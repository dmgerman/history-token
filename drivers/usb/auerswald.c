multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *      auerswald.c  --  Auerswald PBX/System Telephone usb driver.&n; *&n; *      Copyright (C) 2001  Wolfgang M&#xfffd;es (wmues@nexgo.de)&n; *&n; *      Very much code of this driver is borrowed from dabusb.c (Deti Fliegl)&n; *      and from the USB Skeleton driver (Greg Kroah-Hartman). Thank you.&n; *&n; *      This program is free software; you can redistribute it and/or modify&n; *      it under the terms of the GNU General Public License as published by&n; *      the Free Software Foundation; either version 2 of the License, or&n; *      (at your option) any later version.&n; *&n; *      This program is distributed in the hope that it will be useful,&n; *      but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *      GNU General Public License for more details.&n; *&n; *      You should have received a copy of the GNU General Public License&n; *      along with this program; if not, write to the Free Software&n; *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
multiline_comment|/*****************************************************************************/
multiline_comment|/* Standard Linux module include files */
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
DECL|macro|DEBUG
macro_line|#undef DEBUG   &t;&t;/* include debug macros until it&squot;s done&t;*/
macro_line|#include &lt;linux/usb.h&gt;
multiline_comment|/*-------------------------------------------------------------------*/
multiline_comment|/* Debug support &t;&t;&t;&t;&t;&t;     */
macro_line|#ifdef DEBUG
DECL|macro|dump
mdefine_line|#define dump( adr, len) &bslash;&n;do {&t;&t;&t;&bslash;&n;&t;unsigned int u;&t;&bslash;&n;&t;printk (KERN_DEBUG); &bslash;&n;&t;for (u = 0; u &lt; len; u++) &bslash;&n;&t;&t;printk (&quot; %02X&quot;, adr[u] &amp; 0xFF); &bslash;&n;&t;printk (&quot;&bslash;n&quot;); &bslash;&n;} while (0)
macro_line|#else
DECL|macro|dump
mdefine_line|#define dump( adr, len)
macro_line|#endif
multiline_comment|/*-------------------------------------------------------------------*/
multiline_comment|/* Version Information */
DECL|macro|DRIVER_VERSION
mdefine_line|#define DRIVER_VERSION &quot;0.9.11&quot;
DECL|macro|DRIVER_AUTHOR
mdefine_line|#define DRIVER_AUTHOR  &quot;Wolfgang M&#xfffd;es &lt;wmues@nexgo.de&gt;&quot;
DECL|macro|DRIVER_DESC
mdefine_line|#define DRIVER_DESC    &quot;Auerswald PBX/System Telephone usb driver&quot;
multiline_comment|/*-------------------------------------------------------------------*/
multiline_comment|/* Private declarations for Auerswald USB driver                     */
multiline_comment|/* Auerswald Vendor ID */
DECL|macro|ID_AUERSWALD
mdefine_line|#define ID_AUERSWALD  &t;0x09BF
macro_line|#ifndef AUER_MINOR_BASE&t;&t;/* allow external override */
DECL|macro|AUER_MINOR_BASE
mdefine_line|#define AUER_MINOR_BASE&t;80&t;/* auerswald driver minor number */
macro_line|#endif
multiline_comment|/* we can have up to this number of device plugged in at once */
DECL|macro|AUER_MAX_DEVICES
mdefine_line|#define AUER_MAX_DEVICES 16
multiline_comment|/* prefix for the device descriptors in /dev/usb */
DECL|macro|AU_PREFIX
mdefine_line|#define AU_PREFIX&t;&quot;auer&quot;
multiline_comment|/* Number of read buffers for each device */
DECL|macro|AU_RBUFFERS
mdefine_line|#define AU_RBUFFERS     10
multiline_comment|/* Number of chain elements for each control chain */
DECL|macro|AUCH_ELEMENTS
mdefine_line|#define AUCH_ELEMENTS   20
multiline_comment|/* Number of retries in communication */
DECL|macro|AU_RETRIES
mdefine_line|#define AU_RETRIES&t;10
multiline_comment|/*-------------------------------------------------------------------*/
multiline_comment|/* vendor specific protocol                                          */
multiline_comment|/* Header Byte */
DECL|macro|AUH_INDIRMASK
mdefine_line|#define AUH_INDIRMASK   0x80    /* mask for direct/indirect bit */
DECL|macro|AUH_DIRECT
mdefine_line|#define AUH_DIRECT      0x00    /* data is for USB device */
DECL|macro|AUH_INDIRECT
mdefine_line|#define AUH_INDIRECT    0x80    /* USB device is relay */
DECL|macro|AUH_SPLITMASK
mdefine_line|#define AUH_SPLITMASK   0x40    /* mask for split bit */
DECL|macro|AUH_UNSPLIT
mdefine_line|#define AUH_UNSPLIT     0x00    /* data block is full-size */
DECL|macro|AUH_SPLIT
mdefine_line|#define AUH_SPLIT       0x40    /* data block is part of a larger one,&n;                                   split-byte follows */
DECL|macro|AUH_TYPEMASK
mdefine_line|#define AUH_TYPEMASK    0x3F    /* mask for type of data transfer */
DECL|macro|AUH_TYPESIZE
mdefine_line|#define AUH_TYPESIZE    0x40    /* different types */
DECL|macro|AUH_DCHANNEL
mdefine_line|#define AUH_DCHANNEL    0x00    /* D channel data */
DECL|macro|AUH_B1CHANNEL
mdefine_line|#define AUH_B1CHANNEL   0x01    /* B1 channel transparent */
DECL|macro|AUH_B2CHANNEL
mdefine_line|#define AUH_B2CHANNEL   0x02    /* B2 channel transparent */
multiline_comment|/*                0x03..0x0F       reserved for driver internal use */
DECL|macro|AUH_COMMAND
mdefine_line|#define AUH_COMMAND     0x10    /* Command channel */
DECL|macro|AUH_BPROT
mdefine_line|#define AUH_BPROT       0x11    /* Configuration block protocol */
DECL|macro|AUH_DPROTANA
mdefine_line|#define AUH_DPROTANA    0x12    /* D channel protocol analyzer */
DECL|macro|AUH_TAPI
mdefine_line|#define AUH_TAPI        0x13    /* telephone api data (ATD) */
multiline_comment|/*                0x14..0x3F       reserved for other protocols */
DECL|macro|AUH_UNASSIGNED
mdefine_line|#define AUH_UNASSIGNED  0xFF    /* if char device has no assigned service */
DECL|macro|AUH_FIRSTUSERCH
mdefine_line|#define AUH_FIRSTUSERCH 0x11    /* first channel which is available for driver users */
DECL|macro|AUH_SIZE
mdefine_line|#define AUH_SIZE&t;1 &t;/* Size of Header Byte */
multiline_comment|/* Split Byte. Only present if split bit in header byte set.*/
DECL|macro|AUS_STARTMASK
mdefine_line|#define AUS_STARTMASK   0x80    /* mask for first block of splitted frame */
DECL|macro|AUS_FIRST
mdefine_line|#define AUS_FIRST       0x80    /* first block */
DECL|macro|AUS_FOLLOW
mdefine_line|#define AUS_FOLLOW      0x00    /* following block */
DECL|macro|AUS_ENDMASK
mdefine_line|#define AUS_ENDMASK     0x40    /* mask for last block of splitted frame */
DECL|macro|AUS_END
mdefine_line|#define AUS_END         0x40    /* last block */
DECL|macro|AUS_NOEND
mdefine_line|#define AUS_NOEND       0x00    /* not the last block */
DECL|macro|AUS_LENMASK
mdefine_line|#define AUS_LENMASK     0x3F    /* mask for block length information */
multiline_comment|/* Request types */
DECL|macro|AUT_RREQ
mdefine_line|#define AUT_RREQ        (USB_DIR_IN  | USB_TYPE_VENDOR | USB_RECIP_OTHER)   /* Read Request */
DECL|macro|AUT_WREQ
mdefine_line|#define AUT_WREQ        (USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_OTHER)   /* Write Request */
multiline_comment|/* Vendor Requests */
DECL|macro|AUV_GETINFO
mdefine_line|#define AUV_GETINFO     0x00    /* GetDeviceInfo */
DECL|macro|AUV_WBLOCK
mdefine_line|#define AUV_WBLOCK      0x01    /* Write Block */
DECL|macro|AUV_RBLOCK
mdefine_line|#define AUV_RBLOCK      0x02    /* Read Block */
DECL|macro|AUV_CHANNELCTL
mdefine_line|#define AUV_CHANNELCTL  0x03    /* Channel Control */
DECL|macro|AUV_DUMMY
mdefine_line|#define AUV_DUMMY&t;0x04&t;/* Dummy Out for retry */
multiline_comment|/* Device Info Types */
DECL|macro|AUDI_NUMBCH
mdefine_line|#define AUDI_NUMBCH     0x0000  /* Number of supported B channels */
DECL|macro|AUDI_OUTFSIZE
mdefine_line|#define AUDI_OUTFSIZE   0x0001  /* Size of OUT B channel fifos */
DECL|macro|AUDI_MBCTRANS
mdefine_line|#define AUDI_MBCTRANS   0x0002  /* max. Blocklength of control transfer */
multiline_comment|/* Interrupt endpoint definitions */
DECL|macro|AU_IRQENDP
mdefine_line|#define AU_IRQENDP      1       /* Endpoint number */
DECL|macro|AU_IRQCMDID
mdefine_line|#define AU_IRQCMDID     16      /* Command-block ID */
DECL|macro|AU_BLOCKRDY
mdefine_line|#define AU_BLOCKRDY     0       /* Command: Block data ready on ctl endpoint */
DECL|macro|AU_IRQMINSIZE
mdefine_line|#define AU_IRQMINSIZE&t;5&t;/* Nr. of bytes decoded in this driver */
multiline_comment|/* Device String Descriptors */
DECL|macro|AUSI_VENDOR
mdefine_line|#define AUSI_VENDOR   &t;1&t;/* &quot;Auerswald GmbH &amp; Co. KG&quot; */
DECL|macro|AUSI_DEVICE
mdefine_line|#define AUSI_DEVICE   &t;2&t;/* Name of the Device */
DECL|macro|AUSI_SERIALNR
mdefine_line|#define AUSI_SERIALNR &t;3&t;/* Serial Number */
DECL|macro|AUSI_MSN
mdefine_line|#define AUSI_MSN      &t;4&t;/* &quot;MSN ...&quot; (first) Multiple Subscriber Number */
DECL|macro|AUSI_DLEN
mdefine_line|#define AUSI_DLEN&t;100&t;/* Max. Length of Device Description */
DECL|macro|AUV_RETRY
mdefine_line|#define AUV_RETRY&t;0x101&t;/* First Firmware version which can do control retries */
multiline_comment|/*-------------------------------------------------------------------*/
multiline_comment|/* External data structures / Interface                              */
r_typedef
r_struct
(brace
DECL|member|buf
r_char
op_star
id|buf
suffix:semicolon
multiline_comment|/* return buffer for string contents */
DECL|member|bsize
r_int
r_int
id|bsize
suffix:semicolon
multiline_comment|/* size of return buffer */
DECL|typedef|audevinfo_t
DECL|typedef|paudevinfo_t
)brace
id|audevinfo_t
comma
op_star
id|paudevinfo_t
suffix:semicolon
multiline_comment|/* IO controls */
DECL|macro|IOCTL_AU_SLEN
mdefine_line|#define IOCTL_AU_SLEN&t;  _IOR( &squot;U&squot;, 0xF0, int)         /* return the max. string descriptor length */
DECL|macro|IOCTL_AU_DEVINFO
mdefine_line|#define IOCTL_AU_DEVINFO  _IOWR(&squot;U&squot;, 0xF1, audevinfo_t) /* get name of a specific device */
DECL|macro|IOCTL_AU_SERVREQ
mdefine_line|#define IOCTL_AU_SERVREQ  _IOW( &squot;U&squot;, 0xF2, int) &t;/* request a service channel */
DECL|macro|IOCTL_AU_BUFLEN
mdefine_line|#define IOCTL_AU_BUFLEN&t;  _IOR( &squot;U&squot;, 0xF3, int)         /* return the max. buffer length for the device */
DECL|macro|IOCTL_AU_RXAVAIL
mdefine_line|#define IOCTL_AU_RXAVAIL  _IOR( &squot;U&squot;, 0xF4, int)         /* return != 0 if Receive Data available */
DECL|macro|IOCTL_AU_CONNECT
mdefine_line|#define IOCTL_AU_CONNECT  _IOR( &squot;U&squot;, 0xF5, int)         /* return != 0 if connected to a service channel */
DECL|macro|IOCTL_AU_TXREADY
mdefine_line|#define IOCTL_AU_TXREADY  _IOR( &squot;U&squot;, 0xF6, int)         /* return != 0 if Transmitt channel ready to send */
multiline_comment|/*                              &squot;U&squot;  0xF7..0xFF reseved */
multiline_comment|/*-------------------------------------------------------------------*/
multiline_comment|/* Internal data structures                                          */
multiline_comment|/* ..................................................................*/
multiline_comment|/* urb chain element */
r_struct
id|auerchain
suffix:semicolon
multiline_comment|/* forward for circular reference */
r_typedef
r_struct
(brace
DECL|member|chain
r_struct
id|auerchain
op_star
id|chain
suffix:semicolon
multiline_comment|/* pointer to the chain to which this element belongs */
DECL|member|urbp
r_struct
id|urb
op_star
id|urbp
suffix:semicolon
multiline_comment|/* pointer to attached urb */
DECL|member|context
r_void
op_star
id|context
suffix:semicolon
multiline_comment|/* saved URB context */
DECL|member|complete
id|usb_complete_t
id|complete
suffix:semicolon
multiline_comment|/* saved URB completion function */
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
multiline_comment|/* to include element into a list */
DECL|typedef|auerchainelement_t
DECL|typedef|pauerchainelement_t
)brace
id|auerchainelement_t
comma
op_star
id|pauerchainelement_t
suffix:semicolon
multiline_comment|/* urb chain */
DECL|struct|auerchain
r_typedef
r_struct
id|auerchain
(brace
DECL|member|active
id|pauerchainelement_t
id|active
suffix:semicolon
multiline_comment|/* element which is submitted to urb */
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
multiline_comment|/* protection agains interrupts */
DECL|member|waiting_list
r_struct
id|list_head
id|waiting_list
suffix:semicolon
multiline_comment|/* list of waiting elements */
DECL|member|free_list
r_struct
id|list_head
id|free_list
suffix:semicolon
multiline_comment|/* list of available elements */
DECL|typedef|auerchain_t
DECL|typedef|pauerchain_t
)brace
id|auerchain_t
comma
op_star
id|pauerchain_t
suffix:semicolon
multiline_comment|/* urb blocking completion helper struct */
r_typedef
r_struct
(brace
DECL|member|wqh
id|wait_queue_head_t
id|wqh
suffix:semicolon
multiline_comment|/* wait for completion */
DECL|member|done
r_int
r_int
id|done
suffix:semicolon
multiline_comment|/* completion flag */
DECL|typedef|auerchain_chs_t
DECL|typedef|pauerchain_chs_t
)brace
id|auerchain_chs_t
comma
op_star
id|pauerchain_chs_t
suffix:semicolon
multiline_comment|/* ...................................................................*/
multiline_comment|/* buffer element */
r_struct
id|auerbufctl
suffix:semicolon
multiline_comment|/* forward */
r_typedef
r_struct
(brace
DECL|member|bufp
r_char
op_star
id|bufp
suffix:semicolon
multiline_comment|/* reference to allocated data buffer */
DECL|member|len
r_int
r_int
id|len
suffix:semicolon
multiline_comment|/* number of characters in data buffer */
DECL|member|retries
r_int
r_int
id|retries
suffix:semicolon
multiline_comment|/* for urb retries */
DECL|member|dr
r_struct
id|usb_ctrlrequest
op_star
id|dr
suffix:semicolon
multiline_comment|/* for setup data in control messages */
DECL|member|urbp
r_struct
id|urb
op_star
id|urbp
suffix:semicolon
multiline_comment|/* USB urb */
DECL|member|list
r_struct
id|auerbufctl
op_star
id|list
suffix:semicolon
multiline_comment|/* pointer to list */
DECL|member|buff_list
r_struct
id|list_head
id|buff_list
suffix:semicolon
multiline_comment|/* reference to next buffer in list */
DECL|typedef|auerbuf_t
DECL|typedef|pauerbuf_t
)brace
id|auerbuf_t
comma
op_star
id|pauerbuf_t
suffix:semicolon
multiline_comment|/* buffer list control block */
DECL|struct|auerbufctl
r_typedef
r_struct
id|auerbufctl
(brace
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
multiline_comment|/* protection in interrupt */
DECL|member|free_buff_list
r_struct
id|list_head
id|free_buff_list
suffix:semicolon
multiline_comment|/* free buffers */
DECL|member|rec_buff_list
r_struct
id|list_head
id|rec_buff_list
suffix:semicolon
multiline_comment|/* buffers with receive data */
DECL|typedef|auerbufctl_t
DECL|typedef|pauerbufctl_t
)brace
id|auerbufctl_t
comma
op_star
id|pauerbufctl_t
suffix:semicolon
multiline_comment|/* ...................................................................*/
multiline_comment|/* service context */
r_struct
id|auerscon
suffix:semicolon
multiline_comment|/* forward */
DECL|typedef|auer_dispatch_t
r_typedef
r_void
(paren
op_star
id|auer_dispatch_t
)paren
(paren
r_struct
id|auerscon
op_star
comma
id|pauerbuf_t
)paren
suffix:semicolon
DECL|typedef|auer_disconn_t
r_typedef
r_void
(paren
op_star
id|auer_disconn_t
)paren
(paren
r_struct
id|auerscon
op_star
)paren
suffix:semicolon
DECL|struct|auerscon
r_typedef
r_struct
id|auerscon
(brace
DECL|member|id
r_int
r_int
id|id
suffix:semicolon
multiline_comment|/* protocol service id AUH_xxxx */
DECL|member|dispatch
id|auer_dispatch_t
id|dispatch
suffix:semicolon
multiline_comment|/* dispatch read buffer */
DECL|member|disconnect
id|auer_disconn_t
id|disconnect
suffix:semicolon
multiline_comment|/* disconnect from device, wake up all char readers */
DECL|typedef|auerscon_t
DECL|typedef|pauerscon_t
)brace
id|auerscon_t
comma
op_star
id|pauerscon_t
suffix:semicolon
multiline_comment|/* ...................................................................*/
multiline_comment|/* USB device context */
r_typedef
r_struct
(brace
DECL|member|mutex
r_struct
id|semaphore
id|mutex
suffix:semicolon
multiline_comment|/* protection in user context */
DECL|member|name
r_char
id|name
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* name of the /dev/usb entry */
DECL|member|dtindex
r_int
r_int
id|dtindex
suffix:semicolon
multiline_comment|/* index in the device table */
DECL|member|devfs
id|devfs_handle_t
id|devfs
suffix:semicolon
multiline_comment|/* devfs device node */
DECL|member|usbdev
r_struct
id|usb_device
op_star
id|usbdev
suffix:semicolon
multiline_comment|/* USB device handle */
DECL|member|open_count
r_int
id|open_count
suffix:semicolon
multiline_comment|/* count the number of open character channels */
DECL|member|dev_desc
r_char
id|dev_desc
(braket
id|AUSI_DLEN
)braket
suffix:semicolon
multiline_comment|/* for storing a textual description */
DECL|member|maxControlLength
r_int
r_int
id|maxControlLength
suffix:semicolon
multiline_comment|/* max. Length of control paket (without header) */
DECL|member|inturbp
r_struct
id|urb
op_star
id|inturbp
suffix:semicolon
multiline_comment|/* interrupt urb */
DECL|member|intbufp
r_char
op_star
id|intbufp
suffix:semicolon
multiline_comment|/* data buffer for interrupt urb */
DECL|member|irqsize
r_int
r_int
id|irqsize
suffix:semicolon
multiline_comment|/* size of interrupt endpoint 1 */
DECL|member|controlchain
r_struct
id|auerchain
id|controlchain
suffix:semicolon
multiline_comment|/* for chaining of control messages */
DECL|member|bufctl
id|auerbufctl_t
id|bufctl
suffix:semicolon
multiline_comment|/* Buffer control for control transfers */
DECL|member|services
id|pauerscon_t
id|services
(braket
id|AUH_TYPESIZE
)braket
suffix:semicolon
multiline_comment|/* context pointers for each service */
DECL|member|version
r_int
r_int
id|version
suffix:semicolon
multiline_comment|/* Version of the device */
DECL|member|bufferwait
id|wait_queue_head_t
id|bufferwait
suffix:semicolon
multiline_comment|/* wait for a control buffer */
DECL|typedef|auerswald_t
DECL|typedef|pauerswald_t
)brace
id|auerswald_t
comma
op_star
id|pauerswald_t
suffix:semicolon
multiline_comment|/* the global usb devfs handle */
r_extern
id|devfs_handle_t
id|usb_devfs_handle
suffix:semicolon
multiline_comment|/* array of pointers to our devices that are currently connected */
DECL|variable|dev_table
r_static
id|pauerswald_t
id|dev_table
(braket
id|AUER_MAX_DEVICES
)braket
suffix:semicolon
multiline_comment|/* lock to protect the dev_table structure */
DECL|variable|dev_table_mutex
r_static
r_struct
id|semaphore
id|dev_table_mutex
suffix:semicolon
multiline_comment|/* ................................................................... */
multiline_comment|/* character device context */
r_typedef
r_struct
(brace
DECL|member|mutex
r_struct
id|semaphore
id|mutex
suffix:semicolon
multiline_comment|/* protection in user context */
DECL|member|auerdev
id|pauerswald_t
id|auerdev
suffix:semicolon
multiline_comment|/* context pointer of assigned device */
DECL|member|bufctl
id|auerbufctl_t
id|bufctl
suffix:semicolon
multiline_comment|/* controls the buffer chain */
DECL|member|scontext
id|auerscon_t
id|scontext
suffix:semicolon
multiline_comment|/* service context */
DECL|member|readwait
id|wait_queue_head_t
id|readwait
suffix:semicolon
multiline_comment|/* for synchronous reading */
DECL|member|readmutex
r_struct
id|semaphore
id|readmutex
suffix:semicolon
multiline_comment|/* protection against multiple reads */
DECL|member|readbuf
id|pauerbuf_t
id|readbuf
suffix:semicolon
multiline_comment|/* buffer held for partial reading */
DECL|member|readoffset
r_int
r_int
id|readoffset
suffix:semicolon
multiline_comment|/* current offset in readbuf */
DECL|member|removed
r_int
r_int
id|removed
suffix:semicolon
multiline_comment|/* is != 0 if device is removed */
DECL|typedef|auerchar_t
DECL|typedef|pauerchar_t
)brace
id|auerchar_t
comma
op_star
id|pauerchar_t
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------*/
multiline_comment|/* Forwards */
r_static
r_void
id|auerswald_ctrlread_complete
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
r_static
r_void
id|auerswald_removeservice
(paren
id|pauerswald_t
id|cp
comma
id|pauerscon_t
id|scp
)paren
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------*/
multiline_comment|/* USB chain helper functions                                        */
multiline_comment|/* --------------------------                                        */
multiline_comment|/* completion function for chained urbs */
DECL|function|auerchain_complete
r_static
r_void
id|auerchain_complete
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|result
suffix:semicolon
multiline_comment|/* get pointer to element and to chain */
id|pauerchainelement_t
id|acep
op_assign
(paren
id|pauerchainelement_t
)paren
id|urb-&gt;context
suffix:semicolon
id|pauerchain_t
id|acp
op_assign
id|acep-&gt;chain
suffix:semicolon
multiline_comment|/* restore original entries in urb */
id|urb-&gt;context
op_assign
id|acep-&gt;context
suffix:semicolon
id|urb-&gt;complete
op_assign
id|acep-&gt;complete
suffix:semicolon
id|dbg
(paren
l_string|&quot;auerchain_complete called&quot;
)paren
suffix:semicolon
multiline_comment|/* call original completion function&n;           NOTE: this function may lead to more urbs submitted into the chain.&n;                 (no chain lock at calling complete()!)&n;                 acp-&gt;active != NULL is protecting us against recursion.*/
id|urb-&gt;complete
(paren
id|urb
)paren
suffix:semicolon
multiline_comment|/* detach element from chain data structure */
id|spin_lock_irqsave
(paren
op_amp
id|acp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acp-&gt;active
op_ne
id|acep
)paren
multiline_comment|/* paranoia debug check */
id|dbg
(paren
l_string|&quot;auerchain_complete: completion on non-active element called!&quot;
)paren
suffix:semicolon
r_else
id|acp-&gt;active
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* add the used chain element to the list of free elements */
id|list_add_tail
(paren
op_amp
id|acep-&gt;list
comma
op_amp
id|acp-&gt;free_list
)paren
suffix:semicolon
id|acep
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* is there a new element waiting in the chain? */
r_if
c_cond
(paren
op_logical_neg
id|acp-&gt;active
op_logical_and
op_logical_neg
id|list_empty
(paren
op_amp
id|acp-&gt;waiting_list
)paren
)paren
(brace
multiline_comment|/* yes: get the entry */
r_struct
id|list_head
op_star
id|tmp
op_assign
id|acp-&gt;waiting_list.next
suffix:semicolon
id|list_del
(paren
id|tmp
)paren
suffix:semicolon
id|acep
op_assign
id|list_entry
(paren
id|tmp
comma
id|auerchainelement_t
comma
id|list
)paren
suffix:semicolon
id|acp-&gt;active
op_assign
id|acep
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|acp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* submit the new urb */
r_if
c_cond
(paren
id|acep
)paren
(brace
id|urb
op_assign
id|acep-&gt;urbp
suffix:semicolon
id|dbg
(paren
l_string|&quot;auerchain_complete: submitting next urb from chain&quot;
)paren
suffix:semicolon
id|urb-&gt;status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* needed! */
id|result
op_assign
id|usb_submit_urb
c_func
(paren
id|urb
comma
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/* check for submit errors */
r_if
c_cond
(paren
id|result
)paren
(brace
id|urb-&gt;status
op_assign
id|result
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;auerchain_complete: usb_submit_urb with error code %d&quot;
comma
id|result
)paren
suffix:semicolon
multiline_comment|/* and do error handling via *this* completion function (recursive) */
id|auerchain_complete
c_func
(paren
id|urb
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* simple return without submitting a new urb.&n;                   The empty chain is detected with acp-&gt;active == NULL. */
)brace
suffix:semicolon
)brace
multiline_comment|/* submit function for chained urbs&n;   this function may be called from completion context or from user space!&n;   early = 1 -&gt; submit in front of chain&n;*/
DECL|function|auerchain_submit_urb_list
r_static
r_int
id|auerchain_submit_urb_list
(paren
id|pauerchain_t
id|acp
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|early
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|pauerchainelement_t
id|acep
op_assign
l_int|NULL
suffix:semicolon
id|dbg
(paren
l_string|&quot;auerchain_submit_urb called&quot;
)paren
suffix:semicolon
multiline_comment|/* try to get a chain element */
id|spin_lock_irqsave
(paren
op_amp
id|acp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|acp-&gt;free_list
)paren
)paren
(brace
multiline_comment|/* yes: get the entry */
r_struct
id|list_head
op_star
id|tmp
op_assign
id|acp-&gt;free_list.next
suffix:semicolon
id|list_del
(paren
id|tmp
)paren
suffix:semicolon
id|acep
op_assign
id|list_entry
(paren
id|tmp
comma
id|auerchainelement_t
comma
id|list
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|acp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* if no chain element available: return with error */
r_if
c_cond
(paren
op_logical_neg
id|acep
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* fill in the new chain element values */
id|acep-&gt;chain
op_assign
id|acp
suffix:semicolon
id|acep-&gt;context
op_assign
id|urb-&gt;context
suffix:semicolon
id|acep-&gt;complete
op_assign
id|urb-&gt;complete
suffix:semicolon
id|acep-&gt;urbp
op_assign
id|urb
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|acep-&gt;list
)paren
suffix:semicolon
multiline_comment|/* modify urb */
id|urb-&gt;context
op_assign
id|acep
suffix:semicolon
id|urb-&gt;complete
op_assign
id|auerchain_complete
suffix:semicolon
id|urb-&gt;status
op_assign
op_minus
id|EINPROGRESS
suffix:semicolon
multiline_comment|/* usb_submit_urb does this, too */
multiline_comment|/* add element to chain - or start it immediately */
id|spin_lock_irqsave
(paren
op_amp
id|acp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acp-&gt;active
)paren
(brace
multiline_comment|/* there is traffic in the chain, simple add element to chain */
r_if
c_cond
(paren
id|early
)paren
(brace
id|dbg
(paren
l_string|&quot;adding new urb to head of chain&quot;
)paren
suffix:semicolon
id|list_add
(paren
op_amp
id|acep-&gt;list
comma
op_amp
id|acp-&gt;waiting_list
)paren
suffix:semicolon
)brace
r_else
(brace
id|dbg
(paren
l_string|&quot;adding new urb to end of chain&quot;
)paren
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|acep-&gt;list
comma
op_amp
id|acp-&gt;waiting_list
)paren
suffix:semicolon
)brace
id|acep
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* the chain is empty. Prepare restart */
id|acp-&gt;active
op_assign
id|acep
suffix:semicolon
)brace
multiline_comment|/* Spin has to be removed before usb_submit_urb! */
id|spin_unlock_irqrestore
(paren
op_amp
id|acp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Submit urb if immediate restart */
r_if
c_cond
(paren
id|acep
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;submitting urb immediate&quot;
)paren
suffix:semicolon
id|urb-&gt;status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* needed! */
id|result
op_assign
id|usb_submit_urb
c_func
(paren
id|urb
comma
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/* check for submit errors */
r_if
c_cond
(paren
id|result
)paren
(brace
id|urb-&gt;status
op_assign
id|result
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;auerchain_submit_urb: usb_submit_urb with error code %d&quot;
comma
id|result
)paren
suffix:semicolon
multiline_comment|/* and do error handling via completion function */
id|auerchain_complete
c_func
(paren
id|urb
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* submit function for chained urbs&n;   this function may be called from completion context or from user space!&n;*/
DECL|function|auerchain_submit_urb
r_static
r_int
id|auerchain_submit_urb
(paren
id|pauerchain_t
id|acp
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_return
id|auerchain_submit_urb_list
(paren
id|acp
comma
id|urb
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* cancel an urb which is submitted to the chain&n;   the result is 0 if the urb is cancelled, or -EINPROGRESS if&n;   USB_ASYNC_UNLINK is set and the function is successfully started.&n;*/
DECL|function|auerchain_unlink_urb
r_static
r_int
id|auerchain_unlink_urb
(paren
id|pauerchain_t
id|acp
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|urb
op_star
id|urbp
suffix:semicolon
id|pauerchainelement_t
id|acep
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|dbg
(paren
l_string|&quot;auerchain_unlink_urb called&quot;
)paren
suffix:semicolon
multiline_comment|/* search the chain of waiting elements */
id|spin_lock_irqsave
(paren
op_amp
id|acp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|list_for_each
(paren
id|tmp
comma
op_amp
id|acp-&gt;waiting_list
)paren
(brace
id|acep
op_assign
id|list_entry
(paren
id|tmp
comma
id|auerchainelement_t
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acep-&gt;urbp
op_eq
id|urb
)paren
(brace
id|list_del
(paren
id|tmp
)paren
suffix:semicolon
id|urb-&gt;context
op_assign
id|acep-&gt;context
suffix:semicolon
id|urb-&gt;complete
op_assign
id|acep-&gt;complete
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|acep-&gt;list
comma
op_amp
id|acp-&gt;free_list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|acp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|dbg
(paren
l_string|&quot;unlink waiting urb&quot;
)paren
suffix:semicolon
id|urb-&gt;status
op_assign
op_minus
id|ENOENT
suffix:semicolon
id|urb-&gt;complete
(paren
id|urb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* not found. */
id|spin_unlock_irqrestore
(paren
op_amp
id|acp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* get the active urb */
id|acep
op_assign
id|acp-&gt;active
suffix:semicolon
r_if
c_cond
(paren
id|acep
)paren
(brace
id|urbp
op_assign
id|acep-&gt;urbp
suffix:semicolon
multiline_comment|/* check if we have to cancel the active urb */
r_if
c_cond
(paren
id|urbp
op_eq
id|urb
)paren
(brace
multiline_comment|/* note that there is a race condition between the check above&n;                           and the unlink() call because of no lock. This race is harmless,&n;                           because the usb module will detect the unlink() after completion.&n;                           We can&squot;t use the acp-&gt;lock here because the completion function&n;                           wants to grab it.&n;&t;&t;&t;*/
id|dbg
(paren
l_string|&quot;unlink active urb&quot;
)paren
suffix:semicolon
r_return
id|usb_unlink_urb
(paren
id|urbp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* not found anyway&n;           ... is some kind of success&n;&t;*/
id|dbg
(paren
l_string|&quot;urb to unlink not found in chain&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* cancel all urbs which are in the chain.&n;   this function must not be called from interrupt or completion handler.&n;*/
DECL|function|auerchain_unlink_all
r_static
r_void
id|auerchain_unlink_all
(paren
id|pauerchain_t
id|acp
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|urb
op_star
id|urbp
suffix:semicolon
id|pauerchainelement_t
id|acep
suffix:semicolon
id|dbg
(paren
l_string|&quot;auerchain_unlink_all called&quot;
)paren
suffix:semicolon
multiline_comment|/* clear the chain of waiting elements */
id|spin_lock_irqsave
(paren
op_amp
id|acp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|acp-&gt;waiting_list
)paren
)paren
(brace
multiline_comment|/* get the next entry */
r_struct
id|list_head
op_star
id|tmp
op_assign
id|acp-&gt;waiting_list.next
suffix:semicolon
id|list_del
(paren
id|tmp
)paren
suffix:semicolon
id|acep
op_assign
id|list_entry
(paren
id|tmp
comma
id|auerchainelement_t
comma
id|list
)paren
suffix:semicolon
id|urbp
op_assign
id|acep-&gt;urbp
suffix:semicolon
id|urbp-&gt;context
op_assign
id|acep-&gt;context
suffix:semicolon
id|urbp-&gt;complete
op_assign
id|acep-&gt;complete
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|acep-&gt;list
comma
op_amp
id|acp-&gt;free_list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|acp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|dbg
(paren
l_string|&quot;unlink waiting urb&quot;
)paren
suffix:semicolon
id|urbp-&gt;status
op_assign
op_minus
id|ENOENT
suffix:semicolon
id|urbp-&gt;complete
(paren
id|urbp
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|acp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|acp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* clear the active urb */
id|acep
op_assign
id|acp-&gt;active
suffix:semicolon
r_if
c_cond
(paren
id|acep
)paren
(brace
id|urbp
op_assign
id|acep-&gt;urbp
suffix:semicolon
id|urbp-&gt;transfer_flags
op_and_assign
op_complement
id|USB_ASYNC_UNLINK
suffix:semicolon
id|dbg
(paren
l_string|&quot;unlink active urb&quot;
)paren
suffix:semicolon
id|usb_unlink_urb
(paren
id|urbp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* free the chain.&n;   this function must not be called from interrupt or completion handler.&n;*/
DECL|function|auerchain_free
r_static
r_void
id|auerchain_free
(paren
id|pauerchain_t
id|acp
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|pauerchainelement_t
id|acep
suffix:semicolon
id|dbg
(paren
l_string|&quot;auerchain_free called&quot;
)paren
suffix:semicolon
multiline_comment|/* first, cancel all pending urbs */
id|auerchain_unlink_all
(paren
id|acp
)paren
suffix:semicolon
multiline_comment|/* free the elements */
id|spin_lock_irqsave
(paren
op_amp
id|acp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|acp-&gt;free_list
)paren
)paren
(brace
multiline_comment|/* get the next entry */
r_struct
id|list_head
op_star
id|tmp
op_assign
id|acp-&gt;free_list.next
suffix:semicolon
id|list_del
(paren
id|tmp
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|acp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|acep
op_assign
id|list_entry
(paren
id|tmp
comma
id|auerchainelement_t
comma
id|list
)paren
suffix:semicolon
id|kfree
(paren
id|acep
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|acp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|acp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* Init the chain control structure */
DECL|function|auerchain_init
r_static
r_void
id|auerchain_init
(paren
id|pauerchain_t
id|acp
)paren
(brace
multiline_comment|/* init the chain data structure */
id|acp-&gt;active
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock_init
(paren
op_amp
id|acp-&gt;lock
)paren
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|acp-&gt;waiting_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|acp-&gt;free_list
)paren
suffix:semicolon
)brace
multiline_comment|/* setup a chain.&n;   It is assumed that there is no concurrency while setting up the chain&n;   requirement: auerchain_init()&n;*/
DECL|function|auerchain_setup
r_static
r_int
id|auerchain_setup
(paren
id|pauerchain_t
id|acp
comma
r_int
r_int
id|numElements
)paren
(brace
id|pauerchainelement_t
id|acep
suffix:semicolon
id|dbg
(paren
l_string|&quot;auerchain_setup called with %d elements&quot;
comma
id|numElements
)paren
suffix:semicolon
multiline_comment|/* fill the list of free elements */
r_for
c_loop
(paren
suffix:semicolon
id|numElements
suffix:semicolon
id|numElements
op_decrement
)paren
(brace
id|acep
op_assign
(paren
id|pauerchainelement_t
)paren
id|kmalloc
(paren
r_sizeof
(paren
id|auerchainelement_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acep
)paren
r_goto
id|ac_fail
suffix:semicolon
id|memset
(paren
id|acep
comma
l_int|0
comma
r_sizeof
(paren
id|auerchainelement_t
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|acep-&gt;list
)paren
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|acep-&gt;list
comma
op_amp
id|acp-&gt;free_list
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|ac_fail
suffix:colon
multiline_comment|/* free the elements */
r_while
c_loop
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|acp-&gt;free_list
)paren
)paren
(brace
multiline_comment|/* get the next entry */
r_struct
id|list_head
op_star
id|tmp
op_assign
id|acp-&gt;free_list.next
suffix:semicolon
id|list_del
(paren
id|tmp
)paren
suffix:semicolon
id|acep
op_assign
id|list_entry
(paren
id|tmp
comma
id|auerchainelement_t
comma
id|list
)paren
suffix:semicolon
id|kfree
(paren
id|acep
)paren
suffix:semicolon
)brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* completion handler for synchronous chained URBs */
DECL|function|auerchain_blocking_completion
r_static
r_void
id|auerchain_blocking_completion
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
id|pauerchain_chs_t
id|pchs
op_assign
(paren
id|pauerchain_chs_t
)paren
id|urb-&gt;context
suffix:semicolon
id|pchs-&gt;done
op_assign
l_int|1
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|wake_up
(paren
op_amp
id|pchs-&gt;wqh
)paren
suffix:semicolon
)brace
multiline_comment|/* Starts chained urb and waits for completion or timeout */
DECL|function|auerchain_start_wait_urb
r_static
r_int
id|auerchain_start_wait_urb
(paren
id|pauerchain_t
id|acp
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|timeout
comma
r_int
op_star
id|actual_length
)paren
(brace
id|DECLARE_WAITQUEUE
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|auerchain_chs_t
id|chs
suffix:semicolon
r_int
id|status
suffix:semicolon
id|dbg
(paren
l_string|&quot;auerchain_start_wait_urb called&quot;
)paren
suffix:semicolon
id|init_waitqueue_head
(paren
op_amp
id|chs.wqh
)paren
suffix:semicolon
id|chs.done
op_assign
l_int|0
suffix:semicolon
id|set_current_state
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue
(paren
op_amp
id|chs.wqh
comma
op_amp
id|wait
)paren
suffix:semicolon
id|urb-&gt;context
op_assign
op_amp
id|chs
suffix:semicolon
id|status
op_assign
id|auerchain_submit_urb
(paren
id|acp
comma
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
multiline_comment|/* something went wrong */
id|set_current_state
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
(paren
op_amp
id|chs.wqh
comma
op_amp
id|wait
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
r_while
c_loop
(paren
id|timeout
op_logical_and
op_logical_neg
id|chs.done
)paren
(brace
id|timeout
op_assign
id|schedule_timeout
(paren
id|timeout
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|rmb
c_func
(paren
)paren
suffix:semicolon
)brace
id|set_current_state
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
(paren
op_amp
id|chs.wqh
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timeout
op_logical_and
op_logical_neg
id|chs.done
)paren
(brace
r_if
c_cond
(paren
id|urb-&gt;status
op_ne
op_minus
id|EINPROGRESS
)paren
(brace
multiline_comment|/* No callback?!! */
id|dbg
(paren
l_string|&quot;auerchain_start_wait_urb: raced timeout&quot;
)paren
suffix:semicolon
id|status
op_assign
id|urb-&gt;status
suffix:semicolon
)brace
r_else
(brace
id|dbg
(paren
l_string|&quot;auerchain_start_wait_urb: timeout&quot;
)paren
suffix:semicolon
id|auerchain_unlink_urb
(paren
id|acp
comma
id|urb
)paren
suffix:semicolon
multiline_comment|/* remove urb safely */
id|status
op_assign
op_minus
id|ETIMEDOUT
suffix:semicolon
)brace
)brace
r_else
id|status
op_assign
id|urb-&gt;status
suffix:semicolon
r_if
c_cond
(paren
id|actual_length
)paren
op_star
id|actual_length
op_assign
id|urb-&gt;actual_length
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/* auerchain_control_msg - Builds a control urb, sends it off and waits for completion&n;   acp: pointer to the auerchain&n;   dev: pointer to the usb device to send the message to&n;   pipe: endpoint &quot;pipe&quot; to send the message to&n;   request: USB message request value&n;   requesttype: USB message request type value&n;   value: USB message value&n;   index: USB message index value&n;   data: pointer to the data to send&n;   size: length in bytes of the data to send&n;   timeout: time to wait for the message to complete before timing out (if 0 the wait is forever)&n;&n;   This function sends a simple control message to a specified endpoint&n;   and waits for the message to complete, or timeout.&n;&n;   If successful, it returns the transfered length, othwise a negative error number.&n;&n;   Don&squot;t use this function from within an interrupt context, like a&n;   bottom half handler.  If you need a asyncronous message, or need to send&n;   a message from within interrupt context, use auerchain_submit_urb()&n;*/
DECL|function|auerchain_control_msg
r_static
r_int
id|auerchain_control_msg
(paren
id|pauerchain_t
id|acp
comma
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|pipe
comma
id|__u8
id|request
comma
id|__u8
id|requesttype
comma
id|__u16
id|value
comma
id|__u16
id|index
comma
r_void
op_star
id|data
comma
id|__u16
id|size
comma
r_int
id|timeout
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|usb_ctrlrequest
op_star
id|dr
suffix:semicolon
r_struct
id|urb
op_star
id|urb
suffix:semicolon
r_int
id|length
suffix:semicolon
id|dbg
(paren
l_string|&quot;auerchain_control_msg&quot;
)paren
suffix:semicolon
id|dr
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|usb_ctrlrequest
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dr
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|urb
op_assign
id|usb_alloc_urb
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
(brace
id|kfree
(paren
id|dr
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|dr-&gt;bRequestType
op_assign
id|requesttype
suffix:semicolon
id|dr-&gt;bRequest
op_assign
id|request
suffix:semicolon
id|dr-&gt;wValue
op_assign
id|cpu_to_le16
(paren
id|value
)paren
suffix:semicolon
id|dr-&gt;wIndex
op_assign
id|cpu_to_le16
(paren
id|index
)paren
suffix:semicolon
id|dr-&gt;wLength
op_assign
id|cpu_to_le16
(paren
id|size
)paren
suffix:semicolon
id|FILL_CONTROL_URB
(paren
id|urb
comma
id|dev
comma
id|pipe
comma
(paren
r_int
r_char
op_star
)paren
id|dr
comma
id|data
comma
id|size
comma
multiline_comment|/* build urb */
(paren
id|usb_complete_t
)paren
id|auerchain_blocking_completion
comma
l_int|0
)paren
suffix:semicolon
id|ret
op_assign
id|auerchain_start_wait_urb
(paren
id|acp
comma
id|urb
comma
id|timeout
comma
op_amp
id|length
)paren
suffix:semicolon
id|usb_free_urb
(paren
id|urb
)paren
suffix:semicolon
id|kfree
(paren
id|dr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
r_else
r_return
id|length
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------*/
multiline_comment|/* Buffer List helper functions                                      */
multiline_comment|/* free a single auerbuf */
DECL|function|auerbuf_free
r_static
r_void
id|auerbuf_free
(paren
id|pauerbuf_t
id|bp
)paren
(brace
r_if
c_cond
(paren
id|bp-&gt;bufp
)paren
(brace
id|kfree
(paren
id|bp-&gt;bufp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bp-&gt;dr
)paren
(brace
id|kfree
(paren
id|bp-&gt;dr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bp-&gt;urbp
)paren
(brace
id|usb_free_urb
(paren
id|bp-&gt;urbp
)paren
suffix:semicolon
)brace
id|kfree
(paren
id|bp
)paren
suffix:semicolon
)brace
multiline_comment|/* free the buffers from an auerbuf list */
DECL|function|auerbuf_free_list
r_static
r_void
id|auerbuf_free_list
(paren
r_struct
id|list_head
op_star
id|q
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_struct
id|list_head
op_star
id|p
suffix:semicolon
id|pauerbuf_t
id|bp
suffix:semicolon
id|dbg
(paren
l_string|&quot;auerbuf_free_list&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|q-&gt;next
suffix:semicolon
id|p
op_ne
id|q
suffix:semicolon
)paren
(brace
id|bp
op_assign
id|list_entry
(paren
id|p
comma
id|auerbuf_t
comma
id|buff_list
)paren
suffix:semicolon
id|tmp
op_assign
id|p-&gt;next
suffix:semicolon
id|list_del
(paren
id|p
)paren
suffix:semicolon
id|p
op_assign
id|tmp
suffix:semicolon
id|auerbuf_free
(paren
id|bp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* init the members of a list control block */
DECL|function|auerbuf_init
r_static
r_void
id|auerbuf_init
(paren
id|pauerbufctl_t
id|bcp
)paren
(brace
id|dbg
(paren
l_string|&quot;auerbuf_init&quot;
)paren
suffix:semicolon
id|spin_lock_init
(paren
op_amp
id|bcp-&gt;lock
)paren
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|bcp-&gt;free_buff_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|bcp-&gt;rec_buff_list
)paren
suffix:semicolon
)brace
multiline_comment|/* free all buffers from an auerbuf chain */
DECL|function|auerbuf_free_buffers
r_static
r_void
id|auerbuf_free_buffers
(paren
id|pauerbufctl_t
id|bcp
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|dbg
(paren
l_string|&quot;auerbuf_free_buffers&quot;
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|bcp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|auerbuf_free_list
(paren
op_amp
id|bcp-&gt;free_buff_list
)paren
suffix:semicolon
id|auerbuf_free_list
(paren
op_amp
id|bcp-&gt;rec_buff_list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|bcp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* setup a list of buffers */
multiline_comment|/* requirement: auerbuf_init() */
DECL|function|auerbuf_setup
r_static
r_int
id|auerbuf_setup
(paren
id|pauerbufctl_t
id|bcp
comma
r_int
r_int
id|numElements
comma
r_int
r_int
id|bufsize
)paren
(brace
id|pauerbuf_t
id|bep
suffix:semicolon
id|dbg
(paren
l_string|&quot;auerbuf_setup called with %d elements of %d bytes&quot;
comma
id|numElements
comma
id|bufsize
)paren
suffix:semicolon
multiline_comment|/* fill the list of free elements */
r_for
c_loop
(paren
suffix:semicolon
id|numElements
suffix:semicolon
id|numElements
op_decrement
)paren
(brace
id|bep
op_assign
(paren
id|pauerbuf_t
)paren
id|kmalloc
(paren
r_sizeof
(paren
id|auerbuf_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bep
)paren
r_goto
id|bl_fail
suffix:semicolon
id|memset
(paren
id|bep
comma
l_int|0
comma
r_sizeof
(paren
id|auerbuf_t
)paren
)paren
suffix:semicolon
id|bep-&gt;list
op_assign
id|bcp
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|bep-&gt;buff_list
)paren
suffix:semicolon
id|bep-&gt;bufp
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
(paren
id|bufsize
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bep-&gt;bufp
)paren
r_goto
id|bl_fail
suffix:semicolon
id|bep-&gt;dr
op_assign
(paren
r_struct
id|usb_ctrlrequest
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|usb_ctrlrequest
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bep-&gt;dr
)paren
r_goto
id|bl_fail
suffix:semicolon
id|bep-&gt;urbp
op_assign
id|usb_alloc_urb
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bep-&gt;urbp
)paren
r_goto
id|bl_fail
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|bep-&gt;buff_list
comma
op_amp
id|bcp-&gt;free_buff_list
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|bl_fail
suffix:colon
multiline_comment|/* not enought memory. Free allocated elements */
id|dbg
(paren
l_string|&quot;auerbuf_setup: no more memory&quot;
)paren
suffix:semicolon
id|auerbuf_free_buffers
(paren
id|bcp
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* insert a used buffer into the free list */
DECL|function|auerbuf_releasebuf
r_static
r_void
id|auerbuf_releasebuf
c_func
(paren
id|pauerbuf_t
id|bp
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|pauerbufctl_t
id|bcp
op_assign
id|bp-&gt;list
suffix:semicolon
id|bp-&gt;retries
op_assign
l_int|0
suffix:semicolon
id|dbg
(paren
l_string|&quot;auerbuf_releasebuf called&quot;
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|bcp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|bp-&gt;buff_list
comma
op_amp
id|bcp-&gt;free_buff_list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|bcp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------*/
multiline_comment|/* Completion handlers */
multiline_comment|/* Values of urb-&gt;status or results of usb_submit_urb():&n;0&t;&t;Initial, OK&n;-EINPROGRESS&t;during submission until end&n;-ENOENT&t;&t;if urb is unlinked&n;-ETIMEDOUT&t;Transfer timed out, NAK&n;-ENOMEM&t;&t;Memory Overflow&n;-ENODEV&t;&t;Specified USB-device or bus doesn&squot;t exist&n;-ENXIO&t;&t;URB already queued&n;-EINVAL&t;&t;a) Invalid transfer type specified (or not supported)&n;&t;&t;b) Invalid interrupt interval (0n256)&n;-EAGAIN&t;&t;a) Specified ISO start frame too early&n;&t;&t;b) (using ISO-ASAP) Too much scheduled for the future wait some time and try again.&n;-EFBIG&t;&t;Too much ISO frames requested (currently uhci900)&n;-EPIPE&t;&t;Specified pipe-handle/Endpoint is already stalled&n;-EMSGSIZE&t;Endpoint message size is zero, do interface/alternate setting&n;-EPROTO&t;&t;a) Bitstuff error&n;&t;&t;b) Unknown USB error&n;-EILSEQ&t;&t;CRC mismatch&n;-ENOSR&t;&t;Buffer error&n;-EREMOTEIO&t;Short packet detected&n;-EXDEV&t;&t;ISO transfer only partially completed look at individual frame status for details&n;-EINVAL&t;&t;ISO madness, if this happens: Log off and go home&n;-EOVERFLOW&t;babble&n;*/
multiline_comment|/* check if a status code allows a retry */
DECL|function|auerswald_status_retry
r_static
r_int
id|auerswald_status_retry
(paren
r_int
id|status
)paren
(brace
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
l_int|0
suffix:colon
r_case
op_minus
id|ETIMEDOUT
suffix:colon
r_case
op_minus
id|EOVERFLOW
suffix:colon
r_case
op_minus
id|EAGAIN
suffix:colon
r_case
op_minus
id|EPIPE
suffix:colon
r_case
op_minus
id|EPROTO
suffix:colon
r_case
op_minus
id|EILSEQ
suffix:colon
r_case
op_minus
id|ENOSR
suffix:colon
r_case
op_minus
id|EREMOTEIO
suffix:colon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* do a retry */
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* no retry possible */
)brace
multiline_comment|/* Completion of asynchronous write block */
DECL|function|auerchar_ctrlwrite_complete
r_static
r_void
id|auerchar_ctrlwrite_complete
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
id|pauerbuf_t
id|bp
op_assign
(paren
id|pauerbuf_t
)paren
id|urb-&gt;context
suffix:semicolon
id|pauerswald_t
id|cp
op_assign
(paren
(paren
id|pauerswald_t
)paren
(paren
(paren
r_char
op_star
)paren
(paren
id|bp-&gt;list
)paren
op_minus
(paren
r_int
r_int
)paren
(paren
op_amp
(paren
(paren
id|pauerswald_t
)paren
l_int|0
)paren
op_member_access_from_pointer
id|bufctl
)paren
)paren
)paren
suffix:semicolon
id|dbg
(paren
l_string|&quot;auerchar_ctrlwrite_complete called&quot;
)paren
suffix:semicolon
multiline_comment|/* reuse the buffer */
id|auerbuf_releasebuf
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/* Wake up all processes waiting for a buffer */
id|wake_up
(paren
op_amp
id|cp-&gt;bufferwait
)paren
suffix:semicolon
)brace
multiline_comment|/* Completion handler for dummy retry packet */
DECL|function|auerswald_ctrlread_wretcomplete
r_static
r_void
id|auerswald_ctrlread_wretcomplete
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
id|pauerbuf_t
id|bp
op_assign
(paren
id|pauerbuf_t
)paren
id|urb-&gt;context
suffix:semicolon
id|pauerswald_t
id|cp
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|dbg
(paren
l_string|&quot;auerswald_ctrlread_wretcomplete called&quot;
)paren
suffix:semicolon
id|dbg
(paren
l_string|&quot;complete with status: %d&quot;
comma
id|urb-&gt;status
)paren
suffix:semicolon
id|cp
op_assign
(paren
(paren
id|pauerswald_t
)paren
(paren
(paren
r_char
op_star
)paren
(paren
id|bp-&gt;list
)paren
op_minus
(paren
r_int
r_int
)paren
(paren
op_amp
(paren
(paren
id|pauerswald_t
)paren
l_int|0
)paren
op_member_access_from_pointer
id|bufctl
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* check if it is possible to advance */
r_if
c_cond
(paren
op_logical_neg
id|auerswald_status_retry
(paren
id|urb-&gt;status
)paren
op_logical_or
op_logical_neg
id|cp-&gt;usbdev
)paren
(brace
multiline_comment|/* reuse the buffer */
id|err
(paren
l_string|&quot;control dummy: transmission error %d, can not retry&quot;
comma
id|urb-&gt;status
)paren
suffix:semicolon
id|auerbuf_releasebuf
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/* Wake up all processes waiting for a buffer */
id|wake_up
(paren
op_amp
id|cp-&gt;bufferwait
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* fill the control message */
id|bp-&gt;dr-&gt;bRequestType
op_assign
id|AUT_RREQ
suffix:semicolon
id|bp-&gt;dr-&gt;bRequest
op_assign
id|AUV_RBLOCK
suffix:semicolon
id|bp-&gt;dr-&gt;wLength
op_assign
id|bp-&gt;dr-&gt;wValue
suffix:semicolon
multiline_comment|/* temporary stored */
id|bp-&gt;dr-&gt;wValue
op_assign
id|cpu_to_le16
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Retry Flag */
multiline_comment|/* bp-&gt;dr-&gt;index    = channel id;          remains */
id|FILL_CONTROL_URB
(paren
id|bp-&gt;urbp
comma
id|cp-&gt;usbdev
comma
id|usb_rcvctrlpipe
(paren
id|cp-&gt;usbdev
comma
l_int|0
)paren
comma
(paren
r_int
r_char
op_star
)paren
id|bp-&gt;dr
comma
id|bp-&gt;bufp
comma
id|le16_to_cpu
(paren
id|bp-&gt;dr-&gt;wLength
)paren
comma
(paren
id|usb_complete_t
)paren
id|auerswald_ctrlread_complete
comma
id|bp
)paren
suffix:semicolon
multiline_comment|/* submit the control msg as next paket */
id|ret
op_assign
id|auerchain_submit_urb_list
(paren
op_amp
id|cp-&gt;controlchain
comma
id|bp-&gt;urbp
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|dbg
(paren
l_string|&quot;auerswald_ctrlread_complete: nonzero result of auerchain_submit_urb_list %d&quot;
comma
id|ret
)paren
suffix:semicolon
id|bp-&gt;urbp-&gt;status
op_assign
id|ret
suffix:semicolon
id|auerswald_ctrlread_complete
(paren
id|bp-&gt;urbp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* completion handler for receiving of control messages */
DECL|function|auerswald_ctrlread_complete
r_static
r_void
id|auerswald_ctrlread_complete
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
r_int
id|serviceid
suffix:semicolon
id|pauerswald_t
id|cp
suffix:semicolon
id|pauerscon_t
id|scp
suffix:semicolon
id|pauerbuf_t
id|bp
op_assign
(paren
id|pauerbuf_t
)paren
id|urb-&gt;context
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|dbg
(paren
l_string|&quot;auerswald_ctrlread_complete called&quot;
)paren
suffix:semicolon
id|cp
op_assign
(paren
(paren
id|pauerswald_t
)paren
(paren
(paren
r_char
op_star
)paren
(paren
id|bp-&gt;list
)paren
op_minus
(paren
r_int
r_int
)paren
(paren
op_amp
(paren
(paren
id|pauerswald_t
)paren
l_int|0
)paren
op_member_access_from_pointer
id|bufctl
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* check if there is valid data in this urb */
r_if
c_cond
(paren
id|urb-&gt;status
)paren
(brace
id|dbg
(paren
l_string|&quot;complete with non-zero status: %d&quot;
comma
id|urb-&gt;status
)paren
suffix:semicolon
multiline_comment|/* should we do a retry? */
r_if
c_cond
(paren
op_logical_neg
id|auerswald_status_retry
(paren
id|urb-&gt;status
)paren
op_logical_or
op_logical_neg
id|cp-&gt;usbdev
op_logical_or
(paren
id|cp-&gt;version
OL
id|AUV_RETRY
)paren
op_logical_or
(paren
id|bp-&gt;retries
op_ge
id|AU_RETRIES
)paren
)paren
(brace
multiline_comment|/* reuse the buffer */
id|err
(paren
l_string|&quot;control read: transmission error %d, can not retry&quot;
comma
id|urb-&gt;status
)paren
suffix:semicolon
id|auerbuf_releasebuf
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/* Wake up all processes waiting for a buffer */
id|wake_up
(paren
op_amp
id|cp-&gt;bufferwait
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|bp-&gt;retries
op_increment
suffix:semicolon
id|dbg
(paren
l_string|&quot;Retry count = %d&quot;
comma
id|bp-&gt;retries
)paren
suffix:semicolon
multiline_comment|/* send a long dummy control-write-message to allow device firmware to react */
id|bp-&gt;dr-&gt;bRequestType
op_assign
id|AUT_WREQ
suffix:semicolon
id|bp-&gt;dr-&gt;bRequest
op_assign
id|AUV_DUMMY
suffix:semicolon
id|bp-&gt;dr-&gt;wValue
op_assign
id|bp-&gt;dr-&gt;wLength
suffix:semicolon
multiline_comment|/* temporary storage */
singleline_comment|// bp-&gt;dr-&gt;wIndex    channel ID remains
id|bp-&gt;dr-&gt;wLength
op_assign
id|cpu_to_le16
(paren
l_int|32
)paren
suffix:semicolon
multiline_comment|/* &gt;= 8 bytes */
id|FILL_CONTROL_URB
(paren
id|bp-&gt;urbp
comma
id|cp-&gt;usbdev
comma
id|usb_sndctrlpipe
(paren
id|cp-&gt;usbdev
comma
l_int|0
)paren
comma
(paren
r_int
r_char
op_star
)paren
id|bp-&gt;dr
comma
id|bp-&gt;bufp
comma
l_int|32
comma
(paren
id|usb_complete_t
)paren
id|auerswald_ctrlread_wretcomplete
comma
id|bp
)paren
suffix:semicolon
multiline_comment|/* submit the control msg as next paket */
id|ret
op_assign
id|auerchain_submit_urb_list
(paren
op_amp
id|cp-&gt;controlchain
comma
id|bp-&gt;urbp
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|dbg
(paren
l_string|&quot;auerswald_ctrlread_complete: nonzero result of auerchain_submit_urb_list %d&quot;
comma
id|ret
)paren
suffix:semicolon
id|bp-&gt;urbp-&gt;status
op_assign
id|ret
suffix:semicolon
id|auerswald_ctrlread_wretcomplete
(paren
id|bp-&gt;urbp
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* get the actual bytecount (incl. headerbyte) */
id|bp-&gt;len
op_assign
id|urb-&gt;actual_length
suffix:semicolon
id|serviceid
op_assign
id|bp-&gt;bufp
(braket
l_int|0
)braket
op_amp
id|AUH_TYPEMASK
suffix:semicolon
id|dbg
(paren
l_string|&quot;Paket with serviceid %d and %d bytes received&quot;
comma
id|serviceid
comma
id|bp-&gt;len
)paren
suffix:semicolon
multiline_comment|/* dispatch the paket */
id|scp
op_assign
id|cp-&gt;services
(braket
id|serviceid
)braket
suffix:semicolon
r_if
c_cond
(paren
id|scp
)paren
(brace
multiline_comment|/* look, Ma, a listener! */
id|scp-&gt;dispatch
(paren
id|scp
comma
id|bp
)paren
suffix:semicolon
)brace
multiline_comment|/* release the paket */
id|auerbuf_releasebuf
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/* Wake up all processes waiting for a buffer */
id|wake_up
(paren
op_amp
id|cp-&gt;bufferwait
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------*/
multiline_comment|/* Handling of Interrupt Endpoint                                    */
multiline_comment|/* This interrupt Endpoint is used to inform the host about waiting&n;   messages from the USB device.&n;*/
multiline_comment|/* int completion handler. */
DECL|function|auerswald_int_complete
r_static
r_void
id|auerswald_int_complete
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|channelid
suffix:semicolon
r_int
r_int
id|bytecount
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|pauerbuf_t
id|bp
op_assign
l_int|NULL
suffix:semicolon
id|pauerswald_t
id|cp
op_assign
(paren
id|pauerswald_t
)paren
id|urb-&gt;context
suffix:semicolon
id|dbg
(paren
l_string|&quot;auerswald_int_complete called&quot;
)paren
suffix:semicolon
multiline_comment|/* do not respond to an error condition */
r_if
c_cond
(paren
id|urb-&gt;status
op_ne
l_int|0
)paren
(brace
id|dbg
(paren
l_string|&quot;nonzero URB status = %d&quot;
comma
id|urb-&gt;status
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* check if all needed data was received */
r_if
c_cond
(paren
id|urb-&gt;actual_length
OL
id|AU_IRQMINSIZE
)paren
(brace
id|dbg
(paren
l_string|&quot;invalid data length received: %d bytes&quot;
comma
id|urb-&gt;actual_length
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* check the command code */
r_if
c_cond
(paren
id|cp-&gt;intbufp
(braket
l_int|0
)braket
op_ne
id|AU_IRQCMDID
)paren
(brace
id|dbg
(paren
l_string|&quot;invalid command received: %d&quot;
comma
id|cp-&gt;intbufp
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* check the command type */
r_if
c_cond
(paren
id|cp-&gt;intbufp
(braket
l_int|1
)braket
op_ne
id|AU_BLOCKRDY
)paren
(brace
id|dbg
(paren
l_string|&quot;invalid command type received: %d&quot;
comma
id|cp-&gt;intbufp
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* now extract the information */
id|channelid
op_assign
id|cp-&gt;intbufp
(braket
l_int|2
)braket
suffix:semicolon
id|bytecount
op_assign
id|le16_to_cpup
(paren
op_amp
id|cp-&gt;intbufp
(braket
l_int|3
)braket
)paren
suffix:semicolon
multiline_comment|/* check the channel id */
r_if
c_cond
(paren
id|channelid
op_ge
id|AUH_TYPESIZE
)paren
(brace
id|dbg
(paren
l_string|&quot;invalid channel id received: %d&quot;
comma
id|channelid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* check the byte count */
r_if
c_cond
(paren
id|bytecount
OG
(paren
id|cp-&gt;maxControlLength
op_plus
id|AUH_SIZE
)paren
)paren
(brace
id|dbg
(paren
l_string|&quot;invalid byte count received: %d&quot;
comma
id|bytecount
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dbg
(paren
l_string|&quot;Service Channel = %d&quot;
comma
id|channelid
)paren
suffix:semicolon
id|dbg
(paren
l_string|&quot;Byte Count = %d&quot;
comma
id|bytecount
)paren
suffix:semicolon
multiline_comment|/* get a buffer for the next data paket */
id|spin_lock_irqsave
(paren
op_amp
id|cp-&gt;bufctl.lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|cp-&gt;bufctl.free_buff_list
)paren
)paren
(brace
multiline_comment|/* yes: get the entry */
r_struct
id|list_head
op_star
id|tmp
op_assign
id|cp-&gt;bufctl.free_buff_list.next
suffix:semicolon
id|list_del
(paren
id|tmp
)paren
suffix:semicolon
id|bp
op_assign
id|list_entry
(paren
id|tmp
comma
id|auerbuf_t
comma
id|buff_list
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|cp-&gt;bufctl.lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* if no buffer available: skip it */
r_if
c_cond
(paren
op_logical_neg
id|bp
)paren
(brace
id|dbg
(paren
l_string|&quot;auerswald_int_complete: no data buffer available&quot;
)paren
suffix:semicolon
multiline_comment|/* can we do something more?&n;&t;&t;   This is a big problem: if this int packet is ignored, the&n;&t;&t;   device will wait forever and not signal any more data.&n;&t;&t;   The only real solution is: having enought buffers!&n;&t;&t;   Or perhaps temporary disabling the int endpoint?&n;&t;&t;*/
r_return
suffix:semicolon
)brace
multiline_comment|/* fill the control message */
id|bp-&gt;dr-&gt;bRequestType
op_assign
id|AUT_RREQ
suffix:semicolon
id|bp-&gt;dr-&gt;bRequest
op_assign
id|AUV_RBLOCK
suffix:semicolon
id|bp-&gt;dr-&gt;wValue
op_assign
id|cpu_to_le16
(paren
l_int|0
)paren
suffix:semicolon
id|bp-&gt;dr-&gt;wIndex
op_assign
id|cpu_to_le16
(paren
id|channelid
op_or
id|AUH_DIRECT
op_or
id|AUH_UNSPLIT
)paren
suffix:semicolon
id|bp-&gt;dr-&gt;wLength
op_assign
id|cpu_to_le16
(paren
id|bytecount
)paren
suffix:semicolon
id|FILL_CONTROL_URB
(paren
id|bp-&gt;urbp
comma
id|cp-&gt;usbdev
comma
id|usb_rcvctrlpipe
(paren
id|cp-&gt;usbdev
comma
l_int|0
)paren
comma
(paren
r_int
r_char
op_star
)paren
id|bp-&gt;dr
comma
id|bp-&gt;bufp
comma
id|bytecount
comma
(paren
id|usb_complete_t
)paren
id|auerswald_ctrlread_complete
comma
id|bp
)paren
suffix:semicolon
multiline_comment|/* submit the control msg */
id|ret
op_assign
id|auerchain_submit_urb
(paren
op_amp
id|cp-&gt;controlchain
comma
id|bp-&gt;urbp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|dbg
(paren
l_string|&quot;auerswald_int_complete: nonzero result of auerchain_submit_urb %d&quot;
comma
id|ret
)paren
suffix:semicolon
id|bp-&gt;urbp-&gt;status
op_assign
id|ret
suffix:semicolon
id|auerswald_ctrlread_complete
c_func
(paren
id|bp-&gt;urbp
)paren
suffix:semicolon
multiline_comment|/* here applies the same problem as above: device locking! */
)brace
)brace
multiline_comment|/* int memory deallocation&n;   NOTE: no mutex please!&n;*/
DECL|function|auerswald_int_free
r_static
r_void
id|auerswald_int_free
(paren
id|pauerswald_t
id|cp
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;inturbp
)paren
(brace
id|usb_free_urb
(paren
id|cp-&gt;inturbp
)paren
suffix:semicolon
id|cp-&gt;inturbp
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cp-&gt;intbufp
)paren
(brace
id|kfree
(paren
id|cp-&gt;intbufp
)paren
suffix:semicolon
id|cp-&gt;intbufp
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* This function is called to activate the interrupt&n;   endpoint. This function returns 0 if successfull or an error code.&n;   NOTE: no mutex please!&n;*/
DECL|function|auerswald_int_open
r_static
r_int
id|auerswald_int_open
(paren
id|pauerswald_t
id|cp
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|ep
suffix:semicolon
r_int
id|irqsize
suffix:semicolon
id|dbg
(paren
l_string|&quot;auerswald_int_open&quot;
)paren
suffix:semicolon
id|ep
op_assign
id|usb_epnum_to_ep_desc
(paren
id|cp-&gt;usbdev
comma
id|USB_DIR_IN
op_or
id|AU_IRQENDP
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|intoend
suffix:semicolon
)brace
id|irqsize
op_assign
id|ep-&gt;wMaxPacketSize
suffix:semicolon
id|cp-&gt;irqsize
op_assign
id|irqsize
suffix:semicolon
multiline_comment|/* allocate the urb and data buffer */
r_if
c_cond
(paren
op_logical_neg
id|cp-&gt;inturbp
)paren
(brace
id|cp-&gt;inturbp
op_assign
id|usb_alloc_urb
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp-&gt;inturbp
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|intoend
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|cp-&gt;intbufp
)paren
(brace
id|cp-&gt;intbufp
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
(paren
id|irqsize
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp-&gt;intbufp
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|intoend
suffix:semicolon
)brace
)brace
multiline_comment|/* setup urb */
id|FILL_INT_URB
(paren
id|cp-&gt;inturbp
comma
id|cp-&gt;usbdev
comma
id|usb_rcvintpipe
(paren
id|cp-&gt;usbdev
comma
id|AU_IRQENDP
)paren
comma
id|cp-&gt;intbufp
comma
id|irqsize
comma
id|auerswald_int_complete
comma
id|cp
comma
id|ep-&gt;bInterval
)paren
suffix:semicolon
multiline_comment|/* start the urb */
id|cp-&gt;inturbp-&gt;status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* needed! */
id|ret
op_assign
id|usb_submit_urb
(paren
id|cp-&gt;inturbp
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|intoend
suffix:colon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
multiline_comment|/* activation of interrupt endpoint has failed. Now clean up. */
id|dbg
(paren
l_string|&quot;auerswald_int_open: activation of int endpoint failed&quot;
)paren
suffix:semicolon
multiline_comment|/* deallocate memory */
id|auerswald_int_free
(paren
id|cp
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* This function is called to deactivate the interrupt&n;   endpoint. This function returns 0 if successfull or an error code.&n;   NOTE: no mutex please!&n;*/
DECL|function|auerswald_int_release
r_static
r_int
id|auerswald_int_release
(paren
id|pauerswald_t
id|cp
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|dbg
(paren
l_string|&quot;auerswald_int_release&quot;
)paren
suffix:semicolon
multiline_comment|/* stop the int endpoint */
r_if
c_cond
(paren
id|cp-&gt;inturbp
)paren
(brace
id|ret
op_assign
id|usb_unlink_urb
(paren
id|cp-&gt;inturbp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
id|dbg
(paren
l_string|&quot;nonzero int unlink result received: %d&quot;
comma
id|ret
)paren
suffix:semicolon
)brace
multiline_comment|/* deallocate memory */
id|auerswald_int_free
(paren
id|cp
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
multiline_comment|/* Helper functions                                                      */
multiline_comment|/* wake up waiting readers */
DECL|function|auerchar_disconnect
r_static
r_void
id|auerchar_disconnect
(paren
id|pauerscon_t
id|scp
)paren
(brace
id|pauerchar_t
id|ccp
op_assign
(paren
(paren
id|pauerchar_t
)paren
(paren
(paren
r_char
op_star
)paren
(paren
id|scp
)paren
op_minus
(paren
r_int
r_int
)paren
(paren
op_amp
(paren
(paren
id|pauerchar_t
)paren
l_int|0
)paren
op_member_access_from_pointer
id|scontext
)paren
)paren
)paren
suffix:semicolon
id|dbg
(paren
l_string|&quot;auerchar_disconnect called&quot;
)paren
suffix:semicolon
id|ccp-&gt;removed
op_assign
l_int|1
suffix:semicolon
id|wake_up
(paren
op_amp
id|ccp-&gt;readwait
)paren
suffix:semicolon
)brace
multiline_comment|/* dispatch a read paket to a waiting character device */
DECL|function|auerchar_ctrlread_dispatch
r_static
r_void
id|auerchar_ctrlread_dispatch
(paren
id|pauerscon_t
id|scp
comma
id|pauerbuf_t
id|bp
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|pauerchar_t
id|ccp
suffix:semicolon
id|pauerbuf_t
id|newbp
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|charp
suffix:semicolon
id|dbg
(paren
l_string|&quot;auerchar_ctrlread_dispatch called&quot;
)paren
suffix:semicolon
id|ccp
op_assign
(paren
(paren
id|pauerchar_t
)paren
(paren
(paren
r_char
op_star
)paren
(paren
id|scp
)paren
op_minus
(paren
r_int
r_int
)paren
(paren
op_amp
(paren
(paren
id|pauerchar_t
)paren
l_int|0
)paren
op_member_access_from_pointer
id|scontext
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* get a read buffer from character device context */
id|spin_lock_irqsave
(paren
op_amp
id|ccp-&gt;bufctl.lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|ccp-&gt;bufctl.free_buff_list
)paren
)paren
(brace
multiline_comment|/* yes: get the entry */
r_struct
id|list_head
op_star
id|tmp
op_assign
id|ccp-&gt;bufctl.free_buff_list.next
suffix:semicolon
id|list_del
(paren
id|tmp
)paren
suffix:semicolon
id|newbp
op_assign
id|list_entry
(paren
id|tmp
comma
id|auerbuf_t
comma
id|buff_list
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ccp-&gt;bufctl.lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newbp
)paren
(brace
id|dbg
(paren
l_string|&quot;No read buffer available, discard paket!&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* no buffer, no dispatch */
)brace
multiline_comment|/* copy information to new buffer element&n;           (all buffers have the same length) */
id|charp
op_assign
id|newbp-&gt;bufp
suffix:semicolon
id|newbp-&gt;bufp
op_assign
id|bp-&gt;bufp
suffix:semicolon
id|bp-&gt;bufp
op_assign
id|charp
suffix:semicolon
id|newbp-&gt;len
op_assign
id|bp-&gt;len
suffix:semicolon
multiline_comment|/* insert new buffer in read list */
id|spin_lock_irqsave
(paren
op_amp
id|ccp-&gt;bufctl.lock
comma
id|flags
)paren
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|newbp-&gt;buff_list
comma
op_amp
id|ccp-&gt;bufctl.rec_buff_list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|ccp-&gt;bufctl.lock
comma
id|flags
)paren
suffix:semicolon
id|dbg
(paren
l_string|&quot;read buffer appended to rec_list&quot;
)paren
suffix:semicolon
multiline_comment|/* wake up pending synchronous reads */
id|wake_up
(paren
op_amp
id|ccp-&gt;readwait
)paren
suffix:semicolon
)brace
multiline_comment|/* Delete an auerswald driver context */
DECL|function|auerswald_delete
r_static
r_void
id|auerswald_delete
c_func
(paren
id|pauerswald_t
id|cp
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;auerswald_delete&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
multiline_comment|/* Wake up all processes waiting for a buffer */
id|wake_up
(paren
op_amp
id|cp-&gt;bufferwait
)paren
suffix:semicolon
multiline_comment|/* Cleaning up */
id|auerswald_int_release
(paren
id|cp
)paren
suffix:semicolon
id|auerchain_free
(paren
op_amp
id|cp-&gt;controlchain
)paren
suffix:semicolon
id|auerbuf_free_buffers
(paren
op_amp
id|cp-&gt;bufctl
)paren
suffix:semicolon
multiline_comment|/* release the memory */
id|kfree
c_func
(paren
id|cp
)paren
suffix:semicolon
)brace
multiline_comment|/* Delete an auerswald character context */
DECL|function|auerchar_delete
r_static
r_void
id|auerchar_delete
c_func
(paren
id|pauerchar_t
id|ccp
)paren
(brace
id|dbg
(paren
l_string|&quot;auerchar_delete&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccp
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
multiline_comment|/* wake up pending synchronous reads */
id|ccp-&gt;removed
op_assign
l_int|1
suffix:semicolon
id|wake_up
(paren
op_amp
id|ccp-&gt;readwait
)paren
suffix:semicolon
multiline_comment|/* remove the read buffer */
r_if
c_cond
(paren
id|ccp-&gt;readbuf
)paren
(brace
id|auerbuf_releasebuf
(paren
id|ccp-&gt;readbuf
)paren
suffix:semicolon
id|ccp-&gt;readbuf
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* remove the character buffers */
id|auerbuf_free_buffers
(paren
op_amp
id|ccp-&gt;bufctl
)paren
suffix:semicolon
multiline_comment|/* release the memory */
id|kfree
c_func
(paren
id|ccp
)paren
suffix:semicolon
)brace
multiline_comment|/* add a new service to the device&n;   scp-&gt;id must be set!&n;   return: 0 if OK, else error code&n;*/
DECL|function|auerswald_addservice
r_static
r_int
id|auerswald_addservice
(paren
id|pauerswald_t
id|cp
comma
id|pauerscon_t
id|scp
)paren
(brace
r_int
id|ret
suffix:semicolon
multiline_comment|/* is the device available? */
r_if
c_cond
(paren
op_logical_neg
id|cp-&gt;usbdev
)paren
(brace
id|dbg
(paren
l_string|&quot;usbdev == NULL&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/*no: can not add a service, sorry*/
)brace
multiline_comment|/* is the service available? */
r_if
c_cond
(paren
id|cp-&gt;services
(braket
id|scp-&gt;id
)braket
)paren
(brace
id|dbg
(paren
l_string|&quot;service is busy&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* device is available, service is free */
id|cp-&gt;services
(braket
id|scp-&gt;id
)braket
op_assign
id|scp
suffix:semicolon
multiline_comment|/* register service in device */
id|ret
op_assign
id|auerchain_control_msg
c_func
(paren
op_amp
id|cp-&gt;controlchain
comma
multiline_comment|/* pointer to control chain */
id|cp-&gt;usbdev
comma
multiline_comment|/* pointer to device */
id|usb_sndctrlpipe
(paren
id|cp-&gt;usbdev
comma
l_int|0
)paren
comma
multiline_comment|/* pipe to control endpoint */
id|AUV_CHANNELCTL
comma
multiline_comment|/* USB message request value */
id|AUT_WREQ
comma
multiline_comment|/* USB message request type value */
l_int|0x01
comma
multiline_comment|/* open                 USB message value */
id|scp-&gt;id
comma
multiline_comment|/* USB message index value */
l_int|NULL
comma
multiline_comment|/* pointer to the data to send */
l_int|0
comma
multiline_comment|/* length in bytes of the data to send */
id|HZ
op_star
l_int|2
)paren
suffix:semicolon
multiline_comment|/* time to wait for the message to complete before timing out */
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|dbg
(paren
l_string|&quot;auerswald_addservice: auerchain_control_msg returned error code %d&quot;
comma
id|ret
)paren
suffix:semicolon
multiline_comment|/* undo above actions */
id|cp-&gt;services
(braket
id|scp-&gt;id
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|dbg
(paren
l_string|&quot;auerswald_addservice: channel open OK&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* remove a service from the the device&n;   scp-&gt;id must be set! */
DECL|function|auerswald_removeservice
r_static
r_void
id|auerswald_removeservice
(paren
id|pauerswald_t
id|cp
comma
id|pauerscon_t
id|scp
)paren
(brace
id|dbg
(paren
l_string|&quot;auerswald_removeservice called&quot;
)paren
suffix:semicolon
multiline_comment|/* check if we have a service allocated */
r_if
c_cond
(paren
id|scp-&gt;id
op_eq
id|AUH_UNASSIGNED
)paren
r_return
suffix:semicolon
multiline_comment|/* If there is a device: close the channel */
r_if
c_cond
(paren
id|cp-&gt;usbdev
)paren
(brace
multiline_comment|/* Close the service channel inside the device */
r_int
id|ret
op_assign
id|auerchain_control_msg
c_func
(paren
op_amp
id|cp-&gt;controlchain
comma
multiline_comment|/* pointer to control chain */
id|cp-&gt;usbdev
comma
multiline_comment|/* pointer to device */
id|usb_sndctrlpipe
(paren
id|cp-&gt;usbdev
comma
l_int|0
)paren
comma
multiline_comment|/* pipe to control endpoint */
id|AUV_CHANNELCTL
comma
multiline_comment|/* USB message request value */
id|AUT_WREQ
comma
multiline_comment|/* USB message request type value */
l_int|0x00
comma
singleline_comment|// close             /* USB message value */
id|scp-&gt;id
comma
multiline_comment|/* USB message index value */
l_int|NULL
comma
multiline_comment|/* pointer to the data to send */
l_int|0
comma
multiline_comment|/* length in bytes of the data to send */
id|HZ
op_star
l_int|2
)paren
suffix:semicolon
multiline_comment|/* time to wait for the message to complete before timing out */
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|dbg
(paren
l_string|&quot;auerswald_removeservice: auerchain_control_msg returned error code %d&quot;
comma
id|ret
)paren
suffix:semicolon
)brace
r_else
(brace
id|dbg
(paren
l_string|&quot;auerswald_removeservice: channel close OK&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* remove the service from the device */
id|cp-&gt;services
(braket
id|scp-&gt;id
)braket
op_assign
l_int|NULL
suffix:semicolon
id|scp-&gt;id
op_assign
id|AUH_UNASSIGNED
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
multiline_comment|/* Char device functions                                                 */
multiline_comment|/* Open a new character device */
DECL|function|auerchar_open
r_static
r_int
id|auerchar_open
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|dtindex
op_assign
id|minor
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_minus
id|AUER_MINOR_BASE
suffix:semicolon
id|pauerswald_t
id|cp
op_assign
l_int|NULL
suffix:semicolon
id|pauerchar_t
id|ccp
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* minor number in range? */
r_if
c_cond
(paren
(paren
id|dtindex
OL
l_int|0
)paren
op_logical_or
(paren
id|dtindex
op_ge
id|AUER_MAX_DEVICES
)paren
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* usb device available? */
r_if
c_cond
(paren
id|down_interruptible
(paren
op_amp
id|dev_table_mutex
)paren
)paren
(brace
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
id|cp
op_assign
id|dev_table
(braket
id|dtindex
)braket
suffix:semicolon
r_if
c_cond
(paren
id|cp
op_eq
l_int|NULL
)paren
(brace
id|up
(paren
op_amp
id|dev_table_mutex
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|down_interruptible
(paren
op_amp
id|cp-&gt;mutex
)paren
)paren
(brace
id|up
(paren
op_amp
id|dev_table_mutex
)paren
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
id|up
(paren
op_amp
id|dev_table_mutex
)paren
suffix:semicolon
multiline_comment|/* we have access to the device. Now lets allocate memory */
id|ccp
op_assign
(paren
id|pauerchar_t
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|auerchar_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccp
op_eq
l_int|NULL
)paren
(brace
id|err
(paren
l_string|&quot;out of memory&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|ofail
suffix:semicolon
)brace
multiline_comment|/* Initialize device descriptor */
id|memset
c_func
(paren
id|ccp
comma
l_int|0
comma
r_sizeof
(paren
id|auerchar_t
)paren
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|ccp-&gt;mutex
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|ccp-&gt;readmutex
)paren
suffix:semicolon
id|auerbuf_init
(paren
op_amp
id|ccp-&gt;bufctl
)paren
suffix:semicolon
id|ccp-&gt;scontext.id
op_assign
id|AUH_UNASSIGNED
suffix:semicolon
id|ccp-&gt;scontext.dispatch
op_assign
id|auerchar_ctrlread_dispatch
suffix:semicolon
id|ccp-&gt;scontext.disconnect
op_assign
id|auerchar_disconnect
suffix:semicolon
id|init_waitqueue_head
(paren
op_amp
id|ccp-&gt;readwait
)paren
suffix:semicolon
id|ret
op_assign
id|auerbuf_setup
(paren
op_amp
id|ccp-&gt;bufctl
comma
id|AU_RBUFFERS
comma
id|cp-&gt;maxControlLength
op_plus
id|AUH_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
r_goto
id|ofail
suffix:semicolon
)brace
id|cp-&gt;open_count
op_increment
suffix:semicolon
id|ccp-&gt;auerdev
op_assign
id|cp
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;open %s as /dev/usb/%s&quot;
comma
id|cp-&gt;dev_desc
comma
id|cp-&gt;name
)paren
suffix:semicolon
id|up
(paren
op_amp
id|cp-&gt;mutex
)paren
suffix:semicolon
multiline_comment|/* file IO stuff */
id|file-&gt;f_pos
op_assign
l_int|0
suffix:semicolon
id|file-&gt;private_data
op_assign
id|ccp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Error exit */
id|ofail
suffix:colon
id|up
(paren
op_amp
id|cp-&gt;mutex
)paren
suffix:semicolon
id|auerchar_delete
(paren
id|ccp
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* IOCTL functions */
DECL|function|auerchar_ioctl
r_static
r_int
id|auerchar_ioctl
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
id|pauerchar_t
id|ccp
op_assign
(paren
id|pauerchar_t
)paren
id|file-&gt;private_data
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|audevinfo_t
id|devinfo
suffix:semicolon
id|pauerswald_t
id|cp
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|u
suffix:semicolon
id|dbg
(paren
l_string|&quot;ioctl&quot;
)paren
suffix:semicolon
multiline_comment|/* get the mutexes */
r_if
c_cond
(paren
id|down_interruptible
(paren
op_amp
id|ccp-&gt;mutex
)paren
)paren
(brace
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
id|cp
op_assign
id|ccp-&gt;auerdev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
(brace
id|up
(paren
op_amp
id|ccp-&gt;mutex
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|down_interruptible
(paren
op_amp
id|cp-&gt;mutex
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|ccp-&gt;mutex
)paren
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
multiline_comment|/* Check for removal */
r_if
c_cond
(paren
op_logical_neg
id|cp-&gt;usbdev
)paren
(brace
id|up
c_func
(paren
op_amp
id|cp-&gt;mutex
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ccp-&gt;mutex
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
multiline_comment|/* return != 0 if Transmitt channel ready to send */
r_case
id|IOCTL_AU_TXREADY
suffix:colon
id|dbg
(paren
l_string|&quot;IOCTL_AU_TXREADY&quot;
)paren
suffix:semicolon
id|u
op_assign
id|ccp-&gt;auerdev
op_logical_and
(paren
id|ccp-&gt;scontext.id
op_ne
id|AUH_UNASSIGNED
)paren
op_logical_and
op_logical_neg
id|list_empty
(paren
op_amp
id|cp-&gt;bufctl.free_buff_list
)paren
suffix:semicolon
id|ret
op_assign
id|put_user
(paren
id|u
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* return != 0 if connected to a service channel */
r_case
id|IOCTL_AU_CONNECT
suffix:colon
id|dbg
(paren
l_string|&quot;IOCTL_AU_CONNECT&quot;
)paren
suffix:semicolon
id|u
op_assign
(paren
id|ccp-&gt;scontext.id
op_ne
id|AUH_UNASSIGNED
)paren
suffix:semicolon
id|ret
op_assign
id|put_user
(paren
id|u
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* return != 0 if Receive Data available */
r_case
id|IOCTL_AU_RXAVAIL
suffix:colon
id|dbg
(paren
l_string|&quot;IOCTL_AU_RXAVAIL&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccp-&gt;scontext.id
op_eq
id|AUH_UNASSIGNED
)paren
(brace
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
id|u
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* no data */
r_if
c_cond
(paren
id|ccp-&gt;readbuf
)paren
(brace
r_int
id|restlen
op_assign
id|ccp-&gt;readbuf-&gt;len
op_minus
id|ccp-&gt;readoffset
suffix:semicolon
r_if
c_cond
(paren
id|restlen
OG
l_int|0
)paren
id|u
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|u
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|ccp-&gt;bufctl.rec_buff_list
)paren
)paren
(brace
id|u
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|ret
op_assign
id|put_user
(paren
id|u
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* return the max. buffer length for the device */
r_case
id|IOCTL_AU_BUFLEN
suffix:colon
id|dbg
(paren
l_string|&quot;IOCTL_AU_BUFLEN&quot;
)paren
suffix:semicolon
id|u
op_assign
id|cp-&gt;maxControlLength
suffix:semicolon
id|ret
op_assign
id|put_user
(paren
id|u
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* requesting a service channel */
r_case
id|IOCTL_AU_SERVREQ
suffix:colon
id|dbg
(paren
l_string|&quot;IOCTL_AU_SERVREQ&quot;
)paren
suffix:semicolon
multiline_comment|/* requesting a service means: release the previous one first */
id|auerswald_removeservice
(paren
id|cp
comma
op_amp
id|ccp-&gt;scontext
)paren
suffix:semicolon
multiline_comment|/* get the channel number */
id|ret
op_assign
id|get_user
(paren
id|u
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|u
OL
id|AUH_FIRSTUSERCH
)paren
op_logical_or
(paren
id|u
op_ge
id|AUH_TYPESIZE
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
id|dbg
(paren
l_string|&quot;auerchar service request parameters are ok&quot;
)paren
suffix:semicolon
id|ccp-&gt;scontext.id
op_assign
id|u
suffix:semicolon
multiline_comment|/* request the service now */
id|ret
op_assign
id|auerswald_addservice
(paren
id|cp
comma
op_amp
id|ccp-&gt;scontext
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
multiline_comment|/* no: revert service entry */
id|ccp-&gt;scontext.id
op_assign
id|AUH_UNASSIGNED
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* get a string descriptor for the device */
r_case
id|IOCTL_AU_DEVINFO
suffix:colon
id|dbg
(paren
l_string|&quot;IOCTL_AU_DEVINFO&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|devinfo
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|audevinfo_t
)paren
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|u
op_assign
id|strlen
c_func
(paren
id|cp-&gt;dev_desc
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|u
OG
id|devinfo.bsize
)paren
(brace
id|u
op_assign
id|devinfo.bsize
suffix:semicolon
)brace
id|ret
op_assign
id|copy_to_user
c_func
(paren
id|devinfo.buf
comma
id|cp-&gt;dev_desc
comma
id|u
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* get the max. string descriptor length */
r_case
id|IOCTL_AU_SLEN
suffix:colon
id|dbg
(paren
l_string|&quot;IOCTL_AU_SLEN&quot;
)paren
suffix:semicolon
id|u
op_assign
id|AUSI_DLEN
suffix:semicolon
id|ret
op_assign
id|put_user
(paren
id|u
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|dbg
(paren
l_string|&quot;IOCTL_AU_UNKNOWN&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOIOCTLCMD
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* release the mutexes */
id|up
c_func
(paren
op_amp
id|cp-&gt;mutex
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ccp-&gt;mutex
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Read data from the device */
DECL|function|auerchar_read
r_static
id|ssize_t
id|auerchar_read
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|pauerchar_t
id|ccp
op_assign
(paren
id|pauerchar_t
)paren
id|file-&gt;private_data
suffix:semicolon
id|pauerbuf_t
id|bp
op_assign
l_int|NULL
suffix:semicolon
id|wait_queue_t
id|wait
suffix:semicolon
id|dbg
(paren
l_string|&quot;auerchar_read&quot;
)paren
suffix:semicolon
multiline_comment|/* Error checking */
r_if
c_cond
(paren
op_logical_neg
id|ccp
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
op_star
id|ppos
)paren
r_return
op_minus
id|ESPIPE
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* get the mutex */
r_if
c_cond
(paren
id|down_interruptible
(paren
op_amp
id|ccp-&gt;mutex
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
multiline_comment|/* Can we expect to read something? */
r_if
c_cond
(paren
id|ccp-&gt;scontext.id
op_eq
id|AUH_UNASSIGNED
)paren
(brace
id|up
(paren
op_amp
id|ccp-&gt;mutex
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* only one reader per device allowed */
r_if
c_cond
(paren
id|down_interruptible
(paren
op_amp
id|ccp-&gt;readmutex
)paren
)paren
(brace
id|up
(paren
op_amp
id|ccp-&gt;mutex
)paren
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
multiline_comment|/* read data from readbuf, if available */
id|doreadbuf
suffix:colon
id|bp
op_assign
id|ccp-&gt;readbuf
suffix:semicolon
r_if
c_cond
(paren
id|bp
)paren
(brace
multiline_comment|/* read the maximum bytes */
r_int
id|restlen
op_assign
id|bp-&gt;len
op_minus
id|ccp-&gt;readoffset
suffix:semicolon
r_if
c_cond
(paren
id|restlen
OL
l_int|0
)paren
id|restlen
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
id|restlen
)paren
id|count
op_assign
id|restlen
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
(paren
id|buf
comma
id|bp-&gt;bufp
op_plus
id|ccp-&gt;readoffset
comma
id|count
)paren
)paren
(brace
id|dbg
(paren
l_string|&quot;auerswald_read: copy_to_user failed&quot;
)paren
suffix:semicolon
id|up
(paren
op_amp
id|ccp-&gt;readmutex
)paren
suffix:semicolon
id|up
(paren
op_amp
id|ccp-&gt;mutex
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
multiline_comment|/* advance the read offset */
id|ccp-&gt;readoffset
op_add_assign
id|count
suffix:semicolon
id|restlen
op_sub_assign
id|count
suffix:semicolon
singleline_comment|// reuse the read buffer
r_if
c_cond
(paren
id|restlen
op_le
l_int|0
)paren
(brace
id|auerbuf_releasebuf
(paren
id|bp
)paren
suffix:semicolon
id|ccp-&gt;readbuf
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* return with number of bytes read */
r_if
c_cond
(paren
id|count
)paren
(brace
id|up
(paren
op_amp
id|ccp-&gt;readmutex
)paren
suffix:semicolon
id|up
(paren
op_amp
id|ccp-&gt;mutex
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
)brace
multiline_comment|/* a read buffer is not available. Try to get the next data block. */
id|doreadlist
suffix:colon
multiline_comment|/* Preparing for sleep */
id|init_waitqueue_entry
(paren
op_amp
id|wait
comma
id|current
)paren
suffix:semicolon
id|set_current_state
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue
(paren
op_amp
id|ccp-&gt;readwait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|bp
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ccp-&gt;bufctl.lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|ccp-&gt;bufctl.rec_buff_list
)paren
)paren
(brace
multiline_comment|/* yes: get the entry */
r_struct
id|list_head
op_star
id|tmp
op_assign
id|ccp-&gt;bufctl.rec_buff_list.next
suffix:semicolon
id|list_del
(paren
id|tmp
)paren
suffix:semicolon
id|bp
op_assign
id|list_entry
(paren
id|tmp
comma
id|auerbuf_t
comma
id|buff_list
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ccp-&gt;bufctl.lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* have we got data? */
r_if
c_cond
(paren
id|bp
)paren
(brace
id|ccp-&gt;readbuf
op_assign
id|bp
suffix:semicolon
id|ccp-&gt;readoffset
op_assign
id|AUH_SIZE
suffix:semicolon
multiline_comment|/* for headerbyte */
id|set_current_state
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
(paren
op_amp
id|ccp-&gt;readwait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_goto
id|doreadbuf
suffix:semicolon
multiline_comment|/* now we can read! */
)brace
multiline_comment|/* no data available. Should we wait? */
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|dbg
(paren
l_string|&quot;No read buffer available, returning -EAGAIN&quot;
)paren
suffix:semicolon
id|set_current_state
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
(paren
op_amp
id|ccp-&gt;readwait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|up
(paren
op_amp
id|ccp-&gt;readmutex
)paren
suffix:semicolon
id|up
(paren
op_amp
id|ccp-&gt;mutex
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
multiline_comment|/* nonblocking, no data available */
)brace
multiline_comment|/* yes, we should wait! */
id|up
(paren
op_amp
id|ccp-&gt;mutex
)paren
suffix:semicolon
multiline_comment|/* allow other operations while we wait */
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|remove_wait_queue
(paren
op_amp
id|ccp-&gt;readwait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
(paren
id|current
)paren
)paren
(brace
multiline_comment|/* waked up by a signal */
id|up
(paren
op_amp
id|ccp-&gt;readmutex
)paren
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
multiline_comment|/* Anything left to read? */
r_if
c_cond
(paren
(paren
id|ccp-&gt;scontext.id
op_eq
id|AUH_UNASSIGNED
)paren
op_logical_or
id|ccp-&gt;removed
)paren
(brace
id|up
(paren
op_amp
id|ccp-&gt;readmutex
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|down_interruptible
(paren
op_amp
id|ccp-&gt;mutex
)paren
)paren
(brace
id|up
(paren
op_amp
id|ccp-&gt;readmutex
)paren
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
multiline_comment|/* try to read the incomming data again */
r_goto
id|doreadlist
suffix:semicolon
)brace
multiline_comment|/* Write a data block into the right service channel of the device */
DECL|function|auerchar_write
r_static
id|ssize_t
id|auerchar_write
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|len
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|pauerchar_t
id|ccp
op_assign
(paren
id|pauerchar_t
)paren
id|file-&gt;private_data
suffix:semicolon
id|pauerswald_t
id|cp
op_assign
l_int|NULL
suffix:semicolon
id|pauerbuf_t
id|bp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|wait_queue_t
id|wait
suffix:semicolon
id|dbg
(paren
l_string|&quot;auerchar_write %d bytes&quot;
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* Error checking */
r_if
c_cond
(paren
op_logical_neg
id|ccp
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
op_star
id|ppos
)paren
r_return
op_minus
id|ESPIPE
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|write_again
suffix:colon
multiline_comment|/* get the mutex */
r_if
c_cond
(paren
id|down_interruptible
(paren
op_amp
id|ccp-&gt;mutex
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
multiline_comment|/* Can we expect to write something? */
r_if
c_cond
(paren
id|ccp-&gt;scontext.id
op_eq
id|AUH_UNASSIGNED
)paren
(brace
id|up
(paren
op_amp
id|ccp-&gt;mutex
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|cp
op_assign
id|ccp-&gt;auerdev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
(brace
id|up
(paren
op_amp
id|ccp-&gt;mutex
)paren
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|down_interruptible
(paren
op_amp
id|cp-&gt;mutex
)paren
)paren
(brace
id|up
(paren
op_amp
id|ccp-&gt;mutex
)paren
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|cp-&gt;usbdev
)paren
(brace
id|up
(paren
op_amp
id|cp-&gt;mutex
)paren
suffix:semicolon
id|up
(paren
op_amp
id|ccp-&gt;mutex
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Prepare for sleep */
id|init_waitqueue_entry
(paren
op_amp
id|wait
comma
id|current
)paren
suffix:semicolon
id|set_current_state
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue
(paren
op_amp
id|cp-&gt;bufferwait
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/* Try to get a buffer from the device pool.&n;&t;   We can&squot;t use a buffer from ccp-&gt;bufctl because the write&n;&t;   command will last beond a release() */
id|bp
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|cp-&gt;bufctl.lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|cp-&gt;bufctl.free_buff_list
)paren
)paren
(brace
multiline_comment|/* yes: get the entry */
r_struct
id|list_head
op_star
id|tmp
op_assign
id|cp-&gt;bufctl.free_buff_list.next
suffix:semicolon
id|list_del
(paren
id|tmp
)paren
suffix:semicolon
id|bp
op_assign
id|list_entry
(paren
id|tmp
comma
id|auerbuf_t
comma
id|buff_list
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|cp-&gt;bufctl.lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* are there any buffers left? */
r_if
c_cond
(paren
op_logical_neg
id|bp
)paren
(brace
id|up
(paren
op_amp
id|cp-&gt;mutex
)paren
suffix:semicolon
id|up
(paren
op_amp
id|ccp-&gt;mutex
)paren
suffix:semicolon
multiline_comment|/* NONBLOCK: don&squot;t wait */
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|set_current_state
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
(paren
op_amp
id|cp-&gt;bufferwait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/* BLOCKING: wait */
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|remove_wait_queue
(paren
op_amp
id|cp-&gt;bufferwait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
(paren
id|current
)paren
)paren
(brace
multiline_comment|/* waked up by a signal */
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
r_goto
id|write_again
suffix:semicolon
)brace
r_else
(brace
id|set_current_state
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
(paren
op_amp
id|cp-&gt;bufferwait
comma
op_amp
id|wait
)paren
suffix:semicolon
)brace
multiline_comment|/* protect against too big write requests */
r_if
c_cond
(paren
id|len
OG
id|cp-&gt;maxControlLength
)paren
id|len
op_assign
id|cp-&gt;maxControlLength
suffix:semicolon
multiline_comment|/* Fill the buffer */
r_if
c_cond
(paren
id|copy_from_user
(paren
id|bp-&gt;bufp
op_plus
id|AUH_SIZE
comma
id|buf
comma
id|len
)paren
)paren
(brace
id|dbg
(paren
l_string|&quot;copy_from_user failed&quot;
)paren
suffix:semicolon
id|auerbuf_releasebuf
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/* Wake up all processes waiting for a buffer */
id|wake_up
(paren
op_amp
id|cp-&gt;bufferwait
)paren
suffix:semicolon
id|up
(paren
op_amp
id|cp-&gt;mutex
)paren
suffix:semicolon
id|up
(paren
op_amp
id|ccp-&gt;mutex
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* set the header byte */
op_star
(paren
id|bp-&gt;bufp
)paren
op_assign
id|ccp-&gt;scontext.id
op_or
id|AUH_DIRECT
op_or
id|AUH_UNSPLIT
suffix:semicolon
multiline_comment|/* Set the transfer Parameters */
id|bp-&gt;len
op_assign
id|len
op_plus
id|AUH_SIZE
suffix:semicolon
id|bp-&gt;dr-&gt;bRequestType
op_assign
id|AUT_WREQ
suffix:semicolon
id|bp-&gt;dr-&gt;bRequest
op_assign
id|AUV_WBLOCK
suffix:semicolon
id|bp-&gt;dr-&gt;wValue
op_assign
id|cpu_to_le16
(paren
l_int|0
)paren
suffix:semicolon
id|bp-&gt;dr-&gt;wIndex
op_assign
id|cpu_to_le16
(paren
id|ccp-&gt;scontext.id
op_or
id|AUH_DIRECT
op_or
id|AUH_UNSPLIT
)paren
suffix:semicolon
id|bp-&gt;dr-&gt;wLength
op_assign
id|cpu_to_le16
(paren
id|len
op_plus
id|AUH_SIZE
)paren
suffix:semicolon
id|FILL_CONTROL_URB
(paren
id|bp-&gt;urbp
comma
id|cp-&gt;usbdev
comma
id|usb_sndctrlpipe
(paren
id|cp-&gt;usbdev
comma
l_int|0
)paren
comma
(paren
r_int
r_char
op_star
)paren
id|bp-&gt;dr
comma
id|bp-&gt;bufp
comma
id|len
op_plus
id|AUH_SIZE
comma
id|auerchar_ctrlwrite_complete
comma
id|bp
)paren
suffix:semicolon
multiline_comment|/* up we go */
id|ret
op_assign
id|auerchain_submit_urb
(paren
op_amp
id|cp-&gt;controlchain
comma
id|bp-&gt;urbp
)paren
suffix:semicolon
id|up
(paren
op_amp
id|cp-&gt;mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|dbg
(paren
l_string|&quot;auerchar_write: nonzero result of auerchain_submit_urb %d&quot;
comma
id|ret
)paren
suffix:semicolon
id|auerbuf_releasebuf
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/* Wake up all processes waiting for a buffer */
id|wake_up
(paren
op_amp
id|cp-&gt;bufferwait
)paren
suffix:semicolon
id|up
(paren
op_amp
id|ccp-&gt;mutex
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
id|dbg
(paren
l_string|&quot;auerchar_write: Write OK&quot;
)paren
suffix:semicolon
id|up
(paren
op_amp
id|ccp-&gt;mutex
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
)brace
multiline_comment|/* Close a character device */
DECL|function|auerchar_release
r_static
r_int
id|auerchar_release
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|pauerchar_t
id|ccp
op_assign
(paren
id|pauerchar_t
)paren
id|file-&gt;private_data
suffix:semicolon
id|pauerswald_t
id|cp
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;release&quot;
)paren
suffix:semicolon
multiline_comment|/* get the mutexes */
r_if
c_cond
(paren
id|down_interruptible
(paren
op_amp
id|ccp-&gt;mutex
)paren
)paren
(brace
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
id|cp
op_assign
id|ccp-&gt;auerdev
suffix:semicolon
r_if
c_cond
(paren
id|cp
)paren
(brace
r_if
c_cond
(paren
id|down_interruptible
(paren
op_amp
id|cp-&gt;mutex
)paren
)paren
(brace
id|up
(paren
op_amp
id|ccp-&gt;mutex
)paren
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
multiline_comment|/* remove an open service */
id|auerswald_removeservice
(paren
id|cp
comma
op_amp
id|ccp-&gt;scontext
)paren
suffix:semicolon
multiline_comment|/* detach from device */
r_if
c_cond
(paren
(paren
op_decrement
id|cp-&gt;open_count
op_le
l_int|0
)paren
op_logical_and
(paren
id|cp-&gt;usbdev
op_eq
l_int|NULL
)paren
)paren
(brace
multiline_comment|/* usb device waits for removal */
id|up
(paren
op_amp
id|cp-&gt;mutex
)paren
suffix:semicolon
id|auerswald_delete
(paren
id|cp
)paren
suffix:semicolon
)brace
r_else
(brace
id|up
(paren
op_amp
id|cp-&gt;mutex
)paren
suffix:semicolon
)brace
id|cp
op_assign
l_int|NULL
suffix:semicolon
id|ccp-&gt;auerdev
op_assign
l_int|NULL
suffix:semicolon
)brace
id|up
(paren
op_amp
id|ccp-&gt;mutex
)paren
suffix:semicolon
id|auerchar_delete
(paren
id|ccp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*----------------------------------------------------------------------*/
multiline_comment|/* File operation structure                                             */
DECL|variable|auerswald_fops
r_static
r_struct
id|file_operations
id|auerswald_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|llseek
suffix:colon
id|no_llseek
comma
id|read
suffix:colon
id|auerchar_read
comma
id|write
suffix:colon
id|auerchar_write
comma
id|ioctl
suffix:colon
id|auerchar_ioctl
comma
id|open
suffix:colon
id|auerchar_open
comma
id|release
suffix:colon
id|auerchar_release
comma
)brace
suffix:semicolon
multiline_comment|/* --------------------------------------------------------------------- */
multiline_comment|/* Special USB driver functions                                          */
multiline_comment|/* Probe if this driver wants to serve an USB device&n;&n;   This entry point is called whenever a new device is attached to the bus.&n;   Then the device driver has to create a new instance of its internal data&n;   structures for the new device.&n;&n;   The  dev argument specifies the device context, which contains pointers&n;   to all USB descriptors. The  interface argument specifies the interface&n;   number. If a USB driver wants to bind itself to a particular device and&n;   interface it has to return a pointer. This pointer normally references&n;   the device driver&squot;s context structure.&n;&n;   Probing normally is done by checking the vendor and product identifications&n;   or the class and subclass definitions. If they match the interface number&n;   is compared with the ones supported by the driver. When probing is done&n;   class based it might be necessary to parse some more USB descriptors because&n;   the device properties can differ in a wide range.&n;*/
DECL|function|auerswald_probe
r_static
r_void
op_star
id|auerswald_probe
(paren
r_struct
id|usb_device
op_star
id|usbdev
comma
r_int
r_int
id|ifnum
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
(brace
id|pauerswald_t
id|cp
op_assign
l_int|NULL
suffix:semicolon
id|DECLARE_WAIT_QUEUE_HEAD
(paren
id|wqh
)paren
suffix:semicolon
r_int
r_int
id|dtindex
suffix:semicolon
r_int
r_int
id|u
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|pbuf
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|dbg
(paren
l_string|&quot;probe: vendor id 0x%x, device id 0x%x ifnum:%d&quot;
comma
id|usbdev-&gt;descriptor.idVendor
comma
id|usbdev-&gt;descriptor.idProduct
comma
id|ifnum
)paren
suffix:semicolon
multiline_comment|/* See if the device offered us matches that we can accept */
r_if
c_cond
(paren
id|usbdev-&gt;descriptor.idVendor
op_ne
id|ID_AUERSWALD
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* we use only the first -and only- interface */
r_if
c_cond
(paren
id|ifnum
op_ne
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* prevent module unloading while sleeping */
id|MOD_INC_USE_COUNT
suffix:semicolon
multiline_comment|/* allocate memory for our device and intialize it */
id|cp
op_assign
id|kmalloc
(paren
r_sizeof
(paren
id|auerswald_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp
op_eq
l_int|NULL
)paren
(brace
id|err
(paren
l_string|&quot;out of memory&quot;
)paren
suffix:semicolon
r_goto
id|pfail
suffix:semicolon
)brace
multiline_comment|/* Initialize device descriptor */
id|memset
(paren
id|cp
comma
l_int|0
comma
r_sizeof
(paren
id|auerswald_t
)paren
)paren
suffix:semicolon
id|init_MUTEX
(paren
op_amp
id|cp-&gt;mutex
)paren
suffix:semicolon
id|cp-&gt;usbdev
op_assign
id|usbdev
suffix:semicolon
id|auerchain_init
(paren
op_amp
id|cp-&gt;controlchain
)paren
suffix:semicolon
id|auerbuf_init
(paren
op_amp
id|cp-&gt;bufctl
)paren
suffix:semicolon
id|init_waitqueue_head
(paren
op_amp
id|cp-&gt;bufferwait
)paren
suffix:semicolon
multiline_comment|/* find a free slot in the device table */
id|down
(paren
op_amp
id|dev_table_mutex
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dtindex
op_assign
l_int|0
suffix:semicolon
id|dtindex
OL
id|AUER_MAX_DEVICES
suffix:semicolon
op_increment
id|dtindex
)paren
(brace
r_if
c_cond
(paren
id|dev_table
(braket
id|dtindex
)braket
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dtindex
op_ge
id|AUER_MAX_DEVICES
)paren
(brace
id|err
(paren
l_string|&quot;more than %d devices plugged in, can not handle this device&quot;
comma
id|AUER_MAX_DEVICES
)paren
suffix:semicolon
id|up
(paren
op_amp
id|dev_table_mutex
)paren
suffix:semicolon
r_goto
id|pfail
suffix:semicolon
)brace
multiline_comment|/* Give the device a name */
id|sprintf
(paren
id|cp-&gt;name
comma
id|AU_PREFIX
l_string|&quot;%d&quot;
comma
id|dtindex
)paren
suffix:semicolon
multiline_comment|/* Store the index */
id|cp-&gt;dtindex
op_assign
id|dtindex
suffix:semicolon
id|dev_table
(braket
id|dtindex
)braket
op_assign
id|cp
suffix:semicolon
id|up
(paren
op_amp
id|dev_table_mutex
)paren
suffix:semicolon
multiline_comment|/* initialize the devfs node for this device and register it */
id|cp-&gt;devfs
op_assign
id|devfs_register
(paren
id|usb_devfs_handle
comma
id|cp-&gt;name
comma
id|DEVFS_FL_DEFAULT
comma
id|USB_MAJOR
comma
id|AUER_MINOR_BASE
op_plus
id|dtindex
comma
id|S_IFCHR
op_or
id|S_IRUGO
op_or
id|S_IWUGO
comma
op_amp
id|auerswald_fops
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Get the usb version of the device */
id|cp-&gt;version
op_assign
id|cp-&gt;usbdev-&gt;descriptor.bcdDevice
suffix:semicolon
id|dbg
(paren
l_string|&quot;Version is %X&quot;
comma
id|cp-&gt;version
)paren
suffix:semicolon
multiline_comment|/* allow some time to settle the device */
id|sleep_on_timeout
(paren
op_amp
id|wqh
comma
id|HZ
op_div
l_int|3
)paren
suffix:semicolon
multiline_comment|/* Try to get a suitable textual description of the device */
multiline_comment|/* Device name:*/
id|ret
op_assign
id|usb_string
c_func
(paren
id|cp-&gt;usbdev
comma
id|AUSI_DEVICE
comma
id|cp-&gt;dev_desc
comma
id|AUSI_DLEN
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ge
l_int|0
)paren
(brace
id|u
op_add_assign
id|ret
suffix:semicolon
multiline_comment|/* Append Serial Number */
id|memcpy
c_func
(paren
op_amp
id|cp-&gt;dev_desc
(braket
id|u
)braket
comma
l_string|&quot;,Ser# &quot;
comma
l_int|6
)paren
suffix:semicolon
id|u
op_add_assign
l_int|6
suffix:semicolon
id|ret
op_assign
id|usb_string
c_func
(paren
id|cp-&gt;usbdev
comma
id|AUSI_SERIALNR
comma
op_amp
id|cp-&gt;dev_desc
(braket
id|u
)braket
comma
id|AUSI_DLEN
op_minus
id|u
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ge
l_int|0
)paren
(brace
id|u
op_add_assign
id|ret
suffix:semicolon
multiline_comment|/* Append subscriber number */
id|memcpy
c_func
(paren
op_amp
id|cp-&gt;dev_desc
(braket
id|u
)braket
comma
l_string|&quot;, &quot;
comma
l_int|2
)paren
suffix:semicolon
id|u
op_add_assign
l_int|2
suffix:semicolon
id|ret
op_assign
id|usb_string
c_func
(paren
id|cp-&gt;usbdev
comma
id|AUSI_MSN
comma
op_amp
id|cp-&gt;dev_desc
(braket
id|u
)braket
comma
id|AUSI_DLEN
op_minus
id|u
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ge
l_int|0
)paren
(brace
id|u
op_add_assign
id|ret
suffix:semicolon
)brace
)brace
)brace
id|cp-&gt;dev_desc
(braket
id|u
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|info
c_func
(paren
l_string|&quot;device is a %s&quot;
comma
id|cp-&gt;dev_desc
)paren
suffix:semicolon
multiline_comment|/* get the maximum allowed control transfer length */
id|pbuf
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
(paren
l_int|2
comma
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/* use an allocated buffer because of urb target */
r_if
c_cond
(paren
op_logical_neg
id|pbuf
)paren
(brace
id|err
c_func
(paren
l_string|&quot;out of memory&quot;
)paren
suffix:semicolon
r_goto
id|pfail
suffix:semicolon
)brace
id|ret
op_assign
id|usb_control_msg
c_func
(paren
id|cp-&gt;usbdev
comma
multiline_comment|/* pointer to device */
id|usb_rcvctrlpipe
c_func
(paren
id|cp-&gt;usbdev
comma
l_int|0
)paren
comma
multiline_comment|/* pipe to control endpoint */
id|AUV_GETINFO
comma
multiline_comment|/* USB message request value */
id|AUT_RREQ
comma
multiline_comment|/* USB message request type value */
l_int|0
comma
multiline_comment|/* USB message value */
id|AUDI_MBCTRANS
comma
multiline_comment|/* USB message index value */
id|pbuf
comma
multiline_comment|/* pointer to the receive buffer */
l_int|2
comma
multiline_comment|/* length of the buffer */
id|HZ
op_star
l_int|2
)paren
suffix:semicolon
multiline_comment|/* time to wait for the message to complete before timing out */
r_if
c_cond
(paren
id|ret
op_eq
l_int|2
)paren
(brace
id|cp-&gt;maxControlLength
op_assign
id|le16_to_cpup
c_func
(paren
id|pbuf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pbuf
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;setup: max. allowed control transfersize is %d bytes&quot;
comma
id|cp-&gt;maxControlLength
)paren
suffix:semicolon
)brace
r_else
(brace
id|kfree
c_func
(paren
id|pbuf
)paren
suffix:semicolon
id|err
c_func
(paren
l_string|&quot;setup: getting max. allowed control transfer length failed with error %d&quot;
comma
id|ret
)paren
suffix:semicolon
r_goto
id|pfail
suffix:semicolon
)brace
multiline_comment|/* allocate a chain for the control messages */
r_if
c_cond
(paren
id|auerchain_setup
(paren
op_amp
id|cp-&gt;controlchain
comma
id|AUCH_ELEMENTS
)paren
)paren
(brace
id|err
(paren
l_string|&quot;out of memory&quot;
)paren
suffix:semicolon
r_goto
id|pfail
suffix:semicolon
)brace
multiline_comment|/* allocate buffers for control messages */
r_if
c_cond
(paren
id|auerbuf_setup
(paren
op_amp
id|cp-&gt;bufctl
comma
id|AU_RBUFFERS
comma
id|cp-&gt;maxControlLength
op_plus
id|AUH_SIZE
)paren
)paren
(brace
id|err
(paren
l_string|&quot;out of memory&quot;
)paren
suffix:semicolon
r_goto
id|pfail
suffix:semicolon
)brace
multiline_comment|/* start the interrupt endpoint */
r_if
c_cond
(paren
id|auerswald_int_open
(paren
id|cp
)paren
)paren
(brace
id|err
(paren
l_string|&quot;int endpoint failed&quot;
)paren
suffix:semicolon
r_goto
id|pfail
suffix:semicolon
)brace
multiline_comment|/* all OK */
r_return
id|cp
suffix:semicolon
multiline_comment|/* Error exit: clean up the memory */
id|pfail
suffix:colon
id|auerswald_delete
(paren
id|cp
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Disconnect driver from a served device&n;&n;   This function is called whenever a device which was served by this driver&n;   is disconnected.&n;&n;   The argument  dev specifies the device context and the  driver_context&n;   returns a pointer to the previously registered  driver_context of the&n;   probe function. After returning from the disconnect function the USB&n;   framework completly deallocates all data structures associated with&n;   this device. So especially the usb_device structure must not be used&n;   any longer by the usb driver.&n;*/
DECL|function|auerswald_disconnect
r_static
r_void
id|auerswald_disconnect
(paren
r_struct
id|usb_device
op_star
id|usbdev
comma
r_void
op_star
id|driver_context
)paren
(brace
id|pauerswald_t
id|cp
op_assign
(paren
id|pauerswald_t
)paren
id|driver_context
suffix:semicolon
r_int
r_int
id|u
suffix:semicolon
id|down
(paren
op_amp
id|cp-&gt;mutex
)paren
suffix:semicolon
id|info
(paren
l_string|&quot;device /dev/usb/%s now disconnecting&quot;
comma
id|cp-&gt;name
)paren
suffix:semicolon
multiline_comment|/* remove from device table */
multiline_comment|/* Nobody can open() this device any more */
id|down
(paren
op_amp
id|dev_table_mutex
)paren
suffix:semicolon
id|dev_table
(braket
id|cp-&gt;dtindex
)braket
op_assign
l_int|NULL
suffix:semicolon
id|up
(paren
op_amp
id|dev_table_mutex
)paren
suffix:semicolon
multiline_comment|/* remove our devfs node */
multiline_comment|/* Nobody can see this device any more */
id|devfs_unregister
(paren
id|cp-&gt;devfs
)paren
suffix:semicolon
multiline_comment|/* Stop the interrupt endpoint */
id|auerswald_int_release
(paren
id|cp
)paren
suffix:semicolon
multiline_comment|/* remove the control chain allocated in auerswald_probe&n;&t;   This has the benefit of&n;&t;   a) all pending (a)synchronous urbs are unlinked&n;&t;   b) all buffers dealing with urbs are reclaimed&n;&t;*/
id|auerchain_free
(paren
op_amp
id|cp-&gt;controlchain
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;open_count
op_eq
l_int|0
)paren
(brace
multiline_comment|/* nobody is using this device. So we can clean up now */
id|up
(paren
op_amp
id|cp-&gt;mutex
)paren
suffix:semicolon
multiline_comment|/* up() is possible here because no other task&n;&t;&t;&t;&t;   can open the device (see above). I don&squot;t want&n;&t;&t;&t;&t;   to kfree() a locked mutex. */
id|auerswald_delete
(paren
id|cp
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* device is used. Remove the pointer to the&n;&t;&t;   usb device (it&squot;s not valid any more). The last&n;&t;&t;   release() will do the clean up */
id|cp-&gt;usbdev
op_assign
l_int|NULL
suffix:semicolon
id|up
(paren
op_amp
id|cp-&gt;mutex
)paren
suffix:semicolon
multiline_comment|/* Terminate waiting writers */
id|wake_up
(paren
op_amp
id|cp-&gt;bufferwait
)paren
suffix:semicolon
multiline_comment|/* Inform all waiting readers */
r_for
c_loop
(paren
id|u
op_assign
l_int|0
suffix:semicolon
id|u
OL
id|AUH_TYPESIZE
suffix:semicolon
id|u
op_increment
)paren
(brace
id|pauerscon_t
id|scp
op_assign
id|cp-&gt;services
(braket
id|u
)braket
suffix:semicolon
r_if
c_cond
(paren
id|scp
)paren
id|scp
op_member_access_from_pointer
id|disconnect
c_func
(paren
id|scp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* The device releases this module */
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
multiline_comment|/* Descriptor for the devices which are served by this driver.&n;   NOTE: this struct is parsed by the usbmanager install scripts.&n;         Don&squot;t change without caution!&n;*/
DECL|variable|auerswald_ids
r_static
r_struct
id|usb_device_id
id|auerswald_ids
(braket
)braket
op_assign
(brace
(brace
id|USB_DEVICE
(paren
id|ID_AUERSWALD
comma
l_int|0x00C0
)paren
)brace
comma
multiline_comment|/* COMpact 2104 USB */
(brace
id|USB_DEVICE
(paren
id|ID_AUERSWALD
comma
l_int|0x00DB
)paren
)brace
comma
multiline_comment|/* COMpact 4410/2206 USB */
(brace
id|USB_DEVICE
(paren
id|ID_AUERSWALD
comma
l_int|0x00F1
)paren
)brace
comma
multiline_comment|/* Comfort 2000 System Telephone */
(brace
id|USB_DEVICE
(paren
id|ID_AUERSWALD
comma
l_int|0x00F2
)paren
)brace
comma
multiline_comment|/* Comfort 1200 System Telephone */
(brace
)brace
multiline_comment|/* Terminating entry */
)brace
suffix:semicolon
multiline_comment|/* Standard module device table */
id|MODULE_DEVICE_TABLE
(paren
id|usb
comma
id|auerswald_ids
)paren
suffix:semicolon
multiline_comment|/* Standard usb driver struct */
DECL|variable|auerswald_driver
r_static
r_struct
id|usb_driver
id|auerswald_driver
op_assign
(brace
id|name
suffix:colon
l_string|&quot;auerswald&quot;
comma
id|probe
suffix:colon
id|auerswald_probe
comma
id|disconnect
suffix:colon
id|auerswald_disconnect
comma
id|fops
suffix:colon
op_amp
id|auerswald_fops
comma
id|minor
suffix:colon
id|AUER_MINOR_BASE
comma
id|id_table
suffix:colon
id|auerswald_ids
comma
)brace
suffix:semicolon
multiline_comment|/* --------------------------------------------------------------------- */
multiline_comment|/* Module loading/unloading                                              */
multiline_comment|/* Driver initialisation. Called after module loading.&n;   NOTE: there is no concurrency at _init&n;*/
DECL|function|auerswald_init
r_static
r_int
id|__init
id|auerswald_init
(paren
r_void
)paren
(brace
r_int
id|result
suffix:semicolon
id|dbg
(paren
l_string|&quot;init&quot;
)paren
suffix:semicolon
multiline_comment|/* initialize the device table */
id|memset
(paren
op_amp
id|dev_table
comma
l_int|0
comma
r_sizeof
(paren
id|dev_table
)paren
)paren
suffix:semicolon
id|init_MUTEX
(paren
op_amp
id|dev_table_mutex
)paren
suffix:semicolon
multiline_comment|/* register driver at the USB subsystem */
id|result
op_assign
id|usb_register
(paren
op_amp
id|auerswald_driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|err
(paren
l_string|&quot;driver could not be registered&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Driver deinit. Called before module removal.&n;   NOTE: there is no concurrency at _cleanup&n;*/
DECL|function|auerswald_cleanup
r_static
r_void
id|__exit
id|auerswald_cleanup
(paren
r_void
)paren
(brace
id|dbg
(paren
l_string|&quot;cleanup&quot;
)paren
suffix:semicolon
id|usb_deregister
(paren
op_amp
id|auerswald_driver
)paren
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
multiline_comment|/* Linux device driver module description                                */
DECL|variable|DRIVER_AUTHOR
id|MODULE_AUTHOR
(paren
id|DRIVER_AUTHOR
)paren
suffix:semicolon
DECL|variable|DRIVER_DESC
id|MODULE_DESCRIPTION
(paren
id|DRIVER_DESC
)paren
suffix:semicolon
DECL|variable|auerswald_init
id|module_init
(paren
id|auerswald_init
)paren
suffix:semicolon
DECL|variable|auerswald_cleanup
id|module_exit
(paren
id|auerswald_cleanup
)paren
suffix:semicolon
multiline_comment|/* --------------------------------------------------------------------- */
eof
