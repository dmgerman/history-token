singleline_comment|// Portions of this file taken from 
singleline_comment|// Petko Manolov - Petkan (petkan@dce.bg)
singleline_comment|// from his driver pegasus.c
multiline_comment|/*&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/usb.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &quot;CDCEther.h&quot;
DECL|variable|version
r_static
r_const
r_char
op_star
id|version
op_assign
id|__FILE__
l_string|&quot;: v0.98.4 4 July 2001 Brad Hards and another&quot;
suffix:semicolon
singleline_comment|// We will attempt to probe anything that is in the
singleline_comment|// communication device class...
singleline_comment|// We will sort through them later.
DECL|variable|CDCEther_ids
r_static
r_struct
id|usb_device_id
id|CDCEther_ids
(braket
)braket
op_assign
(brace
(brace
id|USB_DEVICE_INFO
c_func
(paren
l_int|2
comma
l_int|0
comma
l_int|0
)paren
)brace
comma
(brace
)brace
)brace
suffix:semicolon
singleline_comment|//////////////////////////////////////////////////////////////////////////////
singleline_comment|// Callback routines from USB device /////////////////////////////////////////
singleline_comment|//////////////////////////////////////////////////////////////////////////////
DECL|function|read_bulk_callback
r_static
r_void
id|read_bulk_callback
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
id|ether_dev_t
op_star
id|ether_dev
op_assign
id|urb-&gt;context
suffix:semicolon
r_struct
id|net_device
op_star
id|net
suffix:semicolon
r_int
id|count
op_assign
id|urb-&gt;actual_length
comma
id|res
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
singleline_comment|// Sanity check 
r_if
c_cond
(paren
op_logical_neg
id|ether_dev
op_logical_or
op_logical_neg
(paren
id|ether_dev-&gt;flags
op_amp
id|CDC_ETHER_RUNNING
)paren
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;BULK IN callback but driver is not active!&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|net
op_assign
id|ether_dev-&gt;net
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|netif_device_present
c_func
(paren
id|net
)paren
)paren
(brace
singleline_comment|// Somebody killed our network interface...
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ether_dev-&gt;flags
op_amp
id|CDC_ETHER_RX_BUSY
)paren
(brace
singleline_comment|// Are we already trying to receive a frame???
id|ether_dev-&gt;stats.rx_errors
op_increment
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;ether_dev Rx busy&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
singleline_comment|// We are busy, leave us alone!
id|ether_dev-&gt;flags
op_or_assign
id|CDC_ETHER_RX_BUSY
suffix:semicolon
r_switch
c_cond
(paren
id|urb-&gt;status
)paren
(brace
r_case
id|USB_ST_NOERROR
suffix:colon
r_break
suffix:semicolon
r_case
id|USB_ST_NORESPONSE
suffix:colon
id|dbg
c_func
(paren
l_string|&quot;no repsonse in BULK IN&quot;
)paren
suffix:semicolon
id|ether_dev-&gt;flags
op_and_assign
op_complement
id|CDC_ETHER_RX_BUSY
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|dbg
c_func
(paren
l_string|&quot;%s: RX status %d&quot;
comma
id|net-&gt;name
comma
id|urb-&gt;status
)paren
suffix:semicolon
r_goto
id|goon
suffix:semicolon
)brace
singleline_comment|// Check to make sure we got some data...
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
(brace
singleline_comment|// We got no data!!!
r_goto
id|goon
suffix:semicolon
)brace
singleline_comment|// Tell the kernel we want some memory
r_if
c_cond
(paren
op_logical_neg
(paren
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|count
)paren
)paren
)paren
(brace
singleline_comment|// We got no receive buffer.
r_goto
id|goon
suffix:semicolon
)brace
singleline_comment|// Here&squot;s where it came from
id|skb-&gt;dev
op_assign
id|net
suffix:semicolon
singleline_comment|// Now we copy it over
id|eth_copy_and_sum
c_func
(paren
id|skb
comma
id|ether_dev-&gt;rx_buff
comma
id|count
comma
l_int|0
)paren
suffix:semicolon
singleline_comment|// Not sure
id|skb_put
c_func
(paren
id|skb
comma
id|count
)paren
suffix:semicolon
singleline_comment|// Not sure here either
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|net
)paren
suffix:semicolon
singleline_comment|// Ship it off to the kernel
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
singleline_comment|// update out statistics
id|ether_dev-&gt;stats.rx_packets
op_increment
suffix:semicolon
id|ether_dev-&gt;stats.rx_bytes
op_add_assign
id|count
suffix:semicolon
id|goon
suffix:colon
singleline_comment|// Prep the USB to wait for another frame
id|FILL_BULK_URB
c_func
(paren
op_amp
id|ether_dev-&gt;rx_urb
comma
id|ether_dev-&gt;usb
comma
id|usb_rcvbulkpipe
c_func
(paren
id|ether_dev-&gt;usb
comma
id|ether_dev-&gt;data_ep_in
)paren
comma
id|ether_dev-&gt;rx_buff
comma
id|ether_dev-&gt;wMaxSegmentSize
comma
id|read_bulk_callback
comma
id|ether_dev
)paren
suffix:semicolon
singleline_comment|// Give this to the USB subsystem so it can tell us 
singleline_comment|// when more data arrives.
r_if
c_cond
(paren
(paren
id|res
op_assign
id|usb_submit_urb
c_func
(paren
op_amp
id|ether_dev-&gt;rx_urb
)paren
)paren
)paren
(brace
id|warn
c_func
(paren
id|__FUNCTION__
l_string|&quot; failed submint rx_urb %d&quot;
comma
id|res
)paren
suffix:semicolon
)brace
singleline_comment|// We are no longer busy, show us the frames!!!
id|ether_dev-&gt;flags
op_and_assign
op_complement
id|CDC_ETHER_RX_BUSY
suffix:semicolon
)brace
DECL|function|write_bulk_callback
r_static
r_void
id|write_bulk_callback
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
id|ether_dev_t
op_star
id|ether_dev
op_assign
id|urb-&gt;context
suffix:semicolon
singleline_comment|// Sanity check
r_if
c_cond
(paren
op_logical_neg
id|ether_dev
op_logical_or
op_logical_neg
(paren
id|ether_dev-&gt;flags
op_amp
id|CDC_ETHER_RUNNING
)paren
)paren
(brace
singleline_comment|// We are insane!!!
id|err
c_func
(paren
l_string|&quot;write_bulk_callback: device not running&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
singleline_comment|// Do we still have a valid kernel network device?
r_if
c_cond
(paren
op_logical_neg
id|netif_device_present
c_func
(paren
id|ether_dev-&gt;net
)paren
)paren
(brace
singleline_comment|// Someone killed our network interface.
id|err
c_func
(paren
l_string|&quot;write_bulk_callback: net device not present&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
singleline_comment|// Hmm...  What on Earth could have happened???
r_if
c_cond
(paren
id|urb-&gt;status
)paren
(brace
id|info
c_func
(paren
l_string|&quot;%s: TX status %d&quot;
comma
id|ether_dev-&gt;net-&gt;name
comma
id|urb-&gt;status
)paren
suffix:semicolon
)brace
singleline_comment|// Update the network interface and tell it we are
singleline_comment|// ready for another frame
id|ether_dev-&gt;net-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|ether_dev-&gt;net
)paren
suffix:semicolon
)brace
singleline_comment|//static void intr_callback( struct urb *urb )
singleline_comment|//{
singleline_comment|//&t;ether_dev_t *ether_dev = urb-&gt;context;
singleline_comment|//&t;struct net_device *net;
singleline_comment|//&t;__u8&t;*d;
singleline_comment|//
singleline_comment|//&t;if ( !ether_dev )
singleline_comment|//&t;&t;return;
singleline_comment|//&t;&t;
singleline_comment|//&t;switch ( urb-&gt;status ) {
singleline_comment|//&t;&t;case USB_ST_NOERROR:
singleline_comment|//&t;&t;&t;break;
singleline_comment|//&t;&t;case USB_ST_URB_KILLED:
singleline_comment|//&t;&t;&t;return;
singleline_comment|//&t;&t;default:
singleline_comment|//&t;&t;&t;info(&quot;intr status %d&quot;, urb-&gt;status);
singleline_comment|//&t;}
singleline_comment|//
singleline_comment|//&t;d = urb-&gt;transfer_buffer;
singleline_comment|//&t;net = ether_dev-&gt;net;
singleline_comment|//&t;if ( d[0] &amp; 0xfc ) {
singleline_comment|//&t;&t;ether_dev-&gt;stats.tx_errors++;
singleline_comment|//&t;&t;if ( d[0] &amp; TX_UNDERRUN )
singleline_comment|//&t;&t;&t;ether_dev-&gt;stats.tx_fifo_errors++;
singleline_comment|//&t;&t;if ( d[0] &amp; (EXCESSIVE_COL | JABBER_TIMEOUT) )
singleline_comment|//&t;&t;&t;ether_dev-&gt;stats.tx_aborted_errors++;
singleline_comment|//&t;&t;if ( d[0] &amp; LATE_COL )
singleline_comment|//&t;&t;&t;ether_dev-&gt;stats.tx_window_errors++;
singleline_comment|//&t;&t;if ( d[0] &amp; (NO_CARRIER | LOSS_CARRIER) )
singleline_comment|//&t;&t;&t;ether_dev-&gt;stats.tx_carrier_errors++;
singleline_comment|//&t;}
singleline_comment|//}
singleline_comment|//////////////////////////////////////////////////////////////////////////////
singleline_comment|// Routines for turning net traffic on and off on the USB side ///////////////
singleline_comment|//////////////////////////////////////////////////////////////////////////////
DECL|function|enable_net_traffic
r_static
r_inline
r_int
id|enable_net_traffic
c_func
(paren
id|ether_dev_t
op_star
id|ether_dev
)paren
(brace
r_struct
id|usb_device
op_star
id|usb
op_assign
id|ether_dev-&gt;usb
suffix:semicolon
singleline_comment|// Here would be the time to set the data interface to the configuration where
singleline_comment|// it has two endpoints that use a protocol we can understand.
r_if
c_cond
(paren
id|usb_set_interface
c_func
(paren
id|usb
comma
id|ether_dev-&gt;data_bInterfaceNumber
comma
id|ether_dev-&gt;data_bAlternateSetting_with_traffic
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;usb_set_interface() failed&quot;
)paren
suffix:semicolon
id|err
c_func
(paren
l_string|&quot;Attempted to set interface %d&quot;
comma
id|ether_dev-&gt;data_bInterfaceNumber
)paren
suffix:semicolon
id|err
c_func
(paren
l_string|&quot;To alternate setting       %d&quot;
comma
id|ether_dev-&gt;data_bAlternateSetting_with_traffic
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|disable_net_traffic
r_static
r_inline
r_void
id|disable_net_traffic
c_func
(paren
id|ether_dev_t
op_star
id|ether_dev
)paren
(brace
singleline_comment|// The thing to do is to set the data interface to the alternate setting that has
singleline_comment|// no endpoints.  This is what the spec suggests.
r_if
c_cond
(paren
id|ether_dev-&gt;data_interface_altset_num_without_traffic
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|usb_set_interface
c_func
(paren
id|ether_dev-&gt;usb
comma
id|ether_dev-&gt;data_bInterfaceNumber
comma
id|ether_dev-&gt;data_bAlternateSetting_without_traffic
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;usb_set_interface() failed&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
singleline_comment|// Some devices just may not support this...
id|warn
c_func
(paren
l_string|&quot;No way to disable net traffic&quot;
)paren
suffix:semicolon
)brace
)brace
singleline_comment|//////////////////////////////////////////////////////////////////////////////
singleline_comment|// Callback routines for kernel Ethernet Device //////////////////////////////
singleline_comment|//////////////////////////////////////////////////////////////////////////////
DECL|function|CDCEther_tx_timeout
r_static
r_void
id|CDCEther_tx_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|net
)paren
(brace
id|ether_dev_t
op_star
id|ether_dev
op_assign
id|net-&gt;priv
suffix:semicolon
singleline_comment|// Sanity check
r_if
c_cond
(paren
op_logical_neg
id|ether_dev
)paren
(brace
singleline_comment|// Seems to be a case of insanity here
r_return
suffix:semicolon
)brace
singleline_comment|// Tell syslog we are hosed.
id|warn
c_func
(paren
l_string|&quot;%s: Tx timed out.&quot;
comma
id|net-&gt;name
)paren
suffix:semicolon
singleline_comment|// Tear the waiting frame off the list
id|ether_dev-&gt;tx_urb.transfer_flags
op_or_assign
id|USB_ASYNC_UNLINK
suffix:semicolon
id|usb_unlink_urb
c_func
(paren
op_amp
id|ether_dev-&gt;tx_urb
)paren
suffix:semicolon
singleline_comment|// Update statistics
id|ether_dev-&gt;stats.tx_errors
op_increment
suffix:semicolon
)brace
DECL|function|CDCEther_start_xmit
r_static
r_int
id|CDCEther_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|net
)paren
(brace
id|ether_dev_t
op_star
id|ether_dev
op_assign
id|net-&gt;priv
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
id|res
suffix:semicolon
singleline_comment|// If we are told to transmit an ethernet frame that fits EXACTLY 
singleline_comment|// into an integer number of USB packets, we force it to send one 
singleline_comment|// more byte so the device will get a runt USB packet signalling the 
singleline_comment|// end of the ethernet frame
r_if
c_cond
(paren
(paren
id|skb-&gt;len
)paren
op_xor
(paren
id|ether_dev-&gt;data_ep_out_size
)paren
)paren
(brace
singleline_comment|// It was not an exact multiple
singleline_comment|// no need to add anything extra
id|count
op_assign
id|skb-&gt;len
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// Add one to make it NOT an exact multiple
id|count
op_assign
id|skb-&gt;len
op_plus
l_int|1
suffix:semicolon
)brace
singleline_comment|// Tell the kernel, &quot;No more frames &squot;til we are done
singleline_comment|// with this one.&squot;
id|netif_stop_queue
c_func
(paren
id|net
)paren
suffix:semicolon
singleline_comment|// Copy it from kernel memory to OUR memory
id|memcpy
c_func
(paren
id|ether_dev-&gt;tx_buff
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
singleline_comment|// Fill in the URB for shipping it out.
id|FILL_BULK_URB
c_func
(paren
op_amp
id|ether_dev-&gt;tx_urb
comma
id|ether_dev-&gt;usb
comma
id|usb_sndbulkpipe
c_func
(paren
id|ether_dev-&gt;usb
comma
id|ether_dev-&gt;data_ep_out
)paren
comma
id|ether_dev-&gt;tx_buff
comma
id|ether_dev-&gt;wMaxSegmentSize
comma
id|write_bulk_callback
comma
id|ether_dev
)paren
suffix:semicolon
singleline_comment|// Tell the URB how much it will be transporting today
id|ether_dev-&gt;tx_urb.transfer_buffer_length
op_assign
id|count
suffix:semicolon
singleline_comment|// Send the URB on its merry way.
r_if
c_cond
(paren
(paren
id|res
op_assign
id|usb_submit_urb
c_func
(paren
op_amp
id|ether_dev-&gt;tx_urb
)paren
)paren
)paren
(brace
singleline_comment|// Hmm...  It didn&squot;t go. Tell someone...
id|warn
c_func
(paren
l_string|&quot;failed tx_urb %d&quot;
comma
id|res
)paren
suffix:semicolon
singleline_comment|// update some stats...
id|ether_dev-&gt;stats.tx_errors
op_increment
suffix:semicolon
singleline_comment|// and tell the kernel to give us another.
singleline_comment|// Maybe we&squot;ll get it right next time.
id|netif_start_queue
c_func
(paren
id|net
)paren
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// Okay, it went out.
singleline_comment|// Update statistics
id|ether_dev-&gt;stats.tx_packets
op_increment
suffix:semicolon
id|ether_dev-&gt;stats.tx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
singleline_comment|// And tell the kernel when the last transmit occurred.
id|net-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
)brace
singleline_comment|// We are done with the kernel&squot;s memory
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
singleline_comment|// We are done here.
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|CDCEther_netdev_stats
r_static
r_struct
id|net_device_stats
op_star
id|CDCEther_netdev_stats
c_func
(paren
r_struct
id|net_device
op_star
id|net
)paren
(brace
singleline_comment|// Easy enough!
r_return
op_amp
(paren
(paren
id|ether_dev_t
op_star
)paren
id|net-&gt;priv
)paren
op_member_access_from_pointer
id|stats
suffix:semicolon
)brace
DECL|function|CDCEther_open
r_static
r_int
id|CDCEther_open
c_func
(paren
r_struct
id|net_device
op_star
id|net
)paren
(brace
id|ether_dev_t
op_star
id|ether_dev
op_assign
(paren
id|ether_dev_t
op_star
)paren
id|net-&gt;priv
suffix:semicolon
r_int
id|res
suffix:semicolon
singleline_comment|// We are finally getting used!
id|MOD_INC_USE_COUNT
suffix:semicolon
singleline_comment|// Turn on the USB and let the packets flow!!!
r_if
c_cond
(paren
(paren
id|res
op_assign
id|enable_net_traffic
c_func
(paren
id|ether_dev
)paren
)paren
)paren
(brace
id|err
c_func
(paren
id|__FUNCTION__
l_string|&quot;can&squot;t enable_net_traffic() - %d&quot;
comma
id|res
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
singleline_comment|// Prep a receive URB
id|FILL_BULK_URB
c_func
(paren
op_amp
id|ether_dev-&gt;rx_urb
comma
id|ether_dev-&gt;usb
comma
id|usb_rcvbulkpipe
c_func
(paren
id|ether_dev-&gt;usb
comma
id|ether_dev-&gt;data_ep_in
)paren
comma
id|ether_dev-&gt;rx_buff
comma
id|ether_dev-&gt;wMaxSegmentSize
comma
id|read_bulk_callback
comma
id|ether_dev
)paren
suffix:semicolon
singleline_comment|// Put it out there so the device can send us stuff
r_if
c_cond
(paren
(paren
id|res
op_assign
id|usb_submit_urb
c_func
(paren
op_amp
id|ether_dev-&gt;rx_urb
)paren
)paren
)paren
(brace
singleline_comment|// Hmm...  Okay...
id|warn
c_func
(paren
id|__FUNCTION__
l_string|&quot; failed rx_urb %d&quot;
comma
id|res
)paren
suffix:semicolon
)brace
singleline_comment|// Tell the kernel we are ready to start receiving from it
id|netif_start_queue
c_func
(paren
id|net
)paren
suffix:semicolon
singleline_comment|// We are up and running.
id|ether_dev-&gt;flags
op_or_assign
id|CDC_ETHER_RUNNING
suffix:semicolon
singleline_comment|// Let&squot;s get ready to move frames!!!
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|CDCEther_close
r_static
r_int
id|CDCEther_close
c_func
(paren
r_struct
id|net_device
op_star
id|net
)paren
(brace
id|ether_dev_t
op_star
id|ether_dev
op_assign
id|net-&gt;priv
suffix:semicolon
singleline_comment|// We are no longer running.
id|ether_dev-&gt;flags
op_and_assign
op_complement
id|CDC_ETHER_RUNNING
suffix:semicolon
singleline_comment|// Tell the kernel to stop sending us stuff
id|netif_stop_queue
c_func
(paren
id|net
)paren
suffix:semicolon
singleline_comment|// If we are not already unplugged, turn off USB
singleline_comment|// traffic
r_if
c_cond
(paren
op_logical_neg
(paren
id|ether_dev-&gt;flags
op_amp
id|CDC_ETHER_UNPLUG
)paren
)paren
(brace
id|disable_net_traffic
c_func
(paren
id|ether_dev
)paren
suffix:semicolon
)brace
singleline_comment|// We don&squot;t need the URBs anymore.
id|usb_unlink_urb
c_func
(paren
op_amp
id|ether_dev-&gt;rx_urb
)paren
suffix:semicolon
id|usb_unlink_urb
c_func
(paren
op_amp
id|ether_dev-&gt;tx_urb
)paren
suffix:semicolon
id|usb_unlink_urb
c_func
(paren
op_amp
id|ether_dev-&gt;intr_urb
)paren
suffix:semicolon
singleline_comment|// We are not being used now.
id|MOD_DEC_USE_COUNT
suffix:semicolon
singleline_comment|// That&squot;s it.  I&squot;m done.
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|CDCEther_ioctl
r_static
r_int
id|CDCEther_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|net
comma
r_struct
id|ifreq
op_star
id|rq
comma
r_int
id|cmd
)paren
(brace
singleline_comment|//__u16 *data = (__u16 *)&amp;rq-&gt;ifr_data;
singleline_comment|//ether_dev_t&t;*ether_dev = net-&gt;priv;
singleline_comment|// No support here yet.
singleline_comment|// Do we need support???
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCDEVPRIVATE
suffix:colon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_case
id|SIOCDEVPRIVATE
op_plus
l_int|1
suffix:colon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_case
id|SIOCDEVPRIVATE
op_plus
l_int|2
suffix:colon
singleline_comment|//return 0;
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
)brace
DECL|function|CDCEther_set_multicast
r_static
r_void
id|CDCEther_set_multicast
c_func
(paren
r_struct
id|net_device
op_star
id|net
)paren
(brace
id|ether_dev_t
op_star
id|ether_dev
op_assign
id|net-&gt;priv
suffix:semicolon
singleline_comment|// Tell the kernel to stop sending us frames while we get this
singleline_comment|// all set up.
id|netif_stop_queue
c_func
(paren
id|net
)paren
suffix:semicolon
singleline_comment|// Do what we are told.
r_if
c_cond
(paren
id|net-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
singleline_comment|// TODO - Turn on promiscuous mode
id|info
c_func
(paren
l_string|&quot;%s: Promiscuous mode enabled&quot;
comma
id|net-&gt;name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|net-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
(brace
singleline_comment|// TODO - Here we need to tell the device to block ALL multicast traffic.
id|info
c_func
(paren
l_string|&quot;%s: set allmulti&quot;
comma
id|net-&gt;name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|net-&gt;mc_count
OG
id|ether_dev-&gt;wNumberMCFilters
)paren
(brace
singleline_comment|// TODO - Here we need to set multicast filters, but
singleline_comment|// There are more than our limit...  Hmm...
id|info
c_func
(paren
l_string|&quot;%s: set too many MC filters&quot;
comma
id|net-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// TODO - Here we are supposed to set SOME of the multicast filters.
singleline_comment|// I must learn how to do this...
singleline_comment|//info(&quot;%s: set Rx mode&quot;, net-&gt;name);
)brace
singleline_comment|// Tell the kernel to start giving frames to us again.
id|netif_wake_queue
c_func
(paren
id|net
)paren
suffix:semicolon
)brace
singleline_comment|//////////////////////////////////////////////////////////////////////////////
singleline_comment|// Routines used to parse out the Functional Descriptors /////////////////////
singleline_comment|//////////////////////////////////////////////////////////////////////////////
DECL|function|parse_header_functional_descriptor
r_static
r_int
id|parse_header_functional_descriptor
c_func
(paren
r_int
op_star
id|bFunctionLength
comma
r_int
id|bDescriptorType
comma
r_int
id|bDescriptorSubtype
comma
r_int
r_char
op_star
id|data
comma
id|ether_dev_t
op_star
id|ether_dev
comma
r_int
op_star
id|requirements
)paren
(brace
singleline_comment|// Check to make sure we haven&squot;t seen one of these already.
r_if
c_cond
(paren
(paren
op_complement
op_star
id|requirements
)paren
op_amp
id|REQ_HDR_FUNC_DESCR
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Multiple Header Functional Descriptors found.&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
singleline_comment|// Is it the right size???
r_if
c_cond
(paren
op_star
id|bFunctionLength
op_ne
l_int|5
)paren
(brace
id|info
c_func
(paren
l_string|&quot;Invalid length in Header Functional Descriptor&quot;
)paren
suffix:semicolon
singleline_comment|// This is a hack to get around a particular device (NO NAMES)
singleline_comment|// It has this function length set to the length of the
singleline_comment|// whole class-specific descriptor
op_star
id|bFunctionLength
op_assign
l_int|5
suffix:semicolon
)brace
singleline_comment|// Nothing extremely useful here.
singleline_comment|// We&squot;ll keep it for posterity
id|ether_dev-&gt;bcdCDC
op_assign
id|data
(braket
l_int|0
)braket
op_plus
(paren
id|data
(braket
l_int|1
)braket
op_lshift
l_int|8
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;Found Header descriptor, CDC version %x&quot;
comma
id|ether_dev-&gt;bcdCDC
)paren
suffix:semicolon
singleline_comment|// We&squot;ve seen one of these
op_star
id|requirements
op_and_assign
op_complement
id|REQ_HDR_FUNC_DESCR
suffix:semicolon
singleline_comment|// It&squot;s all good.
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|parse_union_functional_descriptor
r_static
r_int
id|parse_union_functional_descriptor
c_func
(paren
r_int
op_star
id|bFunctionLength
comma
r_int
id|bDescriptorType
comma
r_int
id|bDescriptorSubtype
comma
r_int
r_char
op_star
id|data
comma
id|ether_dev_t
op_star
id|ether_dev
comma
r_int
op_star
id|requirements
)paren
(brace
singleline_comment|// Check to make sure we haven&squot;t seen one of these already.
r_if
c_cond
(paren
(paren
op_complement
op_star
id|requirements
)paren
op_amp
id|REQ_UNION_FUNC_DESCR
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Multiple Union Functional Descriptors found.&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
singleline_comment|// Is it the right size?
r_if
c_cond
(paren
op_star
id|bFunctionLength
op_ne
l_int|5
)paren
(brace
singleline_comment|// It is NOT the size we expected.
id|err
c_func
(paren
l_string|&quot;Unsupported length in Union Functional Descriptor&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
singleline_comment|// Sanity check of sorts
r_if
c_cond
(paren
id|ether_dev-&gt;comm_interface
op_ne
id|data
(braket
l_int|0
)braket
)paren
(brace
singleline_comment|// This tells us that we are chasing the wrong comm
singleline_comment|// interface or we are crazy or something else weird.
r_if
c_cond
(paren
id|ether_dev-&gt;comm_interface
op_eq
id|data
(braket
l_int|1
)braket
)paren
(brace
id|info
c_func
(paren
l_string|&quot;Probably broken Union descriptor, fudging data interface&quot;
)paren
suffix:semicolon
singleline_comment|// We&squot;ll need this in a few microseconds, 
singleline_comment|// so guess here, and hope for the best
id|ether_dev-&gt;data_interface
op_assign
id|data
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_else
(brace
id|err
c_func
(paren
l_string|&quot;Union Functional Descriptor is broken beyond repair&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
singleline_comment|// Descriptor is OK
singleline_comment|// We&squot;ll need this in a few microseconds!
id|ether_dev-&gt;data_interface
op_assign
id|data
(braket
l_int|1
)braket
suffix:semicolon
)brace
singleline_comment|// We&squot;ve seen one of these now.
op_star
id|requirements
op_and_assign
op_complement
id|REQ_UNION_FUNC_DESCR
suffix:semicolon
singleline_comment|// Done
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|parse_ethernet_functional_descriptor
r_static
r_int
id|parse_ethernet_functional_descriptor
c_func
(paren
r_int
op_star
id|bFunctionLength
comma
r_int
id|bDescriptorType
comma
r_int
id|bDescriptorSubtype
comma
r_int
r_char
op_star
id|data
comma
id|ether_dev_t
op_star
id|ether_dev
comma
r_int
op_star
id|requirements
)paren
(brace
singleline_comment|// Check to make sure we haven&squot;t seen one of these already.
r_if
c_cond
(paren
(paren
op_complement
op_star
id|requirements
)paren
op_amp
id|REQ_ETH_FUNC_DESCR
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Multiple Ethernet Functional Descriptors found.&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
singleline_comment|// Is it the right size?
r_if
c_cond
(paren
op_star
id|bFunctionLength
op_ne
l_int|13
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Invalid length in Ethernet Networking Functional Descriptor&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
singleline_comment|// Lots of goodies from this one.  They are all important.
id|ether_dev-&gt;iMACAddress
op_assign
id|data
(braket
l_int|0
)braket
suffix:semicolon
id|ether_dev-&gt;bmEthernetStatistics
op_assign
id|data
(braket
l_int|1
)braket
op_plus
(paren
id|data
(braket
l_int|2
)braket
op_lshift
l_int|8
)paren
op_plus
(paren
id|data
(braket
l_int|3
)braket
op_lshift
l_int|16
)paren
op_plus
(paren
id|data
(braket
l_int|4
)braket
op_lshift
l_int|24
)paren
suffix:semicolon
id|ether_dev-&gt;wMaxSegmentSize
op_assign
id|data
(braket
l_int|5
)braket
op_plus
(paren
id|data
(braket
l_int|6
)braket
op_lshift
l_int|8
)paren
suffix:semicolon
id|ether_dev-&gt;wNumberMCFilters
op_assign
(paren
id|data
(braket
l_int|7
)braket
op_plus
(paren
id|data
(braket
l_int|8
)braket
op_lshift
l_int|8
)paren
)paren
op_amp
l_int|0x00007FFF
suffix:semicolon
id|ether_dev-&gt;bNumberPowerFilters
op_assign
id|data
(braket
l_int|9
)braket
suffix:semicolon
singleline_comment|// We&squot;ve seen one of these now.
op_star
id|requirements
op_and_assign
op_complement
id|REQ_ETH_FUNC_DESCR
suffix:semicolon
singleline_comment|// That&squot;s all she wrote.
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|parse_protocol_unit_functional_descriptor
r_static
r_int
id|parse_protocol_unit_functional_descriptor
c_func
(paren
r_int
op_star
id|bFunctionLength
comma
r_int
id|bDescriptorType
comma
r_int
id|bDescriptorSubtype
comma
r_int
r_char
op_star
id|data
comma
id|ether_dev_t
op_star
id|ether_dev
comma
r_int
op_star
id|requirements
)paren
(brace
singleline_comment|// There should only be one type if we are sane
r_if
c_cond
(paren
id|bDescriptorType
op_ne
id|CS_INTERFACE
)paren
(brace
id|info
c_func
(paren
l_string|&quot;Invalid bDescriptorType found.&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
singleline_comment|// The Subtype tells the tale.
r_switch
c_cond
(paren
id|bDescriptorSubtype
)paren
(brace
r_case
l_int|0x00
suffix:colon
singleline_comment|// Header Functional Descriptor
r_return
id|parse_header_functional_descriptor
c_func
(paren
id|bFunctionLength
comma
id|bDescriptorType
comma
id|bDescriptorSubtype
comma
id|data
comma
id|ether_dev
comma
id|requirements
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x06
suffix:colon
singleline_comment|// Union Functional Descriptor
r_return
id|parse_union_functional_descriptor
c_func
(paren
id|bFunctionLength
comma
id|bDescriptorType
comma
id|bDescriptorSubtype
comma
id|data
comma
id|ether_dev
comma
id|requirements
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0F
suffix:colon
singleline_comment|// Ethernet Networking Functional Descriptor
r_return
id|parse_ethernet_functional_descriptor
c_func
(paren
id|bFunctionLength
comma
id|bDescriptorType
comma
id|bDescriptorSubtype
comma
id|data
comma
id|ether_dev
comma
id|requirements
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
singleline_comment|// We don&squot;t support this at this time...
singleline_comment|// However that doesn&squot;t necessarily indicate an error.
id|dbg
c_func
(paren
l_string|&quot;Unexpected header type %x:&quot;
comma
id|bDescriptorSubtype
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|// How did we get here???
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|parse_ethernet_class_information
r_static
r_int
id|parse_ethernet_class_information
c_func
(paren
r_int
r_char
op_star
id|data
comma
r_int
id|length
comma
id|ether_dev_t
op_star
id|ether_dev
)paren
(brace
r_int
id|loc
op_assign
l_int|0
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_int
id|bFunctionLength
suffix:semicolon
r_int
id|bDescriptorType
suffix:semicolon
r_int
id|bDescriptorSubtype
suffix:semicolon
r_int
id|requirements
op_assign
id|REQUIREMENTS_TOTAL
suffix:semicolon
singleline_comment|// As long as there is something here, we will try to parse it
r_while
c_loop
(paren
id|loc
OL
id|length
)paren
(brace
singleline_comment|// Length
id|bFunctionLength
op_assign
id|data
(braket
id|loc
)braket
suffix:semicolon
id|loc
op_increment
suffix:semicolon
singleline_comment|// Type
id|bDescriptorType
op_assign
id|data
(braket
id|loc
)braket
suffix:semicolon
id|loc
op_increment
suffix:semicolon
singleline_comment|// Subtype
id|bDescriptorSubtype
op_assign
id|data
(braket
id|loc
)braket
suffix:semicolon
id|loc
op_increment
suffix:semicolon
singleline_comment|// ship this off to be processed elsewhere.
id|rc
op_assign
id|parse_protocol_unit_functional_descriptor
c_func
(paren
op_amp
id|bFunctionLength
comma
id|bDescriptorType
comma
id|bDescriptorSubtype
comma
op_amp
id|data
(braket
id|loc
)braket
comma
id|ether_dev
comma
op_amp
id|requirements
)paren
suffix:semicolon
singleline_comment|// Did it process okay?
r_if
c_cond
(paren
id|rc
)paren
(brace
singleline_comment|// Something was hosed somewhere.
singleline_comment|// No need to continue;
id|err
c_func
(paren
l_string|&quot;Bad descriptor parsing: %x&quot;
comma
id|rc
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
singleline_comment|// We have already taken three bytes.
id|loc
op_add_assign
(paren
id|bFunctionLength
op_minus
l_int|3
)paren
suffix:semicolon
)brace
singleline_comment|// Check to see if we got everything we need.
r_if
c_cond
(paren
id|requirements
)paren
(brace
singleline_comment|// We missed some of the requirements...
id|err
c_func
(paren
l_string|&quot;Not all required functional descriptors present 0x%08X&quot;
comma
id|requirements
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
singleline_comment|// We got everything.
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|//////////////////////////////////////////////////////////////////////////////
singleline_comment|// Routine to check for the existence of the Functional Descriptors //////////
singleline_comment|//////////////////////////////////////////////////////////////////////////////
DECL|function|find_and_parse_ethernet_class_information
r_static
r_int
id|find_and_parse_ethernet_class_information
c_func
(paren
r_struct
id|usb_device
op_star
id|device
comma
id|ether_dev_t
op_star
id|ether_dev
)paren
(brace
r_struct
id|usb_config_descriptor
op_star
id|conf
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|usb_interface
op_star
id|comm_intf_group
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|usb_interface_descriptor
op_star
id|comm_intf
op_assign
l_int|NULL
suffix:semicolon
r_int
id|rc
op_assign
op_minus
l_int|1
suffix:semicolon
singleline_comment|// The assumption here is that find_ethernet_comm_interface
singleline_comment|// and find_valid_configuration 
singleline_comment|// have already filled in the information about where to find
singleline_comment|// the a valid commication interface.
id|conf
op_assign
op_amp
(paren
id|device-&gt;config
(braket
id|ether_dev-&gt;configuration_num
)braket
)paren
suffix:semicolon
id|comm_intf_group
op_assign
op_amp
(paren
id|conf-&gt;interface
(braket
id|ether_dev-&gt;comm_interface
)braket
)paren
suffix:semicolon
id|comm_intf
op_assign
op_amp
(paren
id|comm_intf_group-&gt;altsetting
(braket
id|ether_dev-&gt;comm_interface_altset_num
)braket
)paren
suffix:semicolon
singleline_comment|// Let&squot;s check and see if it has the extra information we need...
r_if
c_cond
(paren
id|comm_intf-&gt;extralen
OG
l_int|0
)paren
(brace
singleline_comment|// This is where the information is SUPPOSED to be.
id|rc
op_assign
id|parse_ethernet_class_information
c_func
(paren
id|comm_intf-&gt;extra
comma
id|comm_intf-&gt;extralen
comma
id|ether_dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|conf-&gt;extralen
OG
l_int|0
)paren
(brace
singleline_comment|// This is a hack.  The spec says it should be at the interface 
singleline_comment|// location checked above.  However I have seen it here also.
singleline_comment|// This is the same device that requires the functional descriptor hack above
id|warn
c_func
(paren
l_string|&quot;Ethernet information found at device configuration.  This is broken.&quot;
)paren
suffix:semicolon
id|rc
op_assign
id|parse_ethernet_class_information
c_func
(paren
id|conf-&gt;extra
comma
id|conf-&gt;extralen
comma
id|ether_dev
)paren
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// I don&squot;t know where else to look.
id|warn
c_func
(paren
l_string|&quot;No ethernet information found.&quot;
)paren
suffix:semicolon
id|rc
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
singleline_comment|//////////////////////////////////////////////////////////////////////////////
singleline_comment|// Routines to verify the data interface /////////////////////////////////////
singleline_comment|//////////////////////////////////////////////////////////////////////////////
DECL|function|get_data_interface_endpoints
r_static
r_int
id|get_data_interface_endpoints
c_func
(paren
r_struct
id|usb_device
op_star
id|device
comma
id|ether_dev_t
op_star
id|ether_dev
)paren
(brace
r_struct
id|usb_config_descriptor
op_star
id|conf
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|usb_interface
op_star
id|data_intf_group
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|usb_interface_descriptor
op_star
id|data_intf
op_assign
l_int|NULL
suffix:semicolon
singleline_comment|// Walk through and get to the data interface we are checking.
id|conf
op_assign
op_amp
(paren
id|device-&gt;config
(braket
id|ether_dev-&gt;configuration_num
)braket
)paren
suffix:semicolon
id|data_intf_group
op_assign
op_amp
(paren
id|conf-&gt;interface
(braket
id|ether_dev-&gt;data_interface
)braket
)paren
suffix:semicolon
id|data_intf
op_assign
op_amp
(paren
id|data_intf_group-&gt;altsetting
(braket
id|ether_dev-&gt;data_interface_altset_num_with_traffic
)braket
)paren
suffix:semicolon
singleline_comment|// Start out assuming we won&squot;t find anything we can use
id|ether_dev-&gt;data_ep_in
op_assign
l_int|0
suffix:semicolon
id|ether_dev-&gt;data_ep_out
op_assign
l_int|0
suffix:semicolon
singleline_comment|// If these are not BULK endpoints, we don&squot;t want them
r_if
c_cond
(paren
id|data_intf-&gt;endpoint
(braket
l_int|0
)braket
dot
id|bmAttributes
op_ne
l_int|0x02
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|data_intf-&gt;endpoint
(braket
l_int|1
)braket
dot
id|bmAttributes
op_ne
l_int|0x02
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
singleline_comment|// Check the first endpoint to see if it is IN or OUT
r_if
c_cond
(paren
id|data_intf-&gt;endpoint
(braket
l_int|0
)braket
dot
id|bEndpointAddress
op_amp
l_int|0x80
)paren
(brace
singleline_comment|// This endpoint is IN
id|ether_dev-&gt;data_ep_in
op_assign
id|data_intf-&gt;endpoint
(braket
l_int|0
)braket
dot
id|bEndpointAddress
op_amp
l_int|0x7F
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// This endpoint is OUT
id|ether_dev-&gt;data_ep_out
op_assign
id|data_intf-&gt;endpoint
(braket
l_int|0
)braket
dot
id|bEndpointAddress
op_amp
l_int|0x7F
suffix:semicolon
id|ether_dev-&gt;data_ep_out_size
op_assign
id|data_intf-&gt;endpoint
(braket
l_int|0
)braket
dot
id|wMaxPacketSize
suffix:semicolon
)brace
singleline_comment|// Check the second endpoint to see if it is IN or OUT
r_if
c_cond
(paren
id|data_intf-&gt;endpoint
(braket
l_int|1
)braket
dot
id|bEndpointAddress
op_amp
l_int|0x80
)paren
(brace
singleline_comment|// This endpoint is IN
id|ether_dev-&gt;data_ep_in
op_assign
id|data_intf-&gt;endpoint
(braket
l_int|1
)braket
dot
id|bEndpointAddress
op_amp
l_int|0x7F
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// This endpoint is OUT
id|ether_dev-&gt;data_ep_out
op_assign
id|data_intf-&gt;endpoint
(braket
l_int|1
)braket
dot
id|bEndpointAddress
op_amp
l_int|0x7F
suffix:semicolon
id|ether_dev-&gt;data_ep_out_size
op_assign
id|data_intf-&gt;endpoint
(braket
l_int|1
)braket
dot
id|wMaxPacketSize
suffix:semicolon
)brace
singleline_comment|// Now make sure we got both an IN and an OUT
r_if
c_cond
(paren
id|ether_dev-&gt;data_ep_in
op_logical_and
id|ether_dev-&gt;data_ep_out
)paren
(brace
singleline_comment|// We did get both, we are in good shape...
id|info
c_func
(paren
l_string|&quot;detected BULK OUT packets of size %d&quot;
comma
id|ether_dev-&gt;data_ep_out_size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|verify_ethernet_data_interface
r_static
r_int
id|verify_ethernet_data_interface
c_func
(paren
r_struct
id|usb_device
op_star
id|device
comma
id|ether_dev_t
op_star
id|ether_dev
)paren
(brace
r_struct
id|usb_config_descriptor
op_star
id|conf
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|usb_interface
op_star
id|data_intf_group
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|usb_interface_descriptor
op_star
id|data_intf
op_assign
l_int|NULL
suffix:semicolon
r_int
id|rc
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|altset_num
suffix:semicolon
singleline_comment|// The assumption here is that parse_ethernet_class_information()
singleline_comment|// and find_valid_configuration() 
singleline_comment|// have already filled in the information about where to find
singleline_comment|// a data interface
id|conf
op_assign
op_amp
(paren
id|device-&gt;config
(braket
id|ether_dev-&gt;configuration_num
)braket
)paren
suffix:semicolon
id|data_intf_group
op_assign
op_amp
(paren
id|conf-&gt;interface
(braket
id|ether_dev-&gt;data_interface
)braket
)paren
suffix:semicolon
singleline_comment|// start out assuming we won&squot;t find what we are looking for.
id|ether_dev-&gt;data_interface_altset_num_with_traffic
op_assign
op_minus
l_int|1
suffix:semicolon
id|ether_dev-&gt;data_bAlternateSetting_with_traffic
op_assign
op_minus
l_int|1
suffix:semicolon
id|ether_dev-&gt;data_interface_altset_num_without_traffic
op_assign
op_minus
l_int|1
suffix:semicolon
id|ether_dev-&gt;data_bAlternateSetting_without_traffic
op_assign
op_minus
l_int|1
suffix:semicolon
singleline_comment|// Walk through every possible setting for this interface until
singleline_comment|// we find what makes us happy.
r_for
c_loop
(paren
id|altset_num
op_assign
l_int|0
suffix:semicolon
id|altset_num
OL
id|data_intf_group-&gt;num_altsetting
suffix:semicolon
id|altset_num
op_increment
)paren
(brace
id|data_intf
op_assign
op_amp
(paren
id|data_intf_group-&gt;altsetting
(braket
id|altset_num
)braket
)paren
suffix:semicolon
singleline_comment|// Is this a data interface we like?
r_if
c_cond
(paren
(paren
id|data_intf-&gt;bInterfaceClass
op_eq
l_int|0x0A
)paren
op_logical_and
(paren
id|data_intf-&gt;bInterfaceSubClass
op_eq
l_int|0x00
)paren
op_logical_and
(paren
id|data_intf-&gt;bInterfaceProtocol
op_eq
l_int|0x00
)paren
)paren
(brace
r_if
c_cond
(paren
id|data_intf-&gt;bNumEndpoints
op_eq
l_int|2
)paren
(brace
singleline_comment|// We are required to have one of these.
singleline_comment|// An interface with 2 endpoints to send Ethernet traffic back and forth
singleline_comment|// It actually may be possible that the device might only
singleline_comment|// communicate in a vendor specific manner.
singleline_comment|// That would not be very nice.
singleline_comment|// We can add that one later.
id|ether_dev-&gt;data_bInterfaceNumber
op_assign
id|data_intf-&gt;bInterfaceNumber
suffix:semicolon
id|ether_dev-&gt;data_interface_altset_num_with_traffic
op_assign
id|altset_num
suffix:semicolon
id|ether_dev-&gt;data_bAlternateSetting_with_traffic
op_assign
id|data_intf-&gt;bAlternateSetting
suffix:semicolon
id|status
op_assign
id|get_data_interface_endpoints
c_func
(paren
id|device
comma
id|ether_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
id|rc
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|data_intf-&gt;bNumEndpoints
op_eq
l_int|0
)paren
(brace
singleline_comment|// According to the spec we are SUPPOSED to have one of these
singleline_comment|// In fact the device is supposed to come up in this state.
singleline_comment|// However, I have seen a device that did not have such an interface.
singleline_comment|// So it must be just optional for our driver...
id|ether_dev-&gt;data_bInterfaceNumber
op_assign
id|data_intf-&gt;bInterfaceNumber
suffix:semicolon
id|ether_dev-&gt;data_interface_altset_num_without_traffic
op_assign
id|altset_num
suffix:semicolon
id|ether_dev-&gt;data_bAlternateSetting_without_traffic
op_assign
id|data_intf-&gt;bAlternateSetting
suffix:semicolon
)brace
)brace
)brace
r_return
id|rc
suffix:semicolon
)brace
singleline_comment|//////////////////////////////////////////////////////////////////////////////
singleline_comment|// Routine to find a communication interface /////////////////////////////////
singleline_comment|//////////////////////////////////////////////////////////////////////////////
DECL|function|find_ethernet_comm_interface
r_static
r_int
id|find_ethernet_comm_interface
c_func
(paren
r_struct
id|usb_device
op_star
id|device
comma
id|ether_dev_t
op_star
id|ether_dev
)paren
(brace
r_struct
id|usb_config_descriptor
op_star
id|conf
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|usb_interface
op_star
id|comm_intf_group
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|usb_interface_descriptor
op_star
id|comm_intf
op_assign
l_int|NULL
suffix:semicolon
r_int
id|intf_num
suffix:semicolon
r_int
id|altset_num
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|conf
op_assign
op_amp
(paren
id|device-&gt;config
(braket
id|ether_dev-&gt;configuration_num
)braket
)paren
suffix:semicolon
singleline_comment|// We need to check and see if any of these interfaces are something we want.
singleline_comment|// Walk through each interface one at a time
r_for
c_loop
(paren
id|intf_num
op_assign
l_int|0
suffix:semicolon
id|intf_num
OL
id|conf-&gt;bNumInterfaces
suffix:semicolon
id|intf_num
op_increment
)paren
(brace
id|comm_intf_group
op_assign
op_amp
(paren
id|conf-&gt;interface
(braket
id|intf_num
)braket
)paren
suffix:semicolon
singleline_comment|// Now for each of those interfaces, check every possible
singleline_comment|// alternate setting.
r_for
c_loop
(paren
id|altset_num
op_assign
l_int|0
suffix:semicolon
id|altset_num
OL
id|comm_intf_group-&gt;num_altsetting
suffix:semicolon
id|altset_num
op_increment
)paren
(brace
id|comm_intf
op_assign
op_amp
(paren
id|comm_intf_group-&gt;altsetting
(braket
id|altset_num
)braket
)paren
suffix:semicolon
singleline_comment|// Is this a communication class of interface of the
singleline_comment|// ethernet subclass variety.
r_if
c_cond
(paren
(paren
id|comm_intf-&gt;bInterfaceClass
op_eq
l_int|0x02
)paren
op_logical_and
(paren
id|comm_intf-&gt;bInterfaceSubClass
op_eq
l_int|0x06
)paren
op_logical_and
(paren
id|comm_intf-&gt;bInterfaceProtocol
op_eq
l_int|0x00
)paren
)paren
(brace
r_if
c_cond
(paren
id|comm_intf-&gt;bNumEndpoints
op_eq
l_int|1
)paren
(brace
singleline_comment|// Good, we found one, we will try this one
singleline_comment|// Fill in the structure...
id|ether_dev-&gt;comm_interface
op_assign
id|intf_num
suffix:semicolon
id|ether_dev-&gt;comm_bInterfaceNumber
op_assign
id|comm_intf-&gt;bInterfaceNumber
suffix:semicolon
id|ether_dev-&gt;comm_interface_altset_num
op_assign
id|altset_num
suffix:semicolon
id|ether_dev-&gt;comm_bAlternateSetting
op_assign
id|comm_intf-&gt;bAlternateSetting
suffix:semicolon
singleline_comment|// Look for the Ethernet Functional Descriptors
id|rc
op_assign
id|find_and_parse_ethernet_class_information
c_func
(paren
id|device
comma
id|ether_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
singleline_comment|// Nope this was no good after all.
r_continue
suffix:semicolon
)brace
singleline_comment|// Check that we really can talk to the data
singleline_comment|// interface 
singleline_comment|// This includes # of endpoints, protocols,
singleline_comment|// etc.
id|rc
op_assign
id|verify_ethernet_data_interface
c_func
(paren
id|device
comma
id|ether_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
singleline_comment|// We got something we didn&squot;t like
r_continue
suffix:semicolon
)brace
singleline_comment|// This communication interface seems to give us everything
singleline_comment|// we require.  We have all the ethernet info we need.
singleline_comment|// Let&squot;s get out of here and go home right now.
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// bNumEndPoints != 1
singleline_comment|// We found an interface that had the wrong number of 
singleline_comment|// endpoints but would have otherwise been okay
)brace
singleline_comment|// end bNumEndpoints check.
)brace
singleline_comment|// end interface specifics check.
)brace
singleline_comment|// end for altset_num
)brace
singleline_comment|// end for intf_num
r_return
op_minus
l_int|1
suffix:semicolon
)brace
singleline_comment|//////////////////////////////////////////////////////////////////////////////
singleline_comment|// Routine to go through all configurations and find one that ////////////////
singleline_comment|// is an Ethernet Networking Device //////////////////////////////////////////
singleline_comment|//////////////////////////////////////////////////////////////////////////////
DECL|function|find_valid_configuration
r_static
r_int
id|find_valid_configuration
c_func
(paren
r_struct
id|usb_device
op_star
id|device
comma
id|ether_dev_t
op_star
id|ether_dev
)paren
(brace
r_struct
id|usb_config_descriptor
op_star
id|conf
op_assign
l_int|NULL
suffix:semicolon
r_int
id|conf_num
suffix:semicolon
r_int
id|rc
suffix:semicolon
singleline_comment|// We will try each and every possible configuration
r_for
c_loop
(paren
id|conf_num
op_assign
l_int|0
suffix:semicolon
id|conf_num
OL
id|device-&gt;descriptor.bNumConfigurations
suffix:semicolon
id|conf_num
op_increment
)paren
(brace
id|conf
op_assign
op_amp
(paren
id|device-&gt;config
(braket
id|conf_num
)braket
)paren
suffix:semicolon
singleline_comment|// Our first requirement : 2 interfaces
r_if
c_cond
(paren
id|conf-&gt;bNumInterfaces
op_ne
l_int|2
)paren
(brace
singleline_comment|// I currently don&squot;t know how to handle devices with any number of interfaces
singleline_comment|// other than 2.
r_continue
suffix:semicolon
)brace
singleline_comment|// This one passed our first check, fill in some 
singleline_comment|// useful data
id|ether_dev-&gt;configuration_num
op_assign
id|conf_num
suffix:semicolon
id|ether_dev-&gt;bConfigurationValue
op_assign
id|conf-&gt;bConfigurationValue
suffix:semicolon
singleline_comment|// Now run it through the ringers and see what comes
singleline_comment|// out the other side.
id|rc
op_assign
id|find_ethernet_comm_interface
c_func
(paren
id|device
comma
id|ether_dev
)paren
suffix:semicolon
singleline_comment|// Check if we found an ethernet Communcation Device
r_if
c_cond
(paren
op_logical_neg
id|rc
)paren
(brace
singleline_comment|// We found one.
r_return
l_int|0
suffix:semicolon
)brace
)brace
singleline_comment|// None of the configurations suited us.
r_return
op_minus
l_int|1
suffix:semicolon
)brace
singleline_comment|//////////////////////////////////////////////////////////////////////////////
singleline_comment|// Routine that checks a given configuration to see if any driver ////////////
singleline_comment|// has claimed any of the devices interfaces /////////////////////////////////
singleline_comment|//////////////////////////////////////////////////////////////////////////////
DECL|function|check_for_claimed_interfaces
r_static
r_int
id|check_for_claimed_interfaces
c_func
(paren
r_struct
id|usb_config_descriptor
op_star
id|config
)paren
(brace
r_struct
id|usb_interface
op_star
id|comm_intf_group
suffix:semicolon
r_int
id|intf_num
suffix:semicolon
singleline_comment|// Go through all the interfaces and make sure none are 
singleline_comment|// claimed by anybody else.
r_for
c_loop
(paren
id|intf_num
op_assign
l_int|0
suffix:semicolon
id|intf_num
OL
id|config-&gt;bNumInterfaces
suffix:semicolon
id|intf_num
op_increment
)paren
(brace
id|comm_intf_group
op_assign
op_amp
(paren
id|config-&gt;interface
(braket
id|intf_num
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_interface_claimed
c_func
(paren
id|comm_intf_group
)paren
)paren
(brace
singleline_comment|// Somebody has beat us to this guy.
singleline_comment|// We can&squot;t change the configuration out from underneath of whoever
singleline_comment|// is using this device, so we will go ahead and give up.
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
singleline_comment|// We made it all the way through.
singleline_comment|// I guess no one has claimed any of these interfaces.
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|//////////////////////////////////////////////////////////////////////////////
singleline_comment|// Routines to ask for and set the kernel network interface&squot;s MAC address ////
singleline_comment|// Used by driver&squot;s probe routine ////////////////////////////////////////////
singleline_comment|//////////////////////////////////////////////////////////////////////////////
DECL|function|hex2dec
r_static
r_inline
r_int
r_char
id|hex2dec
c_func
(paren
r_int
r_char
id|digit
)paren
(brace
singleline_comment|// Is there a standard way to do this???
singleline_comment|// I have written this code TOO MANY times.
r_if
c_cond
(paren
(paren
id|digit
op_ge
l_char|&squot;0&squot;
)paren
op_logical_and
(paren
id|digit
op_le
l_char|&squot;9&squot;
)paren
)paren
(brace
r_return
(paren
id|digit
op_minus
l_char|&squot;0&squot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|digit
op_ge
l_char|&squot;a&squot;
)paren
op_logical_and
(paren
id|digit
op_le
l_char|&squot;f&squot;
)paren
)paren
(brace
r_return
(paren
id|digit
op_minus
l_char|&squot;a&squot;
op_plus
l_int|10
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|digit
op_ge
l_char|&squot;A&squot;
)paren
op_logical_and
(paren
id|digit
op_le
l_char|&squot;F&squot;
)paren
)paren
(brace
r_return
(paren
id|digit
op_minus
l_char|&squot;A&squot;
op_plus
l_int|10
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|set_ethernet_addr
r_static
r_void
id|set_ethernet_addr
c_func
(paren
id|ether_dev_t
op_star
id|ether_dev
)paren
(brace
r_int
r_char
id|mac_addr
(braket
l_int|6
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
r_char
id|buffer
(braket
l_int|13
)braket
suffix:semicolon
singleline_comment|// Let&squot;s assume we don&squot;t get anything...
id|mac_addr
(braket
l_int|0
)braket
op_assign
l_int|0x00
suffix:semicolon
id|mac_addr
(braket
l_int|1
)braket
op_assign
l_int|0x00
suffix:semicolon
id|mac_addr
(braket
l_int|2
)braket
op_assign
l_int|0x00
suffix:semicolon
id|mac_addr
(braket
l_int|3
)braket
op_assign
l_int|0x00
suffix:semicolon
id|mac_addr
(braket
l_int|4
)braket
op_assign
l_int|0x00
suffix:semicolon
id|mac_addr
(braket
l_int|5
)braket
op_assign
l_int|0x00
suffix:semicolon
singleline_comment|// Let&squot;s ask the device...
id|len
op_assign
id|usb_string
c_func
(paren
id|ether_dev-&gt;usb
comma
id|ether_dev-&gt;iMACAddress
comma
id|buffer
comma
l_int|13
)paren
suffix:semicolon
singleline_comment|// Sanity check!
r_if
c_cond
(paren
id|len
op_ne
l_int|12
)paren
(brace
singleline_comment|// You gotta love failing sanity checks
id|err
c_func
(paren
l_string|&quot;Attempting to get MAC address returned %d bytes&quot;
comma
id|len
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
singleline_comment|// Fill in the mac_addr
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mac_addr
(braket
id|i
)braket
op_assign
(paren
id|hex2dec
c_func
(paren
id|buffer
(braket
l_int|2
op_star
id|i
)braket
)paren
op_lshift
l_int|4
)paren
op_plus
id|hex2dec
c_func
(paren
id|buffer
(braket
l_int|2
op_star
id|i
op_plus
l_int|1
)braket
)paren
suffix:semicolon
)brace
singleline_comment|// Now copy it over to the kernel&squot;s network driver.
id|memcpy
c_func
(paren
id|ether_dev-&gt;net-&gt;dev_addr
comma
id|mac_addr
comma
r_sizeof
(paren
id|mac_addr
)paren
)paren
suffix:semicolon
)brace
singleline_comment|//////////////////////////////////////////////////////////////////////////////
singleline_comment|// Routine to print to syslog information about the driver ///////////////////
singleline_comment|// Used by driver&squot;s probe routine ////////////////////////////////////////////
singleline_comment|//////////////////////////////////////////////////////////////////////////////
DECL|function|log_device_info
r_void
id|log_device_info
c_func
(paren
id|ether_dev_t
op_star
id|ether_dev
)paren
(brace
r_int
id|len
suffix:semicolon
r_int
id|string_num
suffix:semicolon
r_int
r_char
id|manu
(braket
l_int|256
)braket
suffix:semicolon
r_int
r_char
id|prod
(braket
l_int|256
)braket
suffix:semicolon
r_int
r_char
id|sern
(braket
l_int|256
)braket
suffix:semicolon
r_int
r_char
op_star
id|mac_addr
suffix:semicolon
singleline_comment|// Default empty strings in case we don&squot;t find a real one
id|manu
(braket
l_int|0
)braket
op_assign
l_int|0x00
suffix:semicolon
id|prod
(braket
l_int|0
)braket
op_assign
l_int|0x00
suffix:semicolon
id|sern
(braket
l_int|0
)braket
op_assign
l_int|0x00
suffix:semicolon
singleline_comment|// Try to get the device Manufacturer
id|string_num
op_assign
id|ether_dev-&gt;usb-&gt;descriptor.iManufacturer
suffix:semicolon
r_if
c_cond
(paren
id|string_num
)paren
(brace
singleline_comment|// Put it into its buffer
id|len
op_assign
id|usb_string
c_func
(paren
id|ether_dev-&gt;usb
comma
id|string_num
comma
id|manu
comma
l_int|255
)paren
suffix:semicolon
singleline_comment|// Just to be safe
id|manu
(braket
id|len
)braket
op_assign
l_int|0x00
suffix:semicolon
)brace
singleline_comment|// Try to get the device Product Name
id|string_num
op_assign
id|ether_dev-&gt;usb-&gt;descriptor.iProduct
suffix:semicolon
r_if
c_cond
(paren
id|string_num
)paren
(brace
singleline_comment|// Put it into its buffer
id|len
op_assign
id|usb_string
c_func
(paren
id|ether_dev-&gt;usb
comma
id|string_num
comma
id|prod
comma
l_int|255
)paren
suffix:semicolon
singleline_comment|// Just to be safe
id|prod
(braket
id|len
)braket
op_assign
l_int|0x00
suffix:semicolon
)brace
singleline_comment|// Try to get the device Serial Number
id|string_num
op_assign
id|ether_dev-&gt;usb-&gt;descriptor.iSerialNumber
suffix:semicolon
r_if
c_cond
(paren
id|string_num
)paren
(brace
singleline_comment|// Put it into its buffer
id|len
op_assign
id|usb_string
c_func
(paren
id|ether_dev-&gt;usb
comma
id|string_num
comma
id|sern
comma
l_int|255
)paren
suffix:semicolon
singleline_comment|// Just to be safe
id|sern
(braket
id|len
)braket
op_assign
l_int|0x00
suffix:semicolon
)brace
singleline_comment|// This makes it easier for us to print
id|mac_addr
op_assign
id|ether_dev-&gt;net-&gt;dev_addr
suffix:semicolon
singleline_comment|// Now send everything we found to the syslog
id|info
c_func
(paren
l_string|&quot;%s: %s %s %s %02X:%02X:%02X:%02X:%02X:%02X&quot;
comma
id|ether_dev-&gt;net-&gt;name
comma
id|manu
comma
id|prod
comma
id|sern
comma
id|mac_addr
(braket
l_int|0
)braket
comma
id|mac_addr
(braket
l_int|1
)braket
comma
id|mac_addr
(braket
l_int|2
)braket
comma
id|mac_addr
(braket
l_int|3
)braket
comma
id|mac_addr
(braket
l_int|4
)braket
comma
id|mac_addr
(braket
l_int|5
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Forward declaration */
DECL|variable|CDCEther_driver
r_static
r_struct
id|usb_driver
id|CDCEther_driver
suffix:semicolon
singleline_comment|//////////////////////////////////////////////////////////////////////////////
singleline_comment|// Module&squot;s probe routine ////////////////////////////////////////////////////
singleline_comment|// claims interfaces if they are for an Ethernet CDC /////////////////////////
singleline_comment|//////////////////////////////////////////////////////////////////////////////
DECL|function|CDCEther_probe
r_static
r_void
op_star
id|CDCEther_probe
c_func
(paren
r_struct
id|usb_device
op_star
id|usb
comma
r_int
r_int
id|ifnum
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
(brace
r_struct
id|net_device
op_star
id|net
suffix:semicolon
id|ether_dev_t
op_star
id|ether_dev
suffix:semicolon
r_int
id|rc
suffix:semicolon
singleline_comment|// First we should check the active configuration to see if 
singleline_comment|// any other driver has claimed any of the interfaces.
r_if
c_cond
(paren
id|check_for_claimed_interfaces
c_func
(paren
id|usb-&gt;actconfig
)paren
)paren
(brace
singleline_comment|// Someone has already put there grubby paws on this device.
singleline_comment|// We don&squot;t want it now...
r_return
l_int|NULL
suffix:semicolon
)brace
singleline_comment|// We might be finding a device we can use.
singleline_comment|// We all go ahead and allocate our storage space.
singleline_comment|// We need to because we have to start filling in the data that
singleline_comment|// we are going to need later.
r_if
c_cond
(paren
op_logical_neg
(paren
id|ether_dev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|ether_dev_t
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;out of memory allocating device structure&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
singleline_comment|// Zero everything out.
id|memset
c_func
(paren
id|ether_dev
comma
l_int|0
comma
r_sizeof
(paren
id|ether_dev_t
)paren
)paren
suffix:semicolon
singleline_comment|// Let&squot;s see if we can find a configuration we can use.
id|rc
op_assign
id|find_valid_configuration
c_func
(paren
id|usb
comma
id|ether_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
singleline_comment|// Nope we couldn&squot;t find one we liked.
singleline_comment|// This device was not meant for us to control.
id|kfree
c_func
(paren
id|ether_dev
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
singleline_comment|// Now that we FOUND a configuration. let&squot;s try to make the 
singleline_comment|// device go into it.
r_if
c_cond
(paren
id|usb_set_configuration
c_func
(paren
id|usb
comma
id|ether_dev-&gt;bConfigurationValue
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;usb_set_configuration() failed&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ether_dev
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
singleline_comment|// Now set the communication interface up as required.
r_if
c_cond
(paren
id|usb_set_interface
c_func
(paren
id|usb
comma
id|ether_dev-&gt;comm_bInterfaceNumber
comma
id|ether_dev-&gt;comm_bAlternateSetting
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;usb_set_interface() failed&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ether_dev
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
singleline_comment|// Only turn traffic on right now if we must...
r_if
c_cond
(paren
id|ether_dev-&gt;data_interface_altset_num_without_traffic
op_ge
l_int|0
)paren
(brace
singleline_comment|// We found an alternate setting for the data
singleline_comment|// interface that allows us to turn off traffic.
singleline_comment|// We should use it.
r_if
c_cond
(paren
id|usb_set_interface
c_func
(paren
id|usb
comma
id|ether_dev-&gt;data_bInterfaceNumber
comma
id|ether_dev-&gt;data_bAlternateSetting_without_traffic
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;usb_set_interface() failed&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ether_dev
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
(brace
singleline_comment|// We didn&squot;t find an alternate setting for the data
singleline_comment|// interface that would let us turn off traffic.
singleline_comment|// Oh well, let&squot;s go ahead and do what we must...
r_if
c_cond
(paren
id|usb_set_interface
c_func
(paren
id|usb
comma
id|ether_dev-&gt;data_bInterfaceNumber
comma
id|ether_dev-&gt;data_bAlternateSetting_with_traffic
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;usb_set_interface() failed&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ether_dev
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
singleline_comment|// Now we need to get a kernel Ethernet interface.
id|net
op_assign
id|init_etherdev
c_func
(paren
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|net
)paren
(brace
singleline_comment|// Hmm...  The kernel is not sharing today...
singleline_comment|// Fine, we didn&squot;t want it anyway...
id|err
c_func
(paren
l_string|&quot;Unable to initialize ethernet device&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ether_dev
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
singleline_comment|// Now that we have an ethernet device, let&squot;s set it up
singleline_comment|// (And I don&squot;t mean &quot;set [it] up the bomb&quot;.)
id|net-&gt;priv
op_assign
id|ether_dev
suffix:semicolon
id|net-&gt;open
op_assign
id|CDCEther_open
suffix:semicolon
id|net-&gt;stop
op_assign
id|CDCEther_close
suffix:semicolon
id|net-&gt;watchdog_timeo
op_assign
id|CDC_ETHER_TX_TIMEOUT
suffix:semicolon
id|net-&gt;tx_timeout
op_assign
id|CDCEther_tx_timeout
suffix:semicolon
singleline_comment|// TX timeout function
id|net-&gt;do_ioctl
op_assign
id|CDCEther_ioctl
suffix:semicolon
id|net-&gt;hard_start_xmit
op_assign
id|CDCEther_start_xmit
suffix:semicolon
id|net-&gt;set_multicast_list
op_assign
id|CDCEther_set_multicast
suffix:semicolon
id|net-&gt;get_stats
op_assign
id|CDCEther_netdev_stats
suffix:semicolon
id|net-&gt;mtu
op_assign
id|ether_dev-&gt;wMaxSegmentSize
op_minus
l_int|14
suffix:semicolon
singleline_comment|// We&squot;ll keep track of this information for later...
id|ether_dev-&gt;usb
op_assign
id|usb
suffix:semicolon
id|ether_dev-&gt;net
op_assign
id|net
suffix:semicolon
singleline_comment|// and don&squot;t forget the MAC address.
id|set_ethernet_addr
c_func
(paren
id|ether_dev
)paren
suffix:semicolon
singleline_comment|// Send a message to syslog about what we are handling
id|log_device_info
c_func
(paren
id|ether_dev
)paren
suffix:semicolon
singleline_comment|// I claim this interface to be a CDC Ethernet Networking device
id|usb_driver_claim_interface
c_func
(paren
op_amp
id|CDCEther_driver
comma
op_amp
(paren
id|usb-&gt;config
(braket
id|ether_dev-&gt;configuration_num
)braket
dot
id|interface
(braket
id|ether_dev-&gt;comm_interface
)braket
)paren
comma
id|ether_dev
)paren
suffix:semicolon
singleline_comment|// I claim this interface to be a CDC Ethernet Networking device
id|usb_driver_claim_interface
c_func
(paren
op_amp
id|CDCEther_driver
comma
op_amp
(paren
id|usb-&gt;config
(braket
id|ether_dev-&gt;configuration_num
)braket
dot
id|interface
(braket
id|ether_dev-&gt;data_interface
)braket
)paren
comma
id|ether_dev
)paren
suffix:semicolon
singleline_comment|// Does this REALLY do anything???
id|usb_inc_dev_use
c_func
(paren
id|usb
)paren
suffix:semicolon
singleline_comment|// TODO - last minute HACK
id|ether_dev-&gt;comm_ep_in
op_assign
l_int|5
suffix:semicolon
singleline_comment|// Okay, we are finally done...
r_return
l_int|NULL
suffix:semicolon
)brace
singleline_comment|//////////////////////////////////////////////////////////////////////////////
singleline_comment|// Module&squot;s disconnect routine ///////////////////////////////////////////////
singleline_comment|// Called when the driver is unloaded or the device is unplugged /////////////
singleline_comment|// (Whichever happens first assuming the driver suceeded at its probe) ///////
singleline_comment|//////////////////////////////////////////////////////////////////////////////
DECL|function|CDCEther_disconnect
r_static
r_void
id|CDCEther_disconnect
c_func
(paren
r_struct
id|usb_device
op_star
id|usb
comma
r_void
op_star
id|ptr
)paren
(brace
id|ether_dev_t
op_star
id|ether_dev
op_assign
id|ptr
suffix:semicolon
singleline_comment|// Sanity check!!!
r_if
c_cond
(paren
op_logical_neg
id|ether_dev
op_logical_or
op_logical_neg
id|ether_dev-&gt;usb
)paren
(brace
singleline_comment|// We failed.  We are insane!!!
id|warn
c_func
(paren
l_string|&quot;unregistering non-existant device&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
singleline_comment|// Make sure we fail the sanity check if we try this again.
id|ether_dev-&gt;usb
op_assign
l_int|NULL
suffix:semicolon
singleline_comment|// It is possible that this function is called before
singleline_comment|// the &quot;close&quot; function.
singleline_comment|// This tells the close function we are already disconnected
id|ether_dev-&gt;flags
op_or_assign
id|CDC_ETHER_UNPLUG
suffix:semicolon
singleline_comment|// We don&squot;t need the network device any more
id|unregister_netdev
c_func
(paren
id|ether_dev-&gt;net
)paren
suffix:semicolon
singleline_comment|// For sanity checks
id|ether_dev-&gt;net
op_assign
l_int|NULL
suffix:semicolon
singleline_comment|// I ask again, does this do anything???
id|usb_dec_dev_use
c_func
(paren
id|usb
)paren
suffix:semicolon
singleline_comment|// We are done with this interface
id|usb_driver_release_interface
c_func
(paren
op_amp
id|CDCEther_driver
comma
op_amp
(paren
id|usb-&gt;config
(braket
id|ether_dev-&gt;configuration_num
)braket
dot
id|interface
(braket
id|ether_dev-&gt;comm_interface
)braket
)paren
)paren
suffix:semicolon
singleline_comment|// We are done with this interface too
id|usb_driver_release_interface
c_func
(paren
op_amp
id|CDCEther_driver
comma
op_amp
(paren
id|usb-&gt;config
(braket
id|ether_dev-&gt;configuration_num
)braket
dot
id|interface
(braket
id|ether_dev-&gt;data_interface
)braket
)paren
)paren
suffix:semicolon
singleline_comment|// No more tied up kernel memory
id|kfree
c_func
(paren
id|ether_dev
)paren
suffix:semicolon
singleline_comment|// This does no good, but it looks nice!
id|ether_dev
op_assign
l_int|NULL
suffix:semicolon
)brace
singleline_comment|//////////////////////////////////////////////////////////////////////////////
singleline_comment|// Driver info ///////////////////////////////////////////////////////////////
singleline_comment|//////////////////////////////////////////////////////////////////////////////
DECL|variable|CDCEther_driver
r_static
r_struct
id|usb_driver
id|CDCEther_driver
op_assign
(brace
id|name
suffix:colon
l_string|&quot;CDCEther&quot;
comma
id|probe
suffix:colon
id|CDCEther_probe
comma
id|disconnect
suffix:colon
id|CDCEther_disconnect
comma
id|id_table
suffix:colon
id|CDCEther_ids
comma
)brace
suffix:semicolon
singleline_comment|//////////////////////////////////////////////////////////////////////////////
singleline_comment|// init and exit routines called when driver is installed and uninstalled ////
singleline_comment|//////////////////////////////////////////////////////////////////////////////
DECL|function|CDCEther_init
r_int
id|__init
id|CDCEther_init
c_func
(paren
r_void
)paren
(brace
id|info
c_func
(paren
l_string|&quot;%s&quot;
comma
id|version
)paren
suffix:semicolon
r_return
id|usb_register
c_func
(paren
op_amp
id|CDCEther_driver
)paren
suffix:semicolon
)brace
DECL|function|CDCEther_exit
r_void
id|__exit
id|CDCEther_exit
c_func
(paren
r_void
)paren
(brace
id|usb_deregister
c_func
(paren
op_amp
id|CDCEther_driver
)paren
suffix:semicolon
)brace
singleline_comment|//////////////////////////////////////////////////////////////////////////////
singleline_comment|// Module info ///////////////////////////////////////////////////////////////
singleline_comment|//////////////////////////////////////////////////////////////////////////////
DECL|variable|CDCEther_init
id|module_init
c_func
(paren
id|CDCEther_init
)paren
suffix:semicolon
DECL|variable|CDCEther_exit
id|module_exit
c_func
(paren
id|CDCEther_exit
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Brad Hards and another&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;USB CDC Ethernet driver&quot;
)paren
suffix:semicolon
id|MODULE_DEVICE_TABLE
(paren
id|usb
comma
id|CDCEther_ids
)paren
suffix:semicolon
singleline_comment|//////////////////////////////////////////////////////////////////////////////
singleline_comment|// End of file ///////////////////////////////////////////////////////////////
singleline_comment|//////////////////////////////////////////////////////////////////////////////
eof
