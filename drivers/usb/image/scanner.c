multiline_comment|/* -*- linux-c -*- */
multiline_comment|/* &n; * Driver for USB Scanners (linux-2.4.18)&n; *&n; * Copyright (C) 1999, 2000, 2001, 2002 David E. Nelson&n; *&n; * Portions may be copyright Brad Keryan and Michael Gee.&n; *&n; * Brian Beattie &lt;beattie@beattie-home.net&gt;&n; * &n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License as&n; * published by the Free Software Foundation; either version 2 of the&n; * License, or (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; * Originally based upon mouse.c (Brad Keryan) and printer.c (Michael Gee).&n; *&n; * History&n; *&n; *  0.1  8/31/1999&n; *&n; *    Developed/tested using linux-2.3.15 with minor ohci.c changes to&n; *    support short packes during bulk xfer mode.  Some testing was&n; *    done with ohci-hcd but the performace was low.  Very limited&n; *    testing was performed with uhci but I was unable to get it to&n; *    work.  Initial relase to the linux-usb development effort.&n; *&n; *&n; *  0.2  10/16/1999&n; *&n; *    - Device can&squot;t be opened unless a scanner is plugged into the USB.&n; *    - Finally settled on a reasonable value for the I/O buffer&squot;s.&n; *    - Cleaned up write_scanner()&n; *    - Disabled read/write stats&n; *    - A little more code cleanup&n; *&n; *&n; *  0.3  10/18/1999&n; *&n; *    - Device registration changed to reflect new device&n; *      allocation/registration for linux-2.3.22+.&n; *    - Adopted David Brownell&squot;s &lt;david-b@pacbell.net&gt; technique for &n; *      assigning bulk endpoints.&n; *    - Removed unnessesary #include&squot;s&n; *    - Scanner model now reported via syslog INFO after being detected &n; *      *and* configured.&n; *    - Added user specified vendor:product USB ID&squot;s which can be passed &n; *      as module parameters.&n; *&n; *&n; *  0.3.1&n; *&n; *    - Applied patches for linux-2.3.25.&n; *    - Error number reporting changed to reflect negative return codes.&n; *&n; *&n; *  0.3.2&n; *&n; *    - Applied patches for linux-2.3.26 to scanner_init().&n; *    - Debug read/write stats now report values as signed decimal.&n; *&n; *&n; *  0.3.3&n; *&n; *    - Updated the bulk_msg() calls to usb usb_bulk_msg().&n; *    - Added a small delay in the write_scanner() method to aid in&n; *      avoiding NULL data reads on HP scanners.  We&squot;ll see how this works.&n; *    - Return values from usb_bulk_msg() now ignore positive values for&n; *      use with the ohci driver.&n; *    - Added conditional debugging instead of commenting/uncommenting&n; *      all over the place.&n; *    - kfree()&squot;d the pointer after using usb_string() as documented in&n; *      linux-usb-api.txt.&n; *    - Added usb_set_configuration().  It got lost in version 0.3 -- ack!&n; *    - Added the HP 5200C USB Vendor/Product ID&squot;s.&n; *&n; *&n; *  0.3.4  1/23/2000&n; *&n; *    - Added Greg K-H&squot;s &lt;greg@kroah.com&gt; patch for better handling of &n; *      Product/Vendor detection.&n; *    - The driver now autoconfigures its endpoints including interrupt&n; *      endpoints if one is detected.  The concept was originally based&n; *      upon David Brownell&squot;s method.&n; *    - Added some Seiko/Epson ID&squot;s. Thanks to Karl Heinz &n; *      Kremer &lt;khk@khk.net&gt;.&n; *    - Added some preliminary ioctl() calls for the PV8630 which is used&n; *      by the HP4200. The ioctl()&squot;s still have to be registered. Thanks &n; *      to Adrian Perez Jorge &lt;adrianpj@easynews.com&gt;.&n; *    - Moved/migrated stuff to scanner.h&n; *    - Removed the usb_set_configuration() since this is handled by&n; *      the usb_new_device() routine in usb.c.&n; *    - Added the HP 3300C.  Thanks to Bruce Tenison.&n; *    - Changed user specified vendor/product id so that root hub doesn&squot;t&n; *      get falsely attached to. Thanks to Greg K-H.&n; *    - Added some Mustek ID&squot;s. Thanks to Gernot Hoyler &n; *      &lt;Dr.Hoyler@t-online.de&gt;.&n; *    - Modified the usb_string() reporting.  See kfree() comment above.&n; *    - Added Umax Astra 2000U. Thanks to Doug Alcorn &lt;doug@lathi.net&gt;.&n; *    - Updated the printk()&squot;s to use the info/warn/dbg macros.&n; *    - Updated usb_bulk_msg() argument types to fix gcc warnings.&n; *&n; *&n; *  0.4  2/4/2000&n; *&n; *    - Removed usb_string() from probe_scanner since the core now does a&n; *      good job of reporting what was connnected.  &n; *    - Finally, simultaneous multiple device attachment!&n; *    - Fixed some potential memory freeing issues should memory allocation&n; *      fail in probe_scanner();&n; *    - Some fixes to disconnect_scanner().&n; *    - Added interrupt endpoint support.&n; *    - Added Agfa SnapScan Touch. Thanks to Jan Van den Bergh&n; *      &lt;jan.vandenbergh@cs.kuleuven.ac.be&gt;.&n; *    - Added Umax 1220U ID&squot;s. Thanks to Maciek Klimkowski&n; *      &lt;mac@nexus.carleton.ca&gt;.&n; *    - Fixed bug in write_scanner(). The buffer was not being properly&n; *      updated for writes larger than OBUF_SIZE. Thanks to Henrik &n; *      Johansson &lt;henrikjo@post.utfors.se&gt; for identifying it.&n; *    - Added Microtek X6 ID&squot;s. Thanks to Oliver Neukum&n; *      &lt;Oliver.Neukum@lrz.uni-muenchen.de&gt;.&n; *&n; * &n; *  0.4.1  2/15/2000&n; *  &n; *    - Fixed &squot;count&squot; bug in read_scanner(). Thanks to Henrik&n; *      Johansson &lt;henrikjo@post.utfors.se&gt; for identifying it.  Amazing&n; *      it has worked this long.&n; *    - Fixed &squot;&gt;=&squot; bug in both read/write_scanner methods.&n; *    - Cleaned up both read/write_scanner() methods so that they are &n; *      a little more readable.&n; *    - Added a lot of Microtek ID&squot;s.  Thanks to Adrian Perez Jorge.&n; *    - Adopted the __initcall().&n; *    - Added #include &lt;linux/init.h&gt; to scanner.h for __initcall().&n; *    - Added one liner in irq_scanner() to keep gcc from complaining &n; *      about an unused variable (data) if debugging was disabled&n; *      in scanner.c.&n; *    - Increased the timeout parameter in read_scanner() to 120 Secs.&n; *&n; *&n; *  0.4.2  3/23/2000&n; *&n; *    - Added Umax 1236U ID.  Thanks to Philipp Baer &lt;ph_baer@npw.net&gt;.&n; *    - Added Primax, ReadyScan, Visioneer, Colorado, and Genius ID&squot;s.&n; *      Thanks to Adrian Perez Jorge &lt;adrianpj@easynews.com&gt;.&n; *    - Fixed error number reported for non-existant devices.  Thanks to&n; *      Spyridon Papadimitriou &lt;Spyridon_Papadimitriou@gs91.sp.cs.cmu.edu&gt;.&n; *    - Added Acer Prisascan 620U ID&squot;s.  Thanks to Joao &lt;joey@knoware.nl&gt;.&n; *    - Replaced __initcall() with module_init()/module_exit(). Updates&n; *      from patch-2.3.48.&n; *    - Replaced file_operations structure with new syntax.  Updates&n; *      from patch-2.3.49.&n; *    - Changed #include &quot;usb.h&quot; to #include &lt;linux/usb.h&gt;&n; *    - Added #define SCN_IOCTL to exclude development areas &n; *      since 2.4.x is about to be released. This mainly affects the &n; *      ioctl() stuff.  See scanner.h for more details.&n; *    - Changed the return value for signal_pending() from -ERESTARTSYS to&n; *      -EINTR.&n; *&n; *&n; * 0.4.3  4/30/2000&n; *&n; *    - Added Umax Astra 2200 ID.  Thanks to Flynn Marquardt &n; *      &lt;flynn@isr.uni-stuttgart.de&gt;.&n; *    - Added iVina 1200U ID. Thanks to Dyson Lin &lt;dyson@avision.com.tw&gt;.&n; *    - Added access time update for the device file courtesy of Paul&n; *      Mackerras &lt;paulus@samba.org&gt;.  This allows a user space daemon&n; *      to turn the lamp off for a Umax 1220U scanner after a prescribed&n; *      time.&n; *    - Fixed HP S20 ID&squot;s.  Thanks to Ruud Linders &lt;rlinders@xs4all.nl&gt;.&n; *    - Added Acer ScanPrisa 620U ID. Thanks to Oliver&n; *      Schwartz &lt;Oliver.Schwartz@gmx.de&gt; via sane-devel mail list.&n; *    - Fixed bug in read_scanner for copy_to_user() function.  The returned&n; *      value should be &squot;partial&squot; not &squot;this_read&squot;.&n; *    - Fixed bug in read_scanner. &squot;count&squot; should be decremented &n; *      by &squot;this_read&squot; and not by &squot;partial&squot;.  This resulted in twice as many&n; *      calls to read_scanner() for small amounts of data and possibly&n; *      unexpected returns of &squot;0&squot;.  Thanks to Karl Heinz &n; *      Kremer &lt;khk@khk.net&gt; and Alain Knaff &lt;Alain.Knaff@ltnb.lu&gt;&n; *      for discovering this.&n; *    - Integrated Randy Dunlap&squot;s &lt;randy.dunlap@intel.com&gt; patch for a&n; *      scanner lookup/ident table. Thanks Randy.&n; *    - Documentation updates.&n; *    - Added wait queues to read_scanner().&n; *&n; *&n; * 0.4.3.1&n; *&n; *    - Fixed HP S20 ID&squot;s...again..sigh.  Thanks to Ruud&n; *      Linders &lt;rlinders@xs4all.nl&gt;.&n; *&n; * 0.4.4&n; *    - Added addtional Mustek ID&squot;s (BearPaw 1200, 600 CU, 1200 USB,&n; *      and 1200 UB.  Thanks to Henning Meier-Geinitz &lt;henningmg@gmx.de&gt;.&n; *    - Added the Vuego Scan Brisa 340U ID&squot;s.  Apparently this scanner is&n; *      marketed by Acer Peripherals as a cheap 300 dpi model. Thanks to&n; *      David Gundersen &lt;gundersd@paradise.net.nz&gt;.&n; *    - Added the Epson Expression1600 ID&squot;s. Thanks to Karl Heinz&n; *      Kremer &lt;khk@khk.net&gt;.&n; *&n; * 0.4.5  2/28/2001&n; *    - Added Mustek ID&squot;s (BearPaw 2400, 1200 CU Plus, BearPaw 1200F).&n; *      Thanks to Henning Meier-Geinitz &lt;henningmg@gmx.de&gt;.&n; *    - Added read_timeout module parameter to override RD_NAK_TIMEOUT&n; *      when read()&squot;ing from devices.&n; *    - Stalled pipes are now checked and cleared with&n; *      usb_clear_halt() for the read_scanner() function. This should&n; *      address the &quot;funky result: -32&quot; error messages.&n; *    - Removed Microtek scanner ID&squot;s.  Microtek scanners are now&n; *      supported via the drivers/usb/microtek.c driver.&n; *    - Added scanner specific read timeout&squot;s.&n; *    - Return status errors are NEGATIVE!!!  This should address the&n; *      &quot;funky result: -110&quot; error messages.&n; *    - Replaced USB_ST_TIMEOUT with ETIMEDOUT.&n; *    - rd_nak was still defined in MODULE_PARM.  It&squot;s been updated with&n; *      read_timeout.  Thanks to Mark W. Webb &lt;markwebb@adelphia.net&gt; for&n; *      reporting this bug.&n; *    - Added Epson Perfection 1640SU and 1640SU Photo.  Thanks to&n; *      Jean-Luc &lt;f5ibh@db0bm.ampr.org&gt; and Manuel&n; *      Pelayo &lt;Manuel.Pelayo@sesips.org&gt;. Reported to work fine by Manuel.&n; *&n; * 0.4.6  9/27/2001&n; *    - Added IOCTL&squot;s to report back scanner USB ID&squot;s.  Thanks to&n; *      Karl Heinz &lt;khk@lynx.phpwebhosting.com&gt;&n; *    - Added Umax Astra 2100U ID&squot;s.  Thanks to Ron&n; *      Wellsted &lt;ron@wellsted.org.uk&gt;.&n; *      and Manuel Pelayo &lt;Manuel.Pelayo@sesips.org&gt;.&n; *    - Added HP 3400 ID&squot;s. Thanks to Harald Hannelius &lt;harald@iki.fi&gt;&n; *      and Bertrik Sikken &lt;bertrik@zonnet.nl&gt;.  Reported to work at&n; *      htpp://home.zonnet.nl/bertrik/hp3300c/hp3300c.htm.&n; *    - Added Minolta Dimage Scan Dual II ID&squot;s.  Thanks to Jose Paulo&n; *      Moitinho de Almeida &lt;moitinho@civil.ist.utl.pt&gt;&n; *    - Confirmed addition for SnapScan E20.  Thanks to Steffen H&#xfffd;bner&n; *      &lt;hueb_s@gmx.de&gt;.&n; *    - Added Lifetec LT9385 ID&squot;s.  Thanks to Van Bruwaene Kris&n; *      &lt;krvbr@yahoo.co.uk&gt;&n; *    - Added Agfa SnapScan e26 ID&squot;s.  Reported to work with SANE&n; *      1.0.5.  Thanks to Falk Sauer &lt;falk@mgnkatze.franken.de&gt;.&n; *    - Added HP 4300 ID&squot;s.  Thanks to Stefan Schlosser&n; *      &lt;castla@grmmbl.org&gt;.&n; *    - Added Relisis Episode ID&squot;s.  Thanks to Manfred&n; *      Morgner &lt;odb-devel@gmx.net&gt;.&n; *    - Added many Acer ID&squot;s. Thanks to Oliver&n; *      Schwartz &lt;Oliver.Schwartz@gmx.de&gt;.&n; *    - Added Snapscan e40 ID&squot;s.  Thanks to Oliver&n; *      Schwartz &lt;Oliver.Schwartz@gmx.de&gt;.&n; *    - Thanks to Oliver Neukum &lt;Oliver.Neukum@lrz.uni-muenchen.de&gt;&n; *      for helping with races.&n; *    - Added Epson Perfection 1650 ID&squot;s. Thanks to Karl Heinz&n; *      Kremer &lt;khk@khk.net&gt;.&n; *    - Added Epson Perfection 2450 ID&squot;s (aka GT-9700 for the Japanese&n; *      market).  Thanks to Karl Heinz Kremer &lt;khk@khk.net&gt;.&n; *    - Added Mustek 600 USB ID&squot;s.  Thanks to Marcus&n; *      Alanen &lt;maalanen@ra.abo.fi&gt;.&n; *    - Added Acer ScanPrisa 1240UT ID&squot;s.  Thanks to Morgan&n; *      Collins &lt;sirmorcant@morcant.org&gt;.&n; *    - Incorporated devfs patches!! Thanks to Tom Rini&n; *      &lt;trini@kernel.crashing.org&gt;, Pavel Roskin &lt;proski@gnu.org&gt;,&n; *      Greg KH &lt;greg@kroah.com&gt;, Yves Duret &lt;yduret@mandrakesoft.com&gt;,&n; *      Flavio Stanchina &lt;flavio.stanchina@tin.it&gt;.&n; *    - Removed Minolta ScanImage II.  This scanner uses USB SCSI.  Thanks&n; *      to Oliver Neukum &lt;Oliver.Neukum@lrz.uni-muenchen.de&gt; for pointing&n; *      this out.&n; *    - Added additional SMP locking.  Thanks to David Brownell and &n; *      Oliver Neukum for their help.&n; *    - Added version reporting - reports for both module load and modinfo&n; *    - Started path to hopefully straighten/clean out ioctl()&squot;s.&n; *    - Users are now notified to consult the Documentation/usb/scanner.txt&n; *      for common error messages rather than the maintainer.&n; *&n; * 0.4.7  11/28/2001&n; *    - Fixed typo in Documentation/scanner.txt.  Thanks to&n; *      Karel &lt;karel.vervaeke@pandora.be&gt; for pointing it out.&n; *    - Added ID&squot;s for a Memorex 6136u. Thanks to &#xfffd;lvaro Gaspar de&n; *      Valenzuela&quot; &lt;agaspard@utsi.edu&gt;.&n; *    - Added ID&squot;s for Agfa e25.  Thanks to Heinrich &n; *      Rust &lt;Heinrich.Rust@gmx.de&gt;.  Also reported to work with&n; *      Linux and SANE (?).&n; *    - Added Canon FB620U, D646U, and 1220U ID&squot;s.  Thanks to Paul&n; *      Rensing &lt;Paul_Rensing@StanfordAlumni.org&gt;.  For more info&n; *      on Linux support for these models, contact &n; *      salvestrini@users.sourceforge.net.&n; *    - Added Plustek OpticPro UT12, OpticPro U24, KYE/Genius&n; *      ColorPage-HR6 V2 ID&squot;s in addition to many &quot;Unknown&quot; models&n; *      under those vendors.  Thanks to&n; *      Jaeger, Gerhard&quot; &lt;g.jaeger@earthling.net&gt;.  These scanner are&n; *      apparently based upon the LM983x IC&squot;s.&n; *    - Applied Frank&squot;s patch that addressed some locking and module&n; *      referencing counts.  Thanks to both&n; *      Frank Zago &lt;fzago@greshamstorage.com&gt; and&n; *      Oliver Neukum &lt;520047054719-0001@t-online.de&gt; for reviewing/testing.&n; *&n; * 05/21/02 Currently maintained by Brian Beattie &lt;beattie@beattie-home.net&gt;&n; *&n; * 0.4.8  5/30/2002&n; *    - Added Mustek BearPaw 2400 TA.  Thanks to Sergey&n; *      Vlasov &lt;vsu@mivlgu.murom.ru&gt;.&n; *    - Added Mustek 1200UB Plus and Mustek BearPaw 1200 CU ID&squot;s.  These use&n; *      the Grandtech GT-6801 chip. Thanks to Henning&n; *      Meier-Geinitz &lt;henning@meier-geinitz.de&gt;.&n; *    - Increased Epson timeout to 60 secs as requested from &n; *      Karl Heinz Kremer &lt;khk@khk.net&gt;.&n; *    - Changed maintainership from David E. Nelson to Brian&n; *      Beattie &lt;beattie@beattie-home.net&gt;.&n; *&n; * TODO&n; *    - Remove the 2/3 endpoint limitation&n; *    - Performance&n; *    - Select/poll methods&n; *    - More testing&n; *    - Proper registry/assignment for LM9830 ioctl&squot;s&n; *    - More general usage ioctl&squot;s&n; *&n; *&n; *  Thanks to:&n; *&n; *    - All the folks on the linux-usb list who put up with me. :)  This &n; *      has been a great learning experience for me.&n; *    - To Linus Torvalds for this great OS.&n; *    - The GNU folks.&n; *    - The folks that forwarded Vendor:Product ID&squot;s to me.&n; *    - Johannes Erdfelt for the loaning of a USB analyzer for tracking an&n; *      issue with HP-4100 and uhci.&n; *    - Adolfo Montero for his assistance.&n; *    - All the folks who chimed in with reports and suggestions.&n; *    - All the developers that are working on USB SANE backends or other&n; *      applications to use USB scanners.&n; *    - Thanks to Greg KH &lt;greg@kroah.com&gt; for setting up Brian Beattie&n; *      to be the new USB Scanner maintainer.&n; *&n; *  Performance:&n; *&n; *    System: Pentium 120, 80 MB RAM, OHCI, Linux 2.3.23, HP 4100C USB Scanner&n; *            300 dpi scan of the entire bed&n; *      24 Bit Color ~ 70 secs - 3.6 Mbit/sec&n; *       8 Bit Gray ~ 17 secs - 4.2 Mbit/sec */
macro_line|#include &lt;asm/byteorder.h&gt;
multiline_comment|/* &n; * Scanner definitions, macros, module info, &n; * debug/ioctl/data_dump enable, and other constants.&n; */
macro_line|#include &quot;scanner.h&quot;
r_static
r_void
DECL|function|irq_scanner
id|irq_scanner
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
multiline_comment|/*&n; * For the meantime, this is just a placeholder until I figure out what&n; * all I want to do with it -- or somebody else for that matter.&n; */
r_struct
id|scn_usb_data
op_star
id|scn
suffix:semicolon
r_int
r_char
op_star
id|data
suffix:semicolon
id|scn
op_assign
id|urb-&gt;context
suffix:semicolon
id|data
op_assign
op_amp
id|scn-&gt;button
suffix:semicolon
id|data
op_add_assign
l_int|0
suffix:semicolon
multiline_comment|/* Keep gcc from complaining about unused var */
r_if
c_cond
(paren
id|urb-&gt;status
)paren
(brace
r_return
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;irq_scanner(%d): data:%x&quot;
comma
id|scn-&gt;scn_minor
comma
op_star
id|data
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_int
DECL|function|open_scanner
id|open_scanner
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|scn_usb_data
op_star
id|scn
suffix:semicolon
r_struct
id|usb_device
op_star
id|dev
suffix:semicolon
r_int
id|scn_minor
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|down
c_func
(paren
op_amp
id|scn_mutex
)paren
suffix:semicolon
id|scn_minor
op_assign
id|USB_SCN_MINOR
c_func
(paren
id|inode
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;open_scanner: scn_minor:%d&quot;
comma
id|scn_minor
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p_scn_table
(braket
id|scn_minor
)braket
)paren
(brace
id|up
c_func
(paren
op_amp
id|scn_mutex
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|err
c_func
(paren
l_string|&quot;open_scanner(%d): Unable to access minor data&quot;
comma
id|scn_minor
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|scn
op_assign
id|p_scn_table
(braket
id|scn_minor
)braket
suffix:semicolon
id|dev
op_assign
id|scn-&gt;scn_dev
suffix:semicolon
id|down
c_func
(paren
op_amp
(paren
id|scn-&gt;sem
)paren
)paren
suffix:semicolon
multiline_comment|/* Now protect the scn_usb_data structure */
id|up
c_func
(paren
op_amp
id|scn_mutex
)paren
suffix:semicolon
multiline_comment|/* Now handled by the above */
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|err
c_func
(paren
l_string|&quot;open_scanner(%d): Scanner device not present&quot;
comma
id|scn_minor
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out_error
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|scn-&gt;present
)paren
(brace
id|err
c_func
(paren
l_string|&quot;open_scanner(%d): Scanner is not present&quot;
comma
id|scn_minor
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out_error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scn-&gt;isopen
)paren
(brace
id|err
c_func
(paren
l_string|&quot;open_scanner(%d): Scanner device is already open&quot;
comma
id|scn_minor
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|out_error
suffix:semicolon
)brace
id|init_waitqueue_head
c_func
(paren
op_amp
id|scn-&gt;rd_wait_q
)paren
suffix:semicolon
id|scn-&gt;isopen
op_assign
l_int|1
suffix:semicolon
id|file-&gt;private_data
op_assign
id|scn
suffix:semicolon
multiline_comment|/* Used by the read and write methods */
id|out_error
suffix:colon
id|up
c_func
(paren
op_amp
(paren
id|scn-&gt;sem
)paren
)paren
suffix:semicolon
multiline_comment|/* Wake up any possible contending processes */
r_if
c_cond
(paren
id|err
)paren
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_static
r_int
DECL|function|close_scanner
id|close_scanner
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|scn_usb_data
op_star
id|scn
suffix:semicolon
r_int
id|scn_minor
suffix:semicolon
id|scn_minor
op_assign
id|USB_SCN_MINOR
(paren
id|inode
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;close_scanner: scn_minor:%d&quot;
comma
id|scn_minor
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p_scn_table
(braket
id|scn_minor
)braket
)paren
(brace
id|err
c_func
(paren
l_string|&quot;close_scanner(%d): invalid scn_minor&quot;
comma
id|scn_minor
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|scn_mutex
)paren
suffix:semicolon
id|scn
op_assign
id|p_scn_table
(braket
id|scn_minor
)braket
suffix:semicolon
id|down
c_func
(paren
op_amp
(paren
id|scn-&gt;sem
)paren
)paren
suffix:semicolon
id|scn-&gt;isopen
op_assign
l_int|0
suffix:semicolon
id|file-&gt;private_data
op_assign
l_int|NULL
suffix:semicolon
id|up
c_func
(paren
op_amp
id|scn_mutex
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
(paren
id|scn-&gt;sem
)paren
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|write_scanner
id|write_scanner
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|scn_usb_data
op_star
id|scn
suffix:semicolon
r_struct
id|usb_device
op_star
id|dev
suffix:semicolon
id|ssize_t
id|bytes_written
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Overall count of bytes written */
id|ssize_t
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|scn_minor
suffix:semicolon
r_int
id|this_write
suffix:semicolon
multiline_comment|/* Number of bytes to write */
r_int
id|partial
suffix:semicolon
multiline_comment|/* Number of bytes successfully written */
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|obuf
suffix:semicolon
id|scn
op_assign
id|file-&gt;private_data
suffix:semicolon
id|down
c_func
(paren
op_amp
(paren
id|scn-&gt;sem
)paren
)paren
suffix:semicolon
id|scn_minor
op_assign
id|scn-&gt;scn_minor
suffix:semicolon
id|obuf
op_assign
id|scn-&gt;obuf
suffix:semicolon
id|dev
op_assign
id|scn-&gt;scn_dev
suffix:semicolon
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_atime
op_assign
id|CURRENT_TIME
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
id|this_write
op_assign
(paren
id|count
op_ge
id|OBUF_SIZE
)paren
ques
c_cond
id|OBUF_SIZE
suffix:colon
id|count
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|scn-&gt;obuf
comma
id|buffer
comma
id|this_write
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|result
op_assign
id|usb_bulk_msg
c_func
(paren
id|dev
comma
id|usb_sndbulkpipe
c_func
(paren
id|dev
comma
id|scn-&gt;bulk_out_ep
)paren
comma
id|obuf
comma
id|this_write
comma
op_amp
id|partial
comma
l_int|60
op_star
id|HZ
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;write stats(%d): result:%d this_write:%d partial:%d&quot;
comma
id|scn_minor
comma
id|result
comma
id|this_write
comma
id|partial
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ETIMEDOUT
)paren
(brace
multiline_comment|/* NAK -- shouldn&squot;t happen */
id|warn
c_func
(paren
l_string|&quot;write_scanner: NAK received.&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|result
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
multiline_comment|/* We should not get any I/O errors */
id|warn
c_func
(paren
l_string|&quot;write_scanner(%d): funky result: %d. Consult Documentataion/usb/scanner.txt.&quot;
comma
id|scn_minor
comma
id|result
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef WR_DATA_DUMP
r_if
c_cond
(paren
id|partial
)paren
(brace
r_int
r_char
id|cnt
comma
id|cnt_max
suffix:semicolon
id|cnt_max
op_assign
(paren
id|partial
OG
l_int|24
)paren
ques
c_cond
l_int|24
suffix:colon
id|partial
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;dump(%d): &quot;
comma
id|scn_minor
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|cnt_max
suffix:semicolon
id|cnt
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%X &quot;
comma
id|obuf
(braket
id|cnt
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|partial
op_ne
id|this_write
)paren
(brace
multiline_comment|/* Unable to write all contents of obuf */
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|partial
)paren
(brace
multiline_comment|/* Data written */
id|buffer
op_add_assign
id|partial
suffix:semicolon
id|count
op_sub_assign
id|partial
suffix:semicolon
id|bytes_written
op_add_assign
id|partial
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* No data written */
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|up
c_func
(paren
op_amp
(paren
id|scn-&gt;sem
)paren
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
multiline_comment|/* This seems to help with SANE queries */
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
id|bytes_written
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|read_scanner
id|read_scanner
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|scn_usb_data
op_star
id|scn
suffix:semicolon
r_struct
id|usb_device
op_star
id|dev
suffix:semicolon
id|ssize_t
id|bytes_read
suffix:semicolon
multiline_comment|/* Overall count of bytes_read */
id|ssize_t
id|ret
suffix:semicolon
r_int
id|scn_minor
suffix:semicolon
r_int
id|partial
suffix:semicolon
multiline_comment|/* Number of bytes successfully read */
r_int
id|this_read
suffix:semicolon
multiline_comment|/* Max number of bytes to read */
r_int
id|result
suffix:semicolon
r_int
id|rd_expire
op_assign
id|RD_EXPIRE
suffix:semicolon
r_char
op_star
id|ibuf
suffix:semicolon
id|scn
op_assign
id|file-&gt;private_data
suffix:semicolon
id|down
c_func
(paren
op_amp
(paren
id|scn-&gt;sem
)paren
)paren
suffix:semicolon
id|scn_minor
op_assign
id|scn-&gt;scn_minor
suffix:semicolon
id|ibuf
op_assign
id|scn-&gt;ibuf
suffix:semicolon
id|dev
op_assign
id|scn-&gt;scn_dev
suffix:semicolon
id|bytes_read
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_atime
op_assign
id|CURRENT_TIME
suffix:semicolon
multiline_comment|/* Update the&n;                                                            atime of&n;                                                            the device&n;                                                            node */
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
id|this_read
op_assign
(paren
id|count
op_ge
id|IBUF_SIZE
)paren
ques
c_cond
id|IBUF_SIZE
suffix:colon
id|count
suffix:semicolon
id|result
op_assign
id|usb_bulk_msg
c_func
(paren
id|dev
comma
id|usb_rcvbulkpipe
c_func
(paren
id|dev
comma
id|scn-&gt;bulk_in_ep
)paren
comma
id|ibuf
comma
id|this_read
comma
op_amp
id|partial
comma
id|scn-&gt;rd_nak_timeout
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;read stats(%d): result:%d this_read:%d partial:%d count:%d&quot;
comma
id|scn_minor
comma
id|result
comma
id|this_read
comma
id|partial
comma
id|count
)paren
suffix:semicolon
multiline_comment|/*&n; * Scanners are sometimes inheriently slow since they are mechanical&n; * in nature.  USB bulk reads tend to timeout while the scanner is&n; * positioning, resetting, warming up the lamp, etc if the timeout is&n; * set too low.  A very long timeout parameter for bulk reads was used&n; * to overcome this limitation, but this sometimes resulted in folks&n; * having to wait for the timeout to expire after pressing Ctrl-C from&n; * an application. The user was sometimes left with the impression&n; * that something had hung or crashed when in fact the USB read was&n; * just waiting on data.  So, the below code retains the same long&n; * timeout period, but splits it up into smaller parts so that&n; * Ctrl-C&squot;s are acted upon in a reasonable amount of time.&n; */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ETIMEDOUT
)paren
(brace
multiline_comment|/* NAK */
r_if
c_cond
(paren
op_logical_neg
id|partial
)paren
(brace
multiline_comment|/* No data */
r_if
c_cond
(paren
op_decrement
id|rd_expire
op_le
l_int|0
)paren
(brace
multiline_comment|/* Give it up */
id|warn
c_func
(paren
l_string|&quot;read_scanner(%d): excessive NAK&squot;s received&quot;
comma
id|scn_minor
)paren
suffix:semicolon
id|ret
op_assign
id|result
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Keep trying to read data */
id|interruptible_sleep_on_timeout
c_func
(paren
op_amp
id|scn-&gt;rd_wait_q
comma
id|scn-&gt;rd_nak_timeout
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Timeout w/ some data */
r_goto
id|data_recvd
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
multiline_comment|/* No hope */
r_if
c_cond
(paren
id|usb_clear_halt
c_func
(paren
id|dev
comma
id|scn-&gt;bulk_in_ep
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;read_scanner(%d): Failure to clear endpoint halt condition (%Zd).&quot;
comma
id|scn_minor
comma
id|ret
)paren
suffix:semicolon
)brace
id|ret
op_assign
id|result
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|result
OL
l_int|0
)paren
op_logical_and
(paren
id|result
op_ne
op_minus
id|EREMOTEIO
)paren
)paren
(brace
id|warn
c_func
(paren
l_string|&quot;read_scanner(%d): funky result:%d. Consult Documentation/usb/scanner.txt.&quot;
comma
id|scn_minor
comma
(paren
r_int
)paren
id|result
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
id|data_recvd
suffix:colon
macro_line|#ifdef RD_DATA_DUMP
r_if
c_cond
(paren
id|partial
)paren
(brace
r_int
r_char
id|cnt
comma
id|cnt_max
suffix:semicolon
id|cnt_max
op_assign
(paren
id|partial
OG
l_int|24
)paren
ques
c_cond
l_int|24
suffix:colon
id|partial
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;dump(%d): &quot;
comma
id|scn_minor
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|cnt_max
suffix:semicolon
id|cnt
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%X &quot;
comma
id|ibuf
(braket
id|cnt
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|partial
)paren
(brace
multiline_comment|/* Data returned */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buffer
comma
id|ibuf
comma
id|partial
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|count
op_sub_assign
id|this_read
suffix:semicolon
multiline_comment|/* Compensate for short reads */
id|bytes_read
op_add_assign
id|partial
suffix:semicolon
multiline_comment|/* Keep tally of what actually was read */
id|buffer
op_add_assign
id|partial
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|up
c_func
(paren
op_amp
(paren
id|scn-&gt;sem
)paren
)paren
suffix:semicolon
r_return
id|ret
ques
c_cond
id|ret
suffix:colon
id|bytes_read
suffix:semicolon
)brace
r_static
r_int
DECL|function|ioctl_scanner
id|ioctl_scanner
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|usb_device
op_star
id|dev
suffix:semicolon
r_int
id|scn_minor
suffix:semicolon
id|scn_minor
op_assign
id|USB_SCN_MINOR
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p_scn_table
(braket
id|scn_minor
)braket
)paren
(brace
id|err
c_func
(paren
l_string|&quot;ioctl_scanner(%d): invalid scn_minor&quot;
comma
id|scn_minor
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|dev
op_assign
id|p_scn_table
(braket
id|scn_minor
)braket
op_member_access_from_pointer
id|scn_dev
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SCANNER_IOCTL_VENDOR
suffix:colon
r_return
(paren
id|put_user
c_func
(paren
id|dev-&gt;descriptor.idVendor
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
)paren
suffix:semicolon
r_case
id|SCANNER_IOCTL_PRODUCT
suffix:colon
r_return
(paren
id|put_user
c_func
(paren
id|dev-&gt;descriptor.idProduct
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
)paren
suffix:semicolon
macro_line|#ifdef PV8630
r_case
id|PV8630_IOCTL_INREQUEST
suffix:colon
(brace
r_int
id|result
suffix:semicolon
r_struct
(brace
id|__u8
id|data
suffix:semicolon
id|__u8
id|request
suffix:semicolon
id|__u16
id|value
suffix:semicolon
id|__u16
id|index
suffix:semicolon
)brace
id|args
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|args
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|args
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|result
op_assign
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|args.request
comma
id|USB_TYPE_VENDOR
op_or
id|USB_RECIP_DEVICE
op_or
id|USB_DIR_IN
comma
id|args.value
comma
id|args.index
comma
op_amp
id|args.data
comma
l_int|1
comma
id|HZ
op_star
l_int|5
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;ioctl_scanner(%d): inreq: args.data:%x args.value:%x args.index:%x args.request:%x&bslash;n&quot;
comma
id|scn_minor
comma
id|args.data
comma
id|args.value
comma
id|args.index
comma
id|args.request
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|args
comma
r_sizeof
(paren
id|args
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;ioctl_scanner(%d): inreq: result:%d&bslash;n&quot;
comma
id|scn_minor
comma
id|result
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_case
id|PV8630_IOCTL_OUTREQUEST
suffix:colon
(brace
r_int
id|result
suffix:semicolon
r_struct
(brace
id|__u8
id|request
suffix:semicolon
id|__u16
id|value
suffix:semicolon
id|__u16
id|index
suffix:semicolon
)brace
id|args
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|args
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|args
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;ioctl_scanner(%d): outreq: args.value:%x args.index:%x args.request:%x&bslash;n&quot;
comma
id|scn_minor
comma
id|args.value
comma
id|args.index
comma
id|args.request
)paren
suffix:semicolon
id|result
op_assign
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|args.request
comma
id|USB_TYPE_VENDOR
op_or
id|USB_RECIP_DEVICE
op_or
id|USB_DIR_OUT
comma
id|args.value
comma
id|args.index
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
op_star
l_int|5
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;ioctl_scanner(%d): outreq: result:%d&bslash;n&quot;
comma
id|scn_minor
comma
id|result
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
macro_line|#endif /* PV8630 */
r_case
id|SCANNER_IOCTL_CTRLMSG
suffix:colon
(brace
r_struct
id|ctrlmsg_ioctl
(brace
r_struct
id|usb_ctrlrequest
id|req
suffix:semicolon
r_void
op_star
id|data
suffix:semicolon
)brace
id|cmsg
suffix:semicolon
r_int
id|pipe
comma
id|nb
comma
id|ret
suffix:semicolon
r_int
r_char
id|buf
(braket
l_int|64
)braket
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|cmsg
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|cmsg
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|nb
op_assign
id|le16_to_cpup
c_func
(paren
op_amp
id|cmsg.req.wLength
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nb
OG
r_sizeof
(paren
id|buf
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmsg.req.bRequestType
op_amp
l_int|0x80
)paren
op_eq
l_int|0
)paren
(brace
id|pipe
op_assign
id|usb_sndctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nb
OG
l_int|0
op_logical_and
id|copy_from_user
c_func
(paren
id|buf
comma
id|cmsg.data
comma
id|nb
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_else
(brace
id|pipe
op_assign
id|usb_rcvctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
)brace
id|ret
op_assign
id|usb_control_msg
c_func
(paren
id|dev
comma
id|pipe
comma
id|cmsg.req.bRequest
comma
id|cmsg.req.bRequestType
comma
id|le16_to_cpup
c_func
(paren
op_amp
id|cmsg.req.wValue
)paren
comma
id|le16_to_cpup
c_func
(paren
op_amp
id|cmsg.req.wIndex
)paren
comma
id|buf
comma
id|nb
comma
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;ioctl_scanner(%d): control_msg returned %d&bslash;n&quot;
comma
id|scn_minor
comma
id|ret
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nb
OG
l_int|0
op_logical_and
(paren
id|cmsg.req.bRequestType
op_amp
l_int|0x80
)paren
op_logical_and
id|copy_to_user
c_func
(paren
id|cmsg.data
comma
id|buf
comma
id|nb
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_default
suffix:colon
r_return
op_minus
id|ENOTTY
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_struct
DECL|variable|usb_scanner_fops
id|file_operations
id|usb_scanner_fops
op_assign
(brace
dot
id|read
op_assign
id|read_scanner
comma
dot
id|write
op_assign
id|write_scanner
comma
dot
id|ioctl
op_assign
id|ioctl_scanner
comma
dot
id|open
op_assign
id|open_scanner
comma
dot
id|release
op_assign
id|close_scanner
comma
)brace
suffix:semicolon
r_static
r_void
op_star
DECL|function|probe_scanner
id|probe_scanner
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|ifnum
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
(brace
r_struct
id|scn_usb_data
op_star
id|scn
suffix:semicolon
r_struct
id|usb_interface_descriptor
op_star
id|interface
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|endpoint
suffix:semicolon
r_int
id|ep_cnt
suffix:semicolon
r_int
id|ix
suffix:semicolon
r_int
id|scn_minor
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_char
id|valid_device
op_assign
l_int|0
suffix:semicolon
r_char
id|have_bulk_in
comma
id|have_bulk_out
comma
id|have_intr
suffix:semicolon
r_char
id|name
(braket
l_int|10
)braket
suffix:semicolon
r_if
c_cond
(paren
id|vendor
op_ne
op_minus
l_int|1
op_logical_and
id|product
op_ne
op_minus
l_int|1
)paren
(brace
id|info
c_func
(paren
l_string|&quot;probe_scanner: User specified USB scanner -- Vendor:Product - %x:%x&quot;
comma
id|vendor
comma
id|product
)paren
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;probe_scanner: USB dev address:%p&quot;
comma
id|dev
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;probe_scanner: ifnum:%u&quot;
comma
id|ifnum
)paren
suffix:semicolon
multiline_comment|/*&n; * 1. Check Vendor/Product&n; * 2. Determine/Assign Bulk Endpoints&n; * 3. Determine/Assign Intr Endpoint&n; */
multiline_comment|/*&n; * There doesn&squot;t seem to be an imaging class defined in the USB&n; * Spec. (yet).  If there is, HP isn&squot;t following it and it doesn&squot;t&n; * look like anybody else is either.  Therefore, we have to test the&n; * Vendor and Product ID&squot;s to see what we have.  Also, other scanners&n; * may be able to use this driver by specifying both vendor and&n; * product ID&squot;s as options to the scanner module in conf.modules.&n; *&n; * NOTE: Just because a product is supported here does not mean that&n; * applications exist that support the product.  It&squot;s in the hopes&n; * that this will allow developers a means to produce applications&n; * that will support USB products.&n; *&n; * Until we detect a device which is pleasing, we silently punt.&n; */
r_for
c_loop
(paren
id|ix
op_assign
l_int|0
suffix:semicolon
id|ix
OL
r_sizeof
(paren
id|scanner_device_ids
)paren
op_div
r_sizeof
(paren
r_struct
id|usb_device_id
)paren
suffix:semicolon
id|ix
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev-&gt;descriptor.idVendor
op_eq
id|scanner_device_ids
(braket
id|ix
)braket
dot
id|idVendor
)paren
op_logical_and
(paren
id|dev-&gt;descriptor.idProduct
op_eq
id|scanner_device_ids
(braket
id|ix
)braket
dot
id|idProduct
)paren
)paren
(brace
id|valid_device
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|dev-&gt;descriptor.idVendor
op_eq
id|vendor
op_logical_and
multiline_comment|/* User specified */
id|dev-&gt;descriptor.idProduct
op_eq
id|product
)paren
(brace
multiline_comment|/* User specified */
id|valid_device
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|valid_device
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* We didn&squot;t find anything pleasing */
multiline_comment|/*&n; * After this point we can be a little noisy about what we are trying to&n; *  configure.&n; */
r_if
c_cond
(paren
id|dev-&gt;descriptor.bNumConfigurations
op_ne
l_int|1
)paren
(brace
id|info
c_func
(paren
l_string|&quot;probe_scanner: Only one device configuration is supported.&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;config
(braket
l_int|0
)braket
dot
id|bNumInterfaces
op_ne
l_int|1
)paren
(brace
id|info
c_func
(paren
l_string|&quot;probe_scanner: Only one device interface is supported.&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|interface
op_assign
id|dev-&gt;config
(braket
l_int|0
)braket
dot
id|interface
(braket
id|ifnum
)braket
dot
id|altsetting
suffix:semicolon
id|endpoint
op_assign
id|interface
(braket
id|ifnum
)braket
dot
id|endpoint
suffix:semicolon
multiline_comment|/*&n; * Start checking for two bulk endpoints OR two bulk endpoints *and* one&n; * interrupt endpoint. If we have an interrupt endpoint go ahead and&n; * setup the handler. FIXME: This is a future enhancement...&n; */
id|dbg
c_func
(paren
l_string|&quot;probe_scanner: Number of Endpoints:%d&quot;
comma
(paren
r_int
)paren
id|interface-&gt;bNumEndpoints
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|interface-&gt;bNumEndpoints
op_ne
l_int|2
)paren
op_logical_and
(paren
id|interface-&gt;bNumEndpoints
op_ne
l_int|3
)paren
)paren
(brace
id|info
c_func
(paren
l_string|&quot;probe_scanner: Only two or three endpoints supported.&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|ep_cnt
op_assign
id|have_bulk_in
op_assign
id|have_bulk_out
op_assign
id|have_intr
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|ep_cnt
OL
id|interface-&gt;bNumEndpoints
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|have_bulk_in
op_logical_and
id|IS_EP_BULK_IN
c_func
(paren
id|endpoint
(braket
id|ep_cnt
)braket
)paren
)paren
(brace
id|ep_cnt
op_increment
suffix:semicolon
id|have_bulk_in
op_assign
id|ep_cnt
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;probe_scanner: bulk_in_ep:%d&quot;
comma
id|have_bulk_in
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|have_bulk_out
op_logical_and
id|IS_EP_BULK_OUT
c_func
(paren
id|endpoint
(braket
id|ep_cnt
)braket
)paren
)paren
(brace
id|ep_cnt
op_increment
suffix:semicolon
id|have_bulk_out
op_assign
id|ep_cnt
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;probe_scanner: bulk_out_ep:%d&quot;
comma
id|have_bulk_out
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|have_intr
op_logical_and
id|IS_EP_INTR
c_func
(paren
id|endpoint
(braket
id|ep_cnt
)braket
)paren
)paren
(brace
id|ep_cnt
op_increment
suffix:semicolon
id|have_intr
op_assign
id|ep_cnt
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;probe_scanner: intr_ep:%d&quot;
comma
id|have_intr
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|info
c_func
(paren
l_string|&quot;probe_scanner: Undetected endpoint -- consult Documentation/usb/scanner.txt.&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Shouldn&squot;t ever get here unless we have something weird */
)brace
multiline_comment|/*&n; * Perform a quick check to make sure that everything worked as it&n; * should have.&n; */
r_switch
c_cond
(paren
id|interface-&gt;bNumEndpoints
)paren
(brace
r_case
l_int|2
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|have_bulk_in
op_logical_or
op_logical_neg
id|have_bulk_out
)paren
(brace
id|info
c_func
(paren
l_string|&quot;probe_scanner: Two bulk endpoints required.&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|have_bulk_in
op_logical_or
op_logical_neg
id|have_bulk_out
op_logical_or
op_logical_neg
id|have_intr
)paren
(brace
id|info
c_func
(paren
l_string|&quot;probe_scanner: Two bulk endpoints and one interrupt endpoint required.&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|info
c_func
(paren
l_string|&quot;probe_scanner: Endpoint determination failed --  consult Documentation/usb/scanner.txt&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Determine a minor number and initialize the structure associated&n; * with it.  The problem with this is that we are counting on the fact&n; * that the user will sequentially add device nodes for the scanner&n; * devices.  */
id|down
c_func
(paren
op_amp
id|scn_mutex
)paren
suffix:semicolon
id|retval
op_assign
id|usb_register_dev
c_func
(paren
op_amp
id|usb_scanner_fops
comma
id|SCN_BASE_MNR
comma
l_int|1
comma
op_amp
id|scn_minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|err
(paren
l_string|&quot;Not able to get a minor for this device.&quot;
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|scn_mutex
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Check to make sure that the last slot isn&squot;t already taken */
r_if
c_cond
(paren
id|p_scn_table
(braket
id|scn_minor
)braket
)paren
(brace
id|err
c_func
(paren
l_string|&quot;probe_scanner: No more minor devices remaining.&quot;
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|scn_mutex
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;probe_scanner: Allocated minor:%d&quot;
comma
id|scn_minor
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|scn
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|scn_usb_data
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;probe_scanner: Out of memory.&quot;
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|scn_mutex
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
(paren
id|scn
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|scn_usb_data
)paren
)paren
suffix:semicolon
id|scn-&gt;scn_irq
op_assign
id|usb_alloc_urb
c_func
(paren
l_int|0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scn-&gt;scn_irq
)paren
(brace
id|kfree
c_func
(paren
id|scn
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|scn_mutex
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|init_MUTEX
c_func
(paren
op_amp
(paren
id|scn-&gt;sem
)paren
)paren
suffix:semicolon
multiline_comment|/* Initializes to unlocked */
id|dbg
(paren
l_string|&quot;probe_scanner(%d): Address of scn:%p&quot;
comma
id|scn_minor
comma
id|scn
)paren
suffix:semicolon
multiline_comment|/* Ok, if we detected an interrupt EP, setup a handler for it */
r_if
c_cond
(paren
id|have_intr
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;probe_scanner(%d): Configuring IRQ handler for intr EP:%d&quot;
comma
id|scn_minor
comma
id|have_intr
)paren
suffix:semicolon
id|FILL_INT_URB
c_func
(paren
id|scn-&gt;scn_irq
comma
id|dev
comma
id|usb_rcvintpipe
c_func
(paren
id|dev
comma
id|have_intr
)paren
comma
op_amp
id|scn-&gt;button
comma
l_int|1
comma
id|irq_scanner
comma
id|scn
comma
singleline_comment|// endpoint[(int)have_intr].bInterval);
l_int|250
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_submit_urb
c_func
(paren
id|scn-&gt;scn_irq
comma
id|GFP_KERNEL
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;probe_scanner(%d): Unable to allocate INT URB.&quot;
comma
id|scn_minor
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|scn
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|scn_mutex
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* Ok, now initialize all the relevant values */
r_if
c_cond
(paren
op_logical_neg
(paren
id|scn-&gt;obuf
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|OBUF_SIZE
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;probe_scanner(%d): Not enough memory for the output buffer.&quot;
comma
id|scn_minor
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|scn
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|scn_mutex
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;probe_scanner(%d): obuf address:%p&quot;
comma
id|scn_minor
comma
id|scn-&gt;obuf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|scn-&gt;ibuf
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|IBUF_SIZE
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;probe_scanner(%d): Not enough memory for the input buffer.&quot;
comma
id|scn_minor
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|scn-&gt;obuf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|scn
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|scn_mutex
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;probe_scanner(%d): ibuf address:%p&quot;
comma
id|scn_minor
comma
id|scn-&gt;ibuf
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|dev-&gt;descriptor.idVendor
)paren
(brace
multiline_comment|/* Scanner specific read timeout parameters */
r_case
l_int|0x04b8
suffix:colon
multiline_comment|/* Seiko/Epson */
id|scn-&gt;rd_nak_timeout
op_assign
id|HZ
op_star
l_int|60
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x055f
suffix:colon
multiline_comment|/* Mustek */
r_case
l_int|0x0400
suffix:colon
multiline_comment|/* Another Mustek */
r_case
l_int|0x0ff5
suffix:colon
multiline_comment|/* And yet another Mustek */
id|scn-&gt;rd_nak_timeout
op_assign
id|HZ
op_star
l_int|1
suffix:semicolon
r_default
suffix:colon
id|scn-&gt;rd_nak_timeout
op_assign
id|RD_NAK_TIMEOUT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|read_timeout
OG
l_int|0
)paren
(brace
multiline_comment|/* User specified read timeout overrides everything */
id|info
c_func
(paren
l_string|&quot;probe_scanner: User specified USB read timeout - %d&quot;
comma
id|read_timeout
)paren
suffix:semicolon
id|scn-&gt;rd_nak_timeout
op_assign
id|read_timeout
suffix:semicolon
)brace
id|scn-&gt;bulk_in_ep
op_assign
id|have_bulk_in
suffix:semicolon
id|scn-&gt;bulk_out_ep
op_assign
id|have_bulk_out
suffix:semicolon
id|scn-&gt;intr_ep
op_assign
id|have_intr
suffix:semicolon
id|scn-&gt;present
op_assign
l_int|1
suffix:semicolon
id|scn-&gt;scn_dev
op_assign
id|dev
suffix:semicolon
id|scn-&gt;scn_minor
op_assign
id|scn_minor
suffix:semicolon
id|scn-&gt;isopen
op_assign
l_int|0
suffix:semicolon
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;scanner%d&quot;
comma
id|scn-&gt;scn_minor
)paren
suffix:semicolon
id|scn-&gt;devfs
op_assign
id|devfs_register
c_func
(paren
id|usb_devfs_handle
comma
id|name
comma
id|DEVFS_FL_DEFAULT
comma
id|USB_MAJOR
comma
id|SCN_BASE_MNR
op_plus
id|scn-&gt;scn_minor
comma
id|S_IFCHR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
op_or
id|S_IRGRP
op_or
id|S_IWGRP
op_or
id|S_IROTH
op_or
id|S_IWOTH
comma
op_amp
id|usb_scanner_fops
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scn-&gt;devfs
op_eq
l_int|NULL
)paren
id|dbg
c_func
(paren
l_string|&quot;scanner%d: device node registration failed&quot;
comma
id|scn_minor
)paren
suffix:semicolon
id|p_scn_table
(braket
id|scn_minor
)braket
op_assign
id|scn
suffix:semicolon
id|up
c_func
(paren
op_amp
id|scn_mutex
)paren
suffix:semicolon
r_return
id|scn
suffix:semicolon
)brace
r_static
r_void
DECL|function|disconnect_scanner
id|disconnect_scanner
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|scn_usb_data
op_star
id|scn
op_assign
(paren
r_struct
id|scn_usb_data
op_star
)paren
id|ptr
suffix:semicolon
id|down
(paren
op_amp
id|scn_mutex
)paren
suffix:semicolon
id|down
(paren
op_amp
(paren
id|scn-&gt;sem
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scn-&gt;intr_ep
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;disconnect_scanner(%d): Unlinking IRQ URB&quot;
comma
id|scn-&gt;scn_minor
)paren
suffix:semicolon
id|usb_unlink_urb
c_func
(paren
id|scn-&gt;scn_irq
)paren
suffix:semicolon
)brace
id|usb_driver_release_interface
c_func
(paren
op_amp
id|scanner_driver
comma
op_amp
id|scn-&gt;scn_dev-&gt;actconfig-&gt;interface
(braket
id|scn-&gt;ifnum
)braket
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|scn-&gt;ibuf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|scn-&gt;obuf
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;disconnect_scanner: De-allocating minor:%d&quot;
comma
id|scn-&gt;scn_minor
)paren
suffix:semicolon
id|devfs_unregister
c_func
(paren
id|scn-&gt;devfs
)paren
suffix:semicolon
id|usb_deregister_dev
c_func
(paren
l_int|1
comma
id|scn-&gt;scn_minor
)paren
suffix:semicolon
id|p_scn_table
(braket
id|scn-&gt;scn_minor
)braket
op_assign
l_int|NULL
suffix:semicolon
id|usb_free_urb
c_func
(paren
id|scn-&gt;scn_irq
)paren
suffix:semicolon
id|up
(paren
op_amp
(paren
id|scn-&gt;sem
)paren
)paren
suffix:semicolon
id|kfree
(paren
id|scn
)paren
suffix:semicolon
id|up
(paren
op_amp
id|scn_mutex
)paren
suffix:semicolon
)brace
r_static
r_struct
DECL|variable|scanner_driver
id|usb_driver
id|scanner_driver
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;usbscanner&quot;
comma
dot
id|probe
op_assign
id|probe_scanner
comma
dot
id|disconnect
op_assign
id|disconnect_scanner
comma
dot
id|id_table
op_assign
l_int|NULL
comma
multiline_comment|/* This would be scanner_device_ids, but we&n;&t;&t;&t;&t; need to check every USB device, in case&n;&t;&t;&t;&t; we match a user defined vendor/product ID. */
)brace
suffix:semicolon
r_void
id|__exit
DECL|function|usb_scanner_exit
id|usb_scanner_exit
c_func
(paren
r_void
)paren
(brace
id|usb_deregister
c_func
(paren
op_amp
id|scanner_driver
)paren
suffix:semicolon
)brace
r_int
id|__init
DECL|function|usb_scanner_init
id|usb_scanner_init
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|usb_register
c_func
(paren
op_amp
id|scanner_driver
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|info
c_func
(paren
id|DRIVER_VERSION
l_string|&quot;:&quot;
id|DRIVER_DESC
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|usb_scanner_init
id|module_init
c_func
(paren
id|usb_scanner_init
)paren
suffix:semicolon
DECL|variable|usb_scanner_exit
id|module_exit
c_func
(paren
id|usb_scanner_exit
)paren
suffix:semicolon
eof
