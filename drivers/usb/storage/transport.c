multiline_comment|/* Driver for USB Mass Storage compliant devices&n; *&n; * $Id: transport.c,v 1.47 2002/04/22 03:39:43 mdharm Exp $&n; *&n; * Current development and maintenance by:&n; *   (c) 1999-2002 Matthew Dharm (mdharm-usb@one-eyed-alien.net)&n; *&n; * Developed with the assistance of:&n; *   (c) 2000 David L. Brown, Jr. (usb-storage@davidb.org)&n; *   (c) 2000 Stephen J. Gowdy (SGowdy@lbl.gov)&n; *   (c) 2002 Alan Stern &lt;stern@rowland.org&gt;&n; *&n; * Initial work by:&n; *   (c) 1999 Michael Gee (michael@linuxspecific.com)&n; *&n; * This driver is based on the &squot;USB Mass Storage Class&squot; document. This&n; * describes in detail the protocol used to communicate with such&n; * devices.  Clearly, the designers had SCSI and ATAPI commands in&n; * mind when they created this document.  The commands are all very&n; * similar to commands in the SCSI-II and ATAPI specifications.&n; *&n; * It is important to note that in a number of cases this class&n; * exhibits class-specific exemptions from the USB specification.&n; * Notably the usage of NAK, STALL and ACK differs from the norm, in&n; * that they are used to communicate wait, failed and OK on commands.&n; *&n; * Also, for certain devices, the interrupt endpoint is used to convey&n; * status of a command.&n; *&n; * Please see http://www.one-eyed-alien.net/~mdharm/linux-usb for more&n; * information about this driver.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2, or (at your option) any&n; * later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write to the Free Software Foundation, Inc.,&n; * 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;scsi/scsi.h&gt;
macro_line|#include &lt;scsi/scsi_cmnd.h&gt;
macro_line|#include &lt;scsi/scsi_device.h&gt;
macro_line|#include &quot;transport.h&quot;
macro_line|#include &quot;protocol.h&quot;
macro_line|#include &quot;scsiglue.h&quot;
macro_line|#include &quot;usb.h&quot;
macro_line|#include &quot;debug.h&quot;
multiline_comment|/***********************************************************************&n; * Data transfer routines&n; ***********************************************************************/
multiline_comment|/*&n; * This is subtle, so pay attention:&n; * ---------------------------------&n; * We&squot;re very concerned about races with a command abort.  Hanging this code&n; * is a sure fire way to hang the kernel.  (Note that this discussion applies&n; * only to transactions resulting from a scsi queued-command, since only&n; * these transactions are subject to a scsi abort.  Other transactions, such&n; * as those occurring during device-specific initialization, must be handled&n; * by a separate code path.)&n; *&n; * The abort function (usb_storage_command_abort() in scsiglue.c) first&n; * sets the machine state and the ABORTING bit in us-&gt;flags to prevent&n; * new URBs from being submitted.  It then calls usb_stor_stop_transport()&n; * below, which atomically tests-and-clears the URB_ACTIVE bit in us-&gt;flags&n; * to see if the current_urb needs to be stopped.  Likewise, the SG_ACTIVE&n; * bit is tested to see if the current_sg scatter-gather request needs to be&n; * stopped.  The timeout callback routine does much the same thing.&n; *&n; * When a disconnect occurs, the DISCONNECTING bit in us-&gt;flags is set to&n; * prevent new URBs from being submitted, and usb_stor_stop_transport() is&n; * called to stop any ongoing requests.&n; *&n; * The submit function first verifies that the submitting is allowed&n; * (neither ABORTING nor DISCONNECTING bits are set) and that the submit&n; * completes without errors, and only then sets the URB_ACTIVE bit.  This&n; * prevents the stop_transport() function from trying to cancel the URB&n; * while the submit call is underway.  Next, the submit function must test&n; * the flags to see if an abort or disconnect occurred during the submission&n; * or before the URB_ACTIVE bit was set.  If so, it&squot;s essential to cancel&n; * the URB if it hasn&squot;t been cancelled already (i.e., if the URB_ACTIVE bit&n; * is still set).  Either way, the function must then wait for the URB to&n; * finish.  Note that because the URB_ASYNC_UNLINK flag is set, the URB can&n; * still be in progress even after a call to usb_unlink_urb() returns.&n; *&n; * The idea is that (1) once the ABORTING or DISCONNECTING bit is set,&n; * either the stop_transport() function or the submitting function&n; * is guaranteed to call usb_unlink_urb() for an active URB,&n; * and (2) test_and_clear_bit() prevents usb_unlink_urb() from being&n; * called more than once or from being called during usb_submit_urb().&n; */
multiline_comment|/* This is the completion handler which will wake us up when an URB&n; * completes.&n; */
DECL|function|usb_stor_blocking_completion
r_static
r_void
id|usb_stor_blocking_completion
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|completion
op_star
id|urb_done_ptr
op_assign
(paren
r_struct
id|completion
op_star
)paren
id|urb-&gt;context
suffix:semicolon
id|complete
c_func
(paren
id|urb_done_ptr
)paren
suffix:semicolon
)brace
multiline_comment|/* This is the timeout handler which will cancel an URB when its timeout&n; * expires.&n; */
DECL|function|timeout_handler
r_static
r_void
id|timeout_handler
c_func
(paren
r_int
r_int
id|us_
)paren
(brace
r_struct
id|us_data
op_star
id|us
op_assign
(paren
r_struct
id|us_data
op_star
)paren
id|us_
suffix:semicolon
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|US_FLIDX_URB_ACTIVE
comma
op_amp
id|us-&gt;flags
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Timeout -- cancelling URB&bslash;n&quot;
)paren
suffix:semicolon
id|usb_unlink_urb
c_func
(paren
id|us-&gt;current_urb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* This is the common part of the URB message submission code&n; *&n; * All URBs from the usb-storage driver involved in handling a queued scsi&n; * command _must_ pass through this function (or something like it) for the&n; * abort mechanisms to work properly.&n; */
DECL|function|usb_stor_msg_common
r_static
r_int
id|usb_stor_msg_common
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
id|timeout
)paren
(brace
r_struct
id|completion
id|urb_done
suffix:semicolon
r_struct
id|timer_list
id|to_timer
suffix:semicolon
r_int
id|status
suffix:semicolon
multiline_comment|/* don&squot;t submit URBs during abort/disconnect processing */
r_if
c_cond
(paren
id|us-&gt;flags
op_amp
id|ABORTING_OR_DISCONNECTING
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* set up data structures for the wakeup system */
id|init_completion
c_func
(paren
op_amp
id|urb_done
)paren
suffix:semicolon
multiline_comment|/* fill the common fields in the URB */
id|us-&gt;current_urb-&gt;context
op_assign
op_amp
id|urb_done
suffix:semicolon
id|us-&gt;current_urb-&gt;actual_length
op_assign
l_int|0
suffix:semicolon
id|us-&gt;current_urb-&gt;error_count
op_assign
l_int|0
suffix:semicolon
id|us-&gt;current_urb-&gt;status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* we assume that if transfer_buffer isn&squot;t us-&gt;iobuf then it&n;&t; * hasn&squot;t been mapped for DMA.  Yes, this is clunky, but it&squot;s&n;&t; * easier than always having the caller tell us whether the&n;&t; * transfer buffer has already been mapped. */
id|us-&gt;current_urb-&gt;transfer_flags
op_assign
id|URB_ASYNC_UNLINK
op_or
id|URB_NO_SETUP_DMA_MAP
suffix:semicolon
r_if
c_cond
(paren
id|us-&gt;current_urb-&gt;transfer_buffer
op_eq
id|us-&gt;iobuf
)paren
id|us-&gt;current_urb-&gt;transfer_flags
op_or_assign
id|URB_NO_TRANSFER_DMA_MAP
suffix:semicolon
id|us-&gt;current_urb-&gt;transfer_dma
op_assign
id|us-&gt;iobuf_dma
suffix:semicolon
id|us-&gt;current_urb-&gt;setup_dma
op_assign
id|us-&gt;cr_dma
suffix:semicolon
multiline_comment|/* submit the URB */
id|status
op_assign
id|usb_submit_urb
c_func
(paren
id|us-&gt;current_urb
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
multiline_comment|/* something went wrong */
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/* since the URB has been submitted successfully, it&squot;s now okay&n;&t; * to cancel it */
id|set_bit
c_func
(paren
id|US_FLIDX_URB_ACTIVE
comma
op_amp
id|us-&gt;flags
)paren
suffix:semicolon
multiline_comment|/* did an abort/disconnect occur during the submission? */
r_if
c_cond
(paren
id|us-&gt;flags
op_amp
id|ABORTING_OR_DISCONNECTING
)paren
(brace
multiline_comment|/* cancel the URB, if it hasn&squot;t been cancelled already */
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|US_FLIDX_URB_ACTIVE
comma
op_amp
id|us-&gt;flags
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- cancelling URB&bslash;n&quot;
)paren
suffix:semicolon
id|usb_unlink_urb
c_func
(paren
id|us-&gt;current_urb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* submit the timeout timer, if a timeout was requested */
r_if
c_cond
(paren
id|timeout
OG
l_int|0
)paren
(brace
id|init_timer
c_func
(paren
op_amp
id|to_timer
)paren
suffix:semicolon
id|to_timer.expires
op_assign
id|jiffies
op_plus
id|timeout
suffix:semicolon
id|to_timer.function
op_assign
id|timeout_handler
suffix:semicolon
id|to_timer.data
op_assign
(paren
r_int
r_int
)paren
id|us
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|to_timer
)paren
suffix:semicolon
)brace
multiline_comment|/* wait for the completion of the URB */
id|wait_for_completion
c_func
(paren
op_amp
id|urb_done
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|US_FLIDX_URB_ACTIVE
comma
op_amp
id|us-&gt;flags
)paren
suffix:semicolon
multiline_comment|/* clean up the timeout timer */
r_if
c_cond
(paren
id|timeout
OG
l_int|0
)paren
id|del_timer_sync
c_func
(paren
op_amp
id|to_timer
)paren
suffix:semicolon
multiline_comment|/* return the URB status */
r_return
id|us-&gt;current_urb-&gt;status
suffix:semicolon
)brace
multiline_comment|/*&n; * Transfer one control message, with timeouts, and allowing early&n; * termination.  Return codes are usual -Exxx, *not* USB_STOR_XFER_xxx.&n; */
DECL|function|usb_stor_control_msg
r_int
id|usb_stor_control_msg
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|pipe
comma
id|u8
id|request
comma
id|u8
id|requesttype
comma
id|u16
id|value
comma
id|u16
id|index
comma
r_void
op_star
id|data
comma
id|u16
id|size
comma
r_int
id|timeout
)paren
(brace
r_int
id|status
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;%s: rq=%02x rqtype=%02x value=%04x index=%02x len=%u&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|request
comma
id|requesttype
comma
id|value
comma
id|index
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* fill in the devrequest structure */
id|us-&gt;cr-&gt;bRequestType
op_assign
id|requesttype
suffix:semicolon
id|us-&gt;cr-&gt;bRequest
op_assign
id|request
suffix:semicolon
id|us-&gt;cr-&gt;wValue
op_assign
id|cpu_to_le16
c_func
(paren
id|value
)paren
suffix:semicolon
id|us-&gt;cr-&gt;wIndex
op_assign
id|cpu_to_le16
c_func
(paren
id|index
)paren
suffix:semicolon
id|us-&gt;cr-&gt;wLength
op_assign
id|cpu_to_le16
c_func
(paren
id|size
)paren
suffix:semicolon
multiline_comment|/* fill and submit the URB */
id|usb_fill_control_urb
c_func
(paren
id|us-&gt;current_urb
comma
id|us-&gt;pusb_dev
comma
id|pipe
comma
(paren
r_int
r_char
op_star
)paren
id|us-&gt;cr
comma
id|data
comma
id|size
comma
id|usb_stor_blocking_completion
comma
l_int|NULL
)paren
suffix:semicolon
id|status
op_assign
id|usb_stor_msg_common
c_func
(paren
id|us
comma
id|timeout
)paren
suffix:semicolon
multiline_comment|/* return the actual length of the data transferred if no error */
r_if
c_cond
(paren
id|status
op_eq
l_int|0
)paren
id|status
op_assign
id|us-&gt;current_urb-&gt;actual_length
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/* This is a version of usb_clear_halt() that allows early termination and&n; * doesn&squot;t read the status from the device -- this is because some devices&n; * crash their internal firmware when the status is requested after a halt.&n; *&n; * A definitive list of these &squot;bad&squot; devices is too difficult to maintain or&n; * make complete enough to be useful.  This problem was first observed on the&n; * Hagiwara FlashGate DUAL unit.  However, bus traces reveal that neither&n; * MacOS nor Windows checks the status after clearing a halt.&n; *&n; * Since many vendors in this space limit their testing to interoperability&n; * with these two OSes, specification violations like this one are common.&n; */
DECL|function|usb_stor_clear_halt
r_int
id|usb_stor_clear_halt
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|pipe
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
id|endp
op_assign
id|usb_pipeendpoint
c_func
(paren
id|pipe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipein
(paren
id|pipe
)paren
)paren
id|endp
op_or_assign
id|USB_DIR_IN
suffix:semicolon
id|result
op_assign
id|usb_stor_control_msg
c_func
(paren
id|us
comma
id|us-&gt;send_ctrl_pipe
comma
id|USB_REQ_CLEAR_FEATURE
comma
id|USB_RECIP_ENDPOINT
comma
id|USB_ENDPOINT_HALT
comma
id|endp
comma
l_int|NULL
comma
l_int|0
comma
l_int|3
op_star
id|HZ
)paren
suffix:semicolon
multiline_comment|/* reset the endpoint toggle */
id|usb_settoggle
c_func
(paren
id|us-&gt;pusb_dev
comma
id|usb_pipeendpoint
c_func
(paren
id|pipe
)paren
comma
id|usb_pipeout
c_func
(paren
id|pipe
)paren
comma
l_int|0
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;%s: result = %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|result
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Interpret the results of a URB transfer&n; *&n; * This function prints appropriate debugging messages, clears halts on&n; * non-control endpoints, and translates the status to the corresponding&n; * USB_STOR_XFER_xxx return code.&n; */
DECL|function|interpret_urb_result
r_static
r_int
id|interpret_urb_result
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|pipe
comma
r_int
r_int
id|length
comma
r_int
id|result
comma
r_int
r_int
id|partial
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Status code %d; transferred %u/%u&bslash;n&quot;
comma
id|result
comma
id|partial
comma
id|length
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|result
)paren
(brace
multiline_comment|/* no error code; did we send all the data? */
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
id|partial
op_ne
id|length
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- short transfer&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_XFER_SHORT
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- transfer complete&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_XFER_GOOD
suffix:semicolon
multiline_comment|/* stalled */
r_case
op_minus
id|EPIPE
suffix:colon
multiline_comment|/* for control endpoints, (used by CB[I]) a stall indicates&n;&t;&t; * a failed command */
r_if
c_cond
(paren
id|usb_pipecontrol
c_func
(paren
id|pipe
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- stall on control pipe&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_XFER_STALLED
suffix:semicolon
)brace
multiline_comment|/* for other sorts of endpoint, clear the stall */
id|US_DEBUGP
c_func
(paren
l_string|&quot;clearing endpoint halt for pipe 0x%x&bslash;n&quot;
comma
id|pipe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_stor_clear_halt
c_func
(paren
id|us
comma
id|pipe
)paren
OL
l_int|0
)paren
r_return
id|USB_STOR_XFER_ERROR
suffix:semicolon
r_return
id|USB_STOR_XFER_STALLED
suffix:semicolon
multiline_comment|/* timeout or excessively long NAK */
r_case
op_minus
id|ETIMEDOUT
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- timeout or NAK&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_XFER_ERROR
suffix:semicolon
multiline_comment|/* babble - the device tried to send more than we wanted to read */
r_case
op_minus
id|EOVERFLOW
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- babble&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_XFER_LONG
suffix:semicolon
multiline_comment|/* the transfer was cancelled by abort, disconnect, or timeout */
r_case
op_minus
id|ECONNRESET
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- transfer cancelled&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_XFER_ERROR
suffix:semicolon
multiline_comment|/* short scatter-gather read transfer */
r_case
op_minus
id|EREMOTEIO
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- short read transfer&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_XFER_SHORT
suffix:semicolon
multiline_comment|/* abort or disconnect in progress */
r_case
op_minus
id|EIO
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- abort or disconnect in progress&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_XFER_ERROR
suffix:semicolon
multiline_comment|/* the catch-all error case */
r_default
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- unknown error&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_XFER_ERROR
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Transfer one control message, without timeouts, but allowing early&n; * termination.  Return codes are USB_STOR_XFER_xxx.&n; */
DECL|function|usb_stor_ctrl_transfer
r_int
id|usb_stor_ctrl_transfer
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|pipe
comma
id|u8
id|request
comma
id|u8
id|requesttype
comma
id|u16
id|value
comma
id|u16
id|index
comma
r_void
op_star
id|data
comma
id|u16
id|size
)paren
(brace
r_int
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;%s: rq=%02x rqtype=%02x value=%04x index=%02x len=%u&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|request
comma
id|requesttype
comma
id|value
comma
id|index
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* fill in the devrequest structure */
id|us-&gt;cr-&gt;bRequestType
op_assign
id|requesttype
suffix:semicolon
id|us-&gt;cr-&gt;bRequest
op_assign
id|request
suffix:semicolon
id|us-&gt;cr-&gt;wValue
op_assign
id|cpu_to_le16
c_func
(paren
id|value
)paren
suffix:semicolon
id|us-&gt;cr-&gt;wIndex
op_assign
id|cpu_to_le16
c_func
(paren
id|index
)paren
suffix:semicolon
id|us-&gt;cr-&gt;wLength
op_assign
id|cpu_to_le16
c_func
(paren
id|size
)paren
suffix:semicolon
multiline_comment|/* fill and submit the URB */
id|usb_fill_control_urb
c_func
(paren
id|us-&gt;current_urb
comma
id|us-&gt;pusb_dev
comma
id|pipe
comma
(paren
r_int
r_char
op_star
)paren
id|us-&gt;cr
comma
id|data
comma
id|size
comma
id|usb_stor_blocking_completion
comma
l_int|NULL
)paren
suffix:semicolon
id|result
op_assign
id|usb_stor_msg_common
c_func
(paren
id|us
comma
l_int|0
)paren
suffix:semicolon
r_return
id|interpret_urb_result
c_func
(paren
id|us
comma
id|pipe
comma
id|size
comma
id|result
comma
id|us-&gt;current_urb-&gt;actual_length
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Receive one interrupt buffer, without timeouts, but allowing early&n; * termination.  Return codes are USB_STOR_XFER_xxx.&n; *&n; * This routine always uses us-&gt;recv_intr_pipe as the pipe and&n; * us-&gt;ep_bInterval as the interrupt interval.&n; */
DECL|function|usb_stor_intr_transfer
r_int
id|usb_stor_intr_transfer
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_void
op_star
id|buf
comma
r_int
r_int
id|length
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_int
id|pipe
op_assign
id|us-&gt;recv_intr_pipe
suffix:semicolon
r_int
r_int
id|maxp
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;%s: xfer %u bytes&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|length
)paren
suffix:semicolon
multiline_comment|/* calculate the max packet size */
id|maxp
op_assign
id|usb_maxpacket
c_func
(paren
id|us-&gt;pusb_dev
comma
id|pipe
comma
id|usb_pipeout
c_func
(paren
id|pipe
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|maxp
OG
id|length
)paren
id|maxp
op_assign
id|length
suffix:semicolon
multiline_comment|/* fill and submit the URB */
id|usb_fill_int_urb
c_func
(paren
id|us-&gt;current_urb
comma
id|us-&gt;pusb_dev
comma
id|pipe
comma
id|buf
comma
id|maxp
comma
id|usb_stor_blocking_completion
comma
l_int|NULL
comma
id|us-&gt;ep_bInterval
)paren
suffix:semicolon
id|result
op_assign
id|usb_stor_msg_common
c_func
(paren
id|us
comma
l_int|0
)paren
suffix:semicolon
r_return
id|interpret_urb_result
c_func
(paren
id|us
comma
id|pipe
comma
id|length
comma
id|result
comma
id|us-&gt;current_urb-&gt;actual_length
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Transfer one buffer via bulk pipe, without timeouts, but allowing early&n; * termination.  Return codes are USB_STOR_XFER_xxx.  If the bulk pipe&n; * stalls during the transfer, the halt is automatically cleared.&n; */
DECL|function|usb_stor_bulk_transfer_buf
r_int
id|usb_stor_bulk_transfer_buf
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|pipe
comma
r_void
op_star
id|buf
comma
r_int
r_int
id|length
comma
r_int
r_int
op_star
id|act_len
)paren
(brace
r_int
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;%s: xfer %u bytes&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|length
)paren
suffix:semicolon
multiline_comment|/* fill and submit the URB */
id|usb_fill_bulk_urb
c_func
(paren
id|us-&gt;current_urb
comma
id|us-&gt;pusb_dev
comma
id|pipe
comma
id|buf
comma
id|length
comma
id|usb_stor_blocking_completion
comma
l_int|NULL
)paren
suffix:semicolon
id|result
op_assign
id|usb_stor_msg_common
c_func
(paren
id|us
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* store the actual length of the data transferred */
r_if
c_cond
(paren
id|act_len
)paren
op_star
id|act_len
op_assign
id|us-&gt;current_urb-&gt;actual_length
suffix:semicolon
r_return
id|interpret_urb_result
c_func
(paren
id|us
comma
id|pipe
comma
id|length
comma
id|result
comma
id|us-&gt;current_urb-&gt;actual_length
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Transfer a scatter-gather list via bulk transfer&n; *&n; * This function does basically the same thing as usb_stor_bulk_transfer_buf()&n; * above, but it uses the usbcore scatter-gather library.&n; */
DECL|function|usb_stor_bulk_transfer_sglist
r_int
id|usb_stor_bulk_transfer_sglist
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|pipe
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|num_sg
comma
r_int
r_int
id|length
comma
r_int
r_int
op_star
id|act_len
)paren
(brace
r_int
id|result
suffix:semicolon
multiline_comment|/* don&squot;t submit s-g requests during abort/disconnect processing */
r_if
c_cond
(paren
id|us-&gt;flags
op_amp
id|ABORTING_OR_DISCONNECTING
)paren
r_return
id|USB_STOR_XFER_ERROR
suffix:semicolon
multiline_comment|/* initialize the scatter-gather request block */
id|US_DEBUGP
c_func
(paren
l_string|&quot;%s: xfer %u bytes, %d entries&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|length
comma
id|num_sg
)paren
suffix:semicolon
id|result
op_assign
id|usb_sg_init
c_func
(paren
op_amp
id|us-&gt;current_sg
comma
id|us-&gt;pusb_dev
comma
id|pipe
comma
l_int|0
comma
id|sg
comma
id|num_sg
comma
id|length
comma
id|SLAB_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;usb_sg_init returned %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_return
id|USB_STOR_XFER_ERROR
suffix:semicolon
)brace
multiline_comment|/* since the block has been initialized successfully, it&squot;s now&n;&t; * okay to cancel it */
id|set_bit
c_func
(paren
id|US_FLIDX_SG_ACTIVE
comma
op_amp
id|us-&gt;flags
)paren
suffix:semicolon
multiline_comment|/* did an abort/disconnect occur during the submission? */
r_if
c_cond
(paren
id|us-&gt;flags
op_amp
id|ABORTING_OR_DISCONNECTING
)paren
(brace
multiline_comment|/* cancel the request, if it hasn&squot;t been cancelled already */
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|US_FLIDX_SG_ACTIVE
comma
op_amp
id|us-&gt;flags
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- cancelling sg request&bslash;n&quot;
)paren
suffix:semicolon
id|usb_sg_cancel
c_func
(paren
op_amp
id|us-&gt;current_sg
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* wait for the completion of the transfer */
id|usb_sg_wait
c_func
(paren
op_amp
id|us-&gt;current_sg
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|US_FLIDX_SG_ACTIVE
comma
op_amp
id|us-&gt;flags
)paren
suffix:semicolon
id|result
op_assign
id|us-&gt;current_sg.status
suffix:semicolon
r_if
c_cond
(paren
id|act_len
)paren
op_star
id|act_len
op_assign
id|us-&gt;current_sg.bytes
suffix:semicolon
r_return
id|interpret_urb_result
c_func
(paren
id|us
comma
id|pipe
comma
id|length
comma
id|result
comma
id|us-&gt;current_sg.bytes
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Transfer an entire SCSI command&squot;s worth of data payload over the bulk&n; * pipe.&n; *&n; * Note that this uses usb_stor_bulk_transfer_buf() and&n; * usb_stor_bulk_transfer_sglist() to achieve its goals --&n; * this function simply determines whether we&squot;re going to use&n; * scatter-gather or not, and acts appropriately.&n; */
DECL|function|usb_stor_bulk_transfer_sg
r_int
id|usb_stor_bulk_transfer_sg
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|pipe
comma
r_void
op_star
id|buf
comma
r_int
r_int
id|length_left
comma
r_int
id|use_sg
comma
r_int
op_star
id|residual
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_int
id|partial
suffix:semicolon
multiline_comment|/* are we scatter-gathering? */
r_if
c_cond
(paren
id|use_sg
)paren
(brace
multiline_comment|/* use the usb core scatter-gather primitives */
id|result
op_assign
id|usb_stor_bulk_transfer_sglist
c_func
(paren
id|us
comma
id|pipe
comma
(paren
r_struct
id|scatterlist
op_star
)paren
id|buf
comma
id|use_sg
comma
id|length_left
comma
op_amp
id|partial
)paren
suffix:semicolon
id|length_left
op_sub_assign
id|partial
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* no scatter-gather, just make the request */
id|result
op_assign
id|usb_stor_bulk_transfer_buf
c_func
(paren
id|us
comma
id|pipe
comma
id|buf
comma
id|length_left
comma
op_amp
id|partial
)paren
suffix:semicolon
id|length_left
op_sub_assign
id|partial
suffix:semicolon
)brace
multiline_comment|/* store the residual and return the error code */
r_if
c_cond
(paren
id|residual
)paren
op_star
id|residual
op_assign
id|length_left
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/***********************************************************************&n; * Transport routines&n; ***********************************************************************/
multiline_comment|/* Invoke the transport and basic error-handling/recovery methods&n; *&n; * This is used by the protocol layers to actually send the message to&n; * the device and receive the response.&n; */
DECL|function|usb_stor_invoke_transport
r_void
id|usb_stor_invoke_transport
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|need_auto_sense
suffix:semicolon
r_int
id|result
suffix:semicolon
multiline_comment|/* send the command to the transport layer */
id|srb-&gt;resid
op_assign
l_int|0
suffix:semicolon
id|result
op_assign
id|us
op_member_access_from_pointer
id|transport
c_func
(paren
id|srb
comma
id|us
)paren
suffix:semicolon
multiline_comment|/* if the command gets aborted by the higher layers, we need to&n;&t; * short-circuit all other processing&n;&t; */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|US_FLIDX_TIMED_OUT
comma
op_amp
id|us-&gt;flags
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- command was aborted&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|Handle_Abort
suffix:semicolon
)brace
multiline_comment|/* if there is a transport error, reset and don&squot;t auto-sense */
r_if
c_cond
(paren
id|result
op_eq
id|USB_STOR_TRANSPORT_ERROR
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- transport indicates error, resetting&bslash;n&quot;
)paren
suffix:semicolon
id|us
op_member_access_from_pointer
id|transport_reset
c_func
(paren
id|us
)paren
suffix:semicolon
id|srb-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* if the transport provided its own sense data, don&squot;t auto-sense */
r_if
c_cond
(paren
id|result
op_eq
id|USB_STOR_TRANSPORT_NO_SENSE
)paren
(brace
id|srb-&gt;result
op_assign
id|SAM_STAT_CHECK_CONDITION
suffix:semicolon
r_return
suffix:semicolon
)brace
id|srb-&gt;result
op_assign
id|SAM_STAT_GOOD
suffix:semicolon
multiline_comment|/* Determine if we need to auto-sense&n;&t; *&n;&t; * I normally don&squot;t use a flag like this, but it&squot;s almost impossible&n;&t; * to understand what&squot;s going on here if I don&squot;t.&n;&t; */
id|need_auto_sense
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If we&squot;re running the CB transport, which is incapable&n;&t; * of determining status on its own, we will auto-sense&n;&t; * unless the operation involved a data-in transfer.  Devices&n;&t; * can signal most data-in errors by stalling the bulk-in pipe.&n;&t; */
r_if
c_cond
(paren
(paren
id|us-&gt;protocol
op_eq
id|US_PR_CB
op_logical_or
id|us-&gt;protocol
op_eq
id|US_PR_DPCM_USB
)paren
op_logical_and
id|srb-&gt;sc_data_direction
op_ne
id|DMA_FROM_DEVICE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- CB transport device requiring auto-sense&bslash;n&quot;
)paren
suffix:semicolon
id|need_auto_sense
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we have a failure, we&squot;re going to do a REQUEST_SENSE &n;&t; * automatically.  Note that we differentiate between a command&n;&t; * &quot;failure&quot; and an &quot;error&quot; in the transport mechanism.&n;&t; */
r_if
c_cond
(paren
id|result
op_eq
id|USB_STOR_TRANSPORT_FAILED
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- transport indicates command failure&bslash;n&quot;
)paren
suffix:semicolon
id|need_auto_sense
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * A short transfer on a command where we don&squot;t expect it&n;&t; * is unusual, but it doesn&squot;t mean we need to auto-sense.&n;&t; */
r_if
c_cond
(paren
(paren
id|srb-&gt;resid
OG
l_int|0
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
op_logical_or
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
op_logical_or
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|MODE_SENSE
)paren
op_logical_or
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|LOG_SENSE
)paren
op_logical_or
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|MODE_SENSE_10
)paren
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- unexpectedly short transfer&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Now, if we need to do the auto-sense, let&squot;s do it */
r_if
c_cond
(paren
id|need_auto_sense
)paren
(brace
r_int
id|temp_result
suffix:semicolon
r_void
op_star
id|old_request_buffer
suffix:semicolon
r_int
r_int
id|old_sg
suffix:semicolon
r_int
id|old_request_bufflen
suffix:semicolon
r_int
r_char
id|old_sc_data_direction
suffix:semicolon
r_int
r_char
id|old_cmd_len
suffix:semicolon
r_int
r_char
id|old_cmnd
(braket
id|MAX_COMMAND_SIZE
)braket
suffix:semicolon
r_int
r_int
id|old_serial_number
suffix:semicolon
r_int
id|old_resid
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Issuing auto-REQUEST_SENSE&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* save the old command */
id|memcpy
c_func
(paren
id|old_cmnd
comma
id|srb-&gt;cmnd
comma
id|MAX_COMMAND_SIZE
)paren
suffix:semicolon
id|old_cmd_len
op_assign
id|srb-&gt;cmd_len
suffix:semicolon
multiline_comment|/* set the command and the LUN */
id|memset
c_func
(paren
id|srb-&gt;cmnd
comma
l_int|0
comma
id|MAX_COMMAND_SIZE
)paren
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_assign
id|REQUEST_SENSE
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|1
)braket
op_assign
id|old_cmnd
(braket
l_int|1
)braket
op_amp
l_int|0xE0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|4
)braket
op_assign
l_int|18
suffix:semicolon
multiline_comment|/* FIXME: we must do the protocol translation here */
r_if
c_cond
(paren
id|us-&gt;subclass
op_eq
id|US_SC_RBC
op_logical_or
id|us-&gt;subclass
op_eq
id|US_SC_SCSI
)paren
id|srb-&gt;cmd_len
op_assign
l_int|6
suffix:semicolon
r_else
id|srb-&gt;cmd_len
op_assign
l_int|12
suffix:semicolon
multiline_comment|/* set the transfer direction */
id|old_sc_data_direction
op_assign
id|srb-&gt;sc_data_direction
suffix:semicolon
id|srb-&gt;sc_data_direction
op_assign
id|DMA_FROM_DEVICE
suffix:semicolon
multiline_comment|/* use the new buffer we have */
id|old_request_buffer
op_assign
id|srb-&gt;request_buffer
suffix:semicolon
id|srb-&gt;request_buffer
op_assign
id|srb-&gt;sense_buffer
suffix:semicolon
multiline_comment|/* set the buffer length for transfer */
id|old_request_bufflen
op_assign
id|srb-&gt;request_bufflen
suffix:semicolon
id|srb-&gt;request_bufflen
op_assign
l_int|18
suffix:semicolon
multiline_comment|/* set up for no scatter-gather use */
id|old_sg
op_assign
id|srb-&gt;use_sg
suffix:semicolon
id|srb-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* change the serial number -- toggle the high bit*/
id|old_serial_number
op_assign
id|srb-&gt;serial_number
suffix:semicolon
id|srb-&gt;serial_number
op_xor_assign
l_int|0x80000000
suffix:semicolon
multiline_comment|/* issue the auto-sense command */
id|old_resid
op_assign
id|srb-&gt;resid
suffix:semicolon
id|srb-&gt;resid
op_assign
l_int|0
suffix:semicolon
id|temp_result
op_assign
id|us
op_member_access_from_pointer
id|transport
c_func
(paren
id|us-&gt;srb
comma
id|us
)paren
suffix:semicolon
multiline_comment|/* let&squot;s clean up right away */
id|srb-&gt;resid
op_assign
id|old_resid
suffix:semicolon
id|srb-&gt;request_buffer
op_assign
id|old_request_buffer
suffix:semicolon
id|srb-&gt;request_bufflen
op_assign
id|old_request_bufflen
suffix:semicolon
id|srb-&gt;use_sg
op_assign
id|old_sg
suffix:semicolon
id|srb-&gt;serial_number
op_assign
id|old_serial_number
suffix:semicolon
id|srb-&gt;sc_data_direction
op_assign
id|old_sc_data_direction
suffix:semicolon
id|srb-&gt;cmd_len
op_assign
id|old_cmd_len
suffix:semicolon
id|memcpy
c_func
(paren
id|srb-&gt;cmnd
comma
id|old_cmnd
comma
id|MAX_COMMAND_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|US_FLIDX_TIMED_OUT
comma
op_amp
id|us-&gt;flags
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- auto-sense aborted&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|Handle_Abort
suffix:semicolon
)brace
r_if
c_cond
(paren
id|temp_result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- auto-sense failure&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* we skip the reset if this happens to be a&n;&t;&t;&t; * multi-target device, since failure of an&n;&t;&t;&t; * auto-sense is perfectly valid&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|us-&gt;flags
op_amp
id|US_FL_SCM_MULT_TARG
)paren
)paren
id|us
op_member_access_from_pointer
id|transport_reset
c_func
(paren
id|us
)paren
suffix:semicolon
id|srb-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
r_return
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- Result from auto-sense is %d&bslash;n&quot;
comma
id|temp_result
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- code: 0x%x, key: 0x%x, ASC: 0x%x, ASCQ: 0x%x&bslash;n&quot;
comma
id|srb-&gt;sense_buffer
(braket
l_int|0
)braket
comma
id|srb-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
comma
id|srb-&gt;sense_buffer
(braket
l_int|12
)braket
comma
id|srb-&gt;sense_buffer
(braket
l_int|13
)braket
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_USB_STORAGE_DEBUG
id|usb_stor_show_sense
c_func
(paren
id|srb-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
comma
id|srb-&gt;sense_buffer
(braket
l_int|12
)braket
comma
id|srb-&gt;sense_buffer
(braket
l_int|13
)braket
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* set the result so the higher layers expect this data */
id|srb-&gt;result
op_assign
id|SAM_STAT_CHECK_CONDITION
suffix:semicolon
multiline_comment|/* If things are really okay, then let&squot;s show that.  Zero&n;&t;&t; * out the sense buffer so the higher layers won&squot;t realize&n;&t;&t; * we did an unsolicited auto-sense. */
r_if
c_cond
(paren
id|result
op_eq
id|USB_STOR_TRANSPORT_GOOD
op_logical_and
multiline_comment|/* Filemark 0, ignore EOM, ILI 0, no sense */
(paren
id|srb-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xaf
)paren
op_eq
l_int|0
op_logical_and
multiline_comment|/* No ASC or ASCQ */
id|srb-&gt;sense_buffer
(braket
l_int|12
)braket
op_eq
l_int|0
op_logical_and
id|srb-&gt;sense_buffer
(braket
l_int|13
)braket
op_eq
l_int|0
)paren
(brace
id|srb-&gt;result
op_assign
id|SAM_STAT_GOOD
suffix:semicolon
id|srb-&gt;sense_buffer
(braket
l_int|0
)braket
op_assign
l_int|0x0
suffix:semicolon
)brace
)brace
multiline_comment|/* Did we transfer less than the minimum amount required? */
r_if
c_cond
(paren
id|srb-&gt;result
op_eq
id|SAM_STAT_GOOD
op_logical_and
id|srb-&gt;request_bufflen
op_minus
id|srb-&gt;resid
OL
id|srb-&gt;underflow
)paren
id|srb-&gt;result
op_assign
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
op_or
(paren
id|SUGGEST_RETRY
op_lshift
l_int|24
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* abort processing: the bulk-only transport requires a reset&n;&t; * following an abort */
id|Handle_Abort
suffix:colon
id|srb-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
r_if
c_cond
(paren
id|us-&gt;protocol
op_eq
id|US_PR_BULK
)paren
id|us
op_member_access_from_pointer
id|transport_reset
c_func
(paren
id|us
)paren
suffix:semicolon
)brace
multiline_comment|/* Stop the current URB transfer */
DECL|function|usb_stor_stop_transport
r_void
id|usb_stor_stop_transport
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;%s called&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* If the state machine is blocked waiting for an URB,&n;&t; * let&squot;s wake it up.  The test_and_clear_bit() call&n;&t; * guarantees that if a URB has just been submitted,&n;&t; * it won&squot;t be cancelled more than once. */
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|US_FLIDX_URB_ACTIVE
comma
op_amp
id|us-&gt;flags
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- cancelling URB&bslash;n&quot;
)paren
suffix:semicolon
id|usb_unlink_urb
c_func
(paren
id|us-&gt;current_urb
)paren
suffix:semicolon
)brace
multiline_comment|/* If we are waiting for a scatter-gather operation, cancel it. */
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|US_FLIDX_SG_ACTIVE
comma
op_amp
id|us-&gt;flags
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- cancelling sg request&bslash;n&quot;
)paren
suffix:semicolon
id|usb_sg_cancel
c_func
(paren
op_amp
id|us-&gt;current_sg
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Control/Bulk/Interrupt transport&n; */
DECL|function|usb_stor_CBI_transport
r_int
id|usb_stor_CBI_transport
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
r_int
id|transfer_length
op_assign
id|srb-&gt;request_bufflen
suffix:semicolon
r_int
r_int
id|pipe
op_assign
l_int|0
suffix:semicolon
r_int
id|result
suffix:semicolon
multiline_comment|/* COMMAND STAGE */
multiline_comment|/* let&squot;s send the command via the control pipe */
id|result
op_assign
id|usb_stor_ctrl_transfer
c_func
(paren
id|us
comma
id|us-&gt;send_ctrl_pipe
comma
id|US_CBI_ADSC
comma
id|USB_TYPE_CLASS
op_or
id|USB_RECIP_INTERFACE
comma
l_int|0
comma
id|us-&gt;ifnum
comma
id|srb-&gt;cmnd
comma
id|srb-&gt;cmd_len
)paren
suffix:semicolon
multiline_comment|/* check the return code for the command */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Call to usb_stor_ctrl_transfer() returned %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
multiline_comment|/* if we stalled the command, it means command failed */
r_if
c_cond
(paren
id|result
op_eq
id|USB_STOR_XFER_STALLED
)paren
(brace
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
multiline_comment|/* Uh oh... serious problem here */
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_XFER_GOOD
)paren
(brace
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/* DATA STAGE */
multiline_comment|/* transfer the data payload for this command, if one exists*/
r_if
c_cond
(paren
id|transfer_length
)paren
(brace
id|pipe
op_assign
id|srb-&gt;sc_data_direction
op_eq
id|DMA_FROM_DEVICE
ques
c_cond
id|us-&gt;recv_bulk_pipe
suffix:colon
id|us-&gt;send_bulk_pipe
suffix:semicolon
id|result
op_assign
id|usb_stor_bulk_transfer_sg
c_func
(paren
id|us
comma
id|pipe
comma
id|srb-&gt;request_buffer
comma
id|transfer_length
comma
id|srb-&gt;use_sg
comma
op_amp
id|srb-&gt;resid
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;CBI data stage result is 0x%x&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
multiline_comment|/* if we stalled the data transfer it means command failed */
r_if
c_cond
(paren
id|result
op_eq
id|USB_STOR_XFER_STALLED
)paren
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
r_if
c_cond
(paren
id|result
OG
id|USB_STOR_XFER_STALLED
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/* STATUS STAGE */
id|result
op_assign
id|usb_stor_intr_transfer
c_func
(paren
id|us
comma
id|us-&gt;iobuf
comma
l_int|2
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Got interrupt data (0x%x, 0x%x)&bslash;n&quot;
comma
id|us-&gt;iobuf
(braket
l_int|0
)braket
comma
id|us-&gt;iobuf
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
multiline_comment|/* UFI gives us ASC and ASCQ, like a request sense&n;&t; *&n;&t; * REQUEST_SENSE and INQUIRY don&squot;t affect the sense data on UFI&n;&t; * devices, so we ignore the information for those commands.  Note&n;&t; * that this means we could be ignoring a real error on these&n;&t; * commands, but that can&squot;t be helped.&n;&t; */
r_if
c_cond
(paren
id|us-&gt;subclass
op_eq
id|US_SC_UFI
)paren
(brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
op_logical_or
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
r_if
c_cond
(paren
id|us-&gt;iobuf
(braket
l_int|0
)braket
)paren
r_goto
id|Failed
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
multiline_comment|/* If not UFI, we interpret the data as a result code &n;&t; * The first byte should always be a 0x0.&n;&t; *&n;&t; * Some bogus devices don&squot;t follow that rule.  They stuff the ASC&n;&t; * into the first byte -- so if it&squot;s non-zero, call it a failure.&n;&t; */
r_if
c_cond
(paren
id|us-&gt;iobuf
(braket
l_int|0
)braket
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;CBI IRQ data showed reserved bType 0x%x&bslash;n&quot;
comma
id|us-&gt;iobuf
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_goto
id|Failed
suffix:semicolon
)brace
multiline_comment|/* The second byte &amp; 0x0F should be 0x0 for good, otherwise error */
r_switch
c_cond
(paren
id|us-&gt;iobuf
(braket
l_int|1
)braket
op_amp
l_int|0x0F
)paren
(brace
r_case
l_int|0x00
suffix:colon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
r_case
l_int|0x01
suffix:colon
r_goto
id|Failed
suffix:semicolon
)brace
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
multiline_comment|/* the CBI spec requires that the bulk pipe must be cleared&n;&t; * following any data-in/out command failure (section 2.4.3.1.3)&n;&t; */
id|Failed
suffix:colon
r_if
c_cond
(paren
id|pipe
)paren
id|usb_stor_clear_halt
c_func
(paren
id|us
comma
id|pipe
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
multiline_comment|/*&n; * Control/Bulk transport&n; */
DECL|function|usb_stor_CB_transport
r_int
id|usb_stor_CB_transport
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
r_int
id|transfer_length
op_assign
id|srb-&gt;request_bufflen
suffix:semicolon
r_int
id|result
suffix:semicolon
multiline_comment|/* COMMAND STAGE */
multiline_comment|/* let&squot;s send the command via the control pipe */
id|result
op_assign
id|usb_stor_ctrl_transfer
c_func
(paren
id|us
comma
id|us-&gt;send_ctrl_pipe
comma
id|US_CBI_ADSC
comma
id|USB_TYPE_CLASS
op_or
id|USB_RECIP_INTERFACE
comma
l_int|0
comma
id|us-&gt;ifnum
comma
id|srb-&gt;cmnd
comma
id|srb-&gt;cmd_len
)paren
suffix:semicolon
multiline_comment|/* check the return code for the command */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Call to usb_stor_ctrl_transfer() returned %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
multiline_comment|/* if we stalled the command, it means command failed */
r_if
c_cond
(paren
id|result
op_eq
id|USB_STOR_XFER_STALLED
)paren
(brace
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
multiline_comment|/* Uh oh... serious problem here */
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_XFER_GOOD
)paren
(brace
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/* DATA STAGE */
multiline_comment|/* transfer the data payload for this command, if one exists*/
r_if
c_cond
(paren
id|transfer_length
)paren
(brace
r_int
r_int
id|pipe
op_assign
id|srb-&gt;sc_data_direction
op_eq
id|DMA_FROM_DEVICE
ques
c_cond
id|us-&gt;recv_bulk_pipe
suffix:colon
id|us-&gt;send_bulk_pipe
suffix:semicolon
id|result
op_assign
id|usb_stor_bulk_transfer_sg
c_func
(paren
id|us
comma
id|pipe
comma
id|srb-&gt;request_buffer
comma
id|transfer_length
comma
id|srb-&gt;use_sg
comma
op_amp
id|srb-&gt;resid
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;CB data stage result is 0x%x&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
multiline_comment|/* if we stalled the data transfer it means command failed */
r_if
c_cond
(paren
id|result
op_eq
id|USB_STOR_XFER_STALLED
)paren
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
r_if
c_cond
(paren
id|result
OG
id|USB_STOR_XFER_STALLED
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/* STATUS STAGE */
multiline_comment|/* NOTE: CB does not have a status stage.  Silly, I know.  So&n;&t; * we have to catch this at a higher level.&n;&t; */
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
multiline_comment|/*&n; * Bulk only transport&n; */
multiline_comment|/* Determine what the maximum LUN supported is */
DECL|function|usb_stor_Bulk_max_lun
r_int
id|usb_stor_Bulk_max_lun
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|result
suffix:semicolon
multiline_comment|/* issue the command */
id|result
op_assign
id|usb_stor_control_msg
c_func
(paren
id|us
comma
id|us-&gt;recv_ctrl_pipe
comma
id|US_BULK_GET_MAX_LUN
comma
id|USB_DIR_IN
op_or
id|USB_TYPE_CLASS
op_or
id|USB_RECIP_INTERFACE
comma
l_int|0
comma
id|us-&gt;ifnum
comma
id|us-&gt;iobuf
comma
l_int|1
comma
id|HZ
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;GetMaxLUN command result is %d, data is %d&bslash;n&quot;
comma
id|result
comma
id|us-&gt;iobuf
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/* if we have a successful request, return the result */
r_if
c_cond
(paren
id|result
OG
l_int|0
)paren
r_return
id|us-&gt;iobuf
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* &n;&t; * Some devices (i.e. Iomega Zip100) need this -- apparently&n;&t; * the bulk pipes get STALLed when the GetMaxLUN request is&n;&t; * processed.   This is, in theory, harmless to all other devices&n;&t; * (regardless of if they stall or not).&n;&t; */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|usb_stor_clear_halt
c_func
(paren
id|us
comma
id|us-&gt;recv_bulk_pipe
)paren
suffix:semicolon
id|usb_stor_clear_halt
c_func
(paren
id|us
comma
id|us-&gt;send_bulk_pipe
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Some devices don&squot;t like GetMaxLUN.  They may STALL the control&n;&t; * pipe, they may return a zero-length result, they may do nothing at&n;&t; * all and timeout, or they may fail in even more bizarrely creative&n;&t; * ways.  In these cases the best approach is to use the default&n;&t; * value: only one LUN.&n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usb_stor_Bulk_transport
r_int
id|usb_stor_Bulk_transport
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_struct
id|bulk_cb_wrap
op_star
id|bcb
op_assign
(paren
r_struct
id|bulk_cb_wrap
op_star
)paren
id|us-&gt;iobuf
suffix:semicolon
r_struct
id|bulk_cs_wrap
op_star
id|bcs
op_assign
(paren
r_struct
id|bulk_cs_wrap
op_star
)paren
id|us-&gt;iobuf
suffix:semicolon
r_int
r_int
id|transfer_length
op_assign
id|srb-&gt;request_bufflen
suffix:semicolon
r_int
r_int
id|residue
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
id|fake_sense
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|cswlen
suffix:semicolon
r_int
r_int
id|cbwlen
op_assign
id|US_BULK_CB_WRAP_LEN
suffix:semicolon
multiline_comment|/* Take care of BULK32 devices; set extra byte to 0 */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|us-&gt;flags
op_amp
id|US_FL_BULK32
)paren
)paren
(brace
id|cbwlen
op_assign
l_int|32
suffix:semicolon
id|us-&gt;iobuf
(braket
l_int|31
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* set up the command wrapper */
id|bcb-&gt;Signature
op_assign
id|cpu_to_le32
c_func
(paren
id|US_BULK_CB_SIGN
)paren
suffix:semicolon
id|bcb-&gt;DataTransferLength
op_assign
id|cpu_to_le32
c_func
(paren
id|transfer_length
)paren
suffix:semicolon
id|bcb-&gt;Flags
op_assign
id|srb-&gt;sc_data_direction
op_eq
id|DMA_FROM_DEVICE
ques
c_cond
l_int|1
op_lshift
l_int|7
suffix:colon
l_int|0
suffix:semicolon
id|bcb-&gt;Tag
op_assign
id|srb-&gt;serial_number
suffix:semicolon
id|bcb-&gt;Lun
op_assign
id|srb-&gt;device-&gt;lun
suffix:semicolon
r_if
c_cond
(paren
id|us-&gt;flags
op_amp
id|US_FL_SCM_MULT_TARG
)paren
id|bcb-&gt;Lun
op_or_assign
id|srb-&gt;device-&gt;id
op_lshift
l_int|4
suffix:semicolon
id|bcb-&gt;Length
op_assign
id|srb-&gt;cmd_len
suffix:semicolon
multiline_comment|/* copy the command payload */
id|memset
c_func
(paren
id|bcb-&gt;CDB
comma
l_int|0
comma
r_sizeof
(paren
id|bcb-&gt;CDB
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|bcb-&gt;CDB
comma
id|srb-&gt;cmnd
comma
id|bcb-&gt;Length
)paren
suffix:semicolon
multiline_comment|/* send it to out endpoint */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bulk Command S 0x%x T 0x%x L %d F %d Trg %d LUN %d CL %d&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|bcb-&gt;Signature
)paren
comma
id|bcb-&gt;Tag
comma
id|le32_to_cpu
c_func
(paren
id|bcb-&gt;DataTransferLength
)paren
comma
id|bcb-&gt;Flags
comma
(paren
id|bcb-&gt;Lun
op_rshift
l_int|4
)paren
comma
(paren
id|bcb-&gt;Lun
op_amp
l_int|0x0F
)paren
comma
id|bcb-&gt;Length
)paren
suffix:semicolon
id|result
op_assign
id|usb_stor_bulk_transfer_buf
c_func
(paren
id|us
comma
id|us-&gt;send_bulk_pipe
comma
id|bcb
comma
id|cbwlen
comma
l_int|NULL
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bulk command transfer result=%d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
multiline_comment|/* DATA STAGE */
multiline_comment|/* send/receive data payload, if there is any */
multiline_comment|/* Genesys Logic interface chips need a 100us delay between the&n;&t; * command phase and the data phase */
r_if
c_cond
(paren
id|us-&gt;pusb_dev-&gt;descriptor.idVendor
op_eq
id|USB_VENDOR_ID_GENESYS
)paren
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
r_if
c_cond
(paren
id|transfer_length
)paren
(brace
r_int
r_int
id|pipe
op_assign
id|srb-&gt;sc_data_direction
op_eq
id|DMA_FROM_DEVICE
ques
c_cond
id|us-&gt;recv_bulk_pipe
suffix:colon
id|us-&gt;send_bulk_pipe
suffix:semicolon
id|result
op_assign
id|usb_stor_bulk_transfer_sg
c_func
(paren
id|us
comma
id|pipe
comma
id|srb-&gt;request_buffer
comma
id|transfer_length
comma
id|srb-&gt;use_sg
comma
op_amp
id|srb-&gt;resid
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bulk data transfer result 0x%x&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
id|USB_STOR_XFER_ERROR
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
multiline_comment|/* If the device tried to send back more data than the&n;&t;&t; * amount requested, the spec requires us to transfer&n;&t;&t; * the CSW anyway.  Since there&squot;s no point retrying the&n;&t;&t; * the command, we&squot;ll return fake sense data indicating&n;&t;&t; * Illegal Request, Invalid Field in CDB.&n;&t;&t; */
r_if
c_cond
(paren
id|result
op_eq
id|USB_STOR_XFER_LONG
)paren
id|fake_sense
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* See flow chart on pg 15 of the Bulk Only Transport spec for&n;&t; * an explanation of how this code works.&n;&t; */
multiline_comment|/* get CSW for device status */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Attempting to get CSW...&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|usb_stor_bulk_transfer_buf
c_func
(paren
id|us
comma
id|us-&gt;recv_bulk_pipe
comma
id|bcs
comma
id|US_BULK_CS_WRAP_LEN
comma
op_amp
id|cswlen
)paren
suffix:semicolon
multiline_comment|/* Some broken devices add unnecessary zero-length packets to the&n;&t; * end of their data transfers.  Such packets show up as 0-length&n;&t; * CSWs.  If we encounter such a thing, try to read the CSW again.&n;&t; */
r_if
c_cond
(paren
id|result
op_eq
id|USB_STOR_XFER_SHORT
op_logical_and
id|cswlen
op_eq
l_int|0
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Received 0-length CSW; retrying...&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|usb_stor_bulk_transfer_buf
c_func
(paren
id|us
comma
id|us-&gt;recv_bulk_pipe
comma
id|bcs
comma
id|US_BULK_CS_WRAP_LEN
comma
op_amp
id|cswlen
)paren
suffix:semicolon
)brace
multiline_comment|/* did the attempt to read the CSW fail? */
r_if
c_cond
(paren
id|result
op_eq
id|USB_STOR_XFER_STALLED
)paren
(brace
multiline_comment|/* get the status again */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Attempting to get CSW (2nd try)...&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|usb_stor_bulk_transfer_buf
c_func
(paren
id|us
comma
id|us-&gt;recv_bulk_pipe
comma
id|bcs
comma
id|US_BULK_CS_WRAP_LEN
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* if we still have a failure at this point, we&squot;re in trouble */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bulk status result = %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
multiline_comment|/* check bulk status */
id|residue
op_assign
id|le32_to_cpu
c_func
(paren
id|bcs-&gt;Residue
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bulk Status S 0x%x T 0x%x R %u Stat 0x%x&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|bcs-&gt;Signature
)paren
comma
id|bcs-&gt;Tag
comma
id|residue
comma
id|bcs-&gt;Status
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bcs-&gt;Signature
op_ne
id|cpu_to_le32
c_func
(paren
id|US_BULK_CS_SIGN
)paren
op_logical_and
id|bcs-&gt;Signature
op_ne
id|cpu_to_le32
c_func
(paren
id|US_BULK_CS_OLYMPUS_SIGN
)paren
)paren
op_logical_or
id|bcs-&gt;Tag
op_ne
id|srb-&gt;serial_number
op_logical_or
id|bcs-&gt;Status
OG
id|US_BULK_STAT_PHASE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bulk logical error&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/* try to compute the actual residue, based on how much data&n;&t; * was really transferred and what the device tells us */
r_if
c_cond
(paren
id|residue
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|us-&gt;flags
op_amp
id|US_FL_IGNORE_RESIDUE
)paren
op_logical_or
id|srb-&gt;sc_data_direction
op_eq
id|DMA_TO_DEVICE
)paren
(brace
id|residue
op_assign
id|min
c_func
(paren
id|residue
comma
id|transfer_length
)paren
suffix:semicolon
id|srb-&gt;resid
op_assign
id|max
c_func
(paren
id|srb-&gt;resid
comma
(paren
r_int
)paren
id|residue
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* based on the status code, we report good or bad */
r_switch
c_cond
(paren
id|bcs-&gt;Status
)paren
(brace
r_case
id|US_BULK_STAT_OK
suffix:colon
multiline_comment|/* device babbled -- return fake sense data */
r_if
c_cond
(paren
id|fake_sense
)paren
(brace
id|memcpy
c_func
(paren
id|srb-&gt;sense_buffer
comma
id|usb_stor_sense_invalidCDB
comma
r_sizeof
(paren
id|usb_stor_sense_invalidCDB
)paren
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_NO_SENSE
suffix:semicolon
)brace
multiline_comment|/* command good -- note that data could be short */
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
r_case
id|US_BULK_STAT_FAIL
suffix:colon
multiline_comment|/* command failed */
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
r_case
id|US_BULK_STAT_PHASE
suffix:colon
multiline_comment|/* phase error -- note that a transport reset will be&n;&t;&t;&t; * invoked by the invoke_transport() function&n;&t;&t;&t; */
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/* we should never get here, but if we do, we&squot;re in trouble */
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/***********************************************************************&n; * Reset routines&n; ***********************************************************************/
multiline_comment|/* This is the common part of the device reset code.&n; *&n; * It&squot;s handy that every transport mechanism uses the control endpoint for&n; * resets.&n; *&n; * Basically, we send a reset with a 20-second timeout, so we don&squot;t get&n; * jammed attempting to do the reset.&n; */
DECL|function|usb_stor_reset_common
r_static
r_int
id|usb_stor_reset_common
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
id|u8
id|request
comma
id|u8
id|requesttype
comma
id|u16
id|value
comma
id|u16
id|index
comma
r_void
op_star
id|data
comma
id|u16
id|size
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
id|result2
suffix:semicolon
r_int
id|rc
op_assign
id|FAILED
suffix:semicolon
multiline_comment|/* Let the SCSI layer know we are doing a reset, set the&n;&t; * RESETTING bit, and clear the ABORTING bit so that the reset&n;&t; * may proceed.&n;&t; */
id|scsi_lock
c_func
(paren
id|us-&gt;host
)paren
suffix:semicolon
id|usb_stor_report_device_reset
c_func
(paren
id|us
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|US_FLIDX_RESETTING
comma
op_amp
id|us-&gt;flags
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|US_FLIDX_ABORTING
comma
op_amp
id|us-&gt;flags
)paren
suffix:semicolon
id|scsi_unlock
c_func
(paren
id|us-&gt;host
)paren
suffix:semicolon
multiline_comment|/* A 20-second timeout may seem rather long, but a LaCie&n;&t; * StudioDrive USB2 device takes 16+ seconds to get going&n;&t; * following a powerup or USB attach event.&n;&t; */
id|result
op_assign
id|usb_stor_control_msg
c_func
(paren
id|us
comma
id|us-&gt;send_ctrl_pipe
comma
id|request
comma
id|requesttype
comma
id|value
comma
id|index
comma
id|data
comma
id|size
comma
l_int|20
op_star
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Soft reset failed: %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
multiline_comment|/* Give the device some time to recover from the reset,&n; &t; * but don&squot;t delay disconnect processing. */
id|wait_event_interruptible_timeout
c_func
(paren
id|us-&gt;dev_reset_wait
comma
id|test_bit
c_func
(paren
id|US_FLIDX_DISCONNECTING
comma
op_amp
id|us-&gt;flags
)paren
comma
id|HZ
op_star
l_int|6
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|US_FLIDX_DISCONNECTING
comma
op_amp
id|us-&gt;flags
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Reset interrupted by disconnect&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Soft reset: clearing bulk-in endpoint halt&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|usb_stor_clear_halt
c_func
(paren
id|us
comma
id|us-&gt;recv_bulk_pipe
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Soft reset: clearing bulk-out endpoint halt&bslash;n&quot;
)paren
suffix:semicolon
id|result2
op_assign
id|usb_stor_clear_halt
c_func
(paren
id|us
comma
id|us-&gt;send_bulk_pipe
)paren
suffix:semicolon
multiline_comment|/* return a result code based on the result of the control message */
r_if
c_cond
(paren
id|result
OL
l_int|0
op_logical_or
id|result2
OL
l_int|0
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Soft reset failed&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|Done
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Soft reset done&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_assign
id|SUCCESS
suffix:semicolon
id|Done
suffix:colon
id|clear_bit
c_func
(paren
id|US_FLIDX_RESETTING
comma
op_amp
id|us-&gt;flags
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* This issues a CB[I] Reset to the device in question&n; */
DECL|macro|CB_RESET_CMD_SIZE
mdefine_line|#define CB_RESET_CMD_SIZE&t;12
DECL|function|usb_stor_CB_reset
r_int
id|usb_stor_CB_reset
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;%s called&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|memset
c_func
(paren
id|us-&gt;iobuf
comma
l_int|0xFF
comma
id|CB_RESET_CMD_SIZE
)paren
suffix:semicolon
id|us-&gt;iobuf
(braket
l_int|0
)braket
op_assign
id|SEND_DIAGNOSTIC
suffix:semicolon
id|us-&gt;iobuf
(braket
l_int|1
)braket
op_assign
l_int|4
suffix:semicolon
r_return
id|usb_stor_reset_common
c_func
(paren
id|us
comma
id|US_CBI_ADSC
comma
id|USB_TYPE_CLASS
op_or
id|USB_RECIP_INTERFACE
comma
l_int|0
comma
id|us-&gt;ifnum
comma
id|us-&gt;iobuf
comma
id|CB_RESET_CMD_SIZE
)paren
suffix:semicolon
)brace
multiline_comment|/* This issues a Bulk-only Reset to the device in question, including&n; * clearing the subsequent endpoint halts that may occur.&n; */
DECL|function|usb_stor_Bulk_reset
r_int
id|usb_stor_Bulk_reset
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;%s called&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
id|usb_stor_reset_common
c_func
(paren
id|us
comma
id|US_BULK_RESET_REQUEST
comma
id|USB_TYPE_CLASS
op_or
id|USB_RECIP_INTERFACE
comma
l_int|0
comma
id|us-&gt;ifnum
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
eof
