multiline_comment|/* Driver for USB Mass Storage compliant devices&n; *&n; * $Id: transport.c,v 1.47 2002/04/22 03:39:43 mdharm Exp $&n; *&n; * Current development and maintenance by:&n; *   (c) 1999-2002 Matthew Dharm (mdharm-usb@one-eyed-alien.net)&n; *&n; * Developed with the assistance of:&n; *   (c) 2000 David L. Brown, Jr. (usb-storage@davidb.org)&n; *   (c) 2000 Stephen J. Gowdy (SGowdy@lbl.gov)&n; *   (c) 2002 Alan Stern &lt;stern@rowland.org&gt;&n; *&n; * Initial work by:&n; *   (c) 1999 Michael Gee (michael@linuxspecific.com)&n; *&n; * This driver is based on the &squot;USB Mass Storage Class&squot; document. This&n; * describes in detail the protocol used to communicate with such&n; * devices.  Clearly, the designers had SCSI and ATAPI commands in&n; * mind when they created this document.  The commands are all very&n; * similar to commands in the SCSI-II and ATAPI specifications.&n; *&n; * It is important to note that in a number of cases this class&n; * exhibits class-specific exemptions from the USB specification.&n; * Notably the usage of NAK, STALL and ACK differs from the norm, in&n; * that they are used to communicate wait, failed and OK on commands.&n; *&n; * Also, for certain devices, the interrupt endpoint is used to convey&n; * status of a command.&n; *&n; * Please see http://www.one-eyed-alien.net/~mdharm/linux-usb for more&n; * information about this driver.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2, or (at your option) any&n; * later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write to the Free Software Foundation, Inc.,&n; * 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &quot;transport.h&quot;
macro_line|#include &quot;protocol.h&quot;
macro_line|#include &quot;usb.h&quot;
macro_line|#include &quot;debug.h&quot;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
multiline_comment|/***********************************************************************&n; * Helper routines&n; ***********************************************************************/
multiline_comment|/* Calculate the length of the data transfer (not the command) for any&n; * given SCSI command&n; */
DECL|function|usb_stor_transfer_length
r_int
r_int
id|usb_stor_transfer_length
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|doDefault
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|total
op_assign
l_int|0
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
multiline_comment|/* This table tells us:&n;&t;   X = command not supported&n;&t;   L = return length in cmnd[4] (8 bits).&n;&t;   M = return length in cmnd[8] (8 bits).&n;&t;   G = return length in cmnd[3] and cmnd[4] (16 bits)&n;&t;   H = return length in cmnd[7] and cmnd[8] (16 bits)&n;&t;   I = return length in cmnd[8] and cmnd[9] (16 bits)&n;&t;   C = return length in cmnd[2] to cmnd[5] (32 bits)&n;&t;   D = return length in cmnd[6] to cmnd[9] (32 bits)&n;&t;   B = return length in blocksize so we use buff_len&n;&t;   R = return length in cmnd[2] to cmnd[4] (24 bits)&n;&t;   S = return length in cmnd[3] to cmnd[5] (24 bits)&n;&t;   T = return length in cmnd[6] to cmnd[8] (24 bits)&n;&t;   U = return length in cmnd[7] to cmnd[9] (24 bits)&n;&t;   0-9 = fixed return length&n;&t;   V = 20 bytes&n;&t;   W = 24 bytes&n;&t;   Z = return length is mode dependant or not in command, use buff_len&n;&t;*/
r_static
r_char
op_star
id|lengths
op_assign
multiline_comment|/* 0123456789ABCDEF   0123456789ABCDEF */
l_string|&quot;00XLZ6XZBXBBXXXB&quot;
l_string|&quot;00LBBLG0R0L0GG0X&quot;
multiline_comment|/* 00-1F */
l_string|&quot;XXXXT8XXB4B0BBBB&quot;
l_string|&quot;ZZZ0B00HCSSZTBHH&quot;
multiline_comment|/* 20-3F */
l_string|&quot;M0HHB0X000H0HH0X&quot;
l_string|&quot;XHH0HHXX0TH0H0XX&quot;
multiline_comment|/* 40-5F */
l_string|&quot;XXXXXXXXXXXXXXXX&quot;
l_string|&quot;XXXXXXXXXXXXXXXX&quot;
multiline_comment|/* 60-7F */
l_string|&quot;XXXXXXXXXXXXXXXX&quot;
l_string|&quot;XXXXXXXXXXXXXXXX&quot;
multiline_comment|/* 80-9F */
l_string|&quot;X0XXX00XB0BXBXBB&quot;
l_string|&quot;ZZZ0XUIDU000XHBX&quot;
multiline_comment|/* A0-BF */
l_string|&quot;XXXXXXXXXXXXXXXX&quot;
l_string|&quot;XXXXXXXXXXXXXXXX&quot;
multiline_comment|/* C0-DF */
l_string|&quot;XDXXXXXXXXXXXXXX&quot;
l_string|&quot;XXW00HXXXXXXXXXX&quot;
suffix:semicolon
multiline_comment|/* E0-FF */
multiline_comment|/* Commands checked in table:&n;&n;&t;   CHANGE_DEFINITION 40&n;&t;   COMPARE 39&n;&t;   COPY 18&n;&t;   COPY_AND_VERIFY 3a&n;&t;   ERASE 19&n;&t;   ERASE_10 2c&n;&t;   ERASE_12 ac&n;&t;   EXCHANGE_MEDIUM a6&n;&t;   FORMAT_UNIT 04&n;&t;   GET_DATA_BUFFER_STATUS 34&n;&t;   GET_MESSAGE_10 28&n;&t;   GET_MESSAGE_12 a8&n;&t;   GET_WINDOW 25   !!! Has more data than READ_CAPACITY, need to fix table&n;&t;   INITIALIZE_ELEMENT_STATUS 07 !!! REASSIGN_BLOCKS luckily uses buff_len&n;&t;   INQUIRY 12&n;&t;   LOAD_UNLOAD 1b&n;&t;   LOCATE 2b&n;&t;   LOCK_UNLOCK_CACHE 36&n;&t;   LOG_SELECT 4c&n;&t;   LOG_SENSE 4d&n;&t;   MEDIUM_SCAN 38     !!! This was M&n;&t;   MODE_SELECT6 15&n;&t;   MODE_SELECT_10 55&n;&t;   MODE_SENSE_6 1a&n;&t;   MODE_SENSE_10 5a&n;&t;   MOVE_MEDIUM a5&n;&t;   OBJECT_POSITION 31  !!! Same as SEARCH_DATA_EQUAL&n;&t;   PAUSE_RESUME 4b&n;&t;   PLAY_AUDIO_10 45&n;&t;   PLAY_AUDIO_12 a5&n;&t;   PLAY_AUDIO_MSF 47&n;&t;   PLAY_AUDIO_TRACK_INDEX 48&n;   &t;   PLAY_AUDIO_TRACK_RELATIVE_10 49&n;&t;   PLAY_AUDIO_TRACK_RELATIVE_12 a9&n;&t;   POSITION_TO_ELEMENT 2b&n;      &t;   PRE-FETCH 34&n;&t;   PREVENT_ALLOW_MEDIUM_REMOVAL 1e&n;&t;   PRINT 0a             !!! Same as WRITE_6 but is always in bytes&n;&t;   READ_6 08&n;&t;   READ_10 28&n;&t;   READ_12 a8&n;&t;   READ_BLOCK_LIMITS 05&n;&t;   READ_BUFFER 3c&n;&t;   READ_CAPACITY 25&n;&t;   READ_CDROM_CAPACITY 25&n;&t;   READ_DEFECT_DATA 37&n;&t;   READ_DEFECT_DATA_12 b7&n;&t;   READ_ELEMENT_STATUS b8 !!! Think this is in bytes&n;&t;   READ_GENERATION 29 !!! Could also be M?&n;&t;   READ_HEADER 44     !!! This was L&n;&t;   READ_LONG 3e&n;&t;   READ_POSITION 34   !!! This should be V but conflicts with PRE-FETCH&n;&t;   READ_REVERSE 0f&n;&t;   READ_SUB-CHANNEL 42 !!! Is this in bytes?&n;&t;   READ_TOC 43         !!! Is this in bytes?&n;&t;   READ_UPDATED_BLOCK 2d&n;&t;   REASSIGN_BLOCKS 07&n;&t;   RECEIVE 08        !!! Same as READ_6 probably in bytes though&n;&t;   RECEIVE_DIAGNOSTIC_RESULTS 1c&n;&t;   RECOVER_BUFFERED_DATA 14 !!! For PRINTERs this is bytes&n;&t;   RELEASE_UNIT 17&n;&t;   REQUEST_SENSE 03&n;&t;   REQUEST_VOLUME_ELEMENT_ADDRESS b5 !!! Think this is in bytes&n;&t;   RESERVE_UNIT 16&n;&t;   REWIND 01&n;&t;   REZERO_UNIT 01&n;&t;   SCAN 1b          !!! Conflicts with various commands, should be L&n;&t;   SEARCH_DATA_EQUAL 31&n;&t;   SEARCH_DATA_EQUAL_12 b1&n;&t;   SEARCH_DATA_LOW 30&n;&t;   SEARCH_DATA_LOW_12 b0&n;&t;   SEARCH_DATA_HIGH 32&n;&t;   SEARCH_DATA_HIGH_12 b2&n;&t;   SEEK_6 0b         !!! Conflicts with SLEW_AND_PRINT&n;&t;   SEEK_10 2b&n;&t;   SEND 0a           !!! Same as WRITE_6, probably in bytes though&n;&t;   SEND 2a           !!! Similar to WRITE_10 but for scanners&n;&t;   SEND_DIAGNOSTIC 1d&n;&t;   SEND_MESSAGE_6 0a   !!! Same as WRITE_6 - is in bytes&n;&t;   SEND_MESSAGE_10 2a  !!! Same as WRITE_10 - is in bytes&n;&t;   SEND_MESSAGE_12 aa  !!! Same as WRITE_12 - is in bytes&n;&t;   SEND_OPC 54&n;&t;   SEND_VOLUME_TAG b6 !!! Think this is in bytes&n;&t;   SET_LIMITS 33&n;&t;   SET_LIMITS_12 b3&n;&t;   SET_WINDOW 24&n;&t;   SLEW_AND_PRINT 0b !!! Conflicts with SEEK_6&n;&t;   SPACE 11&n;&t;   START_STOP_UNIT 1b&n;&t;   STOP_PRINT 1b&n;&t;   SYNCHRONIZE_BUFFER 10&n;&t;   SYNCHRONIZE_CACHE 35&n;&t;   TEST_UNIT_READY 00&n;&t;   UPDATE_BLOCK 3d&n;&t;   VERIFY 13&n;&t;   VERIFY 2f&n;&t;   VERIFY_12 af&n;&t;   WRITE_6 0a&n;&t;   WRITE_10 2a&n;&t;   WRITE_12 aa&n;&t;   WRITE_AND_VERIFY 2e&n;&t;   WRITE_AND_VERIFY_12 ae&n;&t;   WRITE_BUFFER 3b&n;&t;   WRITE_FILEMARKS 10&n;&t;   WRITE_LONG 3f&n;&t;   WRITE_SAME 41&n;&t;*/
r_if
c_cond
(paren
id|srb-&gt;sc_data_direction
op_eq
id|SCSI_DATA_WRITE
)paren
(brace
id|doDefault
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_switch
c_cond
(paren
id|lengths
(braket
id|srb-&gt;cmnd
(braket
l_int|0
)braket
)braket
)paren
(brace
r_case
l_char|&squot;L&squot;
suffix:colon
id|len
op_assign
id|srb-&gt;cmnd
(braket
l_int|4
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;M&squot;
suffix:colon
id|len
op_assign
id|srb-&gt;cmnd
(braket
l_int|8
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;0&squot;
suffix:colon
r_case
l_char|&squot;1&squot;
suffix:colon
r_case
l_char|&squot;2&squot;
suffix:colon
r_case
l_char|&squot;3&squot;
suffix:colon
r_case
l_char|&squot;4&squot;
suffix:colon
r_case
l_char|&squot;5&squot;
suffix:colon
r_case
l_char|&squot;6&squot;
suffix:colon
r_case
l_char|&squot;7&squot;
suffix:colon
r_case
l_char|&squot;8&squot;
suffix:colon
r_case
l_char|&squot;9&squot;
suffix:colon
id|len
op_assign
id|lengths
(braket
id|srb-&gt;cmnd
(braket
l_int|0
)braket
)braket
op_minus
l_char|&squot;0&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;G&squot;
suffix:colon
id|len
op_assign
(paren
(paren
(paren
r_int
r_int
)paren
id|srb-&gt;cmnd
(braket
l_int|3
)braket
)paren
op_lshift
l_int|8
)paren
op_or
id|srb-&gt;cmnd
(braket
l_int|4
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;H&squot;
suffix:colon
id|len
op_assign
(paren
(paren
(paren
r_int
r_int
)paren
id|srb-&gt;cmnd
(braket
l_int|7
)braket
)paren
op_lshift
l_int|8
)paren
op_or
id|srb-&gt;cmnd
(braket
l_int|8
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;I&squot;
suffix:colon
id|len
op_assign
(paren
(paren
(paren
r_int
r_int
)paren
id|srb-&gt;cmnd
(braket
l_int|8
)braket
)paren
op_lshift
l_int|8
)paren
op_or
id|srb-&gt;cmnd
(braket
l_int|9
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;R&squot;
suffix:colon
id|len
op_assign
(paren
(paren
(paren
r_int
r_int
)paren
id|srb-&gt;cmnd
(braket
l_int|2
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
(paren
r_int
r_int
)paren
id|srb-&gt;cmnd
(braket
l_int|3
)braket
)paren
op_lshift
l_int|8
)paren
op_or
id|srb-&gt;cmnd
(braket
l_int|4
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;S&squot;
suffix:colon
id|len
op_assign
(paren
(paren
(paren
r_int
r_int
)paren
id|srb-&gt;cmnd
(braket
l_int|3
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
(paren
r_int
r_int
)paren
id|srb-&gt;cmnd
(braket
l_int|4
)braket
)paren
op_lshift
l_int|8
)paren
op_or
id|srb-&gt;cmnd
(braket
l_int|5
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;T&squot;
suffix:colon
id|len
op_assign
(paren
(paren
(paren
r_int
r_int
)paren
id|srb-&gt;cmnd
(braket
l_int|6
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
(paren
r_int
r_int
)paren
id|srb-&gt;cmnd
(braket
l_int|7
)braket
)paren
op_lshift
l_int|8
)paren
op_or
id|srb-&gt;cmnd
(braket
l_int|8
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;U&squot;
suffix:colon
id|len
op_assign
(paren
(paren
(paren
r_int
r_int
)paren
id|srb-&gt;cmnd
(braket
l_int|7
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
(paren
r_int
r_int
)paren
id|srb-&gt;cmnd
(braket
l_int|8
)braket
)paren
op_lshift
l_int|8
)paren
op_or
id|srb-&gt;cmnd
(braket
l_int|9
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;C&squot;
suffix:colon
id|len
op_assign
(paren
(paren
(paren
r_int
r_int
)paren
id|srb-&gt;cmnd
(braket
l_int|2
)braket
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
(paren
r_int
r_int
)paren
id|srb-&gt;cmnd
(braket
l_int|3
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
(paren
r_int
r_int
)paren
id|srb-&gt;cmnd
(braket
l_int|4
)braket
)paren
op_lshift
l_int|8
)paren
op_or
id|srb-&gt;cmnd
(braket
l_int|5
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;D&squot;
suffix:colon
id|len
op_assign
(paren
(paren
(paren
r_int
r_int
)paren
id|srb-&gt;cmnd
(braket
l_int|6
)braket
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
(paren
r_int
r_int
)paren
id|srb-&gt;cmnd
(braket
l_int|7
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
(paren
r_int
r_int
)paren
id|srb-&gt;cmnd
(braket
l_int|8
)braket
)paren
op_lshift
l_int|8
)paren
op_or
id|srb-&gt;cmnd
(braket
l_int|9
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;V&squot;
suffix:colon
id|len
op_assign
l_int|20
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;W&squot;
suffix:colon
id|len
op_assign
l_int|24
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;B&squot;
suffix:colon
multiline_comment|/* Use buffer size due to different block sizes */
id|doDefault
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;X&squot;
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Error: UNSUPPORTED COMMAND %02X&bslash;n&quot;
comma
id|srb-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|doDefault
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;Z&squot;
suffix:colon
multiline_comment|/* Use buffer size due to mode dependence */
id|doDefault
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Error: COMMAND %02X out of range or table inconsistent (%c).&bslash;n&quot;
comma
id|srb-&gt;cmnd
(braket
l_int|0
)braket
comma
id|lengths
(braket
id|srb-&gt;cmnd
(braket
l_int|0
)braket
)braket
)paren
suffix:semicolon
id|doDefault
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|doDefault
op_eq
l_int|1
)paren
(brace
multiline_comment|/* Are we going to scatter gather? */
r_if
c_cond
(paren
id|srb-&gt;use_sg
)paren
(brace
multiline_comment|/* Add up the sizes of all the sg segments */
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|srb-&gt;request_buffer
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|srb-&gt;use_sg
suffix:semicolon
id|i
op_increment
)paren
id|total
op_add_assign
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
id|len
op_assign
id|total
suffix:semicolon
multiline_comment|/* Double-check to see if the advertised buffer&n;&t;&t;&t;    * length less than the actual buffer length --&n;&t;&t;&t;    * in other words, we should tend towards the&n;&t;&t;&t;    * conservative side for data transfers.&n;&t;&t;&t;    */
r_if
c_cond
(paren
id|len
OG
id|srb-&gt;request_bufflen
)paren
id|len
op_assign
id|srb-&gt;request_bufflen
suffix:semicolon
)brace
r_else
multiline_comment|/* Just return the length of the buffer */
id|len
op_assign
id|srb-&gt;request_bufflen
suffix:semicolon
)brace
multiline_comment|/* According to the linux-scsi people, any command sent which&n;&t; * violates this invariant is a bug.  In the hopes of removing&n;&t; * all the complex logic above, let&squot;s find them and eliminate them.&n;&t; */
r_if
c_cond
(paren
id|len
op_ne
id|srb-&gt;request_bufflen
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;USB len=%d, request_bufflen=%d&bslash;n&quot;
comma
id|len
comma
id|srb-&gt;request_bufflen
)paren
suffix:semicolon
id|dump_stack
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/***********************************************************************&n; * Data transfer routines&n; ***********************************************************************/
multiline_comment|/*&n; * This is subtle, so pay attention:&n; * ---------------------------------&n; * We&squot;re very concerned about races with a command abort.  Hanging this code&n; * is a sure fire way to hang the kernel.  (Note that this discussion applies&n; * only to transactions resulting from a scsi queued-command, since only&n; * these transactions are subject to a scsi abort.  Other transactions, such&n; * as those occurring during device-specific initialization, must be handled&n; * by a separate code path.)&n; *&n; * The abort function first sets the machine state, then atomically&n; * tests-and-clears the CAN_CANCEL bit in us-&gt;flags to see if the current_urb&n; * needs to be aborted.&n; *&n; * The submit function first verifies that the submission completed without&n; * errors, and only then sets the CAN_CANCEL bit.  This prevents the abort&n; * function from trying to cancel the URB while the submit call is underway.&n; * Next, the submit function must test the state to see if we got aborted&n; * before the submission or before setting the CAN_CANCEL bit.  If so, it&squot;s&n; * essential to abort the URB if it hasn&squot;t been cancelled already (i.e.,&n; * if the CAN_CANCEL bit is still set).  Either way, the function must then&n; * wait for the URB to finish.  Note that because the URB_ASYNC_UNLINK flag&n; * is set, the URB can still be in progress even after a call to&n; * usb_unlink_urb() returns.&n; *&n; * (It&squot;s also permissible, but not necessary, to test the state -before-&n; * submitting the URB.  Doing so would prevent an unnecessary submission if&n; * the transaction had already been aborted, but this is very unlikely to&n; * happen, because the abort would have to have been requested during actual&n; * kernel processing rather than during an I/O delay.)&n; *&n; * The idea is that (1) once the state is changed to ABORTING, either the&n; * aborting function or the submitting function is guaranteed to call&n; * usb_unlink_urb() for an active URB, and (2) test_and_clear_bit() prevents&n; * usb_unlink_urb() from being called more than once or from being called&n; * during usb_submit_urb().&n; */
multiline_comment|/* This is the completion handler which will wake us up when an URB&n; * completes.&n; */
DECL|function|usb_stor_blocking_completion
r_static
r_void
id|usb_stor_blocking_completion
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|completion
op_star
id|urb_done_ptr
op_assign
(paren
r_struct
id|completion
op_star
)paren
id|urb-&gt;context
suffix:semicolon
id|complete
c_func
(paren
id|urb_done_ptr
)paren
suffix:semicolon
)brace
multiline_comment|/* This is the common part of the URB message submission code&n; *&n; * All URBs from the usb-storage driver involved in handling a queued scsi&n; * command _must_ pass through this function (or something like it) for the&n; * abort mechanisms to work properly.&n; */
DECL|function|usb_stor_msg_common
r_static
r_int
id|usb_stor_msg_common
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_struct
id|completion
id|urb_done
suffix:semicolon
r_int
id|status
suffix:semicolon
multiline_comment|/* set up data structures for the wakeup system */
id|init_completion
c_func
(paren
op_amp
id|urb_done
)paren
suffix:semicolon
multiline_comment|/* fill the common fields in the URB */
id|us-&gt;current_urb-&gt;context
op_assign
op_amp
id|urb_done
suffix:semicolon
id|us-&gt;current_urb-&gt;actual_length
op_assign
l_int|0
suffix:semicolon
id|us-&gt;current_urb-&gt;error_count
op_assign
l_int|0
suffix:semicolon
id|us-&gt;current_urb-&gt;transfer_flags
op_assign
id|URB_ASYNC_UNLINK
suffix:semicolon
multiline_comment|/* submit the URB */
id|status
op_assign
id|usb_submit_urb
c_func
(paren
id|us-&gt;current_urb
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
multiline_comment|/* something went wrong */
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/* since the URB has been submitted successfully, it&squot;s now okay&n;&t; * to cancel it */
id|set_bit
c_func
(paren
id|US_FLIDX_CAN_CANCEL
comma
op_amp
id|us-&gt;flags
)paren
suffix:semicolon
multiline_comment|/* has the current command been aborted? */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|us-&gt;sm_state
)paren
op_eq
id|US_STATE_ABORTING
)paren
(brace
multiline_comment|/* cancel the URB, if it hasn&squot;t been cancelled already */
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|US_FLIDX_CAN_CANCEL
comma
op_amp
id|us-&gt;flags
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- cancelling URB&bslash;n&quot;
)paren
suffix:semicolon
id|usb_unlink_urb
c_func
(paren
id|us-&gt;current_urb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* wait for the completion of the URB */
id|wait_for_completion
c_func
(paren
op_amp
id|urb_done
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|US_FLIDX_CAN_CANCEL
comma
op_amp
id|us-&gt;flags
)paren
suffix:semicolon
multiline_comment|/* return the URB status */
r_return
id|us-&gt;current_urb-&gt;status
suffix:semicolon
)brace
multiline_comment|/* This is our function to emulate usb_control_msg() with enough control&n; * to make aborts/resets/timeouts work&n; */
DECL|function|usb_stor_control_msg
r_int
id|usb_stor_control_msg
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|pipe
comma
id|u8
id|request
comma
id|u8
id|requesttype
comma
id|u16
id|value
comma
id|u16
id|index
comma
r_void
op_star
id|data
comma
id|u16
id|size
)paren
(brace
r_int
id|status
suffix:semicolon
multiline_comment|/* fill in the devrequest structure */
id|us-&gt;dr-&gt;bRequestType
op_assign
id|requesttype
suffix:semicolon
id|us-&gt;dr-&gt;bRequest
op_assign
id|request
suffix:semicolon
id|us-&gt;dr-&gt;wValue
op_assign
id|cpu_to_le16
c_func
(paren
id|value
)paren
suffix:semicolon
id|us-&gt;dr-&gt;wIndex
op_assign
id|cpu_to_le16
c_func
(paren
id|index
)paren
suffix:semicolon
id|us-&gt;dr-&gt;wLength
op_assign
id|cpu_to_le16
c_func
(paren
id|size
)paren
suffix:semicolon
multiline_comment|/* fill and submit the URB */
id|usb_fill_control_urb
c_func
(paren
id|us-&gt;current_urb
comma
id|us-&gt;pusb_dev
comma
id|pipe
comma
(paren
r_int
r_char
op_star
)paren
id|us-&gt;dr
comma
id|data
comma
id|size
comma
id|usb_stor_blocking_completion
comma
l_int|NULL
)paren
suffix:semicolon
id|status
op_assign
id|usb_stor_msg_common
c_func
(paren
id|us
)paren
suffix:semicolon
multiline_comment|/* return the actual length of the data transferred if no error */
r_if
c_cond
(paren
id|status
op_eq
l_int|0
)paren
id|status
op_assign
id|us-&gt;current_urb-&gt;actual_length
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/* This is our function to emulate usb_bulk_msg() with enough control&n; * to make aborts/resets/timeouts work&n; */
DECL|function|usb_stor_bulk_msg
r_int
id|usb_stor_bulk_msg
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_void
op_star
id|data
comma
r_int
r_int
id|pipe
comma
r_int
r_int
id|len
comma
r_int
r_int
op_star
id|act_len
)paren
(brace
r_int
id|status
suffix:semicolon
multiline_comment|/* fill and submit the URB */
id|usb_fill_bulk_urb
c_func
(paren
id|us-&gt;current_urb
comma
id|us-&gt;pusb_dev
comma
id|pipe
comma
id|data
comma
id|len
comma
id|usb_stor_blocking_completion
comma
l_int|NULL
)paren
suffix:semicolon
id|status
op_assign
id|usb_stor_msg_common
c_func
(paren
id|us
)paren
suffix:semicolon
multiline_comment|/* store the actual length of the data transferred */
op_star
id|act_len
op_assign
id|us-&gt;current_urb-&gt;actual_length
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/* This is our function to submit interrupt URBs with enough control&n; * to make aborts/resets/timeouts work&n; *&n; * This routine always uses us-&gt;recv_intr_pipe as the pipe and&n; * us-&gt;ep_bInterval as the interrupt interval.&n; */
DECL|function|usb_stor_interrupt_msg
r_int
id|usb_stor_interrupt_msg
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_void
op_star
id|data
comma
r_int
r_int
id|len
comma
r_int
r_int
op_star
id|act_len
)paren
(brace
r_int
r_int
id|pipe
op_assign
id|us-&gt;recv_intr_pipe
suffix:semicolon
r_int
r_int
id|maxp
suffix:semicolon
r_int
id|status
suffix:semicolon
multiline_comment|/* calculate the max packet size */
id|maxp
op_assign
id|usb_maxpacket
c_func
(paren
id|us-&gt;pusb_dev
comma
id|pipe
comma
id|usb_pipeout
c_func
(paren
id|pipe
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|maxp
OG
id|len
)paren
id|maxp
op_assign
id|len
suffix:semicolon
multiline_comment|/* fill and submit the URB */
id|usb_fill_int_urb
c_func
(paren
id|us-&gt;current_urb
comma
id|us-&gt;pusb_dev
comma
id|pipe
comma
id|data
comma
id|maxp
comma
id|usb_stor_blocking_completion
comma
l_int|NULL
comma
id|us-&gt;ep_bInterval
)paren
suffix:semicolon
id|status
op_assign
id|usb_stor_msg_common
c_func
(paren
id|us
)paren
suffix:semicolon
multiline_comment|/* store the actual length of the data transferred */
op_star
id|act_len
op_assign
id|us-&gt;current_urb-&gt;actual_length
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/* This is a version of usb_clear_halt() that doesn&squot;t read the status from&n; * the device -- this is because some devices crash their internal firmware&n; * when the status is requested after a halt.&n; *&n; * A definitive list of these &squot;bad&squot; devices is too difficult to maintain or&n; * make complete enough to be useful.  This problem was first observed on the&n; * Hagiwara FlashGate DUAL unit.  However, bus traces reveal that neither&n; * MacOS nor Windows checks the status after clearing a halt.&n; *&n; * Since many vendors in this space limit their testing to interoperability&n; * with these two OSes, specification violations like this one are common.&n; */
DECL|function|usb_stor_clear_halt
r_int
id|usb_stor_clear_halt
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|pipe
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
id|endp
op_assign
id|usb_pipeendpoint
c_func
(paren
id|pipe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipein
(paren
id|pipe
)paren
)paren
id|endp
op_or_assign
id|USB_DIR_IN
suffix:semicolon
id|result
op_assign
id|usb_stor_control_msg
c_func
(paren
id|us
comma
id|us-&gt;send_ctrl_pipe
comma
id|USB_REQ_CLEAR_FEATURE
comma
id|USB_RECIP_ENDPOINT
comma
l_int|0
comma
id|endp
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* note: no 3*HZ timeout */
id|US_DEBUGP
c_func
(paren
l_string|&quot;usb_stor_clear_halt: result=%d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
multiline_comment|/* this is a failure case */
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_return
id|result
suffix:semicolon
multiline_comment|/* reset the toggles and endpoint flags */
id|usb_endpoint_running
c_func
(paren
id|us-&gt;pusb_dev
comma
id|usb_pipeendpoint
c_func
(paren
id|pipe
)paren
comma
id|usb_pipeout
c_func
(paren
id|pipe
)paren
)paren
suffix:semicolon
id|usb_settoggle
c_func
(paren
id|us-&gt;pusb_dev
comma
id|usb_pipeendpoint
c_func
(paren
id|pipe
)paren
comma
id|usb_pipeout
c_func
(paren
id|pipe
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Interpret the results of a URB transfer&n; *&n; * This function prints appropriate debugging messages, clears halts on&n; * bulk endpoints, and translates the status to the corresponding&n; * USB_STOR_XFER_xxx return code.&n; */
DECL|function|interpret_urb_result
r_static
r_int
id|interpret_urb_result
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|pipe
comma
r_int
r_int
id|length
comma
r_int
id|result
comma
r_int
r_int
id|partial
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Status code %d; transferred %u/%u&bslash;n&quot;
comma
id|result
comma
id|partial
comma
id|length
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|result
)paren
(brace
multiline_comment|/* no error code; did we send all the data? */
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
id|partial
op_ne
id|length
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- short transfer&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_XFER_SHORT
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- transfer complete&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_XFER_GOOD
suffix:semicolon
multiline_comment|/* stalled */
r_case
op_minus
id|EPIPE
suffix:colon
multiline_comment|/* for control endpoints, a stall indicates a protocol error */
r_if
c_cond
(paren
id|usb_pipecontrol
c_func
(paren
id|pipe
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- stall on control pipe&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_XFER_ERROR
suffix:semicolon
)brace
multiline_comment|/* for other sorts of endpoint, clear the stall */
id|US_DEBUGP
c_func
(paren
l_string|&quot;clearing endpoint halt for pipe 0x%x&bslash;n&quot;
comma
id|pipe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_stor_clear_halt
c_func
(paren
id|us
comma
id|pipe
)paren
OL
l_int|0
)paren
r_return
id|USB_STOR_XFER_ERROR
suffix:semicolon
r_return
id|USB_STOR_XFER_STALLED
suffix:semicolon
multiline_comment|/* NAK - that means we&squot;ve retried this a few times already */
r_case
op_minus
id|ETIMEDOUT
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- device NAKed&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_XFER_ERROR
suffix:semicolon
multiline_comment|/* the transfer was cancelled, presumably by an abort */
r_case
op_minus
id|ENODEV
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- transfer cancelled&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_XFER_ERROR
suffix:semicolon
multiline_comment|/* short scatter-gather read transfer */
r_case
op_minus
id|EREMOTEIO
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- short read transfer&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_XFER_SHORT
suffix:semicolon
multiline_comment|/* the catch-all error case */
r_default
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- unknown error&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_XFER_ERROR
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Transfer one control message&n; *&n; * This function does basically the same thing as usb_stor_control_msg()&n; * above, except that return codes are USB_STOR_XFER_xxx rather than the&n; * urb status or transfer length.&n; */
DECL|function|usb_stor_ctrl_transfer
r_int
id|usb_stor_ctrl_transfer
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|pipe
comma
id|u8
id|request
comma
id|u8
id|requesttype
comma
id|u16
id|value
comma
id|u16
id|index
comma
r_void
op_star
id|data
comma
id|u16
id|size
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_int
id|partial
op_assign
l_int|0
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;usb_stor_ctrl_transfer(): rq=%02x rqtype=%02x &quot;
l_string|&quot;value=%04x index=%02x len=%u&bslash;n&quot;
comma
id|request
comma
id|requesttype
comma
id|value
comma
id|index
comma
id|size
)paren
suffix:semicolon
id|result
op_assign
id|usb_stor_control_msg
c_func
(paren
id|us
comma
id|pipe
comma
id|request
comma
id|requesttype
comma
id|value
comma
id|index
comma
id|data
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OG
l_int|0
)paren
(brace
multiline_comment|/* Separate out the amount transferred */
id|partial
op_assign
id|result
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|interpret_urb_result
c_func
(paren
id|us
comma
id|pipe
comma
id|size
comma
id|result
comma
id|partial
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Receive one buffer via interrupt transfer&n; *&n; * This function does basically the same thing as usb_stor_interrupt_msg()&n; * above, except that return codes are USB_STOR_XFER_xxx rather than the&n; * urb status.&n; */
DECL|function|usb_stor_intr_transfer
r_int
id|usb_stor_intr_transfer
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_void
op_star
id|buf
comma
r_int
r_int
id|length
comma
r_int
r_int
op_star
id|act_len
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_int
id|partial
suffix:semicolon
multiline_comment|/* transfer the data */
id|US_DEBUGP
c_func
(paren
l_string|&quot;usb_stor_intr_transfer(): xfer %u bytes&bslash;n&quot;
comma
id|length
)paren
suffix:semicolon
id|result
op_assign
id|usb_stor_interrupt_msg
c_func
(paren
id|us
comma
id|buf
comma
id|length
comma
op_amp
id|partial
)paren
suffix:semicolon
r_if
c_cond
(paren
id|act_len
)paren
op_star
id|act_len
op_assign
id|partial
suffix:semicolon
r_return
id|interpret_urb_result
c_func
(paren
id|us
comma
id|us-&gt;recv_intr_pipe
comma
id|length
comma
id|result
comma
id|partial
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Transfer one buffer via bulk transfer&n; *&n; * This function does basically the same thing as usb_stor_bulk_msg()&n; * above, except that:&n; *&n; *&t;1.  If the bulk pipe stalls during the transfer, the halt is&n; *&t;    automatically cleared;&n; *&t;2.  Return codes are USB_STOR_XFER_xxx rather than the&n; *&t;    urb status or transfer length.&n; */
DECL|function|usb_stor_bulk_transfer_buf
r_int
id|usb_stor_bulk_transfer_buf
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|pipe
comma
r_void
op_star
id|buf
comma
r_int
r_int
id|length
comma
r_int
r_int
op_star
id|act_len
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_int
id|partial
suffix:semicolon
multiline_comment|/* transfer the data */
id|US_DEBUGP
c_func
(paren
l_string|&quot;usb_stor_bulk_transfer_buf(): xfer %u bytes&bslash;n&quot;
comma
id|length
)paren
suffix:semicolon
id|result
op_assign
id|usb_stor_bulk_msg
c_func
(paren
id|us
comma
id|buf
comma
id|pipe
comma
id|length
comma
op_amp
id|partial
)paren
suffix:semicolon
r_if
c_cond
(paren
id|act_len
)paren
op_star
id|act_len
op_assign
id|partial
suffix:semicolon
r_return
id|interpret_urb_result
c_func
(paren
id|us
comma
id|pipe
comma
id|length
comma
id|result
comma
id|partial
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Transfer a scatter-gather list via bulk transfer&n; *&n; * This function does basically the same thing as usb_stor_bulk_transfer_buf()&n; * above, but it uses the usbcore scatter-gather primitives&n; */
DECL|function|usb_stor_bulk_transfer_sglist
r_int
id|usb_stor_bulk_transfer_sglist
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|pipe
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|num_sg
comma
r_int
r_int
id|length
comma
r_int
r_int
op_star
id|act_len
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_int
id|partial
suffix:semicolon
multiline_comment|/* initialize the scatter-gather request block */
id|US_DEBUGP
c_func
(paren
l_string|&quot;usb_stor_bulk_transfer_sglist(): xfer %u bytes, &quot;
l_string|&quot;%d entries&bslash;n&quot;
comma
id|length
comma
id|num_sg
)paren
suffix:semicolon
id|result
op_assign
id|usb_sg_init
c_func
(paren
id|us-&gt;current_sg
comma
id|us-&gt;pusb_dev
comma
id|pipe
comma
l_int|0
comma
id|sg
comma
id|num_sg
comma
id|length
comma
id|SLAB_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;usb_sg_init returned %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_return
id|USB_STOR_XFER_ERROR
suffix:semicolon
)brace
multiline_comment|/* since the block has been initialized successfully, it&squot;s now&n;&t; * okay to cancel it */
id|set_bit
c_func
(paren
id|US_FLIDX_CANCEL_SG
comma
op_amp
id|us-&gt;flags
)paren
suffix:semicolon
multiline_comment|/* has the current command been aborted? */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|us-&gt;sm_state
)paren
op_eq
id|US_STATE_ABORTING
)paren
(brace
multiline_comment|/* cancel the request, if it hasn&squot;t been cancelled already */
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|US_FLIDX_CANCEL_SG
comma
op_amp
id|us-&gt;flags
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- cancelling sg request&bslash;n&quot;
)paren
suffix:semicolon
id|usb_sg_cancel
c_func
(paren
id|us-&gt;current_sg
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* wait for the completion of the transfer */
id|usb_sg_wait
c_func
(paren
id|us-&gt;current_sg
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|US_FLIDX_CANCEL_SG
comma
op_amp
id|us-&gt;flags
)paren
suffix:semicolon
id|result
op_assign
id|us-&gt;current_sg-&gt;status
suffix:semicolon
id|partial
op_assign
id|us-&gt;current_sg-&gt;bytes
suffix:semicolon
r_if
c_cond
(paren
id|act_len
)paren
op_star
id|act_len
op_assign
id|partial
suffix:semicolon
r_return
id|interpret_urb_result
c_func
(paren
id|us
comma
id|pipe
comma
id|length
comma
id|result
comma
id|partial
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Transfer an entire SCSI command&squot;s worth of data payload over the bulk&n; * pipe.&n; *&n; * Note that this uses usb_stor_bulk_transfer_buf() and&n; * usb_stor_bulk_transfer_sglist() to achieve its goals --&n; * this function simply determines whether we&squot;re going to use&n; * scatter-gather or not, and acts appropriately.&n; */
DECL|function|usb_stor_bulk_transfer_sg
r_int
id|usb_stor_bulk_transfer_sg
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|pipe
comma
r_void
op_star
id|buf
comma
r_int
r_int
id|length_left
comma
r_int
id|use_sg
comma
r_int
op_star
id|residual
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_int
id|partial
suffix:semicolon
multiline_comment|/* are we scatter-gathering? */
r_if
c_cond
(paren
id|use_sg
)paren
(brace
multiline_comment|/* use the usb core scatter-gather primitives */
id|result
op_assign
id|usb_stor_bulk_transfer_sglist
c_func
(paren
id|us
comma
id|pipe
comma
(paren
r_struct
id|scatterlist
op_star
)paren
id|buf
comma
id|use_sg
comma
id|length_left
comma
op_amp
id|partial
)paren
suffix:semicolon
id|length_left
op_sub_assign
id|partial
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* no scatter-gather, just make the request */
id|result
op_assign
id|usb_stor_bulk_transfer_buf
c_func
(paren
id|us
comma
id|pipe
comma
id|buf
comma
id|length_left
comma
op_amp
id|partial
)paren
suffix:semicolon
id|length_left
op_sub_assign
id|partial
suffix:semicolon
)brace
multiline_comment|/* store the residual and return the error code */
r_if
c_cond
(paren
id|residual
)paren
op_star
id|residual
op_assign
id|length_left
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/***********************************************************************&n; * Transport routines&n; ***********************************************************************/
multiline_comment|/* Invoke the transport and basic error-handling/recovery methods&n; *&n; * This is used by the protocol layers to actually send the message to&n; * the device and receive the response.&n; */
DECL|function|usb_stor_invoke_transport
r_void
id|usb_stor_invoke_transport
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|need_auto_sense
suffix:semicolon
r_int
id|result
suffix:semicolon
multiline_comment|/* send the command to the transport layer */
id|srb-&gt;resid
op_assign
l_int|0
suffix:semicolon
id|result
op_assign
id|us
op_member_access_from_pointer
id|transport
c_func
(paren
id|srb
comma
id|us
)paren
suffix:semicolon
multiline_comment|/* if the command gets aborted by the higher layers, we need to&n;&t; * short-circuit all other processing&n;&t; */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|us-&gt;sm_state
)paren
op_eq
id|US_STATE_ABORTING
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- transport indicates command was aborted&bslash;n&quot;
)paren
suffix:semicolon
id|srb-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* if there is a transport error, reset and don&squot;t auto-sense */
multiline_comment|/* What if we want to abort during the reset? */
r_if
c_cond
(paren
id|result
op_eq
id|USB_STOR_TRANSPORT_ERROR
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- transport indicates error, resetting&bslash;n&quot;
)paren
suffix:semicolon
id|us
op_member_access_from_pointer
id|transport_reset
c_func
(paren
id|us
)paren
suffix:semicolon
id|srb-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Determine if we need to auto-sense&n;&t; *&n;&t; * I normally don&squot;t use a flag like this, but it&squot;s almost impossible&n;&t; * to understand what&squot;s going on here if I don&squot;t.&n;&t; */
id|need_auto_sense
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If we&squot;re running the CB transport, which is incapable&n;&t; * of determining status on it&squot;s own, we need to auto-sense almost&n;&t; * every time.&n;&t; */
r_if
c_cond
(paren
id|us-&gt;protocol
op_eq
id|US_PR_CB
op_logical_or
id|us-&gt;protocol
op_eq
id|US_PR_DPCM_USB
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- CB transport device requiring auto-sense&bslash;n&quot;
)paren
suffix:semicolon
id|need_auto_sense
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* There are some exceptions to this.  Notably, if this is&n;&t;&t; * a UFI device and the command is REQUEST_SENSE or INQUIRY,&n;&t;&t; * then it is impossible to truly determine status.&n;&t;&t; */
r_if
c_cond
(paren
id|us-&gt;subclass
op_eq
id|US_SC_UFI
op_logical_and
(paren
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
op_logical_or
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;** no auto-sense for a special command&bslash;n&quot;
)paren
suffix:semicolon
id|need_auto_sense
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If we have a failure, we&squot;re going to do a REQUEST_SENSE &n;&t; * automatically.  Note that we differentiate between a command&n;&t; * &quot;failure&quot; and an &quot;error&quot; in the transport mechanism.&n;&t; */
r_if
c_cond
(paren
id|result
op_eq
id|USB_STOR_TRANSPORT_FAILED
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- transport indicates command failure&bslash;n&quot;
)paren
suffix:semicolon
id|need_auto_sense
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Also, if we have a short transfer on a command that can&squot;t have&n;&t; * a short transfer, we&squot;re going to do this.&n;&t; */
r_if
c_cond
(paren
(paren
id|srb-&gt;resid
OG
l_int|0
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
op_logical_or
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
op_logical_or
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|MODE_SENSE
)paren
op_logical_or
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|LOG_SENSE
)paren
op_logical_or
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|MODE_SENSE_10
)paren
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- unexpectedly short transfer&bslash;n&quot;
)paren
suffix:semicolon
id|need_auto_sense
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Now, if we need to do the auto-sense, let&squot;s do it */
r_if
c_cond
(paren
id|need_auto_sense
)paren
(brace
r_int
id|temp_result
suffix:semicolon
r_void
op_star
id|old_request_buffer
suffix:semicolon
r_int
r_int
id|old_sg
suffix:semicolon
r_int
id|old_request_bufflen
suffix:semicolon
r_int
r_char
id|old_sc_data_direction
suffix:semicolon
r_int
r_char
id|old_cmnd
(braket
id|MAX_COMMAND_SIZE
)braket
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Issuing auto-REQUEST_SENSE&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* save the old command */
id|memcpy
c_func
(paren
id|old_cmnd
comma
id|srb-&gt;cmnd
comma
id|MAX_COMMAND_SIZE
)paren
suffix:semicolon
multiline_comment|/* set the command and the LUN */
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_assign
id|REQUEST_SENSE
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|1
)braket
op_assign
id|old_cmnd
(braket
l_int|1
)braket
op_amp
l_int|0xE0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|4
)braket
op_assign
l_int|18
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set the transfer direction */
id|old_sc_data_direction
op_assign
id|srb-&gt;sc_data_direction
suffix:semicolon
id|srb-&gt;sc_data_direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
multiline_comment|/* use the new buffer we have */
id|old_request_buffer
op_assign
id|srb-&gt;request_buffer
suffix:semicolon
id|srb-&gt;request_buffer
op_assign
id|srb-&gt;sense_buffer
suffix:semicolon
multiline_comment|/* set the buffer length for transfer */
id|old_request_bufflen
op_assign
id|srb-&gt;request_bufflen
suffix:semicolon
id|srb-&gt;request_bufflen
op_assign
l_int|18
suffix:semicolon
multiline_comment|/* set up for no scatter-gather use */
id|old_sg
op_assign
id|srb-&gt;use_sg
suffix:semicolon
id|srb-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* issue the auto-sense command */
id|temp_result
op_assign
id|us
op_member_access_from_pointer
id|transport
c_func
(paren
id|us-&gt;srb
comma
id|us
)paren
suffix:semicolon
multiline_comment|/* let&squot;s clean up right away */
id|srb-&gt;request_buffer
op_assign
id|old_request_buffer
suffix:semicolon
id|srb-&gt;request_bufflen
op_assign
id|old_request_bufflen
suffix:semicolon
id|srb-&gt;use_sg
op_assign
id|old_sg
suffix:semicolon
id|srb-&gt;sc_data_direction
op_assign
id|old_sc_data_direction
suffix:semicolon
id|memcpy
c_func
(paren
id|srb-&gt;cmnd
comma
id|old_cmnd
comma
id|MAX_COMMAND_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|us-&gt;sm_state
)paren
op_eq
id|US_STATE_ABORTING
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- auto-sense aborted&bslash;n&quot;
)paren
suffix:semicolon
id|srb-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|temp_result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- auto-sense failure&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* we skip the reset if this happens to be a&n;&t;&t;&t; * multi-target device, since failure of an&n;&t;&t;&t; * auto-sense is perfectly valid&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|us-&gt;flags
op_amp
id|US_FL_SCM_MULT_TARG
)paren
)paren
(brace
multiline_comment|/* What if we try to abort during the reset? */
id|us
op_member_access_from_pointer
id|transport_reset
c_func
(paren
id|us
)paren
suffix:semicolon
)brace
id|srb-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
r_return
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- Result from auto-sense is %d&bslash;n&quot;
comma
id|temp_result
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- code: 0x%x, key: 0x%x, ASC: 0x%x, ASCQ: 0x%x&bslash;n&quot;
comma
id|srb-&gt;sense_buffer
(braket
l_int|0
)braket
comma
id|srb-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
comma
id|srb-&gt;sense_buffer
(braket
l_int|12
)braket
comma
id|srb-&gt;sense_buffer
(braket
l_int|13
)braket
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_USB_STORAGE_DEBUG
id|usb_stor_show_sense
c_func
(paren
id|srb-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
comma
id|srb-&gt;sense_buffer
(braket
l_int|12
)braket
comma
id|srb-&gt;sense_buffer
(braket
l_int|13
)braket
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* set the result so the higher layers expect this data */
id|srb-&gt;result
op_assign
id|CHECK_CONDITION
op_lshift
l_int|1
suffix:semicolon
multiline_comment|/* If things are really okay, then let&squot;s show that */
r_if
c_cond
(paren
(paren
id|srb-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_eq
l_int|0x0
)paren
id|srb-&gt;result
op_assign
id|GOOD
op_lshift
l_int|1
suffix:semicolon
)brace
r_else
multiline_comment|/* if (need_auto_sense) */
id|srb-&gt;result
op_assign
id|GOOD
op_lshift
l_int|1
suffix:semicolon
multiline_comment|/* Regardless of auto-sense, if we _know_ we have an error&n;&t; * condition, show that in the result code&n;&t; */
r_if
c_cond
(paren
id|result
op_eq
id|USB_STOR_TRANSPORT_FAILED
)paren
id|srb-&gt;result
op_assign
id|CHECK_CONDITION
op_lshift
l_int|1
suffix:semicolon
multiline_comment|/* If we think we&squot;re good, then make sure the sense data shows it.&n;&t; * This is necessary because the auto-sense for some devices always&n;&t; * sets byte 0 == 0x70, even if there is no error&n;&t; */
r_if
c_cond
(paren
(paren
id|us-&gt;protocol
op_eq
id|US_PR_CB
op_logical_or
id|us-&gt;protocol
op_eq
id|US_PR_DPCM_USB
)paren
op_logical_and
(paren
id|result
op_eq
id|USB_STOR_TRANSPORT_GOOD
)paren
op_logical_and
(paren
(paren
id|srb-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_eq
l_int|0x0
)paren
)paren
id|srb-&gt;sense_buffer
(braket
l_int|0
)braket
op_assign
l_int|0x0
suffix:semicolon
)brace
multiline_comment|/* Abort the currently running scsi command or device reset.&n; * This must be called with scsi_lock(us-&gt;srb-&gt;host) held */
DECL|function|usb_stor_abort_transport
r_void
id|usb_stor_abort_transport
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
r_int
id|state
op_assign
id|atomic_read
c_func
(paren
op_amp
id|us-&gt;sm_state
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;usb_stor_abort_transport called&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Normally the current state is RUNNING.  If the control thread&n;&t; * hasn&squot;t even started processing this command, the state will be&n;&t; * IDLE.  Anything else is a bug. */
id|BUG_ON
c_func
(paren
(paren
id|state
op_ne
id|US_STATE_RUNNING
op_logical_and
id|state
op_ne
id|US_STATE_IDLE
)paren
)paren
suffix:semicolon
multiline_comment|/* set state to abort and release the lock */
id|atomic_set
c_func
(paren
op_amp
id|us-&gt;sm_state
comma
id|US_STATE_ABORTING
)paren
suffix:semicolon
id|host
op_assign
id|us-&gt;srb-&gt;host
suffix:semicolon
id|scsi_unlock
c_func
(paren
id|host
)paren
suffix:semicolon
multiline_comment|/* If the state machine is blocked waiting for an URB,&n;&t; * let&squot;s wake it up */
multiline_comment|/* If we have an URB pending, cancel it.  The test_and_clear_bit()&n;&t; * call guarantees that if a URB has just been submitted, it&n;&t; * won&squot;t be cancelled more than once. */
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|US_FLIDX_CAN_CANCEL
comma
op_amp
id|us-&gt;flags
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- cancelling URB&bslash;n&quot;
)paren
suffix:semicolon
id|usb_unlink_urb
c_func
(paren
id|us-&gt;current_urb
)paren
suffix:semicolon
)brace
multiline_comment|/* If we are waiting for a scatter-gather operation, cancel it. */
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|US_FLIDX_CANCEL_SG
comma
op_amp
id|us-&gt;flags
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- cancelling sg request&bslash;n&quot;
)paren
suffix:semicolon
id|usb_sg_cancel
c_func
(paren
id|us-&gt;current_sg
)paren
suffix:semicolon
)brace
multiline_comment|/* Wait for the aborted command to finish */
id|wait_for_completion
c_func
(paren
op_amp
id|us-&gt;notify
)paren
suffix:semicolon
multiline_comment|/* Reacquire the lock: note that us-&gt;srb is now NULL */
id|scsi_lock
c_func
(paren
id|host
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Control/Bulk/Interrupt transport&n; */
DECL|function|usb_stor_CBI_transport
r_int
id|usb_stor_CBI_transport
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
r_int
id|transfer_length
op_assign
id|usb_stor_transfer_length
c_func
(paren
id|srb
)paren
suffix:semicolon
r_int
id|result
suffix:semicolon
multiline_comment|/* COMMAND STAGE */
multiline_comment|/* let&squot;s send the command via the control pipe */
id|result
op_assign
id|usb_stor_ctrl_transfer
c_func
(paren
id|us
comma
id|us-&gt;send_ctrl_pipe
comma
id|US_CBI_ADSC
comma
id|USB_TYPE_CLASS
op_or
id|USB_RECIP_INTERFACE
comma
l_int|0
comma
id|us-&gt;ifnum
comma
id|srb-&gt;cmnd
comma
id|srb-&gt;cmd_len
)paren
suffix:semicolon
multiline_comment|/* check the return code for the command */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Call to usb_stor_ctrl_transfer() returned %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_XFER_GOOD
)paren
(brace
multiline_comment|/* Uh oh... serious problem here */
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/* DATA STAGE */
multiline_comment|/* transfer the data payload for this command, if one exists*/
r_if
c_cond
(paren
id|transfer_length
)paren
(brace
r_int
r_int
id|pipe
op_assign
id|srb-&gt;sc_data_direction
op_eq
id|SCSI_DATA_READ
ques
c_cond
id|us-&gt;recv_bulk_pipe
suffix:colon
id|us-&gt;send_bulk_pipe
suffix:semicolon
id|result
op_assign
id|usb_stor_bulk_transfer_srb
c_func
(paren
id|us
comma
id|pipe
comma
id|srb
comma
id|transfer_length
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;CBI data stage result is 0x%x&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
id|USB_STOR_XFER_ERROR
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/* STATUS STAGE */
id|result
op_assign
id|usb_stor_intr_transfer
c_func
(paren
id|us
comma
id|us-&gt;irqdata
comma
r_sizeof
(paren
id|us-&gt;irqdata
)paren
comma
l_int|NULL
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Got interrupt data (0x%x, 0x%x)&bslash;n&quot;
comma
id|us-&gt;irqdata
(braket
l_int|0
)braket
comma
id|us-&gt;irqdata
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
multiline_comment|/* UFI gives us ASC and ASCQ, like a request sense&n;&t; *&n;&t; * REQUEST_SENSE and INQUIRY don&squot;t affect the sense data on UFI&n;&t; * devices, so we ignore the information for those commands.  Note&n;&t; * that this means we could be ignoring a real error on these&n;&t; * commands, but that can&squot;t be helped.&n;&t; */
r_if
c_cond
(paren
id|us-&gt;subclass
op_eq
id|US_SC_UFI
)paren
(brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
op_logical_or
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|us-&gt;irqdata
(braket
l_int|0
)braket
)paren
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
r_else
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
)brace
multiline_comment|/* If not UFI, we interpret the data as a result code &n;&t; * The first byte should always be a 0x0&n;&t; * The second byte &amp; 0x0F should be 0x0 for good, otherwise error &n;&t; */
r_if
c_cond
(paren
id|us-&gt;irqdata
(braket
l_int|0
)braket
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;CBI IRQ data showed reserved bType %d&bslash;n&quot;
comma
id|us-&gt;irqdata
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|us-&gt;irqdata
(braket
l_int|1
)braket
op_amp
l_int|0x0F
)paren
(brace
r_case
l_int|0x00
suffix:colon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
r_case
l_int|0x01
suffix:colon
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
r_default
suffix:colon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/* we should never get here, but if we do, we&squot;re in trouble */
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/*&n; * Control/Bulk transport&n; */
DECL|function|usb_stor_CB_transport
r_int
id|usb_stor_CB_transport
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
r_int
id|transfer_length
op_assign
id|usb_stor_transfer_length
c_func
(paren
id|srb
)paren
suffix:semicolon
r_int
id|result
suffix:semicolon
multiline_comment|/* COMMAND STAGE */
multiline_comment|/* let&squot;s send the command via the control pipe */
id|result
op_assign
id|usb_stor_ctrl_transfer
c_func
(paren
id|us
comma
id|us-&gt;send_ctrl_pipe
comma
id|US_CBI_ADSC
comma
id|USB_TYPE_CLASS
op_or
id|USB_RECIP_INTERFACE
comma
l_int|0
comma
id|us-&gt;ifnum
comma
id|srb-&gt;cmnd
comma
id|srb-&gt;cmd_len
)paren
suffix:semicolon
multiline_comment|/* check the return code for the command */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Call to usb_stor_ctrl_transfer() returned %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_XFER_GOOD
)paren
(brace
multiline_comment|/* Uh oh... serious problem here */
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/* DATA STAGE */
multiline_comment|/* transfer the data payload for this command, if one exists*/
r_if
c_cond
(paren
id|transfer_length
)paren
(brace
r_int
r_int
id|pipe
op_assign
id|srb-&gt;sc_data_direction
op_eq
id|SCSI_DATA_READ
ques
c_cond
id|us-&gt;recv_bulk_pipe
suffix:colon
id|us-&gt;send_bulk_pipe
suffix:semicolon
id|result
op_assign
id|usb_stor_bulk_transfer_srb
c_func
(paren
id|us
comma
id|pipe
comma
id|srb
comma
id|transfer_length
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;CB data stage result is 0x%x&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
id|USB_STOR_XFER_ERROR
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/* STATUS STAGE */
multiline_comment|/* NOTE: CB does not have a status stage.  Silly, I know.  So&n;&t; * we have to catch this at a higher level.&n;&t; */
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
multiline_comment|/*&n; * Bulk only transport&n; */
multiline_comment|/* Determine what the maximum LUN supported is */
DECL|function|usb_stor_Bulk_max_lun
r_int
id|usb_stor_Bulk_max_lun
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
r_char
id|data
suffix:semicolon
r_int
id|result
suffix:semicolon
multiline_comment|/* Issue the command -- use usb_control_msg() because this is&n;&t; * not a scsi queued-command.  Also note that at this point the&n;&t; * cached pipe values have not yet been stored. */
id|result
op_assign
id|usb_control_msg
c_func
(paren
id|us-&gt;pusb_dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
comma
id|US_BULK_GET_MAX_LUN
comma
id|USB_DIR_IN
op_or
id|USB_TYPE_CLASS
op_or
id|USB_RECIP_INTERFACE
comma
l_int|0
comma
id|us-&gt;ifnum
comma
op_amp
id|data
comma
r_sizeof
(paren
id|data
)paren
comma
id|HZ
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;GetMaxLUN command result is %d, data is %d&bslash;n&quot;
comma
id|result
comma
id|data
)paren
suffix:semicolon
multiline_comment|/* if we have a successful request, return the result */
r_if
c_cond
(paren
id|result
op_eq
l_int|1
)paren
r_return
id|data
suffix:semicolon
multiline_comment|/* return the default -- no LUNs */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usb_stor_Bulk_transport
r_int
id|usb_stor_Bulk_transport
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_struct
id|bulk_cb_wrap
id|bcb
suffix:semicolon
r_struct
id|bulk_cs_wrap
id|bcs
suffix:semicolon
r_int
r_int
id|transfer_length
op_assign
id|usb_stor_transfer_length
c_func
(paren
id|srb
)paren
suffix:semicolon
r_int
id|result
suffix:semicolon
multiline_comment|/* set up the command wrapper */
id|bcb.Signature
op_assign
id|cpu_to_le32
c_func
(paren
id|US_BULK_CB_SIGN
)paren
suffix:semicolon
id|bcb.DataTransferLength
op_assign
id|cpu_to_le32
c_func
(paren
id|transfer_length
)paren
suffix:semicolon
id|bcb.Flags
op_assign
id|srb-&gt;sc_data_direction
op_eq
id|SCSI_DATA_READ
ques
c_cond
l_int|1
op_lshift
l_int|7
suffix:colon
l_int|0
suffix:semicolon
id|bcb.Tag
op_assign
id|srb-&gt;serial_number
suffix:semicolon
id|bcb.Lun
op_assign
id|srb-&gt;cmnd
(braket
l_int|1
)braket
op_rshift
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|us-&gt;flags
op_amp
id|US_FL_SCM_MULT_TARG
)paren
id|bcb.Lun
op_or_assign
id|srb-&gt;target
op_lshift
l_int|4
suffix:semicolon
id|bcb.Length
op_assign
id|srb-&gt;cmd_len
suffix:semicolon
multiline_comment|/* copy the command payload */
id|memset
c_func
(paren
id|bcb.CDB
comma
l_int|0
comma
r_sizeof
(paren
id|bcb.CDB
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|bcb.CDB
comma
id|srb-&gt;cmnd
comma
id|bcb.Length
)paren
suffix:semicolon
multiline_comment|/* send it to out endpoint */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bulk command S 0x%x T 0x%x Trg %d LUN %d L %d F %d CL %d&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|bcb.Signature
)paren
comma
id|bcb.Tag
comma
(paren
id|bcb.Lun
op_rshift
l_int|4
)paren
comma
(paren
id|bcb.Lun
op_amp
l_int|0x0F
)paren
comma
id|le32_to_cpu
c_func
(paren
id|bcb.DataTransferLength
)paren
comma
id|bcb.Flags
comma
id|bcb.Length
)paren
suffix:semicolon
id|result
op_assign
id|usb_stor_bulk_transfer_buf
c_func
(paren
id|us
comma
id|us-&gt;send_bulk_pipe
comma
op_amp
id|bcb
comma
id|US_BULK_CB_WRAP_LEN
comma
l_int|NULL
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bulk command transfer result=%d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
multiline_comment|/* DATA STAGE */
multiline_comment|/* send/receive data payload, if there is any */
r_if
c_cond
(paren
id|transfer_length
)paren
(brace
r_int
r_int
id|pipe
op_assign
id|srb-&gt;sc_data_direction
op_eq
id|SCSI_DATA_READ
ques
c_cond
id|us-&gt;recv_bulk_pipe
suffix:colon
id|us-&gt;send_bulk_pipe
suffix:semicolon
id|result
op_assign
id|usb_stor_bulk_transfer_srb
c_func
(paren
id|us
comma
id|pipe
comma
id|srb
comma
id|transfer_length
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bulk data transfer result 0x%x&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
id|USB_STOR_XFER_ERROR
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/* See flow chart on pg 15 of the Bulk Only Transport spec for&n;&t; * an explanation of how this code works.&n;&t; */
multiline_comment|/* get CSW for device status */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Attempting to get CSW...&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|usb_stor_bulk_transfer_buf
c_func
(paren
id|us
comma
id|us-&gt;recv_bulk_pipe
comma
op_amp
id|bcs
comma
id|US_BULK_CS_WRAP_LEN
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* did the attempt to read the CSW fail? */
r_if
c_cond
(paren
id|result
op_eq
id|USB_STOR_XFER_STALLED
)paren
(brace
multiline_comment|/* get the status again */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Attempting to get CSW (2nd try)...&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|usb_stor_bulk_transfer_buf
c_func
(paren
id|us
comma
id|us-&gt;recv_bulk_pipe
comma
op_amp
id|bcs
comma
id|US_BULK_CS_WRAP_LEN
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* if we still have a failure at this point, we&squot;re in trouble */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bulk status result = %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
multiline_comment|/* check bulk status */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bulk status Sig 0x%x T 0x%x R %d Stat 0x%x&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|bcs.Signature
)paren
comma
id|bcs.Tag
comma
id|bcs.Residue
comma
id|bcs.Status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bcs.Signature
op_ne
id|cpu_to_le32
c_func
(paren
id|US_BULK_CS_SIGN
)paren
op_logical_or
id|bcs.Tag
op_ne
id|bcb.Tag
op_logical_or
id|bcs.Status
OG
id|US_BULK_STAT_PHASE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bulk logical error&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/* based on the status code, we report good or bad */
r_switch
c_cond
(paren
id|bcs.Status
)paren
(brace
r_case
id|US_BULK_STAT_OK
suffix:colon
multiline_comment|/* command good -- note that data could be short */
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
r_case
id|US_BULK_STAT_FAIL
suffix:colon
multiline_comment|/* command failed */
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
r_case
id|US_BULK_STAT_PHASE
suffix:colon
multiline_comment|/* phase error -- note that a transport reset will be&n;&t;&t;&t; * invoked by the invoke_transport() function&n;&t;&t;&t; */
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/* we should never get here, but if we do, we&squot;re in trouble */
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/***********************************************************************&n; * Reset routines&n; ***********************************************************************/
multiline_comment|/* This is the common part of the device reset code.&n; *&n; * It&squot;s handy that every transport mechanism uses the control endpoint for&n; * resets.&n; *&n; * Basically, we send a reset with a 20-second timeout, so we don&squot;t get&n; * jammed attempting to do the reset.&n; */
DECL|function|usb_stor_reset_common
r_static
r_int
id|usb_stor_reset_common
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
id|u8
id|request
comma
id|u8
id|requesttype
comma
id|u16
id|value
comma
id|u16
id|index
comma
r_void
op_star
id|data
comma
id|u16
id|size
)paren
(brace
r_int
id|result
suffix:semicolon
multiline_comment|/* A 20-second timeout may seem rather long, but a LaCie&n;&t; *  StudioDrive USB2 device takes 16+ seconds to get going&n;&t; *  following a powerup or USB attach event. */
multiline_comment|/* Use usb_control_msg() because this is not a queued-command */
id|result
op_assign
id|usb_control_msg
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;send_ctrl_pipe
comma
id|request
comma
id|requesttype
comma
id|value
comma
id|index
comma
id|data
comma
id|size
comma
l_int|20
op_star
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_goto
id|Done
suffix:semicolon
multiline_comment|/* long wait for reset */
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_star
l_int|6
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
multiline_comment|/* Use usb_clear_halt() because this is not a queued-command */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Soft reset: clearing bulk-in endpoint halt&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;recv_bulk_pipe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_goto
id|Done
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Soft reset: clearing bulk-out endpoint halt&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;send_bulk_pipe
)paren
suffix:semicolon
id|Done
suffix:colon
multiline_comment|/* return a result code based on the result of the control message */
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Soft reset failed: %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
id|result
op_assign
id|FAILED
suffix:semicolon
)brace
r_else
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Soft reset done&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|SUCCESS
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/* This issues a CB[I] Reset to the device in question&n; */
DECL|function|usb_stor_CB_reset
r_int
id|usb_stor_CB_reset
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
r_char
id|cmd
(braket
l_int|12
)braket
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;CB_reset() called&bslash;n&quot;
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cmd
comma
l_int|0xFF
comma
r_sizeof
(paren
id|cmd
)paren
)paren
suffix:semicolon
id|cmd
(braket
l_int|0
)braket
op_assign
id|SEND_DIAGNOSTIC
suffix:semicolon
id|cmd
(braket
l_int|1
)braket
op_assign
l_int|4
suffix:semicolon
r_return
id|usb_stor_reset_common
c_func
(paren
id|us
comma
id|US_CBI_ADSC
comma
id|USB_TYPE_CLASS
op_or
id|USB_RECIP_INTERFACE
comma
l_int|0
comma
id|us-&gt;ifnum
comma
id|cmd
comma
r_sizeof
(paren
id|cmd
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* This issues a Bulk-only Reset to the device in question, including&n; * clearing the subsequent endpoint halts that may occur.&n; */
DECL|function|usb_stor_Bulk_reset
r_int
id|usb_stor_Bulk_reset
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bulk reset requested&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|usb_stor_reset_common
c_func
(paren
id|us
comma
id|US_BULK_RESET_REQUEST
comma
id|USB_TYPE_CLASS
op_or
id|USB_RECIP_INTERFACE
comma
l_int|0
comma
id|us-&gt;ifnum
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
eof
