multiline_comment|/* Driver for Datafab USB Compact Flash reader&n; *&n; * datafab driver v0.1:&n; *&n; * First release&n; *&n; * Current development and maintenance by:&n; *   (c) 2000 Jimmie Mayfield (mayfield+datafab@sackheads.org)&n; *   many thanks to Robert Baruch for the SanDisk SmartMedia reader driver&n; *   which I used as a template for this driver.&n; *   Some bugfixes and scatter-gather code by Gregory P. Smith &n; *   (greg-usb@electricrain.com)&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2, or (at your option) any&n; * later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write to the Free Software Foundation, Inc.,&n; * 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
multiline_comment|/*&n; * This driver attempts to support USB CompactFlash reader/writer devices&n; * based on Datafab USB-to-ATA chips.  It was specifically developed for the &n; * Datafab MDCFE-B USB CompactFlash reader but has since been found to work &n; * with a variety of Datafab-based devices from a number of manufacturers.&n; * I&squot;ve received a report of this driver working with a Datafab-based&n; * SmartMedia device though please be aware that I&squot;m personally unable to&n; * test SmartMedia support.&n; *&n; * This driver supports reading and writing.  If you&squot;re truly paranoid,&n; * however, you can force the driver into a write-protected state by setting&n; * the WP enable bits in datafab_handle_mode_sense().  Basically this means&n; * setting mode_param_header[3] = 0x80.&n; */
macro_line|#include &quot;transport.h&quot;
macro_line|#include &quot;protocol.h&quot;
macro_line|#include &quot;usb.h&quot;
macro_line|#include &quot;debug.h&quot;
macro_line|#include &quot;datafab.h&quot;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
r_extern
r_int
id|usb_stor_bulk_msg
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_void
op_star
id|data
comma
r_int
id|pipe
comma
r_int
r_int
id|len
comma
r_int
r_int
op_star
id|act_len
)paren
suffix:semicolon
r_static
r_int
id|datafab_determine_lun
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_struct
id|datafab_info
op_star
id|info
)paren
suffix:semicolon
DECL|function|datafab_dump_data
r_static
r_void
id|datafab_dump_data
c_func
(paren
r_int
r_char
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_int
r_char
id|buf
(braket
l_int|80
)braket
suffix:semicolon
r_int
id|sofar
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_return
suffix:semicolon
id|memset
c_func
(paren
id|buf
comma
l_int|0
comma
r_sizeof
(paren
id|buf
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sofar
op_assign
l_int|0
suffix:semicolon
id|sofar
OL
id|len
suffix:semicolon
id|sofar
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|buf
op_plus
id|strlen
c_func
(paren
id|buf
)paren
comma
l_string|&quot;%02x &quot;
comma
(paren
(paren
r_int
r_int
)paren
id|data
(braket
id|sofar
)braket
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sofar
op_mod
l_int|16
op_eq
l_int|15
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab:  %s&bslash;n&quot;
comma
id|buf
)paren
suffix:semicolon
id|memset
c_func
(paren
id|buf
comma
l_int|0
comma
r_sizeof
(paren
id|buf
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|buf
)paren
op_ne
l_int|0
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab:  %s&bslash;n&quot;
comma
id|buf
)paren
suffix:semicolon
)brace
DECL|function|datafab_raw_bulk
r_static
r_int
id|datafab_raw_bulk
c_func
(paren
r_int
id|direction
comma
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|data
comma
r_int
r_int
id|len
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
id|act_len
suffix:semicolon
r_int
id|pipe
suffix:semicolon
r_if
c_cond
(paren
id|direction
op_eq
id|SCSI_DATA_READ
)paren
id|pipe
op_assign
id|usb_rcvbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;ep_in
)paren
suffix:semicolon
r_else
id|pipe
op_assign
id|usb_sndbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;ep_out
)paren
suffix:semicolon
id|result
op_assign
id|usb_stor_bulk_msg
c_func
(paren
id|us
comma
id|data
comma
id|pipe
comma
id|len
comma
op_amp
id|act_len
)paren
suffix:semicolon
singleline_comment|// if we stall, we need to clear it before we go on 
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_raw_bulk: EPIPE. clearing endpoint halt for&quot;
l_string|&quot; pipe 0x%x, stalled at %d bytes&bslash;n&quot;
comma
id|pipe
comma
id|act_len
)paren
suffix:semicolon
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|pipe
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
)paren
(brace
singleline_comment|// NAK - that means we&squot;ve retried a few times already 
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ETIMEDOUT
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_raw_bulk:  device NAKed&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|US_BULK_TRANSFER_FAILED
suffix:semicolon
)brace
singleline_comment|// -ENOENT -- we canceled this transfer
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ENOENT
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_raw_bulk:  transfer aborted&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|US_BULK_TRANSFER_ABORTED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_raw_bulk:  output pipe stalled&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
singleline_comment|// the catch-all case
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_raw_bulk:  unknown error&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|US_BULK_TRANSFER_FAILED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|act_len
op_ne
id|len
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_raw_bulk:  Warning. Transferred only %d bytes&bslash;n&quot;
comma
id|act_len
)paren
suffix:semicolon
r_return
id|US_BULK_TRANSFER_SHORT
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_raw_bulk:  Transfered %d of %d bytes&bslash;n&quot;
comma
id|act_len
comma
id|len
)paren
suffix:semicolon
r_return
id|US_BULK_TRANSFER_GOOD
suffix:semicolon
)brace
DECL|function|datafab_bulk_read
r_static
r_inline
r_int
id|datafab_bulk_read
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|data
comma
r_int
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_bulk_read:  len = %d&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
r_return
id|datafab_raw_bulk
c_func
(paren
id|SCSI_DATA_READ
comma
id|us
comma
id|data
comma
id|len
)paren
suffix:semicolon
)brace
DECL|function|datafab_bulk_write
r_static
r_inline
r_int
id|datafab_bulk_write
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|data
comma
r_int
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_bulk_write:  len = %d&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
r_return
id|datafab_raw_bulk
c_func
(paren
id|SCSI_DATA_WRITE
comma
id|us
comma
id|data
comma
id|len
)paren
suffix:semicolon
)brace
DECL|function|datafab_read_data
r_static
r_int
id|datafab_read_data
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_struct
id|datafab_info
op_star
id|info
comma
id|u32
id|sector
comma
id|u32
id|sectors
comma
r_int
r_char
op_star
id|dest
comma
r_int
id|use_sg
)paren
(brace
r_int
r_char
id|command
(braket
l_int|8
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0xE0
comma
l_int|0x20
comma
l_int|0x01
)brace
suffix:semicolon
r_int
r_char
op_star
id|buffer
op_assign
l_int|NULL
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_int
r_char
id|thistime
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
op_assign
l_int|NULL
suffix:semicolon
r_int
id|totallen
comma
id|len
comma
id|result
suffix:semicolon
r_int
id|sg_idx
op_assign
l_int|0
comma
id|current_sg_offset
op_assign
l_int|0
suffix:semicolon
r_int
id|transferred
comma
id|rc
suffix:semicolon
singleline_comment|// we&squot;re working in LBA mode.  according to the ATA spec, 
singleline_comment|// we can support up to 28-bit addressing.  I don&squot;t know if Datafab
singleline_comment|// supports beyond 24-bit addressing.  It&squot;s kind of hard to test 
singleline_comment|// since it requires &gt; 8GB CF card.
singleline_comment|//
r_if
c_cond
(paren
id|sectors
OG
l_int|0x0FFFFFFF
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;lun
op_eq
op_minus
l_int|1
)paren
(brace
id|rc
op_assign
id|datafab_determine_lun
c_func
(paren
id|us
comma
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|rc
suffix:semicolon
)brace
id|command
(braket
l_int|5
)braket
op_add_assign
(paren
id|info-&gt;lun
op_lshift
l_int|4
)paren
suffix:semicolon
singleline_comment|// If we&squot;re using scatter-gather, we have to create a new
singleline_comment|// buffer to read all of the data in first, since a
singleline_comment|// scatter-gather buffer could in theory start in the middle
singleline_comment|// of a page, which would be bad. A developer who wants a
singleline_comment|// challenge might want to write a limited-buffer
singleline_comment|// version of this code.
id|totallen
op_assign
id|sectors
op_star
id|info-&gt;ssize
suffix:semicolon
r_do
(brace
singleline_comment|// loop, never allocate or transfer more than 64k at once (min(128k, 255*info-&gt;ssize) is the real limit)
id|len
op_assign
id|min_t
c_func
(paren
r_int
comma
id|totallen
comma
l_int|65536
)paren
suffix:semicolon
r_if
c_cond
(paren
id|use_sg
)paren
(brace
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|dest
suffix:semicolon
id|buffer
op_assign
id|kmalloc
c_func
(paren
id|len
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
op_eq
l_int|NULL
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|ptr
op_assign
id|buffer
suffix:semicolon
)brace
r_else
(brace
id|ptr
op_assign
id|dest
suffix:semicolon
)brace
id|thistime
op_assign
(paren
id|len
op_div
id|info-&gt;ssize
)paren
op_amp
l_int|0xff
suffix:semicolon
id|command
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|command
(braket
l_int|1
)braket
op_assign
id|thistime
suffix:semicolon
id|command
(braket
l_int|2
)braket
op_assign
id|sector
op_amp
l_int|0xFF
suffix:semicolon
id|command
(braket
l_int|3
)braket
op_assign
(paren
id|sector
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|command
(braket
l_int|4
)braket
op_assign
(paren
id|sector
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|command
(braket
l_int|5
)braket
op_or_assign
(paren
id|sector
op_rshift
l_int|24
)paren
op_amp
l_int|0x0F
suffix:semicolon
singleline_comment|// send the command
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_read_data:  sending following command&bslash;n&quot;
)paren
suffix:semicolon
id|datafab_dump_data
c_func
(paren
id|command
comma
r_sizeof
(paren
id|command
)paren
)paren
suffix:semicolon
id|result
op_assign
id|datafab_bulk_write
c_func
(paren
id|us
comma
id|command
comma
r_sizeof
(paren
id|command
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
r_if
c_cond
(paren
id|use_sg
)paren
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
singleline_comment|// read the result
id|result
op_assign
id|datafab_bulk_read
c_func
(paren
id|us
comma
id|ptr
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
r_if
c_cond
(paren
id|use_sg
)paren
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_read_data results:  %d bytes&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
singleline_comment|// datafab_dump_data(ptr, len);
id|sectors
op_sub_assign
id|thistime
suffix:semicolon
id|sector
op_add_assign
id|thistime
suffix:semicolon
r_if
c_cond
(paren
id|use_sg
)paren
(brace
id|transferred
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|sg_idx
OL
id|use_sg
op_logical_and
id|transferred
OL
id|len
)paren
(brace
r_if
c_cond
(paren
id|len
op_minus
id|transferred
op_ge
id|sg
(braket
id|sg_idx
)braket
dot
id|length
op_minus
id|current_sg_offset
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_read_data:  adding %d bytes to %d byte sg buffer&bslash;n&quot;
comma
id|sg
(braket
id|sg_idx
)braket
dot
id|length
op_minus
id|current_sg_offset
comma
id|sg
(braket
id|sg_idx
)braket
dot
id|length
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|sg
(braket
id|sg_idx
)braket
dot
id|address
op_plus
id|current_sg_offset
comma
id|buffer
op_plus
id|transferred
comma
id|sg
(braket
id|sg_idx
)braket
dot
id|length
op_minus
id|current_sg_offset
)paren
suffix:semicolon
id|transferred
op_add_assign
id|sg
(braket
id|sg_idx
)braket
dot
id|length
op_minus
id|current_sg_offset
suffix:semicolon
id|current_sg_offset
op_assign
l_int|0
suffix:semicolon
singleline_comment|// on to the next sg buffer
op_increment
id|sg_idx
suffix:semicolon
)brace
r_else
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_read_data:  adding %d bytes to %d byte sg buffer&bslash;n&quot;
comma
id|len
op_minus
id|transferred
comma
id|sg
(braket
id|sg_idx
)braket
dot
id|length
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|sg
(braket
id|sg_idx
)braket
dot
id|address
op_plus
id|current_sg_offset
comma
id|buffer
op_plus
id|transferred
comma
id|len
op_minus
id|transferred
)paren
suffix:semicolon
id|current_sg_offset
op_add_assign
id|len
op_minus
id|transferred
suffix:semicolon
singleline_comment|// this sg buffer is only partially full and we&squot;re out of data to copy in
r_break
suffix:semicolon
)brace
)brace
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
)brace
r_else
(brace
id|dest
op_add_assign
id|len
suffix:semicolon
)brace
id|totallen
op_sub_assign
id|len
suffix:semicolon
)brace
r_while
c_loop
(paren
id|totallen
OG
l_int|0
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
DECL|function|datafab_write_data
r_static
r_int
id|datafab_write_data
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_struct
id|datafab_info
op_star
id|info
comma
id|u32
id|sector
comma
id|u32
id|sectors
comma
r_int
r_char
op_star
id|src
comma
r_int
id|use_sg
)paren
(brace
r_int
r_char
id|command
(braket
l_int|8
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0xE0
comma
l_int|0x30
comma
l_int|0x02
)brace
suffix:semicolon
r_int
r_char
id|reply
(braket
l_int|2
)braket
op_assign
(brace
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
op_star
id|buffer
op_assign
l_int|NULL
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_int
r_char
id|thistime
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
op_assign
l_int|NULL
suffix:semicolon
r_int
id|totallen
comma
id|len
comma
id|result
suffix:semicolon
r_int
id|sg_idx
op_assign
l_int|0
comma
id|current_sg_offset
op_assign
l_int|0
suffix:semicolon
r_int
id|transferred
comma
id|rc
suffix:semicolon
singleline_comment|// we&squot;re working in LBA mode.  according to the ATA spec, 
singleline_comment|// we can support up to 28-bit addressing.  I don&squot;t know if Datafab
singleline_comment|// supports beyond 24-bit addressing.  It&squot;s kind of hard to test 
singleline_comment|// since it requires &gt; 8GB CF card.
singleline_comment|//
r_if
c_cond
(paren
id|sectors
OG
l_int|0x0FFFFFFF
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;lun
op_eq
op_minus
l_int|1
)paren
(brace
id|rc
op_assign
id|datafab_determine_lun
c_func
(paren
id|us
comma
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|rc
suffix:semicolon
)brace
id|command
(braket
l_int|5
)braket
op_add_assign
(paren
id|info-&gt;lun
op_lshift
l_int|4
)paren
suffix:semicolon
singleline_comment|// If we&squot;re using scatter-gather, we have to create a new
singleline_comment|// buffer to read all of the data in first, since a
singleline_comment|// scatter-gather buffer could in theory start in the middle
singleline_comment|// of a page, which would be bad. A developer who wants a
singleline_comment|// challenge might want to write a limited-buffer
singleline_comment|// version of this code.
id|totallen
op_assign
id|sectors
op_star
id|info-&gt;ssize
suffix:semicolon
r_do
(brace
singleline_comment|// loop, never allocate or transfer more than 64k at once (min(128k, 255*info-&gt;ssize) is the real limit)
id|len
op_assign
id|min_t
c_func
(paren
r_int
comma
id|totallen
comma
l_int|65536
)paren
suffix:semicolon
r_if
c_cond
(paren
id|use_sg
)paren
(brace
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|src
suffix:semicolon
id|buffer
op_assign
id|kmalloc
c_func
(paren
id|len
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
op_eq
l_int|NULL
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|ptr
op_assign
id|buffer
suffix:semicolon
id|memset
c_func
(paren
id|buffer
comma
l_int|0
comma
id|len
)paren
suffix:semicolon
singleline_comment|// copy the data from the sg bufs into the big contiguous buf
singleline_comment|//
id|transferred
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|transferred
OL
id|len
)paren
(brace
r_if
c_cond
(paren
id|len
op_minus
id|transferred
op_ge
id|sg
(braket
id|sg_idx
)braket
dot
id|length
op_minus
id|current_sg_offset
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_write_data:  getting %d bytes from %d byte sg buffer&bslash;n&quot;
comma
id|sg
(braket
id|sg_idx
)braket
dot
id|length
op_minus
id|current_sg_offset
comma
id|sg
(braket
id|sg_idx
)braket
dot
id|length
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
op_plus
id|transferred
comma
id|sg
(braket
id|sg_idx
)braket
dot
id|address
op_plus
id|current_sg_offset
comma
id|sg
(braket
id|sg_idx
)braket
dot
id|length
op_minus
id|current_sg_offset
)paren
suffix:semicolon
id|transferred
op_add_assign
id|sg
(braket
id|sg_idx
)braket
dot
id|length
op_minus
id|current_sg_offset
suffix:semicolon
id|current_sg_offset
op_assign
l_int|0
suffix:semicolon
singleline_comment|// on to the next sg buffer
op_increment
id|sg_idx
suffix:semicolon
)brace
r_else
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_write_data:  getting %d bytes from %d byte sg buffer&bslash;n&quot;
comma
id|len
op_minus
id|transferred
comma
id|sg
(braket
id|sg_idx
)braket
dot
id|length
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
op_plus
id|transferred
comma
id|sg
(braket
id|sg_idx
)braket
dot
id|address
op_plus
id|current_sg_offset
comma
id|len
op_minus
id|transferred
)paren
suffix:semicolon
id|current_sg_offset
op_add_assign
id|len
op_minus
id|transferred
suffix:semicolon
singleline_comment|// we only copied part of this sg buffer
r_break
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|ptr
op_assign
id|src
suffix:semicolon
)brace
id|thistime
op_assign
(paren
id|len
op_div
id|info-&gt;ssize
)paren
op_amp
l_int|0xff
suffix:semicolon
id|command
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|command
(braket
l_int|1
)braket
op_assign
id|thistime
suffix:semicolon
id|command
(braket
l_int|2
)braket
op_assign
id|sector
op_amp
l_int|0xFF
suffix:semicolon
id|command
(braket
l_int|3
)braket
op_assign
(paren
id|sector
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|command
(braket
l_int|4
)braket
op_assign
(paren
id|sector
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|command
(braket
l_int|5
)braket
op_or_assign
(paren
id|sector
op_rshift
l_int|24
)paren
op_amp
l_int|0x0F
suffix:semicolon
singleline_comment|// send the command
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_write_data:  sending following command&bslash;n&quot;
)paren
suffix:semicolon
id|datafab_dump_data
c_func
(paren
id|command
comma
r_sizeof
(paren
id|command
)paren
)paren
suffix:semicolon
id|result
op_assign
id|datafab_bulk_write
c_func
(paren
id|us
comma
id|command
comma
r_sizeof
(paren
id|command
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
r_if
c_cond
(paren
id|use_sg
)paren
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
singleline_comment|// send the data
id|result
op_assign
id|datafab_bulk_write
c_func
(paren
id|us
comma
id|ptr
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
r_if
c_cond
(paren
id|use_sg
)paren
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
singleline_comment|// read the result
id|result
op_assign
id|datafab_bulk_read
c_func
(paren
id|us
comma
id|reply
comma
r_sizeof
(paren
id|reply
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
r_if
c_cond
(paren
id|use_sg
)paren
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reply
(braket
l_int|0
)braket
op_ne
l_int|0x50
op_logical_and
id|reply
(braket
l_int|1
)braket
op_ne
l_int|0
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_write_data:  Gah! write return code: %02x %02x&bslash;n&quot;
comma
id|reply
(braket
l_int|0
)braket
comma
id|reply
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|use_sg
)paren
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
id|sectors
op_sub_assign
id|thistime
suffix:semicolon
id|sector
op_add_assign
id|thistime
suffix:semicolon
r_if
c_cond
(paren
id|use_sg
)paren
(brace
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
)brace
r_else
(brace
id|src
op_add_assign
id|len
suffix:semicolon
)brace
id|totallen
op_sub_assign
id|len
suffix:semicolon
)brace
r_while
c_loop
(paren
id|totallen
OG
l_int|0
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
DECL|function|datafab_determine_lun
r_static
r_int
id|datafab_determine_lun
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_struct
id|datafab_info
op_star
id|info
)paren
(brace
singleline_comment|// dual-slot readers can be thought of as dual-LUN devices.  we need to
singleline_comment|// determine which card slot is being used.  we&squot;ll send an IDENTIFY DEVICE
singleline_comment|// command and see which LUN responds...
singleline_comment|//
singleline_comment|// there might be a better way of doing this?
singleline_comment|//
r_int
r_char
id|command
(braket
l_int|8
)braket
op_assign
(brace
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0xa0
comma
l_int|0xec
comma
l_int|1
)brace
suffix:semicolon
r_int
r_char
id|buf
(braket
l_int|512
)braket
suffix:semicolon
r_int
id|count
op_assign
l_int|0
comma
id|rc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|us
op_logical_or
op_logical_neg
id|info
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_determine_lun:  locating...&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|// we&squot;ll try 10 times before giving up...
singleline_comment|//
r_while
c_loop
(paren
id|count
op_increment
OL
l_int|10
)paren
(brace
id|command
(braket
l_int|5
)braket
op_assign
l_int|0xa0
suffix:semicolon
id|rc
op_assign
id|datafab_bulk_write
c_func
(paren
id|us
comma
id|command
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|rc
suffix:semicolon
id|rc
op_assign
id|datafab_bulk_read
c_func
(paren
id|us
comma
id|buf
comma
r_sizeof
(paren
id|buf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
id|info-&gt;lun
op_assign
l_int|0
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
id|command
(braket
l_int|5
)braket
op_assign
l_int|0xb0
suffix:semicolon
id|rc
op_assign
id|datafab_bulk_write
c_func
(paren
id|us
comma
id|command
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|rc
suffix:semicolon
id|rc
op_assign
id|datafab_bulk_read
c_func
(paren
id|us
comma
id|buf
comma
r_sizeof
(paren
id|buf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
id|info-&gt;lun
op_assign
l_int|1
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
id|wait_ms
c_func
(paren
l_int|20
)paren
suffix:semicolon
)brace
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
DECL|function|datafab_id_device
r_static
r_int
id|datafab_id_device
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_struct
id|datafab_info
op_star
id|info
)paren
(brace
singleline_comment|// this is a variation of the ATA &quot;IDENTIFY DEVICE&quot; command...according
singleline_comment|// to the ATA spec, &squot;Sector Count&squot; isn&squot;t used but the Windows driver
singleline_comment|// sets this bit so we do too...
singleline_comment|//
r_int
r_char
id|command
(braket
l_int|8
)braket
op_assign
(brace
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0xa0
comma
l_int|0xec
comma
l_int|1
)brace
suffix:semicolon
r_int
r_char
id|reply
(braket
l_int|512
)braket
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|us
op_logical_or
op_logical_neg
id|info
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;lun
op_eq
op_minus
l_int|1
)paren
(brace
id|rc
op_assign
id|datafab_determine_lun
c_func
(paren
id|us
comma
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|rc
suffix:semicolon
)brace
id|command
(braket
l_int|5
)braket
op_add_assign
(paren
id|info-&gt;lun
op_lshift
l_int|4
)paren
suffix:semicolon
id|rc
op_assign
id|datafab_bulk_write
c_func
(paren
id|us
comma
id|command
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|rc
suffix:semicolon
singleline_comment|// we&squot;ll go ahead and extract the media capacity while we&squot;re here...
singleline_comment|//
id|rc
op_assign
id|datafab_bulk_read
c_func
(paren
id|us
comma
id|reply
comma
r_sizeof
(paren
id|reply
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
singleline_comment|// capacity is at word offset 57-58
singleline_comment|//
id|info-&gt;sectors
op_assign
(paren
(paren
id|u32
)paren
(paren
id|reply
(braket
l_int|117
)braket
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|reply
(braket
l_int|116
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|reply
(braket
l_int|115
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|reply
(braket
l_int|114
)braket
)paren
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|function|datafab_handle_mode_sense
r_static
r_int
id|datafab_handle_mode_sense
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
id|Scsi_Cmnd
op_star
id|srb
comma
r_int
r_char
op_star
id|ptr
comma
r_int
id|sense_6
)paren
(brace
r_int
r_char
id|mode_param_header
(braket
l_int|8
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|rw_err_page
(braket
l_int|12
)braket
op_assign
(brace
l_int|0x1
comma
l_int|0xA
comma
l_int|0x21
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|cache_page
(braket
l_int|12
)braket
op_assign
(brace
l_int|0x8
comma
l_int|0xA
comma
l_int|0x1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|rbac_page
(braket
l_int|12
)braket
op_assign
(brace
l_int|0x1B
comma
l_int|0xA
comma
l_int|0
comma
l_int|0x81
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|timer_page
(braket
l_int|8
)braket
op_assign
(brace
l_int|0x1C
comma
l_int|0x6
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|pc
comma
id|page_code
suffix:semicolon
r_int
r_int
id|total_len
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|param_len
comma
id|i
op_assign
l_int|0
suffix:semicolon
singleline_comment|// most of this stuff is just a hack to get things working.  the
singleline_comment|// datafab reader doesn&squot;t present a SCSI interface so we
singleline_comment|// fudge the SCSI commands...
singleline_comment|//
r_if
c_cond
(paren
id|sense_6
)paren
id|param_len
op_assign
id|srb-&gt;cmnd
(braket
l_int|4
)braket
suffix:semicolon
r_else
id|param_len
op_assign
(paren
(paren
id|u16
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|7
)braket
)paren
op_rshift
l_int|8
)paren
op_or
(paren
(paren
id|u16
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|8
)braket
)paren
)paren
suffix:semicolon
id|pc
op_assign
id|srb-&gt;cmnd
(braket
l_int|2
)braket
op_rshift
l_int|6
suffix:semicolon
id|page_code
op_assign
id|srb-&gt;cmnd
(braket
l_int|2
)braket
op_amp
l_int|0x3F
suffix:semicolon
r_switch
c_cond
(paren
id|pc
)paren
(brace
r_case
l_int|0x0
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_handle_mode_sense:  Current values&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x1
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_handle_mode_sense:  Changeable values&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x2
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_handle_mode_sense:  Default values&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x3
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_handle_mode_sense:  Saves values&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|mode_param_header
(braket
l_int|3
)braket
op_assign
l_int|0x80
suffix:semicolon
singleline_comment|// write enable
r_switch
c_cond
(paren
id|page_code
)paren
(brace
r_case
l_int|0x0
suffix:colon
singleline_comment|// vendor-specific mode
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
r_case
l_int|0x1
suffix:colon
id|total_len
op_assign
r_sizeof
(paren
id|rw_err_page
)paren
suffix:semicolon
id|mode_param_header
(braket
l_int|0
)braket
op_assign
id|total_len
op_rshift
l_int|8
suffix:semicolon
id|mode_param_header
(braket
l_int|1
)braket
op_assign
id|total_len
op_amp
l_int|0xFF
suffix:semicolon
id|mode_param_header
(braket
l_int|3
)braket
op_assign
l_int|0x00
suffix:semicolon
singleline_comment|// WP enable: 0x80
id|memcpy
c_func
(paren
id|ptr
comma
id|mode_param_header
comma
r_sizeof
(paren
id|mode_param_header
)paren
)paren
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
id|mode_param_header
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
op_plus
id|i
comma
id|rw_err_page
comma
r_sizeof
(paren
id|rw_err_page
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x8
suffix:colon
id|total_len
op_assign
r_sizeof
(paren
id|cache_page
)paren
suffix:semicolon
id|mode_param_header
(braket
l_int|0
)braket
op_assign
id|total_len
op_rshift
l_int|8
suffix:semicolon
id|mode_param_header
(braket
l_int|1
)braket
op_assign
id|total_len
op_amp
l_int|0xFF
suffix:semicolon
id|mode_param_header
(braket
l_int|3
)braket
op_assign
l_int|0x00
suffix:semicolon
singleline_comment|// WP enable: 0x80
id|memcpy
c_func
(paren
id|ptr
comma
id|mode_param_header
comma
r_sizeof
(paren
id|mode_param_header
)paren
)paren
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
id|mode_param_header
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
op_plus
id|i
comma
id|cache_page
comma
r_sizeof
(paren
id|cache_page
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x1B
suffix:colon
id|total_len
op_assign
r_sizeof
(paren
id|rbac_page
)paren
suffix:semicolon
id|mode_param_header
(braket
l_int|0
)braket
op_assign
id|total_len
op_rshift
l_int|8
suffix:semicolon
id|mode_param_header
(braket
l_int|1
)braket
op_assign
id|total_len
op_amp
l_int|0xFF
suffix:semicolon
id|mode_param_header
(braket
l_int|3
)braket
op_assign
l_int|0x00
suffix:semicolon
singleline_comment|// WP enable: 0x80
id|memcpy
c_func
(paren
id|ptr
comma
id|mode_param_header
comma
r_sizeof
(paren
id|mode_param_header
)paren
)paren
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
id|mode_param_header
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
op_plus
id|i
comma
id|rbac_page
comma
r_sizeof
(paren
id|rbac_page
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x1C
suffix:colon
id|total_len
op_assign
r_sizeof
(paren
id|timer_page
)paren
suffix:semicolon
id|mode_param_header
(braket
l_int|0
)braket
op_assign
id|total_len
op_rshift
l_int|8
suffix:semicolon
id|mode_param_header
(braket
l_int|1
)braket
op_assign
id|total_len
op_amp
l_int|0xFF
suffix:semicolon
id|mode_param_header
(braket
l_int|3
)braket
op_assign
l_int|0x00
suffix:semicolon
singleline_comment|// WP enable: 0x80
id|memcpy
c_func
(paren
id|ptr
comma
id|mode_param_header
comma
r_sizeof
(paren
id|mode_param_header
)paren
)paren
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
id|mode_param_header
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
op_plus
id|i
comma
id|timer_page
comma
r_sizeof
(paren
id|timer_page
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x3F
suffix:colon
singleline_comment|// retrieve all pages
id|total_len
op_assign
r_sizeof
(paren
id|timer_page
)paren
op_plus
r_sizeof
(paren
id|rbac_page
)paren
op_plus
r_sizeof
(paren
id|cache_page
)paren
op_plus
r_sizeof
(paren
id|rw_err_page
)paren
suffix:semicolon
id|mode_param_header
(braket
l_int|0
)braket
op_assign
id|total_len
op_rshift
l_int|8
suffix:semicolon
id|mode_param_header
(braket
l_int|1
)braket
op_assign
id|total_len
op_amp
l_int|0xFF
suffix:semicolon
id|mode_param_header
(braket
l_int|3
)braket
op_assign
l_int|0x00
suffix:semicolon
singleline_comment|// WP enable
id|memcpy
c_func
(paren
id|ptr
comma
id|mode_param_header
comma
r_sizeof
(paren
id|mode_param_header
)paren
)paren
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
id|mode_param_header
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
op_plus
id|i
comma
id|timer_page
comma
r_sizeof
(paren
id|timer_page
)paren
)paren
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
id|timer_page
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
op_plus
id|i
comma
id|rbac_page
comma
r_sizeof
(paren
id|rbac_page
)paren
)paren
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
id|rbac_page
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
op_plus
id|i
comma
id|cache_page
comma
r_sizeof
(paren
id|cache_page
)paren
)paren
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
id|cache_page
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
op_plus
id|i
comma
id|rw_err_page
comma
r_sizeof
(paren
id|rw_err_page
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
DECL|function|datafab_info_destructor
r_void
id|datafab_info_destructor
c_func
(paren
r_void
op_star
id|extra
)paren
(brace
singleline_comment|// this routine is a placeholder...
singleline_comment|// currently, we don&squot;t allocate any extra memory so we&squot;re okay
)brace
singleline_comment|// Transport for the Datafab MDCFE-B
singleline_comment|//
DECL|function|datafab_transport
r_int
id|datafab_transport
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_struct
id|datafab_info
op_star
id|info
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_int
r_int
id|block
comma
id|blocks
suffix:semicolon
r_int
r_char
op_star
id|ptr
op_assign
l_int|NULL
suffix:semicolon
r_int
r_char
id|inquiry_reply
(braket
l_int|36
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0x80
comma
l_int|0x00
comma
l_int|0x01
comma
l_int|0x1F
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|us-&gt;extra
)paren
(brace
id|us-&gt;extra
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|datafab_info
)paren
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|us-&gt;extra
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_transport:  Gah! Can&squot;t allocate storage for Datafab info struct!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
id|memset
c_func
(paren
id|us-&gt;extra
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|datafab_info
)paren
)paren
suffix:semicolon
id|us-&gt;extra_destructor
op_assign
id|datafab_info_destructor
suffix:semicolon
(paren
(paren
r_struct
id|datafab_info
op_star
)paren
id|us-&gt;extra
)paren
op_member_access_from_pointer
id|lun
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|info
op_assign
(paren
r_struct
id|datafab_info
op_star
)paren
(paren
id|us-&gt;extra
)paren
suffix:semicolon
id|ptr
op_assign
(paren
r_int
r_char
op_star
)paren
id|srb-&gt;request_buffer
suffix:semicolon
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_transport:  INQUIRY.  Returning bogus response&quot;
)paren
suffix:semicolon
id|memset
c_func
(paren
id|inquiry_reply
op_plus
l_int|8
comma
l_int|0
comma
l_int|28
)paren
suffix:semicolon
id|fill_inquiry_response
c_func
(paren
id|us
comma
id|inquiry_reply
comma
l_int|36
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|READ_CAPACITY
)paren
(brace
id|info-&gt;ssize
op_assign
l_int|0x200
suffix:semicolon
singleline_comment|// hard coded 512 byte sectors as per ATA spec
id|rc
op_assign
id|datafab_id_device
c_func
(paren
id|us
comma
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|rc
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_transport:  READ_CAPACITY:  %ld sectors, %ld bytes per sector&bslash;n&quot;
comma
id|info-&gt;sectors
comma
id|info-&gt;ssize
)paren
suffix:semicolon
singleline_comment|// build the reply
singleline_comment|//
id|ptr
(braket
l_int|0
)braket
op_assign
(paren
id|info-&gt;sectors
op_rshift
l_int|24
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|ptr
(braket
l_int|1
)braket
op_assign
(paren
id|info-&gt;sectors
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|ptr
(braket
l_int|2
)braket
op_assign
(paren
id|info-&gt;sectors
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|ptr
(braket
l_int|3
)braket
op_assign
(paren
id|info-&gt;sectors
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|ptr
(braket
l_int|4
)braket
op_assign
(paren
id|info-&gt;ssize
op_rshift
l_int|24
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|ptr
(braket
l_int|5
)braket
op_assign
(paren
id|info-&gt;ssize
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|ptr
(braket
l_int|6
)braket
op_assign
(paren
id|info-&gt;ssize
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|ptr
(braket
l_int|7
)braket
op_assign
(paren
id|info-&gt;ssize
)paren
op_amp
l_int|0xFF
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|MODE_SELECT_10
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_transport:  Gah! MODE_SELECT_10.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
singleline_comment|// don&squot;t bother implementing READ_6 or WRITE_6.  Just set MODE_XLATE and
singleline_comment|// let the usb storage code convert to READ_10/WRITE_10
singleline_comment|//
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|READ_10
)paren
(brace
id|block
op_assign
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|2
)braket
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|3
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|4
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|5
)braket
)paren
)paren
suffix:semicolon
id|blocks
op_assign
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|7
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|8
)braket
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_transport:  READ_10: read block 0x%04lx  count %ld&bslash;n&quot;
comma
id|block
comma
id|blocks
)paren
suffix:semicolon
r_return
id|datafab_read_data
c_func
(paren
id|us
comma
id|info
comma
id|block
comma
id|blocks
comma
id|ptr
comma
id|srb-&gt;use_sg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|READ_12
)paren
(brace
singleline_comment|// we&squot;ll probably never see a READ_12 but we&squot;ll do it anyway...
singleline_comment|//
id|block
op_assign
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|2
)braket
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|3
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|4
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|5
)braket
)paren
)paren
suffix:semicolon
id|blocks
op_assign
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|6
)braket
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|7
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|8
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|9
)braket
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_transport:  READ_12: read block 0x%04lx  count %ld&bslash;n&quot;
comma
id|block
comma
id|blocks
)paren
suffix:semicolon
r_return
id|datafab_read_data
c_func
(paren
id|us
comma
id|info
comma
id|block
comma
id|blocks
comma
id|ptr
comma
id|srb-&gt;use_sg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|WRITE_10
)paren
(brace
id|block
op_assign
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|2
)braket
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|3
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|4
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|5
)braket
)paren
)paren
suffix:semicolon
id|blocks
op_assign
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|7
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|8
)braket
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_transport:  WRITE_10: write block 0x%04lx  count %ld&bslash;n&quot;
comma
id|block
comma
id|blocks
)paren
suffix:semicolon
r_return
id|datafab_write_data
c_func
(paren
id|us
comma
id|info
comma
id|block
comma
id|blocks
comma
id|ptr
comma
id|srb-&gt;use_sg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|WRITE_12
)paren
(brace
singleline_comment|// we&squot;ll probably never see a WRITE_12 but we&squot;ll do it anyway...
singleline_comment|//
id|block
op_assign
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|2
)braket
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|3
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|4
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|5
)braket
)paren
)paren
suffix:semicolon
id|blocks
op_assign
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|6
)braket
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|7
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|8
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|9
)braket
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_transport:  WRITE_12: write block 0x%04lx  count %ld&bslash;n&quot;
comma
id|block
comma
id|blocks
)paren
suffix:semicolon
r_return
id|datafab_write_data
c_func
(paren
id|us
comma
id|info
comma
id|block
comma
id|blocks
comma
id|ptr
comma
id|srb-&gt;use_sg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|TEST_UNIT_READY
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_transport:  TEST_UNIT_READY.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|datafab_id_device
c_func
(paren
id|us
comma
id|info
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_transport:  REQUEST_SENSE.  Returning faked response&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|// this response is pretty bogus right now.  eventually if necessary
singleline_comment|// we can set the correct sense data.  so far though it hasn&squot;t been
singleline_comment|// necessary
singleline_comment|//
id|ptr
(braket
l_int|0
)braket
op_assign
l_int|0xF0
suffix:semicolon
id|ptr
(braket
l_int|2
)braket
op_assign
id|info-&gt;sense_key
suffix:semicolon
id|ptr
(braket
l_int|7
)braket
op_assign
l_int|11
suffix:semicolon
id|ptr
(braket
l_int|12
)braket
op_assign
id|info-&gt;sense_asc
suffix:semicolon
id|ptr
(braket
l_int|13
)braket
op_assign
id|info-&gt;sense_ascq
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|MODE_SENSE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_transport:  MODE_SENSE_6 detected&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|datafab_handle_mode_sense
c_func
(paren
id|us
comma
id|srb
comma
id|ptr
comma
id|TRUE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|MODE_SENSE_10
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_transport:  MODE_SENSE_10 detected&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|datafab_handle_mode_sense
c_func
(paren
id|us
comma
id|srb
comma
id|ptr
comma
id|FALSE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|ALLOW_MEDIUM_REMOVAL
)paren
(brace
singleline_comment|// sure.  whatever.  not like we can stop the user from
singleline_comment|// popping the media out of the device (no locking doors, etc)
singleline_comment|//
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;datafab_transport:  Gah! Unknown command: %d (0x%x)&bslash;n&quot;
comma
id|srb-&gt;cmnd
(braket
l_int|0
)braket
comma
id|srb-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
eof
