multiline_comment|/* Driver for SanDisk SDDR-09 SmartMedia reader&n; *&n; * $Id: sddr09.c,v 1.24 2002/04/22 03:39:43 mdharm Exp $&n; *   (c) 2000, 2001 Robert Baruch (autophile@starband.net)&n; *   (c) 2002 Andries Brouwer (aeb@cwi.nl)&n; * Developed with the assistance of:&n; *   (c) 2002 Alan Stern &lt;stern@rowland.org&gt;&n; *&n; * The SanDisk SDDR-09 SmartMedia reader uses the Shuttle EUSB-01 chip.&n; * This chip is a programmable USB controller. In the SDDR-09, it has&n; * been programmed to obey a certain limited set of SCSI commands.&n; * This driver translates the &quot;real&quot; SCSI commands to the SDDR-09 SCSI&n; * commands.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2, or (at your option) any&n; * later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write to the Free Software Foundation, Inc.,&n; * 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
multiline_comment|/*&n; * Known vendor commands: 12 bytes, first byte is opcode&n; *&n; * E7: read scatter gather&n; * E8: read&n; * E9: write&n; * EA: erase&n; * EB: reset&n; * EC: read status&n; * ED: read ID&n; * EE: write CIS (?)&n; * EF: compute checksum (?)&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;scsi/scsi.h&gt;
macro_line|#include &lt;scsi/scsi_cmnd.h&gt;
macro_line|#include &quot;usb.h&quot;
macro_line|#include &quot;transport.h&quot;
macro_line|#include &quot;protocol.h&quot;
macro_line|#include &quot;debug.h&quot;
macro_line|#include &quot;sddr09.h&quot;
DECL|macro|short_pack
mdefine_line|#define short_pack(lsb,msb) ( ((u16)(lsb)) | ( ((u16)(msb))&lt;&lt;8 ) )
DECL|macro|LSB_of
mdefine_line|#define LSB_of(s) ((s)&amp;0xFF)
DECL|macro|MSB_of
mdefine_line|#define MSB_of(s) ((s)&gt;&gt;8)
multiline_comment|/* #define US_DEBUGP printk */
multiline_comment|/*&n; * First some stuff that does not belong here:&n; * data on SmartMedia and other cards, completely&n; * unrelated to this driver.&n; * Similar stuff occurs in &lt;linux/mtd/nand_ids.h&gt;.&n; */
DECL|struct|nand_flash_dev
r_struct
id|nand_flash_dev
(brace
DECL|member|model_id
r_int
id|model_id
suffix:semicolon
DECL|member|chipshift
r_int
id|chipshift
suffix:semicolon
multiline_comment|/* 1&lt;&lt;cs bytes total capacity */
DECL|member|pageshift
r_char
id|pageshift
suffix:semicolon
multiline_comment|/* 1&lt;&lt;ps bytes in a page */
DECL|member|blockshift
r_char
id|blockshift
suffix:semicolon
multiline_comment|/* 1&lt;&lt;bs pages in an erase block */
DECL|member|zoneshift
r_char
id|zoneshift
suffix:semicolon
multiline_comment|/* 1&lt;&lt;zs blocks in a zone */
multiline_comment|/* # of logical blocks is 125/128 of this */
DECL|member|pageadrlen
r_char
id|pageadrlen
suffix:semicolon
multiline_comment|/* length of an address in bytes - 1 */
)brace
suffix:semicolon
multiline_comment|/*&n; * NAND Flash Manufacturer ID Codes&n; */
DECL|macro|NAND_MFR_AMD
mdefine_line|#define NAND_MFR_AMD&t;&t;0x01
DECL|macro|NAND_MFR_NATSEMI
mdefine_line|#define NAND_MFR_NATSEMI&t;0x8f
DECL|macro|NAND_MFR_TOSHIBA
mdefine_line|#define NAND_MFR_TOSHIBA&t;0x98
DECL|macro|NAND_MFR_SAMSUNG
mdefine_line|#define NAND_MFR_SAMSUNG&t;0xec
DECL|function|nand_flash_manufacturer
r_static
r_inline
r_char
op_star
id|nand_flash_manufacturer
c_func
(paren
r_int
id|manuf_id
)paren
(brace
r_switch
c_cond
(paren
id|manuf_id
)paren
(brace
r_case
id|NAND_MFR_AMD
suffix:colon
r_return
l_string|&quot;AMD&quot;
suffix:semicolon
r_case
id|NAND_MFR_NATSEMI
suffix:colon
r_return
l_string|&quot;NATSEMI&quot;
suffix:semicolon
r_case
id|NAND_MFR_TOSHIBA
suffix:colon
r_return
l_string|&quot;Toshiba&quot;
suffix:semicolon
r_case
id|NAND_MFR_SAMSUNG
suffix:colon
r_return
l_string|&quot;Samsung&quot;
suffix:semicolon
r_default
suffix:colon
r_return
l_string|&quot;unknown&quot;
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * It looks like it is unnecessary to attach manufacturer to the&n; * remaining data: SSFDC prescribes manufacturer-independent id codes.&n; *&n; * 256 MB NAND flash has a 5-byte ID with 2nd byte 0xaa, 0xba, 0xca or 0xda.&n; */
DECL|variable|nand_flash_ids
r_static
r_struct
id|nand_flash_dev
id|nand_flash_ids
(braket
)braket
op_assign
(brace
multiline_comment|/* NAND flash */
(brace
l_int|0x6e
comma
l_int|20
comma
l_int|8
comma
l_int|4
comma
l_int|8
comma
l_int|2
)brace
comma
multiline_comment|/* 1 MB */
(brace
l_int|0xe8
comma
l_int|20
comma
l_int|8
comma
l_int|4
comma
l_int|8
comma
l_int|2
)brace
comma
multiline_comment|/* 1 MB */
(brace
l_int|0xec
comma
l_int|20
comma
l_int|8
comma
l_int|4
comma
l_int|8
comma
l_int|2
)brace
comma
multiline_comment|/* 1 MB */
(brace
l_int|0x64
comma
l_int|21
comma
l_int|8
comma
l_int|4
comma
l_int|9
comma
l_int|2
)brace
comma
multiline_comment|/* 2 MB */
(brace
l_int|0xea
comma
l_int|21
comma
l_int|8
comma
l_int|4
comma
l_int|9
comma
l_int|2
)brace
comma
multiline_comment|/* 2 MB */
(brace
l_int|0x6b
comma
l_int|22
comma
l_int|9
comma
l_int|4
comma
l_int|9
comma
l_int|2
)brace
comma
multiline_comment|/* 4 MB */
(brace
l_int|0xe3
comma
l_int|22
comma
l_int|9
comma
l_int|4
comma
l_int|9
comma
l_int|2
)brace
comma
multiline_comment|/* 4 MB */
(brace
l_int|0xe5
comma
l_int|22
comma
l_int|9
comma
l_int|4
comma
l_int|9
comma
l_int|2
)brace
comma
multiline_comment|/* 4 MB */
(brace
l_int|0xe6
comma
l_int|23
comma
l_int|9
comma
l_int|4
comma
l_int|10
comma
l_int|2
)brace
comma
multiline_comment|/* 8 MB */
(brace
l_int|0x73
comma
l_int|24
comma
l_int|9
comma
l_int|5
comma
l_int|10
comma
l_int|2
)brace
comma
multiline_comment|/* 16 MB */
(brace
l_int|0x75
comma
l_int|25
comma
l_int|9
comma
l_int|5
comma
l_int|10
comma
l_int|2
)brace
comma
multiline_comment|/* 32 MB */
(brace
l_int|0x76
comma
l_int|26
comma
l_int|9
comma
l_int|5
comma
l_int|10
comma
l_int|3
)brace
comma
multiline_comment|/* 64 MB */
(brace
l_int|0x79
comma
l_int|27
comma
l_int|9
comma
l_int|5
comma
l_int|10
comma
l_int|3
)brace
comma
multiline_comment|/* 128 MB */
multiline_comment|/* MASK ROM */
(brace
l_int|0x5d
comma
l_int|21
comma
l_int|9
comma
l_int|4
comma
l_int|8
comma
l_int|2
)brace
comma
multiline_comment|/* 2 MB */
(brace
l_int|0xd5
comma
l_int|22
comma
l_int|9
comma
l_int|4
comma
l_int|9
comma
l_int|2
)brace
comma
multiline_comment|/* 4 MB */
(brace
l_int|0xd6
comma
l_int|23
comma
l_int|9
comma
l_int|4
comma
l_int|10
comma
l_int|2
)brace
comma
multiline_comment|/* 8 MB */
(brace
l_int|0x57
comma
l_int|24
comma
l_int|9
comma
l_int|4
comma
l_int|11
comma
l_int|2
)brace
comma
multiline_comment|/* 16 MB */
(brace
l_int|0x58
comma
l_int|25
comma
l_int|9
comma
l_int|4
comma
l_int|12
comma
l_int|2
)brace
comma
multiline_comment|/* 32 MB */
(brace
l_int|0
comma
)brace
)brace
suffix:semicolon
DECL|macro|SIZE
mdefine_line|#define SIZE(a)&t;(sizeof(a)/sizeof((a)[0]))
r_static
r_struct
id|nand_flash_dev
op_star
DECL|function|nand_find_id
id|nand_find_id
c_func
(paren
r_int
r_char
id|id
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SIZE
c_func
(paren
id|nand_flash_ids
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|nand_flash_ids
(braket
id|i
)braket
dot
id|model_id
op_eq
id|id
)paren
r_return
op_amp
(paren
id|nand_flash_ids
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * ECC computation.&n; */
DECL|variable|parity
r_static
r_int
r_char
id|parity
(braket
l_int|256
)braket
suffix:semicolon
DECL|variable|ecc2
r_static
r_int
r_char
id|ecc2
(braket
l_int|256
)braket
suffix:semicolon
DECL|function|nand_init_ecc
r_static
r_void
id|nand_init_ecc
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|j
comma
id|a
suffix:semicolon
id|parity
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
id|parity
(braket
id|i
)braket
op_assign
(paren
id|parity
(braket
id|i
op_amp
(paren
id|i
op_minus
l_int|1
)paren
)braket
op_xor
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
(brace
id|a
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|8
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_amp
(paren
l_int|1
op_lshift
id|j
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|j
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
id|a
op_xor_assign
l_int|0x04
suffix:semicolon
r_if
c_cond
(paren
(paren
id|j
op_amp
l_int|2
)paren
op_eq
l_int|0
)paren
id|a
op_xor_assign
l_int|0x10
suffix:semicolon
r_if
c_cond
(paren
(paren
id|j
op_amp
l_int|4
)paren
op_eq
l_int|0
)paren
id|a
op_xor_assign
l_int|0x40
suffix:semicolon
)brace
)brace
id|ecc2
(braket
id|i
)braket
op_assign
op_complement
(paren
id|a
op_xor
(paren
id|a
op_lshift
l_int|1
)paren
op_xor
(paren
id|parity
(braket
id|i
)braket
ques
c_cond
l_int|0xa8
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* compute 3-byte ecc on 256 bytes */
DECL|function|nand_compute_ecc
r_static
r_void
id|nand_compute_ecc
c_func
(paren
r_int
r_char
op_star
id|data
comma
r_int
r_char
op_star
id|ecc
)paren
(brace
r_int
id|i
comma
id|j
comma
id|a
suffix:semicolon
r_int
r_char
id|par
comma
id|bit
comma
id|bits
(braket
l_int|8
)braket
suffix:semicolon
id|par
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|8
suffix:semicolon
id|j
op_increment
)paren
id|bits
(braket
id|j
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* collect 16 checksum bits */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
(brace
id|par
op_xor_assign
id|data
(braket
id|i
)braket
suffix:semicolon
id|bit
op_assign
id|parity
(braket
id|data
(braket
id|i
)braket
)braket
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|8
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
(paren
id|i
op_amp
(paren
l_int|1
op_lshift
id|j
)paren
)paren
op_eq
l_int|0
)paren
id|bits
(braket
id|j
)braket
op_xor_assign
id|bit
suffix:semicolon
)brace
multiline_comment|/* put 4+4+4 = 12 bits in the ecc */
id|a
op_assign
(paren
id|bits
(braket
l_int|3
)braket
op_lshift
l_int|6
)paren
op_plus
(paren
id|bits
(braket
l_int|2
)braket
op_lshift
l_int|4
)paren
op_plus
(paren
id|bits
(braket
l_int|1
)braket
op_lshift
l_int|2
)paren
op_plus
id|bits
(braket
l_int|0
)braket
suffix:semicolon
id|ecc
(braket
l_int|0
)braket
op_assign
op_complement
(paren
id|a
op_xor
(paren
id|a
op_lshift
l_int|1
)paren
op_xor
(paren
id|parity
(braket
id|par
)braket
ques
c_cond
l_int|0xaa
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
id|a
op_assign
(paren
id|bits
(braket
l_int|7
)braket
op_lshift
l_int|6
)paren
op_plus
(paren
id|bits
(braket
l_int|6
)braket
op_lshift
l_int|4
)paren
op_plus
(paren
id|bits
(braket
l_int|5
)braket
op_lshift
l_int|2
)paren
op_plus
id|bits
(braket
l_int|4
)braket
suffix:semicolon
id|ecc
(braket
l_int|1
)braket
op_assign
op_complement
(paren
id|a
op_xor
(paren
id|a
op_lshift
l_int|1
)paren
op_xor
(paren
id|parity
(braket
id|par
)braket
ques
c_cond
l_int|0xaa
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
id|ecc
(braket
l_int|2
)braket
op_assign
id|ecc2
(braket
id|par
)braket
suffix:semicolon
)brace
DECL|function|nand_compare_ecc
r_static
r_int
id|nand_compare_ecc
c_func
(paren
r_int
r_char
op_star
id|data
comma
r_int
r_char
op_star
id|ecc
)paren
(brace
r_return
(paren
id|data
(braket
l_int|0
)braket
op_eq
id|ecc
(braket
l_int|0
)braket
op_logical_and
id|data
(braket
l_int|1
)braket
op_eq
id|ecc
(braket
l_int|1
)braket
op_logical_and
id|data
(braket
l_int|2
)braket
op_eq
id|ecc
(braket
l_int|2
)braket
)paren
suffix:semicolon
)brace
DECL|function|nand_store_ecc
r_static
r_void
id|nand_store_ecc
c_func
(paren
r_int
r_char
op_star
id|data
comma
r_int
r_char
op_star
id|ecc
)paren
(brace
id|memcpy
c_func
(paren
id|data
comma
id|ecc
comma
l_int|3
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The actual driver starts here.&n; */
multiline_comment|/*&n; * On my 16MB card, control blocks have size 64 (16 real control bytes,&n; * and 48 junk bytes). In reality of course the card uses 16 control bytes,&n; * so the reader makes up the remaining 48. Don&squot;t know whether these numbers&n; * depend on the card. For now a constant.&n; */
DECL|macro|CONTROL_SHIFT
mdefine_line|#define CONTROL_SHIFT 6
multiline_comment|/*&n; * On my Combo CF/SM reader, the SM reader has LUN 1.&n; * (and things fail with LUN 0).&n; * It seems LUN is irrelevant for others.&n; */
DECL|macro|LUN
mdefine_line|#define LUN&t;1
DECL|macro|LUNBITS
mdefine_line|#define&t;LUNBITS&t;(LUN &lt;&lt; 5)
multiline_comment|/*&n; * LBA and PBA are unsigned ints. Special values.&n; */
DECL|macro|UNDEF
mdefine_line|#define UNDEF    0xffffffff
DECL|macro|SPARE
mdefine_line|#define SPARE    0xfffffffe
DECL|macro|UNUSABLE
mdefine_line|#define UNUSABLE 0xfffffffd
DECL|variable|erase_bad_lba_entries
r_static
r_int
id|erase_bad_lba_entries
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* send vendor interface command (0x41) */
multiline_comment|/* called for requests 0, 1, 8 */
r_static
r_int
DECL|function|sddr09_send_command
id|sddr09_send_command
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
id|request
comma
r_int
r_char
id|direction
comma
r_int
r_char
op_star
id|xfer_data
comma
r_int
r_int
id|xfer_len
)paren
(brace
r_int
r_int
id|pipe
suffix:semicolon
r_int
r_char
id|requesttype
op_assign
(paren
l_int|0x41
op_or
id|direction
)paren
suffix:semicolon
r_int
id|rc
suffix:semicolon
singleline_comment|// Get the receive or send control pipe number
r_if
c_cond
(paren
id|direction
op_eq
id|USB_DIR_IN
)paren
id|pipe
op_assign
id|us-&gt;recv_ctrl_pipe
suffix:semicolon
r_else
id|pipe
op_assign
id|us-&gt;send_ctrl_pipe
suffix:semicolon
id|rc
op_assign
id|usb_stor_ctrl_transfer
c_func
(paren
id|us
comma
id|pipe
comma
id|request
comma
id|requesttype
comma
l_int|0
comma
l_int|0
comma
id|xfer_data
comma
id|xfer_len
)paren
suffix:semicolon
r_return
(paren
id|rc
op_eq
id|USB_STOR_XFER_GOOD
ques
c_cond
id|USB_STOR_TRANSPORT_GOOD
suffix:colon
id|USB_STOR_TRANSPORT_ERROR
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|sddr09_send_scsi_command
id|sddr09_send_scsi_command
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|command
comma
r_int
r_int
id|command_len
)paren
(brace
r_return
id|sddr09_send_command
c_func
(paren
id|us
comma
l_int|0
comma
id|USB_DIR_OUT
comma
id|command
comma
id|command_len
)paren
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/*&n; * Test Unit Ready Command: 12 bytes.&n; * byte 0: opcode: 00&n; */
r_static
r_int
id|sddr09_test_unit_ready
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
r_char
op_star
id|command
op_assign
id|us-&gt;iobuf
suffix:semicolon
r_int
id|result
suffix:semicolon
id|memset
c_func
(paren
id|command
comma
l_int|0
comma
l_int|6
)paren
suffix:semicolon
id|command
(braket
l_int|1
)braket
op_assign
id|LUNBITS
suffix:semicolon
id|result
op_assign
id|sddr09_send_scsi_command
c_func
(paren
id|us
comma
id|command
comma
l_int|6
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;sddr09_test_unit_ready returns %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Request Sense Command: 12 bytes.&n; * byte 0: opcode: 03&n; * byte 4: data length&n; */
r_static
r_int
DECL|function|sddr09_request_sense
id|sddr09_request_sense
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|sensebuf
comma
r_int
id|buflen
)paren
(brace
r_int
r_char
op_star
id|command
op_assign
id|us-&gt;iobuf
suffix:semicolon
r_int
id|result
suffix:semicolon
id|memset
c_func
(paren
id|command
comma
l_int|0
comma
l_int|12
)paren
suffix:semicolon
id|command
(braket
l_int|0
)braket
op_assign
l_int|0x03
suffix:semicolon
id|command
(braket
l_int|1
)braket
op_assign
id|LUNBITS
suffix:semicolon
id|command
(braket
l_int|4
)braket
op_assign
id|buflen
suffix:semicolon
id|result
op_assign
id|sddr09_send_scsi_command
c_func
(paren
id|us
comma
id|command
comma
l_int|12
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;request sense failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|result
op_assign
id|usb_stor_bulk_transfer_buf
c_func
(paren
id|us
comma
id|us-&gt;recv_bulk_pipe
comma
id|sensebuf
comma
id|buflen
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_XFER_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;request sense bulk in failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
r_else
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;request sense worked&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Read Command: 12 bytes.&n; * byte 0: opcode: E8&n; * byte 1: last two bits: 00: read data, 01: read blockwise control,&n; *&t;&t;&t;10: read both, 11: read pagewise control.&n; *&t; It turns out we need values 20, 21, 22, 23 here (LUN 1).&n; * bytes 2-5: address (interpretation depends on byte 1, see below)&n; * bytes 10-11: count (idem)&n; *&n; * A page has 512 data bytes and 64 control bytes (16 control and 48 junk).&n; * A read data command gets data in 512-byte pages.&n; * A read control command gets control in 64-byte chunks.&n; * A read both command gets data+control in 576-byte chunks.&n; *&n; * Blocks are groups of 32 pages, and read blockwise control jumps to the&n; * next block, while read pagewise control jumps to the next page after&n; * reading a group of 64 control bytes.&n; * [Here 512 = 1&lt;&lt;pageshift, 32 = 1&lt;&lt;blockshift, 64 is constant?]&n; *&n; * (1 MB and 2 MB cards are a bit different, but I have only a 16 MB card.)&n; */
r_static
r_int
DECL|function|sddr09_readX
id|sddr09_readX
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
id|x
comma
r_int
r_int
id|fromaddress
comma
r_int
id|nr_of_pages
comma
r_int
id|bulklen
comma
r_int
r_char
op_star
id|buf
comma
r_int
id|use_sg
)paren
(brace
r_int
r_char
op_star
id|command
op_assign
id|us-&gt;iobuf
suffix:semicolon
r_int
id|result
suffix:semicolon
id|command
(braket
l_int|0
)braket
op_assign
l_int|0xE8
suffix:semicolon
id|command
(braket
l_int|1
)braket
op_assign
id|LUNBITS
op_or
id|x
suffix:semicolon
id|command
(braket
l_int|2
)braket
op_assign
id|MSB_of
c_func
(paren
id|fromaddress
op_rshift
l_int|16
)paren
suffix:semicolon
id|command
(braket
l_int|3
)braket
op_assign
id|LSB_of
c_func
(paren
id|fromaddress
op_rshift
l_int|16
)paren
suffix:semicolon
id|command
(braket
l_int|4
)braket
op_assign
id|MSB_of
c_func
(paren
id|fromaddress
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
id|command
(braket
l_int|5
)braket
op_assign
id|LSB_of
c_func
(paren
id|fromaddress
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
id|command
(braket
l_int|6
)braket
op_assign
l_int|0
suffix:semicolon
id|command
(braket
l_int|7
)braket
op_assign
l_int|0
suffix:semicolon
id|command
(braket
l_int|8
)braket
op_assign
l_int|0
suffix:semicolon
id|command
(braket
l_int|9
)braket
op_assign
l_int|0
suffix:semicolon
id|command
(braket
l_int|10
)braket
op_assign
id|MSB_of
c_func
(paren
id|nr_of_pages
)paren
suffix:semicolon
id|command
(braket
l_int|11
)braket
op_assign
id|LSB_of
c_func
(paren
id|nr_of_pages
)paren
suffix:semicolon
id|result
op_assign
id|sddr09_send_scsi_command
c_func
(paren
id|us
comma
id|command
comma
l_int|12
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Result for send_control in sddr09_read2%d %d&bslash;n&quot;
comma
id|x
comma
id|result
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|result
op_assign
id|usb_stor_bulk_transfer_sg
c_func
(paren
id|us
comma
id|us-&gt;recv_bulk_pipe
comma
id|buf
comma
id|bulklen
comma
id|use_sg
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_XFER_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Result for bulk_transfer in sddr09_read2%d %d&bslash;n&quot;
comma
id|x
comma
id|result
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
multiline_comment|/*&n; * Read Data&n; *&n; * fromaddress counts data shorts:&n; * increasing it by 256 shifts the bytestream by 512 bytes;&n; * the last 8 bits are ignored.&n; *&n; * nr_of_pages counts pages of size (1 &lt;&lt; pageshift).&n; */
r_static
r_int
DECL|function|sddr09_read20
id|sddr09_read20
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|fromaddress
comma
r_int
id|nr_of_pages
comma
r_int
id|pageshift
comma
r_int
r_char
op_star
id|buf
comma
r_int
id|use_sg
)paren
(brace
r_int
id|bulklen
op_assign
id|nr_of_pages
op_lshift
id|pageshift
suffix:semicolon
multiline_comment|/* The last 8 bits of fromaddress are ignored. */
r_return
id|sddr09_readX
c_func
(paren
id|us
comma
l_int|0
comma
id|fromaddress
comma
id|nr_of_pages
comma
id|bulklen
comma
id|buf
comma
id|use_sg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Read Blockwise Control&n; *&n; * fromaddress gives the starting position (as in read data;&n; * the last 8 bits are ignored); increasing it by 32*256 shifts&n; * the output stream by 64 bytes.&n; *&n; * count counts control groups of size (1 &lt;&lt; controlshift).&n; * For me, controlshift = 6. Is this constant?&n; *&n; * After getting one control group, jump to the next block&n; * (fromaddress += 8192).&n; */
r_static
r_int
DECL|function|sddr09_read21
id|sddr09_read21
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|fromaddress
comma
r_int
id|count
comma
r_int
id|controlshift
comma
r_int
r_char
op_star
id|buf
comma
r_int
id|use_sg
)paren
(brace
r_int
id|bulklen
op_assign
(paren
id|count
op_lshift
id|controlshift
)paren
suffix:semicolon
r_return
id|sddr09_readX
c_func
(paren
id|us
comma
l_int|1
comma
id|fromaddress
comma
id|count
comma
id|bulklen
comma
id|buf
comma
id|use_sg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Read both Data and Control&n; *&n; * fromaddress counts data shorts, ignoring control:&n; * increasing it by 256 shifts the bytestream by 576 = 512+64 bytes;&n; * the last 8 bits are ignored.&n; *&n; * nr_of_pages counts pages of size (1 &lt;&lt; pageshift) + (1 &lt;&lt; controlshift).&n; */
r_static
r_int
DECL|function|sddr09_read22
id|sddr09_read22
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|fromaddress
comma
r_int
id|nr_of_pages
comma
r_int
id|pageshift
comma
r_int
r_char
op_star
id|buf
comma
r_int
id|use_sg
)paren
(brace
r_int
id|bulklen
op_assign
(paren
id|nr_of_pages
op_lshift
id|pageshift
)paren
op_plus
(paren
id|nr_of_pages
op_lshift
id|CONTROL_SHIFT
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;sddr09_read22: reading %d pages, %d bytes&bslash;n&quot;
comma
id|nr_of_pages
comma
id|bulklen
)paren
suffix:semicolon
r_return
id|sddr09_readX
c_func
(paren
id|us
comma
l_int|2
comma
id|fromaddress
comma
id|nr_of_pages
comma
id|bulklen
comma
id|buf
comma
id|use_sg
)paren
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/*&n; * Read Pagewise Control&n; *&n; * fromaddress gives the starting position (as in read data;&n; * the last 8 bits are ignored); increasing it by 256 shifts&n; * the output stream by 64 bytes.&n; *&n; * count counts control groups of size (1 &lt;&lt; controlshift).&n; * For me, controlshift = 6. Is this constant?&n; *&n; * After getting one control group, jump to the next page&n; * (fromaddress += 256).&n; */
r_static
r_int
id|sddr09_read23
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|fromaddress
comma
r_int
id|count
comma
r_int
id|controlshift
comma
r_int
r_char
op_star
id|buf
comma
r_int
id|use_sg
)paren
(brace
r_int
id|bulklen
op_assign
(paren
id|count
op_lshift
id|controlshift
)paren
suffix:semicolon
r_return
id|sddr09_readX
c_func
(paren
id|us
comma
l_int|3
comma
id|fromaddress
comma
id|count
comma
id|bulklen
comma
id|buf
comma
id|use_sg
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Erase Command: 12 bytes.&n; * byte 0: opcode: EA&n; * bytes 6-9: erase address (big-endian, counting shorts, sector aligned).&n; * &n; * Always precisely one block is erased; bytes 2-5 and 10-11 are ignored.&n; * The byte address being erased is 2*Eaddress.&n; * The CIS cannot be erased.&n; */
r_static
r_int
DECL|function|sddr09_erase
id|sddr09_erase
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|Eaddress
)paren
(brace
r_int
r_char
op_star
id|command
op_assign
id|us-&gt;iobuf
suffix:semicolon
r_int
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;sddr09_erase: erase address %lu&bslash;n&quot;
comma
id|Eaddress
)paren
suffix:semicolon
id|memset
c_func
(paren
id|command
comma
l_int|0
comma
l_int|12
)paren
suffix:semicolon
id|command
(braket
l_int|0
)braket
op_assign
l_int|0xEA
suffix:semicolon
id|command
(braket
l_int|1
)braket
op_assign
id|LUNBITS
suffix:semicolon
id|command
(braket
l_int|6
)braket
op_assign
id|MSB_of
c_func
(paren
id|Eaddress
op_rshift
l_int|16
)paren
suffix:semicolon
id|command
(braket
l_int|7
)braket
op_assign
id|LSB_of
c_func
(paren
id|Eaddress
op_rshift
l_int|16
)paren
suffix:semicolon
id|command
(braket
l_int|8
)braket
op_assign
id|MSB_of
c_func
(paren
id|Eaddress
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
id|command
(braket
l_int|9
)braket
op_assign
id|LSB_of
c_func
(paren
id|Eaddress
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
id|result
op_assign
id|sddr09_send_scsi_command
c_func
(paren
id|us
comma
id|command
comma
l_int|12
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;Result for send_control in sddr09_erase %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Write CIS Command: 12 bytes.&n; * byte 0: opcode: EE&n; * bytes 2-5: write address in shorts&n; * bytes 10-11: sector count&n; *&n; * This writes at the indicated address. Don&squot;t know how it differs&n; * from E9. Maybe it does not erase? However, it will also write to&n; * the CIS.&n; *&n; * When two such commands on the same page follow each other directly,&n; * the second one is not done.&n; */
multiline_comment|/*&n; * Write Command: 12 bytes.&n; * byte 0: opcode: E9&n; * bytes 2-5: write address (big-endian, counting shorts, sector aligned).&n; * bytes 6-9: erase address (big-endian, counting shorts, sector aligned).&n; * bytes 10-11: sector count (big-endian, in 512-byte sectors).&n; *&n; * If write address equals erase address, the erase is done first,&n; * otherwise the write is done first. When erase address equals zero&n; * no erase is done?&n; */
r_static
r_int
DECL|function|sddr09_writeX
id|sddr09_writeX
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|Waddress
comma
r_int
r_int
id|Eaddress
comma
r_int
id|nr_of_pages
comma
r_int
id|bulklen
comma
r_int
r_char
op_star
id|buf
comma
r_int
id|use_sg
)paren
(brace
r_int
r_char
op_star
id|command
op_assign
id|us-&gt;iobuf
suffix:semicolon
r_int
id|result
suffix:semicolon
id|command
(braket
l_int|0
)braket
op_assign
l_int|0xE9
suffix:semicolon
id|command
(braket
l_int|1
)braket
op_assign
id|LUNBITS
suffix:semicolon
id|command
(braket
l_int|2
)braket
op_assign
id|MSB_of
c_func
(paren
id|Waddress
op_rshift
l_int|16
)paren
suffix:semicolon
id|command
(braket
l_int|3
)braket
op_assign
id|LSB_of
c_func
(paren
id|Waddress
op_rshift
l_int|16
)paren
suffix:semicolon
id|command
(braket
l_int|4
)braket
op_assign
id|MSB_of
c_func
(paren
id|Waddress
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
id|command
(braket
l_int|5
)braket
op_assign
id|LSB_of
c_func
(paren
id|Waddress
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
id|command
(braket
l_int|6
)braket
op_assign
id|MSB_of
c_func
(paren
id|Eaddress
op_rshift
l_int|16
)paren
suffix:semicolon
id|command
(braket
l_int|7
)braket
op_assign
id|LSB_of
c_func
(paren
id|Eaddress
op_rshift
l_int|16
)paren
suffix:semicolon
id|command
(braket
l_int|8
)braket
op_assign
id|MSB_of
c_func
(paren
id|Eaddress
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
id|command
(braket
l_int|9
)braket
op_assign
id|LSB_of
c_func
(paren
id|Eaddress
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
id|command
(braket
l_int|10
)braket
op_assign
id|MSB_of
c_func
(paren
id|nr_of_pages
)paren
suffix:semicolon
id|command
(braket
l_int|11
)braket
op_assign
id|LSB_of
c_func
(paren
id|nr_of_pages
)paren
suffix:semicolon
id|result
op_assign
id|sddr09_send_scsi_command
c_func
(paren
id|us
comma
id|command
comma
l_int|12
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Result for send_control in sddr09_writeX %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|result
op_assign
id|usb_stor_bulk_transfer_sg
c_func
(paren
id|us
comma
id|us-&gt;send_bulk_pipe
comma
id|buf
comma
id|bulklen
comma
id|use_sg
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_XFER_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Result for bulk_transfer in sddr09_writeX %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
multiline_comment|/* erase address, write same address */
r_static
r_int
DECL|function|sddr09_write_inplace
id|sddr09_write_inplace
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|address
comma
r_int
id|nr_of_pages
comma
r_int
id|pageshift
comma
r_int
r_char
op_star
id|buf
comma
r_int
id|use_sg
)paren
(brace
r_int
id|bulklen
op_assign
(paren
id|nr_of_pages
op_lshift
id|pageshift
)paren
op_plus
(paren
id|nr_of_pages
op_lshift
id|CONTROL_SHIFT
)paren
suffix:semicolon
r_return
id|sddr09_writeX
c_func
(paren
id|us
comma
id|address
comma
id|address
comma
id|nr_of_pages
comma
id|bulklen
comma
id|buf
comma
id|use_sg
)paren
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/*&n; * Read Scatter Gather Command: 3+4n bytes.&n; * byte 0: opcode E7&n; * byte 2: n&n; * bytes 4i-1,4i,4i+1: page address&n; * byte 4i+2: page count&n; * (i=1..n)&n; *&n; * This reads several pages from the card to a single memory buffer.&n; * The last two bits of byte 1 have the same meaning as for E8.&n; */
r_static
r_int
id|sddr09_read_sg_test_only
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
r_char
op_star
id|command
op_assign
id|us-&gt;iobuf
suffix:semicolon
r_int
id|result
comma
id|bulklen
comma
id|nsg
comma
id|ct
suffix:semicolon
r_int
r_char
op_star
id|buf
suffix:semicolon
r_int
r_int
id|address
suffix:semicolon
id|nsg
op_assign
id|bulklen
op_assign
l_int|0
suffix:semicolon
id|command
(braket
l_int|0
)braket
op_assign
l_int|0xE7
suffix:semicolon
id|command
(braket
l_int|1
)braket
op_assign
id|LUNBITS
suffix:semicolon
id|command
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|address
op_assign
l_int|040000
suffix:semicolon
id|ct
op_assign
l_int|1
suffix:semicolon
id|nsg
op_increment
suffix:semicolon
id|bulklen
op_add_assign
(paren
id|ct
op_lshift
l_int|9
)paren
suffix:semicolon
id|command
(braket
l_int|4
op_star
id|nsg
op_plus
l_int|2
)braket
op_assign
id|ct
suffix:semicolon
id|command
(braket
l_int|4
op_star
id|nsg
op_plus
l_int|1
)braket
op_assign
(paren
(paren
id|address
op_rshift
l_int|9
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|command
(braket
l_int|4
op_star
id|nsg
op_plus
l_int|0
)braket
op_assign
(paren
(paren
id|address
op_rshift
l_int|17
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|command
(braket
l_int|4
op_star
id|nsg
op_minus
l_int|1
)braket
op_assign
(paren
(paren
id|address
op_rshift
l_int|25
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|address
op_assign
l_int|0340000
suffix:semicolon
id|ct
op_assign
l_int|1
suffix:semicolon
id|nsg
op_increment
suffix:semicolon
id|bulklen
op_add_assign
(paren
id|ct
op_lshift
l_int|9
)paren
suffix:semicolon
id|command
(braket
l_int|4
op_star
id|nsg
op_plus
l_int|2
)braket
op_assign
id|ct
suffix:semicolon
id|command
(braket
l_int|4
op_star
id|nsg
op_plus
l_int|1
)braket
op_assign
(paren
(paren
id|address
op_rshift
l_int|9
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|command
(braket
l_int|4
op_star
id|nsg
op_plus
l_int|0
)braket
op_assign
(paren
(paren
id|address
op_rshift
l_int|17
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|command
(braket
l_int|4
op_star
id|nsg
op_minus
l_int|1
)braket
op_assign
(paren
(paren
id|address
op_rshift
l_int|25
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|address
op_assign
l_int|01000000
suffix:semicolon
id|ct
op_assign
l_int|2
suffix:semicolon
id|nsg
op_increment
suffix:semicolon
id|bulklen
op_add_assign
(paren
id|ct
op_lshift
l_int|9
)paren
suffix:semicolon
id|command
(braket
l_int|4
op_star
id|nsg
op_plus
l_int|2
)braket
op_assign
id|ct
suffix:semicolon
id|command
(braket
l_int|4
op_star
id|nsg
op_plus
l_int|1
)braket
op_assign
(paren
(paren
id|address
op_rshift
l_int|9
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|command
(braket
l_int|4
op_star
id|nsg
op_plus
l_int|0
)braket
op_assign
(paren
(paren
id|address
op_rshift
l_int|17
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|command
(braket
l_int|4
op_star
id|nsg
op_minus
l_int|1
)braket
op_assign
(paren
(paren
id|address
op_rshift
l_int|25
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|command
(braket
l_int|2
)braket
op_assign
id|nsg
suffix:semicolon
id|result
op_assign
id|sddr09_send_scsi_command
c_func
(paren
id|us
comma
id|command
comma
l_int|4
op_star
id|nsg
op_plus
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Result for send_control in sddr09_read_sg %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|buf
op_assign
(paren
r_int
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|bulklen
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|result
op_assign
id|usb_stor_bulk_transfer_buf
c_func
(paren
id|us
comma
id|us-&gt;recv_bulk_pipe
comma
id|buf
comma
id|bulklen
comma
l_int|NULL
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_XFER_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Result for bulk_transfer in sddr09_read_sg %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Read Status Command: 12 bytes.&n; * byte 0: opcode: EC&n; *&n; * Returns 64 bytes, all zero except for the first.&n; * bit 0: 1: Error&n; * bit 5: 1: Suspended&n; * bit 6: 1: Ready&n; * bit 7: 1: Not write-protected&n; */
r_static
r_int
DECL|function|sddr09_read_status
id|sddr09_read_status
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|status
)paren
(brace
r_int
r_char
op_star
id|command
op_assign
id|us-&gt;iobuf
suffix:semicolon
r_int
r_char
op_star
id|data
op_assign
id|us-&gt;iobuf
suffix:semicolon
r_int
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Reading status...&bslash;n&quot;
)paren
suffix:semicolon
id|memset
c_func
(paren
id|command
comma
l_int|0
comma
l_int|12
)paren
suffix:semicolon
id|command
(braket
l_int|0
)braket
op_assign
l_int|0xEC
suffix:semicolon
id|command
(braket
l_int|1
)braket
op_assign
id|LUNBITS
suffix:semicolon
id|result
op_assign
id|sddr09_send_scsi_command
c_func
(paren
id|us
comma
id|command
comma
l_int|12
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
id|result
op_assign
id|usb_stor_bulk_transfer_buf
c_func
(paren
id|us
comma
id|us-&gt;recv_bulk_pipe
comma
id|data
comma
l_int|64
comma
l_int|NULL
)paren
suffix:semicolon
op_star
id|status
op_assign
id|data
(braket
l_int|0
)braket
suffix:semicolon
r_return
(paren
id|result
op_eq
id|USB_STOR_XFER_GOOD
ques
c_cond
id|USB_STOR_TRANSPORT_GOOD
suffix:colon
id|USB_STOR_TRANSPORT_ERROR
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|sddr09_read_data
id|sddr09_read_data
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|address
comma
r_int
r_int
id|sectors
)paren
(brace
r_struct
id|sddr09_card_info
op_star
id|info
op_assign
(paren
r_struct
id|sddr09_card_info
op_star
)paren
id|us-&gt;extra
suffix:semicolon
r_int
r_char
op_star
id|buffer
suffix:semicolon
r_int
r_int
id|lba
comma
id|maxlba
comma
id|pba
suffix:semicolon
r_int
r_int
id|page
comma
id|pages
suffix:semicolon
r_int
r_int
id|len
comma
id|index
comma
id|offset
suffix:semicolon
r_int
id|result
suffix:semicolon
singleline_comment|// Since we only read in one block at a time, we have to create
singleline_comment|// a bounce buffer and move the data a piece at a time between the
singleline_comment|// bounce buffer and the actual transfer buffer.
id|len
op_assign
id|min
c_func
(paren
id|sectors
comma
(paren
r_int
r_int
)paren
id|info-&gt;blocksize
)paren
op_star
id|info-&gt;pagesize
suffix:semicolon
id|buffer
op_assign
id|kmalloc
c_func
(paren
id|len
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sddr09_read_data: Out of memory&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
singleline_comment|// Figure out the initial LBA and page
id|lba
op_assign
id|address
op_rshift
id|info-&gt;blockshift
suffix:semicolon
id|page
op_assign
(paren
id|address
op_amp
id|info-&gt;blockmask
)paren
suffix:semicolon
id|maxlba
op_assign
id|info-&gt;capacity
op_rshift
(paren
id|info-&gt;pageshift
op_plus
id|info-&gt;blockshift
)paren
suffix:semicolon
singleline_comment|// This could be made much more efficient by checking for
singleline_comment|// contiguous LBA&squot;s. Another exercise left to the student.
id|result
op_assign
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
id|index
op_assign
id|offset
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|sectors
OG
l_int|0
)paren
(brace
multiline_comment|/* Find number of pages we can read in this block */
id|pages
op_assign
id|min
c_func
(paren
id|sectors
comma
id|info-&gt;blocksize
op_minus
id|page
)paren
suffix:semicolon
id|len
op_assign
id|pages
op_lshift
id|info-&gt;pageshift
suffix:semicolon
multiline_comment|/* Not overflowing capacity? */
r_if
c_cond
(paren
id|lba
op_ge
id|maxlba
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Error: Requested lba %u exceeds &quot;
l_string|&quot;maximum %u&bslash;n&quot;
comma
id|lba
comma
id|maxlba
)paren
suffix:semicolon
id|result
op_assign
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Find where this lba lives on disk */
id|pba
op_assign
id|info-&gt;lba_to_pba
(braket
id|lba
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pba
op_eq
id|UNDEF
)paren
(brace
multiline_comment|/* this lba was never written */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Read %d zero pages (LBA %d) page %d&bslash;n&quot;
comma
id|pages
comma
id|lba
comma
id|page
)paren
suffix:semicolon
multiline_comment|/* This is not really an error. It just means&n;&t;&t;&t;   that the block has never been written.&n;&t;&t;&t;   Instead of returning USB_STOR_TRANSPORT_ERROR&n;&t;&t;&t;   it is better to return all zero data. */
id|memset
c_func
(paren
id|buffer
comma
l_int|0
comma
id|len
)paren
suffix:semicolon
)brace
r_else
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Read %d pages, from PBA %d&quot;
l_string|&quot; (LBA %d) page %d&bslash;n&quot;
comma
id|pages
comma
id|pba
comma
id|lba
comma
id|page
)paren
suffix:semicolon
id|address
op_assign
(paren
(paren
id|pba
op_lshift
id|info-&gt;blockshift
)paren
op_plus
id|page
)paren
op_lshift
id|info-&gt;pageshift
suffix:semicolon
id|result
op_assign
id|sddr09_read20
c_func
(paren
id|us
comma
id|address
op_rshift
l_int|1
comma
id|pages
comma
id|info-&gt;pageshift
comma
id|buffer
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_break
suffix:semicolon
)brace
singleline_comment|// Store the data in the transfer buffer
id|usb_stor_access_xfer_buf
c_func
(paren
id|buffer
comma
id|len
comma
id|us-&gt;srb
comma
op_amp
id|index
comma
op_amp
id|offset
comma
id|TO_XFER_BUF
)paren
suffix:semicolon
id|page
op_assign
l_int|0
suffix:semicolon
id|lba
op_increment
suffix:semicolon
id|sectors
op_sub_assign
id|pages
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_static
r_int
r_int
DECL|function|sddr09_find_unused_pba
id|sddr09_find_unused_pba
c_func
(paren
r_struct
id|sddr09_card_info
op_star
id|info
comma
r_int
r_int
id|lba
)paren
(brace
r_static
r_int
r_int
id|lastpba
op_assign
l_int|1
suffix:semicolon
r_int
id|zonestart
comma
id|end
comma
id|i
suffix:semicolon
id|zonestart
op_assign
(paren
id|lba
op_div
l_int|1000
)paren
op_lshift
l_int|10
suffix:semicolon
id|end
op_assign
id|info-&gt;capacity
op_rshift
(paren
id|info-&gt;blockshift
op_plus
id|info-&gt;pageshift
)paren
suffix:semicolon
id|end
op_sub_assign
id|zonestart
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
l_int|1024
)paren
id|end
op_assign
l_int|1024
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|lastpba
op_plus
l_int|1
suffix:semicolon
id|i
OL
id|end
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;pba_to_lba
(braket
id|zonestart
op_plus
id|i
)braket
op_eq
id|UNDEF
)paren
(brace
id|lastpba
op_assign
id|i
suffix:semicolon
r_return
id|zonestart
op_plus
id|i
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|lastpba
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;pba_to_lba
(braket
id|zonestart
op_plus
id|i
)braket
op_eq
id|UNDEF
)paren
(brace
id|lastpba
op_assign
id|i
suffix:semicolon
r_return
id|zonestart
op_plus
id|i
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|sddr09_write_lba
id|sddr09_write_lba
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|lba
comma
r_int
r_int
id|page
comma
r_int
r_int
id|pages
comma
r_int
r_char
op_star
id|ptr
comma
r_int
r_char
op_star
id|blockbuffer
)paren
(brace
r_struct
id|sddr09_card_info
op_star
id|info
op_assign
(paren
r_struct
id|sddr09_card_info
op_star
)paren
id|us-&gt;extra
suffix:semicolon
r_int
r_int
id|address
suffix:semicolon
r_int
r_int
id|pba
comma
id|lbap
suffix:semicolon
r_int
r_int
id|pagelen
suffix:semicolon
r_int
r_char
op_star
id|bptr
comma
op_star
id|cptr
comma
op_star
id|xptr
suffix:semicolon
r_int
r_char
id|ecc
(braket
l_int|3
)braket
suffix:semicolon
r_int
id|i
comma
id|result
comma
id|isnew
suffix:semicolon
id|lbap
op_assign
(paren
(paren
id|lba
op_mod
l_int|1000
)paren
op_lshift
l_int|1
)paren
op_or
l_int|0x1000
suffix:semicolon
r_if
c_cond
(paren
id|parity
(braket
id|MSB_of
c_func
(paren
id|lbap
)paren
op_xor
id|LSB_of
c_func
(paren
id|lbap
)paren
)braket
)paren
id|lbap
op_xor_assign
l_int|1
suffix:semicolon
id|pba
op_assign
id|info-&gt;lba_to_pba
(braket
id|lba
)braket
suffix:semicolon
id|isnew
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pba
op_eq
id|UNDEF
)paren
(brace
id|pba
op_assign
id|sddr09_find_unused_pba
c_func
(paren
id|info
comma
id|lba
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pba
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sddr09_write_lba: Out of unused blocks&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
id|info-&gt;pba_to_lba
(braket
id|pba
)braket
op_assign
id|lba
suffix:semicolon
id|info-&gt;lba_to_pba
(braket
id|lba
)braket
op_assign
id|pba
suffix:semicolon
id|isnew
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pba
op_eq
l_int|1
)paren
(brace
multiline_comment|/* Maybe it is impossible to write to PBA 1.&n;&t;&t;   Fake success, but don&squot;t do anything. */
id|printk
c_func
(paren
l_string|&quot;sddr09: avoid writing to pba 1&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
id|pagelen
op_assign
(paren
l_int|1
op_lshift
id|info-&gt;pageshift
)paren
op_plus
(paren
l_int|1
op_lshift
id|CONTROL_SHIFT
)paren
suffix:semicolon
multiline_comment|/* read old contents */
id|address
op_assign
(paren
id|pba
op_lshift
(paren
id|info-&gt;pageshift
op_plus
id|info-&gt;blockshift
)paren
)paren
suffix:semicolon
id|result
op_assign
id|sddr09_read22
c_func
(paren
id|us
comma
id|address
op_rshift
l_int|1
comma
id|info-&gt;blocksize
comma
id|info-&gt;pageshift
comma
id|blockbuffer
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
multiline_comment|/* check old contents and fill lba */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|info-&gt;blocksize
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bptr
op_assign
id|blockbuffer
op_plus
id|i
op_star
id|pagelen
suffix:semicolon
id|cptr
op_assign
id|bptr
op_plus
id|info-&gt;pagesize
suffix:semicolon
id|nand_compute_ecc
c_func
(paren
id|bptr
comma
id|ecc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nand_compare_ecc
c_func
(paren
id|cptr
op_plus
l_int|13
comma
id|ecc
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Warning: bad ecc in page %d- of pba %d&bslash;n&quot;
comma
id|i
comma
id|pba
)paren
suffix:semicolon
id|nand_store_ecc
c_func
(paren
id|cptr
op_plus
l_int|13
comma
id|ecc
)paren
suffix:semicolon
)brace
id|nand_compute_ecc
c_func
(paren
id|bptr
op_plus
(paren
id|info-&gt;pagesize
op_div
l_int|2
)paren
comma
id|ecc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nand_compare_ecc
c_func
(paren
id|cptr
op_plus
l_int|8
comma
id|ecc
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Warning: bad ecc in page %d+ of pba %d&bslash;n&quot;
comma
id|i
comma
id|pba
)paren
suffix:semicolon
id|nand_store_ecc
c_func
(paren
id|cptr
op_plus
l_int|8
comma
id|ecc
)paren
suffix:semicolon
)brace
id|cptr
(braket
l_int|6
)braket
op_assign
id|cptr
(braket
l_int|11
)braket
op_assign
id|MSB_of
c_func
(paren
id|lbap
)paren
suffix:semicolon
id|cptr
(braket
l_int|7
)braket
op_assign
id|cptr
(braket
l_int|12
)braket
op_assign
id|LSB_of
c_func
(paren
id|lbap
)paren
suffix:semicolon
)brace
multiline_comment|/* copy in new stuff and compute ECC */
id|xptr
op_assign
id|ptr
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|page
suffix:semicolon
id|i
OL
id|page
op_plus
id|pages
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bptr
op_assign
id|blockbuffer
op_plus
id|i
op_star
id|pagelen
suffix:semicolon
id|cptr
op_assign
id|bptr
op_plus
id|info-&gt;pagesize
suffix:semicolon
id|memcpy
c_func
(paren
id|bptr
comma
id|xptr
comma
id|info-&gt;pagesize
)paren
suffix:semicolon
id|xptr
op_add_assign
id|info-&gt;pagesize
suffix:semicolon
id|nand_compute_ecc
c_func
(paren
id|bptr
comma
id|ecc
)paren
suffix:semicolon
id|nand_store_ecc
c_func
(paren
id|cptr
op_plus
l_int|13
comma
id|ecc
)paren
suffix:semicolon
id|nand_compute_ecc
c_func
(paren
id|bptr
op_plus
(paren
id|info-&gt;pagesize
op_div
l_int|2
)paren
comma
id|ecc
)paren
suffix:semicolon
id|nand_store_ecc
c_func
(paren
id|cptr
op_plus
l_int|8
comma
id|ecc
)paren
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Rewrite PBA %d (LBA %d)&bslash;n&quot;
comma
id|pba
comma
id|lba
)paren
suffix:semicolon
id|result
op_assign
id|sddr09_write_inplace
c_func
(paren
id|us
comma
id|address
op_rshift
l_int|1
comma
id|info-&gt;blocksize
comma
id|info-&gt;pageshift
comma
id|blockbuffer
comma
l_int|0
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;sddr09_write_inplace returns %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
macro_line|#if 0
(brace
r_int
r_char
id|status
op_assign
l_int|0
suffix:semicolon
r_int
id|result2
op_assign
id|sddr09_read_status
c_func
(paren
id|us
comma
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result2
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;sddr09_write_inplace: cannot read status&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|status
op_ne
l_int|0xc0
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;sddr09_write_inplace: status after write: 0x%x&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if 0
(brace
r_int
id|result2
op_assign
id|sddr09_test_unit_ready
c_func
(paren
id|us
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
id|result
suffix:semicolon
)brace
r_static
r_int
DECL|function|sddr09_write_data
id|sddr09_write_data
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|address
comma
r_int
r_int
id|sectors
)paren
(brace
r_struct
id|sddr09_card_info
op_star
id|info
op_assign
(paren
r_struct
id|sddr09_card_info
op_star
)paren
id|us-&gt;extra
suffix:semicolon
r_int
r_int
id|lba
comma
id|page
comma
id|pages
suffix:semicolon
r_int
r_int
id|pagelen
comma
id|blocklen
suffix:semicolon
r_int
r_char
op_star
id|blockbuffer
suffix:semicolon
r_int
r_char
op_star
id|buffer
suffix:semicolon
r_int
r_int
id|len
comma
id|index
comma
id|offset
suffix:semicolon
r_int
id|result
suffix:semicolon
singleline_comment|// blockbuffer is used for reading in the old data, overwriting
singleline_comment|// with the new data, and performing ECC calculations
multiline_comment|/* TODO: instead of doing kmalloc/kfree for each write,&n;&t;   add a bufferpointer to the info structure */
id|pagelen
op_assign
(paren
l_int|1
op_lshift
id|info-&gt;pageshift
)paren
op_plus
(paren
l_int|1
op_lshift
id|CONTROL_SHIFT
)paren
suffix:semicolon
id|blocklen
op_assign
(paren
id|pagelen
op_lshift
id|info-&gt;blockshift
)paren
suffix:semicolon
id|blockbuffer
op_assign
id|kmalloc
c_func
(paren
id|blocklen
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|blockbuffer
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sddr09_write_data: Out of memory&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
singleline_comment|// Since we don&squot;t write the user data directly to the device,
singleline_comment|// we have to create a bounce buffer and move the data a piece
singleline_comment|// at a time between the bounce buffer and the actual transfer buffer.
id|len
op_assign
id|min
c_func
(paren
id|sectors
comma
(paren
r_int
r_int
)paren
id|info-&gt;blocksize
)paren
op_star
id|info-&gt;pagesize
suffix:semicolon
id|buffer
op_assign
id|kmalloc
c_func
(paren
id|len
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sddr09_write_data: Out of memory&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|blockbuffer
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
singleline_comment|// Figure out the initial LBA and page
id|lba
op_assign
id|address
op_rshift
id|info-&gt;blockshift
suffix:semicolon
id|page
op_assign
(paren
id|address
op_amp
id|info-&gt;blockmask
)paren
suffix:semicolon
id|result
op_assign
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
id|index
op_assign
id|offset
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|sectors
OG
l_int|0
)paren
(brace
singleline_comment|// Write as many sectors as possible in this block
id|pages
op_assign
id|min
c_func
(paren
id|sectors
comma
id|info-&gt;blocksize
op_minus
id|page
)paren
suffix:semicolon
id|len
op_assign
(paren
id|pages
op_lshift
id|info-&gt;pageshift
)paren
suffix:semicolon
singleline_comment|// Get the data from the transfer buffer
id|usb_stor_access_xfer_buf
c_func
(paren
id|buffer
comma
id|len
comma
id|us-&gt;srb
comma
op_amp
id|index
comma
op_amp
id|offset
comma
id|FROM_XFER_BUF
)paren
suffix:semicolon
id|result
op_assign
id|sddr09_write_lba
c_func
(paren
id|us
comma
id|lba
comma
id|page
comma
id|pages
comma
id|buffer
comma
id|blockbuffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_break
suffix:semicolon
id|page
op_assign
l_int|0
suffix:semicolon
id|lba
op_increment
suffix:semicolon
id|sectors
op_sub_assign
id|pages
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|blockbuffer
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_static
r_int
DECL|function|sddr09_read_control
id|sddr09_read_control
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|address
comma
r_int
r_int
id|blocks
comma
r_int
r_char
op_star
id|content
comma
r_int
id|use_sg
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Read control address %lu, blocks %d&bslash;n&quot;
comma
id|address
comma
id|blocks
)paren
suffix:semicolon
r_return
id|sddr09_read21
c_func
(paren
id|us
comma
id|address
comma
id|blocks
comma
id|CONTROL_SHIFT
comma
id|content
comma
id|use_sg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Read Device ID Command: 12 bytes.&n; * byte 0: opcode: ED&n; *&n; * Returns 2 bytes: Manufacturer ID and Device ID.&n; * On more recent cards 3 bytes: the third byte is an option code A5&n; * signifying that the secret command to read an 128-bit ID is available.&n; * On still more recent cards 4 bytes: the fourth byte C0 means that&n; * a second read ID cmd is available.&n; */
r_static
r_int
DECL|function|sddr09_read_deviceID
id|sddr09_read_deviceID
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|deviceID
)paren
(brace
r_int
r_char
op_star
id|command
op_assign
id|us-&gt;iobuf
suffix:semicolon
r_int
r_char
op_star
id|content
op_assign
id|us-&gt;iobuf
suffix:semicolon
r_int
id|result
comma
id|i
suffix:semicolon
id|memset
c_func
(paren
id|command
comma
l_int|0
comma
l_int|12
)paren
suffix:semicolon
id|command
(braket
l_int|0
)braket
op_assign
l_int|0xED
suffix:semicolon
id|command
(braket
l_int|1
)braket
op_assign
id|LUNBITS
suffix:semicolon
id|result
op_assign
id|sddr09_send_scsi_command
c_func
(paren
id|us
comma
id|command
comma
l_int|12
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
id|result
op_assign
id|usb_stor_bulk_transfer_buf
c_func
(paren
id|us
comma
id|us-&gt;recv_bulk_pipe
comma
id|content
comma
l_int|64
comma
l_int|NULL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
id|deviceID
(braket
id|i
)braket
op_assign
id|content
(braket
id|i
)braket
suffix:semicolon
r_return
(paren
id|result
op_eq
id|USB_STOR_XFER_GOOD
ques
c_cond
id|USB_STOR_TRANSPORT_GOOD
suffix:colon
id|USB_STOR_TRANSPORT_ERROR
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|sddr09_get_wp
id|sddr09_get_wp
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_struct
id|sddr09_card_info
op_star
id|info
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
id|result
op_assign
id|sddr09_read_status
c_func
(paren
id|us
comma
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;sddr09_get_wp: read_status fails&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;sddr09_get_wp: status 0x%02X&quot;
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
l_int|0x80
)paren
op_eq
l_int|0
)paren
(brace
id|info-&gt;flags
op_or_assign
id|SDDR09_WP
suffix:semicolon
multiline_comment|/* write protected */
id|US_DEBUGP
c_func
(paren
l_string|&quot; WP&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
l_int|0x40
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot; Ready&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|LUNBITS
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot; Suspended&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x1
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot; Error&quot;
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/*&n; * Reset Command: 12 bytes.&n; * byte 0: opcode: EB&n; */
r_static
r_int
id|sddr09_reset
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
r_char
op_star
id|command
op_assign
id|us-&gt;iobuf
suffix:semicolon
id|memset
c_func
(paren
id|command
comma
l_int|0
comma
l_int|12
)paren
suffix:semicolon
id|command
(braket
l_int|0
)braket
op_assign
l_int|0xEB
suffix:semicolon
id|command
(braket
l_int|1
)braket
op_assign
id|LUNBITS
suffix:semicolon
r_return
id|sddr09_send_scsi_command
c_func
(paren
id|us
comma
id|command
comma
l_int|12
)paren
suffix:semicolon
)brace
macro_line|#endif
r_static
r_struct
id|nand_flash_dev
op_star
DECL|function|sddr09_get_cardinfo
id|sddr09_get_cardinfo
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
id|flags
)paren
(brace
r_struct
id|nand_flash_dev
op_star
id|cardinfo
suffix:semicolon
r_int
r_char
id|deviceID
(braket
l_int|4
)braket
suffix:semicolon
r_char
id|blurbtxt
(braket
l_int|256
)braket
suffix:semicolon
r_int
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Reading capacity...&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|sddr09_read_deviceID
c_func
(paren
id|us
comma
id|deviceID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Result of read_deviceID is %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sddr09: could not read card info&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|blurbtxt
comma
l_string|&quot;sddr09: Found Flash card, ID = %02X %02X %02X %02X&quot;
comma
id|deviceID
(braket
l_int|0
)braket
comma
id|deviceID
(braket
l_int|1
)braket
comma
id|deviceID
(braket
l_int|2
)braket
comma
id|deviceID
(braket
l_int|3
)braket
)paren
suffix:semicolon
multiline_comment|/* Byte 0 is the manufacturer */
id|sprintf
c_func
(paren
id|blurbtxt
op_plus
id|strlen
c_func
(paren
id|blurbtxt
)paren
comma
l_string|&quot;: Manuf. %s&quot;
comma
id|nand_flash_manufacturer
c_func
(paren
id|deviceID
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
multiline_comment|/* Byte 1 is the device type */
id|cardinfo
op_assign
id|nand_find_id
c_func
(paren
id|deviceID
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cardinfo
)paren
(brace
multiline_comment|/* MB or MiB? It is neither. A 16 MB card has&n;&t;&t;   17301504 raw bytes, of which 16384000 are&n;&t;&t;   usable for user data. */
id|sprintf
c_func
(paren
id|blurbtxt
op_plus
id|strlen
c_func
(paren
id|blurbtxt
)paren
comma
l_string|&quot;, %d MB&quot;
comma
l_int|1
op_lshift
(paren
id|cardinfo-&gt;chipshift
op_minus
l_int|20
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|sprintf
c_func
(paren
id|blurbtxt
op_plus
id|strlen
c_func
(paren
id|blurbtxt
)paren
comma
l_string|&quot;, type unrecognized&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Byte 2 is code to signal availability of 128-bit ID */
r_if
c_cond
(paren
id|deviceID
(braket
l_int|2
)braket
op_eq
l_int|0xa5
)paren
(brace
id|sprintf
c_func
(paren
id|blurbtxt
op_plus
id|strlen
c_func
(paren
id|blurbtxt
)paren
comma
l_string|&quot;, 128-bit ID&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Byte 3 announces the availability of another read ID command */
r_if
c_cond
(paren
id|deviceID
(braket
l_int|3
)braket
op_eq
l_int|0xc0
)paren
(brace
id|sprintf
c_func
(paren
id|blurbtxt
op_plus
id|strlen
c_func
(paren
id|blurbtxt
)paren
comma
l_string|&quot;, extra cmd&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|SDDR09_WP
)paren
id|sprintf
c_func
(paren
id|blurbtxt
op_plus
id|strlen
c_func
(paren
id|blurbtxt
)paren
comma
l_string|&quot;, WP&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|blurbtxt
)paren
suffix:semicolon
r_return
id|cardinfo
suffix:semicolon
)brace
r_static
r_int
DECL|function|sddr09_read_map
id|sddr09_read_map
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_struct
id|sddr09_card_info
op_star
id|info
op_assign
(paren
r_struct
id|sddr09_card_info
op_star
)paren
id|us-&gt;extra
suffix:semicolon
r_int
id|numblocks
comma
id|alloc_len
comma
id|alloc_blocks
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|result
suffix:semicolon
r_int
r_char
op_star
id|buffer
comma
op_star
id|buffer_end
comma
op_star
id|ptr
suffix:semicolon
r_int
r_int
id|lba
comma
id|lbact
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;capacity
)paren
r_return
op_minus
l_int|1
suffix:semicolon
singleline_comment|// size of a block is 1 &lt;&lt; (blockshift + pageshift) bytes
singleline_comment|// divide into the total capacity to get the number of blocks
id|numblocks
op_assign
id|info-&gt;capacity
op_rshift
(paren
id|info-&gt;blockshift
op_plus
id|info-&gt;pageshift
)paren
suffix:semicolon
singleline_comment|// read 64 bytes for every block (actually 1 &lt;&lt; CONTROL_SHIFT)
singleline_comment|// but only use a 64 KB buffer
singleline_comment|// buffer size used must be a multiple of (1 &lt;&lt; CONTROL_SHIFT)
DECL|macro|SDDR09_READ_MAP_BUFSZ
mdefine_line|#define SDDR09_READ_MAP_BUFSZ 65536
id|alloc_blocks
op_assign
id|min
c_func
(paren
id|numblocks
comma
id|SDDR09_READ_MAP_BUFSZ
op_rshift
id|CONTROL_SHIFT
)paren
suffix:semicolon
id|alloc_len
op_assign
(paren
id|alloc_blocks
op_lshift
id|CONTROL_SHIFT
)paren
suffix:semicolon
id|buffer
op_assign
id|kmalloc
c_func
(paren
id|alloc_len
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sddr09_read_map: out of memory&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|buffer_end
op_assign
id|buffer
op_plus
id|alloc_len
suffix:semicolon
DECL|macro|SDDR09_READ_MAP_BUFSZ
macro_line|#undef SDDR09_READ_MAP_BUFSZ
id|kfree
c_func
(paren
id|info-&gt;lba_to_pba
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|info-&gt;pba_to_lba
)paren
suffix:semicolon
id|info-&gt;lba_to_pba
op_assign
id|kmalloc
c_func
(paren
id|numblocks
op_star
r_sizeof
(paren
r_int
)paren
comma
id|GFP_NOIO
)paren
suffix:semicolon
id|info-&gt;pba_to_lba
op_assign
id|kmalloc
c_func
(paren
id|numblocks
op_star
r_sizeof
(paren
r_int
)paren
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;lba_to_pba
op_eq
l_int|NULL
op_logical_or
id|info-&gt;pba_to_lba
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sddr09_read_map: out of memory&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numblocks
suffix:semicolon
id|i
op_increment
)paren
id|info-&gt;lba_to_pba
(braket
id|i
)braket
op_assign
id|info-&gt;pba_to_lba
(braket
id|i
)braket
op_assign
id|UNDEF
suffix:semicolon
multiline_comment|/*&n;&t; * Define lba-pba translation table&n;&t; */
id|ptr
op_assign
id|buffer_end
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numblocks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ptr
op_add_assign
(paren
l_int|1
op_lshift
id|CONTROL_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
op_ge
id|buffer_end
)paren
(brace
r_int
r_int
id|address
suffix:semicolon
id|address
op_assign
id|i
op_lshift
(paren
id|info-&gt;pageshift
op_plus
id|info-&gt;blockshift
)paren
suffix:semicolon
id|result
op_assign
id|sddr09_read_control
c_func
(paren
id|us
comma
id|address
op_rshift
l_int|1
comma
id|min
c_func
(paren
id|alloc_blocks
comma
id|numblocks
op_minus
id|i
)paren
comma
id|buffer
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
id|result
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|ptr
op_assign
id|buffer
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|0
op_logical_or
id|i
op_eq
l_int|1
)paren
(brace
id|info-&gt;pba_to_lba
(braket
id|i
)braket
op_assign
id|UNUSABLE
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* special PBAs have control field 0^16 */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|16
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|ptr
(braket
id|j
)braket
op_ne
l_int|0
)paren
r_goto
id|nonz
suffix:semicolon
id|info-&gt;pba_to_lba
(braket
id|i
)braket
op_assign
id|UNUSABLE
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sddr09: PBA %d has no logical mapping&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_continue
suffix:semicolon
id|nonz
suffix:colon
multiline_comment|/* unwritten PBAs have control field FF^16 */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|16
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|ptr
(braket
id|j
)braket
op_ne
l_int|0xff
)paren
r_goto
id|nonff
suffix:semicolon
r_continue
suffix:semicolon
id|nonff
suffix:colon
multiline_comment|/* normal PBAs start with six FFs */
r_if
c_cond
(paren
id|j
OL
l_int|6
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sddr09: PBA %d has no logical mapping: &quot;
l_string|&quot;reserved area = %02X%02X%02X%02X &quot;
l_string|&quot;data status %02X block status %02X&bslash;n&quot;
comma
id|i
comma
id|ptr
(braket
l_int|0
)braket
comma
id|ptr
(braket
l_int|1
)braket
comma
id|ptr
(braket
l_int|2
)braket
comma
id|ptr
(braket
l_int|3
)braket
comma
id|ptr
(braket
l_int|4
)braket
comma
id|ptr
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|info-&gt;pba_to_lba
(braket
id|i
)braket
op_assign
id|UNUSABLE
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ptr
(braket
l_int|6
)braket
op_rshift
l_int|4
)paren
op_ne
l_int|0x01
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sddr09: PBA %d has invalid address field &quot;
l_string|&quot;%02X%02X/%02X%02X&bslash;n&quot;
comma
id|i
comma
id|ptr
(braket
l_int|6
)braket
comma
id|ptr
(braket
l_int|7
)braket
comma
id|ptr
(braket
l_int|11
)braket
comma
id|ptr
(braket
l_int|12
)braket
)paren
suffix:semicolon
id|info-&gt;pba_to_lba
(braket
id|i
)braket
op_assign
id|UNUSABLE
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* check even parity */
r_if
c_cond
(paren
id|parity
(braket
id|ptr
(braket
l_int|6
)braket
op_xor
id|ptr
(braket
l_int|7
)braket
)braket
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sddr09: Bad parity in LBA for block %d&quot;
l_string|&quot; (%02X %02X)&bslash;n&quot;
comma
id|i
comma
id|ptr
(braket
l_int|6
)braket
comma
id|ptr
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|info-&gt;pba_to_lba
(braket
id|i
)braket
op_assign
id|UNUSABLE
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|lba
op_assign
id|short_pack
c_func
(paren
id|ptr
(braket
l_int|7
)braket
comma
id|ptr
(braket
l_int|6
)braket
)paren
suffix:semicolon
id|lba
op_assign
(paren
id|lba
op_amp
l_int|0x07FF
)paren
op_rshift
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Every 1024 physical blocks (&quot;zone&quot;), the LBA numbers&n;&t;&t; * go back to zero, but are within a higher block of LBA&squot;s.&n;&t;&t; * Also, there is a maximum of 1000 LBA&squot;s per zone.&n;&t;&t; * In other words, in PBA 1024-2047 you will find LBA 0-999&n;&t;&t; * which are really LBA 1000-1999. This allows for 24 bad&n;&t;&t; * or special physical blocks per zone.&n;&t;&t; */
r_if
c_cond
(paren
id|lba
op_ge
l_int|1000
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sddr09: Bad low LBA %d for block %d&bslash;n&quot;
comma
id|lba
comma
id|i
)paren
suffix:semicolon
r_goto
id|possibly_erase
suffix:semicolon
)brace
id|lba
op_add_assign
l_int|1000
op_star
(paren
id|i
op_div
l_int|0x400
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;lba_to_pba
(braket
id|lba
)braket
op_ne
id|UNDEF
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sddr09: LBA %d seen for PBA %d and %d&bslash;n&quot;
comma
id|lba
comma
id|info-&gt;lba_to_pba
(braket
id|lba
)braket
comma
id|i
)paren
suffix:semicolon
r_goto
id|possibly_erase
suffix:semicolon
)brace
id|info-&gt;pba_to_lba
(braket
id|i
)braket
op_assign
id|lba
suffix:semicolon
id|info-&gt;lba_to_pba
(braket
id|lba
)braket
op_assign
id|i
suffix:semicolon
r_continue
suffix:semicolon
id|possibly_erase
suffix:colon
r_if
c_cond
(paren
id|erase_bad_lba_entries
)paren
(brace
r_int
r_int
id|address
suffix:semicolon
id|address
op_assign
(paren
id|i
op_lshift
(paren
id|info-&gt;pageshift
op_plus
id|info-&gt;blockshift
)paren
)paren
suffix:semicolon
id|sddr09_erase
c_func
(paren
id|us
comma
id|address
op_rshift
l_int|1
)paren
suffix:semicolon
id|info-&gt;pba_to_lba
(braket
id|i
)braket
op_assign
id|UNDEF
suffix:semicolon
)brace
r_else
id|info-&gt;pba_to_lba
(braket
id|i
)braket
op_assign
id|UNUSABLE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Approximate capacity. This is not entirely correct yet,&n;&t; * since a zone with less than 1000 usable pages leads to&n;&t; * missing LBAs. Especially if it is the last zone, some&n;&t; * LBAs can be past capacity.&n;&t; */
id|lbact
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numblocks
suffix:semicolon
id|i
op_add_assign
l_int|1024
)paren
(brace
r_int
id|ct
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|1024
op_logical_and
id|i
op_plus
id|j
OL
id|numblocks
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;pba_to_lba
(braket
id|i
op_plus
id|j
)braket
op_ne
id|UNUSABLE
)paren
(brace
r_if
c_cond
(paren
id|ct
op_ge
l_int|1000
)paren
id|info-&gt;pba_to_lba
(braket
id|i
op_plus
id|j
)braket
op_assign
id|SPARE
suffix:semicolon
r_else
id|ct
op_increment
suffix:semicolon
)brace
)brace
id|lbact
op_add_assign
id|ct
suffix:semicolon
)brace
id|info-&gt;lbact
op_assign
id|lbact
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Found %d LBA&squot;s&bslash;n&quot;
comma
id|lbact
)paren
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
id|done
suffix:colon
r_if
c_cond
(paren
id|result
op_ne
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|info-&gt;lba_to_pba
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|info-&gt;pba_to_lba
)paren
suffix:semicolon
id|info-&gt;lba_to_pba
op_assign
l_int|NULL
suffix:semicolon
id|info-&gt;pba_to_lba
op_assign
l_int|NULL
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_static
r_void
DECL|function|sddr09_card_info_destructor
id|sddr09_card_info_destructor
c_func
(paren
r_void
op_star
id|extra
)paren
(brace
r_struct
id|sddr09_card_info
op_star
id|info
op_assign
(paren
r_struct
id|sddr09_card_info
op_star
)paren
id|extra
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
r_return
suffix:semicolon
id|kfree
c_func
(paren
id|info-&gt;lba_to_pba
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|info-&gt;pba_to_lba
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|sddr09_init_card_info
id|sddr09_init_card_info
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|us-&gt;extra
)paren
(brace
id|us-&gt;extra
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|sddr09_card_info
)paren
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|us-&gt;extra
)paren
(brace
id|memset
c_func
(paren
id|us-&gt;extra
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|sddr09_card_info
)paren
)paren
suffix:semicolon
id|us-&gt;extra_destructor
op_assign
id|sddr09_card_info_destructor
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * This is needed at a very early stage. If this is not listed in the&n; * unusual devices list but called from here then LUN 0 of the combo reader&n; * is not recognized. But I do not know what precisely these calls do.&n; */
r_int
DECL|function|sddr09_init
id|sddr09_init
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_char
op_star
id|data
op_assign
id|us-&gt;iobuf
suffix:semicolon
id|result
op_assign
id|sddr09_send_command
c_func
(paren
id|us
comma
l_int|0x01
comma
id|USB_DIR_IN
comma
id|data
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;sddr09_init: send_command fails&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;SDDR09init: %02X %02X&bslash;n&quot;
comma
id|data
(braket
l_int|0
)braket
comma
id|data
(braket
l_int|1
)braket
)paren
suffix:semicolon
singleline_comment|// get 07 02
id|result
op_assign
id|sddr09_send_command
c_func
(paren
id|us
comma
l_int|0x08
comma
id|USB_DIR_IN
comma
id|data
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;sddr09_init: 2nd send_command fails&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;SDDR09init: %02X %02X&bslash;n&quot;
comma
id|data
(braket
l_int|0
)braket
comma
id|data
(braket
l_int|1
)braket
)paren
suffix:semicolon
singleline_comment|// get 07 00
id|result
op_assign
id|sddr09_request_sense
c_func
(paren
id|us
comma
id|data
comma
l_int|18
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
id|USB_STOR_TRANSPORT_GOOD
op_logical_and
id|data
(braket
l_int|2
)braket
op_ne
l_int|0
)paren
(brace
r_int
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|18
suffix:semicolon
id|j
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %02X&quot;
comma
id|data
(braket
id|j
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|// get 70 00 00 00 00 00 00 * 00 00 00 00 00 00
singleline_comment|// 70: current command
singleline_comment|// sense key 0, sense code 0, extd sense code 0
singleline_comment|// additional transfer length * = sizeof(data) - 7
singleline_comment|// Or: 70 00 06 00 00 00 00 0b 00 00 00 00 28 00 00 00 00 00
singleline_comment|// sense key 06, sense code 28: unit attention,
singleline_comment|// not ready to ready transition
)brace
singleline_comment|// test unit ready
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
multiline_comment|/* not result */
)brace
multiline_comment|/*&n; * Transport for the Sandisk SDDR-09&n; */
DECL|function|sddr09_transport
r_int
id|sddr09_transport
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_static
r_int
r_char
id|sensekey
op_assign
l_int|0
comma
id|sensecode
op_assign
l_int|0
suffix:semicolon
r_static
r_int
r_char
id|havefakesense
op_assign
l_int|0
suffix:semicolon
r_int
id|result
comma
id|i
suffix:semicolon
r_int
r_char
op_star
id|ptr
op_assign
id|us-&gt;iobuf
suffix:semicolon
r_int
r_int
id|capacity
suffix:semicolon
r_int
r_int
id|page
comma
id|pages
suffix:semicolon
r_struct
id|sddr09_card_info
op_star
id|info
suffix:semicolon
r_static
r_int
r_char
id|inquiry_response
(braket
l_int|8
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0x80
comma
l_int|0x00
comma
l_int|0x02
comma
l_int|0x1F
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
multiline_comment|/* note: no block descriptor support */
r_static
r_int
r_char
id|mode_page_01
(braket
l_int|19
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0x0F
comma
l_int|0x00
comma
l_int|0x0
comma
l_int|0x0
comma
l_int|0x0
comma
l_int|0x00
comma
l_int|0x01
comma
l_int|0x0A
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
id|info
op_assign
(paren
r_struct
id|sddr09_card_info
op_star
)paren
id|us-&gt;extra
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
(brace
id|nand_init_ecc
c_func
(paren
)paren
suffix:semicolon
id|sddr09_init_card_info
c_func
(paren
id|us
)paren
suffix:semicolon
id|info
op_assign
(paren
r_struct
id|sddr09_card_info
op_star
)paren
id|us-&gt;extra
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
op_logical_and
id|havefakesense
)paren
(brace
multiline_comment|/* for a faked command, we have to follow with a faked sense */
id|memset
c_func
(paren
id|ptr
comma
l_int|0
comma
l_int|18
)paren
suffix:semicolon
id|ptr
(braket
l_int|0
)braket
op_assign
l_int|0x70
suffix:semicolon
id|ptr
(braket
l_int|2
)braket
op_assign
id|sensekey
suffix:semicolon
id|ptr
(braket
l_int|7
)braket
op_assign
l_int|11
suffix:semicolon
id|ptr
(braket
l_int|12
)braket
op_assign
id|sensecode
suffix:semicolon
id|usb_stor_set_xfer_buf
c_func
(paren
id|ptr
comma
l_int|18
comma
id|srb
)paren
suffix:semicolon
id|sensekey
op_assign
id|sensecode
op_assign
id|havefakesense
op_assign
l_int|0
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
id|havefakesense
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Dummy up a response for INQUIRY since SDDR09 doesn&squot;t&n;&t;   respond to INQUIRY commands */
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
(brace
id|memcpy
c_func
(paren
id|ptr
comma
id|inquiry_response
comma
l_int|8
)paren
suffix:semicolon
id|fill_inquiry_response
c_func
(paren
id|us
comma
id|ptr
comma
l_int|36
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|READ_CAPACITY
)paren
(brace
r_struct
id|nand_flash_dev
op_star
id|cardinfo
suffix:semicolon
id|sddr09_get_wp
c_func
(paren
id|us
comma
id|info
)paren
suffix:semicolon
multiline_comment|/* read WP bit */
id|cardinfo
op_assign
id|sddr09_get_cardinfo
c_func
(paren
id|us
comma
id|info-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cardinfo
)paren
(brace
multiline_comment|/* probably no media */
id|init_error
suffix:colon
id|sensekey
op_assign
l_int|0x02
suffix:semicolon
multiline_comment|/* not ready */
id|sensecode
op_assign
l_int|0x3a
suffix:semicolon
multiline_comment|/* medium not present */
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
id|info-&gt;capacity
op_assign
(paren
l_int|1
op_lshift
id|cardinfo-&gt;chipshift
)paren
suffix:semicolon
id|info-&gt;pageshift
op_assign
id|cardinfo-&gt;pageshift
suffix:semicolon
id|info-&gt;pagesize
op_assign
(paren
l_int|1
op_lshift
id|info-&gt;pageshift
)paren
suffix:semicolon
id|info-&gt;blockshift
op_assign
id|cardinfo-&gt;blockshift
suffix:semicolon
id|info-&gt;blocksize
op_assign
(paren
l_int|1
op_lshift
id|info-&gt;blockshift
)paren
suffix:semicolon
id|info-&gt;blockmask
op_assign
id|info-&gt;blocksize
op_minus
l_int|1
suffix:semicolon
singleline_comment|// map initialization, must follow get_cardinfo()
r_if
c_cond
(paren
id|sddr09_read_map
c_func
(paren
id|us
)paren
)paren
(brace
multiline_comment|/* probably out of memory */
r_goto
id|init_error
suffix:semicolon
)brace
singleline_comment|// Report capacity
id|capacity
op_assign
(paren
id|info-&gt;lbact
op_lshift
id|info-&gt;blockshift
)paren
op_minus
l_int|1
suffix:semicolon
(paren
(paren
id|__be32
op_star
)paren
id|ptr
)paren
(braket
l_int|0
)braket
op_assign
id|cpu_to_be32
c_func
(paren
id|capacity
)paren
suffix:semicolon
singleline_comment|// Report page size
(paren
(paren
id|__be32
op_star
)paren
id|ptr
)paren
(braket
l_int|1
)braket
op_assign
id|cpu_to_be32
c_func
(paren
id|info-&gt;pagesize
)paren
suffix:semicolon
id|usb_stor_set_xfer_buf
c_func
(paren
id|ptr
comma
l_int|8
comma
id|srb
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|MODE_SENSE_10
)paren
(brace
r_int
id|modepage
op_assign
(paren
id|srb-&gt;cmnd
(braket
l_int|2
)braket
op_amp
l_int|0x3F
)paren
suffix:semicolon
multiline_comment|/* They ask for the Read/Write error recovery page,&n;&t;&t;   or for all pages. */
multiline_comment|/* %% We should check DBD %% */
r_if
c_cond
(paren
id|modepage
op_eq
l_int|0x01
op_logical_or
id|modepage
op_eq
l_int|0x3F
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;SDDR09: Dummy up request for &quot;
l_string|&quot;mode page 0x%x&bslash;n&quot;
comma
id|modepage
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
comma
id|mode_page_01
comma
r_sizeof
(paren
id|mode_page_01
)paren
)paren
suffix:semicolon
(paren
(paren
id|__be16
op_star
)paren
id|ptr
)paren
(braket
l_int|0
)braket
op_assign
id|cpu_to_be16
c_func
(paren
r_sizeof
(paren
id|mode_page_01
)paren
op_minus
l_int|2
)paren
suffix:semicolon
id|ptr
(braket
l_int|3
)braket
op_assign
(paren
id|info-&gt;flags
op_amp
id|SDDR09_WP
)paren
ques
c_cond
l_int|0x80
suffix:colon
l_int|0
suffix:semicolon
id|usb_stor_set_xfer_buf
c_func
(paren
id|ptr
comma
r_sizeof
(paren
id|mode_page_01
)paren
comma
id|srb
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
id|sensekey
op_assign
l_int|0x05
suffix:semicolon
multiline_comment|/* illegal request */
id|sensecode
op_assign
l_int|0x24
suffix:semicolon
multiline_comment|/* invalid field in CDB */
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|ALLOW_MEDIUM_REMOVAL
)paren
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
id|havefakesense
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|READ_10
)paren
(brace
id|page
op_assign
id|short_pack
c_func
(paren
id|srb-&gt;cmnd
(braket
l_int|3
)braket
comma
id|srb-&gt;cmnd
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|page
op_lshift_assign
l_int|16
suffix:semicolon
id|page
op_or_assign
id|short_pack
c_func
(paren
id|srb-&gt;cmnd
(braket
l_int|5
)braket
comma
id|srb-&gt;cmnd
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|pages
op_assign
id|short_pack
c_func
(paren
id|srb-&gt;cmnd
(braket
l_int|8
)braket
comma
id|srb-&gt;cmnd
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;READ_10: read page %d pagect %d&bslash;n&quot;
comma
id|page
comma
id|pages
)paren
suffix:semicolon
r_return
id|sddr09_read_data
c_func
(paren
id|us
comma
id|page
comma
id|pages
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|WRITE_10
)paren
(brace
id|page
op_assign
id|short_pack
c_func
(paren
id|srb-&gt;cmnd
(braket
l_int|3
)braket
comma
id|srb-&gt;cmnd
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|page
op_lshift_assign
l_int|16
suffix:semicolon
id|page
op_or_assign
id|short_pack
c_func
(paren
id|srb-&gt;cmnd
(braket
l_int|5
)braket
comma
id|srb-&gt;cmnd
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|pages
op_assign
id|short_pack
c_func
(paren
id|srb-&gt;cmnd
(braket
l_int|8
)braket
comma
id|srb-&gt;cmnd
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;WRITE_10: write page %d pagect %d&bslash;n&quot;
comma
id|page
comma
id|pages
)paren
suffix:semicolon
r_return
id|sddr09_write_data
c_func
(paren
id|us
comma
id|page
comma
id|pages
)paren
suffix:semicolon
)brace
multiline_comment|/* catch-all for all other commands, except&n;&t; * pass TEST_UNIT_READY and REQUEST_SENSE through&n;&t; */
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_ne
id|TEST_UNIT_READY
op_logical_and
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_ne
id|REQUEST_SENSE
)paren
(brace
id|sensekey
op_assign
l_int|0x05
suffix:semicolon
multiline_comment|/* illegal request */
id|sensecode
op_assign
l_int|0x20
suffix:semicolon
multiline_comment|/* invalid command */
id|havefakesense
op_assign
l_int|1
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|srb-&gt;cmd_len
OL
l_int|12
suffix:semicolon
id|srb-&gt;cmd_len
op_increment
)paren
id|srb-&gt;cmnd
(braket
id|srb-&gt;cmd_len
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|1
)braket
op_assign
id|LUNBITS
suffix:semicolon
id|ptr
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|12
suffix:semicolon
id|i
op_increment
)paren
id|sprintf
c_func
(paren
id|ptr
op_plus
id|strlen
c_func
(paren
id|ptr
)paren
comma
l_string|&quot;%02X &quot;
comma
id|srb-&gt;cmnd
(braket
id|i
)braket
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;SDDR09: Send control for command %s&bslash;n&quot;
comma
id|ptr
)paren
suffix:semicolon
id|result
op_assign
id|sddr09_send_scsi_command
c_func
(paren
id|us
comma
id|srb-&gt;cmnd
comma
l_int|12
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;sddr09_transport: sddr09_send_scsi_command &quot;
l_string|&quot;returns %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;request_bufflen
op_eq
l_int|0
)paren
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
r_if
c_cond
(paren
id|srb-&gt;sc_data_direction
op_eq
id|DMA_TO_DEVICE
op_logical_or
id|srb-&gt;sc_data_direction
op_eq
id|DMA_FROM_DEVICE
)paren
(brace
r_int
r_int
id|pipe
op_assign
(paren
id|srb-&gt;sc_data_direction
op_eq
id|DMA_TO_DEVICE
)paren
ques
c_cond
id|us-&gt;send_bulk_pipe
suffix:colon
id|us-&gt;recv_bulk_pipe
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;SDDR09: %s %d bytes&bslash;n&quot;
comma
(paren
id|srb-&gt;sc_data_direction
op_eq
id|DMA_TO_DEVICE
)paren
ques
c_cond
l_string|&quot;sending&quot;
suffix:colon
l_string|&quot;receiving&quot;
comma
id|srb-&gt;request_bufflen
)paren
suffix:semicolon
id|result
op_assign
id|usb_stor_bulk_transfer_sg
c_func
(paren
id|us
comma
id|pipe
comma
id|srb-&gt;request_buffer
comma
id|srb-&gt;request_bufflen
comma
id|srb-&gt;use_sg
comma
op_amp
id|srb-&gt;resid
)paren
suffix:semicolon
r_return
(paren
id|result
op_eq
id|USB_STOR_XFER_GOOD
ques
c_cond
id|USB_STOR_TRANSPORT_GOOD
suffix:colon
id|USB_STOR_TRANSPORT_ERROR
)paren
suffix:semicolon
)brace
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
eof
