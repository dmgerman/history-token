multiline_comment|/* Driver for SanDisk SDDR-09 SmartMedia reader&n; *&n; *   (c) 2000, 2001 Robert Baruch (autophile@starband.net)&n; *   (c) 2002 Andries Brouwer (aeb@cwi.nl)&n; *&n; * The SanDisk SDDR-09 SmartMedia reader uses the Shuttle EUSB-01 chip.&n; * This chip is a programmable USB controller. In the SDDR-09, it has&n; * been programmed to obey a certain limited set of SCSI commands.&n; * This driver translates the &quot;real&quot; SCSI commands to the SDDR-09 SCSI&n; * commands.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2, or (at your option) any&n; * later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write to the Free Software Foundation, Inc.,&n; * 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &quot;transport.h&quot;
macro_line|#include &quot;protocol.h&quot;
macro_line|#include &quot;usb.h&quot;
macro_line|#include &quot;debug.h&quot;
macro_line|#include &quot;sddr09.h&quot;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
DECL|macro|short_pack
mdefine_line|#define short_pack(lsb,msb) ( ((u16)(lsb)) | ( ((u16)(msb))&lt;&lt;8 ) )
DECL|macro|LSB_of
mdefine_line|#define LSB_of(s) ((s)&amp;0xFF)
DECL|macro|MSB_of
mdefine_line|#define MSB_of(s) ((s)&gt;&gt;8)
multiline_comment|/* #define US_DEBUGP printk */
multiline_comment|/*&n; * First some stuff that does not belong here:&n; * data on SmartMedia and other cards, completely&n; * unrelated to this driver.&n; * Similar stuff occurs in &lt;linux/mtd/nand_ids.h&gt;.&n; */
DECL|struct|nand_flash_dev
r_struct
id|nand_flash_dev
(brace
DECL|member|model_id
r_int
id|model_id
suffix:semicolon
DECL|member|chipshift
r_int
id|chipshift
suffix:semicolon
multiline_comment|/* 1&lt;&lt;cs bytes total capacity */
DECL|member|pageshift
r_char
id|pageshift
suffix:semicolon
multiline_comment|/* 1&lt;&lt;ps bytes in a page */
DECL|member|blockshift
r_char
id|blockshift
suffix:semicolon
multiline_comment|/* 1&lt;&lt;bs pages in an erase block */
DECL|member|zoneshift
r_char
id|zoneshift
suffix:semicolon
multiline_comment|/* 1&lt;&lt;zs blocks in a zone */
multiline_comment|/* # of logical blocks is 125/128 of this */
DECL|member|pageadrlen
r_char
id|pageadrlen
suffix:semicolon
multiline_comment|/* length of an address in bytes - 1 */
)brace
suffix:semicolon
multiline_comment|/*&n; * NAND Flash Manufacturer ID Codes&n; */
DECL|macro|NAND_MFR_AMD
mdefine_line|#define NAND_MFR_AMD&t;&t;0x01
DECL|macro|NAND_MFR_TOSHIBA
mdefine_line|#define NAND_MFR_TOSHIBA&t;0x98
DECL|macro|NAND_MFR_SAMSUNG
mdefine_line|#define NAND_MFR_SAMSUNG&t;0xec
DECL|function|nand_flash_manufacturer
r_static
r_inline
r_char
op_star
id|nand_flash_manufacturer
c_func
(paren
r_int
id|manuf_id
)paren
(brace
r_switch
c_cond
(paren
id|manuf_id
)paren
(brace
r_case
id|NAND_MFR_AMD
suffix:colon
r_return
l_string|&quot;AMD&quot;
suffix:semicolon
r_case
id|NAND_MFR_TOSHIBA
suffix:colon
r_return
l_string|&quot;Toshiba&quot;
suffix:semicolon
r_case
id|NAND_MFR_SAMSUNG
suffix:colon
r_return
l_string|&quot;Samsung&quot;
suffix:semicolon
r_default
suffix:colon
r_return
l_string|&quot;unknown&quot;
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * It looks like it is unnecessary to attach manufacturer to the&n; * remaining data: SSFDC prescribes manufacturer-independent id codes.&n; */
DECL|variable|nand_flash_ids
r_static
r_struct
id|nand_flash_dev
id|nand_flash_ids
(braket
)braket
op_assign
(brace
multiline_comment|/* NAND flash - these I verified */
(brace
l_int|0x6e
comma
l_int|20
comma
l_int|8
comma
l_int|4
comma
l_int|8
comma
l_int|2
)brace
comma
multiline_comment|/* 1 MB */
(brace
l_int|0xe8
comma
l_int|20
comma
l_int|8
comma
l_int|4
comma
l_int|8
comma
l_int|2
)brace
comma
multiline_comment|/* 1 MB */
(brace
l_int|0xec
comma
l_int|20
comma
l_int|8
comma
l_int|4
comma
l_int|8
comma
l_int|2
)brace
comma
multiline_comment|/* 1 MB */
(brace
l_int|0x64
comma
l_int|21
comma
l_int|8
comma
l_int|4
comma
l_int|9
comma
l_int|2
)brace
comma
multiline_comment|/* 2 MB */
(brace
l_int|0xea
comma
l_int|21
comma
l_int|8
comma
l_int|4
comma
l_int|9
comma
l_int|2
)brace
comma
multiline_comment|/* 2 MB */
(brace
l_int|0x6b
comma
l_int|22
comma
l_int|9
comma
l_int|4
comma
l_int|9
comma
l_int|2
)brace
comma
multiline_comment|/* 4 MB */
(brace
l_int|0xe3
comma
l_int|22
comma
l_int|9
comma
l_int|4
comma
l_int|9
comma
l_int|2
)brace
comma
multiline_comment|/* 4 MB */
(brace
l_int|0xe5
comma
l_int|22
comma
l_int|9
comma
l_int|4
comma
l_int|9
comma
l_int|2
)brace
comma
multiline_comment|/* 4 MB */
(brace
l_int|0xe6
comma
l_int|23
comma
l_int|9
comma
l_int|4
comma
l_int|10
comma
l_int|2
)brace
comma
multiline_comment|/* 8 MB */
(brace
l_int|0x73
comma
l_int|24
comma
l_int|9
comma
l_int|5
comma
l_int|10
comma
l_int|2
)brace
comma
multiline_comment|/* 16 MB */
(brace
l_int|0x75
comma
l_int|25
comma
l_int|9
comma
l_int|5
comma
l_int|10
comma
l_int|2
)brace
comma
multiline_comment|/* 32 MB */
(brace
l_int|0x76
comma
l_int|26
comma
l_int|9
comma
l_int|5
comma
l_int|10
comma
l_int|3
)brace
comma
multiline_comment|/* 64 MB */
(brace
l_int|0x79
comma
l_int|27
comma
l_int|9
comma
l_int|5
comma
l_int|10
comma
l_int|3
)brace
comma
multiline_comment|/* 128 MB */
multiline_comment|/* There do also exist 96 MB (from Datafab) and 256 MB cards */
multiline_comment|/* MASK ROM - from unknown source */
(brace
l_int|0x5d
comma
l_int|21
comma
l_int|9
comma
l_int|4
comma
l_int|8
comma
l_int|2
)brace
comma
multiline_comment|/* 2 MB */
(brace
l_int|0xd5
comma
l_int|22
comma
l_int|9
comma
l_int|4
comma
l_int|9
comma
l_int|2
)brace
comma
multiline_comment|/* 4 MB */
(brace
l_int|0xd6
comma
l_int|23
comma
l_int|9
comma
l_int|4
comma
l_int|10
comma
l_int|2
)brace
comma
multiline_comment|/* 8 MB */
(brace
l_int|0
comma
)brace
)brace
suffix:semicolon
DECL|macro|SIZE
mdefine_line|#define SIZE(a)&t;(sizeof(a)/sizeof((a)[0]))
r_static
r_struct
id|nand_flash_dev
op_star
DECL|function|nand_find_id
id|nand_find_id
c_func
(paren
r_int
r_char
id|id
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SIZE
c_func
(paren
id|nand_flash_ids
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|nand_flash_ids
(braket
id|i
)braket
dot
id|model_id
op_eq
id|id
)paren
r_return
op_amp
(paren
id|nand_flash_ids
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * ECC computation.&n; */
DECL|variable|parity
r_static
r_int
r_char
id|parity
(braket
l_int|256
)braket
suffix:semicolon
DECL|variable|ecc2
r_static
r_int
r_char
id|ecc2
(braket
l_int|256
)braket
suffix:semicolon
DECL|function|nand_init_ecc
r_static
r_void
id|nand_init_ecc
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|j
comma
id|a
suffix:semicolon
id|parity
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
id|parity
(braket
id|i
)braket
op_assign
(paren
id|parity
(braket
id|i
op_amp
(paren
id|i
op_minus
l_int|1
)paren
)braket
op_xor
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
(brace
id|a
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|8
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_amp
(paren
l_int|1
op_lshift
id|j
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|j
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
id|a
op_xor_assign
l_int|0x04
suffix:semicolon
r_if
c_cond
(paren
(paren
id|j
op_amp
l_int|2
)paren
op_eq
l_int|0
)paren
id|a
op_xor_assign
l_int|0x10
suffix:semicolon
r_if
c_cond
(paren
(paren
id|j
op_amp
l_int|4
)paren
op_eq
l_int|0
)paren
id|a
op_xor_assign
l_int|0x40
suffix:semicolon
)brace
)brace
id|ecc2
(braket
id|i
)braket
op_assign
op_complement
(paren
id|a
op_xor
(paren
id|a
op_lshift
l_int|1
)paren
op_xor
(paren
id|parity
(braket
id|i
)braket
ques
c_cond
l_int|0xa8
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* compute 3-byte ecc on 256 bytes */
DECL|function|nand_compute_ecc
r_static
r_void
id|nand_compute_ecc
c_func
(paren
r_int
r_char
op_star
id|data
comma
r_int
r_char
op_star
id|ecc
)paren
(brace
r_int
id|i
comma
id|j
comma
id|a
suffix:semicolon
r_int
r_char
id|par
comma
id|bit
comma
id|bits
(braket
l_int|8
)braket
suffix:semicolon
id|par
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|8
suffix:semicolon
id|j
op_increment
)paren
id|bits
(braket
id|j
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* collect 16 checksum bits */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
(brace
id|par
op_xor_assign
id|data
(braket
id|i
)braket
suffix:semicolon
id|bit
op_assign
id|parity
(braket
id|data
(braket
id|i
)braket
)braket
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|8
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
(paren
id|i
op_amp
(paren
l_int|1
op_lshift
id|j
)paren
)paren
op_eq
l_int|0
)paren
id|bits
(braket
id|j
)braket
op_xor_assign
id|bit
suffix:semicolon
)brace
multiline_comment|/* put 4+4+4 = 12 bits in the ecc */
id|a
op_assign
(paren
id|bits
(braket
l_int|3
)braket
op_lshift
l_int|6
)paren
op_plus
(paren
id|bits
(braket
l_int|2
)braket
op_lshift
l_int|4
)paren
op_plus
(paren
id|bits
(braket
l_int|1
)braket
op_lshift
l_int|2
)paren
op_plus
id|bits
(braket
l_int|0
)braket
suffix:semicolon
id|ecc
(braket
l_int|0
)braket
op_assign
op_complement
(paren
id|a
op_xor
(paren
id|a
op_lshift
l_int|1
)paren
op_xor
(paren
id|parity
(braket
id|par
)braket
ques
c_cond
l_int|0xaa
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
id|a
op_assign
(paren
id|bits
(braket
l_int|7
)braket
op_lshift
l_int|6
)paren
op_plus
(paren
id|bits
(braket
l_int|6
)braket
op_lshift
l_int|4
)paren
op_plus
(paren
id|bits
(braket
l_int|5
)braket
op_lshift
l_int|2
)paren
op_plus
id|bits
(braket
l_int|4
)braket
suffix:semicolon
id|ecc
(braket
l_int|1
)braket
op_assign
op_complement
(paren
id|a
op_xor
(paren
id|a
op_lshift
l_int|1
)paren
op_xor
(paren
id|parity
(braket
id|par
)braket
ques
c_cond
l_int|0xaa
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
id|ecc
(braket
l_int|2
)braket
op_assign
id|ecc2
(braket
id|par
)braket
suffix:semicolon
)brace
DECL|function|nand_compare_ecc
r_static
r_int
id|nand_compare_ecc
c_func
(paren
r_int
r_char
op_star
id|data
comma
r_int
r_char
op_star
id|ecc
)paren
(brace
r_return
(paren
id|data
(braket
l_int|0
)braket
op_eq
id|ecc
(braket
l_int|0
)braket
op_logical_and
id|data
(braket
l_int|1
)braket
op_eq
id|ecc
(braket
l_int|1
)braket
op_logical_and
id|data
(braket
l_int|2
)braket
op_eq
id|ecc
(braket
l_int|2
)braket
)paren
suffix:semicolon
)brace
DECL|function|nand_store_ecc
r_static
r_void
id|nand_store_ecc
c_func
(paren
r_int
r_char
op_star
id|data
comma
r_int
r_char
op_star
id|ecc
)paren
(brace
id|memcpy
c_func
(paren
id|data
comma
id|ecc
comma
l_int|3
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The actual driver starts here.&n; */
multiline_comment|/*&n; * On my 16MB card, control blocks have size 64 (16 real control bytes,&n; * and 48 junk bytes). In reality of course the card uses 16 control bytes,&n; * so the reader makes up the remaining 48. Don&squot;t know whether these numbers&n; * depend on the card. For now a constant.&n; */
DECL|macro|CONTROL_SHIFT
mdefine_line|#define CONTROL_SHIFT 6
multiline_comment|/*&n; * On my Combo CF/SM reader, the SM reader has LUN 1.&n; * (and things fail with LUN 0).&n; * It seems LUN is irrelevant for others.&n; */
DECL|macro|LUN
mdefine_line|#define LUN&t;1
DECL|macro|LUNBITS
mdefine_line|#define&t;LUNBITS&t;(LUN &lt;&lt; 5)
multiline_comment|/*&n; * LBA and PBA are unsigned ints. Special values.&n; */
DECL|macro|UNDEF
mdefine_line|#define UNDEF    0xffffffff
DECL|macro|SPARE
mdefine_line|#define SPARE    0xfffffffe
DECL|macro|UNUSABLE
mdefine_line|#define UNUSABLE 0xfffffffd
DECL|variable|erase_bad_lba_entries
r_static
r_int
id|erase_bad_lba_entries
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Send a control message and wait for the response.&n; *&n; * us - the pointer to the us_data structure for the device to use&n; *&n; * request - the URB Setup Packet&squot;s first 6 bytes. The first byte always&n; *  corresponds to the request type, and the second byte always corresponds&n; *  to the request.  The other 4 bytes do not correspond to value and index,&n; *  since they are used in a custom way by the SCM protocol.&n; *&n; * xfer_data - a buffer from which to get, or to which to store, any data&n; *  that gets send or received, respectively, with the URB. Even though&n; *  it looks like we allocate a buffer in this code for the data, xfer_data&n; *  must contain enough allocated space.&n; *&n; * xfer_len - the number of bytes to send or receive with the URB.&n; *&n; */
r_static
r_int
DECL|function|sddr09_send_control
id|sddr09_send_control
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
id|pipe
comma
r_int
r_char
id|request
comma
r_int
r_char
id|requesttype
comma
r_int
r_int
id|value
comma
r_int
r_int
id|index
comma
r_int
r_char
op_star
id|xfer_data
comma
r_int
r_int
id|xfer_len
)paren
(brace
r_int
id|result
suffix:semicolon
singleline_comment|// Send the URB to the device and wait for a response.
multiline_comment|/* Why are request and request type reversed in this call? */
id|result
op_assign
id|usb_stor_control_msg
c_func
(paren
id|us
comma
id|pipe
comma
id|request
comma
id|requesttype
comma
id|value
comma
id|index
comma
id|xfer_data
comma
id|xfer_len
)paren
suffix:semicolon
singleline_comment|// Check the return code for the command.
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
multiline_comment|/* if the command was aborted, indicate that */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ENOENT
)paren
r_return
id|USB_STOR_TRANSPORT_ABORTED
suffix:semicolon
multiline_comment|/* a stall is a fatal condition from the device */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- Stall on control pipe. Clearing&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|pipe
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- usb_clear_halt() returns %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
multiline_comment|/* send vendor interface command (0x41) */
multiline_comment|/* called for requests 0, 1, 8 */
r_static
r_int
DECL|function|sddr09_send_command
id|sddr09_send_command
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
id|request
comma
r_int
r_char
id|direction
comma
r_int
r_char
op_star
id|xfer_data
comma
r_int
r_int
id|xfer_len
)paren
(brace
r_int
id|pipe
suffix:semicolon
r_int
r_char
id|requesttype
op_assign
(paren
l_int|0x41
op_or
id|direction
)paren
suffix:semicolon
singleline_comment|// Get the receive or send control pipe number
r_if
c_cond
(paren
id|direction
op_eq
id|USB_DIR_IN
)paren
id|pipe
op_assign
id|usb_rcvctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
suffix:semicolon
r_else
id|pipe
op_assign
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
suffix:semicolon
r_return
id|sddr09_send_control
c_func
(paren
id|us
comma
id|pipe
comma
id|request
comma
id|requesttype
comma
l_int|0
comma
l_int|0
comma
id|xfer_data
comma
id|xfer_len
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|sddr09_send_scsi_command
id|sddr09_send_scsi_command
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|command
comma
r_int
r_int
id|command_len
)paren
(brace
r_return
id|sddr09_send_command
c_func
(paren
id|us
comma
l_int|0
comma
id|USB_DIR_OUT
comma
id|command
comma
id|command_len
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|sddr09_raw_bulk
id|sddr09_raw_bulk
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
id|direction
comma
r_int
r_char
op_star
id|data
comma
r_int
r_int
id|len
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
id|act_len
suffix:semicolon
r_int
id|pipe
suffix:semicolon
r_if
c_cond
(paren
id|direction
op_eq
id|SCSI_DATA_READ
)paren
id|pipe
op_assign
id|usb_rcvbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;ep_in
)paren
suffix:semicolon
r_else
id|pipe
op_assign
id|usb_sndbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;ep_out
)paren
suffix:semicolon
id|result
op_assign
id|usb_stor_bulk_msg
c_func
(paren
id|us
comma
id|data
comma
id|pipe
comma
id|len
comma
op_amp
id|act_len
)paren
suffix:semicolon
multiline_comment|/* if we stall, we need to clear it before we go on */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;EPIPE: clearing endpoint halt for&quot;
l_string|&quot; pipe 0x%x, stalled at %d bytes&bslash;n&quot;
comma
id|pipe
comma
id|act_len
)paren
suffix:semicolon
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|pipe
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
)paren
(brace
multiline_comment|/* -ENOENT -- we canceled this transfer */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ENOENT
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;usbat_raw_bulk(): transfer aborted&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|US_BULK_TRANSFER_ABORTED
suffix:semicolon
)brace
multiline_comment|/* NAK - that means we&squot;ve retried a few times already */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ETIMEDOUT
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;usbat_raw_bulk(): device NAKed&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EOVERFLOW
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;us_transfer_partial(): babble/overflow&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|result
op_ne
op_minus
id|EPIPE
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;us_transfer_partial(): unknown error %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_return
id|US_BULK_TRANSFER_FAILED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|act_len
op_ne
id|len
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Warning: Transferred only %d of %d bytes&bslash;n&quot;
comma
id|act_len
comma
id|len
)paren
suffix:semicolon
r_return
id|US_BULK_TRANSFER_SHORT
suffix:semicolon
)brace
r_return
id|US_BULK_TRANSFER_GOOD
suffix:semicolon
)brace
r_static
r_int
DECL|function|sddr09_bulk_transport
id|sddr09_bulk_transport
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
id|direction
comma
r_int
r_char
op_star
id|data
comma
r_int
r_int
id|len
comma
r_int
id|use_sg
)paren
(brace
r_int
id|result
op_assign
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
r_int
id|transferred
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
r_char
id|string
(braket
l_int|64
)braket
suffix:semicolon
DECL|macro|DEBUG_PRCT
mdefine_line|#define DEBUG_PRCT 12
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
r_if
c_cond
(paren
id|direction
op_eq
id|SCSI_DATA_WRITE
op_logical_and
op_logical_neg
id|use_sg
)paren
(brace
multiline_comment|/* Debug-print the first N bytes of the write transfer */
id|strcpy
c_func
(paren
id|string
comma
l_string|&quot;wr: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
op_logical_and
id|i
OL
id|DEBUG_PRCT
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|string
op_plus
id|strlen
c_func
(paren
id|string
)paren
comma
l_string|&quot;%02X &quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|16
)paren
op_eq
l_int|15
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|string
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|string
comma
l_string|&quot;wr: &quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|16
)paren
op_ne
l_int|0
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|string
)paren
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;SCM data %s transfer %d sg buffers %d&bslash;n&quot;
comma
(paren
id|direction
op_eq
id|SCSI_DATA_READ
)paren
ques
c_cond
l_string|&quot;in&quot;
suffix:colon
l_string|&quot;out&quot;
comma
id|len
comma
id|use_sg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|use_sg
)paren
id|result
op_assign
id|sddr09_raw_bulk
c_func
(paren
id|us
comma
id|direction
comma
id|data
comma
id|len
)paren
suffix:semicolon
r_else
(brace
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|data
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|use_sg
op_logical_and
id|transferred
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_char
op_star
id|buf
suffix:semicolon
r_int
r_int
id|length
suffix:semicolon
id|buf
op_assign
id|page_address
c_func
(paren
id|sg
(braket
id|i
)braket
dot
id|page
)paren
op_plus
id|sg
(braket
id|i
)braket
dot
id|offset
suffix:semicolon
id|length
op_assign
id|len
op_minus
id|transferred
suffix:semicolon
r_if
c_cond
(paren
id|length
OG
id|sg
(braket
id|i
)braket
dot
id|length
)paren
id|length
op_assign
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
id|result
op_assign
id|sddr09_raw_bulk
c_func
(paren
id|us
comma
id|direction
comma
id|buf
comma
id|length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|US_BULK_TRANSFER_GOOD
)paren
r_break
suffix:semicolon
id|transferred
op_add_assign
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|direction
op_eq
id|SCSI_DATA_READ
op_logical_and
op_logical_neg
id|use_sg
)paren
(brace
multiline_comment|/* Debug-print the first N bytes of the read transfer */
id|strcpy
c_func
(paren
id|string
comma
l_string|&quot;rd: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
op_logical_and
id|i
OL
id|DEBUG_PRCT
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|string
op_plus
id|strlen
c_func
(paren
id|string
)paren
comma
l_string|&quot;%02X &quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|16
)paren
op_eq
l_int|15
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|string
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|string
comma
l_string|&quot;rd: &quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|16
)paren
op_ne
l_int|0
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|string
)paren
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/*&n; * Test Unit Ready Command: 12 bytes.&n; * byte 0: opcode: 00&n; */
r_static
r_int
id|sddr09_test_unit_ready
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
r_char
id|command
(braket
l_int|6
)braket
op_assign
(brace
l_int|0
comma
id|LUNBITS
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
id|result
suffix:semicolon
id|result
op_assign
id|sddr09_send_scsi_command
c_func
(paren
id|us
comma
id|command
comma
r_sizeof
(paren
id|command
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;sddr09_test_unit_ready returns %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Request Sense Command: 12 bytes.&n; * byte 0: opcode: 03&n; * byte 4: data length&n; */
r_static
r_int
DECL|function|sddr09_request_sense
id|sddr09_request_sense
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|sensebuf
comma
r_int
id|buflen
)paren
(brace
r_int
r_char
id|command
(braket
l_int|12
)braket
op_assign
(brace
l_int|0x03
comma
id|LUNBITS
comma
l_int|0
comma
l_int|0
comma
id|buflen
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
id|result
suffix:semicolon
id|result
op_assign
id|sddr09_send_scsi_command
c_func
(paren
id|us
comma
id|command
comma
r_sizeof
(paren
id|command
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;request sense failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|result
op_assign
id|sddr09_raw_bulk
c_func
(paren
id|us
comma
id|SCSI_DATA_READ
comma
id|sensebuf
comma
id|buflen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;request sense bulk in failed&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|US_DEBUGP
c_func
(paren
l_string|&quot;request sense worked&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Read Command: 12 bytes.&n; * byte 0: opcode: E8&n; * byte 1: last two bits: 00: read data, 01: read blockwise control,&n; *&t;&t;&t;10: read both, 11: read pagewise control.&n; *&t; It turns out we need values 20, 21, 22, 23 here (LUN 1).&n; * bytes 2-5: address (interpretation depends on byte 1, see below)&n; * bytes 10-11: count (idem)&n; *&n; * A page has 512 data bytes and 64 control bytes (16 control and 48 junk).&n; * A read data command gets data in 512-byte pages.&n; * A read control command gets control in 64-byte chunks.&n; * A read both command gets data+control in 576-byte chunks.&n; *&n; * Blocks are groups of 32 pages, and read blockwise control jumps to the&n; * next block, while read pagewise control jumps to the next page after&n; * reading a group of 64 control bytes.&n; * [Here 512 = 1&lt;&lt;pageshift, 32 = 1&lt;&lt;blockshift, 64 is constant?]&n; *&n; * (1 MB and 2 MB cards are a bit different, but I have only a 16 MB card.)&n; */
r_static
r_int
DECL|function|sddr09_readX
id|sddr09_readX
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
id|x
comma
r_int
r_int
id|fromaddress
comma
r_int
id|nr_of_pages
comma
r_int
id|bulklen
comma
r_int
r_char
op_star
id|buf
comma
r_int
id|use_sg
)paren
(brace
r_int
r_char
id|command
(braket
l_int|12
)braket
op_assign
(brace
l_int|0xe8
comma
id|LUNBITS
op_or
id|x
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
id|result
suffix:semicolon
id|command
(braket
l_int|2
)braket
op_assign
id|MSB_of
c_func
(paren
id|fromaddress
op_rshift
l_int|16
)paren
suffix:semicolon
id|command
(braket
l_int|3
)braket
op_assign
id|LSB_of
c_func
(paren
id|fromaddress
op_rshift
l_int|16
)paren
suffix:semicolon
id|command
(braket
l_int|4
)braket
op_assign
id|MSB_of
c_func
(paren
id|fromaddress
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
id|command
(braket
l_int|5
)braket
op_assign
id|LSB_of
c_func
(paren
id|fromaddress
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
id|command
(braket
l_int|10
)braket
op_assign
id|MSB_of
c_func
(paren
id|nr_of_pages
)paren
suffix:semicolon
id|command
(braket
l_int|11
)braket
op_assign
id|LSB_of
c_func
(paren
id|nr_of_pages
)paren
suffix:semicolon
id|result
op_assign
id|sddr09_send_scsi_command
c_func
(paren
id|us
comma
id|command
comma
r_sizeof
(paren
id|command
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Result for send_control in sddr09_read2%d %d&bslash;n&quot;
comma
id|x
comma
id|result
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|result
op_assign
id|sddr09_bulk_transport
c_func
(paren
id|us
comma
id|SCSI_DATA_READ
comma
id|buf
comma
id|bulklen
comma
id|use_sg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;Result for bulk_transport in sddr09_read2%d %d&bslash;n&quot;
comma
id|x
comma
id|result
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Read Data&n; *&n; * fromaddress counts data shorts:&n; * increasing it by 256 shifts the bytestream by 512 bytes;&n; * the last 8 bits are ignored.&n; *&n; * nr_of_pages counts pages of size (1 &lt;&lt; pageshift).&n; */
r_static
r_int
DECL|function|sddr09_read20
id|sddr09_read20
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|fromaddress
comma
r_int
id|nr_of_pages
comma
r_int
id|pageshift
comma
r_int
r_char
op_star
id|buf
comma
r_int
id|use_sg
)paren
(brace
r_int
id|bulklen
op_assign
id|nr_of_pages
op_lshift
id|pageshift
suffix:semicolon
multiline_comment|/* The last 8 bits of fromaddress are ignored. */
r_return
id|sddr09_readX
c_func
(paren
id|us
comma
l_int|0
comma
id|fromaddress
comma
id|nr_of_pages
comma
id|bulklen
comma
id|buf
comma
id|use_sg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Read Blockwise Control&n; *&n; * fromaddress gives the starting position (as in read data;&n; * the last 8 bits are ignored); increasing it by 32*256 shifts&n; * the output stream by 64 bytes.&n; *&n; * count counts control groups of size (1 &lt;&lt; controlshift).&n; * For me, controlshift = 6. Is this constant?&n; *&n; * After getting one control group, jump to the next block&n; * (fromaddress += 8192).&n; */
r_static
r_int
DECL|function|sddr09_read21
id|sddr09_read21
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|fromaddress
comma
r_int
id|count
comma
r_int
id|controlshift
comma
r_int
r_char
op_star
id|buf
comma
r_int
id|use_sg
)paren
(brace
r_int
id|bulklen
op_assign
(paren
id|count
op_lshift
id|controlshift
)paren
suffix:semicolon
r_return
id|sddr09_readX
c_func
(paren
id|us
comma
l_int|1
comma
id|fromaddress
comma
id|count
comma
id|bulklen
comma
id|buf
comma
id|use_sg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Read both Data and Control&n; *&n; * fromaddress counts data shorts, ignoring control:&n; * increasing it by 256 shifts the bytestream by 576 = 512+64 bytes;&n; * the last 8 bits are ignored.&n; *&n; * nr_of_pages counts pages of size (1 &lt;&lt; pageshift) + (1 &lt;&lt; controlshift).&n; */
r_static
r_int
DECL|function|sddr09_read22
id|sddr09_read22
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|fromaddress
comma
r_int
id|nr_of_pages
comma
r_int
id|pageshift
comma
r_int
r_char
op_star
id|buf
comma
r_int
id|use_sg
)paren
(brace
r_int
id|bulklen
op_assign
(paren
id|nr_of_pages
op_lshift
id|pageshift
)paren
op_plus
(paren
id|nr_of_pages
op_lshift
id|CONTROL_SHIFT
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;sddr09_read22: reading %d pages, %d bytes&bslash;n&quot;
comma
id|nr_of_pages
comma
id|bulklen
)paren
suffix:semicolon
r_return
id|sddr09_readX
c_func
(paren
id|us
comma
l_int|2
comma
id|fromaddress
comma
id|nr_of_pages
comma
id|bulklen
comma
id|buf
comma
id|use_sg
)paren
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/*&n; * Read Pagewise Control&n; *&n; * fromaddress gives the starting position (as in read data;&n; * the last 8 bits are ignored); increasing it by 256 shifts&n; * the output stream by 64 bytes.&n; *&n; * count counts control groups of size (1 &lt;&lt; controlshift).&n; * For me, controlshift = 6. Is this constant?&n; *&n; * After getting one control group, jump to the next page&n; * (fromaddress += 256).&n; */
r_static
r_int
id|sddr09_read23
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|fromaddress
comma
r_int
id|count
comma
r_int
id|controlshift
comma
r_int
r_char
op_star
id|buf
comma
r_int
id|use_sg
)paren
(brace
r_int
id|bulklen
op_assign
(paren
id|count
op_lshift
id|controlshift
)paren
suffix:semicolon
r_return
id|sddr09_readX
c_func
(paren
id|us
comma
l_int|3
comma
id|fromaddress
comma
id|count
comma
id|bulklen
comma
id|buf
comma
id|use_sg
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Erase Command: 12 bytes.&n; * byte 0: opcode: EA&n; * bytes 6-9: erase address (big-endian, counting shorts, sector aligned).&n; * &n; * Always precisely one block is erased; bytes 2-5 and 10-11 are ignored.&n; * The byte address being erased is 2*Eaddress.&n; */
r_static
r_int
DECL|function|sddr09_erase
id|sddr09_erase
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|Eaddress
)paren
(brace
r_int
r_char
id|command
(braket
l_int|12
)braket
op_assign
(brace
l_int|0xea
comma
id|LUNBITS
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
id|result
suffix:semicolon
id|command
(braket
l_int|6
)braket
op_assign
id|MSB_of
c_func
(paren
id|Eaddress
op_rshift
l_int|16
)paren
suffix:semicolon
id|command
(braket
l_int|7
)braket
op_assign
id|LSB_of
c_func
(paren
id|Eaddress
op_rshift
l_int|16
)paren
suffix:semicolon
id|command
(braket
l_int|8
)braket
op_assign
id|MSB_of
c_func
(paren
id|Eaddress
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
id|command
(braket
l_int|9
)braket
op_assign
id|LSB_of
c_func
(paren
id|Eaddress
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
id|result
op_assign
id|sddr09_send_scsi_command
c_func
(paren
id|us
comma
id|command
comma
r_sizeof
(paren
id|command
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;Result for send_control in sddr09_erase %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Write Command: 12 bytes.&n; * byte 0: opcode: E9&n; * bytes 2-5: write address (big-endian, counting shorts, sector aligned).&n; * bytes 6-9: erase address (big-endian, counting shorts, sector aligned).&n; * bytes 10-11: sector count (big-endian, in 512-byte sectors).&n; *&n; * If write address equals erase address, the erase is done first,&n; * otherwise the write is done first. When erase address equals zero&n; * no erase is done?&n; */
r_static
r_int
DECL|function|sddr09_writeX
id|sddr09_writeX
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|Waddress
comma
r_int
r_int
id|Eaddress
comma
r_int
id|nr_of_pages
comma
r_int
id|bulklen
comma
r_int
r_char
op_star
id|buf
comma
r_int
id|use_sg
)paren
(brace
r_int
r_char
id|command
(braket
l_int|12
)braket
op_assign
(brace
l_int|0xe9
comma
id|LUNBITS
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
id|result
suffix:semicolon
id|command
(braket
l_int|2
)braket
op_assign
id|MSB_of
c_func
(paren
id|Waddress
op_rshift
l_int|16
)paren
suffix:semicolon
id|command
(braket
l_int|3
)braket
op_assign
id|LSB_of
c_func
(paren
id|Waddress
op_rshift
l_int|16
)paren
suffix:semicolon
id|command
(braket
l_int|4
)braket
op_assign
id|MSB_of
c_func
(paren
id|Waddress
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
id|command
(braket
l_int|5
)braket
op_assign
id|LSB_of
c_func
(paren
id|Waddress
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
id|command
(braket
l_int|6
)braket
op_assign
id|MSB_of
c_func
(paren
id|Eaddress
op_rshift
l_int|16
)paren
suffix:semicolon
id|command
(braket
l_int|7
)braket
op_assign
id|LSB_of
c_func
(paren
id|Eaddress
op_rshift
l_int|16
)paren
suffix:semicolon
id|command
(braket
l_int|8
)braket
op_assign
id|MSB_of
c_func
(paren
id|Eaddress
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
id|command
(braket
l_int|9
)braket
op_assign
id|LSB_of
c_func
(paren
id|Eaddress
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
id|command
(braket
l_int|10
)braket
op_assign
id|MSB_of
c_func
(paren
id|nr_of_pages
)paren
suffix:semicolon
id|command
(braket
l_int|11
)braket
op_assign
id|LSB_of
c_func
(paren
id|nr_of_pages
)paren
suffix:semicolon
id|result
op_assign
id|sddr09_send_scsi_command
c_func
(paren
id|us
comma
id|command
comma
r_sizeof
(paren
id|command
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Result for send_control in sddr09_writeX %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|result
op_assign
id|sddr09_bulk_transport
c_func
(paren
id|us
comma
id|SCSI_DATA_WRITE
comma
id|buf
comma
id|bulklen
comma
id|use_sg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;Result for bulk_transport in sddr09_writeX %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/* erase address, write same address */
r_static
r_int
DECL|function|sddr09_write_inplace
id|sddr09_write_inplace
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|address
comma
r_int
id|nr_of_pages
comma
r_int
id|pageshift
comma
r_int
r_char
op_star
id|buf
comma
r_int
id|use_sg
)paren
(brace
r_int
id|bulklen
op_assign
(paren
id|nr_of_pages
op_lshift
id|pageshift
)paren
op_plus
(paren
id|nr_of_pages
op_lshift
id|CONTROL_SHIFT
)paren
suffix:semicolon
r_return
id|sddr09_writeX
c_func
(paren
id|us
comma
id|address
comma
id|address
comma
id|nr_of_pages
comma
id|bulklen
comma
id|buf
comma
id|use_sg
)paren
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/*&n; * Read Scatter Gather Command: 3+4n bytes.&n; * byte 0: opcode E7&n; * byte 2: n&n; * bytes 4i-1,4i,4i+1: page address&n; * byte 4i+2: page count&n; * (i=1..n)&n; *&n; * This reads several pages from the card to a single memory buffer.&n; * The last two bits of byte 1 have the same meaning as for E8.&n; */
r_static
r_int
id|sddr09_read_sg_test_only
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
r_char
id|command
(braket
l_int|15
)braket
op_assign
(brace
l_int|0xe7
comma
id|LUNBITS
comma
l_int|0
)brace
suffix:semicolon
r_int
id|result
comma
id|bulklen
comma
id|nsg
comma
id|ct
suffix:semicolon
r_int
r_char
op_star
id|buf
suffix:semicolon
r_int
r_int
id|address
suffix:semicolon
id|nsg
op_assign
id|bulklen
op_assign
l_int|0
suffix:semicolon
id|address
op_assign
l_int|040000
suffix:semicolon
id|ct
op_assign
l_int|1
suffix:semicolon
id|nsg
op_increment
suffix:semicolon
id|bulklen
op_add_assign
(paren
id|ct
op_lshift
l_int|9
)paren
suffix:semicolon
id|command
(braket
l_int|4
op_star
id|nsg
op_plus
l_int|2
)braket
op_assign
id|ct
suffix:semicolon
id|command
(braket
l_int|4
op_star
id|nsg
op_plus
l_int|1
)braket
op_assign
(paren
(paren
id|address
op_rshift
l_int|9
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|command
(braket
l_int|4
op_star
id|nsg
op_plus
l_int|0
)braket
op_assign
(paren
(paren
id|address
op_rshift
l_int|17
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|command
(braket
l_int|4
op_star
id|nsg
op_minus
l_int|1
)braket
op_assign
(paren
(paren
id|address
op_rshift
l_int|25
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|address
op_assign
l_int|0340000
suffix:semicolon
id|ct
op_assign
l_int|1
suffix:semicolon
id|nsg
op_increment
suffix:semicolon
id|bulklen
op_add_assign
(paren
id|ct
op_lshift
l_int|9
)paren
suffix:semicolon
id|command
(braket
l_int|4
op_star
id|nsg
op_plus
l_int|2
)braket
op_assign
id|ct
suffix:semicolon
id|command
(braket
l_int|4
op_star
id|nsg
op_plus
l_int|1
)braket
op_assign
(paren
(paren
id|address
op_rshift
l_int|9
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|command
(braket
l_int|4
op_star
id|nsg
op_plus
l_int|0
)braket
op_assign
(paren
(paren
id|address
op_rshift
l_int|17
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|command
(braket
l_int|4
op_star
id|nsg
op_minus
l_int|1
)braket
op_assign
(paren
(paren
id|address
op_rshift
l_int|25
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|address
op_assign
l_int|01000000
suffix:semicolon
id|ct
op_assign
l_int|2
suffix:semicolon
id|nsg
op_increment
suffix:semicolon
id|bulklen
op_add_assign
(paren
id|ct
op_lshift
l_int|9
)paren
suffix:semicolon
id|command
(braket
l_int|4
op_star
id|nsg
op_plus
l_int|2
)braket
op_assign
id|ct
suffix:semicolon
id|command
(braket
l_int|4
op_star
id|nsg
op_plus
l_int|1
)braket
op_assign
(paren
(paren
id|address
op_rshift
l_int|9
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|command
(braket
l_int|4
op_star
id|nsg
op_plus
l_int|0
)braket
op_assign
(paren
(paren
id|address
op_rshift
l_int|17
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|command
(braket
l_int|4
op_star
id|nsg
op_minus
l_int|1
)braket
op_assign
(paren
(paren
id|address
op_rshift
l_int|25
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|command
(braket
l_int|2
)braket
op_assign
id|nsg
suffix:semicolon
id|result
op_assign
id|sddr09_send_scsi_command
c_func
(paren
id|us
comma
id|command
comma
l_int|4
op_star
id|nsg
op_plus
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Result for send_control in sddr09_read_sg %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|buf
op_assign
(paren
r_int
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|bulklen
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|result
op_assign
id|sddr09_bulk_transport
c_func
(paren
id|us
comma
id|SCSI_DATA_READ
comma
id|buf
comma
id|bulklen
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;Result for bulk_transport in sddr09_read_sg %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Read Status Command: 12 bytes.&n; * byte 0: opcode: EC&n; *&n; * Returns 64 bytes, all zero except for the first.&n; * bit 0: 1: Error&n; * bit 5: 1: Suspended&n; * bit 6: 1: Ready&n; * bit 7: 1: Not write-protected&n; */
r_static
r_int
DECL|function|sddr09_read_status
id|sddr09_read_status
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|status
)paren
(brace
r_int
r_char
id|command
(braket
l_int|12
)braket
op_assign
(brace
l_int|0xec
comma
id|LUNBITS
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|data
(braket
l_int|64
)braket
suffix:semicolon
r_int
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Reading status...&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|sddr09_send_scsi_command
c_func
(paren
id|us
comma
id|command
comma
r_sizeof
(paren
id|command
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
id|result
op_assign
id|sddr09_bulk_transport
c_func
(paren
id|us
comma
id|SCSI_DATA_READ
comma
id|data
comma
r_sizeof
(paren
id|data
)paren
comma
l_int|0
)paren
suffix:semicolon
op_star
id|status
op_assign
id|data
(braket
l_int|0
)braket
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_static
r_int
DECL|function|sddr09_read_data
id|sddr09_read_data
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|address
comma
r_int
r_int
id|sectors
comma
r_int
r_char
op_star
id|content
comma
r_int
id|use_sg
)paren
(brace
r_struct
id|sddr09_card_info
op_star
id|info
op_assign
(paren
r_struct
id|sddr09_card_info
op_star
)paren
id|us-&gt;extra
suffix:semicolon
r_int
r_int
id|lba
comma
id|maxlba
comma
id|pba
suffix:semicolon
r_int
r_int
id|page
comma
id|pages
suffix:semicolon
r_int
r_char
op_star
id|buffer
op_assign
l_int|NULL
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
op_assign
l_int|NULL
suffix:semicolon
r_int
id|result
comma
id|i
comma
id|len
suffix:semicolon
singleline_comment|// If we&squot;re using scatter-gather, we have to create a new
singleline_comment|// buffer to read all of the data in first, since a
singleline_comment|// scatter-gather buffer could in theory start in the middle
singleline_comment|// of a page, which would be bad. A developer who wants a
singleline_comment|// challenge might want to write a limited-buffer
singleline_comment|// version of this code.
id|len
op_assign
id|sectors
op_star
id|info-&gt;pagesize
suffix:semicolon
r_if
c_cond
(paren
id|use_sg
)paren
(brace
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|content
suffix:semicolon
id|buffer
op_assign
id|kmalloc
c_func
(paren
id|len
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
op_eq
l_int|NULL
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|ptr
op_assign
id|buffer
suffix:semicolon
)brace
r_else
id|ptr
op_assign
id|content
suffix:semicolon
singleline_comment|// Figure out the initial LBA and page
id|lba
op_assign
id|address
op_rshift
id|info-&gt;blockshift
suffix:semicolon
id|page
op_assign
(paren
id|address
op_amp
id|info-&gt;blockmask
)paren
suffix:semicolon
id|maxlba
op_assign
id|info-&gt;capacity
op_rshift
(paren
id|info-&gt;pageshift
op_plus
id|info-&gt;blockshift
)paren
suffix:semicolon
singleline_comment|// This could be made much more efficient by checking for
singleline_comment|// contiguous LBA&squot;s. Another exercise left to the student.
id|result
op_assign
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
r_while
c_loop
(paren
id|sectors
OG
l_int|0
)paren
(brace
multiline_comment|/* Find number of pages we can read in this block */
id|pages
op_assign
id|info-&gt;blocksize
op_minus
id|page
suffix:semicolon
r_if
c_cond
(paren
id|pages
OG
id|sectors
)paren
id|pages
op_assign
id|sectors
suffix:semicolon
multiline_comment|/* Not overflowing capacity? */
r_if
c_cond
(paren
id|lba
op_ge
id|maxlba
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Error: Requested lba %u exceeds &quot;
l_string|&quot;maximum %u&bslash;n&quot;
comma
id|lba
comma
id|maxlba
)paren
suffix:semicolon
id|result
op_assign
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Find where this lba lives on disk */
id|pba
op_assign
id|info-&gt;lba_to_pba
(braket
id|lba
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pba
op_eq
id|UNDEF
)paren
(brace
multiline_comment|/* this lba was never written */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Read %d zero pages (LBA %d) page %d&bslash;n&quot;
comma
id|pages
comma
id|lba
comma
id|page
)paren
suffix:semicolon
multiline_comment|/* This is not really an error. It just means&n;&t;&t;&t;   that the block has never been written.&n;&t;&t;&t;   Instead of returning USB_STOR_TRANSPORT_ERROR&n;&t;&t;&t;   it is better to return all zero data. */
id|memset
c_func
(paren
id|ptr
comma
l_int|0
comma
id|pages
op_lshift
id|info-&gt;pageshift
)paren
suffix:semicolon
)brace
r_else
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Read %d pages, from PBA %d&quot;
l_string|&quot; (LBA %d) page %d&bslash;n&quot;
comma
id|pages
comma
id|pba
comma
id|lba
comma
id|page
)paren
suffix:semicolon
id|address
op_assign
(paren
(paren
id|pba
op_lshift
id|info-&gt;blockshift
)paren
op_plus
id|page
)paren
op_lshift
id|info-&gt;pageshift
suffix:semicolon
id|result
op_assign
id|sddr09_read20
c_func
(paren
id|us
comma
id|address
op_rshift
l_int|1
comma
id|pages
comma
id|info-&gt;pageshift
comma
id|ptr
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_break
suffix:semicolon
)brace
id|page
op_assign
l_int|0
suffix:semicolon
id|lba
op_increment
suffix:semicolon
id|sectors
op_sub_assign
id|pages
suffix:semicolon
id|ptr
op_add_assign
(paren
id|pages
op_lshift
id|info-&gt;pageshift
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|use_sg
op_logical_and
id|result
op_eq
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
r_int
id|transferred
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|use_sg
op_logical_and
id|transferred
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_char
op_star
id|buf
suffix:semicolon
r_int
r_int
id|length
suffix:semicolon
id|buf
op_assign
id|page_address
c_func
(paren
id|sg
(braket
id|i
)braket
dot
id|page
)paren
op_plus
id|sg
(braket
id|i
)braket
dot
id|offset
suffix:semicolon
id|length
op_assign
id|len
op_minus
id|transferred
suffix:semicolon
r_if
c_cond
(paren
id|length
OG
id|sg
(braket
id|i
)braket
dot
id|length
)paren
id|length
op_assign
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
id|memcpy
c_func
(paren
id|buf
comma
id|buffer
op_plus
id|transferred
comma
id|length
)paren
suffix:semicolon
id|transferred
op_add_assign
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|use_sg
)paren
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/* we never free blocks, so lastpba can only increase */
r_static
r_int
r_int
DECL|function|sddr09_find_unused_pba
id|sddr09_find_unused_pba
c_func
(paren
r_struct
id|sddr09_card_info
op_star
id|info
)paren
(brace
r_static
r_int
r_int
id|lastpba
op_assign
l_int|1
suffix:semicolon
r_int
id|numblocks
op_assign
id|info-&gt;capacity
op_rshift
(paren
id|info-&gt;blockshift
op_plus
id|info-&gt;pageshift
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|lastpba
op_plus
l_int|1
suffix:semicolon
id|i
OL
id|numblocks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;pba_to_lba
(braket
id|i
)braket
op_eq
id|UNDEF
)paren
(brace
id|lastpba
op_assign
id|i
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|sddr09_write_lba
id|sddr09_write_lba
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|lba
comma
r_int
r_int
id|page
comma
r_int
r_int
id|pages
comma
r_int
r_char
op_star
id|ptr
)paren
(brace
r_struct
id|sddr09_card_info
op_star
id|info
op_assign
(paren
r_struct
id|sddr09_card_info
op_star
)paren
id|us-&gt;extra
suffix:semicolon
r_int
r_int
id|address
suffix:semicolon
r_int
r_int
id|pba
comma
id|lbap
suffix:semicolon
r_int
r_int
id|pagelen
comma
id|blocklen
suffix:semicolon
r_int
r_char
op_star
id|blockbuffer
comma
op_star
id|bptr
comma
op_star
id|cptr
comma
op_star
id|xptr
suffix:semicolon
r_int
r_char
id|ecc
(braket
l_int|3
)braket
suffix:semicolon
r_int
id|i
comma
id|result
suffix:semicolon
id|lbap
op_assign
(paren
(paren
id|lba
op_amp
l_int|0x3ff
)paren
op_lshift
l_int|1
)paren
op_or
l_int|0x1000
suffix:semicolon
r_if
c_cond
(paren
id|parity
(braket
id|MSB_of
c_func
(paren
id|lbap
)paren
op_xor
id|LSB_of
c_func
(paren
id|lbap
)paren
)braket
)paren
id|lbap
op_xor_assign
l_int|1
suffix:semicolon
id|pba
op_assign
id|info-&gt;lba_to_pba
(braket
id|lba
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pba
op_eq
id|UNDEF
)paren
(brace
id|pba
op_assign
id|sddr09_find_unused_pba
c_func
(paren
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pba
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sddr09_write_lba: Out of unused blocks&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
id|info-&gt;pba_to_lba
(braket
id|pba
)braket
op_assign
id|lba
suffix:semicolon
id|info-&gt;lba_to_pba
(braket
id|lba
)braket
op_assign
id|pba
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pba
op_eq
l_int|1
)paren
(brace
multiline_comment|/* Maybe it is impossible to write to PBA 1.&n;&t;&t;   Fake success, but don&squot;t do anything. */
id|printk
c_func
(paren
l_string|&quot;sddr09: avoid writing to pba 1&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
id|pagelen
op_assign
(paren
l_int|1
op_lshift
id|info-&gt;pageshift
)paren
op_plus
(paren
l_int|1
op_lshift
id|CONTROL_SHIFT
)paren
suffix:semicolon
id|blocklen
op_assign
(paren
id|pagelen
op_lshift
id|info-&gt;blockshift
)paren
suffix:semicolon
id|blockbuffer
op_assign
id|kmalloc
c_func
(paren
id|blocklen
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|blockbuffer
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sddr09_write_lba: Out of memory&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/* read old contents */
id|address
op_assign
(paren
id|pba
op_lshift
(paren
id|info-&gt;pageshift
op_plus
id|info-&gt;blockshift
)paren
)paren
suffix:semicolon
id|result
op_assign
id|sddr09_read22
c_func
(paren
id|us
comma
id|address
op_rshift
l_int|1
comma
id|info-&gt;blocksize
comma
id|info-&gt;pageshift
comma
id|blockbuffer
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_goto
id|err
suffix:semicolon
multiline_comment|/* check old contents */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|info-&gt;blockshift
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bptr
op_assign
id|blockbuffer
op_plus
id|i
op_star
id|pagelen
suffix:semicolon
id|cptr
op_assign
id|bptr
op_plus
id|info-&gt;pagesize
suffix:semicolon
id|nand_compute_ecc
c_func
(paren
id|bptr
comma
id|ecc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nand_compare_ecc
c_func
(paren
id|cptr
op_plus
l_int|13
comma
id|ecc
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Warning: bad ecc in page %d- of pba %d&bslash;n&quot;
comma
id|i
comma
id|pba
)paren
suffix:semicolon
id|nand_store_ecc
c_func
(paren
id|cptr
op_plus
l_int|13
comma
id|ecc
)paren
suffix:semicolon
)brace
id|nand_compute_ecc
c_func
(paren
id|bptr
op_plus
(paren
id|info-&gt;pagesize
op_div
l_int|2
)paren
comma
id|ecc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nand_compare_ecc
c_func
(paren
id|cptr
op_plus
l_int|8
comma
id|ecc
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Warning: bad ecc in page %d+ of pba %d&bslash;n&quot;
comma
id|i
comma
id|pba
)paren
suffix:semicolon
id|nand_store_ecc
c_func
(paren
id|cptr
op_plus
l_int|8
comma
id|ecc
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* copy in new stuff and compute ECC */
id|xptr
op_assign
id|ptr
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|page
suffix:semicolon
id|i
OL
id|page
op_plus
id|pages
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bptr
op_assign
id|blockbuffer
op_plus
id|i
op_star
id|pagelen
suffix:semicolon
id|cptr
op_assign
id|bptr
op_plus
id|info-&gt;pagesize
suffix:semicolon
id|memcpy
c_func
(paren
id|bptr
comma
id|xptr
comma
id|info-&gt;pagesize
)paren
suffix:semicolon
id|xptr
op_add_assign
id|info-&gt;pagesize
suffix:semicolon
id|nand_compute_ecc
c_func
(paren
id|bptr
comma
id|ecc
)paren
suffix:semicolon
id|nand_store_ecc
c_func
(paren
id|cptr
op_plus
l_int|13
comma
id|ecc
)paren
suffix:semicolon
id|nand_compute_ecc
c_func
(paren
id|bptr
op_plus
(paren
id|info-&gt;pagesize
op_div
l_int|2
)paren
comma
id|ecc
)paren
suffix:semicolon
id|nand_store_ecc
c_func
(paren
id|cptr
op_plus
l_int|8
comma
id|ecc
)paren
suffix:semicolon
id|cptr
(braket
l_int|6
)braket
op_assign
id|cptr
(braket
l_int|11
)braket
op_assign
id|MSB_of
c_func
(paren
id|lbap
)paren
suffix:semicolon
id|cptr
(braket
l_int|7
)braket
op_assign
id|cptr
(braket
l_int|12
)braket
op_assign
id|LSB_of
c_func
(paren
id|lbap
)paren
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Rewrite PBA %d (LBA %d)&bslash;n&quot;
comma
id|pba
comma
id|lba
)paren
suffix:semicolon
id|result
op_assign
id|sddr09_write_inplace
c_func
(paren
id|us
comma
id|address
op_rshift
l_int|1
comma
id|info-&gt;blocksize
comma
id|info-&gt;pageshift
comma
id|blockbuffer
comma
l_int|0
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;sddr09_write_inplace returns %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
macro_line|#if 0
(brace
r_int
r_char
id|status
op_assign
l_int|0
suffix:semicolon
r_int
id|result2
op_assign
id|sddr09_read_status
c_func
(paren
id|us
comma
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result2
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;sddr09_write_inplace: cannot read status&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|status
op_ne
l_int|0xc0
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;sddr09_write_inplace: status after write: 0x%x&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if 0
(brace
r_int
id|result2
op_assign
id|sddr09_test_unit_ready
c_func
(paren
id|us
)paren
suffix:semicolon
)brace
macro_line|#endif
id|err
suffix:colon
id|kfree
c_func
(paren
id|blockbuffer
)paren
suffix:semicolon
multiline_comment|/* TODO: instead of doing kmalloc/kfree for each block,&n;&t;   add a bufferpointer to the info structure */
r_return
id|result
suffix:semicolon
)brace
r_static
r_int
DECL|function|sddr09_write_data
id|sddr09_write_data
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|address
comma
r_int
r_int
id|sectors
comma
r_int
r_char
op_star
id|content
comma
r_int
id|use_sg
)paren
(brace
r_struct
id|sddr09_card_info
op_star
id|info
op_assign
(paren
r_struct
id|sddr09_card_info
op_star
)paren
id|us-&gt;extra
suffix:semicolon
r_int
r_int
id|lba
comma
id|page
comma
id|pages
suffix:semicolon
r_int
r_char
op_star
id|buffer
op_assign
l_int|NULL
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
op_assign
l_int|NULL
suffix:semicolon
r_int
id|result
comma
id|i
comma
id|len
suffix:semicolon
singleline_comment|// If we&squot;re using scatter-gather, we have to create a new
singleline_comment|// buffer to write all of the data in first, since a
singleline_comment|// scatter-gather buffer could in theory start in the middle
singleline_comment|// of a page, which would be bad. A developer who wants a
singleline_comment|// challenge might want to write a limited-buffer
singleline_comment|// version of this code.
id|len
op_assign
id|sectors
op_star
id|info-&gt;pagesize
suffix:semicolon
r_if
c_cond
(paren
id|use_sg
)paren
(brace
r_int
id|transferred
op_assign
l_int|0
suffix:semicolon
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|content
suffix:semicolon
id|buffer
op_assign
id|kmalloc
c_func
(paren
id|len
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
op_eq
l_int|NULL
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|use_sg
op_logical_and
id|transferred
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_char
op_star
id|buf
suffix:semicolon
r_int
r_int
id|length
suffix:semicolon
id|buf
op_assign
id|page_address
c_func
(paren
id|sg
(braket
id|i
)braket
dot
id|page
)paren
op_plus
id|sg
(braket
id|i
)braket
dot
id|offset
suffix:semicolon
id|length
op_assign
id|len
op_minus
id|transferred
suffix:semicolon
r_if
c_cond
(paren
id|length
OG
id|sg
(braket
id|i
)braket
dot
id|length
)paren
id|length
op_assign
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
id|memcpy
c_func
(paren
id|buffer
op_plus
id|transferred
comma
id|buf
comma
id|length
)paren
suffix:semicolon
id|transferred
op_add_assign
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
)brace
id|ptr
op_assign
id|buffer
suffix:semicolon
)brace
r_else
id|ptr
op_assign
id|content
suffix:semicolon
singleline_comment|// Figure out the initial LBA and page
id|lba
op_assign
id|address
op_rshift
id|info-&gt;blockshift
suffix:semicolon
id|page
op_assign
(paren
id|address
op_amp
id|info-&gt;blockmask
)paren
suffix:semicolon
singleline_comment|// This could be made much more efficient by checking for
singleline_comment|// contiguous LBA&squot;s. Another exercise left to the student.
id|result
op_assign
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
r_while
c_loop
(paren
id|sectors
OG
l_int|0
)paren
(brace
singleline_comment|// Write as many sectors as possible in this block
id|pages
op_assign
id|info-&gt;blocksize
op_minus
id|page
suffix:semicolon
r_if
c_cond
(paren
id|pages
OG
id|sectors
)paren
id|pages
op_assign
id|sectors
suffix:semicolon
id|result
op_assign
id|sddr09_write_lba
c_func
(paren
id|us
comma
id|lba
comma
id|page
comma
id|pages
comma
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_break
suffix:semicolon
id|page
op_assign
l_int|0
suffix:semicolon
id|lba
op_increment
suffix:semicolon
id|sectors
op_sub_assign
id|pages
suffix:semicolon
id|ptr
op_add_assign
(paren
id|pages
op_lshift
id|info-&gt;pageshift
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|use_sg
)paren
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_static
r_int
DECL|function|sddr09_read_control
id|sddr09_read_control
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|address
comma
r_int
r_int
id|blocks
comma
r_int
r_char
op_star
id|content
comma
r_int
id|use_sg
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Read control address %08lX blocks %04X&bslash;n&quot;
comma
id|address
comma
id|blocks
)paren
suffix:semicolon
r_return
id|sddr09_read21
c_func
(paren
id|us
comma
id|address
comma
id|blocks
comma
id|CONTROL_SHIFT
comma
id|content
comma
id|use_sg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Read Device ID Command: 12 bytes.&n; * byte 0: opcode: ED&n; *&n; * Returns 2 bytes: Manufacturer ID and Device ID.&n; * On more recent cards 3 bytes: the third byte is an option code A5&n; * signifying that the secret command to read an 128-bit ID is available.&n; * On still more recent cards 4 bytes: the fourth byte C0 means that&n; * a second read ID cmd is available.&n; */
r_static
r_int
DECL|function|sddr09_read_deviceID
id|sddr09_read_deviceID
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|deviceID
)paren
(brace
r_int
r_char
id|command
(braket
l_int|12
)braket
op_assign
(brace
l_int|0xed
comma
id|LUNBITS
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|content
(braket
l_int|64
)braket
suffix:semicolon
r_int
id|result
comma
id|i
suffix:semicolon
id|result
op_assign
id|sddr09_send_scsi_command
c_func
(paren
id|us
comma
id|command
comma
r_sizeof
(paren
id|command
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
id|result
op_assign
id|sddr09_bulk_transport
c_func
(paren
id|us
comma
id|SCSI_DATA_READ
comma
id|content
comma
l_int|64
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
id|deviceID
(braket
id|i
)braket
op_assign
id|content
(braket
id|i
)braket
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_static
r_int
DECL|function|sddr09_get_wp
id|sddr09_get_wp
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_struct
id|sddr09_card_info
op_star
id|info
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
id|result
op_assign
id|sddr09_read_status
c_func
(paren
id|us
comma
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;sddr09_get_wp: read_status fails&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;sddr09_get_wp: status %02X&quot;
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
l_int|0x80
)paren
op_eq
l_int|0
)paren
(brace
id|info-&gt;flags
op_or_assign
id|SDDR09_WP
suffix:semicolon
multiline_comment|/* write protected */
id|US_DEBUGP
c_func
(paren
l_string|&quot; WP&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
l_int|0x40
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot; Ready&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|LUNBITS
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot; Suspended&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x1
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot; Error&quot;
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/*&n; * Reset Command: 12 bytes.&n; * byte 0: opcode: EB&n; */
r_static
r_int
id|sddr09_reset
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
r_char
id|command
(braket
l_int|12
)braket
op_assign
(brace
l_int|0xeb
comma
id|LUNBITS
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_return
id|sddr09_send_scsi_command
c_func
(paren
id|us
comma
id|command
comma
r_sizeof
(paren
id|command
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
r_static
r_struct
id|nand_flash_dev
op_star
DECL|function|sddr09_get_cardinfo
id|sddr09_get_cardinfo
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
id|flags
)paren
(brace
r_struct
id|nand_flash_dev
op_star
id|cardinfo
suffix:semicolon
r_int
r_char
id|deviceID
(braket
l_int|4
)braket
suffix:semicolon
r_char
id|blurbtxt
(braket
l_int|256
)braket
suffix:semicolon
r_int
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Reading capacity...&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|sddr09_read_deviceID
c_func
(paren
id|us
comma
id|deviceID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Result of read_deviceID is %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sddr09: could not read card info&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|blurbtxt
comma
l_string|&quot;sddr09: Found Flash card, ID = %02X %02X %02X %02X&quot;
comma
id|deviceID
(braket
l_int|0
)braket
comma
id|deviceID
(braket
l_int|1
)braket
comma
id|deviceID
(braket
l_int|2
)braket
comma
id|deviceID
(braket
l_int|3
)braket
)paren
suffix:semicolon
multiline_comment|/* Byte 0 is the manufacturer */
id|sprintf
c_func
(paren
id|blurbtxt
op_plus
id|strlen
c_func
(paren
id|blurbtxt
)paren
comma
l_string|&quot;: Manuf. %s&quot;
comma
id|nand_flash_manufacturer
c_func
(paren
id|deviceID
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
multiline_comment|/* Byte 1 is the device type */
id|cardinfo
op_assign
id|nand_find_id
c_func
(paren
id|deviceID
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cardinfo
)paren
(brace
multiline_comment|/* MB or MiB? It is neither. A 16 MB card has&n;&t;&t;   17301504 raw bytes, of which 16384000 are&n;&t;&t;   usable for user data. */
id|sprintf
c_func
(paren
id|blurbtxt
op_plus
id|strlen
c_func
(paren
id|blurbtxt
)paren
comma
l_string|&quot;, %d MB&quot;
comma
l_int|1
op_lshift
(paren
id|cardinfo-&gt;chipshift
op_minus
l_int|20
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|sprintf
c_func
(paren
id|blurbtxt
op_plus
id|strlen
c_func
(paren
id|blurbtxt
)paren
comma
l_string|&quot;, type unrecognized&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Byte 2 is code to signal availability of 128-bit ID */
r_if
c_cond
(paren
id|deviceID
(braket
l_int|2
)braket
op_eq
l_int|0xa5
)paren
(brace
id|sprintf
c_func
(paren
id|blurbtxt
op_plus
id|strlen
c_func
(paren
id|blurbtxt
)paren
comma
l_string|&quot;, 128-bit ID&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Byte 3 announces the availability of another read ID command */
r_if
c_cond
(paren
id|deviceID
(braket
l_int|3
)braket
op_eq
l_int|0xc0
)paren
(brace
id|sprintf
c_func
(paren
id|blurbtxt
op_plus
id|strlen
c_func
(paren
id|blurbtxt
)paren
comma
l_string|&quot;, extra cmd&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|SDDR09_WP
)paren
id|sprintf
c_func
(paren
id|blurbtxt
op_plus
id|strlen
c_func
(paren
id|blurbtxt
)paren
comma
l_string|&quot;, WP&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|blurbtxt
)paren
suffix:semicolon
r_return
id|cardinfo
suffix:semicolon
)brace
r_static
r_int
DECL|function|sddr09_read_map
id|sddr09_read_map
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
r_struct
id|sddr09_card_info
op_star
id|info
op_assign
(paren
r_struct
id|sddr09_card_info
op_star
)paren
id|us-&gt;extra
suffix:semicolon
r_int
id|numblocks
comma
id|alloc_len
comma
id|alloc_blocks
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|result
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_int
r_int
id|lba
comma
id|lbact
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;capacity
)paren
r_return
op_minus
l_int|1
suffix:semicolon
singleline_comment|// read 64 (1&lt;&lt;6) bytes for every block 
singleline_comment|// ( 1 &lt;&lt; ( blockshift + pageshift ) bytes)
singleline_comment|//&t; of capacity:
singleline_comment|// (1&lt;&lt;6)*capacity/(1&lt;&lt;(b+p)) =
singleline_comment|// ((1&lt;&lt;6)*capacity)&gt;&gt;(b+p) =
singleline_comment|// capacity&gt;&gt;(b+p-6)
id|alloc_len
op_assign
id|info-&gt;capacity
op_rshift
(paren
id|info-&gt;blockshift
op_plus
id|info-&gt;pageshift
op_minus
id|CONTROL_SHIFT
)paren
suffix:semicolon
singleline_comment|// Allocate a number of scatterlist structures according to
singleline_comment|// the number of 128k blocks in the alloc_len. Adding 128k-1
singleline_comment|// and then dividing by 128k gives the correct number of blocks.
singleline_comment|// 128k = 1&lt;&lt;17
id|alloc_blocks
op_assign
(paren
id|alloc_len
op_plus
(paren
l_int|1
op_lshift
l_int|17
)paren
op_minus
l_int|1
)paren
op_rshift
l_int|17
suffix:semicolon
id|sg
op_assign
id|kmalloc
c_func
(paren
id|alloc_blocks
op_star
r_sizeof
(paren
r_struct
id|scatterlist
)paren
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sg
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|alloc_blocks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
OL
id|alloc_blocks
op_minus
l_int|1
)paren
(brace
r_char
op_star
id|vaddr
op_assign
id|kmalloc
c_func
(paren
l_int|1
op_lshift
l_int|17
comma
id|GFP_NOIO
)paren
suffix:semicolon
id|sg
(braket
id|i
)braket
dot
id|page
op_assign
id|virt_to_page
c_func
(paren
id|vaddr
)paren
suffix:semicolon
id|sg
(braket
id|i
)braket
dot
id|offset
op_assign
(paren
(paren
r_int
r_int
)paren
id|vaddr
op_amp
op_complement
id|PAGE_MASK
)paren
suffix:semicolon
id|sg
(braket
id|i
)braket
dot
id|length
op_assign
(paren
l_int|1
op_lshift
l_int|17
)paren
suffix:semicolon
)brace
r_else
(brace
r_char
op_star
id|vaddr
op_assign
id|kmalloc
c_func
(paren
id|alloc_len
comma
id|GFP_NOIO
)paren
suffix:semicolon
id|sg
(braket
id|i
)braket
dot
id|page
op_assign
id|virt_to_page
c_func
(paren
id|vaddr
)paren
suffix:semicolon
id|sg
(braket
id|i
)braket
dot
id|offset
op_assign
(paren
(paren
r_int
r_int
)paren
id|vaddr
op_amp
op_complement
id|PAGE_MASK
)paren
suffix:semicolon
id|sg
(braket
id|i
)braket
dot
id|length
op_assign
id|alloc_len
suffix:semicolon
)brace
id|alloc_len
op_sub_assign
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|alloc_blocks
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|sg
(braket
id|i
)braket
dot
id|page
op_eq
l_int|NULL
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|alloc_blocks
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|sg
(braket
id|i
)braket
dot
id|page
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|page_address
c_func
(paren
id|sg
(braket
id|i
)braket
dot
id|page
)paren
op_plus
id|sg
(braket
id|i
)braket
dot
id|offset
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|numblocks
op_assign
id|info-&gt;capacity
op_rshift
(paren
id|info-&gt;blockshift
op_plus
id|info-&gt;pageshift
)paren
suffix:semicolon
id|result
op_assign
id|sddr09_read_control
c_func
(paren
id|us
comma
l_int|0
comma
id|numblocks
comma
(paren
r_int
r_char
op_star
)paren
id|sg
comma
id|alloc_blocks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|alloc_blocks
suffix:semicolon
id|i
op_increment
)paren
id|kfree
c_func
(paren
id|page_address
c_func
(paren
id|sg
(braket
id|i
)braket
dot
id|page
)paren
op_plus
id|sg
(braket
id|i
)braket
dot
id|offset
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sg
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|info-&gt;lba_to_pba
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|info-&gt;pba_to_lba
)paren
suffix:semicolon
id|info-&gt;lba_to_pba
op_assign
id|kmalloc
c_func
(paren
id|numblocks
op_star
r_sizeof
(paren
r_int
)paren
comma
id|GFP_NOIO
)paren
suffix:semicolon
id|info-&gt;pba_to_lba
op_assign
id|kmalloc
c_func
(paren
id|numblocks
op_star
r_sizeof
(paren
r_int
)paren
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;lba_to_pba
op_eq
l_int|NULL
op_logical_or
id|info-&gt;pba_to_lba
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|info-&gt;lba_to_pba
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|info-&gt;pba_to_lba
)paren
suffix:semicolon
id|info-&gt;lba_to_pba
op_assign
l_int|NULL
suffix:semicolon
id|info-&gt;pba_to_lba
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|alloc_blocks
suffix:semicolon
id|i
op_increment
)paren
id|kfree
c_func
(paren
id|page_address
c_func
(paren
id|sg
(braket
id|i
)braket
dot
id|page
)paren
op_plus
id|sg
(braket
id|i
)braket
dot
id|offset
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numblocks
suffix:semicolon
id|i
op_increment
)paren
id|info-&gt;lba_to_pba
(braket
id|i
)braket
op_assign
id|info-&gt;pba_to_lba
(braket
id|i
)braket
op_assign
id|UNDEF
suffix:semicolon
id|ptr
op_assign
id|page_address
c_func
(paren
id|sg
(braket
l_int|0
)braket
dot
id|page
)paren
op_plus
id|sg
(braket
l_int|0
)braket
dot
id|offset
suffix:semicolon
multiline_comment|/*&n;&t; * Define lba-pba translation table&n;&t; */
singleline_comment|// Each block is 64 bytes of control data, so block i is located in
singleline_comment|// scatterlist block i*64/128k = i*(2^6)*(2^-17) = i*(2^-11)
macro_line|#if 0
multiline_comment|/* No translation */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numblocks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lba
op_assign
id|i
suffix:semicolon
id|info-&gt;pba_to_lba
(braket
id|i
)braket
op_assign
id|lba
suffix:semicolon
id|info-&gt;lba_to_pba
(braket
id|lba
)braket
op_assign
id|i
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;sddr09: no translation today&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#else
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numblocks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ptr
op_assign
id|page_address
c_func
(paren
id|sg
(braket
id|i
op_rshift
l_int|11
)braket
dot
id|page
)paren
op_plus
id|sg
(braket
id|i
op_rshift
l_int|11
)braket
dot
id|offset
op_plus
(paren
(paren
id|i
op_amp
l_int|0x7ff
)paren
op_lshift
l_int|6
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
op_logical_or
id|i
op_eq
l_int|1
)paren
(brace
id|info-&gt;pba_to_lba
(braket
id|i
)braket
op_assign
id|UNUSABLE
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* special PBAs have control field 0^16 */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|16
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|ptr
(braket
id|j
)braket
op_ne
l_int|0
)paren
r_goto
id|nonz
suffix:semicolon
id|info-&gt;pba_to_lba
(braket
id|i
)braket
op_assign
id|UNUSABLE
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sddr09: PBA %04X has no logical mapping&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_continue
suffix:semicolon
id|nonz
suffix:colon
multiline_comment|/* unwritten PBAs have control field FF^16 */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|16
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|ptr
(braket
id|j
)braket
op_ne
l_int|0xff
)paren
r_goto
id|nonff
suffix:semicolon
r_continue
suffix:semicolon
id|nonff
suffix:colon
multiline_comment|/* normal PBAs start with six FFs */
r_if
c_cond
(paren
id|j
OL
l_int|6
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sddr09: PBA %04X has no logical mapping: &quot;
l_string|&quot;reserved area = %02X%02X%02X%02X &quot;
l_string|&quot;data status %02X block status %02X&bslash;n&quot;
comma
id|i
comma
id|ptr
(braket
l_int|0
)braket
comma
id|ptr
(braket
l_int|1
)braket
comma
id|ptr
(braket
l_int|2
)braket
comma
id|ptr
(braket
l_int|3
)braket
comma
id|ptr
(braket
l_int|4
)braket
comma
id|ptr
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|info-&gt;pba_to_lba
(braket
id|i
)braket
op_assign
id|UNUSABLE
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ptr
(braket
l_int|6
)braket
op_rshift
l_int|4
)paren
op_ne
l_int|0x01
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sddr09: PBA %04X has invalid address field &quot;
l_string|&quot;%02X%02X/%02X%02X&bslash;n&quot;
comma
id|i
comma
id|ptr
(braket
l_int|6
)braket
comma
id|ptr
(braket
l_int|7
)braket
comma
id|ptr
(braket
l_int|11
)braket
comma
id|ptr
(braket
l_int|12
)braket
)paren
suffix:semicolon
id|info-&gt;pba_to_lba
(braket
id|i
)braket
op_assign
id|UNUSABLE
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* check even parity */
r_if
c_cond
(paren
id|parity
(braket
id|ptr
(braket
l_int|6
)braket
op_xor
id|ptr
(braket
l_int|7
)braket
)braket
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sddr09: Bad parity in LBA for block %04X&quot;
l_string|&quot; (%02X %02X)&bslash;n&quot;
comma
id|i
comma
id|ptr
(braket
l_int|6
)braket
comma
id|ptr
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|info-&gt;pba_to_lba
(braket
id|i
)braket
op_assign
id|UNUSABLE
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|lba
op_assign
id|short_pack
c_func
(paren
id|ptr
(braket
l_int|7
)braket
comma
id|ptr
(braket
l_int|6
)braket
)paren
suffix:semicolon
id|lba
op_assign
(paren
id|lba
op_amp
l_int|0x07FF
)paren
op_rshift
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Every 1024 physical blocks (&quot;zone&quot;), the LBA numbers&n;&t;&t; * go back to zero, but are within a higher block of LBA&squot;s.&n;&t;&t; * Also, there is a maximum of 1000 LBA&squot;s per zone.&n;&t;&t; * In other words, in PBA 1024-2047 you will find LBA 0-999&n;&t;&t; * which are really LBA 1000-1999. This allows for 24 bad&n;&t;&t; * or special physical blocks per zone.&n;&t;&t; */
r_if
c_cond
(paren
id|lba
op_ge
l_int|1000
)paren
(brace
r_int
r_int
id|address
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sddr09: Bad LBA %04X for block %04X&bslash;n&quot;
comma
id|lba
comma
id|i
)paren
suffix:semicolon
id|info-&gt;pba_to_lba
(braket
id|i
)braket
op_assign
id|UNDEF
multiline_comment|/* UNUSABLE */
suffix:semicolon
r_if
c_cond
(paren
id|erase_bad_lba_entries
)paren
(brace
multiline_comment|/* some cameras cannot erase a card if it has&n;&t;&t;&t;&t;   bad entries, so we supply this function */
id|address
op_assign
(paren
id|i
op_lshift
(paren
id|info-&gt;pageshift
op_plus
id|info-&gt;blockshift
)paren
)paren
suffix:semicolon
id|sddr09_erase
c_func
(paren
id|us
comma
id|address
op_rshift
l_int|1
)paren
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
id|lba
op_add_assign
l_int|1000
op_star
(paren
id|i
op_div
l_int|0x400
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lba
OL
l_int|0x10
op_logical_or
(paren
id|lba
op_ge
l_int|0x3E0
op_logical_and
id|lba
OL
l_int|0x3EF
)paren
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;LBA %04X &lt;-&gt; PBA %04X&bslash;n&quot;
comma
id|lba
comma
id|i
)paren
suffix:semicolon
id|info-&gt;pba_to_lba
(braket
id|i
)braket
op_assign
id|lba
suffix:semicolon
id|info-&gt;lba_to_pba
(braket
id|lba
)braket
op_assign
id|i
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Approximate capacity. This is not entirely correct yet,&n;&t; * since a zone with less than 1000 usable pages leads to&n;&t; * missing LBAs. Especially if it is the last zone, some&n;&t; * LBAs can be past capacity.&n;&t; */
id|lbact
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numblocks
suffix:semicolon
id|i
op_add_assign
l_int|1024
)paren
(brace
r_int
id|ct
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|1024
op_logical_and
id|i
op_plus
id|j
OL
id|numblocks
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;pba_to_lba
(braket
id|i
op_plus
id|j
)braket
op_ne
id|UNUSABLE
)paren
(brace
r_if
c_cond
(paren
id|ct
op_ge
l_int|1000
)paren
id|info-&gt;pba_to_lba
(braket
id|i
op_plus
id|j
)braket
op_assign
id|SPARE
suffix:semicolon
r_else
id|ct
op_increment
suffix:semicolon
)brace
)brace
id|lbact
op_add_assign
id|ct
suffix:semicolon
)brace
id|info-&gt;lbact
op_assign
id|lbact
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Found %d LBA&squot;s&bslash;n&quot;
comma
id|lbact
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|alloc_blocks
suffix:semicolon
id|i
op_increment
)paren
id|kfree
c_func
(paren
id|page_address
c_func
(paren
id|sg
(braket
id|i
)braket
dot
id|page
)paren
op_plus
id|sg
(braket
id|i
)braket
dot
id|offset
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|sddr09_card_info_destructor
id|sddr09_card_info_destructor
c_func
(paren
r_void
op_star
id|extra
)paren
(brace
r_struct
id|sddr09_card_info
op_star
id|info
op_assign
(paren
r_struct
id|sddr09_card_info
op_star
)paren
id|extra
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
r_return
suffix:semicolon
id|kfree
c_func
(paren
id|info-&gt;lba_to_pba
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|info-&gt;pba_to_lba
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|sddr09_init_card_info
id|sddr09_init_card_info
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|us-&gt;extra
)paren
(brace
id|us-&gt;extra
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|sddr09_card_info
)paren
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|us-&gt;extra
)paren
(brace
id|memset
c_func
(paren
id|us-&gt;extra
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|sddr09_card_info
)paren
)paren
suffix:semicolon
id|us-&gt;extra_destructor
op_assign
id|sddr09_card_info_destructor
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * This is needed at a very early stage. If this is not listed in the&n; * unusual devices list but called from here then LUN 0 of the combo reader&n; * is not recognized. But I do not know what precisely these calls do.&n; */
r_int
DECL|function|sddr09_init
id|sddr09_init
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_char
id|data
(braket
l_int|18
)braket
suffix:semicolon
id|result
op_assign
id|sddr09_send_command
c_func
(paren
id|us
comma
l_int|0x01
comma
id|USB_DIR_IN
comma
id|data
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;sddr09_init: send_command fails&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;SDDR09init: %02X %02X&bslash;n&quot;
comma
id|data
(braket
l_int|0
)braket
comma
id|data
(braket
l_int|1
)braket
)paren
suffix:semicolon
singleline_comment|// get 07 02
id|result
op_assign
id|sddr09_send_command
c_func
(paren
id|us
comma
l_int|0x08
comma
id|USB_DIR_IN
comma
id|data
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;sddr09_init: 2nd send_command fails&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;SDDR09init: %02X %02X&bslash;n&quot;
comma
id|data
(braket
l_int|0
)braket
comma
id|data
(braket
l_int|1
)braket
)paren
suffix:semicolon
singleline_comment|// get 07 00
id|result
op_assign
id|sddr09_request_sense
c_func
(paren
id|us
comma
id|data
comma
r_sizeof
(paren
id|data
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
id|USB_STOR_TRANSPORT_GOOD
op_logical_and
id|data
(braket
l_int|2
)braket
op_ne
l_int|0
)paren
(brace
r_int
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
r_sizeof
(paren
id|data
)paren
suffix:semicolon
id|j
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %02X&quot;
comma
id|data
(braket
id|j
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|// get 70 00 00 00 00 00 00 * 00 00 00 00 00 00
singleline_comment|// 70: current command
singleline_comment|// sense key 0, sense code 0, extd sense code 0
singleline_comment|// additional transfer length * = sizeof(data) - 7
singleline_comment|// Or: 70 00 06 00 00 00 00 0b 00 00 00 00 28 00 00 00 00 00
singleline_comment|// sense key 06, sense code 28: unit attention,
singleline_comment|// not ready to ready transition
)brace
singleline_comment|// test unit ready
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
multiline_comment|/* not result */
)brace
multiline_comment|/*&n; * Transport for the Sandisk SDDR-09&n; */
DECL|function|sddr09_transport
r_int
id|sddr09_transport
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_static
r_int
r_char
id|sensekey
op_assign
l_int|0
comma
id|sensecode
op_assign
l_int|0
suffix:semicolon
r_static
r_int
r_char
id|havefakesense
op_assign
l_int|0
suffix:semicolon
r_int
id|result
comma
id|i
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_int
r_int
id|capacity
suffix:semicolon
r_int
r_int
id|page
comma
id|pages
suffix:semicolon
r_char
id|string
(braket
l_int|64
)braket
suffix:semicolon
r_struct
id|sddr09_card_info
op_star
id|info
suffix:semicolon
r_int
r_char
id|inquiry_response
(braket
l_int|36
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0x80
comma
l_int|0x00
comma
l_int|0x02
comma
l_int|0x1F
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
r_int
r_char
id|mode_page_01
(braket
l_int|16
)braket
op_assign
(brace
l_int|0x0F
comma
l_int|0x00
comma
l_int|0
comma
l_int|0x00
comma
l_int|0x01
comma
l_int|0x0A
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
id|info
op_assign
(paren
r_struct
id|sddr09_card_info
op_star
)paren
id|us-&gt;extra
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
(brace
id|nand_init_ecc
c_func
(paren
)paren
suffix:semicolon
id|sddr09_init_card_info
c_func
(paren
id|us
)paren
suffix:semicolon
id|info
op_assign
(paren
r_struct
id|sddr09_card_info
op_star
)paren
id|us-&gt;extra
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
id|ptr
op_assign
(paren
r_int
r_char
op_star
)paren
id|srb-&gt;request_buffer
suffix:semicolon
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
op_logical_and
id|havefakesense
)paren
(brace
multiline_comment|/* for a faked command, we have to follow with a faked sense */
id|memset
c_func
(paren
id|ptr
comma
l_int|0
comma
id|srb-&gt;request_bufflen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|srb-&gt;request_bufflen
OG
l_int|7
)paren
(brace
id|ptr
(braket
l_int|0
)braket
op_assign
l_int|0x70
suffix:semicolon
id|ptr
(braket
l_int|2
)braket
op_assign
id|sensekey
suffix:semicolon
id|ptr
(braket
l_int|7
)braket
op_assign
id|srb-&gt;request_bufflen
op_minus
l_int|7
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;request_bufflen
OG
l_int|12
)paren
id|ptr
(braket
l_int|12
)braket
op_assign
id|sensecode
suffix:semicolon
id|sensekey
op_assign
id|sensecode
op_assign
id|havefakesense
op_assign
l_int|0
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
id|havefakesense
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Dummy up a response for INQUIRY since SDDR09 doesn&squot;t&n;&t;   respond to INQUIRY commands */
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
(brace
id|memset
c_func
(paren
id|inquiry_response
op_plus
l_int|8
comma
l_int|0
comma
l_int|28
)paren
suffix:semicolon
id|fill_inquiry_response
c_func
(paren
id|us
comma
id|inquiry_response
comma
l_int|36
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|READ_CAPACITY
)paren
(brace
r_struct
id|nand_flash_dev
op_star
id|cardinfo
suffix:semicolon
id|sddr09_get_wp
c_func
(paren
id|us
comma
id|info
)paren
suffix:semicolon
multiline_comment|/* read WP bit */
id|cardinfo
op_assign
id|sddr09_get_cardinfo
c_func
(paren
id|us
comma
id|info-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cardinfo
)paren
(brace
multiline_comment|/* probably no media */
id|sensekey
op_assign
l_int|0x02
suffix:semicolon
multiline_comment|/* not ready */
id|sensecode
op_assign
l_int|0x3a
suffix:semicolon
multiline_comment|/* medium not present */
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
id|info-&gt;capacity
op_assign
(paren
l_int|1
op_lshift
id|cardinfo-&gt;chipshift
)paren
suffix:semicolon
id|info-&gt;pageshift
op_assign
id|cardinfo-&gt;pageshift
suffix:semicolon
id|info-&gt;pagesize
op_assign
(paren
l_int|1
op_lshift
id|info-&gt;pageshift
)paren
suffix:semicolon
id|info-&gt;blockshift
op_assign
id|cardinfo-&gt;blockshift
suffix:semicolon
id|info-&gt;blocksize
op_assign
(paren
l_int|1
op_lshift
id|info-&gt;blockshift
)paren
suffix:semicolon
id|info-&gt;blockmask
op_assign
id|info-&gt;blocksize
op_minus
l_int|1
suffix:semicolon
singleline_comment|// map initialization, must follow get_cardinfo()
id|sddr09_read_map
c_func
(paren
id|us
)paren
suffix:semicolon
singleline_comment|// Report capacity
id|capacity
op_assign
(paren
id|info-&gt;lbact
op_lshift
id|info-&gt;blockshift
)paren
op_minus
l_int|1
suffix:semicolon
id|ptr
(braket
l_int|0
)braket
op_assign
id|MSB_of
c_func
(paren
id|capacity
op_rshift
l_int|16
)paren
suffix:semicolon
id|ptr
(braket
l_int|1
)braket
op_assign
id|LSB_of
c_func
(paren
id|capacity
op_rshift
l_int|16
)paren
suffix:semicolon
id|ptr
(braket
l_int|2
)braket
op_assign
id|MSB_of
c_func
(paren
id|capacity
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
id|ptr
(braket
l_int|3
)braket
op_assign
id|LSB_of
c_func
(paren
id|capacity
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
singleline_comment|// Report page size
id|ptr
(braket
l_int|4
)braket
op_assign
id|MSB_of
c_func
(paren
id|info-&gt;pagesize
op_rshift
l_int|16
)paren
suffix:semicolon
id|ptr
(braket
l_int|5
)braket
op_assign
id|LSB_of
c_func
(paren
id|info-&gt;pagesize
op_rshift
l_int|16
)paren
suffix:semicolon
id|ptr
(braket
l_int|6
)braket
op_assign
id|MSB_of
c_func
(paren
id|info-&gt;pagesize
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
id|ptr
(braket
l_int|7
)braket
op_assign
id|LSB_of
c_func
(paren
id|info-&gt;pagesize
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|MODE_SENSE
)paren
(brace
singleline_comment|// Read-write error recovery page: there needs to
singleline_comment|// be a check for write-protect here
r_if
c_cond
(paren
(paren
id|srb-&gt;cmnd
(braket
l_int|2
)braket
op_amp
l_int|0x3F
)paren
op_eq
l_int|0x01
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;SDDR09: Dummy up request for mode page 1&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
op_eq
l_int|NULL
op_logical_or
id|srb-&gt;request_bufflen
OL
r_sizeof
(paren
id|mode_page_01
)paren
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|mode_page_01
(braket
l_int|0
)braket
op_assign
r_sizeof
(paren
id|mode_page_01
)paren
op_minus
l_int|1
suffix:semicolon
id|mode_page_01
(braket
l_int|2
)braket
op_assign
(paren
id|info-&gt;flags
op_amp
id|SDDR09_WP
)paren
ques
c_cond
l_int|0x80
suffix:colon
l_int|0
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
comma
id|mode_page_01
comma
r_sizeof
(paren
id|mode_page_01
)paren
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|srb-&gt;cmnd
(braket
l_int|2
)braket
op_amp
l_int|0x3F
)paren
op_eq
l_int|0x3F
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;SDDR09: Dummy up request for &quot;
l_string|&quot;all mode pages&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
op_eq
l_int|NULL
op_logical_or
id|srb-&gt;request_bufflen
OL
r_sizeof
(paren
id|mode_page_01
)paren
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
comma
id|mode_page_01
comma
r_sizeof
(paren
id|mode_page_01
)paren
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|ALLOW_MEDIUM_REMOVAL
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;SDDR09: %s medium removal. Not that I can do&quot;
l_string|&quot; anything about it...&bslash;n&quot;
comma
(paren
id|srb-&gt;cmnd
(braket
l_int|4
)braket
op_amp
l_int|0x03
)paren
ques
c_cond
l_string|&quot;Prevent&quot;
suffix:colon
l_string|&quot;Allow&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
id|havefakesense
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|READ_10
)paren
(brace
id|page
op_assign
id|short_pack
c_func
(paren
id|srb-&gt;cmnd
(braket
l_int|3
)braket
comma
id|srb-&gt;cmnd
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|page
op_lshift_assign
l_int|16
suffix:semicolon
id|page
op_or_assign
id|short_pack
c_func
(paren
id|srb-&gt;cmnd
(braket
l_int|5
)braket
comma
id|srb-&gt;cmnd
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|pages
op_assign
id|short_pack
c_func
(paren
id|srb-&gt;cmnd
(braket
l_int|8
)braket
comma
id|srb-&gt;cmnd
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;READ_10: read page %d pagect %d&bslash;n&quot;
comma
id|page
comma
id|pages
)paren
suffix:semicolon
r_return
id|sddr09_read_data
c_func
(paren
id|us
comma
id|page
comma
id|pages
comma
id|ptr
comma
id|srb-&gt;use_sg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|WRITE_10
)paren
(brace
id|page
op_assign
id|short_pack
c_func
(paren
id|srb-&gt;cmnd
(braket
l_int|3
)braket
comma
id|srb-&gt;cmnd
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|page
op_lshift_assign
l_int|16
suffix:semicolon
id|page
op_or_assign
id|short_pack
c_func
(paren
id|srb-&gt;cmnd
(braket
l_int|5
)braket
comma
id|srb-&gt;cmnd
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|pages
op_assign
id|short_pack
c_func
(paren
id|srb-&gt;cmnd
(braket
l_int|8
)braket
comma
id|srb-&gt;cmnd
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;WRITE_10: write page %d pagect %d&bslash;n&quot;
comma
id|page
comma
id|pages
)paren
suffix:semicolon
r_return
id|sddr09_write_data
c_func
(paren
id|us
comma
id|page
comma
id|pages
comma
id|ptr
comma
id|srb-&gt;use_sg
)paren
suffix:semicolon
)brace
singleline_comment|// Pass TEST_UNIT_READY and REQUEST_SENSE through
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_ne
id|TEST_UNIT_READY
op_logical_and
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_ne
id|REQUEST_SENSE
)paren
(brace
id|havefakesense
op_assign
l_int|1
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|srb-&gt;cmd_len
OL
l_int|12
suffix:semicolon
id|srb-&gt;cmd_len
op_increment
)paren
id|srb-&gt;cmnd
(braket
id|srb-&gt;cmd_len
)braket
op_assign
l_int|0
suffix:semicolon
id|srb-&gt;cmnd
(braket
l_int|1
)braket
op_assign
id|LUNBITS
suffix:semicolon
id|string
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|12
suffix:semicolon
id|i
op_increment
)paren
id|sprintf
c_func
(paren
id|string
op_plus
id|strlen
c_func
(paren
id|string
)paren
comma
l_string|&quot;%02X &quot;
comma
id|srb-&gt;cmnd
(braket
id|i
)braket
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;SDDR09: Send control for command %s&bslash;n&quot;
comma
id|string
)paren
suffix:semicolon
id|result
op_assign
id|sddr09_send_scsi_command
c_func
(paren
id|us
comma
id|srb-&gt;cmnd
comma
l_int|12
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;sddr09_transport: sddr09_send_scsi_command &quot;
l_string|&quot;returns %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;request_bufflen
op_eq
l_int|0
)paren
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
r_if
c_cond
(paren
id|srb-&gt;sc_data_direction
op_eq
id|SCSI_DATA_WRITE
op_logical_or
id|srb-&gt;sc_data_direction
op_eq
id|SCSI_DATA_READ
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;SDDR09: %s %d bytes&bslash;n&quot;
comma
(paren
id|srb-&gt;sc_data_direction
op_eq
id|SCSI_DATA_WRITE
)paren
ques
c_cond
l_string|&quot;sending&quot;
suffix:colon
l_string|&quot;receiving&quot;
comma
id|srb-&gt;request_bufflen
)paren
suffix:semicolon
id|result
op_assign
id|sddr09_bulk_transport
c_func
(paren
id|us
comma
id|srb-&gt;sc_data_direction
comma
id|srb-&gt;request_buffer
comma
id|srb-&gt;request_bufflen
comma
id|srb-&gt;use_sg
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
eof
