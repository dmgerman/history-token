multiline_comment|/* Driver for USB Mass Storage compliant devices&n; * SCSI layer glue code&n; *&n; * $Id: scsiglue.c,v 1.26 2002/04/22 03:39:43 mdharm Exp $&n; *&n; * Current development and maintenance by:&n; *   (c) 1999-2002 Matthew Dharm (mdharm-usb@one-eyed-alien.net)&n; *&n; * Developed with the assistance of:&n; *   (c) 2000 David L. Brown, Jr. (usb-storage@davidb.org)&n; *   (c) 2000 Stephen J. Gowdy (SGowdy@lbl.gov)&n; *&n; * Initial work by:&n; *   (c) 1999 Michael Gee (michael@linuxspecific.com)&n; *&n; * This driver is based on the &squot;USB Mass Storage Class&squot; document. This&n; * describes in detail the protocol used to communicate with such&n; * devices.  Clearly, the designers had SCSI and ATAPI commands in&n; * mind when they created this document.  The commands are all very&n; * similar to commands in the SCSI-II and ATAPI specifications.&n; *&n; * It is important to note that in a number of cases this class&n; * exhibits class-specific exemptions from the USB specification.&n; * Notably the usage of NAK, STALL and ACK differs from the norm, in&n; * that they are used to communicate wait, failed and OK on commands.&n; *&n; * Also, for certain devices, the interrupt endpoint is used to convey&n; * status of a command.&n; *&n; * Please see http://www.one-eyed-alien.net/~mdharm/linux-usb for more&n; * information about this driver.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2, or (at your option) any&n; * later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write to the Free Software Foundation, Inc.,&n; * 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &quot;scsiglue.h&quot;
macro_line|#include &quot;usb.h&quot;
macro_line|#include &quot;debug.h&quot;
macro_line|#include &quot;transport.h&quot;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/module.h&gt;
multiline_comment|/***********************************************************************&n; * Host functions &n; ***********************************************************************/
DECL|function|host_info
r_static
r_const
r_char
op_star
id|host_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_return
l_string|&quot;SCSI emulation for USB Mass Storage devices&quot;
suffix:semicolon
)brace
DECL|function|slave_configure
r_static
r_int
id|slave_configure
(paren
r_struct
id|scsi_device
op_star
id|sdev
)paren
(brace
multiline_comment|/* set device to use 10-byte commands where possible */
id|sdev-&gt;use_10_for_ms
op_assign
l_int|1
suffix:semicolon
id|sdev-&gt;use_10_for_rw
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* this is to satisify the compiler, tho I don&squot;t think the &n;&t; * return code is ever checked anywhere. */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* queue a command */
multiline_comment|/* This is always called with scsi_lock(srb-&gt;host) held */
DECL|function|queuecommand
r_static
r_int
id|queuecommand
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_struct
id|us_data
op_star
id|us
op_assign
(paren
r_struct
id|us_data
op_star
)paren
id|srb-&gt;device-&gt;host-&gt;hostdata
(braket
l_int|0
)braket
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;%s called&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|srb-&gt;host_scribble
op_assign
(paren
r_int
r_char
op_star
)paren
id|us
suffix:semicolon
multiline_comment|/* enqueue the command */
r_if
c_cond
(paren
id|us-&gt;sm_state
op_ne
id|US_STATE_IDLE
op_logical_or
id|us-&gt;srb
op_ne
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|USB_STORAGE
l_string|&quot;Error in %s: &quot;
l_string|&quot;state = %d, us-&gt;srb = %p&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|us-&gt;sm_state
comma
id|us-&gt;srb
)paren
suffix:semicolon
r_return
id|SCSI_MLQUEUE_HOST_BUSY
suffix:semicolon
)brace
id|srb-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|us-&gt;srb
op_assign
id|srb
suffix:semicolon
multiline_comment|/* wake up the process task */
id|up
c_func
(paren
op_amp
(paren
id|us-&gt;sema
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/***********************************************************************&n; * Error handling functions&n; ***********************************************************************/
multiline_comment|/* Command abort */
multiline_comment|/* This is always called with scsi_lock(srb-&gt;host) held */
DECL|function|command_abort
r_static
r_int
id|command_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|srb-&gt;device-&gt;host
suffix:semicolon
r_struct
id|us_data
op_star
id|us
op_assign
(paren
r_struct
id|us_data
op_star
)paren
id|host-&gt;hostdata
(braket
l_int|0
)braket
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;%s called&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* Is this command still active? */
r_if
c_cond
(paren
id|us-&gt;srb
op_ne
id|srb
)paren
(brace
id|US_DEBUGP
(paren
l_string|&quot;-- nothing to abort&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|FAILED
suffix:semicolon
)brace
multiline_comment|/* Normally the current state is RUNNING.  If the control thread&n;&t; * hasn&squot;t even started processing this command, the state will be&n;&t; * IDLE.  Anything else is a bug. */
r_if
c_cond
(paren
id|us-&gt;sm_state
op_ne
id|US_STATE_RUNNING
op_logical_and
id|us-&gt;sm_state
op_ne
id|US_STATE_IDLE
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|USB_STORAGE
l_string|&quot;Error in %s: &quot;
l_string|&quot;invalid state %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|us-&gt;sm_state
)paren
suffix:semicolon
r_return
id|FAILED
suffix:semicolon
)brace
multiline_comment|/* Set state to ABORTING, set the ABORTING bit, and release the lock */
id|us-&gt;sm_state
op_assign
id|US_STATE_ABORTING
suffix:semicolon
id|set_bit
c_func
(paren
id|US_FLIDX_ABORTING
comma
op_amp
id|us-&gt;flags
)paren
suffix:semicolon
id|scsi_unlock
c_func
(paren
id|host
)paren
suffix:semicolon
multiline_comment|/* Stop an ongoing USB transfer */
id|usb_stor_stop_transport
c_func
(paren
id|us
)paren
suffix:semicolon
multiline_comment|/* Wait for the aborted command to finish */
id|wait_for_completion
c_func
(paren
op_amp
id|us-&gt;notify
)paren
suffix:semicolon
multiline_comment|/* Reacquire the lock and allow USB transfers to resume */
id|scsi_lock
c_func
(paren
id|host
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|US_FLIDX_ABORTING
comma
op_amp
id|us-&gt;flags
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
multiline_comment|/* This invokes the transport reset mechanism to reset the state of the&n; * device */
multiline_comment|/* This is always called with scsi_lock(srb-&gt;host) held */
DECL|function|device_reset
r_static
r_int
id|device_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
)paren
(brace
r_struct
id|us_data
op_star
id|us
op_assign
(paren
r_struct
id|us_data
op_star
)paren
id|srb-&gt;device-&gt;host-&gt;hostdata
(braket
l_int|0
)braket
suffix:semicolon
r_int
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;%s called&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_if
c_cond
(paren
id|us-&gt;sm_state
op_ne
id|US_STATE_IDLE
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|USB_STORAGE
l_string|&quot;Error in %s: &quot;
l_string|&quot;invalid state %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|us-&gt;sm_state
)paren
suffix:semicolon
r_return
id|FAILED
suffix:semicolon
)brace
multiline_comment|/* set the state and release the lock */
id|us-&gt;sm_state
op_assign
id|US_STATE_RESETTING
suffix:semicolon
id|scsi_unlock
c_func
(paren
id|srb-&gt;device-&gt;host
)paren
suffix:semicolon
multiline_comment|/* lock the device pointers and do the reset */
id|down
c_func
(paren
op_amp
(paren
id|us-&gt;dev_semaphore
)paren
)paren
suffix:semicolon
id|result
op_assign
id|us
op_member_access_from_pointer
id|transport_reset
c_func
(paren
id|us
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
(paren
id|us-&gt;dev_semaphore
)paren
)paren
suffix:semicolon
multiline_comment|/* lock access to the state and clear it */
id|scsi_lock
c_func
(paren
id|srb-&gt;device-&gt;host
)paren
suffix:semicolon
id|us-&gt;sm_state
op_assign
id|US_STATE_IDLE
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/* This resets the device&squot;s USB port. */
multiline_comment|/* It refuses to work if there&squot;s more than one interface in&n; * the device, so that other users are not affected. */
multiline_comment|/* This is always called with scsi_lock(srb-&gt;host) held */
DECL|function|bus_reset
r_static
r_int
id|bus_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
)paren
(brace
r_struct
id|us_data
op_star
id|us
op_assign
(paren
r_struct
id|us_data
op_star
)paren
id|srb-&gt;device-&gt;host-&gt;hostdata
(braket
l_int|0
)braket
suffix:semicolon
r_int
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;%s called&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_if
c_cond
(paren
id|us-&gt;sm_state
op_ne
id|US_STATE_IDLE
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|USB_STORAGE
l_string|&quot;Error in %s: &quot;
l_string|&quot;invalid state %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|us-&gt;sm_state
)paren
suffix:semicolon
r_return
id|FAILED
suffix:semicolon
)brace
multiline_comment|/* set the state and release the lock */
id|us-&gt;sm_state
op_assign
id|US_STATE_RESETTING
suffix:semicolon
id|scsi_unlock
c_func
(paren
id|srb-&gt;device-&gt;host
)paren
suffix:semicolon
multiline_comment|/* The USB subsystem doesn&squot;t handle synchronisation between&n;&t; * a device&squot;s several drivers. Therefore we reset only devices&n;&t; * with just one interface, which we of course own. */
id|down
c_func
(paren
op_amp
(paren
id|us-&gt;dev_semaphore
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|US_FLIDX_DISCONNECTING
comma
op_amp
id|us-&gt;flags
)paren
)paren
(brace
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Attempt to reset during disconnect&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|us-&gt;pusb_dev-&gt;actconfig-&gt;desc.bNumInterfaces
op_ne
l_int|1
)paren
(brace
id|result
op_assign
op_minus
id|EBUSY
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Refusing to reset a multi-interface device&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|result
op_assign
id|usb_reset_device
c_func
(paren
id|us-&gt;pusb_dev
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;usb_reset_device returns %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
(paren
id|us-&gt;dev_semaphore
)paren
)paren
suffix:semicolon
multiline_comment|/* lock access to the state and clear it */
id|scsi_lock
c_func
(paren
id|srb-&gt;device-&gt;host
)paren
suffix:semicolon
id|us-&gt;sm_state
op_assign
id|US_STATE_IDLE
suffix:semicolon
r_return
id|result
OL
l_int|0
ques
c_cond
id|FAILED
suffix:colon
id|SUCCESS
suffix:semicolon
)brace
multiline_comment|/***********************************************************************&n; * /proc/scsi/ functions&n; ***********************************************************************/
multiline_comment|/* we use this macro to help us write into the buffer */
DECL|macro|SPRINTF
macro_line|#undef SPRINTF
DECL|macro|SPRINTF
mdefine_line|#define SPRINTF(args...) &bslash;&n;&t;do { if (pos &lt; buffer+length) pos += sprintf(pos, ## args); } while (0)
DECL|function|proc_info
r_static
r_int
id|proc_info
(paren
r_struct
id|Scsi_Host
op_star
id|hostptr
comma
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|inout
)paren
(brace
r_struct
id|us_data
op_star
id|us
suffix:semicolon
r_char
op_star
id|pos
op_assign
id|buffer
suffix:semicolon
r_int
r_int
id|f
suffix:semicolon
multiline_comment|/* if someone is sending us data, just throw it away */
r_if
c_cond
(paren
id|inout
)paren
r_return
id|length
suffix:semicolon
id|us
op_assign
(paren
r_struct
id|us_data
op_star
)paren
id|hostptr-&gt;hostdata
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* print the controller name */
id|SPRINTF
c_func
(paren
l_string|&quot;   Host scsi%d: usb-storage&bslash;n&quot;
comma
id|hostptr-&gt;host_no
)paren
suffix:semicolon
multiline_comment|/* print product, vendor, and serial number strings */
id|SPRINTF
c_func
(paren
l_string|&quot;       Vendor: %s&bslash;n&quot;
comma
id|us-&gt;vendor
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;      Product: %s&bslash;n&quot;
comma
id|us-&gt;product
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;Serial Number: %s&bslash;n&quot;
comma
id|us-&gt;serial
)paren
suffix:semicolon
multiline_comment|/* show the protocol and transport */
id|SPRINTF
c_func
(paren
l_string|&quot;     Protocol: %s&bslash;n&quot;
comma
id|us-&gt;protocol_name
)paren
suffix:semicolon
id|SPRINTF
c_func
(paren
l_string|&quot;    Transport: %s&bslash;n&quot;
comma
id|us-&gt;transport_name
)paren
suffix:semicolon
multiline_comment|/* show the device flags */
r_if
c_cond
(paren
id|pos
OL
id|buffer
op_plus
id|length
)paren
(brace
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|pos
comma
l_string|&quot;       Quirks:&quot;
)paren
suffix:semicolon
id|f
op_assign
id|us-&gt;flags
suffix:semicolon
DECL|macro|DO_FLAG
mdefine_line|#define DO_FLAG(a)  &t;if (f &amp; US_FL_##a)  pos += sprintf(pos, &quot; &quot; #a)
id|DO_FLAG
c_func
(paren
id|SINGLE_LUN
)paren
suffix:semicolon
id|DO_FLAG
c_func
(paren
id|MODE_XLATE
)paren
suffix:semicolon
id|DO_FLAG
c_func
(paren
id|SCM_MULT_TARG
)paren
suffix:semicolon
id|DO_FLAG
c_func
(paren
id|FIX_INQUIRY
)paren
suffix:semicolon
id|DO_FLAG
c_func
(paren
id|FIX_CAPACITY
)paren
suffix:semicolon
DECL|macro|DO_FLAG
macro_line|#undef DO_FLAG
op_star
(paren
id|pos
op_increment
)paren
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Calculate start of next buffer, and return value.&n;&t; */
op_star
id|start
op_assign
id|buffer
op_plus
id|offset
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pos
op_minus
id|buffer
)paren
OL
id|offset
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|pos
op_minus
id|buffer
op_minus
id|offset
)paren
OL
id|length
)paren
r_return
(paren
id|pos
op_minus
id|buffer
op_minus
id|offset
)paren
suffix:semicolon
r_else
r_return
(paren
id|length
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * this defines our host template, with which we&squot;ll allocate hosts&n; */
DECL|variable|usb_stor_host_template
r_struct
id|SHT
id|usb_stor_host_template
op_assign
(brace
multiline_comment|/* basic userland interface stuff */
dot
id|name
op_assign
l_string|&quot;usb-storage&quot;
comma
dot
id|proc_name
op_assign
l_string|&quot;usb-storage&quot;
comma
dot
id|proc_info
op_assign
id|proc_info
comma
dot
id|proc_dir
op_assign
l_int|NULL
comma
dot
id|info
op_assign
id|host_info
comma
dot
id|ioctl
op_assign
l_int|NULL
comma
multiline_comment|/* old-style detect and release */
dot
id|detect
op_assign
l_int|NULL
comma
dot
id|release
op_assign
l_int|NULL
comma
multiline_comment|/* command interface -- queued only */
dot
id|command
op_assign
l_int|NULL
comma
dot
id|queuecommand
op_assign
id|queuecommand
comma
multiline_comment|/* error and abort handlers */
dot
id|eh_abort_handler
op_assign
id|command_abort
comma
dot
id|eh_device_reset_handler
op_assign
id|device_reset
comma
dot
id|eh_bus_reset_handler
op_assign
id|bus_reset
comma
dot
id|eh_host_reset_handler
op_assign
l_int|NULL
comma
dot
id|eh_strategy_handler
op_assign
l_int|NULL
comma
multiline_comment|/* queue commands only, only one command per LUN */
dot
id|can_queue
op_assign
l_int|1
comma
dot
id|cmd_per_lun
op_assign
l_int|1
comma
multiline_comment|/* unknown initiator id */
dot
id|this_id
op_assign
op_minus
l_int|1
comma
multiline_comment|/* no limit on commands */
dot
id|max_sectors
op_assign
l_int|0
comma
multiline_comment|/* pre- and post- device scan functions */
dot
id|slave_alloc
op_assign
l_int|NULL
comma
dot
id|slave_configure
op_assign
id|slave_configure
comma
dot
id|slave_destroy
op_assign
l_int|NULL
comma
multiline_comment|/* lots of sg segments can be handled */
dot
id|sg_tablesize
op_assign
id|SG_ALL
comma
multiline_comment|/* use 32-bit address space for DMA */
dot
id|unchecked_isa_dma
op_assign
id|FALSE
comma
dot
id|highmem_io
op_assign
id|FALSE
comma
multiline_comment|/* merge commands... this seems to help performance, but&n;&t; * periodically someone should test to see which setting is more&n;&t; * optimal.&n;&t; */
dot
id|use_clustering
op_assign
id|TRUE
comma
multiline_comment|/* emulated HBA */
dot
id|emulated
op_assign
id|TRUE
comma
multiline_comment|/* sorry, no BIOS to help us */
dot
id|bios_param
op_assign
l_int|NULL
comma
multiline_comment|/* module management */
dot
id|module
op_assign
id|THIS_MODULE
)brace
suffix:semicolon
multiline_comment|/* For a device that is &quot;Not Ready&quot; */
DECL|variable|usb_stor_sense_notready
r_int
r_char
id|usb_stor_sense_notready
(braket
l_int|18
)braket
op_assign
(brace
(braket
l_int|0
)braket
op_assign
l_int|0x70
comma
multiline_comment|/* current error */
(braket
l_int|2
)braket
op_assign
l_int|0x02
comma
multiline_comment|/* not ready */
(braket
l_int|7
)braket
op_assign
l_int|0x0a
comma
multiline_comment|/* additional length */
(braket
l_int|12
)braket
op_assign
l_int|0x04
comma
multiline_comment|/* not ready */
(braket
l_int|13
)braket
op_assign
l_int|0x03
multiline_comment|/* manual intervention */
)brace
suffix:semicolon
multiline_comment|/* To Report &quot;Illegal Request: Invalid Field in CDB */
DECL|variable|usb_stor_sense_invalidCDB
r_int
r_char
id|usb_stor_sense_invalidCDB
(braket
l_int|18
)braket
op_assign
(brace
(braket
l_int|0
)braket
op_assign
l_int|0x70
comma
multiline_comment|/* current error */
(braket
l_int|2
)braket
op_assign
id|ILLEGAL_REQUEST
comma
multiline_comment|/* Illegal Request = 0x05 */
(braket
l_int|7
)braket
op_assign
l_int|0x0a
comma
multiline_comment|/* additional length */
(braket
l_int|12
)braket
op_assign
l_int|0x24
multiline_comment|/* Invalid Field in CDB */
)brace
suffix:semicolon
DECL|macro|USB_STOR_SCSI_SENSE_HDRSZ
mdefine_line|#define USB_STOR_SCSI_SENSE_HDRSZ 4
DECL|macro|USB_STOR_SCSI_SENSE_10_HDRSZ
mdefine_line|#define USB_STOR_SCSI_SENSE_10_HDRSZ 8
DECL|struct|usb_stor_scsi_sense_hdr
r_struct
id|usb_stor_scsi_sense_hdr
(brace
DECL|member|dataLength
id|__u8
op_star
id|dataLength
suffix:semicolon
DECL|member|mediumType
id|__u8
op_star
id|mediumType
suffix:semicolon
DECL|member|devSpecParms
id|__u8
op_star
id|devSpecParms
suffix:semicolon
DECL|member|blkDescLength
id|__u8
op_star
id|blkDescLength
suffix:semicolon
)brace
suffix:semicolon
DECL|typedef|Usb_Stor_Scsi_Sense_Hdr
r_typedef
r_struct
id|usb_stor_scsi_sense_hdr
id|Usb_Stor_Scsi_Sense_Hdr
suffix:semicolon
DECL|union|usb_stor_scsi_sense_hdr_u
r_union
id|usb_stor_scsi_sense_hdr_u
(brace
DECL|member|hdr
id|Usb_Stor_Scsi_Sense_Hdr
id|hdr
suffix:semicolon
DECL|member|array
id|__u8
op_star
id|array
(braket
id|USB_STOR_SCSI_SENSE_HDRSZ
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|typedef|Usb_Stor_Scsi_Sense_Hdr_u
r_typedef
r_union
id|usb_stor_scsi_sense_hdr_u
id|Usb_Stor_Scsi_Sense_Hdr_u
suffix:semicolon
DECL|struct|usb_stor_scsi_sense_hdr_10
r_struct
id|usb_stor_scsi_sense_hdr_10
(brace
DECL|member|dataLengthMSB
id|__u8
op_star
id|dataLengthMSB
suffix:semicolon
DECL|member|dataLengthLSB
id|__u8
op_star
id|dataLengthLSB
suffix:semicolon
DECL|member|mediumType
id|__u8
op_star
id|mediumType
suffix:semicolon
DECL|member|devSpecParms
id|__u8
op_star
id|devSpecParms
suffix:semicolon
DECL|member|reserved1
id|__u8
op_star
id|reserved1
suffix:semicolon
DECL|member|reserved2
id|__u8
op_star
id|reserved2
suffix:semicolon
DECL|member|blkDescLengthMSB
id|__u8
op_star
id|blkDescLengthMSB
suffix:semicolon
DECL|member|blkDescLengthLSB
id|__u8
op_star
id|blkDescLengthLSB
suffix:semicolon
)brace
suffix:semicolon
DECL|typedef|Usb_Stor_Scsi_Sense_Hdr_10
r_typedef
r_struct
id|usb_stor_scsi_sense_hdr_10
id|Usb_Stor_Scsi_Sense_Hdr_10
suffix:semicolon
DECL|union|usb_stor_scsi_sense_hdr_10_u
r_union
id|usb_stor_scsi_sense_hdr_10_u
(brace
DECL|member|hdr
id|Usb_Stor_Scsi_Sense_Hdr_10
id|hdr
suffix:semicolon
DECL|member|array
id|__u8
op_star
id|array
(braket
id|USB_STOR_SCSI_SENSE_10_HDRSZ
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|typedef|Usb_Stor_Scsi_Sense_Hdr_10_u
r_typedef
r_union
id|usb_stor_scsi_sense_hdr_10_u
id|Usb_Stor_Scsi_Sense_Hdr_10_u
suffix:semicolon
r_void
id|usb_stor_scsiSenseParseBuffer
c_func
(paren
id|Scsi_Cmnd
op_star
comma
id|Usb_Stor_Scsi_Sense_Hdr_u
op_star
comma
id|Usb_Stor_Scsi_Sense_Hdr_10_u
op_star
comma
r_int
op_star
)paren
suffix:semicolon
DECL|function|usb_stor_scsiSense10to6
r_int
id|usb_stor_scsiSense10to6
c_func
(paren
id|Scsi_Cmnd
op_star
id|the10
)paren
(brace
id|__u8
op_star
id|buffer
op_assign
l_int|0
suffix:semicolon
r_int
id|outputBufferSize
op_assign
l_int|0
suffix:semicolon
r_int
id|length
op_assign
l_int|0
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
op_assign
l_int|0
suffix:semicolon
r_int
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
comma
id|element
op_assign
l_int|0
suffix:semicolon
id|Usb_Stor_Scsi_Sense_Hdr_u
id|the6Locations
suffix:semicolon
id|Usb_Stor_Scsi_Sense_Hdr_10_u
id|the10Locations
suffix:semicolon
r_int
id|sb
op_assign
l_int|0
comma
id|si
op_assign
l_int|0
comma
id|db
op_assign
l_int|0
comma
id|di
op_assign
l_int|0
suffix:semicolon
r_int
id|sgLength
op_assign
l_int|0
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- converting 10 byte sense data to 6 byte&bslash;n&quot;
)paren
suffix:semicolon
id|the10-&gt;cmnd
(braket
l_int|0
)braket
op_assign
id|the10-&gt;cmnd
(braket
l_int|0
)braket
op_amp
l_int|0xBF
suffix:semicolon
multiline_comment|/* Determine buffer locations */
id|usb_stor_scsiSenseParseBuffer
c_func
(paren
id|the10
comma
op_amp
id|the6Locations
comma
op_amp
id|the10Locations
comma
op_amp
id|length
)paren
suffix:semicolon
multiline_comment|/* Work out minimum buffer to output */
id|outputBufferSize
op_assign
op_star
id|the10Locations.hdr.dataLengthLSB
suffix:semicolon
id|outputBufferSize
op_add_assign
id|USB_STOR_SCSI_SENSE_HDRSZ
suffix:semicolon
multiline_comment|/* Check to see if we need to trucate the output */
r_if
c_cond
(paren
id|outputBufferSize
OG
id|length
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|USB_STORAGE
l_string|&quot;Had to truncate MODE_SENSE_10 buffer into MODE_SENSE.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
id|USB_STORAGE
l_string|&quot;outputBufferSize is %d and length is %d.&bslash;n&quot;
comma
id|outputBufferSize
comma
id|length
)paren
suffix:semicolon
)brace
id|outputBufferSize
op_assign
id|length
suffix:semicolon
multiline_comment|/* Data length */
r_if
c_cond
(paren
op_star
id|the10Locations.hdr.dataLengthMSB
op_ne
l_int|0
)paren
multiline_comment|/* MSB must be zero */
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|USB_STORAGE
l_string|&quot;Command will be truncated to fit in SENSE6 buffer.&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|the6Locations.hdr.dataLength
op_assign
l_int|0xff
suffix:semicolon
)brace
r_else
(brace
op_star
id|the6Locations.hdr.dataLength
op_assign
op_star
id|the10Locations.hdr.dataLengthLSB
suffix:semicolon
)brace
multiline_comment|/* Medium type and DevSpecific parms */
op_star
id|the6Locations.hdr.mediumType
op_assign
op_star
id|the10Locations.hdr.mediumType
suffix:semicolon
op_star
id|the6Locations.hdr.devSpecParms
op_assign
op_star
id|the10Locations.hdr.devSpecParms
suffix:semicolon
multiline_comment|/* Block descriptor length */
r_if
c_cond
(paren
op_star
id|the10Locations.hdr.blkDescLengthMSB
op_ne
l_int|0
)paren
multiline_comment|/* MSB must be zero */
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|USB_STORAGE
l_string|&quot;Command will be truncated to fit in SENSE6 buffer.&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|the6Locations.hdr.blkDescLength
op_assign
l_int|0xff
suffix:semicolon
)brace
r_else
(brace
op_star
id|the6Locations.hdr.blkDescLength
op_assign
op_star
id|the10Locations.hdr.blkDescLengthLSB
suffix:semicolon
)brace
r_if
c_cond
(paren
id|the10-&gt;use_sg
op_eq
l_int|0
)paren
(brace
id|buffer
op_assign
id|the10-&gt;request_buffer
suffix:semicolon
multiline_comment|/* Copy the rest of the data */
id|memmove
c_func
(paren
op_amp
(paren
id|buffer
(braket
id|USB_STOR_SCSI_SENSE_HDRSZ
)braket
)paren
comma
op_amp
(paren
id|buffer
(braket
id|USB_STOR_SCSI_SENSE_10_HDRSZ
)braket
)paren
comma
id|outputBufferSize
op_minus
id|USB_STOR_SCSI_SENSE_HDRSZ
)paren
suffix:semicolon
multiline_comment|/* initialise last bytes left in buffer due to smaller header */
id|memset
c_func
(paren
op_amp
(paren
id|buffer
(braket
id|outputBufferSize
op_minus
(paren
id|USB_STOR_SCSI_SENSE_10_HDRSZ
op_minus
id|USB_STOR_SCSI_SENSE_HDRSZ
)paren
)braket
)paren
comma
l_int|0
comma
id|USB_STOR_SCSI_SENSE_10_HDRSZ
op_minus
id|USB_STOR_SCSI_SENSE_HDRSZ
)paren
suffix:semicolon
)brace
r_else
(brace
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|the10-&gt;request_buffer
suffix:semicolon
multiline_comment|/* scan through this scatterlist and figure out starting positions */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|the10-&gt;use_sg
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sgLength
op_assign
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|sgLength
suffix:semicolon
id|j
op_increment
)paren
(brace
multiline_comment|/* get to end of header */
r_if
c_cond
(paren
id|element
op_eq
id|USB_STOR_SCSI_SENSE_HDRSZ
)paren
(brace
id|db
op_assign
id|i
suffix:semicolon
id|di
op_assign
id|j
suffix:semicolon
)brace
r_if
c_cond
(paren
id|element
op_eq
id|USB_STOR_SCSI_SENSE_10_HDRSZ
)paren
(brace
id|sb
op_assign
id|i
suffix:semicolon
id|si
op_assign
id|j
suffix:semicolon
multiline_comment|/* we&squot;ve found both sets now, exit loops */
id|j
op_assign
id|sgLength
suffix:semicolon
id|i
op_assign
id|the10-&gt;use_sg
suffix:semicolon
)brace
id|element
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* Now we know where to start the copy from */
id|element
op_assign
id|USB_STOR_SCSI_SENSE_HDRSZ
suffix:semicolon
r_while
c_loop
(paren
id|element
OL
id|outputBufferSize
op_minus
(paren
id|USB_STOR_SCSI_SENSE_10_HDRSZ
op_minus
id|USB_STOR_SCSI_SENSE_HDRSZ
)paren
)paren
(brace
multiline_comment|/* check limits */
r_if
c_cond
(paren
id|sb
op_ge
id|the10-&gt;use_sg
op_logical_or
id|si
op_ge
id|sg
(braket
id|sb
)braket
dot
id|length
op_logical_or
id|db
op_ge
id|the10-&gt;use_sg
op_logical_or
id|di
op_ge
id|sg
(braket
id|db
)braket
dot
id|length
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|USB_STORAGE
l_string|&quot;Buffer overrun averted, this shouldn&squot;t happen!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* copy one byte */
(brace
r_char
op_star
id|src
op_assign
id|sg_address
c_func
(paren
id|sg
(braket
id|sb
)braket
)paren
op_plus
id|si
suffix:semicolon
r_char
op_star
id|dst
op_assign
id|sg_address
c_func
(paren
id|sg
(braket
id|db
)braket
)paren
op_plus
id|di
suffix:semicolon
op_star
id|dst
op_assign
op_star
id|src
suffix:semicolon
)brace
multiline_comment|/* get next destination */
r_if
c_cond
(paren
id|sg
(braket
id|db
)braket
dot
id|length
op_minus
l_int|1
op_eq
id|di
)paren
(brace
id|db
op_increment
suffix:semicolon
id|di
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|di
op_increment
suffix:semicolon
)brace
multiline_comment|/* get next source */
r_if
c_cond
(paren
id|sg
(braket
id|sb
)braket
dot
id|length
op_minus
l_int|1
op_eq
id|si
)paren
(brace
id|sb
op_increment
suffix:semicolon
id|si
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|si
op_increment
suffix:semicolon
)brace
id|element
op_increment
suffix:semicolon
)brace
multiline_comment|/* zero the remaining bytes */
r_while
c_loop
(paren
id|element
OL
id|outputBufferSize
)paren
(brace
multiline_comment|/* check limits */
r_if
c_cond
(paren
id|db
op_ge
id|the10-&gt;use_sg
op_logical_or
id|di
op_ge
id|sg
(braket
id|db
)braket
dot
id|length
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|USB_STORAGE
l_string|&quot;Buffer overrun averted, this shouldn&squot;t happen!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
op_star
(paren
r_char
op_star
)paren
(paren
id|sg_address
c_func
(paren
id|sg
(braket
id|db
)braket
)paren
)paren
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* get next destination */
r_if
c_cond
(paren
id|sg
(braket
id|db
)braket
dot
id|length
op_minus
l_int|1
op_eq
id|di
)paren
(brace
id|db
op_increment
suffix:semicolon
id|di
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|di
op_increment
suffix:semicolon
)brace
id|element
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* All done any everything was fine */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usb_stor_scsiSense6to10
r_int
id|usb_stor_scsiSense6to10
c_func
(paren
id|Scsi_Cmnd
op_star
id|the6
)paren
(brace
multiline_comment|/* will be used to store part of buffer */
id|__u8
id|tempBuffer
(braket
id|USB_STOR_SCSI_SENSE_10_HDRSZ
op_minus
id|USB_STOR_SCSI_SENSE_HDRSZ
)braket
comma
op_star
id|buffer
op_assign
l_int|0
suffix:semicolon
r_int
id|outputBufferSize
op_assign
l_int|0
suffix:semicolon
r_int
id|length
op_assign
l_int|0
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
op_assign
l_int|0
suffix:semicolon
r_int
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
comma
id|element
op_assign
l_int|0
suffix:semicolon
id|Usb_Stor_Scsi_Sense_Hdr_u
id|the6Locations
suffix:semicolon
id|Usb_Stor_Scsi_Sense_Hdr_10_u
id|the10Locations
suffix:semicolon
r_int
id|sb
op_assign
l_int|0
comma
id|si
op_assign
l_int|0
comma
id|db
op_assign
l_int|0
comma
id|di
op_assign
l_int|0
suffix:semicolon
r_int
id|lsb
op_assign
l_int|0
comma
id|lsi
op_assign
l_int|0
comma
id|ldb
op_assign
l_int|0
comma
id|ldi
op_assign
l_int|0
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- converting 6 byte sense data to 10 byte&bslash;n&quot;
)paren
suffix:semicolon
id|the6-&gt;cmnd
(braket
l_int|0
)braket
op_assign
id|the6-&gt;cmnd
(braket
l_int|0
)braket
op_or
l_int|0x40
suffix:semicolon
multiline_comment|/* Determine buffer locations */
id|usb_stor_scsiSenseParseBuffer
c_func
(paren
id|the6
comma
op_amp
id|the6Locations
comma
op_amp
id|the10Locations
comma
op_amp
id|length
)paren
suffix:semicolon
multiline_comment|/* Work out minimum buffer to output */
id|outputBufferSize
op_assign
op_star
id|the6Locations.hdr.dataLength
suffix:semicolon
id|outputBufferSize
op_add_assign
id|USB_STOR_SCSI_SENSE_10_HDRSZ
suffix:semicolon
multiline_comment|/* Check to see if we need to trucate the output */
r_if
c_cond
(paren
id|outputBufferSize
OG
id|length
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|USB_STORAGE
l_string|&quot;Had to truncate MODE_SENSE into MODE_SENSE_10 buffer.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
id|USB_STORAGE
l_string|&quot;outputBufferSize is %d and length is %d.&bslash;n&quot;
comma
id|outputBufferSize
comma
id|length
)paren
suffix:semicolon
)brace
id|outputBufferSize
op_assign
id|length
suffix:semicolon
multiline_comment|/* Block descriptor length - save these before overwriting */
id|tempBuffer
(braket
l_int|2
)braket
op_assign
op_star
id|the10Locations.hdr.blkDescLengthMSB
suffix:semicolon
id|tempBuffer
(braket
l_int|3
)braket
op_assign
op_star
id|the10Locations.hdr.blkDescLengthLSB
suffix:semicolon
op_star
id|the10Locations.hdr.blkDescLengthLSB
op_assign
op_star
id|the6Locations.hdr.blkDescLength
suffix:semicolon
op_star
id|the10Locations.hdr.blkDescLengthMSB
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* reserved - save these before overwriting */
id|tempBuffer
(braket
l_int|0
)braket
op_assign
op_star
id|the10Locations.hdr.reserved1
suffix:semicolon
id|tempBuffer
(braket
l_int|1
)braket
op_assign
op_star
id|the10Locations.hdr.reserved2
suffix:semicolon
op_star
id|the10Locations.hdr.reserved1
op_assign
op_star
id|the10Locations.hdr.reserved2
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Medium type and DevSpecific parms */
op_star
id|the10Locations.hdr.devSpecParms
op_assign
op_star
id|the6Locations.hdr.devSpecParms
suffix:semicolon
op_star
id|the10Locations.hdr.mediumType
op_assign
op_star
id|the6Locations.hdr.mediumType
suffix:semicolon
multiline_comment|/* Data length */
op_star
id|the10Locations.hdr.dataLengthLSB
op_assign
op_star
id|the6Locations.hdr.dataLength
suffix:semicolon
op_star
id|the10Locations.hdr.dataLengthMSB
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|the6-&gt;use_sg
)paren
(brace
id|buffer
op_assign
id|the6-&gt;request_buffer
suffix:semicolon
multiline_comment|/* Copy the rest of the data */
id|memmove
c_func
(paren
op_amp
(paren
id|buffer
(braket
id|USB_STOR_SCSI_SENSE_10_HDRSZ
)braket
)paren
comma
op_amp
(paren
id|buffer
(braket
id|USB_STOR_SCSI_SENSE_HDRSZ
)braket
)paren
comma
id|outputBufferSize
op_minus
id|USB_STOR_SCSI_SENSE_10_HDRSZ
)paren
suffix:semicolon
multiline_comment|/* Put the first four bytes (after header) in place */
id|memcpy
c_func
(paren
op_amp
(paren
id|buffer
(braket
id|USB_STOR_SCSI_SENSE_10_HDRSZ
)braket
)paren
comma
id|tempBuffer
comma
id|USB_STOR_SCSI_SENSE_10_HDRSZ
op_minus
id|USB_STOR_SCSI_SENSE_HDRSZ
)paren
suffix:semicolon
)brace
r_else
(brace
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|the6-&gt;request_buffer
suffix:semicolon
multiline_comment|/* scan through this scatterlist and figure out ending positions */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|the6-&gt;use_sg
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
id|j
op_increment
)paren
(brace
multiline_comment|/* get to end of header */
r_if
c_cond
(paren
id|element
op_eq
id|USB_STOR_SCSI_SENSE_HDRSZ
)paren
(brace
id|ldb
op_assign
id|i
suffix:semicolon
id|ldi
op_assign
id|j
suffix:semicolon
)brace
r_if
c_cond
(paren
id|element
op_eq
id|USB_STOR_SCSI_SENSE_10_HDRSZ
)paren
(brace
id|lsb
op_assign
id|i
suffix:semicolon
id|lsi
op_assign
id|j
suffix:semicolon
multiline_comment|/* we&squot;ve found both sets now, exit loops */
id|j
op_assign
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
id|i
op_assign
id|the6-&gt;use_sg
suffix:semicolon
r_break
suffix:semicolon
)brace
id|element
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* scan through this scatterlist and figure out starting positions */
id|element
op_assign
id|length
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* destination is the last element */
id|db
op_assign
id|the6-&gt;use_sg
op_minus
l_int|1
suffix:semicolon
id|di
op_assign
id|sg
(braket
id|db
)braket
dot
id|length
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|the6-&gt;use_sg
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
id|sg
(braket
id|i
)braket
dot
id|length
op_minus
l_int|1
suffix:semicolon
id|j
op_ge
l_int|0
suffix:semicolon
id|j
op_decrement
)paren
(brace
multiline_comment|/* get to end of header and find source for copy */
r_if
c_cond
(paren
id|element
op_eq
id|length
op_minus
l_int|1
op_minus
(paren
id|USB_STOR_SCSI_SENSE_10_HDRSZ
op_minus
id|USB_STOR_SCSI_SENSE_HDRSZ
)paren
)paren
(brace
id|sb
op_assign
id|i
suffix:semicolon
id|si
op_assign
id|j
suffix:semicolon
multiline_comment|/* we&squot;ve found both sets now, exit loops */
id|j
op_assign
op_minus
l_int|1
suffix:semicolon
id|i
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|element
op_decrement
suffix:semicolon
)brace
)brace
multiline_comment|/* Now we know where to start the copy from */
id|element
op_assign
id|length
op_minus
l_int|1
op_minus
(paren
id|USB_STOR_SCSI_SENSE_10_HDRSZ
op_minus
id|USB_STOR_SCSI_SENSE_HDRSZ
)paren
suffix:semicolon
r_while
c_loop
(paren
id|element
op_ge
id|USB_STOR_SCSI_SENSE_10_HDRSZ
)paren
(brace
multiline_comment|/* check limits */
r_if
c_cond
(paren
(paren
id|sb
op_le
id|lsb
op_logical_and
id|si
OL
id|lsi
)paren
op_logical_or
(paren
id|db
op_le
id|ldb
op_logical_and
id|di
OL
id|ldi
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|USB_STORAGE
l_string|&quot;Buffer overrun averted, this shouldn&squot;t happen!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* copy one byte */
(brace
r_char
op_star
id|src
op_assign
id|sg_address
c_func
(paren
id|sg
(braket
id|sb
)braket
)paren
op_plus
id|si
suffix:semicolon
r_char
op_star
id|dst
op_assign
id|sg_address
c_func
(paren
id|sg
(braket
id|db
)braket
)paren
op_plus
id|di
suffix:semicolon
op_star
id|dst
op_assign
op_star
id|src
suffix:semicolon
)brace
multiline_comment|/* get next destination */
r_if
c_cond
(paren
id|di
op_eq
l_int|0
)paren
(brace
id|db
op_decrement
suffix:semicolon
id|di
op_assign
id|sg
(braket
id|db
)braket
dot
id|length
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|di
op_decrement
suffix:semicolon
)brace
multiline_comment|/* get next source */
r_if
c_cond
(paren
id|si
op_eq
l_int|0
)paren
(brace
id|sb
op_decrement
suffix:semicolon
id|si
op_assign
id|sg
(braket
id|sb
)braket
dot
id|length
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|si
op_decrement
suffix:semicolon
)brace
id|element
op_decrement
suffix:semicolon
)brace
multiline_comment|/* copy the remaining four bytes */
r_while
c_loop
(paren
id|element
op_ge
id|USB_STOR_SCSI_SENSE_HDRSZ
)paren
(brace
multiline_comment|/* check limits */
r_if
c_cond
(paren
id|db
op_le
id|ldb
op_logical_and
id|di
OL
id|ldi
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|USB_STORAGE
l_string|&quot;Buffer overrun averted, this shouldn&squot;t happen!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
(brace
r_char
op_star
id|dst
op_assign
id|sg_address
c_func
(paren
id|sg
(braket
id|db
)braket
)paren
op_plus
id|di
suffix:semicolon
op_star
id|dst
op_assign
id|tempBuffer
(braket
id|element
op_minus
id|USB_STOR_SCSI_SENSE_HDRSZ
)braket
suffix:semicolon
)brace
multiline_comment|/* get next destination */
r_if
c_cond
(paren
id|di
op_eq
l_int|0
)paren
(brace
id|db
op_decrement
suffix:semicolon
id|di
op_assign
id|sg
(braket
id|db
)braket
dot
id|length
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|di
op_decrement
suffix:semicolon
)brace
id|element
op_decrement
suffix:semicolon
)brace
)brace
multiline_comment|/* All done and everything was fine */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usb_stor_scsiSenseParseBuffer
r_void
id|usb_stor_scsiSenseParseBuffer
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
id|Usb_Stor_Scsi_Sense_Hdr_u
op_star
id|the6
comma
id|Usb_Stor_Scsi_Sense_Hdr_10_u
op_star
id|the10
comma
r_int
op_star
id|length_p
)paren
(brace
r_int
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
comma
id|element
op_assign
l_int|0
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
op_assign
l_int|0
suffix:semicolon
r_int
id|length
op_assign
l_int|0
suffix:semicolon
id|__u8
op_star
id|buffer
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* are we scatter-gathering? */
r_if
c_cond
(paren
id|srb-&gt;use_sg
op_ne
l_int|0
)paren
(brace
multiline_comment|/* loop over all the scatter gather structures and &n;       * get pointer to the data members in the headers&n;       * (also work out the length while we&squot;re here)&n;       */
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|srb-&gt;request_buffer
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|srb-&gt;use_sg
suffix:semicolon
id|i
op_increment
)paren
(brace
id|length
op_add_assign
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
multiline_comment|/* We only do the inner loop for the headers */
r_if
c_cond
(paren
id|element
OL
id|USB_STOR_SCSI_SENSE_10_HDRSZ
)paren
(brace
multiline_comment|/* scan through this scatterlist */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|element
OL
id|USB_STOR_SCSI_SENSE_HDRSZ
)paren
(brace
multiline_comment|/* fill in the pointers for both header types */
id|the6-&gt;array
(braket
id|element
)braket
op_assign
id|sg_address
c_func
(paren
id|sg
(braket
id|i
)braket
)paren
op_plus
id|j
suffix:semicolon
id|the10-&gt;array
(braket
id|element
)braket
op_assign
id|sg_address
c_func
(paren
id|sg
(braket
id|i
)braket
)paren
op_plus
id|j
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|element
OL
id|USB_STOR_SCSI_SENSE_10_HDRSZ
)paren
(brace
multiline_comment|/* only the longer headers still cares now */
id|the10-&gt;array
(braket
id|element
)braket
op_assign
id|sg_address
c_func
(paren
id|sg
(braket
id|i
)braket
)paren
op_plus
id|j
suffix:semicolon
)brace
multiline_comment|/* increase element counter */
id|element
op_increment
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
(brace
id|length
op_assign
id|srb-&gt;request_bufflen
suffix:semicolon
id|buffer
op_assign
id|srb-&gt;request_buffer
suffix:semicolon
r_if
c_cond
(paren
id|length
OL
id|USB_STOR_SCSI_SENSE_10_HDRSZ
)paren
id|printk
c_func
(paren
id|KERN_ERR
id|USB_STORAGE
l_string|&quot;Buffer length smaller than header!!&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|USB_STOR_SCSI_SENSE_10_HDRSZ
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
OL
id|USB_STOR_SCSI_SENSE_HDRSZ
)paren
(brace
id|the6-&gt;array
(braket
id|i
)braket
op_assign
op_amp
(paren
id|buffer
(braket
id|i
)braket
)paren
suffix:semicolon
id|the10-&gt;array
(braket
id|i
)braket
op_assign
op_amp
(paren
id|buffer
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|the10-&gt;array
(braket
id|i
)braket
op_assign
op_amp
(paren
id|buffer
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Set value of length passed in */
op_star
id|length_p
op_assign
id|length
suffix:semicolon
)brace
eof
