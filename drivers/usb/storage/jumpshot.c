multiline_comment|/* Driver for Lexar &quot;Jumpshot&quot; Compact Flash reader&n; *&n; * jumpshot driver v0.1:&n; *&n; * First release&n; *&n; * Current development and maintenance by:&n; *   (c) 2000 Jimmie Mayfield (mayfield+usb@sackheads.org)&n; *   many thanks to Robert Baruch for the SanDisk SmartMedia reader driver&n; *   which I used as a template for this driver.&n; *   Some bugfixes and scatter-gather code by Gregory P. Smith &n; *   (greg-usb@electricrain.com)&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2, or (at your option) any&n; * later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write to the Free Software Foundation, Inc.,&n; * 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
multiline_comment|/*&n;  * This driver attempts to support the Lexar Jumpshot USB CompactFlash &n;  * reader.  Like many other USB CompactFlash readers, the Jumpshot contains&n;  * a USB-to-ATA chip. &n;  *&n;  * This driver supports reading and writing.  If you&squot;re truly paranoid,&n;  * however, you can force the driver into a write-protected state by setting&n;  * the WP enable bits in jumpshot_handle_mode_sense.  Basically this means&n;  * setting mode_param_header[3] = 0x80.  &n;  */
macro_line|#include &quot;transport.h&quot;
macro_line|#include &quot;protocol.h&quot;
macro_line|#include &quot;usb.h&quot;
macro_line|#include &quot;debug.h&quot;
macro_line|#include &quot;jumpshot.h&quot;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
r_extern
r_int
id|usb_stor_control_msg
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|pipe
comma
id|u8
id|request
comma
id|u8
id|requesttype
comma
id|u16
id|value
comma
id|u16
id|index
comma
r_void
op_star
id|data
comma
id|u16
id|size
)paren
suffix:semicolon
r_extern
r_int
id|usb_stor_bulk_msg
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_void
op_star
id|data
comma
r_int
id|pipe
comma
r_int
r_int
id|len
comma
r_int
r_int
op_star
id|act_len
)paren
suffix:semicolon
macro_line|#if 0
r_static
r_void
id|jumpshot_dump_data
c_func
(paren
r_int
r_char
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_int
r_char
id|buf
(braket
l_int|80
)braket
suffix:semicolon
r_int
id|sofar
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_return
suffix:semicolon
id|memset
c_func
(paren
id|buf
comma
l_int|0
comma
r_sizeof
(paren
id|buf
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sofar
op_assign
l_int|0
suffix:semicolon
id|sofar
OL
id|len
suffix:semicolon
id|sofar
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|buf
op_plus
id|strlen
c_func
(paren
id|buf
)paren
comma
l_string|&quot;%02x &quot;
comma
(paren
(paren
r_int
r_int
)paren
id|data
(braket
id|sofar
)braket
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sofar
op_mod
l_int|16
op_eq
l_int|15
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot:  %s&bslash;n&quot;
comma
id|buf
)paren
suffix:semicolon
id|memset
c_func
(paren
id|buf
comma
l_int|0
comma
r_sizeof
(paren
id|buf
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|buf
)paren
op_ne
l_int|0
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot:  %s&bslash;n&quot;
comma
id|buf
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Send a control message and wait for the response.&n; *&n; * us - the pointer to the us_data structure for the device to use&n; *&n; * request - the URB Setup Packet&squot;s first 6 bytes. The first byte always&n; *  corresponds to the request type, and the second byte always corresponds&n; *  to the request.  The other 4 bytes do not correspond to value and index,&n; *  since they are used in a custom way by the SCM protocol.&n; *&n; * xfer_data - a buffer from which to get, or to which to store, any data&n; *  that gets send or received, respectively, with the URB. Even though&n; *  it looks like we allocate a buffer in this code for the data, xfer_data&n; *  must contain enough allocated space.&n; *&n; * xfer_len - the number of bytes to send or receive with the URB.&n; *&n; * This routine snarfed from the SanDisk SDDR-09 driver&n; *&n; */
DECL|function|jumpshot_send_control
r_static
r_int
id|jumpshot_send_control
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
id|pipe
comma
r_int
r_char
id|request
comma
r_int
r_char
id|requesttype
comma
r_int
r_int
id|value
comma
r_int
r_int
id|index
comma
r_int
r_char
op_star
id|xfer_data
comma
r_int
r_int
id|xfer_len
)paren
(brace
r_int
id|result
suffix:semicolon
singleline_comment|// Send the URB to the device and wait for a response.
multiline_comment|/* Why are request and request type reversed in this call? */
id|result
op_assign
id|usb_stor_control_msg
c_func
(paren
id|us
comma
id|pipe
comma
id|request
comma
id|requesttype
comma
id|value
comma
id|index
comma
id|xfer_data
comma
id|xfer_len
)paren
suffix:semicolon
singleline_comment|// Check the return code for the command.
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
multiline_comment|/* if the command was aborted, indicate that */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ENOENT
)paren
r_return
id|USB_STOR_TRANSPORT_ABORTED
suffix:semicolon
multiline_comment|/* a stall is a fatal condition from the device */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_send_control:  -- Stall on control pipe. Clearing&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|pipe
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_send_control:  -- usb_clear_halt() returns %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
multiline_comment|/* Uh oh... serious problem here */
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
DECL|function|jumpshot_raw_bulk
r_static
r_int
id|jumpshot_raw_bulk
c_func
(paren
r_int
id|direction
comma
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|data
comma
r_int
r_int
id|len
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
id|act_len
suffix:semicolon
r_int
id|pipe
suffix:semicolon
r_if
c_cond
(paren
id|direction
op_eq
id|SCSI_DATA_READ
)paren
id|pipe
op_assign
id|usb_rcvbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;ep_in
)paren
suffix:semicolon
r_else
id|pipe
op_assign
id|usb_sndbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;ep_out
)paren
suffix:semicolon
id|result
op_assign
id|usb_stor_bulk_msg
c_func
(paren
id|us
comma
id|data
comma
id|pipe
comma
id|len
comma
op_amp
id|act_len
)paren
suffix:semicolon
singleline_comment|// if we stall, we need to clear it before we go on
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_raw_bulk:  EPIPE. clearing endpoint halt for&quot;
l_string|&quot; pipe 0x%x, stalled at %d bytes&bslash;n&quot;
comma
id|pipe
comma
id|act_len
)paren
suffix:semicolon
id|usb_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|pipe
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
)paren
(brace
singleline_comment|// NAK - that means we&squot;ve retried a few times already
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ETIMEDOUT
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_raw_bulk:  device NAKed&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|US_BULK_TRANSFER_FAILED
suffix:semicolon
)brace
singleline_comment|// -ENOENT -- we canceled this transfer
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ENOENT
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_raw_bulk:  transfer aborted&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|US_BULK_TRANSFER_ABORTED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_raw_bulk:  output pipe stalled&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
singleline_comment|// the catch-all case
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_raw_bulk:  unknown error&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|US_BULK_TRANSFER_FAILED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|act_len
op_ne
id|len
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_raw_bulk:  Warning. Transferred only %d bytes&bslash;n&quot;
comma
id|act_len
)paren
suffix:semicolon
r_return
id|US_BULK_TRANSFER_SHORT
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_raw_bulk:  Transfered %d of %d bytes&bslash;n&quot;
comma
id|act_len
comma
id|len
)paren
suffix:semicolon
r_return
id|US_BULK_TRANSFER_GOOD
suffix:semicolon
)brace
DECL|function|jumpshot_bulk_read
r_static
r_inline
r_int
id|jumpshot_bulk_read
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|data
comma
r_int
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_bulk_read:  len = %d&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
r_return
id|jumpshot_raw_bulk
c_func
(paren
id|SCSI_DATA_READ
comma
id|us
comma
id|data
comma
id|len
)paren
suffix:semicolon
)brace
DECL|function|jumpshot_bulk_write
r_static
r_inline
r_int
id|jumpshot_bulk_write
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|data
comma
r_int
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_bulk_write:  len = %d&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
r_return
id|jumpshot_raw_bulk
c_func
(paren
id|SCSI_DATA_WRITE
comma
id|us
comma
id|data
comma
id|len
)paren
suffix:semicolon
)brace
DECL|function|jumpshot_get_status
r_static
r_int
id|jumpshot_get_status
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
r_char
id|reply
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|us
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
singleline_comment|// send the setup
id|rc
op_assign
id|jumpshot_send_control
c_func
(paren
id|us
comma
id|usb_rcvctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
comma
l_int|0
comma
l_int|0xA0
comma
l_int|0
comma
l_int|7
comma
op_amp
id|reply
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|reply
op_ne
l_int|0x50
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_get_status:  0x%2x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
(paren
id|reply
)paren
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
DECL|function|jumpshot_read_data
r_static
r_int
id|jumpshot_read_data
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_struct
id|jumpshot_info
op_star
id|info
comma
id|u32
id|sector
comma
id|u32
id|sectors
comma
r_int
r_char
op_star
id|dest
comma
r_int
id|use_sg
)paren
(brace
r_int
r_char
id|command
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0xe0
comma
l_int|0x20
)brace
suffix:semicolon
r_int
r_char
op_star
id|buffer
op_assign
l_int|NULL
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_int
r_char
id|thistime
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
op_assign
l_int|NULL
suffix:semicolon
r_int
id|totallen
comma
id|len
comma
id|result
suffix:semicolon
r_int
id|sg_idx
op_assign
l_int|0
comma
id|current_sg_offset
op_assign
l_int|0
suffix:semicolon
r_int
id|transferred
suffix:semicolon
singleline_comment|// we&squot;re working in LBA mode.  according to the ATA spec, 
singleline_comment|// we can support up to 28-bit addressing.  I don&squot;t know if Jumpshot
singleline_comment|// supports beyond 24-bit addressing.  It&squot;s kind of hard to test 
singleline_comment|// since it requires &gt; 8GB CF card.
singleline_comment|//
r_if
c_cond
(paren
id|sector
OG
l_int|0x0FFFFFFF
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
singleline_comment|// If we&squot;re using scatter-gather, we have to create a new
singleline_comment|// buffer to read all of the data in first, since a
singleline_comment|// scatter-gather buffer could in theory start in the middle
singleline_comment|// of a page, which would be bad. A developer who wants a
singleline_comment|// challenge might want to write a limited-buffer
singleline_comment|// version of this code.
id|totallen
op_assign
id|sectors
op_star
id|info-&gt;ssize
suffix:semicolon
r_do
(brace
singleline_comment|// loop, never allocate or transfer more than 64k at once (min(128k, 255*info-&gt;ssize) is the real limit)
id|len
op_assign
id|min
c_func
(paren
id|totallen
comma
l_int|65536
)paren
suffix:semicolon
r_if
c_cond
(paren
id|use_sg
)paren
(brace
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|dest
suffix:semicolon
id|buffer
op_assign
id|kmalloc
c_func
(paren
id|len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
op_eq
l_int|NULL
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|ptr
op_assign
id|buffer
suffix:semicolon
)brace
r_else
(brace
id|ptr
op_assign
id|dest
suffix:semicolon
)brace
id|thistime
op_assign
(paren
id|len
op_div
id|info-&gt;ssize
)paren
op_amp
l_int|0xff
suffix:semicolon
id|command
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|command
(braket
l_int|1
)braket
op_assign
id|thistime
suffix:semicolon
id|command
(braket
l_int|2
)braket
op_assign
id|sector
op_amp
l_int|0xFF
suffix:semicolon
id|command
(braket
l_int|3
)braket
op_assign
(paren
id|sector
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|command
(braket
l_int|4
)braket
op_assign
(paren
id|sector
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|command
(braket
l_int|5
)braket
op_or_assign
(paren
id|sector
op_rshift
l_int|24
)paren
op_amp
l_int|0x0F
suffix:semicolon
singleline_comment|// send the setup + command
id|result
op_assign
id|jumpshot_send_control
c_func
(paren
id|us
comma
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
comma
l_int|0
comma
l_int|0x20
comma
l_int|0
comma
l_int|1
comma
id|command
comma
l_int|7
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
r_if
c_cond
(paren
id|use_sg
)paren
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
singleline_comment|// read the result
id|result
op_assign
id|jumpshot_bulk_read
c_func
(paren
id|us
comma
id|ptr
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
r_if
c_cond
(paren
id|use_sg
)paren
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_read_data:  %d bytes&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
singleline_comment|//jumpshot_dump_data(ptr, len);
id|sectors
op_sub_assign
id|thistime
suffix:semicolon
id|sector
op_add_assign
id|thistime
suffix:semicolon
r_if
c_cond
(paren
id|use_sg
)paren
(brace
id|transferred
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|sg_idx
OL
id|use_sg
op_logical_and
id|transferred
OL
id|len
)paren
(brace
r_if
c_cond
(paren
id|len
op_minus
id|transferred
op_ge
id|sg
(braket
id|sg_idx
)braket
dot
id|length
op_minus
id|current_sg_offset
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_read_data:  adding %d bytes to %d byte sg buffer&bslash;n&quot;
comma
id|sg
(braket
id|sg_idx
)braket
dot
id|length
op_minus
id|current_sg_offset
comma
id|sg
(braket
id|sg_idx
)braket
dot
id|length
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|sg
(braket
id|sg_idx
)braket
dot
id|address
op_plus
id|current_sg_offset
comma
id|buffer
op_plus
id|transferred
comma
id|sg
(braket
id|sg_idx
)braket
dot
id|length
op_minus
id|current_sg_offset
)paren
suffix:semicolon
id|transferred
op_add_assign
id|sg
(braket
id|sg_idx
)braket
dot
id|length
op_minus
id|current_sg_offset
suffix:semicolon
id|current_sg_offset
op_assign
l_int|0
suffix:semicolon
singleline_comment|// on to the next sg buffer
op_increment
id|sg_idx
suffix:semicolon
)brace
r_else
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_read_data:  adding %d bytes to %d byte sg buffer&bslash;n&quot;
comma
id|len
op_minus
id|transferred
comma
id|sg
(braket
id|sg_idx
)braket
dot
id|length
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|sg
(braket
id|sg_idx
)braket
dot
id|address
op_plus
id|current_sg_offset
comma
id|buffer
op_plus
id|transferred
comma
id|len
op_minus
id|transferred
)paren
suffix:semicolon
id|current_sg_offset
op_add_assign
id|len
op_minus
id|transferred
suffix:semicolon
singleline_comment|// this sg buffer is only partially full and we&squot;re out of data to copy in
r_break
suffix:semicolon
)brace
)brace
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
)brace
r_else
(brace
id|dest
op_add_assign
id|len
suffix:semicolon
)brace
id|totallen
op_sub_assign
id|len
suffix:semicolon
)brace
r_while
c_loop
(paren
id|totallen
OG
l_int|0
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
DECL|function|jumpshot_write_data
r_static
r_int
id|jumpshot_write_data
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_struct
id|jumpshot_info
op_star
id|info
comma
id|u32
id|sector
comma
id|u32
id|sectors
comma
r_int
r_char
op_star
id|src
comma
r_int
id|use_sg
)paren
(brace
r_int
r_char
id|command
(braket
l_int|7
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0xE0
comma
l_int|0x30
)brace
suffix:semicolon
r_int
r_char
op_star
id|buffer
op_assign
l_int|NULL
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_int
r_char
id|thistime
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
op_assign
l_int|NULL
suffix:semicolon
r_int
id|totallen
comma
id|len
comma
id|result
comma
id|waitcount
suffix:semicolon
r_int
id|sg_idx
op_assign
l_int|0
comma
id|current_sg_offset
op_assign
l_int|0
suffix:semicolon
r_int
id|transferred
suffix:semicolon
singleline_comment|// we&squot;re working in LBA mode.  according to the ATA spec, 
singleline_comment|// we can support up to 28-bit addressing.  I don&squot;t know if Jumpshot
singleline_comment|// supports beyond 24-bit addressing.  It&squot;s kind of hard to test 
singleline_comment|// since it requires &gt; 8GB CF card.
singleline_comment|//
r_if
c_cond
(paren
id|sector
OG
l_int|0x0FFFFFFF
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
singleline_comment|// If we&squot;re using scatter-gather, we have to create a new
singleline_comment|// buffer to read all of the data in first, since a
singleline_comment|// scatter-gather buffer could in theory start in the middle
singleline_comment|// of a page, which would be bad. A developer who wants a
singleline_comment|// challenge might want to write a limited-buffer
singleline_comment|// version of this code.
id|totallen
op_assign
id|sectors
op_star
id|info-&gt;ssize
suffix:semicolon
r_do
(brace
singleline_comment|// loop, never allocate or transfer more than 64k at once (min(128k, 255*info-&gt;ssize) is the real limit)
id|len
op_assign
id|min
c_func
(paren
id|totallen
comma
l_int|65536
)paren
suffix:semicolon
r_if
c_cond
(paren
id|use_sg
)paren
(brace
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|src
suffix:semicolon
id|buffer
op_assign
id|kmalloc
c_func
(paren
id|len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
op_eq
l_int|NULL
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|ptr
op_assign
id|buffer
suffix:semicolon
id|memset
c_func
(paren
id|buffer
comma
l_int|0
comma
id|len
)paren
suffix:semicolon
singleline_comment|// copy the data from the sg bufs into the big contiguous buf
singleline_comment|//
id|transferred
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|transferred
OL
id|len
)paren
(brace
r_if
c_cond
(paren
id|len
op_minus
id|transferred
op_ge
id|sg
(braket
id|sg_idx
)braket
dot
id|length
op_minus
id|current_sg_offset
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_write_data:  getting %d bytes from %d byte sg buffer&bslash;n&quot;
comma
id|sg
(braket
id|sg_idx
)braket
dot
id|length
op_minus
id|current_sg_offset
comma
id|sg
(braket
id|sg_idx
)braket
dot
id|length
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
op_plus
id|transferred
comma
id|sg
(braket
id|sg_idx
)braket
dot
id|address
op_plus
id|current_sg_offset
comma
id|sg
(braket
id|sg_idx
)braket
dot
id|length
op_minus
id|current_sg_offset
)paren
suffix:semicolon
id|transferred
op_add_assign
id|sg
(braket
id|sg_idx
)braket
dot
id|length
op_minus
id|current_sg_offset
suffix:semicolon
id|current_sg_offset
op_assign
l_int|0
suffix:semicolon
singleline_comment|// on to the next sg buffer
op_increment
id|sg_idx
suffix:semicolon
)brace
r_else
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_write_data:  getting %d bytes from %d byte sg buffer&bslash;n&quot;
comma
id|len
op_minus
id|transferred
comma
id|sg
(braket
id|sg_idx
)braket
dot
id|length
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
op_plus
id|transferred
comma
id|sg
(braket
id|sg_idx
)braket
dot
id|address
op_plus
id|current_sg_offset
comma
id|len
op_minus
id|transferred
)paren
suffix:semicolon
id|current_sg_offset
op_add_assign
id|len
op_minus
id|transferred
suffix:semicolon
singleline_comment|// we only copied part of this sg buffer
r_break
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|ptr
op_assign
id|src
suffix:semicolon
)brace
id|thistime
op_assign
(paren
id|len
op_div
id|info-&gt;ssize
)paren
op_amp
l_int|0xff
suffix:semicolon
id|command
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|command
(braket
l_int|1
)braket
op_assign
id|thistime
suffix:semicolon
id|command
(braket
l_int|2
)braket
op_assign
id|sector
op_amp
l_int|0xFF
suffix:semicolon
id|command
(braket
l_int|3
)braket
op_assign
(paren
id|sector
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|command
(braket
l_int|4
)braket
op_assign
(paren
id|sector
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|command
(braket
l_int|5
)braket
op_or_assign
(paren
id|sector
op_rshift
l_int|24
)paren
op_amp
l_int|0x0F
suffix:semicolon
singleline_comment|// send the setup + command
id|result
op_assign
id|jumpshot_send_control
c_func
(paren
id|us
comma
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
comma
l_int|0
comma
l_int|0x20
comma
l_int|0
comma
l_int|1
comma
id|command
comma
l_int|7
)paren
suffix:semicolon
singleline_comment|// send the data
id|result
op_assign
id|jumpshot_bulk_write
c_func
(paren
id|us
comma
id|ptr
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
r_if
c_cond
(paren
id|use_sg
)paren
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
singleline_comment|// read the result.  apparently the bulk write can complete before the
singleline_comment|// jumpshot drive is finished writing.  so we loop here until we
singleline_comment|// get a good return code
id|waitcount
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|result
op_assign
id|jumpshot_get_status
c_func
(paren
id|us
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
singleline_comment|// I have not experimented to find the smallest value.
singleline_comment|//
id|wait_ms
c_func
(paren
l_int|50
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
op_logical_and
(paren
id|waitcount
OL
l_int|10
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_write_data:  Gah!  Waitcount = 10.  Bad write!?&bslash;n&quot;
)paren
suffix:semicolon
id|sectors
op_sub_assign
id|thistime
suffix:semicolon
id|sector
op_add_assign
id|thistime
suffix:semicolon
r_if
c_cond
(paren
id|use_sg
)paren
(brace
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
)brace
r_else
(brace
id|src
op_add_assign
id|len
suffix:semicolon
)brace
id|totallen
op_sub_assign
id|len
suffix:semicolon
)brace
r_while
c_loop
(paren
id|totallen
OG
l_int|0
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|jumpshot_id_device
r_static
r_int
id|jumpshot_id_device
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_struct
id|jumpshot_info
op_star
id|info
)paren
(brace
r_int
r_char
id|command
(braket
l_int|2
)braket
op_assign
(brace
l_int|0xe0
comma
l_int|0xec
)brace
suffix:semicolon
r_int
r_char
id|reply
(braket
l_int|512
)braket
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|us
op_logical_or
op_logical_neg
id|info
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
singleline_comment|// send the setup
id|rc
op_assign
id|jumpshot_send_control
c_func
(paren
id|us
comma
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
comma
l_int|0
comma
l_int|0x20
comma
l_int|0
comma
l_int|6
comma
id|command
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_id_device:  Gah! send_control for read_capacity failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
singleline_comment|// read the reply
id|rc
op_assign
id|jumpshot_bulk_read
c_func
(paren
id|us
comma
id|reply
comma
r_sizeof
(paren
id|reply
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|rc
suffix:semicolon
id|info-&gt;sectors
op_assign
(paren
(paren
id|u32
)paren
(paren
id|reply
(braket
l_int|117
)braket
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|reply
(braket
l_int|116
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|reply
(braket
l_int|115
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|reply
(braket
l_int|114
)braket
)paren
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
DECL|function|jumpshot_handle_mode_sense
r_static
r_int
id|jumpshot_handle_mode_sense
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
id|Scsi_Cmnd
op_star
id|srb
comma
r_int
r_char
op_star
id|ptr
comma
r_int
id|sense_6
)paren
(brace
r_int
r_char
id|mode_param_header
(braket
l_int|8
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|rw_err_page
(braket
l_int|12
)braket
op_assign
(brace
l_int|0x1
comma
l_int|0xA
comma
l_int|0x21
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|cache_page
(braket
l_int|12
)braket
op_assign
(brace
l_int|0x8
comma
l_int|0xA
comma
l_int|0x1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|rbac_page
(braket
l_int|12
)braket
op_assign
(brace
l_int|0x1B
comma
l_int|0xA
comma
l_int|0
comma
l_int|0x81
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|timer_page
(braket
l_int|8
)braket
op_assign
(brace
l_int|0x1C
comma
l_int|0x6
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|pc
comma
id|page_code
suffix:semicolon
r_int
r_int
id|total_len
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|param_len
comma
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sense_6
)paren
id|param_len
op_assign
id|srb-&gt;cmnd
(braket
l_int|4
)braket
suffix:semicolon
r_else
id|param_len
op_assign
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|7
)braket
)paren
op_rshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|8
)braket
)paren
)paren
suffix:semicolon
id|pc
op_assign
id|srb-&gt;cmnd
(braket
l_int|2
)braket
op_rshift
l_int|6
suffix:semicolon
id|page_code
op_assign
id|srb-&gt;cmnd
(braket
l_int|2
)braket
op_amp
l_int|0x3F
suffix:semicolon
r_switch
c_cond
(paren
id|pc
)paren
(brace
r_case
l_int|0x0
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_handle_mode_sense:  Current values&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x1
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_handle_mode_sense:  Changeable values&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x2
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_handle_mode_sense:  Default values&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x3
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_handle_mode_sense:  Saves values&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|mode_param_header
(braket
l_int|3
)braket
op_assign
l_int|0x80
suffix:semicolon
singleline_comment|// write enable
r_switch
c_cond
(paren
id|page_code
)paren
(brace
r_case
l_int|0x0
suffix:colon
singleline_comment|// vendor-specific mode
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
r_case
l_int|0x1
suffix:colon
id|total_len
op_assign
r_sizeof
(paren
id|rw_err_page
)paren
suffix:semicolon
id|mode_param_header
(braket
l_int|0
)braket
op_assign
id|total_len
op_rshift
l_int|8
suffix:semicolon
id|mode_param_header
(braket
l_int|1
)braket
op_assign
id|total_len
op_amp
l_int|0xFF
suffix:semicolon
id|mode_param_header
(braket
l_int|3
)braket
op_assign
l_int|0x00
suffix:semicolon
singleline_comment|// WP enable: 0x80
id|memcpy
c_func
(paren
id|ptr
comma
id|mode_param_header
comma
r_sizeof
(paren
id|mode_param_header
)paren
)paren
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
id|mode_param_header
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
op_plus
id|i
comma
id|rw_err_page
comma
r_sizeof
(paren
id|rw_err_page
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x8
suffix:colon
id|total_len
op_assign
r_sizeof
(paren
id|cache_page
)paren
suffix:semicolon
id|mode_param_header
(braket
l_int|0
)braket
op_assign
id|total_len
op_rshift
l_int|8
suffix:semicolon
id|mode_param_header
(braket
l_int|1
)braket
op_assign
id|total_len
op_amp
l_int|0xFF
suffix:semicolon
id|mode_param_header
(braket
l_int|3
)braket
op_assign
l_int|0x00
suffix:semicolon
singleline_comment|// WP enable: 0x80
id|memcpy
c_func
(paren
id|ptr
comma
id|mode_param_header
comma
r_sizeof
(paren
id|mode_param_header
)paren
)paren
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
id|mode_param_header
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
op_plus
id|i
comma
id|cache_page
comma
r_sizeof
(paren
id|cache_page
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x1B
suffix:colon
id|total_len
op_assign
r_sizeof
(paren
id|rbac_page
)paren
suffix:semicolon
id|mode_param_header
(braket
l_int|0
)braket
op_assign
id|total_len
op_rshift
l_int|8
suffix:semicolon
id|mode_param_header
(braket
l_int|1
)braket
op_assign
id|total_len
op_amp
l_int|0xFF
suffix:semicolon
id|mode_param_header
(braket
l_int|3
)braket
op_assign
l_int|0x00
suffix:semicolon
singleline_comment|// WP enable: 0x80
id|memcpy
c_func
(paren
id|ptr
comma
id|mode_param_header
comma
r_sizeof
(paren
id|mode_param_header
)paren
)paren
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
id|mode_param_header
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
op_plus
id|i
comma
id|rbac_page
comma
r_sizeof
(paren
id|rbac_page
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x1C
suffix:colon
id|total_len
op_assign
r_sizeof
(paren
id|timer_page
)paren
suffix:semicolon
id|mode_param_header
(braket
l_int|0
)braket
op_assign
id|total_len
op_rshift
l_int|8
suffix:semicolon
id|mode_param_header
(braket
l_int|1
)braket
op_assign
id|total_len
op_amp
l_int|0xFF
suffix:semicolon
id|mode_param_header
(braket
l_int|3
)braket
op_assign
l_int|0x00
suffix:semicolon
singleline_comment|// WP enable: 0x80
id|memcpy
c_func
(paren
id|ptr
comma
id|mode_param_header
comma
r_sizeof
(paren
id|mode_param_header
)paren
)paren
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
id|mode_param_header
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
op_plus
id|i
comma
id|timer_page
comma
r_sizeof
(paren
id|timer_page
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x3F
suffix:colon
id|total_len
op_assign
r_sizeof
(paren
id|timer_page
)paren
op_plus
r_sizeof
(paren
id|rbac_page
)paren
op_plus
r_sizeof
(paren
id|cache_page
)paren
op_plus
r_sizeof
(paren
id|rw_err_page
)paren
suffix:semicolon
id|mode_param_header
(braket
l_int|0
)braket
op_assign
id|total_len
op_rshift
l_int|8
suffix:semicolon
id|mode_param_header
(braket
l_int|1
)braket
op_assign
id|total_len
op_amp
l_int|0xFF
suffix:semicolon
id|mode_param_header
(braket
l_int|3
)braket
op_assign
l_int|0x00
suffix:semicolon
singleline_comment|// WP enable: 0x80
id|memcpy
c_func
(paren
id|ptr
comma
id|mode_param_header
comma
r_sizeof
(paren
id|mode_param_header
)paren
)paren
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
id|mode_param_header
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
op_plus
id|i
comma
id|timer_page
comma
r_sizeof
(paren
id|timer_page
)paren
)paren
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
id|timer_page
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
op_plus
id|i
comma
id|rbac_page
comma
r_sizeof
(paren
id|rbac_page
)paren
)paren
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
id|rbac_page
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
op_plus
id|i
comma
id|cache_page
comma
r_sizeof
(paren
id|cache_page
)paren
)paren
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
id|cache_page
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
op_plus
id|i
comma
id|rw_err_page
comma
r_sizeof
(paren
id|rw_err_page
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
DECL|function|jumpshot_info_destructor
r_void
id|jumpshot_info_destructor
c_func
(paren
r_void
op_star
id|extra
)paren
(brace
singleline_comment|// this routine is a placeholder...
singleline_comment|// currently, we don&squot;t allocate any extra blocks so we&squot;re okay
)brace
singleline_comment|// Transport for the Lexar &squot;Jumpshot&squot;
singleline_comment|//
DECL|function|jumpshot_transport
r_int
id|jumpshot_transport
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_struct
id|jumpshot_info
op_star
id|info
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_int
r_int
id|block
comma
id|blocks
suffix:semicolon
r_int
r_char
op_star
id|ptr
op_assign
l_int|NULL
suffix:semicolon
r_int
r_char
id|inquiry_response
(braket
l_int|36
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0x80
comma
l_int|0x00
comma
l_int|0x01
comma
l_int|0x1F
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|us-&gt;extra
)paren
(brace
id|us-&gt;extra
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|jumpshot_info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|us-&gt;extra
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_transport:  Gah! Can&squot;t allocate storage for jumpshot info struct!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
id|memset
c_func
(paren
id|us-&gt;extra
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|jumpshot_info
)paren
)paren
suffix:semicolon
id|us-&gt;extra_destructor
op_assign
id|jumpshot_info_destructor
suffix:semicolon
)brace
id|info
op_assign
(paren
r_struct
id|jumpshot_info
op_star
)paren
(paren
id|us-&gt;extra
)paren
suffix:semicolon
id|ptr
op_assign
(paren
r_int
r_char
op_star
)paren
id|srb-&gt;request_buffer
suffix:semicolon
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_transport:  INQUIRY.  Returning bogus response.&bslash;n&quot;
)paren
suffix:semicolon
id|memset
c_func
(paren
id|inquiry_response
op_plus
l_int|8
comma
l_int|0
comma
l_int|28
)paren
suffix:semicolon
id|fill_inquiry_response
c_func
(paren
id|us
comma
id|inquiry_response
comma
l_int|36
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|READ_CAPACITY
)paren
(brace
id|info-&gt;ssize
op_assign
l_int|0x200
suffix:semicolon
singleline_comment|// hard coded 512 byte sectors as per ATA spec
id|rc
op_assign
id|jumpshot_get_status
c_func
(paren
id|us
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|rc
suffix:semicolon
id|rc
op_assign
id|jumpshot_id_device
c_func
(paren
id|us
comma
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|rc
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_transport:  READ_CAPACITY:  %ld sectors, %ld bytes per sector&bslash;n&quot;
comma
id|info-&gt;sectors
comma
id|info-&gt;ssize
)paren
suffix:semicolon
singleline_comment|// build the reply
singleline_comment|//
id|ptr
(braket
l_int|0
)braket
op_assign
(paren
id|info-&gt;sectors
op_rshift
l_int|24
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|ptr
(braket
l_int|1
)braket
op_assign
(paren
id|info-&gt;sectors
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|ptr
(braket
l_int|2
)braket
op_assign
(paren
id|info-&gt;sectors
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|ptr
(braket
l_int|3
)braket
op_assign
(paren
id|info-&gt;sectors
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|ptr
(braket
l_int|4
)braket
op_assign
(paren
id|info-&gt;ssize
op_rshift
l_int|24
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|ptr
(braket
l_int|5
)braket
op_assign
(paren
id|info-&gt;ssize
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|ptr
(braket
l_int|6
)braket
op_assign
(paren
id|info-&gt;ssize
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|ptr
(braket
l_int|7
)braket
op_assign
(paren
id|info-&gt;ssize
)paren
op_amp
l_int|0xFF
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|MODE_SELECT_10
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_transport:  Gah! MODE_SELECT_10.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|READ_10
)paren
(brace
id|block
op_assign
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|2
)braket
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|3
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|4
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|5
)braket
)paren
)paren
suffix:semicolon
id|blocks
op_assign
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|7
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|8
)braket
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_transport:  READ_10: read block 0x%04lx  count %ld&bslash;n&quot;
comma
id|block
comma
id|blocks
)paren
suffix:semicolon
r_return
id|jumpshot_read_data
c_func
(paren
id|us
comma
id|info
comma
id|block
comma
id|blocks
comma
id|ptr
comma
id|srb-&gt;use_sg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|READ_12
)paren
(brace
singleline_comment|// I don&squot;t think we&squot;ll ever see a READ_12 but support it anyway...
singleline_comment|//
id|block
op_assign
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|2
)braket
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|3
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|4
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|5
)braket
)paren
)paren
suffix:semicolon
id|blocks
op_assign
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|6
)braket
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|7
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|8
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|9
)braket
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_transport:  READ_12: read block 0x%04lx  count %ld&bslash;n&quot;
comma
id|block
comma
id|blocks
)paren
suffix:semicolon
r_return
id|jumpshot_read_data
c_func
(paren
id|us
comma
id|info
comma
id|block
comma
id|blocks
comma
id|ptr
comma
id|srb-&gt;use_sg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|WRITE_10
)paren
(brace
id|block
op_assign
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|2
)braket
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|3
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|4
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|5
)braket
)paren
)paren
suffix:semicolon
id|blocks
op_assign
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|7
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|8
)braket
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_transport:  WRITE_10: write block 0x%04lx  count %ld&bslash;n&quot;
comma
id|block
comma
id|blocks
)paren
suffix:semicolon
r_return
id|jumpshot_write_data
c_func
(paren
id|us
comma
id|info
comma
id|block
comma
id|blocks
comma
id|ptr
comma
id|srb-&gt;use_sg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|WRITE_12
)paren
(brace
singleline_comment|// I don&squot;t think we&squot;ll ever see a WRITE_12 but support it anyway...
singleline_comment|//
id|block
op_assign
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|2
)braket
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|3
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|4
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|5
)braket
)paren
)paren
suffix:semicolon
id|blocks
op_assign
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|6
)braket
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|7
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|8
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|9
)braket
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_transport:  WRITE_12: write block 0x%04lx  count %ld&bslash;n&quot;
comma
id|block
comma
id|blocks
)paren
suffix:semicolon
r_return
id|jumpshot_write_data
c_func
(paren
id|us
comma
id|info
comma
id|block
comma
id|blocks
comma
id|ptr
comma
id|srb-&gt;use_sg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|TEST_UNIT_READY
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_transport:  TEST_UNIT_READY.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|jumpshot_get_status
c_func
(paren
id|us
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_transport:  REQUEST_SENSE.  Returning NO SENSE for now&bslash;n&quot;
)paren
suffix:semicolon
id|ptr
(braket
l_int|0
)braket
op_assign
l_int|0xF0
suffix:semicolon
id|ptr
(braket
l_int|2
)braket
op_assign
id|info-&gt;sense_key
suffix:semicolon
id|ptr
(braket
l_int|7
)braket
op_assign
l_int|11
suffix:semicolon
id|ptr
(braket
l_int|12
)braket
op_assign
id|info-&gt;sense_asc
suffix:semicolon
id|ptr
(braket
l_int|13
)braket
op_assign
id|info-&gt;sense_ascq
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|MODE_SENSE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_transport:  MODE_SENSE_6 detected&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|jumpshot_handle_mode_sense
c_func
(paren
id|us
comma
id|srb
comma
id|ptr
comma
id|TRUE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|MODE_SENSE_10
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_transport:  MODE_SENSE_10 detected&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|jumpshot_handle_mode_sense
c_func
(paren
id|us
comma
id|srb
comma
id|ptr
comma
id|FALSE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|ALLOW_MEDIUM_REMOVAL
)paren
(brace
singleline_comment|// sure.  whatever.  not like we can stop the user from popping
singleline_comment|// the media out of the device (no locking doors, etc)
singleline_comment|//
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_transport:  Gah! Unknown command: %d (0x%x)&bslash;n&quot;
comma
id|srb-&gt;cmnd
(braket
l_int|0
)braket
comma
id|srb-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
eof
