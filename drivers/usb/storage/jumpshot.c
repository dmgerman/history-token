multiline_comment|/* Driver for Lexar &quot;Jumpshot&quot; Compact Flash reader&n; *&n; * $Id: jumpshot.c,v 1.7 2002/02/25 00:40:13 mdharm Exp $&n; *&n; * jumpshot driver v0.1:&n; *&n; * First release&n; *&n; * Current development and maintenance by:&n; *   (c) 2000 Jimmie Mayfield (mayfield+usb@sackheads.org)&n; *&n; *   Many thanks to Robert Baruch for the SanDisk SmartMedia reader driver&n; *   which I used as a template for this driver.&n; *&n; *   Some bugfixes and scatter-gather code by Gregory P. Smith &n; *   (greg-usb@electricrain.com)&n; *&n; *   Fix for media change by Joerg Schneider (js@joergschneider.com)&n; *&n; * Developed with the assistance of:&n; *&n; *   (C) 2002 Alan Stern &lt;stern@rowland.org&gt;&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2, or (at your option) any&n; * later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write to the Free Software Foundation, Inc.,&n; * 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
multiline_comment|/*&n;  * This driver attempts to support the Lexar Jumpshot USB CompactFlash &n;  * reader.  Like many other USB CompactFlash readers, the Jumpshot contains&n;  * a USB-to-ATA chip. &n;  *&n;  * This driver supports reading and writing.  If you&squot;re truly paranoid,&n;  * however, you can force the driver into a write-protected state by setting&n;  * the WP enable bits in jumpshot_handle_mode_sense.  Basically this means&n;  * setting mode_param_header[3] = 0x80.  &n;  */
macro_line|#include &quot;transport.h&quot;
macro_line|#include &quot;raw_bulk.h&quot;
macro_line|#include &quot;protocol.h&quot;
macro_line|#include &quot;usb.h&quot;
macro_line|#include &quot;debug.h&quot;
macro_line|#include &quot;jumpshot.h&quot;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
DECL|function|jumpshot_bulk_read
r_static
r_inline
r_int
id|jumpshot_bulk_read
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|data
comma
r_int
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
r_return
id|USB_STOR_XFER_GOOD
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_bulk_read:  len = %d&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
r_return
id|usb_stor_bulk_transfer_buf
c_func
(paren
id|us
comma
id|us-&gt;recv_bulk_pipe
comma
id|data
comma
id|len
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|jumpshot_bulk_write
r_static
r_inline
r_int
id|jumpshot_bulk_write
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|data
comma
r_int
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
r_return
id|USB_STOR_XFER_GOOD
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_bulk_write:  len = %d&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
r_return
id|usb_stor_bulk_transfer_buf
c_func
(paren
id|us
comma
id|us-&gt;send_bulk_pipe
comma
id|data
comma
id|len
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|jumpshot_get_status
r_static
r_int
id|jumpshot_get_status
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|us
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
singleline_comment|// send the setup
id|rc
op_assign
id|usb_stor_ctrl_transfer
c_func
(paren
id|us
comma
id|us-&gt;recv_ctrl_pipe
comma
l_int|0
comma
l_int|0xA0
comma
l_int|0
comma
l_int|7
comma
id|us-&gt;iobuf
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|us-&gt;iobuf
(braket
l_int|0
)braket
op_ne
l_int|0x50
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_get_status:  0x%2x&bslash;n&quot;
comma
id|us-&gt;iobuf
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
DECL|function|jumpshot_read_data
r_static
r_int
id|jumpshot_read_data
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_struct
id|jumpshot_info
op_star
id|info
comma
id|u32
id|sector
comma
id|u32
id|sectors
comma
r_int
r_char
op_star
id|dest
comma
r_int
id|use_sg
)paren
(brace
r_int
r_char
op_star
id|command
op_assign
id|us-&gt;iobuf
suffix:semicolon
r_int
r_char
op_star
id|buffer
op_assign
l_int|NULL
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_int
r_char
id|thistime
suffix:semicolon
r_int
id|totallen
comma
id|len
comma
id|result
suffix:semicolon
r_int
id|sg_idx
op_assign
l_int|0
comma
id|current_sg_offset
op_assign
l_int|0
suffix:semicolon
singleline_comment|// we&squot;re working in LBA mode.  according to the ATA spec, 
singleline_comment|// we can support up to 28-bit addressing.  I don&squot;t know if Jumpshot
singleline_comment|// supports beyond 24-bit addressing.  It&squot;s kind of hard to test 
singleline_comment|// since it requires &gt; 8GB CF card.
r_if
c_cond
(paren
id|sector
OG
l_int|0x0FFFFFFF
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|totallen
op_assign
id|sectors
op_star
id|info-&gt;ssize
suffix:semicolon
r_do
(brace
singleline_comment|// loop, never allocate or transfer more than 64k at once
singleline_comment|// (min(128k, 255*info-&gt;ssize) is the real limit)
id|len
op_assign
id|min_t
c_func
(paren
r_int
comma
id|totallen
comma
l_int|65536
)paren
suffix:semicolon
r_if
c_cond
(paren
id|use_sg
)paren
(brace
id|buffer
op_assign
id|kmalloc
c_func
(paren
id|len
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
op_eq
l_int|NULL
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|ptr
op_assign
id|buffer
suffix:semicolon
)brace
r_else
(brace
id|ptr
op_assign
id|dest
suffix:semicolon
)brace
id|thistime
op_assign
(paren
id|len
op_div
id|info-&gt;ssize
)paren
op_amp
l_int|0xff
suffix:semicolon
id|command
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|command
(braket
l_int|1
)braket
op_assign
id|thistime
suffix:semicolon
id|command
(braket
l_int|2
)braket
op_assign
id|sector
op_amp
l_int|0xFF
suffix:semicolon
id|command
(braket
l_int|3
)braket
op_assign
(paren
id|sector
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|command
(braket
l_int|4
)braket
op_assign
(paren
id|sector
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|command
(braket
l_int|5
)braket
op_assign
l_int|0xE0
op_or
(paren
(paren
id|sector
op_rshift
l_int|24
)paren
op_amp
l_int|0x0F
)paren
suffix:semicolon
id|command
(braket
l_int|6
)braket
op_assign
l_int|0x20
suffix:semicolon
singleline_comment|// send the setup + command
id|result
op_assign
id|usb_stor_ctrl_transfer
c_func
(paren
id|us
comma
id|us-&gt;send_ctrl_pipe
comma
l_int|0
comma
l_int|0x20
comma
l_int|0
comma
l_int|1
comma
id|command
comma
l_int|7
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_goto
id|leave
suffix:semicolon
singleline_comment|// read the result
id|result
op_assign
id|jumpshot_bulk_read
c_func
(paren
id|us
comma
id|ptr
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_goto
id|leave
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_read_data:  %d bytes&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
id|sectors
op_sub_assign
id|thistime
suffix:semicolon
id|sector
op_add_assign
id|thistime
suffix:semicolon
r_if
c_cond
(paren
id|use_sg
)paren
(brace
id|us_copy_to_sgbuf
c_func
(paren
id|buffer
comma
id|len
comma
id|dest
comma
op_amp
id|sg_idx
comma
op_amp
id|current_sg_offset
comma
id|use_sg
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
)brace
r_else
(brace
id|dest
op_add_assign
id|len
suffix:semicolon
)brace
id|totallen
op_sub_assign
id|len
suffix:semicolon
)brace
r_while
c_loop
(paren
id|totallen
OG
l_int|0
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
id|leave
suffix:colon
r_if
c_cond
(paren
id|use_sg
)paren
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
DECL|function|jumpshot_write_data
r_static
r_int
id|jumpshot_write_data
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_struct
id|jumpshot_info
op_star
id|info
comma
id|u32
id|sector
comma
id|u32
id|sectors
comma
r_int
r_char
op_star
id|src
comma
r_int
id|use_sg
)paren
(brace
r_int
r_char
op_star
id|command
op_assign
id|us-&gt;iobuf
suffix:semicolon
r_int
r_char
op_star
id|buffer
op_assign
l_int|NULL
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_int
r_char
id|thistime
suffix:semicolon
r_int
id|totallen
comma
id|len
comma
id|result
comma
id|waitcount
suffix:semicolon
r_int
id|sg_idx
op_assign
l_int|0
comma
id|sg_offset
op_assign
l_int|0
suffix:semicolon
singleline_comment|// we&squot;re working in LBA mode.  according to the ATA spec, 
singleline_comment|// we can support up to 28-bit addressing.  I don&squot;t know if Jumpshot
singleline_comment|// supports beyond 24-bit addressing.  It&squot;s kind of hard to test 
singleline_comment|// since it requires &gt; 8GB CF card.
singleline_comment|//
r_if
c_cond
(paren
id|sector
OG
l_int|0x0FFFFFFF
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|totallen
op_assign
id|sectors
op_star
id|info-&gt;ssize
suffix:semicolon
r_do
(brace
singleline_comment|// loop, never allocate or transfer more than 64k at once
singleline_comment|// (min(128k, 255*info-&gt;ssize) is the real limit)
id|len
op_assign
id|min_t
c_func
(paren
r_int
comma
id|totallen
comma
l_int|65536
)paren
suffix:semicolon
singleline_comment|// if we are using scatter-gather,
singleline_comment|// first copy all to one big buffer
id|buffer
op_assign
id|us_copy_from_sgbuf
c_func
(paren
id|src
comma
id|len
comma
op_amp
id|sg_idx
comma
op_amp
id|sg_offset
comma
id|use_sg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
op_eq
l_int|NULL
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|ptr
op_assign
id|buffer
suffix:semicolon
id|thistime
op_assign
(paren
id|len
op_div
id|info-&gt;ssize
)paren
op_amp
l_int|0xff
suffix:semicolon
id|command
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|command
(braket
l_int|1
)braket
op_assign
id|thistime
suffix:semicolon
id|command
(braket
l_int|2
)braket
op_assign
id|sector
op_amp
l_int|0xFF
suffix:semicolon
id|command
(braket
l_int|3
)braket
op_assign
(paren
id|sector
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|command
(braket
l_int|4
)braket
op_assign
(paren
id|sector
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|command
(braket
l_int|5
)braket
op_assign
l_int|0xE0
op_or
(paren
(paren
id|sector
op_rshift
l_int|24
)paren
op_amp
l_int|0x0F
)paren
suffix:semicolon
id|command
(braket
l_int|6
)braket
op_assign
l_int|0x30
suffix:semicolon
singleline_comment|// send the setup + command
id|result
op_assign
id|usb_stor_ctrl_transfer
c_func
(paren
id|us
comma
id|us-&gt;send_ctrl_pipe
comma
l_int|0
comma
l_int|0x20
comma
l_int|0
comma
l_int|1
comma
id|command
comma
l_int|7
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_goto
id|leave
suffix:semicolon
singleline_comment|// send the data
id|result
op_assign
id|jumpshot_bulk_write
c_func
(paren
id|us
comma
id|ptr
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_goto
id|leave
suffix:semicolon
singleline_comment|// read the result.  apparently the bulk write can complete
singleline_comment|// before the jumpshot drive is finished writing.  so we loop
singleline_comment|// here until we get a good return code
id|waitcount
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|result
op_assign
id|jumpshot_get_status
c_func
(paren
id|us
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
singleline_comment|// I have not experimented to find the smallest value.
singleline_comment|//
id|wait_ms
c_func
(paren
l_int|50
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
op_logical_and
(paren
id|waitcount
OL
l_int|10
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_write_data:  Gah!  Waitcount = 10.  Bad write!?&bslash;n&quot;
)paren
suffix:semicolon
id|sectors
op_sub_assign
id|thistime
suffix:semicolon
id|sector
op_add_assign
id|thistime
suffix:semicolon
r_if
c_cond
(paren
id|use_sg
)paren
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_else
id|src
op_add_assign
id|len
suffix:semicolon
id|totallen
op_sub_assign
id|len
suffix:semicolon
)brace
r_while
c_loop
(paren
id|totallen
OG
l_int|0
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
id|leave
suffix:colon
r_if
c_cond
(paren
id|use_sg
)paren
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
DECL|function|jumpshot_id_device
r_static
r_int
id|jumpshot_id_device
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_struct
id|jumpshot_info
op_star
id|info
)paren
(brace
r_int
r_char
op_star
id|command
op_assign
id|us-&gt;iobuf
suffix:semicolon
r_int
r_char
op_star
id|reply
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|us
op_logical_or
op_logical_neg
id|info
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|command
(braket
l_int|0
)braket
op_assign
l_int|0xE0
suffix:semicolon
id|command
(braket
l_int|1
)braket
op_assign
l_int|0xEC
suffix:semicolon
id|reply
op_assign
id|kmalloc
c_func
(paren
l_int|512
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reply
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
singleline_comment|// send the setup
id|rc
op_assign
id|usb_stor_ctrl_transfer
c_func
(paren
id|us
comma
id|us-&gt;send_ctrl_pipe
comma
l_int|0
comma
l_int|0x20
comma
l_int|0
comma
l_int|6
comma
id|command
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_XFER_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_id_device:  Gah! &quot;
l_string|&quot;send_control for read_capacity failed&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_assign
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
r_goto
id|leave
suffix:semicolon
)brace
singleline_comment|// read the reply
id|rc
op_assign
id|jumpshot_bulk_read
c_func
(paren
id|us
comma
id|reply
comma
r_sizeof
(paren
id|reply
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_XFER_GOOD
)paren
(brace
id|rc
op_assign
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
r_goto
id|leave
suffix:semicolon
)brace
id|info-&gt;sectors
op_assign
(paren
(paren
id|u32
)paren
(paren
id|reply
(braket
l_int|117
)braket
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|reply
(braket
l_int|116
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|reply
(braket
l_int|115
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|reply
(braket
l_int|114
)braket
)paren
)paren
suffix:semicolon
id|rc
op_assign
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
id|leave
suffix:colon
id|kfree
c_func
(paren
id|reply
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|jumpshot_handle_mode_sense
r_static
r_int
id|jumpshot_handle_mode_sense
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
id|Scsi_Cmnd
op_star
id|srb
comma
r_int
r_char
op_star
id|ptr
comma
r_int
id|sense_6
)paren
(brace
r_int
r_char
id|mode_param_header
(braket
l_int|8
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|rw_err_page
(braket
l_int|12
)braket
op_assign
(brace
l_int|0x1
comma
l_int|0xA
comma
l_int|0x21
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|cache_page
(braket
l_int|12
)braket
op_assign
(brace
l_int|0x8
comma
l_int|0xA
comma
l_int|0x1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|rbac_page
(braket
l_int|12
)braket
op_assign
(brace
l_int|0x1B
comma
l_int|0xA
comma
l_int|0
comma
l_int|0x81
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|timer_page
(braket
l_int|8
)braket
op_assign
(brace
l_int|0x1C
comma
l_int|0x6
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|pc
comma
id|page_code
suffix:semicolon
r_int
r_int
id|total_len
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|param_len
comma
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sense_6
)paren
id|param_len
op_assign
id|srb-&gt;cmnd
(braket
l_int|4
)braket
suffix:semicolon
r_else
id|param_len
op_assign
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|7
)braket
)paren
op_rshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|8
)braket
)paren
)paren
suffix:semicolon
id|pc
op_assign
id|srb-&gt;cmnd
(braket
l_int|2
)braket
op_rshift
l_int|6
suffix:semicolon
id|page_code
op_assign
id|srb-&gt;cmnd
(braket
l_int|2
)braket
op_amp
l_int|0x3F
suffix:semicolon
r_switch
c_cond
(paren
id|pc
)paren
(brace
r_case
l_int|0x0
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_handle_mode_sense:  Current values&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x1
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_handle_mode_sense:  Changeable values&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x2
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_handle_mode_sense:  Default values&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x3
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_handle_mode_sense:  Saves values&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|mode_param_header
(braket
l_int|3
)braket
op_assign
l_int|0x80
suffix:semicolon
singleline_comment|// write enable
r_switch
c_cond
(paren
id|page_code
)paren
(brace
r_case
l_int|0x0
suffix:colon
singleline_comment|// vendor-specific mode
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
r_case
l_int|0x1
suffix:colon
id|total_len
op_assign
r_sizeof
(paren
id|rw_err_page
)paren
suffix:semicolon
id|mode_param_header
(braket
l_int|0
)braket
op_assign
id|total_len
op_rshift
l_int|8
suffix:semicolon
id|mode_param_header
(braket
l_int|1
)braket
op_assign
id|total_len
op_amp
l_int|0xFF
suffix:semicolon
id|mode_param_header
(braket
l_int|3
)braket
op_assign
l_int|0x00
suffix:semicolon
singleline_comment|// WP enable: 0x80
id|memcpy
c_func
(paren
id|ptr
comma
id|mode_param_header
comma
r_sizeof
(paren
id|mode_param_header
)paren
)paren
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
id|mode_param_header
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
op_plus
id|i
comma
id|rw_err_page
comma
r_sizeof
(paren
id|rw_err_page
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x8
suffix:colon
id|total_len
op_assign
r_sizeof
(paren
id|cache_page
)paren
suffix:semicolon
id|mode_param_header
(braket
l_int|0
)braket
op_assign
id|total_len
op_rshift
l_int|8
suffix:semicolon
id|mode_param_header
(braket
l_int|1
)braket
op_assign
id|total_len
op_amp
l_int|0xFF
suffix:semicolon
id|mode_param_header
(braket
l_int|3
)braket
op_assign
l_int|0x00
suffix:semicolon
singleline_comment|// WP enable: 0x80
id|memcpy
c_func
(paren
id|ptr
comma
id|mode_param_header
comma
r_sizeof
(paren
id|mode_param_header
)paren
)paren
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
id|mode_param_header
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
op_plus
id|i
comma
id|cache_page
comma
r_sizeof
(paren
id|cache_page
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x1B
suffix:colon
id|total_len
op_assign
r_sizeof
(paren
id|rbac_page
)paren
suffix:semicolon
id|mode_param_header
(braket
l_int|0
)braket
op_assign
id|total_len
op_rshift
l_int|8
suffix:semicolon
id|mode_param_header
(braket
l_int|1
)braket
op_assign
id|total_len
op_amp
l_int|0xFF
suffix:semicolon
id|mode_param_header
(braket
l_int|3
)braket
op_assign
l_int|0x00
suffix:semicolon
singleline_comment|// WP enable: 0x80
id|memcpy
c_func
(paren
id|ptr
comma
id|mode_param_header
comma
r_sizeof
(paren
id|mode_param_header
)paren
)paren
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
id|mode_param_header
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
op_plus
id|i
comma
id|rbac_page
comma
r_sizeof
(paren
id|rbac_page
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x1C
suffix:colon
id|total_len
op_assign
r_sizeof
(paren
id|timer_page
)paren
suffix:semicolon
id|mode_param_header
(braket
l_int|0
)braket
op_assign
id|total_len
op_rshift
l_int|8
suffix:semicolon
id|mode_param_header
(braket
l_int|1
)braket
op_assign
id|total_len
op_amp
l_int|0xFF
suffix:semicolon
id|mode_param_header
(braket
l_int|3
)braket
op_assign
l_int|0x00
suffix:semicolon
singleline_comment|// WP enable: 0x80
id|memcpy
c_func
(paren
id|ptr
comma
id|mode_param_header
comma
r_sizeof
(paren
id|mode_param_header
)paren
)paren
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
id|mode_param_header
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
op_plus
id|i
comma
id|timer_page
comma
r_sizeof
(paren
id|timer_page
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x3F
suffix:colon
id|total_len
op_assign
r_sizeof
(paren
id|timer_page
)paren
op_plus
r_sizeof
(paren
id|rbac_page
)paren
op_plus
r_sizeof
(paren
id|cache_page
)paren
op_plus
r_sizeof
(paren
id|rw_err_page
)paren
suffix:semicolon
id|mode_param_header
(braket
l_int|0
)braket
op_assign
id|total_len
op_rshift
l_int|8
suffix:semicolon
id|mode_param_header
(braket
l_int|1
)braket
op_assign
id|total_len
op_amp
l_int|0xFF
suffix:semicolon
id|mode_param_header
(braket
l_int|3
)braket
op_assign
l_int|0x00
suffix:semicolon
singleline_comment|// WP enable: 0x80
id|memcpy
c_func
(paren
id|ptr
comma
id|mode_param_header
comma
r_sizeof
(paren
id|mode_param_header
)paren
)paren
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
id|mode_param_header
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
op_plus
id|i
comma
id|timer_page
comma
r_sizeof
(paren
id|timer_page
)paren
)paren
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
id|timer_page
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
op_plus
id|i
comma
id|rbac_page
comma
r_sizeof
(paren
id|rbac_page
)paren
)paren
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
id|rbac_page
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
op_plus
id|i
comma
id|cache_page
comma
r_sizeof
(paren
id|cache_page
)paren
)paren
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
id|cache_page
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
op_plus
id|i
comma
id|rw_err_page
comma
r_sizeof
(paren
id|rw_err_page
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
DECL|function|jumpshot_info_destructor
r_void
id|jumpshot_info_destructor
c_func
(paren
r_void
op_star
id|extra
)paren
(brace
singleline_comment|// this routine is a placeholder...
singleline_comment|// currently, we don&squot;t allocate any extra blocks so we&squot;re okay
)brace
singleline_comment|// Transport for the Lexar &squot;Jumpshot&squot;
singleline_comment|//
DECL|function|jumpshot_transport
r_int
id|jumpshot_transport
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_struct
id|jumpshot_info
op_star
id|info
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_int
r_int
id|block
comma
id|blocks
suffix:semicolon
r_int
r_char
op_star
id|ptr
op_assign
l_int|NULL
suffix:semicolon
r_int
r_char
id|inquiry_response
(braket
l_int|36
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0x80
comma
l_int|0x00
comma
l_int|0x01
comma
l_int|0x1F
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|us-&gt;extra
)paren
(brace
id|us-&gt;extra
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|jumpshot_info
)paren
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|us-&gt;extra
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_transport:  Gah! Can&squot;t allocate storage for jumpshot info struct!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
id|memset
c_func
(paren
id|us-&gt;extra
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|jumpshot_info
)paren
)paren
suffix:semicolon
id|us-&gt;extra_destructor
op_assign
id|jumpshot_info_destructor
suffix:semicolon
)brace
id|info
op_assign
(paren
r_struct
id|jumpshot_info
op_star
)paren
(paren
id|us-&gt;extra
)paren
suffix:semicolon
id|ptr
op_assign
(paren
r_int
r_char
op_star
)paren
id|srb-&gt;request_buffer
suffix:semicolon
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_transport:  INQUIRY.  Returning bogus response.&bslash;n&quot;
)paren
suffix:semicolon
id|memset
c_func
(paren
id|inquiry_response
op_plus
l_int|8
comma
l_int|0
comma
l_int|28
)paren
suffix:semicolon
id|fill_inquiry_response
c_func
(paren
id|us
comma
id|inquiry_response
comma
l_int|36
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|READ_CAPACITY
)paren
(brace
id|info-&gt;ssize
op_assign
l_int|0x200
suffix:semicolon
singleline_comment|// hard coded 512 byte sectors as per ATA spec
id|rc
op_assign
id|jumpshot_get_status
c_func
(paren
id|us
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|rc
suffix:semicolon
id|rc
op_assign
id|jumpshot_id_device
c_func
(paren
id|us
comma
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|rc
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_transport:  READ_CAPACITY:  %ld sectors, %ld bytes per sector&bslash;n&quot;
comma
id|info-&gt;sectors
comma
id|info-&gt;ssize
)paren
suffix:semicolon
singleline_comment|// build the reply
singleline_comment|//
id|ptr
(braket
l_int|0
)braket
op_assign
(paren
id|info-&gt;sectors
op_rshift
l_int|24
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|ptr
(braket
l_int|1
)braket
op_assign
(paren
id|info-&gt;sectors
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|ptr
(braket
l_int|2
)braket
op_assign
(paren
id|info-&gt;sectors
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|ptr
(braket
l_int|3
)braket
op_assign
(paren
id|info-&gt;sectors
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|ptr
(braket
l_int|4
)braket
op_assign
(paren
id|info-&gt;ssize
op_rshift
l_int|24
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|ptr
(braket
l_int|5
)braket
op_assign
(paren
id|info-&gt;ssize
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|ptr
(braket
l_int|6
)braket
op_assign
(paren
id|info-&gt;ssize
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|ptr
(braket
l_int|7
)braket
op_assign
(paren
id|info-&gt;ssize
)paren
op_amp
l_int|0xFF
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|MODE_SELECT_10
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_transport:  Gah! MODE_SELECT_10.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|READ_10
)paren
(brace
id|block
op_assign
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|2
)braket
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|3
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|4
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|5
)braket
)paren
)paren
suffix:semicolon
id|blocks
op_assign
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|7
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|8
)braket
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_transport:  READ_10: read block 0x%04lx  count %ld&bslash;n&quot;
comma
id|block
comma
id|blocks
)paren
suffix:semicolon
r_return
id|jumpshot_read_data
c_func
(paren
id|us
comma
id|info
comma
id|block
comma
id|blocks
comma
id|ptr
comma
id|srb-&gt;use_sg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|READ_12
)paren
(brace
singleline_comment|// I don&squot;t think we&squot;ll ever see a READ_12 but support it anyway...
singleline_comment|//
id|block
op_assign
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|2
)braket
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|3
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|4
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|5
)braket
)paren
)paren
suffix:semicolon
id|blocks
op_assign
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|6
)braket
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|7
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|8
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|9
)braket
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_transport:  READ_12: read block 0x%04lx  count %ld&bslash;n&quot;
comma
id|block
comma
id|blocks
)paren
suffix:semicolon
r_return
id|jumpshot_read_data
c_func
(paren
id|us
comma
id|info
comma
id|block
comma
id|blocks
comma
id|ptr
comma
id|srb-&gt;use_sg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|WRITE_10
)paren
(brace
id|block
op_assign
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|2
)braket
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|3
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|4
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|5
)braket
)paren
)paren
suffix:semicolon
id|blocks
op_assign
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|7
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|8
)braket
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_transport:  WRITE_10: write block 0x%04lx  count %ld&bslash;n&quot;
comma
id|block
comma
id|blocks
)paren
suffix:semicolon
r_return
id|jumpshot_write_data
c_func
(paren
id|us
comma
id|info
comma
id|block
comma
id|blocks
comma
id|ptr
comma
id|srb-&gt;use_sg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|WRITE_12
)paren
(brace
singleline_comment|// I don&squot;t think we&squot;ll ever see a WRITE_12 but support it anyway...
singleline_comment|//
id|block
op_assign
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|2
)braket
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|3
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|4
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|5
)braket
)paren
)paren
suffix:semicolon
id|blocks
op_assign
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|6
)braket
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|7
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|8
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|9
)braket
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_transport:  WRITE_12: write block 0x%04lx  count %ld&bslash;n&quot;
comma
id|block
comma
id|blocks
)paren
suffix:semicolon
r_return
id|jumpshot_write_data
c_func
(paren
id|us
comma
id|info
comma
id|block
comma
id|blocks
comma
id|ptr
comma
id|srb-&gt;use_sg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|TEST_UNIT_READY
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_transport:  TEST_UNIT_READY.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|jumpshot_get_status
c_func
(paren
id|us
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_transport:  REQUEST_SENSE.  Returning NO SENSE for now&bslash;n&quot;
)paren
suffix:semicolon
id|ptr
(braket
l_int|0
)braket
op_assign
l_int|0xF0
suffix:semicolon
id|ptr
(braket
l_int|2
)braket
op_assign
id|info-&gt;sense_key
suffix:semicolon
id|ptr
(braket
l_int|7
)braket
op_assign
l_int|11
suffix:semicolon
id|ptr
(braket
l_int|12
)braket
op_assign
id|info-&gt;sense_asc
suffix:semicolon
id|ptr
(braket
l_int|13
)braket
op_assign
id|info-&gt;sense_ascq
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|MODE_SENSE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_transport:  MODE_SENSE_6 detected&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|jumpshot_handle_mode_sense
c_func
(paren
id|us
comma
id|srb
comma
id|ptr
comma
id|TRUE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|MODE_SENSE_10
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_transport:  MODE_SENSE_10 detected&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|jumpshot_handle_mode_sense
c_func
(paren
id|us
comma
id|srb
comma
id|ptr
comma
id|FALSE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|ALLOW_MEDIUM_REMOVAL
)paren
(brace
singleline_comment|// sure.  whatever.  not like we can stop the user from popping
singleline_comment|// the media out of the device (no locking doors, etc)
singleline_comment|//
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|START_STOP
)paren
(brace
multiline_comment|/* this is used by sd.c&squot;check_scsidisk_media_change to detect&n;&t;&t;   media change */
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_transport:  START_STOP.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* the first jumpshot_id_device after a media change returns&n;&t;&t;   an error (determined experimentally) */
id|rc
op_assign
id|jumpshot_id_device
c_func
(paren
id|us
comma
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
id|info-&gt;sense_key
op_assign
id|NO_SENSE
suffix:semicolon
id|srb-&gt;result
op_assign
id|SUCCESS
suffix:semicolon
)brace
r_else
(brace
id|info-&gt;sense_key
op_assign
id|UNIT_ATTENTION
suffix:semicolon
id|srb-&gt;result
op_assign
id|SAM_STAT_CHECK_CONDITION
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;jumpshot_transport:  Gah! Unknown command: %d (0x%x)&bslash;n&quot;
comma
id|srb-&gt;cmnd
(braket
l_int|0
)braket
comma
id|srb-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
eof
