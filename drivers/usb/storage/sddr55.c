multiline_comment|/* Driver for SanDisk SDDR-55 SmartMedia reader&n; *&n; * $Id:$&n; *&n; * SDDR55 driver v0.1:&n; *&n; * First release&n; *&n; * Current development and maintenance by:&n; *   (c) 2002 Simon Munton&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2, or (at your option) any&n; * later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write to the Free Software Foundation, Inc.,&n; * 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &quot;transport.h&quot;
macro_line|#include &quot;raw_bulk.h&quot;
macro_line|#include &quot;protocol.h&quot;
macro_line|#include &quot;usb.h&quot;
macro_line|#include &quot;debug.h&quot;
macro_line|#include &quot;sddr55.h&quot;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
DECL|macro|short_pack
mdefine_line|#define short_pack(lsb,msb) ( ((u16)(lsb)) | ( ((u16)(msb))&lt;&lt;8 ) )
DECL|macro|LSB_of
mdefine_line|#define LSB_of(s) ((s)&amp;0xFF)
DECL|macro|MSB_of
mdefine_line|#define MSB_of(s) ((s)&gt;&gt;8)
DECL|macro|PAGESIZE
mdefine_line|#define PAGESIZE  512
DECL|macro|set_sense_info
mdefine_line|#define set_sense_info(sk, asc, ascq)&t;&bslash;&n;    do {&t;&t;&t;&t;&bslash;&n;&t;info-&gt;sense_data[2] = sk;&t;&bslash;&n;&t;info-&gt;sense_data[12] = asc;&t;&bslash;&n;&t;info-&gt;sense_data[13] = ascq;&t;&bslash;&n;&t;} while (0)
DECL|struct|sddr55_card_info
r_struct
id|sddr55_card_info
(brace
DECL|member|capacity
r_int
r_int
id|capacity
suffix:semicolon
multiline_comment|/* Size of card in bytes */
DECL|member|max_log_blks
r_int
id|max_log_blks
suffix:semicolon
multiline_comment|/* maximum number of logical blocks */
DECL|member|pageshift
r_int
id|pageshift
suffix:semicolon
multiline_comment|/* log2 of pagesize */
DECL|member|smallpageshift
r_int
id|smallpageshift
suffix:semicolon
multiline_comment|/* 1 if pagesize == 256 */
DECL|member|blocksize
r_int
id|blocksize
suffix:semicolon
multiline_comment|/* Size of block in pages */
DECL|member|blockshift
r_int
id|blockshift
suffix:semicolon
multiline_comment|/* log2 of blocksize */
DECL|member|blockmask
r_int
id|blockmask
suffix:semicolon
multiline_comment|/* 2^blockshift - 1 */
DECL|member|read_only
r_int
id|read_only
suffix:semicolon
multiline_comment|/* non zero if card is write protected */
DECL|member|force_read_only
r_int
id|force_read_only
suffix:semicolon
multiline_comment|/* non zero if we find a map error*/
DECL|member|lba_to_pba
r_int
op_star
id|lba_to_pba
suffix:semicolon
multiline_comment|/* logical to physical map */
DECL|member|pba_to_lba
r_int
op_star
id|pba_to_lba
suffix:semicolon
multiline_comment|/* physical to logical map */
DECL|member|fatal_error
r_int
id|fatal_error
suffix:semicolon
multiline_comment|/* set if we detect something nasty */
DECL|member|last_access
r_int
r_int
id|last_access
suffix:semicolon
multiline_comment|/* number of jiffies since we last talked to device */
DECL|member|sense_data
r_int
r_char
id|sense_data
(braket
l_int|18
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|NOT_ALLOCATED
mdefine_line|#define NOT_ALLOCATED&t;&t;0xffffffff
DECL|macro|BAD_BLOCK
mdefine_line|#define BAD_BLOCK&t;&t;0xffff
DECL|macro|CIS_BLOCK
mdefine_line|#define CIS_BLOCK&t;&t;0x400
DECL|macro|UNUSED_BLOCK
mdefine_line|#define UNUSED_BLOCK&t;&t;0x3ff
r_static
r_int
DECL|function|sddr55_bulk_transport
id|sddr55_bulk_transport
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
id|direction
comma
r_int
r_char
op_star
id|data
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|sddr55_card_info
op_star
id|info
op_assign
(paren
r_struct
id|sddr55_card_info
op_star
)paren
id|us-&gt;extra
suffix:semicolon
r_if
c_cond
(paren
id|len
)paren
id|info-&gt;last_access
op_assign
id|jiffies
suffix:semicolon
r_return
id|usb_storage_bulk_transport
c_func
(paren
id|us
comma
id|direction
comma
id|data
comma
id|len
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* check if card inserted, if there is, update read_only status&n; * return non zero if no card&n; */
DECL|function|sddr55_status
r_static
r_int
id|sddr55_status
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_char
id|command
(braket
l_int|8
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0xb0
comma
l_int|0
comma
l_int|0x80
)brace
suffix:semicolon
r_int
r_char
id|status
(braket
l_int|8
)braket
suffix:semicolon
r_struct
id|sddr55_card_info
op_star
id|info
op_assign
(paren
r_struct
id|sddr55_card_info
op_star
)paren
id|us-&gt;extra
suffix:semicolon
multiline_comment|/* send command */
id|result
op_assign
id|sddr55_bulk_transport
c_func
(paren
id|us
comma
id|SCSI_DATA_WRITE
comma
id|command
comma
l_int|8
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Result for send_command in status %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|US_BULK_TRANSFER_GOOD
)paren
(brace
id|set_sense_info
(paren
l_int|4
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* hardware error */
r_return
id|result
suffix:semicolon
)brace
id|result
op_assign
id|sddr55_bulk_transport
c_func
(paren
id|us
comma
id|SCSI_DATA_READ
comma
id|status
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* expect to get short transfer if no card fitted */
r_if
c_cond
(paren
id|result
op_eq
id|US_BULK_TRANSFER_SHORT
)paren
(brace
multiline_comment|/* had a short transfer, no card inserted, free map memory */
r_if
c_cond
(paren
id|info-&gt;lba_to_pba
)paren
id|kfree
c_func
(paren
id|info-&gt;lba_to_pba
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;pba_to_lba
)paren
id|kfree
c_func
(paren
id|info-&gt;pba_to_lba
)paren
suffix:semicolon
id|info-&gt;lba_to_pba
op_assign
l_int|NULL
suffix:semicolon
id|info-&gt;pba_to_lba
op_assign
l_int|NULL
suffix:semicolon
id|info-&gt;fatal_error
op_assign
l_int|0
suffix:semicolon
id|info-&gt;force_read_only
op_assign
l_int|0
suffix:semicolon
id|set_sense_info
(paren
l_int|2
comma
l_int|0x3a
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* not ready, medium not present */
r_return
id|result
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_ne
id|US_BULK_TRANSFER_GOOD
)paren
(brace
id|set_sense_info
(paren
l_int|4
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* hardware error */
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/* check write protect status */
id|info-&gt;read_only
op_assign
(paren
id|status
(braket
l_int|0
)braket
op_amp
l_int|0x20
)paren
suffix:semicolon
multiline_comment|/* now read status */
id|result
op_assign
id|sddr55_bulk_transport
c_func
(paren
id|us
comma
id|SCSI_DATA_READ
comma
id|status
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|US_BULK_TRANSFER_GOOD
)paren
(brace
id|set_sense_info
(paren
l_int|4
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* hardware error */
)brace
r_return
id|result
suffix:semicolon
)brace
DECL|function|sddr55_read_data
r_static
r_int
id|sddr55_read_data
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|lba
comma
r_int
r_int
id|page
comma
r_int
r_int
id|sectors
comma
r_int
r_char
op_star
id|content
comma
r_int
id|use_sg
)paren
(brace
r_int
id|result
op_assign
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
r_int
r_char
id|command
(braket
l_int|8
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0xb0
comma
l_int|0
comma
l_int|0x85
)brace
suffix:semicolon
r_int
r_char
id|status
(braket
l_int|8
)braket
suffix:semicolon
r_struct
id|sddr55_card_info
op_star
id|info
op_assign
(paren
r_struct
id|sddr55_card_info
op_star
)paren
id|us-&gt;extra
suffix:semicolon
r_int
r_int
id|pba
suffix:semicolon
r_int
r_int
id|address
suffix:semicolon
r_int
r_int
id|pages
suffix:semicolon
r_int
r_char
op_star
id|buffer
op_assign
l_int|NULL
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_int
id|len
suffix:semicolon
id|len
op_assign
id|sectors
op_star
id|PAGESIZE
suffix:semicolon
id|buffer
op_assign
(paren
id|use_sg
ques
c_cond
id|kmalloc
c_func
(paren
id|len
comma
id|GFP_NOIO
)paren
suffix:colon
id|content
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
op_eq
l_int|NULL
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
multiline_comment|/* out of memory */
id|ptr
op_assign
id|buffer
suffix:semicolon
r_while
c_loop
(paren
id|sectors
OG
l_int|0
)paren
(brace
multiline_comment|/* have we got to end? */
r_if
c_cond
(paren
id|lba
op_ge
id|info-&gt;max_log_blks
)paren
r_break
suffix:semicolon
id|pba
op_assign
id|info-&gt;lba_to_pba
(braket
id|lba
)braket
suffix:semicolon
singleline_comment|// Read as many sectors as possible in this block
id|pages
op_assign
id|info-&gt;blocksize
op_minus
id|page
suffix:semicolon
r_if
c_cond
(paren
id|pages
OG
(paren
id|sectors
op_lshift
id|info-&gt;smallpageshift
)paren
)paren
id|pages
op_assign
(paren
id|sectors
op_lshift
id|info-&gt;smallpageshift
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Read %02X pages, from PBA %04X&quot;
l_string|&quot; (LBA %04X) page %02X&bslash;n&quot;
comma
id|pages
comma
id|pba
comma
id|lba
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pba
op_eq
id|NOT_ALLOCATED
)paren
(brace
multiline_comment|/* no pba for this lba, fill with zeroes */
id|memset
(paren
id|ptr
comma
l_int|0
comma
id|pages
op_lshift
id|info-&gt;pageshift
)paren
suffix:semicolon
)brace
r_else
(brace
id|address
op_assign
(paren
id|pba
op_lshift
id|info-&gt;blockshift
)paren
op_plus
id|page
suffix:semicolon
id|command
(braket
l_int|1
)braket
op_assign
id|LSB_of
c_func
(paren
id|address
op_rshift
l_int|16
)paren
suffix:semicolon
id|command
(braket
l_int|2
)braket
op_assign
id|LSB_of
c_func
(paren
id|address
op_rshift
l_int|8
)paren
suffix:semicolon
id|command
(braket
l_int|3
)braket
op_assign
id|LSB_of
c_func
(paren
id|address
)paren
suffix:semicolon
id|command
(braket
l_int|6
)braket
op_assign
id|LSB_of
c_func
(paren
id|pages
op_lshift
(paren
l_int|1
op_minus
id|info-&gt;smallpageshift
)paren
)paren
suffix:semicolon
multiline_comment|/* send command */
id|result
op_assign
id|sddr55_bulk_transport
c_func
(paren
id|us
comma
id|SCSI_DATA_WRITE
comma
id|command
comma
l_int|8
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Result for send_command in read_data %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|US_BULK_TRANSFER_GOOD
)paren
r_goto
id|leave
suffix:semicolon
multiline_comment|/* read data */
id|result
op_assign
id|sddr55_bulk_transport
c_func
(paren
id|us
comma
id|SCSI_DATA_READ
comma
id|ptr
comma
id|pages
op_lshift
id|info-&gt;pageshift
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|US_BULK_TRANSFER_GOOD
)paren
r_goto
id|leave
suffix:semicolon
multiline_comment|/* now read status */
id|result
op_assign
id|sddr55_bulk_transport
c_func
(paren
id|us
comma
id|SCSI_DATA_READ
comma
id|status
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|US_BULK_TRANSFER_GOOD
)paren
r_goto
id|leave
suffix:semicolon
multiline_comment|/* check status for error */
r_if
c_cond
(paren
id|status
(braket
l_int|0
)braket
op_eq
l_int|0xff
op_logical_and
id|status
(braket
l_int|1
)braket
op_eq
l_int|0x4
)paren
(brace
id|set_sense_info
(paren
l_int|3
comma
l_int|0x11
comma
l_int|0
)paren
suffix:semicolon
id|result
op_assign
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
r_goto
id|leave
suffix:semicolon
)brace
)brace
id|page
op_assign
l_int|0
suffix:semicolon
id|lba
op_increment
suffix:semicolon
id|sectors
op_sub_assign
id|pages
op_rshift
id|info-&gt;smallpageshift
suffix:semicolon
id|ptr
op_add_assign
(paren
id|pages
op_lshift
id|info-&gt;pageshift
)paren
suffix:semicolon
)brace
id|us_copy_to_sgbuf_all
c_func
(paren
id|buffer
comma
id|len
comma
id|content
comma
id|use_sg
)paren
suffix:semicolon
id|leave
suffix:colon
r_if
c_cond
(paren
id|use_sg
)paren
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|sddr55_write_data
r_static
r_int
id|sddr55_write_data
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_int
id|lba
comma
r_int
r_int
id|page
comma
r_int
r_int
id|sectors
comma
r_int
r_char
op_star
id|content
comma
r_int
id|use_sg
)paren
(brace
r_int
id|result
op_assign
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
r_int
r_char
id|command
(braket
l_int|8
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0xb0
comma
l_int|0
comma
l_int|0x86
)brace
suffix:semicolon
r_int
r_char
id|status
(braket
l_int|8
)braket
suffix:semicolon
r_struct
id|sddr55_card_info
op_star
id|info
op_assign
(paren
r_struct
id|sddr55_card_info
op_star
)paren
id|us-&gt;extra
suffix:semicolon
r_int
r_int
id|pba
suffix:semicolon
r_int
r_int
id|new_pba
suffix:semicolon
r_int
r_int
id|address
suffix:semicolon
r_int
r_int
id|pages
suffix:semicolon
r_int
r_char
op_star
id|buffer
op_assign
l_int|NULL
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_int
id|i
comma
id|len
suffix:semicolon
multiline_comment|/* check if we are allowed to write */
r_if
c_cond
(paren
id|info-&gt;read_only
op_logical_or
id|info-&gt;force_read_only
)paren
(brace
id|set_sense_info
(paren
l_int|7
comma
l_int|0x27
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* read only */
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
id|len
op_assign
id|sectors
op_star
id|PAGESIZE
suffix:semicolon
id|buffer
op_assign
id|us_copy_from_sgbuf_all
c_func
(paren
id|content
comma
id|len
comma
id|use_sg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
op_eq
l_int|NULL
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|ptr
op_assign
id|buffer
suffix:semicolon
r_while
c_loop
(paren
id|sectors
OG
l_int|0
)paren
(brace
multiline_comment|/* have we got to end? */
r_if
c_cond
(paren
id|lba
op_ge
id|info-&gt;max_log_blks
)paren
r_break
suffix:semicolon
id|pba
op_assign
id|info-&gt;lba_to_pba
(braket
id|lba
)braket
suffix:semicolon
singleline_comment|// Write as many sectors as possible in this block
id|pages
op_assign
id|info-&gt;blocksize
op_minus
id|page
suffix:semicolon
r_if
c_cond
(paren
id|pages
OG
(paren
id|sectors
op_lshift
id|info-&gt;smallpageshift
)paren
)paren
id|pages
op_assign
(paren
id|sectors
op_lshift
id|info-&gt;smallpageshift
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Write %02X pages, to PBA %04X&quot;
l_string|&quot; (LBA %04X) page %02X&bslash;n&quot;
comma
id|pages
comma
id|pba
comma
id|lba
comma
id|page
)paren
suffix:semicolon
id|command
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pba
op_eq
id|NOT_ALLOCATED
)paren
(brace
multiline_comment|/* no pba allocated for this lba, find a free pba to use */
r_int
id|max_pba
op_assign
(paren
id|info-&gt;max_log_blks
op_div
l_int|250
)paren
op_star
l_int|256
suffix:semicolon
r_int
id|found_count
op_assign
l_int|0
suffix:semicolon
r_int
id|found_pba
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* set pba to first block in zone lba is in */
id|pba
op_assign
(paren
id|lba
op_div
l_int|1000
)paren
op_star
l_int|1024
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;No PBA for LBA %04X&bslash;n&quot;
comma
id|lba
)paren
suffix:semicolon
r_if
c_cond
(paren
id|max_pba
OG
l_int|1024
)paren
id|max_pba
op_assign
l_int|1024
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Scan through the map looking for an unused block&n;&t;&t;&t; * leave 16 unused blocks at start (or as many as&n;&t;&t;&t; * possible) since the sddr55 seems to reuse a used&n;&t;&t;&t; * block when it shouldn&squot;t if we don&squot;t leave space.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max_pba
suffix:semicolon
id|i
op_increment
comma
id|pba
op_increment
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;pba_to_lba
(braket
id|pba
)braket
op_eq
id|UNUSED_BLOCK
)paren
(brace
id|found_pba
op_assign
id|pba
suffix:semicolon
r_if
c_cond
(paren
id|found_count
op_increment
OG
l_int|16
)paren
r_break
suffix:semicolon
)brace
)brace
id|pba
op_assign
id|found_pba
suffix:semicolon
r_if
c_cond
(paren
id|pba
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* oh dear */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Couldn&squot;t find unallocated block&bslash;n&quot;
)paren
suffix:semicolon
id|set_sense_info
(paren
l_int|3
comma
l_int|0x31
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* medium error */
id|result
op_assign
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
r_goto
id|leave
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Allocating PBA %04X for LBA %04X&bslash;n&quot;
comma
id|pba
comma
id|lba
)paren
suffix:semicolon
multiline_comment|/* set writing to unallocated block flag */
id|command
(braket
l_int|4
)braket
op_assign
l_int|0x40
suffix:semicolon
)brace
id|address
op_assign
(paren
id|pba
op_lshift
id|info-&gt;blockshift
)paren
op_plus
id|page
suffix:semicolon
id|command
(braket
l_int|1
)braket
op_assign
id|LSB_of
c_func
(paren
id|address
op_rshift
l_int|16
)paren
suffix:semicolon
id|command
(braket
l_int|2
)braket
op_assign
id|LSB_of
c_func
(paren
id|address
op_rshift
l_int|8
)paren
suffix:semicolon
id|command
(braket
l_int|3
)braket
op_assign
id|LSB_of
c_func
(paren
id|address
)paren
suffix:semicolon
multiline_comment|/* set the lba into the command, modulo 1000 */
id|command
(braket
l_int|0
)braket
op_assign
id|LSB_of
c_func
(paren
id|lba
op_mod
l_int|1000
)paren
suffix:semicolon
id|command
(braket
l_int|6
)braket
op_assign
id|MSB_of
c_func
(paren
id|lba
op_mod
l_int|1000
)paren
suffix:semicolon
id|command
(braket
l_int|4
)braket
op_or_assign
id|LSB_of
c_func
(paren
id|pages
op_rshift
id|info-&gt;smallpageshift
)paren
suffix:semicolon
multiline_comment|/* send command */
id|result
op_assign
id|sddr55_bulk_transport
c_func
(paren
id|us
comma
id|SCSI_DATA_WRITE
comma
id|command
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|US_BULK_TRANSFER_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Result for send_command in write_data %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
multiline_comment|/* set_sense_info is superfluous here? */
id|set_sense_info
(paren
l_int|3
comma
l_int|0x3
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* peripheral write error */
r_goto
id|leave
suffix:semicolon
)brace
multiline_comment|/* send the data */
id|result
op_assign
id|sddr55_bulk_transport
c_func
(paren
id|us
comma
id|SCSI_DATA_WRITE
comma
id|ptr
comma
id|pages
op_lshift
id|info-&gt;pageshift
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|US_BULK_TRANSFER_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Result for send_data in write_data %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
multiline_comment|/* set_sense_info is superfluous here? */
id|set_sense_info
(paren
l_int|3
comma
l_int|0x3
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* peripheral write error */
r_goto
id|leave
suffix:semicolon
)brace
multiline_comment|/* now read status */
id|result
op_assign
id|sddr55_bulk_transport
c_func
(paren
id|us
comma
id|SCSI_DATA_READ
comma
id|status
comma
l_int|6
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|US_BULK_TRANSFER_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Result for get_status in write_data %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
multiline_comment|/* set_sense_info is superfluous here? */
id|set_sense_info
(paren
l_int|3
comma
l_int|0x3
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* peripheral write error */
r_goto
id|leave
suffix:semicolon
)brace
id|new_pba
op_assign
(paren
id|status
(braket
l_int|3
)braket
op_plus
(paren
id|status
(braket
l_int|4
)braket
op_lshift
l_int|8
)paren
op_plus
(paren
id|status
(braket
l_int|5
)braket
op_lshift
l_int|16
)paren
)paren
op_rshift
id|info-&gt;blockshift
suffix:semicolon
multiline_comment|/* check status for error */
r_if
c_cond
(paren
id|status
(braket
l_int|0
)braket
op_eq
l_int|0xff
op_logical_and
id|status
(braket
l_int|1
)braket
op_eq
l_int|0x4
)paren
(brace
id|info-&gt;pba_to_lba
(braket
id|new_pba
)braket
op_assign
id|BAD_BLOCK
suffix:semicolon
id|set_sense_info
(paren
l_int|3
comma
l_int|0x0c
comma
l_int|0
)paren
suffix:semicolon
id|result
op_assign
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
r_goto
id|leave
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Updating maps for LBA %04X: old PBA %04X, new PBA %04X&bslash;n&quot;
comma
id|lba
comma
id|pba
comma
id|new_pba
)paren
suffix:semicolon
multiline_comment|/* update the lba&lt;-&gt;pba maps, note new_pba might be the same as pba */
id|info-&gt;lba_to_pba
(braket
id|lba
)braket
op_assign
id|new_pba
suffix:semicolon
id|info-&gt;pba_to_lba
(braket
id|pba
)braket
op_assign
id|UNUSED_BLOCK
suffix:semicolon
multiline_comment|/* check that new_pba wasn&squot;t already being used */
r_if
c_cond
(paren
id|info-&gt;pba_to_lba
(braket
id|new_pba
)braket
op_ne
id|UNUSED_BLOCK
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sddr55 error: new PBA %04X already in use for LBA %04X&bslash;n&quot;
comma
id|new_pba
comma
id|info-&gt;pba_to_lba
(braket
id|new_pba
)braket
)paren
suffix:semicolon
id|info-&gt;fatal_error
op_assign
l_int|1
suffix:semicolon
id|set_sense_info
(paren
l_int|3
comma
l_int|0x31
comma
l_int|0
)paren
suffix:semicolon
id|result
op_assign
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
r_goto
id|leave
suffix:semicolon
)brace
multiline_comment|/* update the pba&lt;-&gt;lba maps for new_pba */
id|info-&gt;pba_to_lba
(braket
id|new_pba
)braket
op_assign
id|lba
op_mod
l_int|1000
suffix:semicolon
id|page
op_assign
l_int|0
suffix:semicolon
id|lba
op_increment
suffix:semicolon
id|sectors
op_sub_assign
id|pages
op_rshift
id|info-&gt;smallpageshift
suffix:semicolon
id|ptr
op_add_assign
(paren
id|pages
op_lshift
id|info-&gt;pageshift
)paren
suffix:semicolon
)brace
id|leave
suffix:colon
r_if
c_cond
(paren
id|use_sg
)paren
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|sddr55_read_deviceID
r_static
r_int
id|sddr55_read_deviceID
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|manufacturerID
comma
r_int
r_char
op_star
id|deviceID
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_char
id|command
(braket
l_int|8
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0xb0
comma
l_int|0
comma
l_int|0x84
)brace
suffix:semicolon
r_int
r_char
id|content
(braket
l_int|64
)braket
suffix:semicolon
id|result
op_assign
id|sddr55_bulk_transport
c_func
(paren
id|us
comma
id|SCSI_DATA_WRITE
comma
id|command
comma
l_int|8
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Result of send_control for device ID is %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|US_BULK_TRANSFER_GOOD
)paren
r_return
id|result
suffix:semicolon
id|result
op_assign
id|sddr55_bulk_transport
c_func
(paren
id|us
comma
id|SCSI_DATA_READ
comma
id|content
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|US_BULK_TRANSFER_GOOD
)paren
r_return
id|result
suffix:semicolon
op_star
id|manufacturerID
op_assign
id|content
(braket
l_int|0
)braket
suffix:semicolon
op_star
id|deviceID
op_assign
id|content
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|content
(braket
l_int|0
)braket
op_ne
l_int|0xff
)paren
(brace
id|result
op_assign
id|sddr55_bulk_transport
c_func
(paren
id|us
comma
id|SCSI_DATA_READ
comma
id|content
comma
l_int|2
)paren
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
DECL|function|sddr55_reset
r_int
id|sddr55_reset
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sddr55_get_capacity
r_static
r_int
r_int
id|sddr55_get_capacity
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
r_char
id|manufacturerID
suffix:semicolon
r_int
r_char
id|deviceID
suffix:semicolon
r_int
id|result
suffix:semicolon
r_struct
id|sddr55_card_info
op_star
id|info
op_assign
(paren
r_struct
id|sddr55_card_info
op_star
)paren
id|us-&gt;extra
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Reading capacity...&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|sddr55_read_deviceID
c_func
(paren
id|us
comma
op_amp
id|manufacturerID
comma
op_amp
id|deviceID
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Result of read_deviceID is %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|US_BULK_TRANSFER_GOOD
)paren
r_return
l_int|0
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Device ID = %02X&bslash;n&quot;
comma
id|deviceID
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Manuf  ID = %02X&bslash;n&quot;
comma
id|manufacturerID
)paren
suffix:semicolon
id|info-&gt;pageshift
op_assign
l_int|9
suffix:semicolon
id|info-&gt;smallpageshift
op_assign
l_int|0
suffix:semicolon
id|info-&gt;blocksize
op_assign
l_int|16
suffix:semicolon
id|info-&gt;blockshift
op_assign
l_int|4
suffix:semicolon
id|info-&gt;blockmask
op_assign
l_int|15
suffix:semicolon
r_switch
c_cond
(paren
id|deviceID
)paren
(brace
r_case
l_int|0x6e
suffix:colon
singleline_comment|// 1MB
r_case
l_int|0xe8
suffix:colon
r_case
l_int|0xec
suffix:colon
id|info-&gt;pageshift
op_assign
l_int|8
suffix:semicolon
id|info-&gt;smallpageshift
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0x00100000
suffix:semicolon
r_case
l_int|0xea
suffix:colon
singleline_comment|// 2MB
r_case
l_int|0x64
suffix:colon
id|info-&gt;pageshift
op_assign
l_int|8
suffix:semicolon
id|info-&gt;smallpageshift
op_assign
l_int|1
suffix:semicolon
r_case
l_int|0x5d
suffix:colon
singleline_comment|// 5d is a ROM card with pagesize 512.
r_return
l_int|0x00200000
suffix:semicolon
r_case
l_int|0xe3
suffix:colon
singleline_comment|// 4MB
r_case
l_int|0xe5
suffix:colon
r_case
l_int|0x6b
suffix:colon
r_case
l_int|0xd5
suffix:colon
r_return
l_int|0x00400000
suffix:semicolon
r_case
l_int|0xe6
suffix:colon
singleline_comment|// 8MB
r_case
l_int|0xd6
suffix:colon
r_return
l_int|0x00800000
suffix:semicolon
r_case
l_int|0x73
suffix:colon
singleline_comment|// 16MB
id|info-&gt;blocksize
op_assign
l_int|32
suffix:semicolon
id|info-&gt;blockshift
op_assign
l_int|5
suffix:semicolon
id|info-&gt;blockmask
op_assign
l_int|31
suffix:semicolon
r_return
l_int|0x01000000
suffix:semicolon
r_case
l_int|0x75
suffix:colon
singleline_comment|// 32MB
id|info-&gt;blocksize
op_assign
l_int|32
suffix:semicolon
id|info-&gt;blockshift
op_assign
l_int|5
suffix:semicolon
id|info-&gt;blockmask
op_assign
l_int|31
suffix:semicolon
r_return
l_int|0x02000000
suffix:semicolon
r_case
l_int|0x76
suffix:colon
singleline_comment|// 64MB
id|info-&gt;blocksize
op_assign
l_int|32
suffix:semicolon
id|info-&gt;blockshift
op_assign
l_int|5
suffix:semicolon
id|info-&gt;blockmask
op_assign
l_int|31
suffix:semicolon
r_return
l_int|0x04000000
suffix:semicolon
r_case
l_int|0x79
suffix:colon
singleline_comment|// 128MB
id|info-&gt;blocksize
op_assign
l_int|32
suffix:semicolon
id|info-&gt;blockshift
op_assign
l_int|5
suffix:semicolon
id|info-&gt;blockmask
op_assign
l_int|31
suffix:semicolon
r_return
l_int|0x08000000
suffix:semicolon
r_default
suffix:colon
singleline_comment|// unknown
r_return
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|sddr55_read_map
r_static
r_int
id|sddr55_read_map
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_struct
id|sddr55_card_info
op_star
id|info
op_assign
(paren
r_struct
id|sddr55_card_info
op_star
)paren
(paren
id|us-&gt;extra
)paren
suffix:semicolon
r_int
id|numblocks
suffix:semicolon
r_int
r_char
op_star
id|buffer
suffix:semicolon
r_int
r_char
id|command
(braket
l_int|8
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0xb0
comma
l_int|0
comma
l_int|0x8a
)brace
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|lba
suffix:semicolon
r_int
r_int
id|max_lba
suffix:semicolon
r_int
id|result
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;capacity
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|numblocks
op_assign
id|info-&gt;capacity
op_rshift
(paren
id|info-&gt;blockshift
op_plus
id|info-&gt;pageshift
)paren
suffix:semicolon
id|buffer
op_assign
id|kmalloc
c_func
(paren
id|numblocks
op_star
l_int|2
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|command
(braket
l_int|6
)braket
op_assign
id|numblocks
op_star
l_int|2
op_div
l_int|256
suffix:semicolon
id|result
op_assign
id|sddr55_bulk_transport
c_func
(paren
id|us
comma
id|SCSI_DATA_WRITE
comma
id|command
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|US_BULK_TRANSFER_GOOD
)paren
(brace
id|kfree
(paren
id|buffer
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|result
op_assign
id|sddr55_bulk_transport
c_func
(paren
id|us
comma
id|SCSI_DATA_READ
comma
id|buffer
comma
id|numblocks
op_star
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|US_BULK_TRANSFER_GOOD
)paren
(brace
id|kfree
(paren
id|buffer
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|result
op_assign
id|sddr55_bulk_transport
c_func
(paren
id|us
comma
id|SCSI_DATA_READ
comma
id|command
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|US_BULK_TRANSFER_GOOD
)paren
(brace
id|kfree
(paren
id|buffer
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;lba_to_pba
)paren
id|kfree
c_func
(paren
id|info-&gt;lba_to_pba
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;pba_to_lba
)paren
id|kfree
c_func
(paren
id|info-&gt;pba_to_lba
)paren
suffix:semicolon
id|info-&gt;lba_to_pba
op_assign
id|kmalloc
c_func
(paren
id|numblocks
op_star
r_sizeof
(paren
r_int
)paren
comma
id|GFP_NOIO
)paren
suffix:semicolon
id|info-&gt;pba_to_lba
op_assign
id|kmalloc
c_func
(paren
id|numblocks
op_star
r_sizeof
(paren
r_int
)paren
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;lba_to_pba
op_eq
l_int|NULL
op_logical_or
id|info-&gt;pba_to_lba
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;lba_to_pba
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|info-&gt;lba_to_pba
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;pba_to_lba
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|info-&gt;pba_to_lba
)paren
suffix:semicolon
id|info-&gt;lba_to_pba
op_assign
l_int|NULL
suffix:semicolon
id|info-&gt;pba_to_lba
op_assign
l_int|NULL
suffix:semicolon
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|memset
c_func
(paren
id|info-&gt;lba_to_pba
comma
l_int|0xff
comma
id|numblocks
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|info-&gt;pba_to_lba
comma
l_int|0xff
comma
id|numblocks
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
multiline_comment|/* set maximum lba */
id|max_lba
op_assign
id|info-&gt;max_log_blks
suffix:semicolon
r_if
c_cond
(paren
id|max_lba
OG
l_int|1000
)paren
id|max_lba
op_assign
l_int|1000
suffix:semicolon
singleline_comment|// Each block is 64 bytes of control data, so block i is located in
singleline_comment|// scatterlist block i*64/128k = i*(2^6)*(2^-17) = i*(2^-11)
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numblocks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|zone
op_assign
id|i
op_div
l_int|1024
suffix:semicolon
id|lba
op_assign
id|short_pack
c_func
(paren
id|buffer
(braket
id|i
op_star
l_int|2
)braket
comma
id|buffer
(braket
id|i
op_star
l_int|2
op_plus
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/* Every 1024 physical blocks (&quot;zone&quot;), the LBA numbers&n;&t;&t;&t; * go back to zero, but are within a higher&n;&t;&t;&t; * block of LBA&squot;s. Also, there is a maximum of&n;&t;&t;&t; * 1000 LBA&squot;s per zone. In other words, in PBA&n;&t;&t;&t; * 1024-2047 you will find LBA 0-999 which are&n;&t;&t;&t; * really LBA 1000-1999. Yes, this wastes 24&n;&t;&t;&t; * physical blocks per zone. Go figure. &n;&t;&t;&t; * These devices can have blocks go bad, so there&n;&t;&t;&t; * are 24 spare blocks to use when blocks do go bad.&n;&t;&t;&t; */
multiline_comment|/* SDDR55 returns 0xffff for a bad block, and 0x400 for the &n;&t;&t;&t; * CIS block. (Is this true for cards 8MB or less??)&n;&t;&t;&t; * Record these in the physical to logical map&n;&t;&t;&t; */
id|info-&gt;pba_to_lba
(braket
id|i
)braket
op_assign
id|lba
suffix:semicolon
r_if
c_cond
(paren
id|lba
op_ge
id|max_lba
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;lba_to_pba
(braket
id|lba
op_plus
id|zone
op_star
l_int|1000
)braket
op_ne
id|NOT_ALLOCATED
op_logical_and
op_logical_neg
id|info-&gt;force_read_only
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sddr55: map inconsistency at LBA %04X&bslash;n&quot;
comma
id|lba
op_plus
id|zone
op_star
l_int|1000
)paren
suffix:semicolon
id|info-&gt;force_read_only
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lba
OL
l_int|0x10
op_logical_or
(paren
id|lba
op_ge
l_int|0x3E0
op_logical_and
id|lba
OL
l_int|0x3EF
)paren
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;LBA %04X &lt;-&gt; PBA %04X&bslash;n&quot;
comma
id|lba
comma
id|i
)paren
suffix:semicolon
id|info-&gt;lba_to_pba
(braket
id|lba
op_plus
id|zone
op_star
l_int|1000
)braket
op_assign
id|i
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sddr55_card_info_destructor
r_static
r_void
id|sddr55_card_info_destructor
c_func
(paren
r_void
op_star
id|extra
)paren
(brace
r_struct
id|sddr55_card_info
op_star
id|info
op_assign
(paren
r_struct
id|sddr55_card_info
op_star
)paren
id|extra
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|extra
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;lba_to_pba
)paren
id|kfree
c_func
(paren
id|info-&gt;lba_to_pba
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;pba_to_lba
)paren
id|kfree
c_func
(paren
id|info-&gt;pba_to_lba
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Transport for the Sandisk SDDR-55&n; */
DECL|function|sddr55_transport
r_int
id|sddr55_transport
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_char
id|inquiry_response
(braket
l_int|36
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0x80
comma
l_int|0x00
comma
l_int|0x02
comma
l_int|0x1F
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
r_int
r_char
id|mode_page_01
(braket
l_int|16
)braket
op_assign
(brace
singleline_comment|// write-protected for now
l_int|0x03
comma
l_int|0x00
comma
l_int|0x80
comma
l_int|0x00
comma
l_int|0x01
comma
l_int|0x0A
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
r_int
r_int
id|capacity
suffix:semicolon
r_int
r_int
id|lba
suffix:semicolon
r_int
r_int
id|pba
suffix:semicolon
r_int
r_int
id|page
suffix:semicolon
r_int
r_int
id|pages
suffix:semicolon
r_struct
id|sddr55_card_info
op_star
id|info
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|us-&gt;extra
)paren
(brace
id|us-&gt;extra
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|sddr55_card_info
)paren
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|us-&gt;extra
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|memset
c_func
(paren
id|us-&gt;extra
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|sddr55_card_info
)paren
)paren
suffix:semicolon
id|us-&gt;extra_destructor
op_assign
id|sddr55_card_info_destructor
suffix:semicolon
)brace
id|info
op_assign
(paren
r_struct
id|sddr55_card_info
op_star
)paren
(paren
id|us-&gt;extra
)paren
suffix:semicolon
id|ptr
op_assign
(paren
r_int
r_char
op_star
)paren
id|srb-&gt;request_buffer
suffix:semicolon
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
(brace
id|i
op_assign
id|srb-&gt;cmnd
(braket
l_int|4
)braket
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
r_sizeof
id|info-&gt;sense_data
)paren
id|i
op_assign
r_sizeof
id|info-&gt;sense_data
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;SDDR55: request sense %02x/%02x/%02x&bslash;n&quot;
comma
id|info-&gt;sense_data
(braket
l_int|2
)braket
comma
id|info-&gt;sense_data
(braket
l_int|12
)braket
comma
id|info-&gt;sense_data
(braket
l_int|13
)braket
)paren
suffix:semicolon
id|info-&gt;sense_data
(braket
l_int|0
)braket
op_assign
l_int|0x70
suffix:semicolon
id|info-&gt;sense_data
(braket
l_int|7
)braket
op_assign
l_int|10
suffix:semicolon
id|memcpy
(paren
id|ptr
comma
id|info-&gt;sense_data
comma
id|i
)paren
suffix:semicolon
id|memset
(paren
id|info-&gt;sense_data
comma
l_int|0
comma
r_sizeof
id|info-&gt;sense_data
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
id|memset
(paren
id|info-&gt;sense_data
comma
l_int|0
comma
r_sizeof
id|info-&gt;sense_data
)paren
suffix:semicolon
multiline_comment|/* Dummy up a response for INQUIRY since SDDR55 doesn&squot;t&n;&t;   respond to INQUIRY commands */
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
(brace
id|memset
c_func
(paren
id|inquiry_response
op_plus
l_int|8
comma
l_int|0
comma
l_int|28
)paren
suffix:semicolon
id|fill_inquiry_response
c_func
(paren
id|us
comma
id|inquiry_response
comma
l_int|36
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
multiline_comment|/* only check card status if the map isn&squot;t allocated, ie no card seen yet&n;&t; * or if it&squot;s been over half a second since we last accessed it&n;&t; */
r_if
c_cond
(paren
id|info-&gt;lba_to_pba
op_eq
l_int|NULL
op_logical_or
id|jiffies
OG
(paren
id|info-&gt;last_access
op_plus
id|HZ
op_div
l_int|2
)paren
)paren
(brace
multiline_comment|/* check to see if a card is fitted */
id|result
op_assign
id|sddr55_status
(paren
id|us
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
id|result
op_assign
id|sddr55_status
(paren
id|us
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
(brace
id|set_sense_info
(paren
l_int|6
comma
l_int|0x28
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* new media, set unit attention, not ready to ready */
)brace
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
)brace
multiline_comment|/* if we detected a problem with the map when writing,&n;&t;   don&squot;t allow any more access */
r_if
c_cond
(paren
id|info-&gt;fatal_error
)paren
(brace
id|set_sense_info
(paren
l_int|3
comma
l_int|0x31
comma
l_int|0
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|READ_CAPACITY
)paren
(brace
id|capacity
op_assign
id|sddr55_get_capacity
c_func
(paren
id|us
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capacity
)paren
(brace
id|set_sense_info
(paren
l_int|3
comma
l_int|0x30
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* incompatible medium */
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
id|info-&gt;capacity
op_assign
id|capacity
suffix:semicolon
multiline_comment|/* figure out the maximum logical block number, allowing for&n;&t;&t; * the fact that only 250 out of every 256 are used */
id|info-&gt;max_log_blks
op_assign
(paren
(paren
id|info-&gt;capacity
op_rshift
(paren
id|info-&gt;pageshift
op_plus
id|info-&gt;blockshift
)paren
)paren
op_div
l_int|256
)paren
op_star
l_int|250
suffix:semicolon
multiline_comment|/* Last page in the card, adjust as we only use 250 out of every 256 pages */
id|capacity
op_assign
(paren
id|capacity
op_div
l_int|256
)paren
op_star
l_int|250
suffix:semicolon
id|capacity
op_div_assign
id|PAGESIZE
suffix:semicolon
id|capacity
op_decrement
suffix:semicolon
id|ptr
(braket
l_int|0
)braket
op_assign
id|MSB_of
c_func
(paren
id|capacity
op_rshift
l_int|16
)paren
suffix:semicolon
id|ptr
(braket
l_int|1
)braket
op_assign
id|LSB_of
c_func
(paren
id|capacity
op_rshift
l_int|16
)paren
suffix:semicolon
id|ptr
(braket
l_int|2
)braket
op_assign
id|MSB_of
c_func
(paren
id|capacity
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
id|ptr
(braket
l_int|3
)braket
op_assign
id|LSB_of
c_func
(paren
id|capacity
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
singleline_comment|// The page size
id|ptr
(braket
l_int|4
)braket
op_assign
id|MSB_of
c_func
(paren
id|PAGESIZE
op_rshift
l_int|16
)paren
suffix:semicolon
id|ptr
(braket
l_int|5
)braket
op_assign
id|LSB_of
c_func
(paren
id|PAGESIZE
op_rshift
l_int|16
)paren
suffix:semicolon
id|ptr
(braket
l_int|6
)braket
op_assign
id|MSB_of
c_func
(paren
id|PAGESIZE
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
id|ptr
(braket
l_int|7
)braket
op_assign
id|LSB_of
c_func
(paren
id|PAGESIZE
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
id|sddr55_read_map
c_func
(paren
id|us
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|MODE_SENSE
)paren
(brace
id|mode_page_01
(braket
l_int|2
)braket
op_assign
(paren
id|info-&gt;read_only
op_logical_or
id|info-&gt;force_read_only
)paren
ques
c_cond
l_int|0x80
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|srb-&gt;cmnd
(braket
l_int|2
)braket
op_amp
l_int|0x3F
)paren
op_eq
l_int|0x01
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;SDDR55: Dummy up request for mode page 1&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
op_eq
l_int|NULL
op_logical_or
id|srb-&gt;request_bufflen
OL
r_sizeof
(paren
id|mode_page_01
)paren
)paren
(brace
id|set_sense_info
(paren
l_int|5
comma
l_int|0x24
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* invalid field in command */
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|ptr
comma
id|mode_page_01
comma
r_sizeof
(paren
id|mode_page_01
)paren
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|srb-&gt;cmnd
(braket
l_int|2
)braket
op_amp
l_int|0x3F
)paren
op_eq
l_int|0x3F
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;SDDR55: Dummy up request for all mode pages&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
op_eq
l_int|NULL
op_logical_or
id|srb-&gt;request_bufflen
OL
r_sizeof
(paren
id|mode_page_01
)paren
)paren
(brace
id|set_sense_info
(paren
l_int|5
comma
l_int|0x24
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* invalid field in command */
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|ptr
comma
id|mode_page_01
comma
r_sizeof
(paren
id|mode_page_01
)paren
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
id|set_sense_info
(paren
l_int|5
comma
l_int|0x24
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* invalid field in command */
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|ALLOW_MEDIUM_REMOVAL
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;SDDR55: %s medium removal. Not that I can do&quot;
l_string|&quot; anything about it...&bslash;n&quot;
comma
(paren
id|srb-&gt;cmnd
(braket
l_int|4
)braket
op_amp
l_int|0x03
)paren
ques
c_cond
l_string|&quot;Prevent&quot;
suffix:colon
l_string|&quot;Allow&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|READ_10
op_logical_or
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|WRITE_10
)paren
(brace
id|page
op_assign
id|short_pack
c_func
(paren
id|srb-&gt;cmnd
(braket
l_int|3
)braket
comma
id|srb-&gt;cmnd
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|page
op_lshift_assign
l_int|16
suffix:semicolon
id|page
op_or_assign
id|short_pack
c_func
(paren
id|srb-&gt;cmnd
(braket
l_int|5
)braket
comma
id|srb-&gt;cmnd
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|pages
op_assign
id|short_pack
c_func
(paren
id|srb-&gt;cmnd
(braket
l_int|8
)braket
comma
id|srb-&gt;cmnd
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|page
op_lshift_assign
id|info-&gt;smallpageshift
suffix:semicolon
singleline_comment|// convert page to block and page-within-block
id|lba
op_assign
id|page
op_rshift
id|info-&gt;blockshift
suffix:semicolon
id|page
op_assign
id|page
op_amp
id|info-&gt;blockmask
suffix:semicolon
singleline_comment|// locate physical block corresponding to logical block
r_if
c_cond
(paren
id|lba
op_ge
id|info-&gt;max_log_blks
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Error: Requested LBA %04X exceeds maximum &quot;
l_string|&quot;block %04X&bslash;n&quot;
comma
id|lba
comma
id|info-&gt;max_log_blks
op_minus
l_int|1
)paren
suffix:semicolon
id|set_sense_info
(paren
l_int|5
comma
l_int|0x24
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* invalid field in command */
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
id|pba
op_assign
id|info-&gt;lba_to_pba
(braket
id|lba
)braket
suffix:semicolon
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|WRITE_10
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;WRITE_10: write block %04X (LBA %04X) page %01X&quot;
l_string|&quot; pages %d&bslash;n&quot;
comma
id|pba
comma
id|lba
comma
id|page
comma
id|pages
)paren
suffix:semicolon
r_return
id|sddr55_write_data
c_func
(paren
id|us
comma
id|lba
comma
id|page
comma
id|pages
comma
id|ptr
comma
id|srb-&gt;use_sg
)paren
suffix:semicolon
)brace
r_else
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;READ_10: read block %04X (LBA %04X) page %01X&quot;
l_string|&quot; pages %d&bslash;n&quot;
comma
id|pba
comma
id|lba
comma
id|page
comma
id|pages
)paren
suffix:semicolon
r_return
id|sddr55_read_data
c_func
(paren
id|us
comma
id|lba
comma
id|page
comma
id|pages
comma
id|ptr
comma
id|srb-&gt;use_sg
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|TEST_UNIT_READY
)paren
(brace
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|START_STOP
)paren
(brace
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
id|set_sense_info
(paren
l_int|5
comma
l_int|0x20
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* illegal command */
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
singleline_comment|// FIXME: sense buffer?
)brace
eof
