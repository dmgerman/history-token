multiline_comment|/* Transport &amp; Protocol Driver for In-System Design, Inc. ISD200 ASIC&n; *&n; * First release&n; *&n; * Current development and maintenance by:&n; *   (c) 2000 In-System Design, Inc. (support@in-system.com)&n; *&n; * The ISD200 ASIC does not natively support ATA devices.  The chip&n; * does implement an interface, the ATA Command Block (ATACB) which provides&n; * a means of passing ATA commands and ATA register accesses to a device.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2, or (at your option) any&n; * later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write to the Free Software Foundation, Inc.,&n; * 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; * History:&n; *&n; *  2001-02-24: Removed lots of duplicate code and simplified the structure.&n; *              (bjorn@haxx.se)&n; */
multiline_comment|/* Include files */
macro_line|#include &quot;transport.h&quot;
macro_line|#include &quot;protocol.h&quot;
macro_line|#include &quot;usb.h&quot;
macro_line|#include &quot;debug.h&quot;
macro_line|#include &quot;scsiglue.h&quot;
macro_line|#include &quot;isd200.h&quot;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/ide.h&gt;
multiline_comment|/*&n; * Inquiry defines. Used to interpret data returned from target as result&n; * of inquiry command.&n; *&n; * DeviceType field&n; */
DECL|macro|DIRECT_ACCESS_DEVICE
mdefine_line|#define DIRECT_ACCESS_DEVICE            0x00    /* disks */
multiline_comment|/* Timeout defines (in Seconds) */
DECL|macro|ISD200_ENUM_BSY_TIMEOUT
mdefine_line|#define ISD200_ENUM_BSY_TIMEOUT         35
DECL|macro|ISD200_ENUM_DETECT_TIMEOUT
mdefine_line|#define ISD200_ENUM_DETECT_TIMEOUT      30
DECL|macro|ISD200_DEFAULT_TIMEOUT
mdefine_line|#define ISD200_DEFAULT_TIMEOUT          30
multiline_comment|/* device flags */
DECL|macro|DF_ATA_DEVICE
mdefine_line|#define DF_ATA_DEVICE               0x0001
DECL|macro|DF_MEDIA_STATUS_ENABLED
mdefine_line|#define DF_MEDIA_STATUS_ENABLED     0x0002
DECL|macro|DF_REMOVABLE_MEDIA
mdefine_line|#define DF_REMOVABLE_MEDIA          0x0004
multiline_comment|/* capability bit definitions */
DECL|macro|CAPABILITY_DMA
mdefine_line|#define CAPABILITY_DMA&t;&t;0x01
DECL|macro|CAPABILITY_LBA
mdefine_line|#define CAPABILITY_LBA&t;&t;0x02
multiline_comment|/* command_setX bit definitions */
DECL|macro|COMMANDSET_REMOVABLE
mdefine_line|#define COMMANDSET_REMOVABLE&t;0x02
DECL|macro|COMMANDSET_MEDIA_STATUS
mdefine_line|#define COMMANDSET_MEDIA_STATUS 0x10
multiline_comment|/* ATA Vendor Specific defines */
DECL|macro|ATA_ADDRESS_DEVHEAD_STD
mdefine_line|#define ATA_ADDRESS_DEVHEAD_STD      0xa0
DECL|macro|ATA_ADDRESS_DEVHEAD_LBA_MODE
mdefine_line|#define ATA_ADDRESS_DEVHEAD_LBA_MODE 0x40    
DECL|macro|ATA_ADDRESS_DEVHEAD_SLAVE
mdefine_line|#define ATA_ADDRESS_DEVHEAD_SLAVE    0x10
multiline_comment|/* Action Select bits */
DECL|macro|ACTION_SELECT_0
mdefine_line|#define ACTION_SELECT_0             0x01
DECL|macro|ACTION_SELECT_1
mdefine_line|#define ACTION_SELECT_1             0x02
DECL|macro|ACTION_SELECT_2
mdefine_line|#define ACTION_SELECT_2             0x04
DECL|macro|ACTION_SELECT_3
mdefine_line|#define ACTION_SELECT_3             0x08
DECL|macro|ACTION_SELECT_4
mdefine_line|#define ACTION_SELECT_4             0x10
DECL|macro|ACTION_SELECT_5
mdefine_line|#define ACTION_SELECT_5             0x20
DECL|macro|ACTION_SELECT_6
mdefine_line|#define ACTION_SELECT_6             0x40
DECL|macro|ACTION_SELECT_7
mdefine_line|#define ACTION_SELECT_7             0x80
multiline_comment|/* ATA error definitions not in &lt;linux/hdreg.h&gt; */
DECL|macro|ATA_ERROR_MEDIA_CHANGE
mdefine_line|#define ATA_ERROR_MEDIA_CHANGE       0x20
multiline_comment|/* ATA command definitions not in &lt;linux/hdreg.h&gt; */
DECL|macro|ATA_COMMAND_GET_MEDIA_STATUS
mdefine_line|#define ATA_COMMAND_GET_MEDIA_STATUS        0xDA
DECL|macro|ATA_COMMAND_MEDIA_EJECT
mdefine_line|#define ATA_COMMAND_MEDIA_EJECT             0xED
multiline_comment|/* ATA drive control definitions */
DECL|macro|ATA_DC_DISABLE_INTERRUPTS
mdefine_line|#define ATA_DC_DISABLE_INTERRUPTS    0x02
DECL|macro|ATA_DC_RESET_CONTROLLER
mdefine_line|#define ATA_DC_RESET_CONTROLLER      0x04
DECL|macro|ATA_DC_REENABLE_CONTROLLER
mdefine_line|#define ATA_DC_REENABLE_CONTROLLER   0x00
multiline_comment|/*&n; *  General purpose return codes&n; */
DECL|macro|ISD200_ERROR
mdefine_line|#define ISD200_ERROR                -1
DECL|macro|ISD200_GOOD
mdefine_line|#define ISD200_GOOD                 0
multiline_comment|/*&n; * Transport return codes&n; */
DECL|macro|ISD200_TRANSPORT_GOOD
mdefine_line|#define ISD200_TRANSPORT_GOOD       0   /* Transport good, command good     */
DECL|macro|ISD200_TRANSPORT_FAILED
mdefine_line|#define ISD200_TRANSPORT_FAILED     1   /* Transport good, command failed   */
DECL|macro|ISD200_TRANSPORT_ERROR
mdefine_line|#define ISD200_TRANSPORT_ERROR      2   /* Transport bad (i.e. device dead) */
DECL|macro|ISD200_TRANSPORT_ABORTED
mdefine_line|#define ISD200_TRANSPORT_ABORTED    3   /* Transport aborted                */
DECL|macro|ISD200_TRANSPORT_SHORT
mdefine_line|#define ISD200_TRANSPORT_SHORT      4   /* Transport short                  */
multiline_comment|/* driver action codes */
DECL|macro|ACTION_READ_STATUS
mdefine_line|#define&t;ACTION_READ_STATUS&t;0
DECL|macro|ACTION_RESET
mdefine_line|#define&t;ACTION_RESET&t;&t;1
DECL|macro|ACTION_REENABLE
mdefine_line|#define&t;ACTION_REENABLE&t;&t;2
DECL|macro|ACTION_SOFT_RESET
mdefine_line|#define&t;ACTION_SOFT_RESET&t;3
DECL|macro|ACTION_ENUM
mdefine_line|#define&t;ACTION_ENUM&t;&t;4
DECL|macro|ACTION_IDENTIFY
mdefine_line|#define&t;ACTION_IDENTIFY&t;&t;5
multiline_comment|/*&n; * ata_cdb struct&n; */
DECL|union|ata_cdb
r_union
id|ata_cdb
(brace
r_struct
(brace
DECL|member|SignatureByte0
r_int
r_char
id|SignatureByte0
suffix:semicolon
DECL|member|SignatureByte1
r_int
r_char
id|SignatureByte1
suffix:semicolon
DECL|member|ActionSelect
r_int
r_char
id|ActionSelect
suffix:semicolon
DECL|member|RegisterSelect
r_int
r_char
id|RegisterSelect
suffix:semicolon
DECL|member|TransferBlockSize
r_int
r_char
id|TransferBlockSize
suffix:semicolon
DECL|member|WriteData3F6
r_int
r_char
id|WriteData3F6
suffix:semicolon
DECL|member|WriteData1F1
r_int
r_char
id|WriteData1F1
suffix:semicolon
DECL|member|WriteData1F2
r_int
r_char
id|WriteData1F2
suffix:semicolon
DECL|member|WriteData1F3
r_int
r_char
id|WriteData1F3
suffix:semicolon
DECL|member|WriteData1F4
r_int
r_char
id|WriteData1F4
suffix:semicolon
DECL|member|WriteData1F5
r_int
r_char
id|WriteData1F5
suffix:semicolon
DECL|member|WriteData1F6
r_int
r_char
id|WriteData1F6
suffix:semicolon
DECL|member|WriteData1F7
r_int
r_char
id|WriteData1F7
suffix:semicolon
DECL|member|Reserved
r_int
r_char
id|Reserved
(braket
l_int|3
)braket
suffix:semicolon
DECL|member|generic
)brace
id|generic
suffix:semicolon
r_struct
(brace
DECL|member|SignatureByte0
r_int
r_char
id|SignatureByte0
suffix:semicolon
DECL|member|SignatureByte1
r_int
r_char
id|SignatureByte1
suffix:semicolon
DECL|member|ReadRegisterAccessBit
r_int
r_char
id|ReadRegisterAccessBit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|NoDeviceSelectionBit
r_int
r_char
id|NoDeviceSelectionBit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|NoBSYPollBit
r_int
r_char
id|NoBSYPollBit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|IgnorePhaseErrorBit
r_int
r_char
id|IgnorePhaseErrorBit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|IgnoreDeviceErrorBit
r_int
r_char
id|IgnoreDeviceErrorBit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|Reserved0Bit
r_int
r_char
id|Reserved0Bit
suffix:colon
l_int|3
suffix:semicolon
DECL|member|SelectAlternateStatus
r_int
r_char
id|SelectAlternateStatus
suffix:colon
l_int|1
suffix:semicolon
DECL|member|SelectError
r_int
r_char
id|SelectError
suffix:colon
l_int|1
suffix:semicolon
DECL|member|SelectSectorCount
r_int
r_char
id|SelectSectorCount
suffix:colon
l_int|1
suffix:semicolon
DECL|member|SelectSectorNumber
r_int
r_char
id|SelectSectorNumber
suffix:colon
l_int|1
suffix:semicolon
DECL|member|SelectCylinderLow
r_int
r_char
id|SelectCylinderLow
suffix:colon
l_int|1
suffix:semicolon
DECL|member|SelectCylinderHigh
r_int
r_char
id|SelectCylinderHigh
suffix:colon
l_int|1
suffix:semicolon
DECL|member|SelectDeviceHead
r_int
r_char
id|SelectDeviceHead
suffix:colon
l_int|1
suffix:semicolon
DECL|member|SelectStatus
r_int
r_char
id|SelectStatus
suffix:colon
l_int|1
suffix:semicolon
DECL|member|TransferBlockSize
r_int
r_char
id|TransferBlockSize
suffix:semicolon
DECL|member|AlternateStatusByte
r_int
r_char
id|AlternateStatusByte
suffix:semicolon
DECL|member|ErrorByte
r_int
r_char
id|ErrorByte
suffix:semicolon
DECL|member|SectorCountByte
r_int
r_char
id|SectorCountByte
suffix:semicolon
DECL|member|SectorNumberByte
r_int
r_char
id|SectorNumberByte
suffix:semicolon
DECL|member|CylinderLowByte
r_int
r_char
id|CylinderLowByte
suffix:semicolon
DECL|member|CylinderHighByte
r_int
r_char
id|CylinderHighByte
suffix:semicolon
DECL|member|DeviceHeadByte
r_int
r_char
id|DeviceHeadByte
suffix:semicolon
DECL|member|StatusByte
r_int
r_char
id|StatusByte
suffix:semicolon
DECL|member|Reserved
r_int
r_char
id|Reserved
(braket
l_int|3
)braket
suffix:semicolon
DECL|member|read
)brace
id|read
suffix:semicolon
r_struct
(brace
DECL|member|SignatureByte0
r_int
r_char
id|SignatureByte0
suffix:semicolon
DECL|member|SignatureByte1
r_int
r_char
id|SignatureByte1
suffix:semicolon
DECL|member|ReadRegisterAccessBit
r_int
r_char
id|ReadRegisterAccessBit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|NoDeviceSelectionBit
r_int
r_char
id|NoDeviceSelectionBit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|NoBSYPollBit
r_int
r_char
id|NoBSYPollBit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|IgnorePhaseErrorBit
r_int
r_char
id|IgnorePhaseErrorBit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|IgnoreDeviceErrorBit
r_int
r_char
id|IgnoreDeviceErrorBit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|Reserved0Bit
r_int
r_char
id|Reserved0Bit
suffix:colon
l_int|3
suffix:semicolon
DECL|member|SelectDeviceControl
r_int
r_char
id|SelectDeviceControl
suffix:colon
l_int|1
suffix:semicolon
DECL|member|SelectFeatures
r_int
r_char
id|SelectFeatures
suffix:colon
l_int|1
suffix:semicolon
DECL|member|SelectSectorCount
r_int
r_char
id|SelectSectorCount
suffix:colon
l_int|1
suffix:semicolon
DECL|member|SelectSectorNumber
r_int
r_char
id|SelectSectorNumber
suffix:colon
l_int|1
suffix:semicolon
DECL|member|SelectCylinderLow
r_int
r_char
id|SelectCylinderLow
suffix:colon
l_int|1
suffix:semicolon
DECL|member|SelectCylinderHigh
r_int
r_char
id|SelectCylinderHigh
suffix:colon
l_int|1
suffix:semicolon
DECL|member|SelectDeviceHead
r_int
r_char
id|SelectDeviceHead
suffix:colon
l_int|1
suffix:semicolon
DECL|member|SelectCommand
r_int
r_char
id|SelectCommand
suffix:colon
l_int|1
suffix:semicolon
DECL|member|TransferBlockSize
r_int
r_char
id|TransferBlockSize
suffix:semicolon
DECL|member|DeviceControlByte
r_int
r_char
id|DeviceControlByte
suffix:semicolon
DECL|member|FeaturesByte
r_int
r_char
id|FeaturesByte
suffix:semicolon
DECL|member|SectorCountByte
r_int
r_char
id|SectorCountByte
suffix:semicolon
DECL|member|SectorNumberByte
r_int
r_char
id|SectorNumberByte
suffix:semicolon
DECL|member|CylinderLowByte
r_int
r_char
id|CylinderLowByte
suffix:semicolon
DECL|member|CylinderHighByte
r_int
r_char
id|CylinderHighByte
suffix:semicolon
DECL|member|DeviceHeadByte
r_int
r_char
id|DeviceHeadByte
suffix:semicolon
DECL|member|CommandByte
r_int
r_char
id|CommandByte
suffix:semicolon
DECL|member|Reserved
r_int
r_char
id|Reserved
(braket
l_int|3
)braket
suffix:semicolon
DECL|member|write
)brace
id|write
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Inquiry data structure. This is the data returned from the target&n; * after it receives an inquiry.&n; *&n; * This structure may be extended by the number of bytes specified&n; * in the field AdditionalLength. The defined size constant only&n; * includes fields through ProductRevisionLevel.&n; */
DECL|struct|inquiry_data
r_struct
id|inquiry_data
(brace
DECL|member|DeviceType
r_int
r_char
id|DeviceType
suffix:colon
l_int|5
suffix:semicolon
DECL|member|DeviceTypeQualifier
r_int
r_char
id|DeviceTypeQualifier
suffix:colon
l_int|3
suffix:semicolon
DECL|member|DeviceTypeModifier
r_int
r_char
id|DeviceTypeModifier
suffix:colon
l_int|7
suffix:semicolon
DECL|member|RemovableMedia
r_int
r_char
id|RemovableMedia
suffix:colon
l_int|1
suffix:semicolon
DECL|member|Versions
r_int
r_char
id|Versions
suffix:semicolon
DECL|member|ResponseDataFormat
r_int
r_char
id|ResponseDataFormat
suffix:colon
l_int|4
suffix:semicolon
DECL|member|HiSupport
r_int
r_char
id|HiSupport
suffix:colon
l_int|1
suffix:semicolon
DECL|member|NormACA
r_int
r_char
id|NormACA
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ReservedBit
r_int
r_char
id|ReservedBit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|AERC
r_int
r_char
id|AERC
suffix:colon
l_int|1
suffix:semicolon
DECL|member|AdditionalLength
r_int
r_char
id|AdditionalLength
suffix:semicolon
DECL|member|Reserved
r_int
r_char
id|Reserved
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|SoftReset
r_int
r_char
id|SoftReset
suffix:colon
l_int|1
suffix:semicolon
DECL|member|CommandQueue
r_int
r_char
id|CommandQueue
suffix:colon
l_int|1
suffix:semicolon
DECL|member|Reserved2
r_int
r_char
id|Reserved2
suffix:colon
l_int|1
suffix:semicolon
DECL|member|LinkedCommands
r_int
r_char
id|LinkedCommands
suffix:colon
l_int|1
suffix:semicolon
DECL|member|Synchronous
r_int
r_char
id|Synchronous
suffix:colon
l_int|1
suffix:semicolon
DECL|member|Wide16Bit
r_int
r_char
id|Wide16Bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|Wide32Bit
r_int
r_char
id|Wide32Bit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|RelativeAddressing
r_int
r_char
id|RelativeAddressing
suffix:colon
l_int|1
suffix:semicolon
DECL|member|VendorId
r_int
r_char
id|VendorId
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|ProductId
r_int
r_char
id|ProductId
(braket
l_int|16
)braket
suffix:semicolon
DECL|member|ProductRevisionLevel
r_int
r_char
id|ProductRevisionLevel
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|VendorSpecific
r_int
r_char
id|VendorSpecific
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|Reserved3
r_int
r_char
id|Reserved3
(braket
l_int|40
)braket
suffix:semicolon
)brace
id|__attribute__
(paren
(paren
id|packed
)paren
)paren
suffix:semicolon
multiline_comment|/*&n; * INQUIRY data buffer size&n; */
DECL|macro|INQUIRYDATABUFFERSIZE
mdefine_line|#define INQUIRYDATABUFFERSIZE 36
multiline_comment|/*&n; * ISD200 CONFIG data struct&n; */
DECL|struct|isd200_config
r_struct
id|isd200_config
(brace
DECL|member|EventNotification
r_int
r_char
id|EventNotification
suffix:semicolon
DECL|member|ExternalClock
r_int
r_char
id|ExternalClock
suffix:semicolon
DECL|member|ATAInitTimeout
r_int
r_char
id|ATAInitTimeout
suffix:semicolon
DECL|member|ATATiming
r_int
r_char
id|ATATiming
suffix:colon
l_int|4
suffix:semicolon
DECL|member|ATAPIReset
r_int
r_char
id|ATAPIReset
suffix:colon
l_int|1
suffix:semicolon
DECL|member|MasterSlaveSelection
r_int
r_char
id|MasterSlaveSelection
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ATAPICommandBlockSize
r_int
r_char
id|ATAPICommandBlockSize
suffix:colon
l_int|2
suffix:semicolon
DECL|member|ATAMajorCommand
r_int
r_char
id|ATAMajorCommand
suffix:semicolon
DECL|member|ATAMinorCommand
r_int
r_char
id|ATAMinorCommand
suffix:semicolon
DECL|member|LastLUNIdentifier
r_int
r_char
id|LastLUNIdentifier
suffix:colon
l_int|3
suffix:semicolon
DECL|member|DescriptOverride
r_int
r_char
id|DescriptOverride
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ATA3StateSuspend
r_int
r_char
id|ATA3StateSuspend
suffix:colon
l_int|1
suffix:semicolon
DECL|member|SkipDeviceBoot
r_int
r_char
id|SkipDeviceBoot
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ConfigDescriptor2
r_int
r_char
id|ConfigDescriptor2
suffix:colon
l_int|1
suffix:semicolon
DECL|member|InitStatus
r_int
r_char
id|InitStatus
suffix:colon
l_int|1
suffix:semicolon
DECL|member|SRSTEnable
r_int
r_char
id|SRSTEnable
suffix:colon
l_int|1
suffix:semicolon
DECL|member|Reserved0
r_int
r_char
id|Reserved0
suffix:colon
l_int|7
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * ISD200 driver information struct&n; */
DECL|struct|isd200_info
r_struct
id|isd200_info
(brace
DECL|member|InquiryData
r_struct
id|inquiry_data
id|InquiryData
suffix:semicolon
DECL|member|drive
r_struct
id|hd_driveid
id|drive
suffix:semicolon
DECL|member|ConfigData
r_struct
id|isd200_config
id|ConfigData
suffix:semicolon
DECL|member|ATARegs
r_int
r_char
id|ATARegs
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|DeviceHead
r_int
r_char
id|DeviceHead
suffix:semicolon
DECL|member|DeviceFlags
r_int
r_char
id|DeviceFlags
suffix:semicolon
multiline_comment|/* maximum number of LUNs supported */
DECL|member|MaxLUNs
r_int
r_char
id|MaxLUNs
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Read Capacity Data - returned in Big Endian format&n; */
DECL|struct|read_capacity_data
r_struct
id|read_capacity_data
(brace
DECL|member|LogicalBlockAddress
r_int
r_int
id|LogicalBlockAddress
suffix:semicolon
DECL|member|BytesPerBlock
r_int
r_int
id|BytesPerBlock
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Read Block Limits Data - returned in Big Endian format&n; * This structure returns the maximum and minimum block&n; * size for a TAPE device.&n; */
DECL|struct|read_block_limits
r_struct
id|read_block_limits
(brace
DECL|member|Reserved
r_int
r_char
id|Reserved
suffix:semicolon
DECL|member|BlockMaximumSize
r_int
r_char
id|BlockMaximumSize
(braket
l_int|3
)braket
suffix:semicolon
DECL|member|BlockMinimumSize
r_int
r_char
id|BlockMinimumSize
(braket
l_int|2
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Sense Data Format&n; */
DECL|struct|sense_data
r_struct
id|sense_data
(brace
DECL|member|ErrorCode
r_int
r_char
id|ErrorCode
suffix:colon
l_int|7
suffix:semicolon
DECL|member|Valid
r_int
r_char
id|Valid
suffix:colon
l_int|1
suffix:semicolon
DECL|member|SegmentNumber
r_int
r_char
id|SegmentNumber
suffix:semicolon
DECL|member|SenseKey
r_int
r_char
id|SenseKey
suffix:colon
l_int|4
suffix:semicolon
DECL|member|Reserved
r_int
r_char
id|Reserved
suffix:colon
l_int|1
suffix:semicolon
DECL|member|IncorrectLength
r_int
r_char
id|IncorrectLength
suffix:colon
l_int|1
suffix:semicolon
DECL|member|EndOfMedia
r_int
r_char
id|EndOfMedia
suffix:colon
l_int|1
suffix:semicolon
DECL|member|FileMark
r_int
r_char
id|FileMark
suffix:colon
l_int|1
suffix:semicolon
DECL|member|Information
r_int
r_char
id|Information
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|AdditionalSenseLength
r_int
r_char
id|AdditionalSenseLength
suffix:semicolon
DECL|member|CommandSpecificInformation
r_int
r_char
id|CommandSpecificInformation
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|AdditionalSenseCode
r_int
r_char
id|AdditionalSenseCode
suffix:semicolon
DECL|member|AdditionalSenseCodeQualifier
r_int
r_char
id|AdditionalSenseCodeQualifier
suffix:semicolon
DECL|member|FieldReplaceableUnitCode
r_int
r_char
id|FieldReplaceableUnitCode
suffix:semicolon
DECL|member|SenseKeySpecific
r_int
r_char
id|SenseKeySpecific
(braket
l_int|3
)braket
suffix:semicolon
)brace
id|__attribute__
(paren
(paren
id|packed
)paren
)paren
suffix:semicolon
multiline_comment|/*&n; * Default request sense buffer size&n; */
DECL|macro|SENSE_BUFFER_SIZE
mdefine_line|#define SENSE_BUFFER_SIZE 18
multiline_comment|/***********************************************************************&n; * Helper routines&n; ***********************************************************************/
multiline_comment|/**************************************************************************&n; * isd200_build_sense&n; *                                                                         &n; *  Builds an artificial sense buffer to report the results of a &n; *  failed command.&n; *                                                                       &n; * RETURNS:&n; *    void&n; */
DECL|function|isd200_build_sense
r_void
id|isd200_build_sense
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
id|Scsi_Cmnd
op_star
id|srb
)paren
(brace
r_struct
id|isd200_info
op_star
id|info
op_assign
(paren
r_struct
id|isd200_info
op_star
)paren
id|us-&gt;extra
suffix:semicolon
r_struct
id|sense_data
op_star
id|buf
op_assign
(paren
r_struct
id|sense_data
op_star
)paren
op_amp
id|srb-&gt;sense_buffer
(braket
l_int|0
)braket
suffix:semicolon
r_int
r_char
id|error
op_assign
id|info-&gt;ATARegs
(braket
id|IDE_ERROR_OFFSET
)braket
suffix:semicolon
r_if
c_cond
(paren
id|error
op_amp
id|ATA_ERROR_MEDIA_CHANGE
)paren
(brace
id|buf-&gt;ErrorCode
op_assign
l_int|0x70
suffix:semicolon
id|buf-&gt;Valid
op_assign
l_int|1
suffix:semicolon
id|buf-&gt;AdditionalSenseLength
op_assign
l_int|0xb
suffix:semicolon
id|buf-&gt;SenseKey
op_assign
id|UNIT_ATTENTION
suffix:semicolon
id|buf-&gt;AdditionalSenseCode
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;AdditionalSenseCodeQualifier
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|error
op_amp
id|MCR_ERR
)paren
(brace
id|buf-&gt;ErrorCode
op_assign
l_int|0x70
suffix:semicolon
id|buf-&gt;Valid
op_assign
l_int|1
suffix:semicolon
id|buf-&gt;AdditionalSenseLength
op_assign
l_int|0xb
suffix:semicolon
id|buf-&gt;SenseKey
op_assign
id|UNIT_ATTENTION
suffix:semicolon
id|buf-&gt;AdditionalSenseCode
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;AdditionalSenseCodeQualifier
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|error
op_amp
id|TRK0_ERR
)paren
(brace
id|buf-&gt;ErrorCode
op_assign
l_int|0x70
suffix:semicolon
id|buf-&gt;Valid
op_assign
l_int|1
suffix:semicolon
id|buf-&gt;AdditionalSenseLength
op_assign
l_int|0xb
suffix:semicolon
id|buf-&gt;SenseKey
op_assign
id|NOT_READY
suffix:semicolon
id|buf-&gt;AdditionalSenseCode
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;AdditionalSenseCodeQualifier
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|error
op_amp
id|ECC_ERR
)paren
(brace
id|buf-&gt;ErrorCode
op_assign
l_int|0x70
suffix:semicolon
id|buf-&gt;Valid
op_assign
l_int|1
suffix:semicolon
id|buf-&gt;AdditionalSenseLength
op_assign
l_int|0xb
suffix:semicolon
id|buf-&gt;SenseKey
op_assign
id|DATA_PROTECT
suffix:semicolon
id|buf-&gt;AdditionalSenseCode
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;AdditionalSenseCodeQualifier
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|buf-&gt;ErrorCode
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;Valid
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;AdditionalSenseLength
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;SenseKey
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;AdditionalSenseCode
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;AdditionalSenseCodeQualifier
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/***********************************************************************&n; * Data transfer routines&n; ***********************************************************************/
multiline_comment|/**************************************************************************&n; * Transfer one SCSI scatter-gather buffer via bulk transfer&n; *&n; * Note that this function is necessary because we want the ability to&n; * use scatter-gather memory.  Good performance is achieved by a combination&n; * of scatter-gather and clustering (which makes each chunk bigger).&n; *&n; * Note that the lower layer will always retry when a NAK occurs, up to the&n; * timeout limit.  Thus we don&squot;t have to worry about it for individual&n; * packets.&n; */
DECL|function|isd200_transfer_partial
r_static
r_int
id|isd200_transfer_partial
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
id|dataDirection
comma
r_char
op_star
id|buf
comma
r_int
id|length
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
id|partial
suffix:semicolon
r_int
id|pipe
suffix:semicolon
multiline_comment|/* calculate the appropriate pipe information */
r_if
c_cond
(paren
id|dataDirection
op_eq
id|SCSI_DATA_READ
)paren
id|pipe
op_assign
id|usb_rcvbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;ep_in
)paren
suffix:semicolon
r_else
id|pipe
op_assign
id|usb_sndbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;ep_out
)paren
suffix:semicolon
multiline_comment|/* transfer the data */
id|US_DEBUGP
c_func
(paren
l_string|&quot;isd200_transfer_partial(): xfer %d bytes&bslash;n&quot;
comma
id|length
)paren
suffix:semicolon
id|result
op_assign
id|usb_stor_bulk_msg
c_func
(paren
id|us
comma
id|buf
comma
id|pipe
comma
id|length
comma
op_amp
id|partial
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;usb_stor_bulk_msg() returned %d xferred %d/%d&bslash;n&quot;
comma
id|result
comma
id|partial
comma
id|length
)paren
suffix:semicolon
multiline_comment|/* if we stall, we need to clear it before we go on */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;clearing endpoint halt for pipe 0x%x&bslash;n&quot;
comma
id|pipe
)paren
suffix:semicolon
id|usb_stor_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|pipe
)paren
suffix:semicolon
)brace
multiline_comment|/* did we send all the data? */
r_if
c_cond
(paren
id|partial
op_eq
id|length
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;isd200_transfer_partial(): transfer complete&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ISD200_TRANSPORT_GOOD
suffix:semicolon
)brace
multiline_comment|/* uh oh... we have an error code, so something went wrong. */
r_if
c_cond
(paren
id|result
)paren
(brace
multiline_comment|/* NAK - that means we&squot;ve retried a few times already */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ETIMEDOUT
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;isd200_transfer_partial(): device NAKed&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ISD200_TRANSPORT_FAILED
suffix:semicolon
)brace
multiline_comment|/* -ENOENT -- we canceled this transfer */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ENOENT
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;isd200_transfer_partial(): transfer aborted&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ISD200_TRANSPORT_ABORTED
suffix:semicolon
)brace
multiline_comment|/* the catch-all case */
id|US_DEBUGP
c_func
(paren
l_string|&quot;isd200_transfer_partial(): unknown error&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ISD200_TRANSPORT_FAILED
suffix:semicolon
)brace
multiline_comment|/* no error code, so we must have transferred some data, &n;         * just not all of it */
r_return
id|ISD200_TRANSPORT_SHORT
suffix:semicolon
)brace
multiline_comment|/**************************************************************************&n; * Transfer an entire SCSI command&squot;s worth of data payload over the bulk&n; * pipe.&n; *&n; * Note that this uses us_transfer_partial to achieve it&squot;s goals -- this&n; * function simply determines if we&squot;re going to use scatter-gather or not,&n; * and acts appropriately.  For now, it also re-interprets the error codes.&n; */
DECL|function|isd200_transfer
r_static
r_void
id|isd200_transfer
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
id|Scsi_Cmnd
op_star
id|srb
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|result
op_assign
op_minus
l_int|1
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
r_int
r_int
id|total_transferred
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|transfer_amount
suffix:semicolon
multiline_comment|/* calculate how much we want to transfer */
r_int
id|dir
op_assign
id|srb-&gt;sc_data_direction
suffix:semicolon
id|srb-&gt;sc_data_direction
op_assign
id|SCSI_DATA_WRITE
suffix:semicolon
id|transfer_amount
op_assign
id|usb_stor_transfer_length
c_func
(paren
id|srb
)paren
suffix:semicolon
id|srb-&gt;sc_data_direction
op_assign
id|dir
suffix:semicolon
multiline_comment|/* was someone foolish enough to request more data than available&n;         * buffer space? */
r_if
c_cond
(paren
id|transfer_amount
OG
id|srb-&gt;request_bufflen
)paren
id|transfer_amount
op_assign
id|srb-&gt;request_bufflen
suffix:semicolon
multiline_comment|/* are we scatter-gathering? */
r_if
c_cond
(paren
id|srb-&gt;use_sg
)paren
(brace
multiline_comment|/* loop over all the scatter gather structures and &n;                 * make the appropriate requests for each, until done&n;                 */
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|srb-&gt;request_buffer
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|srb-&gt;use_sg
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* transfer the lesser of the next buffer or the&n;                         * remaining data */
r_if
c_cond
(paren
id|transfer_amount
op_minus
id|total_transferred
op_ge
id|sg
(braket
id|i
)braket
dot
id|length
)paren
(brace
id|result
op_assign
id|isd200_transfer_partial
c_func
(paren
id|us
comma
id|srb-&gt;sc_data_direction
comma
id|sg
(braket
id|i
)braket
dot
id|address
comma
id|sg
(braket
id|i
)braket
dot
id|length
)paren
suffix:semicolon
id|total_transferred
op_add_assign
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
)brace
r_else
id|result
op_assign
id|isd200_transfer_partial
c_func
(paren
id|us
comma
id|srb-&gt;sc_data_direction
comma
id|sg
(braket
id|i
)braket
dot
id|address
comma
id|transfer_amount
op_minus
id|total_transferred
)paren
suffix:semicolon
multiline_comment|/* if we get an error, end the loop here */
r_if
c_cond
(paren
id|result
)paren
r_break
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* no scatter-gather, just make the request */
id|result
op_assign
id|isd200_transfer_partial
c_func
(paren
id|us
comma
id|srb-&gt;sc_data_direction
comma
id|srb-&gt;request_buffer
comma
id|transfer_amount
)paren
suffix:semicolon
multiline_comment|/* return the result in the data structure itself */
id|srb-&gt;result
op_assign
id|result
suffix:semicolon
)brace
multiline_comment|/***********************************************************************&n; * Transport routines&n; ***********************************************************************/
multiline_comment|/**************************************************************************&n; *  ISD200 Bulk Transport&n; *&n; * Note:  This routine was copied from the usb_stor_Bulk_transport routine&n; * located in the transport.c source file.  The scsi command is limited to&n; * only 12 bytes while the CDB for the ISD200 must be 16 bytes.&n; */
DECL|function|isd200_Bulk_transport
r_int
id|isd200_Bulk_transport
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
id|Scsi_Cmnd
op_star
id|srb
comma
r_union
id|ata_cdb
op_star
id|AtaCdb
comma
r_int
r_char
id|AtaCdbLength
)paren
(brace
r_struct
id|bulk_cb_wrap
id|bcb
suffix:semicolon
r_struct
id|bulk_cs_wrap
id|bcs
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
id|pipe
suffix:semicolon
r_int
id|partial
suffix:semicolon
r_int
r_int
id|transfer_amount
suffix:semicolon
r_int
id|dir
op_assign
id|srb-&gt;sc_data_direction
suffix:semicolon
id|srb-&gt;sc_data_direction
op_assign
id|SCSI_DATA_WRITE
suffix:semicolon
id|transfer_amount
op_assign
id|usb_stor_transfer_length
c_func
(paren
id|srb
)paren
suffix:semicolon
id|srb-&gt;sc_data_direction
op_assign
id|dir
suffix:semicolon
multiline_comment|/* set up the command wrapper */
id|bcb.Signature
op_assign
id|cpu_to_le32
c_func
(paren
id|US_BULK_CB_SIGN
)paren
suffix:semicolon
id|bcb.DataTransferLength
op_assign
id|cpu_to_le32
c_func
(paren
id|transfer_amount
)paren
suffix:semicolon
id|bcb.Flags
op_assign
id|srb-&gt;sc_data_direction
op_eq
id|SCSI_DATA_READ
ques
c_cond
l_int|1
op_lshift
l_int|7
suffix:colon
l_int|0
suffix:semicolon
id|bcb.Tag
op_assign
id|srb-&gt;serial_number
suffix:semicolon
id|bcb.Lun
op_assign
id|srb-&gt;cmnd
(braket
l_int|1
)braket
op_rshift
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|us-&gt;flags
op_amp
id|US_FL_SCM_MULT_TARG
)paren
id|bcb.Lun
op_or_assign
id|srb-&gt;target
op_lshift
l_int|4
suffix:semicolon
id|bcb.Length
op_assign
id|AtaCdbLength
suffix:semicolon
multiline_comment|/* construct the pipe handle */
id|pipe
op_assign
id|usb_sndbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;ep_out
)paren
suffix:semicolon
multiline_comment|/* copy the command payload */
id|memset
c_func
(paren
id|bcb.CDB
comma
l_int|0
comma
r_sizeof
(paren
id|bcb.CDB
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|bcb.CDB
comma
id|AtaCdb
comma
id|bcb.Length
)paren
suffix:semicolon
multiline_comment|/* send it to out endpoint */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bulk command S 0x%x T 0x%x Trg %d LUN %d L %d F %d CL %d&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|bcb.Signature
)paren
comma
id|bcb.Tag
comma
(paren
id|bcb.Lun
op_rshift
l_int|4
)paren
comma
(paren
id|bcb.Lun
op_amp
l_int|0xFF
)paren
comma
id|bcb.DataTransferLength
comma
id|bcb.Flags
comma
id|bcb.Length
)paren
suffix:semicolon
id|result
op_assign
id|usb_stor_bulk_msg
c_func
(paren
id|us
comma
op_amp
id|bcb
comma
id|pipe
comma
id|US_BULK_CB_WRAP_LEN
comma
op_amp
id|partial
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bulk command transfer result=%d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ENOENT
)paren
r_return
id|ISD200_TRANSPORT_ABORTED
suffix:semicolon
r_else
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
multiline_comment|/* if we stall, we need to clear it before we go on */
id|US_DEBUGP
c_func
(paren
l_string|&quot;clearing endpoint halt for pipe 0x%x&bslash;n&quot;
comma
id|pipe
)paren
suffix:semicolon
id|usb_stor_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|pipe
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|result
)paren
r_return
id|ISD200_TRANSPORT_ERROR
suffix:semicolon
multiline_comment|/* if the command transfered well, then we go to the data stage */
r_if
c_cond
(paren
op_logical_neg
id|result
op_logical_and
id|bcb.DataTransferLength
)paren
(brace
id|isd200_transfer
c_func
(paren
id|us
comma
id|srb
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bulk data transfer result 0x%x&bslash;n&quot;
comma
id|srb-&gt;result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|srb-&gt;result
op_eq
id|ISD200_TRANSPORT_ABORTED
)paren
r_return
id|ISD200_TRANSPORT_ABORTED
suffix:semicolon
)brace
multiline_comment|/* See flow chart on pg 15 of the Bulk Only Transport spec for&n;         * an explanation of how this code works.&n;         */
multiline_comment|/* construct the pipe handle */
id|pipe
op_assign
id|usb_rcvbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|us-&gt;ep_in
)paren
suffix:semicolon
multiline_comment|/* get CSW for device status */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Attempting to get CSW...&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|usb_stor_bulk_msg
c_func
(paren
id|us
comma
op_amp
id|bcs
comma
id|pipe
comma
id|US_BULK_CS_WRAP_LEN
comma
op_amp
id|partial
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ENOENT
)paren
r_return
id|ISD200_TRANSPORT_ABORTED
suffix:semicolon
multiline_comment|/* did the attempt to read the CSW fail? */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;clearing endpoint halt for pipe 0x%x&bslash;n&quot;
comma
id|pipe
)paren
suffix:semicolon
id|usb_stor_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|pipe
)paren
suffix:semicolon
multiline_comment|/* get the status again */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Attempting to get CSW (2nd try)...&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|usb_stor_bulk_msg
c_func
(paren
id|us
comma
op_amp
id|bcs
comma
id|pipe
comma
id|US_BULK_CS_WRAP_LEN
comma
op_amp
id|partial
)paren
suffix:semicolon
multiline_comment|/* if the command was aborted, indicate that */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ENOENT
)paren
r_return
id|ISD200_TRANSPORT_ABORTED
suffix:semicolon
multiline_comment|/* if it fails again, we need a reset and return an error*/
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;clearing halt for pipe 0x%x&bslash;n&quot;
comma
id|pipe
)paren
suffix:semicolon
id|usb_stor_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|pipe
)paren
suffix:semicolon
r_return
id|ISD200_TRANSPORT_ERROR
suffix:semicolon
)brace
)brace
multiline_comment|/* if we still have a failure at this point, we&squot;re in trouble */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bulk status result = %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_return
id|ISD200_TRANSPORT_ERROR
suffix:semicolon
multiline_comment|/* check bulk status */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bulk status Sig 0x%x T 0x%x R %d Stat 0x%x&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|bcs.Signature
)paren
comma
id|bcs.Tag
comma
id|bcs.Residue
comma
id|bcs.Status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bcs.Signature
op_ne
id|cpu_to_le32
c_func
(paren
id|US_BULK_CS_SIGN
)paren
op_logical_or
id|bcs.Tag
op_ne
id|bcb.Tag
op_logical_or
id|bcs.Status
OG
id|US_BULK_STAT_PHASE
op_logical_or
id|partial
op_ne
l_int|13
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bulk logical error&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ISD200_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/* based on the status code, we report good or bad */
r_switch
c_cond
(paren
id|bcs.Status
)paren
(brace
r_case
id|US_BULK_STAT_OK
suffix:colon
multiline_comment|/* command good -- note that we could be short on data */
r_return
id|ISD200_TRANSPORT_GOOD
suffix:semicolon
r_case
id|US_BULK_STAT_FAIL
suffix:colon
multiline_comment|/* command failed */
r_return
id|ISD200_TRANSPORT_FAILED
suffix:semicolon
r_case
id|US_BULK_STAT_PHASE
suffix:colon
multiline_comment|/* phase error */
id|usb_stor_Bulk_reset
c_func
(paren
id|us
)paren
suffix:semicolon
r_return
id|ISD200_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/* we should never get here, but if we do, we&squot;re in trouble */
r_return
id|ISD200_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/**************************************************************************&n; *  isd200_action&n; *&n; * Routine for sending commands to the isd200&n; *&n; * RETURNS:&n; *    ISD status code&n; */
DECL|function|isd200_action
r_static
r_int
id|isd200_action
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
id|action
comma
r_void
op_star
id|pointer
comma
r_int
id|value
)paren
(brace
r_union
id|ata_cdb
id|ata
suffix:semicolon
r_struct
id|scsi_cmnd
id|srb
suffix:semicolon
r_struct
id|isd200_info
op_star
id|info
op_assign
(paren
r_struct
id|isd200_info
op_star
)paren
id|us-&gt;extra
suffix:semicolon
r_int
id|status
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|ata
comma
l_int|0
comma
r_sizeof
(paren
id|ata
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|srb
comma
l_int|0
comma
r_sizeof
(paren
id|srb
)paren
)paren
suffix:semicolon
id|ata.generic.SignatureByte0
op_assign
id|info-&gt;ConfigData.ATAMajorCommand
suffix:semicolon
id|ata.generic.SignatureByte1
op_assign
id|info-&gt;ConfigData.ATAMinorCommand
suffix:semicolon
id|ata.generic.TransferBlockSize
op_assign
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|action
)paren
(brace
r_case
id|ACTION_READ_STATUS
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;   isd200_action(READ_STATUS)&bslash;n&quot;
)paren
suffix:semicolon
id|ata.generic.ActionSelect
op_assign
id|ACTION_SELECT_0
op_or
id|ACTION_SELECT_2
suffix:semicolon
id|ata.read.SelectStatus
op_assign
l_int|1
suffix:semicolon
id|ata.read.SelectError
op_assign
l_int|1
suffix:semicolon
id|ata.read.SelectCylinderHigh
op_assign
l_int|1
suffix:semicolon
id|ata.read.SelectCylinderLow
op_assign
l_int|1
suffix:semicolon
id|srb.sc_data_direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
id|srb.request_buffer
op_assign
id|pointer
suffix:semicolon
id|srb.request_bufflen
op_assign
id|value
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACTION_ENUM
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;   isd200_action(ENUM,0x%02x)&bslash;n&quot;
comma
id|value
)paren
suffix:semicolon
id|ata.generic.ActionSelect
op_assign
id|ACTION_SELECT_1
op_or
id|ACTION_SELECT_2
op_or
id|ACTION_SELECT_3
op_or
id|ACTION_SELECT_4
op_or
id|ACTION_SELECT_5
suffix:semicolon
id|ata.write.SelectDeviceHead
op_assign
l_int|1
suffix:semicolon
id|ata.write.DeviceHeadByte
op_assign
id|value
suffix:semicolon
id|srb.sc_data_direction
op_assign
id|SCSI_DATA_NONE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACTION_RESET
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;   isd200_action(RESET)&bslash;n&quot;
)paren
suffix:semicolon
id|ata.generic.ActionSelect
op_assign
id|ACTION_SELECT_1
op_or
id|ACTION_SELECT_2
op_or
id|ACTION_SELECT_3
op_or
id|ACTION_SELECT_4
suffix:semicolon
id|ata.write.SelectDeviceControl
op_assign
l_int|1
suffix:semicolon
id|ata.write.DeviceControlByte
op_assign
id|ATA_DC_RESET_CONTROLLER
suffix:semicolon
id|srb.sc_data_direction
op_assign
id|SCSI_DATA_NONE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACTION_REENABLE
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;   isd200_action(REENABLE)&bslash;n&quot;
)paren
suffix:semicolon
id|ata.generic.ActionSelect
op_assign
id|ACTION_SELECT_1
op_or
id|ACTION_SELECT_2
op_or
id|ACTION_SELECT_3
op_or
id|ACTION_SELECT_4
suffix:semicolon
id|ata.write.SelectDeviceControl
op_assign
l_int|1
suffix:semicolon
id|ata.write.DeviceControlByte
op_assign
id|ATA_DC_REENABLE_CONTROLLER
suffix:semicolon
id|srb.sc_data_direction
op_assign
id|SCSI_DATA_NONE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACTION_SOFT_RESET
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;   isd200_action(SOFT_RESET)&bslash;n&quot;
)paren
suffix:semicolon
id|ata.generic.ActionSelect
op_assign
id|ACTION_SELECT_1
op_or
id|ACTION_SELECT_5
suffix:semicolon
id|ata.write.SelectDeviceHead
op_assign
l_int|1
suffix:semicolon
id|ata.write.DeviceHeadByte
op_assign
id|info-&gt;DeviceHead
suffix:semicolon
id|ata.write.SelectCommand
op_assign
l_int|1
suffix:semicolon
id|ata.write.CommandByte
op_assign
id|WIN_SRST
suffix:semicolon
id|srb.sc_data_direction
op_assign
id|SCSI_DATA_NONE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACTION_IDENTIFY
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;   isd200_action(IDENTIFY)&bslash;n&quot;
)paren
suffix:semicolon
id|ata.write.SelectCommand
op_assign
l_int|1
suffix:semicolon
id|ata.write.CommandByte
op_assign
id|WIN_IDENTIFY
suffix:semicolon
id|srb.sc_data_direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
id|srb.request_buffer
op_assign
(paren
r_void
op_star
)paren
op_amp
id|info-&gt;drive
suffix:semicolon
id|srb.request_bufflen
op_assign
r_sizeof
(paren
r_struct
id|hd_driveid
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Error: Undefined action %d&bslash;n&quot;
comma
id|action
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|status
op_assign
id|isd200_Bulk_transport
c_func
(paren
id|us
comma
op_amp
id|srb
comma
op_amp
id|ata
comma
r_sizeof
(paren
id|ata.generic
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
id|ISD200_TRANSPORT_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;   isd200_action(0x%02x) error: %d&bslash;n&quot;
comma
id|action
comma
id|status
)paren
suffix:semicolon
id|status
op_assign
id|ISD200_ERROR
suffix:semicolon
multiline_comment|/* need to reset device here */
)brace
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/**************************************************************************&n; * isd200_read_regs&n; *                                                                         &n; * Read ATA Registers&n; *&n; * RETURNS:&n; *    ISD status code&n; */
DECL|function|isd200_read_regs
r_int
id|isd200_read_regs
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_struct
id|isd200_info
op_star
id|info
op_assign
(paren
r_struct
id|isd200_info
op_star
)paren
id|us-&gt;extra
suffix:semicolon
r_int
id|retStatus
op_assign
id|ISD200_GOOD
suffix:semicolon
r_int
id|transferStatus
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Entering isd200_IssueATAReadRegs&bslash;n&quot;
)paren
suffix:semicolon
id|transferStatus
op_assign
id|isd200_action
c_func
(paren
id|us
comma
id|ACTION_READ_STATUS
comma
id|info-&gt;ATARegs
comma
r_sizeof
(paren
id|info-&gt;ATARegs
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|transferStatus
op_ne
id|ISD200_TRANSPORT_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;   Error reading ATA registers&bslash;n&quot;
)paren
suffix:semicolon
id|retStatus
op_assign
id|ISD200_ERROR
suffix:semicolon
)brace
r_else
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;   Got ATA Register[IDE_ERROR_OFFSET] = 0x%x&bslash;n&quot;
comma
id|info-&gt;ATARegs
(braket
id|IDE_ERROR_OFFSET
)braket
)paren
suffix:semicolon
)brace
r_return
id|retStatus
suffix:semicolon
)brace
multiline_comment|/**************************************************************************&n; * Invoke the transport and basic error-handling/recovery methods&n; *&n; * This is used by the protocol layers to actually send the message to&n; * the device and recieve the response.&n; */
DECL|function|isd200_invoke_transport
r_void
id|isd200_invoke_transport
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
id|Scsi_Cmnd
op_star
id|srb
comma
r_union
id|ata_cdb
op_star
id|ataCdb
)paren
(brace
r_int
id|need_auto_sense
op_assign
l_int|0
suffix:semicolon
r_int
id|transferStatus
suffix:semicolon
multiline_comment|/* send the command to the transport layer */
id|transferStatus
op_assign
id|isd200_Bulk_transport
c_func
(paren
id|us
comma
id|srb
comma
id|ataCdb
comma
r_sizeof
(paren
id|ataCdb-&gt;generic
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|transferStatus
)paren
(brace
r_case
id|ISD200_TRANSPORT_GOOD
suffix:colon
multiline_comment|/* Indicate a good result */
id|srb-&gt;result
op_assign
id|GOOD
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ISD200_TRANSPORT_ABORTED
suffix:colon
multiline_comment|/* if the command gets aborted by the higher layers, we need to&n;&t;&t; * short-circuit all other processing&n;&t;&t; */
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- transport indicates command was aborted&bslash;n&quot;
)paren
suffix:semicolon
id|srb-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ISD200_TRANSPORT_FAILED
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- transport indicates command failure&bslash;n&quot;
)paren
suffix:semicolon
id|need_auto_sense
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ISD200_TRANSPORT_ERROR
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- transport indicates transport failure&bslash;n&quot;
)paren
suffix:semicolon
id|srb-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ISD200_TRANSPORT_SHORT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
op_logical_or
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
op_logical_or
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|MODE_SENSE
)paren
op_logical_or
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|LOG_SENSE
)paren
op_logical_or
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|MODE_SENSE_10
)paren
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- unexpectedly short transfer&bslash;n&quot;
)paren
suffix:semicolon
id|need_auto_sense
op_assign
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- transport indicates unknown failure&bslash;n&quot;
)paren
suffix:semicolon
id|srb-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
)brace
r_if
c_cond
(paren
id|need_auto_sense
)paren
r_if
c_cond
(paren
id|isd200_read_regs
c_func
(paren
id|us
)paren
op_eq
id|ISD200_GOOD
)paren
id|isd200_build_sense
c_func
(paren
id|us
comma
id|srb
)paren
suffix:semicolon
multiline_comment|/* Regardless of auto-sense, if we _know_ we have an error&n;&t; * condition, show that in the result code&n;&t; */
r_if
c_cond
(paren
id|transferStatus
op_eq
id|ISD200_TRANSPORT_FAILED
)paren
id|srb-&gt;result
op_assign
id|CHECK_CONDITION
suffix:semicolon
)brace
multiline_comment|/**************************************************************************&n; * isd200_write_config&n; *                                                                         &n; * Write the ISD200 Configuraton data&n; *&n; * RETURNS:&n; *    ISD status code&n; */
DECL|function|isd200_write_config
r_int
id|isd200_write_config
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_struct
id|isd200_info
op_star
id|info
op_assign
(paren
r_struct
id|isd200_info
op_star
)paren
id|us-&gt;extra
suffix:semicolon
r_int
id|retStatus
op_assign
id|ISD200_GOOD
suffix:semicolon
r_int
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Entering isd200_write_config&bslash;n&quot;
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;   Writing the following ISD200 Config Data:&bslash;n&quot;
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      Event Notification: 0x%x&bslash;n&quot;
comma
id|info-&gt;ConfigData.EventNotification
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      External Clock: 0x%x&bslash;n&quot;
comma
id|info-&gt;ConfigData.ExternalClock
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      ATA Init Timeout: 0x%x&bslash;n&quot;
comma
id|info-&gt;ConfigData.ATAInitTimeout
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      ATAPI Command Block Size: 0x%x&bslash;n&quot;
comma
id|info-&gt;ConfigData.ATAPICommandBlockSize
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      Master/Slave Selection: 0x%x&bslash;n&quot;
comma
id|info-&gt;ConfigData.MasterSlaveSelection
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      ATAPI Reset: 0x%x&bslash;n&quot;
comma
id|info-&gt;ConfigData.ATAPIReset
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      ATA Timing: 0x%x&bslash;n&quot;
comma
id|info-&gt;ConfigData.ATATiming
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      ATA Major Command: 0x%x&bslash;n&quot;
comma
id|info-&gt;ConfigData.ATAMajorCommand
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      ATA Minor Command: 0x%x&bslash;n&quot;
comma
id|info-&gt;ConfigData.ATAMinorCommand
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      Init Status: 0x%x&bslash;n&quot;
comma
id|info-&gt;ConfigData.InitStatus
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      Config Descriptor 2: 0x%x&bslash;n&quot;
comma
id|info-&gt;ConfigData.ConfigDescriptor2
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      Skip Device Boot: 0x%x&bslash;n&quot;
comma
id|info-&gt;ConfigData.SkipDeviceBoot
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      ATA 3 State Supsend: 0x%x&bslash;n&quot;
comma
id|info-&gt;ConfigData.ATA3StateSuspend
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      Descriptor Override: 0x%x&bslash;n&quot;
comma
id|info-&gt;ConfigData.DescriptOverride
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      Last LUN Identifier: 0x%x&bslash;n&quot;
comma
id|info-&gt;ConfigData.LastLUNIdentifier
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      SRST Enable: 0x%x&bslash;n&quot;
comma
id|info-&gt;ConfigData.SRSTEnable
)paren
suffix:semicolon
multiline_comment|/* let&squot;s send the command via the control pipe */
id|result
op_assign
id|usb_stor_control_msg
c_func
(paren
id|us
comma
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
comma
l_int|0x01
comma
id|USB_TYPE_VENDOR
op_or
id|USB_RECIP_DEVICE
op_or
id|USB_DIR_OUT
comma
l_int|0x0000
comma
l_int|0x0002
comma
(paren
r_void
op_star
)paren
op_amp
id|info-&gt;ConfigData
comma
r_sizeof
(paren
id|info-&gt;ConfigData
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ge
l_int|0
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;   ISD200 Config Data was written successfully&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;   Request to write ISD200 Config Data failed!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* STALL must be cleared when they are detected */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- Stall on control pipe. Clearing&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|usb_stor_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- usb_stor_clear_halt() returns %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
)brace
id|retStatus
op_assign
id|ISD200_ERROR
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Leaving isd200_write_config %08X&bslash;n&quot;
comma
id|retStatus
)paren
suffix:semicolon
r_return
id|retStatus
suffix:semicolon
)brace
multiline_comment|/**************************************************************************&n; * isd200_read_config&n; *                                                                         &n; * Reads the ISD200 Configuraton data&n; *&n; * RETURNS:&n; *    ISD status code&n; */
DECL|function|isd200_read_config
r_int
id|isd200_read_config
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_struct
id|isd200_info
op_star
id|info
op_assign
(paren
r_struct
id|isd200_info
op_star
)paren
id|us-&gt;extra
suffix:semicolon
r_int
id|retStatus
op_assign
id|ISD200_GOOD
suffix:semicolon
r_int
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Entering isd200_read_config&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* read the configuration information from ISD200.  Use this to */
multiline_comment|/* determine what the special ATA CDB bytes are.                */
id|result
op_assign
id|usb_stor_control_msg
c_func
(paren
id|us
comma
id|usb_rcvctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
comma
l_int|0x02
comma
id|USB_TYPE_VENDOR
op_or
id|USB_RECIP_DEVICE
op_or
id|USB_DIR_IN
comma
l_int|0x0000
comma
l_int|0x0002
comma
(paren
r_void
op_star
)paren
op_amp
id|info-&gt;ConfigData
comma
r_sizeof
(paren
id|info-&gt;ConfigData
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ge
l_int|0
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;   Retrieved the following ISD200 Config Data:&bslash;n&quot;
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      Event Notification: 0x%x&bslash;n&quot;
comma
id|info-&gt;ConfigData.EventNotification
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      External Clock: 0x%x&bslash;n&quot;
comma
id|info-&gt;ConfigData.ExternalClock
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      ATA Init Timeout: 0x%x&bslash;n&quot;
comma
id|info-&gt;ConfigData.ATAInitTimeout
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      ATAPI Command Block Size: 0x%x&bslash;n&quot;
comma
id|info-&gt;ConfigData.ATAPICommandBlockSize
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      Master/Slave Selection: 0x%x&bslash;n&quot;
comma
id|info-&gt;ConfigData.MasterSlaveSelection
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      ATAPI Reset: 0x%x&bslash;n&quot;
comma
id|info-&gt;ConfigData.ATAPIReset
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      ATA Timing: 0x%x&bslash;n&quot;
comma
id|info-&gt;ConfigData.ATATiming
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      ATA Major Command: 0x%x&bslash;n&quot;
comma
id|info-&gt;ConfigData.ATAMajorCommand
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      ATA Minor Command: 0x%x&bslash;n&quot;
comma
id|info-&gt;ConfigData.ATAMinorCommand
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      Init Status: 0x%x&bslash;n&quot;
comma
id|info-&gt;ConfigData.InitStatus
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      Config Descriptor 2: 0x%x&bslash;n&quot;
comma
id|info-&gt;ConfigData.ConfigDescriptor2
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      Skip Device Boot: 0x%x&bslash;n&quot;
comma
id|info-&gt;ConfigData.SkipDeviceBoot
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      ATA 3 State Supsend: 0x%x&bslash;n&quot;
comma
id|info-&gt;ConfigData.ATA3StateSuspend
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      Descriptor Override: 0x%x&bslash;n&quot;
comma
id|info-&gt;ConfigData.DescriptOverride
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      Last LUN Identifier: 0x%x&bslash;n&quot;
comma
id|info-&gt;ConfigData.LastLUNIdentifier
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      SRST Enable: 0x%x&bslash;n&quot;
comma
id|info-&gt;ConfigData.SRSTEnable
)paren
suffix:semicolon
)brace
r_else
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;   Request to get ISD200 Config Data failed!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* STALL must be cleared when they are detected */
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- Stall on control pipe. Clearing&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|usb_stor_clear_halt
c_func
(paren
id|us-&gt;pusb_dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- usb_stor_clear_halt() returns %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
)brace
id|retStatus
op_assign
id|ISD200_ERROR
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Leaving isd200_read_config %08X&bslash;n&quot;
comma
id|retStatus
)paren
suffix:semicolon
r_return
id|retStatus
suffix:semicolon
)brace
multiline_comment|/**************************************************************************&n; * isd200_atapi_soft_reset&n; *                                                                         &n; * Perform an Atapi Soft Reset on the device&n; *&n; * RETURNS:&n; *    NT status code&n; */
DECL|function|isd200_atapi_soft_reset
r_int
id|isd200_atapi_soft_reset
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|retStatus
op_assign
id|ISD200_GOOD
suffix:semicolon
r_int
id|transferStatus
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Entering isd200_atapi_soft_reset&bslash;n&quot;
)paren
suffix:semicolon
id|transferStatus
op_assign
id|isd200_action
c_func
(paren
id|us
comma
id|ACTION_SOFT_RESET
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|transferStatus
op_ne
id|ISD200_TRANSPORT_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;   Error issuing Atapi Soft Reset&bslash;n&quot;
)paren
suffix:semicolon
id|retStatus
op_assign
id|ISD200_ERROR
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Leaving isd200_atapi_soft_reset %08X&bslash;n&quot;
comma
id|retStatus
)paren
suffix:semicolon
r_return
id|retStatus
suffix:semicolon
)brace
multiline_comment|/**************************************************************************&n; * isd200_srst&n; *                                                                         &n; * Perform an SRST on the device&n; *&n; * RETURNS:&n; *    ISD status code&n; */
DECL|function|isd200_srst
r_int
id|isd200_srst
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|retStatus
op_assign
id|ISD200_GOOD
suffix:semicolon
r_int
id|transferStatus
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Entering isd200_SRST&bslash;n&quot;
)paren
suffix:semicolon
id|transferStatus
op_assign
id|isd200_action
c_func
(paren
id|us
comma
id|ACTION_RESET
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* check to see if this request failed */
r_if
c_cond
(paren
id|transferStatus
op_ne
id|ISD200_TRANSPORT_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;   Error issuing SRST&bslash;n&quot;
)paren
suffix:semicolon
id|retStatus
op_assign
id|ISD200_ERROR
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* delay 10ms to give the drive a chance to see it */
id|wait_ms
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|transferStatus
op_assign
id|isd200_action
c_func
(paren
id|us
comma
id|ACTION_REENABLE
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|transferStatus
op_ne
id|ISD200_TRANSPORT_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;   Error taking drive out of reset&bslash;n&quot;
)paren
suffix:semicolon
id|retStatus
op_assign
id|ISD200_ERROR
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* delay 50ms to give the drive a chance to recover after SRST */
id|wait_ms
c_func
(paren
l_int|50
)paren
suffix:semicolon
)brace
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Leaving isd200_srst %08X&bslash;n&quot;
comma
id|retStatus
)paren
suffix:semicolon
r_return
id|retStatus
suffix:semicolon
)brace
multiline_comment|/**************************************************************************&n; * isd200_try_enum&n; *                                                                         &n; * Helper function for isd200_manual_enum(). Does ENUM and READ_STATUS&n; * and tries to analyze the status registers&n; *&n; * RETURNS:&n; *    ISD status code&n; */
DECL|function|isd200_try_enum
r_static
r_int
id|isd200_try_enum
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
id|master_slave
comma
r_int
id|detect
)paren
(brace
r_int
id|status
op_assign
id|ISD200_GOOD
suffix:semicolon
r_int
r_char
id|regs
(braket
l_int|8
)braket
suffix:semicolon
r_int
r_int
id|endTime
suffix:semicolon
r_struct
id|isd200_info
op_star
id|info
op_assign
(paren
r_struct
id|isd200_info
op_star
)paren
id|us-&gt;extra
suffix:semicolon
r_int
id|recheckAsMaster
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|detect
)paren
id|endTime
op_assign
id|jiffies
op_plus
id|ISD200_ENUM_DETECT_TIMEOUT
op_star
id|HZ
suffix:semicolon
r_else
id|endTime
op_assign
id|jiffies
op_plus
id|ISD200_ENUM_BSY_TIMEOUT
op_star
id|HZ
suffix:semicolon
multiline_comment|/* loop until we detect !BSY or timeout */
r_while
c_loop
(paren
id|TRUE
)paren
(brace
macro_line|#ifdef CONFIG_USB_STORAGE_DEBUG
r_char
op_star
id|mstr
op_assign
id|master_slave
op_eq
id|ATA_ADDRESS_DEVHEAD_STD
ques
c_cond
l_string|&quot;Master&quot;
suffix:colon
l_string|&quot;Slave&quot;
suffix:semicolon
macro_line|#endif
id|status
op_assign
id|isd200_action
c_func
(paren
id|us
comma
id|ACTION_ENUM
comma
l_int|NULL
comma
id|master_slave
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
id|ISD200_GOOD
)paren
r_break
suffix:semicolon
id|status
op_assign
id|isd200_action
c_func
(paren
id|us
comma
id|ACTION_READ_STATUS
comma
id|regs
comma
r_sizeof
(paren
id|regs
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
id|ISD200_GOOD
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|detect
)paren
(brace
r_if
c_cond
(paren
id|regs
(braket
id|IDE_STATUS_OFFSET
)braket
op_amp
id|BUSY_STAT
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;   %s status is still BSY, try again...&bslash;n&quot;
comma
id|mstr
)paren
suffix:semicolon
)brace
r_else
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;   %s status !BSY, continue with next operation&bslash;n&quot;
comma
id|mstr
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* check for BUSY_STAT and */
multiline_comment|/* WRERR_STAT (workaround ATA Zip drive) and */
multiline_comment|/* ERR_STAT (workaround for Archos CD-ROM) */
r_else
r_if
c_cond
(paren
id|regs
(braket
id|IDE_STATUS_OFFSET
)braket
op_amp
(paren
id|BUSY_STAT
op_or
id|WRERR_STAT
op_or
id|ERR_STAT
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;   Status indicates it is not ready, try again...&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* check for DRDY, ATA devices set DRDY after SRST */
r_else
r_if
c_cond
(paren
id|regs
(braket
id|IDE_STATUS_OFFSET
)braket
op_amp
id|READY_STAT
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;   Identified ATA device&bslash;n&quot;
)paren
suffix:semicolon
id|info-&gt;DeviceFlags
op_or_assign
id|DF_ATA_DEVICE
suffix:semicolon
id|info-&gt;DeviceHead
op_assign
id|master_slave
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* check Cylinder High/Low to&n;&t;&t;   determine if it is an ATAPI device&n;&t;&t;*/
r_else
r_if
c_cond
(paren
(paren
id|regs
(braket
id|IDE_HCYL_OFFSET
)braket
op_eq
l_int|0xEB
)paren
op_logical_and
(paren
id|regs
(braket
id|IDE_LCYL_OFFSET
)braket
op_eq
l_int|0x14
)paren
)paren
(brace
multiline_comment|/* It seems that the RICOH &n;&t;&t;&t;   MP6200A CD/RW drive will &n;&t;&t;&t;   report itself okay as a&n;&t;&t;&t;   slave when it is really a&n;&t;&t;&t;   master. So this check again&n;&t;&t;&t;   as a master device just to&n;&t;&t;&t;   make sure it doesn&squot;t report&n;&t;&t;&t;   itself okay as a master also&n;&t;&t;&t;*/
r_if
c_cond
(paren
(paren
id|master_slave
op_amp
id|ATA_ADDRESS_DEVHEAD_SLAVE
)paren
op_logical_and
(paren
id|recheckAsMaster
op_eq
id|FALSE
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;   Identified ATAPI device as slave.  Rechecking again as master&bslash;n&quot;
)paren
suffix:semicolon
id|recheckAsMaster
op_assign
id|TRUE
suffix:semicolon
id|master_slave
op_assign
id|ATA_ADDRESS_DEVHEAD_STD
suffix:semicolon
)brace
r_else
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;   Identified ATAPI device&bslash;n&quot;
)paren
suffix:semicolon
id|info-&gt;DeviceHead
op_assign
id|master_slave
suffix:semicolon
id|status
op_assign
id|isd200_atapi_soft_reset
c_func
(paren
id|us
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;   Not ATA, not ATAPI. Weird.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* check for timeout on this request */
r_if
c_cond
(paren
id|jiffies
op_ge
id|endTime
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|detect
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;   BSY check timeout, just continue with next operation...&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|US_DEBUGP
c_func
(paren
l_string|&quot;   Device detect timeout!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/**************************************************************************&n; * isd200_manual_enum&n; *                                                                         &n; * Determines if the drive attached is an ATA or ATAPI and if it is a&n; * master or slave.&n; *&n; * RETURNS:&n; *    ISD status code&n; */
DECL|function|isd200_manual_enum
r_int
id|isd200_manual_enum
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_struct
id|isd200_info
op_star
id|info
op_assign
(paren
r_struct
id|isd200_info
op_star
)paren
id|us-&gt;extra
suffix:semicolon
r_int
id|retStatus
op_assign
id|ISD200_GOOD
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Entering isd200_manual_enum&bslash;n&quot;
)paren
suffix:semicolon
id|retStatus
op_assign
id|isd200_read_config
c_func
(paren
id|us
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retStatus
op_eq
id|ISD200_GOOD
)paren
(brace
r_int
id|isslave
suffix:semicolon
multiline_comment|/* master or slave? */
id|retStatus
op_assign
id|isd200_try_enum
c_func
(paren
id|us
comma
id|ATA_ADDRESS_DEVHEAD_STD
comma
id|FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retStatus
op_eq
id|ISD200_GOOD
)paren
id|retStatus
op_assign
id|isd200_try_enum
c_func
(paren
id|us
comma
id|ATA_ADDRESS_DEVHEAD_SLAVE
comma
id|FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retStatus
op_eq
id|ISD200_GOOD
)paren
(brace
id|retStatus
op_assign
id|isd200_srst
c_func
(paren
id|us
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retStatus
op_eq
id|ISD200_GOOD
)paren
multiline_comment|/* ata or atapi? */
id|retStatus
op_assign
id|isd200_try_enum
c_func
(paren
id|us
comma
id|ATA_ADDRESS_DEVHEAD_STD
comma
id|TRUE
)paren
suffix:semicolon
)brace
id|isslave
op_assign
(paren
id|info-&gt;DeviceHead
op_amp
id|ATA_ADDRESS_DEVHEAD_SLAVE
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;ConfigData.MasterSlaveSelection
op_ne
id|isslave
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;   Setting Master/Slave selection to %d&bslash;n&quot;
comma
id|isslave
)paren
suffix:semicolon
id|info-&gt;ConfigData.MasterSlaveSelection
op_assign
id|isslave
suffix:semicolon
id|retStatus
op_assign
id|isd200_write_config
c_func
(paren
id|us
)paren
suffix:semicolon
)brace
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Leaving isd200_manual_enum %08X&bslash;n&quot;
comma
id|retStatus
)paren
suffix:semicolon
r_return
id|retStatus
suffix:semicolon
)brace
multiline_comment|/**************************************************************************&n; * isd200_get_inquiry_data&n; *&n; * Get inquiry data&n; *&n; * RETURNS:&n; *    ISD status code&n; */
DECL|function|isd200_get_inquiry_data
r_int
id|isd200_get_inquiry_data
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_struct
id|isd200_info
op_star
id|info
op_assign
(paren
r_struct
id|isd200_info
op_star
)paren
id|us-&gt;extra
suffix:semicolon
r_int
id|retStatus
op_assign
id|ISD200_GOOD
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Entering isd200_get_inquiry_data&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* set default to Master */
id|info-&gt;DeviceHead
op_assign
id|ATA_ADDRESS_DEVHEAD_STD
suffix:semicolon
multiline_comment|/* attempt to manually enumerate this device */
id|retStatus
op_assign
id|isd200_manual_enum
c_func
(paren
id|us
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retStatus
op_eq
id|ISD200_GOOD
)paren
(brace
r_int
id|transferStatus
suffix:semicolon
multiline_comment|/* check for an ATA device */
r_if
c_cond
(paren
id|info-&gt;DeviceFlags
op_amp
id|DF_ATA_DEVICE
)paren
(brace
multiline_comment|/* this must be an ATA device */
multiline_comment|/* perform an ATA Commmand Identify */
id|transferStatus
op_assign
id|isd200_action
c_func
(paren
id|us
comma
id|ACTION_IDENTIFY
comma
op_amp
id|info-&gt;drive
comma
r_sizeof
(paren
r_struct
id|hd_driveid
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|transferStatus
op_ne
id|ISD200_TRANSPORT_GOOD
)paren
(brace
multiline_comment|/* Error issuing ATA Command Identify */
id|US_DEBUGP
c_func
(paren
l_string|&quot;   Error issuing ATA Command Identify&bslash;n&quot;
)paren
suffix:semicolon
id|retStatus
op_assign
id|ISD200_ERROR
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* ATA Command Identify successful */
r_int
id|i
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;   Identify Data Structure:&bslash;n&quot;
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      config = 0x%x&bslash;n&quot;
comma
id|info-&gt;drive.config
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      cyls = 0x%x&bslash;n&quot;
comma
id|info-&gt;drive.cyls
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      heads = 0x%x&bslash;n&quot;
comma
id|info-&gt;drive.heads
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      track_bytes = 0x%x&bslash;n&quot;
comma
id|info-&gt;drive.track_bytes
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      sector_bytes = 0x%x&bslash;n&quot;
comma
id|info-&gt;drive.sector_bytes
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      sectors = 0x%x&bslash;n&quot;
comma
id|info-&gt;drive.sectors
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      serial_no[0] = 0x%x&bslash;n&quot;
comma
id|info-&gt;drive.serial_no
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      buf_type = 0x%x&bslash;n&quot;
comma
id|info-&gt;drive.buf_type
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      buf_size = 0x%x&bslash;n&quot;
comma
id|info-&gt;drive.buf_size
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      ecc_bytes = 0x%x&bslash;n&quot;
comma
id|info-&gt;drive.ecc_bytes
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      fw_rev[0] = 0x%x&bslash;n&quot;
comma
id|info-&gt;drive.fw_rev
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      model[0] = 0x%x&bslash;n&quot;
comma
id|info-&gt;drive.model
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      max_multsect = 0x%x&bslash;n&quot;
comma
id|info-&gt;drive.max_multsect
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      dword_io = 0x%x&bslash;n&quot;
comma
id|info-&gt;drive.dword_io
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      capability = 0x%x&bslash;n&quot;
comma
id|info-&gt;drive.capability
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      tPIO = 0x%x&bslash;n&quot;
comma
id|info-&gt;drive.tPIO
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      tDMA = 0x%x&bslash;n&quot;
comma
id|info-&gt;drive.tDMA
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      field_valid = 0x%x&bslash;n&quot;
comma
id|info-&gt;drive.field_valid
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      cur_cyls = 0x%x&bslash;n&quot;
comma
id|info-&gt;drive.cur_cyls
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      cur_heads = 0x%x&bslash;n&quot;
comma
id|info-&gt;drive.cur_heads
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      cur_sectors = 0x%x&bslash;n&quot;
comma
id|info-&gt;drive.cur_sectors
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      cur_capacity = 0x%x&bslash;n&quot;
comma
(paren
id|info-&gt;drive.cur_capacity1
op_lshift
l_int|16
)paren
op_plus
id|info-&gt;drive.cur_capacity0
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      multsect = 0x%x&bslash;n&quot;
comma
id|info-&gt;drive.multsect
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      lba_capacity = 0x%x&bslash;n&quot;
comma
id|info-&gt;drive.lba_capacity
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      command_set_1 = 0x%x&bslash;n&quot;
comma
id|info-&gt;drive.command_set_1
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;      command_set_2 = 0x%x&bslash;n&quot;
comma
id|info-&gt;drive.command_set_2
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|info-&gt;InquiryData
comma
l_int|0
comma
r_sizeof
(paren
id|info-&gt;InquiryData
)paren
)paren
suffix:semicolon
multiline_comment|/* Standard IDE interface only supports disks */
id|info-&gt;InquiryData.DeviceType
op_assign
id|DIRECT_ACCESS_DEVICE
suffix:semicolon
multiline_comment|/* Fix-up the return data from an INQUIRY command to show &n;&t;&t;&t;&t; * ANSI SCSI rev 2 so we don&squot;t confuse the SCSI layers above us&n;&t;&t;&t;&t; * in Linux.&n;&t;&t;&t;&t; */
id|info-&gt;InquiryData.Versions
op_assign
l_int|0x2
suffix:semicolon
multiline_comment|/* The length must be at least 36 (5 + 31) */
id|info-&gt;InquiryData.AdditionalLength
op_assign
l_int|0x1F
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;drive.command_set_1
op_amp
id|COMMANDSET_MEDIA_STATUS
)paren
(brace
multiline_comment|/* set the removable bit */
id|info-&gt;InquiryData.RemovableMedia
op_assign
l_int|1
suffix:semicolon
id|info-&gt;DeviceFlags
op_or_assign
id|DF_REMOVABLE_MEDIA
suffix:semicolon
)brace
multiline_comment|/* Fill in vendor identification fields */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|20
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|info-&gt;InquiryData.VendorId
(braket
id|i
)braket
op_assign
id|info-&gt;drive.model
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
id|info-&gt;InquiryData.VendorId
(braket
id|i
op_plus
l_int|1
)braket
op_assign
id|info-&gt;drive.model
(braket
id|i
)braket
suffix:semicolon
)brace
multiline_comment|/* Initialize unused portion of product id */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|info-&gt;InquiryData.ProductId
(braket
l_int|12
op_plus
id|i
)braket
op_assign
l_char|&squot; &squot;
suffix:semicolon
)brace
multiline_comment|/* Move firmware revision from IDENTIFY data to */
multiline_comment|/* product revision in INQUIRY data             */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|info-&gt;InquiryData.ProductRevisionLevel
(braket
id|i
)braket
op_assign
id|info-&gt;drive.fw_rev
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
id|info-&gt;InquiryData.ProductRevisionLevel
(braket
id|i
op_plus
l_int|1
)braket
op_assign
id|info-&gt;drive.fw_rev
(braket
id|i
)braket
suffix:semicolon
)brace
multiline_comment|/* determine if it supports Media Status Notification */
r_if
c_cond
(paren
id|info-&gt;drive.command_set_2
op_amp
id|COMMANDSET_MEDIA_STATUS
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;   Device supports Media Status Notification&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Indicate that it is enabled, even though it is not&n;&t;&t;&t;&t;&t; * This allows the lock/unlock of the media to work&n;&t;&t;&t;&t;&t; * correctly.&n;&t;&t;&t;&t;&t; */
id|info-&gt;DeviceFlags
op_or_assign
id|DF_MEDIA_STATUS_ENABLED
suffix:semicolon
)brace
r_else
id|info-&gt;DeviceFlags
op_and_assign
op_complement
id|DF_MEDIA_STATUS_ENABLED
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* &n;&t;&t;&t; * this must be an ATAPI device &n;&t;&t;&t; * use an ATAPI protocol (Transparent SCSI)&n;&t;&t;&t; */
id|us-&gt;protocol_name
op_assign
l_string|&quot;Transparent SCSI&quot;
suffix:semicolon
id|us-&gt;proto_handler
op_assign
id|usb_stor_transparent_scsi_command
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Protocol changed to: %s&bslash;n&quot;
comma
id|us-&gt;protocol_name
)paren
suffix:semicolon
multiline_comment|/* Free driver structure */
r_if
c_cond
(paren
id|us-&gt;extra
op_ne
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|us-&gt;extra
)paren
suffix:semicolon
id|us-&gt;extra
op_assign
l_int|NULL
suffix:semicolon
id|us-&gt;extra_destructor
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Leaving isd200_get_inquiry_data %08X&bslash;n&quot;
comma
id|retStatus
)paren
suffix:semicolon
r_return
id|retStatus
suffix:semicolon
)brace
multiline_comment|/**************************************************************************&n; * isd200_data_copy&n; *                                                                         &n; * Copy data into the srb request buffer.  Use scatter gather if required.&n; *&n; * RETURNS:&n; *    void&n; */
DECL|function|isd200_data_copy
r_void
id|isd200_data_copy
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
r_char
op_star
id|src
comma
r_int
id|length
)paren
(brace
r_int
r_int
id|len
op_assign
id|length
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
r_if
c_cond
(paren
id|srb-&gt;use_sg
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|total
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Add up the sizes of all the sg segments */
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|srb-&gt;request_buffer
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|srb-&gt;use_sg
suffix:semicolon
id|i
op_increment
)paren
id|total
op_add_assign
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
r_if
c_cond
(paren
id|length
OG
id|total
)paren
id|len
op_assign
id|total
suffix:semicolon
id|total
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Copy data into sg buffer(s) */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|srb-&gt;use_sg
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|len
OG
id|total
)paren
op_logical_and
(paren
id|len
OG
l_int|0
)paren
)paren
(brace
multiline_comment|/* transfer the lesser of the next buffer or the&n;&t;&t;&t;&t; * remaining data */
r_if
c_cond
(paren
id|len
op_minus
id|total
op_ge
id|sg
(braket
id|i
)braket
dot
id|length
)paren
(brace
id|memcpy
c_func
(paren
id|sg
(braket
id|i
)braket
dot
id|address
comma
id|src
op_plus
id|total
comma
id|sg
(braket
id|i
)braket
dot
id|length
)paren
suffix:semicolon
id|total
op_add_assign
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|sg
(braket
id|i
)braket
dot
id|address
comma
id|src
op_plus
id|total
comma
id|len
op_minus
id|total
)paren
suffix:semicolon
id|total
op_assign
id|len
suffix:semicolon
)brace
)brace
r_else
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Make sure length does not exceed buffer length */
r_if
c_cond
(paren
id|length
OG
id|srb-&gt;request_bufflen
)paren
id|len
op_assign
id|srb-&gt;request_bufflen
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
id|memcpy
c_func
(paren
id|srb-&gt;request_buffer
comma
id|src
comma
id|len
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**************************************************************************&n; * isd200_scsi_to_ata&n; *                                                                         &n; * Translate SCSI commands to ATA commands.&n; *&n; * RETURNS:&n; *    TRUE if the command needs to be sent to the transport layer&n; *    FALSE otherwise&n; */
DECL|function|isd200_scsi_to_ata
r_int
id|isd200_scsi_to_ata
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
comma
r_union
id|ata_cdb
op_star
id|ataCdb
)paren
(brace
r_struct
id|isd200_info
op_star
id|info
op_assign
(paren
r_struct
id|isd200_info
op_star
)paren
id|us-&gt;extra
suffix:semicolon
r_int
id|sendToTransport
op_assign
id|TRUE
suffix:semicolon
r_int
r_char
id|sectnum
comma
id|head
suffix:semicolon
r_int
r_int
id|cylinder
suffix:semicolon
r_int
r_int
id|lba
suffix:semicolon
r_int
r_int
id|blockCount
suffix:semicolon
r_int
r_char
id|senseData
(braket
l_int|8
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
id|memset
c_func
(paren
id|ataCdb
comma
l_int|0
comma
r_sizeof
(paren
r_union
id|ata_cdb
)paren
)paren
suffix:semicolon
multiline_comment|/* SCSI Command */
r_switch
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
id|INQUIRY
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;   ATA OUT - INQUIRY&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|srb-&gt;request_bufflen
OG
r_sizeof
(paren
r_struct
id|inquiry_data
)paren
)paren
id|srb-&gt;request_bufflen
op_assign
r_sizeof
(paren
r_struct
id|inquiry_data
)paren
suffix:semicolon
multiline_comment|/* copy InquiryData */
id|isd200_data_copy
c_func
(paren
id|srb
comma
(paren
r_char
op_star
)paren
op_amp
id|info-&gt;InquiryData
comma
id|srb-&gt;request_bufflen
)paren
suffix:semicolon
id|srb-&gt;result
op_assign
id|GOOD
suffix:semicolon
id|sendToTransport
op_assign
id|FALSE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MODE_SENSE
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;   ATA OUT - SCSIOP_MODE_SENSE&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Initialize the return buffer */
id|isd200_data_copy
c_func
(paren
id|srb
comma
(paren
r_char
op_star
)paren
op_amp
id|senseData
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;DeviceFlags
op_amp
id|DF_MEDIA_STATUS_ENABLED
)paren
(brace
id|ataCdb-&gt;generic.SignatureByte0
op_assign
id|info-&gt;ConfigData.ATAMajorCommand
suffix:semicolon
id|ataCdb-&gt;generic.SignatureByte1
op_assign
id|info-&gt;ConfigData.ATAMinorCommand
suffix:semicolon
id|ataCdb-&gt;generic.TransferBlockSize
op_assign
l_int|1
suffix:semicolon
id|ataCdb-&gt;write.SelectCommand
op_assign
l_int|1
suffix:semicolon
id|ataCdb-&gt;write.CommandByte
op_assign
id|ATA_COMMAND_GET_MEDIA_STATUS
suffix:semicolon
id|srb-&gt;request_bufflen
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;   Media Status not supported, just report okay&bslash;n&quot;
)paren
suffix:semicolon
id|srb-&gt;result
op_assign
id|GOOD
suffix:semicolon
id|sendToTransport
op_assign
id|FALSE
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TEST_UNIT_READY
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;   ATA OUT - SCSIOP_TEST_UNIT_READY&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Initialize the return buffer */
id|isd200_data_copy
c_func
(paren
id|srb
comma
(paren
r_char
op_star
)paren
op_amp
id|senseData
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;DeviceFlags
op_amp
id|DF_MEDIA_STATUS_ENABLED
)paren
(brace
id|ataCdb-&gt;generic.SignatureByte0
op_assign
id|info-&gt;ConfigData.ATAMajorCommand
suffix:semicolon
id|ataCdb-&gt;generic.SignatureByte1
op_assign
id|info-&gt;ConfigData.ATAMinorCommand
suffix:semicolon
id|ataCdb-&gt;generic.TransferBlockSize
op_assign
l_int|1
suffix:semicolon
id|ataCdb-&gt;write.SelectCommand
op_assign
l_int|1
suffix:semicolon
id|ataCdb-&gt;write.CommandByte
op_assign
id|ATA_COMMAND_GET_MEDIA_STATUS
suffix:semicolon
id|srb-&gt;request_bufflen
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;   Media Status not supported, just report okay&bslash;n&quot;
)paren
suffix:semicolon
id|srb-&gt;result
op_assign
id|GOOD
suffix:semicolon
id|sendToTransport
op_assign
id|FALSE
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|READ_CAPACITY
suffix:colon
(brace
r_int
r_int
id|capacity
suffix:semicolon
r_struct
id|read_capacity_data
id|readCapacityData
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;   ATA OUT - SCSIOP_READ_CAPACITY&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;drive.capability
op_amp
id|CAPABILITY_LBA
)paren
(brace
id|capacity
op_assign
id|info-&gt;drive.lba_capacity
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|capacity
op_assign
(paren
id|info-&gt;drive.heads
op_star
id|info-&gt;drive.cyls
op_star
id|info-&gt;drive.sectors
)paren
op_minus
l_int|1
suffix:semicolon
)brace
id|readCapacityData.LogicalBlockAddress
op_assign
id|cpu_to_be32
c_func
(paren
id|capacity
)paren
suffix:semicolon
id|readCapacityData.BytesPerBlock
op_assign
id|cpu_to_be32
c_func
(paren
l_int|0x200
)paren
suffix:semicolon
r_if
c_cond
(paren
id|srb-&gt;request_bufflen
OG
r_sizeof
(paren
r_struct
id|read_capacity_data
)paren
)paren
id|srb-&gt;request_bufflen
op_assign
r_sizeof
(paren
r_struct
id|read_capacity_data
)paren
suffix:semicolon
id|isd200_data_copy
c_func
(paren
id|srb
comma
(paren
r_char
op_star
)paren
op_amp
id|readCapacityData
comma
id|srb-&gt;request_bufflen
)paren
suffix:semicolon
id|srb-&gt;result
op_assign
id|GOOD
suffix:semicolon
id|sendToTransport
op_assign
id|FALSE
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|READ_10
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;   ATA OUT - SCSIOP_READ&bslash;n&quot;
)paren
suffix:semicolon
id|lba
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
op_amp
id|srb-&gt;cmnd
(braket
l_int|2
)braket
suffix:semicolon
id|lba
op_assign
id|cpu_to_be32
c_func
(paren
id|lba
)paren
suffix:semicolon
id|blockCount
op_assign
(paren
r_int
r_int
)paren
id|srb-&gt;cmnd
(braket
l_int|7
)braket
op_lshift
l_int|8
op_or
(paren
r_int
r_int
)paren
id|srb-&gt;cmnd
(braket
l_int|8
)braket
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;drive.capability
op_amp
id|CAPABILITY_LBA
)paren
(brace
id|sectnum
op_assign
(paren
r_int
r_char
)paren
(paren
id|lba
)paren
suffix:semicolon
id|cylinder
op_assign
(paren
r_int
r_int
)paren
(paren
id|lba
op_rshift
l_int|8
)paren
suffix:semicolon
id|head
op_assign
id|ATA_ADDRESS_DEVHEAD_LBA_MODE
op_or
(paren
r_int
r_char
)paren
(paren
id|lba
op_rshift
l_int|24
op_amp
l_int|0x0F
)paren
suffix:semicolon
)brace
r_else
(brace
id|sectnum
op_assign
(paren
r_int
r_char
)paren
(paren
(paren
id|lba
op_mod
id|info-&gt;drive.sectors
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|cylinder
op_assign
(paren
r_int
r_int
)paren
(paren
id|lba
op_div
(paren
id|info-&gt;drive.sectors
op_star
id|info-&gt;drive.heads
)paren
)paren
suffix:semicolon
id|head
op_assign
(paren
r_int
r_char
)paren
(paren
(paren
id|lba
op_div
id|info-&gt;drive.sectors
)paren
op_mod
id|info-&gt;drive.heads
)paren
suffix:semicolon
)brace
id|ataCdb-&gt;generic.SignatureByte0
op_assign
id|info-&gt;ConfigData.ATAMajorCommand
suffix:semicolon
id|ataCdb-&gt;generic.SignatureByte1
op_assign
id|info-&gt;ConfigData.ATAMinorCommand
suffix:semicolon
id|ataCdb-&gt;generic.TransferBlockSize
op_assign
l_int|1
suffix:semicolon
id|ataCdb-&gt;write.SelectSectorCount
op_assign
l_int|1
suffix:semicolon
id|ataCdb-&gt;write.SectorCountByte
op_assign
(paren
r_int
r_char
)paren
id|blockCount
suffix:semicolon
id|ataCdb-&gt;write.SelectSectorNumber
op_assign
l_int|1
suffix:semicolon
id|ataCdb-&gt;write.SectorNumberByte
op_assign
id|sectnum
suffix:semicolon
id|ataCdb-&gt;write.SelectCylinderHigh
op_assign
l_int|1
suffix:semicolon
id|ataCdb-&gt;write.CylinderHighByte
op_assign
(paren
r_int
r_char
)paren
(paren
id|cylinder
op_rshift
l_int|8
)paren
suffix:semicolon
id|ataCdb-&gt;write.SelectCylinderLow
op_assign
l_int|1
suffix:semicolon
id|ataCdb-&gt;write.CylinderLowByte
op_assign
(paren
r_int
r_char
)paren
id|cylinder
suffix:semicolon
id|ataCdb-&gt;write.SelectDeviceHead
op_assign
l_int|1
suffix:semicolon
id|ataCdb-&gt;write.DeviceHeadByte
op_assign
(paren
id|head
op_or
id|ATA_ADDRESS_DEVHEAD_STD
)paren
suffix:semicolon
id|ataCdb-&gt;write.SelectCommand
op_assign
l_int|1
suffix:semicolon
id|ataCdb-&gt;write.CommandByte
op_assign
id|WIN_READ
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WRITE_10
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;   ATA OUT - SCSIOP_WRITE&bslash;n&quot;
)paren
suffix:semicolon
id|lba
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
op_amp
id|srb-&gt;cmnd
(braket
l_int|2
)braket
suffix:semicolon
id|lba
op_assign
id|cpu_to_be32
c_func
(paren
id|lba
)paren
suffix:semicolon
id|blockCount
op_assign
(paren
r_int
r_int
)paren
id|srb-&gt;cmnd
(braket
l_int|7
)braket
op_lshift
l_int|8
op_or
(paren
r_int
r_int
)paren
id|srb-&gt;cmnd
(braket
l_int|8
)braket
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;drive.capability
op_amp
id|CAPABILITY_LBA
)paren
(brace
id|sectnum
op_assign
(paren
r_int
r_char
)paren
(paren
id|lba
)paren
suffix:semicolon
id|cylinder
op_assign
(paren
r_int
r_int
)paren
(paren
id|lba
op_rshift
l_int|8
)paren
suffix:semicolon
id|head
op_assign
id|ATA_ADDRESS_DEVHEAD_LBA_MODE
op_or
(paren
r_int
r_char
)paren
(paren
id|lba
op_rshift
l_int|24
op_amp
l_int|0x0F
)paren
suffix:semicolon
)brace
r_else
(brace
id|sectnum
op_assign
(paren
r_int
r_char
)paren
(paren
(paren
id|lba
op_mod
id|info-&gt;drive.sectors
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|cylinder
op_assign
(paren
r_int
r_int
)paren
(paren
id|lba
op_div
(paren
id|info-&gt;drive.sectors
op_star
id|info-&gt;drive.heads
)paren
)paren
suffix:semicolon
id|head
op_assign
(paren
r_int
r_char
)paren
(paren
(paren
id|lba
op_div
id|info-&gt;drive.sectors
)paren
op_mod
id|info-&gt;drive.heads
)paren
suffix:semicolon
)brace
id|ataCdb-&gt;generic.SignatureByte0
op_assign
id|info-&gt;ConfigData.ATAMajorCommand
suffix:semicolon
id|ataCdb-&gt;generic.SignatureByte1
op_assign
id|info-&gt;ConfigData.ATAMinorCommand
suffix:semicolon
id|ataCdb-&gt;generic.TransferBlockSize
op_assign
l_int|1
suffix:semicolon
id|ataCdb-&gt;write.SelectSectorCount
op_assign
l_int|1
suffix:semicolon
id|ataCdb-&gt;write.SectorCountByte
op_assign
(paren
r_int
r_char
)paren
id|blockCount
suffix:semicolon
id|ataCdb-&gt;write.SelectSectorNumber
op_assign
l_int|1
suffix:semicolon
id|ataCdb-&gt;write.SectorNumberByte
op_assign
id|sectnum
suffix:semicolon
id|ataCdb-&gt;write.SelectCylinderHigh
op_assign
l_int|1
suffix:semicolon
id|ataCdb-&gt;write.CylinderHighByte
op_assign
(paren
r_int
r_char
)paren
(paren
id|cylinder
op_rshift
l_int|8
)paren
suffix:semicolon
id|ataCdb-&gt;write.SelectCylinderLow
op_assign
l_int|1
suffix:semicolon
id|ataCdb-&gt;write.CylinderLowByte
op_assign
(paren
r_int
r_char
)paren
id|cylinder
suffix:semicolon
id|ataCdb-&gt;write.SelectDeviceHead
op_assign
l_int|1
suffix:semicolon
id|ataCdb-&gt;write.DeviceHeadByte
op_assign
(paren
id|head
op_or
id|ATA_ADDRESS_DEVHEAD_STD
)paren
suffix:semicolon
id|ataCdb-&gt;write.SelectCommand
op_assign
l_int|1
suffix:semicolon
id|ataCdb-&gt;write.CommandByte
op_assign
id|WIN_WRITE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ALLOW_MEDIUM_REMOVAL
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;   ATA OUT - SCSIOP_MEDIUM_REMOVAL&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;DeviceFlags
op_amp
id|DF_REMOVABLE_MEDIA
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;   srb-&gt;cmnd[4] = 0x%X&bslash;n&quot;
comma
id|srb-&gt;cmnd
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|ataCdb-&gt;generic.SignatureByte0
op_assign
id|info-&gt;ConfigData.ATAMajorCommand
suffix:semicolon
id|ataCdb-&gt;generic.SignatureByte1
op_assign
id|info-&gt;ConfigData.ATAMinorCommand
suffix:semicolon
id|ataCdb-&gt;generic.TransferBlockSize
op_assign
l_int|1
suffix:semicolon
id|ataCdb-&gt;write.SelectCommand
op_assign
l_int|1
suffix:semicolon
id|ataCdb-&gt;write.CommandByte
op_assign
(paren
id|srb-&gt;cmnd
(braket
l_int|4
)braket
op_amp
l_int|0x1
)paren
ques
c_cond
id|WIN_DOORLOCK
suffix:colon
id|WIN_DOORUNLOCK
suffix:semicolon
id|srb-&gt;request_bufflen
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;   Not removeable media, just report okay&bslash;n&quot;
)paren
suffix:semicolon
id|srb-&gt;result
op_assign
id|GOOD
suffix:semicolon
id|sendToTransport
op_assign
id|FALSE
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|START_STOP
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;   ATA OUT - SCSIOP_START_STOP_UNIT&bslash;n&quot;
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;   srb-&gt;cmnd[4] = 0x%X&bslash;n&quot;
comma
id|srb-&gt;cmnd
(braket
l_int|4
)braket
)paren
suffix:semicolon
multiline_comment|/* Initialize the return buffer */
id|isd200_data_copy
c_func
(paren
id|srb
comma
(paren
r_char
op_star
)paren
op_amp
id|senseData
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|srb-&gt;cmnd
(braket
l_int|4
)braket
op_amp
l_int|0x3
)paren
op_eq
l_int|0x2
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;   Media Eject&bslash;n&quot;
)paren
suffix:semicolon
id|ataCdb-&gt;generic.SignatureByte0
op_assign
id|info-&gt;ConfigData.ATAMajorCommand
suffix:semicolon
id|ataCdb-&gt;generic.SignatureByte1
op_assign
id|info-&gt;ConfigData.ATAMinorCommand
suffix:semicolon
id|ataCdb-&gt;generic.TransferBlockSize
op_assign
l_int|0
suffix:semicolon
id|ataCdb-&gt;write.SelectCommand
op_assign
l_int|1
suffix:semicolon
id|ataCdb-&gt;write.CommandByte
op_assign
id|ATA_COMMAND_MEDIA_EJECT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|srb-&gt;cmnd
(braket
l_int|4
)braket
op_amp
l_int|0x3
)paren
op_eq
l_int|0x1
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;   Get Media Status&bslash;n&quot;
)paren
suffix:semicolon
id|ataCdb-&gt;generic.SignatureByte0
op_assign
id|info-&gt;ConfigData.ATAMajorCommand
suffix:semicolon
id|ataCdb-&gt;generic.SignatureByte1
op_assign
id|info-&gt;ConfigData.ATAMinorCommand
suffix:semicolon
id|ataCdb-&gt;generic.TransferBlockSize
op_assign
l_int|1
suffix:semicolon
id|ataCdb-&gt;write.SelectCommand
op_assign
l_int|1
suffix:semicolon
id|ataCdb-&gt;write.CommandByte
op_assign
id|ATA_COMMAND_GET_MEDIA_STATUS
suffix:semicolon
id|srb-&gt;request_bufflen
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;   Nothing to do, just report okay&bslash;n&quot;
)paren
suffix:semicolon
id|srb-&gt;result
op_assign
id|GOOD
suffix:semicolon
id|sendToTransport
op_assign
id|FALSE
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Unsupported SCSI command - 0x%X&bslash;n&quot;
comma
id|srb-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|srb-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
id|sendToTransport
op_assign
id|FALSE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|sendToTransport
suffix:semicolon
)brace
multiline_comment|/**************************************************************************&n; * isd200_init_info&n; *                                                                         &n; * Allocates (if necessary) and initializes the driver structure.&n; *&n; * RETURNS:&n; *    ISD status code&n; */
DECL|function|isd200_init_info
r_int
id|isd200_init_info
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|retStatus
op_assign
id|ISD200_GOOD
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|us-&gt;extra
)paren
(brace
id|us-&gt;extra
op_assign
(paren
r_void
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|isd200_info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|us-&gt;extra
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;ERROR - kmalloc failure&bslash;n&quot;
)paren
suffix:semicolon
id|retStatus
op_assign
id|ISD200_ERROR
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|retStatus
op_eq
id|ISD200_GOOD
)paren
(brace
id|memset
c_func
(paren
id|us-&gt;extra
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|isd200_info
)paren
)paren
suffix:semicolon
)brace
r_return
id|retStatus
suffix:semicolon
)brace
multiline_comment|/**************************************************************************&n; * Initialization for the ISD200 &n; */
DECL|function|isd200_Initialization
r_int
id|isd200_Initialization
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;ISD200 Initialization...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Initialize ISD200 info struct */
r_if
c_cond
(paren
id|isd200_init_info
c_func
(paren
id|us
)paren
op_eq
id|ISD200_ERROR
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;ERROR Initializing ISD200 Info struct&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Get device specific data */
r_if
c_cond
(paren
id|isd200_get_inquiry_data
c_func
(paren
id|us
)paren
op_ne
id|ISD200_GOOD
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;ISD200 Initialization Failure&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|US_DEBUGP
c_func
(paren
l_string|&quot;ISD200 Initialization complete&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**************************************************************************&n; * Protocol and Transport for the ISD200 ASIC&n; *&n; * This protocol and transport are for ATA devices connected to an ISD200&n; * ASIC.  An ATAPI device that is conected as a slave device will be&n; * detected in the driver initialization function and the protocol will&n; * be changed to an ATAPI protocol (Transparent SCSI).&n; *&n; */
DECL|function|isd200_ata_command
r_void
id|isd200_ata_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|sendToTransport
op_assign
id|TRUE
suffix:semicolon
r_union
id|ata_cdb
id|ataCdb
suffix:semicolon
multiline_comment|/* Make sure driver was initialized */
r_if
c_cond
(paren
id|us-&gt;extra
op_eq
l_int|NULL
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;ERROR Driver not initialized&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Convert command */
id|sendToTransport
op_assign
id|isd200_scsi_to_ata
c_func
(paren
id|srb
comma
id|us
comma
op_amp
id|ataCdb
)paren
suffix:semicolon
multiline_comment|/* send the command to the transport layer */
r_if
c_cond
(paren
id|sendToTransport
)paren
id|isd200_invoke_transport
c_func
(paren
id|us
comma
id|srb
comma
op_amp
id|ataCdb
)paren
suffix:semicolon
)brace
eof
