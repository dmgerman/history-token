multiline_comment|/* Driver for SCM Microsystems USB-ATAPI cable&n; *&n; * $Id: shuttle_usbat.c,v 1.17 2002/04/22 03:39:43 mdharm Exp $&n; *&n; * Current development and maintenance by:&n; *   (c) 2000, 2001 Robert Baruch (autophile@starband.net)&n; *   (c) 2004, 2005 Daniel Drake &lt;dsd@gentoo.org&gt;&n; *&n; * Developed with the assistance of:&n; *   (c) 2002 Alan Stern &lt;stern@rowland.org&gt;&n; *&n; * Flash support based on earlier work by:&n; *   (c) 2002 Thomas Kreiling &lt;usbdev@sm04.de&gt;&n; *&n; * Many originally ATAPI devices were slightly modified to meet the USB&n; * market by using some kind of translation from ATAPI to USB on the host,&n; * and the peripheral would translate from USB back to ATAPI.&n; *&n; * SCM Microsystems (www.scmmicro.com) makes a device, sold to OEM&squot;s only, &n; * which does the USB-to-ATAPI conversion.  By obtaining the data sheet on&n; * their device under nondisclosure agreement, I have been able to write&n; * this driver for Linux.&n; *&n; * The chip used in the device can also be used for EPP and ISA translation&n; * as well. This driver is only guaranteed to work with the ATAPI&n; * translation.&n; *&n; * See the Kconfig help text for a list of devices known to be supported by&n; * this driver.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2, or (at your option) any&n; * later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write to the Free Software Foundation, Inc.,&n; * 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/cdrom.h&gt;
macro_line|#include &lt;scsi/scsi.h&gt;
macro_line|#include &lt;scsi/scsi_cmnd.h&gt;
macro_line|#include &quot;transport.h&quot;
macro_line|#include &quot;protocol.h&quot;
macro_line|#include &quot;usb.h&quot;
macro_line|#include &quot;debug.h&quot;
macro_line|#include &quot;shuttle_usbat.h&quot;
DECL|macro|short_pack
mdefine_line|#define short_pack(LSB,MSB) ( ((u16)(LSB)) | ( ((u16)(MSB))&lt;&lt;8 ) )
DECL|macro|LSB_of
mdefine_line|#define LSB_of(s) ((s)&amp;0xFF)
DECL|macro|MSB_of
mdefine_line|#define MSB_of(s) ((s)&gt;&gt;8)
DECL|variable|transferred
r_static
r_int
id|transferred
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|usbat_flash_transport
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
suffix:semicolon
r_static
r_int
id|usbat_hp8200e_transport
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
suffix:semicolon
multiline_comment|/*&n; * Convenience function to produce an ATAPI read/write sectors command&n; * Use cmd=0x20 for read, cmd=0x30 for write&n; */
DECL|function|usbat_pack_atapi_sector_cmd
r_static
r_void
id|usbat_pack_atapi_sector_cmd
c_func
(paren
r_int
r_char
op_star
id|buf
comma
r_int
r_char
id|thistime
comma
id|u32
id|sector
comma
r_int
r_char
id|cmd
)paren
(brace
id|buf
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_assign
id|thistime
suffix:semicolon
id|buf
(braket
l_int|2
)braket
op_assign
id|sector
op_amp
l_int|0xFF
suffix:semicolon
id|buf
(braket
l_int|3
)braket
op_assign
(paren
id|sector
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|buf
(braket
l_int|4
)braket
op_assign
(paren
id|sector
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|buf
(braket
l_int|5
)braket
op_assign
l_int|0xE0
op_or
(paren
(paren
id|sector
op_rshift
l_int|24
)paren
op_amp
l_int|0x0F
)paren
suffix:semicolon
id|buf
(braket
l_int|6
)braket
op_assign
id|cmd
suffix:semicolon
)brace
multiline_comment|/*&n; * Convenience function to get the device type (flash or hp8200)&n; */
DECL|function|usbat_get_device_type
r_static
r_int
id|usbat_get_device_type
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_return
(paren
(paren
r_struct
id|usbat_info
op_star
)paren
id|us-&gt;extra
)paren
op_member_access_from_pointer
id|devicetype
suffix:semicolon
)brace
multiline_comment|/*&n; * Read a register from the device&n; */
DECL|function|usbat_read
r_static
r_int
id|usbat_read
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
id|access
comma
r_int
r_char
id|reg
comma
r_int
r_char
op_star
id|content
)paren
(brace
r_return
id|usb_stor_ctrl_transfer
c_func
(paren
id|us
comma
id|us-&gt;recv_ctrl_pipe
comma
id|access
op_or
id|USBAT_CMD_READ_REG
comma
l_int|0xC0
comma
(paren
id|u16
)paren
id|reg
comma
l_int|0
comma
id|content
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Write to a register on the device&n; */
DECL|function|usbat_write
r_static
r_int
id|usbat_write
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
id|access
comma
r_int
r_char
id|reg
comma
r_int
r_char
id|content
)paren
(brace
r_return
id|usb_stor_ctrl_transfer
c_func
(paren
id|us
comma
id|us-&gt;send_ctrl_pipe
comma
id|access
op_or
id|USBAT_CMD_WRITE_REG
comma
l_int|0x40
comma
id|short_pack
c_func
(paren
id|reg
comma
id|content
)paren
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convenience function to perform a bulk read&n; */
DECL|function|usbat_bulk_read
r_static
r_int
id|usbat_bulk_read
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|data
comma
r_int
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
r_return
id|USB_STOR_XFER_GOOD
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;usbat_bulk_read: len = %d&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
r_return
id|usb_stor_bulk_transfer_buf
c_func
(paren
id|us
comma
id|us-&gt;recv_bulk_pipe
comma
id|data
comma
id|len
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convenience function to perform a bulk write&n; */
DECL|function|usbat_bulk_write
r_static
r_int
id|usbat_bulk_write
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|data
comma
r_int
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
r_return
id|USB_STOR_XFER_GOOD
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;usbat_bulk_write:  len = %d&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
r_return
id|usb_stor_bulk_transfer_buf
c_func
(paren
id|us
comma
id|us-&gt;send_bulk_pipe
comma
id|data
comma
id|len
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Some USBAT-specific commands can only be executed over a command transport&n; * This transport allows one (len=8) or two (len=16) vendor-specific commands&n; * to be executed.&n; */
DECL|function|usbat_execute_command
r_static
r_int
id|usbat_execute_command
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|commands
comma
r_int
r_int
id|len
)paren
(brace
r_return
id|usb_stor_ctrl_transfer
c_func
(paren
id|us
comma
id|us-&gt;send_ctrl_pipe
comma
id|USBAT_CMD_EXEC_CMD
comma
l_int|0x40
comma
l_int|0
comma
l_int|0
comma
id|commands
comma
id|len
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Read the status register&n; */
DECL|function|usbat_get_status
r_static
r_int
id|usbat_get_status
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|status
)paren
(brace
r_int
id|rc
suffix:semicolon
id|rc
op_assign
id|usbat_read
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
id|USBAT_ATA_STATUS
comma
id|status
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;usbat_get_status: 0x%02X&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
(paren
op_star
id|status
)paren
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Check the device status&n; */
DECL|function|usbat_check_status
r_static
r_int
id|usbat_check_status
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
r_char
op_star
id|reply
op_assign
id|us-&gt;iobuf
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|us
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|rc
op_assign
id|usbat_get_status
c_func
(paren
id|us
comma
id|reply
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
r_if
c_cond
(paren
op_star
id|reply
op_amp
l_int|0x01
op_logical_and
op_star
id|reply
op_ne
l_int|0x51
)paren
singleline_comment|// error/check condition (0x51 is ok)
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
r_if
c_cond
(paren
op_star
id|reply
op_amp
l_int|0x20
)paren
singleline_comment|// device fault
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
multiline_comment|/*&n; * Stores critical information in internal registers in prepartion for the execution&n; * of a conditional usbat_read_blocks or usbat_write_blocks call.&n; */
DECL|function|usbat_set_shuttle_features
r_static
r_int
id|usbat_set_shuttle_features
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
id|external_trigger
comma
r_int
r_char
id|epp_control
comma
r_int
r_char
id|mask_byte
comma
r_int
r_char
id|test_pattern
comma
r_int
r_char
id|subcountH
comma
r_int
r_char
id|subcountL
)paren
(brace
r_int
r_char
op_star
id|command
op_assign
id|us-&gt;iobuf
suffix:semicolon
id|command
(braket
l_int|0
)braket
op_assign
l_int|0x40
suffix:semicolon
id|command
(braket
l_int|1
)braket
op_assign
id|USBAT_CMD_SET_FEAT
suffix:semicolon
singleline_comment|// The only bit relevant to ATA access is bit 6
singleline_comment|// which defines 8 bit data access (set) or 16 bit (unset)
id|command
(braket
l_int|2
)braket
op_assign
id|epp_control
suffix:semicolon
singleline_comment|// If FCQ is set in the qualifier (defined in R/W cmd), then bits U0, U1,
singleline_comment|// ET1 and ET2 define an external event to be checked for on event of a
singleline_comment|// _read_blocks or _write_blocks operation. The read/write will not take
singleline_comment|// place unless the defined trigger signal is active.
id|command
(braket
l_int|3
)braket
op_assign
id|external_trigger
suffix:semicolon
singleline_comment|// The resultant byte of the mask operation (see mask_byte) is compared for
singleline_comment|// equivalence with this test pattern. If equal, the read/write will take
singleline_comment|// place.
id|command
(braket
l_int|4
)braket
op_assign
id|test_pattern
suffix:semicolon
singleline_comment|// This value is logically ANDed with the status register field specified
singleline_comment|// in the read/write command.
id|command
(braket
l_int|5
)braket
op_assign
id|mask_byte
suffix:semicolon
singleline_comment|// If ALQ is set in the qualifier, this field contains the address of the
singleline_comment|// registers where the byte count should be read for transferring the data.
singleline_comment|// If ALQ is not set, then this field contains the number of bytes to be
singleline_comment|// transferred.
id|command
(braket
l_int|6
)braket
op_assign
id|subcountL
suffix:semicolon
id|command
(braket
l_int|7
)braket
op_assign
id|subcountH
suffix:semicolon
r_return
id|usbat_execute_command
c_func
(paren
id|us
comma
id|command
comma
l_int|8
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Block, waiting for an ATA device to become not busy or to report&n; * an error condition.&n; */
DECL|function|usbat_wait_not_busy
r_static
r_int
id|usbat_wait_not_busy
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
id|minutes
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
r_char
op_star
id|status
op_assign
id|us-&gt;iobuf
suffix:semicolon
multiline_comment|/* Synchronizing cache on a CDR could take a heck of a long time,&n;&t; * but probably not more than 10 minutes or so. On the other hand,&n;&t; * doing a full blank on a CDRW at speed 1 will take about 75&n;&t; * minutes!&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1200
op_plus
id|minutes
op_star
l_int|60
suffix:semicolon
id|i
op_increment
)paren
(brace
id|result
op_assign
id|usbat_get_status
c_func
(paren
id|us
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
r_if
c_cond
(paren
op_star
id|status
op_amp
l_int|0x01
)paren
(brace
singleline_comment|// check condition
id|result
op_assign
id|usbat_read
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
l_int|0x10
comma
id|status
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|status
op_amp
l_int|0x20
)paren
singleline_comment|// device fault
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|status
op_amp
l_int|0x80
)paren
op_eq
l_int|0x00
)paren
(brace
singleline_comment|// not busy
id|US_DEBUGP
c_func
(paren
l_string|&quot;Waited not busy for %d steps&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
l_int|500
)paren
id|msleep
c_func
(paren
l_int|10
)paren
suffix:semicolon
singleline_comment|// 5 seconds
r_else
r_if
c_cond
(paren
id|i
OL
l_int|700
)paren
id|msleep
c_func
(paren
l_int|50
)paren
suffix:semicolon
singleline_comment|// 10 seconds
r_else
r_if
c_cond
(paren
id|i
OL
l_int|1200
)paren
id|msleep
c_func
(paren
l_int|100
)paren
suffix:semicolon
singleline_comment|// 50 seconds
r_else
id|msleep
c_func
(paren
l_int|1000
)paren
suffix:semicolon
singleline_comment|// X minutes
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Waited not busy for %d minutes, timing out.&bslash;n&quot;
comma
id|minutes
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
multiline_comment|/*&n; * Read block data from the data register&n; */
DECL|function|usbat_read_block
r_static
r_int
id|usbat_read_block
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|content
comma
r_int
r_int
id|len
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_char
op_star
id|command
op_assign
id|us-&gt;iobuf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
id|command
(braket
l_int|0
)braket
op_assign
l_int|0xC0
suffix:semicolon
id|command
(braket
l_int|1
)braket
op_assign
id|USBAT_ATA
op_or
id|USBAT_CMD_READ_BLOCK
suffix:semicolon
id|command
(braket
l_int|2
)braket
op_assign
id|USBAT_ATA_DATA
suffix:semicolon
id|command
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|command
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
id|command
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|command
(braket
l_int|6
)braket
op_assign
id|LSB_of
c_func
(paren
id|len
)paren
suffix:semicolon
id|command
(braket
l_int|7
)braket
op_assign
id|MSB_of
c_func
(paren
id|len
)paren
suffix:semicolon
id|result
op_assign
id|usbat_execute_command
c_func
(paren
id|us
comma
id|command
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|result
op_assign
id|usbat_bulk_read
c_func
(paren
id|us
comma
id|content
comma
id|len
)paren
suffix:semicolon
r_return
(paren
id|result
op_eq
id|USB_STOR_XFER_GOOD
ques
c_cond
id|USB_STOR_TRANSPORT_GOOD
suffix:colon
id|USB_STOR_TRANSPORT_ERROR
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Write block data via the data register&n; */
DECL|function|usbat_write_block
r_static
r_int
id|usbat_write_block
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
id|access
comma
r_int
r_char
op_star
id|content
comma
r_int
r_int
id|len
comma
r_int
id|minutes
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_char
op_star
id|command
op_assign
id|us-&gt;iobuf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
id|command
(braket
l_int|0
)braket
op_assign
l_int|0x40
suffix:semicolon
id|command
(braket
l_int|1
)braket
op_assign
id|access
op_or
id|USBAT_CMD_WRITE_BLOCK
suffix:semicolon
id|command
(braket
l_int|2
)braket
op_assign
id|USBAT_ATA_DATA
suffix:semicolon
id|command
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|command
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
id|command
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|command
(braket
l_int|6
)braket
op_assign
id|LSB_of
c_func
(paren
id|len
)paren
suffix:semicolon
id|command
(braket
l_int|7
)braket
op_assign
id|MSB_of
c_func
(paren
id|len
)paren
suffix:semicolon
id|result
op_assign
id|usbat_execute_command
c_func
(paren
id|us
comma
id|command
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|result
op_assign
id|usbat_bulk_write
c_func
(paren
id|us
comma
id|content
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
r_return
id|usbat_wait_not_busy
c_func
(paren
id|us
comma
id|minutes
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Process read and write requests&n; */
DECL|function|usbat_hp8200e_rw_block_test
r_static
r_int
id|usbat_hp8200e_rw_block_test
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
id|access
comma
r_int
r_char
op_star
id|registers
comma
r_int
r_char
op_star
id|data_out
comma
r_int
r_int
id|num_registers
comma
r_int
r_char
id|data_reg
comma
r_int
r_char
id|status_reg
comma
r_int
r_char
id|timeout
comma
r_int
r_char
id|qualifier
comma
r_int
id|direction
comma
r_int
r_char
op_star
id|content
comma
r_int
r_int
id|len
comma
r_int
id|use_sg
comma
r_int
id|minutes
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_int
id|pipe
op_assign
(paren
id|direction
op_eq
id|DMA_FROM_DEVICE
)paren
ques
c_cond
id|us-&gt;recv_bulk_pipe
suffix:colon
id|us-&gt;send_bulk_pipe
suffix:semicolon
r_int
r_char
op_star
id|command
op_assign
id|us-&gt;iobuf
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_int
id|cmdlen
suffix:semicolon
r_int
r_char
op_star
id|data
op_assign
id|us-&gt;iobuf
suffix:semicolon
r_int
r_char
op_star
id|status
op_assign
id|us-&gt;iobuf
suffix:semicolon
id|BUG_ON
c_func
(paren
id|num_registers
OG
id|US_IOBUF_SIZE
op_div
l_int|2
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|20
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * The first time we send the full command, which consists&n;&t;&t; * of downloading the SCSI command followed by downloading&n;&t;&t; * the data via a write-and-test.  Any other time we only&n;&t;&t; * send the command to download the data -- the SCSI command&n;&t;&t; * is still &squot;active&squot; in some sense in the device.&n;&t;&t; * &n;&t;&t; * We&squot;re only going to try sending the data 10 times. After&n;&t;&t; * that, we just return a failure.&n;&t;&t; */
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
id|cmdlen
op_assign
l_int|16
suffix:semicolon
singleline_comment|// Write to multiple registers
singleline_comment|// Not really sure the 0x07, 0x17, 0xfc, 0xe7 is necessary here,
singleline_comment|// but that&squot;s what came out of the trace every single time.
id|command
(braket
l_int|0
)braket
op_assign
l_int|0x40
suffix:semicolon
id|command
(braket
l_int|1
)braket
op_assign
id|access
op_or
id|USBAT_CMD_WRITE_REGS
suffix:semicolon
id|command
(braket
l_int|2
)braket
op_assign
l_int|0x07
suffix:semicolon
id|command
(braket
l_int|3
)braket
op_assign
l_int|0x17
suffix:semicolon
id|command
(braket
l_int|4
)braket
op_assign
l_int|0xFC
suffix:semicolon
id|command
(braket
l_int|5
)braket
op_assign
l_int|0xE7
suffix:semicolon
id|command
(braket
l_int|6
)braket
op_assign
id|LSB_of
c_func
(paren
id|num_registers
op_star
l_int|2
)paren
suffix:semicolon
id|command
(braket
l_int|7
)braket
op_assign
id|MSB_of
c_func
(paren
id|num_registers
op_star
l_int|2
)paren
suffix:semicolon
)brace
r_else
id|cmdlen
op_assign
l_int|8
suffix:semicolon
singleline_comment|// Conditionally read or write blocks
id|command
(braket
id|cmdlen
op_minus
l_int|8
)braket
op_assign
(paren
id|direction
op_eq
id|DMA_TO_DEVICE
ques
c_cond
l_int|0x40
suffix:colon
l_int|0xC0
)paren
suffix:semicolon
id|command
(braket
id|cmdlen
op_minus
l_int|7
)braket
op_assign
id|access
op_or
(paren
id|direction
op_eq
id|DMA_TO_DEVICE
ques
c_cond
id|USBAT_CMD_COND_WRITE_BLOCK
suffix:colon
id|USBAT_CMD_COND_READ_BLOCK
)paren
suffix:semicolon
id|command
(braket
id|cmdlen
op_minus
l_int|6
)braket
op_assign
id|data_reg
suffix:semicolon
id|command
(braket
id|cmdlen
op_minus
l_int|5
)braket
op_assign
id|status_reg
suffix:semicolon
id|command
(braket
id|cmdlen
op_minus
l_int|4
)braket
op_assign
id|timeout
suffix:semicolon
id|command
(braket
id|cmdlen
op_minus
l_int|3
)braket
op_assign
id|qualifier
suffix:semicolon
id|command
(braket
id|cmdlen
op_minus
l_int|2
)braket
op_assign
id|LSB_of
c_func
(paren
id|len
)paren
suffix:semicolon
id|command
(braket
id|cmdlen
op_minus
l_int|1
)braket
op_assign
id|MSB_of
c_func
(paren
id|len
)paren
suffix:semicolon
id|result
op_assign
id|usbat_execute_command
c_func
(paren
id|us
comma
id|command
comma
id|cmdlen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|num_registers
suffix:semicolon
id|j
op_increment
)paren
(brace
id|data
(braket
id|j
op_lshift
l_int|1
)braket
op_assign
id|registers
(braket
id|j
)braket
suffix:semicolon
id|data
(braket
l_int|1
op_plus
(paren
id|j
op_lshift
l_int|1
)paren
)braket
op_assign
id|data_out
(braket
id|j
)braket
suffix:semicolon
)brace
id|result
op_assign
id|usbat_bulk_write
c_func
(paren
id|us
comma
id|data
comma
id|num_registers
op_star
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
singleline_comment|//US_DEBUGP(&quot;Transfer %s %d bytes, sg buffers %d&bslash;n&quot;,
singleline_comment|//&t;direction == DMA_TO_DEVICE ? &quot;out&quot; : &quot;in&quot;,
singleline_comment|//&t;len, use_sg);
id|result
op_assign
id|usb_stor_bulk_transfer_sg
c_func
(paren
id|us
comma
id|pipe
comma
id|content
comma
id|len
comma
id|use_sg
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we get a stall on the bulk download, we&squot;ll retry&n;&t;&t; * the bulk download -- but not the SCSI command because&n;&t;&t; * in some sense the SCSI command is still &squot;active&squot; and&n;&t;&t; * waiting for the data. Don&squot;t ask me why this should be;&n;&t;&t; * I&squot;m only following what the Windoze driver did.&n;&t;&t; *&n;&t;&t; * Note that a stall for the test-and-read/write command means&n;&t;&t; * that the test failed. In this case we&squot;re testing to make&n;&t;&t; * sure that the device is error-free&n;&t;&t; * (i.e. bit 0 -- CHK -- of status is 0). The most likely&n;&t;&t; * hypothesis is that the USBAT chip somehow knows what&n;&t;&t; * the device will accept, but doesn&squot;t give the device any&n;&t;&t; * data until all data is received. Thus, the device would&n;&t;&t; * still be waiting for the first byte of data if a stall&n;&t;&t; * occurs, even if the stall implies that some data was&n;&t;&t; * transferred.&n;&t;&t; */
r_if
c_cond
(paren
id|result
op_eq
id|USB_STOR_XFER_SHORT
op_logical_or
id|result
op_eq
id|USB_STOR_XFER_STALLED
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If we&squot;re reading and we stalled, then clear&n;&t;&t;&t; * the bulk output pipe only the first time.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|direction
op_eq
id|DMA_FROM_DEVICE
op_logical_and
id|i
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|usb_stor_clear_halt
c_func
(paren
id|us
comma
id|us-&gt;send_bulk_pipe
)paren
OL
l_int|0
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Read status: is the device angry, or just busy?&n;&t;&t;&t; */
id|result
op_assign
id|usbat_read
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
id|direction
op_eq
id|DMA_TO_DEVICE
ques
c_cond
id|USBAT_ATA_STATUS
suffix:colon
id|USBAT_ATA_ALTSTATUS
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
r_if
c_cond
(paren
op_star
id|status
op_amp
l_int|0x01
)paren
singleline_comment|// check condition
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
r_if
c_cond
(paren
op_star
id|status
op_amp
l_int|0x20
)paren
singleline_comment|// device fault
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Redoing %s&bslash;n&quot;
comma
id|direction
op_eq
id|DMA_TO_DEVICE
ques
c_cond
l_string|&quot;write&quot;
suffix:colon
l_string|&quot;read&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
r_else
r_return
id|usbat_wait_not_busy
c_func
(paren
id|us
comma
id|minutes
)paren
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bummer! %s bulk data 20 times failed.&bslash;n&quot;
comma
id|direction
op_eq
id|DMA_TO_DEVICE
ques
c_cond
l_string|&quot;Writing&quot;
suffix:colon
l_string|&quot;Reading&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
multiline_comment|/*&n; * Write to multiple registers:&n; * Allows us to write specific data to any registers. The data to be written&n; * gets packed in this sequence: reg0, data0, reg1, data1, ..., regN, dataN&n; * which gets sent through bulk out.&n; * Not designed for large transfers of data!&n; */
DECL|function|usbat_multiple_write
r_static
r_int
id|usbat_multiple_write
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|registers
comma
r_int
r_char
op_star
id|data_out
comma
r_int
r_int
id|num_registers
)paren
(brace
r_int
id|i
comma
id|result
suffix:semicolon
r_int
r_char
op_star
id|data
op_assign
id|us-&gt;iobuf
suffix:semicolon
r_int
r_char
op_star
id|command
op_assign
id|us-&gt;iobuf
suffix:semicolon
id|BUG_ON
c_func
(paren
id|num_registers
OG
id|US_IOBUF_SIZE
op_div
l_int|2
)paren
suffix:semicolon
singleline_comment|// Write to multiple registers, ATA access
id|command
(braket
l_int|0
)braket
op_assign
l_int|0x40
suffix:semicolon
id|command
(braket
l_int|1
)braket
op_assign
id|USBAT_ATA
op_or
id|USBAT_CMD_WRITE_REGS
suffix:semicolon
singleline_comment|// No relevance
id|command
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|command
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|command
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
id|command
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
singleline_comment|// Number of bytes to be transferred (incl. addresses and data)
id|command
(braket
l_int|6
)braket
op_assign
id|LSB_of
c_func
(paren
id|num_registers
op_star
l_int|2
)paren
suffix:semicolon
id|command
(braket
l_int|7
)braket
op_assign
id|MSB_of
c_func
(paren
id|num_registers
op_star
l_int|2
)paren
suffix:semicolon
singleline_comment|// The setup command
id|result
op_assign
id|usbat_execute_command
c_func
(paren
id|us
comma
id|command
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
singleline_comment|// Create the reg/data, reg/data sequence
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_registers
suffix:semicolon
id|i
op_increment
)paren
(brace
id|data
(braket
id|i
op_lshift
l_int|1
)braket
op_assign
id|registers
(braket
id|i
)braket
suffix:semicolon
id|data
(braket
l_int|1
op_plus
(paren
id|i
op_lshift
l_int|1
)paren
)braket
op_assign
id|data_out
(braket
id|i
)braket
suffix:semicolon
)brace
singleline_comment|// Send the data
id|result
op_assign
id|usbat_bulk_write
c_func
(paren
id|us
comma
id|data
comma
id|num_registers
op_star
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|usbat_get_device_type
c_func
(paren
id|us
)paren
op_eq
id|USBAT_DEV_HP8200
)paren
r_return
id|usbat_wait_not_busy
c_func
(paren
id|us
comma
l_int|0
)paren
suffix:semicolon
r_else
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
multiline_comment|/*&n; * Conditionally read blocks from device:&n; * Allows us to read blocks from a specific data register, based upon the&n; * condition that a status register can be successfully masked with a status&n; * qualifier. If this condition is not initially met, the read will wait&n; * up until a maximum amount of time has elapsed, as specified by timeout.&n; * The read will start when the condition is met, otherwise the command aborts.&n; *&n; * The qualifier defined here is not the value that is masked, it defines&n; * conditions for the write to take place. The actual masked qualifier (and&n; * other related details) are defined beforehand with _set_shuttle_features().&n; */
DECL|function|usbat_read_blocks
r_static
r_int
id|usbat_read_blocks
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|buffer
comma
r_int
id|len
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_char
op_star
id|command
op_assign
id|us-&gt;iobuf
suffix:semicolon
id|command
(braket
l_int|0
)braket
op_assign
l_int|0xC0
suffix:semicolon
id|command
(braket
l_int|1
)braket
op_assign
id|USBAT_ATA
op_or
id|USBAT_CMD_COND_READ_BLOCK
suffix:semicolon
id|command
(braket
l_int|2
)braket
op_assign
id|USBAT_ATA_DATA
suffix:semicolon
id|command
(braket
l_int|3
)braket
op_assign
id|USBAT_ATA_STATUS
suffix:semicolon
id|command
(braket
l_int|4
)braket
op_assign
l_int|0xFD
suffix:semicolon
singleline_comment|// Timeout (ms);
id|command
(braket
l_int|5
)braket
op_assign
id|USBAT_QUAL_FCQ
suffix:semicolon
id|command
(braket
l_int|6
)braket
op_assign
id|LSB_of
c_func
(paren
id|len
)paren
suffix:semicolon
id|command
(braket
l_int|7
)braket
op_assign
id|MSB_of
c_func
(paren
id|len
)paren
suffix:semicolon
singleline_comment|// Multiple block read setup command
id|result
op_assign
id|usbat_execute_command
c_func
(paren
id|us
comma
id|command
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
singleline_comment|// Read the blocks we just asked for
id|result
op_assign
id|usbat_bulk_read
c_func
(paren
id|us
comma
id|buffer
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
multiline_comment|/*&n; * Conditionally write blocks to device:&n; * Allows us to write blocks to a specific data register, based upon the&n; * condition that a status register can be successfully masked with a status&n; * qualifier. If this condition is not initially met, the write will wait&n; * up until a maximum amount of time has elapsed, as specified by timeout.&n; * The read will start when the condition is met, otherwise the command aborts.&n; *&n; * The qualifier defined here is not the value that is masked, it defines&n; * conditions for the write to take place. The actual masked qualifier (and&n; * other related details) are defined beforehand with _set_shuttle_features().&n; */
DECL|function|usbat_write_blocks
r_static
r_int
id|usbat_write_blocks
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|buffer
comma
r_int
id|len
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_char
op_star
id|command
op_assign
id|us-&gt;iobuf
suffix:semicolon
id|command
(braket
l_int|0
)braket
op_assign
l_int|0x40
suffix:semicolon
id|command
(braket
l_int|1
)braket
op_assign
id|USBAT_ATA
op_or
id|USBAT_CMD_COND_WRITE_BLOCK
suffix:semicolon
id|command
(braket
l_int|2
)braket
op_assign
id|USBAT_ATA_DATA
suffix:semicolon
id|command
(braket
l_int|3
)braket
op_assign
id|USBAT_ATA_STATUS
suffix:semicolon
id|command
(braket
l_int|4
)braket
op_assign
l_int|0xFD
suffix:semicolon
singleline_comment|// Timeout (ms)
id|command
(braket
l_int|5
)braket
op_assign
id|USBAT_QUAL_FCQ
suffix:semicolon
id|command
(braket
l_int|6
)braket
op_assign
id|LSB_of
c_func
(paren
id|len
)paren
suffix:semicolon
id|command
(braket
l_int|7
)braket
op_assign
id|MSB_of
c_func
(paren
id|len
)paren
suffix:semicolon
singleline_comment|// Multiple block write setup command
id|result
op_assign
id|usbat_execute_command
c_func
(paren
id|us
comma
id|command
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
singleline_comment|// Write the data
id|result
op_assign
id|usbat_bulk_write
c_func
(paren
id|us
comma
id|buffer
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
multiline_comment|/*&n; * Read the User IO register&n; */
DECL|function|usbat_read_user_io
r_static
r_int
id|usbat_read_user_io
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|data_flags
)paren
(brace
r_int
id|result
suffix:semicolon
id|result
op_assign
id|usb_stor_ctrl_transfer
c_func
(paren
id|us
comma
id|us-&gt;recv_ctrl_pipe
comma
id|USBAT_CMD_UIO
comma
l_int|0xC0
comma
l_int|0
comma
l_int|0
comma
id|data_flags
comma
id|USBAT_UIO_READ
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;usbat_read_user_io: UIO register reads %02X&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
(paren
op_star
id|data_flags
)paren
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Write to the User IO register&n; */
DECL|function|usbat_write_user_io
r_static
r_int
id|usbat_write_user_io
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
id|enable_flags
comma
r_int
r_char
id|data_flags
)paren
(brace
r_return
id|usb_stor_ctrl_transfer
c_func
(paren
id|us
comma
id|us-&gt;send_ctrl_pipe
comma
id|USBAT_CMD_UIO
comma
l_int|0x40
comma
id|short_pack
c_func
(paren
id|enable_flags
comma
id|data_flags
)paren
comma
l_int|0
comma
l_int|NULL
comma
id|USBAT_UIO_WRITE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Reset the device&n; * Often needed on media change.&n; */
DECL|function|usbat_device_reset
r_static
r_int
id|usbat_device_reset
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|rc
suffix:semicolon
singleline_comment|// Reset peripheral, enable peripheral control signals
singleline_comment|// (bring reset signal up)
id|rc
op_assign
id|usbat_write_user_io
c_func
(paren
id|us
comma
id|USBAT_UIO_DRVRST
op_or
id|USBAT_UIO_OE1
op_or
id|USBAT_UIO_OE0
comma
id|USBAT_UIO_EPAD
op_or
id|USBAT_UIO_1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
singleline_comment|// Enable peripheral control signals
singleline_comment|// (bring reset signal down)
id|rc
op_assign
id|usbat_write_user_io
c_func
(paren
id|us
comma
id|USBAT_UIO_OE1
op_or
id|USBAT_UIO_OE0
comma
id|USBAT_UIO_EPAD
op_or
id|USBAT_UIO_1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
multiline_comment|/*&n; * Enable card detect&n; */
DECL|function|usbat_device_enable_cdt
r_static
r_int
id|usbat_device_enable_cdt
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|rc
suffix:semicolon
singleline_comment|// Enable peripheral control signals and card detect
id|rc
op_assign
id|usbat_write_user_io
c_func
(paren
id|us
comma
id|USBAT_UIO_ACKD
op_or
id|USBAT_UIO_OE1
op_or
id|USBAT_UIO_OE0
comma
id|USBAT_UIO_EPAD
op_or
id|USBAT_UIO_1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
multiline_comment|/*&n; * Determine if media is present.&n; */
DECL|function|usbat_flash_check_media_present
r_static
r_int
id|usbat_flash_check_media_present
c_func
(paren
r_int
r_char
op_star
id|uio
)paren
(brace
r_if
c_cond
(paren
op_star
id|uio
op_amp
id|USBAT_UIO_UI0
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;usbat_flash_check_media_present: no media detected&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USBAT_FLASH_MEDIA_NONE
suffix:semicolon
)brace
r_return
id|USBAT_FLASH_MEDIA_CF
suffix:semicolon
)brace
multiline_comment|/*&n; * Determine if media has changed since last operation&n; */
DECL|function|usbat_flash_check_media_changed
r_static
r_int
id|usbat_flash_check_media_changed
c_func
(paren
r_int
r_char
op_star
id|uio
)paren
(brace
r_if
c_cond
(paren
op_star
id|uio
op_amp
id|USBAT_UIO_0
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;usbat_flash_check_media_changed: media change detected&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USBAT_FLASH_MEDIA_CHANGED
suffix:semicolon
)brace
r_return
id|USBAT_FLASH_MEDIA_SAME
suffix:semicolon
)brace
multiline_comment|/*&n; * Check for media change / no media and handle the situation appropriately&n; */
DECL|function|usbat_flash_check_media
r_static
r_int
id|usbat_flash_check_media
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_struct
id|usbat_info
op_star
id|info
)paren
(brace
r_int
id|rc
suffix:semicolon
r_int
r_char
op_star
id|uio
op_assign
id|us-&gt;iobuf
suffix:semicolon
id|rc
op_assign
id|usbat_read_user_io
c_func
(paren
id|us
comma
id|uio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
singleline_comment|// Check for media existance
id|rc
op_assign
id|usbat_flash_check_media_present
c_func
(paren
id|uio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
id|USBAT_FLASH_MEDIA_NONE
)paren
(brace
id|info-&gt;sense_key
op_assign
l_int|0x02
suffix:semicolon
id|info-&gt;sense_asc
op_assign
l_int|0x3A
suffix:semicolon
id|info-&gt;sense_ascq
op_assign
l_int|0x00
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
singleline_comment|// Check for media change
id|rc
op_assign
id|usbat_flash_check_media_changed
c_func
(paren
id|uio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
id|USBAT_FLASH_MEDIA_CHANGED
)paren
(brace
singleline_comment|// Reset and re-enable card detect
id|rc
op_assign
id|usbat_device_reset
c_func
(paren
id|us
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|rc
suffix:semicolon
id|rc
op_assign
id|usbat_device_enable_cdt
c_func
(paren
id|us
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|rc
suffix:semicolon
id|msleep
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|rc
op_assign
id|usbat_read_user_io
c_func
(paren
id|us
comma
id|uio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|info-&gt;sense_key
op_assign
id|UNIT_ATTENTION
suffix:semicolon
id|info-&gt;sense_asc
op_assign
l_int|0x28
suffix:semicolon
id|info-&gt;sense_ascq
op_assign
l_int|0x00
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
multiline_comment|/*&n; * Determine whether we are controlling a flash-based reader/writer,&n; * or a HP8200-based CD drive.&n; * Sets transport functions as appropriate.&n; */
DECL|function|usbat_identify_device
r_static
r_int
id|usbat_identify_device
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_struct
id|usbat_info
op_star
id|info
)paren
(brace
r_int
id|rc
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|us
op_logical_or
op_logical_neg
id|info
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|rc
op_assign
id|usbat_device_reset
c_func
(paren
id|us
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/*&n;&t; * By examining the device signature after a reset, we can identify&n;&t; * whether the device supports the ATAPI packet interface.&n;&t; * The flash-devices do not support this, whereas the HP CDRW&squot;s obviously&n;&t; * do.&n;&t; *&n;&t; * This method is not ideal, but works because no other devices have been&n;&t; * produced based on the USBAT/USBAT02.&n;&t; *&n;&t; * Section 9.1 of the ATAPI-4 spec states (amongst other things) that&n;&t; * after a device reset, a Cylinder low of 0x14 indicates that the device&n;&t; * does support packet commands.&n;&t; */
id|rc
op_assign
id|usbat_read
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
id|USBAT_ATA_LBA_ME
comma
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;usbat_identify_device: Cylinder low is %02X&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
l_int|0x14
)paren
(brace
singleline_comment|// Device is HP 8200
id|US_DEBUGP
c_func
(paren
l_string|&quot;usbat_identify_device: Detected HP8200 CDRW&bslash;n&quot;
)paren
suffix:semicolon
id|info-&gt;devicetype
op_assign
id|USBAT_DEV_HP8200
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// Device is a CompactFlash reader/writer
id|US_DEBUGP
c_func
(paren
l_string|&quot;usbat_identify_device: Detected Flash reader/writer&bslash;n&quot;
)paren
suffix:semicolon
id|info-&gt;devicetype
op_assign
id|USBAT_DEV_FLASH
suffix:semicolon
)brace
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
multiline_comment|/*&n; * Set the transport function based on the device type&n; */
DECL|function|usbat_set_transport
r_static
r_int
id|usbat_set_transport
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_struct
id|usbat_info
op_star
id|info
)paren
(brace
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;devicetype
)paren
(brace
id|rc
op_assign
id|usbat_identify_device
c_func
(paren
id|us
comma
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;usbat_set_transport: Could not identify device&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|usbat_get_device_type
c_func
(paren
id|us
)paren
op_eq
id|USBAT_DEV_HP8200
)paren
id|us-&gt;transport
op_assign
id|usbat_hp8200e_transport
suffix:semicolon
r_else
r_if
c_cond
(paren
id|usbat_get_device_type
c_func
(paren
id|us
)paren
op_eq
id|USBAT_DEV_FLASH
)paren
id|us-&gt;transport
op_assign
id|usbat_flash_transport
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Read the media capacity&n; */
DECL|function|usbat_flash_get_sector_count
r_static
r_int
id|usbat_flash_get_sector_count
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_struct
id|usbat_info
op_star
id|info
)paren
(brace
r_int
r_char
id|registers
(braket
l_int|3
)braket
op_assign
(brace
id|USBAT_ATA_SECCNT
comma
id|USBAT_ATA_DEVICE
comma
id|USBAT_ATA_CMD
comma
)brace
suffix:semicolon
r_int
r_char
id|command
(braket
l_int|3
)braket
op_assign
(brace
l_int|0x01
comma
l_int|0xA0
comma
l_int|0xEC
)brace
suffix:semicolon
r_int
r_char
op_star
id|reply
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|us
op_logical_or
op_logical_neg
id|info
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|reply
op_assign
id|kmalloc
c_func
(paren
l_int|512
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reply
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
singleline_comment|// ATAPI command : IDENTIFY DEVICE
id|rc
op_assign
id|usbat_multiple_write
c_func
(paren
id|us
comma
id|registers
comma
id|command
comma
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_XFER_GOOD
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;usbat_flash_get_sector_count: Gah! identify_device failed&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_assign
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
r_goto
id|leave
suffix:semicolon
)brace
singleline_comment|// Read device status
r_if
c_cond
(paren
id|usbat_get_status
c_func
(paren
id|us
comma
op_amp
id|status
)paren
op_ne
id|USB_STOR_XFER_GOOD
)paren
(brace
id|rc
op_assign
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
r_goto
id|leave
suffix:semicolon
)brace
id|msleep
c_func
(paren
l_int|100
)paren
suffix:semicolon
singleline_comment|// Read the device identification data
id|rc
op_assign
id|usbat_read_block
c_func
(paren
id|us
comma
id|reply
comma
l_int|512
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_goto
id|leave
suffix:semicolon
id|info-&gt;sectors
op_assign
(paren
(paren
id|u32
)paren
(paren
id|reply
(braket
l_int|117
)braket
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|reply
(braket
l_int|116
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|reply
(braket
l_int|115
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|reply
(braket
l_int|114
)braket
)paren
)paren
suffix:semicolon
id|rc
op_assign
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
id|leave
suffix:colon
id|kfree
c_func
(paren
id|reply
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Read data from device&n; */
DECL|function|usbat_flash_read_data
r_static
r_int
id|usbat_flash_read_data
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_struct
id|usbat_info
op_star
id|info
comma
id|u32
id|sector
comma
id|u32
id|sectors
)paren
(brace
r_int
r_char
id|registers
(braket
l_int|7
)braket
op_assign
(brace
id|USBAT_ATA_FEATURES
comma
id|USBAT_ATA_SECCNT
comma
id|USBAT_ATA_SECNUM
comma
id|USBAT_ATA_LBA_ME
comma
id|USBAT_ATA_LBA_HI
comma
id|USBAT_ATA_DEVICE
comma
id|USBAT_ATA_STATUS
comma
)brace
suffix:semicolon
r_int
r_char
id|command
(braket
l_int|7
)braket
suffix:semicolon
r_int
r_char
op_star
id|buffer
suffix:semicolon
r_int
r_char
id|thistime
suffix:semicolon
r_int
r_int
id|totallen
comma
id|alloclen
suffix:semicolon
r_int
id|len
comma
id|result
suffix:semicolon
r_int
r_int
id|sg_idx
op_assign
l_int|0
comma
id|sg_offset
op_assign
l_int|0
suffix:semicolon
id|result
op_assign
id|usbat_flash_check_media
c_func
(paren
id|us
comma
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
singleline_comment|// we&squot;re working in LBA mode.  according to the ATA spec,
singleline_comment|// we can support up to 28-bit addressing.  I don&squot;t know if Jumpshot
singleline_comment|// supports beyond 24-bit addressing.  It&squot;s kind of hard to test
singleline_comment|// since it requires &gt; 8GB CF card.
r_if
c_cond
(paren
id|sector
OG
l_int|0x0FFFFFFF
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|totallen
op_assign
id|sectors
op_star
id|info-&gt;ssize
suffix:semicolon
singleline_comment|// Since we don&squot;t read more than 64 KB at a time, we have to create
singleline_comment|// a bounce buffer and move the data a piece at a time between the
singleline_comment|// bounce buffer and the actual transfer buffer.
id|alloclen
op_assign
id|min
c_func
(paren
id|totallen
comma
l_int|65536u
)paren
suffix:semicolon
id|buffer
op_assign
id|kmalloc
c_func
(paren
id|alloclen
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
op_eq
l_int|NULL
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
r_do
(brace
singleline_comment|// loop, never allocate or transfer more than 64k at once
singleline_comment|// (min(128k, 255*info-&gt;ssize) is the real limit)
id|len
op_assign
id|min
c_func
(paren
id|totallen
comma
id|alloclen
)paren
suffix:semicolon
id|thistime
op_assign
(paren
id|len
op_div
id|info-&gt;ssize
)paren
op_amp
l_int|0xff
suffix:semicolon
singleline_comment|// ATAPI command 0x20 (READ SECTORS)
id|usbat_pack_atapi_sector_cmd
c_func
(paren
id|command
comma
id|thistime
comma
id|sector
comma
l_int|0x20
)paren
suffix:semicolon
singleline_comment|// Write/execute ATAPI read command
id|result
op_assign
id|usbat_multiple_write
c_func
(paren
id|us
comma
id|registers
comma
id|command
comma
l_int|7
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_goto
id|leave
suffix:semicolon
singleline_comment|// Read the data we just requested
id|result
op_assign
id|usbat_read_blocks
c_func
(paren
id|us
comma
id|buffer
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_goto
id|leave
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;usbat_flash_read_data:  %d bytes&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
singleline_comment|// Store the data in the transfer buffer
id|usb_stor_access_xfer_buf
c_func
(paren
id|buffer
comma
id|len
comma
id|us-&gt;srb
comma
op_amp
id|sg_idx
comma
op_amp
id|sg_offset
comma
id|TO_XFER_BUF
)paren
suffix:semicolon
id|sector
op_add_assign
id|thistime
suffix:semicolon
id|totallen
op_sub_assign
id|len
suffix:semicolon
)brace
r_while
c_loop
(paren
id|totallen
OG
l_int|0
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
id|leave
suffix:colon
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/*&n; * Write data to device&n; */
DECL|function|usbat_flash_write_data
r_static
r_int
id|usbat_flash_write_data
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_struct
id|usbat_info
op_star
id|info
comma
id|u32
id|sector
comma
id|u32
id|sectors
)paren
(brace
r_int
r_char
id|registers
(braket
l_int|7
)braket
op_assign
(brace
id|USBAT_ATA_FEATURES
comma
id|USBAT_ATA_SECCNT
comma
id|USBAT_ATA_SECNUM
comma
id|USBAT_ATA_LBA_ME
comma
id|USBAT_ATA_LBA_HI
comma
id|USBAT_ATA_DEVICE
comma
id|USBAT_ATA_STATUS
comma
)brace
suffix:semicolon
r_int
r_char
id|command
(braket
l_int|7
)braket
suffix:semicolon
r_int
r_char
op_star
id|buffer
suffix:semicolon
r_int
r_char
id|thistime
suffix:semicolon
r_int
r_int
id|totallen
comma
id|alloclen
suffix:semicolon
r_int
id|len
comma
id|result
suffix:semicolon
r_int
r_int
id|sg_idx
op_assign
l_int|0
comma
id|sg_offset
op_assign
l_int|0
suffix:semicolon
id|result
op_assign
id|usbat_flash_check_media
c_func
(paren
id|us
comma
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|result
suffix:semicolon
singleline_comment|// we&squot;re working in LBA mode.  according to the ATA spec,
singleline_comment|// we can support up to 28-bit addressing.  I don&squot;t know if Jumpshot
singleline_comment|// supports beyond 24-bit addressing.  It&squot;s kind of hard to test
singleline_comment|// since it requires &gt; 8GB CF card.
r_if
c_cond
(paren
id|sector
OG
l_int|0x0FFFFFFF
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|totallen
op_assign
id|sectors
op_star
id|info-&gt;ssize
suffix:semicolon
singleline_comment|// Since we don&squot;t write more than 64 KB at a time, we have to create
singleline_comment|// a bounce buffer and move the data a piece at a time between the
singleline_comment|// bounce buffer and the actual transfer buffer.
id|alloclen
op_assign
id|min
c_func
(paren
id|totallen
comma
l_int|65536u
)paren
suffix:semicolon
id|buffer
op_assign
id|kmalloc
c_func
(paren
id|alloclen
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
op_eq
l_int|NULL
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
r_do
(brace
singleline_comment|// loop, never allocate or transfer more than 64k at once
singleline_comment|// (min(128k, 255*info-&gt;ssize) is the real limit)
id|len
op_assign
id|min
c_func
(paren
id|totallen
comma
id|alloclen
)paren
suffix:semicolon
id|thistime
op_assign
(paren
id|len
op_div
id|info-&gt;ssize
)paren
op_amp
l_int|0xff
suffix:semicolon
singleline_comment|// Get the data from the transfer buffer
id|usb_stor_access_xfer_buf
c_func
(paren
id|buffer
comma
id|len
comma
id|us-&gt;srb
comma
op_amp
id|sg_idx
comma
op_amp
id|sg_offset
comma
id|FROM_XFER_BUF
)paren
suffix:semicolon
singleline_comment|// ATAPI command 0x30 (WRITE SECTORS)
id|usbat_pack_atapi_sector_cmd
c_func
(paren
id|command
comma
id|thistime
comma
id|sector
comma
l_int|0x30
)paren
suffix:semicolon
singleline_comment|// Write/execute ATAPI write command
id|result
op_assign
id|usbat_multiple_write
c_func
(paren
id|us
comma
id|registers
comma
id|command
comma
l_int|7
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_goto
id|leave
suffix:semicolon
singleline_comment|// Write the data
id|result
op_assign
id|usbat_write_blocks
c_func
(paren
id|us
comma
id|buffer
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_goto
id|leave
suffix:semicolon
id|sector
op_add_assign
id|thistime
suffix:semicolon
id|totallen
op_sub_assign
id|len
suffix:semicolon
)brace
r_while
c_loop
(paren
id|totallen
OG
l_int|0
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
id|leave
suffix:colon
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
multiline_comment|/*&n; * Squeeze a potentially huge (&gt; 65535 byte) read10 command into&n; * a little ( &lt;= 65535 byte) ATAPI pipe&n; */
DECL|function|usbat_hp8200e_handle_read10
r_static
r_int
id|usbat_hp8200e_handle_read10
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|registers
comma
r_int
r_char
op_star
id|data
comma
r_struct
id|scsi_cmnd
op_star
id|srb
)paren
(brace
r_int
id|result
op_assign
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
r_int
r_char
op_star
id|buffer
suffix:semicolon
r_int
r_int
id|len
suffix:semicolon
r_int
r_int
id|sector
suffix:semicolon
r_int
r_int
id|sg_segment
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|sg_offset
op_assign
l_int|0
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;handle_read10: transfersize %d&bslash;n&quot;
comma
id|srb-&gt;transfersize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|srb-&gt;request_bufflen
OL
l_int|0x10000
)paren
(brace
id|result
op_assign
id|usbat_hp8200e_rw_block_test
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
id|registers
comma
id|data
comma
l_int|19
comma
id|USBAT_ATA_DATA
comma
id|USBAT_ATA_STATUS
comma
l_int|0xFD
comma
(paren
id|USBAT_QUAL_FCQ
op_or
id|USBAT_QUAL_ALQ
)paren
comma
id|DMA_FROM_DEVICE
comma
id|srb-&gt;request_buffer
comma
id|srb-&gt;request_bufflen
comma
id|srb-&gt;use_sg
comma
l_int|1
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Since we&squot;re requesting more data than we can handle in&n;&t; * a single read command (max is 64k-1), we will perform&n;&t; * multiple reads, but each read must be in multiples of&n;&t; * a sector.  Luckily the sector size is in srb-&gt;transfersize&n;&t; * (see linux/drivers/scsi/sr.c).&n;&t; */
r_if
c_cond
(paren
id|data
(braket
l_int|7
op_plus
l_int|0
)braket
op_eq
id|GPCMD_READ_CD
)paren
(brace
id|len
op_assign
id|short_pack
c_func
(paren
id|data
(braket
l_int|7
op_plus
l_int|9
)braket
comma
id|data
(braket
l_int|7
op_plus
l_int|8
)braket
)paren
suffix:semicolon
id|len
op_lshift_assign
l_int|16
suffix:semicolon
id|len
op_or_assign
id|data
(braket
l_int|7
op_plus
l_int|7
)braket
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;handle_read10: GPCMD_READ_CD: len %d&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
id|srb-&gt;transfersize
op_assign
id|srb-&gt;request_bufflen
op_div
id|len
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|srb-&gt;transfersize
)paren
(brace
id|srb-&gt;transfersize
op_assign
l_int|2048
suffix:semicolon
multiline_comment|/* A guess */
id|US_DEBUGP
c_func
(paren
l_string|&quot;handle_read10: transfersize 0, forcing %d&bslash;n&quot;
comma
id|srb-&gt;transfersize
)paren
suffix:semicolon
)brace
singleline_comment|// Since we only read in one block at a time, we have to create
singleline_comment|// a bounce buffer and move the data a piece at a time between the
singleline_comment|// bounce buffer and the actual transfer buffer.
id|len
op_assign
(paren
l_int|65535
op_div
id|srb-&gt;transfersize
)paren
op_star
id|srb-&gt;transfersize
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Max read is %d bytes&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
id|len
op_assign
id|min
c_func
(paren
id|len
comma
id|srb-&gt;request_bufflen
)paren
suffix:semicolon
id|buffer
op_assign
id|kmalloc
c_func
(paren
id|len
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
op_eq
l_int|NULL
)paren
singleline_comment|// bloody hell!
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
id|sector
op_assign
id|short_pack
c_func
(paren
id|data
(braket
l_int|7
op_plus
l_int|3
)braket
comma
id|data
(braket
l_int|7
op_plus
l_int|2
)braket
)paren
suffix:semicolon
id|sector
op_lshift_assign
l_int|16
suffix:semicolon
id|sector
op_or_assign
id|short_pack
c_func
(paren
id|data
(braket
l_int|7
op_plus
l_int|5
)braket
comma
id|data
(braket
l_int|7
op_plus
l_int|4
)braket
)paren
suffix:semicolon
id|transferred
op_assign
l_int|0
suffix:semicolon
id|sg_segment
op_assign
l_int|0
suffix:semicolon
singleline_comment|// for keeping track of where we are in
id|sg_offset
op_assign
l_int|0
suffix:semicolon
singleline_comment|// the scatter/gather list
r_while
c_loop
(paren
id|transferred
op_ne
id|srb-&gt;request_bufflen
)paren
(brace
r_if
c_cond
(paren
id|len
OG
id|srb-&gt;request_bufflen
op_minus
id|transferred
)paren
id|len
op_assign
id|srb-&gt;request_bufflen
op_minus
id|transferred
suffix:semicolon
id|data
(braket
l_int|3
)braket
op_assign
id|len
op_amp
l_int|0xFF
suffix:semicolon
singleline_comment|// (cylL) = expected length (L)
id|data
(braket
l_int|4
)braket
op_assign
(paren
id|len
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
suffix:semicolon
singleline_comment|// (cylH) = expected length (H)
singleline_comment|// Fix up the SCSI command sector and num sectors
id|data
(braket
l_int|7
op_plus
l_int|2
)braket
op_assign
id|MSB_of
c_func
(paren
id|sector
op_rshift
l_int|16
)paren
suffix:semicolon
singleline_comment|// SCSI command sector
id|data
(braket
l_int|7
op_plus
l_int|3
)braket
op_assign
id|LSB_of
c_func
(paren
id|sector
op_rshift
l_int|16
)paren
suffix:semicolon
id|data
(braket
l_int|7
op_plus
l_int|4
)braket
op_assign
id|MSB_of
c_func
(paren
id|sector
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
id|data
(braket
l_int|7
op_plus
l_int|5
)braket
op_assign
id|LSB_of
c_func
(paren
id|sector
op_amp
l_int|0xFFFF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
(braket
l_int|7
op_plus
l_int|0
)braket
op_eq
id|GPCMD_READ_CD
)paren
id|data
(braket
l_int|7
op_plus
l_int|6
)braket
op_assign
l_int|0
suffix:semicolon
id|data
(braket
l_int|7
op_plus
l_int|7
)braket
op_assign
id|MSB_of
c_func
(paren
id|len
op_div
id|srb-&gt;transfersize
)paren
suffix:semicolon
singleline_comment|// SCSI command
id|data
(braket
l_int|7
op_plus
l_int|8
)braket
op_assign
id|LSB_of
c_func
(paren
id|len
op_div
id|srb-&gt;transfersize
)paren
suffix:semicolon
singleline_comment|// num sectors
id|result
op_assign
id|usbat_hp8200e_rw_block_test
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
id|registers
comma
id|data
comma
l_int|19
comma
id|USBAT_ATA_DATA
comma
id|USBAT_ATA_STATUS
comma
l_int|0xFD
comma
(paren
id|USBAT_QUAL_FCQ
op_or
id|USBAT_QUAL_ALQ
)paren
comma
id|DMA_FROM_DEVICE
comma
id|buffer
comma
id|len
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_break
suffix:semicolon
singleline_comment|// Store the data in the transfer buffer
id|usb_stor_access_xfer_buf
c_func
(paren
id|buffer
comma
id|len
comma
id|srb
comma
op_amp
id|sg_segment
comma
op_amp
id|sg_offset
comma
id|TO_XFER_BUF
)paren
suffix:semicolon
singleline_comment|// Update the amount transferred and the sector number
id|transferred
op_add_assign
id|len
suffix:semicolon
id|sector
op_add_assign
id|len
op_div
id|srb-&gt;transfersize
suffix:semicolon
)brace
singleline_comment|// while transferred != srb-&gt;request_bufflen
id|kfree
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|usbat_select_and_test_registers
r_static
r_int
id|usbat_select_and_test_registers
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|selector
suffix:semicolon
r_int
r_char
op_star
id|status
op_assign
id|us-&gt;iobuf
suffix:semicolon
r_int
r_char
id|max_selector
op_assign
l_int|0xB0
suffix:semicolon
r_if
c_cond
(paren
id|usbat_get_device_type
c_func
(paren
id|us
)paren
op_eq
id|USBAT_DEV_FLASH
)paren
id|max_selector
op_assign
l_int|0xA0
suffix:semicolon
singleline_comment|// try device = master, then device = slave.
r_for
c_loop
(paren
id|selector
op_assign
l_int|0xA0
suffix:semicolon
id|selector
op_le
id|max_selector
suffix:semicolon
id|selector
op_add_assign
l_int|0x10
)paren
(brace
r_if
c_cond
(paren
id|usbat_get_device_type
c_func
(paren
id|us
)paren
op_eq
id|USBAT_DEV_HP8200
op_logical_and
id|usbat_write
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
id|USBAT_ATA_DEVICE
comma
id|selector
)paren
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|usbat_read
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
id|USBAT_ATA_STATUS
comma
id|status
)paren
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|usbat_read
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
id|USBAT_ATA_DEVICE
comma
id|status
)paren
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|usbat_read
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
id|USBAT_ATA_LBA_ME
comma
id|status
)paren
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|usbat_read
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
id|USBAT_ATA_LBA_HI
comma
id|status
)paren
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|usbat_write
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
id|USBAT_ATA_LBA_ME
comma
l_int|0x55
)paren
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|usbat_write
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
id|USBAT_ATA_LBA_HI
comma
l_int|0xAA
)paren
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|usbat_read
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
id|USBAT_ATA_LBA_ME
comma
id|status
)paren
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|usbat_read
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
id|USBAT_ATA_LBA_ME
comma
id|status
)paren
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize the USBAT processor and the storage device&n; */
DECL|function|init_usbat
r_int
id|init_usbat
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|rc
suffix:semicolon
r_struct
id|usbat_info
op_star
id|info
suffix:semicolon
r_int
r_char
id|subcountH
op_assign
id|USBAT_ATA_LBA_HI
suffix:semicolon
r_int
r_char
id|subcountL
op_assign
id|USBAT_ATA_LBA_ME
suffix:semicolon
r_int
r_char
op_star
id|status
op_assign
id|us-&gt;iobuf
suffix:semicolon
id|us-&gt;extra
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|usbat_info
)paren
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|us-&gt;extra
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;init_usbat: Gah! Can&squot;t allocate storage for usbat info struct!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|memset
c_func
(paren
id|us-&gt;extra
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|usbat_info
)paren
)paren
suffix:semicolon
id|info
op_assign
(paren
r_struct
id|usbat_info
op_star
)paren
(paren
id|us-&gt;extra
)paren
suffix:semicolon
singleline_comment|// Enable peripheral control signals
id|rc
op_assign
id|usbat_write_user_io
c_func
(paren
id|us
comma
id|USBAT_UIO_OE1
op_or
id|USBAT_UIO_OE0
comma
id|USBAT_UIO_EPAD
op_or
id|USBAT_UIO_1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;INIT 1&bslash;n&quot;
)paren
suffix:semicolon
id|msleep
c_func
(paren
l_int|2000
)paren
suffix:semicolon
id|rc
op_assign
id|usbat_read_user_io
c_func
(paren
id|us
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|rc
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;INIT 2&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_assign
id|usbat_read_user_io
c_func
(paren
id|us
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|rc
op_assign
id|usbat_read_user_io
c_func
(paren
id|us
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;INIT 3&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|// At this point, we need to detect which device we are using
r_if
c_cond
(paren
id|usbat_set_transport
c_func
(paren
id|us
comma
id|info
)paren
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;INIT 4&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usbat_get_device_type
c_func
(paren
id|us
)paren
op_eq
id|USBAT_DEV_HP8200
)paren
(brace
id|msleep
c_func
(paren
l_int|250
)paren
suffix:semicolon
singleline_comment|// Write 0x80 to ISA port 0x3F
id|rc
op_assign
id|usbat_write
c_func
(paren
id|us
comma
id|USBAT_ISA
comma
l_int|0x3F
comma
l_int|0x80
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;INIT 5&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|// Read ISA port 0x27
id|rc
op_assign
id|usbat_read
c_func
(paren
id|us
comma
id|USBAT_ISA
comma
l_int|0x27
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;INIT 6&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_assign
id|usbat_read_user_io
c_func
(paren
id|us
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;INIT 7&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|rc
op_assign
id|usbat_select_and_test_registers
c_func
(paren
id|us
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|rc
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;INIT 8&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_assign
id|usbat_read_user_io
c_func
(paren
id|us
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;INIT 9&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|// Enable peripheral control signals and card detect
id|rc
op_assign
id|usbat_device_enable_cdt
c_func
(paren
id|us
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|rc
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;INIT 10&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_assign
id|usbat_read_user_io
c_func
(paren
id|us
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;INIT 11&bslash;n&quot;
)paren
suffix:semicolon
id|msleep
c_func
(paren
l_int|1400
)paren
suffix:semicolon
id|rc
op_assign
id|usbat_read_user_io
c_func
(paren
id|us
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;INIT 12&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_assign
id|usbat_select_and_test_registers
c_func
(paren
id|us
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|rc
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;INIT 13&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usbat_get_device_type
c_func
(paren
id|us
)paren
op_eq
id|USBAT_DEV_FLASH
)paren
(brace
id|subcountH
op_assign
l_int|0x02
suffix:semicolon
id|subcountL
op_assign
l_int|0x00
suffix:semicolon
)brace
id|rc
op_assign
id|usbat_set_shuttle_features
c_func
(paren
id|us
comma
(paren
id|USBAT_FEAT_ETEN
op_or
id|USBAT_FEAT_ET2
op_or
id|USBAT_FEAT_ET1
)paren
comma
l_int|0x00
comma
l_int|0x88
comma
l_int|0x08
comma
id|subcountH
comma
id|subcountL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;INIT 14&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
multiline_comment|/*&n; * Transport for the HP 8200e&n; */
DECL|function|usbat_hp8200e_transport
r_static
r_int
id|usbat_hp8200e_transport
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_char
op_star
id|status
op_assign
id|us-&gt;iobuf
suffix:semicolon
r_int
r_char
id|registers
(braket
l_int|32
)braket
suffix:semicolon
r_int
r_char
id|data
(braket
l_int|32
)braket
suffix:semicolon
r_int
r_int
id|len
suffix:semicolon
r_int
id|i
suffix:semicolon
r_char
id|string
(braket
l_int|64
)braket
suffix:semicolon
id|len
op_assign
id|srb-&gt;request_bufflen
suffix:semicolon
multiline_comment|/* Send A0 (ATA PACKET COMMAND).&n;&t;   Note: I guess we&squot;re never going to get any of the ATA&n;&t;   commands... just ATA Packet Commands.&n; &t; */
id|registers
(braket
l_int|0
)braket
op_assign
id|USBAT_ATA_FEATURES
suffix:semicolon
id|registers
(braket
l_int|1
)braket
op_assign
id|USBAT_ATA_SECCNT
suffix:semicolon
id|registers
(braket
l_int|2
)braket
op_assign
id|USBAT_ATA_SECNUM
suffix:semicolon
id|registers
(braket
l_int|3
)braket
op_assign
id|USBAT_ATA_LBA_ME
suffix:semicolon
id|registers
(braket
l_int|4
)braket
op_assign
id|USBAT_ATA_LBA_HI
suffix:semicolon
id|registers
(braket
l_int|5
)braket
op_assign
id|USBAT_ATA_DEVICE
suffix:semicolon
id|registers
(braket
l_int|6
)braket
op_assign
id|USBAT_ATA_CMD
suffix:semicolon
id|data
(braket
l_int|0
)braket
op_assign
l_int|0x00
suffix:semicolon
id|data
(braket
l_int|1
)braket
op_assign
l_int|0x00
suffix:semicolon
id|data
(braket
l_int|2
)braket
op_assign
l_int|0x00
suffix:semicolon
id|data
(braket
l_int|3
)braket
op_assign
id|len
op_amp
l_int|0xFF
suffix:semicolon
singleline_comment|// (cylL) = expected length (L)
id|data
(braket
l_int|4
)braket
op_assign
(paren
id|len
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
suffix:semicolon
singleline_comment|// (cylH) = expected length (H)
id|data
(braket
l_int|5
)braket
op_assign
l_int|0xB0
suffix:semicolon
singleline_comment|// (device sel) = slave
id|data
(braket
l_int|6
)braket
op_assign
l_int|0xA0
suffix:semicolon
singleline_comment|// (command) = ATA PACKET COMMAND
r_for
c_loop
(paren
id|i
op_assign
l_int|7
suffix:semicolon
id|i
OL
l_int|19
suffix:semicolon
id|i
op_increment
)paren
(brace
id|registers
(braket
id|i
)braket
op_assign
l_int|0x10
suffix:semicolon
id|data
(braket
id|i
)braket
op_assign
(paren
id|i
op_minus
l_int|7
op_ge
id|srb-&gt;cmd_len
)paren
ques
c_cond
l_int|0
suffix:colon
id|srb-&gt;cmnd
(braket
id|i
op_minus
l_int|7
)braket
suffix:semicolon
)brace
id|result
op_assign
id|usbat_get_status
c_func
(paren
id|us
comma
id|status
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Status = %02X&bslash;n&quot;
comma
op_star
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
id|USB_STOR_XFER_GOOD
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|TEST_UNIT_READY
)paren
id|transferred
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|srb-&gt;sc_data_direction
op_eq
id|DMA_TO_DEVICE
)paren
(brace
id|result
op_assign
id|usbat_hp8200e_rw_block_test
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
id|registers
comma
id|data
comma
l_int|19
comma
id|USBAT_ATA_DATA
comma
id|USBAT_ATA_STATUS
comma
l_int|0xFD
comma
(paren
id|USBAT_QUAL_FCQ
op_or
id|USBAT_QUAL_ALQ
)paren
comma
id|DMA_TO_DEVICE
comma
id|srb-&gt;request_buffer
comma
id|len
comma
id|srb-&gt;use_sg
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
id|transferred
op_add_assign
id|len
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Wrote %08X bytes&bslash;n&quot;
comma
id|transferred
)paren
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|READ_10
op_logical_or
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|GPCMD_READ_CD
)paren
(brace
r_return
id|usbat_hp8200e_handle_read10
c_func
(paren
id|us
comma
id|registers
comma
id|data
comma
id|srb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
l_int|0xFFFF
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Error: len = %08X... what do I do now?&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|result
op_assign
id|usbat_multiple_write
c_func
(paren
id|us
comma
id|registers
comma
id|data
comma
l_int|7
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
r_return
id|result
suffix:semicolon
)brace
singleline_comment|// Write the 12-byte command header.
singleline_comment|// If the command is BLANK then set the timer for 75 minutes.
singleline_comment|// Otherwise set it for 10 minutes.
singleline_comment|// NOTE: THE 8200 DOCUMENTATION STATES THAT BLANKING A CDRW
singleline_comment|// AT SPEED 4 IS UNRELIABLE!!!
r_if
c_cond
(paren
(paren
id|result
op_assign
id|usbat_write_block
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
id|srb-&gt;cmnd
comma
l_int|12
comma
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|GPCMD_BLANK
ques
c_cond
l_int|75
suffix:colon
l_int|10
)paren
)paren
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
(brace
r_return
id|result
suffix:semicolon
)brace
singleline_comment|// If there is response data to be read in 
singleline_comment|// then do it here.
r_if
c_cond
(paren
id|len
op_ne
l_int|0
op_logical_and
(paren
id|srb-&gt;sc_data_direction
op_eq
id|DMA_FROM_DEVICE
)paren
)paren
(brace
singleline_comment|// How many bytes to read in? Check cylL register
r_if
c_cond
(paren
id|usbat_read
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
id|USBAT_ATA_LBA_ME
comma
id|status
)paren
op_ne
id|USB_STOR_XFER_GOOD
)paren
(brace
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OG
l_int|0xFF
)paren
(brace
singleline_comment|// need to read cylH also
id|len
op_assign
op_star
id|status
suffix:semicolon
r_if
c_cond
(paren
id|usbat_read
c_func
(paren
id|us
comma
id|USBAT_ATA
comma
id|USBAT_ATA_LBA_HI
comma
id|status
)paren
op_ne
id|USB_STOR_XFER_GOOD
)paren
(brace
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
id|len
op_add_assign
(paren
(paren
r_int
r_int
)paren
op_star
id|status
)paren
op_lshift
l_int|8
suffix:semicolon
)brace
r_else
id|len
op_assign
op_star
id|status
suffix:semicolon
id|result
op_assign
id|usbat_read_block
c_func
(paren
id|us
comma
id|srb-&gt;request_buffer
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* Debug-print the first 32 bytes of the transfer */
r_if
c_cond
(paren
op_logical_neg
id|srb-&gt;use_sg
)paren
(brace
id|string
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
op_logical_and
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|string
op_plus
id|strlen
c_func
(paren
id|string
)paren
comma
l_string|&quot;%02X &quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|srb-&gt;request_buffer
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|16
)paren
op_eq
l_int|15
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|string
)paren
suffix:semicolon
id|string
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|string
(braket
l_int|0
)braket
op_ne
l_int|0
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|string
)paren
suffix:semicolon
)brace
)brace
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Transport for USBAT02-based CompactFlash and similar storage devices&n; */
DECL|function|usbat_flash_transport
r_static
r_int
id|usbat_flash_transport
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|rc
suffix:semicolon
r_struct
id|usbat_info
op_star
id|info
op_assign
(paren
r_struct
id|usbat_info
op_star
)paren
(paren
id|us-&gt;extra
)paren
suffix:semicolon
r_int
r_int
id|block
comma
id|blocks
suffix:semicolon
r_int
r_char
op_star
id|ptr
op_assign
id|us-&gt;iobuf
suffix:semicolon
r_static
r_int
r_char
id|inquiry_response
(braket
l_int|36
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0x80
comma
l_int|0x00
comma
l_int|0x01
comma
l_int|0x1F
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;usbat_flash_transport: INQUIRY. Returning bogus response.&bslash;n&quot;
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
comma
id|inquiry_response
comma
r_sizeof
(paren
id|inquiry_response
)paren
)paren
suffix:semicolon
id|fill_inquiry_response
c_func
(paren
id|us
comma
id|ptr
comma
l_int|36
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|READ_CAPACITY
)paren
(brace
id|rc
op_assign
id|usbat_flash_check_media
c_func
(paren
id|us
comma
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|rc
suffix:semicolon
id|rc
op_assign
id|usbat_flash_get_sector_count
c_func
(paren
id|us
comma
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|rc
suffix:semicolon
id|info-&gt;ssize
op_assign
l_int|0x200
suffix:semicolon
singleline_comment|// hard coded 512 byte sectors as per ATA spec
id|US_DEBUGP
c_func
(paren
l_string|&quot;usbat_flash_transport: READ_CAPACITY: %ld sectors, %ld bytes per sector&bslash;n&quot;
comma
id|info-&gt;sectors
comma
id|info-&gt;ssize
)paren
suffix:semicolon
singleline_comment|// build the reply
singleline_comment|// note: must return the sector number of the last sector,
singleline_comment|// *not* the total number of sectors
(paren
(paren
id|__be32
op_star
)paren
id|ptr
)paren
(braket
l_int|0
)braket
op_assign
id|cpu_to_be32
c_func
(paren
id|info-&gt;sectors
op_minus
l_int|1
)paren
suffix:semicolon
(paren
(paren
id|__be32
op_star
)paren
id|ptr
)paren
(braket
l_int|1
)braket
op_assign
id|cpu_to_be32
c_func
(paren
id|info-&gt;ssize
)paren
suffix:semicolon
id|usb_stor_set_xfer_buf
c_func
(paren
id|ptr
comma
l_int|8
comma
id|srb
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|MODE_SELECT_10
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;usbat_flash_transport:  Gah! MODE_SELECT_10.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|READ_10
)paren
(brace
id|block
op_assign
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|2
)braket
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|3
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|4
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|5
)braket
)paren
)paren
suffix:semicolon
id|blocks
op_assign
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|7
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|8
)braket
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;usbat_flash_transport:  READ_10: read block 0x%04lx  count %ld&bslash;n&quot;
comma
id|block
comma
id|blocks
)paren
suffix:semicolon
r_return
id|usbat_flash_read_data
c_func
(paren
id|us
comma
id|info
comma
id|block
comma
id|blocks
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|READ_12
)paren
(brace
singleline_comment|// I don&squot;t think we&squot;ll ever see a READ_12 but support it anyway...
id|block
op_assign
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|2
)braket
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|3
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|4
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|5
)braket
)paren
)paren
suffix:semicolon
id|blocks
op_assign
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|6
)braket
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|7
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|8
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|9
)braket
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;usbat_flash_transport: READ_12: read block 0x%04lx  count %ld&bslash;n&quot;
comma
id|block
comma
id|blocks
)paren
suffix:semicolon
r_return
id|usbat_flash_read_data
c_func
(paren
id|us
comma
id|info
comma
id|block
comma
id|blocks
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|WRITE_10
)paren
(brace
id|block
op_assign
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|2
)braket
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|3
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|4
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|5
)braket
)paren
)paren
suffix:semicolon
id|blocks
op_assign
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|7
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|8
)braket
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;usbat_flash_transport: WRITE_10: write block 0x%04lx  count %ld&bslash;n&quot;
comma
id|block
comma
id|blocks
)paren
suffix:semicolon
r_return
id|usbat_flash_write_data
c_func
(paren
id|us
comma
id|info
comma
id|block
comma
id|blocks
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|WRITE_12
)paren
(brace
singleline_comment|// I don&squot;t think we&squot;ll ever see a WRITE_12 but support it anyway...
id|block
op_assign
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|2
)braket
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|3
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|4
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|5
)braket
)paren
)paren
suffix:semicolon
id|blocks
op_assign
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|6
)braket
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|7
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|8
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|u32
)paren
(paren
id|srb-&gt;cmnd
(braket
l_int|9
)braket
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;usbat_flash_transport: WRITE_12: write block 0x%04lx  count %ld&bslash;n&quot;
comma
id|block
comma
id|blocks
)paren
suffix:semicolon
r_return
id|usbat_flash_write_data
c_func
(paren
id|us
comma
id|info
comma
id|block
comma
id|blocks
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|TEST_UNIT_READY
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;usbat_flash_transport: TEST_UNIT_READY.&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_assign
id|usbat_flash_check_media
c_func
(paren
id|us
comma
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|USB_STOR_TRANSPORT_GOOD
)paren
r_return
id|rc
suffix:semicolon
r_return
id|usbat_check_status
c_func
(paren
id|us
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;usbat_flash_transport: REQUEST_SENSE.&bslash;n&quot;
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ptr
comma
l_int|0
comma
l_int|18
)paren
suffix:semicolon
id|ptr
(braket
l_int|0
)braket
op_assign
l_int|0xF0
suffix:semicolon
id|ptr
(braket
l_int|2
)braket
op_assign
id|info-&gt;sense_key
suffix:semicolon
id|ptr
(braket
l_int|7
)braket
op_assign
l_int|11
suffix:semicolon
id|ptr
(braket
l_int|12
)braket
op_assign
id|info-&gt;sense_asc
suffix:semicolon
id|ptr
(braket
l_int|13
)braket
op_assign
id|info-&gt;sense_ascq
suffix:semicolon
id|usb_stor_set_xfer_buf
c_func
(paren
id|ptr
comma
l_int|18
comma
id|srb
)paren
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|ALLOW_MEDIUM_REMOVAL
)paren
(brace
singleline_comment|// sure.  whatever.  not like we can stop the user from popping
singleline_comment|// the media out of the device (no locking doors, etc)
r_return
id|USB_STOR_TRANSPORT_GOOD
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;usbat_flash_transport: Gah! Unknown command: %d (0x%x)&bslash;n&quot;
comma
id|srb-&gt;cmnd
(braket
l_int|0
)braket
comma
id|srb-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|info-&gt;sense_key
op_assign
l_int|0x05
suffix:semicolon
id|info-&gt;sense_asc
op_assign
l_int|0x20
suffix:semicolon
id|info-&gt;sense_ascq
op_assign
l_int|0x00
suffix:semicolon
r_return
id|USB_STOR_TRANSPORT_FAILED
suffix:semicolon
)brace
multiline_comment|/*&n; * Default transport function. Attempts to detect which transport function&n; * should be called, makes it the new default, and calls it.&n; *&n; * This function should never be called. Our usbat_init() function detects the&n; * device type and changes the us-&gt;transport ptr to the transport function&n; * relevant to the device.&n; * However, we&squot;ll support this impossible(?) case anyway.&n; */
DECL|function|usbat_transport
r_int
id|usbat_transport
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|srb
comma
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_struct
id|usbat_info
op_star
id|info
op_assign
(paren
r_struct
id|usbat_info
op_star
)paren
(paren
id|us-&gt;extra
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usbat_set_transport
c_func
(paren
id|us
comma
id|info
)paren
)paren
r_return
id|USB_STOR_TRANSPORT_ERROR
suffix:semicolon
r_return
id|us
op_member_access_from_pointer
id|transport
c_func
(paren
id|srb
comma
id|us
)paren
suffix:semicolon
)brace
eof
