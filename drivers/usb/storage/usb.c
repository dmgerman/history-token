multiline_comment|/* Driver for USB Mass Storage compliant devices&n; *&n; * $Id: usb.c,v 1.75 2002/04/22 03:39:43 mdharm Exp $&n; *&n; * Current development and maintenance by:&n; *   (c) 1999-2003 Matthew Dharm (mdharm-usb@one-eyed-alien.net)&n; *&n; * Developed with the assistance of:&n; *   (c) 2000 David L. Brown, Jr. (usb-storage@davidb.org)&n; *   (c) 2003 Alan Stern (stern@rowland.harvard.edu)&n; *&n; * Initial work by:&n; *   (c) 1999 Michael Gee (michael@linuxspecific.com)&n; *&n; * usb_device_id support by Adam J. Richter (adam@yggdrasil.com):&n; *   (c) 2000 Yggdrasil Computing, Inc.&n; *&n; * This driver is based on the &squot;USB Mass Storage Class&squot; document. This&n; * describes in detail the protocol used to communicate with such&n; * devices.  Clearly, the designers had SCSI and ATAPI commands in&n; * mind when they created this document.  The commands are all very&n; * similar to commands in the SCSI-II and ATAPI specifications.&n; *&n; * It is important to note that in a number of cases this class&n; * exhibits class-specific exemptions from the USB specification.&n; * Notably the usage of NAK, STALL and ACK differs from the norm, in&n; * that they are used to communicate wait, failed and OK on commands.&n; *&n; * Also, for certain devices, the interrupt endpoint is used to convey&n; * status of a command.&n; *&n; * Please see http://www.one-eyed-alien.net/~mdharm/linux-usb for more&n; * information about this driver.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2, or (at your option) any&n; * later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write to the Free Software Foundation, Inc.,&n; * 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/suspend.h&gt;
macro_line|#include &lt;scsi/scsi.h&gt;
macro_line|#include &lt;scsi/scsi_cmnd.h&gt;
macro_line|#include &lt;scsi/scsi_device.h&gt;
macro_line|#include &quot;usb.h&quot;
macro_line|#include &quot;scsiglue.h&quot;
macro_line|#include &quot;transport.h&quot;
macro_line|#include &quot;protocol.h&quot;
macro_line|#include &quot;debug.h&quot;
macro_line|#include &quot;initializers.h&quot;
macro_line|#ifdef CONFIG_USB_STORAGE_HP8200e
macro_line|#include &quot;shuttle_usbat.h&quot;
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_SDDR09
macro_line|#include &quot;sddr09.h&quot;
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_SDDR55
macro_line|#include &quot;sddr55.h&quot;
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_DPCM
macro_line|#include &quot;dpcm.h&quot;
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_FREECOM
macro_line|#include &quot;freecom.h&quot;
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_ISD200
macro_line|#include &quot;isd200.h&quot;
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_DATAFAB
macro_line|#include &quot;datafab.h&quot;
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_JUMPSHOT
macro_line|#include &quot;jumpshot.h&quot;
macro_line|#endif
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
multiline_comment|/* Some informational data */
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;USB Mass Storage driver for Linux&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|variable|delay_use
r_static
r_int
r_int
id|delay_use
op_assign
l_int|5
suffix:semicolon
id|module_param
c_func
(paren
id|delay_use
comma
id|uint
comma
id|S_IRUGO
op_or
id|S_IWUSR
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|delay_use
comma
l_string|&quot;seconds to delay before using a new device&quot;
)paren
suffix:semicolon
r_static
r_int
id|storage_probe
c_func
(paren
r_struct
id|usb_interface
op_star
id|iface
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
suffix:semicolon
r_static
r_void
id|storage_disconnect
c_func
(paren
r_struct
id|usb_interface
op_star
id|iface
)paren
suffix:semicolon
multiline_comment|/* The entries in this table, except for final ones here&n; * (USB_MASS_STORAGE_CLASS and the empty entry), correspond,&n; * line for line with the entries of us_unsuaul_dev_list[].&n; */
DECL|macro|UNUSUAL_DEV
mdefine_line|#define UNUSUAL_DEV(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax, &bslash;&n;&t;&t;    vendorName, productName,useProtocol, useTransport, &bslash;&n;&t;&t;    initFunction, flags) &bslash;&n;{ USB_DEVICE_VER(id_vendor, id_product, bcdDeviceMin,bcdDeviceMax) }
DECL|variable|storage_usb_ids
r_static
r_struct
id|usb_device_id
id|storage_usb_ids
(braket
)braket
op_assign
(brace
macro_line|#&t;include &quot;unusual_devs.h&quot;
DECL|macro|UNUSUAL_DEV
macro_line|#undef UNUSUAL_DEV
multiline_comment|/* Control/Bulk transport for all SubClass values */
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_RBC
comma
id|US_PR_CB
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_8020
comma
id|US_PR_CB
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_QIC
comma
id|US_PR_CB
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_UFI
comma
id|US_PR_CB
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_8070
comma
id|US_PR_CB
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_SCSI
comma
id|US_PR_CB
)paren
)brace
comma
multiline_comment|/* Control/Bulk/Interrupt transport for all SubClass values */
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_RBC
comma
id|US_PR_CBI
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_8020
comma
id|US_PR_CBI
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_QIC
comma
id|US_PR_CBI
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_UFI
comma
id|US_PR_CBI
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_8070
comma
id|US_PR_CBI
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_SCSI
comma
id|US_PR_CBI
)paren
)brace
comma
multiline_comment|/* Bulk-only transport for all SubClass values */
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_RBC
comma
id|US_PR_BULK
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_8020
comma
id|US_PR_BULK
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_QIC
comma
id|US_PR_BULK
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_UFI
comma
id|US_PR_BULK
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_8070
comma
id|US_PR_BULK
)paren
)brace
comma
macro_line|#if !defined(CONFIG_BLK_DEV_UB) &amp;&amp; !defined(CONFIG_BLK_DEV_UB_MODULE)
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_SCSI
comma
id|US_PR_BULK
)paren
)brace
comma
macro_line|#endif
multiline_comment|/* Terminating entry */
(brace
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
(paren
id|usb
comma
id|storage_usb_ids
)paren
suffix:semicolon
multiline_comment|/* This is the list of devices we recognize, along with their flag data */
multiline_comment|/* The vendor name should be kept at eight characters or less, and&n; * the product name should be kept at 16 characters or less. If a device&n; * has the US_FL_FIX_INQUIRY flag, then the vendor and product names&n; * normally generated by a device thorugh the INQUIRY response will be&n; * taken from this list, and this is the reason for the above size&n; * restriction. However, if the flag is not present, then you&n; * are free to use as many characters as you like.&n; */
DECL|macro|UNUSUAL_DEV
macro_line|#undef UNUSUAL_DEV
DECL|macro|UNUSUAL_DEV
mdefine_line|#define UNUSUAL_DEV(idVendor, idProduct, bcdDeviceMin, bcdDeviceMax, &bslash;&n;&t;&t;    vendor_name, product_name, use_protocol, use_transport, &bslash;&n;&t;&t;    init_function, Flags) &bslash;&n;{ &bslash;&n;&t;.vendorName = vendor_name,&t;&bslash;&n;&t;.productName = product_name,&t;&bslash;&n;&t;.useProtocol = use_protocol,&t;&bslash;&n;&t;.useTransport = use_transport,&t;&bslash;&n;&t;.initFunction = init_function,&t;&bslash;&n;&t;.flags = Flags, &bslash;&n;}
DECL|variable|us_unusual_dev_list
r_static
r_struct
id|us_unusual_dev
id|us_unusual_dev_list
(braket
)braket
op_assign
(brace
macro_line|#&t;include &quot;unusual_devs.h&quot; 
DECL|macro|UNUSUAL_DEV
macro_line|#&t;undef UNUSUAL_DEV
multiline_comment|/* Control/Bulk transport for all SubClass values */
(brace
dot
id|useProtocol
op_assign
id|US_SC_RBC
comma
dot
id|useTransport
op_assign
id|US_PR_CB
)brace
comma
(brace
dot
id|useProtocol
op_assign
id|US_SC_8020
comma
dot
id|useTransport
op_assign
id|US_PR_CB
)brace
comma
(brace
dot
id|useProtocol
op_assign
id|US_SC_QIC
comma
dot
id|useTransport
op_assign
id|US_PR_CB
)brace
comma
(brace
dot
id|useProtocol
op_assign
id|US_SC_UFI
comma
dot
id|useTransport
op_assign
id|US_PR_CB
)brace
comma
(brace
dot
id|useProtocol
op_assign
id|US_SC_8070
comma
dot
id|useTransport
op_assign
id|US_PR_CB
)brace
comma
(brace
dot
id|useProtocol
op_assign
id|US_SC_SCSI
comma
dot
id|useTransport
op_assign
id|US_PR_CB
)brace
comma
multiline_comment|/* Control/Bulk/Interrupt transport for all SubClass values */
(brace
dot
id|useProtocol
op_assign
id|US_SC_RBC
comma
dot
id|useTransport
op_assign
id|US_PR_CBI
)brace
comma
(brace
dot
id|useProtocol
op_assign
id|US_SC_8020
comma
dot
id|useTransport
op_assign
id|US_PR_CBI
)brace
comma
(brace
dot
id|useProtocol
op_assign
id|US_SC_QIC
comma
dot
id|useTransport
op_assign
id|US_PR_CBI
)brace
comma
(brace
dot
id|useProtocol
op_assign
id|US_SC_UFI
comma
dot
id|useTransport
op_assign
id|US_PR_CBI
)brace
comma
(brace
dot
id|useProtocol
op_assign
id|US_SC_8070
comma
dot
id|useTransport
op_assign
id|US_PR_CBI
)brace
comma
(brace
dot
id|useProtocol
op_assign
id|US_SC_SCSI
comma
dot
id|useTransport
op_assign
id|US_PR_CBI
)brace
comma
multiline_comment|/* Bulk-only transport for all SubClass values */
(brace
dot
id|useProtocol
op_assign
id|US_SC_RBC
comma
dot
id|useTransport
op_assign
id|US_PR_BULK
)brace
comma
(brace
dot
id|useProtocol
op_assign
id|US_SC_8020
comma
dot
id|useTransport
op_assign
id|US_PR_BULK
)brace
comma
(brace
dot
id|useProtocol
op_assign
id|US_SC_QIC
comma
dot
id|useTransport
op_assign
id|US_PR_BULK
)brace
comma
(brace
dot
id|useProtocol
op_assign
id|US_SC_UFI
comma
dot
id|useTransport
op_assign
id|US_PR_BULK
)brace
comma
(brace
dot
id|useProtocol
op_assign
id|US_SC_8070
comma
dot
id|useTransport
op_assign
id|US_PR_BULK
)brace
comma
macro_line|#if !defined(CONFIG_BLK_DEV_UB) &amp;&amp; !defined(CONFIG_BLK_DEV_UB_MODULE)
(brace
dot
id|useProtocol
op_assign
id|US_SC_SCSI
comma
dot
id|useTransport
op_assign
id|US_PR_BULK
)brace
comma
macro_line|#endif
multiline_comment|/* Terminating entry */
(brace
l_int|NULL
)brace
)brace
suffix:semicolon
DECL|variable|usb_storage_driver
r_struct
id|usb_driver
id|usb_storage_driver
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|name
op_assign
l_string|&quot;usb-storage&quot;
comma
dot
id|probe
op_assign
id|storage_probe
comma
dot
id|disconnect
op_assign
id|storage_disconnect
comma
dot
id|id_table
op_assign
id|storage_usb_ids
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * fill_inquiry_response takes an unsigned char array (which must&n; * be at least 36 characters) and populates the vendor name,&n; * product name, and revision fields. Then the array is copied&n; * into the SCSI command&squot;s response buffer (oddly enough&n; * called request_buffer). data_len contains the length of the&n; * data array, which again must be at least 36.&n; */
DECL|function|fill_inquiry_response
r_void
id|fill_inquiry_response
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|data
comma
r_int
r_int
id|data_len
)paren
(brace
r_if
c_cond
(paren
id|data_len
OL
l_int|36
)paren
singleline_comment|// You lose.
r_return
suffix:semicolon
r_if
c_cond
(paren
id|data
(braket
l_int|0
)braket
op_amp
l_int|0x20
)paren
(brace
multiline_comment|/* USB device currently not connected. Return&n;&t;&t;&t;      peripheral qualifier 001b (&quot;...however, the&n;&t;&t;&t;      physical device is not currently connected&n;&t;&t;&t;      to this logical unit&quot;) and leave vendor and&n;&t;&t;&t;      product identification empty. (&quot;If the target&n;&t;&t;&t;      does store some of the INQUIRY data on the&n;&t;&t;&t;      device, it may return zeros or ASCII spaces &n;&t;&t;&t;      (20h) in those fields until the data is&n;&t;&t;&t;      available from the device.&quot;). */
id|memset
c_func
(paren
id|data
op_plus
l_int|8
comma
l_int|0
comma
l_int|28
)paren
suffix:semicolon
)brace
r_else
(brace
id|u16
id|bcdDevice
op_assign
id|le16_to_cpu
c_func
(paren
id|us-&gt;pusb_dev-&gt;descriptor.bcdDevice
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|data
op_plus
l_int|8
comma
id|us-&gt;unusual_dev-&gt;vendorName
comma
id|strlen
c_func
(paren
id|us-&gt;unusual_dev-&gt;vendorName
)paren
OG
l_int|8
ques
c_cond
l_int|8
suffix:colon
id|strlen
c_func
(paren
id|us-&gt;unusual_dev-&gt;vendorName
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|data
op_plus
l_int|16
comma
id|us-&gt;unusual_dev-&gt;productName
comma
id|strlen
c_func
(paren
id|us-&gt;unusual_dev-&gt;productName
)paren
OG
l_int|16
ques
c_cond
l_int|16
suffix:colon
id|strlen
c_func
(paren
id|us-&gt;unusual_dev-&gt;productName
)paren
)paren
suffix:semicolon
id|data
(braket
l_int|32
)braket
op_assign
l_int|0x30
op_plus
(paren
(paren
id|bcdDevice
op_rshift
l_int|12
)paren
op_amp
l_int|0x0F
)paren
suffix:semicolon
id|data
(braket
l_int|33
)braket
op_assign
l_int|0x30
op_plus
(paren
(paren
id|bcdDevice
op_rshift
l_int|8
)paren
op_amp
l_int|0x0F
)paren
suffix:semicolon
id|data
(braket
l_int|34
)braket
op_assign
l_int|0x30
op_plus
(paren
(paren
id|bcdDevice
op_rshift
l_int|4
)paren
op_amp
l_int|0x0F
)paren
suffix:semicolon
id|data
(braket
l_int|35
)braket
op_assign
l_int|0x30
op_plus
(paren
(paren
id|bcdDevice
)paren
op_amp
l_int|0x0F
)paren
suffix:semicolon
)brace
id|usb_stor_set_xfer_buf
c_func
(paren
id|data
comma
id|data_len
comma
id|us-&gt;srb
)paren
suffix:semicolon
)brace
DECL|function|usb_stor_control_thread
r_static
r_int
id|usb_stor_control_thread
c_func
(paren
r_void
op_star
id|__us
)paren
(brace
r_struct
id|us_data
op_star
id|us
op_assign
(paren
r_struct
id|us_data
op_star
)paren
id|__us
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|us-&gt;host
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This thread doesn&squot;t need any user-level access,&n;&t; * so get rid of all our resources.&n;&t; */
id|daemonize
c_func
(paren
l_string|&quot;usb-storage&quot;
)paren
suffix:semicolon
id|current-&gt;flags
op_or_assign
id|PF_NOFREEZE
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* signal that we&squot;ve started the thread */
id|complete
c_func
(paren
op_amp
(paren
id|us-&gt;notify
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;*** thread sleeping.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|down_interruptible
c_func
(paren
op_amp
id|us-&gt;sema
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;*** thread awakened.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* lock the device pointers */
id|down
c_func
(paren
op_amp
(paren
id|us-&gt;dev_semaphore
)paren
)paren
suffix:semicolon
multiline_comment|/* if us-&gt;srb is NULL, we are being asked to exit */
r_if
c_cond
(paren
id|us-&gt;srb
op_eq
l_int|NULL
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- exit command received&bslash;n&quot;
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
(paren
id|us-&gt;dev_semaphore
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* lock access to the state */
id|scsi_lock
c_func
(paren
id|host
)paren
suffix:semicolon
multiline_comment|/* has the command timed out *already* ? */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|US_FLIDX_TIMED_OUT
comma
op_amp
id|us-&gt;flags
)paren
)paren
(brace
id|us-&gt;srb-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
r_goto
id|SkipForAbort
suffix:semicolon
)brace
multiline_comment|/* don&squot;t do anything if we are disconnecting */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|US_FLIDX_DISCONNECTING
comma
op_amp
id|us-&gt;flags
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;No command during disconnect&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|SkipForDisconnect
suffix:semicolon
)brace
id|scsi_unlock
c_func
(paren
id|host
)paren
suffix:semicolon
multiline_comment|/* reject the command if the direction indicator &n;&t;&t; * is UNKNOWN&n;&t;&t; */
r_if
c_cond
(paren
id|us-&gt;srb-&gt;sc_data_direction
op_eq
id|DMA_BIDIRECTIONAL
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;UNKNOWN data direction&bslash;n&quot;
)paren
suffix:semicolon
id|us-&gt;srb-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
)brace
multiline_comment|/* reject if target != 0 or if LUN is higher than&n;&t;&t; * the maximum known LUN&n;&t;&t; */
r_else
r_if
c_cond
(paren
id|us-&gt;srb-&gt;device-&gt;id
op_logical_and
op_logical_neg
(paren
id|us-&gt;flags
op_amp
id|US_FL_SCM_MULT_TARG
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bad target number (%d:%d)&bslash;n&quot;
comma
id|us-&gt;srb-&gt;device-&gt;id
comma
id|us-&gt;srb-&gt;device-&gt;lun
)paren
suffix:semicolon
id|us-&gt;srb-&gt;result
op_assign
id|DID_BAD_TARGET
op_lshift
l_int|16
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|us-&gt;srb-&gt;device-&gt;lun
OG
id|us-&gt;max_lun
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bad LUN (%d:%d)&bslash;n&quot;
comma
id|us-&gt;srb-&gt;device-&gt;id
comma
id|us-&gt;srb-&gt;device-&gt;lun
)paren
suffix:semicolon
id|us-&gt;srb-&gt;result
op_assign
id|DID_BAD_TARGET
op_lshift
l_int|16
suffix:semicolon
)brace
multiline_comment|/* Handle those devices which need us to fake &n;&t;&t; * their inquiry data */
r_else
r_if
c_cond
(paren
(paren
id|us-&gt;srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
op_logical_and
(paren
id|us-&gt;flags
op_amp
id|US_FL_FIX_INQUIRY
)paren
)paren
(brace
r_int
r_char
id|data_ptr
(braket
l_int|36
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0x80
comma
l_int|0x02
comma
l_int|0x02
comma
l_int|0x1F
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Faking INQUIRY command&bslash;n&quot;
)paren
suffix:semicolon
id|fill_inquiry_response
c_func
(paren
id|us
comma
id|data_ptr
comma
l_int|36
)paren
suffix:semicolon
id|us-&gt;srb-&gt;result
op_assign
id|SAM_STAT_GOOD
suffix:semicolon
)brace
multiline_comment|/* we&squot;ve got a command, let&squot;s do it! */
r_else
(brace
id|US_DEBUG
c_func
(paren
id|usb_stor_show_command
c_func
(paren
id|us-&gt;srb
)paren
)paren
suffix:semicolon
id|us
op_member_access_from_pointer
id|proto_handler
c_func
(paren
id|us-&gt;srb
comma
id|us
)paren
suffix:semicolon
)brace
multiline_comment|/* lock access to the state */
id|scsi_lock
c_func
(paren
id|host
)paren
suffix:semicolon
multiline_comment|/* indicate that the command is done */
r_if
c_cond
(paren
id|us-&gt;srb-&gt;result
op_ne
id|DID_ABORT
op_lshift
l_int|16
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;scsi cmd done, result=0x%x&bslash;n&quot;
comma
id|us-&gt;srb-&gt;result
)paren
suffix:semicolon
id|us-&gt;srb
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|us-&gt;srb
)paren
suffix:semicolon
)brace
r_else
(brace
id|SkipForAbort
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;scsi command aborted&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* If an abort request was received we need to signal that&n;&t;&t; * the abort has finished.  The proper test for this is&n;&t;&t; * the TIMED_OUT flag, not srb-&gt;result == DID_ABORT, because&n;&t;&t; * a timeout/abort request might be received after all the&n;&t;&t; * USB processing was complete. */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|US_FLIDX_TIMED_OUT
comma
op_amp
id|us-&gt;flags
)paren
)paren
id|complete
c_func
(paren
op_amp
(paren
id|us-&gt;notify
)paren
)paren
suffix:semicolon
multiline_comment|/* finished working on this command */
id|SkipForDisconnect
suffix:colon
id|us-&gt;srb
op_assign
l_int|NULL
suffix:semicolon
id|scsi_unlock
c_func
(paren
id|host
)paren
suffix:semicolon
multiline_comment|/* unlock the device pointers */
id|up
c_func
(paren
op_amp
(paren
id|us-&gt;dev_semaphore
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* for (;;) */
multiline_comment|/* notify the exit routine that we&squot;re actually exiting now &n;&t; *&n;&t; * complete()/wait_for_completion() is similar to up()/down(),&n;&t; * except that complete() is safe in the case where the structure&n;&t; * is getting deleted in a parallel mode of execution (i.e. just&n;&t; * after the down() -- that&squot;s necessary for the thread-shutdown&n;&t; * case.&n;&t; *&n;&t; * complete_and_exit() goes even further than this -- it is safe in&n;&t; * the case that the thread of the caller is going away (not just&n;&t; * the structure) -- this is necessary for the module-remove case.&n;&t; * This is important in preemption kernels, which transfer the flow&n;&t; * of execution immediately upon a complete().&n;&t; */
id|complete_and_exit
c_func
(paren
op_amp
(paren
id|us-&gt;notify
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/***********************************************************************&n; * Device probing and disconnecting&n; ***********************************************************************/
multiline_comment|/* Associate our private data with the USB device */
DECL|function|associate_dev
r_static
r_int
id|associate_dev
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_struct
id|usb_interface
op_star
id|intf
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- %s&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* Fill in the device-related fields */
id|us-&gt;pusb_dev
op_assign
id|interface_to_usbdev
c_func
(paren
id|intf
)paren
suffix:semicolon
id|us-&gt;pusb_intf
op_assign
id|intf
suffix:semicolon
id|us-&gt;ifnum
op_assign
id|intf-&gt;cur_altsetting-&gt;desc.bInterfaceNumber
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Vendor: 0x%04x, Product: 0x%04x, Revision: 0x%04x&bslash;n&quot;
comma
id|le16_to_cpu
c_func
(paren
id|us-&gt;pusb_dev-&gt;descriptor.idVendor
)paren
comma
id|le16_to_cpu
c_func
(paren
id|us-&gt;pusb_dev-&gt;descriptor.idProduct
)paren
comma
id|le16_to_cpu
c_func
(paren
id|us-&gt;pusb_dev-&gt;descriptor.bcdDevice
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Interface Subclass: 0x%02x, Protocol: 0x%02x&bslash;n&quot;
comma
id|intf-&gt;cur_altsetting-&gt;desc.bInterfaceSubClass
comma
id|intf-&gt;cur_altsetting-&gt;desc.bInterfaceProtocol
)paren
suffix:semicolon
multiline_comment|/* Store our private data in the interface */
id|usb_set_intfdata
c_func
(paren
id|intf
comma
id|us
)paren
suffix:semicolon
multiline_comment|/* Allocate the device-related DMA-mapped buffers */
id|us-&gt;cr
op_assign
id|usb_buffer_alloc
c_func
(paren
id|us-&gt;pusb_dev
comma
r_sizeof
(paren
op_star
id|us-&gt;cr
)paren
comma
id|GFP_KERNEL
comma
op_amp
id|us-&gt;cr_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|us-&gt;cr
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;usb_ctrlrequest allocation failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|us-&gt;iobuf
op_assign
id|usb_buffer_alloc
c_func
(paren
id|us-&gt;pusb_dev
comma
id|US_IOBUF_SIZE
comma
id|GFP_KERNEL
comma
op_amp
id|us-&gt;iobuf_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|us-&gt;iobuf
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;I/O buffer allocation failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Get the unusual_devs entries and the string descriptors */
DECL|function|get_device_info
r_static
r_void
id|get_device_info
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
id|id_index
)paren
(brace
r_struct
id|usb_device
op_star
id|dev
op_assign
id|us-&gt;pusb_dev
suffix:semicolon
r_struct
id|usb_interface_descriptor
op_star
id|idesc
op_assign
op_amp
id|us-&gt;pusb_intf-&gt;cur_altsetting-&gt;desc
suffix:semicolon
r_struct
id|us_unusual_dev
op_star
id|unusual_dev
op_assign
op_amp
id|us_unusual_dev_list
(braket
id|id_index
)braket
suffix:semicolon
r_struct
id|usb_device_id
op_star
id|id
op_assign
op_amp
id|storage_usb_ids
(braket
id|id_index
)braket
suffix:semicolon
multiline_comment|/* Store the entries */
id|us-&gt;unusual_dev
op_assign
id|unusual_dev
suffix:semicolon
id|us-&gt;subclass
op_assign
(paren
id|unusual_dev-&gt;useProtocol
op_eq
id|US_SC_DEVICE
)paren
ques
c_cond
id|idesc-&gt;bInterfaceSubClass
suffix:colon
id|unusual_dev-&gt;useProtocol
suffix:semicolon
id|us-&gt;protocol
op_assign
(paren
id|unusual_dev-&gt;useTransport
op_eq
id|US_PR_DEVICE
)paren
ques
c_cond
id|idesc-&gt;bInterfaceProtocol
suffix:colon
id|unusual_dev-&gt;useTransport
suffix:semicolon
id|us-&gt;flags
op_assign
id|unusual_dev-&gt;flags
suffix:semicolon
multiline_comment|/* Log a message if a non-generic unusual_dev entry contains an&n;&t; * unnecessary subclass or protocol override.  This may stimulate&n;&t; * reports from users that will help us remove unneeded entries&n;&t; * from the unusual_devs.h table.&n;&t; */
r_if
c_cond
(paren
id|id-&gt;idVendor
op_logical_or
id|id-&gt;idProduct
)paren
(brace
r_static
r_char
op_star
id|msgs
(braket
l_int|3
)braket
op_assign
(brace
l_string|&quot;an unneeded SubClass entry&quot;
comma
l_string|&quot;an unneeded Protocol entry&quot;
comma
l_string|&quot;unneeded SubClass and Protocol entries&quot;
)brace
suffix:semicolon
r_struct
id|usb_device_descriptor
op_star
id|ddesc
op_assign
op_amp
id|dev-&gt;descriptor
suffix:semicolon
r_int
id|msg
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|unusual_dev-&gt;useProtocol
op_ne
id|US_SC_DEVICE
op_logical_and
id|us-&gt;subclass
op_eq
id|idesc-&gt;bInterfaceSubClass
)paren
id|msg
op_add_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|unusual_dev-&gt;useTransport
op_ne
id|US_PR_DEVICE
op_logical_and
id|us-&gt;protocol
op_eq
id|idesc-&gt;bInterfaceProtocol
)paren
id|msg
op_add_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|msg
op_ge
l_int|0
op_logical_and
op_logical_neg
(paren
id|unusual_dev-&gt;flags
op_amp
id|US_FL_NEED_OVERRIDE
)paren
)paren
id|printk
c_func
(paren
id|KERN_NOTICE
id|USB_STORAGE
l_string|&quot;This device &quot;
l_string|&quot;(%04x,%04x,%04x S %02x P %02x)&quot;
l_string|&quot; has %s in unusual_devs.h&bslash;n&quot;
l_string|&quot;   Please send a copy of this message to &quot;
l_string|&quot;&lt;linux-usb-devel@lists.sourceforge.net&gt;&bslash;n&quot;
comma
id|le16_to_cpu
c_func
(paren
id|ddesc-&gt;idVendor
)paren
comma
id|le16_to_cpu
c_func
(paren
id|ddesc-&gt;idProduct
)paren
comma
id|le16_to_cpu
c_func
(paren
id|ddesc-&gt;bcdDevice
)paren
comma
id|idesc-&gt;bInterfaceSubClass
comma
id|idesc-&gt;bInterfaceProtocol
comma
id|msgs
(braket
id|msg
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Read the device&squot;s string descriptors */
r_if
c_cond
(paren
id|dev-&gt;descriptor.iManufacturer
)paren
id|usb_string
c_func
(paren
id|dev
comma
id|dev-&gt;descriptor.iManufacturer
comma
id|us-&gt;vendor
comma
r_sizeof
(paren
id|us-&gt;vendor
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;descriptor.iProduct
)paren
id|usb_string
c_func
(paren
id|dev
comma
id|dev-&gt;descriptor.iProduct
comma
id|us-&gt;product
comma
r_sizeof
(paren
id|us-&gt;product
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;descriptor.iSerialNumber
)paren
id|usb_string
c_func
(paren
id|dev
comma
id|dev-&gt;descriptor.iSerialNumber
comma
id|us-&gt;serial
comma
r_sizeof
(paren
id|us-&gt;serial
)paren
)paren
suffix:semicolon
multiline_comment|/* Use the unusual_dev strings if the device didn&squot;t provide them */
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|us-&gt;vendor
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|unusual_dev-&gt;vendorName
)paren
id|strlcpy
c_func
(paren
id|us-&gt;vendor
comma
id|unusual_dev-&gt;vendorName
comma
r_sizeof
(paren
id|us-&gt;vendor
)paren
)paren
suffix:semicolon
r_else
id|strcpy
c_func
(paren
id|us-&gt;vendor
comma
l_string|&quot;Unknown&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|us-&gt;product
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|unusual_dev-&gt;productName
)paren
id|strlcpy
c_func
(paren
id|us-&gt;product
comma
id|unusual_dev-&gt;productName
comma
r_sizeof
(paren
id|us-&gt;product
)paren
)paren
suffix:semicolon
r_else
id|strcpy
c_func
(paren
id|us-&gt;product
comma
l_string|&quot;Unknown&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|us-&gt;serial
)paren
op_eq
l_int|0
)paren
id|strcpy
c_func
(paren
id|us-&gt;serial
comma
l_string|&quot;None&quot;
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Vendor: %s,  Product: %s&bslash;n&quot;
comma
id|us-&gt;vendor
comma
id|us-&gt;product
)paren
suffix:semicolon
)brace
multiline_comment|/* Get the transport settings */
DECL|function|get_transport
r_static
r_int
id|get_transport
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_switch
c_cond
(paren
id|us-&gt;protocol
)paren
(brace
r_case
id|US_PR_CB
suffix:colon
id|us-&gt;transport_name
op_assign
l_string|&quot;Control/Bulk&quot;
suffix:semicolon
id|us-&gt;transport
op_assign
id|usb_stor_CB_transport
suffix:semicolon
id|us-&gt;transport_reset
op_assign
id|usb_stor_CB_reset
suffix:semicolon
id|us-&gt;max_lun
op_assign
l_int|7
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_PR_CBI
suffix:colon
id|us-&gt;transport_name
op_assign
l_string|&quot;Control/Bulk/Interrupt&quot;
suffix:semicolon
id|us-&gt;transport
op_assign
id|usb_stor_CBI_transport
suffix:semicolon
id|us-&gt;transport_reset
op_assign
id|usb_stor_CB_reset
suffix:semicolon
id|us-&gt;max_lun
op_assign
l_int|7
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_PR_BULK
suffix:colon
id|us-&gt;transport_name
op_assign
l_string|&quot;Bulk&quot;
suffix:semicolon
id|us-&gt;transport
op_assign
id|usb_stor_Bulk_transport
suffix:semicolon
id|us-&gt;transport_reset
op_assign
id|usb_stor_Bulk_reset
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef CONFIG_USB_STORAGE_HP8200e
r_case
id|US_PR_SCM_ATAPI
suffix:colon
id|us-&gt;transport_name
op_assign
l_string|&quot;SCM/ATAPI&quot;
suffix:semicolon
id|us-&gt;transport
op_assign
id|hp8200e_transport
suffix:semicolon
id|us-&gt;transport_reset
op_assign
id|usb_stor_CB_reset
suffix:semicolon
id|us-&gt;max_lun
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_SDDR09
r_case
id|US_PR_EUSB_SDDR09
suffix:colon
id|us-&gt;transport_name
op_assign
l_string|&quot;EUSB/SDDR09&quot;
suffix:semicolon
id|us-&gt;transport
op_assign
id|sddr09_transport
suffix:semicolon
id|us-&gt;transport_reset
op_assign
id|usb_stor_CB_reset
suffix:semicolon
id|us-&gt;max_lun
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_SDDR55
r_case
id|US_PR_SDDR55
suffix:colon
id|us-&gt;transport_name
op_assign
l_string|&quot;SDDR55&quot;
suffix:semicolon
id|us-&gt;transport
op_assign
id|sddr55_transport
suffix:semicolon
id|us-&gt;transport_reset
op_assign
id|sddr55_reset
suffix:semicolon
id|us-&gt;max_lun
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_DPCM
r_case
id|US_PR_DPCM_USB
suffix:colon
id|us-&gt;transport_name
op_assign
l_string|&quot;Control/Bulk-EUSB/SDDR09&quot;
suffix:semicolon
id|us-&gt;transport
op_assign
id|dpcm_transport
suffix:semicolon
id|us-&gt;transport_reset
op_assign
id|usb_stor_CB_reset
suffix:semicolon
id|us-&gt;max_lun
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_FREECOM
r_case
id|US_PR_FREECOM
suffix:colon
id|us-&gt;transport_name
op_assign
l_string|&quot;Freecom&quot;
suffix:semicolon
id|us-&gt;transport
op_assign
id|freecom_transport
suffix:semicolon
id|us-&gt;transport_reset
op_assign
id|usb_stor_freecom_reset
suffix:semicolon
id|us-&gt;max_lun
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_DATAFAB
r_case
id|US_PR_DATAFAB
suffix:colon
id|us-&gt;transport_name
op_assign
l_string|&quot;Datafab Bulk-Only&quot;
suffix:semicolon
id|us-&gt;transport
op_assign
id|datafab_transport
suffix:semicolon
id|us-&gt;transport_reset
op_assign
id|usb_stor_Bulk_reset
suffix:semicolon
id|us-&gt;max_lun
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_JUMPSHOT
r_case
id|US_PR_JUMPSHOT
suffix:colon
id|us-&gt;transport_name
op_assign
l_string|&quot;Lexar Jumpshot Control/Bulk&quot;
suffix:semicolon
id|us-&gt;transport
op_assign
id|jumpshot_transport
suffix:semicolon
id|us-&gt;transport_reset
op_assign
id|usb_stor_Bulk_reset
suffix:semicolon
id|us-&gt;max_lun
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Transport: %s&bslash;n&quot;
comma
id|us-&gt;transport_name
)paren
suffix:semicolon
multiline_comment|/* fix for single-lun devices */
r_if
c_cond
(paren
id|us-&gt;flags
op_amp
id|US_FL_SINGLE_LUN
)paren
id|us-&gt;max_lun
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Get the protocol settings */
DECL|function|get_protocol
r_static
r_int
id|get_protocol
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_switch
c_cond
(paren
id|us-&gt;subclass
)paren
(brace
r_case
id|US_SC_RBC
suffix:colon
id|us-&gt;protocol_name
op_assign
l_string|&quot;Reduced Block Commands (RBC)&quot;
suffix:semicolon
id|us-&gt;proto_handler
op_assign
id|usb_stor_transparent_scsi_command
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_SC_8020
suffix:colon
id|us-&gt;protocol_name
op_assign
l_string|&quot;8020i&quot;
suffix:semicolon
id|us-&gt;proto_handler
op_assign
id|usb_stor_ATAPI_command
suffix:semicolon
id|us-&gt;max_lun
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_SC_QIC
suffix:colon
id|us-&gt;protocol_name
op_assign
l_string|&quot;QIC-157&quot;
suffix:semicolon
id|us-&gt;proto_handler
op_assign
id|usb_stor_qic157_command
suffix:semicolon
id|us-&gt;max_lun
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_SC_8070
suffix:colon
id|us-&gt;protocol_name
op_assign
l_string|&quot;8070i&quot;
suffix:semicolon
id|us-&gt;proto_handler
op_assign
id|usb_stor_ATAPI_command
suffix:semicolon
id|us-&gt;max_lun
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_SC_SCSI
suffix:colon
id|us-&gt;protocol_name
op_assign
l_string|&quot;Transparent SCSI&quot;
suffix:semicolon
id|us-&gt;proto_handler
op_assign
id|usb_stor_transparent_scsi_command
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_SC_UFI
suffix:colon
id|us-&gt;protocol_name
op_assign
l_string|&quot;Uniform Floppy Interface (UFI)&quot;
suffix:semicolon
id|us-&gt;proto_handler
op_assign
id|usb_stor_ufi_command
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef CONFIG_USB_STORAGE_ISD200
r_case
id|US_SC_ISD200
suffix:colon
id|us-&gt;protocol_name
op_assign
l_string|&quot;ISD200 ATA/ATAPI&quot;
suffix:semicolon
id|us-&gt;proto_handler
op_assign
id|isd200_ata_command
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Protocol: %s&bslash;n&quot;
comma
id|us-&gt;protocol_name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Get the pipe settings */
DECL|function|get_pipes
r_static
r_int
id|get_pipes
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_struct
id|usb_host_interface
op_star
id|altsetting
op_assign
id|us-&gt;pusb_intf-&gt;cur_altsetting
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|ep
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|ep_in
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|ep_out
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|ep_int
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Find the endpoints we need.&n;&t; * We are expecting a minimum of 2 endpoints - in and out (bulk).&n;&t; * An optional interrupt is OK (necessary for CBI protocol).&n;&t; * We will ignore any others.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|altsetting-&gt;desc.bNumEndpoints
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ep
op_assign
op_amp
id|altsetting-&gt;endpoint
(braket
id|i
)braket
dot
id|desc
suffix:semicolon
multiline_comment|/* Is it a BULK endpoint? */
r_if
c_cond
(paren
(paren
id|ep-&gt;bmAttributes
op_amp
id|USB_ENDPOINT_XFERTYPE_MASK
)paren
op_eq
id|USB_ENDPOINT_XFER_BULK
)paren
(brace
multiline_comment|/* BULK in or out? */
r_if
c_cond
(paren
id|ep-&gt;bEndpointAddress
op_amp
id|USB_DIR_IN
)paren
id|ep_in
op_assign
id|ep
suffix:semicolon
r_else
id|ep_out
op_assign
id|ep
suffix:semicolon
)brace
multiline_comment|/* Is it an interrupt endpoint? */
r_else
r_if
c_cond
(paren
(paren
id|ep-&gt;bmAttributes
op_amp
id|USB_ENDPOINT_XFERTYPE_MASK
)paren
op_eq
id|USB_ENDPOINT_XFER_INT
)paren
(brace
id|ep_int
op_assign
id|ep
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|ep_in
op_logical_or
op_logical_neg
id|ep_out
op_logical_or
(paren
id|us-&gt;protocol
op_eq
id|US_PR_CBI
op_logical_and
op_logical_neg
id|ep_int
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Endpoint sanity check failed! Rejecting dev.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Calculate and store the pipe values */
id|us-&gt;send_ctrl_pipe
op_assign
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
suffix:semicolon
id|us-&gt;recv_ctrl_pipe
op_assign
id|usb_rcvctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
suffix:semicolon
id|us-&gt;send_bulk_pipe
op_assign
id|usb_sndbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|ep_out-&gt;bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
)paren
suffix:semicolon
id|us-&gt;recv_bulk_pipe
op_assign
id|usb_rcvbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|ep_in-&gt;bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ep_int
)paren
(brace
id|us-&gt;recv_intr_pipe
op_assign
id|usb_rcvintpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|ep_int-&gt;bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
)paren
suffix:semicolon
id|us-&gt;ep_bInterval
op_assign
id|ep_int-&gt;bInterval
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Initialize all the dynamic resources we need */
DECL|function|usb_stor_acquire_resources
r_static
r_int
id|usb_stor_acquire_resources
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|p
suffix:semicolon
id|us-&gt;current_urb
op_assign
id|usb_alloc_urb
c_func
(paren
l_int|0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|us-&gt;current_urb
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;URB allocation failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Lock the device while we carry out the next two operations */
id|down
c_func
(paren
op_amp
id|us-&gt;dev_semaphore
)paren
suffix:semicolon
multiline_comment|/* For bulk-only devices, determine the max LUN value */
r_if
c_cond
(paren
id|us-&gt;protocol
op_eq
id|US_PR_BULK
)paren
(brace
id|p
op_assign
id|usb_stor_Bulk_max_lun
c_func
(paren
id|us
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
OL
l_int|0
)paren
(brace
id|up
c_func
(paren
op_amp
id|us-&gt;dev_semaphore
)paren
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
id|us-&gt;max_lun
op_assign
id|p
suffix:semicolon
)brace
multiline_comment|/* Just before we start our control thread, initialize&n;&t; * the device if it needs initialization */
r_if
c_cond
(paren
id|us-&gt;unusual_dev-&gt;initFunction
)paren
id|us-&gt;unusual_dev
op_member_access_from_pointer
id|initFunction
c_func
(paren
id|us
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|us-&gt;dev_semaphore
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Since this is a new device, we need to register a SCSI&n;&t; * host definition with the higher SCSI layers.&n;&t; */
id|us-&gt;host
op_assign
id|scsi_host_alloc
c_func
(paren
op_amp
id|usb_stor_host_template
comma
r_sizeof
(paren
id|us
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|us-&gt;host
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|USB_STORAGE
l_string|&quot;Unable to allocate the scsi host&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* Set the hostdata to prepare for scanning */
id|us-&gt;host-&gt;hostdata
(braket
l_int|0
)braket
op_assign
(paren
r_int
r_int
)paren
id|us
suffix:semicolon
multiline_comment|/* Start up our control thread */
id|p
op_assign
id|kernel_thread
c_func
(paren
id|usb_stor_control_thread
comma
id|us
comma
id|CLONE_VM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|USB_STORAGE
l_string|&quot;Unable to start control thread&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
id|us-&gt;pid
op_assign
id|p
suffix:semicolon
multiline_comment|/* Wait for the thread to start */
id|wait_for_completion
c_func
(paren
op_amp
(paren
id|us-&gt;notify
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Release all our dynamic resources */
DECL|function|usb_stor_release_resources
r_void
id|usb_stor_release_resources
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- %s&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* Kill the control thread.  The SCSI host must already have been&n;&t; * removed so it won&squot;t try to queue any more commands.&n;&t; */
r_if
c_cond
(paren
id|us-&gt;pid
)paren
(brace
multiline_comment|/* Wait for the thread to be idle */
id|down
c_func
(paren
op_amp
id|us-&gt;dev_semaphore
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- sending exit command to thread&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* If the SCSI midlayer queued a final command just before&n;&t;&t; * scsi_remove_host() was called, us-&gt;srb might not be&n;&t;&t; * NULL.  We can overwrite it safely, because the midlayer&n;&t;&t; * will not wait for the command to finish.  Also the&n;&t;&t; * control thread will already have been awakened.&n;&t;&t; * That&squot;s okay, an extra up() on us-&gt;sema won&squot;t hurt.&n;&t;&t; *&n;&t;&t; * Enqueue the command, wake up the thread, and wait for &n;&t;&t; * notification that it has exited.&n;&t;&t; */
id|scsi_lock
c_func
(paren
id|us-&gt;host
)paren
suffix:semicolon
id|us-&gt;srb
op_assign
l_int|NULL
suffix:semicolon
id|scsi_unlock
c_func
(paren
id|us-&gt;host
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|us-&gt;dev_semaphore
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|us-&gt;sema
)paren
suffix:semicolon
id|wait_for_completion
c_func
(paren
op_amp
id|us-&gt;notify
)paren
suffix:semicolon
)brace
multiline_comment|/* Call the destructor routine, if it exists */
r_if
c_cond
(paren
id|us-&gt;extra_destructor
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- calling extra_destructor()&bslash;n&quot;
)paren
suffix:semicolon
id|us
op_member_access_from_pointer
id|extra_destructor
c_func
(paren
id|us-&gt;extra
)paren
suffix:semicolon
)brace
multiline_comment|/* Finish the host removal sequence */
r_if
c_cond
(paren
id|us-&gt;host
)paren
id|scsi_host_put
c_func
(paren
id|us-&gt;host
)paren
suffix:semicolon
multiline_comment|/* Free the extra data and the URB */
r_if
c_cond
(paren
id|us-&gt;extra
)paren
id|kfree
c_func
(paren
id|us-&gt;extra
)paren
suffix:semicolon
r_if
c_cond
(paren
id|us-&gt;current_urb
)paren
id|usb_free_urb
c_func
(paren
id|us-&gt;current_urb
)paren
suffix:semicolon
)brace
multiline_comment|/* Dissociate from the USB device */
DECL|function|dissociate_dev
r_static
r_void
id|dissociate_dev
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- %s&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* Free the device-related DMA-mapped buffers */
r_if
c_cond
(paren
id|us-&gt;cr
)paren
id|usb_buffer_free
c_func
(paren
id|us-&gt;pusb_dev
comma
r_sizeof
(paren
op_star
id|us-&gt;cr
)paren
comma
id|us-&gt;cr
comma
id|us-&gt;cr_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|us-&gt;iobuf
)paren
id|usb_buffer_free
c_func
(paren
id|us-&gt;pusb_dev
comma
id|US_IOBUF_SIZE
comma
id|us-&gt;iobuf
comma
id|us-&gt;iobuf_dma
)paren
suffix:semicolon
multiline_comment|/* Remove our private data from the interface */
id|usb_set_intfdata
c_func
(paren
id|us-&gt;pusb_intf
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Free the structure itself */
id|kfree
c_func
(paren
id|us
)paren
suffix:semicolon
)brace
multiline_comment|/* Thread to carry out delayed SCSI-device scanning */
DECL|function|usb_stor_scan_thread
r_static
r_int
id|usb_stor_scan_thread
c_func
(paren
r_void
op_star
id|__us
)paren
(brace
r_struct
id|us_data
op_star
id|us
op_assign
(paren
r_struct
id|us_data
op_star
)paren
id|__us
suffix:semicolon
multiline_comment|/*&n;&t; * This thread doesn&squot;t need any user-level access,&n;&t; * so get rid of all our resources.&n;&t; */
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|daemonize
c_func
(paren
l_string|&quot;usb-stor-scan&quot;
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;usb-storage: device found at %d&bslash;n&quot;
comma
id|us-&gt;pusb_dev-&gt;devnum
)paren
suffix:semicolon
multiline_comment|/* Wait for the timeout to expire or for a disconnect */
r_if
c_cond
(paren
id|delay_use
OG
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;usb-storage: waiting for device &quot;
l_string|&quot;to settle before scanning&bslash;n&quot;
)paren
suffix:semicolon
id|retry
suffix:colon
id|wait_event_interruptible_timeout
c_func
(paren
id|us-&gt;scsi_scan_wait
comma
id|test_bit
c_func
(paren
id|US_FLIDX_DISCONNECTING
comma
op_amp
id|us-&gt;flags
)paren
comma
id|delay_use
op_star
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;flags
op_amp
id|PF_FREEZE
)paren
(brace
id|refrigerator
c_func
(paren
id|PF_FREEZE
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
)brace
multiline_comment|/* If the device is still connected, perform the scanning */
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|US_FLIDX_DISCONNECTING
comma
op_amp
id|us-&gt;flags
)paren
)paren
(brace
id|scsi_scan_host
c_func
(paren
id|us-&gt;host
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;usb-storage: device scan complete&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|complete_and_exit
c_func
(paren
op_amp
id|us-&gt;scsi_scan_done
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Probe to see if we can drive a newly-connected USB device */
DECL|function|storage_probe
r_static
r_int
id|storage_probe
c_func
(paren
r_struct
id|usb_interface
op_star
id|intf
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
(brace
r_struct
id|us_data
op_star
id|us
suffix:semicolon
r_const
r_int
id|id_index
op_assign
id|id
op_minus
id|storage_usb_ids
suffix:semicolon
r_int
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;USB Mass Storage device detected&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Allocate the us_data structure and initialize the mutexes */
id|us
op_assign
(paren
r_struct
id|us_data
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|us
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|us
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|USB_STORAGE
l_string|&quot;Out of memory&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|us
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|us_data
)paren
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
(paren
id|us-&gt;dev_semaphore
)paren
)paren
suffix:semicolon
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
(paren
id|us-&gt;sema
)paren
)paren
suffix:semicolon
id|init_completion
c_func
(paren
op_amp
(paren
id|us-&gt;notify
)paren
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|us-&gt;dev_reset_wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|us-&gt;scsi_scan_wait
)paren
suffix:semicolon
id|init_completion
c_func
(paren
op_amp
id|us-&gt;scsi_scan_done
)paren
suffix:semicolon
multiline_comment|/* Associate the us_data structure with the USB device */
id|result
op_assign
id|associate_dev
c_func
(paren
id|us
comma
id|intf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_goto
id|BadDevice
suffix:semicolon
multiline_comment|/*&n;&t; * Get the unusual_devs entries and the descriptors&n;&t; *&n;&t; * id_index is calculated in the declaration to be the index number&n;&t; * of the match from the usb_device_id table, so we can find the&n;&t; * corresponding entry in the private table.&n;&t; */
id|get_device_info
c_func
(paren
id|us
comma
id|id_index
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_USB_STORAGE_SDDR09
r_if
c_cond
(paren
id|us-&gt;protocol
op_eq
id|US_PR_EUSB_SDDR09
op_logical_or
id|us-&gt;protocol
op_eq
id|US_PR_DPCM_USB
)paren
(brace
multiline_comment|/* set the configuration -- STALL is an acceptable response here */
r_if
c_cond
(paren
id|us-&gt;pusb_dev-&gt;actconfig-&gt;desc.bConfigurationValue
op_ne
l_int|1
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;active config #%d != 1 ??&bslash;n&quot;
comma
id|us-&gt;pusb_dev
op_member_access_from_pointer
id|actconfig-&gt;desc.bConfigurationValue
)paren
suffix:semicolon
r_goto
id|BadDevice
suffix:semicolon
)brace
id|result
op_assign
id|usb_reset_configuration
c_func
(paren
id|us-&gt;pusb_dev
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Result of usb_reset_configuration is %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- stall on control interface&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|result
op_ne
l_int|0
)paren
(brace
multiline_comment|/* it&squot;s not a stall, but another error -- time to bail */
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- Unknown error.  Rejecting device&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|BadDevice
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/* Get the transport, protocol, and pipe settings */
id|result
op_assign
id|get_transport
c_func
(paren
id|us
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_goto
id|BadDevice
suffix:semicolon
id|result
op_assign
id|get_protocol
c_func
(paren
id|us
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_goto
id|BadDevice
suffix:semicolon
id|result
op_assign
id|get_pipes
c_func
(paren
id|us
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_goto
id|BadDevice
suffix:semicolon
multiline_comment|/* Acquire all the other resources and add the host */
id|result
op_assign
id|usb_stor_acquire_resources
c_func
(paren
id|us
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_goto
id|BadDevice
suffix:semicolon
id|result
op_assign
id|scsi_add_host
c_func
(paren
id|us-&gt;host
comma
op_amp
id|intf-&gt;dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|USB_STORAGE
l_string|&quot;Unable to add the scsi host&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|BadDevice
suffix:semicolon
)brace
multiline_comment|/* Start up the thread for delayed SCSI-device scanning */
id|result
op_assign
id|kernel_thread
c_func
(paren
id|usb_stor_scan_thread
comma
id|us
comma
id|CLONE_VM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|USB_STORAGE
l_string|&quot;Unable to start the device-scanning thread&bslash;n&quot;
)paren
suffix:semicolon
id|scsi_remove_host
c_func
(paren
id|us-&gt;host
)paren
suffix:semicolon
r_goto
id|BadDevice
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* We come here if there are any problems */
id|BadDevice
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;storage_probe() failed&bslash;n&quot;
)paren
suffix:semicolon
id|usb_stor_release_resources
c_func
(paren
id|us
)paren
suffix:semicolon
id|dissociate_dev
c_func
(paren
id|us
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/* Handle a disconnect event from the USB core */
DECL|function|storage_disconnect
r_static
r_void
id|storage_disconnect
c_func
(paren
r_struct
id|usb_interface
op_star
id|intf
)paren
(brace
r_struct
id|us_data
op_star
id|us
op_assign
id|usb_get_intfdata
c_func
(paren
id|intf
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;storage_disconnect() called&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Prevent new USB transfers, stop the current command, and&n;&t; * interrupt a device-reset delay */
id|set_bit
c_func
(paren
id|US_FLIDX_DISCONNECTING
comma
op_amp
id|us-&gt;flags
)paren
suffix:semicolon
id|usb_stor_stop_transport
c_func
(paren
id|us
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|us-&gt;dev_reset_wait
)paren
suffix:semicolon
multiline_comment|/* Interrupt the SCSI-device-scanning thread&squot;s time delay, and&n;&t; * wait for the thread to finish */
id|wake_up
c_func
(paren
op_amp
id|us-&gt;scsi_scan_wait
)paren
suffix:semicolon
id|wait_for_completion
c_func
(paren
op_amp
id|us-&gt;scsi_scan_done
)paren
suffix:semicolon
multiline_comment|/* Wait for the current command to finish, then remove the host */
id|down
c_func
(paren
op_amp
id|us-&gt;dev_semaphore
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|us-&gt;dev_semaphore
)paren
suffix:semicolon
id|scsi_remove_host
c_func
(paren
id|us-&gt;host
)paren
suffix:semicolon
multiline_comment|/* Wait for everything to become idle and release all our resources */
id|usb_stor_release_resources
c_func
(paren
id|us
)paren
suffix:semicolon
id|dissociate_dev
c_func
(paren
id|us
)paren
suffix:semicolon
)brace
multiline_comment|/***********************************************************************&n; * Initialization and registration&n; ***********************************************************************/
DECL|function|usb_stor_init
r_static
r_int
id|__init
id|usb_stor_init
c_func
(paren
r_void
)paren
(brace
r_int
id|retval
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Initializing USB Mass Storage driver...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* register the driver, return usb_register return code if error */
id|retval
op_assign
id|usb_register
c_func
(paren
op_amp
id|usb_storage_driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;USB Mass Storage support registered.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|usb_stor_exit
r_static
r_void
id|__exit
id|usb_stor_exit
c_func
(paren
r_void
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;usb_stor_exit() called&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Deregister the driver&n;&t; * This will cause disconnect() to be called for each&n;&t; * attached unit&n;&t; */
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- calling usb_deregister()&bslash;n&quot;
)paren
suffix:semicolon
id|usb_deregister
c_func
(paren
op_amp
id|usb_storage_driver
)paren
suffix:semicolon
)brace
DECL|variable|usb_stor_init
id|module_init
c_func
(paren
id|usb_stor_init
)paren
suffix:semicolon
DECL|variable|usb_stor_exit
id|module_exit
c_func
(paren
id|usb_stor_exit
)paren
suffix:semicolon
eof
