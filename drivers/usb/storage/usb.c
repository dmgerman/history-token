multiline_comment|/* Driver for USB Mass Storage compliant devices&n; *&n; * $Id: usb.c,v 1.70 2002/01/06 07:14:12 mdharm Exp $&n; *&n; * Current development and maintenance by:&n; *   (c) 1999, 2000 Matthew Dharm (mdharm-usb@one-eyed-alien.net)&n; *&n; * Developed with the assistance of:&n; *   (c) 2000 David L. Brown, Jr. (usb-storage@davidb.org)&n; *&n; * Initial work by:&n; *   (c) 1999 Michael Gee (michael@linuxspecific.com)&n; *&n; * usb_device_id support by Adam J. Richter (adam@yggdrasil.com):&n; *   (c) 2000 Yggdrasil Computing, Inc.&n; *&n; * This driver is based on the &squot;USB Mass Storage Class&squot; document. This&n; * describes in detail the protocol used to communicate with such&n; * devices.  Clearly, the designers had SCSI and ATAPI commands in&n; * mind when they created this document.  The commands are all very&n; * similar to commands in the SCSI-II and ATAPI specifications.&n; *&n; * It is important to note that in a number of cases this class&n; * exhibits class-specific exemptions from the USB specification.&n; * Notably the usage of NAK, STALL and ACK differs from the norm, in&n; * that they are used to communicate wait, failed and OK on commands.&n; *&n; * Also, for certain devices, the interrupt endpoint is used to convey&n; * status of a command.&n; *&n; * Please see http://www.one-eyed-alien.net/~mdharm/linux-usb for more&n; * information about this driver.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2, or (at your option) any&n; * later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write to the Free Software Foundation, Inc.,&n; * 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &quot;usb.h&quot;
macro_line|#include &quot;scsiglue.h&quot;
macro_line|#include &quot;transport.h&quot;
macro_line|#include &quot;protocol.h&quot;
macro_line|#include &quot;debug.h&quot;
macro_line|#include &quot;initializers.h&quot;
macro_line|#ifdef CONFIG_USB_STORAGE_HP8200e
macro_line|#include &quot;shuttle_usbat.h&quot;
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_SDDR09
macro_line|#include &quot;sddr09.h&quot;
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_DPCM
macro_line|#include &quot;dpcm.h&quot;
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_FREECOM
macro_line|#include &quot;freecom.h&quot;
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_ISD200
macro_line|#include &quot;isd200.h&quot;
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_DATAFAB
macro_line|#include &quot;datafab.h&quot;
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_JUMPSHOT
macro_line|#include &quot;jumpshot.h&quot;
macro_line|#endif
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
multiline_comment|/* Some informational data */
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;USB Mass Storage driver for Linux&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * Per device data&n; */
DECL|variable|my_host_number
r_static
r_int
id|my_host_number
suffix:semicolon
multiline_comment|/*&n; * kernel thread actions&n; */
DECL|macro|US_ACT_COMMAND
mdefine_line|#define US_ACT_COMMAND&t;&t;1
DECL|macro|US_ACT_DEVICE_RESET
mdefine_line|#define US_ACT_DEVICE_RESET&t;2
DECL|macro|US_ACT_BUS_RESET
mdefine_line|#define US_ACT_BUS_RESET&t;3
DECL|macro|US_ACT_HOST_RESET
mdefine_line|#define US_ACT_HOST_RESET&t;4
DECL|macro|US_ACT_EXIT
mdefine_line|#define US_ACT_EXIT&t;&t;5
multiline_comment|/* The list of structures and the protective lock for them */
DECL|variable|us_list
r_struct
id|us_data
op_star
id|us_list
suffix:semicolon
DECL|variable|us_list_semaphore
r_struct
id|semaphore
id|us_list_semaphore
suffix:semicolon
r_static
r_void
op_star
id|storage_probe
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|ifnum
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
suffix:semicolon
r_static
r_void
id|storage_disconnect
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_void
op_star
id|ptr
)paren
suffix:semicolon
multiline_comment|/* The entries in this table, except for final ones here&n; * (USB_MASS_STORAGE_CLASS and the empty entry), correspond,&n; * line for line with the entries of us_unsuaul_dev_list[].&n; * For now, we duplicate idVendor and idProduct in us_unsual_dev_list,&n; * just to avoid alignment bugs.&n; */
DECL|macro|UNUSUAL_DEV
mdefine_line|#define UNUSUAL_DEV(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax, &bslash;&n;&t;&t;    vendorName, productName,useProtocol, useTransport, &bslash;&n;&t;&t;    initFunction, flags) &bslash;&n;{ USB_DEVICE_VER(id_vendor, id_product, bcdDeviceMin,bcdDeviceMax) }
DECL|variable|storage_usb_ids
r_static
r_struct
id|usb_device_id
id|storage_usb_ids
(braket
)braket
op_assign
(brace
macro_line|#&t;include &quot;unusual_devs.h&quot;
DECL|macro|UNUSUAL_DEV
macro_line|#undef UNUSUAL_DEV
multiline_comment|/* Control/Bulk transport for all SubClass values */
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_RBC
comma
id|US_PR_CB
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_8020
comma
id|US_PR_CB
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_QIC
comma
id|US_PR_CB
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_UFI
comma
id|US_PR_CB
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_8070
comma
id|US_PR_CB
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_SCSI
comma
id|US_PR_CB
)paren
)brace
comma
multiline_comment|/* Control/Bulk/Interrupt transport for all SubClass values */
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_RBC
comma
id|US_PR_CBI
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_8020
comma
id|US_PR_CBI
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_QIC
comma
id|US_PR_CBI
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_UFI
comma
id|US_PR_CBI
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_8070
comma
id|US_PR_CBI
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_SCSI
comma
id|US_PR_CBI
)paren
)brace
comma
multiline_comment|/* Bulk-only transport for all SubClass values */
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_RBC
comma
id|US_PR_BULK
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_8020
comma
id|US_PR_BULK
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_QIC
comma
id|US_PR_BULK
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_UFI
comma
id|US_PR_BULK
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_8070
comma
id|US_PR_BULK
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_SCSI
comma
id|US_PR_BULK
)paren
)brace
comma
multiline_comment|/* Terminating entry */
(brace
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
(paren
id|usb
comma
id|storage_usb_ids
)paren
suffix:semicolon
multiline_comment|/* This is the list of devices we recognize, along with their flag data */
multiline_comment|/* The vendor name should be kept at eight characters or less, and&n; * the product name should be kept at 16 characters or less. If a device&n; * has the US_FL_FIX_INQUIRY flag, then the vendor and product names&n; * normally generated by a device thorugh the INQUIRY response will be&n; * taken from this list, and this is the reason for the above size&n; * restriction. However, if the flag is not present, then you&n; * are free to use as many characters as you like.&n; */
DECL|macro|UNUSUAL_DEV
macro_line|#undef UNUSUAL_DEV
DECL|macro|UNUSUAL_DEV
mdefine_line|#define UNUSUAL_DEV(idVendor, idProduct, bcdDeviceMin, bcdDeviceMax, &bslash;&n;&t;&t;    vendor_name, product_name, use_protocol, use_transport, &bslash;&n;&t;&t;    init_function, Flags) &bslash;&n;{ &bslash;&n;&t;vendorName: vendor_name,&t;&bslash;&n;&t;productName: product_name,&t;&bslash;&n;&t;useProtocol: use_protocol,&t;&bslash;&n;&t;useTransport: use_transport,&t;&bslash;&n;&t;initFunction : init_function,&t;&bslash;&n;&t;flags: Flags, &bslash;&n;}
DECL|variable|us_unusual_dev_list
r_static
r_struct
id|us_unusual_dev
id|us_unusual_dev_list
(braket
)braket
op_assign
(brace
macro_line|#&t;include &quot;unusual_devs.h&quot; 
DECL|macro|UNUSUAL_DEV
macro_line|#&t;undef UNUSUAL_DEV
multiline_comment|/* Control/Bulk transport for all SubClass values */
(brace
id|useProtocol
suffix:colon
id|US_SC_RBC
comma
id|useTransport
suffix:colon
id|US_PR_CB
)brace
comma
(brace
id|useProtocol
suffix:colon
id|US_SC_8020
comma
id|useTransport
suffix:colon
id|US_PR_CB
)brace
comma
(brace
id|useProtocol
suffix:colon
id|US_SC_QIC
comma
id|useTransport
suffix:colon
id|US_PR_CB
)brace
comma
(brace
id|useProtocol
suffix:colon
id|US_SC_UFI
comma
id|useTransport
suffix:colon
id|US_PR_CB
)brace
comma
(brace
id|useProtocol
suffix:colon
id|US_SC_8070
comma
id|useTransport
suffix:colon
id|US_PR_CB
)brace
comma
(brace
id|useProtocol
suffix:colon
id|US_SC_SCSI
comma
id|useTransport
suffix:colon
id|US_PR_CB
)brace
comma
multiline_comment|/* Control/Bulk/Interrupt transport for all SubClass values */
(brace
id|useProtocol
suffix:colon
id|US_SC_RBC
comma
id|useTransport
suffix:colon
id|US_PR_CBI
)brace
comma
(brace
id|useProtocol
suffix:colon
id|US_SC_8020
comma
id|useTransport
suffix:colon
id|US_PR_CBI
)brace
comma
(brace
id|useProtocol
suffix:colon
id|US_SC_QIC
comma
id|useTransport
suffix:colon
id|US_PR_CBI
)brace
comma
(brace
id|useProtocol
suffix:colon
id|US_SC_UFI
comma
id|useTransport
suffix:colon
id|US_PR_CBI
)brace
comma
(brace
id|useProtocol
suffix:colon
id|US_SC_8070
comma
id|useTransport
suffix:colon
id|US_PR_CBI
)brace
comma
(brace
id|useProtocol
suffix:colon
id|US_SC_SCSI
comma
id|useTransport
suffix:colon
id|US_PR_CBI
)brace
comma
multiline_comment|/* Bulk-only transport for all SubClass values */
(brace
id|useProtocol
suffix:colon
id|US_SC_RBC
comma
id|useTransport
suffix:colon
id|US_PR_BULK
)brace
comma
(brace
id|useProtocol
suffix:colon
id|US_SC_8020
comma
id|useTransport
suffix:colon
id|US_PR_BULK
)brace
comma
(brace
id|useProtocol
suffix:colon
id|US_SC_QIC
comma
id|useTransport
suffix:colon
id|US_PR_BULK
)brace
comma
(brace
id|useProtocol
suffix:colon
id|US_SC_UFI
comma
id|useTransport
suffix:colon
id|US_PR_BULK
)brace
comma
(brace
id|useProtocol
suffix:colon
id|US_SC_8070
comma
id|useTransport
suffix:colon
id|US_PR_BULK
)brace
comma
(brace
id|useProtocol
suffix:colon
id|US_SC_SCSI
comma
id|useTransport
suffix:colon
id|US_PR_BULK
)brace
comma
multiline_comment|/* Terminating entry */
(brace
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|usb_storage_driver
r_struct
id|usb_driver
id|usb_storage_driver
op_assign
(brace
id|name
suffix:colon
l_string|&quot;usb-storage&quot;
comma
id|probe
suffix:colon
id|storage_probe
comma
id|disconnect
suffix:colon
id|storage_disconnect
comma
id|id_table
suffix:colon
id|storage_usb_ids
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * fill_inquiry_response takes an unsigned char array (which must&n; * be at least 36 characters) and populates the vendor name,&n; * product name, and revision fields. Then the array is copied&n; * into the SCSI command&squot;s response buffer (oddly enough&n; * called request_buffer). data_len contains the length of the&n; * data array, which again must be at least 36.&n; */
DECL|function|fill_inquiry_response
r_void
id|fill_inquiry_response
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|data
comma
r_int
r_int
id|data_len
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
r_int
id|len
op_assign
id|us-&gt;srb-&gt;request_bufflen
OG
id|data_len
ques
c_cond
id|data_len
suffix:colon
id|us-&gt;srb-&gt;request_bufflen
suffix:semicolon
r_int
id|transferred
suffix:semicolon
r_int
id|amt
suffix:semicolon
r_if
c_cond
(paren
id|data_len
OL
l_int|36
)paren
singleline_comment|// You lose.
r_return
suffix:semicolon
r_if
c_cond
(paren
id|data
(braket
l_int|0
)braket
op_amp
l_int|0x20
)paren
(brace
multiline_comment|/* USB device currently not connected. Return&n;&t;&t;&t;      peripheral qualifier 001b (&quot;...however, the&n;&t;&t;&t;      physical device is not currently connected&n;&t;&t;&t;      to this logical unit&quot;) and leave vendor and&n;&t;&t;&t;      product identification empty. (&quot;If the target&n;&t;&t;&t;      does store some of the INQUIRY data on the&n;&t;&t;&t;      device, it may return zeros or ASCII spaces &n;&t;&t;&t;      (20h) in those fields until the data is&n;&t;&t;&t;      available from the device.&quot;). */
id|memset
c_func
(paren
id|data
op_plus
l_int|8
comma
l_int|0
comma
l_int|28
)paren
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|data
op_plus
l_int|8
comma
id|us-&gt;unusual_dev-&gt;vendorName
comma
id|strlen
c_func
(paren
id|us-&gt;unusual_dev-&gt;vendorName
)paren
OG
l_int|8
ques
c_cond
l_int|8
suffix:colon
id|strlen
c_func
(paren
id|us-&gt;unusual_dev-&gt;vendorName
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|data
op_plus
l_int|16
comma
id|us-&gt;unusual_dev-&gt;productName
comma
id|strlen
c_func
(paren
id|us-&gt;unusual_dev-&gt;productName
)paren
OG
l_int|16
ques
c_cond
l_int|16
suffix:colon
id|strlen
c_func
(paren
id|us-&gt;unusual_dev-&gt;productName
)paren
)paren
suffix:semicolon
id|data
(braket
l_int|32
)braket
op_assign
l_int|0x30
op_plus
(paren
(paren
id|us-&gt;pusb_dev-&gt;descriptor.bcdDevice
op_rshift
l_int|12
)paren
op_amp
l_int|0x0F
)paren
suffix:semicolon
id|data
(braket
l_int|33
)braket
op_assign
l_int|0x30
op_plus
(paren
(paren
id|us-&gt;pusb_dev-&gt;descriptor.bcdDevice
op_rshift
l_int|8
)paren
op_amp
l_int|0x0F
)paren
suffix:semicolon
id|data
(braket
l_int|34
)braket
op_assign
l_int|0x30
op_plus
(paren
(paren
id|us-&gt;pusb_dev-&gt;descriptor.bcdDevice
op_rshift
l_int|4
)paren
op_amp
l_int|0x0F
)paren
suffix:semicolon
id|data
(braket
l_int|35
)braket
op_assign
l_int|0x30
op_plus
(paren
(paren
id|us-&gt;pusb_dev-&gt;descriptor.bcdDevice
)paren
op_amp
l_int|0x0F
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|us-&gt;srb-&gt;use_sg
)paren
(brace
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|us-&gt;srb-&gt;request_buffer
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|us-&gt;srb-&gt;use_sg
suffix:semicolon
id|i
op_increment
)paren
id|memset
c_func
(paren
id|sg
(braket
id|i
)braket
dot
id|address
comma
l_int|0
comma
id|sg
(braket
id|i
)braket
dot
id|length
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|transferred
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|us-&gt;srb-&gt;use_sg
op_logical_and
id|transferred
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|amt
op_assign
id|sg
(braket
id|i
)braket
dot
id|length
OG
id|len
op_minus
id|transferred
ques
c_cond
id|len
op_minus
id|transferred
suffix:colon
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
id|memcpy
c_func
(paren
id|sg
(braket
id|i
)braket
dot
id|address
comma
id|data
op_plus
id|transferred
comma
id|amt
)paren
suffix:semicolon
id|transferred
op_sub_assign
id|amt
suffix:semicolon
)brace
)brace
r_else
(brace
id|memset
c_func
(paren
id|us-&gt;srb-&gt;request_buffer
comma
l_int|0
comma
id|us-&gt;srb-&gt;request_bufflen
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|us-&gt;srb-&gt;request_buffer
comma
id|data
comma
id|len
)paren
suffix:semicolon
)brace
)brace
DECL|function|usb_stor_control_thread
r_static
r_int
id|usb_stor_control_thread
c_func
(paren
r_void
op_star
id|__us
)paren
(brace
r_struct
id|us_data
op_star
id|us
op_assign
(paren
r_struct
id|us_data
op_star
)paren
id|__us
suffix:semicolon
r_int
id|action
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This thread doesn&squot;t need any user-level access,&n;&t; * so get rid of all our resources..&n;&t; */
id|daemonize
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* avoid getting signals */
id|spin_lock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
id|flush_signals
c_func
(paren
id|current
)paren
suffix:semicolon
id|sigfillset
c_func
(paren
op_amp
id|current-&gt;blocked
)paren
suffix:semicolon
id|recalc_sigpending
c_func
(paren
id|current
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
multiline_comment|/* set our name for identification purposes */
id|sprintf
c_func
(paren
id|current-&gt;comm
comma
l_string|&quot;usb-storage-%d&quot;
comma
id|us-&gt;host_number
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* set up for wakeups by new commands */
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
id|us-&gt;sema
)paren
suffix:semicolon
multiline_comment|/* signal that we&squot;ve started the thread */
id|complete
c_func
(paren
op_amp
(paren
id|us-&gt;notify
)paren
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;*** thread sleeping.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|down_interruptible
c_func
(paren
op_amp
id|us-&gt;sema
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;*** thread awakened.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* lock access to the queue element */
id|down
c_func
(paren
op_amp
(paren
id|us-&gt;queue_exclusion
)paren
)paren
suffix:semicolon
multiline_comment|/* take the command off the queue */
id|action
op_assign
id|us-&gt;action
suffix:semicolon
id|us-&gt;action
op_assign
l_int|0
suffix:semicolon
id|us-&gt;srb
op_assign
id|us-&gt;queue_srb
suffix:semicolon
multiline_comment|/* release the queue lock as fast as possible */
id|up
c_func
(paren
op_amp
(paren
id|us-&gt;queue_exclusion
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|action
)paren
(brace
r_case
id|US_ACT_COMMAND
suffix:colon
multiline_comment|/* reject the command if the direction indicator &n;&t;&t;&t; * is UNKNOWN&n;&t;&t;&t; */
r_if
c_cond
(paren
id|us-&gt;srb-&gt;sc_data_direction
op_eq
id|SCSI_DATA_UNKNOWN
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;UNKNOWN data direction&bslash;n&quot;
)paren
suffix:semicolon
id|us-&gt;srb-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|us-&gt;srb
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|us-&gt;srb
)paren
suffix:semicolon
id|us-&gt;srb
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* reject if target != 0 or if LUN is higher than&n;&t;&t;&t; * the maximum known LUN&n;&t;&t;&t; */
r_if
c_cond
(paren
id|us-&gt;srb-&gt;target
op_logical_and
op_logical_neg
(paren
id|us-&gt;flags
op_amp
id|US_FL_SCM_MULT_TARG
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bad target number (%d/%d)&bslash;n&quot;
comma
id|us-&gt;srb-&gt;target
comma
id|us-&gt;srb-&gt;lun
)paren
suffix:semicolon
id|us-&gt;srb-&gt;result
op_assign
id|DID_BAD_TARGET
op_lshift
l_int|16
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|us-&gt;srb
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|us-&gt;srb
)paren
suffix:semicolon
id|us-&gt;srb
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|us-&gt;srb-&gt;lun
OG
id|us-&gt;max_lun
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bad LUN (%d/%d)&bslash;n&quot;
comma
id|us-&gt;srb-&gt;target
comma
id|us-&gt;srb-&gt;lun
)paren
suffix:semicolon
id|us-&gt;srb-&gt;result
op_assign
id|DID_BAD_TARGET
op_lshift
l_int|16
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|us-&gt;srb
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|us-&gt;srb
)paren
suffix:semicolon
id|us-&gt;srb
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* handle those devices which can&squot;t do a START_STOP */
r_if
c_cond
(paren
(paren
id|us-&gt;srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|START_STOP
)paren
op_logical_and
(paren
id|us-&gt;flags
op_amp
id|US_FL_START_STOP
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Skipping START_STOP command&bslash;n&quot;
)paren
suffix:semicolon
id|us-&gt;srb-&gt;result
op_assign
id|GOOD
op_lshift
l_int|1
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|us-&gt;srb
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|us-&gt;srb
)paren
suffix:semicolon
id|us-&gt;srb
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* lock the device pointers */
id|down
c_func
(paren
op_amp
(paren
id|us-&gt;dev_semaphore
)paren
)paren
suffix:semicolon
multiline_comment|/* our device has gone - pretend not ready */
r_if
c_cond
(paren
op_logical_neg
id|us-&gt;pusb_dev
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Request is for removed device&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* For REQUEST_SENSE, it&squot;s the data.  But&n;&t;&t;&t;&t; * for anything else, it should look like&n;&t;&t;&t;&t; * we auto-sensed for it.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|us-&gt;srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
)paren
(brace
id|memcpy
c_func
(paren
id|us-&gt;srb-&gt;request_buffer
comma
id|usb_stor_sense_notready
comma
r_sizeof
(paren
id|usb_stor_sense_notready
)paren
)paren
suffix:semicolon
id|us-&gt;srb-&gt;result
op_assign
id|GOOD
op_lshift
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|us-&gt;srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
(brace
r_int
r_char
id|data_ptr
(braket
l_int|36
)braket
op_assign
(brace
l_int|0x20
comma
l_int|0x80
comma
l_int|0x02
comma
l_int|0x02
comma
l_int|0x1F
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Faking INQUIRY command for disconnected device&bslash;n&quot;
)paren
suffix:semicolon
id|fill_inquiry_response
c_func
(paren
id|us
comma
id|data_ptr
comma
l_int|36
)paren
suffix:semicolon
id|us-&gt;srb-&gt;result
op_assign
id|GOOD
op_lshift
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|us-&gt;srb-&gt;sense_buffer
comma
id|usb_stor_sense_notready
comma
r_sizeof
(paren
id|usb_stor_sense_notready
)paren
)paren
suffix:semicolon
id|us-&gt;srb-&gt;result
op_assign
id|CHECK_CONDITION
op_lshift
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* !us-&gt;pusb_dev */
multiline_comment|/* Handle those devices which need us to fake &n;&t;&t;&t;&t; * their inquiry data */
r_if
c_cond
(paren
(paren
id|us-&gt;srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
op_logical_and
(paren
id|us-&gt;flags
op_amp
id|US_FL_FIX_INQUIRY
)paren
)paren
(brace
r_int
r_char
id|data_ptr
(braket
l_int|36
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0x80
comma
l_int|0x02
comma
l_int|0x02
comma
l_int|0x1F
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Faking INQUIRY command&bslash;n&quot;
)paren
suffix:semicolon
id|fill_inquiry_response
c_func
(paren
id|us
comma
id|data_ptr
comma
l_int|36
)paren
suffix:semicolon
id|us-&gt;srb-&gt;result
op_assign
id|GOOD
op_lshift
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* we&squot;ve got a command, let&squot;s do it! */
id|US_DEBUG
c_func
(paren
id|usb_stor_show_command
c_func
(paren
id|us-&gt;srb
)paren
)paren
suffix:semicolon
id|us
op_member_access_from_pointer
id|proto_handler
c_func
(paren
id|us-&gt;srb
comma
id|us
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* unlock the device pointers */
id|up
c_func
(paren
op_amp
(paren
id|us-&gt;dev_semaphore
)paren
)paren
suffix:semicolon
multiline_comment|/* indicate that the command is done */
r_if
c_cond
(paren
id|us-&gt;srb-&gt;result
op_ne
id|DID_ABORT
op_lshift
l_int|16
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;scsi cmd done, result=0x%x&bslash;n&quot;
comma
id|us-&gt;srb-&gt;result
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|us-&gt;srb
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|us-&gt;srb
)paren
suffix:semicolon
)brace
r_else
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;scsi command aborted&bslash;n&quot;
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|complete
c_func
(paren
op_amp
(paren
id|us-&gt;notify
)paren
)paren
suffix:semicolon
)brace
id|us-&gt;srb
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_ACT_DEVICE_RESET
suffix:colon
r_break
suffix:semicolon
r_case
id|US_ACT_BUS_RESET
suffix:colon
r_break
suffix:semicolon
r_case
id|US_ACT_HOST_RESET
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/* end switch on action */
multiline_comment|/* exit if we get a signal to exit */
r_if
c_cond
(paren
id|action
op_eq
id|US_ACT_EXIT
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- US_ACT_EXIT command received&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* for (;;) */
multiline_comment|/* clean up after ourselves */
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
multiline_comment|/* notify the exit routine that we&squot;re actually exiting now */
id|complete
c_func
(paren
op_amp
(paren
id|us-&gt;notify
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Set up the IRQ pipe and handler&n; * Note that this function assumes that all the data in the us_data&n; * strucuture is current.  This includes the ep_int field, which gives us&n; * the endpoint for the interrupt.&n; * Returns non-zero on failure, zero on success&n; */
DECL|function|usb_stor_allocate_irq
r_static
r_int
id|usb_stor_allocate_irq
c_func
(paren
r_struct
id|us_data
op_star
id|ss
)paren
(brace
r_int
r_int
id|pipe
suffix:semicolon
r_int
id|maxp
suffix:semicolon
r_int
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Allocating IRQ for CBI transport&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* lock access to the data structure */
id|down
c_func
(paren
op_amp
(paren
id|ss-&gt;irq_urb_sem
)paren
)paren
suffix:semicolon
multiline_comment|/* allocate the URB */
id|ss-&gt;irq_urb
op_assign
id|usb_alloc_urb
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ss-&gt;irq_urb
)paren
(brace
id|up
c_func
(paren
op_amp
(paren
id|ss-&gt;irq_urb_sem
)paren
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;couldn&squot;t allocate interrupt URB&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* calculate the pipe and max packet size */
id|pipe
op_assign
id|usb_rcvintpipe
c_func
(paren
id|ss-&gt;pusb_dev
comma
id|ss-&gt;ep_int-&gt;bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
)paren
suffix:semicolon
id|maxp
op_assign
id|usb_maxpacket
c_func
(paren
id|ss-&gt;pusb_dev
comma
id|pipe
comma
id|usb_pipeout
c_func
(paren
id|pipe
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|maxp
OG
r_sizeof
(paren
id|ss-&gt;irqbuf
)paren
)paren
id|maxp
op_assign
r_sizeof
(paren
id|ss-&gt;irqbuf
)paren
suffix:semicolon
multiline_comment|/* fill in the URB with our data */
id|FILL_INT_URB
c_func
(paren
id|ss-&gt;irq_urb
comma
id|ss-&gt;pusb_dev
comma
id|pipe
comma
id|ss-&gt;irqbuf
comma
id|maxp
comma
id|usb_stor_CBI_irq
comma
id|ss
comma
id|ss-&gt;ep_int-&gt;bInterval
)paren
suffix:semicolon
multiline_comment|/* submit the URB for processing */
id|result
op_assign
id|usb_submit_urb
c_func
(paren
id|ss-&gt;irq_urb
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;usb_submit_urb() returns %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
id|usb_free_urb
c_func
(paren
id|ss-&gt;irq_urb
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
(paren
id|ss-&gt;irq_urb_sem
)paren
)paren
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
multiline_comment|/* unlock the data structure and return success */
id|up
c_func
(paren
op_amp
(paren
id|ss-&gt;irq_urb_sem
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Probe to see if a new device is actually a SCSI device */
DECL|function|storage_probe
r_static
r_void
op_star
id|storage_probe
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|ifnum
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
(brace
r_int
id|i
suffix:semicolon
r_const
r_int
id|id_index
op_assign
id|id
op_minus
id|storage_usb_ids
suffix:semicolon
r_char
id|mf
(braket
id|USB_STOR_STRING_LEN
)braket
suffix:semicolon
multiline_comment|/* manufacturer */
r_char
id|prod
(braket
id|USB_STOR_STRING_LEN
)braket
suffix:semicolon
multiline_comment|/* product */
r_char
id|serial
(braket
id|USB_STOR_STRING_LEN
)braket
suffix:semicolon
multiline_comment|/* serial number */
id|GUID
c_func
(paren
id|guid
)paren
suffix:semicolon
multiline_comment|/* Global Unique Identifier */
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|us_unusual_dev
op_star
id|unusual_dev
suffix:semicolon
r_struct
id|us_data
op_star
id|ss
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef CONFIG_USB_STORAGE_SDDR09
r_int
id|result
suffix:semicolon
macro_line|#endif
multiline_comment|/* these are temporary copies -- we test on these, then put them&n;&t; * in the us-data structure &n;&t; */
r_struct
id|usb_endpoint_descriptor
op_star
id|ep_in
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|ep_out
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|ep_int
op_assign
l_int|NULL
suffix:semicolon
id|u8
id|subclass
op_assign
l_int|0
suffix:semicolon
id|u8
id|protocol
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* the altsettting on the interface we&squot;re probing that matched our&n;&t; * usb_match_id table&n;&t; */
r_struct
id|usb_interface
op_star
id|intf
op_assign
id|dev-&gt;actconfig-&gt;interface
suffix:semicolon
r_struct
id|usb_interface_descriptor
op_star
id|altsetting
op_assign
id|intf
(braket
id|ifnum
)braket
dot
id|altsetting
op_plus
id|intf
(braket
id|ifnum
)braket
dot
id|act_altsetting
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;act_altsettting is %d&bslash;n&quot;
comma
id|intf
(braket
id|ifnum
)braket
dot
id|act_altsetting
)paren
suffix:semicolon
multiline_comment|/* clear the temporary strings */
id|memset
c_func
(paren
id|mf
comma
l_int|0
comma
r_sizeof
(paren
id|mf
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|prod
comma
l_int|0
comma
r_sizeof
(paren
id|prod
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|serial
comma
l_int|0
comma
r_sizeof
(paren
id|serial
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Can we support this device, either because we know about it&n;&t; * from our unusual device list, or because it advertises that it&squot;s&n;&t; * compliant to the specification?&n;&t; *&n;&t; * id_index is calculated in the declaration to be the index number&n;&t; * of the match from the usb_device_id table, so we can find the&n;&t; * corresponding entry in the private table.&n;&t; */
id|US_DEBUGP
c_func
(paren
l_string|&quot;id_index calculated to be: %d&bslash;n&quot;
comma
id|id_index
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Array length appears to be: %d&bslash;n&quot;
comma
r_sizeof
(paren
id|us_unusual_dev_list
)paren
op_div
r_sizeof
(paren
id|us_unusual_dev_list
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id_index
OL
r_sizeof
(paren
id|us_unusual_dev_list
)paren
op_div
r_sizeof
(paren
id|us_unusual_dev_list
(braket
l_int|0
)braket
)paren
)paren
(brace
id|unusual_dev
op_assign
op_amp
id|us_unusual_dev_list
(braket
id|id_index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|unusual_dev-&gt;vendorName
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;Vendor: %s&bslash;n&quot;
comma
id|unusual_dev-&gt;vendorName
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unusual_dev-&gt;productName
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;Product: %s&bslash;n&quot;
comma
id|unusual_dev-&gt;productName
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* no, we can&squot;t support it */
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* At this point, we know we&squot;ve got a live one */
id|US_DEBUGP
c_func
(paren
l_string|&quot;USB Mass Storage device detected&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Determine subclass and protocol, or copy from the interface */
id|subclass
op_assign
id|unusual_dev-&gt;useProtocol
suffix:semicolon
id|protocol
op_assign
id|unusual_dev-&gt;useTransport
suffix:semicolon
id|flags
op_assign
id|unusual_dev-&gt;flags
suffix:semicolon
multiline_comment|/*&n;&t; * Find the endpoints we need&n;&t; * We are expecting a minimum of 2 endpoints - in and out (bulk).&n;&t; * An optional interrupt is OK (necessary for CBI protocol).&n;&t; * We will ignore any others.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|altsetting-&gt;bNumEndpoints
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* is it an BULK endpoint? */
r_if
c_cond
(paren
(paren
id|altsetting-&gt;endpoint
(braket
id|i
)braket
dot
id|bmAttributes
op_amp
id|USB_ENDPOINT_XFERTYPE_MASK
)paren
op_eq
id|USB_ENDPOINT_XFER_BULK
)paren
(brace
multiline_comment|/* BULK in or out? */
r_if
c_cond
(paren
id|altsetting-&gt;endpoint
(braket
id|i
)braket
dot
id|bEndpointAddress
op_amp
id|USB_DIR_IN
)paren
id|ep_in
op_assign
op_amp
id|altsetting-&gt;endpoint
(braket
id|i
)braket
suffix:semicolon
r_else
id|ep_out
op_assign
op_amp
id|altsetting-&gt;endpoint
(braket
id|i
)braket
suffix:semicolon
)brace
multiline_comment|/* is it an interrupt endpoint? */
r_if
c_cond
(paren
(paren
id|altsetting-&gt;endpoint
(braket
id|i
)braket
dot
id|bmAttributes
op_amp
id|USB_ENDPOINT_XFERTYPE_MASK
)paren
op_eq
id|USB_ENDPOINT_XFER_INT
)paren
(brace
id|ep_int
op_assign
op_amp
id|altsetting-&gt;endpoint
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Endpoints: In: 0x%p Out: 0x%p Int: 0x%p (Period %d)&bslash;n&quot;
comma
id|ep_in
comma
id|ep_out
comma
id|ep_int
comma
id|ep_int
ques
c_cond
id|ep_int-&gt;bInterval
suffix:colon
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_USB_STORAGE_SDDR09
r_if
c_cond
(paren
id|protocol
op_eq
id|US_PR_EUSB_SDDR09
op_logical_or
id|protocol
op_eq
id|US_PR_DPCM_USB
)paren
(brace
multiline_comment|/* set the configuration -- STALL is an acceptable response here */
id|result
op_assign
id|usb_set_configuration
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Result from usb_set_configuration is %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- clearing stall on control interface&bslash;n&quot;
)paren
suffix:semicolon
id|usb_clear_halt
c_func
(paren
id|dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|result
op_ne
l_int|0
)paren
(brace
multiline_comment|/* it&squot;s not a stall, but another error -- time to bail */
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- Unknown error.  Rejecting device&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/* Do some basic sanity checks, and bail if we find a problem */
r_if
c_cond
(paren
op_logical_neg
id|ep_in
op_logical_or
op_logical_neg
id|ep_out
op_logical_or
(paren
id|protocol
op_eq
id|US_PR_CBI
op_logical_and
op_logical_neg
id|ep_int
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Endpoint sanity check failed! Rejecting dev.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* At this point, we&squot;re committed to using the device */
id|usb_inc_dev_use
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* clear the GUID and fetch the strings */
id|GUID_CLEAR
c_func
(paren
id|guid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;descriptor.iManufacturer
)paren
id|usb_string
c_func
(paren
id|dev
comma
id|dev-&gt;descriptor.iManufacturer
comma
id|mf
comma
r_sizeof
(paren
id|mf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;descriptor.iProduct
)paren
id|usb_string
c_func
(paren
id|dev
comma
id|dev-&gt;descriptor.iProduct
comma
id|prod
comma
r_sizeof
(paren
id|prod
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;descriptor.iSerialNumber
op_logical_and
op_logical_neg
(paren
id|flags
op_amp
id|US_FL_IGNORE_SER
)paren
)paren
id|usb_string
c_func
(paren
id|dev
comma
id|dev-&gt;descriptor.iSerialNumber
comma
id|serial
comma
r_sizeof
(paren
id|serial
)paren
)paren
suffix:semicolon
multiline_comment|/* Create a GUID for this device */
r_if
c_cond
(paren
id|dev-&gt;descriptor.iSerialNumber
op_logical_and
id|serial
(braket
l_int|0
)braket
)paren
(brace
multiline_comment|/* If we have a serial number, and it&squot;s a non-NULL string */
id|make_guid
c_func
(paren
id|guid
comma
id|dev-&gt;descriptor.idVendor
comma
id|dev-&gt;descriptor.idProduct
comma
id|serial
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We don&squot;t have a serial number, so we use 0 */
id|make_guid
c_func
(paren
id|guid
comma
id|dev-&gt;descriptor.idVendor
comma
id|dev-&gt;descriptor.idProduct
comma
l_string|&quot;0&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now check if we have seen this GUID before&n;&t; * We&squot;re looking for a device with a matching GUID that isn&squot;t&n;&t; * already on the system&n;&t; */
id|ss
op_assign
id|us_list
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ss
op_ne
l_int|NULL
)paren
op_logical_and
(paren
(paren
id|ss-&gt;pusb_dev
)paren
op_logical_or
op_logical_neg
id|GUID_EQUAL
c_func
(paren
id|guid
comma
id|ss-&gt;guid
)paren
)paren
)paren
id|ss
op_assign
id|ss-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|ss
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Existing device -- re-connect */
id|US_DEBUGP
c_func
(paren
l_string|&quot;Found existing GUID &quot;
id|GUID_FORMAT
l_string|&quot;&bslash;n&quot;
comma
id|GUID_ARGS
c_func
(paren
id|guid
)paren
)paren
suffix:semicolon
multiline_comment|/* lock the device pointers */
id|down
c_func
(paren
op_amp
(paren
id|ss-&gt;dev_semaphore
)paren
)paren
suffix:semicolon
multiline_comment|/* establish the connection to the new device upon reconnect */
id|ss-&gt;ifnum
op_assign
id|ifnum
suffix:semicolon
id|ss-&gt;pusb_dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/* copy over the endpoint data */
r_if
c_cond
(paren
id|ep_in
)paren
id|ss-&gt;ep_in
op_assign
id|ep_in-&gt;bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
suffix:semicolon
r_if
c_cond
(paren
id|ep_out
)paren
id|ss-&gt;ep_out
op_assign
id|ep_out-&gt;bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
suffix:semicolon
id|ss-&gt;ep_int
op_assign
id|ep_int
suffix:semicolon
multiline_comment|/* allocate an IRQ callback if one is needed */
r_if
c_cond
(paren
(paren
id|ss-&gt;protocol
op_eq
id|US_PR_CBI
)paren
op_logical_and
id|usb_stor_allocate_irq
c_func
(paren
id|ss
)paren
)paren
(brace
id|usb_dec_dev_use
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* allocate the URB we&squot;re going to use */
id|ss-&gt;current_urb
op_assign
id|usb_alloc_urb
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ss-&gt;current_urb
)paren
(brace
id|usb_dec_dev_use
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Re-Initialize the device if it needs it */
r_if
c_cond
(paren
id|unusual_dev
op_logical_and
id|unusual_dev-&gt;initFunction
)paren
(paren
id|unusual_dev-&gt;initFunction
)paren
(paren
id|ss
)paren
suffix:semicolon
multiline_comment|/* unlock the device pointers */
id|up
c_func
(paren
op_amp
(paren
id|ss-&gt;dev_semaphore
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* New device -- allocate memory and initialize */
id|US_DEBUGP
c_func
(paren
l_string|&quot;New GUID &quot;
id|GUID_FORMAT
l_string|&quot;&bslash;n&quot;
comma
id|GUID_ARGS
c_func
(paren
id|guid
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ss
op_assign
(paren
r_struct
id|us_data
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|us_data
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|USB_STORAGE
l_string|&quot;Out of memory&bslash;n&quot;
)paren
suffix:semicolon
id|usb_dec_dev_use
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ss
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|us_data
)paren
)paren
suffix:semicolon
multiline_comment|/* allocate the URB we&squot;re going to use */
id|ss-&gt;current_urb
op_assign
id|usb_alloc_urb
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ss-&gt;current_urb
)paren
(brace
id|kfree
c_func
(paren
id|ss
)paren
suffix:semicolon
id|usb_dec_dev_use
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Initialize the mutexes only when the struct is new */
id|init_completion
c_func
(paren
op_amp
(paren
id|ss-&gt;notify
)paren
)paren
suffix:semicolon
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
(paren
id|ss-&gt;ip_waitq
)paren
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
(paren
id|ss-&gt;queue_exclusion
)paren
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
(paren
id|ss-&gt;irq_urb_sem
)paren
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
(paren
id|ss-&gt;current_urb_sem
)paren
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
(paren
id|ss-&gt;dev_semaphore
)paren
)paren
suffix:semicolon
multiline_comment|/* copy over the subclass and protocol data */
id|ss-&gt;subclass
op_assign
id|subclass
suffix:semicolon
id|ss-&gt;protocol
op_assign
id|protocol
suffix:semicolon
id|ss-&gt;flags
op_assign
id|flags
suffix:semicolon
id|ss-&gt;unusual_dev
op_assign
id|unusual_dev
suffix:semicolon
multiline_comment|/* copy over the endpoint data */
r_if
c_cond
(paren
id|ep_in
)paren
id|ss-&gt;ep_in
op_assign
id|ep_in-&gt;bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
suffix:semicolon
r_if
c_cond
(paren
id|ep_out
)paren
id|ss-&gt;ep_out
op_assign
id|ep_out-&gt;bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
suffix:semicolon
id|ss-&gt;ep_int
op_assign
id|ep_int
suffix:semicolon
multiline_comment|/* establish the connection to the new device */
id|ss-&gt;ifnum
op_assign
id|ifnum
suffix:semicolon
id|ss-&gt;pusb_dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/* copy over the identifiying strings */
id|strncpy
c_func
(paren
id|ss-&gt;vendor
comma
id|mf
comma
id|USB_STOR_STRING_LEN
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|ss-&gt;product
comma
id|prod
comma
id|USB_STOR_STRING_LEN
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|ss-&gt;serial
comma
id|serial
comma
id|USB_STOR_STRING_LEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|ss-&gt;vendor
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|unusual_dev-&gt;vendorName
)paren
id|strncpy
c_func
(paren
id|ss-&gt;vendor
comma
id|unusual_dev-&gt;vendorName
comma
id|USB_STOR_STRING_LEN
)paren
suffix:semicolon
r_else
id|strncpy
c_func
(paren
id|ss-&gt;vendor
comma
l_string|&quot;Unknown&quot;
comma
id|USB_STOR_STRING_LEN
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|ss-&gt;product
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|unusual_dev-&gt;productName
)paren
id|strncpy
c_func
(paren
id|ss-&gt;product
comma
id|unusual_dev-&gt;productName
comma
id|USB_STOR_STRING_LEN
)paren
suffix:semicolon
r_else
id|strncpy
c_func
(paren
id|ss-&gt;product
comma
l_string|&quot;Unknown&quot;
comma
id|USB_STOR_STRING_LEN
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|ss-&gt;serial
)paren
op_eq
l_int|0
)paren
id|strncpy
c_func
(paren
id|ss-&gt;serial
comma
l_string|&quot;None&quot;
comma
id|USB_STOR_STRING_LEN
)paren
suffix:semicolon
multiline_comment|/* copy the GUID we created before */
id|memcpy
c_func
(paren
id|ss-&gt;guid
comma
id|guid
comma
r_sizeof
(paren
id|guid
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * Set the handler pointers based on the protocol&n;&t;&t; * Again, this data is persistant across reattachments&n;&t;&t; */
r_switch
c_cond
(paren
id|ss-&gt;protocol
)paren
(brace
r_case
id|US_PR_CB
suffix:colon
id|ss-&gt;transport_name
op_assign
l_string|&quot;Control/Bulk&quot;
suffix:semicolon
id|ss-&gt;transport
op_assign
id|usb_stor_CB_transport
suffix:semicolon
id|ss-&gt;transport_reset
op_assign
id|usb_stor_CB_reset
suffix:semicolon
id|ss-&gt;max_lun
op_assign
l_int|7
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_PR_CBI
suffix:colon
id|ss-&gt;transport_name
op_assign
l_string|&quot;Control/Bulk/Interrupt&quot;
suffix:semicolon
id|ss-&gt;transport
op_assign
id|usb_stor_CBI_transport
suffix:semicolon
id|ss-&gt;transport_reset
op_assign
id|usb_stor_CB_reset
suffix:semicolon
id|ss-&gt;max_lun
op_assign
l_int|7
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_PR_BULK
suffix:colon
id|ss-&gt;transport_name
op_assign
l_string|&quot;Bulk&quot;
suffix:semicolon
id|ss-&gt;transport
op_assign
id|usb_stor_Bulk_transport
suffix:semicolon
id|ss-&gt;transport_reset
op_assign
id|usb_stor_Bulk_reset
suffix:semicolon
id|ss-&gt;max_lun
op_assign
id|usb_stor_Bulk_max_lun
c_func
(paren
id|ss
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef CONFIG_USB_STORAGE_HP8200e
r_case
id|US_PR_SCM_ATAPI
suffix:colon
id|ss-&gt;transport_name
op_assign
l_string|&quot;SCM/ATAPI&quot;
suffix:semicolon
id|ss-&gt;transport
op_assign
id|hp8200e_transport
suffix:semicolon
id|ss-&gt;transport_reset
op_assign
id|usb_stor_CB_reset
suffix:semicolon
id|ss-&gt;max_lun
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_SDDR09
r_case
id|US_PR_EUSB_SDDR09
suffix:colon
id|ss-&gt;transport_name
op_assign
l_string|&quot;EUSB/SDDR09&quot;
suffix:semicolon
id|ss-&gt;transport
op_assign
id|sddr09_transport
suffix:semicolon
id|ss-&gt;transport_reset
op_assign
id|usb_stor_CB_reset
suffix:semicolon
id|ss-&gt;max_lun
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_DPCM
r_case
id|US_PR_DPCM_USB
suffix:colon
id|ss-&gt;transport_name
op_assign
l_string|&quot;Control/Bulk-EUSB/SDDR09&quot;
suffix:semicolon
id|ss-&gt;transport
op_assign
id|dpcm_transport
suffix:semicolon
id|ss-&gt;transport_reset
op_assign
id|usb_stor_CB_reset
suffix:semicolon
id|ss-&gt;max_lun
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_FREECOM
r_case
id|US_PR_FREECOM
suffix:colon
id|ss-&gt;transport_name
op_assign
l_string|&quot;Freecom&quot;
suffix:semicolon
id|ss-&gt;transport
op_assign
id|freecom_transport
suffix:semicolon
id|ss-&gt;transport_reset
op_assign
id|usb_stor_freecom_reset
suffix:semicolon
id|ss-&gt;max_lun
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_DATAFAB
r_case
id|US_PR_DATAFAB
suffix:colon
id|ss-&gt;transport_name
op_assign
l_string|&quot;Datafab Bulk-Only&quot;
suffix:semicolon
id|ss-&gt;transport
op_assign
id|datafab_transport
suffix:semicolon
id|ss-&gt;transport_reset
op_assign
id|usb_stor_Bulk_reset
suffix:semicolon
id|ss-&gt;max_lun
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_JUMPSHOT
r_case
id|US_PR_JUMPSHOT
suffix:colon
id|ss-&gt;transport_name
op_assign
l_string|&quot;Lexar Jumpshot Control/Bulk&quot;
suffix:semicolon
id|ss-&gt;transport
op_assign
id|jumpshot_transport
suffix:semicolon
id|ss-&gt;transport_reset
op_assign
id|usb_stor_Bulk_reset
suffix:semicolon
id|ss-&gt;max_lun
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
id|ss-&gt;transport_name
op_assign
l_string|&quot;Unknown&quot;
suffix:semicolon
id|kfree
c_func
(paren
id|ss-&gt;current_urb
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ss
)paren
suffix:semicolon
id|usb_dec_dev_use
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Transport: %s&bslash;n&quot;
comma
id|ss-&gt;transport_name
)paren
suffix:semicolon
multiline_comment|/* fix for single-lun devices */
r_if
c_cond
(paren
id|ss-&gt;flags
op_amp
id|US_FL_SINGLE_LUN
)paren
id|ss-&gt;max_lun
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|ss-&gt;subclass
)paren
(brace
r_case
id|US_SC_RBC
suffix:colon
id|ss-&gt;protocol_name
op_assign
l_string|&quot;Reduced Block Commands (RBC)&quot;
suffix:semicolon
id|ss-&gt;proto_handler
op_assign
id|usb_stor_transparent_scsi_command
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_SC_8020
suffix:colon
id|ss-&gt;protocol_name
op_assign
l_string|&quot;8020i&quot;
suffix:semicolon
id|ss-&gt;proto_handler
op_assign
id|usb_stor_ATAPI_command
suffix:semicolon
id|ss-&gt;max_lun
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_SC_QIC
suffix:colon
id|ss-&gt;protocol_name
op_assign
l_string|&quot;QIC-157&quot;
suffix:semicolon
id|ss-&gt;proto_handler
op_assign
id|usb_stor_qic157_command
suffix:semicolon
id|ss-&gt;max_lun
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_SC_8070
suffix:colon
id|ss-&gt;protocol_name
op_assign
l_string|&quot;8070i&quot;
suffix:semicolon
id|ss-&gt;proto_handler
op_assign
id|usb_stor_ATAPI_command
suffix:semicolon
id|ss-&gt;max_lun
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_SC_SCSI
suffix:colon
id|ss-&gt;protocol_name
op_assign
l_string|&quot;Transparent SCSI&quot;
suffix:semicolon
id|ss-&gt;proto_handler
op_assign
id|usb_stor_transparent_scsi_command
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_SC_UFI
suffix:colon
id|ss-&gt;protocol_name
op_assign
l_string|&quot;Uniform Floppy Interface (UFI)&quot;
suffix:semicolon
id|ss-&gt;proto_handler
op_assign
id|usb_stor_ufi_command
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef CONFIG_USB_STORAGE_ISD200
r_case
id|US_SC_ISD200
suffix:colon
id|ss-&gt;protocol_name
op_assign
l_string|&quot;ISD200 ATA/ATAPI&quot;
suffix:semicolon
id|ss-&gt;proto_handler
op_assign
id|isd200_ata_command
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
id|ss-&gt;protocol_name
op_assign
l_string|&quot;Unknown&quot;
suffix:semicolon
id|kfree
c_func
(paren
id|ss-&gt;current_urb
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ss
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Protocol: %s&bslash;n&quot;
comma
id|ss-&gt;protocol_name
)paren
suffix:semicolon
multiline_comment|/* allocate an IRQ callback if one is needed */
r_if
c_cond
(paren
(paren
id|ss-&gt;protocol
op_eq
id|US_PR_CBI
)paren
op_logical_and
id|usb_stor_allocate_irq
c_func
(paren
id|ss
)paren
)paren
(brace
id|usb_dec_dev_use
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Since this is a new device, we need to generate a scsi &n;&t;&t; * host definition, and register with the higher SCSI layers&n;&t;&t; */
multiline_comment|/* Initialize the host template based on the default one */
id|memcpy
c_func
(paren
op_amp
(paren
id|ss-&gt;htmplt
)paren
comma
op_amp
id|usb_stor_host_template
comma
r_sizeof
(paren
id|usb_stor_host_template
)paren
)paren
suffix:semicolon
multiline_comment|/* Grab the next host number */
id|ss-&gt;host_number
op_assign
id|my_host_number
op_increment
suffix:semicolon
multiline_comment|/* We abuse this pointer so we can pass the ss pointer to &n;&t;&t; * the host controller thread in us_detect.  But how else are&n;&t;&t; * we to do it?&n;&t;&t; */
(paren
r_struct
id|us_data
op_star
)paren
id|ss-&gt;htmplt.proc_dir
op_assign
id|ss
suffix:semicolon
multiline_comment|/* Just before we start our control thread, initialize&n;&t;&t; * the device if it needs initialization */
r_if
c_cond
(paren
id|unusual_dev
op_logical_and
id|unusual_dev-&gt;initFunction
)paren
id|unusual_dev
op_member_access_from_pointer
id|initFunction
c_func
(paren
id|ss
)paren
suffix:semicolon
multiline_comment|/* start up our control thread */
id|ss-&gt;pid
op_assign
id|kernel_thread
c_func
(paren
id|usb_stor_control_thread
comma
id|ss
comma
id|CLONE_VM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ss-&gt;pid
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|USB_STORAGE
l_string|&quot;Unable to start control thread&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ss-&gt;current_urb
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ss
)paren
suffix:semicolon
id|usb_dec_dev_use
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* wait for the thread to start */
id|wait_for_completion
c_func
(paren
op_amp
(paren
id|ss-&gt;notify
)paren
)paren
suffix:semicolon
multiline_comment|/* now register&t; - our detect function will be called */
id|ss-&gt;htmplt.module
op_assign
id|THIS_MODULE
suffix:semicolon
id|scsi_register_host
c_func
(paren
op_amp
id|ss-&gt;htmplt
)paren
suffix:semicolon
multiline_comment|/* lock access to the data structures */
id|down
c_func
(paren
op_amp
id|us_list_semaphore
)paren
suffix:semicolon
multiline_comment|/* put us in the list */
id|ss-&gt;next
op_assign
id|us_list
suffix:semicolon
id|us_list
op_assign
id|ss
suffix:semicolon
multiline_comment|/* release the data structure lock */
id|up
c_func
(paren
op_amp
id|us_list_semaphore
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;WARNING: USB Mass Storage data integrity not assured&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;USB Mass Storage device found at %d&bslash;n&quot;
comma
id|dev-&gt;devnum
)paren
suffix:semicolon
multiline_comment|/* return a pointer for the disconnect function */
r_return
id|ss
suffix:semicolon
)brace
multiline_comment|/* Handle a disconnect event from the USB core */
DECL|function|storage_disconnect
r_static
r_void
id|storage_disconnect
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|us_data
op_star
id|ss
op_assign
id|ptr
suffix:semicolon
r_int
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;storage_disconnect() called&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* this is the odd case -- we disconnected but weren&squot;t using it */
r_if
c_cond
(paren
op_logical_neg
id|ss
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- device was not in use&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* lock access to the device data structure */
id|down
c_func
(paren
op_amp
(paren
id|ss-&gt;dev_semaphore
)paren
)paren
suffix:semicolon
multiline_comment|/* release the IRQ, if we have one */
id|down
c_func
(paren
op_amp
(paren
id|ss-&gt;irq_urb_sem
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ss-&gt;irq_urb
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- releasing irq URB&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|usb_unlink_urb
c_func
(paren
id|ss-&gt;irq_urb
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- usb_unlink_urb() returned %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
id|usb_free_urb
c_func
(paren
id|ss-&gt;irq_urb
)paren
suffix:semicolon
id|ss-&gt;irq_urb
op_assign
l_int|NULL
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
(paren
id|ss-&gt;irq_urb_sem
)paren
)paren
suffix:semicolon
multiline_comment|/* free up the main URB for this device */
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- releasing main URB&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|usb_unlink_urb
c_func
(paren
id|ss-&gt;current_urb
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- usb_unlink_urb() returned %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
id|usb_free_urb
c_func
(paren
id|ss-&gt;current_urb
)paren
suffix:semicolon
id|ss-&gt;current_urb
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* mark the device as gone */
id|usb_dec_dev_use
c_func
(paren
id|ss-&gt;pusb_dev
)paren
suffix:semicolon
id|ss-&gt;pusb_dev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* unlock access to the device data structure */
id|up
c_func
(paren
op_amp
(paren
id|ss-&gt;dev_semaphore
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/***********************************************************************&n; * Initialization and registration&n; ***********************************************************************/
DECL|function|usb_stor_init
r_int
id|__init
id|usb_stor_init
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Initializing USB Mass Storage driver...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* initialize internal global data elements */
id|us_list
op_assign
l_int|NULL
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|us_list_semaphore
)paren
suffix:semicolon
id|my_host_number
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* register the driver, return -1 if error */
r_if
c_cond
(paren
id|usb_register
c_func
(paren
op_amp
id|usb_storage_driver
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* we&squot;re all set */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;USB Mass Storage support registered.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usb_stor_exit
r_void
id|__exit
id|usb_stor_exit
c_func
(paren
r_void
)paren
(brace
r_struct
id|us_data
op_star
id|next
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;usb_stor_exit() called&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Deregister the driver&n;&t; * This eliminates races with probes and disconnects &n;&t; */
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- calling usb_deregister()&bslash;n&quot;
)paren
suffix:semicolon
id|usb_deregister
c_func
(paren
op_amp
id|usb_storage_driver
)paren
suffix:semicolon
multiline_comment|/* While there are still virtual hosts, unregister them&n;&t; * Note that it&squot;s important to do this completely before removing&n;&t; * the structures because of possible races with the /proc&n;&t; * interface&n;&t; */
r_for
c_loop
(paren
id|next
op_assign
id|us_list
suffix:semicolon
id|next
suffix:semicolon
id|next
op_assign
id|next-&gt;next
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- calling scsi_unregister_host()&bslash;n&quot;
)paren
suffix:semicolon
id|scsi_unregister_host
c_func
(paren
op_amp
id|next-&gt;htmplt
)paren
suffix:semicolon
)brace
multiline_comment|/* While there are still structures, free them.  Note that we are&n;&t; * now race-free, since these structures can no longer be accessed&n;&t; * from either the SCSI command layer or the /proc interface&n;&t; */
r_while
c_loop
(paren
id|us_list
)paren
(brace
multiline_comment|/* keep track of where the next one is */
id|next
op_assign
id|us_list-&gt;next
suffix:semicolon
multiline_comment|/* If there&squot;s extra data in the us_data structure then&n;&t;&t; * free that first */
r_if
c_cond
(paren
id|us_list-&gt;extra
)paren
(brace
multiline_comment|/* call the destructor routine, if it exists */
r_if
c_cond
(paren
id|us_list-&gt;extra_destructor
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- calling extra_destructor()&bslash;n&quot;
)paren
suffix:semicolon
id|us_list
op_member_access_from_pointer
id|extra_destructor
c_func
(paren
id|us_list-&gt;extra
)paren
suffix:semicolon
)brace
multiline_comment|/* destroy the extra data */
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- freeing the data structure&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|us_list-&gt;extra
)paren
suffix:semicolon
)brace
multiline_comment|/* free the structure itself */
id|kfree
(paren
id|us_list
)paren
suffix:semicolon
multiline_comment|/* advance the list pointer */
id|us_list
op_assign
id|next
suffix:semicolon
)brace
)brace
DECL|variable|usb_stor_init
id|module_init
c_func
(paren
id|usb_stor_init
)paren
suffix:semicolon
DECL|variable|usb_stor_exit
id|module_exit
c_func
(paren
id|usb_stor_exit
)paren
suffix:semicolon
eof
