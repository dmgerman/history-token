multiline_comment|/* Driver for USB Mass Storage compliant devices&n; *&n; * $Id: usb.c,v 1.75 2002/04/22 03:39:43 mdharm Exp $&n; *&n; * Current development and maintenance by:&n; *   (c) 1999-2003 Matthew Dharm (mdharm-usb@one-eyed-alien.net)&n; *&n; * Developed with the assistance of:&n; *   (c) 2000 David L. Brown, Jr. (usb-storage@davidb.org)&n; *   (c) 2003 Alan Stern (stern@rowland.harvard.edu)&n; *&n; * Initial work by:&n; *   (c) 1999 Michael Gee (michael@linuxspecific.com)&n; *&n; * usb_device_id support by Adam J. Richter (adam@yggdrasil.com):&n; *   (c) 2000 Yggdrasil Computing, Inc.&n; *&n; * This driver is based on the &squot;USB Mass Storage Class&squot; document. This&n; * describes in detail the protocol used to communicate with such&n; * devices.  Clearly, the designers had SCSI and ATAPI commands in&n; * mind when they created this document.  The commands are all very&n; * similar to commands in the SCSI-II and ATAPI specifications.&n; *&n; * It is important to note that in a number of cases this class&n; * exhibits class-specific exemptions from the USB specification.&n; * Notably the usage of NAK, STALL and ACK differs from the norm, in&n; * that they are used to communicate wait, failed and OK on commands.&n; *&n; * Also, for certain devices, the interrupt endpoint is used to convey&n; * status of a command.&n; *&n; * Please see http://www.one-eyed-alien.net/~mdharm/linux-usb for more&n; * information about this driver.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2, or (at your option) any&n; * later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write to the Free Software Foundation, Inc.,&n; * 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &quot;usb.h&quot;
macro_line|#include &quot;scsiglue.h&quot;
macro_line|#include &quot;transport.h&quot;
macro_line|#include &quot;protocol.h&quot;
macro_line|#include &quot;debug.h&quot;
macro_line|#include &quot;initializers.h&quot;
macro_line|#ifdef CONFIG_USB_STORAGE_HP8200e
macro_line|#include &quot;shuttle_usbat.h&quot;
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_SDDR09
macro_line|#include &quot;sddr09.h&quot;
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_SDDR55
macro_line|#include &quot;sddr55.h&quot;
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_DPCM
macro_line|#include &quot;dpcm.h&quot;
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_FREECOM
macro_line|#include &quot;freecom.h&quot;
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_ISD200
macro_line|#include &quot;isd200.h&quot;
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_DATAFAB
macro_line|#include &quot;datafab.h&quot;
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_JUMPSHOT
macro_line|#include &quot;jumpshot.h&quot;
macro_line|#endif
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
multiline_comment|/* Some informational data */
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;USB Mass Storage driver for Linux&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
r_static
r_int
id|storage_probe
c_func
(paren
r_struct
id|usb_interface
op_star
id|iface
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
suffix:semicolon
r_static
r_void
id|storage_disconnect
c_func
(paren
r_struct
id|usb_interface
op_star
id|iface
)paren
suffix:semicolon
multiline_comment|/* The entries in this table, except for final ones here&n; * (USB_MASS_STORAGE_CLASS and the empty entry), correspond,&n; * line for line with the entries of us_unsuaul_dev_list[].&n; */
DECL|macro|UNUSUAL_DEV
mdefine_line|#define UNUSUAL_DEV(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax, &bslash;&n;&t;&t;    vendorName, productName,useProtocol, useTransport, &bslash;&n;&t;&t;    initFunction, flags) &bslash;&n;{ USB_DEVICE_VER(id_vendor, id_product, bcdDeviceMin,bcdDeviceMax) }
DECL|variable|storage_usb_ids
r_static
r_struct
id|usb_device_id
id|storage_usb_ids
(braket
)braket
op_assign
(brace
macro_line|#&t;include &quot;unusual_devs.h&quot;
DECL|macro|UNUSUAL_DEV
macro_line|#undef UNUSUAL_DEV
multiline_comment|/* Control/Bulk transport for all SubClass values */
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_RBC
comma
id|US_PR_CB
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_8020
comma
id|US_PR_CB
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_QIC
comma
id|US_PR_CB
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_UFI
comma
id|US_PR_CB
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_8070
comma
id|US_PR_CB
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_SCSI
comma
id|US_PR_CB
)paren
)brace
comma
multiline_comment|/* Control/Bulk/Interrupt transport for all SubClass values */
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_RBC
comma
id|US_PR_CBI
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_8020
comma
id|US_PR_CBI
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_QIC
comma
id|US_PR_CBI
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_UFI
comma
id|US_PR_CBI
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_8070
comma
id|US_PR_CBI
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_SCSI
comma
id|US_PR_CBI
)paren
)brace
comma
multiline_comment|/* Bulk-only transport for all SubClass values */
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_RBC
comma
id|US_PR_BULK
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_8020
comma
id|US_PR_BULK
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_QIC
comma
id|US_PR_BULK
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_UFI
comma
id|US_PR_BULK
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_8070
comma
id|US_PR_BULK
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
id|USB_CLASS_MASS_STORAGE
comma
id|US_SC_SCSI
comma
id|US_PR_BULK
)paren
)brace
comma
multiline_comment|/* Terminating entry */
(brace
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
(paren
id|usb
comma
id|storage_usb_ids
)paren
suffix:semicolon
multiline_comment|/* This is the list of devices we recognize, along with their flag data */
multiline_comment|/* The vendor name should be kept at eight characters or less, and&n; * the product name should be kept at 16 characters or less. If a device&n; * has the US_FL_FIX_INQUIRY flag, then the vendor and product names&n; * normally generated by a device thorugh the INQUIRY response will be&n; * taken from this list, and this is the reason for the above size&n; * restriction. However, if the flag is not present, then you&n; * are free to use as many characters as you like.&n; */
DECL|macro|UNUSUAL_DEV
macro_line|#undef UNUSUAL_DEV
DECL|macro|UNUSUAL_DEV
mdefine_line|#define UNUSUAL_DEV(idVendor, idProduct, bcdDeviceMin, bcdDeviceMax, &bslash;&n;&t;&t;    vendor_name, product_name, use_protocol, use_transport, &bslash;&n;&t;&t;    init_function, Flags) &bslash;&n;{ &bslash;&n;&t;.vendorName = vendor_name,&t;&bslash;&n;&t;.productName = product_name,&t;&bslash;&n;&t;.useProtocol = use_protocol,&t;&bslash;&n;&t;.useTransport = use_transport,&t;&bslash;&n;&t;.initFunction = init_function,&t;&bslash;&n;&t;.flags = Flags, &bslash;&n;}
DECL|variable|us_unusual_dev_list
r_static
r_struct
id|us_unusual_dev
id|us_unusual_dev_list
(braket
)braket
op_assign
(brace
macro_line|#&t;include &quot;unusual_devs.h&quot; 
DECL|macro|UNUSUAL_DEV
macro_line|#&t;undef UNUSUAL_DEV
multiline_comment|/* Control/Bulk transport for all SubClass values */
(brace
dot
id|useProtocol
op_assign
id|US_SC_RBC
comma
dot
id|useTransport
op_assign
id|US_PR_CB
)brace
comma
(brace
dot
id|useProtocol
op_assign
id|US_SC_8020
comma
dot
id|useTransport
op_assign
id|US_PR_CB
)brace
comma
(brace
dot
id|useProtocol
op_assign
id|US_SC_QIC
comma
dot
id|useTransport
op_assign
id|US_PR_CB
)brace
comma
(brace
dot
id|useProtocol
op_assign
id|US_SC_UFI
comma
dot
id|useTransport
op_assign
id|US_PR_CB
)brace
comma
(brace
dot
id|useProtocol
op_assign
id|US_SC_8070
comma
dot
id|useTransport
op_assign
id|US_PR_CB
)brace
comma
(brace
dot
id|useProtocol
op_assign
id|US_SC_SCSI
comma
dot
id|useTransport
op_assign
id|US_PR_CB
)brace
comma
multiline_comment|/* Control/Bulk/Interrupt transport for all SubClass values */
(brace
dot
id|useProtocol
op_assign
id|US_SC_RBC
comma
dot
id|useTransport
op_assign
id|US_PR_CBI
)brace
comma
(brace
dot
id|useProtocol
op_assign
id|US_SC_8020
comma
dot
id|useTransport
op_assign
id|US_PR_CBI
)brace
comma
(brace
dot
id|useProtocol
op_assign
id|US_SC_QIC
comma
dot
id|useTransport
op_assign
id|US_PR_CBI
)brace
comma
(brace
dot
id|useProtocol
op_assign
id|US_SC_UFI
comma
dot
id|useTransport
op_assign
id|US_PR_CBI
)brace
comma
(brace
dot
id|useProtocol
op_assign
id|US_SC_8070
comma
dot
id|useTransport
op_assign
id|US_PR_CBI
)brace
comma
(brace
dot
id|useProtocol
op_assign
id|US_SC_SCSI
comma
dot
id|useTransport
op_assign
id|US_PR_CBI
)brace
comma
multiline_comment|/* Bulk-only transport for all SubClass values */
(brace
dot
id|useProtocol
op_assign
id|US_SC_RBC
comma
dot
id|useTransport
op_assign
id|US_PR_BULK
)brace
comma
(brace
dot
id|useProtocol
op_assign
id|US_SC_8020
comma
dot
id|useTransport
op_assign
id|US_PR_BULK
)brace
comma
(brace
dot
id|useProtocol
op_assign
id|US_SC_QIC
comma
dot
id|useTransport
op_assign
id|US_PR_BULK
)brace
comma
(brace
dot
id|useProtocol
op_assign
id|US_SC_UFI
comma
dot
id|useTransport
op_assign
id|US_PR_BULK
)brace
comma
(brace
dot
id|useProtocol
op_assign
id|US_SC_8070
comma
dot
id|useTransport
op_assign
id|US_PR_BULK
)brace
comma
(brace
dot
id|useProtocol
op_assign
id|US_SC_SCSI
comma
dot
id|useTransport
op_assign
id|US_PR_BULK
)brace
comma
multiline_comment|/* Terminating entry */
(brace
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|usb_storage_driver
r_struct
id|usb_driver
id|usb_storage_driver
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|name
op_assign
l_string|&quot;usb-storage&quot;
comma
dot
id|probe
op_assign
id|storage_probe
comma
dot
id|disconnect
op_assign
id|storage_disconnect
comma
dot
id|id_table
op_assign
id|storage_usb_ids
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * fill_inquiry_response takes an unsigned char array (which must&n; * be at least 36 characters) and populates the vendor name,&n; * product name, and revision fields. Then the array is copied&n; * into the SCSI command&squot;s response buffer (oddly enough&n; * called request_buffer). data_len contains the length of the&n; * data array, which again must be at least 36.&n; */
DECL|function|fill_inquiry_response
r_void
id|fill_inquiry_response
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
r_char
op_star
id|data
comma
r_int
r_int
id|data_len
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
r_int
id|len
op_assign
id|us-&gt;srb-&gt;request_bufflen
OG
id|data_len
ques
c_cond
id|data_len
suffix:colon
id|us-&gt;srb-&gt;request_bufflen
suffix:semicolon
r_int
id|transferred
suffix:semicolon
r_int
id|amt
suffix:semicolon
r_if
c_cond
(paren
id|data_len
OL
l_int|36
)paren
singleline_comment|// You lose.
r_return
suffix:semicolon
r_if
c_cond
(paren
id|data
(braket
l_int|0
)braket
op_amp
l_int|0x20
)paren
(brace
multiline_comment|/* USB device currently not connected. Return&n;&t;&t;&t;      peripheral qualifier 001b (&quot;...however, the&n;&t;&t;&t;      physical device is not currently connected&n;&t;&t;&t;      to this logical unit&quot;) and leave vendor and&n;&t;&t;&t;      product identification empty. (&quot;If the target&n;&t;&t;&t;      does store some of the INQUIRY data on the&n;&t;&t;&t;      device, it may return zeros or ASCII spaces &n;&t;&t;&t;      (20h) in those fields until the data is&n;&t;&t;&t;      available from the device.&quot;). */
id|memset
c_func
(paren
id|data
op_plus
l_int|8
comma
l_int|0
comma
l_int|28
)paren
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|data
op_plus
l_int|8
comma
id|us-&gt;unusual_dev-&gt;vendorName
comma
id|strlen
c_func
(paren
id|us-&gt;unusual_dev-&gt;vendorName
)paren
OG
l_int|8
ques
c_cond
l_int|8
suffix:colon
id|strlen
c_func
(paren
id|us-&gt;unusual_dev-&gt;vendorName
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|data
op_plus
l_int|16
comma
id|us-&gt;unusual_dev-&gt;productName
comma
id|strlen
c_func
(paren
id|us-&gt;unusual_dev-&gt;productName
)paren
OG
l_int|16
ques
c_cond
l_int|16
suffix:colon
id|strlen
c_func
(paren
id|us-&gt;unusual_dev-&gt;productName
)paren
)paren
suffix:semicolon
id|data
(braket
l_int|32
)braket
op_assign
l_int|0x30
op_plus
(paren
(paren
id|us-&gt;pusb_dev-&gt;descriptor.bcdDevice
op_rshift
l_int|12
)paren
op_amp
l_int|0x0F
)paren
suffix:semicolon
id|data
(braket
l_int|33
)braket
op_assign
l_int|0x30
op_plus
(paren
(paren
id|us-&gt;pusb_dev-&gt;descriptor.bcdDevice
op_rshift
l_int|8
)paren
op_amp
l_int|0x0F
)paren
suffix:semicolon
id|data
(braket
l_int|34
)braket
op_assign
l_int|0x30
op_plus
(paren
(paren
id|us-&gt;pusb_dev-&gt;descriptor.bcdDevice
op_rshift
l_int|4
)paren
op_amp
l_int|0x0F
)paren
suffix:semicolon
id|data
(braket
l_int|35
)braket
op_assign
l_int|0x30
op_plus
(paren
(paren
id|us-&gt;pusb_dev-&gt;descriptor.bcdDevice
)paren
op_amp
l_int|0x0F
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|us-&gt;srb-&gt;use_sg
)paren
(brace
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|us-&gt;srb-&gt;request_buffer
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|us-&gt;srb-&gt;use_sg
suffix:semicolon
id|i
op_increment
)paren
id|memset
c_func
(paren
id|sg_address
c_func
(paren
id|sg
(braket
id|i
)braket
)paren
comma
l_int|0
comma
id|sg
(braket
id|i
)braket
dot
id|length
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|transferred
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|us-&gt;srb-&gt;use_sg
op_logical_and
id|transferred
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|amt
op_assign
id|sg
(braket
id|i
)braket
dot
id|length
OG
id|len
op_minus
id|transferred
ques
c_cond
id|len
op_minus
id|transferred
suffix:colon
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
id|memcpy
c_func
(paren
id|sg_address
c_func
(paren
id|sg
(braket
id|i
)braket
)paren
comma
id|data
op_plus
id|transferred
comma
id|amt
)paren
suffix:semicolon
id|transferred
op_sub_assign
id|amt
suffix:semicolon
)brace
)brace
r_else
(brace
id|memset
c_func
(paren
id|us-&gt;srb-&gt;request_buffer
comma
l_int|0
comma
id|us-&gt;srb-&gt;request_bufflen
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|us-&gt;srb-&gt;request_buffer
comma
id|data
comma
id|len
)paren
suffix:semicolon
)brace
)brace
DECL|function|usb_stor_control_thread
r_static
r_int
id|usb_stor_control_thread
c_func
(paren
r_void
op_star
id|__us
)paren
(brace
r_struct
id|us_data
op_star
id|us
op_assign
(paren
r_struct
id|us_data
op_star
)paren
id|__us
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This thread doesn&squot;t need any user-level access,&n;&t; * so get rid of all our resources.&n;&t; */
id|daemonize
c_func
(paren
l_string|&quot;usb-storage&quot;
)paren
suffix:semicolon
id|current-&gt;flags
op_or_assign
id|PF_IOTHREAD
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* signal that we&squot;ve started the thread */
id|complete
c_func
(paren
op_amp
(paren
id|us-&gt;notify
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;*** thread sleeping.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|down_interruptible
c_func
(paren
op_amp
id|us-&gt;sema
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;*** thread awakened.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* if us-&gt;srb is NULL, we are being asked to exit */
r_if
c_cond
(paren
id|us-&gt;srb
op_eq
l_int|NULL
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- exit command received&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|host
op_assign
id|us-&gt;srb-&gt;device-&gt;host
suffix:semicolon
multiline_comment|/* lock access to the state */
id|scsi_lock
c_func
(paren
id|host
)paren
suffix:semicolon
multiline_comment|/* has the command been aborted *already* ? */
r_if
c_cond
(paren
id|us-&gt;sm_state
op_eq
id|US_STATE_ABORTING
)paren
(brace
id|us-&gt;srb-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
r_goto
id|SkipForAbort
suffix:semicolon
)brace
multiline_comment|/* set the state and release the lock */
id|us-&gt;sm_state
op_assign
id|US_STATE_RUNNING
suffix:semicolon
id|scsi_unlock
c_func
(paren
id|host
)paren
suffix:semicolon
multiline_comment|/* lock the device pointers */
id|down
c_func
(paren
op_amp
(paren
id|us-&gt;dev_semaphore
)paren
)paren
suffix:semicolon
multiline_comment|/* don&squot;t do anything if we are disconnecting */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|US_FLIDX_DISCONNECTING
comma
op_amp
id|us-&gt;flags
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;No command during disconnect&bslash;n&quot;
)paren
suffix:semicolon
id|us-&gt;srb-&gt;result
op_assign
id|DID_BAD_TARGET
op_lshift
l_int|16
suffix:semicolon
)brace
multiline_comment|/* reject the command if the direction indicator &n;&t;&t; * is UNKNOWN&n;&t;&t; */
r_else
r_if
c_cond
(paren
id|us-&gt;srb-&gt;sc_data_direction
op_eq
id|SCSI_DATA_UNKNOWN
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;UNKNOWN data direction&bslash;n&quot;
)paren
suffix:semicolon
id|us-&gt;srb-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
)brace
multiline_comment|/* reject if target != 0 or if LUN is higher than&n;&t;&t; * the maximum known LUN&n;&t;&t; */
r_else
r_if
c_cond
(paren
id|us-&gt;srb-&gt;device-&gt;id
op_logical_and
op_logical_neg
(paren
id|us-&gt;flags
op_amp
id|US_FL_SCM_MULT_TARG
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bad target number (%d:%d)&bslash;n&quot;
comma
id|us-&gt;srb-&gt;device-&gt;id
comma
id|us-&gt;srb-&gt;device-&gt;lun
)paren
suffix:semicolon
id|us-&gt;srb-&gt;result
op_assign
id|DID_BAD_TARGET
op_lshift
l_int|16
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|us-&gt;srb-&gt;device-&gt;lun
OG
id|us-&gt;max_lun
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Bad LUN (%d:%d)&bslash;n&quot;
comma
id|us-&gt;srb-&gt;device-&gt;id
comma
id|us-&gt;srb-&gt;device-&gt;lun
)paren
suffix:semicolon
id|us-&gt;srb-&gt;result
op_assign
id|DID_BAD_TARGET
op_lshift
l_int|16
suffix:semicolon
)brace
multiline_comment|/* Handle those devices which need us to fake &n;&t;&t; * their inquiry data */
r_else
r_if
c_cond
(paren
(paren
id|us-&gt;srb-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
op_logical_and
(paren
id|us-&gt;flags
op_amp
id|US_FL_FIX_INQUIRY
)paren
)paren
(brace
r_int
r_char
id|data_ptr
(braket
l_int|36
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0x80
comma
l_int|0x02
comma
l_int|0x02
comma
l_int|0x1F
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Faking INQUIRY command&bslash;n&quot;
)paren
suffix:semicolon
id|fill_inquiry_response
c_func
(paren
id|us
comma
id|data_ptr
comma
l_int|36
)paren
suffix:semicolon
id|us-&gt;srb-&gt;result
op_assign
id|SAM_STAT_GOOD
suffix:semicolon
)brace
multiline_comment|/* we&squot;ve got a command, let&squot;s do it! */
r_else
(brace
id|US_DEBUG
c_func
(paren
id|usb_stor_show_command
c_func
(paren
id|us-&gt;srb
)paren
)paren
suffix:semicolon
id|us
op_member_access_from_pointer
id|proto_handler
c_func
(paren
id|us-&gt;srb
comma
id|us
)paren
suffix:semicolon
)brace
multiline_comment|/* unlock the device pointers */
id|up
c_func
(paren
op_amp
(paren
id|us-&gt;dev_semaphore
)paren
)paren
suffix:semicolon
multiline_comment|/* lock access to the state */
id|scsi_lock
c_func
(paren
id|host
)paren
suffix:semicolon
multiline_comment|/* indicate that the command is done */
r_if
c_cond
(paren
id|us-&gt;srb-&gt;result
op_ne
id|DID_ABORT
op_lshift
l_int|16
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;scsi cmd done, result=0x%x&bslash;n&quot;
comma
id|us-&gt;srb-&gt;result
)paren
suffix:semicolon
id|us-&gt;srb
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|us-&gt;srb
)paren
suffix:semicolon
)brace
r_else
(brace
id|SkipForAbort
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;scsi command aborted&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* If an abort request was received we need to signal that&n;&t;&t; * the abort has finished.  The proper test for this is&n;&t;&t; * sm_state == US_STATE_ABORTING, not srb-&gt;result == DID_ABORT,&n;&t;&t; * because an abort request might be received after all the&n;&t;&t; * USB processing was complete. */
r_if
c_cond
(paren
id|us-&gt;sm_state
op_eq
id|US_STATE_ABORTING
)paren
id|complete
c_func
(paren
op_amp
(paren
id|us-&gt;notify
)paren
)paren
suffix:semicolon
multiline_comment|/* empty the queue, reset the state, and release the lock */
id|us-&gt;srb
op_assign
l_int|NULL
suffix:semicolon
id|us-&gt;sm_state
op_assign
id|US_STATE_IDLE
suffix:semicolon
id|scsi_unlock
c_func
(paren
id|host
)paren
suffix:semicolon
)brace
multiline_comment|/* for (;;) */
multiline_comment|/* notify the exit routine that we&squot;re actually exiting now */
id|complete
c_func
(paren
op_amp
(paren
id|us-&gt;notify
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/***********************************************************************&n; * Device probing and disconnecting&n; ***********************************************************************/
multiline_comment|/* Associate our private data with the USB device */
DECL|function|associate_dev
r_static
r_void
id|associate_dev
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_struct
id|usb_interface
op_star
id|intf
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- %s&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* Fill in the device-related fields */
id|us-&gt;pusb_dev
op_assign
id|interface_to_usbdev
c_func
(paren
id|intf
)paren
suffix:semicolon
id|us-&gt;pusb_intf
op_assign
id|intf
suffix:semicolon
id|us-&gt;ifnum
op_assign
id|intf-&gt;altsetting-&gt;desc.bInterfaceNumber
suffix:semicolon
multiline_comment|/* Store our private data in the interface and increment the&n;&t; * device&squot;s reference count */
id|usb_set_intfdata
c_func
(paren
id|intf
comma
id|us
)paren
suffix:semicolon
id|usb_get_dev
c_func
(paren
id|us-&gt;pusb_dev
)paren
suffix:semicolon
)brace
multiline_comment|/* Get the unusual_devs entries and the string descriptors */
DECL|function|get_device_info
r_static
r_void
id|get_device_info
c_func
(paren
r_struct
id|us_data
op_star
id|us
comma
r_int
id|id_index
)paren
(brace
r_struct
id|usb_device
op_star
id|dev
op_assign
id|us-&gt;pusb_dev
suffix:semicolon
r_struct
id|usb_interface_descriptor
op_star
id|idesc
op_assign
op_amp
id|us-&gt;pusb_intf-&gt;altsetting
(braket
id|us-&gt;pusb_intf-&gt;act_altsetting
)braket
dot
id|desc
suffix:semicolon
r_struct
id|us_unusual_dev
op_star
id|unusual_dev
op_assign
op_amp
id|us_unusual_dev_list
(braket
id|id_index
)braket
suffix:semicolon
r_struct
id|usb_device_id
op_star
id|id
op_assign
op_amp
id|storage_usb_ids
(braket
id|id_index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|unusual_dev-&gt;vendorName
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;Vendor: %s&bslash;n&quot;
comma
id|unusual_dev-&gt;vendorName
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unusual_dev-&gt;productName
)paren
id|US_DEBUGP
c_func
(paren
l_string|&quot;Product: %s&bslash;n&quot;
comma
id|unusual_dev-&gt;productName
)paren
suffix:semicolon
multiline_comment|/* Store the entries */
id|us-&gt;unusual_dev
op_assign
id|unusual_dev
suffix:semicolon
id|us-&gt;subclass
op_assign
(paren
id|unusual_dev-&gt;useProtocol
op_eq
id|US_SC_DEVICE
)paren
ques
c_cond
id|idesc-&gt;bInterfaceSubClass
suffix:colon
id|unusual_dev-&gt;useProtocol
suffix:semicolon
id|us-&gt;protocol
op_assign
(paren
id|unusual_dev-&gt;useTransport
op_eq
id|US_PR_DEVICE
)paren
ques
c_cond
id|idesc-&gt;bInterfaceProtocol
suffix:colon
id|unusual_dev-&gt;useTransport
suffix:semicolon
id|us-&gt;flags
op_assign
id|unusual_dev-&gt;flags
suffix:semicolon
multiline_comment|/* Log a message if a non-generic unusual_dev entry contains an&n;&t; * unnecessary subclass or protocol override.  This may stimulate&n;&t; * reports from users that will help us remove unneeded entries&n;&t; * from the unusual_devs.h table.&n;&t; */
r_if
c_cond
(paren
id|id-&gt;idVendor
op_logical_or
id|id-&gt;idProduct
)paren
(brace
r_static
r_char
op_star
id|msgs
(braket
l_int|3
)braket
op_assign
(brace
l_string|&quot;an unneeded SubClass entry&quot;
comma
l_string|&quot;an unneeded Protocol entry&quot;
comma
l_string|&quot;unneeded SubClass and Protocol entries&quot;
)brace
suffix:semicolon
r_struct
id|usb_device_descriptor
op_star
id|ddesc
op_assign
op_amp
id|dev-&gt;descriptor
suffix:semicolon
r_int
id|msg
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|unusual_dev-&gt;useProtocol
op_ne
id|US_SC_DEVICE
op_logical_and
id|us-&gt;subclass
op_eq
id|idesc-&gt;bInterfaceSubClass
)paren
id|msg
op_add_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|unusual_dev-&gt;useTransport
op_ne
id|US_PR_DEVICE
op_logical_and
id|us-&gt;protocol
op_eq
id|idesc-&gt;bInterfaceProtocol
)paren
id|msg
op_add_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|msg
op_ge
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_NOTICE
id|USB_STORAGE
l_string|&quot;This device &quot;
l_string|&quot;(%04x,%04x,%04x S %02x P %02x)&quot;
l_string|&quot; has %s in unusual_devs.h&bslash;n&quot;
l_string|&quot;   Please send a copy of this message to &quot;
l_string|&quot;&lt;linux-usb-devel@lists.sourceforge.net&gt;&bslash;n&quot;
comma
id|ddesc-&gt;idVendor
comma
id|ddesc-&gt;idProduct
comma
id|ddesc-&gt;bcdDevice
comma
id|idesc-&gt;bInterfaceSubClass
comma
id|idesc-&gt;bInterfaceProtocol
comma
id|msgs
(braket
id|msg
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Read the device&squot;s string descriptors */
r_if
c_cond
(paren
id|dev-&gt;descriptor.iManufacturer
)paren
id|usb_string
c_func
(paren
id|dev
comma
id|dev-&gt;descriptor.iManufacturer
comma
id|us-&gt;vendor
comma
r_sizeof
(paren
id|us-&gt;vendor
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;descriptor.iProduct
)paren
id|usb_string
c_func
(paren
id|dev
comma
id|dev-&gt;descriptor.iProduct
comma
id|us-&gt;product
comma
r_sizeof
(paren
id|us-&gt;product
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;descriptor.iSerialNumber
)paren
id|usb_string
c_func
(paren
id|dev
comma
id|dev-&gt;descriptor.iSerialNumber
comma
id|us-&gt;serial
comma
r_sizeof
(paren
id|us-&gt;serial
)paren
)paren
suffix:semicolon
multiline_comment|/* Use the unusual_dev strings if the device didn&squot;t provide them */
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|us-&gt;vendor
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|unusual_dev-&gt;vendorName
)paren
id|strlcpy
c_func
(paren
id|us-&gt;vendor
comma
id|unusual_dev-&gt;vendorName
comma
r_sizeof
(paren
id|us-&gt;vendor
)paren
)paren
suffix:semicolon
r_else
id|strcpy
c_func
(paren
id|us-&gt;vendor
comma
l_string|&quot;Unknown&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|us-&gt;product
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|unusual_dev-&gt;productName
)paren
id|strlcpy
c_func
(paren
id|us-&gt;product
comma
id|unusual_dev-&gt;productName
comma
r_sizeof
(paren
id|us-&gt;product
)paren
)paren
suffix:semicolon
r_else
id|strcpy
c_func
(paren
id|us-&gt;product
comma
l_string|&quot;Unknown&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|us-&gt;serial
)paren
op_eq
l_int|0
)paren
id|strcpy
c_func
(paren
id|us-&gt;serial
comma
l_string|&quot;None&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Get the transport settings */
DECL|function|get_transport
r_static
r_int
id|get_transport
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_switch
c_cond
(paren
id|us-&gt;protocol
)paren
(brace
r_case
id|US_PR_CB
suffix:colon
id|us-&gt;transport_name
op_assign
l_string|&quot;Control/Bulk&quot;
suffix:semicolon
id|us-&gt;transport
op_assign
id|usb_stor_CB_transport
suffix:semicolon
id|us-&gt;transport_reset
op_assign
id|usb_stor_CB_reset
suffix:semicolon
id|us-&gt;max_lun
op_assign
l_int|7
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_PR_CBI
suffix:colon
id|us-&gt;transport_name
op_assign
l_string|&quot;Control/Bulk/Interrupt&quot;
suffix:semicolon
id|us-&gt;transport
op_assign
id|usb_stor_CBI_transport
suffix:semicolon
id|us-&gt;transport_reset
op_assign
id|usb_stor_CB_reset
suffix:semicolon
id|us-&gt;max_lun
op_assign
l_int|7
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_PR_BULK
suffix:colon
id|us-&gt;transport_name
op_assign
l_string|&quot;Bulk&quot;
suffix:semicolon
id|us-&gt;transport
op_assign
id|usb_stor_Bulk_transport
suffix:semicolon
id|us-&gt;transport_reset
op_assign
id|usb_stor_Bulk_reset
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef CONFIG_USB_STORAGE_HP8200e
r_case
id|US_PR_SCM_ATAPI
suffix:colon
id|us-&gt;transport_name
op_assign
l_string|&quot;SCM/ATAPI&quot;
suffix:semicolon
id|us-&gt;transport
op_assign
id|hp8200e_transport
suffix:semicolon
id|us-&gt;transport_reset
op_assign
id|usb_stor_CB_reset
suffix:semicolon
id|us-&gt;max_lun
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_SDDR09
r_case
id|US_PR_EUSB_SDDR09
suffix:colon
id|us-&gt;transport_name
op_assign
l_string|&quot;EUSB/SDDR09&quot;
suffix:semicolon
id|us-&gt;transport
op_assign
id|sddr09_transport
suffix:semicolon
id|us-&gt;transport_reset
op_assign
id|usb_stor_CB_reset
suffix:semicolon
id|us-&gt;max_lun
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_SDDR55
r_case
id|US_PR_SDDR55
suffix:colon
id|us-&gt;transport_name
op_assign
l_string|&quot;SDDR55&quot;
suffix:semicolon
id|us-&gt;transport
op_assign
id|sddr55_transport
suffix:semicolon
id|us-&gt;transport_reset
op_assign
id|sddr55_reset
suffix:semicolon
id|us-&gt;max_lun
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_DPCM
r_case
id|US_PR_DPCM_USB
suffix:colon
id|us-&gt;transport_name
op_assign
l_string|&quot;Control/Bulk-EUSB/SDDR09&quot;
suffix:semicolon
id|us-&gt;transport
op_assign
id|dpcm_transport
suffix:semicolon
id|us-&gt;transport_reset
op_assign
id|usb_stor_CB_reset
suffix:semicolon
id|us-&gt;max_lun
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_FREECOM
r_case
id|US_PR_FREECOM
suffix:colon
id|us-&gt;transport_name
op_assign
l_string|&quot;Freecom&quot;
suffix:semicolon
id|us-&gt;transport
op_assign
id|freecom_transport
suffix:semicolon
id|us-&gt;transport_reset
op_assign
id|usb_stor_freecom_reset
suffix:semicolon
id|us-&gt;max_lun
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_DATAFAB
r_case
id|US_PR_DATAFAB
suffix:colon
id|us-&gt;transport_name
op_assign
l_string|&quot;Datafab Bulk-Only&quot;
suffix:semicolon
id|us-&gt;transport
op_assign
id|datafab_transport
suffix:semicolon
id|us-&gt;transport_reset
op_assign
id|usb_stor_Bulk_reset
suffix:semicolon
id|us-&gt;max_lun
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_USB_STORAGE_JUMPSHOT
r_case
id|US_PR_JUMPSHOT
suffix:colon
id|us-&gt;transport_name
op_assign
l_string|&quot;Lexar Jumpshot Control/Bulk&quot;
suffix:semicolon
id|us-&gt;transport
op_assign
id|jumpshot_transport
suffix:semicolon
id|us-&gt;transport_reset
op_assign
id|usb_stor_Bulk_reset
suffix:semicolon
id|us-&gt;max_lun
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Transport: %s&bslash;n&quot;
comma
id|us-&gt;transport_name
)paren
suffix:semicolon
multiline_comment|/* fix for single-lun devices */
r_if
c_cond
(paren
id|us-&gt;flags
op_amp
id|US_FL_SINGLE_LUN
)paren
id|us-&gt;max_lun
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Get the protocol settings */
DECL|function|get_protocol
r_static
r_int
id|get_protocol
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_switch
c_cond
(paren
id|us-&gt;subclass
)paren
(brace
r_case
id|US_SC_RBC
suffix:colon
id|us-&gt;protocol_name
op_assign
l_string|&quot;Reduced Block Commands (RBC)&quot;
suffix:semicolon
id|us-&gt;proto_handler
op_assign
id|usb_stor_transparent_scsi_command
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_SC_8020
suffix:colon
id|us-&gt;protocol_name
op_assign
l_string|&quot;8020i&quot;
suffix:semicolon
id|us-&gt;proto_handler
op_assign
id|usb_stor_ATAPI_command
suffix:semicolon
id|us-&gt;max_lun
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_SC_QIC
suffix:colon
id|us-&gt;protocol_name
op_assign
l_string|&quot;QIC-157&quot;
suffix:semicolon
id|us-&gt;proto_handler
op_assign
id|usb_stor_qic157_command
suffix:semicolon
id|us-&gt;max_lun
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_SC_8070
suffix:colon
id|us-&gt;protocol_name
op_assign
l_string|&quot;8070i&quot;
suffix:semicolon
id|us-&gt;proto_handler
op_assign
id|usb_stor_ATAPI_command
suffix:semicolon
id|us-&gt;max_lun
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_SC_SCSI
suffix:colon
id|us-&gt;protocol_name
op_assign
l_string|&quot;Transparent SCSI&quot;
suffix:semicolon
id|us-&gt;proto_handler
op_assign
id|usb_stor_transparent_scsi_command
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_SC_UFI
suffix:colon
id|us-&gt;protocol_name
op_assign
l_string|&quot;Uniform Floppy Interface (UFI)&quot;
suffix:semicolon
id|us-&gt;proto_handler
op_assign
id|usb_stor_ufi_command
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef CONFIG_USB_STORAGE_ISD200
r_case
id|US_SC_ISD200
suffix:colon
id|us-&gt;protocol_name
op_assign
l_string|&quot;ISD200 ATA/ATAPI&quot;
suffix:semicolon
id|us-&gt;proto_handler
op_assign
id|isd200_ata_command
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Protocol: %s&bslash;n&quot;
comma
id|us-&gt;protocol_name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Get the pipe settings */
DECL|function|get_pipes
r_static
r_int
id|get_pipes
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_struct
id|usb_host_interface
op_star
id|altsetting
op_assign
op_amp
id|us-&gt;pusb_intf-&gt;altsetting
(braket
id|us-&gt;pusb_intf-&gt;act_altsetting
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|ep
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|ep_in
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|ep_out
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|ep_int
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Find the endpoints we need.&n;&t; * We are expecting a minimum of 2 endpoints - in and out (bulk).&n;&t; * An optional interrupt is OK (necessary for CBI protocol).&n;&t; * We will ignore any others.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|altsetting-&gt;desc.bNumEndpoints
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ep
op_assign
op_amp
id|altsetting-&gt;endpoint
(braket
id|i
)braket
dot
id|desc
suffix:semicolon
multiline_comment|/* Is it a BULK endpoint? */
r_if
c_cond
(paren
(paren
id|ep-&gt;bmAttributes
op_amp
id|USB_ENDPOINT_XFERTYPE_MASK
)paren
op_eq
id|USB_ENDPOINT_XFER_BULK
)paren
(brace
multiline_comment|/* BULK in or out? */
r_if
c_cond
(paren
id|ep-&gt;bEndpointAddress
op_amp
id|USB_DIR_IN
)paren
id|ep_in
op_assign
id|ep
suffix:semicolon
r_else
id|ep_out
op_assign
id|ep
suffix:semicolon
)brace
multiline_comment|/* Is it an interrupt endpoint? */
r_else
r_if
c_cond
(paren
(paren
id|ep-&gt;bmAttributes
op_amp
id|USB_ENDPOINT_XFERTYPE_MASK
)paren
op_eq
id|USB_ENDPOINT_XFER_INT
)paren
(brace
id|ep_int
op_assign
id|ep
suffix:semicolon
)brace
)brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Endpoints: In: 0x%p Out: 0x%p Int: 0x%p (Period %d)&bslash;n&quot;
comma
id|ep_in
comma
id|ep_out
comma
id|ep_int
comma
id|ep_int
ques
c_cond
id|ep_int-&gt;bInterval
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep_in
op_logical_or
op_logical_neg
id|ep_out
op_logical_or
(paren
id|us-&gt;protocol
op_eq
id|US_PR_CBI
op_logical_and
op_logical_neg
id|ep_int
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;Endpoint sanity check failed! Rejecting dev.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Calculate and store the pipe values */
id|us-&gt;send_ctrl_pipe
op_assign
id|usb_sndctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
suffix:semicolon
id|us-&gt;recv_ctrl_pipe
op_assign
id|usb_rcvctrlpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|0
)paren
suffix:semicolon
id|us-&gt;send_bulk_pipe
op_assign
id|usb_sndbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|ep_out-&gt;bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
)paren
suffix:semicolon
id|us-&gt;recv_bulk_pipe
op_assign
id|usb_rcvbulkpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|ep_in-&gt;bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ep_int
)paren
(brace
id|us-&gt;recv_intr_pipe
op_assign
id|usb_rcvintpipe
c_func
(paren
id|us-&gt;pusb_dev
comma
id|ep_int-&gt;bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
)paren
suffix:semicolon
id|us-&gt;ep_bInterval
op_assign
id|ep_int-&gt;bInterval
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Initialize all the dynamic resources we need */
DECL|function|usb_stor_acquire_resources
r_static
r_int
id|usb_stor_acquire_resources
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
r_int
id|p
suffix:semicolon
multiline_comment|/* Allocate the USB control blocks */
id|us-&gt;cr
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|us-&gt;cr
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|us-&gt;cr
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;usb_ctrlrequest allocation failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|us-&gt;current_urb
op_assign
id|usb_alloc_urb
c_func
(paren
l_int|0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|us-&gt;current_urb
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;URB allocation failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|us-&gt;iobuf
op_assign
id|kmalloc
c_func
(paren
id|US_IOBUF_SIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|us-&gt;iobuf
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;I/O buffer allocation failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Lock the device while we carry out the next two operations */
id|down
c_func
(paren
op_amp
id|us-&gt;dev_semaphore
)paren
suffix:semicolon
multiline_comment|/* For bulk-only devices, determine the max LUN value */
r_if
c_cond
(paren
id|us-&gt;protocol
op_eq
id|US_PR_BULK
)paren
id|us-&gt;max_lun
op_assign
id|usb_stor_Bulk_max_lun
c_func
(paren
id|us
)paren
suffix:semicolon
multiline_comment|/* Just before we start our control thread, initialize&n;&t; * the device if it needs initialization */
r_if
c_cond
(paren
id|us-&gt;unusual_dev-&gt;initFunction
)paren
id|us-&gt;unusual_dev
op_member_access_from_pointer
id|initFunction
c_func
(paren
id|us
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|us-&gt;dev_semaphore
)paren
suffix:semicolon
multiline_comment|/* Start up our control thread */
id|us-&gt;sm_state
op_assign
id|US_STATE_IDLE
suffix:semicolon
id|p
op_assign
id|kernel_thread
c_func
(paren
id|usb_stor_control_thread
comma
id|us
comma
id|CLONE_VM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|USB_STORAGE
l_string|&quot;Unable to start control thread&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
id|us-&gt;pid
op_assign
id|p
suffix:semicolon
multiline_comment|/* Wait for the thread to start */
id|wait_for_completion
c_func
(paren
op_amp
(paren
id|us-&gt;notify
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Since this is a new device, we need to register a SCSI&n;&t; * host definition with the higher SCSI layers.&n;&t; */
id|us-&gt;host
op_assign
id|scsi_host_alloc
c_func
(paren
op_amp
id|usb_stor_host_template
comma
r_sizeof
(paren
id|us
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|us-&gt;host
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|USB_STORAGE
l_string|&quot;Unable to register the scsi host&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* Set the hostdata to prepare for scanning */
id|us-&gt;host-&gt;hostdata
(braket
l_int|0
)braket
op_assign
(paren
r_int
r_int
)paren
id|us
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Dissociate from the USB device */
DECL|function|dissociate_dev
r_static
r_void
id|dissociate_dev
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- %s&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|us-&gt;dev_semaphore
)paren
suffix:semicolon
id|usb_set_intfdata
c_func
(paren
id|us-&gt;pusb_intf
comma
l_int|NULL
)paren
suffix:semicolon
id|usb_put_dev
c_func
(paren
id|us-&gt;pusb_dev
)paren
suffix:semicolon
id|us-&gt;pusb_dev
op_assign
l_int|NULL
suffix:semicolon
id|us-&gt;pusb_intf
op_assign
l_int|NULL
suffix:semicolon
id|up
c_func
(paren
op_amp
id|us-&gt;dev_semaphore
)paren
suffix:semicolon
)brace
multiline_comment|/* Release all our static and dynamic resources */
DECL|function|usb_stor_release_resources
r_void
id|usb_stor_release_resources
c_func
(paren
r_struct
id|us_data
op_star
id|us
)paren
(brace
multiline_comment|/*&n;&t; * The host must already have been removed&n;&t; * and dissociate_dev() must have been called.&n;&t; */
multiline_comment|/* Finish the SCSI host removal sequence */
r_if
c_cond
(paren
id|us-&gt;host
)paren
(brace
(paren
r_struct
id|us_data
op_star
)paren
id|us-&gt;host-&gt;hostdata
(braket
l_int|0
)braket
op_assign
l_int|NULL
suffix:semicolon
id|scsi_host_put
c_func
(paren
id|us-&gt;host
)paren
suffix:semicolon
)brace
multiline_comment|/* Kill the control thread&n;&t; *&n;&t; * Enqueue the command, wake up the thread, and wait for &n;&t; * notification that it has exited.&n;&t; */
r_if
c_cond
(paren
id|us-&gt;pid
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- sending exit command to thread&bslash;n&quot;
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|us-&gt;sm_state
op_ne
id|US_STATE_IDLE
)paren
suffix:semicolon
id|us-&gt;srb
op_assign
l_int|NULL
suffix:semicolon
id|up
c_func
(paren
op_amp
(paren
id|us-&gt;sema
)paren
)paren
suffix:semicolon
id|wait_for_completion
c_func
(paren
op_amp
(paren
id|us-&gt;notify
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Call the destructor routine, if it exists */
r_if
c_cond
(paren
id|us-&gt;extra_destructor
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- calling extra_destructor()&bslash;n&quot;
)paren
suffix:semicolon
id|us
op_member_access_from_pointer
id|extra_destructor
c_func
(paren
id|us-&gt;extra
)paren
suffix:semicolon
)brace
multiline_comment|/* Destroy the extra data */
r_if
c_cond
(paren
id|us-&gt;extra
)paren
(brace
id|kfree
c_func
(paren
id|us-&gt;extra
)paren
suffix:semicolon
)brace
multiline_comment|/* Free the USB control blocks */
r_if
c_cond
(paren
id|us-&gt;iobuf
)paren
id|kfree
c_func
(paren
id|us-&gt;iobuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|us-&gt;current_urb
)paren
id|usb_free_urb
c_func
(paren
id|us-&gt;current_urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|us-&gt;cr
)paren
id|kfree
c_func
(paren
id|us-&gt;cr
)paren
suffix:semicolon
multiline_comment|/* Free the structure itself */
id|kfree
c_func
(paren
id|us
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- %s finished&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
)brace
multiline_comment|/* Probe to see if we can drive a newly-connected USB device */
DECL|function|storage_probe
r_static
r_int
id|storage_probe
c_func
(paren
r_struct
id|usb_interface
op_star
id|intf
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
(brace
r_struct
id|us_data
op_star
id|us
suffix:semicolon
r_const
r_int
id|id_index
op_assign
id|id
op_minus
id|storage_usb_ids
suffix:semicolon
r_int
id|result
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;USB Mass Storage device detected&bslash;n&quot;
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;act_altsetting is %d, id_index is %d&bslash;n&quot;
comma
id|intf-&gt;act_altsetting
comma
id|id_index
)paren
suffix:semicolon
multiline_comment|/* Allocate the us_data structure and initialize the mutexes */
id|us
op_assign
(paren
r_struct
id|us_data
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|us
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|us
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|USB_STORAGE
l_string|&quot;Out of memory&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|us
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|us_data
)paren
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
(paren
id|us-&gt;dev_semaphore
)paren
)paren
suffix:semicolon
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
(paren
id|us-&gt;sema
)paren
)paren
suffix:semicolon
id|init_completion
c_func
(paren
op_amp
(paren
id|us-&gt;notify
)paren
)paren
suffix:semicolon
multiline_comment|/* Associate the us_data structure with the USB device */
id|associate_dev
c_func
(paren
id|us
comma
id|intf
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get the unusual_devs entries and the descriptors&n;&t; *&n;&t; * id_index is calculated in the declaration to be the index number&n;&t; * of the match from the usb_device_id table, so we can find the&n;&t; * corresponding entry in the private table.&n;&t; */
id|get_device_info
c_func
(paren
id|us
comma
id|id_index
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_USB_STORAGE_SDDR09
r_if
c_cond
(paren
id|us-&gt;protocol
op_eq
id|US_PR_EUSB_SDDR09
op_logical_or
id|us-&gt;protocol
op_eq
id|US_PR_DPCM_USB
)paren
(brace
multiline_comment|/* set the configuration -- STALL is an acceptable response here */
id|result
op_assign
id|usb_set_configuration
c_func
(paren
id|us-&gt;pusb_dev
comma
l_int|1
)paren
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;Result from usb_set_configuration is %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- stall on control interface&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|result
op_ne
l_int|0
)paren
(brace
multiline_comment|/* it&squot;s not a stall, but another error -- time to bail */
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- Unknown error.  Rejecting device&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|BadDevice
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/* Get the transport, protocol, and pipe settings */
id|result
op_assign
id|get_transport
c_func
(paren
id|us
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_goto
id|BadDevice
suffix:semicolon
id|result
op_assign
id|get_protocol
c_func
(paren
id|us
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_goto
id|BadDevice
suffix:semicolon
id|result
op_assign
id|get_pipes
c_func
(paren
id|us
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_goto
id|BadDevice
suffix:semicolon
multiline_comment|/* Acquire all the other resources */
id|result
op_assign
id|usb_stor_acquire_resources
c_func
(paren
id|us
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_goto
id|BadDevice
suffix:semicolon
multiline_comment|/* Finally, add the host (this does SCSI device scanning) */
id|result
op_assign
id|scsi_add_host
c_func
(paren
id|us-&gt;host
comma
op_amp
id|intf-&gt;dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|USB_STORAGE
l_string|&quot;Unable to add the scsi host&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|BadDevice
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;WARNING: USB Mass Storage data integrity not assured&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;USB Mass Storage device found at %d&bslash;n&quot;
comma
id|us-&gt;pusb_dev-&gt;devnum
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* We come here if there are any problems */
id|BadDevice
suffix:colon
id|US_DEBUGP
c_func
(paren
l_string|&quot;storage_probe() failed&bslash;n&quot;
)paren
suffix:semicolon
id|dissociate_dev
c_func
(paren
id|us
)paren
suffix:semicolon
id|usb_stor_release_resources
c_func
(paren
id|us
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/* Handle a disconnect event from the USB core */
DECL|function|storage_disconnect
r_static
r_void
id|storage_disconnect
c_func
(paren
r_struct
id|usb_interface
op_star
id|intf
)paren
(brace
r_struct
id|us_data
op_star
id|us
op_assign
id|usb_get_intfdata
c_func
(paren
id|intf
)paren
suffix:semicolon
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
id|US_DEBUGP
c_func
(paren
l_string|&quot;storage_disconnect() called&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Set devices offline -- need host lock for this */
id|scsi_lock
c_func
(paren
id|us-&gt;host
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|sdev
comma
op_amp
id|us-&gt;host-&gt;my_devices
comma
id|siblings
)paren
id|sdev-&gt;online
op_assign
l_int|0
suffix:semicolon
id|scsi_unlock
c_func
(paren
id|us-&gt;host
)paren
suffix:semicolon
multiline_comment|/* Prevent new USB transfers and stop the current command */
id|set_bit
c_func
(paren
id|US_FLIDX_DISCONNECTING
comma
op_amp
id|us-&gt;flags
)paren
suffix:semicolon
id|usb_stor_stop_transport
c_func
(paren
id|us
)paren
suffix:semicolon
multiline_comment|/* Dissociate from the USB device */
id|dissociate_dev
c_func
(paren
id|us
)paren
suffix:semicolon
multiline_comment|/* Begin the SCSI host removal sequence */
r_if
c_cond
(paren
id|scsi_remove_host
c_func
(paren
id|us-&gt;host
)paren
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- SCSI refused to remove the host&bslash;n&quot;
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* TODO: somehow, wait for the device to&n;&t; * be &squot;idle&squot; (tasklet completion) */
multiline_comment|/* Release all our other resources */
id|usb_stor_release_resources
c_func
(paren
id|us
)paren
suffix:semicolon
)brace
multiline_comment|/***********************************************************************&n; * Initialization and registration&n; ***********************************************************************/
DECL|function|usb_stor_init
r_int
id|__init
id|usb_stor_init
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Initializing USB Mass Storage driver...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* register the driver, return -1 if error */
r_if
c_cond
(paren
id|usb_register
c_func
(paren
op_amp
id|usb_storage_driver
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* we&squot;re all set */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;USB Mass Storage support registered.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usb_stor_exit
r_void
id|__exit
id|usb_stor_exit
c_func
(paren
r_void
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;usb_stor_exit() called&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Deregister the driver&n;&t; * This will cause disconnect() to be called for each&n;&t; * attached unit&n;&t; */
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- calling usb_deregister()&bslash;n&quot;
)paren
suffix:semicolon
id|usb_deregister
c_func
(paren
op_amp
id|usb_storage_driver
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* While there are still virtual hosts, unregister them&n;&t; * Note that it&squot;s important to do this completely before removing&n;&t; * the structures because of possible races with the /proc&n;&t; * interface&n;&t; */
r_for
c_loop
(paren
id|next
op_assign
id|us_list
suffix:semicolon
id|next
suffix:semicolon
id|next
op_assign
id|next-&gt;next
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- calling scsi_unregister_host()&bslash;n&quot;
)paren
suffix:semicolon
id|scsi_unregister_host
c_func
(paren
op_amp
id|usb_stor_host_template
)paren
suffix:semicolon
)brace
multiline_comment|/* While there are still structures, free them.  Note that we are&n;&t; * now race-free, since these structures can no longer be accessed&n;&t; * from either the SCSI command layer or the /proc interface&n;&t; */
r_while
c_loop
(paren
id|us_list
)paren
(brace
multiline_comment|/* keep track of where the next one is */
id|next
op_assign
id|us_list-&gt;next
suffix:semicolon
multiline_comment|/* If there&squot;s extra data in the us_data structure then&n;&t;&t; * free that first */
r_if
c_cond
(paren
id|us_list-&gt;extra
)paren
(brace
multiline_comment|/* call the destructor routine, if it exists */
r_if
c_cond
(paren
id|us_list-&gt;extra_destructor
)paren
(brace
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- calling extra_destructor()&bslash;n&quot;
)paren
suffix:semicolon
id|us_list
op_member_access_from_pointer
id|extra_destructor
c_func
(paren
id|us_list-&gt;extra
)paren
suffix:semicolon
)brace
multiline_comment|/* destroy the extra data */
id|US_DEBUGP
c_func
(paren
l_string|&quot;-- freeing the data structure&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|us_list-&gt;extra
)paren
suffix:semicolon
)brace
multiline_comment|/* free the structure itself */
id|kfree
(paren
id|us_list
)paren
suffix:semicolon
multiline_comment|/* advance the list pointer */
id|us_list
op_assign
id|next
suffix:semicolon
)brace
macro_line|#endif
)brace
DECL|variable|usb_stor_init
id|module_init
c_func
(paren
id|usb_stor_init
)paren
suffix:semicolon
DECL|variable|usb_stor_exit
id|module_exit
c_func
(paren
id|usb_stor_exit
)paren
suffix:semicolon
eof
