multiline_comment|/*&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
DECL|macro|__NO_VERSION__
mdefine_line|#define&t;__NO_VERSION__&t;&t;/* Temporary: usbvideo is not a module yet */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/wrapper.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &quot;usbvideo.h&quot;
macro_line|#if defined(MAP_NR)
DECL|macro|virt_to_page
mdefine_line|#define&t;virt_to_page(v)&t;MAP_NR(v)&t;/* Kernels 2.2.x */
macro_line|#endif
DECL|variable|video_nr
r_static
r_int
id|video_nr
op_assign
op_minus
l_int|1
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|video_nr
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * Local prototypes.&n; */
macro_line|#if USES_PROC_FS
r_static
r_void
id|usbvideo_procfs_level1_create
c_func
(paren
id|usbvideo_t
op_star
id|ut
)paren
suffix:semicolon
r_static
r_void
id|usbvideo_procfs_level1_destroy
c_func
(paren
id|usbvideo_t
op_star
id|ut
)paren
suffix:semicolon
r_static
r_void
id|usbvideo_procfs_level2_create
c_func
(paren
id|uvd_t
op_star
id|uvd
)paren
suffix:semicolon
r_static
r_void
id|usbvideo_procfs_level2_destroy
c_func
(paren
id|uvd_t
op_star
id|uvd
)paren
suffix:semicolon
r_static
r_int
id|usbvideo_default_procfs_read_proc
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
suffix:semicolon
r_static
r_int
id|usbvideo_default_procfs_write_proc
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
r_int
id|count
comma
r_void
op_star
id|data
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*******************************/
multiline_comment|/* Memory management functions */
multiline_comment|/*******************************/
DECL|macro|MDEBUG
mdefine_line|#define MDEBUG(x)&t;do { } while(0)&t;&t;/* Debug memory management */
multiline_comment|/* Given PGD from the address space&squot;s page table, return the kernel&n; * virtual mapping of the physical memory mapped at ADR.&n; */
DECL|function|usbvideo_uvirt_to_kva
r_int
r_int
id|usbvideo_uvirt_to_kva
c_func
(paren
id|pgd_t
op_star
id|pgd
comma
r_int
r_int
id|adr
)paren
(brace
r_int
r_int
id|ret
op_assign
l_int|0UL
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
op_star
id|ptep
comma
id|pte
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pgd_none
c_func
(paren
op_star
id|pgd
)paren
)paren
(brace
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pgd
comma
id|adr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
id|ptep
op_assign
id|pte_offset
c_func
(paren
id|pmd
comma
id|adr
)paren
suffix:semicolon
id|pte
op_assign
op_star
id|ptep
suffix:semicolon
r_if
c_cond
(paren
id|pte_present
c_func
(paren
id|pte
)paren
)paren
(brace
id|ret
op_assign
(paren
r_int
r_int
)paren
id|page_address
c_func
(paren
id|pte_page
c_func
(paren
id|pte
)paren
)paren
suffix:semicolon
id|ret
op_or_assign
(paren
id|adr
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
id|MDEBUG
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;uv2kva(%lx--&gt;%lx)&quot;
comma
id|adr
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Here we want the physical address of the memory.&n; * This is used when initializing the contents of the&n; * area and marking the pages as reserved.&n; */
DECL|function|usbvideo_kvirt_to_pa
r_int
r_int
id|usbvideo_kvirt_to_pa
c_func
(paren
r_int
r_int
id|adr
)paren
(brace
r_int
r_int
id|va
comma
id|kva
comma
id|ret
suffix:semicolon
id|va
op_assign
id|VMALLOC_VMADDR
c_func
(paren
id|adr
)paren
suffix:semicolon
id|kva
op_assign
id|usbvideo_uvirt_to_kva
c_func
(paren
id|pgd_offset_k
c_func
(paren
id|va
)paren
comma
id|va
)paren
suffix:semicolon
id|ret
op_assign
id|__pa
c_func
(paren
id|kva
)paren
suffix:semicolon
id|MDEBUG
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;kv2pa(%lx--&gt;%lx)&quot;
comma
id|adr
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|usbvideo_rvmalloc
r_void
op_star
id|usbvideo_rvmalloc
c_func
(paren
r_int
r_int
id|size
)paren
(brace
r_void
op_star
id|mem
suffix:semicolon
r_int
r_int
id|adr
comma
id|page
suffix:semicolon
multiline_comment|/* Round it off to PAGE_SIZE */
id|size
op_add_assign
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|size
op_and_assign
op_complement
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|mem
op_assign
id|vmalloc_32
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mem
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|mem
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* Clear the ram out, no junk to the user */
id|adr
op_assign
(paren
r_int
r_int
)paren
id|mem
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|page
op_assign
id|usbvideo_kvirt_to_pa
c_func
(paren
id|adr
)paren
suffix:semicolon
id|mem_map_reserve
c_func
(paren
id|virt_to_page
c_func
(paren
id|__va
c_func
(paren
id|page
)paren
)paren
)paren
suffix:semicolon
id|adr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|PAGE_SIZE
)paren
id|size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
r_else
id|size
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|mem
suffix:semicolon
)brace
DECL|function|usbvideo_rvfree
r_void
id|usbvideo_rvfree
c_func
(paren
r_void
op_star
id|mem
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|adr
comma
id|page
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mem
)paren
r_return
suffix:semicolon
id|size
op_add_assign
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|size
op_and_assign
op_complement
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|adr
op_assign
(paren
r_int
r_int
)paren
id|mem
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|page
op_assign
id|usbvideo_kvirt_to_pa
c_func
(paren
id|adr
)paren
suffix:semicolon
id|mem_map_unreserve
c_func
(paren
id|virt_to_page
c_func
(paren
id|__va
c_func
(paren
id|page
)paren
)paren
)paren
suffix:semicolon
id|adr
op_add_assign
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|PAGE_SIZE
)paren
id|size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
r_else
id|size
op_assign
l_int|0
suffix:semicolon
)brace
id|vfree
c_func
(paren
id|mem
)paren
suffix:semicolon
)brace
DECL|function|RingQueue_Initialize
r_void
id|RingQueue_Initialize
c_func
(paren
id|RingQueue_t
op_star
id|rq
)paren
(brace
m_assert
(paren
id|rq
op_ne
l_int|NULL
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|rq-&gt;wqh
)paren
suffix:semicolon
)brace
DECL|function|RingQueue_Allocate
r_void
id|RingQueue_Allocate
c_func
(paren
id|RingQueue_t
op_star
id|rq
comma
r_int
id|rqLen
)paren
(brace
m_assert
(paren
id|rq
op_ne
l_int|NULL
)paren
suffix:semicolon
m_assert
(paren
id|rqLen
OG
l_int|0
)paren
suffix:semicolon
id|rq-&gt;length
op_assign
id|rqLen
suffix:semicolon
id|rq-&gt;queue
op_assign
id|usbvideo_rvmalloc
c_func
(paren
id|rq-&gt;length
)paren
suffix:semicolon
m_assert
(paren
id|rq-&gt;queue
op_ne
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|RingQueue_IsAllocated
r_int
id|RingQueue_IsAllocated
c_func
(paren
r_const
id|RingQueue_t
op_star
id|rq
)paren
(brace
r_if
c_cond
(paren
id|rq
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_return
(paren
id|rq-&gt;queue
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|rq-&gt;length
OG
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|RingQueue_Free
r_void
id|RingQueue_Free
c_func
(paren
id|RingQueue_t
op_star
id|rq
)paren
(brace
m_assert
(paren
id|rq
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|RingQueue_IsAllocated
c_func
(paren
id|rq
)paren
)paren
(brace
id|usbvideo_rvfree
c_func
(paren
id|rq-&gt;queue
comma
id|rq-&gt;length
)paren
suffix:semicolon
id|rq-&gt;queue
op_assign
l_int|NULL
suffix:semicolon
id|rq-&gt;length
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|RingQueue_Dequeue
r_int
id|RingQueue_Dequeue
c_func
(paren
id|RingQueue_t
op_star
id|rq
comma
r_int
r_char
op_star
id|dst
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
m_assert
(paren
id|rq
op_ne
l_int|NULL
)paren
suffix:semicolon
m_assert
(paren
id|dst
op_ne
l_int|NULL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dst
(braket
id|i
)braket
op_assign
id|rq-&gt;queue
(braket
id|rq-&gt;ri
)braket
suffix:semicolon
id|RING_QUEUE_DEQUEUE_BYTES
c_func
(paren
id|rq
comma
l_int|1
)paren
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
DECL|function|RingQueue_Enqueue
r_int
id|RingQueue_Enqueue
c_func
(paren
id|RingQueue_t
op_star
id|rq
comma
r_const
r_int
r_char
op_star
id|cdata
comma
r_int
id|n
)paren
(brace
r_int
id|enqueued
op_assign
l_int|0
suffix:semicolon
m_assert
(paren
id|rq
op_ne
l_int|NULL
)paren
suffix:semicolon
m_assert
(paren
id|cdata
op_ne
l_int|NULL
)paren
suffix:semicolon
m_assert
(paren
id|rq-&gt;length
OG
l_int|0
)paren
suffix:semicolon
r_while
c_loop
(paren
id|n
OG
l_int|0
)paren
(brace
r_int
id|m
comma
id|q_avail
suffix:semicolon
multiline_comment|/* Calculate the largest chunk that fits the tail of the ring */
id|q_avail
op_assign
id|rq-&gt;length
op_minus
id|rq-&gt;wi
suffix:semicolon
r_if
c_cond
(paren
id|q_avail
op_le
l_int|0
)paren
(brace
id|rq-&gt;wi
op_assign
l_int|0
suffix:semicolon
id|q_avail
op_assign
id|rq-&gt;length
suffix:semicolon
)brace
id|m
op_assign
id|n
suffix:semicolon
m_assert
(paren
id|q_avail
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
OG
id|q_avail
)paren
id|m
op_assign
id|q_avail
suffix:semicolon
id|memmove
c_func
(paren
id|rq-&gt;queue
op_plus
id|rq-&gt;wi
comma
id|cdata
comma
id|m
)paren
suffix:semicolon
id|RING_QUEUE_ADVANCE_INDEX
c_func
(paren
id|rq
comma
id|wi
comma
id|m
)paren
suffix:semicolon
id|cdata
op_add_assign
id|m
suffix:semicolon
id|enqueued
op_add_assign
id|m
suffix:semicolon
id|n
op_sub_assign
id|m
suffix:semicolon
)brace
r_return
id|enqueued
suffix:semicolon
)brace
DECL|function|RingQueue_GetLength
r_int
id|RingQueue_GetLength
c_func
(paren
r_const
id|RingQueue_t
op_star
id|rq
)paren
(brace
r_int
id|ri
comma
id|wi
suffix:semicolon
m_assert
(paren
id|rq
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ri
op_assign
id|rq-&gt;ri
suffix:semicolon
id|wi
op_assign
id|rq-&gt;wi
suffix:semicolon
r_if
c_cond
(paren
id|ri
op_eq
id|wi
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ri
OL
id|wi
)paren
r_return
id|wi
op_minus
id|ri
suffix:semicolon
r_else
r_return
id|wi
op_plus
(paren
id|rq-&gt;length
op_minus
id|ri
)paren
suffix:semicolon
)brace
DECL|function|RingQueue_InterruptibleSleepOn
r_void
id|RingQueue_InterruptibleSleepOn
c_func
(paren
id|RingQueue_t
op_star
id|rq
)paren
(brace
m_assert
(paren
id|rq
op_ne
l_int|NULL
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|rq-&gt;wqh
)paren
suffix:semicolon
)brace
DECL|function|RingQueue_WakeUpInterruptible
r_void
id|RingQueue_WakeUpInterruptible
c_func
(paren
id|RingQueue_t
op_star
id|rq
)paren
(brace
m_assert
(paren
id|rq
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|rq-&gt;wqh
)paren
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|rq-&gt;wqh
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * usbvideo_VideosizeToString()&n; *&n; * This procedure converts given videosize value to readable string.&n; *&n; * History:&n; * 07-Aug-2000 Created.&n; * 19-Oct-2000 Reworked for usbvideo module.&n; */
DECL|function|usbvideo_VideosizeToString
r_void
id|usbvideo_VideosizeToString
c_func
(paren
r_char
op_star
id|buf
comma
r_int
id|bufLen
comma
id|videosize_t
id|vs
)paren
(brace
r_char
id|tmp
(braket
l_int|40
)braket
suffix:semicolon
r_int
id|n
suffix:semicolon
id|n
op_assign
l_int|1
op_plus
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%ldx%ld&quot;
comma
id|VIDEOSIZE_X
c_func
(paren
id|vs
)paren
comma
id|VIDEOSIZE_Y
c_func
(paren
id|vs
)paren
)paren
suffix:semicolon
m_assert
(paren
id|n
OL
r_sizeof
(paren
id|tmp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|buf
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|bufLen
OL
id|n
)paren
)paren
id|err
c_func
(paren
l_string|&quot;usbvideo_VideosizeToString: buffer is too small.&quot;
)paren
suffix:semicolon
r_else
id|memmove
c_func
(paren
id|buf
comma
id|tmp
comma
id|n
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * usbvideo_OverlayChar()&n; *&n; * History:&n; * 01-Feb-2000 Created.&n; */
DECL|function|usbvideo_OverlayChar
r_void
id|usbvideo_OverlayChar
c_func
(paren
id|uvd_t
op_star
id|uvd
comma
id|usbvideo_frame_t
op_star
id|frame
comma
r_int
id|x
comma
r_int
id|y
comma
r_int
id|ch
)paren
(brace
r_static
r_const
r_int
r_int
id|digits
(braket
l_int|16
)braket
op_assign
(brace
l_int|0xF6DE
comma
multiline_comment|/* 0 */
l_int|0x2492
comma
multiline_comment|/* 1 */
l_int|0xE7CE
comma
multiline_comment|/* 2 */
l_int|0xE79E
comma
multiline_comment|/* 3 */
l_int|0xB792
comma
multiline_comment|/* 4 */
l_int|0xF39E
comma
multiline_comment|/* 5 */
l_int|0xF3DE
comma
multiline_comment|/* 6 */
l_int|0xF492
comma
multiline_comment|/* 7 */
l_int|0xF7DE
comma
multiline_comment|/* 8 */
l_int|0xF79E
comma
multiline_comment|/* 9 */
l_int|0x77DA
comma
multiline_comment|/* a */
l_int|0xD75C
comma
multiline_comment|/* b */
l_int|0xF24E
comma
multiline_comment|/* c */
l_int|0xD6DC
comma
multiline_comment|/* d */
l_int|0xF34E
comma
multiline_comment|/* e */
l_int|0xF348
multiline_comment|/* f */
)brace
suffix:semicolon
r_int
r_int
id|digit
suffix:semicolon
r_int
id|ix
comma
id|iy
suffix:semicolon
r_if
c_cond
(paren
(paren
id|uvd
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|frame
op_eq
l_int|NULL
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_ge
l_char|&squot;0&squot;
op_logical_and
id|ch
op_le
l_char|&squot;9&squot;
)paren
id|ch
op_sub_assign
l_char|&squot;0&squot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ch
op_ge
l_char|&squot;A&squot;
op_logical_and
id|ch
op_le
l_char|&squot;F&squot;
)paren
id|ch
op_assign
l_int|10
op_plus
(paren
id|ch
op_minus
l_char|&squot;A&squot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ch
op_ge
l_char|&squot;a&squot;
op_logical_and
id|ch
op_le
l_char|&squot;f&squot;
)paren
id|ch
op_assign
l_int|10
op_plus
(paren
id|ch
op_minus
l_char|&squot;a&squot;
)paren
suffix:semicolon
r_else
r_return
suffix:semicolon
id|digit
op_assign
id|digits
(braket
id|ch
)braket
suffix:semicolon
r_for
c_loop
(paren
id|iy
op_assign
l_int|0
suffix:semicolon
id|iy
OL
l_int|5
suffix:semicolon
id|iy
op_increment
)paren
(brace
r_for
c_loop
(paren
id|ix
op_assign
l_int|0
suffix:semicolon
id|ix
OL
l_int|3
suffix:semicolon
id|ix
op_increment
)paren
(brace
r_if
c_cond
(paren
id|digit
op_amp
l_int|0x8000
)paren
(brace
r_if
c_cond
(paren
id|uvd-&gt;paletteBits
op_amp
(paren
l_int|1L
op_lshift
id|VIDEO_PALETTE_RGB24
)paren
)paren
(brace
multiline_comment|/* TODO */
id|RGB24_PUTPIXEL
c_func
(paren
id|frame
comma
id|x
op_plus
id|ix
comma
id|y
op_plus
id|iy
comma
l_int|0xFF
comma
l_int|0xFF
comma
l_int|0xFF
)paren
suffix:semicolon
)brace
)brace
id|digit
op_assign
id|digit
op_lshift
l_int|1
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * usbvideo_OverlayString()&n; *&n; * History:&n; * 01-Feb-2000 Created.&n; */
DECL|function|usbvideo_OverlayString
r_void
id|usbvideo_OverlayString
c_func
(paren
id|uvd_t
op_star
id|uvd
comma
id|usbvideo_frame_t
op_star
id|frame
comma
r_int
id|x
comma
r_int
id|y
comma
r_const
r_char
op_star
id|str
)paren
(brace
r_while
c_loop
(paren
op_star
id|str
)paren
(brace
id|usbvideo_OverlayChar
c_func
(paren
id|uvd
comma
id|frame
comma
id|x
comma
id|y
comma
op_star
id|str
)paren
suffix:semicolon
id|str
op_increment
suffix:semicolon
id|x
op_add_assign
l_int|4
suffix:semicolon
multiline_comment|/* 3 pixels character + 1 space */
)brace
)brace
multiline_comment|/*&n; * usbvideo_OverlayStats()&n; *&n; * Overlays important debugging information.&n; *&n; * History:&n; * 01-Feb-2000 Created.&n; */
DECL|function|usbvideo_OverlayStats
r_void
id|usbvideo_OverlayStats
c_func
(paren
id|uvd_t
op_star
id|uvd
comma
id|usbvideo_frame_t
op_star
id|frame
)paren
(brace
r_const
r_int
id|y_diff
op_assign
l_int|8
suffix:semicolon
r_char
id|tmp
(braket
l_int|16
)braket
suffix:semicolon
r_int
id|x
op_assign
l_int|10
comma
id|y
op_assign
l_int|10
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|barLength
suffix:semicolon
r_const
r_int
id|qi_x1
op_assign
l_int|60
comma
id|qi_y1
op_assign
l_int|10
suffix:semicolon
r_const
r_int
id|qi_x2
op_assign
id|VIDEOSIZE_X
c_func
(paren
id|frame-&gt;request
)paren
op_minus
l_int|10
comma
id|qi_h
op_assign
l_int|10
suffix:semicolon
multiline_comment|/* Call the user callback, see if we may proceed after that */
r_if
c_cond
(paren
id|VALID_CALLBACK
c_func
(paren
id|uvd
comma
id|overlayHook
)paren
)paren
(brace
r_if
c_cond
(paren
id|GET_CALLBACK
c_func
(paren
id|uvd
comma
id|overlayHook
)paren
(paren
id|uvd
comma
id|frame
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We draw a (mostly) hollow rectangle with qi_xxx coordinates.&n;&t; * Left edge symbolizes the queue index 0; right edge symbolizes&n;&t; * the full capacity of the queue.&n;&t; */
id|barLength
op_assign
id|qi_x2
op_minus
id|qi_x1
op_minus
l_int|2
suffix:semicolon
r_if
c_cond
(paren
(paren
id|barLength
OG
l_int|10
)paren
op_logical_and
(paren
id|uvd-&gt;paletteBits
op_amp
(paren
l_int|1L
op_lshift
id|VIDEO_PALETTE_RGB24
)paren
)paren
)paren
(brace
multiline_comment|/* TODO */
r_int
id|u_lo
comma
id|u_hi
comma
id|q_used
suffix:semicolon
r_int
id|m_ri
comma
id|m_wi
comma
id|m_lo
comma
id|m_hi
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Determine fill zones (used areas of the queue):&n;&t;&t; * 0 xxxxxxx u_lo ...... uvd-&gt;dp.ri xxxxxxxx u_hi ..... uvd-&gt;dp.length&n;&t;&t; *&n;&t;&t; * if u_lo &lt; 0 then there is no first filler.&n;&t;&t; */
id|q_used
op_assign
id|RingQueue_GetLength
c_func
(paren
op_amp
id|uvd-&gt;dp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|uvd-&gt;dp.ri
op_plus
id|q_used
)paren
op_ge
id|uvd-&gt;dp.length
)paren
(brace
id|u_hi
op_assign
id|uvd-&gt;dp.length
suffix:semicolon
id|u_lo
op_assign
(paren
id|q_used
op_plus
id|uvd-&gt;dp.ri
)paren
op_mod
id|uvd-&gt;dp.length
suffix:semicolon
)brace
r_else
(brace
id|u_hi
op_assign
(paren
id|q_used
op_plus
id|uvd-&gt;dp.ri
)paren
suffix:semicolon
id|u_lo
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Convert byte indices into screen units */
id|m_ri
op_assign
id|qi_x1
op_plus
(paren
(paren
id|barLength
op_star
id|uvd-&gt;dp.ri
)paren
op_div
id|uvd-&gt;dp.length
)paren
suffix:semicolon
id|m_wi
op_assign
id|qi_x1
op_plus
(paren
(paren
id|barLength
op_star
id|uvd-&gt;dp.wi
)paren
op_div
id|uvd-&gt;dp.length
)paren
suffix:semicolon
id|m_lo
op_assign
(paren
id|u_lo
OG
l_int|0
)paren
ques
c_cond
(paren
id|qi_x1
op_plus
(paren
(paren
id|barLength
op_star
id|u_lo
)paren
op_div
id|uvd-&gt;dp.length
)paren
)paren
suffix:colon
op_minus
l_int|1
suffix:semicolon
id|m_hi
op_assign
id|qi_x1
op_plus
(paren
(paren
id|barLength
op_star
id|u_hi
)paren
op_div
id|uvd-&gt;dp.length
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|qi_y1
suffix:semicolon
id|j
OL
(paren
id|qi_y1
op_plus
id|qi_h
)paren
suffix:semicolon
id|j
op_increment
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|qi_x1
suffix:semicolon
id|i
OL
id|qi_x2
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Draw border lines */
r_if
c_cond
(paren
(paren
id|j
op_eq
id|qi_y1
)paren
op_logical_or
(paren
id|j
op_eq
(paren
id|qi_y1
op_plus
id|qi_h
op_minus
l_int|1
)paren
)paren
op_logical_or
(paren
id|i
op_eq
id|qi_x1
)paren
op_logical_or
(paren
id|i
op_eq
(paren
id|qi_x2
op_minus
l_int|1
)paren
)paren
)paren
(brace
id|RGB24_PUTPIXEL
c_func
(paren
id|frame
comma
id|i
comma
id|j
comma
l_int|0xFF
comma
l_int|0xFF
comma
l_int|0xFF
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* For all other points the Y coordinate does not matter */
r_if
c_cond
(paren
(paren
id|i
op_ge
id|m_ri
)paren
op_logical_and
(paren
id|i
op_le
(paren
id|m_ri
op_plus
l_int|3
)paren
)paren
)paren
(brace
id|RGB24_PUTPIXEL
c_func
(paren
id|frame
comma
id|i
comma
id|j
comma
l_int|0x00
comma
l_int|0xFF
comma
l_int|0x00
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|i
op_ge
id|m_wi
)paren
op_logical_and
(paren
id|i
op_le
(paren
id|m_wi
op_plus
l_int|3
)paren
)paren
)paren
(brace
id|RGB24_PUTPIXEL
c_func
(paren
id|frame
comma
id|i
comma
id|j
comma
l_int|0xFF
comma
l_int|0x00
comma
l_int|0x00
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|i
OL
id|m_lo
)paren
op_logical_or
(paren
(paren
id|i
OG
id|m_ri
)paren
op_logical_and
(paren
id|i
OL
id|m_hi
)paren
)paren
)paren
id|RGB24_PUTPIXEL
c_func
(paren
id|frame
comma
id|i
comma
id|j
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0xFF
)paren
suffix:semicolon
)brace
)brace
)brace
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8lx&quot;
comma
id|uvd-&gt;stats.frame_num
)paren
suffix:semicolon
id|usbvideo_OverlayString
c_func
(paren
id|uvd
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8lx&quot;
comma
id|uvd-&gt;stats.urb_count
)paren
suffix:semicolon
id|usbvideo_OverlayString
c_func
(paren
id|uvd
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8lx&quot;
comma
id|uvd-&gt;stats.urb_length
)paren
suffix:semicolon
id|usbvideo_OverlayString
c_func
(paren
id|uvd
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8lx&quot;
comma
id|uvd-&gt;stats.data_count
)paren
suffix:semicolon
id|usbvideo_OverlayString
c_func
(paren
id|uvd
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8lx&quot;
comma
id|uvd-&gt;stats.header_count
)paren
suffix:semicolon
id|usbvideo_OverlayString
c_func
(paren
id|uvd
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8lx&quot;
comma
id|uvd-&gt;stats.iso_skip_count
)paren
suffix:semicolon
id|usbvideo_OverlayString
c_func
(paren
id|uvd
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8lx&quot;
comma
id|uvd-&gt;stats.iso_err_count
)paren
suffix:semicolon
id|usbvideo_OverlayString
c_func
(paren
id|uvd
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8x&quot;
comma
id|uvd-&gt;vpic.colour
)paren
suffix:semicolon
id|usbvideo_OverlayString
c_func
(paren
id|uvd
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8x&quot;
comma
id|uvd-&gt;vpic.hue
)paren
suffix:semicolon
id|usbvideo_OverlayString
c_func
(paren
id|uvd
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8x&quot;
comma
id|uvd-&gt;vpic.brightness
op_rshift
l_int|8
)paren
suffix:semicolon
id|usbvideo_OverlayString
c_func
(paren
id|uvd
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8x&quot;
comma
id|uvd-&gt;vpic.contrast
op_rshift
l_int|12
)paren
suffix:semicolon
id|usbvideo_OverlayString
c_func
(paren
id|uvd
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;%8d&quot;
comma
id|uvd-&gt;vpic.whiteness
op_rshift
l_int|8
)paren
suffix:semicolon
id|usbvideo_OverlayString
c_func
(paren
id|uvd
comma
id|frame
comma
id|x
comma
id|y
comma
id|tmp
)paren
suffix:semicolon
id|y
op_add_assign
id|y_diff
suffix:semicolon
)brace
multiline_comment|/*&n; * usbvideo_ReportStatistics()&n; *&n; * This procedure prints packet and transfer statistics.&n; *&n; * History:&n; * 14-Jan-2000 Corrected default multiplier.&n; */
DECL|function|usbvideo_ReportStatistics
r_void
id|usbvideo_ReportStatistics
c_func
(paren
r_const
id|uvd_t
op_star
id|uvd
)paren
(brace
r_if
c_cond
(paren
(paren
id|uvd
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|uvd-&gt;stats.urb_count
OG
l_int|0
)paren
)paren
(brace
r_int
r_int
id|allPackets
comma
id|badPackets
comma
id|goodPackets
comma
id|percent
suffix:semicolon
id|allPackets
op_assign
id|uvd-&gt;stats.urb_count
op_star
id|CAMERA_URB_FRAMES
suffix:semicolon
id|badPackets
op_assign
id|uvd-&gt;stats.iso_skip_count
op_plus
id|uvd-&gt;stats.iso_err_count
suffix:semicolon
id|goodPackets
op_assign
id|allPackets
op_minus
id|badPackets
suffix:semicolon
multiline_comment|/* Calculate percentage wisely, remember integer limits */
m_assert
(paren
id|allPackets
op_ne
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|goodPackets
OL
(paren
(paren
(paren
r_int
r_int
)paren
op_minus
l_int|1
)paren
op_div
l_int|100
)paren
)paren
id|percent
op_assign
(paren
l_int|100
op_star
id|goodPackets
)paren
op_div
id|allPackets
suffix:semicolon
r_else
id|percent
op_assign
id|goodPackets
op_div
(paren
id|allPackets
op_div
l_int|100
)paren
suffix:semicolon
id|info
c_func
(paren
l_string|&quot;Packet Statistics: Total=%lu. Empty=%lu. Usage=%lu%%&quot;
comma
id|allPackets
comma
id|badPackets
comma
id|percent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uvd-&gt;iso_packet_len
OG
l_int|0
)paren
(brace
r_int
r_int
id|allBytes
comma
id|xferBytes
suffix:semicolon
r_char
id|multiplier
op_assign
l_char|&squot; &squot;
suffix:semicolon
id|allBytes
op_assign
id|allPackets
op_star
id|uvd-&gt;iso_packet_len
suffix:semicolon
id|xferBytes
op_assign
id|uvd-&gt;stats.data_count
suffix:semicolon
m_assert
(paren
id|allBytes
op_ne
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xferBytes
OL
(paren
(paren
(paren
r_int
r_int
)paren
op_minus
l_int|1
)paren
op_div
l_int|100
)paren
)paren
id|percent
op_assign
(paren
l_int|100
op_star
id|xferBytes
)paren
op_div
id|allBytes
suffix:semicolon
r_else
id|percent
op_assign
id|xferBytes
op_div
(paren
id|allBytes
op_div
l_int|100
)paren
suffix:semicolon
multiline_comment|/* Scale xferBytes for easy reading */
r_if
c_cond
(paren
id|xferBytes
OG
l_int|10
op_star
l_int|1024
)paren
(brace
id|xferBytes
op_div_assign
l_int|1024
suffix:semicolon
id|multiplier
op_assign
l_char|&squot;K&squot;
suffix:semicolon
r_if
c_cond
(paren
id|xferBytes
OG
l_int|10
op_star
l_int|1024
)paren
(brace
id|xferBytes
op_div_assign
l_int|1024
suffix:semicolon
id|multiplier
op_assign
l_char|&squot;M&squot;
suffix:semicolon
r_if
c_cond
(paren
id|xferBytes
OG
l_int|10
op_star
l_int|1024
)paren
(brace
id|xferBytes
op_div_assign
l_int|1024
suffix:semicolon
id|multiplier
op_assign
l_char|&squot;G&squot;
suffix:semicolon
r_if
c_cond
(paren
id|xferBytes
OG
l_int|10
op_star
l_int|1024
)paren
(brace
id|xferBytes
op_div_assign
l_int|1024
suffix:semicolon
id|multiplier
op_assign
l_char|&squot;T&squot;
suffix:semicolon
)brace
)brace
)brace
)brace
id|info
c_func
(paren
l_string|&quot;Transfer Statistics: Transferred=%lu%cB Usage=%lu%%&quot;
comma
id|xferBytes
comma
id|multiplier
comma
id|percent
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * usbvideo_DrawLine()&n; *&n; * A standard implementation of Bresenham&squot;s line drawing algorithm.&n; * This procedure is provided primarily for debugging or demo&n; * purposes.&n; */
DECL|function|usbvideo_DrawLine
r_void
id|usbvideo_DrawLine
c_func
(paren
id|usbvideo_frame_t
op_star
id|frame
comma
r_int
id|x1
comma
r_int
id|y1
comma
r_int
id|x2
comma
r_int
id|y2
comma
r_int
r_char
id|cr
comma
r_int
r_char
id|cg
comma
r_int
r_char
id|cb
)paren
(brace
r_int
id|i
comma
id|dx
comma
id|dy
comma
id|np
comma
id|d
suffix:semicolon
r_int
id|dinc1
comma
id|dinc2
comma
id|x
comma
id|xinc1
comma
id|xinc2
comma
id|y
comma
id|yinc1
comma
id|yinc2
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dx
op_assign
id|x2
op_minus
id|x1
)paren
OL
l_int|0
)paren
id|dx
op_assign
op_minus
id|dx
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dy
op_assign
id|y2
op_minus
id|y1
)paren
OL
l_int|0
)paren
id|dy
op_assign
op_minus
id|dy
suffix:semicolon
r_if
c_cond
(paren
id|dx
op_ge
id|dy
)paren
(brace
id|np
op_assign
id|dx
op_plus
l_int|1
suffix:semicolon
id|d
op_assign
(paren
l_int|2
op_star
id|dy
)paren
op_minus
id|dx
suffix:semicolon
id|dinc1
op_assign
id|dy
op_lshift
l_int|1
suffix:semicolon
id|dinc2
op_assign
(paren
id|dy
op_minus
id|dx
)paren
op_lshift
l_int|1
suffix:semicolon
id|xinc1
op_assign
l_int|1
suffix:semicolon
id|xinc2
op_assign
l_int|1
suffix:semicolon
id|yinc1
op_assign
l_int|0
suffix:semicolon
id|yinc2
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|np
op_assign
id|dy
op_plus
l_int|1
suffix:semicolon
id|d
op_assign
(paren
l_int|2
op_star
id|dx
)paren
op_minus
id|dy
suffix:semicolon
id|dinc1
op_assign
id|dx
op_lshift
l_int|1
suffix:semicolon
id|dinc2
op_assign
(paren
id|dx
op_minus
id|dy
)paren
op_lshift
l_int|1
suffix:semicolon
id|xinc1
op_assign
l_int|0
suffix:semicolon
id|xinc2
op_assign
l_int|1
suffix:semicolon
id|yinc1
op_assign
l_int|1
suffix:semicolon
id|yinc2
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Make sure x and y move in the right directions */
r_if
c_cond
(paren
id|x1
OG
id|x2
)paren
(brace
id|xinc1
op_assign
op_minus
id|xinc1
suffix:semicolon
id|xinc2
op_assign
op_minus
id|xinc2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|y1
OG
id|y2
)paren
(brace
id|yinc1
op_assign
op_minus
id|yinc1
suffix:semicolon
id|yinc2
op_assign
op_minus
id|yinc2
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|x
op_assign
id|x1
comma
id|y
op_assign
id|y1
suffix:semicolon
id|i
OL
id|np
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|frame-&gt;palette
op_eq
id|VIDEO_PALETTE_RGB24
)paren
(brace
multiline_comment|/* TODO */
id|RGB24_PUTPIXEL
c_func
(paren
id|frame
comma
id|x
comma
id|y
comma
id|cr
comma
id|cg
comma
id|cb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|d
OL
l_int|0
)paren
(brace
id|d
op_add_assign
id|dinc1
suffix:semicolon
id|x
op_add_assign
id|xinc1
suffix:semicolon
id|y
op_add_assign
id|yinc1
suffix:semicolon
)brace
r_else
(brace
id|d
op_add_assign
id|dinc2
suffix:semicolon
id|x
op_add_assign
id|xinc2
suffix:semicolon
id|y
op_add_assign
id|yinc2
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * usbvideo_TestPattern()&n; *&n; * Procedure forms a test pattern (yellow grid on blue background).&n; *&n; * Parameters:&n; * fullframe: if TRUE then entire frame is filled, otherwise the procedure&n; *&t;      continues from the current scanline.&n; * pmode      0: fill the frame with solid blue color (like on VCR or TV)&n; *&t;      1: Draw a colored grid&n; *&n; * History:&n; * 01-Feb-2000 Created.&n; */
DECL|function|usbvideo_TestPattern
r_void
id|usbvideo_TestPattern
c_func
(paren
id|uvd_t
op_star
id|uvd
comma
r_int
id|fullframe
comma
r_int
id|pmode
)paren
(brace
r_static
r_const
r_char
id|proc
(braket
)braket
op_assign
l_string|&quot;usbvideo_TestPattern&quot;
suffix:semicolon
id|usbvideo_frame_t
op_star
id|frame
suffix:semicolon
r_int
id|num_cell
op_assign
l_int|0
suffix:semicolon
r_int
id|scan_length
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|num_pass
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|uvd
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: uvd == NULL&quot;
comma
id|proc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|uvd-&gt;curframe
OL
l_int|0
)paren
op_logical_or
(paren
id|uvd-&gt;curframe
op_ge
id|USBVIDEO_NUMFRAMES
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: uvd-&gt;curframe=%d.&quot;
comma
id|proc
comma
id|uvd-&gt;curframe
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Grab the current frame */
id|frame
op_assign
op_amp
id|uvd-&gt;frame
(braket
id|uvd-&gt;curframe
)braket
suffix:semicolon
multiline_comment|/* Optionally start at the beginning */
r_if
c_cond
(paren
id|fullframe
)paren
(brace
id|frame-&gt;curline
op_assign
l_int|0
suffix:semicolon
id|frame-&gt;seqRead_Length
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#if 0
(brace
multiline_comment|/* For debugging purposes only */
r_char
id|tmp
(braket
l_int|20
)braket
suffix:semicolon
id|usbvideo_VideosizeToString
c_func
(paren
id|tmp
comma
r_sizeof
(paren
id|tmp
)paren
comma
id|frame-&gt;request
)paren
suffix:semicolon
id|info
c_func
(paren
l_string|&quot;testpattern: frame=%s&quot;
comma
id|tmp
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Form every scan line */
r_for
c_loop
(paren
suffix:semicolon
id|frame-&gt;curline
OL
id|VIDEOSIZE_Y
c_func
(paren
id|frame-&gt;request
)paren
suffix:semicolon
id|frame-&gt;curline
op_increment
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
op_star
id|f
op_assign
id|frame-&gt;data
op_plus
(paren
id|VIDEOSIZE_X
c_func
(paren
id|frame-&gt;request
)paren
op_star
id|V4L_BYTES_PER_PIXEL
op_star
id|frame-&gt;curline
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|VIDEOSIZE_X
c_func
(paren
id|frame-&gt;request
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_char
id|cb
op_assign
l_int|0x80
suffix:semicolon
r_int
r_char
id|cg
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|cr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pmode
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|frame-&gt;curline
op_mod
l_int|32
op_eq
l_int|0
)paren
id|cb
op_assign
l_int|0
comma
id|cg
op_assign
id|cr
op_assign
l_int|0xFF
suffix:semicolon
r_else
r_if
c_cond
(paren
id|i
op_mod
l_int|32
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|frame-&gt;curline
op_mod
l_int|32
op_eq
l_int|1
)paren
id|num_cell
op_increment
suffix:semicolon
id|cb
op_assign
l_int|0
comma
id|cg
op_assign
id|cr
op_assign
l_int|0xFF
suffix:semicolon
)brace
r_else
(brace
id|cb
op_assign
(paren
(paren
id|num_cell
op_star
l_int|7
)paren
op_plus
id|num_pass
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|cg
op_assign
(paren
(paren
id|num_cell
op_star
l_int|5
)paren
op_plus
id|num_pass
op_star
l_int|2
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|cr
op_assign
(paren
(paren
id|num_cell
op_star
l_int|3
)paren
op_plus
id|num_pass
op_star
l_int|3
)paren
op_amp
l_int|0xFF
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Just the blue screen */
)brace
op_star
id|f
op_increment
op_assign
id|cb
suffix:semicolon
op_star
id|f
op_increment
op_assign
id|cg
suffix:semicolon
op_star
id|f
op_increment
op_assign
id|cr
suffix:semicolon
id|scan_length
op_add_assign
l_int|3
suffix:semicolon
)brace
)brace
id|frame-&gt;frameState
op_assign
id|FrameState_Done
suffix:semicolon
id|frame-&gt;seqRead_Length
op_add_assign
id|scan_length
suffix:semicolon
op_increment
id|num_pass
suffix:semicolon
multiline_comment|/* We do this unconditionally, regardless of FLAGS_OVERLAY_STATS */
id|usbvideo_OverlayStats
c_func
(paren
id|uvd
comma
id|frame
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * usbvideo_HexDump()&n; *&n; * A debugging tool. Prints hex dumps.&n; *&n; * History:&n; * 29-Jul-2000 Added printing of offsets.&n; */
DECL|function|usbvideo_HexDump
r_void
id|usbvideo_HexDump
c_func
(paren
r_const
r_int
r_char
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_const
r_int
id|bytes_per_line
op_assign
l_int|32
suffix:semicolon
r_char
id|tmp
(braket
l_int|128
)braket
suffix:semicolon
multiline_comment|/* 32*3 + 5 */
r_int
id|i
comma
id|k
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|k
op_assign
l_int|0
suffix:semicolon
id|len
OG
l_int|0
suffix:semicolon
id|i
op_increment
comma
id|len
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|i
OG
l_int|0
op_logical_and
(paren
(paren
id|i
op_mod
id|bytes_per_line
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|tmp
)paren
suffix:semicolon
id|k
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|i
op_mod
id|bytes_per_line
)paren
op_eq
l_int|0
)paren
id|k
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|tmp
(braket
id|k
)braket
comma
l_string|&quot;%04x: &quot;
comma
id|i
)paren
suffix:semicolon
id|k
op_add_assign
id|sprintf
c_func
(paren
op_amp
id|tmp
(braket
id|k
)braket
comma
l_string|&quot;%02x &quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|k
OG
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|tmp
)paren
suffix:semicolon
)brace
multiline_comment|/* Debugging aid */
DECL|function|usbvideo_SayAndWait
r_void
id|usbvideo_SayAndWait
c_func
(paren
r_const
r_char
op_star
id|what
)paren
(brace
id|wait_queue_head_t
id|wq
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|wq
)paren
suffix:semicolon
id|info
c_func
(paren
l_string|&quot;Say: %s&quot;
comma
id|what
)paren
suffix:semicolon
id|interruptible_sleep_on_timeout
(paren
op_amp
id|wq
comma
id|HZ
op_star
l_int|3
)paren
suffix:semicolon
multiline_comment|/* Timeout */
)brace
multiline_comment|/* ******************************************************************** */
DECL|function|usbvideo_ClientIncModCount
r_static
r_void
id|usbvideo_ClientIncModCount
c_func
(paren
id|uvd_t
op_star
id|uvd
)paren
(brace
r_static
r_const
r_char
id|proc
(braket
)braket
op_assign
l_string|&quot;usbvideo_ClientIncModCount&quot;
suffix:semicolon
r_if
c_cond
(paren
id|uvd
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: uvd == NULL&quot;
comma
id|proc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uvd-&gt;handle
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: uvd-&gt;handle == NULL&quot;
comma
id|proc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uvd-&gt;handle-&gt;md_module
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: uvd-&gt;handle-&gt;md_module == NULL&quot;
comma
id|proc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|__MOD_INC_USE_COUNT
c_func
(paren
id|uvd-&gt;handle-&gt;md_module
)paren
suffix:semicolon
)brace
DECL|function|usbvideo_ClientDecModCount
r_static
r_void
id|usbvideo_ClientDecModCount
c_func
(paren
id|uvd_t
op_star
id|uvd
)paren
(brace
r_static
r_const
r_char
id|proc
(braket
)braket
op_assign
l_string|&quot;usbvideo_ClientDecModCount&quot;
suffix:semicolon
r_if
c_cond
(paren
id|uvd
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: uvd == NULL&quot;
comma
id|proc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uvd-&gt;handle
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: uvd-&gt;handle == NULL&quot;
comma
id|proc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uvd-&gt;handle-&gt;md_module
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: uvd-&gt;handle-&gt;md_module == NULL&quot;
comma
id|proc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|__MOD_DEC_USE_COUNT
c_func
(paren
id|uvd-&gt;handle-&gt;md_module
)paren
suffix:semicolon
)brace
DECL|function|usbvideo_register
r_int
id|usbvideo_register
c_func
(paren
id|usbvideo_t
op_star
op_star
id|pCams
comma
r_const
r_int
id|num_cams
comma
r_const
r_int
id|num_extra
comma
r_const
r_char
op_star
id|driverName
comma
r_const
id|usbvideo_cb_t
op_star
id|cbTbl
comma
r_struct
id|module
op_star
id|md
)paren
(brace
r_static
r_const
r_char
id|proc
(braket
)braket
op_assign
l_string|&quot;usbvideo_register&quot;
suffix:semicolon
id|usbvideo_t
op_star
id|cams
suffix:semicolon
r_int
id|i
comma
id|base_size
suffix:semicolon
multiline_comment|/* Check parameters for sanity */
r_if
c_cond
(paren
(paren
id|num_cams
op_le
l_int|0
)paren
op_logical_or
(paren
id|pCams
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|cbTbl
op_eq
l_int|NULL
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: Illegal call&quot;
comma
id|proc
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Check registration callback - must be set! */
r_if
c_cond
(paren
id|cbTbl-&gt;probe
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: probe() is required!&quot;
comma
id|proc
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|base_size
op_assign
id|num_cams
op_star
r_sizeof
(paren
id|uvd_t
)paren
op_plus
r_sizeof
(paren
id|usbvideo_t
)paren
suffix:semicolon
id|cams
op_assign
(paren
id|usbvideo_t
op_star
)paren
id|kmalloc
c_func
(paren
id|base_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cams
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Failed to allocate %d. bytes for usbvideo_t&quot;
comma
id|base_size
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;%s: Allocated $%p (%d. bytes) for %d. cameras&quot;
comma
id|proc
comma
id|cams
comma
id|base_size
comma
id|num_cams
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cams
comma
l_int|0
comma
id|base_size
)paren
suffix:semicolon
multiline_comment|/* Copy callbacks, apply defaults for those that are not set */
id|memmove
c_func
(paren
op_amp
id|cams-&gt;cb
comma
id|cbTbl
comma
r_sizeof
(paren
id|cams-&gt;cb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cams-&gt;cb.getFrame
op_eq
l_int|NULL
)paren
id|cams-&gt;cb.getFrame
op_assign
id|usbvideo_GetFrame
suffix:semicolon
r_if
c_cond
(paren
id|cams-&gt;cb.disconnect
op_eq
l_int|NULL
)paren
id|cams-&gt;cb.disconnect
op_assign
id|usbvideo_Disconnect
suffix:semicolon
macro_line|#if USES_PROC_FS
multiline_comment|/*&n;&t; * If both /proc fs callbacks are NULL then we assume that the driver&n;&t; * does not need procfs services at all. Leave them NULL.&n;&t; */
id|cams-&gt;uses_procfs
op_assign
(paren
id|cams-&gt;cb.procfs_read
op_ne
l_int|NULL
)paren
op_logical_or
(paren
id|cams-&gt;cb.procfs_write
op_eq
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cams-&gt;uses_procfs
)paren
(brace
r_if
c_cond
(paren
id|cams-&gt;cb.procfs_read
op_eq
l_int|NULL
)paren
id|cams-&gt;cb.procfs_read
op_assign
id|usbvideo_default_procfs_read_proc
suffix:semicolon
r_if
c_cond
(paren
id|cams-&gt;cb.procfs_write
op_eq
l_int|NULL
)paren
id|cams-&gt;cb.procfs_write
op_assign
id|usbvideo_default_procfs_write_proc
suffix:semicolon
)brace
macro_line|#else /* !USES_PROC_FS */
multiline_comment|/* Report a warning so that user knows why there is no /proc entries */
r_if
c_cond
(paren
(paren
id|cams-&gt;cb.procfs_read
op_ne
l_int|NULL
)paren
op_logical_or
(paren
id|cams-&gt;cb.procfs_write
op_eq
l_int|NULL
)paren
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;%s: /proc fs support requested but not configured!&quot;
comma
id|proc
)paren
suffix:semicolon
)brace
macro_line|#endif
id|cams-&gt;num_cameras
op_assign
id|num_cams
suffix:semicolon
id|cams-&gt;cam
op_assign
(paren
id|uvd_t
op_star
)paren
op_amp
id|cams
(braket
l_int|1
)braket
suffix:semicolon
id|cams-&gt;md_module
op_assign
id|md
suffix:semicolon
r_if
c_cond
(paren
id|cams-&gt;md_module
op_eq
l_int|NULL
)paren
id|warn
c_func
(paren
l_string|&quot;%s: module == NULL!&quot;
comma
id|proc
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|cams-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* to 1 == available */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_cams
suffix:semicolon
id|i
op_increment
)paren
(brace
id|uvd_t
op_star
id|up
op_assign
op_amp
id|cams-&gt;cam
(braket
id|i
)braket
suffix:semicolon
id|up-&gt;handle
op_assign
id|cams
suffix:semicolon
multiline_comment|/* Allocate user_data separately because of kmalloc&squot;s limits */
r_if
c_cond
(paren
id|num_extra
OG
l_int|0
)paren
(brace
id|up-&gt;user_size
op_assign
id|num_cams
op_star
id|num_extra
suffix:semicolon
id|up-&gt;user_data
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|up-&gt;user_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;user_data
op_eq
l_int|NULL
)paren
(brace
id|up-&gt;user_size
op_assign
l_int|0
suffix:semicolon
id|err
c_func
(paren
l_string|&quot;%s: Failed to allocate user_data (%d. bytes)&quot;
comma
id|proc
comma
id|up-&gt;user_size
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;%s: Allocated cams[%d].user_data=$%p (%d. bytes)&quot;
comma
id|proc
comma
id|i
comma
id|up-&gt;user_data
comma
id|up-&gt;user_size
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Register ourselves with USB stack.&n;&t; */
id|strcpy
c_func
(paren
id|cams-&gt;drvName
comma
(paren
id|driverName
op_ne
l_int|NULL
)paren
ques
c_cond
id|driverName
suffix:colon
l_string|&quot;Unknown&quot;
)paren
suffix:semicolon
id|cams-&gt;usbdrv.name
op_assign
id|cams-&gt;drvName
suffix:semicolon
id|cams-&gt;usbdrv.probe
op_assign
id|cams-&gt;cb.probe
suffix:semicolon
id|cams-&gt;usbdrv.disconnect
op_assign
id|cams-&gt;cb.disconnect
suffix:semicolon
macro_line|#if USES_PROC_FS
r_if
c_cond
(paren
id|cams-&gt;uses_procfs
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;%s: Creating /proc filesystem entries.&quot;
comma
id|proc
)paren
suffix:semicolon
id|usbvideo_procfs_level1_create
c_func
(paren
id|cams
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Update global handle to usbvideo. This is very important&n;&t; * because probe() can be called before usb_register() returns.&n;&t; * If the handle is not yet updated then the probe() will fail.&n;&t; */
op_star
id|pCams
op_assign
id|cams
suffix:semicolon
id|usb_register
c_func
(paren
op_amp
id|cams-&gt;usbdrv
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * usbvideo_Deregister()&n; *&n; * Procedure frees all usbvideo and user data structures. Be warned that&n; * if you had some dynamically allocated components in -&gt;user field then&n; * you should free them before calling here.&n; */
DECL|function|usbvideo_Deregister
r_void
id|usbvideo_Deregister
c_func
(paren
id|usbvideo_t
op_star
op_star
id|pCams
)paren
(brace
r_static
r_const
r_char
id|proc
(braket
)braket
op_assign
l_string|&quot;usbvideo_deregister&quot;
suffix:semicolon
id|usbvideo_t
op_star
id|cams
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|pCams
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: pCams == NULL&quot;
comma
id|proc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|cams
op_assign
op_star
id|pCams
suffix:semicolon
r_if
c_cond
(paren
id|cams
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: cams == NULL&quot;
comma
id|proc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#if USES_PROC_FS
r_if
c_cond
(paren
id|cams-&gt;uses_procfs
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;%s: Deregistering filesystem entries.&quot;
comma
id|proc
)paren
suffix:semicolon
id|usbvideo_procfs_level1_destroy
c_func
(paren
id|cams
)paren
suffix:semicolon
)brace
macro_line|#endif
id|dbg
c_func
(paren
l_string|&quot;%s: Deregistering %s driver.&quot;
comma
id|proc
comma
id|cams-&gt;drvName
)paren
suffix:semicolon
id|usb_deregister
c_func
(paren
op_amp
id|cams-&gt;usbdrv
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s: Deallocating cams=$%p (%d. cameras)&quot;
comma
id|proc
comma
id|cams
comma
id|cams-&gt;num_cameras
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cams-&gt;num_cameras
suffix:semicolon
id|i
op_increment
)paren
(brace
id|uvd_t
op_star
id|up
op_assign
op_amp
id|cams-&gt;cam
(braket
id|i
)braket
suffix:semicolon
r_int
id|warning
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;user_data
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|up-&gt;user_size
op_le
l_int|0
)paren
op_increment
id|warning
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|up-&gt;user_size
OG
l_int|0
)paren
op_increment
id|warning
suffix:semicolon
)brace
r_if
c_cond
(paren
id|warning
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: Warning: user_data=$%p user_size=%d.&quot;
comma
id|proc
comma
id|up-&gt;user_data
comma
id|up-&gt;user_size
)paren
suffix:semicolon
)brace
r_else
(brace
id|dbg
c_func
(paren
l_string|&quot;%s: Freeing %d. $%p-&gt;user_data=$%p&quot;
comma
id|proc
comma
id|i
comma
id|up
comma
id|up-&gt;user_data
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|up-&gt;user_data
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Whole array was allocated in one chunk */
id|dbg
c_func
(paren
l_string|&quot;%s: Freed %d uvd_t structures&quot;
comma
id|proc
comma
id|cams-&gt;num_cameras
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|cams
)paren
suffix:semicolon
op_star
id|pCams
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * usbvideo_Disconnect()&n; *&n; * This procedure stops all driver activity. Deallocation of&n; * the interface-private structure (pointed by &squot;ptr&squot;) is done now&n; * (if we don&squot;t have any open files) or later, when those files&n; * are closed. After that driver should be removable.&n; *&n; * This code handles surprise removal. The uvd-&gt;user is a counter which&n; * increments on open() and decrements on close(). If we see here that&n; * this counter is not 0 then we have a client who still has us opened.&n; * We set uvd-&gt;remove_pending flag as early as possible, and after that&n; * all access to the camera will gracefully fail. These failures should&n; * prompt client to (eventually) close the video device, and then - in&n; * usbvideo_v4l_close() - we decrement uvd-&gt;uvd_used and usage counter.&n; *&n; * History:&n; * 22-Jan-2000 Added polling of MOD_IN_USE to delay removal until all users gone.&n; * 27-Jan-2000 Reworked to allow pending disconnects; see xxx_close()&n; * 24-May-2000 Corrected to prevent race condition (MOD_xxx_USE_COUNT).&n; * 19-Oct-2000 Moved to usbvideo module.&n; */
DECL|function|usbvideo_Disconnect
r_void
id|usbvideo_Disconnect
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_void
op_star
id|ptr
)paren
(brace
r_static
r_const
r_char
id|proc
(braket
)braket
op_assign
l_string|&quot;usbvideo_Disconnect&quot;
suffix:semicolon
id|uvd_t
op_star
id|uvd
op_assign
(paren
id|uvd_t
op_star
)paren
id|ptr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|uvd
op_eq
l_int|NULL
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s($%p,$%p): Illegal call.&quot;
comma
id|proc
comma
id|dev
comma
id|ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|usbvideo_ClientIncModCount
c_func
(paren
id|uvd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uvd-&gt;debug
OG
l_int|0
)paren
id|info
c_func
(paren
l_string|&quot;%s(%p,%p.)&quot;
comma
id|proc
comma
id|dev
comma
id|ptr
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|uvd-&gt;lock
)paren
suffix:semicolon
id|uvd-&gt;remove_pending
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Now all ISO data will be ignored */
multiline_comment|/* At this time we ask to cancel outstanding URBs */
id|usbvideo_StopDataPump
c_func
(paren
id|uvd
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|USBVIDEO_NUMSBUF
suffix:semicolon
id|i
op_increment
)paren
id|usb_free_urb
c_func
(paren
id|uvd-&gt;sbuf
(braket
id|i
)braket
dot
id|urb
)paren
suffix:semicolon
id|usb_dec_dev_use
c_func
(paren
id|uvd-&gt;dev
)paren
suffix:semicolon
id|uvd-&gt;dev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* USB device is no more */
r_if
c_cond
(paren
id|uvd-&gt;user
)paren
id|info
c_func
(paren
l_string|&quot;%s: In use, disconnect pending.&quot;
comma
id|proc
)paren
suffix:semicolon
r_else
id|usbvideo_CameraRelease
c_func
(paren
id|uvd
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|uvd-&gt;lock
)paren
suffix:semicolon
id|info
c_func
(paren
l_string|&quot;USB camera disconnected.&quot;
)paren
suffix:semicolon
id|usbvideo_ClientDecModCount
c_func
(paren
id|uvd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * usbvideo_CameraRelease()&n; *&n; * This code does final release of uvd_t. This happens&n; * after the device is disconnected -and- all clients&n; * closed their files.&n; *&n; * History:&n; * 27-Jan-2000 Created.&n; */
DECL|function|usbvideo_CameraRelease
r_void
id|usbvideo_CameraRelease
c_func
(paren
id|uvd_t
op_star
id|uvd
)paren
(brace
r_static
r_const
r_char
id|proc
(braket
)braket
op_assign
l_string|&quot;usbvideo_CameraRelease&quot;
suffix:semicolon
r_if
c_cond
(paren
id|uvd
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: Illegal call&quot;
comma
id|proc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|video_unregister_device
c_func
(paren
op_amp
id|uvd-&gt;vdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uvd-&gt;debug
OG
l_int|0
)paren
id|info
c_func
(paren
l_string|&quot;%s: Video unregistered.&quot;
comma
id|proc
)paren
suffix:semicolon
macro_line|#if USES_PROC_FS
m_assert
(paren
id|uvd-&gt;handle
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uvd-&gt;handle-&gt;uses_procfs
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;%s: Removing /proc/%s/ filesystem entries.&quot;
comma
id|proc
comma
id|uvd-&gt;handle-&gt;drvName
)paren
suffix:semicolon
id|usbvideo_procfs_level2_destroy
c_func
(paren
id|uvd
)paren
suffix:semicolon
)brace
macro_line|#endif
id|RingQueue_Free
c_func
(paren
op_amp
id|uvd-&gt;dp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|VALID_CALLBACK
c_func
(paren
id|uvd
comma
id|userFree
)paren
)paren
id|GET_CALLBACK
c_func
(paren
id|uvd
comma
id|userFree
)paren
(paren
id|uvd
)paren
suffix:semicolon
id|uvd-&gt;uvd_used
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* This is atomic, no need to take mutex */
)brace
multiline_comment|/*&n; * usbvideo_find_struct()&n; *&n; * This code searches the array of preallocated (static) structures&n; * and returns index of the first one that isn&squot;t in use. Returns -1&n; * if there are no free structures.&n; *&n; * History:&n; * 27-Jan-2000 Created.&n; */
DECL|function|usbvideo_find_struct
r_static
r_int
id|usbvideo_find_struct
c_func
(paren
id|usbvideo_t
op_star
id|cams
)paren
(brace
r_int
id|u
comma
id|rv
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cams
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
l_string|&quot;No usbvideo_t handle?&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|cams-&gt;lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|u
op_assign
l_int|0
suffix:semicolon
id|u
OL
id|cams-&gt;num_cameras
suffix:semicolon
id|u
op_increment
)paren
(brace
id|uvd_t
op_star
id|uvd
op_assign
op_amp
id|cams-&gt;cam
(braket
id|u
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|uvd-&gt;uvd_used
)paren
multiline_comment|/* This one is free */
(brace
id|uvd-&gt;uvd_used
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* In use now */
id|init_MUTEX
c_func
(paren
op_amp
id|uvd-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* to 1 == available */
id|uvd-&gt;dev
op_assign
l_int|NULL
suffix:semicolon
id|rv
op_assign
id|u
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|up
c_func
(paren
op_amp
id|cams-&gt;lock
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
DECL|function|usbvideo_AllocateDevice
id|uvd_t
op_star
id|usbvideo_AllocateDevice
c_func
(paren
id|usbvideo_t
op_star
id|cams
)paren
(brace
r_int
id|i
comma
id|devnum
suffix:semicolon
id|uvd_t
op_star
id|uvd
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|cams
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
l_string|&quot;No usbvideo_t handle?&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|devnum
op_assign
id|usbvideo_find_struct
c_func
(paren
id|cams
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devnum
op_eq
op_minus
l_int|1
)paren
(brace
id|err
c_func
(paren
l_string|&quot;IBM USB camera driver: Too many devices!&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|uvd
op_assign
op_amp
id|cams-&gt;cam
(braket
id|devnum
)braket
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;Device entry #%d. at $%p&quot;
comma
id|devnum
comma
id|uvd
)paren
suffix:semicolon
multiline_comment|/* Not relying upon caller we increase module counter ourselves */
id|usbvideo_ClientIncModCount
c_func
(paren
id|uvd
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|uvd-&gt;lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|USBVIDEO_NUMSBUF
suffix:semicolon
id|i
op_increment
)paren
(brace
id|uvd-&gt;sbuf
(braket
id|i
)braket
dot
id|urb
op_assign
id|usb_alloc_urb
c_func
(paren
id|FRAMES_PER_DESC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uvd-&gt;sbuf
(braket
id|i
)braket
dot
id|urb
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
l_string|&quot;usb_alloc_urb(%d.) failed.&quot;
comma
id|FRAMES_PER_DESC
)paren
suffix:semicolon
id|uvd-&gt;uvd_used
op_assign
l_int|0
suffix:semicolon
id|uvd
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|allocate_done
suffix:semicolon
)brace
)brace
id|uvd-&gt;user
op_assign
l_int|0
suffix:semicolon
id|uvd-&gt;remove_pending
op_assign
l_int|0
suffix:semicolon
id|uvd-&gt;last_error
op_assign
l_int|0
suffix:semicolon
id|RingQueue_Initialize
c_func
(paren
op_amp
id|uvd-&gt;dp
)paren
suffix:semicolon
multiline_comment|/* Initialize video device structure */
id|memset
c_func
(paren
op_amp
id|uvd-&gt;vdev
comma
l_int|0
comma
r_sizeof
(paren
id|uvd-&gt;vdev
)paren
)paren
suffix:semicolon
id|i
op_assign
id|sprintf
c_func
(paren
id|uvd-&gt;vdev.name
comma
l_string|&quot;%s USB Camera&quot;
comma
id|cams-&gt;drvName
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
r_sizeof
(paren
id|uvd-&gt;vdev.name
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Wrote too much into uvd-&gt;vdev.name, expect trouble!&quot;
)paren
suffix:semicolon
)brace
id|uvd-&gt;vdev.type
op_assign
id|VID_TYPE_CAPTURE
suffix:semicolon
id|uvd-&gt;vdev.hardware
op_assign
id|VID_HARDWARE_CPIA
suffix:semicolon
id|uvd-&gt;vdev.open
op_assign
id|usbvideo_v4l_open
suffix:semicolon
id|uvd-&gt;vdev.close
op_assign
id|usbvideo_v4l_close
suffix:semicolon
id|uvd-&gt;vdev.read
op_assign
id|usbvideo_v4l_read
suffix:semicolon
id|uvd-&gt;vdev.write
op_assign
id|usbvideo_v4l_write
suffix:semicolon
id|uvd-&gt;vdev.ioctl
op_assign
id|usbvideo_v4l_ioctl
suffix:semicolon
id|uvd-&gt;vdev.mmap
op_assign
id|usbvideo_v4l_mmap
suffix:semicolon
id|uvd-&gt;vdev.initialize
op_assign
id|usbvideo_v4l_initialize
suffix:semicolon
multiline_comment|/*&n;&t; * The client is free to overwrite those because we&n;&t; * return control to the client&squot;s probe function right now.&n;&t; */
id|allocate_done
suffix:colon
id|up
(paren
op_amp
id|uvd-&gt;lock
)paren
suffix:semicolon
id|usbvideo_ClientDecModCount
c_func
(paren
id|uvd
)paren
suffix:semicolon
r_return
id|uvd
suffix:semicolon
)brace
DECL|function|usbvideo_RegisterVideoDevice
r_int
id|usbvideo_RegisterVideoDevice
c_func
(paren
id|uvd_t
op_star
id|uvd
)paren
(brace
r_static
r_const
r_char
id|proc
(braket
)braket
op_assign
l_string|&quot;usbvideo_RegisterVideoDevice&quot;
suffix:semicolon
r_char
id|tmp1
(braket
l_int|20
)braket
comma
id|tmp2
(braket
l_int|20
)braket
suffix:semicolon
multiline_comment|/* Buffers for printing */
r_if
c_cond
(paren
id|uvd
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: Illegal call.&quot;
comma
id|proc
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uvd-&gt;video_endp
op_eq
l_int|0
)paren
(brace
id|info
c_func
(paren
l_string|&quot;%s: No video endpoint specified; data pump disabled.&quot;
comma
id|proc
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uvd-&gt;paletteBits
op_eq
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: No palettes specified!&quot;
comma
id|proc
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uvd-&gt;defaultPalette
op_eq
l_int|0
)paren
(brace
id|info
c_func
(paren
l_string|&quot;%s: No default palette!&quot;
comma
id|proc
)paren
suffix:semicolon
)brace
id|uvd-&gt;max_frame_size
op_assign
id|VIDEOSIZE_X
c_func
(paren
id|uvd-&gt;canvas
)paren
op_star
id|VIDEOSIZE_Y
c_func
(paren
id|uvd-&gt;canvas
)paren
op_star
id|V4L_BYTES_PER_PIXEL
suffix:semicolon
id|usbvideo_VideosizeToString
c_func
(paren
id|tmp1
comma
r_sizeof
(paren
id|tmp1
)paren
comma
id|uvd-&gt;videosize
)paren
suffix:semicolon
id|usbvideo_VideosizeToString
c_func
(paren
id|tmp2
comma
r_sizeof
(paren
id|tmp2
)paren
comma
id|uvd-&gt;canvas
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uvd-&gt;debug
OG
l_int|0
)paren
(brace
id|info
c_func
(paren
l_string|&quot;%s: iface=%d. endpoint=$%02x paletteBits=$%08lx&quot;
comma
id|proc
comma
id|uvd-&gt;iface
comma
id|uvd-&gt;video_endp
comma
id|uvd-&gt;paletteBits
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|video_register_device
c_func
(paren
op_amp
id|uvd-&gt;vdev
comma
id|VFL_TYPE_GRABBER
comma
id|video_nr
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: video_register_device failed&quot;
comma
id|proc
)paren
suffix:semicolon
r_return
op_minus
id|EPIPE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uvd-&gt;debug
OG
l_int|1
)paren
(brace
id|info
c_func
(paren
l_string|&quot;%s: video_register_device() successful&quot;
comma
id|proc
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uvd-&gt;dev
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: uvd-&gt;dev == NULL&quot;
comma
id|proc
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|info
c_func
(paren
l_string|&quot;%s on /dev/video%d: canvas=%s videosize=%s&quot;
comma
(paren
id|uvd-&gt;handle
op_ne
l_int|NULL
)paren
ques
c_cond
id|uvd-&gt;handle-&gt;drvName
suffix:colon
l_string|&quot;???&quot;
comma
id|uvd-&gt;vdev.minor
comma
id|tmp2
comma
id|tmp1
)paren
suffix:semicolon
macro_line|#if USES_PROC_FS
m_assert
(paren
id|uvd-&gt;handle
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uvd-&gt;handle-&gt;uses_procfs
)paren
(brace
r_if
c_cond
(paren
id|uvd-&gt;debug
OG
l_int|0
)paren
(brace
id|info
c_func
(paren
l_string|&quot;%s: Creating /proc/video/%s/ filesystem entries.&quot;
comma
id|proc
comma
id|uvd-&gt;handle-&gt;drvName
)paren
suffix:semicolon
)brace
id|usbvideo_procfs_level2_create
c_func
(paren
id|uvd
)paren
suffix:semicolon
)brace
macro_line|#endif
id|usb_inc_dev_use
c_func
(paren
id|uvd-&gt;dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ******************************************************************** */
DECL|function|usbvideo_v4l_initialize
r_int
id|usbvideo_v4l_initialize
c_func
(paren
r_struct
id|video_device
op_star
id|dev
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usbvideo_v4l_write
r_int
id|usbvideo_v4l_write
c_func
(paren
r_struct
id|video_device
op_star
id|dev
comma
r_const
r_char
op_star
id|buf
comma
r_int
r_int
id|count
comma
r_int
id|noblock
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|usbvideo_v4l_mmap
r_int
id|usbvideo_v4l_mmap
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_struct
id|video_device
op_star
id|dev
comma
r_const
r_char
op_star
id|adr
comma
r_int
r_int
id|size
)paren
(brace
id|uvd_t
op_star
id|uvd
op_assign
(paren
id|uvd_t
op_star
)paren
id|dev
suffix:semicolon
r_int
r_int
id|start
op_assign
(paren
r_int
r_int
)paren
id|adr
suffix:semicolon
r_int
r_int
id|page
comma
id|pos
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CAMERA_IS_OPERATIONAL
c_func
(paren
id|uvd
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
(paren
(paren
(paren
l_int|2
op_star
id|uvd-&gt;max_frame_size
)paren
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_amp
op_complement
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|pos
op_assign
(paren
r_int
r_int
)paren
id|uvd-&gt;fbuf
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|page
op_assign
id|usbvideo_kvirt_to_pa
c_func
(paren
id|pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|remap_page_range
c_func
(paren
id|vma
comma
id|start
comma
id|page
comma
id|PAGE_SIZE
comma
id|PAGE_SHARED
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|start
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|pos
op_add_assign
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|PAGE_SIZE
)paren
id|size
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
r_else
id|size
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * usbvideo_v4l_open()&n; *&n; * This is part of Video 4 Linux API. The driver can be opened by one&n; * client only (checks internal counter &squot;uvdser&squot;). The procedure&n; * then allocates buffers needed for video processing.&n; *&n; * History:&n; * 22-Jan-2000 Rewrote, moved scratch buffer allocation here. Now the&n; *             camera is also initialized here (once per connect), at&n; *             expense of V4L client (it waits on open() call).&n; * 27-Jan-2000 Used USBVIDEO_NUMSBUF as number of URB buffers.&n; * 24-May-2000 Corrected to prevent race condition (MOD_xxx_USE_COUNT).&n; */
DECL|function|usbvideo_v4l_open
r_int
id|usbvideo_v4l_open
c_func
(paren
r_struct
id|video_device
op_star
id|dev
comma
r_int
id|flags
)paren
(brace
r_static
r_const
r_char
id|proc
(braket
)braket
op_assign
l_string|&quot;usbvideo_v4l_open&quot;
suffix:semicolon
id|uvd_t
op_star
id|uvd
op_assign
(paren
id|uvd_t
op_star
)paren
id|dev
suffix:semicolon
r_const
r_int
id|sb_size
op_assign
id|FRAMES_PER_DESC
op_star
id|uvd-&gt;iso_packet_len
suffix:semicolon
r_int
id|i
comma
id|errCode
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|uvd-&gt;debug
OG
l_int|1
)paren
id|info
c_func
(paren
l_string|&quot;%s($%p,$%08x&quot;
comma
id|proc
comma
id|dev
comma
id|flags
)paren
suffix:semicolon
id|usbvideo_ClientIncModCount
c_func
(paren
id|uvd
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|uvd-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uvd-&gt;user
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: Someone tried to open an already opened device!&quot;
comma
id|proc
)paren
suffix:semicolon
id|errCode
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Clear statistics */
id|memset
c_func
(paren
op_amp
id|uvd-&gt;stats
comma
l_int|0
comma
r_sizeof
(paren
id|uvd-&gt;stats
)paren
)paren
suffix:semicolon
multiline_comment|/* Clean pointers so we know if we allocated something */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|USBVIDEO_NUMSBUF
suffix:semicolon
id|i
op_increment
)paren
id|uvd-&gt;sbuf
(braket
id|i
)braket
dot
id|data
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Allocate memory for the frame buffers */
id|uvd-&gt;fbuf_size
op_assign
id|USBVIDEO_NUMFRAMES
op_star
id|uvd-&gt;max_frame_size
suffix:semicolon
id|uvd-&gt;fbuf
op_assign
id|usbvideo_rvmalloc
c_func
(paren
id|uvd-&gt;fbuf_size
)paren
suffix:semicolon
id|RingQueue_Allocate
c_func
(paren
op_amp
id|uvd-&gt;dp
comma
l_int|128
op_star
l_int|1024
)paren
suffix:semicolon
multiline_comment|/* FIXME #define */
r_if
c_cond
(paren
(paren
id|uvd-&gt;fbuf
op_eq
l_int|NULL
)paren
op_logical_or
(paren
op_logical_neg
id|RingQueue_IsAllocated
c_func
(paren
op_amp
id|uvd-&gt;dp
)paren
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: Failed to allocate fbuf or dp&quot;
comma
id|proc
)paren
suffix:semicolon
id|errCode
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Allocate all buffers */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|USBVIDEO_NUMFRAMES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|uvd-&gt;frame
(braket
id|i
)braket
dot
id|frameState
op_assign
id|FrameState_Unused
suffix:semicolon
id|uvd-&gt;frame
(braket
id|i
)braket
dot
id|data
op_assign
id|uvd-&gt;fbuf
op_plus
id|i
op_star
(paren
id|uvd-&gt;max_frame_size
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Set default sizes in case IOCTL (VIDIOCMCAPTURE)&n;&t;&t;&t;&t; * is not used (using read() instead).&n;&t;&t;&t;&t; */
id|uvd-&gt;frame
(braket
id|i
)braket
dot
id|canvas
op_assign
id|uvd-&gt;canvas
suffix:semicolon
id|uvd-&gt;frame
(braket
id|i
)braket
dot
id|seqRead_Index
op_assign
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|USBVIDEO_NUMSBUF
suffix:semicolon
id|i
op_increment
)paren
(brace
id|uvd-&gt;sbuf
(braket
id|i
)braket
dot
id|data
op_assign
id|kmalloc
c_func
(paren
id|sb_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uvd-&gt;sbuf
(braket
id|i
)braket
dot
id|data
op_eq
l_int|NULL
)paren
(brace
id|errCode
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|errCode
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Have to free all that memory */
r_if
c_cond
(paren
id|uvd-&gt;fbuf
op_ne
l_int|NULL
)paren
(brace
id|usbvideo_rvfree
c_func
(paren
id|uvd-&gt;fbuf
comma
id|uvd-&gt;fbuf_size
)paren
suffix:semicolon
id|uvd-&gt;fbuf
op_assign
l_int|NULL
suffix:semicolon
)brace
id|RingQueue_Free
c_func
(paren
op_amp
id|uvd-&gt;dp
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|USBVIDEO_NUMSBUF
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|uvd-&gt;sbuf
(braket
id|i
)braket
dot
id|data
op_ne
l_int|NULL
)paren
(brace
id|kfree
(paren
id|uvd-&gt;sbuf
(braket
id|i
)braket
dot
id|data
)paren
suffix:semicolon
id|uvd-&gt;sbuf
(braket
id|i
)braket
dot
id|data
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* If so far no errors then we shall start the camera */
r_if
c_cond
(paren
id|errCode
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Start data pump if we have valid endpoint */
r_if
c_cond
(paren
id|uvd-&gt;video_endp
op_ne
l_int|0
)paren
id|errCode
op_assign
id|usbvideo_StartDataPump
c_func
(paren
id|uvd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|errCode
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|VALID_CALLBACK
c_func
(paren
id|uvd
comma
id|setupOnOpen
)paren
)paren
(brace
r_if
c_cond
(paren
id|uvd-&gt;debug
OG
l_int|1
)paren
id|info
c_func
(paren
l_string|&quot;%s: setupOnOpen callback&quot;
comma
id|proc
)paren
suffix:semicolon
id|errCode
op_assign
id|GET_CALLBACK
c_func
(paren
id|uvd
comma
id|setupOnOpen
)paren
(paren
id|uvd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|errCode
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: setupOnOpen callback failed (%d.).&quot;
comma
id|proc
comma
id|errCode
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|uvd-&gt;debug
OG
l_int|1
)paren
(brace
id|info
c_func
(paren
l_string|&quot;%s: setupOnOpen callback successful&quot;
comma
id|proc
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|errCode
op_eq
l_int|0
)paren
(brace
id|uvd-&gt;settingsAdjusted
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|uvd-&gt;debug
OG
l_int|1
)paren
id|info
c_func
(paren
l_string|&quot;%s: Open succeeded.&quot;
comma
id|proc
)paren
suffix:semicolon
id|uvd-&gt;user
op_increment
suffix:semicolon
)brace
)brace
)brace
id|up
c_func
(paren
op_amp
id|uvd-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|errCode
op_ne
l_int|0
)paren
id|usbvideo_ClientDecModCount
c_func
(paren
id|uvd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uvd-&gt;debug
OG
l_int|0
)paren
id|info
c_func
(paren
l_string|&quot;%s: Returning %d.&quot;
comma
id|proc
comma
id|errCode
)paren
suffix:semicolon
r_return
id|errCode
suffix:semicolon
)brace
multiline_comment|/*&n; * usbvideo_v4l_close()&n; *&n; * This is part of Video 4 Linux API. The procedure&n; * stops streaming and deallocates all buffers that were earlier&n; * allocated in usbvideo_v4l_open().&n; *&n; * History:&n; * 22-Jan-2000 Moved scratch buffer deallocation here.&n; * 27-Jan-2000 Used USBVIDEO_NUMSBUF as number of URB buffers.&n; * 24-May-2000 Moved MOD_DEC_USE_COUNT outside of code that can sleep.&n; */
DECL|function|usbvideo_v4l_close
r_void
id|usbvideo_v4l_close
c_func
(paren
r_struct
id|video_device
op_star
id|dev
)paren
(brace
r_static
r_const
r_char
id|proc
(braket
)braket
op_assign
l_string|&quot;usbvideo_v4l_close&quot;
suffix:semicolon
id|uvd_t
op_star
id|uvd
op_assign
(paren
id|uvd_t
op_star
)paren
id|dev
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|uvd-&gt;debug
OG
l_int|1
)paren
id|info
c_func
(paren
l_string|&quot;%s($%p)&quot;
comma
id|proc
comma
id|dev
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|uvd-&gt;lock
)paren
suffix:semicolon
id|usbvideo_StopDataPump
c_func
(paren
id|uvd
)paren
suffix:semicolon
id|usbvideo_rvfree
c_func
(paren
id|uvd-&gt;fbuf
comma
id|uvd-&gt;fbuf_size
)paren
suffix:semicolon
id|uvd-&gt;fbuf
op_assign
l_int|NULL
suffix:semicolon
id|RingQueue_Free
c_func
(paren
op_amp
id|uvd-&gt;dp
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|USBVIDEO_NUMSBUF
suffix:semicolon
id|i
op_increment
)paren
(brace
id|kfree
c_func
(paren
id|uvd-&gt;sbuf
(braket
id|i
)braket
dot
id|data
)paren
suffix:semicolon
id|uvd-&gt;sbuf
(braket
id|i
)braket
dot
id|data
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#if USBVIDEO_REPORT_STATS
id|usbvideo_ReportStatistics
c_func
(paren
id|uvd
)paren
suffix:semicolon
macro_line|#endif    
id|uvd-&gt;user
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|uvd-&gt;remove_pending
)paren
(brace
r_if
c_cond
(paren
id|uvd-&gt;debug
OG
l_int|0
)paren
id|info
c_func
(paren
l_string|&quot;usbvideo_v4l_close: Final disconnect.&quot;
)paren
suffix:semicolon
id|usbvideo_CameraRelease
c_func
(paren
id|uvd
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|uvd-&gt;lock
)paren
suffix:semicolon
id|usbvideo_ClientDecModCount
c_func
(paren
id|uvd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uvd-&gt;debug
OG
l_int|1
)paren
id|info
c_func
(paren
l_string|&quot;%s: Completed.&quot;
comma
id|proc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * usbvideo_v4l_ioctl()&n; *&n; * This is part of Video 4 Linux API. The procedure handles ioctl() calls.&n; *&n; * History:&n; * 22-Jan-2000 Corrected VIDIOCSPICT to reject unsupported settings.&n; */
DECL|function|usbvideo_v4l_ioctl
r_int
id|usbvideo_v4l_ioctl
c_func
(paren
r_struct
id|video_device
op_star
id|dev
comma
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
id|uvd_t
op_star
id|uvd
op_assign
(paren
id|uvd_t
op_star
)paren
id|dev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CAMERA_IS_OPERATIONAL
c_func
(paren
id|uvd
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|VIDIOCGCAP
suffix:colon
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|uvd-&gt;vcap
comma
r_sizeof
(paren
id|uvd-&gt;vcap
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCGCHAN
suffix:colon
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|uvd-&gt;vchan
comma
r_sizeof
(paren
id|uvd-&gt;vchan
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCSCHAN
suffix:colon
(brace
multiline_comment|/* Not used but we return success */
r_int
id|v
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|v
comma
id|arg
comma
r_sizeof
(paren
id|v
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCGPICT
suffix:colon
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|uvd-&gt;vpic
comma
r_sizeof
(paren
id|uvd-&gt;vpic
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCSPICT
suffix:colon
(brace
r_struct
id|video_picture
id|tmp
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Use temporary &squot;video_picture&squot; structure to preserve our&n;&t;&t;&t; * own settings (such as color depth, palette) that we&n;&t;&t;&t; * aren&squot;t allowing everyone (V4L client) to change.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|arg
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|uvd-&gt;vpic.brightness
op_assign
id|tmp.brightness
suffix:semicolon
id|uvd-&gt;vpic.hue
op_assign
id|tmp.hue
suffix:semicolon
id|uvd-&gt;vpic.colour
op_assign
id|tmp.colour
suffix:semicolon
id|uvd-&gt;vpic.contrast
op_assign
id|tmp.contrast
suffix:semicolon
id|uvd-&gt;settingsAdjusted
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Will force new settings */
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCSWIN
suffix:colon
(brace
r_struct
id|video_window
id|vw
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|vw
comma
id|arg
comma
r_sizeof
(paren
id|vw
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|vw.flags
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|vw.clipcount
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|vw.width
op_ne
id|VIDEOSIZE_X
c_func
(paren
id|uvd-&gt;canvas
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|vw.height
op_ne
id|VIDEOSIZE_Y
c_func
(paren
id|uvd-&gt;canvas
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCGWIN
suffix:colon
(brace
r_struct
id|video_window
id|vw
suffix:semicolon
id|vw.x
op_assign
l_int|0
suffix:semicolon
id|vw.y
op_assign
l_int|0
suffix:semicolon
id|vw.width
op_assign
id|VIDEOSIZE_X
c_func
(paren
id|uvd-&gt;canvas
)paren
suffix:semicolon
id|vw.height
op_assign
id|VIDEOSIZE_Y
c_func
(paren
id|uvd-&gt;canvas
)paren
suffix:semicolon
id|vw.chromakey
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|VALID_CALLBACK
c_func
(paren
id|uvd
comma
id|getFPS
)paren
)paren
id|vw.flags
op_assign
id|GET_CALLBACK
c_func
(paren
id|uvd
comma
id|getFPS
)paren
(paren
id|uvd
)paren
suffix:semicolon
r_else
id|vw.flags
op_assign
l_int|10
suffix:semicolon
multiline_comment|/* FIXME: do better! */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|vw
comma
r_sizeof
(paren
id|vw
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCGMBUF
suffix:colon
(brace
r_struct
id|video_mbuf
id|vm
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|vm
comma
l_int|0
comma
r_sizeof
(paren
id|vm
)paren
)paren
suffix:semicolon
id|vm.size
op_assign
id|uvd-&gt;max_frame_size
op_star
l_int|2
suffix:semicolon
id|vm.frames
op_assign
l_int|2
suffix:semicolon
id|vm.offsets
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|vm.offsets
(braket
l_int|1
)braket
op_assign
id|uvd-&gt;max_frame_size
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
(paren
r_void
op_star
)paren
op_amp
id|vm
comma
r_sizeof
(paren
id|vm
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCMCAPTURE
suffix:colon
(brace
r_struct
id|video_mmap
id|vm
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|vm
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|vm
)paren
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;VIDIOCMCAPTURE: copy_from_user() failed.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uvd-&gt;debug
op_ge
l_int|1
)paren
(brace
id|info
c_func
(paren
l_string|&quot;VIDIOCMCAPTURE: frame=%d. size=%dx%d, format=%d.&quot;
comma
id|vm.frame
comma
id|vm.width
comma
id|vm.height
comma
id|vm.format
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Check if the requested size is supported. If the requestor&n;&t;&t;&t; * requests too big a frame then we may be tricked into accessing&n;&t;&t;&t; * outside of own preallocated frame buffer (in uvd-&gt;frame).&n;&t;&t;&t; * This will cause oops or a security hole. Theoretically, we&n;&t;&t;&t; * could only clamp the size down to acceptable bounds, but then&n;&t;&t;&t; * we&squot;d need to figure out how to insert our smaller buffer into&n;&t;&t;&t; * larger caller&squot;s buffer... this is not an easy question. So we&n;&t;&t;&t; * here just flatly reject too large requests, assuming that the&n;&t;&t;&t; * caller will resubmit with smaller size. Callers should know&n;&t;&t;&t; * what size we support (returned by VIDIOCGCAP). However vidcat,&n;&t;&t;&t; * for one, does not care and allows to ask for any size.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|vm.width
OG
id|VIDEOSIZE_X
c_func
(paren
id|uvd-&gt;canvas
)paren
)paren
op_logical_or
(paren
id|vm.height
OG
id|VIDEOSIZE_Y
c_func
(paren
id|uvd-&gt;canvas
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|uvd-&gt;debug
OG
l_int|0
)paren
(brace
id|info
c_func
(paren
l_string|&quot;VIDIOCMCAPTURE: Size=%dx%d too large; &quot;
l_string|&quot;allowed only up to %ldx%ld&quot;
comma
id|vm.width
comma
id|vm.height
comma
id|VIDEOSIZE_X
c_func
(paren
id|uvd-&gt;canvas
)paren
comma
id|VIDEOSIZE_Y
c_func
(paren
id|uvd-&gt;canvas
)paren
)paren
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Check if the palette is supported */
r_if
c_cond
(paren
(paren
(paren
l_int|1L
op_lshift
id|vm.format
)paren
op_amp
id|uvd-&gt;paletteBits
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|uvd-&gt;debug
OG
l_int|0
)paren
(brace
id|info
c_func
(paren
l_string|&quot;VIDIOCMCAPTURE: format=%d. not supported&quot;
l_string|&quot; (paletteBits=$%08lx)&quot;
comma
id|vm.format
comma
id|uvd-&gt;paletteBits
)paren
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|vm.frame
op_ne
l_int|0
)paren
op_logical_and
(paren
id|vm.frame
op_ne
l_int|1
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;VIDIOCMCAPTURE: vm.frame=%d. !E [0,1]&quot;
comma
id|vm.frame
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uvd-&gt;frame
(braket
id|vm.frame
)braket
dot
id|frameState
op_eq
id|FrameState_Grabbing
)paren
(brace
multiline_comment|/* Not an error - can happen */
)brace
id|uvd-&gt;frame
(braket
id|vm.frame
)braket
dot
id|request
op_assign
id|VIDEOSIZE
c_func
(paren
id|vm.width
comma
id|vm.height
)paren
suffix:semicolon
id|uvd-&gt;frame
(braket
id|vm.frame
)braket
dot
id|palette
op_assign
id|vm.format
suffix:semicolon
multiline_comment|/* Mark it as ready */
id|uvd-&gt;frame
(braket
id|vm.frame
)braket
dot
id|frameState
op_assign
id|FrameState_Ready
suffix:semicolon
r_return
id|usbvideo_NewFrame
c_func
(paren
id|uvd
comma
id|vm.frame
)paren
suffix:semicolon
)brace
r_case
id|VIDIOCSYNC
suffix:colon
(brace
r_int
id|frameNum
comma
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|frameNum
comma
id|arg
comma
r_sizeof
(paren
id|frameNum
)paren
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;VIDIOCSYNC: copy_from_user() failed.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|frameNum
OL
l_int|0
op_logical_or
id|frameNum
op_ge
id|USBVIDEO_NUMFRAMES
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uvd-&gt;debug
op_ge
l_int|1
)paren
id|info
c_func
(paren
l_string|&quot;VIDIOCSYNC: syncing to frame %d.&quot;
comma
id|frameNum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uvd-&gt;flags
op_amp
id|FLAGS_NO_DECODING
)paren
id|ret
op_assign
id|usbvideo_GetFrame
c_func
(paren
id|uvd
comma
id|frameNum
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|VALID_CALLBACK
c_func
(paren
id|uvd
comma
id|getFrame
)paren
)paren
(brace
id|ret
op_assign
id|GET_CALLBACK
c_func
(paren
id|uvd
comma
id|getFrame
)paren
(paren
id|uvd
comma
id|frameNum
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
OL
l_int|0
)paren
op_logical_and
(paren
id|uvd-&gt;debug
op_ge
l_int|1
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;VIDIOCSYNC: getFrame() returned %d.&quot;
comma
id|ret
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|err
c_func
(paren
l_string|&quot;VIDIOCSYNC: getFrame is not set&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * The frame is in FrameState_Done_Hold state. Release it&n;&t;&t;&t; * right now because its data is already mapped into&n;&t;&t;&t; * the user space and it&squot;s up to the application to&n;&t;&t;&t; * make use of it until it asks for another frame.&n;&t;&t;&t; */
id|uvd-&gt;frame
(braket
id|frameNum
)braket
dot
id|frameState
op_assign
id|FrameState_Unused
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_case
id|VIDIOCGFBUF
suffix:colon
(brace
r_struct
id|video_buffer
id|vb
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|vb
comma
l_int|0
comma
r_sizeof
(paren
id|vb
)paren
)paren
suffix:semicolon
id|vb.base
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* frame buffer not supported, not used */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
(paren
r_void
op_star
)paren
op_amp
id|vb
comma
r_sizeof
(paren
id|vb
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VIDIOCKEY
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
id|VIDIOCCAPTURE
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_case
id|VIDIOCSFBUF
suffix:colon
r_case
id|VIDIOCGTUNER
suffix:colon
r_case
id|VIDIOCSTUNER
suffix:colon
r_case
id|VIDIOCGFREQ
suffix:colon
r_case
id|VIDIOCSFREQ
suffix:colon
r_case
id|VIDIOCGAUDIO
suffix:colon
r_case
id|VIDIOCSAUDIO
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * usbvideo_v4l_read()&n; *&n; * This is mostly boring stuff. We simply ask for a frame and when it&n; * arrives copy all the video data from it into user space. There is&n; * no obvious need to override this method.&n; *&n; * History:&n; * 20-Oct-2000 Created.&n; * 01-Nov-2000 Added mutex (uvd-&gt;lock).&n; */
DECL|function|usbvideo_v4l_read
r_int
id|usbvideo_v4l_read
c_func
(paren
r_struct
id|video_device
op_star
id|dev
comma
r_char
op_star
id|buf
comma
r_int
r_int
id|count
comma
r_int
id|noblock
)paren
(brace
r_static
r_const
r_char
id|proc
(braket
)braket
op_assign
l_string|&quot;usbvideo_v4l_read&quot;
suffix:semicolon
id|uvd_t
op_star
id|uvd
op_assign
(paren
id|uvd_t
op_star
)paren
id|dev
suffix:semicolon
r_int
id|frmx
op_assign
op_minus
l_int|1
suffix:semicolon
id|usbvideo_frame_t
op_star
id|frame
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CAMERA_IS_OPERATIONAL
c_func
(paren
id|uvd
)paren
op_logical_or
(paren
id|buf
op_eq
l_int|NULL
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|uvd-&gt;debug
op_ge
l_int|1
)paren
id|info
c_func
(paren
l_string|&quot;%s: %ld. bytes, noblock=%d.&quot;
comma
id|proc
comma
id|count
comma
id|noblock
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|uvd-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* See if a frame is completed, then use it. */
r_if
c_cond
(paren
(paren
id|uvd-&gt;frame
(braket
l_int|0
)braket
dot
id|frameState
op_eq
id|FrameState_Done
)paren
op_logical_or
(paren
id|uvd-&gt;frame
(braket
l_int|0
)braket
dot
id|frameState
op_eq
id|FrameState_Done_Hold
)paren
op_logical_or
(paren
id|uvd-&gt;frame
(braket
l_int|0
)braket
dot
id|frameState
op_eq
id|FrameState_Error
)paren
)paren
(brace
id|frmx
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|uvd-&gt;frame
(braket
l_int|1
)braket
dot
id|frameState
op_ge
id|FrameState_Done
)paren
op_logical_or
(paren
id|uvd-&gt;frame
(braket
l_int|1
)braket
dot
id|frameState
op_eq
id|FrameState_Done_Hold
)paren
op_logical_or
(paren
id|uvd-&gt;frame
(braket
l_int|1
)braket
dot
id|frameState
op_ge
id|FrameState_Done
)paren
)paren
(brace
id|frmx
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* FIXME: If we don&squot;t start a frame here then who ever does? */
r_if
c_cond
(paren
id|noblock
op_logical_and
(paren
id|frmx
op_eq
op_minus
l_int|1
)paren
)paren
(brace
id|count
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|read_done
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If no FrameState_Done, look for a FrameState_Grabbing state.&n;&t; * See if a frame is in process (grabbing), then use it.&n;&t; * We will need to wait until it becomes cooked, of course.&n;&t; */
r_if
c_cond
(paren
id|frmx
op_eq
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|uvd-&gt;frame
(braket
l_int|0
)braket
dot
id|frameState
op_eq
id|FrameState_Grabbing
)paren
id|frmx
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|uvd-&gt;frame
(braket
l_int|1
)braket
dot
id|frameState
op_eq
id|FrameState_Grabbing
)paren
id|frmx
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If no frame is active, start one. We don&squot;t care which one&n;&t; * it will be, so #0 is as good as any.&n;&t; * In read access mode we don&squot;t have convenience of VIDIOCMCAPTURE&n;&t; * to specify the requested palette (video format) on per-frame&n;&t; * basis. This means that we have to return data in -some- format&n;&t; * and just hope that the client knows what to do with it.&n;&t; * The default format is configured in uvd-&gt;defaultPalette field&n;&t; * as one of VIDEO_PALETTE_xxx values. We stuff it into the new&n;&t; * frame and initiate the frame filling process.&n;&t; */
r_if
c_cond
(paren
id|frmx
op_eq
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|uvd-&gt;defaultPalette
op_eq
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: No default palette; don&squot;t know what to do!&quot;
comma
id|proc
)paren
suffix:semicolon
id|count
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|read_done
suffix:semicolon
)brace
id|frmx
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We have no per-frame control over video size.&n;&t;&t; * Therefore we only can use whatever size was&n;&t;&t; * specified as default.&n;&t;&t; */
id|uvd-&gt;frame
(braket
id|frmx
)braket
dot
id|request
op_assign
id|uvd-&gt;videosize
suffix:semicolon
id|uvd-&gt;frame
(braket
id|frmx
)braket
dot
id|palette
op_assign
id|uvd-&gt;defaultPalette
suffix:semicolon
id|uvd-&gt;frame
(braket
id|frmx
)braket
dot
id|frameState
op_assign
id|FrameState_Ready
suffix:semicolon
id|usbvideo_NewFrame
c_func
(paren
id|uvd
comma
id|frmx
)paren
suffix:semicolon
multiline_comment|/* Now frame 0 is supposed to start filling... */
)brace
multiline_comment|/*&n;&t; * Get a pointer to the active frame. It is either previously&n;&t; * completed frame or frame in progress but not completed yet.&n;&t; */
id|frame
op_assign
op_amp
id|uvd-&gt;frame
(braket
id|frmx
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Sit back &amp; wait until the frame gets filled and postprocessed.&n;&t; * If we fail to get the picture [in time] then return the error.&n;&t; * In this call we specify that we want the frame to be waited for,&n;&t; * postprocessed and switched into FrameState_Done_Hold state. This&n;&t; * state is used to hold the frame as &quot;fully completed&quot; between&n;&t; * subsequent partial reads of the same frame.&n;&t; */
r_if
c_cond
(paren
id|frame-&gt;frameState
op_ne
id|FrameState_Done_Hold
)paren
(brace
r_int
id|rv
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|uvd-&gt;flags
op_amp
id|FLAGS_NO_DECODING
)paren
id|rv
op_assign
id|usbvideo_GetFrame
c_func
(paren
id|uvd
comma
id|frmx
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|VALID_CALLBACK
c_func
(paren
id|uvd
comma
id|getFrame
)paren
)paren
id|rv
op_assign
id|GET_CALLBACK
c_func
(paren
id|uvd
comma
id|getFrame
)paren
(paren
id|uvd
comma
id|frmx
)paren
suffix:semicolon
r_else
id|err
c_func
(paren
l_string|&quot;getFrame is not set&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rv
op_ne
l_int|0
)paren
op_logical_or
(paren
id|frame-&gt;frameState
op_ne
id|FrameState_Done_Hold
)paren
)paren
(brace
id|count
op_assign
id|rv
suffix:semicolon
r_goto
id|read_done
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Copy bytes to user space. We allow for partial reads, which&n;&t; * means that the user application can request read less than&n;&t; * the full frame size. It is up to the application to issue&n;&t; * subsequent calls until entire frame is read.&n;&t; *&n;&t; * First things first, make sure we don&squot;t copy more than we&n;&t; * have - even if the application wants more. That would be&n;&t; * a big security embarassment!&n;&t; */
r_if
c_cond
(paren
(paren
id|count
op_plus
id|frame-&gt;seqRead_Index
)paren
OG
id|frame-&gt;seqRead_Length
)paren
id|count
op_assign
id|frame-&gt;seqRead_Length
op_minus
id|frame-&gt;seqRead_Index
suffix:semicolon
multiline_comment|/*&n;&t; * Copy requested amount of data to user space. We start&n;&t; * copying from the position where we last left it, which&n;&t; * will be zero for a new frame (not read before).&n;&t; */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
id|frame-&gt;data
op_plus
id|frame-&gt;seqRead_Index
comma
id|count
)paren
)paren
(brace
id|count
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|read_done
suffix:semicolon
)brace
multiline_comment|/* Update last read position */
id|frame-&gt;seqRead_Index
op_add_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|uvd-&gt;debug
op_ge
l_int|1
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: {copy} count used=%ld, new seqRead_Index=%ld&quot;
comma
id|proc
comma
id|count
comma
id|frame-&gt;seqRead_Index
)paren
suffix:semicolon
)brace
multiline_comment|/* Finally check if the frame is done with and &quot;release&quot; it */
r_if
c_cond
(paren
id|frame-&gt;seqRead_Index
op_ge
id|frame-&gt;seqRead_Length
)paren
(brace
multiline_comment|/* All data has been read */
id|frame-&gt;seqRead_Index
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Mark it as available to be used again. */
id|uvd-&gt;frame
(braket
id|frmx
)braket
dot
id|frameState
op_assign
id|FrameState_Unused
suffix:semicolon
r_if
c_cond
(paren
id|usbvideo_NewFrame
c_func
(paren
id|uvd
comma
id|frmx
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: usbvideo_NewFrame failed.&quot;
comma
id|proc
)paren
suffix:semicolon
)brace
)brace
id|read_done
suffix:colon
id|up
c_func
(paren
op_amp
id|uvd-&gt;lock
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/*&n; * Make all of the blocks of data contiguous&n; */
DECL|function|usbvideo_CompressIsochronous
r_static
r_int
id|usbvideo_CompressIsochronous
c_func
(paren
id|uvd_t
op_star
id|uvd
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_char
op_star
id|cdata
suffix:semicolon
r_int
id|i
comma
id|totlen
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|n
op_assign
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|actual_length
suffix:semicolon
r_int
id|st
op_assign
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|status
suffix:semicolon
id|cdata
op_assign
id|urb-&gt;transfer_buffer
op_plus
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|offset
suffix:semicolon
multiline_comment|/* Detect and ignore errored packets */
r_if
c_cond
(paren
id|st
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|uvd-&gt;debug
op_ge
l_int|1
)paren
id|err
c_func
(paren
l_string|&quot;Data error: packet=%d. len=%d. status=%d.&quot;
comma
id|i
comma
id|n
comma
id|st
)paren
suffix:semicolon
id|uvd-&gt;stats.iso_err_count
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Detect and ignore empty packets */
r_if
c_cond
(paren
id|n
op_le
l_int|0
)paren
(brace
id|uvd-&gt;stats.iso_skip_count
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|totlen
op_add_assign
id|n
suffix:semicolon
multiline_comment|/* Little local accounting */
id|RingQueue_Enqueue
c_func
(paren
op_amp
id|uvd-&gt;dp
comma
id|cdata
comma
id|n
)paren
suffix:semicolon
)brace
r_return
id|totlen
suffix:semicolon
)brace
DECL|function|usbvideo_IsocIrq
r_static
r_void
id|usbvideo_IsocIrq
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
id|i
comma
id|len
suffix:semicolon
id|uvd_t
op_star
id|uvd
op_assign
id|urb-&gt;context
suffix:semicolon
multiline_comment|/* We don&squot;t want to do anything if we are about to be removed! */
r_if
c_cond
(paren
op_logical_neg
id|CAMERA_IS_OPERATIONAL
c_func
(paren
id|uvd
)paren
)paren
r_return
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|urb-&gt;actual_length
OG
l_int|0
)paren
(brace
id|info
c_func
(paren
l_string|&quot;urb=$%p status=%d. errcount=%d. length=%d.&quot;
comma
id|urb
comma
id|urb-&gt;status
comma
id|urb-&gt;error_count
comma
id|urb-&gt;actual_length
)paren
suffix:semicolon
)brace
r_else
(brace
r_static
r_int
id|c
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|c
op_increment
op_mod
l_int|100
op_eq
l_int|0
)paren
id|info
c_func
(paren
l_string|&quot;No Isoc data&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|uvd-&gt;streaming
)paren
(brace
r_if
c_cond
(paren
id|uvd-&gt;debug
op_ge
l_int|1
)paren
id|info
c_func
(paren
l_string|&quot;Not streaming, but interrupt!&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|uvd-&gt;stats.urb_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;actual_length
op_le
l_int|0
)paren
r_goto
id|urb_done_with
suffix:semicolon
multiline_comment|/* Copy the data received into ring queue */
id|len
op_assign
id|usbvideo_CompressIsochronous
c_func
(paren
id|uvd
comma
id|urb
)paren
suffix:semicolon
id|uvd-&gt;stats.urb_length
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
l_int|0
)paren
r_goto
id|urb_done_with
suffix:semicolon
multiline_comment|/* Here we got some data */
id|uvd-&gt;stats.data_count
op_add_assign
id|len
suffix:semicolon
id|RingQueue_WakeUpInterruptible
c_func
(paren
op_amp
id|uvd-&gt;dp
)paren
suffix:semicolon
id|urb_done_with
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FRAMES_PER_DESC
suffix:semicolon
id|i
op_increment
)paren
(brace
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|status
op_assign
l_int|0
suffix:semicolon
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|actual_length
op_assign
l_int|0
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * usbvideo_StartDataPump()&n; *&n; * History:&n; * 27-Jan-2000 Used ibmcam-&gt;iface, ibmcam-&gt;ifaceAltActive instead&n; *             of hardcoded values. Simplified by using for loop,&n; *             allowed any number of URBs.&n; */
DECL|function|usbvideo_StartDataPump
r_int
id|usbvideo_StartDataPump
c_func
(paren
id|uvd_t
op_star
id|uvd
)paren
(brace
r_static
r_const
r_char
id|proc
(braket
)braket
op_assign
l_string|&quot;usbvideo_StartDataPump&quot;
suffix:semicolon
r_struct
id|usb_device
op_star
id|dev
op_assign
id|uvd-&gt;dev
suffix:semicolon
r_int
id|i
comma
id|errFlag
suffix:semicolon
r_if
c_cond
(paren
id|uvd-&gt;debug
OG
l_int|1
)paren
id|info
c_func
(paren
l_string|&quot;%s($%p)&quot;
comma
id|proc
comma
id|uvd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CAMERA_IS_OPERATIONAL
c_func
(paren
id|uvd
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: Camera is not operational&quot;
comma
id|proc
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|uvd-&gt;curframe
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Alternate interface 1 is is the biggest frame size */
id|i
op_assign
id|usb_set_interface
c_func
(paren
id|dev
comma
id|uvd-&gt;iface
comma
id|uvd-&gt;ifaceAltActive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: usb_set_interface error&quot;
comma
id|proc
)paren
suffix:semicolon
id|uvd-&gt;last_error
op_assign
id|i
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|VALID_CALLBACK
c_func
(paren
id|uvd
comma
id|videoStart
)paren
)paren
id|GET_CALLBACK
c_func
(paren
id|uvd
comma
id|videoStart
)paren
(paren
id|uvd
)paren
suffix:semicolon
r_else
id|err
c_func
(paren
l_string|&quot;%s: videoStart not set&quot;
comma
id|proc
)paren
suffix:semicolon
multiline_comment|/* We double buffer the Iso lists */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|USBVIDEO_NUMSBUF
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|j
comma
id|k
suffix:semicolon
r_struct
id|urb
op_star
id|urb
op_assign
id|uvd-&gt;sbuf
(braket
id|i
)braket
dot
id|urb
suffix:semicolon
id|urb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|urb-&gt;context
op_assign
id|uvd
suffix:semicolon
id|urb-&gt;pipe
op_assign
id|usb_rcvisocpipe
c_func
(paren
id|dev
comma
id|uvd-&gt;video_endp
)paren
suffix:semicolon
id|urb-&gt;transfer_flags
op_assign
id|USB_ISO_ASAP
suffix:semicolon
id|urb-&gt;transfer_buffer
op_assign
id|uvd-&gt;sbuf
(braket
id|i
)braket
dot
id|data
suffix:semicolon
id|urb-&gt;complete
op_assign
id|usbvideo_IsocIrq
suffix:semicolon
id|urb-&gt;number_of_packets
op_assign
id|FRAMES_PER_DESC
suffix:semicolon
id|urb-&gt;transfer_buffer_length
op_assign
id|uvd-&gt;iso_packet_len
op_star
id|FRAMES_PER_DESC
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|k
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|FRAMES_PER_DESC
suffix:semicolon
id|j
op_increment
comma
id|k
op_add_assign
id|uvd-&gt;iso_packet_len
)paren
(brace
id|urb-&gt;iso_frame_desc
(braket
id|j
)braket
dot
id|offset
op_assign
id|k
suffix:semicolon
id|urb-&gt;iso_frame_desc
(braket
id|j
)braket
dot
id|length
op_assign
id|uvd-&gt;iso_packet_len
suffix:semicolon
)brace
)brace
multiline_comment|/* Link URBs into a ring so that they invoke each other infinitely */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|USBVIDEO_NUMSBUF
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_plus
l_int|1
)paren
OL
id|USBVIDEO_NUMSBUF
)paren
id|uvd-&gt;sbuf
(braket
id|i
)braket
dot
id|urb-&gt;next
op_assign
id|uvd-&gt;sbuf
(braket
id|i
op_plus
l_int|1
)braket
dot
id|urb
suffix:semicolon
r_else
id|uvd-&gt;sbuf
(braket
id|i
)braket
dot
id|urb-&gt;next
op_assign
id|uvd-&gt;sbuf
(braket
l_int|0
)braket
dot
id|urb
suffix:semicolon
)brace
multiline_comment|/* Submit all URBs */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|USBVIDEO_NUMSBUF
suffix:semicolon
id|i
op_increment
)paren
(brace
id|errFlag
op_assign
id|usb_submit_urb
c_func
(paren
id|uvd-&gt;sbuf
(braket
id|i
)braket
dot
id|urb
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|errFlag
)paren
id|err
c_func
(paren
l_string|&quot;%s: usb_submit_isoc(%d) ret %d&quot;
comma
id|proc
comma
id|i
comma
id|errFlag
)paren
suffix:semicolon
)brace
id|uvd-&gt;streaming
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|uvd-&gt;debug
OG
l_int|1
)paren
id|info
c_func
(paren
l_string|&quot;%s: streaming=1 video_endp=$%02x&quot;
comma
id|proc
comma
id|uvd-&gt;video_endp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * usbvideo_StopDataPump()&n; *&n; * This procedure stops streaming and deallocates URBs. Then it&n; * activates zero-bandwidth alt. setting of the video interface.&n; *&n; * History:&n; * 22-Jan-2000 Corrected order of actions to work after surprise removal.&n; * 27-Jan-2000 Used uvd-&gt;iface, uvd-&gt;ifaceAltInactive instead of hardcoded values.&n; */
DECL|function|usbvideo_StopDataPump
r_void
id|usbvideo_StopDataPump
c_func
(paren
id|uvd_t
op_star
id|uvd
)paren
(brace
r_static
r_const
r_char
id|proc
(braket
)braket
op_assign
l_string|&quot;usbvideo_StopDataPump&quot;
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_if
c_cond
(paren
id|uvd-&gt;debug
OG
l_int|1
)paren
id|info
c_func
(paren
l_string|&quot;%s($%p)&quot;
comma
id|proc
comma
id|uvd
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|uvd
op_eq
l_int|NULL
)paren
op_logical_or
(paren
op_logical_neg
id|uvd-&gt;streaming
)paren
op_logical_or
(paren
id|uvd-&gt;dev
op_eq
l_int|NULL
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Unschedule all of the iso td&squot;s */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|USBVIDEO_NUMSBUF
suffix:semicolon
id|i
op_increment
)paren
(brace
id|j
op_assign
id|usb_unlink_urb
c_func
(paren
id|uvd-&gt;sbuf
(braket
id|i
)braket
dot
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|j
OL
l_int|0
)paren
id|err
c_func
(paren
l_string|&quot;%s: usb_unlink_urb() error %d.&quot;
comma
id|proc
comma
id|j
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uvd-&gt;debug
OG
l_int|1
)paren
id|info
c_func
(paren
l_string|&quot;%s: streaming=0&quot;
comma
id|proc
)paren
suffix:semicolon
id|uvd-&gt;streaming
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|uvd-&gt;remove_pending
)paren
(brace
multiline_comment|/* Invoke minidriver&squot;s magic to stop the camera */
r_if
c_cond
(paren
id|VALID_CALLBACK
c_func
(paren
id|uvd
comma
id|videoStop
)paren
)paren
id|GET_CALLBACK
c_func
(paren
id|uvd
comma
id|videoStop
)paren
(paren
id|uvd
)paren
suffix:semicolon
r_else
id|err
c_func
(paren
l_string|&quot;%s: videoStop not set&quot;
comma
id|proc
)paren
suffix:semicolon
multiline_comment|/* Set packet size to 0 */
id|j
op_assign
id|usb_set_interface
c_func
(paren
id|uvd-&gt;dev
comma
id|uvd-&gt;iface
comma
id|uvd-&gt;ifaceAltInactive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|j
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: usb_set_interface() error %d.&quot;
comma
id|proc
comma
id|j
)paren
suffix:semicolon
id|uvd-&gt;last_error
op_assign
id|j
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * usbvideo_NewFrame()&n; *&n; * History:&n; * 29-Mar-00 Added copying of previous frame into the current one.&n; * 6-Aug-00  Added model 3 video sizes, removed redundant width, height.&n; */
DECL|function|usbvideo_NewFrame
r_int
id|usbvideo_NewFrame
c_func
(paren
id|uvd_t
op_star
id|uvd
comma
r_int
id|framenum
)paren
(brace
id|usbvideo_frame_t
op_star
id|frame
suffix:semicolon
r_int
id|n
suffix:semicolon
r_if
c_cond
(paren
id|uvd-&gt;debug
OG
l_int|1
)paren
id|info
c_func
(paren
l_string|&quot;usbvideo_NewFrame($%p,%d.)&quot;
comma
id|uvd
comma
id|framenum
)paren
suffix:semicolon
multiline_comment|/* If we&squot;re not grabbing a frame right now and the other frame is */
multiline_comment|/*  ready to be grabbed into, then use it instead */
r_if
c_cond
(paren
id|uvd-&gt;curframe
op_ne
op_minus
l_int|1
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* If necessary we adjust picture settings between frames */
r_if
c_cond
(paren
op_logical_neg
id|uvd-&gt;settingsAdjusted
)paren
(brace
r_if
c_cond
(paren
id|VALID_CALLBACK
c_func
(paren
id|uvd
comma
id|adjustPicture
)paren
)paren
id|GET_CALLBACK
c_func
(paren
id|uvd
comma
id|adjustPicture
)paren
(paren
id|uvd
)paren
suffix:semicolon
id|uvd-&gt;settingsAdjusted
op_assign
l_int|1
suffix:semicolon
)brace
id|n
op_assign
(paren
id|framenum
op_minus
l_int|1
op_plus
id|USBVIDEO_NUMFRAMES
)paren
op_mod
id|USBVIDEO_NUMFRAMES
suffix:semicolon
r_if
c_cond
(paren
id|uvd-&gt;frame
(braket
id|n
)braket
dot
id|frameState
op_eq
id|FrameState_Ready
)paren
id|framenum
op_assign
id|n
suffix:semicolon
id|frame
op_assign
op_amp
id|uvd-&gt;frame
(braket
id|framenum
)braket
suffix:semicolon
id|frame-&gt;frameState
op_assign
id|FrameState_Grabbing
suffix:semicolon
id|frame-&gt;scanstate
op_assign
id|ScanState_Scanning
suffix:semicolon
id|frame-&gt;seqRead_Length
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Accumulated in xxx_parse_data() */
id|frame-&gt;deinterlace
op_assign
id|Deinterlace_None
suffix:semicolon
id|frame-&gt;flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* No flags yet, up to minidriver (or us) to set them */
id|uvd-&gt;curframe
op_assign
id|framenum
suffix:semicolon
multiline_comment|/*&n;&t; * Normally we would want to copy previous frame into the current one&n;&t; * before we even start filling it with data; this allows us to stop&n;&t; * filling at any moment; top portion of the frame will be new and&n;&t; * bottom portion will stay as it was in previous frame. If we don&squot;t&n;&t; * do that then missing chunks of video stream will result in flickering&n;&t; * portions of old data whatever it was before.&n;&t; *&n;&t; * If we choose not to copy previous frame (to, for example, save few&n;&t; * bus cycles - the frame can be pretty large!) then we have an option&n;&t; * to clear the frame before using. If we experience losses in this&n;&t; * mode then missing picture will be black (no flickering).&n;&t; *&n;&t; * Finally, if user chooses not to clean the current frame before&n;&t; * filling it with data then the old data will be visible if we fail&n;&t; * to refill entire frame with new data.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|uvd-&gt;flags
op_amp
id|FLAGS_SEPARATE_FRAMES
)paren
)paren
(brace
multiline_comment|/* This copies previous frame into this one to mask losses */
id|memmove
c_func
(paren
id|frame-&gt;data
comma
id|uvd-&gt;frame
(braket
l_int|1
op_minus
id|framenum
)braket
dot
id|data
comma
id|uvd-&gt;max_frame_size
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|uvd-&gt;flags
op_amp
id|FLAGS_CLEAN_FRAMES
)paren
(brace
multiline_comment|/* This provides a &quot;clean&quot; frame but slows things down */
id|memset
c_func
(paren
id|frame-&gt;data
comma
l_int|0
comma
id|uvd-&gt;max_frame_size
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * usbvideo_CollectRawData()&n; *&n; * This procedure can be used instead of &squot;processData&squot; callback if you&n; * only want to dump the raw data from the camera into the output&n; * device (frame buffer). You can look at it with V4L client, but the&n; * image will be unwatchable. The main purpose of this code and of the&n; * mode FLAGS_NO_DECODING is debugging and capturing of datastreams from&n; * new, unknown cameras. This procedure will be automatically invoked&n; * instead of the specified callback handler when uvd-&gt;flags has bit&n; * FLAGS_NO_DECODING set. Therefore, any regular build of any driver&n; * based on usbvideo can use this feature at any time.&n; */
DECL|function|usbvideo_CollectRawData
r_void
id|usbvideo_CollectRawData
c_func
(paren
id|uvd_t
op_star
id|uvd
comma
id|usbvideo_frame_t
op_star
id|frame
)paren
(brace
r_int
id|n
suffix:semicolon
m_assert
(paren
id|uvd
op_ne
l_int|NULL
)paren
suffix:semicolon
m_assert
(paren
id|frame
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Try to move data from queue into frame buffer */
id|n
op_assign
id|RingQueue_GetLength
c_func
(paren
op_amp
id|uvd-&gt;dp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
l_int|0
)paren
(brace
r_int
id|m
suffix:semicolon
multiline_comment|/* See how much space we have left */
id|m
op_assign
id|uvd-&gt;max_frame_size
op_minus
id|frame-&gt;seqRead_Length
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
id|m
)paren
id|n
op_assign
id|m
suffix:semicolon
multiline_comment|/* Now move that much data into frame buffer */
id|RingQueue_Dequeue
c_func
(paren
op_amp
id|uvd-&gt;dp
comma
id|frame-&gt;data
op_plus
id|frame-&gt;seqRead_Length
comma
id|m
)paren
suffix:semicolon
id|frame-&gt;seqRead_Length
op_add_assign
id|m
suffix:semicolon
)brace
multiline_comment|/* See if we filled the frame */
r_if
c_cond
(paren
id|frame-&gt;seqRead_Length
op_ge
id|uvd-&gt;max_frame_size
)paren
(brace
id|frame-&gt;frameState
op_assign
id|FrameState_Done
suffix:semicolon
id|uvd-&gt;curframe
op_assign
op_minus
l_int|1
suffix:semicolon
id|uvd-&gt;stats.frame_num
op_increment
suffix:semicolon
)brace
)brace
DECL|function|usbvideo_GetFrame
r_int
id|usbvideo_GetFrame
c_func
(paren
id|uvd_t
op_star
id|uvd
comma
r_int
id|frameNum
)paren
(brace
r_static
r_const
r_char
id|proc
(braket
)braket
op_assign
l_string|&quot;usbvideo_GetFrame&quot;
suffix:semicolon
id|usbvideo_frame_t
op_star
id|frame
op_assign
op_amp
id|uvd-&gt;frame
(braket
id|frameNum
)braket
suffix:semicolon
r_if
c_cond
(paren
id|uvd-&gt;debug
op_ge
l_int|2
)paren
id|info
c_func
(paren
l_string|&quot;%s($%p,%d.)&quot;
comma
id|proc
comma
id|uvd
comma
id|frameNum
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|frame-&gt;frameState
)paren
(brace
r_case
id|FrameState_Unused
suffix:colon
r_if
c_cond
(paren
id|uvd-&gt;debug
op_ge
l_int|2
)paren
id|info
c_func
(paren
l_string|&quot;%s: FrameState_Unused&quot;
comma
id|proc
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_case
id|FrameState_Ready
suffix:colon
r_case
id|FrameState_Grabbing
suffix:colon
r_case
id|FrameState_Error
suffix:colon
(brace
r_int
id|ntries
comma
id|signalPending
suffix:semicolon
id|redo
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|CAMERA_IS_OPERATIONAL
c_func
(paren
id|uvd
)paren
)paren
(brace
r_if
c_cond
(paren
id|uvd-&gt;debug
op_ge
l_int|2
)paren
id|info
c_func
(paren
l_string|&quot;%s: Camera is not operational (1)&quot;
comma
id|proc
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|ntries
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|RingQueue_InterruptibleSleepOn
c_func
(paren
op_amp
id|uvd-&gt;dp
)paren
suffix:semicolon
id|signalPending
op_assign
id|signal_pending
c_func
(paren
id|current
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CAMERA_IS_OPERATIONAL
c_func
(paren
id|uvd
)paren
)paren
(brace
r_if
c_cond
(paren
id|uvd-&gt;debug
op_ge
l_int|2
)paren
id|info
c_func
(paren
l_string|&quot;%s: Camera is not operational (2)&quot;
comma
id|proc
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
m_assert
(paren
id|uvd-&gt;fbuf
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signalPending
)paren
(brace
r_if
c_cond
(paren
id|uvd-&gt;debug
op_ge
l_int|2
)paren
id|info
c_func
(paren
l_string|&quot;%s: Signal=$%08x&quot;
comma
id|proc
comma
id|signalPending
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uvd-&gt;flags
op_amp
id|FLAGS_RETRY_VIDIOCSYNC
)paren
(brace
id|usbvideo_TestPattern
c_func
(paren
id|uvd
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|uvd-&gt;curframe
op_assign
op_minus
l_int|1
suffix:semicolon
id|uvd-&gt;stats.frame_num
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|uvd-&gt;debug
op_ge
l_int|2
)paren
id|info
c_func
(paren
l_string|&quot;%s: Forced test pattern screen&quot;
comma
id|proc
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Standard answer: Interrupted! */
r_if
c_cond
(paren
id|uvd-&gt;debug
op_ge
l_int|2
)paren
id|info
c_func
(paren
l_string|&quot;%s: Interrupted!&quot;
comma
id|proc
)paren
suffix:semicolon
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* No signals - we just got new data in dp queue */
r_if
c_cond
(paren
id|uvd-&gt;flags
op_amp
id|FLAGS_NO_DECODING
)paren
id|usbvideo_CollectRawData
c_func
(paren
id|uvd
comma
id|frame
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|VALID_CALLBACK
c_func
(paren
id|uvd
comma
id|processData
)paren
)paren
id|GET_CALLBACK
c_func
(paren
id|uvd
comma
id|processData
)paren
(paren
id|uvd
comma
id|frame
)paren
suffix:semicolon
r_else
id|err
c_func
(paren
l_string|&quot;%s: processData not set&quot;
comma
id|proc
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|frame-&gt;frameState
op_eq
id|FrameState_Grabbing
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uvd-&gt;debug
op_ge
l_int|2
)paren
(brace
id|info
c_func
(paren
l_string|&quot;%s: Grabbing done; state=%d. (%lu. bytes)&quot;
comma
id|proc
comma
id|frame-&gt;frameState
comma
id|frame-&gt;seqRead_Length
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|frame-&gt;frameState
op_eq
id|FrameState_Error
)paren
(brace
r_int
id|ret
op_assign
id|usbvideo_NewFrame
c_func
(paren
id|uvd
comma
id|frameNum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: usbvideo_NewFrame() failed (%d.)&quot;
comma
id|proc
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_goto
id|redo
suffix:semicolon
)brace
multiline_comment|/* Note that we fall through to meet our destiny below */
)brace
r_case
id|FrameState_Done
suffix:colon
multiline_comment|/*&n;&t;&t; * Do all necessary postprocessing of data prepared in&n;&t;&t; * &quot;interrupt&quot; code and the collecting code above. The&n;&t;&t; * frame gets marked as FrameState_Done by queue parsing code.&n;&t;&t; * This status means that we collected enough data and&n;&t;&t; * most likely processed it as we went through. However&n;&t;&t; * the data may need postprocessing, such as deinterlacing&n;&t;&t; * or picture adjustments implemented in software (horror!)&n;&t;&t; *&n;&t;&t; * As soon as the frame becomes &quot;final&quot; it gets promoted to&n;&t;&t; * FrameState_Done_Hold status where it will remain until the&n;&t;&t; * caller consumed all the video data from the frame. Then&n;&t;&t; * the empty shell of ex-frame is thrown out for dogs to eat.&n;&t;&t; * But we, worried about pets, will recycle the frame!&n;&t;&t; */
id|uvd-&gt;stats.frame_num
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|uvd-&gt;flags
op_amp
id|FLAGS_NO_DECODING
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|VALID_CALLBACK
c_func
(paren
id|uvd
comma
id|postProcess
)paren
)paren
id|GET_CALLBACK
c_func
(paren
id|uvd
comma
id|postProcess
)paren
(paren
id|uvd
comma
id|frame
)paren
suffix:semicolon
r_if
c_cond
(paren
id|frame-&gt;flags
op_amp
id|USBVIDEO_FRAME_FLAG_SOFTWARE_CONTRAST
)paren
id|usbvideo_SoftwareContrastAdjustment
c_func
(paren
id|uvd
comma
id|frame
)paren
suffix:semicolon
)brace
id|frame-&gt;frameState
op_assign
id|FrameState_Done_Hold
suffix:semicolon
r_if
c_cond
(paren
id|uvd-&gt;debug
op_ge
l_int|2
)paren
id|info
c_func
(paren
l_string|&quot;%s: Entered FrameState_Done_Hold state.&quot;
comma
id|proc
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|FrameState_Done_Hold
suffix:colon
multiline_comment|/*&n;&t;&t; * We stay in this state indefinitely until someone external,&n;&t;&t; * like ioctl() or read() call finishes digesting the frame&n;&t;&t; * data. Then it will mark the frame as FrameState_Unused and&n;&t;&t; * it will be released back into the wild to roam freely.&n;&t;&t; */
r_if
c_cond
(paren
id|uvd-&gt;debug
op_ge
l_int|2
)paren
id|info
c_func
(paren
l_string|&quot;%s: FrameState_Done_Hold state.&quot;
comma
id|proc
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Catch-all for other cases. We shall not be here. */
id|err
c_func
(paren
l_string|&quot;%s: Invalid state %d.&quot;
comma
id|proc
comma
id|frame-&gt;frameState
)paren
suffix:semicolon
id|frame-&gt;frameState
op_assign
id|FrameState_Unused
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * usbvideo_DeinterlaceFrame()&n; *&n; * This procedure deinterlaces the given frame. Some cameras produce&n; * only half of scanlines - sometimes only even lines, sometimes only&n; * odd lines. The deinterlacing method is stored in frame-&gt;deinterlace&n; * variable.&n; *&n; * Here we scan the frame vertically and replace missing scanlines with&n; * average between surrounding ones - before and after. If we have no&n; * line above then we just copy next line. Similarly, if we need to&n; * create a last line then preceding line is used.&n; */
DECL|function|usbvideo_DeinterlaceFrame
r_void
id|usbvideo_DeinterlaceFrame
c_func
(paren
id|uvd_t
op_star
id|uvd
comma
id|usbvideo_frame_t
op_star
id|frame
)paren
(brace
r_if
c_cond
(paren
(paren
id|uvd
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|frame
op_eq
l_int|NULL
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|frame-&gt;deinterlace
op_eq
id|Deinterlace_FillEvenLines
)paren
op_logical_or
(paren
id|frame-&gt;deinterlace
op_eq
id|Deinterlace_FillOddLines
)paren
)paren
(brace
r_const
r_int
id|v4l_linesize
op_assign
id|VIDEOSIZE_X
c_func
(paren
id|frame-&gt;request
)paren
op_star
id|V4L_BYTES_PER_PIXEL
suffix:semicolon
r_int
id|i
op_assign
(paren
id|frame-&gt;deinterlace
op_eq
id|Deinterlace_FillEvenLines
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|VIDEOSIZE_Y
c_func
(paren
id|frame-&gt;request
)paren
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
r_const
r_int
r_char
op_star
id|fs1
comma
op_star
id|fs2
suffix:semicolon
r_int
r_char
op_star
id|fd
suffix:semicolon
r_int
id|ip
comma
id|in
comma
id|j
suffix:semicolon
multiline_comment|/* Previous and next lines */
multiline_comment|/*&n;&t;&t;&t; * Need to average lines before and after &squot;i&squot;.&n;&t;&t;&t; * If we go out of bounds seeking those lines then&n;&t;&t;&t; * we point back to existing line.&n;&t;&t;&t; */
id|ip
op_assign
id|i
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* First, get rough numbers */
id|in
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Now validate */
r_if
c_cond
(paren
id|ip
OL
l_int|0
)paren
id|ip
op_assign
id|in
suffix:semicolon
r_if
c_cond
(paren
id|in
op_ge
id|VIDEOSIZE_Y
c_func
(paren
id|frame-&gt;request
)paren
)paren
id|in
op_assign
id|ip
suffix:semicolon
multiline_comment|/* Sanity check */
r_if
c_cond
(paren
(paren
id|ip
OL
l_int|0
)paren
op_logical_or
(paren
id|in
OL
l_int|0
)paren
op_logical_or
(paren
id|ip
op_ge
id|VIDEOSIZE_Y
c_func
(paren
id|frame-&gt;request
)paren
)paren
op_logical_or
(paren
id|in
op_ge
id|VIDEOSIZE_Y
c_func
(paren
id|frame-&gt;request
)paren
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Error: ip=%d. in=%d. req.height=%ld.&quot;
comma
id|ip
comma
id|in
comma
id|VIDEOSIZE_Y
c_func
(paren
id|frame-&gt;request
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Now we need to average lines &squot;ip&squot; and &squot;in&squot; to produce line &squot;i&squot; */
id|fs1
op_assign
id|frame-&gt;data
op_plus
(paren
id|v4l_linesize
op_star
id|ip
)paren
suffix:semicolon
id|fs2
op_assign
id|frame-&gt;data
op_plus
(paren
id|v4l_linesize
op_star
id|in
)paren
suffix:semicolon
id|fd
op_assign
id|frame-&gt;data
op_plus
(paren
id|v4l_linesize
op_star
id|i
)paren
suffix:semicolon
multiline_comment|/* Average lines around destination */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|v4l_linesize
suffix:semicolon
id|j
op_increment
)paren
(brace
id|fd
(braket
id|j
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
(paren
(paren
(paren
r_int
)paren
id|fs1
(braket
id|j
)braket
)paren
op_plus
(paren
(paren
r_int
)paren
id|fs2
(braket
id|j
)braket
)paren
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Optionally display statistics on the screen */
r_if
c_cond
(paren
id|uvd-&gt;flags
op_amp
id|FLAGS_OVERLAY_STATS
)paren
id|usbvideo_OverlayStats
c_func
(paren
id|uvd
comma
id|frame
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * usbvideo_SoftwareContrastAdjustment()&n; *&n; * This code adjusts the contrast of the frame, assuming RGB24 format.&n; * As most software image processing, this job is CPU-intensive.&n; * Get a camera that supports hardware adjustment!&n; *&n; * History:&n; * 09-Feb-2001  Created.&n; */
DECL|function|usbvideo_SoftwareContrastAdjustment
r_void
id|usbvideo_SoftwareContrastAdjustment
c_func
(paren
id|uvd_t
op_star
id|uvd
comma
id|usbvideo_frame_t
op_star
id|frame
)paren
(brace
r_static
r_const
r_char
id|proc
(braket
)braket
op_assign
l_string|&quot;usbvideo_SoftwareContrastAdjustment&quot;
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|v4l_linesize
suffix:semicolon
r_int
r_int
id|adj
suffix:semicolon
r_const
r_int
id|ccm
op_assign
l_int|128
suffix:semicolon
multiline_comment|/* Color correction median - see below */
r_if
c_cond
(paren
(paren
id|uvd
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|frame
op_eq
l_int|NULL
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: Illegal call.&quot;
comma
id|proc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|adj
op_assign
(paren
id|uvd-&gt;vpic.contrast
op_minus
l_int|0x8000
)paren
op_rshift
l_int|8
suffix:semicolon
multiline_comment|/* -128..+127 = -ccm..+(ccm-1)*/
id|RESTRICT_TO_RANGE
c_func
(paren
id|adj
comma
op_minus
id|ccm
comma
id|ccm
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|adj
op_eq
l_int|0
)paren
(brace
multiline_comment|/* In rare case of no adjustment */
r_return
suffix:semicolon
)brace
id|v4l_linesize
op_assign
id|VIDEOSIZE_X
c_func
(paren
id|frame-&gt;request
)paren
op_star
id|V4L_BYTES_PER_PIXEL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|VIDEOSIZE_Y
c_func
(paren
id|frame-&gt;request
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_char
op_star
id|fd
op_assign
id|frame-&gt;data
op_plus
(paren
id|v4l_linesize
op_star
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|v4l_linesize
suffix:semicolon
id|j
op_increment
)paren
(brace
r_int
r_int
id|v
op_assign
(paren
r_int
r_int
)paren
id|fd
(braket
id|j
)braket
suffix:semicolon
multiline_comment|/* Magnify up to 2 times, reduce down to zero */
id|v
op_assign
l_int|128
op_plus
(paren
(paren
id|ccm
op_plus
id|adj
)paren
op_star
(paren
id|v
op_minus
l_int|128
)paren
)paren
op_div
id|ccm
suffix:semicolon
id|RESTRICT_TO_RANGE
c_func
(paren
id|v
comma
l_int|0
comma
l_int|0xFF
)paren
suffix:semicolon
multiline_comment|/* Must flatten tails */
id|fd
(braket
id|j
)braket
op_assign
(paren
r_int
r_char
)paren
id|v
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * /proc interface&n; *&n; * We will be creating directories and entries under /proc/video using&n; * external &squot;video_proc_entry&squot; directory which is exported by videodev.o&n; * module. Within that directory we will create $driver/ directory to&n; * uniquely and uniformly refer to our specific $driver. Within that&n; * directory we will finally create an entry that is named after the&n; * video device node - video3, for example. The format of that file&n; * is determined by callbacks that the minidriver may provide. If no&n; * callbacks are provided (neither read nor write) then we don&squot;t create&n; * the entry.&n; *&n; * Here is a sample directory entry: /proc/video/ibmcam/video3&n; *&n; * The &quot;file&quot; video3 (in example above) is readable and writeable, in&n; * theory. If the minidriver provides callbacks to do reading and&n; * writing then both those procedures are supported. However if the&n; * driver leaves callbacks in default (NULL) state the default&n; * read and write handlers are used. The default read handler reports&n; * that the driver does not support /proc fs. The default write handler&n; * returns error code on any write attempt.&n; */
macro_line|#if USES_PROC_FS
r_extern
r_struct
id|proc_dir_entry
op_star
id|video_proc_entry
suffix:semicolon
DECL|function|usbvideo_procfs_level1_create
r_static
r_void
id|usbvideo_procfs_level1_create
c_func
(paren
id|usbvideo_t
op_star
id|ut
)paren
(brace
r_static
r_const
r_char
id|proc
(braket
)braket
op_assign
l_string|&quot;usbvideo_procfs_level1_create&quot;
suffix:semicolon
r_if
c_cond
(paren
id|ut
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: ut == NULL&quot;
comma
id|proc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|video_proc_entry
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: /proc/video/ doesn&squot;t exist.&quot;
comma
id|proc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ut-&gt;procfs_dEntry
op_assign
id|create_proc_entry
c_func
(paren
id|ut-&gt;drvName
comma
id|S_IFDIR
comma
id|video_proc_entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ut-&gt;procfs_dEntry
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|ut-&gt;md_module
op_ne
l_int|NULL
)paren
id|ut-&gt;procfs_dEntry-&gt;owner
op_assign
id|ut-&gt;md_module
suffix:semicolon
)brace
r_else
(brace
id|err
c_func
(paren
l_string|&quot;%s: Unable to initialize /proc/video/%s&quot;
comma
id|proc
comma
id|ut-&gt;drvName
)paren
suffix:semicolon
)brace
)brace
DECL|function|usbvideo_procfs_level1_destroy
r_static
r_void
id|usbvideo_procfs_level1_destroy
c_func
(paren
id|usbvideo_t
op_star
id|ut
)paren
(brace
r_static
r_const
r_char
id|proc
(braket
)braket
op_assign
l_string|&quot;usbvideo_procfs_level1_destroy&quot;
suffix:semicolon
r_if
c_cond
(paren
id|ut
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: ut == NULL&quot;
comma
id|proc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ut-&gt;procfs_dEntry
op_ne
l_int|NULL
)paren
(brace
id|remove_proc_entry
c_func
(paren
id|ut-&gt;drvName
comma
id|video_proc_entry
)paren
suffix:semicolon
id|ut-&gt;procfs_dEntry
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|usbvideo_procfs_level2_create
r_static
r_void
id|usbvideo_procfs_level2_create
c_func
(paren
id|uvd_t
op_star
id|uvd
)paren
(brace
r_static
r_const
r_char
id|proc
(braket
)braket
op_assign
l_string|&quot;usbvideo_procfs_level2_create&quot;
suffix:semicolon
r_if
c_cond
(paren
id|uvd
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: uvd == NULL&quot;
comma
id|proc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
m_assert
(paren
id|uvd-&gt;handle
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uvd-&gt;handle-&gt;procfs_dEntry
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: uvd-&gt;handle-&gt;procfs_dEntry == NULL&quot;
comma
id|proc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|uvd-&gt;videoName
comma
l_string|&quot;video%d&quot;
comma
id|uvd-&gt;vdev.minor
)paren
suffix:semicolon
id|uvd-&gt;procfs_vEntry
op_assign
id|create_proc_entry
c_func
(paren
id|uvd-&gt;videoName
comma
id|S_IFREG
op_or
id|S_IRUGO
op_or
id|S_IWUSR
comma
id|uvd-&gt;handle-&gt;procfs_dEntry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uvd-&gt;procfs_vEntry
op_ne
l_int|NULL
)paren
(brace
id|uvd-&gt;procfs_vEntry-&gt;data
op_assign
id|uvd
suffix:semicolon
id|uvd-&gt;procfs_vEntry-&gt;read_proc
op_assign
id|uvd-&gt;handle-&gt;cb.procfs_read
suffix:semicolon
id|uvd-&gt;procfs_vEntry-&gt;write_proc
op_assign
id|uvd-&gt;handle-&gt;cb.procfs_write
suffix:semicolon
)brace
r_else
(brace
id|err
c_func
(paren
l_string|&quot;%s: Failed to create entry &bslash;&quot;%s&bslash;&quot;&quot;
comma
id|proc
comma
id|uvd-&gt;videoName
)paren
suffix:semicolon
)brace
)brace
DECL|function|usbvideo_procfs_level2_destroy
r_static
r_void
id|usbvideo_procfs_level2_destroy
c_func
(paren
id|uvd_t
op_star
id|uvd
)paren
(brace
r_static
r_const
r_char
id|proc
(braket
)braket
op_assign
l_string|&quot;usbvideo_procfs_level2_destroy&quot;
suffix:semicolon
r_if
c_cond
(paren
id|uvd
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: uvd == NULL&quot;
comma
id|proc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uvd-&gt;procfs_vEntry
op_ne
l_int|NULL
)paren
(brace
id|remove_proc_entry
c_func
(paren
id|uvd-&gt;videoName
comma
id|uvd-&gt;procfs_vEntry
)paren
suffix:semicolon
id|uvd-&gt;procfs_vEntry
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|usbvideo_default_procfs_read_proc
r_static
r_int
id|usbvideo_default_procfs_read_proc
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_char
op_star
id|out
op_assign
id|page
suffix:semicolon
r_int
id|len
suffix:semicolon
multiline_comment|/* Stay under PAGE_SIZE or else */
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;This driver does not support /proc services.&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_assign
id|out
op_minus
id|page
suffix:semicolon
id|len
op_sub_assign
id|off
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|count
)paren
(brace
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_else
id|len
op_assign
id|count
suffix:semicolon
op_star
id|start
op_assign
id|page
op_plus
id|off
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|function|usbvideo_default_procfs_write_proc
r_static
r_int
id|usbvideo_default_procfs_write_proc
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
r_int
id|count
comma
r_void
op_star
id|data
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
macro_line|#endif /* USES_PROC_FS */
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
