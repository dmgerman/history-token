multiline_comment|/*&n; * Universal Host Controller Interface driver for USB.&n; *&n; * Maintainer: Alan Stern &lt;stern@rowland.harvard.edu&gt;&n; *&n; * (C) Copyright 1999 Linus Torvalds&n; * (C) Copyright 1999-2002 Johannes Erdfelt, johannes@erdfelt.com&n; * (C) Copyright 1999 Randy Dunlap&n; * (C) Copyright 1999 Georg Acher, acher@in.tum.de&n; * (C) Copyright 1999 Deti Fliegl, deti@fliegl.de&n; * (C) Copyright 1999 Thomas Sailer, sailer@ife.ee.ethz.ch&n; * (C) Copyright 1999 Roman Weissgaerber, weissg@vienna.at&n; * (C) Copyright 2000 Yggdrasil Computing, Inc. (port of new PCI interface&n; *               support from usb-ohci.c by Adam Richter, adam@yggdrasil.com).&n; * (C) Copyright 1999 Gregory P. Smith (from usb-ohci.c)&n; * (C) Copyright 2004 Alan Stern, stern@rowland.harvard.edu&n; *&n; * Intel documents this fairly well, and as far as I know there&n; * are no royalties or anything like that, but even so there are&n; * people who decided that they want to do the same thing in a&n; * completely different way.&n; *&n; * WARNING! The USB documentation is downright evil. Most of it&n; * is just crap, written by a committee. You&squot;re better off ignoring&n; * most of it, the important stuff is:&n; *  - the low-level protocol (fairly simple but lots of small details)&n; *  - working around the horridness of the rest&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#ifdef CONFIG_USB_DEBUG
DECL|macro|DEBUG
mdefine_line|#define DEBUG
macro_line|#else
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#endif
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/debugfs.h&gt;
macro_line|#include &lt;linux/pm.h&gt;
macro_line|#include &lt;linux/dmapool.h&gt;
macro_line|#include &lt;linux/dma-mapping.h&gt;
macro_line|#include &lt;linux/usb.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &quot;../core/hcd.h&quot;
macro_line|#include &quot;uhci-hcd.h&quot;
multiline_comment|/*&n; * Version Information&n; */
DECL|macro|DRIVER_VERSION
mdefine_line|#define DRIVER_VERSION &quot;v2.2&quot;
DECL|macro|DRIVER_AUTHOR
mdefine_line|#define DRIVER_AUTHOR &quot;Linus &squot;Frodo Rabbit&squot; Torvalds, Johannes Erdfelt, &bslash;&n;Randy Dunlap, Georg Acher, Deti Fliegl, Thomas Sailer, Roman Weissgaerber, &bslash;&n;Alan Stern&quot;
DECL|macro|DRIVER_DESC
mdefine_line|#define DRIVER_DESC &quot;USB Universal Host Controller Interface driver&quot;
multiline_comment|/*&n; * debug = 0, no debugging messages&n; * debug = 1, dump failed URB&squot;s except for stalls&n; * debug = 2, dump all failed URB&squot;s (including stalls)&n; *            show all queues in /debug/uhci/[pci_addr]&n; * debug = 3, show all TD&squot;s in URB&squot;s when dumping&n; */
macro_line|#ifdef DEBUG
DECL|variable|debug
r_static
r_int
id|debug
op_assign
l_int|1
suffix:semicolon
macro_line|#else
DECL|variable|debug
r_static
r_int
id|debug
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|module_param
c_func
(paren
id|debug
comma
r_int
comma
id|S_IRUGO
op_or
id|S_IWUSR
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|debug
comma
l_string|&quot;Debug level&quot;
)paren
suffix:semicolon
DECL|variable|errbuf
r_static
r_char
op_star
id|errbuf
suffix:semicolon
DECL|macro|ERRBUF_LEN
mdefine_line|#define ERRBUF_LEN    (32 * 1024)
macro_line|#include &quot;uhci-hub.c&quot;
macro_line|#include &quot;uhci-debug.c&quot;
DECL|variable|uhci_up_cachep
r_static
id|kmem_cache_t
op_star
id|uhci_up_cachep
suffix:semicolon
multiline_comment|/* urb_priv */
r_static
r_int
r_int
id|uhci_get_current_frame_number
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
)paren
suffix:semicolon
r_static
r_int
id|uhci_urb_dequeue
c_func
(paren
r_struct
id|usb_hcd
op_star
id|hcd
comma
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
r_static
r_void
id|uhci_unlink_generic
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
r_static
r_void
id|uhci_remove_pending_urbps
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
)paren
suffix:semicolon
r_static
r_void
id|uhci_finish_completion
c_func
(paren
r_struct
id|usb_hcd
op_star
id|hcd
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|uhci_free_pending_qhs
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
)paren
suffix:semicolon
r_static
r_void
id|uhci_free_pending_tds
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
)paren
suffix:semicolon
r_static
r_void
id|hc_state_transitions
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
)paren
suffix:semicolon
multiline_comment|/* If a transfer is still active after this much time, turn off FSBR */
DECL|macro|IDLE_TIMEOUT
mdefine_line|#define IDLE_TIMEOUT&t;msecs_to_jiffies(50)
DECL|macro|FSBR_DELAY
mdefine_line|#define FSBR_DELAY&t;msecs_to_jiffies(50)
multiline_comment|/* When we timeout an idle transfer for FSBR, we&squot;ll switch it over to */
multiline_comment|/* depth first traversal. We&squot;ll do it in groups of this number of TD&squot;s */
multiline_comment|/* to make sure it doesn&squot;t hog all of the bandwidth */
DECL|macro|DEPTH_INTERVAL
mdefine_line|#define DEPTH_INTERVAL 5
multiline_comment|/*&n; * Technically, updating td-&gt;status here is a race, but it&squot;s not really a&n; * problem. The worst that can happen is that we set the IOC bit again&n; * generating a spurious interrupt. We could fix this by creating another&n; * QH and leaving the IOC bit always set, but then we would have to play&n; * games with the FSBR code to make sure we get the correct order in all&n; * the cases. I don&squot;t think it&squot;s worth the effort&n; */
DECL|function|uhci_set_next_interrupt
r_static
r_inline
r_void
id|uhci_set_next_interrupt
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
)paren
(brace
id|uhci-&gt;term_td-&gt;status
op_or_assign
id|cpu_to_le32
c_func
(paren
id|TD_CTRL_IOC
)paren
suffix:semicolon
)brace
DECL|function|uhci_clear_next_interrupt
r_static
r_inline
r_void
id|uhci_clear_next_interrupt
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
)paren
(brace
id|uhci-&gt;term_td-&gt;status
op_and_assign
op_complement
id|cpu_to_le32
c_func
(paren
id|TD_CTRL_IOC
)paren
suffix:semicolon
)brace
DECL|function|uhci_moveto_complete
r_static
r_inline
r_void
id|uhci_moveto_complete
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb_priv
op_star
id|urbp
)paren
(brace
id|list_move_tail
c_func
(paren
op_amp
id|urbp-&gt;urb_list
comma
op_amp
id|uhci-&gt;complete_list
)paren
suffix:semicolon
)brace
DECL|function|uhci_alloc_td
r_static
r_struct
id|uhci_td
op_star
id|uhci_alloc_td
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
id|dma_addr_t
id|dma_handle
suffix:semicolon
r_struct
id|uhci_td
op_star
id|td
suffix:semicolon
id|td
op_assign
id|dma_pool_alloc
c_func
(paren
id|uhci-&gt;td_pool
comma
id|GFP_ATOMIC
comma
op_amp
id|dma_handle
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|td
)paren
r_return
l_int|NULL
suffix:semicolon
id|td-&gt;dma_handle
op_assign
id|dma_handle
suffix:semicolon
id|td-&gt;link
op_assign
id|UHCI_PTR_TERM
suffix:semicolon
id|td-&gt;buffer
op_assign
l_int|0
suffix:semicolon
id|td-&gt;frame
op_assign
op_minus
l_int|1
suffix:semicolon
id|td-&gt;dev
op_assign
id|dev
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|td-&gt;list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|td-&gt;remove_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|td-&gt;fl_list
)paren
suffix:semicolon
id|usb_get_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|td
suffix:semicolon
)brace
DECL|function|uhci_fill_td
r_static
r_inline
r_void
id|uhci_fill_td
c_func
(paren
r_struct
id|uhci_td
op_star
id|td
comma
id|u32
id|status
comma
id|u32
id|token
comma
id|u32
id|buffer
)paren
(brace
id|td-&gt;status
op_assign
id|cpu_to_le32
c_func
(paren
id|status
)paren
suffix:semicolon
id|td-&gt;token
op_assign
id|cpu_to_le32
c_func
(paren
id|token
)paren
suffix:semicolon
id|td-&gt;buffer
op_assign
id|cpu_to_le32
c_func
(paren
id|buffer
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * We insert Isochronous URB&squot;s directly into the frame list at the beginning&n; */
DECL|function|uhci_insert_td_frame_list
r_static
r_void
id|uhci_insert_td_frame_list
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|uhci_td
op_star
id|td
comma
r_int
id|framenum
)paren
(brace
id|framenum
op_and_assign
(paren
id|UHCI_NUMFRAMES
op_minus
l_int|1
)paren
suffix:semicolon
id|td-&gt;frame
op_assign
id|framenum
suffix:semicolon
multiline_comment|/* Is there a TD already mapped there? */
r_if
c_cond
(paren
id|uhci-&gt;fl-&gt;frame_cpu
(braket
id|framenum
)braket
)paren
(brace
r_struct
id|uhci_td
op_star
id|ftd
comma
op_star
id|ltd
suffix:semicolon
id|ftd
op_assign
id|uhci-&gt;fl-&gt;frame_cpu
(braket
id|framenum
)braket
suffix:semicolon
id|ltd
op_assign
id|list_entry
c_func
(paren
id|ftd-&gt;fl_list.prev
comma
r_struct
id|uhci_td
comma
id|fl_list
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|td-&gt;fl_list
comma
op_amp
id|ftd-&gt;fl_list
)paren
suffix:semicolon
id|td-&gt;link
op_assign
id|ltd-&gt;link
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|ltd-&gt;link
op_assign
id|cpu_to_le32
c_func
(paren
id|td-&gt;dma_handle
)paren
suffix:semicolon
)brace
r_else
(brace
id|td-&gt;link
op_assign
id|uhci-&gt;fl-&gt;frame
(braket
id|framenum
)braket
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|uhci-&gt;fl-&gt;frame
(braket
id|framenum
)braket
op_assign
id|cpu_to_le32
c_func
(paren
id|td-&gt;dma_handle
)paren
suffix:semicolon
id|uhci-&gt;fl-&gt;frame_cpu
(braket
id|framenum
)braket
op_assign
id|td
suffix:semicolon
)brace
)brace
DECL|function|uhci_remove_td
r_static
r_void
id|uhci_remove_td
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|uhci_td
op_star
id|td
)paren
(brace
multiline_comment|/* If it&squot;s not inserted, don&squot;t remove it */
r_if
c_cond
(paren
id|td-&gt;frame
op_eq
op_minus
l_int|1
op_logical_and
id|list_empty
c_func
(paren
op_amp
id|td-&gt;fl_list
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|td-&gt;frame
op_ne
op_minus
l_int|1
op_logical_and
id|uhci-&gt;fl-&gt;frame_cpu
(braket
id|td-&gt;frame
)braket
op_eq
id|td
)paren
(brace
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|td-&gt;fl_list
)paren
)paren
(brace
id|uhci-&gt;fl-&gt;frame
(braket
id|td-&gt;frame
)braket
op_assign
id|td-&gt;link
suffix:semicolon
id|uhci-&gt;fl-&gt;frame_cpu
(braket
id|td-&gt;frame
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
r_struct
id|uhci_td
op_star
id|ntd
suffix:semicolon
id|ntd
op_assign
id|list_entry
c_func
(paren
id|td-&gt;fl_list.next
comma
r_struct
id|uhci_td
comma
id|fl_list
)paren
suffix:semicolon
id|uhci-&gt;fl-&gt;frame
(braket
id|td-&gt;frame
)braket
op_assign
id|cpu_to_le32
c_func
(paren
id|ntd-&gt;dma_handle
)paren
suffix:semicolon
id|uhci-&gt;fl-&gt;frame_cpu
(braket
id|td-&gt;frame
)braket
op_assign
id|ntd
suffix:semicolon
)brace
)brace
r_else
(brace
r_struct
id|uhci_td
op_star
id|ptd
suffix:semicolon
id|ptd
op_assign
id|list_entry
c_func
(paren
id|td-&gt;fl_list.prev
comma
r_struct
id|uhci_td
comma
id|fl_list
)paren
suffix:semicolon
id|ptd-&gt;link
op_assign
id|td-&gt;link
suffix:semicolon
)brace
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|td-&gt;link
op_assign
id|UHCI_PTR_TERM
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|td-&gt;fl_list
)paren
suffix:semicolon
id|td-&gt;frame
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Inserts a td list into qh.&n; */
DECL|function|uhci_insert_tds_in_qh
r_static
r_void
id|uhci_insert_tds_in_qh
c_func
(paren
r_struct
id|uhci_qh
op_star
id|qh
comma
r_struct
id|urb
op_star
id|urb
comma
id|__le32
id|breadth
)paren
(brace
r_struct
id|urb_priv
op_star
id|urbp
op_assign
(paren
r_struct
id|urb_priv
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
r_struct
id|uhci_td
op_star
id|td
suffix:semicolon
id|__le32
op_star
id|plink
suffix:semicolon
multiline_comment|/* Ordering isn&squot;t important here yet since the QH hasn&squot;t been */
multiline_comment|/* inserted into the schedule yet */
id|plink
op_assign
op_amp
id|qh-&gt;element
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|td
comma
op_amp
id|urbp-&gt;td_list
comma
id|list
)paren
(brace
op_star
id|plink
op_assign
id|cpu_to_le32
c_func
(paren
id|td-&gt;dma_handle
)paren
op_or
id|breadth
suffix:semicolon
id|plink
op_assign
op_amp
id|td-&gt;link
suffix:semicolon
)brace
op_star
id|plink
op_assign
id|UHCI_PTR_TERM
suffix:semicolon
)brace
DECL|function|uhci_free_td
r_static
r_void
id|uhci_free_td
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|uhci_td
op_star
id|td
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|td-&gt;list
)paren
)paren
id|dev_warn
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
comma
l_string|&quot;td %p still in list!&bslash;n&quot;
comma
id|td
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|td-&gt;remove_list
)paren
)paren
id|dev_warn
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
comma
l_string|&quot;td %p still in remove_list!&bslash;n&quot;
comma
id|td
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|td-&gt;fl_list
)paren
)paren
id|dev_warn
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
comma
l_string|&quot;td %p still in fl_list!&bslash;n&quot;
comma
id|td
)paren
suffix:semicolon
r_if
c_cond
(paren
id|td-&gt;dev
)paren
id|usb_put_dev
c_func
(paren
id|td-&gt;dev
)paren
suffix:semicolon
id|dma_pool_free
c_func
(paren
id|uhci-&gt;td_pool
comma
id|td
comma
id|td-&gt;dma_handle
)paren
suffix:semicolon
)brace
DECL|function|uhci_alloc_qh
r_static
r_struct
id|uhci_qh
op_star
id|uhci_alloc_qh
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
id|dma_addr_t
id|dma_handle
suffix:semicolon
r_struct
id|uhci_qh
op_star
id|qh
suffix:semicolon
id|qh
op_assign
id|dma_pool_alloc
c_func
(paren
id|uhci-&gt;qh_pool
comma
id|GFP_ATOMIC
comma
op_amp
id|dma_handle
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|qh
)paren
r_return
l_int|NULL
suffix:semicolon
id|qh-&gt;dma_handle
op_assign
id|dma_handle
suffix:semicolon
id|qh-&gt;element
op_assign
id|UHCI_PTR_TERM
suffix:semicolon
id|qh-&gt;link
op_assign
id|UHCI_PTR_TERM
suffix:semicolon
id|qh-&gt;dev
op_assign
id|dev
suffix:semicolon
id|qh-&gt;urbp
op_assign
l_int|NULL
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|qh-&gt;list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|qh-&gt;remove_list
)paren
suffix:semicolon
id|usb_get_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|qh
suffix:semicolon
)brace
DECL|function|uhci_free_qh
r_static
r_void
id|uhci_free_qh
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|uhci_qh
op_star
id|qh
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|qh-&gt;list
)paren
)paren
id|dev_warn
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
comma
l_string|&quot;qh %p list not empty!&bslash;n&quot;
comma
id|qh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|qh-&gt;remove_list
)paren
)paren
id|dev_warn
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
comma
l_string|&quot;qh %p still in remove_list!&bslash;n&quot;
comma
id|qh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qh-&gt;dev
)paren
id|usb_put_dev
c_func
(paren
id|qh-&gt;dev
)paren
suffix:semicolon
id|dma_pool_free
c_func
(paren
id|uhci-&gt;qh_pool
comma
id|qh
comma
id|qh-&gt;dma_handle
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Append this urb&squot;s qh after the last qh in skelqh-&gt;list&n; *&n; * Note that urb_priv.queue_list doesn&squot;t have a separate queue head;&n; * it&squot;s a ring with every element &quot;live&quot;.&n; */
DECL|function|uhci_insert_qh
r_static
r_void
id|uhci_insert_qh
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|uhci_qh
op_star
id|skelqh
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|urb_priv
op_star
id|urbp
op_assign
(paren
r_struct
id|urb_priv
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
r_struct
id|urb_priv
op_star
id|turbp
suffix:semicolon
r_struct
id|uhci_qh
op_star
id|lqh
suffix:semicolon
multiline_comment|/* Grab the last QH */
id|lqh
op_assign
id|list_entry
c_func
(paren
id|skelqh-&gt;list.prev
comma
r_struct
id|uhci_qh
comma
id|list
)paren
suffix:semicolon
multiline_comment|/* Point to the next skelqh */
id|urbp-&gt;qh-&gt;link
op_assign
id|lqh-&gt;link
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Ordering is important */
multiline_comment|/*&n;&t; * Patch QHs for previous endpoint&squot;s queued URBs?  HC goes&n;&t; * here next, not to the next skelqh it now points to.&n;&t; *&n;&t; *    lqh --&gt; td ... --&gt; qh ... --&gt; td --&gt; qh ... --&gt; td&n;&t; *     |                 |                 |&n;&t; *     v                 v                 v&n;&t; *     +&lt;----------------+-----------------+&n;&t; *     v&n;&t; *    newqh --&gt; td ... --&gt; td&n;&t; *     |&n;&t; *     v&n;&t; *    ...&n;&t; *&n;&t; * The HC could see (and use!) any of these as we write them.&n;&t; */
id|lqh-&gt;link
op_assign
id|cpu_to_le32
c_func
(paren
id|urbp-&gt;qh-&gt;dma_handle
)paren
op_or
id|UHCI_PTR_QH
suffix:semicolon
r_if
c_cond
(paren
id|lqh-&gt;urbp
)paren
(brace
id|list_for_each_entry
c_func
(paren
id|turbp
comma
op_amp
id|lqh-&gt;urbp-&gt;queue_list
comma
id|queue_list
)paren
id|turbp-&gt;qh-&gt;link
op_assign
id|lqh-&gt;link
suffix:semicolon
)brace
id|list_add_tail
c_func
(paren
op_amp
id|urbp-&gt;qh-&gt;list
comma
op_amp
id|skelqh-&gt;list
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Start removal of QH from schedule; it finishes next frame.&n; * TDs should be unlinked before this is called.&n; */
DECL|function|uhci_remove_qh
r_static
r_void
id|uhci_remove_qh
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|uhci_qh
op_star
id|qh
)paren
(brace
r_struct
id|uhci_qh
op_star
id|pqh
suffix:semicolon
id|__le32
id|newlink
suffix:semicolon
r_int
r_int
id|age
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|qh
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Only go through the hoops if it&squot;s actually linked in&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|qh-&gt;list
)paren
)paren
(brace
multiline_comment|/* If our queue is nonempty, make the next URB the head */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|qh-&gt;urbp-&gt;queue_list
)paren
)paren
(brace
r_struct
id|urb_priv
op_star
id|nurbp
suffix:semicolon
id|nurbp
op_assign
id|list_entry
c_func
(paren
id|qh-&gt;urbp-&gt;queue_list.next
comma
r_struct
id|urb_priv
comma
id|queue_list
)paren
suffix:semicolon
id|nurbp-&gt;queued
op_assign
l_int|0
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|nurbp-&gt;qh-&gt;list
comma
op_amp
id|qh-&gt;list
)paren
suffix:semicolon
id|newlink
op_assign
id|cpu_to_le32
c_func
(paren
id|nurbp-&gt;qh-&gt;dma_handle
)paren
op_or
id|UHCI_PTR_QH
suffix:semicolon
)brace
r_else
id|newlink
op_assign
id|qh-&gt;link
suffix:semicolon
multiline_comment|/* Fix up the previous QH&squot;s queue to link to either&n;&t;&t; * the new head of this queue or the start of the&n;&t;&t; * next endpoint&squot;s queue. */
id|pqh
op_assign
id|list_entry
c_func
(paren
id|qh-&gt;list.prev
comma
r_struct
id|uhci_qh
comma
id|list
)paren
suffix:semicolon
id|pqh-&gt;link
op_assign
id|newlink
suffix:semicolon
r_if
c_cond
(paren
id|pqh-&gt;urbp
)paren
(brace
r_struct
id|urb_priv
op_star
id|turbp
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|turbp
comma
op_amp
id|pqh-&gt;urbp-&gt;queue_list
comma
id|queue_list
)paren
id|turbp-&gt;qh-&gt;link
op_assign
id|newlink
suffix:semicolon
)brace
id|wmb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Leave qh-&gt;link in case the HC is on the QH now, it will */
multiline_comment|/* continue the rest of the schedule */
id|qh-&gt;element
op_assign
id|UHCI_PTR_TERM
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|qh-&gt;list
)paren
suffix:semicolon
)brace
id|list_del_init
c_func
(paren
op_amp
id|qh-&gt;urbp-&gt;queue_list
)paren
suffix:semicolon
id|qh-&gt;urbp
op_assign
l_int|NULL
suffix:semicolon
id|age
op_assign
id|uhci_get_current_frame_number
c_func
(paren
id|uhci
)paren
suffix:semicolon
r_if
c_cond
(paren
id|age
op_ne
id|uhci-&gt;qh_remove_age
)paren
(brace
id|uhci_free_pending_qhs
c_func
(paren
id|uhci
)paren
suffix:semicolon
id|uhci-&gt;qh_remove_age
op_assign
id|age
suffix:semicolon
)brace
multiline_comment|/* Check to see if the remove list is empty. Set the IOC bit */
multiline_comment|/* to force an interrupt so we can remove the QH */
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|uhci-&gt;qh_remove_list
)paren
)paren
id|uhci_set_next_interrupt
c_func
(paren
id|uhci
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|qh-&gt;remove_list
comma
op_amp
id|uhci-&gt;qh_remove_list
)paren
suffix:semicolon
)brace
DECL|function|uhci_fixup_toggle
r_static
r_int
id|uhci_fixup_toggle
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
r_int
id|toggle
)paren
(brace
r_struct
id|urb_priv
op_star
id|urbp
op_assign
(paren
r_struct
id|urb_priv
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
r_struct
id|uhci_td
op_star
id|td
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|td
comma
op_amp
id|urbp-&gt;td_list
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|toggle
)paren
id|td-&gt;token
op_or_assign
id|cpu_to_le32
c_func
(paren
id|TD_TOKEN_TOGGLE
)paren
suffix:semicolon
r_else
id|td-&gt;token
op_and_assign
op_complement
id|cpu_to_le32
c_func
(paren
id|TD_TOKEN_TOGGLE
)paren
suffix:semicolon
id|toggle
op_xor_assign
l_int|1
suffix:semicolon
)brace
r_return
id|toggle
suffix:semicolon
)brace
multiline_comment|/* This function will append one URB&squot;s QH to another URB&squot;s QH. This is for */
multiline_comment|/* queuing interrupt, control or bulk transfers */
DECL|function|uhci_append_queued_urb
r_static
r_void
id|uhci_append_queued_urb
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|eurb
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|urb_priv
op_star
id|eurbp
comma
op_star
id|urbp
comma
op_star
id|furbp
comma
op_star
id|lurbp
suffix:semicolon
r_struct
id|uhci_td
op_star
id|lltd
suffix:semicolon
id|eurbp
op_assign
id|eurb-&gt;hcpriv
suffix:semicolon
id|urbp
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
multiline_comment|/* Find the first URB in the queue */
id|furbp
op_assign
id|eurbp
suffix:semicolon
r_if
c_cond
(paren
id|eurbp-&gt;queued
)paren
(brace
id|list_for_each_entry
c_func
(paren
id|furbp
comma
op_amp
id|eurbp-&gt;queue_list
comma
id|queue_list
)paren
r_if
c_cond
(paren
op_logical_neg
id|furbp-&gt;queued
)paren
r_break
suffix:semicolon
)brace
id|lurbp
op_assign
id|list_entry
c_func
(paren
id|furbp-&gt;queue_list.prev
comma
r_struct
id|urb_priv
comma
id|queue_list
)paren
suffix:semicolon
id|lltd
op_assign
id|list_entry
c_func
(paren
id|lurbp-&gt;td_list.prev
comma
r_struct
id|uhci_td
comma
id|list
)paren
suffix:semicolon
multiline_comment|/* Control transfers always start with toggle 0 */
r_if
c_cond
(paren
op_logical_neg
id|usb_pipecontrol
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
id|usb_settoggle
c_func
(paren
id|urb-&gt;dev
comma
id|usb_pipeendpoint
c_func
(paren
id|urb-&gt;pipe
)paren
comma
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
comma
id|uhci_fixup_toggle
c_func
(paren
id|urb
comma
id|uhci_toggle
c_func
(paren
id|td_token
c_func
(paren
id|lltd
)paren
)paren
op_xor
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/* All qh&squot;s in the queue need to link to the next queue */
id|urbp-&gt;qh-&gt;link
op_assign
id|eurbp-&gt;qh-&gt;link
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Make sure we flush everything */
id|lltd-&gt;link
op_assign
id|cpu_to_le32
c_func
(paren
id|urbp-&gt;qh-&gt;dma_handle
)paren
op_or
id|UHCI_PTR_QH
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|urbp-&gt;queue_list
comma
op_amp
id|furbp-&gt;queue_list
)paren
suffix:semicolon
id|urbp-&gt;queued
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|uhci_delete_queued_urb
r_static
r_void
id|uhci_delete_queued_urb
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|urb_priv
op_star
id|urbp
comma
op_star
id|nurbp
comma
op_star
id|purbp
comma
op_star
id|turbp
suffix:semicolon
r_struct
id|uhci_td
op_star
id|pltd
suffix:semicolon
r_int
r_int
id|toggle
suffix:semicolon
id|urbp
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|urbp-&gt;queue_list
)paren
)paren
r_return
suffix:semicolon
id|nurbp
op_assign
id|list_entry
c_func
(paren
id|urbp-&gt;queue_list.next
comma
r_struct
id|urb_priv
comma
id|queue_list
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fix up the toggle for the following URBs in the queue.&n;&t; * Only needed for bulk and interrupt: control and isochronous&n;&t; * endpoints don&squot;t propagate toggles between messages.&n;&t; */
r_if
c_cond
(paren
id|usb_pipebulk
c_func
(paren
id|urb-&gt;pipe
)paren
op_logical_or
id|usb_pipeint
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|urbp-&gt;queued
)paren
multiline_comment|/* We just set the toggle in uhci_unlink_generic */
id|toggle
op_assign
id|usb_gettoggle
c_func
(paren
id|urb-&gt;dev
comma
id|usb_pipeendpoint
c_func
(paren
id|urb-&gt;pipe
)paren
comma
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/* If we&squot;re in the middle of the queue, grab the */
multiline_comment|/* toggle from the TD previous to us */
id|purbp
op_assign
id|list_entry
c_func
(paren
id|urbp-&gt;queue_list.prev
comma
r_struct
id|urb_priv
comma
id|queue_list
)paren
suffix:semicolon
id|pltd
op_assign
id|list_entry
c_func
(paren
id|purbp-&gt;td_list.prev
comma
r_struct
id|uhci_td
comma
id|list
)paren
suffix:semicolon
id|toggle
op_assign
id|uhci_toggle
c_func
(paren
id|td_token
c_func
(paren
id|pltd
)paren
)paren
op_xor
l_int|1
suffix:semicolon
)brace
id|list_for_each_entry
c_func
(paren
id|turbp
comma
op_amp
id|urbp-&gt;queue_list
comma
id|queue_list
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|turbp-&gt;queued
)paren
r_break
suffix:semicolon
id|toggle
op_assign
id|uhci_fixup_toggle
c_func
(paren
id|turbp-&gt;urb
comma
id|toggle
)paren
suffix:semicolon
)brace
id|usb_settoggle
c_func
(paren
id|urb-&gt;dev
comma
id|usb_pipeendpoint
c_func
(paren
id|urb-&gt;pipe
)paren
comma
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
comma
id|toggle
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|urbp-&gt;queued
)paren
(brace
multiline_comment|/* We&squot;re somewhere in the middle (or end).  The case where&n;&t;&t; * we&squot;re at the head is handled in uhci_remove_qh(). */
id|purbp
op_assign
id|list_entry
c_func
(paren
id|urbp-&gt;queue_list.prev
comma
r_struct
id|urb_priv
comma
id|queue_list
)paren
suffix:semicolon
id|pltd
op_assign
id|list_entry
c_func
(paren
id|purbp-&gt;td_list.prev
comma
r_struct
id|uhci_td
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nurbp-&gt;queued
)paren
id|pltd-&gt;link
op_assign
id|cpu_to_le32
c_func
(paren
id|nurbp-&gt;qh-&gt;dma_handle
)paren
op_or
id|UHCI_PTR_QH
suffix:semicolon
r_else
multiline_comment|/* The next URB happens to be the beginning, so */
multiline_comment|/*  we&squot;re the last, end the chain */
id|pltd-&gt;link
op_assign
id|UHCI_PTR_TERM
suffix:semicolon
)brace
multiline_comment|/* urbp-&gt;queue_list is handled in uhci_remove_qh() */
)brace
DECL|function|uhci_alloc_urb_priv
r_static
r_struct
id|urb_priv
op_star
id|uhci_alloc_urb_priv
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|urb_priv
op_star
id|urbp
suffix:semicolon
id|urbp
op_assign
id|kmem_cache_alloc
c_func
(paren
id|uhci_up_cachep
comma
id|SLAB_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urbp
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|urbp
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|urbp
)paren
)paren
suffix:semicolon
id|urbp-&gt;inserttime
op_assign
id|jiffies
suffix:semicolon
id|urbp-&gt;fsbrtime
op_assign
id|jiffies
suffix:semicolon
id|urbp-&gt;urb
op_assign
id|urb
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|urbp-&gt;td_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|urbp-&gt;queue_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|urbp-&gt;urb_list
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|urbp-&gt;urb_list
comma
op_amp
id|uhci-&gt;urb_list
)paren
suffix:semicolon
id|urb-&gt;hcpriv
op_assign
id|urbp
suffix:semicolon
r_return
id|urbp
suffix:semicolon
)brace
DECL|function|uhci_add_td_to_urb
r_static
r_void
id|uhci_add_td_to_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|uhci_td
op_star
id|td
)paren
(brace
r_struct
id|urb_priv
op_star
id|urbp
op_assign
(paren
r_struct
id|urb_priv
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
id|td-&gt;urb
op_assign
id|urb
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|td-&gt;list
comma
op_amp
id|urbp-&gt;td_list
)paren
suffix:semicolon
)brace
DECL|function|uhci_remove_td_from_urb
r_static
r_void
id|uhci_remove_td_from_urb
c_func
(paren
r_struct
id|uhci_td
op_star
id|td
)paren
(brace
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|td-&gt;list
)paren
)paren
r_return
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|td-&gt;list
)paren
suffix:semicolon
id|td-&gt;urb
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|uhci_destroy_urb_priv
r_static
r_void
id|uhci_destroy_urb_priv
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|uhci_td
op_star
id|td
comma
op_star
id|tmp
suffix:semicolon
r_struct
id|urb_priv
op_star
id|urbp
suffix:semicolon
r_int
r_int
id|age
suffix:semicolon
id|urbp
op_assign
(paren
r_struct
id|urb_priv
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urbp
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|urbp-&gt;urb_list
)paren
)paren
id|dev_warn
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
comma
l_string|&quot;urb %p still on uhci-&gt;urb_list &quot;
l_string|&quot;or uhci-&gt;remove_list!&bslash;n&quot;
comma
id|urb
)paren
suffix:semicolon
id|age
op_assign
id|uhci_get_current_frame_number
c_func
(paren
id|uhci
)paren
suffix:semicolon
r_if
c_cond
(paren
id|age
op_ne
id|uhci-&gt;td_remove_age
)paren
(brace
id|uhci_free_pending_tds
c_func
(paren
id|uhci
)paren
suffix:semicolon
id|uhci-&gt;td_remove_age
op_assign
id|age
suffix:semicolon
)brace
multiline_comment|/* Check to see if the remove list is empty. Set the IOC bit */
multiline_comment|/* to force an interrupt so we can remove the TD&squot;s*/
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|uhci-&gt;td_remove_list
)paren
)paren
id|uhci_set_next_interrupt
c_func
(paren
id|uhci
)paren
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|td
comma
id|tmp
comma
op_amp
id|urbp-&gt;td_list
comma
id|list
)paren
(brace
id|uhci_remove_td_from_urb
c_func
(paren
id|td
)paren
suffix:semicolon
id|uhci_remove_td
c_func
(paren
id|uhci
comma
id|td
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|td-&gt;remove_list
comma
op_amp
id|uhci-&gt;td_remove_list
)paren
suffix:semicolon
)brace
id|urb-&gt;hcpriv
op_assign
l_int|NULL
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|uhci_up_cachep
comma
id|urbp
)paren
suffix:semicolon
)brace
DECL|function|uhci_inc_fsbr
r_static
r_void
id|uhci_inc_fsbr
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|urb_priv
op_star
id|urbp
op_assign
(paren
r_struct
id|urb_priv
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|urb-&gt;transfer_flags
op_amp
id|URB_NO_FSBR
)paren
)paren
op_logical_and
op_logical_neg
id|urbp-&gt;fsbr
)paren
(brace
id|urbp-&gt;fsbr
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|uhci-&gt;fsbr
op_increment
op_logical_and
op_logical_neg
id|uhci-&gt;fsbrtimeout
)paren
id|uhci-&gt;skel_term_qh-&gt;link
op_assign
id|cpu_to_le32
c_func
(paren
id|uhci-&gt;skel_fs_control_qh-&gt;dma_handle
)paren
op_or
id|UHCI_PTR_QH
suffix:semicolon
)brace
)brace
DECL|function|uhci_dec_fsbr
r_static
r_void
id|uhci_dec_fsbr
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|urb_priv
op_star
id|urbp
op_assign
(paren
r_struct
id|urb_priv
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|urb-&gt;transfer_flags
op_amp
id|URB_NO_FSBR
)paren
)paren
op_logical_and
id|urbp-&gt;fsbr
)paren
(brace
id|urbp-&gt;fsbr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|uhci-&gt;fsbr
)paren
id|uhci-&gt;fsbrtimeout
op_assign
id|jiffies
op_plus
id|FSBR_DELAY
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Map status to standard result codes&n; *&n; * &lt;status&gt; is (td_status(td) &amp; 0xF60000), a.k.a.&n; * uhci_status_bits(td_status(td)).&n; * Note: &lt;status&gt; does not include the TD_CTRL_NAK bit.&n; * &lt;dir_out&gt; is True for output TDs and False for input TDs.&n; */
DECL|function|uhci_map_status
r_static
r_int
id|uhci_map_status
c_func
(paren
r_int
id|status
comma
r_int
id|dir_out
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TD_CTRL_BITSTUFF
)paren
multiline_comment|/* Bitstuff error */
r_return
op_minus
id|EPROTO
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TD_CTRL_CRCTIMEO
)paren
(brace
multiline_comment|/* CRC/Timeout */
r_if
c_cond
(paren
id|dir_out
)paren
r_return
op_minus
id|EPROTO
suffix:semicolon
r_else
r_return
op_minus
id|EILSEQ
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|TD_CTRL_BABBLE
)paren
multiline_comment|/* Babble */
r_return
op_minus
id|EOVERFLOW
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TD_CTRL_DBUFERR
)paren
multiline_comment|/* Buffer error */
r_return
op_minus
id|ENOSR
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TD_CTRL_STALLED
)paren
multiline_comment|/* Stalled */
r_return
op_minus
id|EPIPE
suffix:semicolon
id|WARN_ON
c_func
(paren
id|status
op_amp
id|TD_CTRL_ACTIVE
)paren
suffix:semicolon
multiline_comment|/* Active */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Control transfers&n; */
DECL|function|uhci_submit_control
r_static
r_int
id|uhci_submit_control
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|urb
op_star
id|eurb
)paren
(brace
r_struct
id|urb_priv
op_star
id|urbp
op_assign
(paren
r_struct
id|urb_priv
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
r_struct
id|uhci_td
op_star
id|td
suffix:semicolon
r_struct
id|uhci_qh
op_star
id|qh
comma
op_star
id|skelqh
suffix:semicolon
r_int
r_int
id|destination
comma
id|status
suffix:semicolon
r_int
id|maxsze
op_assign
id|usb_maxpacket
c_func
(paren
id|urb-&gt;dev
comma
id|urb-&gt;pipe
comma
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
r_int
id|len
op_assign
id|urb-&gt;transfer_buffer_length
suffix:semicolon
id|dma_addr_t
id|data
op_assign
id|urb-&gt;transfer_dma
suffix:semicolon
multiline_comment|/* The &quot;pipe&quot; thing contains the destination in bits 8--18 */
id|destination
op_assign
(paren
id|urb-&gt;pipe
op_amp
id|PIPE_DEVEP_MASK
)paren
op_or
id|USB_PID_SETUP
suffix:semicolon
multiline_comment|/* 3 errors */
id|status
op_assign
id|TD_CTRL_ACTIVE
op_or
id|uhci_maxerr
c_func
(paren
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;dev-&gt;speed
op_eq
id|USB_SPEED_LOW
)paren
id|status
op_or_assign
id|TD_CTRL_LS
suffix:semicolon
multiline_comment|/*&n;&t; * Build the TD for the control request setup packet&n;&t; */
id|td
op_assign
id|uhci_alloc_td
c_func
(paren
id|uhci
comma
id|urb-&gt;dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|td
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|uhci_add_td_to_urb
c_func
(paren
id|urb
comma
id|td
)paren
suffix:semicolon
id|uhci_fill_td
c_func
(paren
id|td
comma
id|status
comma
id|destination
op_or
id|uhci_explen
c_func
(paren
l_int|7
)paren
comma
id|urb-&gt;setup_dma
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If direction is &quot;send&quot;, change the packet ID from SETUP (0x2D)&n;&t; * to OUT (0xE1).  Else change it from SETUP to IN (0x69) and&n;&t; * set Short Packet Detect (SPD) for all data packets.&n;&t; */
r_if
c_cond
(paren
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
id|destination
op_xor_assign
(paren
id|USB_PID_SETUP
op_xor
id|USB_PID_OUT
)paren
suffix:semicolon
r_else
(brace
id|destination
op_xor_assign
(paren
id|USB_PID_SETUP
op_xor
id|USB_PID_IN
)paren
suffix:semicolon
id|status
op_or_assign
id|TD_CTRL_SPD
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Build the DATA TD&squot;s&n;&t; */
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
r_int
id|pktsze
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pktsze
OG
id|maxsze
)paren
id|pktsze
op_assign
id|maxsze
suffix:semicolon
id|td
op_assign
id|uhci_alloc_td
c_func
(paren
id|uhci
comma
id|urb-&gt;dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|td
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* Alternate Data0/1 (start with Data1) */
id|destination
op_xor_assign
id|TD_TOKEN_TOGGLE
suffix:semicolon
id|uhci_add_td_to_urb
c_func
(paren
id|urb
comma
id|td
)paren
suffix:semicolon
id|uhci_fill_td
c_func
(paren
id|td
comma
id|status
comma
id|destination
op_or
id|uhci_explen
c_func
(paren
id|pktsze
op_minus
l_int|1
)paren
comma
id|data
)paren
suffix:semicolon
id|data
op_add_assign
id|pktsze
suffix:semicolon
id|len
op_sub_assign
id|pktsze
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Build the final TD for control status &n;&t; */
id|td
op_assign
id|uhci_alloc_td
c_func
(paren
id|uhci
comma
id|urb-&gt;dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|td
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/*&n;&t; * It&squot;s IN if the pipe is an output pipe or we&squot;re not expecting&n;&t; * data back.&n;&t; */
id|destination
op_and_assign
op_complement
id|TD_TOKEN_PID_MASK
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
op_logical_or
op_logical_neg
id|urb-&gt;transfer_buffer_length
)paren
id|destination
op_or_assign
id|USB_PID_IN
suffix:semicolon
r_else
id|destination
op_or_assign
id|USB_PID_OUT
suffix:semicolon
id|destination
op_or_assign
id|TD_TOKEN_TOGGLE
suffix:semicolon
multiline_comment|/* End in Data1 */
id|status
op_and_assign
op_complement
id|TD_CTRL_SPD
suffix:semicolon
id|uhci_add_td_to_urb
c_func
(paren
id|urb
comma
id|td
)paren
suffix:semicolon
id|uhci_fill_td
c_func
(paren
id|td
comma
id|status
op_or
id|TD_CTRL_IOC
comma
id|destination
op_or
id|uhci_explen
c_func
(paren
id|UHCI_NULL_DATA_SIZE
)paren
comma
l_int|0
)paren
suffix:semicolon
id|qh
op_assign
id|uhci_alloc_qh
c_func
(paren
id|uhci
comma
id|urb-&gt;dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|qh
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|urbp-&gt;qh
op_assign
id|qh
suffix:semicolon
id|qh-&gt;urbp
op_assign
id|urbp
suffix:semicolon
id|uhci_insert_tds_in_qh
c_func
(paren
id|qh
comma
id|urb
comma
id|UHCI_PTR_BREADTH
)paren
suffix:semicolon
multiline_comment|/* Low-speed transfers get a different queue, and won&squot;t hog the bus.&n;&t; * Also, some devices enumerate better without FSBR; the easiest way&n;&t; * to do that is to put URBs on the low-speed queue while the device&n;&t; * is in the DEFAULT state. */
r_if
c_cond
(paren
id|urb-&gt;dev-&gt;speed
op_eq
id|USB_SPEED_LOW
op_logical_or
id|urb-&gt;dev-&gt;state
op_eq
id|USB_STATE_DEFAULT
)paren
id|skelqh
op_assign
id|uhci-&gt;skel_ls_control_qh
suffix:semicolon
r_else
(brace
id|skelqh
op_assign
id|uhci-&gt;skel_fs_control_qh
suffix:semicolon
id|uhci_inc_fsbr
c_func
(paren
id|uhci
comma
id|urb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|eurb
)paren
id|uhci_append_queued_urb
c_func
(paren
id|uhci
comma
id|eurb
comma
id|urb
)paren
suffix:semicolon
r_else
id|uhci_insert_qh
c_func
(paren
id|uhci
comma
id|skelqh
comma
id|urb
)paren
suffix:semicolon
r_return
op_minus
id|EINPROGRESS
suffix:semicolon
)brace
multiline_comment|/*&n; * If control-IN transfer was short, the status packet wasn&squot;t sent.&n; * This routine changes the element pointer in the QH to point at the&n; * status TD.  It&squot;s safe to do this even while the QH is live, because&n; * the hardware only updates the element pointer following a successful&n; * transfer.  The inactive TD for the short packet won&squot;t cause an update,&n; * so the pointer won&squot;t get overwritten.  The next time the controller&n; * sees this QH, it will send the status packet.&n; */
DECL|function|usb_control_retrigger_status
r_static
r_int
id|usb_control_retrigger_status
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|urb_priv
op_star
id|urbp
op_assign
(paren
r_struct
id|urb_priv
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
r_struct
id|uhci_td
op_star
id|td
suffix:semicolon
id|urbp-&gt;short_control_packet
op_assign
l_int|1
suffix:semicolon
id|td
op_assign
id|list_entry
c_func
(paren
id|urbp-&gt;td_list.prev
comma
r_struct
id|uhci_td
comma
id|list
)paren
suffix:semicolon
id|urbp-&gt;qh-&gt;element
op_assign
id|cpu_to_le32
c_func
(paren
id|td-&gt;dma_handle
)paren
suffix:semicolon
r_return
op_minus
id|EINPROGRESS
suffix:semicolon
)brace
DECL|function|uhci_result_control
r_static
r_int
id|uhci_result_control
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
comma
op_star
id|head
suffix:semicolon
r_struct
id|urb_priv
op_star
id|urbp
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
r_struct
id|uhci_td
op_star
id|td
suffix:semicolon
r_int
r_int
id|status
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|urbp-&gt;td_list
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|head
op_assign
op_amp
id|urbp-&gt;td_list
suffix:semicolon
r_if
c_cond
(paren
id|urbp-&gt;short_control_packet
)paren
(brace
id|tmp
op_assign
id|head-&gt;prev
suffix:semicolon
r_goto
id|status_stage
suffix:semicolon
)brace
id|tmp
op_assign
id|head-&gt;next
suffix:semicolon
id|td
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|uhci_td
comma
id|list
)paren
suffix:semicolon
multiline_comment|/* The first TD is the SETUP stage, check the status, but skip */
multiline_comment|/*  the count */
id|status
op_assign
id|uhci_status_bits
c_func
(paren
id|td_status
c_func
(paren
id|td
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TD_CTRL_ACTIVE
)paren
r_return
op_minus
id|EINPROGRESS
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_goto
id|td_error
suffix:semicolon
id|urb-&gt;actual_length
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* The rest of the TD&squot;s (but the last) are data */
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
r_while
c_loop
(paren
id|tmp
op_ne
id|head
op_logical_and
id|tmp-&gt;next
op_ne
id|head
)paren
(brace
r_int
r_int
id|ctrlstat
suffix:semicolon
id|td
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|uhci_td
comma
id|list
)paren
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
id|ctrlstat
op_assign
id|td_status
c_func
(paren
id|td
)paren
suffix:semicolon
id|status
op_assign
id|uhci_status_bits
c_func
(paren
id|ctrlstat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TD_CTRL_ACTIVE
)paren
r_return
op_minus
id|EINPROGRESS
suffix:semicolon
id|urb-&gt;actual_length
op_add_assign
id|uhci_actual_length
c_func
(paren
id|ctrlstat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_goto
id|td_error
suffix:semicolon
multiline_comment|/* Check to see if we received a short packet */
r_if
c_cond
(paren
id|uhci_actual_length
c_func
(paren
id|ctrlstat
)paren
OL
id|uhci_expected_length
c_func
(paren
id|td_token
c_func
(paren
id|td
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|urb-&gt;transfer_flags
op_amp
id|URB_SHORT_NOT_OK
)paren
(brace
id|ret
op_assign
op_minus
id|EREMOTEIO
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uhci_packetid
c_func
(paren
id|td_token
c_func
(paren
id|td
)paren
)paren
op_eq
id|USB_PID_IN
)paren
r_return
id|usb_control_retrigger_status
c_func
(paren
id|uhci
comma
id|urb
)paren
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|status_stage
suffix:colon
id|td
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|uhci_td
comma
id|list
)paren
suffix:semicolon
multiline_comment|/* Control status stage */
id|status
op_assign
id|td_status
c_func
(paren
id|td
)paren
suffix:semicolon
macro_line|#ifdef I_HAVE_BUGGY_APC_BACKUPS
multiline_comment|/* APC BackUPS Pro kludge */
multiline_comment|/* It tries to send all of the descriptor instead of the amount */
multiline_comment|/*  we requested */
r_if
c_cond
(paren
id|status
op_amp
id|TD_CTRL_IOC
op_logical_and
multiline_comment|/* IOC is masked out by uhci_status_bits */
id|status
op_amp
id|TD_CTRL_ACTIVE
op_logical_and
id|status
op_amp
id|TD_CTRL_NAK
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#endif
id|status
op_assign
id|uhci_status_bits
c_func
(paren
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TD_CTRL_ACTIVE
)paren
r_return
op_minus
id|EINPROGRESS
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_goto
id|td_error
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|td_error
suffix:colon
id|ret
op_assign
id|uhci_map_status
c_func
(paren
id|status
comma
id|uhci_packetout
c_func
(paren
id|td_token
c_func
(paren
id|td
)paren
)paren
)paren
suffix:semicolon
id|err
suffix:colon
r_if
c_cond
(paren
(paren
id|debug
op_eq
l_int|1
op_logical_and
id|ret
op_ne
op_minus
id|EPIPE
)paren
op_logical_or
id|debug
OG
l_int|1
)paren
(brace
multiline_comment|/* Some debugging code */
id|dev_dbg
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
comma
l_string|&quot;%s: failed with status %x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|errbuf
)paren
(brace
multiline_comment|/* Print the chain for debugging purposes */
id|uhci_show_qh
c_func
(paren
id|urbp-&gt;qh
comma
id|errbuf
comma
id|ERRBUF_LEN
comma
l_int|0
)paren
suffix:semicolon
id|lprintk
c_func
(paren
id|errbuf
)paren
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Common submit for bulk and interrupt&n; */
DECL|function|uhci_submit_common
r_static
r_int
id|uhci_submit_common
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|urb
op_star
id|eurb
comma
r_struct
id|uhci_qh
op_star
id|skelqh
)paren
(brace
r_struct
id|uhci_td
op_star
id|td
suffix:semicolon
r_struct
id|uhci_qh
op_star
id|qh
suffix:semicolon
r_int
r_int
id|destination
comma
id|status
suffix:semicolon
r_int
id|maxsze
op_assign
id|usb_maxpacket
c_func
(paren
id|urb-&gt;dev
comma
id|urb-&gt;pipe
comma
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
r_int
id|len
op_assign
id|urb-&gt;transfer_buffer_length
suffix:semicolon
r_struct
id|urb_priv
op_star
id|urbp
op_assign
(paren
r_struct
id|urb_priv
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
id|dma_addr_t
id|data
op_assign
id|urb-&gt;transfer_dma
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* The &quot;pipe&quot; thing contains the destination in bits 8--18 */
id|destination
op_assign
(paren
id|urb-&gt;pipe
op_amp
id|PIPE_DEVEP_MASK
)paren
op_or
id|usb_packetid
c_func
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
id|status
op_assign
id|uhci_maxerr
c_func
(paren
l_int|3
)paren
op_or
id|TD_CTRL_ACTIVE
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;dev-&gt;speed
op_eq
id|USB_SPEED_LOW
)paren
id|status
op_or_assign
id|TD_CTRL_LS
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipein
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
id|status
op_or_assign
id|TD_CTRL_SPD
suffix:semicolon
multiline_comment|/*&n;&t; * Build the DATA TD&squot;s&n;&t; */
r_do
(brace
multiline_comment|/* Allow zero length packets */
r_int
id|pktsze
op_assign
id|maxsze
suffix:semicolon
r_if
c_cond
(paren
id|pktsze
op_ge
id|len
)paren
(brace
id|pktsze
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|urb-&gt;transfer_flags
op_amp
id|URB_SHORT_NOT_OK
)paren
)paren
id|status
op_and_assign
op_complement
id|TD_CTRL_SPD
suffix:semicolon
)brace
id|td
op_assign
id|uhci_alloc_td
c_func
(paren
id|uhci
comma
id|urb-&gt;dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|td
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|uhci_add_td_to_urb
c_func
(paren
id|urb
comma
id|td
)paren
suffix:semicolon
id|uhci_fill_td
c_func
(paren
id|td
comma
id|status
comma
id|destination
op_or
id|uhci_explen
c_func
(paren
id|pktsze
op_minus
l_int|1
)paren
op_or
(paren
id|usb_gettoggle
c_func
(paren
id|urb-&gt;dev
comma
id|usb_pipeendpoint
c_func
(paren
id|urb-&gt;pipe
)paren
comma
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
op_lshift
id|TD_TOKEN_TOGGLE_SHIFT
)paren
comma
id|data
)paren
suffix:semicolon
id|data
op_add_assign
id|pktsze
suffix:semicolon
id|len
op_sub_assign
id|maxsze
suffix:semicolon
id|usb_dotoggle
c_func
(paren
id|urb-&gt;dev
comma
id|usb_pipeendpoint
c_func
(paren
id|urb-&gt;pipe
)paren
comma
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * URB_ZERO_PACKET means adding a 0-length packet, if direction&n;&t; * is OUT and the transfer_length was an exact multiple of maxsze,&n;&t; * hence (len = transfer_length - N * maxsze) == 0&n;&t; * however, if transfer_length == 0, the zero packet was already&n;&t; * prepared above.&n;&t; */
r_if
c_cond
(paren
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
op_logical_and
(paren
id|urb-&gt;transfer_flags
op_amp
id|URB_ZERO_PACKET
)paren
op_logical_and
op_logical_neg
id|len
op_logical_and
id|urb-&gt;transfer_buffer_length
)paren
(brace
id|td
op_assign
id|uhci_alloc_td
c_func
(paren
id|uhci
comma
id|urb-&gt;dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|td
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|uhci_add_td_to_urb
c_func
(paren
id|urb
comma
id|td
)paren
suffix:semicolon
id|uhci_fill_td
c_func
(paren
id|td
comma
id|status
comma
id|destination
op_or
id|uhci_explen
c_func
(paren
id|UHCI_NULL_DATA_SIZE
)paren
op_or
(paren
id|usb_gettoggle
c_func
(paren
id|urb-&gt;dev
comma
id|usb_pipeendpoint
c_func
(paren
id|urb-&gt;pipe
)paren
comma
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
op_lshift
id|TD_TOKEN_TOGGLE_SHIFT
)paren
comma
id|data
)paren
suffix:semicolon
id|usb_dotoggle
c_func
(paren
id|urb-&gt;dev
comma
id|usb_pipeendpoint
c_func
(paren
id|urb-&gt;pipe
)paren
comma
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Set the interrupt-on-completion flag on the last packet.&n;&t; * A more-or-less typical 4 KB URB (= size of one memory page)&n;&t; * will require about 3 ms to transfer; that&squot;s a little on the&n;&t; * fast side but not enough to justify delaying an interrupt&n;&t; * more than 2 or 3 URBs, so we will ignore the URB_NO_INTERRUPT&n;&t; * flag setting. */
id|td-&gt;status
op_or_assign
id|cpu_to_le32
c_func
(paren
id|TD_CTRL_IOC
)paren
suffix:semicolon
id|qh
op_assign
id|uhci_alloc_qh
c_func
(paren
id|uhci
comma
id|urb-&gt;dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|qh
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|urbp-&gt;qh
op_assign
id|qh
suffix:semicolon
id|qh-&gt;urbp
op_assign
id|urbp
suffix:semicolon
multiline_comment|/* Always breadth first */
id|uhci_insert_tds_in_qh
c_func
(paren
id|qh
comma
id|urb
comma
id|UHCI_PTR_BREADTH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eurb
)paren
id|uhci_append_queued_urb
c_func
(paren
id|uhci
comma
id|eurb
comma
id|urb
)paren
suffix:semicolon
r_else
id|uhci_insert_qh
c_func
(paren
id|uhci
comma
id|skelqh
comma
id|urb
)paren
suffix:semicolon
r_return
op_minus
id|EINPROGRESS
suffix:semicolon
)brace
multiline_comment|/*&n; * Common result for bulk and interrupt&n; */
DECL|function|uhci_result_common
r_static
r_int
id|uhci_result_common
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|urb_priv
op_star
id|urbp
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
r_struct
id|uhci_td
op_star
id|td
suffix:semicolon
r_int
r_int
id|status
op_assign
l_int|0
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|urb-&gt;actual_length
op_assign
l_int|0
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|td
comma
op_amp
id|urbp-&gt;td_list
comma
id|list
)paren
(brace
r_int
r_int
id|ctrlstat
op_assign
id|td_status
c_func
(paren
id|td
)paren
suffix:semicolon
id|status
op_assign
id|uhci_status_bits
c_func
(paren
id|ctrlstat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TD_CTRL_ACTIVE
)paren
r_return
op_minus
id|EINPROGRESS
suffix:semicolon
id|urb-&gt;actual_length
op_add_assign
id|uhci_actual_length
c_func
(paren
id|ctrlstat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_goto
id|td_error
suffix:semicolon
r_if
c_cond
(paren
id|uhci_actual_length
c_func
(paren
id|ctrlstat
)paren
OL
id|uhci_expected_length
c_func
(paren
id|td_token
c_func
(paren
id|td
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|urb-&gt;transfer_flags
op_amp
id|URB_SHORT_NOT_OK
)paren
(brace
id|ret
op_assign
op_minus
id|EREMOTEIO
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
id|td_error
suffix:colon
id|ret
op_assign
id|uhci_map_status
c_func
(paren
id|status
comma
id|uhci_packetout
c_func
(paren
id|td_token
c_func
(paren
id|td
)paren
)paren
)paren
suffix:semicolon
id|err
suffix:colon
multiline_comment|/* &n;&t; * Enable this chunk of code if you want to see some more debugging.&n;&t; * But be careful, it has the tendancy to starve out khubd and prevent&n;&t; * disconnects from happening successfully if you have a slow debug&n;&t; * log interface (like a serial console.&n;&t; */
macro_line|#if 0
r_if
c_cond
(paren
(paren
id|debug
op_eq
l_int|1
op_logical_and
id|ret
op_ne
op_minus
id|EPIPE
)paren
op_logical_or
id|debug
OG
l_int|1
)paren
(brace
multiline_comment|/* Some debugging code */
id|dev_dbg
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
comma
l_string|&quot;%s: failed with status %x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|errbuf
)paren
(brace
multiline_comment|/* Print the chain for debugging purposes */
id|uhci_show_qh
c_func
(paren
id|urbp-&gt;qh
comma
id|errbuf
comma
id|ERRBUF_LEN
comma
l_int|0
)paren
suffix:semicolon
id|lprintk
c_func
(paren
id|errbuf
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
r_return
id|ret
suffix:semicolon
)brace
DECL|function|uhci_submit_bulk
r_static
r_inline
r_int
id|uhci_submit_bulk
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|urb
op_star
id|eurb
)paren
(brace
r_int
id|ret
suffix:semicolon
multiline_comment|/* Can&squot;t have low-speed bulk transfers */
r_if
c_cond
(paren
id|urb-&gt;dev-&gt;speed
op_eq
id|USB_SPEED_LOW
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ret
op_assign
id|uhci_submit_common
c_func
(paren
id|uhci
comma
id|urb
comma
id|eurb
comma
id|uhci-&gt;skel_bulk_qh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EINPROGRESS
)paren
id|uhci_inc_fsbr
c_func
(paren
id|uhci
comma
id|urb
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|uhci_submit_interrupt
r_static
r_inline
r_int
id|uhci_submit_interrupt
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|urb
op_star
id|eurb
)paren
(brace
multiline_comment|/* USB 1.1 interrupt transfers only involve one packet per interval;&n;&t; * that&squot;s the uhci_submit_common() &quot;breadth first&quot; policy.  Drivers&n;&t; * can submit urbs of any length, but longer ones might need many&n;&t; * intervals to complete.&n;&t; */
r_return
id|uhci_submit_common
c_func
(paren
id|uhci
comma
id|urb
comma
id|eurb
comma
id|uhci-&gt;skelqh
(braket
id|__interval_to_skel
c_func
(paren
id|urb-&gt;interval
)paren
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Isochronous transfers&n; */
DECL|function|isochronous_find_limits
r_static
r_int
id|isochronous_find_limits
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
r_int
op_star
id|start
comma
r_int
r_int
op_star
id|end
)paren
(brace
r_struct
id|urb
op_star
id|last_urb
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|urb_priv
op_star
id|up
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|up
comma
op_amp
id|uhci-&gt;urb_list
comma
id|urb_list
)paren
(brace
r_struct
id|urb
op_star
id|u
op_assign
id|up-&gt;urb
suffix:semicolon
multiline_comment|/* look for pending URB&squot;s with identical pipe handle */
r_if
c_cond
(paren
(paren
id|urb-&gt;pipe
op_eq
id|u-&gt;pipe
)paren
op_logical_and
(paren
id|urb-&gt;dev
op_eq
id|u-&gt;dev
)paren
op_logical_and
(paren
id|u-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
op_logical_and
(paren
id|u
op_ne
id|urb
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|last_urb
)paren
op_star
id|start
op_assign
id|u-&gt;start_frame
suffix:semicolon
id|last_urb
op_assign
id|u
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|last_urb
)paren
(brace
op_star
id|end
op_assign
(paren
id|last_urb-&gt;start_frame
op_plus
id|last_urb-&gt;number_of_packets
op_star
id|last_urb-&gt;interval
)paren
op_amp
(paren
id|UHCI_NUMFRAMES
op_minus
l_int|1
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* no previous urb found */
r_return
id|ret
suffix:semicolon
)brace
DECL|function|isochronous_find_start
r_static
r_int
id|isochronous_find_start
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
id|limits
suffix:semicolon
r_int
r_int
id|start
op_assign
l_int|0
comma
id|end
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;number_of_packets
OG
l_int|900
)paren
multiline_comment|/* 900? Why? */
r_return
op_minus
id|EFBIG
suffix:semicolon
id|limits
op_assign
id|isochronous_find_limits
c_func
(paren
id|uhci
comma
id|urb
comma
op_amp
id|start
comma
op_amp
id|end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;transfer_flags
op_amp
id|URB_ISO_ASAP
)paren
(brace
r_if
c_cond
(paren
id|limits
)paren
id|urb-&gt;start_frame
op_assign
(paren
id|uhci_get_current_frame_number
c_func
(paren
id|uhci
)paren
op_plus
l_int|10
)paren
op_amp
(paren
id|UHCI_NUMFRAMES
op_minus
l_int|1
)paren
suffix:semicolon
r_else
id|urb-&gt;start_frame
op_assign
id|end
suffix:semicolon
)brace
r_else
(brace
id|urb-&gt;start_frame
op_and_assign
(paren
id|UHCI_NUMFRAMES
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* FIXME: Sanity check */
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Isochronous transfers&n; */
DECL|function|uhci_submit_isochronous
r_static
r_int
id|uhci_submit_isochronous
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|uhci_td
op_star
id|td
suffix:semicolon
r_int
id|i
comma
id|ret
comma
id|frame
suffix:semicolon
r_int
id|status
comma
id|destination
suffix:semicolon
id|status
op_assign
id|TD_CTRL_ACTIVE
op_or
id|TD_CTRL_IOS
suffix:semicolon
id|destination
op_assign
(paren
id|urb-&gt;pipe
op_amp
id|PIPE_DEVEP_MASK
)paren
op_or
id|usb_packetid
c_func
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
id|ret
op_assign
id|isochronous_find_start
c_func
(paren
id|uhci
comma
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
id|frame
op_assign
id|urb-&gt;start_frame
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|i
op_increment
comma
id|frame
op_add_assign
id|urb-&gt;interval
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|length
)paren
r_continue
suffix:semicolon
id|td
op_assign
id|uhci_alloc_td
c_func
(paren
id|uhci
comma
id|urb-&gt;dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|td
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|uhci_add_td_to_urb
c_func
(paren
id|urb
comma
id|td
)paren
suffix:semicolon
id|uhci_fill_td
c_func
(paren
id|td
comma
id|status
comma
id|destination
op_or
id|uhci_explen
c_func
(paren
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|length
op_minus
l_int|1
)paren
comma
id|urb-&gt;transfer_dma
op_plus
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_plus
l_int|1
op_ge
id|urb-&gt;number_of_packets
)paren
id|td-&gt;status
op_or_assign
id|cpu_to_le32
c_func
(paren
id|TD_CTRL_IOC
)paren
suffix:semicolon
id|uhci_insert_td_frame_list
c_func
(paren
id|uhci
comma
id|td
comma
id|frame
)paren
suffix:semicolon
)brace
r_return
op_minus
id|EINPROGRESS
suffix:semicolon
)brace
DECL|function|uhci_result_isochronous
r_static
r_int
id|uhci_result_isochronous
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|uhci_td
op_star
id|td
suffix:semicolon
r_struct
id|urb_priv
op_star
id|urbp
op_assign
(paren
r_struct
id|urb_priv
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|i
comma
id|ret
op_assign
l_int|0
suffix:semicolon
id|urb-&gt;actual_length
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|td
comma
op_amp
id|urbp-&gt;td_list
comma
id|list
)paren
(brace
r_int
id|actlength
suffix:semicolon
r_int
r_int
id|ctrlstat
op_assign
id|td_status
c_func
(paren
id|td
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctrlstat
op_amp
id|TD_CTRL_ACTIVE
)paren
r_return
op_minus
id|EINPROGRESS
suffix:semicolon
id|actlength
op_assign
id|uhci_actual_length
c_func
(paren
id|ctrlstat
)paren
suffix:semicolon
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|actual_length
op_assign
id|actlength
suffix:semicolon
id|urb-&gt;actual_length
op_add_assign
id|actlength
suffix:semicolon
id|status
op_assign
id|uhci_map_status
c_func
(paren
id|uhci_status_bits
c_func
(paren
id|ctrlstat
)paren
comma
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|status
op_assign
id|status
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
id|urb-&gt;error_count
op_increment
suffix:semicolon
id|ret
op_assign
id|status
suffix:semicolon
)brace
id|i
op_increment
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|uhci_find_urb_ep
r_static
r_struct
id|urb
op_star
id|uhci_find_urb_ep
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|urb_priv
op_star
id|up
suffix:semicolon
multiline_comment|/* We don&squot;t match Isoc transfers since they are special */
r_if
c_cond
(paren
id|usb_pipeisoc
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|up
comma
op_amp
id|uhci-&gt;urb_list
comma
id|urb_list
)paren
(brace
r_struct
id|urb
op_star
id|u
op_assign
id|up-&gt;urb
suffix:semicolon
r_if
c_cond
(paren
id|u-&gt;dev
op_eq
id|urb-&gt;dev
op_logical_and
id|u-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
(brace
multiline_comment|/* For control, ignore the direction */
r_if
c_cond
(paren
id|usb_pipecontrol
c_func
(paren
id|urb-&gt;pipe
)paren
op_logical_and
(paren
id|u-&gt;pipe
op_amp
op_complement
id|USB_DIR_IN
)paren
op_eq
(paren
id|urb-&gt;pipe
op_amp
op_complement
id|USB_DIR_IN
)paren
)paren
r_return
id|u
suffix:semicolon
r_else
r_if
c_cond
(paren
id|u-&gt;pipe
op_eq
id|urb-&gt;pipe
)paren
r_return
id|u
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|uhci_urb_enqueue
r_static
r_int
id|uhci_urb_enqueue
c_func
(paren
r_struct
id|usb_hcd
op_star
id|hcd
comma
r_struct
id|usb_host_endpoint
op_star
id|ep
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|mem_flags
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|uhci_hcd
op_star
id|uhci
op_assign
id|hcd_to_uhci
c_func
(paren
id|hcd
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|urb
op_star
id|eurb
suffix:semicolon
r_int
id|bustime
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|uhci-&gt;schedule_lock
comma
id|flags
)paren
suffix:semicolon
id|ret
op_assign
id|urb-&gt;status
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
op_minus
id|EINPROGRESS
)paren
multiline_comment|/* URB already unlinked! */
r_goto
id|out
suffix:semicolon
id|eurb
op_assign
id|uhci_find_urb_ep
c_func
(paren
id|uhci
comma
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|uhci_alloc_urb_priv
c_func
(paren
id|uhci
comma
id|urb
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
r_case
id|PIPE_CONTROL
suffix:colon
id|ret
op_assign
id|uhci_submit_control
c_func
(paren
id|uhci
comma
id|urb
comma
id|eurb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_INTERRUPT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|eurb
)paren
(brace
id|bustime
op_assign
id|usb_check_bandwidth
c_func
(paren
id|urb-&gt;dev
comma
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bustime
OL
l_int|0
)paren
id|ret
op_assign
id|bustime
suffix:semicolon
r_else
(brace
id|ret
op_assign
id|uhci_submit_interrupt
c_func
(paren
id|uhci
comma
id|urb
comma
id|eurb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EINPROGRESS
)paren
id|usb_claim_bandwidth
c_func
(paren
id|urb-&gt;dev
comma
id|urb
comma
id|bustime
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* inherit from parent */
id|urb-&gt;bandwidth
op_assign
id|eurb-&gt;bandwidth
suffix:semicolon
id|ret
op_assign
id|uhci_submit_interrupt
c_func
(paren
id|uhci
comma
id|urb
comma
id|eurb
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|PIPE_BULK
suffix:colon
id|ret
op_assign
id|uhci_submit_bulk
c_func
(paren
id|uhci
comma
id|urb
comma
id|eurb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_ISOCHRONOUS
suffix:colon
id|bustime
op_assign
id|usb_check_bandwidth
c_func
(paren
id|urb-&gt;dev
comma
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bustime
OL
l_int|0
)paren
(brace
id|ret
op_assign
id|bustime
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ret
op_assign
id|uhci_submit_isochronous
c_func
(paren
id|uhci
comma
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EINPROGRESS
)paren
id|usb_claim_bandwidth
c_func
(paren
id|urb-&gt;dev
comma
id|urb
comma
id|bustime
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_ne
op_minus
id|EINPROGRESS
)paren
(brace
multiline_comment|/* Submit failed, so delete it from the urb_list */
r_struct
id|urb_priv
op_star
id|urbp
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|urbp-&gt;urb_list
)paren
suffix:semicolon
id|uhci_destroy_urb_priv
c_func
(paren
id|uhci
comma
id|urb
)paren
suffix:semicolon
)brace
r_else
id|ret
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|uhci-&gt;schedule_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Return the result of a transfer&n; */
DECL|function|uhci_transfer_result
r_static
r_void
id|uhci_transfer_result
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
id|ret
op_assign
op_minus
id|EINPROGRESS
suffix:semicolon
r_struct
id|urb_priv
op_star
id|urbp
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|urb-&gt;lock
)paren
suffix:semicolon
id|urbp
op_assign
(paren
r_struct
id|urb_priv
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;status
op_ne
op_minus
id|EINPROGRESS
)paren
multiline_comment|/* URB already dequeued */
r_goto
id|out
suffix:semicolon
r_switch
c_cond
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
r_case
id|PIPE_CONTROL
suffix:colon
id|ret
op_assign
id|uhci_result_control
c_func
(paren
id|uhci
comma
id|urb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_BULK
suffix:colon
r_case
id|PIPE_INTERRUPT
suffix:colon
id|ret
op_assign
id|uhci_result_common
c_func
(paren
id|uhci
comma
id|urb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_ISOCHRONOUS
suffix:colon
id|ret
op_assign
id|uhci_result_isochronous
c_func
(paren
id|uhci
comma
id|urb
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EINPROGRESS
)paren
r_goto
id|out
suffix:semicolon
id|urb-&gt;status
op_assign
id|ret
suffix:semicolon
r_switch
c_cond
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
r_case
id|PIPE_CONTROL
suffix:colon
r_case
id|PIPE_BULK
suffix:colon
r_case
id|PIPE_ISOCHRONOUS
suffix:colon
multiline_comment|/* Release bandwidth for Interrupt or Isoc. transfers */
r_if
c_cond
(paren
id|urb-&gt;bandwidth
)paren
id|usb_release_bandwidth
c_func
(paren
id|urb-&gt;dev
comma
id|urb
comma
l_int|1
)paren
suffix:semicolon
id|uhci_unlink_generic
c_func
(paren
id|uhci
comma
id|urb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_INTERRUPT
suffix:colon
multiline_comment|/* Release bandwidth for Interrupt or Isoc. transfers */
multiline_comment|/* Make sure we don&squot;t release if we have a queued URB */
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|urbp-&gt;queue_list
)paren
op_logical_and
id|urb-&gt;bandwidth
)paren
id|usb_release_bandwidth
c_func
(paren
id|urb-&gt;dev
comma
id|urb
comma
l_int|0
)paren
suffix:semicolon
r_else
multiline_comment|/* bandwidth was passed on to queued URB, */
multiline_comment|/* so don&squot;t let usb_unlink_urb() release it */
id|urb-&gt;bandwidth
op_assign
l_int|0
suffix:semicolon
id|uhci_unlink_generic
c_func
(paren
id|uhci
comma
id|urb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|dev_info
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
comma
l_string|&quot;%s: unknown pipe type %d &quot;
l_string|&quot;for urb %p&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
comma
id|urb
)paren
suffix:semicolon
)brace
multiline_comment|/* Move it from uhci-&gt;urb_list to uhci-&gt;complete_list */
id|uhci_moveto_complete
c_func
(paren
id|uhci
comma
id|urbp
)paren
suffix:semicolon
id|out
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|urb-&gt;lock
)paren
suffix:semicolon
)brace
DECL|function|uhci_unlink_generic
r_static
r_void
id|uhci_unlink_generic
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|list_head
op_star
id|head
suffix:semicolon
r_struct
id|uhci_td
op_star
id|td
suffix:semicolon
r_struct
id|urb_priv
op_star
id|urbp
op_assign
(paren
r_struct
id|urb_priv
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
r_int
id|prevactive
op_assign
l_int|0
suffix:semicolon
id|uhci_dec_fsbr
c_func
(paren
id|uhci
comma
id|urb
)paren
suffix:semicolon
multiline_comment|/* Safe since it checks */
multiline_comment|/*&n;&t; * Now we need to find out what the last successful toggle was&n;&t; * so we can update the local data toggle for the next transfer&n;&t; *&n;&t; * There are 2 ways the last successful completed TD is found:&n;&t; *&n;&t; * 1) The TD is NOT active and the actual length &lt; expected length&n;&t; * 2) The TD is NOT active and it&squot;s the last TD in the chain&n;&t; *&n;&t; * and a third way the first uncompleted TD is found:&n;&t; *&n;&t; * 3) The TD is active and the previous TD is NOT active&n;&t; *&n;&t; * Control and Isochronous ignore the toggle, so this is safe&n;&t; * for all types&n;&t; *&n;&t; * FIXME: The toggle fixups won&squot;t be 100% reliable until we&n;&t; * change over to using a single queue for each endpoint and&n;&t; * stop the queue before unlinking.&n;&t; */
id|head
op_assign
op_amp
id|urbp-&gt;td_list
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|td
comma
id|head
comma
id|list
)paren
(brace
r_int
r_int
id|ctrlstat
op_assign
id|td_status
c_func
(paren
id|td
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ctrlstat
op_amp
id|TD_CTRL_ACTIVE
)paren
op_logical_and
(paren
id|uhci_actual_length
c_func
(paren
id|ctrlstat
)paren
OL
id|uhci_expected_length
c_func
(paren
id|td_token
c_func
(paren
id|td
)paren
)paren
op_logical_or
id|td-&gt;list.next
op_eq
id|head
)paren
)paren
id|usb_settoggle
c_func
(paren
id|urb-&gt;dev
comma
id|uhci_endpoint
c_func
(paren
id|td_token
c_func
(paren
id|td
)paren
)paren
comma
id|uhci_packetout
c_func
(paren
id|td_token
c_func
(paren
id|td
)paren
)paren
comma
id|uhci_toggle
c_func
(paren
id|td_token
c_func
(paren
id|td
)paren
)paren
op_xor
l_int|1
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|ctrlstat
op_amp
id|TD_CTRL_ACTIVE
)paren
op_logical_and
op_logical_neg
id|prevactive
)paren
id|usb_settoggle
c_func
(paren
id|urb-&gt;dev
comma
id|uhci_endpoint
c_func
(paren
id|td_token
c_func
(paren
id|td
)paren
)paren
comma
id|uhci_packetout
c_func
(paren
id|td_token
c_func
(paren
id|td
)paren
)paren
comma
id|uhci_toggle
c_func
(paren
id|td_token
c_func
(paren
id|td
)paren
)paren
)paren
suffix:semicolon
id|prevactive
op_assign
id|ctrlstat
op_amp
id|TD_CTRL_ACTIVE
suffix:semicolon
)brace
id|uhci_delete_queued_urb
c_func
(paren
id|uhci
comma
id|urb
)paren
suffix:semicolon
multiline_comment|/* The interrupt loop will reclaim the QH&squot;s */
id|uhci_remove_qh
c_func
(paren
id|uhci
comma
id|urbp-&gt;qh
)paren
suffix:semicolon
id|urbp-&gt;qh
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|uhci_urb_dequeue
r_static
r_int
id|uhci_urb_dequeue
c_func
(paren
r_struct
id|usb_hcd
op_star
id|hcd
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|uhci_hcd
op_star
id|uhci
op_assign
id|hcd_to_uhci
c_func
(paren
id|hcd
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|urb_priv
op_star
id|urbp
suffix:semicolon
r_int
r_int
id|age
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|uhci-&gt;schedule_lock
comma
id|flags
)paren
suffix:semicolon
id|urbp
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urbp
)paren
multiline_comment|/* URB was never linked! */
r_goto
id|done
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|urbp-&gt;urb_list
)paren
suffix:semicolon
id|uhci_unlink_generic
c_func
(paren
id|uhci
comma
id|urb
)paren
suffix:semicolon
id|age
op_assign
id|uhci_get_current_frame_number
c_func
(paren
id|uhci
)paren
suffix:semicolon
r_if
c_cond
(paren
id|age
op_ne
id|uhci-&gt;urb_remove_age
)paren
(brace
id|uhci_remove_pending_urbps
c_func
(paren
id|uhci
)paren
suffix:semicolon
id|uhci-&gt;urb_remove_age
op_assign
id|age
suffix:semicolon
)brace
multiline_comment|/* If we&squot;re the first, set the next interrupt bit */
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|uhci-&gt;urb_remove_list
)paren
)paren
id|uhci_set_next_interrupt
c_func
(paren
id|uhci
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|urbp-&gt;urb_list
comma
op_amp
id|uhci-&gt;urb_remove_list
)paren
suffix:semicolon
id|done
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|uhci-&gt;schedule_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|uhci_fsbr_timeout
r_static
r_int
id|uhci_fsbr_timeout
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|urb_priv
op_star
id|urbp
op_assign
(paren
r_struct
id|urb_priv
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
r_struct
id|list_head
op_star
id|head
suffix:semicolon
r_struct
id|uhci_td
op_star
id|td
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
id|uhci_dec_fsbr
c_func
(paren
id|uhci
comma
id|urb
)paren
suffix:semicolon
id|urbp-&gt;fsbr_timeout
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Ideally we would want to fix qh-&gt;element as well, but it&squot;s&n;&t; * read/write by the HC, so that can introduce a race. It&squot;s not&n;&t; * really worth the hassle&n;&t; */
id|head
op_assign
op_amp
id|urbp-&gt;td_list
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|td
comma
id|head
comma
id|list
)paren
(brace
multiline_comment|/*&n;&t;&t; * Make sure we don&squot;t do the last one (since it&squot;ll have the&n;&t;&t; * TERM bit set) as well as we skip every so many TD&squot;s to&n;&t;&t; * make sure it doesn&squot;t hog the bandwidth&n;&t;&t; */
r_if
c_cond
(paren
id|td-&gt;list.next
op_ne
id|head
op_logical_and
(paren
id|count
op_mod
id|DEPTH_INTERVAL
)paren
op_eq
(paren
id|DEPTH_INTERVAL
op_minus
l_int|1
)paren
)paren
id|td-&gt;link
op_or_assign
id|UHCI_PTR_DEPTH
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * uhci_get_current_frame_number()&n; *&n; * returns the current frame number for a USB bus/controller.&n; */
DECL|function|uhci_get_current_frame_number
r_static
r_int
r_int
id|uhci_get_current_frame_number
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
)paren
(brace
r_return
id|inw
c_func
(paren
id|uhci-&gt;io_addr
op_plus
id|USBFRNUM
)paren
suffix:semicolon
)brace
r_static
r_int
id|init_stall_timer
c_func
(paren
r_struct
id|usb_hcd
op_star
id|hcd
)paren
suffix:semicolon
DECL|function|stall_callback
r_static
r_void
id|stall_callback
c_func
(paren
r_int
r_int
id|ptr
)paren
(brace
r_struct
id|usb_hcd
op_star
id|hcd
op_assign
(paren
r_struct
id|usb_hcd
op_star
)paren
id|ptr
suffix:semicolon
r_struct
id|uhci_hcd
op_star
id|uhci
op_assign
id|hcd_to_uhci
c_func
(paren
id|hcd
)paren
suffix:semicolon
r_struct
id|urb_priv
op_star
id|up
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|called_uhci_finish_completion
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|uhci-&gt;schedule_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|uhci-&gt;urb_remove_list
)paren
op_logical_and
id|uhci_get_current_frame_number
c_func
(paren
id|uhci
)paren
op_ne
id|uhci-&gt;urb_remove_age
)paren
(brace
id|uhci_remove_pending_urbps
c_func
(paren
id|uhci
)paren
suffix:semicolon
id|uhci_finish_completion
c_func
(paren
id|hcd
comma
l_int|NULL
)paren
suffix:semicolon
id|called_uhci_finish_completion
op_assign
l_int|1
suffix:semicolon
)brace
id|list_for_each_entry
c_func
(paren
id|up
comma
op_amp
id|uhci-&gt;urb_list
comma
id|urb_list
)paren
(brace
r_struct
id|urb
op_star
id|u
op_assign
id|up-&gt;urb
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|u-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* Check if the FSBR timed out */
r_if
c_cond
(paren
id|up-&gt;fsbr
op_logical_and
op_logical_neg
id|up-&gt;fsbr_timeout
op_logical_and
id|time_after_eq
c_func
(paren
id|jiffies
comma
id|up-&gt;fsbrtime
op_plus
id|IDLE_TIMEOUT
)paren
)paren
id|uhci_fsbr_timeout
c_func
(paren
id|uhci
comma
id|u
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|u-&gt;lock
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|uhci-&gt;schedule_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Wake up anyone waiting for an URB to complete */
r_if
c_cond
(paren
id|called_uhci_finish_completion
)paren
id|wake_up_all
c_func
(paren
op_amp
id|uhci-&gt;waitqh
)paren
suffix:semicolon
multiline_comment|/* Really disable FSBR */
r_if
c_cond
(paren
op_logical_neg
id|uhci-&gt;fsbr
op_logical_and
id|uhci-&gt;fsbrtimeout
op_logical_and
id|time_after_eq
c_func
(paren
id|jiffies
comma
id|uhci-&gt;fsbrtimeout
)paren
)paren
(brace
id|uhci-&gt;fsbrtimeout
op_assign
l_int|0
suffix:semicolon
id|uhci-&gt;skel_term_qh-&gt;link
op_assign
id|UHCI_PTR_TERM
suffix:semicolon
)brace
multiline_comment|/* Poll for and perform state transitions */
id|hc_state_transitions
c_func
(paren
id|uhci
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|uhci-&gt;suspended_ports
op_logical_and
id|uhci-&gt;state
op_ne
id|UHCI_SUSPENDED
)paren
)paren
id|uhci_check_resume
c_func
(paren
id|uhci
)paren
suffix:semicolon
id|init_stall_timer
c_func
(paren
id|hcd
)paren
suffix:semicolon
)brace
DECL|function|init_stall_timer
r_static
r_int
id|init_stall_timer
c_func
(paren
r_struct
id|usb_hcd
op_star
id|hcd
)paren
(brace
r_struct
id|uhci_hcd
op_star
id|uhci
op_assign
id|hcd_to_uhci
c_func
(paren
id|hcd
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|uhci-&gt;stall_timer
)paren
suffix:semicolon
id|uhci-&gt;stall_timer.function
op_assign
id|stall_callback
suffix:semicolon
id|uhci-&gt;stall_timer.data
op_assign
(paren
r_int
r_int
)paren
id|hcd
suffix:semicolon
id|uhci-&gt;stall_timer.expires
op_assign
id|jiffies
op_plus
id|msecs_to_jiffies
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|uhci-&gt;stall_timer
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|uhci_free_pending_qhs
r_static
r_void
id|uhci_free_pending_qhs
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
)paren
(brace
r_struct
id|uhci_qh
op_star
id|qh
comma
op_star
id|tmp
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|qh
comma
id|tmp
comma
op_amp
id|uhci-&gt;qh_remove_list
comma
id|remove_list
)paren
(brace
id|list_del_init
c_func
(paren
op_amp
id|qh-&gt;remove_list
)paren
suffix:semicolon
id|uhci_free_qh
c_func
(paren
id|uhci
comma
id|qh
)paren
suffix:semicolon
)brace
)brace
DECL|function|uhci_free_pending_tds
r_static
r_void
id|uhci_free_pending_tds
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
)paren
(brace
r_struct
id|uhci_td
op_star
id|td
comma
op_star
id|tmp
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|td
comma
id|tmp
comma
op_amp
id|uhci-&gt;td_remove_list
comma
id|remove_list
)paren
(brace
id|list_del_init
c_func
(paren
op_amp
id|td-&gt;remove_list
)paren
suffix:semicolon
id|uhci_free_td
c_func
(paren
id|uhci
comma
id|td
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
id|uhci_finish_urb
c_func
(paren
r_struct
id|usb_hcd
op_star
id|hcd
comma
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
id|__releases
c_func
(paren
id|uhci-&gt;schedule_lock
)paren
id|__acquires
c_func
(paren
id|uhci-&gt;schedule_lock
)paren
(brace
r_struct
id|uhci_hcd
op_star
id|uhci
op_assign
id|hcd_to_uhci
c_func
(paren
id|hcd
)paren
suffix:semicolon
id|uhci_destroy_urb_priv
c_func
(paren
id|uhci
comma
id|urb
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|uhci-&gt;schedule_lock
)paren
suffix:semicolon
id|usb_hcd_giveback_urb
c_func
(paren
id|hcd
comma
id|urb
comma
id|regs
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|uhci-&gt;schedule_lock
)paren
suffix:semicolon
)brace
DECL|function|uhci_finish_completion
r_static
r_void
id|uhci_finish_completion
c_func
(paren
r_struct
id|usb_hcd
op_star
id|hcd
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|uhci_hcd
op_star
id|uhci
op_assign
id|hcd_to_uhci
c_func
(paren
id|hcd
)paren
suffix:semicolon
r_struct
id|urb_priv
op_star
id|urbp
comma
op_star
id|tmp
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|urbp
comma
id|tmp
comma
op_amp
id|uhci-&gt;complete_list
comma
id|urb_list
)paren
(brace
r_struct
id|urb
op_star
id|urb
op_assign
id|urbp-&gt;urb
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|urbp-&gt;urb_list
)paren
suffix:semicolon
id|uhci_finish_urb
c_func
(paren
id|hcd
comma
id|urb
comma
id|regs
)paren
suffix:semicolon
)brace
)brace
DECL|function|uhci_remove_pending_urbps
r_static
r_void
id|uhci_remove_pending_urbps
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
)paren
(brace
multiline_comment|/* Splice the urb_remove_list onto the end of the complete_list */
id|list_splice_init
c_func
(paren
op_amp
id|uhci-&gt;urb_remove_list
comma
id|uhci-&gt;complete_list.prev
)paren
suffix:semicolon
)brace
DECL|function|uhci_irq
r_static
id|irqreturn_t
id|uhci_irq
c_func
(paren
r_struct
id|usb_hcd
op_star
id|hcd
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|uhci_hcd
op_star
id|uhci
op_assign
id|hcd_to_uhci
c_func
(paren
id|hcd
)paren
suffix:semicolon
r_int
r_int
id|io_addr
op_assign
id|uhci-&gt;io_addr
suffix:semicolon
r_int
r_int
id|status
suffix:semicolon
r_struct
id|urb_priv
op_star
id|urbp
comma
op_star
id|tmp
suffix:semicolon
r_int
r_int
id|age
suffix:semicolon
multiline_comment|/*&n;&t; * Read the interrupt status, and write it back to clear the&n;&t; * interrupt cause.  Contrary to the UHCI specification, the&n;&t; * &quot;HC Halted&quot; status bit is persistent: it is RO, not R/WC.&n;&t; */
id|status
op_assign
id|inw
c_func
(paren
id|io_addr
op_plus
id|USBSTS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
op_complement
id|USBSTS_HCH
)paren
)paren
multiline_comment|/* shared interrupt, not mine */
r_return
id|IRQ_NONE
suffix:semicolon
id|outw
c_func
(paren
id|status
comma
id|io_addr
op_plus
id|USBSTS
)paren
suffix:semicolon
multiline_comment|/* Clear it */
r_if
c_cond
(paren
id|status
op_amp
op_complement
(paren
id|USBSTS_USBINT
op_or
id|USBSTS_ERROR
op_or
id|USBSTS_RD
)paren
)paren
(brace
r_if
c_cond
(paren
id|status
op_amp
id|USBSTS_HSE
)paren
id|dev_err
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
comma
l_string|&quot;host system error, &quot;
l_string|&quot;PCI problems?&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|USBSTS_HCPE
)paren
id|dev_err
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
comma
l_string|&quot;host controller process &quot;
l_string|&quot;error, something bad happened!&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
id|USBSTS_HCH
)paren
op_logical_and
id|uhci-&gt;state
OG
l_int|0
)paren
(brace
id|dev_err
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
comma
l_string|&quot;host controller halted, &quot;
l_string|&quot;very bad!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* FIXME: Reset the controller, fix the offending TD */
)brace
)brace
r_if
c_cond
(paren
id|status
op_amp
id|USBSTS_RD
)paren
id|uhci-&gt;resume_detect
op_assign
l_int|1
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|uhci-&gt;schedule_lock
)paren
suffix:semicolon
id|age
op_assign
id|uhci_get_current_frame_number
c_func
(paren
id|uhci
)paren
suffix:semicolon
r_if
c_cond
(paren
id|age
op_ne
id|uhci-&gt;qh_remove_age
)paren
id|uhci_free_pending_qhs
c_func
(paren
id|uhci
)paren
suffix:semicolon
r_if
c_cond
(paren
id|age
op_ne
id|uhci-&gt;td_remove_age
)paren
id|uhci_free_pending_tds
c_func
(paren
id|uhci
)paren
suffix:semicolon
r_if
c_cond
(paren
id|age
op_ne
id|uhci-&gt;urb_remove_age
)paren
id|uhci_remove_pending_urbps
c_func
(paren
id|uhci
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|uhci-&gt;urb_remove_list
)paren
op_logical_and
id|list_empty
c_func
(paren
op_amp
id|uhci-&gt;td_remove_list
)paren
op_logical_and
id|list_empty
c_func
(paren
op_amp
id|uhci-&gt;qh_remove_list
)paren
)paren
id|uhci_clear_next_interrupt
c_func
(paren
id|uhci
)paren
suffix:semicolon
r_else
id|uhci_set_next_interrupt
c_func
(paren
id|uhci
)paren
suffix:semicolon
multiline_comment|/* Walk the list of pending URBs to see which ones completed&n;&t; * (must be _safe because uhci_transfer_result() dequeues URBs) */
id|list_for_each_entry_safe
c_func
(paren
id|urbp
comma
id|tmp
comma
op_amp
id|uhci-&gt;urb_list
comma
id|urb_list
)paren
(brace
r_struct
id|urb
op_star
id|urb
op_assign
id|urbp-&gt;urb
suffix:semicolon
multiline_comment|/* Checks the status and does all of the magic necessary */
id|uhci_transfer_result
c_func
(paren
id|uhci
comma
id|urb
)paren
suffix:semicolon
)brace
id|uhci_finish_completion
c_func
(paren
id|hcd
comma
id|regs
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|uhci-&gt;schedule_lock
)paren
suffix:semicolon
multiline_comment|/* Wake up anyone waiting for an URB to complete */
id|wake_up_all
c_func
(paren
op_amp
id|uhci-&gt;waitqh
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
DECL|function|reset_hc
r_static
r_void
id|reset_hc
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
)paren
(brace
r_int
r_int
id|io_addr
op_assign
id|uhci-&gt;io_addr
suffix:semicolon
multiline_comment|/* Turn off PIRQ, SMI, and all interrupts.  This also turns off&n;&t; * the BIOS&squot;s USB Legacy Support.&n;&t; */
id|pci_write_config_word
c_func
(paren
id|to_pci_dev
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
)paren
comma
id|USBLEGSUP
comma
l_int|0
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|uhci-&gt;io_addr
op_plus
id|USBINTR
)paren
suffix:semicolon
multiline_comment|/* Global reset for 50ms */
id|uhci-&gt;state
op_assign
id|UHCI_RESET
suffix:semicolon
id|outw
c_func
(paren
id|USBCMD_GRESET
comma
id|io_addr
op_plus
id|USBCMD
)paren
suffix:semicolon
id|msleep
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|io_addr
op_plus
id|USBCMD
)paren
suffix:semicolon
multiline_comment|/* Another 10ms delay */
id|msleep
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|uhci-&gt;resume_detect
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|suspend_hc
r_static
r_void
id|suspend_hc
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
)paren
(brace
r_int
r_int
id|io_addr
op_assign
id|uhci-&gt;io_addr
suffix:semicolon
id|dev_dbg
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|uhci-&gt;state
op_assign
id|UHCI_SUSPENDED
suffix:semicolon
id|uhci-&gt;resume_detect
op_assign
l_int|0
suffix:semicolon
id|outw
c_func
(paren
id|USBCMD_EGSM
comma
id|io_addr
op_plus
id|USBCMD
)paren
suffix:semicolon
)brace
DECL|function|wakeup_hc
r_static
r_void
id|wakeup_hc
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
)paren
(brace
r_int
r_int
id|io_addr
op_assign
id|uhci-&gt;io_addr
suffix:semicolon
r_switch
c_cond
(paren
id|uhci-&gt;state
)paren
(brace
r_case
id|UHCI_SUSPENDED
suffix:colon
multiline_comment|/* Start the resume */
id|dev_dbg
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* Global resume for &gt;= 20ms */
id|outw
c_func
(paren
id|USBCMD_FGR
op_or
id|USBCMD_EGSM
comma
id|io_addr
op_plus
id|USBCMD
)paren
suffix:semicolon
id|uhci-&gt;state
op_assign
id|UHCI_RESUMING_1
suffix:semicolon
id|uhci-&gt;state_end
op_assign
id|jiffies
op_plus
id|msecs_to_jiffies
c_func
(paren
l_int|20
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UHCI_RESUMING_1
suffix:colon
multiline_comment|/* End global resume */
id|uhci-&gt;state
op_assign
id|UHCI_RESUMING_2
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|io_addr
op_plus
id|USBCMD
)paren
suffix:semicolon
multiline_comment|/* Falls through */
r_case
id|UHCI_RESUMING_2
suffix:colon
multiline_comment|/* Wait for EOP to be sent */
r_if
c_cond
(paren
id|inw
c_func
(paren
id|io_addr
op_plus
id|USBCMD
)paren
op_amp
id|USBCMD_FGR
)paren
r_break
suffix:semicolon
multiline_comment|/* Run for at least 1 second, and&n;&t;&t;&t; * mark it configured with a 64-byte max packet */
id|uhci-&gt;state
op_assign
id|UHCI_RUNNING_GRACE
suffix:semicolon
id|uhci-&gt;state_end
op_assign
id|jiffies
op_plus
id|HZ
suffix:semicolon
id|outw
c_func
(paren
id|USBCMD_RS
op_or
id|USBCMD_CF
op_or
id|USBCMD_MAXP
comma
id|io_addr
op_plus
id|USBCMD
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UHCI_RUNNING_GRACE
suffix:colon
multiline_comment|/* Now allowed to suspend */
id|uhci-&gt;state
op_assign
id|UHCI_RUNNING
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
DECL|function|ports_active
r_static
r_int
id|ports_active
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
)paren
(brace
r_int
r_int
id|io_addr
op_assign
id|uhci-&gt;io_addr
suffix:semicolon
r_int
id|connection
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|uhci-&gt;rh_numports
suffix:semicolon
id|i
op_increment
)paren
id|connection
op_or_assign
(paren
id|inw
c_func
(paren
id|io_addr
op_plus
id|USBPORTSC1
op_plus
id|i
op_star
l_int|2
)paren
op_amp
id|USBPORTSC_CCS
)paren
suffix:semicolon
r_return
id|connection
suffix:semicolon
)brace
DECL|function|suspend_allowed
r_static
r_int
id|suspend_allowed
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
)paren
(brace
r_int
r_int
id|io_addr
op_assign
id|uhci-&gt;io_addr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|to_pci_dev
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
)paren
op_member_access_from_pointer
id|vendor
op_ne
id|PCI_VENDOR_ID_INTEL
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Some of Intel&squot;s USB controllers have a bug that causes false&n;&t; * resume indications if any port has an over current condition.&n;&t; * To prevent problems, we will not allow a global suspend if&n;&t; * any ports are OC.&n;&t; *&n;&t; * Some motherboards using Intel&squot;s chipsets (but not using all&n;&t; * the USB ports) appear to hardwire the over current inputs active&n;&t; * to disable the USB ports.&n;&t; */
multiline_comment|/* check for over current condition on any port */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|uhci-&gt;rh_numports
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|inw
c_func
(paren
id|io_addr
op_plus
id|USBPORTSC1
op_plus
id|i
op_star
l_int|2
)paren
op_amp
id|USBPORTSC_OC
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|hc_state_transitions
r_static
r_void
id|hc_state_transitions
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
)paren
(brace
r_switch
c_cond
(paren
id|uhci-&gt;state
)paren
(brace
r_case
id|UHCI_RUNNING
suffix:colon
multiline_comment|/* global suspend if nothing connected for 1 second */
r_if
c_cond
(paren
op_logical_neg
id|ports_active
c_func
(paren
id|uhci
)paren
op_logical_and
id|suspend_allowed
c_func
(paren
id|uhci
)paren
)paren
(brace
id|uhci-&gt;state
op_assign
id|UHCI_SUSPENDING_GRACE
suffix:semicolon
id|uhci-&gt;state_end
op_assign
id|jiffies
op_plus
id|HZ
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|UHCI_SUSPENDING_GRACE
suffix:colon
r_if
c_cond
(paren
id|ports_active
c_func
(paren
id|uhci
)paren
)paren
id|uhci-&gt;state
op_assign
id|UHCI_RUNNING
suffix:semicolon
r_else
r_if
c_cond
(paren
id|time_after_eq
c_func
(paren
id|jiffies
comma
id|uhci-&gt;state_end
)paren
)paren
id|suspend_hc
c_func
(paren
id|uhci
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UHCI_SUSPENDED
suffix:colon
multiline_comment|/* wakeup if requested by a device */
r_if
c_cond
(paren
id|uhci-&gt;resume_detect
)paren
id|wakeup_hc
c_func
(paren
id|uhci
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UHCI_RESUMING_1
suffix:colon
r_case
id|UHCI_RESUMING_2
suffix:colon
r_case
id|UHCI_RUNNING_GRACE
suffix:colon
r_if
c_cond
(paren
id|time_after_eq
c_func
(paren
id|jiffies
comma
id|uhci-&gt;state_end
)paren
)paren
id|wakeup_hc
c_func
(paren
id|uhci
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
DECL|function|start_hc
r_static
r_int
id|start_hc
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
)paren
(brace
r_int
r_int
id|io_addr
op_assign
id|uhci-&gt;io_addr
suffix:semicolon
r_int
id|timeout
op_assign
l_int|10
suffix:semicolon
multiline_comment|/*&n;&t; * Reset the HC - this will force us to get a&n;&t; * new notification of any already connected&n;&t; * ports due to the virtual disconnect that it&n;&t; * implies.&n;&t; */
id|outw
c_func
(paren
id|USBCMD_HCRESET
comma
id|io_addr
op_plus
id|USBCMD
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inw
c_func
(paren
id|io_addr
op_plus
id|USBCMD
)paren
op_amp
id|USBCMD_HCRESET
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|timeout
OL
l_int|0
)paren
(brace
id|dev_err
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
comma
l_string|&quot;USBCMD_HCRESET timed out!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ETIMEDOUT
suffix:semicolon
)brace
id|msleep
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Turn on PIRQ and all interrupts */
id|pci_write_config_word
c_func
(paren
id|to_pci_dev
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
)paren
comma
id|USBLEGSUP
comma
id|USBLEGSUP_DEFAULT
)paren
suffix:semicolon
id|outw
c_func
(paren
id|USBINTR_TIMEOUT
op_or
id|USBINTR_RESUME
op_or
id|USBINTR_IOC
op_or
id|USBINTR_SP
comma
id|io_addr
op_plus
id|USBINTR
)paren
suffix:semicolon
multiline_comment|/* Start at frame 0 */
id|outw
c_func
(paren
l_int|0
comma
id|io_addr
op_plus
id|USBFRNUM
)paren
suffix:semicolon
id|outl
c_func
(paren
id|uhci-&gt;fl-&gt;dma_handle
comma
id|io_addr
op_plus
id|USBFLBASEADD
)paren
suffix:semicolon
multiline_comment|/* Run and mark it configured with a 64-byte max packet */
id|uhci-&gt;state
op_assign
id|UHCI_RUNNING_GRACE
suffix:semicolon
id|uhci-&gt;state_end
op_assign
id|jiffies
op_plus
id|HZ
suffix:semicolon
id|outw
c_func
(paren
id|USBCMD_RS
op_or
id|USBCMD_CF
op_or
id|USBCMD_MAXP
comma
id|io_addr
op_plus
id|USBCMD
)paren
suffix:semicolon
id|uhci_to_hcd
c_func
(paren
id|uhci
)paren
op_member_access_from_pointer
id|state
op_assign
id|USB_STATE_RUNNING
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * De-allocate all resources..&n; */
DECL|function|release_uhci
r_static
r_void
id|release_uhci
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|UHCI_NUM_SKELQH
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|uhci-&gt;skelqh
(braket
id|i
)braket
)paren
(brace
id|uhci_free_qh
c_func
(paren
id|uhci
comma
id|uhci-&gt;skelqh
(braket
id|i
)braket
)paren
suffix:semicolon
id|uhci-&gt;skelqh
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uhci-&gt;term_td
)paren
(brace
id|uhci_free_td
c_func
(paren
id|uhci
comma
id|uhci-&gt;term_td
)paren
suffix:semicolon
id|uhci-&gt;term_td
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uhci-&gt;qh_pool
)paren
(brace
id|dma_pool_destroy
c_func
(paren
id|uhci-&gt;qh_pool
)paren
suffix:semicolon
id|uhci-&gt;qh_pool
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uhci-&gt;td_pool
)paren
(brace
id|dma_pool_destroy
c_func
(paren
id|uhci-&gt;td_pool
)paren
suffix:semicolon
id|uhci-&gt;td_pool
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uhci-&gt;fl
)paren
(brace
id|dma_free_coherent
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
comma
r_sizeof
(paren
op_star
id|uhci-&gt;fl
)paren
comma
id|uhci-&gt;fl
comma
id|uhci-&gt;fl-&gt;dma_handle
)paren
suffix:semicolon
id|uhci-&gt;fl
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uhci-&gt;dentry
)paren
(brace
id|debugfs_remove
c_func
(paren
id|uhci-&gt;dentry
)paren
suffix:semicolon
id|uhci-&gt;dentry
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|uhci_reset
r_static
r_int
id|uhci_reset
c_func
(paren
r_struct
id|usb_hcd
op_star
id|hcd
)paren
(brace
r_struct
id|uhci_hcd
op_star
id|uhci
op_assign
id|hcd_to_uhci
c_func
(paren
id|hcd
)paren
suffix:semicolon
id|uhci-&gt;io_addr
op_assign
(paren
r_int
r_int
)paren
id|hcd-&gt;regs
suffix:semicolon
multiline_comment|/* Kick BIOS off this hardware and reset, so we won&squot;t get&n;&t; * interrupts from any previous setup.&n;&t; */
id|reset_hc
c_func
(paren
id|uhci
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate a frame list, and then setup the skeleton&n; *&n; * The hardware doesn&squot;t really know any difference&n; * in the queues, but the order does matter for the&n; * protocols higher up. The order is:&n; *&n; *  - any isochronous events handled before any&n; *    of the queues. We don&squot;t do that here, because&n; *    we&squot;ll create the actual TD entries on demand.&n; *  - The first queue is the interrupt queue.&n; *  - The second queue is the control queue, split into low- and full-speed&n; *  - The third queue is bulk queue.&n; *  - The fourth queue is the bandwidth reclamation queue, which loops back&n; *    to the full-speed control queue.&n; */
DECL|function|uhci_start
r_static
r_int
id|uhci_start
c_func
(paren
r_struct
id|usb_hcd
op_star
id|hcd
)paren
(brace
r_struct
id|uhci_hcd
op_star
id|uhci
op_assign
id|hcd_to_uhci
c_func
(paren
id|hcd
)paren
suffix:semicolon
r_int
id|retval
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_int
id|i
comma
id|port
suffix:semicolon
r_int
id|io_size
suffix:semicolon
id|dma_addr_t
id|dma_handle
suffix:semicolon
r_struct
id|usb_device
op_star
id|udev
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
id|io_size
op_assign
id|pci_resource_len
c_func
(paren
id|to_pci_dev
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
)paren
comma
id|hcd-&gt;region
)paren
suffix:semicolon
id|dentry
op_assign
id|debugfs_create_file
c_func
(paren
id|hcd-&gt;self.bus_name
comma
id|S_IFREG
op_or
id|S_IRUGO
op_or
id|S_IWUSR
comma
id|uhci_debugfs_root
comma
id|uhci
comma
op_amp
id|uhci_debug_operations
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
(brace
id|dev_err
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
comma
l_string|&quot;couldn&squot;t create uhci debugfs entry&bslash;n&quot;
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err_create_debug_entry
suffix:semicolon
)brace
id|uhci-&gt;dentry
op_assign
id|dentry
suffix:semicolon
id|uhci-&gt;fsbr
op_assign
l_int|0
suffix:semicolon
id|uhci-&gt;fsbrtimeout
op_assign
l_int|0
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|uhci-&gt;schedule_lock
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|uhci-&gt;qh_remove_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|uhci-&gt;td_remove_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|uhci-&gt;urb_remove_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|uhci-&gt;urb_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|uhci-&gt;complete_list
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|uhci-&gt;waitqh
)paren
suffix:semicolon
id|uhci-&gt;fl
op_assign
id|dma_alloc_coherent
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
comma
r_sizeof
(paren
op_star
id|uhci-&gt;fl
)paren
comma
op_amp
id|dma_handle
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|uhci-&gt;fl
)paren
(brace
id|dev_err
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
comma
l_string|&quot;unable to allocate &quot;
l_string|&quot;consistent memory for frame list&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err_alloc_fl
suffix:semicolon
)brace
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|uhci-&gt;fl
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|uhci-&gt;fl
)paren
)paren
suffix:semicolon
id|uhci-&gt;fl-&gt;dma_handle
op_assign
id|dma_handle
suffix:semicolon
id|uhci-&gt;td_pool
op_assign
id|dma_pool_create
c_func
(paren
l_string|&quot;uhci_td&quot;
comma
id|uhci_dev
c_func
(paren
id|uhci
)paren
comma
r_sizeof
(paren
r_struct
id|uhci_td
)paren
comma
l_int|16
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|uhci-&gt;td_pool
)paren
(brace
id|dev_err
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
comma
l_string|&quot;unable to create td dma_pool&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err_create_td_pool
suffix:semicolon
)brace
id|uhci-&gt;qh_pool
op_assign
id|dma_pool_create
c_func
(paren
l_string|&quot;uhci_qh&quot;
comma
id|uhci_dev
c_func
(paren
id|uhci
)paren
comma
r_sizeof
(paren
r_struct
id|uhci_qh
)paren
comma
l_int|16
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|uhci-&gt;qh_pool
)paren
(brace
id|dev_err
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
comma
l_string|&quot;unable to create qh dma_pool&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err_create_qh_pool
suffix:semicolon
)brace
multiline_comment|/* Initialize the root hub */
multiline_comment|/* UHCI specs says devices must have 2 ports, but goes on to say */
multiline_comment|/*  they may have more but give no way to determine how many they */
multiline_comment|/*  have. However, according to the UHCI spec, Bit 7 is always set */
multiline_comment|/*  to 1. So we try to use this to our advantage */
r_for
c_loop
(paren
id|port
op_assign
l_int|0
suffix:semicolon
id|port
OL
(paren
id|io_size
op_minus
l_int|0x10
)paren
op_div
l_int|2
suffix:semicolon
id|port
op_increment
)paren
(brace
r_int
r_int
id|portstatus
suffix:semicolon
id|portstatus
op_assign
id|inw
c_func
(paren
id|uhci-&gt;io_addr
op_plus
l_int|0x10
op_plus
(paren
id|port
op_star
l_int|2
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|portstatus
op_amp
l_int|0x0080
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|debug
)paren
id|dev_info
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
comma
l_string|&quot;detected %d ports&bslash;n&quot;
comma
id|port
)paren
suffix:semicolon
multiline_comment|/* This is experimental so anything less than 2 or greater than 8 is */
multiline_comment|/*  something weird and we&squot;ll ignore it */
r_if
c_cond
(paren
id|port
template_param
id|UHCI_RH_MAXCHILD
)paren
(brace
id|dev_info
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
comma
l_string|&quot;port count misdetected? &quot;
l_string|&quot;forcing to 2 ports&bslash;n&quot;
)paren
suffix:semicolon
id|port
op_assign
l_int|2
suffix:semicolon
)brace
id|uhci-&gt;rh_numports
op_assign
id|port
suffix:semicolon
id|udev
op_assign
id|usb_alloc_dev
c_func
(paren
l_int|NULL
comma
op_amp
id|hcd-&gt;self
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|udev
)paren
(brace
id|dev_err
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
comma
l_string|&quot;unable to allocate root hub&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err_alloc_root_hub
suffix:semicolon
)brace
id|uhci-&gt;term_td
op_assign
id|uhci_alloc_td
c_func
(paren
id|uhci
comma
id|udev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|uhci-&gt;term_td
)paren
(brace
id|dev_err
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
comma
l_string|&quot;unable to allocate terminating TD&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err_alloc_term_td
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|UHCI_NUM_SKELQH
suffix:semicolon
id|i
op_increment
)paren
(brace
id|uhci-&gt;skelqh
(braket
id|i
)braket
op_assign
id|uhci_alloc_qh
c_func
(paren
id|uhci
comma
id|udev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|uhci-&gt;skelqh
(braket
id|i
)braket
)paren
(brace
id|dev_err
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
comma
l_string|&quot;unable to allocate QH&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err_alloc_skelqh
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * 8 Interrupt queues; link all higher int queues to int1,&n;&t; * then link int1 to control and control to bulk&n;&t; */
id|uhci-&gt;skel_int128_qh-&gt;link
op_assign
id|uhci-&gt;skel_int64_qh-&gt;link
op_assign
id|uhci-&gt;skel_int32_qh-&gt;link
op_assign
id|uhci-&gt;skel_int16_qh-&gt;link
op_assign
id|uhci-&gt;skel_int8_qh-&gt;link
op_assign
id|uhci-&gt;skel_int4_qh-&gt;link
op_assign
id|uhci-&gt;skel_int2_qh-&gt;link
op_assign
id|cpu_to_le32
c_func
(paren
id|uhci-&gt;skel_int1_qh-&gt;dma_handle
)paren
op_or
id|UHCI_PTR_QH
suffix:semicolon
id|uhci-&gt;skel_int1_qh-&gt;link
op_assign
id|cpu_to_le32
c_func
(paren
id|uhci-&gt;skel_ls_control_qh-&gt;dma_handle
)paren
op_or
id|UHCI_PTR_QH
suffix:semicolon
id|uhci-&gt;skel_ls_control_qh-&gt;link
op_assign
id|cpu_to_le32
c_func
(paren
id|uhci-&gt;skel_fs_control_qh-&gt;dma_handle
)paren
op_or
id|UHCI_PTR_QH
suffix:semicolon
id|uhci-&gt;skel_fs_control_qh-&gt;link
op_assign
id|cpu_to_le32
c_func
(paren
id|uhci-&gt;skel_bulk_qh-&gt;dma_handle
)paren
op_or
id|UHCI_PTR_QH
suffix:semicolon
id|uhci-&gt;skel_bulk_qh-&gt;link
op_assign
id|cpu_to_le32
c_func
(paren
id|uhci-&gt;skel_term_qh-&gt;dma_handle
)paren
op_or
id|UHCI_PTR_QH
suffix:semicolon
multiline_comment|/* This dummy TD is to work around a bug in Intel PIIX controllers */
id|uhci_fill_td
c_func
(paren
id|uhci-&gt;term_td
comma
l_int|0
comma
(paren
id|UHCI_NULL_DATA_SIZE
op_lshift
l_int|21
)paren
op_or
(paren
l_int|0x7f
op_lshift
id|TD_TOKEN_DEVADDR_SHIFT
)paren
op_or
id|USB_PID_IN
comma
l_int|0
)paren
suffix:semicolon
id|uhci-&gt;term_td-&gt;link
op_assign
id|cpu_to_le32
c_func
(paren
id|uhci-&gt;term_td-&gt;dma_handle
)paren
suffix:semicolon
id|uhci-&gt;skel_term_qh-&gt;link
op_assign
id|UHCI_PTR_TERM
suffix:semicolon
id|uhci-&gt;skel_term_qh-&gt;element
op_assign
id|cpu_to_le32
c_func
(paren
id|uhci-&gt;term_td-&gt;dma_handle
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fill the frame list: make all entries point to the proper&n;&t; * interrupt queue.&n;&t; *&n;&t; * The interrupt queues will be interleaved as evenly as possible.&n;&t; * There&squot;s not much to be done about period-1 interrupts; they have&n;&t; * to occur in every frame.  But we can schedule period-2 interrupts&n;&t; * in odd-numbered frames, period-4 interrupts in frames congruent&n;&t; * to 2 (mod 4), and so on.  This way each frame only has two&n;&t; * interrupt QHs, which will help spread out bandwidth utilization.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|UHCI_NUMFRAMES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|irq
suffix:semicolon
multiline_comment|/*&n;&t;&t; * ffs (Find First bit Set) does exactly what we need:&n;&t;&t; * 1,3,5,...  =&gt; ffs = 0 =&gt; use skel_int2_qh = skelqh[6],&n;&t;&t; * 2,6,10,... =&gt; ffs = 1 =&gt; use skel_int4_qh = skelqh[5], etc.&n;&t;&t; * ffs &gt; 6 =&gt; not on any high-period queue, so use&n;&t;&t; *&t;skel_int1_qh = skelqh[7].&n;&t;&t; * Add UHCI_NUMFRAMES to insure at least one bit is set.&n;&t;&t; */
id|irq
op_assign
l_int|6
op_minus
(paren
r_int
)paren
id|__ffs
c_func
(paren
id|i
op_plus
id|UHCI_NUMFRAMES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
OL
l_int|0
)paren
id|irq
op_assign
l_int|7
suffix:semicolon
multiline_comment|/* Only place we don&squot;t use the frame list routines */
id|uhci-&gt;fl-&gt;frame
(braket
id|i
)braket
op_assign
id|UHCI_PTR_QH
op_or
id|cpu_to_le32
c_func
(paren
id|uhci-&gt;skelqh
(braket
id|irq
)braket
op_member_access_from_pointer
id|dma_handle
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Some architectures require a full mb() to enforce completion of&n;&t; * the memory writes above before the I/O transfers in start_hc().&n;&t; */
id|mb
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|start_hc
c_func
(paren
id|uhci
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|err_alloc_skelqh
suffix:semicolon
id|init_stall_timer
c_func
(paren
id|hcd
)paren
suffix:semicolon
id|udev-&gt;speed
op_assign
id|USB_SPEED_FULL
suffix:semicolon
r_if
c_cond
(paren
id|hcd_register_root
c_func
(paren
id|udev
comma
id|hcd
)paren
op_ne
l_int|0
)paren
(brace
id|dev_err
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
comma
l_string|&quot;unable to start root hub&bslash;n&quot;
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err_start_root_hub
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n; * error exits:&n; */
id|err_start_root_hub
suffix:colon
id|reset_hc
c_func
(paren
id|uhci
)paren
suffix:semicolon
id|del_timer_sync
c_func
(paren
op_amp
id|uhci-&gt;stall_timer
)paren
suffix:semicolon
id|err_alloc_skelqh
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|UHCI_NUM_SKELQH
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|uhci-&gt;skelqh
(braket
id|i
)braket
)paren
(brace
id|uhci_free_qh
c_func
(paren
id|uhci
comma
id|uhci-&gt;skelqh
(braket
id|i
)braket
)paren
suffix:semicolon
id|uhci-&gt;skelqh
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
id|uhci_free_td
c_func
(paren
id|uhci
comma
id|uhci-&gt;term_td
)paren
suffix:semicolon
id|uhci-&gt;term_td
op_assign
l_int|NULL
suffix:semicolon
id|err_alloc_term_td
suffix:colon
id|usb_put_dev
c_func
(paren
id|udev
)paren
suffix:semicolon
id|err_alloc_root_hub
suffix:colon
id|dma_pool_destroy
c_func
(paren
id|uhci-&gt;qh_pool
)paren
suffix:semicolon
id|uhci-&gt;qh_pool
op_assign
l_int|NULL
suffix:semicolon
id|err_create_qh_pool
suffix:colon
id|dma_pool_destroy
c_func
(paren
id|uhci-&gt;td_pool
)paren
suffix:semicolon
id|uhci-&gt;td_pool
op_assign
l_int|NULL
suffix:semicolon
id|err_create_td_pool
suffix:colon
id|dma_free_coherent
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
comma
r_sizeof
(paren
op_star
id|uhci-&gt;fl
)paren
comma
id|uhci-&gt;fl
comma
id|uhci-&gt;fl-&gt;dma_handle
)paren
suffix:semicolon
id|uhci-&gt;fl
op_assign
l_int|NULL
suffix:semicolon
id|err_alloc_fl
suffix:colon
id|debugfs_remove
c_func
(paren
id|uhci-&gt;dentry
)paren
suffix:semicolon
id|uhci-&gt;dentry
op_assign
l_int|NULL
suffix:semicolon
id|err_create_debug_entry
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|uhci_stop
r_static
r_void
id|uhci_stop
c_func
(paren
r_struct
id|usb_hcd
op_star
id|hcd
)paren
(brace
r_struct
id|uhci_hcd
op_star
id|uhci
op_assign
id|hcd_to_uhci
c_func
(paren
id|hcd
)paren
suffix:semicolon
id|del_timer_sync
c_func
(paren
op_amp
id|uhci-&gt;stall_timer
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * At this point, we&squot;re guaranteed that no new connects can be made&n;&t; * to this bus since there are no more parents&n;&t; */
id|reset_hc
c_func
(paren
id|uhci
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|uhci-&gt;schedule_lock
)paren
suffix:semicolon
id|uhci_free_pending_qhs
c_func
(paren
id|uhci
)paren
suffix:semicolon
id|uhci_free_pending_tds
c_func
(paren
id|uhci
)paren
suffix:semicolon
id|uhci_remove_pending_urbps
c_func
(paren
id|uhci
)paren
suffix:semicolon
id|uhci_finish_completion
c_func
(paren
id|hcd
comma
l_int|NULL
)paren
suffix:semicolon
id|uhci_free_pending_qhs
c_func
(paren
id|uhci
)paren
suffix:semicolon
id|uhci_free_pending_tds
c_func
(paren
id|uhci
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|uhci-&gt;schedule_lock
)paren
suffix:semicolon
multiline_comment|/* Wake up anyone waiting for an URB to complete */
id|wake_up_all
c_func
(paren
op_amp
id|uhci-&gt;waitqh
)paren
suffix:semicolon
id|release_uhci
c_func
(paren
id|uhci
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PM
DECL|function|uhci_suspend
r_static
r_int
id|uhci_suspend
c_func
(paren
r_struct
id|usb_hcd
op_star
id|hcd
comma
id|u32
id|state
)paren
(brace
r_struct
id|uhci_hcd
op_star
id|uhci
op_assign
id|hcd_to_uhci
c_func
(paren
id|hcd
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t try to suspend broken motherboards, reset instead */
r_if
c_cond
(paren
id|suspend_allowed
c_func
(paren
id|uhci
)paren
)paren
(brace
id|suspend_hc
c_func
(paren
id|uhci
)paren
suffix:semicolon
id|uhci-&gt;saved_framenumber
op_assign
id|inw
c_func
(paren
id|uhci-&gt;io_addr
op_plus
id|USBFRNUM
)paren
op_amp
l_int|0x3ff
suffix:semicolon
)brace
r_else
id|reset_hc
c_func
(paren
id|uhci
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|uhci_resume
r_static
r_int
id|uhci_resume
c_func
(paren
r_struct
id|usb_hcd
op_star
id|hcd
)paren
(brace
r_struct
id|uhci_hcd
op_star
id|uhci
op_assign
id|hcd_to_uhci
c_func
(paren
id|hcd
)paren
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|pci_set_master
c_func
(paren
id|to_pci_dev
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uhci-&gt;state
op_eq
id|UHCI_SUSPENDED
)paren
(brace
multiline_comment|/*&n;&t;&t; * Some systems don&squot;t maintain the UHCI register values&n;&t;&t; * during a PM suspend/resume cycle, so reinitialize&n;&t;&t; * the Frame Number, Framelist Base Address, Interrupt&n;&t;&t; * Enable, and Legacy Support registers.&n;&t;&t; */
id|pci_write_config_word
c_func
(paren
id|to_pci_dev
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
)paren
comma
id|USBLEGSUP
comma
l_int|0
)paren
suffix:semicolon
id|outw
c_func
(paren
id|uhci-&gt;saved_framenumber
comma
id|uhci-&gt;io_addr
op_plus
id|USBFRNUM
)paren
suffix:semicolon
id|outl
c_func
(paren
id|uhci-&gt;fl-&gt;dma_handle
comma
id|uhci-&gt;io_addr
op_plus
id|USBFLBASEADD
)paren
suffix:semicolon
id|outw
c_func
(paren
id|USBINTR_TIMEOUT
op_or
id|USBINTR_RESUME
op_or
id|USBINTR_IOC
op_or
id|USBINTR_SP
comma
id|uhci-&gt;io_addr
op_plus
id|USBINTR
)paren
suffix:semicolon
id|uhci-&gt;resume_detect
op_assign
l_int|1
suffix:semicolon
id|pci_write_config_word
c_func
(paren
id|to_pci_dev
c_func
(paren
id|uhci_dev
c_func
(paren
id|uhci
)paren
)paren
comma
id|USBLEGSUP
comma
id|USBLEGSUP_DEFAULT
)paren
suffix:semicolon
)brace
r_else
(brace
id|reset_hc
c_func
(paren
id|uhci
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|start_hc
c_func
(paren
id|uhci
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|rc
suffix:semicolon
)brace
id|hcd-&gt;state
op_assign
id|USB_STATE_RUNNING
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Wait until all the URBs for a particular device/endpoint are gone */
DECL|function|uhci_hcd_endpoint_disable
r_static
r_void
id|uhci_hcd_endpoint_disable
c_func
(paren
r_struct
id|usb_hcd
op_star
id|hcd
comma
r_struct
id|usb_host_endpoint
op_star
id|ep
)paren
(brace
r_struct
id|uhci_hcd
op_star
id|uhci
op_assign
id|hcd_to_uhci
c_func
(paren
id|hcd
)paren
suffix:semicolon
id|wait_event_interruptible
c_func
(paren
id|uhci-&gt;waitqh
comma
id|list_empty
c_func
(paren
op_amp
id|ep-&gt;urb_list
)paren
)paren
suffix:semicolon
)brace
DECL|function|uhci_hcd_get_frame_number
r_static
r_int
id|uhci_hcd_get_frame_number
c_func
(paren
r_struct
id|usb_hcd
op_star
id|hcd
)paren
(brace
r_return
id|uhci_get_current_frame_number
c_func
(paren
id|hcd_to_uhci
c_func
(paren
id|hcd
)paren
)paren
suffix:semicolon
)brace
DECL|variable|hcd_name
r_static
r_const
r_char
id|hcd_name
(braket
)braket
op_assign
l_string|&quot;uhci_hcd&quot;
suffix:semicolon
DECL|variable|uhci_driver
r_static
r_const
r_struct
id|hc_driver
id|uhci_driver
op_assign
(brace
dot
id|description
op_assign
id|hcd_name
comma
dot
id|product_desc
op_assign
l_string|&quot;UHCI Host Controller&quot;
comma
dot
id|hcd_priv_size
op_assign
r_sizeof
(paren
r_struct
id|uhci_hcd
)paren
comma
multiline_comment|/* Generic hardware linkage */
dot
id|irq
op_assign
id|uhci_irq
comma
dot
id|flags
op_assign
id|HCD_USB11
comma
multiline_comment|/* Basic lifecycle operations */
dot
id|reset
op_assign
id|uhci_reset
comma
dot
id|start
op_assign
id|uhci_start
comma
macro_line|#ifdef CONFIG_PM
dot
id|suspend
op_assign
id|uhci_suspend
comma
dot
id|resume
op_assign
id|uhci_resume
comma
macro_line|#endif
dot
id|stop
op_assign
id|uhci_stop
comma
dot
id|urb_enqueue
op_assign
id|uhci_urb_enqueue
comma
dot
id|urb_dequeue
op_assign
id|uhci_urb_dequeue
comma
dot
id|endpoint_disable
op_assign
id|uhci_hcd_endpoint_disable
comma
dot
id|get_frame_number
op_assign
id|uhci_hcd_get_frame_number
comma
dot
id|hub_status_data
op_assign
id|uhci_hub_status_data
comma
dot
id|hub_control
op_assign
id|uhci_hub_control
comma
)brace
suffix:semicolon
DECL|variable|uhci_pci_ids
r_static
r_const
r_struct
id|pci_device_id
id|uhci_pci_ids
(braket
)braket
op_assign
(brace
(brace
multiline_comment|/* handle any USB UHCI controller */
id|PCI_DEVICE_CLASS
c_func
(paren
(paren
(paren
id|PCI_CLASS_SERIAL_USB
op_lshift
l_int|8
)paren
op_or
l_int|0x00
)paren
comma
op_complement
l_int|0
)paren
comma
dot
id|driver_data
op_assign
(paren
r_int
r_int
)paren
op_amp
id|uhci_driver
comma
)brace
comma
(brace
multiline_comment|/* end: all zeroes */
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
c_func
(paren
id|pci
comma
id|uhci_pci_ids
)paren
suffix:semicolon
DECL|variable|uhci_pci_driver
r_static
r_struct
id|pci_driver
id|uhci_pci_driver
op_assign
(brace
dot
id|name
op_assign
(paren
r_char
op_star
)paren
id|hcd_name
comma
dot
id|id_table
op_assign
id|uhci_pci_ids
comma
dot
id|probe
op_assign
id|usb_hcd_pci_probe
comma
dot
id|remove
op_assign
id|usb_hcd_pci_remove
comma
macro_line|#ifdef&t;CONFIG_PM
dot
id|suspend
op_assign
id|usb_hcd_pci_suspend
comma
dot
id|resume
op_assign
id|usb_hcd_pci_resume
comma
macro_line|#endif&t;/* PM */
)brace
suffix:semicolon
DECL|function|uhci_hcd_init
r_static
r_int
id|__init
id|uhci_hcd_init
c_func
(paren
r_void
)paren
(brace
r_int
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|DRIVER_DESC
l_string|&quot; &quot;
id|DRIVER_VERSION
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_disabled
c_func
(paren
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
(brace
id|errbuf
op_assign
id|kmalloc
c_func
(paren
id|ERRBUF_LEN
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|errbuf
)paren
r_goto
id|errbuf_failed
suffix:semicolon
)brace
id|uhci_debugfs_root
op_assign
id|debugfs_create_dir
c_func
(paren
l_string|&quot;uhci&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|uhci_debugfs_root
)paren
r_goto
id|debug_failed
suffix:semicolon
id|uhci_up_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;uhci_urb_priv&quot;
comma
r_sizeof
(paren
r_struct
id|urb_priv
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|uhci_up_cachep
)paren
r_goto
id|up_failed
suffix:semicolon
id|retval
op_assign
id|pci_register_driver
c_func
(paren
op_amp
id|uhci_pci_driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|init_failed
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|init_failed
suffix:colon
r_if
c_cond
(paren
id|kmem_cache_destroy
c_func
(paren
id|uhci_up_cachep
)paren
)paren
id|warn
c_func
(paren
l_string|&quot;not all urb_priv&squot;s were freed!&quot;
)paren
suffix:semicolon
id|up_failed
suffix:colon
id|debugfs_remove
c_func
(paren
id|uhci_debugfs_root
)paren
suffix:semicolon
id|debug_failed
suffix:colon
r_if
c_cond
(paren
id|errbuf
)paren
id|kfree
c_func
(paren
id|errbuf
)paren
suffix:semicolon
id|errbuf_failed
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|uhci_hcd_cleanup
r_static
r_void
id|__exit
id|uhci_hcd_cleanup
c_func
(paren
r_void
)paren
(brace
id|pci_unregister_driver
c_func
(paren
op_amp
id|uhci_pci_driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kmem_cache_destroy
c_func
(paren
id|uhci_up_cachep
)paren
)paren
id|warn
c_func
(paren
l_string|&quot;not all urb_priv&squot;s were freed!&quot;
)paren
suffix:semicolon
id|debugfs_remove
c_func
(paren
id|uhci_debugfs_root
)paren
suffix:semicolon
r_if
c_cond
(paren
id|errbuf
)paren
id|kfree
c_func
(paren
id|errbuf
)paren
suffix:semicolon
)brace
DECL|variable|uhci_hcd_init
id|module_init
c_func
(paren
id|uhci_hcd_init
)paren
suffix:semicolon
DECL|variable|uhci_hcd_cleanup
id|module_exit
c_func
(paren
id|uhci_hcd_cleanup
)paren
suffix:semicolon
DECL|variable|DRIVER_AUTHOR
id|MODULE_AUTHOR
c_func
(paren
id|DRIVER_AUTHOR
)paren
suffix:semicolon
DECL|variable|DRIVER_DESC
id|MODULE_DESCRIPTION
c_func
(paren
id|DRIVER_DESC
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
