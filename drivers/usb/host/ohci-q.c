multiline_comment|/*&n; * OHCI HCD (Host Controller Driver) for USB.&n; * &n; * (C) Copyright 1999 Roman Weissgaerber &lt;weissg@vienna.at&gt;&n; * (C) Copyright 2000-2002 David Brownell &lt;dbrownell@users.sourceforge.net&gt;&n; * &n; * This file is licenced under the GPL.&n; * $Id: ohci-q.c,v 1.8 2002/03/27 20:57:01 dbrownell Exp $&n; */
DECL|function|urb_free_priv
r_static
r_void
id|urb_free_priv
(paren
r_struct
id|ohci_hcd
op_star
id|hc
comma
id|urb_priv_t
op_star
id|urb_priv
)paren
(brace
r_int
id|last
op_assign
id|urb_priv-&gt;length
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|last
op_ge
l_int|0
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|td
op_star
id|td
op_assign
id|urb_priv-&gt;td
(braket
l_int|0
)braket
suffix:semicolon
r_int
id|len
op_assign
id|td-&gt;urb-&gt;transfer_buffer_length
suffix:semicolon
r_int
id|dir
op_assign
id|usb_pipeout
(paren
id|td-&gt;urb-&gt;pipe
)paren
ques
c_cond
id|PCI_DMA_TODEVICE
suffix:colon
id|PCI_DMA_FROMDEVICE
suffix:semicolon
multiline_comment|/* unmap CTRL URB setup buffer (always td 0) */
r_if
c_cond
(paren
id|usb_pipecontrol
(paren
id|td-&gt;urb-&gt;pipe
)paren
)paren
(brace
id|pci_unmap_single
(paren
id|hc-&gt;hcd.pdev
comma
id|td-&gt;data_dma
comma
l_int|8
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
multiline_comment|/* CTRL data buffer starts at td 1 if len &gt; 0 */
r_if
c_cond
(paren
id|len
op_logical_and
id|last
OG
l_int|0
)paren
id|td
op_assign
id|urb_priv-&gt;td
(braket
l_int|1
)braket
suffix:semicolon
)brace
multiline_comment|/* else:  ISOC, BULK, INTR data buffer starts at td 0 */
multiline_comment|/* unmap data buffer */
r_if
c_cond
(paren
id|len
op_logical_and
id|td-&gt;data_dma
)paren
id|pci_unmap_single
(paren
id|hc-&gt;hcd.pdev
comma
id|td-&gt;data_dma
comma
id|len
comma
id|dir
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|last
suffix:semicolon
id|i
op_increment
)paren
(brace
id|td
op_assign
id|urb_priv-&gt;td
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|td
)paren
id|td_free
(paren
id|hc
comma
id|td
)paren
suffix:semicolon
)brace
)brace
id|kfree
(paren
id|urb_priv
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * URB goes back to driver, and isn&squot;t reissued.&n; * It&squot;s completely gone from HC data structures.&n; * PRECONDITION:  no locks held  (Giveback can call into HCD.)&n; */
DECL|function|finish_urb
r_static
r_void
id|finish_urb
(paren
r_struct
id|ohci_hcd
op_star
id|ohci
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
op_logical_neg
id|urb-&gt;hcpriv
)paren
(brace
id|err
(paren
l_string|&quot;already unlinked!&quot;
)paren
suffix:semicolon
id|BUG
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|urb_free_priv
(paren
id|ohci
comma
id|urb-&gt;hcpriv
)paren
suffix:semicolon
id|urb-&gt;hcpriv
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|urb-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
(paren
id|urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
)paren
id|urb-&gt;status
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|urb-&gt;lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef OHCI_VERBOSE_DEBUG
id|urb_print
(paren
id|urb
comma
l_string|&quot;RET&quot;
comma
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
macro_line|#endif
id|usb_hcd_giveback_urb
(paren
op_amp
id|ohci-&gt;hcd
comma
id|urb
)paren
suffix:semicolon
)brace
r_static
r_void
id|td_submit_urb
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
multiline_comment|/* Report interrupt transfer completion, maybe reissue */
DECL|function|intr_resub
r_static
r_void
id|intr_resub
(paren
r_struct
id|ohci_hcd
op_star
id|hc
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
id|urb_priv_t
op_star
id|urb_priv
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
singleline_comment|// FIXME rewrite this resubmit path.  use pci_dma_sync_single()
singleline_comment|// and requeue more cheaply, and only if needed.
singleline_comment|// Better yet ... abolish the notion of automagic resubmission.
id|pci_unmap_single
(paren
id|hc-&gt;hcd.pdev
comma
id|urb_priv-&gt;td
(braket
l_int|0
)braket
op_member_access_from_pointer
id|data_dma
comma
id|urb-&gt;transfer_buffer_length
comma
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
ques
c_cond
id|PCI_DMA_TODEVICE
suffix:colon
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
multiline_comment|/* FIXME: MP race.  If another CPU partially unlinks&n;&t; * this URB (urb-&gt;status was updated, hasn&squot;t yet told&n;&t; * us to dequeue) before we call complete() here, an&n;&t; * extra &quot;unlinked&quot; completion will be reported...&n;&t; */
id|spin_lock_irqsave
(paren
op_amp
id|urb-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
(paren
id|urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
)paren
id|urb-&gt;status
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|urb-&gt;lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef OHCI_VERBOSE_DEBUG
id|urb_print
(paren
id|urb
comma
l_string|&quot;INTR&quot;
comma
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
macro_line|#endif
id|urb-&gt;complete
(paren
id|urb
)paren
suffix:semicolon
multiline_comment|/* always requeued, but ED_SKIP if complete() unlinks.&n;&t; * EDs are removed from periodic table only at SOF intr.&n;&t; */
id|urb-&gt;actual_length
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|urb-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb_priv-&gt;state
op_ne
id|URB_DEL
)paren
id|urb-&gt;status
op_assign
op_minus
id|EINPROGRESS
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|urb-&gt;lock
)paren
suffix:semicolon
id|spin_lock
(paren
op_amp
id|hc-&gt;lock
)paren
suffix:semicolon
id|td_submit_urb
(paren
id|urb
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|hc-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*&n; * ED handling functions&n; *-------------------------------------------------------------------------*/
multiline_comment|/* search for the right branch to insert an interrupt ed into the int tree &n; * do some load balancing;&n; * returns the branch&n; * FIXME allow for failure, when there&squot;s no bandwidth left;&n; * and consider iso loads too&n; */
DECL|function|ep_int_balance
r_static
r_int
id|ep_int_balance
(paren
r_struct
id|ohci_hcd
op_star
id|ohci
comma
r_int
id|interval
comma
r_int
id|load
)paren
(brace
r_int
id|i
comma
id|branch
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* search for the least loaded interrupt endpoint branch */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_INTS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|ohci-&gt;ohci_int_load
(braket
id|branch
)braket
OG
id|ohci-&gt;ohci_int_load
(braket
id|i
)braket
)paren
id|branch
op_assign
id|i
suffix:semicolon
id|branch
op_assign
id|branch
op_mod
id|interval
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|branch
suffix:semicolon
id|i
OL
id|NUM_INTS
suffix:semicolon
id|i
op_add_assign
id|interval
)paren
id|ohci-&gt;ohci_int_load
(braket
id|i
)braket
op_add_assign
id|load
suffix:semicolon
r_return
id|branch
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* the int tree is a binary tree &n; * in order to process it sequentially the indexes of the branches have&n; * to be mapped the mapping reverses the bits of a word of num_bits length&n; */
DECL|function|ep_rev
r_static
r_int
id|ep_rev
(paren
r_int
id|num_bits
comma
r_int
id|word
)paren
(brace
r_int
id|i
comma
id|wout
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_bits
suffix:semicolon
id|i
op_increment
)paren
id|wout
op_or_assign
(paren
(paren
(paren
id|word
op_rshift
id|i
)paren
op_amp
l_int|1
)paren
op_lshift
(paren
id|num_bits
op_minus
id|i
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_return
id|wout
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* link an ed into one of the HC chains */
DECL|function|ep_link
r_static
r_int
id|ep_link
(paren
r_struct
id|ohci_hcd
op_star
id|ohci
comma
r_struct
id|ed
op_star
id|edi
)paren
(brace
r_int
id|int_branch
comma
id|i
suffix:semicolon
r_int
id|inter
comma
id|interval
comma
id|load
suffix:semicolon
id|__u32
op_star
id|ed_p
suffix:semicolon
r_volatile
r_struct
id|ed
op_star
id|ed
op_assign
id|edi
suffix:semicolon
id|ed-&gt;state
op_assign
id|ED_OPER
suffix:semicolon
r_switch
c_cond
(paren
id|ed-&gt;type
)paren
(brace
r_case
id|PIPE_CONTROL
suffix:colon
id|ed-&gt;hwNextED
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ohci-&gt;ed_controltail
op_eq
l_int|NULL
)paren
(brace
id|writel
(paren
id|ed-&gt;dma
comma
op_amp
id|ohci-&gt;regs-&gt;ed_controlhead
)paren
suffix:semicolon
)brace
r_else
(brace
id|ohci-&gt;ed_controltail-&gt;hwNextED
op_assign
id|cpu_to_le32
(paren
id|ed-&gt;dma
)paren
suffix:semicolon
)brace
id|ed-&gt;ed_prev
op_assign
id|ohci-&gt;ed_controltail
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ohci-&gt;ed_controltail
op_logical_and
op_logical_neg
id|ohci-&gt;ed_rm_list
op_logical_and
op_logical_neg
id|ohci-&gt;sleeping
)paren
(brace
id|ohci-&gt;hc_control
op_or_assign
id|OHCI_CTRL_CLE
suffix:semicolon
id|writel
(paren
id|ohci-&gt;hc_control
comma
op_amp
id|ohci-&gt;regs-&gt;control
)paren
suffix:semicolon
)brace
id|ohci-&gt;ed_controltail
op_assign
id|edi
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_BULK
suffix:colon
id|ed-&gt;hwNextED
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ohci-&gt;ed_bulktail
op_eq
l_int|NULL
)paren
(brace
id|writel
(paren
id|ed-&gt;dma
comma
op_amp
id|ohci-&gt;regs-&gt;ed_bulkhead
)paren
suffix:semicolon
)brace
r_else
(brace
id|ohci-&gt;ed_bulktail-&gt;hwNextED
op_assign
id|cpu_to_le32
(paren
id|ed-&gt;dma
)paren
suffix:semicolon
)brace
id|ed-&gt;ed_prev
op_assign
id|ohci-&gt;ed_bulktail
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ohci-&gt;ed_bulktail
op_logical_and
op_logical_neg
id|ohci-&gt;ed_rm_list
op_logical_and
op_logical_neg
id|ohci-&gt;sleeping
)paren
(brace
id|ohci-&gt;hc_control
op_or_assign
id|OHCI_CTRL_BLE
suffix:semicolon
id|writel
(paren
id|ohci-&gt;hc_control
comma
op_amp
id|ohci-&gt;regs-&gt;control
)paren
suffix:semicolon
)brace
id|ohci-&gt;ed_bulktail
op_assign
id|edi
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_INTERRUPT
suffix:colon
id|load
op_assign
id|ed-&gt;intriso.intr_info.int_load
suffix:semicolon
id|interval
op_assign
id|ed-&gt;interval
suffix:semicolon
id|int_branch
op_assign
id|ep_int_balance
(paren
id|ohci
comma
id|interval
comma
id|load
)paren
suffix:semicolon
id|ed-&gt;intriso.intr_info.int_branch
op_assign
id|int_branch
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ep_rev
(paren
l_int|6
comma
id|interval
)paren
suffix:semicolon
id|i
op_add_assign
id|inter
)paren
(brace
id|inter
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|ed_p
op_assign
op_amp
(paren
id|ohci-&gt;hcca-&gt;int_table
(braket
id|ep_rev
(paren
l_int|5
comma
id|i
)paren
op_plus
id|int_branch
)braket
)paren
suffix:semicolon
(paren
op_star
id|ed_p
op_ne
l_int|0
)paren
op_logical_and
(paren
(paren
id|dma_to_ed
(paren
id|ohci
comma
id|le32_to_cpup
(paren
id|ed_p
)paren
)paren
)paren
op_member_access_from_pointer
id|interval
op_ge
id|interval
)paren
suffix:semicolon
id|ed_p
op_assign
op_amp
(paren
(paren
id|dma_to_ed
(paren
id|ohci
comma
id|le32_to_cpup
(paren
id|ed_p
)paren
)paren
)paren
op_member_access_from_pointer
id|hwNextED
)paren
)paren
id|inter
op_assign
id|ep_rev
(paren
l_int|6
comma
(paren
id|dma_to_ed
(paren
id|ohci
comma
id|le32_to_cpup
(paren
id|ed_p
)paren
)paren
)paren
op_member_access_from_pointer
id|interval
)paren
suffix:semicolon
id|ed-&gt;hwNextED
op_assign
op_star
id|ed_p
suffix:semicolon
op_star
id|ed_p
op_assign
id|cpu_to_le32
(paren
id|ed-&gt;dma
)paren
suffix:semicolon
)brace
macro_line|#ifdef OHCI_VERBOSE_DEBUG
id|ohci_dump_periodic
(paren
id|ohci
comma
l_string|&quot;LINK_INT&quot;
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|PIPE_ISOCHRONOUS
suffix:colon
id|ed-&gt;hwNextED
op_assign
l_int|0
suffix:semicolon
id|ed-&gt;interval
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ohci-&gt;ed_isotail
op_ne
l_int|NULL
)paren
(brace
id|ohci-&gt;ed_isotail-&gt;hwNextED
op_assign
id|cpu_to_le32
(paren
id|ed-&gt;dma
)paren
suffix:semicolon
id|ed-&gt;ed_prev
op_assign
id|ohci-&gt;ed_isotail
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_INTS
suffix:semicolon
id|i
op_add_assign
id|inter
)paren
(brace
id|inter
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|ed_p
op_assign
op_amp
(paren
id|ohci-&gt;hcca-&gt;int_table
(braket
id|ep_rev
(paren
l_int|5
comma
id|i
)paren
)braket
)paren
suffix:semicolon
op_star
id|ed_p
op_ne
l_int|0
suffix:semicolon
id|ed_p
op_assign
op_amp
(paren
(paren
id|dma_to_ed
(paren
id|ohci
comma
id|le32_to_cpup
(paren
id|ed_p
)paren
)paren
)paren
op_member_access_from_pointer
id|hwNextED
)paren
)paren
id|inter
op_assign
id|ep_rev
(paren
l_int|6
comma
(paren
id|dma_to_ed
(paren
id|ohci
comma
id|le32_to_cpup
(paren
id|ed_p
)paren
)paren
)paren
op_member_access_from_pointer
id|interval
)paren
suffix:semicolon
op_star
id|ed_p
op_assign
id|cpu_to_le32
(paren
id|ed-&gt;dma
)paren
suffix:semicolon
)brace
id|ed-&gt;ed_prev
op_assign
l_int|NULL
suffix:semicolon
)brace
id|ohci-&gt;ed_isotail
op_assign
id|edi
suffix:semicolon
macro_line|#ifdef OHCI_VERBOSE_DEBUG
id|ohci_dump_periodic
(paren
id|ohci
comma
l_string|&quot;LINK_ISO&quot;
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* scan the periodic table to find and unlink this ED */
DECL|function|periodic_unlink
r_static
r_void
id|periodic_unlink
(paren
r_struct
id|ohci_hcd
op_star
id|ohci
comma
r_struct
id|ed
op_star
id|ed
comma
r_int
id|index
comma
r_int
id|period
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|index
OL
id|NUM_INTS
suffix:semicolon
id|index
op_add_assign
id|period
)paren
(brace
id|__u32
op_star
id|ed_p
op_assign
op_amp
id|ohci-&gt;hcca-&gt;int_table
(braket
id|index
)braket
suffix:semicolon
r_while
c_loop
(paren
op_star
id|ed_p
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|dma_to_ed
(paren
id|ohci
comma
id|le32_to_cpup
(paren
id|ed_p
)paren
)paren
)paren
op_eq
id|ed
)paren
(brace
op_star
id|ed_p
op_assign
id|ed-&gt;hwNextED
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ed_p
op_assign
op_amp
(paren
(paren
id|dma_to_ed
(paren
id|ohci
comma
id|le32_to_cpup
(paren
id|ed_p
)paren
)paren
)paren
op_member_access_from_pointer
id|hwNextED
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* unlink an ed from one of the HC chains. &n; * just the link to the ed is unlinked.&n; * the link from the ed still points to another operational ed or 0&n; * so the HC can eventually finish the processing of the unlinked ed&n; * caller guarantees the ED has no active TDs.&n; */
DECL|function|start_ed_unlink
r_static
r_int
id|start_ed_unlink
(paren
r_struct
id|ohci_hcd
op_star
id|ohci
comma
r_struct
id|ed
op_star
id|ed
)paren
(brace
r_int
id|i
suffix:semicolon
id|ed-&gt;hwINFO
op_or_assign
id|ED_SKIP
suffix:semicolon
r_switch
c_cond
(paren
id|ed-&gt;type
)paren
(brace
r_case
id|PIPE_CONTROL
suffix:colon
r_if
c_cond
(paren
id|ed-&gt;ed_prev
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ed-&gt;hwNextED
)paren
(brace
id|ohci-&gt;hc_control
op_and_assign
op_complement
id|OHCI_CTRL_CLE
suffix:semicolon
id|writel
(paren
id|ohci-&gt;hc_control
comma
op_amp
id|ohci-&gt;regs-&gt;control
)paren
suffix:semicolon
)brace
id|writel
(paren
id|le32_to_cpup
(paren
op_amp
id|ed-&gt;hwNextED
)paren
comma
op_amp
id|ohci-&gt;regs-&gt;ed_controlhead
)paren
suffix:semicolon
)brace
r_else
(brace
id|ed-&gt;ed_prev-&gt;hwNextED
op_assign
id|ed-&gt;hwNextED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ohci-&gt;ed_controltail
op_eq
id|ed
)paren
(brace
id|ohci-&gt;ed_controltail
op_assign
id|ed-&gt;ed_prev
suffix:semicolon
)brace
r_else
(brace
(paren
id|dma_to_ed
(paren
id|ohci
comma
id|le32_to_cpup
(paren
op_amp
id|ed-&gt;hwNextED
)paren
)paren
)paren
op_member_access_from_pointer
id|ed_prev
op_assign
id|ed-&gt;ed_prev
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|PIPE_BULK
suffix:colon
r_if
c_cond
(paren
id|ed-&gt;ed_prev
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ed-&gt;hwNextED
)paren
(brace
id|ohci-&gt;hc_control
op_and_assign
op_complement
id|OHCI_CTRL_BLE
suffix:semicolon
id|writel
(paren
id|ohci-&gt;hc_control
comma
op_amp
id|ohci-&gt;regs-&gt;control
)paren
suffix:semicolon
)brace
id|writel
(paren
id|le32_to_cpup
(paren
op_amp
id|ed-&gt;hwNextED
)paren
comma
op_amp
id|ohci-&gt;regs-&gt;ed_bulkhead
)paren
suffix:semicolon
)brace
r_else
(brace
id|ed-&gt;ed_prev-&gt;hwNextED
op_assign
id|ed-&gt;hwNextED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ohci-&gt;ed_bulktail
op_eq
id|ed
)paren
(brace
id|ohci-&gt;ed_bulktail
op_assign
id|ed-&gt;ed_prev
suffix:semicolon
)brace
r_else
(brace
(paren
id|dma_to_ed
(paren
id|ohci
comma
id|le32_to_cpup
(paren
op_amp
id|ed-&gt;hwNextED
)paren
)paren
)paren
op_member_access_from_pointer
id|ed_prev
op_assign
id|ed-&gt;ed_prev
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|PIPE_INTERRUPT
suffix:colon
id|periodic_unlink
(paren
id|ohci
comma
id|ed
comma
id|ed-&gt;intriso.intr_info.int_branch
comma
id|ed-&gt;interval
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|ed-&gt;intriso.intr_info.int_branch
suffix:semicolon
id|i
OL
id|NUM_INTS
suffix:semicolon
id|i
op_add_assign
id|ed-&gt;interval
)paren
id|ohci-&gt;ohci_int_load
(braket
id|i
)braket
op_sub_assign
id|ed-&gt;intriso.intr_info.int_load
suffix:semicolon
macro_line|#ifdef OHCI_VERBOSE_DEBUG
id|ohci_dump_periodic
(paren
id|ohci
comma
l_string|&quot;UNLINK_INT&quot;
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|PIPE_ISOCHRONOUS
suffix:colon
r_if
c_cond
(paren
id|ohci-&gt;ed_isotail
op_eq
id|ed
)paren
id|ohci-&gt;ed_isotail
op_assign
id|ed-&gt;ed_prev
suffix:semicolon
r_if
c_cond
(paren
id|ed-&gt;hwNextED
op_ne
l_int|0
)paren
(paren
id|dma_to_ed
(paren
id|ohci
comma
id|le32_to_cpup
(paren
op_amp
id|ed-&gt;hwNextED
)paren
)paren
)paren
op_member_access_from_pointer
id|ed_prev
op_assign
id|ed-&gt;ed_prev
suffix:semicolon
r_if
c_cond
(paren
id|ed-&gt;ed_prev
op_ne
l_int|NULL
)paren
id|ed-&gt;ed_prev-&gt;hwNextED
op_assign
id|ed-&gt;hwNextED
suffix:semicolon
r_else
id|periodic_unlink
(paren
id|ohci
comma
id|ed
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
macro_line|#ifdef OHCI_VERBOSE_DEBUG
id|ohci_dump_periodic
(paren
id|ohci
comma
l_string|&quot;UNLINK_ISO&quot;
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
multiline_comment|/* FIXME ED&squot;s &quot;unlink&quot; state is indeterminate;&n;&t; * the HC might still be caching it (till SOF).&n;&t; * - use ed_rm_list and finish_unlinks(), adding some state that&n;&t; *   prevents clobbering hw linkage before the appropriate SOF&n;&t; * - a speedup:  when only one urb is queued on the ed, save 1msec&n;&t; *   by making start_urb_unlink() use this routine to deschedule.&n;&t; */
id|ed-&gt;state
op_assign
id|ED_UNLINK
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* get and maybe (re)init an endpoint. init _should_ be done only as part&n; * of usb_set_configuration() or usb_set_interface() ... but the USB stack&n; * isn&squot;t very stateful, so we re-init whenever the HC isn&squot;t looking.&n; */
DECL|function|ed_get
r_static
r_struct
id|ed
op_star
id|ed_get
(paren
r_struct
id|ohci_hcd
op_star
id|ohci
comma
r_struct
id|usb_device
op_star
id|udev
comma
r_int
r_int
id|pipe
comma
r_int
id|interval
)paren
(brace
r_int
id|is_out
op_assign
op_logical_neg
id|usb_pipein
(paren
id|pipe
)paren
suffix:semicolon
r_int
id|type
op_assign
id|usb_pipetype
(paren
id|pipe
)paren
suffix:semicolon
r_int
id|bus_msecs
op_assign
l_int|0
suffix:semicolon
r_struct
id|hcd_dev
op_star
id|dev
op_assign
(paren
r_struct
id|hcd_dev
op_star
)paren
id|udev-&gt;hcpriv
suffix:semicolon
r_struct
id|ed
op_star
id|ed
suffix:semicolon
r_int
id|ep
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|ep
op_assign
id|usb_pipeendpoint
(paren
id|pipe
)paren
op_lshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|PIPE_CONTROL
op_logical_and
id|is_out
)paren
id|ep
op_or_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|PIPE_INTERRUPT
)paren
id|bus_msecs
op_assign
id|usb_calc_bus_time
(paren
id|udev-&gt;speed
comma
op_logical_neg
id|is_out
comma
l_int|0
comma
id|usb_maxpacket
(paren
id|udev
comma
id|pipe
comma
id|is_out
)paren
)paren
op_div
l_int|1000
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ohci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ed
op_assign
id|dev-&gt;ep
(braket
id|ep
)braket
)paren
)paren
(brace
id|ed
op_assign
id|ed_alloc
(paren
id|ohci
comma
id|SLAB_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ed
)paren
(brace
multiline_comment|/* out of memory */
r_goto
id|done
suffix:semicolon
)brace
id|dev-&gt;ep
(braket
id|ep
)braket
op_assign
id|ed
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ed-&gt;state
op_amp
id|ED_URB_DEL
)paren
(brace
multiline_comment|/* pending unlink request */
id|ed
op_assign
l_int|0
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ed-&gt;state
op_eq
id|ED_NEW
)paren
(brace
r_struct
id|td
op_star
id|td
suffix:semicolon
id|ed-&gt;hwINFO
op_assign
id|ED_SKIP
suffix:semicolon
multiline_comment|/* dummy td; end of td list for ed */
id|td
op_assign
id|td_alloc
(paren
id|ohci
comma
id|SLAB_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|td
)paren
(brace
multiline_comment|/* out of memory */
id|ed
op_assign
l_int|0
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|ed-&gt;dummy
op_assign
id|td
suffix:semicolon
id|ed-&gt;hwTailP
op_assign
id|cpu_to_le32
(paren
id|td-&gt;td_dma
)paren
suffix:semicolon
id|ed-&gt;hwHeadP
op_assign
id|ed-&gt;hwTailP
suffix:semicolon
multiline_comment|/* ED_C, ED_H zeroed */
id|ed-&gt;state
op_assign
id|ED_UNLINK
suffix:semicolon
id|ed-&gt;type
op_assign
id|type
suffix:semicolon
)brace
multiline_comment|/* FIXME:  Don&squot;t do this without knowing it&squot;s safe to clobber this&n;&t; * state/mode info.  Currently the upper layers don&squot;t support such&n;&t; * guarantees; we&squot;re lucky changing config/altsetting is rare.&n;&t; */
r_if
c_cond
(paren
id|ed-&gt;state
op_eq
id|ED_UNLINK
)paren
(brace
id|u32
id|info
suffix:semicolon
id|info
op_assign
id|usb_pipedevice
(paren
id|pipe
)paren
suffix:semicolon
id|info
op_or_assign
(paren
id|ep
op_rshift
l_int|1
)paren
op_lshift
l_int|7
suffix:semicolon
id|info
op_or_assign
id|usb_maxpacket
(paren
id|udev
comma
id|pipe
comma
id|is_out
)paren
op_lshift
l_int|16
suffix:semicolon
id|info
op_assign
id|cpu_to_le32
(paren
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|udev-&gt;speed
op_eq
id|USB_SPEED_LOW
)paren
id|info
op_or_assign
id|ED_LOWSPEED
suffix:semicolon
multiline_comment|/* control transfers store pids in tds */
r_if
c_cond
(paren
id|type
op_ne
id|PIPE_CONTROL
)paren
(brace
id|info
op_or_assign
id|is_out
ques
c_cond
id|ED_OUT
suffix:colon
id|ED_IN
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|PIPE_ISOCHRONOUS
)paren
id|info
op_or_assign
id|ED_ISO
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|PIPE_INTERRUPT
)paren
(brace
id|ed-&gt;intriso.intr_info.int_load
op_assign
id|bus_msecs
suffix:semicolon
r_if
c_cond
(paren
id|interval
OG
l_int|32
)paren
id|interval
op_assign
l_int|32
suffix:semicolon
)brace
)brace
id|ed-&gt;hwINFO
op_assign
id|info
suffix:semicolon
multiline_comment|/* value ignored except on periodic EDs, where&n;&t;&t; * we know it&squot;s already a power of 2&n;&t;&t; */
id|ed-&gt;interval
op_assign
id|interval
suffix:semicolon
macro_line|#ifdef DEBUG
multiline_comment|/*&n;&t; * There are two other cases we ought to change hwINFO, both during&n;&t; * enumeration.  There, the control request completes, unlinks, and&n;&t; * the next request gets queued before the unlink completes, so it&n;&t; * uses old/wrong hwINFO.  How much of a problem is this?  khubd is&n;&t; * already retrying after such failures...&n;&t; */
)brace
r_else
r_if
c_cond
(paren
id|type
op_eq
id|PIPE_CONTROL
)paren
(brace
id|u32
id|info
op_assign
id|le32_to_cpup
(paren
op_amp
id|ed-&gt;hwINFO
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|info
op_amp
l_int|0x7f
)paren
)paren
id|dbg
(paren
l_string|&quot;RETRY ctrl: address != 0&quot;
)paren
suffix:semicolon
id|info
op_rshift_assign
l_int|16
suffix:semicolon
r_if
c_cond
(paren
id|info
op_ne
id|udev-&gt;epmaxpacketin
(braket
l_int|0
)braket
)paren
id|dbg
(paren
l_string|&quot;RETRY ctrl: maxpacket %d != 8&quot;
comma
id|udev-&gt;epmaxpacketin
(braket
l_int|0
)braket
)paren
suffix:semicolon
macro_line|#endif /* DEBUG */
)brace
id|done
suffix:colon
id|spin_unlock_irqrestore
(paren
op_amp
id|ohci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ed
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* request unlinking of an endpoint from an operational HC.&n; * put the ep on the rm_list and stop the bulk or ctrl list &n; * real work is done at the next start frame (SF) hardware interrupt&n; */
DECL|function|start_urb_unlink
r_static
r_void
id|start_urb_unlink
(paren
r_struct
id|ohci_hcd
op_star
id|ohci
comma
r_struct
id|ed
op_star
id|ed
)paren
(brace
multiline_comment|/* already pending? */
r_if
c_cond
(paren
id|ed-&gt;state
op_amp
id|ED_URB_DEL
)paren
r_return
suffix:semicolon
id|ed-&gt;state
op_or_assign
id|ED_URB_DEL
suffix:semicolon
id|ed-&gt;hwINFO
op_or_assign
id|ED_SKIP
suffix:semicolon
r_switch
c_cond
(paren
id|ed-&gt;type
)paren
(brace
r_case
id|PIPE_CONTROL
suffix:colon
multiline_comment|/* stop control list */
id|ohci-&gt;hc_control
op_and_assign
op_complement
id|OHCI_CTRL_CLE
suffix:semicolon
id|writel
(paren
id|ohci-&gt;hc_control
comma
op_amp
id|ohci-&gt;regs-&gt;control
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_BULK
suffix:colon
multiline_comment|/* stop bulk list */
id|ohci-&gt;hc_control
op_and_assign
op_complement
id|OHCI_CTRL_BLE
suffix:semicolon
id|writel
(paren
id|ohci-&gt;hc_control
comma
op_amp
id|ohci-&gt;regs-&gt;control
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* SF interrupt might get delayed; record the frame counter value that&n;&t; * indicates when the HC isn&squot;t looking at it, so concurrent unlinks&n;&t; * behave.  frame_no wraps every 2^16 msec, and changes right before&n;&t; * SF is triggered.&n;&t; */
id|ed-&gt;tick
op_assign
id|le16_to_cpu
(paren
id|ohci-&gt;hcca-&gt;frame_no
)paren
op_plus
l_int|1
suffix:semicolon
id|ed-&gt;ed_rm_list
op_assign
id|ohci-&gt;ed_rm_list
suffix:semicolon
id|ohci-&gt;ed_rm_list
op_assign
id|ed
suffix:semicolon
multiline_comment|/* enable SOF interrupt */
r_if
c_cond
(paren
op_logical_neg
id|ohci-&gt;sleeping
)paren
(brace
id|writel
(paren
id|OHCI_INTR_SF
comma
op_amp
id|ohci-&gt;regs-&gt;intrstatus
)paren
suffix:semicolon
id|writel
(paren
id|OHCI_INTR_SF
comma
op_amp
id|ohci-&gt;regs-&gt;intrenable
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*-------------------------------------------------------------------------*&n; * TD handling functions&n; *-------------------------------------------------------------------------*/
multiline_comment|/* enqueue next TD for this URB (OHCI spec 5.2.8.2) */
r_static
r_void
DECL|function|td_fill
id|td_fill
(paren
r_struct
id|ohci_hcd
op_star
id|ohci
comma
r_int
r_int
id|info
comma
id|dma_addr_t
id|data
comma
r_int
id|len
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|index
)paren
(brace
r_struct
id|td
op_star
id|td
comma
op_star
id|td_pt
suffix:semicolon
id|urb_priv_t
op_star
id|urb_priv
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
r_int
id|is_iso
op_assign
id|info
op_amp
id|TD_ISO
suffix:semicolon
r_if
c_cond
(paren
id|index
op_ge
id|urb_priv-&gt;length
)paren
(brace
id|err
(paren
l_string|&quot;internal OHCI error: TD index &gt; length&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* aim for only one interrupt per urb.  mostly applies to control&n;&t; * and iso; other urbs rarely need more than one TD per urb.&n;&t; * this way, only final tds (or ones with an error) cause IRQs.&n;&t; *&n;&t; * NOTE: could delay interrupts even for the last TD, and get fewer&n;&t; * interrupts ... increasing per-urb latency by sharing interrupts.&n;&t; * Drivers that queue bulk urbs may request that behavior.&n;&t; */
r_if
c_cond
(paren
id|index
op_ne
(paren
id|urb_priv-&gt;length
op_minus
l_int|1
)paren
op_logical_or
(paren
id|urb-&gt;transfer_flags
op_amp
id|URB_NO_INTERRUPT
)paren
)paren
id|info
op_or_assign
id|TD_DI_SET
(paren
l_int|7
)paren
suffix:semicolon
multiline_comment|/* use this td as the next dummy */
id|td_pt
op_assign
id|urb_priv-&gt;td
(braket
id|index
)braket
suffix:semicolon
id|td_pt-&gt;hwNextTD
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* fill the old dummy TD */
id|td
op_assign
id|urb_priv-&gt;td
(braket
id|index
)braket
op_assign
id|urb_priv-&gt;ed-&gt;dummy
suffix:semicolon
id|urb_priv-&gt;ed-&gt;dummy
op_assign
id|td_pt
suffix:semicolon
id|td-&gt;ed
op_assign
id|urb_priv-&gt;ed
suffix:semicolon
id|td-&gt;next_dl_td
op_assign
l_int|NULL
suffix:semicolon
id|td-&gt;index
op_assign
id|index
suffix:semicolon
id|td-&gt;urb
op_assign
id|urb
suffix:semicolon
id|td-&gt;data_dma
op_assign
id|data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
id|data
op_assign
l_int|0
suffix:semicolon
id|td-&gt;hwINFO
op_assign
id|cpu_to_le32
(paren
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_iso
)paren
(brace
id|td-&gt;hwCBP
op_assign
id|cpu_to_le32
(paren
id|data
op_amp
l_int|0xFFFFF000
)paren
suffix:semicolon
id|td-&gt;hwPSW
(braket
l_int|0
)braket
op_assign
id|cpu_to_le16
(paren
(paren
id|data
op_amp
l_int|0x0FFF
)paren
op_or
l_int|0xE000
)paren
suffix:semicolon
id|td-&gt;ed-&gt;intriso.last_iso
op_assign
id|info
op_amp
l_int|0xffff
suffix:semicolon
)brace
r_else
(brace
id|td-&gt;hwCBP
op_assign
id|cpu_to_le32
(paren
id|data
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|data
)paren
id|td-&gt;hwBE
op_assign
id|cpu_to_le32
(paren
id|data
op_plus
id|len
op_minus
l_int|1
)paren
suffix:semicolon
r_else
id|td-&gt;hwBE
op_assign
l_int|0
suffix:semicolon
id|td-&gt;hwNextTD
op_assign
id|cpu_to_le32
(paren
id|td_pt-&gt;td_dma
)paren
suffix:semicolon
multiline_comment|/* HC might read the TD right after we link it ... */
id|wmb
(paren
)paren
suffix:semicolon
multiline_comment|/* append to queue */
id|td-&gt;ed-&gt;hwTailP
op_assign
id|td-&gt;hwNextTD
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* prepare all TDs of a transfer */
DECL|function|td_submit_urb
r_static
r_void
id|td_submit_urb
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
id|urb_priv_t
op_star
id|urb_priv
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
r_struct
id|ohci_hcd
op_star
id|ohci
op_assign
id|hcd_to_ohci
(paren
id|urb-&gt;dev-&gt;bus-&gt;hcpriv
)paren
suffix:semicolon
id|dma_addr_t
id|data
suffix:semicolon
r_int
id|data_len
op_assign
id|urb-&gt;transfer_buffer_length
suffix:semicolon
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
id|__u32
id|info
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|toggle
op_assign
l_int|0
suffix:semicolon
r_int
id|is_out
op_assign
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
multiline_comment|/* OHCI handles the DATA-toggles itself, we just use the&n;&t; * USB-toggle bits for resetting&n;&t; */
r_if
c_cond
(paren
id|usb_gettoggle
(paren
id|urb-&gt;dev
comma
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
comma
id|is_out
)paren
)paren
(brace
id|toggle
op_assign
id|TD_T_TOGGLE
suffix:semicolon
)brace
r_else
(brace
id|toggle
op_assign
id|TD_T_DATA0
suffix:semicolon
id|usb_settoggle
(paren
id|urb-&gt;dev
comma
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
comma
id|is_out
comma
l_int|1
)paren
suffix:semicolon
)brace
id|urb_priv-&gt;td_cnt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|data_len
)paren
(brace
id|data
op_assign
id|pci_map_single
(paren
id|ohci-&gt;hcd.pdev
comma
id|urb-&gt;transfer_buffer
comma
id|data_len
comma
id|is_out
ques
c_cond
id|PCI_DMA_TODEVICE
suffix:colon
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
)brace
r_else
id|data
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* NOTE:  TD_CC is set so we can tell which TDs the HC processed by&n;&t; * using TD_CC_GET, as well as by seeing them on the done list.&n;&t; */
r_switch
c_cond
(paren
id|usb_pipetype
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
r_case
id|PIPE_BULK
suffix:colon
id|info
op_assign
id|is_out
ques
c_cond
id|TD_CC
op_or
id|TD_DP_OUT
suffix:colon
id|TD_CC
op_or
id|TD_DP_IN
suffix:semicolon
multiline_comment|/* TDs _could_ transfer up to 8K each */
r_while
c_loop
(paren
id|data_len
OG
l_int|4096
)paren
(brace
id|td_fill
(paren
id|ohci
comma
id|info
op_or
(paren
id|cnt
ques
c_cond
id|TD_T_TOGGLE
suffix:colon
id|toggle
)paren
comma
id|data
comma
l_int|4096
comma
id|urb
comma
id|cnt
)paren
suffix:semicolon
id|data
op_add_assign
l_int|4096
suffix:semicolon
id|data_len
op_sub_assign
l_int|4096
suffix:semicolon
id|cnt
op_increment
suffix:semicolon
)brace
multiline_comment|/* maybe avoid ED halt on final TD short read */
r_if
c_cond
(paren
op_logical_neg
(paren
id|urb-&gt;transfer_flags
op_amp
id|USB_DISABLE_SPD
)paren
)paren
id|info
op_or_assign
id|TD_R
suffix:semicolon
id|td_fill
(paren
id|ohci
comma
id|info
op_or
(paren
id|cnt
ques
c_cond
id|TD_T_TOGGLE
suffix:colon
id|toggle
)paren
comma
id|data
comma
id|data_len
comma
id|urb
comma
id|cnt
)paren
suffix:semicolon
id|cnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|urb-&gt;transfer_flags
op_amp
id|USB_ZERO_PACKET
)paren
op_logical_and
id|cnt
OL
id|urb_priv-&gt;length
)paren
(brace
id|td_fill
(paren
id|ohci
comma
id|info
op_or
(paren
id|cnt
ques
c_cond
id|TD_T_TOGGLE
suffix:colon
id|toggle
)paren
comma
l_int|0
comma
l_int|0
comma
id|urb
comma
id|cnt
)paren
suffix:semicolon
id|cnt
op_increment
suffix:semicolon
)brace
multiline_comment|/* start bulk list */
r_if
c_cond
(paren
op_logical_neg
id|ohci-&gt;sleeping
)paren
(brace
id|wmb
(paren
)paren
suffix:semicolon
id|writel
(paren
id|OHCI_BLF
comma
op_amp
id|ohci-&gt;regs-&gt;cmdstatus
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|PIPE_INTERRUPT
suffix:colon
multiline_comment|/* current policy:  only one TD per request.&n;&t;&t;&t; * otherwise identical to bulk, except for BLF&n;&t;&t;&t; */
id|info
op_assign
id|TD_CC
op_or
id|toggle
suffix:semicolon
id|info
op_or_assign
id|is_out
ques
c_cond
id|TD_DP_OUT
suffix:colon
id|TD_R
op_or
id|TD_DP_IN
suffix:semicolon
id|td_fill
(paren
id|ohci
comma
id|info
comma
id|data
comma
id|data_len
comma
id|urb
comma
id|cnt
op_increment
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_CONTROL
suffix:colon
multiline_comment|/* control requests don&squot;t use toggle state  */
id|info
op_assign
id|TD_CC
op_or
id|TD_DP_SETUP
op_or
id|TD_T_DATA0
suffix:semicolon
id|td_fill
(paren
id|ohci
comma
id|info
comma
id|pci_map_single
(paren
id|ohci-&gt;hcd.pdev
comma
id|urb-&gt;setup_packet
comma
l_int|8
comma
id|PCI_DMA_TODEVICE
)paren
comma
l_int|8
comma
id|urb
comma
id|cnt
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data_len
OG
l_int|0
)paren
(brace
id|info
op_assign
id|TD_CC
op_or
id|TD_R
op_or
id|TD_T_DATA1
suffix:semicolon
id|info
op_or_assign
id|is_out
ques
c_cond
id|TD_DP_OUT
suffix:colon
id|TD_DP_IN
suffix:semicolon
multiline_comment|/* NOTE:  mishandles transfers &gt;8K, some &gt;4K */
id|td_fill
(paren
id|ohci
comma
id|info
comma
id|data
comma
id|data_len
comma
id|urb
comma
id|cnt
op_increment
)paren
suffix:semicolon
)brace
id|info
op_assign
id|is_out
ques
c_cond
id|TD_CC
op_or
id|TD_DP_IN
op_or
id|TD_T_DATA1
suffix:colon
id|TD_CC
op_or
id|TD_DP_OUT
op_or
id|TD_T_DATA1
suffix:semicolon
id|td_fill
(paren
id|ohci
comma
id|info
comma
id|data
comma
l_int|0
comma
id|urb
comma
id|cnt
op_increment
)paren
suffix:semicolon
multiline_comment|/* start control list */
r_if
c_cond
(paren
op_logical_neg
id|ohci-&gt;sleeping
)paren
(brace
id|wmb
(paren
)paren
suffix:semicolon
id|writel
(paren
id|OHCI_CLF
comma
op_amp
id|ohci-&gt;regs-&gt;cmdstatus
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|PIPE_ISOCHRONOUS
suffix:colon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_int
id|frame
op_assign
id|urb-&gt;start_frame
suffix:semicolon
singleline_comment|// FIXME scheduling should handle frame counter
singleline_comment|// roll-around ... exotic case (and OHCI has
singleline_comment|// a 2^16 iso range, vs other HCs max of 2^10)
id|frame
op_add_assign
id|cnt
op_star
id|urb-&gt;interval
suffix:semicolon
id|frame
op_and_assign
l_int|0xffff
suffix:semicolon
id|td_fill
(paren
id|ohci
comma
id|TD_CC
op_or
id|TD_ISO
op_or
id|frame
comma
id|data
op_plus
id|urb-&gt;iso_frame_desc
(braket
id|cnt
)braket
dot
id|offset
comma
id|urb-&gt;iso_frame_desc
(braket
id|cnt
)braket
dot
id|length
comma
id|urb
comma
id|cnt
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|urb_priv-&gt;length
op_ne
id|cnt
)paren
id|dbg
(paren
l_string|&quot;TD LENGTH %d != CNT %d&quot;
comma
id|urb_priv-&gt;length
comma
id|cnt
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*&n; * Done List handling functions&n; *-------------------------------------------------------------------------*/
multiline_comment|/* calculate transfer length/status and update the urb&n; * PRECONDITION:  irqsafe (only for urb-&gt;status locking)&n; */
DECL|function|td_done
r_static
r_void
id|td_done
(paren
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|td
op_star
id|td
)paren
(brace
id|u32
id|tdINFO
op_assign
id|le32_to_cpup
(paren
op_amp
id|td-&gt;hwINFO
)paren
suffix:semicolon
r_int
id|cc
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ISO ... drivers see per-TD length/status */
r_if
c_cond
(paren
id|tdINFO
op_amp
id|TD_ISO
)paren
(brace
id|u16
id|tdPSW
op_assign
id|le16_to_cpu
(paren
id|td-&gt;hwPSW
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_int
id|dlen
op_assign
l_int|0
suffix:semicolon
id|cc
op_assign
(paren
id|tdPSW
op_rshift
l_int|12
)paren
op_amp
l_int|0xF
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
)paren
id|dlen
op_assign
id|urb-&gt;iso_frame_desc
(braket
id|td-&gt;index
)braket
dot
id|length
suffix:semicolon
r_else
id|dlen
op_assign
id|tdPSW
op_amp
l_int|0x3ff
suffix:semicolon
id|urb-&gt;actual_length
op_add_assign
id|dlen
suffix:semicolon
id|urb-&gt;iso_frame_desc
(braket
id|td-&gt;index
)braket
dot
id|actual_length
op_assign
id|dlen
suffix:semicolon
id|urb-&gt;iso_frame_desc
(braket
id|td-&gt;index
)braket
dot
id|status
op_assign
id|cc_to_error
(braket
id|cc
)braket
suffix:semicolon
r_if
c_cond
(paren
id|cc
op_ne
l_int|0
)paren
id|dbg
(paren
l_string|&quot;  urb %p iso TD %p (%d) len %d CC %d&quot;
comma
id|urb
comma
id|td
comma
l_int|1
op_plus
id|td-&gt;index
comma
id|dlen
comma
id|cc
)paren
suffix:semicolon
multiline_comment|/* BULK, INT, CONTROL ... drivers see aggregate length/status,&n;&t; * except that &quot;setup&quot; bytes aren&squot;t counted and &quot;short&quot; transfers&n;&t; * might not be reported as errors.&n;&t; */
)brace
r_else
(brace
r_int
id|type
op_assign
id|usb_pipetype
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
id|u32
id|tdBE
op_assign
id|le32_to_cpup
(paren
op_amp
id|td-&gt;hwBE
)paren
suffix:semicolon
id|cc
op_assign
id|TD_CC_GET
(paren
id|tdINFO
)paren
suffix:semicolon
multiline_comment|/* control endpoints only have soft stalls */
r_if
c_cond
(paren
id|type
op_ne
id|PIPE_CONTROL
op_logical_and
id|cc
op_eq
id|TD_CC_STALL
)paren
id|usb_endpoint_halt
(paren
id|urb-&gt;dev
comma
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
comma
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
multiline_comment|/* update packet status if needed (short is normally ok) */
r_if
c_cond
(paren
id|cc
op_eq
id|TD_DATAUNDERRUN
op_logical_and
op_logical_neg
(paren
id|urb-&gt;transfer_flags
op_amp
id|URB_SHORT_NOT_OK
)paren
)paren
id|cc
op_assign
id|TD_CC_NOERROR
suffix:semicolon
r_if
c_cond
(paren
id|cc
op_ne
id|TD_CC_NOERROR
)paren
(brace
id|spin_lock
(paren
op_amp
id|urb-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
id|urb-&gt;status
op_assign
id|cc_to_error
(braket
id|cc
)braket
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|urb-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/* count all non-empty packets except control SETUP packet */
r_if
c_cond
(paren
(paren
id|type
op_ne
id|PIPE_CONTROL
op_logical_or
id|td-&gt;index
op_ne
l_int|0
)paren
op_logical_and
id|tdBE
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|td-&gt;hwCBP
op_eq
l_int|0
)paren
id|urb-&gt;actual_length
op_add_assign
id|tdBE
op_minus
id|td-&gt;data_dma
op_plus
l_int|1
suffix:semicolon
r_else
id|urb-&gt;actual_length
op_add_assign
id|le32_to_cpup
(paren
op_amp
id|td-&gt;hwCBP
)paren
op_minus
id|td-&gt;data_dma
suffix:semicolon
)brace
macro_line|#ifdef VERBOSE_DEBUG
r_if
c_cond
(paren
id|cc
op_ne
l_int|0
)paren
id|dbg
(paren
l_string|&quot;  urb %p TD %p (%d) CC %d, len=%d/%d&quot;
comma
id|urb
comma
id|td
comma
l_int|1
op_plus
id|td-&gt;index
comma
id|cc
comma
id|urb-&gt;actual_length
comma
id|urb-&gt;transfer_buffer_length
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* replies to the request have to be on a FIFO basis so&n; * we unreverse the hc-reversed done-list&n; */
DECL|function|dl_reverse_done_list
r_static
r_struct
id|td
op_star
id|dl_reverse_done_list
(paren
r_struct
id|ohci_hcd
op_star
id|ohci
)paren
(brace
id|__u32
id|td_list_hc
suffix:semicolon
r_struct
id|td
op_star
id|td_rev
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|td
op_star
id|td_list
op_assign
l_int|NULL
suffix:semicolon
id|urb_priv_t
op_star
id|urb_priv
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ohci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|td_list_hc
op_assign
id|le32_to_cpup
(paren
op_amp
id|ohci-&gt;hcca-&gt;done_head
)paren
suffix:semicolon
id|ohci-&gt;hcca-&gt;done_head
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|td_list_hc
)paren
(brace
id|td_list
op_assign
id|dma_to_td
(paren
id|ohci
comma
id|td_list_hc
)paren
suffix:semicolon
id|td_list-&gt;hwINFO
op_or_assign
id|cpu_to_le32
(paren
id|TD_DONE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TD_CC_GET
(paren
id|le32_to_cpup
(paren
op_amp
id|td_list-&gt;hwINFO
)paren
)paren
)paren
(brace
id|urb_priv
op_assign
(paren
id|urb_priv_t
op_star
)paren
id|td_list-&gt;urb-&gt;hcpriv
suffix:semicolon
multiline_comment|/* Non-iso endpoints can halt on error; un-halt,&n;&t;&t;&t; * and dequeue any other TDs from this urb.&n;&t;&t;&t; * No other TD could have caused the halt.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|td_list-&gt;ed-&gt;hwHeadP
op_amp
id|ED_H
)paren
(brace
r_if
c_cond
(paren
id|urb_priv
op_logical_and
(paren
(paren
id|td_list-&gt;index
op_plus
l_int|1
)paren
OL
id|urb_priv-&gt;length
)paren
)paren
(brace
macro_line|#ifdef OHCI_VERBOSE_DEBUG
id|dbg
(paren
l_string|&quot;urb %p TD %p (%d/%d), patch ED&quot;
comma
id|td_list-&gt;urb
comma
id|td_list
comma
l_int|1
op_plus
id|td_list-&gt;index
comma
id|urb_priv-&gt;length
)paren
suffix:semicolon
macro_line|#endif
id|td_list-&gt;ed-&gt;hwHeadP
op_assign
(paren
id|urb_priv-&gt;td
(braket
id|urb_priv-&gt;length
op_minus
l_int|1
)braket
op_member_access_from_pointer
id|hwNextTD
op_amp
id|__constant_cpu_to_le32
(paren
id|TD_MASK
)paren
)paren
op_or
(paren
id|td_list-&gt;ed-&gt;hwHeadP
op_amp
id|ED_C
)paren
suffix:semicolon
id|urb_priv-&gt;td_cnt
op_add_assign
id|urb_priv-&gt;length
op_minus
id|td_list-&gt;index
op_minus
l_int|1
suffix:semicolon
)brace
r_else
id|td_list-&gt;ed-&gt;hwHeadP
op_and_assign
op_complement
id|ED_H
suffix:semicolon
)brace
)brace
id|td_list-&gt;next_dl_td
op_assign
id|td_rev
suffix:semicolon
id|td_rev
op_assign
id|td_list
suffix:semicolon
id|td_list_hc
op_assign
id|le32_to_cpup
(paren
op_amp
id|td_list-&gt;hwNextTD
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ohci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|td_list
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* wrap-aware logic stolen from &lt;linux/jiffies.h&gt; */
DECL|macro|tick_before
mdefine_line|#define tick_before(t1,t2) ((((s16)(t1))-((s16)(t2))) &lt; 0)
multiline_comment|/* there are some urbs/eds to unlink; called in_irq(), with HCD locked */
DECL|function|finish_unlinks
r_static
r_void
id|finish_unlinks
(paren
r_struct
id|ohci_hcd
op_star
id|ohci
comma
id|u16
id|tick
)paren
(brace
r_struct
id|ed
op_star
id|ed
comma
op_star
op_star
id|last
suffix:semicolon
r_int
id|ctrl
op_assign
l_int|0
comma
id|bulk
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|last
op_assign
op_amp
id|ohci-&gt;ed_rm_list
comma
id|ed
op_assign
op_star
id|last
suffix:semicolon
id|ed
op_ne
l_int|NULL
suffix:semicolon
id|ed
op_assign
op_star
id|last
)paren
(brace
r_struct
id|td
op_star
id|td
comma
op_star
id|td_next
comma
op_star
id|tdHeadP
comma
op_star
id|tdTailP
suffix:semicolon
id|u32
op_star
id|td_p
suffix:semicolon
r_int
id|unlinked
suffix:semicolon
multiline_comment|/* only take off EDs that the HC isn&squot;t using, accounting for&n;&t;&t; * frame counter wraps.  completion callbacks might prepend&n;&t;&t; * EDs to the list, they&squot;ll be checked next irq.&n;&t;&t; */
r_if
c_cond
(paren
id|tick_before
(paren
id|tick
comma
id|ed-&gt;tick
)paren
)paren
(brace
id|last
op_assign
op_amp
id|ed-&gt;ed_rm_list
suffix:semicolon
r_continue
suffix:semicolon
)brace
op_star
id|last
op_assign
id|ed-&gt;ed_rm_list
suffix:semicolon
id|ed-&gt;ed_rm_list
op_assign
l_int|0
suffix:semicolon
id|unlinked
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* unlink urbs from first one requested to queue end;&n;&t;&t; * leave earlier urbs alone&n;&t;&t; */
id|tdTailP
op_assign
id|dma_to_td
(paren
id|ohci
comma
id|le32_to_cpup
(paren
op_amp
id|ed-&gt;hwTailP
)paren
)paren
suffix:semicolon
id|tdHeadP
op_assign
id|dma_to_td
(paren
id|ohci
comma
id|le32_to_cpup
(paren
op_amp
id|ed-&gt;hwHeadP
)paren
)paren
suffix:semicolon
id|td_p
op_assign
op_amp
id|ed-&gt;hwHeadP
suffix:semicolon
r_for
c_loop
(paren
id|td
op_assign
id|tdHeadP
suffix:semicolon
id|td
op_ne
id|tdTailP
suffix:semicolon
id|td
op_assign
id|td_next
)paren
(brace
r_struct
id|urb
op_star
id|urb
op_assign
id|td-&gt;urb
suffix:semicolon
id|urb_priv_t
op_star
id|urb_priv
op_assign
id|td-&gt;urb-&gt;hcpriv
suffix:semicolon
id|td_next
op_assign
id|dma_to_td
(paren
id|ohci
comma
id|le32_to_cpup
(paren
op_amp
id|td-&gt;hwNextTD
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlinked
op_logical_or
(paren
id|urb_priv-&gt;state
op_eq
id|URB_DEL
)paren
)paren
(brace
id|u32
id|tdINFO
op_assign
id|le32_to_cpup
(paren
op_amp
id|td-&gt;hwINFO
)paren
suffix:semicolon
id|unlinked
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* HC may have partly processed this TD */
r_if
c_cond
(paren
id|TD_CC_GET
(paren
id|tdINFO
)paren
OL
l_int|0xE
)paren
id|td_done
(paren
id|urb
comma
id|td
)paren
suffix:semicolon
op_star
id|td_p
op_assign
id|td-&gt;hwNextTD
op_or
(paren
op_star
id|td_p
op_amp
id|__constant_cpu_to_le32
(paren
l_int|0x3
)paren
)paren
suffix:semicolon
multiline_comment|/* URB is done; clean up */
r_if
c_cond
(paren
op_increment
(paren
id|urb_priv-&gt;td_cnt
)paren
op_eq
id|urb_priv-&gt;length
)paren
(brace
r_if
c_cond
(paren
id|urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
id|urb-&gt;status
op_assign
op_minus
id|ECONNRESET
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|ohci-&gt;lock
)paren
suffix:semicolon
id|finish_urb
(paren
id|ohci
comma
id|urb
)paren
suffix:semicolon
id|spin_lock
(paren
op_amp
id|ohci-&gt;lock
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|td_p
op_assign
op_amp
id|td-&gt;hwNextTD
suffix:semicolon
)brace
)brace
multiline_comment|/* FIXME actually want four cases here:&n;&t;&t; * (a) finishing URB unlink&n;&t;&t; *     [a1] no URBs queued, so start ED unlink&n;&t;&t; *     [a2] some (earlier) URBs still linked, re-enable&n;&t;&t; * (b) finishing ED unlink&n;&t;&t; *     [b1] no URBs queued, ED is truly idle now&n;&t;&t; *          ... we could set state ED_NEW and free dummy&n;&t;&t; *     [b2] URBs now queued, link ED back into schedule&n;&t;&t; * right now we only have (a)&n;&t;&t; */
id|ed-&gt;state
op_and_assign
op_complement
id|ED_URB_DEL
suffix:semicolon
id|tdHeadP
op_assign
id|dma_to_td
(paren
id|ohci
comma
id|le32_to_cpup
(paren
op_amp
id|ed-&gt;hwHeadP
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tdHeadP
op_eq
id|tdTailP
)paren
(brace
r_if
c_cond
(paren
id|ed-&gt;state
op_eq
id|ED_OPER
)paren
id|start_ed_unlink
(paren
id|ohci
comma
id|ed
)paren
suffix:semicolon
)brace
r_else
id|ed-&gt;hwINFO
op_and_assign
op_complement
id|ED_SKIP
suffix:semicolon
r_switch
c_cond
(paren
id|ed-&gt;type
)paren
(brace
r_case
id|PIPE_CONTROL
suffix:colon
id|ctrl
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_BULK
suffix:colon
id|bulk
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* maybe reenable control and bulk lists */
r_if
c_cond
(paren
op_logical_neg
id|ohci-&gt;disabled
)paren
(brace
r_if
c_cond
(paren
id|ctrl
)paren
multiline_comment|/* reset control list */
id|writel
(paren
l_int|0
comma
op_amp
id|ohci-&gt;regs-&gt;ed_controlcurrent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bulk
)paren
multiline_comment|/* reset bulk list */
id|writel
(paren
l_int|0
comma
op_amp
id|ohci-&gt;regs-&gt;ed_bulkcurrent
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ohci-&gt;ed_rm_list
)paren
(brace
r_if
c_cond
(paren
id|ohci-&gt;ed_controltail
)paren
id|ohci-&gt;hc_control
op_or_assign
id|OHCI_CTRL_CLE
suffix:semicolon
r_if
c_cond
(paren
id|ohci-&gt;ed_bulktail
)paren
id|ohci-&gt;hc_control
op_or_assign
id|OHCI_CTRL_BLE
suffix:semicolon
id|writel
(paren
id|ohci-&gt;hc_control
comma
op_amp
id|ohci-&gt;regs-&gt;control
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * Process normal completions (error or success) and clean the schedules.&n; *&n; * This is the main path for handing urbs back to drivers.  The only other&n; * path is finish_unlinks(), which unlinks URBs using ed_rm_list, instead of&n; * scanning the (re-reversed) donelist as this does.&n; */
DECL|function|dl_done_list
r_static
r_void
id|dl_done_list
(paren
r_struct
id|ohci_hcd
op_star
id|ohci
comma
r_struct
id|td
op_star
id|td
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ohci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
id|td
)paren
(brace
r_struct
id|td
op_star
id|td_next
op_assign
id|td-&gt;next_dl_td
suffix:semicolon
r_struct
id|urb
op_star
id|urb
op_assign
id|td-&gt;urb
suffix:semicolon
id|urb_priv_t
op_star
id|urb_priv
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
r_struct
id|ed
op_star
id|ed
op_assign
id|td-&gt;ed
suffix:semicolon
multiline_comment|/* update URB&squot;s length and status from TD */
id|td_done
(paren
id|urb
comma
id|td
)paren
suffix:semicolon
id|urb_priv-&gt;td_cnt
op_increment
suffix:semicolon
multiline_comment|/* If all this urb&squot;s TDs are done, call complete().&n;&t;&t; * Interrupt transfers are the only special case:&n;&t;&t; * they&squot;re reissued, until &quot;deleted&quot; by usb_unlink_urb&n;&t;&t; * (real work done in a SOF intr, by finish_unlinks).&n;&t;&t; */
r_if
c_cond
(paren
id|urb_priv-&gt;td_cnt
op_eq
id|urb_priv-&gt;length
)paren
(brace
r_int
id|resubmit
suffix:semicolon
id|resubmit
op_assign
id|usb_pipeint
(paren
id|urb-&gt;pipe
)paren
op_logical_and
(paren
id|urb_priv-&gt;state
op_ne
id|URB_DEL
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|ohci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|resubmit
)paren
id|intr_resub
(paren
id|ohci
comma
id|urb
)paren
suffix:semicolon
r_else
id|finish_urb
(paren
id|ohci
comma
id|urb
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ohci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* clean schedule:  unlink EDs that are no longer busy */
r_if
c_cond
(paren
(paren
id|ed-&gt;hwHeadP
op_amp
id|__constant_cpu_to_le32
(paren
id|TD_MASK
)paren
)paren
op_eq
id|ed-&gt;hwTailP
op_logical_and
(paren
id|ed-&gt;state
op_eq
id|ED_OPER
)paren
)paren
id|start_ed_unlink
(paren
id|ohci
comma
id|ed
)paren
suffix:semicolon
id|td
op_assign
id|td_next
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ohci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
eof
