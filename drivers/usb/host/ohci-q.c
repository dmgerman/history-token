multiline_comment|/*&n; * OHCI HCD (Host Controller Driver) for USB.&n; * &n; * (C) Copyright 1999 Roman Weissgaerber &lt;weissg@vienna.at&gt;&n; * (C) Copyright 2000-2002 David Brownell &lt;dbrownell@users.sourceforge.net&gt;&n; * &n; * This file is licenced under the GPL.&n; */
DECL|function|urb_free_priv
r_static
r_void
id|urb_free_priv
(paren
r_struct
id|ohci_hcd
op_star
id|hc
comma
id|urb_priv_t
op_star
id|urb_priv
)paren
(brace
r_int
id|last
op_assign
id|urb_priv-&gt;length
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|last
op_ge
l_int|0
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|td
op_star
id|td
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|last
suffix:semicolon
id|i
op_increment
)paren
(brace
id|td
op_assign
id|urb_priv-&gt;td
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|td
)paren
id|td_free
(paren
id|hc
comma
id|td
)paren
suffix:semicolon
)brace
)brace
id|kfree
(paren
id|urb_priv
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * URB goes back to driver, and isn&squot;t reissued.&n; * It&squot;s completely gone from HC data structures.&n; * PRECONDITION:  no locks held  (Giveback can call into HCD.)&n; */
DECL|function|finish_urb
r_static
r_void
id|finish_urb
(paren
r_struct
id|ohci_hcd
op_star
id|ohci
comma
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
singleline_comment|// ASSERT (urb-&gt;hcpriv != 0);
id|urb_free_priv
(paren
id|ohci
comma
id|urb-&gt;hcpriv
)paren
suffix:semicolon
id|urb-&gt;hcpriv
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|urb-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
(paren
id|urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
)paren
id|urb-&gt;status
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|urb-&gt;lock
comma
id|flags
)paren
suffix:semicolon
singleline_comment|// what lock protects these?
r_switch
c_cond
(paren
id|usb_pipetype
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
r_case
id|PIPE_ISOCHRONOUS
suffix:colon
id|hcd_to_bus
(paren
op_amp
id|ohci-&gt;hcd
)paren
op_member_access_from_pointer
id|bandwidth_isoc_reqs
op_decrement
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_INTERRUPT
suffix:colon
id|hcd_to_bus
(paren
op_amp
id|ohci-&gt;hcd
)paren
op_member_access_from_pointer
id|bandwidth_int_reqs
op_decrement
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef OHCI_VERBOSE_DEBUG
id|urb_print
(paren
id|urb
comma
l_string|&quot;RET&quot;
comma
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
macro_line|#endif
id|usb_hcd_giveback_urb
(paren
op_amp
id|ohci-&gt;hcd
comma
id|urb
comma
id|regs
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*&n; * ED handling functions&n; *-------------------------------------------------------------------------*/
multiline_comment|/* search for the right schedule branch to use for a periodic ed.&n; * does some load balancing; returns the branch, or negative errno.&n; */
DECL|function|balance
r_static
r_int
id|balance
(paren
r_struct
id|ohci_hcd
op_star
id|ohci
comma
r_int
id|interval
comma
r_int
id|load
)paren
(brace
r_int
id|i
comma
id|branch
op_assign
op_minus
id|ENOSPC
suffix:semicolon
multiline_comment|/* iso periods can be huge; iso tds specify frame numbers */
r_if
c_cond
(paren
id|interval
OG
id|NUM_INTS
)paren
id|interval
op_assign
id|NUM_INTS
suffix:semicolon
multiline_comment|/* search for the least loaded schedule branch of that period&n;&t; * that has enough bandwidth left unreserved.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|interval
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|branch
template_param
id|ohci-&gt;load
(braket
id|i
)braket
)paren
(brace
macro_line|#if 1&t;/* CONFIG_USB_BANDWIDTH */
r_int
id|j
suffix:semicolon
multiline_comment|/* usb 1.1 says 90% of one frame */
r_for
c_loop
(paren
id|j
op_assign
id|i
suffix:semicolon
id|j
OL
id|NUM_INTS
suffix:semicolon
id|j
op_add_assign
id|interval
)paren
(brace
r_if
c_cond
(paren
(paren
id|ohci-&gt;load
(braket
id|j
)braket
op_plus
id|load
)paren
OG
l_int|900
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|j
OL
id|NUM_INTS
)paren
r_continue
suffix:semicolon
macro_line|#endif
id|branch
op_assign
id|i
suffix:semicolon
)brace
)brace
r_return
id|branch
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* both iso and interrupt requests have periods; this routine puts them&n; * into the schedule tree in the apppropriate place.  most iso devices use&n; * 1msec periods, but that&squot;s not required.&n; */
DECL|function|periodic_link
r_static
r_void
id|periodic_link
(paren
r_struct
id|ohci_hcd
op_star
id|ohci
comma
r_struct
id|ed
op_star
id|ed
)paren
(brace
r_int
id|i
suffix:semicolon
id|ohci_vdbg
(paren
id|ohci
comma
l_string|&quot;link %sed %p branch %d [%dus.], interval %d&bslash;n&quot;
comma
(paren
id|ed-&gt;hwINFO
op_amp
id|ED_ISO
)paren
ques
c_cond
l_string|&quot;iso &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|ed
comma
id|ed-&gt;branch
comma
id|ed-&gt;load
comma
id|ed-&gt;interval
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|ed-&gt;branch
suffix:semicolon
id|i
OL
id|NUM_INTS
suffix:semicolon
id|i
op_add_assign
id|ed-&gt;interval
)paren
(brace
r_struct
id|ed
op_star
op_star
id|prev
op_assign
op_amp
id|ohci-&gt;periodic
(braket
id|i
)braket
suffix:semicolon
id|u32
op_star
id|prev_p
op_assign
op_amp
id|ohci-&gt;hcca-&gt;int_table
(braket
id|i
)braket
suffix:semicolon
r_struct
id|ed
op_star
id|here
op_assign
op_star
id|prev
suffix:semicolon
multiline_comment|/* sorting each branch by period (slow before fast)&n;&t;&t; * lets us share the faster parts of the tree.&n;&t;&t; * (plus maybe: put interrupt eds before iso)&n;&t;&t; */
r_while
c_loop
(paren
id|here
op_logical_and
id|ed
op_ne
id|here
)paren
(brace
r_if
c_cond
(paren
id|ed-&gt;interval
OG
id|here-&gt;interval
)paren
r_break
suffix:semicolon
id|prev
op_assign
op_amp
id|here-&gt;ed_next
suffix:semicolon
id|prev_p
op_assign
op_amp
id|here-&gt;hwNextED
suffix:semicolon
id|here
op_assign
op_star
id|prev
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ed
op_ne
id|here
)paren
(brace
id|ed-&gt;ed_next
op_assign
id|here
suffix:semicolon
r_if
c_cond
(paren
id|here
)paren
id|ed-&gt;hwNextED
op_assign
op_star
id|prev_p
suffix:semicolon
id|wmb
(paren
)paren
suffix:semicolon
op_star
id|prev
op_assign
id|ed
suffix:semicolon
op_star
id|prev_p
op_assign
id|cpu_to_le32p
(paren
op_amp
id|ed-&gt;dma
)paren
suffix:semicolon
)brace
id|ohci-&gt;load
(braket
id|i
)braket
op_add_assign
id|ed-&gt;load
suffix:semicolon
)brace
id|hcd_to_bus
(paren
op_amp
id|ohci-&gt;hcd
)paren
op_member_access_from_pointer
id|bandwidth_allocated
op_add_assign
id|ed-&gt;load
op_div
id|ed-&gt;interval
suffix:semicolon
)brace
multiline_comment|/* link an ed into one of the HC chains */
DECL|function|ed_schedule
r_static
r_int
id|ed_schedule
(paren
r_struct
id|ohci_hcd
op_star
id|ohci
comma
r_struct
id|ed
op_star
id|ed
)paren
(brace
r_int
id|branch
suffix:semicolon
id|ed-&gt;state
op_assign
id|ED_OPER
suffix:semicolon
id|ed-&gt;ed_prev
op_assign
l_int|0
suffix:semicolon
id|ed-&gt;ed_next
op_assign
l_int|0
suffix:semicolon
id|ed-&gt;hwNextED
op_assign
l_int|0
suffix:semicolon
id|wmb
(paren
)paren
suffix:semicolon
multiline_comment|/* we care about rm_list when setting CLE/BLE in case the HC was at&n;&t; * work on some TD when CLE/BLE was turned off, and isn&squot;t quiesced&n;&t; * yet.  finish_unlinks() restarts as needed, some upcoming INTR_SF.&n;&t; *&n;&t; * control and bulk EDs are doubly linked (ed_next, ed_prev), but&n;&t; * periodic ones are singly linked (ed_next). that&squot;s because the&n;&t; * periodic schedule encodes a tree like figure 3-5 in the ohci&n;&t; * spec:  each qh can have several &quot;previous&quot; nodes, and the tree&n;&t; * doesn&squot;t have unused/idle descriptors.&n;&t; */
r_switch
c_cond
(paren
id|ed-&gt;type
)paren
(brace
r_case
id|PIPE_CONTROL
suffix:colon
r_if
c_cond
(paren
id|ohci-&gt;ed_controltail
op_eq
l_int|NULL
)paren
(brace
id|writel
(paren
id|ed-&gt;dma
comma
op_amp
id|ohci-&gt;regs-&gt;ed_controlhead
)paren
suffix:semicolon
)brace
r_else
(brace
id|ohci-&gt;ed_controltail-&gt;ed_next
op_assign
id|ed
suffix:semicolon
id|ohci-&gt;ed_controltail-&gt;hwNextED
op_assign
id|cpu_to_le32
(paren
id|ed-&gt;dma
)paren
suffix:semicolon
)brace
id|ed-&gt;ed_prev
op_assign
id|ohci-&gt;ed_controltail
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ohci-&gt;ed_controltail
op_logical_and
op_logical_neg
id|ohci-&gt;ed_rm_list
)paren
(brace
id|ohci-&gt;hc_control
op_or_assign
id|OHCI_CTRL_CLE
suffix:semicolon
id|writel
(paren
l_int|0
comma
op_amp
id|ohci-&gt;regs-&gt;ed_controlcurrent
)paren
suffix:semicolon
id|writel
(paren
id|ohci-&gt;hc_control
comma
op_amp
id|ohci-&gt;regs-&gt;control
)paren
suffix:semicolon
)brace
id|ohci-&gt;ed_controltail
op_assign
id|ed
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_BULK
suffix:colon
r_if
c_cond
(paren
id|ohci-&gt;ed_bulktail
op_eq
l_int|NULL
)paren
(brace
id|writel
(paren
id|ed-&gt;dma
comma
op_amp
id|ohci-&gt;regs-&gt;ed_bulkhead
)paren
suffix:semicolon
)brace
r_else
(brace
id|ohci-&gt;ed_bulktail-&gt;ed_next
op_assign
id|ed
suffix:semicolon
id|ohci-&gt;ed_bulktail-&gt;hwNextED
op_assign
id|cpu_to_le32
(paren
id|ed-&gt;dma
)paren
suffix:semicolon
)brace
id|ed-&gt;ed_prev
op_assign
id|ohci-&gt;ed_bulktail
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ohci-&gt;ed_bulktail
op_logical_and
op_logical_neg
id|ohci-&gt;ed_rm_list
)paren
(brace
id|ohci-&gt;hc_control
op_or_assign
id|OHCI_CTRL_BLE
suffix:semicolon
id|writel
(paren
l_int|0
comma
op_amp
id|ohci-&gt;regs-&gt;ed_bulkcurrent
)paren
suffix:semicolon
id|writel
(paren
id|ohci-&gt;hc_control
comma
op_amp
id|ohci-&gt;regs-&gt;control
)paren
suffix:semicolon
)brace
id|ohci-&gt;ed_bulktail
op_assign
id|ed
suffix:semicolon
r_break
suffix:semicolon
singleline_comment|// case PIPE_INTERRUPT:
singleline_comment|// case PIPE_ISOCHRONOUS:
r_default
suffix:colon
id|branch
op_assign
id|balance
(paren
id|ohci
comma
id|ed-&gt;interval
comma
id|ed-&gt;load
)paren
suffix:semicolon
r_if
c_cond
(paren
id|branch
OL
l_int|0
)paren
(brace
id|ohci_dbg
(paren
id|ohci
comma
l_string|&quot;ERR %d, interval %d msecs, load %d&bslash;n&quot;
comma
id|branch
comma
id|ed-&gt;interval
comma
id|ed-&gt;load
)paren
suffix:semicolon
singleline_comment|// FIXME if there are TDs queued, fail them!
r_return
id|branch
suffix:semicolon
)brace
id|ed-&gt;branch
op_assign
id|branch
suffix:semicolon
id|periodic_link
(paren
id|ohci
comma
id|ed
)paren
suffix:semicolon
)brace
multiline_comment|/* the HC may not see the schedule updates yet, but if it does&n;&t; * then they&squot;ll be properly ordered.&n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* scan the periodic table to find and unlink this ED */
DECL|function|periodic_unlink
r_static
r_void
id|periodic_unlink
(paren
r_struct
id|ohci_hcd
op_star
id|ohci
comma
r_struct
id|ed
op_star
id|ed
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|ed-&gt;branch
suffix:semicolon
id|i
OL
id|NUM_INTS
suffix:semicolon
id|i
op_add_assign
id|ed-&gt;interval
)paren
(brace
r_struct
id|ed
op_star
id|temp
suffix:semicolon
r_struct
id|ed
op_star
op_star
id|prev
op_assign
op_amp
id|ohci-&gt;periodic
(braket
id|i
)braket
suffix:semicolon
id|u32
op_star
id|prev_p
op_assign
op_amp
id|ohci-&gt;hcca-&gt;int_table
(braket
id|i
)braket
suffix:semicolon
r_while
c_loop
(paren
op_star
id|prev
op_logical_and
(paren
id|temp
op_assign
op_star
id|prev
)paren
op_ne
id|ed
)paren
(brace
id|prev_p
op_assign
op_amp
id|temp-&gt;hwNextED
suffix:semicolon
id|prev
op_assign
op_amp
id|temp-&gt;ed_next
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|prev
)paren
(brace
op_star
id|prev_p
op_assign
id|ed-&gt;hwNextED
suffix:semicolon
op_star
id|prev
op_assign
id|ed-&gt;ed_next
suffix:semicolon
)brace
id|ohci-&gt;load
(braket
id|i
)braket
op_sub_assign
id|ed-&gt;load
suffix:semicolon
)brace
id|hcd_to_bus
(paren
op_amp
id|ohci-&gt;hcd
)paren
op_member_access_from_pointer
id|bandwidth_allocated
op_sub_assign
id|ed-&gt;load
op_div
id|ed-&gt;interval
suffix:semicolon
id|ohci_vdbg
(paren
id|ohci
comma
l_string|&quot;unlink %sed %p branch %d [%dus.], interval %d&bslash;n&quot;
comma
(paren
id|ed-&gt;hwINFO
op_amp
id|ED_ISO
)paren
ques
c_cond
l_string|&quot;iso &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|ed
comma
id|ed-&gt;branch
comma
id|ed-&gt;load
comma
id|ed-&gt;interval
)paren
suffix:semicolon
)brace
multiline_comment|/* unlink an ed from one of the HC chains. &n; * just the link to the ed is unlinked.&n; * the link from the ed still points to another operational ed or 0&n; * so the HC can eventually finish the processing of the unlinked ed&n; */
DECL|function|ed_deschedule
r_static
r_void
id|ed_deschedule
(paren
r_struct
id|ohci_hcd
op_star
id|ohci
comma
r_struct
id|ed
op_star
id|ed
)paren
(brace
id|ed-&gt;hwINFO
op_or_assign
id|ED_SKIP
suffix:semicolon
r_switch
c_cond
(paren
id|ed-&gt;type
)paren
(brace
r_case
id|PIPE_CONTROL
suffix:colon
r_if
c_cond
(paren
id|ed-&gt;ed_prev
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ed-&gt;hwNextED
)paren
(brace
id|ohci-&gt;hc_control
op_and_assign
op_complement
id|OHCI_CTRL_CLE
suffix:semicolon
id|writel
(paren
id|ohci-&gt;hc_control
comma
op_amp
id|ohci-&gt;regs-&gt;control
)paren
suffix:semicolon
id|writel
(paren
l_int|0
comma
op_amp
id|ohci-&gt;regs-&gt;ed_controlcurrent
)paren
suffix:semicolon
singleline_comment|// post those pci writes
(paren
r_void
)paren
id|readl
(paren
op_amp
id|ohci-&gt;regs-&gt;control
)paren
suffix:semicolon
)brace
id|writel
(paren
id|le32_to_cpup
(paren
op_amp
id|ed-&gt;hwNextED
)paren
comma
op_amp
id|ohci-&gt;regs-&gt;ed_controlhead
)paren
suffix:semicolon
)brace
r_else
(brace
id|ed-&gt;ed_prev-&gt;ed_next
op_assign
id|ed-&gt;ed_next
suffix:semicolon
id|ed-&gt;ed_prev-&gt;hwNextED
op_assign
id|ed-&gt;hwNextED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ohci-&gt;ed_controltail
op_eq
id|ed
)paren
(brace
id|ohci-&gt;ed_controltail
op_assign
id|ed-&gt;ed_prev
suffix:semicolon
r_if
c_cond
(paren
id|ohci-&gt;ed_controltail
)paren
id|ohci-&gt;ed_controltail-&gt;ed_next
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ed-&gt;ed_next
)paren
(brace
id|ed-&gt;ed_next-&gt;ed_prev
op_assign
id|ed-&gt;ed_prev
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|PIPE_BULK
suffix:colon
r_if
c_cond
(paren
id|ed-&gt;ed_prev
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ed-&gt;hwNextED
)paren
(brace
id|ohci-&gt;hc_control
op_and_assign
op_complement
id|OHCI_CTRL_BLE
suffix:semicolon
id|writel
(paren
id|ohci-&gt;hc_control
comma
op_amp
id|ohci-&gt;regs-&gt;control
)paren
suffix:semicolon
id|writel
(paren
l_int|0
comma
op_amp
id|ohci-&gt;regs-&gt;ed_bulkcurrent
)paren
suffix:semicolon
singleline_comment|// post those pci writes
(paren
r_void
)paren
id|readl
(paren
op_amp
id|ohci-&gt;regs-&gt;control
)paren
suffix:semicolon
)brace
id|writel
(paren
id|le32_to_cpup
(paren
op_amp
id|ed-&gt;hwNextED
)paren
comma
op_amp
id|ohci-&gt;regs-&gt;ed_bulkhead
)paren
suffix:semicolon
)brace
r_else
(brace
id|ed-&gt;ed_prev-&gt;ed_next
op_assign
id|ed-&gt;ed_next
suffix:semicolon
id|ed-&gt;ed_prev-&gt;hwNextED
op_assign
id|ed-&gt;hwNextED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ohci-&gt;ed_bulktail
op_eq
id|ed
)paren
(brace
id|ohci-&gt;ed_bulktail
op_assign
id|ed-&gt;ed_prev
suffix:semicolon
r_if
c_cond
(paren
id|ohci-&gt;ed_bulktail
)paren
id|ohci-&gt;ed_bulktail-&gt;ed_next
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ed-&gt;ed_next
)paren
(brace
id|ed-&gt;ed_next-&gt;ed_prev
op_assign
id|ed-&gt;ed_prev
suffix:semicolon
)brace
r_break
suffix:semicolon
singleline_comment|// case PIPE_INTERRUPT:
singleline_comment|// case PIPE_ISOCHRONOUS:
r_default
suffix:colon
id|periodic_unlink
(paren
id|ohci
comma
id|ed
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* NOTE: Except for a couple of exceptionally clean unlink cases&n;&t; * (like unlinking the only c/b ED, with no TDs) HCs may still be&n;&t; * caching this operational ED (or its address).  Safe unlinking&n;&t; * involves not marking it ED_IDLE till INTR_SF; we always do that&n;&t; * if td_list isn&squot;t empty.  Otherwise the race is small; but ...&n;&t; */
r_if
c_cond
(paren
id|ed-&gt;state
op_eq
id|ED_OPER
)paren
(brace
id|ed-&gt;state
op_assign
id|ED_IDLE
suffix:semicolon
id|ed-&gt;hwINFO
op_and_assign
op_complement
(paren
id|ED_SKIP
op_or
id|ED_DEQUEUE
)paren
suffix:semicolon
id|ed-&gt;hwHeadP
op_and_assign
op_complement
id|ED_H
suffix:semicolon
id|wmb
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* get and maybe (re)init an endpoint. init _should_ be done only as part&n; * of usb_set_configuration() or usb_set_interface() ... but the USB stack&n; * isn&squot;t very stateful, so we re-init whenever the HC isn&squot;t looking.&n; */
DECL|function|ed_get
r_static
r_struct
id|ed
op_star
id|ed_get
(paren
r_struct
id|ohci_hcd
op_star
id|ohci
comma
r_struct
id|usb_device
op_star
id|udev
comma
r_int
r_int
id|pipe
comma
r_int
id|interval
)paren
(brace
r_int
id|is_out
op_assign
op_logical_neg
id|usb_pipein
(paren
id|pipe
)paren
suffix:semicolon
r_int
id|type
op_assign
id|usb_pipetype
(paren
id|pipe
)paren
suffix:semicolon
r_struct
id|hcd_dev
op_star
id|dev
op_assign
(paren
r_struct
id|hcd_dev
op_star
)paren
id|udev-&gt;hcpriv
suffix:semicolon
r_struct
id|ed
op_star
id|ed
suffix:semicolon
r_int
id|ep
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|ep
op_assign
id|usb_pipeendpoint
(paren
id|pipe
)paren
op_lshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|PIPE_CONTROL
op_logical_and
id|is_out
)paren
id|ep
op_or_assign
l_int|1
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ohci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ed
op_assign
id|dev-&gt;ep
(braket
id|ep
)braket
)paren
)paren
(brace
r_struct
id|td
op_star
id|td
suffix:semicolon
id|ed
op_assign
id|ed_alloc
(paren
id|ohci
comma
id|SLAB_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ed
)paren
(brace
multiline_comment|/* out of memory */
r_goto
id|done
suffix:semicolon
)brace
id|dev-&gt;ep
(braket
id|ep
)braket
op_assign
id|ed
suffix:semicolon
multiline_comment|/* dummy td; end of td list for ed */
id|td
op_assign
id|td_alloc
(paren
id|ohci
comma
id|SLAB_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|td
)paren
(brace
multiline_comment|/* out of memory */
id|ed_free
(paren
id|ohci
comma
id|ed
)paren
suffix:semicolon
id|ed
op_assign
l_int|0
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|ed-&gt;dummy
op_assign
id|td
suffix:semicolon
id|ed-&gt;hwTailP
op_assign
id|cpu_to_le32
(paren
id|td-&gt;td_dma
)paren
suffix:semicolon
id|ed-&gt;hwHeadP
op_assign
id|ed-&gt;hwTailP
suffix:semicolon
multiline_comment|/* ED_C, ED_H zeroed */
id|ed-&gt;state
op_assign
id|ED_IDLE
suffix:semicolon
id|ed-&gt;type
op_assign
id|type
suffix:semicolon
)brace
multiline_comment|/* FIXME:  Don&squot;t do this without knowing it&squot;s safe to clobber this&n;&t; * state/mode info.  Currently the upper layers don&squot;t support such&n;&t; * guarantees; we&squot;re lucky changing config/altsetting is rare.&n;&t; * The state/mode info also changes during enumeration: set_address&n;&t; * uses the &squot;wrong&squot; device address, and ep0 maxpacketsize will often&n;&t; * improve on the initial value.&n;&t; */
r_if
c_cond
(paren
id|ed-&gt;state
op_eq
id|ED_IDLE
)paren
(brace
id|u32
id|info
suffix:semicolon
id|info
op_assign
id|usb_pipedevice
(paren
id|pipe
)paren
suffix:semicolon
id|info
op_or_assign
(paren
id|ep
op_rshift
l_int|1
)paren
op_lshift
l_int|7
suffix:semicolon
id|info
op_or_assign
id|usb_maxpacket
(paren
id|udev
comma
id|pipe
comma
id|is_out
)paren
op_lshift
l_int|16
suffix:semicolon
id|info
op_assign
id|cpu_to_le32
(paren
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|udev-&gt;speed
op_eq
id|USB_SPEED_LOW
)paren
id|info
op_or_assign
id|ED_LOWSPEED
suffix:semicolon
multiline_comment|/* only control transfers store pids in tds */
r_if
c_cond
(paren
id|type
op_ne
id|PIPE_CONTROL
)paren
(brace
id|info
op_or_assign
id|is_out
ques
c_cond
id|ED_OUT
suffix:colon
id|ED_IN
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|PIPE_BULK
)paren
(brace
multiline_comment|/* periodic transfers... */
r_if
c_cond
(paren
id|type
op_eq
id|PIPE_ISOCHRONOUS
)paren
id|info
op_or_assign
id|ED_ISO
suffix:semicolon
r_else
r_if
c_cond
(paren
id|interval
OG
l_int|32
)paren
multiline_comment|/* iso can be bigger */
id|interval
op_assign
l_int|32
suffix:semicolon
id|ed-&gt;interval
op_assign
id|interval
suffix:semicolon
id|ed-&gt;load
op_assign
id|usb_calc_bus_time
(paren
id|udev-&gt;speed
comma
op_logical_neg
id|is_out
comma
id|type
op_eq
id|PIPE_ISOCHRONOUS
comma
id|usb_maxpacket
(paren
id|udev
comma
id|pipe
comma
id|is_out
)paren
)paren
op_div
l_int|1000
suffix:semicolon
)brace
)brace
id|ed-&gt;hwINFO
op_assign
id|info
suffix:semicolon
)brace
id|done
suffix:colon
id|spin_unlock_irqrestore
(paren
op_amp
id|ohci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ed
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* request unlinking of an endpoint from an operational HC.&n; * put the ep on the rm_list&n; * real work is done at the next start frame (SF) hardware interrupt&n; */
DECL|function|start_urb_unlink
r_static
r_void
id|start_urb_unlink
(paren
r_struct
id|ohci_hcd
op_star
id|ohci
comma
r_struct
id|ed
op_star
id|ed
)paren
(brace
id|ed-&gt;hwINFO
op_or_assign
id|ED_DEQUEUE
suffix:semicolon
id|ed-&gt;state
op_assign
id|ED_UNLINK
suffix:semicolon
id|ed_deschedule
(paren
id|ohci
comma
id|ed
)paren
suffix:semicolon
multiline_comment|/* SF interrupt might get delayed; record the frame counter value that&n;&t; * indicates when the HC isn&squot;t looking at it, so concurrent unlinks&n;&t; * behave.  frame_no wraps every 2^16 msec, and changes right before&n;&t; * SF is triggered.&n;&t; */
id|ed-&gt;tick
op_assign
id|le16_to_cpu
(paren
id|ohci-&gt;hcca-&gt;frame_no
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* rm_list is just singly linked, for simplicity */
id|ed-&gt;ed_next
op_assign
id|ohci-&gt;ed_rm_list
suffix:semicolon
id|ed-&gt;ed_prev
op_assign
l_int|0
suffix:semicolon
id|ohci-&gt;ed_rm_list
op_assign
id|ed
suffix:semicolon
multiline_comment|/* enable SOF interrupt */
r_if
c_cond
(paren
op_logical_neg
id|ohci-&gt;sleeping
)paren
(brace
id|writel
(paren
id|OHCI_INTR_SF
comma
op_amp
id|ohci-&gt;regs-&gt;intrstatus
)paren
suffix:semicolon
id|writel
(paren
id|OHCI_INTR_SF
comma
op_amp
id|ohci-&gt;regs-&gt;intrenable
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*-------------------------------------------------------------------------*&n; * TD handling functions&n; *-------------------------------------------------------------------------*/
multiline_comment|/* enqueue next TD for this URB (OHCI spec 5.2.8.2) */
r_static
r_void
DECL|function|td_fill
id|td_fill
(paren
r_struct
id|ohci_hcd
op_star
id|ohci
comma
id|u32
id|info
comma
id|dma_addr_t
id|data
comma
r_int
id|len
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|index
)paren
(brace
r_struct
id|td
op_star
id|td
comma
op_star
id|td_pt
suffix:semicolon
r_struct
id|urb_priv
op_star
id|urb_priv
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
r_int
id|is_iso
op_assign
id|info
op_amp
id|TD_ISO
suffix:semicolon
r_int
id|hash
suffix:semicolon
singleline_comment|// ASSERT (index &lt; urb_priv-&gt;length);
multiline_comment|/* aim for only one interrupt per urb.  mostly applies to control&n;&t; * and iso; other urbs rarely need more than one TD per urb.&n;&t; * this way, only final tds (or ones with an error) cause IRQs.&n;&t; * at least immediately; use DI=6 in case any control request is&n;&t; * tempted to die part way through.&n;&t; *&n;&t; * NOTE: could delay interrupts even for the last TD, and get fewer&n;&t; * interrupts ... increasing per-urb latency by sharing interrupts.&n;&t; * Drivers that queue bulk urbs may request that behavior.&n;&t; */
r_if
c_cond
(paren
id|index
op_ne
(paren
id|urb_priv-&gt;length
op_minus
l_int|1
)paren
op_logical_or
(paren
id|urb-&gt;transfer_flags
op_amp
id|URB_NO_INTERRUPT
)paren
)paren
id|info
op_or_assign
id|TD_DI_SET
(paren
l_int|6
)paren
suffix:semicolon
multiline_comment|/* use this td as the next dummy */
id|td_pt
op_assign
id|urb_priv-&gt;td
(braket
id|index
)braket
suffix:semicolon
multiline_comment|/* fill the old dummy TD */
id|td
op_assign
id|urb_priv-&gt;td
(braket
id|index
)braket
op_assign
id|urb_priv-&gt;ed-&gt;dummy
suffix:semicolon
id|urb_priv-&gt;ed-&gt;dummy
op_assign
id|td_pt
suffix:semicolon
id|td-&gt;ed
op_assign
id|urb_priv-&gt;ed
suffix:semicolon
id|td-&gt;next_dl_td
op_assign
l_int|NULL
suffix:semicolon
id|td-&gt;index
op_assign
id|index
suffix:semicolon
id|td-&gt;urb
op_assign
id|urb
suffix:semicolon
id|td-&gt;data_dma
op_assign
id|data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
id|data
op_assign
l_int|0
suffix:semicolon
id|td-&gt;hwINFO
op_assign
id|cpu_to_le32
(paren
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_iso
)paren
(brace
id|td-&gt;hwCBP
op_assign
id|cpu_to_le32
(paren
id|data
op_amp
l_int|0xFFFFF000
)paren
suffix:semicolon
id|td-&gt;hwPSW
(braket
l_int|0
)braket
op_assign
id|cpu_to_le16
(paren
(paren
id|data
op_amp
l_int|0x0FFF
)paren
op_or
l_int|0xE000
)paren
suffix:semicolon
id|td-&gt;ed-&gt;last_iso
op_assign
id|info
op_amp
l_int|0xffff
suffix:semicolon
)brace
r_else
(brace
id|td-&gt;hwCBP
op_assign
id|cpu_to_le32
(paren
id|data
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|data
)paren
id|td-&gt;hwBE
op_assign
id|cpu_to_le32
(paren
id|data
op_plus
id|len
op_minus
l_int|1
)paren
suffix:semicolon
r_else
id|td-&gt;hwBE
op_assign
l_int|0
suffix:semicolon
id|td-&gt;hwNextTD
op_assign
id|cpu_to_le32
(paren
id|td_pt-&gt;td_dma
)paren
suffix:semicolon
multiline_comment|/* append to queue */
id|list_add_tail
(paren
op_amp
id|td-&gt;td_list
comma
op_amp
id|td-&gt;ed-&gt;td_list
)paren
suffix:semicolon
multiline_comment|/* hash it for later reverse mapping */
id|hash
op_assign
id|TD_HASH_FUNC
(paren
id|td-&gt;td_dma
)paren
suffix:semicolon
id|td-&gt;td_hash
op_assign
id|ohci-&gt;td_hash
(braket
id|hash
)braket
suffix:semicolon
id|ohci-&gt;td_hash
(braket
id|hash
)braket
op_assign
id|td
suffix:semicolon
multiline_comment|/* HC might read the TD (or cachelines) right away ... */
id|wmb
(paren
)paren
suffix:semicolon
id|td-&gt;ed-&gt;hwTailP
op_assign
id|td-&gt;hwNextTD
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* Prepare all TDs of a transfer, and queue them onto the ED.&n; * Caller guarantees HC is active.&n; * Usually the ED is already on the schedule, so TDs might be&n; * processed as soon as they&squot;re queued.&n; */
DECL|function|td_submit_urb
r_static
r_void
id|td_submit_urb
(paren
r_struct
id|ohci_hcd
op_star
id|ohci
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|urb_priv
op_star
id|urb_priv
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
id|dma_addr_t
id|data
suffix:semicolon
r_int
id|data_len
op_assign
id|urb-&gt;transfer_buffer_length
suffix:semicolon
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
id|u32
id|info
op_assign
l_int|0
suffix:semicolon
r_int
id|is_out
op_assign
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
multiline_comment|/* OHCI handles the bulk/interrupt data toggles itself.  We just&n;&t; * use the device toggle bits for resetting, and rely on the fact&n;&t; * that resetting toggle is meaningless if the endpoint is active.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|usb_gettoggle
(paren
id|urb-&gt;dev
comma
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
comma
id|is_out
)paren
)paren
(brace
id|usb_settoggle
(paren
id|urb-&gt;dev
comma
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
comma
id|is_out
comma
l_int|1
)paren
suffix:semicolon
id|urb_priv-&gt;ed-&gt;hwHeadP
op_and_assign
op_complement
id|ED_C
suffix:semicolon
)brace
id|urb_priv-&gt;td_cnt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|data_len
)paren
id|data
op_assign
id|urb-&gt;transfer_dma
suffix:semicolon
r_else
id|data
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* NOTE:  TD_CC is set so we can tell which TDs the HC processed by&n;&t; * using TD_CC_GET, as well as by seeing them on the done list.&n;&t; * (CC = NotAccessed ... 0x0F, or 0x0E in PSWs for ISO.)&n;&t; */
r_switch
c_cond
(paren
id|urb_priv-&gt;ed-&gt;type
)paren
(brace
multiline_comment|/* Bulk and interrupt are identical except for where in the schedule&n;&t; * their EDs live.&n;&t; */
r_case
id|PIPE_INTERRUPT
suffix:colon
multiline_comment|/* ... and periodic urbs have extra accounting */
id|hcd_to_bus
(paren
op_amp
id|ohci-&gt;hcd
)paren
op_member_access_from_pointer
id|bandwidth_int_reqs
op_increment
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_case
id|PIPE_BULK
suffix:colon
id|info
op_assign
id|is_out
ques
c_cond
id|TD_T_TOGGLE
op_or
id|TD_CC
op_or
id|TD_DP_OUT
suffix:colon
id|TD_T_TOGGLE
op_or
id|TD_CC
op_or
id|TD_DP_IN
suffix:semicolon
multiline_comment|/* TDs _could_ transfer up to 8K each */
r_while
c_loop
(paren
id|data_len
OG
l_int|4096
)paren
(brace
id|td_fill
(paren
id|ohci
comma
id|info
comma
id|data
comma
l_int|4096
comma
id|urb
comma
id|cnt
)paren
suffix:semicolon
id|data
op_add_assign
l_int|4096
suffix:semicolon
id|data_len
op_sub_assign
l_int|4096
suffix:semicolon
id|cnt
op_increment
suffix:semicolon
)brace
multiline_comment|/* maybe avoid ED halt on final TD short read */
r_if
c_cond
(paren
op_logical_neg
(paren
id|urb-&gt;transfer_flags
op_amp
id|URB_SHORT_NOT_OK
)paren
)paren
id|info
op_or_assign
id|TD_R
suffix:semicolon
id|td_fill
(paren
id|ohci
comma
id|info
comma
id|data
comma
id|data_len
comma
id|urb
comma
id|cnt
)paren
suffix:semicolon
id|cnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|urb-&gt;transfer_flags
op_amp
id|URB_ZERO_PACKET
)paren
op_logical_and
id|cnt
OL
id|urb_priv-&gt;length
)paren
(brace
id|td_fill
(paren
id|ohci
comma
id|info
comma
l_int|0
comma
l_int|0
comma
id|urb
comma
id|cnt
)paren
suffix:semicolon
id|cnt
op_increment
suffix:semicolon
)brace
multiline_comment|/* maybe kickstart bulk list */
r_if
c_cond
(paren
id|urb_priv-&gt;ed-&gt;type
op_eq
id|PIPE_BULK
)paren
(brace
id|wmb
(paren
)paren
suffix:semicolon
id|writel
(paren
id|OHCI_BLF
comma
op_amp
id|ohci-&gt;regs-&gt;cmdstatus
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* control manages DATA0/DATA1 toggle per-request; SETUP resets it,&n;&t; * any DATA phase works normally, and the STATUS ack is special.&n;&t; */
r_case
id|PIPE_CONTROL
suffix:colon
id|info
op_assign
id|TD_CC
op_or
id|TD_DP_SETUP
op_or
id|TD_T_DATA0
suffix:semicolon
id|td_fill
(paren
id|ohci
comma
id|info
comma
id|urb-&gt;setup_dma
comma
l_int|8
comma
id|urb
comma
id|cnt
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data_len
OG
l_int|0
)paren
(brace
id|info
op_assign
id|TD_CC
op_or
id|TD_R
op_or
id|TD_T_DATA1
suffix:semicolon
id|info
op_or_assign
id|is_out
ques
c_cond
id|TD_DP_OUT
suffix:colon
id|TD_DP_IN
suffix:semicolon
multiline_comment|/* NOTE:  mishandles transfers &gt;8K, some &gt;4K */
id|td_fill
(paren
id|ohci
comma
id|info
comma
id|data
comma
id|data_len
comma
id|urb
comma
id|cnt
op_increment
)paren
suffix:semicolon
)brace
id|info
op_assign
id|is_out
ques
c_cond
id|TD_CC
op_or
id|TD_DP_IN
op_or
id|TD_T_DATA1
suffix:colon
id|TD_CC
op_or
id|TD_DP_OUT
op_or
id|TD_T_DATA1
suffix:semicolon
id|td_fill
(paren
id|ohci
comma
id|info
comma
id|data
comma
l_int|0
comma
id|urb
comma
id|cnt
op_increment
)paren
suffix:semicolon
multiline_comment|/* maybe kickstart control list */
id|wmb
(paren
)paren
suffix:semicolon
id|writel
(paren
id|OHCI_CLF
comma
op_amp
id|ohci-&gt;regs-&gt;cmdstatus
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* ISO has no retransmit, so no toggle; and it uses special TDs.&n;&t; * Each TD could handle multiple consecutive frames (interval 1);&n;&t; * we could often reduce the number of TDs here.&n;&t; */
r_case
id|PIPE_ISOCHRONOUS
suffix:colon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_int
id|frame
op_assign
id|urb-&gt;start_frame
suffix:semicolon
singleline_comment|// FIXME scheduling should handle frame counter
singleline_comment|// roll-around ... exotic case (and OHCI has
singleline_comment|// a 2^16 iso range, vs other HCs max of 2^10)
id|frame
op_add_assign
id|cnt
op_star
id|urb-&gt;interval
suffix:semicolon
id|frame
op_and_assign
l_int|0xffff
suffix:semicolon
id|td_fill
(paren
id|ohci
comma
id|TD_CC
op_or
id|TD_ISO
op_or
id|frame
comma
id|data
op_plus
id|urb-&gt;iso_frame_desc
(braket
id|cnt
)braket
dot
id|offset
comma
id|urb-&gt;iso_frame_desc
(braket
id|cnt
)braket
dot
id|length
comma
id|urb
comma
id|cnt
)paren
suffix:semicolon
)brace
id|hcd_to_bus
(paren
op_amp
id|ohci-&gt;hcd
)paren
op_member_access_from_pointer
id|bandwidth_isoc_reqs
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
singleline_comment|// ASSERT (urb_priv-&gt;length == cnt);
)brace
multiline_comment|/*-------------------------------------------------------------------------*&n; * Done List handling functions&n; *-------------------------------------------------------------------------*/
multiline_comment|/* calculate transfer length/status and update the urb&n; * PRECONDITION:  irqsafe (only for urb-&gt;status locking)&n; */
DECL|function|td_done
r_static
r_void
id|td_done
(paren
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|td
op_star
id|td
)paren
(brace
id|u32
id|tdINFO
op_assign
id|le32_to_cpup
(paren
op_amp
id|td-&gt;hwINFO
)paren
suffix:semicolon
r_int
id|cc
op_assign
l_int|0
suffix:semicolon
id|list_del
(paren
op_amp
id|td-&gt;td_list
)paren
suffix:semicolon
multiline_comment|/* ISO ... drivers see per-TD length/status */
r_if
c_cond
(paren
id|tdINFO
op_amp
id|TD_ISO
)paren
(brace
id|u16
id|tdPSW
op_assign
id|le16_to_cpu
(paren
id|td-&gt;hwPSW
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_int
id|dlen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* NOTE:  assumes FC in tdINFO == 0 (and MAXPSW == 1) */
id|cc
op_assign
(paren
id|tdPSW
op_rshift
l_int|12
)paren
op_amp
l_int|0xF
suffix:semicolon
r_if
c_cond
(paren
id|tdINFO
op_amp
id|TD_CC
)paren
multiline_comment|/* hc didn&squot;t touch? */
r_return
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
)paren
id|dlen
op_assign
id|urb-&gt;iso_frame_desc
(braket
id|td-&gt;index
)braket
dot
id|length
suffix:semicolon
r_else
(brace
multiline_comment|/* short reads are always OK for ISO */
r_if
c_cond
(paren
id|cc
op_eq
id|TD_DATAUNDERRUN
)paren
id|cc
op_assign
id|TD_CC_NOERROR
suffix:semicolon
id|dlen
op_assign
id|tdPSW
op_amp
l_int|0x3ff
suffix:semicolon
)brace
id|urb-&gt;actual_length
op_add_assign
id|dlen
suffix:semicolon
id|urb-&gt;iso_frame_desc
(braket
id|td-&gt;index
)braket
dot
id|actual_length
op_assign
id|dlen
suffix:semicolon
id|urb-&gt;iso_frame_desc
(braket
id|td-&gt;index
)braket
dot
id|status
op_assign
id|cc_to_error
(braket
id|cc
)braket
suffix:semicolon
r_if
c_cond
(paren
id|cc
op_ne
id|TD_CC_NOERROR
)paren
id|ohci_vdbg
(paren
id|ohci
comma
l_string|&quot;urb %p iso td %p (%d) len %d cc %d&bslash;n&quot;
comma
id|urb
comma
id|td
comma
l_int|1
op_plus
id|td-&gt;index
comma
id|dlen
comma
id|cc
)paren
suffix:semicolon
multiline_comment|/* BULK, INT, CONTROL ... drivers see aggregate length/status,&n;&t; * except that &quot;setup&quot; bytes aren&squot;t counted and &quot;short&quot; transfers&n;&t; * might not be reported as errors.&n;&t; */
)brace
r_else
(brace
r_int
id|type
op_assign
id|usb_pipetype
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
id|u32
id|tdBE
op_assign
id|le32_to_cpup
(paren
op_amp
id|td-&gt;hwBE
)paren
suffix:semicolon
id|cc
op_assign
id|TD_CC_GET
(paren
id|tdINFO
)paren
suffix:semicolon
multiline_comment|/* control endpoints only have soft stalls */
r_if
c_cond
(paren
id|type
op_ne
id|PIPE_CONTROL
op_logical_and
id|cc
op_eq
id|TD_CC_STALL
)paren
id|usb_endpoint_halt
(paren
id|urb-&gt;dev
comma
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
comma
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
multiline_comment|/* update packet status if needed (short is normally ok) */
r_if
c_cond
(paren
id|cc
op_eq
id|TD_DATAUNDERRUN
op_logical_and
op_logical_neg
(paren
id|urb-&gt;transfer_flags
op_amp
id|URB_SHORT_NOT_OK
)paren
)paren
id|cc
op_assign
id|TD_CC_NOERROR
suffix:semicolon
r_if
c_cond
(paren
id|cc
op_ne
id|TD_CC_NOERROR
op_logical_and
id|cc
OL
l_int|0x0E
)paren
(brace
id|spin_lock
(paren
op_amp
id|urb-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
id|urb-&gt;status
op_assign
id|cc_to_error
(braket
id|cc
)braket
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|urb-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/* count all non-empty packets except control SETUP packet */
r_if
c_cond
(paren
(paren
id|type
op_ne
id|PIPE_CONTROL
op_logical_or
id|td-&gt;index
op_ne
l_int|0
)paren
op_logical_and
id|tdBE
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|td-&gt;hwCBP
op_eq
l_int|0
)paren
id|urb-&gt;actual_length
op_add_assign
id|tdBE
op_minus
id|td-&gt;data_dma
op_plus
l_int|1
suffix:semicolon
r_else
id|urb-&gt;actual_length
op_add_assign
id|le32_to_cpup
(paren
op_amp
id|td-&gt;hwCBP
)paren
op_minus
id|td-&gt;data_dma
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cc
op_ne
id|TD_CC_NOERROR
op_logical_and
id|cc
OL
l_int|0x0E
)paren
id|ohci_vdbg
(paren
id|ohci
comma
l_string|&quot;urb %p td %p (%d) cc %d, len=%d/%d&bslash;n&quot;
comma
id|urb
comma
id|td
comma
l_int|1
op_plus
id|td-&gt;index
comma
id|cc
comma
id|urb-&gt;actual_length
comma
id|urb-&gt;transfer_buffer_length
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
r_static
r_inline
r_struct
id|td
op_star
DECL|function|ed_halted
id|ed_halted
(paren
r_struct
id|ohci_hcd
op_star
id|ohci
comma
r_struct
id|td
op_star
id|td
comma
r_int
id|cc
comma
r_struct
id|td
op_star
id|rev
)paren
(brace
r_struct
id|urb
op_star
id|urb
op_assign
id|td-&gt;urb
suffix:semicolon
r_struct
id|ed
op_star
id|ed
op_assign
id|td-&gt;ed
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
op_assign
id|td-&gt;td_list.next
suffix:semicolon
id|u32
id|toggle
op_assign
id|ed-&gt;hwHeadP
op_amp
id|ED_C
suffix:semicolon
multiline_comment|/* clear ed halt; this is the td that caused it, but keep it inactive&n;&t; * until its urb-&gt;complete() has a chance to clean up.&n;&t; */
id|ed-&gt;hwINFO
op_or_assign
id|ED_SKIP
suffix:semicolon
id|wmb
(paren
)paren
suffix:semicolon
id|ed-&gt;hwHeadP
op_and_assign
op_complement
id|ED_H
suffix:semicolon
multiline_comment|/* put any later tds from this urb onto the donelist, after &squot;td&squot;,&n;&t; * order won&squot;t matter here: no errors, and nothing was transferred.&n;&t; * also patch the ed so it looks as if those tds completed normally.&n;&t; */
r_while
c_loop
(paren
id|tmp
op_ne
op_amp
id|ed-&gt;td_list
)paren
(brace
r_struct
id|td
op_star
id|next
suffix:semicolon
id|u32
id|info
suffix:semicolon
id|next
op_assign
id|list_entry
(paren
id|tmp
comma
r_struct
id|td
comma
id|td_list
)paren
suffix:semicolon
id|tmp
op_assign
id|next-&gt;td_list.next
suffix:semicolon
r_if
c_cond
(paren
id|next-&gt;urb
op_ne
id|urb
)paren
r_break
suffix:semicolon
multiline_comment|/* NOTE: if multi-td control DATA segments get supported,&n;&t;&t; * this urb had one of them, this td wasn&squot;t the last td&n;&t;&t; * in that segment (TD_R clear), this ed halted because&n;&t;&t; * of a short read, _and_ URB_SHORT_NOT_OK is clear ...&n;&t;&t; * then we need to leave the control STATUS packet queued&n;&t;&t; * and clear ED_SKIP.&n;&t;&t; */
id|info
op_assign
id|next-&gt;hwINFO
suffix:semicolon
id|info
op_or_assign
id|cpu_to_le32
(paren
id|TD_DONE
)paren
suffix:semicolon
id|info
op_and_assign
op_complement
id|cpu_to_le32
(paren
id|TD_CC
)paren
suffix:semicolon
id|next-&gt;hwINFO
op_assign
id|info
suffix:semicolon
id|next-&gt;next_dl_td
op_assign
id|rev
suffix:semicolon
id|rev
op_assign
id|next
suffix:semicolon
r_if
c_cond
(paren
id|ed-&gt;hwTailP
op_eq
id|cpu_to_le32
(paren
id|next-&gt;td_dma
)paren
)paren
id|ed-&gt;hwTailP
op_assign
id|next-&gt;hwNextTD
suffix:semicolon
id|ed-&gt;hwHeadP
op_assign
id|next-&gt;hwNextTD
op_or
id|toggle
suffix:semicolon
)brace
multiline_comment|/* help for troubleshooting:  report anything that&n;&t; * looks odd ... that doesn&squot;t include protocol stalls&n;&t; * (or maybe some other things)&n;&t; */
r_if
c_cond
(paren
id|cc
op_ne
id|TD_CC_STALL
op_logical_or
op_logical_neg
id|usb_pipecontrol
(paren
id|urb-&gt;pipe
)paren
)paren
id|ohci_dbg
(paren
id|ohci
comma
l_string|&quot;urb %p path %s ep%d%s %08x cc %d --&gt; status %d&bslash;n&quot;
comma
id|urb
comma
id|urb-&gt;dev-&gt;devpath
comma
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
comma
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
ques
c_cond
l_string|&quot;in&quot;
suffix:colon
l_string|&quot;out&quot;
comma
id|le32_to_cpu
(paren
id|td-&gt;hwINFO
)paren
comma
id|cc
comma
id|cc_to_error
(braket
id|cc
)braket
)paren
suffix:semicolon
r_return
id|rev
suffix:semicolon
)brace
multiline_comment|/* replies to the request have to be on a FIFO basis so&n; * we unreverse the hc-reversed done-list&n; */
DECL|function|dl_reverse_done_list
r_static
r_struct
id|td
op_star
id|dl_reverse_done_list
(paren
r_struct
id|ohci_hcd
op_star
id|ohci
)paren
(brace
id|u32
id|td_dma
suffix:semicolon
r_struct
id|td
op_star
id|td_rev
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|td
op_star
id|td
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ohci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|td_dma
op_assign
id|le32_to_cpup
(paren
op_amp
id|ohci-&gt;hcca-&gt;done_head
)paren
suffix:semicolon
id|ohci-&gt;hcca-&gt;done_head
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* get TD from hc&squot;s singly linked list, and&n;&t; * prepend to ours.  ed-&gt;td_list changes later.&n;&t; */
r_while
c_loop
(paren
id|td_dma
)paren
(brace
r_int
id|cc
suffix:semicolon
id|td
op_assign
id|dma_to_td
(paren
id|ohci
comma
id|td_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|td
)paren
(brace
id|ohci_err
(paren
id|ohci
comma
l_string|&quot;bad entry %8x&bslash;n&quot;
comma
id|td_dma
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|td-&gt;hwINFO
op_or_assign
id|cpu_to_le32
(paren
id|TD_DONE
)paren
suffix:semicolon
id|cc
op_assign
id|TD_CC_GET
(paren
id|le32_to_cpup
(paren
op_amp
id|td-&gt;hwINFO
)paren
)paren
suffix:semicolon
multiline_comment|/* Non-iso endpoints can halt on error; un-halt,&n;&t;&t; * and dequeue any other TDs from this urb.&n;&t;&t; * No other TD could have caused the halt.&n;&t;&t; */
r_if
c_cond
(paren
id|cc
op_ne
id|TD_CC_NOERROR
op_logical_and
(paren
id|td-&gt;ed-&gt;hwHeadP
op_amp
id|ED_H
)paren
)paren
id|td_rev
op_assign
id|ed_halted
(paren
id|ohci
comma
id|td
comma
id|cc
comma
id|td_rev
)paren
suffix:semicolon
id|td-&gt;next_dl_td
op_assign
id|td_rev
suffix:semicolon
id|td_rev
op_assign
id|td
suffix:semicolon
id|td_dma
op_assign
id|le32_to_cpup
(paren
op_amp
id|td-&gt;hwNextTD
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ohci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|td_rev
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* wrap-aware logic stolen from &lt;linux/jiffies.h&gt; */
DECL|macro|tick_before
mdefine_line|#define tick_before(t1,t2) ((((s16)(t1))-((s16)(t2))) &lt; 0)
multiline_comment|/* there are some urbs/eds to unlink; called in_irq(), with HCD locked */
DECL|function|finish_unlinks
r_static
r_void
id|finish_unlinks
(paren
r_struct
id|ohci_hcd
op_star
id|ohci
comma
id|u16
id|tick
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|ed
op_star
id|ed
comma
op_star
op_star
id|last
suffix:semicolon
id|rescan_all
suffix:colon
r_for
c_loop
(paren
id|last
op_assign
op_amp
id|ohci-&gt;ed_rm_list
comma
id|ed
op_assign
op_star
id|last
suffix:semicolon
id|ed
op_ne
l_int|NULL
suffix:semicolon
id|ed
op_assign
op_star
id|last
)paren
(brace
r_struct
id|list_head
op_star
id|entry
comma
op_star
id|tmp
suffix:semicolon
r_int
id|completed
comma
id|modified
suffix:semicolon
id|u32
op_star
id|prev
suffix:semicolon
multiline_comment|/* only take off EDs that the HC isn&squot;t using, accounting for&n;&t;&t; * frame counter wraps.&n;&t;&t; */
r_if
c_cond
(paren
id|tick_before
(paren
id|tick
comma
id|ed-&gt;tick
)paren
op_logical_and
op_logical_neg
id|ohci-&gt;disabled
)paren
(brace
id|last
op_assign
op_amp
id|ed-&gt;ed_next
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* reentrancy:  if we drop the schedule lock, someone might&n;&t;&t; * have modified this list.  normally it&squot;s just prepending&n;&t;&t; * entries (which we&squot;d ignore), but paranoia won&squot;t hurt.&n;&t;&t; */
op_star
id|last
op_assign
id|ed-&gt;ed_next
suffix:semicolon
id|ed-&gt;ed_next
op_assign
l_int|0
suffix:semicolon
id|modified
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* unlink urbs as requested, but rescan the list after&n;&t;&t; * we call a completion since it might have unlinked&n;&t;&t; * another (earlier) urb&n;&t;&t; */
id|rescan_this
suffix:colon
id|completed
op_assign
l_int|0
suffix:semicolon
id|prev
op_assign
op_amp
id|ed-&gt;hwHeadP
suffix:semicolon
id|list_for_each_safe
(paren
id|entry
comma
id|tmp
comma
op_amp
id|ed-&gt;td_list
)paren
(brace
r_struct
id|td
op_star
id|td
suffix:semicolon
r_struct
id|urb
op_star
id|urb
suffix:semicolon
id|urb_priv_t
op_star
id|urb_priv
suffix:semicolon
id|u32
id|savebits
suffix:semicolon
id|td
op_assign
id|list_entry
(paren
id|entry
comma
r_struct
id|td
comma
id|td_list
)paren
suffix:semicolon
id|urb
op_assign
id|td-&gt;urb
suffix:semicolon
id|urb_priv
op_assign
id|td-&gt;urb-&gt;hcpriv
suffix:semicolon
r_if
c_cond
(paren
id|urb_priv-&gt;state
op_ne
id|URB_DEL
)paren
(brace
id|prev
op_assign
op_amp
id|td-&gt;hwNextTD
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* patch pointers hc uses ... tail, if we&squot;re removing&n;&t;&t;&t; * an otherwise active td, and whatever td pointer&n;&t;&t;&t; * points to this td&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ed-&gt;hwTailP
op_eq
id|cpu_to_le32
(paren
id|td-&gt;td_dma
)paren
)paren
id|ed-&gt;hwTailP
op_assign
id|td-&gt;hwNextTD
suffix:semicolon
id|savebits
op_assign
op_star
id|prev
op_amp
op_complement
id|cpu_to_le32
(paren
id|TD_MASK
)paren
suffix:semicolon
op_star
id|prev
op_assign
id|td-&gt;hwNextTD
op_or
id|savebits
suffix:semicolon
multiline_comment|/* HC may have partly processed this TD */
id|td_done
(paren
id|urb
comma
id|td
)paren
suffix:semicolon
id|urb_priv-&gt;td_cnt
op_increment
suffix:semicolon
multiline_comment|/* if URB is done, clean up */
r_if
c_cond
(paren
id|urb_priv-&gt;td_cnt
op_eq
id|urb_priv-&gt;length
)paren
(brace
id|modified
op_assign
id|completed
op_assign
l_int|1
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|ohci-&gt;lock
)paren
suffix:semicolon
id|finish_urb
(paren
id|ohci
comma
id|urb
comma
id|regs
)paren
suffix:semicolon
id|spin_lock
(paren
op_amp
id|ohci-&gt;lock
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|completed
op_logical_and
op_logical_neg
id|list_empty
(paren
op_amp
id|ed-&gt;td_list
)paren
)paren
r_goto
id|rescan_this
suffix:semicolon
multiline_comment|/* ED&squot;s now officially unlinked, hc doesn&squot;t see */
id|ed-&gt;state
op_assign
id|ED_IDLE
suffix:semicolon
id|ed-&gt;hwINFO
op_and_assign
op_complement
(paren
id|ED_SKIP
op_or
id|ED_DEQUEUE
)paren
suffix:semicolon
id|ed-&gt;hwHeadP
op_and_assign
op_complement
id|ED_H
suffix:semicolon
id|ed-&gt;hwNextED
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* but if there&squot;s work queued, reschedule */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|ed-&gt;td_list
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ohci-&gt;disabled
op_logical_and
op_logical_neg
id|ohci-&gt;sleeping
)paren
id|ed_schedule
(paren
id|ohci
comma
id|ed
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|modified
)paren
r_goto
id|rescan_all
suffix:semicolon
)brace
multiline_comment|/* maybe reenable control and bulk lists */
r_if
c_cond
(paren
op_logical_neg
id|ohci-&gt;disabled
op_logical_and
op_logical_neg
id|ohci-&gt;ed_rm_list
)paren
(brace
id|u32
id|command
op_assign
l_int|0
comma
id|control
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ohci-&gt;ed_controltail
)paren
(brace
id|command
op_or_assign
id|OHCI_CLF
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ohci-&gt;hc_control
op_amp
id|OHCI_CTRL_CLE
)paren
)paren
(brace
id|control
op_or_assign
id|OHCI_CTRL_CLE
suffix:semicolon
id|writel
(paren
l_int|0
comma
op_amp
id|ohci-&gt;regs-&gt;ed_controlcurrent
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ohci-&gt;ed_bulktail
)paren
(brace
id|command
op_or_assign
id|OHCI_BLF
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ohci-&gt;hc_control
op_amp
id|OHCI_CTRL_BLE
)paren
)paren
(brace
id|control
op_or_assign
id|OHCI_CTRL_BLE
suffix:semicolon
id|writel
(paren
l_int|0
comma
op_amp
id|ohci-&gt;regs-&gt;ed_bulkcurrent
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* CLE/BLE to enable, CLF/BLF to (maybe) kickstart */
r_if
c_cond
(paren
id|control
)paren
(brace
id|ohci-&gt;hc_control
op_or_assign
id|control
suffix:semicolon
id|writel
(paren
id|ohci-&gt;hc_control
comma
op_amp
id|ohci-&gt;regs-&gt;control
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|command
)paren
id|writel
(paren
id|command
comma
op_amp
id|ohci-&gt;regs-&gt;cmdstatus
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * Process normal completions (error or success) and clean the schedules.&n; *&n; * This is the main path for handing urbs back to drivers.  The only other&n; * path is finish_unlinks(), which unlinks URBs using ed_rm_list, instead of&n; * scanning the (re-reversed) donelist as this does.&n; */
DECL|function|dl_done_list
r_static
r_void
id|dl_done_list
(paren
r_struct
id|ohci_hcd
op_star
id|ohci
comma
r_struct
id|td
op_star
id|td
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ohci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
id|td
)paren
(brace
r_struct
id|td
op_star
id|td_next
op_assign
id|td-&gt;next_dl_td
suffix:semicolon
r_struct
id|urb
op_star
id|urb
op_assign
id|td-&gt;urb
suffix:semicolon
id|urb_priv_t
op_star
id|urb_priv
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
r_struct
id|ed
op_star
id|ed
op_assign
id|td-&gt;ed
suffix:semicolon
multiline_comment|/* update URB&squot;s length and status from TD */
id|td_done
(paren
id|urb
comma
id|td
)paren
suffix:semicolon
id|urb_priv-&gt;td_cnt
op_increment
suffix:semicolon
multiline_comment|/* If all this urb&squot;s TDs are done, call complete() */
r_if
c_cond
(paren
id|urb_priv-&gt;td_cnt
op_eq
id|urb_priv-&gt;length
)paren
(brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ohci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|finish_urb
(paren
id|ohci
comma
id|urb
comma
id|regs
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ohci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* clean schedule:  unlink EDs that are no longer busy */
r_if
c_cond
(paren
id|list_empty
(paren
op_amp
id|ed-&gt;td_list
)paren
)paren
id|ed_deschedule
(paren
id|ohci
comma
id|ed
)paren
suffix:semicolon
multiline_comment|/* ... reenabling halted EDs only after fault cleanup */
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|ed-&gt;hwINFO
op_amp
id|ED_DEQUEUE
)paren
)paren
(brace
id|td
op_assign
id|list_entry
(paren
id|ed-&gt;td_list.next
comma
r_struct
id|td
comma
id|td_list
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|td-&gt;hwINFO
op_amp
id|TD_DONE
)paren
)paren
id|ed-&gt;hwINFO
op_and_assign
op_complement
id|ED_SKIP
suffix:semicolon
)brace
id|td
op_assign
id|td_next
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ohci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
eof
