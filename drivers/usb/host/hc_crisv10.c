multiline_comment|/*&n; * usb-host.c: ETRAX 100LX USB Host Controller Driver (HCD)&n; *&n; * Copyright (c) 2002, 2003 Axis Communications AB.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/arch/svinto.h&gt;
macro_line|#include &lt;linux/usb.h&gt;
multiline_comment|/* Ugly include because we don&squot;t live with the other host drivers. */
macro_line|#include &lt;../drivers/usb/core/hcd.h&gt;
macro_line|#include &lt;../drivers/usb/core/usb.h&gt;
macro_line|#include &quot;hc_crisv10.h&quot;
DECL|macro|ETRAX_USB_HC_IRQ
mdefine_line|#define ETRAX_USB_HC_IRQ USB_HC_IRQ_NBR
DECL|macro|ETRAX_USB_RX_IRQ
mdefine_line|#define ETRAX_USB_RX_IRQ USB_DMA_RX_IRQ_NBR
DECL|macro|ETRAX_USB_TX_IRQ
mdefine_line|#define ETRAX_USB_TX_IRQ USB_DMA_TX_IRQ_NBR
DECL|variable|usb_hcd_version
r_static
r_const
r_char
op_star
id|usb_hcd_version
op_assign
l_string|&quot;$Revision: 1.2 $&quot;
suffix:semicolon
DECL|macro|KERN_DEBUG
macro_line|#undef KERN_DEBUG
DECL|macro|KERN_DEBUG
mdefine_line|#define KERN_DEBUG &quot;&quot;
DECL|macro|USB_DEBUG_RH
macro_line|#undef USB_DEBUG_RH
DECL|macro|USB_DEBUG_EPID
macro_line|#undef USB_DEBUG_EPID
DECL|macro|USB_DEBUG_SB
macro_line|#undef USB_DEBUG_SB
DECL|macro|USB_DEBUG_DESC
macro_line|#undef USB_DEBUG_DESC
DECL|macro|USB_DEBUG_URB
macro_line|#undef USB_DEBUG_URB
DECL|macro|USB_DEBUG_TRACE
macro_line|#undef USB_DEBUG_TRACE
DECL|macro|USB_DEBUG_BULK
macro_line|#undef USB_DEBUG_BULK
DECL|macro|USB_DEBUG_CTRL
macro_line|#undef USB_DEBUG_CTRL
DECL|macro|USB_DEBUG_INTR
macro_line|#undef USB_DEBUG_INTR
DECL|macro|USB_DEBUG_ISOC
macro_line|#undef USB_DEBUG_ISOC
macro_line|#ifdef USB_DEBUG_RH
DECL|macro|dbg_rh
mdefine_line|#define dbg_rh(format, arg...) printk(KERN_DEBUG __FILE__ &quot;: (RH) &quot; format &quot;&bslash;n&quot; , ## arg)
macro_line|#else
DECL|macro|dbg_rh
mdefine_line|#define dbg_rh(format, arg...) do {} while (0)
macro_line|#endif
macro_line|#ifdef USB_DEBUG_EPID
DECL|macro|dbg_epid
mdefine_line|#define dbg_epid(format, arg...) printk(KERN_DEBUG __FILE__ &quot;: (EPID) &quot; format &quot;&bslash;n&quot; , ## arg)
macro_line|#else
DECL|macro|dbg_epid
mdefine_line|#define dbg_epid(format, arg...) do {} while (0)
macro_line|#endif
macro_line|#ifdef USB_DEBUG_SB
DECL|macro|dbg_sb
mdefine_line|#define dbg_sb(format, arg...) printk(KERN_DEBUG __FILE__ &quot;: (SB) &quot; format &quot;&bslash;n&quot; , ## arg)
macro_line|#else
DECL|macro|dbg_sb
mdefine_line|#define dbg_sb(format, arg...) do {} while (0)
macro_line|#endif
macro_line|#ifdef USB_DEBUG_CTRL
DECL|macro|dbg_ctrl
mdefine_line|#define dbg_ctrl(format, arg...) printk(KERN_DEBUG __FILE__ &quot;: (CTRL) &quot; format &quot;&bslash;n&quot; , ## arg)
macro_line|#else
DECL|macro|dbg_ctrl
mdefine_line|#define dbg_ctrl(format, arg...) do {} while (0)
macro_line|#endif
macro_line|#ifdef USB_DEBUG_BULK
DECL|macro|dbg_bulk
mdefine_line|#define dbg_bulk(format, arg...) printk(KERN_DEBUG __FILE__ &quot;: (BULK) &quot; format &quot;&bslash;n&quot; , ## arg)
macro_line|#else
DECL|macro|dbg_bulk
mdefine_line|#define dbg_bulk(format, arg...) do {} while (0)
macro_line|#endif
macro_line|#ifdef USB_DEBUG_INTR
DECL|macro|dbg_intr
mdefine_line|#define dbg_intr(format, arg...) printk(KERN_DEBUG __FILE__ &quot;: (INTR) &quot; format &quot;&bslash;n&quot; , ## arg)
macro_line|#else
DECL|macro|dbg_intr
mdefine_line|#define dbg_intr(format, arg...) do {} while (0)
macro_line|#endif
macro_line|#ifdef USB_DEBUG_ISOC
DECL|macro|dbg_isoc
mdefine_line|#define dbg_isoc(format, arg...) printk(KERN_DEBUG __FILE__ &quot;: (ISOC) &quot; format &quot;&bslash;n&quot; , ## arg)
macro_line|#else
DECL|macro|dbg_isoc
mdefine_line|#define dbg_isoc(format, arg...) do {} while (0)
macro_line|#endif
macro_line|#ifdef USB_DEBUG_TRACE
DECL|macro|DBFENTER
mdefine_line|#define DBFENTER (printk(&quot;: Entering: %s&bslash;n&quot;, __FUNCTION__))
DECL|macro|DBFEXIT
mdefine_line|#define DBFEXIT  (printk(&quot;: Exiting:  %s&bslash;n&quot;, __FUNCTION__))
macro_line|#else
DECL|macro|DBFENTER
mdefine_line|#define DBFENTER do {} while (0)
DECL|macro|DBFEXIT
mdefine_line|#define DBFEXIT  do {} while (0)
macro_line|#endif
DECL|macro|usb_pipeslow
mdefine_line|#define usb_pipeslow(pipe)&t;(((pipe) &gt;&gt; 26) &amp; 1)
multiline_comment|/*-------------------------------------------------------------------&n; Virtual Root Hub&n; -------------------------------------------------------------------*/
DECL|variable|root_hub_dev_des
r_static
id|__u8
id|root_hub_dev_des
(braket
)braket
op_assign
(brace
l_int|0x12
comma
multiline_comment|/*  __u8  bLength; */
l_int|0x01
comma
multiline_comment|/*  __u8  bDescriptorType; Device */
l_int|0x00
comma
multiline_comment|/*  __le16 bcdUSB; v1.0 */
l_int|0x01
comma
l_int|0x09
comma
multiline_comment|/*  __u8  bDeviceClass; HUB_CLASSCODE */
l_int|0x00
comma
multiline_comment|/*  __u8  bDeviceSubClass; */
l_int|0x00
comma
multiline_comment|/*  __u8  bDeviceProtocol; */
l_int|0x08
comma
multiline_comment|/*  __u8  bMaxPacketSize0; 8 Bytes */
l_int|0x00
comma
multiline_comment|/*  __le16 idVendor; */
l_int|0x00
comma
l_int|0x00
comma
multiline_comment|/*  __le16 idProduct; */
l_int|0x00
comma
l_int|0x00
comma
multiline_comment|/*  __le16 bcdDevice; */
l_int|0x00
comma
l_int|0x00
comma
multiline_comment|/*  __u8  iManufacturer; */
l_int|0x02
comma
multiline_comment|/*  __u8  iProduct; */
l_int|0x01
comma
multiline_comment|/*  __u8  iSerialNumber; */
l_int|0x01
multiline_comment|/*  __u8  bNumConfigurations; */
)brace
suffix:semicolon
multiline_comment|/* Configuration descriptor */
DECL|variable|root_hub_config_des
r_static
id|__u8
id|root_hub_config_des
(braket
)braket
op_assign
(brace
l_int|0x09
comma
multiline_comment|/*  __u8  bLength; */
l_int|0x02
comma
multiline_comment|/*  __u8  bDescriptorType; Configuration */
l_int|0x19
comma
multiline_comment|/*  __u16 wTotalLength; */
l_int|0x00
comma
l_int|0x01
comma
multiline_comment|/*  __u8  bNumInterfaces; */
l_int|0x01
comma
multiline_comment|/*  __u8  bConfigurationValue; */
l_int|0x00
comma
multiline_comment|/*  __u8  iConfiguration; */
l_int|0x40
comma
multiline_comment|/*  __u8  bmAttributes; Bit 7: Bus-powered */
l_int|0x00
comma
multiline_comment|/*  __u8  MaxPower; */
multiline_comment|/* interface */
l_int|0x09
comma
multiline_comment|/*  __u8  if_bLength; */
l_int|0x04
comma
multiline_comment|/*  __u8  if_bDescriptorType; Interface */
l_int|0x00
comma
multiline_comment|/*  __u8  if_bInterfaceNumber; */
l_int|0x00
comma
multiline_comment|/*  __u8  if_bAlternateSetting; */
l_int|0x01
comma
multiline_comment|/*  __u8  if_bNumEndpoints; */
l_int|0x09
comma
multiline_comment|/*  __u8  if_bInterfaceClass; HUB_CLASSCODE */
l_int|0x00
comma
multiline_comment|/*  __u8  if_bInterfaceSubClass; */
l_int|0x00
comma
multiline_comment|/*  __u8  if_bInterfaceProtocol; */
l_int|0x00
comma
multiline_comment|/*  __u8  if_iInterface; */
multiline_comment|/* endpoint */
l_int|0x07
comma
multiline_comment|/*  __u8  ep_bLength; */
l_int|0x05
comma
multiline_comment|/*  __u8  ep_bDescriptorType; Endpoint */
l_int|0x81
comma
multiline_comment|/*  __u8  ep_bEndpointAddress; IN Endpoint 1 */
l_int|0x03
comma
multiline_comment|/*  __u8  ep_bmAttributes; Interrupt */
l_int|0x08
comma
multiline_comment|/*  __u16 ep_wMaxPacketSize; 8 Bytes */
l_int|0x00
comma
l_int|0xff
multiline_comment|/*  __u8  ep_bInterval; 255 ms */
)brace
suffix:semicolon
DECL|variable|root_hub_hub_des
r_static
id|__u8
id|root_hub_hub_des
(braket
)braket
op_assign
(brace
l_int|0x09
comma
multiline_comment|/*  __u8  bLength; */
l_int|0x29
comma
multiline_comment|/*  __u8  bDescriptorType; Hub-descriptor */
l_int|0x02
comma
multiline_comment|/*  __u8  bNbrPorts; */
l_int|0x00
comma
multiline_comment|/* __u16  wHubCharacteristics; */
l_int|0x00
comma
l_int|0x01
comma
multiline_comment|/*  __u8  bPwrOn2pwrGood; 2ms */
l_int|0x00
comma
multiline_comment|/*  __u8  bHubContrCurrent; 0 mA */
l_int|0x00
comma
multiline_comment|/*  __u8  DeviceRemovable; *** 7 Ports max *** */
l_int|0xff
multiline_comment|/*  __u8  PortPwrCtrlMask; *** 7 ports max *** */
)brace
suffix:semicolon
DECL|variable|bulk_start_timer
r_static
r_struct
id|timer_list
id|bulk_start_timer
op_assign
id|TIMER_INITIALIZER
c_func
(paren
l_int|NULL
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
DECL|variable|bulk_eot_timer
r_static
r_struct
id|timer_list
id|bulk_eot_timer
op_assign
id|TIMER_INITIALIZER
c_func
(paren
l_int|NULL
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* We want the start timer to expire before the eot timer, because the former might start&n;   traffic, thus making it unnecessary for the latter to time out. */
DECL|macro|BULK_START_TIMER_INTERVAL
mdefine_line|#define BULK_START_TIMER_INTERVAL (HZ/10) /* 100 ms */
DECL|macro|BULK_EOT_TIMER_INTERVAL
mdefine_line|#define BULK_EOT_TIMER_INTERVAL (HZ/10+2) /* 120 ms */
DECL|macro|OK
mdefine_line|#define OK(x) len = (x); dbg_rh(&quot;OK(%d): line: %d&quot;, x, __LINE__); break
DECL|macro|CHECK_ALIGN
mdefine_line|#define CHECK_ALIGN(x) if (((__u32)(x)) &amp; 0x00000003) &bslash;&n;{panic(&quot;Alignment check (DWORD) failed at %s:%s:%d&bslash;n&quot;, __FILE__, __FUNCTION__, __LINE__);}
DECL|macro|SLAB_FLAG
mdefine_line|#define SLAB_FLAG     (in_interrupt() ? SLAB_ATOMIC : SLAB_KERNEL)
DECL|macro|KMALLOC_FLAG
mdefine_line|#define KMALLOC_FLAG  (in_interrupt() ? GFP_ATOMIC : GFP_KERNEL)
multiline_comment|/* Most helpful debugging aid */
DECL|macro|assert
mdefine_line|#define assert(expr) ((void) ((expr) ? 0 : (err(&quot;assert failed at line %d&quot;,__LINE__))))
multiline_comment|/* Alternative assert define which stops after a failed assert. */
multiline_comment|/*&n;#define assert(expr)                                      &bslash;&n;{                                                         &bslash;&n;        if (!(expr)) {                                    &bslash;&n;                err(&quot;assert failed at line %d&quot;,__LINE__); &bslash;&n;                while (1);                                &bslash;&n;        }                                                 &bslash;&n;}&n;*/
multiline_comment|/* FIXME: Should RX_BUF_SIZE be a config option, or maybe we should adjust it dynamically?&n;   To adjust it dynamically we would have to get an interrupt when we reach the end&n;   of the rx descriptor list, or when we get close to the end, and then allocate more&n;   descriptors. */
DECL|macro|NBR_OF_RX_DESC
mdefine_line|#define NBR_OF_RX_DESC     512
DECL|macro|RX_DESC_BUF_SIZE
mdefine_line|#define RX_DESC_BUF_SIZE   1024
DECL|macro|RX_BUF_SIZE
mdefine_line|#define RX_BUF_SIZE        (NBR_OF_RX_DESC * RX_DESC_BUF_SIZE)
multiline_comment|/* The number of epids is, among other things, used for pre-allocating&n;   ctrl, bulk and isoc EP descriptors (one for each epid).&n;   Assumed to be &gt; 1 when initiating the DMA lists. */
DECL|macro|NBR_OF_EPIDS
mdefine_line|#define NBR_OF_EPIDS       32
multiline_comment|/* Support interrupt traffic intervals up to 128 ms. */
DECL|macro|MAX_INTR_INTERVAL
mdefine_line|#define MAX_INTR_INTERVAL 128
multiline_comment|/* If periodic traffic (intr or isoc) is to be used, then one entry in the EP table&n;   must be &quot;invalid&quot;. By this we mean that we shouldn&squot;t care about epid attentions&n;   for this epid, or at least handle them differently from epid attentions for &quot;valid&quot;&n;   epids. This define determines which one to use (don&squot;t change it). */
DECL|macro|INVALID_EPID
mdefine_line|#define INVALID_EPID     31
multiline_comment|/* A special epid for the bulk dummys. */
DECL|macro|DUMMY_EPID
mdefine_line|#define DUMMY_EPID       30
multiline_comment|/* This is just a software cache for the valid entries in R_USB_EPT_DATA. */
DECL|variable|epid_usage_bitmask
r_static
id|__u32
id|epid_usage_bitmask
suffix:semicolon
multiline_comment|/* A bitfield to keep information on in/out traffic is needed to uniquely identify&n;   an endpoint on a device, since the most significant bit which indicates traffic&n;   direction is lacking in the ep_id field (ETRAX epids can handle both in and&n;   out traffic on endpoints that are otherwise identical). The USB framework, however,&n;   relies on them to be handled separately.  For example, bulk IN and OUT urbs cannot&n;   be queued in the same list, since they would block each other. */
DECL|variable|epid_out_traffic
r_static
id|__u32
id|epid_out_traffic
suffix:semicolon
multiline_comment|/* DMA IN cache bug. Align the DMA IN buffers to 32 bytes, i.e. a cache line.&n;   Since RX_DESC_BUF_SIZE is 1024 is a multiple of 32, all rx buffers will be cache aligned. */
DECL|variable|RxBuf
r_static
r_volatile
r_int
r_char
id|RxBuf
(braket
id|RX_BUF_SIZE
)braket
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|32
)paren
)paren
)paren
suffix:semicolon
DECL|variable|RxDescList
r_static
r_volatile
id|USB_IN_Desc_t
id|RxDescList
(braket
id|NBR_OF_RX_DESC
)braket
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|4
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Pointers into RxDescList. */
DECL|variable|myNextRxDesc
r_static
r_volatile
id|USB_IN_Desc_t
op_star
id|myNextRxDesc
suffix:semicolon
DECL|variable|myLastRxDesc
r_static
r_volatile
id|USB_IN_Desc_t
op_star
id|myLastRxDesc
suffix:semicolon
DECL|variable|myPrevRxDesc
r_static
r_volatile
id|USB_IN_Desc_t
op_star
id|myPrevRxDesc
suffix:semicolon
multiline_comment|/* EP descriptors must be 32-bit aligned. */
DECL|variable|TxCtrlEPList
r_static
r_volatile
id|USB_EP_Desc_t
id|TxCtrlEPList
(braket
id|NBR_OF_EPIDS
)braket
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|4
)paren
)paren
)paren
suffix:semicolon
DECL|variable|TxBulkEPList
r_static
r_volatile
id|USB_EP_Desc_t
id|TxBulkEPList
(braket
id|NBR_OF_EPIDS
)braket
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|4
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* After each enabled bulk EP (IN or OUT) we put two disabled EP descriptors with the eol flag set,&n;   causing the DMA to stop the DMA channel. The first of these two has the intr flag set, which&n;   gives us a dma8_sub0_descr interrupt. When we receive this, we advance the DMA one step in the&n;   EP list and then restart the bulk channel, thus forcing a switch between bulk EP descriptors&n;   in each frame. */
DECL|variable|TxBulkDummyEPList
r_static
r_volatile
id|USB_EP_Desc_t
id|TxBulkDummyEPList
(braket
id|NBR_OF_EPIDS
)braket
(braket
l_int|2
)braket
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|4
)paren
)paren
)paren
suffix:semicolon
DECL|variable|TxIsocEPList
r_static
r_volatile
id|USB_EP_Desc_t
id|TxIsocEPList
(braket
id|NBR_OF_EPIDS
)braket
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|4
)paren
)paren
)paren
suffix:semicolon
DECL|variable|TxIsocSB_zout
r_static
r_volatile
id|USB_SB_Desc_t
id|TxIsocSB_zout
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|4
)paren
)paren
)paren
suffix:semicolon
DECL|variable|TxIntrEPList
r_static
r_volatile
id|USB_EP_Desc_t
id|TxIntrEPList
(braket
id|MAX_INTR_INTERVAL
)braket
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|4
)paren
)paren
)paren
suffix:semicolon
DECL|variable|TxIntrSB_zout
r_static
r_volatile
id|USB_SB_Desc_t
id|TxIntrSB_zout
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|4
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* A zout transfer makes a memory access at the address of its buf pointer, which means that setting&n;   this buf pointer to 0 will cause an access to the flash. In addition to this, setting sw_len to 0&n;   results in a 16/32 bytes (depending on DMA burst size) transfer. Instead, we set it to 1, and point&n;   it to this buffer. */
DECL|variable|zout_buffer
r_static
r_int
id|zout_buffer
(braket
l_int|4
)braket
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|4
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Cache for allocating new EP and SB descriptors. */
DECL|variable|usb_desc_cache
r_static
id|kmem_cache_t
op_star
id|usb_desc_cache
suffix:semicolon
multiline_comment|/* Cache for the registers allocated in the top half. */
DECL|variable|top_half_reg_cache
r_static
id|kmem_cache_t
op_star
id|top_half_reg_cache
suffix:semicolon
multiline_comment|/* Cache for the data allocated in the isoc descr top half. */
DECL|variable|isoc_compl_cache
r_static
id|kmem_cache_t
op_star
id|isoc_compl_cache
suffix:semicolon
DECL|variable|etrax_usb_bus
r_static
r_struct
id|usb_bus
op_star
id|etrax_usb_bus
suffix:semicolon
multiline_comment|/* This is a circular (double-linked) list of the active urbs for each epid.&n;   The head is never removed, and new urbs are linked onto the list as&n;   urb_entry_t elements. Don&squot;t reference urb_list directly; use the wrapper&n;   functions instead. Note that working with these lists might require spinlock&n;   protection. */
DECL|variable|urb_list
r_static
r_struct
id|list_head
id|urb_list
(braket
id|NBR_OF_EPIDS
)braket
suffix:semicolon
multiline_comment|/* Read about the need and usage of this lock in submit_ctrl_urb. */
DECL|variable|urb_list_lock
r_static
id|spinlock_t
id|urb_list_lock
suffix:semicolon
multiline_comment|/* Used when unlinking asynchronously. */
DECL|variable|urb_unlink_list
r_static
r_struct
id|list_head
id|urb_unlink_list
suffix:semicolon
multiline_comment|/* for returning string descriptors in UTF-16LE */
DECL|function|ascii2utf
r_static
r_int
id|ascii2utf
(paren
r_char
op_star
id|ascii
comma
id|__u8
op_star
id|utf
comma
r_int
id|utfmax
)paren
(brace
r_int
id|retval
suffix:semicolon
r_for
c_loop
(paren
id|retval
op_assign
l_int|0
suffix:semicolon
op_star
id|ascii
op_logical_and
id|utfmax
OG
l_int|1
suffix:semicolon
id|utfmax
op_sub_assign
l_int|2
comma
id|retval
op_add_assign
l_int|2
)paren
(brace
op_star
id|utf
op_increment
op_assign
op_star
id|ascii
op_increment
op_amp
l_int|0x7f
suffix:semicolon
op_star
id|utf
op_increment
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
DECL|function|usb_root_hub_string
r_static
r_int
id|usb_root_hub_string
(paren
r_int
id|id
comma
r_int
id|serial
comma
r_char
op_star
id|type
comma
id|__u8
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_char
id|buf
(braket
l_int|30
)braket
suffix:semicolon
singleline_comment|// assert (len &gt; (2 * (sizeof (buf) + 1)));
singleline_comment|// assert (strlen (type) &lt;= 8);
singleline_comment|// language ids
r_if
c_cond
(paren
id|id
op_eq
l_int|0
)paren
(brace
op_star
id|data
op_increment
op_assign
l_int|4
suffix:semicolon
op_star
id|data
op_increment
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* 4 bytes data */
op_star
id|data
op_increment
op_assign
l_int|0
suffix:semicolon
op_star
id|data
op_increment
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* some language id */
r_return
l_int|4
suffix:semicolon
singleline_comment|// serial number
)brace
r_else
r_if
c_cond
(paren
id|id
op_eq
l_int|1
)paren
(brace
id|sprintf
(paren
id|buf
comma
l_string|&quot;%x&quot;
comma
id|serial
)paren
suffix:semicolon
singleline_comment|// product description
)brace
r_else
r_if
c_cond
(paren
id|id
op_eq
l_int|2
)paren
(brace
id|sprintf
(paren
id|buf
comma
l_string|&quot;USB %s Root Hub&quot;
comma
id|type
)paren
suffix:semicolon
singleline_comment|// id 3 == vendor description
singleline_comment|// unsupported IDs --&gt; &quot;stall&quot;
)brace
r_else
r_return
l_int|0
suffix:semicolon
id|data
(braket
l_int|0
)braket
op_assign
l_int|2
op_plus
id|ascii2utf
(paren
id|buf
comma
id|data
op_plus
l_int|2
comma
id|len
op_minus
l_int|2
)paren
suffix:semicolon
id|data
(braket
l_int|1
)braket
op_assign
l_int|3
suffix:semicolon
r_return
id|data
(braket
l_int|0
)braket
suffix:semicolon
)brace
multiline_comment|/* Wrappers around the list functions (include/linux/list.h). */
DECL|function|urb_list_empty
r_static
r_inline
r_int
id|urb_list_empty
c_func
(paren
r_int
id|epid
)paren
(brace
r_return
id|list_empty
c_func
(paren
op_amp
id|urb_list
(braket
id|epid
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Returns first urb for this epid, or NULL if list is empty. */
DECL|function|urb_list_first
r_static
r_inline
r_struct
id|urb
op_star
id|urb_list_first
c_func
(paren
r_int
id|epid
)paren
(brace
r_struct
id|urb
op_star
id|first_urb
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb_list_empty
c_func
(paren
id|epid
)paren
)paren
(brace
multiline_comment|/* Get the first urb (i.e. head-&gt;next). */
id|urb_entry_t
op_star
id|urb_entry
op_assign
id|list_entry
c_func
(paren
(paren
op_amp
id|urb_list
(braket
id|epid
)braket
)paren
op_member_access_from_pointer
id|next
comma
id|urb_entry_t
comma
id|list
)paren
suffix:semicolon
id|first_urb
op_assign
id|urb_entry-&gt;urb
suffix:semicolon
)brace
r_return
id|first_urb
suffix:semicolon
)brace
multiline_comment|/* Adds an urb_entry last in the list for this epid. */
DECL|function|urb_list_add
r_static
r_inline
r_void
id|urb_list_add
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|epid
)paren
(brace
id|urb_entry_t
op_star
id|urb_entry
op_assign
(paren
id|urb_entry_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|urb_entry_t
)paren
comma
id|KMALLOC_FLAG
)paren
suffix:semicolon
m_assert
(paren
id|urb_entry
)paren
suffix:semicolon
id|urb_entry-&gt;urb
op_assign
id|urb
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|urb_entry-&gt;list
comma
op_amp
id|urb_list
(braket
id|epid
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Search through the list for an element that contains this urb. (The list&n;   is expected to be short and the one we are about to delete will often be&n;   the first in the list.) */
DECL|function|__urb_list_entry
r_static
r_inline
id|urb_entry_t
op_star
id|__urb_list_entry
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|epid
)paren
(brace
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|urb_entry_t
op_star
id|urb_entry
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|entry
comma
id|tmp
comma
op_amp
id|urb_list
(braket
id|epid
)braket
)paren
(brace
id|urb_entry
op_assign
id|list_entry
c_func
(paren
id|entry
comma
id|urb_entry_t
comma
id|list
)paren
suffix:semicolon
m_assert
(paren
id|urb_entry
)paren
suffix:semicolon
m_assert
(paren
id|urb_entry-&gt;urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb_entry-&gt;urb
op_eq
id|urb
)paren
(brace
r_return
id|urb_entry
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Delete an urb from the list. */
DECL|function|urb_list_del
r_static
r_inline
r_void
id|urb_list_del
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|epid
)paren
(brace
id|urb_entry_t
op_star
id|urb_entry
op_assign
id|__urb_list_entry
c_func
(paren
id|urb
comma
id|epid
)paren
suffix:semicolon
m_assert
(paren
id|urb_entry
)paren
suffix:semicolon
multiline_comment|/* Delete entry and free. */
id|list_del
c_func
(paren
op_amp
id|urb_entry-&gt;list
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|urb_entry
)paren
suffix:semicolon
)brace
multiline_comment|/* Move an urb to the end of the list. */
DECL|function|urb_list_move_last
r_static
r_inline
r_void
id|urb_list_move_last
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|epid
)paren
(brace
id|urb_entry_t
op_star
id|urb_entry
op_assign
id|__urb_list_entry
c_func
(paren
id|urb
comma
id|epid
)paren
suffix:semicolon
m_assert
(paren
id|urb_entry
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|urb_entry-&gt;list
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|urb_entry-&gt;list
comma
op_amp
id|urb_list
(braket
id|epid
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Get the next urb in the list. */
DECL|function|urb_list_next
r_static
r_inline
r_struct
id|urb
op_star
id|urb_list_next
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|epid
)paren
(brace
id|urb_entry_t
op_star
id|urb_entry
op_assign
id|__urb_list_entry
c_func
(paren
id|urb
comma
id|epid
)paren
suffix:semicolon
m_assert
(paren
id|urb_entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb_entry-&gt;list.next
op_ne
op_amp
id|urb_list
(braket
id|epid
)braket
)paren
(brace
r_struct
id|list_head
op_star
id|elem
op_assign
id|urb_entry-&gt;list.next
suffix:semicolon
id|urb_entry
op_assign
id|list_entry
c_func
(paren
id|elem
comma
id|urb_entry_t
comma
id|list
)paren
suffix:semicolon
r_return
id|urb_entry-&gt;urb
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* For debug purposes only. */
DECL|function|urb_list_dump
r_static
r_inline
r_void
id|urb_list_dump
c_func
(paren
r_int
id|epid
)paren
(brace
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|urb_entry_t
op_star
id|urb_entry
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|info
c_func
(paren
l_string|&quot;Dumping urb list for epid %d&quot;
comma
id|epid
)paren
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|entry
comma
id|tmp
comma
op_amp
id|urb_list
(braket
id|epid
)braket
)paren
(brace
id|urb_entry
op_assign
id|list_entry
c_func
(paren
id|entry
comma
id|urb_entry_t
comma
id|list
)paren
suffix:semicolon
id|info
c_func
(paren
l_string|&quot;   entry %d, urb = 0x%lx&quot;
comma
id|i
comma
(paren
r_int
r_int
)paren
id|urb_entry-&gt;urb
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
id|init_rx_buffers
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|etrax_rh_unlink_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
r_static
r_void
id|etrax_rh_send_irq
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
r_static
r_void
id|etrax_rh_init_int_timer
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
r_static
r_void
id|etrax_rh_int_timer_do
c_func
(paren
r_int
r_int
id|ptr
)paren
suffix:semicolon
r_static
r_int
id|etrax_usb_setup_epid
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
r_static
r_int
id|etrax_usb_lookup_epid
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
r_static
r_int
id|etrax_usb_allocate_epid
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|etrax_usb_free_epid
c_func
(paren
r_int
id|epid
)paren
suffix:semicolon
r_static
r_int
id|etrax_remove_from_sb_list
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
r_static
r_void
op_star
id|etrax_usb_buffer_alloc
c_func
(paren
r_struct
id|usb_bus
op_star
id|bus
comma
r_int
id|size
comma
r_int
id|mem_flags
comma
id|dma_addr_t
op_star
id|dma
)paren
suffix:semicolon
r_static
r_void
id|etrax_usb_buffer_free
c_func
(paren
r_struct
id|usb_bus
op_star
id|bus
comma
r_int
id|size
comma
r_void
op_star
id|addr
comma
id|dma_addr_t
id|dma
)paren
suffix:semicolon
r_static
r_void
id|etrax_usb_add_to_bulk_sb_list
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|epid
)paren
suffix:semicolon
r_static
r_void
id|etrax_usb_add_to_ctrl_sb_list
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|epid
)paren
suffix:semicolon
r_static
r_void
id|etrax_usb_add_to_intr_sb_list
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|epid
)paren
suffix:semicolon
r_static
r_void
id|etrax_usb_add_to_isoc_sb_list
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|epid
)paren
suffix:semicolon
r_static
r_int
id|etrax_usb_submit_bulk_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
r_static
r_int
id|etrax_usb_submit_ctrl_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
r_static
r_int
id|etrax_usb_submit_intr_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
r_static
r_int
id|etrax_usb_submit_isoc_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
r_static
r_int
id|etrax_usb_submit_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|mem_flags
)paren
suffix:semicolon
r_static
r_int
id|etrax_usb_unlink_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|status
)paren
suffix:semicolon
r_static
r_int
id|etrax_usb_get_frame_number
c_func
(paren
r_struct
id|usb_device
op_star
id|usb_dev
)paren
suffix:semicolon
r_static
id|irqreturn_t
id|etrax_usb_tx_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|vhc
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
id|irqreturn_t
id|etrax_usb_rx_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|vhc
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
id|irqreturn_t
id|etrax_usb_hc_interrupt_top_half
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|vhc
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|etrax_usb_hc_interrupt_bottom_half
c_func
(paren
r_void
op_star
id|data
)paren
suffix:semicolon
r_static
r_void
id|etrax_usb_isoc_descr_interrupt_bottom_half
c_func
(paren
r_void
op_star
id|data
)paren
suffix:semicolon
multiline_comment|/* The following is a list of interrupt handlers for the host controller interrupts we use.&n;   They are called from etrax_usb_hc_interrupt_bottom_half. */
r_static
r_void
id|etrax_usb_hc_isoc_eof_interrupt
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|etrax_usb_hc_bulk_eot_interrupt
c_func
(paren
r_int
id|timer_induced
)paren
suffix:semicolon
r_static
r_void
id|etrax_usb_hc_epid_attn_interrupt
c_func
(paren
id|usb_interrupt_registers_t
op_star
id|reg
)paren
suffix:semicolon
r_static
r_void
id|etrax_usb_hc_port_status_interrupt
c_func
(paren
id|usb_interrupt_registers_t
op_star
id|reg
)paren
suffix:semicolon
r_static
r_void
id|etrax_usb_hc_ctl_status_interrupt
c_func
(paren
id|usb_interrupt_registers_t
op_star
id|reg
)paren
suffix:semicolon
r_static
r_int
id|etrax_rh_submit_urb
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
multiline_comment|/* Forward declaration needed because they are used in the rx interrupt routine. */
r_static
r_void
id|etrax_usb_complete_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|status
)paren
suffix:semicolon
r_static
r_void
id|etrax_usb_complete_bulk_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|status
)paren
suffix:semicolon
r_static
r_void
id|etrax_usb_complete_ctrl_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|status
)paren
suffix:semicolon
r_static
r_void
id|etrax_usb_complete_intr_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|status
)paren
suffix:semicolon
r_static
r_void
id|etrax_usb_complete_isoc_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|status
)paren
suffix:semicolon
r_static
r_int
id|etrax_usb_hc_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|etrax_usb_hc_cleanup
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|etrax_usb_device_operations
r_static
r_struct
id|usb_operations
id|etrax_usb_device_operations
op_assign
(brace
dot
id|get_frame_number
op_assign
id|etrax_usb_get_frame_number
comma
dot
id|submit_urb
op_assign
id|etrax_usb_submit_urb
comma
dot
id|unlink_urb
op_assign
id|etrax_usb_unlink_urb
comma
dot
id|buffer_alloc
op_assign
id|etrax_usb_buffer_alloc
comma
dot
id|buffer_free
op_assign
id|etrax_usb_buffer_free
)brace
suffix:semicolon
multiline_comment|/* Note that these functions are always available in their &quot;__&quot; variants, for use in&n;   error situations. The &quot;__&quot; missing variants are controlled by the USB_DEBUG_DESC/&n;   USB_DEBUG_URB macros. */
DECL|function|__dump_urb
r_static
r_void
id|__dump_urb
c_func
(paren
r_struct
id|urb
op_star
id|purb
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nurb                  :0x%08lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|purb
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;dev                   :0x%08lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|purb-&gt;dev
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pipe                  :0x%08x&bslash;n&quot;
comma
id|purb-&gt;pipe
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;status                :%d&bslash;n&quot;
comma
id|purb-&gt;status
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;transfer_flags        :0x%08x&bslash;n&quot;
comma
id|purb-&gt;transfer_flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;transfer_buffer       :0x%08lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|purb-&gt;transfer_buffer
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;transfer_buffer_length:%d&bslash;n&quot;
comma
id|purb-&gt;transfer_buffer_length
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;actual_length         :%d&bslash;n&quot;
comma
id|purb-&gt;actual_length
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;setup_packet          :0x%08lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|purb-&gt;setup_packet
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;start_frame           :%d&bslash;n&quot;
comma
id|purb-&gt;start_frame
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;number_of_packets     :%d&bslash;n&quot;
comma
id|purb-&gt;number_of_packets
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;interval              :%d&bslash;n&quot;
comma
id|purb-&gt;interval
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;error_count           :%d&bslash;n&quot;
comma
id|purb-&gt;error_count
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;context               :0x%08lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|purb-&gt;context
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;complete              :0x%08lx&bslash;n&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|purb-&gt;complete
)paren
suffix:semicolon
)brace
DECL|function|__dump_in_desc
r_static
r_void
id|__dump_in_desc
c_func
(paren
r_volatile
id|USB_IN_Desc_t
op_star
id|in
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nUSB_IN_Desc at 0x%08lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|in
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  sw_len  : 0x%04x (%d)&bslash;n&quot;
comma
id|in-&gt;sw_len
comma
id|in-&gt;sw_len
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  command : 0x%04x&bslash;n&quot;
comma
id|in-&gt;command
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  next    : 0x%08lx&bslash;n&quot;
comma
id|in-&gt;next
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  buf     : 0x%08lx&bslash;n&quot;
comma
id|in-&gt;buf
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  hw_len  : 0x%04x (%d)&bslash;n&quot;
comma
id|in-&gt;hw_len
comma
id|in-&gt;hw_len
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  status  : 0x%04x&bslash;n&bslash;n&quot;
comma
id|in-&gt;status
)paren
suffix:semicolon
)brace
DECL|function|__dump_sb_desc
r_static
r_void
id|__dump_sb_desc
c_func
(paren
r_volatile
id|USB_SB_Desc_t
op_star
id|sb
)paren
(brace
r_char
id|tt
op_assign
(paren
id|sb-&gt;command
op_amp
l_int|0x30
)paren
op_rshift
l_int|4
suffix:semicolon
r_char
op_star
id|tt_string
suffix:semicolon
r_switch
c_cond
(paren
id|tt
)paren
(brace
r_case
l_int|0
suffix:colon
id|tt_string
op_assign
l_string|&quot;zout&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|tt_string
op_assign
l_string|&quot;in&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|tt_string
op_assign
l_string|&quot;out&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|tt_string
op_assign
l_string|&quot;setup&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|tt_string
op_assign
l_string|&quot;unknown (weird)&quot;
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n   USB_SB_Desc at 0x%08lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|sb
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;     command : 0x%04x&bslash;n&quot;
comma
id|sb-&gt;command
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;        rem     : %d&bslash;n&quot;
comma
(paren
id|sb-&gt;command
op_amp
l_int|0x3f00
)paren
op_rshift
l_int|8
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;        full    : %d&bslash;n&quot;
comma
(paren
id|sb-&gt;command
op_amp
l_int|0x40
)paren
op_rshift
l_int|6
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;        tt      : %d (%s)&bslash;n&quot;
comma
id|tt
comma
id|tt_string
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;        intr    : %d&bslash;n&quot;
comma
(paren
id|sb-&gt;command
op_amp
l_int|0x8
)paren
op_rshift
l_int|3
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;        eot     : %d&bslash;n&quot;
comma
(paren
id|sb-&gt;command
op_amp
l_int|0x2
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;        eol     : %d&bslash;n&quot;
comma
id|sb-&gt;command
op_amp
l_int|0x1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;     sw_len  : 0x%04x (%d)&bslash;n&quot;
comma
id|sb-&gt;sw_len
comma
id|sb-&gt;sw_len
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;     next    : 0x%08lx&bslash;n&quot;
comma
id|sb-&gt;next
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;     buf     : 0x%08lx&bslash;n&bslash;n&quot;
comma
id|sb-&gt;buf
)paren
suffix:semicolon
)brace
DECL|function|__dump_ep_desc
r_static
r_void
id|__dump_ep_desc
c_func
(paren
r_volatile
id|USB_EP_Desc_t
op_star
id|ep
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nUSB_EP_Desc at 0x%08lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ep
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  command : 0x%04x&bslash;n&quot;
comma
id|ep-&gt;command
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;     ep_id   : %d&bslash;n&quot;
comma
(paren
id|ep-&gt;command
op_amp
l_int|0x1f00
)paren
op_rshift
l_int|8
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;     enable  : %d&bslash;n&quot;
comma
(paren
id|ep-&gt;command
op_amp
l_int|0x10
)paren
op_rshift
l_int|4
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;     intr    : %d&bslash;n&quot;
comma
(paren
id|ep-&gt;command
op_amp
l_int|0x8
)paren
op_rshift
l_int|3
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;     eof     : %d&bslash;n&quot;
comma
(paren
id|ep-&gt;command
op_amp
l_int|0x2
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;     eol     : %d&bslash;n&quot;
comma
id|ep-&gt;command
op_amp
l_int|0x1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  hw_len  : 0x%04x (%d)&bslash;n&quot;
comma
id|ep-&gt;hw_len
comma
id|ep-&gt;hw_len
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  next    : 0x%08lx&bslash;n&quot;
comma
id|ep-&gt;next
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  sub     : 0x%08lx&bslash;n&bslash;n&quot;
comma
id|ep-&gt;sub
)paren
suffix:semicolon
)brace
DECL|function|__dump_ep_list
r_static
r_inline
r_void
id|__dump_ep_list
c_func
(paren
r_int
id|pipe_type
)paren
(brace
r_volatile
id|USB_EP_Desc_t
op_star
id|ep
suffix:semicolon
r_volatile
id|USB_EP_Desc_t
op_star
id|first_ep
suffix:semicolon
r_volatile
id|USB_SB_Desc_t
op_star
id|sb
suffix:semicolon
r_switch
c_cond
(paren
id|pipe_type
)paren
(brace
r_case
id|PIPE_BULK
suffix:colon
id|first_ep
op_assign
op_amp
id|TxBulkEPList
(braket
l_int|0
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_CONTROL
suffix:colon
id|first_ep
op_assign
op_amp
id|TxCtrlEPList
(braket
l_int|0
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_INTERRUPT
suffix:colon
id|first_ep
op_assign
op_amp
id|TxIntrEPList
(braket
l_int|0
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_ISOCHRONOUS
suffix:colon
id|first_ep
op_assign
op_amp
id|TxIsocEPList
(braket
l_int|0
)braket
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|warn
c_func
(paren
l_string|&quot;Cannot dump unknown traffic type&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ep
op_assign
id|first_ep
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&bslash;nDumping EP list...&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
r_do
(brace
id|__dump_ep_desc
c_func
(paren
id|ep
)paren
suffix:semicolon
multiline_comment|/* Cannot phys_to_virt on 0 as it turns into 80000000, which is != 0. */
id|sb
op_assign
id|ep-&gt;sub
ques
c_cond
id|phys_to_virt
c_func
(paren
id|ep-&gt;sub
)paren
suffix:colon
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|sb
)paren
(brace
id|__dump_sb_desc
c_func
(paren
id|sb
)paren
suffix:semicolon
id|sb
op_assign
id|sb-&gt;next
ques
c_cond
id|phys_to_virt
c_func
(paren
id|sb-&gt;next
)paren
suffix:colon
l_int|0
suffix:semicolon
)brace
id|ep
op_assign
(paren
r_volatile
id|USB_EP_Desc_t
op_star
)paren
(paren
id|phys_to_virt
c_func
(paren
id|ep-&gt;next
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ep
op_ne
id|first_ep
)paren
suffix:semicolon
)brace
DECL|function|__dump_ept_data
r_static
r_inline
r_void
id|__dump_ept_data
c_func
(paren
r_int
id|epid
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|__u32
id|r_usb_ept_data
suffix:semicolon
r_if
c_cond
(paren
id|epid
template_param
l_int|31
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Cannot dump ept data for invalid epid %d&bslash;n&quot;
comma
id|epid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
op_star
id|R_USB_EPT_INDEX
op_assign
id|IO_FIELD
c_func
(paren
id|R_USB_EPT_INDEX
comma
id|value
comma
id|epid
)paren
suffix:semicolon
id|nop
c_func
(paren
)paren
suffix:semicolon
id|r_usb_ept_data
op_assign
op_star
id|R_USB_EPT_DATA
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nR_USB_EPT_DATA = 0x%x for epid %d :&bslash;n&quot;
comma
id|r_usb_ept_data
comma
id|epid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r_usb_ept_data
op_eq
l_int|0
)paren
(brace
multiline_comment|/* No need for more detailed printing. */
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;  valid           : %d&bslash;n&quot;
comma
(paren
id|r_usb_ept_data
op_amp
l_int|0x80000000
)paren
op_rshift
l_int|31
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  hold            : %d&bslash;n&quot;
comma
(paren
id|r_usb_ept_data
op_amp
l_int|0x40000000
)paren
op_rshift
l_int|30
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  error_count_in  : %d&bslash;n&quot;
comma
(paren
id|r_usb_ept_data
op_amp
l_int|0x30000000
)paren
op_rshift
l_int|28
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  t_in            : %d&bslash;n&quot;
comma
(paren
id|r_usb_ept_data
op_amp
l_int|0x08000000
)paren
op_rshift
l_int|27
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  low_speed       : %d&bslash;n&quot;
comma
(paren
id|r_usb_ept_data
op_amp
l_int|0x04000000
)paren
op_rshift
l_int|26
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  port            : %d&bslash;n&quot;
comma
(paren
id|r_usb_ept_data
op_amp
l_int|0x03000000
)paren
op_rshift
l_int|24
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  error_code      : %d&bslash;n&quot;
comma
(paren
id|r_usb_ept_data
op_amp
l_int|0x00c00000
)paren
op_rshift
l_int|22
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  t_out           : %d&bslash;n&quot;
comma
(paren
id|r_usb_ept_data
op_amp
l_int|0x00200000
)paren
op_rshift
l_int|21
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  error_count_out : %d&bslash;n&quot;
comma
(paren
id|r_usb_ept_data
op_amp
l_int|0x00180000
)paren
op_rshift
l_int|19
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  max_len         : %d&bslash;n&quot;
comma
(paren
id|r_usb_ept_data
op_amp
l_int|0x0003f800
)paren
op_rshift
l_int|11
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  ep              : %d&bslash;n&quot;
comma
(paren
id|r_usb_ept_data
op_amp
l_int|0x00000780
)paren
op_rshift
l_int|7
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  dev             : %d&bslash;n&quot;
comma
(paren
id|r_usb_ept_data
op_amp
l_int|0x0000003f
)paren
)paren
suffix:semicolon
)brace
DECL|function|__dump_ept_data_list
r_static
r_inline
r_void
id|__dump_ept_data_list
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Dumping the whole R_USB_EPT_DATA list&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
id|__dump_ept_data
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef USB_DEBUG_DESC
DECL|macro|dump_in_desc
mdefine_line|#define dump_in_desc(...) __dump_in_desc(...)
DECL|macro|dump_sb_desc
mdefine_line|#define dump_sb_desc(...) __dump_sb_desc(...)
DECL|macro|dump_ep_desc
mdefine_line|#define dump_ep_desc(...) __dump_ep_desc(...)
macro_line|#else
DECL|macro|dump_in_desc
mdefine_line|#define dump_in_desc(...) do {} while (0)
DECL|macro|dump_sb_desc
mdefine_line|#define dump_sb_desc(...) do {} while (0)
DECL|macro|dump_ep_desc
mdefine_line|#define dump_ep_desc(...) do {} while (0)
macro_line|#endif
macro_line|#ifdef USB_DEBUG_URB
DECL|macro|dump_urb
mdefine_line|#define dump_urb(x)     __dump_urb(x)
macro_line|#else
DECL|macro|dump_urb
mdefine_line|#define dump_urb(x)     do {} while (0)
macro_line|#endif
DECL|function|init_rx_buffers
r_static
r_void
id|init_rx_buffers
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|DBFENTER
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|NBR_OF_RX_DESC
op_minus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|RxDescList
(braket
id|i
)braket
dot
id|sw_len
op_assign
id|RX_DESC_BUF_SIZE
suffix:semicolon
id|RxDescList
(braket
id|i
)braket
dot
id|command
op_assign
l_int|0
suffix:semicolon
id|RxDescList
(braket
id|i
)braket
dot
id|next
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|RxDescList
(braket
id|i
op_plus
l_int|1
)braket
)paren
suffix:semicolon
id|RxDescList
(braket
id|i
)braket
dot
id|buf
op_assign
id|virt_to_phys
c_func
(paren
id|RxBuf
op_plus
(paren
id|i
op_star
id|RX_DESC_BUF_SIZE
)paren
)paren
suffix:semicolon
id|RxDescList
(braket
id|i
)braket
dot
id|hw_len
op_assign
l_int|0
suffix:semicolon
id|RxDescList
(braket
id|i
)braket
dot
id|status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* DMA IN cache bug. (struct etrax_dma_descr has the same layout as USB_IN_Desc&n;&t;&t;   for the relevant fields.) */
id|prepare_rx_descriptor
c_func
(paren
(paren
r_struct
id|etrax_dma_descr
op_star
)paren
op_amp
id|RxDescList
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|RxDescList
(braket
id|i
)braket
dot
id|sw_len
op_assign
id|RX_DESC_BUF_SIZE
suffix:semicolon
id|RxDescList
(braket
id|i
)braket
dot
id|command
op_assign
id|IO_STATE
c_func
(paren
id|USB_IN_command
comma
id|eol
comma
id|yes
)paren
suffix:semicolon
id|RxDescList
(braket
id|i
)braket
dot
id|next
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|RxDescList
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|RxDescList
(braket
id|i
)braket
dot
id|buf
op_assign
id|virt_to_phys
c_func
(paren
id|RxBuf
op_plus
(paren
id|i
op_star
id|RX_DESC_BUF_SIZE
)paren
)paren
suffix:semicolon
id|RxDescList
(braket
id|i
)braket
dot
id|hw_len
op_assign
l_int|0
suffix:semicolon
id|RxDescList
(braket
id|i
)braket
dot
id|status
op_assign
l_int|0
suffix:semicolon
id|myNextRxDesc
op_assign
op_amp
id|RxDescList
(braket
l_int|0
)braket
suffix:semicolon
id|myLastRxDesc
op_assign
op_amp
id|RxDescList
(braket
id|NBR_OF_RX_DESC
op_minus
l_int|1
)braket
suffix:semicolon
id|myPrevRxDesc
op_assign
op_amp
id|RxDescList
(braket
id|NBR_OF_RX_DESC
op_minus
l_int|1
)braket
suffix:semicolon
op_star
id|R_DMA_CH9_FIRST
op_assign
id|virt_to_phys
c_func
(paren
id|myNextRxDesc
)paren
suffix:semicolon
op_star
id|R_DMA_CH9_CMD
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH9_CMD
comma
id|cmd
comma
id|start
)paren
suffix:semicolon
id|DBFEXIT
suffix:semicolon
)brace
DECL|function|init_tx_bulk_ep
r_static
r_void
id|init_tx_bulk_ep
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|DBFENTER
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|NBR_OF_EPIDS
op_minus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|CHECK_ALIGN
c_func
(paren
op_amp
id|TxBulkEPList
(braket
id|i
)braket
)paren
suffix:semicolon
id|TxBulkEPList
(braket
id|i
)braket
dot
id|hw_len
op_assign
l_int|0
suffix:semicolon
id|TxBulkEPList
(braket
id|i
)braket
dot
id|command
op_assign
id|IO_FIELD
c_func
(paren
id|USB_EP_command
comma
id|epid
comma
id|i
)paren
suffix:semicolon
id|TxBulkEPList
(braket
id|i
)braket
dot
id|sub
op_assign
l_int|0
suffix:semicolon
id|TxBulkEPList
(braket
id|i
)braket
dot
id|next
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|TxBulkEPList
(braket
id|i
op_plus
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/* Initiate two EPs, disabled and with the eol flag set. No need for any&n;&t;&t;   preserved epid. */
multiline_comment|/* The first one has the intr flag set so we get an interrupt when the DMA&n;&t;&t;   channel is about to become disabled. */
id|CHECK_ALIGN
c_func
(paren
op_amp
id|TxBulkDummyEPList
(braket
id|i
)braket
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|TxBulkDummyEPList
(braket
id|i
)braket
(braket
l_int|0
)braket
dot
id|hw_len
op_assign
l_int|0
suffix:semicolon
id|TxBulkDummyEPList
(braket
id|i
)braket
(braket
l_int|0
)braket
dot
id|command
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|USB_EP_command
comma
id|epid
comma
id|DUMMY_EPID
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_EP_command
comma
id|eol
comma
id|yes
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_EP_command
comma
id|intr
comma
id|yes
)paren
)paren
suffix:semicolon
id|TxBulkDummyEPList
(braket
id|i
)braket
(braket
l_int|0
)braket
dot
id|sub
op_assign
l_int|0
suffix:semicolon
id|TxBulkDummyEPList
(braket
id|i
)braket
(braket
l_int|0
)braket
dot
id|next
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|TxBulkDummyEPList
(braket
id|i
)braket
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/* The second one. */
id|CHECK_ALIGN
c_func
(paren
op_amp
id|TxBulkDummyEPList
(braket
id|i
)braket
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|TxBulkDummyEPList
(braket
id|i
)braket
(braket
l_int|1
)braket
dot
id|hw_len
op_assign
l_int|0
suffix:semicolon
id|TxBulkDummyEPList
(braket
id|i
)braket
(braket
l_int|1
)braket
dot
id|command
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|USB_EP_command
comma
id|epid
comma
id|DUMMY_EPID
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_EP_command
comma
id|eol
comma
id|yes
)paren
)paren
suffix:semicolon
id|TxBulkDummyEPList
(braket
id|i
)braket
(braket
l_int|1
)braket
dot
id|sub
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* The last dummy&squot;s next pointer is the same as the current EP&squot;s next pointer. */
id|TxBulkDummyEPList
(braket
id|i
)braket
(braket
l_int|1
)braket
dot
id|next
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|TxBulkEPList
(braket
id|i
op_plus
l_int|1
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Configure the last one. */
id|CHECK_ALIGN
c_func
(paren
op_amp
id|TxBulkEPList
(braket
id|i
)braket
)paren
suffix:semicolon
id|TxBulkEPList
(braket
id|i
)braket
dot
id|hw_len
op_assign
l_int|0
suffix:semicolon
id|TxBulkEPList
(braket
id|i
)braket
dot
id|command
op_assign
(paren
id|IO_STATE
c_func
(paren
id|USB_EP_command
comma
id|eol
comma
id|yes
)paren
op_or
id|IO_FIELD
c_func
(paren
id|USB_EP_command
comma
id|epid
comma
id|i
)paren
)paren
suffix:semicolon
id|TxBulkEPList
(braket
id|i
)braket
dot
id|sub
op_assign
l_int|0
suffix:semicolon
id|TxBulkEPList
(braket
id|i
)braket
dot
id|next
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|TxBulkEPList
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/* No need configuring dummy EPs for the last one as it will never be used for&n;&t;   bulk traffic (i == INVALD_EPID at this point). */
multiline_comment|/* Set up to start on the last EP so we will enable it when inserting traffic&n;&t;   for the first time (imitating the situation where the DMA has stopped&n;&t;   because there was no more traffic). */
op_star
id|R_DMA_CH8_SUB0_EP
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|TxBulkEPList
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* No point in starting the bulk channel yet.&n;&t; *R_DMA_CH8_SUB0_CMD = IO_STATE(R_DMA_CH8_SUB0_CMD, cmd, start); */
id|DBFEXIT
suffix:semicolon
)brace
DECL|function|init_tx_ctrl_ep
r_static
r_void
id|init_tx_ctrl_ep
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|DBFENTER
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|NBR_OF_EPIDS
op_minus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|CHECK_ALIGN
c_func
(paren
op_amp
id|TxCtrlEPList
(braket
id|i
)braket
)paren
suffix:semicolon
id|TxCtrlEPList
(braket
id|i
)braket
dot
id|hw_len
op_assign
l_int|0
suffix:semicolon
id|TxCtrlEPList
(braket
id|i
)braket
dot
id|command
op_assign
id|IO_FIELD
c_func
(paren
id|USB_EP_command
comma
id|epid
comma
id|i
)paren
suffix:semicolon
id|TxCtrlEPList
(braket
id|i
)braket
dot
id|sub
op_assign
l_int|0
suffix:semicolon
id|TxCtrlEPList
(braket
id|i
)braket
dot
id|next
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|TxCtrlEPList
(braket
id|i
op_plus
l_int|1
)braket
)paren
suffix:semicolon
)brace
id|CHECK_ALIGN
c_func
(paren
op_amp
id|TxCtrlEPList
(braket
id|i
)braket
)paren
suffix:semicolon
id|TxCtrlEPList
(braket
id|i
)braket
dot
id|hw_len
op_assign
l_int|0
suffix:semicolon
id|TxCtrlEPList
(braket
id|i
)braket
dot
id|command
op_assign
(paren
id|IO_STATE
c_func
(paren
id|USB_EP_command
comma
id|eol
comma
id|yes
)paren
op_or
id|IO_FIELD
c_func
(paren
id|USB_EP_command
comma
id|epid
comma
id|i
)paren
)paren
suffix:semicolon
id|TxCtrlEPList
(braket
id|i
)braket
dot
id|sub
op_assign
l_int|0
suffix:semicolon
id|TxCtrlEPList
(braket
id|i
)braket
dot
id|next
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|TxCtrlEPList
(braket
l_int|0
)braket
)paren
suffix:semicolon
op_star
id|R_DMA_CH8_SUB1_EP
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|TxCtrlEPList
(braket
l_int|0
)braket
)paren
suffix:semicolon
op_star
id|R_DMA_CH8_SUB1_CMD
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH8_SUB1_CMD
comma
id|cmd
comma
id|start
)paren
suffix:semicolon
id|DBFEXIT
suffix:semicolon
)brace
DECL|function|init_tx_intr_ep
r_static
r_void
id|init_tx_intr_ep
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|DBFENTER
suffix:semicolon
multiline_comment|/* Read comment at zout_buffer declaration for an explanation to this. */
id|TxIntrSB_zout.sw_len
op_assign
l_int|1
suffix:semicolon
id|TxIntrSB_zout.next
op_assign
l_int|0
suffix:semicolon
id|TxIntrSB_zout.buf
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|zout_buffer
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|TxIntrSB_zout.command
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|USB_SB_command
comma
id|rem
comma
l_int|0
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|tt
comma
id|zout
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|full
comma
id|yes
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|eot
comma
id|yes
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|eol
comma
id|yes
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|MAX_INTR_INTERVAL
op_minus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|CHECK_ALIGN
c_func
(paren
op_amp
id|TxIntrEPList
(braket
id|i
)braket
)paren
suffix:semicolon
id|TxIntrEPList
(braket
id|i
)braket
dot
id|hw_len
op_assign
l_int|0
suffix:semicolon
id|TxIntrEPList
(braket
id|i
)braket
dot
id|command
op_assign
(paren
id|IO_STATE
c_func
(paren
id|USB_EP_command
comma
id|eof
comma
id|yes
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_EP_command
comma
id|enable
comma
id|yes
)paren
op_or
id|IO_FIELD
c_func
(paren
id|USB_EP_command
comma
id|epid
comma
id|INVALID_EPID
)paren
)paren
suffix:semicolon
id|TxIntrEPList
(braket
id|i
)braket
dot
id|sub
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|TxIntrSB_zout
)paren
suffix:semicolon
id|TxIntrEPList
(braket
id|i
)braket
dot
id|next
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|TxIntrEPList
(braket
id|i
op_plus
l_int|1
)braket
)paren
suffix:semicolon
)brace
id|CHECK_ALIGN
c_func
(paren
op_amp
id|TxIntrEPList
(braket
id|i
)braket
)paren
suffix:semicolon
id|TxIntrEPList
(braket
id|i
)braket
dot
id|hw_len
op_assign
l_int|0
suffix:semicolon
id|TxIntrEPList
(braket
id|i
)braket
dot
id|command
op_assign
(paren
id|IO_STATE
c_func
(paren
id|USB_EP_command
comma
id|eof
comma
id|yes
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_EP_command
comma
id|eol
comma
id|yes
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_EP_command
comma
id|enable
comma
id|yes
)paren
op_or
id|IO_FIELD
c_func
(paren
id|USB_EP_command
comma
id|epid
comma
id|INVALID_EPID
)paren
)paren
suffix:semicolon
id|TxIntrEPList
(braket
id|i
)braket
dot
id|sub
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|TxIntrSB_zout
)paren
suffix:semicolon
id|TxIntrEPList
(braket
id|i
)braket
dot
id|next
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|TxIntrEPList
(braket
l_int|0
)braket
)paren
suffix:semicolon
op_star
id|R_DMA_CH8_SUB2_EP
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|TxIntrEPList
(braket
l_int|0
)braket
)paren
suffix:semicolon
op_star
id|R_DMA_CH8_SUB2_CMD
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH8_SUB2_CMD
comma
id|cmd
comma
id|start
)paren
suffix:semicolon
id|DBFEXIT
suffix:semicolon
)brace
DECL|function|init_tx_isoc_ep
r_static
r_void
id|init_tx_isoc_ep
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|DBFENTER
suffix:semicolon
multiline_comment|/* Read comment at zout_buffer declaration for an explanation to this. */
id|TxIsocSB_zout.sw_len
op_assign
l_int|1
suffix:semicolon
id|TxIsocSB_zout.next
op_assign
l_int|0
suffix:semicolon
id|TxIsocSB_zout.buf
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|zout_buffer
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|TxIsocSB_zout.command
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|USB_SB_command
comma
id|rem
comma
l_int|0
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|tt
comma
id|zout
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|full
comma
id|yes
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|eot
comma
id|yes
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|eol
comma
id|yes
)paren
)paren
suffix:semicolon
multiline_comment|/* The last isochronous EP descriptor is a dummy. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|NBR_OF_EPIDS
op_minus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|CHECK_ALIGN
c_func
(paren
op_amp
id|TxIsocEPList
(braket
id|i
)braket
)paren
suffix:semicolon
id|TxIsocEPList
(braket
id|i
)braket
dot
id|hw_len
op_assign
l_int|0
suffix:semicolon
id|TxIsocEPList
(braket
id|i
)braket
dot
id|command
op_assign
id|IO_FIELD
c_func
(paren
id|USB_EP_command
comma
id|epid
comma
id|i
)paren
suffix:semicolon
id|TxIsocEPList
(braket
id|i
)braket
dot
id|sub
op_assign
l_int|0
suffix:semicolon
id|TxIsocEPList
(braket
id|i
)braket
dot
id|next
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|TxIsocEPList
(braket
id|i
op_plus
l_int|1
)braket
)paren
suffix:semicolon
)brace
id|CHECK_ALIGN
c_func
(paren
op_amp
id|TxIsocEPList
(braket
id|i
)braket
)paren
suffix:semicolon
id|TxIsocEPList
(braket
id|i
)braket
dot
id|hw_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Must enable the last EP descr to get eof interrupt. */
id|TxIsocEPList
(braket
id|i
)braket
dot
id|command
op_assign
(paren
id|IO_STATE
c_func
(paren
id|USB_EP_command
comma
id|enable
comma
id|yes
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_EP_command
comma
id|eof
comma
id|yes
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_EP_command
comma
id|eol
comma
id|yes
)paren
op_or
id|IO_FIELD
c_func
(paren
id|USB_EP_command
comma
id|epid
comma
id|INVALID_EPID
)paren
)paren
suffix:semicolon
id|TxIsocEPList
(braket
id|i
)braket
dot
id|sub
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|TxIsocSB_zout
)paren
suffix:semicolon
id|TxIsocEPList
(braket
id|i
)braket
dot
id|next
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|TxIsocEPList
(braket
l_int|0
)braket
)paren
suffix:semicolon
op_star
id|R_DMA_CH8_SUB3_EP
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|TxIsocEPList
(braket
l_int|0
)braket
)paren
suffix:semicolon
op_star
id|R_DMA_CH8_SUB3_CMD
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH8_SUB3_CMD
comma
id|cmd
comma
id|start
)paren
suffix:semicolon
id|DBFEXIT
suffix:semicolon
)brace
DECL|function|etrax_usb_unlink_intr_urb
r_static
r_void
id|etrax_usb_unlink_intr_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_volatile
id|USB_EP_Desc_t
op_star
id|first_ep
suffix:semicolon
multiline_comment|/* First EP in the list. */
r_volatile
id|USB_EP_Desc_t
op_star
id|curr_ep
suffix:semicolon
multiline_comment|/* Current EP, the iterator. */
r_volatile
id|USB_EP_Desc_t
op_star
id|next_ep
suffix:semicolon
multiline_comment|/* The EP after current. */
r_volatile
id|USB_EP_Desc_t
op_star
id|unlink_ep
suffix:semicolon
multiline_comment|/* The one we should remove from the list. */
r_int
id|epid
suffix:semicolon
multiline_comment|/* Read 8.8.4 in Designer&squot;s Reference, &quot;Removing an EP Descriptor from the List&quot;. */
id|DBFENTER
suffix:semicolon
id|epid
op_assign
(paren
(paren
id|etrax_urb_priv_t
op_star
)paren
id|urb-&gt;hcpriv
)paren
op_member_access_from_pointer
id|epid
suffix:semicolon
id|first_ep
op_assign
op_amp
id|TxIntrEPList
(braket
l_int|0
)braket
suffix:semicolon
id|curr_ep
op_assign
id|first_ep
suffix:semicolon
multiline_comment|/* Note that this loop removes all EP descriptors with this epid. This assumes&n;&t;   that all EP descriptors belong to the one and only urb for this epid. */
r_do
(brace
id|next_ep
op_assign
(paren
id|USB_EP_Desc_t
op_star
)paren
id|phys_to_virt
c_func
(paren
id|curr_ep-&gt;next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IO_EXTRACT
c_func
(paren
id|USB_EP_command
comma
id|epid
comma
id|next_ep-&gt;command
)paren
op_eq
id|epid
)paren
(brace
id|dbg_intr
c_func
(paren
l_string|&quot;Found EP to unlink for epid %d&quot;
comma
id|epid
)paren
suffix:semicolon
multiline_comment|/* This is the one we should unlink. */
id|unlink_ep
op_assign
id|next_ep
suffix:semicolon
multiline_comment|/* Actually unlink the EP from the DMA list. */
id|curr_ep-&gt;next
op_assign
id|unlink_ep-&gt;next
suffix:semicolon
multiline_comment|/* Wait until the DMA is no longer at this descriptor. */
r_while
c_loop
(paren
op_star
id|R_DMA_CH8_SUB2_EP
op_eq
id|virt_to_phys
c_func
(paren
id|unlink_ep
)paren
)paren
suffix:semicolon
multiline_comment|/* Now we are free to remove it and its SB descriptor.&n;&t;&t;&t;   Note that it is assumed here that there is only one sb in the&n;&t;&t;&t;   sb list for this ep. */
id|kmem_cache_free
c_func
(paren
id|usb_desc_cache
comma
id|phys_to_virt
c_func
(paren
id|unlink_ep-&gt;sub
)paren
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|usb_desc_cache
comma
(paren
id|USB_EP_Desc_t
op_star
)paren
id|unlink_ep
)paren
suffix:semicolon
)brace
id|curr_ep
op_assign
id|phys_to_virt
c_func
(paren
id|curr_ep-&gt;next
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|curr_ep
op_ne
id|first_ep
)paren
suffix:semicolon
id|urb-&gt;hcpriv
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|etrax_usb_do_intr_recover
r_void
id|etrax_usb_do_intr_recover
c_func
(paren
r_int
id|epid
)paren
(brace
id|USB_EP_Desc_t
op_star
id|first_ep
comma
op_star
id|tmp_ep
suffix:semicolon
id|DBFENTER
suffix:semicolon
id|first_ep
op_assign
(paren
id|USB_EP_Desc_t
op_star
)paren
id|phys_to_virt
c_func
(paren
op_star
id|R_DMA_CH8_SUB2_EP
)paren
suffix:semicolon
id|tmp_ep
op_assign
id|first_ep
suffix:semicolon
multiline_comment|/* What this does is simply to walk the list of interrupt&n;&t;   ep descriptors and enable those that are disabled. */
r_do
(brace
r_if
c_cond
(paren
id|IO_EXTRACT
c_func
(paren
id|USB_EP_command
comma
id|epid
comma
id|tmp_ep-&gt;command
)paren
op_eq
id|epid
op_logical_and
op_logical_neg
(paren
id|tmp_ep-&gt;command
op_amp
id|IO_MASK
c_func
(paren
id|USB_EP_command
comma
id|enable
)paren
)paren
)paren
(brace
id|tmp_ep-&gt;command
op_or_assign
id|IO_STATE
c_func
(paren
id|USB_EP_command
comma
id|enable
comma
id|yes
)paren
suffix:semicolon
)brace
id|tmp_ep
op_assign
(paren
id|USB_EP_Desc_t
op_star
)paren
id|phys_to_virt
c_func
(paren
id|tmp_ep-&gt;next
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp_ep
op_ne
id|first_ep
)paren
suffix:semicolon
id|DBFEXIT
suffix:semicolon
)brace
DECL|function|etrax_rh_unlink_urb
r_static
r_int
id|etrax_rh_unlink_urb
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
id|etrax_hc_t
op_star
id|hc
suffix:semicolon
id|DBFENTER
suffix:semicolon
id|hc
op_assign
id|urb-&gt;dev-&gt;bus-&gt;hcpriv
suffix:semicolon
r_if
c_cond
(paren
id|hc-&gt;rh.urb
op_eq
id|urb
)paren
(brace
id|hc-&gt;rh.send
op_assign
l_int|0
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|hc-&gt;rh.rh_int_timer
)paren
suffix:semicolon
)brace
id|DBFEXIT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|etrax_rh_send_irq
r_static
r_void
id|etrax_rh_send_irq
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
id|__u16
id|data
op_assign
l_int|0
suffix:semicolon
id|etrax_hc_t
op_star
id|hc
op_assign
id|urb-&gt;dev-&gt;bus-&gt;hcpriv
suffix:semicolon
id|DBFENTER
suffix:semicolon
multiline_comment|/*&n;  dbg_rh(&quot;R_USB_FM_NUMBER   : 0x%08X&quot;, *R_USB_FM_NUMBER);&n;  dbg_rh(&quot;R_USB_FM_REMAINING: 0x%08X&quot;, *R_USB_FM_REMAINING);&n;*/
id|data
op_or_assign
(paren
id|hc-&gt;rh.wPortChange_1
)paren
ques
c_cond
(paren
l_int|1
op_lshift
l_int|1
)paren
suffix:colon
l_int|0
suffix:semicolon
id|data
op_or_assign
(paren
id|hc-&gt;rh.wPortChange_2
)paren
ques
c_cond
(paren
l_int|1
op_lshift
l_int|2
)paren
suffix:colon
l_int|0
suffix:semicolon
op_star
(paren
(paren
id|__u16
op_star
)paren
id|urb-&gt;transfer_buffer
)paren
op_assign
id|cpu_to_le16
c_func
(paren
id|data
)paren
suffix:semicolon
multiline_comment|/* FIXME: Why is actual_length set to 1 when data is 2 bytes?&n;&t;   Since only 1 byte is used, why not declare data as __u8? */
id|urb-&gt;actual_length
op_assign
l_int|1
suffix:semicolon
id|urb-&gt;status
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|hc-&gt;rh.send
op_logical_and
id|urb-&gt;complete
)paren
(brace
id|dbg_rh
c_func
(paren
l_string|&quot;wPortChange_1: 0x%04X&quot;
comma
id|hc-&gt;rh.wPortChange_1
)paren
suffix:semicolon
id|dbg_rh
c_func
(paren
l_string|&quot;wPortChange_2: 0x%04X&quot;
comma
id|hc-&gt;rh.wPortChange_2
)paren
suffix:semicolon
id|urb
op_member_access_from_pointer
id|complete
c_func
(paren
id|urb
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|DBFEXIT
suffix:semicolon
)brace
DECL|function|etrax_rh_init_int_timer
r_static
r_void
id|etrax_rh_init_int_timer
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
id|etrax_hc_t
op_star
id|hc
suffix:semicolon
id|DBFENTER
suffix:semicolon
id|hc
op_assign
id|urb-&gt;dev-&gt;bus-&gt;hcpriv
suffix:semicolon
id|hc-&gt;rh.interval
op_assign
id|urb-&gt;interval
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|hc-&gt;rh.rh_int_timer
)paren
suffix:semicolon
id|hc-&gt;rh.rh_int_timer.function
op_assign
id|etrax_rh_int_timer_do
suffix:semicolon
id|hc-&gt;rh.rh_int_timer.data
op_assign
(paren
r_int
r_int
)paren
id|urb
suffix:semicolon
multiline_comment|/* FIXME: Is the jiffies resolution enough? All intervals &lt; 10 ms will be mapped&n;&t;   to 0, and the rest to the nearest lower 10 ms. */
id|hc-&gt;rh.rh_int_timer.expires
op_assign
id|jiffies
op_plus
(paren
(paren
id|HZ
op_star
id|hc-&gt;rh.interval
)paren
op_div
l_int|1000
)paren
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|hc-&gt;rh.rh_int_timer
)paren
suffix:semicolon
id|DBFEXIT
suffix:semicolon
)brace
DECL|function|etrax_rh_int_timer_do
r_static
r_void
id|etrax_rh_int_timer_do
c_func
(paren
r_int
r_int
id|ptr
)paren
(brace
r_struct
id|urb
op_star
id|urb
suffix:semicolon
id|etrax_hc_t
op_star
id|hc
suffix:semicolon
id|DBFENTER
suffix:semicolon
id|urb
op_assign
(paren
r_struct
id|urb
op_star
)paren
id|ptr
suffix:semicolon
id|hc
op_assign
id|urb-&gt;dev-&gt;bus-&gt;hcpriv
suffix:semicolon
r_if
c_cond
(paren
id|hc-&gt;rh.send
)paren
(brace
id|etrax_rh_send_irq
c_func
(paren
id|urb
)paren
suffix:semicolon
)brace
id|DBFEXIT
suffix:semicolon
)brace
DECL|function|etrax_usb_setup_epid
r_static
r_int
id|etrax_usb_setup_epid
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
id|epid
suffix:semicolon
r_char
id|devnum
comma
id|endpoint
comma
id|out_traffic
comma
id|slow
suffix:semicolon
r_int
id|maxlen
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|DBFENTER
suffix:semicolon
id|epid
op_assign
id|etrax_usb_lookup_epid
c_func
(paren
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|epid
op_ne
op_minus
l_int|1
)paren
)paren
(brace
multiline_comment|/* An epid that fits this urb has been found. */
id|DBFEXIT
suffix:semicolon
r_return
id|epid
suffix:semicolon
)brace
multiline_comment|/* We must find and initiate a new epid for this urb. */
id|epid
op_assign
id|etrax_usb_allocate_epid
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|epid
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* Failed to allocate a new epid. */
id|DBFEXIT
suffix:semicolon
r_return
id|epid
suffix:semicolon
)brace
multiline_comment|/* We now have a new epid to use. Initiate it. */
id|set_bit
c_func
(paren
id|epid
comma
(paren
r_void
op_star
)paren
op_amp
id|epid_usage_bitmask
)paren
suffix:semicolon
id|devnum
op_assign
id|usb_pipedevice
c_func
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
id|endpoint
op_assign
id|usb_pipeendpoint
c_func
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
id|slow
op_assign
id|usb_pipeslow
c_func
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
id|maxlen
op_assign
id|usb_maxpacket
c_func
(paren
id|urb-&gt;dev
comma
id|urb-&gt;pipe
comma
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
op_eq
id|PIPE_CONTROL
)paren
(brace
multiline_comment|/* We want both IN and OUT control traffic to be put on the same EP/SB list. */
id|out_traffic
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|out_traffic
op_assign
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
op_star
id|R_USB_EPT_INDEX
op_assign
id|IO_FIELD
c_func
(paren
id|R_USB_EPT_INDEX
comma
id|value
comma
id|epid
)paren
suffix:semicolon
id|nop
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
op_eq
id|PIPE_ISOCHRONOUS
)paren
(brace
op_star
id|R_USB_EPT_DATA_ISO
op_assign
id|IO_STATE
c_func
(paren
id|R_USB_EPT_DATA_ISO
comma
id|valid
comma
id|yes
)paren
op_or
multiline_comment|/* FIXME: Change any to the actual port? */
id|IO_STATE
c_func
(paren
id|R_USB_EPT_DATA_ISO
comma
id|port
comma
id|any
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_USB_EPT_DATA_ISO
comma
id|max_len
comma
id|maxlen
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_USB_EPT_DATA_ISO
comma
id|ep
comma
id|endpoint
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_USB_EPT_DATA_ISO
comma
id|dev
comma
id|devnum
)paren
suffix:semicolon
)brace
r_else
(brace
op_star
id|R_USB_EPT_DATA
op_assign
id|IO_STATE
c_func
(paren
id|R_USB_EPT_DATA
comma
id|valid
comma
id|yes
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_USB_EPT_DATA
comma
id|low_speed
comma
id|slow
)paren
op_or
multiline_comment|/* FIXME: Change any to the actual port? */
id|IO_STATE
c_func
(paren
id|R_USB_EPT_DATA
comma
id|port
comma
id|any
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_USB_EPT_DATA
comma
id|max_len
comma
id|maxlen
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_USB_EPT_DATA
comma
id|ep
comma
id|endpoint
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_USB_EPT_DATA
comma
id|dev
comma
id|devnum
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|out_traffic
)paren
(brace
id|set_bit
c_func
(paren
id|epid
comma
(paren
r_void
op_star
)paren
op_amp
id|epid_out_traffic
)paren
suffix:semicolon
)brace
r_else
(brace
id|clear_bit
c_func
(paren
id|epid
comma
(paren
r_void
op_star
)paren
op_amp
id|epid_out_traffic
)paren
suffix:semicolon
)brace
id|dbg_epid
c_func
(paren
l_string|&quot;Setting up epid %d with devnum %d, endpoint %d and max_len %d (%s)&quot;
comma
id|epid
comma
id|devnum
comma
id|endpoint
comma
id|maxlen
comma
id|out_traffic
ques
c_cond
l_string|&quot;OUT&quot;
suffix:colon
l_string|&quot;IN&quot;
)paren
suffix:semicolon
id|DBFEXIT
suffix:semicolon
r_return
id|epid
suffix:semicolon
)brace
DECL|function|etrax_usb_free_epid
r_static
r_void
id|etrax_usb_free_epid
c_func
(paren
r_int
id|epid
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|DBFENTER
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|epid
comma
(paren
r_void
op_star
)paren
op_amp
id|epid_usage_bitmask
)paren
)paren
(brace
id|warn
c_func
(paren
l_string|&quot;Trying to free unused epid %d&quot;
comma
id|epid
)paren
suffix:semicolon
id|DBFEXIT
suffix:semicolon
r_return
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
op_star
id|R_USB_EPT_INDEX
op_assign
id|IO_FIELD
c_func
(paren
id|R_USB_EPT_INDEX
comma
id|value
comma
id|epid
)paren
suffix:semicolon
id|nop
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|R_USB_EPT_DATA
op_amp
id|IO_MASK
c_func
(paren
id|R_USB_EPT_DATA
comma
id|hold
)paren
)paren
suffix:semicolon
multiline_comment|/* This will, among other things, set the valid field to 0. */
op_star
id|R_USB_EPT_DATA
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|epid
comma
(paren
r_void
op_star
)paren
op_amp
id|epid_usage_bitmask
)paren
suffix:semicolon
id|dbg_epid
c_func
(paren
l_string|&quot;Freed epid %d&quot;
comma
id|epid
)paren
suffix:semicolon
id|DBFEXIT
suffix:semicolon
)brace
DECL|function|etrax_usb_lookup_epid
r_static
r_int
id|etrax_usb_lookup_epid
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
id|i
suffix:semicolon
id|__u32
id|data
suffix:semicolon
r_char
id|devnum
comma
id|endpoint
comma
id|slow
comma
id|out_traffic
suffix:semicolon
r_int
id|maxlen
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|DBFENTER
suffix:semicolon
id|devnum
op_assign
id|usb_pipedevice
c_func
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
id|endpoint
op_assign
id|usb_pipeendpoint
c_func
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
id|slow
op_assign
id|usb_pipeslow
c_func
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
id|maxlen
op_assign
id|usb_maxpacket
c_func
(paren
id|urb-&gt;dev
comma
id|urb-&gt;pipe
comma
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
op_eq
id|PIPE_CONTROL
)paren
(brace
multiline_comment|/* We want both IN and OUT control traffic to be put on the same EP/SB list. */
id|out_traffic
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|out_traffic
op_assign
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
)brace
multiline_comment|/* Step through att epids. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NBR_OF_EPIDS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|i
comma
(paren
r_void
op_star
)paren
op_amp
id|epid_usage_bitmask
)paren
op_logical_and
id|test_bit
c_func
(paren
id|i
comma
(paren
r_void
op_star
)paren
op_amp
id|epid_out_traffic
)paren
op_eq
id|out_traffic
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
op_star
id|R_USB_EPT_INDEX
op_assign
id|IO_FIELD
c_func
(paren
id|R_USB_EPT_INDEX
comma
id|value
comma
id|i
)paren
suffix:semicolon
id|nop
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
op_eq
id|PIPE_ISOCHRONOUS
)paren
(brace
id|data
op_assign
op_star
id|R_USB_EPT_DATA_ISO
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|IO_MASK
c_func
(paren
id|R_USB_EPT_DATA_ISO
comma
id|valid
)paren
op_amp
id|data
)paren
op_logical_and
(paren
id|IO_EXTRACT
c_func
(paren
id|R_USB_EPT_DATA_ISO
comma
id|dev
comma
id|data
)paren
op_eq
id|devnum
)paren
op_logical_and
(paren
id|IO_EXTRACT
c_func
(paren
id|R_USB_EPT_DATA_ISO
comma
id|ep
comma
id|data
)paren
op_eq
id|endpoint
)paren
op_logical_and
(paren
id|IO_EXTRACT
c_func
(paren
id|R_USB_EPT_DATA_ISO
comma
id|max_len
comma
id|data
)paren
op_eq
id|maxlen
)paren
)paren
(brace
id|dbg_epid
c_func
(paren
l_string|&quot;Found epid %d for devnum %d, endpoint %d (%s)&quot;
comma
id|i
comma
id|devnum
comma
id|endpoint
comma
id|out_traffic
ques
c_cond
l_string|&quot;OUT&quot;
suffix:colon
l_string|&quot;IN&quot;
)paren
suffix:semicolon
id|DBFEXIT
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
)brace
r_else
(brace
id|data
op_assign
op_star
id|R_USB_EPT_DATA
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|IO_MASK
c_func
(paren
id|R_USB_EPT_DATA
comma
id|valid
)paren
op_amp
id|data
)paren
op_logical_and
(paren
id|IO_EXTRACT
c_func
(paren
id|R_USB_EPT_DATA
comma
id|dev
comma
id|data
)paren
op_eq
id|devnum
)paren
op_logical_and
(paren
id|IO_EXTRACT
c_func
(paren
id|R_USB_EPT_DATA
comma
id|ep
comma
id|data
)paren
op_eq
id|endpoint
)paren
op_logical_and
(paren
id|IO_EXTRACT
c_func
(paren
id|R_USB_EPT_DATA
comma
id|low_speed
comma
id|data
)paren
op_eq
id|slow
)paren
op_logical_and
(paren
id|IO_EXTRACT
c_func
(paren
id|R_USB_EPT_DATA
comma
id|max_len
comma
id|data
)paren
op_eq
id|maxlen
)paren
)paren
(brace
id|dbg_epid
c_func
(paren
l_string|&quot;Found epid %d for devnum %d, endpoint %d (%s)&quot;
comma
id|i
comma
id|devnum
comma
id|endpoint
comma
id|out_traffic
ques
c_cond
l_string|&quot;OUT&quot;
suffix:colon
l_string|&quot;IN&quot;
)paren
suffix:semicolon
id|DBFEXIT
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
)brace
)brace
)brace
id|DBFEXIT
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|etrax_usb_allocate_epid
r_static
r_int
id|etrax_usb_allocate_epid
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|DBFENTER
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NBR_OF_EPIDS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|i
comma
(paren
r_void
op_star
)paren
op_amp
id|epid_usage_bitmask
)paren
)paren
(brace
id|dbg_epid
c_func
(paren
l_string|&quot;Found free epid %d&quot;
comma
id|i
)paren
suffix:semicolon
id|DBFEXIT
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
)brace
id|dbg_epid
c_func
(paren
l_string|&quot;Found no free epids&quot;
)paren
suffix:semicolon
id|DBFEXIT
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|etrax_usb_submit_urb
r_static
r_int
id|etrax_usb_submit_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|mem_flags
)paren
(brace
id|etrax_hc_t
op_star
id|hc
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|DBFENTER
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb-&gt;dev
op_logical_or
op_logical_neg
id|urb-&gt;dev-&gt;bus
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|usb_maxpacket
c_func
(paren
id|urb-&gt;dev
comma
id|urb-&gt;pipe
comma
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
op_le
l_int|0
)paren
(brace
id|info
c_func
(paren
l_string|&quot;Submit urb to pipe with maxpacketlen 0, pipe 0x%X&bslash;n&quot;
comma
id|urb-&gt;pipe
)paren
suffix:semicolon
r_return
op_minus
id|EMSGSIZE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|urb-&gt;timeout
)paren
(brace
multiline_comment|/* FIXME. */
id|warn
c_func
(paren
l_string|&quot;urb-&gt;timeout specified, ignoring.&quot;
)paren
suffix:semicolon
)brace
id|hc
op_assign
(paren
id|etrax_hc_t
op_star
)paren
id|urb-&gt;dev-&gt;bus-&gt;hcpriv
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipedevice
c_func
(paren
id|urb-&gt;pipe
)paren
op_eq
id|hc-&gt;rh.devnum
)paren
(brace
multiline_comment|/* This request is for the Virtual Root Hub. */
id|ret
op_assign
id|etrax_rh_submit_urb
c_func
(paren
id|urb
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
op_eq
id|PIPE_BULK
)paren
(brace
id|ret
op_assign
id|etrax_usb_submit_bulk_urb
c_func
(paren
id|urb
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
op_eq
id|PIPE_CONTROL
)paren
(brace
id|ret
op_assign
id|etrax_usb_submit_ctrl_urb
c_func
(paren
id|urb
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
op_eq
id|PIPE_INTERRUPT
)paren
(brace
r_int
id|bustime
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;bandwidth
op_eq
l_int|0
)paren
(brace
id|bustime
op_assign
id|usb_check_bandwidth
c_func
(paren
id|urb-&gt;dev
comma
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bustime
OL
l_int|0
)paren
(brace
id|ret
op_assign
id|bustime
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
id|etrax_usb_submit_intr_urb
c_func
(paren
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|usb_claim_bandwidth
c_func
(paren
id|urb-&gt;dev
comma
id|urb
comma
id|bustime
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Bandwidth already set. */
id|ret
op_assign
id|etrax_usb_submit_intr_urb
c_func
(paren
id|urb
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
op_eq
id|PIPE_ISOCHRONOUS
)paren
(brace
r_int
id|bustime
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;bandwidth
op_eq
l_int|0
)paren
(brace
id|bustime
op_assign
id|usb_check_bandwidth
c_func
(paren
id|urb-&gt;dev
comma
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bustime
OL
l_int|0
)paren
(brace
id|ret
op_assign
id|bustime
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
id|etrax_usb_submit_isoc_urb
c_func
(paren
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|usb_claim_bandwidth
c_func
(paren
id|urb-&gt;dev
comma
id|urb
comma
id|bustime
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Bandwidth already set. */
id|ret
op_assign
id|etrax_usb_submit_isoc_urb
c_func
(paren
id|urb
)paren
suffix:semicolon
)brace
)brace
id|DBFEXIT
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;Submit URB error %d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|etrax_usb_unlink_urb
r_static
r_int
id|etrax_usb_unlink_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|status
)paren
(brace
id|etrax_hc_t
op_star
id|hc
suffix:semicolon
id|etrax_urb_priv_t
op_star
id|urb_priv
suffix:semicolon
r_int
id|epid
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|DBFENTER
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Disable interrupts here since a descriptor interrupt for the isoc epid&n;&t;   will modify the sb list.  This could possibly be done more granular, but&n;&t;   unlink_urb should not be used frequently anyway.&n;&t;*/
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb-&gt;dev
op_logical_or
op_logical_neg
id|urb-&gt;dev-&gt;bus
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|urb-&gt;hcpriv
)paren
(brace
multiline_comment|/* This happens if a device driver calls unlink on an urb that&n;&t;&t;   was never submitted (lazy driver) or if the urb was completed&n;&t;&t;   while unlink was being called. */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|urb-&gt;transfer_flags
op_amp
id|URB_ASYNC_UNLINK
)paren
(brace
multiline_comment|/* FIXME. */
multiline_comment|/* If URB_ASYNC_UNLINK is set:&n;&t;&t;   unlink&n;&t;&t;   move to a separate urb list&n;&t;&t;   call complete at next sof with ECONNRESET&n;&n;&t;&t;   If not:&n;&t;&t;   wait 1 ms&n;&t;&t;   unlink&n;&t;&t;   call complete with ENOENT&n;&t;&t;*/
id|warn
c_func
(paren
l_string|&quot;URB_ASYNC_UNLINK set, ignoring.&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* One might think that urb-&gt;status = -EINPROGRESS would be a requirement for unlinking,&n;&t;   but that doesn&squot;t work for interrupt and isochronous traffic since they are completed&n;&t;   repeatedly, and urb-&gt;status is set then. That may in itself be a bug though. */
id|hc
op_assign
id|urb-&gt;dev-&gt;bus-&gt;hcpriv
suffix:semicolon
id|urb_priv
op_assign
(paren
id|etrax_urb_priv_t
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
id|epid
op_assign
id|urb_priv-&gt;epid
suffix:semicolon
multiline_comment|/* Set the urb status (synchronous unlink). */
id|urb-&gt;status
op_assign
op_minus
id|ENOENT
suffix:semicolon
id|urb_priv-&gt;urb_state
op_assign
id|UNLINK
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipedevice
c_func
(paren
id|urb-&gt;pipe
)paren
op_eq
id|hc-&gt;rh.devnum
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|etrax_rh_unlink_urb
c_func
(paren
id|urb
)paren
suffix:semicolon
id|DBFEXIT
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
op_eq
id|PIPE_BULK
)paren
(brace
id|dbg_bulk
c_func
(paren
l_string|&quot;Unlink of bulk urb (0x%lx)&quot;
comma
(paren
r_int
r_int
)paren
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TxBulkEPList
(braket
id|epid
)braket
dot
id|command
op_amp
id|IO_MASK
c_func
(paren
id|USB_EP_command
comma
id|enable
)paren
)paren
(brace
multiline_comment|/* The EP was enabled, disable it and wait. */
id|TxBulkEPList
(braket
id|epid
)braket
dot
id|command
op_and_assign
op_complement
id|IO_MASK
c_func
(paren
id|USB_EP_command
comma
id|enable
)paren
suffix:semicolon
multiline_comment|/* Ah, the luxury of busy-wait. */
r_while
c_loop
(paren
op_star
id|R_DMA_CH8_SUB0_EP
op_eq
id|virt_to_phys
c_func
(paren
op_amp
id|TxBulkEPList
(braket
id|epid
)braket
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Kicking dummy list out of the party. */
id|TxBulkEPList
(braket
id|epid
)braket
dot
id|next
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|TxBulkEPList
(braket
(paren
id|epid
op_plus
l_int|1
)paren
op_mod
id|NBR_OF_EPIDS
)braket
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
op_eq
id|PIPE_CONTROL
)paren
(brace
id|dbg_ctrl
c_func
(paren
l_string|&quot;Unlink of ctrl urb (0x%lx)&quot;
comma
(paren
r_int
r_int
)paren
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TxCtrlEPList
(braket
id|epid
)braket
dot
id|command
op_amp
id|IO_MASK
c_func
(paren
id|USB_EP_command
comma
id|enable
)paren
)paren
(brace
multiline_comment|/* The EP was enabled, disable it and wait. */
id|TxCtrlEPList
(braket
id|epid
)braket
dot
id|command
op_and_assign
op_complement
id|IO_MASK
c_func
(paren
id|USB_EP_command
comma
id|enable
)paren
suffix:semicolon
multiline_comment|/* Ah, the luxury of busy-wait. */
r_while
c_loop
(paren
op_star
id|R_DMA_CH8_SUB1_EP
op_eq
id|virt_to_phys
c_func
(paren
op_amp
id|TxCtrlEPList
(braket
id|epid
)braket
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
op_eq
id|PIPE_INTERRUPT
)paren
(brace
id|dbg_intr
c_func
(paren
l_string|&quot;Unlink of intr urb (0x%lx)&quot;
comma
(paren
r_int
r_int
)paren
id|urb
)paren
suffix:semicolon
multiline_comment|/* Separate function because it&squot;s a tad more complicated. */
id|etrax_usb_unlink_intr_urb
c_func
(paren
id|urb
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
op_eq
id|PIPE_ISOCHRONOUS
)paren
(brace
id|dbg_isoc
c_func
(paren
l_string|&quot;Unlink of isoc urb (0x%lx)&quot;
comma
(paren
r_int
r_int
)paren
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|command
op_amp
id|IO_MASK
c_func
(paren
id|USB_EP_command
comma
id|enable
)paren
)paren
(brace
multiline_comment|/* The EP was enabled, disable it and wait. */
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|command
op_and_assign
op_complement
id|IO_MASK
c_func
(paren
id|USB_EP_command
comma
id|enable
)paren
suffix:semicolon
multiline_comment|/* Ah, the luxury of busy-wait. */
r_while
c_loop
(paren
op_star
id|R_DMA_CH8_SUB3_EP
op_eq
id|virt_to_phys
c_func
(paren
op_amp
id|TxIsocEPList
(braket
id|epid
)braket
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Note that we need to remove the urb from the urb list *before* removing its SB&n;&t;   descriptors. (This means that the isoc eof handler might get a null urb when we&n;&t;   are unlinking the last urb.) */
r_if
c_cond
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
op_eq
id|PIPE_BULK
)paren
(brace
id|urb_list_del
c_func
(paren
id|urb
comma
id|epid
)paren
suffix:semicolon
id|TxBulkEPList
(braket
id|epid
)braket
dot
id|sub
op_assign
l_int|0
suffix:semicolon
id|etrax_remove_from_sb_list
c_func
(paren
id|urb
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
op_eq
id|PIPE_CONTROL
)paren
(brace
id|urb_list_del
c_func
(paren
id|urb
comma
id|epid
)paren
suffix:semicolon
id|TxCtrlEPList
(braket
id|epid
)braket
dot
id|sub
op_assign
l_int|0
suffix:semicolon
id|etrax_remove_from_sb_list
c_func
(paren
id|urb
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
op_eq
id|PIPE_INTERRUPT
)paren
(brace
id|urb_list_del
c_func
(paren
id|urb
comma
id|epid
)paren
suffix:semicolon
multiline_comment|/* Sanity check (should never happen). */
m_assert
(paren
id|urb_list_empty
c_func
(paren
id|epid
)paren
)paren
suffix:semicolon
multiline_comment|/* Release allocated bandwidth. */
id|usb_release_bandwidth
c_func
(paren
id|urb-&gt;dev
comma
id|urb
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
op_eq
id|PIPE_ISOCHRONOUS
)paren
(brace
r_if
c_cond
(paren
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
id|USB_SB_Desc_t
op_star
id|iter_sb
comma
op_star
id|prev_sb
comma
op_star
id|next_sb
suffix:semicolon
r_if
c_cond
(paren
id|__urb_list_entry
c_func
(paren
id|urb
comma
id|epid
)paren
)paren
(brace
id|urb_list_del
c_func
(paren
id|urb
comma
id|epid
)paren
suffix:semicolon
id|iter_sb
op_assign
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|sub
ques
c_cond
id|phys_to_virt
c_func
(paren
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|sub
)paren
suffix:colon
l_int|0
suffix:semicolon
id|prev_sb
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|iter_sb
op_logical_and
(paren
id|iter_sb
op_ne
id|urb_priv-&gt;first_sb
)paren
)paren
(brace
id|prev_sb
op_assign
id|iter_sb
suffix:semicolon
id|iter_sb
op_assign
id|iter_sb-&gt;next
ques
c_cond
id|phys_to_virt
c_func
(paren
id|iter_sb-&gt;next
)paren
suffix:colon
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|iter_sb
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Unlink of the URB currently being transmitted. */
id|prev_sb
op_assign
l_int|0
suffix:semicolon
id|iter_sb
op_assign
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|sub
ques
c_cond
id|phys_to_virt
c_func
(paren
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|sub
)paren
suffix:colon
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|iter_sb
op_logical_and
(paren
id|iter_sb
op_ne
id|urb_priv-&gt;last_sb
)paren
)paren
(brace
id|iter_sb
op_assign
id|iter_sb-&gt;next
ques
c_cond
id|phys_to_virt
c_func
(paren
id|iter_sb-&gt;next
)paren
suffix:colon
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|iter_sb
)paren
(brace
id|next_sb
op_assign
id|iter_sb-&gt;next
ques
c_cond
id|phys_to_virt
c_func
(paren
id|iter_sb-&gt;next
)paren
suffix:colon
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* This should only happen if the DMA has completed&n;&t;&t;&t;&t;&t;   processing the SB list for this EP while interrupts&n;&t;&t;&t;&t;&t;   are disabled. */
id|dbg_isoc
c_func
(paren
l_string|&quot;Isoc urb not found, already sent?&quot;
)paren
suffix:semicolon
id|next_sb
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prev_sb
)paren
(brace
id|prev_sb-&gt;next
op_assign
id|next_sb
ques
c_cond
id|virt_to_phys
c_func
(paren
id|next_sb
)paren
suffix:colon
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|sub
op_assign
id|next_sb
ques
c_cond
id|virt_to_phys
c_func
(paren
id|next_sb
)paren
suffix:colon
l_int|0
suffix:semicolon
)brace
id|etrax_remove_from_sb_list
c_func
(paren
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb_list_empty
c_func
(paren
id|epid
)paren
)paren
(brace
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|sub
op_assign
l_int|0
suffix:semicolon
id|dbg_isoc
c_func
(paren
l_string|&quot;Last isoc out urb epid %d&quot;
comma
id|epid
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|next_sb
op_logical_or
id|prev_sb
)paren
(brace
id|dbg_isoc
c_func
(paren
l_string|&quot;Re-enable isoc out epid %d&quot;
comma
id|epid
)paren
suffix:semicolon
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|hw_len
op_assign
l_int|0
suffix:semicolon
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|command
op_or_assign
id|IO_STATE
c_func
(paren
id|USB_EP_command
comma
id|enable
comma
id|yes
)paren
suffix:semicolon
)brace
r_else
(brace
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|sub
op_assign
l_int|0
suffix:semicolon
id|dbg_isoc
c_func
(paren
l_string|&quot;URB list non-empty and no SB list, EP disabled&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|dbg_isoc
c_func
(paren
l_string|&quot;Urb 0x%p not found, completed already?&quot;
comma
id|urb
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|urb_list_del
c_func
(paren
id|urb
comma
id|epid
)paren
suffix:semicolon
multiline_comment|/* For in traffic there is only one SB descriptor for each EP even&n;&t;&t;&t;   though there may be several urbs (all urbs point at the same SB). */
r_if
c_cond
(paren
id|urb_list_empty
c_func
(paren
id|epid
)paren
)paren
(brace
multiline_comment|/* No more urbs, remove the SB. */
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|sub
op_assign
l_int|0
suffix:semicolon
id|etrax_remove_from_sb_list
c_func
(paren
id|urb
)paren
suffix:semicolon
)brace
r_else
(brace
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|hw_len
op_assign
l_int|0
suffix:semicolon
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|command
op_or_assign
id|IO_STATE
c_func
(paren
id|USB_EP_command
comma
id|enable
comma
id|yes
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Release allocated bandwidth. */
id|usb_release_bandwidth
c_func
(paren
id|urb-&gt;dev
comma
id|urb
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Free the epid if urb list is empty. */
r_if
c_cond
(paren
id|urb_list_empty
c_func
(paren
id|epid
)paren
)paren
(brace
id|etrax_usb_free_epid
c_func
(paren
id|epid
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Must be done before calling completion handler. */
id|kfree
c_func
(paren
id|urb_priv
)paren
suffix:semicolon
id|urb-&gt;hcpriv
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;complete
)paren
(brace
id|urb
op_member_access_from_pointer
id|complete
c_func
(paren
id|urb
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|DBFEXIT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|etrax_usb_get_frame_number
r_static
r_int
id|etrax_usb_get_frame_number
c_func
(paren
r_struct
id|usb_device
op_star
id|usb_dev
)paren
(brace
id|DBFENTER
suffix:semicolon
id|DBFEXIT
suffix:semicolon
r_return
(paren
op_star
id|R_USB_FM_NUMBER
op_amp
l_int|0x7ff
)paren
suffix:semicolon
)brace
DECL|function|etrax_usb_tx_interrupt
r_static
id|irqreturn_t
id|etrax_usb_tx_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|vhc
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|DBFENTER
suffix:semicolon
multiline_comment|/* This interrupt handler could be used when unlinking EP descriptors. */
r_if
c_cond
(paren
op_star
id|R_IRQ_READ2
op_amp
id|IO_MASK
c_func
(paren
id|R_IRQ_READ2
comma
id|dma8_sub0_descr
)paren
)paren
(brace
id|USB_EP_Desc_t
op_star
id|ep
suffix:semicolon
singleline_comment|//dbg_bulk(&quot;dma8_sub0_descr (BULK) intr.&quot;);
multiline_comment|/* It should be safe clearing the interrupt here, since we don&squot;t expect to get a new&n;&t;&t;   one until we restart the bulk channel. */
op_star
id|R_DMA_CH8_SUB0_CLR_INTR
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH8_SUB0_CLR_INTR
comma
id|clr_descr
comma
r_do
)paren
suffix:semicolon
multiline_comment|/* Wait while the DMA is running (though we don&squot;t expect it to be). */
r_while
c_loop
(paren
op_star
id|R_DMA_CH8_SUB0_CMD
op_amp
id|IO_MASK
c_func
(paren
id|R_DMA_CH8_SUB0_CMD
comma
id|cmd
)paren
)paren
suffix:semicolon
multiline_comment|/* Advance the DMA to the next EP descriptor. */
id|ep
op_assign
(paren
id|USB_EP_Desc_t
op_star
)paren
id|phys_to_virt
c_func
(paren
op_star
id|R_DMA_CH8_SUB0_EP
)paren
suffix:semicolon
singleline_comment|//dbg_bulk(&quot;descr intr: DMA is at 0x%lx&quot;, (unsigned long)ep);
multiline_comment|/* ep-&gt;next is already a physical address; no need for a virt_to_phys. */
op_star
id|R_DMA_CH8_SUB0_EP
op_assign
id|ep-&gt;next
suffix:semicolon
multiline_comment|/* Start the DMA bulk channel again. */
op_star
id|R_DMA_CH8_SUB0_CMD
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH8_SUB0_CMD
comma
id|cmd
comma
id|start
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|R_IRQ_READ2
op_amp
id|IO_MASK
c_func
(paren
id|R_IRQ_READ2
comma
id|dma8_sub1_descr
)paren
)paren
(brace
r_struct
id|urb
op_star
id|urb
suffix:semicolon
r_int
id|epid
suffix:semicolon
id|etrax_urb_priv_t
op_star
id|urb_priv
suffix:semicolon
r_int
r_int
r_int
id|flags
suffix:semicolon
id|dbg_ctrl
c_func
(paren
l_string|&quot;dma8_sub1_descr (CTRL) intr.&quot;
)paren
suffix:semicolon
op_star
id|R_DMA_CH8_SUB1_CLR_INTR
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH8_SUB1_CLR_INTR
comma
id|clr_descr
comma
r_do
)paren
suffix:semicolon
multiline_comment|/* The complete callback gets called so we cli. */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|epid
op_assign
l_int|0
suffix:semicolon
id|epid
OL
id|NBR_OF_EPIDS
op_minus
l_int|1
suffix:semicolon
id|epid
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|TxCtrlEPList
(braket
id|epid
)braket
dot
id|sub
op_eq
l_int|0
)paren
op_logical_or
(paren
id|epid
op_eq
id|DUMMY_EPID
)paren
op_logical_or
(paren
id|epid
op_eq
id|INVALID_EPID
)paren
)paren
(brace
multiline_comment|/* Nothing here to see. */
r_continue
suffix:semicolon
)brace
multiline_comment|/* Get the first urb (if any). */
id|urb
op_assign
id|urb_list_first
c_func
(paren
id|epid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb
)paren
(brace
multiline_comment|/* Sanity check. */
m_assert
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
op_eq
id|PIPE_CONTROL
)paren
suffix:semicolon
id|urb_priv
op_assign
(paren
id|etrax_urb_priv_t
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
m_assert
(paren
id|urb_priv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb_priv-&gt;urb_state
op_eq
id|WAITING_FOR_DESCR_INTR
)paren
(brace
m_assert
(paren
op_logical_neg
(paren
id|TxCtrlEPList
(braket
id|urb_priv-&gt;epid
)braket
dot
id|command
op_amp
id|IO_MASK
c_func
(paren
id|USB_EP_command
comma
id|enable
)paren
)paren
)paren
suffix:semicolon
id|etrax_usb_complete_urb
c_func
(paren
id|urb
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|R_IRQ_READ2
op_amp
id|IO_MASK
c_func
(paren
id|R_IRQ_READ2
comma
id|dma8_sub2_descr
)paren
)paren
(brace
id|dbg_intr
c_func
(paren
l_string|&quot;dma8_sub2_descr (INTR) intr.&quot;
)paren
suffix:semicolon
op_star
id|R_DMA_CH8_SUB2_CLR_INTR
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH8_SUB2_CLR_INTR
comma
id|clr_descr
comma
r_do
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|R_IRQ_READ2
op_amp
id|IO_MASK
c_func
(paren
id|R_IRQ_READ2
comma
id|dma8_sub3_descr
)paren
)paren
(brace
r_struct
id|urb
op_star
id|urb
suffix:semicolon
r_int
id|epid
suffix:semicolon
r_int
id|epid_done
suffix:semicolon
id|etrax_urb_priv_t
op_star
id|urb_priv
suffix:semicolon
id|USB_SB_Desc_t
op_star
id|sb_desc
suffix:semicolon
id|usb_isoc_complete_data_t
op_star
id|comp_data
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* One or more isoc out transfers are done. */
id|dbg_isoc
c_func
(paren
l_string|&quot;dma8_sub3_descr (ISOC) intr.&quot;
)paren
suffix:semicolon
multiline_comment|/* For each isoc out EP search for the first sb_desc with the intr flag&n;&t;&t;   set.  This descriptor must be the last packet from an URB.  Then&n;&t;&t;   traverse the URB list for the EP until the URB with urb_priv-&gt;last_sb&n;&t;&t;   matching the intr-marked sb_desc is found.  All URBs before this have&n;&t;&t;   been sent.&n;&t;&t;*/
r_for
c_loop
(paren
id|epid
op_assign
l_int|0
suffix:semicolon
id|epid
OL
id|NBR_OF_EPIDS
op_minus
l_int|1
suffix:semicolon
id|epid
op_increment
)paren
(brace
multiline_comment|/* Skip past epids with no SB lists, epids used for in traffic,&n;&t;&t;&t;   and special (dummy, invalid) epids. */
r_if
c_cond
(paren
(paren
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|sub
op_eq
l_int|0
)paren
op_logical_or
(paren
id|test_bit
c_func
(paren
id|epid
comma
(paren
r_void
op_star
)paren
op_amp
id|epid_out_traffic
)paren
op_eq
l_int|0
)paren
op_logical_or
(paren
id|epid
op_eq
id|DUMMY_EPID
)paren
op_logical_or
(paren
id|epid
op_eq
id|INVALID_EPID
)paren
)paren
(brace
multiline_comment|/* Nothing here to see. */
r_continue
suffix:semicolon
)brace
id|sb_desc
op_assign
id|phys_to_virt
c_func
(paren
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|sub
)paren
suffix:semicolon
multiline_comment|/* Find the last descriptor of the currently active URB for this ep.&n;&t;&t;&t;   This is the first descriptor in the sub list marked for a descriptor&n;&t;&t;&t;   interrupt. */
r_while
c_loop
(paren
id|sb_desc
op_logical_and
op_logical_neg
id|IO_EXTRACT
c_func
(paren
id|USB_SB_command
comma
id|intr
comma
id|sb_desc-&gt;command
)paren
)paren
(brace
id|sb_desc
op_assign
id|sb_desc-&gt;next
ques
c_cond
id|phys_to_virt
c_func
(paren
id|sb_desc-&gt;next
)paren
suffix:colon
l_int|0
suffix:semicolon
)brace
m_assert
(paren
id|sb_desc
)paren
suffix:semicolon
id|dbg_isoc
c_func
(paren
l_string|&quot;Check epid %d, sub 0x%p, SB 0x%p&quot;
comma
id|epid
comma
id|phys_to_virt
c_func
(paren
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|sub
)paren
comma
id|sb_desc
)paren
suffix:semicolon
id|epid_done
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Get the first urb (if any). */
id|urb
op_assign
id|urb_list_first
c_func
(paren
id|epid
)paren
suffix:semicolon
m_assert
(paren
id|urb
)paren
suffix:semicolon
r_while
c_loop
(paren
id|urb
op_logical_and
op_logical_neg
id|epid_done
)paren
(brace
multiline_comment|/* Sanity check. */
m_assert
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
op_eq
id|PIPE_ISOCHRONOUS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
multiline_comment|/* descr interrupts are generated only for out pipes. */
id|epid_done
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|urb_priv
op_assign
(paren
id|etrax_urb_priv_t
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
m_assert
(paren
id|urb_priv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb_desc
op_ne
id|urb_priv-&gt;last_sb
)paren
(brace
multiline_comment|/* This urb has been sent. */
id|dbg_isoc
c_func
(paren
l_string|&quot;out URB 0x%p sent&quot;
comma
id|urb
)paren
suffix:semicolon
id|urb_priv-&gt;urb_state
op_assign
id|TRANSFER_DONE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|sb_desc
op_eq
id|urb_priv-&gt;last_sb
)paren
op_logical_and
op_logical_neg
(paren
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|command
op_amp
id|IO_MASK
c_func
(paren
id|USB_EP_command
comma
id|enable
)paren
)paren
)paren
(brace
m_assert
(paren
(paren
id|sb_desc-&gt;command
op_amp
id|IO_MASK
c_func
(paren
id|USB_SB_command
comma
id|eol
)paren
)paren
op_eq
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|eol
comma
id|yes
)paren
)paren
suffix:semicolon
m_assert
(paren
id|sb_desc-&gt;next
op_eq
l_int|0
)paren
suffix:semicolon
id|dbg_isoc
c_func
(paren
l_string|&quot;out URB 0x%p last in list, epid disabled&quot;
comma
id|urb
)paren
suffix:semicolon
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|sub
op_assign
l_int|0
suffix:semicolon
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|hw_len
op_assign
l_int|0
suffix:semicolon
id|urb_priv-&gt;urb_state
op_assign
id|TRANSFER_DONE
suffix:semicolon
id|epid_done
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|epid_done
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|epid_done
)paren
(brace
id|urb
op_assign
id|urb_list_next
c_func
(paren
id|urb
comma
id|epid
)paren
suffix:semicolon
)brace
)brace
)brace
op_star
id|R_DMA_CH8_SUB3_CLR_INTR
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH8_SUB3_CLR_INTR
comma
id|clr_descr
comma
r_do
)paren
suffix:semicolon
id|comp_data
op_assign
(paren
id|usb_isoc_complete_data_t
op_star
)paren
id|kmem_cache_alloc
c_func
(paren
id|isoc_compl_cache
comma
id|SLAB_ATOMIC
)paren
suffix:semicolon
m_assert
(paren
id|comp_data
op_ne
l_int|NULL
)paren
suffix:semicolon
id|INIT_WORK
c_func
(paren
op_amp
id|comp_data-&gt;usb_bh
comma
id|etrax_usb_isoc_descr_interrupt_bottom_half
comma
id|comp_data
)paren
suffix:semicolon
id|schedule_work
c_func
(paren
op_amp
id|comp_data-&gt;usb_bh
)paren
suffix:semicolon
)brace
id|DBFEXIT
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
DECL|function|etrax_usb_isoc_descr_interrupt_bottom_half
r_static
r_void
id|etrax_usb_isoc_descr_interrupt_bottom_half
c_func
(paren
r_void
op_star
id|data
)paren
(brace
id|usb_isoc_complete_data_t
op_star
id|comp_data
op_assign
(paren
id|usb_isoc_complete_data_t
op_star
)paren
id|data
suffix:semicolon
r_struct
id|urb
op_star
id|urb
suffix:semicolon
r_int
id|epid
suffix:semicolon
r_int
id|epid_done
suffix:semicolon
id|etrax_urb_priv_t
op_star
id|urb_priv
suffix:semicolon
id|DBFENTER
suffix:semicolon
id|dbg_isoc
c_func
(paren
l_string|&quot;dma8_sub3_descr (ISOC) bottom half.&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|epid
op_assign
l_int|0
suffix:semicolon
id|epid
OL
id|NBR_OF_EPIDS
op_minus
l_int|1
suffix:semicolon
id|epid
op_increment
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|epid_done
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* The descriptor interrupt handler has marked all transmitted isoch. out&n;&t;&t;   URBs with TRANSFER_DONE.  Now we traverse all epids and for all that&n; &t;&t;   have isoch. out traffic traverse its URB list and complete the&n;&t;&t;   transmitted URB.&n;&t;&t;*/
r_while
c_loop
(paren
op_logical_neg
id|epid_done
)paren
(brace
multiline_comment|/* Get the first urb (if any). */
id|urb
op_assign
id|urb_list_first
c_func
(paren
id|epid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb
op_eq
l_int|0
)paren
(brace
id|epid_done
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
op_ne
id|PIPE_ISOCHRONOUS
)paren
(brace
id|epid_done
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
multiline_comment|/* descr interrupts are generated only for out pipes. */
id|epid_done
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|dbg_isoc
c_func
(paren
l_string|&quot;Check epid %d, SB 0x%p&quot;
comma
id|epid
comma
(paren
r_char
op_star
)paren
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|sub
)paren
suffix:semicolon
id|urb_priv
op_assign
(paren
id|etrax_urb_priv_t
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
m_assert
(paren
id|urb_priv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb_priv-&gt;urb_state
op_eq
id|TRANSFER_DONE
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|usb_iso_packet_descriptor
op_star
id|packet
suffix:semicolon
multiline_comment|/* This urb has been sent. */
id|dbg_isoc
c_func
(paren
l_string|&quot;Completing isoc out URB 0x%p&quot;
comma
id|urb
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|i
op_increment
)paren
(brace
id|packet
op_assign
op_amp
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
suffix:semicolon
id|packet-&gt;status
op_assign
l_int|0
suffix:semicolon
id|packet-&gt;actual_length
op_assign
id|packet-&gt;length
suffix:semicolon
)brace
id|etrax_usb_complete_isoc_urb
c_func
(paren
id|urb
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb_list_empty
c_func
(paren
id|epid
)paren
)paren
(brace
id|etrax_usb_free_epid
c_func
(paren
id|epid
)paren
suffix:semicolon
id|epid_done
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|epid_done
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
id|kmem_cache_free
c_func
(paren
id|isoc_compl_cache
comma
id|comp_data
)paren
suffix:semicolon
id|DBFEXIT
suffix:semicolon
)brace
DECL|function|etrax_usb_rx_interrupt
r_static
id|irqreturn_t
id|etrax_usb_rx_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|vhc
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|urb
op_star
id|urb
suffix:semicolon
id|etrax_urb_priv_t
op_star
id|urb_priv
suffix:semicolon
r_int
id|epid
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Isoc diagnostics. */
r_static
r_int
id|curr_fm
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|prev_fm
op_assign
l_int|0
suffix:semicolon
id|DBFENTER
suffix:semicolon
multiline_comment|/* Clear this interrupt. */
op_star
id|R_DMA_CH9_CLR_INTR
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH9_CLR_INTR
comma
id|clr_eop
comma
r_do
)paren
suffix:semicolon
multiline_comment|/* Note that this while loop assumes that all packets span only&n;&t;   one rx descriptor. */
multiline_comment|/* The reason we cli here is that we call the driver&squot;s callback functions. */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|myNextRxDesc-&gt;status
op_amp
id|IO_MASK
c_func
(paren
id|USB_IN_status
comma
id|eop
)paren
)paren
(brace
id|epid
op_assign
id|IO_EXTRACT
c_func
(paren
id|USB_IN_status
comma
id|epid
comma
id|myNextRxDesc-&gt;status
)paren
suffix:semicolon
id|urb
op_assign
id|urb_list_first
c_func
(paren
id|epid
)paren
suffix:semicolon
singleline_comment|//printk(&quot;eop for epid %d, first urb 0x%lx&bslash;n&quot;, epid, (unsigned long)urb);
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
(brace
id|err
c_func
(paren
l_string|&quot;No urb for epid %d in rx interrupt&quot;
comma
id|epid
)paren
suffix:semicolon
id|__dump_ept_data
c_func
(paren
id|epid
)paren
suffix:semicolon
r_goto
id|skip_out
suffix:semicolon
)brace
multiline_comment|/* Note that we cannot indescriminately assert(usb_pipein(urb-&gt;pipe)) since&n;&t;&t;   ctrl pipes are not. */
r_if
c_cond
(paren
id|myNextRxDesc-&gt;status
op_amp
id|IO_MASK
c_func
(paren
id|USB_IN_status
comma
id|error
)paren
)paren
(brace
id|__u32
id|r_usb_ept_data
suffix:semicolon
r_int
id|no_error
op_assign
l_int|0
suffix:semicolon
m_assert
(paren
id|test_bit
c_func
(paren
id|epid
comma
(paren
r_void
op_star
)paren
op_amp
id|epid_usage_bitmask
)paren
)paren
suffix:semicolon
op_star
id|R_USB_EPT_INDEX
op_assign
id|IO_FIELD
c_func
(paren
id|R_USB_EPT_INDEX
comma
id|value
comma
id|epid
)paren
suffix:semicolon
id|nop
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
op_eq
id|PIPE_ISOCHRONOUS
)paren
(brace
id|r_usb_ept_data
op_assign
op_star
id|R_USB_EPT_DATA_ISO
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r_usb_ept_data
op_amp
id|IO_MASK
c_func
(paren
id|R_USB_EPT_DATA_ISO
comma
id|valid
)paren
)paren
op_logical_and
(paren
id|IO_EXTRACT
c_func
(paren
id|R_USB_EPT_DATA_ISO
comma
id|error_code
comma
id|r_usb_ept_data
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|myNextRxDesc-&gt;status
op_amp
id|IO_MASK
c_func
(paren
id|USB_IN_status
comma
id|nodata
)paren
)paren
)paren
(brace
multiline_comment|/* Not an error, just a failure to receive an expected iso&n;&t;&t;&t;&t;&t;   in packet in this frame.  This is not documented&n;&t;&t;&t;&t;&t;   in the designers reference.&n;&t;&t;&t;&t;&t;*/
id|no_error
op_increment
suffix:semicolon
)brace
r_else
(brace
id|warn
c_func
(paren
l_string|&quot;R_USB_EPT_DATA_ISO for epid %d = 0x%x&quot;
comma
id|epid
comma
id|r_usb_ept_data
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|r_usb_ept_data
op_assign
op_star
id|R_USB_EPT_DATA
suffix:semicolon
id|warn
c_func
(paren
l_string|&quot;R_USB_EPT_DATA for epid %d = 0x%x&quot;
comma
id|epid
comma
id|r_usb_ept_data
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|no_error
)paren
(brace
id|warn
c_func
(paren
l_string|&quot;error in rx desc-&gt;status, epid %d, first urb = 0x%lx&quot;
comma
id|epid
comma
(paren
r_int
r_int
)paren
id|urb
)paren
suffix:semicolon
id|__dump_in_desc
c_func
(paren
id|myNextRxDesc
)paren
suffix:semicolon
id|warn
c_func
(paren
l_string|&quot;R_USB_STATUS = 0x%x&quot;
comma
op_star
id|R_USB_STATUS
)paren
suffix:semicolon
multiline_comment|/* Check that ept was disabled when error occurred. */
r_switch
c_cond
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
r_case
id|PIPE_BULK
suffix:colon
m_assert
(paren
op_logical_neg
(paren
id|TxBulkEPList
(braket
id|epid
)braket
dot
id|command
op_amp
id|IO_MASK
c_func
(paren
id|USB_EP_command
comma
id|enable
)paren
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_CONTROL
suffix:colon
m_assert
(paren
op_logical_neg
(paren
id|TxCtrlEPList
(braket
id|epid
)braket
dot
id|command
op_amp
id|IO_MASK
c_func
(paren
id|USB_EP_command
comma
id|enable
)paren
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_INTERRUPT
suffix:colon
m_assert
(paren
op_logical_neg
(paren
id|TxIntrEPList
(braket
id|epid
)braket
dot
id|command
op_amp
id|IO_MASK
c_func
(paren
id|USB_EP_command
comma
id|enable
)paren
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_ISOCHRONOUS
suffix:colon
m_assert
(paren
op_logical_neg
(paren
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|command
op_amp
id|IO_MASK
c_func
(paren
id|USB_EP_command
comma
id|enable
)paren
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|warn
c_func
(paren
l_string|&quot;etrax_usb_rx_interrupt: bad pipetype %d in urb 0x%p&quot;
comma
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
comma
id|urb
)paren
suffix:semicolon
)brace
id|etrax_usb_complete_urb
c_func
(paren
id|urb
comma
op_minus
id|EPROTO
)paren
suffix:semicolon
r_goto
id|skip_out
suffix:semicolon
)brace
)brace
id|urb_priv
op_assign
(paren
id|etrax_urb_priv_t
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
m_assert
(paren
id|urb_priv
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
op_eq
id|PIPE_BULK
)paren
op_logical_or
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
op_eq
id|PIPE_CONTROL
)paren
op_logical_or
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
op_eq
id|PIPE_INTERRUPT
)paren
)paren
(brace
r_if
c_cond
(paren
id|myNextRxDesc-&gt;status
op_amp
id|IO_MASK
c_func
(paren
id|USB_IN_status
comma
id|nodata
)paren
)paren
(brace
multiline_comment|/* We get nodata for empty data transactions, and the rx descriptor&squot;s&n;&t;&t;&t;&t;   hw_len field is not valid in that case. No data to copy in other&n;&t;&t;&t;&t;   words. */
)brace
r_else
(brace
multiline_comment|/* Make sure the data fits in the buffer. */
m_assert
(paren
id|urb_priv-&gt;rx_offset
op_plus
id|myNextRxDesc-&gt;hw_len
op_le
id|urb-&gt;transfer_buffer_length
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|urb-&gt;transfer_buffer
op_plus
id|urb_priv-&gt;rx_offset
comma
id|phys_to_virt
c_func
(paren
id|myNextRxDesc-&gt;buf
)paren
comma
id|myNextRxDesc-&gt;hw_len
)paren
suffix:semicolon
id|urb_priv-&gt;rx_offset
op_add_assign
id|myNextRxDesc-&gt;hw_len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|myNextRxDesc-&gt;status
op_amp
id|IO_MASK
c_func
(paren
id|USB_IN_status
comma
id|eot
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
op_eq
id|PIPE_CONTROL
)paren
op_logical_and
(paren
(paren
id|TxCtrlEPList
(braket
id|urb_priv-&gt;epid
)braket
dot
id|command
op_amp
id|IO_MASK
c_func
(paren
id|USB_EP_command
comma
id|enable
)paren
)paren
op_eq
id|IO_STATE
c_func
(paren
id|USB_EP_command
comma
id|enable
comma
id|yes
)paren
)paren
)paren
(brace
multiline_comment|/* The EP is still enabled, so the OUT packet used to ack&n;&t;&t;&t;&t;&t;   the in data is probably not processed yet.  If the EP&n;&t;&t;&t;&t;&t;   sub pointer has not moved beyond urb_priv-&gt;last_sb mark&n;&t;&t;&t;&t;&t;   it for a descriptor interrupt and complete the urb in&n;&t;&t;&t;&t;&t;   the descriptor interrupt handler.&n;&t;&t;&t;&t;&t;*/
id|USB_SB_Desc_t
op_star
id|sub
op_assign
id|TxCtrlEPList
(braket
id|urb_priv-&gt;epid
)braket
dot
id|sub
ques
c_cond
id|phys_to_virt
c_func
(paren
id|TxCtrlEPList
(braket
id|urb_priv-&gt;epid
)braket
dot
id|sub
)paren
suffix:colon
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|sub
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|sub
op_ne
id|urb_priv-&gt;last_sb
)paren
)paren
(brace
id|sub
op_assign
id|sub-&gt;next
ques
c_cond
id|phys_to_virt
c_func
(paren
id|sub-&gt;next
)paren
suffix:colon
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sub
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* The urb has not been fully processed. */
id|urb_priv-&gt;urb_state
op_assign
id|WAITING_FOR_DESCR_INTR
suffix:semicolon
)brace
r_else
(brace
id|warn
c_func
(paren
l_string|&quot;(CTRL) epid enabled and urb (0x%p) processed, ep-&gt;sub=0x%p&quot;
comma
id|urb
comma
(paren
r_char
op_star
)paren
id|TxCtrlEPList
(braket
id|urb_priv-&gt;epid
)braket
dot
id|sub
)paren
suffix:semicolon
id|etrax_usb_complete_urb
c_func
(paren
id|urb
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|etrax_usb_complete_urb
c_func
(paren
id|urb
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
op_eq
id|PIPE_ISOCHRONOUS
)paren
(brace
r_struct
id|usb_iso_packet_descriptor
op_star
id|packet
suffix:semicolon
r_if
c_cond
(paren
id|urb_priv-&gt;urb_state
op_eq
id|UNLINK
)paren
(brace
id|info
c_func
(paren
l_string|&quot;Ignoring rx data for urb being unlinked.&quot;
)paren
suffix:semicolon
r_goto
id|skip_out
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|urb_priv-&gt;urb_state
op_eq
id|NOT_STARTED
)paren
(brace
id|info
c_func
(paren
l_string|&quot;What? Got rx data for urb that isn&squot;t started?&quot;
)paren
suffix:semicolon
r_goto
id|skip_out
suffix:semicolon
)brace
id|packet
op_assign
op_amp
id|urb-&gt;iso_frame_desc
(braket
id|urb_priv-&gt;isoc_packet_counter
)braket
suffix:semicolon
id|packet-&gt;status
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|myNextRxDesc-&gt;status
op_amp
id|IO_MASK
c_func
(paren
id|USB_IN_status
comma
id|nodata
)paren
)paren
(brace
multiline_comment|/* We get nodata for empty data transactions, and the rx descriptor&squot;s&n;&t;&t;&t;&t;   hw_len field is not valid in that case. We copy 0 bytes however to&n;&t;&t;&t;&t;   stay in synch. */
id|packet-&gt;actual_length
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|packet-&gt;actual_length
op_assign
id|myNextRxDesc-&gt;hw_len
suffix:semicolon
multiline_comment|/* Make sure the data fits in the buffer. */
m_assert
(paren
id|packet-&gt;actual_length
op_le
id|packet-&gt;length
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|urb-&gt;transfer_buffer
op_plus
id|packet-&gt;offset
comma
id|phys_to_virt
c_func
(paren
id|myNextRxDesc-&gt;buf
)paren
comma
id|packet-&gt;actual_length
)paren
suffix:semicolon
)brace
multiline_comment|/* Increment the packet counter. */
id|urb_priv-&gt;isoc_packet_counter
op_increment
suffix:semicolon
multiline_comment|/* Note that we don&squot;t care about the eot field in the rx descriptor&squot;s status.&n;&t;&t;&t;   It will always be set for isoc traffic. */
r_if
c_cond
(paren
id|urb-&gt;number_of_packets
op_eq
id|urb_priv-&gt;isoc_packet_counter
)paren
(brace
multiline_comment|/* Out-of-synch diagnostics. */
id|curr_fm
op_assign
(paren
op_star
id|R_USB_FM_NUMBER
op_amp
l_int|0x7ff
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|prev_fm
op_plus
id|urb_priv-&gt;isoc_packet_counter
)paren
op_mod
(paren
l_int|0x7ff
op_plus
l_int|1
)paren
)paren
op_ne
id|curr_fm
)paren
(brace
multiline_comment|/* This test is wrong, if there is more than one isoc&n;&t;&t;&t;&t;&t;   in endpoint active it will always calculate wrong&n;&t;&t;&t;&t;&t;   since prev_fm is shared by all endpoints.&n;&n;&t;&t;&t;&t;&t;   FIXME Make this check per URB using urb-&gt;start_frame.&n;&t;&t;&t;&t;&t;*/
id|dbg_isoc
c_func
(paren
l_string|&quot;Out of synch? Previous frame = %d, current frame = %d&quot;
comma
id|prev_fm
comma
id|curr_fm
)paren
suffix:semicolon
)brace
id|prev_fm
op_assign
id|curr_fm
suffix:semicolon
multiline_comment|/* Complete the urb with status OK. */
id|etrax_usb_complete_isoc_urb
c_func
(paren
id|urb
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|skip_out
suffix:colon
multiline_comment|/* DMA IN cache bug. Flush the DMA IN buffer from the cache. (struct etrax_dma_descr&n;&t;&t;   has the same layout as USB_IN_Desc for the relevant fields.) */
id|prepare_rx_descriptor
c_func
(paren
(paren
r_struct
id|etrax_dma_descr
op_star
)paren
id|myNextRxDesc
)paren
suffix:semicolon
id|myPrevRxDesc
op_assign
id|myNextRxDesc
suffix:semicolon
id|myPrevRxDesc-&gt;command
op_or_assign
id|IO_MASK
c_func
(paren
id|USB_IN_command
comma
id|eol
)paren
suffix:semicolon
id|myLastRxDesc-&gt;command
op_and_assign
op_complement
id|IO_MASK
c_func
(paren
id|USB_IN_command
comma
id|eol
)paren
suffix:semicolon
id|myLastRxDesc
op_assign
id|myPrevRxDesc
suffix:semicolon
id|myNextRxDesc-&gt;status
op_assign
l_int|0
suffix:semicolon
id|myNextRxDesc
op_assign
id|phys_to_virt
c_func
(paren
id|myNextRxDesc-&gt;next
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|DBFEXIT
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/* This function will unlink the SB descriptors associated with this urb. */
DECL|function|etrax_remove_from_sb_list
r_static
r_int
id|etrax_remove_from_sb_list
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
id|USB_SB_Desc_t
op_star
id|next_sb
comma
op_star
id|first_sb
comma
op_star
id|last_sb
suffix:semicolon
id|etrax_urb_priv_t
op_star
id|urb_priv
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|DBFENTER
suffix:semicolon
id|urb_priv
op_assign
(paren
id|etrax_urb_priv_t
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
m_assert
(paren
id|urb_priv
)paren
suffix:semicolon
multiline_comment|/* Just a sanity check. Since we don&squot;t fiddle with the DMA list the EP descriptor&n;&t;   doesn&squot;t really need to be disabled, it&squot;s just that we expect it to be. */
r_if
c_cond
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
op_eq
id|PIPE_BULK
)paren
(brace
m_assert
(paren
op_logical_neg
(paren
id|TxBulkEPList
(braket
id|urb_priv-&gt;epid
)braket
dot
id|command
op_amp
id|IO_MASK
c_func
(paren
id|USB_EP_command
comma
id|enable
)paren
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
op_eq
id|PIPE_CONTROL
)paren
(brace
m_assert
(paren
op_logical_neg
(paren
id|TxCtrlEPList
(braket
id|urb_priv-&gt;epid
)braket
dot
id|command
op_amp
id|IO_MASK
c_func
(paren
id|USB_EP_command
comma
id|enable
)paren
)paren
)paren
suffix:semicolon
)brace
id|first_sb
op_assign
id|urb_priv-&gt;first_sb
suffix:semicolon
id|last_sb
op_assign
id|urb_priv-&gt;last_sb
suffix:semicolon
m_assert
(paren
id|first_sb
)paren
suffix:semicolon
m_assert
(paren
id|last_sb
)paren
suffix:semicolon
r_while
c_loop
(paren
id|first_sb
op_ne
id|last_sb
)paren
(brace
id|next_sb
op_assign
(paren
id|USB_SB_Desc_t
op_star
)paren
id|phys_to_virt
c_func
(paren
id|first_sb-&gt;next
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|usb_desc_cache
comma
id|first_sb
)paren
suffix:semicolon
id|first_sb
op_assign
id|next_sb
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
id|kmem_cache_free
c_func
(paren
id|usb_desc_cache
comma
id|last_sb
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|dbg_sb
c_func
(paren
l_string|&quot;%d SB descriptors freed&quot;
comma
id|i
)paren
suffix:semicolon
multiline_comment|/* Compare i with urb-&gt;number_of_packets for Isoc traffic.&n;&t;   Should be same when calling unlink_urb */
id|DBFEXIT
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
DECL|function|etrax_usb_submit_bulk_urb
r_static
r_int
id|etrax_usb_submit_bulk_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
id|epid
suffix:semicolon
r_int
id|empty
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|etrax_urb_priv_t
op_star
id|urb_priv
suffix:semicolon
id|DBFENTER
suffix:semicolon
multiline_comment|/* Epid allocation, empty check and list add must be protected.&n;&t;   Read about this in etrax_usb_submit_ctrl_urb. */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|urb_list_lock
comma
id|flags
)paren
suffix:semicolon
id|epid
op_assign
id|etrax_usb_setup_epid
c_func
(paren
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|epid
op_eq
op_minus
l_int|1
)paren
(brace
id|DBFEXIT
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|urb_list_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|empty
op_assign
id|urb_list_empty
c_func
(paren
id|epid
)paren
suffix:semicolon
id|urb_list_add
c_func
(paren
id|urb
comma
id|epid
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|urb_list_lock
comma
id|flags
)paren
suffix:semicolon
id|dbg_bulk
c_func
(paren
l_string|&quot;Adding bulk %s urb 0x%lx to %s list, epid %d&quot;
comma
id|usb_pipein
c_func
(paren
id|urb-&gt;pipe
)paren
ques
c_cond
l_string|&quot;IN&quot;
suffix:colon
l_string|&quot;OUT&quot;
comma
(paren
r_int
r_int
)paren
id|urb
comma
id|empty
ques
c_cond
l_string|&quot;empty&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|epid
)paren
suffix:semicolon
multiline_comment|/* Mark the urb as being in progress. */
id|urb-&gt;status
op_assign
op_minus
id|EINPROGRESS
suffix:semicolon
multiline_comment|/* Setup the hcpriv data. */
id|urb_priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|etrax_urb_priv_t
)paren
comma
id|KMALLOC_FLAG
)paren
suffix:semicolon
m_assert
(paren
id|urb_priv
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* This sets rx_offset to 0. */
id|memset
c_func
(paren
id|urb_priv
comma
l_int|0
comma
r_sizeof
(paren
id|etrax_urb_priv_t
)paren
)paren
suffix:semicolon
id|urb_priv-&gt;urb_state
op_assign
id|NOT_STARTED
suffix:semicolon
id|urb-&gt;hcpriv
op_assign
id|urb_priv
suffix:semicolon
r_if
c_cond
(paren
id|empty
)paren
(brace
id|etrax_usb_add_to_bulk_sb_list
c_func
(paren
id|urb
comma
id|epid
)paren
suffix:semicolon
)brace
id|DBFEXIT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|etrax_usb_add_to_bulk_sb_list
r_static
r_void
id|etrax_usb_add_to_bulk_sb_list
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|epid
)paren
(brace
id|USB_SB_Desc_t
op_star
id|sb_desc
suffix:semicolon
id|etrax_urb_priv_t
op_star
id|urb_priv
op_assign
(paren
id|etrax_urb_priv_t
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_char
id|maxlen
suffix:semicolon
id|DBFENTER
suffix:semicolon
id|dbg_bulk
c_func
(paren
l_string|&quot;etrax_usb_add_to_bulk_sb_list, urb 0x%lx&quot;
comma
(paren
r_int
r_int
)paren
id|urb
)paren
suffix:semicolon
id|maxlen
op_assign
id|usb_maxpacket
c_func
(paren
id|urb-&gt;dev
comma
id|urb-&gt;pipe
comma
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
id|sb_desc
op_assign
(paren
id|USB_SB_Desc_t
op_star
)paren
id|kmem_cache_alloc
c_func
(paren
id|usb_desc_cache
comma
id|SLAB_FLAG
)paren
suffix:semicolon
m_assert
(paren
id|sb_desc
op_ne
l_int|NULL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|sb_desc
comma
l_int|0
comma
r_sizeof
(paren
id|USB_SB_Desc_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
id|dbg_bulk
c_func
(paren
l_string|&quot;Grabbing bulk OUT, urb 0x%lx, epid %d&quot;
comma
(paren
r_int
r_int
)paren
id|urb
comma
id|epid
)paren
suffix:semicolon
multiline_comment|/* This is probably a sanity check of the bulk transaction length&n;&t;&t;   not being larger than 64 kB. */
r_if
c_cond
(paren
id|urb-&gt;transfer_buffer_length
OG
l_int|0xffff
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;urb-&gt;transfer_buffer_length &gt; 0xffff&quot;
)paren
suffix:semicolon
)brace
id|sb_desc-&gt;sw_len
op_assign
id|urb-&gt;transfer_buffer_length
suffix:semicolon
multiline_comment|/* The rem field is don&squot;t care if it&squot;s not a full-length transfer, so setting&n;&t;&t;   it shouldn&squot;t hurt. Also, rem isn&squot;t used for OUT traffic. */
id|sb_desc-&gt;command
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|USB_SB_command
comma
id|rem
comma
l_int|0
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|tt
comma
id|out
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|eot
comma
id|yes
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|eol
comma
id|yes
)paren
)paren
suffix:semicolon
multiline_comment|/* The full field is set to yes, even if we don&squot;t actually check that this is&n;&t;&t;   a full-length transfer (i.e., that transfer_buffer_length % maxlen = 0).&n;&t;&t;   Setting full prevents the USB controller from sending an empty packet in&n;&t;&t;   that case.  However, if URB_ZERO_PACKET was set we want that. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|urb-&gt;transfer_flags
op_amp
id|URB_ZERO_PACKET
)paren
)paren
(brace
id|sb_desc-&gt;command
op_or_assign
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|full
comma
id|yes
)paren
suffix:semicolon
)brace
id|sb_desc-&gt;buf
op_assign
id|virt_to_phys
c_func
(paren
id|urb-&gt;transfer_buffer
)paren
suffix:semicolon
id|sb_desc-&gt;next
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|usb_pipein
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
id|dbg_bulk
c_func
(paren
l_string|&quot;Grabbing bulk IN, urb 0x%lx, epid %d&quot;
comma
(paren
r_int
r_int
)paren
id|urb
comma
id|epid
)paren
suffix:semicolon
id|sb_desc-&gt;sw_len
op_assign
id|urb-&gt;transfer_buffer_length
ques
c_cond
(paren
id|urb-&gt;transfer_buffer_length
op_minus
l_int|1
)paren
op_div
id|maxlen
op_plus
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* The rem field is don&squot;t care if it&squot;s not a full-length transfer, so setting&n;&t;&t;   it shouldn&squot;t hurt. */
id|sb_desc-&gt;command
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|USB_SB_command
comma
id|rem
comma
id|urb-&gt;transfer_buffer_length
op_mod
id|maxlen
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|tt
comma
id|in
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|eot
comma
id|yes
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|eol
comma
id|yes
)paren
)paren
suffix:semicolon
id|sb_desc-&gt;buf
op_assign
l_int|0
suffix:semicolon
id|sb_desc-&gt;next
op_assign
l_int|0
suffix:semicolon
)brace
id|urb_priv-&gt;first_sb
op_assign
id|sb_desc
suffix:semicolon
id|urb_priv-&gt;last_sb
op_assign
id|sb_desc
suffix:semicolon
id|urb_priv-&gt;epid
op_assign
id|epid
suffix:semicolon
id|urb-&gt;hcpriv
op_assign
id|urb_priv
suffix:semicolon
multiline_comment|/* Reset toggle bits and reset error count. */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
op_star
id|R_USB_EPT_INDEX
op_assign
id|IO_FIELD
c_func
(paren
id|R_USB_EPT_INDEX
comma
id|value
comma
id|epid
)paren
suffix:semicolon
id|nop
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* FIXME: Is this a special case since the hold field is checked,&n;&t;   or should we check hold in a lot of other cases as well? */
r_if
c_cond
(paren
op_star
id|R_USB_EPT_DATA
op_amp
id|IO_MASK
c_func
(paren
id|R_USB_EPT_DATA
comma
id|hold
)paren
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Hold was set in %s&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
)brace
multiline_comment|/* Reset error counters (regardless of which direction this traffic is). */
op_star
id|R_USB_EPT_DATA
op_and_assign
op_complement
(paren
id|IO_MASK
c_func
(paren
id|R_USB_EPT_DATA
comma
id|error_count_in
)paren
op_or
id|IO_MASK
c_func
(paren
id|R_USB_EPT_DATA
comma
id|error_count_out
)paren
)paren
suffix:semicolon
multiline_comment|/* Software must preset the toggle bits. */
r_if
c_cond
(paren
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
r_char
id|toggle
op_assign
id|usb_gettoggle
c_func
(paren
id|urb-&gt;dev
comma
id|usb_pipeendpoint
c_func
(paren
id|urb-&gt;pipe
)paren
comma
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
op_star
id|R_USB_EPT_DATA
op_and_assign
op_complement
id|IO_MASK
c_func
(paren
id|R_USB_EPT_DATA
comma
id|t_out
)paren
suffix:semicolon
op_star
id|R_USB_EPT_DATA
op_or_assign
id|IO_FIELD
c_func
(paren
id|R_USB_EPT_DATA
comma
id|t_out
comma
id|toggle
)paren
suffix:semicolon
)brace
r_else
(brace
r_char
id|toggle
op_assign
id|usb_gettoggle
c_func
(paren
id|urb-&gt;dev
comma
id|usb_pipeendpoint
c_func
(paren
id|urb-&gt;pipe
)paren
comma
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
op_star
id|R_USB_EPT_DATA
op_and_assign
op_complement
id|IO_MASK
c_func
(paren
id|R_USB_EPT_DATA
comma
id|t_in
)paren
suffix:semicolon
op_star
id|R_USB_EPT_DATA
op_or_assign
id|IO_FIELD
c_func
(paren
id|R_USB_EPT_DATA
comma
id|t_in
comma
id|toggle
)paren
suffix:semicolon
)brace
multiline_comment|/* Assert that the EP descriptor is disabled. */
m_assert
(paren
op_logical_neg
(paren
id|TxBulkEPList
(braket
id|epid
)braket
dot
id|command
op_amp
id|IO_MASK
c_func
(paren
id|USB_EP_command
comma
id|enable
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* The reason we set the EP&squot;s sub pointer directly instead of&n;&t;   walking the SB list and linking it last in the list is that we only&n;&t;   have one active urb at a time (the rest are queued). */
multiline_comment|/* Note that we cannot have interrupts running when we have set the SB descriptor&n;&t;   but the EP is not yet enabled.  If a bulk eot happens for another EP, we will&n;&t;   find this EP disabled and with a SB != 0, which will make us think that it&squot;s done. */
id|TxBulkEPList
(braket
id|epid
)braket
dot
id|sub
op_assign
id|virt_to_phys
c_func
(paren
id|sb_desc
)paren
suffix:semicolon
id|TxBulkEPList
(braket
id|epid
)braket
dot
id|hw_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Note that we don&squot;t have to fill in the ep_id field since this&n;&t;   was done when we allocated the EP descriptors in init_tx_bulk_ep. */
multiline_comment|/* Check if the dummy list is already with us (if several urbs were queued). */
r_if
c_cond
(paren
id|TxBulkEPList
(braket
id|epid
)braket
dot
id|next
op_ne
id|virt_to_phys
c_func
(paren
op_amp
id|TxBulkDummyEPList
(braket
id|epid
)braket
(braket
l_int|0
)braket
)paren
)paren
(brace
id|dbg_bulk
c_func
(paren
l_string|&quot;Inviting dummy list to the party for urb 0x%lx, epid %d&quot;
comma
(paren
r_int
r_int
)paren
id|urb
comma
id|epid
)paren
suffix:semicolon
multiline_comment|/* The last EP in the dummy list already has its next pointer set to&n;&t;&t;   TxBulkEPList[epid].next. */
multiline_comment|/* We don&squot;t need to check if the DMA is at this EP or not before changing the&n;&t;&t;   next pointer, since we will do it in one 32-bit write (EP descriptors are&n;&t;&t;   32-bit aligned). */
id|TxBulkEPList
(braket
id|epid
)braket
dot
id|next
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|TxBulkDummyEPList
(braket
id|epid
)braket
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Enable the EP descr. */
id|dbg_bulk
c_func
(paren
l_string|&quot;Enabling bulk EP for urb 0x%lx, epid %d&quot;
comma
(paren
r_int
r_int
)paren
id|urb
comma
id|epid
)paren
suffix:semicolon
id|TxBulkEPList
(braket
id|epid
)braket
dot
id|command
op_or_assign
id|IO_STATE
c_func
(paren
id|USB_EP_command
comma
id|enable
comma
id|yes
)paren
suffix:semicolon
multiline_comment|/* Everything is set up, safe to enable interrupts again. */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* If the DMA bulk channel isn&squot;t running, we need to restart it if it&n;&t;   has stopped at the last EP descriptor (DMA stopped because there was&n;&t;   no more traffic) or if it has stopped at a dummy EP with the intr flag&n;&t;   set (DMA stopped because we were too slow in inserting new traffic). */
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|R_DMA_CH8_SUB0_CMD
op_amp
id|IO_MASK
c_func
(paren
id|R_DMA_CH8_SUB0_CMD
comma
id|cmd
)paren
)paren
)paren
(brace
id|USB_EP_Desc_t
op_star
id|ep
suffix:semicolon
id|ep
op_assign
(paren
id|USB_EP_Desc_t
op_star
)paren
id|phys_to_virt
c_func
(paren
op_star
id|R_DMA_CH8_SUB0_EP
)paren
suffix:semicolon
id|dbg_bulk
c_func
(paren
l_string|&quot;DMA channel not running in add&quot;
)paren
suffix:semicolon
id|dbg_bulk
c_func
(paren
l_string|&quot;DMA is at 0x%lx&quot;
comma
(paren
r_int
r_int
)paren
id|ep
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|R_DMA_CH8_SUB0_EP
op_eq
id|virt_to_phys
c_func
(paren
op_amp
id|TxBulkEPList
(braket
id|NBR_OF_EPIDS
op_minus
l_int|1
)braket
)paren
op_logical_or
(paren
id|ep-&gt;command
op_amp
l_int|0x8
)paren
op_rshift
l_int|3
)paren
(brace
op_star
id|R_DMA_CH8_SUB0_CMD
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH8_SUB0_CMD
comma
id|cmd
comma
id|start
)paren
suffix:semicolon
multiline_comment|/* Update/restart the bulk start timer since we just started the channel. */
id|mod_timer
c_func
(paren
op_amp
id|bulk_start_timer
comma
id|jiffies
op_plus
id|BULK_START_TIMER_INTERVAL
)paren
suffix:semicolon
multiline_comment|/* Update/restart the bulk eot timer since we just inserted traffic. */
id|mod_timer
c_func
(paren
op_amp
id|bulk_eot_timer
comma
id|jiffies
op_plus
id|BULK_EOT_TIMER_INTERVAL
)paren
suffix:semicolon
)brace
)brace
id|DBFEXIT
suffix:semicolon
)brace
DECL|function|etrax_usb_complete_bulk_urb
r_static
r_void
id|etrax_usb_complete_bulk_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|status
)paren
(brace
id|etrax_urb_priv_t
op_star
id|urb_priv
op_assign
(paren
id|etrax_urb_priv_t
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
r_int
id|epid
op_assign
id|urb_priv-&gt;epid
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|DBFENTER
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
id|warn
c_func
(paren
l_string|&quot;Completing bulk urb with status %d.&quot;
comma
id|status
)paren
suffix:semicolon
id|dbg_bulk
c_func
(paren
l_string|&quot;Completing bulk urb 0x%lx for epid %d&quot;
comma
(paren
r_int
r_int
)paren
id|urb
comma
id|epid
)paren
suffix:semicolon
multiline_comment|/* Update the urb list. */
id|urb_list_del
c_func
(paren
id|urb
comma
id|epid
)paren
suffix:semicolon
multiline_comment|/* For an IN pipe, we always set the actual length, regardless of whether there was&n;&t;   an error or not (which means the device driver can use the data if it wants to). */
r_if
c_cond
(paren
id|usb_pipein
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
id|urb-&gt;actual_length
op_assign
id|urb_priv-&gt;rx_offset
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Set actual_length for OUT urbs also; the USB mass storage driver seems&n;&t;&t;   to want that. We wouldn&squot;t know of any partial writes if there was an error. */
r_if
c_cond
(paren
id|status
op_eq
l_int|0
)paren
(brace
id|urb-&gt;actual_length
op_assign
id|urb-&gt;transfer_buffer_length
suffix:semicolon
)brace
r_else
(brace
id|urb-&gt;actual_length
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* FIXME: Is there something of the things below we shouldn&squot;t do if there was an error?&n;&t;   Like, maybe we shouldn&squot;t toggle the toggle bits, or maybe we shouldn&squot;t insert more traffic. */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
op_star
id|R_USB_EPT_INDEX
op_assign
id|IO_FIELD
c_func
(paren
id|R_USB_EPT_INDEX
comma
id|value
comma
id|epid
)paren
suffix:semicolon
id|nop
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* We need to fiddle with the toggle bits because the hardware doesn&squot;t do it for us. */
r_if
c_cond
(paren
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
r_char
id|toggle
op_assign
id|IO_EXTRACT
c_func
(paren
id|R_USB_EPT_DATA
comma
id|t_out
comma
op_star
id|R_USB_EPT_DATA
)paren
suffix:semicolon
id|usb_settoggle
c_func
(paren
id|urb-&gt;dev
comma
id|usb_pipeendpoint
c_func
(paren
id|urb-&gt;pipe
)paren
comma
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
comma
id|toggle
)paren
suffix:semicolon
)brace
r_else
(brace
r_char
id|toggle
op_assign
id|IO_EXTRACT
c_func
(paren
id|R_USB_EPT_DATA
comma
id|t_in
comma
op_star
id|R_USB_EPT_DATA
)paren
suffix:semicolon
id|usb_settoggle
c_func
(paren
id|urb-&gt;dev
comma
id|usb_pipeendpoint
c_func
(paren
id|urb-&gt;pipe
)paren
comma
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
comma
id|toggle
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Remember to free the SBs. */
id|etrax_remove_from_sb_list
c_func
(paren
id|urb
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|urb_priv
)paren
suffix:semicolon
id|urb-&gt;hcpriv
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If there are any more urb&squot;s in the list we&squot;d better start sending */
r_if
c_cond
(paren
op_logical_neg
id|urb_list_empty
c_func
(paren
id|epid
)paren
)paren
(brace
r_struct
id|urb
op_star
id|new_urb
suffix:semicolon
multiline_comment|/* Get the first urb. */
id|new_urb
op_assign
id|urb_list_first
c_func
(paren
id|epid
)paren
suffix:semicolon
m_assert
(paren
id|new_urb
)paren
suffix:semicolon
id|dbg_bulk
c_func
(paren
l_string|&quot;More bulk for epid %d&quot;
comma
id|epid
)paren
suffix:semicolon
id|etrax_usb_add_to_bulk_sb_list
c_func
(paren
id|new_urb
comma
id|epid
)paren
suffix:semicolon
)brace
id|urb-&gt;status
op_assign
id|status
suffix:semicolon
multiline_comment|/* We let any non-zero status from the layer above have precedence. */
r_if
c_cond
(paren
id|status
op_eq
l_int|0
)paren
(brace
multiline_comment|/* URB_SHORT_NOT_OK means that short reads (shorter than the endpoint&squot;s max length)&n;&t;&t;   is to be treated as an error. */
r_if
c_cond
(paren
id|urb-&gt;transfer_flags
op_amp
id|URB_SHORT_NOT_OK
)paren
(brace
r_if
c_cond
(paren
id|usb_pipein
c_func
(paren
id|urb-&gt;pipe
)paren
op_logical_and
(paren
id|urb-&gt;actual_length
op_ne
id|usb_maxpacket
c_func
(paren
id|urb-&gt;dev
comma
id|urb-&gt;pipe
comma
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
)paren
)paren
(brace
id|urb-&gt;status
op_assign
op_minus
id|EREMOTEIO
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|urb-&gt;complete
)paren
(brace
id|urb
op_member_access_from_pointer
id|complete
c_func
(paren
id|urb
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|urb_list_empty
c_func
(paren
id|epid
)paren
)paren
(brace
multiline_comment|/* This means that this EP is now free, deconfigure it. */
id|etrax_usb_free_epid
c_func
(paren
id|epid
)paren
suffix:semicolon
multiline_comment|/* No more traffic; time to clean up.&n;&t;&t;   Must set sub pointer to 0, since we look at the sub pointer when handling&n;&t;&t;   the bulk eot interrupt. */
id|dbg_bulk
c_func
(paren
l_string|&quot;No bulk for epid %d&quot;
comma
id|epid
)paren
suffix:semicolon
id|TxBulkEPList
(braket
id|epid
)braket
dot
id|sub
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Unlink the dummy list. */
id|dbg_bulk
c_func
(paren
l_string|&quot;Kicking dummy list out of party for urb 0x%lx, epid %d&quot;
comma
(paren
r_int
r_int
)paren
id|urb
comma
id|epid
)paren
suffix:semicolon
multiline_comment|/* No need to wait for the DMA before changing the next pointer.&n;&t;&t;   The modulo NBR_OF_EPIDS isn&squot;t actually necessary, since we will never use&n;&t;&t;   the last one (INVALID_EPID) for actual traffic. */
id|TxBulkEPList
(braket
id|epid
)braket
dot
id|next
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|TxBulkEPList
(braket
(paren
id|epid
op_plus
l_int|1
)paren
op_mod
id|NBR_OF_EPIDS
)braket
)paren
suffix:semicolon
)brace
id|DBFEXIT
suffix:semicolon
)brace
DECL|function|etrax_usb_submit_ctrl_urb
r_static
r_int
id|etrax_usb_submit_ctrl_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
id|epid
suffix:semicolon
r_int
id|empty
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|etrax_urb_priv_t
op_star
id|urb_priv
suffix:semicolon
id|DBFENTER
suffix:semicolon
multiline_comment|/* FIXME: Return -ENXIO if there is already a queued urb for this endpoint? */
multiline_comment|/* Epid allocation, empty check and list add must be protected.&n;&n;&t;   Epid allocation because if we find an existing epid for this endpoint an urb might be&n;&t;   completed (emptying the list) before we add the new urb to the list, causing the epid&n;&t;   to be de-allocated. We would then start the transfer with an invalid epid -&gt; epid attn.&n;&n;&t;   Empty check and add because otherwise we might conclude that the list is not empty,&n;&t;   after which it becomes empty before we add the new urb to the list, causing us not to&n;&t;   insert the new traffic into the SB list. */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|urb_list_lock
comma
id|flags
)paren
suffix:semicolon
id|epid
op_assign
id|etrax_usb_setup_epid
c_func
(paren
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|epid
op_eq
op_minus
l_int|1
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|urb_list_lock
comma
id|flags
)paren
suffix:semicolon
id|DBFEXIT
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|empty
op_assign
id|urb_list_empty
c_func
(paren
id|epid
)paren
suffix:semicolon
id|urb_list_add
c_func
(paren
id|urb
comma
id|epid
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|urb_list_lock
comma
id|flags
)paren
suffix:semicolon
id|dbg_ctrl
c_func
(paren
l_string|&quot;Adding ctrl urb 0x%lx to %s list, epid %d&quot;
comma
(paren
r_int
r_int
)paren
id|urb
comma
id|empty
ques
c_cond
l_string|&quot;empty&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|epid
)paren
suffix:semicolon
multiline_comment|/* Mark the urb as being in progress. */
id|urb-&gt;status
op_assign
op_minus
id|EINPROGRESS
suffix:semicolon
multiline_comment|/* Setup the hcpriv data. */
id|urb_priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|etrax_urb_priv_t
)paren
comma
id|KMALLOC_FLAG
)paren
suffix:semicolon
m_assert
(paren
id|urb_priv
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* This sets rx_offset to 0. */
id|memset
c_func
(paren
id|urb_priv
comma
l_int|0
comma
r_sizeof
(paren
id|etrax_urb_priv_t
)paren
)paren
suffix:semicolon
id|urb_priv-&gt;urb_state
op_assign
id|NOT_STARTED
suffix:semicolon
id|urb-&gt;hcpriv
op_assign
id|urb_priv
suffix:semicolon
r_if
c_cond
(paren
id|empty
)paren
(brace
id|etrax_usb_add_to_ctrl_sb_list
c_func
(paren
id|urb
comma
id|epid
)paren
suffix:semicolon
)brace
id|DBFEXIT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|etrax_usb_add_to_ctrl_sb_list
r_static
r_void
id|etrax_usb_add_to_ctrl_sb_list
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|epid
)paren
(brace
id|USB_SB_Desc_t
op_star
id|sb_desc_setup
suffix:semicolon
id|USB_SB_Desc_t
op_star
id|sb_desc_data
suffix:semicolon
id|USB_SB_Desc_t
op_star
id|sb_desc_status
suffix:semicolon
id|etrax_urb_priv_t
op_star
id|urb_priv
op_assign
(paren
id|etrax_urb_priv_t
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_char
id|maxlen
suffix:semicolon
id|DBFENTER
suffix:semicolon
id|maxlen
op_assign
id|usb_maxpacket
c_func
(paren
id|urb-&gt;dev
comma
id|urb-&gt;pipe
comma
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
id|sb_desc_setup
op_assign
(paren
id|USB_SB_Desc_t
op_star
)paren
id|kmem_cache_alloc
c_func
(paren
id|usb_desc_cache
comma
id|SLAB_FLAG
)paren
suffix:semicolon
m_assert
(paren
id|sb_desc_setup
op_ne
l_int|NULL
)paren
suffix:semicolon
id|sb_desc_status
op_assign
(paren
id|USB_SB_Desc_t
op_star
)paren
id|kmem_cache_alloc
c_func
(paren
id|usb_desc_cache
comma
id|SLAB_FLAG
)paren
suffix:semicolon
m_assert
(paren
id|sb_desc_status
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Initialize the mandatory setup SB descriptor (used only in control transfers) */
id|sb_desc_setup-&gt;sw_len
op_assign
l_int|8
suffix:semicolon
id|sb_desc_setup-&gt;command
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|USB_SB_command
comma
id|rem
comma
l_int|0
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|tt
comma
id|setup
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|full
comma
id|yes
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|eot
comma
id|yes
)paren
)paren
suffix:semicolon
id|sb_desc_setup-&gt;buf
op_assign
id|virt_to_phys
c_func
(paren
id|urb-&gt;setup_packet
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
id|dbg_ctrl
c_func
(paren
l_string|&quot;Transfer for epid %d is OUT&quot;
comma
id|epid
)paren
suffix:semicolon
multiline_comment|/* If this Control OUT transfer has an optional data stage we add an OUT token&n;&t;&t;   before the mandatory IN (status) token, hence the reordered SB list */
id|sb_desc_setup-&gt;next
op_assign
id|virt_to_phys
c_func
(paren
id|sb_desc_status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;transfer_buffer
)paren
(brace
id|dbg_ctrl
c_func
(paren
l_string|&quot;This OUT transfer has an extra data stage&quot;
)paren
suffix:semicolon
id|sb_desc_data
op_assign
(paren
id|USB_SB_Desc_t
op_star
)paren
id|kmem_cache_alloc
c_func
(paren
id|usb_desc_cache
comma
id|SLAB_FLAG
)paren
suffix:semicolon
m_assert
(paren
id|sb_desc_data
op_ne
l_int|NULL
)paren
suffix:semicolon
id|sb_desc_setup-&gt;next
op_assign
id|virt_to_phys
c_func
(paren
id|sb_desc_data
)paren
suffix:semicolon
id|sb_desc_data-&gt;sw_len
op_assign
id|urb-&gt;transfer_buffer_length
suffix:semicolon
id|sb_desc_data-&gt;command
op_assign
(paren
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|tt
comma
id|out
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|full
comma
id|yes
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|eot
comma
id|yes
)paren
)paren
suffix:semicolon
id|sb_desc_data-&gt;buf
op_assign
id|virt_to_phys
c_func
(paren
id|urb-&gt;transfer_buffer
)paren
suffix:semicolon
id|sb_desc_data-&gt;next
op_assign
id|virt_to_phys
c_func
(paren
id|sb_desc_status
)paren
suffix:semicolon
)brace
id|sb_desc_status-&gt;sw_len
op_assign
l_int|1
suffix:semicolon
id|sb_desc_status-&gt;command
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|USB_SB_command
comma
id|rem
comma
l_int|0
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|tt
comma
id|in
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|eot
comma
id|yes
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|intr
comma
id|yes
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|eol
comma
id|yes
)paren
)paren
suffix:semicolon
id|sb_desc_status-&gt;buf
op_assign
l_int|0
suffix:semicolon
id|sb_desc_status-&gt;next
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|usb_pipein
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
id|dbg_ctrl
c_func
(paren
l_string|&quot;Transfer for epid %d is IN&quot;
comma
id|epid
)paren
suffix:semicolon
id|dbg_ctrl
c_func
(paren
l_string|&quot;transfer_buffer_length = %d&quot;
comma
id|urb-&gt;transfer_buffer_length
)paren
suffix:semicolon
id|dbg_ctrl
c_func
(paren
l_string|&quot;rem is calculated to %d&quot;
comma
id|urb-&gt;transfer_buffer_length
op_mod
id|maxlen
)paren
suffix:semicolon
id|sb_desc_data
op_assign
(paren
id|USB_SB_Desc_t
op_star
)paren
id|kmem_cache_alloc
c_func
(paren
id|usb_desc_cache
comma
id|SLAB_FLAG
)paren
suffix:semicolon
m_assert
(paren
id|sb_desc_data
op_ne
l_int|NULL
)paren
suffix:semicolon
id|sb_desc_setup-&gt;next
op_assign
id|virt_to_phys
c_func
(paren
id|sb_desc_data
)paren
suffix:semicolon
id|sb_desc_data-&gt;sw_len
op_assign
id|urb-&gt;transfer_buffer_length
ques
c_cond
(paren
id|urb-&gt;transfer_buffer_length
op_minus
l_int|1
)paren
op_div
id|maxlen
op_plus
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|dbg_ctrl
c_func
(paren
l_string|&quot;sw_len got %d&quot;
comma
id|sb_desc_data-&gt;sw_len
)paren
suffix:semicolon
id|sb_desc_data-&gt;command
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|USB_SB_command
comma
id|rem
comma
id|urb-&gt;transfer_buffer_length
op_mod
id|maxlen
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|tt
comma
id|in
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|eot
comma
id|yes
)paren
)paren
suffix:semicolon
id|sb_desc_data-&gt;buf
op_assign
l_int|0
suffix:semicolon
id|sb_desc_data-&gt;next
op_assign
id|virt_to_phys
c_func
(paren
id|sb_desc_status
)paren
suffix:semicolon
multiline_comment|/* Read comment at zout_buffer declaration for an explanation to this. */
id|sb_desc_status-&gt;sw_len
op_assign
l_int|1
suffix:semicolon
id|sb_desc_status-&gt;command
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|USB_SB_command
comma
id|rem
comma
l_int|0
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|tt
comma
id|zout
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|full
comma
id|yes
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|eot
comma
id|yes
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|intr
comma
id|yes
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|eol
comma
id|yes
)paren
)paren
suffix:semicolon
id|sb_desc_status-&gt;buf
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|zout_buffer
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|sb_desc_status-&gt;next
op_assign
l_int|0
suffix:semicolon
)brace
id|urb_priv-&gt;first_sb
op_assign
id|sb_desc_setup
suffix:semicolon
id|urb_priv-&gt;last_sb
op_assign
id|sb_desc_status
suffix:semicolon
id|urb_priv-&gt;epid
op_assign
id|epid
suffix:semicolon
id|urb_priv-&gt;urb_state
op_assign
id|STARTED
suffix:semicolon
multiline_comment|/* Reset toggle bits and reset error count, remember to di and ei */
multiline_comment|/* Warning: it is possible that this locking doesn&squot;t work with bottom-halves */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
op_star
id|R_USB_EPT_INDEX
op_assign
id|IO_FIELD
c_func
(paren
id|R_USB_EPT_INDEX
comma
id|value
comma
id|epid
)paren
suffix:semicolon
id|nop
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|R_USB_EPT_DATA
op_amp
id|IO_MASK
c_func
(paren
id|R_USB_EPT_DATA
comma
id|hold
)paren
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Hold was set in %s&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
)brace
multiline_comment|/* FIXME: Compare with etrax_usb_add_to_bulk_sb_list where the toggle bits&n;&t;   are set to a specific value. Why the difference? Read &quot;Transfer and Toggle Bits&n;&t;   in Designer&squot;s Reference, p. 8 - 11. */
op_star
id|R_USB_EPT_DATA
op_and_assign
op_complement
(paren
id|IO_MASK
c_func
(paren
id|R_USB_EPT_DATA
comma
id|error_count_in
)paren
op_or
id|IO_MASK
c_func
(paren
id|R_USB_EPT_DATA
comma
id|error_count_out
)paren
op_or
id|IO_MASK
c_func
(paren
id|R_USB_EPT_DATA
comma
id|t_in
)paren
op_or
id|IO_MASK
c_func
(paren
id|R_USB_EPT_DATA
comma
id|t_out
)paren
)paren
suffix:semicolon
multiline_comment|/* Since we use the rx interrupt to complete ctrl urbs, we can enable interrupts now&n;&t;   (i.e. we don&squot;t check the sub pointer on an eot interrupt like we do for bulk traffic). */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Assert that the EP descriptor is disabled. */
m_assert
(paren
op_logical_neg
(paren
id|TxCtrlEPList
(braket
id|epid
)braket
dot
id|command
op_amp
id|IO_MASK
c_func
(paren
id|USB_EP_command
comma
id|enable
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Set up and enable the EP descriptor. */
id|TxCtrlEPList
(braket
id|epid
)braket
dot
id|sub
op_assign
id|virt_to_phys
c_func
(paren
id|sb_desc_setup
)paren
suffix:semicolon
id|TxCtrlEPList
(braket
id|epid
)braket
dot
id|hw_len
op_assign
l_int|0
suffix:semicolon
id|TxCtrlEPList
(braket
id|epid
)braket
dot
id|command
op_or_assign
id|IO_STATE
c_func
(paren
id|USB_EP_command
comma
id|enable
comma
id|yes
)paren
suffix:semicolon
multiline_comment|/* We start the DMA sub channel without checking if it&squot;s running or not, because:&n;&t;   1) If it&squot;s already running, issuing the start command is a nop.&n;&t;   2) We avoid a test-and-set race condition. */
op_star
id|R_DMA_CH8_SUB1_CMD
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH8_SUB1_CMD
comma
id|cmd
comma
id|start
)paren
suffix:semicolon
id|DBFEXIT
suffix:semicolon
)brace
DECL|function|etrax_usb_complete_ctrl_urb
r_static
r_void
id|etrax_usb_complete_ctrl_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|status
)paren
(brace
id|etrax_urb_priv_t
op_star
id|urb_priv
op_assign
(paren
id|etrax_urb_priv_t
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
r_int
id|epid
op_assign
id|urb_priv-&gt;epid
suffix:semicolon
id|DBFENTER
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
id|warn
c_func
(paren
l_string|&quot;Completing ctrl urb with status %d.&quot;
comma
id|status
)paren
suffix:semicolon
id|dbg_ctrl
c_func
(paren
l_string|&quot;Completing ctrl epid %d, urb 0x%lx&quot;
comma
id|epid
comma
(paren
r_int
r_int
)paren
id|urb
)paren
suffix:semicolon
multiline_comment|/* Remove this urb from the list. */
id|urb_list_del
c_func
(paren
id|urb
comma
id|epid
)paren
suffix:semicolon
multiline_comment|/* For an IN pipe, we always set the actual length, regardless of whether there was&n;&t;   an error or not (which means the device driver can use the data if it wants to). */
r_if
c_cond
(paren
id|usb_pipein
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
id|urb-&gt;actual_length
op_assign
id|urb_priv-&gt;rx_offset
suffix:semicolon
)brace
multiline_comment|/* FIXME: Is there something of the things below we shouldn&squot;t do if there was an error?&n;&t;   Like, maybe we shouldn&squot;t insert more traffic. */
multiline_comment|/* Remember to free the SBs. */
id|etrax_remove_from_sb_list
c_func
(paren
id|urb
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|urb_priv
)paren
suffix:semicolon
id|urb-&gt;hcpriv
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If there are any more urbs in the list we&squot;d better start sending. */
r_if
c_cond
(paren
op_logical_neg
id|urb_list_empty
c_func
(paren
id|epid
)paren
)paren
(brace
r_struct
id|urb
op_star
id|new_urb
suffix:semicolon
multiline_comment|/* Get the first urb. */
id|new_urb
op_assign
id|urb_list_first
c_func
(paren
id|epid
)paren
suffix:semicolon
m_assert
(paren
id|new_urb
)paren
suffix:semicolon
id|dbg_ctrl
c_func
(paren
l_string|&quot;More ctrl for epid %d, first urb = 0x%lx&quot;
comma
id|epid
comma
(paren
r_int
r_int
)paren
id|new_urb
)paren
suffix:semicolon
id|etrax_usb_add_to_ctrl_sb_list
c_func
(paren
id|new_urb
comma
id|epid
)paren
suffix:semicolon
)brace
id|urb-&gt;status
op_assign
id|status
suffix:semicolon
multiline_comment|/* We let any non-zero status from the layer above have precedence. */
r_if
c_cond
(paren
id|status
op_eq
l_int|0
)paren
(brace
multiline_comment|/* URB_SHORT_NOT_OK means that short reads (shorter than the endpoint&squot;s max length)&n;&t;&t;   is to be treated as an error. */
r_if
c_cond
(paren
id|urb-&gt;transfer_flags
op_amp
id|URB_SHORT_NOT_OK
)paren
(brace
r_if
c_cond
(paren
id|usb_pipein
c_func
(paren
id|urb-&gt;pipe
)paren
op_logical_and
(paren
id|urb-&gt;actual_length
op_ne
id|usb_maxpacket
c_func
(paren
id|urb-&gt;dev
comma
id|urb-&gt;pipe
comma
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
)paren
)paren
(brace
id|urb-&gt;status
op_assign
op_minus
id|EREMOTEIO
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|urb-&gt;complete
)paren
(brace
id|urb
op_member_access_from_pointer
id|complete
c_func
(paren
id|urb
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|urb_list_empty
c_func
(paren
id|epid
)paren
)paren
(brace
multiline_comment|/* No more traffic. Time to clean up. */
id|etrax_usb_free_epid
c_func
(paren
id|epid
)paren
suffix:semicolon
multiline_comment|/* Must set sub pointer to 0. */
id|dbg_ctrl
c_func
(paren
l_string|&quot;No ctrl for epid %d&quot;
comma
id|epid
)paren
suffix:semicolon
id|TxCtrlEPList
(braket
id|epid
)braket
dot
id|sub
op_assign
l_int|0
suffix:semicolon
)brace
id|DBFEXIT
suffix:semicolon
)brace
DECL|function|etrax_usb_submit_intr_urb
r_static
r_int
id|etrax_usb_submit_intr_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
id|epid
suffix:semicolon
id|DBFENTER
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
multiline_comment|/* Unsupported transfer type.&n;&t;&t;   We don&squot;t support interrupt out traffic. (If we do, we can&squot;t support&n;&t;&t;   intervals for neither in or out traffic, but are forced to schedule all&n;&t;&t;   interrupt traffic in one frame.) */
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|epid
op_assign
id|etrax_usb_setup_epid
c_func
(paren
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|epid
op_eq
op_minus
l_int|1
)paren
(brace
id|DBFEXIT
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|urb_list_empty
c_func
(paren
id|epid
)paren
)paren
(brace
multiline_comment|/* There is already a queued urb for this endpoint. */
id|etrax_usb_free_epid
c_func
(paren
id|epid
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|urb-&gt;status
op_assign
op_minus
id|EINPROGRESS
suffix:semicolon
id|dbg_intr
c_func
(paren
l_string|&quot;Add intr urb 0x%lx, to list, epid %d&quot;
comma
(paren
r_int
r_int
)paren
id|urb
comma
id|epid
)paren
suffix:semicolon
id|urb_list_add
c_func
(paren
id|urb
comma
id|epid
)paren
suffix:semicolon
id|etrax_usb_add_to_intr_sb_list
c_func
(paren
id|urb
comma
id|epid
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|DBFEXIT
suffix:semicolon
)brace
DECL|function|etrax_usb_add_to_intr_sb_list
r_static
r_void
id|etrax_usb_add_to_intr_sb_list
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|epid
)paren
(brace
r_volatile
id|USB_EP_Desc_t
op_star
id|tmp_ep
suffix:semicolon
r_volatile
id|USB_EP_Desc_t
op_star
id|first_ep
suffix:semicolon
r_char
id|maxlen
suffix:semicolon
r_int
id|interval
suffix:semicolon
r_int
id|i
suffix:semicolon
id|etrax_urb_priv_t
op_star
id|urb_priv
suffix:semicolon
id|DBFENTER
suffix:semicolon
id|maxlen
op_assign
id|usb_maxpacket
c_func
(paren
id|urb-&gt;dev
comma
id|urb-&gt;pipe
comma
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
id|interval
op_assign
id|urb-&gt;interval
suffix:semicolon
id|urb_priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|etrax_urb_priv_t
)paren
comma
id|KMALLOC_FLAG
)paren
suffix:semicolon
m_assert
(paren
id|urb_priv
op_ne
l_int|NULL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|urb_priv
comma
l_int|0
comma
r_sizeof
(paren
id|etrax_urb_priv_t
)paren
)paren
suffix:semicolon
id|urb-&gt;hcpriv
op_assign
id|urb_priv
suffix:semicolon
id|first_ep
op_assign
op_amp
id|TxIntrEPList
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* Round of the interval to 2^n, it is obvious that this code favours&n;&t;   smaller numbers, but that is actually a good thing */
multiline_comment|/* FIXME: The &quot;rounding error&quot; for larger intervals will be quite&n;&t;   large. For in traffic this shouldn&squot;t be a problem since it will only&n;&t;   mean that we &quot;poll&quot; more often. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|interval
suffix:semicolon
id|i
op_increment
)paren
(brace
id|interval
op_assign
id|interval
op_rshift
l_int|1
suffix:semicolon
)brace
id|interval
op_assign
l_int|1
op_lshift
(paren
id|i
op_minus
l_int|1
)paren
suffix:semicolon
id|dbg_intr
c_func
(paren
l_string|&quot;Interval rounded to %d&quot;
comma
id|interval
)paren
suffix:semicolon
id|tmp_ep
op_assign
id|first_ep
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|tmp_ep-&gt;command
op_amp
id|IO_MASK
c_func
(paren
id|USB_EP_command
comma
id|eof
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_mod
id|interval
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Insert the traffic ep after tmp_ep */
id|USB_EP_Desc_t
op_star
id|ep_desc
suffix:semicolon
id|USB_SB_Desc_t
op_star
id|sb_desc
suffix:semicolon
id|dbg_intr
c_func
(paren
l_string|&quot;Inserting EP for epid %d&quot;
comma
id|epid
)paren
suffix:semicolon
id|ep_desc
op_assign
(paren
id|USB_EP_Desc_t
op_star
)paren
id|kmem_cache_alloc
c_func
(paren
id|usb_desc_cache
comma
id|SLAB_FLAG
)paren
suffix:semicolon
id|sb_desc
op_assign
(paren
id|USB_SB_Desc_t
op_star
)paren
id|kmem_cache_alloc
c_func
(paren
id|usb_desc_cache
comma
id|SLAB_FLAG
)paren
suffix:semicolon
m_assert
(paren
id|ep_desc
op_ne
l_int|NULL
)paren
suffix:semicolon
id|CHECK_ALIGN
c_func
(paren
id|ep_desc
)paren
suffix:semicolon
m_assert
(paren
id|sb_desc
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ep_desc-&gt;sub
op_assign
id|virt_to_phys
c_func
(paren
id|sb_desc
)paren
suffix:semicolon
id|ep_desc-&gt;hw_len
op_assign
l_int|0
suffix:semicolon
id|ep_desc-&gt;command
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|USB_EP_command
comma
id|epid
comma
id|epid
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_EP_command
comma
id|enable
comma
id|yes
)paren
)paren
suffix:semicolon
multiline_comment|/* Round upwards the number of packets of size maxlen&n;&t;&t;&t;&t;   that this SB descriptor should receive. */
id|sb_desc-&gt;sw_len
op_assign
id|urb-&gt;transfer_buffer_length
ques
c_cond
(paren
id|urb-&gt;transfer_buffer_length
op_minus
l_int|1
)paren
op_div
id|maxlen
op_plus
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|sb_desc-&gt;next
op_assign
l_int|0
suffix:semicolon
id|sb_desc-&gt;buf
op_assign
l_int|0
suffix:semicolon
id|sb_desc-&gt;command
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|USB_SB_command
comma
id|rem
comma
id|urb-&gt;transfer_buffer_length
op_mod
id|maxlen
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|tt
comma
id|in
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|eot
comma
id|yes
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|eol
comma
id|yes
)paren
)paren
suffix:semicolon
id|ep_desc-&gt;next
op_assign
id|tmp_ep-&gt;next
suffix:semicolon
id|tmp_ep-&gt;next
op_assign
id|virt_to_phys
c_func
(paren
id|ep_desc
)paren
suffix:semicolon
)brace
id|i
op_increment
suffix:semicolon
)brace
id|tmp_ep
op_assign
(paren
id|USB_EP_Desc_t
op_star
)paren
id|phys_to_virt
c_func
(paren
id|tmp_ep-&gt;next
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp_ep
op_ne
id|first_ep
)paren
suffix:semicolon
multiline_comment|/* Note that first_sb/last_sb doesn&squot;t apply to interrupt traffic. */
id|urb_priv-&gt;epid
op_assign
id|epid
suffix:semicolon
multiline_comment|/* We start the DMA sub channel without checking if it&squot;s running or not, because:&n;&t;   1) If it&squot;s already running, issuing the start command is a nop.&n;&t;   2) We avoid a test-and-set race condition. */
op_star
id|R_DMA_CH8_SUB2_CMD
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH8_SUB2_CMD
comma
id|cmd
comma
id|start
)paren
suffix:semicolon
id|DBFEXIT
suffix:semicolon
)brace
DECL|function|etrax_usb_complete_intr_urb
r_static
r_void
id|etrax_usb_complete_intr_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|status
)paren
(brace
id|etrax_urb_priv_t
op_star
id|urb_priv
op_assign
(paren
id|etrax_urb_priv_t
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
r_int
id|epid
op_assign
id|urb_priv-&gt;epid
suffix:semicolon
id|DBFENTER
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
id|warn
c_func
(paren
l_string|&quot;Completing intr urb with status %d.&quot;
comma
id|status
)paren
suffix:semicolon
id|dbg_intr
c_func
(paren
l_string|&quot;Completing intr epid %d, urb 0x%lx&quot;
comma
id|epid
comma
(paren
r_int
r_int
)paren
id|urb
)paren
suffix:semicolon
id|urb-&gt;status
op_assign
id|status
suffix:semicolon
id|urb-&gt;actual_length
op_assign
id|urb_priv-&gt;rx_offset
suffix:semicolon
id|dbg_intr
c_func
(paren
l_string|&quot;interrupt urb-&gt;actual_length = %d&quot;
comma
id|urb-&gt;actual_length
)paren
suffix:semicolon
multiline_comment|/* We let any non-zero status from the layer above have precedence. */
r_if
c_cond
(paren
id|status
op_eq
l_int|0
)paren
(brace
multiline_comment|/* URB_SHORT_NOT_OK means that short reads (shorter than the endpoint&squot;s max length)&n;&t;&t;   is to be treated as an error. */
r_if
c_cond
(paren
id|urb-&gt;transfer_flags
op_amp
id|URB_SHORT_NOT_OK
)paren
(brace
r_if
c_cond
(paren
id|urb-&gt;actual_length
op_ne
id|usb_maxpacket
c_func
(paren
id|urb-&gt;dev
comma
id|urb-&gt;pipe
comma
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
)paren
(brace
id|urb-&gt;status
op_assign
op_minus
id|EREMOTEIO
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* The driver will resubmit the URB so we need to remove it first */
id|etrax_usb_unlink_urb
c_func
(paren
id|urb
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;complete
)paren
(brace
id|urb
op_member_access_from_pointer
id|complete
c_func
(paren
id|urb
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|DBFEXIT
suffix:semicolon
)brace
DECL|function|etrax_usb_submit_isoc_urb
r_static
r_int
id|etrax_usb_submit_isoc_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
id|epid
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|DBFENTER
suffix:semicolon
id|dbg_isoc
c_func
(paren
l_string|&quot;Submitting isoc urb = 0x%lx&quot;
comma
(paren
r_int
r_int
)paren
id|urb
)paren
suffix:semicolon
multiline_comment|/* Epid allocation, empty check and list add must be protected.&n;&t;   Read about this in etrax_usb_submit_ctrl_urb. */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|urb_list_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Is there an active epid for this urb ? */
id|epid
op_assign
id|etrax_usb_setup_epid
c_func
(paren
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|epid
op_eq
op_minus
l_int|1
)paren
(brace
id|DBFEXIT
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|urb_list_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Ok, now we got valid endpoint, lets insert some traffic */
id|urb-&gt;status
op_assign
op_minus
id|EINPROGRESS
suffix:semicolon
multiline_comment|/* Find the last urb in the URB_List and add this urb after that one.&n;&t;   Also add the traffic, that is do an etrax_usb_add_to_isoc_sb_list.  This&n;&t;   is important to make this in &quot;real time&quot; since isochronous traffic is&n;&t;   time sensitive. */
id|dbg_isoc
c_func
(paren
l_string|&quot;Adding isoc urb to (possibly empty) list&quot;
)paren
suffix:semicolon
id|urb_list_add
c_func
(paren
id|urb
comma
id|epid
)paren
suffix:semicolon
id|etrax_usb_add_to_isoc_sb_list
c_func
(paren
id|urb
comma
id|epid
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|urb_list_lock
comma
id|flags
)paren
suffix:semicolon
id|DBFEXIT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|etrax_usb_check_error_isoc_ep
r_static
r_void
id|etrax_usb_check_error_isoc_ep
c_func
(paren
r_const
r_int
id|epid
)paren
(brace
r_int
r_int
r_int
id|flags
suffix:semicolon
r_int
id|error_code
suffix:semicolon
id|__u32
id|r_usb_ept_data
suffix:semicolon
multiline_comment|/* We can&squot;t read R_USB_EPID_ATTN here since it would clear the iso_eof,&n;&t;   bulk_eot and epid_attn interrupts.  So we just check the status of&n;&t;   the epid without testing if for it in R_USB_EPID_ATTN. */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
op_star
id|R_USB_EPT_INDEX
op_assign
id|IO_FIELD
c_func
(paren
id|R_USB_EPT_INDEX
comma
id|value
comma
id|epid
)paren
suffix:semicolon
id|nop
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Note that although there are separate R_USB_EPT_DATA and R_USB_EPT_DATA_ISO&n;&t;   registers, they are located at the same address and are of the same size.&n;&t;   In other words, this read should be ok for isoc also. */
id|r_usb_ept_data
op_assign
op_star
id|R_USB_EPT_DATA
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|error_code
op_assign
id|IO_EXTRACT
c_func
(paren
id|R_USB_EPT_DATA_ISO
comma
id|error_code
comma
id|r_usb_ept_data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r_usb_ept_data
op_amp
id|IO_MASK
c_func
(paren
id|R_USB_EPT_DATA
comma
id|hold
)paren
)paren
(brace
id|warn
c_func
(paren
l_string|&quot;Hold was set for epid %d.&quot;
comma
id|epid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error_code
op_eq
id|IO_STATE_VALUE
c_func
(paren
id|R_USB_EPT_DATA_ISO
comma
id|error_code
comma
id|no_error
)paren
)paren
(brace
multiline_comment|/* This indicates that the SB list of the ept was completed before&n;&t;&t;   new data was appended to it.  This is not an error, but indicates&n;&t;&t;   large system or USB load and could possibly cause trouble for&n;&t;&t;   very timing sensitive USB device drivers so we log it.&n;&t;&t;*/
id|info
c_func
(paren
l_string|&quot;Isoc. epid %d disabled with no error&quot;
comma
id|epid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|error_code
op_eq
id|IO_STATE_VALUE
c_func
(paren
id|R_USB_EPT_DATA_ISO
comma
id|error_code
comma
id|stall
)paren
)paren
(brace
multiline_comment|/* Not really a protocol error, just says that the endpoint gave&n;&t;&t;   a stall response. Note that error_code cannot be stall for isoc. */
id|panic
c_func
(paren
l_string|&quot;Isoc traffic cannot stall&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|error_code
op_eq
id|IO_STATE_VALUE
c_func
(paren
id|R_USB_EPT_DATA_ISO
comma
id|error_code
comma
id|bus_error
)paren
)paren
(brace
multiline_comment|/* Two devices responded to a transaction request. Must be resolved&n;&t;&t;   by software. FIXME: Reset ports? */
id|panic
c_func
(paren
l_string|&quot;Bus error for epid %d.&quot;
l_string|&quot; Two devices responded to transaction request&quot;
comma
id|epid
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|error_code
op_eq
id|IO_STATE_VALUE
c_func
(paren
id|R_USB_EPT_DATA
comma
id|error_code
comma
id|buffer_error
)paren
)paren
(brace
multiline_comment|/* DMA overrun or underrun. */
id|warn
c_func
(paren
l_string|&quot;Buffer overrun/underrun for epid %d. DMA too busy?&quot;
comma
id|epid
)paren
suffix:semicolon
multiline_comment|/* It seems that error_code = buffer_error in&n;&t;&t;   R_USB_EPT_DATA/R_USB_EPT_DATA_ISO and ourun = yes in R_USB_STATUS&n;&t;&t;   are the same error. */
)brace
)brace
DECL|function|etrax_usb_add_to_isoc_sb_list
r_static
r_void
id|etrax_usb_add_to_isoc_sb_list
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|epid
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|etrax_urb_priv_t
op_star
id|urb_priv
suffix:semicolon
id|USB_SB_Desc_t
op_star
id|prev_sb_desc
comma
op_star
id|next_sb_desc
comma
op_star
id|temp_sb_desc
suffix:semicolon
id|DBFENTER
suffix:semicolon
id|prev_sb_desc
op_assign
id|next_sb_desc
op_assign
id|temp_sb_desc
op_assign
l_int|NULL
suffix:semicolon
id|urb_priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|etrax_urb_priv_t
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
m_assert
(paren
id|urb_priv
op_ne
l_int|NULL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|urb_priv
comma
l_int|0
comma
r_sizeof
(paren
id|etrax_urb_priv_t
)paren
)paren
suffix:semicolon
id|urb-&gt;hcpriv
op_assign
id|urb_priv
suffix:semicolon
id|urb_priv-&gt;epid
op_assign
id|epid
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
r_if
c_cond
(paren
id|urb-&gt;number_of_packets
op_eq
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;etrax_usb_add_to_isoc_sb_list 0 packets&bslash;n&quot;
)paren
suffix:semicolon
id|dbg_isoc
c_func
(paren
l_string|&quot;Transfer for epid %d is OUT&quot;
comma
id|epid
)paren
suffix:semicolon
id|dbg_isoc
c_func
(paren
l_string|&quot;%d packets in URB&quot;
comma
id|urb-&gt;number_of_packets
)paren
suffix:semicolon
multiline_comment|/* Create one SB descriptor for each packet and link them together. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|length
)paren
r_continue
suffix:semicolon
id|next_sb_desc
op_assign
(paren
id|USB_SB_Desc_t
op_star
)paren
id|kmem_cache_alloc
c_func
(paren
id|usb_desc_cache
comma
id|SLAB_ATOMIC
)paren
suffix:semicolon
m_assert
(paren
id|next_sb_desc
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|length
OG
l_int|0
)paren
(brace
id|next_sb_desc-&gt;command
op_assign
(paren
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|tt
comma
id|out
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|eot
comma
id|yes
)paren
)paren
suffix:semicolon
id|next_sb_desc-&gt;sw_len
op_assign
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|length
suffix:semicolon
id|next_sb_desc-&gt;buf
op_assign
id|virt_to_phys
c_func
(paren
(paren
r_char
op_star
)paren
id|urb-&gt;transfer_buffer
op_plus
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|offset
)paren
suffix:semicolon
multiline_comment|/* Check if full length transfer. */
r_if
c_cond
(paren
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|length
op_eq
id|usb_maxpacket
c_func
(paren
id|urb-&gt;dev
comma
id|urb-&gt;pipe
comma
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
)paren
(brace
id|next_sb_desc-&gt;command
op_or_assign
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|full
comma
id|yes
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|dbg_isoc
c_func
(paren
l_string|&quot;zero len packet&quot;
)paren
suffix:semicolon
id|next_sb_desc-&gt;command
op_assign
(paren
id|IO_FIELD
c_func
(paren
id|USB_SB_command
comma
id|rem
comma
l_int|0
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|tt
comma
id|zout
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|eot
comma
id|yes
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|full
comma
id|yes
)paren
)paren
suffix:semicolon
id|next_sb_desc-&gt;sw_len
op_assign
l_int|1
suffix:semicolon
id|next_sb_desc-&gt;buf
op_assign
id|virt_to_phys
c_func
(paren
op_amp
id|zout_buffer
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* First SB descriptor that belongs to this urb */
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
id|urb_priv-&gt;first_sb
op_assign
id|next_sb_desc
suffix:semicolon
r_else
id|prev_sb_desc-&gt;next
op_assign
id|virt_to_phys
c_func
(paren
id|next_sb_desc
)paren
suffix:semicolon
id|prev_sb_desc
op_assign
id|next_sb_desc
suffix:semicolon
)brace
id|next_sb_desc-&gt;command
op_or_assign
(paren
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|intr
comma
id|yes
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|eol
comma
id|yes
)paren
)paren
suffix:semicolon
id|next_sb_desc-&gt;next
op_assign
l_int|0
suffix:semicolon
id|urb_priv-&gt;last_sb
op_assign
id|next_sb_desc
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|usb_pipein
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
id|dbg_isoc
c_func
(paren
l_string|&quot;Transfer for epid %d is IN&quot;
comma
id|epid
)paren
suffix:semicolon
id|dbg_isoc
c_func
(paren
l_string|&quot;transfer_buffer_length = %d&quot;
comma
id|urb-&gt;transfer_buffer_length
)paren
suffix:semicolon
id|dbg_isoc
c_func
(paren
l_string|&quot;rem is calculated to %d&quot;
comma
id|urb-&gt;iso_frame_desc
(braket
id|urb-&gt;number_of_packets
op_minus
l_int|1
)braket
dot
id|length
)paren
suffix:semicolon
multiline_comment|/* Note that in descriptors for periodic traffic are not consumed. This means that&n;&t;&t;   the USB controller never propagates in the SB list. In other words, if there already&n;&t;&t;   is an SB descriptor in the list for this EP we don&squot;t have to do anything. */
r_if
c_cond
(paren
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|sub
op_eq
l_int|0
)paren
(brace
id|dbg_isoc
c_func
(paren
l_string|&quot;Isoc traffic not already running, allocating SB&quot;
)paren
suffix:semicolon
id|next_sb_desc
op_assign
(paren
id|USB_SB_Desc_t
op_star
)paren
id|kmem_cache_alloc
c_func
(paren
id|usb_desc_cache
comma
id|SLAB_ATOMIC
)paren
suffix:semicolon
m_assert
(paren
id|next_sb_desc
op_ne
l_int|NULL
)paren
suffix:semicolon
id|next_sb_desc-&gt;command
op_assign
(paren
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|tt
comma
id|in
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|eot
comma
id|yes
)paren
op_or
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|eol
comma
id|yes
)paren
)paren
suffix:semicolon
id|next_sb_desc-&gt;next
op_assign
l_int|0
suffix:semicolon
id|next_sb_desc-&gt;sw_len
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Actual number of packets is not relevant&n;&t;&t;&t;&t;&t;&t;     for periodic in traffic as long as it is more&n;&t;&t;&t;&t;&t;&t;     than zero.  Set to 1 always. */
id|next_sb_desc-&gt;buf
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* The rem field is don&squot;t care for isoc traffic, so we don&squot;t set it. */
multiline_comment|/* Only one SB descriptor that belongs to this urb. */
id|urb_priv-&gt;first_sb
op_assign
id|next_sb_desc
suffix:semicolon
id|urb_priv-&gt;last_sb
op_assign
id|next_sb_desc
suffix:semicolon
)brace
r_else
(brace
id|dbg_isoc
c_func
(paren
l_string|&quot;Isoc traffic already running, just setting first/last_sb&quot;
)paren
suffix:semicolon
multiline_comment|/* Each EP for isoc in will have only one SB descriptor, setup when submitting the&n;&t;&t;&t;   already active urb. Note that even though we may have several first_sb/last_sb&n;&t;&t;&t;   pointing at the same SB descriptor, they are freed only once (when the list has&n;&t;&t;&t;   become empty). */
id|urb_priv-&gt;first_sb
op_assign
id|phys_to_virt
c_func
(paren
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|sub
)paren
suffix:semicolon
id|urb_priv-&gt;last_sb
op_assign
id|phys_to_virt
c_func
(paren
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|sub
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* Find the spot to insert this urb and add it. */
r_if
c_cond
(paren
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|sub
op_eq
l_int|0
)paren
(brace
multiline_comment|/* First SB descriptor inserted in this list (in or out). */
id|dbg_isoc
c_func
(paren
l_string|&quot;Inserting SB desc first in list&quot;
)paren
suffix:semicolon
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|hw_len
op_assign
l_int|0
suffix:semicolon
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|sub
op_assign
id|virt_to_phys
c_func
(paren
id|urb_priv-&gt;first_sb
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Isochronous traffic is already running, insert new traffic last (only out). */
id|dbg_isoc
c_func
(paren
l_string|&quot;Inserting SB desc last in list&quot;
)paren
suffix:semicolon
id|temp_sb_desc
op_assign
id|phys_to_virt
c_func
(paren
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|sub
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|temp_sb_desc-&gt;command
op_amp
id|IO_MASK
c_func
(paren
id|USB_SB_command
comma
id|eol
)paren
)paren
op_ne
id|IO_STATE
c_func
(paren
id|USB_SB_command
comma
id|eol
comma
id|yes
)paren
)paren
(brace
m_assert
(paren
id|temp_sb_desc-&gt;next
)paren
suffix:semicolon
id|temp_sb_desc
op_assign
id|phys_to_virt
c_func
(paren
id|temp_sb_desc-&gt;next
)paren
suffix:semicolon
)brace
id|dbg_isoc
c_func
(paren
l_string|&quot;Appending list on desc 0x%p&quot;
comma
id|temp_sb_desc
)paren
suffix:semicolon
multiline_comment|/* Next pointer must be set before eol is removed. */
id|temp_sb_desc-&gt;next
op_assign
id|virt_to_phys
c_func
(paren
id|urb_priv-&gt;first_sb
)paren
suffix:semicolon
multiline_comment|/* Clear the previous end of list flag since there is a new in the&n;&t;&t;   added SB descriptor list. */
id|temp_sb_desc-&gt;command
op_and_assign
op_complement
id|IO_MASK
c_func
(paren
id|USB_SB_command
comma
id|eol
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|command
op_amp
id|IO_MASK
c_func
(paren
id|USB_EP_command
comma
id|enable
)paren
)paren
)paren
(brace
multiline_comment|/* 8.8.5 in Designer&squot;s Reference says we should check for and correct&n;&t;&t;&t;   any errors in the EP here.  That should not be necessary if epid_attn&n;&t;&t;&t;   is handled correctly, so we assume all is ok. */
id|dbg_isoc
c_func
(paren
l_string|&quot;EP disabled&quot;
)paren
suffix:semicolon
id|etrax_usb_check_error_isoc_ep
c_func
(paren
id|epid
)paren
suffix:semicolon
multiline_comment|/* The SB list was exhausted. */
r_if
c_cond
(paren
id|virt_to_phys
c_func
(paren
id|urb_priv-&gt;last_sb
)paren
op_ne
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|sub
)paren
(brace
multiline_comment|/* The new sublist did not get processed before the EP was&n;&t;&t;&t;&t;   disabled.  Setup the EP again. */
id|dbg_isoc
c_func
(paren
l_string|&quot;Set EP sub to new list&quot;
)paren
suffix:semicolon
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|hw_len
op_assign
l_int|0
suffix:semicolon
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|sub
op_assign
id|virt_to_phys
c_func
(paren
id|urb_priv-&gt;first_sb
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|urb-&gt;transfer_flags
op_amp
id|URB_ISO_ASAP
)paren
(brace
multiline_comment|/* The isoc transfer should be started as soon as possible. The start_frame&n;&t;&t;   field is a return value if URB_ISO_ASAP was set. Comparing R_USB_FM_NUMBER&n;&t;&t;   with a USB Chief trace shows that the first isoc IN token is sent 2 frames&n;&t;&t;   later. I&squot;m not sure how this affects usage of the start_frame field by the&n;&t;&t;   device driver, or how it affects things when USB_ISO_ASAP is not set, so&n;&t;&t;   therefore there&squot;s no compensation for the 2 frame &quot;lag&quot; here. */
id|urb-&gt;start_frame
op_assign
(paren
op_star
id|R_USB_FM_NUMBER
op_amp
l_int|0x7ff
)paren
suffix:semicolon
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|command
op_or_assign
id|IO_STATE
c_func
(paren
id|USB_EP_command
comma
id|enable
comma
id|yes
)paren
suffix:semicolon
id|urb_priv-&gt;urb_state
op_assign
id|STARTED
suffix:semicolon
id|dbg_isoc
c_func
(paren
l_string|&quot;URB_ISO_ASAP set, urb-&gt;start_frame set to %d&quot;
comma
id|urb-&gt;start_frame
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Not started yet. */
id|urb_priv-&gt;urb_state
op_assign
id|NOT_STARTED
suffix:semicolon
id|dbg_isoc
c_func
(paren
l_string|&quot;urb_priv-&gt;urb_state set to NOT_STARTED&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* We start the DMA sub channel without checking if it&squot;s running or not, because:&n;&t;  1) If it&squot;s already running, issuing the start command is a nop.&n;&t;  2) We avoid a test-and-set race condition. */
op_star
id|R_DMA_CH8_SUB3_CMD
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH8_SUB3_CMD
comma
id|cmd
comma
id|start
)paren
suffix:semicolon
id|DBFEXIT
suffix:semicolon
)brace
DECL|function|etrax_usb_complete_isoc_urb
r_static
r_void
id|etrax_usb_complete_isoc_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|status
)paren
(brace
id|etrax_urb_priv_t
op_star
id|urb_priv
op_assign
(paren
id|etrax_urb_priv_t
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
r_int
id|epid
op_assign
id|urb_priv-&gt;epid
suffix:semicolon
r_int
id|auto_resubmit
op_assign
l_int|0
suffix:semicolon
id|DBFENTER
suffix:semicolon
id|dbg_isoc
c_func
(paren
l_string|&quot;complete urb 0x%p, status %d&quot;
comma
id|urb
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
id|warn
c_func
(paren
l_string|&quot;Completing isoc urb with status %d.&quot;
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipein
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Make that all isoc packets have status and length set before&n;&t;&t;   completing the urb. */
r_for
c_loop
(paren
id|i
op_assign
id|urb_priv-&gt;isoc_packet_counter
suffix:semicolon
id|i
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|i
op_increment
)paren
(brace
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|actual_length
op_assign
l_int|0
suffix:semicolon
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|status
op_assign
op_minus
id|EPROTO
suffix:semicolon
)brace
id|urb_list_del
c_func
(paren
id|urb
comma
id|epid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|urb_list
(braket
id|epid
)braket
)paren
)paren
(brace
(paren
(paren
id|etrax_urb_priv_t
op_star
)paren
(paren
id|urb_list_first
c_func
(paren
id|epid
)paren
op_member_access_from_pointer
id|hcpriv
)paren
)paren
op_member_access_from_pointer
id|urb_state
op_assign
id|STARTED
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|command
op_amp
id|IO_MASK
c_func
(paren
id|USB_EP_command
comma
id|enable
)paren
)paren
(brace
multiline_comment|/* The EP was enabled, disable it and wait. */
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|command
op_and_assign
op_complement
id|IO_MASK
c_func
(paren
id|USB_EP_command
comma
id|enable
)paren
suffix:semicolon
multiline_comment|/* Ah, the luxury of busy-wait. */
r_while
c_loop
(paren
op_star
id|R_DMA_CH8_SUB3_EP
op_eq
id|virt_to_phys
c_func
(paren
op_amp
id|TxIsocEPList
(braket
id|epid
)braket
)paren
)paren
suffix:semicolon
)brace
id|etrax_remove_from_sb_list
c_func
(paren
id|urb
)paren
suffix:semicolon
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|sub
op_assign
l_int|0
suffix:semicolon
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|hw_len
op_assign
l_int|0
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|etrax_usb_free_epid
c_func
(paren
id|epid
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
id|urb-&gt;hcpriv
op_assign
l_int|0
suffix:semicolon
id|kfree
c_func
(paren
id|urb_priv
)paren
suffix:semicolon
multiline_comment|/* Release allocated bandwidth. */
id|usb_release_bandwidth
c_func
(paren
id|urb-&gt;dev
comma
id|urb
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
r_int
id|freed_descr
suffix:semicolon
id|dbg_isoc
c_func
(paren
l_string|&quot;Isoc out urb complete 0x%p&quot;
comma
id|urb
)paren
suffix:semicolon
multiline_comment|/* Update the urb list. */
id|urb_list_del
c_func
(paren
id|urb
comma
id|epid
)paren
suffix:semicolon
id|freed_descr
op_assign
id|etrax_remove_from_sb_list
c_func
(paren
id|urb
)paren
suffix:semicolon
id|dbg_isoc
c_func
(paren
l_string|&quot;freed %d descriptors of %d packets&quot;
comma
id|freed_descr
comma
id|urb-&gt;number_of_packets
)paren
suffix:semicolon
m_assert
(paren
id|freed_descr
op_eq
id|urb-&gt;number_of_packets
)paren
suffix:semicolon
id|urb-&gt;hcpriv
op_assign
l_int|0
suffix:semicolon
id|kfree
c_func
(paren
id|urb_priv
)paren
suffix:semicolon
multiline_comment|/* Release allocated bandwidth. */
id|usb_release_bandwidth
c_func
(paren
id|urb-&gt;dev
comma
id|urb
comma
l_int|0
)paren
suffix:semicolon
)brace
id|urb-&gt;status
op_assign
id|status
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;complete
)paren
(brace
id|urb
op_member_access_from_pointer
id|complete
c_func
(paren
id|urb
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|auto_resubmit
)paren
(brace
multiline_comment|/* Check that urb was not unlinked by the complete callback. */
r_if
c_cond
(paren
id|__urb_list_entry
c_func
(paren
id|urb
comma
id|epid
)paren
)paren
(brace
multiline_comment|/* Move this one down the list. */
id|urb_list_move_last
c_func
(paren
id|urb
comma
id|epid
)paren
suffix:semicolon
multiline_comment|/* Mark the now first urb as started (may already be). */
(paren
(paren
id|etrax_urb_priv_t
op_star
)paren
(paren
id|urb_list_first
c_func
(paren
id|epid
)paren
op_member_access_from_pointer
id|hcpriv
)paren
)paren
op_member_access_from_pointer
id|urb_state
op_assign
id|STARTED
suffix:semicolon
multiline_comment|/* Must set this to 0 since this urb is still active after&n;&t;&t;&t;   completion. */
id|urb_priv-&gt;isoc_packet_counter
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|warn
c_func
(paren
l_string|&quot;(ISOC) automatic resubmit urb 0x%p removed by complete.&quot;
comma
id|urb
)paren
suffix:semicolon
)brace
)brace
id|DBFEXIT
suffix:semicolon
)brace
DECL|function|etrax_usb_complete_urb
r_static
r_void
id|etrax_usb_complete_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|status
)paren
(brace
r_switch
c_cond
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
r_case
id|PIPE_BULK
suffix:colon
id|etrax_usb_complete_bulk_urb
c_func
(paren
id|urb
comma
id|status
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_CONTROL
suffix:colon
id|etrax_usb_complete_ctrl_urb
c_func
(paren
id|urb
comma
id|status
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_INTERRUPT
suffix:colon
id|etrax_usb_complete_intr_urb
c_func
(paren
id|urb
comma
id|status
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_ISOCHRONOUS
suffix:colon
id|etrax_usb_complete_isoc_urb
c_func
(paren
id|urb
comma
id|status
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
c_func
(paren
l_string|&quot;Unknown pipetype&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|etrax_usb_hc_interrupt_top_half
r_static
id|irqreturn_t
id|etrax_usb_hc_interrupt_top_half
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|vhc
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|usb_interrupt_registers_t
op_star
id|reg
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|__u32
id|irq_mask
suffix:semicolon
id|__u8
id|status
suffix:semicolon
id|__u32
id|epid_attn
suffix:semicolon
id|__u16
id|port_status_1
suffix:semicolon
id|__u16
id|port_status_2
suffix:semicolon
id|__u32
id|fm_number
suffix:semicolon
id|DBFENTER
suffix:semicolon
multiline_comment|/* Read critical registers into local variables, do kmalloc afterwards. */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|irq_mask
op_assign
op_star
id|R_USB_IRQ_MASK_READ
suffix:semicolon
multiline_comment|/* Reading R_USB_STATUS clears the ctl_status interrupt. Note that R_USB_STATUS&n;&t;   must be read before R_USB_EPID_ATTN since reading the latter clears the&n;&t;   ourun and perror fields of R_USB_STATUS. */
id|status
op_assign
op_star
id|R_USB_STATUS
suffix:semicolon
multiline_comment|/* Reading R_USB_EPID_ATTN clears the iso_eof, bulk_eot and epid_attn interrupts. */
id|epid_attn
op_assign
op_star
id|R_USB_EPID_ATTN
suffix:semicolon
multiline_comment|/* Reading R_USB_RH_PORT_STATUS_1 and R_USB_RH_PORT_STATUS_2 clears the&n;&t;   port_status interrupt. */
id|port_status_1
op_assign
op_star
id|R_USB_RH_PORT_STATUS_1
suffix:semicolon
id|port_status_2
op_assign
op_star
id|R_USB_RH_PORT_STATUS_2
suffix:semicolon
multiline_comment|/* Reading R_USB_FM_NUMBER clears the sof interrupt. */
multiline_comment|/* Note: the lower 11 bits contain the actual frame number, sent with each sof. */
id|fm_number
op_assign
op_star
id|R_USB_FM_NUMBER
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|reg
op_assign
(paren
id|usb_interrupt_registers_t
op_star
)paren
id|kmem_cache_alloc
c_func
(paren
id|top_half_reg_cache
comma
id|SLAB_ATOMIC
)paren
suffix:semicolon
m_assert
(paren
id|reg
op_ne
l_int|NULL
)paren
suffix:semicolon
id|reg-&gt;hc
op_assign
(paren
id|etrax_hc_t
op_star
)paren
id|vhc
suffix:semicolon
multiline_comment|/* Now put register values into kmalloc&squot;d area. */
id|reg-&gt;r_usb_irq_mask_read
op_assign
id|irq_mask
suffix:semicolon
id|reg-&gt;r_usb_status
op_assign
id|status
suffix:semicolon
id|reg-&gt;r_usb_epid_attn
op_assign
id|epid_attn
suffix:semicolon
id|reg-&gt;r_usb_rh_port_status_1
op_assign
id|port_status_1
suffix:semicolon
id|reg-&gt;r_usb_rh_port_status_2
op_assign
id|port_status_2
suffix:semicolon
id|reg-&gt;r_usb_fm_number
op_assign
id|fm_number
suffix:semicolon
id|INIT_WORK
c_func
(paren
op_amp
id|reg-&gt;usb_bh
comma
id|etrax_usb_hc_interrupt_bottom_half
comma
id|reg
)paren
suffix:semicolon
id|schedule_work
c_func
(paren
op_amp
id|reg-&gt;usb_bh
)paren
suffix:semicolon
id|DBFEXIT
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
DECL|function|etrax_usb_hc_interrupt_bottom_half
r_static
r_void
id|etrax_usb_hc_interrupt_bottom_half
c_func
(paren
r_void
op_star
id|data
)paren
(brace
id|usb_interrupt_registers_t
op_star
id|reg
op_assign
(paren
id|usb_interrupt_registers_t
op_star
)paren
id|data
suffix:semicolon
id|__u32
id|irq_mask
op_assign
id|reg-&gt;r_usb_irq_mask_read
suffix:semicolon
id|DBFENTER
suffix:semicolon
multiline_comment|/* Interrupts are handled in order of priority. */
r_if
c_cond
(paren
id|irq_mask
op_amp
id|IO_MASK
c_func
(paren
id|R_USB_IRQ_MASK_READ
comma
id|epid_attn
)paren
)paren
(brace
id|etrax_usb_hc_epid_attn_interrupt
c_func
(paren
id|reg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irq_mask
op_amp
id|IO_MASK
c_func
(paren
id|R_USB_IRQ_MASK_READ
comma
id|port_status
)paren
)paren
(brace
id|etrax_usb_hc_port_status_interrupt
c_func
(paren
id|reg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irq_mask
op_amp
id|IO_MASK
c_func
(paren
id|R_USB_IRQ_MASK_READ
comma
id|ctl_status
)paren
)paren
(brace
id|etrax_usb_hc_ctl_status_interrupt
c_func
(paren
id|reg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irq_mask
op_amp
id|IO_MASK
c_func
(paren
id|R_USB_IRQ_MASK_READ
comma
id|iso_eof
)paren
)paren
(brace
id|etrax_usb_hc_isoc_eof_interrupt
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irq_mask
op_amp
id|IO_MASK
c_func
(paren
id|R_USB_IRQ_MASK_READ
comma
id|bulk_eot
)paren
)paren
(brace
multiline_comment|/* Update/restart the bulk start timer since obviously the channel is running. */
id|mod_timer
c_func
(paren
op_amp
id|bulk_start_timer
comma
id|jiffies
op_plus
id|BULK_START_TIMER_INTERVAL
)paren
suffix:semicolon
multiline_comment|/* Update/restart the bulk eot timer since we just received an bulk eot interrupt. */
id|mod_timer
c_func
(paren
op_amp
id|bulk_eot_timer
comma
id|jiffies
op_plus
id|BULK_EOT_TIMER_INTERVAL
)paren
suffix:semicolon
id|etrax_usb_hc_bulk_eot_interrupt
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|kmem_cache_free
c_func
(paren
id|top_half_reg_cache
comma
id|reg
)paren
suffix:semicolon
id|DBFEXIT
suffix:semicolon
)brace
DECL|function|etrax_usb_hc_isoc_eof_interrupt
r_void
id|etrax_usb_hc_isoc_eof_interrupt
c_func
(paren
r_void
)paren
(brace
r_struct
id|urb
op_star
id|urb
suffix:semicolon
id|etrax_urb_priv_t
op_star
id|urb_priv
suffix:semicolon
r_int
id|epid
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|DBFENTER
suffix:semicolon
multiline_comment|/* Do not check the invalid epid (it has a valid sub pointer). */
r_for
c_loop
(paren
id|epid
op_assign
l_int|0
suffix:semicolon
id|epid
OL
id|NBR_OF_EPIDS
op_minus
l_int|1
suffix:semicolon
id|epid
op_increment
)paren
(brace
multiline_comment|/* Do not check the invalid epid (it has a valid sub pointer). */
r_if
c_cond
(paren
(paren
id|epid
op_eq
id|DUMMY_EPID
)paren
op_logical_or
(paren
id|epid
op_eq
id|INVALID_EPID
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Disable interrupts to block the isoc out descriptor interrupt handler&n;&t;&t;   from being called while the isoc EPID list is being checked.&n;&t;&t;*/
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|sub
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Nothing here to see. */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Get the first urb (if any). */
id|urb
op_assign
id|urb_list_first
c_func
(paren
id|epid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb
op_eq
l_int|0
)paren
(brace
id|warn
c_func
(paren
l_string|&quot;Ignoring NULL urb&quot;
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|usb_pipein
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
multiline_comment|/* Sanity check. */
m_assert
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
op_eq
id|PIPE_ISOCHRONOUS
)paren
suffix:semicolon
id|urb_priv
op_assign
(paren
id|etrax_urb_priv_t
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
m_assert
(paren
id|urb_priv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb_priv-&gt;urb_state
op_eq
id|NOT_STARTED
)paren
(brace
multiline_comment|/* If ASAP is not set and urb-&gt;start_frame is the current frame,&n;&t;&t;&t;&t;   start the transfer. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|urb-&gt;transfer_flags
op_amp
id|URB_ISO_ASAP
)paren
op_logical_and
(paren
id|urb-&gt;start_frame
op_eq
(paren
op_star
id|R_USB_FM_NUMBER
op_amp
l_int|0x7ff
)paren
)paren
)paren
(brace
id|dbg_isoc
c_func
(paren
l_string|&quot;Enabling isoc IN EP descr for epid %d&quot;
comma
id|epid
)paren
suffix:semicolon
id|TxIsocEPList
(braket
id|epid
)braket
dot
id|command
op_or_assign
id|IO_STATE
c_func
(paren
id|USB_EP_command
comma
id|enable
comma
id|yes
)paren
suffix:semicolon
multiline_comment|/* This urb is now active. */
id|urb_priv-&gt;urb_state
op_assign
id|STARTED
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
id|DBFEXIT
suffix:semicolon
)brace
DECL|function|etrax_usb_hc_bulk_eot_interrupt
r_void
id|etrax_usb_hc_bulk_eot_interrupt
c_func
(paren
r_int
id|timer_induced
)paren
(brace
r_int
id|epid
suffix:semicolon
multiline_comment|/* The technique is to run one urb at a time, wait for the eot interrupt at which&n;&t;   point the EP descriptor has been disabled. */
id|DBFENTER
suffix:semicolon
id|dbg_bulk
c_func
(paren
l_string|&quot;bulk eot%s&quot;
comma
id|timer_induced
ques
c_cond
l_string|&quot;, called by timer&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|epid
op_assign
l_int|0
suffix:semicolon
id|epid
OL
id|NBR_OF_EPIDS
suffix:semicolon
id|epid
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|TxBulkEPList
(braket
id|epid
)braket
dot
id|command
op_amp
id|IO_MASK
c_func
(paren
id|USB_EP_command
comma
id|enable
)paren
)paren
op_logical_and
(paren
id|TxBulkEPList
(braket
id|epid
)braket
dot
id|sub
op_ne
l_int|0
)paren
)paren
(brace
r_struct
id|urb
op_star
id|urb
suffix:semicolon
id|etrax_urb_priv_t
op_star
id|urb_priv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|__u32
id|r_usb_ept_data
suffix:semicolon
multiline_comment|/* Found a disabled EP descriptor which has a non-null sub pointer.&n;&t;&t;&t;   Verify that this ctrl EP descriptor got disabled no errors.&n;&t;&t;&t;   FIXME: Necessary to check error_code? */
id|dbg_bulk
c_func
(paren
l_string|&quot;for epid %d?&quot;
comma
id|epid
)paren
suffix:semicolon
multiline_comment|/* Get the first urb. */
id|urb
op_assign
id|urb_list_first
c_func
(paren
id|epid
)paren
suffix:semicolon
multiline_comment|/* FIXME: Could this happen for valid reasons? Why did it disappear? Because of&n;&t;&t;&t;   wrong unlinking? */
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
(brace
id|warn
c_func
(paren
l_string|&quot;NULL urb for epid %d&quot;
comma
id|epid
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
m_assert
(paren
id|urb
)paren
suffix:semicolon
id|urb_priv
op_assign
(paren
id|etrax_urb_priv_t
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
m_assert
(paren
id|urb_priv
)paren
suffix:semicolon
multiline_comment|/* Sanity checks. */
m_assert
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
op_eq
id|PIPE_BULK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|phys_to_virt
c_func
(paren
id|TxBulkEPList
(braket
id|epid
)braket
dot
id|sub
)paren
op_ne
id|urb_priv-&gt;last_sb
)paren
(brace
id|err
c_func
(paren
l_string|&quot;bulk endpoint got disabled before reaching last sb&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* For bulk IN traffic, there seems to be a race condition between&n;&t;&t;&t;   between the bulk eot and eop interrupts, or rather an uncertainty regarding&n;&t;&t;&t;   the order in which they happen. Normally we expect the eop interrupt from&n;&t;&t;&t;   DMA channel 9 to happen before the eot interrupt.&n;&n;&t;&t;&t;   Therefore, we complete the bulk IN urb in the rx interrupt handler instead. */
r_if
c_cond
(paren
id|usb_pipein
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
id|dbg_bulk
c_func
(paren
l_string|&quot;in urb, continuing&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
op_star
id|R_USB_EPT_INDEX
op_assign
id|IO_FIELD
c_func
(paren
id|R_USB_EPT_INDEX
comma
id|value
comma
id|epid
)paren
suffix:semicolon
id|nop
c_func
(paren
)paren
suffix:semicolon
id|r_usb_ept_data
op_assign
op_star
id|R_USB_EPT_DATA
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IO_EXTRACT
c_func
(paren
id|R_USB_EPT_DATA
comma
id|error_code
comma
id|r_usb_ept_data
)paren
op_eq
id|IO_STATE_VALUE
c_func
(paren
id|R_USB_EPT_DATA
comma
id|error_code
comma
id|no_error
)paren
)paren
(brace
multiline_comment|/* This means that the endpoint has no error, is disabled&n;&t;&t;&t;&t;   and had inserted traffic, i.e. transfer successfully completed. */
id|etrax_usb_complete_bulk_urb
c_func
(paren
id|urb
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Shouldn&squot;t happen. We expect errors to be caught by epid attention. */
id|err
c_func
(paren
l_string|&quot;Found disabled bulk EP desc, error_code != no_error&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Normally, we should find (at least) one disabled EP descriptor with a valid sub pointer.&n;&t;   However, because of the uncertainty in the deliverance of the eop/eot interrupts, we may&n;&t;   not.  Also, we might find two disabled EPs when handling an eot interrupt, and then find&n;&t;   none the next time. */
id|DBFEXIT
suffix:semicolon
)brace
DECL|function|etrax_usb_hc_epid_attn_interrupt
r_void
id|etrax_usb_hc_epid_attn_interrupt
c_func
(paren
id|usb_interrupt_registers_t
op_star
id|reg
)paren
(brace
multiline_comment|/* This function handles the epid attention interrupt.  There are a variety of reasons&n;&t;   for this interrupt to happen (Designer&squot;s Reference, p. 8 - 22 for the details):&n;&n;&t;   invalid ep_id  - Invalid epid in an EP (EP disabled).&n;&t;   stall&t;  - Not strictly an error condition (EP disabled).&n;&t;   3rd error      - Three successive transaction errors  (EP disabled).&n;&t;   buffer ourun   - Buffer overrun or underrun (EP disabled).&n;&t;   past eof1      - Intr or isoc transaction proceeds past EOF1.&n;&t;   near eof       - Intr or isoc transaction would not fit inside the frame.&n;&t;   zout transfer  - If zout transfer for a bulk endpoint (EP disabled).&n;&t;   setup transfer - If setup transfer for a non-ctrl endpoint (EP disabled). */
r_int
id|epid
suffix:semicolon
id|DBFENTER
suffix:semicolon
m_assert
(paren
id|reg
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Note that we loop through all epids. We still want to catch errors for&n;&t;   the invalid one, even though we might handle them differently. */
r_for
c_loop
(paren
id|epid
op_assign
l_int|0
suffix:semicolon
id|epid
OL
id|NBR_OF_EPIDS
suffix:semicolon
id|epid
op_increment
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|epid
comma
(paren
r_void
op_star
)paren
op_amp
id|reg-&gt;r_usb_epid_attn
)paren
)paren
(brace
r_struct
id|urb
op_star
id|urb
suffix:semicolon
id|__u32
id|r_usb_ept_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|error_code
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
op_star
id|R_USB_EPT_INDEX
op_assign
id|IO_FIELD
c_func
(paren
id|R_USB_EPT_INDEX
comma
id|value
comma
id|epid
)paren
suffix:semicolon
id|nop
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Note that although there are separate R_USB_EPT_DATA and R_USB_EPT_DATA_ISO&n;&t;&t;&t;   registers, they are located at the same address and are of the same size.&n;&t;&t;&t;   In other words, this read should be ok for isoc also. */
id|r_usb_ept_data
op_assign
op_star
id|R_USB_EPT_DATA
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* First some sanity checks. */
r_if
c_cond
(paren
id|epid
op_eq
id|INVALID_EPID
)paren
(brace
multiline_comment|/* FIXME: What if it became disabled? Could seriously hurt interrupt&n;&t;&t;&t;&t;   traffic. (Use do_intr_recover.) */
id|warn
c_func
(paren
l_string|&quot;Got epid_attn for INVALID_EPID (%d).&quot;
comma
id|epid
)paren
suffix:semicolon
id|err
c_func
(paren
l_string|&quot;R_USB_EPT_DATA = 0x%x&quot;
comma
id|r_usb_ept_data
)paren
suffix:semicolon
id|err
c_func
(paren
l_string|&quot;R_USB_STATUS = 0x%x&quot;
comma
id|reg-&gt;r_usb_status
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|epid
op_eq
id|DUMMY_EPID
)paren
(brace
multiline_comment|/* We definitely don&squot;t care about these ones. Besides, they are&n;&t;&t;&t;&t;   always disabled, so any possible disabling caused by the&n;&t;&t;&t;&t;   epid attention interrupt is irrelevant. */
id|warn
c_func
(paren
l_string|&quot;Got epid_attn for DUMMY_EPID (%d).&quot;
comma
id|epid
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Get the first urb in the urb list for this epid. We blatantly assume&n;&t;&t;&t;   that only the first urb could have caused the epid attention.&n;&t;&t;&t;   (For bulk and ctrl, only one urb is active at any one time. For intr&n;&t;&t;&t;   and isoc we remove them once they are completed.) */
id|urb
op_assign
id|urb_list_first
c_func
(paren
id|epid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Got epid_attn for epid %i with no urb.&quot;
comma
id|epid
)paren
suffix:semicolon
id|err
c_func
(paren
l_string|&quot;R_USB_EPT_DATA = 0x%x&quot;
comma
id|r_usb_ept_data
)paren
suffix:semicolon
id|err
c_func
(paren
l_string|&quot;R_USB_STATUS = 0x%x&quot;
comma
id|reg-&gt;r_usb_status
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
r_case
id|PIPE_BULK
suffix:colon
id|warn
c_func
(paren
l_string|&quot;Got epid attn for bulk endpoint, epid %d&quot;
comma
id|epid
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_CONTROL
suffix:colon
id|warn
c_func
(paren
l_string|&quot;Got epid attn for control endpoint, epid %d&quot;
comma
id|epid
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_INTERRUPT
suffix:colon
id|warn
c_func
(paren
l_string|&quot;Got epid attn for interrupt endpoint, epid %d&quot;
comma
id|epid
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_ISOCHRONOUS
suffix:colon
id|warn
c_func
(paren
l_string|&quot;Got epid attn for isochronous endpoint, epid %d&quot;
comma
id|epid
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
op_ne
id|PIPE_ISOCHRONOUS
)paren
(brace
r_if
c_cond
(paren
id|r_usb_ept_data
op_amp
id|IO_MASK
c_func
(paren
id|R_USB_EPT_DATA
comma
id|hold
)paren
)paren
(brace
id|warn
c_func
(paren
l_string|&quot;Hold was set for epid %d.&quot;
comma
id|epid
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
multiline_comment|/* Even though error_code occupies bits 22 - 23 in both R_USB_EPT_DATA and&n;&t;&t;&t;   R_USB_EPT_DATA_ISOC, we separate them here so we don&squot;t forget in other places. */
r_if
c_cond
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
op_eq
id|PIPE_ISOCHRONOUS
)paren
(brace
id|error_code
op_assign
id|IO_EXTRACT
c_func
(paren
id|R_USB_EPT_DATA_ISO
comma
id|error_code
comma
id|r_usb_ept_data
)paren
suffix:semicolon
)brace
r_else
(brace
id|error_code
op_assign
id|IO_EXTRACT
c_func
(paren
id|R_USB_EPT_DATA
comma
id|error_code
comma
id|r_usb_ept_data
)paren
suffix:semicolon
)brace
multiline_comment|/* Using IO_STATE_VALUE on R_USB_EPT_DATA should be ok for isoc also. */
r_if
c_cond
(paren
id|error_code
op_eq
id|IO_STATE_VALUE
c_func
(paren
id|R_USB_EPT_DATA
comma
id|error_code
comma
id|no_error
)paren
)paren
(brace
multiline_comment|/* Isoc traffic doesn&squot;t have error_count_in/error_count_out. */
r_if
c_cond
(paren
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
op_ne
id|PIPE_ISOCHRONOUS
)paren
op_logical_and
(paren
id|IO_EXTRACT
c_func
(paren
id|R_USB_EPT_DATA
comma
id|error_count_in
comma
id|r_usb_ept_data
)paren
op_eq
l_int|3
op_logical_or
id|IO_EXTRACT
c_func
(paren
id|R_USB_EPT_DATA
comma
id|error_count_out
comma
id|r_usb_ept_data
)paren
op_eq
l_int|3
)paren
)paren
(brace
multiline_comment|/* 3rd error. */
id|warn
c_func
(paren
l_string|&quot;3rd error for epid %i&quot;
comma
id|epid
)paren
suffix:semicolon
id|etrax_usb_complete_urb
c_func
(paren
id|urb
comma
op_minus
id|EPROTO
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|reg-&gt;r_usb_status
op_amp
id|IO_MASK
c_func
(paren
id|R_USB_STATUS
comma
id|perror
)paren
)paren
(brace
id|warn
c_func
(paren
l_string|&quot;Perror for epid %d&quot;
comma
id|epid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|r_usb_ept_data
op_amp
id|IO_MASK
c_func
(paren
id|R_USB_EPT_DATA
comma
id|valid
)paren
)paren
)paren
(brace
multiline_comment|/* invalid ep_id */
id|panic
c_func
(paren
l_string|&quot;Perror because of invalid epid.&quot;
l_string|&quot; Deconfigured too early?&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* past eof1, near eof, zout transfer, setup transfer */
multiline_comment|/* Dump the urb and the relevant EP descriptor list. */
id|__dump_urb
c_func
(paren
id|urb
)paren
suffix:semicolon
id|__dump_ept_data
c_func
(paren
id|epid
)paren
suffix:semicolon
id|__dump_ep_list
c_func
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;Something wrong with DMA descriptor contents.&quot;
l_string|&quot; Too much traffic inserted?&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|reg-&gt;r_usb_status
op_amp
id|IO_MASK
c_func
(paren
id|R_USB_STATUS
comma
id|ourun
)paren
)paren
(brace
multiline_comment|/* buffer ourun */
id|panic
c_func
(paren
l_string|&quot;Buffer overrun/underrun for epid %d. DMA too busy?&quot;
comma
id|epid
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|error_code
op_eq
id|IO_STATE_VALUE
c_func
(paren
id|R_USB_EPT_DATA
comma
id|error_code
comma
id|stall
)paren
)paren
(brace
multiline_comment|/* Not really a protocol error, just says that the endpoint gave&n;&t;&t;&t;&t;   a stall response. Note that error_code cannot be stall for isoc. */
r_if
c_cond
(paren
id|usb_pipetype
c_func
(paren
id|urb-&gt;pipe
)paren
op_eq
id|PIPE_ISOCHRONOUS
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Isoc traffic cannot stall&quot;
)paren
suffix:semicolon
)brace
id|warn
c_func
(paren
l_string|&quot;Stall for epid %d&quot;
comma
id|epid
)paren
suffix:semicolon
id|etrax_usb_complete_urb
c_func
(paren
id|urb
comma
op_minus
id|EPIPE
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|error_code
op_eq
id|IO_STATE_VALUE
c_func
(paren
id|R_USB_EPT_DATA
comma
id|error_code
comma
id|bus_error
)paren
)paren
(brace
multiline_comment|/* Two devices responded to a transaction request. Must be resolved&n;&t;&t;&t;&t;   by software. FIXME: Reset ports? */
id|panic
c_func
(paren
l_string|&quot;Bus error for epid %d.&quot;
l_string|&quot; Two devices responded to transaction request&quot;
comma
id|epid
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|error_code
op_eq
id|IO_STATE_VALUE
c_func
(paren
id|R_USB_EPT_DATA
comma
id|error_code
comma
id|buffer_error
)paren
)paren
(brace
multiline_comment|/* DMA overrun or underrun. */
id|warn
c_func
(paren
l_string|&quot;Buffer overrun/underrun for epid %d. DMA too busy?&quot;
comma
id|epid
)paren
suffix:semicolon
multiline_comment|/* It seems that error_code = buffer_error in&n;&t;&t;&t;&t;   R_USB_EPT_DATA/R_USB_EPT_DATA_ISO and ourun = yes in R_USB_STATUS&n;&t;&t;&t;&t;   are the same error. */
id|etrax_usb_complete_urb
c_func
(paren
id|urb
comma
op_minus
id|EPROTO
)paren
suffix:semicolon
)brace
)brace
)brace
id|DBFEXIT
suffix:semicolon
)brace
DECL|function|etrax_usb_bulk_start_timer_func
r_void
id|etrax_usb_bulk_start_timer_func
c_func
(paren
r_int
r_int
id|dummy
)paren
(brace
multiline_comment|/* We might enable an EP descriptor behind the current DMA position when it&squot;s about&n;&t;   to decide that there are no more bulk traffic and it should stop the bulk channel.&n;&t;   Therefore we periodically check if the bulk channel is stopped and there is an&n;&t;   enabled bulk EP descriptor, in which case we start the bulk channel. */
id|dbg_bulk
c_func
(paren
l_string|&quot;bulk_start_timer timed out.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|R_DMA_CH8_SUB0_CMD
op_amp
id|IO_MASK
c_func
(paren
id|R_DMA_CH8_SUB0_CMD
comma
id|cmd
)paren
)paren
)paren
(brace
r_int
id|epid
suffix:semicolon
id|dbg_bulk
c_func
(paren
l_string|&quot;Bulk DMA channel not running.&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|epid
op_assign
l_int|0
suffix:semicolon
id|epid
OL
id|NBR_OF_EPIDS
suffix:semicolon
id|epid
op_increment
)paren
(brace
r_if
c_cond
(paren
id|TxBulkEPList
(braket
id|epid
)braket
dot
id|command
op_amp
id|IO_MASK
c_func
(paren
id|USB_EP_command
comma
id|enable
)paren
)paren
(brace
id|dbg_bulk
c_func
(paren
l_string|&quot;Found enabled EP for epid %d, starting bulk channel.&bslash;n&quot;
comma
id|epid
)paren
suffix:semicolon
op_star
id|R_DMA_CH8_SUB0_CMD
op_assign
id|IO_STATE
c_func
(paren
id|R_DMA_CH8_SUB0_CMD
comma
id|cmd
comma
id|start
)paren
suffix:semicolon
multiline_comment|/* Restart the bulk eot timer since we just started the bulk channel. */
id|mod_timer
c_func
(paren
op_amp
id|bulk_eot_timer
comma
id|jiffies
op_plus
id|BULK_EOT_TIMER_INTERVAL
)paren
suffix:semicolon
multiline_comment|/* No need to search any further. */
r_break
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|dbg_bulk
c_func
(paren
l_string|&quot;Bulk DMA channel running.&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|etrax_usb_hc_port_status_interrupt
r_void
id|etrax_usb_hc_port_status_interrupt
c_func
(paren
id|usb_interrupt_registers_t
op_star
id|reg
)paren
(brace
id|etrax_hc_t
op_star
id|hc
op_assign
id|reg-&gt;hc
suffix:semicolon
id|__u16
id|r_usb_rh_port_status_1
op_assign
id|reg-&gt;r_usb_rh_port_status_1
suffix:semicolon
id|__u16
id|r_usb_rh_port_status_2
op_assign
id|reg-&gt;r_usb_rh_port_status_2
suffix:semicolon
id|DBFENTER
suffix:semicolon
multiline_comment|/* The Etrax RH does not include a wPortChange register, so this has to be handled in software&n;&t;   (by saving the old port status value for comparison when the port status interrupt happens).&n;&t;   See section 11.16.2.6.2 in the USB 1.1 spec for details. */
id|dbg_rh
c_func
(paren
l_string|&quot;hc-&gt;rh.prev_wPortStatus_1 = 0x%x&quot;
comma
id|hc-&gt;rh.prev_wPortStatus_1
)paren
suffix:semicolon
id|dbg_rh
c_func
(paren
l_string|&quot;hc-&gt;rh.prev_wPortStatus_2 = 0x%x&quot;
comma
id|hc-&gt;rh.prev_wPortStatus_2
)paren
suffix:semicolon
id|dbg_rh
c_func
(paren
l_string|&quot;r_usb_rh_port_status_1 = 0x%x&quot;
comma
id|r_usb_rh_port_status_1
)paren
suffix:semicolon
id|dbg_rh
c_func
(paren
l_string|&quot;r_usb_rh_port_status_2 = 0x%x&quot;
comma
id|r_usb_rh_port_status_2
)paren
suffix:semicolon
multiline_comment|/* C_PORT_CONNECTION is set on any transition. */
id|hc-&gt;rh.wPortChange_1
op_or_assign
(paren
(paren
id|r_usb_rh_port_status_1
op_amp
(paren
l_int|1
op_lshift
id|RH_PORT_CONNECTION
)paren
)paren
op_ne
(paren
id|hc-&gt;rh.prev_wPortStatus_1
op_amp
(paren
l_int|1
op_lshift
id|RH_PORT_CONNECTION
)paren
)paren
)paren
ques
c_cond
(paren
l_int|1
op_lshift
id|RH_PORT_CONNECTION
)paren
suffix:colon
l_int|0
suffix:semicolon
id|hc-&gt;rh.wPortChange_2
op_or_assign
(paren
(paren
id|r_usb_rh_port_status_2
op_amp
(paren
l_int|1
op_lshift
id|RH_PORT_CONNECTION
)paren
)paren
op_ne
(paren
id|hc-&gt;rh.prev_wPortStatus_2
op_amp
(paren
l_int|1
op_lshift
id|RH_PORT_CONNECTION
)paren
)paren
)paren
ques
c_cond
(paren
l_int|1
op_lshift
id|RH_PORT_CONNECTION
)paren
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* C_PORT_ENABLE is _only_ set on a one to zero transition, i.e. when&n;&t;   the port is disabled, not when it&squot;s enabled. */
id|hc-&gt;rh.wPortChange_1
op_or_assign
(paren
(paren
id|hc-&gt;rh.prev_wPortStatus_1
op_amp
(paren
l_int|1
op_lshift
id|RH_PORT_ENABLE
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|r_usb_rh_port_status_1
op_amp
(paren
l_int|1
op_lshift
id|RH_PORT_ENABLE
)paren
)paren
)paren
ques
c_cond
(paren
l_int|1
op_lshift
id|RH_PORT_ENABLE
)paren
suffix:colon
l_int|0
suffix:semicolon
id|hc-&gt;rh.wPortChange_2
op_or_assign
(paren
(paren
id|hc-&gt;rh.prev_wPortStatus_2
op_amp
(paren
l_int|1
op_lshift
id|RH_PORT_ENABLE
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|r_usb_rh_port_status_2
op_amp
(paren
l_int|1
op_lshift
id|RH_PORT_ENABLE
)paren
)paren
)paren
ques
c_cond
(paren
l_int|1
op_lshift
id|RH_PORT_ENABLE
)paren
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* C_PORT_SUSPEND is set to one when the device has transitioned out&n;&t;   of the suspended state, i.e. when suspend goes from one to zero. */
id|hc-&gt;rh.wPortChange_1
op_or_assign
(paren
(paren
id|hc-&gt;rh.prev_wPortStatus_1
op_amp
(paren
l_int|1
op_lshift
id|RH_PORT_SUSPEND
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|r_usb_rh_port_status_1
op_amp
(paren
l_int|1
op_lshift
id|RH_PORT_SUSPEND
)paren
)paren
)paren
ques
c_cond
(paren
l_int|1
op_lshift
id|RH_PORT_SUSPEND
)paren
suffix:colon
l_int|0
suffix:semicolon
id|hc-&gt;rh.wPortChange_2
op_or_assign
(paren
(paren
id|hc-&gt;rh.prev_wPortStatus_2
op_amp
(paren
l_int|1
op_lshift
id|RH_PORT_SUSPEND
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|r_usb_rh_port_status_2
op_amp
(paren
l_int|1
op_lshift
id|RH_PORT_SUSPEND
)paren
)paren
)paren
ques
c_cond
(paren
l_int|1
op_lshift
id|RH_PORT_SUSPEND
)paren
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* C_PORT_RESET is set when reset processing on this port is complete. */
id|hc-&gt;rh.wPortChange_1
op_or_assign
(paren
(paren
id|hc-&gt;rh.prev_wPortStatus_1
op_amp
(paren
l_int|1
op_lshift
id|RH_PORT_RESET
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|r_usb_rh_port_status_1
op_amp
(paren
l_int|1
op_lshift
id|RH_PORT_RESET
)paren
)paren
)paren
ques
c_cond
(paren
l_int|1
op_lshift
id|RH_PORT_RESET
)paren
suffix:colon
l_int|0
suffix:semicolon
id|hc-&gt;rh.wPortChange_2
op_or_assign
(paren
(paren
id|hc-&gt;rh.prev_wPortStatus_2
op_amp
(paren
l_int|1
op_lshift
id|RH_PORT_RESET
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|r_usb_rh_port_status_2
op_amp
(paren
l_int|1
op_lshift
id|RH_PORT_RESET
)paren
)paren
)paren
ques
c_cond
(paren
l_int|1
op_lshift
id|RH_PORT_RESET
)paren
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* Save the new values for next port status change. */
id|hc-&gt;rh.prev_wPortStatus_1
op_assign
id|r_usb_rh_port_status_1
suffix:semicolon
id|hc-&gt;rh.prev_wPortStatus_2
op_assign
id|r_usb_rh_port_status_2
suffix:semicolon
id|dbg_rh
c_func
(paren
l_string|&quot;hc-&gt;rh.wPortChange_1 set to 0x%x&quot;
comma
id|hc-&gt;rh.wPortChange_1
)paren
suffix:semicolon
id|dbg_rh
c_func
(paren
l_string|&quot;hc-&gt;rh.wPortChange_2 set to 0x%x&quot;
comma
id|hc-&gt;rh.wPortChange_2
)paren
suffix:semicolon
id|DBFEXIT
suffix:semicolon
)brace
DECL|function|etrax_usb_hc_ctl_status_interrupt
r_void
id|etrax_usb_hc_ctl_status_interrupt
c_func
(paren
id|usb_interrupt_registers_t
op_star
id|reg
)paren
(brace
id|DBFENTER
suffix:semicolon
multiline_comment|/* FIXME: What should we do if we get ourun or perror? Dump the EP and SB&n;&t;   list for the corresponding epid? */
r_if
c_cond
(paren
id|reg-&gt;r_usb_status
op_amp
id|IO_MASK
c_func
(paren
id|R_USB_STATUS
comma
id|ourun
)paren
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;USB controller got ourun.&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reg-&gt;r_usb_status
op_amp
id|IO_MASK
c_func
(paren
id|R_USB_STATUS
comma
id|perror
)paren
)paren
(brace
multiline_comment|/* Before, etrax_usb_do_intr_recover was called on this epid if it was&n;&t;&t;   an interrupt pipe. I don&squot;t see how re-enabling all EP descriptors&n;&t;&t;   will help if there was a programming error. */
id|panic
c_func
(paren
l_string|&quot;USB controller got perror.&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reg-&gt;r_usb_status
op_amp
id|IO_MASK
c_func
(paren
id|R_USB_STATUS
comma
id|device_mode
)paren
)paren
(brace
multiline_comment|/* We should never operate in device mode. */
id|panic
c_func
(paren
l_string|&quot;USB controller in device mode.&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* These if-statements could probably be nested. */
r_if
c_cond
(paren
id|reg-&gt;r_usb_status
op_amp
id|IO_MASK
c_func
(paren
id|R_USB_STATUS
comma
id|host_mode
)paren
)paren
(brace
id|info
c_func
(paren
l_string|&quot;USB controller in host mode.&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reg-&gt;r_usb_status
op_amp
id|IO_MASK
c_func
(paren
id|R_USB_STATUS
comma
id|started
)paren
)paren
(brace
id|info
c_func
(paren
l_string|&quot;USB controller started.&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reg-&gt;r_usb_status
op_amp
id|IO_MASK
c_func
(paren
id|R_USB_STATUS
comma
id|running
)paren
)paren
(brace
id|info
c_func
(paren
l_string|&quot;USB controller running.&quot;
)paren
suffix:semicolon
)brace
id|DBFEXIT
suffix:semicolon
)brace
DECL|function|etrax_rh_submit_urb
r_static
r_int
id|etrax_rh_submit_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|usb_device
op_star
id|usb_dev
op_assign
id|urb-&gt;dev
suffix:semicolon
id|etrax_hc_t
op_star
id|hc
op_assign
id|usb_dev-&gt;bus-&gt;hcpriv
suffix:semicolon
r_int
r_int
id|pipe
op_assign
id|urb-&gt;pipe
suffix:semicolon
r_struct
id|usb_ctrlrequest
op_star
id|cmd
op_assign
(paren
r_struct
id|usb_ctrlrequest
op_star
)paren
id|urb-&gt;setup_packet
suffix:semicolon
r_void
op_star
id|data
op_assign
id|urb-&gt;transfer_buffer
suffix:semicolon
r_int
id|leni
op_assign
id|urb-&gt;transfer_buffer_length
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_int
id|stat
op_assign
l_int|0
suffix:semicolon
id|__u16
id|bmRType_bReq
suffix:semicolon
id|__u16
id|wValue
suffix:semicolon
id|__u16
id|wIndex
suffix:semicolon
id|__u16
id|wLength
suffix:semicolon
id|DBFENTER
suffix:semicolon
multiline_comment|/* FIXME: What is this interrupt urb that is sent to the root hub? */
r_if
c_cond
(paren
id|usb_pipetype
(paren
id|pipe
)paren
op_eq
id|PIPE_INTERRUPT
)paren
(brace
id|dbg_rh
c_func
(paren
l_string|&quot;Root-Hub submit IRQ: every %d ms&quot;
comma
id|urb-&gt;interval
)paren
suffix:semicolon
id|hc-&gt;rh.urb
op_assign
id|urb
suffix:semicolon
id|hc-&gt;rh.send
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* FIXME: We could probably remove this line since it&squot;s done&n;&t;&t;   in etrax_rh_init_int_timer. (Don&squot;t remove it from&n;&t;&t;   etrax_rh_init_int_timer though.) */
id|hc-&gt;rh.interval
op_assign
id|urb-&gt;interval
suffix:semicolon
id|etrax_rh_init_int_timer
c_func
(paren
id|urb
)paren
suffix:semicolon
id|DBFEXIT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|bmRType_bReq
op_assign
id|cmd-&gt;bRequestType
op_or
(paren
id|cmd-&gt;bRequest
op_lshift
l_int|8
)paren
suffix:semicolon
id|wValue
op_assign
id|le16_to_cpu
c_func
(paren
id|cmd-&gt;wValue
)paren
suffix:semicolon
id|wIndex
op_assign
id|le16_to_cpu
c_func
(paren
id|cmd-&gt;wIndex
)paren
suffix:semicolon
id|wLength
op_assign
id|le16_to_cpu
c_func
(paren
id|cmd-&gt;wLength
)paren
suffix:semicolon
id|dbg_rh
c_func
(paren
l_string|&quot;bmRType_bReq : 0x%04x (%d)&quot;
comma
id|bmRType_bReq
comma
id|bmRType_bReq
)paren
suffix:semicolon
id|dbg_rh
c_func
(paren
l_string|&quot;wValue       : 0x%04x (%d)&quot;
comma
id|wValue
comma
id|wValue
)paren
suffix:semicolon
id|dbg_rh
c_func
(paren
l_string|&quot;wIndex       : 0x%04x (%d)&quot;
comma
id|wIndex
comma
id|wIndex
)paren
suffix:semicolon
id|dbg_rh
c_func
(paren
l_string|&quot;wLength      : 0x%04x (%d)&quot;
comma
id|wLength
comma
id|wLength
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|bmRType_bReq
)paren
(brace
multiline_comment|/* Request Destination:&n;&t;&t;   without flags: Device,&n;&t;&t;   RH_INTERFACE: interface,&n;&t;&t;   RH_ENDPOINT: endpoint,&n;&t;&t;   RH_CLASS means HUB here,&n;&t;&t;   RH_OTHER | RH_CLASS  almost ever means HUB_PORT here&n;&t;&t; */
r_case
id|RH_GET_STATUS
suffix:colon
op_star
(paren
id|__u16
op_star
)paren
id|data
op_assign
id|cpu_to_le16
(paren
l_int|1
)paren
suffix:semicolon
id|OK
(paren
l_int|2
)paren
suffix:semicolon
r_case
id|RH_GET_STATUS
op_or
id|RH_INTERFACE
suffix:colon
op_star
(paren
id|__u16
op_star
)paren
id|data
op_assign
id|cpu_to_le16
(paren
l_int|0
)paren
suffix:semicolon
id|OK
(paren
l_int|2
)paren
suffix:semicolon
r_case
id|RH_GET_STATUS
op_or
id|RH_ENDPOINT
suffix:colon
op_star
(paren
id|__u16
op_star
)paren
id|data
op_assign
id|cpu_to_le16
(paren
l_int|0
)paren
suffix:semicolon
id|OK
(paren
l_int|2
)paren
suffix:semicolon
r_case
id|RH_GET_STATUS
op_or
id|RH_CLASS
suffix:colon
op_star
(paren
id|__u32
op_star
)paren
id|data
op_assign
id|cpu_to_le32
(paren
l_int|0
)paren
suffix:semicolon
id|OK
(paren
l_int|4
)paren
suffix:semicolon
multiline_comment|/* hub power ** */
r_case
id|RH_GET_STATUS
op_or
id|RH_OTHER
op_or
id|RH_CLASS
suffix:colon
r_if
c_cond
(paren
id|wIndex
op_eq
l_int|1
)paren
(brace
op_star
(paren
(paren
id|__u16
op_star
)paren
id|data
)paren
op_assign
id|cpu_to_le16
c_func
(paren
id|hc-&gt;rh.prev_wPortStatus_1
)paren
suffix:semicolon
op_star
(paren
(paren
id|__u16
op_star
)paren
id|data
op_plus
l_int|1
)paren
op_assign
id|cpu_to_le16
c_func
(paren
id|hc-&gt;rh.wPortChange_1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|wIndex
op_eq
l_int|2
)paren
(brace
op_star
(paren
(paren
id|__u16
op_star
)paren
id|data
)paren
op_assign
id|cpu_to_le16
c_func
(paren
id|hc-&gt;rh.prev_wPortStatus_2
)paren
suffix:semicolon
op_star
(paren
(paren
id|__u16
op_star
)paren
id|data
op_plus
l_int|1
)paren
op_assign
id|cpu_to_le16
c_func
(paren
id|hc-&gt;rh.wPortChange_2
)paren
suffix:semicolon
)brace
r_else
(brace
id|dbg_rh
c_func
(paren
l_string|&quot;RH_GET_STATUS whith invalid wIndex!&quot;
)paren
suffix:semicolon
id|OK
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|OK
c_func
(paren
l_int|4
)paren
suffix:semicolon
r_case
id|RH_CLEAR_FEATURE
op_or
id|RH_ENDPOINT
suffix:colon
r_switch
c_cond
(paren
id|wValue
)paren
(brace
r_case
(paren
id|RH_ENDPOINT_STALL
)paren
suffix:colon
id|OK
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RH_CLEAR_FEATURE
op_or
id|RH_CLASS
suffix:colon
r_switch
c_cond
(paren
id|wValue
)paren
(brace
r_case
(paren
id|RH_C_HUB_OVER_CURRENT
)paren
suffix:colon
id|OK
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* hub power over current ** */
)brace
r_break
suffix:semicolon
r_case
id|RH_CLEAR_FEATURE
op_or
id|RH_OTHER
op_or
id|RH_CLASS
suffix:colon
r_switch
c_cond
(paren
id|wValue
)paren
(brace
r_case
(paren
id|RH_PORT_ENABLE
)paren
suffix:colon
r_if
c_cond
(paren
id|wIndex
op_eq
l_int|1
)paren
(brace
id|dbg_rh
c_func
(paren
l_string|&quot;trying to do disable port 1&quot;
)paren
suffix:semicolon
op_star
id|R_USB_PORT1_DISABLE
op_assign
id|IO_STATE
c_func
(paren
id|R_USB_PORT1_DISABLE
comma
id|disable
comma
id|yes
)paren
suffix:semicolon
r_while
c_loop
(paren
id|hc-&gt;rh.prev_wPortStatus_1
op_amp
id|IO_STATE
c_func
(paren
id|R_USB_RH_PORT_STATUS_1
comma
id|enabled
comma
id|yes
)paren
)paren
suffix:semicolon
op_star
id|R_USB_PORT1_DISABLE
op_assign
id|IO_STATE
c_func
(paren
id|R_USB_PORT1_DISABLE
comma
id|disable
comma
id|no
)paren
suffix:semicolon
id|dbg_rh
c_func
(paren
l_string|&quot;Port 1 is disabled&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|wIndex
op_eq
l_int|2
)paren
(brace
id|dbg_rh
c_func
(paren
l_string|&quot;trying to do disable port 2&quot;
)paren
suffix:semicolon
op_star
id|R_USB_PORT2_DISABLE
op_assign
id|IO_STATE
c_func
(paren
id|R_USB_PORT2_DISABLE
comma
id|disable
comma
id|yes
)paren
suffix:semicolon
r_while
c_loop
(paren
id|hc-&gt;rh.prev_wPortStatus_2
op_amp
id|IO_STATE
c_func
(paren
id|R_USB_RH_PORT_STATUS_2
comma
id|enabled
comma
id|yes
)paren
)paren
suffix:semicolon
op_star
id|R_USB_PORT2_DISABLE
op_assign
id|IO_STATE
c_func
(paren
id|R_USB_PORT2_DISABLE
comma
id|disable
comma
id|no
)paren
suffix:semicolon
id|dbg_rh
c_func
(paren
l_string|&quot;Port 2 is disabled&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|dbg_rh
c_func
(paren
l_string|&quot;RH_CLEAR_FEATURE-&gt;RH_PORT_ENABLE &quot;
l_string|&quot;with invalid wIndex == %d!&quot;
comma
id|wIndex
)paren
suffix:semicolon
)brace
id|OK
(paren
l_int|0
)paren
suffix:semicolon
r_case
(paren
id|RH_PORT_SUSPEND
)paren
suffix:colon
multiline_comment|/* Opposite to suspend should be resume, so we&squot;ll do a resume. */
multiline_comment|/* FIXME: USB 1.1, 11.16.2.2 says:&n;&t;&t;&t;   &quot;Clearing the PORT_SUSPEND feature causes a host-initiated resume&n;&t;&t;&t;   on the specified port. If the port is not in the Suspended state,&n;&t;&t;&t;   the hub should treat this request as a functional no-operation.&quot;&n;&t;&t;&t;   Shouldn&squot;t we check if the port is in a suspended state before&n;&t;&t;&t;   resuming? */
multiline_comment|/* Make sure the controller isn&squot;t busy. */
r_while
c_loop
(paren
op_star
id|R_USB_COMMAND
op_amp
id|IO_MASK
c_func
(paren
id|R_USB_COMMAND
comma
id|busy
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wIndex
op_eq
l_int|1
)paren
(brace
op_star
id|R_USB_COMMAND
op_assign
id|IO_STATE
c_func
(paren
id|R_USB_COMMAND
comma
id|port_sel
comma
id|port1
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_USB_COMMAND
comma
id|port_cmd
comma
id|resume
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_USB_COMMAND
comma
id|ctrl_cmd
comma
id|nop
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|wIndex
op_eq
l_int|2
)paren
(brace
op_star
id|R_USB_COMMAND
op_assign
id|IO_STATE
c_func
(paren
id|R_USB_COMMAND
comma
id|port_sel
comma
id|port2
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_USB_COMMAND
comma
id|port_cmd
comma
id|resume
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_USB_COMMAND
comma
id|ctrl_cmd
comma
id|nop
)paren
suffix:semicolon
)brace
r_else
(brace
id|dbg_rh
c_func
(paren
l_string|&quot;RH_CLEAR_FEATURE-&gt;RH_PORT_SUSPEND &quot;
l_string|&quot;with invalid wIndex == %d!&quot;
comma
id|wIndex
)paren
suffix:semicolon
)brace
id|OK
(paren
l_int|0
)paren
suffix:semicolon
r_case
(paren
id|RH_PORT_POWER
)paren
suffix:colon
id|OK
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* port power ** */
r_case
(paren
id|RH_C_PORT_CONNECTION
)paren
suffix:colon
r_if
c_cond
(paren
id|wIndex
op_eq
l_int|1
)paren
(brace
id|hc-&gt;rh.wPortChange_1
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|RH_PORT_CONNECTION
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|wIndex
op_eq
l_int|2
)paren
(brace
id|hc-&gt;rh.wPortChange_2
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|RH_PORT_CONNECTION
)paren
suffix:semicolon
)brace
r_else
(brace
id|dbg_rh
c_func
(paren
l_string|&quot;RH_CLEAR_FEATURE-&gt;RH_C_PORT_CONNECTION &quot;
l_string|&quot;with invalid wIndex == %d!&quot;
comma
id|wIndex
)paren
suffix:semicolon
)brace
id|OK
(paren
l_int|0
)paren
suffix:semicolon
r_case
(paren
id|RH_C_PORT_ENABLE
)paren
suffix:colon
r_if
c_cond
(paren
id|wIndex
op_eq
l_int|1
)paren
(brace
id|hc-&gt;rh.wPortChange_1
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|RH_PORT_ENABLE
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|wIndex
op_eq
l_int|2
)paren
(brace
id|hc-&gt;rh.wPortChange_2
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|RH_PORT_ENABLE
)paren
suffix:semicolon
)brace
r_else
(brace
id|dbg_rh
c_func
(paren
l_string|&quot;RH_CLEAR_FEATURE-&gt;RH_C_PORT_ENABLE &quot;
l_string|&quot;with invalid wIndex == %d!&quot;
comma
id|wIndex
)paren
suffix:semicolon
)brace
id|OK
(paren
l_int|0
)paren
suffix:semicolon
r_case
(paren
id|RH_C_PORT_SUSPEND
)paren
suffix:colon
multiline_comment|/*** WR_RH_PORTSTAT(RH_PS_PSSC); */
id|OK
(paren
l_int|0
)paren
suffix:semicolon
r_case
(paren
id|RH_C_PORT_OVER_CURRENT
)paren
suffix:colon
id|OK
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* port power over current ** */
r_case
(paren
id|RH_C_PORT_RESET
)paren
suffix:colon
r_if
c_cond
(paren
id|wIndex
op_eq
l_int|1
)paren
(brace
id|hc-&gt;rh.wPortChange_1
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|RH_PORT_RESET
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|wIndex
op_eq
l_int|2
)paren
(brace
id|hc-&gt;rh.wPortChange_2
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|RH_PORT_RESET
)paren
suffix:semicolon
)brace
r_else
(brace
id|dbg_rh
c_func
(paren
l_string|&quot;RH_CLEAR_FEATURE-&gt;RH_C_PORT_RESET &quot;
l_string|&quot;with invalid index == %d!&quot;
comma
id|wIndex
)paren
suffix:semicolon
)brace
id|OK
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RH_SET_FEATURE
op_or
id|RH_OTHER
op_or
id|RH_CLASS
suffix:colon
r_switch
c_cond
(paren
id|wValue
)paren
(brace
r_case
(paren
id|RH_PORT_SUSPEND
)paren
suffix:colon
multiline_comment|/* Make sure the controller isn&squot;t busy. */
r_while
c_loop
(paren
op_star
id|R_USB_COMMAND
op_amp
id|IO_MASK
c_func
(paren
id|R_USB_COMMAND
comma
id|busy
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wIndex
op_eq
l_int|1
)paren
(brace
op_star
id|R_USB_COMMAND
op_assign
id|IO_STATE
c_func
(paren
id|R_USB_COMMAND
comma
id|port_sel
comma
id|port1
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_USB_COMMAND
comma
id|port_cmd
comma
id|suspend
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_USB_COMMAND
comma
id|ctrl_cmd
comma
id|nop
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|wIndex
op_eq
l_int|2
)paren
(brace
op_star
id|R_USB_COMMAND
op_assign
id|IO_STATE
c_func
(paren
id|R_USB_COMMAND
comma
id|port_sel
comma
id|port2
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_USB_COMMAND
comma
id|port_cmd
comma
id|suspend
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_USB_COMMAND
comma
id|ctrl_cmd
comma
id|nop
)paren
suffix:semicolon
)brace
r_else
(brace
id|dbg_rh
c_func
(paren
l_string|&quot;RH_SET_FEATURE-&gt;RH_PORT_SUSPEND &quot;
l_string|&quot;with invalid wIndex == %d!&quot;
comma
id|wIndex
)paren
suffix:semicolon
)brace
id|OK
(paren
l_int|0
)paren
suffix:semicolon
r_case
(paren
id|RH_PORT_RESET
)paren
suffix:colon
r_if
c_cond
(paren
id|wIndex
op_eq
l_int|1
)paren
(brace
id|port_1_reset
suffix:colon
id|dbg_rh
c_func
(paren
l_string|&quot;Doing reset of port 1&quot;
)paren
suffix:semicolon
multiline_comment|/* Make sure the controller isn&squot;t busy. */
r_while
c_loop
(paren
op_star
id|R_USB_COMMAND
op_amp
id|IO_MASK
c_func
(paren
id|R_USB_COMMAND
comma
id|busy
)paren
)paren
suffix:semicolon
op_star
id|R_USB_COMMAND
op_assign
id|IO_STATE
c_func
(paren
id|R_USB_COMMAND
comma
id|port_sel
comma
id|port1
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_USB_COMMAND
comma
id|port_cmd
comma
id|reset
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_USB_COMMAND
comma
id|ctrl_cmd
comma
id|nop
)paren
suffix:semicolon
multiline_comment|/* We must wait at least 10 ms for the device to recover.&n;&t;&t;&t;&t;   15 ms should be enough. */
id|udelay
c_func
(paren
l_int|15000
)paren
suffix:semicolon
multiline_comment|/* Wait for reset bit to go low (should be done by now). */
r_while
c_loop
(paren
id|hc-&gt;rh.prev_wPortStatus_1
op_amp
id|IO_STATE
c_func
(paren
id|R_USB_RH_PORT_STATUS_1
comma
id|reset
comma
id|yes
)paren
)paren
suffix:semicolon
multiline_comment|/* If the port status is&n;&t;&t;&t;&t;   1) connected and enabled then there is a device and everything is fine&n;&t;&t;&t;&t;   2) neither connected nor enabled then there is no device, also fine&n;&t;&t;&t;&t;   3) connected and not enabled then we try again&n;&t;&t;&t;&t;   (Yes, there are other port status combinations besides these.) */
r_if
c_cond
(paren
(paren
id|hc-&gt;rh.prev_wPortStatus_1
op_amp
id|IO_STATE
c_func
(paren
id|R_USB_RH_PORT_STATUS_1
comma
id|connected
comma
id|yes
)paren
)paren
op_logical_and
(paren
id|hc-&gt;rh.prev_wPortStatus_1
op_amp
id|IO_STATE
c_func
(paren
id|R_USB_RH_PORT_STATUS_1
comma
id|enabled
comma
id|no
)paren
)paren
)paren
(brace
id|dbg_rh
c_func
(paren
l_string|&quot;Connected device on port 1, but port not enabled?&quot;
l_string|&quot; Trying reset again.&quot;
)paren
suffix:semicolon
r_goto
id|port_2_reset
suffix:semicolon
)brace
multiline_comment|/* Diagnostic printouts. */
r_if
c_cond
(paren
(paren
id|hc-&gt;rh.prev_wPortStatus_1
op_amp
id|IO_STATE
c_func
(paren
id|R_USB_RH_PORT_STATUS_1
comma
id|connected
comma
id|no
)paren
)paren
op_logical_and
(paren
id|hc-&gt;rh.prev_wPortStatus_1
op_amp
id|IO_STATE
c_func
(paren
id|R_USB_RH_PORT_STATUS_1
comma
id|enabled
comma
id|no
)paren
)paren
)paren
(brace
id|dbg_rh
c_func
(paren
l_string|&quot;No connected device on port 1&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|hc-&gt;rh.prev_wPortStatus_1
op_amp
id|IO_STATE
c_func
(paren
id|R_USB_RH_PORT_STATUS_1
comma
id|connected
comma
id|yes
)paren
)paren
op_logical_and
(paren
id|hc-&gt;rh.prev_wPortStatus_1
op_amp
id|IO_STATE
c_func
(paren
id|R_USB_RH_PORT_STATUS_1
comma
id|enabled
comma
id|yes
)paren
)paren
)paren
(brace
id|dbg_rh
c_func
(paren
l_string|&quot;Connected device on port 1, port 1 enabled&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|wIndex
op_eq
l_int|2
)paren
(brace
id|port_2_reset
suffix:colon
id|dbg_rh
c_func
(paren
l_string|&quot;Doing reset of port 2&quot;
)paren
suffix:semicolon
multiline_comment|/* Make sure the controller isn&squot;t busy. */
r_while
c_loop
(paren
op_star
id|R_USB_COMMAND
op_amp
id|IO_MASK
c_func
(paren
id|R_USB_COMMAND
comma
id|busy
)paren
)paren
suffix:semicolon
multiline_comment|/* Issue the reset command. */
op_star
id|R_USB_COMMAND
op_assign
id|IO_STATE
c_func
(paren
id|R_USB_COMMAND
comma
id|port_sel
comma
id|port2
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_USB_COMMAND
comma
id|port_cmd
comma
id|reset
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_USB_COMMAND
comma
id|ctrl_cmd
comma
id|nop
)paren
suffix:semicolon
multiline_comment|/* We must wait at least 10 ms for the device to recover.&n;&t;&t;&t;&t;   15 ms should be enough. */
id|udelay
c_func
(paren
l_int|15000
)paren
suffix:semicolon
multiline_comment|/* Wait for reset bit to go low (should be done by now). */
r_while
c_loop
(paren
id|hc-&gt;rh.prev_wPortStatus_2
op_amp
id|IO_STATE
c_func
(paren
id|R_USB_RH_PORT_STATUS_2
comma
id|reset
comma
id|yes
)paren
)paren
suffix:semicolon
multiline_comment|/* If the port status is&n;&t;&t;&t;&t;   1) connected and enabled then there is a device and everything is fine&n;&t;&t;&t;&t;   2) neither connected nor enabled then there is no device, also fine&n;&t;&t;&t;&t;   3) connected and not enabled then we try again&n;&t;&t;&t;&t;   (Yes, there are other port status combinations besides these.) */
r_if
c_cond
(paren
(paren
id|hc-&gt;rh.prev_wPortStatus_2
op_amp
id|IO_STATE
c_func
(paren
id|R_USB_RH_PORT_STATUS_2
comma
id|connected
comma
id|yes
)paren
)paren
op_logical_and
(paren
id|hc-&gt;rh.prev_wPortStatus_2
op_amp
id|IO_STATE
c_func
(paren
id|R_USB_RH_PORT_STATUS_2
comma
id|enabled
comma
id|no
)paren
)paren
)paren
(brace
id|dbg_rh
c_func
(paren
l_string|&quot;Connected device on port 2, but port not enabled?&quot;
l_string|&quot; Trying reset again.&quot;
)paren
suffix:semicolon
r_goto
id|port_2_reset
suffix:semicolon
)brace
multiline_comment|/* Diagnostic printouts. */
r_if
c_cond
(paren
(paren
id|hc-&gt;rh.prev_wPortStatus_2
op_amp
id|IO_STATE
c_func
(paren
id|R_USB_RH_PORT_STATUS_2
comma
id|connected
comma
id|no
)paren
)paren
op_logical_and
(paren
id|hc-&gt;rh.prev_wPortStatus_2
op_amp
id|IO_STATE
c_func
(paren
id|R_USB_RH_PORT_STATUS_2
comma
id|enabled
comma
id|no
)paren
)paren
)paren
(brace
id|dbg_rh
c_func
(paren
l_string|&quot;No connected device on port 2&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|hc-&gt;rh.prev_wPortStatus_2
op_amp
id|IO_STATE
c_func
(paren
id|R_USB_RH_PORT_STATUS_2
comma
id|connected
comma
id|yes
)paren
)paren
op_logical_and
(paren
id|hc-&gt;rh.prev_wPortStatus_2
op_amp
id|IO_STATE
c_func
(paren
id|R_USB_RH_PORT_STATUS_2
comma
id|enabled
comma
id|yes
)paren
)paren
)paren
(brace
id|dbg_rh
c_func
(paren
l_string|&quot;Connected device on port 2, port 2 enabled&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|dbg_rh
c_func
(paren
l_string|&quot;RH_SET_FEATURE-&gt;RH_PORT_RESET with invalid wIndex = %d&quot;
comma
id|wIndex
)paren
suffix:semicolon
)brace
multiline_comment|/* Make sure the controller isn&squot;t busy. */
r_while
c_loop
(paren
op_star
id|R_USB_COMMAND
op_amp
id|IO_MASK
c_func
(paren
id|R_USB_COMMAND
comma
id|busy
)paren
)paren
suffix:semicolon
multiline_comment|/* If all enabled ports were disabled the host controller goes down into&n;&t;&t;&t;   started mode, so we need to bring it back into the running state.&n;&t;&t;&t;   (This is safe even if it&squot;s already in the running state.) */
op_star
id|R_USB_COMMAND
op_assign
id|IO_STATE
c_func
(paren
id|R_USB_COMMAND
comma
id|port_sel
comma
id|nop
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_USB_COMMAND
comma
id|port_cmd
comma
id|reset
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_USB_COMMAND
comma
id|ctrl_cmd
comma
id|host_run
)paren
suffix:semicolon
id|dbg_rh
c_func
(paren
l_string|&quot;...Done&quot;
)paren
suffix:semicolon
id|OK
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_case
(paren
id|RH_PORT_POWER
)paren
suffix:colon
id|OK
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* port power ** */
r_case
(paren
id|RH_PORT_ENABLE
)paren
suffix:colon
multiline_comment|/* There is no port enable command in the host controller, so if the&n;&t;&t;&t;   port is already enabled, we do nothing. If not, we reset the port&n;&t;&t;&t;   (with an ugly goto). */
r_if
c_cond
(paren
id|wIndex
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|hc-&gt;rh.prev_wPortStatus_1
op_amp
id|IO_STATE
c_func
(paren
id|R_USB_RH_PORT_STATUS_1
comma
id|enabled
comma
id|no
)paren
)paren
(brace
r_goto
id|port_1_reset
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|wIndex
op_eq
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|hc-&gt;rh.prev_wPortStatus_2
op_amp
id|IO_STATE
c_func
(paren
id|R_USB_RH_PORT_STATUS_2
comma
id|enabled
comma
id|no
)paren
)paren
(brace
r_goto
id|port_2_reset
suffix:semicolon
)brace
)brace
r_else
(brace
id|dbg_rh
c_func
(paren
l_string|&quot;RH_SET_FEATURE-&gt;RH_GET_STATUS with invalid wIndex = %d&quot;
comma
id|wIndex
)paren
suffix:semicolon
)brace
id|OK
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RH_SET_ADDRESS
suffix:colon
id|hc-&gt;rh.devnum
op_assign
id|wValue
suffix:semicolon
id|dbg_rh
c_func
(paren
l_string|&quot;RH address set to: %d&quot;
comma
id|hc-&gt;rh.devnum
)paren
suffix:semicolon
id|OK
(paren
l_int|0
)paren
suffix:semicolon
r_case
id|RH_GET_DESCRIPTOR
suffix:colon
r_switch
c_cond
(paren
(paren
id|wValue
op_amp
l_int|0xff00
)paren
op_rshift
l_int|8
)paren
(brace
r_case
(paren
l_int|0x01
)paren
suffix:colon
multiline_comment|/* device descriptor */
id|len
op_assign
id|min_t
c_func
(paren
r_int
r_int
comma
id|leni
comma
id|min_t
c_func
(paren
r_int
r_int
comma
r_sizeof
(paren
id|root_hub_dev_des
)paren
comma
id|wLength
)paren
)paren
suffix:semicolon
id|memcpy
(paren
id|data
comma
id|root_hub_dev_des
comma
id|len
)paren
suffix:semicolon
id|OK
(paren
id|len
)paren
suffix:semicolon
r_case
(paren
l_int|0x02
)paren
suffix:colon
multiline_comment|/* configuration descriptor */
id|len
op_assign
id|min_t
c_func
(paren
r_int
r_int
comma
id|leni
comma
id|min_t
c_func
(paren
r_int
r_int
comma
r_sizeof
(paren
id|root_hub_config_des
)paren
comma
id|wLength
)paren
)paren
suffix:semicolon
id|memcpy
(paren
id|data
comma
id|root_hub_config_des
comma
id|len
)paren
suffix:semicolon
id|OK
(paren
id|len
)paren
suffix:semicolon
r_case
(paren
l_int|0x03
)paren
suffix:colon
multiline_comment|/* string descriptors */
id|len
op_assign
id|usb_root_hub_string
(paren
id|wValue
op_amp
l_int|0xff
comma
l_int|0xff
comma
l_string|&quot;ETRAX 100LX&quot;
comma
id|data
comma
id|wLength
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|OK
c_func
(paren
id|min
c_func
(paren
id|leni
comma
id|len
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|stat
op_assign
op_minus
id|EPIPE
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|RH_GET_DESCRIPTOR
op_or
id|RH_CLASS
suffix:colon
id|root_hub_hub_des
(braket
l_int|2
)braket
op_assign
id|hc-&gt;rh.numports
suffix:semicolon
id|len
op_assign
id|min_t
c_func
(paren
r_int
r_int
comma
id|leni
comma
id|min_t
c_func
(paren
r_int
r_int
comma
r_sizeof
(paren
id|root_hub_hub_des
)paren
comma
id|wLength
)paren
)paren
suffix:semicolon
id|memcpy
(paren
id|data
comma
id|root_hub_hub_des
comma
id|len
)paren
suffix:semicolon
id|OK
(paren
id|len
)paren
suffix:semicolon
r_case
id|RH_GET_CONFIGURATION
suffix:colon
op_star
(paren
id|__u8
op_star
)paren
id|data
op_assign
l_int|0x01
suffix:semicolon
id|OK
(paren
l_int|1
)paren
suffix:semicolon
r_case
id|RH_SET_CONFIGURATION
suffix:colon
id|OK
(paren
l_int|0
)paren
suffix:semicolon
r_default
suffix:colon
id|stat
op_assign
op_minus
id|EPIPE
suffix:semicolon
)brace
id|urb-&gt;actual_length
op_assign
id|len
suffix:semicolon
id|urb-&gt;status
op_assign
id|stat
suffix:semicolon
id|urb-&gt;dev
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;complete
)paren
(brace
id|urb
op_member_access_from_pointer
id|complete
c_func
(paren
id|urb
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|DBFEXIT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|etrax_usb_bulk_eot_timer_func
id|etrax_usb_bulk_eot_timer_func
c_func
(paren
r_int
r_int
id|dummy
)paren
(brace
multiline_comment|/* Because of a race condition in the top half, we might miss a bulk eot.&n;&t;   This timer &quot;simulates&quot; a bulk eot if we don&squot;t get one for a while, hopefully&n;&t;   correcting the situation. */
id|dbg_bulk
c_func
(paren
l_string|&quot;bulk_eot_timer timed out.&quot;
)paren
suffix:semicolon
id|etrax_usb_hc_bulk_eot_interrupt
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_static
r_void
op_star
DECL|function|etrax_usb_buffer_alloc
id|etrax_usb_buffer_alloc
c_func
(paren
r_struct
id|usb_bus
op_star
id|bus
comma
r_int
id|size
comma
r_int
id|mem_flags
comma
id|dma_addr_t
op_star
id|dma
)paren
(brace
r_return
id|kmalloc
c_func
(paren
id|size
comma
id|mem_flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|etrax_usb_buffer_free
id|etrax_usb_buffer_free
c_func
(paren
r_struct
id|usb_bus
op_star
id|bus
comma
r_int
id|size
comma
r_void
op_star
id|addr
comma
id|dma_addr_t
id|dma
)paren
(brace
id|kfree
c_func
(paren
id|addr
)paren
suffix:semicolon
)brace
DECL|variable|fake_device
r_static
r_struct
id|device
id|fake_device
suffix:semicolon
DECL|function|etrax_usb_hc_init
r_static
r_int
id|__init
id|etrax_usb_hc_init
c_func
(paren
r_void
)paren
(brace
r_static
id|etrax_hc_t
op_star
id|hc
suffix:semicolon
r_struct
id|usb_bus
op_star
id|bus
suffix:semicolon
r_struct
id|usb_device
op_star
id|usb_rh
suffix:semicolon
r_int
id|i
suffix:semicolon
id|DBFENTER
suffix:semicolon
id|info
c_func
(paren
l_string|&quot;ETRAX 100LX USB-HCD %s (c) 2001-2003 Axis Communications AB&bslash;n&quot;
comma
id|usb_hcd_version
)paren
suffix:semicolon
id|hc
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|etrax_hc_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
m_assert
(paren
id|hc
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* We use kmem_cache_* to make sure that all DMA desc. are dword aligned */
multiline_comment|/* Note that we specify sizeof(USB_EP_Desc_t) as the size, but also allocate&n;&t;   SB descriptors from this cache. This is ok since sizeof(USB_EP_Desc_t) ==&n;&t;   sizeof(USB_SB_Desc_t). */
id|usb_desc_cache
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;usb_desc_cache&quot;
comma
r_sizeof
(paren
id|USB_EP_Desc_t
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
m_assert
(paren
id|usb_desc_cache
op_ne
l_int|NULL
)paren
suffix:semicolon
id|top_half_reg_cache
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;top_half_reg_cache&quot;
comma
r_sizeof
(paren
id|usb_interrupt_registers_t
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
m_assert
(paren
id|top_half_reg_cache
op_ne
l_int|NULL
)paren
suffix:semicolon
id|isoc_compl_cache
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;isoc_compl_cache&quot;
comma
r_sizeof
(paren
id|usb_isoc_complete_data_t
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
m_assert
(paren
id|isoc_compl_cache
op_ne
l_int|NULL
)paren
suffix:semicolon
id|etrax_usb_bus
op_assign
id|bus
op_assign
id|usb_alloc_bus
c_func
(paren
op_amp
id|etrax_usb_device_operations
)paren
suffix:semicolon
id|hc-&gt;bus
op_assign
id|bus
suffix:semicolon
id|bus-&gt;bus_name
op_assign
l_string|&quot;ETRAX 100LX&quot;
suffix:semicolon
id|bus-&gt;hcpriv
op_assign
id|hc
suffix:semicolon
multiline_comment|/* Initalize RH to the default address.&n;&t;   And make sure that we have no status change indication */
id|hc-&gt;rh.numports
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* The RH has two ports */
id|hc-&gt;rh.devnum
op_assign
l_int|1
suffix:semicolon
id|hc-&gt;rh.wPortChange_1
op_assign
l_int|0
suffix:semicolon
id|hc-&gt;rh.wPortChange_2
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Also initate the previous values to zero */
id|hc-&gt;rh.prev_wPortStatus_1
op_assign
l_int|0
suffix:semicolon
id|hc-&gt;rh.prev_wPortStatus_2
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Initialize the intr-traffic flags */
multiline_comment|/* FIXME: This isn&squot;t used. (Besides, the error field isn&squot;t initialized.) */
id|hc-&gt;intr.sleeping
op_assign
l_int|0
suffix:semicolon
id|hc-&gt;intr.wq
op_assign
l_int|NULL
suffix:semicolon
id|epid_usage_bitmask
op_assign
l_int|0
suffix:semicolon
id|epid_out_traffic
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Mark the invalid epid as being used. */
id|set_bit
c_func
(paren
id|INVALID_EPID
comma
(paren
r_void
op_star
)paren
op_amp
id|epid_usage_bitmask
)paren
suffix:semicolon
op_star
id|R_USB_EPT_INDEX
op_assign
id|IO_FIELD
c_func
(paren
id|R_USB_EPT_INDEX
comma
id|value
comma
id|INVALID_EPID
)paren
suffix:semicolon
id|nop
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* The valid bit should still be set (&squot;invalid&squot; is in our world; not the hardware&squot;s). */
op_star
id|R_USB_EPT_DATA
op_assign
(paren
id|IO_STATE
c_func
(paren
id|R_USB_EPT_DATA
comma
id|valid
comma
id|yes
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_USB_EPT_DATA
comma
id|max_len
comma
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/* Mark the dummy epid as being used. */
id|set_bit
c_func
(paren
id|DUMMY_EPID
comma
(paren
r_void
op_star
)paren
op_amp
id|epid_usage_bitmask
)paren
suffix:semicolon
op_star
id|R_USB_EPT_INDEX
op_assign
id|IO_FIELD
c_func
(paren
id|R_USB_EPT_INDEX
comma
id|value
comma
id|DUMMY_EPID
)paren
suffix:semicolon
id|nop
c_func
(paren
)paren
suffix:semicolon
op_star
id|R_USB_EPT_DATA
op_assign
(paren
id|IO_STATE
c_func
(paren
id|R_USB_EPT_DATA
comma
id|valid
comma
id|no
)paren
op_or
id|IO_FIELD
c_func
(paren
id|R_USB_EPT_DATA
comma
id|max_len
comma
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/* Initialize the urb list by initiating a head for each list. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NBR_OF_EPIDS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|urb_list
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|spin_lock_init
c_func
(paren
op_amp
id|urb_list_lock
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|urb_unlink_list
)paren
suffix:semicolon
multiline_comment|/* Initiate the bulk start timer. */
id|init_timer
c_func
(paren
op_amp
id|bulk_start_timer
)paren
suffix:semicolon
id|bulk_start_timer.expires
op_assign
id|jiffies
op_plus
id|BULK_START_TIMER_INTERVAL
suffix:semicolon
id|bulk_start_timer.function
op_assign
id|etrax_usb_bulk_start_timer_func
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|bulk_start_timer
)paren
suffix:semicolon
multiline_comment|/* Initiate the bulk eot timer. */
id|init_timer
c_func
(paren
op_amp
id|bulk_eot_timer
)paren
suffix:semicolon
id|bulk_eot_timer.expires
op_assign
id|jiffies
op_plus
id|BULK_EOT_TIMER_INTERVAL
suffix:semicolon
id|bulk_eot_timer.function
op_assign
id|etrax_usb_bulk_eot_timer_func
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|bulk_eot_timer
)paren
suffix:semicolon
multiline_comment|/* Set up the data structures for USB traffic. Note that this must be done before&n;&t;   any interrupt that relies on sane DMA list occurrs. */
id|init_rx_buffers
c_func
(paren
)paren
suffix:semicolon
id|init_tx_bulk_ep
c_func
(paren
)paren
suffix:semicolon
id|init_tx_ctrl_ep
c_func
(paren
)paren
suffix:semicolon
id|init_tx_intr_ep
c_func
(paren
)paren
suffix:semicolon
id|init_tx_isoc_ep
c_func
(paren
)paren
suffix:semicolon
id|device_initialize
c_func
(paren
op_amp
id|fake_device
)paren
suffix:semicolon
id|kobject_set_name
c_func
(paren
op_amp
id|fake_device.kobj
comma
l_string|&quot;etrax_usb&quot;
)paren
suffix:semicolon
id|kobject_add
c_func
(paren
op_amp
id|fake_device.kobj
)paren
suffix:semicolon
id|hc-&gt;bus-&gt;controller
op_assign
op_amp
id|fake_device
suffix:semicolon
id|usb_register_bus
c_func
(paren
id|hc-&gt;bus
)paren
suffix:semicolon
op_star
id|R_IRQ_MASK2_SET
op_assign
multiline_comment|/* Note that these interrupts are not used. */
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK2_SET
comma
id|dma8_sub0_descr
comma
id|set
)paren
op_or
multiline_comment|/* Sub channel 1 (ctrl) descr. interrupts are used. */
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK2_SET
comma
id|dma8_sub1_descr
comma
id|set
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK2_SET
comma
id|dma8_sub2_descr
comma
id|set
)paren
op_or
multiline_comment|/* Sub channel 3 (isoc) descr. interrupts are used. */
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK2_SET
comma
id|dma8_sub3_descr
comma
id|set
)paren
suffix:semicolon
multiline_comment|/* Note that the dma9_descr interrupt is not used. */
op_star
id|R_IRQ_MASK2_SET
op_assign
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK2_SET
comma
id|dma9_eop
comma
id|set
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_IRQ_MASK2_SET
comma
id|dma9_descr
comma
id|set
)paren
suffix:semicolon
multiline_comment|/* FIXME: Enable iso_eof only when isoc traffic is running. */
op_star
id|R_USB_IRQ_MASK_SET
op_assign
id|IO_STATE
c_func
(paren
id|R_USB_IRQ_MASK_SET
comma
id|iso_eof
comma
id|set
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_USB_IRQ_MASK_SET
comma
id|bulk_eot
comma
id|set
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_USB_IRQ_MASK_SET
comma
id|epid_attn
comma
id|set
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_USB_IRQ_MASK_SET
comma
id|port_status
comma
id|set
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_USB_IRQ_MASK_SET
comma
id|ctl_status
comma
id|set
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|ETRAX_USB_HC_IRQ
comma
id|etrax_usb_hc_interrupt_top_half
comma
l_int|0
comma
l_string|&quot;ETRAX 100LX built-in USB (HC)&quot;
comma
id|hc
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Could not allocate IRQ %d for USB&quot;
comma
id|ETRAX_USB_HC_IRQ
)paren
suffix:semicolon
id|etrax_usb_hc_cleanup
c_func
(paren
)paren
suffix:semicolon
id|DBFEXIT
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|ETRAX_USB_RX_IRQ
comma
id|etrax_usb_rx_interrupt
comma
l_int|0
comma
l_string|&quot;ETRAX 100LX built-in USB (Rx)&quot;
comma
id|hc
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Could not allocate IRQ %d for USB&quot;
comma
id|ETRAX_USB_RX_IRQ
)paren
suffix:semicolon
id|etrax_usb_hc_cleanup
c_func
(paren
)paren
suffix:semicolon
id|DBFEXIT
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|ETRAX_USB_TX_IRQ
comma
id|etrax_usb_tx_interrupt
comma
l_int|0
comma
l_string|&quot;ETRAX 100LX built-in USB (Tx)&quot;
comma
id|hc
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Could not allocate IRQ %d for USB&quot;
comma
id|ETRAX_USB_TX_IRQ
)paren
suffix:semicolon
id|etrax_usb_hc_cleanup
c_func
(paren
)paren
suffix:semicolon
id|DBFEXIT
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* R_USB_COMMAND:&n;&t;   USB commands in host mode. The fields in this register should all be&n;&t;   written to in one write. Do not read-modify-write one field at a time. A&n;&t;   write to this register will trigger events in the USB controller and an&n;&t;   incomplete command may lead to unpredictable results, and in worst case&n;&t;   even to a deadlock in the controller.&n;&t;   (Note however that the busy field is read-only, so no need to write to it.) */
multiline_comment|/* Check the busy bit before writing to R_USB_COMMAND. */
r_while
c_loop
(paren
op_star
id|R_USB_COMMAND
op_amp
id|IO_MASK
c_func
(paren
id|R_USB_COMMAND
comma
id|busy
)paren
)paren
suffix:semicolon
multiline_comment|/* Reset the USB interface. */
op_star
id|R_USB_COMMAND
op_assign
id|IO_STATE
c_func
(paren
id|R_USB_COMMAND
comma
id|port_sel
comma
id|nop
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_USB_COMMAND
comma
id|port_cmd
comma
id|reset
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_USB_COMMAND
comma
id|ctrl_cmd
comma
id|reset
)paren
suffix:semicolon
multiline_comment|/* Designer&squot;s Reference, p. 8 - 10 says we should Initate R_USB_FM_PSTART to 0x2A30 (10800),&n;&t;   to guarantee that control traffic gets 10% of the bandwidth, and periodic transfer may&n;&t;   allocate the rest (90%). This doesn&squot;t work though. Read on for a lenghty explanation.&n;&n;&t;   While there is a difference between rev. 2 and rev. 3 of the ETRAX 100LX regarding the NAK&n;&t;   behaviour, it doesn&squot;t solve this problem. What happens is that a control transfer will not&n;&t;   be interrupted in its data stage when PSTART happens (the point at which periodic traffic&n;&t;   is started). Thus, if PSTART is set to 10800 and its IN or OUT token is NAKed until just before&n;&t;   PSTART happens, it will continue the IN/OUT transfer as long as it&squot;s ACKed. After it&squot;s done,&n;&t;   there may be too little time left for an isochronous transfer, causing an epid attention&n;&t;   interrupt due to perror. The work-around for this is to let the control transfers run at the&n;&t;   end of the frame instead of at the beginning, and will be interrupted just fine if it doesn&squot;t&n;&t;   fit into the frame. However, since there will *always* be a control transfer at the beginning&n;&t;   of the frame, regardless of what we set PSTART to, that transfer might be a 64-byte transfer&n;&t;   which consumes up to 15% of the frame, leaving only 85% for periodic traffic. The solution to&n;&t;   this would be to &squot;dummy allocate&squot; 5% of the frame with the usb_claim_bandwidth function to make&n;&t;   sure that the periodic transfers that are inserted will always fit in the frame.&n;&n;&t;   The idea was suggested that a control transfer could be split up into several 8 byte transfers,&n;&t;   so that it would be interrupted by PSTART, but since this can&squot;t be done for an IN transfer this&n;&t;   hasn&squot;t been implemented.&n;&n;&t;   The value 11960 is chosen to be just after the SOF token, with a couple of bit times extra&n;&t;   for possible bit stuffing. */
op_star
id|R_USB_FM_PSTART
op_assign
id|IO_FIELD
c_func
(paren
id|R_USB_FM_PSTART
comma
id|value
comma
l_int|11960
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_ETRAX_USB_HOST_PORT1
op_star
id|R_USB_PORT1_DISABLE
op_assign
id|IO_STATE
c_func
(paren
id|R_USB_PORT1_DISABLE
comma
id|disable
comma
id|no
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_ETRAX_USB_HOST_PORT2
op_star
id|R_USB_PORT2_DISABLE
op_assign
id|IO_STATE
c_func
(paren
id|R_USB_PORT2_DISABLE
comma
id|disable
comma
id|no
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
op_star
id|R_USB_COMMAND
op_amp
id|IO_MASK
c_func
(paren
id|R_USB_COMMAND
comma
id|busy
)paren
)paren
suffix:semicolon
multiline_comment|/* Configure the USB interface as a host controller. */
op_star
id|R_USB_COMMAND
op_assign
id|IO_STATE
c_func
(paren
id|R_USB_COMMAND
comma
id|port_sel
comma
id|nop
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_USB_COMMAND
comma
id|port_cmd
comma
id|reset
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_USB_COMMAND
comma
id|ctrl_cmd
comma
id|host_config
)paren
suffix:semicolon
multiline_comment|/* Note: Do not reset any ports here. Await the port status interrupts, to have a controlled&n;&t;   sequence of resetting the ports. If we reset both ports now, and there are devices&n;&t;   on both ports, we will get a bus error because both devices will answer the set address&n;&t;   request. */
r_while
c_loop
(paren
op_star
id|R_USB_COMMAND
op_amp
id|IO_MASK
c_func
(paren
id|R_USB_COMMAND
comma
id|busy
)paren
)paren
suffix:semicolon
multiline_comment|/* Start processing of USB traffic. */
op_star
id|R_USB_COMMAND
op_assign
id|IO_STATE
c_func
(paren
id|R_USB_COMMAND
comma
id|port_sel
comma
id|nop
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_USB_COMMAND
comma
id|port_cmd
comma
id|reset
)paren
op_or
id|IO_STATE
c_func
(paren
id|R_USB_COMMAND
comma
id|ctrl_cmd
comma
id|host_run
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|R_USB_COMMAND
op_amp
id|IO_MASK
c_func
(paren
id|R_USB_COMMAND
comma
id|busy
)paren
)paren
suffix:semicolon
id|usb_rh
op_assign
id|usb_alloc_dev
c_func
(paren
l_int|NULL
comma
id|hc-&gt;bus
comma
l_int|0
)paren
suffix:semicolon
id|hc-&gt;bus-&gt;root_hub
op_assign
id|usb_rh
suffix:semicolon
id|usb_rh-&gt;state
op_assign
id|USB_STATE_ADDRESS
suffix:semicolon
id|usb_rh-&gt;speed
op_assign
id|USB_SPEED_FULL
suffix:semicolon
id|usb_rh-&gt;devnum
op_assign
l_int|1
suffix:semicolon
id|hc-&gt;bus-&gt;devnum_next
op_assign
l_int|2
suffix:semicolon
id|usb_rh-&gt;ep0.desc.wMaxPacketSize
op_assign
l_int|64
suffix:semicolon
id|usb_get_device_descriptor
c_func
(paren
id|usb_rh
comma
id|USB_DT_DEVICE_SIZE
)paren
suffix:semicolon
id|usb_new_device
c_func
(paren
id|usb_rh
)paren
suffix:semicolon
id|DBFEXIT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|etrax_usb_hc_cleanup
r_static
r_void
id|etrax_usb_hc_cleanup
c_func
(paren
r_void
)paren
(brace
id|DBFENTER
suffix:semicolon
id|free_irq
c_func
(paren
id|ETRAX_USB_HC_IRQ
comma
l_int|NULL
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|ETRAX_USB_RX_IRQ
comma
l_int|NULL
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|ETRAX_USB_TX_IRQ
comma
l_int|NULL
)paren
suffix:semicolon
id|usb_deregister_bus
c_func
(paren
id|etrax_usb_bus
)paren
suffix:semicolon
multiline_comment|/* FIXME: call kmem_cache_destroy here? */
id|DBFEXIT
suffix:semicolon
)brace
DECL|variable|etrax_usb_hc_init
id|module_init
c_func
(paren
id|etrax_usb_hc_init
)paren
suffix:semicolon
DECL|variable|etrax_usb_hc_cleanup
id|module_exit
c_func
(paren
id|etrax_usb_hc_cleanup
)paren
suffix:semicolon
eof
