multiline_comment|/*&n; * Copyright (c) 2001-2002 by David Brownell&n; * &n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2 of the License, or (at your&n; * option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY&n; * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License&n; * for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software Foundation,&n; * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
multiline_comment|/* this file is part of ehci-hcd.c */
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * EHCI scheduled transaction support:  interrupt, iso, split iso&n; * These are called &quot;periodic&quot; transactions in the EHCI spec.&n; */
multiline_comment|/*&n; * Ceiling microseconds (typical) for that many bytes at high speed&n; * ISO is a bit less, no ACK ... from USB 2.0 spec, 5.11.3 (and needed&n; * to preallocate bandwidth)&n; */
DECL|macro|EHCI_HOST_DELAY
mdefine_line|#define EHCI_HOST_DELAY&t;5&t;/* nsec, guess */
DECL|macro|HS_USECS
mdefine_line|#define HS_USECS(bytes) NS_TO_US ( ((55 * 8 * 2083)/1000) &bslash;&n;&t;+ ((2083UL * (3167 + BitTime (bytes)))/1000) &bslash;&n;&t;+ EHCI_HOST_DELAY)
DECL|macro|HS_USECS_ISO
mdefine_line|#define HS_USECS_ISO(bytes) NS_TO_US ( ((long)(38 * 8 * 2.083)) &bslash;&n;&t;+ ((2083UL * (3167 + BitTime (bytes)))/1000) &bslash;&n;&t;+ EHCI_HOST_DELAY)
r_static
r_int
id|ehci_get_frame
(paren
r_struct
id|usb_hcd
op_star
id|hcd
)paren
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * periodic_next_shadow - return &quot;next&quot; pointer on shadow list&n; * @periodic: host pointer to qh/itd/sitd&n; * @tag: hardware tag for type of this record&n; */
r_static
r_union
id|ehci_shadow
op_star
DECL|function|periodic_next_shadow
id|periodic_next_shadow
(paren
r_union
id|ehci_shadow
op_star
id|periodic
comma
r_int
id|tag
)paren
(brace
r_switch
c_cond
(paren
id|tag
)paren
(brace
r_case
id|Q_TYPE_QH
suffix:colon
r_return
op_amp
id|periodic-&gt;qh-&gt;qh_next
suffix:semicolon
r_case
id|Q_TYPE_FSTN
suffix:colon
r_return
op_amp
id|periodic-&gt;fstn-&gt;fstn_next
suffix:semicolon
r_case
id|Q_TYPE_ITD
suffix:colon
r_return
op_amp
id|periodic-&gt;itd-&gt;itd_next
suffix:semicolon
macro_line|#ifdef have_split_iso
r_case
id|Q_TYPE_SITD
suffix:colon
r_return
op_amp
id|periodic-&gt;sitd-&gt;sitd_next
suffix:semicolon
macro_line|#endif /* have_split_iso */
)brace
id|dbg
(paren
l_string|&quot;BAD shadow %p tag %d&quot;
comma
id|periodic-&gt;ptr
comma
id|tag
)paren
suffix:semicolon
singleline_comment|// BUG ();
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* returns true after successful unlink */
multiline_comment|/* caller must hold ehci-&gt;lock */
DECL|function|periodic_unlink
r_static
r_int
id|periodic_unlink
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_int
id|frame
comma
r_void
op_star
id|ptr
)paren
(brace
r_union
id|ehci_shadow
op_star
id|prev_p
op_assign
op_amp
id|ehci-&gt;pshadow
(braket
id|frame
)braket
suffix:semicolon
id|u32
op_star
id|hw_p
op_assign
op_amp
id|ehci-&gt;periodic
(braket
id|frame
)braket
suffix:semicolon
r_union
id|ehci_shadow
id|here
op_assign
op_star
id|prev_p
suffix:semicolon
r_union
id|ehci_shadow
op_star
id|next_p
suffix:semicolon
multiline_comment|/* find predecessor of &quot;ptr&quot;; hw and shadow lists are in sync */
r_while
c_loop
(paren
id|here.ptr
op_logical_and
id|here.ptr
op_ne
id|ptr
)paren
(brace
id|prev_p
op_assign
id|periodic_next_shadow
(paren
id|prev_p
comma
id|Q_NEXT_TYPE
(paren
op_star
id|hw_p
)paren
)paren
suffix:semicolon
id|hw_p
op_assign
op_amp
id|here.qh-&gt;hw_next
suffix:semicolon
id|here
op_assign
op_star
id|prev_p
suffix:semicolon
)brace
multiline_comment|/* an interrupt entry (at list end) could have been shared */
r_if
c_cond
(paren
op_logical_neg
id|here.ptr
)paren
(brace
id|dbg
(paren
l_string|&quot;entry %p no longer on frame [%d]&quot;
comma
id|ptr
comma
id|frame
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|// vdbg (&quot;periodic unlink %p from frame %d&quot;, ptr, frame);
multiline_comment|/* update hardware list ... HC may still know the old structure, so&n;&t; * don&squot;t change hw_next until it&squot;ll have purged its cache&n;&t; */
id|next_p
op_assign
id|periodic_next_shadow
(paren
op_amp
id|here
comma
id|Q_NEXT_TYPE
(paren
op_star
id|hw_p
)paren
)paren
suffix:semicolon
op_star
id|hw_p
op_assign
id|here.qh-&gt;hw_next
suffix:semicolon
multiline_comment|/* unlink from shadow list; HCD won&squot;t see old structure again */
op_star
id|prev_p
op_assign
op_star
id|next_p
suffix:semicolon
id|next_p-&gt;ptr
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* how many of the uframe&squot;s 125 usecs are allocated? */
r_static
r_int
r_int
DECL|function|periodic_usecs
id|periodic_usecs
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_int
id|frame
comma
r_int
id|uframe
)paren
(brace
id|u32
op_star
id|hw_p
op_assign
op_amp
id|ehci-&gt;periodic
(braket
id|frame
)braket
suffix:semicolon
r_union
id|ehci_shadow
op_star
id|q
op_assign
op_amp
id|ehci-&gt;pshadow
(braket
id|frame
)braket
suffix:semicolon
r_int
id|usecs
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|q-&gt;ptr
)paren
(brace
r_switch
c_cond
(paren
id|Q_NEXT_TYPE
(paren
op_star
id|hw_p
)paren
)paren
(brace
r_case
id|Q_TYPE_QH
suffix:colon
multiline_comment|/* is it in the S-mask? */
r_if
c_cond
(paren
id|q-&gt;qh-&gt;hw_info2
op_amp
id|cpu_to_le32
(paren
l_int|1
op_lshift
id|uframe
)paren
)paren
id|usecs
op_add_assign
id|q-&gt;qh-&gt;usecs
suffix:semicolon
id|q
op_assign
op_amp
id|q-&gt;qh-&gt;qh_next
suffix:semicolon
r_break
suffix:semicolon
r_case
id|Q_TYPE_FSTN
suffix:colon
multiline_comment|/* for &quot;save place&quot; FSTNs, count the relevant INTR&n;&t;&t;&t; * bandwidth from the previous frame&n;&t;&t;&t; */
r_if
c_cond
(paren
id|q-&gt;fstn-&gt;hw_prev
op_ne
id|EHCI_LIST_END
)paren
(brace
id|dbg
(paren
l_string|&quot;not counting FSTN bandwidth yet ...&quot;
)paren
suffix:semicolon
)brace
id|q
op_assign
op_amp
id|q-&gt;fstn-&gt;fstn_next
suffix:semicolon
r_break
suffix:semicolon
r_case
id|Q_TYPE_ITD
suffix:colon
multiline_comment|/* NOTE the &quot;one uframe per itd&quot; policy */
r_if
c_cond
(paren
id|q-&gt;itd-&gt;hw_transaction
(braket
id|uframe
)braket
op_ne
l_int|0
)paren
id|usecs
op_add_assign
id|q-&gt;itd-&gt;usecs
suffix:semicolon
id|q
op_assign
op_amp
id|q-&gt;itd-&gt;itd_next
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef have_split_iso
r_case
id|Q_TYPE_SITD
suffix:colon
id|temp
op_assign
id|q-&gt;sitd-&gt;hw_fullspeed_ep
op_amp
id|__constant_cpu_to_le32
(paren
l_int|1
op_lshift
l_int|31
)paren
suffix:semicolon
singleline_comment|// FIXME:  this doesn&squot;t count data bytes right...
multiline_comment|/* is it in the S-mask?  (count SPLIT, DATA) */
r_if
c_cond
(paren
id|q-&gt;sitd-&gt;hw_uframe
op_amp
id|cpu_to_le32
(paren
l_int|1
op_lshift
id|uframe
)paren
)paren
(brace
r_if
c_cond
(paren
id|temp
)paren
id|usecs
op_add_assign
id|HS_USECS
(paren
l_int|188
)paren
suffix:semicolon
r_else
id|usecs
op_add_assign
id|HS_USECS
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* ... C-mask?  (count CSPLIT, DATA) */
r_if
c_cond
(paren
id|q-&gt;sitd-&gt;hw_uframe
op_amp
id|cpu_to_le32
(paren
l_int|1
op_lshift
(paren
l_int|8
op_plus
id|uframe
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|temp
)paren
id|usecs
op_add_assign
id|HS_USECS
(paren
l_int|0
)paren
suffix:semicolon
r_else
id|usecs
op_add_assign
id|HS_USECS
(paren
l_int|188
)paren
suffix:semicolon
)brace
id|q
op_assign
op_amp
id|q-&gt;sitd-&gt;sitd_next
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /* have_split_iso */
r_default
suffix:colon
id|BUG
(paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef&t;DEBUG
r_if
c_cond
(paren
id|usecs
OG
l_int|100
)paren
id|err
(paren
l_string|&quot;overallocated uframe %d, periodic is %d usecs&quot;
comma
id|frame
op_star
l_int|8
op_plus
id|uframe
comma
id|usecs
)paren
suffix:semicolon
macro_line|#endif
r_return
id|usecs
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|enable_periodic
r_static
r_void
id|enable_periodic
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
)paren
(brace
id|u32
id|cmd
suffix:semicolon
multiline_comment|/* did clearing PSE did take effect yet?&n;&t; * takes effect only at frame boundaries...&n;&t; */
r_while
c_loop
(paren
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;status
)paren
op_amp
id|STS_PSS
)paren
id|udelay
(paren
l_int|20
)paren
suffix:semicolon
id|cmd
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
op_or
id|CMD_PSE
suffix:semicolon
id|writel
(paren
id|cmd
comma
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
multiline_comment|/* posted write ... PSS happens later */
id|ehci-&gt;hcd.state
op_assign
id|USB_STATE_RUNNING
suffix:semicolon
multiline_comment|/* make sure tasklet scans these */
id|ehci-&gt;next_uframe
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;frame_index
)paren
op_mod
(paren
id|ehci-&gt;periodic_size
op_lshift
l_int|3
)paren
suffix:semicolon
)brace
DECL|function|disable_periodic
r_static
r_void
id|disable_periodic
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
)paren
(brace
id|u32
id|cmd
suffix:semicolon
multiline_comment|/* did setting PSE not take effect yet?&n;&t; * takes effect only at frame boundaries...&n;&t; */
r_while
c_loop
(paren
op_logical_neg
(paren
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;status
)paren
op_amp
id|STS_PSS
)paren
)paren
id|udelay
(paren
l_int|20
)paren
suffix:semicolon
id|cmd
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
op_amp
op_complement
id|CMD_PSE
suffix:semicolon
id|writel
(paren
id|cmd
comma
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
multiline_comment|/* posted write ... */
id|ehci-&gt;next_uframe
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|intr_deschedule
r_static
r_void
id|intr_deschedule
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_int
id|frame
comma
r_struct
id|ehci_qh
op_star
id|qh
comma
r_int
id|period
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_do
(brace
id|periodic_unlink
(paren
id|ehci
comma
id|frame
comma
id|qh
)paren
suffix:semicolon
id|qh_put
(paren
id|ehci
comma
id|qh
)paren
suffix:semicolon
id|frame
op_add_assign
id|period
suffix:semicolon
)brace
r_while
c_loop
(paren
id|frame
OL
id|ehci-&gt;periodic_size
)paren
suffix:semicolon
id|qh-&gt;qh_state
op_assign
id|QH_STATE_UNLINK
suffix:semicolon
id|qh-&gt;qh_next.ptr
op_assign
l_int|0
suffix:semicolon
id|ehci-&gt;periodic_urbs
op_decrement
suffix:semicolon
multiline_comment|/* maybe turn off periodic schedule */
r_if
c_cond
(paren
op_logical_neg
id|ehci-&gt;periodic_urbs
)paren
id|disable_periodic
(paren
id|ehci
)paren
suffix:semicolon
r_else
id|vdbg
(paren
l_string|&quot;periodic schedule still enabled&quot;
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the hc may be looking at this qh, then delay a uframe&n;&t; * (yeech!) to be sure it&squot;s done.&n;&t; * No other threads may be mucking with this qh.&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|ehci_get_frame
(paren
op_amp
id|ehci-&gt;hcd
)paren
op_minus
id|frame
)paren
op_mod
id|period
)paren
op_eq
l_int|0
)paren
id|udelay
(paren
l_int|125
)paren
suffix:semicolon
id|qh-&gt;qh_state
op_assign
id|QH_STATE_IDLE
suffix:semicolon
id|qh-&gt;hw_next
op_assign
id|EHCI_LIST_END
suffix:semicolon
id|vdbg
(paren
l_string|&quot;descheduled qh %p, per = %d frame = %d count = %d, urbs = %d&quot;
comma
id|qh
comma
id|period
comma
id|frame
comma
id|atomic_read
(paren
op_amp
id|qh-&gt;refcount
)paren
comma
id|ehci-&gt;periodic_urbs
)paren
suffix:semicolon
)brace
DECL|function|intr_submit
r_static
r_int
id|intr_submit
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|list_head
op_star
id|qtd_list
comma
r_int
id|mem_flags
)paren
(brace
r_int
id|epnum
comma
id|period
suffix:semicolon
r_int
id|temp
suffix:semicolon
r_int
r_int
id|usecs
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|ehci_qh
op_star
id|qh
suffix:semicolon
r_struct
id|hcd_dev
op_star
id|dev
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* get endpoint and transfer data */
id|epnum
op_assign
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
id|temp
op_assign
id|urb-&gt;dev-&gt;epmaxpacketin
(braket
id|epnum
)braket
suffix:semicolon
id|epnum
op_or_assign
l_int|0x10
suffix:semicolon
)brace
r_else
id|temp
op_assign
id|urb-&gt;dev-&gt;epmaxpacketout
(braket
id|epnum
)braket
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;dev-&gt;speed
op_ne
id|USB_SPEED_HIGH
)paren
(brace
id|dbg
(paren
l_string|&quot;no intr/tt scheduling yet&quot;
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|ENOSYS
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * NOTE: current completion/restart logic doesn&squot;t handle more than&n;&t; * one qtd in a periodic qh ... 16-20 KB/urb is pretty big for this.&n;&t; * such big requests need many periods to transfer.&n;&t; */
r_if
c_cond
(paren
id|unlikely
(paren
id|qtd_list-&gt;next
op_ne
id|qtd_list-&gt;prev
)paren
)paren
(brace
id|dbg
(paren
l_string|&quot;only one intr qtd per urb allowed&quot;
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|usecs
op_assign
id|HS_USECS
(paren
id|urb-&gt;transfer_buffer_length
)paren
suffix:semicolon
multiline_comment|/* FIXME handle HS periods of less than 1 frame. */
r_if
c_cond
(paren
id|urb-&gt;interval
OL
l_int|8
)paren
id|period
op_assign
l_int|1
suffix:semicolon
r_else
id|period
op_assign
id|urb-&gt;interval
op_rshift
l_int|8
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* get the qh (must be empty and idle) */
id|dev
op_assign
(paren
r_struct
id|hcd_dev
op_star
)paren
id|urb-&gt;dev-&gt;hcpriv
suffix:semicolon
id|qh
op_assign
(paren
r_struct
id|ehci_qh
op_star
)paren
id|dev-&gt;ep
(braket
id|epnum
)braket
suffix:semicolon
r_if
c_cond
(paren
id|qh
)paren
(brace
multiline_comment|/* only allow one queued interrupt urb per EP */
r_if
c_cond
(paren
id|unlikely
(paren
id|qh-&gt;qh_state
op_ne
id|QH_STATE_IDLE
op_logical_or
op_logical_neg
id|list_empty
(paren
op_amp
id|qh-&gt;qtd_list
)paren
)paren
)paren
(brace
id|dbg
(paren
l_string|&quot;interrupt urb already queued&quot;
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* maybe reset hardware&squot;s data toggle in the qh */
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|usb_gettoggle
(paren
id|urb-&gt;dev
comma
id|epnum
op_amp
l_int|0x0f
comma
op_logical_neg
(paren
id|epnum
op_amp
l_int|0x10
)paren
)paren
)paren
)paren
(brace
id|qh-&gt;hw_token
op_or_assign
id|__constant_cpu_to_le32
(paren
id|QTD_TOGGLE
)paren
suffix:semicolon
id|usb_settoggle
(paren
id|urb-&gt;dev
comma
id|epnum
op_amp
l_int|0x0f
comma
op_logical_neg
(paren
id|epnum
op_amp
l_int|0x10
)paren
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* trust the QH was set up as interrupt ... */
id|list_splice
(paren
id|qtd_list
comma
op_amp
id|qh-&gt;qtd_list
)paren
suffix:semicolon
id|qh_update
(paren
id|qh
comma
id|list_entry
(paren
id|qtd_list-&gt;next
comma
r_struct
id|ehci_qtd
comma
id|qtd_list
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* can&squot;t sleep here, we have ehci-&gt;lock... */
id|qh
op_assign
id|ehci_qh_make
(paren
id|ehci
comma
id|urb
comma
id|qtd_list
comma
id|SLAB_ATOMIC
)paren
suffix:semicolon
id|qtd_list
op_assign
op_amp
id|qh-&gt;qtd_list
suffix:semicolon
r_if
c_cond
(paren
id|likely
(paren
id|qh
op_ne
l_int|0
)paren
)paren
(brace
singleline_comment|// dbg (&quot;new INTR qh %p&quot;, qh);
id|dev-&gt;ep
(braket
id|epnum
)braket
op_assign
id|qh
suffix:semicolon
)brace
r_else
id|status
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Schedule this periodic QH. */
r_if
c_cond
(paren
id|likely
(paren
id|status
op_eq
l_int|0
)paren
)paren
(brace
r_int
id|frame
op_assign
id|urb-&gt;interval
suffix:semicolon
id|qh-&gt;hw_next
op_assign
id|EHCI_LIST_END
suffix:semicolon
id|qh-&gt;usecs
op_assign
id|usecs
suffix:semicolon
id|urb-&gt;hcpriv
op_assign
id|qh_get
(paren
id|qh
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|ENOSPC
suffix:semicolon
multiline_comment|/* pick a set of schedule slots, link the QH into them */
r_do
(brace
r_int
id|uframe
suffix:semicolon
multiline_comment|/* Select some frame 0..(urb-&gt;interval - 1) with a&n;&t;&t;&t; * microframe that can hold this transaction.&n;&t;&t;&t; *&n;&t;&t;&t; * FIXME for TT splits, need uframes for start and end.&n;&t;&t;&t; * FSTNs can put end into next frame (uframes 0 or 1).&n;&t;&t;&t; */
id|frame
op_decrement
suffix:semicolon
r_for
c_loop
(paren
id|uframe
op_assign
l_int|0
suffix:semicolon
id|uframe
OL
l_int|8
suffix:semicolon
id|uframe
op_increment
)paren
(brace
r_int
id|claimed
suffix:semicolon
id|claimed
op_assign
id|periodic_usecs
(paren
id|ehci
comma
id|frame
comma
id|uframe
)paren
suffix:semicolon
multiline_comment|/* 80% periodic == 100 usec max committed */
r_if
c_cond
(paren
(paren
id|claimed
op_plus
id|usecs
)paren
op_le
l_int|100
)paren
(brace
id|vdbg
(paren
l_string|&quot;frame %d.%d: %d usecs, plus %d&quot;
comma
id|frame
comma
id|uframe
comma
id|claimed
comma
id|usecs
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|uframe
op_eq
l_int|8
)paren
r_continue
suffix:semicolon
singleline_comment|// FIXME delete when code below handles non-empty queues
r_if
c_cond
(paren
id|ehci-&gt;pshadow
(braket
id|frame
)braket
dot
id|ptr
)paren
r_continue
suffix:semicolon
multiline_comment|/* QH will run once each period, starting there  */
id|urb-&gt;start_frame
op_assign
id|frame
suffix:semicolon
id|status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set S-frame mask */
id|qh-&gt;hw_info2
op_or_assign
id|cpu_to_le32
(paren
l_int|1
op_lshift
id|uframe
)paren
suffix:semicolon
singleline_comment|// dbg_qh (&quot;Schedule INTR qh&quot;, ehci, qh);
multiline_comment|/* stuff into the periodic schedule */
id|qh-&gt;qh_state
op_assign
id|QH_STATE_LINKED
suffix:semicolon
id|vdbg
(paren
l_string|&quot;qh %p usecs %d period %d starting %d.%d&quot;
comma
id|qh
comma
id|qh-&gt;usecs
comma
id|period
comma
id|frame
comma
id|uframe
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|unlikely
(paren
id|ehci-&gt;pshadow
(braket
id|frame
)braket
dot
id|ptr
op_ne
l_int|0
)paren
)paren
(brace
singleline_comment|// FIXME -- just link to the end, before any qh with a shorter period,
singleline_comment|// AND handle it already being (implicitly) linked into this frame
id|BUG
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|ehci-&gt;pshadow
(braket
id|frame
)braket
dot
id|qh
op_assign
id|qh_get
(paren
id|qh
)paren
suffix:semicolon
id|ehci-&gt;periodic
(braket
id|frame
)braket
op_assign
id|QH_NEXT
(paren
id|qh-&gt;qh_dma
)paren
suffix:semicolon
)brace
id|frame
op_add_assign
id|period
suffix:semicolon
)brace
r_while
c_loop
(paren
id|frame
OL
id|ehci-&gt;periodic_size
)paren
suffix:semicolon
multiline_comment|/* update bandwidth utilization records (for usbfs) */
id|usb_claim_bandwidth
(paren
id|urb-&gt;dev
comma
id|urb
comma
id|usecs
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* maybe enable periodic schedule processing */
r_if
c_cond
(paren
op_logical_neg
id|ehci-&gt;periodic_urbs
op_increment
)paren
id|enable_periodic
(paren
id|ehci
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
id|frame
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|done
suffix:colon
r_if
c_cond
(paren
id|status
)paren
(brace
id|usb_complete_t
id|complete
op_assign
id|urb-&gt;complete
suffix:semicolon
id|urb-&gt;complete
op_assign
l_int|0
suffix:semicolon
id|urb-&gt;status
op_assign
id|status
suffix:semicolon
id|qh_completions
(paren
id|ehci
comma
id|qtd_list
comma
l_int|1
)paren
suffix:semicolon
id|urb-&gt;complete
op_assign
id|complete
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
r_static
r_int
r_int
DECL|function|intr_complete
id|intr_complete
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_int
id|frame
comma
r_struct
id|ehci_qh
op_star
id|qh
comma
r_int
r_int
id|flags
multiline_comment|/* caller owns ehci-&gt;lock ... */
)paren
(brace
r_struct
id|ehci_qtd
op_star
id|qtd
suffix:semicolon
r_struct
id|urb
op_star
id|urb
suffix:semicolon
r_int
id|unlinking
suffix:semicolon
multiline_comment|/* nothing to report? */
r_if
c_cond
(paren
id|likely
(paren
(paren
id|qh-&gt;hw_token
op_amp
id|__constant_cpu_to_le32
(paren
id|QTD_STS_ACTIVE
)paren
)paren
op_ne
l_int|0
)paren
)paren
r_return
id|flags
suffix:semicolon
id|qtd
op_assign
id|list_entry
(paren
id|qh-&gt;qtd_list.next
comma
r_struct
id|ehci_qtd
comma
id|qtd_list
)paren
suffix:semicolon
id|urb
op_assign
id|qtd-&gt;urb
suffix:semicolon
id|unlinking
op_assign
(paren
id|urb-&gt;status
op_eq
op_minus
id|ENOENT
)paren
op_logical_or
(paren
id|urb-&gt;status
op_eq
op_minus
id|ECONNRESET
)paren
suffix:semicolon
multiline_comment|/* call any completions, after patching for reactivation */
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* NOTE:  currently restricted to one qtd per qh! */
r_if
c_cond
(paren
id|qh_completions
(paren
id|ehci
comma
op_amp
id|qh-&gt;qtd_list
comma
l_int|0
)paren
op_eq
l_int|0
)paren
id|urb
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* never reactivate requests that were unlinked ... */
r_if
c_cond
(paren
id|likely
(paren
id|urb
op_ne
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|unlinking
op_logical_or
id|urb-&gt;status
op_eq
op_minus
id|ECONNRESET
op_logical_or
id|urb-&gt;status
op_eq
op_minus
id|ENOENT
singleline_comment|// || (urb-&gt;dev == null)
op_logical_or
id|ehci-&gt;hcd.state
op_eq
id|USB_STATE_HALT
)paren
id|urb
op_assign
l_int|0
suffix:semicolon
singleline_comment|// FIXME look at all those unlink cases ... we always
singleline_comment|// need exactly one completion that reports unlink.
singleline_comment|// the one above might not have been it!
)brace
multiline_comment|/* normally reactivate */
r_if
c_cond
(paren
id|likely
(paren
id|urb
op_ne
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
)paren
id|pci_dma_sync_single
(paren
id|ehci-&gt;hcd.pdev
comma
id|qtd-&gt;buf_dma
comma
id|urb-&gt;transfer_buffer_length
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
id|urb-&gt;status
op_assign
op_minus
id|EINPROGRESS
suffix:semicolon
id|urb-&gt;actual_length
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* patch qh and restart */
id|qh_update
(paren
id|qh
comma
id|qtd
)paren
suffix:semicolon
)brace
r_return
id|flags
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
r_static
r_void
DECL|function|itd_free_list
id|itd_free_list
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|ehci_itd
op_star
id|first_itd
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
id|pci_unmap_single
(paren
id|ehci-&gt;hcd.pdev
comma
id|first_itd-&gt;buf_dma
comma
id|urb-&gt;transfer_buffer_length
comma
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
ques
c_cond
id|PCI_DMA_FROMDEVICE
suffix:colon
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|first_itd-&gt;itd_list
)paren
)paren
(brace
r_struct
id|ehci_itd
op_star
id|itd
suffix:semicolon
id|itd
op_assign
id|list_entry
(paren
id|first_itd-&gt;itd_list.next
comma
r_struct
id|ehci_itd
comma
id|itd_list
)paren
suffix:semicolon
id|list_del
(paren
op_amp
id|itd-&gt;itd_list
)paren
suffix:semicolon
id|pci_pool_free
(paren
id|ehci-&gt;itd_pool
comma
id|itd
comma
id|itd-&gt;itd_dma
)paren
suffix:semicolon
)brace
id|pci_pool_free
(paren
id|ehci-&gt;itd_pool
comma
id|first_itd
comma
id|first_itd-&gt;itd_dma
)paren
suffix:semicolon
id|urb-&gt;hcpriv
op_assign
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|itd_fill
id|itd_fill
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|ehci_itd
op_star
id|itd
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|index
comma
singleline_comment|// urb-&gt;iso_frame_desc [index]
id|dma_addr_t
id|dma
singleline_comment|// mapped transfer buffer
)paren
(brace
id|u64
id|temp
suffix:semicolon
id|u32
id|buf1
suffix:semicolon
r_int
id|i
comma
id|epnum
comma
id|maxp
comma
id|multi
suffix:semicolon
r_int
id|length
suffix:semicolon
id|itd-&gt;hw_next
op_assign
id|EHCI_LIST_END
suffix:semicolon
id|itd-&gt;urb
op_assign
id|urb
suffix:semicolon
id|itd-&gt;index
op_assign
id|index
suffix:semicolon
multiline_comment|/* tell itd about its transfer buffer, max 2 pages */
id|length
op_assign
id|urb-&gt;iso_frame_desc
(braket
id|index
)braket
dot
id|length
suffix:semicolon
id|dma
op_add_assign
id|urb-&gt;iso_frame_desc
(braket
id|index
)braket
dot
id|offset
suffix:semicolon
id|temp
op_assign
id|dma
op_amp
op_complement
l_int|0x0fff
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
id|itd-&gt;hw_bufp
(braket
id|i
)braket
op_assign
id|cpu_to_le32
(paren
(paren
id|u32
)paren
id|temp
)paren
suffix:semicolon
id|itd-&gt;hw_bufp_hi
(braket
id|i
)braket
op_assign
id|cpu_to_le32
(paren
(paren
id|u32
)paren
(paren
id|temp
op_rshift
l_int|32
)paren
)paren
suffix:semicolon
id|temp
op_add_assign
l_int|0x1000
suffix:semicolon
)brace
id|itd-&gt;buf_dma
op_assign
id|dma
suffix:semicolon
multiline_comment|/*&n;&t; * this might be a &quot;high bandwidth&quot; highspeed endpoint,&n;&t; * as encoded in the ep descriptor&squot;s maxpacket field&n;&t; */
id|epnum
op_assign
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
id|maxp
op_assign
id|urb-&gt;dev-&gt;epmaxpacketin
(braket
id|epnum
)braket
suffix:semicolon
id|buf1
op_assign
(paren
l_int|1
op_lshift
l_int|11
)paren
suffix:semicolon
)brace
r_else
(brace
id|maxp
op_assign
id|urb-&gt;dev-&gt;epmaxpacketout
(braket
id|epnum
)braket
suffix:semicolon
id|buf1
op_assign
l_int|0
suffix:semicolon
)brace
id|buf1
op_or_assign
(paren
id|maxp
op_amp
l_int|0x03ff
)paren
suffix:semicolon
id|multi
op_assign
l_int|1
suffix:semicolon
id|multi
op_add_assign
(paren
id|maxp
op_rshift
l_int|11
)paren
op_amp
l_int|0x03
suffix:semicolon
id|maxp
op_and_assign
l_int|0x03ff
suffix:semicolon
id|maxp
op_mul_assign
id|multi
suffix:semicolon
multiline_comment|/* transfer can&squot;t fit in any uframe? */
r_if
c_cond
(paren
id|length
OL
l_int|0
op_logical_or
id|maxp
OL
id|length
)paren
(brace
id|dbg
(paren
l_string|&quot;BAD iso packet: %d bytes, max %d, urb %p [%d] (of %d)&quot;
comma
id|length
comma
id|maxp
comma
id|urb
comma
id|index
comma
id|urb-&gt;iso_frame_desc
(braket
id|index
)braket
dot
id|length
)paren
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
id|itd-&gt;usecs
op_assign
id|HS_USECS_ISO
(paren
id|length
)paren
suffix:semicolon
multiline_comment|/* &quot;plus&quot; info in low order bits of buffer pointers */
id|itd-&gt;hw_bufp
(braket
l_int|0
)braket
op_or_assign
id|cpu_to_le32
(paren
(paren
id|epnum
op_lshift
l_int|8
)paren
op_or
id|urb-&gt;dev-&gt;devnum
)paren
suffix:semicolon
id|itd-&gt;hw_bufp
(braket
l_int|1
)braket
op_or_assign
id|cpu_to_le32
(paren
id|buf1
)paren
suffix:semicolon
id|itd-&gt;hw_bufp
(braket
l_int|2
)braket
op_or_assign
id|cpu_to_le32
(paren
id|multi
)paren
suffix:semicolon
multiline_comment|/* figure hw_transaction[] value (it&squot;s scheduled later) */
id|itd-&gt;transaction
op_assign
id|EHCI_ISOC_ACTIVE
suffix:semicolon
id|itd-&gt;transaction
op_or_assign
id|dma
op_amp
l_int|0x0fff
suffix:semicolon
multiline_comment|/* offset; buffer=0 */
r_if
c_cond
(paren
(paren
id|index
op_plus
l_int|1
)paren
op_eq
id|urb-&gt;number_of_packets
)paren
id|itd-&gt;transaction
op_or_assign
id|EHCI_ITD_IOC
suffix:semicolon
multiline_comment|/* end-of-urb irq */
id|itd-&gt;transaction
op_or_assign
id|length
op_lshift
l_int|16
suffix:semicolon
id|cpu_to_le32s
(paren
op_amp
id|itd-&gt;transaction
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|itd_urb_transaction
id|itd_urb_transaction
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|mem_flags
)paren
(brace
r_int
id|frame_index
suffix:semicolon
r_struct
id|ehci_itd
op_star
id|first_itd
comma
op_star
id|itd
suffix:semicolon
r_int
id|status
suffix:semicolon
id|dma_addr_t
id|buf_dma
comma
id|itd_dma
suffix:semicolon
multiline_comment|/* set up one dma mapping for this urb */
id|buf_dma
op_assign
id|pci_map_single
(paren
id|ehci-&gt;hcd.pdev
comma
id|urb-&gt;transfer_buffer
comma
id|urb-&gt;transfer_buffer_length
comma
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
ques
c_cond
id|PCI_DMA_FROMDEVICE
suffix:colon
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf_dma
op_eq
l_int|0
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* allocate/init ITDs */
r_for
c_loop
(paren
id|frame_index
op_assign
l_int|0
comma
id|first_itd
op_assign
l_int|0
suffix:semicolon
id|frame_index
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|frame_index
op_increment
)paren
(brace
id|itd
op_assign
id|pci_pool_alloc
(paren
id|ehci-&gt;itd_pool
comma
id|mem_flags
comma
op_amp
id|itd_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|itd
)paren
(brace
id|status
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
id|memset
(paren
id|itd
comma
l_int|0
comma
r_sizeof
op_star
id|itd
)paren
suffix:semicolon
id|itd-&gt;itd_dma
op_assign
id|itd_dma
suffix:semicolon
id|status
op_assign
id|itd_fill
(paren
id|ehci
comma
id|itd
comma
id|urb
comma
id|frame_index
comma
id|buf_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
l_int|0
)paren
r_goto
id|fail
suffix:semicolon
r_if
c_cond
(paren
id|first_itd
)paren
id|list_add_tail
(paren
op_amp
id|itd-&gt;itd_list
comma
op_amp
id|first_itd-&gt;itd_list
)paren
suffix:semicolon
r_else
(brace
id|INIT_LIST_HEAD
(paren
op_amp
id|itd-&gt;itd_list
)paren
suffix:semicolon
id|urb-&gt;hcpriv
op_assign
id|first_itd
op_assign
id|itd
suffix:semicolon
)brace
)brace
id|urb-&gt;error_count
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|fail
suffix:colon
r_if
c_cond
(paren
id|urb-&gt;hcpriv
)paren
id|itd_free_list
(paren
id|ehci
comma
id|urb
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
r_static
r_inline
r_void
DECL|function|itd_link
id|itd_link
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_int
id|frame
comma
r_struct
id|ehci_itd
op_star
id|itd
)paren
(brace
multiline_comment|/* always prepend ITD/SITD ... only QH tree is order-sensitive */
id|itd-&gt;itd_next
op_assign
id|ehci-&gt;pshadow
(braket
id|frame
)braket
suffix:semicolon
id|itd-&gt;hw_next
op_assign
id|ehci-&gt;periodic
(braket
id|frame
)braket
suffix:semicolon
id|ehci-&gt;pshadow
(braket
id|frame
)braket
dot
id|itd
op_assign
id|itd
suffix:semicolon
id|ehci-&gt;periodic
(braket
id|frame
)braket
op_assign
id|cpu_to_le32
(paren
id|itd-&gt;itd_dma
)paren
op_or
id|Q_TYPE_ITD
suffix:semicolon
)brace
multiline_comment|/*&n; * return zero on success, else -errno&n; * - start holds first uframe to start scheduling into&n; * - max is the first uframe it&squot;s NOT (!) OK to start scheduling into&n; * math to be done modulo &quot;mod&quot; (ehci-&gt;periodic_size &lt;&lt; 3)&n; */
DECL|function|get_iso_range
r_static
r_int
id|get_iso_range
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
op_star
id|start
comma
r_int
op_star
id|max
comma
r_int
id|mod
)paren
(brace
r_struct
id|list_head
op_star
id|lh
suffix:semicolon
r_struct
id|hcd_dev
op_star
id|dev
op_assign
id|urb-&gt;dev-&gt;hcpriv
suffix:semicolon
r_int
id|last
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|now
comma
id|span
comma
id|end
suffix:semicolon
id|span
op_assign
id|urb-&gt;interval
op_star
id|urb-&gt;number_of_packets
suffix:semicolon
multiline_comment|/* first see if we know when the next transfer SHOULD happen */
id|list_for_each
(paren
id|lh
comma
op_amp
id|dev-&gt;urb_list
)paren
(brace
r_struct
id|urb
op_star
id|u
suffix:semicolon
r_struct
id|ehci_itd
op_star
id|itd
suffix:semicolon
r_int
id|s
suffix:semicolon
id|u
op_assign
id|list_entry
(paren
id|lh
comma
r_struct
id|urb
comma
id|urb_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|u
op_eq
id|urb
op_logical_or
id|u-&gt;pipe
op_ne
id|urb-&gt;pipe
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|u-&gt;interval
op_ne
id|urb-&gt;interval
)paren
(brace
multiline_comment|/* must not change! */
id|dbg
(paren
l_string|&quot;urb %p interval %d ... != %p interval %d&quot;
comma
id|u
comma
id|u-&gt;interval
comma
id|urb
comma
id|urb-&gt;interval
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* URB for this endpoint... covers through when?  */
id|itd
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
id|s
op_assign
id|itd-&gt;uframe
op_plus
id|u-&gt;interval
op_star
id|u-&gt;number_of_packets
suffix:semicolon
r_if
c_cond
(paren
id|last
OL
l_int|0
)paren
id|last
op_assign
id|s
suffix:semicolon
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * So far we can only queue two ISO URBs...&n;&t;&t;&t; *&n;&t;&t;&t; * FIXME do interval math, figure out whether&n;&t;&t;&t; * this URB is &quot;before&quot; or not ... also, handle&n;&t;&t;&t; * the case where the URB might have completed,&n;&t;&t;&t; * but hasn&squot;t yet been processed.&n;&t;&t;&t; */
id|dbg
(paren
l_string|&quot;NYET: queue &gt;2 URBs per ISO endpoint&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EDOM
suffix:semicolon
)brace
)brace
multiline_comment|/* calculate the legal range [start,max) */
id|now
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;frame_index
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* next uframe */
r_if
c_cond
(paren
op_logical_neg
id|ehci-&gt;periodic_urbs
)paren
id|now
op_add_assign
l_int|8
suffix:semicolon
multiline_comment|/* startup delay */
id|now
op_mod_assign
id|mod
suffix:semicolon
id|end
op_assign
id|now
op_plus
id|mod
suffix:semicolon
r_if
c_cond
(paren
id|last
OL
l_int|0
)paren
(brace
op_star
id|start
op_assign
id|now
op_plus
id|ehci-&gt;i_thresh
op_plus
multiline_comment|/* paranoia */
l_int|1
suffix:semicolon
op_star
id|max
op_assign
id|end
op_minus
id|span
suffix:semicolon
r_if
c_cond
(paren
op_star
id|max
OL
op_star
id|start
op_plus
l_int|1
)paren
op_star
id|max
op_assign
op_star
id|start
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
op_star
id|start
op_assign
id|last
op_mod
id|mod
suffix:semicolon
op_star
id|max
op_assign
(paren
id|last
op_plus
l_int|1
)paren
op_mod
id|mod
suffix:semicolon
)brace
multiline_comment|/* explicit start frame? */
r_if
c_cond
(paren
op_logical_neg
(paren
id|urb-&gt;transfer_flags
op_amp
id|USB_ISO_ASAP
)paren
)paren
(brace
r_int
id|temp
suffix:semicolon
multiline_comment|/* sanity check: must be in range */
id|urb-&gt;start_frame
op_mod_assign
id|ehci-&gt;periodic_size
suffix:semicolon
id|temp
op_assign
id|urb-&gt;start_frame
op_lshift
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|temp
OL
op_star
id|start
)paren
id|temp
op_add_assign
id|mod
suffix:semicolon
r_if
c_cond
(paren
id|temp
OG
op_star
id|max
)paren
r_return
op_minus
id|EDOM
suffix:semicolon
multiline_comment|/* use that explicit start frame */
op_star
id|start
op_assign
id|urb-&gt;start_frame
op_lshift
l_int|3
suffix:semicolon
id|temp
op_add_assign
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|temp
OL
op_star
id|max
)paren
op_star
id|max
op_assign
id|temp
suffix:semicolon
)brace
singleline_comment|// FIXME minimize wraparound to &quot;now&quot; ... insist max+span
singleline_comment|// (and start+span) remains a few frames short of &quot;end&quot;
op_star
id|max
op_mod_assign
id|ehci-&gt;periodic_size
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|start
op_plus
id|span
)paren
OL
id|end
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_minus
id|EFBIG
suffix:semicolon
)brace
r_static
r_int
DECL|function|itd_schedule
id|itd_schedule
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
id|start
comma
id|max
comma
id|i
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|mod
op_assign
id|ehci-&gt;periodic_size
op_lshift
l_int|3
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|i
op_increment
)paren
(brace
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|status
op_assign
op_minus
id|EINPROGRESS
suffix:semicolon
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|actual_length
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|status
op_assign
id|get_iso_range
(paren
id|ehci
comma
id|urb
comma
op_amp
id|start
comma
op_amp
id|max
comma
id|mod
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|status
suffix:semicolon
r_do
(brace
r_int
id|uframe
suffix:semicolon
r_int
id|usecs
suffix:semicolon
r_struct
id|ehci_itd
op_star
id|itd
suffix:semicolon
multiline_comment|/* check schedule: enough space? */
id|itd
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
id|uframe
op_assign
id|start
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|uframe
op_assign
id|start
suffix:semicolon
id|i
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|i
op_increment
comma
id|uframe
op_add_assign
id|urb-&gt;interval
)paren
(brace
id|uframe
op_mod_assign
id|mod
suffix:semicolon
multiline_comment|/* can&squot;t commit more than 80% periodic == 100 usec */
r_if
c_cond
(paren
id|periodic_usecs
(paren
id|ehci
comma
id|uframe
op_rshift
l_int|3
comma
id|uframe
op_amp
l_int|0x7
)paren
OG
(paren
l_int|100
op_minus
id|itd-&gt;usecs
)paren
)paren
(brace
id|itd
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|itd
op_assign
id|list_entry
(paren
id|itd-&gt;itd_list.next
comma
r_struct
id|ehci_itd
comma
id|itd_list
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|itd
)paren
r_continue
suffix:semicolon
multiline_comment|/* that&squot;s where we&squot;ll schedule this! */
id|itd
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
id|urb-&gt;start_frame
op_assign
id|start
op_rshift
l_int|3
suffix:semicolon
id|vdbg
(paren
l_string|&quot;ISO urb %p (%d packets period %d) starting %d.%d&quot;
comma
id|urb
comma
id|urb-&gt;number_of_packets
comma
id|urb-&gt;interval
comma
id|urb-&gt;start_frame
comma
id|start
op_amp
l_int|0x7
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|uframe
op_assign
id|start
comma
id|usecs
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|i
op_increment
comma
id|uframe
op_add_assign
id|urb-&gt;interval
)paren
(brace
id|uframe
op_mod_assign
id|mod
suffix:semicolon
id|itd-&gt;uframe
op_assign
id|uframe
suffix:semicolon
id|itd-&gt;hw_transaction
(braket
id|uframe
op_amp
l_int|0x07
)braket
op_assign
id|itd-&gt;transaction
suffix:semicolon
id|itd_link
(paren
id|ehci
comma
(paren
id|uframe
op_rshift
l_int|3
)paren
op_mod
id|ehci-&gt;periodic_size
comma
id|itd
)paren
suffix:semicolon
id|usecs
op_add_assign
id|itd-&gt;usecs
suffix:semicolon
id|itd
op_assign
id|list_entry
(paren
id|itd-&gt;itd_list.next
comma
r_struct
id|ehci_itd
comma
id|itd_list
)paren
suffix:semicolon
)brace
multiline_comment|/* update bandwidth utilization records (for usbfs) */
multiline_comment|/* FIXME usbcore expects per-frame average, which isn&squot;t&n;&t;&t; * most accurate model... this provides the total claim,&n;&t;&t; * and expects the average to be computed only display.&n;&t;&t; */
id|usb_claim_bandwidth
(paren
id|urb-&gt;dev
comma
id|urb
comma
id|usecs
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* maybe enable periodic schedule processing */
r_if
c_cond
(paren
op_logical_neg
id|ehci-&gt;periodic_urbs
op_increment
)paren
id|enable_periodic
(paren
id|ehci
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|start
op_assign
op_increment
id|start
op_mod
id|mod
)paren
op_ne
id|max
)paren
suffix:semicolon
multiline_comment|/* no room in the schedule */
id|dbg
(paren
l_string|&quot;urb %p, CAN&squot;T SCHEDULE&quot;
comma
id|urb
)paren
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|macro|ISO_ERRS
mdefine_line|#define&t;ISO_ERRS (EHCI_ISOC_BUF_ERR | EHCI_ISOC_BABBLE | EHCI_ISOC_XACTERR)
r_static
r_int
r_int
DECL|function|itd_complete
id|itd_complete
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|ehci_itd
op_star
id|itd
comma
r_int
id|uframe
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|urb
op_star
id|urb
op_assign
id|itd-&gt;urb
suffix:semicolon
r_struct
id|usb_iso_packet_descriptor
op_star
id|desc
suffix:semicolon
id|u32
id|t
suffix:semicolon
multiline_comment|/* update status for this uframe&squot;s transfers */
id|desc
op_assign
op_amp
id|urb-&gt;iso_frame_desc
(braket
id|itd-&gt;index
)braket
suffix:semicolon
id|t
op_assign
id|itd-&gt;hw_transaction
(braket
id|uframe
)braket
suffix:semicolon
id|itd-&gt;hw_transaction
(braket
id|uframe
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|t
op_amp
id|EHCI_ISOC_ACTIVE
)paren
id|desc-&gt;status
op_assign
op_minus
id|EXDEV
suffix:semicolon
r_else
r_if
c_cond
(paren
id|t
op_amp
id|ISO_ERRS
)paren
(brace
id|urb-&gt;error_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|t
op_amp
id|EHCI_ISOC_BUF_ERR
)paren
id|desc-&gt;status
op_assign
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
ques
c_cond
op_minus
id|ENOSR
multiline_comment|/* couldn&squot;t read */
suffix:colon
op_minus
id|ECOMM
suffix:semicolon
multiline_comment|/* couldn&squot;t write */
r_else
r_if
c_cond
(paren
id|t
op_amp
id|EHCI_ISOC_BABBLE
)paren
id|desc-&gt;status
op_assign
op_minus
id|EOVERFLOW
suffix:semicolon
r_else
multiline_comment|/* (t &amp; EHCI_ISOC_XACTERR) */
id|desc-&gt;status
op_assign
op_minus
id|EPROTO
suffix:semicolon
multiline_comment|/* HC need not update length with this error */
r_if
c_cond
(paren
op_logical_neg
(paren
id|t
op_amp
id|EHCI_ISOC_BABBLE
)paren
)paren
id|desc-&gt;actual_length
op_add_assign
id|EHCI_ITD_LENGTH
(paren
id|t
)paren
suffix:semicolon
)brace
r_else
(brace
id|desc-&gt;status
op_assign
l_int|0
suffix:semicolon
id|desc-&gt;actual_length
op_add_assign
id|EHCI_ITD_LENGTH
(paren
id|t
)paren
suffix:semicolon
)brace
id|vdbg
(paren
l_string|&quot;itd %p urb %p packet %d/%d trans %x status %d len %d&quot;
comma
id|itd
comma
id|urb
comma
id|itd-&gt;index
op_plus
l_int|1
comma
id|urb-&gt;number_of_packets
comma
id|t
comma
id|desc-&gt;status
comma
id|desc-&gt;actual_length
)paren
suffix:semicolon
multiline_comment|/* handle completion now? */
r_if
c_cond
(paren
(paren
id|itd-&gt;index
op_plus
l_int|1
)paren
op_ne
id|urb-&gt;number_of_packets
)paren
r_return
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * For now, always give the urb back to the driver ... expect it&n;&t; * to submit a new urb (or resubmit this), and to have another&n;&t; * already queued when un-interrupted transfers are needed.&n;&t; * No, that&squot;s not what OHCI or UHCI are now doing.&n;&t; *&n;&t; * FIXME Revisit the ISO URB model.  It&squot;s cleaner not to have all&n;&t; * the special case magic, but it&squot;d be faster to reuse existing&n;&t; * ITD/DMA setup and schedule state.  Easy to dma_sync/complete(),&n;&t; * then either reschedule or, if unlinking, free and giveback().&n;&t; * But we can&squot;t overcommit like the full and low speed HCs do, and&n;&t; * there&squot;s no clean way to report an error when rescheduling...&n;&t; *&n;&t; * NOTE that for now we don&squot;t accelerate ISO unlinks; they just&n;&t; * happen according to the current schedule.  Means a delay of&n;&t; * up to about a second (max).&n;&t; */
id|itd_free_list
(paren
id|ehci
comma
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
id|urb-&gt;status
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|usb_hcd_giveback_urb
(paren
op_amp
id|ehci-&gt;hcd
comma
id|urb
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* defer stopping schedule; completion can submit */
id|ehci-&gt;periodic_urbs
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ehci-&gt;periodic_urbs
)paren
id|disable_periodic
(paren
id|ehci
)paren
suffix:semicolon
r_return
id|flags
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|itd_submit
r_static
r_int
id|itd_submit
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|mem_flags
)paren
(brace
r_int
id|status
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|dbg
(paren
l_string|&quot;itd_submit urb %p&quot;
comma
id|urb
)paren
suffix:semicolon
multiline_comment|/* NOTE DMA mapping assumes this ... */
r_if
c_cond
(paren
id|urb-&gt;iso_frame_desc
(braket
l_int|0
)braket
dot
id|offset
op_ne
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * NOTE doing this for now, anticipating periodic URB models&n;&t; * get updated to be &quot;explicit resubmit&quot;.&n;&t; */
r_if
c_cond
(paren
id|urb-&gt;next
)paren
(brace
id|dbg
(paren
l_string|&quot;use explicit resubmit for ISO&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* allocate ITDs w/o locking anything */
id|status
op_assign
id|itd_urb_transaction
(paren
id|ehci
comma
id|urb
comma
id|mem_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
r_return
id|status
suffix:semicolon
multiline_comment|/* schedule ... need to lock */
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|status
op_assign
id|itd_schedule
(paren
id|ehci
comma
id|urb
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
id|itd_free_list
(paren
id|ehci
comma
id|urb
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
macro_line|#ifdef have_split_iso
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * &quot;Split ISO TDs&quot; ... used for USB 1.1 devices going through&n; * the TTs in USB 2.0 hubs.&n; */
r_static
r_void
DECL|function|sitd_free
id|sitd_free
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|ehci_sitd
op_star
id|sitd
)paren
(brace
id|pci_pool_free
(paren
id|ehci-&gt;sitd_pool
comma
id|sitd
comma
id|sitd-&gt;sitd_dma
)paren
suffix:semicolon
)brace
r_static
r_struct
id|ehci_sitd
op_star
DECL|function|sitd_make
id|sitd_make
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|index
comma
singleline_comment|// urb-&gt;iso_frame_desc [index]
r_int
id|uframe
comma
singleline_comment|// scheduled start
id|dma_addr_t
id|dma
comma
singleline_comment|// mapped transfer buffer
r_int
id|mem_flags
)paren
(brace
r_struct
id|ehci_sitd
op_star
id|sitd
suffix:semicolon
r_int
id|length
suffix:semicolon
id|sitd
op_assign
id|pci_pool_alloc
(paren
id|ehci-&gt;sitd_pool
comma
id|mem_flags
comma
op_amp
id|dma
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sitd
)paren
r_return
id|sitd
suffix:semicolon
id|sitd-&gt;urb
op_assign
id|urb
suffix:semicolon
id|length
op_assign
id|urb-&gt;iso_frame_desc
(braket
id|index
)braket
dot
id|length
suffix:semicolon
id|dma
op_add_assign
id|urb-&gt;iso_frame_desc
(braket
id|index
)braket
dot
id|offset
suffix:semicolon
macro_line|#if 0
singleline_comment|// FIXME:  do the rest!
macro_line|#else
id|sitd_free
(paren
id|ehci
comma
id|sitd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#endif
)brace
r_static
r_void
DECL|function|sitd_link
id|sitd_link
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_int
id|frame
comma
r_struct
id|ehci_sitd
op_star
id|sitd
)paren
(brace
id|u32
id|ptr
suffix:semicolon
id|ptr
op_assign
id|cpu_to_le32
(paren
id|sitd-&gt;sitd_dma
op_or
l_int|2
)paren
suffix:semicolon
singleline_comment|// type 2 == sitd
r_if
c_cond
(paren
id|ehci-&gt;pshadow
(braket
id|frame
)braket
dot
id|ptr
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sitd-&gt;sitd_next.ptr
)paren
(brace
id|sitd-&gt;sitd_next
op_assign
id|ehci-&gt;pshadow
(braket
id|frame
)braket
suffix:semicolon
id|sitd-&gt;hw_next
op_assign
id|ehci-&gt;periodic
(braket
id|frame
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sitd-&gt;sitd_next.ptr
op_ne
id|ehci-&gt;pshadow
(braket
id|frame
)braket
dot
id|ptr
)paren
(brace
id|dbg
(paren
l_string|&quot;frame %d sitd link goof&quot;
comma
id|frame
)paren
suffix:semicolon
id|BUG
(paren
)paren
suffix:semicolon
)brace
)brace
id|ehci-&gt;pshadow
(braket
id|frame
)braket
dot
id|sitd
op_assign
id|sitd
suffix:semicolon
id|ehci-&gt;periodic
(braket
id|frame
)braket
op_assign
id|ptr
suffix:semicolon
)brace
r_static
r_int
r_int
DECL|function|sitd_complete
id|sitd_complete
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|ehci_sitd
op_star
id|sitd
comma
r_int
r_int
id|flags
)paren
(brace
singleline_comment|// FIXME -- implement!
id|dbg
(paren
l_string|&quot;NYI -- sitd_complete&quot;
)paren
suffix:semicolon
r_return
id|flags
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|sitd_submit
r_static
r_int
id|sitd_submit
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|mem_flags
)paren
(brace
singleline_comment|// struct ehci_sitd&t;*first_sitd = 0;
r_int
id|frame_index
suffix:semicolon
id|dma_addr_t
id|dma
suffix:semicolon
id|dbg
(paren
l_string|&quot;NYI -- sitd_submit&quot;
)paren
suffix:semicolon
singleline_comment|// FIXME -- implement!
singleline_comment|// FIXME:  setup one big dma mapping
id|dma
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|frame_index
op_assign
l_int|0
suffix:semicolon
id|frame_index
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|frame_index
op_increment
)paren
(brace
r_struct
id|ehci_sitd
op_star
id|sitd
suffix:semicolon
r_int
id|uframe
suffix:semicolon
singleline_comment|// FIXME:  use real arguments, schedule this!
id|uframe
op_assign
op_minus
l_int|1
suffix:semicolon
id|sitd
op_assign
id|sitd_make
(paren
id|ehci
comma
id|urb
comma
id|frame_index
comma
id|uframe
comma
id|dma
comma
id|mem_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sitd
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;if (first_sitd)&n;&t;&t;&t;&t;list_add_tail (&amp;sitd-&gt;sitd_list,&n;&t;&t;&t;&t;&t;&t;&amp;first_sitd-&gt;sitd_list);&n;&t;&t;&t;else&n;&t;&t;&t;&t;first_sitd = sitd;&n;    */
)brace
r_else
(brace
singleline_comment|// FIXME:  clean everything up
)brace
)brace
singleline_comment|// if we have a first sitd, then
singleline_comment|// store them all into the periodic schedule!
singleline_comment|// urb-&gt;hcpriv = first sitd in sitd_list
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
macro_line|#endif /* have_split_iso */
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|scan_periodic
r_static
r_void
id|scan_periodic
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
)paren
(brace
r_int
id|frame
comma
id|clock
comma
id|now_uframe
comma
id|mod
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|mod
op_assign
id|ehci-&gt;periodic_size
op_lshift
l_int|3
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * When running, scan from last scan point up to &quot;now&quot;&n;&t; * else clean up by scanning everything that&squot;s left.&n;&t; * Touches as few pages as possible:  cache-friendly.&n;&t; * Don&squot;t scan ISO entries more than once, though.&n;&t; */
id|frame
op_assign
id|ehci-&gt;next_uframe
op_rshift
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|HCD_IS_RUNNING
(paren
id|ehci-&gt;hcd.state
)paren
)paren
id|now_uframe
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;frame_index
)paren
suffix:semicolon
r_else
id|now_uframe
op_assign
(paren
id|frame
op_lshift
l_int|3
)paren
op_minus
l_int|1
suffix:semicolon
id|now_uframe
op_mod_assign
id|mod
suffix:semicolon
id|clock
op_assign
id|now_uframe
op_rshift
l_int|3
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_union
id|ehci_shadow
id|q
comma
op_star
id|q_p
suffix:semicolon
id|u32
id|type
comma
op_star
id|hw_p
suffix:semicolon
r_int
id|uframes
suffix:semicolon
id|restart
suffix:colon
multiline_comment|/* scan schedule to _before_ current frame index */
r_if
c_cond
(paren
id|frame
op_eq
id|clock
)paren
id|uframes
op_assign
id|now_uframe
op_amp
l_int|0x07
suffix:semicolon
r_else
id|uframes
op_assign
l_int|8
suffix:semicolon
id|q_p
op_assign
op_amp
id|ehci-&gt;pshadow
(braket
id|frame
)braket
suffix:semicolon
id|hw_p
op_assign
op_amp
id|ehci-&gt;periodic
(braket
id|frame
)braket
suffix:semicolon
id|q.ptr
op_assign
id|q_p-&gt;ptr
suffix:semicolon
id|type
op_assign
id|Q_NEXT_TYPE
(paren
op_star
id|hw_p
)paren
suffix:semicolon
multiline_comment|/* scan each element in frame&squot;s queue for completions */
r_while
c_loop
(paren
id|q.ptr
op_ne
l_int|0
)paren
(brace
r_int
id|last
suffix:semicolon
r_int
id|uf
suffix:semicolon
r_union
id|ehci_shadow
id|temp
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|Q_TYPE_QH
suffix:colon
id|last
op_assign
(paren
id|q.qh-&gt;hw_next
op_eq
id|EHCI_LIST_END
)paren
suffix:semicolon
id|temp
op_assign
id|q.qh-&gt;qh_next
suffix:semicolon
id|type
op_assign
id|Q_NEXT_TYPE
(paren
id|q.qh-&gt;hw_next
)paren
suffix:semicolon
id|flags
op_assign
id|intr_complete
(paren
id|ehci
comma
id|frame
comma
id|qh_get
(paren
id|q.qh
)paren
comma
id|flags
)paren
suffix:semicolon
id|qh_put
(paren
id|ehci
comma
id|q.qh
)paren
suffix:semicolon
id|q
op_assign
id|temp
suffix:semicolon
r_break
suffix:semicolon
r_case
id|Q_TYPE_FSTN
suffix:colon
id|last
op_assign
(paren
id|q.fstn-&gt;hw_next
op_eq
id|EHCI_LIST_END
)paren
suffix:semicolon
multiline_comment|/* for &quot;save place&quot; FSTNs, look at QH entries&n;&t;&t;&t;&t; * in the previous frame for completions.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|q.fstn-&gt;hw_prev
op_ne
id|EHCI_LIST_END
)paren
(brace
id|dbg
(paren
l_string|&quot;ignoring completions from FSTNs&quot;
)paren
suffix:semicolon
)brace
id|type
op_assign
id|Q_NEXT_TYPE
(paren
id|q.fstn-&gt;hw_next
)paren
suffix:semicolon
id|q
op_assign
id|q.fstn-&gt;fstn_next
suffix:semicolon
r_break
suffix:semicolon
r_case
id|Q_TYPE_ITD
suffix:colon
id|last
op_assign
(paren
id|q.itd-&gt;hw_next
op_eq
id|EHCI_LIST_END
)paren
suffix:semicolon
multiline_comment|/* Unlink each (S)ITD we see, since the ISO&n;&t;&t;&t;&t; * URB model forces constant rescheduling.&n;&t;&t;&t;&t; * That complicates sharing uframes in ITDs,&n;&t;&t;&t;&t; * and means we need to skip uframes the HC&n;&t;&t;&t;&t; * hasn&squot;t yet processed.&n;&t;&t;&t;&t; */
r_for
c_loop
(paren
id|uf
op_assign
l_int|0
suffix:semicolon
id|uf
OL
id|uframes
suffix:semicolon
id|uf
op_increment
)paren
(brace
r_if
c_cond
(paren
id|q.itd-&gt;hw_transaction
(braket
id|uf
)braket
op_ne
l_int|0
)paren
(brace
id|temp
op_assign
id|q
suffix:semicolon
op_star
id|q_p
op_assign
id|q.itd-&gt;itd_next
suffix:semicolon
op_star
id|hw_p
op_assign
id|q.itd-&gt;hw_next
suffix:semicolon
id|type
op_assign
id|Q_NEXT_TYPE
(paren
op_star
id|hw_p
)paren
suffix:semicolon
multiline_comment|/* might free q.itd ... */
id|flags
op_assign
id|itd_complete
(paren
id|ehci
comma
id|temp.itd
comma
id|uf
comma
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* we might skip this ITD&squot;s uframe ... */
r_if
c_cond
(paren
id|uf
op_eq
id|uframes
)paren
(brace
id|q_p
op_assign
op_amp
id|q.itd-&gt;itd_next
suffix:semicolon
id|hw_p
op_assign
op_amp
id|q.itd-&gt;hw_next
suffix:semicolon
id|type
op_assign
id|Q_NEXT_TYPE
(paren
id|q.itd-&gt;hw_next
)paren
suffix:semicolon
)brace
id|q
op_assign
op_star
id|q_p
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef have_split_iso
r_case
id|Q_TYPE_SITD
suffix:colon
id|last
op_assign
(paren
id|q.sitd-&gt;hw_next
op_eq
id|EHCI_LIST_END
)paren
suffix:semicolon
id|flags
op_assign
id|sitd_complete
(paren
id|ehci
comma
id|q.sitd
comma
id|flags
)paren
suffix:semicolon
id|type
op_assign
id|Q_NEXT_TYPE
(paren
id|q.sitd-&gt;hw_next
)paren
suffix:semicolon
singleline_comment|// FIXME unlink SITD after split completes
id|q
op_assign
id|q.sitd-&gt;sitd_next
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /* have_split_iso */
r_default
suffix:colon
id|dbg
(paren
l_string|&quot;corrupt type %d frame %d shadow %p&quot;
comma
id|type
comma
id|frame
comma
id|q.ptr
)paren
suffix:semicolon
singleline_comment|// BUG ();
id|last
op_assign
l_int|1
suffix:semicolon
id|q.ptr
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* did completion remove an interior q entry? */
r_if
c_cond
(paren
id|unlikely
(paren
id|q.ptr
op_eq
l_int|0
op_logical_and
op_logical_neg
id|last
)paren
)paren
r_goto
id|restart
suffix:semicolon
)brace
multiline_comment|/* stop when we catch up to the HC */
singleline_comment|// FIXME:  this assumes we won&squot;t get lapped when
singleline_comment|// latencies climb; that should be rare, but...
singleline_comment|// detect it, and just go all the way around.
singleline_comment|// FLR might help detect this case, so long as latencies
singleline_comment|// don&squot;t exceed periodic_size msec (default 1.024 sec).
singleline_comment|// FIXME:  likewise assumes HC doesn&squot;t halt mid-scan
r_if
c_cond
(paren
id|frame
op_eq
id|clock
)paren
(brace
r_int
id|now
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|HCD_IS_RUNNING
(paren
id|ehci-&gt;hcd.state
)paren
)paren
r_break
suffix:semicolon
id|ehci-&gt;next_uframe
op_assign
id|now_uframe
suffix:semicolon
id|now
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;frame_index
)paren
op_mod
id|mod
suffix:semicolon
r_if
c_cond
(paren
id|now_uframe
op_eq
id|now
)paren
r_break
suffix:semicolon
multiline_comment|/* rescan the rest of this frame, then ... */
id|now_uframe
op_assign
id|now
suffix:semicolon
id|clock
op_assign
id|now_uframe
op_rshift
l_int|3
suffix:semicolon
)brace
r_else
id|frame
op_assign
(paren
id|frame
op_plus
l_int|1
)paren
op_mod
id|ehci-&gt;periodic_size
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
eof
