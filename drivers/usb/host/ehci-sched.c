multiline_comment|/*&n; * Copyright (c) 2001-2003 by David Brownell&n; * Copyright (c) 2003 Michal Sojka, for high-speed iso transfers&n; * &n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2 of the License, or (at your&n; * option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY&n; * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License&n; * for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software Foundation,&n; * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
multiline_comment|/* this file is part of ehci-hcd.c */
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * EHCI scheduled transaction support:  interrupt, iso, split iso&n; * These are called &quot;periodic&quot; transactions in the EHCI spec.&n; *&n; * Note that for interrupt transfers, the QH/QTD manipulation is shared&n; * with the &quot;asynchronous&quot; transaction support (control/bulk transfers).&n; * The only real difference is in how interrupt transfers are scheduled.&n; *&n; * For ISO, we make an &quot;iso_stream&quot; head to serve the same role as a QH.&n; * It keeps track of every ITD (or SITD) that&squot;s linked, and holds enough&n; * pre-calculated schedule data to make appending to the queue be quick.&n; */
r_static
r_int
id|ehci_get_frame
(paren
r_struct
id|usb_hcd
op_star
id|hcd
)paren
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * periodic_next_shadow - return &quot;next&quot; pointer on shadow list&n; * @periodic: host pointer to qh/itd/sitd&n; * @tag: hardware tag for type of this record&n; */
r_static
r_union
id|ehci_shadow
op_star
DECL|function|periodic_next_shadow
id|periodic_next_shadow
(paren
r_union
id|ehci_shadow
op_star
id|periodic
comma
id|__le32
id|tag
)paren
(brace
r_switch
c_cond
(paren
id|tag
)paren
(brace
r_case
id|Q_TYPE_QH
suffix:colon
r_return
op_amp
id|periodic-&gt;qh-&gt;qh_next
suffix:semicolon
r_case
id|Q_TYPE_FSTN
suffix:colon
r_return
op_amp
id|periodic-&gt;fstn-&gt;fstn_next
suffix:semicolon
r_case
id|Q_TYPE_ITD
suffix:colon
r_return
op_amp
id|periodic-&gt;itd-&gt;itd_next
suffix:semicolon
singleline_comment|// case Q_TYPE_SITD:
r_default
suffix:colon
r_return
op_amp
id|periodic-&gt;sitd-&gt;sitd_next
suffix:semicolon
)brace
)brace
multiline_comment|/* returns true after successful unlink */
multiline_comment|/* caller must hold ehci-&gt;lock */
DECL|function|periodic_unlink
r_static
r_int
id|periodic_unlink
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_int
id|frame
comma
r_void
op_star
id|ptr
)paren
(brace
r_union
id|ehci_shadow
op_star
id|prev_p
op_assign
op_amp
id|ehci-&gt;pshadow
(braket
id|frame
)braket
suffix:semicolon
id|__le32
op_star
id|hw_p
op_assign
op_amp
id|ehci-&gt;periodic
(braket
id|frame
)braket
suffix:semicolon
r_union
id|ehci_shadow
id|here
op_assign
op_star
id|prev_p
suffix:semicolon
r_union
id|ehci_shadow
op_star
id|next_p
suffix:semicolon
multiline_comment|/* find predecessor of &quot;ptr&quot;; hw and shadow lists are in sync */
r_while
c_loop
(paren
id|here.ptr
op_logical_and
id|here.ptr
op_ne
id|ptr
)paren
(brace
id|prev_p
op_assign
id|periodic_next_shadow
(paren
id|prev_p
comma
id|Q_NEXT_TYPE
(paren
op_star
id|hw_p
)paren
)paren
suffix:semicolon
id|hw_p
op_assign
op_amp
id|here.qh-&gt;hw_next
suffix:semicolon
id|here
op_assign
op_star
id|prev_p
suffix:semicolon
)brace
multiline_comment|/* an interrupt entry (at list end) could have been shared */
r_if
c_cond
(paren
op_logical_neg
id|here.ptr
)paren
(brace
id|dbg
(paren
l_string|&quot;entry %p no longer on frame [%d]&quot;
comma
id|ptr
comma
id|frame
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|// vdbg (&quot;periodic unlink %p from frame %d&quot;, ptr, frame);
multiline_comment|/* update hardware list ... HC may still know the old structure, so&n;&t; * don&squot;t change hw_next until it&squot;ll have purged its cache&n;&t; */
id|next_p
op_assign
id|periodic_next_shadow
(paren
op_amp
id|here
comma
id|Q_NEXT_TYPE
(paren
op_star
id|hw_p
)paren
)paren
suffix:semicolon
op_star
id|hw_p
op_assign
id|here.qh-&gt;hw_next
suffix:semicolon
multiline_comment|/* unlink from shadow list; HCD won&squot;t see old structure again */
op_star
id|prev_p
op_assign
op_star
id|next_p
suffix:semicolon
id|next_p-&gt;ptr
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* how many of the uframe&squot;s 125 usecs are allocated? */
r_static
r_int
r_int
DECL|function|periodic_usecs
id|periodic_usecs
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_int
id|frame
comma
r_int
id|uframe
)paren
(brace
id|__le32
op_star
id|hw_p
op_assign
op_amp
id|ehci-&gt;periodic
(braket
id|frame
)braket
suffix:semicolon
r_union
id|ehci_shadow
op_star
id|q
op_assign
op_amp
id|ehci-&gt;pshadow
(braket
id|frame
)braket
suffix:semicolon
r_int
id|usecs
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|q-&gt;ptr
)paren
(brace
r_switch
c_cond
(paren
id|Q_NEXT_TYPE
(paren
op_star
id|hw_p
)paren
)paren
(brace
r_case
id|Q_TYPE_QH
suffix:colon
multiline_comment|/* is it in the S-mask? */
r_if
c_cond
(paren
id|q-&gt;qh-&gt;hw_info2
op_amp
id|cpu_to_le32
(paren
l_int|1
op_lshift
id|uframe
)paren
)paren
id|usecs
op_add_assign
id|q-&gt;qh-&gt;usecs
suffix:semicolon
multiline_comment|/* ... or C-mask? */
r_if
c_cond
(paren
id|q-&gt;qh-&gt;hw_info2
op_amp
id|cpu_to_le32
(paren
l_int|1
op_lshift
(paren
l_int|8
op_plus
id|uframe
)paren
)paren
)paren
id|usecs
op_add_assign
id|q-&gt;qh-&gt;c_usecs
suffix:semicolon
id|hw_p
op_assign
op_amp
id|q-&gt;qh-&gt;hw_next
suffix:semicolon
id|q
op_assign
op_amp
id|q-&gt;qh-&gt;qh_next
suffix:semicolon
r_break
suffix:semicolon
r_case
id|Q_TYPE_FSTN
suffix:colon
multiline_comment|/* for &quot;save place&quot; FSTNs, count the relevant INTR&n;&t;&t;&t; * bandwidth from the previous frame&n;&t;&t;&t; */
r_if
c_cond
(paren
id|q-&gt;fstn-&gt;hw_prev
op_ne
id|EHCI_LIST_END
)paren
(brace
id|ehci_dbg
(paren
id|ehci
comma
l_string|&quot;ignoring FSTN cost ...&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|hw_p
op_assign
op_amp
id|q-&gt;fstn-&gt;hw_next
suffix:semicolon
id|q
op_assign
op_amp
id|q-&gt;fstn-&gt;fstn_next
suffix:semicolon
r_break
suffix:semicolon
r_case
id|Q_TYPE_ITD
suffix:colon
id|usecs
op_add_assign
id|q-&gt;itd-&gt;usecs
(braket
id|uframe
)braket
suffix:semicolon
id|hw_p
op_assign
op_amp
id|q-&gt;itd-&gt;hw_next
suffix:semicolon
id|q
op_assign
op_amp
id|q-&gt;itd-&gt;itd_next
suffix:semicolon
r_break
suffix:semicolon
r_case
id|Q_TYPE_SITD
suffix:colon
multiline_comment|/* is it in the S-mask?  (count SPLIT, DATA) */
r_if
c_cond
(paren
id|q-&gt;sitd-&gt;hw_uframe
op_amp
id|cpu_to_le32
(paren
l_int|1
op_lshift
id|uframe
)paren
)paren
(brace
r_if
c_cond
(paren
id|q-&gt;sitd-&gt;hw_fullspeed_ep
op_amp
id|__constant_cpu_to_le32
(paren
l_int|1
op_lshift
l_int|31
)paren
)paren
id|usecs
op_add_assign
id|q-&gt;sitd-&gt;stream-&gt;usecs
suffix:semicolon
r_else
multiline_comment|/* worst case for OUT start-split */
id|usecs
op_add_assign
id|HS_USECS_ISO
(paren
l_int|188
)paren
suffix:semicolon
)brace
multiline_comment|/* ... C-mask?  (count CSPLIT, DATA) */
r_if
c_cond
(paren
id|q-&gt;sitd-&gt;hw_uframe
op_amp
id|cpu_to_le32
(paren
l_int|1
op_lshift
(paren
l_int|8
op_plus
id|uframe
)paren
)paren
)paren
(brace
multiline_comment|/* worst case for IN complete-split */
id|usecs
op_add_assign
id|q-&gt;sitd-&gt;stream-&gt;c_usecs
suffix:semicolon
)brace
id|hw_p
op_assign
op_amp
id|q-&gt;sitd-&gt;hw_next
suffix:semicolon
id|q
op_assign
op_amp
id|q-&gt;sitd-&gt;sitd_next
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
(paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef&t;DEBUG
r_if
c_cond
(paren
id|usecs
OG
l_int|100
)paren
id|err
(paren
l_string|&quot;overallocated uframe %d, periodic is %d usecs&quot;
comma
id|frame
op_star
l_int|8
op_plus
id|uframe
comma
id|usecs
)paren
suffix:semicolon
macro_line|#endif
r_return
id|usecs
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|same_tt
r_static
r_int
id|same_tt
(paren
r_struct
id|usb_device
op_star
id|dev1
comma
r_struct
id|usb_device
op_star
id|dev2
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dev1-&gt;tt
op_logical_or
op_logical_neg
id|dev2-&gt;tt
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dev1-&gt;tt
op_ne
id|dev2-&gt;tt
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dev1-&gt;tt-&gt;multi
)paren
r_return
id|dev1-&gt;ttport
op_eq
id|dev2-&gt;ttport
suffix:semicolon
r_else
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* return true iff the device&squot;s transaction translator is available&n; * for a periodic transfer starting at the specified frame, using&n; * all the uframes in the mask.&n; */
DECL|function|tt_no_collision
r_static
r_int
id|tt_no_collision
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_int
id|period
comma
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|frame
comma
id|u32
id|uf_mask
)paren
(brace
r_if
c_cond
(paren
id|period
op_eq
l_int|0
)paren
multiline_comment|/* error */
r_return
l_int|0
suffix:semicolon
multiline_comment|/* note bandwidth wastage:  split never follows csplit&n;&t; * (different dev or endpoint) until the next uframe.&n;&t; * calling convention doesn&squot;t make that distinction.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|frame
OL
id|ehci-&gt;periodic_size
suffix:semicolon
id|frame
op_add_assign
id|period
)paren
(brace
r_union
id|ehci_shadow
id|here
suffix:semicolon
id|__le32
id|type
suffix:semicolon
id|here
op_assign
id|ehci-&gt;pshadow
(braket
id|frame
)braket
suffix:semicolon
id|type
op_assign
id|Q_NEXT_TYPE
(paren
id|ehci-&gt;periodic
(braket
id|frame
)braket
)paren
suffix:semicolon
r_while
c_loop
(paren
id|here.ptr
)paren
(brace
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|Q_TYPE_ITD
suffix:colon
id|type
op_assign
id|Q_NEXT_TYPE
(paren
id|here.itd-&gt;hw_next
)paren
suffix:semicolon
id|here
op_assign
id|here.itd-&gt;itd_next
suffix:semicolon
r_continue
suffix:semicolon
r_case
id|Q_TYPE_QH
suffix:colon
r_if
c_cond
(paren
id|same_tt
(paren
id|dev
comma
id|here.qh-&gt;dev
)paren
)paren
(brace
id|u32
id|mask
suffix:semicolon
id|mask
op_assign
id|le32_to_cpu
(paren
id|here.qh-&gt;hw_info2
)paren
suffix:semicolon
multiline_comment|/* &quot;knows&quot; no gap is needed */
id|mask
op_or_assign
id|mask
op_rshift
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
id|uf_mask
)paren
r_break
suffix:semicolon
)brace
id|type
op_assign
id|Q_NEXT_TYPE
(paren
id|here.qh-&gt;hw_next
)paren
suffix:semicolon
id|here
op_assign
id|here.qh-&gt;qh_next
suffix:semicolon
r_continue
suffix:semicolon
r_case
id|Q_TYPE_SITD
suffix:colon
r_if
c_cond
(paren
id|same_tt
(paren
id|dev
comma
id|here.itd-&gt;urb-&gt;dev
)paren
)paren
(brace
id|u16
id|mask
suffix:semicolon
id|mask
op_assign
id|le32_to_cpu
(paren
id|here.sitd
op_member_access_from_pointer
id|hw_uframe
)paren
suffix:semicolon
multiline_comment|/* FIXME assumes no gap for IN! */
id|mask
op_or_assign
id|mask
op_rshift
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
id|uf_mask
)paren
r_break
suffix:semicolon
)brace
id|type
op_assign
id|Q_NEXT_TYPE
(paren
id|here.qh-&gt;hw_next
)paren
suffix:semicolon
id|here
op_assign
id|here.sitd-&gt;sitd_next
suffix:semicolon
r_continue
suffix:semicolon
singleline_comment|// case Q_TYPE_FSTN:
r_default
suffix:colon
id|ehci_dbg
(paren
id|ehci
comma
l_string|&quot;periodic frame %d bogus type %d&bslash;n&quot;
comma
id|frame
comma
id|type
)paren
suffix:semicolon
)brace
multiline_comment|/* collision or error */
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* no collision */
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|enable_periodic
r_static
r_int
id|enable_periodic
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
)paren
(brace
id|u32
id|cmd
suffix:semicolon
r_int
id|status
suffix:semicolon
multiline_comment|/* did clearing PSE did take effect yet?&n;&t; * takes effect only at frame boundaries...&n;&t; */
id|status
op_assign
id|handshake
(paren
op_amp
id|ehci-&gt;regs-&gt;status
comma
id|STS_PSS
comma
l_int|0
comma
l_int|9
op_star
l_int|125
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
l_int|0
)paren
(brace
id|ehci-&gt;hcd.state
op_assign
id|USB_STATE_HALT
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
id|cmd
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
op_or
id|CMD_PSE
suffix:semicolon
id|writel
(paren
id|cmd
comma
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
multiline_comment|/* posted write ... PSS happens later */
id|ehci-&gt;hcd.state
op_assign
id|USB_STATE_RUNNING
suffix:semicolon
multiline_comment|/* make sure ehci_work scans these */
id|ehci-&gt;next_uframe
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;frame_index
)paren
op_mod
(paren
id|ehci-&gt;periodic_size
op_lshift
l_int|3
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|disable_periodic
r_static
r_int
id|disable_periodic
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
)paren
(brace
id|u32
id|cmd
suffix:semicolon
r_int
id|status
suffix:semicolon
multiline_comment|/* did setting PSE not take effect yet?&n;&t; * takes effect only at frame boundaries...&n;&t; */
id|status
op_assign
id|handshake
(paren
op_amp
id|ehci-&gt;regs-&gt;status
comma
id|STS_PSS
comma
id|STS_PSS
comma
l_int|9
op_star
l_int|125
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
l_int|0
)paren
(brace
id|ehci-&gt;hcd.state
op_assign
id|USB_STATE_HALT
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
id|cmd
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
op_amp
op_complement
id|CMD_PSE
suffix:semicolon
id|writel
(paren
id|cmd
comma
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
multiline_comment|/* posted write ... */
id|ehci-&gt;next_uframe
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
singleline_comment|// FIXME microframe periods not yet handled
DECL|function|intr_deschedule
r_static
r_void
id|intr_deschedule
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|ehci_qh
op_star
id|qh
comma
r_int
id|wait
)paren
(brace
r_int
id|status
suffix:semicolon
r_int
id|frame
op_assign
id|qh-&gt;start
suffix:semicolon
r_do
(brace
id|periodic_unlink
(paren
id|ehci
comma
id|frame
comma
id|qh
)paren
suffix:semicolon
id|qh_put
(paren
id|qh
)paren
suffix:semicolon
id|frame
op_add_assign
id|qh-&gt;period
suffix:semicolon
)brace
r_while
c_loop
(paren
id|frame
OL
id|ehci-&gt;periodic_size
)paren
suffix:semicolon
id|qh-&gt;qh_state
op_assign
id|QH_STATE_UNLINK
suffix:semicolon
id|qh-&gt;qh_next.ptr
op_assign
l_int|NULL
suffix:semicolon
id|ehci-&gt;periodic_sched
op_decrement
suffix:semicolon
multiline_comment|/* maybe turn off periodic schedule */
r_if
c_cond
(paren
op_logical_neg
id|ehci-&gt;periodic_sched
)paren
id|status
op_assign
id|disable_periodic
(paren
id|ehci
)paren
suffix:semicolon
r_else
(brace
id|status
op_assign
l_int|0
suffix:semicolon
id|ehci_vdbg
(paren
id|ehci
comma
l_string|&quot;periodic schedule still enabled&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the hc may be looking at this qh, then delay a uframe&n;&t; * (yeech!) to be sure it&squot;s done.&n;&t; * No other threads may be mucking with this qh.&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|ehci_get_frame
(paren
op_amp
id|ehci-&gt;hcd
)paren
op_minus
id|frame
)paren
op_mod
id|qh-&gt;period
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|wait
)paren
(brace
id|udelay
(paren
l_int|125
)paren
suffix:semicolon
id|qh-&gt;hw_next
op_assign
id|EHCI_LIST_END
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* we may not be IDLE yet, but if the qh is empty&n;&t;&t;&t; * the race is very short.  then if qh also isn&squot;t&n;&t;&t;&t; * rescheduled soon, it won&squot;t matter.  otherwise...&n;&t;&t;&t; */
id|ehci_vdbg
(paren
id|ehci
comma
l_string|&quot;intr_deschedule...&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
id|qh-&gt;hw_next
op_assign
id|EHCI_LIST_END
suffix:semicolon
id|qh-&gt;qh_state
op_assign
id|QH_STATE_IDLE
suffix:semicolon
multiline_comment|/* update per-qh bandwidth utilization (for usbfs) */
id|hcd_to_bus
(paren
op_amp
id|ehci-&gt;hcd
)paren
op_member_access_from_pointer
id|bandwidth_allocated
op_sub_assign
(paren
id|qh-&gt;usecs
op_plus
id|qh-&gt;c_usecs
)paren
op_div
id|qh-&gt;period
suffix:semicolon
id|ehci_dbg
(paren
id|ehci
comma
l_string|&quot;descheduled qh%d/%p frame=%d count=%d, urbs=%d&bslash;n&quot;
comma
id|qh-&gt;period
comma
id|qh
comma
id|frame
comma
id|atomic_read
(paren
op_amp
id|qh-&gt;kref.refcount
)paren
comma
id|ehci-&gt;periodic_sched
)paren
suffix:semicolon
)brace
DECL|function|check_period
r_static
r_int
id|check_period
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_int
id|frame
comma
r_int
id|uframe
comma
r_int
id|period
comma
r_int
id|usecs
)paren
(brace
multiline_comment|/* complete split running into next frame?&n;&t; * given FSTN support, we could sometimes check...&n;&t; */
r_if
c_cond
(paren
id|uframe
op_ge
l_int|8
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * 80% periodic == 100 usec/uframe available&n;&t; * convert &quot;usecs we need&quot; to &quot;max already claimed&quot; &n;&t; */
id|usecs
op_assign
l_int|100
op_minus
id|usecs
suffix:semicolon
r_do
(brace
r_int
id|claimed
suffix:semicolon
singleline_comment|// FIXME delete when intr_submit handles non-empty queues
singleline_comment|// this gives us a one intr/frame limit (vs N/uframe)
singleline_comment|// ... and also lets us avoid tracking split transactions
singleline_comment|// that might collide at a given TT/hub.
r_if
c_cond
(paren
id|ehci-&gt;pshadow
(braket
id|frame
)braket
dot
id|ptr
)paren
r_return
l_int|0
suffix:semicolon
id|claimed
op_assign
id|periodic_usecs
(paren
id|ehci
comma
id|frame
comma
id|uframe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|claimed
OG
id|usecs
)paren
r_return
l_int|0
suffix:semicolon
singleline_comment|// FIXME update to handle sub-frame periods
)brace
r_while
c_loop
(paren
(paren
id|frame
op_add_assign
id|period
)paren
OL
id|ehci-&gt;periodic_size
)paren
suffix:semicolon
singleline_comment|// success!
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|check_intr_schedule
r_static
r_int
id|check_intr_schedule
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_int
id|frame
comma
r_int
id|uframe
comma
r_const
r_struct
id|ehci_qh
op_star
id|qh
comma
id|__le32
op_star
id|c_maskp
)paren
(brace
r_int
id|retval
op_assign
op_minus
id|ENOSPC
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|check_period
(paren
id|ehci
comma
id|frame
comma
id|uframe
comma
id|qh-&gt;period
comma
id|qh-&gt;usecs
)paren
)paren
r_goto
id|done
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|qh-&gt;c_usecs
)paren
(brace
id|retval
op_assign
l_int|0
suffix:semicolon
op_star
id|c_maskp
op_assign
l_int|0
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/* This is a split transaction; check the bandwidth available for&n;&t; * the completion too.  Check both worst and best case gaps: worst&n;&t; * case is SPLIT near uframe end, and CSPLIT near start ... best is&n;&t; * vice versa.  Difference can be almost two uframe times, but we&n;&t; * reserve unnecessary bandwidth (waste it) this way.  (Actually&n;&t; * even better cases exist, like immediate device NAK.)&n;&t; *&n;&t; * FIXME don&squot;t even bother unless we know this TT is idle in that&n;&t; * range of uframes ... for now, check_period() allows only one&n;&t; * interrupt transfer per frame, so needn&squot;t check &quot;TT busy&quot; status&n;&t; * when scheduling a split (QH, SITD, or FSTN).&n;&t; *&n;&t; * FIXME ehci 0.96 and above can use FSTNs&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|check_period
(paren
id|ehci
comma
id|frame
comma
id|uframe
op_plus
id|qh-&gt;gap_uf
op_plus
l_int|1
comma
id|qh-&gt;period
comma
id|qh-&gt;c_usecs
)paren
)paren
r_goto
id|done
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|check_period
(paren
id|ehci
comma
id|frame
comma
id|uframe
op_plus
id|qh-&gt;gap_uf
comma
id|qh-&gt;period
comma
id|qh-&gt;c_usecs
)paren
)paren
r_goto
id|done
suffix:semicolon
op_star
id|c_maskp
op_assign
id|cpu_to_le32
(paren
l_int|0x03
op_lshift
(paren
l_int|8
op_plus
id|uframe
op_plus
id|qh-&gt;gap_uf
)paren
)paren
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
id|done
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|qh_schedule
r_static
r_int
id|qh_schedule
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|ehci_qh
op_star
id|qh
)paren
(brace
r_int
id|status
suffix:semicolon
r_int
id|uframe
suffix:semicolon
id|__le32
id|c_mask
suffix:semicolon
r_int
id|frame
suffix:semicolon
multiline_comment|/* 0..(qh-&gt;period - 1), or NO_FRAME */
id|qh_refresh
c_func
(paren
id|ehci
comma
id|qh
)paren
suffix:semicolon
id|qh-&gt;hw_next
op_assign
id|EHCI_LIST_END
suffix:semicolon
id|frame
op_assign
id|qh-&gt;start
suffix:semicolon
multiline_comment|/* reuse the previous schedule slots, if we can */
r_if
c_cond
(paren
id|frame
OL
id|qh-&gt;period
)paren
(brace
id|uframe
op_assign
id|ffs
(paren
id|le32_to_cpup
(paren
op_amp
id|qh-&gt;hw_info2
)paren
op_amp
l_int|0x00ff
)paren
suffix:semicolon
id|status
op_assign
id|check_intr_schedule
(paren
id|ehci
comma
id|frame
comma
op_decrement
id|uframe
comma
id|qh
comma
op_amp
id|c_mask
)paren
suffix:semicolon
)brace
r_else
(brace
id|uframe
op_assign
l_int|0
suffix:semicolon
id|c_mask
op_assign
l_int|0
suffix:semicolon
id|status
op_assign
op_minus
id|ENOSPC
suffix:semicolon
)brace
multiline_comment|/* else scan the schedule to find a group of slots such that all&n;&t; * uframes have enough periodic bandwidth available.&n;&t; */
r_if
c_cond
(paren
id|status
)paren
(brace
id|frame
op_assign
id|qh-&gt;period
op_minus
l_int|1
suffix:semicolon
r_do
(brace
r_for
c_loop
(paren
id|uframe
op_assign
l_int|0
suffix:semicolon
id|uframe
OL
l_int|8
suffix:semicolon
id|uframe
op_increment
)paren
(brace
id|status
op_assign
id|check_intr_schedule
(paren
id|ehci
comma
id|frame
comma
id|uframe
comma
id|qh
comma
op_amp
id|c_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|status
op_logical_and
id|frame
op_decrement
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_goto
id|done
suffix:semicolon
id|qh-&gt;start
op_assign
id|frame
suffix:semicolon
multiline_comment|/* reset S-frame and (maybe) C-frame masks */
id|qh-&gt;hw_info2
op_and_assign
op_complement
id|__constant_cpu_to_le32
c_func
(paren
l_int|0xffff
)paren
suffix:semicolon
id|qh-&gt;hw_info2
op_or_assign
id|cpu_to_le32
(paren
l_int|1
op_lshift
id|uframe
)paren
op_or
id|c_mask
suffix:semicolon
)brace
r_else
id|ehci_dbg
(paren
id|ehci
comma
l_string|&quot;reused qh %p schedule&bslash;n&quot;
comma
id|qh
)paren
suffix:semicolon
multiline_comment|/* stuff into the periodic schedule */
id|qh-&gt;qh_state
op_assign
id|QH_STATE_LINKED
suffix:semicolon
id|ehci_dbg
c_func
(paren
id|ehci
comma
l_string|&quot;scheduled qh%d/%p usecs %d/%d starting %d.%d (gap %d)&bslash;n&quot;
comma
id|qh-&gt;period
comma
id|qh
comma
id|qh-&gt;usecs
comma
id|qh-&gt;c_usecs
comma
id|frame
comma
id|uframe
comma
id|qh-&gt;gap_uf
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|unlikely
(paren
id|ehci-&gt;pshadow
(braket
id|frame
)braket
dot
id|ptr
op_ne
l_int|0
)paren
)paren
(brace
singleline_comment|// FIXME -- just link toward the end, before any qh with a shorter period,
singleline_comment|// AND accommodate it already having been linked here (after some other qh)
singleline_comment|// AS WELL AS updating the schedule checking logic
id|BUG
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|ehci-&gt;pshadow
(braket
id|frame
)braket
dot
id|qh
op_assign
id|qh_get
(paren
id|qh
)paren
suffix:semicolon
id|ehci-&gt;periodic
(braket
id|frame
)braket
op_assign
id|QH_NEXT
(paren
id|qh-&gt;qh_dma
)paren
suffix:semicolon
)brace
id|wmb
(paren
)paren
suffix:semicolon
id|frame
op_add_assign
id|qh-&gt;period
suffix:semicolon
)brace
r_while
c_loop
(paren
id|frame
OL
id|ehci-&gt;periodic_size
)paren
suffix:semicolon
multiline_comment|/* update per-qh bandwidth for usbfs */
id|hcd_to_bus
(paren
op_amp
id|ehci-&gt;hcd
)paren
op_member_access_from_pointer
id|bandwidth_allocated
op_add_assign
(paren
id|qh-&gt;usecs
op_plus
id|qh-&gt;c_usecs
)paren
op_div
id|qh-&gt;period
suffix:semicolon
multiline_comment|/* maybe enable periodic schedule processing */
r_if
c_cond
(paren
op_logical_neg
id|ehci-&gt;periodic_sched
op_increment
)paren
id|status
op_assign
id|enable_periodic
(paren
id|ehci
)paren
suffix:semicolon
id|done
suffix:colon
r_return
id|status
suffix:semicolon
)brace
DECL|function|intr_submit
r_static
r_int
id|intr_submit
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|list_head
op_star
id|qtd_list
comma
r_int
id|mem_flags
)paren
(brace
r_int
id|epnum
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|ehci_qh
op_star
id|qh
suffix:semicolon
r_struct
id|hcd_dev
op_star
id|dev
suffix:semicolon
r_int
id|is_input
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
r_struct
id|list_head
id|empty
suffix:semicolon
multiline_comment|/* get endpoint and transfer/schedule data */
id|epnum
op_assign
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
id|is_input
op_assign
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_input
)paren
id|epnum
op_or_assign
l_int|0x10
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|dev
op_assign
(paren
r_struct
id|hcd_dev
op_star
)paren
id|urb-&gt;dev-&gt;hcpriv
suffix:semicolon
multiline_comment|/* get qh and force any scheduling errors */
id|INIT_LIST_HEAD
(paren
op_amp
id|empty
)paren
suffix:semicolon
id|qh
op_assign
id|qh_append_tds
(paren
id|ehci
comma
id|urb
comma
op_amp
id|empty
comma
id|epnum
comma
op_amp
id|dev-&gt;ep
(braket
id|epnum
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qh
op_eq
l_int|0
)paren
(brace
id|status
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|qh-&gt;qh_state
op_eq
id|QH_STATE_IDLE
)paren
(brace
r_if
c_cond
(paren
(paren
id|status
op_assign
id|qh_schedule
(paren
id|ehci
comma
id|qh
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/* then queue the urb&squot;s tds to the qh */
id|qh
op_assign
id|qh_append_tds
(paren
id|ehci
comma
id|urb
comma
id|qtd_list
comma
id|epnum
comma
op_amp
id|dev-&gt;ep
(braket
id|epnum
)braket
)paren
suffix:semicolon
id|BUG_ON
(paren
id|qh
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/* ... update usbfs periodic stats */
id|hcd_to_bus
(paren
op_amp
id|ehci-&gt;hcd
)paren
op_member_access_from_pointer
id|bandwidth_int_reqs
op_increment
suffix:semicolon
id|done
suffix:colon
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
id|qtd_list_free
(paren
id|ehci
comma
id|urb
comma
id|qtd_list
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* ehci_iso_stream ops work with both ITD and SITD */
r_static
r_struct
id|ehci_iso_stream
op_star
DECL|function|iso_stream_alloc
id|iso_stream_alloc
(paren
r_int
id|mem_flags
)paren
(brace
r_struct
id|ehci_iso_stream
op_star
id|stream
suffix:semicolon
id|stream
op_assign
id|kmalloc
c_func
(paren
r_sizeof
op_star
id|stream
comma
id|mem_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
(paren
id|stream
op_ne
l_int|0
)paren
)paren
(brace
id|memset
(paren
id|stream
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|stream
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|stream-&gt;td_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|stream-&gt;free_list
)paren
suffix:semicolon
id|stream-&gt;next_uframe
op_assign
op_minus
l_int|1
suffix:semicolon
id|stream-&gt;refcount
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|stream
suffix:semicolon
)brace
r_static
r_void
DECL|function|iso_stream_init
id|iso_stream_init
(paren
r_struct
id|ehci_iso_stream
op_star
id|stream
comma
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|pipe
comma
r_int
id|interval
)paren
(brace
r_static
r_const
id|u8
id|smask_out
(braket
)braket
op_assign
(brace
l_int|0x01
comma
l_int|0x03
comma
l_int|0x07
comma
l_int|0x0f
comma
l_int|0x1f
comma
l_int|0x3f
)brace
suffix:semicolon
id|u32
id|buf1
suffix:semicolon
r_int
id|epnum
comma
id|maxp
suffix:semicolon
r_int
id|is_input
suffix:semicolon
r_int
id|bandwidth
suffix:semicolon
multiline_comment|/*&n;&t; * this might be a &quot;high bandwidth&quot; highspeed endpoint,&n;&t; * as encoded in the ep descriptor&squot;s wMaxPacket field&n;&t; */
id|epnum
op_assign
id|usb_pipeendpoint
(paren
id|pipe
)paren
suffix:semicolon
id|is_input
op_assign
id|usb_pipein
(paren
id|pipe
)paren
ques
c_cond
id|USB_DIR_IN
suffix:colon
l_int|0
suffix:semicolon
id|maxp
op_assign
id|usb_maxpacket
c_func
(paren
id|dev
comma
id|pipe
comma
op_logical_neg
id|is_input
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_input
)paren
(brace
id|buf1
op_assign
(paren
l_int|1
op_lshift
l_int|11
)paren
suffix:semicolon
)brace
r_else
(brace
id|buf1
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* knows about ITD vs SITD */
r_if
c_cond
(paren
id|dev-&gt;speed
op_eq
id|USB_SPEED_HIGH
)paren
(brace
r_int
id|multi
op_assign
id|hb_mult
c_func
(paren
id|maxp
)paren
suffix:semicolon
id|stream-&gt;highspeed
op_assign
l_int|1
suffix:semicolon
id|maxp
op_assign
id|max_packet
c_func
(paren
id|maxp
)paren
suffix:semicolon
id|buf1
op_or_assign
id|maxp
suffix:semicolon
id|maxp
op_mul_assign
id|multi
suffix:semicolon
id|stream-&gt;buf0
op_assign
id|cpu_to_le32
(paren
(paren
id|epnum
op_lshift
l_int|8
)paren
op_or
id|dev-&gt;devnum
)paren
suffix:semicolon
id|stream-&gt;buf1
op_assign
id|cpu_to_le32
(paren
id|buf1
)paren
suffix:semicolon
id|stream-&gt;buf2
op_assign
id|cpu_to_le32
(paren
id|multi
)paren
suffix:semicolon
multiline_comment|/* usbfs wants to report the average usecs per frame tied up&n;&t;&t; * when transfers on this endpoint are scheduled ...&n;&t;&t; */
id|stream-&gt;usecs
op_assign
id|HS_USECS_ISO
(paren
id|maxp
)paren
suffix:semicolon
id|bandwidth
op_assign
id|stream-&gt;usecs
op_star
l_int|8
suffix:semicolon
id|bandwidth
op_div_assign
l_int|1
op_lshift
(paren
id|interval
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|u32
id|addr
suffix:semicolon
id|addr
op_assign
id|dev-&gt;ttport
op_lshift
l_int|24
suffix:semicolon
id|addr
op_or_assign
id|dev-&gt;tt-&gt;hub-&gt;devnum
op_lshift
l_int|16
suffix:semicolon
id|addr
op_or_assign
id|epnum
op_lshift
l_int|8
suffix:semicolon
id|addr
op_or_assign
id|dev-&gt;devnum
suffix:semicolon
id|stream-&gt;usecs
op_assign
id|HS_USECS_ISO
(paren
id|maxp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_input
)paren
(brace
id|u32
id|tmp
suffix:semicolon
id|addr
op_or_assign
l_int|1
op_lshift
l_int|31
suffix:semicolon
id|stream-&gt;c_usecs
op_assign
id|stream-&gt;usecs
suffix:semicolon
id|stream-&gt;usecs
op_assign
id|HS_USECS_ISO
(paren
l_int|1
)paren
suffix:semicolon
id|stream-&gt;raw_mask
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* pessimistic c-mask */
id|tmp
op_assign
id|usb_calc_bus_time
(paren
id|USB_SPEED_FULL
comma
l_int|1
comma
l_int|0
comma
id|maxp
)paren
op_div
(paren
l_int|125
op_star
l_int|1000
)paren
suffix:semicolon
id|stream-&gt;raw_mask
op_or_assign
l_int|3
op_lshift
(paren
id|tmp
op_plus
l_int|9
)paren
suffix:semicolon
)brace
r_else
id|stream-&gt;raw_mask
op_assign
id|smask_out
(braket
id|maxp
op_div
l_int|188
)braket
suffix:semicolon
id|bandwidth
op_assign
id|stream-&gt;usecs
op_plus
id|stream-&gt;c_usecs
suffix:semicolon
id|bandwidth
op_div_assign
l_int|1
op_lshift
(paren
id|interval
op_plus
l_int|2
)paren
suffix:semicolon
multiline_comment|/* stream-&gt;splits gets created from raw_mask later */
id|stream-&gt;address
op_assign
id|cpu_to_le32
(paren
id|addr
)paren
suffix:semicolon
)brace
id|stream-&gt;bandwidth
op_assign
id|bandwidth
suffix:semicolon
id|stream-&gt;udev
op_assign
id|dev
suffix:semicolon
id|stream-&gt;bEndpointAddress
op_assign
id|is_input
op_or
id|epnum
suffix:semicolon
id|stream-&gt;interval
op_assign
id|interval
suffix:semicolon
id|stream-&gt;maxp
op_assign
id|maxp
suffix:semicolon
)brace
r_static
r_void
DECL|function|iso_stream_put
id|iso_stream_put
c_func
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|ehci_iso_stream
op_star
id|stream
)paren
(brace
id|stream-&gt;refcount
op_decrement
suffix:semicolon
multiline_comment|/* free whenever just a dev-&gt;ep reference remains.&n;&t; * not like a QH -- no persistent state (toggle, halt)&n;&t; */
r_if
c_cond
(paren
id|stream-&gt;refcount
op_eq
l_int|1
)paren
(brace
r_int
id|is_in
suffix:semicolon
r_struct
id|hcd_dev
op_star
id|dev
op_assign
id|stream-&gt;udev-&gt;hcpriv
suffix:semicolon
singleline_comment|// BUG_ON (!list_empty(&amp;stream-&gt;td_list));
r_while
c_loop
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|stream-&gt;free_list
)paren
)paren
(brace
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
id|entry
op_assign
id|stream-&gt;free_list.next
suffix:semicolon
id|list_del
(paren
id|entry
)paren
suffix:semicolon
multiline_comment|/* knows about ITD vs SITD */
r_if
c_cond
(paren
id|stream-&gt;highspeed
)paren
(brace
r_struct
id|ehci_itd
op_star
id|itd
suffix:semicolon
id|itd
op_assign
id|list_entry
(paren
id|entry
comma
r_struct
id|ehci_itd
comma
id|itd_list
)paren
suffix:semicolon
id|dma_pool_free
(paren
id|ehci-&gt;itd_pool
comma
id|itd
comma
id|itd-&gt;itd_dma
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|ehci_sitd
op_star
id|sitd
suffix:semicolon
id|sitd
op_assign
id|list_entry
(paren
id|entry
comma
r_struct
id|ehci_sitd
comma
id|sitd_list
)paren
suffix:semicolon
id|dma_pool_free
(paren
id|ehci-&gt;sitd_pool
comma
id|sitd
comma
id|sitd-&gt;sitd_dma
)paren
suffix:semicolon
)brace
)brace
id|is_in
op_assign
(paren
id|stream-&gt;bEndpointAddress
op_amp
id|USB_DIR_IN
)paren
ques
c_cond
l_int|0x10
suffix:colon
l_int|0
suffix:semicolon
id|stream-&gt;bEndpointAddress
op_and_assign
l_int|0x0f
suffix:semicolon
id|dev-&gt;ep
(braket
id|is_in
op_plus
id|stream-&gt;bEndpointAddress
)braket
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|stream-&gt;rescheduled
)paren
(brace
id|ehci_info
(paren
id|ehci
comma
l_string|&quot;ep%d%s-iso rescheduled &quot;
l_string|&quot;%lu times in %lu seconds&bslash;n&quot;
comma
id|stream-&gt;bEndpointAddress
comma
id|is_in
ques
c_cond
l_string|&quot;in&quot;
suffix:colon
l_string|&quot;out&quot;
comma
id|stream-&gt;rescheduled
comma
(paren
(paren
id|jiffies
op_minus
id|stream-&gt;start
)paren
op_div
id|HZ
)paren
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|stream
)paren
suffix:semicolon
)brace
)brace
r_static
r_inline
r_struct
id|ehci_iso_stream
op_star
DECL|function|iso_stream_get
id|iso_stream_get
(paren
r_struct
id|ehci_iso_stream
op_star
id|stream
)paren
(brace
r_if
c_cond
(paren
id|likely
(paren
id|stream
op_ne
l_int|0
)paren
)paren
id|stream-&gt;refcount
op_increment
suffix:semicolon
r_return
id|stream
suffix:semicolon
)brace
r_static
r_struct
id|ehci_iso_stream
op_star
DECL|function|iso_stream_find
id|iso_stream_find
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
id|epnum
suffix:semicolon
r_struct
id|hcd_dev
op_star
id|dev
suffix:semicolon
r_struct
id|ehci_iso_stream
op_star
id|stream
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|epnum
op_assign
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipein
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
id|epnum
op_add_assign
l_int|0x10
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|dev
op_assign
(paren
r_struct
id|hcd_dev
op_star
)paren
id|urb-&gt;dev-&gt;hcpriv
suffix:semicolon
id|stream
op_assign
id|dev-&gt;ep
(braket
id|epnum
)braket
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
id|stream
op_eq
l_int|0
)paren
)paren
(brace
id|stream
op_assign
id|iso_stream_alloc
c_func
(paren
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
(paren
id|stream
op_ne
l_int|0
)paren
)paren
(brace
multiline_comment|/* dev-&gt;ep owns the initial refcount */
id|dev-&gt;ep
(braket
id|epnum
)braket
op_assign
id|stream
suffix:semicolon
id|iso_stream_init
c_func
(paren
id|stream
comma
id|urb-&gt;dev
comma
id|urb-&gt;pipe
comma
id|urb-&gt;interval
)paren
suffix:semicolon
)brace
multiline_comment|/* if dev-&gt;ep [epnum] is a QH, info1.maxpacket is nonzero */
)brace
r_else
r_if
c_cond
(paren
id|unlikely
(paren
id|stream-&gt;hw_info1
op_ne
l_int|0
)paren
)paren
(brace
id|ehci_dbg
(paren
id|ehci
comma
l_string|&quot;dev %s ep%d%s, not iso??&bslash;n&quot;
comma
id|urb-&gt;dev-&gt;devpath
comma
id|epnum
op_amp
l_int|0x0f
comma
(paren
id|epnum
op_amp
l_int|0x10
)paren
ques
c_cond
l_string|&quot;in&quot;
suffix:colon
l_string|&quot;out&quot;
)paren
suffix:semicolon
id|stream
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* caller guarantees an eventual matching iso_stream_put */
id|stream
op_assign
id|iso_stream_get
(paren
id|stream
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|stream
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* ehci_iso_sched ops can be shared, ITD-only, or SITD-only */
r_static
r_struct
id|ehci_iso_sched
op_star
DECL|function|iso_sched_alloc
id|iso_sched_alloc
(paren
r_int
id|packets
comma
r_int
id|mem_flags
)paren
(brace
r_struct
id|ehci_iso_sched
op_star
id|iso_sched
suffix:semicolon
r_int
id|size
op_assign
r_sizeof
op_star
id|iso_sched
suffix:semicolon
id|size
op_add_assign
id|packets
op_star
r_sizeof
(paren
r_struct
id|ehci_iso_packet
)paren
suffix:semicolon
id|iso_sched
op_assign
id|kmalloc
(paren
id|size
comma
id|mem_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
(paren
id|iso_sched
op_ne
l_int|0
)paren
)paren
(brace
id|memset
c_func
(paren
id|iso_sched
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|iso_sched-&gt;td_list
)paren
suffix:semicolon
)brace
r_return
id|iso_sched
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|itd_sched_init
id|itd_sched_init
(paren
r_struct
id|ehci_iso_sched
op_star
id|iso_sched
comma
r_struct
id|ehci_iso_stream
op_star
id|stream
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
id|i
suffix:semicolon
id|dma_addr_t
id|dma
op_assign
id|urb-&gt;transfer_dma
suffix:semicolon
multiline_comment|/* how many uframes are needed for these transfers */
id|iso_sched-&gt;span
op_assign
id|urb-&gt;number_of_packets
op_star
id|stream-&gt;interval
suffix:semicolon
multiline_comment|/* figure out per-uframe itd fields that we&squot;ll need later&n;&t; * when we fit new itds into the schedule.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ehci_iso_packet
op_star
id|uframe
op_assign
op_amp
id|iso_sched-&gt;packet
(braket
id|i
)braket
suffix:semicolon
r_int
id|length
suffix:semicolon
id|dma_addr_t
id|buf
suffix:semicolon
id|u32
id|trans
suffix:semicolon
id|length
op_assign
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|length
suffix:semicolon
id|buf
op_assign
id|dma
op_plus
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|offset
suffix:semicolon
id|trans
op_assign
id|EHCI_ISOC_ACTIVE
suffix:semicolon
id|trans
op_or_assign
id|buf
op_amp
l_int|0x0fff
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
(paren
(paren
id|i
op_plus
l_int|1
)paren
op_eq
id|urb-&gt;number_of_packets
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|urb-&gt;transfer_flags
op_amp
id|URB_NO_INTERRUPT
)paren
)paren
id|trans
op_or_assign
id|EHCI_ITD_IOC
suffix:semicolon
id|trans
op_or_assign
id|length
op_lshift
l_int|16
suffix:semicolon
id|uframe-&gt;transaction
op_assign
id|cpu_to_le32
(paren
id|trans
)paren
suffix:semicolon
multiline_comment|/* might need to cross a buffer page within a td */
id|uframe-&gt;bufp
op_assign
(paren
id|buf
op_amp
op_complement
(paren
id|u64
)paren
l_int|0x0fff
)paren
suffix:semicolon
id|buf
op_add_assign
id|length
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
(paren
id|uframe-&gt;bufp
op_ne
(paren
id|buf
op_amp
op_complement
(paren
id|u64
)paren
l_int|0x0fff
)paren
)paren
)paren
)paren
id|uframe-&gt;cross
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|iso_sched_free
id|iso_sched_free
(paren
r_struct
id|ehci_iso_stream
op_star
id|stream
comma
r_struct
id|ehci_iso_sched
op_star
id|iso_sched
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|iso_sched
)paren
r_return
suffix:semicolon
singleline_comment|// caller must hold ehci-&gt;lock!
id|list_splice
(paren
op_amp
id|iso_sched-&gt;td_list
comma
op_amp
id|stream-&gt;free_list
)paren
suffix:semicolon
id|kfree
(paren
id|iso_sched
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|itd_urb_transaction
id|itd_urb_transaction
(paren
r_struct
id|ehci_iso_stream
op_star
id|stream
comma
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|mem_flags
)paren
(brace
r_struct
id|ehci_itd
op_star
id|itd
suffix:semicolon
id|dma_addr_t
id|itd_dma
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|num_itds
suffix:semicolon
r_struct
id|ehci_iso_sched
op_star
id|sched
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|sched
op_assign
id|iso_sched_alloc
(paren
id|urb-&gt;number_of_packets
comma
id|mem_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
id|sched
op_eq
l_int|0
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|itd_sched_init
(paren
id|sched
comma
id|stream
comma
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;interval
OL
l_int|8
)paren
id|num_itds
op_assign
l_int|1
op_plus
(paren
id|sched-&gt;span
op_plus
l_int|7
)paren
op_div
l_int|8
suffix:semicolon
r_else
id|num_itds
op_assign
id|urb-&gt;number_of_packets
suffix:semicolon
multiline_comment|/* allocate/init ITDs */
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_itds
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* free_list.next might be cache-hot ... but maybe&n;&t;&t; * the HC caches it too. avoid that issue for now.&n;&t;&t; */
multiline_comment|/* prefer previously-allocated itds */
r_if
c_cond
(paren
id|likely
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|stream-&gt;free_list
)paren
)paren
)paren
(brace
id|itd
op_assign
id|list_entry
(paren
id|stream-&gt;free_list.prev
comma
r_struct
id|ehci_itd
comma
id|itd_list
)paren
suffix:semicolon
id|list_del
(paren
op_amp
id|itd-&gt;itd_list
)paren
suffix:semicolon
id|itd_dma
op_assign
id|itd-&gt;itd_dma
suffix:semicolon
)brace
r_else
id|itd
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|itd
)paren
(brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|itd
op_assign
id|dma_pool_alloc
(paren
id|ehci-&gt;itd_pool
comma
id|mem_flags
comma
op_amp
id|itd_dma
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
(paren
l_int|0
op_eq
id|itd
)paren
)paren
(brace
id|iso_sched_free
(paren
id|stream
comma
id|sched
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
(paren
id|itd
comma
l_int|0
comma
r_sizeof
op_star
id|itd
)paren
suffix:semicolon
id|itd-&gt;itd_dma
op_assign
id|itd_dma
suffix:semicolon
id|list_add
(paren
op_amp
id|itd-&gt;itd_list
comma
op_amp
id|sched-&gt;td_list
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* temporarily store schedule info in hcpriv */
id|urb-&gt;hcpriv
op_assign
id|sched
suffix:semicolon
id|urb-&gt;error_count
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
r_static
r_inline
r_int
DECL|function|itd_slot_ok
id|itd_slot_ok
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
id|u32
id|mod
comma
id|u32
id|uframe
comma
id|u8
id|usecs
comma
id|u32
id|period
)paren
(brace
id|uframe
op_mod_assign
id|period
suffix:semicolon
r_do
(brace
multiline_comment|/* can&squot;t commit more than 80% periodic == 100 usec */
r_if
c_cond
(paren
id|periodic_usecs
(paren
id|ehci
comma
id|uframe
op_rshift
l_int|3
comma
id|uframe
op_amp
l_int|0x7
)paren
OG
(paren
l_int|100
op_minus
id|usecs
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* we know urb-&gt;interval is 2^N uframes */
id|uframe
op_add_assign
id|period
suffix:semicolon
)brace
r_while
c_loop
(paren
id|uframe
OL
id|mod
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|sitd_slot_ok
id|sitd_slot_ok
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
id|u32
id|mod
comma
r_struct
id|ehci_iso_stream
op_star
id|stream
comma
id|u32
id|uframe
comma
r_struct
id|ehci_iso_sched
op_star
id|sched
comma
id|u32
id|period_uframes
)paren
(brace
id|u32
id|mask
comma
id|tmp
suffix:semicolon
id|u32
id|frame
comma
id|uf
suffix:semicolon
id|mask
op_assign
id|stream-&gt;raw_mask
op_lshift
(paren
id|uframe
op_amp
l_int|7
)paren
suffix:semicolon
multiline_comment|/* for IN, don&squot;t wrap CSPLIT into the next frame */
r_if
c_cond
(paren
id|mask
op_amp
op_complement
l_int|0xffff
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* this multi-pass logic is simple, but performance may&n;&t; * suffer when the schedule data isn&squot;t cached.&n;&t; */
multiline_comment|/* check bandwidth */
id|uframe
op_mod_assign
id|period_uframes
suffix:semicolon
r_do
(brace
id|u32
id|max_used
suffix:semicolon
id|frame
op_assign
id|uframe
op_rshift
l_int|3
suffix:semicolon
id|uf
op_assign
id|uframe
op_amp
l_int|7
suffix:semicolon
multiline_comment|/* tt must be idle for start(s), any gap, and csplit.&n;&t;&t; * assume scheduling slop leaves 10+% for control/bulk.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|tt_no_collision
(paren
id|ehci
comma
id|period_uframes
op_lshift
l_int|3
comma
id|stream-&gt;udev
comma
id|frame
comma
id|mask
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* check starts (OUT uses more than one) */
id|max_used
op_assign
l_int|100
op_minus
id|stream-&gt;usecs
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
id|stream-&gt;raw_mask
op_amp
l_int|0xff
suffix:semicolon
id|tmp
suffix:semicolon
id|tmp
op_rshift_assign
l_int|1
comma
id|uf
op_increment
)paren
(brace
r_if
c_cond
(paren
id|periodic_usecs
(paren
id|ehci
comma
id|frame
comma
id|uf
)paren
OG
id|max_used
)paren
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* for IN, check CSPLIT */
r_if
c_cond
(paren
id|stream-&gt;c_usecs
)paren
(brace
id|max_used
op_assign
l_int|100
op_minus
id|stream-&gt;c_usecs
suffix:semicolon
r_do
(brace
id|tmp
op_assign
l_int|1
op_lshift
id|uf
suffix:semicolon
id|tmp
op_lshift_assign
l_int|8
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stream-&gt;raw_mask
op_amp
id|tmp
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|periodic_usecs
(paren
id|ehci
comma
id|frame
comma
id|uf
)paren
OG
id|max_used
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
op_increment
id|uf
OL
l_int|8
)paren
suffix:semicolon
)brace
multiline_comment|/* we know urb-&gt;interval is 2^N uframes */
id|uframe
op_add_assign
id|period_uframes
suffix:semicolon
)brace
r_while
c_loop
(paren
id|uframe
OL
id|mod
)paren
suffix:semicolon
id|stream-&gt;splits
op_assign
id|cpu_to_le32
c_func
(paren
id|stream-&gt;raw_mask
op_lshift
(paren
id|uframe
op_amp
l_int|7
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * This scheduler plans almost as far into the future as it has actual&n; * periodic schedule slots.  (Affected by TUNE_FLS, which defaults to&n; * &quot;as small as possible&quot; to be cache-friendlier.)  That limits the size&n; * transfers you can stream reliably; avoid more than 64 msec per urb.&n; * Also avoid queue depths of less than ehci&squot;s worst irq latency (affected&n; * by the per-urb URB_NO_INTERRUPT hint, the log2_irq_thresh module parameter,&n; * and other factors); or more than about 230 msec total (for portability,&n; * given EHCI_TUNE_FLS and the slop).  Or, write a smarter scheduler!&n; */
DECL|macro|SCHEDULE_SLOP
mdefine_line|#define SCHEDULE_SLOP&t;10&t;/* frames */
r_static
r_int
DECL|function|iso_stream_schedule
id|iso_stream_schedule
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|ehci_iso_stream
op_star
id|stream
)paren
(brace
id|u32
id|now
comma
id|start
comma
id|max
comma
id|period
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|mod
op_assign
id|ehci-&gt;periodic_size
op_lshift
l_int|3
suffix:semicolon
r_struct
id|ehci_iso_sched
op_star
id|sched
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
r_if
c_cond
(paren
id|sched-&gt;span
OG
(paren
id|mod
op_minus
l_int|8
op_star
id|SCHEDULE_SLOP
)paren
)paren
(brace
id|ehci_dbg
(paren
id|ehci
comma
l_string|&quot;iso request %p too long&bslash;n&quot;
comma
id|urb
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|EFBIG
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|stream-&gt;depth
op_plus
id|sched-&gt;span
)paren
OG
id|mod
)paren
(brace
id|ehci_dbg
(paren
id|ehci
comma
l_string|&quot;request %p would overflow (%d+%d&gt;%d)&bslash;n&quot;
comma
id|urb
comma
id|stream-&gt;depth
comma
id|sched-&gt;span
comma
id|mod
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|EFBIG
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
id|now
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;frame_index
)paren
op_mod
id|mod
suffix:semicolon
multiline_comment|/* when&squot;s the last uframe this urb could start? */
id|max
op_assign
id|now
op_plus
id|mod
suffix:semicolon
multiline_comment|/* typical case: reuse current schedule. stream is still active,&n;&t; * and no gaps from host falling behind (irq delays etc)&n;&t; */
r_if
c_cond
(paren
id|likely
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|stream-&gt;td_list
)paren
)paren
)paren
(brace
id|start
op_assign
id|stream-&gt;next_uframe
suffix:semicolon
r_if
c_cond
(paren
id|start
OL
id|now
)paren
id|start
op_add_assign
id|mod
suffix:semicolon
r_if
c_cond
(paren
id|likely
(paren
(paren
id|start
op_plus
id|sched-&gt;span
)paren
OL
id|max
)paren
)paren
r_goto
id|ready
suffix:semicolon
multiline_comment|/* else fell behind; someday, try to reschedule */
id|status
op_assign
op_minus
id|EL2NSYNC
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
multiline_comment|/* need to schedule; when&squot;s the next (u)frame we could start?&n;&t; * this is bigger than ehci-&gt;i_thresh allows; scheduling itself&n;&t; * isn&squot;t free, the slop should handle reasonably slow cpus.  it&n;&t; * can also help high bandwidth if the dma and irq loads don&squot;t&n;&t; * jump until after the queue is primed.&n;&t; */
id|start
op_assign
id|SCHEDULE_SLOP
op_star
l_int|8
op_plus
(paren
id|now
op_amp
op_complement
l_int|0x07
)paren
suffix:semicolon
id|start
op_mod_assign
id|mod
suffix:semicolon
id|stream-&gt;next_uframe
op_assign
id|start
suffix:semicolon
multiline_comment|/* NOTE:  assumes URB_ISO_ASAP, to limit complexity/bugs */
id|period
op_assign
id|urb-&gt;interval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stream-&gt;highspeed
)paren
id|period
op_lshift_assign
l_int|3
suffix:semicolon
multiline_comment|/* find a uframe slot with enough bandwidth */
r_for
c_loop
(paren
suffix:semicolon
id|start
OL
(paren
id|stream-&gt;next_uframe
op_plus
id|period
)paren
suffix:semicolon
id|start
op_increment
)paren
(brace
r_int
id|enough_space
suffix:semicolon
multiline_comment|/* check schedule: enough space? */
r_if
c_cond
(paren
id|stream-&gt;highspeed
)paren
id|enough_space
op_assign
id|itd_slot_ok
(paren
id|ehci
comma
id|mod
comma
id|start
comma
id|stream-&gt;usecs
comma
id|period
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
(paren
id|start
op_mod
l_int|8
)paren
op_ge
l_int|6
)paren
r_continue
suffix:semicolon
id|enough_space
op_assign
id|sitd_slot_ok
(paren
id|ehci
comma
id|mod
comma
id|stream
comma
id|start
comma
id|sched
comma
id|period
)paren
suffix:semicolon
)brace
multiline_comment|/* schedule it here if there&squot;s enough bandwidth */
r_if
c_cond
(paren
id|enough_space
)paren
(brace
id|stream-&gt;next_uframe
op_assign
id|start
op_mod
id|mod
suffix:semicolon
r_goto
id|ready
suffix:semicolon
)brace
)brace
multiline_comment|/* no room in the schedule */
id|ehci_dbg
(paren
id|ehci
comma
l_string|&quot;iso %ssched full %p (now %d max %d)&bslash;n&quot;
comma
id|list_empty
(paren
op_amp
id|stream-&gt;td_list
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;re&quot;
comma
id|urb
comma
id|now
comma
id|max
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|ENOSPC
suffix:semicolon
id|fail
suffix:colon
id|iso_sched_free
(paren
id|stream
comma
id|sched
)paren
suffix:semicolon
id|urb-&gt;hcpriv
op_assign
l_int|NULL
suffix:semicolon
r_return
id|status
suffix:semicolon
id|ready
suffix:colon
id|urb-&gt;start_frame
op_assign
id|stream-&gt;next_uframe
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
r_static
r_inline
r_void
DECL|function|itd_init
id|itd_init
(paren
r_struct
id|ehci_iso_stream
op_star
id|stream
comma
r_struct
id|ehci_itd
op_star
id|itd
)paren
(brace
r_int
id|i
suffix:semicolon
id|itd-&gt;hw_next
op_assign
id|EHCI_LIST_END
suffix:semicolon
id|itd-&gt;hw_bufp
(braket
l_int|0
)braket
op_assign
id|stream-&gt;buf0
suffix:semicolon
id|itd-&gt;hw_bufp
(braket
l_int|1
)braket
op_assign
id|stream-&gt;buf1
suffix:semicolon
id|itd-&gt;hw_bufp
(braket
l_int|2
)braket
op_assign
id|stream-&gt;buf2
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
id|itd-&gt;index
(braket
id|i
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* All other fields are filled when scheduling */
)brace
r_static
r_inline
r_void
DECL|function|itd_patch
id|itd_patch
(paren
r_struct
id|ehci_itd
op_star
id|itd
comma
r_struct
id|ehci_iso_sched
op_star
id|iso_sched
comma
r_int
id|index
comma
id|u16
id|uframe
comma
r_int
id|first
)paren
(brace
r_struct
id|ehci_iso_packet
op_star
id|uf
op_assign
op_amp
id|iso_sched-&gt;packet
(braket
id|index
)braket
suffix:semicolon
r_int
id|pg
op_assign
id|itd-&gt;pg
suffix:semicolon
singleline_comment|// BUG_ON (pg == 6 &amp;&amp; uf-&gt;cross);
id|uframe
op_and_assign
l_int|0x07
suffix:semicolon
id|itd-&gt;index
(braket
id|uframe
)braket
op_assign
id|index
suffix:semicolon
id|itd-&gt;hw_transaction
(braket
id|uframe
)braket
op_assign
id|uf-&gt;transaction
suffix:semicolon
id|itd-&gt;hw_transaction
(braket
id|uframe
)braket
op_or_assign
id|cpu_to_le32
(paren
id|pg
op_lshift
l_int|12
)paren
suffix:semicolon
id|itd-&gt;hw_bufp
(braket
id|pg
)braket
op_or_assign
id|cpu_to_le32
(paren
id|uf-&gt;bufp
op_amp
op_complement
(paren
id|u32
)paren
l_int|0
)paren
suffix:semicolon
id|itd-&gt;hw_bufp_hi
(braket
id|pg
)braket
op_or_assign
id|cpu_to_le32
(paren
(paren
id|u32
)paren
(paren
id|uf-&gt;bufp
op_rshift
l_int|32
)paren
)paren
suffix:semicolon
multiline_comment|/* iso_frame_desc[].offset must be strictly increasing */
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|first
op_logical_and
id|uf-&gt;cross
)paren
)paren
(brace
id|u64
id|bufp
op_assign
id|uf-&gt;bufp
op_plus
l_int|4096
suffix:semicolon
id|itd-&gt;pg
op_assign
op_increment
id|pg
suffix:semicolon
id|itd-&gt;hw_bufp
(braket
id|pg
)braket
op_or_assign
id|cpu_to_le32
(paren
id|bufp
op_amp
op_complement
(paren
id|u32
)paren
l_int|0
)paren
suffix:semicolon
id|itd-&gt;hw_bufp_hi
(braket
id|pg
)braket
op_or_assign
id|cpu_to_le32
(paren
(paren
id|u32
)paren
(paren
id|bufp
op_rshift
l_int|32
)paren
)paren
suffix:semicolon
)brace
)brace
r_static
r_inline
r_void
DECL|function|itd_link
id|itd_link
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_int
id|frame
comma
r_struct
id|ehci_itd
op_star
id|itd
)paren
(brace
multiline_comment|/* always prepend ITD/SITD ... only QH tree is order-sensitive */
id|itd-&gt;itd_next
op_assign
id|ehci-&gt;pshadow
(braket
id|frame
)braket
suffix:semicolon
id|itd-&gt;hw_next
op_assign
id|ehci-&gt;periodic
(braket
id|frame
)braket
suffix:semicolon
id|ehci-&gt;pshadow
(braket
id|frame
)braket
dot
id|itd
op_assign
id|itd
suffix:semicolon
id|itd-&gt;frame
op_assign
id|frame
suffix:semicolon
id|wmb
(paren
)paren
suffix:semicolon
id|ehci-&gt;periodic
(braket
id|frame
)braket
op_assign
id|cpu_to_le32
(paren
id|itd-&gt;itd_dma
)paren
op_or
id|Q_TYPE_ITD
suffix:semicolon
)brace
multiline_comment|/* fit urb&squot;s itds into the selected schedule slot; activate as needed */
r_static
r_int
DECL|function|itd_link_urb
id|itd_link_urb
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|mod
comma
r_struct
id|ehci_iso_stream
op_star
id|stream
)paren
(brace
r_int
id|packet
comma
id|first
op_assign
l_int|1
suffix:semicolon
r_int
id|next_uframe
comma
id|uframe
comma
id|frame
suffix:semicolon
r_struct
id|ehci_iso_sched
op_star
id|iso_sched
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
r_struct
id|ehci_itd
op_star
id|itd
suffix:semicolon
id|next_uframe
op_assign
id|stream-&gt;next_uframe
op_mod
id|mod
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
id|list_empty
c_func
(paren
op_amp
id|stream-&gt;td_list
)paren
)paren
)paren
(brace
id|hcd_to_bus
(paren
op_amp
id|ehci-&gt;hcd
)paren
op_member_access_from_pointer
id|bandwidth_allocated
op_add_assign
id|stream-&gt;bandwidth
suffix:semicolon
id|ehci_vdbg
(paren
id|ehci
comma
l_string|&quot;schedule devp %s ep%d%s-iso period %d start %d.%d&bslash;n&quot;
comma
id|urb-&gt;dev-&gt;devpath
comma
id|stream-&gt;bEndpointAddress
op_amp
l_int|0x0f
comma
(paren
id|stream-&gt;bEndpointAddress
op_amp
id|USB_DIR_IN
)paren
ques
c_cond
l_string|&quot;in&quot;
suffix:colon
l_string|&quot;out&quot;
comma
id|urb-&gt;interval
comma
id|next_uframe
op_rshift
l_int|3
comma
id|next_uframe
op_amp
l_int|0x7
)paren
suffix:semicolon
id|stream-&gt;start
op_assign
id|jiffies
suffix:semicolon
)brace
id|hcd_to_bus
(paren
op_amp
id|ehci-&gt;hcd
)paren
op_member_access_from_pointer
id|bandwidth_isoc_reqs
op_increment
suffix:semicolon
multiline_comment|/* fill iTDs uframe by uframe */
r_for
c_loop
(paren
id|packet
op_assign
l_int|0
comma
id|itd
op_assign
l_int|NULL
suffix:semicolon
id|packet
OL
id|urb-&gt;number_of_packets
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|itd
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* ASSERT:  we have all necessary itds */
singleline_comment|// BUG_ON (list_empty (&amp;iso_sched-&gt;td_list));
multiline_comment|/* ASSERT:  no itds for this endpoint in this uframe */
id|itd
op_assign
id|list_entry
(paren
id|iso_sched-&gt;td_list.next
comma
r_struct
id|ehci_itd
comma
id|itd_list
)paren
suffix:semicolon
id|list_move_tail
(paren
op_amp
id|itd-&gt;itd_list
comma
op_amp
id|stream-&gt;td_list
)paren
suffix:semicolon
id|itd-&gt;stream
op_assign
id|iso_stream_get
(paren
id|stream
)paren
suffix:semicolon
id|itd-&gt;urb
op_assign
id|usb_get_urb
(paren
id|urb
)paren
suffix:semicolon
id|first
op_assign
l_int|1
suffix:semicolon
id|itd_init
(paren
id|stream
comma
id|itd
)paren
suffix:semicolon
)brace
id|uframe
op_assign
id|next_uframe
op_amp
l_int|0x07
suffix:semicolon
id|frame
op_assign
id|next_uframe
op_rshift
l_int|3
suffix:semicolon
id|itd-&gt;usecs
(braket
id|uframe
)braket
op_assign
id|stream-&gt;usecs
suffix:semicolon
id|itd_patch
(paren
id|itd
comma
id|iso_sched
comma
id|packet
comma
id|uframe
comma
id|first
)paren
suffix:semicolon
id|first
op_assign
l_int|0
suffix:semicolon
id|next_uframe
op_add_assign
id|stream-&gt;interval
suffix:semicolon
id|stream-&gt;depth
op_add_assign
id|stream-&gt;interval
suffix:semicolon
id|next_uframe
op_mod_assign
id|mod
suffix:semicolon
id|packet
op_increment
suffix:semicolon
multiline_comment|/* link completed itds into the schedule */
r_if
c_cond
(paren
(paren
(paren
id|next_uframe
op_rshift
l_int|3
)paren
op_ne
id|frame
)paren
op_logical_or
id|packet
op_eq
id|urb-&gt;number_of_packets
)paren
(brace
id|itd_link
(paren
id|ehci
comma
id|frame
op_mod
id|ehci-&gt;periodic_size
comma
id|itd
)paren
suffix:semicolon
id|itd
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|stream-&gt;next_uframe
op_assign
id|next_uframe
suffix:semicolon
multiline_comment|/* don&squot;t need that schedule data any more */
id|iso_sched_free
(paren
id|stream
comma
id|iso_sched
)paren
suffix:semicolon
id|urb-&gt;hcpriv
op_assign
l_int|NULL
suffix:semicolon
id|timer_action
(paren
id|ehci
comma
id|TIMER_IO_WATCHDOG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|ehci-&gt;periodic_sched
op_increment
)paren
)paren
r_return
id|enable_periodic
(paren
id|ehci
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|ISO_ERRS
mdefine_line|#define&t;ISO_ERRS (EHCI_ISOC_BUF_ERR | EHCI_ISOC_BABBLE | EHCI_ISOC_XACTERR)
r_static
r_int
DECL|function|itd_complete
id|itd_complete
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|ehci_itd
op_star
id|itd
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|urb
op_star
id|urb
op_assign
id|itd-&gt;urb
suffix:semicolon
r_struct
id|usb_iso_packet_descriptor
op_star
id|desc
suffix:semicolon
id|u32
id|t
suffix:semicolon
r_int
id|uframe
suffix:semicolon
r_int
id|urb_index
op_assign
op_minus
l_int|1
suffix:semicolon
r_struct
id|ehci_iso_stream
op_star
id|stream
op_assign
id|itd-&gt;stream
suffix:semicolon
r_struct
id|usb_device
op_star
id|dev
suffix:semicolon
multiline_comment|/* for each uframe with a packet */
r_for
c_loop
(paren
id|uframe
op_assign
l_int|0
suffix:semicolon
id|uframe
OL
l_int|8
suffix:semicolon
id|uframe
op_increment
)paren
(brace
r_if
c_cond
(paren
id|likely
(paren
id|itd-&gt;index
(braket
id|uframe
)braket
op_eq
op_minus
l_int|1
)paren
)paren
r_continue
suffix:semicolon
id|urb_index
op_assign
id|itd-&gt;index
(braket
id|uframe
)braket
suffix:semicolon
id|desc
op_assign
op_amp
id|urb-&gt;iso_frame_desc
(braket
id|urb_index
)braket
suffix:semicolon
id|t
op_assign
id|le32_to_cpup
(paren
op_amp
id|itd-&gt;hw_transaction
(braket
id|uframe
)braket
)paren
suffix:semicolon
id|itd-&gt;hw_transaction
(braket
id|uframe
)braket
op_assign
l_int|0
suffix:semicolon
id|stream-&gt;depth
op_sub_assign
id|stream-&gt;interval
suffix:semicolon
multiline_comment|/* report transfer status */
r_if
c_cond
(paren
id|unlikely
(paren
id|t
op_amp
id|ISO_ERRS
)paren
)paren
(brace
id|urb-&gt;error_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|t
op_amp
id|EHCI_ISOC_BUF_ERR
)paren
id|desc-&gt;status
op_assign
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
ques
c_cond
op_minus
id|ENOSR
multiline_comment|/* hc couldn&squot;t read */
suffix:colon
op_minus
id|ECOMM
suffix:semicolon
multiline_comment|/* hc couldn&squot;t write */
r_else
r_if
c_cond
(paren
id|t
op_amp
id|EHCI_ISOC_BABBLE
)paren
id|desc-&gt;status
op_assign
op_minus
id|EOVERFLOW
suffix:semicolon
r_else
multiline_comment|/* (t &amp; EHCI_ISOC_XACTERR) */
id|desc-&gt;status
op_assign
op_minus
id|EPROTO
suffix:semicolon
multiline_comment|/* HC need not update length with this error */
r_if
c_cond
(paren
op_logical_neg
(paren
id|t
op_amp
id|EHCI_ISOC_BABBLE
)paren
)paren
id|desc-&gt;actual_length
op_assign
id|EHCI_ITD_LENGTH
(paren
id|t
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|likely
(paren
(paren
id|t
op_amp
id|EHCI_ISOC_ACTIVE
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|desc-&gt;status
op_assign
l_int|0
suffix:semicolon
id|desc-&gt;actual_length
op_assign
id|EHCI_ITD_LENGTH
(paren
id|t
)paren
suffix:semicolon
)brace
)brace
id|usb_put_urb
(paren
id|urb
)paren
suffix:semicolon
id|itd-&gt;urb
op_assign
l_int|NULL
suffix:semicolon
id|itd-&gt;stream
op_assign
l_int|NULL
suffix:semicolon
id|list_move
(paren
op_amp
id|itd-&gt;itd_list
comma
op_amp
id|stream-&gt;free_list
)paren
suffix:semicolon
id|iso_stream_put
(paren
id|ehci
comma
id|stream
)paren
suffix:semicolon
multiline_comment|/* handle completion now? */
r_if
c_cond
(paren
id|likely
(paren
(paren
id|urb_index
op_plus
l_int|1
)paren
op_ne
id|urb-&gt;number_of_packets
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* ASSERT: it&squot;s really the last itd for this urb&n;&t;list_for_each_entry (itd, &amp;stream-&gt;td_list, itd_list)&n;&t;&t;BUG_ON (itd-&gt;urb == urb);&n;&t; */
multiline_comment|/* give urb back to the driver ... can be out-of-order */
id|dev
op_assign
id|usb_get_dev
(paren
id|urb-&gt;dev
)paren
suffix:semicolon
id|ehci_urb_done
(paren
id|ehci
comma
id|urb
comma
id|regs
)paren
suffix:semicolon
id|urb
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* defer stopping schedule; completion can submit */
id|ehci-&gt;periodic_sched
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|ehci-&gt;periodic_sched
)paren
)paren
(paren
r_void
)paren
id|disable_periodic
(paren
id|ehci
)paren
suffix:semicolon
id|hcd_to_bus
(paren
op_amp
id|ehci-&gt;hcd
)paren
op_member_access_from_pointer
id|bandwidth_isoc_reqs
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
id|list_empty
(paren
op_amp
id|stream-&gt;td_list
)paren
)paren
)paren
(brace
id|hcd_to_bus
(paren
op_amp
id|ehci-&gt;hcd
)paren
op_member_access_from_pointer
id|bandwidth_allocated
op_sub_assign
id|stream-&gt;bandwidth
suffix:semicolon
id|ehci_vdbg
(paren
id|ehci
comma
l_string|&quot;deschedule devp %s ep%d%s-iso&bslash;n&quot;
comma
id|dev-&gt;devpath
comma
id|stream-&gt;bEndpointAddress
op_amp
l_int|0x0f
comma
(paren
id|stream-&gt;bEndpointAddress
op_amp
id|USB_DIR_IN
)paren
ques
c_cond
l_string|&quot;in&quot;
suffix:colon
l_string|&quot;out&quot;
)paren
suffix:semicolon
)brace
id|iso_stream_put
(paren
id|ehci
comma
id|stream
)paren
suffix:semicolon
id|usb_put_dev
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|itd_submit
r_static
r_int
id|itd_submit
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|mem_flags
)paren
(brace
r_int
id|status
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|ehci_iso_stream
op_star
id|stream
suffix:semicolon
multiline_comment|/* Get iso_stream head */
id|stream
op_assign
id|iso_stream_find
(paren
id|ehci
comma
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
id|stream
op_eq
l_int|0
)paren
)paren
(brace
id|ehci_dbg
(paren
id|ehci
comma
l_string|&quot;can&squot;t get iso stream&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
(paren
id|urb-&gt;interval
op_ne
id|stream-&gt;interval
)paren
)paren
(brace
id|ehci_dbg
(paren
id|ehci
comma
l_string|&quot;can&squot;t change iso interval %d --&gt; %d&bslash;n&quot;
comma
id|stream-&gt;interval
comma
id|urb-&gt;interval
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
macro_line|#ifdef EHCI_URB_TRACE
id|ehci_dbg
(paren
id|ehci
comma
l_string|&quot;%s %s urb %p ep%d%s len %d, %d pkts %d uframes [%p]&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|urb-&gt;dev-&gt;devpath
comma
id|urb
comma
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
comma
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
ques
c_cond
l_string|&quot;in&quot;
suffix:colon
l_string|&quot;out&quot;
comma
id|urb-&gt;transfer_buffer_length
comma
id|urb-&gt;number_of_packets
comma
id|urb-&gt;interval
comma
id|stream
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* allocate ITDs w/o locking anything */
id|status
op_assign
id|itd_urb_transaction
(paren
id|stream
comma
id|ehci
comma
id|urb
comma
id|mem_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
id|status
OL
l_int|0
)paren
)paren
(brace
id|ehci_dbg
(paren
id|ehci
comma
l_string|&quot;can&squot;t init itds&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/* schedule ... need to lock */
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|status
op_assign
id|iso_stream_schedule
(paren
id|ehci
comma
id|urb
comma
id|stream
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
(paren
id|status
op_eq
l_int|0
)paren
)paren
id|itd_link_urb
(paren
id|ehci
comma
id|urb
comma
id|ehci-&gt;periodic_size
op_lshift
l_int|3
comma
id|stream
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|done
suffix:colon
r_if
c_cond
(paren
id|unlikely
(paren
id|status
OL
l_int|0
)paren
)paren
id|iso_stream_put
(paren
id|ehci
comma
id|stream
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_USB_EHCI_SPLIT_ISO
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * &quot;Split ISO TDs&quot; ... used for USB 1.1 devices going through the&n; * TTs in USB 2.0 hubs.  These need microframe scheduling.&n; */
r_static
r_inline
r_void
DECL|function|sitd_sched_init
id|sitd_sched_init
(paren
r_struct
id|ehci_iso_sched
op_star
id|iso_sched
comma
r_struct
id|ehci_iso_stream
op_star
id|stream
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
id|i
suffix:semicolon
id|dma_addr_t
id|dma
op_assign
id|urb-&gt;transfer_dma
suffix:semicolon
multiline_comment|/* how many frames are needed for these transfers */
id|iso_sched-&gt;span
op_assign
id|urb-&gt;number_of_packets
op_star
id|stream-&gt;interval
suffix:semicolon
multiline_comment|/* figure out per-frame sitd fields that we&squot;ll need later&n;&t; * when we fit new sitds into the schedule.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ehci_iso_packet
op_star
id|packet
op_assign
op_amp
id|iso_sched-&gt;packet
(braket
id|i
)braket
suffix:semicolon
r_int
id|length
suffix:semicolon
id|dma_addr_t
id|buf
suffix:semicolon
id|u32
id|trans
suffix:semicolon
id|length
op_assign
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|length
op_amp
l_int|0x03ff
suffix:semicolon
id|buf
op_assign
id|dma
op_plus
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|offset
suffix:semicolon
id|trans
op_assign
id|SITD_STS_ACTIVE
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|i
op_plus
l_int|1
)paren
op_eq
id|urb-&gt;number_of_packets
)paren
op_logical_and
op_logical_neg
(paren
id|urb-&gt;transfer_flags
op_amp
id|URB_NO_INTERRUPT
)paren
)paren
id|trans
op_or_assign
id|SITD_IOC
suffix:semicolon
id|trans
op_or_assign
id|length
op_lshift
l_int|16
suffix:semicolon
id|packet-&gt;transaction
op_assign
id|cpu_to_le32
(paren
id|trans
)paren
suffix:semicolon
multiline_comment|/* might need to cross a buffer page within a td */
id|packet-&gt;bufp
op_assign
id|buf
suffix:semicolon
id|buf
op_add_assign
id|length
suffix:semicolon
id|packet-&gt;buf1
op_assign
id|buf
op_amp
op_complement
l_int|0x0fff
suffix:semicolon
r_if
c_cond
(paren
id|packet-&gt;buf1
op_ne
(paren
id|buf
op_amp
op_complement
(paren
id|u64
)paren
l_int|0x0fff
)paren
)paren
id|packet-&gt;cross
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* OUT uses multiple start-splits */
r_if
c_cond
(paren
id|stream-&gt;bEndpointAddress
op_amp
id|USB_DIR_IN
)paren
r_continue
suffix:semicolon
id|length
op_assign
l_int|1
op_plus
(paren
id|length
op_div
l_int|188
)paren
suffix:semicolon
id|packet-&gt;buf1
op_or_assign
id|length
suffix:semicolon
r_if
c_cond
(paren
id|length
OG
l_int|1
)paren
multiline_comment|/* BEGIN vs ALL */
id|packet-&gt;buf1
op_or_assign
l_int|1
op_lshift
l_int|3
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|sitd_urb_transaction
id|sitd_urb_transaction
(paren
r_struct
id|ehci_iso_stream
op_star
id|stream
comma
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|mem_flags
)paren
(brace
r_struct
id|ehci_sitd
op_star
id|sitd
suffix:semicolon
id|dma_addr_t
id|sitd_dma
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|ehci_iso_sched
op_star
id|iso_sched
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|iso_sched
op_assign
id|iso_sched_alloc
(paren
id|urb-&gt;number_of_packets
comma
id|mem_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iso_sched
op_eq
l_int|0
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|sitd_sched_init
(paren
id|iso_sched
comma
id|stream
comma
id|urb
)paren
suffix:semicolon
multiline_comment|/* allocate/init sITDs */
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* NOTE:  for now, we don&squot;t try to handle wraparound cases&n;&t;&t; * for IN (using sitd-&gt;hw_backpointer, like a FSTN), which&n;&t;&t; * means we never need two sitds for full speed packets.&n;&t;&t; */
multiline_comment|/* free_list.next might be cache-hot ... but maybe&n;&t;&t; * the HC caches it too. avoid that issue for now.&n;&t;&t; */
multiline_comment|/* prefer previously-allocated sitds */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|stream-&gt;free_list
)paren
)paren
(brace
id|sitd
op_assign
id|list_entry
(paren
id|stream-&gt;free_list.prev
comma
r_struct
id|ehci_sitd
comma
id|sitd_list
)paren
suffix:semicolon
id|list_del
(paren
op_amp
id|sitd-&gt;sitd_list
)paren
suffix:semicolon
id|sitd_dma
op_assign
id|sitd-&gt;sitd_dma
suffix:semicolon
)brace
r_else
id|sitd
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sitd
)paren
(brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|sitd
op_assign
id|dma_pool_alloc
(paren
id|ehci-&gt;sitd_pool
comma
id|mem_flags
comma
op_amp
id|sitd_dma
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sitd
)paren
(brace
id|iso_sched_free
(paren
id|stream
comma
id|iso_sched
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
(paren
id|sitd
comma
l_int|0
comma
r_sizeof
op_star
id|sitd
)paren
suffix:semicolon
id|sitd-&gt;sitd_dma
op_assign
id|sitd_dma
suffix:semicolon
id|list_add
(paren
op_amp
id|sitd-&gt;sitd_list
comma
op_amp
id|iso_sched-&gt;td_list
)paren
suffix:semicolon
)brace
multiline_comment|/* temporarily store schedule info in hcpriv */
id|urb-&gt;hcpriv
op_assign
id|iso_sched
suffix:semicolon
id|urb-&gt;error_count
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
r_static
r_inline
r_void
DECL|function|sitd_patch
id|sitd_patch
(paren
r_struct
id|ehci_iso_stream
op_star
id|stream
comma
r_struct
id|ehci_sitd
op_star
id|sitd
comma
r_struct
id|ehci_iso_sched
op_star
id|iso_sched
comma
r_int
id|index
)paren
(brace
r_struct
id|ehci_iso_packet
op_star
id|uf
op_assign
op_amp
id|iso_sched-&gt;packet
(braket
id|index
)braket
suffix:semicolon
id|u64
id|bufp
op_assign
id|uf-&gt;bufp
suffix:semicolon
id|sitd-&gt;hw_next
op_assign
id|EHCI_LIST_END
suffix:semicolon
id|sitd-&gt;hw_fullspeed_ep
op_assign
id|stream-&gt;address
suffix:semicolon
id|sitd-&gt;hw_uframe
op_assign
id|stream-&gt;splits
suffix:semicolon
id|sitd-&gt;hw_results
op_assign
id|uf-&gt;transaction
suffix:semicolon
id|sitd-&gt;hw_backpointer
op_assign
id|EHCI_LIST_END
suffix:semicolon
id|bufp
op_assign
id|uf-&gt;bufp
suffix:semicolon
id|sitd-&gt;hw_buf
(braket
l_int|0
)braket
op_assign
id|cpu_to_le32
(paren
id|bufp
)paren
suffix:semicolon
id|sitd-&gt;hw_buf_hi
(braket
l_int|0
)braket
op_assign
id|cpu_to_le32
(paren
id|bufp
op_rshift
l_int|32
)paren
suffix:semicolon
id|sitd-&gt;hw_buf
(braket
l_int|1
)braket
op_assign
id|cpu_to_le32
(paren
id|uf-&gt;buf1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uf-&gt;cross
)paren
(brace
id|bufp
op_add_assign
l_int|4096
suffix:semicolon
id|sitd-&gt;hw_buf_hi
(braket
l_int|1
)braket
op_assign
id|cpu_to_le32
(paren
id|bufp
op_rshift
l_int|32
)paren
suffix:semicolon
)brace
id|sitd-&gt;index
op_assign
id|index
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|sitd_link
id|sitd_link
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_int
id|frame
comma
r_struct
id|ehci_sitd
op_star
id|sitd
)paren
(brace
multiline_comment|/* note: sitd ordering could matter (CSPLIT then SSPLIT) */
id|sitd-&gt;sitd_next
op_assign
id|ehci-&gt;pshadow
(braket
id|frame
)braket
suffix:semicolon
id|sitd-&gt;hw_next
op_assign
id|ehci-&gt;periodic
(braket
id|frame
)braket
suffix:semicolon
id|ehci-&gt;pshadow
(braket
id|frame
)braket
dot
id|sitd
op_assign
id|sitd
suffix:semicolon
id|sitd-&gt;frame
op_assign
id|frame
suffix:semicolon
id|wmb
(paren
)paren
suffix:semicolon
id|ehci-&gt;periodic
(braket
id|frame
)braket
op_assign
id|cpu_to_le32
(paren
id|sitd-&gt;sitd_dma
)paren
op_or
id|Q_TYPE_SITD
suffix:semicolon
)brace
multiline_comment|/* fit urb&squot;s sitds into the selected schedule slot; activate as needed */
r_static
r_int
DECL|function|sitd_link_urb
id|sitd_link_urb
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|mod
comma
r_struct
id|ehci_iso_stream
op_star
id|stream
)paren
(brace
r_int
id|packet
suffix:semicolon
r_int
id|next_uframe
suffix:semicolon
r_struct
id|ehci_iso_sched
op_star
id|sched
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
r_struct
id|ehci_sitd
op_star
id|sitd
suffix:semicolon
id|next_uframe
op_assign
id|stream-&gt;next_uframe
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|stream-&gt;td_list
)paren
)paren
(brace
multiline_comment|/* usbfs ignores TT bandwidth */
id|hcd_to_bus
(paren
op_amp
id|ehci-&gt;hcd
)paren
op_member_access_from_pointer
id|bandwidth_allocated
op_add_assign
id|stream-&gt;bandwidth
suffix:semicolon
id|ehci_vdbg
(paren
id|ehci
comma
l_string|&quot;sched dev%s ep%d%s-iso [%d] %dms/%04x&bslash;n&quot;
comma
id|urb-&gt;dev-&gt;devpath
comma
id|stream-&gt;bEndpointAddress
op_amp
l_int|0x0f
comma
(paren
id|stream-&gt;bEndpointAddress
op_amp
id|USB_DIR_IN
)paren
ques
c_cond
l_string|&quot;in&quot;
suffix:colon
l_string|&quot;out&quot;
comma
(paren
id|next_uframe
op_rshift
l_int|3
)paren
op_mod
id|ehci-&gt;periodic_size
comma
id|stream-&gt;interval
comma
id|le32_to_cpu
(paren
id|stream-&gt;splits
)paren
)paren
suffix:semicolon
id|stream-&gt;start
op_assign
id|jiffies
suffix:semicolon
)brace
id|hcd_to_bus
(paren
op_amp
id|ehci-&gt;hcd
)paren
op_member_access_from_pointer
id|bandwidth_isoc_reqs
op_increment
suffix:semicolon
multiline_comment|/* fill sITDs frame by frame */
r_for
c_loop
(paren
id|packet
op_assign
l_int|0
comma
id|sitd
op_assign
l_int|NULL
suffix:semicolon
id|packet
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|packet
op_increment
)paren
(brace
multiline_comment|/* ASSERT:  we have all necessary sitds */
id|BUG_ON
(paren
id|list_empty
(paren
op_amp
id|sched-&gt;td_list
)paren
)paren
suffix:semicolon
multiline_comment|/* ASSERT:  no itds for this endpoint in this frame */
id|sitd
op_assign
id|list_entry
(paren
id|sched-&gt;td_list.next
comma
r_struct
id|ehci_sitd
comma
id|sitd_list
)paren
suffix:semicolon
id|list_move_tail
(paren
op_amp
id|sitd-&gt;sitd_list
comma
op_amp
id|stream-&gt;td_list
)paren
suffix:semicolon
id|sitd-&gt;stream
op_assign
id|iso_stream_get
(paren
id|stream
)paren
suffix:semicolon
id|sitd-&gt;urb
op_assign
id|usb_get_urb
(paren
id|urb
)paren
suffix:semicolon
id|sitd_patch
(paren
id|stream
comma
id|sitd
comma
id|sched
comma
id|packet
)paren
suffix:semicolon
id|sitd_link
(paren
id|ehci
comma
(paren
id|next_uframe
op_rshift
l_int|3
)paren
op_mod
id|ehci-&gt;periodic_size
comma
id|sitd
)paren
suffix:semicolon
id|next_uframe
op_add_assign
id|stream-&gt;interval
op_lshift
l_int|3
suffix:semicolon
id|stream-&gt;depth
op_add_assign
id|stream-&gt;interval
op_lshift
l_int|3
suffix:semicolon
)brace
id|stream-&gt;next_uframe
op_assign
id|next_uframe
op_mod
id|mod
suffix:semicolon
multiline_comment|/* don&squot;t need that schedule data any more */
id|iso_sched_free
(paren
id|stream
comma
id|sched
)paren
suffix:semicolon
id|urb-&gt;hcpriv
op_assign
l_int|NULL
suffix:semicolon
id|timer_action
(paren
id|ehci
comma
id|TIMER_IO_WATCHDOG
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ehci-&gt;periodic_sched
op_increment
)paren
r_return
id|enable_periodic
(paren
id|ehci
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|macro|SITD_ERRS
mdefine_line|#define&t;SITD_ERRS (SITD_STS_ERR | SITD_STS_DBE | SITD_STS_BABBLE &bslash;&n;&t;&t;&t;| SITD_STS_XACT | SITD_STS_MMF | SITD_STS_STS)
r_static
r_int
DECL|function|sitd_complete
id|sitd_complete
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|ehci_sitd
op_star
id|sitd
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|urb
op_star
id|urb
op_assign
id|sitd-&gt;urb
suffix:semicolon
r_struct
id|usb_iso_packet_descriptor
op_star
id|desc
suffix:semicolon
id|u32
id|t
suffix:semicolon
r_int
id|urb_index
op_assign
op_minus
l_int|1
suffix:semicolon
r_struct
id|ehci_iso_stream
op_star
id|stream
op_assign
id|sitd-&gt;stream
suffix:semicolon
r_struct
id|usb_device
op_star
id|dev
suffix:semicolon
id|urb_index
op_assign
id|sitd-&gt;index
suffix:semicolon
id|desc
op_assign
op_amp
id|urb-&gt;iso_frame_desc
(braket
id|urb_index
)braket
suffix:semicolon
id|t
op_assign
id|le32_to_cpup
(paren
op_amp
id|sitd-&gt;hw_results
)paren
suffix:semicolon
multiline_comment|/* report transfer status */
r_if
c_cond
(paren
id|t
op_amp
id|SITD_ERRS
)paren
(brace
id|urb-&gt;error_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|t
op_amp
id|SITD_STS_DBE
)paren
id|desc-&gt;status
op_assign
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
ques
c_cond
op_minus
id|ENOSR
multiline_comment|/* hc couldn&squot;t read */
suffix:colon
op_minus
id|ECOMM
suffix:semicolon
multiline_comment|/* hc couldn&squot;t write */
r_else
r_if
c_cond
(paren
id|t
op_amp
id|SITD_STS_BABBLE
)paren
id|desc-&gt;status
op_assign
op_minus
id|EOVERFLOW
suffix:semicolon
r_else
multiline_comment|/* XACT, MMF, etc */
id|desc-&gt;status
op_assign
op_minus
id|EPROTO
suffix:semicolon
)brace
r_else
(brace
id|desc-&gt;status
op_assign
l_int|0
suffix:semicolon
id|desc-&gt;actual_length
op_assign
id|desc-&gt;length
op_minus
id|SITD_LENGTH
(paren
id|t
)paren
suffix:semicolon
)brace
id|usb_put_urb
(paren
id|urb
)paren
suffix:semicolon
id|sitd-&gt;urb
op_assign
l_int|NULL
suffix:semicolon
id|sitd-&gt;stream
op_assign
l_int|NULL
suffix:semicolon
id|list_move
(paren
op_amp
id|sitd-&gt;sitd_list
comma
op_amp
id|stream-&gt;free_list
)paren
suffix:semicolon
id|stream-&gt;depth
op_sub_assign
id|stream-&gt;interval
op_lshift
l_int|3
suffix:semicolon
id|iso_stream_put
(paren
id|ehci
comma
id|stream
)paren
suffix:semicolon
multiline_comment|/* handle completion now? */
r_if
c_cond
(paren
(paren
id|urb_index
op_plus
l_int|1
)paren
op_ne
id|urb-&gt;number_of_packets
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* ASSERT: it&squot;s really the last sitd for this urb&n;&t;list_for_each_entry (sitd, &amp;stream-&gt;td_list, sitd_list)&n;&t;&t;BUG_ON (sitd-&gt;urb == urb);&n;&t; */
multiline_comment|/* give urb back to the driver */
id|dev
op_assign
id|usb_get_dev
(paren
id|urb-&gt;dev
)paren
suffix:semicolon
id|ehci_urb_done
(paren
id|ehci
comma
id|urb
comma
id|regs
)paren
suffix:semicolon
id|urb
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* defer stopping schedule; completion can submit */
id|ehci-&gt;periodic_sched
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ehci-&gt;periodic_sched
)paren
(paren
r_void
)paren
id|disable_periodic
(paren
id|ehci
)paren
suffix:semicolon
id|hcd_to_bus
(paren
op_amp
id|ehci-&gt;hcd
)paren
op_member_access_from_pointer
id|bandwidth_isoc_reqs
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
(paren
op_amp
id|stream-&gt;td_list
)paren
)paren
(brace
id|hcd_to_bus
(paren
op_amp
id|ehci-&gt;hcd
)paren
op_member_access_from_pointer
id|bandwidth_allocated
op_sub_assign
id|stream-&gt;bandwidth
suffix:semicolon
id|ehci_vdbg
(paren
id|ehci
comma
l_string|&quot;deschedule devp %s ep%d%s-iso&bslash;n&quot;
comma
id|dev-&gt;devpath
comma
id|stream-&gt;bEndpointAddress
op_amp
l_int|0x0f
comma
(paren
id|stream-&gt;bEndpointAddress
op_amp
id|USB_DIR_IN
)paren
ques
c_cond
l_string|&quot;in&quot;
suffix:colon
l_string|&quot;out&quot;
)paren
suffix:semicolon
)brace
id|iso_stream_put
(paren
id|ehci
comma
id|stream
)paren
suffix:semicolon
id|usb_put_dev
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|sitd_submit
r_static
r_int
id|sitd_submit
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|mem_flags
)paren
(brace
r_int
id|status
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|ehci_iso_stream
op_star
id|stream
suffix:semicolon
singleline_comment|// FIXME remove when csplits behave
r_if
c_cond
(paren
id|usb_pipein
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
id|ehci_dbg
(paren
id|ehci
comma
l_string|&quot;no iso-IN split transactions yet&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Get iso_stream head */
id|stream
op_assign
id|iso_stream_find
(paren
id|ehci
comma
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stream
op_eq
l_int|0
)paren
(brace
id|ehci_dbg
(paren
id|ehci
comma
l_string|&quot;can&squot;t get iso stream&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|urb-&gt;interval
op_ne
id|stream-&gt;interval
)paren
(brace
id|ehci_dbg
(paren
id|ehci
comma
l_string|&quot;can&squot;t change iso interval %d --&gt; %d&bslash;n&quot;
comma
id|stream-&gt;interval
comma
id|urb-&gt;interval
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
macro_line|#ifdef EHCI_URB_TRACE
id|ehci_dbg
(paren
id|ehci
comma
l_string|&quot;submit %p dev%s ep%d%s-iso len %d&bslash;n&quot;
comma
id|urb
comma
id|urb-&gt;dev-&gt;devpath
comma
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
comma
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
ques
c_cond
l_string|&quot;in&quot;
suffix:colon
l_string|&quot;out&quot;
comma
id|urb-&gt;transfer_buffer_length
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* allocate SITDs */
id|status
op_assign
id|sitd_urb_transaction
(paren
id|stream
comma
id|ehci
comma
id|urb
comma
id|mem_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
id|ehci_dbg
(paren
id|ehci
comma
l_string|&quot;can&squot;t init sitds&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/* schedule ... need to lock */
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|status
op_assign
id|iso_stream_schedule
(paren
id|ehci
comma
id|urb
comma
id|stream
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
l_int|0
)paren
id|sitd_link_urb
(paren
id|ehci
comma
id|urb
comma
id|ehci-&gt;periodic_size
op_lshift
l_int|3
comma
id|stream
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|done
suffix:colon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
id|iso_stream_put
(paren
id|ehci
comma
id|stream
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
macro_line|#else
r_static
r_inline
r_int
DECL|function|sitd_submit
id|sitd_submit
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|mem_flags
)paren
(brace
id|ehci_dbg
(paren
id|ehci
comma
l_string|&quot;split iso support is disabled&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|sitd_complete
id|sitd_complete
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|ehci_sitd
op_star
id|sitd
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|ehci_err
(paren
id|ehci
comma
l_string|&quot;sitd_complete %p?&bslash;n&quot;
comma
id|sitd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* USB_EHCI_SPLIT_ISO */
multiline_comment|/*-------------------------------------------------------------------------*/
r_static
r_void
DECL|function|scan_periodic
id|scan_periodic
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|frame
comma
id|clock
comma
id|now_uframe
comma
id|mod
suffix:semicolon
r_int
id|modified
suffix:semicolon
id|mod
op_assign
id|ehci-&gt;periodic_size
op_lshift
l_int|3
suffix:semicolon
multiline_comment|/*&n;&t; * When running, scan from last scan point up to &quot;now&quot;&n;&t; * else clean up by scanning everything that&squot;s left.&n;&t; * Touches as few pages as possible:  cache-friendly.&n;&t; */
id|now_uframe
op_assign
id|ehci-&gt;next_uframe
suffix:semicolon
r_if
c_cond
(paren
id|HCD_IS_RUNNING
(paren
id|ehci-&gt;hcd.state
)paren
)paren
id|clock
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;frame_index
)paren
suffix:semicolon
r_else
id|clock
op_assign
id|now_uframe
op_plus
id|mod
op_minus
l_int|1
suffix:semicolon
id|clock
op_mod_assign
id|mod
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_union
id|ehci_shadow
id|q
comma
op_star
id|q_p
suffix:semicolon
id|__le32
id|type
comma
op_star
id|hw_p
suffix:semicolon
r_int
id|uframes
suffix:semicolon
multiline_comment|/* don&squot;t scan past the live uframe */
id|frame
op_assign
id|now_uframe
op_rshift
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|frame
op_eq
(paren
id|clock
op_rshift
l_int|3
)paren
)paren
id|uframes
op_assign
id|now_uframe
op_amp
l_int|0x07
suffix:semicolon
r_else
(brace
multiline_comment|/* safe to scan the whole frame at once */
id|now_uframe
op_or_assign
l_int|0x07
suffix:semicolon
id|uframes
op_assign
l_int|8
suffix:semicolon
)brace
id|restart
suffix:colon
multiline_comment|/* scan each element in frame&squot;s queue for completions */
id|q_p
op_assign
op_amp
id|ehci-&gt;pshadow
(braket
id|frame
)braket
suffix:semicolon
id|hw_p
op_assign
op_amp
id|ehci-&gt;periodic
(braket
id|frame
)braket
suffix:semicolon
id|q.ptr
op_assign
id|q_p-&gt;ptr
suffix:semicolon
id|type
op_assign
id|Q_NEXT_TYPE
(paren
op_star
id|hw_p
)paren
suffix:semicolon
id|modified
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|q.ptr
op_ne
l_int|0
)paren
(brace
r_int
id|uf
suffix:semicolon
r_union
id|ehci_shadow
id|temp
suffix:semicolon
r_int
id|live
suffix:semicolon
id|live
op_assign
id|HCD_IS_RUNNING
(paren
id|ehci-&gt;hcd.state
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|Q_TYPE_QH
suffix:colon
multiline_comment|/* handle any completions */
id|temp.qh
op_assign
id|qh_get
(paren
id|q.qh
)paren
suffix:semicolon
id|type
op_assign
id|Q_NEXT_TYPE
(paren
id|q.qh-&gt;hw_next
)paren
suffix:semicolon
id|q
op_assign
id|q.qh-&gt;qh_next
suffix:semicolon
id|modified
op_assign
id|qh_completions
(paren
id|ehci
comma
id|temp.qh
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
id|list_empty
(paren
op_amp
id|temp.qh-&gt;qtd_list
)paren
)paren
)paren
id|intr_deschedule
(paren
id|ehci
comma
id|temp.qh
comma
l_int|0
)paren
suffix:semicolon
id|qh_put
(paren
id|temp.qh
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|Q_TYPE_FSTN
suffix:colon
multiline_comment|/* for &quot;save place&quot; FSTNs, look at QH entries&n;&t;&t;&t;&t; * in the previous frame for completions.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|q.fstn-&gt;hw_prev
op_ne
id|EHCI_LIST_END
)paren
(brace
id|dbg
(paren
l_string|&quot;ignoring completions from FSTNs&quot;
)paren
suffix:semicolon
)brace
id|type
op_assign
id|Q_NEXT_TYPE
(paren
id|q.fstn-&gt;hw_next
)paren
suffix:semicolon
id|q
op_assign
id|q.fstn-&gt;fstn_next
suffix:semicolon
r_break
suffix:semicolon
r_case
id|Q_TYPE_ITD
suffix:colon
multiline_comment|/* skip itds for later in the frame */
id|rmb
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|uf
op_assign
id|live
ques
c_cond
id|uframes
suffix:colon
l_int|8
suffix:semicolon
id|uf
OL
l_int|8
suffix:semicolon
id|uf
op_increment
)paren
(brace
r_if
c_cond
(paren
l_int|0
op_eq
(paren
id|q.itd-&gt;hw_transaction
(braket
id|uf
)braket
op_amp
id|ITD_ACTIVE
)paren
)paren
r_continue
suffix:semicolon
id|q_p
op_assign
op_amp
id|q.itd-&gt;itd_next
suffix:semicolon
id|hw_p
op_assign
op_amp
id|q.itd-&gt;hw_next
suffix:semicolon
id|type
op_assign
id|Q_NEXT_TYPE
(paren
id|q.itd-&gt;hw_next
)paren
suffix:semicolon
id|q
op_assign
op_star
id|q_p
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uf
op_ne
l_int|8
)paren
r_break
suffix:semicolon
multiline_comment|/* this one&squot;s ready ... HC won&squot;t cache the&n;&t;&t;&t;&t; * pointer for much longer, if at all.&n;&t;&t;&t;&t; */
op_star
id|q_p
op_assign
id|q.itd-&gt;itd_next
suffix:semicolon
op_star
id|hw_p
op_assign
id|q.itd-&gt;hw_next
suffix:semicolon
id|type
op_assign
id|Q_NEXT_TYPE
(paren
id|q.itd-&gt;hw_next
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|modified
op_assign
id|itd_complete
(paren
id|ehci
comma
id|q.itd
comma
id|regs
)paren
suffix:semicolon
id|q
op_assign
op_star
id|q_p
suffix:semicolon
r_break
suffix:semicolon
r_case
id|Q_TYPE_SITD
suffix:colon
r_if
c_cond
(paren
(paren
id|q.sitd-&gt;hw_results
op_amp
id|SITD_ACTIVE
)paren
op_logical_and
id|live
)paren
(brace
id|q_p
op_assign
op_amp
id|q.sitd-&gt;sitd_next
suffix:semicolon
id|hw_p
op_assign
op_amp
id|q.sitd-&gt;hw_next
suffix:semicolon
id|type
op_assign
id|Q_NEXT_TYPE
(paren
id|q.sitd-&gt;hw_next
)paren
suffix:semicolon
id|q
op_assign
op_star
id|q_p
suffix:semicolon
r_break
suffix:semicolon
)brace
op_star
id|q_p
op_assign
id|q.sitd-&gt;sitd_next
suffix:semicolon
op_star
id|hw_p
op_assign
id|q.sitd-&gt;hw_next
suffix:semicolon
id|type
op_assign
id|Q_NEXT_TYPE
(paren
id|q.sitd-&gt;hw_next
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|modified
op_assign
id|sitd_complete
(paren
id|ehci
comma
id|q.sitd
comma
id|regs
)paren
suffix:semicolon
id|q
op_assign
op_star
id|q_p
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|dbg
(paren
l_string|&quot;corrupt type %d frame %d shadow %p&quot;
comma
id|type
comma
id|frame
comma
id|q.ptr
)paren
suffix:semicolon
singleline_comment|// BUG ();
id|q.ptr
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* assume completion callbacks modify the queue */
r_if
c_cond
(paren
id|unlikely
(paren
id|modified
)paren
)paren
r_goto
id|restart
suffix:semicolon
)brace
multiline_comment|/* stop when we catch up to the HC */
singleline_comment|// FIXME:  this assumes we won&squot;t get lapped when
singleline_comment|// latencies climb; that should be rare, but...
singleline_comment|// detect it, and just go all the way around.
singleline_comment|// FLR might help detect this case, so long as latencies
singleline_comment|// don&squot;t exceed periodic_size msec (default 1.024 sec).
singleline_comment|// FIXME:  likewise assumes HC doesn&squot;t halt mid-scan
r_if
c_cond
(paren
id|now_uframe
op_eq
id|clock
)paren
(brace
r_int
id|now
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|HCD_IS_RUNNING
(paren
id|ehci-&gt;hcd.state
)paren
)paren
r_break
suffix:semicolon
id|ehci-&gt;next_uframe
op_assign
id|now_uframe
suffix:semicolon
id|now
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;frame_index
)paren
op_mod
id|mod
suffix:semicolon
r_if
c_cond
(paren
id|now_uframe
op_eq
id|now
)paren
r_break
suffix:semicolon
multiline_comment|/* rescan the rest of this frame, then ... */
id|clock
op_assign
id|now
suffix:semicolon
)brace
r_else
(brace
id|now_uframe
op_increment
suffix:semicolon
id|now_uframe
op_mod_assign
id|mod
suffix:semicolon
)brace
)brace
)brace
eof
