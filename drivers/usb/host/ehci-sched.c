multiline_comment|/*&n; * Copyright (c) 2001-2002 by David Brownell&n; * &n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2 of the License, or (at your&n; * option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY&n; * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License&n; * for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software Foundation,&n; * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
multiline_comment|/* this file is part of ehci-hcd.c */
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * EHCI scheduled transaction support:  interrupt, iso, split iso&n; * These are called &quot;periodic&quot; transactions in the EHCI spec.&n; *&n; * Note that for interrupt transfers, the QH/QTD manipulation is shared&n; * with the &quot;asynchronous&quot; transaction support (control/bulk transfers).&n; * The only real difference is in how interrupt transfers are scheduled.&n; * We get some funky API restrictions from the current URB model, which&n; * works notably better for reading transfers than for writing.  (And&n; * which accordingly needs to change before it&squot;ll work inside devices,&n; * or with &quot;USB On The Go&quot; additions to USB 2.0 ...)&n; */
r_static
r_int
id|ehci_get_frame
(paren
r_struct
id|usb_hcd
op_star
id|hcd
)paren
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * periodic_next_shadow - return &quot;next&quot; pointer on shadow list&n; * @periodic: host pointer to qh/itd/sitd&n; * @tag: hardware tag for type of this record&n; */
r_static
r_union
id|ehci_shadow
op_star
DECL|function|periodic_next_shadow
id|periodic_next_shadow
(paren
r_union
id|ehci_shadow
op_star
id|periodic
comma
r_int
id|tag
)paren
(brace
r_switch
c_cond
(paren
id|tag
)paren
(brace
r_case
id|Q_TYPE_QH
suffix:colon
r_return
op_amp
id|periodic-&gt;qh-&gt;qh_next
suffix:semicolon
r_case
id|Q_TYPE_FSTN
suffix:colon
r_return
op_amp
id|periodic-&gt;fstn-&gt;fstn_next
suffix:semicolon
r_case
id|Q_TYPE_ITD
suffix:colon
r_return
op_amp
id|periodic-&gt;itd-&gt;itd_next
suffix:semicolon
macro_line|#ifdef have_split_iso
r_case
id|Q_TYPE_SITD
suffix:colon
r_return
op_amp
id|periodic-&gt;sitd-&gt;sitd_next
suffix:semicolon
macro_line|#endif /* have_split_iso */
)brace
id|dbg
(paren
l_string|&quot;BAD shadow %p tag %d&quot;
comma
id|periodic-&gt;ptr
comma
id|tag
)paren
suffix:semicolon
singleline_comment|// BUG ();
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* returns true after successful unlink */
multiline_comment|/* caller must hold ehci-&gt;lock */
DECL|function|periodic_unlink
r_static
r_int
id|periodic_unlink
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_int
id|frame
comma
r_void
op_star
id|ptr
)paren
(brace
r_union
id|ehci_shadow
op_star
id|prev_p
op_assign
op_amp
id|ehci-&gt;pshadow
(braket
id|frame
)braket
suffix:semicolon
id|u32
op_star
id|hw_p
op_assign
op_amp
id|ehci-&gt;periodic
(braket
id|frame
)braket
suffix:semicolon
r_union
id|ehci_shadow
id|here
op_assign
op_star
id|prev_p
suffix:semicolon
r_union
id|ehci_shadow
op_star
id|next_p
suffix:semicolon
multiline_comment|/* find predecessor of &quot;ptr&quot;; hw and shadow lists are in sync */
r_while
c_loop
(paren
id|here.ptr
op_logical_and
id|here.ptr
op_ne
id|ptr
)paren
(brace
id|prev_p
op_assign
id|periodic_next_shadow
(paren
id|prev_p
comma
id|Q_NEXT_TYPE
(paren
op_star
id|hw_p
)paren
)paren
suffix:semicolon
id|hw_p
op_assign
op_amp
id|here.qh-&gt;hw_next
suffix:semicolon
id|here
op_assign
op_star
id|prev_p
suffix:semicolon
)brace
multiline_comment|/* an interrupt entry (at list end) could have been shared */
r_if
c_cond
(paren
op_logical_neg
id|here.ptr
)paren
(brace
id|dbg
(paren
l_string|&quot;entry %p no longer on frame [%d]&quot;
comma
id|ptr
comma
id|frame
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|// vdbg (&quot;periodic unlink %p from frame %d&quot;, ptr, frame);
multiline_comment|/* update hardware list ... HC may still know the old structure, so&n;&t; * don&squot;t change hw_next until it&squot;ll have purged its cache&n;&t; */
id|next_p
op_assign
id|periodic_next_shadow
(paren
op_amp
id|here
comma
id|Q_NEXT_TYPE
(paren
op_star
id|hw_p
)paren
)paren
suffix:semicolon
op_star
id|hw_p
op_assign
id|here.qh-&gt;hw_next
suffix:semicolon
multiline_comment|/* unlink from shadow list; HCD won&squot;t see old structure again */
op_star
id|prev_p
op_assign
op_star
id|next_p
suffix:semicolon
id|next_p-&gt;ptr
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* how many of the uframe&squot;s 125 usecs are allocated? */
r_static
r_int
r_int
DECL|function|periodic_usecs
id|periodic_usecs
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_int
id|frame
comma
r_int
id|uframe
)paren
(brace
id|u32
op_star
id|hw_p
op_assign
op_amp
id|ehci-&gt;periodic
(braket
id|frame
)braket
suffix:semicolon
r_union
id|ehci_shadow
op_star
id|q
op_assign
op_amp
id|ehci-&gt;pshadow
(braket
id|frame
)braket
suffix:semicolon
r_int
id|usecs
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|q-&gt;ptr
)paren
(brace
r_switch
c_cond
(paren
id|Q_NEXT_TYPE
(paren
op_star
id|hw_p
)paren
)paren
(brace
r_case
id|Q_TYPE_QH
suffix:colon
multiline_comment|/* is it in the S-mask? */
r_if
c_cond
(paren
id|q-&gt;qh-&gt;hw_info2
op_amp
id|cpu_to_le32
(paren
l_int|1
op_lshift
id|uframe
)paren
)paren
id|usecs
op_add_assign
id|q-&gt;qh-&gt;usecs
suffix:semicolon
multiline_comment|/* ... or C-mask? */
r_if
c_cond
(paren
id|q-&gt;qh-&gt;hw_info2
op_amp
id|cpu_to_le32
(paren
l_int|1
op_lshift
(paren
l_int|8
op_plus
id|uframe
)paren
)paren
)paren
id|usecs
op_add_assign
id|q-&gt;qh-&gt;c_usecs
suffix:semicolon
id|q
op_assign
op_amp
id|q-&gt;qh-&gt;qh_next
suffix:semicolon
r_break
suffix:semicolon
r_case
id|Q_TYPE_FSTN
suffix:colon
multiline_comment|/* for &quot;save place&quot; FSTNs, count the relevant INTR&n;&t;&t;&t; * bandwidth from the previous frame&n;&t;&t;&t; */
r_if
c_cond
(paren
id|q-&gt;fstn-&gt;hw_prev
op_ne
id|EHCI_LIST_END
)paren
(brace
id|dbg
(paren
l_string|&quot;not counting FSTN bandwidth yet ...&quot;
)paren
suffix:semicolon
)brace
id|q
op_assign
op_amp
id|q-&gt;fstn-&gt;fstn_next
suffix:semicolon
r_break
suffix:semicolon
r_case
id|Q_TYPE_ITD
suffix:colon
multiline_comment|/* NOTE the &quot;one uframe per itd&quot; policy */
r_if
c_cond
(paren
id|q-&gt;itd-&gt;hw_transaction
(braket
id|uframe
)braket
op_ne
l_int|0
)paren
id|usecs
op_add_assign
id|q-&gt;itd-&gt;usecs
suffix:semicolon
id|q
op_assign
op_amp
id|q-&gt;itd-&gt;itd_next
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef have_split_iso
r_case
id|Q_TYPE_SITD
suffix:colon
id|temp
op_assign
id|q-&gt;sitd-&gt;hw_fullspeed_ep
op_amp
id|__constant_cpu_to_le32
(paren
l_int|1
op_lshift
l_int|31
)paren
suffix:semicolon
singleline_comment|// FIXME:  this doesn&squot;t count data bytes right...
multiline_comment|/* is it in the S-mask?  (count SPLIT, DATA) */
r_if
c_cond
(paren
id|q-&gt;sitd-&gt;hw_uframe
op_amp
id|cpu_to_le32
(paren
l_int|1
op_lshift
id|uframe
)paren
)paren
(brace
r_if
c_cond
(paren
id|temp
)paren
id|usecs
op_add_assign
id|HS_USECS
(paren
l_int|188
)paren
suffix:semicolon
r_else
id|usecs
op_add_assign
id|HS_USECS
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* ... C-mask?  (count CSPLIT, DATA) */
r_if
c_cond
(paren
id|q-&gt;sitd-&gt;hw_uframe
op_amp
id|cpu_to_le32
(paren
l_int|1
op_lshift
(paren
l_int|8
op_plus
id|uframe
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|temp
)paren
id|usecs
op_add_assign
id|HS_USECS
(paren
l_int|0
)paren
suffix:semicolon
r_else
id|usecs
op_add_assign
id|HS_USECS
(paren
l_int|188
)paren
suffix:semicolon
)brace
id|q
op_assign
op_amp
id|q-&gt;sitd-&gt;sitd_next
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /* have_split_iso */
r_default
suffix:colon
id|BUG
(paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef&t;DEBUG
r_if
c_cond
(paren
id|usecs
OG
l_int|100
)paren
id|err
(paren
l_string|&quot;overallocated uframe %d, periodic is %d usecs&quot;
comma
id|frame
op_star
l_int|8
op_plus
id|uframe
comma
id|usecs
)paren
suffix:semicolon
macro_line|#endif
r_return
id|usecs
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|enable_periodic
r_static
r_int
id|enable_periodic
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
)paren
(brace
id|u32
id|cmd
suffix:semicolon
r_int
id|status
suffix:semicolon
multiline_comment|/* did clearing PSE did take effect yet?&n;&t; * takes effect only at frame boundaries...&n;&t; */
id|status
op_assign
id|handshake
(paren
op_amp
id|ehci-&gt;regs-&gt;status
comma
id|STS_PSS
comma
l_int|0
comma
l_int|9
op_star
l_int|125
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
l_int|0
)paren
(brace
id|ehci-&gt;hcd.state
op_assign
id|USB_STATE_HALT
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
id|cmd
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
op_or
id|CMD_PSE
suffix:semicolon
id|writel
(paren
id|cmd
comma
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
multiline_comment|/* posted write ... PSS happens later */
id|ehci-&gt;hcd.state
op_assign
id|USB_STATE_RUNNING
suffix:semicolon
multiline_comment|/* make sure tasklet scans these */
id|ehci-&gt;next_uframe
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;frame_index
)paren
op_mod
(paren
id|ehci-&gt;periodic_size
op_lshift
l_int|3
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|disable_periodic
r_static
r_int
id|disable_periodic
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
)paren
(brace
id|u32
id|cmd
suffix:semicolon
r_int
id|status
suffix:semicolon
multiline_comment|/* did setting PSE not take effect yet?&n;&t; * takes effect only at frame boundaries...&n;&t; */
id|status
op_assign
id|handshake
(paren
op_amp
id|ehci-&gt;regs-&gt;status
comma
id|STS_PSS
comma
id|STS_PSS
comma
l_int|9
op_star
l_int|125
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
l_int|0
)paren
(brace
id|ehci-&gt;hcd.state
op_assign
id|USB_STATE_HALT
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
id|cmd
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
op_amp
op_complement
id|CMD_PSE
suffix:semicolon
id|writel
(paren
id|cmd
comma
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
multiline_comment|/* posted write ... */
id|ehci-&gt;next_uframe
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
singleline_comment|// FIXME microframe periods not yet handled
DECL|function|intr_deschedule
r_static
r_void
id|intr_deschedule
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|ehci_qh
op_star
id|qh
comma
r_int
id|wait
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|frame
op_assign
id|qh-&gt;start
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_do
(brace
id|periodic_unlink
(paren
id|ehci
comma
id|frame
comma
id|qh
)paren
suffix:semicolon
id|qh_put
(paren
id|ehci
comma
id|qh
)paren
suffix:semicolon
id|frame
op_add_assign
id|qh-&gt;period
suffix:semicolon
)brace
r_while
c_loop
(paren
id|frame
OL
id|ehci-&gt;periodic_size
)paren
suffix:semicolon
id|qh-&gt;qh_state
op_assign
id|QH_STATE_UNLINK
suffix:semicolon
id|qh-&gt;qh_next.ptr
op_assign
l_int|0
suffix:semicolon
id|ehci-&gt;periodic_sched
op_decrement
suffix:semicolon
multiline_comment|/* maybe turn off periodic schedule */
r_if
c_cond
(paren
op_logical_neg
id|ehci-&gt;periodic_sched
)paren
id|status
op_assign
id|disable_periodic
(paren
id|ehci
)paren
suffix:semicolon
r_else
(brace
id|status
op_assign
l_int|0
suffix:semicolon
id|vdbg
(paren
l_string|&quot;periodic schedule still enabled&quot;
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the hc may be looking at this qh, then delay a uframe&n;&t; * (yeech!) to be sure it&squot;s done.&n;&t; * No other threads may be mucking with this qh.&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|ehci_get_frame
(paren
op_amp
id|ehci-&gt;hcd
)paren
op_minus
id|frame
)paren
op_mod
id|qh-&gt;period
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|wait
)paren
(brace
id|udelay
(paren
l_int|125
)paren
suffix:semicolon
id|qh-&gt;hw_next
op_assign
id|EHCI_LIST_END
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* we may not be IDLE yet, but if the qh is empty&n;&t;&t;&t; * the race is very short.  then if qh also isn&squot;t&n;&t;&t;&t; * rescheduled soon, it won&squot;t matter.  otherwise...&n;&t;&t;&t; */
id|vdbg
(paren
l_string|&quot;intr_deschedule...&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
id|qh-&gt;hw_next
op_assign
id|EHCI_LIST_END
suffix:semicolon
id|qh-&gt;qh_state
op_assign
id|QH_STATE_IDLE
suffix:semicolon
multiline_comment|/* update per-qh bandwidth utilization (for usbfs) */
id|ehci-&gt;hcd.self.bandwidth_allocated
op_sub_assign
(paren
id|qh-&gt;usecs
op_plus
id|qh-&gt;c_usecs
)paren
op_div
id|qh-&gt;period
suffix:semicolon
id|vdbg
(paren
l_string|&quot;descheduled qh %p, per = %d frame = %d count = %d, urbs = %d&quot;
comma
id|qh
comma
id|qh-&gt;period
comma
id|frame
comma
id|atomic_read
(paren
op_amp
id|qh-&gt;refcount
)paren
comma
id|ehci-&gt;periodic_sched
)paren
suffix:semicolon
)brace
DECL|function|check_period
r_static
r_int
id|check_period
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_int
id|frame
comma
r_int
id|uframe
comma
r_int
id|period
comma
r_int
id|usecs
)paren
(brace
multiline_comment|/* complete split running into next frame?&n;&t; * given FSTN support, we could sometimes check...&n;&t; */
r_if
c_cond
(paren
id|uframe
op_ge
l_int|8
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * 80% periodic == 100 usec/uframe available&n;&t; * convert &quot;usecs we need&quot; to &quot;max already claimed&quot; &n;&t; */
id|usecs
op_assign
l_int|100
op_minus
id|usecs
suffix:semicolon
r_do
(brace
r_int
id|claimed
suffix:semicolon
singleline_comment|// FIXME delete when intr_submit handles non-empty queues
singleline_comment|// this gives us a one intr/frame limit (vs N/uframe)
singleline_comment|// ... and also lets us avoid tracking split transactions
singleline_comment|// that might collide at a given TT/hub.
r_if
c_cond
(paren
id|ehci-&gt;pshadow
(braket
id|frame
)braket
dot
id|ptr
)paren
r_return
l_int|0
suffix:semicolon
id|claimed
op_assign
id|periodic_usecs
(paren
id|ehci
comma
id|frame
comma
id|uframe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|claimed
OG
id|usecs
)paren
r_return
l_int|0
suffix:semicolon
singleline_comment|// FIXME update to handle sub-frame periods
)brace
r_while
c_loop
(paren
(paren
id|frame
op_add_assign
id|period
)paren
OL
id|ehci-&gt;periodic_size
)paren
suffix:semicolon
singleline_comment|// success!
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|check_intr_schedule
r_static
r_int
id|check_intr_schedule
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_int
id|frame
comma
r_int
id|uframe
comma
r_const
r_struct
id|ehci_qh
op_star
id|qh
comma
id|u32
op_star
id|c_maskp
)paren
(brace
r_int
id|retval
op_assign
op_minus
id|ENOSPC
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|check_period
(paren
id|ehci
comma
id|frame
comma
id|uframe
comma
id|qh-&gt;period
comma
id|qh-&gt;usecs
)paren
)paren
r_goto
id|done
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|qh-&gt;c_usecs
)paren
(brace
id|retval
op_assign
l_int|0
suffix:semicolon
op_star
id|c_maskp
op_assign
id|cpu_to_le32
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/* This is a split transaction; check the bandwidth available for&n;&t; * the completion too.  Check both worst and best case gaps: worst&n;&t; * case is SPLIT near uframe end, and CSPLIT near start ... best is&n;&t; * vice versa.  Difference can be almost two uframe times, but we&n;&t; * reserve unnecessary bandwidth (waste it) this way.  (Actually&n;&t; * even better cases exist, like immediate device NAK.)&n;&t; *&n;&t; * FIXME don&squot;t even bother unless we know this TT is idle in that&n;&t; * range of uframes ... for now, check_period() allows only one&n;&t; * interrupt transfer per frame, so needn&squot;t check &quot;TT busy&quot; status&n;&t; * when scheduling a split (QH, SITD, or FSTN).&n;&t; *&n;&t; * FIXME ehci 0.96 and above can use FSTNs&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|check_period
(paren
id|ehci
comma
id|frame
comma
id|uframe
op_plus
id|qh-&gt;gap_uf
op_plus
l_int|1
comma
id|qh-&gt;period
comma
id|qh-&gt;c_usecs
)paren
)paren
r_goto
id|done
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|check_period
(paren
id|ehci
comma
id|frame
comma
id|uframe
op_plus
id|qh-&gt;gap_uf
comma
id|qh-&gt;period
comma
id|qh-&gt;c_usecs
)paren
)paren
r_goto
id|done
suffix:semicolon
op_star
id|c_maskp
op_assign
id|cpu_to_le32
(paren
l_int|0x03
op_lshift
(paren
l_int|8
op_plus
id|uframe
op_plus
id|qh-&gt;gap_uf
)paren
)paren
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
id|done
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|qh_schedule
r_static
r_int
id|qh_schedule
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|ehci_qh
op_star
id|qh
)paren
(brace
r_int
id|status
suffix:semicolon
r_int
id|uframe
suffix:semicolon
id|u32
id|c_mask
suffix:semicolon
r_int
id|frame
suffix:semicolon
multiline_comment|/* 0..(qh-&gt;period - 1), or NO_FRAME */
id|qh-&gt;hw_next
op_assign
id|EHCI_LIST_END
suffix:semicolon
id|frame
op_assign
id|qh-&gt;start
suffix:semicolon
multiline_comment|/* reuse the previous schedule slots, if we can */
r_if
c_cond
(paren
id|frame
OL
id|qh-&gt;period
)paren
(brace
id|uframe
op_assign
id|ffs
(paren
id|le32_to_cpup
(paren
op_amp
id|qh-&gt;hw_info2
)paren
op_amp
l_int|0x00ff
)paren
suffix:semicolon
id|status
op_assign
id|check_intr_schedule
(paren
id|ehci
comma
id|frame
comma
op_decrement
id|uframe
comma
id|qh
comma
op_amp
id|c_mask
)paren
suffix:semicolon
)brace
r_else
(brace
id|uframe
op_assign
l_int|0
suffix:semicolon
id|c_mask
op_assign
l_int|0
suffix:semicolon
id|status
op_assign
op_minus
id|ENOSPC
suffix:semicolon
)brace
multiline_comment|/* else scan the schedule to find a group of slots such that all&n;&t; * uframes have enough periodic bandwidth available.&n;&t; */
r_if
c_cond
(paren
id|status
)paren
(brace
id|frame
op_assign
id|qh-&gt;period
op_minus
l_int|1
suffix:semicolon
r_do
(brace
r_for
c_loop
(paren
id|uframe
op_assign
l_int|0
suffix:semicolon
id|uframe
OL
l_int|8
suffix:semicolon
id|uframe
op_increment
)paren
(brace
id|status
op_assign
id|check_intr_schedule
(paren
id|ehci
comma
id|frame
comma
id|uframe
comma
id|qh
comma
op_amp
id|c_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|status
op_logical_and
op_decrement
id|frame
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_goto
id|done
suffix:semicolon
id|qh-&gt;start
op_assign
id|frame
suffix:semicolon
multiline_comment|/* reset S-frame and (maybe) C-frame masks */
id|qh-&gt;hw_info2
op_and_assign
op_complement
l_int|0xffff
suffix:semicolon
id|qh-&gt;hw_info2
op_or_assign
id|cpu_to_le32
(paren
l_int|1
op_lshift
id|uframe
)paren
op_or
id|c_mask
suffix:semicolon
)brace
r_else
id|dbg
(paren
l_string|&quot;reused previous qh %p schedule&quot;
comma
id|qh
)paren
suffix:semicolon
multiline_comment|/* stuff into the periodic schedule */
id|qh-&gt;qh_state
op_assign
id|QH_STATE_LINKED
suffix:semicolon
id|dbg
(paren
l_string|&quot;qh %p usecs %d/%d period %d.0 starting %d.%d (gap %d)&quot;
comma
id|qh
comma
id|qh-&gt;usecs
comma
id|qh-&gt;c_usecs
comma
id|qh-&gt;period
comma
id|frame
comma
id|uframe
comma
id|qh-&gt;gap_uf
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|unlikely
(paren
id|ehci-&gt;pshadow
(braket
id|frame
)braket
dot
id|ptr
op_ne
l_int|0
)paren
)paren
(brace
singleline_comment|// FIXME -- just link toward the end, before any qh with a shorter period,
singleline_comment|// AND accomodate it already having been linked here (after some other qh)
singleline_comment|// AS WELL AS updating the schedule checking logic
id|BUG
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|ehci-&gt;pshadow
(braket
id|frame
)braket
dot
id|qh
op_assign
id|qh_get
(paren
id|qh
)paren
suffix:semicolon
id|ehci-&gt;periodic
(braket
id|frame
)braket
op_assign
id|QH_NEXT
(paren
id|qh-&gt;qh_dma
)paren
suffix:semicolon
)brace
id|wmb
(paren
)paren
suffix:semicolon
id|frame
op_add_assign
id|qh-&gt;period
suffix:semicolon
)brace
r_while
c_loop
(paren
id|frame
OL
id|ehci-&gt;periodic_size
)paren
suffix:semicolon
multiline_comment|/* update per-qh bandwidth for usbfs */
id|ehci-&gt;hcd.self.bandwidth_allocated
op_add_assign
(paren
id|qh-&gt;usecs
op_plus
id|qh-&gt;c_usecs
)paren
op_div
id|qh-&gt;period
suffix:semicolon
multiline_comment|/* maybe enable periodic schedule processing */
r_if
c_cond
(paren
op_logical_neg
id|ehci-&gt;periodic_sched
op_increment
)paren
id|status
op_assign
id|enable_periodic
(paren
id|ehci
)paren
suffix:semicolon
id|done
suffix:colon
r_return
id|status
suffix:semicolon
)brace
DECL|function|intr_submit
r_static
r_int
id|intr_submit
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|list_head
op_star
id|qtd_list
comma
r_int
id|mem_flags
)paren
(brace
r_int
id|epnum
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|ehci_qh
op_star
id|qh
suffix:semicolon
r_struct
id|hcd_dev
op_star
id|dev
suffix:semicolon
r_int
id|is_input
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
r_struct
id|list_head
id|empty
suffix:semicolon
multiline_comment|/* get endpoint and transfer/schedule data */
id|epnum
op_assign
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
id|is_input
op_assign
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_input
)paren
id|epnum
op_or_assign
l_int|0x10
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|dev
op_assign
(paren
r_struct
id|hcd_dev
op_star
)paren
id|urb-&gt;dev-&gt;hcpriv
suffix:semicolon
multiline_comment|/* get qh and force any scheduling errors */
id|INIT_LIST_HEAD
(paren
op_amp
id|empty
)paren
suffix:semicolon
id|qh
op_assign
id|qh_append_tds
(paren
id|ehci
comma
id|urb
comma
op_amp
id|empty
comma
id|epnum
comma
op_amp
id|dev-&gt;ep
(braket
id|epnum
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qh
op_eq
l_int|0
)paren
(brace
id|status
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|qh-&gt;qh_state
op_eq
id|QH_STATE_IDLE
)paren
(brace
r_if
c_cond
(paren
(paren
id|status
op_assign
id|qh_schedule
(paren
id|ehci
comma
id|qh
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/* then queue the urb&squot;s tds to the qh */
id|qh
op_assign
id|qh_append_tds
(paren
id|ehci
comma
id|urb
comma
id|qtd_list
comma
id|epnum
comma
op_amp
id|dev-&gt;ep
(braket
id|epnum
)braket
)paren
suffix:semicolon
id|BUG_ON
(paren
id|qh
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/* ... update usbfs periodic stats */
id|ehci-&gt;hcd.self.bandwidth_int_reqs
op_increment
suffix:semicolon
id|done
suffix:colon
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
id|qtd_list_free
(paren
id|ehci
comma
id|urb
comma
id|qtd_list
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
r_static
r_int
r_int
DECL|function|intr_complete
id|intr_complete
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_int
id|frame
comma
r_struct
id|ehci_qh
op_star
id|qh
comma
r_int
r_int
id|flags
multiline_comment|/* caller owns ehci-&gt;lock ... */
)paren
(brace
multiline_comment|/* nothing to report? */
r_if
c_cond
(paren
id|likely
(paren
(paren
id|qh-&gt;hw_token
op_amp
id|__constant_cpu_to_le32
(paren
id|QTD_STS_ACTIVE
)paren
)paren
op_ne
l_int|0
)paren
)paren
r_return
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
id|list_empty
(paren
op_amp
id|qh-&gt;qtd_list
)paren
)paren
)paren
(brace
id|dbg
(paren
l_string|&quot;intr qh %p no TDs?&quot;
comma
id|qh
)paren
suffix:semicolon
r_return
id|flags
suffix:semicolon
)brace
multiline_comment|/* handle any completions */
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|qh_completions
(paren
id|ehci
comma
id|qh
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
id|list_empty
(paren
op_amp
id|qh-&gt;qtd_list
)paren
)paren
)paren
id|intr_deschedule
(paren
id|ehci
comma
id|qh
comma
l_int|0
)paren
suffix:semicolon
r_return
id|flags
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
r_static
r_void
DECL|function|itd_free_list
id|itd_free_list
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|ehci_itd
op_star
id|first_itd
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|first_itd-&gt;itd_list
)paren
)paren
(brace
r_struct
id|ehci_itd
op_star
id|itd
suffix:semicolon
id|itd
op_assign
id|list_entry
(paren
id|first_itd-&gt;itd_list.next
comma
r_struct
id|ehci_itd
comma
id|itd_list
)paren
suffix:semicolon
id|list_del
(paren
op_amp
id|itd-&gt;itd_list
)paren
suffix:semicolon
id|pci_pool_free
(paren
id|ehci-&gt;itd_pool
comma
id|itd
comma
id|itd-&gt;itd_dma
)paren
suffix:semicolon
)brace
id|pci_pool_free
(paren
id|ehci-&gt;itd_pool
comma
id|first_itd
comma
id|first_itd-&gt;itd_dma
)paren
suffix:semicolon
id|urb-&gt;hcpriv
op_assign
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|itd_fill
id|itd_fill
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|ehci_itd
op_star
id|itd
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|index
comma
singleline_comment|// urb-&gt;iso_frame_desc [index]
id|dma_addr_t
id|dma
singleline_comment|// mapped transfer buffer
)paren
(brace
id|u64
id|temp
suffix:semicolon
id|u32
id|buf1
suffix:semicolon
r_int
id|i
comma
id|epnum
comma
id|maxp
comma
id|multi
suffix:semicolon
r_int
id|length
suffix:semicolon
r_int
id|is_input
suffix:semicolon
id|itd-&gt;hw_next
op_assign
id|EHCI_LIST_END
suffix:semicolon
id|itd-&gt;urb
op_assign
id|urb
suffix:semicolon
id|itd-&gt;index
op_assign
id|index
suffix:semicolon
multiline_comment|/* tell itd about its transfer buffer, max 2 pages */
id|length
op_assign
id|urb-&gt;iso_frame_desc
(braket
id|index
)braket
dot
id|length
suffix:semicolon
id|dma
op_add_assign
id|urb-&gt;iso_frame_desc
(braket
id|index
)braket
dot
id|offset
suffix:semicolon
id|temp
op_assign
id|dma
op_amp
op_complement
l_int|0x0fff
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
id|itd-&gt;hw_bufp
(braket
id|i
)braket
op_assign
id|cpu_to_le32
(paren
(paren
id|u32
)paren
id|temp
)paren
suffix:semicolon
id|itd-&gt;hw_bufp_hi
(braket
id|i
)braket
op_assign
id|cpu_to_le32
(paren
(paren
id|u32
)paren
(paren
id|temp
op_rshift
l_int|32
)paren
)paren
suffix:semicolon
id|temp
op_add_assign
l_int|0x1000
suffix:semicolon
)brace
id|itd-&gt;buf_dma
op_assign
id|dma
suffix:semicolon
multiline_comment|/*&n;&t; * this might be a &quot;high bandwidth&quot; highspeed endpoint,&n;&t; * as encoded in the ep descriptor&squot;s maxpacket field&n;&t; */
id|epnum
op_assign
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
id|is_input
op_assign
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_input
)paren
(brace
id|maxp
op_assign
id|urb-&gt;dev-&gt;epmaxpacketin
(braket
id|epnum
)braket
suffix:semicolon
id|buf1
op_assign
(paren
l_int|1
op_lshift
l_int|11
)paren
suffix:semicolon
)brace
r_else
(brace
id|maxp
op_assign
id|urb-&gt;dev-&gt;epmaxpacketout
(braket
id|epnum
)braket
suffix:semicolon
id|buf1
op_assign
l_int|0
suffix:semicolon
)brace
id|buf1
op_or_assign
(paren
id|maxp
op_amp
l_int|0x03ff
)paren
suffix:semicolon
id|multi
op_assign
l_int|1
suffix:semicolon
id|multi
op_add_assign
(paren
id|maxp
op_rshift
l_int|11
)paren
op_amp
l_int|0x03
suffix:semicolon
id|maxp
op_and_assign
l_int|0x03ff
suffix:semicolon
id|maxp
op_mul_assign
id|multi
suffix:semicolon
multiline_comment|/* transfer can&squot;t fit in any uframe? */
r_if
c_cond
(paren
id|length
OL
l_int|0
op_logical_or
id|maxp
OL
id|length
)paren
(brace
id|dbg
(paren
l_string|&quot;BAD iso packet: %d bytes, max %d, urb %p [%d] (of %d)&quot;
comma
id|length
comma
id|maxp
comma
id|urb
comma
id|index
comma
id|urb-&gt;iso_frame_desc
(braket
id|index
)braket
dot
id|length
)paren
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
id|itd-&gt;usecs
op_assign
id|usb_calc_bus_time
(paren
id|USB_SPEED_HIGH
comma
id|is_input
comma
l_int|1
comma
id|length
)paren
suffix:semicolon
multiline_comment|/* &quot;plus&quot; info in low order bits of buffer pointers */
id|itd-&gt;hw_bufp
(braket
l_int|0
)braket
op_or_assign
id|cpu_to_le32
(paren
(paren
id|epnum
op_lshift
l_int|8
)paren
op_or
id|urb-&gt;dev-&gt;devnum
)paren
suffix:semicolon
id|itd-&gt;hw_bufp
(braket
l_int|1
)braket
op_or_assign
id|cpu_to_le32
(paren
id|buf1
)paren
suffix:semicolon
id|itd-&gt;hw_bufp
(braket
l_int|2
)braket
op_or_assign
id|cpu_to_le32
(paren
id|multi
)paren
suffix:semicolon
multiline_comment|/* figure hw_transaction[] value (it&squot;s scheduled later) */
id|itd-&gt;transaction
op_assign
id|EHCI_ISOC_ACTIVE
suffix:semicolon
id|itd-&gt;transaction
op_or_assign
id|dma
op_amp
l_int|0x0fff
suffix:semicolon
multiline_comment|/* offset; buffer=0 */
r_if
c_cond
(paren
(paren
id|index
op_plus
l_int|1
)paren
op_eq
id|urb-&gt;number_of_packets
)paren
id|itd-&gt;transaction
op_or_assign
id|EHCI_ITD_IOC
suffix:semicolon
multiline_comment|/* end-of-urb irq */
id|itd-&gt;transaction
op_or_assign
id|length
op_lshift
l_int|16
suffix:semicolon
id|cpu_to_le32s
(paren
op_amp
id|itd-&gt;transaction
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|itd_urb_transaction
id|itd_urb_transaction
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|mem_flags
)paren
(brace
r_int
id|frame_index
suffix:semicolon
r_struct
id|ehci_itd
op_star
id|first_itd
comma
op_star
id|itd
suffix:semicolon
r_int
id|status
suffix:semicolon
id|dma_addr_t
id|itd_dma
suffix:semicolon
multiline_comment|/* allocate/init ITDs */
r_for
c_loop
(paren
id|frame_index
op_assign
l_int|0
comma
id|first_itd
op_assign
l_int|0
suffix:semicolon
id|frame_index
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|frame_index
op_increment
)paren
(brace
id|itd
op_assign
id|pci_pool_alloc
(paren
id|ehci-&gt;itd_pool
comma
id|mem_flags
comma
op_amp
id|itd_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|itd
)paren
(brace
id|status
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
id|memset
(paren
id|itd
comma
l_int|0
comma
r_sizeof
op_star
id|itd
)paren
suffix:semicolon
id|itd-&gt;itd_dma
op_assign
id|itd_dma
suffix:semicolon
id|status
op_assign
id|itd_fill
(paren
id|ehci
comma
id|itd
comma
id|urb
comma
id|frame_index
comma
id|urb-&gt;transfer_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
l_int|0
)paren
r_goto
id|fail
suffix:semicolon
r_if
c_cond
(paren
id|first_itd
)paren
id|list_add_tail
(paren
op_amp
id|itd-&gt;itd_list
comma
op_amp
id|first_itd-&gt;itd_list
)paren
suffix:semicolon
r_else
(brace
id|INIT_LIST_HEAD
(paren
op_amp
id|itd-&gt;itd_list
)paren
suffix:semicolon
id|urb-&gt;hcpriv
op_assign
id|first_itd
op_assign
id|itd
suffix:semicolon
)brace
)brace
id|urb-&gt;error_count
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|fail
suffix:colon
r_if
c_cond
(paren
id|urb-&gt;hcpriv
)paren
id|itd_free_list
(paren
id|ehci
comma
id|urb
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
r_static
r_inline
r_void
DECL|function|itd_link
id|itd_link
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_int
id|frame
comma
r_struct
id|ehci_itd
op_star
id|itd
)paren
(brace
multiline_comment|/* always prepend ITD/SITD ... only QH tree is order-sensitive */
id|itd-&gt;itd_next
op_assign
id|ehci-&gt;pshadow
(braket
id|frame
)braket
suffix:semicolon
id|itd-&gt;hw_next
op_assign
id|ehci-&gt;periodic
(braket
id|frame
)braket
suffix:semicolon
id|ehci-&gt;pshadow
(braket
id|frame
)braket
dot
id|itd
op_assign
id|itd
suffix:semicolon
id|ehci-&gt;periodic
(braket
id|frame
)braket
op_assign
id|cpu_to_le32
(paren
id|itd-&gt;itd_dma
)paren
op_or
id|Q_TYPE_ITD
suffix:semicolon
)brace
multiline_comment|/*&n; * return zero on success, else -errno&n; * - start holds first uframe to start scheduling into&n; * - max is the first uframe it&squot;s NOT (!) OK to start scheduling into&n; * math to be done modulo &quot;mod&quot; (ehci-&gt;periodic_size &lt;&lt; 3)&n; */
DECL|function|get_iso_range
r_static
r_int
id|get_iso_range
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
op_star
id|start
comma
r_int
op_star
id|max
comma
r_int
id|mod
)paren
(brace
r_struct
id|list_head
op_star
id|lh
suffix:semicolon
r_struct
id|hcd_dev
op_star
id|dev
op_assign
id|urb-&gt;dev-&gt;hcpriv
suffix:semicolon
r_int
id|last
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|now
comma
id|span
comma
id|end
suffix:semicolon
id|span
op_assign
id|urb-&gt;interval
op_star
id|urb-&gt;number_of_packets
suffix:semicolon
multiline_comment|/* first see if we know when the next transfer SHOULD happen */
id|list_for_each
(paren
id|lh
comma
op_amp
id|dev-&gt;urb_list
)paren
(brace
r_struct
id|urb
op_star
id|u
suffix:semicolon
r_struct
id|ehci_itd
op_star
id|itd
suffix:semicolon
r_int
id|s
suffix:semicolon
id|u
op_assign
id|list_entry
(paren
id|lh
comma
r_struct
id|urb
comma
id|urb_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|u
op_eq
id|urb
op_logical_or
id|u-&gt;pipe
op_ne
id|urb-&gt;pipe
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|u-&gt;interval
op_ne
id|urb-&gt;interval
)paren
(brace
multiline_comment|/* must not change! */
id|dbg
(paren
l_string|&quot;urb %p interval %d ... != %p interval %d&quot;
comma
id|u
comma
id|u-&gt;interval
comma
id|urb
comma
id|urb-&gt;interval
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* URB for this endpoint... covers through when?  */
id|itd
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
id|s
op_assign
id|itd-&gt;uframe
op_plus
id|u-&gt;interval
op_star
id|u-&gt;number_of_packets
suffix:semicolon
r_if
c_cond
(paren
id|last
OL
l_int|0
)paren
id|last
op_assign
id|s
suffix:semicolon
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * So far we can only queue two ISO URBs...&n;&t;&t;&t; *&n;&t;&t;&t; * FIXME do interval math, figure out whether&n;&t;&t;&t; * this URB is &quot;before&quot; or not ... also, handle&n;&t;&t;&t; * the case where the URB might have completed,&n;&t;&t;&t; * but hasn&squot;t yet been processed.&n;&t;&t;&t; */
id|dbg
(paren
l_string|&quot;NYET: queue &gt;2 URBs per ISO endpoint&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EDOM
suffix:semicolon
)brace
)brace
multiline_comment|/* calculate the legal range [start,max) */
id|now
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;frame_index
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* next uframe */
r_if
c_cond
(paren
op_logical_neg
id|ehci-&gt;periodic_sched
)paren
id|now
op_add_assign
l_int|8
suffix:semicolon
multiline_comment|/* startup delay */
id|now
op_mod_assign
id|mod
suffix:semicolon
id|end
op_assign
id|now
op_plus
id|mod
suffix:semicolon
r_if
c_cond
(paren
id|last
OL
l_int|0
)paren
(brace
op_star
id|start
op_assign
id|now
op_plus
id|ehci-&gt;i_thresh
op_plus
multiline_comment|/* paranoia */
l_int|1
suffix:semicolon
op_star
id|max
op_assign
id|end
op_minus
id|span
suffix:semicolon
r_if
c_cond
(paren
op_star
id|max
OL
op_star
id|start
op_plus
l_int|1
)paren
op_star
id|max
op_assign
op_star
id|start
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
op_star
id|start
op_assign
id|last
op_mod
id|mod
suffix:semicolon
op_star
id|max
op_assign
(paren
id|last
op_plus
l_int|1
)paren
op_mod
id|mod
suffix:semicolon
)brace
multiline_comment|/* explicit start frame? */
r_if
c_cond
(paren
op_logical_neg
(paren
id|urb-&gt;transfer_flags
op_amp
id|USB_ISO_ASAP
)paren
)paren
(brace
r_int
id|temp
suffix:semicolon
multiline_comment|/* sanity check: must be in range */
id|urb-&gt;start_frame
op_mod_assign
id|ehci-&gt;periodic_size
suffix:semicolon
id|temp
op_assign
id|urb-&gt;start_frame
op_lshift
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|temp
OL
op_star
id|start
)paren
id|temp
op_add_assign
id|mod
suffix:semicolon
r_if
c_cond
(paren
id|temp
OG
op_star
id|max
)paren
r_return
op_minus
id|EDOM
suffix:semicolon
multiline_comment|/* use that explicit start frame */
op_star
id|start
op_assign
id|urb-&gt;start_frame
op_lshift
l_int|3
suffix:semicolon
id|temp
op_add_assign
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|temp
OL
op_star
id|max
)paren
op_star
id|max
op_assign
id|temp
suffix:semicolon
)brace
singleline_comment|// FIXME minimize wraparound to &quot;now&quot; ... insist max+span
singleline_comment|// (and start+span) remains a few frames short of &quot;end&quot;
op_star
id|max
op_mod_assign
id|ehci-&gt;periodic_size
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|start
op_plus
id|span
)paren
OL
id|end
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_minus
id|EFBIG
suffix:semicolon
)brace
r_static
r_int
DECL|function|itd_schedule
id|itd_schedule
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
id|start
comma
id|max
comma
id|i
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|mod
op_assign
id|ehci-&gt;periodic_size
op_lshift
l_int|3
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|i
op_increment
)paren
(brace
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|status
op_assign
op_minus
id|EINPROGRESS
suffix:semicolon
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|actual_length
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|status
op_assign
id|get_iso_range
(paren
id|ehci
comma
id|urb
comma
op_amp
id|start
comma
op_amp
id|max
comma
id|mod
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|status
suffix:semicolon
r_do
(brace
r_int
id|uframe
suffix:semicolon
r_int
id|usecs
suffix:semicolon
r_struct
id|ehci_itd
op_star
id|itd
suffix:semicolon
multiline_comment|/* check schedule: enough space? */
id|itd
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
id|uframe
op_assign
id|start
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|uframe
op_assign
id|start
suffix:semicolon
id|i
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|i
op_increment
comma
id|uframe
op_add_assign
id|urb-&gt;interval
)paren
(brace
id|uframe
op_mod_assign
id|mod
suffix:semicolon
multiline_comment|/* can&squot;t commit more than 80% periodic == 100 usec */
r_if
c_cond
(paren
id|periodic_usecs
(paren
id|ehci
comma
id|uframe
op_rshift
l_int|3
comma
id|uframe
op_amp
l_int|0x7
)paren
OG
(paren
l_int|100
op_minus
id|itd-&gt;usecs
)paren
)paren
(brace
id|itd
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|itd
op_assign
id|list_entry
(paren
id|itd-&gt;itd_list.next
comma
r_struct
id|ehci_itd
comma
id|itd_list
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|itd
)paren
r_continue
suffix:semicolon
multiline_comment|/* that&squot;s where we&squot;ll schedule this! */
id|itd
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
id|urb-&gt;start_frame
op_assign
id|start
op_rshift
l_int|3
suffix:semicolon
id|vdbg
(paren
l_string|&quot;ISO urb %p (%d packets period %d) starting %d.%d&quot;
comma
id|urb
comma
id|urb-&gt;number_of_packets
comma
id|urb-&gt;interval
comma
id|urb-&gt;start_frame
comma
id|start
op_amp
l_int|0x7
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|uframe
op_assign
id|start
comma
id|usecs
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|i
op_increment
comma
id|uframe
op_add_assign
id|urb-&gt;interval
)paren
(brace
id|uframe
op_mod_assign
id|mod
suffix:semicolon
id|itd-&gt;uframe
op_assign
id|uframe
suffix:semicolon
id|itd-&gt;hw_transaction
(braket
id|uframe
op_amp
l_int|0x07
)braket
op_assign
id|itd-&gt;transaction
suffix:semicolon
id|itd_link
(paren
id|ehci
comma
(paren
id|uframe
op_rshift
l_int|3
)paren
op_mod
id|ehci-&gt;periodic_size
comma
id|itd
)paren
suffix:semicolon
id|wmb
(paren
)paren
suffix:semicolon
id|usecs
op_add_assign
id|itd-&gt;usecs
suffix:semicolon
id|itd
op_assign
id|list_entry
(paren
id|itd-&gt;itd_list.next
comma
r_struct
id|ehci_itd
comma
id|itd_list
)paren
suffix:semicolon
)brace
multiline_comment|/* update bandwidth utilization records (for usbfs)&n;&t;&t; *&n;&t;&t; * FIXME This claims each URB queued to an endpoint, as if&n;&t;&t; * transfers were concurrent, not sequential.  So bandwidth&n;&t;&t; * typically gets double-billed ... comes from tying it to&n;&t;&t; * URBs rather than endpoints in the schedule.  Luckily we&n;&t;&t; * don&squot;t use this usbfs data for serious decision making.&n;&t;&t; */
id|usecs
op_div_assign
id|urb-&gt;number_of_packets
suffix:semicolon
id|usecs
op_div_assign
id|urb-&gt;interval
suffix:semicolon
id|usecs
op_rshift_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|usecs
OL
l_int|1
)paren
id|usecs
op_assign
l_int|1
suffix:semicolon
id|usb_claim_bandwidth
(paren
id|urb-&gt;dev
comma
id|urb
comma
id|usecs
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* maybe enable periodic schedule processing */
r_if
c_cond
(paren
op_logical_neg
id|ehci-&gt;periodic_sched
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|status
op_assign
id|enable_periodic
(paren
id|ehci
)paren
)paren
op_ne
l_int|0
)paren
(brace
singleline_comment|// FIXME deschedule right away
id|err
(paren
l_string|&quot;itd_schedule, enable = %d&quot;
comma
id|status
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|start
op_assign
op_increment
id|start
op_mod
id|mod
)paren
op_ne
id|max
)paren
suffix:semicolon
multiline_comment|/* no room in the schedule */
id|dbg
(paren
l_string|&quot;urb %p, CAN&squot;T SCHEDULE&quot;
comma
id|urb
)paren
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|macro|ISO_ERRS
mdefine_line|#define&t;ISO_ERRS (EHCI_ISOC_BUF_ERR | EHCI_ISOC_BABBLE | EHCI_ISOC_XACTERR)
r_static
r_int
r_int
DECL|function|itd_complete
id|itd_complete
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|ehci_itd
op_star
id|itd
comma
r_int
id|uframe
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|urb
op_star
id|urb
op_assign
id|itd-&gt;urb
suffix:semicolon
r_struct
id|usb_iso_packet_descriptor
op_star
id|desc
suffix:semicolon
id|u32
id|t
suffix:semicolon
multiline_comment|/* update status for this uframe&squot;s transfers */
id|desc
op_assign
op_amp
id|urb-&gt;iso_frame_desc
(braket
id|itd-&gt;index
)braket
suffix:semicolon
id|t
op_assign
id|itd-&gt;hw_transaction
(braket
id|uframe
)braket
suffix:semicolon
id|itd-&gt;hw_transaction
(braket
id|uframe
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|t
op_amp
id|EHCI_ISOC_ACTIVE
)paren
id|desc-&gt;status
op_assign
op_minus
id|EXDEV
suffix:semicolon
r_else
r_if
c_cond
(paren
id|t
op_amp
id|ISO_ERRS
)paren
(brace
id|urb-&gt;error_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|t
op_amp
id|EHCI_ISOC_BUF_ERR
)paren
id|desc-&gt;status
op_assign
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
ques
c_cond
op_minus
id|ENOSR
multiline_comment|/* couldn&squot;t read */
suffix:colon
op_minus
id|ECOMM
suffix:semicolon
multiline_comment|/* couldn&squot;t write */
r_else
r_if
c_cond
(paren
id|t
op_amp
id|EHCI_ISOC_BABBLE
)paren
id|desc-&gt;status
op_assign
op_minus
id|EOVERFLOW
suffix:semicolon
r_else
multiline_comment|/* (t &amp; EHCI_ISOC_XACTERR) */
id|desc-&gt;status
op_assign
op_minus
id|EPROTO
suffix:semicolon
multiline_comment|/* HC need not update length with this error */
r_if
c_cond
(paren
op_logical_neg
(paren
id|t
op_amp
id|EHCI_ISOC_BABBLE
)paren
)paren
id|desc-&gt;actual_length
op_add_assign
id|EHCI_ITD_LENGTH
(paren
id|t
)paren
suffix:semicolon
)brace
r_else
(brace
id|desc-&gt;status
op_assign
l_int|0
suffix:semicolon
id|desc-&gt;actual_length
op_add_assign
id|EHCI_ITD_LENGTH
(paren
id|t
)paren
suffix:semicolon
)brace
id|vdbg
(paren
l_string|&quot;itd %p urb %p packet %d/%d trans %x status %d len %d&quot;
comma
id|itd
comma
id|urb
comma
id|itd-&gt;index
op_plus
l_int|1
comma
id|urb-&gt;number_of_packets
comma
id|t
comma
id|desc-&gt;status
comma
id|desc-&gt;actual_length
)paren
suffix:semicolon
multiline_comment|/* handle completion now? */
r_if
c_cond
(paren
(paren
id|itd-&gt;index
op_plus
l_int|1
)paren
op_ne
id|urb-&gt;number_of_packets
)paren
r_return
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * Always give the urb back to the driver ... expect it to submit&n;&t; * a new urb (or resubmit this), and to have another already queued&n;&t; * when un-interrupted transfers are needed.&n;&t; *&n;&t; * NOTE that for now we don&squot;t accelerate ISO unlinks; they just&n;&t; * happen according to the current schedule.  Means a delay of&n;&t; * up to about a second (max).&n;&t; */
id|itd_free_list
(paren
id|ehci
comma
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
id|urb-&gt;status
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|usb_hcd_giveback_urb
(paren
op_amp
id|ehci-&gt;hcd
comma
id|urb
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* defer stopping schedule; completion can submit */
id|ehci-&gt;periodic_sched
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ehci-&gt;periodic_sched
)paren
(paren
r_void
)paren
id|disable_periodic
(paren
id|ehci
)paren
suffix:semicolon
r_return
id|flags
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|itd_submit
r_static
r_int
id|itd_submit
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|mem_flags
)paren
(brace
r_int
id|status
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|dbg
(paren
l_string|&quot;itd_submit urb %p&quot;
comma
id|urb
)paren
suffix:semicolon
multiline_comment|/* NOTE DMA mapping assumes this ... */
r_if
c_cond
(paren
id|urb-&gt;iso_frame_desc
(braket
l_int|0
)braket
dot
id|offset
op_ne
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* allocate ITDs w/o locking anything */
id|status
op_assign
id|itd_urb_transaction
(paren
id|ehci
comma
id|urb
comma
id|mem_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
r_return
id|status
suffix:semicolon
multiline_comment|/* schedule ... need to lock */
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|status
op_assign
id|itd_schedule
(paren
id|ehci
comma
id|urb
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
id|itd_free_list
(paren
id|ehci
comma
id|urb
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
macro_line|#ifdef have_split_iso
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * &quot;Split ISO TDs&quot; ... used for USB 1.1 devices going through&n; * the TTs in USB 2.0 hubs.&n; */
r_static
r_void
DECL|function|sitd_free
id|sitd_free
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|ehci_sitd
op_star
id|sitd
)paren
(brace
id|pci_pool_free
(paren
id|ehci-&gt;sitd_pool
comma
id|sitd
comma
id|sitd-&gt;sitd_dma
)paren
suffix:semicolon
)brace
r_static
r_struct
id|ehci_sitd
op_star
DECL|function|sitd_make
id|sitd_make
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|index
comma
singleline_comment|// urb-&gt;iso_frame_desc [index]
r_int
id|uframe
comma
singleline_comment|// scheduled start
id|dma_addr_t
id|dma
comma
singleline_comment|// mapped transfer buffer
r_int
id|mem_flags
)paren
(brace
r_struct
id|ehci_sitd
op_star
id|sitd
suffix:semicolon
r_int
id|length
suffix:semicolon
id|sitd
op_assign
id|pci_pool_alloc
(paren
id|ehci-&gt;sitd_pool
comma
id|mem_flags
comma
op_amp
id|dma
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sitd
)paren
r_return
id|sitd
suffix:semicolon
id|sitd-&gt;urb
op_assign
id|urb
suffix:semicolon
id|length
op_assign
id|urb-&gt;iso_frame_desc
(braket
id|index
)braket
dot
id|length
suffix:semicolon
id|dma
op_add_assign
id|urb-&gt;iso_frame_desc
(braket
id|index
)braket
dot
id|offset
suffix:semicolon
macro_line|#if 0
singleline_comment|// FIXME:  do the rest!
macro_line|#else
id|sitd_free
(paren
id|ehci
comma
id|sitd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#endif
)brace
r_static
r_void
DECL|function|sitd_link
id|sitd_link
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_int
id|frame
comma
r_struct
id|ehci_sitd
op_star
id|sitd
)paren
(brace
id|u32
id|ptr
suffix:semicolon
id|ptr
op_assign
id|cpu_to_le32
(paren
id|sitd-&gt;sitd_dma
op_or
l_int|2
)paren
suffix:semicolon
singleline_comment|// type 2 == sitd
r_if
c_cond
(paren
id|ehci-&gt;pshadow
(braket
id|frame
)braket
dot
id|ptr
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sitd-&gt;sitd_next.ptr
)paren
(brace
id|sitd-&gt;sitd_next
op_assign
id|ehci-&gt;pshadow
(braket
id|frame
)braket
suffix:semicolon
id|sitd-&gt;hw_next
op_assign
id|ehci-&gt;periodic
(braket
id|frame
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sitd-&gt;sitd_next.ptr
op_ne
id|ehci-&gt;pshadow
(braket
id|frame
)braket
dot
id|ptr
)paren
(brace
id|dbg
(paren
l_string|&quot;frame %d sitd link goof&quot;
comma
id|frame
)paren
suffix:semicolon
id|BUG
(paren
)paren
suffix:semicolon
)brace
)brace
id|ehci-&gt;pshadow
(braket
id|frame
)braket
dot
id|sitd
op_assign
id|sitd
suffix:semicolon
id|ehci-&gt;periodic
(braket
id|frame
)braket
op_assign
id|ptr
suffix:semicolon
)brace
r_static
r_int
r_int
DECL|function|sitd_complete
id|sitd_complete
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|ehci_sitd
op_star
id|sitd
comma
r_int
r_int
id|flags
)paren
(brace
singleline_comment|// FIXME -- implement!
id|dbg
(paren
l_string|&quot;NYI -- sitd_complete&quot;
)paren
suffix:semicolon
r_return
id|flags
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|sitd_submit
r_static
r_int
id|sitd_submit
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|mem_flags
)paren
(brace
singleline_comment|// struct ehci_sitd&t;*first_sitd = 0;
r_int
id|frame_index
suffix:semicolon
id|dma_addr_t
id|dma
suffix:semicolon
id|dbg
(paren
l_string|&quot;NYI -- sitd_submit&quot;
)paren
suffix:semicolon
singleline_comment|// FIXME -- implement!
singleline_comment|// FIXME:  setup one big dma mapping
id|dma
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|frame_index
op_assign
l_int|0
suffix:semicolon
id|frame_index
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|frame_index
op_increment
)paren
(brace
r_struct
id|ehci_sitd
op_star
id|sitd
suffix:semicolon
r_int
id|uframe
suffix:semicolon
singleline_comment|// FIXME:  use real arguments, schedule this!
id|uframe
op_assign
op_minus
l_int|1
suffix:semicolon
id|sitd
op_assign
id|sitd_make
(paren
id|ehci
comma
id|urb
comma
id|frame_index
comma
id|uframe
comma
id|dma
comma
id|mem_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sitd
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;if (first_sitd)&n;&t;&t;&t;&t;list_add_tail (&amp;sitd-&gt;sitd_list,&n;&t;&t;&t;&t;&t;&t;&amp;first_sitd-&gt;sitd_list);&n;&t;&t;&t;else&n;&t;&t;&t;&t;first_sitd = sitd;&n;    */
)brace
r_else
(brace
singleline_comment|// FIXME:  clean everything up
)brace
)brace
singleline_comment|// if we have a first sitd, then
singleline_comment|// store them all into the periodic schedule!
singleline_comment|// urb-&gt;hcpriv = first sitd in sitd_list
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
macro_line|#endif /* have_split_iso */
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|scan_periodic
r_static
r_void
id|scan_periodic
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
)paren
(brace
r_int
id|frame
comma
id|clock
comma
id|now_uframe
comma
id|mod
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|mod
op_assign
id|ehci-&gt;periodic_size
op_lshift
l_int|3
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * When running, scan from last scan point up to &quot;now&quot;&n;&t; * else clean up by scanning everything that&squot;s left.&n;&t; * Touches as few pages as possible:  cache-friendly.&n;&t; * Don&squot;t scan ISO entries more than once, though.&n;&t; */
id|frame
op_assign
id|ehci-&gt;next_uframe
op_rshift
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|HCD_IS_RUNNING
(paren
id|ehci-&gt;hcd.state
)paren
)paren
id|now_uframe
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;frame_index
)paren
suffix:semicolon
r_else
id|now_uframe
op_assign
(paren
id|frame
op_lshift
l_int|3
)paren
op_minus
l_int|1
suffix:semicolon
id|now_uframe
op_mod_assign
id|mod
suffix:semicolon
id|clock
op_assign
id|now_uframe
op_rshift
l_int|3
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_union
id|ehci_shadow
id|q
comma
op_star
id|q_p
suffix:semicolon
id|u32
id|type
comma
op_star
id|hw_p
suffix:semicolon
r_int
id|uframes
suffix:semicolon
id|restart
suffix:colon
multiline_comment|/* scan schedule to _before_ current frame index */
r_if
c_cond
(paren
id|frame
op_eq
id|clock
)paren
id|uframes
op_assign
id|now_uframe
op_amp
l_int|0x07
suffix:semicolon
r_else
id|uframes
op_assign
l_int|8
suffix:semicolon
id|q_p
op_assign
op_amp
id|ehci-&gt;pshadow
(braket
id|frame
)braket
suffix:semicolon
id|hw_p
op_assign
op_amp
id|ehci-&gt;periodic
(braket
id|frame
)braket
suffix:semicolon
id|q.ptr
op_assign
id|q_p-&gt;ptr
suffix:semicolon
id|type
op_assign
id|Q_NEXT_TYPE
(paren
op_star
id|hw_p
)paren
suffix:semicolon
multiline_comment|/* scan each element in frame&squot;s queue for completions */
r_while
c_loop
(paren
id|q.ptr
op_ne
l_int|0
)paren
(brace
r_int
id|last
suffix:semicolon
r_int
id|uf
suffix:semicolon
r_union
id|ehci_shadow
id|temp
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|Q_TYPE_QH
suffix:colon
id|last
op_assign
(paren
id|q.qh-&gt;hw_next
op_eq
id|EHCI_LIST_END
)paren
suffix:semicolon
id|temp
op_assign
id|q.qh-&gt;qh_next
suffix:semicolon
id|type
op_assign
id|Q_NEXT_TYPE
(paren
id|q.qh-&gt;hw_next
)paren
suffix:semicolon
id|flags
op_assign
id|intr_complete
(paren
id|ehci
comma
id|frame
comma
id|qh_get
(paren
id|q.qh
)paren
comma
id|flags
)paren
suffix:semicolon
id|qh_put
(paren
id|ehci
comma
id|q.qh
)paren
suffix:semicolon
id|q
op_assign
id|temp
suffix:semicolon
r_break
suffix:semicolon
r_case
id|Q_TYPE_FSTN
suffix:colon
id|last
op_assign
(paren
id|q.fstn-&gt;hw_next
op_eq
id|EHCI_LIST_END
)paren
suffix:semicolon
multiline_comment|/* for &quot;save place&quot; FSTNs, look at QH entries&n;&t;&t;&t;&t; * in the previous frame for completions.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|q.fstn-&gt;hw_prev
op_ne
id|EHCI_LIST_END
)paren
(brace
id|dbg
(paren
l_string|&quot;ignoring completions from FSTNs&quot;
)paren
suffix:semicolon
)brace
id|type
op_assign
id|Q_NEXT_TYPE
(paren
id|q.fstn-&gt;hw_next
)paren
suffix:semicolon
id|q
op_assign
id|q.fstn-&gt;fstn_next
suffix:semicolon
r_break
suffix:semicolon
r_case
id|Q_TYPE_ITD
suffix:colon
id|last
op_assign
(paren
id|q.itd-&gt;hw_next
op_eq
id|EHCI_LIST_END
)paren
suffix:semicolon
multiline_comment|/* Unlink each (S)ITD we see, since the ISO&n;&t;&t;&t;&t; * URB model forces constant rescheduling.&n;&t;&t;&t;&t; * That complicates sharing uframes in ITDs,&n;&t;&t;&t;&t; * and means we need to skip uframes the HC&n;&t;&t;&t;&t; * hasn&squot;t yet processed.&n;&t;&t;&t;&t; */
r_for
c_loop
(paren
id|uf
op_assign
l_int|0
suffix:semicolon
id|uf
OL
id|uframes
suffix:semicolon
id|uf
op_increment
)paren
(brace
r_if
c_cond
(paren
id|q.itd-&gt;hw_transaction
(braket
id|uf
)braket
op_ne
l_int|0
)paren
(brace
id|temp
op_assign
id|q
suffix:semicolon
op_star
id|q_p
op_assign
id|q.itd-&gt;itd_next
suffix:semicolon
op_star
id|hw_p
op_assign
id|q.itd-&gt;hw_next
suffix:semicolon
id|type
op_assign
id|Q_NEXT_TYPE
(paren
op_star
id|hw_p
)paren
suffix:semicolon
multiline_comment|/* might free q.itd ... */
id|flags
op_assign
id|itd_complete
(paren
id|ehci
comma
id|temp.itd
comma
id|uf
comma
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* we might skip this ITD&squot;s uframe ... */
r_if
c_cond
(paren
id|uf
op_eq
id|uframes
)paren
(brace
id|q_p
op_assign
op_amp
id|q.itd-&gt;itd_next
suffix:semicolon
id|hw_p
op_assign
op_amp
id|q.itd-&gt;hw_next
suffix:semicolon
id|type
op_assign
id|Q_NEXT_TYPE
(paren
id|q.itd-&gt;hw_next
)paren
suffix:semicolon
)brace
id|q
op_assign
op_star
id|q_p
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef have_split_iso
r_case
id|Q_TYPE_SITD
suffix:colon
id|last
op_assign
(paren
id|q.sitd-&gt;hw_next
op_eq
id|EHCI_LIST_END
)paren
suffix:semicolon
id|flags
op_assign
id|sitd_complete
(paren
id|ehci
comma
id|q.sitd
comma
id|flags
)paren
suffix:semicolon
id|type
op_assign
id|Q_NEXT_TYPE
(paren
id|q.sitd-&gt;hw_next
)paren
suffix:semicolon
singleline_comment|// FIXME unlink SITD after split completes
id|q
op_assign
id|q.sitd-&gt;sitd_next
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /* have_split_iso */
r_default
suffix:colon
id|dbg
(paren
l_string|&quot;corrupt type %d frame %d shadow %p&quot;
comma
id|type
comma
id|frame
comma
id|q.ptr
)paren
suffix:semicolon
singleline_comment|// BUG ();
id|last
op_assign
l_int|1
suffix:semicolon
id|q.ptr
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* did completion remove an interior q entry? */
r_if
c_cond
(paren
id|unlikely
(paren
id|q.ptr
op_eq
l_int|0
op_logical_and
op_logical_neg
id|last
)paren
)paren
r_goto
id|restart
suffix:semicolon
)brace
multiline_comment|/* stop when we catch up to the HC */
singleline_comment|// FIXME:  this assumes we won&squot;t get lapped when
singleline_comment|// latencies climb; that should be rare, but...
singleline_comment|// detect it, and just go all the way around.
singleline_comment|// FLR might help detect this case, so long as latencies
singleline_comment|// don&squot;t exceed periodic_size msec (default 1.024 sec).
singleline_comment|// FIXME:  likewise assumes HC doesn&squot;t halt mid-scan
r_if
c_cond
(paren
id|frame
op_eq
id|clock
)paren
(brace
r_int
id|now
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|HCD_IS_RUNNING
(paren
id|ehci-&gt;hcd.state
)paren
)paren
r_break
suffix:semicolon
id|ehci-&gt;next_uframe
op_assign
id|now_uframe
suffix:semicolon
id|now
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;frame_index
)paren
op_mod
id|mod
suffix:semicolon
r_if
c_cond
(paren
id|now_uframe
op_eq
id|now
)paren
r_break
suffix:semicolon
multiline_comment|/* rescan the rest of this frame, then ... */
id|now_uframe
op_assign
id|now
suffix:semicolon
id|clock
op_assign
id|now_uframe
op_rshift
l_int|3
suffix:semicolon
)brace
r_else
id|frame
op_assign
(paren
id|frame
op_plus
l_int|1
)paren
op_mod
id|ehci-&gt;periodic_size
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
eof
