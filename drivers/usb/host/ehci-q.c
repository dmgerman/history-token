multiline_comment|/*&n; * Copyright (c) 2001-2002 by David Brownell&n; * &n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2 of the License, or (at your&n; * option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY&n; * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License&n; * for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software Foundation,&n; * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
multiline_comment|/* this file is part of ehci-hcd.c */
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * EHCI hardware queue manipulation ... the core.  QH/QTD manipulation.&n; *&n; * Control, bulk, and interrupt traffic all use &quot;qh&quot; lists.  They list &quot;qtd&quot;&n; * entries describing USB transactions, max 16-20kB/entry (with 4kB-aligned&n; * buffers needed for the larger number).  We use one QH per endpoint, queue&n; * multiple urbs (all three types) per endpoint.  URBs may need several qtds.&n; *&n; * ISO traffic uses &quot;ISO TD&quot; (itd, and sitd) records, and (along with&n; * interrupts) needs careful scheduling.  Performance improvements can be&n; * an ongoing challenge.  That&squot;s in &quot;ehci-sched.c&quot;.&n; * &n; * USB 1.1 devices are handled (a) by &quot;companion&quot; OHCI or UHCI root hubs,&n; * or otherwise through transaction translators (TTs) in USB 2.0 hubs using&n; * (b) special fields in qh entries or (c) split iso entries.  TTs will&n; * buffer low/full speed data so the host collects it at high speed.&n; */
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* fill a qtd, returning how much of the buffer we were able to queue up */
r_static
r_int
DECL|function|qtd_fill
id|qtd_fill
(paren
r_struct
id|ehci_qtd
op_star
id|qtd
comma
id|dma_addr_t
id|buf
comma
r_int
id|len
comma
r_int
id|token
comma
r_int
id|maxpacket
)paren
(brace
r_int
id|i
comma
id|count
suffix:semicolon
id|u64
id|addr
op_assign
id|buf
suffix:semicolon
multiline_comment|/* one buffer entry per 4K ... first might be short or unaligned */
id|qtd-&gt;hw_buf
(braket
l_int|0
)braket
op_assign
id|cpu_to_le32
(paren
(paren
id|u32
)paren
id|addr
)paren
suffix:semicolon
id|qtd-&gt;hw_buf_hi
(braket
l_int|0
)braket
op_assign
id|cpu_to_le32
(paren
(paren
id|u32
)paren
(paren
id|addr
op_rshift
l_int|32
)paren
)paren
suffix:semicolon
id|count
op_assign
l_int|0x1000
op_minus
(paren
id|buf
op_amp
l_int|0x0fff
)paren
suffix:semicolon
multiline_comment|/* rest of that page */
r_if
c_cond
(paren
id|likely
(paren
id|len
OL
id|count
)paren
)paren
multiline_comment|/* ... iff needed */
id|count
op_assign
id|len
suffix:semicolon
r_else
(brace
id|buf
op_add_assign
l_int|0x1000
suffix:semicolon
id|buf
op_and_assign
op_complement
l_int|0x0fff
suffix:semicolon
multiline_comment|/* per-qtd limit: from 16K to 20K (best alignment) */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|count
OL
id|len
op_logical_and
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
(brace
id|addr
op_assign
id|buf
suffix:semicolon
id|qtd-&gt;hw_buf
(braket
id|i
)braket
op_assign
id|cpu_to_le32
(paren
(paren
id|u32
)paren
id|addr
)paren
suffix:semicolon
id|qtd-&gt;hw_buf_hi
(braket
id|i
)braket
op_assign
id|cpu_to_le32
(paren
(paren
id|u32
)paren
(paren
id|addr
op_rshift
l_int|32
)paren
)paren
suffix:semicolon
id|buf
op_add_assign
l_int|0x1000
suffix:semicolon
r_if
c_cond
(paren
(paren
id|count
op_plus
l_int|0x1000
)paren
OL
id|len
)paren
id|count
op_add_assign
l_int|0x1000
suffix:semicolon
r_else
id|count
op_assign
id|len
suffix:semicolon
)brace
multiline_comment|/* short packets may only terminate transfers */
r_if
c_cond
(paren
id|count
op_ne
id|len
)paren
id|count
op_sub_assign
(paren
id|count
op_mod
id|maxpacket
)paren
suffix:semicolon
)brace
id|qtd-&gt;hw_token
op_assign
id|cpu_to_le32
(paren
(paren
id|count
op_lshift
l_int|16
)paren
op_or
id|token
)paren
suffix:semicolon
id|qtd-&gt;length
op_assign
id|count
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
r_static
r_inline
r_void
DECL|function|qh_update
id|qh_update
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|ehci_qh
op_star
id|qh
comma
r_struct
id|ehci_qtd
op_star
id|qtd
)paren
(brace
multiline_comment|/* writes to an active overlay are unsafe */
id|BUG_ON
c_func
(paren
id|qh-&gt;qh_state
op_ne
id|QH_STATE_IDLE
)paren
suffix:semicolon
id|qh-&gt;hw_qtd_next
op_assign
id|QTD_NEXT
(paren
id|qtd-&gt;qtd_dma
)paren
suffix:semicolon
id|qh-&gt;hw_alt_next
op_assign
id|EHCI_LIST_END
suffix:semicolon
multiline_comment|/* Except for control endpoints, we make hardware maintain data&n;&t; * toggle (like OHCI) ... here (re)initialize the toggle in the QH,&n;&t; * and set the pseudo-toggle in udev. Only usb_clear_halt() will&n;&t; * ever clear it.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|qh-&gt;hw_info1
op_amp
id|cpu_to_le32
c_func
(paren
l_int|1
op_lshift
l_int|14
)paren
)paren
)paren
(brace
r_int
id|is_out
comma
id|epnum
suffix:semicolon
id|is_out
op_assign
op_logical_neg
(paren
id|qtd-&gt;hw_token
op_amp
id|cpu_to_le32
c_func
(paren
l_int|1
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
id|epnum
op_assign
(paren
id|le32_to_cpup
c_func
(paren
op_amp
id|qh-&gt;hw_info1
)paren
op_rshift
l_int|8
)paren
op_amp
l_int|0x0f
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|usb_gettoggle
(paren
id|qh-&gt;dev
comma
id|epnum
comma
id|is_out
)paren
)paren
)paren
(brace
id|qh-&gt;hw_token
op_and_assign
op_complement
id|__constant_cpu_to_le32
(paren
id|QTD_TOGGLE
)paren
suffix:semicolon
id|usb_settoggle
(paren
id|qh-&gt;dev
comma
id|epnum
comma
id|is_out
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* HC must see latest qtd and qh data before we clear ACTIVE+HALT */
id|wmb
(paren
)paren
suffix:semicolon
id|qh-&gt;hw_token
op_and_assign
id|__constant_cpu_to_le32
(paren
id|QTD_TOGGLE
op_or
id|QTD_STS_PING
)paren
suffix:semicolon
)brace
multiline_comment|/* if it weren&squot;t for a common silicon quirk (writing the dummy into the qh&n; * overlay, so qh-&gt;hw_token wrongly becomes inactive/halted), only fault&n; * recovery (including urb dequeue) would need software changes to a QH...&n; */
r_static
r_void
DECL|function|qh_refresh
id|qh_refresh
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|ehci_qh
op_star
id|qh
)paren
(brace
r_struct
id|ehci_qtd
op_star
id|qtd
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
(paren
op_amp
id|qh-&gt;qtd_list
)paren
)paren
id|qtd
op_assign
id|qh-&gt;dummy
suffix:semicolon
r_else
(brace
id|qtd
op_assign
id|list_entry
(paren
id|qh-&gt;qtd_list.next
comma
r_struct
id|ehci_qtd
comma
id|qtd_list
)paren
suffix:semicolon
multiline_comment|/* first qtd may already be partially processed */
r_if
c_cond
(paren
id|cpu_to_le32
(paren
id|qtd-&gt;qtd_dma
)paren
op_eq
id|qh-&gt;hw_current
)paren
id|qtd
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|qtd
)paren
id|qh_update
(paren
id|ehci
comma
id|qh
comma
id|qtd
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|qtd_copy_status
r_static
r_void
id|qtd_copy_status
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|length
comma
id|u32
id|token
)paren
(brace
multiline_comment|/* count IN/OUT bytes, not SETUP (even short packets) */
r_if
c_cond
(paren
id|likely
(paren
id|QTD_PID
(paren
id|token
)paren
op_ne
l_int|2
)paren
)paren
id|urb-&gt;actual_length
op_add_assign
id|length
op_minus
id|QTD_LENGTH
(paren
id|token
)paren
suffix:semicolon
multiline_comment|/* don&squot;t modify error codes */
r_if
c_cond
(paren
id|unlikely
(paren
id|urb-&gt;status
op_ne
op_minus
id|EINPROGRESS
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* force cleanup after short read; not always an error */
r_if
c_cond
(paren
id|unlikely
(paren
id|IS_SHORT_READ
(paren
id|token
)paren
)paren
)paren
id|urb-&gt;status
op_assign
op_minus
id|EREMOTEIO
suffix:semicolon
multiline_comment|/* serious &quot;can&squot;t proceed&quot; faults reported by the hardware */
r_if
c_cond
(paren
id|token
op_amp
id|QTD_STS_HALT
)paren
(brace
r_if
c_cond
(paren
id|token
op_amp
id|QTD_STS_BABBLE
)paren
(brace
multiline_comment|/* FIXME &quot;must&quot; disable babbling device&squot;s port too */
id|urb-&gt;status
op_assign
op_minus
id|EOVERFLOW
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|token
op_amp
id|QTD_STS_MMF
)paren
(brace
multiline_comment|/* fs/ls interrupt xfer missed the complete-split */
id|urb-&gt;status
op_assign
op_minus
id|EPROTO
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|token
op_amp
id|QTD_STS_DBE
)paren
(brace
id|urb-&gt;status
op_assign
(paren
id|QTD_PID
(paren
id|token
)paren
op_eq
l_int|1
)paren
multiline_comment|/* IN ? */
ques
c_cond
op_minus
id|ENOSR
multiline_comment|/* hc couldn&squot;t read data */
suffix:colon
op_minus
id|ECOMM
suffix:semicolon
multiline_comment|/* hc couldn&squot;t write data */
)brace
r_else
r_if
c_cond
(paren
id|token
op_amp
id|QTD_STS_XACT
)paren
(brace
multiline_comment|/* timeout, bad crc, wrong PID, etc; retried */
r_if
c_cond
(paren
id|QTD_CERR
(paren
id|token
)paren
)paren
id|urb-&gt;status
op_assign
op_minus
id|EPIPE
suffix:semicolon
r_else
(brace
id|ehci_dbg
(paren
id|ehci
comma
l_string|&quot;devpath %s ep%d%s 3strikes&bslash;n&quot;
comma
id|urb-&gt;dev-&gt;devpath
comma
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
comma
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
ques
c_cond
l_string|&quot;in&quot;
suffix:colon
l_string|&quot;out&quot;
)paren
suffix:semicolon
id|urb-&gt;status
op_assign
op_minus
id|EPROTO
suffix:semicolon
)brace
multiline_comment|/* CERR nonzero + no errors + halt --&gt; stall */
)brace
r_else
r_if
c_cond
(paren
id|QTD_CERR
(paren
id|token
)paren
)paren
id|urb-&gt;status
op_assign
op_minus
id|EPIPE
suffix:semicolon
r_else
multiline_comment|/* unknown */
id|urb-&gt;status
op_assign
op_minus
id|EPROTO
suffix:semicolon
id|ehci_vdbg
(paren
id|ehci
comma
l_string|&quot;dev%d ep%d%s qtd token %08x --&gt; status %d&bslash;n&quot;
comma
id|usb_pipedevice
(paren
id|urb-&gt;pipe
)paren
comma
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
comma
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
ques
c_cond
l_string|&quot;in&quot;
suffix:colon
l_string|&quot;out&quot;
comma
id|token
comma
id|urb-&gt;status
)paren
suffix:semicolon
multiline_comment|/* if async CSPLIT failed, try cleaning out the TT buffer */
r_if
c_cond
(paren
id|urb-&gt;status
op_ne
op_minus
id|EPIPE
op_logical_and
id|urb-&gt;dev-&gt;tt
op_logical_and
op_logical_neg
id|usb_pipeint
(paren
id|urb-&gt;pipe
)paren
op_logical_and
(paren
(paren
id|token
op_amp
id|QTD_STS_MMF
)paren
op_ne
l_int|0
op_logical_or
id|QTD_CERR
c_func
(paren
id|token
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
op_logical_neg
id|ehci_is_ARC
c_func
(paren
id|ehci
)paren
op_logical_or
id|urb-&gt;dev-&gt;tt-&gt;hub
op_ne
id|ehci-&gt;hcd.self.root_hub
)paren
)paren
(brace
macro_line|#ifdef DEBUG
r_struct
id|usb_device
op_star
id|tt
op_assign
id|urb-&gt;dev-&gt;tt-&gt;hub
suffix:semicolon
id|dev_dbg
(paren
op_amp
id|tt-&gt;dev
comma
l_string|&quot;clear tt buffer port %d, a%d ep%d t%08x&bslash;n&quot;
comma
id|urb-&gt;dev-&gt;ttport
comma
id|urb-&gt;dev-&gt;devnum
comma
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
comma
id|token
)paren
suffix:semicolon
macro_line|#endif /* DEBUG */
id|usb_hub_tt_clear_buffer
(paren
id|urb-&gt;dev
comma
id|urb-&gt;pipe
)paren
suffix:semicolon
)brace
)brace
)brace
r_static
r_void
id|ehci_urb_done
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
id|__releases
c_func
(paren
id|ehci-&gt;lock
)paren
id|__acquires
c_func
(paren
id|ehci-&gt;lock
)paren
(brace
r_if
c_cond
(paren
id|likely
(paren
id|urb-&gt;hcpriv
op_ne
l_int|0
)paren
)paren
(brace
r_struct
id|ehci_qh
op_star
id|qh
op_assign
(paren
r_struct
id|ehci_qh
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
multiline_comment|/* S-mask in a QH means it&squot;s an interrupt urb */
r_if
c_cond
(paren
(paren
id|qh-&gt;hw_info2
op_amp
id|__constant_cpu_to_le32
(paren
l_int|0x00ff
)paren
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* ... update hc-wide periodic stats (for usbfs) */
id|hcd_to_bus
(paren
op_amp
id|ehci-&gt;hcd
)paren
op_member_access_from_pointer
id|bandwidth_int_reqs
op_decrement
suffix:semicolon
)brace
id|qh_put
(paren
id|qh
)paren
suffix:semicolon
)brace
id|spin_lock
(paren
op_amp
id|urb-&gt;lock
)paren
suffix:semicolon
id|urb-&gt;hcpriv
op_assign
l_int|NULL
suffix:semicolon
r_switch
c_cond
(paren
id|urb-&gt;status
)paren
(brace
r_case
op_minus
id|EINPROGRESS
suffix:colon
multiline_comment|/* success */
id|urb-&gt;status
op_assign
l_int|0
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* fault */
id|COUNT
(paren
id|ehci-&gt;stats.complete
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|EREMOTEIO
suffix:colon
multiline_comment|/* fault or normal */
r_if
c_cond
(paren
op_logical_neg
(paren
id|urb-&gt;transfer_flags
op_amp
id|URB_SHORT_NOT_OK
)paren
)paren
id|urb-&gt;status
op_assign
l_int|0
suffix:semicolon
id|COUNT
(paren
id|ehci-&gt;stats.complete
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
op_minus
id|ECONNRESET
suffix:colon
multiline_comment|/* canceled */
r_case
op_minus
id|ENOENT
suffix:colon
id|COUNT
(paren
id|ehci-&gt;stats.unlink
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_unlock
(paren
op_amp
id|urb-&gt;lock
)paren
suffix:semicolon
macro_line|#ifdef EHCI_URB_TRACE
id|ehci_dbg
(paren
id|ehci
comma
l_string|&quot;%s %s urb %p ep%d%s status %d len %d/%d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|urb-&gt;dev-&gt;devpath
comma
id|urb
comma
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
comma
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
ques
c_cond
l_string|&quot;in&quot;
suffix:colon
l_string|&quot;out&quot;
comma
id|urb-&gt;status
comma
id|urb-&gt;actual_length
comma
id|urb-&gt;transfer_buffer_length
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* complete() can reenter this HCD */
id|spin_unlock
(paren
op_amp
id|ehci-&gt;lock
)paren
suffix:semicolon
id|usb_hcd_giveback_urb
(paren
op_amp
id|ehci-&gt;hcd
comma
id|urb
comma
id|regs
)paren
suffix:semicolon
id|spin_lock
(paren
op_amp
id|ehci-&gt;lock
)paren
suffix:semicolon
)brace
r_static
r_void
id|start_unlink_async
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|ehci_qh
op_star
id|qh
)paren
suffix:semicolon
r_static
r_void
id|intr_deschedule
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|ehci_qh
op_star
id|qh
comma
r_int
id|wait
)paren
suffix:semicolon
r_static
r_int
id|qh_schedule
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|ehci_qh
op_star
id|qh
)paren
suffix:semicolon
multiline_comment|/*&n; * Process and free completed qtds for a qh, returning URBs to drivers.&n; * Chases up to qh-&gt;hw_current.  Returns number of completions called,&n; * indicating how much &quot;real&quot; work we did.&n; */
DECL|macro|HALT_BIT
mdefine_line|#define HALT_BIT __constant_cpu_to_le32(QTD_STS_HALT)
r_static
r_int
DECL|function|qh_completions
id|qh_completions
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|ehci_qh
op_star
id|qh
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|ehci_qtd
op_star
id|last
op_assign
l_int|NULL
comma
op_star
id|end
op_assign
id|qh-&gt;dummy
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
comma
op_star
id|tmp
suffix:semicolon
r_int
id|stopped
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_int
id|do_status
op_assign
l_int|0
suffix:semicolon
id|u8
id|state
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
id|list_empty
(paren
op_amp
id|qh-&gt;qtd_list
)paren
)paren
)paren
r_return
id|count
suffix:semicolon
multiline_comment|/* completions (or tasks on other cpus) must never clobber HALT&n;&t; * till we&squot;ve gone through and cleaned everything up, even when&n;&t; * they add urbs to this qh&squot;s queue or mark them for unlinking.&n;&t; *&n;&t; * NOTE:  unlinking expects to be done in queue order.&n;&t; */
id|state
op_assign
id|qh-&gt;qh_state
suffix:semicolon
id|qh-&gt;qh_state
op_assign
id|QH_STATE_COMPLETING
suffix:semicolon
id|stopped
op_assign
(paren
id|state
op_eq
id|QH_STATE_IDLE
)paren
suffix:semicolon
multiline_comment|/* remove de-activated QTDs from front of queue.&n;&t; * after faults (including short reads), cleanup this urb&n;&t; * then let the queue advance.&n;&t; * if queue is stopped, handles unlinks.&n;&t; */
id|list_for_each_safe
(paren
id|entry
comma
id|tmp
comma
op_amp
id|qh-&gt;qtd_list
)paren
(brace
r_struct
id|ehci_qtd
op_star
id|qtd
suffix:semicolon
r_struct
id|urb
op_star
id|urb
suffix:semicolon
id|u32
id|token
op_assign
l_int|0
suffix:semicolon
id|qtd
op_assign
id|list_entry
(paren
id|entry
comma
r_struct
id|ehci_qtd
comma
id|qtd_list
)paren
suffix:semicolon
id|urb
op_assign
id|qtd-&gt;urb
suffix:semicolon
multiline_comment|/* clean up any state from previous QTD ...*/
r_if
c_cond
(paren
id|last
)paren
(brace
r_if
c_cond
(paren
id|likely
(paren
id|last-&gt;urb
op_ne
id|urb
)paren
)paren
(brace
id|ehci_urb_done
(paren
id|ehci
comma
id|last-&gt;urb
comma
id|regs
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
id|ehci_qtd_free
(paren
id|ehci
comma
id|last
)paren
suffix:semicolon
id|last
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* ignore urbs submitted during completions we reported */
r_if
c_cond
(paren
id|qtd
op_eq
id|end
)paren
r_break
suffix:semicolon
multiline_comment|/* hardware copies qtd out of qh overlay */
id|rmb
(paren
)paren
suffix:semicolon
id|token
op_assign
id|le32_to_cpu
(paren
id|qtd-&gt;hw_token
)paren
suffix:semicolon
multiline_comment|/* always clean up qtds the hc de-activated */
r_if
c_cond
(paren
(paren
id|token
op_amp
id|QTD_STS_ACTIVE
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|token
op_amp
id|QTD_STS_HALT
)paren
op_ne
l_int|0
)paren
(brace
id|stopped
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* magic dummy for some short reads; qh won&squot;t advance */
)brace
r_else
r_if
c_cond
(paren
id|IS_SHORT_READ
(paren
id|token
)paren
op_logical_and
(paren
id|qh-&gt;hw_alt_next
op_amp
id|QTD_MASK
)paren
op_eq
id|ehci-&gt;async-&gt;hw_alt_next
)paren
(brace
id|stopped
op_assign
l_int|1
suffix:semicolon
r_goto
id|halt
suffix:semicolon
)brace
multiline_comment|/* stop scanning when we reach qtds the hc is using */
)brace
r_else
r_if
c_cond
(paren
id|likely
(paren
op_logical_neg
id|stopped
op_logical_and
id|HCD_IS_RUNNING
(paren
id|ehci-&gt;hcd.state
)paren
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
r_else
(brace
id|stopped
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|HCD_IS_RUNNING
(paren
id|ehci-&gt;hcd.state
)paren
)paren
)paren
id|urb-&gt;status
op_assign
op_minus
id|ESHUTDOWN
suffix:semicolon
multiline_comment|/* ignore active urbs unless some previous qtd&n;&t;&t;&t; * for the urb faulted (including short read) or&n;&t;&t;&t; * its urb was canceled.  we may patch qh or qtds.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|likely
(paren
id|urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* issue status after short control reads */
r_if
c_cond
(paren
id|unlikely
(paren
id|do_status
op_ne
l_int|0
)paren
op_logical_and
id|QTD_PID
(paren
id|token
)paren
op_eq
l_int|0
multiline_comment|/* OUT */
)paren
(brace
id|do_status
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* token in overlay may be most current */
r_if
c_cond
(paren
id|state
op_eq
id|QH_STATE_IDLE
op_logical_and
id|cpu_to_le32
(paren
id|qtd-&gt;qtd_dma
)paren
op_eq
id|qh-&gt;hw_current
)paren
id|token
op_assign
id|le32_to_cpu
(paren
id|qh-&gt;hw_token
)paren
suffix:semicolon
multiline_comment|/* force halt for unlinked or blocked qh, so we&squot;ll&n;&t;&t;&t; * patch the qh later and so that completions can&squot;t&n;&t;&t;&t; * activate it while we &quot;know&quot; it&squot;s stopped.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|HALT_BIT
op_amp
id|qh-&gt;hw_token
)paren
op_eq
l_int|0
)paren
(brace
id|halt
suffix:colon
id|qh-&gt;hw_token
op_or_assign
id|HALT_BIT
suffix:semicolon
id|wmb
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* remove it from the queue */
id|spin_lock
(paren
op_amp
id|urb-&gt;lock
)paren
suffix:semicolon
id|qtd_copy_status
(paren
id|ehci
comma
id|urb
comma
id|qtd-&gt;length
comma
id|token
)paren
suffix:semicolon
id|do_status
op_assign
(paren
id|urb-&gt;status
op_eq
op_minus
id|EREMOTEIO
)paren
op_logical_and
id|usb_pipecontrol
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|urb-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stopped
op_logical_and
id|qtd-&gt;qtd_list.prev
op_ne
op_amp
id|qh-&gt;qtd_list
)paren
(brace
id|last
op_assign
id|list_entry
(paren
id|qtd-&gt;qtd_list.prev
comma
r_struct
id|ehci_qtd
comma
id|qtd_list
)paren
suffix:semicolon
id|last-&gt;hw_next
op_assign
id|qtd-&gt;hw_next
suffix:semicolon
)brace
id|list_del
(paren
op_amp
id|qtd-&gt;qtd_list
)paren
suffix:semicolon
id|last
op_assign
id|qtd
suffix:semicolon
)brace
multiline_comment|/* last urb&squot;s completion might still need calling */
r_if
c_cond
(paren
id|likely
(paren
id|last
op_ne
l_int|0
)paren
)paren
(brace
id|ehci_urb_done
(paren
id|ehci
comma
id|last-&gt;urb
comma
id|regs
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
id|ehci_qtd_free
(paren
id|ehci
comma
id|last
)paren
suffix:semicolon
)brace
multiline_comment|/* restore original state; caller must unlink or relink */
id|qh-&gt;qh_state
op_assign
id|state
suffix:semicolon
multiline_comment|/* be sure the hardware&squot;s done with the qh before refreshing&n;&t; * it after fault cleanup, or recovering from silicon wrongly&n;&t; * overlaying the dummy qtd (which reduces DMA chatter).&n;&t; */
r_if
c_cond
(paren
id|stopped
op_ne
l_int|0
op_logical_or
id|qh-&gt;hw_qtd_next
op_eq
id|EHCI_LIST_END
)paren
(brace
r_switch
c_cond
(paren
id|state
)paren
(brace
r_case
id|QH_STATE_IDLE
suffix:colon
id|qh_refresh
c_func
(paren
id|ehci
comma
id|qh
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QH_STATE_LINKED
suffix:colon
multiline_comment|/* should be rare for periodic transfers,&n;&t;&t;&t; * except maybe high bandwidth ...&n;&t;&t;&t; */
r_if
c_cond
(paren
id|qh-&gt;period
)paren
(brace
id|intr_deschedule
(paren
id|ehci
comma
id|qh
comma
l_int|1
)paren
suffix:semicolon
(paren
r_void
)paren
id|qh_schedule
(paren
id|ehci
comma
id|qh
)paren
suffix:semicolon
)brace
r_else
id|start_unlink_async
(paren
id|ehci
comma
id|qh
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* otherwise, unlink already started */
)brace
)brace
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
singleline_comment|// high bandwidth multiplier, as encoded in highspeed endpoint descriptors
DECL|macro|hb_mult
mdefine_line|#define hb_mult(wMaxPacketSize) (1 + (((wMaxPacketSize) &gt;&gt; 11) &amp; 0x03))
singleline_comment|// ... and packet size, for any kind of endpoint descriptor
DECL|macro|max_packet
mdefine_line|#define max_packet(wMaxPacketSize) ((wMaxPacketSize) &amp; 0x07ff)
multiline_comment|/*&n; * reverse of qh_urb_transaction:  free a list of TDs.&n; * used for cleanup after errors, before HC sees an URB&squot;s TDs.&n; */
DECL|function|qtd_list_free
r_static
r_void
id|qtd_list_free
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|list_head
op_star
id|qtd_list
)paren
(brace
r_struct
id|list_head
op_star
id|entry
comma
op_star
id|temp
suffix:semicolon
id|list_for_each_safe
(paren
id|entry
comma
id|temp
comma
id|qtd_list
)paren
(brace
r_struct
id|ehci_qtd
op_star
id|qtd
suffix:semicolon
id|qtd
op_assign
id|list_entry
(paren
id|entry
comma
r_struct
id|ehci_qtd
comma
id|qtd_list
)paren
suffix:semicolon
id|list_del
(paren
op_amp
id|qtd-&gt;qtd_list
)paren
suffix:semicolon
id|ehci_qtd_free
(paren
id|ehci
comma
id|qtd
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * create a list of filled qtds for this URB; won&squot;t link into qh.&n; */
r_static
r_struct
id|list_head
op_star
DECL|function|qh_urb_transaction
id|qh_urb_transaction
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|list_head
op_star
id|head
comma
r_int
id|flags
)paren
(brace
r_struct
id|ehci_qtd
op_star
id|qtd
comma
op_star
id|qtd_prev
suffix:semicolon
id|dma_addr_t
id|buf
suffix:semicolon
r_int
id|len
comma
id|maxpacket
suffix:semicolon
r_int
id|is_input
suffix:semicolon
id|u32
id|token
suffix:semicolon
multiline_comment|/*&n;&t; * URBs map to sequences of QTDs:  one logical transaction&n;&t; */
id|qtd
op_assign
id|ehci_qtd_alloc
(paren
id|ehci
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|qtd
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|qtd-&gt;qtd_list
comma
id|head
)paren
suffix:semicolon
id|qtd-&gt;urb
op_assign
id|urb
suffix:semicolon
id|token
op_assign
id|QTD_STS_ACTIVE
suffix:semicolon
id|token
op_or_assign
(paren
id|EHCI_TUNE_CERR
op_lshift
l_int|10
)paren
suffix:semicolon
multiline_comment|/* for split transactions, SplitXState initialized to zero */
id|len
op_assign
id|urb-&gt;transfer_buffer_length
suffix:semicolon
id|is_input
op_assign
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipecontrol
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
multiline_comment|/* SETUP pid */
id|qtd_fill
(paren
id|qtd
comma
id|urb-&gt;setup_dma
comma
r_sizeof
(paren
r_struct
id|usb_ctrlrequest
)paren
comma
id|token
op_or
(paren
l_int|2
multiline_comment|/* &quot;setup&quot; */
op_lshift
l_int|8
)paren
comma
l_int|8
)paren
suffix:semicolon
multiline_comment|/* ... and always at least one more pid */
id|token
op_xor_assign
id|QTD_TOGGLE
suffix:semicolon
id|qtd_prev
op_assign
id|qtd
suffix:semicolon
id|qtd
op_assign
id|ehci_qtd_alloc
(paren
id|ehci
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|qtd
)paren
)paren
r_goto
id|cleanup
suffix:semicolon
id|qtd-&gt;urb
op_assign
id|urb
suffix:semicolon
id|qtd_prev-&gt;hw_next
op_assign
id|QTD_NEXT
(paren
id|qtd-&gt;qtd_dma
)paren
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|qtd-&gt;qtd_list
comma
id|head
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * data transfer stage:  buffer setup&n;&t; */
r_if
c_cond
(paren
id|likely
(paren
id|len
OG
l_int|0
)paren
)paren
id|buf
op_assign
id|urb-&gt;transfer_dma
suffix:semicolon
r_else
id|buf
op_assign
l_int|0
suffix:semicolon
singleline_comment|// FIXME this &squot;buf&squot; check break some zlps...
r_if
c_cond
(paren
op_logical_neg
id|buf
op_logical_or
id|is_input
)paren
id|token
op_or_assign
(paren
l_int|1
multiline_comment|/* &quot;in&quot; */
op_lshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/* else it&squot;s already initted to &quot;out&quot; pid (0 &lt;&lt; 8) */
id|maxpacket
op_assign
id|max_packet
c_func
(paren
id|usb_maxpacket
c_func
(paren
id|urb-&gt;dev
comma
id|urb-&gt;pipe
comma
op_logical_neg
id|is_input
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * buffer gets wrapped in one or more qtds;&n;&t; * last one may be &quot;short&quot; (including zero len)&n;&t; * and may serve as a control status ack&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|this_qtd_len
suffix:semicolon
id|this_qtd_len
op_assign
id|qtd_fill
(paren
id|qtd
comma
id|buf
comma
id|len
comma
id|token
comma
id|maxpacket
)paren
suffix:semicolon
id|len
op_sub_assign
id|this_qtd_len
suffix:semicolon
id|buf
op_add_assign
id|this_qtd_len
suffix:semicolon
r_if
c_cond
(paren
id|is_input
)paren
id|qtd-&gt;hw_alt_next
op_assign
id|ehci-&gt;async-&gt;hw_alt_next
suffix:semicolon
multiline_comment|/* qh makes control packets use qtd toggle; maybe switch it */
r_if
c_cond
(paren
(paren
id|maxpacket
op_amp
(paren
id|this_qtd_len
op_plus
(paren
id|maxpacket
op_minus
l_int|1
)paren
)paren
)paren
op_eq
l_int|0
)paren
id|token
op_xor_assign
id|QTD_TOGGLE
suffix:semicolon
r_if
c_cond
(paren
id|likely
(paren
id|len
op_le
l_int|0
)paren
)paren
r_break
suffix:semicolon
id|qtd_prev
op_assign
id|qtd
suffix:semicolon
id|qtd
op_assign
id|ehci_qtd_alloc
(paren
id|ehci
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|qtd
)paren
)paren
r_goto
id|cleanup
suffix:semicolon
id|qtd-&gt;urb
op_assign
id|urb
suffix:semicolon
id|qtd_prev-&gt;hw_next
op_assign
id|QTD_NEXT
(paren
id|qtd-&gt;qtd_dma
)paren
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|qtd-&gt;qtd_list
comma
id|head
)paren
suffix:semicolon
)brace
multiline_comment|/* unless the bulk/interrupt caller wants a chance to clean&n;&t; * up after short reads, hc should advance qh past this urb&n;&t; */
r_if
c_cond
(paren
id|likely
(paren
(paren
id|urb-&gt;transfer_flags
op_amp
id|URB_SHORT_NOT_OK
)paren
op_eq
l_int|0
op_logical_or
id|usb_pipecontrol
(paren
id|urb-&gt;pipe
)paren
)paren
)paren
id|qtd-&gt;hw_alt_next
op_assign
id|EHCI_LIST_END
suffix:semicolon
multiline_comment|/*&n;&t; * control requests may need a terminating data &quot;status&quot; ack;&n;&t; * bulk ones may need a terminating short packet (zero length).&n;&t; */
r_if
c_cond
(paren
id|likely
(paren
id|buf
op_ne
l_int|0
)paren
)paren
(brace
r_int
id|one_more
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipecontrol
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
id|one_more
op_assign
l_int|1
suffix:semicolon
id|token
op_xor_assign
l_int|0x0100
suffix:semicolon
multiline_comment|/* &quot;in&quot; &lt;--&gt; &quot;out&quot;  */
id|token
op_or_assign
id|QTD_TOGGLE
suffix:semicolon
multiline_comment|/* force DATA1 */
)brace
r_else
r_if
c_cond
(paren
id|usb_pipebulk
(paren
id|urb-&gt;pipe
)paren
op_logical_and
(paren
id|urb-&gt;transfer_flags
op_amp
id|URB_ZERO_PACKET
)paren
op_logical_and
op_logical_neg
(paren
id|urb-&gt;transfer_buffer_length
op_mod
id|maxpacket
)paren
)paren
(brace
id|one_more
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|one_more
)paren
(brace
id|qtd_prev
op_assign
id|qtd
suffix:semicolon
id|qtd
op_assign
id|ehci_qtd_alloc
(paren
id|ehci
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|qtd
)paren
)paren
r_goto
id|cleanup
suffix:semicolon
id|qtd-&gt;urb
op_assign
id|urb
suffix:semicolon
id|qtd_prev-&gt;hw_next
op_assign
id|QTD_NEXT
(paren
id|qtd-&gt;qtd_dma
)paren
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|qtd-&gt;qtd_list
comma
id|head
)paren
suffix:semicolon
multiline_comment|/* never any data in such packets */
id|qtd_fill
(paren
id|qtd
comma
l_int|0
comma
l_int|0
comma
id|token
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* by default, enable interrupt on urb completion */
r_if
c_cond
(paren
id|likely
(paren
op_logical_neg
(paren
id|urb-&gt;transfer_flags
op_amp
id|URB_NO_INTERRUPT
)paren
)paren
)paren
id|qtd-&gt;hw_token
op_or_assign
id|__constant_cpu_to_le32
(paren
id|QTD_IOC
)paren
suffix:semicolon
r_return
id|head
suffix:semicolon
id|cleanup
suffix:colon
id|qtd_list_free
(paren
id|ehci
comma
id|urb
comma
id|head
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
singleline_comment|// Would be best to create all qh&squot;s from config descriptors,
singleline_comment|// when each interface/altsetting is established.  Unlink
singleline_comment|// any previous qh and cancel its urbs first; endpoints are
singleline_comment|// implicitly reset then (data toggle too).
singleline_comment|// That&squot;d mean updating how usbcore talks to HCDs. (2.7?)
multiline_comment|/*&n; * Each QH holds a qtd list; a QH is used for everything except iso.&n; *&n; * For interrupt urbs, the scheduler must set the microframe scheduling&n; * mask(s) each time the QH gets scheduled.  For highspeed, that&squot;s&n; * just one microframe in the s-mask.  For split interrupt transactions&n; * there are additional complications: c-mask, maybe FSTNs.&n; */
r_static
r_struct
id|ehci_qh
op_star
DECL|function|qh_make
id|qh_make
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|flags
)paren
(brace
r_struct
id|ehci_qh
op_star
id|qh
op_assign
id|ehci_qh_alloc
(paren
id|ehci
comma
id|flags
)paren
suffix:semicolon
id|u32
id|info1
op_assign
l_int|0
comma
id|info2
op_assign
l_int|0
suffix:semicolon
r_int
id|is_input
comma
id|type
suffix:semicolon
r_int
id|maxp
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|qh
)paren
r_return
id|qh
suffix:semicolon
multiline_comment|/*&n;&t; * init endpoint/device data for this QH&n;&t; */
id|info1
op_or_assign
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
op_lshift
l_int|8
suffix:semicolon
id|info1
op_or_assign
id|usb_pipedevice
(paren
id|urb-&gt;pipe
)paren
op_lshift
l_int|0
suffix:semicolon
id|is_input
op_assign
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
id|type
op_assign
id|usb_pipetype
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
id|maxp
op_assign
id|usb_maxpacket
(paren
id|urb-&gt;dev
comma
id|urb-&gt;pipe
comma
op_logical_neg
id|is_input
)paren
suffix:semicolon
multiline_comment|/* Compute interrupt scheduling parameters just once, and save.&n;&t; * - allowing for high bandwidth, how many nsec/uframe are used?&n;&t; * - split transactions need a second CSPLIT uframe; same question&n;&t; * - splits also need a schedule gap (for full/low speed I/O)&n;&t; * - qh has a polling interval&n;&t; *&n;&t; * For control/bulk requests, the HC or TT handles these.&n;&t; */
r_if
c_cond
(paren
id|type
op_eq
id|PIPE_INTERRUPT
)paren
(brace
id|qh-&gt;usecs
op_assign
id|usb_calc_bus_time
(paren
id|USB_SPEED_HIGH
comma
id|is_input
comma
l_int|0
comma
id|hb_mult
(paren
id|maxp
)paren
op_star
id|max_packet
(paren
id|maxp
)paren
)paren
suffix:semicolon
id|qh-&gt;start
op_assign
id|NO_FRAME
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;dev-&gt;speed
op_eq
id|USB_SPEED_HIGH
)paren
(brace
id|qh-&gt;c_usecs
op_assign
l_int|0
suffix:semicolon
id|qh-&gt;gap_uf
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* FIXME handle HS periods of less than 1 frame. */
id|qh-&gt;period
op_assign
id|urb-&gt;interval
op_rshift
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|qh-&gt;period
OL
l_int|1
)paren
(brace
id|dbg
(paren
l_string|&quot;intr period %d uframes, NYET!&quot;
comma
id|urb-&gt;interval
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* gap is f(FS/LS transfer times) */
id|qh-&gt;gap_uf
op_assign
l_int|1
op_plus
id|usb_calc_bus_time
(paren
id|urb-&gt;dev-&gt;speed
comma
id|is_input
comma
l_int|0
comma
id|maxp
)paren
op_div
(paren
l_int|125
op_star
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* FIXME this just approximates SPLIT/CSPLIT times */
r_if
c_cond
(paren
id|is_input
)paren
(brace
singleline_comment|// SPLIT, gap, CSPLIT+DATA
id|qh-&gt;c_usecs
op_assign
id|qh-&gt;usecs
op_plus
id|HS_USECS
(paren
l_int|0
)paren
suffix:semicolon
id|qh-&gt;usecs
op_assign
id|HS_USECS
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// SPLIT+DATA, gap, CSPLIT
id|qh-&gt;usecs
op_add_assign
id|HS_USECS
(paren
l_int|1
)paren
suffix:semicolon
id|qh-&gt;c_usecs
op_assign
id|HS_USECS
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|qh-&gt;period
op_assign
id|urb-&gt;interval
suffix:semicolon
)brace
)brace
multiline_comment|/* support for tt scheduling, and access to toggles */
id|qh-&gt;dev
op_assign
id|usb_get_dev
(paren
id|urb-&gt;dev
)paren
suffix:semicolon
multiline_comment|/* using TT? */
r_switch
c_cond
(paren
id|urb-&gt;dev-&gt;speed
)paren
(brace
r_case
id|USB_SPEED_LOW
suffix:colon
id|info1
op_or_assign
(paren
l_int|1
op_lshift
l_int|12
)paren
suffix:semicolon
multiline_comment|/* EPS &quot;low&quot; */
multiline_comment|/* FALL THROUGH */
r_case
id|USB_SPEED_FULL
suffix:colon
multiline_comment|/* EPS 0 means &quot;full&quot; */
r_if
c_cond
(paren
id|type
op_ne
id|PIPE_INTERRUPT
)paren
id|info1
op_or_assign
(paren
id|EHCI_TUNE_RL_TT
op_lshift
l_int|28
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|PIPE_CONTROL
)paren
(brace
id|info1
op_or_assign
(paren
l_int|1
op_lshift
l_int|27
)paren
suffix:semicolon
multiline_comment|/* for TT */
id|info1
op_or_assign
l_int|1
op_lshift
l_int|14
suffix:semicolon
multiline_comment|/* toggle from qtd */
)brace
id|info1
op_or_assign
id|maxp
op_lshift
l_int|16
suffix:semicolon
id|info2
op_or_assign
(paren
id|EHCI_TUNE_MULT_TT
op_lshift
l_int|30
)paren
suffix:semicolon
id|info2
op_or_assign
id|urb-&gt;dev-&gt;ttport
op_lshift
l_int|23
suffix:semicolon
multiline_comment|/* set the address of the TT; for ARC&squot;s integrated&n;&t;&t; * root hub tt, leave it zeroed.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ehci_is_ARC
c_func
(paren
id|ehci
)paren
op_logical_or
id|urb-&gt;dev-&gt;tt-&gt;hub
op_ne
id|ehci-&gt;hcd.self.root_hub
)paren
id|info2
op_or_assign
id|urb-&gt;dev-&gt;tt-&gt;hub-&gt;devnum
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* NOTE:  if (PIPE_INTERRUPT) { scheduler sets c-mask } */
r_break
suffix:semicolon
r_case
id|USB_SPEED_HIGH
suffix:colon
multiline_comment|/* no TT involved */
id|info1
op_or_assign
(paren
l_int|2
op_lshift
l_int|12
)paren
suffix:semicolon
multiline_comment|/* EPS &quot;high&quot; */
r_if
c_cond
(paren
id|type
op_eq
id|PIPE_CONTROL
)paren
(brace
id|info1
op_or_assign
(paren
id|EHCI_TUNE_RL_HS
op_lshift
l_int|28
)paren
suffix:semicolon
id|info1
op_or_assign
l_int|64
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* usb2 fixed maxpacket */
id|info1
op_or_assign
l_int|1
op_lshift
l_int|14
suffix:semicolon
multiline_comment|/* toggle from qtd */
id|info2
op_or_assign
(paren
id|EHCI_TUNE_MULT_HS
op_lshift
l_int|30
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|type
op_eq
id|PIPE_BULK
)paren
(brace
id|info1
op_or_assign
(paren
id|EHCI_TUNE_RL_HS
op_lshift
l_int|28
)paren
suffix:semicolon
id|info1
op_or_assign
l_int|512
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* usb2 fixed maxpacket */
id|info2
op_or_assign
(paren
id|EHCI_TUNE_MULT_HS
op_lshift
l_int|30
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* PIPE_INTERRUPT */
id|info1
op_or_assign
id|max_packet
(paren
id|maxp
)paren
op_lshift
l_int|16
suffix:semicolon
id|info2
op_or_assign
id|hb_mult
(paren
id|maxp
)paren
op_lshift
l_int|30
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|dbg
(paren
l_string|&quot;bogus dev %p speed %d&quot;
comma
id|urb-&gt;dev
comma
id|urb-&gt;dev-&gt;speed
)paren
suffix:semicolon
id|done
suffix:colon
id|qh_put
(paren
id|qh
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* NOTE:  if (PIPE_INTERRUPT) { scheduler sets s-mask } */
multiline_comment|/* init as live, toggle clear, advance to dummy */
id|qh-&gt;qh_state
op_assign
id|QH_STATE_IDLE
suffix:semicolon
id|qh-&gt;hw_info1
op_assign
id|cpu_to_le32
(paren
id|info1
)paren
suffix:semicolon
id|qh-&gt;hw_info2
op_assign
id|cpu_to_le32
(paren
id|info2
)paren
suffix:semicolon
id|usb_settoggle
(paren
id|urb-&gt;dev
comma
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
comma
op_logical_neg
id|is_input
comma
l_int|1
)paren
suffix:semicolon
id|qh_refresh
(paren
id|ehci
comma
id|qh
)paren
suffix:semicolon
r_return
id|qh
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* move qh (and its qtds) onto async queue; maybe enable queue.  */
DECL|function|qh_link_async
r_static
r_void
id|qh_link_async
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|ehci_qh
op_star
id|qh
)paren
(brace
id|__le32
id|dma
op_assign
id|QH_NEXT
(paren
id|qh-&gt;qh_dma
)paren
suffix:semicolon
r_struct
id|ehci_qh
op_star
id|head
suffix:semicolon
multiline_comment|/* (re)start the async schedule? */
id|head
op_assign
id|ehci-&gt;async
suffix:semicolon
id|timer_action_done
(paren
id|ehci
comma
id|TIMER_ASYNC_OFF
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|head-&gt;qh_next.qh
)paren
(brace
id|u32
id|cmd
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cmd
op_amp
id|CMD_ASE
)paren
)paren
(brace
multiline_comment|/* in case a clear of CMD_ASE didn&squot;t take yet */
(paren
r_void
)paren
id|handshake
(paren
op_amp
id|ehci-&gt;regs-&gt;status
comma
id|STS_ASS
comma
l_int|0
comma
l_int|150
)paren
suffix:semicolon
id|cmd
op_or_assign
id|CMD_ASE
op_or
id|CMD_RUN
suffix:semicolon
id|writel
(paren
id|cmd
comma
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
id|ehci-&gt;hcd.state
op_assign
id|USB_STATE_RUNNING
suffix:semicolon
multiline_comment|/* posted write need not be known to HC yet ... */
)brace
)brace
multiline_comment|/* clear halt and/or toggle; and maybe recover from silicon quirk */
r_if
c_cond
(paren
id|qh-&gt;qh_state
op_eq
id|QH_STATE_IDLE
)paren
id|qh_refresh
(paren
id|ehci
comma
id|qh
)paren
suffix:semicolon
multiline_comment|/* splice right after start */
id|qh-&gt;qh_next
op_assign
id|head-&gt;qh_next
suffix:semicolon
id|qh-&gt;hw_next
op_assign
id|head-&gt;hw_next
suffix:semicolon
id|wmb
(paren
)paren
suffix:semicolon
id|head-&gt;qh_next.qh
op_assign
id|qh
suffix:semicolon
id|head-&gt;hw_next
op_assign
id|dma
suffix:semicolon
id|qh-&gt;qh_state
op_assign
id|QH_STATE_LINKED
suffix:semicolon
multiline_comment|/* qtd completions reported later by interrupt */
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|macro|QH_ADDR_MASK
mdefine_line|#define&t;QH_ADDR_MASK&t;__constant_cpu_to_le32(0x7f)
multiline_comment|/*&n; * For control/bulk/interrupt, return QH with these TDs appended.&n; * Allocates and initializes the QH if necessary.&n; * Returns null if it can&squot;t allocate a QH it needs to.&n; * If the QH has TDs (urbs) already, that&squot;s great.&n; */
DECL|function|qh_append_tds
r_static
r_struct
id|ehci_qh
op_star
id|qh_append_tds
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|list_head
op_star
id|qtd_list
comma
r_int
id|epnum
comma
r_void
op_star
op_star
id|ptr
)paren
(brace
r_struct
id|ehci_qh
op_star
id|qh
op_assign
l_int|NULL
suffix:semicolon
id|qh
op_assign
(paren
r_struct
id|ehci_qh
op_star
)paren
op_star
id|ptr
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
id|qh
op_eq
l_int|NULL
)paren
)paren
(brace
multiline_comment|/* can&squot;t sleep here, we have ehci-&gt;lock... */
id|qh
op_assign
id|qh_make
(paren
id|ehci
comma
id|urb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
op_star
id|ptr
op_assign
id|qh
suffix:semicolon
)brace
r_if
c_cond
(paren
id|likely
(paren
id|qh
op_ne
l_int|NULL
)paren
)paren
(brace
r_struct
id|ehci_qtd
op_star
id|qtd
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
id|list_empty
(paren
id|qtd_list
)paren
)paren
)paren
id|qtd
op_assign
l_int|NULL
suffix:semicolon
r_else
id|qtd
op_assign
id|list_entry
(paren
id|qtd_list-&gt;next
comma
r_struct
id|ehci_qtd
comma
id|qtd_list
)paren
suffix:semicolon
multiline_comment|/* control qh may need patching ... */
r_if
c_cond
(paren
id|unlikely
(paren
id|epnum
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* usb_reset_device() briefly reverts to address 0 */
r_if
c_cond
(paren
id|usb_pipedevice
(paren
id|urb-&gt;pipe
)paren
op_eq
l_int|0
)paren
id|qh-&gt;hw_info1
op_and_assign
op_complement
id|QH_ADDR_MASK
suffix:semicolon
)brace
multiline_comment|/* just one way to queue requests: swap with the dummy qtd.&n;&t;&t; * only hc or qh_refresh() ever modify the overlay.&n;&t;&t; */
r_if
c_cond
(paren
id|likely
(paren
id|qtd
op_ne
l_int|0
)paren
)paren
(brace
r_struct
id|ehci_qtd
op_star
id|dummy
suffix:semicolon
id|dma_addr_t
id|dma
suffix:semicolon
id|__le32
id|token
suffix:semicolon
multiline_comment|/* to avoid racing the HC, use the dummy td instead of&n;&t;&t;&t; * the first td of our list (becomes new dummy).  both&n;&t;&t;&t; * tds stay deactivated until we&squot;re done, when the&n;&t;&t;&t; * HC is allowed to fetch the old dummy (4.10.2).&n;&t;&t;&t; */
id|token
op_assign
id|qtd-&gt;hw_token
suffix:semicolon
id|qtd-&gt;hw_token
op_assign
id|HALT_BIT
suffix:semicolon
id|wmb
(paren
)paren
suffix:semicolon
id|dummy
op_assign
id|qh-&gt;dummy
suffix:semicolon
id|dma
op_assign
id|dummy-&gt;qtd_dma
suffix:semicolon
op_star
id|dummy
op_assign
op_star
id|qtd
suffix:semicolon
id|dummy-&gt;qtd_dma
op_assign
id|dma
suffix:semicolon
id|list_del
(paren
op_amp
id|qtd-&gt;qtd_list
)paren
suffix:semicolon
id|list_add
(paren
op_amp
id|dummy-&gt;qtd_list
comma
id|qtd_list
)paren
suffix:semicolon
id|__list_splice
(paren
id|qtd_list
comma
id|qh-&gt;qtd_list.prev
)paren
suffix:semicolon
id|ehci_qtd_init
(paren
id|qtd
comma
id|qtd-&gt;qtd_dma
)paren
suffix:semicolon
id|qh-&gt;dummy
op_assign
id|qtd
suffix:semicolon
multiline_comment|/* hc must see the new dummy at list end */
id|dma
op_assign
id|qtd-&gt;qtd_dma
suffix:semicolon
id|qtd
op_assign
id|list_entry
(paren
id|qh-&gt;qtd_list.prev
comma
r_struct
id|ehci_qtd
comma
id|qtd_list
)paren
suffix:semicolon
id|qtd-&gt;hw_next
op_assign
id|QTD_NEXT
(paren
id|dma
)paren
suffix:semicolon
multiline_comment|/* let the hc process these next qtds */
id|wmb
(paren
)paren
suffix:semicolon
id|dummy-&gt;hw_token
op_assign
id|token
suffix:semicolon
id|urb-&gt;hcpriv
op_assign
id|qh_get
(paren
id|qh
)paren
suffix:semicolon
)brace
)brace
r_return
id|qh
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
r_static
r_int
DECL|function|submit_async
id|submit_async
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|usb_host_endpoint
op_star
id|ep
comma
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|list_head
op_star
id|qtd_list
comma
r_int
id|mem_flags
)paren
(brace
r_struct
id|ehci_qtd
op_star
id|qtd
suffix:semicolon
r_int
id|epnum
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|ehci_qh
op_star
id|qh
op_assign
l_int|NULL
suffix:semicolon
id|qtd
op_assign
id|list_entry
(paren
id|qtd_list-&gt;next
comma
r_struct
id|ehci_qtd
comma
id|qtd_list
)paren
suffix:semicolon
id|epnum
op_assign
id|ep-&gt;desc.bEndpointAddress
suffix:semicolon
macro_line|#ifdef EHCI_URB_TRACE
id|ehci_dbg
(paren
id|ehci
comma
l_string|&quot;%s %s urb %p ep%d%s len %d, qtd %p [qh %p]&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|urb-&gt;dev-&gt;devpath
comma
id|urb
comma
id|epnum
op_amp
l_int|0x0f
comma
(paren
id|epnum
op_amp
id|USB_DIR_IN
)paren
ques
c_cond
l_string|&quot;in&quot;
suffix:colon
l_string|&quot;out&quot;
comma
id|urb-&gt;transfer_buffer_length
comma
id|qtd
comma
id|ep-&gt;hcpriv
)paren
suffix:semicolon
macro_line|#endif
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|qh
op_assign
id|qh_append_tds
(paren
id|ehci
comma
id|urb
comma
id|qtd_list
comma
id|epnum
comma
op_amp
id|ep-&gt;hcpriv
)paren
suffix:semicolon
multiline_comment|/* Control/bulk operations through TTs don&squot;t need scheduling,&n;&t; * the HC and TT handle it when the TT has a buffer ready.&n;&t; */
r_if
c_cond
(paren
id|likely
(paren
id|qh
op_ne
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|likely
(paren
id|qh-&gt;qh_state
op_eq
id|QH_STATE_IDLE
)paren
)paren
id|qh_link_async
(paren
id|ehci
comma
id|qh_get
(paren
id|qh
)paren
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
id|qh
op_eq
l_int|0
)paren
)paren
(brace
id|qtd_list_free
(paren
id|ehci
comma
id|urb
comma
id|qtd_list
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* the async qh for the qtds being reclaimed are now unlinked from the HC */
DECL|function|end_unlink_async
r_static
r_void
id|end_unlink_async
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|ehci_qh
op_star
id|qh
op_assign
id|ehci-&gt;reclaim
suffix:semicolon
r_struct
id|ehci_qh
op_star
id|next
suffix:semicolon
id|timer_action_done
(paren
id|ehci
comma
id|TIMER_IAA_WATCHDOG
)paren
suffix:semicolon
singleline_comment|// qh-&gt;hw_next = cpu_to_le32 (qh-&gt;qh_dma);
id|qh-&gt;qh_state
op_assign
id|QH_STATE_IDLE
suffix:semicolon
id|qh-&gt;qh_next.qh
op_assign
l_int|NULL
suffix:semicolon
id|qh_put
(paren
id|qh
)paren
suffix:semicolon
singleline_comment|// refcount from reclaim 
multiline_comment|/* other unlink(s) may be pending (in QH_STATE_UNLINK_WAIT) */
id|next
op_assign
id|qh-&gt;reclaim
suffix:semicolon
id|ehci-&gt;reclaim
op_assign
id|next
suffix:semicolon
id|ehci-&gt;reclaim_ready
op_assign
l_int|0
suffix:semicolon
id|qh-&gt;reclaim
op_assign
l_int|NULL
suffix:semicolon
id|qh_completions
(paren
id|ehci
comma
id|qh
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|qh-&gt;qtd_list
)paren
op_logical_and
id|HCD_IS_RUNNING
(paren
id|ehci-&gt;hcd.state
)paren
)paren
id|qh_link_async
(paren
id|ehci
comma
id|qh
)paren
suffix:semicolon
r_else
(brace
id|qh_put
(paren
id|qh
)paren
suffix:semicolon
singleline_comment|// refcount from async list
multiline_comment|/* it&squot;s not free to turn the async schedule on/off; leave it&n;&t;&t; * active but idle for a while once it empties.&n;&t;&t; */
r_if
c_cond
(paren
id|HCD_IS_RUNNING
(paren
id|ehci-&gt;hcd.state
)paren
op_logical_and
id|ehci-&gt;async-&gt;qh_next.qh
op_eq
l_int|0
)paren
id|timer_action
(paren
id|ehci
comma
id|TIMER_ASYNC_OFF
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|next
)paren
(brace
id|ehci-&gt;reclaim
op_assign
l_int|NULL
suffix:semicolon
id|start_unlink_async
(paren
id|ehci
comma
id|next
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* makes sure the async qh will become idle */
multiline_comment|/* caller must own ehci-&gt;lock */
DECL|function|start_unlink_async
r_static
r_void
id|start_unlink_async
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|ehci_qh
op_star
id|qh
)paren
(brace
r_int
id|cmd
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
r_struct
id|ehci_qh
op_star
id|prev
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|ehci-&gt;reclaim
op_logical_or
(paren
id|qh-&gt;qh_state
op_ne
id|QH_STATE_LINKED
op_logical_and
id|qh-&gt;qh_state
op_ne
id|QH_STATE_UNLINK_WAIT
)paren
macro_line|#ifdef CONFIG_SMP
singleline_comment|// this macro lies except on SMP compiles
op_logical_or
op_logical_neg
id|spin_is_locked
(paren
op_amp
id|ehci-&gt;lock
)paren
macro_line|#endif
)paren
id|BUG
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* stop async schedule right now? */
r_if
c_cond
(paren
id|unlikely
(paren
id|qh
op_eq
id|ehci-&gt;async
)paren
)paren
(brace
multiline_comment|/* can&squot;t get here without STS_ASS set */
r_if
c_cond
(paren
id|ehci-&gt;hcd.state
op_ne
id|USB_STATE_HALT
)paren
(brace
id|writel
(paren
id|cmd
op_amp
op_complement
id|CMD_ASE
comma
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
id|wmb
(paren
)paren
suffix:semicolon
singleline_comment|// handshake later, if we need to
)brace
id|timer_action_done
(paren
id|ehci
comma
id|TIMER_ASYNC_OFF
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|qh-&gt;qh_state
op_assign
id|QH_STATE_UNLINK
suffix:semicolon
id|ehci-&gt;reclaim
op_assign
id|qh
op_assign
id|qh_get
(paren
id|qh
)paren
suffix:semicolon
id|prev
op_assign
id|ehci-&gt;async
suffix:semicolon
r_while
c_loop
(paren
id|prev-&gt;qh_next.qh
op_ne
id|qh
)paren
id|prev
op_assign
id|prev-&gt;qh_next.qh
suffix:semicolon
id|prev-&gt;hw_next
op_assign
id|qh-&gt;hw_next
suffix:semicolon
id|prev-&gt;qh_next
op_assign
id|qh-&gt;qh_next
suffix:semicolon
id|wmb
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
id|ehci-&gt;hcd.state
op_eq
id|USB_STATE_HALT
)paren
)paren
(brace
multiline_comment|/* if (unlikely (qh-&gt;reclaim != 0))&n;&t;&t; * &t;this will recurse, probably not much&n;&t;&t; */
id|end_unlink_async
(paren
id|ehci
comma
l_int|NULL
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ehci-&gt;reclaim_ready
op_assign
l_int|0
suffix:semicolon
id|cmd
op_or_assign
id|CMD_IAAD
suffix:semicolon
id|writel
(paren
id|cmd
comma
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
(paren
r_void
)paren
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
id|timer_action
(paren
id|ehci
comma
id|TIMER_IAA_WATCHDOG
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
r_static
r_void
DECL|function|scan_async
id|scan_async
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|ehci_qh
op_star
id|qh
suffix:semicolon
r_enum
id|ehci_timer_action
id|action
op_assign
id|TIMER_IO_WATCHDOG
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_increment
(paren
id|ehci-&gt;stamp
)paren
)paren
id|ehci-&gt;stamp
op_increment
suffix:semicolon
id|timer_action_done
(paren
id|ehci
comma
id|TIMER_ASYNC_SHRINK
)paren
suffix:semicolon
id|rescan
suffix:colon
id|qh
op_assign
id|ehci-&gt;async-&gt;qh_next.qh
suffix:semicolon
r_if
c_cond
(paren
id|likely
(paren
id|qh
op_ne
l_int|0
)paren
)paren
(brace
r_do
(brace
multiline_comment|/* clean any finished work for this qh */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|qh-&gt;qtd_list
)paren
op_logical_and
id|qh-&gt;stamp
op_ne
id|ehci-&gt;stamp
)paren
(brace
r_int
id|temp
suffix:semicolon
multiline_comment|/* unlinks could happen here; completion&n;&t;&t;&t;&t; * reporting drops the lock.  rescan using&n;&t;&t;&t;&t; * the latest schedule, but don&squot;t rescan&n;&t;&t;&t;&t; * qhs we already finished (no looping).&n;&t;&t;&t;&t; */
id|qh
op_assign
id|qh_get
(paren
id|qh
)paren
suffix:semicolon
id|qh-&gt;stamp
op_assign
id|ehci-&gt;stamp
suffix:semicolon
id|temp
op_assign
id|qh_completions
(paren
id|ehci
comma
id|qh
comma
id|regs
)paren
suffix:semicolon
id|qh_put
(paren
id|qh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|temp
op_ne
l_int|0
)paren
(brace
r_goto
id|rescan
suffix:semicolon
)brace
)brace
multiline_comment|/* unlink idle entries, reducing HC PCI usage as well&n;&t;&t;&t; * as HCD schedule-scanning costs.  delay for any qh&n;&t;&t;&t; * we just scanned, there&squot;s a not-unusual case that it&n;&t;&t;&t; * doesn&squot;t stay idle for long.&n;&t;&t;&t; * (plus, avoids some kind of re-activation race.)&n;&t;&t;&t; */
r_if
c_cond
(paren
id|list_empty
(paren
op_amp
id|qh-&gt;qtd_list
)paren
)paren
(brace
r_if
c_cond
(paren
id|qh-&gt;stamp
op_eq
id|ehci-&gt;stamp
)paren
id|action
op_assign
id|TIMER_ASYNC_SHRINK
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|ehci-&gt;reclaim
op_logical_and
id|qh-&gt;qh_state
op_eq
id|QH_STATE_LINKED
)paren
id|start_unlink_async
(paren
id|ehci
comma
id|qh
)paren
suffix:semicolon
)brace
id|qh
op_assign
id|qh-&gt;qh_next.qh
suffix:semicolon
)brace
r_while
c_loop
(paren
id|qh
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|action
op_eq
id|TIMER_ASYNC_SHRINK
)paren
id|timer_action
(paren
id|ehci
comma
id|TIMER_ASYNC_SHRINK
)paren
suffix:semicolon
)brace
eof
