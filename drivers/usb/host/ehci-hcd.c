multiline_comment|/*&n; * Copyright (c) 2000-2004 by David Brownell&n; * &n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2 of the License, or (at your&n; * option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY&n; * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License&n; * for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software Foundation,&n; * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#ifdef CONFIG_USB_DEBUG
DECL|macro|DEBUG
mdefine_line|#define DEBUG
macro_line|#else
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#endif
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/dmapool.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/reboot.h&gt;
macro_line|#include &lt;linux/usb.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;linux/dma-mapping.h&gt;
macro_line|#include &quot;../core/hcd.h&quot;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/unaligned.h&gt;
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * EHCI hc_driver implementation ... experimental, incomplete.&n; * Based on the final 1.0 register interface specification.&n; *&n; * USB 2.0 shows up in upcoming www.pcmcia.org technology.&n; * First was PCMCIA, like ISA; then CardBus, which is PCI.&n; * Next comes &quot;CardBay&quot;, using USB 2.0 signals.&n; *&n; * Contains additional contributions by Brad Hards, Rory Bolt, and others.&n; * Special thanks to Intel and VIA for providing host controllers to&n; * test this driver on, and Cypress (including In-System Design) for&n; * providing early devices for those host controllers to talk to!&n; *&n; * HISTORY:&n; *&n; * 2004-05-10 Root hub and PCI suspend/resume support; remote wakeup. (db)&n; * 2004-02-24 Replace pci_* with generic dma_* API calls (dsaxena@plexity.net)&n; * 2003-12-29 Rewritten high speed iso transfer support (by Michal Sojka,&n; *&t;&lt;sojkam@centrum.cz&gt;, updates by DB).&n; *&n; * 2002-11-29&t;Correct handling for hw async_next register.&n; * 2002-08-06&t;Handling for bulk and interrupt transfers is mostly shared;&n; *&t;only scheduling is different, no arbitrary limitations.&n; * 2002-07-25&t;Sanity check PCI reads, mostly for better cardbus support,&n; * &t;clean up HC run state handshaking.&n; * 2002-05-24&t;Preliminary FS/LS interrupts, using scheduling shortcuts&n; * 2002-05-11&t;Clear TT errors for FS/LS ctrl/bulk.  Fill in some other&n; *&t;missing pieces:  enabling 64bit dma, handoff from BIOS/SMM.&n; * 2002-05-07&t;Some error path cleanups to report better errors; wmb();&n; *&t;use non-CVS version id; better iso bandwidth claim.&n; * 2002-04-19&t;Control/bulk/interrupt submit no longer uses giveback() on&n; *&t;errors in submit path.  Bugfixes to interrupt scheduling/processing.&n; * 2002-03-05&t;Initial high-speed ISO support; reduce ITD memory; shift&n; *&t;more checking to generic hcd framework (db).  Make it work with&n; *&t;Philips EHCI; reduce PCI traffic; shorten IRQ path (Rory Bolt).&n; * 2002-01-14&t;Minor cleanup; version synch.&n; * 2002-01-08&t;Fix roothub handoff of FS/LS to companion controllers.&n; * 2002-01-04&t;Control/Bulk queuing behaves.&n; *&n; * 2001-12-12&t;Initial patch version for Linux 2.5.1 kernel.&n; * 2001-June&t;Works with usb-storage and NEC EHCI on 2.4&n; */
DECL|macro|DRIVER_VERSION
mdefine_line|#define DRIVER_VERSION &quot;26 Oct 2004&quot;
DECL|macro|DRIVER_AUTHOR
mdefine_line|#define DRIVER_AUTHOR &quot;David Brownell&quot;
DECL|macro|DRIVER_DESC
mdefine_line|#define DRIVER_DESC &quot;USB 2.0 &squot;Enhanced&squot; Host Controller (EHCI) Driver&quot;
DECL|variable|hcd_name
r_static
r_const
r_char
id|hcd_name
(braket
)braket
op_assign
l_string|&quot;ehci_hcd&quot;
suffix:semicolon
DECL|macro|EHCI_VERBOSE_DEBUG
macro_line|#undef EHCI_VERBOSE_DEBUG
DECL|macro|EHCI_URB_TRACE
macro_line|#undef EHCI_URB_TRACE
macro_line|#ifdef DEBUG
DECL|macro|EHCI_STATS
mdefine_line|#define EHCI_STATS
macro_line|#endif
multiline_comment|/* magic numbers that can affect system performance */
DECL|macro|EHCI_TUNE_CERR
mdefine_line|#define&t;EHCI_TUNE_CERR&t;&t;3&t;/* 0-3 qtd retries; 0 == don&squot;t stop */
DECL|macro|EHCI_TUNE_RL_HS
mdefine_line|#define&t;EHCI_TUNE_RL_HS&t;&t;4&t;/* nak throttle; see 4.9 */
DECL|macro|EHCI_TUNE_RL_TT
mdefine_line|#define&t;EHCI_TUNE_RL_TT&t;&t;0
DECL|macro|EHCI_TUNE_MULT_HS
mdefine_line|#define&t;EHCI_TUNE_MULT_HS&t;1&t;/* 1-3 transactions/uframe; 4.10.3 */
DECL|macro|EHCI_TUNE_MULT_TT
mdefine_line|#define&t;EHCI_TUNE_MULT_TT&t;1
DECL|macro|EHCI_TUNE_FLS
mdefine_line|#define&t;EHCI_TUNE_FLS&t;&t;2&t;/* (small) 256 frame schedule */
DECL|macro|EHCI_IAA_JIFFIES
mdefine_line|#define EHCI_IAA_JIFFIES&t;(HZ/100)&t;/* arbitrary; ~10 msec */
DECL|macro|EHCI_IO_JIFFIES
mdefine_line|#define EHCI_IO_JIFFIES&t;&t;(HZ/10)&t;&t;/* io watchdog &gt; irq_thresh */
DECL|macro|EHCI_ASYNC_JIFFIES
mdefine_line|#define EHCI_ASYNC_JIFFIES&t;(HZ/20)&t;&t;/* async idle timeout */
DECL|macro|EHCI_SHRINK_JIFFIES
mdefine_line|#define EHCI_SHRINK_JIFFIES&t;(HZ/200)&t;/* async qh unlink delay */
multiline_comment|/* Initial IRQ latency:  lower than default */
DECL|variable|log2_irq_thresh
r_static
r_int
id|log2_irq_thresh
op_assign
l_int|0
suffix:semicolon
singleline_comment|// 0 to 6
id|module_param
(paren
id|log2_irq_thresh
comma
r_int
comma
id|S_IRUGO
)paren
suffix:semicolon
id|MODULE_PARM_DESC
(paren
id|log2_irq_thresh
comma
l_string|&quot;log2 IRQ latency, 1-64 microframes&quot;
)paren
suffix:semicolon
DECL|macro|INTR_MASK
mdefine_line|#define&t;INTR_MASK (STS_IAA | STS_FATAL | STS_PCD | STS_ERR | STS_INT)
multiline_comment|/*-------------------------------------------------------------------------*/
macro_line|#include &quot;ehci.h&quot;
macro_line|#include &quot;ehci-dbg.c&quot;
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * handshake - spin reading hc until handshake completes or fails&n; * @ptr: address of hc register to be read&n; * @mask: bits to look at in result of read&n; * @done: value of those bits when handshake succeeds&n; * @usec: timeout in microseconds&n; *&n; * Returns negative errno, or zero on success&n; *&n; * Success happens when the &quot;mask&quot; bits have the specified value (hardware&n; * handshake done).  There are two failure modes:  &quot;usec&quot; have passed (major&n; * hardware flakeout), or the register reads as all-ones (hardware removed).&n; *&n; * That last failure should_only happen in cases like physical cardbus eject&n; * before driver shutdown. But it also seems to be caused by bugs in cardbus&n; * bridge shutdown:  shutting down the bridge before the devices using it.&n; */
DECL|function|handshake
r_static
r_int
id|handshake
(paren
r_void
id|__iomem
op_star
id|ptr
comma
id|u32
id|mask
comma
id|u32
id|done
comma
r_int
id|usec
)paren
(brace
id|u32
id|result
suffix:semicolon
r_do
(brace
id|result
op_assign
id|readl
(paren
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
op_complement
(paren
id|u32
)paren
l_int|0
)paren
multiline_comment|/* card removed */
r_return
op_minus
id|ENODEV
suffix:semicolon
id|result
op_and_assign
id|mask
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
id|done
)paren
r_return
l_int|0
suffix:semicolon
id|udelay
(paren
l_int|1
)paren
suffix:semicolon
id|usec
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
id|usec
OG
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|ETIMEDOUT
suffix:semicolon
)brace
multiline_comment|/* force HC to halt state from unknown (EHCI spec section 2.3) */
DECL|function|ehci_halt
r_static
r_int
id|ehci_halt
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
)paren
(brace
id|u32
id|temp
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;status
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|temp
op_amp
id|STS_HALT
)paren
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|temp
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
id|temp
op_and_assign
op_complement
id|CMD_RUN
suffix:semicolon
id|writel
(paren
id|temp
comma
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
r_return
id|handshake
(paren
op_amp
id|ehci-&gt;regs-&gt;status
comma
id|STS_HALT
comma
id|STS_HALT
comma
l_int|16
op_star
l_int|125
)paren
suffix:semicolon
)brace
multiline_comment|/* reset a non-running (STS_HALT == 1) controller */
DECL|function|ehci_reset
r_static
r_int
id|ehci_reset
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
)paren
(brace
id|u32
id|command
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
id|command
op_or_assign
id|CMD_RESET
suffix:semicolon
id|dbg_cmd
(paren
id|ehci
comma
l_string|&quot;reset&quot;
comma
id|command
)paren
suffix:semicolon
id|writel
(paren
id|command
comma
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
id|ehci-&gt;hcd.state
op_assign
id|USB_STATE_HALT
suffix:semicolon
id|ehci-&gt;next_statechange
op_assign
id|jiffies
suffix:semicolon
r_return
id|handshake
(paren
op_amp
id|ehci-&gt;regs-&gt;command
comma
id|CMD_RESET
comma
l_int|0
comma
l_int|250
op_star
l_int|1000
)paren
suffix:semicolon
)brace
multiline_comment|/* idle the controller (from running) */
DECL|function|ehci_quiesce
r_static
r_void
id|ehci_quiesce
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
)paren
(brace
id|u32
id|temp
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
op_logical_neg
id|HCD_IS_RUNNING
(paren
id|ehci-&gt;hcd.state
)paren
)paren
id|BUG
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* wait for any schedule enables/disables to take effect */
id|temp
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
op_lshift
l_int|10
suffix:semicolon
id|temp
op_and_assign
id|STS_ASS
op_or
id|STS_PSS
suffix:semicolon
r_if
c_cond
(paren
id|handshake
(paren
op_amp
id|ehci-&gt;regs-&gt;status
comma
id|STS_ASS
op_or
id|STS_PSS
comma
id|temp
comma
l_int|16
op_star
l_int|125
)paren
op_ne
l_int|0
)paren
(brace
id|ehci-&gt;hcd.state
op_assign
id|USB_STATE_HALT
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* then disable anything that&squot;s still active */
id|temp
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
id|temp
op_and_assign
op_complement
(paren
id|CMD_ASE
op_or
id|CMD_IAAD
op_or
id|CMD_PSE
)paren
suffix:semicolon
id|writel
(paren
id|temp
comma
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
multiline_comment|/* hardware can take 16 microframes to turn off ... */
r_if
c_cond
(paren
id|handshake
(paren
op_amp
id|ehci-&gt;regs-&gt;status
comma
id|STS_ASS
op_or
id|STS_PSS
comma
l_int|0
comma
l_int|16
op_star
l_int|125
)paren
op_ne
l_int|0
)paren
(brace
id|ehci-&gt;hcd.state
op_assign
id|USB_STATE_HALT
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
r_static
r_void
id|ehci_work
c_func
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
macro_line|#include &quot;ehci-hub.c&quot;
macro_line|#include &quot;ehci-mem.c&quot;
macro_line|#include &quot;ehci-q.c&quot;
macro_line|#include &quot;ehci-sched.c&quot;
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|ehci_watchdog
r_static
r_void
id|ehci_watchdog
(paren
r_int
r_int
id|param
)paren
(brace
r_struct
id|ehci_hcd
op_star
id|ehci
op_assign
(paren
r_struct
id|ehci_hcd
op_star
)paren
id|param
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* lost IAA irqs wedge things badly; seen with a vt8235 */
r_if
c_cond
(paren
id|ehci-&gt;reclaim
)paren
(brace
id|u32
id|status
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|STS_IAA
)paren
(brace
id|ehci_vdbg
(paren
id|ehci
comma
l_string|&quot;lost IAA&bslash;n&quot;
)paren
suffix:semicolon
id|COUNT
(paren
id|ehci-&gt;stats.lost_iaa
)paren
suffix:semicolon
id|writel
(paren
id|STS_IAA
comma
op_amp
id|ehci-&gt;regs-&gt;status
)paren
suffix:semicolon
id|ehci-&gt;reclaim_ready
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* stop async processing after it&squot;s idled a bit */
r_if
c_cond
(paren
id|test_bit
(paren
id|TIMER_ASYNC_OFF
comma
op_amp
id|ehci-&gt;actions
)paren
)paren
id|start_unlink_async
(paren
id|ehci
comma
id|ehci-&gt;async
)paren
suffix:semicolon
multiline_comment|/* ehci could run by timer, without IRQs ... */
id|ehci_work
(paren
id|ehci
comma
l_int|NULL
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
macro_line|#ifdef&t;CONFIG_PCI
multiline_comment|/* EHCI 0.96 (and later) section 5.1 says how to kick BIOS/SMM/...&n; * off the controller (maybe it can boot from highspeed USB disks).&n; */
DECL|function|bios_handoff
r_static
r_int
id|bios_handoff
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_int
id|where
comma
id|u32
id|cap
)paren
(brace
r_if
c_cond
(paren
id|cap
op_amp
(paren
l_int|1
op_lshift
l_int|16
)paren
)paren
(brace
r_int
id|msec
op_assign
l_int|5000
suffix:semicolon
r_struct
id|pci_dev
op_star
id|pdev
op_assign
id|to_pci_dev
c_func
(paren
id|ehci-&gt;hcd.self.controller
)paren
suffix:semicolon
multiline_comment|/* request handoff to OS */
id|cap
op_or_assign
l_int|1
op_lshift
l_int|24
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|pdev
comma
id|where
comma
id|cap
)paren
suffix:semicolon
multiline_comment|/* and wait a while for it to happen */
r_do
(brace
id|msleep
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|msec
op_sub_assign
l_int|10
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|pdev
comma
id|where
comma
op_amp
id|cap
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|cap
op_amp
(paren
l_int|1
op_lshift
l_int|16
)paren
)paren
op_logical_and
id|msec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cap
op_amp
(paren
l_int|1
op_lshift
l_int|16
)paren
)paren
(brace
id|ehci_err
(paren
id|ehci
comma
l_string|&quot;BIOS handoff failed (%d, %04x)&bslash;n&quot;
comma
id|where
comma
id|cap
)paren
suffix:semicolon
singleline_comment|// some BIOS versions seem buggy...
singleline_comment|// return 1;
id|ehci_warn
(paren
id|ehci
comma
l_string|&quot;continuing after BIOS bug...&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ehci_dbg
(paren
id|ehci
comma
l_string|&quot;BIOS handoff succeeded&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_static
r_int
DECL|function|ehci_reboot
id|ehci_reboot
(paren
r_struct
id|notifier_block
op_star
id|self
comma
r_int
r_int
id|code
comma
r_void
op_star
id|null
)paren
(brace
r_struct
id|ehci_hcd
op_star
id|ehci
suffix:semicolon
id|ehci
op_assign
id|container_of
(paren
id|self
comma
r_struct
id|ehci_hcd
comma
id|reboot_notifier
)paren
suffix:semicolon
multiline_comment|/* make BIOS/etc use companion controller during reboot */
id|writel
(paren
l_int|0
comma
op_amp
id|ehci-&gt;regs-&gt;configured_flag
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* called by khubd or root hub init threads */
DECL|function|ehci_hc_reset
r_static
r_int
id|ehci_hc_reset
(paren
r_struct
id|usb_hcd
op_star
id|hcd
)paren
(brace
r_struct
id|ehci_hcd
op_star
id|ehci
op_assign
id|hcd_to_ehci
(paren
id|hcd
)paren
suffix:semicolon
id|u32
id|temp
suffix:semicolon
r_int
id|count
op_assign
l_int|256
op_div
l_int|4
suffix:semicolon
id|spin_lock_init
(paren
op_amp
id|ehci-&gt;lock
)paren
suffix:semicolon
id|ehci-&gt;caps
op_assign
id|hcd-&gt;regs
suffix:semicolon
id|ehci-&gt;regs
op_assign
id|hcd-&gt;regs
op_plus
id|HC_LENGTH
(paren
id|readl
(paren
op_amp
id|ehci-&gt;caps-&gt;hc_capbase
)paren
)paren
suffix:semicolon
id|dbg_hcs_params
(paren
id|ehci
comma
l_string|&quot;reset&quot;
)paren
suffix:semicolon
id|dbg_hcc_params
(paren
id|ehci
comma
l_string|&quot;reset&quot;
)paren
suffix:semicolon
macro_line|#ifdef&t;CONFIG_PCI
multiline_comment|/* EHCI 0.96 and later may have &quot;extended capabilities&quot; */
r_if
c_cond
(paren
id|hcd-&gt;self.controller-&gt;bus
op_eq
op_amp
id|pci_bus_type
)paren
(brace
r_struct
id|pci_dev
op_star
id|pdev
op_assign
id|to_pci_dev
c_func
(paren
id|ehci-&gt;hcd.self.controller
)paren
suffix:semicolon
multiline_comment|/* AMD8111 EHCI doesn&squot;t work, according to AMD errata */
r_if
c_cond
(paren
(paren
id|pdev-&gt;vendor
op_eq
id|PCI_VENDOR_ID_AMD
)paren
op_logical_and
(paren
id|pdev-&gt;device
op_eq
l_int|0x7463
)paren
)paren
(brace
id|ehci_info
(paren
id|ehci
comma
l_string|&quot;ignoring AMD8111 (errata)&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|temp
op_assign
id|HCC_EXT_CAPS
(paren
id|readl
(paren
op_amp
id|ehci-&gt;caps-&gt;hcc_params
)paren
)paren
suffix:semicolon
)brace
r_else
id|temp
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|temp
op_logical_and
id|count
op_decrement
)paren
(brace
id|u32
id|cap
suffix:semicolon
id|pci_read_config_dword
(paren
id|to_pci_dev
c_func
(paren
id|ehci-&gt;hcd.self.controller
)paren
comma
id|temp
comma
op_amp
id|cap
)paren
suffix:semicolon
id|ehci_dbg
(paren
id|ehci
comma
l_string|&quot;capability %04x at %02x&bslash;n&quot;
comma
id|cap
comma
id|temp
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cap
op_amp
l_int|0xff
)paren
(brace
r_case
l_int|1
suffix:colon
multiline_comment|/* BIOS/SMM/... handoff */
r_if
c_cond
(paren
id|bios_handoff
(paren
id|ehci
comma
id|temp
comma
id|cap
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
multiline_comment|/* illegal reserved capability */
id|ehci_warn
(paren
id|ehci
comma
l_string|&quot;illegal capability!&bslash;n&quot;
)paren
suffix:semicolon
id|cap
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_default
suffix:colon
multiline_comment|/* unknown */
r_break
suffix:semicolon
)brace
id|temp
op_assign
(paren
id|cap
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
(brace
id|ehci_err
(paren
id|ehci
comma
l_string|&quot;bogus capabilities ... PCI problems!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* cache this readonly data; minimize PCI reads */
id|ehci-&gt;hcs_params
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;caps-&gt;hcs_params
)paren
suffix:semicolon
multiline_comment|/* at least the Genesys GL880S needs fixup here */
id|temp
op_assign
id|HCS_N_CC
c_func
(paren
id|ehci-&gt;hcs_params
)paren
op_star
id|HCS_N_PCC
c_func
(paren
id|ehci-&gt;hcs_params
)paren
suffix:semicolon
id|temp
op_and_assign
l_int|0x0f
suffix:semicolon
r_if
c_cond
(paren
id|temp
op_logical_and
id|HCS_N_PORTS
c_func
(paren
id|ehci-&gt;hcs_params
)paren
OG
id|temp
)paren
(brace
id|temp
op_or_assign
(paren
id|ehci-&gt;hcs_params
op_amp
op_complement
l_int|0xf
)paren
suffix:semicolon
id|ehci-&gt;hcs_params
op_assign
id|temp
suffix:semicolon
)brace
multiline_comment|/* force HC to halt state */
r_return
id|ehci_halt
(paren
id|ehci
)paren
suffix:semicolon
)brace
DECL|function|ehci_start
r_static
r_int
id|ehci_start
(paren
r_struct
id|usb_hcd
op_star
id|hcd
)paren
(brace
r_struct
id|ehci_hcd
op_star
id|ehci
op_assign
id|hcd_to_ehci
(paren
id|hcd
)paren
suffix:semicolon
id|u32
id|temp
suffix:semicolon
r_struct
id|usb_device
op_star
id|udev
suffix:semicolon
r_struct
id|usb_bus
op_star
id|bus
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|u32
id|hcc_params
suffix:semicolon
id|u8
id|sbrn
op_assign
l_int|0
suffix:semicolon
r_int
id|first
suffix:semicolon
multiline_comment|/* skip some things on restart paths */
id|first
op_assign
(paren
id|ehci-&gt;watchdog.data
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|first
)paren
(brace
id|init_timer
(paren
op_amp
id|ehci-&gt;watchdog
)paren
suffix:semicolon
id|ehci-&gt;watchdog.function
op_assign
id|ehci_watchdog
suffix:semicolon
id|ehci-&gt;watchdog.data
op_assign
(paren
r_int
r_int
)paren
id|ehci
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * hw default: 1K periodic list heads, one per frame.&n;&t; * periodic_size can shrink by USBCMD update if hcc_params allows.&n;&t; */
id|ehci-&gt;periodic_size
op_assign
id|DEFAULT_I_TDPS
suffix:semicolon
r_if
c_cond
(paren
id|first
op_logical_and
(paren
id|retval
op_assign
id|ehci_mem_init
(paren
id|ehci
comma
id|GFP_KERNEL
)paren
)paren
OL
l_int|0
)paren
r_return
id|retval
suffix:semicolon
multiline_comment|/* controllers may cache some of the periodic schedule ... */
id|hcc_params
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;caps-&gt;hcc_params
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HCC_ISOC_CACHE
(paren
id|hcc_params
)paren
)paren
singleline_comment|// full frame cache
id|ehci-&gt;i_thresh
op_assign
l_int|8
suffix:semicolon
r_else
singleline_comment|// N microframes cached
id|ehci-&gt;i_thresh
op_assign
l_int|2
op_plus
id|HCC_ISOC_THRES
(paren
id|hcc_params
)paren
suffix:semicolon
id|ehci-&gt;reclaim
op_assign
l_int|NULL
suffix:semicolon
id|ehci-&gt;reclaim_ready
op_assign
l_int|0
suffix:semicolon
id|ehci-&gt;next_uframe
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* controller state:  unknown --&gt; reset */
multiline_comment|/* EHCI spec section 4.1 */
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|ehci_reset
(paren
id|ehci
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|ehci_mem_cleanup
(paren
id|ehci
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|writel
(paren
id|ehci-&gt;periodic_dma
comma
op_amp
id|ehci-&gt;regs-&gt;frame_list
)paren
suffix:semicolon
macro_line|#ifdef&t;CONFIG_PCI
r_if
c_cond
(paren
id|hcd-&gt;self.controller-&gt;bus
op_eq
op_amp
id|pci_bus_type
)paren
(brace
r_struct
id|pci_dev
op_star
id|pdev
suffix:semicolon
id|u16
id|port_wake
suffix:semicolon
id|pdev
op_assign
id|to_pci_dev
c_func
(paren
id|hcd-&gt;self.controller
)paren
suffix:semicolon
multiline_comment|/* Serial Bus Release Number is at PCI 0x60 offset */
id|pci_read_config_byte
c_func
(paren
id|pdev
comma
l_int|0x60
comma
op_amp
id|sbrn
)paren
suffix:semicolon
multiline_comment|/* port wake capability, reported by boot firmware */
id|pci_read_config_word
c_func
(paren
id|pdev
comma
l_int|0x62
comma
op_amp
id|port_wake
)paren
suffix:semicolon
id|hcd-&gt;can_wakeup
op_assign
(paren
id|port_wake
op_amp
l_int|1
)paren
op_ne
l_int|0
suffix:semicolon
multiline_comment|/* help hc dma work well with cachelines */
id|pci_set_mwi
(paren
id|pdev
)paren
suffix:semicolon
multiline_comment|/* chip-specific init */
r_switch
c_cond
(paren
id|pdev-&gt;vendor
)paren
(brace
r_case
id|PCI_VENDOR_ID_ARC
suffix:colon
r_if
c_cond
(paren
id|pdev-&gt;device
op_eq
id|PCI_DEVICE_ID_ARC_EHCI
)paren
id|ehci-&gt;is_arc_rh_tt
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * dedicate a qh for the async ring head, since we couldn&squot;t unlink&n;&t; * a &squot;real&squot; qh without stopping the async schedule [4.8].  use it&n;&t; * as the &squot;reclamation list head&squot; too.&n;&t; * its dummy is used in hw_alt_next of many tds, to prevent the qh&n;&t; * from automatically advancing to the next td after short reads.&n;&t; */
r_if
c_cond
(paren
id|first
)paren
(brace
id|ehci-&gt;async-&gt;qh_next.qh
op_assign
l_int|NULL
suffix:semicolon
id|ehci-&gt;async-&gt;hw_next
op_assign
id|QH_NEXT
(paren
id|ehci-&gt;async-&gt;qh_dma
)paren
suffix:semicolon
id|ehci-&gt;async-&gt;hw_info1
op_assign
id|cpu_to_le32
(paren
id|QH_HEAD
)paren
suffix:semicolon
id|ehci-&gt;async-&gt;hw_token
op_assign
id|cpu_to_le32
(paren
id|QTD_STS_HALT
)paren
suffix:semicolon
id|ehci-&gt;async-&gt;hw_qtd_next
op_assign
id|EHCI_LIST_END
suffix:semicolon
id|ehci-&gt;async-&gt;qh_state
op_assign
id|QH_STATE_LINKED
suffix:semicolon
id|ehci-&gt;async-&gt;hw_alt_next
op_assign
id|QTD_NEXT
(paren
id|ehci-&gt;async-&gt;dummy-&gt;qtd_dma
)paren
suffix:semicolon
)brace
id|writel
(paren
(paren
id|u32
)paren
id|ehci-&gt;async-&gt;qh_dma
comma
op_amp
id|ehci-&gt;regs-&gt;async_next
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * hcc_params controls whether ehci-&gt;regs-&gt;segment must (!!!)&n;&t; * be used; it constrains QH/ITD/SITD and QTD locations.&n;&t; * pci_pool consistent memory always uses segment zero.&n;&t; * streaming mappings for I/O buffers, like pci_map_single(),&n;&t; * can return segments above 4GB, if the device allows.&n;&t; *&n;&t; * NOTE:  the dma mask is visible through dma_supported(), so&n;&t; * drivers can pass this info along ... like NETIF_F_HIGHDMA,&n;&t; * Scsi_Host.highmem_io, and so forth.  It&squot;s readonly to all&n;&t; * host side drivers though.&n;&t; */
r_if
c_cond
(paren
id|HCC_64BIT_ADDR
(paren
id|hcc_params
)paren
)paren
(brace
id|writel
(paren
l_int|0
comma
op_amp
id|ehci-&gt;regs-&gt;segment
)paren
suffix:semicolon
macro_line|#if 0
singleline_comment|// this is deeply broken on almost all architectures
r_if
c_cond
(paren
op_logical_neg
id|pci_set_dma_mask
(paren
id|to_pci_dev
c_func
(paren
id|ehci-&gt;hcd.self.controller
)paren
comma
l_int|0xffffffffffffffffULL
)paren
)paren
id|ehci_info
(paren
id|ehci
comma
l_string|&quot;enabled 64bit PCI DMA&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* clear interrupt enables, set irq latency */
id|temp
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
op_amp
l_int|0x0fff
suffix:semicolon
r_if
c_cond
(paren
id|log2_irq_thresh
template_param
l_int|6
)paren
id|log2_irq_thresh
op_assign
l_int|0
suffix:semicolon
id|temp
op_or_assign
l_int|1
op_lshift
(paren
l_int|16
op_plus
id|log2_irq_thresh
)paren
suffix:semicolon
singleline_comment|// if hc can park (ehci &gt;= 0.96), default is 3 packets per async QH 
r_if
c_cond
(paren
id|HCC_PGM_FRAMELISTLEN
(paren
id|hcc_params
)paren
)paren
(brace
multiline_comment|/* periodic schedule size can be smaller than default */
id|temp
op_and_assign
op_complement
(paren
l_int|3
op_lshift
l_int|2
)paren
suffix:semicolon
id|temp
op_or_assign
(paren
id|EHCI_TUNE_FLS
op_lshift
l_int|2
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|EHCI_TUNE_FLS
)paren
(brace
r_case
l_int|0
suffix:colon
id|ehci-&gt;periodic_size
op_assign
l_int|1024
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|ehci-&gt;periodic_size
op_assign
l_int|512
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|ehci-&gt;periodic_size
op_assign
l_int|256
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
(paren
)paren
suffix:semicolon
)brace
)brace
id|temp
op_and_assign
op_complement
(paren
id|CMD_IAAD
op_or
id|CMD_ASE
op_or
id|CMD_PSE
)paren
comma
singleline_comment|// Philips, Intel, and maybe others need CMD_RUN before the
singleline_comment|// root hub will detect new devices (why?); NEC doesn&squot;t
id|temp
op_or_assign
id|CMD_RUN
suffix:semicolon
id|writel
(paren
id|temp
comma
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
id|dbg_cmd
(paren
id|ehci
comma
l_string|&quot;init&quot;
comma
id|temp
)paren
suffix:semicolon
multiline_comment|/* set async sleep time = 10 us ... ? */
multiline_comment|/* wire up the root hub */
id|bus
op_assign
id|hcd_to_bus
(paren
id|hcd
)paren
suffix:semicolon
id|udev
op_assign
id|first
ques
c_cond
id|usb_alloc_dev
(paren
l_int|NULL
comma
id|bus
comma
l_int|0
)paren
suffix:colon
id|bus-&gt;root_hub
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|udev
)paren
(brace
id|done2
suffix:colon
id|ehci_mem_cleanup
(paren
id|ehci
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|udev-&gt;speed
op_assign
id|USB_SPEED_HIGH
suffix:semicolon
id|udev-&gt;state
op_assign
id|first
ques
c_cond
id|USB_STATE_ATTACHED
suffix:colon
id|USB_STATE_CONFIGURED
suffix:semicolon
multiline_comment|/*&n;&t; * Start, enabling full USB 2.0 functionality ... usb 1.1 devices&n;&t; * are explicitly handed to companion controller(s), so no TT is&n;&t; * involved with the root hub.  (Except where one is integrated,&n;&t; * and there&squot;s no companion controller unless maybe for USB OTG.)&n;&t; */
r_if
c_cond
(paren
id|first
)paren
(brace
id|ehci-&gt;reboot_notifier.notifier_call
op_assign
id|ehci_reboot
suffix:semicolon
id|register_reboot_notifier
(paren
op_amp
id|ehci-&gt;reboot_notifier
)paren
suffix:semicolon
)brace
id|ehci-&gt;hcd.state
op_assign
id|USB_STATE_RUNNING
suffix:semicolon
id|writel
(paren
id|FLAG_CF
comma
op_amp
id|ehci-&gt;regs-&gt;configured_flag
)paren
suffix:semicolon
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
multiline_comment|/* unblock posted write */
id|temp
op_assign
id|HC_VERSION
c_func
(paren
id|readl
(paren
op_amp
id|ehci-&gt;caps-&gt;hc_capbase
)paren
)paren
suffix:semicolon
id|ehci_info
(paren
id|ehci
comma
l_string|&quot;USB %x.%x %s, EHCI %x.%02x, driver %s&bslash;n&quot;
comma
(paren
(paren
id|sbrn
op_amp
l_int|0xf0
)paren
op_rshift
l_int|4
)paren
comma
(paren
id|sbrn
op_amp
l_int|0x0f
)paren
comma
id|first
ques
c_cond
l_string|&quot;initialized&quot;
suffix:colon
l_string|&quot;restarted&quot;
comma
id|temp
op_rshift
l_int|8
comma
id|temp
op_amp
l_int|0xff
comma
id|DRIVER_VERSION
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * From here on, khubd concurrently accesses the root&n;&t; * hub; drivers will be talking to enumerated devices.&n;&t; * (On restart paths, khubd already knows about the root&n;&t; * hub and could find work as soon as we wrote FLAG_CF.)&n;&t; *&n;&t; * Before this point the HC was idle/ready.  After, khubd&n;&t; * and device drivers may start it running.&n;&t; */
r_if
c_cond
(paren
id|first
op_logical_and
id|hcd_register_root
(paren
id|udev
comma
id|hcd
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|hcd-&gt;state
op_eq
id|USB_STATE_RUNNING
)paren
id|ehci_quiesce
(paren
id|ehci
)paren
suffix:semicolon
id|ehci_reset
(paren
id|ehci
)paren
suffix:semicolon
id|usb_put_dev
(paren
id|udev
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|done2
suffix:semicolon
)brace
id|writel
(paren
id|INTR_MASK
comma
op_amp
id|ehci-&gt;regs-&gt;intr_enable
)paren
suffix:semicolon
multiline_comment|/* Turn On Interrupts */
r_if
c_cond
(paren
id|first
)paren
id|create_debug_files
(paren
id|ehci
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* always called by thread; normally rmmod */
DECL|function|ehci_stop
r_static
r_void
id|ehci_stop
(paren
r_struct
id|usb_hcd
op_star
id|hcd
)paren
(brace
r_struct
id|ehci_hcd
op_star
id|ehci
op_assign
id|hcd_to_ehci
(paren
id|hcd
)paren
suffix:semicolon
id|u8
id|rh_ports
comma
id|port
suffix:semicolon
id|ehci_dbg
(paren
id|ehci
comma
l_string|&quot;stop&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Turn off port power on all root hub ports. */
id|rh_ports
op_assign
id|HCS_N_PORTS
(paren
id|ehci-&gt;hcs_params
)paren
suffix:semicolon
r_for
c_loop
(paren
id|port
op_assign
l_int|1
suffix:semicolon
id|port
op_le
id|rh_ports
suffix:semicolon
id|port
op_increment
)paren
(paren
r_void
)paren
id|ehci_hub_control
c_func
(paren
id|hcd
comma
id|ClearPortFeature
comma
id|USB_PORT_FEAT_POWER
comma
id|port
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* no more interrupts ... */
id|del_timer_sync
(paren
op_amp
id|ehci-&gt;watchdog
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|ehci-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HCD_IS_RUNNING
(paren
id|ehci-&gt;hcd.state
)paren
)paren
id|ehci_quiesce
(paren
id|ehci
)paren
suffix:semicolon
id|ehci_reset
(paren
id|ehci
)paren
suffix:semicolon
id|writel
(paren
l_int|0
comma
op_amp
id|ehci-&gt;regs-&gt;intr_enable
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|ehci-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* let companion controllers work when we aren&squot;t */
id|writel
(paren
l_int|0
comma
op_amp
id|ehci-&gt;regs-&gt;configured_flag
)paren
suffix:semicolon
id|unregister_reboot_notifier
(paren
op_amp
id|ehci-&gt;reboot_notifier
)paren
suffix:semicolon
id|remove_debug_files
(paren
id|ehci
)paren
suffix:semicolon
multiline_comment|/* root hub is shut down separately (first, when possible) */
id|spin_lock_irq
(paren
op_amp
id|ehci-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ehci-&gt;async
)paren
id|ehci_work
(paren
id|ehci
comma
l_int|NULL
)paren
suffix:semicolon
id|spin_unlock_irq
(paren
op_amp
id|ehci-&gt;lock
)paren
suffix:semicolon
id|ehci_mem_cleanup
(paren
id|ehci
)paren
suffix:semicolon
macro_line|#ifdef&t;EHCI_STATS
id|ehci_dbg
(paren
id|ehci
comma
l_string|&quot;irq normal %ld err %ld reclaim %ld (lost %ld)&bslash;n&quot;
comma
id|ehci-&gt;stats.normal
comma
id|ehci-&gt;stats.error
comma
id|ehci-&gt;stats.reclaim
comma
id|ehci-&gt;stats.lost_iaa
)paren
suffix:semicolon
id|ehci_dbg
(paren
id|ehci
comma
l_string|&quot;complete %ld unlink %ld&bslash;n&quot;
comma
id|ehci-&gt;stats.complete
comma
id|ehci-&gt;stats.unlink
)paren
suffix:semicolon
macro_line|#endif
id|dbg_status
(paren
id|ehci
comma
l_string|&quot;ehci_stop completed&quot;
comma
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;status
)paren
)paren
suffix:semicolon
)brace
DECL|function|ehci_get_frame
r_static
r_int
id|ehci_get_frame
(paren
r_struct
id|usb_hcd
op_star
id|hcd
)paren
(brace
r_struct
id|ehci_hcd
op_star
id|ehci
op_assign
id|hcd_to_ehci
(paren
id|hcd
)paren
suffix:semicolon
r_return
(paren
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;frame_index
)paren
op_rshift
l_int|3
)paren
op_mod
id|ehci-&gt;periodic_size
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
macro_line|#ifdef&t;CONFIG_PM
multiline_comment|/* suspend/resume, section 4.3 */
multiline_comment|/* These routines rely on the bus (pci, platform, etc)&n; * to handle powerdown and wakeup, and currently also on&n; * transceivers that don&squot;t need any software attention to set up&n; * the right sort of wakeup.  &n; */
DECL|function|ehci_suspend
r_static
r_int
id|ehci_suspend
(paren
r_struct
id|usb_hcd
op_star
id|hcd
comma
id|u32
id|state
)paren
(brace
r_struct
id|ehci_hcd
op_star
id|ehci
op_assign
id|hcd_to_ehci
(paren
id|hcd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|time_before
(paren
id|jiffies
comma
id|ehci-&gt;next_statechange
)paren
)paren
id|msleep
(paren
l_int|100
)paren
suffix:semicolon
macro_line|#ifdef&t;CONFIG_USB_SUSPEND
(paren
r_void
)paren
id|usb_suspend_device
(paren
id|hcd-&gt;self.root_hub
comma
id|state
)paren
suffix:semicolon
macro_line|#else
id|usb_lock_device
(paren
id|hcd-&gt;self.root_hub
)paren
suffix:semicolon
(paren
r_void
)paren
id|ehci_hub_suspend
(paren
id|hcd
)paren
suffix:semicolon
id|usb_unlock_device
(paren
id|hcd-&gt;self.root_hub
)paren
suffix:semicolon
macro_line|#endif
singleline_comment|// save (PCI) FLADJ in case of Vaux power loss
singleline_comment|// ... we&squot;d only use it to handle clock skew
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ehci_resume
r_static
r_int
id|ehci_resume
(paren
r_struct
id|usb_hcd
op_star
id|hcd
)paren
(brace
r_struct
id|ehci_hcd
op_star
id|ehci
op_assign
id|hcd_to_ehci
(paren
id|hcd
)paren
suffix:semicolon
r_int
id|port
suffix:semicolon
r_struct
id|usb_device
op_star
id|root
op_assign
id|hcd-&gt;self.root_hub
suffix:semicolon
r_int
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_int
id|powerup
op_assign
l_int|0
suffix:semicolon
singleline_comment|// maybe restore (PCI) FLADJ
r_if
c_cond
(paren
id|time_before
(paren
id|jiffies
comma
id|ehci-&gt;next_statechange
)paren
)paren
id|msleep
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* If any port is suspended, we know we can/must resume the HC. */
r_for
c_loop
(paren
id|port
op_assign
id|HCS_N_PORTS
(paren
id|ehci-&gt;hcs_params
)paren
suffix:semicolon
id|port
OG
l_int|0
suffix:semicolon
)paren
(brace
id|u32
id|status
suffix:semicolon
id|port
op_decrement
suffix:semicolon
id|status
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;port_status
(braket
id|port
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|PORT_SUSPEND
)paren
(brace
id|down
(paren
op_amp
id|hcd-&gt;self.root_hub-&gt;serialize
)paren
suffix:semicolon
id|retval
op_assign
id|ehci_hub_resume
(paren
id|hcd
)paren
suffix:semicolon
id|up
(paren
op_amp
id|hcd-&gt;self.root_hub-&gt;serialize
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|status
op_amp
id|PORT_POWER
)paren
op_eq
l_int|0
)paren
id|powerup
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|root-&gt;children
(braket
id|port
)braket
)paren
r_continue
suffix:semicolon
id|dbg_port
(paren
id|ehci
comma
id|__FUNCTION__
comma
id|port
op_plus
l_int|1
comma
id|status
)paren
suffix:semicolon
id|usb_set_device_state
(paren
id|root-&gt;children
(braket
id|port
)braket
comma
id|USB_STATE_NOTATTACHED
)paren
suffix:semicolon
)brace
multiline_comment|/* Else reset, to cope with power loss or flush-to-storage&n;&t; * style &quot;resume&quot; having activated BIOS during reboot.&n;&t; */
r_if
c_cond
(paren
id|port
op_eq
l_int|0
)paren
(brace
(paren
r_void
)paren
id|ehci_halt
(paren
id|ehci
)paren
suffix:semicolon
(paren
r_void
)paren
id|ehci_reset
(paren
id|ehci
)paren
suffix:semicolon
(paren
r_void
)paren
id|ehci_hc_reset
(paren
id|hcd
)paren
suffix:semicolon
multiline_comment|/* emptying the schedule aborts any urbs */
id|spin_lock_irq
(paren
op_amp
id|ehci-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ehci-&gt;reclaim
)paren
id|ehci-&gt;reclaim_ready
op_assign
l_int|1
suffix:semicolon
id|ehci_work
(paren
id|ehci
comma
l_int|NULL
)paren
suffix:semicolon
id|spin_unlock_irq
(paren
op_amp
id|ehci-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* restart; khubd will disconnect devices */
id|retval
op_assign
id|ehci_start
(paren
id|hcd
)paren
suffix:semicolon
multiline_comment|/* here we &quot;know&quot; root ports should always stay powered;&n;&t;&t; * but some controllers may lost all power.&n;&t;&t; */
r_if
c_cond
(paren
id|powerup
)paren
(brace
id|ehci_dbg
(paren
id|ehci
comma
l_string|&quot;...powerup ports...&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|port
op_assign
id|HCS_N_PORTS
(paren
id|ehci-&gt;hcs_params
)paren
suffix:semicolon
id|port
OG
l_int|0
suffix:semicolon
)paren
(paren
r_void
)paren
id|ehci_hub_control
c_func
(paren
id|hcd
comma
id|SetPortFeature
comma
id|USB_PORT_FEAT_POWER
comma
id|port
op_decrement
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|msleep
c_func
(paren
l_int|20
)paren
suffix:semicolon
)brace
)brace
r_return
id|retval
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * ehci_work is called from some interrupts, timers, and so on.&n; * it calls driver completion functions, after dropping ehci-&gt;lock.&n; */
DECL|function|ehci_work
r_static
r_void
id|ehci_work
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|timer_action_done
(paren
id|ehci
comma
id|TIMER_IO_WATCHDOG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ehci-&gt;reclaim_ready
)paren
id|end_unlink_async
(paren
id|ehci
comma
id|regs
)paren
suffix:semicolon
multiline_comment|/* another CPU may drop ehci-&gt;lock during a schedule scan while&n;&t; * it reports urb completions.  this flag guards against bogus&n;&t; * attempts at re-entrant schedule scanning.&n;&t; */
r_if
c_cond
(paren
id|ehci-&gt;scanning
)paren
r_return
suffix:semicolon
id|ehci-&gt;scanning
op_assign
l_int|1
suffix:semicolon
id|scan_async
(paren
id|ehci
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ehci-&gt;next_uframe
op_ne
op_minus
l_int|1
)paren
id|scan_periodic
(paren
id|ehci
comma
id|regs
)paren
suffix:semicolon
id|ehci-&gt;scanning
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* the IO watchdog guards against hardware or driver bugs that&n;&t; * misplace IRQs, and should let us run completely without IRQs.&n;&t; * such lossage has been observed on both VT6202 and VT8235. &n;&t; */
r_if
c_cond
(paren
id|HCD_IS_RUNNING
(paren
id|ehci-&gt;hcd.state
)paren
op_logical_and
(paren
id|ehci-&gt;async-&gt;qh_next.ptr
op_ne
l_int|0
op_logical_or
id|ehci-&gt;periodic_sched
op_ne
l_int|0
)paren
)paren
id|timer_action
(paren
id|ehci
comma
id|TIMER_IO_WATCHDOG
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|ehci_irq
r_static
id|irqreturn_t
id|ehci_irq
(paren
r_struct
id|usb_hcd
op_star
id|hcd
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|ehci_hcd
op_star
id|ehci
op_assign
id|hcd_to_ehci
(paren
id|hcd
)paren
suffix:semicolon
id|u32
id|status
suffix:semicolon
r_int
id|bh
suffix:semicolon
id|spin_lock
(paren
op_amp
id|ehci-&gt;lock
)paren
suffix:semicolon
id|status
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;status
)paren
suffix:semicolon
multiline_comment|/* e.g. cardbus physical eject */
r_if
c_cond
(paren
id|status
op_eq
op_complement
(paren
id|u32
)paren
l_int|0
)paren
(brace
id|ehci_dbg
(paren
id|ehci
comma
l_string|&quot;device removed&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|dead
suffix:semicolon
)brace
id|status
op_and_assign
id|INTR_MASK
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
multiline_comment|/* irq sharing? */
id|spin_unlock
c_func
(paren
op_amp
id|ehci-&gt;lock
)paren
suffix:semicolon
r_return
id|IRQ_NONE
suffix:semicolon
)brace
multiline_comment|/* clear (just) interrupts */
id|writel
(paren
id|status
comma
op_amp
id|ehci-&gt;regs-&gt;status
)paren
suffix:semicolon
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
multiline_comment|/* unblock posted write */
id|bh
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef&t;EHCI_VERBOSE_DEBUG
multiline_comment|/* unrequested/ignored: Frame List Rollover */
id|dbg_status
(paren
id|ehci
comma
l_string|&quot;irq&quot;
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* INT, ERR, and IAA interrupt rates can be throttled */
multiline_comment|/* normal [4.15.1.2] or error [4.15.1.1] completion */
r_if
c_cond
(paren
id|likely
(paren
(paren
id|status
op_amp
(paren
id|STS_INT
op_or
id|STS_ERR
)paren
)paren
op_ne
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|likely
(paren
(paren
id|status
op_amp
id|STS_ERR
)paren
op_eq
l_int|0
)paren
)paren
id|COUNT
(paren
id|ehci-&gt;stats.normal
)paren
suffix:semicolon
r_else
id|COUNT
(paren
id|ehci-&gt;stats.error
)paren
suffix:semicolon
id|bh
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* complete the unlinking of some qh [4.15.2.3] */
r_if
c_cond
(paren
id|status
op_amp
id|STS_IAA
)paren
(brace
id|COUNT
(paren
id|ehci-&gt;stats.reclaim
)paren
suffix:semicolon
id|ehci-&gt;reclaim_ready
op_assign
l_int|1
suffix:semicolon
id|bh
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* remote wakeup [4.3.1] */
r_if
c_cond
(paren
(paren
id|status
op_amp
id|STS_PCD
)paren
op_logical_and
id|ehci-&gt;hcd.remote_wakeup
)paren
(brace
r_int
id|i
op_assign
id|HCS_N_PORTS
(paren
id|ehci-&gt;hcs_params
)paren
suffix:semicolon
multiline_comment|/* resume root hub? */
id|status
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|CMD_RUN
)paren
)paren
id|writel
(paren
id|status
op_or
id|CMD_RUN
comma
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
r_while
c_loop
(paren
id|i
op_decrement
)paren
(brace
id|status
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;port_status
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|PORT_OWNER
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|PORT_RESUME
)paren
op_logical_or
id|ehci-&gt;reset_done
(braket
id|i
)braket
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/* start 20 msec resume signaling from this port,&n;&t;&t;&t; * and make khubd collect PORT_STAT_C_SUSPEND to&n;&t;&t;&t; * stop that signaling.&n;&t;&t;&t; */
id|ehci-&gt;reset_done
(braket
id|i
)braket
op_assign
id|jiffies
op_plus
id|msecs_to_jiffies
(paren
l_int|20
)paren
suffix:semicolon
id|mod_timer
(paren
op_amp
id|ehci-&gt;hcd.rh_timer
comma
id|ehci-&gt;reset_done
(braket
id|i
)braket
op_plus
l_int|1
)paren
suffix:semicolon
id|ehci_dbg
(paren
id|ehci
comma
l_string|&quot;port %d remote wakeup&bslash;n&quot;
comma
id|i
op_plus
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* PCI errors [4.15.2.4] */
r_if
c_cond
(paren
id|unlikely
(paren
(paren
id|status
op_amp
id|STS_FATAL
)paren
op_ne
l_int|0
)paren
)paren
(brace
id|ehci_err
(paren
id|ehci
comma
l_string|&quot;fatal error&bslash;n&quot;
)paren
suffix:semicolon
id|dead
suffix:colon
id|ehci_reset
(paren
id|ehci
)paren
suffix:semicolon
multiline_comment|/* generic layer kills/unlinks all urbs, then&n;&t;&t; * uses ehci_stop to clean up the rest&n;&t;&t; */
id|bh
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bh
)paren
id|ehci_work
(paren
id|ehci
comma
id|regs
)paren
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|ehci-&gt;lock
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * non-error returns are a promise to giveback() the urb later&n; * we drop ownership so next owner (or urb unlink) can get it&n; *&n; * urb + dev is in hcd.self.controller.urb_list&n; * we&squot;re queueing TDs onto software and hardware lists&n; *&n; * hcd-specific init for hcpriv hasn&squot;t been done yet&n; *&n; * NOTE:  control, bulk, and interrupt share the same code to append TDs&n; * to a (possibly active) QH, and the same QH scanning code.&n; */
DECL|function|ehci_urb_enqueue
r_static
r_int
id|ehci_urb_enqueue
(paren
r_struct
id|usb_hcd
op_star
id|hcd
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|mem_flags
)paren
(brace
r_struct
id|ehci_hcd
op_star
id|ehci
op_assign
id|hcd_to_ehci
(paren
id|hcd
)paren
suffix:semicolon
r_struct
id|list_head
id|qtd_list
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|qtd_list
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|usb_pipetype
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
singleline_comment|// case PIPE_CONTROL:
singleline_comment|// case PIPE_BULK:
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|qh_urb_transaction
(paren
id|ehci
comma
id|urb
comma
op_amp
id|qtd_list
comma
id|mem_flags
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_return
id|submit_async
(paren
id|ehci
comma
id|urb
comma
op_amp
id|qtd_list
comma
id|mem_flags
)paren
suffix:semicolon
r_case
id|PIPE_INTERRUPT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|qh_urb_transaction
(paren
id|ehci
comma
id|urb
comma
op_amp
id|qtd_list
comma
id|mem_flags
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_return
id|intr_submit
(paren
id|ehci
comma
id|urb
comma
op_amp
id|qtd_list
comma
id|mem_flags
)paren
suffix:semicolon
r_case
id|PIPE_ISOCHRONOUS
suffix:colon
r_if
c_cond
(paren
id|urb-&gt;dev-&gt;speed
op_eq
id|USB_SPEED_HIGH
)paren
r_return
id|itd_submit
(paren
id|ehci
comma
id|urb
comma
id|mem_flags
)paren
suffix:semicolon
r_else
r_return
id|sitd_submit
(paren
id|ehci
comma
id|urb
comma
id|mem_flags
)paren
suffix:semicolon
)brace
)brace
DECL|function|unlink_async
r_static
r_void
id|unlink_async
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|ehci_qh
op_star
id|qh
)paren
(brace
multiline_comment|/* if we need to use IAA and it&squot;s busy, defer */
r_if
c_cond
(paren
id|qh-&gt;qh_state
op_eq
id|QH_STATE_LINKED
op_logical_and
id|ehci-&gt;reclaim
op_logical_and
id|HCD_IS_RUNNING
(paren
id|ehci-&gt;hcd.state
)paren
)paren
(brace
r_struct
id|ehci_qh
op_star
id|last
suffix:semicolon
r_for
c_loop
(paren
id|last
op_assign
id|ehci-&gt;reclaim
suffix:semicolon
id|last-&gt;reclaim
suffix:semicolon
id|last
op_assign
id|last-&gt;reclaim
)paren
r_continue
suffix:semicolon
id|qh-&gt;qh_state
op_assign
id|QH_STATE_UNLINK_WAIT
suffix:semicolon
id|last-&gt;reclaim
op_assign
id|qh
suffix:semicolon
multiline_comment|/* bypass IAA if the hc can&squot;t care */
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|HCD_IS_RUNNING
(paren
id|ehci-&gt;hcd.state
)paren
op_logical_and
id|ehci-&gt;reclaim
)paren
id|end_unlink_async
(paren
id|ehci
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* something else might have unlinked the qh by now */
r_if
c_cond
(paren
id|qh-&gt;qh_state
op_eq
id|QH_STATE_LINKED
)paren
id|start_unlink_async
(paren
id|ehci
comma
id|qh
)paren
suffix:semicolon
)brace
multiline_comment|/* remove from hardware lists&n; * completions normally happen asynchronously&n; */
DECL|function|ehci_urb_dequeue
r_static
r_int
id|ehci_urb_dequeue
(paren
r_struct
id|usb_hcd
op_star
id|hcd
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|ehci_hcd
op_star
id|ehci
op_assign
id|hcd_to_ehci
(paren
id|hcd
)paren
suffix:semicolon
r_struct
id|ehci_qh
op_star
id|qh
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|usb_pipetype
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
singleline_comment|// case PIPE_CONTROL:
singleline_comment|// case PIPE_BULK:
r_default
suffix:colon
id|qh
op_assign
(paren
r_struct
id|ehci_qh
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|qh
)paren
r_break
suffix:semicolon
id|unlink_async
(paren
id|ehci
comma
id|qh
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_INTERRUPT
suffix:colon
id|qh
op_assign
(paren
r_struct
id|ehci_qh
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|qh
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|qh-&gt;qh_state
op_eq
id|QH_STATE_LINKED
)paren
(brace
multiline_comment|/* messy, can spin or block a microframe ... */
id|intr_deschedule
(paren
id|ehci
comma
id|qh
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* qh_state == IDLE */
)brace
id|qh_completions
(paren
id|ehci
comma
id|qh
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* reschedule QH iff another request is queued */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|qh-&gt;qtd_list
)paren
op_logical_and
id|HCD_IS_RUNNING
(paren
id|ehci-&gt;hcd.state
)paren
)paren
(brace
r_int
id|status
suffix:semicolon
id|status
op_assign
id|qh_schedule
(paren
id|ehci
comma
id|qh
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
l_int|0
)paren
(brace
singleline_comment|// shouldn&squot;t happen often, but ...
singleline_comment|// FIXME kill those tds&squot; urbs
id|err
(paren
l_string|&quot;can&squot;t reschedule qh %p, err %d&quot;
comma
id|qh
comma
id|status
)paren
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|PIPE_ISOCHRONOUS
suffix:colon
singleline_comment|// itd or sitd ...
singleline_comment|// wait till next completion, do it then.
singleline_comment|// completion irqs can wait up to 1024 msec,
r_break
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
singleline_comment|// bulk qh holds the data toggle
r_static
r_void
DECL|function|ehci_endpoint_disable
id|ehci_endpoint_disable
(paren
r_struct
id|usb_hcd
op_star
id|hcd
comma
r_struct
id|hcd_dev
op_star
id|dev
comma
r_int
id|ep
)paren
(brace
r_struct
id|ehci_hcd
op_star
id|ehci
op_assign
id|hcd_to_ehci
(paren
id|hcd
)paren
suffix:semicolon
r_int
id|epnum
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|ehci_qh
op_star
id|qh
comma
op_star
id|tmp
suffix:semicolon
multiline_comment|/* ASSERT:  any requests/urbs are being unlinked */
multiline_comment|/* ASSERT:  nobody can be submitting urbs for this any more */
id|epnum
op_assign
id|ep
op_amp
id|USB_ENDPOINT_NUMBER_MASK
suffix:semicolon
r_if
c_cond
(paren
id|epnum
op_ne
l_int|0
op_logical_and
(paren
id|ep
op_amp
id|USB_DIR_IN
)paren
)paren
id|epnum
op_or_assign
l_int|0x10
suffix:semicolon
id|rescan
suffix:colon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|qh
op_assign
(paren
r_struct
id|ehci_qh
op_star
)paren
id|dev-&gt;ep
(braket
id|epnum
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|qh
)paren
r_goto
id|done
suffix:semicolon
multiline_comment|/* endpoints can be iso streams.  for now, we don&squot;t&n;&t; * accelerate iso completions ... so spin a while.&n;&t; */
r_if
c_cond
(paren
id|qh-&gt;hw_info1
op_eq
l_int|0
)paren
(brace
id|ehci_vdbg
(paren
id|ehci
comma
l_string|&quot;iso delay&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|idle_timeout
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|HCD_IS_RUNNING
(paren
id|ehci-&gt;hcd.state
)paren
)paren
id|qh-&gt;qh_state
op_assign
id|QH_STATE_IDLE
suffix:semicolon
r_switch
c_cond
(paren
id|qh-&gt;qh_state
)paren
(brace
r_case
id|QH_STATE_LINKED
suffix:colon
r_for
c_loop
(paren
id|tmp
op_assign
id|ehci-&gt;async-&gt;qh_next.qh
suffix:semicolon
id|tmp
op_logical_and
id|tmp
op_ne
id|qh
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;qh_next.qh
)paren
r_continue
suffix:semicolon
multiline_comment|/* periodic qh self-unlinks on empty */
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
r_goto
id|nogood
suffix:semicolon
id|unlink_async
(paren
id|ehci
comma
id|qh
)paren
suffix:semicolon
multiline_comment|/* FALL THROUGH */
r_case
id|QH_STATE_UNLINK
suffix:colon
multiline_comment|/* wait for hw to finish? */
id|idle_timeout
suffix:colon
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|set_current_state
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
(paren
l_int|1
)paren
suffix:semicolon
r_goto
id|rescan
suffix:semicolon
r_case
id|QH_STATE_IDLE
suffix:colon
multiline_comment|/* fully unlinked */
r_if
c_cond
(paren
id|list_empty
(paren
op_amp
id|qh-&gt;qtd_list
)paren
)paren
(brace
id|qh_put
(paren
id|qh
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* else FALL THROUGH */
r_default
suffix:colon
id|nogood
suffix:colon
multiline_comment|/* caller was supposed to have unlinked any requests;&n;&t;&t; * that&squot;s not our job.  just leak this memory.&n;&t;&t; */
id|ehci_err
(paren
id|ehci
comma
l_string|&quot;qh %p (#%d) state %d%s&bslash;n&quot;
comma
id|qh
comma
id|epnum
comma
id|qh-&gt;qh_state
comma
id|list_empty
(paren
op_amp
id|qh-&gt;qtd_list
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;(has tds)&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|dev-&gt;ep
(braket
id|epnum
)braket
op_assign
l_int|NULL
suffix:semicolon
id|done
suffix:colon
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|variable|ehci_driver
r_static
r_const
r_struct
id|hc_driver
id|ehci_driver
op_assign
(brace
dot
id|description
op_assign
id|hcd_name
comma
multiline_comment|/*&n;&t; * generic hardware linkage&n;&t; */
dot
id|irq
op_assign
id|ehci_irq
comma
dot
id|flags
op_assign
id|HCD_MEMORY
op_or
id|HCD_USB2
comma
multiline_comment|/*&n;&t; * basic lifecycle operations&n;&t; */
dot
id|reset
op_assign
id|ehci_hc_reset
comma
dot
id|start
op_assign
id|ehci_start
comma
macro_line|#ifdef&t;CONFIG_PM
dot
id|suspend
op_assign
id|ehci_suspend
comma
dot
id|resume
op_assign
id|ehci_resume
comma
macro_line|#endif
dot
id|stop
op_assign
id|ehci_stop
comma
multiline_comment|/*&n;&t; * memory lifecycle (except per-request)&n;&t; */
dot
id|hcd_alloc
op_assign
id|ehci_hcd_alloc
comma
multiline_comment|/*&n;&t; * managing i/o requests and associated device resources&n;&t; */
dot
id|urb_enqueue
op_assign
id|ehci_urb_enqueue
comma
dot
id|urb_dequeue
op_assign
id|ehci_urb_dequeue
comma
dot
id|endpoint_disable
op_assign
id|ehci_endpoint_disable
comma
multiline_comment|/*&n;&t; * scheduling support&n;&t; */
dot
id|get_frame_number
op_assign
id|ehci_get_frame
comma
multiline_comment|/*&n;&t; * root hub support&n;&t; */
dot
id|hub_status_data
op_assign
id|ehci_hub_status_data
comma
dot
id|hub_control
op_assign
id|ehci_hub_control
comma
dot
id|hub_suspend
op_assign
id|ehci_hub_suspend
comma
dot
id|hub_resume
op_assign
id|ehci_hub_resume
comma
)brace
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* EHCI 1.0 doesn&squot;t require PCI */
macro_line|#ifdef&t;CONFIG_PCI
multiline_comment|/* PCI driver selection metadata; PCI hotplugging uses this */
DECL|variable|pci_ids
r_static
r_const
r_struct
id|pci_device_id
id|pci_ids
(braket
)braket
op_assign
(brace
(brace
multiline_comment|/* handle any USB 2.0 EHCI controller */
id|PCI_DEVICE_CLASS
c_func
(paren
(paren
(paren
id|PCI_CLASS_SERIAL_USB
op_lshift
l_int|8
)paren
op_or
l_int|0x20
)paren
comma
op_complement
l_int|0
)paren
comma
dot
id|driver_data
op_assign
(paren
r_int
r_int
)paren
op_amp
id|ehci_driver
comma
)brace
comma
(brace
multiline_comment|/* end: all zeroes */
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
(paren
id|pci
comma
id|pci_ids
)paren
suffix:semicolon
multiline_comment|/* pci driver glue; this is a &quot;new style&quot; PCI driver module */
DECL|variable|ehci_pci_driver
r_static
r_struct
id|pci_driver
id|ehci_pci_driver
op_assign
(brace
dot
id|name
op_assign
(paren
r_char
op_star
)paren
id|hcd_name
comma
dot
id|id_table
op_assign
id|pci_ids
comma
dot
id|probe
op_assign
id|usb_hcd_pci_probe
comma
dot
id|remove
op_assign
id|usb_hcd_pci_remove
comma
macro_line|#ifdef&t;CONFIG_PM
dot
id|suspend
op_assign
id|usb_hcd_pci_suspend
comma
dot
id|resume
op_assign
id|usb_hcd_pci_resume
comma
macro_line|#endif
)brace
suffix:semicolon
macro_line|#endif&t;/* PCI */
DECL|macro|DRIVER_INFO
mdefine_line|#define DRIVER_INFO DRIVER_VERSION &quot; &quot; DRIVER_DESC
DECL|variable|DRIVER_INFO
id|MODULE_DESCRIPTION
(paren
id|DRIVER_INFO
)paren
suffix:semicolon
DECL|variable|DRIVER_AUTHOR
id|MODULE_AUTHOR
(paren
id|DRIVER_AUTHOR
)paren
suffix:semicolon
id|MODULE_LICENSE
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|function|init
r_static
r_int
id|__init
id|init
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|usb_disabled
c_func
(paren
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|pr_debug
(paren
l_string|&quot;%s: block sizes: qh %Zd qtd %Zd itd %Zd sitd %Zd&bslash;n&quot;
comma
id|hcd_name
comma
r_sizeof
(paren
r_struct
id|ehci_qh
)paren
comma
r_sizeof
(paren
r_struct
id|ehci_qtd
)paren
comma
r_sizeof
(paren
r_struct
id|ehci_itd
)paren
comma
r_sizeof
(paren
r_struct
id|ehci_sitd
)paren
)paren
suffix:semicolon
r_return
id|pci_register_driver
(paren
op_amp
id|ehci_pci_driver
)paren
suffix:semicolon
)brace
DECL|variable|init
id|module_init
(paren
id|init
)paren
suffix:semicolon
DECL|function|cleanup
r_static
r_void
id|__exit
id|cleanup
(paren
r_void
)paren
(brace
id|pci_unregister_driver
(paren
op_amp
id|ehci_pci_driver
)paren
suffix:semicolon
)brace
DECL|variable|cleanup
id|module_exit
(paren
id|cleanup
)paren
suffix:semicolon
eof
