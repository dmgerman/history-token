multiline_comment|/*&n; * Copyright (c) 2000-2002 by David Brownell&n; * &n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2 of the License, or (at your&n; * option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY&n; * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License&n; * for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software Foundation,&n; * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#ifdef CONFIG_USB_DEBUG
DECL|macro|DEBUG
mdefine_line|#define DEBUG
macro_line|#else
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#endif
macro_line|#include &lt;linux/usb.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,5,32)
macro_line|#include &quot;../hcd.h&quot;
macro_line|#else
macro_line|#include &quot;../core/hcd.h&quot;
macro_line|#endif
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/unaligned.h&gt;
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * EHCI hc_driver implementation ... experimental, incomplete.&n; * Based on the final 1.0 register interface specification.&n; *&n; * USB 2.0 shows up in upcoming www.pcmcia.org technology.&n; * First was PCMCIA, like ISA; then CardBus, which is PCI.&n; * Next comes &quot;CardBay&quot;, using USB 2.0 signals.&n; *&n; * Contains additional contributions by Brad Hards, Rory Bolt, and others.&n; * Special thanks to Intel and VIA for providing host controllers to&n; * test this driver on, and Cypress (including In-System Design) for&n; * providing early devices for those host controllers to talk to!&n; *&n; * HISTORY:&n; *&n; * 2002-08-06&t;Handling for bulk and interrupt transfers is mostly shared;&n; *&t;only scheduling is different, no arbitrary limitations.&n; * 2002-07-25&t;Sanity check PCI reads, mostly for better cardbus support,&n; * &t;clean up HC run state handshaking.&n; * 2002-05-24&t;Preliminary FS/LS interrupts, using scheduling shortcuts&n; * 2002-05-11&t;Clear TT errors for FS/LS ctrl/bulk.  Fill in some other&n; *&t;missing pieces:  enabling 64bit dma, handoff from BIOS/SMM.&n; * 2002-05-07&t;Some error path cleanups to report better errors; wmb();&n; *&t;use non-CVS version id; better iso bandwidth claim.&n; * 2002-04-19&t;Control/bulk/interrupt submit no longer uses giveback() on&n; *&t;errors in submit path.  Bugfixes to interrupt scheduling/processing.&n; * 2002-03-05&t;Initial high-speed ISO support; reduce ITD memory; shift&n; *&t;more checking to generic hcd framework (db).  Make it work with&n; *&t;Philips EHCI; reduce PCI traffic; shorten IRQ path (Rory Bolt).&n; * 2002-01-14&t;Minor cleanup; version synch.&n; * 2002-01-08&t;Fix roothub handoff of FS/LS to companion controllers.&n; * 2002-01-04&t;Control/Bulk queuing behaves.&n; *&n; * 2001-12-12&t;Initial patch version for Linux 2.5.1 kernel.&n; * 2001-June&t;Works with usb-storage and NEC EHCI on 2.4&n; */
DECL|macro|DRIVER_VERSION
mdefine_line|#define DRIVER_VERSION &quot;2002-Sep-23&quot;
DECL|macro|DRIVER_AUTHOR
mdefine_line|#define DRIVER_AUTHOR &quot;David Brownell&quot;
DECL|macro|DRIVER_DESC
mdefine_line|#define DRIVER_DESC &quot;USB 2.0 &squot;Enhanced&squot; Host Controller (EHCI) Driver&quot;
DECL|variable|hcd_name
r_static
r_const
r_char
id|hcd_name
(braket
)braket
op_assign
l_string|&quot;ehci-hcd&quot;
suffix:semicolon
singleline_comment|// #define EHCI_VERBOSE_DEBUG
singleline_comment|// #define have_split_iso
macro_line|#ifdef DEBUG
DECL|macro|EHCI_STATS
mdefine_line|#define EHCI_STATS
macro_line|#endif
DECL|macro|INTR_AUTOMAGIC
mdefine_line|#define INTR_AUTOMAGIC&t;&t;/* to be removed later in 2.5 */
multiline_comment|/* magic numbers that can affect system performance */
DECL|macro|EHCI_TUNE_CERR
mdefine_line|#define&t;EHCI_TUNE_CERR&t;&t;3&t;/* 0-3 qtd retries; 0 == don&squot;t stop */
DECL|macro|EHCI_TUNE_RL_HS
mdefine_line|#define&t;EHCI_TUNE_RL_HS&t;&t;0&t;/* nak throttle; see 4.9 */
DECL|macro|EHCI_TUNE_RL_TT
mdefine_line|#define&t;EHCI_TUNE_RL_TT&t;&t;0
DECL|macro|EHCI_TUNE_MULT_HS
mdefine_line|#define&t;EHCI_TUNE_MULT_HS&t;1&t;/* 1-3 transactions/uframe; 4.10.3 */
DECL|macro|EHCI_TUNE_MULT_TT
mdefine_line|#define&t;EHCI_TUNE_MULT_TT&t;1
DECL|macro|EHCI_WATCHDOG_JIFFIES
mdefine_line|#define EHCI_WATCHDOG_JIFFIES&t;(HZ/100)&t;/* arbitrary; ~10 msec */
DECL|macro|EHCI_ASYNC_JIFFIES
mdefine_line|#define EHCI_ASYNC_JIFFIES&t;(HZ/3)&t;&t;/* async idle timeout */
multiline_comment|/* Initial IRQ latency:  lower than default */
DECL|variable|log2_irq_thresh
r_static
r_int
id|log2_irq_thresh
op_assign
l_int|0
suffix:semicolon
singleline_comment|// 0 to 6
id|MODULE_PARM
(paren
id|log2_irq_thresh
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
(paren
id|log2_irq_thresh
comma
l_string|&quot;log2 IRQ latency, 1-64 microframes&quot;
)paren
suffix:semicolon
multiline_comment|/* allow irqs at least every N URB completions */
DECL|variable|max_completions
r_static
r_int
id|max_completions
op_assign
l_int|16
suffix:semicolon
id|MODULE_PARM
(paren
id|max_completions
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
(paren
id|max_completions
comma
l_string|&quot;limit for urb completions called with irqs disenabled&quot;
)paren
suffix:semicolon
DECL|macro|INTR_MASK
mdefine_line|#define&t;INTR_MASK (STS_IAA | STS_FATAL | STS_ERR | STS_INT)
multiline_comment|/*-------------------------------------------------------------------------*/
macro_line|#include &quot;ehci.h&quot;
macro_line|#include &quot;ehci-dbg.c&quot;
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * handshake - spin reading hc until handshake completes or fails&n; * @ptr: address of hc register to be read&n; * @mask: bits to look at in result of read&n; * @done: value of those bits when handshake succeeds&n; * @usec: timeout in microseconds&n; *&n; * Returns negative errno, or zero on success&n; *&n; * Success happens when the &quot;mask&quot; bits have the specified value (hardware&n; * handshake done).  There are two failure modes:  &quot;usec&quot; have passed (major&n; * hardware flakeout), or the register reads as all-ones (hardware removed).&n; *&n; * That last failure should_only happen in cases like physical cardbus eject&n; * before driver shutdown. But it also seems to be caused by bugs in cardbus&n; * bridge shutdown:  shutting down the bridge before the devices using it.&n; */
DECL|function|handshake
r_static
r_int
id|handshake
(paren
id|u32
op_star
id|ptr
comma
id|u32
id|mask
comma
id|u32
id|done
comma
r_int
id|usec
)paren
(brace
id|u32
id|result
suffix:semicolon
r_do
(brace
id|result
op_assign
id|readl
(paren
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
op_complement
(paren
id|u32
)paren
l_int|0
)paren
multiline_comment|/* card removed */
r_return
op_minus
id|ENODEV
suffix:semicolon
id|result
op_and_assign
id|mask
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
id|done
)paren
r_return
l_int|0
suffix:semicolon
id|udelay
(paren
l_int|1
)paren
suffix:semicolon
id|usec
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
id|usec
OG
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|ETIMEDOUT
suffix:semicolon
)brace
multiline_comment|/*&n; * hc states include: unknown, halted, ready, running&n; * transitional states are messy just now&n; * trying to avoid &quot;running&quot; unless urbs are active&n; * a &quot;ready&quot; hc can be finishing prefetched work&n; */
multiline_comment|/* force HC to halt state from unknown (EHCI spec section 2.3) */
DECL|function|ehci_halt
r_static
r_int
id|ehci_halt
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
)paren
(brace
id|u32
id|temp
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;status
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|temp
op_amp
id|STS_HALT
)paren
op_ne
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|temp
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
id|temp
op_and_assign
op_complement
id|CMD_RUN
suffix:semicolon
id|writel
(paren
id|temp
comma
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
r_return
id|handshake
(paren
op_amp
id|ehci-&gt;regs-&gt;status
comma
id|STS_HALT
comma
id|STS_HALT
comma
l_int|16
op_star
l_int|125
)paren
suffix:semicolon
)brace
multiline_comment|/* reset a non-running (STS_HALT == 1) controller */
DECL|function|ehci_reset
r_static
r_int
id|ehci_reset
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
)paren
(brace
id|u32
id|command
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
id|command
op_or_assign
id|CMD_RESET
suffix:semicolon
id|dbg_cmd
(paren
id|ehci
comma
l_string|&quot;reset&quot;
comma
id|command
)paren
suffix:semicolon
id|writel
(paren
id|command
comma
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
id|ehci-&gt;hcd.state
op_assign
id|USB_STATE_HALT
suffix:semicolon
r_return
id|handshake
(paren
op_amp
id|ehci-&gt;regs-&gt;command
comma
id|CMD_RESET
comma
l_int|0
comma
l_int|250
)paren
suffix:semicolon
)brace
multiline_comment|/* idle the controller (from running) */
DECL|function|ehci_ready
r_static
r_void
id|ehci_ready
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
)paren
(brace
id|u32
id|temp
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
op_logical_neg
id|HCD_IS_RUNNING
(paren
id|ehci-&gt;hcd.state
)paren
)paren
id|BUG
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* wait for any schedule enables/disables to take effect */
id|temp
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ehci-&gt;async
)paren
id|temp
op_assign
id|STS_ASS
suffix:semicolon
r_if
c_cond
(paren
id|ehci-&gt;next_uframe
op_ne
op_minus
l_int|1
)paren
id|temp
op_or_assign
id|STS_PSS
suffix:semicolon
r_if
c_cond
(paren
id|handshake
(paren
op_amp
id|ehci-&gt;regs-&gt;status
comma
id|STS_ASS
op_or
id|STS_PSS
comma
id|temp
comma
l_int|16
op_star
l_int|125
)paren
op_ne
l_int|0
)paren
(brace
id|ehci-&gt;hcd.state
op_assign
id|USB_STATE_HALT
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* then disable anything that&squot;s still active */
id|temp
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
id|temp
op_and_assign
op_complement
(paren
id|CMD_ASE
op_or
id|CMD_IAAD
op_or
id|CMD_PSE
)paren
suffix:semicolon
id|writel
(paren
id|temp
comma
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
multiline_comment|/* hardware can take 16 microframes to turn off ... */
r_if
c_cond
(paren
id|handshake
(paren
op_amp
id|ehci-&gt;regs-&gt;status
comma
id|STS_ASS
op_or
id|STS_PSS
comma
l_int|0
comma
l_int|16
op_star
l_int|125
)paren
op_ne
l_int|0
)paren
(brace
id|ehci-&gt;hcd.state
op_assign
id|USB_STATE_HALT
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ehci-&gt;hcd.state
op_assign
id|USB_STATE_READY
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
macro_line|#include &quot;ehci-hub.c&quot;
macro_line|#include &quot;ehci-mem.c&quot;
macro_line|#include &quot;ehci-q.c&quot;
macro_line|#include &quot;ehci-sched.c&quot;
multiline_comment|/*-------------------------------------------------------------------------*/
r_static
r_void
id|ehci_tasklet
(paren
r_int
r_int
id|param
)paren
suffix:semicolon
r_static
r_void
id|ehci_irq
(paren
r_struct
id|usb_hcd
op_star
id|hcd
)paren
suffix:semicolon
DECL|function|ehci_watchdog
r_static
r_void
id|ehci_watchdog
(paren
r_int
r_int
id|param
)paren
(brace
r_struct
id|ehci_hcd
op_star
id|ehci
op_assign
(paren
r_struct
id|ehci_hcd
op_star
)paren
id|param
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* guard against lost IAA, which wedges everything */
id|ehci_irq
(paren
op_amp
id|ehci-&gt;hcd
)paren
suffix:semicolon
multiline_comment|/* unlink the last qh after it&squot;s idled a while */
r_if
c_cond
(paren
id|ehci-&gt;async_idle
)paren
(brace
id|start_unlink_async
(paren
id|ehci
comma
id|ehci-&gt;async
)paren
suffix:semicolon
id|ehci-&gt;async_idle
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* EHCI 0.96 (and later) section 5.1 says how to kick BIOS/SMM/...&n; * off the controller (maybe it can boot from highspeed USB disks).&n; */
DECL|function|bios_handoff
r_static
r_int
id|bios_handoff
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_int
id|where
comma
id|u32
id|cap
)paren
(brace
r_if
c_cond
(paren
id|cap
op_amp
(paren
l_int|1
op_lshift
l_int|16
)paren
)paren
(brace
r_int
id|msec
op_assign
l_int|500
suffix:semicolon
multiline_comment|/* request handoff to OS */
id|cap
op_and_assign
l_int|1
op_lshift
l_int|24
suffix:semicolon
id|pci_write_config_dword
(paren
id|ehci-&gt;hcd.pdev
comma
id|where
comma
id|cap
)paren
suffix:semicolon
multiline_comment|/* and wait a while for it to happen */
r_do
(brace
id|wait_ms
(paren
l_int|10
)paren
suffix:semicolon
id|msec
op_sub_assign
l_int|10
suffix:semicolon
id|pci_read_config_dword
(paren
id|ehci-&gt;hcd.pdev
comma
id|where
comma
op_amp
id|cap
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|cap
op_amp
(paren
l_int|1
op_lshift
l_int|16
)paren
)paren
op_logical_and
id|msec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cap
op_amp
(paren
l_int|1
op_lshift
l_int|16
)paren
)paren
(brace
id|info
(paren
l_string|&quot;BIOS handoff failed (%d, %04x)&quot;
comma
id|where
comma
id|cap
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|dbg
(paren
l_string|&quot;BIOS handoff succeeded&quot;
)paren
suffix:semicolon
)brace
r_else
id|dbg
(paren
l_string|&quot;BIOS handoff not needed&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* called by khubd or root hub init threads */
DECL|function|ehci_start
r_static
r_int
id|ehci_start
(paren
r_struct
id|usb_hcd
op_star
id|hcd
)paren
(brace
r_struct
id|ehci_hcd
op_star
id|ehci
op_assign
id|hcd_to_ehci
(paren
id|hcd
)paren
suffix:semicolon
id|u32
id|temp
suffix:semicolon
r_struct
id|usb_device
op_star
id|udev
suffix:semicolon
r_struct
id|usb_bus
op_star
id|bus
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|u32
id|hcc_params
suffix:semicolon
id|u8
id|tempbyte
suffix:semicolon
id|spin_lock_init
(paren
op_amp
id|ehci-&gt;lock
)paren
suffix:semicolon
id|ehci-&gt;caps
op_assign
(paren
r_struct
id|ehci_caps
op_star
)paren
id|hcd-&gt;regs
suffix:semicolon
id|ehci-&gt;regs
op_assign
(paren
r_struct
id|ehci_regs
op_star
)paren
(paren
id|hcd-&gt;regs
op_plus
id|ehci-&gt;caps-&gt;length
)paren
suffix:semicolon
id|dbg_hcs_params
(paren
id|ehci
comma
l_string|&quot;ehci_start&quot;
)paren
suffix:semicolon
id|dbg_hcc_params
(paren
id|ehci
comma
l_string|&quot;ehci_start&quot;
)paren
suffix:semicolon
id|hcc_params
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;caps-&gt;hcc_params
)paren
suffix:semicolon
multiline_comment|/* EHCI 0.96 and later may have &quot;extended capabilities&quot; */
id|temp
op_assign
id|HCC_EXT_CAPS
(paren
id|hcc_params
)paren
suffix:semicolon
r_while
c_loop
(paren
id|temp
)paren
(brace
id|u32
id|cap
suffix:semicolon
id|pci_read_config_dword
(paren
id|ehci-&gt;hcd.pdev
comma
id|temp
comma
op_amp
id|cap
)paren
suffix:semicolon
id|dbg
(paren
l_string|&quot;capability %04x at %02x&quot;
comma
id|cap
comma
id|temp
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cap
op_amp
l_int|0xff
)paren
(brace
r_case
l_int|1
suffix:colon
multiline_comment|/* BIOS/SMM/... handoff */
r_if
c_cond
(paren
id|bios_handoff
(paren
id|ehci
comma
id|temp
comma
id|cap
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
multiline_comment|/* illegal reserved capability */
id|warn
(paren
l_string|&quot;illegal capability!&quot;
)paren
suffix:semicolon
id|cap
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_default
suffix:colon
multiline_comment|/* unknown */
r_break
suffix:semicolon
)brace
id|temp
op_assign
(paren
id|cap
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
)brace
multiline_comment|/* cache this readonly data; minimize PCI reads */
id|ehci-&gt;hcs_params
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;caps-&gt;hcs_params
)paren
suffix:semicolon
multiline_comment|/* force HC to halt state */
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|ehci_halt
(paren
id|ehci
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|retval
suffix:semicolon
multiline_comment|/*&n;&t; * hw default: 1K periodic list heads, one per frame.&n;&t; * periodic_size can shrink by USBCMD update if hcc_params allows.&n;&t; */
id|ehci-&gt;periodic_size
op_assign
id|DEFAULT_I_TDPS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|ehci_mem_init
(paren
id|ehci
comma
id|SLAB_KERNEL
)paren
)paren
OL
l_int|0
)paren
r_return
id|retval
suffix:semicolon
multiline_comment|/* controllers may cache some of the periodic schedule ... */
r_if
c_cond
(paren
id|HCC_ISOC_CACHE
(paren
id|hcc_params
)paren
)paren
singleline_comment|// full frame cache
id|ehci-&gt;i_thresh
op_assign
l_int|8
suffix:semicolon
r_else
singleline_comment|// N microframes cached
id|ehci-&gt;i_thresh
op_assign
l_int|2
op_plus
id|HCC_ISOC_THRES
(paren
id|hcc_params
)paren
suffix:semicolon
id|ehci-&gt;async
op_assign
l_int|0
suffix:semicolon
id|ehci-&gt;reclaim
op_assign
l_int|0
suffix:semicolon
id|ehci-&gt;next_uframe
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* controller state:  unknown --&gt; reset */
multiline_comment|/* EHCI spec section 4.1 */
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|ehci_reset
(paren
id|ehci
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|ehci_mem_cleanup
(paren
id|ehci
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|writel
(paren
id|INTR_MASK
comma
op_amp
id|ehci-&gt;regs-&gt;intr_enable
)paren
suffix:semicolon
id|writel
(paren
id|ehci-&gt;periodic_dma
comma
op_amp
id|ehci-&gt;regs-&gt;frame_list
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * hcc_params controls whether ehci-&gt;regs-&gt;segment must (!!!)&n;&t; * be used; it constrains QH/ITD/SITD and QTD locations.&n;&t; * pci_pool consistent memory always uses segment zero.&n;&t; * streaming mappings for I/O buffers, like pci_map_single(),&n;&t; * can return segments above 4GB, if the device allows.&n;&t; *&n;&t; * NOTE:  layered drivers can&squot;t yet tell when we enable that,&n;&t; * so they can&squot;t pass this info along (like NETIF_F_HIGHDMA)&n;&t; * (or like Scsi_Host.highmem_io) ... usb_bus.flags?&n;&t; */
r_if
c_cond
(paren
id|HCC_64BIT_ADDR
(paren
id|hcc_params
)paren
)paren
(brace
id|writel
(paren
l_int|0
comma
op_amp
id|ehci-&gt;regs-&gt;segment
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pci_set_dma_mask
(paren
id|ehci-&gt;hcd.pdev
comma
l_int|0xffffffffffffffffULL
)paren
)paren
id|info
(paren
l_string|&quot;enabled 64bit PCI DMA (DAC)&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* clear interrupt enables, set irq latency */
id|temp
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|log2_irq_thresh
template_param
l_int|6
)paren
id|log2_irq_thresh
op_assign
l_int|0
suffix:semicolon
id|temp
op_or_assign
l_int|1
op_lshift
(paren
l_int|16
op_plus
id|log2_irq_thresh
)paren
suffix:semicolon
singleline_comment|// if hc can park (ehci &gt;= 0.96), default is 3 packets per async QH 
singleline_comment|// keeping default periodic framelist size
id|temp
op_and_assign
op_complement
(paren
id|CMD_IAAD
op_or
id|CMD_ASE
op_or
id|CMD_PSE
)paren
comma
singleline_comment|// Philips, Intel, and maybe others need CMD_RUN before the
singleline_comment|// root hub will detect new devices (why?); NEC doesn&squot;t
id|temp
op_or_assign
id|CMD_RUN
suffix:semicolon
id|writel
(paren
id|temp
comma
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
id|dbg_cmd
(paren
id|ehci
comma
l_string|&quot;init&quot;
comma
id|temp
)paren
suffix:semicolon
multiline_comment|/* set async sleep time = 10 us ... ? */
id|ehci-&gt;tasklet.func
op_assign
id|ehci_tasklet
suffix:semicolon
id|ehci-&gt;tasklet.data
op_assign
(paren
r_int
r_int
)paren
id|ehci
suffix:semicolon
id|init_timer
(paren
op_amp
id|ehci-&gt;watchdog
)paren
suffix:semicolon
id|ehci-&gt;watchdog.function
op_assign
id|ehci_watchdog
suffix:semicolon
id|ehci-&gt;watchdog.data
op_assign
(paren
r_int
r_int
)paren
id|ehci
suffix:semicolon
multiline_comment|/* wire up the root hub */
id|bus
op_assign
id|hcd_to_bus
(paren
id|hcd
)paren
suffix:semicolon
id|bus-&gt;root_hub
op_assign
id|udev
op_assign
id|usb_alloc_dev
(paren
l_int|NULL
comma
id|bus
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|udev
)paren
(brace
id|done2
suffix:colon
id|ehci_mem_cleanup
(paren
id|ehci
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Start, enabling full USB 2.0 functionality ... usb 1.1 devices&n;&t; * are explicitly handed to companion controller(s), so no TT is&n;&t; * involved with the root hub.&n;&t; */
id|ehci-&gt;hcd.state
op_assign
id|USB_STATE_READY
suffix:semicolon
id|writel
(paren
id|FLAG_CF
comma
op_amp
id|ehci-&gt;regs-&gt;configured_flag
)paren
suffix:semicolon
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
multiline_comment|/* unblock posted write */
multiline_comment|/* PCI Serial Bus Release Number is at 0x60 offset */
id|pci_read_config_byte
(paren
id|hcd-&gt;pdev
comma
l_int|0x60
comma
op_amp
id|tempbyte
)paren
suffix:semicolon
id|temp
op_assign
id|readw
(paren
op_amp
id|ehci-&gt;caps-&gt;hci_version
)paren
suffix:semicolon
id|info
(paren
l_string|&quot;USB %x.%x support enabled, EHCI rev %x.%02x, %s %s&quot;
comma
(paren
(paren
id|tempbyte
op_amp
l_int|0xf0
)paren
op_rshift
l_int|4
)paren
comma
(paren
id|tempbyte
op_amp
l_int|0x0f
)paren
comma
id|temp
op_rshift
l_int|8
comma
id|temp
op_amp
l_int|0xff
comma
id|hcd_name
comma
id|DRIVER_VERSION
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * From here on, khubd concurrently accesses the root&n;&t; * hub; drivers will be talking to enumerated devices.&n;&t; *&n;&t; * Before this point the HC was idle/ready.  After, khubd&n;&t; * and device drivers may start it running.&n;&t; */
id|usb_connect
(paren
id|udev
)paren
suffix:semicolon
id|udev-&gt;speed
op_assign
id|USB_SPEED_HIGH
suffix:semicolon
r_if
c_cond
(paren
id|hcd_register_root
(paren
id|hcd
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|hcd-&gt;state
op_eq
id|USB_STATE_RUNNING
)paren
id|ehci_ready
(paren
id|ehci
)paren
suffix:semicolon
id|ehci_reset
(paren
id|ehci
)paren
suffix:semicolon
id|bus-&gt;root_hub
op_assign
l_int|0
suffix:semicolon
id|usb_free_dev
(paren
id|udev
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|done2
suffix:semicolon
)brace
id|create_debug_files
(paren
id|ehci
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* always called by thread; normally rmmod */
DECL|function|ehci_stop
r_static
r_void
id|ehci_stop
(paren
r_struct
id|usb_hcd
op_star
id|hcd
)paren
(brace
r_struct
id|ehci_hcd
op_star
id|ehci
op_assign
id|hcd_to_ehci
(paren
id|hcd
)paren
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s: stop&quot;
comma
id|hcd_to_bus
(paren
id|hcd
)paren
op_member_access_from_pointer
id|bus_name
)paren
suffix:semicolon
multiline_comment|/* no more interrupts ... */
r_if
c_cond
(paren
id|hcd-&gt;state
op_eq
id|USB_STATE_RUNNING
)paren
id|ehci_ready
(paren
id|ehci
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_interrupt
(paren
)paren
)paren
multiline_comment|/* should not happen!! */
id|err
(paren
l_string|&quot;stopped %s!&quot;
comma
id|RUN_CONTEXT
)paren
suffix:semicolon
r_else
id|del_timer_sync
(paren
op_amp
id|ehci-&gt;watchdog
)paren
suffix:semicolon
id|ehci_reset
(paren
id|ehci
)paren
suffix:semicolon
multiline_comment|/* let companion controllers work when we aren&squot;t */
id|writel
(paren
l_int|0
comma
op_amp
id|ehci-&gt;regs-&gt;configured_flag
)paren
suffix:semicolon
id|remove_debug_files
(paren
id|ehci
)paren
suffix:semicolon
multiline_comment|/* root hub is shut down separately (first, when possible) */
id|tasklet_disable
(paren
op_amp
id|ehci-&gt;tasklet
)paren
suffix:semicolon
id|ehci_tasklet
(paren
(paren
r_int
r_int
)paren
id|ehci
)paren
suffix:semicolon
id|ehci_mem_cleanup
(paren
id|ehci
)paren
suffix:semicolon
macro_line|#ifdef&t;EHCI_STATS
id|dbg
(paren
l_string|&quot;irq normal %ld err %ld reclaim %ld&quot;
comma
id|ehci-&gt;stats.normal
comma
id|ehci-&gt;stats.error
comma
id|ehci-&gt;stats.reclaim
)paren
suffix:semicolon
id|dbg
(paren
l_string|&quot;complete %ld unlink %ld qpatch %ld&quot;
comma
id|ehci-&gt;stats.complete
comma
id|ehci-&gt;stats.unlink
comma
id|ehci-&gt;stats.qpatch
)paren
suffix:semicolon
macro_line|#endif
id|dbg_status
(paren
id|ehci
comma
l_string|&quot;ehci_stop completed&quot;
comma
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;status
)paren
)paren
suffix:semicolon
)brace
DECL|function|ehci_get_frame
r_static
r_int
id|ehci_get_frame
(paren
r_struct
id|usb_hcd
op_star
id|hcd
)paren
(brace
r_struct
id|ehci_hcd
op_star
id|ehci
op_assign
id|hcd_to_ehci
(paren
id|hcd
)paren
suffix:semicolon
r_return
(paren
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;frame_index
)paren
op_rshift
l_int|3
)paren
op_mod
id|ehci-&gt;periodic_size
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
macro_line|#ifdef&t;CONFIG_PM
multiline_comment|/* suspend/resume, section 4.3 */
DECL|function|ehci_suspend
r_static
r_int
id|ehci_suspend
(paren
r_struct
id|usb_hcd
op_star
id|hcd
comma
id|u32
id|state
)paren
(brace
r_struct
id|ehci_hcd
op_star
id|ehci
op_assign
id|hcd_to_ehci
(paren
id|hcd
)paren
suffix:semicolon
r_int
id|ports
suffix:semicolon
r_int
id|i
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s: suspend to %d&quot;
comma
id|hcd_to_bus
(paren
id|hcd
)paren
op_member_access_from_pointer
id|bus_name
comma
id|state
)paren
suffix:semicolon
id|ports
op_assign
id|HCS_N_PORTS
(paren
id|ehci-&gt;hcs_params
)paren
suffix:semicolon
singleline_comment|// FIXME:  This assumes what&squot;s probably a D3 level suspend...
singleline_comment|// FIXME:  usb wakeup events on this bus should resume the machine.
singleline_comment|// pci config register PORTWAKECAP controls which ports can do it;
singleline_comment|// bios may have initted the register...
multiline_comment|/* suspend each port, then stop the hc */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ports
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|temp
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;port_status
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|temp
op_amp
id|PORT_PE
)paren
op_eq
l_int|0
op_logical_or
(paren
id|temp
op_amp
id|PORT_OWNER
)paren
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s: suspend port %d&quot;
comma
id|hcd_to_bus
(paren
id|hcd
)paren
op_member_access_from_pointer
id|bus_name
comma
id|i
)paren
suffix:semicolon
id|temp
op_or_assign
id|PORT_SUSPEND
suffix:semicolon
id|writel
(paren
id|temp
comma
op_amp
id|ehci-&gt;regs-&gt;port_status
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hcd-&gt;state
op_eq
id|USB_STATE_RUNNING
)paren
id|ehci_ready
(paren
id|ehci
)paren
suffix:semicolon
id|writel
(paren
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
op_amp
op_complement
id|CMD_RUN
comma
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
singleline_comment|// save pci FLADJ value
multiline_comment|/* who tells PCI to reduce power consumption? */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ehci_resume
r_static
r_int
id|ehci_resume
(paren
r_struct
id|usb_hcd
op_star
id|hcd
)paren
(brace
r_struct
id|ehci_hcd
op_star
id|ehci
op_assign
id|hcd_to_ehci
(paren
id|hcd
)paren
suffix:semicolon
r_int
id|ports
suffix:semicolon
r_int
id|i
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s: resume&quot;
comma
id|hcd_to_bus
(paren
id|hcd
)paren
op_member_access_from_pointer
id|bus_name
)paren
suffix:semicolon
id|ports
op_assign
id|HCS_N_PORTS
(paren
id|ehci-&gt;hcs_params
)paren
suffix:semicolon
singleline_comment|// FIXME:  if controller didn&squot;t retain state,
singleline_comment|// return and let generic code clean it up
singleline_comment|// test configured_flag ?
multiline_comment|/* resume HC and each port */
singleline_comment|// restore pci FLADJ value
singleline_comment|// khubd and drivers will set HC running, if needed;
id|hcd-&gt;state
op_assign
id|USB_STATE_READY
suffix:semicolon
singleline_comment|// FIXME Philips/Intel/... etc don&squot;t really have a &quot;READY&quot;
singleline_comment|// state ... turn on CMD_RUN too
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ports
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|temp
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;port_status
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|temp
op_amp
id|PORT_PE
)paren
op_eq
l_int|0
op_logical_or
(paren
id|temp
op_amp
id|PORT_SUSPEND
)paren
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s: resume port %d&quot;
comma
id|hcd_to_bus
(paren
id|hcd
)paren
op_member_access_from_pointer
id|bus_name
comma
id|i
)paren
suffix:semicolon
id|temp
op_or_assign
id|PORT_RESUME
suffix:semicolon
id|writel
(paren
id|temp
comma
op_amp
id|ehci-&gt;regs-&gt;port_status
(braket
id|i
)braket
)paren
suffix:semicolon
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
multiline_comment|/* unblock posted writes */
id|wait_ms
(paren
l_int|20
)paren
suffix:semicolon
id|temp
op_and_assign
op_complement
id|PORT_RESUME
suffix:semicolon
id|writel
(paren
id|temp
comma
op_amp
id|ehci-&gt;regs-&gt;port_status
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
multiline_comment|/* unblock posted writes */
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * tasklet scheduled by some interrupts and other events&n; * calls driver completion functions ... but not in_irq()&n; */
DECL|function|ehci_tasklet
r_static
r_void
id|ehci_tasklet
(paren
r_int
r_int
id|param
)paren
(brace
r_struct
id|ehci_hcd
op_star
id|ehci
op_assign
(paren
r_struct
id|ehci_hcd
op_star
)paren
id|param
suffix:semicolon
id|spin_lock_irq
(paren
op_amp
id|ehci-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ehci-&gt;reclaim_ready
)paren
id|end_unlink_async
(paren
id|ehci
)paren
suffix:semicolon
id|scan_async
(paren
id|ehci
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ehci-&gt;next_uframe
op_ne
op_minus
l_int|1
)paren
id|scan_periodic
(paren
id|ehci
)paren
suffix:semicolon
id|spin_unlock_irq
(paren
op_amp
id|ehci-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|ehci_irq
r_static
r_void
id|ehci_irq
(paren
r_struct
id|usb_hcd
op_star
id|hcd
)paren
(brace
r_struct
id|ehci_hcd
op_star
id|ehci
op_assign
id|hcd_to_ehci
(paren
id|hcd
)paren
suffix:semicolon
id|u32
id|status
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;status
)paren
suffix:semicolon
r_int
id|bh
suffix:semicolon
multiline_comment|/* e.g. cardbus physical eject */
r_if
c_cond
(paren
id|status
op_eq
op_complement
(paren
id|u32
)paren
l_int|0
)paren
(brace
id|dbg
(paren
l_string|&quot;%s: device removed!&quot;
comma
id|hcd_to_bus
(paren
id|hcd
)paren
op_member_access_from_pointer
id|bus_name
)paren
suffix:semicolon
r_goto
id|dead
suffix:semicolon
)brace
id|status
op_and_assign
id|INTR_MASK
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
multiline_comment|/* irq sharing? */
r_return
suffix:semicolon
multiline_comment|/* clear (just) interrupts */
id|writel
(paren
id|status
comma
op_amp
id|ehci-&gt;regs-&gt;status
)paren
suffix:semicolon
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
multiline_comment|/* unblock posted write */
id|bh
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef&t;EHCI_VERBOSE_DEBUG
multiline_comment|/* unrequested/ignored: Port Change Detect, Frame List Rollover */
id|dbg_status
(paren
id|ehci
comma
l_string|&quot;irq&quot;
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* INT, ERR, and IAA interrupt rates can be throttled */
multiline_comment|/* normal [4.15.1.2] or error [4.15.1.1] completion */
r_if
c_cond
(paren
id|likely
(paren
(paren
id|status
op_amp
(paren
id|STS_INT
op_or
id|STS_ERR
)paren
)paren
op_ne
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|likely
(paren
(paren
id|status
op_amp
id|STS_ERR
)paren
op_eq
l_int|0
)paren
)paren
id|COUNT
(paren
id|ehci-&gt;stats.normal
)paren
suffix:semicolon
r_else
id|COUNT
(paren
id|ehci-&gt;stats.error
)paren
suffix:semicolon
id|bh
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* complete the unlinking of some qh [4.15.2.3] */
r_if
c_cond
(paren
id|status
op_amp
id|STS_IAA
)paren
(brace
id|COUNT
(paren
id|ehci-&gt;stats.reclaim
)paren
suffix:semicolon
id|ehci-&gt;reclaim_ready
op_assign
l_int|1
suffix:semicolon
id|bh
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* PCI errors [4.15.2.4] */
r_if
c_cond
(paren
id|unlikely
(paren
(paren
id|status
op_amp
id|STS_FATAL
)paren
op_ne
l_int|0
)paren
)paren
(brace
id|err
(paren
l_string|&quot;%s: fatal error, state %x&quot;
comma
id|hcd_to_bus
(paren
id|hcd
)paren
op_member_access_from_pointer
id|bus_name
comma
id|hcd-&gt;state
)paren
suffix:semicolon
id|dead
suffix:colon
id|ehci_reset
(paren
id|ehci
)paren
suffix:semicolon
multiline_comment|/* generic layer kills/unlinks all urbs, then&n;&t;&t; * uses ehci_stop to clean up the rest&n;&t;&t; */
id|bh
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* most work doesn&squot;t need to be in_irq() */
r_if
c_cond
(paren
id|likely
(paren
id|bh
op_eq
l_int|1
)paren
)paren
id|tasklet_schedule
(paren
op_amp
id|ehci-&gt;tasklet
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * non-error returns are a promise to giveback() the urb later&n; * we drop ownership so next owner (or urb unlink) can get it&n; *&n; * urb + dev is in hcd_dev.urb_list&n; * we&squot;re queueing TDs onto software and hardware lists&n; *&n; * hcd-specific init for hcpriv hasn&squot;t been done yet&n; *&n; * NOTE:  control, bulk, and interrupt share the same code to append TDs&n; * to a (possibly active) QH, and the same QH scanning code.&n; */
DECL|function|ehci_urb_enqueue
r_static
r_int
id|ehci_urb_enqueue
(paren
r_struct
id|usb_hcd
op_star
id|hcd
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|mem_flags
)paren
(brace
r_struct
id|ehci_hcd
op_star
id|ehci
op_assign
id|hcd_to_ehci
(paren
id|hcd
)paren
suffix:semicolon
r_struct
id|list_head
id|qtd_list
suffix:semicolon
id|urb-&gt;transfer_flags
op_and_assign
op_complement
id|EHCI_STATE_UNLINK
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|qtd_list
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|usb_pipetype
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
singleline_comment|// case PIPE_CONTROL:
singleline_comment|// case PIPE_BULK:
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|qh_urb_transaction
(paren
id|ehci
comma
id|urb
comma
op_amp
id|qtd_list
comma
id|mem_flags
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_return
id|submit_async
(paren
id|ehci
comma
id|urb
comma
op_amp
id|qtd_list
comma
id|mem_flags
)paren
suffix:semicolon
r_case
id|PIPE_INTERRUPT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|qh_urb_transaction
(paren
id|ehci
comma
id|urb
comma
op_amp
id|qtd_list
comma
id|mem_flags
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_return
id|intr_submit
(paren
id|ehci
comma
id|urb
comma
op_amp
id|qtd_list
comma
id|mem_flags
)paren
suffix:semicolon
r_case
id|PIPE_ISOCHRONOUS
suffix:colon
r_if
c_cond
(paren
id|urb-&gt;dev-&gt;speed
op_eq
id|USB_SPEED_HIGH
)paren
r_return
id|itd_submit
(paren
id|ehci
comma
id|urb
comma
id|mem_flags
)paren
suffix:semicolon
macro_line|#ifdef have_split_iso
r_else
r_return
id|sitd_submit
(paren
id|ehci
comma
id|urb
comma
id|mem_flags
)paren
suffix:semicolon
macro_line|#else
id|dbg
(paren
l_string|&quot;no split iso support yet&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOSYS
suffix:semicolon
macro_line|#endif /* have_split_iso */
)brace
)brace
multiline_comment|/* remove from hardware lists&n; * completions normally happen asynchronously&n; */
DECL|function|ehci_urb_dequeue
r_static
r_int
id|ehci_urb_dequeue
(paren
r_struct
id|usb_hcd
op_star
id|hcd
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|ehci_hcd
op_star
id|ehci
op_assign
id|hcd_to_ehci
(paren
id|hcd
)paren
suffix:semicolon
r_struct
id|ehci_qh
op_star
id|qh
op_assign
(paren
r_struct
id|ehci_qh
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s urb_dequeue %p qh %p state %d&quot;
comma
id|hcd_to_bus
(paren
id|hcd
)paren
op_member_access_from_pointer
id|bus_name
comma
id|urb
comma
id|qh
comma
id|qh-&gt;qh_state
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|usb_pipetype
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
singleline_comment|// case PIPE_CONTROL:
singleline_comment|// case PIPE_BULK:
r_default
suffix:colon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ehci-&gt;reclaim
)paren
(brace
id|dbg
(paren
l_string|&quot;dq %p: reclaim = %p, %s&quot;
comma
id|qh
comma
id|ehci-&gt;reclaim
comma
id|RUN_CONTEXT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qh
op_eq
id|ehci-&gt;reclaim
)paren
(brace
multiline_comment|/* unlinking qh for another queued urb? */
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|in_interrupt
(paren
)paren
)paren
(brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_while
c_loop
(paren
id|qh-&gt;qh_state
op_eq
id|QH_STATE_LINKED
op_logical_and
id|ehci-&gt;reclaim
op_logical_and
id|ehci-&gt;hcd.state
op_ne
id|USB_STATE_HALT
)paren
(brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* let pending unlinks complete */
id|wait_ms
(paren
l_int|1
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|qh-&gt;qh_state
op_eq
id|QH_STATE_LINKED
)paren
id|start_unlink_async
(paren
id|ehci
comma
id|qh
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_INTERRUPT
suffix:colon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qh-&gt;qh_state
op_eq
id|QH_STATE_LINKED
)paren
(brace
multiline_comment|/* messy, can spin or block a microframe ... */
id|intr_deschedule
(paren
id|ehci
comma
id|qh
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* qh_state == IDLE */
)brace
id|qh_completions
(paren
id|ehci
comma
id|qh
)paren
suffix:semicolon
multiline_comment|/* reschedule QH iff another request is queued */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|qh-&gt;qtd_list
)paren
op_logical_and
id|HCD_IS_RUNNING
(paren
id|ehci-&gt;hcd.state
)paren
)paren
(brace
r_int
id|status
suffix:semicolon
id|status
op_assign
id|qh_schedule
(paren
id|ehci
comma
id|qh
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
l_int|0
)paren
(brace
singleline_comment|// shouldn&squot;t happen often, but ...
singleline_comment|// FIXME kill those tds&squot; urbs
id|err
(paren
l_string|&quot;can&squot;t reschedule qh %p, err %d&quot;
comma
id|qh
comma
id|status
)paren
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_ISOCHRONOUS
suffix:colon
singleline_comment|// itd or sitd ...
singleline_comment|// wait till next completion, do it then.
singleline_comment|// completion irqs can wait up to 1024 msec,
id|urb-&gt;transfer_flags
op_or_assign
id|EHCI_STATE_UNLINK
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
singleline_comment|// bulk qh holds the data toggle
DECL|function|ehci_free_config
r_static
r_void
id|ehci_free_config
(paren
r_struct
id|usb_hcd
op_star
id|hcd
comma
r_struct
id|usb_device
op_star
id|udev
)paren
(brace
r_struct
id|hcd_dev
op_star
id|dev
op_assign
(paren
r_struct
id|hcd_dev
op_star
)paren
id|udev-&gt;hcpriv
suffix:semicolon
r_struct
id|ehci_hcd
op_star
id|ehci
op_assign
id|hcd_to_ehci
(paren
id|hcd
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* ASSERT:  no requests/urbs are still linked (so no TDs) */
multiline_comment|/* ASSERT:  nobody can be submitting urbs for this any more */
id|dbg
(paren
l_string|&quot;%s: free_config devnum %d&quot;
comma
id|hcd_to_bus
(paren
id|hcd
)paren
op_member_access_from_pointer
id|bus_name
comma
id|udev-&gt;devnum
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;ep
(braket
id|i
)braket
)paren
(brace
r_struct
id|ehci_qh
op_star
id|qh
suffix:semicolon
r_char
op_star
id|why
suffix:semicolon
multiline_comment|/* dev-&gt;ep never has ITDs or SITDs */
id|qh
op_assign
(paren
r_struct
id|ehci_qh
op_star
)paren
id|dev-&gt;ep
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* detect/report non-recoverable errors */
r_if
c_cond
(paren
id|in_interrupt
(paren
)paren
)paren
id|why
op_assign
l_string|&quot;disconnect() didn&squot;t&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|qh-&gt;hw_info2
op_amp
id|cpu_to_le32
(paren
l_int|0xffff
)paren
)paren
op_ne
l_int|0
op_logical_and
id|qh-&gt;qh_state
op_ne
id|QH_STATE_IDLE
)paren
id|why
op_assign
l_string|&quot;(active periodic)&quot;
suffix:semicolon
r_else
id|why
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|why
)paren
(brace
id|err
(paren
l_string|&quot;dev %s-%s ep %d-%s error: %s&quot;
comma
id|hcd_to_bus
(paren
id|hcd
)paren
op_member_access_from_pointer
id|bus_name
comma
id|udev-&gt;devpath
comma
id|i
op_amp
l_int|0xf
comma
(paren
id|i
op_amp
l_int|0x10
)paren
ques
c_cond
l_string|&quot;IN&quot;
suffix:colon
l_string|&quot;OUT&quot;
comma
id|why
)paren
suffix:semicolon
id|BUG
(paren
)paren
suffix:semicolon
)brace
id|dev-&gt;ep
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|qh-&gt;qh_state
op_eq
id|QH_STATE_IDLE
)paren
r_goto
id|idle
suffix:semicolon
id|dbg
(paren
l_string|&quot;free_config, async ep 0x%02x qh %p&quot;
comma
id|i
comma
id|qh
)paren
suffix:semicolon
multiline_comment|/* scan_async() empties the ring as it does its work,&n;&t;&t;&t; * using IAA, but doesn&squot;t (yet?) turn it off.  if it&n;&t;&t;&t; * doesn&squot;t empty this qh, likely it&squot;s the last entry.&n;&t;&t;&t; */
r_while
c_loop
(paren
id|qh-&gt;qh_state
op_eq
id|QH_STATE_LINKED
op_logical_and
id|ehci-&gt;reclaim
op_logical_and
id|ehci-&gt;hcd.state
op_ne
id|USB_STATE_HALT
)paren
(brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* wait_ms() won&squot;t spin, we&squot;re a thread;&n;&t;&t;&t;&t; * and we know IRQ+tasklet can progress&n;&t;&t;&t;&t; */
id|wait_ms
(paren
l_int|1
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|qh-&gt;qh_state
op_eq
id|QH_STATE_LINKED
)paren
id|start_unlink_async
(paren
id|ehci
comma
id|qh
)paren
suffix:semicolon
r_while
c_loop
(paren
id|qh-&gt;qh_state
op_ne
id|QH_STATE_IDLE
op_logical_and
id|ehci-&gt;hcd.state
op_ne
id|USB_STATE_HALT
)paren
(brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|wait_ms
(paren
l_int|1
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|idle
suffix:colon
id|qh_put
(paren
id|ehci
comma
id|qh
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|variable|ehci_driver
r_static
r_const
r_struct
id|hc_driver
id|ehci_driver
op_assign
(brace
dot
id|description
op_assign
id|hcd_name
comma
multiline_comment|/*&n;&t; * generic hardware linkage&n;&t; */
dot
id|irq
op_assign
id|ehci_irq
comma
dot
id|flags
op_assign
id|HCD_MEMORY
op_or
id|HCD_USB2
comma
multiline_comment|/*&n;&t; * basic lifecycle operations&n;&t; */
dot
id|start
op_assign
id|ehci_start
comma
macro_line|#ifdef&t;CONFIG_PM
dot
id|suspend
op_assign
id|ehci_suspend
comma
dot
id|resume
op_assign
id|ehci_resume
comma
macro_line|#endif
dot
id|stop
op_assign
id|ehci_stop
comma
multiline_comment|/*&n;&t; * memory lifecycle (except per-request)&n;&t; */
dot
id|hcd_alloc
op_assign
id|ehci_hcd_alloc
comma
dot
id|hcd_free
op_assign
id|ehci_hcd_free
comma
multiline_comment|/*&n;&t; * managing i/o requests and associated device resources&n;&t; */
dot
id|urb_enqueue
op_assign
id|ehci_urb_enqueue
comma
dot
id|urb_dequeue
op_assign
id|ehci_urb_dequeue
comma
dot
id|free_config
op_assign
id|ehci_free_config
comma
multiline_comment|/*&n;&t; * scheduling support&n;&t; */
dot
id|get_frame_number
op_assign
id|ehci_get_frame
comma
multiline_comment|/*&n;&t; * root hub support&n;&t; */
dot
id|hub_status_data
op_assign
id|ehci_hub_status_data
comma
dot
id|hub_control
op_assign
id|ehci_hub_control
comma
)brace
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* EHCI spec says PCI is required. */
multiline_comment|/* PCI driver selection metadata; PCI hotplugging uses this */
DECL|variable|pci_ids
r_static
r_const
r_struct
id|pci_device_id
id|__devinitdata
id|pci_ids
(braket
)braket
op_assign
(brace
(brace
multiline_comment|/* handle any USB 2.0 EHCI controller */
dot
r_class
op_assign
(paren
(paren
id|PCI_CLASS_SERIAL_USB
op_lshift
l_int|8
)paren
op_or
l_int|0x20
)paren
comma
dot
id|class_mask
op_assign
op_complement
l_int|0
comma
dot
id|driver_data
op_assign
(paren
r_int
r_int
)paren
op_amp
id|ehci_driver
comma
multiline_comment|/* no matter who makes it */
dot
id|vendor
op_assign
id|PCI_ANY_ID
comma
dot
id|device
op_assign
id|PCI_ANY_ID
comma
dot
id|subvendor
op_assign
id|PCI_ANY_ID
comma
dot
id|subdevice
op_assign
id|PCI_ANY_ID
comma
)brace
comma
(brace
multiline_comment|/* end: all zeroes */
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
(paren
id|pci
comma
id|pci_ids
)paren
suffix:semicolon
multiline_comment|/* pci driver glue; this is a &quot;new style&quot; PCI driver module */
DECL|variable|ehci_pci_driver
r_static
r_struct
id|pci_driver
id|ehci_pci_driver
op_assign
(brace
dot
id|name
op_assign
(paren
r_char
op_star
)paren
id|hcd_name
comma
dot
id|id_table
op_assign
id|pci_ids
comma
dot
id|probe
op_assign
id|usb_hcd_pci_probe
comma
dot
id|remove
op_assign
id|usb_hcd_pci_remove
comma
macro_line|#ifdef&t;CONFIG_PM
dot
id|suspend
op_assign
id|usb_hcd_pci_suspend
comma
dot
id|resume
op_assign
id|usb_hcd_pci_resume
comma
macro_line|#endif
)brace
suffix:semicolon
DECL|macro|DRIVER_INFO
mdefine_line|#define DRIVER_INFO DRIVER_VERSION &quot; &quot; DRIVER_DESC
DECL|variable|DRIVER_INFO
id|MODULE_DESCRIPTION
(paren
id|DRIVER_INFO
)paren
suffix:semicolon
DECL|variable|DRIVER_AUTHOR
id|MODULE_AUTHOR
(paren
id|DRIVER_AUTHOR
)paren
suffix:semicolon
id|MODULE_LICENSE
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|function|init
r_static
r_int
id|__init
id|init
(paren
r_void
)paren
(brace
id|dbg
(paren
id|DRIVER_INFO
)paren
suffix:semicolon
id|dbg
(paren
l_string|&quot;block sizes: qh %Zd qtd %Zd itd %Zd sitd %Zd&quot;
comma
r_sizeof
(paren
r_struct
id|ehci_qh
)paren
comma
r_sizeof
(paren
r_struct
id|ehci_qtd
)paren
comma
r_sizeof
(paren
r_struct
id|ehci_itd
)paren
comma
r_sizeof
(paren
r_struct
id|ehci_sitd
)paren
)paren
suffix:semicolon
r_return
id|pci_module_init
(paren
op_amp
id|ehci_pci_driver
)paren
suffix:semicolon
)brace
DECL|variable|init
id|module_init
(paren
id|init
)paren
suffix:semicolon
DECL|function|cleanup
r_static
r_void
id|__exit
id|cleanup
(paren
r_void
)paren
(brace
id|pci_unregister_driver
(paren
op_amp
id|ehci_pci_driver
)paren
suffix:semicolon
)brace
DECL|variable|cleanup
id|module_exit
(paren
id|cleanup
)paren
suffix:semicolon
eof
