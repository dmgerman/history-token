multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*-------------------------------------------------------------------------*&n; * simple generic USB HCD frontend Version 0.9.5 (10/28/2001)&n; * for embedded HCs (SL811HS)&n; * &n; * USB URB handling, hci_ hcs_&n; * URB queueing, qu_&n; * Transfer scheduling, sh_&n; * &n; *&n; *-------------------------------------------------------------------------*&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA&n; *&n; *-------------------------------------------------------------------------*/
multiline_comment|/* main lock for urb access */
DECL|variable|usb_urb_lock
r_static
id|spinlock_t
id|usb_urb_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* URB HCD API function layer&n; * * * */
multiline_comment|/***************************************************************************&n; * Function Name : hcs_urb_queue&n; *&n; * This function initializes the urb status and length before queueing the &n; * urb. &n; *&n; * Input:  hci = data structure for the host controller&n; *         urb = USB request block data structure &n; *&n; * Return: 0 &n; **************************************************************************/
DECL|function|hcs_urb_queue
r_static
r_inline
r_int
id|hcs_urb_queue
(paren
id|hci_t
op_star
id|hci
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
id|i
suffix:semicolon
id|DBGFUNC
(paren
l_string|&quot;enter hcs_urb_queue&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipeisoc
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
id|DBGVERBOSE
(paren
l_string|&quot;hcs_urb_queue: isoc pipe&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|i
op_increment
)paren
(brace
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|actual_length
op_assign
l_int|0
suffix:semicolon
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|status
op_assign
op_minus
id|EXDEV
suffix:semicolon
)brace
multiline_comment|/* urb-&gt;next hack : 1 .. resub, 0 .. single shot */
multiline_comment|/* urb-&gt;interval = urb-&gt;next ? 1 : 0; */
)brace
id|urb-&gt;status
op_assign
op_minus
id|EINPROGRESS
suffix:semicolon
id|urb-&gt;actual_length
op_assign
l_int|0
suffix:semicolon
id|urb-&gt;error_count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipecontrol
(paren
id|urb-&gt;pipe
)paren
)paren
id|hc_flush_data_cache
(paren
id|hci
comma
id|urb-&gt;setup_packet
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
)paren
id|hc_flush_data_cache
(paren
id|hci
comma
id|urb-&gt;transfer_buffer
comma
id|urb-&gt;transfer_buffer_length
)paren
suffix:semicolon
id|qu_queue_urb
(paren
id|hci
comma
id|urb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/***************************************************************************&n; * Function Name : hcs_return_urb&n; *&n; * This function the return path of URB back to the USB core. It calls the&n; * the urb complete function if exist, and also handles the resubmition of&n; * interrupt URBs.&n; *&n; * Input:  hci = data structure for the host controller&n; *         urb = USB request block data structure &n; *         resub_ok = resubmit flag: 1 = submit urb again, 0 = not submit &n; *&n; * Return: 0 &n; **************************************************************************/
DECL|function|hcs_return_urb
r_static
r_int
id|hcs_return_urb
(paren
id|hci_t
op_star
id|hci
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|resub_ok
)paren
(brace
r_struct
id|usb_device
op_star
id|dev
op_assign
id|urb-&gt;dev
suffix:semicolon
r_int
id|resubmit
op_assign
l_int|0
suffix:semicolon
id|DBGFUNC
(paren
l_string|&quot;enter hcs_return_urb, urb pointer = 0x%x, &quot;
l_string|&quot;transferbuffer point = 0x%x, &quot;
l_string|&quot; setup packet pointer = 0x%x, context pointer = 0x%x &bslash;n&quot;
comma
(paren
id|__u32
op_star
)paren
id|urb
comma
(paren
id|__u32
op_star
)paren
id|urb-&gt;transfer_buffer
comma
(paren
id|__u32
op_star
)paren
id|urb-&gt;setup_packet
comma
(paren
id|__u32
op_star
)paren
id|urb-&gt;context
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb_debug
)paren
id|urb_print
(paren
id|urb
comma
l_string|&quot;RET&quot;
comma
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
id|resubmit
op_assign
id|urb-&gt;interval
op_logical_and
id|resub_ok
suffix:semicolon
id|urb-&gt;dev
op_assign
id|urb-&gt;hcpriv
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;complete
)paren
(brace
id|urb-&gt;complete
(paren
id|urb
)paren
suffix:semicolon
multiline_comment|/* call complete */
)brace
r_if
c_cond
(paren
id|resubmit
)paren
(brace
multiline_comment|/* requeue the URB */
id|urb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|hcs_urb_queue
(paren
id|hci
comma
id|urb
)paren
suffix:semicolon
)brace
r_else
(brace
id|usb_put_urb
c_func
(paren
id|urb
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/***************************************************************************&n; * Function Name : hci_submit_urb&n; *&n; * This function is called by the USB core API when an URB is available to&n; * process.  This function does the following&n; *&n; * 1) Check the validity of the URB&n; * 2) Parse the device number from the URB&n; * 3) Pass the URB to the root hub routine if its intended for the hub, else&n; *    queue the urb for the attached device. &n; *&n; * Input: urb = USB request block data structure &n; *&n; * Return: 0 if success or error code &n; **************************************************************************/
DECL|function|hci_submit_urb
r_static
r_int
id|hci_submit_urb
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|mem_flags
)paren
(brace
id|hci_t
op_star
id|hci
suffix:semicolon
r_int
r_int
id|pipe
op_assign
id|urb-&gt;pipe
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|DBGFUNC
(paren
l_string|&quot;enter hci_submit_urb, pipe = 0x%x&bslash;n&quot;
comma
id|urb-&gt;pipe
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb-&gt;dev
op_logical_or
op_logical_neg
id|urb-&gt;dev-&gt;bus
op_logical_or
id|urb-&gt;hcpriv
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|usb_endpoint_halted
(paren
id|urb-&gt;dev
comma
id|usb_pipeendpoint
(paren
id|pipe
)paren
comma
id|usb_pipeout
(paren
id|pipe
)paren
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;hci_submit_urb: endpoint_halted&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EPIPE
suffix:semicolon
)brace
id|hci
op_assign
(paren
id|hci_t
op_star
)paren
id|urb-&gt;dev-&gt;bus-&gt;hcpriv
suffix:semicolon
multiline_comment|/* a request to the virtual root hub */
r_if
c_cond
(paren
id|usb_pipedevice
(paren
id|pipe
)paren
op_eq
id|hci-&gt;rh.devnum
)paren
(brace
r_if
c_cond
(paren
id|urb_debug
OG
l_int|1
)paren
id|urb_print
(paren
id|urb
comma
l_string|&quot;SUB-RH&quot;
comma
id|usb_pipein
(paren
id|pipe
)paren
)paren
suffix:semicolon
r_return
id|rh_submit_urb
(paren
id|urb
)paren
suffix:semicolon
)brace
multiline_comment|/* increment urb&squot;s reference count, we now control it. */
id|urb
op_assign
id|usb_get_urb
(paren
id|urb
)paren
suffix:semicolon
multiline_comment|/* queue the URB to its endpoint-queue */
id|spin_lock_irqsave
(paren
op_amp
id|usb_urb_lock
comma
id|flags
)paren
suffix:semicolon
id|ret
op_assign
id|hcs_urb_queue
(paren
id|hci
comma
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
multiline_comment|/* error on return */
id|DBGERR
(paren
l_string|&quot;hci_submit_urb: return err, ret = 0x%x, urb-&gt;status = 0x%x&bslash;n&quot;
comma
id|ret
comma
id|urb-&gt;status
)paren
suffix:semicolon
id|usb_put_urb
(paren
id|urb
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|usb_urb_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/***************************************************************************&n; * Function Name : hci_unlink_urb&n; *&n; * This function mark the URB to unlink&n; *&n; * Input: urb = USB request block data structure &n; *&n; * Return: 0 if success or error code &n; **************************************************************************/
DECL|function|hci_unlink_urb
r_static
r_int
id|hci_unlink_urb
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|hci_t
op_star
id|hci
suffix:semicolon
id|DECLARE_WAITQUEUE
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_void
op_star
id|comp
op_assign
l_int|NULL
suffix:semicolon
id|DBGFUNC
(paren
l_string|&quot;enter hci_unlink_urb&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
multiline_comment|/* just to be sure */
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb-&gt;dev
op_logical_or
op_logical_neg
id|urb-&gt;dev-&gt;bus
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|hci
op_assign
(paren
id|hci_t
op_star
)paren
id|urb-&gt;dev-&gt;bus-&gt;hcpriv
suffix:semicolon
multiline_comment|/* a request to the virtual root hub */
r_if
c_cond
(paren
id|usb_pipedevice
(paren
id|urb-&gt;pipe
)paren
op_eq
id|hci-&gt;rh.devnum
)paren
(brace
r_return
id|rh_unlink_urb
(paren
id|urb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|urb_debug
)paren
id|urb_print
(paren
id|urb
comma
l_string|&quot;UNLINK&quot;
comma
l_int|1
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|usb_urb_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|urb-&gt;urb_list
)paren
op_logical_and
id|urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
(brace
multiline_comment|/* URB active? */
r_if
c_cond
(paren
id|urb-&gt;transfer_flags
op_amp
(paren
id|USB_ASYNC_UNLINK
op_or
id|USB_TIMEOUT_KILLED
)paren
)paren
(brace
multiline_comment|/* asynchronous with callback */
multiline_comment|/* relink the urb to the del list */
id|list_move
(paren
op_amp
id|urb-&gt;urb_list
comma
op_amp
id|hci-&gt;del_list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|usb_urb_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* synchronous without callback */
id|add_wait_queue
(paren
op_amp
id|hci-&gt;waitq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|comp
op_assign
id|urb-&gt;complete
suffix:semicolon
id|urb-&gt;complete
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* relink the urb to the del list */
id|list_move
c_func
(paren
op_amp
id|urb-&gt;urb_list
comma
op_amp
id|hci-&gt;del_list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|usb_urb_lock
comma
id|flags
)paren
suffix:semicolon
id|schedule_timeout
(paren
id|HZ
op_div
l_int|50
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|urb-&gt;urb_list
)paren
)paren
id|list_del
(paren
op_amp
id|urb-&gt;urb_list
)paren
suffix:semicolon
id|urb-&gt;complete
op_assign
id|comp
suffix:semicolon
id|urb-&gt;hcpriv
op_assign
l_int|NULL
suffix:semicolon
id|remove_wait_queue
(paren
op_amp
id|hci-&gt;waitq
comma
op_amp
id|wait
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* hcd does not own URB but we keep the driver happy anyway */
id|spin_unlock_irqrestore
(paren
op_amp
id|usb_urb_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;complete
op_logical_and
(paren
id|urb-&gt;transfer_flags
op_amp
id|USB_ASYNC_UNLINK
)paren
)paren
(brace
id|urb-&gt;status
op_assign
op_minus
id|ENOENT
suffix:semicolon
id|urb-&gt;actual_length
op_assign
l_int|0
suffix:semicolon
id|urb-&gt;complete
(paren
id|urb
)paren
suffix:semicolon
id|urb-&gt;status
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|urb-&gt;status
op_assign
op_minus
id|ENOENT
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/***************************************************************************&n; * Function Name : hci_alloc_dev&n; *&n; * This function allocates private data space for the usb device and &n; * initialize the endpoint descriptor heads.&n; *&n; * Input: usb_dev = pointer to the usb device &n; *&n; * Return: 0 if success or error code &n; **************************************************************************/
DECL|function|hci_alloc_dev
r_static
r_int
id|hci_alloc_dev
(paren
r_struct
id|usb_device
op_star
id|usb_dev
)paren
(brace
r_struct
id|hci_device
op_star
id|dev
suffix:semicolon
r_int
id|i
suffix:semicolon
id|DBGFUNC
(paren
l_string|&quot;enter hci_alloc_dev&bslash;n&quot;
)paren
suffix:semicolon
id|dev
op_assign
id|kmalloc
(paren
r_sizeof
(paren
op_star
id|dev
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
(paren
id|dev
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|dev
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
id|INIT_LIST_HEAD
(paren
op_amp
(paren
id|dev-&gt;ed
(braket
id|i
)braket
dot
id|urb_queue
)paren
)paren
suffix:semicolon
id|dev-&gt;ed
(braket
id|i
)braket
dot
id|pipe_head
op_assign
l_int|NULL
suffix:semicolon
)brace
id|usb_dev-&gt;hcpriv
op_assign
id|dev
suffix:semicolon
id|DBGVERBOSE
(paren
l_string|&quot;USB HC dev alloc %d bytes&bslash;n&quot;
comma
r_sizeof
(paren
op_star
id|dev
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/***************************************************************************&n; * Function Name : hci_free_dev&n; *&n; * This function de-allocates private data space for the usb devic&n; *&n; * Input: usb_dev = pointer to the usb device &n; *&n; * Return: 0  &n; **************************************************************************/
DECL|function|hci_free_dev
r_static
r_int
id|hci_free_dev
(paren
r_struct
id|usb_device
op_star
id|usb_dev
)paren
(brace
id|DBGFUNC
(paren
l_string|&quot;enter hci_free_dev&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_dev-&gt;hcpriv
)paren
id|kfree
(paren
id|usb_dev-&gt;hcpriv
)paren
suffix:semicolon
id|usb_dev-&gt;hcpriv
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/***************************************************************************&n; * Function Name : hci_get_current_frame_number&n; *&n; * This function get the current USB frame number&n; *&n; * Input: usb_dev = pointer to the usb device &n; *&n; * Return: frame number  &n; **************************************************************************/
DECL|function|hci_get_current_frame_number
r_static
r_int
id|hci_get_current_frame_number
(paren
r_struct
id|usb_device
op_star
id|usb_dev
)paren
(brace
id|hci_t
op_star
id|hci
op_assign
id|usb_dev-&gt;bus-&gt;hcpriv
suffix:semicolon
id|DBGFUNC
(paren
l_string|&quot;enter hci_get_current_frame_number, frame = 0x%x &bslash;r&bslash;n&quot;
comma
id|hci-&gt;frame_number
)paren
suffix:semicolon
r_return
(paren
id|hci-&gt;frame_number
)paren
suffix:semicolon
)brace
multiline_comment|/***************************************************************************&n; * List of all io-functions &n; **************************************************************************/
DECL|variable|hci_device_operations
r_static
r_struct
id|usb_operations
id|hci_device_operations
op_assign
(brace
id|allocate
suffix:colon
id|hci_alloc_dev
comma
id|deallocate
suffix:colon
id|hci_free_dev
comma
id|get_frame_number
suffix:colon
id|hci_get_current_frame_number
comma
id|submit_urb
suffix:colon
id|hci_submit_urb
comma
id|unlink_urb
suffix:colon
id|hci_unlink_urb
comma
)brace
suffix:semicolon
multiline_comment|/***************************************************************************&n; * URB queueing:&n; * &n; * For each type of transfer (INTR, BULK, ISO, CTRL) there is a list of &n; * active URBs.&n; * (hci-&gt;intr_list, hci-&gt;bulk_list, hci-&gt;iso_list, hci-&gt;ctrl_list)&n; * For every endpoint the head URB of the queued URBs is linked to one of &n; * those lists.&n; * &n; * The rest of the queued URBs of an endpoint are linked into a &n; * private URB list for each endpoint. (hci_dev-&gt;ed [endpoint_io].urb_queue)&n; * hci_dev-&gt;ed [endpoint_io].pipe_head .. points to the head URB which is &n; * in one of the active URB lists.&n; * &n; * The index of an endpoint consists of its number and its direction.&n; * &n; * The state of an intr and iso URB is 0. &n; * For ctrl URBs the states are US_CTRL_SETUP, US_CTRL_DATA, US_CTRL_ACK&n; * Bulk URBs states are US_BULK and US_BULK0 (with 0-len packet)&n; * &n; **************************************************************************/
multiline_comment|/***************************************************************************&n; * Function Name : qu_urb_timeout&n; *&n; * This function is called when the URB timeout. The function unlinks the &n; * URB. &n; *&n; * Input: lurb: URB &n; *&n; * Return: none  &n; **************************************************************************/
macro_line|#ifdef HC_URB_TIMEOUT
DECL|function|qu_urb_timeout
r_static
r_void
id|qu_urb_timeout
(paren
r_int
r_int
id|lurb
)paren
(brace
r_struct
id|urb
op_star
id|urb
op_assign
(paren
r_struct
id|urb
op_star
)paren
id|lurb
suffix:semicolon
id|DBGFUNC
(paren
l_string|&quot;enter qu_urb_timeout&bslash;n&quot;
)paren
suffix:semicolon
id|urb-&gt;transfer_flags
op_or_assign
id|USB_TIMEOUT_KILLED
suffix:semicolon
id|hci_unlink_urb
(paren
id|urb
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/***************************************************************************&n; * Function Name : qu_pipeindex&n; *&n; * This function gets the index of the pipe.   &n; *&n; * Input: pipe: the urb pipe &n; *&n; * Return: index  &n; **************************************************************************/
DECL|function|qu_pipeindex
r_static
r_inline
r_int
id|qu_pipeindex
(paren
id|__u32
id|pipe
)paren
(brace
id|DBGFUNC
(paren
l_string|&quot;enter qu_pipeindex&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
id|usb_pipeendpoint
(paren
id|pipe
)paren
op_lshift
l_int|1
)paren
op_or
(paren
id|usb_pipecontrol
(paren
id|pipe
)paren
ques
c_cond
l_int|0
suffix:colon
id|usb_pipeout
(paren
id|pipe
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/***************************************************************************&n; * Function Name : qu_seturbstate&n; *&n; * This function set the state of the URB.  &n; * &n; * control pipe: 3 states -- Setup, data, status&n; * interrupt and bulk pipe: 1 state -- data    &n; *&n; * Input: urb = USB request block data structure &n; *        state = the urb state&n; *&n; * Return: none  &n; **************************************************************************/
DECL|function|qu_seturbstate
r_static
r_inline
r_void
id|qu_seturbstate
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|state
)paren
(brace
id|DBGFUNC
(paren
l_string|&quot;enter qu_seturbstate&bslash;n&quot;
)paren
suffix:semicolon
id|urb-&gt;pipe
op_and_assign
op_complement
l_int|0x1f
suffix:semicolon
id|urb-&gt;pipe
op_or_assign
id|state
op_amp
l_int|0x1f
suffix:semicolon
)brace
multiline_comment|/***************************************************************************&n; * Function Name : qu_urbstate&n; *&n; * This function get the current state of the URB.  &n; * &n; * Input: urb = USB request block data structure &n; *&n; * Return: none  &n; **************************************************************************/
DECL|function|qu_urbstate
r_static
r_inline
r_int
id|qu_urbstate
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
id|DBGFUNC
(paren
l_string|&quot;enter qu_urbstate&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|urb-&gt;pipe
op_amp
l_int|0x1f
suffix:semicolon
)brace
multiline_comment|/***************************************************************************&n; * Function Name : qu_queue_active_urb&n; *&n; * This function adds the urb to the appropriate active urb list and set&n; * the urb state.&n; * &n; * There are four active lists: isochoronous list, interrupt list, &n; * control list, and bulk list.&n; * &n; * Input: hci = data structure for the host controller &n; *        urb = USB request block data structure &n; *        ed = endpoint descriptor&n; *&n; * Return: none  &n; **************************************************************************/
DECL|function|qu_queue_active_urb
r_static
r_inline
r_void
id|qu_queue_active_urb
(paren
id|hci_t
op_star
id|hci
comma
r_struct
id|urb
op_star
id|urb
comma
id|epd_t
op_star
id|ed
)paren
(brace
r_int
id|urb_state
op_assign
l_int|0
suffix:semicolon
id|DBGFUNC
(paren
l_string|&quot;enter qu_queue_active_urb&bslash;n&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|usb_pipetype
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
r_case
id|PIPE_CONTROL
suffix:colon
id|list_add
(paren
op_amp
id|urb-&gt;urb_list
comma
op_amp
id|hci-&gt;ctrl_list
)paren
suffix:semicolon
id|urb_state
op_assign
id|US_CTRL_SETUP
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_BULK
suffix:colon
id|list_add
(paren
op_amp
id|urb-&gt;urb_list
comma
op_amp
id|hci-&gt;bulk_list
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|urb-&gt;transfer_flags
op_amp
id|USB_ZERO_PACKET
)paren
op_logical_and
id|urb-&gt;transfer_buffer_length
OG
l_int|0
op_logical_and
(paren
(paren
id|urb-&gt;transfer_buffer_length
op_mod
id|usb_maxpacket
(paren
id|urb-&gt;dev
comma
id|urb-&gt;pipe
comma
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
)paren
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|urb_state
op_assign
id|US_BULK0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|PIPE_INTERRUPT
suffix:colon
id|urb-&gt;start_frame
op_assign
id|hci-&gt;frame_number
suffix:semicolon
id|list_add
(paren
op_amp
id|urb-&gt;urb_list
comma
op_amp
id|hci-&gt;intr_list
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_ISOCHRONOUS
suffix:colon
id|list_add
(paren
op_amp
id|urb-&gt;urb_list
comma
op_amp
id|hci-&gt;iso_list
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef HC_URB_TIMEOUT
r_if
c_cond
(paren
id|urb-&gt;timeout
)paren
(brace
id|ed-&gt;timeout.data
op_assign
(paren
r_int
r_int
)paren
id|urb
suffix:semicolon
id|ed-&gt;timeout.expires
op_assign
id|urb-&gt;timeout
op_plus
id|jiffies
suffix:semicolon
id|ed-&gt;timeout.function
op_assign
id|qu_urb_timeout
suffix:semicolon
id|add_timer
(paren
op_amp
id|ed-&gt;timeout
)paren
suffix:semicolon
)brace
macro_line|#endif
id|qu_seturbstate
(paren
id|urb
comma
id|urb_state
)paren
suffix:semicolon
)brace
multiline_comment|/***************************************************************************&n; * Function Name : qu_queue_urb&n; *&n; * This function adds the urb to the endpoint descriptor list &n; * &n; * Input: hci = data structure for the host controller &n; *        urb = USB request block data structure &n; *&n; * Return: none  &n; **************************************************************************/
DECL|function|qu_queue_urb
r_static
r_int
id|qu_queue_urb
(paren
id|hci_t
op_star
id|hci
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|hci_device
op_star
id|hci_dev
op_assign
id|usb_to_hci
(paren
id|urb-&gt;dev
)paren
suffix:semicolon
id|epd_t
op_star
id|ed
op_assign
op_amp
id|hci_dev-&gt;ed
(braket
id|qu_pipeindex
(paren
id|urb-&gt;pipe
)paren
)braket
suffix:semicolon
id|DBGFUNC
(paren
l_string|&quot;Enter qu_queue_urb&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* for ISOC transfers calculate start frame index */
r_if
c_cond
(paren
id|usb_pipeisoc
(paren
id|urb-&gt;pipe
)paren
op_logical_and
id|urb-&gt;transfer_flags
op_amp
id|USB_ISO_ASAP
)paren
(brace
id|urb-&gt;start_frame
op_assign
(paren
(paren
id|ed-&gt;pipe_head
)paren
ques
c_cond
(paren
id|ed-&gt;last_iso
op_plus
l_int|1
)paren
suffix:colon
id|hci_get_current_frame_number
(paren
id|urb
op_member_access_from_pointer
id|dev
)paren
op_plus
l_int|1
)paren
op_amp
l_int|0xffff
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ed-&gt;pipe_head
)paren
(brace
id|__list_add
(paren
op_amp
id|urb-&gt;urb_list
comma
id|ed-&gt;urb_queue.prev
comma
op_amp
(paren
id|ed-&gt;urb_queue
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|ed-&gt;pipe_head
op_assign
id|urb
suffix:semicolon
id|qu_queue_active_urb
(paren
id|hci
comma
id|urb
comma
id|ed
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|hci-&gt;active_urbs
op_eq
l_int|1
)paren
id|hc_start_int
(paren
id|hci
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/***************************************************************************&n; * Function Name : qu_next_urb&n; *&n; * This function removes the URB from the queue and add the next URB to &n; * active list. &n; * &n; * Input: hci = data structure for the host controller &n; *        urb = USB request block data structure &n; *        resub_ok = resubmit flag&n; *&n; * Return: pointer to the next urb  &n; **************************************************************************/
DECL|function|qu_next_urb
r_static
r_struct
id|urb
op_star
id|qu_next_urb
(paren
id|hci_t
op_star
id|hci
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|resub_ok
)paren
(brace
r_struct
id|hci_device
op_star
id|hci_dev
op_assign
id|usb_to_hci
(paren
id|urb-&gt;dev
)paren
suffix:semicolon
id|epd_t
op_star
id|ed
op_assign
op_amp
id|hci_dev-&gt;ed
(braket
id|qu_pipeindex
(paren
id|urb-&gt;pipe
)paren
)braket
suffix:semicolon
id|DBGFUNC
(paren
l_string|&quot;enter qu_next_urb&bslash;n&quot;
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|urb-&gt;urb_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ed-&gt;pipe_head
op_eq
id|urb
)paren
(brace
macro_line|#ifdef HC_URB_TIMEOUT
r_if
c_cond
(paren
id|urb-&gt;timeout
)paren
id|del_timer
(paren
op_amp
id|ed-&gt;timeout
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|hci-&gt;active_urbs
)paren
id|hc_stop_int
(paren
id|hci
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|ed-&gt;urb_queue
)paren
)paren
(brace
id|urb
op_assign
id|list_entry
(paren
id|ed-&gt;urb_queue.next
comma
r_struct
id|urb
comma
id|urb_list
)paren
suffix:semicolon
id|list_del_init
(paren
op_amp
id|urb-&gt;urb_list
)paren
suffix:semicolon
id|ed-&gt;pipe_head
op_assign
id|urb
suffix:semicolon
id|qu_queue_active_urb
(paren
id|hci
comma
id|urb
comma
id|ed
)paren
suffix:semicolon
)brace
r_else
(brace
id|ed-&gt;pipe_head
op_assign
l_int|NULL
suffix:semicolon
id|urb
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
id|urb
suffix:semicolon
)brace
multiline_comment|/***************************************************************************&n; * Function Name : qu_return_urb&n; *&n; * This function is part of the return path.   &n; * &n; * Input: hci = data structure for the host controller &n; *        urb = USB request block data structure &n; *        resub_ok = resubmit flag&n; *&n; * Return: pointer to the next urb  &n; **************************************************************************/
DECL|function|qu_return_urb
r_static
r_struct
id|urb
op_star
id|qu_return_urb
(paren
id|hci_t
op_star
id|hci
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|resub_ok
)paren
(brace
r_struct
id|urb
op_star
id|next_urb
suffix:semicolon
id|DBGFUNC
(paren
l_string|&quot;enter qu_return_rub&bslash;n&quot;
)paren
suffix:semicolon
id|next_urb
op_assign
id|qu_next_urb
(paren
id|hci
comma
id|urb
comma
id|resub_ok
)paren
suffix:semicolon
id|hcs_return_urb
(paren
id|hci
comma
id|urb
comma
id|resub_ok
)paren
suffix:semicolon
r_return
id|next_urb
suffix:semicolon
)brace
multiline_comment|/***************************************************************************&n; * Function Name : sh_scan_iso_urb_list&n; *&n; * This function goes throught the isochronous urb list and schedule the &n; * the transfer.   &n; *&n; * Note: This function has not tested yet&n; * &n; * Input: hci = data structure for the host controller &n; *        list_lh = pointer to the isochronous list &n; *        frame_number = the frame number &n; *&n; * Return: 0 = unsuccessful; 1 = successful  &n; **************************************************************************/
DECL|function|sh_scan_iso_urb_list
r_static
r_int
id|sh_scan_iso_urb_list
(paren
id|hci_t
op_star
id|hci
comma
r_struct
id|list_head
op_star
id|list_lh
comma
r_int
id|frame_number
)paren
(brace
r_struct
id|list_head
op_star
id|lh
op_assign
id|list_lh-&gt;next
suffix:semicolon
r_struct
id|urb
op_star
id|urb
suffix:semicolon
id|DBGFUNC
(paren
l_string|&quot;enter sh_scan_iso_urb_list&bslash;n&quot;
)paren
suffix:semicolon
id|hci-&gt;td_array-&gt;len
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|lh
op_ne
id|list_lh
)paren
(brace
id|urb
op_assign
id|list_entry
(paren
id|lh
comma
r_struct
id|urb
comma
id|urb_list
)paren
suffix:semicolon
id|lh
op_assign
id|lh-&gt;next
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|frame_number
op_minus
id|urb-&gt;start_frame
)paren
op_amp
l_int|0x7ff
)paren
OL
id|urb-&gt;number_of_packets
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sh_add_packet
(paren
id|hci
comma
id|urb
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
(paren
id|frame_number
op_minus
id|urb-&gt;start_frame
)paren
op_amp
l_int|0x7ff
)paren
OG
l_int|0x400
)paren
(brace
r_if
c_cond
(paren
id|qu_urbstate
(paren
id|urb
)paren
OG
l_int|0
)paren
id|urb
op_assign
id|qu_return_urb
(paren
id|hci
comma
id|urb
comma
l_int|1
)paren
suffix:semicolon
r_else
id|urb
op_assign
id|qu_next_urb
(paren
id|hci
comma
id|urb
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lh
op_eq
id|list_lh
op_logical_and
id|urb
)paren
id|lh
op_assign
op_amp
id|urb-&gt;urb_list
suffix:semicolon
)brace
)brace
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/***************************************************************************&n; * Function Name : sh_scan_urb_list&n; *&n; * This function goes through the urb list and schedule the &n; * the transaction.   &n; * &n; * Input: hci = data structure for the host controller &n; *        list_lh = pointer to the isochronous list &n; *&n; * Return: 0 = unsuccessful; 1 = successful  &n; **************************************************************************/
DECL|function|sh_scan_urb_list
r_static
r_int
id|sh_scan_urb_list
(paren
id|hci_t
op_star
id|hci
comma
r_struct
id|list_head
op_star
id|list_lh
)paren
(brace
r_struct
id|list_head
op_star
id|lh
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|urb
op_star
id|urb
suffix:semicolon
r_if
c_cond
(paren
id|list_lh
op_eq
l_int|NULL
)paren
(brace
id|DBGERR
(paren
l_string|&quot;sh_scan_urb_list: error, list_lh == NULL&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|DBGFUNC
(paren
l_string|&quot;enter sh_scan_urb_list: frame# &bslash;n&quot;
)paren
suffix:semicolon
id|list_for_each
(paren
id|lh
comma
id|list_lh
)paren
(brace
id|urb
op_assign
id|list_entry
(paren
id|lh
comma
r_struct
id|urb
comma
id|urb_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb
op_eq
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|usb_pipeint
(paren
id|urb-&gt;pipe
)paren
op_logical_or
(paren
(paren
(paren
id|hci-&gt;frame_number
op_minus
id|urb-&gt;start_frame
)paren
op_amp
l_int|0x7ff
)paren
op_ge
id|urb-&gt;interval
)paren
)paren
(brace
id|DBGVERBOSE
(paren
l_string|&quot;sh_scan_urb_list !INT: %d fr_no: %d int: %d pint: %d&bslash;n&quot;
comma
id|urb-&gt;start_frame
comma
id|hci-&gt;frame_number
comma
id|urb-&gt;interval
comma
id|usb_pipeint
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sh_add_packet
(paren
id|hci
comma
id|urb
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|DBGVERBOSE
(paren
l_string|&quot;INT: start: %d fr_no: %d int: %d pint: %d&bslash;n&quot;
comma
id|urb-&gt;start_frame
comma
id|hci-&gt;frame_number
comma
id|urb-&gt;interval
comma
id|usb_pipeint
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
id|urb-&gt;start_frame
op_assign
id|hci-&gt;frame_number
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/***************************************************************************&n; * Function Name : sh_shedule_trans&n; *&n; * This function schedule the USB transaction.&n; * This function will process the endpoint in the following order: &n; * interrupt, control, and bulk.    &n; * &n; * Input: hci = data structure for the host controller &n; *        isSOF = flag indicate if Start Of Frame has occurred &n; *&n; * Return: 0   &n; **************************************************************************/
DECL|function|sh_schedule_trans
r_static
r_int
id|sh_schedule_trans
(paren
id|hci_t
op_star
id|hci
comma
r_int
id|isSOF
)paren
(brace
r_int
id|units_left
op_assign
l_int|1
suffix:semicolon
r_struct
id|list_head
op_star
id|lh
suffix:semicolon
r_if
c_cond
(paren
id|hci
op_eq
l_int|NULL
)paren
(brace
id|DBGERR
(paren
l_string|&quot;sh_schedule_trans: hci == NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hci-&gt;td_array
op_eq
l_int|NULL
)paren
(brace
id|DBGERR
(paren
l_string|&quot;sh_schedule_trans: hci-&gt;td_array == NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hci-&gt;td_array-&gt;len
op_ne
l_int|0
)paren
(brace
id|DBGERR
(paren
l_string|&quot;ERROR: schedule, hci-&gt;td_array-&gt;len = 0x%x, s/b: 0&bslash;n&quot;
comma
id|hci-&gt;td_array-&gt;len
)paren
suffix:semicolon
)brace
multiline_comment|/* schedule the next available interrupt transfer or the next&n;&t; * stage of the interrupt transfer */
r_if
c_cond
(paren
id|hci-&gt;td_array-&gt;len
op_eq
l_int|0
op_logical_and
op_logical_neg
id|list_empty
(paren
op_amp
id|hci-&gt;intr_list
)paren
)paren
(brace
id|units_left
op_assign
id|sh_scan_urb_list
(paren
id|hci
comma
op_amp
id|hci-&gt;intr_list
)paren
suffix:semicolon
)brace
multiline_comment|/* schedule the next available control transfer or the next&n;&t; * stage of the control transfer */
r_if
c_cond
(paren
id|hci-&gt;td_array-&gt;len
op_eq
l_int|0
op_logical_and
op_logical_neg
id|list_empty
(paren
op_amp
id|hci-&gt;ctrl_list
)paren
op_logical_and
id|units_left
OG
l_int|0
)paren
(brace
id|units_left
op_assign
id|sh_scan_urb_list
(paren
id|hci
comma
op_amp
id|hci-&gt;ctrl_list
)paren
suffix:semicolon
)brace
multiline_comment|/* schedule the next available bulk transfer or the next&n;&t; * stage of the bulk transfer */
r_if
c_cond
(paren
id|hci-&gt;td_array-&gt;len
op_eq
l_int|0
op_logical_and
op_logical_neg
id|list_empty
(paren
op_amp
id|hci-&gt;bulk_list
)paren
op_logical_and
id|units_left
OG
l_int|0
)paren
(brace
id|sh_scan_urb_list
(paren
id|hci
comma
op_amp
id|hci-&gt;bulk_list
)paren
suffix:semicolon
multiline_comment|/* be fair to each BULK URB (move list head around) &n;&t;&t; * only when the new SOF happens */
id|lh
op_assign
id|hci-&gt;bulk_list.next
suffix:semicolon
id|list_move
(paren
op_amp
id|hci-&gt;bulk_list
comma
id|lh
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/***************************************************************************&n; * Function Name : sh_add_packet&n; *&n; * This function forms the packet and transmit the packet. This function&n; * will handle all endpoint type: isochoronus, interrupt, control, and &n; * bulk.&n; * &n; * Input: hci = data structure for the host controller &n; *        urb = USB request block data structure &n; *&n; * Return: 0 = unsucessful; 1 = successful   &n; **************************************************************************/
DECL|function|sh_add_packet
r_static
r_int
id|sh_add_packet
(paren
id|hci_t
op_star
id|hci
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
id|__u8
op_star
id|data
op_assign
l_int|NULL
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_int
id|toggle
op_assign
l_int|0
suffix:semicolon
r_int
id|maxps
op_assign
id|usb_maxpacket
(paren
id|urb-&gt;dev
comma
id|urb-&gt;pipe
comma
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
r_int
id|endpoint
op_assign
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
r_int
id|address
op_assign
id|usb_pipedevice
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
r_int
id|slow
op_assign
(paren
(paren
(paren
id|urb-&gt;pipe
)paren
op_rshift
l_int|26
)paren
op_amp
l_int|1
)paren
suffix:semicolon
r_int
id|out
op_assign
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
r_int
id|pid
op_assign
l_int|0
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|iso
op_assign
l_int|0
suffix:semicolon
id|DBGFUNC
(paren
l_string|&quot;enter sh_add_packet&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|maxps
op_eq
l_int|0
)paren
id|maxps
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* calculate len, toggle bit and add the transaction */
r_switch
c_cond
(paren
id|usb_pipetype
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
r_case
id|PIPE_ISOCHRONOUS
suffix:colon
id|pid
op_assign
id|out
ques
c_cond
id|PID_OUT
suffix:colon
id|PID_IN
suffix:semicolon
id|iso
op_assign
l_int|1
suffix:semicolon
id|i
op_assign
id|hci-&gt;frame_number
op_minus
id|urb-&gt;start_frame
suffix:semicolon
id|data
op_assign
id|urb-&gt;transfer_buffer
op_plus
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|offset
suffix:semicolon
id|len
op_assign
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|length
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_BULK
suffix:colon
multiline_comment|/* BULK and BULK0 */
r_case
id|PIPE_INTERRUPT
suffix:colon
id|pid
op_assign
id|out
ques
c_cond
id|PID_OUT
suffix:colon
id|PID_IN
suffix:semicolon
id|len
op_assign
id|urb-&gt;transfer_buffer_length
op_minus
id|urb-&gt;actual_length
suffix:semicolon
id|data
op_assign
id|urb-&gt;transfer_buffer
op_plus
id|urb-&gt;actual_length
suffix:semicolon
id|toggle
op_assign
id|usb_gettoggle
(paren
id|urb-&gt;dev
comma
id|endpoint
comma
id|out
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_CONTROL
suffix:colon
r_switch
c_cond
(paren
id|qu_urbstate
(paren
id|urb
)paren
)paren
(brace
r_case
id|US_CTRL_SETUP
suffix:colon
id|len
op_assign
l_int|8
suffix:semicolon
id|pid
op_assign
id|PID_SETUP
suffix:semicolon
id|data
op_assign
id|urb-&gt;setup_packet
suffix:semicolon
id|toggle
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|US_CTRL_DATA
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|hci-&gt;last_packet_nak
)paren
(brace
multiline_comment|/* The last packet received is not a nak:&n;&t;&t;&t;&t; * reset the nak count&n;&t;&t;&t;&t; */
id|hci-&gt;nakCnt
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|urb-&gt;transfer_buffer_length
op_ne
l_int|0
)paren
(brace
id|pid
op_assign
id|out
ques
c_cond
id|PID_OUT
suffix:colon
id|PID_IN
suffix:semicolon
id|len
op_assign
id|urb-&gt;transfer_buffer_length
op_minus
id|urb-&gt;actual_length
suffix:semicolon
id|data
op_assign
id|urb-&gt;transfer_buffer
op_plus
id|urb-&gt;actual_length
suffix:semicolon
id|toggle
op_assign
(paren
id|urb-&gt;actual_length
op_amp
id|maxps
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
id|usb_settoggle
(paren
id|urb-&gt;dev
comma
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
comma
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
comma
id|toggle
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* correct state and fall through */
id|qu_seturbstate
(paren
id|urb
comma
id|US_CTRL_ACK
)paren
suffix:semicolon
)brace
r_case
id|US_CTRL_ACK
suffix:colon
id|len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* reply in opposite direction */
id|pid
op_assign
op_logical_neg
id|out
ques
c_cond
id|PID_OUT
suffix:colon
id|PID_IN
suffix:semicolon
id|toggle
op_assign
l_int|1
suffix:semicolon
id|usb_settoggle
(paren
id|urb-&gt;dev
comma
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
comma
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
comma
id|toggle
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|ret
op_assign
id|hc_add_trans
(paren
id|hci
comma
id|len
comma
id|data
comma
id|toggle
comma
id|maxps
comma
id|slow
comma
id|endpoint
comma
id|address
comma
id|pid
comma
id|iso
comma
id|qu_urbstate
(paren
id|urb
)paren
)paren
suffix:semicolon
id|DBGVERBOSE
(paren
l_string|&quot;transfer_pa: addr:%d ep:%d pid:%x tog:%x iso:%x sl:%x &quot;
l_string|&quot;max:%d&bslash;n len:%d ret:%d data:%p left:%d&bslash;n&quot;
comma
id|address
comma
id|endpoint
comma
id|pid
comma
id|toggle
comma
id|iso
comma
id|slow
comma
id|maxps
comma
id|len
comma
id|ret
comma
id|data
comma
id|hci-&gt;hp.units_left
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ge
l_int|0
)paren
(brace
id|hci-&gt;td_array-&gt;td
(braket
id|hci-&gt;td_array-&gt;len
)braket
dot
id|urb
op_assign
id|urb
suffix:semicolon
id|hci-&gt;td_array-&gt;td
(braket
id|hci-&gt;td_array-&gt;len
)braket
dot
id|len
op_assign
id|ret
suffix:semicolon
id|hci-&gt;td_array-&gt;td
(braket
id|hci-&gt;td_array-&gt;len
)braket
dot
id|iso_index
op_assign
id|i
suffix:semicolon
id|hci-&gt;td_array-&gt;len
op_increment
suffix:semicolon
id|hci-&gt;active_trans
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/***************************************************************************&n; * Function Name : cc_to_error&n; *&n; * This function maps the SL811HS hardware error code to the linux USB error&n; * code.&n; * &n; * Input: cc = hardware error code &n; *&n; * Return: USB error code   &n; **************************************************************************/
DECL|function|cc_to_error
r_static
r_int
id|cc_to_error
(paren
r_int
id|cc
)paren
(brace
r_int
id|errCode
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cc
op_amp
id|SL11H_STATMASK_ERROR
)paren
(brace
id|errCode
op_or_assign
op_minus
id|EILSEQ
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cc
op_amp
id|SL11H_STATMASK_OVF
)paren
(brace
id|errCode
op_or_assign
op_minus
id|EOVERFLOW
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cc
op_amp
id|SL11H_STATMASK_STALL
)paren
(brace
id|errCode
op_or_assign
op_minus
id|EPIPE
suffix:semicolon
)brace
r_return
id|errCode
suffix:semicolon
)brace
multiline_comment|/***************************************************************************&n; * Function Name : sh_done_list&n; *&n; * This function process the packet when it has done finish transfer.&n; * &n; * 1) It handles hardware error&n; * 2) It updates the URB state&n; * 3) If the USB transaction is complete, it start the return stack path.&n; * &n; * Input: hci = data structure for the host controller &n; *        isExcessNak = flag tells if there excess NAK condition occurred &n; *&n; * Return:  urb_state or -1 if the transaction has complete   &n; **************************************************************************/
DECL|function|sh_done_list
r_static
r_int
id|sh_done_list
(paren
id|hci_t
op_star
id|hci
comma
r_int
op_star
id|isExcessNak
)paren
(brace
r_int
id|actbytes
op_assign
l_int|0
suffix:semicolon
r_int
id|active
op_assign
l_int|0
suffix:semicolon
r_void
op_star
id|data
op_assign
l_int|NULL
suffix:semicolon
r_int
id|cc
suffix:semicolon
r_int
id|maxps
suffix:semicolon
r_int
id|toggle
suffix:semicolon
r_struct
id|urb
op_star
id|urb
suffix:semicolon
r_int
id|urb_state
op_assign
l_int|0
suffix:semicolon
r_int
id|ret
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* -1 parse abbort, 1 parse ok, 0 last element */
r_int
id|trans
op_assign
l_int|0
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
id|iso_index
op_assign
l_int|0
suffix:semicolon
r_int
id|out
suffix:semicolon
r_int
id|pid
op_assign
l_int|0
suffix:semicolon
r_int
id|debugLen
op_assign
l_int|0
suffix:semicolon
op_star
id|isExcessNak
op_assign
l_int|0
suffix:semicolon
id|DBGFUNC
(paren
l_string|&quot;enter sh_done_list: td_array-&gt;len = 0x%x&bslash;n&quot;
comma
id|hci-&gt;td_array-&gt;len
)paren
suffix:semicolon
id|debugLen
op_assign
id|hci-&gt;td_array-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|debugLen
OG
l_int|1
)paren
id|DBGERR
(paren
l_string|&quot;sh_done_list: td_array-&gt;len = 0x%x &gt; 1&bslash;n&quot;
comma
id|hci-&gt;td_array-&gt;len
)paren
suffix:semicolon
r_for
c_loop
(paren
id|trans
op_assign
l_int|0
suffix:semicolon
id|ret
op_logical_and
id|trans
OL
id|hci-&gt;td_array-&gt;len
op_logical_and
id|trans
OL
id|MAX_TRANS
suffix:semicolon
id|trans
op_increment
)paren
(brace
id|urb
op_assign
id|hci-&gt;td_array-&gt;td
(braket
id|trans
)braket
dot
id|urb
suffix:semicolon
id|len
op_assign
id|hci-&gt;td_array-&gt;td
(braket
id|trans
)braket
dot
id|len
suffix:semicolon
id|out
op_assign
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipeisoc
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
id|iso_index
op_assign
id|hci-&gt;td_array-&gt;td
(braket
id|trans
)braket
dot
id|iso_index
suffix:semicolon
id|data
op_assign
id|urb-&gt;transfer_buffer
op_plus
id|urb-&gt;iso_frame_desc
(braket
id|iso_index
)braket
dot
id|offset
suffix:semicolon
id|toggle
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|data
op_assign
id|urb-&gt;transfer_buffer
op_plus
id|urb-&gt;actual_length
suffix:semicolon
id|toggle
op_assign
id|usb_gettoggle
(paren
id|urb-&gt;dev
comma
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
comma
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
)brace
id|urb_state
op_assign
id|qu_urbstate
(paren
id|urb
)paren
suffix:semicolon
id|pid
op_assign
id|out
ques
c_cond
id|PID_OUT
suffix:colon
id|PID_IN
suffix:semicolon
id|ret
op_assign
id|hc_parse_trans
(paren
id|hci
comma
op_amp
id|actbytes
comma
id|data
comma
op_amp
id|cc
comma
op_amp
id|toggle
comma
id|len
comma
id|pid
comma
id|urb_state
)paren
suffix:semicolon
id|maxps
op_assign
id|usb_maxpacket
(paren
id|urb-&gt;dev
comma
id|urb-&gt;pipe
comma
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|maxps
op_eq
l_int|0
)paren
id|maxps
op_assign
l_int|8
suffix:semicolon
id|active
op_assign
(paren
id|urb_state
op_ne
id|US_CTRL_SETUP
)paren
op_logical_and
(paren
id|actbytes
op_logical_and
op_logical_neg
(paren
id|actbytes
op_amp
(paren
id|maxps
op_minus
l_int|1
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* If the transfer is not bulk in, then it is necessary to get all&n;&t;&t; * data specify by the urb-&gt;transfer_len.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|usb_pipebulk
(paren
id|urb-&gt;pipe
)paren
op_logical_and
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
)paren
)paren
id|active
op_assign
id|active
op_logical_and
(paren
id|urb-&gt;transfer_buffer_length
op_ne
id|urb-&gt;actual_length
op_plus
id|actbytes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;transfer_buffer_length
op_eq
id|urb-&gt;actual_length
op_plus
id|actbytes
)paren
id|active
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cc
op_amp
(paren
id|SL11H_STATMASK_ERROR
op_or
id|SL11H_STATMASK_TMOUT
op_or
id|SL11H_STATMASK_OVF
op_or
id|SL11H_STATMASK_STALL
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|cc
op_amp
id|SL11H_STATMASK_NAK
)paren
)paren
(brace
r_if
c_cond
(paren
op_increment
id|urb-&gt;error_count
OG
l_int|3
)paren
(brace
id|DBGERR
(paren
l_string|&quot;done_list: excessive error: errcount = 0x%x, cc = 0x%x&bslash;n&quot;
comma
id|urb-&gt;error_count
comma
id|cc
)paren
suffix:semicolon
id|urb_state
op_assign
l_int|0
suffix:semicolon
id|active
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|DBGERR
(paren
l_string|&quot;done_list: packet err, cc = 0x%x, &quot;
l_string|&quot; urb-&gt;length = 0x%x, actual_len = 0x%x,&quot;
l_string|&quot; urb_state =0x%x&bslash;n&quot;
comma
id|cc
comma
id|urb-&gt;transfer_buffer_length
comma
id|urb-&gt;actual_length
comma
id|urb_state
)paren
suffix:semicolon
singleline_comment|//&t;&t;&t;if (cc &amp; SL11H_STATMASK_STALL) {
multiline_comment|/* The USB function is STALLED on a control pipe (0), &n;&t;&t;&t;&t; * then it needs to send the SETUP command again to &n;&t;&t;&t;&t; * clear the STALL condition&n;&t;&t;&t;&t; */
singleline_comment|//&t;&t;&t;&t;if (usb_pipeendpoint (urb-&gt;pipe) == 0) {
singleline_comment|//&t;&t;&t;&t;&t;urb_state = 2;  
singleline_comment|//&t;&t;&t;&t;&t;active = 0;
singleline_comment|//&t;&t;&t;&t;}
singleline_comment|//&t;&t;&t;} else   
id|active
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|cc
op_amp
id|SL11H_STATMASK_NAK
)paren
(brace
r_if
c_cond
(paren
id|hci-&gt;nakCnt
OL
l_int|0x10000
)paren
(brace
id|hci-&gt;nakCnt
op_increment
suffix:semicolon
id|hci-&gt;last_packet_nak
op_assign
l_int|1
suffix:semicolon
id|active
op_assign
l_int|1
suffix:semicolon
op_star
id|isExcessNak
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|DBGERR
(paren
l_string|&quot;done_list: nak count exceed limit&bslash;n&quot;
)paren
suffix:semicolon
id|active
op_assign
l_int|0
suffix:semicolon
op_star
id|isExcessNak
op_assign
l_int|1
suffix:semicolon
id|hci-&gt;nakCnt
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|hci-&gt;nakCnt
op_assign
l_int|0
suffix:semicolon
id|hci-&gt;last_packet_nak
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|urb_state
op_ne
id|US_CTRL_SETUP
)paren
(brace
multiline_comment|/* no error */
id|urb-&gt;actual_length
op_add_assign
id|actbytes
suffix:semicolon
id|usb_settoggle
(paren
id|urb-&gt;dev
comma
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
comma
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
comma
id|toggle
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|usb_pipeisoc
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
id|urb-&gt;iso_frame_desc
(braket
id|iso_index
)braket
dot
id|actual_length
op_assign
id|actbytes
suffix:semicolon
id|urb-&gt;iso_frame_desc
(braket
id|iso_index
)braket
dot
id|status
op_assign
id|cc_to_error
(paren
id|cc
)paren
suffix:semicolon
id|active
op_assign
(paren
id|iso_index
OL
id|urb-&gt;number_of_packets
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|active
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|urb_state
)paren
(brace
id|urb-&gt;status
op_assign
id|cc_to_error
(paren
id|cc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;status
)paren
(brace
id|DBGERR
(paren
l_string|&quot;error on received packet: urb-&gt;status = 0x%x&bslash;n&quot;
comma
id|urb-&gt;status
)paren
suffix:semicolon
)brace
id|hci-&gt;td_array-&gt;len
op_assign
l_int|0
suffix:semicolon
id|qu_return_urb
(paren
id|hci
comma
id|urb
comma
l_int|1
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We do not want to decrement the urb_state if exceeded nak,&n;&t;&t;&t;&t; * because we need to finish the data stage of the control &n;&t;&t;&t;&t; * packet &n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|isExcessNak
)paren
)paren
id|urb_state
op_decrement
suffix:semicolon
id|qu_seturbstate
(paren
id|urb
comma
id|urb_state
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|urb_state
OL
l_int|0
)paren
id|DBGERR
(paren
l_string|&quot;ERROR: done_list, urb_state = %d, suppose &gt; 0&bslash;n&quot;
comma
id|urb_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debugLen
op_ne
id|hci-&gt;td_array-&gt;len
)paren
(brace
id|DBGERR
(paren
l_string|&quot;ERROR: done_list, debugLen!= td_array-&gt;len,&quot;
l_string|&quot;debugLen = 0x%x, hci-&gt;td_array-&gt;len = 0x%x&bslash;n&quot;
comma
id|debugLen
comma
id|hci-&gt;td_array-&gt;len
)paren
suffix:semicolon
)brace
id|hci-&gt;td_array-&gt;len
op_assign
l_int|0
suffix:semicolon
r_return
id|urb_state
suffix:semicolon
)brace
eof
