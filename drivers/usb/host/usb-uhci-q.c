multiline_comment|/*  &n;    UHCI HCD (Host Controller Driver) for USB, UHCI transfer processing&n;    &n;    (c) 1999-2002 &n;    Georg Acher      +    Deti Fliegl    +    Thomas Sailer&n;    georg@acher.org      deti@fliegl.de   sailer@ife.ee.ethz.ch&n;   &n;    with the help of&n;    David Brownell, david-b@pacbell.net&n;    Adam Richter, adam@yggdrasil.com&n;    Roman Weissgaerber, weissg@vienna.at&n;    &n;    HW-initalization based on material of&n;    Randy Dunlap + Johannes Erdfelt + Gregory P. Smith + Linus Torvalds &n;&n;    $Id: usb-uhci-q.c,v 1.1 2002/05/14 20:36:57 acher Exp $&n;*/
multiline_comment|/*-------------------------------------------------------------------*/
DECL|function|finish_urb
r_static
r_inline
r_void
id|finish_urb
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_if
c_cond
(paren
id|urb-&gt;hcpriv
)paren
id|uhci_free_priv
(paren
id|uhci
comma
id|urb
comma
id|urb-&gt;hcpriv
)paren
suffix:semicolon
id|usb_hcd_giveback_urb
(paren
op_amp
id|uhci-&gt;hcd
comma
id|urb
)paren
suffix:semicolon
)brace
multiline_comment|/*###########################################################################*/
singleline_comment|//                        URB SUBMISSION STUFF
singleline_comment|//     assembles QHs und TDs for control, bulk, interrupt  and isochronous
multiline_comment|/*###########################################################################*/
singleline_comment|// returns: 0 (no transfer queued), urb* (this urb already queued) 
DECL|function|search_dev_ep
r_static
r_struct
id|urb
op_star
id|search_dev_ep
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
r_struct
id|urb
op_star
id|tmp
suffix:semicolon
id|urb_priv_t
op_star
id|priv
suffix:semicolon
r_int
r_int
id|mask
op_assign
id|usb_pipecontrol
c_func
(paren
id|urb-&gt;pipe
)paren
ques
c_cond
(paren
op_complement
id|USB_DIR_IN
)paren
suffix:colon
(paren
op_complement
l_int|0
)paren
suffix:semicolon
id|p
op_assign
id|uhci-&gt;urb_list.next
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|p
op_ne
op_amp
id|uhci-&gt;urb_list
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
id|priv
op_assign
id|list_entry
(paren
id|p
comma
id|urb_priv_t
comma
id|urb_list
)paren
suffix:semicolon
id|tmp
op_assign
id|priv-&gt;urb
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;search_dev_ep urb: %p&quot;
comma
id|tmp
)paren
suffix:semicolon
singleline_comment|// we can accept this urb if it is not queued at this time 
singleline_comment|// or if non-iso transfer requests should be scheduled for the same device and pipe
r_if
c_cond
(paren
(paren
op_logical_neg
id|usb_pipeisoc
c_func
(paren
id|urb-&gt;pipe
)paren
op_logical_and
(paren
id|tmp-&gt;dev
op_eq
id|urb-&gt;dev
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|tmp-&gt;pipe
op_xor
id|urb-&gt;pipe
)paren
op_amp
id|mask
)paren
)paren
op_logical_or
(paren
id|urb
op_eq
id|tmp
)paren
)paren
r_return
id|tmp
suffix:semicolon
singleline_comment|// found another urb already queued for processing
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------*/
DECL|function|uhci_submit_control_urb
r_static
r_int
id|uhci_submit_control_urb
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
id|uhci_desc_t
op_star
id|qh
comma
op_star
id|td
suffix:semicolon
id|urb_priv_t
op_star
id|urb_priv
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
r_int
r_int
id|destination
comma
id|status
suffix:semicolon
r_int
id|maxsze
op_assign
id|usb_maxpacket
(paren
id|urb-&gt;dev
comma
id|urb-&gt;pipe
comma
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
r_int
id|depth_first
op_assign
id|USE_CTRL_DEPTH_FIRST
suffix:semicolon
singleline_comment|// UHCI descriptor chasing method
r_int
r_int
id|len
suffix:semicolon
r_char
op_star
id|data
suffix:semicolon
singleline_comment|//&t;err(&quot;uhci_submit_control start, buf %p&quot;, urb-&gt;transfer_buffer);
r_if
c_cond
(paren
id|alloc_qh
(paren
id|uhci
comma
op_amp
id|qh
)paren
)paren
singleline_comment|// alloc qh for this request
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|alloc_td
(paren
id|uhci
comma
op_amp
id|td
comma
id|UHCI_PTR_DEPTH
op_star
id|depth_first
)paren
)paren
singleline_comment|// get td for setup stage
r_goto
id|fail_unmap_enomem
suffix:semicolon
multiline_comment|/* The &quot;pipe&quot; thing contains the destination in bits 8--18 */
id|destination
op_assign
(paren
id|urb-&gt;pipe
op_amp
id|PIPE_DEVEP_MASK
)paren
op_or
id|USB_PID_SETUP
suffix:semicolon
id|status
op_assign
id|TD_CTRL_ACTIVE
op_or
(paren
id|urb-&gt;transfer_flags
op_amp
id|USB_DISABLE_SPD
ques
c_cond
l_int|0
suffix:colon
id|TD_CTRL_SPD
)paren
op_or
(paren
l_int|3
op_lshift
l_int|27
)paren
suffix:semicolon
multiline_comment|/* 3 errors */
r_if
c_cond
(paren
id|urb-&gt;dev-&gt;speed
op_eq
id|USB_SPEED_LOW
)paren
id|status
op_or_assign
id|TD_CTRL_LS
suffix:semicolon
multiline_comment|/*  Build the TD for the control request, try forever, 8 bytes of data */
id|fill_td
(paren
id|td
comma
id|status
comma
id|destination
op_or
(paren
l_int|7
op_lshift
l_int|21
)paren
comma
id|urb_priv-&gt;setup_packet_dma
)paren
suffix:semicolon
id|insert_td
(paren
id|uhci
comma
id|qh
comma
id|td
comma
l_int|0
)paren
suffix:semicolon
singleline_comment|// queue &squot;setup stage&squot;-td in qh
macro_line|#if 0
(brace
r_char
op_star
id|sp
op_assign
id|urb-&gt;setup_packet
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;SETUP to pipe %x: %x %x %x %x %x %x %x %x&quot;
comma
id|urb-&gt;pipe
comma
id|sp
(braket
l_int|0
)braket
comma
id|sp
(braket
l_int|1
)braket
comma
id|sp
(braket
l_int|2
)braket
comma
id|sp
(braket
l_int|3
)braket
comma
id|sp
(braket
l_int|4
)braket
comma
id|sp
(braket
l_int|5
)braket
comma
id|sp
(braket
l_int|6
)braket
comma
id|sp
(braket
l_int|7
)braket
)paren
suffix:semicolon
)brace
singleline_comment|//uhci_show_td(td);
macro_line|#endif
id|len
op_assign
id|urb-&gt;transfer_buffer_length
suffix:semicolon
id|data
op_assign
id|urb-&gt;transfer_buffer
suffix:semicolon
multiline_comment|/* If direction is &quot;send&quot;, change the frame from SETUP (0x2D)&n;&t;   to OUT (0xE1). Else change it from SETUP to IN (0x69). */
id|destination
op_assign
(paren
id|urb-&gt;pipe
op_amp
id|PIPE_DEVEP_MASK
)paren
op_or
(paren
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
ques
c_cond
id|USB_PID_OUT
suffix:colon
id|USB_PID_IN
)paren
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
r_int
id|pktsze
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|alloc_td
(paren
id|uhci
comma
op_amp
id|td
comma
id|UHCI_PTR_DEPTH
op_star
id|depth_first
)paren
)paren
r_goto
id|fail_unmap_enomem
suffix:semicolon
r_if
c_cond
(paren
id|pktsze
OG
id|maxsze
)paren
id|pktsze
op_assign
id|maxsze
suffix:semicolon
id|destination
op_xor_assign
l_int|1
op_lshift
id|TD_TOKEN_TOGGLE
suffix:semicolon
singleline_comment|// toggle DATA0/1
singleline_comment|// Status, pktsze bytes of data
id|fill_td
(paren
id|td
comma
id|status
comma
id|destination
op_or
(paren
(paren
id|pktsze
op_minus
l_int|1
)paren
op_lshift
l_int|21
)paren
comma
id|urb_priv-&gt;transfer_buffer_dma
op_plus
(paren
id|data
op_minus
(paren
r_char
op_star
)paren
id|urb-&gt;transfer_buffer
)paren
)paren
suffix:semicolon
id|insert_td
(paren
id|uhci
comma
id|qh
comma
id|td
comma
id|UHCI_PTR_DEPTH
op_star
id|depth_first
)paren
suffix:semicolon
singleline_comment|// queue &squot;data stage&squot;-td in qh
id|data
op_add_assign
id|pktsze
suffix:semicolon
id|len
op_sub_assign
id|pktsze
suffix:semicolon
)brace
multiline_comment|/* Build the final TD for control status &n;&t;   It&squot;s only IN if the pipe is out AND we aren&squot;t expecting data */
id|destination
op_and_assign
op_complement
id|UHCI_PID
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
op_logical_or
(paren
id|urb-&gt;transfer_buffer_length
op_eq
l_int|0
)paren
)paren
id|destination
op_or_assign
id|USB_PID_IN
suffix:semicolon
r_else
id|destination
op_or_assign
id|USB_PID_OUT
suffix:semicolon
id|destination
op_or_assign
l_int|1
op_lshift
id|TD_TOKEN_TOGGLE
suffix:semicolon
multiline_comment|/* End in Data1 */
r_if
c_cond
(paren
id|alloc_td
(paren
id|uhci
comma
op_amp
id|td
comma
id|UHCI_PTR_DEPTH
)paren
)paren
r_goto
id|fail_unmap_enomem
suffix:semicolon
id|status
op_and_assign
op_complement
id|TD_CTRL_SPD
suffix:semicolon
multiline_comment|/* no limit on errors on final packet, 0 bytes of data */
id|fill_td
(paren
id|td
comma
id|status
op_or
id|TD_CTRL_IOC
comma
id|destination
op_or
(paren
id|UHCI_NULL_DATA_SIZE
op_lshift
l_int|21
)paren
comma
l_int|0
)paren
suffix:semicolon
id|insert_td
(paren
id|uhci
comma
id|qh
comma
id|td
comma
id|UHCI_PTR_DEPTH
op_star
id|depth_first
)paren
suffix:semicolon
singleline_comment|// queue status td
id|list_add
(paren
op_amp
id|qh-&gt;desc_list
comma
op_amp
id|urb_priv-&gt;desc_list
)paren
suffix:semicolon
id|queue_urb
(paren
id|uhci
comma
id|urb
)paren
suffix:semicolon
singleline_comment|// queue _before_ inserting in desc chain
id|qh-&gt;hw.qh.element
op_and_assign
id|cpu_to_le32
c_func
(paren
op_complement
id|UHCI_PTR_TERM
)paren
suffix:semicolon
multiline_comment|/* Start it up... put low speed first */
r_if
c_cond
(paren
id|urb-&gt;dev-&gt;speed
op_eq
id|USB_SPEED_LOW
)paren
id|insert_qh
(paren
id|uhci
comma
id|uhci-&gt;control_chain
comma
id|qh
comma
l_int|0
)paren
suffix:semicolon
r_else
id|insert_qh
(paren
id|uhci
comma
id|uhci-&gt;bulk_chain
comma
id|qh
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|fail_unmap_enomem
suffix:colon
id|delete_qh
c_func
(paren
id|uhci
comma
id|qh
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------*/
singleline_comment|// For queued bulk transfers, two additional QH helpers are allocated (nqh, bqh)
singleline_comment|// Due to the linking with other bulk urbs, it has to be locked with urb_list_lock!
DECL|function|uhci_submit_bulk_urb
r_static
r_int
id|uhci_submit_bulk_urb
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|urb
op_star
id|bulk_urb
)paren
(brace
id|urb_priv_t
op_star
id|urb_priv
op_assign
id|urb-&gt;hcpriv
comma
op_star
id|upriv
comma
op_star
id|bpriv
op_assign
l_int|NULL
suffix:semicolon
id|uhci_desc_t
op_star
id|qh
comma
op_star
id|td
comma
op_star
id|nqh
op_assign
l_int|NULL
comma
op_star
id|bqh
op_assign
l_int|NULL
comma
op_star
id|first_td
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|destination
comma
id|status
suffix:semicolon
r_char
op_star
id|data
suffix:semicolon
r_int
r_int
id|pipe
op_assign
id|urb-&gt;pipe
suffix:semicolon
r_int
id|maxsze
op_assign
id|usb_maxpacket
(paren
id|urb-&gt;dev
comma
id|pipe
comma
id|usb_pipeout
(paren
id|pipe
)paren
)paren
suffix:semicolon
r_int
id|info
comma
id|len
comma
id|last
suffix:semicolon
r_int
id|depth_first
op_assign
id|USE_BULK_DEPTH_FIRST
suffix:semicolon
singleline_comment|// UHCI descriptor chasing method
r_if
c_cond
(paren
id|usb_endpoint_halted
(paren
id|urb-&gt;dev
comma
id|usb_pipeendpoint
(paren
id|pipe
)paren
comma
id|usb_pipeout
(paren
id|pipe
)paren
)paren
)paren
r_return
op_minus
id|EPIPE
suffix:semicolon
id|queue_dbg
c_func
(paren
l_string|&quot;uhci_submit_bulk_urb: urb %p, old %p, pipe %08x, len %i&quot;
comma
id|urb
comma
id|bulk_urb
comma
id|urb-&gt;pipe
comma
id|urb-&gt;transfer_buffer_length
)paren
suffix:semicolon
id|upriv
op_assign
(paren
id|urb_priv_t
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bulk_urb
)paren
(brace
r_if
c_cond
(paren
id|alloc_qh
(paren
id|uhci
comma
op_amp
id|qh
)paren
)paren
singleline_comment|// get qh for this request
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;transfer_flags
op_amp
id|USB_QUEUE_BULK
)paren
(brace
r_if
c_cond
(paren
id|alloc_qh
c_func
(paren
id|uhci
comma
op_amp
id|nqh
)paren
)paren
singleline_comment|// placeholder for clean unlink
r_goto
id|fail_unmap_enomem
suffix:semicolon
id|upriv-&gt;next_qh
op_assign
id|nqh
suffix:semicolon
id|queue_dbg
c_func
(paren
l_string|&quot;new next qh %p&quot;
comma
id|nqh
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|bpriv
op_assign
(paren
id|urb_priv_t
op_star
)paren
id|bulk_urb-&gt;hcpriv
suffix:semicolon
id|qh
op_assign
id|bpriv-&gt;bottom_qh
suffix:semicolon
singleline_comment|// re-use bottom qh and next qh
id|nqh
op_assign
id|bpriv-&gt;next_qh
suffix:semicolon
id|upriv-&gt;next_qh
op_assign
id|nqh
suffix:semicolon
id|upriv-&gt;prev_queued_urb
op_assign
id|bulk_urb
suffix:semicolon
)brace
r_if
c_cond
(paren
id|urb-&gt;transfer_flags
op_amp
id|USB_QUEUE_BULK
)paren
(brace
r_if
c_cond
(paren
id|alloc_qh
(paren
id|uhci
comma
op_amp
id|bqh
)paren
)paren
singleline_comment|// &quot;bottom&quot; QH
r_goto
id|fail_unmap_enomem
suffix:semicolon
id|set_qh_element
c_func
(paren
id|bqh
comma
id|UHCI_PTR_TERM
)paren
suffix:semicolon
id|set_qh_head
c_func
(paren
id|bqh
comma
id|nqh-&gt;dma_addr
op_or
id|UHCI_PTR_QH
)paren
suffix:semicolon
singleline_comment|// element
id|upriv-&gt;bottom_qh
op_assign
id|bqh
suffix:semicolon
)brace
id|queue_dbg
c_func
(paren
l_string|&quot;uhci_submit_bulk: qh %p bqh %p nqh %p&quot;
comma
id|qh
comma
id|bqh
comma
id|nqh
)paren
suffix:semicolon
multiline_comment|/* The &quot;pipe&quot; thing contains the destination in bits 8--18. */
id|destination
op_assign
(paren
id|pipe
op_amp
id|PIPE_DEVEP_MASK
)paren
op_or
id|usb_packetid
(paren
id|pipe
)paren
suffix:semicolon
id|status
op_assign
id|TD_CTRL_ACTIVE
op_or
(paren
(paren
id|urb-&gt;transfer_flags
op_amp
id|USB_DISABLE_SPD
)paren
ques
c_cond
l_int|0
suffix:colon
id|TD_CTRL_SPD
)paren
op_or
(paren
l_int|3
op_lshift
l_int|27
)paren
suffix:semicolon
multiline_comment|/* 3 errors */
r_if
c_cond
(paren
id|urb-&gt;dev-&gt;speed
op_eq
id|USB_SPEED_LOW
)paren
id|status
op_or_assign
id|TD_CTRL_LS
suffix:semicolon
multiline_comment|/* Build the TDs for the bulk request */
id|len
op_assign
id|urb-&gt;transfer_buffer_length
suffix:semicolon
id|data
op_assign
id|urb-&gt;transfer_buffer
suffix:semicolon
r_do
(brace
singleline_comment|// TBD: Really allow zero-length packets?
r_int
id|pktsze
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|alloc_td
(paren
id|uhci
comma
op_amp
id|td
comma
id|UHCI_PTR_DEPTH
op_star
id|depth_first
)paren
)paren
r_goto
id|fail_unmap_enomem
suffix:semicolon
r_if
c_cond
(paren
id|pktsze
OG
id|maxsze
)paren
id|pktsze
op_assign
id|maxsze
suffix:semicolon
singleline_comment|// pktsze bytes of data 
id|info
op_assign
id|destination
op_or
(paren
(paren
(paren
id|pktsze
op_minus
l_int|1
)paren
op_amp
id|UHCI_NULL_DATA_SIZE
)paren
op_lshift
l_int|21
)paren
op_or
(paren
id|uhci_get_toggle
(paren
id|urb
)paren
op_lshift
id|TD_TOKEN_TOGGLE
)paren
suffix:semicolon
id|fill_td
(paren
id|td
comma
id|status
comma
id|info
comma
id|urb_priv-&gt;transfer_buffer_dma
op_plus
(paren
id|data
op_minus
(paren
r_char
op_star
)paren
id|urb-&gt;transfer_buffer
)paren
)paren
suffix:semicolon
id|data
op_add_assign
id|pktsze
suffix:semicolon
id|len
op_sub_assign
id|pktsze
suffix:semicolon
singleline_comment|// Use USB_ZERO_PACKET to finish bulk OUTs always with a zero length packet
id|last
op_assign
(paren
id|len
op_eq
l_int|0
op_logical_and
(paren
id|usb_pipein
c_func
(paren
id|pipe
)paren
op_logical_or
id|pktsze
OL
id|maxsze
op_logical_or
op_logical_neg
(paren
id|urb-&gt;transfer_flags
op_amp
id|USB_ZERO_PACKET
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last
)paren
id|set_td_ioc
c_func
(paren
id|td
)paren
suffix:semicolon
singleline_comment|// last one generates INT
id|insert_td
(paren
id|uhci
comma
id|qh
comma
id|td
comma
id|UHCI_PTR_DEPTH
op_star
id|depth_first
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|first_td
)paren
id|first_td
op_assign
id|td
suffix:semicolon
id|uhci_do_toggle
(paren
id|urb
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|last
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bulk_urb
op_logical_and
id|bpriv
)paren
singleline_comment|// everything went OK, link with old bulk URB
id|bpriv-&gt;next_queued_urb
op_assign
id|urb
suffix:semicolon
id|list_add
(paren
op_amp
id|qh-&gt;desc_list
comma
op_amp
id|urb_priv-&gt;desc_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;transfer_flags
op_amp
id|USB_QUEUE_BULK
)paren
id|append_qh
c_func
(paren
id|uhci
comma
id|td
comma
id|bqh
comma
id|UHCI_PTR_DEPTH
op_star
id|depth_first
)paren
suffix:semicolon
id|queue_urb_unlocked
(paren
id|uhci
comma
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;transfer_flags
op_amp
id|USB_QUEUE_BULK
)paren
id|set_qh_element
c_func
(paren
id|qh
comma
id|first_td-&gt;dma_addr
)paren
suffix:semicolon
r_else
id|qh-&gt;hw.qh.element
op_and_assign
id|cpu_to_le32
c_func
(paren
op_complement
id|UHCI_PTR_TERM
)paren
suffix:semicolon
singleline_comment|// arm QH
r_if
c_cond
(paren
op_logical_neg
id|bulk_urb
)paren
(brace
singleline_comment|// new bulk queue&t;
r_if
c_cond
(paren
id|urb-&gt;transfer_flags
op_amp
id|USB_QUEUE_BULK
)paren
(brace
id|spin_lock
(paren
op_amp
id|uhci-&gt;td_lock
)paren
suffix:semicolon
singleline_comment|// both QHs in one go
id|insert_qh
(paren
id|uhci
comma
id|uhci-&gt;chain_end
comma
id|qh
comma
l_int|0
)paren
suffix:semicolon
singleline_comment|// Main QH
id|insert_qh
(paren
id|uhci
comma
id|uhci-&gt;chain_end
comma
id|nqh
comma
l_int|0
)paren
suffix:semicolon
singleline_comment|// Helper QH
id|spin_unlock
(paren
op_amp
id|uhci-&gt;td_lock
)paren
suffix:semicolon
)brace
r_else
id|insert_qh
(paren
id|uhci
comma
id|uhci-&gt;chain_end
comma
id|qh
comma
l_int|0
)paren
suffix:semicolon
)brace
singleline_comment|//dbg(&quot;uhci_submit_bulk_urb: exit&bslash;n&quot;);
r_return
l_int|0
suffix:semicolon
id|fail_unmap_enomem
suffix:colon
id|delete_qh
c_func
(paren
id|uhci
comma
id|qh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bqh
)paren
id|delete_qh
c_func
(paren
id|uhci
comma
id|bqh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bulk_urb
op_logical_and
id|nqh
)paren
id|delete_qh
c_func
(paren
id|uhci
comma
id|nqh
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*---------------------------------------------------------------------------*/
singleline_comment|// submits USB interrupt (ie. polling ;-) 
singleline_comment|// ASAP-flag set implicitely
singleline_comment|// if period==0, the transfer is only done once
DECL|function|uhci_submit_int_urb
r_static
r_int
id|uhci_submit_int_urb
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
id|urb_priv_t
op_star
id|urb_priv
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
r_int
id|nint
comma
id|n
suffix:semicolon
id|uhci_desc_t
op_star
id|td
suffix:semicolon
r_int
id|status
comma
id|destination
suffix:semicolon
r_int
id|info
suffix:semicolon
r_int
r_int
id|pipe
op_assign
id|urb-&gt;pipe
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;interval
op_eq
l_int|0
)paren
id|nint
op_assign
l_int|0
suffix:semicolon
r_else
(brace
singleline_comment|// round interval down to 2^n
r_for
c_loop
(paren
id|nint
op_assign
l_int|0
comma
id|n
op_assign
l_int|1
suffix:semicolon
id|nint
op_le
l_int|8
suffix:semicolon
id|nint
op_increment
comma
id|n
op_add_assign
id|n
)paren
r_if
c_cond
(paren
id|urb-&gt;interval
OL
id|n
)paren
(brace
id|urb-&gt;interval
op_assign
id|n
op_div
l_int|2
suffix:semicolon
r_break
suffix:semicolon
)brace
id|nint
op_decrement
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;Rounded interval to %i, chain  %i&quot;
comma
id|urb-&gt;interval
comma
id|nint
)paren
suffix:semicolon
singleline_comment|// remember start frame, just in case...
id|urb-&gt;start_frame
op_assign
id|UHCI_GET_CURRENT_FRAME
(paren
id|uhci
)paren
op_amp
l_int|1023
suffix:semicolon
id|urb-&gt;number_of_packets
op_assign
l_int|1
suffix:semicolon
singleline_comment|// INT allows only one packet
r_if
c_cond
(paren
id|alloc_td
(paren
id|uhci
comma
op_amp
id|td
comma
id|UHCI_PTR_DEPTH
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|status
op_assign
id|TD_CTRL_ACTIVE
op_or
id|TD_CTRL_IOC
op_or
(paren
id|urb-&gt;transfer_flags
op_amp
id|USB_DISABLE_SPD
ques
c_cond
l_int|0
suffix:colon
id|TD_CTRL_SPD
)paren
op_or
(paren
l_int|3
op_lshift
l_int|27
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;dev-&gt;speed
op_eq
id|USB_SPEED_LOW
)paren
id|status
op_or_assign
id|TD_CTRL_LS
suffix:semicolon
id|destination
op_assign
(paren
id|pipe
op_amp
id|PIPE_DEVEP_MASK
)paren
op_or
id|usb_packetid
(paren
id|pipe
)paren
op_or
(paren
(paren
(paren
id|urb-&gt;transfer_buffer_length
op_minus
l_int|1
)paren
op_amp
l_int|0x7ff
)paren
op_lshift
l_int|21
)paren
suffix:semicolon
id|info
op_assign
id|destination
op_or
(paren
id|uhci_get_toggle
(paren
id|urb
)paren
op_lshift
id|TD_TOKEN_TOGGLE
)paren
suffix:semicolon
id|fill_td
(paren
id|td
comma
id|status
comma
id|info
comma
id|urb_priv-&gt;transfer_buffer_dma
)paren
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|td-&gt;desc_list
comma
op_amp
id|urb_priv-&gt;desc_list
)paren
suffix:semicolon
id|queue_urb
(paren
id|uhci
comma
id|urb
)paren
suffix:semicolon
id|insert_td_horizontal
(paren
id|uhci
comma
id|uhci-&gt;int_chain
(braket
id|nint
)braket
comma
id|td
)paren
suffix:semicolon
singleline_comment|// store in INT-TDs
id|uhci_do_toggle
(paren
id|urb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*###########################################################################*/
singleline_comment|//                  ISOCHRONOUS TRANSFERS
multiline_comment|/*###########################################################################*/
singleline_comment|// In case of ASAP iso transfer, search the URB-list for already queued URBs
singleline_comment|// for this EP and calculate the earliest start frame for the new
singleline_comment|// URB (easy seamless URB continuation!)
DECL|function|find_iso_limits
r_static
r_int
id|find_iso_limits
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
r_int
op_star
id|start
comma
r_int
r_int
op_star
id|end
)paren
(brace
r_struct
id|urb
op_star
id|u
comma
op_star
id|last_urb
op_assign
l_int|NULL
suffix:semicolon
id|urb_priv_t
op_star
id|priv
suffix:semicolon
r_struct
id|list_head
op_star
id|p
suffix:semicolon
r_int
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|uhci-&gt;urb_list_lock
comma
id|flags
)paren
suffix:semicolon
id|p
op_assign
id|uhci-&gt;urb_list.prev
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|p
op_ne
op_amp
id|uhci-&gt;urb_list
suffix:semicolon
id|p
op_assign
id|p-&gt;prev
)paren
(brace
id|priv
op_assign
id|list_entry
(paren
id|p
comma
id|urb_priv_t
comma
id|urb_list
)paren
suffix:semicolon
id|u
op_assign
id|priv-&gt;urb
suffix:semicolon
singleline_comment|// look for pending URBs with identical pipe handle
singleline_comment|// works only because iso doesn&squot;t toggle the data bit!
r_if
c_cond
(paren
(paren
id|urb-&gt;pipe
op_eq
id|u-&gt;pipe
)paren
op_logical_and
(paren
id|urb-&gt;dev
op_eq
id|u-&gt;dev
)paren
op_logical_and
(paren
id|u-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|last_urb
)paren
op_star
id|start
op_assign
id|u-&gt;start_frame
suffix:semicolon
id|last_urb
op_assign
id|u
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|last_urb
)paren
(brace
op_star
id|end
op_assign
(paren
id|last_urb-&gt;start_frame
op_plus
id|last_urb-&gt;number_of_packets
)paren
op_amp
l_int|1023
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|uhci-&gt;urb_list_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------*/
singleline_comment|// adjust start_frame according to scheduling constraints (ASAP etc)
DECL|function|iso_find_start
r_static
r_int
id|iso_find_start
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
r_int
id|now
suffix:semicolon
r_int
r_int
id|start_limit
op_assign
l_int|0
comma
id|stop_limit
op_assign
l_int|0
comma
id|queued_size
suffix:semicolon
r_int
id|limits
suffix:semicolon
id|now
op_assign
id|UHCI_GET_CURRENT_FRAME
(paren
id|uhci
)paren
op_amp
l_int|1023
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|urb-&gt;number_of_packets
OG
l_int|900
)paren
r_return
op_minus
id|EFBIG
suffix:semicolon
id|limits
op_assign
id|find_iso_limits
(paren
id|uhci
comma
id|urb
comma
op_amp
id|start_limit
comma
op_amp
id|stop_limit
)paren
suffix:semicolon
id|queued_size
op_assign
(paren
id|stop_limit
op_minus
id|start_limit
)paren
op_amp
l_int|1023
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;transfer_flags
op_amp
id|USB_ISO_ASAP
)paren
(brace
singleline_comment|// first iso
r_if
c_cond
(paren
id|limits
)paren
(brace
singleline_comment|// 10ms setup should be enough //FIXME!
id|urb-&gt;start_frame
op_assign
(paren
id|now
op_plus
l_int|10
)paren
op_amp
l_int|1023
suffix:semicolon
)brace
r_else
(brace
id|urb-&gt;start_frame
op_assign
id|stop_limit
suffix:semicolon
singleline_comment|// seamless linkage
r_if
c_cond
(paren
(paren
(paren
id|now
op_minus
id|urb-&gt;start_frame
)paren
op_amp
l_int|1023
)paren
op_le
(paren
r_int
)paren
id|urb-&gt;number_of_packets
)paren
(brace
id|info
c_func
(paren
l_string|&quot;iso_find_start: gap in seamless isochronous scheduling&quot;
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;iso_find_start: now %u start_frame %u number_of_packets %u pipe 0x%08x&quot;
comma
id|now
comma
id|urb-&gt;start_frame
comma
id|urb-&gt;number_of_packets
comma
id|urb-&gt;pipe
)paren
suffix:semicolon
id|urb-&gt;start_frame
op_assign
(paren
id|now
op_plus
l_int|5
)paren
op_amp
l_int|1023
suffix:semicolon
singleline_comment|// 5ms setup should be enough
)brace
)brace
)brace
r_else
(brace
id|urb-&gt;start_frame
op_and_assign
l_int|1023
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|now
op_minus
id|urb-&gt;start_frame
)paren
op_amp
l_int|1023
)paren
OL
(paren
r_int
)paren
id|urb-&gt;number_of_packets
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;iso_find_start: now between start_frame and end&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
)brace
multiline_comment|/* check if either start_frame or start_frame+number_of_packets-1 lies between start_limit and stop_limit */
r_if
c_cond
(paren
id|limits
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|urb-&gt;start_frame
op_minus
id|start_limit
)paren
op_amp
l_int|1023
)paren
OL
id|queued_size
op_logical_or
(paren
(paren
id|urb-&gt;start_frame
op_plus
id|urb-&gt;number_of_packets
op_minus
l_int|1
op_minus
id|start_limit
)paren
op_amp
l_int|1023
)paren
OL
id|queued_size
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;iso_find_start: start_frame %u number_of_packets %u start_limit %u stop_limit %u&quot;
comma
id|urb-&gt;start_frame
comma
id|urb-&gt;number_of_packets
comma
id|start_limit
comma
id|stop_limit
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------*/
DECL|function|uhci_submit_iso_urb
r_static
r_int
id|uhci_submit_iso_urb
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|mem_flags
)paren
(brace
id|urb_priv_t
op_star
id|urb_priv
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
r_int
id|n
op_assign
l_int|0
comma
id|i
comma
id|ret
comma
id|last
op_assign
l_int|0
suffix:semicolon
id|uhci_desc_t
op_star
id|td
comma
op_star
op_star
id|tdm
suffix:semicolon
r_int
id|status
comma
id|destination
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|tdm
op_assign
(paren
id|uhci_desc_t
op_star
op_star
)paren
id|kmalloc
(paren
id|urb-&gt;number_of_packets
op_star
r_sizeof
(paren
id|uhci_desc_t
op_star
)paren
comma
id|mem_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tdm
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|tdm
comma
l_int|0
comma
id|urb-&gt;number_of_packets
op_star
r_sizeof
(paren
id|uhci_desc_t
op_star
)paren
)paren
suffix:semicolon
singleline_comment|// First try to get all TDs. Cause: Removing already inserted TDs can only be done 
singleline_comment|// racefree in three steps: unlink TDs, wait one frame, delete TDs. 
singleline_comment|// So, this solutions seems simpler...
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|n
op_increment
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;n:%d urb-&gt;iso_frame_desc[n].length:%d&quot;
comma
id|n
comma
id|urb-&gt;iso_frame_desc
(braket
id|n
)braket
dot
id|length
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb-&gt;iso_frame_desc
(braket
id|n
)braket
dot
id|length
)paren
r_continue
suffix:semicolon
singleline_comment|// allows ISO striping by setting length to zero in iso_descriptor
r_if
c_cond
(paren
id|alloc_td
(paren
id|uhci
comma
op_amp
id|td
comma
id|UHCI_PTR_DEPTH
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|fail_unmap_tds
suffix:semicolon
)brace
id|last
op_assign
id|n
suffix:semicolon
id|tdm
(braket
id|n
)braket
op_assign
id|td
suffix:semicolon
)brace
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
singleline_comment|// Disable IRQs to schedule all ISO-TDs in time
id|ret
op_assign
id|iso_find_start
(paren
id|uhci
comma
id|urb
)paren
suffix:semicolon
singleline_comment|// adjusts urb-&gt;start_frame for later use
r_if
c_cond
(paren
id|ret
)paren
(brace
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|n
op_assign
id|urb-&gt;number_of_packets
suffix:semicolon
r_goto
id|fail_unmap_tds
suffix:semicolon
)brace
id|status
op_assign
id|TD_CTRL_ACTIVE
op_or
id|TD_CTRL_IOS
suffix:semicolon
id|destination
op_assign
(paren
id|urb-&gt;pipe
op_amp
id|PIPE_DEVEP_MASK
)paren
op_or
id|usb_packetid
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
singleline_comment|// Queue all allocated TDs
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|n
op_increment
)paren
(brace
id|td
op_assign
id|tdm
(braket
id|n
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|td
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|n
op_eq
id|last
)paren
(brace
id|status
op_or_assign
id|TD_CTRL_IOC
suffix:semicolon
id|queue_urb
(paren
id|uhci
comma
id|urb
)paren
suffix:semicolon
)brace
id|fill_td
(paren
id|td
comma
id|status
comma
id|destination
op_or
(paren
(paren
(paren
id|urb-&gt;iso_frame_desc
(braket
id|n
)braket
dot
id|length
op_minus
l_int|1
)paren
op_amp
l_int|0x7ff
)paren
op_lshift
l_int|21
)paren
comma
id|urb_priv-&gt;transfer_buffer_dma
op_plus
id|urb-&gt;iso_frame_desc
(braket
id|n
)braket
dot
id|offset
)paren
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|td-&gt;desc_list
comma
op_amp
id|urb_priv-&gt;desc_list
)paren
suffix:semicolon
id|insert_td_horizontal
(paren
id|uhci
comma
id|uhci-&gt;iso_td
(braket
(paren
id|urb-&gt;start_frame
op_plus
id|n
)paren
op_amp
l_int|1023
)braket
comma
id|td
)paren
suffix:semicolon
singleline_comment|// store in iso-tds
)brace
id|kfree
(paren
id|tdm
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;ISO-INT# %i, start %i, now %i&quot;
comma
id|urb-&gt;number_of_packets
comma
id|urb-&gt;start_frame
comma
id|UHCI_GET_CURRENT_FRAME
(paren
id|uhci
)paren
op_amp
l_int|1023
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
singleline_comment|// Cleanup allocated TDs
id|fail_unmap_tds
suffix:colon
id|dbg
c_func
(paren
l_string|&quot;ISO failed, free %i, ret %i&quot;
comma
id|n
comma
id|ret
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|tdm
(braket
id|i
)braket
)paren
id|delete_desc
c_func
(paren
id|uhci
comma
id|tdm
(braket
id|i
)braket
)paren
suffix:semicolon
id|kfree
(paren
id|tdm
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*###########################################################################*/
singleline_comment|//                        URB UNLINK PROCESSING
multiline_comment|/*###########################################################################*/
DECL|function|uhci_clean_iso_step1
r_static
r_void
id|uhci_clean_iso_step1
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
id|urb_priv_t
op_star
id|urb_priv
)paren
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
id|uhci_desc_t
op_star
id|td
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;uhci_clean_iso_step1&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|urb_priv-&gt;desc_list.next
suffix:semicolon
id|p
op_ne
op_amp
id|urb_priv-&gt;desc_list
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
id|td
op_assign
id|list_entry
(paren
id|p
comma
id|uhci_desc_t
comma
id|desc_list
)paren
suffix:semicolon
id|unlink_td
(paren
id|uhci
comma
id|td
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*-------------------------------------------------------------------*/
DECL|function|uhci_clean_iso_step2
r_static
r_void
id|uhci_clean_iso_step2
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
id|urb_priv_t
op_star
id|urb_priv
)paren
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
id|uhci_desc_t
op_star
id|td
suffix:semicolon
r_int
id|now
op_assign
id|UHCI_GET_CURRENT_FRAME
c_func
(paren
id|uhci
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;uhci_clean_iso_step2&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|p
op_assign
id|urb_priv-&gt;desc_list.next
)paren
op_ne
op_amp
id|urb_priv-&gt;desc_list
)paren
(brace
id|td
op_assign
id|list_entry
(paren
id|p
comma
id|uhci_desc_t
comma
id|desc_list
)paren
suffix:semicolon
id|list_del
(paren
id|p
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|td-&gt;horizontal
)paren
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|td-&gt;horizontal
comma
op_amp
id|uhci-&gt;free_desc_td
)paren
suffix:semicolon
id|td-&gt;last_used
op_assign
id|now
suffix:semicolon
)brace
)brace
multiline_comment|/*-------------------------------------------------------------------*/
multiline_comment|/* mode: CLEAN_TRANSFER_NO_DELETION: unlink but no deletion mark (step 1 of async_unlink)&n;         CLEAN_TRANSFER_REGULAR: regular (unlink/delete-mark)&n;         CLEAN_TRANSFER_DELETION_MARK: deletion mark for QH (step 2 of async_unlink)&n; looks a bit complicated because of all the bulk queueing goodies&n;*/
DECL|function|uhci_clean_transfer
r_static
r_void
id|uhci_clean_transfer
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
comma
id|uhci_desc_t
op_star
id|qh
comma
r_int
id|mode
)paren
(brace
id|uhci_desc_t
op_star
id|bqh
comma
op_star
id|nqh
comma
op_star
id|prevqh
comma
op_star
id|prevtd
suffix:semicolon
id|urb_priv_t
op_star
id|priv
op_assign
(paren
id|urb_priv_t
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
r_int
id|now
op_assign
id|UHCI_GET_CURRENT_FRAME
c_func
(paren
id|uhci
)paren
suffix:semicolon
id|bqh
op_assign
id|priv-&gt;bottom_qh
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|priv-&gt;next_queued_urb
)paren
(brace
singleline_comment|// no more appended bulk queues
id|queue_dbg
c_func
(paren
l_string|&quot;uhci_clean_transfer: No more bulks for urb %p, qh %p, bqh %p, nqh %p&quot;
comma
id|urb
comma
id|qh
comma
id|bqh
comma
id|priv-&gt;next_qh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;prev_queued_urb
op_logical_and
id|mode
op_ne
id|CLEAN_TRANSFER_DELETION_MARK
)paren
(brace
singleline_comment|// qh not top of the queue
r_int
r_int
id|flags
suffix:semicolon
id|urb_priv_t
op_star
id|ppriv
op_assign
(paren
id|urb_priv_t
op_star
)paren
id|priv-&gt;prev_queued_urb-&gt;hcpriv
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|uhci-&gt;qh_lock
comma
id|flags
)paren
suffix:semicolon
id|prevqh
op_assign
id|list_entry
(paren
id|ppriv-&gt;desc_list.next
comma
id|uhci_desc_t
comma
id|desc_list
)paren
suffix:semicolon
id|prevtd
op_assign
id|list_entry
(paren
id|prevqh-&gt;vertical.prev
comma
id|uhci_desc_t
comma
id|vertical
)paren
suffix:semicolon
id|set_td_link
c_func
(paren
id|prevtd
comma
id|priv-&gt;bottom_qh-&gt;dma_addr
op_or
id|UHCI_PTR_QH
)paren
suffix:semicolon
singleline_comment|// skip current qh
id|mb
c_func
(paren
)paren
suffix:semicolon
id|queue_dbg
c_func
(paren
l_string|&quot;uhci_clean_transfer: relink pqh %p, ptd %p&quot;
comma
id|prevqh
comma
id|prevtd
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|uhci-&gt;qh_lock
comma
id|flags
)paren
suffix:semicolon
id|ppriv-&gt;bottom_qh
op_assign
id|priv-&gt;bottom_qh
suffix:semicolon
id|ppriv-&gt;next_queued_urb
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// queue is dead, qh is top of the queue
r_if
c_cond
(paren
id|mode
op_ne
id|CLEAN_TRANSFER_DELETION_MARK
)paren
id|unlink_qh
c_func
(paren
id|uhci
comma
id|qh
)paren
suffix:semicolon
singleline_comment|// remove qh from horizontal chain
r_if
c_cond
(paren
id|bqh
)paren
(brace
singleline_comment|// remove remainings of bulk queue
id|nqh
op_assign
id|priv-&gt;next_qh
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_ne
id|CLEAN_TRANSFER_DELETION_MARK
)paren
id|unlink_qh
c_func
(paren
id|uhci
comma
id|nqh
)paren
suffix:semicolon
singleline_comment|// remove nqh from horizontal chain
r_if
c_cond
(paren
id|mode
op_ne
id|CLEAN_TRANSFER_NO_DELETION
)paren
(brace
singleline_comment|// add helper QHs to free desc list
id|nqh-&gt;last_used
op_assign
id|bqh-&gt;last_used
op_assign
id|now
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|nqh-&gt;horizontal
comma
op_amp
id|uhci-&gt;free_desc_qh
)paren
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|bqh-&gt;horizontal
comma
op_amp
id|uhci-&gt;free_desc_qh
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
(brace
singleline_comment|// there are queued urbs following
id|queue_dbg
c_func
(paren
l_string|&quot;uhci_clean_transfer: urb %p, prevurb %p, nexturb %p, qh %p, bqh %p, nqh %p&quot;
comma
id|urb
comma
id|priv-&gt;prev_queued_urb
comma
id|priv-&gt;next_queued_urb
comma
id|qh
comma
id|bqh
comma
id|priv-&gt;next_qh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_ne
id|CLEAN_TRANSFER_DELETION_MARK
)paren
(brace
singleline_comment|// no work for cleanup at unlink-completion
r_struct
id|urb
op_star
id|nurb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|nurb
op_assign
id|priv-&gt;next_queued_urb
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|uhci-&gt;qh_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|priv-&gt;prev_queued_urb
)paren
(brace
singleline_comment|// top QH
id|prevqh
op_assign
id|list_entry
(paren
id|qh-&gt;horizontal.prev
comma
id|uhci_desc_t
comma
id|horizontal
)paren
suffix:semicolon
id|set_qh_head
c_func
(paren
id|prevqh
comma
id|bqh-&gt;dma_addr
op_or
id|UHCI_PTR_QH
)paren
suffix:semicolon
id|list_del
(paren
op_amp
id|qh-&gt;horizontal
)paren
suffix:semicolon
singleline_comment|// remove this qh from horizontal chain
id|list_add
(paren
op_amp
id|bqh-&gt;horizontal
comma
op_amp
id|prevqh-&gt;horizontal
)paren
suffix:semicolon
singleline_comment|// insert next bqh in horizontal chain
)brace
r_else
(brace
singleline_comment|// intermediate QH
id|urb_priv_t
op_star
id|ppriv
op_assign
(paren
id|urb_priv_t
op_star
)paren
id|priv-&gt;prev_queued_urb-&gt;hcpriv
suffix:semicolon
id|urb_priv_t
op_star
id|npriv
op_assign
(paren
id|urb_priv_t
op_star
)paren
id|nurb-&gt;hcpriv
suffix:semicolon
id|uhci_desc_t
op_star
id|bnqh
suffix:semicolon
id|bnqh
op_assign
id|list_entry
(paren
id|npriv-&gt;desc_list.next
comma
id|uhci_desc_t
comma
id|desc_list
)paren
suffix:semicolon
id|ppriv-&gt;bottom_qh
op_assign
id|bnqh
suffix:semicolon
id|ppriv-&gt;next_queued_urb
op_assign
id|nurb
suffix:semicolon
id|prevqh
op_assign
id|list_entry
(paren
id|ppriv-&gt;desc_list.next
comma
id|uhci_desc_t
comma
id|desc_list
)paren
suffix:semicolon
id|set_qh_head
c_func
(paren
id|prevqh
comma
id|bqh-&gt;dma_addr
op_or
id|UHCI_PTR_QH
)paren
suffix:semicolon
)brace
id|mb
c_func
(paren
)paren
suffix:semicolon
(paren
(paren
id|urb_priv_t
op_star
)paren
id|nurb-&gt;hcpriv
)paren
op_member_access_from_pointer
id|prev_queued_urb
op_assign
id|priv-&gt;prev_queued_urb
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|uhci-&gt;qh_lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|mode
op_ne
id|CLEAN_TRANSFER_NO_DELETION
)paren
(brace
id|qh-&gt;last_used
op_assign
id|now
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|qh-&gt;horizontal
comma
op_amp
id|uhci-&gt;free_desc_qh
)paren
suffix:semicolon
singleline_comment|// mark qh for later deletion/kfree
)brace
)brace
multiline_comment|/*-------------------------------------------------------------------*/
singleline_comment|// async unlink_urb completion/cleanup work
singleline_comment|// has to be protected by urb_list_lock!
singleline_comment|// features: if set in transfer_flags, the resulting status of the killed
singleline_comment|// transaction is not overwritten
DECL|function|uhci_cleanup_unlink
r_static
r_void
id|uhci_cleanup_unlink
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_int
id|force
)paren
(brace
r_struct
id|list_head
op_star
id|q
suffix:semicolon
r_struct
id|urb
op_star
id|urb
suffix:semicolon
id|urb_priv_t
op_star
id|urb_priv
suffix:semicolon
r_int
id|type
comma
id|now
op_assign
id|UHCI_GET_CURRENT_FRAME
c_func
(paren
id|uhci
)paren
suffix:semicolon
id|q
op_assign
id|uhci-&gt;urb_unlinked.next
suffix:semicolon
r_while
c_loop
(paren
id|q
op_ne
op_amp
id|uhci-&gt;urb_unlinked
)paren
(brace
id|urb_priv
op_assign
id|list_entry
(paren
id|q
comma
id|urb_priv_t
comma
id|urb_list
)paren
suffix:semicolon
id|urb
op_assign
id|urb_priv-&gt;urb
suffix:semicolon
id|q
op_assign
id|urb_priv-&gt;urb_list.next
suffix:semicolon
r_if
c_cond
(paren
id|force
op_logical_or
(paren
(paren
id|urb_priv-&gt;started
op_ne
op_complement
l_int|0
)paren
op_logical_and
(paren
id|urb_priv-&gt;started
op_ne
id|now
)paren
)paren
)paren
(brace
id|async_dbg
c_func
(paren
l_string|&quot;async cleanup %p&quot;
comma
id|urb
)paren
suffix:semicolon
id|type
op_assign
id|usb_pipetype
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
singleline_comment|// process descriptors
r_case
id|PIPE_CONTROL
suffix:colon
singleline_comment|//&t;&t;&t;&t;usb_show_device(urb-&gt;dev);
id|process_transfer
(paren
id|uhci
comma
id|urb
comma
id|CLEAN_TRANSFER_DELETION_MARK
)paren
suffix:semicolon
singleline_comment|// don&squot;t unlink (already done)
singleline_comment|//&t;&t;&t;&t;usb_show_device(urb-&gt;dev);
r_break
suffix:semicolon
r_case
id|PIPE_BULK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|uhci-&gt;avoid_bulk.counter
)paren
id|process_transfer
(paren
id|uhci
comma
id|urb
comma
id|CLEAN_TRANSFER_DELETION_MARK
)paren
suffix:semicolon
singleline_comment|// don&squot;t unlink (already done)
r_else
r_continue
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_ISOCHRONOUS
suffix:colon
id|process_iso
(paren
id|uhci
comma
id|urb
comma
id|PROCESS_ISO_FORCE
)paren
suffix:semicolon
singleline_comment|// force, don&squot;t unlink
r_break
suffix:semicolon
r_case
id|PIPE_INTERRUPT
suffix:colon
id|process_interrupt
(paren
id|uhci
comma
id|urb
comma
id|PROCESS_INT_REMOVE
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|list_del
(paren
op_amp
id|urb_priv-&gt;urb_list
)paren
suffix:semicolon
id|uhci_urb_dma_sync
c_func
(paren
id|uhci
comma
id|urb
comma
id|urb_priv
)paren
suffix:semicolon
singleline_comment|// clean up descriptors for INT/ISO
singleline_comment|//&t;&t;&t;if (type==PIPE_ISOCHRONOUS || type==PIPE_INTERRUPT) 
singleline_comment|//&t;&t;&t;&t;uhci_clean_iso_step2(uhci, urb_priv);
id|uhci_free_priv
c_func
(paren
id|uhci
comma
id|urb
comma
id|urb_priv
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|urb-&gt;transfer_flags
op_amp
id|USB_TIMEOUT_KILLED
)paren
)paren
id|urb-&gt;status
op_assign
op_minus
id|ENOENT
suffix:semicolon
singleline_comment|// now the urb is really dead
id|spin_unlock
c_func
(paren
op_amp
id|uhci-&gt;urb_list_lock
)paren
suffix:semicolon
id|usb_hcd_giveback_urb
c_func
(paren
op_amp
id|uhci-&gt;hcd
comma
id|urb
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|uhci-&gt;urb_list_lock
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*-------------------------------------------------------------------*/
multiline_comment|/* needs urb_list_lock!&n;   mode: UNLINK_ASYNC_STORE_URB: unlink and move URB into unlinked list&n;         UNLINK_ASYNC_DONT_STORE: unlink, don&squot;t move URB into unlinked list&n;*/
DECL|function|uhci_unlink_urb_async
r_static
r_int
id|uhci_unlink_urb_async
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|mode
)paren
(brace
id|uhci_desc_t
op_star
id|qh
suffix:semicolon
id|urb_priv_t
op_star
id|urb_priv
suffix:semicolon
id|async_dbg
c_func
(paren
l_string|&quot;unlink_urb_async called %p&quot;
comma
id|urb
)paren
suffix:semicolon
id|urb_priv
op_assign
(paren
id|urb_priv_t
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
r_if
c_cond
(paren
id|urb_priv
op_eq
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;hc_priv for URB %p is zero!&quot;
comma
id|urb
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|urb_priv-&gt;started
op_assign
op_complement
l_int|0
suffix:semicolon
singleline_comment|// mark
id|dequeue_urb
(paren
id|uhci
comma
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_eq
id|UNLINK_ASYNC_STORE_URB
)paren
id|list_add_tail
(paren
op_amp
id|urb_priv-&gt;urb_list
comma
op_amp
id|uhci-&gt;urb_unlinked
)paren
suffix:semicolon
singleline_comment|// store urb
id|uhci_switch_timer_int
c_func
(paren
id|uhci
)paren
suffix:semicolon
id|uhci-&gt;unlink_urb_done
op_assign
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|usb_pipetype
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
r_case
id|PIPE_INTERRUPT
suffix:colon
id|uhci_do_toggle
(paren
id|urb
)paren
suffix:semicolon
r_case
id|PIPE_ISOCHRONOUS
suffix:colon
id|uhci_clean_iso_step1
(paren
id|uhci
comma
id|urb_priv
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_BULK
suffix:colon
r_case
id|PIPE_CONTROL
suffix:colon
id|qh
op_assign
id|list_entry
(paren
id|urb_priv-&gt;desc_list.next
comma
id|uhci_desc_t
comma
id|desc_list
)paren
suffix:semicolon
id|uhci_clean_transfer
(paren
id|uhci
comma
id|urb
comma
id|qh
comma
id|CLEAN_TRANSFER_NO_DELETION
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|urb_priv-&gt;started
op_assign
id|UHCI_GET_CURRENT_FRAME
c_func
(paren
id|uhci
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
singleline_comment|// completion will follow
)brace
multiline_comment|/*-------------------------------------------------------------------*/
singleline_comment|// kills an urb by unlinking descriptors and waiting for at least one frame
DECL|function|uhci_unlink_urb_sync
r_static
r_int
id|uhci_unlink_urb_sync
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
id|uhci_desc_t
op_star
id|qh
suffix:semicolon
id|urb_priv_t
op_star
id|urb_priv
suffix:semicolon
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|uhci-&gt;urb_list_lock
comma
id|flags
)paren
suffix:semicolon
singleline_comment|//&t;err(&quot;uhci_unlink_urb_sync %p, %i&quot;,urb,urb-&gt;status);
singleline_comment|// move descriptors out the the running chains, dequeue urb
id|uhci_unlink_urb_async
c_func
(paren
id|uhci
comma
id|urb
comma
id|UNLINK_ASYNC_DONT_STORE
)paren
suffix:semicolon
id|urb_priv
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|uhci-&gt;urb_list_lock
comma
id|flags
)paren
suffix:semicolon
singleline_comment|// cleanup the rest
r_switch
c_cond
(paren
id|usb_pipetype
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
r_case
id|PIPE_INTERRUPT
suffix:colon
r_case
id|PIPE_ISOCHRONOUS
suffix:colon
id|uhci_wait_ms
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|uhci_clean_iso_step2
c_func
(paren
id|uhci
comma
id|urb_priv
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_BULK
suffix:colon
r_case
id|PIPE_CONTROL
suffix:colon
id|qh
op_assign
id|list_entry
(paren
id|urb_priv-&gt;desc_list.next
comma
id|uhci_desc_t
comma
id|desc_list
)paren
suffix:semicolon
id|uhci_clean_transfer
c_func
(paren
id|uhci
comma
id|urb
comma
id|qh
comma
id|CLEAN_TRANSFER_DELETION_MARK
)paren
suffix:semicolon
id|uhci_wait_ms
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|urb-&gt;status
op_assign
op_minus
id|ENOENT
suffix:semicolon
singleline_comment|// mark urb as killed&t;&t;
id|finish_urb
c_func
(paren
id|uhci
comma
id|urb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------*/
singleline_comment|// unlink urbs for specific device or all devices
DECL|function|uhci_unlink_urbs
r_static
r_void
id|uhci_unlink_urbs
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|usb_device
op_star
id|usb_dev
comma
r_int
id|remove_all
)paren
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
r_struct
id|list_head
op_star
id|p2
suffix:semicolon
r_struct
id|urb
op_star
id|urb
suffix:semicolon
id|urb_priv_t
op_star
id|priv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|uhci-&gt;urb_list_lock
comma
id|flags
)paren
suffix:semicolon
id|p
op_assign
id|uhci-&gt;urb_list.prev
suffix:semicolon
r_while
c_loop
(paren
id|p
op_ne
op_amp
id|uhci-&gt;urb_list
)paren
(brace
id|p2
op_assign
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;prev
suffix:semicolon
id|priv
op_assign
id|list_entry
(paren
id|p2
comma
id|urb_priv_t
comma
id|urb_list
)paren
suffix:semicolon
id|urb
op_assign
id|priv-&gt;urb
suffix:semicolon
singleline_comment|//&t;&t;err(&quot;unlink urb: %p, dev %p, ud %p&quot;, urb, usb_dev,urb-&gt;dev);
singleline_comment|//urb-&gt;transfer_flags |=USB_ASYNC_UNLINK;
r_if
c_cond
(paren
id|remove_all
op_logical_or
(paren
id|usb_dev
op_eq
id|urb-&gt;dev
)paren
)paren
(brace
id|spin_unlock_irqrestore
(paren
op_amp
id|uhci-&gt;urb_list_lock
comma
id|flags
)paren
suffix:semicolon
id|err
c_func
(paren
l_string|&quot;forced removing of queued URB %p due to disconnect&quot;
comma
id|urb
)paren
suffix:semicolon
id|uhci_urb_dequeue
c_func
(paren
op_amp
id|uhci-&gt;hcd
comma
id|urb
)paren
suffix:semicolon
id|urb-&gt;dev
op_assign
l_int|NULL
suffix:semicolon
singleline_comment|// avoid further processing of this URB
id|spin_lock_irqsave
(paren
op_amp
id|uhci-&gt;urb_list_lock
comma
id|flags
)paren
suffix:semicolon
id|p
op_assign
id|uhci-&gt;urb_list.prev
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|uhci-&gt;urb_list_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------*/
singleline_comment|// Checks for URB timeout and removes bandwidth reclamation if URB idles too long
DECL|function|uhci_check_timeouts
r_static
r_void
id|uhci_check_timeouts
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
)paren
(brace
r_struct
id|list_head
op_star
id|p
comma
op_star
id|p2
suffix:semicolon
r_struct
id|urb
op_star
id|urb
suffix:semicolon
r_int
id|type
suffix:semicolon
id|p
op_assign
id|uhci-&gt;urb_list.prev
suffix:semicolon
r_while
c_loop
(paren
id|p
op_ne
op_amp
id|uhci-&gt;urb_list
)paren
(brace
id|urb_priv_t
op_star
id|hcpriv
suffix:semicolon
id|p2
op_assign
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;prev
suffix:semicolon
id|hcpriv
op_assign
id|list_entry
(paren
id|p2
comma
id|urb_priv_t
comma
id|urb_list
)paren
suffix:semicolon
id|urb
op_assign
id|hcpriv-&gt;urb
suffix:semicolon
id|type
op_assign
id|usb_pipetype
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;timeout
op_logical_and
id|time_after
c_func
(paren
id|jiffies
comma
id|hcpriv-&gt;started
op_plus
id|urb-&gt;timeout
)paren
)paren
(brace
id|urb-&gt;transfer_flags
op_or_assign
id|USB_TIMEOUT_KILLED
op_or
id|USB_ASYNC_UNLINK
suffix:semicolon
id|async_dbg
c_func
(paren
l_string|&quot;uhci_check_timeout: timeout for %p&quot;
comma
id|urb
)paren
suffix:semicolon
id|uhci_unlink_urb_async
c_func
(paren
id|uhci
comma
id|urb
comma
id|UNLINK_ASYNC_STORE_URB
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_USB_UHCI_HIGH_BANDWIDTH
r_else
r_if
c_cond
(paren
(paren
(paren
id|type
op_eq
id|PIPE_BULK
)paren
op_logical_or
(paren
id|type
op_eq
id|PIPE_CONTROL
)paren
)paren
op_logical_and
(paren
id|hcpriv-&gt;use_loop
)paren
op_logical_and
id|time_after
c_func
(paren
id|jiffies
comma
id|hcpriv-&gt;started
op_plus
id|IDLE_TIMEOUT
)paren
)paren
id|disable_desc_loop
c_func
(paren
id|uhci
comma
id|urb
)paren
suffix:semicolon
macro_line|#endif
)brace
id|uhci-&gt;timeout_check
op_assign
id|jiffies
suffix:semicolon
)brace
multiline_comment|/*###########################################################################*/
singleline_comment|//                        INTERRUPT PROCESSING ROUTINES
multiline_comment|/*###########################################################################*/
multiline_comment|/*&n; * Map status to standard result codes&n; *&n; * &lt;status&gt; is (td-&gt;status &amp; 0xFE0000) [a.k.a. uhci_status_bits(td-&gt;status)&n; * &lt;dir_out&gt; is True for output TDs and False for input TDs.&n; */
DECL|function|uhci_map_status
r_static
r_int
id|uhci_map_status
(paren
r_int
id|status
comma
r_int
id|dir_out
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TD_CTRL_BITSTUFF
)paren
multiline_comment|/* Bitstuff error */
r_return
op_minus
id|EPROTO
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TD_CTRL_CRCTIMEO
)paren
(brace
multiline_comment|/* CRC/Timeout */
r_if
c_cond
(paren
id|dir_out
)paren
r_return
op_minus
id|ETIMEDOUT
suffix:semicolon
r_else
r_return
op_minus
id|EILSEQ
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|TD_CTRL_NAK
)paren
multiline_comment|/* NAK */
r_return
op_minus
id|ETIMEDOUT
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TD_CTRL_BABBLE
)paren
multiline_comment|/* Babble */
r_return
op_minus
id|EOVERFLOW
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TD_CTRL_DBUFERR
)paren
multiline_comment|/* Buffer error */
r_return
op_minus
id|ENOSR
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TD_CTRL_STALLED
)paren
multiline_comment|/* Stalled */
r_return
op_minus
id|EPIPE
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TD_CTRL_ACTIVE
)paren
multiline_comment|/* Active */
r_return
l_int|0
suffix:semicolon
r_return
op_minus
id|EPROTO
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------*/
DECL|function|correct_data_toggles
r_static
r_void
id|correct_data_toggles
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
id|usb_settoggle
(paren
id|urb-&gt;dev
comma
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
comma
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
comma
op_logical_neg
id|uhci_get_toggle
(paren
id|urb
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|urb
)paren
(brace
id|urb_priv_t
op_star
id|priv
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
id|uhci_desc_t
op_star
id|qh
op_assign
id|list_entry
(paren
id|priv-&gt;desc_list.next
comma
id|uhci_desc_t
comma
id|desc_list
)paren
suffix:semicolon
r_struct
id|list_head
op_star
id|p
op_assign
id|qh-&gt;vertical.next
suffix:semicolon
id|uhci_desc_t
op_star
id|td
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;URB to correct %p&bslash;n&quot;
comma
id|urb
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|p
op_ne
op_amp
id|qh-&gt;vertical
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
id|td
op_assign
id|list_entry
(paren
id|p
comma
id|uhci_desc_t
comma
id|vertical
)paren
suffix:semicolon
id|td-&gt;hw.td.info
op_xor_assign
id|cpu_to_le32
c_func
(paren
l_int|1
op_lshift
id|TD_TOKEN_TOGGLE
)paren
suffix:semicolon
)brace
id|urb
op_assign
id|priv-&gt;next_queued_urb
suffix:semicolon
)brace
)brace
multiline_comment|/*-------------------------------------------------------------------*/
multiline_comment|/* &n; * For IN-control transfers, process_transfer gets a bit more complicated,&n; * since there are devices that return less data (eg. strings) than they&n; * have announced. This leads to a queue abort due to the short packet,&n; * the status stage is not executed. If this happens, the status stage&n; * is manually re-executed.&n; * mode: PROCESS_TRANSFER_REGULAR: regular (unlink QH)&n; *       PROCESS_TRANSFER_DONT_UNLINK: QHs already unlinked (for async unlink_urb)&n; */
DECL|function|process_transfer
r_static
r_int
id|process_transfer
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|mode
)paren
(brace
id|urb_priv_t
op_star
id|urb_priv
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
r_struct
id|list_head
op_star
id|qhl
op_assign
id|urb_priv-&gt;desc_list.next
suffix:semicolon
id|uhci_desc_t
op_star
id|qh
op_assign
id|list_entry
(paren
id|qhl
comma
id|uhci_desc_t
comma
id|desc_list
)paren
suffix:semicolon
r_struct
id|list_head
op_star
id|p
op_assign
id|qh-&gt;vertical.next
suffix:semicolon
id|uhci_desc_t
op_star
id|desc
op_assign
id|list_entry
(paren
id|urb_priv-&gt;desc_list.prev
comma
id|uhci_desc_t
comma
id|desc_list
)paren
suffix:semicolon
id|uhci_desc_t
op_star
id|last_desc
op_assign
id|list_entry
(paren
id|desc-&gt;vertical.prev
comma
id|uhci_desc_t
comma
id|vertical
)paren
suffix:semicolon
r_int
id|data_toggle
op_assign
id|uhci_get_toggle
(paren
id|urb
)paren
suffix:semicolon
singleline_comment|// save initial data_toggle
r_int
id|maxlength
suffix:semicolon
singleline_comment|// extracted and remapped info from TD
r_int
id|actual_length
suffix:semicolon
r_int
id|status
op_assign
l_int|0
comma
id|ret
op_assign
l_int|0
suffix:semicolon
singleline_comment|//dbg(&quot;process_transfer: urb %p, urb_priv %p, qh %p last_desc %p&bslash;n&quot;,urb,urb_priv, qh, last_desc);
multiline_comment|/* if the status phase has been retriggered and the&n;&t;   queue is empty or the last status-TD is inactive, the retriggered&n;&t;   status stage is completed&n;&t; */
r_if
c_cond
(paren
id|urb_priv-&gt;flags
op_logical_and
(paren
(paren
id|qh-&gt;hw.qh.element
op_eq
id|cpu_to_le32
c_func
(paren
id|UHCI_PTR_TERM
)paren
)paren
op_logical_or
op_logical_neg
id|is_td_active
c_func
(paren
id|desc
)paren
)paren
)paren
r_goto
id|transfer_finished
suffix:semicolon
id|urb-&gt;actual_length
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|p
op_ne
op_amp
id|qh-&gt;vertical
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
id|desc
op_assign
id|list_entry
(paren
id|p
comma
id|uhci_desc_t
comma
id|vertical
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_td_active
c_func
(paren
id|desc
)paren
)paren
(brace
singleline_comment|// do not process active TDs
r_if
c_cond
(paren
id|mode
op_eq
id|CLEAN_TRANSFER_DELETION_MARK
)paren
singleline_comment|// if called from async_unlink
id|uhci_clean_transfer
c_func
(paren
id|uhci
comma
id|urb
comma
id|qh
comma
id|CLEAN_TRANSFER_DELETION_MARK
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|actual_length
op_assign
id|uhci_actual_length
c_func
(paren
id|desc
)paren
suffix:semicolon
singleline_comment|// extract transfer parameters from TD
id|maxlength
op_assign
(paren
(paren
(paren
id|le32_to_cpu
c_func
(paren
id|desc-&gt;hw.td.info
)paren
op_rshift
l_int|21
)paren
op_amp
l_int|0x7ff
)paren
op_plus
l_int|1
)paren
op_amp
l_int|0x7ff
suffix:semicolon
id|status
op_assign
id|uhci_map_status
(paren
id|uhci_status_bits
(paren
id|le32_to_cpu
c_func
(paren
id|desc-&gt;hw.td.status
)paren
)paren
comma
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
op_minus
id|EPIPE
)paren
(brace
singleline_comment|// see if EP is stalled
singleline_comment|// set up stalled condition
id|usb_endpoint_halt
(paren
id|urb-&gt;dev
comma
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
comma
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_logical_and
(paren
id|status
op_ne
op_minus
id|EPIPE
)paren
op_logical_and
(paren
id|status
op_ne
op_minus
id|EOVERFLOW
)paren
)paren
(brace
singleline_comment|// if any error occurred stop processing of further TDs
singleline_comment|// only set ret if status returned an error
id|ret
op_assign
id|status
suffix:semicolon
id|urb-&gt;error_count
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|le32_to_cpu
c_func
(paren
id|desc-&gt;hw.td.info
)paren
op_amp
l_int|0xff
)paren
op_ne
id|USB_PID_SETUP
)paren
id|urb-&gt;actual_length
op_add_assign
id|actual_length
suffix:semicolon
singleline_comment|// got less data than requested
r_if
c_cond
(paren
(paren
id|actual_length
OL
id|maxlength
)paren
)paren
(brace
r_if
c_cond
(paren
id|urb-&gt;transfer_flags
op_amp
id|USB_DISABLE_SPD
)paren
(brace
id|status
op_assign
op_minus
id|EREMOTEIO
suffix:semicolon
singleline_comment|// treat as real error
id|dbg
c_func
(paren
l_string|&quot;process_transfer: SPD!!&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
singleline_comment|// exit after this TD because SP was detected
)brace
singleline_comment|// short read during control-IN: re-start status stage
r_if
c_cond
(paren
(paren
id|usb_pipetype
(paren
id|urb-&gt;pipe
)paren
op_eq
id|PIPE_CONTROL
)paren
)paren
(brace
r_if
c_cond
(paren
id|uhci_packetid
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|last_desc-&gt;hw.td.info
)paren
)paren
op_eq
id|USB_PID_OUT
)paren
(brace
id|set_qh_element
c_func
(paren
id|qh
comma
id|last_desc-&gt;dma_addr
)paren
suffix:semicolon
singleline_comment|// re-trigger status stage
id|dbg
c_func
(paren
l_string|&quot;short packet during control transfer, retrigger status stage @ %p&quot;
comma
id|last_desc
)paren
suffix:semicolon
id|urb_priv-&gt;flags
op_assign
l_int|1
suffix:semicolon
singleline_comment|// mark as short control packet
r_return
l_int|0
suffix:semicolon
)brace
)brace
singleline_comment|// all other cases: short read is OK
id|data_toggle
op_assign
id|uhci_toggle
(paren
id|le32_to_cpu
c_func
(paren
id|desc-&gt;hw.td.info
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
)paren
(brace
id|ret
op_assign
id|status
suffix:semicolon
id|urb-&gt;error_count
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
id|data_toggle
op_assign
id|uhci_toggle
(paren
id|le32_to_cpu
c_func
(paren
id|desc-&gt;hw.td.info
)paren
)paren
suffix:semicolon
id|queue_dbg
c_func
(paren
l_string|&quot;process_transfer: len:%d status:%x mapped:%x toggle:%d&quot;
comma
id|actual_length
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;hw.td.status
)paren
comma
id|status
comma
id|data_toggle
)paren
suffix:semicolon
)brace
multiline_comment|/* toggle correction for short bulk transfers (nonqueued/queued) */
r_if
c_cond
(paren
id|usb_pipetype
(paren
id|urb-&gt;pipe
)paren
op_eq
id|PIPE_BULK
)paren
(brace
id|urb_priv_t
op_star
id|priv
op_assign
(paren
id|urb_priv_t
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
r_struct
id|urb
op_star
id|next_queued_urb
op_assign
id|priv-&gt;next_queued_urb
suffix:semicolon
r_if
c_cond
(paren
id|next_queued_urb
)paren
(brace
id|urb_priv_t
op_star
id|next_priv
op_assign
(paren
id|urb_priv_t
op_star
)paren
id|next_queued_urb-&gt;hcpriv
suffix:semicolon
id|uhci_desc_t
op_star
id|qh
op_assign
id|list_entry
(paren
id|next_priv-&gt;desc_list.next
comma
id|uhci_desc_t
comma
id|desc_list
)paren
suffix:semicolon
id|uhci_desc_t
op_star
id|first_td
op_assign
id|list_entry
(paren
id|qh-&gt;vertical.next
comma
id|uhci_desc_t
comma
id|vertical
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data_toggle
op_eq
id|uhci_toggle
(paren
id|le32_to_cpu
c_func
(paren
id|first_td-&gt;hw.td.info
)paren
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;process_transfer: fixed toggle&quot;
)paren
suffix:semicolon
id|correct_data_toggles
c_func
(paren
id|next_queued_urb
)paren
suffix:semicolon
)brace
)brace
r_else
id|usb_settoggle
(paren
id|urb-&gt;dev
comma
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
comma
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
comma
op_logical_neg
id|data_toggle
)paren
suffix:semicolon
)brace
id|transfer_finished
suffix:colon
id|uhci_clean_transfer
c_func
(paren
id|uhci
comma
id|urb
comma
id|qh
comma
id|mode
)paren
suffix:semicolon
id|urb-&gt;status
op_assign
id|status
suffix:semicolon
macro_line|#ifdef CONFIG_USB_UHCI_HIGH_BANDWIDTH&t;
id|disable_desc_loop
c_func
(paren
id|uhci
comma
id|urb
)paren
suffix:semicolon
macro_line|#endif&t;
id|dbg
c_func
(paren
l_string|&quot;process_transfer: (end) urb %p, wanted len %d, len %d status %x err %d&quot;
comma
id|urb
comma
id|urb-&gt;transfer_buffer_length
comma
id|urb-&gt;actual_length
comma
id|urb-&gt;status
comma
id|urb-&gt;error_count
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------*/
DECL|function|process_interrupt
r_static
r_int
id|process_interrupt
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|mode
)paren
(brace
id|urb_priv_t
op_star
id|urb_priv
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
r_struct
id|list_head
op_star
id|p
op_assign
id|urb_priv-&gt;desc_list.next
suffix:semicolon
id|uhci_desc_t
op_star
id|desc
op_assign
id|list_entry
(paren
id|urb_priv-&gt;desc_list.prev
comma
id|uhci_desc_t
comma
id|desc_list
)paren
suffix:semicolon
r_int
id|actual_length
comma
id|status
op_assign
l_int|0
comma
id|i
comma
id|ret
op_assign
op_minus
id|EINPROGRESS
suffix:semicolon
singleline_comment|//dbg(&quot;urb contains interrupt request&quot;);
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|p
op_ne
op_amp
id|urb_priv-&gt;desc_list
suffix:semicolon
id|p
op_assign
id|p-&gt;next
comma
id|i
op_increment
)paren
singleline_comment|// Maybe we allow more than one TD later ;-)
(brace
id|desc
op_assign
id|list_entry
(paren
id|p
comma
id|uhci_desc_t
comma
id|desc_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_td_active
c_func
(paren
id|desc
)paren
op_logical_or
op_logical_neg
(paren
id|desc-&gt;hw.td.status
op_amp
id|cpu_to_le32
c_func
(paren
id|TD_CTRL_IOC
)paren
)paren
)paren
(brace
singleline_comment|// do not process active TDs or one-shot TDs (-&gt;no recycling)
singleline_comment|//dbg(&quot;TD ACT Status @%p %08x&quot;,desc,le32_to_cpu(desc-&gt;hw.td.status));
r_break
suffix:semicolon
)brace
singleline_comment|// extract transfer parameters from TD
id|actual_length
op_assign
id|uhci_actual_length
c_func
(paren
id|desc
)paren
suffix:semicolon
id|status
op_assign
id|uhci_map_status
(paren
id|uhci_status_bits
(paren
id|le32_to_cpu
c_func
(paren
id|desc-&gt;hw.td.status
)paren
)paren
comma
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
singleline_comment|// see if EP is stalled
r_if
c_cond
(paren
id|status
op_eq
op_minus
id|EPIPE
)paren
(brace
singleline_comment|// set up stalled condition
id|usb_endpoint_halt
(paren
id|urb-&gt;dev
comma
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
comma
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
)brace
singleline_comment|// if any error occurred: ignore this td, and continue
r_if
c_cond
(paren
id|status
op_ne
l_int|0
)paren
(brace
singleline_comment|//uhci_show_td (desc);
id|urb-&gt;error_count
op_increment
suffix:semicolon
r_goto
id|recycle
suffix:semicolon
)brace
r_else
id|urb-&gt;actual_length
op_assign
id|actual_length
suffix:semicolon
id|recycle
suffix:colon
id|uhci_urb_dma_sync
c_func
(paren
id|uhci
comma
id|urb
comma
id|urb-&gt;hcpriv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;complete
)paren
(brace
singleline_comment|//dbg(&quot;process_interrupt: calling completion, status %i&quot;,status);
id|urb-&gt;status
op_assign
id|status
suffix:semicolon
(paren
(paren
id|urb_priv_t
op_star
)paren
id|urb-&gt;hcpriv
)paren
op_member_access_from_pointer
id|flags
op_assign
l_int|1
suffix:semicolon
singleline_comment|// if unlink_urb is called during completion
id|spin_unlock
c_func
(paren
op_amp
id|uhci-&gt;urb_list_lock
)paren
suffix:semicolon
id|urb-&gt;complete
(paren
(paren
r_struct
id|urb
op_star
)paren
id|urb
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|uhci-&gt;urb_list_lock
)paren
suffix:semicolon
(paren
(paren
id|urb_priv_t
op_star
)paren
id|urb-&gt;hcpriv
)paren
op_member_access_from_pointer
id|flags
op_assign
l_int|0
suffix:semicolon
singleline_comment|// FIXME: unlink in completion not handled...
)brace
r_if
c_cond
(paren
(paren
id|urb-&gt;status
op_ne
op_minus
id|ECONNABORTED
)paren
op_logical_and
(paren
id|urb-&gt;status
op_ne
id|ECONNRESET
)paren
op_logical_and
(paren
id|urb-&gt;status
op_ne
op_minus
id|ENOENT
)paren
)paren
(brace
id|urb-&gt;status
op_assign
op_minus
id|EINPROGRESS
suffix:semicolon
singleline_comment|// Recycle INT-TD if interval!=0, else mark TD as one-shot
r_if
c_cond
(paren
id|urb-&gt;interval
)paren
(brace
id|desc-&gt;hw.td.info
op_and_assign
id|cpu_to_le32
c_func
(paren
op_complement
(paren
l_int|1
op_lshift
id|TD_TOKEN_TOGGLE
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
l_int|0
)paren
(brace
(paren
(paren
id|urb_priv_t
op_star
)paren
id|urb-&gt;hcpriv
)paren
op_member_access_from_pointer
id|started
op_assign
id|jiffies
suffix:semicolon
id|desc-&gt;hw.td.info
op_or_assign
id|cpu_to_le32
c_func
(paren
(paren
id|uhci_get_toggle
(paren
id|urb
)paren
op_lshift
id|TD_TOKEN_TOGGLE
)paren
)paren
suffix:semicolon
id|uhci_do_toggle
(paren
id|urb
)paren
suffix:semicolon
)brace
r_else
(brace
id|desc-&gt;hw.td.info
op_or_assign
id|cpu_to_le32
c_func
(paren
(paren
op_logical_neg
id|uhci_get_toggle
(paren
id|urb
)paren
op_lshift
id|TD_TOKEN_TOGGLE
)paren
)paren
suffix:semicolon
)brace
id|desc-&gt;hw.td.status
op_assign
id|cpu_to_le32
c_func
(paren
id|TD_CTRL_ACTIVE
op_or
id|TD_CTRL_IOC
op_or
(paren
id|urb-&gt;transfer_flags
op_amp
id|USB_DISABLE_SPD
ques
c_cond
l_int|0
suffix:colon
id|TD_CTRL_SPD
)paren
op_or
(paren
l_int|3
op_lshift
l_int|27
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;dev-&gt;speed
op_eq
id|USB_SPEED_LOW
)paren
id|desc-&gt;hw.td.status
op_or_assign
id|__constant_cpu_to_le32
(paren
id|TD_CTRL_LS
)paren
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|uhci_unlink_urb_async
c_func
(paren
id|uhci
comma
id|urb
comma
id|UNLINK_ASYNC_STORE_URB
)paren
suffix:semicolon
id|uhci_do_toggle
(paren
id|urb
)paren
suffix:semicolon
singleline_comment|// correct toggle after unlink
id|clr_td_ioc
c_func
(paren
id|desc
)paren
suffix:semicolon
singleline_comment|// inactivate TD
)brace
)brace
r_if
c_cond
(paren
id|mode
op_eq
id|PROCESS_INT_REMOVE
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|desc-&gt;horizontal
)paren
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|desc-&gt;horizontal
comma
op_amp
id|uhci-&gt;free_desc_td
)paren
suffix:semicolon
id|desc-&gt;last_used
op_assign
id|UHCI_GET_CURRENT_FRAME
c_func
(paren
id|uhci
)paren
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------*/
singleline_comment|// mode: PROCESS_ISO_REGULAR: processing only for done TDs, unlink TDs
singleline_comment|// mode: PROCESS_ISO_FORCE: force processing, don&squot;t unlink TDs (already unlinked)
DECL|function|process_iso
r_static
r_int
id|process_iso
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|mode
)paren
(brace
id|urb_priv_t
op_star
id|urb_priv
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
r_struct
id|list_head
op_star
id|p
op_assign
id|urb_priv-&gt;desc_list.next
comma
op_star
id|p_tmp
suffix:semicolon
id|uhci_desc_t
op_star
id|desc
op_assign
id|list_entry
(paren
id|urb_priv-&gt;desc_list.prev
comma
id|uhci_desc_t
comma
id|desc_list
)paren
suffix:semicolon
r_int
id|i
comma
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|now
op_assign
id|UHCI_GET_CURRENT_FRAME
c_func
(paren
id|uhci
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;urb contains iso request&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_td_active
c_func
(paren
id|desc
)paren
op_logical_and
id|mode
op_eq
id|PROCESS_ISO_REGULAR
)paren
r_return
op_minus
id|EXDEV
suffix:semicolon
singleline_comment|// last TD not finished
id|urb-&gt;error_count
op_assign
l_int|0
suffix:semicolon
id|urb-&gt;actual_length
op_assign
l_int|0
suffix:semicolon
id|urb-&gt;status
op_assign
l_int|0
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;process iso urb %p, %li, %i, %i, %i %08x&quot;
comma
id|urb
comma
id|jiffies
comma
id|UHCI_GET_CURRENT_FRAME
c_func
(paren
id|s
)paren
comma
id|urb-&gt;number_of_packets
comma
id|mode
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;hw.td.status
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|p
op_ne
op_amp
id|urb_priv-&gt;desc_list
suffix:semicolon
id|i
op_increment
)paren
(brace
id|desc
op_assign
id|list_entry
(paren
id|p
comma
id|uhci_desc_t
comma
id|desc_list
)paren
suffix:semicolon
singleline_comment|//uhci_show_td(desc);
r_if
c_cond
(paren
id|is_td_active
c_func
(paren
id|desc
)paren
)paren
(brace
singleline_comment|// means we have completed the last TD, but not the TDs before
id|desc-&gt;hw.td.status
op_and_assign
id|cpu_to_le32
c_func
(paren
op_complement
id|TD_CTRL_ACTIVE
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;TD still active (%x)- grrr. paranoia!&quot;
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;hw.td.status
)paren
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EXDEV
suffix:semicolon
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|status
op_assign
id|ret
suffix:semicolon
id|unlink_td
(paren
id|uhci
comma
id|desc
comma
l_int|1
)paren
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mode
op_eq
id|PROCESS_ISO_REGULAR
)paren
id|unlink_td
(paren
id|uhci
comma
id|desc
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;number_of_packets
op_le
id|i
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;urb-&gt;number_of_packets (%d)&lt;=(%d)&quot;
comma
id|urb-&gt;number_of_packets
comma
id|i
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|actual_length
op_assign
id|uhci_actual_length
c_func
(paren
id|desc
)paren
suffix:semicolon
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|status
op_assign
id|uhci_map_status
(paren
id|uhci_status_bits
(paren
id|le32_to_cpu
c_func
(paren
id|desc-&gt;hw.td.status
)paren
)paren
comma
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
id|urb-&gt;actual_length
op_add_assign
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|actual_length
suffix:semicolon
id|err
suffix:colon
r_if
c_cond
(paren
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|status
op_ne
l_int|0
)paren
(brace
id|urb-&gt;error_count
op_increment
suffix:semicolon
id|urb-&gt;status
op_assign
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|status
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;process_iso: %i: len:%d %08x status:%x&quot;
comma
id|i
comma
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|actual_length
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;hw.td.status
)paren
comma
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|status
)paren
suffix:semicolon
id|p_tmp
op_assign
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
suffix:semicolon
id|list_del
(paren
id|p_tmp
)paren
suffix:semicolon
singleline_comment|//&t;&t;delete_desc (uhci, desc);
singleline_comment|// add to cool down pool
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|desc-&gt;horizontal
)paren
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|desc-&gt;horizontal
comma
op_amp
id|uhci-&gt;free_desc_td
)paren
suffix:semicolon
id|desc-&gt;last_used
op_assign
id|now
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;process_iso: exit %i (%d), actual_len %i&quot;
comma
id|i
comma
id|ret
comma
id|urb-&gt;actual_length
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------*/
singleline_comment|// called with urb_list_lock set
DECL|function|process_urb
r_static
r_int
id|process_urb
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
comma
r_struct
id|list_head
op_star
id|p
)paren
(brace
r_struct
id|urb
op_star
id|urb
comma
op_star
id|urbt
suffix:semicolon
r_struct
id|usb_device
op_star
id|usb_dev
suffix:semicolon
id|urb_priv_t
op_star
id|priv
suffix:semicolon
r_int
id|type
comma
id|n
comma
id|ret
op_assign
l_int|0
suffix:semicolon
id|priv
op_assign
id|list_entry
(paren
id|p
comma
id|urb_priv_t
comma
id|urb_list
)paren
suffix:semicolon
id|urb
op_assign
id|priv-&gt;urb
suffix:semicolon
singleline_comment|//&t;dbg(&quot;process_urb p %p, udev %p&quot;,urb, urb-&gt;dev);
id|type
op_assign
id|usb_pipetype
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|PIPE_CONTROL
suffix:colon
id|ret
op_assign
id|process_transfer
(paren
id|uhci
comma
id|urb
comma
id|CLEAN_TRANSFER_REGULAR
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_BULK
suffix:colon
singleline_comment|// if a submit is fiddling with bulk queues, ignore it for now
r_if
c_cond
(paren
op_logical_neg
id|uhci-&gt;avoid_bulk.counter
)paren
id|ret
op_assign
id|process_transfer
(paren
id|uhci
comma
id|urb
comma
id|CLEAN_TRANSFER_REGULAR
)paren
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_ISOCHRONOUS
suffix:colon
id|ret
op_assign
id|process_iso
(paren
id|uhci
comma
id|urb
comma
id|PROCESS_ISO_REGULAR
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_INTERRUPT
suffix:colon
id|ret
op_assign
id|process_interrupt
(paren
id|uhci
comma
id|urb
comma
id|PROCESS_INT_REGULAR
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|urb-&gt;status
op_ne
op_minus
id|EINPROGRESS
)paren
(brace
id|dequeue_urb
(paren
id|uhci
comma
id|urb
)paren
suffix:semicolon
id|uhci_free_priv
c_func
(paren
id|uhci
comma
id|urb
comma
id|urb-&gt;hcpriv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|PIPE_INTERRUPT
)paren
(brace
singleline_comment|// process_interrupt does completion on its own&t;&t;
singleline_comment|// FIXME: How to detect killed URBs in a ring?&t;&t;&t;
r_if
c_cond
(paren
id|type
op_eq
id|PIPE_ISOCHRONOUS
)paren
(brace
r_for
c_loop
(paren
id|n
op_assign
l_int|0
comma
id|urbt
op_assign
id|urb-&gt;next
suffix:semicolon
id|urbt
op_logical_and
(paren
id|urbt
op_ne
id|urb
)paren
op_logical_and
(paren
id|n
OL
id|MAX_NEXT_COUNT
)paren
suffix:semicolon
id|urbt
op_assign
id|urbt-&gt;next
comma
id|n
op_increment
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|urbt
op_logical_and
(paren
id|n
OL
id|MAX_NEXT_COUNT
)paren
)paren
(brace
id|usb_dev
op_assign
id|urb-&gt;dev
suffix:semicolon
id|urb-&gt;dev
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|uhci-&gt;urb_list_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;complete
)paren
id|urb-&gt;complete
(paren
id|urb
)paren
suffix:semicolon
id|urb-&gt;dev
op_assign
id|usb_dev
suffix:semicolon
id|uhci_urb_enqueue
c_func
(paren
op_amp
id|uhci-&gt;hcd
comma
id|urb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
singleline_comment|// FIXME memflags!
id|spin_lock
c_func
(paren
op_amp
id|uhci-&gt;urb_list_lock
)paren
suffix:semicolon
)brace
r_else
(brace
id|spin_unlock
c_func
(paren
op_amp
id|uhci-&gt;urb_list_lock
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;giveback iso urb %p, status %i, length %i&bslash;n&quot;
comma
id|urb
comma
id|urb-&gt;status
comma
id|urb-&gt;transfer_buffer_length
)paren
suffix:semicolon
id|usb_hcd_giveback_urb
c_func
(paren
op_amp
id|uhci-&gt;hcd
comma
id|urb
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|uhci-&gt;urb_list_lock
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|spin_unlock
c_func
(paren
op_amp
id|uhci-&gt;urb_list_lock
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;giveback urb %p, status %i, length %i&bslash;n&quot;
comma
id|urb
comma
id|urb-&gt;status
comma
id|urb-&gt;transfer_buffer_length
)paren
suffix:semicolon
id|usb_hcd_giveback_urb
c_func
(paren
op_amp
id|uhci-&gt;hcd
comma
id|urb
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|uhci-&gt;urb_list_lock
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*###########################################################################*/
singleline_comment|//                        EMERGENCY ROOM
multiline_comment|/*###########################################################################*/
multiline_comment|/* used to reanimate a halted hostcontroller which signals no interrupts anymore.&n;   This is a shortcut for unloading and reloading the module, and should be only&n;   used as the last resort, but some VIA chips need it.&n;*/
DECL|function|hc_defibrillate
r_static
r_int
id|hc_defibrillate
c_func
(paren
r_struct
id|uhci_hcd
op_star
id|uhci
)paren
(brace
r_int
id|ret
suffix:semicolon
id|err
c_func
(paren
l_string|&quot;Watchdog timeout, host controller obviously clinically dead, defibrillating...&bslash;n&quot;
l_string|&quot;Expect disconnections for all devices on this controller!&quot;
)paren
suffix:semicolon
id|uhci-&gt;running
op_assign
l_int|0
suffix:semicolon
id|outw
(paren
id|USBCMD_HCRESET
comma
(paren
r_int
)paren
id|uhci-&gt;hcd.regs
op_plus
id|USBCMD
)paren
suffix:semicolon
id|uhci_stop
c_func
(paren
op_amp
id|uhci-&gt;hcd
)paren
suffix:semicolon
id|ret
op_assign
id|init_skel
c_func
(paren
id|uhci
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|set_td_ioc
c_func
(paren
id|uhci-&gt;td128ms
)paren
suffix:semicolon
singleline_comment|// enable watchdog interrupt
id|hc_irq_run
c_func
(paren
id|uhci
)paren
suffix:semicolon
id|uhci-&gt;reanimations
op_increment
suffix:semicolon
id|err
c_func
(paren
l_string|&quot;Host controller restart done...&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
