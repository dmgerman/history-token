multiline_comment|/*&n; * Copyright (c) 2001 by David Brownell&n; * &n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2 of the License, or (at your&n; * option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY&n; * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License&n; * for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software Foundation,&n; * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
multiline_comment|/* this file is part of ehci-hcd.c */
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * EHCI scheduled transaction support:  interrupt, iso, split iso&n; * These are called &quot;periodic&quot; transactions in the EHCI spec.&n; */
multiline_comment|/*&n; * Ceiling microseconds (typical) for that many bytes at high speed&n; * ISO is a bit less, no ACK ... from USB 2.0 spec, 5.11.3 (and needed&n; * to preallocate bandwidth)&n; */
DECL|macro|EHCI_HOST_DELAY
mdefine_line|#define EHCI_HOST_DELAY&t;5&t;/* nsec, guess */
DECL|macro|HS_USECS
mdefine_line|#define HS_USECS(bytes) NS_TO_US ( ((55 * 8 * 2083)/1000) &bslash;&n;&t;+ ((2083UL * (3167 + BitTime (bytes)))/1000) &bslash;&n;&t;+ EHCI_HOST_DELAY)
DECL|macro|HS_USECS_ISO
mdefine_line|#define HS_USECS_ISO(bytes) NS_TO_US ( ((long)(38 * 8 * 2.083)) &bslash;&n;&t;+ ((2083UL * (3167 + BitTime (bytes)))/1000) &bslash;&n;&t;+ EHCI_HOST_DELAY)
r_static
r_int
id|ehci_get_frame
(paren
r_struct
id|usb_hcd
op_star
id|hcd
)paren
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * periodic_next_shadow - return &quot;next&quot; pointer on shadow list&n; * @periodic: host pointer to qh/itd/sitd&n; * @tag: hardware tag for type of this record&n; */
r_static
r_union
id|ehci_shadow
op_star
DECL|function|periodic_next_shadow
id|periodic_next_shadow
(paren
r_union
id|ehci_shadow
op_star
id|periodic
comma
r_int
id|tag
)paren
(brace
r_switch
c_cond
(paren
id|tag
)paren
(brace
r_case
id|Q_TYPE_QH
suffix:colon
r_return
op_amp
id|periodic-&gt;qh-&gt;qh_next
suffix:semicolon
r_case
id|Q_TYPE_FSTN
suffix:colon
r_return
op_amp
id|periodic-&gt;fstn-&gt;fstn_next
suffix:semicolon
macro_line|#ifdef have_iso
r_case
id|Q_TYPE_ITD
suffix:colon
r_return
op_amp
id|periodic-&gt;itd-&gt;itd_next
suffix:semicolon
r_case
id|Q_TYPE_SITD
suffix:colon
r_return
op_amp
id|periodic-&gt;sitd-&gt;sitd_next
suffix:semicolon
macro_line|#endif /* have_iso */
)brace
id|dbg
(paren
l_string|&quot;BAD shadow %p tag %d&quot;
comma
id|periodic-&gt;ptr
comma
id|tag
)paren
suffix:semicolon
singleline_comment|// BUG ();
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* returns true after successful unlink */
multiline_comment|/* caller must hold ehci-&gt;lock */
DECL|function|periodic_unlink
r_static
r_int
id|periodic_unlink
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_int
id|frame
comma
r_void
op_star
id|ptr
)paren
(brace
r_union
id|ehci_shadow
op_star
id|prev_p
op_assign
op_amp
id|ehci-&gt;pshadow
(braket
id|frame
)braket
suffix:semicolon
id|u32
op_star
id|hw_p
op_assign
op_amp
id|ehci-&gt;periodic
(braket
id|frame
)braket
suffix:semicolon
r_union
id|ehci_shadow
id|here
op_assign
op_star
id|prev_p
suffix:semicolon
r_union
id|ehci_shadow
op_star
id|next_p
suffix:semicolon
multiline_comment|/* find predecessor of &quot;ptr&quot;; hw and shadow lists are in sync */
r_while
c_loop
(paren
id|here.ptr
op_logical_and
id|here.ptr
op_ne
id|ptr
)paren
(brace
id|prev_p
op_assign
id|periodic_next_shadow
(paren
id|prev_p
comma
id|Q_NEXT_TYPE
(paren
op_star
id|hw_p
)paren
)paren
suffix:semicolon
id|hw_p
op_assign
op_amp
id|here.qh-&gt;hw_next
suffix:semicolon
id|here
op_assign
op_star
id|prev_p
suffix:semicolon
)brace
multiline_comment|/* an interrupt entry (at list end) could have been shared */
r_if
c_cond
(paren
op_logical_neg
id|here.ptr
)paren
(brace
id|dbg
(paren
l_string|&quot;entry %p no longer on frame [%d]&quot;
comma
id|ptr
comma
id|frame
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|// vdbg (&quot;periodic unlink %p from frame %d&quot;, ptr, frame);
multiline_comment|/* update hardware list ... HC may still know the old structure, so&n;&t; * don&squot;t change hw_next until it&squot;ll have purged its cache&n;&t; */
id|next_p
op_assign
id|periodic_next_shadow
(paren
op_amp
id|here
comma
id|Q_NEXT_TYPE
(paren
op_star
id|hw_p
)paren
)paren
suffix:semicolon
op_star
id|hw_p
op_assign
id|here.qh-&gt;hw_next
suffix:semicolon
multiline_comment|/* unlink from shadow list; HCD won&squot;t see old structure again */
op_star
id|prev_p
op_assign
op_star
id|next_p
suffix:semicolon
id|next_p-&gt;ptr
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* how many of the uframe&squot;s 125 usecs are allocated? */
r_static
r_int
r_int
DECL|function|periodic_usecs
id|periodic_usecs
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_int
id|frame
comma
r_int
id|uframe
)paren
(brace
id|u32
op_star
id|hw_p
op_assign
op_amp
id|ehci-&gt;periodic
(braket
id|frame
)braket
suffix:semicolon
r_union
id|ehci_shadow
op_star
id|q
op_assign
op_amp
id|ehci-&gt;pshadow
(braket
id|frame
)braket
suffix:semicolon
r_int
id|usecs
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef have_iso
id|u32
id|temp
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
id|q-&gt;ptr
)paren
(brace
r_switch
c_cond
(paren
id|Q_NEXT_TYPE
(paren
op_star
id|hw_p
)paren
)paren
(brace
r_case
id|Q_TYPE_QH
suffix:colon
multiline_comment|/* is it in the S-mask? */
r_if
c_cond
(paren
id|q-&gt;qh-&gt;hw_info2
op_amp
id|cpu_to_le32
(paren
l_int|1
op_lshift
id|uframe
)paren
)paren
id|usecs
op_add_assign
id|q-&gt;qh-&gt;usecs
suffix:semicolon
id|q
op_assign
op_amp
id|q-&gt;qh-&gt;qh_next
suffix:semicolon
r_break
suffix:semicolon
r_case
id|Q_TYPE_FSTN
suffix:colon
multiline_comment|/* for &quot;save place&quot; FSTNs, count the relevant INTR&n;&t;&t;&t; * bandwidth from the previous frame&n;&t;&t;&t; */
r_if
c_cond
(paren
id|q-&gt;fstn-&gt;hw_prev
op_ne
id|EHCI_LIST_END
)paren
(brace
id|dbg
(paren
l_string|&quot;not counting FSTN bandwidth yet ...&quot;
)paren
suffix:semicolon
)brace
id|q
op_assign
op_amp
id|q-&gt;fstn-&gt;fstn_next
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef have_iso
r_case
id|Q_TYPE_ITD
suffix:colon
id|temp
op_assign
id|le32_to_cpu
(paren
id|q-&gt;itd-&gt;transaction
(braket
id|uframe
)braket
)paren
suffix:semicolon
id|temp
op_rshift_assign
l_int|16
suffix:semicolon
id|temp
op_and_assign
l_int|0x0fff
suffix:semicolon
r_if
c_cond
(paren
id|temp
)paren
id|usecs
op_add_assign
id|HS_USECS_ISO
(paren
id|temp
)paren
suffix:semicolon
id|q
op_assign
op_amp
id|q-&gt;itd-&gt;itd_next
suffix:semicolon
r_break
suffix:semicolon
r_case
id|Q_TYPE_SITD
suffix:colon
id|temp
op_assign
id|q-&gt;sitd-&gt;hw_fullspeed_ep
op_amp
id|__constant_cpu_to_le32
(paren
l_int|1
op_lshift
l_int|31
)paren
suffix:semicolon
singleline_comment|// FIXME:  this doesn&squot;t count data bytes right...
multiline_comment|/* is it in the S-mask?  (count SPLIT, DATA) */
r_if
c_cond
(paren
id|q-&gt;sitd-&gt;hw_uframe
op_amp
id|cpu_to_le32
(paren
l_int|1
op_lshift
id|uframe
)paren
)paren
(brace
r_if
c_cond
(paren
id|temp
)paren
id|usecs
op_add_assign
id|HS_USECS
(paren
l_int|188
)paren
suffix:semicolon
r_else
id|usecs
op_add_assign
id|HS_USECS
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* ... C-mask?  (count CSPLIT, DATA) */
r_if
c_cond
(paren
id|q-&gt;sitd-&gt;hw_uframe
op_amp
id|cpu_to_le32
(paren
l_int|1
op_lshift
(paren
l_int|8
op_plus
id|uframe
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|temp
)paren
id|usecs
op_add_assign
id|HS_USECS
(paren
l_int|0
)paren
suffix:semicolon
r_else
id|usecs
op_add_assign
id|HS_USECS
(paren
l_int|188
)paren
suffix:semicolon
)brace
id|q
op_assign
op_amp
id|q-&gt;sitd-&gt;sitd_next
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /* have_iso */
r_default
suffix:colon
id|BUG
(paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef&t;DEBUG
r_if
c_cond
(paren
id|usecs
OG
l_int|100
)paren
id|err
(paren
l_string|&quot;overallocated uframe %d, periodic is %d usecs&quot;
comma
id|frame
op_star
l_int|8
op_plus
id|uframe
comma
id|usecs
)paren
suffix:semicolon
macro_line|#endif
r_return
id|usecs
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|intr_deschedule
r_static
r_void
id|intr_deschedule
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_int
id|frame
comma
r_struct
id|ehci_qh
op_star
id|qh
comma
r_int
id|period
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_do
(brace
id|periodic_unlink
(paren
id|ehci
comma
id|frame
comma
id|qh
)paren
suffix:semicolon
id|qh_unput
(paren
id|ehci
comma
id|qh
)paren
suffix:semicolon
id|frame
op_add_assign
id|period
suffix:semicolon
)brace
r_while
c_loop
(paren
id|frame
OL
id|ehci-&gt;periodic_size
)paren
suffix:semicolon
id|qh-&gt;qh_state
op_assign
id|QH_STATE_UNLINK
suffix:semicolon
id|qh-&gt;qh_next.ptr
op_assign
l_int|0
suffix:semicolon
id|ehci-&gt;periodic_urbs
op_decrement
suffix:semicolon
multiline_comment|/* maybe turn off periodic schedule */
r_if
c_cond
(paren
op_logical_neg
id|ehci-&gt;periodic_urbs
)paren
(brace
id|u32
id|cmd
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
multiline_comment|/* did setting PSE not take effect yet?&n;&t;&t; * takes effect only at frame boundaries...&n;&t;&t; */
r_while
c_loop
(paren
op_logical_neg
(paren
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;status
)paren
op_amp
id|STS_PSS
)paren
)paren
id|udelay
(paren
l_int|20
)paren
suffix:semicolon
id|cmd
op_and_assign
op_complement
id|CMD_PSE
suffix:semicolon
id|writel
(paren
id|cmd
comma
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
multiline_comment|/* posted write ... */
id|ehci-&gt;next_frame
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
id|vdbg
(paren
l_string|&quot;periodic schedule still enabled&quot;
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the hc may be looking at this qh, then delay a uframe&n;&t; * (yeech!) to be sure it&squot;s done.&n;&t; * No other threads may be mucking with this qh.&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|ehci_get_frame
(paren
op_amp
id|ehci-&gt;hcd
)paren
op_minus
id|frame
)paren
op_mod
id|period
)paren
op_eq
l_int|0
)paren
id|udelay
(paren
l_int|125
)paren
suffix:semicolon
id|qh-&gt;qh_state
op_assign
id|QH_STATE_IDLE
suffix:semicolon
id|qh-&gt;hw_next
op_assign
id|EHCI_LIST_END
suffix:semicolon
id|vdbg
(paren
l_string|&quot;descheduled qh %p, per = %d frame = %d count = %d, urbs = %d&quot;
comma
id|qh
comma
id|period
comma
id|frame
comma
id|atomic_read
(paren
op_amp
id|qh-&gt;refcount
)paren
comma
id|ehci-&gt;periodic_urbs
)paren
suffix:semicolon
)brace
DECL|function|intr_submit
r_static
r_int
id|intr_submit
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|list_head
op_star
id|qtd_list
comma
r_int
id|mem_flags
)paren
(brace
r_int
id|epnum
comma
id|period
suffix:semicolon
r_int
id|temp
suffix:semicolon
r_int
r_int
id|mult
comma
id|usecs
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|ehci_qh
op_star
id|qh
suffix:semicolon
r_struct
id|hcd_dev
op_star
id|dev
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* get endpoint and transfer data */
id|epnum
op_assign
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
id|temp
op_assign
id|urb-&gt;dev-&gt;epmaxpacketin
(braket
id|epnum
)braket
suffix:semicolon
id|epnum
op_or_assign
l_int|0x10
suffix:semicolon
)brace
r_else
id|temp
op_assign
id|urb-&gt;dev-&gt;epmaxpacketout
(braket
id|epnum
)braket
suffix:semicolon
id|mult
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;dev-&gt;speed
op_eq
id|USB_SPEED_HIGH
)paren
(brace
multiline_comment|/* high speed &quot;high bandwidth&quot; is coded in ep maxpacket */
id|mult
op_add_assign
(paren
id|temp
op_rshift
l_int|11
)paren
op_amp
l_int|0x03
suffix:semicolon
id|temp
op_and_assign
l_int|0x03ff
suffix:semicolon
)brace
r_else
(brace
id|dbg
(paren
l_string|&quot;no intr/tt scheduling yet&quot;
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|ENOSYS
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * NOTE: current completion/restart logic doesn&squot;t handle more than&n;&t; * one qtd in a periodic qh ... 16-20 KB/urb is pretty big for this.&n;&t; * such big requests need many periods to transfer.&n;&t; */
r_if
c_cond
(paren
id|unlikely
(paren
id|qtd_list-&gt;next
op_ne
id|qtd_list-&gt;prev
)paren
)paren
(brace
id|dbg
(paren
l_string|&quot;only one intr qtd per urb allowed&quot;
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|usecs
op_assign
id|HS_USECS
(paren
id|urb-&gt;transfer_buffer_length
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * force a power-of-two (frames) sized polling interval&n;&t; *&n;&t; * NOTE: endpoint-&gt;bInterval for highspeed is measured in uframes,&n;&t; * while for full/low speeds it&squot;s in frames.  Here we &quot;know&quot; that&n;&t; * urb-&gt;interval doesn&squot;t give acccess to high interrupt rates.&n;&t; */
id|period
op_assign
id|ehci-&gt;periodic_size
suffix:semicolon
id|temp
op_assign
id|period
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
id|urb-&gt;interval
OL
l_int|1
)paren
)paren
id|urb-&gt;interval
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|temp
OG
id|urb-&gt;interval
)paren
id|temp
op_rshift_assign
l_int|1
suffix:semicolon
id|period
op_assign
id|urb-&gt;interval
op_assign
id|temp
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* get the qh (must be empty and idle) */
id|dev
op_assign
(paren
r_struct
id|hcd_dev
op_star
)paren
id|urb-&gt;dev-&gt;hcpriv
suffix:semicolon
id|qh
op_assign
(paren
r_struct
id|ehci_qh
op_star
)paren
id|dev-&gt;ep
(braket
id|epnum
)braket
suffix:semicolon
r_if
c_cond
(paren
id|qh
)paren
(brace
multiline_comment|/* only allow one queued interrupt urb per EP */
r_if
c_cond
(paren
id|unlikely
(paren
id|qh-&gt;qh_state
op_ne
id|QH_STATE_IDLE
op_logical_or
op_logical_neg
id|list_empty
(paren
op_amp
id|qh-&gt;qtd_list
)paren
)paren
)paren
(brace
id|dbg
(paren
l_string|&quot;interrupt urb already queued&quot;
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* maybe reset hardware&squot;s data toggle in the qh */
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|usb_gettoggle
(paren
id|urb-&gt;dev
comma
id|epnum
op_amp
l_int|0x0f
comma
op_logical_neg
(paren
id|epnum
op_amp
l_int|0x10
)paren
)paren
)paren
)paren
(brace
id|qh-&gt;hw_token
op_or_assign
id|__constant_cpu_to_le32
(paren
id|QTD_TOGGLE
)paren
suffix:semicolon
id|usb_settoggle
(paren
id|urb-&gt;dev
comma
id|epnum
op_amp
l_int|0x0f
comma
op_logical_neg
(paren
id|epnum
op_amp
l_int|0x10
)paren
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* trust the QH was set up as interrupt ... */
id|list_splice
(paren
id|qtd_list
comma
op_amp
id|qh-&gt;qtd_list
)paren
suffix:semicolon
id|qh_update
(paren
id|qh
comma
id|list_entry
(paren
id|qtd_list-&gt;next
comma
r_struct
id|ehci_qtd
comma
id|qtd_list
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* can&squot;t sleep here, we have ehci-&gt;lock... */
id|qh
op_assign
id|ehci_qh_make
(paren
id|ehci
comma
id|urb
comma
id|qtd_list
comma
id|SLAB_ATOMIC
)paren
suffix:semicolon
id|qtd_list
op_assign
op_amp
id|qh-&gt;qtd_list
suffix:semicolon
r_if
c_cond
(paren
id|likely
(paren
id|qh
op_ne
l_int|0
)paren
)paren
(brace
singleline_comment|// dbg (&quot;new INTR qh %p&quot;, qh);
id|dev-&gt;ep
(braket
id|epnum
)braket
op_assign
id|qh
suffix:semicolon
)brace
r_else
id|status
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Schedule this periodic QH. */
r_if
c_cond
(paren
id|likely
(paren
id|status
op_eq
l_int|0
)paren
)paren
(brace
r_int
id|frame
op_assign
id|urb-&gt;interval
suffix:semicolon
id|qh-&gt;hw_next
op_assign
id|EHCI_LIST_END
suffix:semicolon
id|qh-&gt;hw_info2
op_or_assign
id|cpu_to_le32
(paren
id|mult
op_lshift
l_int|30
)paren
suffix:semicolon
id|qh-&gt;usecs
op_assign
id|usecs
suffix:semicolon
id|urb-&gt;hcpriv
op_assign
id|qh_put
(paren
id|qh
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|ENOSPC
suffix:semicolon
multiline_comment|/* pick a set of schedule slots, link the QH into them */
r_do
(brace
r_int
id|uframe
suffix:semicolon
multiline_comment|/* Select some frame 0..(urb-&gt;interval - 1) with a&n;&t;&t;&t; * microframe that can hold this transaction.&n;&t;&t;&t; *&n;&t;&t;&t; * FIXME for TT splits, need uframes for start and end.&n;&t;&t;&t; * FSTNs can put end into next frame (uframes 0 or 1).&n;&t;&t;&t; */
id|frame
op_decrement
suffix:semicolon
r_for
c_loop
(paren
id|uframe
op_assign
l_int|0
suffix:semicolon
id|uframe
OL
l_int|8
suffix:semicolon
id|uframe
op_increment
)paren
(brace
r_int
id|claimed
suffix:semicolon
id|claimed
op_assign
id|periodic_usecs
(paren
id|ehci
comma
id|frame
comma
id|uframe
)paren
suffix:semicolon
multiline_comment|/* 80% periodic == 100 usec max committed */
r_if
c_cond
(paren
(paren
id|claimed
op_plus
id|usecs
)paren
op_le
l_int|100
)paren
(brace
id|vdbg
(paren
l_string|&quot;frame %d.%d: %d usecs, plus %d&quot;
comma
id|frame
comma
id|uframe
comma
id|claimed
comma
id|usecs
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|uframe
op_eq
l_int|8
)paren
r_continue
suffix:semicolon
singleline_comment|// FIXME delete when code below handles non-empty queues
r_if
c_cond
(paren
id|ehci-&gt;pshadow
(braket
id|frame
)braket
dot
id|ptr
)paren
r_continue
suffix:semicolon
multiline_comment|/* QH will run once each period, starting there  */
id|urb-&gt;start_frame
op_assign
id|frame
suffix:semicolon
id|status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set S-frame mask */
id|qh-&gt;hw_info2
op_or_assign
id|cpu_to_le32
(paren
l_int|1
op_lshift
id|uframe
)paren
suffix:semicolon
singleline_comment|// dbg_qh (&quot;Schedule INTR qh&quot;, ehci, qh);
multiline_comment|/* stuff into the periodic schedule */
id|qh-&gt;qh_state
op_assign
id|QH_STATE_LINKED
suffix:semicolon
id|vdbg
(paren
l_string|&quot;qh %p usecs %d period %d starting frame %d.%d&quot;
comma
id|qh
comma
id|qh-&gt;usecs
comma
id|period
comma
id|frame
comma
id|uframe
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|unlikely
(paren
(paren
r_int
)paren
id|ehci-&gt;pshadow
(braket
id|frame
)braket
dot
id|ptr
)paren
)paren
(brace
singleline_comment|// FIXME -- just link to the end, before any qh with a shorter period,
singleline_comment|// AND handle it already being (implicitly) linked into this frame
id|BUG
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|ehci-&gt;pshadow
(braket
id|frame
)braket
dot
id|qh
op_assign
id|qh_put
(paren
id|qh
)paren
suffix:semicolon
id|ehci-&gt;periodic
(braket
id|frame
)braket
op_assign
id|QH_NEXT
(paren
id|qh-&gt;qh_dma
)paren
suffix:semicolon
)brace
id|frame
op_add_assign
id|period
suffix:semicolon
)brace
r_while
c_loop
(paren
id|frame
OL
id|ehci-&gt;periodic_size
)paren
suffix:semicolon
multiline_comment|/* maybe enable periodic schedule processing */
r_if
c_cond
(paren
op_logical_neg
id|ehci-&gt;periodic_urbs
op_increment
)paren
(brace
id|u32
id|cmd
suffix:semicolon
multiline_comment|/* did clearing PSE did take effect yet?&n;&t;&t;&t;&t; * takes effect only at frame boundaries...&n;&t;&t;&t;&t; */
r_while
c_loop
(paren
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;status
)paren
op_amp
id|STS_PSS
)paren
id|udelay
(paren
l_int|20
)paren
suffix:semicolon
id|cmd
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
op_or
id|CMD_PSE
suffix:semicolon
id|writel
(paren
id|cmd
comma
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
multiline_comment|/* posted write ... PSS happens later */
id|ehci-&gt;hcd.state
op_assign
id|USB_STATE_RUNNING
suffix:semicolon
multiline_comment|/* make sure tasklet scans these */
id|ehci-&gt;next_frame
op_assign
id|ehci_get_frame
(paren
op_amp
id|ehci-&gt;hcd
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
id|frame
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|done
suffix:colon
r_if
c_cond
(paren
id|status
)paren
(brace
id|usb_complete_t
id|complete
op_assign
id|urb-&gt;complete
suffix:semicolon
id|urb-&gt;complete
op_assign
l_int|0
suffix:semicolon
id|urb-&gt;status
op_assign
id|status
suffix:semicolon
id|qh_completions
(paren
id|ehci
comma
id|qtd_list
comma
l_int|1
)paren
suffix:semicolon
id|urb-&gt;complete
op_assign
id|complete
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
r_static
r_int
r_int
DECL|function|intr_complete
id|intr_complete
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_int
id|frame
comma
r_struct
id|ehci_qh
op_star
id|qh
comma
r_int
r_int
id|flags
multiline_comment|/* caller owns ehci-&gt;lock ... */
)paren
(brace
r_struct
id|ehci_qtd
op_star
id|qtd
suffix:semicolon
r_struct
id|urb
op_star
id|urb
suffix:semicolon
r_int
id|unlinking
suffix:semicolon
multiline_comment|/* nothing to report? */
r_if
c_cond
(paren
id|likely
(paren
(paren
id|qh-&gt;hw_token
op_amp
id|__constant_cpu_to_le32
(paren
id|QTD_STS_ACTIVE
)paren
)paren
op_ne
l_int|0
)paren
)paren
r_return
id|flags
suffix:semicolon
id|qtd
op_assign
id|list_entry
(paren
id|qh-&gt;qtd_list.next
comma
r_struct
id|ehci_qtd
comma
id|qtd_list
)paren
suffix:semicolon
id|urb
op_assign
id|qtd-&gt;urb
suffix:semicolon
id|unlinking
op_assign
(paren
id|urb-&gt;status
op_eq
op_minus
id|ENOENT
)paren
op_logical_or
(paren
id|urb-&gt;status
op_eq
op_minus
id|ECONNRESET
)paren
suffix:semicolon
multiline_comment|/* call any completions, after patching for reactivation */
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* NOTE:  currently restricted to one qtd per qh! */
r_if
c_cond
(paren
id|qh_completions
(paren
id|ehci
comma
op_amp
id|qh-&gt;qtd_list
comma
l_int|0
)paren
op_eq
l_int|0
)paren
id|urb
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* never reactivate requests that were unlinked ... */
r_if
c_cond
(paren
id|likely
(paren
id|urb
op_ne
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|unlinking
op_logical_or
id|urb-&gt;status
op_eq
op_minus
id|ECONNRESET
op_logical_or
id|urb-&gt;status
op_eq
op_minus
id|ENOENT
singleline_comment|// || (urb-&gt;dev == null)
op_logical_or
id|ehci-&gt;hcd.state
op_eq
id|USB_STATE_HALT
)paren
id|urb
op_assign
l_int|0
suffix:semicolon
singleline_comment|// FIXME look at all those unlink cases ... we always
singleline_comment|// need exactly one completion that reports unlink.
singleline_comment|// the one above might not have been it!
)brace
multiline_comment|/* normally reactivate */
r_if
c_cond
(paren
id|likely
(paren
id|urb
op_ne
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
)paren
id|pci_dma_sync_single
(paren
id|ehci-&gt;hcd.pdev
comma
id|qtd-&gt;buf_dma
comma
id|urb-&gt;transfer_buffer_length
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
id|urb-&gt;status
op_assign
op_minus
id|EINPROGRESS
suffix:semicolon
id|urb-&gt;actual_length
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* patch qh and restart */
id|qh_update
(paren
id|qh
comma
id|qtd
)paren
suffix:semicolon
)brace
r_return
id|flags
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
macro_line|#ifdef&t;have_iso
DECL|function|itd_free
r_static
r_inline
r_void
id|itd_free
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|ehci_itd
op_star
id|itd
)paren
(brace
id|pci_pool_free
(paren
id|ehci-&gt;itd_pool
comma
id|itd
comma
id|itd-&gt;itd_dma
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Create itd and allocate into uframes within specified frame.&n; * Caller must update the resulting uframe links.&n; */
r_static
r_struct
id|ehci_itd
op_star
DECL|function|itd_make
id|itd_make
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|index
comma
singleline_comment|// urb-&gt;iso_frame_desc [index]
r_int
id|frame
comma
singleline_comment|// scheduled start
id|dma_addr_t
id|dma
comma
singleline_comment|// mapped transfer buffer
r_int
id|mem_flags
)paren
(brace
r_struct
id|ehci_itd
op_star
id|itd
suffix:semicolon
id|u64
id|temp
suffix:semicolon
id|u32
id|buf1
suffix:semicolon
r_int
id|epnum
comma
id|maxp
comma
id|multi
comma
id|usecs
suffix:semicolon
r_int
id|length
suffix:semicolon
r_int
id|i
comma
id|bufnum
suffix:semicolon
multiline_comment|/* allocate itd, start to fill it */
id|itd
op_assign
id|pci_pool_alloc
(paren
id|ehci-&gt;itd_pool
comma
id|mem_flags
comma
op_amp
id|dma
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|itd
)paren
r_return
id|itd
suffix:semicolon
id|itd-&gt;hw_next
op_assign
id|EHCI_LIST_END
suffix:semicolon
id|itd-&gt;urb
op_assign
id|urb
suffix:semicolon
id|itd-&gt;index
op_assign
id|index
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|itd-&gt;itd_list
)paren
suffix:semicolon
id|itd-&gt;uframe
op_assign
(paren
id|frame
op_star
l_int|8
)paren
op_mod
id|ehci-&gt;periodic_size
suffix:semicolon
multiline_comment|/* tell itd about the buffer its transfers will consume */
id|length
op_assign
id|urb-&gt;iso_frame_desc
(braket
id|index
)braket
dot
id|length
suffix:semicolon
id|dma
op_add_assign
id|urb-&gt;iso_frame_desc
(braket
id|index
)braket
dot
id|offset
suffix:semicolon
id|temp
op_assign
id|dma
op_amp
op_complement
l_int|0x0fff
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
(brace
id|itd-&gt;hw_bufp
(braket
id|i
)braket
op_assign
id|cpu_to_le32
(paren
(paren
id|u32
)paren
id|temp
)paren
suffix:semicolon
id|itd-&gt;hw_bufp_hi
(braket
id|i
)braket
op_assign
id|cpu_to_le32
(paren
(paren
id|u32
)paren
(paren
id|temp
op_rshift
l_int|32
)paren
)paren
suffix:semicolon
id|temp
op_add_assign
l_int|0x0fff
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * this might be a &quot;high bandwidth&quot; highspeed endpoint,&n;&t; * as encoded in the ep descriptor&squot;s maxpacket field&n;&t; */
id|epnum
op_assign
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
id|maxp
op_assign
id|urb-&gt;dev-&gt;epmaxpacketin
(braket
id|epnum
)braket
suffix:semicolon
id|buf1
op_assign
(paren
l_int|1
op_lshift
l_int|11
)paren
op_or
id|maxp
suffix:semicolon
)brace
r_else
(brace
id|maxp
op_assign
id|urb-&gt;dev-&gt;epmaxpacketout
(braket
id|epnum
)braket
suffix:semicolon
id|buf1
op_assign
id|maxp
suffix:semicolon
)brace
id|multi
op_assign
l_int|1
suffix:semicolon
id|multi
op_add_assign
(paren
id|temp
op_rshift
l_int|11
)paren
op_amp
l_int|0x03
suffix:semicolon
id|maxp
op_and_assign
l_int|0x03ff
suffix:semicolon
multiline_comment|/* &quot;plus&quot; info in low order bits of buffer pointers */
id|itd-&gt;hw_bufp
(braket
l_int|0
)braket
op_or_assign
id|cpu_to_le32
(paren
(paren
id|epnum
op_lshift
l_int|8
)paren
op_or
id|urb-&gt;dev-&gt;devnum
)paren
suffix:semicolon
id|itd-&gt;hw_bufp
(braket
l_int|1
)braket
op_or_assign
id|cpu_to_le32
(paren
id|buf1
)paren
suffix:semicolon
id|itd-&gt;hw_bufp
(braket
l_int|2
)braket
op_or_assign
id|cpu_to_le32
(paren
id|multi
)paren
suffix:semicolon
multiline_comment|/* schedule as many uframes as needed */
id|maxp
op_mul_assign
id|multi
suffix:semicolon
id|usecs
op_assign
id|HS_USECS_ISO
(paren
id|maxp
)paren
suffix:semicolon
id|bufnum
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|t
comma
id|offset
comma
id|scratch
suffix:semicolon
r_if
c_cond
(paren
id|length
op_le
l_int|0
)paren
(brace
id|itd-&gt;hw_transaction
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* don&squot;t commit more than 80% periodic == 100 usec */
r_if
c_cond
(paren
(paren
id|periodic_usecs
(paren
id|ehci
comma
id|itd-&gt;uframe
comma
id|i
)paren
op_plus
id|usecs
)paren
OG
l_int|100
)paren
r_continue
suffix:semicolon
multiline_comment|/* we&squot;ll use this uframe; figure hw_transaction */
id|t
op_assign
id|EHCI_ISOC_ACTIVE
suffix:semicolon
id|t
op_or_assign
id|bufnum
op_lshift
l_int|12
suffix:semicolon
singleline_comment|// which buffer?
id|offset
op_assign
id|temp
op_amp
l_int|0x0fff
suffix:semicolon
singleline_comment|// offset therein
id|t
op_or_assign
id|offset
suffix:semicolon
r_if
c_cond
(paren
(paren
id|offset
op_plus
id|maxp
)paren
op_ge
l_int|4096
)paren
singleline_comment|// hc auto-wraps end-of-&quot;page&quot;
id|bufnum
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|length
op_le
id|maxp
)paren
(brace
singleline_comment|// interrupt only needed at end-of-urb
r_if
c_cond
(paren
(paren
id|index
op_plus
l_int|1
)paren
op_eq
id|urb-&gt;number_of_packets
)paren
id|t
op_or_assign
id|EHCI_ITD_IOC
suffix:semicolon
id|scratch
op_assign
id|length
suffix:semicolon
)brace
r_else
id|scratch
op_assign
id|maxp
suffix:semicolon
id|t
op_or_assign
id|scratch
op_lshift
l_int|16
suffix:semicolon
id|t
op_assign
id|cpu_to_le32
(paren
id|t
)paren
suffix:semicolon
id|itd-&gt;hw_transaction
(braket
id|i
)braket
op_assign
id|itd-&gt;transaction
(braket
id|i
)braket
op_assign
id|t
suffix:semicolon
id|length
op_sub_assign
id|scratch
suffix:semicolon
)brace
r_if
c_cond
(paren
id|length
OG
l_int|0
)paren
(brace
id|dbg
(paren
l_string|&quot;iso frame too big, urb %p [%d], %d extra (of %d)&quot;
comma
id|urb
comma
id|index
comma
id|length
comma
id|urb-&gt;iso_frame_desc
(braket
id|index
)braket
dot
id|length
)paren
suffix:semicolon
id|itd_free
(paren
id|ehci
comma
id|itd
)paren
suffix:semicolon
id|itd
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|itd
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|itd_link
id|itd_link
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_int
id|frame
comma
r_struct
id|ehci_itd
op_star
id|itd
)paren
(brace
id|u32
id|ptr
suffix:semicolon
id|ptr
op_assign
id|cpu_to_le32
(paren
id|itd-&gt;itd_dma
)paren
suffix:semicolon
singleline_comment|// type 0 == itd
r_if
c_cond
(paren
id|ehci-&gt;pshadow
(braket
id|frame
)braket
dot
id|ptr
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|itd-&gt;itd_next.ptr
)paren
(brace
id|itd-&gt;itd_next
op_assign
id|ehci-&gt;pshadow
(braket
id|frame
)braket
suffix:semicolon
id|itd-&gt;hw_next
op_assign
id|ehci-&gt;periodic
(braket
id|frame
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|itd-&gt;itd_next.ptr
op_ne
id|ehci-&gt;pshadow
(braket
id|frame
)braket
dot
id|ptr
)paren
(brace
id|dbg
(paren
l_string|&quot;frame %d itd link goof&quot;
comma
id|frame
)paren
suffix:semicolon
id|BUG
(paren
)paren
suffix:semicolon
)brace
)brace
id|ehci-&gt;pshadow
(braket
id|frame
)braket
dot
id|itd
op_assign
id|itd
suffix:semicolon
id|ehci-&gt;periodic
(braket
id|frame
)braket
op_assign
id|ptr
suffix:semicolon
)brace
DECL|macro|ISO_ERRS
mdefine_line|#define&t;ISO_ERRS (EHCI_ISOC_BUF_ERR | EHCI_ISOC_BABBLE | EHCI_ISOC_XACTERR)
r_static
r_int
r_int
DECL|function|itd_complete
id|itd_complete
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|ehci_itd
op_star
id|itd
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|urb
op_star
id|urb
op_assign
id|itd-&gt;urb
suffix:semicolon
multiline_comment|/* if not unlinking: */
r_if
c_cond
(paren
op_logical_neg
(paren
id|urb-&gt;transfer_flags
op_amp
id|EHCI_STATE_UNLINK
)paren
op_logical_and
id|ehci-&gt;hcd.state
op_ne
id|USB_STATE_HALT
)paren
(brace
r_int
id|i
suffix:semicolon
id|iso_packet_descriptor_t
op_star
id|desc
suffix:semicolon
r_struct
id|ehci_itd
op_star
id|first_itd
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
multiline_comment|/* update status for this frame&squot;s transfers */
id|desc
op_assign
op_amp
id|urb-&gt;iso_frame_desc
(braket
id|itd-&gt;index
)braket
suffix:semicolon
id|desc-&gt;status
op_assign
l_int|0
suffix:semicolon
id|desc-&gt;actual_length
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|u32
id|t
op_assign
id|itd-&gt;hw_transaction
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|t
op_amp
(paren
id|ISO_ERRS
op_or
id|EHCI_ISOC_ACTIVE
)paren
)paren
(brace
r_if
c_cond
(paren
id|t
op_amp
id|EHCI_ISOC_ACTIVE
)paren
id|desc-&gt;status
op_assign
op_minus
id|EXDEV
suffix:semicolon
r_else
r_if
c_cond
(paren
id|t
op_amp
id|EHCI_ISOC_BUF_ERR
)paren
id|desc-&gt;status
op_assign
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
ques
c_cond
op_minus
id|ENOSR
multiline_comment|/* couldn&squot;t read */
suffix:colon
op_minus
id|ECOMM
suffix:semicolon
multiline_comment|/* couldn&squot;t write */
r_else
r_if
c_cond
(paren
id|t
op_amp
id|EHCI_ISOC_BABBLE
)paren
id|desc-&gt;status
op_assign
op_minus
id|EOVERFLOW
suffix:semicolon
r_else
multiline_comment|/* (t &amp; EHCI_ISOC_XACTERR) */
id|desc-&gt;status
op_assign
op_minus
id|EPROTO
suffix:semicolon
r_break
suffix:semicolon
)brace
id|desc-&gt;actual_length
op_add_assign
id|EHCI_ITD_LENGTH
(paren
id|t
)paren
suffix:semicolon
)brace
multiline_comment|/* handle completion now? */
r_if
c_cond
(paren
(paren
id|itd-&gt;index
op_plus
l_int|1
)paren
op_ne
id|urb-&gt;number_of_packets
)paren
r_return
id|flags
suffix:semicolon
id|i
op_assign
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
id|pci_dma_sync_single
(paren
id|ehci-&gt;hcd.pdev
comma
id|first_itd-&gt;buf_dma
comma
id|urb-&gt;transfer_buffer_length
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
multiline_comment|/* call completion with no locks; it can unlink ... */
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|urb-&gt;complete
(paren
id|urb
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* re-activate this URB? or unlink? */
r_if
c_cond
(paren
op_logical_neg
(paren
id|urb-&gt;transfer_flags
op_amp
id|EHCI_STATE_UNLINK
)paren
op_logical_and
id|ehci-&gt;hcd.state
op_ne
id|USB_STATE_HALT
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
id|pci_dma_sync_single
(paren
id|ehci-&gt;hcd.pdev
comma
id|first_itd-&gt;buf_dma
comma
id|urb-&gt;transfer_buffer_length
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
id|itd
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
r_do
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
id|itd-&gt;hw_transaction
(braket
id|i
)braket
op_assign
id|itd-&gt;transaction
(braket
id|i
)braket
suffix:semicolon
id|itd
op_assign
id|list_entry
(paren
id|itd-&gt;itd_list.next
comma
r_struct
id|ehci_itd
comma
id|itd_list
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|itd
op_ne
id|urb-&gt;hcpriv
)paren
suffix:semicolon
r_return
id|flags
suffix:semicolon
)brace
multiline_comment|/* unlink done only on the last itd */
)brace
r_else
r_if
c_cond
(paren
(paren
id|itd-&gt;index
op_plus
l_int|1
)paren
op_ne
id|urb-&gt;number_of_packets
)paren
r_return
id|flags
suffix:semicolon
multiline_comment|/* we&squot;re unlinking ... */
multiline_comment|/* decouple urb from the hcd */
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ehci-&gt;hcd.state
op_eq
id|USB_STATE_HALT
)paren
id|urb-&gt;status
op_assign
op_minus
id|ESHUTDOWN
suffix:semicolon
id|itd
op_assign
id|urb-&gt;hcpriv
suffix:semicolon
id|urb-&gt;hcpriv
op_assign
l_int|0
suffix:semicolon
id|ehci_urb_done
(paren
id|ehci
comma
id|itd-&gt;buf_dma
comma
id|urb
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* take itds out of the hc&squot;s periodic schedule */
id|list_entry
(paren
id|itd-&gt;itd_list.prev
comma
r_struct
id|ehci_itd
comma
id|itd_list
)paren
op_member_access_from_pointer
id|itd_list.next
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_struct
id|ehci_itd
op_star
id|next
suffix:semicolon
r_if
c_cond
(paren
id|itd-&gt;itd_list.next
)paren
id|next
op_assign
id|list_entry
(paren
id|itd-&gt;itd_list.next
comma
r_struct
id|ehci_itd
comma
id|itd_list
)paren
suffix:semicolon
r_else
id|next
op_assign
l_int|0
suffix:semicolon
singleline_comment|// FIXME:  hc WILL (!) lap us here, if we get behind
singleline_comment|// by 128 msec (or less, with smaller periodic_size).
singleline_comment|// Reading/caching these itds will cause trouble...
id|periodic_unlink
(paren
id|ehci
comma
id|itd-&gt;uframe
comma
id|itd
)paren
suffix:semicolon
id|itd_free
(paren
id|ehci
comma
id|itd
)paren
suffix:semicolon
id|itd
op_assign
id|next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|itd
)paren
suffix:semicolon
r_return
id|flags
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|itd_submit
r_static
r_int
id|itd_submit
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|ehci_itd
op_star
id|first_itd
op_assign
l_int|0
comma
op_star
id|itd
suffix:semicolon
r_int
id|frame_index
suffix:semicolon
id|dma_addr_t
id|dma
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|dbg
(paren
l_string|&quot;itd_submit&quot;
)paren
suffix:semicolon
multiline_comment|/* set up one dma mapping for this urb */
id|dma
op_assign
id|pci_map_single
(paren
id|ehci-&gt;hcd.pdev
comma
id|urb-&gt;transfer_buffer
comma
id|urb-&gt;transfer_buffer_length
comma
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
ques
c_cond
id|PCI_DMA_FROMDEVICE
suffix:colon
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma
op_eq
l_int|0
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/*&n;&t; * Schedule as needed.  This is VERY optimistic about free&n;&t; * bandwidth!  But the API assumes drivers can pick frames&n;&t; * intelligently (how?), so there&squot;s no other good option.&n;&t; *&n;&t; * FIXME  this doesn&squot;t handle urb-&gt;next rings, or try to&n;&t; * use the iso periodicity.&n;&t; */
r_if
c_cond
(paren
id|urb-&gt;transfer_flags
op_amp
id|USB_ISO_ASAP
)paren
(brace
id|urb-&gt;start_frame
op_assign
id|ehci_get_frame
(paren
op_amp
id|ehci-&gt;hcd
)paren
suffix:semicolon
id|urb-&gt;start_frame
op_increment
suffix:semicolon
)brace
id|urb-&gt;start_frame
op_mod_assign
id|ehci-&gt;periodic_size
suffix:semicolon
multiline_comment|/* create and populate itds (doing uframe scheduling) */
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|frame_index
op_assign
l_int|0
suffix:semicolon
id|frame_index
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|frame_index
op_increment
)paren
(brace
id|itd
op_assign
id|itd_make
(paren
id|ehci
comma
id|urb
comma
id|frame_index
comma
id|urb-&gt;start_frame
op_plus
id|frame_index
comma
id|dma
comma
id|SLAB_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|itd
)paren
(brace
r_if
c_cond
(paren
id|first_itd
)paren
id|list_add_tail
(paren
op_amp
id|itd-&gt;itd_list
comma
op_amp
id|first_itd-&gt;itd_list
)paren
suffix:semicolon
r_else
id|first_itd
op_assign
id|itd
suffix:semicolon
)brace
r_else
(brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|first_itd
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|first_itd-&gt;itd_list
)paren
)paren
(brace
id|itd
op_assign
id|list_entry
(paren
id|first_itd-&gt;itd_list.next
comma
r_struct
id|ehci_itd
comma
id|itd_list
)paren
suffix:semicolon
id|list_del
(paren
op_amp
id|itd-&gt;itd_list
)paren
suffix:semicolon
id|itd_free
(paren
id|ehci
comma
id|itd
)paren
suffix:semicolon
)brace
id|itd_free
(paren
id|ehci
comma
id|first_itd
)paren
suffix:semicolon
)brace
id|pci_unmap_single
(paren
id|ehci-&gt;hcd.pdev
comma
id|dma
comma
id|urb-&gt;transfer_buffer_length
comma
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
ques
c_cond
id|PCI_DMA_FROMDEVICE
suffix:colon
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
multiline_comment|/* stuff into the schedule */
id|itd
op_assign
id|first_itd
suffix:semicolon
r_do
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|itd-&gt;hw_transaction
(braket
id|i
)braket
)paren
r_continue
suffix:semicolon
id|itd_link
(paren
id|ehci
comma
id|itd-&gt;uframe
op_plus
id|i
comma
id|itd
)paren
suffix:semicolon
)brace
id|itd
op_assign
id|list_entry
(paren
id|itd-&gt;itd_list.next
comma
r_struct
id|ehci_itd
comma
id|itd_list
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|itd
op_ne
id|first_itd
)paren
suffix:semicolon
id|urb-&gt;hcpriv
op_assign
id|first_itd
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * &quot;Split ISO TDs&quot; ... used for USB 1.1 devices going through&n; * the TTs in USB 2.0 hubs.&n; */
r_static
r_inline
r_void
DECL|function|sitd_free
id|sitd_free
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|ehci_sitd
op_star
id|sitd
)paren
(brace
id|pci_pool_free
(paren
id|ehci-&gt;sitd_pool
comma
id|sitd
comma
id|sitd-&gt;sitd_dma
)paren
suffix:semicolon
)brace
r_static
r_struct
id|ehci_sitd
op_star
DECL|function|sitd_make
id|sitd_make
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|index
comma
singleline_comment|// urb-&gt;iso_frame_desc [index]
r_int
id|uframe
comma
singleline_comment|// scheduled start
id|dma_addr_t
id|dma
comma
singleline_comment|// mapped transfer buffer
r_int
id|mem_flags
)paren
(brace
r_struct
id|ehci_sitd
op_star
id|sitd
suffix:semicolon
r_int
id|length
suffix:semicolon
id|sitd
op_assign
id|pci_pool_alloc
(paren
id|ehci-&gt;sitd_pool
comma
id|mem_flags
comma
op_amp
id|dma
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sitd
)paren
r_return
id|sitd
suffix:semicolon
id|sitd-&gt;urb
op_assign
id|urb
suffix:semicolon
id|length
op_assign
id|urb-&gt;iso_frame_desc
(braket
id|index
)braket
dot
id|length
suffix:semicolon
id|dma
op_add_assign
id|urb-&gt;iso_frame_desc
(braket
id|index
)braket
dot
id|offset
suffix:semicolon
macro_line|#if 0
singleline_comment|// FIXME:  do the rest!
macro_line|#else
id|sitd_free
(paren
id|ehci
comma
id|sitd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#endif
)brace
r_static
r_inline
r_void
DECL|function|sitd_link
id|sitd_link
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_int
id|frame
comma
r_struct
id|ehci_sitd
op_star
id|sitd
)paren
(brace
id|u32
id|ptr
suffix:semicolon
id|ptr
op_assign
id|cpu_to_le32
(paren
id|sitd-&gt;sitd_dma
op_or
l_int|2
)paren
suffix:semicolon
singleline_comment|// type 2 == sitd
r_if
c_cond
(paren
id|ehci-&gt;pshadow
(braket
id|frame
)braket
dot
id|ptr
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sitd-&gt;sitd_next.ptr
)paren
(brace
id|sitd-&gt;sitd_next
op_assign
id|ehci-&gt;pshadow
(braket
id|frame
)braket
suffix:semicolon
id|sitd-&gt;hw_next
op_assign
id|ehci-&gt;periodic
(braket
id|frame
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sitd-&gt;sitd_next.ptr
op_ne
id|ehci-&gt;pshadow
(braket
id|frame
)braket
dot
id|ptr
)paren
(brace
id|dbg
(paren
l_string|&quot;frame %d sitd link goof&quot;
comma
id|frame
)paren
suffix:semicolon
id|BUG
(paren
)paren
suffix:semicolon
)brace
)brace
id|ehci-&gt;pshadow
(braket
id|frame
)braket
dot
id|sitd
op_assign
id|sitd
suffix:semicolon
id|ehci-&gt;periodic
(braket
id|frame
)braket
op_assign
id|ptr
suffix:semicolon
)brace
r_static
r_int
r_int
DECL|function|sitd_complete
id|sitd_complete
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|ehci_sitd
op_star
id|sitd
comma
r_int
r_int
id|flags
)paren
(brace
singleline_comment|// FIXME -- implement!
id|dbg
(paren
l_string|&quot;NYI -- sitd_complete&quot;
)paren
suffix:semicolon
r_return
id|flags
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|sitd_submit
r_static
r_int
id|sitd_submit
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
singleline_comment|// struct ehci_sitd&t;*first_sitd = 0;
r_int
id|frame_index
suffix:semicolon
id|dma_addr_t
id|dma
suffix:semicolon
r_int
id|mem_flags
suffix:semicolon
id|dbg
(paren
l_string|&quot;NYI -- sitd_submit&quot;
)paren
suffix:semicolon
singleline_comment|// FIXME -- implement!
singleline_comment|// FIXME:  setup one big dma mapping
id|dma
op_assign
l_int|0
suffix:semicolon
id|mem_flags
op_assign
id|SLAB_ATOMIC
suffix:semicolon
r_for
c_loop
(paren
id|frame_index
op_assign
l_int|0
suffix:semicolon
id|frame_index
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|frame_index
op_increment
)paren
(brace
r_struct
id|ehci_sitd
op_star
id|sitd
suffix:semicolon
r_int
id|uframe
suffix:semicolon
singleline_comment|// FIXME:  use real arguments, schedule this!
id|uframe
op_assign
op_minus
l_int|1
suffix:semicolon
id|sitd
op_assign
id|sitd_make
(paren
id|ehci
comma
id|urb
comma
id|frame_index
comma
id|uframe
comma
id|dma
comma
id|mem_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sitd
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;if (first_sitd)&n;&t;&t;&t;&t;list_add_tail (&amp;sitd-&gt;sitd_list,&n;&t;&t;&t;&t;&t;&t;&amp;first_sitd-&gt;sitd_list);&n;&t;&t;&t;else&n;&t;&t;&t;&t;first_sitd = sitd;&n;    */
)brace
r_else
(brace
singleline_comment|// FIXME:  clean everything up
)brace
)brace
singleline_comment|// if we have a first sitd, then
singleline_comment|// store them all into the periodic schedule!
singleline_comment|// urb-&gt;hcpriv = first sitd in sitd_list
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
macro_line|#endif&t;/* have_iso */
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|scan_periodic
r_static
r_void
id|scan_periodic
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
)paren
(brace
r_int
id|frame
suffix:semicolon
r_int
id|clock
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * When running, scan from last scan point up to &quot;now&quot;&n;&t; * Touches as few pages as possible:  cache-friendly.&n;&t; * It&squot;s safe to scan entries more than once, though.&n;&t; */
r_if
c_cond
(paren
id|HCD_IS_RUNNING
(paren
id|ehci-&gt;hcd.state
)paren
)paren
(brace
id|frame
op_assign
id|ehci-&gt;next_frame
suffix:semicolon
id|clock
op_assign
id|ehci_get_frame
(paren
op_amp
id|ehci-&gt;hcd
)paren
suffix:semicolon
multiline_comment|/* when shutting down, scan everything for thoroughness */
)brace
r_else
(brace
id|frame
op_assign
l_int|0
suffix:semicolon
id|clock
op_assign
id|ehci-&gt;periodic_size
op_minus
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_union
id|ehci_shadow
id|q
suffix:semicolon
id|u32
id|type
suffix:semicolon
id|restart
suffix:colon
id|q.ptr
op_assign
id|ehci-&gt;pshadow
(braket
id|frame
)braket
dot
id|ptr
suffix:semicolon
id|type
op_assign
id|Q_NEXT_TYPE
(paren
id|ehci-&gt;periodic
(braket
id|frame
)braket
)paren
suffix:semicolon
multiline_comment|/* scan each element in frame&squot;s queue for completions */
r_while
c_loop
(paren
id|q.ptr
op_ne
l_int|0
)paren
(brace
r_int
id|last
suffix:semicolon
r_union
id|ehci_shadow
id|temp
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|Q_TYPE_QH
suffix:colon
id|last
op_assign
(paren
id|q.qh-&gt;hw_next
op_eq
id|EHCI_LIST_END
)paren
suffix:semicolon
id|flags
op_assign
id|intr_complete
(paren
id|ehci
comma
id|frame
comma
id|qh_put
(paren
id|q.qh
)paren
comma
id|flags
)paren
suffix:semicolon
id|type
op_assign
id|Q_NEXT_TYPE
(paren
id|q.qh-&gt;hw_next
)paren
suffix:semicolon
id|temp
op_assign
id|q.qh-&gt;qh_next
suffix:semicolon
id|qh_unput
(paren
id|ehci
comma
id|q.qh
)paren
suffix:semicolon
id|q
op_assign
id|temp
suffix:semicolon
r_break
suffix:semicolon
r_case
id|Q_TYPE_FSTN
suffix:colon
id|last
op_assign
(paren
id|q.fstn-&gt;hw_next
op_eq
id|EHCI_LIST_END
)paren
suffix:semicolon
multiline_comment|/* for &quot;save place&quot; FSTNs, look at QH entries&n;&t;&t;&t;&t; * in the previous frame for completions.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|q.fstn-&gt;hw_prev
op_ne
id|EHCI_LIST_END
)paren
(brace
id|dbg
(paren
l_string|&quot;ignoring completions from FSTNs&quot;
)paren
suffix:semicolon
)brace
id|type
op_assign
id|Q_NEXT_TYPE
(paren
id|q.fstn-&gt;hw_next
)paren
suffix:semicolon
id|temp
op_assign
id|q.fstn-&gt;fstn_next
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef have_iso
r_case
id|Q_TYPE_ITD
suffix:colon
id|last
op_assign
(paren
id|q.itd-&gt;hw_next
op_eq
id|EHCI_LIST_END
)paren
suffix:semicolon
id|flags
op_assign
id|itd_complete
(paren
id|ehci
comma
id|q.itd
comma
id|flags
)paren
suffix:semicolon
id|type
op_assign
id|Q_NEXT_TYPE
(paren
id|q.itd-&gt;hw_next
)paren
suffix:semicolon
id|q
op_assign
id|q.itd-&gt;itd_next
suffix:semicolon
r_break
suffix:semicolon
r_case
id|Q_TYPE_SITD
suffix:colon
id|last
op_assign
(paren
id|q.sitd-&gt;hw_next
op_eq
id|EHCI_LIST_END
)paren
suffix:semicolon
id|flags
op_assign
id|sitd_complete
(paren
id|ehci
comma
id|q.sitd
comma
id|flags
)paren
suffix:semicolon
id|type
op_assign
id|Q_NEXT_TYPE
(paren
id|q.sitd-&gt;hw_next
)paren
suffix:semicolon
id|q
op_assign
id|q.sitd-&gt;sitd_next
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /* have_iso */
r_default
suffix:colon
id|dbg
(paren
l_string|&quot;corrupt type %d frame %d shadow %p&quot;
comma
id|type
comma
id|frame
comma
id|q.ptr
)paren
suffix:semicolon
singleline_comment|// BUG ();
id|last
op_assign
l_int|1
suffix:semicolon
id|q.ptr
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* did completion remove an interior q entry? */
r_if
c_cond
(paren
id|unlikely
(paren
id|q.ptr
op_eq
l_int|0
op_logical_and
op_logical_neg
id|last
)paren
)paren
r_goto
id|restart
suffix:semicolon
)brace
multiline_comment|/* stop when we catch up to the HC */
singleline_comment|// FIXME:  this assumes we won&squot;t get lapped when
singleline_comment|// latencies climb; that should be rare, but...
singleline_comment|// detect it, and just go all the way around.
singleline_comment|// FLR might help detect this case, so long as latencies
singleline_comment|// don&squot;t exceed periodic_size msec (default 1.024 sec).
singleline_comment|// FIXME:  likewise assumes HC doesn&squot;t halt mid-scan
r_if
c_cond
(paren
id|frame
op_eq
id|clock
)paren
(brace
r_int
id|now
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|HCD_IS_RUNNING
(paren
id|ehci-&gt;hcd.state
)paren
)paren
r_break
suffix:semicolon
id|ehci-&gt;next_frame
op_assign
id|clock
suffix:semicolon
id|now
op_assign
id|ehci_get_frame
(paren
op_amp
id|ehci-&gt;hcd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clock
op_eq
id|now
)paren
r_break
suffix:semicolon
id|clock
op_assign
id|now
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_increment
id|frame
op_ge
id|ehci-&gt;periodic_size
)paren
id|frame
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
eof
