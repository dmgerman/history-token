multiline_comment|/*&n; * Copyright (c) 2000-2002 by David Brownell&n; * &n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2 of the License, or (at your&n; * option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY&n; * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License&n; * for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software Foundation,&n; * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#ifdef CONFIG_USB_DEBUG
DECL|macro|DEBUG
mdefine_line|#define DEBUG
macro_line|#else
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#endif
macro_line|#include &lt;linux/usb.h&gt;
macro_line|#include &quot;../hcd.h&quot;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/unaligned.h&gt;
singleline_comment|//#undef KERN_DEBUG
singleline_comment|//#define KERN_DEBUG &quot;&quot;
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * EHCI hc_driver implementation ... experimental, incomplete.&n; * Based on the 0.96 register interface specification.&n; *&n; * There are lots of things to help out with here ... notably&n; * everything &quot;periodic&quot;, and of course testing with all sorts&n; * of usb 2.0 devices and configurations.&n; *&n; * USB 2.0 shows up in upcoming www.pcmcia.org technology.&n; * First was PCMCIA, like ISA; then CardBus, which is PCI.&n; * Next comes &quot;CardBay&quot;, using USB 2.0 signals.&n; *&n; * Contains additional contributions by:&n; *&t;Brad Hards&n; *&t;Rory Bolt&n; *&t;...&n; *&n; * HISTORY:&n; *&n; * 2002-03-05&t;Initial high-speed ISO support; reduce ITD memory; shift&n; *&t;more checking to generic hcd framework (db).  Make it work with&n; *&t;Philips EHCI; reduce PCI traffic; shorten IRQ path (Rory Bolt).&n; * 2002-01-14&t;Minor cleanup; version synch.&n; * 2002-01-08&t;Fix roothub handoff of FS/LS to companion controllers.&n; * 2002-01-04&t;Control/Bulk queuing behaves.&n; *&n; * 2001-12-12&t;Initial patch version for Linux 2.5.1 kernel.&n; * 2001-June&t;Works with usb-storage and NEC EHCI on 2.4&n; */
DECL|macro|DRIVER_VERSION
mdefine_line|#define DRIVER_VERSION &quot;$Revision: 0.27 $&quot;
DECL|macro|DRIVER_AUTHOR
mdefine_line|#define DRIVER_AUTHOR &quot;David Brownell&quot;
DECL|macro|DRIVER_DESC
mdefine_line|#define DRIVER_DESC &quot;USB 2.0 &squot;Enhanced&squot; Host Controller (EHCI) Driver&quot;
singleline_comment|// #define EHCI_VERBOSE_DEBUG
singleline_comment|// #define have_split_iso
multiline_comment|/* magic numbers that can affect system performance */
DECL|macro|EHCI_TUNE_CERR
mdefine_line|#define&t;EHCI_TUNE_CERR&t;&t;3&t;/* 0-3 qtd retries; 0 == don&squot;t stop */
DECL|macro|EHCI_TUNE_RL_HS
mdefine_line|#define&t;EHCI_TUNE_RL_HS&t;&t;0&t;/* nak throttle; see 4.9 */
DECL|macro|EHCI_TUNE_RL_TT
mdefine_line|#define&t;EHCI_TUNE_RL_TT&t;&t;0
DECL|macro|EHCI_TUNE_MULT_HS
mdefine_line|#define&t;EHCI_TUNE_MULT_HS&t;1&t;/* 1-3 transactions/uframe; 4.10.3 */
DECL|macro|EHCI_TUNE_MULT_TT
mdefine_line|#define&t;EHCI_TUNE_MULT_TT&t;1
multiline_comment|/* Initial IRQ latency:  lower than default */
DECL|variable|log2_irq_thresh
r_static
r_int
id|log2_irq_thresh
op_assign
l_int|0
suffix:semicolon
singleline_comment|// 0 to 6
id|MODULE_PARM
(paren
id|log2_irq_thresh
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
(paren
id|log2_irq_thresh
comma
l_string|&quot;log2 IRQ latency, 1-64 microframes&quot;
)paren
suffix:semicolon
DECL|macro|INTR_MASK
mdefine_line|#define&t;INTR_MASK (STS_IAA | STS_FATAL | STS_ERR | STS_INT)
multiline_comment|/*-------------------------------------------------------------------------*/
macro_line|#include &quot;ehci.h&quot;
macro_line|#include &quot;ehci-dbg.c&quot;
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * hc states include: unknown, halted, ready, running&n; * transitional states are messy just now&n; * trying to avoid &quot;running&quot; unless urbs are active&n; * a &quot;ready&quot; hc can be finishing prefetched work&n; */
multiline_comment|/* halt a non-running controller */
DECL|function|ehci_reset
r_static
r_void
id|ehci_reset
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
)paren
(brace
id|u32
id|command
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
id|command
op_or_assign
id|CMD_RESET
suffix:semicolon
id|dbg_cmd
(paren
id|ehci
comma
l_string|&quot;reset&quot;
comma
id|command
)paren
suffix:semicolon
id|writel
(paren
id|command
comma
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
r_while
c_loop
(paren
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
op_amp
id|CMD_RESET
)paren
r_continue
suffix:semicolon
id|ehci-&gt;hcd.state
op_assign
id|USB_STATE_HALT
suffix:semicolon
)brace
multiline_comment|/* idle the controller (from running) */
DECL|function|ehci_ready
r_static
r_void
id|ehci_ready
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
)paren
(brace
id|u32
id|command
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
op_logical_neg
id|HCD_IS_RUNNING
(paren
id|ehci-&gt;hcd.state
)paren
)paren
id|BUG
(paren
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
op_logical_neg
(paren
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;status
)paren
op_amp
(paren
id|STS_ASS
op_or
id|STS_PSS
)paren
)paren
)paren
id|udelay
(paren
l_int|100
)paren
suffix:semicolon
id|command
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
id|command
op_and_assign
op_complement
(paren
id|CMD_ASE
op_or
id|CMD_IAAD
op_or
id|CMD_PSE
)paren
suffix:semicolon
id|writel
(paren
id|command
comma
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
singleline_comment|// hardware can take 16 microframes to turn off ...
id|ehci-&gt;hcd.state
op_assign
id|USB_STATE_READY
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
macro_line|#include &quot;ehci-hub.c&quot;
macro_line|#include &quot;ehci-mem.c&quot;
macro_line|#include &quot;ehci-q.c&quot;
macro_line|#include &quot;ehci-sched.c&quot;
multiline_comment|/*-------------------------------------------------------------------------*/
r_static
r_void
id|ehci_tasklet
(paren
r_int
r_int
id|param
)paren
suffix:semicolon
multiline_comment|/* called by khubd or root hub init threads */
DECL|function|ehci_start
r_static
r_int
id|ehci_start
(paren
r_struct
id|usb_hcd
op_star
id|hcd
)paren
(brace
r_struct
id|ehci_hcd
op_star
id|ehci
op_assign
id|hcd_to_ehci
(paren
id|hcd
)paren
suffix:semicolon
id|u32
id|temp
suffix:semicolon
r_struct
id|usb_device
op_star
id|udev
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|u32
id|hcc_params
suffix:semicolon
id|u8
id|tempbyte
suffix:semicolon
singleline_comment|// FIXME:  given EHCI 0.96 or later, and a controller with
singleline_comment|// the USBLEGSUP/USBLEGCTLSTS extended capability, make sure
singleline_comment|// the BIOS doesn&squot;t still own this controller.
id|spin_lock_init
(paren
op_amp
id|ehci-&gt;lock
)paren
suffix:semicolon
id|ehci-&gt;caps
op_assign
(paren
r_struct
id|ehci_caps
op_star
)paren
id|hcd-&gt;regs
suffix:semicolon
id|ehci-&gt;regs
op_assign
(paren
r_struct
id|ehci_regs
op_star
)paren
(paren
id|hcd-&gt;regs
op_plus
id|ehci-&gt;caps-&gt;length
)paren
suffix:semicolon
id|dbg_hcs_params
(paren
id|ehci
comma
l_string|&quot;ehci_start&quot;
)paren
suffix:semicolon
id|dbg_hcc_params
(paren
id|ehci
comma
l_string|&quot;ehci_start&quot;
)paren
suffix:semicolon
multiline_comment|/* cache this readonly data; minimize PCI reads */
id|ehci-&gt;hcs_params
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;caps-&gt;hcs_params
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * hw default: 1K periodic list heads, one per frame.&n;&t; * periodic_size can shrink by USBCMD update if hcc_params allows.&n;&t; */
id|ehci-&gt;periodic_size
op_assign
id|DEFAULT_I_TDPS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|ehci_mem_init
(paren
id|ehci
comma
id|SLAB_KERNEL
)paren
)paren
OL
l_int|0
)paren
r_return
id|retval
suffix:semicolon
id|hcc_params
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;caps-&gt;hcc_params
)paren
suffix:semicolon
multiline_comment|/* controllers may cache some of the periodic schedule ... */
r_if
c_cond
(paren
id|HCC_ISOC_CACHE
(paren
id|hcc_params
)paren
)paren
singleline_comment|// full frame cache
id|ehci-&gt;i_thresh
op_assign
l_int|8
suffix:semicolon
r_else
singleline_comment|// N microframes cached
id|ehci-&gt;i_thresh
op_assign
l_int|2
op_plus
id|HCC_ISOC_THRES
(paren
id|hcc_params
)paren
suffix:semicolon
id|ehci-&gt;async
op_assign
l_int|0
suffix:semicolon
id|ehci-&gt;reclaim
op_assign
l_int|0
suffix:semicolon
id|ehci-&gt;next_uframe
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* controller state:  unknown --&gt; reset */
multiline_comment|/* EHCI spec section 4.1 */
id|ehci_reset
(paren
id|ehci
)paren
suffix:semicolon
id|writel
(paren
id|INTR_MASK
comma
op_amp
id|ehci-&gt;regs-&gt;intr_enable
)paren
suffix:semicolon
id|writel
(paren
id|ehci-&gt;periodic_dma
comma
op_amp
id|ehci-&gt;regs-&gt;frame_list
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * hcc_params controls whether ehci-&gt;regs-&gt;segment must (!!!)&n;&t; * be used; it constrains QH/ITD/SITD and QTD locations.&n;&t; * By default, pci_alloc_consistent() won&squot;t hand out addresses&n;&t; * above 4GB (via pdev-&gt;dma_mask) so we know this value.&n;&t; *&n;&t; * NOTE:  that pdev-&gt;dma_mask setting means that all DMA mappings&n;&t; * for I/O buffers will have the same restriction, though it&squot;s&n;&t; * neither necessary nor desirable in that case.&n;&t; */
r_if
c_cond
(paren
id|HCC_64BIT_ADDR
(paren
id|hcc_params
)paren
)paren
(brace
id|writel
(paren
l_int|0
comma
op_amp
id|ehci-&gt;regs-&gt;segment
)paren
suffix:semicolon
id|info
(paren
l_string|&quot;using segment 0 for 64bit DMA addresses ...&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* clear interrupt enables, set irq latency */
id|temp
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|log2_irq_thresh
template_param
l_int|6
)paren
id|log2_irq_thresh
op_assign
l_int|0
suffix:semicolon
id|temp
op_or_assign
l_int|1
op_lshift
(paren
l_int|16
op_plus
id|log2_irq_thresh
)paren
suffix:semicolon
singleline_comment|// keeping default periodic framelist size
id|temp
op_and_assign
op_complement
(paren
id|CMD_IAAD
op_or
id|CMD_ASE
op_or
id|CMD_PSE
)paren
comma
id|writel
(paren
id|temp
comma
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
id|dbg_cmd
(paren
id|ehci
comma
l_string|&quot;init&quot;
comma
id|temp
)paren
suffix:semicolon
multiline_comment|/* set async sleep time = 10 us ... ? */
id|ehci-&gt;tasklet.func
op_assign
id|ehci_tasklet
suffix:semicolon
id|ehci-&gt;tasklet.data
op_assign
(paren
r_int
r_int
)paren
id|ehci
suffix:semicolon
multiline_comment|/* wire up the root hub */
id|hcd-&gt;bus-&gt;root_hub
op_assign
id|udev
op_assign
id|usb_alloc_dev
(paren
l_int|NULL
comma
id|hcd-&gt;bus
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|udev
)paren
(brace
id|done2
suffix:colon
id|ehci_mem_cleanup
(paren
id|ehci
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Start, enabling full USB 2.0 functionality ... usb 1.1 devices&n;&t; * are explicitly handed to companion controller(s), so no TT is&n;&t; * involved with the root hub.&n;&t; */
id|ehci-&gt;hcd.state
op_assign
id|USB_STATE_READY
suffix:semicolon
id|writel
(paren
id|FLAG_CF
comma
op_amp
id|ehci-&gt;regs-&gt;configured_flag
)paren
suffix:semicolon
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
multiline_comment|/* unblock posted write */
multiline_comment|/* PCI Serial Bus Release Number is at 0x60 offset */
id|pci_read_config_byte
c_func
(paren
id|hcd-&gt;pdev
comma
l_int|0x60
comma
op_amp
id|tempbyte
)paren
suffix:semicolon
id|temp
op_assign
id|readw
(paren
op_amp
id|ehci-&gt;caps-&gt;hci_version
)paren
suffix:semicolon
id|info
(paren
l_string|&quot;USB %x.%x support enabled, EHCI rev %x.%2x&quot;
comma
(paren
(paren
id|tempbyte
op_amp
l_int|0xf0
)paren
op_rshift
l_int|4
)paren
comma
(paren
id|tempbyte
op_amp
l_int|0x0f
)paren
comma
id|temp
op_rshift
l_int|8
comma
id|temp
op_amp
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * From here on, khubd concurrently accesses the root&n;&t; * hub; drivers will be talking to enumerated devices.&n;&t; *&n;&t; * Before this point the HC was idle/ready.  After, khubd&n;&t; * and device drivers may start it running.&n;&t; */
id|usb_connect
(paren
id|udev
)paren
suffix:semicolon
id|udev-&gt;speed
op_assign
id|USB_SPEED_HIGH
suffix:semicolon
r_if
c_cond
(paren
id|usb_register_root_hub
(paren
id|udev
comma
op_amp
id|ehci-&gt;hcd.pdev-&gt;dev
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|hcd-&gt;state
op_eq
id|USB_STATE_RUNNING
)paren
id|ehci_ready
(paren
id|ehci
)paren
suffix:semicolon
r_while
c_loop
(paren
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;status
)paren
op_amp
(paren
id|STS_ASS
op_or
id|STS_PSS
)paren
)paren
id|udelay
(paren
l_int|100
)paren
suffix:semicolon
id|ehci_reset
(paren
id|ehci
)paren
suffix:semicolon
singleline_comment|// usb_disconnect (udev); 
id|hcd-&gt;bus-&gt;root_hub
op_assign
l_int|0
suffix:semicolon
id|usb_free_dev
(paren
id|udev
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|done2
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* always called by thread; normally rmmod */
DECL|function|ehci_stop
r_static
r_void
id|ehci_stop
(paren
r_struct
id|usb_hcd
op_star
id|hcd
)paren
(brace
r_struct
id|ehci_hcd
op_star
id|ehci
op_assign
id|hcd_to_ehci
(paren
id|hcd
)paren
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s: stop&quot;
comma
id|hcd-&gt;bus_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hcd-&gt;state
op_eq
id|USB_STATE_RUNNING
)paren
id|ehci_ready
(paren
id|ehci
)paren
suffix:semicolon
r_while
c_loop
(paren
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;status
)paren
op_amp
(paren
id|STS_ASS
op_or
id|STS_PSS
)paren
)paren
id|udelay
(paren
l_int|100
)paren
suffix:semicolon
id|ehci_reset
(paren
id|ehci
)paren
suffix:semicolon
singleline_comment|// root hub is shut down separately (first, when possible)
id|scan_async
(paren
id|ehci
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ehci-&gt;next_uframe
op_ne
op_minus
l_int|1
)paren
id|scan_periodic
(paren
id|ehci
)paren
suffix:semicolon
id|ehci_mem_cleanup
(paren
id|ehci
)paren
suffix:semicolon
id|dbg_status
(paren
id|ehci
comma
l_string|&quot;ehci_stop completed&quot;
comma
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;status
)paren
)paren
suffix:semicolon
)brace
DECL|function|ehci_get_frame
r_static
r_int
id|ehci_get_frame
(paren
r_struct
id|usb_hcd
op_star
id|hcd
)paren
(brace
r_struct
id|ehci_hcd
op_star
id|ehci
op_assign
id|hcd_to_ehci
(paren
id|hcd
)paren
suffix:semicolon
r_return
(paren
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;frame_index
)paren
op_rshift
l_int|3
)paren
op_mod
id|ehci-&gt;periodic_size
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
macro_line|#ifdef&t;CONFIG_PM
multiline_comment|/* suspend/resume, section 4.3 */
DECL|function|ehci_suspend
r_static
r_int
id|ehci_suspend
(paren
r_struct
id|usb_hcd
op_star
id|hcd
comma
id|u32
id|state
)paren
(brace
r_struct
id|ehci_hcd
op_star
id|ehci
op_assign
id|hcd_to_ehci
(paren
id|hcd
)paren
suffix:semicolon
r_int
id|ports
suffix:semicolon
r_int
id|i
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s: suspend to %d&quot;
comma
id|hcd-&gt;bus_name
comma
id|state
)paren
suffix:semicolon
id|ports
op_assign
id|HCS_N_PORTS
(paren
id|ehci-&gt;hcs_params
)paren
suffix:semicolon
singleline_comment|// FIXME:  This assumes what&squot;s probably a D3 level suspend...
singleline_comment|// FIXME:  usb wakeup events on this bus should resume the machine.
singleline_comment|// pci config register PORTWAKECAP controls which ports can do it;
singleline_comment|// bios may have initted the register...
multiline_comment|/* suspend each port, then stop the hc */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ports
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|temp
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;port_status
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|temp
op_amp
id|PORT_PE
)paren
op_eq
l_int|0
op_logical_or
(paren
id|temp
op_amp
id|PORT_OWNER
)paren
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s: suspend port %d&quot;
comma
id|hcd-&gt;bus_name
comma
id|i
)paren
suffix:semicolon
id|temp
op_or_assign
id|PORT_SUSPEND
suffix:semicolon
id|writel
(paren
id|temp
comma
op_amp
id|ehci-&gt;regs-&gt;port_status
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hcd-&gt;state
op_eq
id|USB_STATE_RUNNING
)paren
id|ehci_ready
(paren
id|ehci
)paren
suffix:semicolon
r_while
c_loop
(paren
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;status
)paren
op_amp
(paren
id|STS_ASS
op_or
id|STS_PSS
)paren
)paren
id|udelay
(paren
l_int|100
)paren
suffix:semicolon
id|writel
(paren
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
op_amp
op_complement
id|CMD_RUN
comma
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
singleline_comment|// save pci FLADJ value
multiline_comment|/* who tells PCI to reduce power consumption? */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ehci_resume
r_static
r_int
id|ehci_resume
(paren
r_struct
id|usb_hcd
op_star
id|hcd
)paren
(brace
r_struct
id|ehci_hcd
op_star
id|ehci
op_assign
id|hcd_to_ehci
(paren
id|hcd
)paren
suffix:semicolon
r_int
id|ports
suffix:semicolon
r_int
id|i
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s: resume&quot;
comma
id|hcd-&gt;bus_name
)paren
suffix:semicolon
id|ports
op_assign
id|HCS_N_PORTS
(paren
id|ehci-&gt;hcs_params
)paren
suffix:semicolon
singleline_comment|// FIXME:  if controller didn&squot;t retain state,
singleline_comment|// return and let generic code clean it up
singleline_comment|// test configured_flag ?
multiline_comment|/* resume HC and each port */
singleline_comment|// restore pci FLADJ value
singleline_comment|// khubd and drivers will set HC running, if needed;
id|hcd-&gt;state
op_assign
id|USB_STATE_READY
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ports
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|temp
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;port_status
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|temp
op_amp
id|PORT_PE
)paren
op_eq
l_int|0
op_logical_or
(paren
id|temp
op_amp
id|PORT_SUSPEND
)paren
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s: resume port %d&quot;
comma
id|hcd-&gt;bus_name
comma
id|i
)paren
suffix:semicolon
id|temp
op_or_assign
id|PORT_RESUME
suffix:semicolon
id|writel
(paren
id|temp
comma
op_amp
id|ehci-&gt;regs-&gt;port_status
(braket
id|i
)braket
)paren
suffix:semicolon
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
multiline_comment|/* unblock posted writes */
id|wait_ms
(paren
l_int|20
)paren
suffix:semicolon
id|temp
op_and_assign
op_complement
id|PORT_RESUME
suffix:semicolon
id|writel
(paren
id|temp
comma
op_amp
id|ehci-&gt;regs-&gt;port_status
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
multiline_comment|/* unblock posted writes */
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * tasklet scheduled by some interrupts and other events&n; * calls driver completion functions ... but not in_irq()&n; */
DECL|function|ehci_tasklet
r_static
r_void
id|ehci_tasklet
(paren
r_int
r_int
id|param
)paren
(brace
r_struct
id|ehci_hcd
op_star
id|ehci
op_assign
(paren
r_struct
id|ehci_hcd
op_star
)paren
id|param
suffix:semicolon
r_if
c_cond
(paren
id|ehci-&gt;reclaim_ready
)paren
id|end_unlink_async
(paren
id|ehci
)paren
suffix:semicolon
id|scan_async
(paren
id|ehci
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ehci-&gt;next_uframe
op_ne
op_minus
l_int|1
)paren
id|scan_periodic
(paren
id|ehci
)paren
suffix:semicolon
singleline_comment|// FIXME:  when nothing is connected to the root hub,
singleline_comment|// turn off the RUN bit so the host can enter C3 &quot;sleep&quot; power
singleline_comment|// saving mode; make root hub code scan memory less often.
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|ehci_irq
r_static
r_void
id|ehci_irq
(paren
r_struct
id|usb_hcd
op_star
id|hcd
)paren
(brace
r_struct
id|ehci_hcd
op_star
id|ehci
op_assign
id|hcd_to_ehci
(paren
id|hcd
)paren
suffix:semicolon
id|u32
id|status
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;status
)paren
suffix:semicolon
r_int
id|bh
suffix:semicolon
id|status
op_and_assign
id|INTR_MASK
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
multiline_comment|/* irq sharing? */
r_return
suffix:semicolon
multiline_comment|/* clear (just) interrupts */
id|writel
(paren
id|status
comma
op_amp
id|ehci-&gt;regs-&gt;status
)paren
suffix:semicolon
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
multiline_comment|/* unblock posted write */
id|bh
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef&t;EHCI_VERBOSE_DEBUG
multiline_comment|/* unrequested/ignored: Port Change Detect, Frame List Rollover */
id|dbg_status
(paren
id|ehci
comma
l_string|&quot;irq&quot;
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* INT, ERR, and IAA interrupt rates can be throttled */
multiline_comment|/* normal [4.15.1.2] or error [4.15.1.1] completion */
r_if
c_cond
(paren
id|likely
(paren
(paren
id|status
op_amp
(paren
id|STS_INT
op_or
id|STS_ERR
)paren
)paren
op_ne
l_int|0
)paren
)paren
id|bh
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* complete the unlinking of some qh [4.15.2.3] */
r_if
c_cond
(paren
id|status
op_amp
id|STS_IAA
)paren
(brace
id|ehci-&gt;reclaim_ready
op_assign
l_int|1
suffix:semicolon
id|bh
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* PCI errors [4.15.2.4] */
r_if
c_cond
(paren
id|unlikely
(paren
(paren
id|status
op_amp
id|STS_FATAL
)paren
op_ne
l_int|0
)paren
)paren
(brace
id|err
(paren
l_string|&quot;%s: fatal error, state %x&quot;
comma
id|hcd-&gt;bus_name
comma
id|hcd-&gt;state
)paren
suffix:semicolon
id|ehci_reset
(paren
id|ehci
)paren
suffix:semicolon
singleline_comment|// generic layer kills/unlinks all urbs
singleline_comment|// then tasklet cleans up the rest
id|bh
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* most work doesn&squot;t need to be in_irq() */
r_if
c_cond
(paren
id|likely
(paren
id|bh
op_eq
l_int|1
)paren
)paren
id|tasklet_schedule
(paren
op_amp
id|ehci-&gt;tasklet
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * non-error returns are a promise to giveback() the urb later&n; * we drop ownership so next owner (or urb unlink) can get it&n; *&n; * urb + dev is in hcd_dev.urb_list&n; * we&squot;re queueing TDs onto software and hardware lists&n; *&n; * hcd-specific init for hcpriv hasn&squot;t been done yet&n; *&n; * NOTE:  EHCI queues control and bulk requests transparently, like OHCI.&n; */
DECL|function|ehci_urb_enqueue
r_static
r_int
id|ehci_urb_enqueue
(paren
r_struct
id|usb_hcd
op_star
id|hcd
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|mem_flags
)paren
(brace
r_struct
id|ehci_hcd
op_star
id|ehci
op_assign
id|hcd_to_ehci
(paren
id|hcd
)paren
suffix:semicolon
r_struct
id|list_head
id|qtd_list
suffix:semicolon
id|urb-&gt;transfer_flags
op_and_assign
op_complement
id|EHCI_STATE_UNLINK
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|qtd_list
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|usb_pipetype
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
r_case
id|PIPE_CONTROL
suffix:colon
r_case
id|PIPE_BULK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|qh_urb_transaction
(paren
id|ehci
comma
id|urb
comma
op_amp
id|qtd_list
comma
id|mem_flags
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|submit_async
(paren
id|ehci
comma
id|urb
comma
op_amp
id|qtd_list
comma
id|mem_flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_INTERRUPT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|qh_urb_transaction
(paren
id|ehci
comma
id|urb
comma
op_amp
id|qtd_list
comma
id|mem_flags
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_return
id|intr_submit
(paren
id|ehci
comma
id|urb
comma
op_amp
id|qtd_list
comma
id|mem_flags
)paren
suffix:semicolon
r_case
id|PIPE_ISOCHRONOUS
suffix:colon
r_if
c_cond
(paren
id|urb-&gt;dev-&gt;speed
op_eq
id|USB_SPEED_HIGH
)paren
r_return
id|itd_submit
(paren
id|ehci
comma
id|urb
comma
id|mem_flags
)paren
suffix:semicolon
macro_line|#ifdef have_split_iso
r_else
r_return
id|sitd_submit
(paren
id|ehci
comma
id|urb
comma
id|mem_flags
)paren
suffix:semicolon
macro_line|#else
id|dbg
(paren
l_string|&quot;no split iso support yet&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOSYS
suffix:semicolon
macro_line|#endif /* have_split_iso */
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* remove from hardware lists&n; * completions normally happen asynchronously&n; */
DECL|function|ehci_urb_dequeue
r_static
r_int
id|ehci_urb_dequeue
(paren
r_struct
id|usb_hcd
op_star
id|hcd
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|ehci_hcd
op_star
id|ehci
op_assign
id|hcd_to_ehci
(paren
id|hcd
)paren
suffix:semicolon
r_struct
id|ehci_qh
op_star
id|qh
op_assign
(paren
r_struct
id|ehci_qh
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s urb_dequeue %p qh state %d&quot;
comma
id|hcd-&gt;bus_name
comma
id|urb
comma
id|qh-&gt;qh_state
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|usb_pipetype
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
r_case
id|PIPE_CONTROL
suffix:colon
r_case
id|PIPE_BULK
suffix:colon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ehci-&gt;reclaim
)paren
(brace
id|dbg
(paren
l_string|&quot;dq: reclaim busy, %s&quot;
comma
id|RUN_CONTEXT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_interrupt
(paren
)paren
)paren
(brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_while
c_loop
(paren
id|qh-&gt;qh_state
op_eq
id|QH_STATE_LINKED
op_logical_and
id|ehci-&gt;reclaim
op_logical_and
id|ehci-&gt;hcd.state
op_ne
id|USB_STATE_HALT
)paren
(brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
singleline_comment|// yeech ... this could spin for up to two frames!
id|dbg
(paren
l_string|&quot;wait for dequeue: state %d, reclaim %p, hcd state %d&quot;
comma
id|qh-&gt;qh_state
comma
id|ehci-&gt;reclaim
comma
id|ehci-&gt;hcd.state
)paren
suffix:semicolon
id|udelay
(paren
l_int|100
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|qh-&gt;qh_state
op_eq
id|QH_STATE_LINKED
)paren
id|start_unlink_async
(paren
id|ehci
comma
id|qh
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|PIPE_INTERRUPT
suffix:colon
id|intr_deschedule
(paren
id|ehci
comma
id|urb-&gt;start_frame
comma
id|qh
comma
id|urb-&gt;interval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ehci-&gt;hcd.state
op_eq
id|USB_STATE_HALT
)paren
id|urb-&gt;status
op_assign
op_minus
id|ESHUTDOWN
suffix:semicolon
id|qh_completions
(paren
id|ehci
comma
op_amp
id|qh-&gt;qtd_list
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|PIPE_ISOCHRONOUS
suffix:colon
singleline_comment|// itd or sitd ...
singleline_comment|// wait till next completion, do it then.
singleline_comment|// completion irqs can wait up to 128 msec,
id|urb-&gt;transfer_flags
op_or_assign
id|EHCI_STATE_UNLINK
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
singleline_comment|// bulk qh holds the data toggle
DECL|function|ehci_free_config
r_static
r_void
id|ehci_free_config
(paren
r_struct
id|usb_hcd
op_star
id|hcd
comma
r_struct
id|usb_device
op_star
id|udev
)paren
(brace
r_struct
id|hcd_dev
op_star
id|dev
op_assign
(paren
r_struct
id|hcd_dev
op_star
)paren
id|udev-&gt;hcpriv
suffix:semicolon
r_struct
id|ehci_hcd
op_star
id|ehci
op_assign
id|hcd_to_ehci
(paren
id|hcd
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* ASSERT:  nobody can be submitting urbs for this any more */
id|dbg
(paren
l_string|&quot;%s: free_config devnum %d&quot;
comma
id|hcd-&gt;bus_name
comma
id|udev-&gt;devnum
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;ep
(braket
id|i
)braket
)paren
(brace
r_struct
id|ehci_qh
op_star
id|qh
suffix:semicolon
singleline_comment|// FIXME:  this might be an itd/sitd too ...
singleline_comment|// or an interrupt urb (not on async list)
singleline_comment|// can use &quot;union ehci_shadow&quot;
id|qh
op_assign
(paren
r_struct
id|ehci_qh
op_star
)paren
id|dev-&gt;ep
(braket
id|i
)braket
suffix:semicolon
id|vdbg
(paren
l_string|&quot;free_config, ep 0x%02x qh %p&quot;
comma
id|i
comma
id|qh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|qh-&gt;qtd_list
)paren
)paren
(brace
id|dbg
(paren
l_string|&quot;ep 0x%02x qh %p not empty!&quot;
comma
id|i
comma
id|qh
)paren
suffix:semicolon
id|BUG
(paren
)paren
suffix:semicolon
)brace
id|dev-&gt;ep
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* wait_ms() won&squot;t spin here -- we&squot;re a thread */
r_while
c_loop
(paren
id|qh-&gt;qh_state
op_eq
id|QH_STATE_LINKED
op_logical_and
id|ehci-&gt;reclaim
op_logical_and
id|ehci-&gt;hcd.state
op_ne
id|USB_STATE_HALT
)paren
(brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|wait_ms
(paren
l_int|1
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|qh-&gt;qh_state
op_eq
id|QH_STATE_LINKED
)paren
(brace
id|start_unlink_async
(paren
id|ehci
comma
id|qh
)paren
suffix:semicolon
r_while
c_loop
(paren
id|qh-&gt;qh_state
op_ne
id|QH_STATE_IDLE
)paren
(brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|wait_ms
(paren
l_int|1
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
id|qh_unput
(paren
id|ehci
comma
id|qh
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|variable|hcd_name
r_static
r_const
r_char
id|hcd_name
(braket
)braket
op_assign
l_string|&quot;ehci-hcd&quot;
suffix:semicolon
DECL|variable|ehci_driver
r_static
r_const
r_struct
id|hc_driver
id|ehci_driver
op_assign
(brace
id|description
suffix:colon
id|hcd_name
comma
multiline_comment|/*&n;&t; * generic hardware linkage&n;&t; */
id|irq
suffix:colon
id|ehci_irq
comma
id|flags
suffix:colon
id|HCD_MEMORY
op_or
id|HCD_USB2
comma
multiline_comment|/*&n;&t; * basic lifecycle operations&n;&t; */
id|start
suffix:colon
id|ehci_start
comma
macro_line|#ifdef&t;CONFIG_PM
id|suspend
suffix:colon
id|ehci_suspend
comma
id|resume
suffix:colon
id|ehci_resume
comma
macro_line|#endif
id|stop
suffix:colon
id|ehci_stop
comma
multiline_comment|/*&n;&t; * memory lifecycle (except per-request)&n;&t; */
id|hcd_alloc
suffix:colon
id|ehci_hcd_alloc
comma
id|hcd_free
suffix:colon
id|ehci_hcd_free
comma
multiline_comment|/*&n;&t; * managing i/o requests and associated device resources&n;&t; */
id|urb_enqueue
suffix:colon
id|ehci_urb_enqueue
comma
id|urb_dequeue
suffix:colon
id|ehci_urb_dequeue
comma
id|free_config
suffix:colon
id|ehci_free_config
comma
multiline_comment|/*&n;&t; * scheduling support&n;&t; */
id|get_frame_number
suffix:colon
id|ehci_get_frame
comma
multiline_comment|/*&n;&t; * root hub support&n;&t; */
id|hub_status_data
suffix:colon
id|ehci_hub_status_data
comma
id|hub_control
suffix:colon
id|ehci_hub_control
comma
)brace
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* EHCI spec says PCI is required. */
multiline_comment|/* PCI driver selection metadata; PCI hotplugging uses this */
DECL|variable|pci_ids
r_static
r_const
r_struct
id|pci_device_id
id|__devinitdata
id|pci_ids
(braket
)braket
op_assign
(brace
(brace
multiline_comment|/* handle any USB 2.0 EHCI controller */
r_class
suffix:colon
(paren
(paren
id|PCI_CLASS_SERIAL_USB
op_lshift
l_int|8
)paren
op_or
l_int|0x20
)paren
comma
id|class_mask
suffix:colon
op_complement
l_int|0
comma
id|driver_data
suffix:colon
(paren
r_int
r_int
)paren
op_amp
id|ehci_driver
comma
multiline_comment|/* no matter who makes it */
id|vendor
suffix:colon
id|PCI_ANY_ID
comma
id|device
suffix:colon
id|PCI_ANY_ID
comma
id|subvendor
suffix:colon
id|PCI_ANY_ID
comma
id|subdevice
suffix:colon
id|PCI_ANY_ID
comma
)brace
comma
(brace
multiline_comment|/* end: all zeroes */
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
(paren
id|pci
comma
id|pci_ids
)paren
suffix:semicolon
multiline_comment|/* pci driver glue; this is a &quot;new style&quot; PCI driver module */
DECL|variable|ehci_pci_driver
r_static
r_struct
id|pci_driver
id|ehci_pci_driver
op_assign
(brace
id|name
suffix:colon
(paren
r_char
op_star
)paren
id|hcd_name
comma
id|id_table
suffix:colon
id|pci_ids
comma
id|probe
suffix:colon
id|usb_hcd_pci_probe
comma
id|remove
suffix:colon
id|usb_hcd_pci_remove
comma
macro_line|#ifdef&t;CONFIG_PM
id|suspend
suffix:colon
id|usb_hcd_pci_suspend
comma
id|resume
suffix:colon
id|usb_hcd_pci_resume
comma
macro_line|#endif
)brace
suffix:semicolon
DECL|macro|DRIVER_INFO
mdefine_line|#define DRIVER_INFO DRIVER_VERSION &quot; &quot; DRIVER_DESC
id|EXPORT_NO_SYMBOLS
suffix:semicolon
DECL|variable|DRIVER_INFO
id|MODULE_DESCRIPTION
(paren
id|DRIVER_INFO
)paren
suffix:semicolon
DECL|variable|DRIVER_AUTHOR
id|MODULE_AUTHOR
(paren
id|DRIVER_AUTHOR
)paren
suffix:semicolon
id|MODULE_LICENSE
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|function|init
r_static
r_int
id|__init
id|init
(paren
r_void
)paren
(brace
id|dbg
(paren
id|DRIVER_INFO
)paren
suffix:semicolon
id|dbg
(paren
l_string|&quot;block sizes: qh %Zd qtd %Zd itd %Zd sitd %Zd&quot;
comma
r_sizeof
(paren
r_struct
id|ehci_qh
)paren
comma
r_sizeof
(paren
r_struct
id|ehci_qtd
)paren
comma
r_sizeof
(paren
r_struct
id|ehci_itd
)paren
comma
r_sizeof
(paren
r_struct
id|ehci_sitd
)paren
)paren
suffix:semicolon
r_return
id|pci_module_init
(paren
op_amp
id|ehci_pci_driver
)paren
suffix:semicolon
)brace
DECL|variable|init
id|module_init
(paren
id|init
)paren
suffix:semicolon
DECL|function|cleanup
r_static
r_void
id|__exit
id|cleanup
(paren
r_void
)paren
(brace
id|pci_unregister_driver
(paren
op_amp
id|ehci_pci_driver
)paren
suffix:semicolon
)brace
DECL|variable|cleanup
id|module_exit
(paren
id|cleanup
)paren
suffix:semicolon
eof
