multiline_comment|/*&n; * Copyright (c) 2001 by David Brownell&n; * &n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2 of the License, or (at your&n; * option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY&n; * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License&n; * for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software Foundation,&n; * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
multiline_comment|/* this file is part of ehci-hcd.c */
macro_line|#include &lt;asm/byteorder.h&gt;
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * EHCI hardware queue manipulation&n; *&n; * Control, bulk, and interrupt traffic all use &quot;qh&quot; lists.  They list &quot;qtd&quot;&n; * entries describing USB transactions, max 16-20kB/entry (with 4kB-aligned&n; * buffers needed for the larger number).  We use one QH per endpoint, queue&n; * multiple (bulk or control) urbs per endpoint.  URBs may need several qtds.&n; * A scheduled interrupt qh always has one qtd, one urb.&n; *&n; * ISO traffic uses &quot;ISO TD&quot; (itd, and sitd) records, and (along with&n; * interrupts) needs careful scheduling.  Performance improvements can be&n; * an ongoing challenge.&n; * &n; * USB 1.1 devices are handled (a) by &quot;companion&quot; OHCI or UHCI root hubs,&n; * or otherwise through transaction translators (TTs) in USB 2.0 hubs using&n; * (b) special fields in qh entries or (c) split iso entries.  TTs will&n; * buffer low/full speed data so the host collects it at high speed.&n; */
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* fill a qtd, returning how much of the buffer we were able to queue up */
r_static
r_int
DECL|function|qtd_fill
id|qtd_fill
(paren
r_struct
id|ehci_qtd
op_star
id|qtd
comma
id|dma_addr_t
id|buf
comma
r_int
id|len
comma
r_int
id|token
)paren
(brace
r_int
id|i
comma
id|count
suffix:semicolon
multiline_comment|/* one buffer entry per 4K ... first might be short or unaligned */
id|qtd-&gt;hw_buf
(braket
l_int|0
)braket
op_assign
id|cpu_to_le32
(paren
id|buf
)paren
suffix:semicolon
id|count
op_assign
l_int|0x1000
op_minus
(paren
id|buf
op_amp
l_int|0x0fff
)paren
suffix:semicolon
multiline_comment|/* rest of that page */
r_if
c_cond
(paren
id|likely
(paren
id|len
OL
id|count
)paren
)paren
multiline_comment|/* ... iff needed */
id|count
op_assign
id|len
suffix:semicolon
r_else
(brace
id|buf
op_add_assign
l_int|0x1000
suffix:semicolon
id|buf
op_and_assign
op_complement
l_int|0x0fff
suffix:semicolon
multiline_comment|/* per-qtd limit: from 16K to 20K (best alignment) */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|count
OL
id|len
op_logical_and
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
(brace
id|u64
id|addr
op_assign
id|buf
suffix:semicolon
id|qtd-&gt;hw_buf
(braket
id|i
)braket
op_assign
id|cpu_to_le32
(paren
(paren
id|u32
)paren
id|addr
)paren
suffix:semicolon
id|qtd-&gt;hw_buf_hi
(braket
id|i
)braket
op_assign
id|cpu_to_le32
(paren
(paren
id|u32
)paren
(paren
id|addr
op_rshift
l_int|32
)paren
)paren
suffix:semicolon
id|buf
op_add_assign
l_int|0x1000
suffix:semicolon
r_if
c_cond
(paren
(paren
id|count
op_plus
l_int|0x1000
)paren
OL
id|len
)paren
id|count
op_add_assign
l_int|0x1000
suffix:semicolon
r_else
id|count
op_assign
id|len
suffix:semicolon
)brace
)brace
id|qtd-&gt;hw_token
op_assign
id|cpu_to_le32
(paren
(paren
id|count
op_lshift
l_int|16
)paren
op_or
id|token
)paren
suffix:semicolon
id|qtd-&gt;length
op_assign
id|count
suffix:semicolon
macro_line|#if 0
id|vdbg
(paren
l_string|&quot;  qtd_fill %p, token %8x bytes %d dma %x&quot;
comma
id|qtd
comma
id|le32_to_cpu
(paren
id|qtd-&gt;hw_token
)paren
comma
id|count
comma
id|qtd-&gt;hw_buf
(braket
l_int|0
)braket
)paren
suffix:semicolon
macro_line|#endif
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* update halted (but potentially linked) qh */
DECL|function|qh_update
r_static
r_inline
r_void
id|qh_update
(paren
r_struct
id|ehci_qh
op_star
id|qh
comma
r_struct
id|ehci_qtd
op_star
id|qtd
)paren
(brace
id|qh-&gt;hw_current
op_assign
l_int|0
suffix:semicolon
id|qh-&gt;hw_qtd_next
op_assign
id|QTD_NEXT
(paren
id|qtd-&gt;qtd_dma
)paren
suffix:semicolon
id|qh-&gt;hw_alt_next
op_assign
id|EHCI_LIST_END
suffix:semicolon
multiline_comment|/* HC must see latest qtd and qh data before we clear ACTIVE+HALT */
id|qh-&gt;hw_token
op_and_assign
id|__constant_cpu_to_le32
(paren
id|QTD_TOGGLE
op_or
id|QTD_STS_PING
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|qtd_copy_status
r_static
r_inline
r_void
id|qtd_copy_status
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|length
comma
id|u32
id|token
)paren
(brace
multiline_comment|/* count IN/OUT bytes, not SETUP (even short packets) */
r_if
c_cond
(paren
id|likely
(paren
id|QTD_PID
(paren
id|token
)paren
op_ne
l_int|2
)paren
)paren
id|urb-&gt;actual_length
op_add_assign
id|length
op_minus
id|QTD_LENGTH
(paren
id|token
)paren
suffix:semicolon
multiline_comment|/* don&squot;t modify error codes */
r_if
c_cond
(paren
id|unlikely
(paren
id|urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
op_logical_and
(paren
id|token
op_amp
id|QTD_STS_HALT
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|token
op_amp
id|QTD_STS_BABBLE
)paren
(brace
id|urb-&gt;status
op_assign
op_minus
id|EOVERFLOW
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|QTD_CERR
(paren
id|token
)paren
)paren
(brace
r_if
c_cond
(paren
id|token
op_amp
id|QTD_STS_DBE
)paren
id|urb-&gt;status
op_assign
(paren
id|QTD_PID
(paren
id|token
)paren
op_eq
l_int|1
)paren
multiline_comment|/* IN ? */
ques
c_cond
op_minus
id|ENOSR
multiline_comment|/* hc couldn&squot;t read data */
suffix:colon
op_minus
id|ECOMM
suffix:semicolon
multiline_comment|/* hc couldn&squot;t write data */
r_else
r_if
c_cond
(paren
id|token
op_amp
id|QTD_STS_MMF
)paren
multiline_comment|/* missed tt uframe */
id|urb-&gt;status
op_assign
op_minus
id|EPROTO
suffix:semicolon
r_else
r_if
c_cond
(paren
id|token
op_amp
id|QTD_STS_XACT
)paren
(brace
r_if
c_cond
(paren
id|QTD_LENGTH
(paren
id|token
)paren
)paren
id|urb-&gt;status
op_assign
op_minus
id|EPIPE
suffix:semicolon
r_else
(brace
id|dbg
(paren
l_string|&quot;3strikes&quot;
)paren
suffix:semicolon
id|urb-&gt;status
op_assign
op_minus
id|EPROTO
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* presumably a stall */
id|urb-&gt;status
op_assign
op_minus
id|EPIPE
suffix:semicolon
multiline_comment|/* CERR nonzero + data left + halt --&gt; stall */
)brace
r_else
r_if
c_cond
(paren
id|QTD_LENGTH
(paren
id|token
)paren
)paren
id|urb-&gt;status
op_assign
op_minus
id|EPIPE
suffix:semicolon
r_else
multiline_comment|/* unknown */
id|urb-&gt;status
op_assign
op_minus
id|EPROTO
suffix:semicolon
id|dbg
(paren
l_string|&quot;ep %d-%s qtd token %08x --&gt; status %d&quot;
comma
multiline_comment|/* devpath */
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
comma
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
ques
c_cond
l_string|&quot;in&quot;
suffix:colon
l_string|&quot;out&quot;
comma
id|token
comma
id|urb-&gt;status
)paren
suffix:semicolon
multiline_comment|/* stall indicates some recovery action is needed */
r_if
c_cond
(paren
id|urb-&gt;status
op_eq
op_minus
id|EPIPE
)paren
(brace
r_int
id|pipe
op_assign
id|urb-&gt;pipe
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|usb_pipecontrol
(paren
id|pipe
)paren
)paren
id|usb_endpoint_halt
(paren
id|urb-&gt;dev
comma
id|usb_pipeendpoint
(paren
id|pipe
)paren
comma
id|usb_pipeout
(paren
id|pipe
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;dev-&gt;tt
op_logical_and
op_logical_neg
id|usb_pipeint
(paren
id|pipe
)paren
)paren
(brace
id|err
(paren
l_string|&quot;must CLEAR_TT_BUFFER, hub port %d%s addr %d ep %d&quot;
comma
id|urb-&gt;dev-&gt;ttport
comma
multiline_comment|/* devpath */
id|urb-&gt;dev-&gt;tt-&gt;multi
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot; (all-ports TT)&quot;
comma
id|urb-&gt;dev-&gt;devnum
comma
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
singleline_comment|// FIXME something (khubd?) should make the hub
singleline_comment|// CLEAR_TT_BUFFER ASAP, it&squot;s blocking other
singleline_comment|// fs/ls requests... hub_tt_clear_buffer() ?
)brace
)brace
)brace
)brace
DECL|function|ehci_urb_complete
r_static
r_void
id|ehci_urb_complete
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
id|dma_addr_t
id|addr
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_if
c_cond
(paren
id|urb-&gt;transfer_buffer_length
op_logical_and
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
)paren
id|pci_dma_sync_single
(paren
id|ehci-&gt;hcd.pdev
comma
id|addr
comma
id|urb-&gt;transfer_buffer_length
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
multiline_comment|/* cleanse status if we saw no error */
r_if
c_cond
(paren
id|likely
(paren
id|urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
)paren
(brace
r_if
c_cond
(paren
id|urb-&gt;actual_length
op_ne
id|urb-&gt;transfer_buffer_length
op_logical_and
(paren
id|urb-&gt;transfer_flags
op_amp
id|USB_DISABLE_SPD
)paren
)paren
id|urb-&gt;status
op_assign
op_minus
id|EREMOTEIO
suffix:semicolon
r_else
id|urb-&gt;status
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* only report unlinks once */
r_if
c_cond
(paren
id|likely
(paren
id|urb-&gt;status
op_ne
op_minus
id|ENOENT
op_logical_and
id|urb-&gt;status
op_ne
op_minus
id|ENOTCONN
)paren
)paren
id|urb-&gt;complete
(paren
id|urb
)paren
suffix:semicolon
)brace
multiline_comment|/* urb-&gt;lock ignored from here on (hcd is done with urb) */
DECL|function|ehci_urb_done
r_static
r_void
id|ehci_urb_done
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
id|dma_addr_t
id|addr
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_if
c_cond
(paren
id|urb-&gt;transfer_buffer_length
)paren
id|pci_unmap_single
(paren
id|ehci-&gt;hcd.pdev
comma
id|addr
comma
id|urb-&gt;transfer_buffer_length
comma
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
ques
c_cond
id|PCI_DMA_FROMDEVICE
suffix:colon
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
(paren
id|urb-&gt;hcpriv
op_ne
l_int|0
)paren
)paren
(brace
id|qh_unput
(paren
id|ehci
comma
(paren
r_struct
id|ehci_qh
op_star
)paren
id|urb-&gt;hcpriv
)paren
suffix:semicolon
id|urb-&gt;hcpriv
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|likely
(paren
id|urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
)paren
(brace
r_if
c_cond
(paren
id|urb-&gt;actual_length
op_ne
id|urb-&gt;transfer_buffer_length
op_logical_and
(paren
id|urb-&gt;transfer_flags
op_amp
id|USB_DISABLE_SPD
)paren
)paren
id|urb-&gt;status
op_assign
op_minus
id|EREMOTEIO
suffix:semicolon
r_else
id|urb-&gt;status
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* hand off urb ownership */
id|usb_hcd_giveback_urb
(paren
op_amp
id|ehci-&gt;hcd
comma
id|urb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Process completed qtds for a qh, issuing completions if needed.&n; * When freeing:  frees qtds, unmaps buf, returns URB to driver.&n; * When not freeing (queued periodic qh):  retain qtds, mapping, and urb.&n; * Races up to qh-&gt;hw_current; returns number of urb completions.&n; */
r_static
r_int
DECL|function|qh_completions
id|qh_completions
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|list_head
op_star
id|qtd_list
comma
r_int
id|freeing
)paren
(brace
r_struct
id|ehci_qtd
op_star
id|qtd
comma
op_star
id|last
suffix:semicolon
r_struct
id|list_head
op_star
id|next
suffix:semicolon
r_struct
id|ehci_qh
op_star
id|qh
op_assign
l_int|0
suffix:semicolon
r_int
id|unlink
op_assign
l_int|0
comma
id|halted
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
id|list_empty
(paren
id|qtd_list
)paren
)paren
)paren
(brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* scan QTDs till end of list, or we reach an active one */
r_for
c_loop
(paren
id|qtd
op_assign
id|list_entry
(paren
id|qtd_list-&gt;next
comma
r_struct
id|ehci_qtd
comma
id|qtd_list
)paren
comma
id|last
op_assign
l_int|0
comma
id|next
op_assign
l_int|0
suffix:semicolon
id|next
op_ne
id|qtd_list
suffix:semicolon
id|last
op_assign
id|qtd
comma
id|qtd
op_assign
id|list_entry
(paren
id|next
comma
r_struct
id|ehci_qtd
comma
id|qtd_list
)paren
)paren
(brace
r_struct
id|urb
op_star
id|urb
op_assign
id|qtd-&gt;urb
suffix:semicolon
id|u32
id|token
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* qh is non-null iff these qtds were queued to the HC */
id|qh
op_assign
(paren
r_struct
id|ehci_qh
op_star
)paren
id|urb-&gt;hcpriv
suffix:semicolon
multiline_comment|/* clean up any state from previous QTD ...*/
r_if
c_cond
(paren
id|last
)paren
(brace
r_if
c_cond
(paren
id|likely
(paren
id|last-&gt;urb
op_ne
id|urb
)paren
)paren
(brace
multiline_comment|/* complete() can reenter this HCD */
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
(paren
id|freeing
op_ne
l_int|0
)paren
)paren
id|ehci_urb_done
(paren
id|ehci
comma
id|last-&gt;buf_dma
comma
id|last-&gt;urb
)paren
suffix:semicolon
r_else
id|ehci_urb_complete
(paren
id|ehci
comma
id|last-&gt;buf_dma
comma
id|last-&gt;urb
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|retval
op_increment
suffix:semicolon
)brace
multiline_comment|/* qh overlays can have HC&squot;s old cached copies of&n;&t;&t;&t; * next qtd ptrs, if an URB was queued afterwards.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|qh
op_logical_and
id|cpu_to_le32
(paren
id|last-&gt;qtd_dma
)paren
op_eq
id|qh-&gt;hw_current
op_logical_and
id|last-&gt;hw_next
op_ne
id|qh-&gt;hw_qtd_next
)paren
(brace
id|qh-&gt;hw_alt_next
op_assign
id|last-&gt;hw_alt_next
suffix:semicolon
id|qh-&gt;hw_qtd_next
op_assign
id|last-&gt;hw_next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|likely
(paren
id|freeing
op_ne
l_int|0
)paren
)paren
id|ehci_qtd_free
(paren
id|ehci
comma
id|last
)paren
suffix:semicolon
id|last
op_assign
l_int|0
suffix:semicolon
)brace
id|next
op_assign
id|qtd-&gt;qtd_list.next
suffix:semicolon
multiline_comment|/* if these qtds were queued to the HC, some may be active.&n;&t;&t; * else we&squot;re cleaning up after a failed URB submission.&n;&t;&t; */
r_if
c_cond
(paren
id|likely
(paren
id|qh
op_ne
l_int|0
)paren
)paren
(brace
r_int
id|qh_halted
suffix:semicolon
id|qh_halted
op_assign
id|__constant_cpu_to_le32
(paren
id|QTD_STS_HALT
)paren
op_amp
id|qh-&gt;hw_token
suffix:semicolon
id|token
op_assign
id|le32_to_cpu
(paren
id|qtd-&gt;hw_token
)paren
suffix:semicolon
id|halted
op_assign
id|halted
op_logical_or
id|qh_halted
op_logical_or
(paren
id|ehci-&gt;hcd.state
op_eq
id|USB_STATE_HALT
)paren
op_logical_or
(paren
id|qh-&gt;qh_state
op_eq
id|QH_STATE_IDLE
)paren
suffix:semicolon
multiline_comment|/* QH halts only because of fault or unlink; in both&n;&t;&t;&t; * cases, queued URBs get unlinked.  But for unlink,&n;&t;&t;&t; * URBs at the head of the queue can stay linked.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|unlikely
(paren
id|halted
op_ne
l_int|0
)paren
)paren
(brace
multiline_comment|/* unlink everything because of HC shutdown? */
r_if
c_cond
(paren
id|ehci-&gt;hcd.state
op_eq
id|USB_STATE_HALT
)paren
(brace
id|freeing
op_assign
id|unlink
op_assign
l_int|1
suffix:semicolon
id|urb-&gt;status
op_assign
op_minus
id|ESHUTDOWN
suffix:semicolon
multiline_comment|/* explicit unlink, starting here? */
)brace
r_else
r_if
c_cond
(paren
id|qh-&gt;qh_state
op_eq
id|QH_STATE_IDLE
op_logical_and
(paren
id|urb-&gt;status
op_eq
op_minus
id|ECONNRESET
op_logical_or
id|urb-&gt;status
op_eq
op_minus
id|ENOENT
)paren
)paren
(brace
id|freeing
op_assign
id|unlink
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* unlink everything because of error? */
)brace
r_else
r_if
c_cond
(paren
id|qh_halted
op_logical_and
op_logical_neg
(paren
id|token
op_amp
id|QTD_STS_HALT
)paren
)paren
(brace
id|freeing
op_assign
id|unlink
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
id|urb-&gt;status
op_assign
op_minus
id|ECONNRESET
suffix:semicolon
multiline_comment|/* unlink the rest? */
)brace
r_else
r_if
c_cond
(paren
id|unlink
)paren
(brace
id|urb-&gt;status
op_assign
op_minus
id|ECONNRESET
suffix:semicolon
multiline_comment|/* QH halted to unlink urbs after this?  */
)brace
r_else
r_if
c_cond
(paren
(paren
id|token
op_amp
id|QTD_STS_ACTIVE
)paren
op_ne
l_int|0
)paren
(brace
id|qtd
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Else QH is active, so we must not modify QTDs&n;&t;&t;&t; * that HC may be working on.  Break from loop.&n;&t;&t;&t; */
)brace
r_else
r_if
c_cond
(paren
id|unlikely
(paren
(paren
id|token
op_amp
id|QTD_STS_ACTIVE
)paren
op_ne
l_int|0
)paren
)paren
(brace
id|next
op_assign
id|qtd_list
suffix:semicolon
id|qtd
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|spin_lock
(paren
op_amp
id|urb-&gt;lock
)paren
suffix:semicolon
id|qtd_copy_status
(paren
id|urb
comma
id|qtd-&gt;length
comma
id|token
)paren
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|urb-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * NOTE:  this won&squot;t work right with interrupt urbs that&n;&t;&t; * need multiple qtds ... only the first scan of qh-&gt;qtd_list&n;&t;&t; * starts at the right qtd, yet multiple scans could happen&n;&t;&t; * for transfers that are scheduled across multiple uframes. &n;&t;&t; * (Such schedules are not currently allowed!)&n;&t;&t; */
r_if
c_cond
(paren
id|likely
(paren
id|freeing
op_ne
l_int|0
)paren
)paren
id|list_del
(paren
op_amp
id|qtd-&gt;qtd_list
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/* restore everything the HC could change&n;&t;&t;&t; * from an interrupt QTD&n;&t;&t;&t; */
id|qtd-&gt;hw_token
op_assign
(paren
id|qtd-&gt;hw_token
op_amp
op_complement
id|__constant_cpu_to_le32
(paren
l_int|0x8300
)paren
)paren
op_or
id|cpu_to_le32
(paren
id|qtd-&gt;length
op_lshift
l_int|16
)paren
op_or
id|__constant_cpu_to_le32
(paren
id|QTD_IOC
op_or
(paren
id|EHCI_TUNE_CERR
op_lshift
l_int|10
)paren
op_or
id|QTD_STS_ACTIVE
)paren
suffix:semicolon
id|qtd-&gt;hw_buf
(braket
l_int|0
)braket
op_and_assign
op_complement
id|__constant_cpu_to_le32
(paren
l_int|0x0fff
)paren
suffix:semicolon
multiline_comment|/* this offset, and the length above,&n;&t;&t;&t; * are likely wrong on QTDs #2..N&n;&t;&t;&t; */
id|qtd-&gt;hw_buf
(braket
l_int|0
)braket
op_or_assign
id|cpu_to_le32
(paren
l_int|0x0fff
op_amp
id|qtd-&gt;buf_dma
)paren
suffix:semicolon
)brace
macro_line|#if 0
r_if
c_cond
(paren
id|urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
id|vdbg
(paren
l_string|&quot;  qtd %p ok, urb %p, token %8x, len %d&quot;
comma
id|qtd
comma
id|urb
comma
id|token
comma
id|urb-&gt;actual_length
)paren
suffix:semicolon
r_else
id|vdbg
(paren
l_string|&quot;urb %p status %d, qtd %p, token %8x, len %d&quot;
comma
id|urb
comma
id|urb-&gt;status
comma
id|qtd
comma
id|token
comma
id|urb-&gt;actual_length
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* SETUP for control urb? */
r_if
c_cond
(paren
id|unlikely
(paren
id|QTD_PID
(paren
id|token
)paren
op_eq
l_int|2
)paren
)paren
id|pci_unmap_single
(paren
id|ehci-&gt;hcd.pdev
comma
id|qtd-&gt;buf_dma
comma
r_sizeof
(paren
r_struct
id|usb_ctrlrequest
)paren
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
)brace
multiline_comment|/* patch up list head? */
r_if
c_cond
(paren
id|unlikely
(paren
id|halted
op_logical_and
id|qh
op_logical_and
op_logical_neg
id|list_empty
(paren
id|qtd_list
)paren
)paren
)paren
(brace
id|qh_update
(paren
id|qh
comma
id|list_entry
(paren
id|qtd_list-&gt;next
comma
r_struct
id|ehci_qtd
comma
id|qtd_list
)paren
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* last urb&squot;s completion might still need calling */
r_if
c_cond
(paren
id|likely
(paren
id|last
op_ne
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|likely
(paren
id|freeing
op_ne
l_int|0
)paren
)paren
(brace
id|ehci_urb_done
(paren
id|ehci
comma
id|last-&gt;buf_dma
comma
id|last-&gt;urb
)paren
suffix:semicolon
id|ehci_qtd_free
(paren
id|ehci
comma
id|last
)paren
suffix:semicolon
)brace
r_else
id|ehci_urb_complete
(paren
id|ehci
comma
id|last-&gt;buf_dma
comma
id|last-&gt;urb
)paren
suffix:semicolon
id|retval
op_increment
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * create a list of filled qtds for this URB; won&squot;t link into qh.&n; */
r_static
r_struct
id|list_head
op_star
DECL|function|qh_urb_transaction
id|qh_urb_transaction
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|list_head
op_star
id|head
comma
r_int
id|flags
)paren
(brace
r_struct
id|ehci_qtd
op_star
id|qtd
comma
op_star
id|qtd_prev
suffix:semicolon
id|dma_addr_t
id|buf
comma
id|map_buf
suffix:semicolon
r_int
id|len
comma
id|maxpacket
suffix:semicolon
id|u32
id|token
suffix:semicolon
multiline_comment|/*&n;&t; * URBs map to sequences of QTDs:  one logical transaction&n;&t; */
id|qtd
op_assign
id|ehci_qtd_alloc
(paren
id|ehci
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|qtd
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|qtd_prev
op_assign
l_int|0
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|qtd-&gt;qtd_list
comma
id|head
)paren
suffix:semicolon
id|qtd-&gt;urb
op_assign
id|urb
suffix:semicolon
id|token
op_assign
id|QTD_STS_ACTIVE
suffix:semicolon
id|token
op_or_assign
(paren
id|EHCI_TUNE_CERR
op_lshift
l_int|10
)paren
suffix:semicolon
multiline_comment|/* for split transactions, SplitXState initialized to zero */
r_if
c_cond
(paren
id|usb_pipecontrol
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
multiline_comment|/* control request data is passed in the &quot;setup&quot; pid */
multiline_comment|/* NOTE:  this isn&squot;t smart about 64bit DMA, since it uses the&n;&t;&t; * default (32bit) mask rather than using the whole address&n;&t;&t; * space.  we could set pdev-&gt;dma_mask to all-ones while&n;&t;&t; * getting this mapping, locking it and restoring before&n;&t;&t; * allocating qtd/qh/... or maybe only do that for the main&n;&t;&t; * data phase (below).&n;&t;&t; */
id|qtd-&gt;buf_dma
op_assign
id|pci_map_single
(paren
id|ehci-&gt;hcd.pdev
comma
id|urb-&gt;setup_packet
comma
r_sizeof
(paren
r_struct
id|usb_ctrlrequest
)paren
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|qtd-&gt;buf_dma
)paren
)paren
r_goto
id|cleanup
suffix:semicolon
multiline_comment|/* SETUP pid */
id|qtd_fill
(paren
id|qtd
comma
id|qtd-&gt;buf_dma
comma
r_sizeof
(paren
r_struct
id|usb_ctrlrequest
)paren
comma
id|token
op_or
(paren
l_int|2
multiline_comment|/* &quot;setup&quot; */
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
multiline_comment|/* ... and always at least one more pid */
id|token
op_xor_assign
id|QTD_TOGGLE
suffix:semicolon
id|qtd_prev
op_assign
id|qtd
suffix:semicolon
id|qtd
op_assign
id|ehci_qtd_alloc
(paren
id|ehci
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|qtd
)paren
)paren
r_goto
id|cleanup
suffix:semicolon
id|qtd-&gt;urb
op_assign
id|urb
suffix:semicolon
id|qtd_prev-&gt;hw_next
op_assign
id|QTD_NEXT
(paren
id|qtd-&gt;qtd_dma
)paren
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|qtd-&gt;qtd_list
comma
id|head
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * data transfer stage:  buffer setup&n;&t; */
id|len
op_assign
id|urb-&gt;transfer_buffer_length
suffix:semicolon
r_if
c_cond
(paren
id|likely
(paren
id|len
OG
l_int|0
)paren
)paren
(brace
multiline_comment|/* NOTE:  sub-optimal mapping with 64bit DMA (see above) */
id|buf
op_assign
id|map_buf
op_assign
id|pci_map_single
(paren
id|ehci-&gt;hcd.pdev
comma
id|urb-&gt;transfer_buffer
comma
id|len
comma
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
ques
c_cond
id|PCI_DMA_FROMDEVICE
suffix:colon
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|buf
)paren
)paren
r_goto
id|cleanup
suffix:semicolon
)brace
r_else
id|buf
op_assign
id|map_buf
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
op_logical_or
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
)paren
id|token
op_or_assign
(paren
l_int|1
multiline_comment|/* &quot;in&quot; */
op_lshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/* else it&squot;s already initted to &quot;out&quot; pid (0 &lt;&lt; 8) */
id|maxpacket
op_assign
id|usb_maxpacket
(paren
id|urb-&gt;dev
comma
id|urb-&gt;pipe
comma
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * buffer gets wrapped in one or more qtds;&n;&t; * last one may be &quot;short&quot; (including zero len)&n;&t; * and may serve as a control status ack&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|this_qtd_len
suffix:semicolon
id|qtd-&gt;urb
op_assign
id|urb
suffix:semicolon
id|qtd-&gt;buf_dma
op_assign
id|map_buf
suffix:semicolon
id|this_qtd_len
op_assign
id|qtd_fill
(paren
id|qtd
comma
id|buf
comma
id|len
comma
id|token
)paren
suffix:semicolon
id|len
op_sub_assign
id|this_qtd_len
suffix:semicolon
id|buf
op_add_assign
id|this_qtd_len
suffix:semicolon
multiline_comment|/* qh makes control packets use qtd toggle; maybe switch it */
r_if
c_cond
(paren
(paren
id|maxpacket
op_amp
(paren
id|this_qtd_len
op_plus
(paren
id|maxpacket
op_minus
l_int|1
)paren
)paren
)paren
op_eq
l_int|0
)paren
id|token
op_xor_assign
id|QTD_TOGGLE
suffix:semicolon
r_if
c_cond
(paren
id|likely
(paren
id|len
op_le
l_int|0
)paren
)paren
r_break
suffix:semicolon
id|qtd_prev
op_assign
id|qtd
suffix:semicolon
id|qtd
op_assign
id|ehci_qtd_alloc
(paren
id|ehci
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|qtd
)paren
)paren
r_goto
id|cleanup
suffix:semicolon
id|qtd-&gt;urb
op_assign
id|urb
suffix:semicolon
id|qtd_prev-&gt;hw_next
op_assign
id|QTD_NEXT
(paren
id|qtd-&gt;qtd_dma
)paren
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|qtd-&gt;qtd_list
comma
id|head
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * control requests may need a terminating data &quot;status&quot; ack;&n;&t; * bulk ones may need a terminating short packet (zero length).&n;&t; */
r_if
c_cond
(paren
id|likely
(paren
id|buf
op_ne
l_int|0
)paren
)paren
(brace
r_int
id|one_more
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipecontrol
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
id|one_more
op_assign
l_int|1
suffix:semicolon
id|token
op_xor_assign
l_int|0x0100
suffix:semicolon
multiline_comment|/* &quot;in&quot; &lt;--&gt; &quot;out&quot;  */
id|token
op_or_assign
id|QTD_TOGGLE
suffix:semicolon
multiline_comment|/* force DATA1 */
)brace
r_else
r_if
c_cond
(paren
id|usb_pipebulk
(paren
id|urb-&gt;pipe
)paren
op_logical_and
(paren
id|urb-&gt;transfer_flags
op_amp
id|USB_ZERO_PACKET
)paren
op_logical_and
op_logical_neg
(paren
id|urb-&gt;transfer_buffer_length
op_mod
id|maxpacket
)paren
)paren
(brace
id|one_more
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|one_more
)paren
(brace
id|qtd_prev
op_assign
id|qtd
suffix:semicolon
id|qtd
op_assign
id|ehci_qtd_alloc
(paren
id|ehci
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|qtd
)paren
)paren
r_goto
id|cleanup
suffix:semicolon
id|qtd-&gt;urb
op_assign
id|urb
suffix:semicolon
id|qtd_prev-&gt;hw_next
op_assign
id|QTD_NEXT
(paren
id|qtd-&gt;qtd_dma
)paren
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|qtd-&gt;qtd_list
comma
id|head
)paren
suffix:semicolon
multiline_comment|/* never any data in such packets */
id|qtd_fill
(paren
id|qtd
comma
l_int|0
comma
l_int|0
comma
id|token
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* by default, enable interrupt on urb completion */
r_if
c_cond
(paren
id|likely
(paren
op_logical_neg
(paren
id|urb-&gt;transfer_flags
op_amp
id|URB_NO_INTERRUPT
)paren
)paren
)paren
id|qtd-&gt;hw_token
op_or_assign
id|__constant_cpu_to_le32
(paren
id|QTD_IOC
)paren
suffix:semicolon
r_return
id|head
suffix:semicolon
id|cleanup
suffix:colon
id|urb-&gt;status
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|qh_completions
(paren
id|ehci
comma
id|head
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * Hardware maintains data toggle (like OHCI) ... here we (re)initialize&n; * the hardware data toggle in the QH, and set the pseudo-toggle in udev&n; * so we can see if usb_clear_halt() was called.  NOP for control, since&n; * we set up qh-&gt;hw_info1 to always use the QTD toggle bits. &n; */
r_static
r_inline
r_void
DECL|function|clear_toggle
id|clear_toggle
(paren
r_struct
id|usb_device
op_star
id|udev
comma
r_int
id|ep
comma
r_int
id|is_out
comma
r_struct
id|ehci_qh
op_star
id|qh
)paren
(brace
id|vdbg
(paren
l_string|&quot;clear toggle, dev %d ep 0x%x-%s&quot;
comma
id|udev-&gt;devnum
comma
id|ep
comma
id|is_out
ques
c_cond
l_string|&quot;out&quot;
suffix:colon
l_string|&quot;in&quot;
)paren
suffix:semicolon
id|qh-&gt;hw_token
op_and_assign
op_complement
id|__constant_cpu_to_le32
(paren
id|QTD_TOGGLE
)paren
suffix:semicolon
id|usb_settoggle
(paren
id|udev
comma
id|ep
comma
id|is_out
comma
l_int|1
)paren
suffix:semicolon
)brace
singleline_comment|// Would be best to create all qh&squot;s from config descriptors,
singleline_comment|// when each interface/altsetting is established.  Unlink
singleline_comment|// any previous qh and cancel its urbs first; endpoints are
singleline_comment|// implicitly reset then (data toggle too).
singleline_comment|// That&squot;d mean updating how usbcore talks to HCDs. (2.5?)
multiline_comment|/*&n; * Each QH holds a qtd list; a QH is used for everything except iso.&n; *&n; * For interrupt urbs, the scheduler must set the microframe scheduling&n; * mask(s) each time the QH gets scheduled.  For highspeed, that&squot;s&n; * just one microframe in the s-mask.  For split interrupt transactions&n; * there are additional complications: c-mask, maybe FSTNs.&n; */
r_static
r_struct
id|ehci_qh
op_star
DECL|function|ehci_qh_make
id|ehci_qh_make
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|list_head
op_star
id|qtd_list
comma
r_int
id|flags
)paren
(brace
r_struct
id|ehci_qh
op_star
id|qh
op_assign
id|ehci_qh_alloc
(paren
id|ehci
comma
id|flags
)paren
suffix:semicolon
id|u32
id|info1
op_assign
l_int|0
comma
id|info2
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|qh
)paren
r_return
id|qh
suffix:semicolon
multiline_comment|/*&n;&t; * init endpoint/device data for this QH&n;&t; */
id|info1
op_or_assign
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
op_lshift
l_int|8
suffix:semicolon
id|info1
op_or_assign
id|usb_pipedevice
(paren
id|urb-&gt;pipe
)paren
op_lshift
l_int|0
suffix:semicolon
multiline_comment|/* using TT? */
r_switch
c_cond
(paren
id|urb-&gt;dev-&gt;speed
)paren
(brace
r_case
id|USB_SPEED_LOW
suffix:colon
id|info1
op_or_assign
(paren
l_int|1
op_lshift
l_int|12
)paren
suffix:semicolon
multiline_comment|/* EPS &quot;low&quot; */
multiline_comment|/* FALL THROUGH */
r_case
id|USB_SPEED_FULL
suffix:colon
multiline_comment|/* EPS 0 means &quot;full&quot; */
id|info1
op_or_assign
(paren
id|EHCI_TUNE_RL_TT
op_lshift
l_int|28
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipecontrol
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
id|info1
op_or_assign
(paren
l_int|1
op_lshift
l_int|27
)paren
suffix:semicolon
multiline_comment|/* for TT */
id|info1
op_or_assign
l_int|1
op_lshift
l_int|14
suffix:semicolon
multiline_comment|/* toggle from qtd */
)brace
id|info1
op_or_assign
id|usb_maxpacket
(paren
id|urb-&gt;dev
comma
id|urb-&gt;pipe
comma
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
)paren
op_lshift
l_int|16
suffix:semicolon
id|info2
op_or_assign
(paren
id|EHCI_TUNE_MULT_TT
op_lshift
l_int|30
)paren
suffix:semicolon
id|info2
op_or_assign
id|urb-&gt;dev-&gt;ttport
op_lshift
l_int|23
suffix:semicolon
id|info2
op_or_assign
id|urb-&gt;dev-&gt;tt-&gt;hub-&gt;devnum
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* NOTE:  if (usb_pipeint (urb-&gt;pipe)) { scheduler sets c-mask }&n;&t;&t; * ... and a 0.96 scheduler might use FSTN nodes too&n;&t;&t; */
r_break
suffix:semicolon
r_case
id|USB_SPEED_HIGH
suffix:colon
multiline_comment|/* no TT involved */
id|info1
op_or_assign
(paren
l_int|2
op_lshift
l_int|12
)paren
suffix:semicolon
multiline_comment|/* EPS &quot;high&quot; */
id|info1
op_or_assign
(paren
id|EHCI_TUNE_RL_HS
op_lshift
l_int|28
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipecontrol
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
id|info1
op_or_assign
l_int|64
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* usb2 fixed maxpacket */
id|info1
op_or_assign
l_int|1
op_lshift
l_int|14
suffix:semicolon
multiline_comment|/* toggle from qtd */
)brace
r_else
r_if
c_cond
(paren
id|usb_pipebulk
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
id|info1
op_or_assign
l_int|512
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* usb2 fixed maxpacket */
id|info2
op_or_assign
(paren
id|EHCI_TUNE_MULT_HS
op_lshift
l_int|30
)paren
suffix:semicolon
)brace
r_else
id|info1
op_or_assign
id|usb_maxpacket
(paren
id|urb-&gt;dev
comma
id|urb-&gt;pipe
comma
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
)paren
op_lshift
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
macro_line|#ifdef DEBUG
id|BUG
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* NOTE:  if (usb_pipeint (urb-&gt;pipe)) { scheduler sets s-mask } */
id|qh-&gt;qh_state
op_assign
id|QH_STATE_IDLE
suffix:semicolon
id|qh-&gt;hw_info1
op_assign
id|cpu_to_le32
(paren
id|info1
)paren
suffix:semicolon
id|qh-&gt;hw_info2
op_assign
id|cpu_to_le32
(paren
id|info2
)paren
suffix:semicolon
multiline_comment|/* initialize sw and hw queues with these qtds */
id|list_splice
(paren
id|qtd_list
comma
op_amp
id|qh-&gt;qtd_list
)paren
suffix:semicolon
id|qh_update
(paren
id|qh
comma
id|list_entry
(paren
id|qtd_list-&gt;next
comma
r_struct
id|ehci_qtd
comma
id|qtd_list
)paren
)paren
suffix:semicolon
multiline_comment|/* initialize data toggle state */
r_if
c_cond
(paren
op_logical_neg
id|usb_pipecontrol
(paren
id|urb-&gt;pipe
)paren
)paren
id|clear_toggle
(paren
id|urb-&gt;dev
comma
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
comma
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
comma
id|qh
)paren
suffix:semicolon
r_return
id|qh
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* move qh (and its qtds) onto async queue; maybe enable queue.  */
DECL|function|qh_link_async
r_static
r_void
id|qh_link_async
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|ehci_qh
op_star
id|qh
)paren
(brace
id|u32
id|dma
op_assign
id|QH_NEXT
(paren
id|qh-&gt;qh_dma
)paren
suffix:semicolon
r_struct
id|ehci_qh
op_star
id|q
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
(paren
id|q
op_assign
id|ehci-&gt;async
)paren
)paren
)paren
(brace
id|u32
id|cmd
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
multiline_comment|/* in case a clear of CMD_ASE didn&squot;t take yet */
r_while
c_loop
(paren
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;status
)paren
op_amp
id|STS_ASS
)paren
id|udelay
(paren
l_int|100
)paren
suffix:semicolon
id|qh-&gt;hw_info1
op_or_assign
id|__constant_cpu_to_le32
(paren
id|QH_HEAD
)paren
suffix:semicolon
multiline_comment|/* [4.8] */
id|qh-&gt;qh_next.qh
op_assign
id|qh
suffix:semicolon
id|qh-&gt;hw_next
op_assign
id|dma
suffix:semicolon
id|ehci-&gt;async
op_assign
id|qh
suffix:semicolon
id|writel
(paren
(paren
id|u32
)paren
id|qh-&gt;qh_dma
comma
op_amp
id|ehci-&gt;regs-&gt;async_next
)paren
suffix:semicolon
id|cmd
op_or_assign
id|CMD_ASE
op_or
id|CMD_RUN
suffix:semicolon
id|writel
(paren
id|cmd
comma
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
id|ehci-&gt;hcd.state
op_assign
id|USB_STATE_RUNNING
suffix:semicolon
multiline_comment|/* posted write need not be known to HC yet ... */
)brace
r_else
(brace
multiline_comment|/* splice right after &quot;start&quot; of ring */
id|qh-&gt;hw_info1
op_and_assign
op_complement
id|__constant_cpu_to_le32
(paren
id|QH_HEAD
)paren
suffix:semicolon
multiline_comment|/* [4.8] */
id|qh-&gt;qh_next
op_assign
id|q-&gt;qh_next
suffix:semicolon
id|qh-&gt;hw_next
op_assign
id|q-&gt;hw_next
suffix:semicolon
id|q-&gt;qh_next.qh
op_assign
id|qh
suffix:semicolon
id|q-&gt;hw_next
op_assign
id|dma
suffix:semicolon
)brace
id|qh-&gt;qh_state
op_assign
id|QH_STATE_LINKED
suffix:semicolon
multiline_comment|/* qtd completions reported later by interrupt */
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
r_static
r_void
DECL|function|submit_async
id|submit_async
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|list_head
op_star
id|qtd_list
comma
r_int
id|mem_flags
)paren
(brace
r_struct
id|ehci_qtd
op_star
id|qtd
suffix:semicolon
r_struct
id|hcd_dev
op_star
id|dev
suffix:semicolon
r_int
id|epnum
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|ehci_qh
op_star
id|qh
op_assign
l_int|0
suffix:semicolon
id|qtd
op_assign
id|list_entry
(paren
id|qtd_list-&gt;next
comma
r_struct
id|ehci_qtd
comma
id|qtd_list
)paren
suffix:semicolon
id|dev
op_assign
(paren
r_struct
id|hcd_dev
op_star
)paren
id|urb-&gt;dev-&gt;hcpriv
suffix:semicolon
id|epnum
op_assign
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
)paren
id|epnum
op_or_assign
l_int|0x10
suffix:semicolon
id|vdbg
(paren
l_string|&quot;%s: submit_async urb %p len %d ep %d-%s qtd %p [qh %p]&quot;
comma
id|ehci-&gt;hcd.bus_name
comma
id|urb
comma
id|urb-&gt;transfer_buffer_length
comma
id|epnum
op_amp
l_int|0x0f
comma
(paren
id|epnum
op_amp
l_int|0x10
)paren
ques
c_cond
l_string|&quot;in&quot;
suffix:colon
l_string|&quot;out&quot;
comma
id|qtd
comma
id|dev
ques
c_cond
id|dev-&gt;ep
(braket
id|epnum
)braket
suffix:colon
(paren
r_void
op_star
)paren
op_complement
l_int|0
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|qh
op_assign
(paren
r_struct
id|ehci_qh
op_star
)paren
id|dev-&gt;ep
(braket
id|epnum
)braket
suffix:semicolon
r_if
c_cond
(paren
id|likely
(paren
id|qh
op_ne
l_int|0
)paren
)paren
(brace
id|u32
id|hw_next
op_assign
id|QTD_NEXT
(paren
id|qtd-&gt;qtd_dma
)paren
suffix:semicolon
multiline_comment|/* maybe patch the qh used for set_address */
r_if
c_cond
(paren
id|unlikely
(paren
id|epnum
op_eq
l_int|0
op_logical_and
id|le32_to_cpu
(paren
id|qh-&gt;hw_info1
op_amp
l_int|0x7f
)paren
op_eq
l_int|0
)paren
)paren
id|qh-&gt;hw_info1
op_or_assign
id|cpu_to_le32
(paren
id|usb_pipedevice
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
multiline_comment|/* is an URB is queued to this qh already? */
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|qh-&gt;qtd_list
)paren
)paren
)paren
(brace
r_struct
id|ehci_qtd
op_star
id|last_qtd
suffix:semicolon
r_int
id|short_rx
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* update the last qtd&squot;s &quot;next&quot; pointer */
singleline_comment|// dbg_qh (&quot;non-empty qh&quot;, ehci, qh);
id|last_qtd
op_assign
id|list_entry
(paren
id|qh-&gt;qtd_list.prev
comma
r_struct
id|ehci_qtd
comma
id|qtd_list
)paren
suffix:semicolon
id|last_qtd-&gt;hw_next
op_assign
id|hw_next
suffix:semicolon
multiline_comment|/* previous urb allows short rx? maybe optimize. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|last_qtd-&gt;urb-&gt;transfer_flags
op_amp
id|USB_DISABLE_SPD
)paren
op_logical_and
(paren
id|epnum
op_amp
l_int|0x10
)paren
)paren
(brace
singleline_comment|// only the last QTD for now
id|last_qtd-&gt;hw_alt_next
op_assign
id|hw_next
suffix:semicolon
id|short_rx
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Adjust any old copies in qh overlay too.&n;&t;&t;&t; * Interrupt code must cope with case of HC having it&n;&t;&t;&t; * cached, and clobbering these updates.&n;&t;&t;&t; * ... complicates getting rid of extra interrupts!&n;&t;&t;&t; */
r_if
c_cond
(paren
id|qh-&gt;hw_current
op_eq
id|cpu_to_le32
(paren
id|last_qtd-&gt;qtd_dma
)paren
)paren
(brace
id|wmb
(paren
)paren
suffix:semicolon
id|qh-&gt;hw_qtd_next
op_assign
id|hw_next
suffix:semicolon
r_if
c_cond
(paren
id|short_rx
)paren
id|qh-&gt;hw_alt_next
op_assign
id|hw_next
op_or
(paren
id|qh-&gt;hw_alt_next
op_amp
l_int|0x1e
)paren
suffix:semicolon
id|vdbg
(paren
l_string|&quot;queue to qh %p, patch&quot;
comma
id|qh
)paren
suffix:semicolon
)brace
multiline_comment|/* no URB queued */
)brace
r_else
(brace
singleline_comment|// dbg_qh (&quot;empty qh&quot;, ehci, qh);
singleline_comment|// FIXME:  how handle usb_clear_halt() for an EP with queued URBs?
singleline_comment|// usbcore may not let us handle that cleanly...
singleline_comment|// likely must cancel them all first!
multiline_comment|/* usb_clear_halt() means qh data toggle gets reset */
r_if
c_cond
(paren
id|usb_pipebulk
(paren
id|urb-&gt;pipe
)paren
op_logical_and
id|unlikely
(paren
op_logical_neg
id|usb_gettoggle
(paren
id|urb-&gt;dev
comma
(paren
id|epnum
op_amp
l_int|0x0f
)paren
comma
op_logical_neg
(paren
id|epnum
op_amp
l_int|0x10
)paren
)paren
)paren
)paren
(brace
id|clear_toggle
(paren
id|urb-&gt;dev
comma
id|epnum
op_amp
l_int|0x0f
comma
op_logical_neg
(paren
id|epnum
op_amp
l_int|0x10
)paren
comma
id|qh
)paren
suffix:semicolon
)brace
id|qh_update
(paren
id|qh
comma
id|qtd
)paren
suffix:semicolon
)brace
id|list_splice
(paren
id|qtd_list
comma
id|qh-&gt;qtd_list.prev
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* can&squot;t sleep here, we have ehci-&gt;lock... */
id|qh
op_assign
id|ehci_qh_make
(paren
id|ehci
comma
id|urb
comma
id|qtd_list
comma
id|SLAB_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
(paren
id|qh
op_ne
l_int|0
)paren
)paren
(brace
singleline_comment|// dbg_qh (&quot;new qh&quot;, ehci, qh);
id|dev-&gt;ep
(braket
id|epnum
)braket
op_assign
id|qh
suffix:semicolon
)brace
r_else
id|urb-&gt;status
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Control/bulk operations through TTs don&squot;t need scheduling,&n;&t; * the HC and TT handle it when the TT has a buffer ready.&n;&t; */
r_if
c_cond
(paren
id|likely
(paren
id|qh
op_ne
l_int|0
)paren
)paren
(brace
id|urb-&gt;hcpriv
op_assign
id|qh_put
(paren
id|qh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
(paren
id|qh-&gt;qh_state
op_eq
id|QH_STATE_IDLE
)paren
)paren
id|qh_link_async
(paren
id|ehci
comma
id|qh_put
(paren
id|qh
)paren
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|qh
)paren
)paren
id|qh_completions
(paren
id|ehci
comma
id|qtd_list
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* the async qh for the qtds being reclaimed are now unlinked from the HC */
multiline_comment|/* caller must not own ehci-&gt;lock */
DECL|function|end_unlink_async
r_static
r_void
id|end_unlink_async
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
)paren
(brace
r_struct
id|ehci_qh
op_star
id|qh
op_assign
id|ehci-&gt;reclaim
suffix:semicolon
id|qh-&gt;qh_state
op_assign
id|QH_STATE_IDLE
suffix:semicolon
id|qh-&gt;qh_next.qh
op_assign
l_int|0
suffix:semicolon
id|qh_unput
(paren
id|ehci
comma
id|qh
)paren
suffix:semicolon
singleline_comment|// refcount from reclaim 
id|ehci-&gt;reclaim
op_assign
l_int|0
suffix:semicolon
id|ehci-&gt;reclaim_ready
op_assign
l_int|0
suffix:semicolon
id|qh_completions
(paren
id|ehci
comma
op_amp
id|qh-&gt;qtd_list
comma
l_int|1
)paren
suffix:semicolon
singleline_comment|// unlink any urb should now unlink all following urbs, so that
singleline_comment|// relinking only happens for urbs before the unlinked ones.
r_if
c_cond
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|qh-&gt;qtd_list
)paren
op_logical_and
id|HCD_IS_RUNNING
(paren
id|ehci-&gt;hcd.state
)paren
)paren
id|qh_link_async
(paren
id|ehci
comma
id|qh
)paren
suffix:semicolon
r_else
id|qh_unput
(paren
id|ehci
comma
id|qh
)paren
suffix:semicolon
singleline_comment|// refcount from async list
)brace
multiline_comment|/* makes sure the async qh will become idle */
multiline_comment|/* caller must own ehci-&gt;lock */
DECL|function|start_unlink_async
r_static
r_void
id|start_unlink_async
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
comma
r_struct
id|ehci_qh
op_star
id|qh
)paren
(brace
r_int
id|cmd
op_assign
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
r_struct
id|ehci_qh
op_star
id|prev
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|ehci-&gt;reclaim
op_logical_or
op_logical_neg
id|ehci-&gt;async
op_logical_or
id|qh-&gt;qh_state
op_ne
id|QH_STATE_LINKED
macro_line|#ifdef CONFIG_SMP
singleline_comment|// this macro lies except on SMP compiles
op_logical_or
op_logical_neg
id|spin_is_locked
(paren
op_amp
id|ehci-&gt;lock
)paren
macro_line|#endif
)paren
id|BUG
(paren
)paren
suffix:semicolon
macro_line|#endif
id|qh-&gt;qh_state
op_assign
id|QH_STATE_UNLINK
suffix:semicolon
id|ehci-&gt;reclaim
op_assign
id|qh
op_assign
id|qh_put
(paren
id|qh
)paren
suffix:semicolon
singleline_comment|// dbg_qh (&quot;start unlink&quot;, ehci, qh);
multiline_comment|/* Remove the last QH (qhead)?  Stop async schedule first. */
r_if
c_cond
(paren
id|unlikely
(paren
id|qh
op_eq
id|ehci-&gt;async
op_logical_and
id|qh-&gt;qh_next.qh
op_eq
id|qh
)paren
)paren
(brace
multiline_comment|/* can&squot;t get here without STS_ASS set */
r_if
c_cond
(paren
id|ehci-&gt;hcd.state
op_ne
id|USB_STATE_HALT
)paren
(brace
r_if
c_cond
(paren
id|cmd
op_amp
id|CMD_PSE
)paren
id|writel
(paren
id|cmd
op_amp
op_complement
id|CMD_ASE
comma
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
r_else
(brace
id|ehci_ready
(paren
id|ehci
)paren
suffix:semicolon
r_while
c_loop
(paren
id|readl
(paren
op_amp
id|ehci-&gt;regs-&gt;status
)paren
op_amp
id|STS_ASS
)paren
id|udelay
(paren
l_int|100
)paren
suffix:semicolon
)brace
)brace
id|qh-&gt;qh_next.qh
op_assign
id|ehci-&gt;async
op_assign
l_int|0
suffix:semicolon
id|ehci-&gt;reclaim_ready
op_assign
l_int|1
suffix:semicolon
id|tasklet_schedule
(paren
op_amp
id|ehci-&gt;tasklet
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
(paren
id|ehci-&gt;hcd.state
op_eq
id|USB_STATE_HALT
)paren
)paren
(brace
id|ehci-&gt;reclaim_ready
op_assign
l_int|1
suffix:semicolon
id|tasklet_schedule
(paren
op_amp
id|ehci-&gt;tasklet
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|prev
op_assign
id|ehci-&gt;async
suffix:semicolon
r_while
c_loop
(paren
id|prev-&gt;qh_next.qh
op_ne
id|qh
op_logical_and
id|prev-&gt;qh_next.qh
op_ne
id|ehci-&gt;async
)paren
id|prev
op_assign
id|prev-&gt;qh_next.qh
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|prev-&gt;qh_next.qh
op_ne
id|qh
)paren
id|BUG
(paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|qh-&gt;hw_info1
op_amp
id|__constant_cpu_to_le32
(paren
id|QH_HEAD
)paren
)paren
(brace
id|ehci-&gt;async
op_assign
id|prev
suffix:semicolon
id|prev-&gt;hw_info1
op_or_assign
id|__constant_cpu_to_le32
(paren
id|QH_HEAD
)paren
suffix:semicolon
)brace
id|prev-&gt;hw_next
op_assign
id|qh-&gt;hw_next
suffix:semicolon
id|prev-&gt;qh_next
op_assign
id|qh-&gt;qh_next
suffix:semicolon
id|ehci-&gt;reclaim_ready
op_assign
l_int|0
suffix:semicolon
id|cmd
op_or_assign
id|CMD_IAAD
suffix:semicolon
id|writel
(paren
id|cmd
comma
op_amp
id|ehci-&gt;regs-&gt;command
)paren
suffix:semicolon
multiline_comment|/* posted write need not be known to HC yet ... */
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|scan_async
r_static
r_void
id|scan_async
(paren
r_struct
id|ehci_hcd
op_star
id|ehci
)paren
(brace
r_struct
id|ehci_qh
op_star
id|qh
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|rescan
suffix:colon
id|qh
op_assign
id|ehci-&gt;async
suffix:semicolon
r_if
c_cond
(paren
id|likely
(paren
id|qh
op_ne
l_int|0
)paren
)paren
(brace
r_do
(brace
multiline_comment|/* clean any finished work for this qh */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|qh-&gt;qtd_list
)paren
)paren
(brace
singleline_comment|// dbg_qh (&quot;scan_async&quot;, ehci, qh);
id|qh
op_assign
id|qh_put
(paren
id|qh
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* concurrent unlink could happen here */
id|qh_completions
(paren
id|ehci
comma
op_amp
id|qh-&gt;qtd_list
comma
l_int|1
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|qh_unput
(paren
id|ehci
comma
id|qh
)paren
suffix:semicolon
)brace
multiline_comment|/* unlink idle entries (reduces PCI usage) */
r_if
c_cond
(paren
id|list_empty
(paren
op_amp
id|qh-&gt;qtd_list
)paren
op_logical_and
op_logical_neg
id|ehci-&gt;reclaim
)paren
(brace
r_if
c_cond
(paren
id|qh-&gt;qh_next.qh
op_ne
id|qh
)paren
(brace
singleline_comment|// dbg (&quot;irq/empty&quot;);
id|start_unlink_async
(paren
id|ehci
comma
id|qh
)paren
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// FIXME:  arrange to stop
singleline_comment|// after it&squot;s been idle a while.
)brace
)brace
id|qh
op_assign
id|qh-&gt;qh_next.qh
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|qh
)paren
multiline_comment|/* unlinked? */
r_goto
id|rescan
suffix:semicolon
)brace
r_while
c_loop
(paren
id|qh
op_ne
id|ehci-&gt;async
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|ehci-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
eof
