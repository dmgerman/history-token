multiline_comment|/*&n; * USB Serial Converter driver&n; *&n; * Copyright (C) 1999 - 2002 Greg Kroah-Hartman (greg@kroah.com)&n; * Copyright (c) 2000 Peter Berger (pberger@brimson.com)&n; * Copyright (c) 2000 Al Borchers (borchers@steinerpoint.com)&n; *&n; *&t;This program is free software; you can redistribute it and/or&n; *&t;modify it under the terms of the GNU General Public License version&n; *&t;2 as published by the Free Software Foundation.&n; *&n; * This driver was originally based on the ACM driver by Armin Fuerst (which was &n; * based on a driver by Brad Keryan)&n; *&n; * See Documentation/usb/usb-serial.txt for more information on using this driver&n; *&n; * (10/02/2002) gkh&n; *&t;moved the console code to console.c and out of this file.&n; *&n; * (06/05/2002) gkh&n; *&t;moved location of startup() call in serial_probe() until after all&n; *&t;of the port information and endpoints are initialized.  This makes&n; *&t;things easier for some drivers.&n; *&n; * (04/10/2002) gkh&n; *&t;added serial_read_proc function which creates a&n; *&t;/proc/tty/driver/usb-serial file.&n; *&n; * (03/27/2002) gkh&n; *&t;Got USB serial console code working properly and merged into the main&n; *&t;version of the tree.  Thanks to Randy Dunlap for the initial version&n; *&t;of this code, and for pushing me to finish it up.&n; *&t;The USB serial console works with any usb serial driver device.&n; *&n; * (03/21/2002) gkh&n; *&t;Moved all manipulation of port-&gt;open_count into the core.  Now the&n; *&t;individual driver&squot;s open and close functions are called only when the&n; *&t;first open() and last close() is called.  Making the drivers a bit&n; *&t;smaller and simpler.&n; *&t;Fixed a bug if a driver didn&squot;t have the owner field set.&n; *&n; * (02/26/2002) gkh&n; *&t;Moved all locking into the main serial_* functions, instead of having &n; *&t;the individual drivers have to grab the port semaphore.  This should&n; *&t;reduce races.&n; *&t;Reworked the MOD_INC logic a bit to always increment and decrement, even&n; *&t;if the generic driver is being used.&n; *&n; * (10/10/2001) gkh&n; *&t;usb_serial_disconnect() now sets the serial-&gt;dev pointer is to NULL to&n; *&t;help prevent child drivers from accessing the device since it is now&n; *&t;gone.&n; *&n; * (09/13/2001) gkh&n; *&t;Moved generic driver initialize after we have registered with the USB&n; *&t;core.  Thanks to Randy Dunlap for pointing this problem out.&n; *&n; * (07/03/2001) gkh&n; *&t;Fixed module paramater size.  Thanks to John Brockmeyer for the pointer.&n; *&t;Fixed vendor and product getting defined through the MODULE_PARM macro&n; *&t;if the Generic driver wasn&squot;t compiled in.&n; *&t;Fixed problem with generic_shutdown() not being called for drivers that&n; *&t;don&squot;t have a shutdown() function.&n; *&n; * (06/06/2001) gkh&n; *&t;added evil hack that is needed for the prolific pl2303 device due to the&n; *&t;crazy way its endpoints are set up.&n; *&n; * (05/30/2001) gkh&n; *&t;switched from using spinlock to a semaphore, which fixes lots of problems.&n; *&n; * (04/08/2001) gb&n; *&t;Identify version on module load.&n; *&n; * 2001_02_05 gkh&n; *&t;Fixed buffer overflows bug with the generic serial driver.  Thanks to&n; *&t;Todd Squires &lt;squirest@ct0.com&gt; for fixing this.&n; *&n; * (01/10/2001) gkh&n; *&t;Fixed bug where the generic serial adaptor grabbed _any_ device that was&n; *&t;offered to it.&n; *&n; * (12/12/2000) gkh&n; *&t;Removed MOD_INC and MOD_DEC from poll and disconnect functions, and&n; *&t;moved them to the serial_open and serial_close functions.&n; *&t;Also fixed bug with there not being a MOD_DEC for the generic driver&n; *&t;(thanks to Gary Brubaker for finding this.)&n; *&n; * (11/29/2000) gkh&n; *&t;Small NULL pointer initialization cleanup which saves a bit of disk image&n; *&n; * (11/01/2000) Adam J. Richter&n; *&t;instead of using idVendor/idProduct pairs, usb serial drivers&n; *&t;now identify their hardware interest with usb_device_id tables,&n; *&t;which they usually have anyhow for use with MODULE_DEVICE_TABLE.&n; *&n; * (10/05/2000) gkh&n; *&t;Fixed bug with urb-&gt;dev not being set properly, now that the usb&n; *&t;core needs it.&n; * &n; * (09/11/2000) gkh&n; *&t;Removed DEBUG #ifdefs with call to usb_serial_debug_data&n; *&n; * (08/28/2000) gkh&n; *&t;Added port_lock to port structure.&n; *&t;Added locks for SMP safeness to generic driver&n; *&t;Fixed the ability to open a generic device&squot;s port more than once.&n; *&n; * (07/23/2000) gkh&n; *&t;Added bulk_out_endpointAddress to port structure.&n; *&n; * (07/19/2000) gkh, pberger, and borchers&n; *&t;Modifications to allow usb-serial drivers to be modules.&n; *&n; * (07/03/2000) gkh&n; *&t;Added more debugging to serial_ioctl call&n; * &n; * (06/25/2000) gkh&n; *&t;Changed generic_write_bulk_callback to not call wake_up_interruptible&n; *&t;directly, but to have port_softint do it at a safer time.&n; *&n; * (06/23/2000) gkh&n; *&t;Cleaned up debugging statements in a quest to find UHCI timeout bug.&n; *&n; * (05/22/2000) gkh&n; *&t;Changed the makefile, enabling the big CONFIG_USB_SERIAL_SOMTHING to be &n; *&t;removed from the individual device source files.&n; *&n; * (05/03/2000) gkh&n; *&t;Added the Digi Acceleport driver from Al Borchers and Peter Berger.&n; * &n; * (05/02/2000) gkh&n; *&t;Changed devfs and tty register code to work properly now. This was based on&n; *&t;the ACM driver changes by Vojtech Pavlik.&n; *&n; * (04/27/2000) Ryan VanderBijl&n; * &t;Put calls to *_paranoia_checks into one function.&n; * &n; * (04/23/2000) gkh&n; *&t;Fixed bug that Randy Dunlap found for Generic devices with no bulk out ports.&n; *&t;Moved when the startup code printed out the devices that are supported.&n; *&n; * (04/19/2000) gkh&n; *&t;Added driver for ZyXEL omni.net lcd plus ISDN TA&n; *&t;Made startup info message specify which drivers were compiled in.&n; *&n; * (04/03/2000) gkh&n; *&t;Changed the probe process to remove the module unload races.&n; *&t;Changed where the tty layer gets initialized to have devfs work nicer.&n; *&t;Added initial devfs support.&n; *&n; * (03/26/2000) gkh&n; *&t;Split driver up into device specific pieces.&n; * &n; * (03/19/2000) gkh&n; *&t;Fixed oops that could happen when device was removed while a program&n; *&t;was talking to the device.&n; *&t;Removed the static urbs and now all urbs are created and destroyed&n; *&t;dynamically.&n; *&t;Reworked the internal interface. Now everything is based on the &n; *&t;usb_serial_port structure instead of the larger usb_serial structure.&n; *&t;This fixes the bug that a multiport device could not have more than&n; *&t;one port open at one time.&n; *&n; * (03/17/2000) gkh&n; *&t;Added config option for debugging messages.&n; *&t;Added patch for keyspan pda from Brian Warner.&n; *&n; * (03/06/2000) gkh&n; *&t;Added the keyspan pda code from Brian Warner &lt;warner@lothar.com&gt;&n; *&t;Moved a bunch of the port specific stuff into its own structure. This&n; *&t;is in anticipation of the true multiport devices (there&squot;s a bug if you&n; *&t;try to access more than one port of any multiport device right now)&n; *&n; * (02/21/2000) gkh&n; *&t;Made it so that any serial devices only have to specify which functions&n; *&t;they want to overload from the generic function calls (great, &n; *&t;inheritance in C, in a driver, just what I wanted...)&n; *&t;Added support for set_termios and ioctl function calls. No drivers take&n; *&t;advantage of this yet.&n; *&t;Removed the #ifdef MODULE, now there is no module specific code.&n; *&t;Cleaned up a few comments in usb-serial.h that were wrong (thanks again&n; *&t;to Miles Lott).&n; *&t;Small fix to get_free_serial.&n; *&n; * (02/14/2000) gkh&n; *&t;Removed the Belkin and Peracom functionality from the driver due to&n; *&t;the lack of support from the vendor, and me not wanting people to &n; *&t;accidenatly buy the device, expecting it to work with Linux.&n; *&t;Added read_bulk_callback and write_bulk_callback to the type structure&n; *&t;for the needs of the FTDI and WhiteHEAT driver.&n; *&t;Changed all reverences to FTDI to FTDI_SIO at the request of Bill&n; *&t;Ryder.&n; *&t;Changed the output urb size back to the max endpoint size to make&n; *&t;the ftdi_sio driver have it easier, and due to the fact that it didn&squot;t&n; *&t;really increase the speed any.&n; *&n; * (02/11/2000) gkh&n; *&t;Added VISOR_FUNCTION_CONSOLE to the visor startup function. This was a&n; *&t;patch from Miles Lott (milos@insync.net).&n; *&t;Fixed bug with not restoring the minor range that a device grabs, if&n; *&t;the startup function fails (thanks Miles for finding this).&n; *&n; * (02/05/2000) gkh&n; *&t;Added initial framework for the Keyspan PDA serial converter so that&n; *&t;Brian Warner has a place to put his code.&n; *&t;Made the ezusb specific functions generic enough that different&n; *&t;devices can use them (whiteheat and keyspan_pda both need them).&n; *&t;Split out a whole bunch of structure and other stuff to a seperate&n; *&t;usb-serial.h file.&n; *&t;Made the Visor connection messages a little more understandable, now&n; *&t;that Miles Lott (milos@insync.net) has gotten the Generic channel to&n; *&t;work. Also made them always show up in the log file.&n; * &n; * (01/25/2000) gkh&n; *&t;Added initial framework for FTDI serial converter so that Bill Ryder&n; *&t;has a place to put his code.&n; *&t;Added the vendor specific info from Handspring. Now we can print out&n; *&t;informational debug messages as well as understand what is happening.&n; *&n; * (01/23/2000) gkh&n; *&t;Fixed problem of crash when trying to open a port that didn&squot;t have a&n; *&t;device assigned to it. Made the minor node finding a little smarter,&n; *&t;now it looks to find a continous space for the new device.&n; *&n; * (01/21/2000) gkh&n; *&t;Fixed bug in visor_startup with patch from Miles Lott (milos@insync.net)&n; *&t;Fixed get_serial_by_minor which was all messed up for multi port &n; *&t;devices. Fixed multi port problem for generic devices. Now the number&n; *&t;of ports is determined by the number of bulk out endpoints for the&n; *&t;generic device.&n; *&n; * (01/19/2000) gkh&n; *&t;Removed lots of cruft that was around from the old (pre urb) driver &n; *&t;interface.&n; *&t;Made the serial_table dynamic. This should save lots of memory when&n; *&t;the number of minor nodes goes up to 256.&n; *&t;Added initial support for devices that have more than one port. &n; *&t;Added more debugging comments for the Visor, and added a needed &n; *&t;set_configuration call.&n; *&n; * (01/17/2000) gkh&n; *&t;Fixed the WhiteHEAT firmware (my processing tool had a bug)&n; *&t;and added new debug loader firmware for it.&n; *&t;Removed the put_char function as it isn&squot;t really needed.&n; *&t;Added visor startup commands as found by the Win98 dump.&n; * &n; * (01/13/2000) gkh&n; *&t;Fixed the vendor id for the generic driver to the one I meant it to be.&n; *&n; * (01/12/2000) gkh&n; *&t;Forget the version numbering...that&squot;s pretty useless...&n; *&t;Made the driver able to be compiled so that the user can select which&n; *&t;converter they want to use. This allows people who only want the Visor&n; *&t;support to not pay the memory size price of the WhiteHEAT.&n; *&t;Fixed bug where the generic driver (idVendor=0000 and idProduct=0000)&n; *&t;grabbed the root hub. Not good.&n; * &n; * version 0.4.0 (01/10/2000) gkh&n; *&t;Added whiteheat.h containing the firmware for the ConnectTech WhiteHEAT&n; *&t;device. Added startup function to allow firmware to be downloaded to&n; *&t;a device if it needs to be.&n; *&t;Added firmware download logic to the WhiteHEAT device.&n; *&t;Started to add #defines to split up the different drivers for potential&n; *&t;configuration option.&n; *&t;&n; * version 0.3.1 (12/30/99) gkh&n; *      Fixed problems with urb for bulk out.&n; *      Added initial support for multiple sets of endpoints. This enables&n; *      the Handspring Visor to be attached successfully. Only the first&n; *      bulk in / bulk out endpoint pair is being used right now.&n; *&n; * version 0.3.0 (12/27/99) gkh&n; *&t;Added initial support for the Handspring Visor based on a patch from&n; *&t;Miles Lott (milos@sneety.insync.net)&n; *&t;Cleaned up the code a bunch and converted over to using urbs only.&n; *&n; * version 0.2.3 (12/21/99) gkh&n; *&t;Added initial support for the Connect Tech WhiteHEAT converter.&n; *&t;Incremented the number of ports in expectation of getting the&n; *&t;WhiteHEAT to work properly (4 ports per connection).&n; *&t;Added notification on insertion and removal of what port the&n; *&t;device is/was connected to (and what kind of device it was).&n; *&n; * version 0.2.2 (12/16/99) gkh&n; *&t;Changed major number to the new allocated number. We&squot;re legal now!&n; *&n; * version 0.2.1 (12/14/99) gkh&n; *&t;Fixed bug that happens when device node is opened when there isn&squot;t a&n; *&t;device attached to it. Thanks to marek@webdesign.no for noticing this.&n; *&n; * version 0.2.0 (11/10/99) gkh&n; *&t;Split up internals to make it easier to add different types of serial &n; *&t;converters to the code.&n; *&t;Added a &quot;generic&quot; driver that gets it&squot;s vendor and product id&n; *&t;from when the module is loaded. Thanks to David E. Nelson (dnelson@jump.net)&n; *&t;for the idea and sample code (from the usb scanner driver.)&n; *&t;Cleared up any licensing questions by releasing it under the GNU GPL.&n; *&n; * version 0.1.2 (10/25/99) gkh&n; * &t;Fixed bug in detecting device.&n; *&n; * version 0.1.1 (10/05/99) gkh&n; * &t;Changed the major number to not conflict with anything else.&n; *&n; * version 0.1 (09/28/99) gkh&n; * &t;Can recognize the two different devices and start up a read from&n; *&t;device when asked to. Writes also work. No control signals yet, this&n; *&t;all is vendor specific data (i.e. no spec), also no control for&n; *&t;different baud rates or other bit settings.&n; *&t;Currently we are using the same devid as the acm driver. This needs&n; *&t;to change.&n; * &n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/tty_driver.h&gt;
macro_line|#include &lt;linux/tty_flip.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/usb.h&gt;
macro_line|#ifdef CONFIG_USB_SERIAL_DEBUG
DECL|variable|debug
r_static
r_int
id|debug
op_assign
l_int|1
suffix:semicolon
macro_line|#else
DECL|variable|debug
r_static
r_int
id|debug
suffix:semicolon
macro_line|#endif
macro_line|#include &quot;usb-serial.h&quot;
macro_line|#include &quot;pl2303.h&quot;
multiline_comment|/*&n; * Version Information&n; */
DECL|macro|DRIVER_VERSION
mdefine_line|#define DRIVER_VERSION &quot;v1.6&quot;
DECL|macro|DRIVER_AUTHOR
mdefine_line|#define DRIVER_AUTHOR &quot;Greg Kroah-Hartman, greg@kroah.com, http:
singleline_comment|//www.kroah.com/linux/&quot;
DECL|macro|DRIVER_DESC
mdefine_line|#define DRIVER_DESC &quot;USB Serial Driver core&quot;
multiline_comment|/* function prototypes for a &quot;generic&quot; type serial converter (no flow control, not all endpoints needed) */
multiline_comment|/* need to always compile these in, as some of the other devices use these functions as their own. */
multiline_comment|/* if a driver does not provide a function pointer, the generic function will be called. */
r_int
id|usb_serial_generic_open
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_int
id|usb_serial_generic_write
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
suffix:semicolon
r_static
r_void
id|generic_close
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_int
id|generic_write_room
(paren
r_struct
id|usb_serial_port
op_star
id|port
)paren
suffix:semicolon
r_static
r_int
id|generic_chars_in_buffer
(paren
r_struct
id|usb_serial_port
op_star
id|port
)paren
suffix:semicolon
r_static
r_void
id|generic_read_bulk_callback
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
r_static
r_void
id|generic_write_bulk_callback
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
r_static
r_void
id|generic_shutdown
(paren
r_struct
id|usb_serial
op_star
id|serial
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_USB_SERIAL_GENERIC
DECL|variable|vendor
r_static
id|__u16
id|vendor
op_assign
l_int|0x05f9
suffix:semicolon
DECL|variable|product
r_static
id|__u16
id|product
op_assign
l_int|0xffff
suffix:semicolon
DECL|variable|generic_device_ids
r_static
r_struct
id|usb_device_id
id|generic_device_ids
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* Initially all zeroes. */
multiline_comment|/* All of the device info needed for the Generic Serial Converter */
DECL|variable|generic_device
r_static
r_struct
id|usb_serial_device_type
id|generic_device
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|name
op_assign
l_string|&quot;Generic&quot;
comma
dot
id|id_table
op_assign
id|generic_device_ids
comma
dot
id|num_interrupt_in
op_assign
id|NUM_DONT_CARE
comma
dot
id|num_bulk_in
op_assign
id|NUM_DONT_CARE
comma
dot
id|num_bulk_out
op_assign
id|NUM_DONT_CARE
comma
dot
id|num_ports
op_assign
l_int|1
comma
dot
id|shutdown
op_assign
id|generic_shutdown
comma
)brace
suffix:semicolon
multiline_comment|/* we want to look at all devices, as the vendor/product id can change&n; * depending on the command line argument */
DECL|variable|generic_serial_ids
r_static
r_struct
id|usb_device_id
id|generic_serial_ids
(braket
)braket
op_assign
(brace
(brace
dot
id|driver_info
op_assign
l_int|42
)brace
comma
(brace
)brace
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/* Driver structure we register with the USB core */
DECL|variable|usb_serial_driver
r_static
r_struct
id|usb_driver
id|usb_serial_driver
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;serial&quot;
comma
dot
id|probe
op_assign
id|usb_serial_probe
comma
dot
id|disconnect
op_assign
id|usb_serial_disconnect
comma
macro_line|#ifdef CONFIG_USB_SERIAL_GENERIC
dot
id|id_table
op_assign
id|generic_serial_ids
comma
macro_line|#endif
)brace
suffix:semicolon
multiline_comment|/* There is no MODULE_DEVICE_TABLE for usbserial.c.  Instead&n;   the MODULE_DEVICE_TABLE declarations in each serial driver&n;   cause the &quot;hotplug&quot; program to pull in whatever module is necessary&n;   via modprobe, and modprobe will load usbserial because the serial&n;   drivers depend on it.&n;*/
DECL|variable|serial_refcount
r_static
r_int
id|serial_refcount
suffix:semicolon
DECL|variable|serial_tty_driver
r_static
r_struct
id|tty_driver
id|serial_tty_driver
suffix:semicolon
DECL|variable|serial_tty
r_static
r_struct
id|tty_struct
op_star
id|serial_tty
(braket
id|SERIAL_TTY_MINORS
)braket
suffix:semicolon
DECL|variable|serial_termios
r_static
r_struct
id|termios
op_star
id|serial_termios
(braket
id|SERIAL_TTY_MINORS
)braket
suffix:semicolon
DECL|variable|serial_termios_locked
r_static
r_struct
id|termios
op_star
id|serial_termios_locked
(braket
id|SERIAL_TTY_MINORS
)braket
suffix:semicolon
DECL|variable|serial_table
r_static
r_struct
id|usb_serial
op_star
id|serial_table
(braket
id|SERIAL_TTY_MINORS
)braket
suffix:semicolon
multiline_comment|/* initially all NULL */
r_static
id|LIST_HEAD
c_func
(paren
id|usb_serial_driver_list
)paren
suffix:semicolon
DECL|function|usb_serial_get_by_minor
r_struct
id|usb_serial
op_star
id|usb_serial_get_by_minor
(paren
r_int
r_int
id|minor
)paren
(brace
r_return
id|serial_table
(braket
id|minor
)braket
suffix:semicolon
)brace
DECL|function|get_free_serial
r_static
r_struct
id|usb_serial
op_star
id|get_free_serial
(paren
r_struct
id|usb_serial
op_star
id|serial
comma
r_int
id|num_ports
comma
r_int
r_int
op_star
id|minor
)paren
(brace
r_int
r_int
id|i
comma
id|j
suffix:semicolon
r_int
id|good_spot
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s %d&quot;
comma
id|__FUNCTION__
comma
id|num_ports
)paren
suffix:semicolon
op_star
id|minor
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SERIAL_TTY_MINORS
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|serial_table
(braket
id|i
)braket
)paren
r_continue
suffix:semicolon
id|good_spot
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|1
suffix:semicolon
id|j
op_le
id|num_ports
op_minus
l_int|1
suffix:semicolon
op_increment
id|j
)paren
r_if
c_cond
(paren
(paren
id|serial_table
(braket
id|i
op_plus
id|j
)braket
)paren
op_logical_or
(paren
id|i
op_plus
id|j
op_ge
id|SERIAL_TTY_MINORS
)paren
)paren
(brace
id|good_spot
op_assign
l_int|0
suffix:semicolon
id|i
op_add_assign
id|j
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|good_spot
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|serial-&gt;magic
op_assign
id|USB_SERIAL_MAGIC
suffix:semicolon
op_star
id|minor
op_assign
id|i
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s - minor base = %d&quot;
comma
id|__FUNCTION__
comma
op_star
id|minor
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
op_star
id|minor
suffix:semicolon
(paren
id|i
OL
(paren
op_star
id|minor
op_plus
id|num_ports
)paren
)paren
op_logical_and
(paren
id|i
OL
id|SERIAL_TTY_MINORS
)paren
suffix:semicolon
op_increment
id|i
)paren
id|serial_table
(braket
id|i
)braket
op_assign
id|serial
suffix:semicolon
r_return
id|serial
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|return_serial
r_static
r_void
id|return_serial
(paren
r_struct
id|usb_serial
op_star
id|serial
)paren
(brace
r_int
id|i
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serial
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|serial-&gt;num_ports
suffix:semicolon
op_increment
id|i
)paren
(brace
id|serial_table
(braket
id|serial-&gt;minor
op_plus
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
macro_line|#ifdef USES_EZUSB_FUNCTIONS
multiline_comment|/* EZ-USB Control and Status Register.  Bit 0 controls 8051 reset */
DECL|macro|CPUCS_REG
mdefine_line|#define CPUCS_REG    0x7F92
DECL|function|ezusb_writememory
r_int
id|ezusb_writememory
(paren
r_struct
id|usb_serial
op_star
id|serial
comma
r_int
id|address
comma
r_int
r_char
op_star
id|data
comma
r_int
id|length
comma
id|__u8
id|bRequest
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_char
op_star
id|transfer_buffer
suffix:semicolon
multiline_comment|/* dbg(&quot;ezusb_writememory %x, %d&quot;, address, length); */
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;dev
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;%s - no physical device present, failing.&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|transfer_buffer
op_assign
id|kmalloc
(paren
id|length
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|transfer_buffer
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s - kmalloc(%d) failed.&quot;
comma
id|__FUNCTION__
comma
id|length
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memcpy
(paren
id|transfer_buffer
comma
id|data
comma
id|length
)paren
suffix:semicolon
id|result
op_assign
id|usb_control_msg
(paren
id|serial-&gt;dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
id|bRequest
comma
l_int|0x40
comma
id|address
comma
l_int|0
comma
id|transfer_buffer
comma
id|length
comma
l_int|3
op_star
id|HZ
)paren
suffix:semicolon
id|kfree
(paren
id|transfer_buffer
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|ezusb_set_reset
r_int
id|ezusb_set_reset
(paren
r_struct
id|usb_serial
op_star
id|serial
comma
r_int
r_char
id|reset_bit
)paren
(brace
r_int
id|response
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s - %d&quot;
comma
id|__FUNCTION__
comma
id|reset_bit
)paren
suffix:semicolon
id|response
op_assign
id|ezusb_writememory
(paren
id|serial
comma
id|CPUCS_REG
comma
op_amp
id|reset_bit
comma
l_int|1
comma
l_int|0xa0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|response
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s- %d failed&quot;
comma
id|__FUNCTION__
comma
id|reset_bit
)paren
suffix:semicolon
)brace
r_return
id|response
suffix:semicolon
)brace
macro_line|#endif&t;/* USES_EZUSB_FUNCTIONS */
multiline_comment|/*****************************************************************************&n; * Driver tty interface functions&n; *****************************************************************************/
DECL|function|serial_open
r_static
r_int
id|serial_open
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
suffix:semicolon
r_struct
id|usb_serial_port
op_star
id|port
suffix:semicolon
r_int
r_int
id|portNumber
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* initialize the pointer incase something fails */
id|tty-&gt;driver_data
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* get the serial object associated with this tty pointer */
id|serial
op_assign
id|usb_serial_get_by_minor
(paren
id|minor
c_func
(paren
id|tty-&gt;device
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serial_paranoia_check
(paren
id|serial
comma
id|__FUNCTION__
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* set up our port structure making the tty driver remember our port object, and us it */
id|portNumber
op_assign
id|minor
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|serial-&gt;minor
suffix:semicolon
id|port
op_assign
op_amp
id|serial-&gt;port
(braket
id|portNumber
)braket
suffix:semicolon
id|tty-&gt;driver_data
op_assign
id|port
suffix:semicolon
id|down
(paren
op_amp
id|port-&gt;sem
)paren
suffix:semicolon
id|port-&gt;tty
op_assign
id|tty
suffix:semicolon
multiline_comment|/* lock this module before we call it */
r_if
c_cond
(paren
id|serial-&gt;type-&gt;owner
)paren
id|__MOD_INC_USE_COUNT
c_func
(paren
id|serial-&gt;type-&gt;owner
)paren
suffix:semicolon
op_increment
id|port-&gt;open_count
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;open_count
op_eq
l_int|1
)paren
(brace
multiline_comment|/* only call the device specific open if this &n;&t;&t; * is the first time the port is opened */
r_if
c_cond
(paren
id|serial-&gt;type-&gt;open
)paren
id|retval
op_assign
id|serial-&gt;type
op_member_access_from_pointer
id|open
c_func
(paren
id|port
comma
id|filp
)paren
suffix:semicolon
r_else
id|retval
op_assign
id|usb_serial_generic_open
c_func
(paren
id|port
comma
id|filp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|port-&gt;open_count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|serial-&gt;type-&gt;owner
)paren
id|__MOD_DEC_USE_COUNT
c_func
(paren
id|serial-&gt;type-&gt;owner
)paren
suffix:semicolon
)brace
)brace
id|up
(paren
op_amp
id|port-&gt;sem
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|__serial_close
r_static
r_void
id|__serial_close
c_func
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;open_count
)paren
(brace
id|dbg
(paren
l_string|&quot;%s - port not opened&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
op_decrement
id|port-&gt;open_count
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;open_count
op_le
l_int|0
)paren
(brace
multiline_comment|/* only call the device specific close if this &n;&t;&t; * port is being closed by the last owner */
r_if
c_cond
(paren
id|port-&gt;serial-&gt;type-&gt;close
)paren
id|port-&gt;serial-&gt;type
op_member_access_from_pointer
id|close
c_func
(paren
id|port
comma
id|filp
)paren
suffix:semicolon
r_else
id|generic_close
c_func
(paren
id|port
comma
id|filp
)paren
suffix:semicolon
id|port-&gt;open_count
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|port-&gt;serial-&gt;type-&gt;owner
)paren
id|__MOD_DEC_USE_COUNT
c_func
(paren
id|port-&gt;serial-&gt;type-&gt;owner
)paren
suffix:semicolon
)brace
DECL|function|serial_close
r_static
r_void
id|serial_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|usb_serial_port
op_star
id|port
op_assign
(paren
r_struct
id|usb_serial_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_struct
id|usb_serial
op_star
id|serial
op_assign
id|get_usb_serial
(paren
id|port
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
r_return
suffix:semicolon
id|down
(paren
op_amp
id|port-&gt;sem
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s - port %d&quot;
comma
id|__FUNCTION__
comma
id|port-&gt;number
)paren
suffix:semicolon
multiline_comment|/* if disconnect beat us to the punch here, there&squot;s nothing to do */
r_if
c_cond
(paren
id|tty-&gt;driver_data
)paren
(brace
id|__serial_close
c_func
(paren
id|port
comma
id|filp
)paren
suffix:semicolon
)brace
id|up
(paren
op_amp
id|port-&gt;sem
)paren
suffix:semicolon
)brace
DECL|function|serial_write
r_static
r_int
id|serial_write
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|usb_serial_port
op_star
id|port
op_assign
(paren
r_struct
id|usb_serial_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_struct
id|usb_serial
op_star
id|serial
op_assign
id|get_usb_serial
(paren
id|port
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_int
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|down
(paren
op_amp
id|port-&gt;sem
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s - port %d, %d byte(s)&quot;
comma
id|__FUNCTION__
comma
id|port-&gt;number
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;open_count
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;%s - port not opened&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
multiline_comment|/* pass on to the driver specific version of this function if it is available */
r_if
c_cond
(paren
id|serial-&gt;type-&gt;write
)paren
id|retval
op_assign
id|serial-&gt;type
op_member_access_from_pointer
id|write
c_func
(paren
id|port
comma
id|from_user
comma
id|buf
comma
id|count
)paren
suffix:semicolon
r_else
id|retval
op_assign
id|usb_serial_generic_write
c_func
(paren
id|port
comma
id|from_user
comma
id|buf
comma
id|count
)paren
suffix:semicolon
m_exit
suffix:colon
id|up
(paren
op_amp
id|port-&gt;sem
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|serial_write_room
r_static
r_int
id|serial_write_room
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|usb_serial_port
op_star
id|port
op_assign
(paren
r_struct
id|usb_serial_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_struct
id|usb_serial
op_star
id|serial
op_assign
id|get_usb_serial
(paren
id|port
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_int
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|down
(paren
op_amp
id|port-&gt;sem
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s - port %d&quot;
comma
id|__FUNCTION__
comma
id|port-&gt;number
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;open_count
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;%s - port not open&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
multiline_comment|/* pass on to the driver specific version of this function if it is available */
r_if
c_cond
(paren
id|serial-&gt;type-&gt;write_room
)paren
id|retval
op_assign
id|serial-&gt;type
op_member_access_from_pointer
id|write_room
c_func
(paren
id|port
)paren
suffix:semicolon
r_else
id|retval
op_assign
id|generic_write_room
c_func
(paren
id|port
)paren
suffix:semicolon
m_exit
suffix:colon
id|up
(paren
op_amp
id|port-&gt;sem
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|serial_chars_in_buffer
r_static
r_int
id|serial_chars_in_buffer
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|usb_serial_port
op_star
id|port
op_assign
(paren
r_struct
id|usb_serial_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_struct
id|usb_serial
op_star
id|serial
op_assign
id|get_usb_serial
(paren
id|port
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_int
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|down
(paren
op_amp
id|port-&gt;sem
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s = port %d&quot;
comma
id|__FUNCTION__
comma
id|port-&gt;number
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;open_count
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;%s - port not open&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
multiline_comment|/* pass on to the driver specific version of this function if it is available */
r_if
c_cond
(paren
id|serial-&gt;type-&gt;chars_in_buffer
)paren
id|retval
op_assign
id|serial-&gt;type
op_member_access_from_pointer
id|chars_in_buffer
c_func
(paren
id|port
)paren
suffix:semicolon
r_else
id|retval
op_assign
id|generic_chars_in_buffer
c_func
(paren
id|port
)paren
suffix:semicolon
m_exit
suffix:colon
id|up
(paren
op_amp
id|port-&gt;sem
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|serial_throttle
r_static
r_void
id|serial_throttle
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|usb_serial_port
op_star
id|port
op_assign
(paren
r_struct
id|usb_serial_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_struct
id|usb_serial
op_star
id|serial
op_assign
id|get_usb_serial
(paren
id|port
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
r_return
suffix:semicolon
id|down
(paren
op_amp
id|port-&gt;sem
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s - port %d&quot;
comma
id|__FUNCTION__
comma
id|port-&gt;number
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;open_count
)paren
(brace
id|dbg
(paren
l_string|&quot;%s - port not open&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
multiline_comment|/* pass on to the driver specific version of this function */
r_if
c_cond
(paren
id|serial-&gt;type-&gt;throttle
)paren
id|serial-&gt;type
op_member_access_from_pointer
id|throttle
c_func
(paren
id|port
)paren
suffix:semicolon
m_exit
suffix:colon
id|up
(paren
op_amp
id|port-&gt;sem
)paren
suffix:semicolon
)brace
DECL|function|serial_unthrottle
r_static
r_void
id|serial_unthrottle
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|usb_serial_port
op_star
id|port
op_assign
(paren
r_struct
id|usb_serial_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_struct
id|usb_serial
op_star
id|serial
op_assign
id|get_usb_serial
(paren
id|port
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
r_return
suffix:semicolon
id|down
(paren
op_amp
id|port-&gt;sem
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s - port %d&quot;
comma
id|__FUNCTION__
comma
id|port-&gt;number
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;open_count
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;%s - port not open&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
multiline_comment|/* pass on to the driver specific version of this function */
r_if
c_cond
(paren
id|serial-&gt;type-&gt;unthrottle
)paren
id|serial-&gt;type
op_member_access_from_pointer
id|unthrottle
c_func
(paren
id|port
)paren
suffix:semicolon
m_exit
suffix:colon
id|up
(paren
op_amp
id|port-&gt;sem
)paren
suffix:semicolon
)brace
DECL|function|serial_ioctl
r_static
r_int
id|serial_ioctl
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|usb_serial_port
op_star
id|port
op_assign
(paren
r_struct
id|usb_serial_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_struct
id|usb_serial
op_star
id|serial
op_assign
id|get_usb_serial
(paren
id|port
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_int
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|down
(paren
op_amp
id|port-&gt;sem
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s - port %d, cmd 0x%.4x&quot;
comma
id|__FUNCTION__
comma
id|port-&gt;number
comma
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;open_count
)paren
(brace
id|dbg
(paren
l_string|&quot;%s - port not open&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
multiline_comment|/* pass on to the driver specific version of this function if it is available */
r_if
c_cond
(paren
id|serial-&gt;type-&gt;ioctl
)paren
id|retval
op_assign
id|serial-&gt;type
op_member_access_from_pointer
id|ioctl
c_func
(paren
id|port
comma
id|file
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_else
id|retval
op_assign
op_minus
id|ENOIOCTLCMD
suffix:semicolon
m_exit
suffix:colon
id|up
(paren
op_amp
id|port-&gt;sem
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|serial_set_termios
r_static
r_void
id|serial_set_termios
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|termios
op_star
id|old
)paren
(brace
r_struct
id|usb_serial_port
op_star
id|port
op_assign
(paren
r_struct
id|usb_serial_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_struct
id|usb_serial
op_star
id|serial
op_assign
id|get_usb_serial
(paren
id|port
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
r_return
suffix:semicolon
id|down
(paren
op_amp
id|port-&gt;sem
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s - port %d&quot;
comma
id|__FUNCTION__
comma
id|port-&gt;number
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;open_count
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;%s - port not open&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
multiline_comment|/* pass on to the driver specific version of this function if it is available */
r_if
c_cond
(paren
id|serial-&gt;type-&gt;set_termios
)paren
id|serial-&gt;type
op_member_access_from_pointer
id|set_termios
c_func
(paren
id|port
comma
id|old
)paren
suffix:semicolon
m_exit
suffix:colon
id|up
(paren
op_amp
id|port-&gt;sem
)paren
suffix:semicolon
)brace
DECL|function|serial_break
r_static
r_void
id|serial_break
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|break_state
)paren
(brace
r_struct
id|usb_serial_port
op_star
id|port
op_assign
(paren
r_struct
id|usb_serial_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_struct
id|usb_serial
op_star
id|serial
op_assign
id|get_usb_serial
(paren
id|port
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
r_return
suffix:semicolon
id|down
(paren
op_amp
id|port-&gt;sem
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s - port %d&quot;
comma
id|__FUNCTION__
comma
id|port-&gt;number
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;open_count
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;%s - port not open&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
multiline_comment|/* pass on to the driver specific version of this function if it is available */
r_if
c_cond
(paren
id|serial-&gt;type-&gt;break_ctl
)paren
id|serial-&gt;type
op_member_access_from_pointer
id|break_ctl
c_func
(paren
id|port
comma
id|break_state
)paren
suffix:semicolon
m_exit
suffix:colon
id|up
(paren
op_amp
id|port-&gt;sem
)paren
suffix:semicolon
)brace
DECL|function|serial_shutdown
r_static
r_void
id|serial_shutdown
(paren
r_struct
id|usb_serial
op_star
id|serial
)paren
(brace
id|dbg
(paren
l_string|&quot;%s&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serial-&gt;type-&gt;shutdown
)paren
id|serial-&gt;type
op_member_access_from_pointer
id|shutdown
c_func
(paren
id|serial
)paren
suffix:semicolon
r_else
id|generic_shutdown
c_func
(paren
id|serial
)paren
suffix:semicolon
)brace
DECL|function|serial_read_proc
r_static
r_int
id|serial_read_proc
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
suffix:semicolon
r_int
id|length
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
id|off_t
id|begin
op_assign
l_int|0
suffix:semicolon
r_char
id|tmp
(braket
l_int|40
)braket
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|length
op_add_assign
id|sprintf
(paren
id|page
comma
l_string|&quot;usbserinfo:1.0 driver:%s&bslash;n&quot;
comma
id|DRIVER_VERSION
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SERIAL_TTY_MINORS
op_logical_and
id|length
OL
id|PAGE_SIZE
suffix:semicolon
op_increment
id|i
)paren
(brace
id|serial
op_assign
id|usb_serial_get_by_minor
c_func
(paren
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serial
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|length
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|length
comma
l_string|&quot;%d:&quot;
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serial-&gt;type-&gt;owner
)paren
id|length
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|length
comma
l_string|&quot; module:%s&quot;
comma
id|serial-&gt;type-&gt;owner-&gt;name
)paren
suffix:semicolon
id|length
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|length
comma
l_string|&quot; name:&bslash;&quot;%s&bslash;&quot;&quot;
comma
id|serial-&gt;type-&gt;name
)paren
suffix:semicolon
id|length
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|length
comma
l_string|&quot; vendor:%04x product:%04x&quot;
comma
id|serial-&gt;vendor
comma
id|serial-&gt;product
)paren
suffix:semicolon
id|length
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|length
comma
l_string|&quot; num_ports:%d&quot;
comma
id|serial-&gt;num_ports
)paren
suffix:semicolon
id|length
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|length
comma
l_string|&quot; port:%d&quot;
comma
id|i
op_minus
id|serial-&gt;minor
op_plus
l_int|1
)paren
suffix:semicolon
id|usb_make_path
c_func
(paren
id|serial-&gt;dev
comma
id|tmp
comma
r_sizeof
(paren
id|tmp
)paren
)paren
suffix:semicolon
id|length
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|length
comma
l_string|&quot; path:%s&quot;
comma
id|tmp
)paren
suffix:semicolon
id|length
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|length
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|length
op_plus
id|begin
)paren
OG
(paren
id|off
op_plus
id|count
)paren
)paren
r_goto
id|done
suffix:semicolon
r_if
c_cond
(paren
(paren
id|length
op_plus
id|begin
)paren
OL
id|off
)paren
(brace
id|begin
op_add_assign
id|length
suffix:semicolon
id|length
op_assign
l_int|0
suffix:semicolon
)brace
)brace
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
id|done
suffix:colon
r_if
c_cond
(paren
id|off
op_ge
(paren
id|length
op_plus
id|begin
)paren
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|start
op_assign
id|page
op_plus
(paren
id|off
op_minus
id|begin
)paren
suffix:semicolon
r_return
(paren
(paren
id|count
OL
id|begin
op_plus
id|length
op_minus
id|off
)paren
ques
c_cond
id|count
suffix:colon
id|begin
op_plus
id|length
op_minus
id|off
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; * generic devices specific driver functions&n; *****************************************************************************/
DECL|function|usb_serial_generic_open
r_int
id|usb_serial_generic_open
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
id|port-&gt;serial
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|port_paranoia_check
(paren
id|port
comma
id|__FUNCTION__
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s - port %d&quot;
comma
id|__FUNCTION__
comma
id|port-&gt;number
)paren
suffix:semicolon
multiline_comment|/* force low_latency on so that our tty_push actually forces the data through, &n;&t;   otherwise it is scheduled, and with high data rates (like with OHCI) data&n;&t;   can get lost. */
r_if
c_cond
(paren
id|port-&gt;tty
)paren
id|port-&gt;tty-&gt;low_latency
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* if we have a bulk interrupt, start reading from it */
r_if
c_cond
(paren
id|serial-&gt;num_bulk_in
)paren
(brace
multiline_comment|/* Start reading from the device */
id|usb_fill_bulk_urb
(paren
id|port-&gt;read_urb
comma
id|serial-&gt;dev
comma
id|usb_rcvbulkpipe
c_func
(paren
id|serial-&gt;dev
comma
id|port-&gt;bulk_in_endpointAddress
)paren
comma
id|port-&gt;read_urb-&gt;transfer_buffer
comma
id|port-&gt;read_urb-&gt;transfer_buffer_length
comma
(paren
(paren
id|serial-&gt;type-&gt;read_bulk_callback
)paren
ques
c_cond
id|serial-&gt;type-&gt;read_bulk_callback
suffix:colon
id|generic_read_bulk_callback
)paren
comma
id|port
)paren
suffix:semicolon
id|result
op_assign
id|usb_submit_urb
c_func
(paren
id|port-&gt;read_urb
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
id|err
c_func
(paren
l_string|&quot;%s - failed resubmitting read urb, error %d&quot;
comma
id|__FUNCTION__
comma
id|result
)paren
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
DECL|function|generic_cleanup
r_static
r_void
id|generic_cleanup
(paren
r_struct
id|usb_serial_port
op_star
id|port
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
id|port-&gt;serial
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s - port %d&quot;
comma
id|__FUNCTION__
comma
id|port-&gt;number
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serial-&gt;dev
)paren
(brace
multiline_comment|/* shutdown any bulk reads that might be going on */
r_if
c_cond
(paren
id|serial-&gt;num_bulk_out
)paren
id|usb_unlink_urb
(paren
id|port-&gt;write_urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serial-&gt;num_bulk_in
)paren
id|usb_unlink_urb
(paren
id|port-&gt;read_urb
)paren
suffix:semicolon
)brace
)brace
DECL|function|generic_close
r_static
r_void
id|generic_close
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;%s - port %d&quot;
comma
id|__FUNCTION__
comma
id|port-&gt;number
)paren
suffix:semicolon
id|generic_cleanup
(paren
id|port
)paren
suffix:semicolon
)brace
DECL|function|usb_serial_generic_write
r_int
id|usb_serial_generic_write
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
id|port-&gt;serial
suffix:semicolon
r_int
id|result
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s - port %d&quot;
comma
id|__FUNCTION__
comma
id|port-&gt;number
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;%s - write request of 0 bytes&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* only do something if we have a bulk out endpoint */
r_if
c_cond
(paren
id|serial-&gt;num_bulk_out
)paren
(brace
r_if
c_cond
(paren
id|port-&gt;write_urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;%s - already writing&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|count
op_assign
(paren
id|count
OG
id|port-&gt;bulk_out_size
)paren
ques
c_cond
id|port-&gt;bulk_out_size
suffix:colon
id|count
suffix:semicolon
r_if
c_cond
(paren
id|from_user
)paren
(brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|port-&gt;write_urb-&gt;transfer_buffer
comma
id|buf
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_else
(brace
id|memcpy
(paren
id|port-&gt;write_urb-&gt;transfer_buffer
comma
id|buf
comma
id|count
)paren
suffix:semicolon
)brace
id|usb_serial_debug_data
(paren
id|__FILE__
comma
id|__FUNCTION__
comma
id|count
comma
id|port-&gt;write_urb-&gt;transfer_buffer
)paren
suffix:semicolon
multiline_comment|/* set up our urb */
id|usb_fill_bulk_urb
(paren
id|port-&gt;write_urb
comma
id|serial-&gt;dev
comma
id|usb_sndbulkpipe
(paren
id|serial-&gt;dev
comma
id|port-&gt;bulk_out_endpointAddress
)paren
comma
id|port-&gt;write_urb-&gt;transfer_buffer
comma
id|count
comma
(paren
(paren
id|serial-&gt;type-&gt;write_bulk_callback
)paren
ques
c_cond
id|serial-&gt;type-&gt;write_bulk_callback
suffix:colon
id|generic_write_bulk_callback
)paren
comma
id|port
)paren
suffix:semicolon
multiline_comment|/* send the data out the bulk port */
id|result
op_assign
id|usb_submit_urb
c_func
(paren
id|port-&gt;write_urb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
id|err
c_func
(paren
l_string|&quot;%s - failed submitting write urb, error %d&quot;
comma
id|__FUNCTION__
comma
id|result
)paren
suffix:semicolon
r_else
id|result
op_assign
id|count
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/* no bulk out, so return 0 bytes written */
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|generic_write_room
r_static
r_int
id|generic_write_room
(paren
r_struct
id|usb_serial_port
op_star
id|port
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
id|port-&gt;serial
suffix:semicolon
r_int
id|room
op_assign
l_int|0
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s - port %d&quot;
comma
id|__FUNCTION__
comma
id|port-&gt;number
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serial-&gt;num_bulk_out
)paren
(brace
r_if
c_cond
(paren
id|port-&gt;write_urb-&gt;status
op_ne
op_minus
id|EINPROGRESS
)paren
id|room
op_assign
id|port-&gt;bulk_out_size
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;%s - returns %d&quot;
comma
id|__FUNCTION__
comma
id|room
)paren
suffix:semicolon
r_return
(paren
id|room
)paren
suffix:semicolon
)brace
DECL|function|generic_chars_in_buffer
r_static
r_int
id|generic_chars_in_buffer
(paren
r_struct
id|usb_serial_port
op_star
id|port
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
id|port-&gt;serial
suffix:semicolon
r_int
id|chars
op_assign
l_int|0
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s - port %d&quot;
comma
id|__FUNCTION__
comma
id|port-&gt;number
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serial-&gt;num_bulk_out
)paren
(brace
r_if
c_cond
(paren
id|port-&gt;write_urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
id|chars
op_assign
id|port-&gt;write_urb-&gt;transfer_buffer_length
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;%s - returns %d&quot;
comma
id|__FUNCTION__
comma
id|chars
)paren
suffix:semicolon
r_return
(paren
id|chars
)paren
suffix:semicolon
)brace
DECL|function|generic_read_bulk_callback
r_static
r_void
id|generic_read_bulk_callback
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|usb_serial_port
op_star
id|port
op_assign
(paren
r_struct
id|usb_serial_port
op_star
)paren
id|urb-&gt;context
suffix:semicolon
r_struct
id|usb_serial
op_star
id|serial
op_assign
id|get_usb_serial
(paren
id|port
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_int
r_char
op_star
id|data
op_assign
id|urb-&gt;transfer_buffer
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|result
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s - port %d&quot;
comma
id|__FUNCTION__
comma
id|port-&gt;number
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;%s - bad serial pointer, exiting&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|urb-&gt;status
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;%s - nonzero read bulk status received: %d&quot;
comma
id|__FUNCTION__
comma
id|urb-&gt;status
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|usb_serial_debug_data
(paren
id|__FILE__
comma
id|__FUNCTION__
comma
id|urb-&gt;actual_length
comma
id|data
)paren
suffix:semicolon
id|tty
op_assign
id|port-&gt;tty
suffix:semicolon
r_if
c_cond
(paren
id|tty
op_logical_and
id|urb-&gt;actual_length
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|urb-&gt;actual_length
suffix:semicolon
op_increment
id|i
)paren
(brace
multiline_comment|/* if we insert more than TTY_FLIPBUF_SIZE characters, we drop them. */
r_if
c_cond
(paren
id|tty-&gt;flip.count
op_ge
id|TTY_FLIPBUF_SIZE
)paren
(brace
id|tty_flip_buffer_push
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/* this doesn&squot;t actually push the data through unless tty-&gt;low_latency is set */
id|tty_insert_flip_char
c_func
(paren
id|tty
comma
id|data
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
)brace
id|tty_flip_buffer_push
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/* Continue trying to always read  */
id|usb_fill_bulk_urb
(paren
id|port-&gt;read_urb
comma
id|serial-&gt;dev
comma
id|usb_rcvbulkpipe
(paren
id|serial-&gt;dev
comma
id|port-&gt;bulk_in_endpointAddress
)paren
comma
id|port-&gt;read_urb-&gt;transfer_buffer
comma
id|port-&gt;read_urb-&gt;transfer_buffer_length
comma
(paren
(paren
id|serial-&gt;type-&gt;read_bulk_callback
)paren
ques
c_cond
id|serial-&gt;type-&gt;read_bulk_callback
suffix:colon
id|generic_read_bulk_callback
)paren
comma
id|port
)paren
suffix:semicolon
id|result
op_assign
id|usb_submit_urb
c_func
(paren
id|port-&gt;read_urb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
id|err
c_func
(paren
l_string|&quot;%s - failed resubmitting read urb, error %d&quot;
comma
id|__FUNCTION__
comma
id|result
)paren
suffix:semicolon
)brace
DECL|function|generic_write_bulk_callback
r_static
r_void
id|generic_write_bulk_callback
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|usb_serial_port
op_star
id|port
op_assign
(paren
r_struct
id|usb_serial_port
op_star
)paren
id|urb-&gt;context
suffix:semicolon
r_struct
id|usb_serial
op_star
id|serial
op_assign
id|get_usb_serial
(paren
id|port
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s - port %d&quot;
comma
id|__FUNCTION__
comma
id|port-&gt;number
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;%s - bad serial pointer, exiting&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|urb-&gt;status
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;%s - nonzero write bulk status received: %d&quot;
comma
id|__FUNCTION__
comma
id|urb-&gt;status
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|usb_serial_port_softint
c_func
(paren
(paren
r_void
op_star
)paren
id|port
)paren
suffix:semicolon
id|schedule_work
c_func
(paren
op_amp
id|port-&gt;work
)paren
suffix:semicolon
)brace
DECL|function|generic_shutdown
r_static
r_void
id|generic_shutdown
(paren
r_struct
id|usb_serial
op_star
id|serial
)paren
(brace
r_int
id|i
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* stop reads and writes on all ports */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|serial-&gt;num_ports
suffix:semicolon
op_increment
id|i
)paren
(brace
id|generic_cleanup
(paren
op_amp
id|serial-&gt;port
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
DECL|function|usb_serial_port_softint
r_void
id|usb_serial_port_softint
c_func
(paren
r_void
op_star
r_private
)paren
(brace
r_struct
id|usb_serial_port
op_star
id|port
op_assign
(paren
r_struct
id|usb_serial_port
op_star
)paren
r_private
suffix:semicolon
r_struct
id|usb_serial
op_star
id|serial
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s - port %d&quot;
comma
id|__FUNCTION__
comma
id|port-&gt;number
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
)paren
r_return
suffix:semicolon
id|serial
op_assign
id|get_usb_serial
(paren
id|port
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
r_return
suffix:semicolon
id|tty
op_assign
id|port-&gt;tty
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|tty-&gt;ldisc.write_wakeup
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;%s - write wakeup call.&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
(paren
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty
)paren
suffix:semicolon
)brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
)brace
DECL|function|create_serial
r_static
r_struct
id|usb_serial
op_star
id|create_serial
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_struct
id|usb_interface
op_star
id|interface
comma
r_struct
id|usb_serial_device_type
op_star
id|type
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
suffix:semicolon
id|serial
op_assign
id|kmalloc
(paren
r_sizeof
(paren
op_star
id|serial
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
(brace
id|err
(paren
l_string|&quot;%s - out of memory&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
(paren
id|serial
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|serial
)paren
)paren
suffix:semicolon
id|serial-&gt;dev
op_assign
id|dev
suffix:semicolon
id|serial-&gt;type
op_assign
id|type
suffix:semicolon
id|serial-&gt;interface
op_assign
id|interface
suffix:semicolon
id|serial-&gt;vendor
op_assign
id|dev-&gt;descriptor.idVendor
suffix:semicolon
id|serial-&gt;product
op_assign
id|dev-&gt;descriptor.idProduct
suffix:semicolon
r_return
id|serial
suffix:semicolon
)brace
DECL|function|usb_serial_probe
r_int
id|usb_serial_probe
c_func
(paren
r_struct
id|usb_interface
op_star
id|interface
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
(brace
r_struct
id|usb_device
op_star
id|dev
op_assign
id|interface_to_usbdev
(paren
id|interface
)paren
suffix:semicolon
r_struct
id|usb_serial
op_star
id|serial
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|usb_serial_port
op_star
id|port
suffix:semicolon
r_struct
id|usb_host_interface
op_star
id|iface_desc
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|endpoint
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|interrupt_in_endpoint
(braket
id|MAX_NUM_PORTS
)braket
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|bulk_in_endpoint
(braket
id|MAX_NUM_PORTS
)braket
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|bulk_out_endpoint
(braket
id|MAX_NUM_PORTS
)braket
suffix:semicolon
r_struct
id|usb_serial_device_type
op_star
id|type
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_int
id|found
suffix:semicolon
r_int
id|minor
suffix:semicolon
r_int
id|buffer_size
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|num_interrupt_in
op_assign
l_int|0
suffix:semicolon
r_int
id|num_bulk_in
op_assign
l_int|0
suffix:semicolon
r_int
id|num_bulk_out
op_assign
l_int|0
suffix:semicolon
r_int
id|num_ports
op_assign
l_int|0
suffix:semicolon
r_int
id|max_endpoints
suffix:semicolon
r_const
r_struct
id|usb_device_id
op_star
id|id_pattern
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* loop through our list of known serial converters, and see if this&n;&t;   device matches. */
id|found
op_assign
l_int|0
suffix:semicolon
id|list_for_each
(paren
id|tmp
comma
op_amp
id|usb_serial_driver_list
)paren
(brace
id|type
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|usb_serial_device_type
comma
id|driver_list
)paren
suffix:semicolon
id|id_pattern
op_assign
id|usb_match_id
c_func
(paren
id|interface
comma
id|type-&gt;id_table
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id_pattern
op_ne
l_int|NULL
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;descriptor matches&quot;
)paren
suffix:semicolon
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
multiline_comment|/* no match */
id|dbg
c_func
(paren
l_string|&quot;none matched&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|serial
op_assign
id|create_serial
(paren
id|dev
comma
id|interface
comma
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
(brace
id|err
(paren
l_string|&quot;%s - out of memory&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* if this device type has a probe function, call it */
r_if
c_cond
(paren
id|type-&gt;probe
)paren
(brace
r_if
c_cond
(paren
id|type-&gt;owner
)paren
id|__MOD_INC_USE_COUNT
c_func
(paren
id|type-&gt;owner
)paren
suffix:semicolon
id|retval
op_assign
id|type-&gt;probe
(paren
id|serial
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type-&gt;owner
)paren
id|__MOD_DEC_USE_COUNT
c_func
(paren
id|type-&gt;owner
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
(brace
id|dbg
(paren
l_string|&quot;sub driver rejected device&quot;
)paren
suffix:semicolon
id|kfree
(paren
id|serial
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
)brace
multiline_comment|/* descriptor matches, let&squot;s find the endpoints needed */
multiline_comment|/* check out the endpoints */
id|iface_desc
op_assign
op_amp
id|interface-&gt;altsetting
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|iface_desc-&gt;desc.bNumEndpoints
suffix:semicolon
op_increment
id|i
)paren
(brace
id|endpoint
op_assign
op_amp
id|iface_desc-&gt;endpoint
(braket
id|i
)braket
dot
id|desc
suffix:semicolon
r_if
c_cond
(paren
(paren
id|endpoint-&gt;bEndpointAddress
op_amp
l_int|0x80
)paren
op_logical_and
(paren
(paren
id|endpoint-&gt;bmAttributes
op_amp
l_int|3
)paren
op_eq
l_int|0x02
)paren
)paren
(brace
multiline_comment|/* we found a bulk in endpoint */
id|dbg
c_func
(paren
l_string|&quot;found bulk in&quot;
)paren
suffix:semicolon
id|bulk_in_endpoint
(braket
id|num_bulk_in
)braket
op_assign
id|endpoint
suffix:semicolon
op_increment
id|num_bulk_in
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|endpoint-&gt;bEndpointAddress
op_amp
l_int|0x80
)paren
op_eq
l_int|0x00
)paren
op_logical_and
(paren
(paren
id|endpoint-&gt;bmAttributes
op_amp
l_int|3
)paren
op_eq
l_int|0x02
)paren
)paren
(brace
multiline_comment|/* we found a bulk out endpoint */
id|dbg
c_func
(paren
l_string|&quot;found bulk out&quot;
)paren
suffix:semicolon
id|bulk_out_endpoint
(braket
id|num_bulk_out
)braket
op_assign
id|endpoint
suffix:semicolon
op_increment
id|num_bulk_out
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|endpoint-&gt;bEndpointAddress
op_amp
l_int|0x80
)paren
op_logical_and
(paren
(paren
id|endpoint-&gt;bmAttributes
op_amp
l_int|3
)paren
op_eq
l_int|0x03
)paren
)paren
(brace
multiline_comment|/* we found a interrupt in endpoint */
id|dbg
c_func
(paren
l_string|&quot;found interrupt in&quot;
)paren
suffix:semicolon
id|interrupt_in_endpoint
(braket
id|num_interrupt_in
)braket
op_assign
id|endpoint
suffix:semicolon
op_increment
id|num_interrupt_in
suffix:semicolon
)brace
)brace
macro_line|#if defined(CONFIG_USB_SERIAL_PL2303) || defined(CONFIG_USB_SERIAL_PL2303_MODULE)
multiline_comment|/* BEGIN HORRIBLE HACK FOR PL2303 */
multiline_comment|/* this is needed due to the looney way its endpoints are set up */
r_if
c_cond
(paren
(paren
(paren
id|dev-&gt;descriptor.idVendor
op_eq
id|PL2303_VENDOR_ID
)paren
op_logical_and
(paren
id|dev-&gt;descriptor.idProduct
op_eq
id|PL2303_PRODUCT_ID
)paren
)paren
op_logical_or
(paren
(paren
id|dev-&gt;descriptor.idVendor
op_eq
id|ATEN_VENDOR_ID
)paren
op_logical_and
(paren
id|dev-&gt;descriptor.idProduct
op_eq
id|ATEN_PRODUCT_ID
)paren
)paren
)paren
(brace
singleline_comment|//if (ifnum == 1) {
r_if
c_cond
(paren
id|interface
op_ne
op_amp
id|dev-&gt;actconfig-&gt;interface
(braket
l_int|0
)braket
)paren
(brace
multiline_comment|/* check out the endpoints of the other interface*/
singleline_comment|//interface = &amp;dev-&gt;actconfig-&gt;interface[ifnum ^ 1];
id|interface
op_assign
op_amp
id|dev-&gt;actconfig-&gt;interface
(braket
l_int|0
)braket
suffix:semicolon
id|iface_desc
op_assign
op_amp
id|interface-&gt;altsetting
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|iface_desc-&gt;desc.bNumEndpoints
suffix:semicolon
op_increment
id|i
)paren
(brace
id|endpoint
op_assign
op_amp
id|iface_desc-&gt;endpoint
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|endpoint-&gt;bEndpointAddress
op_amp
l_int|0x80
)paren
op_logical_and
(paren
(paren
id|endpoint-&gt;bmAttributes
op_amp
l_int|3
)paren
op_eq
l_int|0x03
)paren
)paren
(brace
multiline_comment|/* we found a interrupt in endpoint */
id|dbg
c_func
(paren
l_string|&quot;found interrupt in for Prolific device on separate interface&quot;
)paren
suffix:semicolon
id|interrupt_in_endpoint
(braket
id|num_interrupt_in
)braket
op_assign
id|endpoint
suffix:semicolon
op_increment
id|num_interrupt_in
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Now make sure the PL-2303 is configured correctly.&n;&t;&t; * If not, give up now and hope this hack will work&n;&t;&t; * properly during a later invocation of usb_serial_probe&n;&t;&t; */
r_if
c_cond
(paren
id|num_bulk_in
op_eq
l_int|0
op_logical_or
id|num_bulk_out
op_eq
l_int|0
)paren
(brace
id|info
c_func
(paren
l_string|&quot;PL-2303 hack: descriptors matched but endpoints did not&quot;
)paren
suffix:semicolon
id|kfree
(paren
id|serial
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
)brace
multiline_comment|/* END HORRIBLE HACK FOR PL2303 */
macro_line|#endif
multiline_comment|/* found all that we need */
id|info
c_func
(paren
l_string|&quot;%s converter detected&quot;
comma
id|type-&gt;name
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_USB_SERIAL_GENERIC
r_if
c_cond
(paren
id|type
op_eq
op_amp
id|generic_device
)paren
(brace
id|num_ports
op_assign
id|num_bulk_out
suffix:semicolon
r_if
c_cond
(paren
id|num_ports
op_eq
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Generic device with no bulk out, not allowed.&quot;
)paren
suffix:semicolon
id|kfree
(paren
id|serial
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|num_ports
)paren
(brace
multiline_comment|/* if this device type has a calc_num_ports function, call it */
r_if
c_cond
(paren
id|type-&gt;calc_num_ports
)paren
(brace
r_if
c_cond
(paren
id|type-&gt;owner
)paren
id|__MOD_INC_USE_COUNT
c_func
(paren
id|type-&gt;owner
)paren
suffix:semicolon
id|num_ports
op_assign
id|type-&gt;calc_num_ports
(paren
id|serial
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type-&gt;owner
)paren
id|__MOD_DEC_USE_COUNT
c_func
(paren
id|type-&gt;owner
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|num_ports
)paren
id|num_ports
op_assign
id|type-&gt;num_ports
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_free_serial
(paren
id|serial
comma
id|num_ports
comma
op_amp
id|minor
)paren
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
l_string|&quot;No more free serial devices&quot;
)paren
suffix:semicolon
id|kfree
(paren
id|serial
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|serial-&gt;minor
op_assign
id|minor
suffix:semicolon
id|serial-&gt;num_ports
op_assign
id|num_ports
suffix:semicolon
id|serial-&gt;num_bulk_in
op_assign
id|num_bulk_in
suffix:semicolon
id|serial-&gt;num_bulk_out
op_assign
id|num_bulk_out
suffix:semicolon
id|serial-&gt;num_interrupt_in
op_assign
id|num_interrupt_in
suffix:semicolon
multiline_comment|/* set up the endpoint information */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_bulk_in
suffix:semicolon
op_increment
id|i
)paren
(brace
id|endpoint
op_assign
id|bulk_in_endpoint
(braket
id|i
)braket
suffix:semicolon
id|port
op_assign
op_amp
id|serial-&gt;port
(braket
id|i
)braket
suffix:semicolon
id|port-&gt;read_urb
op_assign
id|usb_alloc_urb
(paren
l_int|0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;read_urb
)paren
(brace
id|err
c_func
(paren
l_string|&quot;No free urbs available&quot;
)paren
suffix:semicolon
r_goto
id|probe_error
suffix:semicolon
)brace
id|buffer_size
op_assign
id|endpoint-&gt;wMaxPacketSize
suffix:semicolon
id|port-&gt;bulk_in_endpointAddress
op_assign
id|endpoint-&gt;bEndpointAddress
suffix:semicolon
id|port-&gt;bulk_in_buffer
op_assign
id|kmalloc
(paren
id|buffer_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;bulk_in_buffer
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Couldn&squot;t allocate bulk_in_buffer&quot;
)paren
suffix:semicolon
r_goto
id|probe_error
suffix:semicolon
)brace
id|usb_fill_bulk_urb
(paren
id|port-&gt;read_urb
comma
id|dev
comma
id|usb_rcvbulkpipe
(paren
id|dev
comma
id|endpoint-&gt;bEndpointAddress
)paren
comma
id|port-&gt;bulk_in_buffer
comma
id|buffer_size
comma
(paren
(paren
id|serial-&gt;type-&gt;read_bulk_callback
)paren
ques
c_cond
id|serial-&gt;type-&gt;read_bulk_callback
suffix:colon
id|generic_read_bulk_callback
)paren
comma
id|port
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_bulk_out
suffix:semicolon
op_increment
id|i
)paren
(brace
id|endpoint
op_assign
id|bulk_out_endpoint
(braket
id|i
)braket
suffix:semicolon
id|port
op_assign
op_amp
id|serial-&gt;port
(braket
id|i
)braket
suffix:semicolon
id|port-&gt;write_urb
op_assign
id|usb_alloc_urb
c_func
(paren
l_int|0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;write_urb
)paren
(brace
id|err
c_func
(paren
l_string|&quot;No free urbs available&quot;
)paren
suffix:semicolon
r_goto
id|probe_error
suffix:semicolon
)brace
id|buffer_size
op_assign
id|endpoint-&gt;wMaxPacketSize
suffix:semicolon
id|port-&gt;bulk_out_size
op_assign
id|buffer_size
suffix:semicolon
id|port-&gt;bulk_out_endpointAddress
op_assign
id|endpoint-&gt;bEndpointAddress
suffix:semicolon
id|port-&gt;bulk_out_buffer
op_assign
id|kmalloc
(paren
id|buffer_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;bulk_out_buffer
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Couldn&squot;t allocate bulk_out_buffer&quot;
)paren
suffix:semicolon
r_goto
id|probe_error
suffix:semicolon
)brace
id|usb_fill_bulk_urb
(paren
id|port-&gt;write_urb
comma
id|dev
comma
id|usb_sndbulkpipe
(paren
id|dev
comma
id|endpoint-&gt;bEndpointAddress
)paren
comma
id|port-&gt;bulk_out_buffer
comma
id|buffer_size
comma
(paren
(paren
id|serial-&gt;type-&gt;write_bulk_callback
)paren
ques
c_cond
id|serial-&gt;type-&gt;write_bulk_callback
suffix:colon
id|generic_write_bulk_callback
)paren
comma
id|port
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_interrupt_in
suffix:semicolon
op_increment
id|i
)paren
(brace
id|endpoint
op_assign
id|interrupt_in_endpoint
(braket
id|i
)braket
suffix:semicolon
id|port
op_assign
op_amp
id|serial-&gt;port
(braket
id|i
)braket
suffix:semicolon
id|port-&gt;interrupt_in_urb
op_assign
id|usb_alloc_urb
c_func
(paren
l_int|0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;interrupt_in_urb
)paren
(brace
id|err
c_func
(paren
l_string|&quot;No free urbs available&quot;
)paren
suffix:semicolon
r_goto
id|probe_error
suffix:semicolon
)brace
id|buffer_size
op_assign
id|endpoint-&gt;wMaxPacketSize
suffix:semicolon
id|port-&gt;interrupt_in_endpointAddress
op_assign
id|endpoint-&gt;bEndpointAddress
suffix:semicolon
id|port-&gt;interrupt_in_buffer
op_assign
id|kmalloc
(paren
id|buffer_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;interrupt_in_buffer
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Couldn&squot;t allocate interrupt_in_buffer&quot;
)paren
suffix:semicolon
r_goto
id|probe_error
suffix:semicolon
)brace
id|usb_fill_int_urb
(paren
id|port-&gt;interrupt_in_urb
comma
id|dev
comma
id|usb_rcvintpipe
(paren
id|dev
comma
id|endpoint-&gt;bEndpointAddress
)paren
comma
id|port-&gt;interrupt_in_buffer
comma
id|buffer_size
comma
id|serial-&gt;type-&gt;read_int_callback
comma
id|port
comma
id|endpoint-&gt;bInterval
)paren
suffix:semicolon
)brace
multiline_comment|/* initialize some parts of the port structures */
multiline_comment|/* we don&squot;t use num_ports here cauz some devices have more endpoint pairs than ports */
id|max_endpoints
op_assign
id|max
c_func
(paren
id|num_bulk_in
comma
id|num_bulk_out
)paren
suffix:semicolon
id|max_endpoints
op_assign
id|max
c_func
(paren
id|max_endpoints
comma
id|num_interrupt_in
)paren
suffix:semicolon
id|max_endpoints
op_assign
id|max
c_func
(paren
id|max_endpoints
comma
(paren
r_int
)paren
id|serial-&gt;num_ports
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%s - setting up %d port structures for this device&quot;
comma
id|__FUNCTION__
comma
id|max_endpoints
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max_endpoints
suffix:semicolon
op_increment
id|i
)paren
(brace
id|port
op_assign
op_amp
id|serial-&gt;port
(braket
id|i
)braket
suffix:semicolon
id|port-&gt;number
op_assign
id|i
op_plus
id|serial-&gt;minor
suffix:semicolon
id|port-&gt;serial
op_assign
id|serial
suffix:semicolon
id|port-&gt;magic
op_assign
id|USB_SERIAL_PORT_MAGIC
suffix:semicolon
id|INIT_WORK
c_func
(paren
op_amp
id|port-&gt;work
comma
id|usb_serial_port_softint
comma
id|port
)paren
suffix:semicolon
id|init_MUTEX
(paren
op_amp
id|port-&gt;sem
)paren
suffix:semicolon
)brace
multiline_comment|/* if this device type has an attach function, call it */
r_if
c_cond
(paren
id|type-&gt;attach
)paren
(brace
r_if
c_cond
(paren
id|type-&gt;owner
)paren
id|__MOD_INC_USE_COUNT
c_func
(paren
id|type-&gt;owner
)paren
suffix:semicolon
id|retval
op_assign
id|type-&gt;attach
(paren
id|serial
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type-&gt;owner
)paren
id|__MOD_DEC_USE_COUNT
c_func
(paren
id|type-&gt;owner
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_goto
id|probe_error
suffix:semicolon
r_if
c_cond
(paren
id|retval
OG
l_int|0
)paren
(brace
multiline_comment|/* quietly accept this device, but don&squot;t bind to a serial port&n;&t;&t;&t; * as it&squot;s about to disappear */
id|dev_set_drvdata
(paren
op_amp
id|interface-&gt;dev
comma
id|serial
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* initialize the devfs nodes for this device and let the user know what ports we are bound to */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|serial-&gt;num_ports
suffix:semicolon
op_increment
id|i
)paren
(brace
id|tty_register_devfs
(paren
op_amp
id|serial_tty_driver
comma
l_int|0
comma
id|serial-&gt;port
(braket
id|i
)braket
dot
id|number
)paren
suffix:semicolon
id|info
c_func
(paren
l_string|&quot;%s converter now attached to ttyUSB%d (or usb/tts/%d for devfs)&quot;
comma
id|type-&gt;name
comma
id|serial-&gt;port
(braket
id|i
)braket
dot
id|number
comma
id|serial-&gt;port
(braket
id|i
)braket
dot
id|number
)paren
suffix:semicolon
)brace
id|usb_serial_console_init
(paren
id|debug
comma
id|minor
)paren
suffix:semicolon
multiline_comment|/* success */
id|dev_set_drvdata
(paren
op_amp
id|interface-&gt;dev
comma
id|serial
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|probe_error
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_bulk_in
suffix:semicolon
op_increment
id|i
)paren
(brace
id|port
op_assign
op_amp
id|serial-&gt;port
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;read_urb
)paren
id|usb_free_urb
(paren
id|port-&gt;read_urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;bulk_in_buffer
)paren
id|kfree
(paren
id|port-&gt;bulk_in_buffer
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_bulk_out
suffix:semicolon
op_increment
id|i
)paren
(brace
id|port
op_assign
op_amp
id|serial-&gt;port
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;write_urb
)paren
id|usb_free_urb
(paren
id|port-&gt;write_urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;bulk_out_buffer
)paren
id|kfree
(paren
id|port-&gt;bulk_out_buffer
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_interrupt_in
suffix:semicolon
op_increment
id|i
)paren
(brace
id|port
op_assign
op_amp
id|serial-&gt;port
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;interrupt_in_urb
)paren
id|usb_free_urb
(paren
id|port-&gt;interrupt_in_urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;interrupt_in_buffer
)paren
id|kfree
(paren
id|port-&gt;interrupt_in_buffer
)paren
suffix:semicolon
)brace
multiline_comment|/* return the minor range that this device had */
id|return_serial
(paren
id|serial
)paren
suffix:semicolon
multiline_comment|/* free up any memory that we allocated */
id|kfree
(paren
id|serial
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
DECL|function|usb_serial_disconnect
r_void
id|usb_serial_disconnect
c_func
(paren
r_struct
id|usb_interface
op_star
id|interface
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
id|dev_get_drvdata
(paren
op_amp
id|interface-&gt;dev
)paren
suffix:semicolon
r_struct
id|usb_serial_port
op_star
id|port
suffix:semicolon
r_int
id|i
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|dev_set_drvdata
(paren
op_amp
id|interface-&gt;dev
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serial
)paren
(brace
multiline_comment|/* fail all future close/read/write/ioctl/etc calls */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|serial-&gt;num_ports
suffix:semicolon
op_increment
id|i
)paren
(brace
id|port
op_assign
op_amp
id|serial-&gt;port
(braket
id|i
)braket
suffix:semicolon
id|down
(paren
op_amp
id|port-&gt;sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;tty
op_ne
l_int|NULL
)paren
(brace
r_while
c_loop
(paren
id|port-&gt;open_count
OG
l_int|0
)paren
(brace
id|__serial_close
c_func
(paren
id|port
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|port-&gt;tty-&gt;driver_data
op_assign
l_int|NULL
suffix:semicolon
)brace
id|up
(paren
op_amp
id|port-&gt;sem
)paren
suffix:semicolon
)brace
id|serial-&gt;dev
op_assign
l_int|NULL
suffix:semicolon
id|serial_shutdown
(paren
id|serial
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|serial-&gt;num_ports
suffix:semicolon
op_increment
id|i
)paren
id|serial-&gt;port
(braket
id|i
)braket
dot
id|open_count
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|serial-&gt;num_bulk_in
suffix:semicolon
op_increment
id|i
)paren
(brace
id|port
op_assign
op_amp
id|serial-&gt;port
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;read_urb
)paren
(brace
id|usb_unlink_urb
(paren
id|port-&gt;read_urb
)paren
suffix:semicolon
id|usb_free_urb
(paren
id|port-&gt;read_urb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|port-&gt;bulk_in_buffer
)paren
id|kfree
(paren
id|port-&gt;bulk_in_buffer
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|serial-&gt;num_bulk_out
suffix:semicolon
op_increment
id|i
)paren
(brace
id|port
op_assign
op_amp
id|serial-&gt;port
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;write_urb
)paren
(brace
id|usb_unlink_urb
(paren
id|port-&gt;write_urb
)paren
suffix:semicolon
id|usb_free_urb
(paren
id|port-&gt;write_urb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|port-&gt;bulk_out_buffer
)paren
id|kfree
(paren
id|port-&gt;bulk_out_buffer
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|serial-&gt;num_interrupt_in
suffix:semicolon
op_increment
id|i
)paren
(brace
id|port
op_assign
op_amp
id|serial-&gt;port
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;interrupt_in_urb
)paren
(brace
id|usb_unlink_urb
(paren
id|port-&gt;interrupt_in_urb
)paren
suffix:semicolon
id|usb_free_urb
(paren
id|port-&gt;interrupt_in_urb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|port-&gt;interrupt_in_buffer
)paren
id|kfree
(paren
id|port-&gt;interrupt_in_buffer
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|serial-&gt;num_ports
suffix:semicolon
op_increment
id|i
)paren
(brace
id|tty_unregister_devfs
(paren
op_amp
id|serial_tty_driver
comma
id|serial-&gt;port
(braket
id|i
)braket
dot
id|number
)paren
suffix:semicolon
id|info
c_func
(paren
l_string|&quot;%s converter now disconnected from ttyUSB%d&quot;
comma
id|serial-&gt;type-&gt;name
comma
id|serial-&gt;port
(braket
id|i
)braket
dot
id|number
)paren
suffix:semicolon
)brace
multiline_comment|/* return the minor range that this device had */
id|return_serial
(paren
id|serial
)paren
suffix:semicolon
multiline_comment|/* free up any memory that we allocated */
id|kfree
(paren
id|serial
)paren
suffix:semicolon
)brace
id|info
c_func
(paren
l_string|&quot;device disconnected&quot;
)paren
suffix:semicolon
)brace
DECL|variable|serial_tty_driver
r_static
r_struct
id|tty_driver
id|serial_tty_driver
op_assign
(brace
dot
id|magic
op_assign
id|TTY_DRIVER_MAGIC
comma
dot
id|driver_name
op_assign
l_string|&quot;usb-serial&quot;
comma
macro_line|#ifndef CONFIG_DEVFS_FS
dot
id|name
op_assign
l_string|&quot;ttyUSB&quot;
comma
macro_line|#else
dot
id|name
op_assign
l_string|&quot;usb/tts/%d&quot;
comma
macro_line|#endif
dot
id|major
op_assign
id|SERIAL_TTY_MAJOR
comma
dot
id|minor_start
op_assign
l_int|0
comma
dot
id|num
op_assign
id|SERIAL_TTY_MINORS
comma
dot
id|type
op_assign
id|TTY_DRIVER_TYPE_SERIAL
comma
dot
id|subtype
op_assign
id|SERIAL_TYPE_NORMAL
comma
dot
id|flags
op_assign
id|TTY_DRIVER_REAL_RAW
op_or
id|TTY_DRIVER_NO_DEVFS
comma
dot
id|refcount
op_assign
op_amp
id|serial_refcount
comma
dot
id|table
op_assign
id|serial_tty
comma
dot
id|termios
op_assign
id|serial_termios
comma
dot
id|termios_locked
op_assign
id|serial_termios_locked
comma
dot
id|open
op_assign
id|serial_open
comma
dot
id|close
op_assign
id|serial_close
comma
dot
id|write
op_assign
id|serial_write
comma
dot
id|write_room
op_assign
id|serial_write_room
comma
dot
id|ioctl
op_assign
id|serial_ioctl
comma
dot
id|set_termios
op_assign
id|serial_set_termios
comma
dot
id|throttle
op_assign
id|serial_throttle
comma
dot
id|unthrottle
op_assign
id|serial_unthrottle
comma
dot
id|break_ctl
op_assign
id|serial_break
comma
dot
id|chars_in_buffer
op_assign
id|serial_chars_in_buffer
comma
dot
id|read_proc
op_assign
id|serial_read_proc
comma
)brace
suffix:semicolon
DECL|function|usb_serial_init
r_static
r_int
id|__init
id|usb_serial_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|result
suffix:semicolon
multiline_comment|/* Initalize our global data */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SERIAL_TTY_MINORS
suffix:semicolon
op_increment
id|i
)paren
(brace
id|serial_table
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* register the tty driver */
id|serial_tty_driver.init_termios
op_assign
id|tty_std_termios
suffix:semicolon
id|serial_tty_driver.init_termios.c_cflag
op_assign
id|B9600
op_or
id|CS8
op_or
id|CREAD
op_or
id|HUPCL
op_or
id|CLOCAL
suffix:semicolon
r_if
c_cond
(paren
id|tty_register_driver
(paren
op_amp
id|serial_tty_driver
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s - failed to register tty driver&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* register the USB driver */
id|result
op_assign
id|usb_register
c_func
(paren
op_amp
id|usb_serial_driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|tty_unregister_driver
c_func
(paren
op_amp
id|serial_tty_driver
)paren
suffix:semicolon
id|err
c_func
(paren
l_string|&quot;usb_register failed for the usb-serial driver. Error number %d&quot;
comma
id|result
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_USB_SERIAL_GENERIC
id|generic_device_ids
(braket
l_int|0
)braket
dot
id|idVendor
op_assign
id|vendor
suffix:semicolon
id|generic_device_ids
(braket
l_int|0
)braket
dot
id|idProduct
op_assign
id|product
suffix:semicolon
id|generic_device_ids
(braket
l_int|0
)braket
dot
id|match_flags
op_assign
id|USB_DEVICE_ID_MATCH_VENDOR
op_or
id|USB_DEVICE_ID_MATCH_PRODUCT
suffix:semicolon
multiline_comment|/* register our generic driver with ourselves */
id|usb_serial_register
(paren
op_amp
id|generic_device
)paren
suffix:semicolon
macro_line|#endif
id|info
c_func
(paren
id|DRIVER_DESC
l_string|&quot; &quot;
id|DRIVER_VERSION
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usb_serial_exit
r_static
r_void
id|__exit
id|usb_serial_exit
c_func
(paren
r_void
)paren
(brace
id|usb_serial_console_exit
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_USB_SERIAL_GENERIC
multiline_comment|/* remove our generic driver */
id|usb_serial_deregister
(paren
op_amp
id|generic_device
)paren
suffix:semicolon
macro_line|#endif
id|usb_deregister
c_func
(paren
op_amp
id|usb_serial_driver
)paren
suffix:semicolon
id|tty_unregister_driver
c_func
(paren
op_amp
id|serial_tty_driver
)paren
suffix:semicolon
)brace
DECL|variable|usb_serial_init
id|module_init
c_func
(paren
id|usb_serial_init
)paren
suffix:semicolon
DECL|variable|usb_serial_exit
id|module_exit
c_func
(paren
id|usb_serial_exit
)paren
suffix:semicolon
DECL|function|usb_serial_register
r_int
id|usb_serial_register
c_func
(paren
r_struct
id|usb_serial_device_type
op_star
id|new_device
)paren
(brace
multiline_comment|/* Add this device to our list of devices */
id|list_add
c_func
(paren
op_amp
id|new_device-&gt;driver_list
comma
op_amp
id|usb_serial_driver_list
)paren
suffix:semicolon
id|info
(paren
l_string|&quot;USB Serial support registered for %s&quot;
comma
id|new_device-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usb_serial_deregister
r_void
id|usb_serial_deregister
c_func
(paren
r_struct
id|usb_serial_device_type
op_star
id|device
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
suffix:semicolon
r_int
id|i
suffix:semicolon
id|info
c_func
(paren
l_string|&quot;USB Serial deregistering driver %s&quot;
comma
id|device-&gt;name
)paren
suffix:semicolon
multiline_comment|/* clear out the serial_table if the device is attached to a port */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SERIAL_TTY_MINORS
suffix:semicolon
op_increment
id|i
)paren
(brace
id|serial
op_assign
id|serial_table
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|serial
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|serial-&gt;type
op_eq
id|device
)paren
)paren
(brace
id|usb_driver_release_interface
(paren
op_amp
id|usb_serial_driver
comma
id|serial-&gt;interface
)paren
suffix:semicolon
id|usb_serial_disconnect
(paren
id|serial-&gt;interface
)paren
suffix:semicolon
)brace
)brace
id|list_del
c_func
(paren
op_amp
id|device-&gt;driver_list
)paren
suffix:semicolon
)brace
multiline_comment|/* If the usb-serial core is built into the core, the usb-serial drivers&n;   need these symbols to load properly as modules. */
DECL|variable|usb_serial_register
id|EXPORT_SYMBOL
c_func
(paren
id|usb_serial_register
)paren
suffix:semicolon
DECL|variable|usb_serial_deregister
id|EXPORT_SYMBOL
c_func
(paren
id|usb_serial_deregister
)paren
suffix:semicolon
DECL|variable|usb_serial_probe
id|EXPORT_SYMBOL
c_func
(paren
id|usb_serial_probe
)paren
suffix:semicolon
DECL|variable|usb_serial_disconnect
id|EXPORT_SYMBOL
c_func
(paren
id|usb_serial_disconnect
)paren
suffix:semicolon
DECL|variable|usb_serial_port_softint
id|EXPORT_SYMBOL
c_func
(paren
id|usb_serial_port_softint
)paren
suffix:semicolon
macro_line|#ifdef USES_EZUSB_FUNCTIONS
DECL|variable|ezusb_writememory
id|EXPORT_SYMBOL
c_func
(paren
id|ezusb_writememory
)paren
suffix:semicolon
DECL|variable|ezusb_set_reset
id|EXPORT_SYMBOL
c_func
(paren
id|ezusb_set_reset
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Module information */
DECL|variable|DRIVER_AUTHOR
id|MODULE_AUTHOR
c_func
(paren
id|DRIVER_AUTHOR
)paren
suffix:semicolon
DECL|variable|DRIVER_DESC
id|MODULE_DESCRIPTION
c_func
(paren
id|DRIVER_DESC
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|debug
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|debug
comma
l_string|&quot;Debug enabled or not&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_USB_SERIAL_GENERIC
id|MODULE_PARM
c_func
(paren
id|vendor
comma
l_string|&quot;h&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|vendor
comma
l_string|&quot;User specified USB idVendor&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|product
comma
l_string|&quot;h&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|product
comma
l_string|&quot;User specified USB idProduct&quot;
)paren
suffix:semicolon
macro_line|#endif
eof
