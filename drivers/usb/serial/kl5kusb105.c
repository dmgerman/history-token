multiline_comment|/*&n; * KLSI KL5KUSB105 chip RS232 converter driver&n; *&n; *   Copyright (C) 2001 Utz-Uwe Haus &lt;haus@uuhaus.de&gt;&n; *&n; *   This program is free software; you can redistribute it and/or modify&n; *   it under the terms of the GNU General Public License as published by&n; *   the Free Software Foundation; either version 2 of the License, or&n; *   (at your option) any later version.&n; *&n; * All information about the device was acquired using SniffUSB ans snoopUSB&n; * on Windows98.&n; * It was written out of frustration with the PalmConnect USB Serial adapter&n; * sold by Palm Inc.&n; * Neither Palm, nor their contractor (MCCI) or their supplier (KLSI) provided&n; * information that was not already available.&n; *&n; * It seems that KLSI bought some silicon-design information from ScanLogic, &n; * whose SL11R processor is at the core of the KL5KUSB chipset from KLSI.&n; * KLSI has firmware available for their devices; it is probable that the&n; * firmware differs from that used by KLSI in their products. If you have an&n; * original KLSI device and can provide some information on it, I would be &n; * most interested in adding support for it here. If you have any information &n; * on the protocol used (or find errors in my reverse-engineered stuff), please&n; * let me know.&n; *&n; * The code was only tested with a PalmConnect USB adapter; if you&n; * are adventurous, try it with any KLSI-based device and let me know how it&n; * breaks so that I can fix it!&n; */
multiline_comment|/* TODO:&n; *&t;check modem line signals&n; *&t;implement handshaking or decide that we do not support it&n; */
multiline_comment|/* History:&n; *   0.3a - implemented pools of write URBs&n; *   0.3  - alpha version for public testing&n; *   0.2  - TIOCMGET works, so autopilot(1) can be used!&n; *   0.1  - can be used to to pilot-xfer -p /dev/ttyUSB0 -l&n; *&n; *   The driver skeleton is mainly based on mct_u232.c and various other &n; *   pieces of code shamelessly copied from the drivers/usb/serial/ directory.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/tty_driver.h&gt;
macro_line|#include &lt;linux/tty_flip.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/usb.h&gt;
macro_line|#ifdef CONFIG_USB_SERIAL_DEBUG
DECL|variable|debug
r_static
r_int
id|debug
op_assign
l_int|1
suffix:semicolon
macro_line|#else
DECL|variable|debug
r_static
r_int
id|debug
suffix:semicolon
macro_line|#endif
macro_line|#include &quot;usb-serial.h&quot;
macro_line|#include &quot;kl5kusb105.h&quot;
multiline_comment|/*&n; * Version Information&n; */
DECL|macro|DRIVER_VERSION
mdefine_line|#define DRIVER_VERSION &quot;v0.3a&quot;
DECL|macro|DRIVER_AUTHOR
mdefine_line|#define DRIVER_AUTHOR &quot;Utz-Uwe Haus &lt;haus@uuhaus.de&gt;&quot;
DECL|macro|DRIVER_DESC
mdefine_line|#define DRIVER_DESC &quot;KLSI KL5KUSB105 chipset USB-&gt;Serial Converter driver&quot;
multiline_comment|/*&n; * Function prototypes&n; */
r_static
r_int
id|klsi_105_startup
(paren
r_struct
id|usb_serial
op_star
id|serial
)paren
suffix:semicolon
r_static
r_void
id|klsi_105_shutdown
(paren
r_struct
id|usb_serial
op_star
id|serial
)paren
suffix:semicolon
r_static
r_int
id|klsi_105_open
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_void
id|klsi_105_close
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_int
id|klsi_105_write
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
suffix:semicolon
r_static
r_void
id|klsi_105_write_bulk_callback
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
r_static
r_int
id|klsi_105_chars_in_buffer
(paren
r_struct
id|usb_serial_port
op_star
id|port
)paren
suffix:semicolon
r_static
r_int
id|klsi_105_write_room
(paren
r_struct
id|usb_serial_port
op_star
id|port
)paren
suffix:semicolon
r_static
r_void
id|klsi_105_read_bulk_callback
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
r_static
r_void
id|klsi_105_set_termios
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_struct
id|termios
op_star
id|old
)paren
suffix:semicolon
r_static
r_int
id|klsi_105_ioctl
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_void
id|klsi_105_throttle
(paren
r_struct
id|usb_serial_port
op_star
id|port
)paren
suffix:semicolon
r_static
r_void
id|klsi_105_unthrottle
(paren
r_struct
id|usb_serial_port
op_star
id|port
)paren
suffix:semicolon
multiline_comment|/*&n;static void klsi_105_break_ctl&t;         (struct usb_serial_port *port,&n;&t;&t;&t;&t;&t;  int break_state );&n; */
multiline_comment|/*&n; * All of the device info needed for the KLSI converters.&n; */
DECL|variable|id_table
r_static
id|__devinitdata
r_struct
id|usb_device_id
id|id_table
(braket
)braket
op_assign
(brace
(brace
id|USB_DEVICE
c_func
(paren
id|PALMCONNECT_VID
comma
id|PALMCONNECT_PID
)paren
)brace
comma
(brace
id|USB_DEVICE
c_func
(paren
id|KLSI_VID
comma
id|KLSI_KL5KUSB105D_PID
)paren
)brace
comma
(brace
)brace
multiline_comment|/* Terminating entry */
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
(paren
id|usb
comma
id|id_table
)paren
suffix:semicolon
DECL|variable|kl5kusb105d_device
r_static
r_struct
id|usb_serial_device_type
id|kl5kusb105d_device
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|name
suffix:colon
l_string|&quot;KL5KUSB105D / PalmConnect&quot;
comma
id|id_table
suffix:colon
id|id_table
comma
id|num_interrupt_in
suffix:colon
l_int|1
comma
id|num_bulk_in
suffix:colon
l_int|1
comma
id|num_bulk_out
suffix:colon
l_int|1
comma
id|num_ports
suffix:colon
l_int|1
comma
id|open
suffix:colon
id|klsi_105_open
comma
id|close
suffix:colon
id|klsi_105_close
comma
id|write
suffix:colon
id|klsi_105_write
comma
id|write_bulk_callback
suffix:colon
id|klsi_105_write_bulk_callback
comma
id|chars_in_buffer
suffix:colon
id|klsi_105_chars_in_buffer
comma
id|write_room
suffix:colon
id|klsi_105_write_room
comma
id|read_bulk_callback
suffix:colon
id|klsi_105_read_bulk_callback
comma
id|ioctl
suffix:colon
id|klsi_105_ioctl
comma
id|set_termios
suffix:colon
id|klsi_105_set_termios
comma
multiline_comment|/*break_ctl:&t;     klsi_105_break_ctl,*/
id|startup
suffix:colon
id|klsi_105_startup
comma
id|shutdown
suffix:colon
id|klsi_105_shutdown
comma
id|throttle
suffix:colon
id|klsi_105_throttle
comma
id|unthrottle
suffix:colon
id|klsi_105_unthrottle
comma
)brace
suffix:semicolon
DECL|struct|klsi_105_port_settings
r_struct
id|klsi_105_port_settings
(brace
DECL|member|pktlen
id|__u8
id|pktlen
suffix:semicolon
multiline_comment|/* always 5, it seems */
DECL|member|baudrate
id|__u8
id|baudrate
suffix:semicolon
DECL|member|databits
id|__u8
id|databits
suffix:semicolon
DECL|member|unknown1
id|__u8
id|unknown1
suffix:semicolon
DECL|member|unknown2
id|__u8
id|unknown2
suffix:semicolon
)brace
id|__attribute__
(paren
(paren
id|packed
)paren
)paren
suffix:semicolon
multiline_comment|/* we implement a pool of NUM_URBS urbs per usb_serial */
DECL|macro|NUM_URBS
mdefine_line|#define NUM_URBS&t;&t;&t;1
DECL|macro|URB_TRANSFER_BUFFER_SIZE
mdefine_line|#define URB_TRANSFER_BUFFER_SIZE&t;64
DECL|struct|klsi_105_private
r_struct
id|klsi_105_private
(brace
DECL|member|cfg
r_struct
id|klsi_105_port_settings
id|cfg
suffix:semicolon
DECL|member|termios
r_struct
id|termios
id|termios
suffix:semicolon
DECL|member|line_state
r_int
r_int
id|line_state
suffix:semicolon
multiline_comment|/* modem line settings */
multiline_comment|/* write pool */
DECL|member|write_urb_pool
r_struct
id|urb
op_star
id|write_urb_pool
(braket
id|NUM_URBS
)braket
suffix:semicolon
DECL|member|write_urb_pool_lock
id|spinlock_t
id|write_urb_pool_lock
suffix:semicolon
DECL|member|bytes_in
r_int
r_int
id|bytes_in
suffix:semicolon
DECL|member|bytes_out
r_int
r_int
id|bytes_out
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Handle vendor specific USB requests&n; */
DECL|macro|KLSI_TIMEOUT
mdefine_line|#define KLSI_TIMEOUT&t; (HZ * 5 ) /* default urb timeout */
DECL|function|klsi_105_chg_port_settings
r_static
r_int
id|klsi_105_chg_port_settings
c_func
(paren
r_struct
id|usb_serial
op_star
id|serial
comma
r_struct
id|klsi_105_port_settings
op_star
id|settings
)paren
(brace
r_int
id|rc
suffix:semicolon
id|rc
op_assign
id|usb_control_msg
c_func
(paren
id|serial-&gt;dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
id|KL5KUSB105A_SIO_SET_DATA
comma
id|USB_TYPE_VENDOR
op_or
id|USB_DIR_OUT
op_or
id|USB_RECIP_INTERFACE
comma
l_int|0
comma
multiline_comment|/* value */
l_int|0
comma
multiline_comment|/* index */
id|settings
comma
r_sizeof
(paren
r_struct
id|klsi_105_port_settings
)paren
comma
id|KLSI_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
id|err
c_func
(paren
l_string|&quot;Change port settings failed (error = %d)&quot;
comma
id|rc
)paren
suffix:semicolon
id|info
c_func
(paren
id|__FUNCTION__
l_string|&quot; - %d byte block, baudrate %x, databits %d, u1 %d, u2 %d&quot;
comma
id|settings-&gt;pktlen
comma
id|settings-&gt;baudrate
comma
id|settings-&gt;databits
comma
id|settings-&gt;unknown1
comma
id|settings-&gt;unknown2
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* klsi_105_chg_port_settings */
multiline_comment|/* translate a 16-bit status value from the device to linux&squot;s TIO bits */
DECL|function|klsi_105_status2linestate
r_static
r_int
r_int
id|klsi_105_status2linestate
c_func
(paren
r_const
id|__u16
id|status
)paren
(brace
r_int
r_int
id|res
op_assign
l_int|0
suffix:semicolon
id|res
op_assign
(paren
(paren
id|status
op_amp
id|KL5KUSB105A_DSR
)paren
ques
c_cond
id|TIOCM_DSR
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|status
op_amp
id|KL5KUSB105A_CTS
)paren
ques
c_cond
id|TIOCM_CTS
suffix:colon
l_int|0
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/* &n; * Read line control via vendor command and return result through&n; * *line_state_p &n; */
multiline_comment|/* It seems that the status buffer has always only 2 bytes length */
DECL|macro|KLSI_STATUSBUF_LEN
mdefine_line|#define KLSI_STATUSBUF_LEN&t;2
DECL|function|klsi_105_get_line_state
r_static
r_int
id|klsi_105_get_line_state
c_func
(paren
r_struct
id|usb_serial
op_star
id|serial
comma
r_int
r_int
op_star
id|line_state_p
)paren
(brace
r_int
id|rc
suffix:semicolon
id|__u8
id|status_buf
(braket
id|KLSI_STATUSBUF_LEN
)braket
op_assign
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
suffix:semicolon
id|__u16
id|status
suffix:semicolon
id|info
c_func
(paren
id|__FUNCTION__
l_string|&quot; - sending SIO Poll request&quot;
)paren
suffix:semicolon
id|rc
op_assign
id|usb_control_msg
c_func
(paren
id|serial-&gt;dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
id|KL5KUSB105A_SIO_POLL
comma
id|USB_TYPE_VENDOR
op_or
id|USB_DIR_IN
comma
l_int|0
comma
multiline_comment|/* value */
l_int|0
comma
multiline_comment|/* index */
id|status_buf
comma
id|KLSI_STATUSBUF_LEN
comma
l_int|10
op_star
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
id|err
c_func
(paren
l_string|&quot;Reading line status failed (error = %d)&quot;
comma
id|rc
)paren
suffix:semicolon
r_else
(brace
id|status
op_assign
id|status_buf
(braket
l_int|0
)braket
op_plus
(paren
id|status_buf
(braket
l_int|1
)braket
op_lshift
l_int|8
)paren
suffix:semicolon
id|info
c_func
(paren
id|__FUNCTION__
l_string|&quot; - read status %x %x&quot;
comma
id|status_buf
(braket
l_int|0
)braket
comma
id|status_buf
(braket
l_int|1
)braket
)paren
suffix:semicolon
op_star
id|line_state_p
op_assign
id|klsi_105_status2linestate
c_func
(paren
id|status
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Driver&squot;s tty interface functions&n; */
DECL|function|klsi_105_startup
r_static
r_int
id|klsi_105_startup
(paren
r_struct
id|usb_serial
op_star
id|serial
)paren
(brace
r_struct
id|klsi_105_private
op_star
id|priv
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* check if we support the product id (see keyspan.c)&n;&t; * FIXME&n;&t; */
multiline_comment|/* allocate the private data structure */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|serial-&gt;num_ports
suffix:semicolon
id|i
op_increment
)paren
(brace
id|serial-&gt;port
(braket
id|i
)braket
dot
r_private
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|klsi_105_private
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|serial-&gt;port
(braket
id|i
)braket
dot
r_private
)paren
(brace
id|dbg
c_func
(paren
id|__FUNCTION__
l_string|&quot;kmalloc for klsi_105_private failed.&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* error */
)brace
id|priv
op_assign
(paren
r_struct
id|klsi_105_private
op_star
)paren
id|serial-&gt;port
(braket
id|i
)braket
dot
r_private
suffix:semicolon
multiline_comment|/* set initial values for control structures */
id|priv-&gt;cfg.pktlen
op_assign
l_int|5
suffix:semicolon
id|priv-&gt;cfg.baudrate
op_assign
id|kl5kusb105a_sio_b9600
suffix:semicolon
id|priv-&gt;cfg.databits
op_assign
id|kl5kusb105a_dtb_8
suffix:semicolon
id|priv-&gt;cfg.unknown1
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;cfg.unknown2
op_assign
l_int|1
suffix:semicolon
id|priv-&gt;line_state
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;bytes_in
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;bytes_out
op_assign
l_int|0
suffix:semicolon
id|spin_lock_init
(paren
op_amp
id|priv-&gt;write_urb_pool_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_URBS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|urb
op_star
id|urb
op_assign
id|usb_alloc_urb
c_func
(paren
l_int|0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|priv-&gt;write_urb_pool
(braket
id|i
)braket
op_assign
id|urb
suffix:semicolon
r_if
c_cond
(paren
id|urb
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
l_string|&quot;No more urbs???&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|urb-&gt;transfer_buffer
op_assign
l_int|NULL
suffix:semicolon
id|urb-&gt;transfer_buffer
op_assign
id|kmalloc
(paren
id|URB_TRANSFER_BUFFER_SIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb-&gt;transfer_buffer
)paren
(brace
id|err
(paren
id|__FUNCTION__
l_string|&quot; - out of memory for urb buffers.&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
multiline_comment|/* priv-&gt;termios is left uninitalized until port opening */
id|init_waitqueue_head
c_func
(paren
op_amp
id|serial-&gt;port
(braket
id|i
)braket
dot
id|write_wait
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* klsi_105_startup */
DECL|function|klsi_105_shutdown
r_static
r_void
id|klsi_105_shutdown
(paren
r_struct
id|usb_serial
op_star
id|serial
)paren
(brace
r_int
id|i
suffix:semicolon
id|dbg
(paren
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/* stop reads and writes on all ports */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|serial-&gt;num_ports
suffix:semicolon
op_increment
id|i
)paren
(brace
r_struct
id|klsi_105_private
op_star
id|priv
op_assign
(paren
r_struct
id|klsi_105_private
op_star
)paren
id|serial-&gt;port
(braket
id|i
)braket
dot
r_private
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|priv
)paren
(brace
multiline_comment|/* kill our write urb pool */
r_int
id|j
suffix:semicolon
r_struct
id|urb
op_star
op_star
id|write_urbs
op_assign
id|priv-&gt;write_urb_pool
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|priv-&gt;write_urb_pool_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|NUM_URBS
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|write_urbs
(braket
id|j
)braket
)paren
(brace
multiline_comment|/* FIXME - uncomment the following&n;&t;&t;&t;&t;&t; * usb_unlink_urb call when the host&n;&t;&t;&t;&t;&t; * controllers get fixed to set&n;&t;&t;&t;&t;&t; * urb-&gt;dev = NULL after the urb is&n;&t;&t;&t;&t;&t; * finished.  Otherwise this call&n;&t;&t;&t;&t;&t; * oopses. */
multiline_comment|/* usb_unlink_urb(write_urbs[j]); */
r_if
c_cond
(paren
id|write_urbs
(braket
id|j
)braket
op_member_access_from_pointer
id|transfer_buffer
)paren
id|kfree
c_func
(paren
id|write_urbs
(braket
id|j
)braket
op_member_access_from_pointer
id|transfer_buffer
)paren
suffix:semicolon
id|usb_free_urb
(paren
id|write_urbs
(braket
id|j
)braket
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|priv-&gt;write_urb_pool_lock
comma
id|flags
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|serial-&gt;port
(braket
id|i
)braket
dot
r_private
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* klsi_105_shutdown */
DECL|function|klsi_105_open
r_static
r_int
id|klsi_105_open
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
id|port-&gt;serial
suffix:semicolon
r_struct
id|klsi_105_private
op_star
id|priv
op_assign
(paren
r_struct
id|klsi_105_private
op_star
)paren
id|port
op_member_access_from_pointer
r_private
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|line_state
suffix:semicolon
id|dbg
c_func
(paren
id|__FUNCTION__
l_string|&quot; port %d&quot;
comma
id|port-&gt;number
)paren
suffix:semicolon
multiline_comment|/* force low_latency on so that our tty_push actually forces&n;&t; * the data through&n;&t; * port-&gt;tty-&gt;low_latency = 1; */
multiline_comment|/* Do a defined restart:&n;&t; * Set up sane default baud rate and send the &squot;READ_ON&squot;&n;&t; * vendor command. &n;&t; * FIXME: set modem line control (how?)&n;&t; * Then read the modem line control and store values in&n;&t; * priv-&gt;line_state.&n;&t; */
id|priv-&gt;cfg.pktlen
op_assign
l_int|5
suffix:semicolon
id|priv-&gt;cfg.baudrate
op_assign
id|kl5kusb105a_sio_b9600
suffix:semicolon
id|priv-&gt;cfg.databits
op_assign
id|kl5kusb105a_dtb_8
suffix:semicolon
id|priv-&gt;cfg.unknown1
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;cfg.unknown2
op_assign
l_int|1
suffix:semicolon
id|klsi_105_chg_port_settings
c_func
(paren
id|serial
comma
op_amp
(paren
id|priv-&gt;cfg
)paren
)paren
suffix:semicolon
multiline_comment|/* set up termios structure */
id|priv-&gt;termios.c_iflag
op_assign
id|port-&gt;tty-&gt;termios-&gt;c_iflag
suffix:semicolon
id|priv-&gt;termios.c_oflag
op_assign
id|port-&gt;tty-&gt;termios-&gt;c_oflag
suffix:semicolon
id|priv-&gt;termios.c_cflag
op_assign
id|port-&gt;tty-&gt;termios-&gt;c_cflag
suffix:semicolon
id|priv-&gt;termios.c_lflag
op_assign
id|port-&gt;tty-&gt;termios-&gt;c_lflag
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NCCS
suffix:semicolon
id|i
op_increment
)paren
id|priv-&gt;termios.c_cc
(braket
id|i
)braket
op_assign
id|port-&gt;tty-&gt;termios-&gt;c_cc
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* READ_ON and urb submission */
id|FILL_BULK_URB
c_func
(paren
id|port-&gt;read_urb
comma
id|serial-&gt;dev
comma
id|usb_rcvbulkpipe
c_func
(paren
id|serial-&gt;dev
comma
id|port-&gt;bulk_in_endpointAddress
)paren
comma
id|port-&gt;read_urb-&gt;transfer_buffer
comma
id|port-&gt;read_urb-&gt;transfer_buffer_length
comma
id|klsi_105_read_bulk_callback
comma
id|port
)paren
suffix:semicolon
id|port-&gt;read_urb-&gt;transfer_flags
op_or_assign
id|USB_QUEUE_BULK
suffix:semicolon
id|rc
op_assign
id|usb_submit_urb
c_func
(paren
id|port-&gt;read_urb
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|err
c_func
(paren
id|__FUNCTION__
l_string|&quot; - failed submitting read urb, error %d&quot;
comma
id|rc
)paren
suffix:semicolon
id|retval
op_assign
id|rc
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
id|rc
op_assign
id|usb_control_msg
c_func
(paren
id|serial-&gt;dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
id|KL5KUSB105A_SIO_CONFIGURE
comma
id|USB_TYPE_VENDOR
op_or
id|USB_DIR_OUT
op_or
id|USB_RECIP_INTERFACE
comma
id|KL5KUSB105A_SIO_CONFIGURE_READ_ON
comma
l_int|0
comma
multiline_comment|/* index */
l_int|NULL
comma
l_int|0
comma
id|KLSI_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Enabling read failed (error = %d)&quot;
comma
id|rc
)paren
suffix:semicolon
id|retval
op_assign
id|rc
suffix:semicolon
)brace
r_else
id|dbg
c_func
(paren
id|__FUNCTION__
l_string|&quot; - enabled reading&quot;
)paren
suffix:semicolon
id|rc
op_assign
id|klsi_105_get_line_state
c_func
(paren
id|serial
comma
op_amp
id|line_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ge
l_int|0
)paren
(brace
id|priv-&gt;line_state
op_assign
id|line_state
suffix:semicolon
id|dbg
c_func
(paren
id|__FUNCTION__
l_string|&quot; - read line state 0x%lx&quot;
comma
id|line_state
)paren
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|retval
op_assign
id|rc
suffix:semicolon
m_exit
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* klsi_105_open */
DECL|function|klsi_105_close
r_static
r_void
id|klsi_105_close
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
suffix:semicolon
r_struct
id|klsi_105_private
op_star
id|priv
op_assign
(paren
r_struct
id|klsi_105_private
op_star
)paren
id|port
op_member_access_from_pointer
r_private
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|dbg
c_func
(paren
id|__FUNCTION__
l_string|&quot; port %d&quot;
comma
id|port-&gt;number
)paren
suffix:semicolon
id|serial
op_assign
id|get_usb_serial
(paren
id|port
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* send READ_OFF */
id|rc
op_assign
id|usb_control_msg
(paren
id|serial-&gt;dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|serial-&gt;dev
comma
l_int|0
)paren
comma
id|KL5KUSB105A_SIO_CONFIGURE
comma
id|USB_TYPE_VENDOR
op_or
id|USB_DIR_OUT
comma
id|KL5KUSB105A_SIO_CONFIGURE_READ_OFF
comma
l_int|0
comma
multiline_comment|/* index */
l_int|NULL
comma
l_int|0
comma
id|KLSI_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
id|err
c_func
(paren
l_string|&quot;Disabling read failed (error = %d)&quot;
comma
id|rc
)paren
suffix:semicolon
multiline_comment|/* shutdown our bulk reads and writes */
id|usb_unlink_urb
(paren
id|port-&gt;write_urb
)paren
suffix:semicolon
id|usb_unlink_urb
(paren
id|port-&gt;read_urb
)paren
suffix:semicolon
multiline_comment|/* unlink our write pool */
multiline_comment|/* FIXME */
multiline_comment|/* wgg - do I need this? I think so. */
id|usb_unlink_urb
(paren
id|port-&gt;interrupt_in_urb
)paren
suffix:semicolon
id|info
c_func
(paren
l_string|&quot;kl5kusb105 port stats: %ld bytes in, %ld bytes out&quot;
comma
id|priv-&gt;bytes_in
comma
id|priv-&gt;bytes_out
)paren
suffix:semicolon
)brace
multiline_comment|/* klsi_105_close */
multiline_comment|/* We need to write a complete 64-byte data block and encode the&n; * number actually sent in the first double-byte, LSB-order. That &n; * leaves at most 62 bytes of payload.&n; */
DECL|macro|KLSI_105_DATA_OFFSET
mdefine_line|#define KLSI_105_DATA_OFFSET&t;2   /* in the bulk urb data block */
DECL|function|klsi_105_write
r_static
r_int
id|klsi_105_write
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
id|port-&gt;serial
suffix:semicolon
r_struct
id|klsi_105_private
op_star
id|priv
op_assign
(paren
r_struct
id|klsi_105_private
op_star
)paren
id|port
op_member_access_from_pointer
r_private
suffix:semicolon
r_int
id|result
comma
id|size
suffix:semicolon
r_int
id|bytes_sent
op_assign
l_int|0
suffix:semicolon
id|dbg
c_func
(paren
id|__FUNCTION__
l_string|&quot; - port %d&quot;
comma
id|port-&gt;number
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
multiline_comment|/* try to find a free urb (write 0 bytes if none) */
r_struct
id|urb
op_star
id|urb
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* since the pool is per-port we might not need the spin lock !? */
id|spin_lock_irqsave
(paren
op_amp
id|priv-&gt;write_urb_pool_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_URBS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|priv-&gt;write_urb_pool
(braket
id|i
)braket
op_member_access_from_pointer
id|status
op_ne
op_minus
id|EINPROGRESS
)paren
(brace
id|urb
op_assign
id|priv-&gt;write_urb_pool
(braket
id|i
)braket
suffix:semicolon
id|dbg
c_func
(paren
id|__FUNCTION__
l_string|&quot; - using pool URB %d&quot;
comma
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|priv-&gt;write_urb_pool_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb
op_eq
l_int|NULL
)paren
(brace
id|dbg
(paren
id|__FUNCTION__
l_string|&quot; - no more free urbs&quot;
)paren
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
r_if
c_cond
(paren
id|urb-&gt;transfer_buffer
op_eq
l_int|NULL
)paren
(brace
id|urb-&gt;transfer_buffer
op_assign
id|kmalloc
(paren
id|URB_TRANSFER_BUFFER_SIZE
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;transfer_buffer
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
id|__FUNCTION__
l_string|&quot; - no more kernel memory...&quot;
)paren
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
)brace
id|size
op_assign
id|min
(paren
id|count
comma
id|port-&gt;bulk_out_size
op_minus
id|KLSI_105_DATA_OFFSET
)paren
suffix:semicolon
id|size
op_assign
id|min
(paren
id|size
comma
id|URB_TRANSFER_BUFFER_SIZE
op_minus
id|KLSI_105_DATA_OFFSET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|from_user
)paren
(brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|urb-&gt;transfer_buffer
op_plus
id|KLSI_105_DATA_OFFSET
comma
id|buf
comma
id|size
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
r_else
(brace
id|memcpy
(paren
id|urb-&gt;transfer_buffer
op_plus
id|KLSI_105_DATA_OFFSET
comma
id|buf
comma
id|size
)paren
suffix:semicolon
)brace
multiline_comment|/* write payload size into transfer buffer */
(paren
(paren
id|__u8
op_star
)paren
id|urb-&gt;transfer_buffer
)paren
(braket
l_int|0
)braket
op_assign
(paren
id|__u8
)paren
(paren
id|size
op_amp
l_int|0xFF
)paren
suffix:semicolon
(paren
(paren
id|__u8
op_star
)paren
id|urb-&gt;transfer_buffer
)paren
(braket
l_int|1
)braket
op_assign
(paren
id|__u8
)paren
(paren
(paren
id|size
op_amp
l_int|0xFF00
)paren
op_rshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/* set up our urb */
id|FILL_BULK_URB
c_func
(paren
id|urb
comma
id|serial-&gt;dev
comma
id|usb_sndbulkpipe
c_func
(paren
id|serial-&gt;dev
comma
id|port-&gt;bulk_out_endpointAddress
)paren
comma
id|urb-&gt;transfer_buffer
comma
id|URB_TRANSFER_BUFFER_SIZE
comma
id|klsi_105_write_bulk_callback
comma
id|port
)paren
suffix:semicolon
id|urb-&gt;transfer_flags
op_or_assign
id|USB_QUEUE_BULK
suffix:semicolon
multiline_comment|/* send the data out the bulk port */
id|result
op_assign
id|usb_submit_urb
c_func
(paren
id|urb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
id|err
c_func
(paren
id|__FUNCTION__
l_string|&quot; - failed submitting write urb, error %d&quot;
comma
id|result
)paren
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
id|buf
op_add_assign
id|size
suffix:semicolon
id|bytes_sent
op_add_assign
id|size
suffix:semicolon
id|count
op_sub_assign
id|size
suffix:semicolon
)brace
m_exit
suffix:colon
id|priv-&gt;bytes_out
op_add_assign
id|bytes_sent
suffix:semicolon
r_return
id|bytes_sent
suffix:semicolon
multiline_comment|/* that&squot;s how much we wrote */
)brace
multiline_comment|/* klsi_105_write */
DECL|function|klsi_105_write_bulk_callback
r_static
r_void
id|klsi_105_write_bulk_callback
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|usb_serial_port
op_star
id|port
op_assign
(paren
r_struct
id|usb_serial_port
op_star
)paren
id|urb-&gt;context
suffix:semicolon
r_struct
id|usb_serial
op_star
id|serial
op_assign
id|port-&gt;serial
suffix:semicolon
id|dbg
c_func
(paren
id|__FUNCTION__
l_string|&quot; - port %d&quot;
comma
id|port-&gt;number
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
(brace
id|dbg
c_func
(paren
id|__FUNCTION__
l_string|&quot; - bad serial pointer, exiting&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|urb-&gt;status
)paren
(brace
id|dbg
c_func
(paren
id|__FUNCTION__
l_string|&quot; - nonzero write bulk status received: %d&quot;
comma
id|urb-&gt;status
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* from generic_write_bulk_callback */
id|queue_task
c_func
(paren
op_amp
id|port-&gt;tqueue
comma
op_amp
id|tq_immediate
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|IMMEDIATE_BH
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* klsi_105_write_bulk_completion_callback */
multiline_comment|/* return number of characters currently in the writing process */
DECL|function|klsi_105_chars_in_buffer
r_static
r_int
id|klsi_105_chars_in_buffer
(paren
r_struct
id|usb_serial_port
op_star
id|port
)paren
(brace
r_int
id|chars
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|klsi_105_private
op_star
id|priv
op_assign
(paren
r_struct
id|klsi_105_private
op_star
)paren
id|port
op_member_access_from_pointer
r_private
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|priv-&gt;write_urb_pool_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_URBS
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|priv-&gt;write_urb_pool
(braket
id|i
)braket
op_member_access_from_pointer
id|status
op_eq
op_minus
id|EINPROGRESS
)paren
(brace
id|chars
op_add_assign
id|URB_TRANSFER_BUFFER_SIZE
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|priv-&gt;write_urb_pool_lock
comma
id|flags
)paren
suffix:semicolon
id|dbg
(paren
id|__FUNCTION__
l_string|&quot; - returns %d&quot;
comma
id|chars
)paren
suffix:semicolon
r_return
(paren
id|chars
)paren
suffix:semicolon
)brace
DECL|function|klsi_105_write_room
r_static
r_int
id|klsi_105_write_room
(paren
r_struct
id|usb_serial_port
op_star
id|port
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|room
op_assign
l_int|0
suffix:semicolon
r_struct
id|klsi_105_private
op_star
id|priv
op_assign
(paren
r_struct
id|klsi_105_private
op_star
)paren
id|port
op_member_access_from_pointer
r_private
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|priv-&gt;write_urb_pool_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_URBS
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|priv-&gt;write_urb_pool
(braket
id|i
)braket
op_member_access_from_pointer
id|status
op_ne
op_minus
id|EINPROGRESS
)paren
(brace
id|room
op_add_assign
id|URB_TRANSFER_BUFFER_SIZE
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|priv-&gt;write_urb_pool_lock
comma
id|flags
)paren
suffix:semicolon
id|dbg
c_func
(paren
id|__FUNCTION__
l_string|&quot; - returns %d&quot;
comma
id|room
)paren
suffix:semicolon
r_return
(paren
id|room
)paren
suffix:semicolon
)brace
DECL|function|klsi_105_read_bulk_callback
r_static
r_void
id|klsi_105_read_bulk_callback
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|usb_serial_port
op_star
id|port
op_assign
(paren
r_struct
id|usb_serial_port
op_star
)paren
id|urb-&gt;context
suffix:semicolon
r_struct
id|usb_serial
op_star
id|serial
op_assign
id|port-&gt;serial
suffix:semicolon
r_struct
id|klsi_105_private
op_star
id|priv
op_assign
(paren
r_struct
id|klsi_105_private
op_star
)paren
id|port
op_member_access_from_pointer
r_private
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_int
r_char
op_star
id|data
op_assign
id|urb-&gt;transfer_buffer
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|dbg
c_func
(paren
id|__FUNCTION__
l_string|&quot; - port %d&quot;
comma
id|port-&gt;number
)paren
suffix:semicolon
multiline_comment|/* The urb might have been killed. */
r_if
c_cond
(paren
id|urb-&gt;status
)paren
(brace
id|dbg
c_func
(paren
id|__FUNCTION__
l_string|&quot; - nonzero read bulk status received: %d&quot;
comma
id|urb-&gt;status
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|serial
)paren
(brace
id|dbg
c_func
(paren
id|__FUNCTION__
l_string|&quot; - bad serial pointer, exiting&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* The data received is again preceded by a length double-byte in LSB-&n;&t; * first order (see klsi_105_write() )&n;&t; */
r_if
c_cond
(paren
id|urb-&gt;actual_length
op_eq
l_int|0
)paren
(brace
multiline_comment|/* empty urbs seem to happen, we ignore them */
multiline_comment|/* dbg(__FUNCTION__ &quot; - emtpy URB&quot;); */
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|urb-&gt;actual_length
op_le
l_int|2
)paren
(brace
id|dbg
c_func
(paren
id|__FUNCTION__
l_string|&quot; - size %d URB not understood&quot;
comma
id|urb-&gt;actual_length
)paren
suffix:semicolon
id|usb_serial_debug_data
(paren
id|__FILE__
comma
id|__FUNCTION__
comma
id|urb-&gt;actual_length
comma
id|data
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|i
suffix:semicolon
r_int
id|bytes_sent
op_assign
(paren
(paren
id|__u8
op_star
)paren
id|data
)paren
(braket
l_int|0
)braket
op_plus
(paren
(paren
r_int
r_int
)paren
(paren
(paren
id|__u8
op_star
)paren
id|data
)paren
(braket
l_int|1
)braket
op_lshift
l_int|8
)paren
suffix:semicolon
id|tty
op_assign
id|port-&gt;tty
suffix:semicolon
multiline_comment|/* we should immediately resubmit the URB, before attempting&n;&t;&t; * to pass the data on to the tty layer. But that needs locking&n;&t;&t; * against re-entry an then mixed-up data because of&n;&t;&t; * intermixed tty_flip_buffer_push()s&n;&t;&t; * FIXME&n;&t;&t; */
id|usb_serial_debug_data
(paren
id|__FILE__
comma
id|__FUNCTION__
comma
id|urb-&gt;actual_length
comma
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bytes_sent
op_plus
l_int|2
OG
id|urb-&gt;actual_length
)paren
(brace
id|dbg
c_func
(paren
id|__FUNCTION__
l_string|&quot; - trying to read more data than available&quot;
l_string|&quot; (%d vs. %d)&quot;
comma
id|bytes_sent
op_plus
l_int|2
comma
id|urb-&gt;actual_length
)paren
suffix:semicolon
multiline_comment|/* cap at implied limit */
id|bytes_sent
op_assign
id|urb-&gt;actual_length
op_minus
l_int|2
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|2
suffix:semicolon
id|i
OL
l_int|2
op_plus
id|bytes_sent
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* if we insert more than TTY_FLIPBUF_SIZE characters,&n;&t;&t;&t; * we drop them. */
r_if
c_cond
(paren
id|tty-&gt;flip.count
op_ge
id|TTY_FLIPBUF_SIZE
)paren
(brace
id|tty_flip_buffer_push
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/* this doesn&squot;t actually push the data through unless &n;&t;&t;&t; * tty-&gt;low_latency is set */
id|tty_insert_flip_char
c_func
(paren
id|tty
comma
(paren
(paren
id|__u8
op_star
)paren
id|data
)paren
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
)brace
id|tty_flip_buffer_push
c_func
(paren
id|tty
)paren
suffix:semicolon
id|priv-&gt;bytes_in
op_add_assign
id|bytes_sent
suffix:semicolon
)brace
multiline_comment|/* Continue trying to always read  */
id|FILL_BULK_URB
c_func
(paren
id|port-&gt;read_urb
comma
id|serial-&gt;dev
comma
id|usb_rcvbulkpipe
c_func
(paren
id|serial-&gt;dev
comma
id|port-&gt;bulk_in_endpointAddress
)paren
comma
id|port-&gt;read_urb-&gt;transfer_buffer
comma
id|port-&gt;read_urb-&gt;transfer_buffer_length
comma
id|klsi_105_read_bulk_callback
comma
id|port
)paren
suffix:semicolon
id|rc
op_assign
id|usb_submit_urb
c_func
(paren
id|port-&gt;read_urb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
id|err
c_func
(paren
id|__FUNCTION__
l_string|&quot; - failed resubmitting read urb, error %d&quot;
comma
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/* klsi_105_read_bulk_callback */
DECL|function|klsi_105_set_termios
r_static
r_void
id|klsi_105_set_termios
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_struct
id|termios
op_star
id|old_termios
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
id|port-&gt;serial
suffix:semicolon
r_struct
id|klsi_105_private
op_star
id|priv
op_assign
(paren
r_struct
id|klsi_105_private
op_star
)paren
id|port
op_member_access_from_pointer
r_private
suffix:semicolon
r_int
r_int
id|iflag
op_assign
id|port-&gt;tty-&gt;termios-&gt;c_iflag
suffix:semicolon
r_int
r_int
id|old_iflag
op_assign
id|old_termios-&gt;c_iflag
suffix:semicolon
r_int
r_int
id|cflag
op_assign
id|port-&gt;tty-&gt;termios-&gt;c_cflag
suffix:semicolon
r_int
r_int
id|old_cflag
op_assign
id|old_termios-&gt;c_cflag
suffix:semicolon
multiline_comment|/*&n;&t; * Update baud rate&n;&t; */
r_if
c_cond
(paren
(paren
id|cflag
op_amp
id|CBAUD
)paren
op_ne
(paren
id|old_cflag
op_amp
id|CBAUD
)paren
)paren
(brace
multiline_comment|/* reassert DTR and (maybe) RTS on transition from B0 */
r_if
c_cond
(paren
(paren
id|old_cflag
op_amp
id|CBAUD
)paren
op_eq
id|B0
)paren
(brace
id|dbg
c_func
(paren
id|__FUNCTION__
l_string|&quot;: baud was B0&quot;
)paren
suffix:semicolon
macro_line|#if 0
id|priv-&gt;control_state
op_or_assign
id|TIOCM_DTR
suffix:semicolon
multiline_comment|/* don&squot;t set RTS if using hardware flow control */
r_if
c_cond
(paren
op_logical_neg
(paren
id|old_cflag
op_amp
id|CRTSCTS
)paren
)paren
(brace
id|priv-&gt;control_state
op_or_assign
id|TIOCM_RTS
suffix:semicolon
)brace
id|mct_u232_set_modem_ctrl
c_func
(paren
id|serial
comma
id|priv-&gt;control_state
)paren
suffix:semicolon
macro_line|#endif
)brace
r_switch
c_cond
(paren
id|cflag
op_amp
id|CBAUD
)paren
(brace
r_case
id|B0
suffix:colon
multiline_comment|/* handled below */
r_break
suffix:semicolon
r_case
id|B1200
suffix:colon
id|priv-&gt;cfg.baudrate
op_assign
id|kl5kusb105a_sio_b1200
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B2400
suffix:colon
id|priv-&gt;cfg.baudrate
op_assign
id|kl5kusb105a_sio_b2400
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B4800
suffix:colon
id|priv-&gt;cfg.baudrate
op_assign
id|kl5kusb105a_sio_b4800
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B9600
suffix:colon
id|priv-&gt;cfg.baudrate
op_assign
id|kl5kusb105a_sio_b9600
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B19200
suffix:colon
id|priv-&gt;cfg.baudrate
op_assign
id|kl5kusb105a_sio_b19200
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B38400
suffix:colon
id|priv-&gt;cfg.baudrate
op_assign
id|kl5kusb105a_sio_b38400
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B57600
suffix:colon
id|priv-&gt;cfg.baudrate
op_assign
id|kl5kusb105a_sio_b57600
suffix:semicolon
r_break
suffix:semicolon
r_case
id|B115200
suffix:colon
id|priv-&gt;cfg.baudrate
op_assign
id|kl5kusb105a_sio_b115200
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
c_func
(paren
l_string|&quot;KLSI USB-&gt;Serial converter:&quot;
l_string|&quot; unsupported baudrate request, using default&quot;
l_string|&quot; of 9600&quot;
)paren
suffix:semicolon
id|priv-&gt;cfg.baudrate
op_assign
id|kl5kusb105a_sio_b9600
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|cflag
op_amp
id|CBAUD
)paren
op_eq
id|B0
)paren
(brace
id|dbg
c_func
(paren
id|__FUNCTION__
l_string|&quot;: baud is B0&quot;
)paren
suffix:semicolon
multiline_comment|/* Drop RTS and DTR */
multiline_comment|/* maybe this should be simulated by sending read&n;&t;&t;&t; * disable and read enable messages?&n;&t;&t;&t; */
suffix:semicolon
macro_line|#if 0
id|priv-&gt;control_state
op_and_assign
op_complement
(paren
id|TIOCM_DTR
op_or
id|TIOCM_RTS
)paren
suffix:semicolon
id|mct_u232_set_modem_ctrl
c_func
(paren
id|serial
comma
id|priv-&gt;control_state
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
r_if
c_cond
(paren
(paren
id|cflag
op_amp
id|CSIZE
)paren
op_ne
(paren
id|old_cflag
op_amp
id|CSIZE
)paren
)paren
(brace
multiline_comment|/* set the number of data bits */
r_switch
c_cond
(paren
id|cflag
op_amp
id|CSIZE
)paren
(brace
r_case
id|CS5
suffix:colon
id|dbg
c_func
(paren
id|__FUNCTION__
l_string|&quot; - 5 bits/byte not supported&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|CS6
suffix:colon
id|dbg
c_func
(paren
id|__FUNCTION__
l_string|&quot; - 6 bits/byte not supported&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|CS7
suffix:colon
id|priv-&gt;cfg.databits
op_assign
id|kl5kusb105a_dtb_7
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS8
suffix:colon
id|priv-&gt;cfg.databits
op_assign
id|kl5kusb105a_dtb_8
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
c_func
(paren
l_string|&quot;CSIZE was not CS5-CS8, using default of 8&quot;
)paren
suffix:semicolon
id|priv-&gt;cfg.databits
op_assign
id|kl5kusb105a_dtb_8
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Update line control register (LCR)&n;&t; */
r_if
c_cond
(paren
(paren
id|cflag
op_amp
(paren
id|PARENB
op_or
id|PARODD
)paren
)paren
op_ne
(paren
id|old_cflag
op_amp
(paren
id|PARENB
op_or
id|PARODD
)paren
)paren
op_logical_or
(paren
id|cflag
op_amp
id|CSTOPB
)paren
op_ne
(paren
id|old_cflag
op_amp
id|CSTOPB
)paren
)paren
(brace
macro_line|#if 0
id|priv-&gt;last_lcr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set the parity */
r_if
c_cond
(paren
id|cflag
op_amp
id|PARENB
)paren
id|priv-&gt;last_lcr
op_or_assign
(paren
id|cflag
op_amp
id|PARODD
)paren
ques
c_cond
id|MCT_U232_PARITY_ODD
suffix:colon
id|MCT_U232_PARITY_EVEN
suffix:semicolon
r_else
id|priv-&gt;last_lcr
op_or_assign
id|MCT_U232_PARITY_NONE
suffix:semicolon
multiline_comment|/* set the number of stop bits */
id|priv-&gt;last_lcr
op_or_assign
(paren
id|cflag
op_amp
id|CSTOPB
)paren
ques
c_cond
id|MCT_U232_STOP_BITS_2
suffix:colon
id|MCT_U232_STOP_BITS_1
suffix:semicolon
id|mct_u232_set_line_ctrl
c_func
(paren
id|serial
comma
id|priv-&gt;last_lcr
)paren
suffix:semicolon
macro_line|#endif
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Set flow control: well, I do not really now how to handle DTR/RTS.&n;&t; * Just do what we have seen with SniffUSB on Win98.&n;&t; */
r_if
c_cond
(paren
(paren
id|iflag
op_amp
id|IXOFF
)paren
op_ne
(paren
id|old_iflag
op_amp
id|IXOFF
)paren
op_logical_or
(paren
id|iflag
op_amp
id|IXON
)paren
op_ne
(paren
id|old_iflag
op_amp
id|IXON
)paren
op_logical_or
(paren
id|cflag
op_amp
id|CRTSCTS
)paren
op_ne
(paren
id|old_cflag
op_amp
id|CRTSCTS
)paren
)paren
(brace
multiline_comment|/* Drop DTR/RTS if no flow control otherwise assert */
macro_line|#if 0
r_if
c_cond
(paren
(paren
id|iflag
op_amp
id|IXOFF
)paren
op_logical_or
(paren
id|iflag
op_amp
id|IXON
)paren
op_logical_or
(paren
id|cflag
op_amp
id|CRTSCTS
)paren
)paren
id|priv-&gt;control_state
op_or_assign
id|TIOCM_DTR
op_or
id|TIOCM_RTS
suffix:semicolon
r_else
id|priv-&gt;control_state
op_and_assign
op_complement
(paren
id|TIOCM_DTR
op_or
id|TIOCM_RTS
)paren
suffix:semicolon
id|mct_u232_set_modem_ctrl
c_func
(paren
id|serial
comma
id|priv-&gt;control_state
)paren
suffix:semicolon
macro_line|#endif
suffix:semicolon
)brace
multiline_comment|/* now commit changes to device */
id|klsi_105_chg_port_settings
c_func
(paren
id|serial
comma
op_amp
(paren
id|priv-&gt;cfg
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* klsi_105_set_termios */
macro_line|#if 0
r_static
r_void
id|mct_u232_break_ctl
c_func
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_int
id|break_state
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
id|port-&gt;serial
suffix:semicolon
r_struct
id|mct_u232_private
op_star
id|priv
op_assign
(paren
r_struct
id|mct_u232_private
op_star
)paren
id|port
op_member_access_from_pointer
r_private
suffix:semicolon
r_int
r_char
id|lcr
op_assign
id|priv-&gt;last_lcr
suffix:semicolon
id|dbg
(paren
id|__FUNCTION__
l_string|&quot;state=%d&quot;
comma
id|break_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|break_state
)paren
id|lcr
op_or_assign
id|MCT_U232_SET_BREAK
suffix:semicolon
id|mct_u232_set_line_ctrl
c_func
(paren
id|serial
comma
id|lcr
)paren
suffix:semicolon
)brace
multiline_comment|/* mct_u232_break_ctl */
macro_line|#endif
DECL|function|klsi_105_ioctl
r_static
r_int
id|klsi_105_ioctl
(paren
r_struct
id|usb_serial_port
op_star
id|port
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|usb_serial
op_star
id|serial
op_assign
id|port-&gt;serial
suffix:semicolon
r_struct
id|klsi_105_private
op_star
id|priv
op_assign
(paren
r_struct
id|klsi_105_private
op_star
)paren
id|port
op_member_access_from_pointer
r_private
suffix:semicolon
r_int
id|mask
suffix:semicolon
id|dbg
(paren
id|__FUNCTION__
l_string|&quot;cmd=0x%x&quot;
comma
id|cmd
)paren
suffix:semicolon
multiline_comment|/* Based on code from acm.c and others */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TIOCMGET
suffix:colon
(brace
r_int
id|rc
suffix:semicolon
r_int
r_int
id|line_state
suffix:semicolon
id|dbg
(paren
id|__FUNCTION__
l_string|&quot; - TIOCMGET request, just guessing&quot;
)paren
suffix:semicolon
id|rc
op_assign
id|klsi_105_get_line_state
c_func
(paren
id|serial
comma
op_amp
id|line_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Reading line control failed (error = %d)&quot;
comma
id|rc
)paren
suffix:semicolon
multiline_comment|/* better return value? EAGAIN? */
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
r_else
(brace
id|priv-&gt;line_state
op_assign
id|line_state
suffix:semicolon
id|dbg
c_func
(paren
id|__FUNCTION__
l_string|&quot; - read line state 0x%lx&quot;
comma
id|line_state
)paren
suffix:semicolon
)brace
r_return
id|put_user
c_func
(paren
id|priv-&gt;line_state
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
suffix:semicolon
r_case
id|TIOCMSET
suffix:colon
multiline_comment|/* Turns on and off the lines as specified by the mask */
r_case
id|TIOCMBIS
suffix:colon
multiline_comment|/* turns on (Sets) the lines as specified by the mask */
r_case
id|TIOCMBIC
suffix:colon
multiline_comment|/* turns off (Clears) the lines as specified by the mask */
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|mask
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmd
op_eq
id|TIOCMSET
)paren
op_logical_or
(paren
id|mask
op_amp
id|TIOCM_RTS
)paren
)paren
(brace
multiline_comment|/* RTS needs set */
r_if
c_cond
(paren
(paren
(paren
id|cmd
op_eq
id|TIOCMSET
)paren
op_logical_and
(paren
id|mask
op_amp
id|TIOCM_RTS
)paren
)paren
op_logical_or
(paren
id|cmd
op_eq
id|TIOCMBIS
)paren
)paren
(brace
id|dbg
(paren
id|__FUNCTION__
l_string|&quot; - set RTS not handled&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* priv-&gt;control_state |=  TIOCM_RTS; */
r_else
id|dbg
(paren
id|__FUNCTION__
l_string|&quot; - clear RTS not handled&quot;
)paren
suffix:semicolon
multiline_comment|/* priv-&gt;control_state &amp;= ~TIOCM_RTS; */
)brace
r_if
c_cond
(paren
(paren
id|cmd
op_eq
id|TIOCMSET
)paren
op_logical_or
(paren
id|mask
op_amp
id|TIOCM_DTR
)paren
)paren
(brace
multiline_comment|/* DTR needs set */
r_if
c_cond
(paren
(paren
(paren
id|cmd
op_eq
id|TIOCMSET
)paren
op_logical_and
(paren
id|mask
op_amp
id|TIOCM_DTR
)paren
)paren
op_logical_or
(paren
id|cmd
op_eq
id|TIOCMBIS
)paren
)paren
(brace
id|dbg
(paren
id|__FUNCTION__
l_string|&quot; - set DTR not handled&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&t;priv-&gt;control_state |=  TIOCM_DTR; */
r_else
id|dbg
(paren
id|__FUNCTION__
l_string|&quot; - clear DTR not handled&quot;
)paren
suffix:semicolon
multiline_comment|/* priv-&gt;control_state &amp;= ~TIOCM_DTR; */
)brace
multiline_comment|/*&n;&t;&t;mct_u232_set_modem_ctrl(serial, priv-&gt;control_state);&n;&t;&t;*/
r_break
suffix:semicolon
r_case
id|TIOCMIWAIT
suffix:colon
multiline_comment|/* wait for any of the 4 modem inputs (DCD,RI,DSR,CTS)*/
multiline_comment|/* TODO */
id|dbg
(paren
id|__FUNCTION__
l_string|&quot; - TIOCMIWAIT not handled&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
r_case
id|TIOCGICOUNT
suffix:colon
multiline_comment|/* return count of modemline transitions */
multiline_comment|/* TODO */
id|dbg
(paren
id|__FUNCTION__
l_string|&quot; - TIOCGICOUNT not handled&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
r_case
id|TCGETS
suffix:colon
(brace
multiline_comment|/* return current info to caller */
r_int
id|retval
suffix:semicolon
id|dbg
(paren
id|__FUNCTION__
l_string|&quot; - TCGETS data faked/incomplete&quot;
)paren
suffix:semicolon
id|retval
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|termios
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|kernel_termios_to_user_termios
c_func
(paren
(paren
r_struct
id|termios
op_star
)paren
id|arg
comma
op_amp
id|priv-&gt;termios
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|TCSETS
suffix:colon
(brace
multiline_comment|/* set port termios to the one given by the user */
r_int
id|retval
suffix:semicolon
id|dbg
(paren
id|__FUNCTION__
l_string|&quot; - TCSETS not handled&quot;
)paren
suffix:semicolon
id|retval
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|termios
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|user_termios_to_kernel_termios
c_func
(paren
op_amp
id|priv-&gt;termios
comma
(paren
r_struct
id|termios
op_star
)paren
id|arg
)paren
suffix:semicolon
id|klsi_105_set_termios
c_func
(paren
id|port
comma
op_amp
id|priv-&gt;termios
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|TCSETSW
suffix:colon
(brace
multiline_comment|/* set port termios and try to wait for completion of last&n;&t;&t; * write operation */
multiline_comment|/* We guess here. If there are not too many write urbs&n;&t;&t; * outstanding, we lie. */
multiline_comment|/* what is the right way to wait here? schedule() ? */
multiline_comment|/*&n;&t;&t;while (klsi_105_chars_in_buffer(port) &gt; (NUM_URBS / 4 ) * URB_TRANSFER_BUFFER_SIZE)&n;&t;&t;&t;    schedule();&n;&t;&t; */
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
r_default
suffix:colon
id|dbg
c_func
(paren
id|__FUNCTION__
l_string|&quot;: arg not supported - 0x%04x&quot;
comma
id|cmd
)paren
suffix:semicolon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* klsi_105_ioctl */
DECL|function|klsi_105_throttle
r_static
r_void
id|klsi_105_throttle
(paren
r_struct
id|usb_serial_port
op_star
id|port
)paren
(brace
id|dbg
c_func
(paren
id|__FUNCTION__
l_string|&quot; - port %d&quot;
comma
id|port-&gt;number
)paren
suffix:semicolon
id|usb_unlink_urb
(paren
id|port-&gt;read_urb
)paren
suffix:semicolon
)brace
DECL|function|klsi_105_unthrottle
r_static
r_void
id|klsi_105_unthrottle
(paren
r_struct
id|usb_serial_port
op_star
id|port
)paren
(brace
r_int
id|result
suffix:semicolon
id|dbg
c_func
(paren
id|__FUNCTION__
l_string|&quot; - port %d&quot;
comma
id|port-&gt;number
)paren
suffix:semicolon
id|port-&gt;read_urb-&gt;dev
op_assign
id|port-&gt;serial-&gt;dev
suffix:semicolon
id|result
op_assign
id|usb_submit_urb
c_func
(paren
id|port-&gt;read_urb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
id|err
c_func
(paren
id|__FUNCTION__
l_string|&quot; - failed submitting read urb, error %d&quot;
comma
id|result
)paren
suffix:semicolon
)brace
DECL|function|klsi_105_init
r_static
r_int
id|__init
id|klsi_105_init
(paren
r_void
)paren
(brace
id|usb_serial_register
(paren
op_amp
id|kl5kusb105d_device
)paren
suffix:semicolon
id|info
c_func
(paren
id|DRIVER_DESC
l_string|&quot; &quot;
id|DRIVER_VERSION
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|klsi_105_exit
r_static
r_void
id|__exit
id|klsi_105_exit
(paren
r_void
)paren
(brace
id|usb_serial_deregister
(paren
op_amp
id|kl5kusb105d_device
)paren
suffix:semicolon
)brace
DECL|variable|klsi_105_init
id|module_init
(paren
id|klsi_105_init
)paren
suffix:semicolon
DECL|variable|klsi_105_exit
id|module_exit
(paren
id|klsi_105_exit
)paren
suffix:semicolon
DECL|variable|DRIVER_AUTHOR
id|MODULE_AUTHOR
c_func
(paren
id|DRIVER_AUTHOR
)paren
suffix:semicolon
DECL|variable|DRIVER_DESC
id|MODULE_DESCRIPTION
c_func
(paren
id|DRIVER_DESC
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|debug
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|debug
comma
l_string|&quot;enable extensive debugging messages&quot;
)paren
suffix:semicolon
multiline_comment|/* FIXME: implement&n;MODULE_PARM(num_urbs, &quot;i&quot;);&n;MODULE_PARM_DESC(num_urbs, &quot;number of URBs to use in write pool&quot;);&n;*/
multiline_comment|/* vim: set sts=8 ts=8 sw=8: */
eof
