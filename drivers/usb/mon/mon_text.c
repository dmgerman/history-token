multiline_comment|/*&n; * The USB Monitor, inspired by Dave Harding&squot;s USBMon.&n; *&n; * This is a text format reader.&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/usb.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &quot;usb_mon.h&quot;
multiline_comment|/*&n; * No, we do not want arbitrarily long data strings.&n; * Use the binary interface if you want to capture bulk data!&n; */
DECL|macro|DATA_MAX
mdefine_line|#define DATA_MAX  32
multiline_comment|/*&n; * This limit exists to prevent OOMs when the user process stops reading.&n; */
DECL|macro|EVENT_MAX
mdefine_line|#define EVENT_MAX  25
DECL|macro|PRINTF_DFL
mdefine_line|#define PRINTF_DFL  120
DECL|struct|mon_event_text
r_struct
id|mon_event_text
(brace
DECL|member|e_link
r_struct
id|list_head
id|e_link
suffix:semicolon
DECL|member|type
r_int
id|type
suffix:semicolon
multiline_comment|/* submit, complete, etc. */
DECL|member|pipe
r_int
r_int
id|pipe
suffix:semicolon
multiline_comment|/* Pipe */
DECL|member|id
r_int
r_int
id|id
suffix:semicolon
multiline_comment|/* From pointer, most of the time */
DECL|member|tstamp
r_int
r_int
id|tstamp
suffix:semicolon
DECL|member|length
r_int
id|length
suffix:semicolon
multiline_comment|/* Depends on type: xfer length or act length */
DECL|member|status
r_int
id|status
suffix:semicolon
DECL|member|data_flag
r_char
id|data_flag
suffix:semicolon
DECL|member|data
r_int
r_char
id|data
(braket
id|DATA_MAX
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|SLAB_NAME_SZ
mdefine_line|#define SLAB_NAME_SZ  30
DECL|struct|mon_reader_text
r_struct
id|mon_reader_text
(brace
DECL|member|e_slab
id|kmem_cache_t
op_star
id|e_slab
suffix:semicolon
DECL|member|nevents
r_int
id|nevents
suffix:semicolon
DECL|member|e_list
r_struct
id|list_head
id|e_list
suffix:semicolon
DECL|member|r
r_struct
id|mon_reader
id|r
suffix:semicolon
multiline_comment|/* In C, parent class can be placed anywhere */
DECL|member|wait
id|wait_queue_head_t
id|wait
suffix:semicolon
DECL|member|printf_size
r_int
id|printf_size
suffix:semicolon
DECL|member|printf_buf
r_char
op_star
id|printf_buf
suffix:semicolon
DECL|member|printf_lock
r_struct
id|semaphore
id|printf_lock
suffix:semicolon
DECL|member|slab_name
r_char
id|slab_name
(braket
id|SLAB_NAME_SZ
)braket
suffix:semicolon
)brace
suffix:semicolon
r_static
r_void
id|mon_text_ctor
c_func
(paren
r_void
op_star
comma
id|kmem_cache_t
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|mon_text_dtor
c_func
(paren
r_void
op_star
comma
id|kmem_cache_t
op_star
comma
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/*&n; * mon_text_submit&n; * mon_text_complete&n; *&n; * May be called from an interrupt.&n; *&n; * This is called with the whole mon_bus locked, so no additional lock.&n; */
DECL|function|mon_text_get_data
r_static
r_inline
r_char
id|mon_text_get_data
c_func
(paren
r_struct
id|mon_event_text
op_star
id|ep
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|len
comma
r_char
id|ev_type
)paren
(brace
r_int
id|pipe
op_assign
id|urb-&gt;pipe
suffix:semicolon
r_int
r_char
op_star
id|data
suffix:semicolon
multiline_comment|/*&n;&t; * The check to see if it&squot;s safe to poke at data has an enormous&n;&t; * number of corner cases, but it seems that the following is&n;&t; * more or less safe.&n;&t; *&n;&t; * We do not even try to look transfer_buffer, because it can&n;&t; * contain non-NULL garbage in case the upper level promised to&n;&t; * set DMA for the HCD.&n;&t; */
r_if
c_cond
(paren
id|urb-&gt;transfer_flags
op_amp
id|URB_NO_TRANSFER_DMA_MAP
)paren
r_return
l_char|&squot;D&squot;
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
l_int|0
)paren
r_return
l_char|&squot;L&squot;
suffix:semicolon
r_if
c_cond
(paren
(paren
id|data
op_assign
id|urb-&gt;transfer_buffer
)paren
op_eq
l_int|NULL
)paren
r_return
l_char|&squot;Z&squot;
suffix:semicolon
multiline_comment|/* &squot;0&squot; would be not as pretty. */
multiline_comment|/*&n;&t; * Bulk is easy to shortcut reliably. &n;&t; * XXX Control needs setup packet taken.&n;&t; * XXX Other pipe types need consideration. Currently, we overdo it&n;&t; * and collect garbage for them: better more than less.&n;&t; */
r_if
c_cond
(paren
id|usb_pipebulk
c_func
(paren
id|pipe
)paren
op_logical_or
id|usb_pipecontrol
c_func
(paren
id|pipe
)paren
)paren
(brace
r_if
c_cond
(paren
id|usb_pipein
c_func
(paren
id|pipe
)paren
)paren
(brace
r_if
c_cond
(paren
id|ev_type
op_eq
l_char|&squot;S&squot;
)paren
r_return
l_char|&squot;&lt;&squot;
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|ev_type
op_eq
l_char|&squot;C&squot;
)paren
r_return
l_char|&squot;&gt;&squot;
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|len
op_ge
id|DATA_MAX
)paren
id|len
op_assign
id|DATA_MAX
suffix:semicolon
id|memcpy
c_func
(paren
id|ep-&gt;data
comma
id|urb-&gt;transfer_buffer
comma
id|len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mon_get_timestamp
r_static
r_inline
r_int
r_int
id|mon_get_timestamp
c_func
(paren
r_void
)paren
(brace
r_struct
id|timeval
id|tval
suffix:semicolon
r_int
r_int
id|stamp
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
id|tval
)paren
suffix:semicolon
id|stamp
op_assign
id|tval.tv_sec
op_amp
l_int|0xFFFF
suffix:semicolon
multiline_comment|/* 2^32 = 4294967296. Limit to 4096s. */
id|stamp
op_assign
id|stamp
op_star
l_int|1000000
op_plus
id|tval.tv_usec
suffix:semicolon
r_return
id|stamp
suffix:semicolon
)brace
DECL|function|mon_text_event
r_static
r_void
id|mon_text_event
c_func
(paren
r_struct
id|mon_reader_text
op_star
id|rp
comma
r_struct
id|urb
op_star
id|urb
comma
r_char
id|ev_type
)paren
(brace
r_struct
id|mon_event_text
op_star
id|ep
suffix:semicolon
r_int
r_int
id|stamp
suffix:semicolon
id|stamp
op_assign
id|mon_get_timestamp
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rp-&gt;nevents
op_ge
id|EVENT_MAX
op_logical_or
(paren
id|ep
op_assign
id|kmem_cache_alloc
c_func
(paren
id|rp-&gt;e_slab
comma
id|SLAB_ATOMIC
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|rp-&gt;r.m_bus-&gt;cnt_text_lost
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ep-&gt;type
op_assign
id|ev_type
suffix:semicolon
id|ep-&gt;pipe
op_assign
id|urb-&gt;pipe
suffix:semicolon
id|ep-&gt;id
op_assign
(paren
r_int
r_int
)paren
id|urb
suffix:semicolon
id|ep-&gt;tstamp
op_assign
id|stamp
suffix:semicolon
id|ep-&gt;length
op_assign
(paren
id|ev_type
op_eq
l_char|&squot;S&squot;
)paren
ques
c_cond
id|urb-&gt;transfer_buffer_length
suffix:colon
id|urb-&gt;actual_length
suffix:semicolon
multiline_comment|/* Collecting status makes debugging sense for submits, too */
id|ep-&gt;status
op_assign
id|urb-&gt;status
suffix:semicolon
id|ep-&gt;data_flag
op_assign
id|mon_text_get_data
c_func
(paren
id|ep
comma
id|urb
comma
id|ep-&gt;length
comma
id|ev_type
)paren
suffix:semicolon
id|rp-&gt;nevents
op_increment
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|ep-&gt;e_link
comma
op_amp
id|rp-&gt;e_list
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|rp-&gt;wait
)paren
suffix:semicolon
)brace
DECL|function|mon_text_submit
r_static
r_void
id|mon_text_submit
c_func
(paren
r_void
op_star
id|data
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|mon_reader_text
op_star
id|rp
op_assign
id|data
suffix:semicolon
id|mon_text_event
c_func
(paren
id|rp
comma
id|urb
comma
l_char|&squot;S&squot;
)paren
suffix:semicolon
)brace
DECL|function|mon_text_complete
r_static
r_void
id|mon_text_complete
c_func
(paren
r_void
op_star
id|data
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|mon_reader_text
op_star
id|rp
op_assign
id|data
suffix:semicolon
id|mon_text_event
c_func
(paren
id|rp
comma
id|urb
comma
l_char|&squot;C&squot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Fetch next event from the circular buffer.&n; */
DECL|function|mon_text_fetch
r_static
r_struct
id|mon_event_text
op_star
id|mon_text_fetch
c_func
(paren
r_struct
id|mon_reader_text
op_star
id|rp
comma
r_struct
id|mon_bus
op_star
id|mbus
)paren
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|mbus-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|rp-&gt;e_list
)paren
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|mbus-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|p
op_assign
id|rp-&gt;e_list.next
suffix:semicolon
id|list_del
c_func
(paren
id|p
)paren
suffix:semicolon
op_decrement
id|rp-&gt;nevents
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|mbus-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|mon_event_text
comma
id|e_link
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; */
DECL|function|mon_text_open
r_static
r_int
id|mon_text_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|mon_bus
op_star
id|mbus
suffix:semicolon
r_struct
id|usb_bus
op_star
id|ubus
suffix:semicolon
r_struct
id|mon_reader_text
op_star
id|rp
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|down
c_func
(paren
op_amp
id|mon_lock
)paren
suffix:semicolon
id|mbus
op_assign
id|inode-&gt;u.generic_ip
suffix:semicolon
id|ubus
op_assign
id|mbus-&gt;u_bus
suffix:semicolon
id|rp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|mon_reader_text
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rp
op_eq
l_int|NULL
)paren
(brace
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err_alloc
suffix:semicolon
)brace
id|memset
c_func
(paren
id|rp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|mon_reader_text
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|rp-&gt;e_list
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|rp-&gt;wait
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|rp-&gt;printf_lock
)paren
suffix:semicolon
id|rp-&gt;printf_size
op_assign
id|PRINTF_DFL
suffix:semicolon
id|rp-&gt;printf_buf
op_assign
id|kmalloc
c_func
(paren
id|rp-&gt;printf_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rp-&gt;printf_buf
op_eq
l_int|NULL
)paren
(brace
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err_alloc_pr
suffix:semicolon
)brace
id|rp-&gt;r.m_bus
op_assign
id|mbus
suffix:semicolon
id|rp-&gt;r.r_data
op_assign
id|rp
suffix:semicolon
id|rp-&gt;r.rnf_submit
op_assign
id|mon_text_submit
suffix:semicolon
id|rp-&gt;r.rnf_complete
op_assign
id|mon_text_complete
suffix:semicolon
id|snprintf
c_func
(paren
id|rp-&gt;slab_name
comma
id|SLAB_NAME_SZ
comma
l_string|&quot;mon%dt_%lx&quot;
comma
id|ubus-&gt;busnum
comma
(paren
r_int
)paren
id|rp
)paren
suffix:semicolon
id|rp-&gt;e_slab
op_assign
id|kmem_cache_create
c_func
(paren
id|rp-&gt;slab_name
comma
r_sizeof
(paren
r_struct
id|mon_event_text
)paren
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0
comma
id|mon_text_ctor
comma
id|mon_text_dtor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rp-&gt;e_slab
op_eq
l_int|NULL
)paren
(brace
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err_slab
suffix:semicolon
)brace
id|mon_reader_add
c_func
(paren
id|mbus
comma
op_amp
id|rp-&gt;r
)paren
suffix:semicolon
id|file-&gt;private_data
op_assign
id|rp
suffix:semicolon
id|up
c_func
(paren
op_amp
id|mon_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
singleline_comment|// err_busy:
singleline_comment|//&t;kmem_cache_destroy(rp-&gt;e_slab);
id|err_slab
suffix:colon
id|kfree
c_func
(paren
id|rp-&gt;printf_buf
)paren
suffix:semicolon
id|err_alloc_pr
suffix:colon
id|kfree
c_func
(paren
id|rp
)paren
suffix:semicolon
id|err_alloc
suffix:colon
id|up
c_func
(paren
op_amp
id|mon_lock
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * For simplicity, we read one record in one system call and throw out&n; * what does not fit. This means that the following does not work:&n; *   dd if=/dbg/usbmon/0t bs=10&n; * Also, we do not allow seeks and do not bother advancing the offset.&n; */
DECL|function|mon_text_read
r_static
id|ssize_t
id|mon_text_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
id|__user
op_star
id|buf
comma
r_int
id|nbytes
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|mon_reader_text
op_star
id|rp
op_assign
id|file-&gt;private_data
suffix:semicolon
r_struct
id|mon_bus
op_star
id|mbus
op_assign
id|rp-&gt;r.m_bus
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|waita
comma
id|current
)paren
suffix:semicolon
r_struct
id|mon_event_text
op_star
id|ep
suffix:semicolon
r_int
id|cnt
comma
id|limit
suffix:semicolon
r_char
op_star
id|pbuf
suffix:semicolon
r_char
id|udir
comma
id|utype
suffix:semicolon
r_int
id|data_len
comma
id|i
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|rp-&gt;wait
comma
op_amp
id|waita
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ep
op_assign
id|mon_text_fetch
c_func
(paren
id|rp
comma
id|mbus
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|rp-&gt;wait
comma
op_amp
id|waita
)paren
suffix:semicolon
r_return
op_minus
id|EWOULDBLOCK
suffix:semicolon
multiline_comment|/* Same as EAGAIN in Linux */
)brace
multiline_comment|/*&n;&t;&t; * We do not count nwaiters, because -&gt;release is supposed&n;&t;&t; * to be called when all openers are gone only.&n;&t;&t; */
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|remove_wait_queue
c_func
(paren
op_amp
id|rp-&gt;wait
comma
op_amp
id|waita
)paren
suffix:semicolon
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
)brace
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|rp-&gt;wait
comma
op_amp
id|waita
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|rp-&gt;printf_lock
)paren
suffix:semicolon
id|cnt
op_assign
l_int|0
suffix:semicolon
id|pbuf
op_assign
id|rp-&gt;printf_buf
suffix:semicolon
id|limit
op_assign
id|rp-&gt;printf_size
suffix:semicolon
id|udir
op_assign
id|usb_pipein
c_func
(paren
id|ep-&gt;pipe
)paren
ques
c_cond
l_char|&squot;i&squot;
suffix:colon
l_char|&squot;o&squot;
suffix:semicolon
r_switch
c_cond
(paren
id|usb_pipetype
c_func
(paren
id|ep-&gt;pipe
)paren
)paren
(brace
r_case
id|PIPE_ISOCHRONOUS
suffix:colon
id|utype
op_assign
l_char|&squot;Z&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_INTERRUPT
suffix:colon
id|utype
op_assign
l_char|&squot;I&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_CONTROL
suffix:colon
id|utype
op_assign
l_char|&squot;C&squot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* PIPE_BULK */
id|utype
op_assign
l_char|&squot;B&squot;
suffix:semicolon
)brace
id|cnt
op_add_assign
id|snprintf
c_func
(paren
id|pbuf
op_plus
id|cnt
comma
id|limit
op_minus
id|cnt
comma
l_string|&quot;%lx %u %c %c%c:%03u:%02u %d %d&quot;
comma
id|ep-&gt;id
comma
id|ep-&gt;tstamp
comma
id|ep-&gt;type
comma
id|utype
comma
id|udir
comma
id|usb_pipedevice
c_func
(paren
id|ep-&gt;pipe
)paren
comma
id|usb_pipeendpoint
c_func
(paren
id|ep-&gt;pipe
)paren
comma
id|ep-&gt;status
comma
id|ep-&gt;length
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|data_len
op_assign
id|ep-&gt;length
)paren
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ep-&gt;data_flag
op_eq
l_int|0
)paren
(brace
id|cnt
op_add_assign
id|snprintf
c_func
(paren
id|pbuf
op_plus
id|cnt
comma
id|limit
op_minus
id|cnt
comma
l_string|&quot; =&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data_len
op_ge
id|DATA_MAX
)paren
id|data_len
op_assign
id|DATA_MAX
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|data_len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_mod
l_int|4
op_eq
l_int|0
)paren
(brace
id|cnt
op_add_assign
id|snprintf
c_func
(paren
id|pbuf
op_plus
id|cnt
comma
id|limit
op_minus
id|cnt
comma
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
id|cnt
op_add_assign
id|snprintf
c_func
(paren
id|pbuf
op_plus
id|cnt
comma
id|limit
op_minus
id|cnt
comma
l_string|&quot;%02x&quot;
comma
id|ep-&gt;data
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|cnt
op_add_assign
id|snprintf
c_func
(paren
id|pbuf
op_plus
id|cnt
comma
id|limit
op_minus
id|cnt
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|cnt
op_add_assign
id|snprintf
c_func
(paren
id|pbuf
op_plus
id|cnt
comma
id|limit
op_minus
id|cnt
comma
l_string|&quot; %c&bslash;n&quot;
comma
id|ep-&gt;data_flag
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|cnt
op_add_assign
id|snprintf
c_func
(paren
id|pbuf
op_plus
id|cnt
comma
id|limit
op_minus
id|cnt
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
id|rp-&gt;printf_buf
comma
id|cnt
)paren
)paren
id|cnt
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|up
c_func
(paren
op_amp
id|rp-&gt;printf_lock
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|rp-&gt;e_slab
comma
id|ep
)paren
suffix:semicolon
r_return
id|cnt
suffix:semicolon
)brace
DECL|function|mon_text_release
r_static
r_int
id|mon_text_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|mon_reader_text
op_star
id|rp
op_assign
id|file-&gt;private_data
suffix:semicolon
r_struct
id|mon_bus
op_star
id|mbus
suffix:semicolon
multiline_comment|/* unsigned long flags; */
r_struct
id|list_head
op_star
id|p
suffix:semicolon
r_struct
id|mon_event_text
op_star
id|ep
suffix:semicolon
id|down
c_func
(paren
op_amp
id|mon_lock
)paren
suffix:semicolon
id|mbus
op_assign
id|inode-&gt;u.generic_ip
suffix:semicolon
r_if
c_cond
(paren
id|mbus-&gt;nreaders
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|TAG
l_string|&quot;: consistency error on close&bslash;n&quot;
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|mon_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|mon_reader_del
c_func
(paren
id|mbus
comma
op_amp
id|rp-&gt;r
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * In theory, e_list is protected by mbus-&gt;lock. However,&n;&t; * after mon_reader_del has finished, the following is the case:&n;&t; *  - we are not on reader list anymore, so new events won&squot;t be added;&n;&t; *  - whole mbus may be dropped if it was orphaned.&n;&t; * So, we better not touch mbus.&n;&t; */
multiline_comment|/* spin_lock_irqsave(&amp;mbus-&gt;lock, flags); */
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|rp-&gt;e_list
)paren
)paren
(brace
id|p
op_assign
id|rp-&gt;e_list.next
suffix:semicolon
id|ep
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|mon_event_text
comma
id|e_link
)paren
suffix:semicolon
id|list_del
c_func
(paren
id|p
)paren
suffix:semicolon
op_decrement
id|rp-&gt;nevents
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|rp-&gt;e_slab
comma
id|ep
)paren
suffix:semicolon
)brace
multiline_comment|/* spin_unlock_irqrestore(&amp;mbus-&gt;lock, flags); */
id|kmem_cache_destroy
c_func
(paren
id|rp-&gt;e_slab
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|rp-&gt;printf_buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|rp
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|mon_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|mon_fops_text
r_struct
id|file_operations
id|mon_fops_text
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|open
op_assign
id|mon_text_open
comma
dot
id|llseek
op_assign
id|no_llseek
comma
dot
id|read
op_assign
id|mon_text_read
comma
multiline_comment|/* .write =&t;mon_text_write, */
multiline_comment|/* .poll =&t;&t;mon_text_poll, */
multiline_comment|/* .ioctl =&t;mon_text_ioctl, */
dot
id|release
op_assign
id|mon_text_release
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Slab interface: constructor.&n; */
DECL|function|mon_text_ctor
r_static
r_void
id|mon_text_ctor
c_func
(paren
r_void
op_star
id|mem
comma
id|kmem_cache_t
op_star
id|slab
comma
r_int
r_int
id|sflags
)paren
(brace
multiline_comment|/*&n;&t; * Nothing to initialize. No, really!&n;&t; * So, we fill it with garbage to emulate a reused object.&n;&t; */
id|memset
c_func
(paren
id|mem
comma
l_int|0xe5
comma
r_sizeof
(paren
r_struct
id|mon_event_text
)paren
)paren
suffix:semicolon
)brace
DECL|function|mon_text_dtor
r_static
r_void
id|mon_text_dtor
c_func
(paren
r_void
op_star
id|mem
comma
id|kmem_cache_t
op_star
id|slab
comma
r_int
r_int
id|sflags
)paren
(brace
suffix:semicolon
)brace
eof
