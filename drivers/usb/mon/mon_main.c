multiline_comment|/*&n; * The USB Monitor, inspired by Dave Harding&squot;s USBMon.&n; *&n; * mon_main.c: Main file, module initiation and exit, registrations, etc.&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/usb.h&gt;
macro_line|#include &lt;linux/debugfs.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &quot;usb_mon.h&quot;
macro_line|#include &quot;../core/hcd.h&quot;
r_static
r_void
id|mon_submit
c_func
(paren
r_struct
id|usb_bus
op_star
id|ubus
comma
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
r_static
r_void
id|mon_complete
c_func
(paren
r_struct
id|usb_bus
op_star
id|ubus
comma
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
r_static
r_void
id|mon_stop
c_func
(paren
r_struct
id|mon_bus
op_star
id|mbus
)paren
suffix:semicolon
r_static
r_void
id|mon_dissolve
c_func
(paren
r_struct
id|mon_bus
op_star
id|mbus
comma
r_struct
id|usb_bus
op_star
id|ubus
)paren
suffix:semicolon
r_static
r_void
id|mon_bus_drop
c_func
(paren
r_struct
id|kref
op_star
id|r
)paren
suffix:semicolon
r_static
r_void
id|mon_bus_init
c_func
(paren
r_struct
id|dentry
op_star
id|mondir
comma
r_struct
id|usb_bus
op_star
id|ubus
)paren
suffix:semicolon
DECL|variable|mon_lock
id|DECLARE_MUTEX
c_func
(paren
id|mon_lock
)paren
suffix:semicolon
DECL|variable|mon_dir
r_static
r_struct
id|dentry
op_star
id|mon_dir
suffix:semicolon
multiline_comment|/* /dbg/usbmon */
r_static
id|LIST_HEAD
c_func
(paren
id|mon_buses
)paren
suffix:semicolon
multiline_comment|/* All buses we know: struct mon_bus */
multiline_comment|/*&n; * Link a reader into the bus.&n; *&n; * This must be called with mon_lock taken because of mbus-&gt;ref.&n; */
DECL|function|mon_reader_add
r_void
id|mon_reader_add
c_func
(paren
r_struct
id|mon_bus
op_star
id|mbus
comma
r_struct
id|mon_reader
op_star
id|r
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|usb_bus
op_star
id|ubus
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|mbus-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mbus-&gt;nreaders
op_eq
l_int|0
)paren
(brace
id|ubus
op_assign
id|mbus-&gt;u_bus
suffix:semicolon
r_if
c_cond
(paren
id|ubus-&gt;monitored
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Something is really broken, refuse to go on and&n;&t;&t;&t; * possibly corrupt ops pointers or worse.&n;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_ERR
id|TAG
l_string|&quot;: bus %d is already monitored&bslash;n&quot;
comma
id|ubus-&gt;busnum
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|mbus-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ubus-&gt;monitored
op_assign
l_int|1
suffix:semicolon
)brace
id|mbus-&gt;nreaders
op_increment
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|r-&gt;r_link
comma
op_amp
id|mbus-&gt;r_list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|mbus-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|kref_get
c_func
(paren
op_amp
id|mbus-&gt;ref
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Unlink reader from the bus.&n; *&n; * This is called with mon_lock taken, so we can decrement mbus-&gt;ref.&n; */
DECL|function|mon_reader_del
r_void
id|mon_reader_del
c_func
(paren
r_struct
id|mon_bus
op_star
id|mbus
comma
r_struct
id|mon_reader
op_star
id|r
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|mbus-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|r-&gt;r_link
)paren
suffix:semicolon
op_decrement
id|mbus-&gt;nreaders
suffix:semicolon
r_if
c_cond
(paren
id|mbus-&gt;nreaders
op_eq
l_int|0
)paren
id|mon_stop
c_func
(paren
id|mbus
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|mbus-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|kref_put
c_func
(paren
op_amp
id|mbus-&gt;ref
comma
id|mon_bus_drop
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; */
DECL|function|mon_submit
r_static
r_void
id|mon_submit
c_func
(paren
r_struct
id|usb_bus
op_star
id|ubus
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|mon_bus
op_star
id|mbus
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
r_struct
id|mon_reader
op_star
id|r
suffix:semicolon
id|mbus
op_assign
id|ubus-&gt;mon_bus
suffix:semicolon
r_if
c_cond
(paren
id|mbus
op_eq
l_int|NULL
)paren
r_goto
id|out_unlocked
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|mbus-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mbus-&gt;nreaders
op_eq
l_int|0
)paren
r_goto
id|out_locked
suffix:semicolon
id|list_for_each
(paren
id|pos
comma
op_amp
id|mbus-&gt;r_list
)paren
(brace
id|r
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|mon_reader
comma
id|r_link
)paren
suffix:semicolon
id|r
op_member_access_from_pointer
id|rnf_submit
c_func
(paren
id|r-&gt;r_data
comma
id|urb
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|mbus-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
id|out_locked
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|mbus-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|out_unlocked
suffix:colon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; */
DECL|function|mon_submit_error
r_static
r_void
id|mon_submit_error
c_func
(paren
r_struct
id|usb_bus
op_star
id|ubus
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|err
)paren
(brace
r_struct
id|mon_bus
op_star
id|mbus
suffix:semicolon
id|mbus
op_assign
id|ubus-&gt;mon_bus
suffix:semicolon
r_if
c_cond
(paren
id|mbus
op_eq
l_int|NULL
)paren
r_goto
id|out_unlocked
suffix:semicolon
multiline_comment|/*&n;&t; * XXX Capture the error code and the &squot;E&squot; event.&n;&t; */
r_return
suffix:semicolon
id|out_unlocked
suffix:colon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; */
DECL|function|mon_complete
r_static
r_void
id|mon_complete
c_func
(paren
r_struct
id|usb_bus
op_star
id|ubus
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|mon_bus
op_star
id|mbus
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
r_struct
id|mon_reader
op_star
id|r
suffix:semicolon
id|mbus
op_assign
id|ubus-&gt;mon_bus
suffix:semicolon
r_if
c_cond
(paren
id|mbus
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * This should not happen.&n;&t;&t; * At this point we do not even know the bus number...&n;&t;&t; */
id|printk
c_func
(paren
id|KERN_ERR
id|TAG
l_string|&quot;: Null mon bus in URB, pipe 0x%x&bslash;n&quot;
comma
id|urb-&gt;pipe
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|mbus-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|list_for_each
(paren
id|pos
comma
op_amp
id|mbus-&gt;r_list
)paren
(brace
id|r
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|mon_reader
comma
id|r_link
)paren
suffix:semicolon
id|r
op_member_access_from_pointer
id|rnf_complete
c_func
(paren
id|r-&gt;r_data
comma
id|urb
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|mbus-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* int (*unlink_urb) (struct urb *urb, int status); */
multiline_comment|/*&n; * Stop monitoring.&n; * Obviously this must be well locked, so no need to play with mb&squot;s.&n; */
DECL|function|mon_stop
r_static
r_void
id|mon_stop
c_func
(paren
r_struct
id|mon_bus
op_star
id|mbus
)paren
(brace
r_struct
id|usb_bus
op_star
id|ubus
op_assign
id|mbus-&gt;u_bus
suffix:semicolon
multiline_comment|/*&n;&t; * A stop can be called for a dissolved mon_bus in case of&n;&t; * a reader staying across an rmmod foo_hcd.&n;&t; */
r_if
c_cond
(paren
id|ubus
op_ne
l_int|NULL
)paren
(brace
id|ubus-&gt;monitored
op_assign
l_int|0
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Add a USB bus (usually by a modprobe foo-hcd)&n; *&n; * This does not return an error code because the core cannot care less&n; * if monitoring is not established.&n; */
DECL|function|mon_bus_add
r_static
r_void
id|mon_bus_add
c_func
(paren
r_struct
id|usb_bus
op_star
id|ubus
)paren
(brace
id|mon_bus_init
c_func
(paren
id|mon_dir
comma
id|ubus
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove a USB bus (either from rmmod foo-hcd or from a hot-remove event).&n; */
DECL|function|mon_bus_remove
r_static
r_void
id|mon_bus_remove
c_func
(paren
r_struct
id|usb_bus
op_star
id|ubus
)paren
(brace
r_struct
id|mon_bus
op_star
id|mbus
op_assign
id|ubus-&gt;mon_bus
suffix:semicolon
id|down
c_func
(paren
op_amp
id|mon_lock
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|mbus-&gt;bus_link
)paren
suffix:semicolon
id|debugfs_remove
c_func
(paren
id|mbus-&gt;dent_t
)paren
suffix:semicolon
id|debugfs_remove
c_func
(paren
id|mbus-&gt;dent_s
)paren
suffix:semicolon
id|mon_dissolve
c_func
(paren
id|mbus
comma
id|ubus
)paren
suffix:semicolon
id|kref_put
c_func
(paren
op_amp
id|mbus-&gt;ref
comma
id|mon_bus_drop
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|mon_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Ops&n; */
DECL|variable|mon_ops_0
r_static
r_struct
id|usb_mon_operations
id|mon_ops_0
op_assign
(brace
dot
id|urb_submit
op_assign
id|mon_submit
comma
dot
id|urb_submit_error
op_assign
id|mon_submit_error
comma
dot
id|urb_complete
op_assign
id|mon_complete
comma
dot
id|bus_add
op_assign
id|mon_bus_add
comma
dot
id|bus_remove
op_assign
id|mon_bus_remove
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Tear usb_bus and mon_bus apart.&n; */
DECL|function|mon_dissolve
r_static
r_void
id|mon_dissolve
c_func
(paren
r_struct
id|mon_bus
op_star
id|mbus
comma
r_struct
id|usb_bus
op_star
id|ubus
)paren
(brace
multiline_comment|/*&n;&t; * Never happens, but...&n;&t; */
r_if
c_cond
(paren
id|ubus-&gt;monitored
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|TAG
l_string|&quot;: bus %d is dissolved while monitored&bslash;n&quot;
comma
id|ubus-&gt;busnum
)paren
suffix:semicolon
id|ubus-&gt;monitored
op_assign
l_int|0
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
id|ubus-&gt;mon_bus
op_assign
l_int|NULL
suffix:semicolon
id|mbus-&gt;u_bus
op_assign
l_int|NULL
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
singleline_comment|// usb_bus_put(ubus);
)brace
multiline_comment|/*&n; */
DECL|function|mon_bus_drop
r_static
r_void
id|mon_bus_drop
c_func
(paren
r_struct
id|kref
op_star
id|r
)paren
(brace
r_struct
id|mon_bus
op_star
id|mbus
op_assign
id|container_of
c_func
(paren
id|r
comma
r_struct
id|mon_bus
comma
id|ref
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mbus
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize a bus for us:&n; *  - allocate mon_bus&n; *  - refcount USB bus struct&n; *  - link&n; */
DECL|function|mon_bus_init
r_static
r_void
id|mon_bus_init
c_func
(paren
r_struct
id|dentry
op_star
id|mondir
comma
r_struct
id|usb_bus
op_star
id|ubus
)paren
(brace
r_struct
id|dentry
op_star
id|d
suffix:semicolon
r_struct
id|mon_bus
op_star
id|mbus
suffix:semicolon
r_enum
(brace
id|NAMESZ
op_assign
l_int|10
)brace
suffix:semicolon
r_char
id|name
(braket
id|NAMESZ
)braket
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mbus
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|mon_bus
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
id|err_alloc
suffix:semicolon
id|memset
c_func
(paren
id|mbus
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|mon_bus
)paren
)paren
suffix:semicolon
id|kref_init
c_func
(paren
op_amp
id|mbus-&gt;ref
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|mbus-&gt;lock
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|mbus-&gt;r_list
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This usb_bus_get here is superfluous, because we receive&n;&t; * a notification if usb_bus is about to be removed.&n;&t; */
singleline_comment|// usb_bus_get(ubus);
id|mbus-&gt;u_bus
op_assign
id|ubus
suffix:semicolon
id|ubus-&gt;mon_bus
op_assign
id|mbus
suffix:semicolon
id|rc
op_assign
id|snprintf
c_func
(paren
id|name
comma
id|NAMESZ
comma
l_string|&quot;%dt&quot;
comma
id|ubus-&gt;busnum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_le
l_int|0
op_logical_or
id|rc
op_ge
id|NAMESZ
)paren
r_goto
id|err_print_t
suffix:semicolon
id|d
op_assign
id|debugfs_create_file
c_func
(paren
id|name
comma
l_int|0600
comma
id|mondir
comma
id|mbus
comma
op_amp
id|mon_fops_text
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d
op_eq
l_int|NULL
)paren
r_goto
id|err_create_t
suffix:semicolon
id|mbus-&gt;dent_t
op_assign
id|d
suffix:semicolon
id|rc
op_assign
id|snprintf
c_func
(paren
id|name
comma
id|NAMESZ
comma
l_string|&quot;%ds&quot;
comma
id|ubus-&gt;busnum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_le
l_int|0
op_logical_or
id|rc
op_ge
id|NAMESZ
)paren
r_goto
id|err_print_s
suffix:semicolon
id|d
op_assign
id|debugfs_create_file
c_func
(paren
id|name
comma
l_int|0600
comma
id|mondir
comma
id|mbus
comma
op_amp
id|mon_fops_stat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d
op_eq
l_int|NULL
)paren
r_goto
id|err_create_s
suffix:semicolon
id|mbus-&gt;dent_s
op_assign
id|d
suffix:semicolon
id|down
c_func
(paren
op_amp
id|mon_lock
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|mbus-&gt;bus_link
comma
op_amp
id|mon_buses
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|mon_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
id|err_create_s
suffix:colon
id|err_print_s
suffix:colon
id|debugfs_remove
c_func
(paren
id|mbus-&gt;dent_t
)paren
suffix:semicolon
id|err_create_t
suffix:colon
id|err_print_t
suffix:colon
id|kfree
c_func
(paren
id|mbus
)paren
suffix:semicolon
id|err_alloc
suffix:colon
r_return
suffix:semicolon
)brace
DECL|function|mon_init
r_static
r_int
id|__init
id|mon_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|usb_bus
op_star
id|ubus
suffix:semicolon
r_struct
id|dentry
op_star
id|mondir
suffix:semicolon
id|mondir
op_assign
id|debugfs_create_dir
c_func
(paren
l_string|&quot;usbmon&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|mondir
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
id|TAG
l_string|&quot;: debugs is not available&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mondir
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
id|TAG
l_string|&quot;: unable to create usbmon directory&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|mon_dir
op_assign
id|mondir
suffix:semicolon
r_if
c_cond
(paren
id|usb_mon_register
c_func
(paren
op_amp
id|mon_ops_0
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
id|TAG
l_string|&quot;: unable to register with the core&bslash;n&quot;
)paren
suffix:semicolon
id|debugfs_remove
c_func
(paren
id|mondir
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
singleline_comment|// MOD_INC_USE_COUNT(which_module?);
id|down
c_func
(paren
op_amp
id|usb_bus_list_lock
)paren
suffix:semicolon
id|list_for_each_entry
(paren
id|ubus
comma
op_amp
id|usb_bus_list
comma
id|bus_list
)paren
(brace
id|mon_bus_init
c_func
(paren
id|mondir
comma
id|ubus
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|usb_bus_list_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mon_exit
r_static
r_void
id|__exit
id|mon_exit
c_func
(paren
r_void
)paren
(brace
r_struct
id|mon_bus
op_star
id|mbus
suffix:semicolon
r_struct
id|list_head
op_star
id|p
suffix:semicolon
id|usb_mon_deregister
c_func
(paren
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|mon_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|mon_buses
)paren
)paren
(brace
id|p
op_assign
id|mon_buses.next
suffix:semicolon
id|mbus
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|mon_bus
comma
id|bus_link
)paren
suffix:semicolon
id|list_del
c_func
(paren
id|p
)paren
suffix:semicolon
id|debugfs_remove
c_func
(paren
id|mbus-&gt;dent_t
)paren
suffix:semicolon
id|debugfs_remove
c_func
(paren
id|mbus-&gt;dent_s
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This never happens, because the open/close paths in&n;&t;&t; * file level maintain module use counters and so rmmod fails&n;&t;&t; * before reaching here. However, better be safe...&n;&t;&t; */
r_if
c_cond
(paren
id|mbus-&gt;nreaders
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|TAG
l_string|&quot;: Outstanding opens (%d) on usb%d, leaking...&bslash;n&quot;
comma
id|mbus-&gt;nreaders
comma
id|mbus-&gt;u_bus-&gt;busnum
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|mbus-&gt;ref.refcount
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Force leak */
)brace
id|mon_dissolve
c_func
(paren
id|mbus
comma
id|mbus-&gt;u_bus
)paren
suffix:semicolon
id|kref_put
c_func
(paren
op_amp
id|mbus-&gt;ref
comma
id|mon_bus_drop
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|mon_lock
)paren
suffix:semicolon
id|debugfs_remove
c_func
(paren
id|mon_dir
)paren
suffix:semicolon
)brace
DECL|variable|mon_init
id|module_init
c_func
(paren
id|mon_init
)paren
suffix:semicolon
DECL|variable|mon_exit
id|module_exit
c_func
(paren
id|mon_exit
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
