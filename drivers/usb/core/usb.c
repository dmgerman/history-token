multiline_comment|/*&n; * drivers/usb/usb.c&n; *&n; * (C) Copyright Linus Torvalds 1999&n; * (C) Copyright Johannes Erdfelt 1999-2001&n; * (C) Copyright Andreas Gal 1999&n; * (C) Copyright Gregory P. Smith 1999&n; * (C) Copyright Deti Fliegl 1999 (new USB architecture)&n; * (C) Copyright Randy Dunlap 2000&n; * (C) Copyright David Brownell 2000-2001 (kernel hotplug, usb_device_id,&n; &t;more docs, etc)&n; * (C) Copyright Yggdrasil Computing, Inc. 2000&n; *     (usb_device_id matching changes by Adam J. Richter)&n; * (C) Copyright Greg Kroah-Hartman 2002&n; *&n; * NOTE! This is not actually a driver at all, rather this is&n; * just a collection of helper routines that implement the&n; * generic USB things that the real drivers can use..&n; *&n; * Think of this as a &quot;USB library&quot; rather than anything else.&n; * It should be considered a slave, with no callbacks. Callbacks&n; * are evil.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;  /* for in_interrupt() */
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#ifdef CONFIG_USB_DEBUG
DECL|macro|DEBUG
mdefine_line|#define DEBUG
macro_line|#else
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#endif
macro_line|#include &lt;linux/usb.h&gt;
macro_line|#include &quot;hcd.h&quot;
r_extern
r_int
id|usb_hub_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|usb_hub_cleanup
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|usb_major_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|usb_major_cleanup
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * Prototypes for the device driver probing/loading functions&n; */
r_static
r_void
id|usb_find_drivers
c_func
(paren
r_struct
id|usb_device
op_star
)paren
suffix:semicolon
r_static
r_int
id|usb_find_interface_driver
c_func
(paren
r_struct
id|usb_device
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|usb_check_support
c_func
(paren
r_struct
id|usb_device
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * We have a per-interface &quot;registered driver&quot; list.&n; */
DECL|variable|usb_driver_list
id|LIST_HEAD
c_func
(paren
id|usb_driver_list
)paren
suffix:semicolon
multiline_comment|/**&n; * usb_register - register a USB driver&n; * @new_driver: USB operations for the driver&n; *&n; * Registers a USB driver with the USB core.  The list of unattached&n; * interfaces will be rescanned whenever a new driver is added, allowing&n; * the new driver to attach to any recognized devices.&n; * Returns a negative error code on failure and 0 on success.&n; * &n; * NOTE: if you want your driver to use the USB major number, you must call&n; * usb_register_dev() to enable that functionality.  This function no longer&n; * takes care of that.&n; */
DECL|function|usb_register
r_int
id|usb_register
c_func
(paren
r_struct
id|usb_driver
op_star
id|new_driver
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
id|info
c_func
(paren
l_string|&quot;registered new driver %s&quot;
comma
id|new_driver-&gt;name
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|new_driver-&gt;serialize
)paren
suffix:semicolon
multiline_comment|/* Add it to the list of known drivers */
id|list_add_tail
c_func
(paren
op_amp
id|new_driver-&gt;driver_list
comma
op_amp
id|usb_driver_list
)paren
suffix:semicolon
id|usb_scan_devices
c_func
(paren
)paren
suffix:semicolon
id|usbfs_update_special
c_func
(paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;usb_scan_devices - scans all unclaimed USB interfaces&n; *&t;Context: !in_interrupt ()&n; *&n; *&t;Goes through all unclaimed USB interfaces, and offers them to all&n; *&t;registered USB drivers through the &squot;probe&squot; function.&n; *&t;This will automatically be called after usb_register is called.&n; *&t;It is called by some of the subsystems layered over USB&n; *&t;after one of their subdrivers are registered.&n; */
DECL|function|usb_scan_devices
r_void
id|usb_scan_devices
c_func
(paren
r_void
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|down
(paren
op_amp
id|usb_bus_list_lock
)paren
suffix:semicolon
id|tmp
op_assign
id|usb_bus_list.next
suffix:semicolon
r_while
c_loop
(paren
id|tmp
op_ne
op_amp
id|usb_bus_list
)paren
(brace
r_struct
id|usb_bus
op_star
id|bus
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|usb_bus
comma
id|bus_list
)paren
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
id|usb_check_support
c_func
(paren
id|bus-&gt;root_hub
)paren
suffix:semicolon
)brace
id|up
(paren
op_amp
id|usb_bus_list_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is part of a depth-first search down the device tree,&n; * removing any instances of a device driver.&n; */
DECL|function|usb_drivers_purge
r_static
r_void
id|usb_drivers_purge
c_func
(paren
r_struct
id|usb_driver
op_star
id|driver
comma
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|err
c_func
(paren
l_string|&quot;null device being purged!!!&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|USB_MAXCHILDREN
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|dev-&gt;children
(braket
id|i
)braket
)paren
id|usb_drivers_purge
c_func
(paren
id|driver
comma
id|dev-&gt;children
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;actconfig
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;actconfig-&gt;bNumInterfaces
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|usb_interface
op_star
id|interface
op_assign
op_amp
id|dev-&gt;actconfig-&gt;interface
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|interface-&gt;driver
op_eq
id|driver
)paren
(brace
r_if
c_cond
(paren
id|driver-&gt;owner
)paren
id|__MOD_INC_USE_COUNT
c_func
(paren
id|driver-&gt;owner
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|driver-&gt;serialize
)paren
suffix:semicolon
id|driver
op_member_access_from_pointer
id|disconnect
c_func
(paren
id|dev
comma
id|interface-&gt;private_data
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|driver-&gt;serialize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver-&gt;owner
)paren
id|__MOD_DEC_USE_COUNT
c_func
(paren
id|driver-&gt;owner
)paren
suffix:semicolon
multiline_comment|/* if driver-&gt;disconnect didn&squot;t release the interface */
r_if
c_cond
(paren
id|interface-&gt;driver
)paren
id|usb_driver_release_interface
c_func
(paren
id|driver
comma
id|interface
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * This will go through the list looking for another&n;&t;&t;&t; * driver that can handle the device&n;&t;&t;&t; */
id|usb_find_interface_driver
c_func
(paren
id|dev
comma
id|i
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/**&n; * usb_deregister - unregister a USB driver&n; * @driver: USB operations of the driver to unregister&n; * Context: !in_interrupt ()&n; *&n; * Unlinks the specified driver from the internal USB driver list.&n; * &n; * NOTE: If you called usb_register_dev(), you still need to call&n; * usb_deregister_dev() to clean up your driver&squot;s allocated minor numbers,&n; * this * call will no longer do it for you.&n; */
DECL|function|usb_deregister
r_void
id|usb_deregister
c_func
(paren
r_struct
id|usb_driver
op_star
id|driver
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|info
c_func
(paren
l_string|&quot;deregistering driver %s&quot;
comma
id|driver-&gt;name
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * first we remove the driver, to be sure it doesn&squot;t get used by&n;&t; * another thread while we are stepping through removing entries&n;&t; */
id|list_del
c_func
(paren
op_amp
id|driver-&gt;driver_list
)paren
suffix:semicolon
id|down
(paren
op_amp
id|usb_bus_list_lock
)paren
suffix:semicolon
id|tmp
op_assign
id|usb_bus_list.next
suffix:semicolon
r_while
c_loop
(paren
id|tmp
op_ne
op_amp
id|usb_bus_list
)paren
(brace
r_struct
id|usb_bus
op_star
id|bus
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|usb_bus
comma
id|bus_list
)paren
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
id|usb_drivers_purge
c_func
(paren
id|driver
comma
id|bus-&gt;root_hub
)paren
suffix:semicolon
)brace
id|up
(paren
op_amp
id|usb_bus_list_lock
)paren
suffix:semicolon
id|usbfs_update_special
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_ifnum_to_ifpos - convert the interface number to the interface position&n; * @dev: the device to use&n; * @ifnum: the interface number (bInterfaceNumber); not interface position&n; *&n; * This is used to convert the interface _number_ (as in&n; * interface.bInterfaceNumber) to the interface _position_ (as in&n; * dev-&gt;actconfig-&gt;interface + position).  Note that the number is the same as&n; * the position for all interfaces _except_ devices with interfaces not&n; * sequentially numbered (e.g., 0, 2, 3, etc).&n; */
DECL|function|usb_ifnum_to_ifpos
r_int
id|usb_ifnum_to_ifpos
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|ifnum
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;actconfig-&gt;bNumInterfaces
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|dev-&gt;actconfig-&gt;interface
(braket
id|i
)braket
dot
id|altsetting
(braket
l_int|0
)braket
dot
id|bInterfaceNumber
op_eq
id|ifnum
)paren
r_return
id|i
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_ifnum_to_if - get the interface object with a given interface number&n; * @dev: the device whose current configuration is considered&n; * @ifnum: the desired interface&n; *&n; * This walks the device descriptor for the currently active configuration&n; * and returns a pointer to the interface with that particular interface&n; * number, or null.&n; *&n; * Note that configuration descriptors are not required to assign interface&n; * numbers sequentially, so that it would be incorrect to assume that&n; * the first interface in that descriptor corresponds to interface zero.&n; * This routine helps device drivers avoid such mistakes.&n; * However, you should make sure that you do the right thing with any&n; * alternate settings available for this interfaces.&n; */
DECL|function|usb_ifnum_to_if
r_struct
id|usb_interface
op_star
id|usb_ifnum_to_if
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|ifnum
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;actconfig-&gt;bNumInterfaces
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|dev-&gt;actconfig-&gt;interface
(braket
id|i
)braket
dot
id|altsetting
(braket
l_int|0
)braket
dot
id|bInterfaceNumber
op_eq
id|ifnum
)paren
r_return
op_amp
id|dev-&gt;actconfig-&gt;interface
(braket
id|i
)braket
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_epnum_to_ep_desc - get the endpoint object with a given endpoint number&n; * @dev: the device whose current configuration is considered&n; * @epnum: the desired endpoint&n; *&n; * This walks the device descriptor for the currently active configuration,&n; * and returns a pointer to the endpoint with that particular endpoint&n; * number, or null.&n; *&n; * Note that interface descriptors are not required to assign endpont&n; * numbers sequentially, so that it would be incorrect to assume that&n; * the first endpoint in that descriptor corresponds to interface zero.&n; * This routine helps device drivers avoid such mistakes.&n; */
DECL|function|usb_epnum_to_ep_desc
r_struct
id|usb_endpoint_descriptor
op_star
id|usb_epnum_to_ep_desc
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|epnum
)paren
(brace
r_int
id|i
comma
id|j
comma
id|k
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;actconfig-&gt;bNumInterfaces
suffix:semicolon
id|i
op_increment
)paren
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|dev-&gt;actconfig-&gt;interface
(braket
id|i
)braket
dot
id|num_altsetting
suffix:semicolon
id|j
op_increment
)paren
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|dev-&gt;actconfig-&gt;interface
(braket
id|i
)braket
dot
id|altsetting
(braket
id|j
)braket
dot
id|bNumEndpoints
suffix:semicolon
id|k
op_increment
)paren
r_if
c_cond
(paren
id|epnum
op_eq
id|dev-&gt;actconfig-&gt;interface
(braket
id|i
)braket
dot
id|altsetting
(braket
id|j
)braket
dot
id|endpoint
(braket
id|k
)braket
dot
id|bEndpointAddress
)paren
r_return
op_amp
id|dev-&gt;actconfig-&gt;interface
(braket
id|i
)braket
dot
id|altsetting
(braket
id|j
)braket
dot
id|endpoint
(braket
id|k
)braket
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is for doing a depth-first search for devices which&n; * have support, for dynamic loading of driver modules.&n; */
DECL|function|usb_check_support
r_static
r_void
id|usb_check_support
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|err
c_func
(paren
l_string|&quot;null device being checked!!!&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|USB_MAXCHILDREN
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|dev-&gt;children
(braket
id|i
)braket
)paren
id|usb_check_support
c_func
(paren
id|dev-&gt;children
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;actconfig
)paren
r_return
suffix:semicolon
multiline_comment|/* now we check this device */
r_if
c_cond
(paren
id|dev-&gt;devnum
OG
l_int|0
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;actconfig-&gt;bNumInterfaces
suffix:semicolon
id|i
op_increment
)paren
id|usb_find_interface_driver
c_func
(paren
id|dev
comma
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_driver_claim_interface - bind a driver to an interface&n; * @driver: the driver to be bound&n; * @iface: the interface to which it will be bound&n; * @priv: driver data associated with that interface&n; *&n; * This is used by usb device drivers that need to claim more than one&n; * interface on a device when probing (audio and acm are current examples).&n; * No device driver should directly modify internal usb_interface or&n; * usb_device structure members.&n; *&n; * Few drivers should need to use this routine, since the most natural&n; * way to bind to an interface is to return the private data from&n; * the driver&squot;s probe() method.  Any driver that does use this must&n; * first be sure that no other driver has claimed the interface, by&n; * checking with usb_interface_claimed().&n; */
DECL|function|usb_driver_claim_interface
r_void
id|usb_driver_claim_interface
c_func
(paren
r_struct
id|usb_driver
op_star
id|driver
comma
r_struct
id|usb_interface
op_star
id|iface
comma
r_void
op_star
id|priv
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|iface
op_logical_or
op_logical_neg
id|driver
)paren
r_return
suffix:semicolon
singleline_comment|// FIXME change API to report an error in this case
r_if
c_cond
(paren
id|iface-&gt;driver
)paren
id|err
(paren
l_string|&quot;%s driver booted %s off interface %p&quot;
comma
id|driver-&gt;name
comma
id|iface-&gt;driver-&gt;name
comma
id|iface
)paren
suffix:semicolon
r_else
id|dbg
c_func
(paren
l_string|&quot;%s driver claimed interface %p&quot;
comma
id|driver-&gt;name
comma
id|iface
)paren
suffix:semicolon
id|iface-&gt;driver
op_assign
id|driver
suffix:semicolon
id|iface-&gt;private_data
op_assign
id|priv
suffix:semicolon
)brace
multiline_comment|/* usb_driver_claim_interface() */
multiline_comment|/**&n; * usb_interface_claimed - returns true iff an interface is claimed&n; * @iface: the interface being checked&n; *&n; * This should be used by drivers to check other interfaces to see if&n; * they are available or not.  If another driver has claimed the interface,&n; * they may not claim it.  Otherwise it&squot;s OK to claim it using&n; * usb_driver_claim_interface().&n; *&n; * Returns true (nonzero) iff the interface is claimed, else false (zero).&n; */
DECL|function|usb_interface_claimed
r_int
id|usb_interface_claimed
c_func
(paren
r_struct
id|usb_interface
op_star
id|iface
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|iface
)paren
r_return
l_int|0
suffix:semicolon
r_return
(paren
id|iface-&gt;driver
op_ne
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* usb_interface_claimed() */
multiline_comment|/**&n; * usb_driver_release_interface - unbind a driver from an interface&n; * @driver: the driver to be unbound&n; * @iface: the interface from which it will be unbound&n; * &n; * This should be used by drivers to release their claimed interfaces.&n; * It is normally called in their disconnect() methods, and only for&n; * drivers that bound to more than one interface in their probe().&n; *&n; * When the USB subsystem disconnect()s a driver from some interface,&n; * it automatically invokes this method for that interface.  That&n; * means that even drivers that used usb_driver_claim_interface()&n; * usually won&squot;t need to call this.&n; */
DECL|function|usb_driver_release_interface
r_void
id|usb_driver_release_interface
c_func
(paren
r_struct
id|usb_driver
op_star
id|driver
comma
r_struct
id|usb_interface
op_star
id|iface
)paren
(brace
multiline_comment|/* this should never happen, don&squot;t release something that&squot;s not ours */
r_if
c_cond
(paren
op_logical_neg
id|iface
op_logical_or
id|iface-&gt;driver
op_ne
id|driver
)paren
r_return
suffix:semicolon
id|iface-&gt;driver
op_assign
l_int|NULL
suffix:semicolon
id|iface-&gt;private_data
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_match_id - find first usb_device_id matching device or interface&n; * @dev: the device whose descriptors are considered when matching&n; * @interface: the interface of interest&n; * @id: array of usb_device_id structures, terminated by zero entry&n; *&n; * usb_match_id searches an array of usb_device_id&squot;s and returns&n; * the first one matching the device or interface, or null.&n; * This is used when binding (or rebinding) a driver to an interface.&n; * Most USB device drivers will use this indirectly, through the usb core,&n; * but some layered driver frameworks use it directly.&n; * These device tables are exported with MODULE_DEVICE_TABLE, through&n; * modutils and &quot;modules.usbmap&quot;, to support the driver loading&n; * functionality of USB hotplugging.&n; *&n; * What Matches:&n; *&n; * The &quot;match_flags&quot; element in a usb_device_id controls which&n; * members are used.  If the corresponding bit is set, the&n; * value in the device_id must match its corresponding member&n; * in the device or interface descriptor, or else the device_id&n; * does not match.&n; *&n; * &quot;driver_info&quot; is normally used only by device drivers,&n; * but you can create a wildcard &quot;matches anything&quot; usb_device_id&n; * as a driver&squot;s &quot;modules.usbmap&quot; entry if you provide an id with&n; * only a nonzero &quot;driver_info&quot; field.  If you do this, the USB device&n; * driver&squot;s probe() routine should use additional intelligence to&n; * decide whether to bind to the specified interface.&n; * &n; * What Makes Good usb_device_id Tables:&n; *&n; * The match algorithm is very simple, so that intelligence in&n; * driver selection must come from smart driver id records.&n; * Unless you have good reasons to use another selection policy,&n; * provide match elements only in related groups, and order match&n; * specifiers from specific to general.  Use the macros provided&n; * for that purpose if you can.&n; *&n; * The most specific match specifiers use device descriptor&n; * data.  These are commonly used with product-specific matches;&n; * the USB_DEVICE macro lets you provide vendor and product IDs,&n; * and you can also match against ranges of product revisions.&n; * These are widely used for devices with application or vendor&n; * specific bDeviceClass values.&n; *&n; * Matches based on device class/subclass/protocol specifications&n; * are slightly more general; use the USB_DEVICE_INFO macro, or&n; * its siblings.  These are used with single-function devices&n; * where bDeviceClass doesn&squot;t specify that each interface has&n; * its own class. &n; *&n; * Matches based on interface class/subclass/protocol are the&n; * most general; they let drivers bind to any interface on a&n; * multiple-function device.  Use the USB_INTERFACE_INFO&n; * macro, or its siblings, to match class-per-interface style &n; * devices (as recorded in bDeviceClass).&n; *  &n; * Within those groups, remember that not all combinations are&n; * meaningful.  For example, don&squot;t give a product version range&n; * without vendor and product IDs; or specify a protocol without&n; * its associated class and subclass.&n; */
r_const
r_struct
id|usb_device_id
op_star
DECL|function|usb_match_id
id|usb_match_id
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_struct
id|usb_interface
op_star
id|interface
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
(brace
r_struct
id|usb_interface_descriptor
op_star
id|intf
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* proc_connectinfo in devio.c may call us with id == NULL. */
r_if
c_cond
(paren
id|id
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* It is important to check that id-&gt;driver_info is nonzero,&n;&t;   since an entry that is all zeroes except for a nonzero&n;&t;   id-&gt;driver_info is the way to create an entry that&n;&t;   indicates that the driver want to examine every&n;&t;   device and interface. */
r_for
c_loop
(paren
suffix:semicolon
id|id-&gt;idVendor
op_logical_or
id|id-&gt;bDeviceClass
op_logical_or
id|id-&gt;bInterfaceClass
op_logical_or
id|id-&gt;driver_info
suffix:semicolon
id|id
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|USB_DEVICE_ID_MATCH_VENDOR
)paren
op_logical_and
id|id-&gt;idVendor
op_ne
id|dev-&gt;descriptor.idVendor
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|USB_DEVICE_ID_MATCH_PRODUCT
)paren
op_logical_and
id|id-&gt;idProduct
op_ne
id|dev-&gt;descriptor.idProduct
)paren
r_continue
suffix:semicolon
multiline_comment|/* No need to test id-&gt;bcdDevice_lo != 0, since 0 is never&n;&t;&t;   greater than any unsigned number. */
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|USB_DEVICE_ID_MATCH_DEV_LO
)paren
op_logical_and
(paren
id|id-&gt;bcdDevice_lo
OG
id|dev-&gt;descriptor.bcdDevice
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|USB_DEVICE_ID_MATCH_DEV_HI
)paren
op_logical_and
(paren
id|id-&gt;bcdDevice_hi
OL
id|dev-&gt;descriptor.bcdDevice
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|USB_DEVICE_ID_MATCH_DEV_CLASS
)paren
op_logical_and
(paren
id|id-&gt;bDeviceClass
op_ne
id|dev-&gt;descriptor.bDeviceClass
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|USB_DEVICE_ID_MATCH_DEV_SUBCLASS
)paren
op_logical_and
(paren
id|id-&gt;bDeviceSubClass
op_ne
id|dev-&gt;descriptor.bDeviceSubClass
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|USB_DEVICE_ID_MATCH_DEV_PROTOCOL
)paren
op_logical_and
(paren
id|id-&gt;bDeviceProtocol
op_ne
id|dev-&gt;descriptor.bDeviceProtocol
)paren
)paren
r_continue
suffix:semicolon
id|intf
op_assign
op_amp
id|interface-&gt;altsetting
(braket
id|interface-&gt;act_altsetting
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|USB_DEVICE_ID_MATCH_INT_CLASS
)paren
op_logical_and
(paren
id|id-&gt;bInterfaceClass
op_ne
id|intf-&gt;bInterfaceClass
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|USB_DEVICE_ID_MATCH_INT_SUBCLASS
)paren
op_logical_and
(paren
id|id-&gt;bInterfaceSubClass
op_ne
id|intf-&gt;bInterfaceSubClass
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|USB_DEVICE_ID_MATCH_INT_PROTOCOL
)paren
op_logical_and
(paren
id|id-&gt;bInterfaceProtocol
op_ne
id|intf-&gt;bInterfaceProtocol
)paren
)paren
r_continue
suffix:semicolon
r_return
id|id
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * This entrypoint gets called for each new device.&n; *&n; * We now walk the list of registered USB drivers,&n; * looking for one that will accept this interface.&n; *&n; * &quot;New Style&quot; drivers use a table describing the devices and interfaces&n; * they handle.  Those tables are available to user mode tools deciding&n; * whether to load driver modules for a new device.&n; *&n; * The probe return value is changed to be a private pointer.  This way&n; * the drivers don&squot;t have to dig around in our structures to set the&n; * private pointer if they only need one interface. &n; *&n; * Returns: 0 if a driver accepted the interface, -1 otherwise&n; */
DECL|function|usb_find_interface_driver
r_static
r_int
id|usb_find_interface_driver
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|ifnum
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_struct
id|usb_interface
op_star
id|interface
suffix:semicolon
r_void
op_star
r_private
suffix:semicolon
r_const
r_struct
id|usb_device_id
op_star
id|id
suffix:semicolon
r_struct
id|usb_driver
op_star
id|driver
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|dev
)paren
op_logical_or
(paren
id|ifnum
op_ge
id|dev-&gt;actconfig-&gt;bNumInterfaces
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;bad find_interface_driver params&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|dev-&gt;serialize
)paren
suffix:semicolon
id|interface
op_assign
id|dev-&gt;actconfig-&gt;interface
op_plus
id|ifnum
suffix:semicolon
r_if
c_cond
(paren
id|usb_interface_claimed
c_func
(paren
id|interface
)paren
)paren
r_goto
id|out_err
suffix:semicolon
r_private
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
id|usb_driver_list.next
suffix:semicolon
id|tmp
op_ne
op_amp
id|usb_driver_list
suffix:semicolon
)paren
(brace
id|driver
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|usb_driver
comma
id|driver_list
)paren
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|driver-&gt;owner
)paren
id|__MOD_INC_USE_COUNT
c_func
(paren
id|driver-&gt;owner
)paren
suffix:semicolon
id|id
op_assign
id|driver-&gt;id_table
suffix:semicolon
multiline_comment|/* new style driver? */
r_if
c_cond
(paren
id|id
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|interface-&gt;num_altsetting
suffix:semicolon
id|i
op_increment
)paren
(brace
id|interface-&gt;act_altsetting
op_assign
id|i
suffix:semicolon
id|id
op_assign
id|usb_match_id
c_func
(paren
id|dev
comma
id|interface
comma
id|id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id
)paren
(brace
id|down
c_func
(paren
op_amp
id|driver-&gt;serialize
)paren
suffix:semicolon
r_private
op_assign
id|driver
op_member_access_from_pointer
id|probe
c_func
(paren
id|dev
comma
id|ifnum
comma
id|id
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|driver-&gt;serialize
)paren
suffix:semicolon
r_if
c_cond
(paren
r_private
op_ne
l_int|NULL
)paren
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* if driver not bound, leave defaults unchanged */
r_if
c_cond
(paren
r_private
op_eq
l_int|NULL
)paren
id|interface-&gt;act_altsetting
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* &quot;old style&quot; driver */
id|down
c_func
(paren
op_amp
id|driver-&gt;serialize
)paren
suffix:semicolon
r_private
op_assign
id|driver
op_member_access_from_pointer
id|probe
c_func
(paren
id|dev
comma
id|ifnum
comma
l_int|NULL
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|driver-&gt;serialize
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|driver-&gt;owner
)paren
id|__MOD_DEC_USE_COUNT
c_func
(paren
id|driver-&gt;owner
)paren
suffix:semicolon
multiline_comment|/* probe() may have changed the config on us */
id|interface
op_assign
id|dev-&gt;actconfig-&gt;interface
op_plus
id|ifnum
suffix:semicolon
r_if
c_cond
(paren
r_private
)paren
(brace
id|usb_driver_claim_interface
c_func
(paren
id|driver
comma
id|interface
comma
r_private
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|dev-&gt;serialize
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|out_err
suffix:colon
id|up
c_func
(paren
op_amp
id|dev-&gt;serialize
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_find_interface_driver_for_ifnum - finds a usb interface driver for the specified ifnum&n; * @dev: the device to use&n; * @ifnum: the interface number (bInterfaceNumber); not interface position!&n; *&n; * This converts a ifnum to ifpos via a call to usb_ifnum_to_ifpos and then&n; * calls usb_find_interface_driver() with the found ifpos.  Note&n; * usb_find_interface_driver&squot;s ifnum parameter is actually interface position.&n; */
DECL|function|usb_find_interface_driver_for_ifnum
r_int
id|usb_find_interface_driver_for_ifnum
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|ifnum
)paren
(brace
r_int
id|ifpos
op_assign
id|usb_ifnum_to_ifpos
c_func
(paren
id|dev
comma
id|ifnum
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
OG
id|ifpos
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|usb_find_interface_driver
c_func
(paren
id|dev
comma
id|ifpos
)paren
suffix:semicolon
)brace
macro_line|#ifdef&t;CONFIG_HOTPLUG
multiline_comment|/*&n; * USB hotplugging invokes what /proc/sys/kernel/hotplug says&n; * (normally /sbin/hotplug) when USB devices get added or removed.&n; *&n; * This invokes a user mode policy agent, typically helping to load driver&n; * or other modules, configure the device, and more.  Drivers can provide&n; * a MODULE_DEVICE_TABLE to help with module loading subtasks.&n; *&n; * Some synchronization is important: removes can&squot;t start processing&n; * before the add-device processing completes, and vice versa.  That keeps&n; * a stack of USB-related identifiers stable while they&squot;re in use.  If we&n; * know that agents won&squot;t complete after they return (such as by forking&n; * a process that completes later), it&squot;s enough to just waitpid() for the&n; * agent -- as is currently done.&n; *&n; * The reason: we know we&squot;re called either from khubd (the typical case)&n; * or from root hub initialization (init, kapmd, modprobe, etc).  In both&n; * cases, we know no other thread can recycle our address, since we must&n; * already have been serialized enough to prevent that.&n; */
DECL|function|call_policy
r_static
r_void
id|call_policy
(paren
r_char
op_star
id|verb
comma
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_char
op_star
id|argv
(braket
l_int|3
)braket
comma
op_star
op_star
id|envp
comma
op_star
id|buf
comma
op_star
id|scratch
suffix:semicolon
r_int
id|i
op_assign
l_int|0
comma
id|value
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hotplug_path
(braket
l_int|0
)braket
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|in_interrupt
(paren
)paren
)paren
(brace
id|dbg
(paren
l_string|&quot;In_interrupt&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|current-&gt;fs-&gt;root
)paren
(brace
multiline_comment|/* statically linked USB is initted rather early */
id|dbg
(paren
l_string|&quot;call_policy %s, num %d -- no FS yet&quot;
comma
id|verb
comma
id|dev-&gt;devnum
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;devnum
OL
l_int|0
)paren
(brace
id|dbg
(paren
l_string|&quot;device already deleted ??&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|envp
op_assign
(paren
r_char
op_star
op_star
)paren
id|kmalloc
(paren
l_int|20
op_star
r_sizeof
(paren
r_char
op_star
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|dbg
(paren
l_string|&quot;enomem&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|buf
op_assign
id|kmalloc
(paren
l_int|256
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|kfree
(paren
id|envp
)paren
suffix:semicolon
id|dbg
(paren
l_string|&quot;enomem2&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* only one standardized param to hotplug command: type */
id|argv
(braket
l_int|0
)braket
op_assign
id|hotplug_path
suffix:semicolon
id|argv
(braket
l_int|1
)braket
op_assign
l_string|&quot;usb&quot;
suffix:semicolon
id|argv
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* minimal command environment */
id|envp
(braket
id|i
op_increment
)braket
op_assign
l_string|&quot;HOME=/&quot;
suffix:semicolon
id|envp
(braket
id|i
op_increment
)braket
op_assign
l_string|&quot;PATH=/sbin:/bin:/usr/sbin:/usr/bin&quot;
suffix:semicolon
macro_line|#ifdef&t;DEBUG
multiline_comment|/* hint that policy agent should enter no-stdout debug mode */
id|envp
(braket
id|i
op_increment
)braket
op_assign
l_string|&quot;DEBUG=kernel&quot;
suffix:semicolon
macro_line|#endif
multiline_comment|/* extensible set of named bus-specific parameters,&n;&t; * supporting multiple driver selection algorithms.&n;&t; */
id|scratch
op_assign
id|buf
suffix:semicolon
multiline_comment|/* action:  add, remove */
id|envp
(braket
id|i
op_increment
)braket
op_assign
id|scratch
suffix:semicolon
id|scratch
op_add_assign
id|sprintf
(paren
id|scratch
comma
l_string|&quot;ACTION=%s&quot;
comma
id|verb
)paren
op_plus
l_int|1
suffix:semicolon
macro_line|#ifdef&t;CONFIG_USB_DEVICEFS
multiline_comment|/* If this is available, userspace programs can directly read&n;&t; * all the device descriptors we don&squot;t tell them about.  Or&n;&t; * even act as usermode drivers.&n;&t; *&n;&t; * FIXME reduce hardwired intelligence here&n;&t; */
id|envp
(braket
id|i
op_increment
)braket
op_assign
l_string|&quot;DEVFS=/proc/bus/usb&quot;
suffix:semicolon
id|envp
(braket
id|i
op_increment
)braket
op_assign
id|scratch
suffix:semicolon
id|scratch
op_add_assign
id|sprintf
(paren
id|scratch
comma
l_string|&quot;DEVICE=/proc/bus/usb/%03d/%03d&quot;
comma
id|dev-&gt;bus-&gt;busnum
comma
id|dev-&gt;devnum
)paren
op_plus
l_int|1
suffix:semicolon
macro_line|#endif
multiline_comment|/* per-device configuration hacks are common */
id|envp
(braket
id|i
op_increment
)braket
op_assign
id|scratch
suffix:semicolon
id|scratch
op_add_assign
id|sprintf
(paren
id|scratch
comma
l_string|&quot;PRODUCT=%x/%x/%x&quot;
comma
id|dev-&gt;descriptor.idVendor
comma
id|dev-&gt;descriptor.idProduct
comma
id|dev-&gt;descriptor.bcdDevice
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* class-based driver binding models */
id|envp
(braket
id|i
op_increment
)braket
op_assign
id|scratch
suffix:semicolon
id|scratch
op_add_assign
id|sprintf
(paren
id|scratch
comma
l_string|&quot;TYPE=%d/%d/%d&quot;
comma
id|dev-&gt;descriptor.bDeviceClass
comma
id|dev-&gt;descriptor.bDeviceSubClass
comma
id|dev-&gt;descriptor.bDeviceProtocol
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;descriptor.bDeviceClass
op_eq
l_int|0
)paren
(brace
r_int
id|alt
op_assign
id|dev-&gt;actconfig-&gt;interface
(braket
l_int|0
)braket
dot
id|act_altsetting
suffix:semicolon
multiline_comment|/* a simple/common case: one config, one interface, one driver&n;&t;&t; * with current altsetting being a reasonable setting.&n;&t;&t; * everything needs a smart agent and usbfs; or can rely on&n;&t;&t; * device-specific binding policies.&n;&t;&t; */
id|envp
(braket
id|i
op_increment
)braket
op_assign
id|scratch
suffix:semicolon
id|scratch
op_add_assign
id|sprintf
(paren
id|scratch
comma
l_string|&quot;INTERFACE=%d/%d/%d&quot;
comma
id|dev-&gt;actconfig-&gt;interface
(braket
l_int|0
)braket
dot
id|altsetting
(braket
id|alt
)braket
dot
id|bInterfaceClass
comma
id|dev-&gt;actconfig-&gt;interface
(braket
l_int|0
)braket
dot
id|altsetting
(braket
id|alt
)braket
dot
id|bInterfaceSubClass
comma
id|dev-&gt;actconfig-&gt;interface
(braket
l_int|0
)braket
dot
id|altsetting
(braket
id|alt
)braket
dot
id|bInterfaceProtocol
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* INTERFACE-0, INTERFACE-1, ... ? */
)brace
id|envp
(braket
id|i
op_increment
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* assert: (scratch - buf) &lt; sizeof buf */
multiline_comment|/* NOTE: user mode daemons can call the agents too */
id|dbg
(paren
l_string|&quot;kusbd: %s %s %d&quot;
comma
id|argv
(braket
l_int|0
)braket
comma
id|verb
comma
id|dev-&gt;devnum
)paren
suffix:semicolon
id|value
op_assign
id|call_usermodehelper
(paren
id|argv
(braket
l_int|0
)braket
comma
id|argv
comma
id|envp
)paren
suffix:semicolon
id|kfree
(paren
id|buf
)paren
suffix:semicolon
id|kfree
(paren
id|envp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_ne
l_int|0
)paren
id|dbg
(paren
l_string|&quot;kusbd policy returned 0x%x&quot;
comma
id|value
)paren
suffix:semicolon
)brace
macro_line|#else
r_static
r_inline
r_void
DECL|function|call_policy
id|call_policy
(paren
r_char
op_star
id|verb
comma
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
)brace
macro_line|#endif&t;/* CONFIG_HOTPLUG */
multiline_comment|/* driverfs files */
multiline_comment|/* devices have one current configuration, with one&n; * or more interfaces that are used concurrently &n; */
r_static
id|ssize_t
DECL|function|show_config
id|show_config
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
id|off
)paren
(brace
r_struct
id|usb_device
op_star
id|udev
suffix:semicolon
r_if
c_cond
(paren
id|off
)paren
r_return
l_int|0
suffix:semicolon
id|udev
op_assign
id|list_entry
(paren
id|dev
comma
r_struct
id|usb_device
comma
id|dev
)paren
suffix:semicolon
r_return
id|sprintf
(paren
id|buf
comma
l_string|&quot;%u&bslash;n&quot;
comma
id|udev-&gt;actconfig-&gt;bConfigurationValue
)paren
suffix:semicolon
)brace
DECL|variable|usb_config_entry
r_static
r_struct
id|driver_file_entry
id|usb_config_entry
op_assign
(brace
id|name
suffix:colon
l_string|&quot;configuration&quot;
comma
id|mode
suffix:colon
id|S_IRUGO
comma
id|show
suffix:colon
id|show_config
comma
)brace
suffix:semicolon
multiline_comment|/* interfaces have one current setting; alternates&n; * can have different endpoints and class info.&n; */
r_static
id|ssize_t
DECL|function|show_altsetting
id|show_altsetting
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
id|off
)paren
(brace
r_struct
id|usb_interface
op_star
id|interface
suffix:semicolon
r_if
c_cond
(paren
id|off
)paren
r_return
l_int|0
suffix:semicolon
id|interface
op_assign
id|list_entry
(paren
id|dev
comma
r_struct
id|usb_interface
comma
id|dev
)paren
suffix:semicolon
r_return
id|sprintf
(paren
id|buf
comma
l_string|&quot;%u&bslash;n&quot;
comma
id|interface-&gt;altsetting-&gt;bAlternateSetting
)paren
suffix:semicolon
)brace
DECL|variable|usb_altsetting_entry
r_static
r_struct
id|driver_file_entry
id|usb_altsetting_entry
op_assign
(brace
id|name
suffix:colon
l_string|&quot;altsetting&quot;
comma
id|mode
suffix:colon
id|S_IRUGO
comma
id|show
suffix:colon
id|show_altsetting
comma
)brace
suffix:semicolon
multiline_comment|/* product driverfs file */
DECL|function|show_product
r_static
id|ssize_t
id|show_product
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
id|off
)paren
(brace
r_struct
id|usb_device
op_star
id|udev
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
id|off
)paren
r_return
l_int|0
suffix:semicolon
id|udev
op_assign
id|list_entry
(paren
id|dev
comma
r_struct
id|usb_device
comma
id|dev
)paren
suffix:semicolon
id|len
op_assign
id|usb_string
c_func
(paren
id|udev
comma
id|udev-&gt;descriptor.iProduct
comma
id|buf
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|buf
(braket
id|len
)braket
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|buf
(braket
id|len
op_plus
l_int|1
)braket
op_assign
l_int|0x00
suffix:semicolon
r_return
id|len
op_plus
l_int|1
suffix:semicolon
)brace
DECL|variable|usb_product_entry
r_static
r_struct
id|driver_file_entry
id|usb_product_entry
op_assign
(brace
id|name
suffix:colon
l_string|&quot;product&quot;
comma
id|mode
suffix:colon
id|S_IRUGO
comma
id|show
suffix:colon
id|show_product
comma
)brace
suffix:semicolon
multiline_comment|/* manufacturer driverfs file */
r_static
id|ssize_t
DECL|function|show_manufacturer
id|show_manufacturer
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
id|off
)paren
(brace
r_struct
id|usb_device
op_star
id|udev
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
id|off
)paren
r_return
l_int|0
suffix:semicolon
id|udev
op_assign
id|list_entry
(paren
id|dev
comma
r_struct
id|usb_device
comma
id|dev
)paren
suffix:semicolon
id|len
op_assign
id|usb_string
c_func
(paren
id|udev
comma
id|udev-&gt;descriptor.iManufacturer
comma
id|buf
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|buf
(braket
id|len
)braket
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|buf
(braket
id|len
op_plus
l_int|1
)braket
op_assign
l_int|0x00
suffix:semicolon
r_return
id|len
op_plus
l_int|1
suffix:semicolon
)brace
DECL|variable|usb_manufacturer_entry
r_static
r_struct
id|driver_file_entry
id|usb_manufacturer_entry
op_assign
(brace
id|name
suffix:colon
l_string|&quot;manufacturer&quot;
comma
id|mode
suffix:colon
id|S_IRUGO
comma
id|show
suffix:colon
id|show_manufacturer
comma
)brace
suffix:semicolon
multiline_comment|/* serial number driverfs file */
r_static
id|ssize_t
DECL|function|show_serial
id|show_serial
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
id|off
)paren
(brace
r_struct
id|usb_device
op_star
id|udev
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
id|off
)paren
r_return
l_int|0
suffix:semicolon
id|udev
op_assign
id|list_entry
(paren
id|dev
comma
r_struct
id|usb_device
comma
id|dev
)paren
suffix:semicolon
id|len
op_assign
id|usb_string
c_func
(paren
id|udev
comma
id|udev-&gt;descriptor.iSerialNumber
comma
id|buf
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|buf
(braket
id|len
)braket
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|buf
(braket
id|len
op_plus
l_int|1
)braket
op_assign
l_int|0x00
suffix:semicolon
r_return
id|len
op_plus
l_int|1
suffix:semicolon
)brace
DECL|variable|usb_serial_entry
r_static
r_struct
id|driver_file_entry
id|usb_serial_entry
op_assign
(brace
id|name
suffix:colon
l_string|&quot;serial&quot;
comma
id|mode
suffix:colon
id|S_IRUGO
comma
id|show
suffix:colon
id|show_serial
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * This entrypoint gets called for each new device.&n; *&n; * All interfaces are scanned for matching drivers.&n; */
DECL|function|usb_find_drivers
r_static
r_void
id|usb_find_drivers
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_int
id|ifnum
suffix:semicolon
r_int
id|rejected
op_assign
l_int|0
suffix:semicolon
r_int
id|claimed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* FIXME should get called for each new configuration not just the&n;&t; * first one for a device. switching configs (or altesettings) should&n;&t; * undo driverfs and HCD state for the previous interfaces.&n;&t; */
r_for
c_loop
(paren
id|ifnum
op_assign
l_int|0
suffix:semicolon
id|ifnum
OL
id|dev-&gt;actconfig-&gt;bNumInterfaces
suffix:semicolon
id|ifnum
op_increment
)paren
(brace
r_struct
id|usb_interface
op_star
id|interface
op_assign
op_amp
id|dev-&gt;actconfig-&gt;interface
(braket
id|ifnum
)braket
suffix:semicolon
r_struct
id|usb_interface_descriptor
op_star
id|desc
op_assign
id|interface-&gt;altsetting
suffix:semicolon
multiline_comment|/* register this interface with driverfs */
id|interface-&gt;dev.parent
op_assign
op_amp
id|dev-&gt;dev
suffix:semicolon
id|interface-&gt;dev.bus
op_assign
op_amp
id|usb_bus_type
suffix:semicolon
id|sprintf
(paren
op_amp
id|interface-&gt;dev.bus_id
(braket
l_int|0
)braket
comma
l_string|&quot;if%d&quot;
comma
id|interface-&gt;altsetting-&gt;bInterfaceNumber
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|desc-&gt;iInterface
op_logical_or
id|usb_string
(paren
id|dev
comma
id|desc-&gt;iInterface
comma
id|interface-&gt;dev.name
comma
r_sizeof
id|interface-&gt;dev.name
)paren
op_le
l_int|0
)paren
(brace
multiline_comment|/* typically devices won&squot;t bother with interface&n;&t;&t;&t; * descriptions; this is the normal case.  an&n;&t;&t;&t; * interface&squot;s driver might describe it better.&n;&t;&t;&t; * (also: iInterface is per-altsetting ...)&n;&t;&t;&t; */
id|sprintf
(paren
op_amp
id|interface-&gt;dev.name
(braket
l_int|0
)braket
comma
l_string|&quot;usb-%s-%s interface %d&quot;
comma
id|dev-&gt;bus-&gt;bus_name
comma
id|dev-&gt;devpath
comma
id|interface-&gt;altsetting-&gt;bInterfaceNumber
)paren
suffix:semicolon
)brace
id|device_register
(paren
op_amp
id|interface-&gt;dev
)paren
suffix:semicolon
id|device_create_file
(paren
op_amp
id|interface-&gt;dev
comma
op_amp
id|usb_altsetting_entry
)paren
suffix:semicolon
multiline_comment|/* if this interface hasn&squot;t already been claimed */
r_if
c_cond
(paren
op_logical_neg
id|usb_interface_claimed
c_func
(paren
id|interface
)paren
)paren
(brace
r_if
c_cond
(paren
id|usb_find_interface_driver
c_func
(paren
id|dev
comma
id|ifnum
)paren
)paren
id|rejected
op_increment
suffix:semicolon
r_else
id|claimed
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rejected
)paren
id|dbg
c_func
(paren
l_string|&quot;unhandled interfaces on device&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|claimed
)paren
(brace
id|warn
c_func
(paren
l_string|&quot;USB device %d (vend/prod 0x%x/0x%x) is not claimed by any active driver.&quot;
comma
id|dev-&gt;devnum
comma
id|dev-&gt;descriptor.idVendor
comma
id|dev-&gt;descriptor.idProduct
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|usb_show_device
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
multiline_comment|/**&n; * usb_alloc_dev - allocate a usb device structure (usbcore-internal)&n; * @parent: hub to which device is connected&n; * @bus: bus used to access the device&n; * Context: !in_interrupt ()&n; *&n; * Only hub drivers (including virtual root hub drivers for host&n; * controllers) should ever call this.&n; *&n; * This call is synchronous, and may not be used in an interrupt context.&n; */
DECL|function|usb_alloc_dev
r_struct
id|usb_device
op_star
id|usb_alloc_dev
c_func
(paren
r_struct
id|usb_device
op_star
id|parent
comma
r_struct
id|usb_bus
op_star
id|bus
)paren
(brace
r_struct
id|usb_device
op_star
id|dev
suffix:semicolon
id|dev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|dev
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|dev
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|dev
)paren
)paren
suffix:semicolon
id|usb_bus_get
c_func
(paren
id|bus
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parent
)paren
id|dev-&gt;devpath
(braket
l_int|0
)braket
op_assign
l_char|&squot;/&squot;
suffix:semicolon
id|dev-&gt;bus
op_assign
id|bus
suffix:semicolon
id|dev-&gt;parent
op_assign
id|parent
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|dev-&gt;refcnt
comma
l_int|1
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|dev-&gt;filelist
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|dev-&gt;serialize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;bus-&gt;op-&gt;allocate
)paren
id|dev-&gt;bus-&gt;op
op_member_access_from_pointer
id|allocate
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|dev
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_get_dev - increments the reference count of the device&n; * @dev: the device being referenced&n; *&n; * Each live reference to a device should be refcounted.&n; *&n; * Drivers for USB interfaces should normally record such references in&n; * their probe() methods, when they bind to an interface, and release&n; * them by calling usb_put_dev(), in their disconnect() methods.&n; *&n; * A pointer to the device with the incremented reference counter is returned.&n; */
DECL|function|usb_get_dev
r_struct
id|usb_device
op_star
id|usb_get_dev
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev
)paren
(brace
id|atomic_inc
(paren
op_amp
id|dev-&gt;refcnt
)paren
suffix:semicolon
r_return
id|dev
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_free_dev - free a usb device structure when all users of it are finished.&n; * @dev: device that&squot;s been disconnected&n; * Context: !in_interrupt ()&n; *&n; * Must be called when a user of a device is finished with it.  When the last&n; * user of the device calls this function, the memory of the device is freed.&n; *&n; * Used by hub and virtual root hub drivers.  The device is completely&n; * gone, everything is cleaned up, so it&squot;s time to get rid of these last&n; * records of this device.&n; */
DECL|function|usb_free_dev
r_void
id|usb_free_dev
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|dev-&gt;refcnt
)paren
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;bus-&gt;op-&gt;deallocate
)paren
id|dev-&gt;bus-&gt;op
op_member_access_from_pointer
id|deallocate
c_func
(paren
id|dev
)paren
suffix:semicolon
id|usb_destroy_configuration
(paren
id|dev
)paren
suffix:semicolon
id|usb_bus_put
(paren
id|dev-&gt;bus
)paren
suffix:semicolon
id|kfree
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * usb_get_current_frame_number - return current bus frame number&n; * @dev: the device whose bus is being queried&n; *&n; * Returns the current frame number for the USB host controller&n; * used with the given USB device.  This can be used when scheduling&n; * isochronous requests.&n; *&n; * Note that different kinds of host controller have different&n; * &quot;scheduling horizons&quot;.  While one type might support scheduling only&n; * 32 frames into the future, others could support scheduling up to&n; * 1024 frames into the future.&n; */
DECL|function|usb_get_current_frame_number
r_int
id|usb_get_current_frame_number
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_return
id|dev-&gt;bus-&gt;op-&gt;get_frame_number
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------*/
multiline_comment|/* for returning string descriptors in UTF-16LE */
DECL|function|ascii2utf
r_static
r_int
id|ascii2utf
(paren
r_char
op_star
id|ascii
comma
id|__u8
op_star
id|utf
comma
r_int
id|utfmax
)paren
(brace
r_int
id|retval
suffix:semicolon
r_for
c_loop
(paren
id|retval
op_assign
l_int|0
suffix:semicolon
op_star
id|ascii
op_logical_and
id|utfmax
OG
l_int|1
suffix:semicolon
id|utfmax
op_sub_assign
l_int|2
comma
id|retval
op_add_assign
l_int|2
)paren
(brace
op_star
id|utf
op_increment
op_assign
op_star
id|ascii
op_increment
op_amp
l_int|0x7f
suffix:semicolon
op_star
id|utf
op_increment
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * root_hub_string is used by each host controller&squot;s root hub code,&n; * so that they&squot;re identified consistently throughout the system.&n; */
DECL|function|usb_root_hub_string
r_int
id|usb_root_hub_string
(paren
r_int
id|id
comma
r_int
id|serial
comma
r_char
op_star
id|type
comma
id|__u8
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_char
id|buf
(braket
l_int|30
)braket
suffix:semicolon
singleline_comment|// assert (len &gt; (2 * (sizeof (buf) + 1)));
singleline_comment|// assert (strlen (type) &lt;= 8);
singleline_comment|// language ids
r_if
c_cond
(paren
id|id
op_eq
l_int|0
)paren
(brace
op_star
id|data
op_increment
op_assign
l_int|4
suffix:semicolon
op_star
id|data
op_increment
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* 4 bytes data */
op_star
id|data
op_increment
op_assign
l_int|0
suffix:semicolon
op_star
id|data
op_increment
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* some language id */
r_return
l_int|4
suffix:semicolon
singleline_comment|// serial number
)brace
r_else
r_if
c_cond
(paren
id|id
op_eq
l_int|1
)paren
(brace
id|sprintf
(paren
id|buf
comma
l_string|&quot;%x&quot;
comma
id|serial
)paren
suffix:semicolon
singleline_comment|// product description
)brace
r_else
r_if
c_cond
(paren
id|id
op_eq
l_int|2
)paren
(brace
id|sprintf
(paren
id|buf
comma
l_string|&quot;USB %s Root Hub&quot;
comma
id|type
)paren
suffix:semicolon
singleline_comment|// id 3 == vendor description
singleline_comment|// unsupported IDs --&gt; &quot;stall&quot;
)brace
r_else
r_return
l_int|0
suffix:semicolon
id|data
(braket
l_int|0
)braket
op_assign
l_int|2
op_plus
id|ascii2utf
(paren
id|buf
comma
id|data
op_plus
l_int|2
comma
id|len
op_minus
l_int|2
)paren
suffix:semicolon
id|data
(braket
l_int|1
)braket
op_assign
l_int|3
suffix:semicolon
r_return
id|data
(braket
l_int|0
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; * __usb_get_extra_descriptor() finds a descriptor of specific type in the&n; * extra field of the interface and endpoint descriptor structs.&n; */
DECL|function|__usb_get_extra_descriptor
r_int
id|__usb_get_extra_descriptor
c_func
(paren
r_char
op_star
id|buffer
comma
r_int
id|size
comma
r_int
r_char
id|type
comma
r_void
op_star
op_star
id|ptr
)paren
(brace
r_struct
id|usb_descriptor_header
op_star
id|header
suffix:semicolon
r_while
c_loop
(paren
id|size
op_ge
r_sizeof
(paren
r_struct
id|usb_descriptor_header
)paren
)paren
(brace
id|header
op_assign
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
id|buffer
suffix:semicolon
r_if
c_cond
(paren
id|header-&gt;bLength
OL
l_int|2
)paren
(brace
id|err
c_func
(paren
l_string|&quot;invalid descriptor length of %d&quot;
comma
id|header-&gt;bLength
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|header-&gt;bDescriptorType
op_eq
id|type
)paren
(brace
op_star
id|ptr
op_assign
id|header
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|buffer
op_add_assign
id|header-&gt;bLength
suffix:semicolon
id|size
op_sub_assign
id|header-&gt;bLength
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_disconnect - disconnect a device (usbcore-internal)&n; * @pdev: pointer to device being disconnected&n; * Context: !in_interrupt ()&n; *&n; * Something got disconnected. Get rid of it, and all of its children.&n; *&n; * Only hub drivers (including virtual root hub drivers for host&n; * controllers) should ever call this.&n; *&n; * This call is synchronous, and may not be used in an interrupt context.&n; */
DECL|function|usb_disconnect
r_void
id|usb_disconnect
c_func
(paren
r_struct
id|usb_device
op_star
op_star
id|pdev
)paren
(brace
r_struct
id|usb_device
op_star
id|dev
op_assign
op_star
id|pdev
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
suffix:semicolon
op_star
id|pdev
op_assign
l_int|NULL
suffix:semicolon
id|info
c_func
(paren
l_string|&quot;USB disconnect on device %d&quot;
comma
id|dev-&gt;devnum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;actconfig
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;actconfig-&gt;bNumInterfaces
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|usb_interface
op_star
id|interface
op_assign
op_amp
id|dev-&gt;actconfig-&gt;interface
(braket
id|i
)braket
suffix:semicolon
r_struct
id|usb_driver
op_star
id|driver
op_assign
id|interface-&gt;driver
suffix:semicolon
r_if
c_cond
(paren
id|driver
)paren
(brace
r_if
c_cond
(paren
id|driver-&gt;owner
)paren
id|__MOD_INC_USE_COUNT
c_func
(paren
id|driver-&gt;owner
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|driver-&gt;serialize
)paren
suffix:semicolon
id|driver
op_member_access_from_pointer
id|disconnect
c_func
(paren
id|dev
comma
id|interface-&gt;private_data
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|driver-&gt;serialize
)paren
suffix:semicolon
multiline_comment|/* if driver-&gt;disconnect didn&squot;t release the interface */
r_if
c_cond
(paren
id|interface-&gt;driver
)paren
id|usb_driver_release_interface
c_func
(paren
id|driver
comma
id|interface
)paren
suffix:semicolon
multiline_comment|/* we don&squot;t need the driver any longer */
r_if
c_cond
(paren
id|driver-&gt;owner
)paren
id|__MOD_DEC_USE_COUNT
c_func
(paren
id|driver-&gt;owner
)paren
suffix:semicolon
)brace
multiline_comment|/* remove our device node for this interface */
id|put_device
c_func
(paren
op_amp
id|interface-&gt;dev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Free up all the children.. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|USB_MAXCHILDREN
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|usb_device
op_star
op_star
id|child
op_assign
id|dev-&gt;children
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
op_star
id|child
)paren
id|usb_disconnect
c_func
(paren
id|child
)paren
suffix:semicolon
)brace
multiline_comment|/* Let policy agent unload modules etc */
id|call_policy
(paren
l_string|&quot;remove&quot;
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/* Free the device number and remove the /proc/bus/usb entry */
r_if
c_cond
(paren
id|dev-&gt;devnum
OG
l_int|0
)paren
(brace
id|clear_bit
c_func
(paren
id|dev-&gt;devnum
comma
id|dev-&gt;bus-&gt;devmap.devicemap
)paren
suffix:semicolon
id|usbfs_remove_device
c_func
(paren
id|dev
)paren
suffix:semicolon
id|put_device
c_func
(paren
op_amp
id|dev-&gt;dev
)paren
suffix:semicolon
)brace
multiline_comment|/* Decrement the reference count, it&squot;ll auto free everything when */
multiline_comment|/* it hits 0 which could very well be now */
id|usb_put_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_connect - connects a new device during enumeration (usbcore-internal)&n; * @dev: partially enumerated device&n; *&n; * Connect a new USB device. This basically just initializes&n; * the USB device information and sets up the topology - it&squot;s&n; * up to the low-level driver to reset the port and actually&n; * do the setup (the upper levels don&squot;t know how to do that).&n; *&n; * Only hub drivers (including virtual root hub drivers for host&n; * controllers) should ever call this.&n; */
DECL|function|usb_connect
r_void
id|usb_connect
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_int
id|devnum
suffix:semicolon
singleline_comment|// FIXME needs locking for SMP!!
multiline_comment|/* why? this is called only from the hub thread, &n;&t; * which hopefully doesn&squot;t run on multiple CPU&squot;s simultaneously 8-)&n;&t; * ... it&squot;s also called from modprobe/rmmod/apmd threads as part&n;&t; * of virtual root hub init/reinit.  In the init case, the hub code &n;&t; * won&squot;t have seen this, but not so for reinit ... &n;&t; */
id|dev-&gt;descriptor.bMaxPacketSize0
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* Start off at 8 bytes  */
macro_line|#ifndef DEVNUM_ROUND_ROBIN
id|devnum
op_assign
id|find_next_zero_bit
c_func
(paren
id|dev-&gt;bus-&gt;devmap.devicemap
comma
l_int|128
comma
l_int|1
)paren
suffix:semicolon
macro_line|#else&t;/* round_robin alloc of devnums */
multiline_comment|/* Try to allocate the next devnum beginning at bus-&gt;devnum_next. */
id|devnum
op_assign
id|find_next_zero_bit
c_func
(paren
id|dev-&gt;bus-&gt;devmap.devicemap
comma
l_int|128
comma
id|dev-&gt;bus-&gt;devnum_next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devnum
op_ge
l_int|128
)paren
id|devnum
op_assign
id|find_next_zero_bit
c_func
(paren
id|dev-&gt;bus-&gt;devmap.devicemap
comma
l_int|128
comma
l_int|1
)paren
suffix:semicolon
id|dev-&gt;bus-&gt;devnum_next
op_assign
(paren
id|devnum
op_ge
l_int|127
ques
c_cond
l_int|1
suffix:colon
id|devnum
op_plus
l_int|1
)paren
suffix:semicolon
macro_line|#endif&t;/* round_robin alloc of devnums */
r_if
c_cond
(paren
id|devnum
OL
l_int|128
)paren
(brace
id|set_bit
c_func
(paren
id|devnum
comma
id|dev-&gt;bus-&gt;devmap.devicemap
)paren
suffix:semicolon
id|dev-&gt;devnum
op_assign
id|devnum
suffix:semicolon
)brace
)brace
singleline_comment|// hub-only!! ... and only exported for reset/reinit path.
singleline_comment|// otherwise used internally, for usb_new_device()
DECL|function|usb_set_address
r_int
id|usb_set_address
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_return
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_snddefctrl
c_func
(paren
id|dev
)paren
comma
id|USB_REQ_SET_ADDRESS
comma
singleline_comment|// FIXME USB_CTRL_SET_TIMEOUT
l_int|0
comma
id|dev-&gt;devnum
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
op_star
id|USB_CTRL_GET_TIMEOUT
)paren
suffix:semicolon
)brace
multiline_comment|/* improve on the default device description, if we can ... and&n; * while we&squot;re at it, maybe show the vendor and product strings.&n; */
DECL|function|set_device_description
r_static
r_void
id|set_device_description
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_char
op_star
id|buf
comma
op_star
id|here
comma
op_star
id|end
suffix:semicolon
r_int
id|mfgr
op_assign
id|dev-&gt;descriptor.iManufacturer
suffix:semicolon
r_int
id|prod
op_assign
id|dev-&gt;descriptor.iProduct
suffix:semicolon
multiline_comment|/* set default; keep it if there are no strings */
id|sprintf
(paren
id|dev-&gt;dev.name
comma
l_string|&quot;USB device %04x:%04x&quot;
comma
id|dev-&gt;descriptor.idVendor
comma
id|dev-&gt;descriptor.idProduct
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mfgr
op_logical_and
op_logical_neg
id|prod
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|buf
op_assign
id|kmalloc
c_func
(paren
l_int|256
comma
id|GFP_KERNEL
)paren
)paren
)paren
r_return
suffix:semicolon
id|here
op_assign
id|dev-&gt;dev.name
suffix:semicolon
id|end
op_assign
id|here
op_plus
r_sizeof
id|dev-&gt;dev.name
op_minus
l_int|2
suffix:semicolon
op_star
id|end
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* much like pci ... describe as either:&n;&t; * - both strings:   &squot;product descr (vendor descr)&squot;&n;&t; * - product only:   &squot;product descr (USB device vvvv:pppp)&squot;&n;&t; * - vendor only:    &squot;USB device vvvv:pppp (vendor descr)&squot;&n;&t; * - neither string: &squot;USB device vvvv:pppp&squot;&n;&t; */
r_if
c_cond
(paren
id|prod
op_logical_and
id|usb_string
(paren
id|dev
comma
id|prod
comma
id|buf
comma
l_int|256
)paren
OG
l_int|0
)paren
(brace
id|strncpy
(paren
id|here
comma
id|buf
comma
id|end
op_minus
id|here
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
(paren
id|KERN_INFO
l_string|&quot;Product: %s&bslash;n&quot;
comma
id|buf
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|buf
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|prod
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|here
op_assign
id|strchr
(paren
id|here
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mfgr
op_logical_and
id|usb_string
(paren
id|dev
comma
id|mfgr
comma
id|buf
comma
l_int|256
)paren
OG
l_int|0
)paren
(brace
op_star
id|here
op_increment
op_assign
l_char|&squot; &squot;
suffix:semicolon
op_star
id|here
op_increment
op_assign
l_char|&squot;(&squot;
suffix:semicolon
id|strncpy
(paren
id|here
comma
id|buf
comma
id|end
op_minus
id|here
op_minus
l_int|1
)paren
suffix:semicolon
id|here
op_assign
id|strchr
(paren
id|here
comma
l_int|0
)paren
suffix:semicolon
op_star
id|here
op_increment
op_assign
l_char|&squot;)&squot;
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
(paren
id|KERN_INFO
l_string|&quot;Manufacturer: %s&bslash;n&quot;
comma
id|buf
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
r_if
c_cond
(paren
id|prod
op_ne
op_minus
l_int|1
)paren
id|snprintf
(paren
id|here
comma
id|end
op_minus
id|here
op_minus
l_int|1
comma
l_string|&quot; (USB device %04x:%04x)&quot;
comma
id|dev-&gt;descriptor.idVendor
comma
id|dev-&gt;descriptor.idProduct
)paren
suffix:semicolon
multiline_comment|/* both strings unavailable, keep the default */
)brace
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * By the time we get here, the device has gotten a new device ID&n; * and is in the default state. We need to identify the thing and&n; * get the ball rolling..&n; *&n; * Returns 0 for success, != 0 for error.&n; *&n; * This call is synchronous, and may not be used in an interrupt context.&n; *&n; * Only hub drivers (including virtual root hub drivers for host&n; * controllers) should ever call this.&n; */
DECL|macro|NEW_DEVICE_RETRYS
mdefine_line|#define NEW_DEVICE_RETRYS&t;2
DECL|macro|SET_ADDRESS_RETRYS
mdefine_line|#define SET_ADDRESS_RETRYS&t;2
DECL|function|usb_new_device
r_int
id|usb_new_device
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|j
suffix:semicolon
multiline_comment|/* USB v1.1 5.5.3 */
multiline_comment|/* We read the first 8 bytes from the device descriptor to get to */
multiline_comment|/*  the bMaxPacketSize0 field. Then we set the maximum packet size */
multiline_comment|/*  for the control pipe, and retrieve the rest */
id|dev-&gt;epmaxpacketin
(braket
l_int|0
)braket
op_assign
l_int|8
suffix:semicolon
id|dev-&gt;epmaxpacketout
(braket
l_int|0
)braket
op_assign
l_int|8
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NEW_DEVICE_RETRYS
suffix:semicolon
op_increment
id|i
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|SET_ADDRESS_RETRYS
suffix:semicolon
op_increment
id|j
)paren
(brace
id|err
op_assign
id|usb_set_address
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ge
l_int|0
)paren
r_break
suffix:semicolon
id|wait_ms
c_func
(paren
l_int|200
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;USB device not accepting new address=%d (error=%d)&quot;
comma
id|dev-&gt;devnum
comma
id|err
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|dev-&gt;devnum
comma
id|dev-&gt;bus-&gt;devmap.devicemap
)paren
suffix:semicolon
id|dev-&gt;devnum
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|wait_ms
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* Let the SET_ADDRESS settle */
id|err
op_assign
id|usb_get_descriptor
c_func
(paren
id|dev
comma
id|USB_DT_DEVICE
comma
l_int|0
comma
op_amp
id|dev-&gt;descriptor
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ge
l_int|8
)paren
r_break
suffix:semicolon
id|wait_ms
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
OL
l_int|8
)paren
(brace
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
id|err
c_func
(paren
l_string|&quot;USB device not responding, giving up (error=%d)&quot;
comma
id|err
)paren
suffix:semicolon
r_else
id|err
c_func
(paren
l_string|&quot;USB device descriptor short read (expected %i, got %i)&quot;
comma
l_int|8
comma
id|err
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|dev-&gt;devnum
comma
id|dev-&gt;bus-&gt;devmap.devicemap
)paren
suffix:semicolon
id|dev-&gt;devnum
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|dev-&gt;epmaxpacketin
(braket
l_int|0
)braket
op_assign
id|dev-&gt;descriptor.bMaxPacketSize0
suffix:semicolon
id|dev-&gt;epmaxpacketout
(braket
l_int|0
)braket
op_assign
id|dev-&gt;descriptor.bMaxPacketSize0
suffix:semicolon
id|err
op_assign
id|usb_get_device_descriptor
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
(paren
r_int
)paren
r_sizeof
(paren
id|dev-&gt;descriptor
)paren
)paren
(brace
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
id|err
c_func
(paren
l_string|&quot;unable to get device descriptor (error=%d)&quot;
comma
id|err
)paren
suffix:semicolon
r_else
id|err
c_func
(paren
l_string|&quot;USB device descriptor short read (expected %Zi, got %i)&quot;
comma
r_sizeof
(paren
id|dev-&gt;descriptor
)paren
comma
id|err
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|dev-&gt;devnum
comma
id|dev-&gt;bus-&gt;devmap.devicemap
)paren
suffix:semicolon
id|dev-&gt;devnum
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|err
op_assign
id|usb_get_configuration
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;unable to get device %d configuration (error=%d)&quot;
comma
id|dev-&gt;devnum
comma
id|err
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|dev-&gt;devnum
comma
id|dev-&gt;bus-&gt;devmap.devicemap
)paren
suffix:semicolon
id|dev-&gt;devnum
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* we set the default configuration here */
id|err
op_assign
id|usb_set_configuration
c_func
(paren
id|dev
comma
id|dev-&gt;config
(braket
l_int|0
)braket
dot
id|bConfigurationValue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|err
c_func
(paren
l_string|&quot;failed to set device %d default configuration (error=%d)&quot;
comma
id|dev-&gt;devnum
comma
id|err
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|dev-&gt;devnum
comma
id|dev-&gt;bus-&gt;devmap.devicemap
)paren
suffix:semicolon
id|dev-&gt;devnum
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;new device strings: Mfr=%d, Product=%d, SerialNumber=%d&quot;
comma
id|dev-&gt;descriptor.iManufacturer
comma
id|dev-&gt;descriptor.iProduct
comma
id|dev-&gt;descriptor.iSerialNumber
)paren
suffix:semicolon
id|set_device_description
(paren
id|dev
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|dev-&gt;descriptor.iSerialNumber
)paren
id|usb_show_string
c_func
(paren
id|dev
comma
l_string|&quot;SerialNumber&quot;
comma
id|dev-&gt;descriptor.iSerialNumber
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* register this device in the driverfs tree */
id|err
op_assign
id|device_register
(paren
op_amp
id|dev-&gt;dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|device_create_file
(paren
op_amp
id|dev-&gt;dev
comma
op_amp
id|usb_config_entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;descriptor.iManufacturer
)paren
id|device_create_file
(paren
op_amp
id|dev-&gt;dev
comma
op_amp
id|usb_manufacturer_entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;descriptor.iProduct
)paren
id|device_create_file
(paren
op_amp
id|dev-&gt;dev
comma
op_amp
id|usb_product_entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;descriptor.iSerialNumber
)paren
id|device_create_file
(paren
op_amp
id|dev-&gt;dev
comma
op_amp
id|usb_serial_entry
)paren
suffix:semicolon
multiline_comment|/* now that the basic setup is over, add a /proc/bus/usb entry */
id|usbfs_add_device
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* find drivers willing to handle this device */
id|usb_find_drivers
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* userspace may load modules and/or configure further */
id|call_policy
(paren
l_string|&quot;add&quot;
comma
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
DECL|function|usb_driver_get_list
r_struct
id|list_head
op_star
id|usb_driver_get_list
c_func
(paren
r_void
)paren
(brace
r_return
op_amp
id|usb_driver_list
suffix:semicolon
)brace
DECL|function|usb_bus_get_list
r_struct
id|list_head
op_star
id|usb_bus_get_list
c_func
(paren
r_void
)paren
(brace
r_return
op_amp
id|usb_bus_list
suffix:semicolon
)brace
macro_line|#endif
DECL|variable|usb_bus_type
r_struct
id|bus_type
id|usb_bus_type
op_assign
(brace
id|name
suffix:colon
l_string|&quot;usb&quot;
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Init&n; */
DECL|function|usb_init
r_static
r_int
id|__init
id|usb_init
c_func
(paren
r_void
)paren
(brace
id|bus_register
c_func
(paren
op_amp
id|usb_bus_type
)paren
suffix:semicolon
id|usb_major_init
c_func
(paren
)paren
suffix:semicolon
id|usbfs_init
c_func
(paren
)paren
suffix:semicolon
id|usb_hub_init
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Cleanup&n; */
DECL|function|usb_exit
r_static
r_void
id|__exit
id|usb_exit
c_func
(paren
r_void
)paren
(brace
id|put_bus
c_func
(paren
op_amp
id|usb_bus_type
)paren
suffix:semicolon
id|usb_major_cleanup
c_func
(paren
)paren
suffix:semicolon
id|usbfs_cleanup
c_func
(paren
)paren
suffix:semicolon
id|usb_hub_cleanup
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|usb_init
id|subsys_initcall
c_func
(paren
id|usb_init
)paren
suffix:semicolon
DECL|variable|usb_exit
id|module_exit
c_func
(paren
id|usb_exit
)paren
suffix:semicolon
multiline_comment|/*&n; * USB may be built into the kernel or be built as modules.&n; * These symbols are exported for device (or host controller)&n; * driver modules to use.&n; */
DECL|variable|usb_ifnum_to_ifpos
id|EXPORT_SYMBOL
c_func
(paren
id|usb_ifnum_to_ifpos
)paren
suffix:semicolon
DECL|variable|usb_ifnum_to_if
id|EXPORT_SYMBOL
c_func
(paren
id|usb_ifnum_to_if
)paren
suffix:semicolon
DECL|variable|usb_epnum_to_ep_desc
id|EXPORT_SYMBOL
c_func
(paren
id|usb_epnum_to_ep_desc
)paren
suffix:semicolon
DECL|variable|usb_register
id|EXPORT_SYMBOL
c_func
(paren
id|usb_register
)paren
suffix:semicolon
DECL|variable|usb_deregister
id|EXPORT_SYMBOL
c_func
(paren
id|usb_deregister
)paren
suffix:semicolon
DECL|variable|usb_scan_devices
id|EXPORT_SYMBOL
c_func
(paren
id|usb_scan_devices
)paren
suffix:semicolon
DECL|variable|usb_alloc_dev
id|EXPORT_SYMBOL
c_func
(paren
id|usb_alloc_dev
)paren
suffix:semicolon
DECL|variable|usb_free_dev
id|EXPORT_SYMBOL
c_func
(paren
id|usb_free_dev
)paren
suffix:semicolon
DECL|variable|usb_get_dev
id|EXPORT_SYMBOL
c_func
(paren
id|usb_get_dev
)paren
suffix:semicolon
DECL|variable|usb_hub_tt_clear_buffer
id|EXPORT_SYMBOL
c_func
(paren
id|usb_hub_tt_clear_buffer
)paren
suffix:semicolon
DECL|variable|usb_find_interface_driver_for_ifnum
id|EXPORT_SYMBOL
c_func
(paren
id|usb_find_interface_driver_for_ifnum
)paren
suffix:semicolon
DECL|variable|usb_driver_claim_interface
id|EXPORT_SYMBOL
c_func
(paren
id|usb_driver_claim_interface
)paren
suffix:semicolon
DECL|variable|usb_interface_claimed
id|EXPORT_SYMBOL
c_func
(paren
id|usb_interface_claimed
)paren
suffix:semicolon
DECL|variable|usb_driver_release_interface
id|EXPORT_SYMBOL
c_func
(paren
id|usb_driver_release_interface
)paren
suffix:semicolon
DECL|variable|usb_match_id
id|EXPORT_SYMBOL
c_func
(paren
id|usb_match_id
)paren
suffix:semicolon
DECL|variable|usb_root_hub_string
id|EXPORT_SYMBOL
c_func
(paren
id|usb_root_hub_string
)paren
suffix:semicolon
DECL|variable|usb_new_device
id|EXPORT_SYMBOL
c_func
(paren
id|usb_new_device
)paren
suffix:semicolon
DECL|variable|usb_reset_device
id|EXPORT_SYMBOL
c_func
(paren
id|usb_reset_device
)paren
suffix:semicolon
DECL|variable|usb_connect
id|EXPORT_SYMBOL
c_func
(paren
id|usb_connect
)paren
suffix:semicolon
DECL|variable|usb_disconnect
id|EXPORT_SYMBOL
c_func
(paren
id|usb_disconnect
)paren
suffix:semicolon
DECL|variable|__usb_get_extra_descriptor
id|EXPORT_SYMBOL
c_func
(paren
id|__usb_get_extra_descriptor
)paren
suffix:semicolon
DECL|variable|usb_get_current_frame_number
id|EXPORT_SYMBOL
c_func
(paren
id|usb_get_current_frame_number
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
