multiline_comment|/*&n; * drivers/usb/usb.c&n; *&n; * (C) Copyright Linus Torvalds 1999&n; * (C) Copyright Johannes Erdfelt 1999-2001&n; * (C) Copyright Andreas Gal 1999&n; * (C) Copyright Gregory P. Smith 1999&n; * (C) Copyright Deti Fliegl 1999 (new USB architecture)&n; * (C) Copyright Randy Dunlap 2000&n; * (C) Copyright David Brownell 2000-2004&n; * (C) Copyright Yggdrasil Computing, Inc. 2000&n; *     (usb_device_id matching changes by Adam J. Richter)&n; * (C) Copyright Greg Kroah-Hartman 2002-2003&n; *&n; * NOTE! This is not actually a driver at all, rather this is&n; * just a collection of helper routines that implement the&n; * generic USB things that the real drivers can use..&n; *&n; * Think of this as a &quot;USB library&quot; rather than anything else.&n; * It should be considered a slave, with no callbacks. Callbacks&n; * are evil.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#ifdef CONFIG_USB_DEBUG
DECL|macro|DEBUG
mdefine_line|#define DEBUG
macro_line|#else
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#endif
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;  /* for in_interrupt() */
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/rwsem.h&gt;
macro_line|#include &lt;linux/usb.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/scatterlist.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/dma-mapping.h&gt;
macro_line|#include &quot;hcd.h&quot;
macro_line|#include &quot;usb.h&quot;
r_extern
r_int
id|usb_hub_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|usb_hub_cleanup
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|usb_major_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|usb_major_cleanup
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|usb_host_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|usb_host_cleanup
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|usbcore_name
r_const
r_char
op_star
id|usbcore_name
op_assign
l_string|&quot;usbcore&quot;
suffix:semicolon
DECL|variable|nousb
r_int
id|nousb
suffix:semicolon
multiline_comment|/* Disable USB when built into kernel image */
multiline_comment|/* Not honored on modular build */
DECL|variable|usb_all_devices_rwsem
id|DECLARE_RWSEM
c_func
(paren
id|usb_all_devices_rwsem
)paren
suffix:semicolon
DECL|variable|usb_all_devices_rwsem
id|EXPORT_SYMBOL
c_func
(paren
id|usb_all_devices_rwsem
)paren
suffix:semicolon
DECL|function|generic_probe
r_static
r_int
id|generic_probe
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|generic_remove
r_static
r_int
id|generic_remove
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|usb_generic_driver
r_static
r_struct
id|device_driver
id|usb_generic_driver
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|name
op_assign
l_string|&quot;usb&quot;
comma
dot
id|bus
op_assign
op_amp
id|usb_bus_type
comma
dot
id|probe
op_assign
id|generic_probe
comma
dot
id|remove
op_assign
id|generic_remove
comma
)brace
suffix:semicolon
DECL|variable|usb_generic_driver_data
r_static
r_int
id|usb_generic_driver_data
suffix:semicolon
multiline_comment|/* called from driver core with usb_bus_type.subsys writelock */
DECL|function|usb_probe_interface
r_int
id|usb_probe_interface
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|usb_interface
op_star
id|intf
op_assign
id|to_usb_interface
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|usb_driver
op_star
id|driver
op_assign
id|to_usb_driver
c_func
(paren
id|dev-&gt;driver
)paren
suffix:semicolon
r_const
r_struct
id|usb_device_id
op_star
id|id
suffix:semicolon
r_int
id|error
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|dev_dbg
c_func
(paren
id|dev
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|driver-&gt;probe
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* FIXME we&squot;d much prefer to just resume it ... */
r_if
c_cond
(paren
id|interface_to_usbdev
c_func
(paren
id|intf
)paren
op_member_access_from_pointer
id|state
op_eq
id|USB_STATE_SUSPENDED
)paren
r_return
op_minus
id|EHOSTUNREACH
suffix:semicolon
id|id
op_assign
id|usb_match_id
(paren
id|intf
comma
id|driver-&gt;id_table
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id
)paren
(brace
id|dev_dbg
(paren
id|dev
comma
l_string|&quot;%s - got id&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|intf-&gt;condition
op_assign
id|USB_INTERFACE_BINDING
suffix:semicolon
id|error
op_assign
id|driver-&gt;probe
(paren
id|intf
comma
id|id
)paren
suffix:semicolon
id|intf-&gt;condition
op_assign
id|error
ques
c_cond
id|USB_INTERFACE_UNBOUND
suffix:colon
id|USB_INTERFACE_BOUND
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* called from driver core with usb_bus_type.subsys writelock */
DECL|function|usb_unbind_interface
r_int
id|usb_unbind_interface
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|usb_interface
op_star
id|intf
op_assign
id|to_usb_interface
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|usb_driver
op_star
id|driver
op_assign
id|to_usb_driver
c_func
(paren
id|intf-&gt;dev.driver
)paren
suffix:semicolon
id|intf-&gt;condition
op_assign
id|USB_INTERFACE_UNBINDING
suffix:semicolon
multiline_comment|/* release all urbs for this interface */
id|usb_disable_interface
c_func
(paren
id|interface_to_usbdev
c_func
(paren
id|intf
)paren
comma
id|intf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver
op_logical_and
id|driver-&gt;disconnect
)paren
id|driver
op_member_access_from_pointer
id|disconnect
c_func
(paren
id|intf
)paren
suffix:semicolon
multiline_comment|/* reset other interface state */
id|usb_set_interface
c_func
(paren
id|interface_to_usbdev
c_func
(paren
id|intf
)paren
comma
id|intf-&gt;altsetting
(braket
l_int|0
)braket
dot
id|desc.bInterfaceNumber
comma
l_int|0
)paren
suffix:semicolon
id|usb_set_intfdata
c_func
(paren
id|intf
comma
l_int|NULL
)paren
suffix:semicolon
id|intf-&gt;condition
op_assign
id|USB_INTERFACE_UNBOUND
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_register - register a USB driver&n; * @new_driver: USB operations for the driver&n; *&n; * Registers a USB driver with the USB core.  The list of unattached&n; * interfaces will be rescanned whenever a new driver is added, allowing&n; * the new driver to attach to any recognized devices.&n; * Returns a negative error code on failure and 0 on success.&n; * &n; * NOTE: if you want your driver to use the USB major number, you must call&n; * usb_register_dev() to enable that functionality.  This function no longer&n; * takes care of that.&n; */
DECL|function|usb_register
r_int
id|usb_register
c_func
(paren
r_struct
id|usb_driver
op_star
id|new_driver
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|nousb
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|new_driver-&gt;driver.name
op_assign
(paren
r_char
op_star
)paren
id|new_driver-&gt;name
suffix:semicolon
id|new_driver-&gt;driver.bus
op_assign
op_amp
id|usb_bus_type
suffix:semicolon
id|new_driver-&gt;driver.probe
op_assign
id|usb_probe_interface
suffix:semicolon
id|new_driver-&gt;driver.remove
op_assign
id|usb_unbind_interface
suffix:semicolon
id|new_driver-&gt;driver.owner
op_assign
id|new_driver-&gt;owner
suffix:semicolon
id|usb_lock_all_devices
c_func
(paren
)paren
suffix:semicolon
id|retval
op_assign
id|driver_register
c_func
(paren
op_amp
id|new_driver-&gt;driver
)paren
suffix:semicolon
id|usb_unlock_all_devices
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
(brace
id|pr_info
c_func
(paren
l_string|&quot;%s: registered new driver %s&bslash;n&quot;
comma
id|usbcore_name
comma
id|new_driver-&gt;name
)paren
suffix:semicolon
id|usbfs_update_special
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: error %d registering driver %s&bslash;n&quot;
comma
id|usbcore_name
comma
id|retval
comma
id|new_driver-&gt;name
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_deregister - unregister a USB driver&n; * @driver: USB operations of the driver to unregister&n; * Context: must be able to sleep&n; *&n; * Unlinks the specified driver from the internal USB driver list.&n; * &n; * NOTE: If you called usb_register_dev(), you still need to call&n; * usb_deregister_dev() to clean up your driver&squot;s allocated minor numbers,&n; * this * call will no longer do it for you.&n; */
DECL|function|usb_deregister
r_void
id|usb_deregister
c_func
(paren
r_struct
id|usb_driver
op_star
id|driver
)paren
(brace
id|pr_info
c_func
(paren
l_string|&quot;%s: deregistering driver %s&bslash;n&quot;
comma
id|usbcore_name
comma
id|driver-&gt;name
)paren
suffix:semicolon
id|usb_lock_all_devices
c_func
(paren
)paren
suffix:semicolon
id|driver_unregister
(paren
op_amp
id|driver-&gt;driver
)paren
suffix:semicolon
id|usb_unlock_all_devices
c_func
(paren
)paren
suffix:semicolon
id|usbfs_update_special
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_ifnum_to_if - get the interface object with a given interface number&n; * @dev: the device whose current configuration is considered&n; * @ifnum: the desired interface&n; *&n; * This walks the device descriptor for the currently active configuration&n; * and returns a pointer to the interface with that particular interface&n; * number, or null.&n; *&n; * Note that configuration descriptors are not required to assign interface&n; * numbers sequentially, so that it would be incorrect to assume that&n; * the first interface in that descriptor corresponds to interface zero.&n; * This routine helps device drivers avoid such mistakes.&n; * However, you should make sure that you do the right thing with any&n; * alternate settings available for this interfaces.&n; *&n; * Don&squot;t call this function unless you are bound to one of the interfaces&n; * on this device or you have locked the device!&n; */
DECL|function|usb_ifnum_to_if
r_struct
id|usb_interface
op_star
id|usb_ifnum_to_if
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|ifnum
)paren
(brace
r_struct
id|usb_host_config
op_star
id|config
op_assign
id|dev-&gt;actconfig
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|config
)paren
r_return
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|config-&gt;desc.bNumInterfaces
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|config-&gt;interface
(braket
id|i
)braket
op_member_access_from_pointer
id|altsetting
(braket
l_int|0
)braket
dot
id|desc.bInterfaceNumber
op_eq
id|ifnum
)paren
r_return
id|config-&gt;interface
(braket
id|i
)braket
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_altnum_to_altsetting - get the altsetting structure with a given&n; *&t;alternate setting number.&n; * @intf: the interface containing the altsetting in question&n; * @altnum: the desired alternate setting number&n; *&n; * This searches the altsetting array of the specified interface for&n; * an entry with the correct bAlternateSetting value and returns a pointer&n; * to that entry, or null.&n; *&n; * Note that altsettings need not be stored sequentially by number, so&n; * it would be incorrect to assume that the first altsetting entry in&n; * the array corresponds to altsetting zero.  This routine helps device&n; * drivers avoid such mistakes.&n; *&n; * Don&squot;t call this function unless you are bound to the intf interface&n; * or you have locked the device!&n; */
DECL|function|usb_altnum_to_altsetting
r_struct
id|usb_host_interface
op_star
id|usb_altnum_to_altsetting
c_func
(paren
r_struct
id|usb_interface
op_star
id|intf
comma
r_int
r_int
id|altnum
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|intf-&gt;num_altsetting
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|intf-&gt;altsetting
(braket
id|i
)braket
dot
id|desc.bAlternateSetting
op_eq
id|altnum
)paren
r_return
op_amp
id|intf-&gt;altsetting
(braket
id|i
)braket
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_driver_claim_interface - bind a driver to an interface&n; * @driver: the driver to be bound&n; * @iface: the interface to which it will be bound; must be in the&n; *&t;usb device&squot;s active configuration&n; * @priv: driver data associated with that interface&n; *&n; * This is used by usb device drivers that need to claim more than one&n; * interface on a device when probing (audio and acm are current examples).&n; * No device driver should directly modify internal usb_interface or&n; * usb_device structure members.&n; *&n; * Few drivers should need to use this routine, since the most natural&n; * way to bind to an interface is to return the private data from&n; * the driver&squot;s probe() method.&n; *&n; * Callers must own the device lock and the driver model&squot;s usb_bus_type.subsys&n; * writelock.  So driver probe() entries don&squot;t need extra locking,&n; * but other call contexts may need to explicitly claim those locks.&n; */
DECL|function|usb_driver_claim_interface
r_int
id|usb_driver_claim_interface
c_func
(paren
r_struct
id|usb_driver
op_star
id|driver
comma
r_struct
id|usb_interface
op_star
id|iface
comma
r_void
op_star
id|priv
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
op_amp
id|iface-&gt;dev
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;driver
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|dev-&gt;driver
op_assign
op_amp
id|driver-&gt;driver
suffix:semicolon
id|usb_set_intfdata
c_func
(paren
id|iface
comma
id|priv
)paren
suffix:semicolon
id|iface-&gt;condition
op_assign
id|USB_INTERFACE_BOUND
suffix:semicolon
multiline_comment|/* if interface was already added, bind now; else let&n;&t; * the future device_add() bind it, bypassing probe()&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|dev-&gt;bus_list
)paren
)paren
id|device_bind_driver
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_driver_release_interface - unbind a driver from an interface&n; * @driver: the driver to be unbound&n; * @iface: the interface from which it will be unbound&n; *&n; * This can be used by drivers to release an interface without waiting&n; * for their disconnect() methods to be called.  In typical cases this&n; * also causes the driver disconnect() method to be called.&n; *&n; * This call is synchronous, and may not be used in an interrupt context.&n; * Callers must own the device lock and the driver model&squot;s usb_bus_type.subsys&n; * writelock.  So driver disconnect() entries don&squot;t need extra locking,&n; * but other call contexts may need to explicitly claim those locks.&n; */
DECL|function|usb_driver_release_interface
r_void
id|usb_driver_release_interface
c_func
(paren
r_struct
id|usb_driver
op_star
id|driver
comma
r_struct
id|usb_interface
op_star
id|iface
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
op_amp
id|iface-&gt;dev
suffix:semicolon
multiline_comment|/* this should never happen, don&squot;t release something that&squot;s not ours */
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;driver
op_logical_or
id|dev-&gt;driver
op_ne
op_amp
id|driver-&gt;driver
)paren
r_return
suffix:semicolon
multiline_comment|/* don&squot;t disconnect from disconnect(), or before dev_add() */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|dev-&gt;driver_list
)paren
op_logical_and
op_logical_neg
id|list_empty
(paren
op_amp
id|dev-&gt;bus_list
)paren
)paren
id|device_release_driver
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;driver
op_assign
l_int|NULL
suffix:semicolon
id|usb_set_intfdata
c_func
(paren
id|iface
comma
l_int|NULL
)paren
suffix:semicolon
id|iface-&gt;condition
op_assign
id|USB_INTERFACE_UNBOUND
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_match_id - find first usb_device_id matching device or interface&n; * @interface: the interface of interest&n; * @id: array of usb_device_id structures, terminated by zero entry&n; *&n; * usb_match_id searches an array of usb_device_id&squot;s and returns&n; * the first one matching the device or interface, or null.&n; * This is used when binding (or rebinding) a driver to an interface.&n; * Most USB device drivers will use this indirectly, through the usb core,&n; * but some layered driver frameworks use it directly.&n; * These device tables are exported with MODULE_DEVICE_TABLE, through&n; * modutils and &quot;modules.usbmap&quot;, to support the driver loading&n; * functionality of USB hotplugging.&n; *&n; * What Matches:&n; *&n; * The &quot;match_flags&quot; element in a usb_device_id controls which&n; * members are used.  If the corresponding bit is set, the&n; * value in the device_id must match its corresponding member&n; * in the device or interface descriptor, or else the device_id&n; * does not match.&n; *&n; * &quot;driver_info&quot; is normally used only by device drivers,&n; * but you can create a wildcard &quot;matches anything&quot; usb_device_id&n; * as a driver&squot;s &quot;modules.usbmap&quot; entry if you provide an id with&n; * only a nonzero &quot;driver_info&quot; field.  If you do this, the USB device&n; * driver&squot;s probe() routine should use additional intelligence to&n; * decide whether to bind to the specified interface.&n; * &n; * What Makes Good usb_device_id Tables:&n; *&n; * The match algorithm is very simple, so that intelligence in&n; * driver selection must come from smart driver id records.&n; * Unless you have good reasons to use another selection policy,&n; * provide match elements only in related groups, and order match&n; * specifiers from specific to general.  Use the macros provided&n; * for that purpose if you can.&n; *&n; * The most specific match specifiers use device descriptor&n; * data.  These are commonly used with product-specific matches;&n; * the USB_DEVICE macro lets you provide vendor and product IDs,&n; * and you can also match against ranges of product revisions.&n; * These are widely used for devices with application or vendor&n; * specific bDeviceClass values.&n; *&n; * Matches based on device class/subclass/protocol specifications&n; * are slightly more general; use the USB_DEVICE_INFO macro, or&n; * its siblings.  These are used with single-function devices&n; * where bDeviceClass doesn&squot;t specify that each interface has&n; * its own class. &n; *&n; * Matches based on interface class/subclass/protocol are the&n; * most general; they let drivers bind to any interface on a&n; * multiple-function device.  Use the USB_INTERFACE_INFO&n; * macro, or its siblings, to match class-per-interface style &n; * devices (as recorded in bDeviceClass).&n; *  &n; * Within those groups, remember that not all combinations are&n; * meaningful.  For example, don&squot;t give a product version range&n; * without vendor and product IDs; or specify a protocol without&n; * its associated class and subclass.&n; */
r_const
r_struct
id|usb_device_id
op_star
DECL|function|usb_match_id
id|usb_match_id
c_func
(paren
r_struct
id|usb_interface
op_star
id|interface
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
(brace
r_struct
id|usb_host_interface
op_star
id|intf
suffix:semicolon
r_struct
id|usb_device
op_star
id|dev
suffix:semicolon
multiline_comment|/* proc_connectinfo in devio.c may call us with id == NULL. */
r_if
c_cond
(paren
id|id
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|intf
op_assign
id|interface-&gt;cur_altsetting
suffix:semicolon
id|dev
op_assign
id|interface_to_usbdev
c_func
(paren
id|interface
)paren
suffix:semicolon
multiline_comment|/* It is important to check that id-&gt;driver_info is nonzero,&n;&t;   since an entry that is all zeroes except for a nonzero&n;&t;   id-&gt;driver_info is the way to create an entry that&n;&t;   indicates that the driver want to examine every&n;&t;   device and interface. */
r_for
c_loop
(paren
suffix:semicolon
id|id-&gt;idVendor
op_logical_or
id|id-&gt;bDeviceClass
op_logical_or
id|id-&gt;bInterfaceClass
op_logical_or
id|id-&gt;driver_info
suffix:semicolon
id|id
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|USB_DEVICE_ID_MATCH_VENDOR
)paren
op_logical_and
id|id-&gt;idVendor
op_ne
id|dev-&gt;descriptor.idVendor
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|USB_DEVICE_ID_MATCH_PRODUCT
)paren
op_logical_and
id|id-&gt;idProduct
op_ne
id|dev-&gt;descriptor.idProduct
)paren
r_continue
suffix:semicolon
multiline_comment|/* No need to test id-&gt;bcdDevice_lo != 0, since 0 is never&n;&t;&t;   greater than any unsigned number. */
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|USB_DEVICE_ID_MATCH_DEV_LO
)paren
op_logical_and
(paren
id|id-&gt;bcdDevice_lo
OG
id|dev-&gt;descriptor.bcdDevice
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|USB_DEVICE_ID_MATCH_DEV_HI
)paren
op_logical_and
(paren
id|id-&gt;bcdDevice_hi
OL
id|dev-&gt;descriptor.bcdDevice
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|USB_DEVICE_ID_MATCH_DEV_CLASS
)paren
op_logical_and
(paren
id|id-&gt;bDeviceClass
op_ne
id|dev-&gt;descriptor.bDeviceClass
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|USB_DEVICE_ID_MATCH_DEV_SUBCLASS
)paren
op_logical_and
(paren
id|id-&gt;bDeviceSubClass
op_ne
id|dev-&gt;descriptor.bDeviceSubClass
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|USB_DEVICE_ID_MATCH_DEV_PROTOCOL
)paren
op_logical_and
(paren
id|id-&gt;bDeviceProtocol
op_ne
id|dev-&gt;descriptor.bDeviceProtocol
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|USB_DEVICE_ID_MATCH_INT_CLASS
)paren
op_logical_and
(paren
id|id-&gt;bInterfaceClass
op_ne
id|intf-&gt;desc.bInterfaceClass
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|USB_DEVICE_ID_MATCH_INT_SUBCLASS
)paren
op_logical_and
(paren
id|id-&gt;bInterfaceSubClass
op_ne
id|intf-&gt;desc.bInterfaceSubClass
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;match_flags
op_amp
id|USB_DEVICE_ID_MATCH_INT_PROTOCOL
)paren
op_logical_and
(paren
id|id-&gt;bInterfaceProtocol
op_ne
id|intf-&gt;desc.bInterfaceProtocol
)paren
)paren
r_continue
suffix:semicolon
r_return
id|id
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_find_interface - find usb_interface pointer for driver and device&n; * @drv: the driver whose current configuration is considered&n; * @minor: the minor number of the desired device&n; *&n; * This walks the driver device list and returns a pointer to the interface &n; * with the matching minor.  Note, this only works for devices that share the&n; * USB major number.&n; */
DECL|function|usb_find_interface
r_struct
id|usb_interface
op_star
id|usb_find_interface
c_func
(paren
r_struct
id|usb_driver
op_star
id|drv
comma
r_int
id|minor
)paren
(brace
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_struct
id|usb_interface
op_star
id|intf
suffix:semicolon
id|list_for_each
c_func
(paren
id|entry
comma
op_amp
id|drv-&gt;driver.devices
)paren
(brace
id|dev
op_assign
id|container_of
c_func
(paren
id|entry
comma
r_struct
id|device
comma
id|driver_list
)paren
suffix:semicolon
multiline_comment|/* can&squot;t look at usb devices, only interfaces */
r_if
c_cond
(paren
id|dev-&gt;driver
op_eq
op_amp
id|usb_generic_driver
)paren
r_continue
suffix:semicolon
id|intf
op_assign
id|to_usb_interface
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intf-&gt;minor
op_eq
op_minus
l_int|1
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|intf-&gt;minor
op_eq
id|minor
)paren
r_return
id|intf
suffix:semicolon
)brace
multiline_comment|/* no device found that matches */
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|usb_device_match
r_static
r_int
id|usb_device_match
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|device_driver
op_star
id|drv
)paren
(brace
r_struct
id|usb_interface
op_star
id|intf
suffix:semicolon
r_struct
id|usb_driver
op_star
id|usb_drv
suffix:semicolon
r_const
r_struct
id|usb_device_id
op_star
id|id
suffix:semicolon
multiline_comment|/* check for generic driver, which we don&squot;t match any device with */
r_if
c_cond
(paren
id|drv
op_eq
op_amp
id|usb_generic_driver
)paren
r_return
l_int|0
suffix:semicolon
id|intf
op_assign
id|to_usb_interface
c_func
(paren
id|dev
)paren
suffix:semicolon
id|usb_drv
op_assign
id|to_usb_driver
c_func
(paren
id|drv
)paren
suffix:semicolon
id|id
op_assign
id|usb_match_id
(paren
id|intf
comma
id|usb_drv-&gt;id_table
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef&t;CONFIG_HOTPLUG
multiline_comment|/*&n; * USB hotplugging invokes what /proc/sys/kernel/hotplug says&n; * (normally /sbin/hotplug) when USB devices get added or removed.&n; *&n; * This invokes a user mode policy agent, typically helping to load driver&n; * or other modules, configure the device, and more.  Drivers can provide&n; * a MODULE_DEVICE_TABLE to help with module loading subtasks.&n; *&n; * We&squot;re called either from khubd (the typical case) or from root hub&n; * (init, kapmd, modprobe, rmmod, etc), but the agents need to handle&n; * delays in event delivery.  Use sysfs (and DEVPATH) to make sure the&n; * device (and this configuration!) are still present.&n; */
DECL|function|usb_hotplug
r_static
r_int
id|usb_hotplug
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
op_star
id|envp
comma
r_int
id|num_envp
comma
r_char
op_star
id|buffer
comma
r_int
id|buffer_size
)paren
(brace
r_struct
id|usb_interface
op_star
id|intf
suffix:semicolon
r_struct
id|usb_device
op_star
id|usb_dev
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|length
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* driver is often null here; dev_dbg() would oops */
id|pr_debug
(paren
l_string|&quot;usb %s: hotplug&bslash;n&quot;
comma
id|dev-&gt;bus_id
)paren
suffix:semicolon
multiline_comment|/* Must check driver_data here, as on remove driver is always NULL */
r_if
c_cond
(paren
(paren
id|dev-&gt;driver
op_eq
op_amp
id|usb_generic_driver
)paren
op_logical_or
(paren
id|dev-&gt;driver_data
op_eq
op_amp
id|usb_generic_driver_data
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|intf
op_assign
id|to_usb_interface
c_func
(paren
id|dev
)paren
suffix:semicolon
id|usb_dev
op_assign
id|interface_to_usbdev
(paren
id|intf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_dev-&gt;devnum
OL
l_int|0
)paren
(brace
id|pr_debug
(paren
l_string|&quot;usb %s: already deleted?&bslash;n&quot;
comma
id|dev-&gt;bus_id
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|usb_dev-&gt;bus
)paren
(brace
id|pr_debug
(paren
l_string|&quot;usb %s: bus removed?&bslash;n&quot;
comma
id|dev-&gt;bus_id
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
macro_line|#ifdef&t;CONFIG_USB_DEVICEFS
multiline_comment|/* If this is available, userspace programs can directly read&n;&t; * all the device descriptors we don&squot;t tell them about.  Or&n;&t; * even act as usermode drivers.&n;&t; *&n;&t; * FIXME reduce hardwired intelligence here&n;&t; */
r_if
c_cond
(paren
id|add_hotplug_env_var
c_func
(paren
id|envp
comma
id|num_envp
comma
op_amp
id|i
comma
id|buffer
comma
id|buffer_size
comma
op_amp
id|length
comma
l_string|&quot;DEVICE=/proc/bus/usb/%03d/%03d&quot;
comma
id|usb_dev-&gt;bus-&gt;busnum
comma
id|usb_dev-&gt;devnum
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
macro_line|#endif
multiline_comment|/* per-device configurations are common */
r_if
c_cond
(paren
id|add_hotplug_env_var
c_func
(paren
id|envp
comma
id|num_envp
comma
op_amp
id|i
comma
id|buffer
comma
id|buffer_size
comma
op_amp
id|length
comma
l_string|&quot;PRODUCT=%x/%x/%x&quot;
comma
id|usb_dev-&gt;descriptor.idVendor
comma
id|usb_dev-&gt;descriptor.idProduct
comma
id|usb_dev-&gt;descriptor.bcdDevice
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* class-based driver binding models */
r_if
c_cond
(paren
id|add_hotplug_env_var
c_func
(paren
id|envp
comma
id|num_envp
comma
op_amp
id|i
comma
id|buffer
comma
id|buffer_size
comma
op_amp
id|length
comma
l_string|&quot;TYPE=%d/%d/%d&quot;
comma
id|usb_dev-&gt;descriptor.bDeviceClass
comma
id|usb_dev-&gt;descriptor.bDeviceSubClass
comma
id|usb_dev-&gt;descriptor.bDeviceProtocol
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|usb_dev-&gt;descriptor.bDeviceClass
op_eq
l_int|0
)paren
(brace
r_struct
id|usb_host_interface
op_star
id|alt
op_assign
id|intf-&gt;cur_altsetting
suffix:semicolon
multiline_comment|/* 2.4 only exposed interface zero.  in 2.5, hotplug&n;&t;&t; * agents are called for all interfaces, and can use&n;&t;&t; * $DEVPATH/bInterfaceNumber if necessary.&n;&t;&t; */
r_if
c_cond
(paren
id|add_hotplug_env_var
c_func
(paren
id|envp
comma
id|num_envp
comma
op_amp
id|i
comma
id|buffer
comma
id|buffer_size
comma
op_amp
id|length
comma
l_string|&quot;INTERFACE=%d/%d/%d&quot;
comma
id|alt-&gt;desc.bInterfaceClass
comma
id|alt-&gt;desc.bInterfaceSubClass
comma
id|alt-&gt;desc.bInterfaceProtocol
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|envp
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#else
DECL|function|usb_hotplug
r_static
r_int
id|usb_hotplug
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
op_star
id|envp
comma
r_int
id|num_envp
comma
r_char
op_star
id|buffer
comma
r_int
id|buffer_size
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_HOTPLUG */
multiline_comment|/**&n; * usb_release_dev - free a usb device structure when all users of it are finished.&n; * @dev: device that&squot;s been disconnected&n; *&n; * Will be called only by the device core when all users of this usb device are&n; * done.&n; */
DECL|function|usb_release_dev
r_static
r_void
id|usb_release_dev
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|usb_device
op_star
id|udev
suffix:semicolon
id|udev
op_assign
id|to_usb_device
c_func
(paren
id|dev
)paren
suffix:semicolon
id|usb_destroy_configuration
c_func
(paren
id|udev
)paren
suffix:semicolon
id|usb_bus_put
c_func
(paren
id|udev-&gt;bus
)paren
suffix:semicolon
id|kfree
(paren
id|udev
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_alloc_dev - usb device constructor (usbcore-internal)&n; * @parent: hub to which device is connected; null to allocate a root hub&n; * @bus: bus used to access the device&n; * @port: zero based index of port; ignored for root hubs&n; * Context: !in_interrupt ()&n; *&n; * Only hub drivers (including virtual root hub drivers for host&n; * controllers) should ever call this.&n; *&n; * This call may not be used in a non-sleeping context.&n; */
r_struct
id|usb_device
op_star
DECL|function|usb_alloc_dev
id|usb_alloc_dev
c_func
(paren
r_struct
id|usb_device
op_star
id|parent
comma
r_struct
id|usb_bus
op_star
id|bus
comma
r_int
id|port
)paren
(brace
r_struct
id|usb_device
op_star
id|dev
suffix:semicolon
id|dev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|dev
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|dev
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|dev
)paren
)paren
suffix:semicolon
id|bus
op_assign
id|usb_bus_get
c_func
(paren
id|bus
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bus
)paren
(brace
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|device_initialize
c_func
(paren
op_amp
id|dev-&gt;dev
)paren
suffix:semicolon
id|dev-&gt;dev.bus
op_assign
op_amp
id|usb_bus_type
suffix:semicolon
id|dev-&gt;dev.dma_mask
op_assign
id|bus-&gt;controller-&gt;dma_mask
suffix:semicolon
id|dev-&gt;dev.driver_data
op_assign
op_amp
id|usb_generic_driver_data
suffix:semicolon
id|dev-&gt;dev.driver
op_assign
op_amp
id|usb_generic_driver
suffix:semicolon
id|dev-&gt;dev.release
op_assign
id|usb_release_dev
suffix:semicolon
id|dev-&gt;state
op_assign
id|USB_STATE_ATTACHED
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|dev-&gt;ep0.urb_list
)paren
suffix:semicolon
id|dev-&gt;ep0.desc.bLength
op_assign
id|USB_DT_ENDPOINT_SIZE
suffix:semicolon
id|dev-&gt;ep0.desc.bDescriptorType
op_assign
id|USB_DT_ENDPOINT
suffix:semicolon
multiline_comment|/* ep0 maxpacket comes later, from device descriptor */
id|dev-&gt;ep_in
(braket
l_int|0
)braket
op_assign
id|dev-&gt;ep_out
(braket
l_int|0
)braket
op_assign
op_amp
id|dev-&gt;ep0
suffix:semicolon
multiline_comment|/* Save readable and stable topology id, distinguishing devices&n;&t; * by location for diagnostics, tools, driver model, etc.  The&n;&t; * string is a path along hub ports, from the root.  Each device&squot;s&n;&t; * dev-&gt;devpath will be stable until USB is re-cabled, and hubs&n;&t; * are often labeled with these port numbers.  The bus_id isn&squot;t&n;&t; * as stable:  bus-&gt;busnum changes easily from modprobe order,&n;&t; * cardbus or pci hotplugging, and so on.&n;&t; */
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|parent
)paren
)paren
(brace
id|dev-&gt;devpath
(braket
l_int|0
)braket
op_assign
l_char|&squot;0&squot;
suffix:semicolon
id|dev-&gt;dev.parent
op_assign
id|bus-&gt;controller
suffix:semicolon
id|sprintf
(paren
op_amp
id|dev-&gt;dev.bus_id
(braket
l_int|0
)braket
comma
l_string|&quot;usb%d&quot;
comma
id|bus-&gt;busnum
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* match any labeling on the hubs; it&squot;s one-based */
r_if
c_cond
(paren
id|parent-&gt;devpath
(braket
l_int|0
)braket
op_eq
l_char|&squot;0&squot;
)paren
id|snprintf
(paren
id|dev-&gt;devpath
comma
r_sizeof
id|dev-&gt;devpath
comma
l_string|&quot;%d&quot;
comma
id|port
op_plus
l_int|1
)paren
suffix:semicolon
r_else
id|snprintf
(paren
id|dev-&gt;devpath
comma
r_sizeof
id|dev-&gt;devpath
comma
l_string|&quot;%s.%d&quot;
comma
id|parent-&gt;devpath
comma
id|port
op_plus
l_int|1
)paren
suffix:semicolon
id|dev-&gt;dev.parent
op_assign
op_amp
id|parent-&gt;dev
suffix:semicolon
id|sprintf
(paren
op_amp
id|dev-&gt;dev.bus_id
(braket
l_int|0
)braket
comma
l_string|&quot;%d-%s&quot;
comma
id|bus-&gt;busnum
comma
id|dev-&gt;devpath
)paren
suffix:semicolon
multiline_comment|/* hub driver sets up TT records */
)brace
id|dev-&gt;bus
op_assign
id|bus
suffix:semicolon
id|dev-&gt;parent
op_assign
id|parent
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|dev-&gt;filelist
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|dev-&gt;serialize
)paren
suffix:semicolon
r_return
id|dev
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_get_dev - increments the reference count of the usb device structure&n; * @dev: the device being referenced&n; *&n; * Each live reference to a device should be refcounted.&n; *&n; * Drivers for USB interfaces should normally record such references in&n; * their probe() methods, when they bind to an interface, and release&n; * them by calling usb_put_dev(), in their disconnect() methods.&n; *&n; * A pointer to the device with the incremented reference counter is returned.&n; */
DECL|function|usb_get_dev
r_struct
id|usb_device
op_star
id|usb_get_dev
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev
)paren
id|get_device
c_func
(paren
op_amp
id|dev-&gt;dev
)paren
suffix:semicolon
r_return
id|dev
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_put_dev - release a use of the usb device structure&n; * @dev: device that&squot;s been disconnected&n; *&n; * Must be called when a user of a device is finished with it.  When the last&n; * user of the device calls this function, the memory of the device is freed.&n; */
DECL|function|usb_put_dev
r_void
id|usb_put_dev
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev
)paren
id|put_device
c_func
(paren
op_amp
id|dev-&gt;dev
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_get_intf - increments the reference count of the usb interface structure&n; * @intf: the interface being referenced&n; *&n; * Each live reference to a interface must be refcounted.&n; *&n; * Drivers for USB interfaces should normally record such references in&n; * their probe() methods, when they bind to an interface, and release&n; * them by calling usb_put_intf(), in their disconnect() methods.&n; *&n; * A pointer to the interface with the incremented reference counter is&n; * returned.&n; */
DECL|function|usb_get_intf
r_struct
id|usb_interface
op_star
id|usb_get_intf
c_func
(paren
r_struct
id|usb_interface
op_star
id|intf
)paren
(brace
r_if
c_cond
(paren
id|intf
)paren
id|get_device
c_func
(paren
op_amp
id|intf-&gt;dev
)paren
suffix:semicolon
r_return
id|intf
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_put_intf - release a use of the usb interface structure&n; * @intf: interface that&squot;s been decremented&n; *&n; * Must be called when a user of an interface is finished with it.  When the&n; * last user of the interface calls this function, the memory of the interface&n; * is freed.&n; */
DECL|function|usb_put_intf
r_void
id|usb_put_intf
c_func
(paren
r_struct
id|usb_interface
op_star
id|intf
)paren
(brace
r_if
c_cond
(paren
id|intf
)paren
id|put_device
c_func
(paren
op_amp
id|intf-&gt;dev
)paren
suffix:semicolon
)brace
multiline_comment|/*&t;&t;&t;USB device locking&n; *&n; * Although locking USB devices should be straightforward, it is&n; * complicated by the way the driver-model core works.  When a new USB&n; * driver is registered or unregistered, the core will automatically&n; * probe or disconnect all matching interfaces on all USB devices while&n; * holding the USB subsystem writelock.  There&squot;s no good way for us to&n; * tell which devices will be used or to lock them beforehand; our only&n; * option is to effectively lock all the USB devices.&n; *&n; * We do that by using a private rw-semaphore, usb_all_devices_rwsem.&n; * When locking an individual device you must first acquire the rwsem&squot;s&n; * readlock.  When a driver is registered or unregistered the writelock&n; * must be held.  These actions are encapsulated in the subroutines&n; * below, so all a driver needs to do is call usb_lock_device() and&n; * usb_unlock_device().&n; *&n; * Complications arise when several devices are to be locked at the same&n; * time.  Only hub-aware drivers that are part of usbcore ever have to&n; * do this; nobody else needs to worry about it.  The problem is that&n; * usb_lock_device() must not be called to lock a second device since it&n; * would acquire the rwsem&squot;s readlock reentrantly, leading to deadlock if&n; * another thread was waiting for the writelock.  The solution is simple:&n; *&n; *&t;When locking more than one device, call usb_lock_device()&n; *&t;to lock the first one.  Lock the others by calling&n; *&t;down(&amp;udev-&gt;serialize) directly.&n; *&n; *&t;When unlocking multiple devices, use up(&amp;udev-&gt;serialize)&n; *&t;to unlock all but the last one.  Unlock the last one by&n; *&t;calling usb_unlock_device().&n; *&n; *&t;When locking both a device and its parent, always lock the&n; *&t;the parent first.&n; */
multiline_comment|/**&n; * usb_lock_device - acquire the lock for a usb device structure&n; * @udev: device that&squot;s being locked&n; *&n; * Use this routine when you don&squot;t hold any other device locks;&n; * to acquire nested inner locks call down(&amp;udev-&gt;serialize) directly.&n; * This is necessary for proper interaction with usb_lock_all_devices().&n; */
DECL|function|usb_lock_device
r_void
id|usb_lock_device
c_func
(paren
r_struct
id|usb_device
op_star
id|udev
)paren
(brace
id|down_read
c_func
(paren
op_amp
id|usb_all_devices_rwsem
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|udev-&gt;serialize
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_trylock_device - attempt to acquire the lock for a usb device structure&n; * @udev: device that&squot;s being locked&n; *&n; * Don&squot;t use this routine if you already hold a device lock;&n; * use down_trylock(&amp;udev-&gt;serialize) instead.&n; * This is necessary for proper interaction with usb_lock_all_devices().&n; *&n; * Returns 1 if successful, 0 if contention.&n; */
DECL|function|usb_trylock_device
r_int
id|usb_trylock_device
c_func
(paren
r_struct
id|usb_device
op_star
id|udev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|down_read_trylock
c_func
(paren
op_amp
id|usb_all_devices_rwsem
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|down_trylock
c_func
(paren
op_amp
id|udev-&gt;serialize
)paren
)paren
(brace
id|up_read
c_func
(paren
op_amp
id|usb_all_devices_rwsem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_lock_device_for_reset - cautiously acquire the lock for a&n; *&t;usb device structure&n; * @udev: device that&squot;s being locked&n; * @iface: interface bound to the driver making the request (optional)&n; *&n; * Attempts to acquire the device lock, but fails if the device is&n; * NOTATTACHED or SUSPENDED, or if iface is specified and the interface&n; * is neither BINDING nor BOUND.  Rather than sleeping to wait for the&n; * lock, the routine polls repeatedly.  This is to prevent deadlock with&n; * disconnect; in some drivers (such as usb-storage) the disconnect()&n; * callback will block waiting for a device reset to complete.&n; *&n; * Returns a negative error code for failure, otherwise 1 or 0 to indicate&n; * that the device will or will not have to be unlocked.  (0 can be&n; * returned when an interface is given and is BINDING, because in that&n; * case the driver already owns the device lock.)&n; */
DECL|function|usb_lock_device_for_reset
r_int
id|usb_lock_device_for_reset
c_func
(paren
r_struct
id|usb_device
op_star
id|udev
comma
r_struct
id|usb_interface
op_star
id|iface
)paren
(brace
r_if
c_cond
(paren
id|udev-&gt;state
op_eq
id|USB_STATE_NOTATTACHED
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|udev-&gt;state
op_eq
id|USB_STATE_SUSPENDED
)paren
r_return
op_minus
id|EHOSTUNREACH
suffix:semicolon
r_if
c_cond
(paren
id|iface
)paren
(brace
r_switch
c_cond
(paren
id|iface-&gt;condition
)paren
(brace
r_case
id|USB_INTERFACE_BINDING
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
id|USB_INTERFACE_BOUND
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_logical_neg
id|usb_trylock_device
c_func
(paren
id|udev
)paren
)paren
(brace
id|msleep
c_func
(paren
l_int|15
)paren
suffix:semicolon
r_if
c_cond
(paren
id|udev-&gt;state
op_eq
id|USB_STATE_NOTATTACHED
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|udev-&gt;state
op_eq
id|USB_STATE_SUSPENDED
)paren
r_return
op_minus
id|EHOSTUNREACH
suffix:semicolon
r_if
c_cond
(paren
id|iface
op_logical_and
id|iface-&gt;condition
op_ne
id|USB_INTERFACE_BOUND
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_unlock_device - release the lock for a usb device structure&n; * @udev: device that&squot;s being unlocked&n; *&n; * Use this routine when releasing the only device lock you hold;&n; * to release inner nested locks call up(&amp;udev-&gt;serialize) directly.&n; * This is necessary for proper interaction with usb_lock_all_devices().&n; */
DECL|function|usb_unlock_device
r_void
id|usb_unlock_device
c_func
(paren
r_struct
id|usb_device
op_star
id|udev
)paren
(brace
id|up
c_func
(paren
op_amp
id|udev-&gt;serialize
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|usb_all_devices_rwsem
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_lock_all_devices - acquire the lock for all usb device structures&n; *&n; * This is necessary when registering a new driver or probing a bus,&n; * since the driver-model core may try to use any usb_device.&n; */
DECL|function|usb_lock_all_devices
r_void
id|usb_lock_all_devices
c_func
(paren
r_void
)paren
(brace
id|down_write
c_func
(paren
op_amp
id|usb_all_devices_rwsem
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_unlock_all_devices - release the lock for all usb device structures&n; */
DECL|function|usb_unlock_all_devices
r_void
id|usb_unlock_all_devices
c_func
(paren
r_void
)paren
(brace
id|up_write
c_func
(paren
op_amp
id|usb_all_devices_rwsem
)paren
suffix:semicolon
)brace
DECL|function|match_device
r_static
r_struct
id|usb_device
op_star
id|match_device
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
id|u16
id|vendor_id
comma
id|u16
id|product_id
)paren
(brace
r_struct
id|usb_device
op_star
id|ret_dev
op_assign
l_int|NULL
suffix:semicolon
r_int
id|child
suffix:semicolon
id|dev_dbg
c_func
(paren
op_amp
id|dev-&gt;dev
comma
l_string|&quot;check for vendor %04x, product %04x ...&bslash;n&quot;
comma
id|dev-&gt;descriptor.idVendor
comma
id|dev-&gt;descriptor.idProduct
)paren
suffix:semicolon
multiline_comment|/* see if this device matches */
r_if
c_cond
(paren
(paren
id|dev-&gt;descriptor.idVendor
op_eq
id|vendor_id
)paren
op_logical_and
(paren
id|dev-&gt;descriptor.idProduct
op_eq
id|product_id
)paren
)paren
(brace
id|dev_dbg
(paren
op_amp
id|dev-&gt;dev
comma
l_string|&quot;matched this device!&bslash;n&quot;
)paren
suffix:semicolon
id|ret_dev
op_assign
id|usb_get_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
multiline_comment|/* look through all of the children of this device */
r_for
c_loop
(paren
id|child
op_assign
l_int|0
suffix:semicolon
id|child
OL
id|dev-&gt;maxchild
suffix:semicolon
op_increment
id|child
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;children
(braket
id|child
)braket
)paren
(brace
id|down
c_func
(paren
op_amp
id|dev-&gt;children
(braket
id|child
)braket
op_member_access_from_pointer
id|serialize
)paren
suffix:semicolon
id|ret_dev
op_assign
id|match_device
c_func
(paren
id|dev-&gt;children
(braket
id|child
)braket
comma
id|vendor_id
comma
id|product_id
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|dev-&gt;children
(braket
id|child
)braket
op_member_access_from_pointer
id|serialize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret_dev
)paren
r_goto
m_exit
suffix:semicolon
)brace
)brace
m_exit
suffix:colon
r_return
id|ret_dev
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_find_device - find a specific usb device in the system&n; * @vendor_id: the vendor id of the device to find&n; * @product_id: the product id of the device to find&n; *&n; * Returns a pointer to a struct usb_device if such a specified usb&n; * device is present in the system currently.  The usage count of the&n; * device will be incremented if a device is found.  Make sure to call&n; * usb_put_dev() when the caller is finished with the device.&n; *&n; * If a device with the specified vendor and product id is not found,&n; * NULL is returned.&n; */
DECL|function|usb_find_device
r_struct
id|usb_device
op_star
id|usb_find_device
c_func
(paren
id|u16
id|vendor_id
comma
id|u16
id|product_id
)paren
(brace
r_struct
id|list_head
op_star
id|buslist
suffix:semicolon
r_struct
id|usb_bus
op_star
id|bus
suffix:semicolon
r_struct
id|usb_device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
id|down
c_func
(paren
op_amp
id|usb_bus_list_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|buslist
op_assign
id|usb_bus_list.next
suffix:semicolon
id|buslist
op_ne
op_amp
id|usb_bus_list
suffix:semicolon
id|buslist
op_assign
id|buslist-&gt;next
)paren
(brace
id|bus
op_assign
id|container_of
c_func
(paren
id|buslist
comma
r_struct
id|usb_bus
comma
id|bus_list
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bus-&gt;root_hub
)paren
r_continue
suffix:semicolon
id|usb_lock_device
c_func
(paren
id|bus-&gt;root_hub
)paren
suffix:semicolon
id|dev
op_assign
id|match_device
c_func
(paren
id|bus-&gt;root_hub
comma
id|vendor_id
comma
id|product_id
)paren
suffix:semicolon
id|usb_unlock_device
c_func
(paren
id|bus-&gt;root_hub
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
)paren
r_goto
m_exit
suffix:semicolon
)brace
m_exit
suffix:colon
id|up
c_func
(paren
op_amp
id|usb_bus_list_lock
)paren
suffix:semicolon
r_return
id|dev
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_get_current_frame_number - return current bus frame number&n; * @dev: the device whose bus is being queried&n; *&n; * Returns the current frame number for the USB host controller&n; * used with the given USB device.  This can be used when scheduling&n; * isochronous requests.&n; *&n; * Note that different kinds of host controller have different&n; * &quot;scheduling horizons&quot;.  While one type might support scheduling only&n; * 32 frames into the future, others could support scheduling up to&n; * 1024 frames into the future.&n; */
DECL|function|usb_get_current_frame_number
r_int
id|usb_get_current_frame_number
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_return
id|dev-&gt;bus-&gt;op-&gt;get_frame_number
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------*/
multiline_comment|/*&n; * __usb_get_extra_descriptor() finds a descriptor of specific type in the&n; * extra field of the interface and endpoint descriptor structs.&n; */
DECL|function|__usb_get_extra_descriptor
r_int
id|__usb_get_extra_descriptor
c_func
(paren
r_char
op_star
id|buffer
comma
r_int
id|size
comma
r_int
r_char
id|type
comma
r_void
op_star
op_star
id|ptr
)paren
(brace
r_struct
id|usb_descriptor_header
op_star
id|header
suffix:semicolon
r_while
c_loop
(paren
id|size
op_ge
r_sizeof
(paren
r_struct
id|usb_descriptor_header
)paren
)paren
(brace
id|header
op_assign
(paren
r_struct
id|usb_descriptor_header
op_star
)paren
id|buffer
suffix:semicolon
r_if
c_cond
(paren
id|header-&gt;bLength
OL
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: bogus descriptor, type %d length %d&bslash;n&quot;
comma
id|usbcore_name
comma
id|header-&gt;bDescriptorType
comma
id|header-&gt;bLength
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|header-&gt;bDescriptorType
op_eq
id|type
)paren
(brace
op_star
id|ptr
op_assign
id|header
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|buffer
op_add_assign
id|header-&gt;bLength
suffix:semicolon
id|size
op_sub_assign
id|header-&gt;bLength
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_buffer_alloc - allocate dma-consistent buffer for URB_NO_xxx_DMA_MAP&n; * @dev: device the buffer will be used with&n; * @size: requested buffer size&n; * @mem_flags: affect whether allocation may block&n; * @dma: used to return DMA address of buffer&n; *&n; * Return value is either null (indicating no buffer could be allocated), or&n; * the cpu-space pointer to a buffer that may be used to perform DMA to the&n; * specified device.  Such cpu-space buffers are returned along with the DMA&n; * address (through the pointer provided).&n; *&n; * These buffers are used with URB_NO_xxx_DMA_MAP set in urb-&gt;transfer_flags&n; * to avoid behaviors like using &quot;DMA bounce buffers&quot;, or tying down I/O&n; * mapping hardware for long idle periods.  The implementation varies between&n; * platforms, depending on details of how DMA will work to this device.&n; * Using these buffers also helps prevent cacheline sharing problems on&n; * architectures where CPU caches are not DMA-coherent.&n; *&n; * When the buffer is no longer used, free it with usb_buffer_free().&n; */
DECL|function|usb_buffer_alloc
r_void
op_star
id|usb_buffer_alloc
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|size
comma
r_int
id|mem_flags
comma
id|dma_addr_t
op_star
id|dma
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dev
op_logical_or
op_logical_neg
id|dev-&gt;bus
op_logical_or
op_logical_neg
id|dev-&gt;bus-&gt;op
op_logical_or
op_logical_neg
id|dev-&gt;bus-&gt;op-&gt;buffer_alloc
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|dev-&gt;bus-&gt;op-&gt;buffer_alloc
(paren
id|dev-&gt;bus
comma
id|size
comma
id|mem_flags
comma
id|dma
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_buffer_free - free memory allocated with usb_buffer_alloc()&n; * @dev: device the buffer was used with&n; * @size: requested buffer size&n; * @addr: CPU address of buffer&n; * @dma: DMA address of buffer&n; *&n; * This reclaims an I/O buffer, letting it be reused.  The memory must have&n; * been allocated using usb_buffer_alloc(), and the parameters must match&n; * those provided in that allocation request. &n; */
DECL|function|usb_buffer_free
r_void
id|usb_buffer_free
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|size
comma
r_void
op_star
id|addr
comma
id|dma_addr_t
id|dma
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dev
op_logical_or
op_logical_neg
id|dev-&gt;bus
op_logical_or
op_logical_neg
id|dev-&gt;bus-&gt;op
op_logical_or
op_logical_neg
id|dev-&gt;bus-&gt;op-&gt;buffer_free
)paren
r_return
suffix:semicolon
id|dev-&gt;bus-&gt;op-&gt;buffer_free
(paren
id|dev-&gt;bus
comma
id|size
comma
id|addr
comma
id|dma
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_buffer_map - create DMA mapping(s) for an urb&n; * @urb: urb whose transfer_buffer/setup_packet will be mapped&n; *&n; * Return value is either null (indicating no buffer could be mapped), or&n; * the parameter.  URB_NO_TRANSFER_DMA_MAP and URB_NO_SETUP_DMA_MAP are&n; * added to urb-&gt;transfer_flags if the operation succeeds.  If the device&n; * is connected to this system through a non-DMA controller, this operation&n; * always succeeds.&n; *&n; * This call would normally be used for an urb which is reused, perhaps&n; * as the target of a large periodic transfer, with usb_buffer_dmasync()&n; * calls to synchronize memory and dma state.&n; *&n; * Reverse the effect of this call with usb_buffer_unmap().&n; */
DECL|function|usb_buffer_map
r_struct
id|urb
op_star
id|usb_buffer_map
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|usb_bus
op_star
id|bus
suffix:semicolon
r_struct
id|device
op_star
id|controller
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
op_logical_or
op_logical_neg
id|urb-&gt;dev
op_logical_or
op_logical_neg
(paren
id|bus
op_assign
id|urb-&gt;dev-&gt;bus
)paren
op_logical_or
op_logical_neg
(paren
id|controller
op_assign
id|bus-&gt;controller
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|controller-&gt;dma_mask
)paren
(brace
id|urb-&gt;transfer_dma
op_assign
id|dma_map_single
(paren
id|controller
comma
id|urb-&gt;transfer_buffer
comma
id|urb-&gt;transfer_buffer_length
comma
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
ques
c_cond
id|DMA_FROM_DEVICE
suffix:colon
id|DMA_TO_DEVICE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipecontrol
(paren
id|urb-&gt;pipe
)paren
)paren
id|urb-&gt;setup_dma
op_assign
id|dma_map_single
(paren
id|controller
comma
id|urb-&gt;setup_packet
comma
r_sizeof
(paren
r_struct
id|usb_ctrlrequest
)paren
comma
id|DMA_TO_DEVICE
)paren
suffix:semicolon
singleline_comment|// FIXME generic api broken like pci, can&squot;t report errors
singleline_comment|// if (urb-&gt;transfer_dma == DMA_ADDR_INVALID) return 0;
)brace
r_else
id|urb-&gt;transfer_dma
op_assign
op_complement
l_int|0
suffix:semicolon
id|urb-&gt;transfer_flags
op_or_assign
(paren
id|URB_NO_TRANSFER_DMA_MAP
op_or
id|URB_NO_SETUP_DMA_MAP
)paren
suffix:semicolon
r_return
id|urb
suffix:semicolon
)brace
multiline_comment|/* XXX DISABLED, no users currently.  If you wish to re-enable this&n; * XXX please determine whether the sync is to transfer ownership of&n; * XXX the buffer from device to cpu or vice verse, and thusly use the&n; * XXX appropriate _for_{cpu,device}() method.  -DaveM&n; */
macro_line|#if 0
multiline_comment|/**&n; * usb_buffer_dmasync - synchronize DMA and CPU view of buffer(s)&n; * @urb: urb whose transfer_buffer/setup_packet will be synchronized&n; */
r_void
id|usb_buffer_dmasync
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|usb_bus
op_star
id|bus
suffix:semicolon
r_struct
id|device
op_star
id|controller
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
op_logical_or
op_logical_neg
(paren
id|urb-&gt;transfer_flags
op_amp
id|URB_NO_TRANSFER_DMA_MAP
)paren
op_logical_or
op_logical_neg
id|urb-&gt;dev
op_logical_or
op_logical_neg
(paren
id|bus
op_assign
id|urb-&gt;dev-&gt;bus
)paren
op_logical_or
op_logical_neg
(paren
id|controller
op_assign
id|bus-&gt;controller
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|controller-&gt;dma_mask
)paren
(brace
id|dma_sync_single
(paren
id|controller
comma
id|urb-&gt;transfer_dma
comma
id|urb-&gt;transfer_buffer_length
comma
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
ques
c_cond
id|DMA_FROM_DEVICE
suffix:colon
id|DMA_TO_DEVICE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipecontrol
(paren
id|urb-&gt;pipe
)paren
)paren
id|dma_sync_single
(paren
id|controller
comma
id|urb-&gt;setup_dma
comma
r_sizeof
(paren
r_struct
id|usb_ctrlrequest
)paren
comma
id|DMA_TO_DEVICE
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/**&n; * usb_buffer_unmap - free DMA mapping(s) for an urb&n; * @urb: urb whose transfer_buffer will be unmapped&n; *&n; * Reverses the effect of usb_buffer_map().&n; */
DECL|function|usb_buffer_unmap
r_void
id|usb_buffer_unmap
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|usb_bus
op_star
id|bus
suffix:semicolon
r_struct
id|device
op_star
id|controller
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
op_logical_or
op_logical_neg
(paren
id|urb-&gt;transfer_flags
op_amp
id|URB_NO_TRANSFER_DMA_MAP
)paren
op_logical_or
op_logical_neg
id|urb-&gt;dev
op_logical_or
op_logical_neg
(paren
id|bus
op_assign
id|urb-&gt;dev-&gt;bus
)paren
op_logical_or
op_logical_neg
(paren
id|controller
op_assign
id|bus-&gt;controller
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|controller-&gt;dma_mask
)paren
(brace
id|dma_unmap_single
(paren
id|controller
comma
id|urb-&gt;transfer_dma
comma
id|urb-&gt;transfer_buffer_length
comma
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
ques
c_cond
id|DMA_FROM_DEVICE
suffix:colon
id|DMA_TO_DEVICE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipecontrol
(paren
id|urb-&gt;pipe
)paren
)paren
id|dma_unmap_single
(paren
id|controller
comma
id|urb-&gt;setup_dma
comma
r_sizeof
(paren
r_struct
id|usb_ctrlrequest
)paren
comma
id|DMA_TO_DEVICE
)paren
suffix:semicolon
)brace
id|urb-&gt;transfer_flags
op_and_assign
op_complement
(paren
id|URB_NO_TRANSFER_DMA_MAP
op_or
id|URB_NO_SETUP_DMA_MAP
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_buffer_map_sg - create scatterlist DMA mapping(s) for an endpoint&n; * @dev: device to which the scatterlist will be mapped&n; * @pipe: endpoint defining the mapping direction&n; * @sg: the scatterlist to map&n; * @nents: the number of entries in the scatterlist&n; *&n; * Return value is either &lt; 0 (indicating no buffers could be mapped), or&n; * the number of DMA mapping array entries in the scatterlist.&n; *&n; * The caller is responsible for placing the resulting DMA addresses from&n; * the scatterlist into URB transfer buffer pointers, and for setting the&n; * URB_NO_TRANSFER_DMA_MAP transfer flag in each of those URBs.&n; *&n; * Top I/O rates come from queuing URBs, instead of waiting for each one&n; * to complete before starting the next I/O.   This is particularly easy&n; * to do with scatterlists.  Just allocate and submit one URB for each DMA&n; * mapping entry returned, stopping on the first error or when all succeed.&n; * Better yet, use the usb_sg_*() calls, which do that (and more) for you.&n; *&n; * This call would normally be used when translating scatterlist requests,&n; * rather than usb_buffer_map(), since on some hardware (with IOMMUs) it&n; * may be able to coalesce mappings for improved I/O efficiency.&n; *&n; * Reverse the effect of this call with usb_buffer_unmap_sg().&n; */
DECL|function|usb_buffer_map_sg
r_int
id|usb_buffer_map_sg
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|pipe
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
)paren
(brace
r_struct
id|usb_bus
op_star
id|bus
suffix:semicolon
r_struct
id|device
op_star
id|controller
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
op_logical_or
id|usb_pipecontrol
(paren
id|pipe
)paren
op_logical_or
op_logical_neg
(paren
id|bus
op_assign
id|dev-&gt;bus
)paren
op_logical_or
op_logical_neg
(paren
id|controller
op_assign
id|bus-&gt;controller
)paren
op_logical_or
op_logical_neg
id|controller-&gt;dma_mask
)paren
r_return
op_minus
l_int|1
suffix:semicolon
singleline_comment|// FIXME generic api broken like pci, can&squot;t report errors
r_return
id|dma_map_sg
(paren
id|controller
comma
id|sg
comma
id|nents
comma
id|usb_pipein
(paren
id|pipe
)paren
ques
c_cond
id|DMA_FROM_DEVICE
suffix:colon
id|DMA_TO_DEVICE
)paren
suffix:semicolon
)brace
multiline_comment|/* XXX DISABLED, no users currently.  If you wish to re-enable this&n; * XXX please determine whether the sync is to transfer ownership of&n; * XXX the buffer from device to cpu or vice verse, and thusly use the&n; * XXX appropriate _for_{cpu,device}() method.  -DaveM&n; */
macro_line|#if 0
multiline_comment|/**&n; * usb_buffer_dmasync_sg - synchronize DMA and CPU view of scatterlist buffer(s)&n; * @dev: device to which the scatterlist will be mapped&n; * @pipe: endpoint defining the mapping direction&n; * @sg: the scatterlist to synchronize&n; * @n_hw_ents: the positive return value from usb_buffer_map_sg&n; *&n; * Use this when you are re-using a scatterlist&squot;s data buffers for&n; * another USB request.&n; */
r_void
id|usb_buffer_dmasync_sg
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|pipe
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|n_hw_ents
)paren
(brace
r_struct
id|usb_bus
op_star
id|bus
suffix:semicolon
r_struct
id|device
op_star
id|controller
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
op_logical_or
op_logical_neg
(paren
id|bus
op_assign
id|dev-&gt;bus
)paren
op_logical_or
op_logical_neg
(paren
id|controller
op_assign
id|bus-&gt;controller
)paren
op_logical_or
op_logical_neg
id|controller-&gt;dma_mask
)paren
r_return
suffix:semicolon
id|dma_sync_sg
(paren
id|controller
comma
id|sg
comma
id|n_hw_ents
comma
id|usb_pipein
(paren
id|pipe
)paren
ques
c_cond
id|DMA_FROM_DEVICE
suffix:colon
id|DMA_TO_DEVICE
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/**&n; * usb_buffer_unmap_sg - free DMA mapping(s) for a scatterlist&n; * @dev: device to which the scatterlist will be mapped&n; * @pipe: endpoint defining the mapping direction&n; * @sg: the scatterlist to unmap&n; * @n_hw_ents: the positive return value from usb_buffer_map_sg&n; *&n; * Reverses the effect of usb_buffer_map_sg().&n; */
DECL|function|usb_buffer_unmap_sg
r_void
id|usb_buffer_unmap_sg
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|pipe
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|n_hw_ents
)paren
(brace
r_struct
id|usb_bus
op_star
id|bus
suffix:semicolon
r_struct
id|device
op_star
id|controller
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
op_logical_or
op_logical_neg
(paren
id|bus
op_assign
id|dev-&gt;bus
)paren
op_logical_or
op_logical_neg
(paren
id|controller
op_assign
id|bus-&gt;controller
)paren
op_logical_or
op_logical_neg
id|controller-&gt;dma_mask
)paren
r_return
suffix:semicolon
id|dma_unmap_sg
(paren
id|controller
comma
id|sg
comma
id|n_hw_ents
comma
id|usb_pipein
(paren
id|pipe
)paren
ques
c_cond
id|DMA_FROM_DEVICE
suffix:colon
id|DMA_TO_DEVICE
)paren
suffix:semicolon
)brace
DECL|function|usb_generic_suspend
r_static
r_int
id|usb_generic_suspend
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|u32
id|state
)paren
(brace
r_struct
id|usb_interface
op_star
id|intf
suffix:semicolon
r_struct
id|usb_driver
op_star
id|driver
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;driver
op_eq
op_amp
id|usb_generic_driver
)paren
r_return
id|usb_suspend_device
(paren
id|to_usb_device
c_func
(paren
id|dev
)paren
comma
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;driver
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|dev-&gt;driver_data
op_eq
op_amp
id|usb_generic_driver_data
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|intf
op_assign
id|to_usb_interface
c_func
(paren
id|dev
)paren
suffix:semicolon
id|driver
op_assign
id|to_usb_driver
c_func
(paren
id|dev-&gt;driver
)paren
suffix:semicolon
multiline_comment|/* there&squot;s only one USB suspend state */
r_if
c_cond
(paren
id|intf-&gt;dev.power.power_state
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|driver-&gt;suspend
)paren
r_return
id|driver
op_member_access_from_pointer
id|suspend
c_func
(paren
id|intf
comma
id|state
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usb_generic_resume
r_static
r_int
id|usb_generic_resume
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|usb_interface
op_star
id|intf
suffix:semicolon
r_struct
id|usb_driver
op_star
id|driver
suffix:semicolon
multiline_comment|/* devices resume through their hub */
r_if
c_cond
(paren
id|dev-&gt;driver
op_eq
op_amp
id|usb_generic_driver
)paren
r_return
id|usb_resume_device
(paren
id|to_usb_device
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;driver
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|dev-&gt;driver_data
op_eq
op_amp
id|usb_generic_driver_data
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|intf
op_assign
id|to_usb_interface
c_func
(paren
id|dev
)paren
suffix:semicolon
id|driver
op_assign
id|to_usb_driver
c_func
(paren
id|dev-&gt;driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver-&gt;resume
)paren
r_return
id|driver
op_member_access_from_pointer
id|resume
c_func
(paren
id|intf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|usb_bus_type
r_struct
id|bus_type
id|usb_bus_type
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;usb&quot;
comma
dot
id|match
op_assign
id|usb_device_match
comma
dot
id|hotplug
op_assign
id|usb_hotplug
comma
dot
id|suspend
op_assign
id|usb_generic_suspend
comma
dot
id|resume
op_assign
id|usb_generic_resume
comma
)brace
suffix:semicolon
macro_line|#ifndef MODULE
DECL|function|usb_setup_disable
r_static
r_int
id|__init
id|usb_setup_disable
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|nousb
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* format to disable USB on kernel command line is: nousb */
id|__setup
c_func
(paren
l_string|&quot;nousb&quot;
comma
id|usb_setup_disable
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * for external read access to &lt;nousb&gt;&n; */
DECL|function|usb_disabled
r_int
id|usb_disabled
c_func
(paren
r_void
)paren
(brace
r_return
id|nousb
suffix:semicolon
)brace
multiline_comment|/*&n; * Init&n; */
DECL|function|usb_init
r_static
r_int
id|__init
id|usb_init
c_func
(paren
r_void
)paren
(brace
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|nousb
)paren
(brace
id|pr_info
(paren
l_string|&quot;%s: USB support disabled&bslash;n&quot;
comma
id|usbcore_name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|retval
op_assign
id|bus_register
c_func
(paren
op_amp
id|usb_bus_type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|out
suffix:semicolon
id|retval
op_assign
id|usb_host_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|host_init_failed
suffix:semicolon
id|retval
op_assign
id|usb_major_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|major_init_failed
suffix:semicolon
id|retval
op_assign
id|usbfs_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|fs_init_failed
suffix:semicolon
id|retval
op_assign
id|usb_hub_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|hub_init_failed
suffix:semicolon
id|retval
op_assign
id|driver_register
c_func
(paren
op_amp
id|usb_generic_driver
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
r_goto
id|out
suffix:semicolon
id|usb_hub_cleanup
c_func
(paren
)paren
suffix:semicolon
id|hub_init_failed
suffix:colon
id|usbfs_cleanup
c_func
(paren
)paren
suffix:semicolon
id|fs_init_failed
suffix:colon
id|usb_major_cleanup
c_func
(paren
)paren
suffix:semicolon
id|major_init_failed
suffix:colon
id|usb_host_cleanup
c_func
(paren
)paren
suffix:semicolon
id|host_init_failed
suffix:colon
id|bus_unregister
c_func
(paren
op_amp
id|usb_bus_type
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Cleanup&n; */
DECL|function|usb_exit
r_static
r_void
id|__exit
id|usb_exit
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* This will matter if shutdown/reboot does exitcalls. */
r_if
c_cond
(paren
id|nousb
)paren
r_return
suffix:semicolon
id|driver_unregister
c_func
(paren
op_amp
id|usb_generic_driver
)paren
suffix:semicolon
id|usb_major_cleanup
c_func
(paren
)paren
suffix:semicolon
id|usbfs_cleanup
c_func
(paren
)paren
suffix:semicolon
id|usb_hub_cleanup
c_func
(paren
)paren
suffix:semicolon
id|usb_host_cleanup
c_func
(paren
)paren
suffix:semicolon
id|bus_unregister
c_func
(paren
op_amp
id|usb_bus_type
)paren
suffix:semicolon
)brace
DECL|variable|usb_init
id|subsys_initcall
c_func
(paren
id|usb_init
)paren
suffix:semicolon
DECL|variable|usb_exit
id|module_exit
c_func
(paren
id|usb_exit
)paren
suffix:semicolon
multiline_comment|/*&n; * USB may be built into the kernel or be built as modules.&n; * These symbols are exported for device (or host controller)&n; * driver modules to use.&n; */
DECL|variable|usb_register
id|EXPORT_SYMBOL
c_func
(paren
id|usb_register
)paren
suffix:semicolon
DECL|variable|usb_deregister
id|EXPORT_SYMBOL
c_func
(paren
id|usb_deregister
)paren
suffix:semicolon
DECL|variable|usb_disabled
id|EXPORT_SYMBOL
c_func
(paren
id|usb_disabled
)paren
suffix:semicolon
DECL|variable|usb_alloc_dev
id|EXPORT_SYMBOL
c_func
(paren
id|usb_alloc_dev
)paren
suffix:semicolon
DECL|variable|usb_put_dev
id|EXPORT_SYMBOL
c_func
(paren
id|usb_put_dev
)paren
suffix:semicolon
DECL|variable|usb_get_dev
id|EXPORT_SYMBOL
c_func
(paren
id|usb_get_dev
)paren
suffix:semicolon
DECL|variable|usb_hub_tt_clear_buffer
id|EXPORT_SYMBOL
c_func
(paren
id|usb_hub_tt_clear_buffer
)paren
suffix:semicolon
DECL|variable|usb_lock_device
id|EXPORT_SYMBOL
c_func
(paren
id|usb_lock_device
)paren
suffix:semicolon
DECL|variable|usb_trylock_device
id|EXPORT_SYMBOL
c_func
(paren
id|usb_trylock_device
)paren
suffix:semicolon
DECL|variable|usb_lock_device_for_reset
id|EXPORT_SYMBOL
c_func
(paren
id|usb_lock_device_for_reset
)paren
suffix:semicolon
DECL|variable|usb_unlock_device
id|EXPORT_SYMBOL
c_func
(paren
id|usb_unlock_device
)paren
suffix:semicolon
DECL|variable|usb_driver_claim_interface
id|EXPORT_SYMBOL
c_func
(paren
id|usb_driver_claim_interface
)paren
suffix:semicolon
DECL|variable|usb_driver_release_interface
id|EXPORT_SYMBOL
c_func
(paren
id|usb_driver_release_interface
)paren
suffix:semicolon
DECL|variable|usb_match_id
id|EXPORT_SYMBOL
c_func
(paren
id|usb_match_id
)paren
suffix:semicolon
DECL|variable|usb_find_interface
id|EXPORT_SYMBOL
c_func
(paren
id|usb_find_interface
)paren
suffix:semicolon
DECL|variable|usb_ifnum_to_if
id|EXPORT_SYMBOL
c_func
(paren
id|usb_ifnum_to_if
)paren
suffix:semicolon
DECL|variable|usb_altnum_to_altsetting
id|EXPORT_SYMBOL
c_func
(paren
id|usb_altnum_to_altsetting
)paren
suffix:semicolon
DECL|variable|usb_reset_device
id|EXPORT_SYMBOL
c_func
(paren
id|usb_reset_device
)paren
suffix:semicolon
DECL|variable|usb_disconnect
id|EXPORT_SYMBOL
c_func
(paren
id|usb_disconnect
)paren
suffix:semicolon
DECL|variable|__usb_get_extra_descriptor
id|EXPORT_SYMBOL
c_func
(paren
id|__usb_get_extra_descriptor
)paren
suffix:semicolon
DECL|variable|usb_find_device
id|EXPORT_SYMBOL
c_func
(paren
id|usb_find_device
)paren
suffix:semicolon
DECL|variable|usb_get_current_frame_number
id|EXPORT_SYMBOL
c_func
(paren
id|usb_get_current_frame_number
)paren
suffix:semicolon
DECL|variable|usb_buffer_alloc
id|EXPORT_SYMBOL
(paren
id|usb_buffer_alloc
)paren
suffix:semicolon
DECL|variable|usb_buffer_free
id|EXPORT_SYMBOL
(paren
id|usb_buffer_free
)paren
suffix:semicolon
DECL|variable|usb_buffer_map
id|EXPORT_SYMBOL
(paren
id|usb_buffer_map
)paren
suffix:semicolon
macro_line|#if 0
id|EXPORT_SYMBOL
(paren
id|usb_buffer_dmasync
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|usb_buffer_unmap
id|EXPORT_SYMBOL
(paren
id|usb_buffer_unmap
)paren
suffix:semicolon
DECL|variable|usb_buffer_map_sg
id|EXPORT_SYMBOL
(paren
id|usb_buffer_map_sg
)paren
suffix:semicolon
macro_line|#if 0
id|EXPORT_SYMBOL
(paren
id|usb_buffer_dmasync_sg
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|usb_buffer_unmap_sg
id|EXPORT_SYMBOL
(paren
id|usb_buffer_unmap_sg
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
