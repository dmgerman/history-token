multiline_comment|/*&n; * USB hub driver.&n; *&n; * (C) Copyright 1999 Linus Torvalds&n; * (C) Copyright 1999 Johannes Erdfelt&n; * (C) Copyright 1999 Gregory P. Smith&n; * (C) Copyright 2001 Brad Hards (bhards@bigpond.net.au)&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/completion.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#ifdef CONFIG_USB_DEBUG
DECL|macro|DEBUG
mdefine_line|#define DEBUG
macro_line|#else
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#endif
macro_line|#include &lt;linux/usb.h&gt;
macro_line|#include &lt;linux/usbdevice_fs.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &quot;hcd.h&quot;
macro_line|#include &quot;hub.h&quot;
multiline_comment|/* Wakes up khubd */
DECL|variable|hub_event_lock
r_static
id|spinlock_t
id|hub_event_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_static
id|DECLARE_MUTEX
c_func
(paren
id|usb_address0_sem
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|hub_event_list
)paren
suffix:semicolon
multiline_comment|/* List of hubs needing servicing */
r_static
id|LIST_HEAD
c_func
(paren
id|hub_list
)paren
suffix:semicolon
multiline_comment|/* List of all hubs (for cleanup) */
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|khubd_wait
)paren
suffix:semicolon
DECL|variable|khubd_pid
r_static
r_int
id|khubd_pid
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* PID of khubd */
r_static
id|DECLARE_COMPLETION
c_func
(paren
id|khubd_exited
)paren
suffix:semicolon
macro_line|#ifdef&t;DEBUG
DECL|function|portspeed
r_static
r_inline
r_char
op_star
id|portspeed
(paren
r_int
id|portstatus
)paren
(brace
r_if
c_cond
(paren
id|portstatus
op_amp
(paren
l_int|1
op_lshift
id|USB_PORT_FEAT_HIGHSPEED
)paren
)paren
r_return
l_string|&quot;480 Mb/s&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|portstatus
op_amp
(paren
l_int|1
op_lshift
id|USB_PORT_FEAT_LOWSPEED
)paren
)paren
r_return
l_string|&quot;1.5 Mb/s&quot;
suffix:semicolon
r_else
r_return
l_string|&quot;12 Mb/s&quot;
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* USB 2.0 spec Section 11.24.4.5 */
DECL|function|usb_get_hub_descriptor
r_static
r_int
id|usb_get_hub_descriptor
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_void
op_star
id|data
comma
r_int
id|size
)paren
(brace
r_return
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|USB_REQ_GET_DESCRIPTOR
comma
id|USB_DIR_IN
op_or
id|USB_RT_HUB
comma
id|USB_DT_HUB
op_lshift
l_int|8
comma
l_int|0
comma
id|data
comma
id|size
comma
id|HZ
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * USB 2.0 spec Section 11.24.2.1&n; */
DECL|function|usb_clear_hub_feature
r_static
r_int
id|usb_clear_hub_feature
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|feature
)paren
(brace
r_return
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|USB_REQ_CLEAR_FEATURE
comma
id|USB_RT_HUB
comma
id|feature
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * USB 2.0 spec Section 11.24.2.2&n; * BUG: doesn&squot;t handle port indicator selector in high byte of wIndex&n; */
DECL|function|usb_clear_port_feature
r_static
r_int
id|usb_clear_port_feature
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|port
comma
r_int
id|feature
)paren
(brace
r_return
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|USB_REQ_CLEAR_FEATURE
comma
id|USB_RT_PORT
comma
id|feature
comma
id|port
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * USB 2.0 spec Section 11.24.2.13&n; * BUG: doesn&squot;t handle port indicator selector in high byte of wIndex&n; */
DECL|function|usb_set_port_feature
r_static
r_int
id|usb_set_port_feature
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|port
comma
r_int
id|feature
)paren
(brace
r_return
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|USB_REQ_SET_FEATURE
comma
id|USB_RT_PORT
comma
id|feature
comma
id|port
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * USB 2.0 spec Section 11.24.2.6&n; */
DECL|function|usb_get_hub_status
r_static
r_int
id|usb_get_hub_status
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_void
op_star
id|data
)paren
(brace
r_return
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|USB_REQ_GET_STATUS
comma
id|USB_DIR_IN
op_or
id|USB_RT_HUB
comma
l_int|0
comma
l_int|0
comma
id|data
comma
r_sizeof
(paren
r_struct
id|usb_hub_status
)paren
comma
id|HZ
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * USB 2.0 spec Section 11.24.2.7&n; */
DECL|function|usb_get_port_status
r_static
r_int
id|usb_get_port_status
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|port
comma
r_void
op_star
id|data
)paren
(brace
r_return
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|USB_REQ_GET_STATUS
comma
id|USB_DIR_IN
op_or
id|USB_RT_PORT
comma
l_int|0
comma
id|port
comma
id|data
comma
r_sizeof
(paren
r_struct
id|usb_hub_status
)paren
comma
id|HZ
)paren
suffix:semicolon
)brace
multiline_comment|/* completion function, fires on port status changes and various faults */
DECL|function|hub_irq
r_static
r_void
id|hub_irq
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|usb_hub
op_star
id|hub
op_assign
(paren
r_struct
id|usb_hub
op_star
)paren
id|urb-&gt;context
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_switch
c_cond
(paren
id|urb-&gt;status
)paren
(brace
r_case
op_minus
id|ENOENT
suffix:colon
multiline_comment|/* synchronous unlink */
r_case
op_minus
id|ECONNRESET
suffix:colon
multiline_comment|/* async unlink */
r_case
op_minus
id|ESHUTDOWN
suffix:colon
multiline_comment|/* hardware going away */
r_return
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* presumably an error */
multiline_comment|/* Cause a hub reset after 10 consecutive errors */
id|dbg
c_func
(paren
l_string|&quot;hub &squot;%s&squot; status %d for interrupt transfer&quot;
comma
id|urb-&gt;dev-&gt;devpath
comma
id|urb-&gt;status
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_increment
id|hub-&gt;nerrors
OL
l_int|10
)paren
op_logical_or
id|hub-&gt;error
)paren
r_return
suffix:semicolon
id|hub-&gt;error
op_assign
id|urb-&gt;status
suffix:semicolon
multiline_comment|/* FALL THROUGH */
multiline_comment|/* let khubd handle things */
r_case
l_int|0
suffix:colon
multiline_comment|/* we got data:  port status changed */
r_break
suffix:semicolon
)brace
id|hub-&gt;nerrors
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Something happened, let khubd figure it out */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hub_event_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|hub-&gt;event_list
)paren
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|hub-&gt;event_list
comma
op_amp
id|hub_event_list
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|khubd_wait
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hub_event_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|usb_hub_power_on
r_static
r_void
id|usb_hub_power_on
c_func
(paren
r_struct
id|usb_hub
op_star
id|hub
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Enable power to the ports */
id|dbg
c_func
(paren
l_string|&quot;enabling power on all ports&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|hub-&gt;descriptor-&gt;bNbrPorts
suffix:semicolon
id|i
op_increment
)paren
id|usb_set_port_feature
c_func
(paren
id|hub-&gt;dev
comma
id|i
op_plus
l_int|1
comma
id|USB_PORT_FEAT_POWER
)paren
suffix:semicolon
multiline_comment|/* Wait for power to be enabled */
id|wait_ms
c_func
(paren
id|hub-&gt;descriptor-&gt;bPwrOn2PwrGood
op_star
l_int|2
)paren
suffix:semicolon
)brace
DECL|function|usb_hub_configure
r_static
r_int
id|usb_hub_configure
c_func
(paren
r_struct
id|usb_hub
op_star
id|hub
comma
r_struct
id|usb_endpoint_descriptor
op_star
id|endpoint
)paren
(brace
r_struct
id|usb_device
op_star
id|dev
op_assign
id|hub-&gt;dev
suffix:semicolon
r_struct
id|usb_hub_status
id|hubstatus
suffix:semicolon
r_char
id|portstr
(braket
id|USB_MAXCHILDREN
op_plus
l_int|1
)braket
suffix:semicolon
r_int
r_int
id|pipe
suffix:semicolon
r_int
id|i
comma
id|maxp
comma
id|ret
suffix:semicolon
id|hub-&gt;descriptor
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|hub-&gt;descriptor
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hub-&gt;descriptor
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Unable to kmalloc %Zd bytes for hub descriptor&quot;
comma
r_sizeof
(paren
op_star
id|hub-&gt;descriptor
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Request the entire hub descriptor.&n;&t; * hub-&gt;descriptor can handle USB_MAXCHILDREN ports,&n;&t; * but the hub can/will return fewer bytes here.&n;&t; */
id|ret
op_assign
id|usb_get_hub_descriptor
c_func
(paren
id|dev
comma
id|hub-&gt;descriptor
comma
r_sizeof
(paren
op_star
id|hub-&gt;descriptor
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Unable to get hub descriptor (err = %d)&quot;
comma
id|ret
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|hub-&gt;descriptor
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|hub-&gt;descriptor-&gt;bNbrPorts
OG
id|USB_MAXCHILDREN
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Hub is too big! %d children&quot;
comma
id|hub-&gt;descriptor-&gt;bNbrPorts
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|hub-&gt;descriptor
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|dev-&gt;maxchild
op_assign
id|hub-&gt;descriptor-&gt;bNbrPorts
suffix:semicolon
id|info
c_func
(paren
l_string|&quot;%d port%s detected&quot;
comma
id|dev-&gt;maxchild
comma
(paren
id|dev-&gt;maxchild
op_eq
l_int|1
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|le16_to_cpus
c_func
(paren
op_amp
id|hub-&gt;descriptor-&gt;wHubCharacteristics
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hub-&gt;descriptor-&gt;wHubCharacteristics
op_amp
id|HUB_CHAR_COMPOUND
)paren
id|dbg
c_func
(paren
l_string|&quot;part of a compound device&quot;
)paren
suffix:semicolon
r_else
id|dbg
c_func
(paren
l_string|&quot;standalone hub&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|hub-&gt;descriptor-&gt;wHubCharacteristics
op_amp
id|HUB_CHAR_LPSM
)paren
(brace
r_case
l_int|0x00
suffix:colon
id|dbg
c_func
(paren
l_string|&quot;ganged power switching&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x01
suffix:colon
id|dbg
c_func
(paren
l_string|&quot;individual port power switching&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x02
suffix:colon
r_case
l_int|0x03
suffix:colon
id|dbg
c_func
(paren
l_string|&quot;unknown reserved power switching mode&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|hub-&gt;descriptor-&gt;wHubCharacteristics
op_amp
id|HUB_CHAR_OCPM
)paren
(brace
r_case
l_int|0x00
suffix:colon
id|dbg
c_func
(paren
l_string|&quot;global over-current protection&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x08
suffix:colon
id|dbg
c_func
(paren
l_string|&quot;individual port over-current protection&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x10
suffix:colon
r_case
l_int|0x18
suffix:colon
id|dbg
c_func
(paren
l_string|&quot;no over-current protection&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|dev-&gt;descriptor.bDeviceProtocol
)paren
(brace
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|dbg
c_func
(paren
l_string|&quot;Single TT&quot;
)paren
suffix:semicolon
id|hub-&gt;tt.hub
op_assign
id|dev
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|dbg
c_func
(paren
l_string|&quot;TT per port&quot;
)paren
suffix:semicolon
id|hub-&gt;tt.hub
op_assign
id|dev
suffix:semicolon
id|hub-&gt;tt.multi
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|dbg
c_func
(paren
l_string|&quot;Unrecognized hub protocol %d&quot;
comma
id|dev-&gt;descriptor.bDeviceProtocol
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|hub-&gt;descriptor-&gt;wHubCharacteristics
op_amp
id|HUB_CHAR_TTTT
)paren
(brace
r_case
l_int|0x00
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;descriptor.bDeviceProtocol
op_ne
l_int|0
)paren
id|dbg
c_func
(paren
l_string|&quot;TT requires at most 8 FS bit times&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x20
suffix:colon
id|dbg
c_func
(paren
l_string|&quot;TT requires at most 16 FS bit times&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x40
suffix:colon
id|dbg
c_func
(paren
l_string|&quot;TT requires at most 24 FS bit times&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x60
suffix:colon
id|dbg
c_func
(paren
l_string|&quot;TT requires at most 32 FS bit times&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;Port indicators are %s supported&quot;
comma
(paren
id|hub-&gt;descriptor-&gt;wHubCharacteristics
op_amp
id|HUB_CHAR_PORTIND
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;not&quot;
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;power on to power good time: %dms&quot;
comma
id|hub-&gt;descriptor-&gt;bPwrOn2PwrGood
op_star
l_int|2
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;hub controller current requirement: %dmA&quot;
comma
id|hub-&gt;descriptor-&gt;bHubContrCurrent
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;maxchild
suffix:semicolon
id|i
op_increment
)paren
id|portstr
(braket
id|i
)braket
op_assign
id|hub-&gt;descriptor-&gt;DeviceRemovable
(braket
(paren
(paren
id|i
op_plus
l_int|1
)paren
op_div
l_int|8
)paren
)braket
op_amp
(paren
l_int|1
op_lshift
(paren
(paren
id|i
op_plus
l_int|1
)paren
op_mod
l_int|8
)paren
)paren
ques
c_cond
l_char|&squot;F&squot;
suffix:colon
l_char|&squot;R&squot;
suffix:semicolon
id|portstr
(braket
id|dev-&gt;maxchild
)braket
op_assign
l_int|0
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;port removable status: %s&quot;
comma
id|portstr
)paren
suffix:semicolon
id|ret
op_assign
id|usb_get_hub_status
c_func
(paren
id|dev
comma
op_amp
id|hubstatus
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Unable to get hub status (err = %d)&quot;
comma
id|ret
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|hub-&gt;descriptor
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|le16_to_cpus
c_func
(paren
op_amp
id|hubstatus.wHubStatus
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;local power source is %s&quot;
comma
(paren
id|hubstatus.wHubStatus
op_amp
id|HUB_STATUS_LOCAL_POWER
)paren
ques
c_cond
l_string|&quot;lost (inactive)&quot;
suffix:colon
l_string|&quot;good&quot;
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%sover-current condition exists&quot;
comma
(paren
id|hubstatus.wHubStatus
op_amp
id|HUB_STATUS_OVERCURRENT
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;no &quot;
)paren
suffix:semicolon
multiline_comment|/* Start the interrupt endpoint */
id|pipe
op_assign
id|usb_rcvintpipe
c_func
(paren
id|dev
comma
id|endpoint-&gt;bEndpointAddress
)paren
suffix:semicolon
id|maxp
op_assign
id|usb_maxpacket
c_func
(paren
id|dev
comma
id|pipe
comma
id|usb_pipeout
c_func
(paren
id|pipe
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|maxp
OG
r_sizeof
(paren
id|hub-&gt;buffer
)paren
)paren
id|maxp
op_assign
r_sizeof
(paren
id|hub-&gt;buffer
)paren
suffix:semicolon
id|hub-&gt;urb
op_assign
id|usb_alloc_urb
c_func
(paren
l_int|0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hub-&gt;urb
)paren
(brace
id|err
c_func
(paren
l_string|&quot;couldn&squot;t allocate interrupt urb&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|hub-&gt;descriptor
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|FILL_INT_URB
c_func
(paren
id|hub-&gt;urb
comma
id|dev
comma
id|pipe
comma
id|hub-&gt;buffer
comma
id|maxp
comma
id|hub_irq
comma
id|hub
comma
id|endpoint-&gt;bInterval
)paren
suffix:semicolon
id|ret
op_assign
id|usb_submit_urb
c_func
(paren
id|hub-&gt;urb
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|err
c_func
(paren
l_string|&quot;usb_submit_urb failed (%d)&quot;
comma
id|ret
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|hub-&gt;descriptor
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Wake up khubd */
id|wake_up
c_func
(paren
op_amp
id|khubd_wait
)paren
suffix:semicolon
id|usb_hub_power_on
c_func
(paren
id|hub
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|hub_probe
r_static
r_void
op_star
id|hub_probe
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|i
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
(brace
r_struct
id|usb_interface_descriptor
op_star
id|interface
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|endpoint
suffix:semicolon
r_struct
id|usb_hub
op_star
id|hub
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|interface
op_assign
op_amp
id|dev-&gt;actconfig-&gt;interface
(braket
id|i
)braket
dot
id|altsetting
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* Some hubs have a subclass of 1, which AFAICT according to the */
multiline_comment|/*  specs is not defined, but it works */
r_if
c_cond
(paren
(paren
id|interface-&gt;bInterfaceSubClass
op_ne
l_int|0
)paren
op_logical_and
(paren
id|interface-&gt;bInterfaceSubClass
op_ne
l_int|1
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;invalid subclass (%d) for USB hub device #%d&quot;
comma
id|interface-&gt;bInterfaceSubClass
comma
id|dev-&gt;devnum
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Multiple endpoints? What kind of mutant ninja-hub is this? */
r_if
c_cond
(paren
id|interface-&gt;bNumEndpoints
op_ne
l_int|1
)paren
(brace
id|err
c_func
(paren
l_string|&quot;invalid bNumEndpoints (%d) for USB hub device #%d&quot;
comma
id|interface-&gt;bNumEndpoints
comma
id|dev-&gt;devnum
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|endpoint
op_assign
op_amp
id|interface-&gt;endpoint
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* Output endpoint? Curiousier and curiousier.. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|endpoint-&gt;bEndpointAddress
op_amp
id|USB_DIR_IN
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Device #%d is hub class, but has output endpoint?&quot;
comma
id|dev-&gt;devnum
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* If it&squot;s not an interrupt endpoint, we&squot;d better punt! */
r_if
c_cond
(paren
(paren
id|endpoint-&gt;bmAttributes
op_amp
id|USB_ENDPOINT_XFERTYPE_MASK
)paren
op_ne
id|USB_ENDPOINT_XFER_INT
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Device #%d is hub class, but endpoint is not interrupt?&quot;
comma
id|dev-&gt;devnum
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* We found a hub */
id|info
c_func
(paren
l_string|&quot;USB hub found at %s&quot;
comma
id|dev-&gt;devpath
)paren
suffix:semicolon
id|hub
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|hub
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hub
)paren
(brace
id|err
c_func
(paren
l_string|&quot;couldn&squot;t kmalloc hub struct&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|hub
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|hub
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|hub-&gt;event_list
)paren
suffix:semicolon
id|hub-&gt;dev
op_assign
id|dev
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|hub-&gt;khubd_sem
)paren
suffix:semicolon
multiline_comment|/* Record the new hub&squot;s existence */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hub_event_lock
comma
id|flags
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|hub-&gt;hub_list
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|hub-&gt;hub_list
comma
op_amp
id|hub_list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hub_event_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_hub_configure
c_func
(paren
id|hub
comma
id|endpoint
)paren
op_ge
l_int|0
)paren
r_return
id|hub
suffix:semicolon
id|err
c_func
(paren
l_string|&quot;hub configuration failed for device at %s&quot;
comma
id|dev-&gt;devpath
)paren
suffix:semicolon
multiline_comment|/* free hub, but first clean up its list. */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hub_event_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Delete it and then reset it */
id|list_del
c_func
(paren
op_amp
id|hub-&gt;event_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|hub-&gt;event_list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|hub-&gt;hub_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|hub-&gt;hub_list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hub_event_lock
comma
id|flags
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|hub
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|hub_disconnect
r_static
r_void
id|hub_disconnect
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|usb_hub
op_star
id|hub
op_assign
(paren
r_struct
id|usb_hub
op_star
)paren
id|ptr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hub_event_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Delete it and then reset it */
id|list_del
c_func
(paren
op_amp
id|hub-&gt;event_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|hub-&gt;event_list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|hub-&gt;hub_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|hub-&gt;hub_list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hub_event_lock
comma
id|flags
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|hub-&gt;khubd_sem
)paren
suffix:semicolon
multiline_comment|/* Wait for khubd to leave this hub alone. */
id|up
c_func
(paren
op_amp
id|hub-&gt;khubd_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hub-&gt;urb
)paren
(brace
id|usb_unlink_urb
c_func
(paren
id|hub-&gt;urb
)paren
suffix:semicolon
id|usb_free_urb
c_func
(paren
id|hub-&gt;urb
)paren
suffix:semicolon
id|hub-&gt;urb
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hub-&gt;descriptor
)paren
(brace
id|kfree
c_func
(paren
id|hub-&gt;descriptor
)paren
suffix:semicolon
id|hub-&gt;descriptor
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Free the memory */
id|kfree
c_func
(paren
id|hub
)paren
suffix:semicolon
)brace
DECL|function|hub_ioctl
r_static
r_int
id|hub_ioctl
c_func
(paren
r_struct
id|usb_device
op_star
id|hub
comma
r_int
r_int
id|code
comma
r_void
op_star
id|user_data
)paren
(brace
multiline_comment|/* assert ifno == 0 (part of hub spec) */
r_switch
c_cond
(paren
id|code
)paren
(brace
r_case
id|USBDEVFS_HUB_PORTINFO
suffix:colon
(brace
r_struct
id|usbdevfs_hub_portinfo
op_star
id|info
op_assign
id|user_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hub_event_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hub-&gt;devnum
op_le
l_int|0
)paren
id|info-&gt;nports
op_assign
l_int|0
suffix:semicolon
r_else
(brace
id|info-&gt;nports
op_assign
id|hub-&gt;maxchild
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|info-&gt;nports
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|hub-&gt;children
(braket
id|i
)braket
op_eq
l_int|NULL
)paren
id|info-&gt;port
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_else
id|info-&gt;port
(braket
id|i
)braket
op_assign
id|hub-&gt;children
(braket
id|i
)braket
op_member_access_from_pointer
id|devnum
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hub_event_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|info-&gt;nports
op_plus
l_int|1
suffix:semicolon
)brace
r_default
suffix:colon
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
)brace
DECL|function|usb_hub_reset
r_static
r_int
id|usb_hub_reset
c_func
(paren
r_struct
id|usb_hub
op_star
id|hub
)paren
(brace
r_struct
id|usb_device
op_star
id|dev
op_assign
id|hub-&gt;dev
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Disconnect any attached devices */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|hub-&gt;descriptor-&gt;bNbrPorts
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;children
(braket
id|i
)braket
)paren
id|usb_disconnect
c_func
(paren
op_amp
id|dev-&gt;children
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Attempt to reset the hub */
r_if
c_cond
(paren
id|hub-&gt;urb
)paren
id|usb_unlink_urb
c_func
(paren
id|hub-&gt;urb
)paren
suffix:semicolon
r_else
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|usb_reset_device
c_func
(paren
id|dev
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|hub-&gt;urb-&gt;dev
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|usb_submit_urb
c_func
(paren
id|hub-&gt;urb
comma
id|GFP_KERNEL
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|usb_hub_power_on
c_func
(paren
id|hub
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usb_hub_disconnect
r_static
r_void
id|usb_hub_disconnect
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_struct
id|usb_device
op_star
id|parent
op_assign
id|dev-&gt;parent
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Find the device pointer to disconnect */
r_if
c_cond
(paren
id|parent
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|parent-&gt;maxchild
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|parent-&gt;children
(braket
id|i
)braket
op_eq
id|dev
)paren
(brace
id|usb_disconnect
c_func
(paren
op_amp
id|parent-&gt;children
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
id|err
c_func
(paren
l_string|&quot;cannot disconnect hub %s&quot;
comma
id|dev-&gt;devpath
)paren
suffix:semicolon
)brace
DECL|function|usb_hub_port_status
r_static
r_int
id|usb_hub_port_status
c_func
(paren
r_struct
id|usb_device
op_star
id|hub
comma
r_int
id|port
comma
id|u16
op_star
id|status
comma
id|u16
op_star
id|change
)paren
(brace
r_struct
id|usb_port_status
op_star
id|portsts
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|portsts
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|portsts
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|portsts
)paren
(brace
id|ret
op_assign
id|usb_get_port_status
c_func
(paren
id|hub
comma
id|port
op_plus
l_int|1
comma
id|portsts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
id|err
c_func
(paren
l_string|&quot;%s(%s) failed (err = %d)&quot;
comma
id|__FUNCTION__
comma
id|hub-&gt;devpath
comma
id|ret
)paren
suffix:semicolon
r_else
(brace
op_star
id|status
op_assign
id|le16_to_cpu
c_func
(paren
id|portsts-&gt;wPortStatus
)paren
suffix:semicolon
op_star
id|change
op_assign
id|le16_to_cpu
c_func
(paren
id|portsts-&gt;wPortChange
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;port %d, portstatus %x, change %x, %s&quot;
comma
id|port
op_plus
l_int|1
comma
op_star
id|status
comma
op_star
id|change
comma
id|portspeed
c_func
(paren
op_star
id|status
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|portsts
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|macro|HUB_RESET_TRIES
mdefine_line|#define HUB_RESET_TRIES&t;&t;5
DECL|macro|HUB_PROBE_TRIES
mdefine_line|#define HUB_PROBE_TRIES&t;&t;2
DECL|macro|HUB_SHORT_RESET_TIME
mdefine_line|#define HUB_SHORT_RESET_TIME&t;10
DECL|macro|HUB_LONG_RESET_TIME
mdefine_line|#define HUB_LONG_RESET_TIME&t;200
DECL|macro|HUB_RESET_TIMEOUT
mdefine_line|#define HUB_RESET_TIMEOUT&t;500
multiline_comment|/* return: -1 on error, 0 on success, 1 on disconnect.  */
DECL|function|usb_hub_port_wait_reset
r_static
r_int
id|usb_hub_port_wait_reset
c_func
(paren
r_struct
id|usb_device
op_star
id|hub
comma
r_int
id|port
comma
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|delay
)paren
(brace
r_int
id|delay_time
comma
id|ret
suffix:semicolon
id|u16
id|portstatus
suffix:semicolon
id|u16
id|portchange
suffix:semicolon
r_for
c_loop
(paren
id|delay_time
op_assign
l_int|0
suffix:semicolon
id|delay_time
OL
id|HUB_RESET_TIMEOUT
suffix:semicolon
id|delay_time
op_add_assign
id|delay
)paren
(brace
multiline_comment|/* wait to give the device a chance to reset */
id|wait_ms
c_func
(paren
id|delay
)paren
suffix:semicolon
multiline_comment|/* read and decode port status */
id|ret
op_assign
id|usb_hub_port_status
c_func
(paren
id|hub
comma
id|port
comma
op_amp
id|portstatus
comma
op_amp
id|portchange
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Device went away? */
r_if
c_cond
(paren
op_logical_neg
(paren
id|portstatus
op_amp
id|USB_PORT_STAT_CONNECTION
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* bomb out completely if something weird happened */
r_if
c_cond
(paren
(paren
id|portchange
op_amp
id|USB_PORT_STAT_C_CONNECTION
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* if we`ve finished resetting, then break out of the loop */
r_if
c_cond
(paren
op_logical_neg
(paren
id|portstatus
op_amp
id|USB_PORT_STAT_RESET
)paren
op_logical_and
(paren
id|portstatus
op_amp
id|USB_PORT_STAT_ENABLE
)paren
)paren
(brace
r_if
c_cond
(paren
id|portstatus
op_amp
id|USB_PORT_STAT_HIGH_SPEED
)paren
id|dev-&gt;speed
op_assign
id|USB_SPEED_HIGH
suffix:semicolon
r_else
r_if
c_cond
(paren
id|portstatus
op_amp
id|USB_PORT_STAT_LOW_SPEED
)paren
id|dev-&gt;speed
op_assign
id|USB_SPEED_LOW
suffix:semicolon
r_else
id|dev-&gt;speed
op_assign
id|USB_SPEED_FULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* switch to the long delay after two short delay failures */
r_if
c_cond
(paren
id|delay_time
op_ge
l_int|2
op_star
id|HUB_SHORT_RESET_TIME
)paren
id|delay
op_assign
id|HUB_LONG_RESET_TIME
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;port %d of hub %s not reset yet, waiting %dms&quot;
comma
id|port
op_plus
l_int|1
comma
id|hub-&gt;devpath
comma
id|delay
)paren
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* return: -1 on error, 0 on success, 1 on disconnect.  */
DECL|function|usb_hub_port_reset
r_static
r_int
id|usb_hub_port_reset
c_func
(paren
r_struct
id|usb_device
op_star
id|hub
comma
r_int
id|port
comma
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|delay
)paren
(brace
r_int
id|i
comma
id|status
suffix:semicolon
multiline_comment|/* Reset the port */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|HUB_RESET_TRIES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|usb_set_port_feature
c_func
(paren
id|hub
comma
id|port
op_plus
l_int|1
comma
id|USB_PORT_FEAT_RESET
)paren
suffix:semicolon
multiline_comment|/* return on disconnect or reset */
id|status
op_assign
id|usb_hub_port_wait_reset
c_func
(paren
id|hub
comma
id|port
comma
id|dev
comma
id|delay
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
op_minus
l_int|1
)paren
(brace
id|usb_clear_port_feature
c_func
(paren
id|hub
comma
id|port
op_plus
l_int|1
comma
id|USB_PORT_FEAT_C_RESET
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;port %d of hub %s not enabled, trying reset again...&quot;
comma
id|port
op_plus
l_int|1
comma
id|hub-&gt;devpath
)paren
suffix:semicolon
id|delay
op_assign
id|HUB_LONG_RESET_TIME
suffix:semicolon
)brace
id|err
c_func
(paren
l_string|&quot;Cannot enable port %i of hub %s, disabling port.&quot;
comma
id|port
op_plus
l_int|1
comma
id|hub-&gt;devpath
)paren
suffix:semicolon
id|err
c_func
(paren
l_string|&quot;Maybe the USB cable is bad?&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|usb_hub_port_disable
r_void
id|usb_hub_port_disable
c_func
(paren
r_struct
id|usb_device
op_star
id|hub
comma
r_int
id|port
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|usb_clear_port_feature
c_func
(paren
id|hub
comma
id|port
op_plus
l_int|1
comma
id|USB_PORT_FEAT_ENABLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
id|err
c_func
(paren
l_string|&quot;cannot disable port %d of hub %s (err = %d)&quot;
comma
id|port
op_plus
l_int|1
comma
id|hub-&gt;devpath
comma
id|ret
)paren
suffix:semicolon
)brace
multiline_comment|/* USB 2.0 spec, 7.1.7.3 / fig 7-29:&n; *&n; * Between connect detection and reset signaling there must be a delay&n; * of 100ms at least for debounce and power-settling. The corresponding&n; * timer shall restart whenever the downstream port detects a disconnect.&n; * &n; * Apparently there are some bluetooth and irda-dongles and a number&n; * of low-speed devices which require longer delays of about 200-400ms.&n; * Not covered by the spec - but easy to deal with.&n; *&n; * This implementation uses 400ms minimum debounce timeout and checks&n; * every 100ms for transient disconnects to restart the delay.&n; */
DECL|macro|HUB_DEBOUNCE_TIMEOUT
mdefine_line|#define HUB_DEBOUNCE_TIMEOUT&t;400
DECL|macro|HUB_DEBOUNCE_STEP
mdefine_line|#define HUB_DEBOUNCE_STEP&t;100
multiline_comment|/* return: -1 on error, 0 on success, 1 on disconnect.  */
DECL|function|usb_hub_port_debounce
r_static
r_int
id|usb_hub_port_debounce
c_func
(paren
r_struct
id|usb_device
op_star
id|hub
comma
r_int
id|port
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
id|delay_time
suffix:semicolon
id|u16
id|portchange
comma
id|portstatus
suffix:semicolon
r_for
c_loop
(paren
id|delay_time
op_assign
l_int|0
suffix:semicolon
id|delay_time
OL
id|HUB_DEBOUNCE_TIMEOUT
suffix:semicolon
multiline_comment|/* empty */
)paren
(brace
multiline_comment|/* wait debounce step increment */
id|wait_ms
c_func
(paren
id|HUB_DEBOUNCE_STEP
)paren
suffix:semicolon
id|ret
op_assign
id|usb_hub_port_status
c_func
(paren
id|hub
comma
id|port
comma
op_amp
id|portstatus
comma
op_amp
id|portchange
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|portchange
op_amp
id|USB_PORT_STAT_C_CONNECTION
)paren
)paren
(brace
id|usb_clear_port_feature
c_func
(paren
id|hub
comma
id|port
op_plus
l_int|1
comma
id|USB_PORT_FEAT_C_CONNECTION
)paren
suffix:semicolon
id|delay_time
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|delay_time
op_add_assign
id|HUB_DEBOUNCE_STEP
suffix:semicolon
)brace
r_return
(paren
(paren
id|portstatus
op_amp
id|USB_PORT_STAT_CONNECTION
)paren
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
)brace
DECL|function|usb_hub_port_connect_change
r_static
r_void
id|usb_hub_port_connect_change
c_func
(paren
r_struct
id|usb_hub
op_star
id|hubstate
comma
r_int
id|port
comma
id|u16
id|portstatus
comma
id|u16
id|portchange
)paren
(brace
r_struct
id|usb_device
op_star
id|hub
op_assign
id|hubstate-&gt;dev
suffix:semicolon
r_struct
id|usb_device
op_star
id|dev
suffix:semicolon
r_int
r_int
id|delay
op_assign
id|HUB_SHORT_RESET_TIME
suffix:semicolon
r_int
id|i
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;hub %s port %d, portstatus %x, change %x, %s&quot;
comma
id|hub-&gt;devpath
comma
id|port
op_plus
l_int|1
comma
id|portstatus
comma
id|portchange
comma
id|portspeed
(paren
id|portstatus
)paren
)paren
suffix:semicolon
multiline_comment|/* Clear the connection change status */
id|usb_clear_port_feature
c_func
(paren
id|hub
comma
id|port
op_plus
l_int|1
comma
id|USB_PORT_FEAT_C_CONNECTION
)paren
suffix:semicolon
multiline_comment|/* Disconnect any existing devices under this port */
r_if
c_cond
(paren
id|hub-&gt;children
(braket
id|port
)braket
)paren
id|usb_disconnect
c_func
(paren
op_amp
id|hub-&gt;children
(braket
id|port
)braket
)paren
suffix:semicolon
multiline_comment|/* Return now if nothing is connected */
r_if
c_cond
(paren
op_logical_neg
(paren
id|portstatus
op_amp
id|USB_PORT_STAT_CONNECTION
)paren
)paren
(brace
r_if
c_cond
(paren
id|portstatus
op_amp
id|USB_PORT_STAT_ENABLE
)paren
id|usb_hub_port_disable
c_func
(paren
id|hub
comma
id|port
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|usb_hub_port_debounce
c_func
(paren
id|hub
comma
id|port
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;connect-debounce failed, port %d disabled&quot;
comma
id|port
op_plus
l_int|1
)paren
suffix:semicolon
id|usb_hub_port_disable
c_func
(paren
id|hub
comma
id|port
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Some low speed devices have problems with the quick delay, so */
multiline_comment|/*  be a bit pessimistic with those devices. RHbug #23670 */
r_if
c_cond
(paren
id|portstatus
op_amp
id|USB_PORT_STAT_LOW_SPEED
)paren
id|delay
op_assign
id|HUB_LONG_RESET_TIME
suffix:semicolon
id|down
c_func
(paren
op_amp
id|usb_address0_sem
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|HUB_PROBE_TRIES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|usb_device
op_star
id|pdev
suffix:semicolon
r_int
id|len
suffix:semicolon
multiline_comment|/* Allocate a new device struct */
id|dev
op_assign
id|usb_alloc_dev
c_func
(paren
id|hub
comma
id|hub-&gt;bus
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|err
c_func
(paren
l_string|&quot;couldn&squot;t allocate usb_device&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|hub-&gt;children
(braket
id|port
)braket
op_assign
id|dev
suffix:semicolon
multiline_comment|/* Reset the device, and detect its speed */
r_if
c_cond
(paren
id|usb_hub_port_reset
c_func
(paren
id|hub
comma
id|port
comma
id|dev
comma
id|delay
)paren
)paren
(brace
id|usb_free_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Find a new address for it */
id|usb_connect
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Set up TT records, if needed  */
r_if
c_cond
(paren
id|hub-&gt;tt
)paren
(brace
id|dev-&gt;tt
op_assign
id|hub-&gt;tt
suffix:semicolon
id|dev-&gt;ttport
op_assign
id|hub-&gt;ttport
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;speed
op_ne
id|USB_SPEED_HIGH
op_logical_and
id|hub-&gt;speed
op_eq
id|USB_SPEED_HIGH
)paren
(brace
id|dev-&gt;tt
op_assign
op_amp
id|hubstate-&gt;tt
suffix:semicolon
id|dev-&gt;ttport
op_assign
id|port
op_plus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Save readable and stable topology id, distinguishing&n;&t;&t; * devices by location for diagnostics, tools, etc.  The&n;&t;&t; * string is a path along hub ports, from the root.  Each&n;&t;&t; * device&squot;s id will be stable until USB is re-cabled, and&n;&t;&t; * hubs are often labeled with these port numbers.&n;&t;&t; *&n;&t;&t; * Initial size: &quot;.NN&quot; times five hubs + NUL = 16 bytes max&n;&t;&t; * (quite rare, since most hubs have 4-6 ports).&n;&t;&t; */
id|pdev
op_assign
id|dev-&gt;parent
suffix:semicolon
r_if
c_cond
(paren
id|pdev-&gt;devpath
(braket
l_int|0
)braket
op_ne
l_char|&squot;/&squot;
)paren
multiline_comment|/* parent not root */
id|len
op_assign
id|snprintf
(paren
id|dev-&gt;devpath
comma
r_sizeof
id|dev-&gt;devpath
comma
l_string|&quot;%s.%d&quot;
comma
id|pdev-&gt;devpath
comma
id|port
op_plus
l_int|1
)paren
suffix:semicolon
r_else
multiline_comment|/* root == &quot;/&quot;, root port 2 == &quot;2&quot;, port 3 that hub &quot;/2.3&quot; */
id|len
op_assign
id|snprintf
(paren
id|dev-&gt;devpath
comma
r_sizeof
id|dev-&gt;devpath
comma
l_string|&quot;%d&quot;
comma
id|port
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
r_sizeof
id|dev-&gt;devpath
)paren
id|warn
(paren
l_string|&quot;devpath size! usb/%03d/%03d path %s&quot;
comma
id|dev-&gt;bus-&gt;busnum
comma
id|dev-&gt;devnum
comma
id|dev-&gt;devpath
)paren
suffix:semicolon
id|info
c_func
(paren
l_string|&quot;new USB device %s-%s, assigned address %d&quot;
comma
id|dev-&gt;bus-&gt;bus_name
comma
id|dev-&gt;devpath
comma
id|dev-&gt;devnum
)paren
suffix:semicolon
multiline_comment|/* put the device in the global device tree */
id|dev-&gt;dev.parent
op_assign
op_amp
id|dev-&gt;parent-&gt;dev
suffix:semicolon
id|sprintf
(paren
op_amp
id|dev-&gt;dev.name
(braket
l_int|0
)braket
comma
l_string|&quot;USB device %04x:%04x&quot;
comma
id|dev-&gt;descriptor.idVendor
comma
id|dev-&gt;descriptor.idProduct
)paren
suffix:semicolon
multiline_comment|/* find the number of the port this device is connected to */
id|sprintf
(paren
op_amp
id|dev-&gt;dev.bus_id
(braket
l_int|0
)braket
comma
l_string|&quot;unknown_port_%03d&quot;
comma
id|dev-&gt;devnum
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|USB_MAXCHILDREN
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;parent-&gt;children
(braket
id|i
)braket
op_eq
id|dev
)paren
(brace
id|sprintf
(paren
op_amp
id|dev-&gt;dev.bus_id
(braket
l_int|0
)braket
comma
l_string|&quot;%02d&quot;
comma
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Run it through the hoops (find a driver, etc) */
r_if
c_cond
(paren
op_logical_neg
id|usb_new_device
c_func
(paren
id|dev
)paren
)paren
r_goto
id|done
suffix:semicolon
multiline_comment|/* Free the configuration if there was an error */
id|usb_free_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Switch to a long reset time */
id|delay
op_assign
id|HUB_LONG_RESET_TIME
suffix:semicolon
)brace
id|hub-&gt;children
(braket
id|port
)braket
op_assign
l_int|NULL
suffix:semicolon
id|usb_hub_port_disable
c_func
(paren
id|hub
comma
id|port
)paren
suffix:semicolon
id|done
suffix:colon
id|up
c_func
(paren
op_amp
id|usb_address0_sem
)paren
suffix:semicolon
)brace
DECL|function|usb_hub_events
r_static
r_void
id|usb_hub_events
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_struct
id|usb_device
op_star
id|dev
suffix:semicolon
r_struct
id|usb_hub
op_star
id|hub
suffix:semicolon
r_struct
id|usb_hub_status
id|hubsts
suffix:semicolon
id|u16
id|hubstatus
suffix:semicolon
id|u16
id|hubchange
suffix:semicolon
id|u16
id|portstatus
suffix:semicolon
id|u16
id|portchange
suffix:semicolon
r_int
id|i
comma
id|ret
suffix:semicolon
multiline_comment|/*&n;&t; *  We restart the list everytime to avoid a deadlock with&n;&t; * deleting hubs downstream from this one. This should be&n;&t; * safe since we delete the hub from the event list.&n;&t; * Not the most efficient, but avoids deadlocks.&n;&t; */
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hub_event_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|hub_event_list
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* Grab the next entry from the beginning of the list */
id|tmp
op_assign
id|hub_event_list.next
suffix:semicolon
id|hub
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|usb_hub
comma
id|event_list
)paren
suffix:semicolon
id|dev
op_assign
id|hub-&gt;dev
suffix:semicolon
id|list_del
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|hub-&gt;khubd_sem
)paren
suffix:semicolon
multiline_comment|/* never blocks, we were on list */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hub_event_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hub-&gt;error
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;resetting hub %s for error %d&quot;
comma
id|dev-&gt;devpath
comma
id|hub-&gt;error
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_hub_reset
c_func
(paren
id|hub
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;error resetting hub %s - disconnecting&quot;
comma
id|dev-&gt;devpath
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|hub-&gt;khubd_sem
)paren
suffix:semicolon
id|usb_hub_disconnect
c_func
(paren
id|dev
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|hub-&gt;nerrors
op_assign
l_int|0
suffix:semicolon
id|hub-&gt;error
op_assign
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|hub-&gt;descriptor-&gt;bNbrPorts
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ret
op_assign
id|usb_hub_port_status
c_func
(paren
id|dev
comma
id|i
comma
op_amp
id|portstatus
comma
op_amp
id|portchange
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|portchange
op_amp
id|USB_PORT_STAT_C_CONNECTION
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;hub %s port %d connection change&quot;
comma
id|dev-&gt;devpath
comma
id|i
op_plus
l_int|1
)paren
suffix:semicolon
id|usb_hub_port_connect_change
c_func
(paren
id|hub
comma
id|i
comma
id|portstatus
comma
id|portchange
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|portchange
op_amp
id|USB_PORT_STAT_C_ENABLE
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;hub %s port %d enable change, status %x&quot;
comma
id|dev-&gt;devpath
comma
id|i
op_plus
l_int|1
comma
id|portstatus
)paren
suffix:semicolon
id|usb_clear_port_feature
c_func
(paren
id|dev
comma
id|i
op_plus
l_int|1
comma
id|USB_PORT_FEAT_C_ENABLE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * EM interference sometimes causes badly&n;&t;&t;&t;&t; * shielded USB devices to be shutdown by&n;&t;&t;&t;&t; * the hub, this hack enables them again.&n;&t;&t;&t;&t; * Works at least with mouse driver. &n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|portstatus
op_amp
id|USB_PORT_STAT_ENABLE
)paren
op_logical_and
(paren
id|portstatus
op_amp
id|USB_PORT_STAT_CONNECTION
)paren
op_logical_and
(paren
id|dev-&gt;children
(braket
id|i
)braket
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;already running hub %s port %i &quot;
l_string|&quot;disabled by hub (EMI?), &quot;
l_string|&quot;re-enabling...&quot;
comma
id|dev-&gt;devpath
comma
id|i
op_plus
l_int|1
)paren
suffix:semicolon
id|usb_hub_port_connect_change
c_func
(paren
id|hub
comma
id|i
comma
id|portstatus
comma
id|portchange
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|portchange
op_amp
id|USB_PORT_STAT_C_SUSPEND
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;hub %s port %d suspend change&quot;
comma
id|dev-&gt;devpath
comma
id|i
op_plus
l_int|1
)paren
suffix:semicolon
id|usb_clear_port_feature
c_func
(paren
id|dev
comma
id|i
op_plus
l_int|1
comma
id|USB_PORT_FEAT_C_SUSPEND
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|portchange
op_amp
id|USB_PORT_STAT_C_OVERCURRENT
)paren
(brace
id|err
c_func
(paren
l_string|&quot;hub %s port %d over-current change&quot;
comma
id|dev-&gt;devpath
comma
id|i
op_plus
l_int|1
)paren
suffix:semicolon
id|usb_clear_port_feature
c_func
(paren
id|dev
comma
id|i
op_plus
l_int|1
comma
id|USB_PORT_FEAT_C_OVER_CURRENT
)paren
suffix:semicolon
id|usb_hub_power_on
c_func
(paren
id|hub
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|portchange
op_amp
id|USB_PORT_STAT_C_RESET
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;hub %s port %d reset change&quot;
comma
id|dev-&gt;devpath
comma
id|i
op_plus
l_int|1
)paren
suffix:semicolon
id|usb_clear_port_feature
c_func
(paren
id|dev
comma
id|i
op_plus
l_int|1
comma
id|USB_PORT_FEAT_C_RESET
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* end for i */
multiline_comment|/* deal with hub status changes */
r_if
c_cond
(paren
id|usb_get_hub_status
c_func
(paren
id|dev
comma
op_amp
id|hubsts
)paren
OL
l_int|0
)paren
id|err
c_func
(paren
l_string|&quot;get_hub_status %s failed&quot;
comma
id|dev-&gt;devpath
)paren
suffix:semicolon
r_else
(brace
id|hubstatus
op_assign
id|le16_to_cpup
c_func
(paren
op_amp
id|hubsts.wHubStatus
)paren
suffix:semicolon
id|hubchange
op_assign
id|le16_to_cpup
c_func
(paren
op_amp
id|hubsts.wHubChange
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hubchange
op_amp
id|HUB_CHANGE_LOCAL_POWER
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;hub %s power change&quot;
comma
id|dev-&gt;devpath
)paren
suffix:semicolon
id|usb_clear_hub_feature
c_func
(paren
id|dev
comma
id|C_HUB_LOCAL_POWER
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hubchange
op_amp
id|HUB_CHANGE_OVERCURRENT
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;hub %s overcurrent change&quot;
comma
id|dev-&gt;devpath
)paren
suffix:semicolon
id|wait_ms
c_func
(paren
l_int|500
)paren
suffix:semicolon
multiline_comment|/* Cool down */
id|usb_clear_hub_feature
c_func
(paren
id|dev
comma
id|C_HUB_OVER_CURRENT
)paren
suffix:semicolon
id|usb_hub_power_on
c_func
(paren
id|hub
)paren
suffix:semicolon
)brace
)brace
id|up
c_func
(paren
op_amp
id|hub-&gt;khubd_sem
)paren
suffix:semicolon
)brace
multiline_comment|/* end while (1) */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hub_event_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|usb_hub_thread
r_static
r_int
id|usb_hub_thread
c_func
(paren
r_void
op_star
id|__hub
)paren
(brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This thread doesn&squot;t need any user-level access,&n;&t; * so get rid of all our resources&n;&t; */
id|daemonize
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Setup a nice name */
id|strcpy
c_func
(paren
id|current-&gt;comm
comma
l_string|&quot;khubd&quot;
)paren
suffix:semicolon
multiline_comment|/* Send me a signal to get me die (for debugging) */
r_do
(brace
id|usb_hub_events
c_func
(paren
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|khubd_wait
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|signal_pending
c_func
(paren
id|current
)paren
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;usb_hub_thread exiting&quot;
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|complete_and_exit
c_func
(paren
op_amp
id|khubd_exited
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|variable|hub_id_table
r_static
r_struct
id|usb_device_id
id|hub_id_table
(braket
)braket
op_assign
(brace
(brace
id|match_flags
suffix:colon
id|USB_DEVICE_ID_MATCH_DEV_CLASS
comma
id|bDeviceClass
suffix:colon
id|USB_CLASS_HUB
)brace
comma
(brace
id|match_flags
suffix:colon
id|USB_DEVICE_ID_MATCH_INT_CLASS
comma
id|bInterfaceClass
suffix:colon
id|USB_CLASS_HUB
)brace
comma
(brace
)brace
multiline_comment|/* Terminating entry */
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
(paren
id|usb
comma
id|hub_id_table
)paren
suffix:semicolon
DECL|variable|hub_driver
r_static
r_struct
id|usb_driver
id|hub_driver
op_assign
(brace
id|name
suffix:colon
l_string|&quot;hub&quot;
comma
id|probe
suffix:colon
id|hub_probe
comma
id|ioctl
suffix:colon
id|hub_ioctl
comma
id|disconnect
suffix:colon
id|hub_disconnect
comma
id|id_table
suffix:colon
id|hub_id_table
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * This should be a separate module.&n; */
DECL|function|usb_hub_init
r_int
id|usb_hub_init
c_func
(paren
r_void
)paren
(brace
r_int
id|pid
suffix:semicolon
r_if
c_cond
(paren
id|usb_register
c_func
(paren
op_amp
id|hub_driver
)paren
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Unable to register USB hub driver&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|pid
op_assign
id|kernel_thread
c_func
(paren
id|usb_hub_thread
comma
l_int|NULL
comma
id|CLONE_FS
op_or
id|CLONE_FILES
op_or
id|CLONE_SIGHAND
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pid
op_ge
l_int|0
)paren
(brace
id|khubd_pid
op_assign
id|pid
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Fall through if kernel_thread failed */
id|usb_deregister
c_func
(paren
op_amp
id|hub_driver
)paren
suffix:semicolon
id|err
c_func
(paren
l_string|&quot;failed to start usb_hub_thread&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|usb_hub_cleanup
r_void
id|usb_hub_cleanup
c_func
(paren
r_void
)paren
(brace
r_int
id|ret
suffix:semicolon
multiline_comment|/* Kill the thread */
id|ret
op_assign
id|kill_proc
c_func
(paren
id|khubd_pid
comma
id|SIGTERM
comma
l_int|1
)paren
suffix:semicolon
id|wait_for_completion
c_func
(paren
op_amp
id|khubd_exited
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Hub resources are freed for us by usb_deregister. It calls&n;&t; * usb_driver_purge on every device which in turn calls that&n;&t; * devices disconnect function if it is using this driver.&n;&t; * The hub_disconnect function takes care of releasing the&n;&t; * individual hub resources. -greg&n;&t; */
id|usb_deregister
c_func
(paren
op_amp
id|hub_driver
)paren
suffix:semicolon
)brace
multiline_comment|/* usb_hub_cleanup() */
multiline_comment|/*&n; * WARNING - If a driver calls usb_reset_device, you should simulate a&n; * disconnect() and probe() for other interfaces you doesn&squot;t claim. This&n; * is left up to the driver writer right now. This insures other drivers&n; * have a chance to re-setup their interface.&n; *&n; * Take a look at proc_resetdevice in devio.c for some sample code to&n; * do this.&n; */
DECL|function|usb_reset_device
r_int
id|usb_reset_device
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_struct
id|usb_device
op_star
id|parent
op_assign
id|dev-&gt;parent
suffix:semicolon
r_struct
id|usb_device_descriptor
id|descriptor
suffix:semicolon
r_int
id|i
comma
id|ret
comma
id|port
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parent
)paren
(brace
id|err
c_func
(paren
l_string|&quot;attempting to reset root hub!&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|parent-&gt;maxchild
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|parent-&gt;children
(braket
id|i
)braket
op_eq
id|dev
)paren
(brace
id|port
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|port
OL
l_int|0
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
id|down
c_func
(paren
op_amp
id|usb_address0_sem
)paren
suffix:semicolon
multiline_comment|/* Send a reset to the device */
r_if
c_cond
(paren
id|usb_hub_port_reset
c_func
(paren
id|parent
comma
id|port
comma
id|dev
comma
id|HUB_SHORT_RESET_TIME
)paren
)paren
(brace
id|usb_hub_port_disable
c_func
(paren
id|parent
comma
id|port
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|usb_address0_sem
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* Reprogram the Address */
id|ret
op_assign
id|usb_set_address
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;USB device not accepting new address (error=%d)&quot;
comma
id|ret
)paren
suffix:semicolon
id|usb_hub_port_disable
c_func
(paren
id|parent
comma
id|port
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|usb_address0_sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Let the SET_ADDRESS settle */
id|wait_ms
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|usb_address0_sem
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now we fetch the configuration descriptors for the device and&n;&t; * see if anything has changed. If it has, we dump the current&n;&t; * parsed descriptors and reparse from scratch. Then we leave&n;&t; * the device alone for the caller to finish setting up.&n;&t; *&n;&t; * If nothing changed, we reprogram the configuration and then&n;&t; * the alternate settings.&n;&t; */
id|ret
op_assign
id|usb_get_descriptor
c_func
(paren
id|dev
comma
id|USB_DT_DEVICE
comma
l_int|0
comma
op_amp
id|descriptor
comma
r_sizeof
(paren
id|descriptor
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
id|le16_to_cpus
c_func
(paren
op_amp
id|descriptor.bcdUSB
)paren
suffix:semicolon
id|le16_to_cpus
c_func
(paren
op_amp
id|descriptor.idVendor
)paren
suffix:semicolon
id|le16_to_cpus
c_func
(paren
op_amp
id|descriptor.idProduct
)paren
suffix:semicolon
id|le16_to_cpus
c_func
(paren
op_amp
id|descriptor.bcdDevice
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
op_amp
id|dev-&gt;descriptor
comma
op_amp
id|descriptor
comma
r_sizeof
(paren
id|descriptor
)paren
)paren
)paren
(brace
id|usb_destroy_configuration
c_func
(paren
id|dev
)paren
suffix:semicolon
id|ret
op_assign
id|usb_get_device_descriptor
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
r_sizeof
(paren
id|dev-&gt;descriptor
)paren
)paren
(brace
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
id|err
c_func
(paren
l_string|&quot;unable to get device %s descriptor &quot;
l_string|&quot;(error=%d)&quot;
comma
id|dev-&gt;devpath
comma
id|ret
)paren
suffix:semicolon
r_else
id|err
c_func
(paren
l_string|&quot;USB device %s descriptor short read &quot;
l_string|&quot;(expected %Zi, got %i)&quot;
comma
id|dev-&gt;devpath
comma
r_sizeof
(paren
id|dev-&gt;descriptor
)paren
comma
id|ret
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|dev-&gt;devnum
comma
op_amp
id|dev-&gt;bus-&gt;devmap.devicemap
)paren
suffix:semicolon
id|dev-&gt;devnum
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|ret
op_assign
id|usb_get_configuration
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;unable to get configuration (error=%d)&quot;
comma
id|ret
)paren
suffix:semicolon
id|usb_destroy_configuration
c_func
(paren
id|dev
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|dev-&gt;devnum
comma
op_amp
id|dev-&gt;bus-&gt;devmap.devicemap
)paren
suffix:semicolon
id|dev-&gt;devnum
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|dev-&gt;actconfig
op_assign
id|dev-&gt;config
suffix:semicolon
id|usb_set_maxpacket
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|ret
op_assign
id|usb_set_configuration
c_func
(paren
id|dev
comma
id|dev-&gt;actconfig-&gt;bConfigurationValue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;failed to set dev %s active configuration (error=%d)&quot;
comma
id|dev-&gt;devpath
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;actconfig-&gt;bNumInterfaces
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|usb_interface
op_star
id|intf
op_assign
op_amp
id|dev-&gt;actconfig-&gt;interface
(braket
id|i
)braket
suffix:semicolon
r_struct
id|usb_interface_descriptor
op_star
id|as
suffix:semicolon
id|as
op_assign
op_amp
id|intf-&gt;altsetting
(braket
id|intf-&gt;act_altsetting
)braket
suffix:semicolon
id|ret
op_assign
id|usb_set_interface
c_func
(paren
id|dev
comma
id|as-&gt;bInterfaceNumber
comma
id|as-&gt;bAlternateSetting
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;failed to set active alternate setting &quot;
l_string|&quot;for dev %s interface %d (error=%d)&quot;
comma
id|dev-&gt;devpath
comma
id|i
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
