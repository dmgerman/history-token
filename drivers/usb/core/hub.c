multiline_comment|/*&n; * USB hub driver.&n; *&n; * (C) Copyright 1999 Linus Torvalds&n; * (C) Copyright 1999 Johannes Erdfelt&n; * (C) Copyright 1999 Gregory P. Smith&n; * (C) Copyright 2001 Brad Hards (bhards@bigpond.net.au)&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#ifdef CONFIG_USB_DEBUG
DECL|macro|DEBUG
mdefine_line|#define DEBUG
macro_line|#else
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#endif
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;linux/completion.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/ioctl.h&gt;
macro_line|#include &lt;linux/usb.h&gt;
macro_line|#include &lt;linux/usbdevice_fs.h&gt;
macro_line|#include &lt;linux/suspend.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &quot;usb.h&quot;
macro_line|#include &quot;hcd.h&quot;
macro_line|#include &quot;hub.h&quot;
multiline_comment|/* Protect struct usb_device state and children members */
DECL|variable|device_state_lock
r_static
id|spinlock_t
id|device_state_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* Wakes up khubd */
DECL|variable|hub_event_lock
r_static
id|spinlock_t
id|hub_event_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|hub_event_list
)paren
suffix:semicolon
multiline_comment|/* List of hubs needing servicing */
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|khubd_wait
)paren
suffix:semicolon
DECL|variable|khubd_pid
r_static
id|pid_t
id|khubd_pid
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* PID of khubd */
r_static
id|DECLARE_COMPLETION
c_func
(paren
id|khubd_exited
)paren
suffix:semicolon
multiline_comment|/* cycle leds on hubs that aren&squot;t blinking for attention */
DECL|variable|blinkenlights
r_static
r_int
id|blinkenlights
op_assign
l_int|0
suffix:semicolon
id|module_param
(paren
id|blinkenlights
comma
r_bool
comma
id|S_IRUGO
)paren
suffix:semicolon
id|MODULE_PARM_DESC
(paren
id|blinkenlights
comma
l_string|&quot;true to cycle leds on hubs&quot;
)paren
suffix:semicolon
macro_line|#ifdef&t;DEBUG
DECL|function|portspeed
r_static
r_inline
r_char
op_star
id|portspeed
(paren
r_int
id|portstatus
)paren
(brace
r_if
c_cond
(paren
id|portstatus
op_amp
(paren
l_int|1
op_lshift
id|USB_PORT_FEAT_HIGHSPEED
)paren
)paren
r_return
l_string|&quot;480 Mb/s&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|portstatus
op_amp
(paren
l_int|1
op_lshift
id|USB_PORT_FEAT_LOWSPEED
)paren
)paren
r_return
l_string|&quot;1.5 Mb/s&quot;
suffix:semicolon
r_else
r_return
l_string|&quot;12 Mb/s&quot;
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* for dev_info, dev_dbg, etc */
DECL|function|hubdev
r_static
r_inline
r_struct
id|device
op_star
id|hubdev
(paren
r_struct
id|usb_device
op_star
id|hdev
)paren
(brace
r_return
op_amp
id|hdev-&gt;actconfig-&gt;interface
(braket
l_int|0
)braket
op_member_access_from_pointer
id|dev
suffix:semicolon
)brace
multiline_comment|/* USB 2.0 spec Section 11.24.4.5 */
DECL|function|get_hub_descriptor
r_static
r_int
id|get_hub_descriptor
c_func
(paren
r_struct
id|usb_device
op_star
id|hdev
comma
r_void
op_star
id|data
comma
r_int
id|size
)paren
(brace
r_return
id|usb_control_msg
c_func
(paren
id|hdev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|hdev
comma
l_int|0
)paren
comma
id|USB_REQ_GET_DESCRIPTOR
comma
id|USB_DIR_IN
op_or
id|USB_RT_HUB
comma
id|USB_DT_HUB
op_lshift
l_int|8
comma
l_int|0
comma
id|data
comma
id|size
comma
id|HZ
op_star
id|USB_CTRL_GET_TIMEOUT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * USB 2.0 spec Section 11.24.2.1&n; */
DECL|function|clear_hub_feature
r_static
r_int
id|clear_hub_feature
c_func
(paren
r_struct
id|usb_device
op_star
id|hdev
comma
r_int
id|feature
)paren
(brace
r_return
id|usb_control_msg
c_func
(paren
id|hdev
comma
id|usb_sndctrlpipe
c_func
(paren
id|hdev
comma
l_int|0
)paren
comma
id|USB_REQ_CLEAR_FEATURE
comma
id|USB_RT_HUB
comma
id|feature
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * USB 2.0 spec Section 11.24.2.2&n; */
DECL|function|clear_port_feature
r_static
r_int
id|clear_port_feature
c_func
(paren
r_struct
id|usb_device
op_star
id|hdev
comma
r_int
id|port
comma
r_int
id|feature
)paren
(brace
r_return
id|usb_control_msg
c_func
(paren
id|hdev
comma
id|usb_sndctrlpipe
c_func
(paren
id|hdev
comma
l_int|0
)paren
comma
id|USB_REQ_CLEAR_FEATURE
comma
id|USB_RT_PORT
comma
id|feature
comma
id|port
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * USB 2.0 spec Section 11.24.2.13&n; */
DECL|function|set_port_feature
r_static
r_int
id|set_port_feature
c_func
(paren
r_struct
id|usb_device
op_star
id|hdev
comma
r_int
id|port
comma
r_int
id|feature
)paren
(brace
r_return
id|usb_control_msg
c_func
(paren
id|hdev
comma
id|usb_sndctrlpipe
c_func
(paren
id|hdev
comma
l_int|0
)paren
comma
id|USB_REQ_SET_FEATURE
comma
id|USB_RT_PORT
comma
id|feature
comma
id|port
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * USB 2.0 spec Section 11.24.2.7.1.10 and table 11-7&n; * for info about using port indicators&n; */
DECL|function|set_port_led
r_static
r_void
id|set_port_led
c_func
(paren
r_struct
id|usb_device
op_star
id|hdev
comma
r_int
id|port
comma
r_int
id|selector
)paren
(brace
r_int
id|status
op_assign
id|set_port_feature
c_func
(paren
id|hdev
comma
(paren
id|selector
op_lshift
l_int|8
)paren
op_or
id|port
comma
id|USB_PORT_FEAT_INDICATOR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
id|dev_dbg
(paren
id|hubdev
(paren
id|hdev
)paren
comma
l_string|&quot;port %d indicator %s status %d&bslash;n&quot;
comma
id|port
comma
(paren
(brace
r_char
op_star
id|s
suffix:semicolon
r_switch
(paren
id|selector
)paren
(brace
r_case
id|HUB_LED_AMBER
suffix:colon
id|s
op_assign
l_string|&quot;amber&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HUB_LED_GREEN
suffix:colon
id|s
op_assign
l_string|&quot;green&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HUB_LED_OFF
suffix:colon
id|s
op_assign
l_string|&quot;off&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HUB_LED_AUTO
suffix:colon
id|s
op_assign
l_string|&quot;auto&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|s
op_assign
l_string|&quot;??&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|s
suffix:semicolon
)brace
)paren
comma
id|status
)paren
suffix:semicolon
)brace
DECL|macro|LED_CYCLE_PERIOD
mdefine_line|#define&t;LED_CYCLE_PERIOD&t;((2*HZ)/3)
DECL|function|led_work
r_static
r_void
id|led_work
(paren
r_void
op_star
id|__hub
)paren
(brace
r_struct
id|usb_hub
op_star
id|hub
op_assign
id|__hub
suffix:semicolon
r_struct
id|usb_device
op_star
id|hdev
op_assign
id|hub-&gt;hdev
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|changed
op_assign
l_int|0
suffix:semicolon
r_int
id|cursor
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|hdev-&gt;state
op_ne
id|USB_STATE_CONFIGURED
op_logical_or
id|hub-&gt;quiescing
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|hub-&gt;descriptor-&gt;bNbrPorts
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|selector
comma
id|mode
suffix:semicolon
multiline_comment|/* 30%-50% duty cycle */
r_switch
c_cond
(paren
id|hub-&gt;indicator
(braket
id|i
)braket
)paren
(brace
multiline_comment|/* cycle marker */
r_case
id|INDICATOR_CYCLE
suffix:colon
id|cursor
op_assign
id|i
suffix:semicolon
id|selector
op_assign
id|HUB_LED_AUTO
suffix:semicolon
id|mode
op_assign
id|INDICATOR_AUTO
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* blinking green = sw attention */
r_case
id|INDICATOR_GREEN_BLINK
suffix:colon
id|selector
op_assign
id|HUB_LED_GREEN
suffix:semicolon
id|mode
op_assign
id|INDICATOR_GREEN_BLINK_OFF
suffix:semicolon
r_break
suffix:semicolon
r_case
id|INDICATOR_GREEN_BLINK_OFF
suffix:colon
id|selector
op_assign
id|HUB_LED_OFF
suffix:semicolon
id|mode
op_assign
id|INDICATOR_GREEN_BLINK
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* blinking amber = hw attention */
r_case
id|INDICATOR_AMBER_BLINK
suffix:colon
id|selector
op_assign
id|HUB_LED_AMBER
suffix:semicolon
id|mode
op_assign
id|INDICATOR_AMBER_BLINK_OFF
suffix:semicolon
r_break
suffix:semicolon
r_case
id|INDICATOR_AMBER_BLINK_OFF
suffix:colon
id|selector
op_assign
id|HUB_LED_OFF
suffix:semicolon
id|mode
op_assign
id|INDICATOR_AMBER_BLINK
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* blink green/amber = reserved */
r_case
id|INDICATOR_ALT_BLINK
suffix:colon
id|selector
op_assign
id|HUB_LED_GREEN
suffix:semicolon
id|mode
op_assign
id|INDICATOR_ALT_BLINK_OFF
suffix:semicolon
r_break
suffix:semicolon
r_case
id|INDICATOR_ALT_BLINK_OFF
suffix:colon
id|selector
op_assign
id|HUB_LED_AMBER
suffix:semicolon
id|mode
op_assign
id|INDICATOR_ALT_BLINK
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|selector
op_ne
id|HUB_LED_AUTO
)paren
id|changed
op_assign
l_int|1
suffix:semicolon
id|set_port_led
c_func
(paren
id|hdev
comma
id|i
op_plus
l_int|1
comma
id|selector
)paren
suffix:semicolon
id|hub-&gt;indicator
(braket
id|i
)braket
op_assign
id|mode
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|changed
op_logical_and
id|blinkenlights
)paren
(brace
id|cursor
op_increment
suffix:semicolon
id|cursor
op_mod_assign
id|hub-&gt;descriptor-&gt;bNbrPorts
suffix:semicolon
id|set_port_led
c_func
(paren
id|hdev
comma
id|cursor
op_plus
l_int|1
comma
id|HUB_LED_GREEN
)paren
suffix:semicolon
id|hub-&gt;indicator
(braket
id|cursor
)braket
op_assign
id|INDICATOR_CYCLE
suffix:semicolon
id|changed
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|changed
)paren
id|schedule_delayed_work
c_func
(paren
op_amp
id|hub-&gt;leds
comma
id|LED_CYCLE_PERIOD
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * USB 2.0 spec Section 11.24.2.6&n; */
DECL|function|get_hub_status
r_static
r_int
id|get_hub_status
c_func
(paren
r_struct
id|usb_device
op_star
id|hdev
comma
r_struct
id|usb_hub_status
op_star
id|data
)paren
(brace
r_return
id|usb_control_msg
c_func
(paren
id|hdev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|hdev
comma
l_int|0
)paren
comma
id|USB_REQ_GET_STATUS
comma
id|USB_DIR_IN
op_or
id|USB_RT_HUB
comma
l_int|0
comma
l_int|0
comma
id|data
comma
r_sizeof
(paren
op_star
id|data
)paren
comma
id|HZ
op_star
id|USB_CTRL_GET_TIMEOUT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * USB 2.0 spec Section 11.24.2.7&n; */
DECL|function|get_port_status
r_static
r_int
id|get_port_status
c_func
(paren
r_struct
id|usb_device
op_star
id|hdev
comma
r_int
id|port
comma
r_struct
id|usb_port_status
op_star
id|data
)paren
(brace
r_return
id|usb_control_msg
c_func
(paren
id|hdev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|hdev
comma
l_int|0
)paren
comma
id|USB_REQ_GET_STATUS
comma
id|USB_DIR_IN
op_or
id|USB_RT_PORT
comma
l_int|0
comma
id|port
comma
id|data
comma
r_sizeof
(paren
op_star
id|data
)paren
comma
id|HZ
op_star
id|USB_CTRL_GET_TIMEOUT
)paren
suffix:semicolon
)brace
multiline_comment|/* completion function, fires on port status changes and various faults */
DECL|function|hub_irq
r_static
r_void
id|hub_irq
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|usb_hub
op_star
id|hub
op_assign
(paren
r_struct
id|usb_hub
op_star
)paren
id|urb-&gt;context
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|bits
suffix:semicolon
r_switch
c_cond
(paren
id|urb-&gt;status
)paren
(brace
r_case
op_minus
id|ENOENT
suffix:colon
multiline_comment|/* synchronous unlink */
r_case
op_minus
id|ECONNRESET
suffix:colon
multiline_comment|/* async unlink */
r_case
op_minus
id|ESHUTDOWN
suffix:colon
multiline_comment|/* hardware going away */
r_return
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* presumably an error */
multiline_comment|/* Cause a hub reset after 10 consecutive errors */
id|dev_dbg
(paren
op_amp
id|hub-&gt;intf-&gt;dev
comma
l_string|&quot;transfer --&gt; %d&bslash;n&quot;
comma
id|urb-&gt;status
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_increment
id|hub-&gt;nerrors
OL
l_int|10
)paren
op_logical_or
id|hub-&gt;error
)paren
r_goto
id|resubmit
suffix:semicolon
id|hub-&gt;error
op_assign
id|urb-&gt;status
suffix:semicolon
multiline_comment|/* FALL THROUGH */
multiline_comment|/* let khubd handle things */
r_case
l_int|0
suffix:colon
multiline_comment|/* we got data:  port status changed */
id|bits
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|urb-&gt;actual_length
suffix:semicolon
op_increment
id|i
)paren
id|bits
op_or_assign
(paren
(paren
r_int
r_int
)paren
(paren
(paren
op_star
id|hub-&gt;buffer
)paren
(braket
id|i
)braket
)paren
)paren
op_lshift
(paren
id|i
op_star
l_int|8
)paren
suffix:semicolon
id|hub-&gt;event_bits
(braket
l_int|0
)braket
op_assign
id|bits
suffix:semicolon
r_break
suffix:semicolon
)brace
id|hub-&gt;nerrors
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Something happened, let khubd figure it out */
id|spin_lock
c_func
(paren
op_amp
id|hub_event_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|hub-&gt;event_list
)paren
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
id|hub-&gt;event_list
comma
op_amp
id|hub_event_list
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|khubd_wait
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|hub_event_lock
)paren
suffix:semicolon
id|resubmit
suffix:colon
r_if
c_cond
(paren
id|hub-&gt;quiescing
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_assign
id|usb_submit_urb
(paren
id|hub-&gt;urb
comma
id|GFP_ATOMIC
)paren
)paren
op_ne
l_int|0
op_logical_and
id|status
op_ne
op_minus
id|ENODEV
op_logical_and
id|status
op_ne
op_minus
id|EPERM
)paren
id|dev_err
(paren
op_amp
id|hub-&gt;intf-&gt;dev
comma
l_string|&quot;resubmit --&gt; %d&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/* USB 2.0 spec Section 11.24.2.3 */
r_static
r_inline
r_int
DECL|function|hub_clear_tt_buffer
id|hub_clear_tt_buffer
(paren
r_struct
id|usb_device
op_star
id|hdev
comma
id|u16
id|devinfo
comma
id|u16
id|tt
)paren
(brace
r_return
id|usb_control_msg
c_func
(paren
id|hdev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|hdev
comma
l_int|0
)paren
comma
id|HUB_CLEAR_TT_BUFFER
comma
id|USB_RT_PORT
comma
id|devinfo
comma
id|tt
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * enumeration blocks khubd for a long time. we use keventd instead, since&n; * long blocking there is the exception, not the rule.  accordingly, HCDs&n; * talking to TTs must queue control transfers (not just bulk and iso), so&n; * both can talk to the same hub concurrently.&n; */
DECL|function|hub_tt_kevent
r_static
r_void
id|hub_tt_kevent
(paren
r_void
op_star
id|arg
)paren
(brace
r_struct
id|usb_hub
op_star
id|hub
op_assign
id|arg
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|hub-&gt;tt.lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|hub-&gt;tt.clear_list
)paren
)paren
(brace
r_struct
id|list_head
op_star
id|temp
suffix:semicolon
r_struct
id|usb_tt_clear
op_star
id|clear
suffix:semicolon
r_struct
id|usb_device
op_star
id|hdev
op_assign
id|hub-&gt;hdev
suffix:semicolon
r_int
id|status
suffix:semicolon
id|temp
op_assign
id|hub-&gt;tt.clear_list.next
suffix:semicolon
id|clear
op_assign
id|list_entry
(paren
id|temp
comma
r_struct
id|usb_tt_clear
comma
id|clear_list
)paren
suffix:semicolon
id|list_del
(paren
op_amp
id|clear-&gt;clear_list
)paren
suffix:semicolon
multiline_comment|/* drop lock so HCD can concurrently report other TT errors */
id|spin_unlock_irqrestore
(paren
op_amp
id|hub-&gt;tt.lock
comma
id|flags
)paren
suffix:semicolon
id|status
op_assign
id|hub_clear_tt_buffer
(paren
id|hdev
comma
id|clear-&gt;devinfo
comma
id|clear-&gt;tt
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|hub-&gt;tt.lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
id|dev_err
(paren
op_amp
id|hdev-&gt;dev
comma
l_string|&quot;clear tt %d (%04x) error %d&bslash;n&quot;
comma
id|clear-&gt;tt
comma
id|clear-&gt;devinfo
comma
id|status
)paren
suffix:semicolon
id|kfree
(paren
id|clear
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|hub-&gt;tt.lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_hub_tt_clear_buffer - clear control/bulk TT state in high speed hub&n; * @dev: the device whose split transaction failed&n; * @pipe: identifies the endpoint of the failed transaction&n; *&n; * High speed HCDs use this to tell the hub driver that some split control or&n; * bulk transaction failed in a way that requires clearing internal state of&n; * a transaction translator.  This is normally detected (and reported) from&n; * interrupt context.&n; *&n; * It may not be possible for that hub to handle additional full (or low)&n; * speed transactions until that state is fully cleared out.&n; */
DECL|function|usb_hub_tt_clear_buffer
r_void
id|usb_hub_tt_clear_buffer
(paren
r_struct
id|usb_device
op_star
id|udev
comma
r_int
id|pipe
)paren
(brace
r_struct
id|usb_tt
op_star
id|tt
op_assign
id|udev-&gt;tt
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|usb_tt_clear
op_star
id|clear
suffix:semicolon
multiline_comment|/* we&squot;ve got to cope with an arbitrary number of pending TT clears,&n;&t; * since each TT has &quot;at least two&quot; buffers that can need it (and&n;&t; * there can be many TTs per hub).  even if they&squot;re uncommon.&n;&t; */
r_if
c_cond
(paren
(paren
id|clear
op_assign
id|kmalloc
(paren
r_sizeof
op_star
id|clear
comma
id|SLAB_ATOMIC
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|dev_err
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;can&squot;t save CLEAR_TT_BUFFER state&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* FIXME recover somehow ... RESET_TT? */
r_return
suffix:semicolon
)brace
multiline_comment|/* info that CLEAR_TT_BUFFER needs */
id|clear-&gt;tt
op_assign
id|tt-&gt;multi
ques
c_cond
id|udev-&gt;ttport
suffix:colon
l_int|1
suffix:semicolon
id|clear-&gt;devinfo
op_assign
id|usb_pipeendpoint
(paren
id|pipe
)paren
suffix:semicolon
id|clear-&gt;devinfo
op_or_assign
id|udev-&gt;devnum
op_lshift
l_int|4
suffix:semicolon
id|clear-&gt;devinfo
op_or_assign
id|usb_pipecontrol
(paren
id|pipe
)paren
ques
c_cond
(paren
id|USB_ENDPOINT_XFER_CONTROL
op_lshift
l_int|11
)paren
suffix:colon
(paren
id|USB_ENDPOINT_XFER_BULK
op_lshift
l_int|11
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipein
(paren
id|pipe
)paren
)paren
id|clear-&gt;devinfo
op_or_assign
l_int|1
op_lshift
l_int|15
suffix:semicolon
multiline_comment|/* tell keventd to clear state for this TT */
id|spin_lock_irqsave
(paren
op_amp
id|tt-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|clear-&gt;clear_list
comma
op_amp
id|tt-&gt;clear_list
)paren
suffix:semicolon
id|schedule_work
(paren
op_amp
id|tt-&gt;kevent
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|tt-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|hub_power_on
r_static
r_void
id|hub_power_on
c_func
(paren
r_struct
id|usb_hub
op_star
id|hub
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* if hub supports power switching, enable power on each port */
r_if
c_cond
(paren
(paren
id|hub-&gt;descriptor-&gt;wHubCharacteristics
op_amp
id|HUB_CHAR_LPSM
)paren
OL
l_int|2
)paren
(brace
id|dev_dbg
c_func
(paren
op_amp
id|hub-&gt;intf-&gt;dev
comma
l_string|&quot;enabling power on all ports&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|hub-&gt;descriptor-&gt;bNbrPorts
suffix:semicolon
id|i
op_increment
)paren
id|set_port_feature
c_func
(paren
id|hub-&gt;hdev
comma
id|i
op_plus
l_int|1
comma
id|USB_PORT_FEAT_POWER
)paren
suffix:semicolon
)brace
multiline_comment|/* Wait for power to be enabled */
id|msleep
c_func
(paren
id|hub-&gt;descriptor-&gt;bPwrOn2PwrGood
op_star
l_int|2
)paren
suffix:semicolon
)brace
DECL|function|hub_hub_status
r_static
r_int
id|hub_hub_status
c_func
(paren
r_struct
id|usb_hub
op_star
id|hub
comma
id|u16
op_star
id|status
comma
id|u16
op_star
id|change
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|get_hub_status
c_func
(paren
id|hub-&gt;hdev
comma
op_amp
id|hub-&gt;status-&gt;hub
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
id|dev_err
(paren
op_amp
id|hub-&gt;intf-&gt;dev
comma
l_string|&quot;%s failed (err = %d)&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|ret
)paren
suffix:semicolon
r_else
(brace
op_star
id|status
op_assign
id|le16_to_cpu
c_func
(paren
id|hub-&gt;status-&gt;hub.wHubStatus
)paren
suffix:semicolon
op_star
id|change
op_assign
id|le16_to_cpu
c_func
(paren
id|hub-&gt;status-&gt;hub.wHubChange
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|hub_configure
r_static
r_int
id|hub_configure
c_func
(paren
r_struct
id|usb_hub
op_star
id|hub
comma
r_struct
id|usb_endpoint_descriptor
op_star
id|endpoint
)paren
(brace
r_struct
id|usb_device
op_star
id|hdev
op_assign
id|hub-&gt;hdev
suffix:semicolon
r_struct
id|device
op_star
id|hub_dev
op_assign
op_amp
id|hub-&gt;intf-&gt;dev
suffix:semicolon
id|u16
id|hubstatus
comma
id|hubchange
suffix:semicolon
r_int
r_int
id|pipe
suffix:semicolon
r_int
id|maxp
comma
id|ret
suffix:semicolon
r_char
op_star
id|message
suffix:semicolon
id|hub-&gt;buffer
op_assign
id|usb_buffer_alloc
c_func
(paren
id|hdev
comma
r_sizeof
(paren
op_star
id|hub-&gt;buffer
)paren
comma
id|GFP_KERNEL
comma
op_amp
id|hub-&gt;buffer_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hub-&gt;buffer
)paren
(brace
id|message
op_assign
l_string|&quot;can&squot;t allocate hub irq buffer&quot;
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
id|hub-&gt;status
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|hub-&gt;status
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hub-&gt;status
)paren
(brace
id|message
op_assign
l_string|&quot;can&squot;t kmalloc hub status buffer&quot;
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
id|hub-&gt;descriptor
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|hub-&gt;descriptor
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hub-&gt;descriptor
)paren
(brace
id|message
op_assign
l_string|&quot;can&squot;t kmalloc hub descriptor&quot;
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
multiline_comment|/* Request the entire hub descriptor.&n;&t; * hub-&gt;descriptor can handle USB_MAXCHILDREN ports,&n;&t; * but the hub can/will return fewer bytes here.&n;&t; */
id|ret
op_assign
id|get_hub_descriptor
c_func
(paren
id|hdev
comma
id|hub-&gt;descriptor
comma
r_sizeof
(paren
op_star
id|hub-&gt;descriptor
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|message
op_assign
l_string|&quot;can&squot;t read hub descriptor&quot;
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|hub-&gt;descriptor-&gt;bNbrPorts
OG
id|USB_MAXCHILDREN
)paren
(brace
id|message
op_assign
l_string|&quot;hub has too many ports!&quot;
suffix:semicolon
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
id|hdev-&gt;maxchild
op_assign
id|hub-&gt;descriptor-&gt;bNbrPorts
suffix:semicolon
id|dev_info
(paren
id|hub_dev
comma
l_string|&quot;%d port%s detected&bslash;n&quot;
comma
id|hdev-&gt;maxchild
comma
(paren
id|hdev-&gt;maxchild
op_eq
l_int|1
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|le16_to_cpus
c_func
(paren
op_amp
id|hub-&gt;descriptor-&gt;wHubCharacteristics
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hub-&gt;descriptor-&gt;wHubCharacteristics
op_amp
id|HUB_CHAR_COMPOUND
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
id|portstr
(braket
id|USB_MAXCHILDREN
op_plus
l_int|1
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|hdev-&gt;maxchild
suffix:semicolon
id|i
op_increment
)paren
id|portstr
(braket
id|i
)braket
op_assign
id|hub-&gt;descriptor-&gt;DeviceRemovable
(braket
(paren
(paren
id|i
op_plus
l_int|1
)paren
op_div
l_int|8
)paren
)braket
op_amp
(paren
l_int|1
op_lshift
(paren
(paren
id|i
op_plus
l_int|1
)paren
op_mod
l_int|8
)paren
)paren
ques
c_cond
l_char|&squot;F&squot;
suffix:colon
l_char|&squot;R&squot;
suffix:semicolon
id|portstr
(braket
id|hdev-&gt;maxchild
)braket
op_assign
l_int|0
suffix:semicolon
id|dev_dbg
c_func
(paren
id|hub_dev
comma
l_string|&quot;compound device; port removable status: %s&bslash;n&quot;
comma
id|portstr
)paren
suffix:semicolon
)brace
r_else
id|dev_dbg
c_func
(paren
id|hub_dev
comma
l_string|&quot;standalone hub&bslash;n&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|hub-&gt;descriptor-&gt;wHubCharacteristics
op_amp
id|HUB_CHAR_LPSM
)paren
(brace
r_case
l_int|0x00
suffix:colon
id|dev_dbg
c_func
(paren
id|hub_dev
comma
l_string|&quot;ganged power switching&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x01
suffix:colon
id|dev_dbg
c_func
(paren
id|hub_dev
comma
l_string|&quot;individual port power switching&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x02
suffix:colon
r_case
l_int|0x03
suffix:colon
id|dev_dbg
c_func
(paren
id|hub_dev
comma
l_string|&quot;no power switching (usb 1.0)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|hub-&gt;descriptor-&gt;wHubCharacteristics
op_amp
id|HUB_CHAR_OCPM
)paren
(brace
r_case
l_int|0x00
suffix:colon
id|dev_dbg
c_func
(paren
id|hub_dev
comma
l_string|&quot;global over-current protection&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x08
suffix:colon
id|dev_dbg
c_func
(paren
id|hub_dev
comma
l_string|&quot;individual port over-current protection&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x10
suffix:colon
r_case
l_int|0x18
suffix:colon
id|dev_dbg
c_func
(paren
id|hub_dev
comma
l_string|&quot;no over-current protection&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_lock_init
(paren
op_amp
id|hub-&gt;tt.lock
)paren
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|hub-&gt;tt.clear_list
)paren
suffix:semicolon
id|INIT_WORK
(paren
op_amp
id|hub-&gt;tt.kevent
comma
id|hub_tt_kevent
comma
id|hub
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|hdev-&gt;descriptor.bDeviceProtocol
)paren
(brace
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|dev_dbg
c_func
(paren
id|hub_dev
comma
l_string|&quot;Single TT&bslash;n&quot;
)paren
suffix:semicolon
id|hub-&gt;tt.hub
op_assign
id|hdev
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|ret
op_assign
id|usb_set_interface
c_func
(paren
id|hdev
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|dev_dbg
c_func
(paren
id|hub_dev
comma
l_string|&quot;TT per port&bslash;n&quot;
)paren
suffix:semicolon
id|hub-&gt;tt.multi
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|dev_err
c_func
(paren
id|hub_dev
comma
l_string|&quot;Using single TT (err %d)&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
id|hub-&gt;tt.hub
op_assign
id|hdev
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|dev_dbg
c_func
(paren
id|hub_dev
comma
l_string|&quot;Unrecognized hub protocol %d&bslash;n&quot;
comma
id|hdev-&gt;descriptor.bDeviceProtocol
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|hub-&gt;descriptor-&gt;wHubCharacteristics
op_amp
id|HUB_CHAR_TTTT
)paren
(brace
r_case
l_int|0x00
suffix:colon
r_if
c_cond
(paren
id|hdev-&gt;descriptor.bDeviceProtocol
op_ne
l_int|0
)paren
id|dev_dbg
c_func
(paren
id|hub_dev
comma
l_string|&quot;TT requires at most 8 FS bit times&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x20
suffix:colon
id|dev_dbg
c_func
(paren
id|hub_dev
comma
l_string|&quot;TT requires at most 16 FS bit times&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x40
suffix:colon
id|dev_dbg
c_func
(paren
id|hub_dev
comma
l_string|&quot;TT requires at most 24 FS bit times&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x60
suffix:colon
id|dev_dbg
c_func
(paren
id|hub_dev
comma
l_string|&quot;TT requires at most 32 FS bit times&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* probe() zeroes hub-&gt;indicator[] */
r_if
c_cond
(paren
id|hub-&gt;descriptor-&gt;wHubCharacteristics
op_amp
id|HUB_CHAR_PORTIND
)paren
(brace
id|hub-&gt;has_indicators
op_assign
l_int|1
suffix:semicolon
id|dev_dbg
c_func
(paren
id|hub_dev
comma
l_string|&quot;Port indicators are supported&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|dev_dbg
c_func
(paren
id|hub_dev
comma
l_string|&quot;power on to power good time: %dms&bslash;n&quot;
comma
id|hub-&gt;descriptor-&gt;bPwrOn2PwrGood
op_star
l_int|2
)paren
suffix:semicolon
multiline_comment|/* power budgeting mostly matters with bus-powered hubs,&n;&t; * and battery-powered root hubs (may provide just 8 mA).&n;&t; */
id|ret
op_assign
id|usb_get_status
c_func
(paren
id|hdev
comma
id|USB_RECIP_DEVICE
comma
l_int|0
comma
op_amp
id|hubstatus
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|message
op_assign
l_string|&quot;can&squot;t get hub status&quot;
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
id|cpu_to_le16s
c_func
(paren
op_amp
id|hubstatus
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hubstatus
op_amp
(paren
l_int|1
op_lshift
id|USB_DEVICE_SELF_POWERED
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|dev_dbg
c_func
(paren
id|hub_dev
comma
l_string|&quot;hub controller current requirement: %dmA&bslash;n&quot;
comma
id|hub-&gt;descriptor-&gt;bHubContrCurrent
)paren
suffix:semicolon
id|hub-&gt;power_budget
op_assign
(paren
l_int|501
op_minus
id|hub-&gt;descriptor-&gt;bHubContrCurrent
)paren
op_div
l_int|2
suffix:semicolon
id|dev_dbg
c_func
(paren
id|hub_dev
comma
l_string|&quot;%dmA bus power budget for children&bslash;n&quot;
comma
id|hub-&gt;power_budget
op_star
l_int|2
)paren
suffix:semicolon
)brace
id|ret
op_assign
id|hub_hub_status
c_func
(paren
id|hub
comma
op_amp
id|hubstatus
comma
op_amp
id|hubchange
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|message
op_assign
l_string|&quot;can&squot;t get hub status&quot;
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
multiline_comment|/* local power status reports aren&squot;t always correct */
r_if
c_cond
(paren
id|hdev-&gt;actconfig-&gt;desc.bmAttributes
op_amp
id|USB_CONFIG_ATT_SELFPOWER
)paren
id|dev_dbg
c_func
(paren
id|hub_dev
comma
l_string|&quot;local power source is %s&bslash;n&quot;
comma
(paren
id|hubstatus
op_amp
id|HUB_STATUS_LOCAL_POWER
)paren
ques
c_cond
l_string|&quot;lost (inactive)&quot;
suffix:colon
l_string|&quot;good&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hub-&gt;descriptor-&gt;wHubCharacteristics
op_amp
id|HUB_CHAR_OCPM
)paren
op_eq
l_int|0
)paren
id|dev_dbg
c_func
(paren
id|hub_dev
comma
l_string|&quot;%sover-current condition exists&bslash;n&quot;
comma
(paren
id|hubstatus
op_amp
id|HUB_STATUS_OVERCURRENT
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;no &quot;
)paren
suffix:semicolon
multiline_comment|/* Start the interrupt endpoint */
id|pipe
op_assign
id|usb_rcvintpipe
c_func
(paren
id|hdev
comma
id|endpoint-&gt;bEndpointAddress
)paren
suffix:semicolon
id|maxp
op_assign
id|usb_maxpacket
c_func
(paren
id|hdev
comma
id|pipe
comma
id|usb_pipeout
c_func
(paren
id|pipe
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|maxp
OG
r_sizeof
(paren
op_star
id|hub-&gt;buffer
)paren
)paren
id|maxp
op_assign
r_sizeof
(paren
op_star
id|hub-&gt;buffer
)paren
suffix:semicolon
id|hub-&gt;urb
op_assign
id|usb_alloc_urb
c_func
(paren
l_int|0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hub-&gt;urb
)paren
(brace
id|message
op_assign
l_string|&quot;couldn&squot;t allocate interrupt urb&quot;
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
id|usb_fill_int_urb
c_func
(paren
id|hub-&gt;urb
comma
id|hdev
comma
id|pipe
comma
op_star
id|hub-&gt;buffer
comma
id|maxp
comma
id|hub_irq
comma
id|hub
comma
id|endpoint-&gt;bInterval
)paren
suffix:semicolon
id|hub-&gt;urb-&gt;transfer_dma
op_assign
id|hub-&gt;buffer_dma
suffix:semicolon
id|hub-&gt;urb-&gt;transfer_flags
op_or_assign
id|URB_NO_TRANSFER_DMA_MAP
suffix:semicolon
id|ret
op_assign
id|usb_submit_urb
c_func
(paren
id|hub-&gt;urb
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|message
op_assign
l_string|&quot;couldn&squot;t submit status urb&quot;
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
multiline_comment|/* Wake up khubd */
id|wake_up
c_func
(paren
op_amp
id|khubd_wait
)paren
suffix:semicolon
multiline_comment|/* maybe start cycling the hub leds */
r_if
c_cond
(paren
id|hub-&gt;has_indicators
op_logical_and
id|blinkenlights
)paren
(brace
id|set_port_led
c_func
(paren
id|hdev
comma
l_int|1
comma
id|HUB_LED_GREEN
)paren
suffix:semicolon
id|hub-&gt;indicator
(braket
l_int|0
)braket
op_assign
id|INDICATOR_CYCLE
suffix:semicolon
id|schedule_delayed_work
c_func
(paren
op_amp
id|hub-&gt;leds
comma
id|LED_CYCLE_PERIOD
)paren
suffix:semicolon
)brace
id|hub_power_on
c_func
(paren
id|hub
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|fail
suffix:colon
id|dev_err
(paren
id|hub_dev
comma
l_string|&quot;config failed, %s (err %d)&bslash;n&quot;
comma
id|message
comma
id|ret
)paren
suffix:semicolon
multiline_comment|/* hub_disconnect() frees urb and descriptor */
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|highspeed_hubs
r_static
r_int
id|highspeed_hubs
suffix:semicolon
DECL|function|hub_quiesce
r_static
r_void
id|hub_quiesce
c_func
(paren
r_struct
id|usb_hub
op_star
id|hub
)paren
(brace
multiline_comment|/* stop khubd and related activity */
id|hub-&gt;quiescing
op_assign
l_int|1
suffix:semicolon
id|usb_kill_urb
c_func
(paren
id|hub-&gt;urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hub-&gt;has_indicators
)paren
id|cancel_delayed_work
c_func
(paren
op_amp
id|hub-&gt;leds
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hub-&gt;has_indicators
op_logical_or
id|hub-&gt;tt.hub
)paren
id|flush_scheduled_work
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef&t;CONFIG_USB_SUSPEND
DECL|function|hub_reactivate
r_static
r_void
id|hub_reactivate
c_func
(paren
r_struct
id|usb_hub
op_star
id|hub
)paren
(brace
r_int
id|status
suffix:semicolon
id|hub-&gt;quiescing
op_assign
l_int|0
suffix:semicolon
id|status
op_assign
id|usb_submit_urb
c_func
(paren
id|hub-&gt;urb
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
id|dev_err
c_func
(paren
op_amp
id|hub-&gt;intf-&gt;dev
comma
l_string|&quot;reactivate --&gt; %d&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hub-&gt;has_indicators
op_logical_and
id|blinkenlights
)paren
id|schedule_delayed_work
c_func
(paren
op_amp
id|hub-&gt;leds
comma
id|LED_CYCLE_PERIOD
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|hub_disconnect
r_static
r_void
id|hub_disconnect
c_func
(paren
r_struct
id|usb_interface
op_star
id|intf
)paren
(brace
r_struct
id|usb_hub
op_star
id|hub
op_assign
id|usb_get_intfdata
(paren
id|intf
)paren
suffix:semicolon
r_struct
id|usb_device
op_star
id|hdev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hub
)paren
r_return
suffix:semicolon
id|hdev
op_assign
id|hub-&gt;hdev
suffix:semicolon
r_if
c_cond
(paren
id|hdev-&gt;speed
op_eq
id|USB_SPEED_HIGH
)paren
id|highspeed_hubs
op_decrement
suffix:semicolon
id|usb_set_intfdata
(paren
id|intf
comma
l_int|NULL
)paren
suffix:semicolon
id|hub_quiesce
c_func
(paren
id|hub
)paren
suffix:semicolon
id|usb_free_urb
c_func
(paren
id|hub-&gt;urb
)paren
suffix:semicolon
id|hub-&gt;urb
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|hub_event_lock
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|hub-&gt;event_list
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|hub_event_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hub-&gt;descriptor
)paren
(brace
id|kfree
c_func
(paren
id|hub-&gt;descriptor
)paren
suffix:semicolon
id|hub-&gt;descriptor
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hub-&gt;status
)paren
(brace
id|kfree
c_func
(paren
id|hub-&gt;status
)paren
suffix:semicolon
id|hub-&gt;status
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hub-&gt;buffer
)paren
(brace
id|usb_buffer_free
c_func
(paren
id|hdev
comma
r_sizeof
(paren
op_star
id|hub-&gt;buffer
)paren
comma
id|hub-&gt;buffer
comma
id|hub-&gt;buffer_dma
)paren
suffix:semicolon
id|hub-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Free the memory */
id|kfree
c_func
(paren
id|hub
)paren
suffix:semicolon
)brace
DECL|function|hub_probe
r_static
r_int
id|hub_probe
c_func
(paren
r_struct
id|usb_interface
op_star
id|intf
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
(brace
r_struct
id|usb_host_interface
op_star
id|desc
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|endpoint
suffix:semicolon
r_struct
id|usb_device
op_star
id|hdev
suffix:semicolon
r_struct
id|usb_hub
op_star
id|hub
suffix:semicolon
r_struct
id|device
op_star
id|hub_dev
suffix:semicolon
id|desc
op_assign
id|intf-&gt;cur_altsetting
suffix:semicolon
id|hdev
op_assign
id|interface_to_usbdev
c_func
(paren
id|intf
)paren
suffix:semicolon
id|hub_dev
op_assign
op_amp
id|intf-&gt;dev
suffix:semicolon
multiline_comment|/* Some hubs have a subclass of 1, which AFAICT according to the */
multiline_comment|/*  specs is not defined, but it works */
r_if
c_cond
(paren
(paren
id|desc-&gt;desc.bInterfaceSubClass
op_ne
l_int|0
)paren
op_logical_and
(paren
id|desc-&gt;desc.bInterfaceSubClass
op_ne
l_int|1
)paren
)paren
(brace
id|descriptor_error
suffix:colon
id|dev_err
(paren
id|hub_dev
comma
l_string|&quot;bad descriptor, ignoring hub&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Multiple endpoints? What kind of mutant ninja-hub is this? */
r_if
c_cond
(paren
id|desc-&gt;desc.bNumEndpoints
op_ne
l_int|1
)paren
r_goto
id|descriptor_error
suffix:semicolon
id|endpoint
op_assign
op_amp
id|desc-&gt;endpoint
(braket
l_int|0
)braket
dot
id|desc
suffix:semicolon
multiline_comment|/* Output endpoint? Curiouser and curiouser.. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|endpoint-&gt;bEndpointAddress
op_amp
id|USB_DIR_IN
)paren
)paren
r_goto
id|descriptor_error
suffix:semicolon
multiline_comment|/* If it&squot;s not an interrupt endpoint, we&squot;d better punt! */
r_if
c_cond
(paren
(paren
id|endpoint-&gt;bmAttributes
op_amp
id|USB_ENDPOINT_XFERTYPE_MASK
)paren
op_ne
id|USB_ENDPOINT_XFER_INT
)paren
r_goto
id|descriptor_error
suffix:semicolon
multiline_comment|/* We found a hub */
id|dev_info
(paren
id|hub_dev
comma
l_string|&quot;USB hub found&bslash;n&quot;
)paren
suffix:semicolon
id|hub
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|hub
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hub
)paren
(brace
id|dev_dbg
(paren
id|hub_dev
comma
l_string|&quot;couldn&squot;t kmalloc hub struct&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|hub
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|hub
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|hub-&gt;event_list
)paren
suffix:semicolon
id|hub-&gt;intf
op_assign
id|intf
suffix:semicolon
id|hub-&gt;hdev
op_assign
id|hdev
suffix:semicolon
id|INIT_WORK
c_func
(paren
op_amp
id|hub-&gt;leds
comma
id|led_work
comma
id|hub
)paren
suffix:semicolon
id|usb_set_intfdata
(paren
id|intf
comma
id|hub
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hdev-&gt;speed
op_eq
id|USB_SPEED_HIGH
)paren
id|highspeed_hubs
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|hub_configure
c_func
(paren
id|hub
comma
id|endpoint
)paren
op_ge
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|hub_disconnect
(paren
id|intf
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_static
r_int
DECL|function|hub_ioctl
id|hub_ioctl
c_func
(paren
r_struct
id|usb_interface
op_star
id|intf
comma
r_int
r_int
id|code
comma
r_void
op_star
id|user_data
)paren
(brace
r_struct
id|usb_device
op_star
id|hdev
op_assign
id|interface_to_usbdev
(paren
id|intf
)paren
suffix:semicolon
multiline_comment|/* assert ifno == 0 (part of hub spec) */
r_switch
c_cond
(paren
id|code
)paren
(brace
r_case
id|USBDEVFS_HUB_PORTINFO
suffix:colon
(brace
r_struct
id|usbdevfs_hub_portinfo
op_star
id|info
op_assign
id|user_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hub_event_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hdev-&gt;devnum
op_le
l_int|0
)paren
id|info-&gt;nports
op_assign
l_int|0
suffix:semicolon
r_else
(brace
id|info-&gt;nports
op_assign
id|hdev-&gt;maxchild
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|info-&gt;nports
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|hdev-&gt;children
(braket
id|i
)braket
op_eq
l_int|NULL
)paren
id|info-&gt;port
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_else
id|info-&gt;port
(braket
id|i
)braket
op_assign
id|hdev-&gt;children
(braket
id|i
)braket
op_member_access_from_pointer
id|devnum
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hub_event_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|info-&gt;nports
op_plus
l_int|1
suffix:semicolon
)brace
r_default
suffix:colon
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
)brace
multiline_comment|/* caller has locked the hub */
DECL|function|hub_reset
r_static
r_int
id|hub_reset
c_func
(paren
r_struct
id|usb_hub
op_star
id|hub
)paren
(brace
r_struct
id|usb_device
op_star
id|hdev
op_assign
id|hub-&gt;hdev
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Disconnect any attached devices */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|hub-&gt;descriptor-&gt;bNbrPorts
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|hdev-&gt;children
(braket
id|i
)braket
)paren
id|usb_disconnect
c_func
(paren
op_amp
id|hdev-&gt;children
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Attempt to reset the hub */
r_if
c_cond
(paren
id|hub-&gt;urb
)paren
id|usb_kill_urb
c_func
(paren
id|hub-&gt;urb
)paren
suffix:semicolon
r_else
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|usb_reset_device
c_func
(paren
id|hdev
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|hub-&gt;urb-&gt;dev
op_assign
id|hdev
suffix:semicolon
r_if
c_cond
(paren
id|usb_submit_urb
c_func
(paren
id|hub-&gt;urb
comma
id|GFP_KERNEL
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|hub_power_on
c_func
(paren
id|hub
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* caller has locked the hub */
multiline_comment|/* FIXME!  This routine should be subsumed into hub_reset */
DECL|function|hub_start_disconnect
r_static
r_void
id|hub_start_disconnect
c_func
(paren
r_struct
id|usb_device
op_star
id|hdev
)paren
(brace
r_struct
id|usb_device
op_star
id|parent
op_assign
id|hdev-&gt;parent
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Find the device pointer to disconnect */
r_if
c_cond
(paren
id|parent
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|parent-&gt;maxchild
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|parent-&gt;children
(braket
id|i
)braket
op_eq
id|hdev
)paren
(brace
id|usb_disconnect
c_func
(paren
op_amp
id|parent-&gt;children
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
id|dev_err
c_func
(paren
op_amp
id|hdev-&gt;dev
comma
l_string|&quot;cannot disconnect hub!&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|recursively_mark_NOTATTACHED
r_static
r_void
id|recursively_mark_NOTATTACHED
c_func
(paren
r_struct
id|usb_device
op_star
id|udev
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|udev-&gt;maxchild
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|udev-&gt;children
(braket
id|i
)braket
)paren
id|recursively_mark_NOTATTACHED
c_func
(paren
id|udev-&gt;children
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|udev-&gt;state
op_assign
id|USB_STATE_NOTATTACHED
suffix:semicolon
)brace
multiline_comment|/* grab device/port lock, returning index of that port (zero based).&n; * protects the upstream link used by this device from concurrent&n; * tree operations like suspend, resume, reset, and disconnect, which&n; * apply to everything downstream of a given port.&n; */
DECL|function|locktree
r_static
r_int
id|locktree
c_func
(paren
r_struct
id|usb_device
op_star
id|udev
)paren
(brace
r_int
id|t
suffix:semicolon
r_struct
id|usb_device
op_star
id|hdev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|udev
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* root hub is always the first lock in the series */
id|hdev
op_assign
id|udev-&gt;parent
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hdev
)paren
(brace
id|down
c_func
(paren
op_amp
id|udev-&gt;serialize
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* on the path from root to us, lock everything from&n;&t; * top down, dropping parent locks when not needed&n;&t; *&n;&t; * NOTE: if disconnect were to ignore the locking, we&squot;d need&n;&t; * to get extra refcounts to everything since hdev-&gt;children&n;&t; * and udev-&gt;parent could be invalidated while we work...&n;&t; */
id|t
op_assign
id|locktree
c_func
(paren
id|hdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
OL
l_int|0
)paren
r_return
id|t
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|device_state_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|t
op_assign
l_int|0
suffix:semicolon
id|t
OL
id|hdev-&gt;maxchild
suffix:semicolon
id|t
op_increment
)paren
(brace
r_if
c_cond
(paren
id|hdev-&gt;children
(braket
id|t
)braket
op_eq
id|udev
)paren
(brace
multiline_comment|/* everything is fail-fast once disconnect&n;&t;&t;&t; * processing starts&n;&t;&t;&t; */
r_if
c_cond
(paren
id|udev-&gt;state
op_eq
id|USB_STATE_NOTATTACHED
)paren
r_break
suffix:semicolon
multiline_comment|/* when everyone grabs locks top-&gt;bottom,&n;&t;&t;&t; * non-overlapping work may be concurrent&n;&t;&t;&t; */
id|spin_unlock_irq
c_func
(paren
op_amp
id|device_state_lock
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|udev-&gt;serialize
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|hdev-&gt;serialize
)paren
suffix:semicolon
r_return
id|t
suffix:semicolon
)brace
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|device_state_lock
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|hdev-&gt;serialize
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_set_device_state - change a device&squot;s current state (usbcore-internal)&n; * @udev: pointer to device whose state should be changed&n; * @new_state: new state value to be stored&n; *&n; * udev-&gt;state is _not_ protected by the device lock.  This&n; * is so that devices can be marked as disconnected as soon as possible,&n; * without having to wait for the semaphore to be released.  Instead,&n; * changes to the state must be protected by the device_state_lock spinlock.&n; *&n; * Once a device has been added to the device tree, all changes to its state&n; * should be made using this routine.  The state should _not_ be set directly.&n; *&n; * If udev-&gt;state is already USB_STATE_NOTATTACHED then no change is made.&n; * Otherwise udev-&gt;state is set to new_state, and if new_state is&n; * USB_STATE_NOTATTACHED then all of udev&squot;s descendant&squot;s states are also set&n; * to USB_STATE_NOTATTACHED.&n; */
DECL|function|usb_set_device_state
r_void
id|usb_set_device_state
c_func
(paren
r_struct
id|usb_device
op_star
id|udev
comma
r_enum
id|usb_device_state
id|new_state
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|device_state_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|udev-&gt;state
op_eq
id|USB_STATE_NOTATTACHED
)paren
suffix:semicolon
multiline_comment|/* do nothing */
r_else
r_if
c_cond
(paren
id|new_state
op_ne
id|USB_STATE_NOTATTACHED
)paren
id|udev-&gt;state
op_assign
id|new_state
suffix:semicolon
r_else
id|recursively_mark_NOTATTACHED
c_func
(paren
id|udev
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|device_state_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|choose_address
r_static
r_void
id|choose_address
c_func
(paren
r_struct
id|usb_device
op_star
id|udev
)paren
(brace
r_int
id|devnum
suffix:semicolon
r_struct
id|usb_bus
op_star
id|bus
op_assign
id|udev-&gt;bus
suffix:semicolon
multiline_comment|/* If khubd ever becomes multithreaded, this will need a lock */
multiline_comment|/* Try to allocate the next devnum beginning at bus-&gt;devnum_next. */
id|devnum
op_assign
id|find_next_zero_bit
c_func
(paren
id|bus-&gt;devmap.devicemap
comma
l_int|128
comma
id|bus-&gt;devnum_next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devnum
op_ge
l_int|128
)paren
id|devnum
op_assign
id|find_next_zero_bit
c_func
(paren
id|bus-&gt;devmap.devicemap
comma
l_int|128
comma
l_int|1
)paren
suffix:semicolon
id|bus-&gt;devnum_next
op_assign
(paren
id|devnum
op_ge
l_int|127
ques
c_cond
l_int|1
suffix:colon
id|devnum
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devnum
OL
l_int|128
)paren
(brace
id|set_bit
c_func
(paren
id|devnum
comma
id|bus-&gt;devmap.devicemap
)paren
suffix:semicolon
id|udev-&gt;devnum
op_assign
id|devnum
suffix:semicolon
)brace
)brace
DECL|function|release_address
r_static
r_void
id|release_address
c_func
(paren
r_struct
id|usb_device
op_star
id|udev
)paren
(brace
r_if
c_cond
(paren
id|udev-&gt;devnum
OG
l_int|0
)paren
(brace
id|clear_bit
c_func
(paren
id|udev-&gt;devnum
comma
id|udev-&gt;bus-&gt;devmap.devicemap
)paren
suffix:semicolon
id|udev-&gt;devnum
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * usb_disconnect - disconnect a device (usbcore-internal)&n; * @pdev: pointer to device being disconnected, into a locked hub&n; * Context: !in_interrupt ()&n; *&n; * Something got disconnected. Get rid of it, and all of its children.&n; * If *pdev is a normal device then the parent hub should be locked.&n; * If *pdev is a root hub then this routine will acquire the&n; * usb_bus_list_lock on behalf of the caller.&n; *&n; * Only hub drivers (including virtual root hub drivers for host&n; * controllers) should ever call this.&n; *&n; * This call is synchronous, and may not be used in an interrupt context.&n; */
DECL|function|usb_disconnect
r_void
id|usb_disconnect
c_func
(paren
r_struct
id|usb_device
op_star
op_star
id|pdev
)paren
(brace
r_struct
id|usb_device
op_star
id|udev
op_assign
op_star
id|pdev
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|udev
)paren
(brace
id|pr_debug
(paren
l_string|&quot;%s nodev&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* mark the device as inactive, so any further urb submissions for&n;&t; * this device (and any of its children) will fail immediately.&n;&t; * this quiesces everyting except pending urbs.&n;&t; */
id|usb_set_device_state
c_func
(paren
id|udev
comma
id|USB_STATE_NOTATTACHED
)paren
suffix:semicolon
multiline_comment|/* lock the bus list on behalf of HCDs unregistering their root hubs */
r_if
c_cond
(paren
op_logical_neg
id|udev-&gt;parent
)paren
id|down
c_func
(paren
op_amp
id|usb_bus_list_lock
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|udev-&gt;serialize
)paren
suffix:semicolon
id|dev_info
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;USB disconnect, address %d&bslash;n&quot;
comma
id|udev-&gt;devnum
)paren
suffix:semicolon
multiline_comment|/* Free up all the children before we remove this device */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|USB_MAXCHILDREN
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|udev-&gt;children
(braket
id|i
)braket
)paren
id|usb_disconnect
c_func
(paren
op_amp
id|udev-&gt;children
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* deallocate hcd/hardware state ... nuking all pending urbs and&n;&t; * cleaning up all state associated with the current configuration&n;&t; * so that the hardware is now fully quiesced.&n;&t; */
id|usb_disable_device
c_func
(paren
id|udev
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Free the device number, remove the /proc/bus/usb entry and&n;&t; * the sysfs attributes, and delete the parent&squot;s children[]&n;&t; * (or root_hub) pointer.&n;&t; */
id|dev_dbg
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;unregistering device&bslash;n&quot;
)paren
suffix:semicolon
id|release_address
c_func
(paren
id|udev
)paren
suffix:semicolon
id|usbfs_remove_device
c_func
(paren
id|udev
)paren
suffix:semicolon
id|usb_remove_sysfs_dev_files
c_func
(paren
id|udev
)paren
suffix:semicolon
multiline_comment|/* Avoid races with recursively_mark_NOTATTACHED() and locktree() */
id|spin_lock_irq
c_func
(paren
op_amp
id|device_state_lock
)paren
suffix:semicolon
op_star
id|pdev
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|device_state_lock
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|udev-&gt;serialize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|udev-&gt;parent
)paren
id|up
c_func
(paren
op_amp
id|usb_bus_list_lock
)paren
suffix:semicolon
id|device_unregister
c_func
(paren
op_amp
id|udev-&gt;dev
)paren
suffix:semicolon
)brace
DECL|function|choose_configuration
r_static
r_int
id|choose_configuration
c_func
(paren
r_struct
id|usb_device
op_star
id|udev
)paren
(brace
r_int
id|c
comma
id|i
suffix:semicolon
multiline_comment|/* NOTE: this should interact with hub power budgeting */
id|c
op_assign
id|udev-&gt;config
(braket
l_int|0
)braket
dot
id|desc.bConfigurationValue
suffix:semicolon
r_if
c_cond
(paren
id|udev-&gt;descriptor.bNumConfigurations
op_ne
l_int|1
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|udev-&gt;descriptor.bNumConfigurations
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|usb_interface_descriptor
op_star
id|desc
suffix:semicolon
multiline_comment|/* heuristic:  Linux is more likely to have class&n;&t;&t;&t; * drivers, so avoid vendor-specific interfaces.&n;&t;&t;&t; */
id|desc
op_assign
op_amp
id|udev-&gt;config
(braket
id|i
)braket
dot
id|intf_cache
(braket
l_int|0
)braket
op_member_access_from_pointer
id|altsetting-&gt;desc
suffix:semicolon
r_if
c_cond
(paren
id|desc-&gt;bInterfaceClass
op_eq
id|USB_CLASS_VENDOR_SPEC
)paren
r_continue
suffix:semicolon
multiline_comment|/* COMM/2/all is CDC ACM, except 0xff is MSFT RNDIS */
r_if
c_cond
(paren
id|desc-&gt;bInterfaceClass
op_eq
id|USB_CLASS_COMM
op_logical_and
id|desc-&gt;bInterfaceSubClass
op_eq
l_int|2
op_logical_and
id|desc-&gt;bInterfaceProtocol
op_eq
l_int|0xff
)paren
r_continue
suffix:semicolon
id|c
op_assign
id|udev-&gt;config
(braket
id|i
)braket
dot
id|desc.bConfigurationValue
suffix:semicolon
r_break
suffix:semicolon
)brace
id|dev_info
c_func
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;configuration #%d chosen from %d choices&bslash;n&quot;
comma
id|c
comma
id|udev-&gt;descriptor.bNumConfigurations
)paren
suffix:semicolon
)brace
r_return
id|c
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
DECL|function|show_string
r_static
r_void
id|show_string
c_func
(paren
r_struct
id|usb_device
op_star
id|udev
comma
r_char
op_star
id|id
comma
r_int
id|index
)paren
(brace
r_char
op_star
id|buf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|index
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|buf
op_assign
id|kmalloc
c_func
(paren
l_int|256
comma
id|GFP_KERNEL
)paren
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|usb_string
c_func
(paren
id|udev
comma
id|index
comma
id|buf
comma
l_int|256
)paren
OG
l_int|0
)paren
id|dev_printk
c_func
(paren
id|KERN_INFO
comma
op_amp
id|udev-&gt;dev
comma
l_string|&quot;%s: %s&bslash;n&quot;
comma
id|id
comma
id|buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|function|show_string
r_static
r_inline
r_void
id|show_string
c_func
(paren
r_struct
id|usb_device
op_star
id|udev
comma
r_char
op_star
id|id
comma
r_int
id|index
)paren
(brace
)brace
macro_line|#endif
multiline_comment|/**&n; * usb_new_device - perform initial device setup (usbcore-internal)&n; * @udev: newly addressed device (in ADDRESS state)&n; *&n; * This is called with devices which have been enumerated, but not yet&n; * configured.  The device descriptor is available, but not descriptors&n; * for any device configuration.  The caller must have locked udev and&n; * either the parent hub (if udev is a normal device) or else the&n; * usb_bus_list_lock (if udev is a root hub).  The parent&squot;s pointer to&n; * udev has already been installed, but udev is not yet visible through&n; * sysfs or other filesystem code.&n; *&n; * Returns 0 for success (device is configured and listed, with its&n; * interfaces, in sysfs); else a negative errno value.&n; *&n; * This call is synchronous, and may not be used in an interrupt context.&n; *&n; * Only the hub driver should ever call this; root hub registration&n; * uses it indirectly.&n; */
DECL|function|usb_new_device
r_int
id|usb_new_device
c_func
(paren
r_struct
id|usb_device
op_star
id|udev
)paren
(brace
r_int
id|err
suffix:semicolon
r_int
id|c
suffix:semicolon
id|err
op_assign
id|usb_get_configuration
c_func
(paren
id|udev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|dev_err
c_func
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;can&squot;t read configurations, error %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
multiline_comment|/* Tell the world! */
id|dev_dbg
c_func
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;new device strings: Mfr=%d, Product=%d, &quot;
l_string|&quot;SerialNumber=%d&bslash;n&quot;
comma
id|udev-&gt;descriptor.iManufacturer
comma
id|udev-&gt;descriptor.iProduct
comma
id|udev-&gt;descriptor.iSerialNumber
)paren
suffix:semicolon
r_if
c_cond
(paren
id|udev-&gt;descriptor.iProduct
)paren
id|show_string
c_func
(paren
id|udev
comma
l_string|&quot;Product&quot;
comma
id|udev-&gt;descriptor.iProduct
)paren
suffix:semicolon
r_if
c_cond
(paren
id|udev-&gt;descriptor.iManufacturer
)paren
id|show_string
c_func
(paren
id|udev
comma
l_string|&quot;Manufacturer&quot;
comma
id|udev-&gt;descriptor.iManufacturer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|udev-&gt;descriptor.iSerialNumber
)paren
id|show_string
c_func
(paren
id|udev
comma
l_string|&quot;SerialNumber&quot;
comma
id|udev-&gt;descriptor.iSerialNumber
)paren
suffix:semicolon
multiline_comment|/* put device-specific files into sysfs */
id|err
op_assign
id|device_add
(paren
op_amp
id|udev-&gt;dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|dev_err
c_func
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;can&squot;t device_add, error %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
id|usb_create_sysfs_dev_files
(paren
id|udev
)paren
suffix:semicolon
multiline_comment|/* choose and set the configuration. that registers the interfaces&n;&t; * with the driver core, and lets usb device drivers bind to them.&n;&t; */
id|c
op_assign
id|choose_configuration
c_func
(paren
id|udev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
OL
l_int|0
)paren
id|dev_warn
c_func
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;can&squot;t choose an initial configuration&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
id|err
op_assign
id|usb_set_configuration
c_func
(paren
id|udev
comma
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|dev_err
c_func
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;can&squot;t set config #%d, error %d&bslash;n&quot;
comma
id|c
comma
id|err
)paren
suffix:semicolon
id|usb_remove_sysfs_dev_files
c_func
(paren
id|udev
)paren
suffix:semicolon
id|device_del
c_func
(paren
op_amp
id|udev-&gt;dev
)paren
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
)brace
multiline_comment|/* USB device state == configured ... usable */
multiline_comment|/* add a /proc/bus/usb entry */
id|usbfs_add_device
c_func
(paren
id|udev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|fail
suffix:colon
id|usb_set_device_state
c_func
(paren
id|udev
comma
id|USB_STATE_NOTATTACHED
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|hub_port_status
r_static
r_int
id|hub_port_status
c_func
(paren
r_struct
id|usb_device
op_star
id|hdev
comma
r_int
id|port
comma
id|u16
op_star
id|status
comma
id|u16
op_star
id|change
)paren
(brace
r_struct
id|usb_hub
op_star
id|hub
op_assign
id|usb_get_intfdata
c_func
(paren
id|hdev-&gt;actconfig-&gt;interface
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hub
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|ret
op_assign
id|get_port_status
c_func
(paren
id|hdev
comma
id|port
op_plus
l_int|1
comma
op_amp
id|hub-&gt;status-&gt;port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
id|dev_err
(paren
op_amp
id|hub-&gt;intf-&gt;dev
comma
l_string|&quot;%s failed (err = %d)&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|ret
)paren
suffix:semicolon
r_else
(brace
op_star
id|status
op_assign
id|le16_to_cpu
c_func
(paren
id|hub-&gt;status-&gt;port.wPortStatus
)paren
suffix:semicolon
op_star
id|change
op_assign
id|le16_to_cpu
c_func
(paren
id|hub-&gt;status-&gt;port.wPortChange
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|macro|PORT_RESET_TRIES
mdefine_line|#define PORT_RESET_TRIES&t;5
DECL|macro|SET_ADDRESS_TRIES
mdefine_line|#define SET_ADDRESS_TRIES&t;2
DECL|macro|GET_DESCRIPTOR_TRIES
mdefine_line|#define GET_DESCRIPTOR_TRIES&t;2
DECL|macro|SET_CONFIG_TRIES
mdefine_line|#define SET_CONFIG_TRIES&t;2
DECL|macro|HUB_ROOT_RESET_TIME
mdefine_line|#define HUB_ROOT_RESET_TIME&t;50&t;/* times are in msec */
DECL|macro|HUB_SHORT_RESET_TIME
mdefine_line|#define HUB_SHORT_RESET_TIME&t;10
DECL|macro|HUB_LONG_RESET_TIME
mdefine_line|#define HUB_LONG_RESET_TIME&t;200
DECL|macro|HUB_RESET_TIMEOUT
mdefine_line|#define HUB_RESET_TIMEOUT&t;500
DECL|function|hub_port_wait_reset
r_static
r_int
id|hub_port_wait_reset
c_func
(paren
r_struct
id|usb_device
op_star
id|hdev
comma
r_int
id|port
comma
r_struct
id|usb_device
op_star
id|udev
comma
r_int
r_int
id|delay
)paren
(brace
r_int
id|delay_time
comma
id|ret
suffix:semicolon
id|u16
id|portstatus
suffix:semicolon
id|u16
id|portchange
suffix:semicolon
r_for
c_loop
(paren
id|delay_time
op_assign
l_int|0
suffix:semicolon
id|delay_time
OL
id|HUB_RESET_TIMEOUT
suffix:semicolon
id|delay_time
op_add_assign
id|delay
)paren
(brace
multiline_comment|/* wait to give the device a chance to reset */
id|msleep
c_func
(paren
id|delay
)paren
suffix:semicolon
multiline_comment|/* read and decode port status */
id|ret
op_assign
id|hub_port_status
c_func
(paren
id|hdev
comma
id|port
comma
op_amp
id|portstatus
comma
op_amp
id|portchange
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/* Device went away? */
r_if
c_cond
(paren
op_logical_neg
(paren
id|portstatus
op_amp
id|USB_PORT_STAT_CONNECTION
)paren
)paren
r_return
op_minus
id|ENOTCONN
suffix:semicolon
multiline_comment|/* bomb out completely if something weird happened */
r_if
c_cond
(paren
(paren
id|portchange
op_amp
id|USB_PORT_STAT_C_CONNECTION
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* if we`ve finished resetting, then break out of the loop */
r_if
c_cond
(paren
op_logical_neg
(paren
id|portstatus
op_amp
id|USB_PORT_STAT_RESET
)paren
op_logical_and
(paren
id|portstatus
op_amp
id|USB_PORT_STAT_ENABLE
)paren
)paren
(brace
r_if
c_cond
(paren
id|portstatus
op_amp
id|USB_PORT_STAT_HIGH_SPEED
)paren
id|udev-&gt;speed
op_assign
id|USB_SPEED_HIGH
suffix:semicolon
r_else
r_if
c_cond
(paren
id|portstatus
op_amp
id|USB_PORT_STAT_LOW_SPEED
)paren
id|udev-&gt;speed
op_assign
id|USB_SPEED_LOW
suffix:semicolon
r_else
id|udev-&gt;speed
op_assign
id|USB_SPEED_FULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* switch to the long delay after two short delay failures */
r_if
c_cond
(paren
id|delay_time
op_ge
l_int|2
op_star
id|HUB_SHORT_RESET_TIME
)paren
id|delay
op_assign
id|HUB_LONG_RESET_TIME
suffix:semicolon
id|dev_dbg
(paren
id|hubdev
(paren
id|hdev
)paren
comma
l_string|&quot;port %d not reset yet, waiting %dms&bslash;n&quot;
comma
id|port
op_plus
l_int|1
comma
id|delay
)paren
suffix:semicolon
)brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
DECL|function|hub_port_reset
r_static
r_int
id|hub_port_reset
c_func
(paren
r_struct
id|usb_device
op_star
id|hdev
comma
r_int
id|port
comma
r_struct
id|usb_device
op_star
id|udev
comma
r_int
r_int
id|delay
)paren
(brace
r_int
id|i
comma
id|status
suffix:semicolon
r_struct
id|device
op_star
id|hub_dev
op_assign
id|hubdev
(paren
id|hdev
)paren
suffix:semicolon
multiline_comment|/* Reset the port */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PORT_RESET_TRIES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|status
op_assign
id|set_port_feature
c_func
(paren
id|hdev
comma
id|port
op_plus
l_int|1
comma
id|USB_PORT_FEAT_RESET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
id|dev_err
c_func
(paren
id|hub_dev
comma
l_string|&quot;cannot reset port %d (err = %d)&bslash;n&quot;
comma
id|port
op_plus
l_int|1
comma
id|status
)paren
suffix:semicolon
r_else
id|status
op_assign
id|hub_port_wait_reset
c_func
(paren
id|hdev
comma
id|port
comma
id|udev
comma
id|delay
)paren
suffix:semicolon
multiline_comment|/* return on disconnect or reset */
r_if
c_cond
(paren
id|status
op_eq
op_minus
id|ENOTCONN
op_logical_or
id|status
op_eq
l_int|0
)paren
(brace
id|clear_port_feature
c_func
(paren
id|hdev
comma
id|port
op_plus
l_int|1
comma
id|USB_PORT_FEAT_C_RESET
)paren
suffix:semicolon
multiline_comment|/* FIXME need disconnect() for NOTATTACHED device */
id|usb_set_device_state
c_func
(paren
id|udev
comma
id|status
ques
c_cond
id|USB_STATE_NOTATTACHED
suffix:colon
id|USB_STATE_DEFAULT
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
id|dev_dbg
(paren
id|hub_dev
comma
l_string|&quot;port %d not enabled, trying reset again...&bslash;n&quot;
comma
id|port
op_plus
l_int|1
)paren
suffix:semicolon
id|delay
op_assign
id|HUB_LONG_RESET_TIME
suffix:semicolon
)brace
id|dev_err
(paren
id|hub_dev
comma
l_string|&quot;Cannot enable port %i.  Maybe the USB cable is bad?&bslash;n&quot;
comma
id|port
op_plus
l_int|1
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
DECL|function|hub_port_disable
r_static
r_int
id|hub_port_disable
c_func
(paren
r_struct
id|usb_device
op_star
id|hdev
comma
r_int
id|port
)paren
(brace
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|hdev-&gt;children
(braket
id|port
)braket
)paren
(brace
multiline_comment|/* FIXME need disconnect() for NOTATTACHED device */
id|usb_set_device_state
c_func
(paren
id|hdev-&gt;children
(braket
id|port
)braket
comma
id|USB_STATE_NOTATTACHED
)paren
suffix:semicolon
)brace
id|ret
op_assign
id|clear_port_feature
c_func
(paren
id|hdev
comma
id|port
op_plus
l_int|1
comma
id|USB_PORT_FEAT_ENABLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
id|dev_err
c_func
(paren
id|hubdev
c_func
(paren
id|hdev
)paren
comma
l_string|&quot;cannot disable port %d (err = %d)&bslash;n&quot;
comma
id|port
op_plus
l_int|1
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#ifdef&t;CONFIG_USB_SUSPEND
multiline_comment|/*&n; * Selective port suspend reduces power; most suspended devices draw&n; * less than 500 uA.  It&squot;s also used in OTG, along with remote wakeup.&n; * All devices below the suspended port are also suspended.&n; *&n; * Devices leave suspend state when the host wakes them up.  Some devices&n; * also support &quot;remote wakeup&quot;, where the device can activate the USB&n; * tree above them to deliver data, such as a keypress or packet.  In&n; * some cases, this wakes the USB host.&n; */
DECL|function|hub_port_suspend
r_static
r_int
id|hub_port_suspend
c_func
(paren
r_struct
id|usb_device
op_star
id|hdev
comma
r_int
id|port
)paren
(brace
r_int
id|status
suffix:semicolon
r_struct
id|usb_device
op_star
id|udev
suffix:semicolon
id|udev
op_assign
id|hdev-&gt;children
(braket
id|port
op_minus
l_int|1
)braket
suffix:semicolon
singleline_comment|// dev_dbg(hubdev(hdev), &quot;suspend port %d&bslash;n&quot;, port);
multiline_comment|/* enable remote wakeup when appropriate; this lets the device&n;&t; * wake up the upstream hub (including maybe the root hub).&n;&t; *&n;&t; * NOTE:  OTG devices may issue remote wakeup (or SRP) even when&n;&t; * we don&squot;t explicitly enable it here.&n;&t; */
r_if
c_cond
(paren
id|udev-&gt;actconfig
singleline_comment|// &amp;&amp; FIXME (remote wakeup enabled on this bus)
singleline_comment|// ... currently assuming it&squot;s always appropriate
op_logical_and
(paren
id|udev-&gt;actconfig-&gt;desc.bmAttributes
op_amp
id|USB_CONFIG_ATT_WAKEUP
)paren
op_ne
l_int|0
)paren
(brace
id|status
op_assign
id|usb_control_msg
c_func
(paren
id|udev
comma
id|usb_sndctrlpipe
c_func
(paren
id|udev
comma
l_int|0
)paren
comma
id|USB_REQ_SET_FEATURE
comma
id|USB_RECIP_DEVICE
comma
id|USB_DEVICE_REMOTE_WAKEUP
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|USB_CTRL_SET_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
id|dev_dbg
c_func
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;won&squot;t remote wakeup, status %d&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/* see 7.1.7.6 */
id|status
op_assign
id|set_port_feature
c_func
(paren
id|hdev
comma
id|port
comma
id|USB_PORT_FEAT_SUSPEND
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
id|dev_dbg
c_func
(paren
id|hubdev
c_func
(paren
id|hdev
)paren
comma
l_string|&quot;can&squot;t suspend port %d, status %d&bslash;n&quot;
comma
id|port
comma
id|status
)paren
suffix:semicolon
multiline_comment|/* paranoia:  &quot;should not happen&quot; */
(paren
r_void
)paren
id|usb_control_msg
c_func
(paren
id|udev
comma
id|usb_sndctrlpipe
c_func
(paren
id|udev
comma
l_int|0
)paren
comma
id|USB_REQ_CLEAR_FEATURE
comma
id|USB_RECIP_DEVICE
comma
id|USB_DEVICE_REMOTE_WAKEUP
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|USB_CTRL_SET_TIMEOUT
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* device has up to 10 msec to fully suspend */
id|dev_dbg
c_func
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;usb suspend&bslash;n&quot;
)paren
suffix:semicolon
id|udev-&gt;state
op_assign
id|USB_STATE_SUSPENDED
suffix:semicolon
id|msleep
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n; * Devices on USB hub ports have only one &quot;suspend&quot; state, corresponding&n; * to ACPI D2 (PM_SUSPEND_MEM), &quot;may cause the device to lose some context&quot;.&n; * State transitions include:&n; *&n; *   - suspend, resume ... when the VBUS power link stays live&n; *   - suspend, disconnect ... VBUS lost&n; *&n; * Once VBUS drop breaks the circuit, the port it&squot;s using has to go through&n; * normal re-enumeration procedures, starting with enabling VBUS power.&n; * Other than re-initializing the hub (plug/unplug, except for root hubs),&n; * Linux (2.6) currently has NO mechanisms to initiate that:  no khubd&n; * timer, no SRP, no requests through sysfs.&n; */
DECL|function|__usb_suspend_device
r_static
r_int
id|__usb_suspend_device
(paren
r_struct
id|usb_device
op_star
id|udev
comma
r_int
id|port
comma
id|u32
id|state
)paren
(brace
r_int
id|status
suffix:semicolon
r_if
c_cond
(paren
id|port
OL
l_int|0
)paren
r_return
id|port
suffix:semicolon
multiline_comment|/* NOTE:  udev-&gt;serialize released on all real returns! */
r_if
c_cond
(paren
id|state
op_le
id|udev-&gt;dev.power.power_state
op_logical_or
id|state
OL
id|PM_SUSPEND_MEM
op_logical_or
id|udev-&gt;state
op_eq
id|USB_STATE_SUSPENDED
op_logical_or
id|udev-&gt;state
op_eq
id|USB_STATE_NOTATTACHED
)paren
(brace
id|up
c_func
(paren
op_amp
id|udev-&gt;serialize
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* suspend interface drivers; if this is a hub, it&n;&t; * suspends the child devices&n;&t; */
r_if
c_cond
(paren
id|udev-&gt;actconfig
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|udev-&gt;actconfig-&gt;desc.bNumInterfaces
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|usb_interface
op_star
id|intf
suffix:semicolon
r_struct
id|usb_driver
op_star
id|driver
suffix:semicolon
id|intf
op_assign
id|udev-&gt;actconfig-&gt;interface
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|state
op_le
id|intf-&gt;dev.power.power_state
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|intf-&gt;dev.driver
)paren
r_continue
suffix:semicolon
id|driver
op_assign
id|to_usb_driver
c_func
(paren
id|intf-&gt;dev.driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver-&gt;suspend
)paren
(brace
id|status
op_assign
id|driver
op_member_access_from_pointer
id|suspend
c_func
(paren
id|intf
comma
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intf-&gt;dev.power.power_state
op_ne
id|state
op_logical_or
id|status
)paren
id|dev_err
c_func
(paren
op_amp
id|intf-&gt;dev
comma
l_string|&quot;suspend %d fail, code %d&bslash;n&quot;
comma
id|state
comma
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/* only drivers with suspend() can ever resume();&n;&t;&t;&t; * and after power loss, even they won&squot;t.&n;&t;&t;&t; * bus_rescan_devices() can rebind drivers later.&n;&t;&t;&t; *&n;&t;&t;&t; * FIXME the PM core self-deadlocks when unbinding&n;&t;&t;&t; * drivers during suspend/resume ... everything grabs&n;&t;&t;&t; * dpm_sem (not a spinlock, ugh).  we want to unbind,&n;&t;&t;&t; * since we know every driver&squot;s probe/disconnect works&n;&t;&t;&t; * even for drivers that can&squot;t suspend.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|driver-&gt;suspend
op_logical_or
id|state
OG
id|PM_SUSPEND_MEM
)paren
(brace
macro_line|#if 1
id|dev_warn
c_func
(paren
op_amp
id|intf-&gt;dev
comma
l_string|&quot;resume is unsafe!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#else
id|down_write
c_func
(paren
op_amp
id|usb_bus_type.rwsem
)paren
suffix:semicolon
id|device_release_driver
c_func
(paren
op_amp
id|intf-&gt;dev
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|usb_bus_type.rwsem
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
)brace
multiline_comment|/*&n;&t; * FIXME this needs port power off call paths too, to help force&n;&t; * USB into the &quot;generic&quot; PM model.  At least for devices on&n;&t; * ports that aren&squot;t using ganged switching (usually root hubs).&n;&t; *&n;&t; * NOTE: SRP-capable links should adopt more aggressive poweroff&n;&t; * policies (when HNP doesn&squot;t apply) once we have mechanisms to&n;&t; * turn power back on!  (Likely not before 2.7...)&n;&t; */
r_if
c_cond
(paren
id|state
OG
id|PM_SUSPEND_MEM
)paren
(brace
id|dev_warn
c_func
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;no poweroff yet, suspending instead&bslash;n&quot;
)paren
suffix:semicolon
id|state
op_assign
id|PM_SUSPEND_MEM
suffix:semicolon
)brace
multiline_comment|/* &quot;global suspend&quot; of the HC-to-USB interface (root hub), or&n;&t; * &quot;selective suspend&quot; of just one hub-device link.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|udev-&gt;parent
)paren
(brace
r_struct
id|usb_bus
op_star
id|bus
op_assign
id|udev-&gt;bus
suffix:semicolon
r_if
c_cond
(paren
id|bus
op_logical_and
id|bus-&gt;op-&gt;hub_suspend
)paren
id|status
op_assign
id|bus-&gt;op-&gt;hub_suspend
(paren
id|bus
)paren
suffix:semicolon
r_else
id|status
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
r_else
id|status
op_assign
id|hub_port_suspend
c_func
(paren
id|udev-&gt;parent
comma
id|port
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
l_int|0
)paren
id|udev-&gt;dev.power.power_state
op_assign
id|state
suffix:semicolon
id|up
c_func
(paren
op_amp
id|udev-&gt;serialize
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_suspend_device - suspend a usb device&n; * @udev: device that&squot;s no longer in active use&n; * @state: PM_SUSPEND_MEM to suspend&n; * Context: must be able to sleep; device not locked&n; *&n; * Suspends a USB device that isn&squot;t in active use, conserving power.&n; * Devices may wake out of a suspend, if anything important happens,&n; * using the remote wakeup mechanism.  They may also be taken out of&n; * suspend by the host, using usb_resume_device().  It&squot;s also routine&n; * to disconnect devices while they are suspended.&n; *&n; * Suspending OTG devices may trigger HNP, if that&squot;s been enabled&n; * between a pair of dual-role devices.  That will change roles, such&n; * as from A-Host to A-Peripheral or from B-Host back to B-Peripheral.&n; *&n; * Returns 0 on success, else negative errno.&n; */
DECL|function|usb_suspend_device
r_int
id|usb_suspend_device
c_func
(paren
r_struct
id|usb_device
op_star
id|udev
comma
id|u32
id|state
)paren
(brace
r_return
id|__usb_suspend_device
c_func
(paren
id|udev
comma
id|locktree
c_func
(paren
id|udev
)paren
comma
id|state
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * hardware resume signaling is finished, either because of selective&n; * resume (by host) or remote wakeup (by device) ... now see what changed&n; * in the tree that&squot;s rooted at this device.&n; */
DECL|function|finish_port_resume
r_static
r_int
id|finish_port_resume
c_func
(paren
r_struct
id|usb_device
op_star
id|udev
)paren
(brace
r_int
id|status
suffix:semicolon
id|u16
id|devstatus
suffix:semicolon
multiline_comment|/* caller owns udev-&gt;serialize */
id|dev_dbg
c_func
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;usb resume&bslash;n&quot;
)paren
suffix:semicolon
id|udev-&gt;dev.power.power_state
op_assign
id|PM_SUSPEND_ON
suffix:semicolon
multiline_comment|/* usb ch9 identifies four variants of SUSPENDED, based on what&n;&t; * state the device resumes to.  Linux currently won&squot;t see the&n;&t; * first two on the host side; they&squot;d be inside hub_port_init()&n;&t; * during many timeouts, but khubd can&squot;t suspend until later.&n;&t; */
id|udev-&gt;state
op_assign
id|udev-&gt;actconfig
ques
c_cond
id|USB_STATE_CONFIGURED
suffix:colon
id|USB_STATE_ADDRESS
suffix:semicolon
multiline_comment|/* 10.5.4.5 says be sure devices in the tree are still there.&n; &t; * For now let&squot;s assume the device didn&squot;t go crazy on resume,&n;&t; * and device drivers will know about any resume quirks.&n;&t; */
id|status
op_assign
id|usb_get_status
c_func
(paren
id|udev
comma
id|USB_RECIP_DEVICE
comma
l_int|0
comma
op_amp
id|devstatus
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
id|dev_dbg
c_func
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;gone after usb resume? status %d&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|udev-&gt;actconfig
)paren
(brace
r_int
id|i
suffix:semicolon
id|le16_to_cpus
c_func
(paren
op_amp
id|devstatus
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devstatus
op_amp
(paren
l_int|1
op_lshift
id|USB_DEVICE_REMOTE_WAKEUP
)paren
)paren
(brace
id|status
op_assign
id|usb_control_msg
c_func
(paren
id|udev
comma
id|usb_sndctrlpipe
c_func
(paren
id|udev
comma
l_int|0
)paren
comma
id|USB_REQ_CLEAR_FEATURE
comma
id|USB_RECIP_DEVICE
comma
id|USB_DEVICE_REMOTE_WAKEUP
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|USB_CTRL_SET_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
id|dev_dbg
c_func
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;disable remote &quot;
l_string|&quot;wakeup, status %d&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
id|status
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* resume interface drivers; if this is a hub, it&n;&t;&t; * resumes the child devices&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|udev-&gt;actconfig-&gt;desc.bNumInterfaces
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|usb_interface
op_star
id|intf
suffix:semicolon
r_struct
id|usb_driver
op_star
id|driver
suffix:semicolon
id|intf
op_assign
id|udev-&gt;actconfig-&gt;interface
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|intf-&gt;dev.power.power_state
op_eq
id|PM_SUSPEND_ON
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|intf-&gt;dev.driver
)paren
(brace
multiline_comment|/* FIXME maybe force to alt 0 */
r_continue
suffix:semicolon
)brace
id|driver
op_assign
id|to_usb_driver
c_func
(paren
id|intf-&gt;dev.driver
)paren
suffix:semicolon
multiline_comment|/* bus_rescan_devices() may rebind drivers */
r_if
c_cond
(paren
op_logical_neg
id|driver-&gt;resume
)paren
r_continue
suffix:semicolon
multiline_comment|/* can we do better than just logging errors? */
id|status
op_assign
id|driver
op_member_access_from_pointer
id|resume
c_func
(paren
id|intf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intf-&gt;dev.power.power_state
op_ne
id|PM_SUSPEND_ON
op_logical_or
id|status
)paren
id|dev_dbg
c_func
(paren
op_amp
id|intf-&gt;dev
comma
l_string|&quot;resume fail, state %d code %d&bslash;n&quot;
comma
id|intf-&gt;dev.power.power_state
comma
id|status
)paren
suffix:semicolon
)brace
id|status
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|udev-&gt;devnum
op_le
l_int|0
)paren
(brace
id|dev_dbg
c_func
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;bogus resume!&bslash;n&quot;
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
r_static
r_int
DECL|function|hub_port_resume
id|hub_port_resume
c_func
(paren
r_struct
id|usb_device
op_star
id|hdev
comma
r_int
id|port
)paren
(brace
r_int
id|status
suffix:semicolon
r_struct
id|usb_device
op_star
id|udev
suffix:semicolon
id|udev
op_assign
id|hdev-&gt;children
(braket
id|port
op_minus
l_int|1
)braket
suffix:semicolon
singleline_comment|// dev_dbg(hubdev(hdev), &quot;resume port %d&bslash;n&quot;, port);
multiline_comment|/* see 7.1.7.7; affects power usage, but not budgeting */
id|status
op_assign
id|clear_port_feature
c_func
(paren
id|hdev
comma
id|port
comma
id|USB_PORT_FEAT_SUSPEND
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
id|dev_dbg
c_func
(paren
op_amp
id|hdev-&gt;actconfig-&gt;interface
(braket
l_int|0
)braket
op_member_access_from_pointer
id|dev
comma
l_string|&quot;can&squot;t resume port %d, status %d&bslash;n&quot;
comma
id|port
comma
id|status
)paren
suffix:semicolon
)brace
r_else
(brace
id|u16
id|devstatus
suffix:semicolon
id|u16
id|portchange
suffix:semicolon
multiline_comment|/* drive resume for at least 20 msec */
id|dev_dbg
c_func
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;RESUME&bslash;n&quot;
)paren
suffix:semicolon
id|msleep
c_func
(paren
l_int|25
)paren
suffix:semicolon
DECL|macro|LIVE_FLAGS
mdefine_line|#define LIVE_FLAGS&t;( USB_PORT_STAT_POWER &bslash;&n;&t;&t;&t;| USB_PORT_STAT_ENABLE &bslash;&n;&t;&t;&t;| USB_PORT_STAT_CONNECTION)
multiline_comment|/* Virtual root hubs can trigger on GET_PORT_STATUS to&n;&t;&t; * stop resume signaling.  Then finish the resume&n;&t;&t; * sequence.&n;&t;&t; */
id|devstatus
op_assign
id|portchange
op_assign
l_int|0
suffix:semicolon
id|status
op_assign
id|hub_port_status
c_func
(paren
id|hdev
comma
id|port
op_minus
l_int|1
comma
op_amp
id|devstatus
comma
op_amp
id|portchange
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
op_logical_or
(paren
id|devstatus
op_amp
id|LIVE_FLAGS
)paren
op_ne
id|LIVE_FLAGS
op_logical_or
(paren
id|devstatus
op_amp
id|USB_PORT_STAT_SUSPEND
)paren
op_ne
l_int|0
)paren
(brace
id|dev_dbg
c_func
(paren
op_amp
id|hdev-&gt;actconfig-&gt;interface
(braket
l_int|0
)braket
op_member_access_from_pointer
id|dev
comma
l_string|&quot;port %d status %04x.%04x after resume, %d&bslash;n&quot;
comma
id|port
comma
id|portchange
comma
id|devstatus
comma
id|status
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* TRSMRCY = 10 msec */
id|msleep
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|status
op_assign
id|finish_port_resume
c_func
(paren
id|udev
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
id|status
op_assign
id|hub_port_disable
c_func
(paren
id|hdev
comma
id|port
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
r_static
r_int
id|hub_resume
(paren
r_struct
id|usb_interface
op_star
id|intf
)paren
suffix:semicolon
multiline_comment|/**&n; * usb_resume_device - re-activate a suspended usb device&n; * @udev: device to re-activate&n; * Context: must be able to sleep; device not locked&n; *&n; * This will re-activate the suspended device, increasing power usage&n; * while letting drivers communicate again with its endpoints.&n; * USB resume explicitly guarantees that the power session between&n; * the host and the device is the same as it was when the device&n; * suspended.&n; *&n; * Returns 0 on success, else negative errno.&n; */
DECL|function|usb_resume_device
r_int
id|usb_resume_device
c_func
(paren
r_struct
id|usb_device
op_star
id|udev
)paren
(brace
r_int
id|port
comma
id|status
suffix:semicolon
id|port
op_assign
id|locktree
c_func
(paren
id|udev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port
OL
l_int|0
)paren
r_return
id|port
suffix:semicolon
multiline_comment|/* &quot;global resume&quot; of the HC-to-USB interface (root hub), or&n;&t; * selective resume of one hub-to-device port&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|udev-&gt;parent
)paren
(brace
r_struct
id|usb_bus
op_star
id|bus
op_assign
id|udev-&gt;bus
suffix:semicolon
r_if
c_cond
(paren
id|bus
op_logical_and
id|bus-&gt;op-&gt;hub_resume
)paren
id|status
op_assign
id|bus-&gt;op-&gt;hub_resume
(paren
id|bus
)paren
suffix:semicolon
r_else
id|status
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
l_int|0
)paren
(brace
multiline_comment|/* TRSMRCY = 10 msec */
id|msleep
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|status
op_assign
id|hub_resume
(paren
id|bus-&gt;root_hub
op_member_access_from_pointer
id|actconfig-&gt;interface
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|udev-&gt;state
op_eq
id|USB_STATE_SUSPENDED
)paren
(brace
id|status
op_assign
id|hub_port_resume
c_func
(paren
id|udev-&gt;parent
comma
id|port
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
l_int|0
suffix:semicolon
id|udev-&gt;dev.power.power_state
op_assign
id|PM_SUSPEND_ON
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
id|dev_dbg
c_func
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;can&squot;t resume, status %d&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|udev-&gt;serialize
)paren
suffix:semicolon
multiline_comment|/* rebind drivers that had no suspend() */
id|bus_rescan_devices
c_func
(paren
op_amp
id|usb_bus_type
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
DECL|function|remote_wakeup
r_static
r_int
id|remote_wakeup
c_func
(paren
r_struct
id|usb_device
op_star
id|udev
)paren
(brace
r_int
id|status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* don&squot;t repeat RESUME sequence if this device&n;&t; * was already woken up by some other task&n;&t; */
id|down
c_func
(paren
op_amp
id|udev-&gt;serialize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|udev-&gt;state
op_eq
id|USB_STATE_SUSPENDED
)paren
(brace
id|dev_dbg
c_func
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;RESUME (wakeup)&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* TRSMRCY = 10 msec */
id|msleep
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|status
op_assign
id|finish_port_resume
c_func
(paren
id|udev
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|udev-&gt;serialize
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
DECL|function|hub_suspend
r_static
r_int
id|hub_suspend
c_func
(paren
r_struct
id|usb_interface
op_star
id|intf
comma
id|u32
id|state
)paren
(brace
r_struct
id|usb_hub
op_star
id|hub
op_assign
id|usb_get_intfdata
(paren
id|intf
)paren
suffix:semicolon
r_struct
id|usb_device
op_star
id|hdev
op_assign
id|hub-&gt;hdev
suffix:semicolon
r_int
id|port
suffix:semicolon
r_int
id|status
suffix:semicolon
multiline_comment|/* stop khubd and related activity */
id|hub_quiesce
c_func
(paren
id|hub
)paren
suffix:semicolon
multiline_comment|/* then suspend every port */
r_for
c_loop
(paren
id|port
op_assign
l_int|0
suffix:semicolon
id|port
OL
id|hdev-&gt;maxchild
suffix:semicolon
id|port
op_increment
)paren
(brace
r_struct
id|usb_device
op_star
id|udev
suffix:semicolon
id|udev
op_assign
id|hdev-&gt;children
(braket
id|port
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|udev
)paren
r_continue
suffix:semicolon
id|down
c_func
(paren
op_amp
id|udev-&gt;serialize
)paren
suffix:semicolon
id|status
op_assign
id|__usb_suspend_device
c_func
(paren
id|udev
comma
id|port
comma
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
id|dev_dbg
c_func
(paren
op_amp
id|intf-&gt;dev
comma
l_string|&quot;suspend port %d --&gt; %d&bslash;n&quot;
comma
id|port
comma
id|status
)paren
suffix:semicolon
)brace
id|intf-&gt;dev.power.power_state
op_assign
id|state
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|hub_resume
r_static
r_int
id|hub_resume
c_func
(paren
r_struct
id|usb_interface
op_star
id|intf
)paren
(brace
r_struct
id|usb_device
op_star
id|hdev
op_assign
id|interface_to_usbdev
c_func
(paren
id|intf
)paren
suffix:semicolon
r_struct
id|usb_hub
op_star
id|hub
op_assign
id|usb_get_intfdata
(paren
id|intf
)paren
suffix:semicolon
r_int
id|port
suffix:semicolon
r_int
id|status
suffix:semicolon
r_for
c_loop
(paren
id|port
op_assign
l_int|0
suffix:semicolon
id|port
OL
id|hdev-&gt;maxchild
suffix:semicolon
id|port
op_increment
)paren
(brace
r_struct
id|usb_device
op_star
id|udev
suffix:semicolon
id|u16
id|portstat
comma
id|portchange
suffix:semicolon
id|udev
op_assign
id|hdev-&gt;children
(braket
id|port
)braket
suffix:semicolon
id|status
op_assign
id|hub_port_status
c_func
(paren
id|hdev
comma
id|port
comma
op_amp
id|portstat
comma
op_amp
id|portchange
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|portchange
op_amp
id|USB_PORT_STAT_C_SUSPEND
)paren
(brace
id|clear_port_feature
c_func
(paren
id|hdev
comma
id|port
op_plus
l_int|1
comma
id|USB_PORT_FEAT_C_SUSPEND
)paren
suffix:semicolon
id|portchange
op_and_assign
op_complement
id|USB_PORT_STAT_C_SUSPEND
suffix:semicolon
)brace
multiline_comment|/* let khubd handle disconnects etc */
r_if
c_cond
(paren
id|portchange
)paren
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|udev
)paren
r_continue
suffix:semicolon
id|down
(paren
op_amp
id|udev-&gt;serialize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|portstat
op_amp
id|USB_PORT_STAT_SUSPEND
)paren
id|status
op_assign
id|hub_port_resume
c_func
(paren
id|hdev
comma
id|port
op_plus
l_int|1
)paren
suffix:semicolon
r_else
(brace
id|status
op_assign
id|finish_port_resume
c_func
(paren
id|udev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
id|status
op_assign
id|hub_port_disable
c_func
(paren
id|hdev
comma
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
id|dev_dbg
c_func
(paren
op_amp
id|intf-&gt;dev
comma
l_string|&quot;resume port %d --&gt; %d&bslash;n&quot;
comma
id|port
comma
id|status
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|udev-&gt;serialize
)paren
suffix:semicolon
)brace
id|intf-&gt;dev.power.power_state
op_assign
id|PM_SUSPEND_ON
suffix:semicolon
id|hub_reactivate
c_func
(paren
id|hub
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#else&t;/* !CONFIG_USB_SUSPEND */
DECL|function|usb_suspend_device
r_int
id|usb_suspend_device
c_func
(paren
r_struct
id|usb_device
op_star
id|udev
comma
id|u32
id|state
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usb_resume_device
r_int
id|usb_resume_device
c_func
(paren
r_struct
id|usb_device
op_star
id|udev
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|hub_suspend
mdefine_line|#define&t;hub_suspend&t;&t;NULL
DECL|macro|hub_resume
mdefine_line|#define&t;hub_resume&t;&t;NULL
DECL|macro|remote_wakeup
mdefine_line|#define&t;remote_wakeup(x)&t;0
macro_line|#endif&t;/* CONFIG_USB_SUSPEND */
DECL|variable|usb_suspend_device
id|EXPORT_SYMBOL
c_func
(paren
id|usb_suspend_device
)paren
suffix:semicolon
DECL|variable|usb_resume_device
id|EXPORT_SYMBOL
c_func
(paren
id|usb_resume_device
)paren
suffix:semicolon
multiline_comment|/* USB 2.0 spec, 7.1.7.3 / fig 7-29:&n; *&n; * Between connect detection and reset signaling there must be a delay&n; * of 100ms at least for debounce and power-settling.  The corresponding&n; * timer shall restart whenever the downstream port detects a disconnect.&n; * &n; * Apparently there are some bluetooth and irda-dongles and a number of&n; * low-speed devices for which this debounce period may last over a second.&n; * Not covered by the spec - but easy to deal with.&n; *&n; * This implementation uses a 1500ms total debounce timeout; if the&n; * connection isn&squot;t stable by then it returns -ETIMEDOUT.  It checks&n; * every 25ms for transient disconnects.  When the port status has been&n; * unchanged for 100ms it returns the port status.&n; */
DECL|macro|HUB_DEBOUNCE_TIMEOUT
mdefine_line|#define HUB_DEBOUNCE_TIMEOUT&t;1500
DECL|macro|HUB_DEBOUNCE_STEP
mdefine_line|#define HUB_DEBOUNCE_STEP&t;  25
DECL|macro|HUB_DEBOUNCE_STABLE
mdefine_line|#define HUB_DEBOUNCE_STABLE&t; 100
DECL|function|hub_port_debounce
r_static
r_int
id|hub_port_debounce
c_func
(paren
r_struct
id|usb_device
op_star
id|hdev
comma
r_int
id|port
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
id|total_time
comma
id|stable_time
op_assign
l_int|0
suffix:semicolon
id|u16
id|portchange
comma
id|portstatus
suffix:semicolon
r_int
id|connection
op_assign
l_int|0xffff
suffix:semicolon
r_for
c_loop
(paren
id|total_time
op_assign
l_int|0
suffix:semicolon
suffix:semicolon
id|total_time
op_add_assign
id|HUB_DEBOUNCE_STEP
)paren
(brace
id|ret
op_assign
id|hub_port_status
c_func
(paren
id|hdev
comma
id|port
comma
op_amp
id|portstatus
comma
op_amp
id|portchange
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|portchange
op_amp
id|USB_PORT_STAT_C_CONNECTION
)paren
op_logical_and
(paren
id|portstatus
op_amp
id|USB_PORT_STAT_CONNECTION
)paren
op_eq
id|connection
)paren
(brace
id|stable_time
op_add_assign
id|HUB_DEBOUNCE_STEP
suffix:semicolon
r_if
c_cond
(paren
id|stable_time
op_ge
id|HUB_DEBOUNCE_STABLE
)paren
r_break
suffix:semicolon
)brace
r_else
(brace
id|stable_time
op_assign
l_int|0
suffix:semicolon
id|connection
op_assign
id|portstatus
op_amp
id|USB_PORT_STAT_CONNECTION
suffix:semicolon
)brace
r_if
c_cond
(paren
id|portchange
op_amp
id|USB_PORT_STAT_C_CONNECTION
)paren
(brace
id|clear_port_feature
c_func
(paren
id|hdev
comma
id|port
op_plus
l_int|1
comma
id|USB_PORT_FEAT_C_CONNECTION
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|total_time
op_ge
id|HUB_DEBOUNCE_TIMEOUT
)paren
r_break
suffix:semicolon
id|msleep
c_func
(paren
id|HUB_DEBOUNCE_STEP
)paren
suffix:semicolon
)brace
id|dev_dbg
(paren
id|hubdev
(paren
id|hdev
)paren
comma
l_string|&quot;debounce: port %d: total %dms stable %dms status 0x%x&bslash;n&quot;
comma
id|port
op_plus
l_int|1
comma
id|total_time
comma
id|stable_time
comma
id|portstatus
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stable_time
OL
id|HUB_DEBOUNCE_STABLE
)paren
r_return
op_minus
id|ETIMEDOUT
suffix:semicolon
r_return
id|portstatus
suffix:semicolon
)brace
DECL|function|hub_set_address
r_static
r_int
id|hub_set_address
c_func
(paren
r_struct
id|usb_device
op_star
id|udev
)paren
(brace
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|udev-&gt;devnum
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|udev-&gt;state
op_ne
id|USB_STATE_DEFAULT
op_logical_and
id|udev-&gt;state
op_ne
id|USB_STATE_ADDRESS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|retval
op_assign
id|usb_control_msg
c_func
(paren
id|udev
comma
(paren
id|PIPE_CONTROL
op_lshift
l_int|30
)paren
multiline_comment|/* Address 0 */
comma
id|USB_REQ_SET_ADDRESS
comma
l_int|0
comma
id|udev-&gt;devnum
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
op_star
id|USB_CTRL_SET_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
l_int|0
)paren
id|usb_set_device_state
c_func
(paren
id|udev
comma
id|USB_STATE_ADDRESS
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* Reset device, (re)assign address, get device descriptor.&n; * Device connection must be stable, no more debouncing needed.&n; * Returns device in USB_STATE_ADDRESS, except on error.&n; *&n; * If this is called for an already-existing device (as part of&n; * usb_reset_device), the caller must own the device lock.  For a&n; * newly detected device that is not accessible through any global&n; * pointers, it&squot;s not necessary to lock the device.&n; */
r_static
r_int
DECL|function|hub_port_init
id|hub_port_init
(paren
r_struct
id|usb_device
op_star
id|hdev
comma
r_struct
id|usb_device
op_star
id|udev
comma
r_int
id|port
)paren
(brace
r_static
id|DECLARE_MUTEX
c_func
(paren
id|usb_address0_sem
)paren
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|retval
suffix:semicolon
r_int
id|delay
op_assign
id|HUB_SHORT_RESET_TIME
suffix:semicolon
r_enum
id|usb_device_speed
id|oldspeed
op_assign
id|udev-&gt;speed
suffix:semicolon
multiline_comment|/* root hub ports have a slightly longer reset period&n;&t; * (from USB 2.0 spec, section 7.1.7.5)&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|hdev-&gt;parent
)paren
(brace
id|delay
op_assign
id|HUB_ROOT_RESET_TIME
suffix:semicolon
r_if
c_cond
(paren
id|port
op_plus
l_int|1
op_eq
id|hdev-&gt;bus-&gt;otg_port
)paren
id|hdev-&gt;bus-&gt;b_hnp_enable
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Some low speed devices have problems with the quick delay, so */
multiline_comment|/*  be a bit pessimistic with those devices. RHbug #23670 */
r_if
c_cond
(paren
id|oldspeed
op_eq
id|USB_SPEED_LOW
)paren
id|delay
op_assign
id|HUB_LONG_RESET_TIME
suffix:semicolon
id|down
c_func
(paren
op_amp
id|usb_address0_sem
)paren
suffix:semicolon
multiline_comment|/* Reset the device; full speed may morph to high speed */
id|retval
op_assign
id|hub_port_reset
c_func
(paren
id|hdev
comma
id|port
comma
id|udev
comma
id|delay
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
multiline_comment|/* error or disconnect */
r_goto
id|fail
suffix:semicolon
multiline_comment|/* success, speed is known */
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|oldspeed
op_ne
id|USB_SPEED_UNKNOWN
op_logical_and
id|oldspeed
op_ne
id|udev-&gt;speed
)paren
(brace
id|dev_dbg
c_func
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;device reset changed speed!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
multiline_comment|/* USB 2.0 section 5.5.3 talks about ep0 maxpacket ...&n;&t; * it&squot;s fixed size except for full speed devices.&n;&t; */
r_switch
c_cond
(paren
id|udev-&gt;speed
)paren
(brace
r_case
id|USB_SPEED_HIGH
suffix:colon
multiline_comment|/* fixed at 64 */
id|i
op_assign
l_int|64
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_SPEED_FULL
suffix:colon
multiline_comment|/* 8, 16, 32, or 64 */
multiline_comment|/* to determine the ep0 maxpacket size, read the first 8&n;&t;&t; * bytes from the device descriptor to get bMaxPacketSize0;&n;&t;&t; * then correct our initial (small) guess.&n;&t;&t; */
singleline_comment|// FALLTHROUGH
r_case
id|USB_SPEED_LOW
suffix:colon
multiline_comment|/* fixed at 8 */
id|i
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_goto
id|fail
suffix:semicolon
)brace
id|udev-&gt;epmaxpacketin
(braket
l_int|0
)braket
op_assign
id|i
suffix:semicolon
id|udev-&gt;epmaxpacketout
(braket
l_int|0
)braket
op_assign
id|i
suffix:semicolon
id|dev_info
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;%s %s speed USB device using address %d&bslash;n&quot;
comma
(paren
id|udev-&gt;config
)paren
ques
c_cond
l_string|&quot;reset&quot;
suffix:colon
l_string|&quot;new&quot;
comma
(paren
(brace
r_char
op_star
id|speed
suffix:semicolon
r_switch
(paren
id|udev-&gt;speed
)paren
(brace
r_case
id|USB_SPEED_LOW
suffix:colon
id|speed
op_assign
l_string|&quot;low&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_SPEED_FULL
suffix:colon
id|speed
op_assign
l_string|&quot;full&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_SPEED_HIGH
suffix:colon
id|speed
op_assign
l_string|&quot;high&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|speed
op_assign
l_string|&quot;?&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|speed
suffix:semicolon
)brace
)paren
comma
id|udev-&gt;devnum
)paren
suffix:semicolon
multiline_comment|/* Set up TT records, if needed  */
r_if
c_cond
(paren
id|hdev-&gt;tt
)paren
(brace
id|udev-&gt;tt
op_assign
id|hdev-&gt;tt
suffix:semicolon
id|udev-&gt;ttport
op_assign
id|hdev-&gt;ttport
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|udev-&gt;speed
op_ne
id|USB_SPEED_HIGH
op_logical_and
id|hdev-&gt;speed
op_eq
id|USB_SPEED_HIGH
)paren
(brace
r_struct
id|usb_hub
op_star
id|hub
suffix:semicolon
id|hub
op_assign
id|usb_get_intfdata
c_func
(paren
id|hdev-&gt;actconfig-&gt;interface
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|udev-&gt;tt
op_assign
op_amp
id|hub-&gt;tt
suffix:semicolon
id|udev-&gt;ttport
op_assign
id|port
op_plus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Why interleave GET_DESCRIPTOR and SET_ADDRESS this way?&n;&t; * Because device hardware and firmware is sometimes buggy in&n;&t; * this area, and this is how Linux has done it for ages.&n;&t; * Change it cautiously.&n;&t; *&n;&t; * NOTE:  Windows gets the descriptor first, seemingly to help&n;&t; * work around device bugs like &quot;can&squot;t use addresses with bit 3&n;&t; * set in certain configurations&quot;.  Yes, really.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|GET_DESCRIPTOR_TRIES
suffix:semicolon
op_increment
id|i
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|SET_ADDRESS_TRIES
suffix:semicolon
op_increment
id|j
)paren
(brace
id|retval
op_assign
id|hub_set_address
c_func
(paren
id|udev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ge
l_int|0
)paren
r_break
suffix:semicolon
id|msleep
c_func
(paren
l_int|200
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
(brace
id|dev_err
c_func
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;device not accepting address %d, error %d&bslash;n&quot;
comma
id|udev-&gt;devnum
comma
id|retval
)paren
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
multiline_comment|/* cope with hardware quirkiness:&n;&t;&t; *  - let SET_ADDRESS settle, some device hardware wants it&n;&t;&t; *  - read ep0 maxpacket even for high and low speed,&n;  &t;&t; */
id|msleep
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|retval
op_assign
id|usb_get_device_descriptor
c_func
(paren
id|udev
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ge
l_int|8
)paren
r_break
suffix:semicolon
id|msleep
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
op_ne
l_int|8
)paren
(brace
id|dev_err
c_func
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;device descriptor read/%s, error %d&bslash;n&quot;
comma
l_string|&quot;8&quot;
comma
id|retval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ge
l_int|0
)paren
id|retval
op_assign
op_minus
id|EMSGSIZE
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
r_if
c_cond
(paren
id|udev-&gt;speed
op_eq
id|USB_SPEED_FULL
op_logical_and
(paren
id|udev-&gt;epmaxpacketin
(braket
l_int|0
)braket
op_ne
id|udev-&gt;descriptor.bMaxPacketSize0
)paren
)paren
(brace
id|usb_disable_endpoint
c_func
(paren
id|udev
comma
l_int|0
op_plus
id|USB_DIR_IN
)paren
suffix:semicolon
id|usb_disable_endpoint
c_func
(paren
id|udev
comma
l_int|0
op_plus
id|USB_DIR_OUT
)paren
suffix:semicolon
id|usb_endpoint_running
c_func
(paren
id|udev
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|usb_endpoint_running
c_func
(paren
id|udev
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|udev-&gt;epmaxpacketin
(braket
l_int|0
)braket
op_assign
id|udev-&gt;descriptor.bMaxPacketSize0
suffix:semicolon
id|udev-&gt;epmaxpacketout
(braket
l_int|0
)braket
op_assign
id|udev-&gt;descriptor.bMaxPacketSize0
suffix:semicolon
)brace
id|retval
op_assign
id|usb_get_device_descriptor
c_func
(paren
id|udev
comma
id|USB_DT_DEVICE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
(paren
r_int
)paren
r_sizeof
(paren
id|udev-&gt;descriptor
)paren
)paren
(brace
id|dev_err
c_func
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;device descriptor read/%s, error %d&bslash;n&quot;
comma
l_string|&quot;all&quot;
comma
id|retval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ge
l_int|0
)paren
id|retval
op_assign
op_minus
id|ENOMSG
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
id|retval
op_assign
l_int|0
suffix:semicolon
id|fail
suffix:colon
id|up
c_func
(paren
op_amp
id|usb_address0_sem
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_static
r_void
DECL|function|check_highspeed
id|check_highspeed
(paren
r_struct
id|usb_hub
op_star
id|hub
comma
r_struct
id|usb_device
op_star
id|udev
comma
r_int
id|port
)paren
(brace
r_struct
id|usb_qualifier_descriptor
op_star
id|qual
suffix:semicolon
r_int
id|status
suffix:semicolon
id|qual
op_assign
id|kmalloc
(paren
r_sizeof
op_star
id|qual
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qual
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|status
op_assign
id|usb_get_descriptor
(paren
id|udev
comma
id|USB_DT_DEVICE_QUALIFIER
comma
l_int|0
comma
id|qual
comma
r_sizeof
op_star
id|qual
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
r_sizeof
op_star
id|qual
)paren
(brace
id|dev_info
c_func
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;not running at top speed; &quot;
l_string|&quot;connect to a high speed hub&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* hub LEDs are probably harder to miss than syslog */
r_if
c_cond
(paren
id|hub-&gt;has_indicators
)paren
(brace
id|hub-&gt;indicator
(braket
id|port
)braket
op_assign
id|INDICATOR_GREEN_BLINK
suffix:semicolon
id|schedule_work
(paren
op_amp
id|hub-&gt;leds
)paren
suffix:semicolon
)brace
)brace
id|kfree
(paren
id|qual
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|hub_power_remaining
id|hub_power_remaining
(paren
r_struct
id|usb_hub
op_star
id|hub
)paren
(brace
r_struct
id|usb_device
op_star
id|hdev
op_assign
id|hub-&gt;hdev
suffix:semicolon
r_int
id|remaining
suffix:semicolon
r_int
id|i
suffix:semicolon
id|remaining
op_assign
id|hub-&gt;power_budget
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|remaining
)paren
multiline_comment|/* self-powered */
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|hdev-&gt;maxchild
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|usb_device
op_star
id|udev
op_assign
id|hdev-&gt;children
(braket
id|i
)braket
suffix:semicolon
r_int
id|delta
comma
id|ceiling
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|udev
)paren
r_continue
suffix:semicolon
multiline_comment|/* 100mA per-port ceiling, or 8mA for OTG ports */
r_if
c_cond
(paren
id|i
op_ne
(paren
id|udev-&gt;bus-&gt;otg_port
op_minus
l_int|1
)paren
op_logical_or
id|hdev-&gt;parent
)paren
id|ceiling
op_assign
l_int|50
suffix:semicolon
r_else
id|ceiling
op_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|udev-&gt;actconfig
)paren
id|delta
op_assign
id|udev-&gt;actconfig-&gt;desc.bMaxPower
suffix:semicolon
r_else
id|delta
op_assign
id|ceiling
suffix:semicolon
singleline_comment|// dev_dbg(&amp;udev-&gt;dev, &quot;budgeted %dmA&bslash;n&quot;, 2 * delta);
r_if
c_cond
(paren
id|delta
OG
id|ceiling
)paren
id|dev_warn
c_func
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;%dmA over %dmA budget!&bslash;n&quot;
comma
l_int|2
op_star
(paren
id|delta
op_minus
id|ceiling
)paren
comma
l_int|2
op_star
id|ceiling
)paren
suffix:semicolon
id|remaining
op_sub_assign
id|delta
suffix:semicolon
)brace
r_if
c_cond
(paren
id|remaining
OL
l_int|0
)paren
(brace
id|dev_warn
c_func
(paren
op_amp
id|hub-&gt;intf-&gt;dev
comma
l_string|&quot;%dmA over power budget!&bslash;n&quot;
comma
op_minus
l_int|2
op_star
id|remaining
)paren
suffix:semicolon
id|remaining
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|remaining
suffix:semicolon
)brace
multiline_comment|/* Handle physical or logical connection change events.&n; * This routine is called when:&n; * &t;a port connection-change occurs;&n; *&t;a port enable-change occurs (often caused by EMI);&n; *&t;usb_reset_device() encounters changed descriptors (as from&n; *&t;&t;a firmware download)&n; * caller already locked the hub&n; */
DECL|function|hub_port_connect_change
r_static
r_void
id|hub_port_connect_change
c_func
(paren
r_struct
id|usb_hub
op_star
id|hub
comma
r_int
id|port
comma
id|u16
id|portstatus
comma
id|u16
id|portchange
)paren
(brace
r_struct
id|usb_device
op_star
id|hdev
op_assign
id|hub-&gt;hdev
suffix:semicolon
r_struct
id|device
op_star
id|hub_dev
op_assign
op_amp
id|hub-&gt;intf-&gt;dev
suffix:semicolon
r_int
id|status
comma
id|i
suffix:semicolon
id|dev_dbg
(paren
id|hub_dev
comma
l_string|&quot;port %d, status %04x, change %04x, %s&bslash;n&quot;
comma
id|port
op_plus
l_int|1
comma
id|portstatus
comma
id|portchange
comma
id|portspeed
(paren
id|portstatus
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hub-&gt;has_indicators
)paren
(brace
id|set_port_led
c_func
(paren
id|hdev
comma
id|port
op_plus
l_int|1
comma
id|HUB_LED_AUTO
)paren
suffix:semicolon
id|hub-&gt;indicator
(braket
id|port
)braket
op_assign
id|INDICATOR_AUTO
suffix:semicolon
)brace
multiline_comment|/* Disconnect any existing devices under this port */
r_if
c_cond
(paren
id|hdev-&gt;children
(braket
id|port
)braket
)paren
id|usb_disconnect
c_func
(paren
op_amp
id|hdev-&gt;children
(braket
id|port
)braket
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|port
comma
id|hub-&gt;change_bits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|portchange
op_amp
id|USB_PORT_STAT_C_CONNECTION
)paren
(brace
id|status
op_assign
id|hub_port_debounce
c_func
(paren
id|hdev
comma
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
id|dev_err
(paren
id|hub_dev
comma
l_string|&quot;connect-debounce failed, port %d disabled&bslash;n&quot;
comma
id|port
op_plus
l_int|1
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|portstatus
op_assign
id|status
suffix:semicolon
)brace
multiline_comment|/* Return now if nothing is connected */
r_if
c_cond
(paren
op_logical_neg
(paren
id|portstatus
op_amp
id|USB_PORT_STAT_CONNECTION
)paren
)paren
(brace
multiline_comment|/* maybe switch power back on (e.g. root hub was reset) */
r_if
c_cond
(paren
(paren
id|hub-&gt;descriptor-&gt;wHubCharacteristics
op_amp
id|HUB_CHAR_LPSM
)paren
OL
l_int|2
op_logical_and
op_logical_neg
(paren
id|portstatus
op_amp
(paren
l_int|1
op_lshift
id|USB_PORT_FEAT_POWER
)paren
)paren
)paren
id|set_port_feature
c_func
(paren
id|hdev
comma
id|port
op_plus
l_int|1
comma
id|USB_PORT_FEAT_POWER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|portstatus
op_amp
id|USB_PORT_STAT_ENABLE
)paren
r_goto
id|done
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SET_CONFIG_TRIES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|usb_device
op_star
id|udev
suffix:semicolon
multiline_comment|/* reallocate for each attempt, since references&n;&t;&t; * to the previous one can escape in various ways&n;&t;&t; */
id|udev
op_assign
id|usb_alloc_dev
c_func
(paren
id|hdev
comma
id|hdev-&gt;bus
comma
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|udev
)paren
(brace
id|dev_err
(paren
id|hub_dev
comma
l_string|&quot;couldn&squot;t allocate port %d usb_device&bslash;n&quot;
comma
id|port
op_plus
l_int|1
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|usb_set_device_state
c_func
(paren
id|udev
comma
id|USB_STATE_POWERED
)paren
suffix:semicolon
id|udev-&gt;speed
op_assign
id|USB_SPEED_UNKNOWN
suffix:semicolon
multiline_comment|/* set the address */
id|choose_address
c_func
(paren
id|udev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|udev-&gt;devnum
op_le
l_int|0
)paren
(brace
id|status
op_assign
op_minus
id|ENOTCONN
suffix:semicolon
multiline_comment|/* Don&squot;t retry */
r_goto
id|loop
suffix:semicolon
)brace
multiline_comment|/* reset and get descriptor */
id|status
op_assign
id|hub_port_init
c_func
(paren
id|hdev
comma
id|udev
comma
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
r_goto
id|loop
suffix:semicolon
multiline_comment|/* consecutive bus-powered hubs aren&squot;t reliable; they can&n;&t;&t; * violate the voltage drop budget.  if the new child has&n;&t;&t; * a &quot;powered&quot; LED, users should notice we didn&squot;t enable it&n;&t;&t; * (without reading syslog), even without per-port LEDs&n;&t;&t; * on the parent.&n;&t;&t; */
r_if
c_cond
(paren
id|udev-&gt;descriptor.bDeviceClass
op_eq
id|USB_CLASS_HUB
op_logical_and
id|hub-&gt;power_budget
)paren
(brace
id|u16
id|devstat
suffix:semicolon
id|status
op_assign
id|usb_get_status
c_func
(paren
id|udev
comma
id|USB_RECIP_DEVICE
comma
l_int|0
comma
op_amp
id|devstat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
id|dev_dbg
c_func
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;get status %d ?&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_goto
id|loop
suffix:semicolon
)brace
id|cpu_to_le16s
c_func
(paren
op_amp
id|devstat
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|devstat
op_amp
(paren
l_int|1
op_lshift
id|USB_DEVICE_SELF_POWERED
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|dev_err
c_func
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;can&squot;t connect bus-powered hub &quot;
l_string|&quot;to this port&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hub-&gt;has_indicators
)paren
(brace
id|hub-&gt;indicator
(braket
id|port
)braket
op_assign
id|INDICATOR_AMBER_BLINK
suffix:semicolon
id|schedule_work
(paren
op_amp
id|hub-&gt;leds
)paren
suffix:semicolon
)brace
id|status
op_assign
op_minus
id|ENOTCONN
suffix:semicolon
multiline_comment|/* Don&squot;t retry */
r_goto
id|loop
suffix:semicolon
)brace
)brace
multiline_comment|/* check for devices running slower than they could */
r_if
c_cond
(paren
id|udev-&gt;descriptor.bcdUSB
op_ge
l_int|0x0200
op_logical_and
id|udev-&gt;speed
op_eq
id|USB_SPEED_FULL
op_logical_and
id|highspeed_hubs
op_ne
l_int|0
)paren
id|check_highspeed
(paren
id|hub
comma
id|udev
comma
id|port
)paren
suffix:semicolon
multiline_comment|/* Store the parent&squot;s children[] pointer.  At this point&n;&t;&t; * udev becomes globally accessible, although presumably&n;&t;&t; * no one will look at it until hdev is unlocked.&n;&t;&t; */
id|down
(paren
op_amp
id|udev-&gt;serialize
)paren
suffix:semicolon
id|status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We mustn&squot;t add new devices if the parent hub has&n;&t;&t; * been disconnected; we would race with the&n;&t;&t; * recursively_mark_NOTATTACHED() routine.&n;&t;&t; */
id|spin_lock_irq
c_func
(paren
op_amp
id|device_state_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hdev-&gt;state
op_eq
id|USB_STATE_NOTATTACHED
)paren
id|status
op_assign
op_minus
id|ENOTCONN
suffix:semicolon
r_else
id|hdev-&gt;children
(braket
id|port
)braket
op_assign
id|udev
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|device_state_lock
)paren
suffix:semicolon
multiline_comment|/* Run it through the hoops (find a driver, etc) */
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
id|status
op_assign
id|usb_new_device
c_func
(paren
id|udev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|device_state_lock
)paren
suffix:semicolon
id|hdev-&gt;children
(braket
id|port
)braket
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|device_state_lock
)paren
suffix:semicolon
)brace
)brace
id|up
(paren
op_amp
id|udev-&gt;serialize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_goto
id|loop
suffix:semicolon
id|status
op_assign
id|hub_power_remaining
c_func
(paren
id|hub
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
id|dev_dbg
c_func
(paren
id|hub_dev
comma
l_string|&quot;%dmA power budget left&bslash;n&quot;
comma
l_int|2
op_star
id|status
)paren
suffix:semicolon
r_return
suffix:semicolon
id|loop
suffix:colon
id|hub_port_disable
c_func
(paren
id|hdev
comma
id|port
)paren
suffix:semicolon
id|usb_disable_endpoint
c_func
(paren
id|udev
comma
l_int|0
op_plus
id|USB_DIR_IN
)paren
suffix:semicolon
id|usb_disable_endpoint
c_func
(paren
id|udev
comma
l_int|0
op_plus
id|USB_DIR_OUT
)paren
suffix:semicolon
id|release_address
c_func
(paren
id|udev
)paren
suffix:semicolon
id|usb_put_dev
c_func
(paren
id|udev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
op_minus
id|ENOTCONN
)paren
r_break
suffix:semicolon
)brace
id|done
suffix:colon
id|hub_port_disable
c_func
(paren
id|hdev
comma
id|port
)paren
suffix:semicolon
)brace
DECL|function|hub_events
r_static
r_void
id|hub_events
c_func
(paren
r_void
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_struct
id|usb_device
op_star
id|hdev
suffix:semicolon
r_struct
id|usb_hub
op_star
id|hub
suffix:semicolon
r_struct
id|device
op_star
id|hub_dev
suffix:semicolon
id|u16
id|hubstatus
suffix:semicolon
id|u16
id|hubchange
suffix:semicolon
id|u16
id|portstatus
suffix:semicolon
id|u16
id|portchange
suffix:semicolon
r_int
id|i
comma
id|ret
suffix:semicolon
r_int
id|connect_change
suffix:semicolon
multiline_comment|/*&n;&t; *  We restart the list every time to avoid a deadlock with&n;&t; * deleting hubs downstream from this one. This should be&n;&t; * safe since we delete the hub from the event list.&n;&t; * Not the most efficient, but avoids deadlocks.&n;&t; */
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/* Grab the first entry at the beginning of the list */
id|spin_lock_irq
c_func
(paren
op_amp
id|hub_event_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|hub_event_list
)paren
)paren
(brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|hub_event_lock
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tmp
op_assign
id|hub_event_list.next
suffix:semicolon
id|list_del_init
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|hub
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|usb_hub
comma
id|event_list
)paren
suffix:semicolon
id|hdev
op_assign
id|hub-&gt;hdev
suffix:semicolon
id|hub_dev
op_assign
op_amp
id|hub-&gt;intf-&gt;dev
suffix:semicolon
id|usb_get_dev
c_func
(paren
id|hdev
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|hub_event_lock
)paren
suffix:semicolon
multiline_comment|/* Lock the device, then check to see if we were&n;&t;&t; * disconnected while waiting for the lock to succeed. */
r_if
c_cond
(paren
id|locktree
c_func
(paren
id|hdev
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|hdev-&gt;state
op_ne
id|USB_STATE_CONFIGURED
op_logical_or
op_logical_neg
id|hdev-&gt;actconfig
op_logical_or
id|hub
op_ne
id|usb_get_intfdata
c_func
(paren
id|hdev-&gt;actconfig-&gt;interface
(braket
l_int|0
)braket
)paren
)paren
r_goto
id|loop
suffix:semicolon
r_if
c_cond
(paren
id|hub-&gt;error
)paren
(brace
id|dev_dbg
(paren
id|hub_dev
comma
l_string|&quot;resetting for error %d&bslash;n&quot;
comma
id|hub-&gt;error
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hub_reset
c_func
(paren
id|hub
)paren
)paren
(brace
id|dev_dbg
(paren
id|hub_dev
comma
l_string|&quot;can&squot;t reset; disconnecting&bslash;n&quot;
)paren
suffix:semicolon
id|hub_start_disconnect
c_func
(paren
id|hdev
)paren
suffix:semicolon
r_goto
id|loop
suffix:semicolon
)brace
id|hub-&gt;nerrors
op_assign
l_int|0
suffix:semicolon
id|hub-&gt;error
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* deal with port status changes */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|hub-&gt;descriptor-&gt;bNbrPorts
suffix:semicolon
id|i
op_increment
)paren
(brace
id|connect_change
op_assign
id|test_bit
c_func
(paren
id|i
comma
id|hub-&gt;change_bits
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_and_clear_bit
c_func
(paren
id|i
op_plus
l_int|1
comma
id|hub-&gt;event_bits
)paren
op_logical_and
op_logical_neg
id|connect_change
)paren
r_continue
suffix:semicolon
id|ret
op_assign
id|hub_port_status
c_func
(paren
id|hdev
comma
id|i
comma
op_amp
id|portstatus
comma
op_amp
id|portchange
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|portchange
op_amp
id|USB_PORT_STAT_C_CONNECTION
)paren
(brace
id|clear_port_feature
c_func
(paren
id|hdev
comma
id|i
op_plus
l_int|1
comma
id|USB_PORT_FEAT_C_CONNECTION
)paren
suffix:semicolon
id|connect_change
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|portchange
op_amp
id|USB_PORT_STAT_C_ENABLE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|connect_change
)paren
id|dev_dbg
(paren
id|hub_dev
comma
l_string|&quot;port %d enable change, &quot;
l_string|&quot;status %08x&bslash;n&quot;
comma
id|i
op_plus
l_int|1
comma
id|portstatus
)paren
suffix:semicolon
id|clear_port_feature
c_func
(paren
id|hdev
comma
id|i
op_plus
l_int|1
comma
id|USB_PORT_FEAT_C_ENABLE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * EM interference sometimes causes badly&n;&t;&t;&t;&t; * shielded USB devices to be shutdown by&n;&t;&t;&t;&t; * the hub, this hack enables them again.&n;&t;&t;&t;&t; * Works at least with mouse driver. &n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|portstatus
op_amp
id|USB_PORT_STAT_ENABLE
)paren
op_logical_and
op_logical_neg
id|connect_change
op_logical_and
id|hdev-&gt;children
(braket
id|i
)braket
)paren
(brace
id|dev_err
(paren
id|hub_dev
comma
l_string|&quot;port %i &quot;
l_string|&quot;disabled by hub (EMI?), &quot;
l_string|&quot;re-enabling...&bslash;n&quot;
comma
id|i
op_plus
l_int|1
)paren
suffix:semicolon
id|connect_change
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|portchange
op_amp
id|USB_PORT_STAT_C_SUSPEND
)paren
(brace
id|clear_port_feature
c_func
(paren
id|hdev
comma
id|i
op_plus
l_int|1
comma
id|USB_PORT_FEAT_C_SUSPEND
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hdev-&gt;children
(braket
id|i
)braket
)paren
id|ret
op_assign
id|remote_wakeup
c_func
(paren
id|hdev-&gt;children
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|dev_dbg
(paren
id|hub_dev
comma
l_string|&quot;resume on port %d, status %d&bslash;n&quot;
comma
id|i
op_plus
l_int|1
comma
id|ret
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
id|ret
op_assign
id|hub_port_disable
c_func
(paren
id|hdev
comma
id|i
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|portchange
op_amp
id|USB_PORT_STAT_C_OVERCURRENT
)paren
(brace
id|dev_err
(paren
id|hub_dev
comma
l_string|&quot;over-current change on port %d&bslash;n&quot;
comma
id|i
op_plus
l_int|1
)paren
suffix:semicolon
id|clear_port_feature
c_func
(paren
id|hdev
comma
id|i
op_plus
l_int|1
comma
id|USB_PORT_FEAT_C_OVER_CURRENT
)paren
suffix:semicolon
id|hub_power_on
c_func
(paren
id|hub
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|portchange
op_amp
id|USB_PORT_STAT_C_RESET
)paren
(brace
id|dev_dbg
(paren
id|hub_dev
comma
l_string|&quot;reset change on port %d&bslash;n&quot;
comma
id|i
op_plus
l_int|1
)paren
suffix:semicolon
id|clear_port_feature
c_func
(paren
id|hdev
comma
id|i
op_plus
l_int|1
comma
id|USB_PORT_FEAT_C_RESET
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|connect_change
)paren
id|hub_port_connect_change
c_func
(paren
id|hub
comma
id|i
comma
id|portstatus
comma
id|portchange
)paren
suffix:semicolon
)brace
multiline_comment|/* end for i */
multiline_comment|/* deal with hub status changes */
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
l_int|0
comma
id|hub-&gt;event_bits
)paren
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/* do nothing */
r_else
r_if
c_cond
(paren
id|hub_hub_status
c_func
(paren
id|hub
comma
op_amp
id|hubstatus
comma
op_amp
id|hubchange
)paren
OL
l_int|0
)paren
id|dev_err
(paren
id|hub_dev
comma
l_string|&quot;get_hub_status failed&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|hubchange
op_amp
id|HUB_CHANGE_LOCAL_POWER
)paren
(brace
id|dev_dbg
(paren
id|hub_dev
comma
l_string|&quot;power change&bslash;n&quot;
)paren
suffix:semicolon
id|clear_hub_feature
c_func
(paren
id|hdev
comma
id|C_HUB_LOCAL_POWER
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hubchange
op_amp
id|HUB_CHANGE_OVERCURRENT
)paren
(brace
id|dev_dbg
(paren
id|hub_dev
comma
l_string|&quot;overcurrent change&bslash;n&quot;
)paren
suffix:semicolon
id|msleep
c_func
(paren
l_int|500
)paren
suffix:semicolon
multiline_comment|/* Cool down */
id|clear_hub_feature
c_func
(paren
id|hdev
comma
id|C_HUB_OVER_CURRENT
)paren
suffix:semicolon
id|hub_power_on
c_func
(paren
id|hub
)paren
suffix:semicolon
)brace
)brace
id|loop
suffix:colon
id|up
c_func
(paren
op_amp
id|hdev-&gt;serialize
)paren
suffix:semicolon
id|usb_put_dev
c_func
(paren
id|hdev
)paren
suffix:semicolon
)brace
multiline_comment|/* end while (1) */
)brace
DECL|function|hub_thread
r_static
r_int
id|hub_thread
c_func
(paren
r_void
op_star
id|__unused
)paren
(brace
multiline_comment|/*&n;&t; * This thread doesn&squot;t need any user-level access,&n;&t; * so get rid of all our resources&n;&t; */
id|daemonize
c_func
(paren
l_string|&quot;khubd&quot;
)paren
suffix:semicolon
id|allow_signal
c_func
(paren
id|SIGKILL
)paren
suffix:semicolon
multiline_comment|/* Send me a signal to get me die (for debugging) */
r_do
(brace
id|hub_events
c_func
(paren
)paren
suffix:semicolon
id|wait_event_interruptible
c_func
(paren
id|khubd_wait
comma
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|hub_event_list
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;flags
op_amp
id|PF_FREEZE
)paren
id|refrigerator
c_func
(paren
id|PF_FREEZE
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|signal_pending
c_func
(paren
id|current
)paren
)paren
suffix:semicolon
id|pr_debug
(paren
l_string|&quot;%s: khubd exiting&bslash;n&quot;
comma
id|usbcore_name
)paren
suffix:semicolon
id|complete_and_exit
c_func
(paren
op_amp
id|khubd_exited
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|variable|hub_id_table
r_static
r_struct
id|usb_device_id
id|hub_id_table
(braket
)braket
op_assign
(brace
(brace
dot
id|match_flags
op_assign
id|USB_DEVICE_ID_MATCH_DEV_CLASS
comma
dot
id|bDeviceClass
op_assign
id|USB_CLASS_HUB
)brace
comma
(brace
dot
id|match_flags
op_assign
id|USB_DEVICE_ID_MATCH_INT_CLASS
comma
dot
id|bInterfaceClass
op_assign
id|USB_CLASS_HUB
)brace
comma
(brace
)brace
multiline_comment|/* Terminating entry */
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
(paren
id|usb
comma
id|hub_id_table
)paren
suffix:semicolon
DECL|variable|hub_driver
r_static
r_struct
id|usb_driver
id|hub_driver
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|name
op_assign
l_string|&quot;hub&quot;
comma
dot
id|probe
op_assign
id|hub_probe
comma
dot
id|disconnect
op_assign
id|hub_disconnect
comma
dot
id|suspend
op_assign
id|hub_suspend
comma
dot
id|resume
op_assign
id|hub_resume
comma
dot
id|ioctl
op_assign
id|hub_ioctl
comma
dot
id|id_table
op_assign
id|hub_id_table
comma
)brace
suffix:semicolon
DECL|function|usb_hub_init
r_int
id|usb_hub_init
c_func
(paren
r_void
)paren
(brace
id|pid_t
id|pid
suffix:semicolon
r_if
c_cond
(paren
id|usb_register
c_func
(paren
op_amp
id|hub_driver
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: can&squot;t register hub driver&bslash;n&quot;
comma
id|usbcore_name
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|pid
op_assign
id|kernel_thread
c_func
(paren
id|hub_thread
comma
l_int|NULL
comma
id|CLONE_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pid
op_ge
l_int|0
)paren
(brace
id|khubd_pid
op_assign
id|pid
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Fall through if kernel_thread failed */
id|usb_deregister
c_func
(paren
op_amp
id|hub_driver
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: can&squot;t start khubd&bslash;n&quot;
comma
id|usbcore_name
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|usb_hub_cleanup
r_void
id|usb_hub_cleanup
c_func
(paren
r_void
)paren
(brace
r_int
id|ret
suffix:semicolon
multiline_comment|/* Kill the thread */
id|ret
op_assign
id|kill_proc
c_func
(paren
id|khubd_pid
comma
id|SIGKILL
comma
l_int|1
)paren
suffix:semicolon
id|wait_for_completion
c_func
(paren
op_amp
id|khubd_exited
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Hub resources are freed for us by usb_deregister. It calls&n;&t; * usb_driver_purge on every device which in turn calls that&n;&t; * devices disconnect function if it is using this driver.&n;&t; * The hub_disconnect function takes care of releasing the&n;&t; * individual hub resources. -greg&n;&t; */
id|usb_deregister
c_func
(paren
op_amp
id|hub_driver
)paren
suffix:semicolon
)brace
multiline_comment|/* usb_hub_cleanup() */
DECL|function|config_descriptors_changed
r_static
r_int
id|config_descriptors_changed
c_func
(paren
r_struct
id|usb_device
op_star
id|udev
)paren
(brace
r_int
id|index
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_struct
id|usb_config_descriptor
op_star
id|buf
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|udev-&gt;descriptor.bNumConfigurations
suffix:semicolon
id|index
op_increment
)paren
(brace
r_if
c_cond
(paren
id|len
OL
id|udev-&gt;config
(braket
id|index
)braket
dot
id|desc.wTotalLength
)paren
id|len
op_assign
id|udev-&gt;config
(braket
id|index
)braket
dot
id|desc.wTotalLength
suffix:semicolon
)brace
id|buf
op_assign
id|kmalloc
(paren
id|len
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_eq
l_int|0
)paren
(brace
id|dev_err
c_func
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;no mem to re-read configs after reset&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* assume the worst */
r_return
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|udev-&gt;descriptor.bNumConfigurations
suffix:semicolon
id|index
op_increment
)paren
(brace
r_int
id|length
suffix:semicolon
r_int
id|old_length
op_assign
id|udev-&gt;config
(braket
id|index
)braket
dot
id|desc.wTotalLength
suffix:semicolon
id|length
op_assign
id|usb_get_descriptor
c_func
(paren
id|udev
comma
id|USB_DT_CONFIG
comma
id|index
comma
id|buf
comma
id|old_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|length
OL
id|old_length
)paren
(brace
id|dev_dbg
c_func
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;config index %d, error %d&bslash;n&quot;
comma
id|index
comma
id|length
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|memcmp
(paren
id|buf
comma
id|udev-&gt;rawdescriptors
(braket
id|index
)braket
comma
id|old_length
)paren
op_ne
l_int|0
)paren
(brace
id|dev_dbg
c_func
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;config index %d changed (#%d)&bslash;n&quot;
comma
id|index
comma
id|buf-&gt;bConfigurationValue
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|index
op_ne
id|udev-&gt;descriptor.bNumConfigurations
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_reset_device - perform a USB port reset to reinitialize a device&n; * @udev: device to reset (not in SUSPENDED or NOTATTACHED state)&n; *&n; * WARNING - don&squot;t reset any device unless drivers for all of its&n; * interfaces are expecting that reset!  Maybe some driver-&gt;reset()&n; * method should eventually help ensure sufficient cooperation.&n; *&n; * Do a port reset, reassign the device&squot;s address, and establish its&n; * former operating configuration.  If the reset fails, or the device&squot;s&n; * descriptors change from their values before the reset, or the original&n; * configuration and altsettings cannot be restored, a flag will be set&n; * telling khubd to pretend the device has been disconnected and then&n; * re-connected.  All drivers will be unbound, and the device will be&n; * re-enumerated and probed all over again.&n; *&n; * Returns 0 if the reset succeeded, -ENODEV if the device has been&n; * flagged for logical disconnection, or some other negative error code&n; * if the reset wasn&squot;t even attempted.&n; *&n; * The caller must own the device lock.  For example, it&squot;s safe to use&n; * this from a driver probe() routine after downloading new firmware.&n; */
DECL|function|__usb_reset_device
r_int
id|__usb_reset_device
c_func
(paren
r_struct
id|usb_device
op_star
id|udev
)paren
(brace
r_struct
id|usb_device
op_star
id|parent
op_assign
id|udev-&gt;parent
suffix:semicolon
r_struct
id|usb_device_descriptor
id|descriptor
op_assign
id|udev-&gt;descriptor
suffix:semicolon
r_int
id|i
comma
id|ret
comma
id|port
op_assign
op_minus
l_int|1
suffix:semicolon
r_struct
id|usb_hub
op_star
id|hub
suffix:semicolon
r_if
c_cond
(paren
id|udev-&gt;state
op_eq
id|USB_STATE_NOTATTACHED
op_logical_or
id|udev-&gt;state
op_eq
id|USB_STATE_SUSPENDED
)paren
(brace
id|dev_dbg
c_func
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;device reset not allowed in state %d&bslash;n&quot;
comma
id|udev-&gt;state
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* FIXME: This should be legal for regular hubs.  Root hubs may&n;&t; * have special requirements. */
r_if
c_cond
(paren
id|udev-&gt;maxchild
)paren
(brace
multiline_comment|/* this requires hub- or hcd-specific logic;&n;&t;&t; * see hub_reset() and OHCI hc_restart()&n;&t;&t; */
id|dev_dbg
c_func
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;%s for hub!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
op_minus
id|EISDIR
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|parent-&gt;maxchild
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|parent-&gt;children
(braket
id|i
)braket
op_eq
id|udev
)paren
(brace
id|port
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|port
OL
l_int|0
)paren
(brace
multiline_comment|/* If this ever happens, it&squot;s very bad */
id|dev_err
c_func
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;Can&squot;t locate device&squot;s port!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
id|ret
op_assign
id|hub_port_init
c_func
(paren
id|parent
comma
id|udev
comma
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|re_enumerate
suffix:semicolon
multiline_comment|/* Device might have changed firmware (DFU or similar) */
r_if
c_cond
(paren
id|memcmp
c_func
(paren
op_amp
id|udev-&gt;descriptor
comma
op_amp
id|descriptor
comma
r_sizeof
id|descriptor
)paren
op_logical_or
id|config_descriptors_changed
(paren
id|udev
)paren
)paren
(brace
id|dev_info
c_func
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;device firmware changed&bslash;n&quot;
)paren
suffix:semicolon
id|udev-&gt;descriptor
op_assign
id|descriptor
suffix:semicolon
multiline_comment|/* for disconnect() calls */
r_goto
id|re_enumerate
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|udev-&gt;actconfig
)paren
r_return
l_int|0
suffix:semicolon
id|ret
op_assign
id|usb_control_msg
c_func
(paren
id|udev
comma
id|usb_sndctrlpipe
c_func
(paren
id|udev
comma
l_int|0
)paren
comma
id|USB_REQ_SET_CONFIGURATION
comma
l_int|0
comma
id|udev-&gt;actconfig-&gt;desc.bConfigurationValue
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
op_star
id|USB_CTRL_SET_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|dev_err
c_func
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;can&squot;t restore configuration #%d (error=%d)&bslash;n&quot;
comma
id|udev-&gt;actconfig-&gt;desc.bConfigurationValue
comma
id|ret
)paren
suffix:semicolon
r_goto
id|re_enumerate
suffix:semicolon
)brace
id|usb_set_device_state
c_func
(paren
id|udev
comma
id|USB_STATE_CONFIGURED
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|udev-&gt;actconfig-&gt;desc.bNumInterfaces
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|usb_interface
op_star
id|intf
op_assign
id|udev-&gt;actconfig-&gt;interface
(braket
id|i
)braket
suffix:semicolon
r_struct
id|usb_interface_descriptor
op_star
id|desc
suffix:semicolon
multiline_comment|/* set_interface resets host side toggle even&n;&t;&t; * for altsetting zero.  the interface may have no driver.&n;&t;&t; */
id|desc
op_assign
op_amp
id|intf-&gt;cur_altsetting-&gt;desc
suffix:semicolon
id|ret
op_assign
id|usb_set_interface
c_func
(paren
id|udev
comma
id|desc-&gt;bInterfaceNumber
comma
id|desc-&gt;bAlternateSetting
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|dev_err
c_func
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;failed to restore interface %d &quot;
l_string|&quot;altsetting %d (error=%d)&bslash;n&quot;
comma
id|desc-&gt;bInterfaceNumber
comma
id|desc-&gt;bAlternateSetting
comma
id|ret
)paren
suffix:semicolon
r_goto
id|re_enumerate
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
id|re_enumerate
suffix:colon
id|hub_port_disable
c_func
(paren
id|parent
comma
id|port
)paren
suffix:semicolon
id|hub
op_assign
id|usb_get_intfdata
c_func
(paren
id|parent-&gt;actconfig-&gt;interface
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|port
comma
id|hub-&gt;change_bits
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|hub_event_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|hub-&gt;event_list
)paren
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
id|hub-&gt;event_list
comma
op_amp
id|hub_event_list
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|khubd_wait
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|hub_event_lock
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|variable|__usb_reset_device
id|EXPORT_SYMBOL
c_func
(paren
id|__usb_reset_device
)paren
suffix:semicolon
DECL|function|usb_reset_device
r_int
id|usb_reset_device
c_func
(paren
r_struct
id|usb_device
op_star
id|udev
)paren
(brace
r_int
id|r
suffix:semicolon
id|down
c_func
(paren
op_amp
id|udev-&gt;serialize
)paren
suffix:semicolon
id|r
op_assign
id|__usb_reset_device
c_func
(paren
id|udev
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|udev-&gt;serialize
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
eof
