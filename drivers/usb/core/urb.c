macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#ifdef CONFIG_USB_DEBUG
DECL|macro|DEBUG
mdefine_line|#define DEBUG
macro_line|#else
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#endif
macro_line|#include &lt;linux/usb.h&gt;
macro_line|#include &quot;hcd.h&quot;
multiline_comment|/**&n; * usb_alloc_urb - creates a new urb for a USB driver to use&n; * @iso_packets: number of iso packets for this urb&n; * @mem_flags: the type of memory to allocate, see kmalloc() for a list of&n; *&t;valid options for this.&n; *&n; * Creates an urb for the USB driver to use, initializes a few internal&n; * structures, incrementes the usage counter, and returns a pointer to it.&n; *&n; * If no memory is available, NULL is returned.&n; *&n; * If the driver want to use this urb for interrupt, control, or bulk&n; * endpoints, pass &squot;0&squot; as the number of iso packets.&n; *&n; * The driver must call usb_free_urb() when it is finished with the urb.&n; */
DECL|function|usb_alloc_urb
r_struct
id|urb
op_star
id|usb_alloc_urb
c_func
(paren
r_int
id|iso_packets
comma
r_int
id|mem_flags
)paren
(brace
r_struct
id|urb
op_star
id|urb
suffix:semicolon
id|urb
op_assign
(paren
r_struct
id|urb
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|urb
)paren
op_plus
id|iso_packets
op_star
r_sizeof
(paren
r_struct
id|usb_iso_packet_descriptor
)paren
comma
id|mem_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
(brace
id|err
c_func
(paren
l_string|&quot;alloc_urb: kmalloc failed&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|urb
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|urb
)paren
)paren
suffix:semicolon
id|urb-&gt;count
op_assign
(paren
id|atomic_t
)paren
id|ATOMIC_INIT
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|urb-&gt;lock
)paren
suffix:semicolon
r_return
id|urb
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_free_urb - frees the memory used by a urb when all users of it are finished&n; * @urb: pointer to the urb to free&n; *&n; * Must be called when a user of a urb is finished with it.  When the last user&n; * of the urb calls this function, the memory of the urb is freed.&n; *&n; * Note: The transfer buffer associated with the urb is not freed, that must be&n; * done elsewhere.&n; */
DECL|function|usb_free_urb
r_void
id|usb_free_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_if
c_cond
(paren
id|urb
)paren
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|urb-&gt;count
)paren
)paren
id|kfree
c_func
(paren
id|urb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_get_urb - increments the reference count of the urb&n; * @urb: pointer to the urb to modify&n; *&n; * This must be  called whenever a urb is transfered from a device driver to a&n; * host controller driver.  This allows proper reference counting to happen&n; * for urbs.&n; *&n; * A pointer to the urb with the incremented reference counter is returned.&n; */
DECL|function|usb_get_urb
r_struct
id|urb
op_star
id|usb_get_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_if
c_cond
(paren
id|urb
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|urb-&gt;count
)paren
suffix:semicolon
r_return
id|urb
suffix:semicolon
)brace
r_else
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------*/
multiline_comment|/**&n; * usb_submit_urb - asynchronously issue a transfer request for an endpoint&n; * @urb: pointer to the urb describing the request&n; * @mem_flags: the type of memory to allocate, see kmalloc() for a list&n; *&t;of valid options for this.&n; *&n; * This submits a transfer request, and transfers control of the URB&n; * describing that request to the USB subsystem.  Request completion will&n; * indicated later, asynchronously, by calling the completion handler.&n; * This call may be issued in interrupt context.&n; *&n; * The caller must have correctly initialized the URB before submitting&n; * it.  Functions such as usb_fill_bulk_urb() and usb_fill_control_urb() are&n; * available to ensure that most fields are correctly initialized, for&n; * the particular kind of transfer, although they will not initialize&n; * any transfer flags.&n; *&n; * Successful submissions return 0; otherwise this routine returns a&n; * negative error number.  If the submission is successful, the complete&n; * fuction of the urb will be called when the USB host driver is&n; * finished with the urb (either a successful transmission, or some&n; * error case.)&n; *&n; * Unreserved Bandwidth Transfers:&n; *&n; * Bulk or control requests complete only once.  When the completion&n; * function is called, control of the URB is returned to the device&n; * driver which issued the request.  The completion handler may then&n; * immediately free or reuse that URB.&n; *&n; * Bulk URBs will be queued if the USB_QUEUE_BULK transfer flag is set&n; * in the URB.  This can be used to maximize bandwidth utilization by&n; * letting the USB controller start work on the next URB without any&n; * delay to report completion (scheduling and processing an interrupt)&n; * and then submit that next request.&n; *&n; * For control endpoints, the synchronous usb_control_msg() call is&n; * often used (in non-interrupt context) instead of this call.&n; *&n; * Reserved Bandwidth Transfers:&n; *&n; * Periodic URBs (interrupt or isochronous) are completed repeatedly,&n; * until the original request is aborted.  When the completion callback&n; * indicates the URB has been unlinked (with a special status code),&n; * control of that URB returns to the device driver.  Otherwise, the&n; * completion handler does not control the URB, and should not change&n; * any of its fields.&n; *&n; * Note that isochronous URBs should be submitted in a &quot;ring&quot; data&n; * structure (using urb-&gt;next) to ensure that they are resubmitted&n; * appropriately.&n; *&n; * If the USB subsystem can&squot;t reserve sufficient bandwidth to perform&n; * the periodic request, and bandwidth reservation is being done for&n; * this controller, submitting such a periodic request will fail.&n; *&n; * Memory Flags:&n; *&n; * General rules for how to decide which mem_flags to use:&n; * &n; * Basically the rules are the same as for kmalloc.  There are four&n; * different possible values; GFP_KERNEL, GFP_NOFS, GFP_NOIO and&n; * GFP_ATOMIC.&n; *&n; * GFP_NOFS is not ever used, as it has not been implemented yet.&n; *&n; * There are three situations you must use GFP_ATOMIC.&n; *    a) you are inside a completion handler, an interrupt, bottom half,&n; *       tasklet or timer.&n; *    b) you are holding a spinlock or rwlock (does not apply to&n; *       semaphores)&n; *    c) current-&gt;state != TASK_RUNNING, this is the case only after&n; *       you&squot;ve changed it.&n; * &n; * GFP_NOIO is used in the block io path and error handling of storage&n; * devices.&n; *&n; * All other situations use GFP_KERNEL.&n; *&n; * Specfic rules for how to decide which mem_flags to use:&n; *&n; *    - start_xmit, timeout, and receive methods of network drivers must&n; *      use GFP_ATOMIC (spinlock)&n; *    - queuecommand methods of scsi drivers must use GFP_ATOMIC (spinlock)&n; *    - If you use a kernel thread with a network driver you must use&n; *      GFP_NOIO, unless b) or c) apply&n; *    - After you have done a down() you use GFP_KERNEL, unless b) or c)&n; *      apply or your are in a storage driver&squot;s block io path&n; *    - probe and disconnect use GFP_KERNEL unless b) or c) apply&n; *    - Changing firmware on a running storage or net device uses&n; *      GFP_NOIO, unless b) or c) apply&n; *&n; */
DECL|function|usb_submit_urb
r_int
id|usb_submit_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|mem_flags
)paren
(brace
r_if
c_cond
(paren
id|urb
op_logical_and
id|urb-&gt;dev
op_logical_and
id|urb-&gt;dev-&gt;bus
op_logical_and
id|urb-&gt;dev-&gt;bus-&gt;op
)paren
(brace
r_if
c_cond
(paren
id|usb_maxpacket
c_func
(paren
id|urb-&gt;dev
comma
id|urb-&gt;pipe
comma
id|usb_pipeout
c_func
(paren
id|urb-&gt;pipe
)paren
)paren
op_le
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: pipe %x has invalid size (&lt;= 0)&quot;
comma
id|__FUNCTION__
comma
id|urb-&gt;pipe
)paren
suffix:semicolon
r_return
op_minus
id|EMSGSIZE
suffix:semicolon
)brace
r_return
id|urb-&gt;dev-&gt;bus-&gt;op
op_member_access_from_pointer
id|submit_urb
c_func
(paren
id|urb
comma
id|mem_flags
)paren
suffix:semicolon
)brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------*/
multiline_comment|/**&n; * usb_unlink_urb - abort/cancel a transfer request for an endpoint&n; * @urb: pointer to urb describing a previously submitted request&n; *&n; * This routine cancels an in-progress request.  The requests&squot;s&n; * completion handler will be called with a status code indicating&n; * that the request has been canceled, and that control of the URB&n; * has been returned to that device driver.  This is the only way&n; * to stop an interrupt transfer, so long as the device is connected.&n; *&n; * When the USB_ASYNC_UNLINK transfer flag for the URB is clear, this&n; * request is synchronous.  Success is indicated by returning zero,&n; * at which time the urb will have been unlinked,&n; * and the completion function will see status -ENOENT.  Failure is&n; * indicated by any other return value.  This mode may not be used&n; * when unlinking an urb from an interrupt context, such as a bottom&n; * half or a completion handler,&n; *&n; * When the USB_ASYNC_UNLINK transfer flag for the URB is set, this&n; * request is asynchronous.  Success is indicated by returning -EINPROGRESS,&n; * at which time the urb will normally not have been unlinked,&n; * and the completion function will see status -ECONNRESET.  Failure is&n; * indicated by any other return value.&n; */
DECL|function|usb_unlink_urb
r_int
id|usb_unlink_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_if
c_cond
(paren
id|urb
op_logical_and
id|urb-&gt;dev
op_logical_and
id|urb-&gt;dev-&gt;bus
op_logical_and
id|urb-&gt;dev-&gt;bus-&gt;op
)paren
r_return
id|urb-&gt;dev-&gt;bus-&gt;op
op_member_access_from_pointer
id|unlink_urb
c_func
(paren
id|urb
)paren
suffix:semicolon
r_else
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
singleline_comment|// asynchronous request completion model
DECL|variable|usb_alloc_urb
id|EXPORT_SYMBOL
c_func
(paren
id|usb_alloc_urb
)paren
suffix:semicolon
DECL|variable|usb_free_urb
id|EXPORT_SYMBOL
c_func
(paren
id|usb_free_urb
)paren
suffix:semicolon
DECL|variable|usb_get_urb
id|EXPORT_SYMBOL
c_func
(paren
id|usb_get_urb
)paren
suffix:semicolon
DECL|variable|usb_submit_urb
id|EXPORT_SYMBOL
c_func
(paren
id|usb_submit_urb
)paren
suffix:semicolon
DECL|variable|usb_unlink_urb
id|EXPORT_SYMBOL
c_func
(paren
id|usb_unlink_urb
)paren
suffix:semicolon
eof
