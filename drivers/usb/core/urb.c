macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#ifdef CONFIG_USB_DEBUG
DECL|macro|DEBUG
mdefine_line|#define DEBUG
macro_line|#else
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#endif
macro_line|#include &lt;linux/usb.h&gt;
macro_line|#include &quot;hcd.h&quot;
DECL|macro|to_urb
mdefine_line|#define to_urb(d) container_of(d, struct urb, kref)
DECL|function|urb_destroy
r_static
r_void
id|urb_destroy
c_func
(paren
r_struct
id|kref
op_star
id|kref
)paren
(brace
r_struct
id|urb
op_star
id|urb
op_assign
id|to_urb
c_func
(paren
id|kref
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|urb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_init_urb - initializes a urb so that it can be used by a USB driver&n; * @urb: pointer to the urb to initialize&n; *&n; * Initializes a urb so that the USB subsystem can use it properly.&n; *&n; * If a urb is created with a call to usb_alloc_urb() it is not&n; * necessary to call this function.  Only use this if you allocate the&n; * space for a struct urb on your own.  If you call this function, be&n; * careful when freeing the memory for your urb that it is no longer in&n; * use by the USB core.&n; *&n; * Only use this function if you _really_ understand what you are doing.&n; */
DECL|function|usb_init_urb
r_void
id|usb_init_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_if
c_cond
(paren
id|urb
)paren
(brace
id|memset
c_func
(paren
id|urb
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|urb
)paren
)paren
suffix:semicolon
id|kref_init
c_func
(paren
op_amp
id|urb-&gt;kref
comma
id|urb_destroy
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|urb-&gt;lock
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * usb_alloc_urb - creates a new urb for a USB driver to use&n; * @iso_packets: number of iso packets for this urb&n; * @mem_flags: the type of memory to allocate, see kmalloc() for a list of&n; *&t;valid options for this.&n; *&n; * Creates an urb for the USB driver to use, initializes a few internal&n; * structures, incrementes the usage counter, and returns a pointer to it.&n; *&n; * If no memory is available, NULL is returned.&n; *&n; * If the driver want to use this urb for interrupt, control, or bulk&n; * endpoints, pass &squot;0&squot; as the number of iso packets.&n; *&n; * The driver must call usb_free_urb() when it is finished with the urb.&n; */
DECL|function|usb_alloc_urb
r_struct
id|urb
op_star
id|usb_alloc_urb
c_func
(paren
r_int
id|iso_packets
comma
r_int
id|mem_flags
)paren
(brace
r_struct
id|urb
op_star
id|urb
suffix:semicolon
id|urb
op_assign
(paren
r_struct
id|urb
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|urb
)paren
op_plus
id|iso_packets
op_star
r_sizeof
(paren
r_struct
id|usb_iso_packet_descriptor
)paren
comma
id|mem_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
(brace
id|err
c_func
(paren
l_string|&quot;alloc_urb: kmalloc failed&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|usb_init_urb
c_func
(paren
id|urb
)paren
suffix:semicolon
r_return
id|urb
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_free_urb - frees the memory used by a urb when all users of it are finished&n; * @urb: pointer to the urb to free, may be NULL&n; *&n; * Must be called when a user of a urb is finished with it.  When the last user&n; * of the urb calls this function, the memory of the urb is freed.&n; *&n; * Note: The transfer buffer associated with the urb is not freed, that must be&n; * done elsewhere.&n; */
DECL|function|usb_free_urb
r_void
id|usb_free_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_if
c_cond
(paren
id|urb
)paren
id|kref_put
c_func
(paren
op_amp
id|urb-&gt;kref
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_get_urb - increments the reference count of the urb&n; * @urb: pointer to the urb to modify, may be NULL&n; *&n; * This must be  called whenever a urb is transferred from a device driver to a&n; * host controller driver.  This allows proper reference counting to happen&n; * for urbs.&n; *&n; * A pointer to the urb with the incremented reference counter is returned.&n; */
DECL|function|usb_get_urb
r_struct
id|urb
op_star
id|usb_get_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_if
c_cond
(paren
id|urb
)paren
id|kref_get
c_func
(paren
op_amp
id|urb-&gt;kref
)paren
suffix:semicolon
r_return
id|urb
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------*/
multiline_comment|/**&n; * usb_submit_urb - issue an asynchronous transfer request for an endpoint&n; * @urb: pointer to the urb describing the request&n; * @mem_flags: the type of memory to allocate, see kmalloc() for a list&n; *&t;of valid options for this.&n; *&n; * This submits a transfer request, and transfers control of the URB&n; * describing that request to the USB subsystem.  Request completion will&n; * be indicated later, asynchronously, by calling the completion handler.&n; * The three types of completion are success, error, and unlink&n; * (a software-induced fault, also called &quot;request cancelation&quot;).  &n; *&n; * URBs may be submitted in interrupt context.&n; *&n; * The caller must have correctly initialized the URB before submitting&n; * it.  Functions such as usb_fill_bulk_urb() and usb_fill_control_urb() are&n; * available to ensure that most fields are correctly initialized, for&n; * the particular kind of transfer, although they will not initialize&n; * any transfer flags.&n; *&n; * Successful submissions return 0; otherwise this routine returns a&n; * negative error number.  If the submission is successful, the complete()&n; * callback from the URB will be called exactly once, when the USB core and&n; * Host Controller Driver (HCD) are finished with the URB.  When the completion&n; * function is called, control of the URB is returned to the device&n; * driver which issued the request.  The completion handler may then&n; * immediately free or reuse that URB.&n; *&n; * With few exceptions, USB device drivers should never access URB fields&n; * provided by usbcore or the HCD until its complete() is called.&n; * The exceptions relate to periodic transfer scheduling.  For both&n; * interrupt and isochronous urbs, as part of successful URB submission&n; * urb-&gt;interval is modified to reflect the actual transfer period used&n; * (normally some power of two units).  And for isochronous urbs,&n; * urb-&gt;start_frame is modified to reflect when the URB&squot;s transfers were&n; * scheduled to start.  Not all isochronous transfer scheduling policies&n; * will work, but most host controller drivers should easily handle ISO&n; * queues going from now until 10-200 msec into the future.&n; *&n; * For control endpoints, the synchronous usb_control_msg() call is&n; * often used (in non-interrupt context) instead of this call.&n; * That is often used through convenience wrappers, for the requests&n; * that are standardized in the USB 2.0 specification.  For bulk&n; * endpoints, a synchronous usb_bulk_msg() call is available.&n; *&n; * Request Queuing:&n; *&n; * URBs may be submitted to endpoints before previous ones complete, to&n; * minimize the impact of interrupt latencies and system overhead on data&n; * throughput.  With that queuing policy, an endpoint&squot;s queue would never&n; * be empty.  This is required for continuous isochronous data streams,&n; * and may also be required for some kinds of interrupt transfers. Such&n; * queuing also maximizes bandwidth utilization by letting USB controllers&n; * start work on later requests before driver software has finished the&n; * completion processing for earlier (successful) requests.&n; *&n; * As of Linux 2.6, all USB endpoint transfer queues support depths greater&n; * than one.  This was previously a HCD-specific behavior, except for ISO&n; * transfers.  Non-isochronous endpoint queues are inactive during cleanup&n; * after faults (transfer errors or cancelation).&n; *&n; * Reserved Bandwidth Transfers:&n; *&n; * Periodic transfers (interrupt or isochronous) are performed repeatedly,&n; * using the interval specified in the urb.  Submitting the first urb to&n; * the endpoint reserves the bandwidth necessary to make those transfers.&n; * If the USB subsystem can&squot;t allocate sufficient bandwidth to perform&n; * the periodic request, submitting such a periodic request should fail.&n; *&n; * Device drivers must explicitly request that repetition, by ensuring that&n; * some URB is always on the endpoint&squot;s queue (except possibly for short&n; * periods during completion callacks).  When there is no longer an urb&n; * queued, the endpoint&squot;s bandwidth reservation is canceled.  This means&n; * drivers can use their completion handlers to ensure they keep bandwidth&n; * they need, by reinitializing and resubmitting the just-completed urb&n; * until the driver longer needs that periodic bandwidth.&n; *&n; * Memory Flags:&n; *&n; * The general rules for how to decide which mem_flags to use&n; * are the same as for kmalloc.  There are four&n; * different possible values; GFP_KERNEL, GFP_NOFS, GFP_NOIO and&n; * GFP_ATOMIC.&n; *&n; * GFP_NOFS is not ever used, as it has not been implemented yet.&n; *&n; * GFP_ATOMIC is used when&n; *   (a) you are inside a completion handler, an interrupt, bottom half,&n; *       tasklet or timer, or&n; *   (b) you are holding a spinlock or rwlock (does not apply to&n; *       semaphores), or&n; *   (c) current-&gt;state != TASK_RUNNING, this is the case only after&n; *       you&squot;ve changed it.&n; * &n; * GFP_NOIO is used in the block io path and error handling of storage&n; * devices.&n; *&n; * All other situations use GFP_KERNEL.&n; *&n; * Some more specific rules for mem_flags can be inferred, such as&n; *  (1) start_xmit, timeout, and receive methods of network drivers must&n; *      use GFP_ATOMIC (they are called with a spinlock held);&n; *  (2) queuecommand methods of scsi drivers must use GFP_ATOMIC (also&n; *      called with a spinlock held);&n; *  (3) If you use a kernel thread with a network driver you must use&n; *      GFP_NOIO, unless (b) or (c) apply;&n; *  (4) after you have done a down() you can use GFP_KERNEL, unless (b) or (c)&n; *      apply or your are in a storage driver&squot;s block io path;&n; *  (5) USB probe and disconnect can use GFP_KERNEL unless (b) or (c) apply; and&n; *  (6) changing firmware on a running storage or net device uses&n; *      GFP_NOIO, unless b) or c) apply&n; *&n; */
DECL|function|usb_submit_urb
r_int
id|usb_submit_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|mem_flags
)paren
(brace
r_int
id|pipe
comma
id|temp
comma
id|max
suffix:semicolon
r_struct
id|usb_device
op_star
id|dev
suffix:semicolon
r_struct
id|usb_operations
op_star
id|op
suffix:semicolon
r_int
id|is_out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
op_logical_or
id|urb-&gt;hcpriv
op_logical_or
op_logical_neg
id|urb-&gt;complete
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev
op_assign
id|urb-&gt;dev
)paren
op_logical_or
(paren
id|dev-&gt;state
OL
id|USB_STATE_DEFAULT
)paren
op_logical_or
(paren
op_logical_neg
id|dev-&gt;bus
)paren
op_logical_or
(paren
id|dev-&gt;devnum
op_le
l_int|0
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;state
op_eq
id|USB_STATE_SUSPENDED
)paren
r_return
op_minus
id|EHOSTUNREACH
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|op
op_assign
id|dev-&gt;bus-&gt;op
)paren
op_logical_or
op_logical_neg
id|op-&gt;submit_urb
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|urb-&gt;status
op_assign
op_minus
id|EINPROGRESS
suffix:semicolon
id|urb-&gt;actual_length
op_assign
l_int|0
suffix:semicolon
id|urb-&gt;bandwidth
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Lots of sanity checks, so HCDs can rely on clean data&n;&t; * and don&squot;t need to duplicate tests&n;&t; */
id|pipe
op_assign
id|urb-&gt;pipe
suffix:semicolon
id|temp
op_assign
id|usb_pipetype
(paren
id|pipe
)paren
suffix:semicolon
id|is_out
op_assign
id|usb_pipeout
(paren
id|pipe
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|usb_pipecontrol
(paren
id|pipe
)paren
op_logical_and
id|dev-&gt;state
OL
id|USB_STATE_CONFIGURED
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* (actually HCDs may need to duplicate this, endpoint might yet&n;&t; * stall due to queued bulk/intr transactions that complete after&n;&t; * we check)&n;&t; */
r_if
c_cond
(paren
id|usb_endpoint_halted
(paren
id|dev
comma
id|usb_pipeendpoint
(paren
id|pipe
)paren
comma
id|is_out
)paren
)paren
r_return
op_minus
id|EPIPE
suffix:semicolon
multiline_comment|/* FIXME there should be a sharable lock protecting us against&n;&t; * config/altsetting changes and disconnects, kicking in here.&n;&t; * (here == before maxpacket, and eventually endpoint type,&n;&t; * checks get made.)&n;&t; */
id|max
op_assign
id|usb_maxpacket
(paren
id|dev
comma
id|pipe
comma
id|is_out
)paren
suffix:semicolon
r_if
c_cond
(paren
id|max
op_le
l_int|0
)paren
(brace
id|dbg
(paren
l_string|&quot;%s: bogus endpoint %d-%s on usb-%s-%s (bad maxpacket %d)&quot;
comma
id|__FUNCTION__
comma
id|usb_pipeendpoint
(paren
id|pipe
)paren
comma
id|is_out
ques
c_cond
l_string|&quot;OUT&quot;
suffix:colon
l_string|&quot;IN&quot;
comma
id|dev-&gt;bus-&gt;bus_name
comma
id|dev-&gt;devpath
comma
id|max
)paren
suffix:semicolon
r_return
op_minus
id|EMSGSIZE
suffix:semicolon
)brace
multiline_comment|/* periodic transfers limit size per frame/uframe,&n;&t; * but drivers only control those sizes for ISO.&n;&t; * while we&squot;re checking, initialize return status.&n;&t; */
r_if
c_cond
(paren
id|temp
op_eq
id|PIPE_ISOCHRONOUS
)paren
(brace
r_int
id|n
comma
id|len
suffix:semicolon
multiline_comment|/* &quot;high bandwidth&quot; mode, 1-3 packets/uframe? */
r_if
c_cond
(paren
id|dev-&gt;speed
op_eq
id|USB_SPEED_HIGH
)paren
(brace
r_int
id|mult
op_assign
l_int|1
op_plus
(paren
(paren
id|max
op_rshift
l_int|11
)paren
op_amp
l_int|0x03
)paren
suffix:semicolon
id|max
op_and_assign
l_int|0x07ff
suffix:semicolon
id|max
op_mul_assign
id|mult
suffix:semicolon
)brace
r_if
c_cond
(paren
id|urb-&gt;number_of_packets
op_le
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|urb-&gt;number_of_packets
suffix:semicolon
id|n
op_increment
)paren
(brace
id|len
op_assign
id|urb-&gt;iso_frame_desc
(braket
id|n
)braket
dot
id|length
suffix:semicolon
r_if
c_cond
(paren
id|len
template_param
id|max
)paren
r_return
op_minus
id|EMSGSIZE
suffix:semicolon
id|urb-&gt;iso_frame_desc
(braket
id|n
)braket
dot
id|status
op_assign
op_minus
id|EXDEV
suffix:semicolon
id|urb-&gt;iso_frame_desc
(braket
id|n
)braket
dot
id|actual_length
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* the I/O buffer must be mapped/unmapped, except when length=0 */
r_if
c_cond
(paren
id|urb-&gt;transfer_buffer_length
OL
l_int|0
)paren
r_return
op_minus
id|EMSGSIZE
suffix:semicolon
macro_line|#ifdef DEBUG
multiline_comment|/* stuff that drivers shouldn&squot;t do, but which shouldn&squot;t&n;&t; * cause problems in HCDs if they get it wrong.&n;&t; */
(brace
r_int
r_int
id|orig_flags
op_assign
id|urb-&gt;transfer_flags
suffix:semicolon
r_int
r_int
id|allowed
suffix:semicolon
multiline_comment|/* enforce simple/standard policy */
id|allowed
op_assign
id|URB_ASYNC_UNLINK
suffix:semicolon
singleline_comment|// affects later unlinks
id|allowed
op_or_assign
(paren
id|URB_NO_TRANSFER_DMA_MAP
op_or
id|URB_NO_SETUP_DMA_MAP
)paren
suffix:semicolon
id|allowed
op_or_assign
id|URB_NO_INTERRUPT
suffix:semicolon
r_switch
c_cond
(paren
id|temp
)paren
(brace
r_case
id|PIPE_BULK
suffix:colon
r_if
c_cond
(paren
id|is_out
)paren
id|allowed
op_or_assign
id|URB_ZERO_PACKET
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_case
id|PIPE_CONTROL
suffix:colon
id|allowed
op_or_assign
id|URB_NO_FSBR
suffix:semicolon
multiline_comment|/* only affects UHCI */
multiline_comment|/* FALLTHROUGH */
r_default
suffix:colon
(brace
)brace
multiline_comment|/* all non-iso endpoints */
r_if
c_cond
(paren
op_logical_neg
id|is_out
)paren
id|allowed
op_or_assign
id|URB_SHORT_NOT_OK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIPE_ISOCHRONOUS
suffix:colon
id|allowed
op_or_assign
id|URB_ISO_ASAP
suffix:semicolon
r_break
suffix:semicolon
)brace
id|urb-&gt;transfer_flags
op_and_assign
id|allowed
suffix:semicolon
multiline_comment|/* fail if submitter gave bogus flags */
r_if
c_cond
(paren
id|urb-&gt;transfer_flags
op_ne
id|orig_flags
)paren
(brace
id|err
(paren
l_string|&quot;BOGUS urb flags, %x --&gt; %x&quot;
comma
id|orig_flags
comma
id|urb-&gt;transfer_flags
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Force periodic transfer intervals to be legal values that are&n;&t; * a power of two (so HCDs don&squot;t need to).&n;&t; *&n;&t; * FIXME want bus-&gt;{intr,iso}_sched_horizon values here.  Each HC&n;&t; * supports different values... this uses EHCI/UHCI defaults (and&n;&t; * EHCI can use smaller non-default values).&n;&t; */
r_switch
c_cond
(paren
id|temp
)paren
(brace
r_case
id|PIPE_ISOCHRONOUS
suffix:colon
r_case
id|PIPE_INTERRUPT
suffix:colon
multiline_comment|/* too small? */
r_if
c_cond
(paren
id|urb-&gt;interval
op_le
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* too big? */
r_switch
c_cond
(paren
id|dev-&gt;speed
)paren
(brace
r_case
id|USB_SPEED_HIGH
suffix:colon
multiline_comment|/* units are microframes */
singleline_comment|// NOTE usb handles 2^15
r_if
c_cond
(paren
id|urb-&gt;interval
OG
(paren
l_int|1024
op_star
l_int|8
)paren
)paren
id|urb-&gt;interval
op_assign
l_int|1024
op_star
l_int|8
suffix:semicolon
id|temp
op_assign
l_int|1024
op_star
l_int|8
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_SPEED_FULL
suffix:colon
multiline_comment|/* units are frames/msec */
r_case
id|USB_SPEED_LOW
suffix:colon
r_if
c_cond
(paren
id|temp
op_eq
id|PIPE_INTERRUPT
)paren
(brace
r_if
c_cond
(paren
id|urb-&gt;interval
OG
l_int|255
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
singleline_comment|// NOTE ohci only handles up to 32
id|temp
op_assign
l_int|128
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|urb-&gt;interval
OG
l_int|1024
)paren
id|urb-&gt;interval
op_assign
l_int|1024
suffix:semicolon
singleline_comment|// NOTE usb and ohci handle up to 2^15
id|temp
op_assign
l_int|1024
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* power of two? */
r_while
c_loop
(paren
id|temp
OG
id|urb-&gt;interval
)paren
id|temp
op_rshift_assign
l_int|1
suffix:semicolon
id|urb-&gt;interval
op_assign
id|temp
suffix:semicolon
)brace
r_return
id|op-&gt;submit_urb
(paren
id|urb
comma
id|mem_flags
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------*/
multiline_comment|/**&n; * usb_unlink_urb - abort/cancel a transfer request for an endpoint&n; * @urb: pointer to urb describing a previously submitted request,&n; *&t;may be NULL&n; *&n; * This routine cancels an in-progress request.  URBs complete only&n; * once per submission, and may be canceled only once per submission.&n; * Successful cancelation means the requests&squot;s completion handler will&n; * be called with a status code indicating that the request has been&n; * canceled (rather than any other code) and will quickly be removed&n; * from host controller data structures.&n; *&n; * In the past, clearing the URB_ASYNC_UNLINK transfer flag for the&n; * URB indicated that the request was synchronous.  This usage is now&n; * deprecated; if the flag is clear the call will be forwarded to&n; * usb_kill_urb() and the return value will be 0.  In the future, drivers&n; * should call usb_kill_urb() directly for synchronous unlinking.&n; *&n; * When the URB_ASYNC_UNLINK transfer flag for the URB is set, this&n; * request is asynchronous.  Success is indicated by returning -EINPROGRESS,&n; * at which time the URB will normally have been unlinked but not yet&n; * given back to the device driver.  When it is called, the completion&n; * function will see urb-&gt;status == -ECONNRESET.  Failure is indicated&n; * by any other return value.  Unlinking will fail when the URB is not&n; * currently &quot;linked&quot; (i.e., it was never submitted, or it was unlinked&n; * before, or the hardware is already finished with it), even if the&n; * completion handler has not yet run.&n; *&n; * Unlinking and Endpoint Queues:&n; *&n; * Host Controller Drivers (HCDs) place all the URBs for a particular&n; * endpoint in a queue.  Normally the queue advances as the controller&n; * hardware processes each request.  But when an URB terminates with any&n; * fault (such as an error, or being unlinked) its queue stops, at least&n; * until that URB&squot;s completion routine returns.  It is guaranteed that&n; * the queue will not restart until all its unlinked URBs have been fully&n; * retired, with their completion routines run, even if that&squot;s not until&n; * some time after the original completion handler returns.&n; *&n; * This means that USB device drivers can safely build deep queues for&n; * large or complex transfers, and clean them up reliably after any sort&n; * of aborted transfer by unlinking all pending URBs at the first fault.&n; *&n; * Note that an URB terminating early because a short packet was received&n; * will count as an error if and only if the URB_SHORT_NOT_OK flag is set.&n; * Also, that all unlinks performed in any URB completion handler must&n; * be asynchronous.&n; *&n; * Queues for isochronous endpoints are treated differently, because they&n; * advance at fixed rates.  Such queues do not stop when an URB is unlinked.&n; * An unlinked URB may leave a gap in the stream of packets.  It is undefined&n; * whether such gaps can be filled in.&n; *&n; * When a control URB terminates with an error, it is likely that the&n; * status stage of the transfer will not take place, even if it is merely&n; * a soft error resulting from a short-packet with URB_SHORT_NOT_OK set.&n; */
DECL|function|usb_unlink_urb
r_int
id|usb_unlink_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|urb-&gt;transfer_flags
op_amp
id|URB_ASYNC_UNLINK
)paren
)paren
(brace
id|usb_kill_urb
c_func
(paren
id|urb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|urb-&gt;dev
op_logical_and
id|urb-&gt;dev-&gt;bus
op_logical_and
id|urb-&gt;dev-&gt;bus-&gt;op
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_return
id|urb-&gt;dev-&gt;bus-&gt;op
op_member_access_from_pointer
id|unlink_urb
c_func
(paren
id|urb
comma
op_minus
id|ECONNRESET
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_kill_urb - cancel a transfer request and wait for it to finish&n; * @urb: pointer to URB describing a previously submitted request,&n; *&t;may be NULL&n; *&n; * This routine cancels an in-progress request.  It is guaranteed that&n; * upon return all completion handlers will have finished and the URB&n; * will be totally idle and available for reuse.  These features make&n; * this an ideal way to stop I/O in a disconnect() callback or close()&n; * function.  If the request has not already finished or been unlinked&n; * the completion handler will see urb-&gt;status == -ENOENT.&n; *&n; * While the routine is running, attempts to resubmit the URB will fail&n; * with error -EPERM.  Thus even if the URB&squot;s completion handler always&n; * tries to resubmit, it will not succeed and the URB will become idle.&n; *&n; * This routine may not be used in an interrupt context (such as a bottom&n; * half or a completion handler), or when holding a spinlock, or in other&n; * situations where the caller can&squot;t schedule().&n; */
DECL|function|usb_kill_urb
r_void
id|usb_kill_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|urb
op_logical_and
id|urb-&gt;dev
op_logical_and
id|urb-&gt;dev-&gt;bus
op_logical_and
id|urb-&gt;dev-&gt;bus-&gt;op
)paren
)paren
r_return
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|urb-&gt;lock
)paren
suffix:semicolon
op_increment
id|urb-&gt;reject
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|urb-&gt;lock
)paren
suffix:semicolon
id|urb-&gt;dev-&gt;bus-&gt;op
op_member_access_from_pointer
id|unlink_urb
c_func
(paren
id|urb
comma
op_minus
id|ENOENT
)paren
suffix:semicolon
id|wait_event
c_func
(paren
id|usb_kill_urb_queue
comma
id|atomic_read
c_func
(paren
op_amp
id|urb-&gt;use_count
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|urb-&gt;lock
)paren
suffix:semicolon
op_decrement
id|urb-&gt;reject
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|urb-&gt;lock
)paren
suffix:semicolon
)brace
DECL|variable|usb_init_urb
id|EXPORT_SYMBOL
c_func
(paren
id|usb_init_urb
)paren
suffix:semicolon
DECL|variable|usb_alloc_urb
id|EXPORT_SYMBOL
c_func
(paren
id|usb_alloc_urb
)paren
suffix:semicolon
DECL|variable|usb_free_urb
id|EXPORT_SYMBOL
c_func
(paren
id|usb_free_urb
)paren
suffix:semicolon
DECL|variable|usb_get_urb
id|EXPORT_SYMBOL
c_func
(paren
id|usb_get_urb
)paren
suffix:semicolon
DECL|variable|usb_submit_urb
id|EXPORT_SYMBOL
c_func
(paren
id|usb_submit_urb
)paren
suffix:semicolon
DECL|variable|usb_unlink_urb
id|EXPORT_SYMBOL
c_func
(paren
id|usb_unlink_urb
)paren
suffix:semicolon
DECL|variable|usb_kill_urb
id|EXPORT_SYMBOL
c_func
(paren
id|usb_kill_urb
)paren
suffix:semicolon
eof
