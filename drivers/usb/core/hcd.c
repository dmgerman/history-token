multiline_comment|/*&n; * (C) Copyright Linus Torvalds 1999&n; * (C) Copyright Johannes Erdfelt 1999-2001&n; * (C) Copyright Andreas Gal 1999&n; * (C) Copyright Gregory P. Smith 1999&n; * (C) Copyright Deti Fliegl 1999&n; * (C) Copyright Randy Dunlap 2000&n; * (C) Copyright David Brownell 2000-2002&n; * &n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2 of the License, or (at your&n; * option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY&n; * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License&n; * for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software Foundation,&n; * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/completion.h&gt;
macro_line|#include &lt;linux/uts.h&gt;&t;&t;&t;/* for UTS_SYSNAME */
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#ifdef CONFIG_USB_DEBUG
DECL|macro|DEBUG
mdefine_line|#define DEBUG
macro_line|#else
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#endif
macro_line|#include &lt;linux/usb.h&gt;
macro_line|#include &quot;hcd.h&quot;
singleline_comment|// #define USB_BANDWIDTH_MESSAGES
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * USB Host Controller Driver framework&n; *&n; * Plugs into usbcore (usb_bus) and lets HCDs share code, minimizing&n; * HCD-specific behaviors/bugs.&n; *&n; * This does error checks, tracks devices and urbs, and delegates to a&n; * &quot;hc_driver&quot; only for code (and data) that really needs to know about&n; * hardware differences.  That includes root hub registers, i/o queues,&n; * and so on ... but as little else as possible.&n; *&n; * Shared code includes most of the &quot;root hub&quot; code (these are emulated,&n; * though each HC&squot;s hardware works differently) and PCI glue, plus request&n; * tracking overhead.  The HCD code should only block on spinlocks or on&n; * hardware handshaking; blocking on software events (such as other kernel&n; * threads releasing resources, or completing actions) is all generic.&n; *&n; * Happens the USB 2.0 spec says this would be invisible inside the &quot;USBD&quot;,&n; * and includes mostly a &quot;HCDI&quot; (HCD Interface) along with some APIs used&n; * only by the hub driver ... and that neither should be seen or used by&n; * usb client device drivers.&n; *&n; * Contributors of ideas or unattributed patches include: David Brownell,&n; * Roman Weissgaerber, Rory Bolt, Greg Kroah-Hartman, ...&n; *&n; * HISTORY:&n; * 2002-02-21&t;Pull in most of the usb_bus support from usb.c; some&n; *&t;&t;associated cleanup.  &quot;usb_hcd&quot; still != &quot;usb_bus&quot;.&n; * 2001-12-12&t;Initial patch version for Linux 2.5.1 kernel.&n; */
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* host controllers we manage */
DECL|variable|usb_bus_list
id|LIST_HEAD
(paren
id|usb_bus_list
)paren
suffix:semicolon
multiline_comment|/* used when allocating bus numbers */
DECL|macro|USB_MAXBUS
mdefine_line|#define USB_MAXBUS&t;&t;64
DECL|struct|usb_busmap
r_struct
id|usb_busmap
(brace
DECL|member|busmap
r_int
r_int
id|busmap
(braket
id|USB_MAXBUS
op_div
(paren
l_int|8
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|busmap
r_static
r_struct
id|usb_busmap
id|busmap
suffix:semicolon
multiline_comment|/* used when updating list of hcds */
DECL|variable|usb_bus_list_lock
id|DECLARE_MUTEX
(paren
id|usb_bus_list_lock
)paren
suffix:semicolon
multiline_comment|/* exported only for usbfs */
multiline_comment|/* used when updating hcd data */
DECL|variable|hcd_data_lock
r_static
id|spinlock_t
id|hcd_data_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * Sharable chunks of root hub code.&n; */
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|macro|KERNEL_REL
mdefine_line|#define KERNEL_REL&t;((LINUX_VERSION_CODE &gt;&gt; 16) &amp; 0x0ff)
DECL|macro|KERNEL_VER
mdefine_line|#define KERNEL_VER&t;((LINUX_VERSION_CODE &gt;&gt; 8) &amp; 0x0ff)
multiline_comment|/* usb 2.0 root hub device descriptor */
DECL|variable|usb2_rh_dev_descriptor
r_static
r_const
id|u8
id|usb2_rh_dev_descriptor
(braket
l_int|18
)braket
op_assign
(brace
l_int|0x12
comma
multiline_comment|/*  __u8  bLength; */
l_int|0x01
comma
multiline_comment|/*  __u8  bDescriptorType; Device */
l_int|0x00
comma
l_int|0x02
comma
multiline_comment|/*  __u16 bcdUSB; v2.0 */
l_int|0x09
comma
multiline_comment|/*  __u8  bDeviceClass; HUB_CLASSCODE */
l_int|0x00
comma
multiline_comment|/*  __u8  bDeviceSubClass; */
l_int|0x01
comma
multiline_comment|/*  __u8  bDeviceProtocol; [ usb 2.0 single TT ]*/
l_int|0x08
comma
multiline_comment|/*  __u8  bMaxPacketSize0; 8 Bytes */
l_int|0x00
comma
l_int|0x00
comma
multiline_comment|/*  __u16 idVendor; */
l_int|0x00
comma
l_int|0x00
comma
multiline_comment|/*  __u16 idProduct; */
id|KERNEL_VER
comma
id|KERNEL_REL
comma
multiline_comment|/*  __u16 bcdDevice */
l_int|0x03
comma
multiline_comment|/*  __u8  iManufacturer; */
l_int|0x02
comma
multiline_comment|/*  __u8  iProduct; */
l_int|0x01
comma
multiline_comment|/*  __u8  iSerialNumber; */
l_int|0x01
multiline_comment|/*  __u8  bNumConfigurations; */
)brace
suffix:semicolon
multiline_comment|/* no usb 2.0 root hub &quot;device qualifier&quot; descriptor: one speed only */
multiline_comment|/* usb 1.1 root hub device descriptor */
DECL|variable|usb11_rh_dev_descriptor
r_static
r_const
id|u8
id|usb11_rh_dev_descriptor
(braket
l_int|18
)braket
op_assign
(brace
l_int|0x12
comma
multiline_comment|/*  __u8  bLength; */
l_int|0x01
comma
multiline_comment|/*  __u8  bDescriptorType; Device */
l_int|0x10
comma
l_int|0x01
comma
multiline_comment|/*  __u16 bcdUSB; v1.1 */
l_int|0x09
comma
multiline_comment|/*  __u8  bDeviceClass; HUB_CLASSCODE */
l_int|0x00
comma
multiline_comment|/*  __u8  bDeviceSubClass; */
l_int|0x00
comma
multiline_comment|/*  __u8  bDeviceProtocol; [ low/full speeds only ] */
l_int|0x08
comma
multiline_comment|/*  __u8  bMaxPacketSize0; 8 Bytes */
l_int|0x00
comma
l_int|0x00
comma
multiline_comment|/*  __u16 idVendor; */
l_int|0x00
comma
l_int|0x00
comma
multiline_comment|/*  __u16 idProduct; */
id|KERNEL_VER
comma
id|KERNEL_REL
comma
multiline_comment|/*  __u16 bcdDevice */
l_int|0x03
comma
multiline_comment|/*  __u8  iManufacturer; */
l_int|0x02
comma
multiline_comment|/*  __u8  iProduct; */
l_int|0x01
comma
multiline_comment|/*  __u8  iSerialNumber; */
l_int|0x01
multiline_comment|/*  __u8  bNumConfigurations; */
)brace
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* Configuration descriptors for our root hubs */
DECL|variable|fs_rh_config_descriptor
r_static
r_const
id|u8
id|fs_rh_config_descriptor
(braket
)braket
op_assign
(brace
multiline_comment|/* one configuration */
l_int|0x09
comma
multiline_comment|/*  __u8  bLength; */
l_int|0x02
comma
multiline_comment|/*  __u8  bDescriptorType; Configuration */
l_int|0x19
comma
l_int|0x00
comma
multiline_comment|/*  __u16 wTotalLength; */
l_int|0x01
comma
multiline_comment|/*  __u8  bNumInterfaces; (1) */
l_int|0x01
comma
multiline_comment|/*  __u8  bConfigurationValue; */
l_int|0x00
comma
multiline_comment|/*  __u8  iConfiguration; */
l_int|0x40
comma
multiline_comment|/*  __u8  bmAttributes; &n;&t;&t;&t;&t; Bit 7: Bus-powered,&n;&t;&t;&t;&t;     6: Self-powered,&n;&t;&t;&t;&t;     5 Remote-wakwup,&n;&t;&t;&t;&t;     4..0: resvd */
l_int|0x00
comma
multiline_comment|/*  __u8  MaxPower; */
multiline_comment|/* USB 1.1:&n;&t; * USB 2.0, single TT organization (mandatory):&n;&t; *&t;one interface, protocol 0&n;&t; *&n;&t; * USB 2.0, multiple TT organization (optional):&n;&t; *&t;two interfaces, protocols 1 (like single TT)&n;&t; *&t;and 2 (multiple TT mode) ... config is&n;&t; *&t;sometimes settable&n;&t; *&t;NOT IMPLEMENTED&n;&t; */
multiline_comment|/* one interface */
l_int|0x09
comma
multiline_comment|/*  __u8  if_bLength; */
l_int|0x04
comma
multiline_comment|/*  __u8  if_bDescriptorType; Interface */
l_int|0x00
comma
multiline_comment|/*  __u8  if_bInterfaceNumber; */
l_int|0x00
comma
multiline_comment|/*  __u8  if_bAlternateSetting; */
l_int|0x01
comma
multiline_comment|/*  __u8  if_bNumEndpoints; */
l_int|0x09
comma
multiline_comment|/*  __u8  if_bInterfaceClass; HUB_CLASSCODE */
l_int|0x00
comma
multiline_comment|/*  __u8  if_bInterfaceSubClass; */
l_int|0x00
comma
multiline_comment|/*  __u8  if_bInterfaceProtocol; [usb1.1 or single tt] */
l_int|0x00
comma
multiline_comment|/*  __u8  if_iInterface; */
multiline_comment|/* one endpoint (status change endpoint) */
l_int|0x07
comma
multiline_comment|/*  __u8  ep_bLength; */
l_int|0x05
comma
multiline_comment|/*  __u8  ep_bDescriptorType; Endpoint */
l_int|0x81
comma
multiline_comment|/*  __u8  ep_bEndpointAddress; IN Endpoint 1 */
l_int|0x03
comma
multiline_comment|/*  __u8  ep_bmAttributes; Interrupt */
l_int|0x02
comma
l_int|0x00
comma
multiline_comment|/*  __u16 ep_wMaxPacketSize; 1 + (MAX_ROOT_PORTS / 8) */
l_int|0xff
multiline_comment|/*  __u8  ep_bInterval; (255ms -- usb 2.0 spec) */
)brace
suffix:semicolon
DECL|variable|hs_rh_config_descriptor
r_static
r_const
id|u8
id|hs_rh_config_descriptor
(braket
)braket
op_assign
(brace
multiline_comment|/* one configuration */
l_int|0x09
comma
multiline_comment|/*  __u8  bLength; */
l_int|0x02
comma
multiline_comment|/*  __u8  bDescriptorType; Configuration */
l_int|0x19
comma
l_int|0x00
comma
multiline_comment|/*  __u16 wTotalLength; */
l_int|0x01
comma
multiline_comment|/*  __u8  bNumInterfaces; (1) */
l_int|0x01
comma
multiline_comment|/*  __u8  bConfigurationValue; */
l_int|0x00
comma
multiline_comment|/*  __u8  iConfiguration; */
l_int|0x40
comma
multiline_comment|/*  __u8  bmAttributes; &n;&t;&t;&t;&t; Bit 7: Bus-powered,&n;&t;&t;&t;&t;     6: Self-powered,&n;&t;&t;&t;&t;     5 Remote-wakwup,&n;&t;&t;&t;&t;     4..0: resvd */
l_int|0x00
comma
multiline_comment|/*  __u8  MaxPower; */
multiline_comment|/* USB 1.1:&n;&t; * USB 2.0, single TT organization (mandatory):&n;&t; *&t;one interface, protocol 0&n;&t; *&n;&t; * USB 2.0, multiple TT organization (optional):&n;&t; *&t;two interfaces, protocols 1 (like single TT)&n;&t; *&t;and 2 (multiple TT mode) ... config is&n;&t; *&t;sometimes settable&n;&t; *&t;NOT IMPLEMENTED&n;&t; */
multiline_comment|/* one interface */
l_int|0x09
comma
multiline_comment|/*  __u8  if_bLength; */
l_int|0x04
comma
multiline_comment|/*  __u8  if_bDescriptorType; Interface */
l_int|0x00
comma
multiline_comment|/*  __u8  if_bInterfaceNumber; */
l_int|0x00
comma
multiline_comment|/*  __u8  if_bAlternateSetting; */
l_int|0x01
comma
multiline_comment|/*  __u8  if_bNumEndpoints; */
l_int|0x09
comma
multiline_comment|/*  __u8  if_bInterfaceClass; HUB_CLASSCODE */
l_int|0x00
comma
multiline_comment|/*  __u8  if_bInterfaceSubClass; */
l_int|0x00
comma
multiline_comment|/*  __u8  if_bInterfaceProtocol; [usb1.1 or single tt] */
l_int|0x00
comma
multiline_comment|/*  __u8  if_iInterface; */
multiline_comment|/* one endpoint (status change endpoint) */
l_int|0x07
comma
multiline_comment|/*  __u8  ep_bLength; */
l_int|0x05
comma
multiline_comment|/*  __u8  ep_bDescriptorType; Endpoint */
l_int|0x81
comma
multiline_comment|/*  __u8  ep_bEndpointAddress; IN Endpoint 1 */
l_int|0x03
comma
multiline_comment|/*  __u8  ep_bmAttributes; Interrupt */
l_int|0x02
comma
l_int|0x00
comma
multiline_comment|/*  __u16 ep_wMaxPacketSize; 1 + (MAX_ROOT_PORTS / 8) */
l_int|0x0c
multiline_comment|/*  __u8  ep_bInterval; (256ms -- usb 2.0 spec) */
)brace
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * helper routine for returning string descriptors in UTF-16LE&n; * input can actually be ISO-8859-1; ASCII is its 7-bit subset&n; */
DECL|function|ascii2utf
r_static
r_int
id|ascii2utf
(paren
r_char
op_star
id|s
comma
id|u8
op_star
id|utf
comma
r_int
id|utfmax
)paren
(brace
r_int
id|retval
suffix:semicolon
r_for
c_loop
(paren
id|retval
op_assign
l_int|0
suffix:semicolon
op_star
id|s
op_logical_and
id|utfmax
OG
l_int|1
suffix:semicolon
id|utfmax
op_sub_assign
l_int|2
comma
id|retval
op_add_assign
l_int|2
)paren
(brace
op_star
id|utf
op_increment
op_assign
op_star
id|s
op_increment
suffix:semicolon
op_star
id|utf
op_increment
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * rh_string - provides manufacturer, product and serial strings for root hub&n; * @id: the string ID number (1: serial number, 2: product, 3: vendor)&n; * @hcd: the host controller for this root hub&n; * @type: string describing our driver &n; * @data: return packet in UTF-16 LE&n; * @len: length of the return packet&n; *&n; * Produces either a manufacturer, product or serial number string for the&n; * virtual root hub device.&n; */
DECL|function|rh_string
r_static
r_int
id|rh_string
(paren
r_int
id|id
comma
r_struct
id|usb_hcd
op_star
id|hcd
comma
id|u8
op_star
id|data
comma
r_int
id|len
)paren
(brace
r_char
id|buf
(braket
l_int|100
)braket
suffix:semicolon
singleline_comment|// language ids
r_if
c_cond
(paren
id|id
op_eq
l_int|0
)paren
(brace
op_star
id|data
op_increment
op_assign
l_int|4
suffix:semicolon
op_star
id|data
op_increment
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* 4 bytes string data */
op_star
id|data
op_increment
op_assign
l_int|0
suffix:semicolon
op_star
id|data
op_increment
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* some language id */
r_return
l_int|4
suffix:semicolon
singleline_comment|// serial number
)brace
r_else
r_if
c_cond
(paren
id|id
op_eq
l_int|1
)paren
(brace
id|strcpy
(paren
id|buf
comma
id|hcd-&gt;self.bus_name
)paren
suffix:semicolon
singleline_comment|// product description
)brace
r_else
r_if
c_cond
(paren
id|id
op_eq
l_int|2
)paren
(brace
id|strcpy
(paren
id|buf
comma
id|hcd-&gt;product_desc
)paren
suffix:semicolon
singleline_comment|// id 3 == vendor description
)brace
r_else
r_if
c_cond
(paren
id|id
op_eq
l_int|3
)paren
(brace
id|sprintf
(paren
id|buf
comma
l_string|&quot;%s %s %s&quot;
comma
id|UTS_SYSNAME
comma
id|UTS_RELEASE
comma
id|hcd-&gt;description
)paren
suffix:semicolon
singleline_comment|// unsupported IDs --&gt; &quot;protocol stall&quot;
)brace
r_else
r_return
l_int|0
suffix:semicolon
id|data
(braket
l_int|0
)braket
op_assign
l_int|2
op_plus
id|ascii2utf
(paren
id|buf
comma
id|data
op_plus
l_int|2
comma
id|len
op_minus
l_int|2
)paren
suffix:semicolon
id|data
(braket
l_int|1
)braket
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* type == string */
r_return
id|data
(braket
l_int|0
)braket
suffix:semicolon
)brace
multiline_comment|/* Root hub control transfers execute synchronously */
DECL|function|rh_call_control
r_static
r_int
id|rh_call_control
(paren
r_struct
id|usb_hcd
op_star
id|hcd
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|usb_ctrlrequest
op_star
id|cmd
op_assign
(paren
r_struct
id|usb_ctrlrequest
op_star
)paren
id|urb-&gt;setup_packet
suffix:semicolon
id|u16
id|typeReq
comma
id|wValue
comma
id|wIndex
comma
id|wLength
suffix:semicolon
r_const
id|u8
op_star
id|bufp
op_assign
l_int|0
suffix:semicolon
id|u8
op_star
id|ubuf
op_assign
id|urb-&gt;transfer_buffer
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|typeReq
op_assign
(paren
id|cmd-&gt;bRequestType
op_lshift
l_int|8
)paren
op_or
id|cmd-&gt;bRequest
suffix:semicolon
id|wValue
op_assign
id|le16_to_cpu
(paren
id|cmd-&gt;wValue
)paren
suffix:semicolon
id|wIndex
op_assign
id|le16_to_cpu
(paren
id|cmd-&gt;wIndex
)paren
suffix:semicolon
id|wLength
op_assign
id|le16_to_cpu
(paren
id|cmd-&gt;wLength
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wLength
OG
id|urb-&gt;transfer_buffer_length
)paren
r_goto
id|error
suffix:semicolon
multiline_comment|/* set up for success */
id|urb-&gt;status
op_assign
l_int|0
suffix:semicolon
id|urb-&gt;actual_length
op_assign
id|wLength
suffix:semicolon
r_switch
c_cond
(paren
id|typeReq
)paren
(brace
multiline_comment|/* DEVICE REQUESTS */
r_case
id|DeviceRequest
op_or
id|USB_REQ_GET_STATUS
suffix:colon
singleline_comment|// DEVICE_REMOTE_WAKEUP
id|ubuf
(braket
l_int|0
)braket
op_assign
l_int|1
suffix:semicolon
singleline_comment|// selfpowered
id|ubuf
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_case
id|DeviceOutRequest
op_or
id|USB_REQ_CLEAR_FEATURE
suffix:colon
r_case
id|DeviceOutRequest
op_or
id|USB_REQ_SET_FEATURE
suffix:colon
id|dbg
(paren
l_string|&quot;no device features yet yet&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DeviceRequest
op_or
id|USB_REQ_GET_CONFIGURATION
suffix:colon
id|ubuf
(braket
l_int|0
)braket
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_case
id|DeviceOutRequest
op_or
id|USB_REQ_SET_CONFIGURATION
suffix:colon
r_break
suffix:semicolon
r_case
id|DeviceRequest
op_or
id|USB_REQ_GET_DESCRIPTOR
suffix:colon
r_switch
c_cond
(paren
id|wValue
op_amp
l_int|0xff00
)paren
(brace
r_case
id|USB_DT_DEVICE
op_lshift
l_int|8
suffix:colon
r_if
c_cond
(paren
id|hcd-&gt;driver-&gt;flags
op_amp
id|HCD_USB2
)paren
id|bufp
op_assign
id|usb2_rh_dev_descriptor
suffix:semicolon
r_else
r_if
c_cond
(paren
id|hcd-&gt;driver-&gt;flags
op_amp
id|HCD_USB11
)paren
id|bufp
op_assign
id|usb11_rh_dev_descriptor
suffix:semicolon
r_else
r_goto
id|error
suffix:semicolon
id|len
op_assign
l_int|18
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_DT_CONFIG
op_lshift
l_int|8
suffix:colon
r_if
c_cond
(paren
id|hcd-&gt;driver-&gt;flags
op_amp
id|HCD_USB2
)paren
(brace
id|bufp
op_assign
id|hs_rh_config_descriptor
suffix:semicolon
id|len
op_assign
r_sizeof
id|hs_rh_config_descriptor
suffix:semicolon
)brace
r_else
(brace
id|bufp
op_assign
id|fs_rh_config_descriptor
suffix:semicolon
id|len
op_assign
r_sizeof
id|fs_rh_config_descriptor
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|USB_DT_STRING
op_lshift
l_int|8
suffix:colon
id|urb-&gt;actual_length
op_assign
id|rh_string
(paren
id|wValue
op_amp
l_int|0xff
comma
id|hcd
comma
id|ubuf
comma
id|wLength
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_goto
id|error
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DeviceRequest
op_or
id|USB_REQ_GET_INTERFACE
suffix:colon
id|ubuf
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_case
id|DeviceOutRequest
op_or
id|USB_REQ_SET_INTERFACE
suffix:colon
r_break
suffix:semicolon
r_case
id|DeviceOutRequest
op_or
id|USB_REQ_SET_ADDRESS
suffix:colon
singleline_comment|// wValue == urb-&gt;dev-&gt;devaddr
id|dbg
(paren
l_string|&quot;%s root hub device address %d&quot;
comma
id|hcd-&gt;self.bus_name
comma
id|wValue
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* INTERFACE REQUESTS (no defined feature/status flags) */
multiline_comment|/* ENDPOINT REQUESTS */
r_case
id|EndpointRequest
op_or
id|USB_REQ_GET_STATUS
suffix:colon
singleline_comment|// ENDPOINT_HALT flag
id|ubuf
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|ubuf
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_case
id|EndpointOutRequest
op_or
id|USB_REQ_CLEAR_FEATURE
suffix:colon
r_case
id|EndpointOutRequest
op_or
id|USB_REQ_SET_FEATURE
suffix:colon
id|dbg
(paren
l_string|&quot;no endpoint features yet&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* CLASS REQUESTS (and errors) */
r_default
suffix:colon
multiline_comment|/* non-generic request */
id|urb-&gt;status
op_assign
id|hcd-&gt;driver-&gt;hub_control
(paren
id|hcd
comma
id|typeReq
comma
id|wValue
comma
id|wIndex
comma
id|ubuf
comma
id|wLength
)paren
suffix:semicolon
r_break
suffix:semicolon
id|error
suffix:colon
multiline_comment|/* &quot;protocol stall&quot; on error */
id|urb-&gt;status
op_assign
op_minus
id|EPIPE
suffix:semicolon
id|dbg
(paren
l_string|&quot;unsupported hub control message (maxchild %d)&quot;
comma
id|urb-&gt;dev-&gt;maxchild
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|urb-&gt;status
)paren
(brace
id|urb-&gt;actual_length
op_assign
l_int|0
suffix:semicolon
id|dbg
(paren
l_string|&quot;CTRL: TypeReq=0x%x val=0x%x idx=0x%x len=%d ==&gt; %d&quot;
comma
id|typeReq
comma
id|wValue
comma
id|wIndex
comma
id|wLength
comma
id|urb-&gt;status
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bufp
)paren
(brace
r_if
c_cond
(paren
id|urb-&gt;transfer_buffer_length
OL
id|len
)paren
id|len
op_assign
id|urb-&gt;transfer_buffer_length
suffix:semicolon
id|urb-&gt;actual_length
op_assign
id|len
suffix:semicolon
singleline_comment|// always USB_DIR_IN, toward host
id|memcpy
(paren
id|ubuf
comma
id|bufp
comma
id|len
)paren
suffix:semicolon
)brace
multiline_comment|/* any errors get returned through the urb completion */
id|usb_hcd_giveback_urb
(paren
id|hcd
comma
id|urb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * Root Hub interrupt transfers are synthesized with a timer.&n; * Completions are called in_interrupt() but not in_irq().&n; */
r_static
r_void
id|rh_report_status
(paren
r_int
r_int
id|ptr
)paren
suffix:semicolon
DECL|function|rh_status_urb
r_static
r_int
id|rh_status_urb
(paren
r_struct
id|usb_hcd
op_star
id|hcd
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
id|len
op_assign
l_int|1
op_plus
(paren
id|urb-&gt;dev-&gt;maxchild
op_div
l_int|8
)paren
suffix:semicolon
multiline_comment|/* rh_timer protected by hcd_data_lock */
r_if
c_cond
(paren
id|timer_pending
(paren
op_amp
id|hcd-&gt;rh_timer
)paren
op_logical_or
id|urb-&gt;status
op_ne
op_minus
id|EINPROGRESS
op_logical_or
op_logical_neg
id|HCD_IS_RUNNING
(paren
id|hcd-&gt;state
)paren
op_logical_or
id|urb-&gt;transfer_buffer_length
OL
id|len
)paren
(brace
id|dbg
(paren
l_string|&quot;not queuing status urb, stat %d&quot;
comma
id|urb-&gt;status
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|urb-&gt;hcpriv
op_assign
id|hcd
suffix:semicolon
multiline_comment|/* nonzero to indicate it&squot;s queued */
id|init_timer
(paren
op_amp
id|hcd-&gt;rh_timer
)paren
suffix:semicolon
id|hcd-&gt;rh_timer.function
op_assign
id|rh_report_status
suffix:semicolon
id|hcd-&gt;rh_timer.data
op_assign
(paren
r_int
r_int
)paren
id|urb
suffix:semicolon
multiline_comment|/* USB 2.0 spec says 256msec; this is close enough */
id|hcd-&gt;rh_timer.expires
op_assign
id|jiffies
op_plus
id|HZ
op_div
l_int|4
suffix:semicolon
id|add_timer
(paren
op_amp
id|hcd-&gt;rh_timer
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* timer callback */
DECL|function|rh_report_status
r_static
r_void
id|rh_report_status
(paren
r_int
r_int
id|ptr
)paren
(brace
r_struct
id|urb
op_star
id|urb
suffix:semicolon
r_struct
id|usb_hcd
op_star
id|hcd
suffix:semicolon
r_int
id|length
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|urb
op_assign
(paren
r_struct
id|urb
op_star
)paren
id|ptr
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|urb-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb-&gt;dev
)paren
(brace
id|spin_unlock_irqrestore
(paren
op_amp
id|urb-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|hcd
op_assign
id|urb-&gt;dev-&gt;bus-&gt;hcpriv
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
(brace
r_if
c_cond
(paren
id|HCD_IS_RUNNING
(paren
id|hcd-&gt;state
)paren
)paren
(brace
id|length
op_assign
id|hcd-&gt;driver-&gt;hub_status_data
(paren
id|hcd
comma
id|urb-&gt;transfer_buffer
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|urb-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|length
OG
l_int|0
)paren
(brace
id|urb-&gt;actual_length
op_assign
id|length
suffix:semicolon
id|urb-&gt;status
op_assign
l_int|0
suffix:semicolon
id|urb-&gt;complete
(paren
id|urb
)paren
suffix:semicolon
)brace
id|spin_lock_irqsave
(paren
op_amp
id|hcd_data_lock
comma
id|flags
)paren
suffix:semicolon
id|urb-&gt;status
op_assign
op_minus
id|EINPROGRESS
suffix:semicolon
r_if
c_cond
(paren
id|HCD_IS_RUNNING
(paren
id|hcd-&gt;state
)paren
op_logical_and
id|rh_status_urb
(paren
id|hcd
comma
id|urb
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* another driver snuck in? */
id|dbg
(paren
l_string|&quot;%s, can&squot;t resubmit roothub status urb?&quot;
comma
id|hcd-&gt;self.bus_name
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|hcd_data_lock
comma
id|flags
)paren
suffix:semicolon
id|BUG
(paren
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|hcd_data_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
id|spin_unlock_irqrestore
(paren
op_amp
id|urb-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* this urb&squot;s been unlinked */
id|urb-&gt;hcpriv
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|urb-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|usb_hcd_giveback_urb
(paren
id|hcd
comma
id|urb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|rh_urb_enqueue
r_static
r_int
id|rh_urb_enqueue
(paren
r_struct
id|usb_hcd
op_star
id|hcd
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_if
c_cond
(paren
id|usb_pipeint
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
r_int
id|retval
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|hcd_data_lock
comma
id|flags
)paren
suffix:semicolon
id|retval
op_assign
id|rh_status_urb
(paren
id|hcd
comma
id|urb
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|hcd_data_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_if
c_cond
(paren
id|usb_pipecontrol
(paren
id|urb-&gt;pipe
)paren
)paren
r_return
id|rh_call_control
(paren
id|hcd
comma
id|urb
)paren
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|usb_rh_status_dequeue
r_void
id|usb_rh_status_dequeue
(paren
r_struct
id|usb_hcd
op_star
id|hcd
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|hcd_data_lock
comma
id|flags
)paren
suffix:semicolon
id|del_timer_sync
(paren
op_amp
id|hcd-&gt;rh_timer
)paren
suffix:semicolon
id|hcd-&gt;rh_timer.data
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|hcd_data_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* we rely on RH callback code not unlinking its URB! */
id|usb_hcd_giveback_urb
(paren
id|hcd
comma
id|urb
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* exported only within usbcore */
DECL|function|usb_bus_get
r_void
id|usb_bus_get
(paren
r_struct
id|usb_bus
op_star
id|bus
)paren
(brace
id|atomic_inc
(paren
op_amp
id|bus-&gt;refcnt
)paren
suffix:semicolon
)brace
multiline_comment|/* exported only within usbcore */
DECL|function|usb_bus_put
r_void
id|usb_bus_put
(paren
r_struct
id|usb_bus
op_star
id|bus
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
(paren
op_amp
id|bus-&gt;refcnt
)paren
)paren
id|kfree
(paren
id|bus
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/**&n; * usb_bus_init - shared initialization code&n; * @bus: the bus structure being initialized&n; *&n; * This code is used to initialize a usb_bus structure, memory for which is&n; * separately managed.&n; */
DECL|function|usb_bus_init
r_void
id|usb_bus_init
(paren
r_struct
id|usb_bus
op_star
id|bus
)paren
(brace
id|memset
(paren
op_amp
id|bus-&gt;devmap
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|usb_devmap
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEVNUM_ROUND_ROBIN
id|bus-&gt;devnum_next
op_assign
l_int|1
suffix:semicolon
macro_line|#endif /* DEVNUM_ROUND_ROBIN */
id|bus-&gt;root_hub
op_assign
l_int|NULL
suffix:semicolon
id|bus-&gt;hcpriv
op_assign
l_int|NULL
suffix:semicolon
id|bus-&gt;busnum
op_assign
op_minus
l_int|1
suffix:semicolon
id|bus-&gt;bandwidth_allocated
op_assign
l_int|0
suffix:semicolon
id|bus-&gt;bandwidth_int_reqs
op_assign
l_int|0
suffix:semicolon
id|bus-&gt;bandwidth_isoc_reqs
op_assign
l_int|0
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|bus-&gt;bus_list
)paren
suffix:semicolon
id|atomic_set
(paren
op_amp
id|bus-&gt;refcnt
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|variable|usb_bus_init
id|EXPORT_SYMBOL
(paren
id|usb_bus_init
)paren
suffix:semicolon
multiline_comment|/**&n; * usb_alloc_bus - creates a new USB host controller structure&n; * @op: pointer to a struct usb_operations that this bus structure should use&n; * Context: !in_interrupt()&n; *&n; * Creates a USB host controller bus structure with the specified &n; * usb_operations and initializes all the necessary internal objects.&n; *&n; * If no memory is available, NULL is returned.&n; *&n; * The caller should call usb_free_bus() when it is finished with the structure.&n; */
DECL|function|usb_alloc_bus
r_struct
id|usb_bus
op_star
id|usb_alloc_bus
(paren
r_struct
id|usb_operations
op_star
id|op
)paren
(brace
r_struct
id|usb_bus
op_star
id|bus
suffix:semicolon
id|bus
op_assign
id|kmalloc
(paren
r_sizeof
op_star
id|bus
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bus
)paren
r_return
l_int|NULL
suffix:semicolon
id|usb_bus_init
(paren
id|bus
)paren
suffix:semicolon
id|bus-&gt;op
op_assign
id|op
suffix:semicolon
r_return
id|bus
suffix:semicolon
)brace
DECL|variable|usb_alloc_bus
id|EXPORT_SYMBOL
(paren
id|usb_alloc_bus
)paren
suffix:semicolon
multiline_comment|/**&n; * usb_free_bus - frees the memory used by a bus structure&n; * @bus: pointer to the bus to free&n; *&n; * To be invoked by a HCD, only as the last step of decoupling from&n; * hardware.  It is an error to call this if the reference count is&n; * anything but one.  That would indicate that some system component&n; * did not correctly shut down, and thought the hardware was still&n; * accessible.&n; */
DECL|function|usb_free_bus
r_void
id|usb_free_bus
(paren
r_struct
id|usb_bus
op_star
id|bus
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bus
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
(paren
op_amp
id|bus-&gt;refcnt
)paren
op_ne
l_int|1
)paren
id|err
(paren
l_string|&quot;usb_free_bus #%d, count != 1&quot;
comma
id|bus-&gt;busnum
)paren
suffix:semicolon
id|usb_bus_put
(paren
id|bus
)paren
suffix:semicolon
)brace
DECL|variable|usb_free_bus
id|EXPORT_SYMBOL
(paren
id|usb_free_bus
)paren
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/**&n; * usb_register_bus - registers the USB host controller with the usb core&n; * @bus: pointer to the bus to register&n; * Context: !in_interrupt()&n; *&n; * Assigns a bus number, and links the controller into usbcore data&n; * structures so that it can be seen by scanning the bus list.&n; */
DECL|function|usb_register_bus
r_void
id|usb_register_bus
c_func
(paren
r_struct
id|usb_bus
op_star
id|bus
)paren
(brace
r_int
id|busnum
suffix:semicolon
id|down
(paren
op_amp
id|usb_bus_list_lock
)paren
suffix:semicolon
id|busnum
op_assign
id|find_next_zero_bit
(paren
id|busmap.busmap
comma
id|USB_MAXBUS
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|busnum
OL
id|USB_MAXBUS
)paren
(brace
id|set_bit
(paren
id|busnum
comma
id|busmap.busmap
)paren
suffix:semicolon
id|bus-&gt;busnum
op_assign
id|busnum
suffix:semicolon
)brace
r_else
id|warn
(paren
l_string|&quot;too many buses&quot;
)paren
suffix:semicolon
id|usb_bus_get
(paren
id|bus
)paren
suffix:semicolon
multiline_comment|/* Add it to the list of buses */
id|list_add
(paren
op_amp
id|bus-&gt;bus_list
comma
op_amp
id|usb_bus_list
)paren
suffix:semicolon
id|up
(paren
op_amp
id|usb_bus_list_lock
)paren
suffix:semicolon
id|usbfs_add_bus
(paren
id|bus
)paren
suffix:semicolon
id|info
(paren
l_string|&quot;new USB bus registered, assigned bus number %d&quot;
comma
id|bus-&gt;busnum
)paren
suffix:semicolon
)brace
DECL|variable|usb_register_bus
id|EXPORT_SYMBOL
(paren
id|usb_register_bus
)paren
suffix:semicolon
multiline_comment|/**&n; * usb_deregister_bus - deregisters the USB host controller&n; * @bus: pointer to the bus to deregister&n; * Context: !in_interrupt()&n; *&n; * Recycles the bus number, and unlinks the controller from usbcore data&n; * structures so that it won&squot;t be seen by scanning the bus list.&n; */
DECL|function|usb_deregister_bus
r_void
id|usb_deregister_bus
(paren
r_struct
id|usb_bus
op_star
id|bus
)paren
(brace
id|info
(paren
l_string|&quot;USB bus %d deregistered&quot;
comma
id|bus-&gt;busnum
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * NOTE: make sure that all the devices are removed by the&n;&t; * controller code, as well as having it call this when cleaning&n;&t; * itself up&n;&t; */
id|down
(paren
op_amp
id|usb_bus_list_lock
)paren
suffix:semicolon
id|list_del
(paren
op_amp
id|bus-&gt;bus_list
)paren
suffix:semicolon
id|up
(paren
op_amp
id|usb_bus_list_lock
)paren
suffix:semicolon
id|usbfs_remove_bus
(paren
id|bus
)paren
suffix:semicolon
id|clear_bit
(paren
id|bus-&gt;busnum
comma
id|busmap.busmap
)paren
suffix:semicolon
id|usb_bus_put
(paren
id|bus
)paren
suffix:semicolon
)brace
DECL|variable|usb_deregister_bus
id|EXPORT_SYMBOL
(paren
id|usb_deregister_bus
)paren
suffix:semicolon
multiline_comment|/**&n; * usb_register_root_hub - called by HCD to register its root hub &n; * @usb_dev: the usb root hub device to be registered.&n; * @parent_dev: the parent device of this root hub.&n; *&n; * The USB host controller calls this function to register the root hub&n; * properly with the USB subsystem.  It sets up the device properly in&n; * the driverfs tree, and then calls usb_new_device() to register the&n; * usb device.&n; */
DECL|function|usb_register_root_hub
r_int
id|usb_register_root_hub
(paren
r_struct
id|usb_device
op_star
id|usb_dev
comma
r_struct
id|device
op_star
id|parent_dev
)paren
(brace
r_int
id|retval
suffix:semicolon
id|usb_dev-&gt;dev.parent
op_assign
id|parent_dev
suffix:semicolon
id|strcpy
(paren
op_amp
id|usb_dev-&gt;dev.name
(braket
l_int|0
)braket
comma
l_string|&quot;usb_name&quot;
)paren
suffix:semicolon
id|strcpy
(paren
op_amp
id|usb_dev-&gt;dev.bus_id
(braket
l_int|0
)braket
comma
l_string|&quot;usb_bus&quot;
)paren
suffix:semicolon
id|retval
op_assign
id|usb_new_device
(paren
id|usb_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
id|put_device
(paren
op_amp
id|usb_dev-&gt;dev
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|usb_register_root_hub
id|EXPORT_SYMBOL
(paren
id|usb_register_root_hub
)paren
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/**&n; * usb_calc_bus_time: approximate periodic transaction time in nanoseconds&n; * @speed: from dev-&gt;speed; USB_SPEED_{LOW,FULL,HIGH}&n; * @is_input: true iff the transaction sends data to the host&n; * @is_isoc: true for isochronous transactions, false for interrupt ones&n; * @bytecount: how many bytes in the transaction.&n; *&n; * Returns approximate bus time in nanoseconds for a periodic transaction.&n; * See USB 2.0 spec section 5.11.3; only periodic transfers need to be&n; * scheduled in software, this function is only used for such scheduling.&n; */
DECL|function|usb_calc_bus_time
r_int
id|usb_calc_bus_time
(paren
r_int
id|speed
comma
r_int
id|is_input
comma
r_int
id|isoc
comma
r_int
id|bytecount
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
r_switch
c_cond
(paren
id|speed
)paren
(brace
r_case
id|USB_SPEED_LOW
suffix:colon
multiline_comment|/* INTR only */
r_if
c_cond
(paren
id|is_input
)paren
(brace
id|tmp
op_assign
(paren
l_int|67667L
op_star
(paren
l_int|31L
op_plus
l_int|10L
op_star
id|BitTime
(paren
id|bytecount
)paren
)paren
)paren
op_div
l_int|1000L
suffix:semicolon
r_return
(paren
l_int|64060L
op_plus
(paren
l_int|2
op_star
id|BW_HUB_LS_SETUP
)paren
op_plus
id|BW_HOST_DELAY
op_plus
id|tmp
)paren
suffix:semicolon
)brace
r_else
(brace
id|tmp
op_assign
(paren
l_int|66700L
op_star
(paren
l_int|31L
op_plus
l_int|10L
op_star
id|BitTime
(paren
id|bytecount
)paren
)paren
)paren
op_div
l_int|1000L
suffix:semicolon
r_return
(paren
l_int|64107L
op_plus
(paren
l_int|2
op_star
id|BW_HUB_LS_SETUP
)paren
op_plus
id|BW_HOST_DELAY
op_plus
id|tmp
)paren
suffix:semicolon
)brace
r_case
id|USB_SPEED_FULL
suffix:colon
multiline_comment|/* ISOC or INTR */
r_if
c_cond
(paren
id|isoc
)paren
(brace
id|tmp
op_assign
(paren
l_int|8354L
op_star
(paren
l_int|31L
op_plus
l_int|10L
op_star
id|BitTime
(paren
id|bytecount
)paren
)paren
)paren
op_div
l_int|1000L
suffix:semicolon
r_return
(paren
(paren
(paren
id|is_input
)paren
ques
c_cond
l_int|7268L
suffix:colon
l_int|6265L
)paren
op_plus
id|BW_HOST_DELAY
op_plus
id|tmp
)paren
suffix:semicolon
)brace
r_else
(brace
id|tmp
op_assign
(paren
l_int|8354L
op_star
(paren
l_int|31L
op_plus
l_int|10L
op_star
id|BitTime
(paren
id|bytecount
)paren
)paren
)paren
op_div
l_int|1000L
suffix:semicolon
r_return
(paren
l_int|9107L
op_plus
id|BW_HOST_DELAY
op_plus
id|tmp
)paren
suffix:semicolon
)brace
r_case
id|USB_SPEED_HIGH
suffix:colon
multiline_comment|/* ISOC or INTR */
singleline_comment|// FIXME adjust for input vs output
r_if
c_cond
(paren
id|isoc
)paren
id|tmp
op_assign
id|HS_USECS
(paren
id|bytecount
)paren
suffix:semicolon
r_else
id|tmp
op_assign
id|HS_USECS_ISO
(paren
id|bytecount
)paren
suffix:semicolon
r_return
id|tmp
suffix:semicolon
r_default
suffix:colon
id|dbg
(paren
l_string|&quot;bogus device speed!&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
DECL|variable|usb_calc_bus_time
id|EXPORT_SYMBOL
(paren
id|usb_calc_bus_time
)paren
suffix:semicolon
multiline_comment|/*&n; * usb_check_bandwidth():&n; *&n; * old_alloc is from host_controller-&gt;bandwidth_allocated in microseconds;&n; * bustime is from calc_bus_time(), but converted to microseconds.&n; *&n; * returns &lt;bustime in us&gt; if successful,&n; * or -ENOSPC if bandwidth request fails.&n; *&n; * FIXME:&n; * This initial implementation does not use Endpoint.bInterval&n; * in managing bandwidth allocation.&n; * It probably needs to be expanded to use Endpoint.bInterval.&n; * This can be done as a later enhancement (correction).&n; *&n; * This will also probably require some kind of&n; * frame allocation tracking...meaning, for example,&n; * that if multiple drivers request interrupts every 10 USB frames,&n; * they don&squot;t all have to be allocated at&n; * frame numbers N, N+10, N+20, etc.  Some of them could be at&n; * N+11, N+21, N+31, etc., and others at&n; * N+12, N+22, N+32, etc.&n; *&n; * Similarly for isochronous transfers...&n; *&n; * Individual HCDs can schedule more directly ... this logic&n; * is not correct for high speed transfers.&n; */
DECL|function|usb_check_bandwidth
r_int
id|usb_check_bandwidth
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
r_int
id|pipe
op_assign
id|urb-&gt;pipe
suffix:semicolon
r_int
id|bustime
suffix:semicolon
r_int
id|is_in
op_assign
id|usb_pipein
(paren
id|pipe
)paren
suffix:semicolon
r_int
id|is_iso
op_assign
id|usb_pipeisoc
(paren
id|pipe
)paren
suffix:semicolon
r_int
id|old_alloc
op_assign
id|dev-&gt;bus-&gt;bandwidth_allocated
suffix:semicolon
r_int
id|new_alloc
suffix:semicolon
id|bustime
op_assign
id|NS_TO_US
(paren
id|usb_calc_bus_time
(paren
id|dev-&gt;speed
comma
id|is_in
comma
id|is_iso
comma
id|usb_maxpacket
(paren
id|dev
comma
id|pipe
comma
op_logical_neg
id|is_in
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_iso
)paren
id|bustime
op_div_assign
id|urb-&gt;number_of_packets
suffix:semicolon
id|new_alloc
op_assign
id|old_alloc
op_plus
(paren
r_int
)paren
id|bustime
suffix:semicolon
r_if
c_cond
(paren
id|new_alloc
OG
id|FRAME_TIME_MAX_USECS_ALLOC
)paren
(brace
macro_line|#ifdef&t;DEBUG
r_char
op_star
id|mode
op_assign
macro_line|#ifdef CONFIG_USB_BANDWIDTH
l_string|&quot;&quot;
suffix:semicolon
macro_line|#else
l_string|&quot;would have &quot;
suffix:semicolon
macro_line|#endif
id|dbg
(paren
l_string|&quot;usb_check_bandwidth %sFAILED: %d + %ld = %d usec&quot;
comma
id|mode
comma
id|old_alloc
comma
id|bustime
comma
id|new_alloc
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_USB_BANDWIDTH
id|bustime
op_assign
op_minus
id|ENOSPC
suffix:semicolon
multiline_comment|/* report error */
macro_line|#endif
)brace
r_return
id|bustime
suffix:semicolon
)brace
DECL|variable|usb_check_bandwidth
id|EXPORT_SYMBOL
(paren
id|usb_check_bandwidth
)paren
suffix:semicolon
multiline_comment|/**&n; * usb_claim_bandwidth - records bandwidth for a periodic transfer&n; * @dev: source/target of request&n; * @urb: request (urb-&gt;dev == dev)&n; * @bustime: bandwidth consumed, in (average) microseconds per frame&n; * @isoc: true iff the request is isochronous&n; *&n; * Bus bandwidth reservations are recorded purely for diagnostic purposes.&n; * HCDs are expected not to overcommit periodic bandwidth, and to record such&n; * reservations whenever endpoints are added to the periodic schedule.&n; *&n; * FIXME averaging per-frame is suboptimal.  Better to sum over the HCD&squot;s&n; * entire periodic schedule ... 32 frames for OHCI, 1024 for UHCI, settable&n; * for EHCI (256/512/1024 frames, default 1024) and have the bus expose how&n; * large its periodic schedule is.&n; */
DECL|function|usb_claim_bandwidth
r_void
id|usb_claim_bandwidth
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|bustime
comma
r_int
id|isoc
)paren
(brace
id|dev-&gt;bus-&gt;bandwidth_allocated
op_add_assign
id|bustime
suffix:semicolon
r_if
c_cond
(paren
id|isoc
)paren
id|dev-&gt;bus-&gt;bandwidth_isoc_reqs
op_increment
suffix:semicolon
r_else
id|dev-&gt;bus-&gt;bandwidth_int_reqs
op_increment
suffix:semicolon
id|urb-&gt;bandwidth
op_assign
id|bustime
suffix:semicolon
macro_line|#ifdef USB_BANDWIDTH_MESSAGES
id|dbg
(paren
l_string|&quot;bandwidth alloc increased by %d (%s) to %d for %d requesters&quot;
comma
id|bustime
comma
id|isoc
ques
c_cond
l_string|&quot;ISOC&quot;
suffix:colon
l_string|&quot;INTR&quot;
comma
id|dev-&gt;bus-&gt;bandwidth_allocated
comma
id|dev-&gt;bus-&gt;bandwidth_int_reqs
op_plus
id|dev-&gt;bus-&gt;bandwidth_isoc_reqs
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|variable|usb_claim_bandwidth
id|EXPORT_SYMBOL
(paren
id|usb_claim_bandwidth
)paren
suffix:semicolon
multiline_comment|/**&n; * usb_release_bandwidth - reverses effect of usb_claim_bandwidth()&n; * @dev: source/target of request&n; * @urb: request (urb-&gt;dev == dev)&n; * @isoc: true iff the request is isochronous&n; *&n; * This records that previously allocated bandwidth has been released.&n; * Bandwidth is released when endpoints are removed from the host controller&squot;s&n; * periodic schedule.&n; */
DECL|function|usb_release_bandwidth
r_void
id|usb_release_bandwidth
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_struct
id|urb
op_star
id|urb
comma
r_int
id|isoc
)paren
(brace
id|dev-&gt;bus-&gt;bandwidth_allocated
op_sub_assign
id|urb-&gt;bandwidth
suffix:semicolon
r_if
c_cond
(paren
id|isoc
)paren
id|dev-&gt;bus-&gt;bandwidth_isoc_reqs
op_decrement
suffix:semicolon
r_else
id|dev-&gt;bus-&gt;bandwidth_int_reqs
op_decrement
suffix:semicolon
macro_line|#ifdef USB_BANDWIDTH_MESSAGES
id|dbg
(paren
l_string|&quot;bandwidth alloc reduced by %d (%s) to %d for %d requesters&quot;
comma
id|urb-&gt;bandwidth
comma
id|isoc
ques
c_cond
l_string|&quot;ISOC&quot;
suffix:colon
l_string|&quot;INTR&quot;
comma
id|dev-&gt;bus-&gt;bandwidth_allocated
comma
id|dev-&gt;bus-&gt;bandwidth_int_reqs
op_plus
id|dev-&gt;bus-&gt;bandwidth_isoc_reqs
)paren
suffix:semicolon
macro_line|#endif
id|urb-&gt;bandwidth
op_assign
l_int|0
suffix:semicolon
)brace
DECL|variable|usb_release_bandwidth
id|EXPORT_SYMBOL
(paren
id|usb_release_bandwidth
)paren
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/*&n; * Generic HC operations.&n; */
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* called from khubd, or root hub init threads for hcd-private init */
DECL|function|hcd_alloc_dev
r_static
r_int
id|hcd_alloc_dev
(paren
r_struct
id|usb_device
op_star
id|udev
)paren
(brace
r_struct
id|hcd_dev
op_star
id|dev
suffix:semicolon
r_struct
id|usb_hcd
op_star
id|hcd
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|udev
op_logical_or
id|udev-&gt;hcpriv
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|udev-&gt;bus
op_logical_or
op_logical_neg
id|udev-&gt;bus-&gt;hcpriv
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|hcd
op_assign
id|udev-&gt;bus-&gt;hcpriv
suffix:semicolon
r_if
c_cond
(paren
id|hcd-&gt;state
op_eq
id|USB_STATE_QUIESCING
)paren
r_return
op_minus
id|ENOLINK
suffix:semicolon
id|dev
op_assign
(paren
r_struct
id|hcd_dev
op_star
)paren
id|kmalloc
(paren
r_sizeof
op_star
id|dev
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
(paren
id|dev
comma
l_int|0
comma
r_sizeof
op_star
id|dev
)paren
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|dev-&gt;dev_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|dev-&gt;urb_list
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|hcd_data_lock
comma
id|flags
)paren
suffix:semicolon
id|list_add
(paren
op_amp
id|dev-&gt;dev_list
comma
op_amp
id|hcd-&gt;dev_list
)paren
suffix:semicolon
singleline_comment|// refcount is implicit
id|udev-&gt;hcpriv
op_assign
id|dev
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|hcd_data_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|urb_unlink
r_static
r_void
id|urb_unlink
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|usb_device
op_star
id|dev
suffix:semicolon
multiline_comment|/* Release any periodic transfer bandwidth */
r_if
c_cond
(paren
id|urb-&gt;bandwidth
)paren
id|usb_release_bandwidth
(paren
id|urb-&gt;dev
comma
id|urb
comma
id|usb_pipeisoc
(paren
id|urb-&gt;pipe
)paren
)paren
suffix:semicolon
multiline_comment|/* clear all state linking urb to this dev (and hcd) */
id|spin_lock_irqsave
(paren
op_amp
id|hcd_data_lock
comma
id|flags
)paren
suffix:semicolon
id|list_del_init
(paren
op_amp
id|urb-&gt;urb_list
)paren
suffix:semicolon
id|dev
op_assign
id|urb-&gt;dev
suffix:semicolon
id|urb-&gt;dev
op_assign
l_int|NULL
suffix:semicolon
id|usb_put_dev
(paren
id|dev
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|hcd_data_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* may be called in any context with a valid urb-&gt;dev usecount&n; * caller surrenders &quot;ownership&quot; of urb&n; * expects usb_submit_urb() to have sanity checked and conditioned all&n; * inputs in the urb&n; */
DECL|function|hcd_submit_urb
r_static
r_int
id|hcd_submit_urb
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|mem_flags
)paren
(brace
r_int
id|status
suffix:semicolon
r_struct
id|usb_hcd
op_star
id|hcd
op_assign
id|urb-&gt;dev-&gt;bus-&gt;hcpriv
suffix:semicolon
r_struct
id|hcd_dev
op_star
id|dev
op_assign
id|urb-&gt;dev-&gt;hcpriv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hcd
op_logical_or
op_logical_neg
id|dev
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME:  make urb timeouts be generic, keeping the HCD cores&n;&t; * as simple as possible.&n;&t; */
singleline_comment|// NOTE:  a generic device/urb monitoring hook would go here.
singleline_comment|// hcd_monitor_hook(MONITOR_URB_SUBMIT, urb)
singleline_comment|// It would catch submission paths for all urbs.
multiline_comment|/*&n;&t; * Atomically queue the urb,  first to our records, then to the HCD.&n;&t; * Access to urb-&gt;status is controlled by urb-&gt;lock ... changes on&n;&t; * i/o completion (normal or fault) or unlinking.&n;&t; */
singleline_comment|// FIXME:  verify that quiescing hc works right (RH cleans up)
id|spin_lock_irqsave
(paren
op_amp
id|hcd_data_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HCD_IS_RUNNING
(paren
id|hcd-&gt;state
)paren
op_logical_and
id|hcd-&gt;state
op_ne
id|USB_STATE_QUIESCING
)paren
(brace
id|usb_get_dev
(paren
id|urb-&gt;dev
)paren
suffix:semicolon
id|list_add
(paren
op_amp
id|urb-&gt;urb_list
comma
op_amp
id|dev-&gt;urb_list
)paren
suffix:semicolon
id|status
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|INIT_LIST_HEAD
(paren
op_amp
id|urb-&gt;urb_list
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|ESHUTDOWN
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|hcd_data_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_return
id|status
suffix:semicolon
multiline_comment|/* increment urb&squot;s reference count as part of giving it to the HCD&n;&t; * (which now controls it).  HCD guarantees that it either returns&n;&t; * an error or calls giveback(), but not both.&n;&t; */
id|urb
op_assign
id|usb_get_urb
(paren
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;dev
op_eq
id|hcd-&gt;self.root_hub
)paren
id|status
op_assign
id|rh_urb_enqueue
(paren
id|hcd
comma
id|urb
)paren
suffix:semicolon
r_else
id|status
op_assign
id|hcd-&gt;driver-&gt;urb_enqueue
(paren
id|hcd
comma
id|urb
comma
id|mem_flags
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* called in any context */
DECL|function|hcd_get_frame_number
r_static
r_int
id|hcd_get_frame_number
(paren
r_struct
id|usb_device
op_star
id|udev
)paren
(brace
r_struct
id|usb_hcd
op_star
id|hcd
op_assign
(paren
r_struct
id|usb_hcd
op_star
)paren
id|udev-&gt;bus-&gt;hcpriv
suffix:semicolon
r_return
id|hcd-&gt;driver-&gt;get_frame_number
(paren
id|hcd
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|struct|completion_splice
r_struct
id|completion_splice
(brace
singleline_comment|// modified urb context:
multiline_comment|/* did we complete? */
DECL|member|done
r_struct
id|completion
id|done
suffix:semicolon
multiline_comment|/* original urb data */
DECL|member|complete
r_void
(paren
op_star
id|complete
)paren
(paren
r_struct
id|urb
op_star
)paren
suffix:semicolon
DECL|member|context
r_void
op_star
id|context
suffix:semicolon
)brace
suffix:semicolon
DECL|function|unlink_complete
r_static
r_void
id|unlink_complete
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|completion_splice
op_star
id|splice
suffix:semicolon
id|splice
op_assign
(paren
r_struct
id|completion_splice
op_star
)paren
id|urb-&gt;context
suffix:semicolon
multiline_comment|/* issue original completion call */
id|urb-&gt;complete
op_assign
id|splice-&gt;complete
suffix:semicolon
id|urb-&gt;context
op_assign
id|splice-&gt;context
suffix:semicolon
id|urb-&gt;complete
(paren
id|urb
)paren
suffix:semicolon
multiline_comment|/* then let the synchronous unlink call complete */
id|complete
(paren
op_amp
id|splice-&gt;done
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * called in any context; note ASYNC_UNLINK restrictions&n; *&n; * caller guarantees urb won&squot;t be recycled till both unlink()&n; * and the urb&squot;s completion function return&n; */
DECL|function|hcd_unlink_urb
r_static
r_int
id|hcd_unlink_urb
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|hcd_dev
op_star
id|dev
suffix:semicolon
r_struct
id|usb_hcd
op_star
id|hcd
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|completion_splice
id|splice
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * we contend for urb-&gt;status with the hcd core,&n;&t; * which changes it while returning the urb.&n;&t; *&n;&t; * Caller guaranteed that the urb pointer hasn&squot;t been freed, and&n;&t; * that it was submitted.  But as a rule it can&squot;t know whether or&n;&t; * not it&squot;s already been unlinked ... so we respect the reversed&n;&t; * lock sequence needed for the usb_hcd_giveback_urb() code paths&n;&t; * (urb lock, then hcd_data_lock) in case some other CPU is now&n;&t; * unlinking it.&n;&t; */
id|spin_lock_irqsave
(paren
op_amp
id|urb-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|spin_lock
(paren
op_amp
id|hcd_data_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb-&gt;hcpriv
op_logical_or
id|urb-&gt;transfer_flags
op_amp
id|USB_TIMEOUT_KILLED
)paren
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|urb-&gt;dev
op_logical_or
op_logical_neg
id|urb-&gt;dev-&gt;bus
)paren
(brace
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/* giveback clears dev; non-null means it&squot;s linked at this level */
id|dev
op_assign
id|urb-&gt;dev-&gt;hcpriv
suffix:semicolon
id|hcd
op_assign
id|urb-&gt;dev-&gt;bus-&gt;hcpriv
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
op_logical_or
op_logical_neg
id|hcd
)paren
(brace
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/* For non-periodic transfers, any status except -EINPROGRESS means&n;&t; * the HCD has already started to unlink this URB from the hardware.&n;&t; * In that case, there&squot;s no more work to do.&n;&t; *&n;&t; * For periodic transfers, this is the only way to trigger unlinking&n;&t; * from the hardware.  Since we (currently) overload urb-&gt;status to&n;&t; * tell the driver to unlink, error status might get clobbered ...&n;&t; * unless that transfer hasn&squot;t yet restarted.  One such case is when&n;&t; * the URB gets unlinked from its completion handler.&n;&t; *&n;&t; * FIXME use an URB_UNLINKED flag to match URB_TIMEOUT_KILLED&n;&t; */
r_switch
c_cond
(paren
id|usb_pipetype
(paren
id|urb-&gt;pipe
)paren
)paren
(brace
r_case
id|PIPE_CONTROL
suffix:colon
r_case
id|PIPE_BULK
suffix:colon
r_if
c_cond
(paren
id|urb-&gt;status
op_ne
op_minus
id|EINPROGRESS
)paren
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
)brace
multiline_comment|/* maybe set up to block on completion notification */
r_if
c_cond
(paren
(paren
id|urb-&gt;transfer_flags
op_amp
id|USB_TIMEOUT_KILLED
)paren
)paren
id|urb-&gt;status
op_assign
op_minus
id|ETIMEDOUT
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|urb-&gt;transfer_flags
op_amp
id|USB_ASYNC_UNLINK
)paren
)paren
(brace
r_if
c_cond
(paren
id|in_interrupt
(paren
)paren
)paren
(brace
id|dbg
(paren
l_string|&quot;non-async unlink in_interrupt&quot;
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EWOULDBLOCK
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/* synchronous unlink: block till we see the completion */
id|init_completion
(paren
op_amp
id|splice.done
)paren
suffix:semicolon
id|splice.complete
op_assign
id|urb-&gt;complete
suffix:semicolon
id|splice.context
op_assign
id|urb-&gt;context
suffix:semicolon
id|urb-&gt;complete
op_assign
id|unlink_complete
suffix:semicolon
id|urb-&gt;context
op_assign
op_amp
id|splice
suffix:semicolon
id|urb-&gt;status
op_assign
op_minus
id|ENOENT
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* asynchronous unlink */
id|urb-&gt;status
op_assign
op_minus
id|ECONNRESET
suffix:semicolon
)brace
id|spin_unlock
(paren
op_amp
id|hcd_data_lock
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|urb-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb
op_eq
(paren
r_struct
id|urb
op_star
)paren
id|hcd-&gt;rh_timer.data
)paren
(brace
id|usb_rh_status_dequeue
(paren
id|hcd
comma
id|urb
)paren
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|retval
op_assign
id|hcd-&gt;driver-&gt;urb_dequeue
(paren
id|hcd
comma
id|urb
)paren
suffix:semicolon
singleline_comment|// FIXME:  if retval and we tried to splice, whoa!!
r_if
c_cond
(paren
id|retval
op_logical_and
id|urb-&gt;status
op_eq
op_minus
id|ENOENT
)paren
id|err
(paren
l_string|&quot;whoa! retval %d&quot;
comma
id|retval
)paren
suffix:semicolon
)brace
multiline_comment|/* block till giveback, if needed */
r_if
c_cond
(paren
op_logical_neg
(paren
id|urb-&gt;transfer_flags
op_amp
(paren
id|USB_ASYNC_UNLINK
op_or
id|USB_TIMEOUT_KILLED
)paren
)paren
op_logical_and
id|HCD_IS_RUNNING
(paren
id|hcd-&gt;state
)paren
op_logical_and
op_logical_neg
id|retval
)paren
(brace
id|dbg
(paren
l_string|&quot;%s: wait for giveback urb %p&quot;
comma
id|hcd-&gt;self.bus_name
comma
id|urb
)paren
suffix:semicolon
id|wait_for_completion
(paren
op_amp
id|splice.done
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|urb-&gt;transfer_flags
op_amp
id|USB_ASYNC_UNLINK
)paren
op_logical_and
id|retval
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|EINPROGRESS
suffix:semicolon
)brace
r_goto
id|bye
suffix:semicolon
id|done
suffix:colon
id|spin_unlock
(paren
op_amp
id|hcd_data_lock
)paren
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|urb-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|bye
suffix:colon
r_if
c_cond
(paren
id|retval
)paren
id|dbg
(paren
l_string|&quot;%s: hcd_unlink_urb fail %d&quot;
comma
id|hcd
ques
c_cond
id|hcd-&gt;self.bus_name
suffix:colon
l_string|&quot;(no bus?)&quot;
comma
id|retval
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* called by khubd, rmmod, apmd, or other thread for hcd-private cleanup */
singleline_comment|// FIXME:  likely best to have explicit per-setting (config+alt)
singleline_comment|// setup primitives in the usbcore-to-hcd driver API, so nothing
singleline_comment|// is implicit.  kernel 2.5 needs a bunch of config cleanup...
DECL|function|hcd_free_dev
r_static
r_int
id|hcd_free_dev
(paren
r_struct
id|usb_device
op_star
id|udev
)paren
(brace
r_struct
id|hcd_dev
op_star
id|dev
suffix:semicolon
r_struct
id|usb_hcd
op_star
id|hcd
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|udev
op_logical_or
op_logical_neg
id|udev-&gt;hcpriv
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|udev-&gt;bus
op_logical_or
op_logical_neg
id|udev-&gt;bus-&gt;hcpriv
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
singleline_comment|// should udev-&gt;devnum == -1 ??
id|dev
op_assign
id|udev-&gt;hcpriv
suffix:semicolon
id|hcd
op_assign
id|udev-&gt;bus-&gt;hcpriv
suffix:semicolon
multiline_comment|/* device driver problem with refcounts? */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|dev-&gt;urb_list
)paren
)paren
(brace
id|dbg
(paren
l_string|&quot;free busy dev, %s devnum %d (bug!)&quot;
comma
id|hcd-&gt;self.bus_name
comma
id|udev-&gt;devnum
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hcd-&gt;driver-&gt;free_config
)paren
id|hcd-&gt;driver-&gt;free_config
(paren
id|hcd
comma
id|udev
)paren
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|hcd_data_lock
comma
id|flags
)paren
suffix:semicolon
id|list_del
(paren
op_amp
id|dev-&gt;dev_list
)paren
suffix:semicolon
id|udev-&gt;hcpriv
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|hcd_data_lock
comma
id|flags
)paren
suffix:semicolon
id|kfree
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_hcd_operations - adapts usb_bus framework to HCD framework (bus glue)&n; *&n; * When registering a USB bus through the HCD framework code, use this&n; * usb_operations vector.  The PCI glue layer does so automatically; only&n; * bus glue for non-PCI system busses will need to use this.&n; */
DECL|variable|usb_hcd_operations
r_struct
id|usb_operations
id|usb_hcd_operations
op_assign
(brace
id|allocate
suffix:colon
id|hcd_alloc_dev
comma
id|get_frame_number
suffix:colon
id|hcd_get_frame_number
comma
id|submit_urb
suffix:colon
id|hcd_submit_urb
comma
id|unlink_urb
suffix:colon
id|hcd_unlink_urb
comma
id|deallocate
suffix:colon
id|hcd_free_dev
comma
)brace
suffix:semicolon
DECL|variable|usb_hcd_operations
id|EXPORT_SYMBOL
(paren
id|usb_hcd_operations
)paren
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/**&n; * usb_hcd_giveback_urb - return URB from HCD to device driver&n; * @hcd: host controller returning the URB&n; * @urb: urb being returned to the USB device driver.&n; * Context: in_interrupt()&n; *&n; * This hands the URB from HCD to its USB device driver, using its&n; * completion function.  The HCD has freed all per-urb resources&n; * (and is done using urb-&gt;hcpriv).  It also released all HCD locks;&n; * the device driver won&squot;t cause deadlocks if it resubmits this URB,&n; * and won&squot;t confuse things by modifying and resubmitting this one.&n; * Bandwidth and other resources will be deallocated.&n; *&n; * HCDs must not use this for periodic URBs that are still scheduled&n; * and will be reissued.  They should just call their completion handlers&n; * until the urb is returned to the device driver by unlinking.&n; */
DECL|function|usb_hcd_giveback_urb
r_void
id|usb_hcd_giveback_urb
(paren
r_struct
id|usb_hcd
op_star
id|hcd
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
id|urb_unlink
(paren
id|urb
)paren
suffix:semicolon
singleline_comment|// NOTE:  a generic device/urb monitoring hook would go here.
singleline_comment|// hcd_monitor_hook(MONITOR_URB_FINISH, urb, dev)
singleline_comment|// It would catch exit/unlink paths for all urbs, but non-exit
singleline_comment|// completions for periodic urbs need hooks inside the HCD.
singleline_comment|// hcd_monitor_hook(MONITOR_URB_UPDATE, urb, dev)
r_if
c_cond
(paren
id|urb-&gt;status
)paren
id|dbg
(paren
l_string|&quot;giveback urb %p status %d len %d&quot;
comma
id|urb
comma
id|urb-&gt;status
comma
id|urb-&gt;actual_length
)paren
suffix:semicolon
multiline_comment|/* pass ownership to the completion handler */
id|urb-&gt;complete
(paren
id|urb
)paren
suffix:semicolon
id|usb_put_urb
(paren
id|urb
)paren
suffix:semicolon
)brace
DECL|variable|usb_hcd_giveback_urb
id|EXPORT_SYMBOL
(paren
id|usb_hcd_giveback_urb
)paren
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/**&n; * usb_hcd_irq - hook IRQs to HCD framework (bus glue)&n; * @irq: the IRQ being raised&n; * @__hcd: pointer to the HCD whose IRQ is beinng signaled&n; * @r: saved hardware registers (not passed to HCD)&n; *&n; * When registering a USB bus through the HCD framework code, use this&n; * to handle interrupts.  The PCI glue layer does so automatically; only&n; * bus glue for non-PCI system busses will need to use this.&n; */
DECL|function|usb_hcd_irq
r_void
id|usb_hcd_irq
(paren
r_int
id|irq
comma
r_void
op_star
id|__hcd
comma
r_struct
id|pt_regs
op_star
id|r
)paren
(brace
r_struct
id|usb_hcd
op_star
id|hcd
op_assign
id|__hcd
suffix:semicolon
r_int
id|start
op_assign
id|hcd-&gt;state
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
id|hcd-&gt;state
op_eq
id|USB_STATE_HALT
)paren
)paren
multiline_comment|/* irq sharing? */
r_return
suffix:semicolon
id|hcd-&gt;driver-&gt;irq
(paren
id|hcd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hcd-&gt;state
op_ne
id|start
op_logical_and
id|hcd-&gt;state
op_eq
id|USB_STATE_HALT
)paren
id|usb_hc_died
(paren
id|hcd
)paren
suffix:semicolon
)brace
DECL|variable|usb_hcd_irq
id|EXPORT_SYMBOL
(paren
id|usb_hcd_irq
)paren
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/**&n; * usb_hc_died - report abnormal shutdown of a host controller (bus glue)&n; * @hcd: pointer to the HCD representing the controller&n; *&n; * This is called by bus glue to report a USB host controller that died&n; * while operations may still have been pending.  It&squot;s called automatically&n; * by the PCI glue, so only glue for non-PCI busses should need to call it. &n; */
DECL|function|usb_hc_died
r_void
id|usb_hc_died
(paren
r_struct
id|usb_hcd
op_star
id|hcd
)paren
(brace
r_struct
id|list_head
op_star
id|devlist
comma
op_star
id|urblist
suffix:semicolon
r_struct
id|hcd_dev
op_star
id|dev
suffix:semicolon
r_struct
id|urb
op_star
id|urb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* flag every pending urb as done */
id|spin_lock_irqsave
(paren
op_amp
id|hcd_data_lock
comma
id|flags
)paren
suffix:semicolon
id|list_for_each
(paren
id|devlist
comma
op_amp
id|hcd-&gt;dev_list
)paren
(brace
id|dev
op_assign
id|list_entry
(paren
id|devlist
comma
r_struct
id|hcd_dev
comma
id|dev_list
)paren
suffix:semicolon
id|list_for_each
(paren
id|urblist
comma
op_amp
id|dev-&gt;urb_list
)paren
(brace
id|urb
op_assign
id|list_entry
(paren
id|urblist
comma
r_struct
id|urb
comma
id|urb_list
)paren
suffix:semicolon
id|dbg
(paren
l_string|&quot;shutdown %s urb %p pipe %x, current status %d&quot;
comma
id|hcd-&gt;self.bus_name
comma
id|urb
comma
id|urb-&gt;pipe
comma
id|urb-&gt;status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
id|urb-&gt;status
op_assign
op_minus
id|ESHUTDOWN
suffix:semicolon
)brace
)brace
id|urb
op_assign
(paren
r_struct
id|urb
op_star
)paren
id|hcd-&gt;rh_timer.data
suffix:semicolon
r_if
c_cond
(paren
id|urb
)paren
id|urb-&gt;status
op_assign
op_minus
id|ESHUTDOWN
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|hcd_data_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb
)paren
id|usb_rh_status_dequeue
(paren
id|hcd
comma
id|urb
)paren
suffix:semicolon
id|hcd-&gt;driver-&gt;stop
(paren
id|hcd
)paren
suffix:semicolon
)brace
DECL|variable|usb_hc_died
id|EXPORT_SYMBOL
(paren
id|usb_hc_died
)paren
suffix:semicolon
eof
