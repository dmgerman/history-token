multiline_comment|/*&n; * message.c - synchronous message handling&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#ifdef CONFIG_USB_DEBUG
DECL|macro|DEBUG
mdefine_line|#define DEBUG
macro_line|#else
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#endif
macro_line|#include &lt;linux/pci.h&gt;&t;/* for scatterlist macros */
macro_line|#include &lt;linux/usb.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &quot;hcd.h&quot;&t;/* for usbcore internals */
macro_line|#include &quot;usb.h&quot;
DECL|function|usb_api_blocking_completion
r_static
r_void
id|usb_api_blocking_completion
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|complete
c_func
(paren
(paren
r_struct
id|completion
op_star
)paren
id|urb-&gt;context
)paren
suffix:semicolon
)brace
DECL|function|timeout_kill
r_static
r_void
id|timeout_kill
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|urb
op_star
id|urb
op_assign
(paren
r_struct
id|urb
op_star
)paren
id|data
suffix:semicolon
id|usb_unlink_urb
c_func
(paren
id|urb
)paren
suffix:semicolon
)brace
singleline_comment|// Starts urb and waits for completion or timeout
singleline_comment|// note that this call is NOT interruptible, while
singleline_comment|// many device driver i/o requests should be interruptible
DECL|function|usb_start_wait_urb
r_static
r_int
id|usb_start_wait_urb
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|timeout
comma
r_int
op_star
id|actual_length
)paren
(brace
r_struct
id|completion
id|done
suffix:semicolon
r_struct
id|timer_list
id|timer
suffix:semicolon
r_int
id|status
suffix:semicolon
id|init_completion
c_func
(paren
op_amp
id|done
)paren
suffix:semicolon
id|urb-&gt;context
op_assign
op_amp
id|done
suffix:semicolon
id|urb-&gt;transfer_flags
op_or_assign
id|URB_ASYNC_UNLINK
suffix:semicolon
id|urb-&gt;actual_length
op_assign
l_int|0
suffix:semicolon
id|status
op_assign
id|usb_submit_urb
c_func
(paren
id|urb
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|timeout
OG
l_int|0
)paren
(brace
id|init_timer
c_func
(paren
op_amp
id|timer
)paren
suffix:semicolon
id|timer.expires
op_assign
id|jiffies
op_plus
id|timeout
suffix:semicolon
id|timer.data
op_assign
(paren
r_int
r_int
)paren
id|urb
suffix:semicolon
id|timer.function
op_assign
id|timeout_kill
suffix:semicolon
multiline_comment|/* grr.  timeout _should_ include submit delays. */
id|add_timer
c_func
(paren
op_amp
id|timer
)paren
suffix:semicolon
)brace
id|wait_for_completion
c_func
(paren
op_amp
id|done
)paren
suffix:semicolon
id|status
op_assign
id|urb-&gt;status
suffix:semicolon
multiline_comment|/* note:  HCDs return ETIMEDOUT for other reasons too */
r_if
c_cond
(paren
id|status
op_eq
op_minus
id|ECONNRESET
)paren
(brace
id|dev_warn
c_func
(paren
op_amp
id|urb-&gt;dev-&gt;dev
comma
l_string|&quot;%s timed out on ep%d%s&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|usb_pipeendpoint
c_func
(paren
id|urb-&gt;pipe
)paren
comma
id|usb_pipein
c_func
(paren
id|urb-&gt;pipe
)paren
ques
c_cond
l_string|&quot;in&quot;
suffix:colon
l_string|&quot;out&quot;
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|ETIMEDOUT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|timeout
OG
l_int|0
)paren
id|del_timer_sync
c_func
(paren
op_amp
id|timer
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|actual_length
)paren
op_star
id|actual_length
op_assign
id|urb-&gt;actual_length
suffix:semicolon
id|usb_free_urb
c_func
(paren
id|urb
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------*/
singleline_comment|// returns status (negative) or length (positive)
DECL|function|usb_internal_control_msg
r_int
id|usb_internal_control_msg
c_func
(paren
r_struct
id|usb_device
op_star
id|usb_dev
comma
r_int
r_int
id|pipe
comma
r_struct
id|usb_ctrlrequest
op_star
id|cmd
comma
r_void
op_star
id|data
comma
r_int
id|len
comma
r_int
id|timeout
)paren
(brace
r_struct
id|urb
op_star
id|urb
suffix:semicolon
r_int
id|retv
suffix:semicolon
r_int
id|length
suffix:semicolon
id|urb
op_assign
id|usb_alloc_urb
c_func
(paren
l_int|0
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|usb_fill_control_urb
c_func
(paren
id|urb
comma
id|usb_dev
comma
id|pipe
comma
(paren
r_int
r_char
op_star
)paren
id|cmd
comma
id|data
comma
id|len
comma
id|usb_api_blocking_completion
comma
l_int|NULL
)paren
suffix:semicolon
id|retv
op_assign
id|usb_start_wait_urb
c_func
(paren
id|urb
comma
id|timeout
comma
op_amp
id|length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retv
OL
l_int|0
)paren
r_return
id|retv
suffix:semicolon
r_else
r_return
id|length
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;usb_control_msg - Builds a control urb, sends it off and waits for completion&n; *&t;@dev: pointer to the usb device to send the message to&n; *&t;@pipe: endpoint &quot;pipe&quot; to send the message to&n; *&t;@request: USB message request value&n; *&t;@requesttype: USB message request type value&n; *&t;@value: USB message value&n; *&t;@index: USB message index value&n; *&t;@data: pointer to the data to send&n; *&t;@size: length in bytes of the data to send&n; *&t;@timeout: time in jiffies to wait for the message to complete before&n; *&t;&t;timing out (if 0 the wait is forever)&n; *&t;Context: !in_interrupt ()&n; *&n; *&t;This function sends a simple control message to a specified endpoint&n; *&t;and waits for the message to complete, or timeout.&n; *&t;&n; *&t;If successful, it returns the number of bytes transferred, otherwise a negative error number.&n; *&n; *&t;Don&squot;t use this function from within an interrupt context, like a&n; *&t;bottom half handler.  If you need an asynchronous message, or need to send&n; *&t;a message from within interrupt context, use usb_submit_urb()&n; *      If a thread in your driver uses this call, make sure your disconnect()&n; *      method can wait for it to complete.  Since you don&squot;t have a handle on&n; *      the URB used, you can&squot;t cancel the request.&n; */
DECL|function|usb_control_msg
r_int
id|usb_control_msg
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|pipe
comma
id|__u8
id|request
comma
id|__u8
id|requesttype
comma
id|__u16
id|value
comma
id|__u16
id|index
comma
r_void
op_star
id|data
comma
id|__u16
id|size
comma
r_int
id|timeout
)paren
(brace
r_struct
id|usb_ctrlrequest
op_star
id|dr
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|usb_ctrlrequest
)paren
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dr
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|dr-&gt;bRequestType
op_assign
id|requesttype
suffix:semicolon
id|dr-&gt;bRequest
op_assign
id|request
suffix:semicolon
id|dr-&gt;wValue
op_assign
id|cpu_to_le16p
c_func
(paren
op_amp
id|value
)paren
suffix:semicolon
id|dr-&gt;wIndex
op_assign
id|cpu_to_le16p
c_func
(paren
op_amp
id|index
)paren
suffix:semicolon
id|dr-&gt;wLength
op_assign
id|cpu_to_le16p
c_func
(paren
op_amp
id|size
)paren
suffix:semicolon
singleline_comment|//dbg(&quot;usb_control_msg&quot;);&t;
id|ret
op_assign
id|usb_internal_control_msg
c_func
(paren
id|dev
comma
id|pipe
comma
id|dr
comma
id|data
comma
id|size
comma
id|timeout
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dr
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;usb_bulk_msg - Builds a bulk urb, sends it off and waits for completion&n; *&t;@usb_dev: pointer to the usb device to send the message to&n; *&t;@pipe: endpoint &quot;pipe&quot; to send the message to&n; *&t;@data: pointer to the data to send&n; *&t;@len: length in bytes of the data to send&n; *&t;@actual_length: pointer to a location to put the actual length transferred in bytes&n; *&t;@timeout: time in jiffies to wait for the message to complete before&n; *&t;&t;timing out (if 0 the wait is forever)&n; *&t;Context: !in_interrupt ()&n; *&n; *&t;This function sends a simple bulk message to a specified endpoint&n; *&t;and waits for the message to complete, or timeout.&n; *&t;&n; *&t;If successful, it returns 0, otherwise a negative error number.&n; *&t;The number of actual bytes transferred will be stored in the &n; *&t;actual_length paramater.&n; *&n; *&t;Don&squot;t use this function from within an interrupt context, like a&n; *&t;bottom half handler.  If you need an asynchronous message, or need to&n; *&t;send a message from within interrupt context, use usb_submit_urb()&n; *      If a thread in your driver uses this call, make sure your disconnect()&n; *      method can wait for it to complete.  Since you don&squot;t have a handle on&n; *      the URB used, you can&squot;t cancel the request.&n; */
DECL|function|usb_bulk_msg
r_int
id|usb_bulk_msg
c_func
(paren
r_struct
id|usb_device
op_star
id|usb_dev
comma
r_int
r_int
id|pipe
comma
r_void
op_star
id|data
comma
r_int
id|len
comma
r_int
op_star
id|actual_length
comma
r_int
id|timeout
)paren
(brace
r_struct
id|urb
op_star
id|urb
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|urb
op_assign
id|usb_alloc_urb
c_func
(paren
l_int|0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|usb_fill_bulk_urb
c_func
(paren
id|urb
comma
id|usb_dev
comma
id|pipe
comma
id|data
comma
id|len
comma
id|usb_api_blocking_completion
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|usb_start_wait_urb
c_func
(paren
id|urb
comma
id|timeout
comma
id|actual_length
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------*/
DECL|function|sg_clean
r_static
r_void
id|sg_clean
(paren
r_struct
id|usb_sg_request
op_star
id|io
)paren
(brace
r_if
c_cond
(paren
id|io-&gt;urbs
)paren
(brace
r_while
c_loop
(paren
id|io-&gt;entries
op_decrement
)paren
id|usb_free_urb
(paren
id|io-&gt;urbs
(braket
id|io-&gt;entries
)braket
)paren
suffix:semicolon
id|kfree
(paren
id|io-&gt;urbs
)paren
suffix:semicolon
id|io-&gt;urbs
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|io-&gt;dev-&gt;dev.dma_mask
op_ne
l_int|0
)paren
id|usb_buffer_unmap_sg
(paren
id|io-&gt;dev
comma
id|io-&gt;pipe
comma
id|io-&gt;sg
comma
id|io-&gt;nents
)paren
suffix:semicolon
id|io-&gt;dev
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|sg_complete
r_static
r_void
id|sg_complete
(paren
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|usb_sg_request
op_star
id|io
op_assign
(paren
r_struct
id|usb_sg_request
op_star
)paren
id|urb-&gt;context
suffix:semicolon
id|spin_lock
(paren
op_amp
id|io-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* In 2.5 we require hcds&squot; endpoint queues not to progress after fault&n;&t; * reports, until the completion callback (this!) returns.  That lets&n;&t; * device driver code (like this routine) unlink queued urbs first,&n;&t; * if it needs to, since the HC won&squot;t work on them at all.  So it&squot;s&n;&t; * not possible for page N+1 to overwrite page N, and so on.&n;&t; *&n;&t; * That&squot;s only for &quot;hard&quot; faults; &quot;soft&quot; faults (unlinks) sometimes&n;&t; * complete before the HCD can get requests away from hardware,&n;&t; * though never during cleanup after a hard fault.&n;&t; */
r_if
c_cond
(paren
id|io-&gt;status
op_logical_and
(paren
id|io-&gt;status
op_ne
op_minus
id|ECONNRESET
op_logical_or
id|urb-&gt;status
op_ne
op_minus
id|ECONNRESET
)paren
op_logical_and
id|urb-&gt;actual_length
)paren
(brace
id|dev_err
(paren
id|io-&gt;dev-&gt;bus-&gt;controller
comma
l_string|&quot;dev %s ep%d%s scatterlist error %d/%d&bslash;n&quot;
comma
id|io-&gt;dev-&gt;devpath
comma
id|usb_pipeendpoint
(paren
id|urb-&gt;pipe
)paren
comma
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
ques
c_cond
l_string|&quot;in&quot;
suffix:colon
l_string|&quot;out&quot;
comma
id|urb-&gt;status
comma
id|io-&gt;status
)paren
suffix:semicolon
singleline_comment|// BUG ();
)brace
r_if
c_cond
(paren
id|io-&gt;status
op_eq
l_int|0
op_logical_and
id|urb-&gt;status
op_logical_and
id|urb-&gt;status
op_ne
op_minus
id|ECONNRESET
)paren
(brace
r_int
id|i
comma
id|found
comma
id|status
suffix:semicolon
id|io-&gt;status
op_assign
id|urb-&gt;status
suffix:semicolon
multiline_comment|/* the previous urbs, and this one, completed already.&n;&t;&t; * unlink pending urbs so they won&squot;t rx/tx bad data.&n;&t;&t; * careful: unlink can sometimes be synchronous...&n;&t;&t; */
id|spin_unlock
(paren
op_amp
id|io-&gt;lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|found
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|io-&gt;entries
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|io-&gt;urbs
(braket
id|i
)braket
op_logical_or
op_logical_neg
id|io-&gt;urbs
(braket
id|i
)braket
op_member_access_from_pointer
id|dev
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|found
)paren
(brace
id|status
op_assign
id|usb_unlink_urb
(paren
id|io-&gt;urbs
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
op_minus
id|EINPROGRESS
op_logical_and
id|status
op_ne
op_minus
id|EBUSY
)paren
id|dev_err
(paren
op_amp
id|io-&gt;dev-&gt;dev
comma
l_string|&quot;%s, unlink --&gt; %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|status
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|urb
op_eq
id|io-&gt;urbs
(braket
id|i
)braket
)paren
id|found
op_assign
l_int|1
suffix:semicolon
)brace
id|spin_lock
(paren
op_amp
id|io-&gt;lock
)paren
suffix:semicolon
)brace
id|urb-&gt;dev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* on the last completion, signal usb_sg_wait() */
id|io-&gt;bytes
op_add_assign
id|urb-&gt;actual_length
suffix:semicolon
id|io-&gt;count
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|io-&gt;count
)paren
id|complete
(paren
op_amp
id|io-&gt;complete
)paren
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|io-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_sg_init - initializes scatterlist-based bulk/interrupt I/O request&n; * @io: request block being initialized.  until usb_sg_wait() returns,&n; *&t;treat this as a pointer to an opaque block of memory,&n; * @dev: the usb device that will send or receive the data&n; * @pipe: endpoint &quot;pipe&quot; used to transfer the data&n; * @period: polling rate for interrupt endpoints, in frames or&n; * &t;(for high speed endpoints) microframes; ignored for bulk&n; * @sg: scatterlist entries&n; * @nents: how many entries in the scatterlist&n; * @length: how many bytes to send from the scatterlist, or zero to&n; * &t;send every byte identified in the list.&n; * @mem_flags: SLAB_* flags affecting memory allocations in this call&n; *&n; * Returns zero for success, else a negative errno value.  This initializes a&n; * scatter/gather request, allocating resources such as I/O mappings and urb&n; * memory (except maybe memory used by USB controller drivers).&n; *&n; * The request must be issued using usb_sg_wait(), which waits for the I/O to&n; * complete (or to be canceled) and then cleans up all resources allocated by&n; * usb_sg_init().&n; *&n; * The request may be canceled with usb_sg_cancel(), either before or after&n; * usb_sg_wait() is called.&n; */
DECL|function|usb_sg_init
r_int
id|usb_sg_init
(paren
r_struct
id|usb_sg_request
op_star
id|io
comma
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|pipe
comma
r_int
id|period
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
comma
r_int
id|length
comma
r_int
id|mem_flags
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|urb_flags
suffix:semicolon
r_int
id|dma
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|io
op_logical_or
op_logical_neg
id|dev
op_logical_or
op_logical_neg
id|sg
op_logical_or
id|usb_pipecontrol
(paren
id|pipe
)paren
op_logical_or
id|usb_pipeisoc
(paren
id|pipe
)paren
op_logical_or
id|nents
op_le
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_init
(paren
op_amp
id|io-&gt;lock
)paren
suffix:semicolon
id|io-&gt;dev
op_assign
id|dev
suffix:semicolon
id|io-&gt;pipe
op_assign
id|pipe
suffix:semicolon
id|io-&gt;sg
op_assign
id|sg
suffix:semicolon
id|io-&gt;nents
op_assign
id|nents
suffix:semicolon
multiline_comment|/* not all host controllers use DMA (like the mainstream pci ones);&n;&t; * they can use PIO (sl811) or be software over another transport.&n;&t; */
id|dma
op_assign
(paren
id|dev-&gt;dev.dma_mask
op_ne
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma
)paren
id|io-&gt;entries
op_assign
id|usb_buffer_map_sg
(paren
id|dev
comma
id|pipe
comma
id|sg
comma
id|nents
)paren
suffix:semicolon
r_else
id|io-&gt;entries
op_assign
id|nents
suffix:semicolon
multiline_comment|/* initialize all the urbs we&squot;ll use */
r_if
c_cond
(paren
id|io-&gt;entries
op_le
l_int|0
)paren
r_return
id|io-&gt;entries
suffix:semicolon
id|io-&gt;count
op_assign
id|io-&gt;entries
suffix:semicolon
id|io-&gt;urbs
op_assign
id|kmalloc
(paren
id|io-&gt;entries
op_star
r_sizeof
op_star
id|io-&gt;urbs
comma
id|mem_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|io-&gt;urbs
)paren
r_goto
id|nomem
suffix:semicolon
id|urb_flags
op_assign
id|URB_ASYNC_UNLINK
op_or
id|URB_NO_TRANSFER_DMA_MAP
op_or
id|URB_NO_INTERRUPT
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipein
(paren
id|pipe
)paren
)paren
id|urb_flags
op_or_assign
id|URB_SHORT_NOT_OK
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|io-&gt;entries
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|len
suffix:semicolon
id|io-&gt;urbs
(braket
id|i
)braket
op_assign
id|usb_alloc_urb
(paren
l_int|0
comma
id|mem_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|io-&gt;urbs
(braket
id|i
)braket
)paren
(brace
id|io-&gt;entries
op_assign
id|i
suffix:semicolon
r_goto
id|nomem
suffix:semicolon
)brace
id|io-&gt;urbs
(braket
id|i
)braket
op_member_access_from_pointer
id|dev
op_assign
l_int|NULL
suffix:semicolon
id|io-&gt;urbs
(braket
id|i
)braket
op_member_access_from_pointer
id|pipe
op_assign
id|pipe
suffix:semicolon
id|io-&gt;urbs
(braket
id|i
)braket
op_member_access_from_pointer
id|interval
op_assign
id|period
suffix:semicolon
id|io-&gt;urbs
(braket
id|i
)braket
op_member_access_from_pointer
id|transfer_flags
op_assign
id|urb_flags
suffix:semicolon
id|io-&gt;urbs
(braket
id|i
)braket
op_member_access_from_pointer
id|complete
op_assign
id|sg_complete
suffix:semicolon
id|io-&gt;urbs
(braket
id|i
)braket
op_member_access_from_pointer
id|context
op_assign
id|io
suffix:semicolon
id|io-&gt;urbs
(braket
id|i
)braket
op_member_access_from_pointer
id|status
op_assign
op_minus
id|EINPROGRESS
suffix:semicolon
id|io-&gt;urbs
(braket
id|i
)braket
op_member_access_from_pointer
id|actual_length
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dma
)paren
(brace
multiline_comment|/* hc may use _only_ transfer_dma */
id|io-&gt;urbs
(braket
id|i
)braket
op_member_access_from_pointer
id|transfer_dma
op_assign
id|sg_dma_address
(paren
id|sg
op_plus
id|i
)paren
suffix:semicolon
id|len
op_assign
id|sg_dma_len
(paren
id|sg
op_plus
id|i
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* hc may use _only_ transfer_buffer */
id|io-&gt;urbs
(braket
id|i
)braket
op_member_access_from_pointer
id|transfer_buffer
op_assign
id|page_address
(paren
id|sg
(braket
id|i
)braket
dot
id|page
)paren
op_plus
id|sg
(braket
id|i
)braket
dot
id|offset
suffix:semicolon
id|len
op_assign
id|sg
(braket
id|i
)braket
dot
id|length
suffix:semicolon
)brace
r_if
c_cond
(paren
id|length
)paren
(brace
id|len
op_assign
id|min_t
(paren
r_int
comma
id|len
comma
id|length
)paren
suffix:semicolon
id|length
op_sub_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|length
op_eq
l_int|0
)paren
id|io-&gt;entries
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
)brace
id|io-&gt;urbs
(braket
id|i
)braket
op_member_access_from_pointer
id|transfer_buffer_length
op_assign
id|len
suffix:semicolon
)brace
id|io-&gt;urbs
(braket
op_decrement
id|i
)braket
op_member_access_from_pointer
id|transfer_flags
op_and_assign
op_complement
id|URB_NO_INTERRUPT
suffix:semicolon
multiline_comment|/* transaction state */
id|io-&gt;status
op_assign
l_int|0
suffix:semicolon
id|io-&gt;bytes
op_assign
l_int|0
suffix:semicolon
id|init_completion
(paren
op_amp
id|io-&gt;complete
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|nomem
suffix:colon
id|sg_clean
(paren
id|io
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_sg_wait - synchronously execute scatter/gather request&n; * @io: request block handle, as initialized with usb_sg_init().&n; * &t;some fields become accessible when this call returns.&n; * Context: !in_interrupt ()&n; *&n; * This function blocks until the specified I/O operation completes.  It&n; * leverages the grouping of the related I/O requests to get good transfer&n; * rates, by queueing the requests.  At higher speeds, such queuing can&n; * significantly improve USB throughput.&n; *&n; * There are three kinds of completion for this function.&n; * (1) success, where io-&gt;status is zero.  The number of io-&gt;bytes&n; *     transferred is as requested.&n; * (2) error, where io-&gt;status is a negative errno value.  The number&n; *     of io-&gt;bytes transferred before the error is usually less&n; *     than requested, and can be nonzero.&n; * (3) cancelation, a type of error with status -ECONNRESET that&n; *     is initiated by usb_sg_cancel().&n; *&n; * When this function returns, all memory allocated through usb_sg_init() or&n; * this call will have been freed.  The request block parameter may still be&n; * passed to usb_sg_cancel(), or it may be freed.  It could also be&n; * reinitialized and then reused.&n; *&n; * Data Transfer Rates:&n; *&n; * Bulk transfers are valid for full or high speed endpoints.&n; * The best full speed data rate is 19 packets of 64 bytes each&n; * per frame, or 1216 bytes per millisecond.&n; * The best high speed data rate is 13 packets of 512 bytes each&n; * per microframe, or 52 KBytes per millisecond.&n; *&n; * The reason to use interrupt transfers through this API would most likely&n; * be to reserve high speed bandwidth, where up to 24 KBytes per millisecond&n; * could be transferred.  That capability is less useful for low or full&n; * speed interrupt endpoints, which allow at most one packet per millisecond,&n; * of at most 8 or 64 bytes (respectively).&n; */
DECL|function|usb_sg_wait
r_void
id|usb_sg_wait
(paren
r_struct
id|usb_sg_request
op_star
id|io
)paren
(brace
r_int
id|i
comma
id|entries
op_assign
id|io-&gt;entries
suffix:semicolon
multiline_comment|/* queue the urbs.  */
id|spin_lock_irq
(paren
op_amp
id|io-&gt;lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|entries
op_logical_and
op_logical_neg
id|io-&gt;status
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|retval
suffix:semicolon
id|io-&gt;urbs
(braket
id|i
)braket
op_member_access_from_pointer
id|dev
op_assign
id|io-&gt;dev
suffix:semicolon
id|retval
op_assign
id|usb_submit_urb
(paren
id|io-&gt;urbs
(braket
id|i
)braket
comma
id|SLAB_ATOMIC
)paren
suffix:semicolon
multiline_comment|/* after we submit, let completions or cancelations fire;&n;&t;&t; * we handshake using io-&gt;status.&n;&t;&t; */
id|spin_unlock_irq
(paren
op_amp
id|io-&gt;lock
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|retval
)paren
(brace
multiline_comment|/* maybe we retrying will recover */
r_case
op_minus
id|ENXIO
suffix:colon
singleline_comment|// hc didn&squot;t queue this one
r_case
op_minus
id|EAGAIN
suffix:colon
r_case
op_minus
id|ENOMEM
suffix:colon
id|io-&gt;urbs
(braket
id|i
)braket
op_member_access_from_pointer
id|dev
op_assign
l_int|NULL
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
id|i
op_decrement
suffix:semicolon
id|yield
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* no error? continue immediately.&n;&t;&t;&t; *&n;&t;&t;&t; * NOTE: to work better with UHCI (4K I/O buffer may&n;&t;&t;&t; * need 3K of TDs) it may be good to limit how many&n;&t;&t;&t; * URBs are queued at once; N milliseconds?&n;&t;&t;&t; */
r_case
l_int|0
suffix:colon
id|cpu_relax
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* fail any uncompleted urbs */
r_default
suffix:colon
id|io-&gt;urbs
(braket
id|i
)braket
op_member_access_from_pointer
id|dev
op_assign
l_int|NULL
suffix:semicolon
id|io-&gt;urbs
(braket
id|i
)braket
op_member_access_from_pointer
id|status
op_assign
id|retval
suffix:semicolon
id|dev_dbg
(paren
op_amp
id|io-&gt;dev-&gt;dev
comma
l_string|&quot;%s, submit --&gt; %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|retval
)paren
suffix:semicolon
id|usb_sg_cancel
(paren
id|io
)paren
suffix:semicolon
)brace
id|spin_lock_irq
(paren
op_amp
id|io-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_logical_and
(paren
id|io-&gt;status
op_eq
l_int|0
op_logical_or
id|io-&gt;status
op_eq
op_minus
id|ECONNRESET
)paren
)paren
id|io-&gt;status
op_assign
id|retval
suffix:semicolon
)brace
id|io-&gt;count
op_sub_assign
id|entries
op_minus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|io-&gt;count
op_eq
l_int|0
)paren
id|complete
(paren
op_amp
id|io-&gt;complete
)paren
suffix:semicolon
id|spin_unlock_irq
(paren
op_amp
id|io-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* OK, yes, this could be packaged as non-blocking.&n;&t; * So could the submit loop above ... but it&squot;s easier to&n;&t; * solve neither problem than to solve both!&n;&t; */
id|wait_for_completion
(paren
op_amp
id|io-&gt;complete
)paren
suffix:semicolon
id|sg_clean
(paren
id|io
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_sg_cancel - stop scatter/gather i/o issued by usb_sg_wait()&n; * @io: request block, initialized with usb_sg_init()&n; *&n; * This stops a request after it has been started by usb_sg_wait().&n; * It can also prevents one initialized by usb_sg_init() from starting,&n; * so that call just frees resources allocated to the request.&n; */
DECL|function|usb_sg_cancel
r_void
id|usb_sg_cancel
(paren
r_struct
id|usb_sg_request
op_star
id|io
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
(paren
op_amp
id|io-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* shut everything down, if it didn&squot;t already */
r_if
c_cond
(paren
op_logical_neg
id|io-&gt;status
)paren
(brace
r_int
id|i
suffix:semicolon
id|io-&gt;status
op_assign
op_minus
id|ECONNRESET
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|io-&gt;lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|io-&gt;entries
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|io-&gt;urbs
(braket
id|i
)braket
op_member_access_from_pointer
id|dev
)paren
r_continue
suffix:semicolon
id|retval
op_assign
id|usb_unlink_urb
(paren
id|io-&gt;urbs
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
op_minus
id|EINPROGRESS
op_logical_and
id|retval
op_ne
op_minus
id|EBUSY
)paren
id|dev_warn
(paren
op_amp
id|io-&gt;dev-&gt;dev
comma
l_string|&quot;%s, unlink --&gt; %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|retval
)paren
suffix:semicolon
)brace
id|spin_lock
(paren
op_amp
id|io-&gt;lock
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
(paren
op_amp
id|io-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------*/
multiline_comment|/**&n; * usb_get_descriptor - issues a generic GET_DESCRIPTOR request&n; * @dev: the device whose descriptor is being retrieved&n; * @type: the descriptor type (USB_DT_*)&n; * @index: the number of the descriptor&n; * @buf: where to put the descriptor&n; * @size: how big is &quot;buf&quot;?&n; * Context: !in_interrupt ()&n; *&n; * Gets a USB descriptor.  Convenience functions exist to simplify&n; * getting some types of descriptors.  Use&n; * usb_get_string() or usb_string() for USB_DT_STRING.&n; * Device (USB_DT_DEVICE) and configuration descriptors (USB_DT_CONFIG)&n; * are part of the device structure.&n; * In addition to a number of USB-standard descriptors, some&n; * devices also use class-specific or vendor-specific descriptors.&n; *&n; * This call is synchronous, and may not be used in an interrupt context.&n; *&n; * Returns the number of bytes received on success, or else the status code&n; * returned by the underlying usb_control_msg() call.&n; */
DECL|function|usb_get_descriptor
r_int
id|usb_get_descriptor
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_char
id|type
comma
r_int
r_char
id|index
comma
r_void
op_star
id|buf
comma
r_int
id|size
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|result
suffix:semicolon
id|memset
c_func
(paren
id|buf
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
singleline_comment|// Make sure we parse really received data
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
op_increment
id|i
)paren
(brace
multiline_comment|/* retry on length 0 or stall; some devices are flakey */
id|result
op_assign
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|USB_REQ_GET_DESCRIPTOR
comma
id|USB_DIR_IN
comma
(paren
id|type
op_lshift
l_int|8
)paren
op_plus
id|index
comma
l_int|0
comma
id|buf
comma
id|size
comma
id|HZ
op_star
id|USB_CTRL_GET_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
op_logical_or
id|result
op_eq
op_minus
id|EPIPE
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|result
OG
l_int|1
op_logical_and
(paren
(paren
id|u8
op_star
)paren
id|buf
)paren
(braket
l_int|1
)braket
op_ne
id|type
)paren
(brace
id|result
op_assign
op_minus
id|EPROTO
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_get_string - gets a string descriptor&n; * @dev: the device whose string descriptor is being retrieved&n; * @langid: code for language chosen (from string descriptor zero)&n; * @index: the number of the descriptor&n; * @buf: where to put the string&n; * @size: how big is &quot;buf&quot;?&n; * Context: !in_interrupt ()&n; *&n; * Retrieves a string, encoded using UTF-16LE (Unicode, 16 bits per character,&n; * in little-endian byte order).&n; * The usb_string() function will often be a convenient way to turn&n; * these strings into kernel-printable form.&n; *&n; * Strings may be referenced in device, configuration, interface, or other&n; * descriptors, and could also be used in vendor-specific ways.&n; *&n; * This call is synchronous, and may not be used in an interrupt context.&n; *&n; * Returns the number of bytes received on success, or else the status code&n; * returned by the underlying usb_control_msg() call.&n; */
DECL|function|usb_get_string
r_int
id|usb_get_string
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|langid
comma
r_int
r_char
id|index
comma
r_void
op_star
id|buf
comma
r_int
id|size
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|result
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
op_increment
id|i
)paren
(brace
multiline_comment|/* retry on length 0 or stall; some devices are flakey */
id|result
op_assign
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|USB_REQ_GET_DESCRIPTOR
comma
id|USB_DIR_IN
comma
(paren
id|USB_DT_STRING
op_lshift
l_int|8
)paren
op_plus
id|index
comma
id|langid
comma
id|buf
comma
id|size
comma
id|HZ
op_star
id|USB_CTRL_GET_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|result
op_eq
l_int|0
op_logical_or
id|result
op_eq
op_minus
id|EPIPE
)paren
)paren
r_break
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
DECL|function|usb_try_string_workarounds
r_static
r_void
id|usb_try_string_workarounds
c_func
(paren
r_int
r_char
op_star
id|buf
comma
r_int
op_star
id|length
)paren
(brace
r_int
id|newlength
comma
id|oldlength
op_assign
op_star
id|length
suffix:semicolon
r_for
c_loop
(paren
id|newlength
op_assign
l_int|2
suffix:semicolon
id|newlength
op_plus
l_int|1
OL
id|oldlength
suffix:semicolon
id|newlength
op_add_assign
l_int|2
)paren
r_if
c_cond
(paren
op_logical_neg
id|isprint
c_func
(paren
id|buf
(braket
id|newlength
)braket
)paren
op_logical_or
id|buf
(braket
id|newlength
op_plus
l_int|1
)braket
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|newlength
OG
l_int|2
)paren
(brace
id|buf
(braket
l_int|0
)braket
op_assign
id|newlength
suffix:semicolon
op_star
id|length
op_assign
id|newlength
suffix:semicolon
)brace
)brace
DECL|function|usb_string_sub
r_static
r_int
id|usb_string_sub
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|langid
comma
r_int
r_int
id|index
comma
r_int
r_char
op_star
id|buf
)paren
(brace
r_int
id|rc
suffix:semicolon
multiline_comment|/* Try to read the string descriptor by asking for the maximum&n;&t; * possible number of bytes */
id|rc
op_assign
id|usb_get_string
c_func
(paren
id|dev
comma
id|langid
comma
id|index
comma
id|buf
comma
l_int|255
)paren
suffix:semicolon
multiline_comment|/* If that failed try to read the descriptor length, then&n;&t; * ask for just that many bytes */
r_if
c_cond
(paren
id|rc
OL
l_int|2
)paren
(brace
id|rc
op_assign
id|usb_get_string
c_func
(paren
id|dev
comma
id|langid
comma
id|index
comma
id|buf
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|2
)paren
id|rc
op_assign
id|usb_get_string
c_func
(paren
id|dev
comma
id|langid
comma
id|index
comma
id|buf
comma
id|buf
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rc
op_ge
l_int|2
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|buf
(braket
l_int|0
)braket
op_logical_and
op_logical_neg
id|buf
(braket
l_int|1
)braket
)paren
id|usb_try_string_workarounds
c_func
(paren
id|buf
comma
op_amp
id|rc
)paren
suffix:semicolon
multiline_comment|/* There might be extra junk at the end of the descriptor */
r_if
c_cond
(paren
id|buf
(braket
l_int|0
)braket
OL
id|rc
)paren
id|rc
op_assign
id|buf
(braket
l_int|0
)braket
suffix:semicolon
id|rc
op_assign
id|rc
op_minus
(paren
id|rc
op_amp
l_int|1
)paren
suffix:semicolon
multiline_comment|/* force a multiple of two */
)brace
r_if
c_cond
(paren
id|rc
OL
l_int|2
)paren
id|rc
op_assign
(paren
id|rc
OL
l_int|0
ques
c_cond
id|rc
suffix:colon
op_minus
id|EINVAL
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_string - returns ISO 8859-1 version of a string descriptor&n; * @dev: the device whose string descriptor is being retrieved&n; * @index: the number of the descriptor&n; * @buf: where to put the string&n; * @size: how big is &quot;buf&quot;?&n; * Context: !in_interrupt ()&n; * &n; * This converts the UTF-16LE encoded strings returned by devices, from&n; * usb_get_string_descriptor(), to null-terminated ISO-8859-1 encoded ones&n; * that are more usable in most kernel contexts.  Note that all characters&n; * in the chosen descriptor that can&squot;t be encoded using ISO-8859-1&n; * are converted to the question mark (&quot;?&quot;) character, and this function&n; * chooses strings in the first language supported by the device.&n; *&n; * The ASCII (or, redundantly, &quot;US-ASCII&quot;) character set is the seven-bit&n; * subset of ISO 8859-1. ISO-8859-1 is the eight-bit subset of Unicode,&n; * and is appropriate for use many uses of English and several other&n; * Western European languages.  (But it doesn&squot;t include the &quot;Euro&quot; symbol.)&n; *&n; * This call is synchronous, and may not be used in an interrupt context.&n; *&n; * Returns length of the string (&gt;= 0) or usb_control_msg status (&lt; 0).&n; */
DECL|function|usb_string
r_int
id|usb_string
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|index
comma
r_char
op_star
id|buf
comma
r_int
id|size
)paren
(brace
r_int
r_char
op_star
id|tbuf
suffix:semicolon
r_int
id|err
suffix:semicolon
r_int
r_int
id|u
comma
id|idx
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;state
op_eq
id|USB_STATE_SUSPENDED
)paren
r_return
op_minus
id|EHOSTUNREACH
suffix:semicolon
r_if
c_cond
(paren
id|size
op_le
l_int|0
op_logical_or
op_logical_neg
id|buf
op_logical_or
op_logical_neg
id|index
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|buf
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|tbuf
op_assign
id|kmalloc
c_func
(paren
l_int|256
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tbuf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* get langid for strings if it&squot;s not yet known */
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;have_langid
)paren
(brace
id|err
op_assign
id|usb_string_sub
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0
comma
id|tbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|dev_err
(paren
op_amp
id|dev-&gt;dev
comma
l_string|&quot;string descriptor 0 read error: %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_goto
id|errout
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|err
OL
l_int|4
)paren
(brace
id|dev_err
(paren
op_amp
id|dev-&gt;dev
comma
l_string|&quot;string descriptor 0 too short&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|errout
suffix:semicolon
)brace
r_else
(brace
id|dev-&gt;have_langid
op_assign
op_minus
l_int|1
suffix:semicolon
id|dev-&gt;string_langid
op_assign
id|tbuf
(braket
l_int|2
)braket
op_or
(paren
id|tbuf
(braket
l_int|3
)braket
op_lshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/* always use the first langid listed */
id|dev_dbg
(paren
op_amp
id|dev-&gt;dev
comma
l_string|&quot;default language 0x%04x&bslash;n&quot;
comma
id|dev-&gt;string_langid
)paren
suffix:semicolon
)brace
)brace
id|err
op_assign
id|usb_string_sub
c_func
(paren
id|dev
comma
id|dev-&gt;string_langid
comma
id|index
comma
id|tbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|errout
suffix:semicolon
id|size
op_decrement
suffix:semicolon
multiline_comment|/* leave room for trailing NULL char in output buffer */
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
comma
id|u
op_assign
l_int|2
suffix:semicolon
id|u
OL
id|err
suffix:semicolon
id|u
op_add_assign
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|idx
op_ge
id|size
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|tbuf
(braket
id|u
op_plus
l_int|1
)braket
)paren
multiline_comment|/* high byte */
id|buf
(braket
id|idx
op_increment
)braket
op_assign
l_char|&squot;?&squot;
suffix:semicolon
multiline_comment|/* non ISO-8859-1 character */
r_else
id|buf
(braket
id|idx
op_increment
)braket
op_assign
id|tbuf
(braket
id|u
)braket
suffix:semicolon
)brace
id|buf
(braket
id|idx
)braket
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
id|idx
suffix:semicolon
r_if
c_cond
(paren
id|tbuf
(braket
l_int|1
)braket
op_ne
id|USB_DT_STRING
)paren
id|dev_dbg
c_func
(paren
op_amp
id|dev-&gt;dev
comma
l_string|&quot;wrong descriptor type %02x for string %d (&bslash;&quot;%s&bslash;&quot;)&bslash;n&quot;
comma
id|tbuf
(braket
l_int|1
)braket
comma
id|index
comma
id|buf
)paren
suffix:semicolon
id|errout
suffix:colon
id|kfree
c_func
(paren
id|tbuf
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * usb_get_device_descriptor - (re)reads the device descriptor (usbcore)&n; * @dev: the device whose device descriptor is being updated&n; * @size: how much of the descriptor to read&n; * Context: !in_interrupt ()&n; *&n; * Updates the copy of the device descriptor stored in the device structure,&n; * which dedicates space for this purpose.  Note that several fields are&n; * converted to the host CPU&squot;s byte order:  the USB version (bcdUSB), and&n; * vendors product and version fields (idVendor, idProduct, and bcdDevice).&n; * That lets device drivers compare against non-byteswapped constants.&n; *&n; * Not exported, only for use by the core.  If drivers really want to read&n; * the device descriptor directly, they can call usb_get_descriptor() with&n; * type = USB_DT_DEVICE and index = 0.&n; *&n; * This call is synchronous, and may not be used in an interrupt context.&n; *&n; * Returns the number of bytes received on success, or else the status code&n; * returned by the underlying usb_control_msg() call.&n; */
DECL|function|usb_get_device_descriptor
r_int
id|usb_get_device_descriptor
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|size
)paren
(brace
r_struct
id|usb_device_descriptor
op_star
id|desc
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
r_sizeof
(paren
op_star
id|desc
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|desc
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|desc
)paren
comma
id|GFP_NOIO
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|desc
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|ret
op_assign
id|usb_get_descriptor
c_func
(paren
id|dev
comma
id|USB_DT_DEVICE
comma
l_int|0
comma
id|desc
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ge
l_int|0
)paren
id|memcpy
c_func
(paren
op_amp
id|dev-&gt;descriptor
comma
id|desc
comma
id|size
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|desc
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_get_status - issues a GET_STATUS call&n; * @dev: the device whose status is being checked&n; * @type: USB_RECIP_*; for device, interface, or endpoint&n; * @target: zero (for device), else interface or endpoint number&n; * @data: pointer to two bytes of bitmap data&n; * Context: !in_interrupt ()&n; *&n; * Returns device, interface, or endpoint status.  Normally only of&n; * interest to see if the device is self powered, or has enabled the&n; * remote wakeup facility; or whether a bulk or interrupt endpoint&n; * is halted (&quot;stalled&quot;).&n; *&n; * Bits in these status bitmaps are set using the SET_FEATURE request,&n; * and cleared using the CLEAR_FEATURE request.  The usb_clear_halt()&n; * function should be used to clear halt (&quot;stall&quot;) status.&n; *&n; * This call is synchronous, and may not be used in an interrupt context.&n; *&n; * Returns the number of bytes received on success, or else the status code&n; * returned by the underlying usb_control_msg() call.&n; */
DECL|function|usb_get_status
r_int
id|usb_get_status
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|type
comma
r_int
id|target
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|ret
suffix:semicolon
id|u16
op_star
id|status
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|status
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|ret
op_assign
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_rcvctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|USB_REQ_GET_STATUS
comma
id|USB_DIR_IN
op_or
id|type
comma
l_int|0
comma
id|target
comma
id|status
comma
r_sizeof
(paren
op_star
id|status
)paren
comma
id|HZ
op_star
id|USB_CTRL_GET_TIMEOUT
)paren
suffix:semicolon
op_star
(paren
id|u16
op_star
)paren
id|data
op_assign
op_star
id|status
suffix:semicolon
id|kfree
c_func
(paren
id|status
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_clear_halt - tells device to clear endpoint halt/stall condition&n; * @dev: device whose endpoint is halted&n; * @pipe: endpoint &quot;pipe&quot; being cleared&n; * Context: !in_interrupt ()&n; *&n; * This is used to clear halt conditions for bulk and interrupt endpoints,&n; * as reported by URB completion status.  Endpoints that are halted are&n; * sometimes referred to as being &quot;stalled&quot;.  Such endpoints are unable&n; * to transmit or receive data until the halt status is cleared.  Any URBs&n; * queued for such an endpoint should normally be unlinked by the driver&n; * before clearing the halt condition, as described in sections 5.7.5&n; * and 5.8.5 of the USB 2.0 spec.&n; *&n; * Note that control and isochronous endpoints don&squot;t halt, although control&n; * endpoints report &quot;protocol stall&quot; (for unsupported requests) using the&n; * same status code used to report a true stall.&n; *&n; * This call is synchronous, and may not be used in an interrupt context.&n; *&n; * Returns zero on success, or else the status code returned by the&n; * underlying usb_control_msg() call.&n; */
DECL|function|usb_clear_halt
r_int
id|usb_clear_halt
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|pipe
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
id|endp
op_assign
id|usb_pipeendpoint
c_func
(paren
id|pipe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipein
(paren
id|pipe
)paren
)paren
id|endp
op_or_assign
id|USB_DIR_IN
suffix:semicolon
multiline_comment|/* we don&squot;t care if it wasn&squot;t halted first. in fact some devices&n;&t; * (like some ibmcam model 1 units) seem to expect hosts to make&n;&t; * this request for iso endpoints, which can&squot;t halt!&n;&t; */
id|result
op_assign
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|USB_REQ_CLEAR_FEATURE
comma
id|USB_RECIP_ENDPOINT
comma
id|USB_ENDPOINT_HALT
comma
id|endp
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
op_star
id|USB_CTRL_SET_TIMEOUT
)paren
suffix:semicolon
multiline_comment|/* don&squot;t un-halt or force to DATA0 except on success */
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_return
id|result
suffix:semicolon
multiline_comment|/* NOTE:  seems like Microsoft and Apple don&squot;t bother verifying&n;&t; * the clear &quot;took&quot;, so some devices could lock up if you check...&n;&t; * such as the Hagiwara FlashGate DUAL.  So we won&squot;t bother.&n;&t; *&n;&t; * NOTE:  make sure the logic here doesn&squot;t diverge much from&n;&t; * the copy in usb-storage, for as long as we need two copies.&n;&t; */
multiline_comment|/* toggle was reset by the clear */
id|usb_settoggle
c_func
(paren
id|dev
comma
id|usb_pipeendpoint
c_func
(paren
id|pipe
)paren
comma
id|usb_pipeout
c_func
(paren
id|pipe
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_disable_endpoint -- Disable an endpoint by address&n; * @dev: the device whose endpoint is being disabled&n; * @epaddr: the endpoint&squot;s address.  Endpoint number for output,&n; *&t;endpoint number + USB_DIR_IN for input&n; *&n; * Deallocates hcd/hardware state for this endpoint ... and nukes all&n; * pending urbs.&n; *&n; * If the HCD hasn&squot;t registered a disable() function, this sets the&n; * endpoint&squot;s maxpacket size to 0 to prevent further submissions.&n; */
DECL|function|usb_disable_endpoint
r_void
id|usb_disable_endpoint
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
r_int
id|epaddr
)paren
(brace
r_int
r_int
id|epnum
op_assign
id|epaddr
op_amp
id|USB_ENDPOINT_NUMBER_MASK
suffix:semicolon
r_struct
id|usb_host_endpoint
op_star
id|ep
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|usb_endpoint_out
c_func
(paren
id|epaddr
)paren
)paren
(brace
id|ep
op_assign
id|dev-&gt;ep_out
(braket
id|epnum
)braket
suffix:semicolon
id|dev-&gt;ep_out
(braket
id|epnum
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|ep
op_assign
id|dev-&gt;ep_in
(braket
id|epnum
)braket
suffix:semicolon
id|dev-&gt;ep_in
(braket
id|epnum
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ep
op_logical_and
id|dev-&gt;bus
op_logical_and
id|dev-&gt;bus-&gt;op
op_logical_and
id|dev-&gt;bus-&gt;op-&gt;disable
)paren
id|dev-&gt;bus-&gt;op
op_member_access_from_pointer
id|disable
c_func
(paren
id|dev
comma
id|ep
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_disable_interface -- Disable all endpoints for an interface&n; * @dev: the device whose interface is being disabled&n; * @intf: pointer to the interface descriptor&n; *&n; * Disables all the endpoints for the interface&squot;s current altsetting.&n; */
DECL|function|usb_disable_interface
r_void
id|usb_disable_interface
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_struct
id|usb_interface
op_star
id|intf
)paren
(brace
r_struct
id|usb_host_interface
op_star
id|alt
op_assign
id|intf-&gt;cur_altsetting
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|alt-&gt;desc.bNumEndpoints
suffix:semicolon
op_increment
id|i
)paren
(brace
id|usb_disable_endpoint
c_func
(paren
id|dev
comma
id|alt-&gt;endpoint
(braket
id|i
)braket
dot
id|desc.bEndpointAddress
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * usb_disable_device - Disable all the endpoints for a USB device&n; * @dev: the device whose endpoints are being disabled&n; * @skip_ep0: 0 to disable endpoint 0, 1 to skip it.&n; *&n; * Disables all the device&squot;s endpoints, potentially including endpoint 0.&n; * Deallocates hcd/hardware state for the endpoints (nuking all or most&n; * pending urbs) and usbcore state for the interfaces, so that usbcore&n; * must usb_set_configuration() before any interfaces could be used.&n; */
DECL|function|usb_disable_device
r_void
id|usb_disable_device
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|skip_ep0
)paren
(brace
r_int
id|i
suffix:semicolon
id|dev_dbg
c_func
(paren
op_amp
id|dev-&gt;dev
comma
l_string|&quot;%s nuking %s URBs&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|skip_ep0
ques
c_cond
l_string|&quot;non-ep0&quot;
suffix:colon
l_string|&quot;all&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|skip_ep0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
op_increment
id|i
)paren
(brace
id|usb_disable_endpoint
c_func
(paren
id|dev
comma
id|i
)paren
suffix:semicolon
id|usb_disable_endpoint
c_func
(paren
id|dev
comma
id|i
op_plus
id|USB_DIR_IN
)paren
suffix:semicolon
)brace
id|dev-&gt;toggle
(braket
l_int|0
)braket
op_assign
id|dev-&gt;toggle
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* getting rid of interfaces will disconnect&n;&t; * any drivers bound to them (a key side effect)&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;actconfig
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;actconfig-&gt;desc.bNumInterfaces
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|usb_interface
op_star
id|interface
suffix:semicolon
multiline_comment|/* remove this interface */
id|interface
op_assign
id|dev-&gt;actconfig-&gt;interface
(braket
id|i
)braket
suffix:semicolon
id|dev_dbg
(paren
op_amp
id|dev-&gt;dev
comma
l_string|&quot;unregistering interface %s&bslash;n&quot;
comma
id|interface-&gt;dev.bus_id
)paren
suffix:semicolon
id|usb_remove_sysfs_intf_files
c_func
(paren
id|interface
)paren
suffix:semicolon
id|device_del
(paren
op_amp
id|interface-&gt;dev
)paren
suffix:semicolon
)brace
multiline_comment|/* Now that the interfaces are unbound, nobody should&n;&t;&t; * try to access them.&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;actconfig-&gt;desc.bNumInterfaces
suffix:semicolon
id|i
op_increment
)paren
(brace
id|put_device
(paren
op_amp
id|dev-&gt;actconfig-&gt;interface
(braket
id|i
)braket
op_member_access_from_pointer
id|dev
)paren
suffix:semicolon
id|dev-&gt;actconfig-&gt;interface
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
id|dev-&gt;actconfig
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;state
op_eq
id|USB_STATE_CONFIGURED
)paren
id|usb_set_device_state
c_func
(paren
id|dev
comma
id|USB_STATE_ADDRESS
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * usb_enable_endpoint - Enable an endpoint for USB communications&n; * @dev: the device whose interface is being enabled&n; * @ep: the endpoint&n; *&n; * Resets the endpoint toggle, and sets dev-&gt;ep_{in,out} pointers.&n; * For control endpoints, both the input and output sides are handled.&n; */
r_static
r_void
DECL|function|usb_enable_endpoint
id|usb_enable_endpoint
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_struct
id|usb_host_endpoint
op_star
id|ep
)paren
(brace
r_int
r_int
id|epaddr
op_assign
id|ep-&gt;desc.bEndpointAddress
suffix:semicolon
r_int
r_int
id|epnum
op_assign
id|epaddr
op_amp
id|USB_ENDPOINT_NUMBER_MASK
suffix:semicolon
r_int
id|is_control
suffix:semicolon
id|is_control
op_assign
(paren
(paren
id|ep-&gt;desc.bmAttributes
op_amp
id|USB_ENDPOINT_XFERTYPE_MASK
)paren
op_eq
id|USB_ENDPOINT_XFER_CONTROL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_endpoint_out
c_func
(paren
id|epaddr
)paren
op_logical_or
id|is_control
)paren
(brace
id|usb_settoggle
c_func
(paren
id|dev
comma
id|epnum
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|dev-&gt;ep_out
(braket
id|epnum
)braket
op_assign
id|ep
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|usb_endpoint_out
c_func
(paren
id|epaddr
)paren
op_logical_or
id|is_control
)paren
(brace
id|usb_settoggle
c_func
(paren
id|dev
comma
id|epnum
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|dev-&gt;ep_in
(braket
id|epnum
)braket
op_assign
id|ep
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * usb_enable_interface - Enable all the endpoints for an interface&n; * @dev: the device whose interface is being enabled&n; * @intf: pointer to the interface descriptor&n; *&n; * Enables all the endpoints for the interface&squot;s current altsetting.&n; */
DECL|function|usb_enable_interface
r_void
id|usb_enable_interface
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_struct
id|usb_interface
op_star
id|intf
)paren
(brace
r_struct
id|usb_host_interface
op_star
id|alt
op_assign
id|intf-&gt;cur_altsetting
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|alt-&gt;desc.bNumEndpoints
suffix:semicolon
op_increment
id|i
)paren
id|usb_enable_endpoint
c_func
(paren
id|dev
comma
op_amp
id|alt-&gt;endpoint
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_set_interface - Makes a particular alternate setting be current&n; * @dev: the device whose interface is being updated&n; * @interface: the interface being updated&n; * @alternate: the setting being chosen.&n; * Context: !in_interrupt ()&n; *&n; * This is used to enable data transfers on interfaces that may not&n; * be enabled by default.  Not all devices support such configurability.&n; * Only the driver bound to an interface may change its setting.&n; *&n; * Within any given configuration, each interface may have several&n; * alternative settings.  These are often used to control levels of&n; * bandwidth consumption.  For example, the default setting for a high&n; * speed interrupt endpoint may not send more than 64 bytes per microframe,&n; * while interrupt transfers of up to 3KBytes per microframe are legal.&n; * Also, isochronous endpoints may never be part of an&n; * interface&squot;s default setting.  To access such bandwidth, alternate&n; * interface settings must be made current.&n; *&n; * Note that in the Linux USB subsystem, bandwidth associated with&n; * an endpoint in a given alternate setting is not reserved until an URB&n; * is submitted that needs that bandwidth.  Some other operating systems&n; * allocate bandwidth early, when a configuration is chosen.&n; *&n; * This call is synchronous, and may not be used in an interrupt context.&n; * Also, drivers must not change altsettings while urbs are scheduled for&n; * endpoints in that interface; all such urbs must first be completed&n; * (perhaps forced by unlinking).&n; *&n; * Returns zero on success, or else the status code returned by the&n; * underlying usb_control_msg() call.&n; */
DECL|function|usb_set_interface
r_int
id|usb_set_interface
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|interface
comma
r_int
id|alternate
)paren
(brace
r_struct
id|usb_interface
op_star
id|iface
suffix:semicolon
r_struct
id|usb_host_interface
op_star
id|alt
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|manual
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;state
op_eq
id|USB_STATE_SUSPENDED
)paren
r_return
op_minus
id|EHOSTUNREACH
suffix:semicolon
id|iface
op_assign
id|usb_ifnum_to_if
c_func
(paren
id|dev
comma
id|interface
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|iface
)paren
(brace
id|dev_dbg
c_func
(paren
op_amp
id|dev-&gt;dev
comma
l_string|&quot;selecting invalid interface %d&bslash;n&quot;
comma
id|interface
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|alt
op_assign
id|usb_altnum_to_altsetting
c_func
(paren
id|iface
comma
id|alternate
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|alt
)paren
(brace
id|warn
c_func
(paren
l_string|&quot;selecting invalid altsetting %d&quot;
comma
id|alternate
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ret
op_assign
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|USB_REQ_SET_INTERFACE
comma
id|USB_RECIP_INTERFACE
comma
id|alternate
comma
id|interface
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
op_star
l_int|5
)paren
suffix:semicolon
multiline_comment|/* 9.4.10 says devices don&squot;t need this and are free to STALL the&n;&t; * request if the interface only has one alternate setting.&n;&t; */
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EPIPE
op_logical_and
id|iface-&gt;num_altsetting
op_eq
l_int|1
)paren
(brace
id|dev_dbg
c_func
(paren
op_amp
id|dev-&gt;dev
comma
l_string|&quot;manual set_interface for iface %d, alt %d&bslash;n&quot;
comma
id|interface
comma
id|alternate
)paren
suffix:semicolon
id|manual
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/* FIXME drivers shouldn&squot;t need to replicate/bugfix the logic here&n;&t; * when they implement async or easily-killable versions of this or&n;&t; * other &quot;should-be-internal&quot; functions (like clear_halt).&n;&t; * should hcd+usbcore postprocess control requests?&n;&t; */
multiline_comment|/* prevent submissions using previous endpoint settings */
id|usb_disable_interface
c_func
(paren
id|dev
comma
id|iface
)paren
suffix:semicolon
id|iface-&gt;cur_altsetting
op_assign
id|alt
suffix:semicolon
multiline_comment|/* If the interface only has one altsetting and the device didn&squot;t&n;&t; * accept the request, we attempt to carry out the equivalent action&n;&t; * by manually clearing the HALT feature for each endpoint in the&n;&t; * new altsetting.&n;&t; */
r_if
c_cond
(paren
id|manual
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|alt-&gt;desc.bNumEndpoints
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|epaddr
op_assign
id|alt-&gt;endpoint
(braket
id|i
)braket
dot
id|desc.bEndpointAddress
suffix:semicolon
r_int
r_int
id|pipe
op_assign
id|__create_pipe
c_func
(paren
id|dev
comma
id|USB_ENDPOINT_NUMBER_MASK
op_amp
id|epaddr
)paren
op_or
(paren
id|usb_endpoint_out
c_func
(paren
id|epaddr
)paren
ques
c_cond
id|USB_DIR_OUT
suffix:colon
id|USB_DIR_IN
)paren
suffix:semicolon
id|usb_clear_halt
c_func
(paren
id|dev
comma
id|pipe
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* 9.1.1.5: reset toggles for all endpoints in the new altsetting&n;&t; *&n;&t; * Note:&n;&t; * Despite EP0 is always present in all interfaces/AS, the list of&n;&t; * endpoints from the descriptor does not contain EP0. Due to its&n;&t; * omnipresence one might expect EP0 being considered &quot;affected&quot; by&n;&t; * any SetInterface request and hence assume toggles need to be reset.&n;&t; * However, EP0 toggles are re-synced for every individual transfer&n;&t; * during the SETUP stage - hence EP0 toggles are &quot;don&squot;t care&quot; here.&n;&t; * (Likewise, EP0 never &quot;halts&quot; on well designed devices.)&n;&t; */
id|usb_enable_interface
c_func
(paren
id|dev
comma
id|iface
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * usb_reset_configuration - lightweight device reset&n; * @dev: the device whose configuration is being reset&n; *&n; * This issues a standard SET_CONFIGURATION request to the device using&n; * the current configuration.  The effect is to reset most USB-related&n; * state in the device, including interface altsettings (reset to zero),&n; * endpoint halts (cleared), and data toggle (only for bulk and interrupt&n; * endpoints).  Other usbcore state is unchanged, including bindings of&n; * usb device drivers to interfaces.&n; *&n; * Because this affects multiple interfaces, avoid using this with composite&n; * (multi-interface) devices.  Instead, the driver for each interface may&n; * use usb_set_interface() on the interfaces it claims.  Resetting the whole&n; * configuration would affect other drivers&squot; interfaces.&n; *&n; * The caller must own the device lock.&n; *&n; * Returns zero on success, else a negative error code.&n; */
DECL|function|usb_reset_configuration
r_int
id|usb_reset_configuration
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
)paren
(brace
r_int
id|i
comma
id|retval
suffix:semicolon
r_struct
id|usb_host_config
op_star
id|config
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;state
op_eq
id|USB_STATE_SUSPENDED
)paren
r_return
op_minus
id|EHOSTUNREACH
suffix:semicolon
multiline_comment|/* caller must have locked the device and must own&n;&t; * the usb bus readlock (so driver bindings are stable);&n;&t; * calls during probe() are fine&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
op_increment
id|i
)paren
(brace
id|usb_disable_endpoint
c_func
(paren
id|dev
comma
id|i
)paren
suffix:semicolon
id|usb_disable_endpoint
c_func
(paren
id|dev
comma
id|i
op_plus
id|USB_DIR_IN
)paren
suffix:semicolon
)brace
id|config
op_assign
id|dev-&gt;actconfig
suffix:semicolon
id|retval
op_assign
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|USB_REQ_SET_CONFIGURATION
comma
l_int|0
comma
id|config-&gt;desc.bConfigurationValue
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
op_star
id|USB_CTRL_SET_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
(brace
id|usb_set_device_state
c_func
(paren
id|dev
comma
id|USB_STATE_ADDRESS
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|dev-&gt;toggle
(braket
l_int|0
)braket
op_assign
id|dev-&gt;toggle
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* re-init hc/hcd interface/endpoint state */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|config-&gt;desc.bNumInterfaces
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|usb_interface
op_star
id|intf
op_assign
id|config-&gt;interface
(braket
id|i
)braket
suffix:semicolon
r_struct
id|usb_host_interface
op_star
id|alt
suffix:semicolon
id|alt
op_assign
id|usb_altnum_to_altsetting
c_func
(paren
id|intf
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* No altsetting 0?  We&squot;ll assume the first altsetting.&n;&t;&t; * We could use a GetInterface call, but if a device is&n;&t;&t; * so non-compliant that it doesn&squot;t have altsetting 0&n;&t;&t; * then I wouldn&squot;t trust its reply anyway.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|alt
)paren
id|alt
op_assign
op_amp
id|intf-&gt;altsetting
(braket
l_int|0
)braket
suffix:semicolon
id|intf-&gt;cur_altsetting
op_assign
id|alt
suffix:semicolon
id|usb_enable_interface
c_func
(paren
id|dev
comma
id|intf
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|release_interface
r_static
r_void
id|release_interface
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|usb_interface
op_star
id|intf
op_assign
id|to_usb_interface
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|usb_interface_cache
op_star
id|intfc
op_assign
id|altsetting_to_usb_interface_cache
c_func
(paren
id|intf-&gt;altsetting
)paren
suffix:semicolon
id|kref_put
c_func
(paren
op_amp
id|intfc-&gt;ref
comma
id|usb_release_interface_cache
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|intf
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * usb_set_configuration - Makes a particular device setting be current&n; * @dev: the device whose configuration is being updated&n; * @configuration: the configuration being chosen.&n; * Context: !in_interrupt(), caller owns the device lock&n; *&n; * This is used to enable non-default device modes.  Not all devices&n; * use this kind of configurability; many devices only have one&n; * configuration.&n; *&n; * USB device configurations may affect Linux interoperability,&n; * power consumption and the functionality available.  For example,&n; * the default configuration is limited to using 100mA of bus power,&n; * so that when certain device functionality requires more power,&n; * and the device is bus powered, that functionality should be in some&n; * non-default device configuration.  Other device modes may also be&n; * reflected as configuration options, such as whether two ISDN&n; * channels are available independently; and choosing between open&n; * standard device protocols (like CDC) or proprietary ones.&n; *&n; * Note that USB has an additional level of device configurability,&n; * associated with interfaces.  That configurability is accessed using&n; * usb_set_interface().&n; *&n; * This call is synchronous. The calling context must be able to sleep,&n; * must own the device lock, and must not hold the driver model&squot;s USB&n; * bus rwsem; usb device driver probe() methods cannot use this routine.&n; *&n; * Returns zero on success, or else the status code returned by the&n; * underlying call that failed.  On succesful completion, each interface&n; * in the original device configuration has been destroyed, and each one&n; * in the new configuration has been probed by all relevant usb device&n; * drivers currently known to the kernel.&n; */
DECL|function|usb_set_configuration
r_int
id|usb_set_configuration
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|configuration
)paren
(brace
r_int
id|i
comma
id|ret
suffix:semicolon
r_struct
id|usb_host_config
op_star
id|cp
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|usb_interface
op_star
op_star
id|new_interfaces
op_assign
l_int|NULL
suffix:semicolon
r_int
id|n
comma
id|nintf
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;descriptor.bNumConfigurations
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;config
(braket
id|i
)braket
dot
id|desc.bConfigurationValue
op_eq
id|configuration
)paren
(brace
id|cp
op_assign
op_amp
id|dev-&gt;config
(braket
id|i
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|cp
op_logical_and
id|configuration
op_ne
l_int|0
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* The USB spec says configuration 0 means unconfigured.&n;&t; * But if a device includes a configuration numbered 0,&n;&t; * we will accept it as a correctly configured state.&n;&t; */
r_if
c_cond
(paren
id|cp
op_logical_and
id|configuration
op_eq
l_int|0
)paren
id|dev_warn
c_func
(paren
op_amp
id|dev-&gt;dev
comma
l_string|&quot;config 0 descriptor??&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;state
op_eq
id|USB_STATE_SUSPENDED
)paren
r_return
op_minus
id|EHOSTUNREACH
suffix:semicolon
multiline_comment|/* Allocate memory for new interfaces before doing anything else,&n;&t; * so that if we run out then nothing will have changed. */
id|n
op_assign
id|nintf
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cp
)paren
(brace
id|nintf
op_assign
id|cp-&gt;desc.bNumInterfaces
suffix:semicolon
id|new_interfaces
op_assign
id|kmalloc
c_func
(paren
id|nintf
op_star
r_sizeof
(paren
op_star
id|new_interfaces
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_interfaces
)paren
(brace
id|dev_err
c_func
(paren
op_amp
id|dev-&gt;dev
comma
l_string|&quot;Out of memory&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|n
OL
id|nintf
suffix:semicolon
op_increment
id|n
)paren
(brace
id|new_interfaces
(braket
id|n
)braket
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|usb_interface
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_interfaces
(braket
id|n
)braket
)paren
(brace
id|dev_err
c_func
(paren
op_amp
id|dev-&gt;dev
comma
l_string|&quot;Out of memory&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|free_interfaces
suffix:colon
r_while
c_loop
(paren
op_decrement
id|n
op_ge
l_int|0
)paren
id|kfree
c_func
(paren
id|new_interfaces
(braket
id|n
)braket
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|new_interfaces
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* if it&squot;s already configured, clear out old state first.&n;&t; * getting rid of old interfaces means unbinding their drivers.&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;state
op_ne
id|USB_STATE_ADDRESS
)paren
id|usb_disable_device
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
singleline_comment|// Skip ep0
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|usb_control_msg
c_func
(paren
id|dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|dev
comma
l_int|0
)paren
comma
id|USB_REQ_SET_CONFIGURATION
comma
l_int|0
comma
id|configuration
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
op_star
id|USB_CTRL_SET_TIMEOUT
)paren
)paren
OL
l_int|0
)paren
r_goto
id|free_interfaces
suffix:semicolon
id|dev-&gt;actconfig
op_assign
id|cp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
id|usb_set_device_state
c_func
(paren
id|dev
comma
id|USB_STATE_ADDRESS
)paren
suffix:semicolon
r_else
(brace
id|usb_set_device_state
c_func
(paren
id|dev
comma
id|USB_STATE_CONFIGURED
)paren
suffix:semicolon
multiline_comment|/* Initialize the new interface structures and the&n;&t;&t; * hc/hcd/usbcore interface/endpoint state.&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nintf
suffix:semicolon
op_increment
id|i
)paren
(brace
r_struct
id|usb_interface_cache
op_star
id|intfc
suffix:semicolon
r_struct
id|usb_interface
op_star
id|intf
suffix:semicolon
r_struct
id|usb_host_interface
op_star
id|alt
suffix:semicolon
id|cp-&gt;interface
(braket
id|i
)braket
op_assign
id|intf
op_assign
id|new_interfaces
(braket
id|i
)braket
suffix:semicolon
id|memset
c_func
(paren
id|intf
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|intf
)paren
)paren
suffix:semicolon
id|intfc
op_assign
id|cp-&gt;intf_cache
(braket
id|i
)braket
suffix:semicolon
id|intf-&gt;altsetting
op_assign
id|intfc-&gt;altsetting
suffix:semicolon
id|intf-&gt;num_altsetting
op_assign
id|intfc-&gt;num_altsetting
suffix:semicolon
id|kref_get
c_func
(paren
op_amp
id|intfc-&gt;ref
)paren
suffix:semicolon
id|alt
op_assign
id|usb_altnum_to_altsetting
c_func
(paren
id|intf
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* No altsetting 0?  We&squot;ll assume the first altsetting.&n;&t;&t;&t; * We could use a GetInterface call, but if a device is&n;&t;&t;&t; * so non-compliant that it doesn&squot;t have altsetting 0&n;&t;&t;&t; * then I wouldn&squot;t trust its reply anyway.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|alt
)paren
id|alt
op_assign
op_amp
id|intf-&gt;altsetting
(braket
l_int|0
)braket
suffix:semicolon
id|intf-&gt;cur_altsetting
op_assign
id|alt
suffix:semicolon
id|usb_enable_interface
c_func
(paren
id|dev
comma
id|intf
)paren
suffix:semicolon
id|intf-&gt;dev.parent
op_assign
op_amp
id|dev-&gt;dev
suffix:semicolon
id|intf-&gt;dev.driver
op_assign
l_int|NULL
suffix:semicolon
id|intf-&gt;dev.bus
op_assign
op_amp
id|usb_bus_type
suffix:semicolon
id|intf-&gt;dev.dma_mask
op_assign
id|dev-&gt;dev.dma_mask
suffix:semicolon
id|intf-&gt;dev.release
op_assign
id|release_interface
suffix:semicolon
id|device_initialize
(paren
op_amp
id|intf-&gt;dev
)paren
suffix:semicolon
id|sprintf
(paren
op_amp
id|intf-&gt;dev.bus_id
(braket
l_int|0
)braket
comma
l_string|&quot;%d-%s:%d.%d&quot;
comma
id|dev-&gt;bus-&gt;busnum
comma
id|dev-&gt;devpath
comma
id|configuration
comma
id|alt-&gt;desc.bInterfaceNumber
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|new_interfaces
)paren
suffix:semicolon
multiline_comment|/* Now that all the interfaces are set up, register them&n;&t;&t; * to trigger binding of drivers to interfaces.  probe()&n;&t;&t; * routines may install different altsettings and may&n;&t;&t; * claim() any interfaces not yet bound.  Many class drivers&n;&t;&t; * need that: CDC, audio, video, etc.&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nintf
suffix:semicolon
op_increment
id|i
)paren
(brace
r_struct
id|usb_interface
op_star
id|intf
op_assign
id|cp-&gt;interface
(braket
id|i
)braket
suffix:semicolon
r_struct
id|usb_interface_descriptor
op_star
id|desc
suffix:semicolon
id|desc
op_assign
op_amp
id|intf-&gt;altsetting
(braket
l_int|0
)braket
dot
id|desc
suffix:semicolon
id|dev_dbg
(paren
op_amp
id|dev-&gt;dev
comma
l_string|&quot;adding %s (config #%d, interface %d)&bslash;n&quot;
comma
id|intf-&gt;dev.bus_id
comma
id|configuration
comma
id|desc-&gt;bInterfaceNumber
)paren
suffix:semicolon
id|ret
op_assign
id|device_add
(paren
op_amp
id|intf-&gt;dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|dev_err
c_func
(paren
op_amp
id|dev-&gt;dev
comma
l_string|&quot;device_add(%s) --&gt; %d&bslash;n&quot;
comma
id|intf-&gt;dev.bus_id
comma
id|ret
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|usb_create_sysfs_intf_files
(paren
id|intf
)paren
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
singleline_comment|// synchronous request completion model
DECL|variable|usb_control_msg
id|EXPORT_SYMBOL
c_func
(paren
id|usb_control_msg
)paren
suffix:semicolon
DECL|variable|usb_bulk_msg
id|EXPORT_SYMBOL
c_func
(paren
id|usb_bulk_msg
)paren
suffix:semicolon
DECL|variable|usb_sg_init
id|EXPORT_SYMBOL
c_func
(paren
id|usb_sg_init
)paren
suffix:semicolon
DECL|variable|usb_sg_cancel
id|EXPORT_SYMBOL
c_func
(paren
id|usb_sg_cancel
)paren
suffix:semicolon
DECL|variable|usb_sg_wait
id|EXPORT_SYMBOL
c_func
(paren
id|usb_sg_wait
)paren
suffix:semicolon
singleline_comment|// synchronous control message convenience routines
DECL|variable|usb_get_descriptor
id|EXPORT_SYMBOL
c_func
(paren
id|usb_get_descriptor
)paren
suffix:semicolon
DECL|variable|usb_get_status
id|EXPORT_SYMBOL
c_func
(paren
id|usb_get_status
)paren
suffix:semicolon
DECL|variable|usb_get_string
id|EXPORT_SYMBOL
c_func
(paren
id|usb_get_string
)paren
suffix:semicolon
DECL|variable|usb_string
id|EXPORT_SYMBOL
c_func
(paren
id|usb_string
)paren
suffix:semicolon
singleline_comment|// synchronous calls that also maintain usbcore state
DECL|variable|usb_clear_halt
id|EXPORT_SYMBOL
c_func
(paren
id|usb_clear_halt
)paren
suffix:semicolon
DECL|variable|usb_reset_configuration
id|EXPORT_SYMBOL
c_func
(paren
id|usb_reset_configuration
)paren
suffix:semicolon
DECL|variable|usb_set_interface
id|EXPORT_SYMBOL
c_func
(paren
id|usb_set_interface
)paren
suffix:semicolon
eof
