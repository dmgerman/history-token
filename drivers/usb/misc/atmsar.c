multiline_comment|/******************************************************************************&n; *  atmsar.c  --  General SAR library for ATM devices.&n; *&n; *  Copyright (C) 2000, Johan Verrept&n; *&n; *  This program is free software; you can redistribute it and/or modify it&n; *  under the terms of the GNU General Public License as published by the Free&n; *  Software Foundation; either version 2 of the License, or (at your option)&n; *  any later version.&n; *&n; *  This program is distributed in the hope that it will be useful, but WITHOUT&n; *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or&n; *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for&n; *  more details.&n; *&n; *  You should have received a copy of the GNU General Public License along with&n; *  this program; if not, write to the Free Software Foundation, Inc., 59&n; *  Temple Place - Suite 330, Boston, MA  02111-1307, USA.&n; *&n; ******************************************************************************/
multiline_comment|/*&n; *  Written by Johan Verrept (Johan.Verrept@advalvas.be)&n; *&n; *  0.2.4A:&t;- Version for inclusion in 2.5 series kernel&n; *&t;&t;- Modifications by Richard Purdie (rpurdie@rpsys.net)&n; *&t;&t;- replaced &quot;sarlib&quot; with &quot;atmsar&quot;&n; *&t;&t;- adaptations for inclusion in kernel tree&n; *&n; *  0.2.4:&t;- Fixed wrong buffer overrun check in atmsar_decode_rawcell()&n; *&t;&t;reported by Stephen Robinson &lt;stephen.robinson@zen.co.uk&gt;&n; *&t;&t;- Fixed bug when input skb did not contain a multple of 52/53&n; *&t;&t;bytes (would happen when the speedtouch device resynced)&n; *&t;&t;also reported by Stephen Robinson &lt;stephen.robinson@zen.co.uk&gt;&n; *&n; *  0.2.3:&t;- Fixed wrong allocation size. caused memory corruption in some&n; *&t;&t;cases. Reported by Vladimir Dergachev &lt;volodya@mindspring.com&gt;&n; *&t;&t;- Added some comments&n; *&n; *  0.2.2:&t;- Fixed CRCASM&n; *&t;&t;patch from Linus Flannagan &lt;linusf@netservices.eng.net&gt;&n; *&t;&t;- Fixed problem when user did NOT use the&n; *&t;&t;ATMSAR_USE_53BYTE_CELL flag.&n; *&t;&t;reported by  Piers Scannell &lt;email@lot105.com&gt;&n; *&t;&t;- No more in-buffer rewriting for cloned buffers.&n; *&t;&t;- Removed the PII specific CFLAGS in the Makefile.&n; *&n; *  0.2.1:&t;- removed dependency on alloc_tx. tis presented problems when&n; *&t;&t;using this with the br2684 code.&n; *&n; *  0.2:&t;- added AAL0 reassembly&n; *&t;&t;- added alloc_tx support&n; *&t;&t;- replaced alloc_skb in decode functions to dev_alloc_skb to&n; *&t;&t;allow calling from interrupt&n; *&t;&t;- fixed embarassing AAL5 bug. I was setting the pti bit in the&n; *&t;&t;wrong byte...&n; *&t;&t;- fixed another emabrassing bug.. picked up the wrong crc type&n; *&t;&t;and forgot to invert the crc result...&n; *&t;&t;- fixed AAL5 length calculations.&n; *&t;&t;- removed automatic skb freeing from encode functions.&n; *&t;&t;This caused problems because i did kfree_skb it, while it&n; *&t;&t;needed to be popped. I cannot determine though whether it&n; *&t;&t;needs to be popped or not. Figu&squot;e it out ye&squot;self ;-)&n; *&t;&t;- added mru field. This is the buffersize. atmsar_decode_aal0&n; *&t;&t;will use when it allocates a receive buffer. A stop gap for&n; *&t;&t;real buffer management.&n; *&n; *  0.1:&t;- library created.&n; *&t;&t;- only contains AAL5, AAL0 can be easily added. (actually, only&n; *&t;&t;AAL0 reassembly is missing)&n; *&n; */
macro_line|#include &lt;linux/crc32.h&gt;
macro_line|#include &quot;atmsar.h&quot;
multiline_comment|/***********************&n; **&n; **  things to remember&n; **&n; ***********************/
multiline_comment|/*&n;  1. the atmsar_vcc_data list pointer MUST be initialized to NULL&n;  2. atmsar_encode_rawcell will drop incomplete cells.&n;  3. ownership of the skb goes to the library !&n;*/
DECL|macro|ATM_HDR_VPVC_MASK
mdefine_line|#define ATM_HDR_VPVC_MASK  (ATM_HDR_VPI_MASK | ATM_HDR_VCI_MASK)
multiline_comment|/***********************&n; **&n; **  LOCAL STRUCTURES&n; **&n; ***********************/
multiline_comment|/***********************&n; **&n; **  LOCAL MACROS&n; **&n; ***********************/
multiline_comment|/*&n;#define DEBUG 1&n;*/
macro_line|#ifdef DEBUG
DECL|macro|PDEBUG
mdefine_line|#define PDEBUG(arg...)  printk(KERN_DEBUG &quot;atmsar: &quot; arg)
macro_line|#else
DECL|macro|PDEBUG
mdefine_line|#define PDEBUG(arg...)
macro_line|#endif
DECL|macro|ADD_HEADER
mdefine_line|#define ADD_HEADER(dest, header) &bslash;&n;  *dest++ = (unsigned char) (header &gt;&gt; 24); &bslash;&n;  *dest++ = (unsigned char) (header &gt;&gt; 16); &bslash;&n;  *dest++ = (unsigned char) (header &gt;&gt; 8); &bslash;&n;  *dest++ = (unsigned char) (header &amp; 0xff);
DECL|function|atmsar_open
r_struct
id|atmsar_vcc_data
op_star
id|atmsar_open
(paren
r_struct
id|atmsar_vcc_data
op_star
op_star
id|list
comma
r_struct
id|atm_vcc
op_star
id|vcc
comma
id|uint
id|type
comma
id|ushort
id|vpi
comma
id|ushort
id|vci
comma
id|unchar
id|pti
comma
id|unchar
id|gfc
comma
id|uint
id|flags
)paren
(brace
r_struct
id|atmsar_vcc_data
op_star
r_new
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vcc
)paren
r_return
l_int|NULL
suffix:semicolon
r_new
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|atmsar_vcc_data
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
(paren
r_new
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|atmsar_vcc_data
)paren
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|vcc
op_assign
id|vcc
suffix:semicolon
r_new
op_member_access_from_pointer
id|stats
op_assign
id|vcc-&gt;stats
suffix:semicolon
r_new
op_member_access_from_pointer
id|type
op_assign
id|type
suffix:semicolon
r_new
op_member_access_from_pointer
id|next
op_assign
l_int|NULL
suffix:semicolon
r_new
op_member_access_from_pointer
id|gfc
op_assign
id|gfc
suffix:semicolon
r_new
op_member_access_from_pointer
id|vp
op_assign
id|vpi
suffix:semicolon
r_new
op_member_access_from_pointer
id|vc
op_assign
id|vci
suffix:semicolon
r_new
op_member_access_from_pointer
id|pti
op_assign
id|pti
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|ATMSAR_TYPE_AAL0
suffix:colon
r_new
op_member_access_from_pointer
id|mtu
op_assign
id|ATMSAR_DEF_MTU_AAL0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ATMSAR_TYPE_AAL1
suffix:colon
r_new
op_member_access_from_pointer
id|mtu
op_assign
id|ATMSAR_DEF_MTU_AAL1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ATMSAR_TYPE_AAL2
suffix:colon
r_new
op_member_access_from_pointer
id|mtu
op_assign
id|ATMSAR_DEF_MTU_AAL2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ATMSAR_TYPE_AAL34
suffix:colon
multiline_comment|/* not supported */
r_new
op_member_access_from_pointer
id|mtu
op_assign
id|ATMSAR_DEF_MTU_AAL34
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ATMSAR_TYPE_AAL5
suffix:colon
r_new
op_member_access_from_pointer
id|mtu
op_assign
id|ATMSAR_DEF_MTU_AAL5
suffix:semicolon
r_break
suffix:semicolon
)brace
r_new
op_member_access_from_pointer
id|atmHeader
op_assign
(paren
(paren
r_int
r_int
)paren
id|gfc
op_lshift
id|ATM_HDR_GFC_SHIFT
)paren
op_or
(paren
(paren
r_int
r_int
)paren
id|vpi
op_lshift
id|ATM_HDR_VPI_SHIFT
)paren
op_or
(paren
(paren
r_int
r_int
)paren
id|vci
op_lshift
id|ATM_HDR_VCI_SHIFT
)paren
op_or
(paren
(paren
r_int
r_int
)paren
id|pti
op_lshift
id|ATM_HDR_PTI_SHIFT
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|flags
op_assign
id|flags
suffix:semicolon
r_new
op_member_access_from_pointer
id|next
op_assign
l_int|NULL
suffix:semicolon
r_new
op_member_access_from_pointer
id|reasBuffer
op_assign
l_int|NULL
suffix:semicolon
r_new
op_member_access_from_pointer
id|next
op_assign
op_star
id|list
suffix:semicolon
op_star
id|list
op_assign
r_new
suffix:semicolon
id|PDEBUG
(paren
l_string|&quot;Allocated new SARLib vcc 0x%p with vp %d vc %d&bslash;n&quot;
comma
r_new
comma
id|vpi
comma
id|vci
)paren
suffix:semicolon
r_return
r_new
suffix:semicolon
)brace
DECL|function|atmsar_close
r_void
id|atmsar_close
(paren
r_struct
id|atmsar_vcc_data
op_star
op_star
id|list
comma
r_struct
id|atmsar_vcc_data
op_star
id|vcc
)paren
(brace
r_struct
id|atmsar_vcc_data
op_star
id|work
suffix:semicolon
r_if
c_cond
(paren
op_star
id|list
op_eq
id|vcc
)paren
(brace
op_star
id|list
op_assign
(paren
op_star
id|list
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|work
op_assign
op_star
id|list
suffix:semicolon
id|work
op_logical_and
id|work-&gt;next
op_logical_and
(paren
id|work-&gt;next
op_ne
id|vcc
)paren
suffix:semicolon
id|work
op_assign
id|work-&gt;next
)paren
suffix:semicolon
multiline_comment|/* return if not found */
r_if
c_cond
(paren
id|work-&gt;next
op_ne
id|vcc
)paren
r_return
suffix:semicolon
id|work-&gt;next
op_assign
id|work-&gt;next-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vcc-&gt;reasBuffer
)paren
(brace
id|dev_kfree_skb
(paren
id|vcc-&gt;reasBuffer
)paren
suffix:semicolon
)brace
id|PDEBUG
(paren
l_string|&quot;Allocated SARLib vcc 0x%p with vp %d vc %d&bslash;n&quot;
comma
id|vcc
comma
id|vcc-&gt;vp
comma
id|vcc-&gt;vc
)paren
suffix:semicolon
id|kfree
(paren
id|vcc
)paren
suffix:semicolon
)brace
multiline_comment|/***********************&n; **&n; **  DECODE FUNCTIONS&n; **&n; ***********************/
DECL|function|atmsar_decode_rawcell
r_struct
id|sk_buff
op_star
id|atmsar_decode_rawcell
(paren
r_struct
id|atmsar_vcc_data
op_star
id|list
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|atmsar_vcc_data
op_star
op_star
id|ctx
)paren
(brace
r_while
c_loop
(paren
id|skb-&gt;len
)paren
(brace
r_int
r_char
op_star
id|cell
op_assign
id|skb-&gt;data
suffix:semicolon
r_int
r_char
op_star
id|cell_payload
suffix:semicolon
r_struct
id|atmsar_vcc_data
op_star
id|vcc
op_assign
id|list
suffix:semicolon
r_int
r_int
id|atmHeader
op_assign
(paren
(paren
r_int
r_int
)paren
(paren
id|cell
(braket
l_int|0
)braket
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
r_int
r_int
)paren
(paren
id|cell
(braket
l_int|1
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
r_int
r_int
)paren
(paren
id|cell
(braket
l_int|2
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|cell
(braket
l_int|3
)braket
op_amp
l_int|0xff
)paren
suffix:semicolon
id|PDEBUG
(paren
l_string|&quot;atmsar_decode_rawcell (0x%p, 0x%p, 0x%p) called&bslash;n&quot;
comma
id|list
comma
id|skb
comma
id|ctx
)paren
suffix:semicolon
id|PDEBUG
(paren
l_string|&quot;atmsar_decode_rawcell skb-&gt;data %p, skb-&gt;tail %p&bslash;n&quot;
comma
id|skb-&gt;data
comma
id|skb-&gt;tail
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list
op_logical_or
op_logical_neg
id|skb
op_logical_or
op_logical_neg
id|ctx
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;data
op_logical_or
op_logical_neg
id|skb-&gt;tail
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* here should the header CRC check be... */
multiline_comment|/* look up correct vcc */
r_for
c_loop
(paren
suffix:semicolon
id|vcc
op_logical_and
(paren
(paren
id|vcc-&gt;atmHeader
op_amp
id|ATM_HDR_VPVC_MASK
)paren
op_ne
(paren
id|atmHeader
op_amp
id|ATM_HDR_VPVC_MASK
)paren
)paren
suffix:semicolon
id|vcc
op_assign
id|vcc-&gt;next
)paren
suffix:semicolon
id|PDEBUG
(paren
l_string|&quot;atmsar_decode_rawcell found vcc %p for packet on vp %d, vc %d&bslash;n&quot;
comma
id|vcc
comma
(paren
r_int
)paren
(paren
(paren
id|atmHeader
op_amp
id|ATM_HDR_VPI_MASK
)paren
op_rshift
id|ATM_HDR_VPI_SHIFT
)paren
comma
(paren
r_int
)paren
(paren
(paren
id|atmHeader
op_amp
id|ATM_HDR_VCI_MASK
)paren
op_rshift
id|ATM_HDR_VCI_SHIFT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vcc
op_logical_and
(paren
id|skb-&gt;len
op_ge
(paren
id|vcc-&gt;flags
op_amp
id|ATMSAR_USE_53BYTE_CELL
ques
c_cond
l_int|53
suffix:colon
l_int|52
)paren
)paren
)paren
(brace
id|cell_payload
op_assign
id|cell
op_plus
(paren
id|vcc-&gt;flags
op_amp
id|ATMSAR_USE_53BYTE_CELL
ques
c_cond
l_int|5
suffix:colon
l_int|4
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|vcc-&gt;type
)paren
(brace
r_case
id|ATMSAR_TYPE_AAL0
suffix:colon
multiline_comment|/* case ATMSAR_TYPE_AAL1: when we have a decode AAL1 function... */
(brace
r_struct
id|sk_buff
op_star
id|tmp
op_assign
id|dev_alloc_skb
(paren
id|vcc-&gt;mtu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
(brace
id|memcpy
(paren
id|tmp-&gt;tail
comma
id|cell_payload
comma
l_int|48
)paren
suffix:semicolon
id|skb_put
(paren
id|tmp
comma
l_int|48
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vcc-&gt;stats
)paren
id|atomic_inc
(paren
op_amp
id|vcc-&gt;stats-&gt;rx
)paren
suffix:semicolon
id|skb_pull
(paren
id|skb
comma
(paren
id|vcc
op_member_access_from_pointer
id|flags
op_amp
id|ATMSAR_USE_53BYTE_CELL
ques
c_cond
l_int|53
suffix:colon
l_int|52
)paren
)paren
suffix:semicolon
id|PDEBUG
(paren
l_string|&quot;atmsar_decode_rawcell returns ATMSAR_TYPE_AAL0 pdu 0x%p with length %d&bslash;n&quot;
comma
id|tmp
comma
id|tmp-&gt;len
)paren
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ATMSAR_TYPE_AAL1
suffix:colon
r_case
id|ATMSAR_TYPE_AAL2
suffix:colon
r_case
id|ATMSAR_TYPE_AAL34
suffix:colon
multiline_comment|/* not supported */
r_break
suffix:semicolon
r_case
id|ATMSAR_TYPE_AAL5
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|vcc-&gt;reasBuffer
)paren
id|vcc-&gt;reasBuffer
op_assign
id|dev_alloc_skb
(paren
id|vcc-&gt;mtu
)paren
suffix:semicolon
multiline_comment|/* if alloc fails, we just drop the cell. it is possible that we can still&n;&t;&t;&t;&t; * receive cells on other vcc&squot;s&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|vcc-&gt;reasBuffer
)paren
(brace
multiline_comment|/* if (buffer overrun) discard received cells until now */
r_if
c_cond
(paren
(paren
id|vcc-&gt;reasBuffer-&gt;len
)paren
OG
(paren
id|vcc-&gt;mtu
op_minus
l_int|48
)paren
)paren
id|skb_trim
(paren
id|vcc-&gt;reasBuffer
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* copy data */
id|memcpy
(paren
id|vcc-&gt;reasBuffer-&gt;tail
comma
id|cell_payload
comma
l_int|48
)paren
suffix:semicolon
id|skb_put
(paren
id|vcc-&gt;reasBuffer
comma
l_int|48
)paren
suffix:semicolon
multiline_comment|/* check for end of buffer */
r_if
c_cond
(paren
id|cell
(braket
l_int|3
)braket
op_amp
l_int|0x2
)paren
(brace
r_struct
id|sk_buff
op_star
id|tmp
suffix:semicolon
multiline_comment|/* the aal5 buffer ends here, cut the buffer. */
multiline_comment|/* buffer will always have at least one whole cell, so */
multiline_comment|/* don&squot;t need to check return from skb_pull */
id|skb_pull
(paren
id|skb
comma
(paren
id|vcc
op_member_access_from_pointer
id|flags
op_amp
id|ATMSAR_USE_53BYTE_CELL
ques
c_cond
l_int|53
suffix:colon
l_int|52
)paren
)paren
suffix:semicolon
op_star
id|ctx
op_assign
id|vcc
suffix:semicolon
id|tmp
op_assign
id|vcc-&gt;reasBuffer
suffix:semicolon
id|vcc-&gt;reasBuffer
op_assign
l_int|NULL
suffix:semicolon
id|PDEBUG
(paren
l_string|&quot;atmsar_decode_rawcell returns ATMSAR_TYPE_AAL5 pdu 0x%p with length %d&bslash;n&quot;
comma
id|tmp
comma
id|tmp-&gt;len
)paren
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* flush the cell */
multiline_comment|/* buffer will always contain at least one whole cell, so don&squot;t */
multiline_comment|/* need to check return value from skb_pull */
id|skb_pull
(paren
id|skb
comma
(paren
id|vcc-&gt;flags
op_amp
id|ATMSAR_USE_53BYTE_CELL
ques
c_cond
l_int|53
suffix:colon
l_int|52
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* If data is corrupt and skb doesn&squot;t hold a whole cell, flush the lot */
r_if
c_cond
(paren
id|skb_pull
(paren
id|skb
comma
(paren
id|list-&gt;flags
op_amp
id|ATMSAR_USE_53BYTE_CELL
ques
c_cond
l_int|53
suffix:colon
l_int|52
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
suffix:semicolon
DECL|function|atmsar_decode_aal5
r_struct
id|sk_buff
op_star
id|atmsar_decode_aal5
(paren
r_struct
id|atmsar_vcc_data
op_star
id|ctx
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|uint
id|crc
op_assign
l_int|0xffffffff
suffix:semicolon
id|uint
id|length
comma
id|pdu_crc
comma
id|pdu_length
suffix:semicolon
id|PDEBUG
(paren
l_string|&quot;atmsar_decode_aal5 (0x%p, 0x%p) called&bslash;n&quot;
comma
id|ctx
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
op_logical_and
(paren
id|skb-&gt;len
op_mod
l_int|48
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|length
op_assign
(paren
id|skb-&gt;tail
(braket
op_minus
l_int|6
)braket
op_lshift
l_int|8
)paren
op_plus
id|skb-&gt;tail
(braket
op_minus
l_int|5
)braket
suffix:semicolon
id|pdu_crc
op_assign
(paren
id|skb-&gt;tail
(braket
op_minus
l_int|4
)braket
op_lshift
l_int|24
)paren
op_plus
(paren
id|skb-&gt;tail
(braket
op_minus
l_int|3
)braket
op_lshift
l_int|16
)paren
op_plus
(paren
id|skb-&gt;tail
(braket
op_minus
l_int|2
)braket
op_lshift
l_int|8
)paren
op_plus
id|skb-&gt;tail
(braket
op_minus
l_int|1
)braket
suffix:semicolon
id|pdu_length
op_assign
(paren
(paren
id|length
op_plus
l_int|47
op_plus
l_int|8
)paren
op_div
l_int|48
)paren
op_star
l_int|48
suffix:semicolon
id|PDEBUG
(paren
l_string|&quot;atmsar_decode_aal5: skb-&gt;len = %d, length = %d, pdu_crc = 0x%x, pdu_length = %d&bslash;n&quot;
comma
id|skb-&gt;len
comma
id|length
comma
id|pdu_crc
comma
id|pdu_length
)paren
suffix:semicolon
multiline_comment|/* is skb long enough ? */
r_if
c_cond
(paren
id|skb-&gt;len
OL
id|pdu_length
)paren
(brace
r_if
c_cond
(paren
id|ctx-&gt;stats
)paren
id|atomic_inc
(paren
op_amp
id|ctx-&gt;stats-&gt;rx_err
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* is skb too long ? */
r_if
c_cond
(paren
id|skb-&gt;len
OG
id|pdu_length
)paren
(brace
id|PDEBUG
(paren
l_string|&quot;atmsar_decode_aal5: Warning: readjusting illeagl size %d -&gt; %d&bslash;n&quot;
comma
id|skb-&gt;len
comma
id|pdu_length
)paren
suffix:semicolon
multiline_comment|/* buffer is too long. we can try to recover&n;&t;&t; * if we discard the first part of the skb.&n;&t;&t; * the crc will decide whether this was ok&n;&t;&t; */
id|skb_pull
(paren
id|skb
comma
id|skb-&gt;len
op_minus
id|pdu_length
)paren
suffix:semicolon
)brace
id|crc
op_assign
op_complement
id|crc32_be
(paren
id|crc
comma
id|skb-&gt;data
comma
id|pdu_length
op_minus
l_int|4
)paren
suffix:semicolon
multiline_comment|/* check crc */
r_if
c_cond
(paren
id|pdu_crc
op_ne
id|crc
)paren
(brace
id|PDEBUG
(paren
l_string|&quot;atmsar_decode_aal5: crc check failed!&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;stats
)paren
id|atomic_inc
(paren
op_amp
id|ctx-&gt;stats-&gt;rx_err
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* pdu is ok */
id|skb_trim
(paren
id|skb
comma
id|length
)paren
suffix:semicolon
multiline_comment|/* update stats */
r_if
c_cond
(paren
id|ctx-&gt;stats
)paren
id|atomic_inc
(paren
op_amp
id|ctx-&gt;stats-&gt;rx
)paren
suffix:semicolon
id|PDEBUG
(paren
l_string|&quot;atmsar_decode_aal5 returns pdu 0x%p with length %d&bslash;n&quot;
comma
id|skb
comma
id|skb-&gt;len
)paren
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
suffix:semicolon
eof
