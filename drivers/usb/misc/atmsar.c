multiline_comment|/******************************************************************************&n; *  atmsar.c  --  General SAR library for ATM devices.&n; *&n; *  Copyright (C) 2000, Johan Verrept&n; *&n; *  This program is free software; you can redistribute it and/or modify it&n; *  under the terms of the GNU General Public License as published by the Free&n; *  Software Foundation; either version 2 of the License, or (at your option)&n; *  any later version.&n; *&n; *  This program is distributed in the hope that it will be useful, but WITHOUT&n; *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or&n; *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for&n; *  more details.&n; *&n; *  You should have received a copy of the GNU General Public License along with&n; *  this program; if not, write to the Free Software Foundation, Inc., 59&n; *  Temple Place - Suite 330, Boston, MA  02111-1307, USA.&n; *&n; ******************************************************************************/
multiline_comment|/*&n; *  Written by Johan Verrept (Johan.Verrept@advalvas.be)&n; *&n; *  0.2.4A:&t;- Version for inclusion in 2.5 series kernel&n; *&t;&t;- Modifications by Richard Purdie (rpurdie@rpsys.net)&n; *&t;&t;- replaced &quot;sarlib&quot; with &quot;atmsar&quot;&n; *&t;&t;- adaptations for inclusion in kernel tree&n; *&n; *  0.2.4:&t;- Fixed wrong buffer overrun check in atmsar_decode_rawcell()&n; *&t;&t;reported by Stephen Robinson &lt;stephen.robinson@zen.co.uk&gt;&n; *&t;&t;- Fixed bug when input skb did not contain a multple of 52/53&n; *&t;&t;bytes (would happen when the speedtouch device resynced)&n; *&t;&t;also reported by Stephen Robinson &lt;stephen.robinson@zen.co.uk&gt;&n; *&n; *  0.2.3:&t;- Fixed wrong allocation size. caused memory corruption in some&n; *&t;&t;cases. Reported by Vladimir Dergachev &lt;volodya@mindspring.com&gt;&n; *&t;&t;- Added some comments&n; *&n; *  0.2.2:&t;- Fixed CRCASM&n; *&t;&t;patch from Linus Flannagan &lt;linusf@netservices.eng.net&gt;&n; *&t;&t;- Fixed problem when user did NOT use the&n; *&t;&t;ATMSAR_USE_53BYTE_CELL flag.&n; *&t;&t;reported by  Piers Scannell &lt;email@lot105.com&gt;&n; *&t;&t;- No more in-buffer rewriting for cloned buffers.&n; *&t;&t;- Removed the PII specific CFLAGS in the Makefile.&n; *&n; *  0.2.1:&t;- removed dependancy on alloc_tx. tis presented problems when&n; *&t;&t;using this with the br2684 code.&n; *&n; *  0.2:&t;- added AAL0 reassembly&n; *&t;&t;- added alloc_tx support&n; *&t;&t;- replaced alloc_skb in decode functions to dev_alloc_skb to&n; *&t;&t;allow calling from interrupt&n; *&t;&t;- fixed embarassing AAL5 bug. I was setting the pti bit in the&n; *&t;&t;wrong byte...&n; *&t;&t;- fixed another emabrassing bug.. picked up the wrong crc type&n; *&t;&t;and forgot to invert the crc result...&n; *&t;&t;- fixed AAL5 length calculations.&n; *&t;&t;- removed automatic skb freeing from encode functions.&n; *&t;&t;This caused problems because i did kfree_skb it, while it&n; *&t;&t;needed to be popped. I cannot determine though whether it&n; *&t;&t;needs to be popped or not. Figu&squot;e it out ye&squot;self ;-)&n; *&t;&t;- added mru field. This is the buffersize. atmsar_decode_aal0&n; *&t;&t;will use when it allocates a receive buffer. A stop gap for&n; *&t;&t;real buffer management.&n; *&n; *  0.1:&t;- library created.&n; *&t;&t;- only contains AAL5, AAL0 can be easily added. (actually, only&n; *&t;&t;AAL0 reassembly is missing)&n; *&n; */
macro_line|#include &quot;atmsar.h&quot;
multiline_comment|/***********************&n; **&n; **  things to remember&n; **&n; ***********************/
multiline_comment|/*&n;  1. the atmsar_vcc_data list pointer MUST be initialized to NULL&n;  2. atmsar_encode_rawcell will drop incomplete cells.&n;  3. ownership of the skb goes to the library !&n;*/
DECL|macro|ATM_HDR_VPVC_MASK
mdefine_line|#define ATM_HDR_VPVC_MASK  (ATM_HDR_VPI_MASK | ATM_HDR_VCI_MASK)
multiline_comment|/***********************&n; **&n; **  LOCAL STRUCTURES&n; **&n; ***********************/
multiline_comment|/***********************&n; **&n; **  LOCAL MACROS&n; **&n; ***********************/
multiline_comment|/*&n;#define DEBUG 1&n;*/
macro_line|#ifdef DEBUG
DECL|macro|PDEBUG
mdefine_line|#define PDEBUG(arg...)  printk(KERN_DEBUG &quot;atmsar: &quot; arg)
macro_line|#else
DECL|macro|PDEBUG
mdefine_line|#define PDEBUG(arg...)
macro_line|#endif
DECL|macro|ADD_HEADER
mdefine_line|#define ADD_HEADER(dest, header) &bslash;&n;  *dest++ = (unsigned char) (header &gt;&gt; 24); &bslash;&n;  *dest++ = (unsigned char) (header &gt;&gt; 16); &bslash;&n;  *dest++ = (unsigned char) (header &gt;&gt; 8); &bslash;&n;  *dest++ = (unsigned char) (header &amp; 0xff);
multiline_comment|/*&n; * CRC Routines from  net/wan/sbni.c)&n; * table generated by Rocksoft^tm Model CRC Algorithm Table Generation Program V1.0&n; */
DECL|macro|CRC32_REMAINDER
mdefine_line|#define CRC32_REMAINDER CBF43926
DECL|macro|CRC32_INITIAL
mdefine_line|#define CRC32_INITIAL 0xffffffff
DECL|macro|CRC32
mdefine_line|#define CRC32(c,crc) (crc32tab[((size_t)(crc&gt;&gt;24) ^ (c)) &amp; 0xff] ^ (((crc) &lt;&lt; 8)))
DECL|variable|crc32tab
r_int
r_int
id|crc32tab
(braket
l_int|256
)braket
op_assign
(brace
l_int|0x00000000L
comma
l_int|0x04C11DB7L
comma
l_int|0x09823B6EL
comma
l_int|0x0D4326D9L
comma
l_int|0x130476DCL
comma
l_int|0x17C56B6BL
comma
l_int|0x1A864DB2L
comma
l_int|0x1E475005L
comma
l_int|0x2608EDB8L
comma
l_int|0x22C9F00FL
comma
l_int|0x2F8AD6D6L
comma
l_int|0x2B4BCB61L
comma
l_int|0x350C9B64L
comma
l_int|0x31CD86D3L
comma
l_int|0x3C8EA00AL
comma
l_int|0x384FBDBDL
comma
l_int|0x4C11DB70L
comma
l_int|0x48D0C6C7L
comma
l_int|0x4593E01EL
comma
l_int|0x4152FDA9L
comma
l_int|0x5F15ADACL
comma
l_int|0x5BD4B01BL
comma
l_int|0x569796C2L
comma
l_int|0x52568B75L
comma
l_int|0x6A1936C8L
comma
l_int|0x6ED82B7FL
comma
l_int|0x639B0DA6L
comma
l_int|0x675A1011L
comma
l_int|0x791D4014L
comma
l_int|0x7DDC5DA3L
comma
l_int|0x709F7B7AL
comma
l_int|0x745E66CDL
comma
l_int|0x9823B6E0L
comma
l_int|0x9CE2AB57L
comma
l_int|0x91A18D8EL
comma
l_int|0x95609039L
comma
l_int|0x8B27C03CL
comma
l_int|0x8FE6DD8BL
comma
l_int|0x82A5FB52L
comma
l_int|0x8664E6E5L
comma
l_int|0xBE2B5B58L
comma
l_int|0xBAEA46EFL
comma
l_int|0xB7A96036L
comma
l_int|0xB3687D81L
comma
l_int|0xAD2F2D84L
comma
l_int|0xA9EE3033L
comma
l_int|0xA4AD16EAL
comma
l_int|0xA06C0B5DL
comma
l_int|0xD4326D90L
comma
l_int|0xD0F37027L
comma
l_int|0xDDB056FEL
comma
l_int|0xD9714B49L
comma
l_int|0xC7361B4CL
comma
l_int|0xC3F706FBL
comma
l_int|0xCEB42022L
comma
l_int|0xCA753D95L
comma
l_int|0xF23A8028L
comma
l_int|0xF6FB9D9FL
comma
l_int|0xFBB8BB46L
comma
l_int|0xFF79A6F1L
comma
l_int|0xE13EF6F4L
comma
l_int|0xE5FFEB43L
comma
l_int|0xE8BCCD9AL
comma
l_int|0xEC7DD02DL
comma
l_int|0x34867077L
comma
l_int|0x30476DC0L
comma
l_int|0x3D044B19L
comma
l_int|0x39C556AEL
comma
l_int|0x278206ABL
comma
l_int|0x23431B1CL
comma
l_int|0x2E003DC5L
comma
l_int|0x2AC12072L
comma
l_int|0x128E9DCFL
comma
l_int|0x164F8078L
comma
l_int|0x1B0CA6A1L
comma
l_int|0x1FCDBB16L
comma
l_int|0x018AEB13L
comma
l_int|0x054BF6A4L
comma
l_int|0x0808D07DL
comma
l_int|0x0CC9CDCAL
comma
l_int|0x7897AB07L
comma
l_int|0x7C56B6B0L
comma
l_int|0x71159069L
comma
l_int|0x75D48DDEL
comma
l_int|0x6B93DDDBL
comma
l_int|0x6F52C06CL
comma
l_int|0x6211E6B5L
comma
l_int|0x66D0FB02L
comma
l_int|0x5E9F46BFL
comma
l_int|0x5A5E5B08L
comma
l_int|0x571D7DD1L
comma
l_int|0x53DC6066L
comma
l_int|0x4D9B3063L
comma
l_int|0x495A2DD4L
comma
l_int|0x44190B0DL
comma
l_int|0x40D816BAL
comma
l_int|0xACA5C697L
comma
l_int|0xA864DB20L
comma
l_int|0xA527FDF9L
comma
l_int|0xA1E6E04EL
comma
l_int|0xBFA1B04BL
comma
l_int|0xBB60ADFCL
comma
l_int|0xB6238B25L
comma
l_int|0xB2E29692L
comma
l_int|0x8AAD2B2FL
comma
l_int|0x8E6C3698L
comma
l_int|0x832F1041L
comma
l_int|0x87EE0DF6L
comma
l_int|0x99A95DF3L
comma
l_int|0x9D684044L
comma
l_int|0x902B669DL
comma
l_int|0x94EA7B2AL
comma
l_int|0xE0B41DE7L
comma
l_int|0xE4750050L
comma
l_int|0xE9362689L
comma
l_int|0xEDF73B3EL
comma
l_int|0xF3B06B3BL
comma
l_int|0xF771768CL
comma
l_int|0xFA325055L
comma
l_int|0xFEF34DE2L
comma
l_int|0xC6BCF05FL
comma
l_int|0xC27DEDE8L
comma
l_int|0xCF3ECB31L
comma
l_int|0xCBFFD686L
comma
l_int|0xD5B88683L
comma
l_int|0xD1799B34L
comma
l_int|0xDC3ABDEDL
comma
l_int|0xD8FBA05AL
comma
l_int|0x690CE0EEL
comma
l_int|0x6DCDFD59L
comma
l_int|0x608EDB80L
comma
l_int|0x644FC637L
comma
l_int|0x7A089632L
comma
l_int|0x7EC98B85L
comma
l_int|0x738AAD5CL
comma
l_int|0x774BB0EBL
comma
l_int|0x4F040D56L
comma
l_int|0x4BC510E1L
comma
l_int|0x46863638L
comma
l_int|0x42472B8FL
comma
l_int|0x5C007B8AL
comma
l_int|0x58C1663DL
comma
l_int|0x558240E4L
comma
l_int|0x51435D53L
comma
l_int|0x251D3B9EL
comma
l_int|0x21DC2629L
comma
l_int|0x2C9F00F0L
comma
l_int|0x285E1D47L
comma
l_int|0x36194D42L
comma
l_int|0x32D850F5L
comma
l_int|0x3F9B762CL
comma
l_int|0x3B5A6B9BL
comma
l_int|0x0315D626L
comma
l_int|0x07D4CB91L
comma
l_int|0x0A97ED48L
comma
l_int|0x0E56F0FFL
comma
l_int|0x1011A0FAL
comma
l_int|0x14D0BD4DL
comma
l_int|0x19939B94L
comma
l_int|0x1D528623L
comma
l_int|0xF12F560EL
comma
l_int|0xF5EE4BB9L
comma
l_int|0xF8AD6D60L
comma
l_int|0xFC6C70D7L
comma
l_int|0xE22B20D2L
comma
l_int|0xE6EA3D65L
comma
l_int|0xEBA91BBCL
comma
l_int|0xEF68060BL
comma
l_int|0xD727BBB6L
comma
l_int|0xD3E6A601L
comma
l_int|0xDEA580D8L
comma
l_int|0xDA649D6FL
comma
l_int|0xC423CD6AL
comma
l_int|0xC0E2D0DDL
comma
l_int|0xCDA1F604L
comma
l_int|0xC960EBB3L
comma
l_int|0xBD3E8D7EL
comma
l_int|0xB9FF90C9L
comma
l_int|0xB4BCB610L
comma
l_int|0xB07DABA7L
comma
l_int|0xAE3AFBA2L
comma
l_int|0xAAFBE615L
comma
l_int|0xA7B8C0CCL
comma
l_int|0xA379DD7BL
comma
l_int|0x9B3660C6L
comma
l_int|0x9FF77D71L
comma
l_int|0x92B45BA8L
comma
l_int|0x9675461FL
comma
l_int|0x8832161AL
comma
l_int|0x8CF30BADL
comma
l_int|0x81B02D74L
comma
l_int|0x857130C3L
comma
l_int|0x5D8A9099L
comma
l_int|0x594B8D2EL
comma
l_int|0x5408ABF7L
comma
l_int|0x50C9B640L
comma
l_int|0x4E8EE645L
comma
l_int|0x4A4FFBF2L
comma
l_int|0x470CDD2BL
comma
l_int|0x43CDC09CL
comma
l_int|0x7B827D21L
comma
l_int|0x7F436096L
comma
l_int|0x7200464FL
comma
l_int|0x76C15BF8L
comma
l_int|0x68860BFDL
comma
l_int|0x6C47164AL
comma
l_int|0x61043093L
comma
l_int|0x65C52D24L
comma
l_int|0x119B4BE9L
comma
l_int|0x155A565EL
comma
l_int|0x18197087L
comma
l_int|0x1CD86D30L
comma
l_int|0x029F3D35L
comma
l_int|0x065E2082L
comma
l_int|0x0B1D065BL
comma
l_int|0x0FDC1BECL
comma
l_int|0x3793A651L
comma
l_int|0x3352BBE6L
comma
l_int|0x3E119D3FL
comma
l_int|0x3AD08088L
comma
l_int|0x2497D08DL
comma
l_int|0x2056CD3AL
comma
l_int|0x2D15EBE3L
comma
l_int|0x29D4F654L
comma
l_int|0xC5A92679L
comma
l_int|0xC1683BCEL
comma
l_int|0xCC2B1D17L
comma
l_int|0xC8EA00A0L
comma
l_int|0xD6AD50A5L
comma
l_int|0xD26C4D12L
comma
l_int|0xDF2F6BCBL
comma
l_int|0xDBEE767CL
comma
l_int|0xE3A1CBC1L
comma
l_int|0xE760D676L
comma
l_int|0xEA23F0AFL
comma
l_int|0xEEE2ED18L
comma
l_int|0xF0A5BD1DL
comma
l_int|0xF464A0AAL
comma
l_int|0xF9278673L
comma
l_int|0xFDE69BC4L
comma
l_int|0x89B8FD09L
comma
l_int|0x8D79E0BEL
comma
l_int|0x803AC667L
comma
l_int|0x84FBDBD0L
comma
l_int|0x9ABC8BD5L
comma
l_int|0x9E7D9662L
comma
l_int|0x933EB0BBL
comma
l_int|0x97FFAD0CL
comma
l_int|0xAFB010B1L
comma
l_int|0xAB710D06L
comma
l_int|0xA6322BDFL
comma
l_int|0xA2F33668L
comma
l_int|0xBCB4666DL
comma
l_int|0xB8757BDAL
comma
l_int|0xB5365D03L
comma
l_int|0xB1F740B4L
)brace
suffix:semicolon
macro_line|#ifdef CRCASM
DECL|function|calc_crc
r_int
r_int
id|calc_crc
(paren
r_char
op_star
id|mem
comma
r_int
id|len
comma
r_int
id|initial
)paren
(brace
r_int
id|crc
comma
id|dummy_len
suffix:semicolon
id|__asm__
(paren
l_string|&quot;xorl %%eax,%%eax&bslash;n&bslash;t&quot;
l_string|&quot;1:&bslash;n&bslash;t&quot;
l_string|&quot;movl %%edx,%%eax&bslash;n&bslash;t&quot;
l_string|&quot;shrl $16,%%eax&bslash;n&bslash;t&quot;
l_string|&quot;lodsb&bslash;n&bslash;t&quot;
l_string|&quot;xorb %%ah,%%al&bslash;n&bslash;t&quot;
l_string|&quot;andl $255,%%eax&bslash;n&bslash;t&quot;
l_string|&quot;shll $8,%%edx&bslash;n&bslash;t&quot;
l_string|&quot;xorl (%%edi,%%eax,4),%%edx&bslash;n&bslash;t&quot;
l_string|&quot;loop 1b&quot;
suffix:colon
l_string|&quot;=d&quot;
(paren
id|crc
)paren
comma
l_string|&quot;=c&quot;
(paren
id|dummy_len
)paren
suffix:colon
l_string|&quot;S&quot;
(paren
id|mem
)paren
comma
l_string|&quot;D&quot;
(paren
op_amp
id|crc32tab
(braket
l_int|0
)braket
)paren
comma
l_string|&quot;1&quot;
(paren
id|len
)paren
comma
l_string|&quot;0&quot;
(paren
id|initial
)paren
suffix:colon
l_string|&quot;eax&quot;
)paren
suffix:semicolon
r_return
id|crc
suffix:semicolon
)brace
macro_line|#else
DECL|function|calc_crc
r_int
r_int
id|calc_crc
(paren
r_char
op_star
id|mem
comma
r_int
id|len
comma
r_int
id|initial
)paren
(brace
r_int
id|crc
suffix:semicolon
id|crc
op_assign
id|initial
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|len
suffix:semicolon
id|mem
op_increment
comma
id|len
op_decrement
)paren
(brace
id|crc
op_assign
id|CRC32
(paren
op_star
id|mem
comma
id|crc
)paren
suffix:semicolon
)brace
r_return
(paren
id|crc
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|macro|crc32
mdefine_line|#define crc32( crc, mem, len) calc_crc(mem, len, crc);
multiline_comment|/* initialization routines. not used at the moment&n; * I will avoid these as long as possible !!&n; */
DECL|function|open_atmsar
r_int
id|open_atmsar
(paren
r_void
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|remove_atmsar
r_int
id|remove_atmsar
(paren
r_void
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ATOMIC version of alloc_tx */
DECL|function|atmsar_alloc_skb_wrapper
r_struct
id|sk_buff
op_star
id|atmsar_alloc_skb_wrapper
(paren
r_struct
id|atm_vcc
op_star
id|vcc
comma
r_int
r_int
id|size
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
(paren
op_amp
id|vcc-&gt;tx_inuse
)paren
op_logical_and
op_logical_neg
id|atm_may_send
(paren
id|vcc
comma
id|size
)paren
)paren
(brace
id|PDEBUG
(paren
l_string|&quot;Sorry: tx_inuse = %d, size = %d, sndbuf = %d&bslash;n&quot;
comma
id|atomic_read
(paren
op_amp
id|vcc-&gt;tx_inuse
)paren
comma
id|size
comma
id|vcc-&gt;sk-&gt;sndbuf
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|skb
op_assign
id|alloc_skb
(paren
id|size
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_return
l_int|NULL
suffix:semicolon
id|atomic_add
(paren
id|skb-&gt;truesize
op_plus
id|ATM_PDU_OVHD
comma
op_amp
id|vcc-&gt;tx_inuse
)paren
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
DECL|function|atmsar_alloc_tx
r_struct
id|sk_buff
op_star
id|atmsar_alloc_tx
(paren
r_struct
id|atmsar_vcc_data
op_star
id|vcc
comma
r_int
r_int
id|size
)paren
(brace
r_struct
id|sk_buff
op_star
id|tmp
op_assign
l_int|NULL
suffix:semicolon
r_int
id|bufsize
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|vcc-&gt;type
)paren
(brace
r_case
id|ATMSAR_TYPE_AAL0
suffix:colon
multiline_comment|/* reserving adequate headroom */
id|bufsize
op_assign
id|size
op_plus
(paren
(paren
(paren
id|size
op_div
l_int|48
)paren
op_plus
l_int|1
)paren
op_star
(paren
(paren
id|vcc-&gt;flags
op_amp
id|ATMSAR_USE_53BYTE_CELL
)paren
ques
c_cond
l_int|5
suffix:colon
l_int|4
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ATMSAR_TYPE_AAL1
suffix:colon
multiline_comment|/* reserving adequate headroom */
id|bufsize
op_assign
id|size
op_plus
(paren
(paren
(paren
id|size
op_div
l_int|47
)paren
op_plus
l_int|1
)paren
op_star
(paren
(paren
id|vcc-&gt;flags
op_amp
id|ATMSAR_USE_53BYTE_CELL
)paren
ques
c_cond
l_int|5
suffix:colon
l_int|4
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ATMSAR_TYPE_AAL2
suffix:colon
r_case
id|ATMSAR_TYPE_AAL34
suffix:colon
multiline_comment|/* not supported */
r_break
suffix:semicolon
r_case
id|ATMSAR_TYPE_AAL5
suffix:colon
multiline_comment|/* reserving adequate tailroom */
id|bufsize
op_assign
id|size
op_plus
(paren
(paren
(paren
id|size
op_plus
l_int|8
op_plus
l_int|47
)paren
op_div
l_int|48
)paren
op_star
l_int|48
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|PDEBUG
(paren
l_string|&quot;Requested size %d, Allocating size %d&bslash;n&quot;
comma
id|size
comma
id|bufsize
)paren
suffix:semicolon
id|tmp
op_assign
id|vcc-&gt;alloc_tx
(paren
id|vcc-&gt;vcc
comma
id|bufsize
)paren
suffix:semicolon
id|skb_put
(paren
id|tmp
comma
id|bufsize
)paren
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
DECL|function|atmsar_open
r_struct
id|atmsar_vcc_data
op_star
id|atmsar_open
(paren
r_struct
id|atmsar_vcc_data
op_star
op_star
id|list
comma
r_struct
id|atm_vcc
op_star
id|vcc
comma
id|uint
id|type
comma
id|ushort
id|vpi
comma
id|ushort
id|vci
comma
id|unchar
id|pti
comma
id|unchar
id|gfc
comma
id|uint
id|flags
)paren
(brace
r_struct
id|atmsar_vcc_data
op_star
r_new
suffix:semicolon
r_new
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|atmsar_vcc_data
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vcc
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
(paren
r_new
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|atmsar_vcc_data
)paren
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|vcc
op_assign
id|vcc
suffix:semicolon
multiline_comment|/*&n; * This gives problems with the ATM layer alloc_tx().&n; * It is not usable from interrupt context and for&n; * some reason this is used in interrupt context&n; * with br2684.c&n; *&n;  if (vcc-&gt;alloc_tx)&n;    new-&gt;alloc_tx  = vcc-&gt;alloc_tx;&n;  else&n;*/
r_new
op_member_access_from_pointer
id|alloc_tx
op_assign
id|atmsar_alloc_skb_wrapper
suffix:semicolon
r_new
op_member_access_from_pointer
id|stats
op_assign
id|vcc-&gt;stats
suffix:semicolon
r_new
op_member_access_from_pointer
id|type
op_assign
id|type
suffix:semicolon
r_new
op_member_access_from_pointer
id|next
op_assign
l_int|NULL
suffix:semicolon
r_new
op_member_access_from_pointer
id|gfc
op_assign
id|gfc
suffix:semicolon
r_new
op_member_access_from_pointer
id|vp
op_assign
id|vpi
suffix:semicolon
r_new
op_member_access_from_pointer
id|vc
op_assign
id|vci
suffix:semicolon
r_new
op_member_access_from_pointer
id|pti
op_assign
id|pti
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|ATMSAR_TYPE_AAL0
suffix:colon
r_new
op_member_access_from_pointer
id|mtu
op_assign
id|ATMSAR_DEF_MTU_AAL0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ATMSAR_TYPE_AAL1
suffix:colon
r_new
op_member_access_from_pointer
id|mtu
op_assign
id|ATMSAR_DEF_MTU_AAL1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ATMSAR_TYPE_AAL2
suffix:colon
r_new
op_member_access_from_pointer
id|mtu
op_assign
id|ATMSAR_DEF_MTU_AAL2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ATMSAR_TYPE_AAL34
suffix:colon
multiline_comment|/* not supported */
r_new
op_member_access_from_pointer
id|mtu
op_assign
id|ATMSAR_DEF_MTU_AAL34
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ATMSAR_TYPE_AAL5
suffix:colon
r_new
op_member_access_from_pointer
id|mtu
op_assign
id|ATMSAR_DEF_MTU_AAL5
suffix:semicolon
r_break
suffix:semicolon
)brace
r_new
op_member_access_from_pointer
id|atmHeader
op_assign
(paren
(paren
r_int
r_int
)paren
id|gfc
op_lshift
id|ATM_HDR_GFC_SHIFT
)paren
op_or
(paren
(paren
r_int
r_int
)paren
id|vpi
op_lshift
id|ATM_HDR_VPI_SHIFT
)paren
op_or
(paren
(paren
r_int
r_int
)paren
id|vci
op_lshift
id|ATM_HDR_VCI_SHIFT
)paren
op_or
(paren
(paren
r_int
r_int
)paren
id|pti
op_lshift
id|ATM_HDR_PTI_SHIFT
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|flags
op_assign
id|flags
suffix:semicolon
r_new
op_member_access_from_pointer
id|next
op_assign
l_int|NULL
suffix:semicolon
r_new
op_member_access_from_pointer
id|reasBuffer
op_assign
l_int|NULL
suffix:semicolon
r_new
op_member_access_from_pointer
id|next
op_assign
op_star
id|list
suffix:semicolon
op_star
id|list
op_assign
r_new
suffix:semicolon
id|PDEBUG
(paren
l_string|&quot;Allocated new SARLib vcc 0x%p with vp %d vc %d&bslash;n&quot;
comma
r_new
comma
id|vpi
comma
id|vci
)paren
suffix:semicolon
r_return
r_new
suffix:semicolon
)brace
DECL|function|atmsar_close
r_void
id|atmsar_close
(paren
r_struct
id|atmsar_vcc_data
op_star
op_star
id|list
comma
r_struct
id|atmsar_vcc_data
op_star
id|vcc
)paren
(brace
r_struct
id|atmsar_vcc_data
op_star
id|work
suffix:semicolon
r_if
c_cond
(paren
op_star
id|list
op_eq
id|vcc
)paren
(brace
op_star
id|list
op_assign
(paren
op_star
id|list
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|work
op_assign
op_star
id|list
suffix:semicolon
id|work
op_logical_and
id|work-&gt;next
op_logical_and
(paren
id|work-&gt;next
op_ne
id|vcc
)paren
suffix:semicolon
id|work
op_assign
id|work-&gt;next
)paren
suffix:semicolon
multiline_comment|/* return if not found */
r_if
c_cond
(paren
id|work-&gt;next
op_ne
id|vcc
)paren
r_return
suffix:semicolon
id|work-&gt;next
op_assign
id|work-&gt;next-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vcc-&gt;reasBuffer
)paren
(brace
id|dev_kfree_skb
(paren
id|vcc-&gt;reasBuffer
)paren
suffix:semicolon
)brace
id|PDEBUG
(paren
l_string|&quot;Allocated SARLib vcc 0x%p with vp %d vc %d&bslash;n&quot;
comma
id|vcc
comma
id|vcc-&gt;vp
comma
id|vcc-&gt;vc
)paren
suffix:semicolon
id|kfree
(paren
id|vcc
)paren
suffix:semicolon
)brace
multiline_comment|/***********************&n; **&n; **    ENCODE FUNCTIONS&n; **&n; ***********************/
DECL|function|atmsar_encode_rawcell
r_struct
id|sk_buff
op_star
id|atmsar_encode_rawcell
(paren
r_struct
id|atmsar_vcc_data
op_star
id|ctx
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|number_of_cells
op_assign
(paren
id|skb-&gt;len
)paren
op_div
l_int|48
suffix:semicolon
r_int
id|total_length
op_assign
id|number_of_cells
op_star
(paren
id|ctx-&gt;flags
op_amp
id|ATMSAR_USE_53BYTE_CELL
ques
c_cond
l_int|53
suffix:colon
l_int|52
)paren
suffix:semicolon
r_int
r_char
op_star
id|source
suffix:semicolon
r_int
r_char
op_star
id|target
suffix:semicolon
r_struct
id|sk_buff
op_star
id|out
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
suffix:semicolon
id|PDEBUG
(paren
l_string|&quot;atmsar_encode_rawcell (0x%p, 0x%p) called&bslash;n&quot;
comma
id|ctx
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb_cloned
(paren
id|skb
)paren
op_logical_or
(paren
id|skb_headroom
(paren
id|skb
)paren
OL
(paren
id|number_of_cells
op_star
(paren
id|ctx-&gt;flags
op_amp
id|ATMSAR_USE_53BYTE_CELL
ques
c_cond
l_int|5
suffix:colon
l_int|4
)paren
)paren
)paren
)paren
(brace
id|PDEBUG
(paren
l_string|&quot;atmsar_encode_rawcell allocating new skb. ctx-&gt;alloc_tx = 0x%p, ctx-&gt;vcc = 0x%p&bslash;n&quot;
comma
id|ctx-&gt;alloc_tx
comma
id|ctx-&gt;vcc
)paren
suffix:semicolon
multiline_comment|/* get new skb */
id|out
op_assign
id|ctx-&gt;alloc_tx
(paren
id|ctx-&gt;vcc
comma
id|total_length
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|out
)paren
r_return
l_int|NULL
suffix:semicolon
id|skb_put
(paren
id|out
comma
id|total_length
)paren
suffix:semicolon
id|source
op_assign
id|skb-&gt;data
suffix:semicolon
id|target
op_assign
id|out-&gt;data
suffix:semicolon
)brace
r_else
(brace
id|PDEBUG
(paren
l_string|&quot;atmsar_encode_rawcell: sufficient headroom&bslash;n&quot;
)paren
suffix:semicolon
id|source
op_assign
id|skb-&gt;data
suffix:semicolon
id|skb_push
(paren
id|skb
comma
id|number_of_cells
op_star
(paren
(paren
id|ctx-&gt;flags
op_amp
id|ATMSAR_USE_53BYTE_CELL
)paren
ques
c_cond
l_int|5
suffix:colon
l_int|4
)paren
)paren
suffix:semicolon
id|target
op_assign
id|skb-&gt;data
suffix:semicolon
id|out
op_assign
id|skb
suffix:semicolon
)brace
id|PDEBUG
(paren
l_string|&quot;source 0x=%p, target 0x%p&bslash;n&quot;
comma
id|source
comma
id|target
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;flags
op_amp
id|ATMSAR_USE_53BYTE_CELL
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|number_of_cells
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ADD_HEADER
(paren
id|target
comma
id|ctx-&gt;atmHeader
)paren
suffix:semicolon
op_star
id|target
op_increment
op_assign
(paren
r_char
)paren
l_int|0xEC
suffix:semicolon
id|memcpy
(paren
id|target
comma
id|source
comma
l_int|48
)paren
suffix:semicolon
id|target
op_add_assign
l_int|48
suffix:semicolon
id|source
op_add_assign
l_int|48
suffix:semicolon
id|PDEBUG
(paren
l_string|&quot;source 0x=%p, target 0x%p&bslash;n&quot;
comma
id|source
comma
id|target
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|number_of_cells
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ADD_HEADER
(paren
id|target
comma
id|ctx-&gt;atmHeader
)paren
suffix:semicolon
id|memcpy
(paren
id|target
comma
id|source
comma
l_int|48
)paren
suffix:semicolon
id|target
op_add_assign
l_int|48
suffix:semicolon
id|source
op_add_assign
l_int|48
suffix:semicolon
id|PDEBUG
(paren
l_string|&quot;source 0x=%p, target 0x%p&bslash;n&quot;
comma
id|source
comma
id|target
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx-&gt;flags
op_amp
id|ATMSAR_SET_PTI
)paren
(brace
multiline_comment|/* setting pti bit in last cell */
op_star
(paren
id|target
op_minus
(paren
id|ctx-&gt;flags
op_amp
id|ATMSAR_USE_53BYTE_CELL
ques
c_cond
l_int|50
suffix:colon
l_int|49
)paren
)paren
op_or_assign
l_int|0x2
suffix:semicolon
)brace
multiline_comment|/* update stats */
r_if
c_cond
(paren
id|ctx-&gt;stats
op_logical_and
(paren
id|ctx-&gt;type
op_le
id|ATMSAR_TYPE_AAL1
)paren
)paren
id|atomic_add
(paren
id|number_of_cells
comma
op_amp
(paren
id|ctx-&gt;stats-&gt;tx
)paren
)paren
suffix:semicolon
id|PDEBUG
(paren
l_string|&quot;atmsar_encode_rawcell return 0x%p (length %d)&bslash;n&quot;
comma
id|out
comma
id|out-&gt;len
)paren
suffix:semicolon
r_return
id|out
suffix:semicolon
)brace
DECL|function|atmsar_encode_aal5
r_struct
id|sk_buff
op_star
id|atmsar_encode_aal5
(paren
r_struct
id|atmsar_vcc_data
op_star
id|ctx
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
id|length
comma
id|pdu_length
suffix:semicolon
r_int
r_char
op_star
id|trailer
suffix:semicolon
r_int
r_char
op_star
id|pad
suffix:semicolon
id|uint
id|crc
op_assign
l_int|0xffffffff
suffix:semicolon
id|PDEBUG
(paren
l_string|&quot;atmsar_encode_aal5 (0x%p, 0x%p) called&bslash;n&quot;
comma
id|ctx
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/* determine aal5 length */
id|pdu_length
op_assign
id|skb-&gt;len
suffix:semicolon
id|length
op_assign
(paren
(paren
id|pdu_length
op_plus
l_int|8
op_plus
l_int|47
)paren
op_div
l_int|48
)paren
op_star
l_int|48
suffix:semicolon
r_if
c_cond
(paren
id|skb_tailroom
(paren
id|skb
)paren
OL
(paren
id|length
op_minus
id|pdu_length
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|out
suffix:semicolon
id|PDEBUG
(paren
l_string|&quot;atmsar_encode_aal5 allocating new skb. ctx-&gt;alloc_tx = 0x%p, ctx-&gt;vcc = 0x%p&bslash;n&quot;
comma
id|ctx-&gt;alloc_tx
comma
id|ctx-&gt;vcc
)paren
suffix:semicolon
multiline_comment|/* get new skb */
id|out
op_assign
id|ctx-&gt;alloc_tx
(paren
id|ctx-&gt;vcc
comma
id|length
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|out
)paren
r_return
l_int|NULL
suffix:semicolon
id|PDEBUG
(paren
l_string|&quot;out-&gt;data = 0x%p&bslash;n&quot;
comma
id|out-&gt;data
)paren
suffix:semicolon
id|PDEBUG
(paren
l_string|&quot;atmsar_encode_aal5 pdu length %d, allocated length %d&bslash;n&quot;
comma
id|skb-&gt;len
comma
id|length
)paren
suffix:semicolon
id|memcpy
(paren
id|out-&gt;data
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|skb_put
(paren
id|out
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|skb
op_assign
id|out
suffix:semicolon
)brace
id|PDEBUG
(paren
l_string|&quot;skb-&gt;data = 0x%p&bslash;n&quot;
comma
id|skb-&gt;data
)paren
suffix:semicolon
multiline_comment|/* note end of pdu and add length */
id|pad
op_assign
id|skb_put
(paren
id|skb
comma
id|length
op_minus
id|pdu_length
)paren
suffix:semicolon
id|trailer
op_assign
id|skb-&gt;tail
op_minus
l_int|8
suffix:semicolon
id|PDEBUG
(paren
l_string|&quot;trailer = 0x%p&bslash;n&quot;
comma
id|trailer
)paren
suffix:semicolon
multiline_comment|/* zero padding space */
id|memset
(paren
id|pad
comma
l_int|0
comma
id|length
op_minus
id|pdu_length
op_minus
l_int|8
)paren
suffix:semicolon
multiline_comment|/* add trailer */
op_star
id|trailer
op_increment
op_assign
(paren
r_int
r_char
)paren
l_int|0
suffix:semicolon
multiline_comment|/* UU  = 0 */
op_star
id|trailer
op_increment
op_assign
(paren
r_int
r_char
)paren
l_int|0
suffix:semicolon
multiline_comment|/* CPI = 0 */
op_star
id|trailer
op_increment
op_assign
(paren
r_int
r_char
)paren
(paren
id|pdu_length
op_rshift
l_int|8
)paren
suffix:semicolon
op_star
id|trailer
op_increment
op_assign
(paren
r_int
r_char
)paren
(paren
id|pdu_length
op_amp
l_int|0xff
)paren
suffix:semicolon
id|crc
op_assign
op_complement
id|crc32
(paren
id|crc
comma
id|skb-&gt;data
comma
id|length
op_minus
l_int|4
)paren
suffix:semicolon
op_star
id|trailer
op_increment
op_assign
(paren
r_int
r_char
)paren
(paren
id|crc
op_rshift
l_int|24
)paren
suffix:semicolon
op_star
id|trailer
op_increment
op_assign
(paren
r_int
r_char
)paren
(paren
id|crc
op_rshift
l_int|16
)paren
suffix:semicolon
op_star
id|trailer
op_increment
op_assign
(paren
r_int
r_char
)paren
(paren
id|crc
op_rshift
l_int|8
)paren
suffix:semicolon
op_star
id|trailer
op_increment
op_assign
(paren
r_int
r_char
)paren
(paren
id|crc
op_amp
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/* update stats */
r_if
c_cond
(paren
id|ctx-&gt;stats
)paren
id|atomic_inc
(paren
op_amp
id|ctx-&gt;stats-&gt;tx
)paren
suffix:semicolon
id|PDEBUG
(paren
l_string|&quot;atmsar_encode_aal5 return 0x%p (length %d)&bslash;n&quot;
comma
id|skb
comma
id|skb-&gt;len
)paren
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
multiline_comment|/***********************&n; **&n; **  DECODE FUNCTIONS&n; **&n; ***********************/
DECL|function|atmsar_decode_rawcell
r_struct
id|sk_buff
op_star
id|atmsar_decode_rawcell
(paren
r_struct
id|atmsar_vcc_data
op_star
id|list
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|atmsar_vcc_data
op_star
op_star
id|ctx
)paren
(brace
r_while
c_loop
(paren
id|skb-&gt;len
)paren
(brace
r_int
r_char
op_star
id|cell
op_assign
id|skb-&gt;data
suffix:semicolon
r_int
r_char
op_star
id|cell_payload
suffix:semicolon
r_struct
id|atmsar_vcc_data
op_star
id|vcc
op_assign
id|list
suffix:semicolon
r_int
r_int
id|atmHeader
op_assign
(paren
(paren
r_int
r_int
)paren
(paren
id|cell
(braket
l_int|0
)braket
)paren
op_lshift
l_int|24
)paren
op_or
(paren
(paren
r_int
r_int
)paren
(paren
id|cell
(braket
l_int|1
)braket
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
r_int
r_int
)paren
(paren
id|cell
(braket
l_int|2
)braket
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|cell
(braket
l_int|3
)braket
op_amp
l_int|0xff
)paren
suffix:semicolon
id|PDEBUG
(paren
l_string|&quot;atmsar_decode_rawcell (0x%p, 0x%p, 0x%p) called&bslash;n&quot;
comma
id|list
comma
id|skb
comma
id|ctx
)paren
suffix:semicolon
id|PDEBUG
(paren
l_string|&quot;atmsar_decode_rawcell skb-&gt;data %p, skb-&gt;tail %p&bslash;n&quot;
comma
id|skb-&gt;data
comma
id|skb-&gt;tail
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list
op_logical_or
op_logical_neg
id|skb
op_logical_or
op_logical_neg
id|ctx
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;data
op_logical_or
op_logical_neg
id|skb-&gt;tail
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* here should the header CRC check be... */
multiline_comment|/* look up correct vcc */
r_for
c_loop
(paren
suffix:semicolon
id|vcc
op_logical_and
(paren
(paren
id|vcc-&gt;atmHeader
op_amp
id|ATM_HDR_VPVC_MASK
)paren
op_ne
(paren
id|atmHeader
op_amp
id|ATM_HDR_VPVC_MASK
)paren
)paren
suffix:semicolon
id|vcc
op_assign
id|vcc-&gt;next
)paren
suffix:semicolon
id|PDEBUG
(paren
l_string|&quot;atmsar_decode_rawcell found vcc %p for packet on vp %d, vc %d&bslash;n&quot;
comma
id|vcc
comma
(paren
r_int
)paren
(paren
(paren
id|atmHeader
op_amp
id|ATM_HDR_VPI_MASK
)paren
op_rshift
id|ATM_HDR_VPI_SHIFT
)paren
comma
(paren
r_int
)paren
(paren
(paren
id|atmHeader
op_amp
id|ATM_HDR_VCI_MASK
)paren
op_rshift
id|ATM_HDR_VCI_SHIFT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vcc
op_logical_and
(paren
id|skb-&gt;len
op_ge
(paren
id|vcc-&gt;flags
op_amp
id|ATMSAR_USE_53BYTE_CELL
ques
c_cond
l_int|53
suffix:colon
l_int|52
)paren
)paren
)paren
(brace
id|cell_payload
op_assign
id|cell
op_plus
(paren
id|vcc-&gt;flags
op_amp
id|ATMSAR_USE_53BYTE_CELL
ques
c_cond
l_int|5
suffix:colon
l_int|4
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|vcc-&gt;type
)paren
(brace
r_case
id|ATMSAR_TYPE_AAL0
suffix:colon
multiline_comment|/* case ATMSAR_TYPE_AAL1: when we have a decode AAL1 function... */
(brace
r_struct
id|sk_buff
op_star
id|tmp
op_assign
id|dev_alloc_skb
(paren
id|vcc-&gt;mtu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
(brace
id|memcpy
(paren
id|tmp-&gt;tail
comma
id|cell_payload
comma
l_int|48
)paren
suffix:semicolon
id|skb_put
(paren
id|tmp
comma
l_int|48
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vcc-&gt;stats
)paren
id|atomic_inc
(paren
op_amp
id|vcc-&gt;stats-&gt;rx
)paren
suffix:semicolon
id|skb_pull
(paren
id|skb
comma
(paren
id|vcc
op_member_access_from_pointer
id|flags
op_amp
id|ATMSAR_USE_53BYTE_CELL
ques
c_cond
l_int|53
suffix:colon
l_int|52
)paren
)paren
suffix:semicolon
id|PDEBUG
(paren
l_string|&quot;atmsar_decode_rawcell returns ATMSAR_TYPE_AAL0 pdu 0x%p with length %d&bslash;n&quot;
comma
id|tmp
comma
id|tmp-&gt;len
)paren
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ATMSAR_TYPE_AAL1
suffix:colon
r_case
id|ATMSAR_TYPE_AAL2
suffix:colon
r_case
id|ATMSAR_TYPE_AAL34
suffix:colon
multiline_comment|/* not supported */
r_break
suffix:semicolon
r_case
id|ATMSAR_TYPE_AAL5
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|vcc-&gt;reasBuffer
)paren
id|vcc-&gt;reasBuffer
op_assign
id|dev_alloc_skb
(paren
id|vcc-&gt;mtu
)paren
suffix:semicolon
multiline_comment|/* if alloc fails, we just drop the cell. it is possible that we can still&n;&t;&t;&t;&t; * receive cells on other vcc&squot;s&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|vcc-&gt;reasBuffer
)paren
(brace
multiline_comment|/* if (buffer overrun) discard received cells until now */
r_if
c_cond
(paren
(paren
id|vcc-&gt;reasBuffer-&gt;len
)paren
OG
(paren
id|vcc-&gt;mtu
op_minus
l_int|48
)paren
)paren
id|skb_trim
(paren
id|vcc-&gt;reasBuffer
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* copy data */
id|memcpy
(paren
id|vcc-&gt;reasBuffer-&gt;tail
comma
id|cell_payload
comma
l_int|48
)paren
suffix:semicolon
id|skb_put
(paren
id|vcc-&gt;reasBuffer
comma
l_int|48
)paren
suffix:semicolon
multiline_comment|/* check for end of buffer */
r_if
c_cond
(paren
id|cell
(braket
l_int|3
)braket
op_amp
l_int|0x2
)paren
(brace
r_struct
id|sk_buff
op_star
id|tmp
suffix:semicolon
multiline_comment|/* the aal5 buffer ends here, cut the buffer. */
multiline_comment|/* buffer will always have at least one whole cell, so */
multiline_comment|/* don&squot;t need to check return from skb_pull */
id|skb_pull
(paren
id|skb
comma
(paren
id|vcc
op_member_access_from_pointer
id|flags
op_amp
id|ATMSAR_USE_53BYTE_CELL
ques
c_cond
l_int|53
suffix:colon
l_int|52
)paren
)paren
suffix:semicolon
op_star
id|ctx
op_assign
id|vcc
suffix:semicolon
id|tmp
op_assign
id|vcc-&gt;reasBuffer
suffix:semicolon
id|vcc-&gt;reasBuffer
op_assign
l_int|NULL
suffix:semicolon
id|PDEBUG
(paren
l_string|&quot;atmsar_decode_rawcell returns ATMSAR_TYPE_AAL5 pdu 0x%p with length %d&bslash;n&quot;
comma
id|tmp
comma
id|tmp-&gt;len
)paren
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* flush the cell */
multiline_comment|/* buffer will always contain at least one whole cell, so don&squot;t */
multiline_comment|/* need to check return value from skb_pull */
id|skb_pull
(paren
id|skb
comma
(paren
id|vcc-&gt;flags
op_amp
id|ATMSAR_USE_53BYTE_CELL
ques
c_cond
l_int|53
suffix:colon
l_int|52
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* If data is corrupt and skb doesn&squot;t hold a whole cell, flush the lot */
r_if
c_cond
(paren
id|skb_pull
(paren
id|skb
comma
(paren
id|list-&gt;flags
op_amp
id|ATMSAR_USE_53BYTE_CELL
ques
c_cond
l_int|53
suffix:colon
l_int|52
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|skb_trim
(paren
id|skb
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
suffix:semicolon
DECL|function|atmsar_decode_aal5
r_struct
id|sk_buff
op_star
id|atmsar_decode_aal5
(paren
r_struct
id|atmsar_vcc_data
op_star
id|ctx
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|uint
id|crc
op_assign
l_int|0xffffffff
suffix:semicolon
id|uint
id|length
comma
id|pdu_crc
comma
id|pdu_length
suffix:semicolon
id|PDEBUG
(paren
l_string|&quot;atmsar_decode_aal5 (0x%p, 0x%p) called&bslash;n&quot;
comma
id|ctx
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
op_logical_and
(paren
id|skb-&gt;len
op_mod
l_int|48
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|length
op_assign
(paren
id|skb-&gt;tail
(braket
op_minus
l_int|6
)braket
op_lshift
l_int|8
)paren
op_plus
id|skb-&gt;tail
(braket
op_minus
l_int|5
)braket
suffix:semicolon
id|pdu_crc
op_assign
(paren
id|skb-&gt;tail
(braket
op_minus
l_int|4
)braket
op_lshift
l_int|24
)paren
op_plus
(paren
id|skb-&gt;tail
(braket
op_minus
l_int|3
)braket
op_lshift
l_int|16
)paren
op_plus
(paren
id|skb-&gt;tail
(braket
op_minus
l_int|2
)braket
op_lshift
l_int|8
)paren
op_plus
id|skb-&gt;tail
(braket
op_minus
l_int|1
)braket
suffix:semicolon
id|pdu_length
op_assign
(paren
(paren
id|length
op_plus
l_int|47
op_plus
l_int|8
)paren
op_div
l_int|48
)paren
op_star
l_int|48
suffix:semicolon
id|PDEBUG
(paren
l_string|&quot;atmsar_decode_aal5: skb-&gt;len = %d, length = %d, pdu_crc = 0x%x, pdu_length = %d&bslash;n&quot;
comma
id|skb-&gt;len
comma
id|length
comma
id|pdu_crc
comma
id|pdu_length
)paren
suffix:semicolon
multiline_comment|/* is skb long enough ? */
r_if
c_cond
(paren
id|skb-&gt;len
OL
id|pdu_length
)paren
(brace
r_if
c_cond
(paren
id|ctx-&gt;stats
)paren
id|atomic_inc
(paren
op_amp
id|ctx-&gt;stats-&gt;rx_err
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* is skb too long ? */
r_if
c_cond
(paren
id|skb-&gt;len
OG
id|pdu_length
)paren
(brace
id|PDEBUG
(paren
l_string|&quot;atmsar_decode_aal5: Warning: readjusting illeagl size %d -&gt; %d&bslash;n&quot;
comma
id|skb-&gt;len
comma
id|pdu_length
)paren
suffix:semicolon
multiline_comment|/* buffer is too long. we can try to recover&n;&t;&t; * if we discard the first part of the skb.&n;&t;&t; * the crc will decide whether this was ok&n;&t;&t; */
id|skb_pull
(paren
id|skb
comma
id|skb-&gt;len
op_minus
id|pdu_length
)paren
suffix:semicolon
)brace
id|crc
op_assign
op_complement
id|crc32
(paren
id|crc
comma
id|skb-&gt;data
comma
id|pdu_length
op_minus
l_int|4
)paren
suffix:semicolon
multiline_comment|/* check crc */
r_if
c_cond
(paren
id|pdu_crc
op_ne
id|crc
)paren
(brace
id|PDEBUG
(paren
l_string|&quot;atmsar_decode_aal5: crc check failed!&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;stats
)paren
id|atomic_inc
(paren
op_amp
id|ctx-&gt;stats-&gt;rx_err
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* pdu is ok */
id|skb_trim
(paren
id|skb
comma
id|length
)paren
suffix:semicolon
multiline_comment|/* update stats */
r_if
c_cond
(paren
id|ctx-&gt;stats
)paren
id|atomic_inc
(paren
op_amp
id|ctx-&gt;stats-&gt;rx
)paren
suffix:semicolon
id|PDEBUG
(paren
l_string|&quot;atmsar_decode_aal5 returns pdu 0x%p with length %d&bslash;n&quot;
comma
id|skb
comma
id|skb-&gt;len
)paren
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
suffix:semicolon
eof
