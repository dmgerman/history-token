macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/module.h&gt;
singleline_comment|//#include &lt;linux/time.h&gt;
macro_line|#include &lt;asm/scatterlist.h&gt;
macro_line|#if !defined (DEBUG) &amp;&amp; defined (CONFIG_USB_DEBUG)
DECL|macro|DEBUG
macro_line|#   define DEBUG
macro_line|#endif
macro_line|#include &lt;linux/usb.h&gt;
multiline_comment|/*-------------------------------------------------------------------------*/
singleline_comment|// FIXME make these public somewhere; usbdevfs.h?
singleline_comment|//
DECL|struct|usbtest_param
r_struct
id|usbtest_param
(brace
singleline_comment|// inputs
DECL|member|test_num
r_int
id|test_num
suffix:semicolon
multiline_comment|/* 0..(TEST_CASES-1) */
DECL|member|iterations
r_int
id|iterations
suffix:semicolon
DECL|member|length
r_int
id|length
suffix:semicolon
DECL|member|vary
r_int
id|vary
suffix:semicolon
DECL|member|sglen
r_int
id|sglen
suffix:semicolon
singleline_comment|// outputs
DECL|member|duration
r_struct
id|timeval
id|duration
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|USBTEST_REQUEST
mdefine_line|#define USBTEST_REQUEST&t;_IOWR(&squot;U&squot;, 100, struct usbtest_param)
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* this is accessed only through usbfs ioctl calls.&n; * one ioctl to issue a test ... no locking needed!!!&n; * tests create other threads if they need them.&n; * urbs and buffers are allocated dynamically,&n; * and data generated deterministically.&n; *&n; * there&squot;s a minor complication on disconnect(), since&n; * usbfs.disconnect() waits till our ioctl completes.&n; */
DECL|struct|usbtest_dev
r_struct
id|usbtest_dev
(brace
DECL|member|intf
r_struct
id|usb_interface
op_star
id|intf
suffix:semicolon
DECL|member|info
r_struct
id|testdev_info
op_star
id|info
suffix:semicolon
DECL|member|id
r_char
id|id
(braket
l_int|32
)braket
suffix:semicolon
DECL|member|in_pipe
r_int
id|in_pipe
suffix:semicolon
DECL|member|out_pipe
r_int
id|out_pipe
suffix:semicolon
)brace
suffix:semicolon
DECL|function|testdev_to_usbdev
r_static
r_struct
id|usb_device
op_star
id|testdev_to_usbdev
(paren
r_struct
id|usbtest_dev
op_star
id|test
)paren
(brace
r_return
id|interface_to_usbdev
(paren
id|test-&gt;intf
)paren
suffix:semicolon
)brace
multiline_comment|/* set up all urbs so they can be used with either bulk or interrupt */
DECL|macro|INTERRUPT_RATE
mdefine_line|#define&t;INTERRUPT_RATE&t;&t;1&t;/* msec/transfer */
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* Support for testing basic non-queued I/O streams.&n; *&n; * These just package urbs as requests that can be easily canceled.&n; * Each urb&squot;s data buffer is dynamically allocated; callers can fill&n; * them with non-zero test data (or test for it) when appropriate.&n; */
DECL|function|simple_callback
r_static
r_void
id|simple_callback
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
id|complete
(paren
(paren
r_struct
id|completion
op_star
)paren
id|urb-&gt;context
)paren
suffix:semicolon
)brace
DECL|function|simple_alloc_urb
r_static
r_struct
id|urb
op_star
id|simple_alloc_urb
(paren
r_struct
id|usb_device
op_star
id|udev
comma
r_int
id|pipe
comma
r_int
id|bytes
)paren
(brace
r_struct
id|urb
op_star
id|urb
suffix:semicolon
r_if
c_cond
(paren
id|bytes
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|urb
op_assign
id|usb_alloc_urb
(paren
l_int|0
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
r_return
id|urb
suffix:semicolon
id|usb_fill_bulk_urb
(paren
id|urb
comma
id|udev
comma
id|pipe
comma
l_int|0
comma
id|bytes
comma
id|simple_callback
comma
l_int|0
)paren
suffix:semicolon
id|urb-&gt;interval
op_assign
(paren
id|udev-&gt;speed
op_eq
id|USB_SPEED_HIGH
)paren
ques
c_cond
(paren
id|INTERRUPT_RATE
op_lshift
l_int|3
)paren
suffix:colon
id|INTERRUPT_RATE
comma
id|urb-&gt;transfer_flags
op_assign
id|URB_NO_DMA_MAP
suffix:semicolon
id|urb-&gt;transfer_buffer
op_assign
id|usb_buffer_alloc
(paren
id|udev
comma
id|bytes
comma
id|SLAB_KERNEL
comma
op_amp
id|urb-&gt;transfer_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb-&gt;transfer_buffer
)paren
(brace
id|usb_free_urb
(paren
id|urb
)paren
suffix:semicolon
id|urb
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|memset
(paren
id|urb-&gt;transfer_buffer
comma
l_int|0
comma
id|bytes
)paren
suffix:semicolon
r_return
id|urb
suffix:semicolon
)brace
DECL|function|simple_free_urb
r_static
r_void
id|simple_free_urb
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
id|usb_buffer_free
(paren
id|urb-&gt;dev
comma
id|urb-&gt;transfer_buffer_length
comma
id|urb-&gt;transfer_buffer
comma
id|urb-&gt;transfer_dma
)paren
suffix:semicolon
id|usb_free_urb
(paren
id|urb
)paren
suffix:semicolon
)brace
DECL|function|simple_io
r_static
r_int
id|simple_io
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|iterations
comma
r_int
id|vary
)paren
(brace
r_struct
id|usb_device
op_star
id|udev
op_assign
id|urb-&gt;dev
suffix:semicolon
r_int
id|max
op_assign
id|urb-&gt;transfer_buffer_length
suffix:semicolon
r_struct
id|completion
id|completion
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
id|urb-&gt;context
op_assign
op_amp
id|completion
suffix:semicolon
r_while
c_loop
(paren
id|iterations
op_decrement
OG
l_int|0
op_logical_and
id|retval
op_eq
l_int|0
)paren
(brace
id|init_completion
(paren
op_amp
id|completion
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|usb_submit_urb
(paren
id|urb
comma
id|SLAB_KERNEL
)paren
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* NOTE:  no timeouts; can&squot;t be broken out of by interrupt */
id|wait_for_completion
(paren
op_amp
id|completion
)paren
suffix:semicolon
id|retval
op_assign
id|urb-&gt;status
suffix:semicolon
id|urb-&gt;dev
op_assign
id|udev
suffix:semicolon
r_if
c_cond
(paren
id|vary
)paren
(brace
r_int
id|len
op_assign
id|urb-&gt;transfer_buffer_length
suffix:semicolon
id|len
op_add_assign
id|max
suffix:semicolon
id|len
op_mod_assign
id|max
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
id|len
op_assign
(paren
id|vary
OL
id|max
)paren
ques
c_cond
id|vary
suffix:colon
id|max
suffix:semicolon
id|urb-&gt;transfer_buffer_length
op_assign
id|len
suffix:semicolon
)brace
multiline_comment|/* FIXME if endpoint halted, clear halt (and log) */
)brace
id|urb-&gt;transfer_buffer_length
op_assign
id|max
suffix:semicolon
singleline_comment|// FIXME for unlink or fault handling tests, don&squot;t report
singleline_comment|// failure if retval is as we expected ...
r_if
c_cond
(paren
id|retval
)paren
id|dbg
(paren
l_string|&quot;simple_io failed, iterations left %d, status %d&quot;
comma
id|iterations
comma
id|retval
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* We use scatterlist primitives to test queued I/O.&n; * Yes, this also tests the scatterlist primitives.&n; */
DECL|function|free_sglist
r_static
r_void
id|free_sglist
(paren
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sg
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nents
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sg
(braket
id|i
)braket
dot
id|page
)paren
r_continue
suffix:semicolon
id|kfree
(paren
id|page_address
(paren
id|sg
(braket
id|i
)braket
dot
id|page
)paren
op_plus
id|sg
(braket
id|i
)braket
dot
id|offset
)paren
suffix:semicolon
)brace
id|kfree
(paren
id|sg
)paren
suffix:semicolon
)brace
r_static
r_struct
id|scatterlist
op_star
DECL|function|alloc_sglist
id|alloc_sglist
(paren
r_int
id|nents
comma
r_int
id|max
comma
r_int
id|vary
)paren
(brace
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|size
op_assign
id|max
suffix:semicolon
id|sg
op_assign
id|kmalloc
(paren
id|nents
op_star
r_sizeof
op_star
id|sg
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sg
)paren
r_return
l_int|0
suffix:semicolon
id|memset
(paren
id|sg
comma
l_int|0
comma
id|nents
op_star
r_sizeof
op_star
id|sg
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nents
suffix:semicolon
id|i
op_increment
)paren
(brace
r_char
op_star
id|buf
suffix:semicolon
id|buf
op_assign
id|kmalloc
(paren
id|size
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
(brace
id|free_sglist
(paren
id|sg
comma
id|i
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|memset
(paren
id|buf
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* kmalloc pages are always physically contiguous! */
id|sg
(braket
id|i
)braket
dot
id|page
op_assign
id|virt_to_page
(paren
id|buf
)paren
suffix:semicolon
id|sg
(braket
id|i
)braket
dot
id|offset
op_assign
(paren
(paren
r_int
)paren
id|buf
)paren
op_amp
op_complement
id|PAGE_MASK
suffix:semicolon
id|sg
(braket
id|i
)braket
dot
id|length
op_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|vary
)paren
(brace
id|size
op_add_assign
id|vary
suffix:semicolon
id|size
op_mod_assign
id|max
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
id|size
op_assign
(paren
id|vary
OL
id|max
)paren
ques
c_cond
id|vary
suffix:colon
id|max
suffix:semicolon
)brace
)brace
r_return
id|sg
suffix:semicolon
)brace
DECL|function|perform_sglist
r_static
r_int
id|perform_sglist
(paren
r_struct
id|usb_device
op_star
id|udev
comma
r_int
id|iterations
comma
r_int
id|pipe
comma
r_struct
id|usb_sg_request
op_star
id|req
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|retval
op_eq
l_int|0
op_logical_and
id|iterations
op_decrement
OG
l_int|0
)paren
(brace
id|retval
op_assign
id|usb_sg_init
(paren
id|req
comma
id|udev
comma
id|pipe
comma
(paren
id|udev-&gt;speed
op_eq
id|USB_SPEED_HIGH
)paren
ques
c_cond
(paren
id|INTERRUPT_RATE
op_lshift
l_int|3
)paren
suffix:colon
id|INTERRUPT_RATE
comma
id|sg
comma
id|nents
comma
l_int|0
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_break
suffix:semicolon
id|usb_sg_wait
(paren
id|req
)paren
suffix:semicolon
id|retval
op_assign
id|req-&gt;status
suffix:semicolon
multiline_comment|/* FIXME if endpoint halted, clear halt (and log) */
)brace
singleline_comment|// FIXME for unlink or fault handling tests, don&squot;t report
singleline_comment|// failure if retval is as we expected ...
r_if
c_cond
(paren
id|retval
)paren
id|dbg
(paren
l_string|&quot;perform_sglist failed, iterations left %d, status %d&quot;
comma
id|iterations
comma
id|retval
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* We only have this one interface to user space, through usbfs.&n; * User mode code can scan usbfs to find N different devices (maybe on&n; * different busses) to use when testing, and allocate one thread per&n; * test.  So discovery is simplified, and we have no device naming issues.&n; *&n; * Don&squot;t use these only as stress/load tests.  Use them along with with&n; * other USB bus activity:  plugging, unplugging, mousing, mp3 playback,&n; * video capture, and so on.  Run different tests at different times, in&n; * different sequences.  Nothing here should interact with other devices,&n; * except indirectly by consuming USB bandwidth and CPU resources for test&n; * threads and request completion.&n; */
DECL|function|usbtest_ioctl
r_static
r_int
id|usbtest_ioctl
(paren
r_struct
id|usb_interface
op_star
id|intf
comma
r_int
r_int
id|code
comma
r_void
op_star
id|buf
)paren
(brace
r_struct
id|usbtest_dev
op_star
id|dev
op_assign
id|dev_get_drvdata
(paren
op_amp
id|intf-&gt;dev
)paren
suffix:semicolon
r_struct
id|usb_device
op_star
id|udev
op_assign
id|testdev_to_usbdev
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|usbtest_param
op_star
id|param
op_assign
id|buf
suffix:semicolon
r_int
id|retval
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_struct
id|urb
op_star
id|urb
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
r_struct
id|usb_sg_request
id|req
suffix:semicolon
r_struct
id|timeval
id|start
suffix:semicolon
singleline_comment|// FIXME USBDEVFS_CONNECTINFO doesn&squot;t say how fast the device is.
r_if
c_cond
(paren
id|code
op_ne
id|USBTEST_REQUEST
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_if
c_cond
(paren
id|param-&gt;iterations
op_le
l_int|0
op_logical_or
id|param-&gt;length
OL
l_int|0
op_logical_or
id|param-&gt;sglen
OL
l_int|0
op_logical_or
id|param-&gt;vary
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * Just a bunch of test cases that every HCD is expected to handle.&n;&t; *&n;&t; * Some may need specific firmware, though it&squot;d be good to have&n;&t; * one firmware image to handle all the test cases.&n;&t; *&n;&t; * FIXME add more tests!  cancel requests, verify the data, control&n;&t; * requests, and so on.&n;&t; */
id|do_gettimeofday
(paren
op_amp
id|start
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|param-&gt;test_num
)paren
(brace
r_case
l_int|0
suffix:colon
id|dbg
(paren
l_string|&quot;%s TEST 0:  NOP&quot;
comma
id|dev-&gt;id
)paren
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Simple non-queued bulk I/O tests */
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;out_pipe
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s TEST 1:  write %d bytes %u times&quot;
comma
id|dev-&gt;id
comma
id|param-&gt;length
comma
id|param-&gt;iterations
)paren
suffix:semicolon
id|urb
op_assign
id|simple_alloc_urb
(paren
id|udev
comma
id|dev-&gt;out_pipe
comma
id|param-&gt;length
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
(brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
singleline_comment|// FIRMWARE:  bulk sink (maybe accepts short writes)
id|retval
op_assign
id|simple_io
(paren
id|urb
comma
id|param-&gt;iterations
comma
l_int|0
)paren
suffix:semicolon
id|simple_free_urb
(paren
id|urb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;in_pipe
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s TEST 2:  read %d bytes %u times&quot;
comma
id|dev-&gt;id
comma
id|param-&gt;length
comma
id|param-&gt;iterations
)paren
suffix:semicolon
id|urb
op_assign
id|simple_alloc_urb
(paren
id|udev
comma
id|dev-&gt;in_pipe
comma
id|param-&gt;length
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
(brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
singleline_comment|// FIRMWARE:  bulk source (maybe generates short writes)
id|retval
op_assign
id|simple_io
(paren
id|urb
comma
id|param-&gt;iterations
comma
l_int|0
)paren
suffix:semicolon
id|simple_free_urb
(paren
id|urb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;out_pipe
op_eq
l_int|0
op_logical_or
id|param-&gt;vary
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s TEST 3:  write/%d 0..%d bytes %u times&quot;
comma
id|dev-&gt;id
comma
id|param-&gt;vary
comma
id|param-&gt;length
comma
id|param-&gt;iterations
)paren
suffix:semicolon
id|urb
op_assign
id|simple_alloc_urb
(paren
id|udev
comma
id|dev-&gt;out_pipe
comma
id|param-&gt;length
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
(brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
singleline_comment|// FIRMWARE:  bulk sink (maybe accepts short writes)
id|retval
op_assign
id|simple_io
(paren
id|urb
comma
id|param-&gt;iterations
comma
id|param-&gt;vary
)paren
suffix:semicolon
id|simple_free_urb
(paren
id|urb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;in_pipe
op_eq
l_int|0
op_logical_or
id|param-&gt;vary
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s TEST 3:  read/%d 0..%d bytes %u times&quot;
comma
id|dev-&gt;id
comma
id|param-&gt;vary
comma
id|param-&gt;length
comma
id|param-&gt;iterations
)paren
suffix:semicolon
id|urb
op_assign
id|simple_alloc_urb
(paren
id|udev
comma
id|dev-&gt;out_pipe
comma
id|param-&gt;length
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
(brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
singleline_comment|// FIRMWARE:  bulk source (maybe generates short writes)
id|retval
op_assign
id|simple_io
(paren
id|urb
comma
id|param-&gt;iterations
comma
id|param-&gt;vary
)paren
suffix:semicolon
id|simple_free_urb
(paren
id|urb
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Queued bulk I/O tests */
r_case
l_int|5
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;out_pipe
op_eq
l_int|0
op_logical_or
id|param-&gt;sglen
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s TEST 5:  write %d sglists, %d entries of %d bytes&quot;
comma
id|dev-&gt;id
comma
id|param-&gt;iterations
comma
id|param-&gt;sglen
comma
id|param-&gt;length
)paren
suffix:semicolon
id|sg
op_assign
id|alloc_sglist
(paren
id|param-&gt;sglen
comma
id|param-&gt;length
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sg
)paren
(brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
singleline_comment|// FIRMWARE:  bulk sink (maybe accepts short writes)
id|retval
op_assign
id|perform_sglist
(paren
id|udev
comma
id|param-&gt;iterations
comma
id|dev-&gt;out_pipe
comma
op_amp
id|req
comma
id|sg
comma
id|param-&gt;sglen
)paren
suffix:semicolon
id|free_sglist
(paren
id|sg
comma
id|param-&gt;sglen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;in_pipe
op_eq
l_int|0
op_logical_or
id|param-&gt;sglen
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s TEST 6:  read %d sglists, %d entries of %d bytes&quot;
comma
id|dev-&gt;id
comma
id|param-&gt;iterations
comma
id|param-&gt;sglen
comma
id|param-&gt;length
)paren
suffix:semicolon
id|sg
op_assign
id|alloc_sglist
(paren
id|param-&gt;sglen
comma
id|param-&gt;length
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sg
)paren
(brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
singleline_comment|// FIRMWARE:  bulk source (maybe generates short writes)
id|retval
op_assign
id|perform_sglist
(paren
id|udev
comma
id|param-&gt;iterations
comma
id|dev-&gt;in_pipe
comma
op_amp
id|req
comma
id|sg
comma
id|param-&gt;sglen
)paren
suffix:semicolon
id|free_sglist
(paren
id|sg
comma
id|param-&gt;sglen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;out_pipe
op_eq
l_int|0
op_logical_or
id|param-&gt;sglen
op_eq
l_int|0
op_logical_or
id|param-&gt;vary
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s TEST 7:  write/%d %d sglists, %d entries 0..%d bytes&quot;
comma
id|dev-&gt;id
comma
id|param-&gt;vary
comma
id|param-&gt;iterations
comma
id|param-&gt;sglen
comma
id|param-&gt;length
)paren
suffix:semicolon
id|sg
op_assign
id|alloc_sglist
(paren
id|param-&gt;sglen
comma
id|param-&gt;length
comma
id|param-&gt;vary
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sg
)paren
(brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
singleline_comment|// FIRMWARE:  bulk sink (maybe accepts short writes)
id|retval
op_assign
id|perform_sglist
(paren
id|udev
comma
id|param-&gt;iterations
comma
id|dev-&gt;out_pipe
comma
op_amp
id|req
comma
id|sg
comma
id|param-&gt;sglen
)paren
suffix:semicolon
id|free_sglist
(paren
id|sg
comma
id|param-&gt;sglen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;in_pipe
op_eq
l_int|0
op_logical_or
id|param-&gt;sglen
op_eq
l_int|0
op_logical_or
id|param-&gt;vary
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s TEST 8:  read/%d %d sglists, %d entries 0..%d bytes&quot;
comma
id|dev-&gt;id
comma
id|param-&gt;vary
comma
id|param-&gt;iterations
comma
id|param-&gt;sglen
comma
id|param-&gt;length
)paren
suffix:semicolon
id|sg
op_assign
id|alloc_sglist
(paren
id|param-&gt;sglen
comma
id|param-&gt;length
comma
id|param-&gt;vary
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sg
)paren
(brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
singleline_comment|// FIRMWARE:  bulk source (maybe generates short writes)
id|retval
op_assign
id|perform_sglist
(paren
id|udev
comma
id|param-&gt;iterations
comma
id|dev-&gt;in_pipe
comma
op_amp
id|req
comma
id|sg
comma
id|param-&gt;sglen
)paren
suffix:semicolon
id|free_sglist
(paren
id|sg
comma
id|param-&gt;sglen
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* test cases for the unlink/cancel codepaths need a thread to&n;&t; * usb_unlink_urb() or usg_sg_cancel(), and a way to check if&n;&t; * the urb/sg_request was properly canceled.&n;&t; *&n;&t; * for the unlink-queued cases, the usb_sg_*() code uses/tests&n;&t; * the &quot;streamed&quot; cleanup mode, not the &quot;packet&quot; one&n;&t; */
)brace
id|do_gettimeofday
(paren
op_amp
id|param-&gt;duration
)paren
suffix:semicolon
id|param-&gt;duration.tv_sec
op_sub_assign
id|start.tv_sec
suffix:semicolon
id|param-&gt;duration.tv_usec
op_sub_assign
id|start.tv_usec
suffix:semicolon
r_if
c_cond
(paren
id|param-&gt;duration.tv_usec
OL
l_int|0
)paren
(brace
id|param-&gt;duration.tv_usec
op_add_assign
l_int|1000
op_star
l_int|1000
suffix:semicolon
id|param-&gt;duration.tv_sec
op_sub_assign
l_int|1
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* most programmable USB devices can be given firmware that will support the&n; * test cases above.  one basic question is which endpoints to use for&n; * testing; endpoint numbers are not always firmware-selectable.&n; *&n; * for now, the driver_info in the device_id table entry just encodes the&n; * endpoint info for a pair of bulk-capable endpoints, which we can use&n; * for some interrupt transfer tests too.  later this could get fancier.&n; */
DECL|macro|EP_PAIR
mdefine_line|#define EP_PAIR(in,out) (((in)&lt;&lt;4)|(out))
DECL|variable|force_interrupt
r_static
r_int
id|force_interrupt
op_assign
l_int|0
suffix:semicolon
id|MODULE_PARM
(paren
id|force_interrupt
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
(paren
id|force_interrupt
comma
l_string|&quot;0 = test bulk (default), else interrupt&quot;
)paren
suffix:semicolon
r_static
r_int
DECL|function|usbtest_probe
id|usbtest_probe
(paren
r_struct
id|usb_interface
op_star
id|intf
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
(brace
r_struct
id|usb_device
op_star
id|udev
suffix:semicolon
r_struct
id|usbtest_dev
op_star
id|dev
suffix:semicolon
r_int
r_int
id|driver_info
op_assign
id|id-&gt;driver_info
suffix:semicolon
id|udev
op_assign
id|interface_to_usbdev
(paren
id|intf
)paren
suffix:semicolon
id|dev
op_assign
id|kmalloc
(paren
r_sizeof
op_star
id|dev
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
(paren
id|dev
comma
l_int|0
comma
r_sizeof
op_star
id|dev
)paren
suffix:semicolon
id|snprintf
(paren
id|dev-&gt;id
comma
r_sizeof
id|dev-&gt;id
comma
l_string|&quot;%s-%s&quot;
comma
id|udev-&gt;bus-&gt;bus_name
comma
id|udev-&gt;devpath
)paren
suffix:semicolon
id|dev-&gt;intf
op_assign
id|intf
suffix:semicolon
multiline_comment|/* NOTE this doesn&squot;t yet test the handful of difference that are&n;&t; * visible with high speed devices:  bigger maxpacket (1K) and&n;&t; * &quot;high bandwidth&quot; modes (up to 3 packets/uframe).&n;&t; */
r_if
c_cond
(paren
id|force_interrupt
op_logical_or
id|udev-&gt;speed
op_eq
id|USB_SPEED_LOW
)paren
(brace
r_if
c_cond
(paren
id|driver_info
op_amp
l_int|0xf0
)paren
id|dev-&gt;in_pipe
op_assign
id|usb_rcvintpipe
(paren
id|udev
comma
(paren
id|driver_info
op_rshift
l_int|4
)paren
op_amp
l_int|0x0f
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver_info
op_amp
l_int|0x0f
)paren
id|dev-&gt;out_pipe
op_assign
id|usb_sndintpipe
(paren
id|udev
comma
id|driver_info
op_amp
l_int|0x0f
)paren
suffix:semicolon
macro_line|#if 1
singleline_comment|// FIXME disabling this until we finally get rid of
singleline_comment|// interrupt &quot;automagic&quot; resubmission
id|dbg
(paren
l_string|&quot;%s:  no interrupt transfers for now&quot;
comma
id|dev-&gt;id
)paren
suffix:semicolon
id|kfree
(paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
r_if
c_cond
(paren
id|driver_info
op_amp
l_int|0xf0
)paren
id|dev-&gt;in_pipe
op_assign
id|usb_rcvbulkpipe
(paren
id|udev
comma
(paren
id|driver_info
op_rshift
l_int|4
)paren
op_amp
l_int|0x0f
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver_info
op_amp
l_int|0x0f
)paren
id|dev-&gt;out_pipe
op_assign
id|usb_sndbulkpipe
(paren
id|udev
comma
id|driver_info
op_amp
l_int|0x0f
)paren
suffix:semicolon
)brace
id|dev_set_drvdata
(paren
op_amp
id|intf-&gt;dev
comma
id|dev
)paren
suffix:semicolon
id|info
(paren
l_string|&quot;bound to %s ...%s%s&quot;
comma
id|dev-&gt;id
comma
id|dev-&gt;out_pipe
ques
c_cond
l_string|&quot; writes&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|dev-&gt;in_pipe
ques
c_cond
l_string|&quot; reads&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usbtest_disconnect
r_static
r_void
id|usbtest_disconnect
(paren
r_struct
id|usb_interface
op_star
id|intf
)paren
(brace
r_struct
id|usbtest_dev
op_star
id|dev
op_assign
id|dev_get_drvdata
(paren
op_amp
id|intf-&gt;dev
)paren
suffix:semicolon
id|dev_set_drvdata
(paren
op_amp
id|intf-&gt;dev
comma
l_int|0
)paren
suffix:semicolon
id|info
(paren
l_string|&quot;unbound %s&quot;
comma
id|dev-&gt;id
)paren
suffix:semicolon
id|kfree
(paren
id|intf-&gt;private_data
)paren
suffix:semicolon
)brace
multiline_comment|/* Basic testing only needs a device that can source or sink bulk traffic.&n; */
DECL|variable|id_table
r_static
r_struct
id|usb_device_id
id|id_table
(braket
)braket
op_assign
(brace
multiline_comment|/* EZ-USB FX2 &quot;bulksrc&quot; or &quot;bulkloop&quot; firmware from Cypress&n;&t; * reads disabled on this one, my version has some problem there&n;&t; */
(brace
id|USB_DEVICE
(paren
l_int|0x0547
comma
l_int|0x1002
)paren
comma
dot
id|driver_info
op_assign
id|EP_PAIR
(paren
l_int|0
comma
l_int|2
)paren
comma
)brace
comma
macro_line|#if 1
singleline_comment|// this does not coexist with a real iBOT2 driver!
singleline_comment|// it makes a nice source of high speed bulk-in data
(brace
id|USB_DEVICE
(paren
l_int|0x0b62
comma
l_int|0x0059
)paren
comma
dot
id|driver_info
op_assign
id|EP_PAIR
(paren
l_int|2
comma
l_int|0
)paren
comma
)brace
comma
macro_line|#endif
multiline_comment|/* can that old &quot;usbstress-0.3&quot; firmware be used with this? */
(brace
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
(paren
id|usb
comma
id|id_table
)paren
suffix:semicolon
DECL|variable|usbtest_driver
r_static
r_struct
id|usb_driver
id|usbtest_driver
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|name
op_assign
l_string|&quot;usbtest&quot;
comma
dot
id|id_table
op_assign
id|id_table
comma
dot
id|probe
op_assign
id|usbtest_probe
comma
dot
id|ioctl
op_assign
id|usbtest_ioctl
comma
dot
id|disconnect
op_assign
id|usbtest_disconnect
comma
)brace
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|usbtest_init
r_static
r_int
id|__init
id|usbtest_init
(paren
r_void
)paren
(brace
r_return
id|usb_register
(paren
op_amp
id|usbtest_driver
)paren
suffix:semicolon
)brace
DECL|variable|usbtest_init
id|module_init
(paren
id|usbtest_init
)paren
suffix:semicolon
DECL|function|usbtest_exit
r_static
r_void
id|__exit
id|usbtest_exit
(paren
r_void
)paren
(brace
id|usb_deregister
(paren
op_amp
id|usbtest_driver
)paren
suffix:semicolon
)brace
DECL|variable|usbtest_exit
id|module_exit
(paren
id|usbtest_exit
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
(paren
l_string|&quot;USB HCD Testing Driver&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
