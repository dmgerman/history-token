macro_line|#include &lt;linux/config.h&gt;
macro_line|#if !defined (DEBUG) &amp;&amp; defined (CONFIG_USB_DEBUG)
DECL|macro|DEBUG
macro_line|#   define DEBUG
macro_line|#endif
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;asm/scatterlist.h&gt;
macro_line|#include &lt;linux/usb.h&gt;
multiline_comment|/*-------------------------------------------------------------------------*/
singleline_comment|// FIXME make these public somewhere; usbdevfs.h?
singleline_comment|//
DECL|struct|usbtest_param
r_struct
id|usbtest_param
(brace
singleline_comment|// inputs
DECL|member|test_num
r_int
id|test_num
suffix:semicolon
multiline_comment|/* 0..(TEST_CASES-1) */
DECL|member|iterations
r_int
id|iterations
suffix:semicolon
DECL|member|length
r_int
id|length
suffix:semicolon
DECL|member|vary
r_int
id|vary
suffix:semicolon
DECL|member|sglen
r_int
id|sglen
suffix:semicolon
singleline_comment|// outputs
DECL|member|duration
r_struct
id|timeval
id|duration
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|USBTEST_REQUEST
mdefine_line|#define USBTEST_REQUEST&t;_IOWR(&squot;U&squot;, 100, struct usbtest_param)
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|macro|GENERIC
mdefine_line|#define&t;GENERIC&t;&t;/* let probe() bind using module params */
multiline_comment|/* Some devices that can be used for testing will have &quot;real&quot; drivers.&n; * Entries for those need to be enabled here by hand, after disabling&n; * that &quot;real&quot; driver.&n; */
singleline_comment|//#define&t;IBOT2&t;&t;/* grab iBOT2 webcams */
singleline_comment|//#define&t;KEYSPAN_19Qi&t;/* grab un-renumerated serial adapter */
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|struct|usbtest_info
r_struct
id|usbtest_info
(brace
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|ep_in
id|u8
id|ep_in
suffix:semicolon
multiline_comment|/* bulk/intr source */
DECL|member|ep_out
id|u8
id|ep_out
suffix:semicolon
multiline_comment|/* bulk/intr sink */
DECL|member|autoconf
r_int
id|autoconf
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ctrl_out
r_int
id|ctrl_out
suffix:colon
l_int|1
suffix:semicolon
DECL|member|iso
r_int
id|iso
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* try iso in/out */
DECL|member|alt
r_int
id|alt
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* this is accessed only through usbfs ioctl calls.&n; * one ioctl to issue a test ... one lock per device.&n; * tests create other threads if they need them.&n; * urbs and buffers are allocated dynamically,&n; * and data generated deterministically.&n; */
DECL|struct|usbtest_dev
r_struct
id|usbtest_dev
(brace
DECL|member|intf
r_struct
id|usb_interface
op_star
id|intf
suffix:semicolon
DECL|member|info
r_struct
id|usbtest_info
op_star
id|info
suffix:semicolon
DECL|member|in_pipe
r_int
id|in_pipe
suffix:semicolon
DECL|member|out_pipe
r_int
id|out_pipe
suffix:semicolon
DECL|member|in_iso_pipe
r_int
id|in_iso_pipe
suffix:semicolon
DECL|member|out_iso_pipe
r_int
id|out_iso_pipe
suffix:semicolon
DECL|member|iso_in
DECL|member|iso_out
r_struct
id|usb_endpoint_descriptor
op_star
id|iso_in
comma
op_star
id|iso_out
suffix:semicolon
DECL|member|sem
r_struct
id|semaphore
id|sem
suffix:semicolon
DECL|macro|TBUF_SIZE
mdefine_line|#define TBUF_SIZE&t;256
DECL|member|buf
id|u8
op_star
id|buf
suffix:semicolon
)brace
suffix:semicolon
DECL|function|testdev_to_usbdev
r_static
r_struct
id|usb_device
op_star
id|testdev_to_usbdev
(paren
r_struct
id|usbtest_dev
op_star
id|test
)paren
(brace
r_return
id|interface_to_usbdev
(paren
id|test-&gt;intf
)paren
suffix:semicolon
)brace
multiline_comment|/* set up all urbs so they can be used with either bulk or interrupt */
DECL|macro|INTERRUPT_RATE
mdefine_line|#define&t;INTERRUPT_RATE&t;&t;1&t;/* msec/transfer */
DECL|macro|xprintk
mdefine_line|#define xprintk(tdev,level,fmt,args...) &bslash;&n;&t;dev_printk(level ,  &amp;(tdev)-&gt;intf-&gt;dev ,  fmt ,  ## args)
macro_line|#ifdef DEBUG
DECL|macro|DBG
mdefine_line|#define DBG(dev,fmt,args...) &bslash;&n;&t;xprintk(dev , KERN_DEBUG , fmt , ## args)
macro_line|#else
DECL|macro|DBG
mdefine_line|#define DBG(dev,fmt,args...) &bslash;&n;&t;do { } while (0)
macro_line|#endif /* DEBUG */
macro_line|#ifdef VERBOSE
DECL|macro|VDBG
mdefine_line|#define VDBG DBG
macro_line|#else
DECL|macro|VDBG
mdefine_line|#define VDBG(dev,fmt,args...) &bslash;&n;&t;do { } while (0)
macro_line|#endif&t;/* VERBOSE */
DECL|macro|ERROR
mdefine_line|#define ERROR(dev,fmt,args...) &bslash;&n;&t;xprintk(dev , KERN_ERR , fmt , ## args)
DECL|macro|WARN
mdefine_line|#define WARN(dev,fmt,args...) &bslash;&n;&t;xprintk(dev , KERN_WARNING , fmt , ## args)
DECL|macro|INFO
mdefine_line|#define INFO(dev,fmt,args...) &bslash;&n;&t;xprintk(dev , KERN_INFO , fmt , ## args)
multiline_comment|/*-------------------------------------------------------------------------*/
r_static
r_int
DECL|function|get_endpoints
id|get_endpoints
(paren
r_struct
id|usbtest_dev
op_star
id|dev
comma
r_struct
id|usb_interface
op_star
id|intf
)paren
(brace
r_int
id|tmp
suffix:semicolon
r_struct
id|usb_host_interface
op_star
id|alt
suffix:semicolon
r_struct
id|usb_host_endpoint
op_star
id|in
comma
op_star
id|out
suffix:semicolon
r_struct
id|usb_host_endpoint
op_star
id|iso_in
comma
op_star
id|iso_out
suffix:semicolon
r_struct
id|usb_device
op_star
id|udev
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
l_int|0
suffix:semicolon
id|tmp
OL
id|intf-&gt;num_altsetting
suffix:semicolon
id|tmp
op_increment
)paren
(brace
r_int
id|ep
suffix:semicolon
id|in
op_assign
id|out
op_assign
l_int|NULL
suffix:semicolon
id|iso_in
op_assign
id|iso_out
op_assign
l_int|NULL
suffix:semicolon
id|alt
op_assign
id|intf-&gt;altsetting
op_plus
id|tmp
suffix:semicolon
multiline_comment|/* take the first altsetting with in-bulk + out-bulk;&n;&t;&t; * ignore other endpoints and altsetttings.&n;&t;&t; */
r_for
c_loop
(paren
id|ep
op_assign
l_int|0
suffix:semicolon
id|ep
OL
id|alt-&gt;desc.bNumEndpoints
suffix:semicolon
id|ep
op_increment
)paren
(brace
r_struct
id|usb_host_endpoint
op_star
id|e
suffix:semicolon
id|e
op_assign
id|alt-&gt;endpoint
op_plus
id|ep
suffix:semicolon
r_switch
c_cond
(paren
id|e-&gt;desc.bmAttributes
)paren
(brace
r_case
id|USB_ENDPOINT_XFER_BULK
suffix:colon
r_break
suffix:semicolon
r_case
id|USB_ENDPOINT_XFER_ISOC
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;info-&gt;iso
)paren
r_goto
id|try_iso
suffix:semicolon
singleline_comment|// FALLTHROUGH
r_default
suffix:colon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e-&gt;desc.bEndpointAddress
op_amp
id|USB_DIR_IN
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|in
)paren
id|in
op_assign
id|e
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|out
)paren
id|out
op_assign
id|e
suffix:semicolon
)brace
r_continue
suffix:semicolon
id|try_iso
suffix:colon
r_if
c_cond
(paren
id|e-&gt;desc.bEndpointAddress
op_amp
id|USB_DIR_IN
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|iso_in
)paren
id|iso_in
op_assign
id|e
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|iso_out
)paren
id|iso_out
op_assign
id|e
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|in
op_logical_and
id|out
)paren
op_logical_or
(paren
id|iso_in
op_logical_and
id|iso_out
)paren
)paren
r_goto
id|found
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
id|found
suffix:colon
id|udev
op_assign
id|testdev_to_usbdev
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|alt-&gt;desc.bAlternateSetting
op_ne
l_int|0
)paren
(brace
id|tmp
op_assign
id|usb_set_interface
(paren
id|udev
comma
id|alt-&gt;desc.bInterfaceNumber
comma
id|alt-&gt;desc.bAlternateSetting
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
r_return
id|tmp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|in
)paren
(brace
id|dev-&gt;in_pipe
op_assign
id|usb_rcvbulkpipe
(paren
id|udev
comma
id|in-&gt;desc.bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
)paren
suffix:semicolon
id|dev-&gt;out_pipe
op_assign
id|usb_sndbulkpipe
(paren
id|udev
comma
id|out-&gt;desc.bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|iso_in
)paren
(brace
id|dev-&gt;iso_in
op_assign
op_amp
id|iso_in-&gt;desc
suffix:semicolon
id|dev-&gt;in_iso_pipe
op_assign
id|usb_rcvisocpipe
(paren
id|udev
comma
id|iso_in-&gt;desc.bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
)paren
suffix:semicolon
id|dev-&gt;iso_out
op_assign
op_amp
id|iso_out-&gt;desc
suffix:semicolon
id|dev-&gt;out_iso_pipe
op_assign
id|usb_sndisocpipe
(paren
id|udev
comma
id|iso_out-&gt;desc.bEndpointAddress
op_amp
id|USB_ENDPOINT_NUMBER_MASK
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* Support for testing basic non-queued I/O streams.&n; *&n; * These just package urbs as requests that can be easily canceled.&n; * Each urb&squot;s data buffer is dynamically allocated; callers can fill&n; * them with non-zero test data (or test for it) when appropriate.&n; */
DECL|function|simple_callback
r_static
r_void
id|simple_callback
(paren
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|complete
(paren
(paren
r_struct
id|completion
op_star
)paren
id|urb-&gt;context
)paren
suffix:semicolon
)brace
DECL|function|simple_alloc_urb
r_static
r_struct
id|urb
op_star
id|simple_alloc_urb
(paren
r_struct
id|usb_device
op_star
id|udev
comma
r_int
id|pipe
comma
r_int
r_int
id|bytes
)paren
(brace
r_struct
id|urb
op_star
id|urb
suffix:semicolon
r_if
c_cond
(paren
id|bytes
OL
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
id|urb
op_assign
id|usb_alloc_urb
(paren
l_int|0
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
r_return
id|urb
suffix:semicolon
id|usb_fill_bulk_urb
(paren
id|urb
comma
id|udev
comma
id|pipe
comma
l_int|NULL
comma
id|bytes
comma
id|simple_callback
comma
l_int|NULL
)paren
suffix:semicolon
id|urb-&gt;interval
op_assign
(paren
id|udev-&gt;speed
op_eq
id|USB_SPEED_HIGH
)paren
ques
c_cond
(paren
id|INTERRUPT_RATE
op_lshift
l_int|3
)paren
suffix:colon
id|INTERRUPT_RATE
suffix:semicolon
id|urb-&gt;transfer_flags
op_assign
id|URB_NO_TRANSFER_DMA_MAP
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipein
(paren
id|pipe
)paren
)paren
id|urb-&gt;transfer_flags
op_or_assign
id|URB_SHORT_NOT_OK
suffix:semicolon
id|urb-&gt;transfer_buffer
op_assign
id|usb_buffer_alloc
(paren
id|udev
comma
id|bytes
comma
id|SLAB_KERNEL
comma
op_amp
id|urb-&gt;transfer_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb-&gt;transfer_buffer
)paren
(brace
id|usb_free_urb
(paren
id|urb
)paren
suffix:semicolon
id|urb
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
id|memset
(paren
id|urb-&gt;transfer_buffer
comma
l_int|0
comma
id|bytes
)paren
suffix:semicolon
r_return
id|urb
suffix:semicolon
)brace
DECL|variable|pattern
r_static
r_int
id|pattern
op_assign
l_int|0
suffix:semicolon
id|module_param
(paren
id|pattern
comma
id|uint
comma
id|S_IRUGO
)paren
suffix:semicolon
singleline_comment|// MODULE_PARM_DESC (pattern, &quot;i/o pattern (0 == zeroes)&quot;);
DECL|function|simple_fill_buf
r_static
r_inline
r_void
id|simple_fill_buf
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
id|i
suffix:semicolon
id|u8
op_star
id|buf
op_assign
id|urb-&gt;transfer_buffer
suffix:semicolon
r_int
id|len
op_assign
id|urb-&gt;transfer_buffer_length
suffix:semicolon
r_switch
c_cond
(paren
id|pattern
)paren
(brace
r_default
suffix:colon
singleline_comment|// FALLTHROUGH
r_case
l_int|0
suffix:colon
id|memset
(paren
id|buf
comma
l_int|0
comma
id|len
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* mod63 */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
op_star
id|buf
op_increment
op_assign
(paren
id|u8
)paren
(paren
id|i
op_mod
l_int|63
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|simple_check_buf
r_static
r_inline
r_int
id|simple_check_buf
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
id|i
suffix:semicolon
id|u8
id|expected
suffix:semicolon
id|u8
op_star
id|buf
op_assign
id|urb-&gt;transfer_buffer
suffix:semicolon
r_int
id|len
op_assign
id|urb-&gt;actual_length
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
comma
id|buf
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|pattern
)paren
(brace
multiline_comment|/* all-zeroes has no synchronization issues */
r_case
l_int|0
suffix:colon
id|expected
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* mod63 stays in sync with short-terminated transfers,&n;&t;&t; * or otherwise when host and gadget agree on how large&n;&t;&t; * each usb transfer request should be.  resync is done&n;&t;&t; * with set_interface or set_config.&n;&t;&t; */
r_case
l_int|1
suffix:colon
multiline_comment|/* mod63 */
id|expected
op_assign
id|i
op_mod
l_int|63
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* always fail unsupported patterns */
r_default
suffix:colon
id|expected
op_assign
op_logical_neg
op_star
id|buf
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|buf
op_eq
id|expected
)paren
r_continue
suffix:semicolon
id|dbg
(paren
l_string|&quot;buf[%d] = %d (not %d)&quot;
comma
id|i
comma
op_star
id|buf
comma
id|expected
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|simple_free_urb
r_static
r_void
id|simple_free_urb
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
id|usb_buffer_free
(paren
id|urb-&gt;dev
comma
id|urb-&gt;transfer_buffer_length
comma
id|urb-&gt;transfer_buffer
comma
id|urb-&gt;transfer_dma
)paren
suffix:semicolon
id|usb_free_urb
(paren
id|urb
)paren
suffix:semicolon
)brace
DECL|function|simple_io
r_static
r_int
id|simple_io
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|iterations
comma
r_int
id|vary
comma
r_int
id|expected
comma
r_const
r_char
op_star
id|label
)paren
(brace
r_struct
id|usb_device
op_star
id|udev
op_assign
id|urb-&gt;dev
suffix:semicolon
r_int
id|max
op_assign
id|urb-&gt;transfer_buffer_length
suffix:semicolon
r_struct
id|completion
id|completion
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
id|urb-&gt;context
op_assign
op_amp
id|completion
suffix:semicolon
r_while
c_loop
(paren
id|retval
op_eq
l_int|0
op_logical_and
id|iterations
op_decrement
OG
l_int|0
)paren
(brace
id|init_completion
(paren
op_amp
id|completion
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipeout
(paren
id|urb-&gt;pipe
)paren
)paren
id|simple_fill_buf
(paren
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|usb_submit_urb
(paren
id|urb
comma
id|SLAB_KERNEL
)paren
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* NOTE:  no timeouts; can&squot;t be broken out of by interrupt */
id|wait_for_completion
(paren
op_amp
id|completion
)paren
suffix:semicolon
id|retval
op_assign
id|urb-&gt;status
suffix:semicolon
id|urb-&gt;dev
op_assign
id|udev
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
l_int|0
op_logical_and
id|usb_pipein
(paren
id|urb-&gt;pipe
)paren
)paren
id|retval
op_assign
id|simple_check_buf
(paren
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vary
)paren
(brace
r_int
id|len
op_assign
id|urb-&gt;transfer_buffer_length
suffix:semicolon
id|len
op_add_assign
id|vary
suffix:semicolon
id|len
op_mod_assign
id|max
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
id|len
op_assign
(paren
id|vary
OL
id|max
)paren
ques
c_cond
id|vary
suffix:colon
id|max
suffix:semicolon
id|urb-&gt;transfer_buffer_length
op_assign
id|len
suffix:semicolon
)brace
multiline_comment|/* FIXME if endpoint halted, clear halt (and log) */
)brace
id|urb-&gt;transfer_buffer_length
op_assign
id|max
suffix:semicolon
r_if
c_cond
(paren
id|expected
op_ne
id|retval
)paren
id|dev_dbg
(paren
op_amp
id|udev-&gt;dev
comma
l_string|&quot;%s failed, iterations left %d, status %d (not %d)&bslash;n&quot;
comma
id|label
comma
id|iterations
comma
id|retval
comma
id|expected
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* We use scatterlist primitives to test queued I/O.&n; * Yes, this also tests the scatterlist primitives.&n; */
DECL|function|free_sglist
r_static
r_void
id|free_sglist
(paren
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sg
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nents
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sg
(braket
id|i
)braket
dot
id|page
)paren
r_continue
suffix:semicolon
id|kfree
(paren
id|page_address
(paren
id|sg
(braket
id|i
)braket
dot
id|page
)paren
op_plus
id|sg
(braket
id|i
)braket
dot
id|offset
)paren
suffix:semicolon
)brace
id|kfree
(paren
id|sg
)paren
suffix:semicolon
)brace
r_static
r_struct
id|scatterlist
op_star
DECL|function|alloc_sglist
id|alloc_sglist
(paren
r_int
id|nents
comma
r_int
id|max
comma
r_int
id|vary
)paren
(brace
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|size
op_assign
id|max
suffix:semicolon
id|sg
op_assign
id|kmalloc
(paren
id|nents
op_star
r_sizeof
op_star
id|sg
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sg
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
(paren
id|sg
comma
l_int|0
comma
id|nents
op_star
r_sizeof
op_star
id|sg
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nents
suffix:semicolon
id|i
op_increment
)paren
(brace
r_char
op_star
id|buf
suffix:semicolon
id|buf
op_assign
id|kmalloc
(paren
id|size
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
(brace
id|free_sglist
(paren
id|sg
comma
id|i
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
(paren
id|buf
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* kmalloc pages are always physically contiguous! */
id|sg
(braket
id|i
)braket
dot
id|page
op_assign
id|virt_to_page
(paren
id|buf
)paren
suffix:semicolon
id|sg
(braket
id|i
)braket
dot
id|offset
op_assign
id|offset_in_page
(paren
id|buf
)paren
suffix:semicolon
id|sg
(braket
id|i
)braket
dot
id|length
op_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|vary
)paren
(brace
id|size
op_add_assign
id|vary
suffix:semicolon
id|size
op_mod_assign
id|max
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
id|size
op_assign
(paren
id|vary
OL
id|max
)paren
ques
c_cond
id|vary
suffix:colon
id|max
suffix:semicolon
)brace
)brace
r_return
id|sg
suffix:semicolon
)brace
DECL|function|perform_sglist
r_static
r_int
id|perform_sglist
(paren
r_struct
id|usb_device
op_star
id|udev
comma
r_int
id|iterations
comma
r_int
id|pipe
comma
r_struct
id|usb_sg_request
op_star
id|req
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|retval
op_eq
l_int|0
op_logical_and
id|iterations
op_decrement
OG
l_int|0
)paren
(brace
id|retval
op_assign
id|usb_sg_init
(paren
id|req
comma
id|udev
comma
id|pipe
comma
(paren
id|udev-&gt;speed
op_eq
id|USB_SPEED_HIGH
)paren
ques
c_cond
(paren
id|INTERRUPT_RATE
op_lshift
l_int|3
)paren
suffix:colon
id|INTERRUPT_RATE
comma
id|sg
comma
id|nents
comma
l_int|0
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_break
suffix:semicolon
id|usb_sg_wait
(paren
id|req
)paren
suffix:semicolon
id|retval
op_assign
id|req-&gt;status
suffix:semicolon
multiline_comment|/* FIXME if endpoint halted, clear halt (and log) */
)brace
singleline_comment|// FIXME for unlink or fault handling tests, don&squot;t report
singleline_comment|// failure if retval is as we expected ...
r_if
c_cond
(paren
id|retval
)paren
id|dbg
(paren
l_string|&quot;perform_sglist failed, iterations left %d, status %d&quot;
comma
id|iterations
comma
id|retval
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* unqueued control message testing&n; *&n; * there&squot;s a nice set of device functional requirements in chapter 9 of the&n; * usb 2.0 spec, which we can apply to ANY device, even ones that don&squot;t use&n; * special test firmware.&n; *&n; * we know the device is configured (or suspended) by the time it&squot;s visible&n; * through usbfs.  we can&squot;t change that, so we won&squot;t test enumeration (which&n; * worked &squot;well enough&squot; to get here, this time), power management (ditto),&n; * or remote wakeup (which needs human interaction).&n; */
DECL|variable|realworld
r_static
r_int
id|realworld
op_assign
l_int|1
suffix:semicolon
id|module_param
(paren
id|realworld
comma
id|uint
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
(paren
id|realworld
comma
l_string|&quot;clear to demand stricter ch9 compliance&quot;
)paren
suffix:semicolon
DECL|function|get_altsetting
r_static
r_int
id|get_altsetting
(paren
r_struct
id|usbtest_dev
op_star
id|dev
)paren
(brace
r_struct
id|usb_interface
op_star
id|iface
op_assign
id|dev-&gt;intf
suffix:semicolon
r_struct
id|usb_device
op_star
id|udev
op_assign
id|interface_to_usbdev
(paren
id|iface
)paren
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|retval
op_assign
id|usb_control_msg
(paren
id|udev
comma
id|usb_rcvctrlpipe
(paren
id|udev
comma
l_int|0
)paren
comma
id|USB_REQ_GET_INTERFACE
comma
id|USB_DIR_IN
op_or
id|USB_RECIP_INTERFACE
comma
l_int|0
comma
id|iface-&gt;altsetting
(braket
l_int|0
)braket
dot
id|desc.bInterfaceNumber
comma
id|dev-&gt;buf
comma
l_int|1
comma
id|USB_CTRL_GET_TIMEOUT
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|retval
)paren
(brace
r_case
l_int|1
suffix:colon
r_return
id|dev-&gt;buf
(braket
l_int|0
)braket
suffix:semicolon
r_case
l_int|0
suffix:colon
id|retval
op_assign
op_minus
id|ERANGE
suffix:semicolon
singleline_comment|// FALLTHROUGH
r_default
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
)brace
DECL|function|set_altsetting
r_static
r_int
id|set_altsetting
(paren
r_struct
id|usbtest_dev
op_star
id|dev
comma
r_int
id|alternate
)paren
(brace
r_struct
id|usb_interface
op_star
id|iface
op_assign
id|dev-&gt;intf
suffix:semicolon
r_struct
id|usb_device
op_star
id|udev
suffix:semicolon
r_if
c_cond
(paren
id|alternate
OL
l_int|0
op_logical_or
id|alternate
op_ge
l_int|256
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|udev
op_assign
id|interface_to_usbdev
(paren
id|iface
)paren
suffix:semicolon
r_return
id|usb_set_interface
(paren
id|udev
comma
id|iface-&gt;altsetting
(braket
l_int|0
)braket
dot
id|desc.bInterfaceNumber
comma
id|alternate
)paren
suffix:semicolon
)brace
DECL|function|is_good_config
r_static
r_int
id|is_good_config
(paren
r_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_struct
id|usb_config_descriptor
op_star
id|config
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
r_sizeof
op_star
id|config
)paren
r_return
l_int|0
suffix:semicolon
id|config
op_assign
(paren
r_struct
id|usb_config_descriptor
op_star
)paren
id|buf
suffix:semicolon
r_switch
c_cond
(paren
id|config-&gt;bDescriptorType
)paren
(brace
r_case
id|USB_DT_CONFIG
suffix:colon
r_case
id|USB_DT_OTHER_SPEED_CONFIG
suffix:colon
r_if
c_cond
(paren
id|config-&gt;bLength
op_ne
l_int|9
)paren
(brace
id|dbg
(paren
l_string|&quot;bogus config descriptor length&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* this bit &squot;must be 1&squot; but often isn&squot;t */
r_if
c_cond
(paren
op_logical_neg
id|realworld
op_logical_and
op_logical_neg
(paren
id|config-&gt;bmAttributes
op_amp
l_int|0x80
)paren
)paren
(brace
id|dbg
(paren
l_string|&quot;high bit of config attributes not set&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|config-&gt;bmAttributes
op_amp
l_int|0x1f
)paren
(brace
multiline_comment|/* reserved == 0 */
id|dbg
(paren
l_string|&quot;reserved config bits set&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|le16_to_cpu
c_func
(paren
id|config-&gt;wTotalLength
)paren
op_eq
id|len
)paren
multiline_comment|/* read it all */
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|le16_to_cpu
c_func
(paren
id|config-&gt;wTotalLength
)paren
op_ge
id|TBUF_SIZE
)paren
multiline_comment|/* max partial read */
r_return
l_int|1
suffix:semicolon
id|dbg
(paren
l_string|&quot;bogus config descriptor read size&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* sanity test for standard requests working with usb_control_mesg() and some&n; * of the utility functions which use it.&n; *&n; * this doesn&squot;t test how endpoint halts behave or data toggles get set, since&n; * we won&squot;t do I/O to bulk/interrupt endpoints here (which is how to change&n; * halt or toggle).  toggle testing is impractical without support from hcds.&n; *&n; * this avoids failing devices linux would normally work with, by not testing&n; * config/altsetting operations for devices that only support their defaults.&n; * such devices rarely support those needless operations.&n; *&n; * NOTE that since this is a sanity test, it&squot;s not examining boundary cases&n; * to see if usbcore, hcd, and device all behave right.  such testing would&n; * involve varied read sizes and other operation sequences.&n; */
DECL|function|ch9_postconfig
r_static
r_int
id|ch9_postconfig
(paren
r_struct
id|usbtest_dev
op_star
id|dev
)paren
(brace
r_struct
id|usb_interface
op_star
id|iface
op_assign
id|dev-&gt;intf
suffix:semicolon
r_struct
id|usb_device
op_star
id|udev
op_assign
id|interface_to_usbdev
(paren
id|iface
)paren
suffix:semicolon
r_int
id|i
comma
id|alt
comma
id|retval
suffix:semicolon
multiline_comment|/* [9.2.3] if there&squot;s more than one altsetting, we need to be able to&n;&t; * set and get each one.  mostly trusts the descriptors from usbcore.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|iface-&gt;num_altsetting
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* 9.2.3 constrains the range here */
id|alt
op_assign
id|iface-&gt;altsetting
(braket
id|i
)braket
dot
id|desc.bAlternateSetting
suffix:semicolon
r_if
c_cond
(paren
id|alt
OL
l_int|0
op_logical_or
id|alt
op_ge
id|iface-&gt;num_altsetting
)paren
(brace
id|dev_dbg
(paren
op_amp
id|iface-&gt;dev
comma
l_string|&quot;invalid alt [%d].bAltSetting = %d&bslash;n&quot;
comma
id|i
comma
id|alt
)paren
suffix:semicolon
)brace
multiline_comment|/* [real world] get/set unimplemented if there&squot;s only one */
r_if
c_cond
(paren
id|realworld
op_logical_and
id|iface-&gt;num_altsetting
op_eq
l_int|1
)paren
r_continue
suffix:semicolon
multiline_comment|/* [9.4.10] set_interface */
id|retval
op_assign
id|set_altsetting
(paren
id|dev
comma
id|alt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|dev_dbg
(paren
op_amp
id|iface-&gt;dev
comma
l_string|&quot;can&squot;t set_interface = %d, %d&bslash;n&quot;
comma
id|alt
comma
id|retval
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* [9.4.4] get_interface always works */
id|retval
op_assign
id|get_altsetting
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
id|alt
)paren
(brace
id|dev_dbg
(paren
op_amp
id|iface-&gt;dev
comma
l_string|&quot;get alt should be %d, was %d&bslash;n&quot;
comma
id|alt
comma
id|retval
)paren
suffix:semicolon
r_return
(paren
id|retval
OL
l_int|0
)paren
ques
c_cond
id|retval
suffix:colon
op_minus
id|EDOM
suffix:semicolon
)brace
)brace
multiline_comment|/* [real world] get_config unimplemented if there&squot;s only one */
r_if
c_cond
(paren
op_logical_neg
id|realworld
op_logical_or
id|udev-&gt;descriptor.bNumConfigurations
op_ne
l_int|1
)paren
(brace
r_int
id|expected
op_assign
id|udev-&gt;actconfig-&gt;desc.bConfigurationValue
suffix:semicolon
multiline_comment|/* [9.4.2] get_configuration always works&n;&t;&t; * ... although some cheap devices (like one TI Hub I&squot;ve got)&n;&t;&t; * won&squot;t return config descriptors except before set_config.&n;&t;&t; */
id|retval
op_assign
id|usb_control_msg
(paren
id|udev
comma
id|usb_rcvctrlpipe
(paren
id|udev
comma
l_int|0
)paren
comma
id|USB_REQ_GET_CONFIGURATION
comma
id|USB_DIR_IN
op_or
id|USB_RECIP_DEVICE
comma
l_int|0
comma
l_int|0
comma
id|dev-&gt;buf
comma
l_int|1
comma
id|USB_CTRL_GET_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
l_int|1
op_logical_or
id|dev-&gt;buf
(braket
l_int|0
)braket
op_ne
id|expected
)paren
(brace
id|dev_dbg
(paren
op_amp
id|iface-&gt;dev
comma
l_string|&quot;get config --&gt; %d (%d)&bslash;n&quot;
comma
id|retval
comma
id|expected
)paren
suffix:semicolon
r_return
(paren
id|retval
OL
l_int|0
)paren
ques
c_cond
id|retval
suffix:colon
op_minus
id|EDOM
suffix:semicolon
)brace
)brace
multiline_comment|/* there&squot;s always [9.4.3] a device descriptor [9.6.1] */
id|retval
op_assign
id|usb_get_descriptor
(paren
id|udev
comma
id|USB_DT_DEVICE
comma
l_int|0
comma
id|dev-&gt;buf
comma
r_sizeof
id|udev-&gt;descriptor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
r_sizeof
id|udev-&gt;descriptor
)paren
(brace
id|dev_dbg
(paren
op_amp
id|iface-&gt;dev
comma
l_string|&quot;dev descriptor --&gt; %d&bslash;n&quot;
comma
id|retval
)paren
suffix:semicolon
r_return
(paren
id|retval
OL
l_int|0
)paren
ques
c_cond
id|retval
suffix:colon
op_minus
id|EDOM
suffix:semicolon
)brace
multiline_comment|/* there&squot;s always [9.4.3] at least one config descriptor [9.6.3] */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|udev-&gt;descriptor.bNumConfigurations
suffix:semicolon
id|i
op_increment
)paren
(brace
id|retval
op_assign
id|usb_get_descriptor
(paren
id|udev
comma
id|USB_DT_CONFIG
comma
id|i
comma
id|dev-&gt;buf
comma
id|TBUF_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_good_config
(paren
id|dev-&gt;buf
comma
id|retval
)paren
)paren
(brace
id|dev_dbg
(paren
op_amp
id|iface-&gt;dev
comma
l_string|&quot;config [%d] descriptor --&gt; %d&bslash;n&quot;
comma
id|i
comma
id|retval
)paren
suffix:semicolon
r_return
(paren
id|retval
OL
l_int|0
)paren
ques
c_cond
id|retval
suffix:colon
op_minus
id|EDOM
suffix:semicolon
)brace
singleline_comment|// FIXME cross-checking udev-&gt;config[i] to make sure usbcore
singleline_comment|// parsed it right (etc) would be good testing paranoia
)brace
multiline_comment|/* and sometimes [9.2.6.6] speed dependent descriptors */
r_if
c_cond
(paren
id|le16_to_cpu
c_func
(paren
id|udev-&gt;descriptor.bcdUSB
)paren
op_eq
l_int|0x0200
)paren
(brace
r_struct
id|usb_qualifier_descriptor
op_star
id|d
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* device qualifier [9.6.2] */
id|retval
op_assign
id|usb_get_descriptor
(paren
id|udev
comma
id|USB_DT_DEVICE_QUALIFIER
comma
l_int|0
comma
id|dev-&gt;buf
comma
r_sizeof
(paren
r_struct
id|usb_qualifier_descriptor
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
op_minus
id|EPIPE
)paren
(brace
r_if
c_cond
(paren
id|udev-&gt;speed
op_eq
id|USB_SPEED_HIGH
)paren
(brace
id|dev_dbg
(paren
op_amp
id|iface-&gt;dev
comma
l_string|&quot;hs dev qualifier --&gt; %d&bslash;n&quot;
comma
id|retval
)paren
suffix:semicolon
r_return
(paren
id|retval
OL
l_int|0
)paren
ques
c_cond
id|retval
suffix:colon
op_minus
id|EDOM
suffix:semicolon
)brace
multiline_comment|/* usb2.0 but not high-speed capable; fine */
)brace
r_else
r_if
c_cond
(paren
id|retval
op_ne
r_sizeof
(paren
r_struct
id|usb_qualifier_descriptor
)paren
)paren
(brace
id|dev_dbg
(paren
op_amp
id|iface-&gt;dev
comma
l_string|&quot;dev qualifier --&gt; %d&bslash;n&quot;
comma
id|retval
)paren
suffix:semicolon
r_return
(paren
id|retval
OL
l_int|0
)paren
ques
c_cond
id|retval
suffix:colon
op_minus
id|EDOM
suffix:semicolon
)brace
r_else
id|d
op_assign
(paren
r_struct
id|usb_qualifier_descriptor
op_star
)paren
id|dev-&gt;buf
suffix:semicolon
multiline_comment|/* might not have [9.6.2] any other-speed configs [9.6.4] */
r_if
c_cond
(paren
id|d
)paren
(brace
r_int
id|max
op_assign
id|d-&gt;bNumConfigurations
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max
suffix:semicolon
id|i
op_increment
)paren
(brace
id|retval
op_assign
id|usb_get_descriptor
(paren
id|udev
comma
id|USB_DT_OTHER_SPEED_CONFIG
comma
id|i
comma
id|dev-&gt;buf
comma
id|TBUF_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_good_config
(paren
id|dev-&gt;buf
comma
id|retval
)paren
)paren
(brace
id|dev_dbg
(paren
op_amp
id|iface-&gt;dev
comma
l_string|&quot;other speed config --&gt; %d&bslash;n&quot;
comma
id|retval
)paren
suffix:semicolon
r_return
(paren
id|retval
OL
l_int|0
)paren
ques
c_cond
id|retval
suffix:colon
op_minus
id|EDOM
suffix:semicolon
)brace
)brace
)brace
)brace
singleline_comment|// FIXME fetch strings from at least the device descriptor
multiline_comment|/* [9.4.5] get_status always works */
id|retval
op_assign
id|usb_get_status
(paren
id|udev
comma
id|USB_RECIP_DEVICE
comma
l_int|0
comma
id|dev-&gt;buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
l_int|2
)paren
(brace
id|dev_dbg
(paren
op_amp
id|iface-&gt;dev
comma
l_string|&quot;get dev status --&gt; %d&bslash;n&quot;
comma
id|retval
)paren
suffix:semicolon
r_return
(paren
id|retval
OL
l_int|0
)paren
ques
c_cond
id|retval
suffix:colon
op_minus
id|EDOM
suffix:semicolon
)brace
singleline_comment|// FIXME configuration.bmAttributes says if we could try to set/clear
singleline_comment|// the device&squot;s remote wakeup feature ... if we can, test that here
id|retval
op_assign
id|usb_get_status
(paren
id|udev
comma
id|USB_RECIP_INTERFACE
comma
id|iface-&gt;altsetting
(braket
l_int|0
)braket
dot
id|desc.bInterfaceNumber
comma
id|dev-&gt;buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
l_int|2
)paren
(brace
id|dev_dbg
(paren
op_amp
id|iface-&gt;dev
comma
l_string|&quot;get interface status --&gt; %d&bslash;n&quot;
comma
id|retval
)paren
suffix:semicolon
r_return
(paren
id|retval
OL
l_int|0
)paren
ques
c_cond
id|retval
suffix:colon
op_minus
id|EDOM
suffix:semicolon
)brace
singleline_comment|// FIXME get status for each endpoint in the interface
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* use ch9 requests to test whether:&n; *   (a) queues work for control, keeping N subtests queued and&n; *       active (auto-resubmit) for M loops through the queue.&n; *   (b) protocol stalls (control-only) will autorecover.&n; *       it&squot;s not like bulk/intr; no halt clearing.&n; *   (c) short control reads are reported and handled.&n; *   (d) queues are always processed in-order&n; */
DECL|struct|ctrl_ctx
r_struct
id|ctrl_ctx
(brace
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|dev
r_struct
id|usbtest_dev
op_star
id|dev
suffix:semicolon
DECL|member|complete
r_struct
id|completion
id|complete
suffix:semicolon
DECL|member|count
r_int
id|count
suffix:semicolon
DECL|member|pending
r_int
id|pending
suffix:semicolon
DECL|member|status
r_int
id|status
suffix:semicolon
DECL|member|urb
r_struct
id|urb
op_star
op_star
id|urb
suffix:semicolon
DECL|member|param
r_struct
id|usbtest_param
op_star
id|param
suffix:semicolon
DECL|member|last
r_int
id|last
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|NUM_SUBCASES
mdefine_line|#define NUM_SUBCASES&t;15&t;&t;/* how many test subcases here? */
DECL|struct|subcase
r_struct
id|subcase
(brace
DECL|member|setup
r_struct
id|usb_ctrlrequest
id|setup
suffix:semicolon
DECL|member|number
r_int
id|number
suffix:semicolon
DECL|member|expected
r_int
id|expected
suffix:semicolon
)brace
suffix:semicolon
DECL|function|ctrl_complete
r_static
r_void
id|ctrl_complete
(paren
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|ctrl_ctx
op_star
id|ctx
op_assign
id|urb-&gt;context
suffix:semicolon
r_struct
id|usb_ctrlrequest
op_star
id|reqp
suffix:semicolon
r_struct
id|subcase
op_star
id|subcase
suffix:semicolon
r_int
id|status
op_assign
id|urb-&gt;status
suffix:semicolon
id|reqp
op_assign
(paren
r_struct
id|usb_ctrlrequest
op_star
)paren
id|urb-&gt;setup_packet
suffix:semicolon
id|subcase
op_assign
id|container_of
(paren
id|reqp
comma
r_struct
id|subcase
comma
id|setup
)paren
suffix:semicolon
id|spin_lock
(paren
op_amp
id|ctx-&gt;lock
)paren
suffix:semicolon
id|ctx-&gt;count
op_decrement
suffix:semicolon
id|ctx-&gt;pending
op_decrement
suffix:semicolon
multiline_comment|/* queue must transfer and complete in fifo order, unless&n;&t; * usb_unlink_urb() is used to unlink something not at the&n;&t; * physical queue head (not tested).&n;&t; */
r_if
c_cond
(paren
id|subcase-&gt;number
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|subcase-&gt;number
op_minus
id|ctx-&gt;last
)paren
op_ne
l_int|1
)paren
(brace
id|dbg
(paren
l_string|&quot;subcase %d completed out of order, last %d&quot;
comma
id|subcase-&gt;number
comma
id|ctx-&gt;last
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|EDOM
suffix:semicolon
id|ctx-&gt;last
op_assign
id|subcase-&gt;number
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
)brace
id|ctx-&gt;last
op_assign
id|subcase-&gt;number
suffix:semicolon
multiline_comment|/* succeed or fault in only one way? */
r_if
c_cond
(paren
id|status
op_eq
id|subcase-&gt;expected
)paren
id|status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* async unlink for cleanup? */
r_else
r_if
c_cond
(paren
id|status
op_ne
op_minus
id|ECONNRESET
)paren
(brace
multiline_comment|/* some faults are allowed, not required */
r_if
c_cond
(paren
id|subcase-&gt;expected
OG
l_int|0
op_logical_and
(paren
(paren
(paren
id|urb-&gt;status
op_eq
op_minus
id|subcase-&gt;expected
multiline_comment|/* happened */
op_logical_or
id|urb-&gt;status
op_eq
l_int|0
)paren
)paren
)paren
)paren
multiline_comment|/* didn&squot;t */
id|status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* sometimes more than one fault is allowed */
r_else
r_if
c_cond
(paren
id|subcase-&gt;number
op_eq
l_int|12
op_logical_and
id|status
op_eq
op_minus
id|EPIPE
)paren
id|status
op_assign
l_int|0
suffix:semicolon
r_else
id|dbg
(paren
l_string|&quot;subtest %d error, status %d&quot;
comma
id|subcase-&gt;number
comma
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/* unexpected status codes mean errors; ideally, in hardware */
r_if
c_cond
(paren
id|status
)paren
(brace
id|error
suffix:colon
r_if
c_cond
(paren
id|ctx-&gt;status
op_eq
l_int|0
)paren
(brace
r_int
id|i
suffix:semicolon
id|ctx-&gt;status
op_assign
id|status
suffix:semicolon
id|info
(paren
l_string|&quot;control queue %02x.%02x, err %d, %d left&quot;
comma
id|reqp-&gt;bRequestType
comma
id|reqp-&gt;bRequest
comma
id|status
comma
id|ctx-&gt;count
)paren
suffix:semicolon
multiline_comment|/* FIXME this &quot;unlink everything&quot; exit route should&n;&t;&t;&t; * be a separate test case.&n;&t;&t;&t; */
multiline_comment|/* unlink whatever&squot;s still pending */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|ctx-&gt;param-&gt;sglen
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|urb
op_star
id|u
op_assign
id|ctx-&gt;urb
(braket
(paren
id|i
op_plus
id|subcase-&gt;number
)paren
op_mod
id|ctx-&gt;param-&gt;sglen
)braket
suffix:semicolon
r_if
c_cond
(paren
id|u
op_eq
id|urb
op_logical_or
op_logical_neg
id|u-&gt;dev
)paren
r_continue
suffix:semicolon
id|status
op_assign
id|usb_unlink_urb
(paren
id|u
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
op_minus
id|EINPROGRESS
suffix:colon
r_case
op_minus
id|EBUSY
suffix:colon
r_case
op_minus
id|EIDRM
suffix:colon
r_continue
suffix:semicolon
r_default
suffix:colon
id|dbg
(paren
l_string|&quot;urb unlink --&gt; %d&quot;
comma
id|status
)paren
suffix:semicolon
)brace
)brace
id|status
op_assign
id|ctx-&gt;status
suffix:semicolon
)brace
)brace
multiline_comment|/* resubmit if we need to, else mark this as done */
r_if
c_cond
(paren
(paren
id|status
op_eq
l_int|0
)paren
op_logical_and
(paren
id|ctx-&gt;pending
OL
id|ctx-&gt;count
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|status
op_assign
id|usb_submit_urb
(paren
id|urb
comma
id|SLAB_ATOMIC
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|dbg
(paren
l_string|&quot;can&squot;t resubmit ctrl %02x.%02x, err %d&quot;
comma
id|reqp-&gt;bRequestType
comma
id|reqp-&gt;bRequest
comma
id|status
)paren
suffix:semicolon
id|urb-&gt;dev
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
id|ctx-&gt;pending
op_increment
suffix:semicolon
)brace
r_else
id|urb-&gt;dev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* signal completion when nothing&squot;s queued */
r_if
c_cond
(paren
id|ctx-&gt;pending
op_eq
l_int|0
)paren
id|complete
(paren
op_amp
id|ctx-&gt;complete
)paren
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|ctx-&gt;lock
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|test_ctrl_queue
id|test_ctrl_queue
(paren
r_struct
id|usbtest_dev
op_star
id|dev
comma
r_struct
id|usbtest_param
op_star
id|param
)paren
(brace
r_struct
id|usb_device
op_star
id|udev
op_assign
id|testdev_to_usbdev
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|urb
op_star
op_star
id|urb
suffix:semicolon
r_struct
id|ctrl_ctx
id|context
suffix:semicolon
r_int
id|i
suffix:semicolon
id|spin_lock_init
(paren
op_amp
id|context.lock
)paren
suffix:semicolon
id|context.dev
op_assign
id|dev
suffix:semicolon
id|init_completion
(paren
op_amp
id|context.complete
)paren
suffix:semicolon
id|context.count
op_assign
id|param-&gt;sglen
op_star
id|param-&gt;iterations
suffix:semicolon
id|context.pending
op_assign
l_int|0
suffix:semicolon
id|context.status
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|context.param
op_assign
id|param
suffix:semicolon
id|context.last
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* allocate and init the urbs we&squot;ll queue.&n;&t; * as with bulk/intr sglists, sglen is the queue depth; it also&n;&t; * controls which subtests run (more tests than sglen) or rerun.&n;&t; */
id|urb
op_assign
id|kmalloc
(paren
id|param-&gt;sglen
op_star
r_sizeof
(paren
r_struct
id|urb
op_star
)paren
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
r_goto
id|cleanup
suffix:semicolon
id|memset
(paren
id|urb
comma
l_int|0
comma
id|param-&gt;sglen
op_star
r_sizeof
(paren
r_struct
id|urb
op_star
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|param-&gt;sglen
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|pipe
op_assign
id|usb_rcvctrlpipe
(paren
id|udev
comma
l_int|0
)paren
suffix:semicolon
r_int
id|len
suffix:semicolon
r_struct
id|urb
op_star
id|u
suffix:semicolon
r_struct
id|usb_ctrlrequest
id|req
suffix:semicolon
r_struct
id|subcase
op_star
id|reqp
suffix:semicolon
r_int
id|expected
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* requests here are mostly expected to succeed on any&n;&t;&t; * device, but some are chosen to trigger protocol stalls&n;&t;&t; * or short reads.&n;&t;&t; */
id|memset
(paren
op_amp
id|req
comma
l_int|0
comma
r_sizeof
id|req
)paren
suffix:semicolon
id|req.bRequest
op_assign
id|USB_REQ_GET_DESCRIPTOR
suffix:semicolon
id|req.bRequestType
op_assign
id|USB_DIR_IN
op_or
id|USB_RECIP_DEVICE
suffix:semicolon
r_switch
c_cond
(paren
id|i
op_mod
id|NUM_SUBCASES
)paren
(brace
r_case
l_int|0
suffix:colon
singleline_comment|// get device descriptor
id|req.wValue
op_assign
id|cpu_to_le16
(paren
id|USB_DT_DEVICE
op_lshift
l_int|8
)paren
suffix:semicolon
id|len
op_assign
r_sizeof
(paren
r_struct
id|usb_device_descriptor
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
singleline_comment|// get first config descriptor (only)
id|req.wValue
op_assign
id|cpu_to_le16
(paren
(paren
id|USB_DT_CONFIG
op_lshift
l_int|8
)paren
op_or
l_int|0
)paren
suffix:semicolon
id|len
op_assign
r_sizeof
(paren
r_struct
id|usb_config_descriptor
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
singleline_comment|// get altsetting (OFTEN STALLS)
id|req.bRequest
op_assign
id|USB_REQ_GET_INTERFACE
suffix:semicolon
id|req.bRequestType
op_assign
id|USB_DIR_IN
op_or
id|USB_RECIP_INTERFACE
suffix:semicolon
singleline_comment|// index = 0 means first interface
id|len
op_assign
l_int|1
suffix:semicolon
id|expected
op_assign
id|EPIPE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
singleline_comment|// get interface status
id|req.bRequest
op_assign
id|USB_REQ_GET_STATUS
suffix:semicolon
id|req.bRequestType
op_assign
id|USB_DIR_IN
op_or
id|USB_RECIP_INTERFACE
suffix:semicolon
singleline_comment|// interface 0
id|len
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
singleline_comment|// get device status
id|req.bRequest
op_assign
id|USB_REQ_GET_STATUS
suffix:semicolon
id|req.bRequestType
op_assign
id|USB_DIR_IN
op_or
id|USB_RECIP_DEVICE
suffix:semicolon
id|len
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
singleline_comment|// get device qualifier (MAY STALL)
id|req.wValue
op_assign
id|cpu_to_le16
(paren
id|USB_DT_DEVICE_QUALIFIER
op_lshift
l_int|8
)paren
suffix:semicolon
id|len
op_assign
r_sizeof
(paren
r_struct
id|usb_qualifier_descriptor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|udev-&gt;speed
op_ne
id|USB_SPEED_HIGH
)paren
id|expected
op_assign
id|EPIPE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
singleline_comment|// get first config descriptor, plus interface
id|req.wValue
op_assign
id|cpu_to_le16
(paren
(paren
id|USB_DT_CONFIG
op_lshift
l_int|8
)paren
op_or
l_int|0
)paren
suffix:semicolon
id|len
op_assign
r_sizeof
(paren
r_struct
id|usb_config_descriptor
)paren
suffix:semicolon
id|len
op_add_assign
r_sizeof
(paren
r_struct
id|usb_interface_descriptor
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
singleline_comment|// get interface descriptor (ALWAYS STALLS)
id|req.wValue
op_assign
id|cpu_to_le16
(paren
id|USB_DT_INTERFACE
op_lshift
l_int|8
)paren
suffix:semicolon
singleline_comment|// interface == 0
id|len
op_assign
r_sizeof
(paren
r_struct
id|usb_interface_descriptor
)paren
suffix:semicolon
id|expected
op_assign
id|EPIPE
suffix:semicolon
r_break
suffix:semicolon
singleline_comment|// NOTE: two consecutive stalls in the queue here.
singleline_comment|// that tests fault recovery a bit more aggressively.
r_case
l_int|8
suffix:colon
singleline_comment|// clear endpoint halt (USUALLY STALLS)
id|req.bRequest
op_assign
id|USB_REQ_CLEAR_FEATURE
suffix:semicolon
id|req.bRequestType
op_assign
id|USB_RECIP_ENDPOINT
suffix:semicolon
singleline_comment|// wValue 0 == ep halt
singleline_comment|// wIndex 0 == ep0 (shouldn&squot;t halt!)
id|len
op_assign
l_int|0
suffix:semicolon
id|pipe
op_assign
id|usb_sndctrlpipe
(paren
id|udev
comma
l_int|0
)paren
suffix:semicolon
id|expected
op_assign
id|EPIPE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9
suffix:colon
singleline_comment|// get endpoint status
id|req.bRequest
op_assign
id|USB_REQ_GET_STATUS
suffix:semicolon
id|req.bRequestType
op_assign
id|USB_DIR_IN
op_or
id|USB_RECIP_ENDPOINT
suffix:semicolon
singleline_comment|// endpoint 0
id|len
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|10
suffix:colon
singleline_comment|// trigger short read (EREMOTEIO)
id|req.wValue
op_assign
id|cpu_to_le16
(paren
(paren
id|USB_DT_CONFIG
op_lshift
l_int|8
)paren
op_or
l_int|0
)paren
suffix:semicolon
id|len
op_assign
l_int|1024
suffix:semicolon
id|expected
op_assign
op_minus
id|EREMOTEIO
suffix:semicolon
r_break
suffix:semicolon
singleline_comment|// NOTE: two consecutive _different_ faults in the queue.
r_case
l_int|11
suffix:colon
singleline_comment|// get endpoint descriptor (ALWAYS STALLS)
id|req.wValue
op_assign
id|cpu_to_le16
(paren
id|USB_DT_ENDPOINT
op_lshift
l_int|8
)paren
suffix:semicolon
singleline_comment|// endpoint == 0
id|len
op_assign
r_sizeof
(paren
r_struct
id|usb_interface_descriptor
)paren
suffix:semicolon
id|expected
op_assign
id|EPIPE
suffix:semicolon
r_break
suffix:semicolon
singleline_comment|// NOTE: sometimes even a third fault in the queue!
r_case
l_int|12
suffix:colon
singleline_comment|// get string 0 descriptor (MAY STALL)
id|req.wValue
op_assign
id|cpu_to_le16
(paren
id|USB_DT_STRING
op_lshift
l_int|8
)paren
suffix:semicolon
singleline_comment|// string == 0, for language IDs
id|len
op_assign
r_sizeof
(paren
r_struct
id|usb_interface_descriptor
)paren
suffix:semicolon
singleline_comment|// may succeed when &gt; 4 languages
id|expected
op_assign
id|EREMOTEIO
suffix:semicolon
singleline_comment|// or EPIPE, if no strings
r_break
suffix:semicolon
r_case
l_int|13
suffix:colon
singleline_comment|// short read, resembling case 10
id|req.wValue
op_assign
id|cpu_to_le16
(paren
(paren
id|USB_DT_CONFIG
op_lshift
l_int|8
)paren
op_or
l_int|0
)paren
suffix:semicolon
singleline_comment|// last data packet &quot;should&quot; be DATA1, not DATA0
id|len
op_assign
l_int|1024
op_minus
id|udev-&gt;descriptor.bMaxPacketSize0
suffix:semicolon
id|expected
op_assign
op_minus
id|EREMOTEIO
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|14
suffix:colon
singleline_comment|// short read; try to fill the last packet
id|req.wValue
op_assign
id|cpu_to_le16
(paren
(paren
id|USB_DT_DEVICE
op_lshift
l_int|8
)paren
op_or
l_int|0
)paren
suffix:semicolon
singleline_comment|// device descriptor size == 18 bytes 
id|len
op_assign
id|udev-&gt;descriptor.bMaxPacketSize0
suffix:semicolon
r_switch
c_cond
(paren
id|len
)paren
(brace
r_case
l_int|8
suffix:colon
id|len
op_assign
l_int|24
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|16
suffix:colon
id|len
op_assign
l_int|32
suffix:semicolon
r_break
suffix:semicolon
)brace
id|expected
op_assign
op_minus
id|EREMOTEIO
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
(paren
l_string|&quot;bogus number of ctrl queue testcases!&quot;
)paren
suffix:semicolon
id|context.status
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
id|req.wLength
op_assign
id|cpu_to_le16
(paren
id|len
)paren
suffix:semicolon
id|urb
(braket
id|i
)braket
op_assign
id|u
op_assign
id|simple_alloc_urb
(paren
id|udev
comma
id|pipe
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|u
)paren
r_goto
id|cleanup
suffix:semicolon
id|reqp
op_assign
id|usb_buffer_alloc
(paren
id|udev
comma
r_sizeof
op_star
id|reqp
comma
id|SLAB_KERNEL
comma
op_amp
id|u-&gt;setup_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reqp
)paren
r_goto
id|cleanup
suffix:semicolon
id|reqp-&gt;setup
op_assign
id|req
suffix:semicolon
id|reqp-&gt;number
op_assign
id|i
op_mod
id|NUM_SUBCASES
suffix:semicolon
id|reqp-&gt;expected
op_assign
id|expected
suffix:semicolon
id|u-&gt;setup_packet
op_assign
(paren
r_char
op_star
)paren
op_amp
id|reqp-&gt;setup
suffix:semicolon
id|u-&gt;context
op_assign
op_amp
id|context
suffix:semicolon
id|u-&gt;complete
op_assign
id|ctrl_complete
suffix:semicolon
id|u-&gt;transfer_flags
op_or_assign
id|URB_ASYNC_UNLINK
suffix:semicolon
)brace
multiline_comment|/* queue the urbs */
id|context.urb
op_assign
id|urb
suffix:semicolon
id|spin_lock_irq
(paren
op_amp
id|context.lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|param-&gt;sglen
suffix:semicolon
id|i
op_increment
)paren
(brace
id|context.status
op_assign
id|usb_submit_urb
(paren
id|urb
(braket
id|i
)braket
comma
id|SLAB_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|context.status
op_ne
l_int|0
)paren
(brace
id|dbg
(paren
l_string|&quot;can&squot;t submit urb[%d], status %d&quot;
comma
id|i
comma
id|context.status
)paren
suffix:semicolon
id|context.count
op_assign
id|context.pending
suffix:semicolon
r_break
suffix:semicolon
)brace
id|context.pending
op_increment
suffix:semicolon
)brace
id|spin_unlock_irq
(paren
op_amp
id|context.lock
)paren
suffix:semicolon
multiline_comment|/* FIXME  set timer and time out; provide a disconnect hook */
multiline_comment|/* wait for the last one to complete */
r_if
c_cond
(paren
id|context.pending
OG
l_int|0
)paren
id|wait_for_completion
(paren
op_amp
id|context.complete
)paren
suffix:semicolon
id|cleanup
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|param-&gt;sglen
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|urb
(braket
id|i
)braket
)paren
r_continue
suffix:semicolon
id|urb
(braket
id|i
)braket
op_member_access_from_pointer
id|dev
op_assign
id|udev
suffix:semicolon
r_if
c_cond
(paren
id|urb
(braket
id|i
)braket
op_member_access_from_pointer
id|setup_packet
)paren
id|usb_buffer_free
(paren
id|udev
comma
r_sizeof
(paren
r_struct
id|usb_ctrlrequest
)paren
comma
id|urb
(braket
id|i
)braket
op_member_access_from_pointer
id|setup_packet
comma
id|urb
(braket
id|i
)braket
op_member_access_from_pointer
id|setup_dma
)paren
suffix:semicolon
id|simple_free_urb
(paren
id|urb
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|kfree
(paren
id|urb
)paren
suffix:semicolon
r_return
id|context.status
suffix:semicolon
)brace
DECL|macro|NUM_SUBCASES
macro_line|#undef NUM_SUBCASES
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|unlink1_callback
r_static
r_void
id|unlink1_callback
(paren
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|status
op_assign
id|urb-&gt;status
suffix:semicolon
singleline_comment|// we &quot;know&quot; -EPIPE (stall) never happens
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
id|status
op_assign
id|usb_submit_urb
(paren
id|urb
comma
id|SLAB_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
id|urb-&gt;status
op_assign
id|status
suffix:semicolon
id|complete
(paren
(paren
r_struct
id|completion
op_star
)paren
id|urb-&gt;context
)paren
suffix:semicolon
)brace
)brace
DECL|function|unlink1
r_static
r_int
id|unlink1
(paren
r_struct
id|usbtest_dev
op_star
id|dev
comma
r_int
id|pipe
comma
r_int
id|size
comma
r_int
id|async
)paren
(brace
r_struct
id|urb
op_star
id|urb
suffix:semicolon
r_struct
id|completion
id|completion
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
id|init_completion
(paren
op_amp
id|completion
)paren
suffix:semicolon
id|urb
op_assign
id|simple_alloc_urb
(paren
id|testdev_to_usbdev
(paren
id|dev
)paren
comma
id|pipe
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|urb-&gt;transfer_flags
op_or_assign
id|URB_ASYNC_UNLINK
suffix:semicolon
id|urb-&gt;context
op_assign
op_amp
id|completion
suffix:semicolon
id|urb-&gt;complete
op_assign
id|unlink1_callback
suffix:semicolon
multiline_comment|/* keep the endpoint busy.  there are lots of hc/hcd-internal&n;&t; * states, and testing should get to all of them over time.&n;&t; *&n;&t; * FIXME want additional tests for when endpoint is STALLing&n;&t; * due to errors, or is just NAKing requests.&n;&t; */
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|usb_submit_urb
(paren
id|urb
comma
id|SLAB_KERNEL
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|dev_dbg
(paren
op_amp
id|dev-&gt;intf-&gt;dev
comma
l_string|&quot;submit fail %d&bslash;n&quot;
comma
id|retval
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* unlinking that should always work.  variable delay tests more&n;&t; * hcd states and code paths, even with little other system load.&n;&t; */
id|msleep
(paren
id|jiffies
op_mod
(paren
l_int|2
op_star
id|INTERRUPT_RATE
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|async
)paren
(brace
id|retry
suffix:colon
id|retval
op_assign
id|usb_unlink_urb
(paren
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
op_minus
id|EBUSY
op_logical_or
id|retval
op_eq
op_minus
id|EIDRM
)paren
(brace
multiline_comment|/* we can&squot;t unlink urbs while they&squot;re completing.&n;&t;&t;&t; * or if they&squot;ve completed, and we haven&squot;t resubmitted.&n;&t;&t;&t; * &quot;normal&quot; drivers would prevent resubmission, but&n;&t;&t;&t; * since we&squot;re testing unlink paths, we can&squot;t.&n;&t;&t;&t; */
id|dev_dbg
(paren
op_amp
id|dev-&gt;intf-&gt;dev
comma
l_string|&quot;unlink retry&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
)brace
r_else
id|usb_kill_urb
(paren
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|retval
op_eq
l_int|0
op_logical_or
id|retval
op_eq
op_minus
id|EINPROGRESS
)paren
)paren
(brace
id|dev_dbg
(paren
op_amp
id|dev-&gt;intf-&gt;dev
comma
l_string|&quot;unlink fail %d&bslash;n&quot;
comma
id|retval
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|wait_for_completion
(paren
op_amp
id|completion
)paren
suffix:semicolon
id|retval
op_assign
id|urb-&gt;status
suffix:semicolon
id|simple_free_urb
(paren
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|async
)paren
r_return
(paren
id|retval
op_eq
op_minus
id|ECONNRESET
)paren
ques
c_cond
l_int|0
suffix:colon
id|retval
op_minus
l_int|1000
suffix:semicolon
r_else
r_return
(paren
id|retval
op_eq
op_minus
id|ENOENT
op_logical_or
id|retval
op_eq
op_minus
id|EPERM
)paren
ques
c_cond
l_int|0
suffix:colon
id|retval
op_minus
l_int|2000
suffix:semicolon
)brace
DECL|function|unlink_simple
r_static
r_int
id|unlink_simple
(paren
r_struct
id|usbtest_dev
op_star
id|dev
comma
r_int
id|pipe
comma
r_int
id|len
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* test sync and async paths */
id|retval
op_assign
id|unlink1
(paren
id|dev
comma
id|pipe
comma
id|len
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|retval
op_assign
id|unlink1
(paren
id|dev
comma
id|pipe
comma
id|len
comma
l_int|0
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|verify_not_halted
r_static
r_int
id|verify_not_halted
(paren
r_int
id|ep
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
id|retval
suffix:semicolon
id|u16
id|status
suffix:semicolon
multiline_comment|/* shouldn&squot;t look or act halted */
id|retval
op_assign
id|usb_get_status
(paren
id|urb-&gt;dev
comma
id|USB_RECIP_ENDPOINT
comma
id|ep
comma
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
(brace
id|dbg
(paren
l_string|&quot;ep %02x couldn&squot;t get no-halt status, %d&quot;
comma
id|ep
comma
id|retval
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_ne
l_int|0
)paren
(brace
id|dbg
(paren
l_string|&quot;ep %02x bogus status: %04x != 0&quot;
comma
id|ep
comma
id|status
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|retval
op_assign
id|simple_io
(paren
id|urb
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|verify_halted
r_static
r_int
id|verify_halted
(paren
r_int
id|ep
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
id|retval
suffix:semicolon
id|u16
id|status
suffix:semicolon
multiline_comment|/* should look and act halted */
id|retval
op_assign
id|usb_get_status
(paren
id|urb-&gt;dev
comma
id|USB_RECIP_ENDPOINT
comma
id|ep
comma
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
(brace
id|dbg
(paren
l_string|&quot;ep %02x couldn&squot;t get halt status, %d&quot;
comma
id|ep
comma
id|retval
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_ne
l_int|1
)paren
(brace
id|dbg
(paren
l_string|&quot;ep %02x bogus status: %04x != 1&quot;
comma
id|ep
comma
id|status
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|retval
op_assign
id|simple_io
(paren
id|urb
comma
l_int|1
comma
l_int|0
comma
op_minus
id|EPIPE
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
op_minus
id|EPIPE
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|retval
op_assign
id|simple_io
(paren
id|urb
comma
l_int|1
comma
l_int|0
comma
op_minus
id|EPIPE
comma
l_string|&quot;verify_still_halted&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
op_minus
id|EPIPE
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|test_halt
r_static
r_int
id|test_halt
(paren
r_int
id|ep
comma
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_int
id|retval
suffix:semicolon
multiline_comment|/* shouldn&squot;t look or act halted now */
id|retval
op_assign
id|verify_not_halted
(paren
id|ep
comma
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_return
id|retval
suffix:semicolon
multiline_comment|/* set halt (protocol test only), verify it worked */
id|retval
op_assign
id|usb_control_msg
(paren
id|urb-&gt;dev
comma
id|usb_sndctrlpipe
(paren
id|urb-&gt;dev
comma
l_int|0
)paren
comma
id|USB_REQ_SET_FEATURE
comma
id|USB_RECIP_ENDPOINT
comma
id|USB_ENDPOINT_HALT
comma
id|ep
comma
l_int|NULL
comma
l_int|0
comma
id|USB_CTRL_SET_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
(brace
id|dbg
(paren
l_string|&quot;ep %02x couldn&squot;t set halt, %d&quot;
comma
id|ep
comma
id|retval
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|retval
op_assign
id|verify_halted
(paren
id|ep
comma
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_return
id|retval
suffix:semicolon
multiline_comment|/* clear halt (tests API + protocol), verify it worked */
id|retval
op_assign
id|usb_clear_halt
(paren
id|urb-&gt;dev
comma
id|urb-&gt;pipe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
(brace
id|dbg
(paren
l_string|&quot;ep %02x couldn&squot;t clear halt, %d&quot;
comma
id|ep
comma
id|retval
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|retval
op_assign
id|verify_not_halted
(paren
id|ep
comma
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_return
id|retval
suffix:semicolon
multiline_comment|/* NOTE:  could also verify SET_INTERFACE clear halts ... */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|halt_simple
r_static
r_int
id|halt_simple
(paren
r_struct
id|usbtest_dev
op_star
id|dev
)paren
(brace
r_int
id|ep
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_struct
id|urb
op_star
id|urb
suffix:semicolon
id|urb
op_assign
id|simple_alloc_urb
(paren
id|testdev_to_usbdev
(paren
id|dev
)paren
comma
l_int|0
comma
l_int|512
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;in_pipe
)paren
(brace
id|ep
op_assign
id|usb_pipeendpoint
(paren
id|dev-&gt;in_pipe
)paren
op_or
id|USB_DIR_IN
suffix:semicolon
id|urb-&gt;pipe
op_assign
id|dev-&gt;in_pipe
suffix:semicolon
id|retval
op_assign
id|test_halt
(paren
id|ep
comma
id|urb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;out_pipe
)paren
(brace
id|ep
op_assign
id|usb_pipeendpoint
(paren
id|dev-&gt;out_pipe
)paren
suffix:semicolon
id|urb-&gt;pipe
op_assign
id|dev-&gt;out_pipe
suffix:semicolon
id|retval
op_assign
id|test_halt
(paren
id|ep
comma
id|urb
)paren
suffix:semicolon
)brace
id|done
suffix:colon
id|simple_free_urb
(paren
id|urb
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* Control OUT tests use the vendor control requests from Intel&squot;s&n; * USB 2.0 compliance test device:  write a buffer, read it back.&n; *&n; * Intel&squot;s spec only _requires_ that it work for one packet, which&n; * is pretty weak.   Some HCDs place limits here; most devices will&n; * need to be able to handle more than one OUT data packet.  We&squot;ll&n; * try whatever we&squot;re told to try.&n; */
DECL|function|ctrl_out
r_static
r_int
id|ctrl_out
(paren
r_struct
id|usbtest_dev
op_star
id|dev
comma
r_int
id|count
comma
r_int
id|length
comma
r_int
id|vary
)paren
(brace
r_int
id|i
comma
id|j
comma
id|len
comma
id|retval
suffix:semicolon
id|u8
op_star
id|buf
suffix:semicolon
r_char
op_star
id|what
op_assign
l_string|&quot;?&quot;
suffix:semicolon
r_struct
id|usb_device
op_star
id|udev
suffix:semicolon
r_if
c_cond
(paren
id|length
OG
l_int|0xffff
op_logical_or
id|vary
op_ge
id|length
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|buf
op_assign
id|kmalloc
c_func
(paren
id|length
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|udev
op_assign
id|testdev_to_usbdev
(paren
id|dev
)paren
suffix:semicolon
id|len
op_assign
id|length
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* NOTE:  hardware might well act differently if we pushed it&n;&t; * with lots back-to-back queued requests.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* write patterned data */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|len
suffix:semicolon
id|j
op_increment
)paren
id|buf
(braket
id|j
)braket
op_assign
id|i
op_plus
id|j
suffix:semicolon
id|retval
op_assign
id|usb_control_msg
(paren
id|udev
comma
id|usb_sndctrlpipe
(paren
id|udev
comma
l_int|0
)paren
comma
l_int|0x5b
comma
id|USB_DIR_OUT
op_or
id|USB_TYPE_VENDOR
comma
l_int|0
comma
l_int|0
comma
id|buf
comma
id|len
comma
id|USB_CTRL_SET_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
id|len
)paren
(brace
id|what
op_assign
l_string|&quot;write&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* read it back -- assuming nothing intervened!!  */
id|retval
op_assign
id|usb_control_msg
(paren
id|udev
comma
id|usb_rcvctrlpipe
(paren
id|udev
comma
l_int|0
)paren
comma
l_int|0x5c
comma
id|USB_DIR_IN
op_or
id|USB_TYPE_VENDOR
comma
l_int|0
comma
l_int|0
comma
id|buf
comma
id|len
comma
id|USB_CTRL_GET_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
id|len
)paren
(brace
id|what
op_assign
l_string|&quot;read&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* fail if we can&squot;t verify */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|len
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|buf
(braket
id|j
)braket
op_ne
(paren
id|u8
)paren
(paren
id|i
op_plus
id|j
)paren
)paren
(brace
id|INFO
(paren
id|dev
comma
l_string|&quot;ctrl_out, byte %d is %d not %d&bslash;n&quot;
comma
id|j
comma
id|buf
(braket
id|j
)braket
comma
(paren
id|u8
)paren
id|i
op_plus
id|j
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EBADMSG
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
(brace
id|what
op_assign
l_string|&quot;verify&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
id|len
op_add_assign
id|vary
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
id|INFO
(paren
id|dev
comma
l_string|&quot;ctrl_out %s failed, code %d, count %d&bslash;n&quot;
comma
id|what
comma
id|retval
comma
id|i
)paren
suffix:semicolon
id|kfree
(paren
id|buf
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* ISO tests ... mimics common usage&n; *  - buffer length is split into N packets (mostly maxpacket sized)&n; *  - multi-buffers according to sglen&n; */
DECL|struct|iso_context
r_struct
id|iso_context
(brace
DECL|member|count
r_int
id|count
suffix:semicolon
DECL|member|pending
r_int
id|pending
suffix:semicolon
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|done
r_struct
id|completion
id|done
suffix:semicolon
DECL|member|errors
r_int
r_int
id|errors
suffix:semicolon
DECL|member|dev
r_struct
id|usbtest_dev
op_star
id|dev
suffix:semicolon
)brace
suffix:semicolon
DECL|function|iso_callback
r_static
r_void
id|iso_callback
(paren
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|iso_context
op_star
id|ctx
op_assign
id|urb-&gt;context
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|ctx-&gt;lock
)paren
suffix:semicolon
id|ctx-&gt;count
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;error_count
OG
l_int|0
)paren
id|ctx-&gt;errors
op_add_assign
id|urb-&gt;error_count
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;status
op_eq
l_int|0
op_logical_and
id|ctx-&gt;count
OG
(paren
id|ctx-&gt;pending
op_minus
l_int|1
)paren
)paren
(brace
r_int
id|status
op_assign
id|usb_submit_urb
(paren
id|urb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
l_int|0
suffix:colon
r_goto
id|done
suffix:semicolon
r_default
suffix:colon
id|dev_dbg
(paren
op_amp
id|ctx-&gt;dev-&gt;intf-&gt;dev
comma
l_string|&quot;iso resubmit err %d&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_case
op_minus
id|ENODEV
suffix:colon
multiline_comment|/* disconnected */
r_break
suffix:semicolon
)brace
)brace
id|simple_free_urb
(paren
id|urb
)paren
suffix:semicolon
id|ctx-&gt;pending
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;pending
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ctx-&gt;errors
)paren
id|dev_dbg
(paren
op_amp
id|ctx-&gt;dev-&gt;intf-&gt;dev
comma
l_string|&quot;iso test, %lu errors&bslash;n&quot;
comma
id|ctx-&gt;errors
)paren
suffix:semicolon
id|complete
(paren
op_amp
id|ctx-&gt;done
)paren
suffix:semicolon
)brace
id|done
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|ctx-&gt;lock
)paren
suffix:semicolon
)brace
DECL|function|iso_alloc_urb
r_static
r_struct
id|urb
op_star
id|iso_alloc_urb
(paren
r_struct
id|usb_device
op_star
id|udev
comma
r_int
id|pipe
comma
r_struct
id|usb_endpoint_descriptor
op_star
id|desc
comma
r_int
id|bytes
)paren
(brace
r_struct
id|urb
op_star
id|urb
suffix:semicolon
r_int
id|i
comma
id|maxp
comma
id|packets
suffix:semicolon
r_if
c_cond
(paren
id|bytes
OL
l_int|0
op_logical_or
op_logical_neg
id|desc
)paren
r_return
l_int|NULL
suffix:semicolon
id|maxp
op_assign
l_int|0x7ff
op_amp
id|le16_to_cpu
c_func
(paren
id|desc-&gt;wMaxPacketSize
)paren
suffix:semicolon
id|maxp
op_mul_assign
l_int|1
op_plus
(paren
l_int|0x3
op_amp
(paren
id|le16_to_cpu
c_func
(paren
id|desc-&gt;wMaxPacketSize
)paren
op_rshift
l_int|11
)paren
)paren
suffix:semicolon
id|packets
op_assign
(paren
id|bytes
op_plus
id|maxp
op_minus
l_int|1
)paren
op_div
id|maxp
suffix:semicolon
id|urb
op_assign
id|usb_alloc_urb
(paren
id|packets
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
r_return
id|urb
suffix:semicolon
id|urb-&gt;dev
op_assign
id|udev
suffix:semicolon
id|urb-&gt;pipe
op_assign
id|pipe
suffix:semicolon
id|urb-&gt;number_of_packets
op_assign
id|packets
suffix:semicolon
id|urb-&gt;transfer_buffer_length
op_assign
id|bytes
suffix:semicolon
id|urb-&gt;transfer_buffer
op_assign
id|usb_buffer_alloc
(paren
id|udev
comma
id|bytes
comma
id|SLAB_KERNEL
comma
op_amp
id|urb-&gt;transfer_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb-&gt;transfer_buffer
)paren
(brace
id|usb_free_urb
(paren
id|urb
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
(paren
id|urb-&gt;transfer_buffer
comma
l_int|0
comma
id|bytes
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|packets
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* here, only the last packet will be short */
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|length
op_assign
id|min
(paren
(paren
r_int
)paren
id|bytes
comma
id|maxp
)paren
suffix:semicolon
id|bytes
op_sub_assign
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|length
suffix:semicolon
id|urb-&gt;iso_frame_desc
(braket
id|i
)braket
dot
id|offset
op_assign
id|maxp
op_star
id|i
suffix:semicolon
)brace
id|urb-&gt;complete
op_assign
id|iso_callback
suffix:semicolon
singleline_comment|// urb-&gt;context = SET BY CALLER
id|urb-&gt;interval
op_assign
l_int|1
op_lshift
(paren
id|desc-&gt;bInterval
op_minus
l_int|1
)paren
suffix:semicolon
id|urb-&gt;transfer_flags
op_assign
id|URB_ISO_ASAP
op_or
id|URB_NO_TRANSFER_DMA_MAP
suffix:semicolon
r_return
id|urb
suffix:semicolon
)brace
r_static
r_int
DECL|function|test_iso_queue
id|test_iso_queue
(paren
r_struct
id|usbtest_dev
op_star
id|dev
comma
r_struct
id|usbtest_param
op_star
id|param
comma
r_int
id|pipe
comma
r_struct
id|usb_endpoint_descriptor
op_star
id|desc
)paren
(brace
r_struct
id|iso_context
id|context
suffix:semicolon
r_struct
id|usb_device
op_star
id|udev
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|packets
op_assign
l_int|0
suffix:semicolon
r_int
id|status
suffix:semicolon
r_struct
id|urb
op_star
id|urbs
(braket
l_int|10
)braket
suffix:semicolon
multiline_comment|/* FIXME no limit */
r_if
c_cond
(paren
id|param-&gt;sglen
OG
l_int|10
)paren
r_return
op_minus
id|EDOM
suffix:semicolon
id|context.count
op_assign
id|param-&gt;iterations
op_star
id|param-&gt;sglen
suffix:semicolon
id|context.pending
op_assign
id|param-&gt;sglen
suffix:semicolon
id|context.errors
op_assign
l_int|0
suffix:semicolon
id|context.dev
op_assign
id|dev
suffix:semicolon
id|init_completion
(paren
op_amp
id|context.done
)paren
suffix:semicolon
id|spin_lock_init
(paren
op_amp
id|context.lock
)paren
suffix:semicolon
id|memset
(paren
id|urbs
comma
l_int|0
comma
r_sizeof
id|urbs
)paren
suffix:semicolon
id|udev
op_assign
id|testdev_to_usbdev
(paren
id|dev
)paren
suffix:semicolon
id|dev_dbg
(paren
op_amp
id|dev-&gt;intf-&gt;dev
comma
l_string|&quot;... iso period %d %sframes, wMaxPacket %04x&bslash;n&quot;
comma
l_int|1
op_lshift
(paren
id|desc-&gt;bInterval
op_minus
l_int|1
)paren
comma
(paren
id|udev-&gt;speed
op_eq
id|USB_SPEED_HIGH
)paren
ques
c_cond
l_string|&quot;micro&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|le16_to_cpu
c_func
(paren
id|desc-&gt;wMaxPacketSize
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|param-&gt;sglen
suffix:semicolon
id|i
op_increment
)paren
(brace
id|urbs
(braket
id|i
)braket
op_assign
id|iso_alloc_urb
(paren
id|udev
comma
id|pipe
comma
id|desc
comma
id|param-&gt;length
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urbs
(braket
id|i
)braket
)paren
(brace
id|status
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
id|packets
op_add_assign
id|urbs
(braket
id|i
)braket
op_member_access_from_pointer
id|number_of_packets
suffix:semicolon
id|urbs
(braket
id|i
)braket
op_member_access_from_pointer
id|context
op_assign
op_amp
id|context
suffix:semicolon
)brace
id|packets
op_mul_assign
id|param-&gt;iterations
suffix:semicolon
id|dev_dbg
(paren
op_amp
id|dev-&gt;intf-&gt;dev
comma
l_string|&quot;... total %lu msec (%lu packets)&bslash;n&quot;
comma
(paren
id|packets
op_star
(paren
l_int|1
op_lshift
(paren
id|desc-&gt;bInterval
op_minus
l_int|1
)paren
)paren
)paren
op_div
(paren
(paren
id|udev-&gt;speed
op_eq
id|USB_SPEED_HIGH
)paren
ques
c_cond
l_int|8
suffix:colon
l_int|1
)paren
comma
id|packets
)paren
suffix:semicolon
id|spin_lock_irq
(paren
op_amp
id|context.lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|param-&gt;sglen
suffix:semicolon
id|i
op_increment
)paren
(brace
id|status
op_assign
id|usb_submit_urb
(paren
id|urbs
(braket
id|i
)braket
comma
id|SLAB_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
id|ERROR
(paren
id|dev
comma
l_string|&quot;submit iso[%d], error %d&bslash;n&quot;
comma
id|i
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
id|spin_unlock_irq
(paren
op_amp
id|context.lock
)paren
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
id|simple_free_urb
(paren
id|urbs
(braket
id|i
)braket
)paren
suffix:semicolon
id|context.pending
op_decrement
suffix:semicolon
)brace
)brace
id|spin_unlock_irq
(paren
op_amp
id|context.lock
)paren
suffix:semicolon
id|wait_for_completion
(paren
op_amp
id|context.done
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|fail
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|param-&gt;sglen
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|urbs
(braket
id|i
)braket
)paren
id|simple_free_urb
(paren
id|urbs
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* We only have this one interface to user space, through usbfs.&n; * User mode code can scan usbfs to find N different devices (maybe on&n; * different busses) to use when testing, and allocate one thread per&n; * test.  So discovery is simplified, and we have no device naming issues.&n; *&n; * Don&squot;t use these only as stress/load tests.  Use them along with with&n; * other USB bus activity:  plugging, unplugging, mousing, mp3 playback,&n; * video capture, and so on.  Run different tests at different times, in&n; * different sequences.  Nothing here should interact with other devices,&n; * except indirectly by consuming USB bandwidth and CPU resources for test&n; * threads and request completion.  But the only way to know that for sure&n; * is to test when HC queues are in use by many devices.&n; */
r_static
r_int
DECL|function|usbtest_ioctl
id|usbtest_ioctl
(paren
r_struct
id|usb_interface
op_star
id|intf
comma
r_int
r_int
id|code
comma
r_void
op_star
id|buf
)paren
(brace
r_struct
id|usbtest_dev
op_star
id|dev
op_assign
id|usb_get_intfdata
(paren
id|intf
)paren
suffix:semicolon
r_struct
id|usb_device
op_star
id|udev
op_assign
id|testdev_to_usbdev
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|usbtest_param
op_star
id|param
op_assign
id|buf
suffix:semicolon
r_int
id|retval
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_struct
id|urb
op_star
id|urb
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
r_struct
id|usb_sg_request
id|req
suffix:semicolon
r_struct
id|timeval
id|start
suffix:semicolon
r_int
id|i
suffix:semicolon
singleline_comment|// FIXME USBDEVFS_CONNECTINFO doesn&squot;t say how fast the device is.
r_if
c_cond
(paren
id|code
op_ne
id|USBTEST_REQUEST
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_if
c_cond
(paren
id|param-&gt;iterations
op_le
l_int|0
op_logical_or
id|param-&gt;length
OL
l_int|0
op_logical_or
id|param-&gt;sglen
OL
l_int|0
op_logical_or
id|param-&gt;vary
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|down_interruptible
(paren
op_amp
id|dev-&gt;sem
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
multiline_comment|/* some devices, like ez-usb default devices, need a non-default&n;&t; * altsetting to have any active endpoints.  some tests change&n;&t; * altsettings; force a default so most tests don&squot;t need to check.&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;info-&gt;alt
op_ge
l_int|0
)paren
(brace
r_int
id|res
suffix:semicolon
r_if
c_cond
(paren
id|intf-&gt;altsetting-&gt;desc.bInterfaceNumber
)paren
(brace
id|up
(paren
op_amp
id|dev-&gt;sem
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|res
op_assign
id|set_altsetting
(paren
id|dev
comma
id|dev-&gt;info-&gt;alt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
(brace
id|dev_err
(paren
op_amp
id|intf-&gt;dev
comma
l_string|&quot;set altsetting to %d failed, %d&bslash;n&quot;
comma
id|dev-&gt;info-&gt;alt
comma
id|res
)paren
suffix:semicolon
id|up
(paren
op_amp
id|dev-&gt;sem
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Just a bunch of test cases that every HCD is expected to handle.&n;&t; *&n;&t; * Some may need specific firmware, though it&squot;d be good to have&n;&t; * one firmware image to handle all the test cases.&n;&t; *&n;&t; * FIXME add more tests!  cancel requests, verify the data, control&n;&t; * queueing, concurrent read+write threads, and so on.&n;&t; */
id|do_gettimeofday
(paren
op_amp
id|start
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|param-&gt;test_num
)paren
(brace
r_case
l_int|0
suffix:colon
id|dev_dbg
(paren
op_amp
id|intf-&gt;dev
comma
l_string|&quot;TEST 0:  NOP&bslash;n&quot;
)paren
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Simple non-queued bulk I/O tests */
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;out_pipe
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|dev_dbg
(paren
op_amp
id|intf-&gt;dev
comma
l_string|&quot;TEST 1:  write %d bytes %u times&bslash;n&quot;
comma
id|param-&gt;length
comma
id|param-&gt;iterations
)paren
suffix:semicolon
id|urb
op_assign
id|simple_alloc_urb
(paren
id|udev
comma
id|dev-&gt;out_pipe
comma
id|param-&gt;length
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
(brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
singleline_comment|// FIRMWARE:  bulk sink (maybe accepts short writes)
id|retval
op_assign
id|simple_io
(paren
id|urb
comma
id|param-&gt;iterations
comma
l_int|0
comma
l_int|0
comma
l_string|&quot;test1&quot;
)paren
suffix:semicolon
id|simple_free_urb
(paren
id|urb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;in_pipe
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|dev_dbg
(paren
op_amp
id|intf-&gt;dev
comma
l_string|&quot;TEST 2:  read %d bytes %u times&bslash;n&quot;
comma
id|param-&gt;length
comma
id|param-&gt;iterations
)paren
suffix:semicolon
id|urb
op_assign
id|simple_alloc_urb
(paren
id|udev
comma
id|dev-&gt;in_pipe
comma
id|param-&gt;length
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
(brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
singleline_comment|// FIRMWARE:  bulk source (maybe generates short writes)
id|retval
op_assign
id|simple_io
(paren
id|urb
comma
id|param-&gt;iterations
comma
l_int|0
comma
l_int|0
comma
l_string|&quot;test2&quot;
)paren
suffix:semicolon
id|simple_free_urb
(paren
id|urb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;out_pipe
op_eq
l_int|0
op_logical_or
id|param-&gt;vary
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|dev_dbg
(paren
op_amp
id|intf-&gt;dev
comma
l_string|&quot;TEST 3:  write/%d 0..%d bytes %u times&bslash;n&quot;
comma
id|param-&gt;vary
comma
id|param-&gt;length
comma
id|param-&gt;iterations
)paren
suffix:semicolon
id|urb
op_assign
id|simple_alloc_urb
(paren
id|udev
comma
id|dev-&gt;out_pipe
comma
id|param-&gt;length
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
(brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
singleline_comment|// FIRMWARE:  bulk sink (maybe accepts short writes)
id|retval
op_assign
id|simple_io
(paren
id|urb
comma
id|param-&gt;iterations
comma
id|param-&gt;vary
comma
l_int|0
comma
l_string|&quot;test3&quot;
)paren
suffix:semicolon
id|simple_free_urb
(paren
id|urb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;in_pipe
op_eq
l_int|0
op_logical_or
id|param-&gt;vary
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|dev_dbg
(paren
op_amp
id|intf-&gt;dev
comma
l_string|&quot;TEST 4:  read/%d 0..%d bytes %u times&bslash;n&quot;
comma
id|param-&gt;vary
comma
id|param-&gt;length
comma
id|param-&gt;iterations
)paren
suffix:semicolon
id|urb
op_assign
id|simple_alloc_urb
(paren
id|udev
comma
id|dev-&gt;in_pipe
comma
id|param-&gt;length
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
(brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
singleline_comment|// FIRMWARE:  bulk source (maybe generates short writes)
id|retval
op_assign
id|simple_io
(paren
id|urb
comma
id|param-&gt;iterations
comma
id|param-&gt;vary
comma
l_int|0
comma
l_string|&quot;test4&quot;
)paren
suffix:semicolon
id|simple_free_urb
(paren
id|urb
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Queued bulk I/O tests */
r_case
l_int|5
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;out_pipe
op_eq
l_int|0
op_logical_or
id|param-&gt;sglen
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|dev_dbg
(paren
op_amp
id|intf-&gt;dev
comma
l_string|&quot;TEST 5:  write %d sglists %d entries of %d bytes&bslash;n&quot;
comma
id|param-&gt;iterations
comma
id|param-&gt;sglen
comma
id|param-&gt;length
)paren
suffix:semicolon
id|sg
op_assign
id|alloc_sglist
(paren
id|param-&gt;sglen
comma
id|param-&gt;length
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sg
)paren
(brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
singleline_comment|// FIRMWARE:  bulk sink (maybe accepts short writes)
id|retval
op_assign
id|perform_sglist
(paren
id|udev
comma
id|param-&gt;iterations
comma
id|dev-&gt;out_pipe
comma
op_amp
id|req
comma
id|sg
comma
id|param-&gt;sglen
)paren
suffix:semicolon
id|free_sglist
(paren
id|sg
comma
id|param-&gt;sglen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;in_pipe
op_eq
l_int|0
op_logical_or
id|param-&gt;sglen
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|dev_dbg
(paren
op_amp
id|intf-&gt;dev
comma
l_string|&quot;TEST 6:  read %d sglists %d entries of %d bytes&bslash;n&quot;
comma
id|param-&gt;iterations
comma
id|param-&gt;sglen
comma
id|param-&gt;length
)paren
suffix:semicolon
id|sg
op_assign
id|alloc_sglist
(paren
id|param-&gt;sglen
comma
id|param-&gt;length
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sg
)paren
(brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
singleline_comment|// FIRMWARE:  bulk source (maybe generates short writes)
id|retval
op_assign
id|perform_sglist
(paren
id|udev
comma
id|param-&gt;iterations
comma
id|dev-&gt;in_pipe
comma
op_amp
id|req
comma
id|sg
comma
id|param-&gt;sglen
)paren
suffix:semicolon
id|free_sglist
(paren
id|sg
comma
id|param-&gt;sglen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;out_pipe
op_eq
l_int|0
op_logical_or
id|param-&gt;sglen
op_eq
l_int|0
op_logical_or
id|param-&gt;vary
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|dev_dbg
(paren
op_amp
id|intf-&gt;dev
comma
l_string|&quot;TEST 7:  write/%d %d sglists %d entries 0..%d bytes&bslash;n&quot;
comma
id|param-&gt;vary
comma
id|param-&gt;iterations
comma
id|param-&gt;sglen
comma
id|param-&gt;length
)paren
suffix:semicolon
id|sg
op_assign
id|alloc_sglist
(paren
id|param-&gt;sglen
comma
id|param-&gt;length
comma
id|param-&gt;vary
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sg
)paren
(brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
singleline_comment|// FIRMWARE:  bulk sink (maybe accepts short writes)
id|retval
op_assign
id|perform_sglist
(paren
id|udev
comma
id|param-&gt;iterations
comma
id|dev-&gt;out_pipe
comma
op_amp
id|req
comma
id|sg
comma
id|param-&gt;sglen
)paren
suffix:semicolon
id|free_sglist
(paren
id|sg
comma
id|param-&gt;sglen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;in_pipe
op_eq
l_int|0
op_logical_or
id|param-&gt;sglen
op_eq
l_int|0
op_logical_or
id|param-&gt;vary
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|dev_dbg
(paren
op_amp
id|intf-&gt;dev
comma
l_string|&quot;TEST 8:  read/%d %d sglists %d entries 0..%d bytes&bslash;n&quot;
comma
id|param-&gt;vary
comma
id|param-&gt;iterations
comma
id|param-&gt;sglen
comma
id|param-&gt;length
)paren
suffix:semicolon
id|sg
op_assign
id|alloc_sglist
(paren
id|param-&gt;sglen
comma
id|param-&gt;length
comma
id|param-&gt;vary
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sg
)paren
(brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
singleline_comment|// FIRMWARE:  bulk source (maybe generates short writes)
id|retval
op_assign
id|perform_sglist
(paren
id|udev
comma
id|param-&gt;iterations
comma
id|dev-&gt;in_pipe
comma
op_amp
id|req
comma
id|sg
comma
id|param-&gt;sglen
)paren
suffix:semicolon
id|free_sglist
(paren
id|sg
comma
id|param-&gt;sglen
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* non-queued sanity tests for control (chapter 9 subset) */
r_case
l_int|9
suffix:colon
id|retval
op_assign
l_int|0
suffix:semicolon
id|dev_dbg
(paren
op_amp
id|intf-&gt;dev
comma
l_string|&quot;TEST 9:  ch9 (subset) control tests, %d times&bslash;n&quot;
comma
id|param-&gt;iterations
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|param-&gt;iterations
suffix:semicolon
id|retval
op_eq
l_int|0
op_logical_and
id|i
op_decrement
suffix:semicolon
multiline_comment|/* NOP */
)paren
id|retval
op_assign
id|ch9_postconfig
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
id|dbg
(paren
l_string|&quot;ch9 subset failed, iterations left %d&quot;
comma
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* queued control messaging */
r_case
l_int|10
suffix:colon
r_if
c_cond
(paren
id|param-&gt;sglen
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
id|dev_dbg
(paren
op_amp
id|intf-&gt;dev
comma
l_string|&quot;TEST 10:  queue %d control calls, %d times&bslash;n&quot;
comma
id|param-&gt;sglen
comma
id|param-&gt;iterations
)paren
suffix:semicolon
id|retval
op_assign
id|test_ctrl_queue
(paren
id|dev
comma
id|param
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* simple non-queued unlinks (ring with one urb) */
r_case
l_int|11
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;in_pipe
op_eq
l_int|0
op_logical_or
op_logical_neg
id|param-&gt;length
)paren
r_break
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
id|dev_dbg
(paren
op_amp
id|intf-&gt;dev
comma
l_string|&quot;TEST 11:  unlink %d reads of %d&bslash;n&quot;
comma
id|param-&gt;iterations
comma
id|param-&gt;length
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|param-&gt;iterations
suffix:semicolon
id|retval
op_eq
l_int|0
op_logical_and
id|i
op_decrement
suffix:semicolon
multiline_comment|/* NOP */
)paren
id|retval
op_assign
id|unlink_simple
(paren
id|dev
comma
id|dev-&gt;in_pipe
comma
id|param-&gt;length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
id|dev_dbg
(paren
op_amp
id|intf-&gt;dev
comma
l_string|&quot;unlink reads failed %d, &quot;
l_string|&quot;iterations left %d&bslash;n&quot;
comma
id|retval
comma
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|12
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;out_pipe
op_eq
l_int|0
op_logical_or
op_logical_neg
id|param-&gt;length
)paren
r_break
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
id|dev_dbg
(paren
op_amp
id|intf-&gt;dev
comma
l_string|&quot;TEST 12:  unlink %d writes of %d&bslash;n&quot;
comma
id|param-&gt;iterations
comma
id|param-&gt;length
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|param-&gt;iterations
suffix:semicolon
id|retval
op_eq
l_int|0
op_logical_and
id|i
op_decrement
suffix:semicolon
multiline_comment|/* NOP */
)paren
id|retval
op_assign
id|unlink_simple
(paren
id|dev
comma
id|dev-&gt;out_pipe
comma
id|param-&gt;length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
id|dev_dbg
(paren
op_amp
id|intf-&gt;dev
comma
l_string|&quot;unlink writes failed %d, &quot;
l_string|&quot;iterations left %d&bslash;n&quot;
comma
id|retval
comma
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* ep halt tests */
r_case
l_int|13
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;out_pipe
op_eq
l_int|0
op_logical_and
id|dev-&gt;in_pipe
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
id|dev_dbg
(paren
op_amp
id|intf-&gt;dev
comma
l_string|&quot;TEST 13:  set/clear %d halts&bslash;n&quot;
comma
id|param-&gt;iterations
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|param-&gt;iterations
suffix:semicolon
id|retval
op_eq
l_int|0
op_logical_and
id|i
op_decrement
suffix:semicolon
multiline_comment|/* NOP */
)paren
id|retval
op_assign
id|halt_simple
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
id|DBG
(paren
id|dev
comma
l_string|&quot;halts failed, iterations left %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* control write tests */
r_case
l_int|14
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;info-&gt;ctrl_out
)paren
r_break
suffix:semicolon
id|dev_dbg
(paren
op_amp
id|intf-&gt;dev
comma
l_string|&quot;TEST 14:  %d ep0out, 0..%d vary %d&bslash;n&quot;
comma
id|param-&gt;iterations
comma
id|param-&gt;length
comma
id|param-&gt;vary
)paren
suffix:semicolon
id|retval
op_assign
id|ctrl_out
(paren
id|dev
comma
id|param-&gt;iterations
comma
id|param-&gt;length
comma
id|param-&gt;vary
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* iso write tests */
r_case
l_int|15
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;out_iso_pipe
op_eq
l_int|0
op_logical_or
id|param-&gt;sglen
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|dev_dbg
(paren
op_amp
id|intf-&gt;dev
comma
l_string|&quot;TEST 15:  write %d iso, %d entries of %d bytes&bslash;n&quot;
comma
id|param-&gt;iterations
comma
id|param-&gt;sglen
comma
id|param-&gt;length
)paren
suffix:semicolon
singleline_comment|// FIRMWARE:  iso sink
id|retval
op_assign
id|test_iso_queue
(paren
id|dev
comma
id|param
comma
id|dev-&gt;out_iso_pipe
comma
id|dev-&gt;iso_out
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* iso read tests */
r_case
l_int|16
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;in_iso_pipe
op_eq
l_int|0
op_logical_or
id|param-&gt;sglen
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|dev_dbg
(paren
op_amp
id|intf-&gt;dev
comma
l_string|&quot;TEST 16:  read %d iso, %d entries of %d bytes&bslash;n&quot;
comma
id|param-&gt;iterations
comma
id|param-&gt;sglen
comma
id|param-&gt;length
)paren
suffix:semicolon
singleline_comment|// FIRMWARE:  iso source
id|retval
op_assign
id|test_iso_queue
(paren
id|dev
comma
id|param
comma
id|dev-&gt;in_iso_pipe
comma
id|dev-&gt;iso_in
)paren
suffix:semicolon
r_break
suffix:semicolon
singleline_comment|// FIXME unlink from queue (ring with N urbs)
singleline_comment|// FIXME scatterlist cancel (needs helper thread)
)brace
id|do_gettimeofday
(paren
op_amp
id|param-&gt;duration
)paren
suffix:semicolon
id|param-&gt;duration.tv_sec
op_sub_assign
id|start.tv_sec
suffix:semicolon
id|param-&gt;duration.tv_usec
op_sub_assign
id|start.tv_usec
suffix:semicolon
r_if
c_cond
(paren
id|param-&gt;duration.tv_usec
OL
l_int|0
)paren
(brace
id|param-&gt;duration.tv_usec
op_add_assign
l_int|1000
op_star
l_int|1000
suffix:semicolon
id|param-&gt;duration.tv_sec
op_sub_assign
l_int|1
suffix:semicolon
)brace
id|up
(paren
op_amp
id|dev-&gt;sem
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|variable|force_interrupt
r_static
r_int
id|force_interrupt
op_assign
l_int|0
suffix:semicolon
id|module_param
(paren
id|force_interrupt
comma
id|uint
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
(paren
id|force_interrupt
comma
l_string|&quot;0 = test default; else interrupt&quot;
)paren
suffix:semicolon
macro_line|#ifdef&t;GENERIC
DECL|variable|vendor
r_static
r_int
r_int
id|vendor
suffix:semicolon
id|module_param
c_func
(paren
id|vendor
comma
id|ushort
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
(paren
id|vendor
comma
l_string|&quot;vendor code (from usb-if)&quot;
)paren
suffix:semicolon
DECL|variable|product
r_static
r_int
r_int
id|product
suffix:semicolon
id|module_param
c_func
(paren
id|product
comma
id|ushort
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
(paren
id|product
comma
l_string|&quot;product code (from vendor)&quot;
)paren
suffix:semicolon
macro_line|#endif
r_static
r_int
DECL|function|usbtest_probe
id|usbtest_probe
(paren
r_struct
id|usb_interface
op_star
id|intf
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
(brace
r_struct
id|usb_device
op_star
id|udev
suffix:semicolon
r_struct
id|usbtest_dev
op_star
id|dev
suffix:semicolon
r_struct
id|usbtest_info
op_star
id|info
suffix:semicolon
r_char
op_star
id|rtest
comma
op_star
id|wtest
suffix:semicolon
r_char
op_star
id|irtest
comma
op_star
id|iwtest
suffix:semicolon
id|udev
op_assign
id|interface_to_usbdev
(paren
id|intf
)paren
suffix:semicolon
macro_line|#ifdef&t;GENERIC
multiline_comment|/* specify devices by module parameters? */
r_if
c_cond
(paren
id|id-&gt;match_flags
op_eq
l_int|0
)paren
(brace
multiline_comment|/* vendor match required, product match optional */
r_if
c_cond
(paren
op_logical_neg
id|vendor
op_logical_or
id|le16_to_cpu
c_func
(paren
id|udev-&gt;descriptor.idVendor
)paren
op_ne
(paren
id|u16
)paren
id|vendor
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|product
op_logical_and
id|le16_to_cpu
c_func
(paren
id|udev-&gt;descriptor.idProduct
)paren
op_ne
(paren
id|u16
)paren
id|product
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|dbg
(paren
l_string|&quot;matched module params, vend=0x%04x prod=0x%04x&quot;
comma
id|le16_to_cpu
c_func
(paren
id|udev-&gt;descriptor.idVendor
)paren
comma
id|le16_to_cpu
c_func
(paren
id|udev-&gt;descriptor.idProduct
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|dev
op_assign
id|kmalloc
(paren
r_sizeof
op_star
id|dev
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
(paren
id|dev
comma
l_int|0
comma
r_sizeof
op_star
id|dev
)paren
suffix:semicolon
id|info
op_assign
(paren
r_struct
id|usbtest_info
op_star
)paren
id|id-&gt;driver_info
suffix:semicolon
id|dev-&gt;info
op_assign
id|info
suffix:semicolon
id|init_MUTEX
(paren
op_amp
id|dev-&gt;sem
)paren
suffix:semicolon
id|dev-&gt;intf
op_assign
id|intf
suffix:semicolon
multiline_comment|/* cacheline-aligned scratch for i/o */
r_if
c_cond
(paren
(paren
id|dev-&gt;buf
op_assign
id|kmalloc
(paren
id|TBUF_SIZE
comma
id|SLAB_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|kfree
(paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* NOTE this doesn&squot;t yet test the handful of difference that are&n;&t; * visible with high speed interrupts:  bigger maxpacket (1K) and&n;&t; * &quot;high bandwidth&quot; modes (up to 3 packets/uframe).&n;&t; */
id|rtest
op_assign
id|wtest
op_assign
l_string|&quot;&quot;
suffix:semicolon
id|irtest
op_assign
id|iwtest
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_if
c_cond
(paren
id|force_interrupt
op_logical_or
id|udev-&gt;speed
op_eq
id|USB_SPEED_LOW
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;ep_in
)paren
(brace
id|dev-&gt;in_pipe
op_assign
id|usb_rcvintpipe
(paren
id|udev
comma
id|info-&gt;ep_in
)paren
suffix:semicolon
id|rtest
op_assign
l_string|&quot; intr-in&quot;
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;ep_out
)paren
(brace
id|dev-&gt;out_pipe
op_assign
id|usb_sndintpipe
(paren
id|udev
comma
id|info-&gt;ep_out
)paren
suffix:semicolon
id|wtest
op_assign
l_string|&quot; intr-out&quot;
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|info-&gt;autoconf
)paren
(brace
r_int
id|status
suffix:semicolon
id|status
op_assign
id|get_endpoints
(paren
id|dev
comma
id|intf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
id|dbg
(paren
l_string|&quot;couldn&squot;t get endpoints, %d&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/* may find bulk or ISO pipes */
)brace
r_else
(brace
r_if
c_cond
(paren
id|info-&gt;ep_in
)paren
id|dev-&gt;in_pipe
op_assign
id|usb_rcvbulkpipe
(paren
id|udev
comma
id|info-&gt;ep_in
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;ep_out
)paren
id|dev-&gt;out_pipe
op_assign
id|usb_sndbulkpipe
(paren
id|udev
comma
id|info-&gt;ep_out
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;in_pipe
)paren
id|rtest
op_assign
l_string|&quot; bulk-in&quot;
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;out_pipe
)paren
id|wtest
op_assign
l_string|&quot; bulk-out&quot;
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;in_iso_pipe
)paren
id|irtest
op_assign
l_string|&quot; iso-in&quot;
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;out_iso_pipe
)paren
id|iwtest
op_assign
l_string|&quot; iso-out&quot;
suffix:semicolon
)brace
id|usb_set_intfdata
(paren
id|intf
comma
id|dev
)paren
suffix:semicolon
id|dev_info
(paren
op_amp
id|intf-&gt;dev
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|info-&gt;name
)paren
suffix:semicolon
id|dev_info
(paren
op_amp
id|intf-&gt;dev
comma
l_string|&quot;%s speed {control%s%s%s%s%s} tests%s&bslash;n&quot;
comma
(paren
(brace
r_char
op_star
id|tmp
suffix:semicolon
r_switch
(paren
id|udev-&gt;speed
)paren
(brace
r_case
id|USB_SPEED_LOW
suffix:colon
id|tmp
op_assign
l_string|&quot;low&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_SPEED_FULL
suffix:colon
id|tmp
op_assign
l_string|&quot;full&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_SPEED_HIGH
suffix:colon
id|tmp
op_assign
l_string|&quot;high&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|tmp
op_assign
l_string|&quot;unknown&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|tmp
suffix:semicolon
)brace
)paren
comma
id|info-&gt;ctrl_out
ques
c_cond
l_string|&quot; in/out&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|rtest
comma
id|wtest
comma
id|irtest
comma
id|iwtest
comma
id|info-&gt;alt
op_ge
l_int|0
ques
c_cond
l_string|&quot; (+alt)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usbtest_disconnect
r_static
r_void
id|usbtest_disconnect
(paren
r_struct
id|usb_interface
op_star
id|intf
)paren
(brace
r_struct
id|usbtest_dev
op_star
id|dev
op_assign
id|usb_get_intfdata
(paren
id|intf
)paren
suffix:semicolon
id|down
(paren
op_amp
id|dev-&gt;sem
)paren
suffix:semicolon
id|usb_set_intfdata
(paren
id|intf
comma
l_int|NULL
)paren
suffix:semicolon
id|dev_dbg
(paren
op_amp
id|intf-&gt;dev
comma
l_string|&quot;disconnect&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* Basic testing only needs a device that can source or sink bulk traffic.&n; * Any device can test control transfers (default with GENERIC binding).&n; *&n; * Several entries work with the default EP0 implementation that&squot;s built&n; * into EZ-USB chips.  There&squot;s a default vendor ID which can be overridden&n; * by (very) small config EEPROMS, but otherwise all these devices act&n; * identically until firmware is loaded:  only EP0 works.  It turns out&n; * to be easy to make other endpoints work, without modifying that EP0&n; * behavior.  For now, we expect that kind of firmware.&n; */
multiline_comment|/* an21xx or fx versions of ez-usb */
DECL|variable|ez1_info
r_static
r_struct
id|usbtest_info
id|ez1_info
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;EZ-USB device&quot;
comma
dot
id|ep_in
op_assign
l_int|2
comma
dot
id|ep_out
op_assign
l_int|2
comma
dot
id|alt
op_assign
l_int|1
comma
)brace
suffix:semicolon
multiline_comment|/* fx2 version of ez-usb */
DECL|variable|ez2_info
r_static
r_struct
id|usbtest_info
id|ez2_info
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;FX2 device&quot;
comma
dot
id|ep_in
op_assign
l_int|6
comma
dot
id|ep_out
op_assign
l_int|2
comma
dot
id|alt
op_assign
l_int|1
comma
)brace
suffix:semicolon
multiline_comment|/* ezusb family device with dedicated usb test firmware,&n; */
DECL|variable|fw_info
r_static
r_struct
id|usbtest_info
id|fw_info
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;usb test device&quot;
comma
dot
id|ep_in
op_assign
l_int|2
comma
dot
id|ep_out
op_assign
l_int|2
comma
dot
id|alt
op_assign
l_int|1
comma
dot
id|autoconf
op_assign
l_int|1
comma
singleline_comment|// iso and ctrl_out need autoconf
dot
id|ctrl_out
op_assign
l_int|1
comma
dot
id|iso
op_assign
l_int|1
comma
singleline_comment|// iso_ep&squot;s are #8 in/out
)brace
suffix:semicolon
multiline_comment|/* peripheral running Linux and &squot;zero.c&squot; test firmware, or&n; * its user-mode cousin. different versions of this use&n; * different hardware with the same vendor/product codes.&n; * host side MUST rely on the endpoint descriptors.&n; */
DECL|variable|gz_info
r_static
r_struct
id|usbtest_info
id|gz_info
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;Linux gadget zero&quot;
comma
dot
id|autoconf
op_assign
l_int|1
comma
dot
id|ctrl_out
op_assign
l_int|1
comma
dot
id|alt
op_assign
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|um_info
r_static
r_struct
id|usbtest_info
id|um_info
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;Linux user mode test driver&quot;
comma
dot
id|autoconf
op_assign
l_int|1
comma
dot
id|alt
op_assign
op_minus
l_int|1
comma
)brace
suffix:semicolon
DECL|variable|um2_info
r_static
r_struct
id|usbtest_info
id|um2_info
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;Linux user mode ISO test driver&quot;
comma
dot
id|autoconf
op_assign
l_int|1
comma
dot
id|iso
op_assign
l_int|1
comma
dot
id|alt
op_assign
op_minus
l_int|1
comma
)brace
suffix:semicolon
macro_line|#ifdef IBOT2
multiline_comment|/* this is a nice source of high speed bulk data;&n; * uses an FX2, with firmware provided in the device&n; */
DECL|variable|ibot2_info
r_static
r_struct
id|usbtest_info
id|ibot2_info
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;iBOT2 webcam&quot;
comma
dot
id|ep_in
op_assign
l_int|2
comma
dot
id|alt
op_assign
op_minus
l_int|1
comma
)brace
suffix:semicolon
macro_line|#endif
macro_line|#ifdef GENERIC
multiline_comment|/* we can use any device to test control traffic */
DECL|variable|generic_info
r_static
r_struct
id|usbtest_info
id|generic_info
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;Generic USB device&quot;
comma
dot
id|alt
op_assign
op_minus
l_int|1
comma
)brace
suffix:semicolon
macro_line|#endif
singleline_comment|// FIXME remove this 
DECL|variable|hact_info
r_static
r_struct
id|usbtest_info
id|hact_info
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;FX2/hact&quot;
comma
singleline_comment|//.ep_in&t;&t;= 6,
dot
id|ep_out
op_assign
l_int|2
comma
dot
id|alt
op_assign
op_minus
l_int|1
comma
)brace
suffix:semicolon
DECL|variable|id_table
r_static
r_struct
id|usb_device_id
id|id_table
(braket
)braket
op_assign
(brace
(brace
id|USB_DEVICE
(paren
l_int|0x0547
comma
l_int|0x1002
)paren
comma
dot
id|driver_info
op_assign
(paren
r_int
r_int
)paren
op_amp
id|hact_info
comma
)brace
comma
multiline_comment|/*-------------------------------------------------------------*/
multiline_comment|/* EZ-USB devices which download firmware to replace (or in our&n;&t; * case augment) the default device implementation.&n;&t; */
multiline_comment|/* generic EZ-USB FX controller */
(brace
id|USB_DEVICE
(paren
l_int|0x0547
comma
l_int|0x2235
)paren
comma
dot
id|driver_info
op_assign
(paren
r_int
r_int
)paren
op_amp
id|ez1_info
comma
)brace
comma
multiline_comment|/* CY3671 development board with EZ-USB FX */
(brace
id|USB_DEVICE
(paren
l_int|0x0547
comma
l_int|0x0080
)paren
comma
dot
id|driver_info
op_assign
(paren
r_int
r_int
)paren
op_amp
id|ez1_info
comma
)brace
comma
multiline_comment|/* generic EZ-USB FX2 controller (or development board) */
(brace
id|USB_DEVICE
(paren
l_int|0x04b4
comma
l_int|0x8613
)paren
comma
dot
id|driver_info
op_assign
(paren
r_int
r_int
)paren
op_amp
id|ez2_info
comma
)brace
comma
multiline_comment|/* re-enumerated usb test device firmware */
(brace
id|USB_DEVICE
(paren
l_int|0xfff0
comma
l_int|0xfff0
)paren
comma
dot
id|driver_info
op_assign
(paren
r_int
r_int
)paren
op_amp
id|fw_info
comma
)brace
comma
multiline_comment|/* &quot;Gadget Zero&quot; firmware runs under Linux */
(brace
id|USB_DEVICE
(paren
l_int|0x0525
comma
l_int|0xa4a0
)paren
comma
dot
id|driver_info
op_assign
(paren
r_int
r_int
)paren
op_amp
id|gz_info
comma
)brace
comma
multiline_comment|/* so does a user-mode variant */
(brace
id|USB_DEVICE
(paren
l_int|0x0525
comma
l_int|0xa4a4
)paren
comma
dot
id|driver_info
op_assign
(paren
r_int
r_int
)paren
op_amp
id|um_info
comma
)brace
comma
multiline_comment|/* ... and a user-mode variant that talks iso */
(brace
id|USB_DEVICE
(paren
l_int|0x0525
comma
l_int|0xa4a3
)paren
comma
dot
id|driver_info
op_assign
(paren
r_int
r_int
)paren
op_amp
id|um2_info
comma
)brace
comma
macro_line|#ifdef KEYSPAN_19Qi
multiline_comment|/* Keyspan 19qi uses an21xx (original EZ-USB) */
singleline_comment|// this does not coexist with the real Keyspan 19qi driver!
(brace
id|USB_DEVICE
(paren
l_int|0x06cd
comma
l_int|0x010b
)paren
comma
dot
id|driver_info
op_assign
(paren
r_int
r_int
)paren
op_amp
id|ez1_info
comma
)brace
comma
macro_line|#endif
multiline_comment|/*-------------------------------------------------------------*/
macro_line|#ifdef IBOT2
multiline_comment|/* iBOT2 makes a nice source of high speed bulk-in data */
singleline_comment|// this does not coexist with a real iBOT2 driver!
(brace
id|USB_DEVICE
(paren
l_int|0x0b62
comma
l_int|0x0059
)paren
comma
dot
id|driver_info
op_assign
(paren
r_int
r_int
)paren
op_amp
id|ibot2_info
comma
)brace
comma
macro_line|#endif
multiline_comment|/*-------------------------------------------------------------*/
macro_line|#ifdef GENERIC
multiline_comment|/* module params can specify devices to use for control tests */
(brace
dot
id|driver_info
op_assign
(paren
r_int
r_int
)paren
op_amp
id|generic_info
comma
)brace
comma
macro_line|#endif
multiline_comment|/*-------------------------------------------------------------*/
(brace
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
(paren
id|usb
comma
id|id_table
)paren
suffix:semicolon
DECL|variable|usbtest_driver
r_static
r_struct
id|usb_driver
id|usbtest_driver
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|name
op_assign
l_string|&quot;usbtest&quot;
comma
dot
id|id_table
op_assign
id|id_table
comma
dot
id|probe
op_assign
id|usbtest_probe
comma
dot
id|ioctl
op_assign
id|usbtest_ioctl
comma
dot
id|disconnect
op_assign
id|usbtest_disconnect
comma
)brace
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|usbtest_init
r_static
r_int
id|__init
id|usbtest_init
(paren
r_void
)paren
(brace
macro_line|#ifdef GENERIC
r_if
c_cond
(paren
id|vendor
)paren
id|dbg
(paren
l_string|&quot;params: vend=0x%04x prod=0x%04x&quot;
comma
id|vendor
comma
id|product
)paren
suffix:semicolon
macro_line|#endif
r_return
id|usb_register
(paren
op_amp
id|usbtest_driver
)paren
suffix:semicolon
)brace
DECL|variable|usbtest_init
id|module_init
(paren
id|usbtest_init
)paren
suffix:semicolon
DECL|function|usbtest_exit
r_static
r_void
id|__exit
id|usbtest_exit
(paren
r_void
)paren
(brace
id|usb_deregister
(paren
op_amp
id|usbtest_driver
)paren
suffix:semicolon
)brace
DECL|variable|usbtest_exit
id|module_exit
(paren
id|usbtest_exit
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
(paren
l_string|&quot;USB Core/HCD Testing Driver&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
