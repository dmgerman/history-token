macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/scatterlist.h&gt;
macro_line|#if !defined (DEBUG) &amp;&amp; defined (CONFIG_USB_DEBUG)
DECL|macro|DEBUG
macro_line|#   define DEBUG
macro_line|#endif
macro_line|#include &lt;linux/usb.h&gt;
multiline_comment|/*-------------------------------------------------------------------------*/
singleline_comment|// FIXME make these public somewhere; usbdevfs.h?
singleline_comment|//
DECL|struct|usbtest_param
r_struct
id|usbtest_param
(brace
singleline_comment|// inputs
DECL|member|test_num
r_int
id|test_num
suffix:semicolon
multiline_comment|/* 0..(TEST_CASES-1) */
DECL|member|iterations
r_int
id|iterations
suffix:semicolon
DECL|member|length
r_int
id|length
suffix:semicolon
DECL|member|vary
r_int
id|vary
suffix:semicolon
DECL|member|sglen
r_int
id|sglen
suffix:semicolon
singleline_comment|// outputs
DECL|member|duration
r_struct
id|timeval
id|duration
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|USBTEST_REQUEST
mdefine_line|#define USBTEST_REQUEST&t;_IOWR(&squot;U&squot;, 100, struct usbtest_param)
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|macro|GENERIC
mdefine_line|#define&t;GENERIC&t;&t;/* let probe() bind using module params */
multiline_comment|/* Some devices that can be used for testing will have &quot;real&quot; drivers.&n; * Entries for those need to be enabled here by hand, after disabling&n; * that &quot;real&quot; driver.&n; */
singleline_comment|//#define&t;IBOT2&t;&t;/* grab iBOT2 webcams */
singleline_comment|//#define&t;KEYSPAN_19Qi&t;/* grab un-renumerated serial adapter */
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|struct|usbtest_info
r_struct
id|usbtest_info
(brace
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|ep_in
id|u8
id|ep_in
suffix:semicolon
multiline_comment|/* bulk/intr source */
DECL|member|ep_out
id|u8
id|ep_out
suffix:semicolon
multiline_comment|/* bulk/intr sink */
DECL|member|alt
r_int
id|alt
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* this is accessed only through usbfs ioctl calls.&n; * one ioctl to issue a test ... one lock per device.&n; * tests create other threads if they need them.&n; * urbs and buffers are allocated dynamically,&n; * and data generated deterministically.&n; */
DECL|struct|usbtest_dev
r_struct
id|usbtest_dev
(brace
DECL|member|intf
r_struct
id|usb_interface
op_star
id|intf
suffix:semicolon
DECL|member|info
r_struct
id|usbtest_info
op_star
id|info
suffix:semicolon
DECL|member|id
r_char
id|id
(braket
l_int|32
)braket
suffix:semicolon
DECL|member|in_pipe
r_int
id|in_pipe
suffix:semicolon
DECL|member|out_pipe
r_int
id|out_pipe
suffix:semicolon
DECL|member|sem
r_struct
id|semaphore
id|sem
suffix:semicolon
DECL|macro|TBUF_SIZE
mdefine_line|#define TBUF_SIZE&t;256
DECL|member|buf
id|u8
op_star
id|buf
suffix:semicolon
)brace
suffix:semicolon
DECL|function|testdev_to_usbdev
r_static
r_struct
id|usb_device
op_star
id|testdev_to_usbdev
(paren
r_struct
id|usbtest_dev
op_star
id|test
)paren
(brace
r_return
id|interface_to_usbdev
(paren
id|test-&gt;intf
)paren
suffix:semicolon
)brace
multiline_comment|/* set up all urbs so they can be used with either bulk or interrupt */
DECL|macro|INTERRUPT_RATE
mdefine_line|#define&t;INTERRUPT_RATE&t;&t;1&t;/* msec/transfer */
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* Support for testing basic non-queued I/O streams.&n; *&n; * These just package urbs as requests that can be easily canceled.&n; * Each urb&squot;s data buffer is dynamically allocated; callers can fill&n; * them with non-zero test data (or test for it) when appropriate.&n; */
DECL|function|simple_callback
r_static
r_void
id|simple_callback
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
id|complete
(paren
(paren
r_struct
id|completion
op_star
)paren
id|urb-&gt;context
)paren
suffix:semicolon
)brace
DECL|function|simple_alloc_urb
r_static
r_struct
id|urb
op_star
id|simple_alloc_urb
(paren
r_struct
id|usb_device
op_star
id|udev
comma
r_int
id|pipe
comma
r_int
id|bytes
)paren
(brace
r_struct
id|urb
op_star
id|urb
suffix:semicolon
r_if
c_cond
(paren
id|bytes
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|urb
op_assign
id|usb_alloc_urb
(paren
l_int|0
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
r_return
id|urb
suffix:semicolon
id|usb_fill_bulk_urb
(paren
id|urb
comma
id|udev
comma
id|pipe
comma
l_int|0
comma
id|bytes
comma
id|simple_callback
comma
l_int|0
)paren
suffix:semicolon
id|urb-&gt;interval
op_assign
(paren
id|udev-&gt;speed
op_eq
id|USB_SPEED_HIGH
)paren
ques
c_cond
(paren
id|INTERRUPT_RATE
op_lshift
l_int|3
)paren
suffix:colon
id|INTERRUPT_RATE
suffix:semicolon
id|urb-&gt;transfer_flags
op_assign
id|URB_NO_DMA_MAP
suffix:semicolon
r_if
c_cond
(paren
id|usb_pipein
(paren
id|pipe
)paren
)paren
id|urb-&gt;transfer_flags
op_or_assign
id|URB_SHORT_NOT_OK
suffix:semicolon
id|urb-&gt;transfer_buffer
op_assign
id|usb_buffer_alloc
(paren
id|udev
comma
id|bytes
comma
id|SLAB_KERNEL
comma
op_amp
id|urb-&gt;transfer_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb-&gt;transfer_buffer
)paren
(brace
id|usb_free_urb
(paren
id|urb
)paren
suffix:semicolon
id|urb
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|memset
(paren
id|urb-&gt;transfer_buffer
comma
l_int|0
comma
id|bytes
)paren
suffix:semicolon
r_return
id|urb
suffix:semicolon
)brace
DECL|function|simple_free_urb
r_static
r_void
id|simple_free_urb
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
id|usb_buffer_free
(paren
id|urb-&gt;dev
comma
id|urb-&gt;transfer_buffer_length
comma
id|urb-&gt;transfer_buffer
comma
id|urb-&gt;transfer_dma
)paren
suffix:semicolon
id|usb_free_urb
(paren
id|urb
)paren
suffix:semicolon
)brace
DECL|function|simple_io
r_static
r_int
id|simple_io
(paren
r_struct
id|urb
op_star
id|urb
comma
r_int
id|iterations
comma
r_int
id|vary
)paren
(brace
r_struct
id|usb_device
op_star
id|udev
op_assign
id|urb-&gt;dev
suffix:semicolon
r_int
id|max
op_assign
id|urb-&gt;transfer_buffer_length
suffix:semicolon
r_struct
id|completion
id|completion
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
id|urb-&gt;context
op_assign
op_amp
id|completion
suffix:semicolon
r_while
c_loop
(paren
id|retval
op_eq
l_int|0
op_logical_and
id|iterations
op_decrement
OG
l_int|0
)paren
(brace
id|init_completion
(paren
op_amp
id|completion
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|usb_submit_urb
(paren
id|urb
comma
id|SLAB_KERNEL
)paren
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* NOTE:  no timeouts; can&squot;t be broken out of by interrupt */
id|wait_for_completion
(paren
op_amp
id|completion
)paren
suffix:semicolon
id|retval
op_assign
id|urb-&gt;status
suffix:semicolon
id|urb-&gt;dev
op_assign
id|udev
suffix:semicolon
r_if
c_cond
(paren
id|vary
)paren
(brace
r_int
id|len
op_assign
id|urb-&gt;transfer_buffer_length
suffix:semicolon
id|len
op_add_assign
id|vary
suffix:semicolon
id|len
op_mod_assign
id|max
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|0
)paren
id|len
op_assign
(paren
id|vary
OL
id|max
)paren
ques
c_cond
id|vary
suffix:colon
id|max
suffix:semicolon
id|urb-&gt;transfer_buffer_length
op_assign
id|len
suffix:semicolon
)brace
multiline_comment|/* FIXME if endpoint halted, clear halt (and log) */
)brace
id|urb-&gt;transfer_buffer_length
op_assign
id|max
suffix:semicolon
singleline_comment|// FIXME for unlink or fault handling tests, don&squot;t report
singleline_comment|// failure if retval is as we expected ...
r_if
c_cond
(paren
id|retval
)paren
id|dbg
(paren
l_string|&quot;simple_io failed, iterations left %d, status %d&quot;
comma
id|iterations
comma
id|retval
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* We use scatterlist primitives to test queued I/O.&n; * Yes, this also tests the scatterlist primitives.&n; */
DECL|function|free_sglist
r_static
r_void
id|free_sglist
(paren
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sg
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nents
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sg
(braket
id|i
)braket
dot
id|page
)paren
r_continue
suffix:semicolon
id|kfree
(paren
id|page_address
(paren
id|sg
(braket
id|i
)braket
dot
id|page
)paren
op_plus
id|sg
(braket
id|i
)braket
dot
id|offset
)paren
suffix:semicolon
)brace
id|kfree
(paren
id|sg
)paren
suffix:semicolon
)brace
r_static
r_struct
id|scatterlist
op_star
DECL|function|alloc_sglist
id|alloc_sglist
(paren
r_int
id|nents
comma
r_int
id|max
comma
r_int
id|vary
)paren
(brace
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|size
op_assign
id|max
suffix:semicolon
id|sg
op_assign
id|kmalloc
(paren
id|nents
op_star
r_sizeof
op_star
id|sg
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sg
)paren
r_return
l_int|0
suffix:semicolon
id|memset
(paren
id|sg
comma
l_int|0
comma
id|nents
op_star
r_sizeof
op_star
id|sg
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nents
suffix:semicolon
id|i
op_increment
)paren
(brace
r_char
op_star
id|buf
suffix:semicolon
id|buf
op_assign
id|kmalloc
(paren
id|size
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
(brace
id|free_sglist
(paren
id|sg
comma
id|i
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|memset
(paren
id|buf
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* kmalloc pages are always physically contiguous! */
id|sg
(braket
id|i
)braket
dot
id|page
op_assign
id|virt_to_page
(paren
id|buf
)paren
suffix:semicolon
id|sg
(braket
id|i
)braket
dot
id|offset
op_assign
(paren
(paren
r_int
)paren
id|buf
)paren
op_amp
op_complement
id|PAGE_MASK
suffix:semicolon
id|sg
(braket
id|i
)braket
dot
id|length
op_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|vary
)paren
(brace
id|size
op_add_assign
id|vary
suffix:semicolon
id|size
op_mod_assign
id|max
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
id|size
op_assign
(paren
id|vary
OL
id|max
)paren
ques
c_cond
id|vary
suffix:colon
id|max
suffix:semicolon
)brace
)brace
r_return
id|sg
suffix:semicolon
)brace
DECL|function|perform_sglist
r_static
r_int
id|perform_sglist
(paren
r_struct
id|usb_device
op_star
id|udev
comma
r_int
id|iterations
comma
r_int
id|pipe
comma
r_struct
id|usb_sg_request
op_star
id|req
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
id|nents
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|retval
op_eq
l_int|0
op_logical_and
id|iterations
op_decrement
OG
l_int|0
)paren
(brace
id|retval
op_assign
id|usb_sg_init
(paren
id|req
comma
id|udev
comma
id|pipe
comma
(paren
id|udev-&gt;speed
op_eq
id|USB_SPEED_HIGH
)paren
ques
c_cond
(paren
id|INTERRUPT_RATE
op_lshift
l_int|3
)paren
suffix:colon
id|INTERRUPT_RATE
comma
id|sg
comma
id|nents
comma
l_int|0
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_break
suffix:semicolon
id|usb_sg_wait
(paren
id|req
)paren
suffix:semicolon
id|retval
op_assign
id|req-&gt;status
suffix:semicolon
multiline_comment|/* FIXME if endpoint halted, clear halt (and log) */
)brace
singleline_comment|// FIXME for unlink or fault handling tests, don&squot;t report
singleline_comment|// failure if retval is as we expected ...
r_if
c_cond
(paren
id|retval
)paren
id|dbg
(paren
l_string|&quot;perform_sglist failed, iterations left %d, status %d&quot;
comma
id|iterations
comma
id|retval
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* unqueued control message testing&n; *&n; * there&squot;s a nice set of device functional requirements in chapter 9 of the&n; * usb 2.0 spec, which we can apply to ANY device, even ones that don&squot;t use&n; * special test firmware.&n; *&n; * we know the device is configured (or suspended) by the time it&squot;s visible&n; * through usbfs.  we can&squot;t change that, so we won&squot;t test enumeration (which&n; * worked &squot;well enough&squot; to get here, this time), power management (ditto),&n; * or remote wakeup (which needs human interaction).&n; */
DECL|variable|realworld
r_static
r_int
id|realworld
op_assign
l_int|1
suffix:semicolon
id|MODULE_PARM
(paren
id|realworld
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
(paren
id|realworld
comma
l_string|&quot;clear to demand stricter ch9 compliance&quot;
)paren
suffix:semicolon
DECL|function|get_altsetting
r_static
r_int
id|get_altsetting
(paren
r_struct
id|usbtest_dev
op_star
id|dev
)paren
(brace
r_struct
id|usb_interface
op_star
id|iface
op_assign
id|dev-&gt;intf
suffix:semicolon
r_struct
id|usb_device
op_star
id|udev
op_assign
id|interface_to_usbdev
(paren
id|iface
)paren
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|retval
op_assign
id|usb_control_msg
(paren
id|udev
comma
id|usb_rcvctrlpipe
(paren
id|udev
comma
l_int|0
)paren
comma
id|USB_REQ_GET_INTERFACE
comma
id|USB_DIR_IN
op_or
id|USB_RECIP_INTERFACE
comma
l_int|0
comma
id|iface-&gt;altsetting
(braket
l_int|0
)braket
dot
id|desc.bInterfaceNumber
comma
id|dev-&gt;buf
comma
l_int|1
comma
id|HZ
op_star
id|USB_CTRL_GET_TIMEOUT
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|retval
)paren
(brace
r_case
l_int|1
suffix:colon
r_return
id|dev-&gt;buf
(braket
l_int|0
)braket
suffix:semicolon
r_case
l_int|0
suffix:colon
id|retval
op_assign
op_minus
id|ERANGE
suffix:semicolon
singleline_comment|// FALLTHROUGH
r_default
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
)brace
multiline_comment|/* this is usb_set_interface(), with no &squot;only one altsetting&squot; case */
DECL|function|set_altsetting
r_static
r_int
id|set_altsetting
(paren
r_struct
id|usbtest_dev
op_star
id|dev
comma
r_int
id|alternate
)paren
(brace
r_struct
id|usb_interface
op_star
id|iface
op_assign
id|dev-&gt;intf
suffix:semicolon
r_struct
id|usb_device
op_star
id|udev
suffix:semicolon
r_struct
id|usb_host_interface
op_star
id|iface_as
suffix:semicolon
r_int
id|i
comma
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|alternate
OL
l_int|0
op_logical_or
id|alternate
op_ge
id|iface-&gt;num_altsetting
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|udev
op_assign
id|interface_to_usbdev
(paren
id|iface
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|usb_control_msg
(paren
id|udev
comma
id|usb_sndctrlpipe
(paren
id|udev
comma
l_int|0
)paren
comma
id|USB_REQ_SET_INTERFACE
comma
id|USB_RECIP_INTERFACE
comma
id|alternate
comma
id|iface-&gt;altsetting-&gt;desc.bInterfaceNumber
comma
l_int|NULL
comma
l_int|0
comma
id|HZ
op_star
id|USB_CTRL_SET_TIMEOUT
)paren
)paren
OL
l_int|0
)paren
r_return
id|ret
suffix:semicolon
singleline_comment|// FIXME usbcore should be more like this:
singleline_comment|// - remove that special casing in usbcore.
singleline_comment|// - fix usbcore signature to take interface
multiline_comment|/* prevent requests using previous endpoint settings */
id|iface_as
op_assign
id|iface-&gt;altsetting
op_plus
id|iface-&gt;act_altsetting
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|iface_as-&gt;desc.bNumEndpoints
suffix:semicolon
id|i
op_increment
)paren
(brace
id|u8
id|ep
op_assign
id|iface_as-&gt;endpoint
(braket
id|i
)braket
dot
id|desc.bEndpointAddress
suffix:semicolon
r_int
id|out
op_assign
op_logical_neg
(paren
id|ep
op_amp
id|USB_DIR_IN
)paren
suffix:semicolon
id|ep
op_and_assign
id|USB_ENDPOINT_NUMBER_MASK
suffix:semicolon
(paren
id|out
ques
c_cond
id|udev-&gt;epmaxpacketout
suffix:colon
id|udev-&gt;epmaxpacketin
)paren
(braket
id|ep
)braket
op_assign
l_int|0
suffix:semicolon
singleline_comment|// FIXME want hcd hook here, &quot;forget this endpoint&quot;
)brace
id|iface-&gt;act_altsetting
op_assign
id|alternate
suffix:semicolon
multiline_comment|/* reset toggles and maxpacket for all endpoints affected */
id|iface_as
op_assign
id|iface-&gt;altsetting
op_plus
id|iface-&gt;act_altsetting
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|iface_as-&gt;desc.bNumEndpoints
suffix:semicolon
id|i
op_increment
)paren
(brace
id|u8
id|ep
op_assign
id|iface_as-&gt;endpoint
(braket
id|i
)braket
dot
id|desc.bEndpointAddress
suffix:semicolon
r_int
id|out
op_assign
op_logical_neg
(paren
id|ep
op_amp
id|USB_DIR_IN
)paren
suffix:semicolon
id|ep
op_and_assign
id|USB_ENDPOINT_NUMBER_MASK
suffix:semicolon
id|usb_settoggle
(paren
id|udev
comma
id|ep
comma
id|out
comma
l_int|0
)paren
suffix:semicolon
(paren
id|out
ques
c_cond
id|udev-&gt;epmaxpacketout
suffix:colon
id|udev-&gt;epmaxpacketin
)paren
(braket
id|ep
)braket
op_assign
id|iface_as-&gt;endpoint
(braket
id|i
)braket
dot
id|desc.wMaxPacketSize
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|is_good_config
r_static
r_int
id|is_good_config
(paren
r_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_struct
id|usb_config_descriptor
op_star
id|config
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
r_sizeof
op_star
id|config
)paren
r_return
l_int|0
suffix:semicolon
id|config
op_assign
(paren
r_struct
id|usb_config_descriptor
op_star
)paren
id|buf
suffix:semicolon
r_switch
c_cond
(paren
id|config-&gt;bDescriptorType
)paren
(brace
r_case
id|USB_DT_CONFIG
suffix:colon
r_case
id|USB_DT_OTHER_SPEED_CONFIG
suffix:colon
r_if
c_cond
(paren
id|config-&gt;bLength
op_ne
l_int|9
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* this bit &squot;must be 1&squot; but often isn&squot;t */
r_if
c_cond
(paren
op_logical_neg
id|realworld
op_logical_and
op_logical_neg
(paren
id|config-&gt;bmAttributes
op_amp
l_int|0x80
)paren
)paren
(brace
id|dbg
(paren
l_string|&quot;high bit of config attributes not set&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|config-&gt;bmAttributes
op_amp
l_int|0x1f
)paren
multiline_comment|/* reserved == 0 */
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
id|le32_to_cpus
(paren
op_amp
id|config-&gt;wTotalLength
)paren
suffix:semicolon
r_if
c_cond
(paren
id|config-&gt;wTotalLength
op_eq
id|len
)paren
multiline_comment|/* read it all */
r_return
l_int|1
suffix:semicolon
r_return
id|config-&gt;wTotalLength
op_ge
id|TBUF_SIZE
suffix:semicolon
multiline_comment|/* max partial read */
)brace
multiline_comment|/* sanity test for standard requests working with usb_control_mesg() and some&n; * of the utility functions which use it.&n; *&n; * this doesn&squot;t test how endpoint halts behave or data toggles get set, since&n; * we won&squot;t do I/O to bulk/interrupt endpoints here (which is how to change&n; * halt or toggle).  toggle testing is impractical without support from hcds.&n; *&n; * this avoids failing devices linux would normally work with, by not testing&n; * config/altsetting operations for devices that only support their defaults.&n; * such devices rarely support those needless operations.&n; *&n; * NOTE that since this is a sanity test, it&squot;s not examining boundary cases&n; * to see if usbcore, hcd, and device all behave right.  such testing would&n; * involve varied read sizes and other operation sequences.&n; */
DECL|function|ch9_postconfig
r_static
r_int
id|ch9_postconfig
(paren
r_struct
id|usbtest_dev
op_star
id|dev
)paren
(brace
r_struct
id|usb_interface
op_star
id|iface
op_assign
id|dev-&gt;intf
suffix:semicolon
r_struct
id|usb_device
op_star
id|udev
op_assign
id|interface_to_usbdev
(paren
id|iface
)paren
suffix:semicolon
r_int
id|i
comma
id|retval
suffix:semicolon
multiline_comment|/* [9.2.3] if there&squot;s more than one altsetting, we need to be able to&n;&t; * set and get each one.  mostly trusts the descriptors from usbcore.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|iface-&gt;num_altsetting
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* 9.2.3 constrains the range here, and Linux ensures&n;&t;&t; * they&squot;re ordered meaningfully in this array&n;&t;&t; */
r_if
c_cond
(paren
id|iface-&gt;altsetting
(braket
id|i
)braket
dot
id|desc.bAlternateSetting
op_ne
id|i
)paren
(brace
id|dbg
(paren
l_string|&quot;%s, illegal alt [%d].bAltSetting = %d&quot;
comma
id|dev-&gt;id
comma
id|i
comma
id|iface-&gt;altsetting
(braket
id|i
)braket
dot
id|desc
dot
id|bAlternateSetting
)paren
suffix:semicolon
r_return
op_minus
id|EDOM
suffix:semicolon
)brace
multiline_comment|/* [real world] get/set unimplemented if there&squot;s only one */
r_if
c_cond
(paren
id|realworld
op_logical_and
id|iface-&gt;num_altsetting
op_eq
l_int|1
)paren
r_continue
suffix:semicolon
multiline_comment|/* [9.4.10] set_interface */
id|retval
op_assign
id|set_altsetting
(paren
id|dev
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|dbg
(paren
l_string|&quot;%s can&squot;t set_interface = %d, %d&quot;
comma
id|dev-&gt;id
comma
id|i
comma
id|retval
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* [9.4.4] get_interface always works */
id|retval
op_assign
id|get_altsetting
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
id|i
)paren
(brace
id|dbg
(paren
l_string|&quot;%s get alt should be %d, was %d&quot;
comma
id|dev-&gt;id
comma
id|i
comma
id|retval
)paren
suffix:semicolon
r_return
(paren
id|retval
OL
l_int|0
)paren
ques
c_cond
id|retval
suffix:colon
op_minus
id|EDOM
suffix:semicolon
)brace
)brace
multiline_comment|/* [real world] get_config unimplemented if there&squot;s only one */
r_if
c_cond
(paren
op_logical_neg
id|realworld
op_logical_or
id|udev-&gt;descriptor.bNumConfigurations
op_ne
l_int|1
)paren
(brace
r_int
id|expected
op_assign
id|udev-&gt;actconfig-&gt;desc.bConfigurationValue
suffix:semicolon
multiline_comment|/* [9.4.2] get_configuration always works&n;&t;&t; * ... although some cheap devices (like one TI Hub I&squot;ve got)&n;&t;&t; * won&squot;t return config descriptors except before set_config.&n;&t;&t; */
id|retval
op_assign
id|usb_control_msg
(paren
id|udev
comma
id|usb_rcvctrlpipe
(paren
id|udev
comma
l_int|0
)paren
comma
id|USB_REQ_GET_CONFIGURATION
comma
id|USB_DIR_IN
op_or
id|USB_RECIP_DEVICE
comma
l_int|0
comma
l_int|0
comma
id|dev-&gt;buf
comma
l_int|1
comma
id|HZ
op_star
id|USB_CTRL_GET_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
l_int|1
op_logical_or
id|dev-&gt;buf
(braket
l_int|0
)braket
op_ne
id|expected
)paren
(brace
id|dbg
(paren
l_string|&quot;%s get config --&gt; %d (%d)&quot;
comma
id|dev-&gt;id
comma
id|retval
comma
id|expected
)paren
suffix:semicolon
r_return
(paren
id|retval
OL
l_int|0
)paren
ques
c_cond
id|retval
suffix:colon
op_minus
id|EDOM
suffix:semicolon
)brace
)brace
multiline_comment|/* there&squot;s always [9.4.3] a device descriptor [9.6.1] */
id|retval
op_assign
id|usb_get_descriptor
(paren
id|udev
comma
id|USB_DT_DEVICE
comma
l_int|0
comma
id|dev-&gt;buf
comma
r_sizeof
id|udev-&gt;descriptor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
r_sizeof
id|udev-&gt;descriptor
)paren
(brace
id|dbg
(paren
l_string|&quot;%s dev descriptor --&gt; %d&quot;
comma
id|dev-&gt;id
comma
id|retval
)paren
suffix:semicolon
r_return
(paren
id|retval
OL
l_int|0
)paren
ques
c_cond
id|retval
suffix:colon
op_minus
id|EDOM
suffix:semicolon
)brace
multiline_comment|/* there&squot;s always [9.4.3] at least one config descriptor [9.6.3] */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|udev-&gt;descriptor.bNumConfigurations
suffix:semicolon
id|i
op_increment
)paren
(brace
id|retval
op_assign
id|usb_get_descriptor
(paren
id|udev
comma
id|USB_DT_CONFIG
comma
id|i
comma
id|dev-&gt;buf
comma
id|TBUF_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_good_config
(paren
id|dev-&gt;buf
comma
id|retval
)paren
)paren
(brace
id|dbg
(paren
l_string|&quot;%s config [%d] descriptor --&gt; %d&quot;
comma
id|dev-&gt;id
comma
id|i
comma
id|retval
)paren
suffix:semicolon
r_return
(paren
id|retval
OL
l_int|0
)paren
ques
c_cond
id|retval
suffix:colon
op_minus
id|EDOM
suffix:semicolon
)brace
singleline_comment|// FIXME cross-checking udev-&gt;config[i] to make sure usbcore
singleline_comment|// parsed it right (etc) would be good testing paranoia
)brace
multiline_comment|/* and sometimes [9.2.6.6] speed dependent descriptors */
r_if
c_cond
(paren
id|udev-&gt;descriptor.bcdUSB
op_eq
l_int|0x0200
)paren
(brace
multiline_comment|/* pre-swapped */
r_struct
id|usb_qualifier_descriptor
op_star
id|d
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* device qualifier [9.6.2] */
id|retval
op_assign
id|usb_get_descriptor
(paren
id|udev
comma
id|USB_DT_DEVICE_QUALIFIER
comma
l_int|0
comma
id|dev-&gt;buf
comma
r_sizeof
(paren
r_struct
id|usb_qualifier_descriptor
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
op_minus
id|EPIPE
)paren
(brace
r_if
c_cond
(paren
id|udev-&gt;speed
op_eq
id|USB_SPEED_HIGH
)paren
(brace
id|dbg
(paren
l_string|&quot;%s hs dev qualifier --&gt; %d&quot;
comma
id|dev-&gt;id
comma
id|retval
)paren
suffix:semicolon
r_return
(paren
id|retval
OL
l_int|0
)paren
ques
c_cond
id|retval
suffix:colon
op_minus
id|EDOM
suffix:semicolon
)brace
multiline_comment|/* usb2.0 but not high-speed capable; fine */
)brace
r_else
r_if
c_cond
(paren
id|retval
op_ne
r_sizeof
(paren
r_struct
id|usb_qualifier_descriptor
)paren
)paren
(brace
id|dbg
(paren
l_string|&quot;%s dev qualifier --&gt; %d&quot;
comma
id|dev-&gt;id
comma
id|retval
)paren
suffix:semicolon
r_return
(paren
id|retval
OL
l_int|0
)paren
ques
c_cond
id|retval
suffix:colon
op_minus
id|EDOM
suffix:semicolon
)brace
r_else
id|d
op_assign
(paren
r_struct
id|usb_qualifier_descriptor
op_star
)paren
id|dev-&gt;buf
suffix:semicolon
multiline_comment|/* might not have [9.6.2] any other-speed configs [9.6.4] */
r_if
c_cond
(paren
id|d
)paren
(brace
r_int
id|max
op_assign
id|d-&gt;bNumConfigurations
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max
suffix:semicolon
id|i
op_increment
)paren
(brace
id|retval
op_assign
id|usb_get_descriptor
(paren
id|udev
comma
id|USB_DT_OTHER_SPEED_CONFIG
comma
id|i
comma
id|dev-&gt;buf
comma
id|TBUF_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_good_config
(paren
id|dev-&gt;buf
comma
id|retval
)paren
)paren
(brace
id|dbg
(paren
l_string|&quot;%s other speed config --&gt; %d&quot;
comma
id|dev-&gt;id
comma
id|retval
)paren
suffix:semicolon
r_return
(paren
id|retval
OL
l_int|0
)paren
ques
c_cond
id|retval
suffix:colon
op_minus
id|EDOM
suffix:semicolon
)brace
)brace
)brace
)brace
singleline_comment|// FIXME fetch strings from at least the device descriptor
multiline_comment|/* [9.4.5] get_status always works */
id|retval
op_assign
id|usb_get_status
(paren
id|udev
comma
id|USB_RECIP_DEVICE
comma
l_int|0
comma
id|dev-&gt;buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
l_int|2
)paren
(brace
id|dbg
(paren
l_string|&quot;%s get dev status --&gt; %d&quot;
comma
id|dev-&gt;id
comma
id|retval
)paren
suffix:semicolon
r_return
(paren
id|retval
OL
l_int|0
)paren
ques
c_cond
id|retval
suffix:colon
op_minus
id|EDOM
suffix:semicolon
)brace
singleline_comment|// FIXME configuration.bmAttributes says if we could try to set/clear
singleline_comment|// the device&squot;s remote wakeup feature ... if we can, test that here
id|retval
op_assign
id|usb_get_status
(paren
id|udev
comma
id|USB_RECIP_INTERFACE
comma
id|iface-&gt;altsetting
(braket
l_int|0
)braket
dot
id|desc.bInterfaceNumber
comma
id|dev-&gt;buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
l_int|2
)paren
(brace
id|dbg
(paren
l_string|&quot;%s get interface status --&gt; %d&quot;
comma
id|dev-&gt;id
comma
id|retval
)paren
suffix:semicolon
r_return
(paren
id|retval
OL
l_int|0
)paren
ques
c_cond
id|retval
suffix:colon
op_minus
id|EDOM
suffix:semicolon
)brace
singleline_comment|// FIXME get status for each endpoint in the interface
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
singleline_comment|// control queueing !!
multiline_comment|/*-------------------------------------------------------------------------*/
multiline_comment|/* We only have this one interface to user space, through usbfs.&n; * User mode code can scan usbfs to find N different devices (maybe on&n; * different busses) to use when testing, and allocate one thread per&n; * test.  So discovery is simplified, and we have no device naming issues.&n; *&n; * Don&squot;t use these only as stress/load tests.  Use them along with with&n; * other USB bus activity:  plugging, unplugging, mousing, mp3 playback,&n; * video capture, and so on.  Run different tests at different times, in&n; * different sequences.  Nothing here should interact with other devices,&n; * except indirectly by consuming USB bandwidth and CPU resources for test&n; * threads and request completion.&n; */
r_static
r_int
DECL|function|usbtest_ioctl
id|usbtest_ioctl
(paren
r_struct
id|usb_interface
op_star
id|intf
comma
r_int
r_int
id|code
comma
r_void
op_star
id|buf
)paren
(brace
r_struct
id|usbtest_dev
op_star
id|dev
op_assign
id|dev_get_drvdata
(paren
op_amp
id|intf-&gt;dev
)paren
suffix:semicolon
r_struct
id|usb_device
op_star
id|udev
op_assign
id|testdev_to_usbdev
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|usbtest_param
op_star
id|param
op_assign
id|buf
suffix:semicolon
r_int
id|retval
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_struct
id|urb
op_star
id|urb
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
r_struct
id|usb_sg_request
id|req
suffix:semicolon
r_struct
id|timeval
id|start
suffix:semicolon
r_int
id|i
suffix:semicolon
singleline_comment|// FIXME USBDEVFS_CONNECTINFO doesn&squot;t say how fast the device is.
r_if
c_cond
(paren
id|code
op_ne
id|USBTEST_REQUEST
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_if
c_cond
(paren
id|param-&gt;iterations
op_le
l_int|0
op_logical_or
id|param-&gt;length
OL
l_int|0
op_logical_or
id|param-&gt;sglen
OL
l_int|0
op_logical_or
id|param-&gt;vary
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|down_interruptible
(paren
op_amp
id|dev-&gt;sem
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
multiline_comment|/* some devices, like ez-usb default devices, need a non-default&n;&t; * altsetting to have any active endpoints.  some tests change&n;&t; * altsettings; force a default so most tests don&squot;t need to check.&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;info-&gt;alt
op_ge
l_int|0
)paren
(brace
r_int
id|res
suffix:semicolon
r_if
c_cond
(paren
id|intf-&gt;altsetting-&gt;desc.bInterfaceNumber
)paren
(brace
id|up
(paren
op_amp
id|dev-&gt;sem
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|res
op_assign
id|set_altsetting
(paren
id|dev
comma
id|dev-&gt;info-&gt;alt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
(brace
id|err
(paren
l_string|&quot;%s: set altsetting to %d failed, %d&quot;
comma
id|dev-&gt;id
comma
id|dev-&gt;info-&gt;alt
comma
id|res
)paren
suffix:semicolon
id|up
(paren
op_amp
id|dev-&gt;sem
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Just a bunch of test cases that every HCD is expected to handle.&n;&t; *&n;&t; * Some may need specific firmware, though it&squot;d be good to have&n;&t; * one firmware image to handle all the test cases.&n;&t; *&n;&t; * FIXME add more tests!  cancel requests, verify the data, control&n;&t; * queueing, concurrent read+write threads, and so on.&n;&t; */
id|do_gettimeofday
(paren
op_amp
id|start
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|param-&gt;test_num
)paren
(brace
r_case
l_int|0
suffix:colon
id|dbg
(paren
l_string|&quot;%s TEST 0:  NOP&quot;
comma
id|dev-&gt;id
)paren
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Simple non-queued bulk I/O tests */
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;out_pipe
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s TEST 1:  write %d bytes %u times&quot;
comma
id|dev-&gt;id
comma
id|param-&gt;length
comma
id|param-&gt;iterations
)paren
suffix:semicolon
id|urb
op_assign
id|simple_alloc_urb
(paren
id|udev
comma
id|dev-&gt;out_pipe
comma
id|param-&gt;length
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
(brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
singleline_comment|// FIRMWARE:  bulk sink (maybe accepts short writes)
id|retval
op_assign
id|simple_io
(paren
id|urb
comma
id|param-&gt;iterations
comma
l_int|0
)paren
suffix:semicolon
id|simple_free_urb
(paren
id|urb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;in_pipe
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s TEST 2:  read %d bytes %u times&quot;
comma
id|dev-&gt;id
comma
id|param-&gt;length
comma
id|param-&gt;iterations
)paren
suffix:semicolon
id|urb
op_assign
id|simple_alloc_urb
(paren
id|udev
comma
id|dev-&gt;in_pipe
comma
id|param-&gt;length
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
(brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
singleline_comment|// FIRMWARE:  bulk source (maybe generates short writes)
id|retval
op_assign
id|simple_io
(paren
id|urb
comma
id|param-&gt;iterations
comma
l_int|0
)paren
suffix:semicolon
id|simple_free_urb
(paren
id|urb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;out_pipe
op_eq
l_int|0
op_logical_or
id|param-&gt;vary
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s TEST 3:  write/%d 0..%d bytes %u times&quot;
comma
id|dev-&gt;id
comma
id|param-&gt;vary
comma
id|param-&gt;length
comma
id|param-&gt;iterations
)paren
suffix:semicolon
id|urb
op_assign
id|simple_alloc_urb
(paren
id|udev
comma
id|dev-&gt;out_pipe
comma
id|param-&gt;length
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
(brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
singleline_comment|// FIRMWARE:  bulk sink (maybe accepts short writes)
id|retval
op_assign
id|simple_io
(paren
id|urb
comma
id|param-&gt;iterations
comma
id|param-&gt;vary
)paren
suffix:semicolon
id|simple_free_urb
(paren
id|urb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;in_pipe
op_eq
l_int|0
op_logical_or
id|param-&gt;vary
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s TEST 4:  read/%d 0..%d bytes %u times&quot;
comma
id|dev-&gt;id
comma
id|param-&gt;vary
comma
id|param-&gt;length
comma
id|param-&gt;iterations
)paren
suffix:semicolon
id|urb
op_assign
id|simple_alloc_urb
(paren
id|udev
comma
id|dev-&gt;in_pipe
comma
id|param-&gt;length
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|urb
)paren
(brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
singleline_comment|// FIRMWARE:  bulk source (maybe generates short writes)
id|retval
op_assign
id|simple_io
(paren
id|urb
comma
id|param-&gt;iterations
comma
id|param-&gt;vary
)paren
suffix:semicolon
id|simple_free_urb
(paren
id|urb
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Queued bulk I/O tests */
r_case
l_int|5
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;out_pipe
op_eq
l_int|0
op_logical_or
id|param-&gt;sglen
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s TEST 5:  write %d sglists, %d entries of %d bytes&quot;
comma
id|dev-&gt;id
comma
id|param-&gt;iterations
comma
id|param-&gt;sglen
comma
id|param-&gt;length
)paren
suffix:semicolon
id|sg
op_assign
id|alloc_sglist
(paren
id|param-&gt;sglen
comma
id|param-&gt;length
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sg
)paren
(brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
singleline_comment|// FIRMWARE:  bulk sink (maybe accepts short writes)
id|retval
op_assign
id|perform_sglist
(paren
id|udev
comma
id|param-&gt;iterations
comma
id|dev-&gt;out_pipe
comma
op_amp
id|req
comma
id|sg
comma
id|param-&gt;sglen
)paren
suffix:semicolon
id|free_sglist
(paren
id|sg
comma
id|param-&gt;sglen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;in_pipe
op_eq
l_int|0
op_logical_or
id|param-&gt;sglen
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s TEST 6:  read %d sglists, %d entries of %d bytes&quot;
comma
id|dev-&gt;id
comma
id|param-&gt;iterations
comma
id|param-&gt;sglen
comma
id|param-&gt;length
)paren
suffix:semicolon
id|sg
op_assign
id|alloc_sglist
(paren
id|param-&gt;sglen
comma
id|param-&gt;length
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sg
)paren
(brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
singleline_comment|// FIRMWARE:  bulk source (maybe generates short writes)
id|retval
op_assign
id|perform_sglist
(paren
id|udev
comma
id|param-&gt;iterations
comma
id|dev-&gt;in_pipe
comma
op_amp
id|req
comma
id|sg
comma
id|param-&gt;sglen
)paren
suffix:semicolon
id|free_sglist
(paren
id|sg
comma
id|param-&gt;sglen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;out_pipe
op_eq
l_int|0
op_logical_or
id|param-&gt;sglen
op_eq
l_int|0
op_logical_or
id|param-&gt;vary
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s TEST 7:  write/%d %d sglists, %d entries 0..%d bytes&quot;
comma
id|dev-&gt;id
comma
id|param-&gt;vary
comma
id|param-&gt;iterations
comma
id|param-&gt;sglen
comma
id|param-&gt;length
)paren
suffix:semicolon
id|sg
op_assign
id|alloc_sglist
(paren
id|param-&gt;sglen
comma
id|param-&gt;length
comma
id|param-&gt;vary
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sg
)paren
(brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
singleline_comment|// FIRMWARE:  bulk sink (maybe accepts short writes)
id|retval
op_assign
id|perform_sglist
(paren
id|udev
comma
id|param-&gt;iterations
comma
id|dev-&gt;out_pipe
comma
op_amp
id|req
comma
id|sg
comma
id|param-&gt;sglen
)paren
suffix:semicolon
id|free_sglist
(paren
id|sg
comma
id|param-&gt;sglen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
r_if
c_cond
(paren
id|dev-&gt;in_pipe
op_eq
l_int|0
op_logical_or
id|param-&gt;sglen
op_eq
l_int|0
op_logical_or
id|param-&gt;vary
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s TEST 8:  read/%d %d sglists, %d entries 0..%d bytes&quot;
comma
id|dev-&gt;id
comma
id|param-&gt;vary
comma
id|param-&gt;iterations
comma
id|param-&gt;sglen
comma
id|param-&gt;length
)paren
suffix:semicolon
id|sg
op_assign
id|alloc_sglist
(paren
id|param-&gt;sglen
comma
id|param-&gt;length
comma
id|param-&gt;vary
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sg
)paren
(brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_break
suffix:semicolon
)brace
singleline_comment|// FIRMWARE:  bulk source (maybe generates short writes)
id|retval
op_assign
id|perform_sglist
(paren
id|udev
comma
id|param-&gt;iterations
comma
id|dev-&gt;in_pipe
comma
op_amp
id|req
comma
id|sg
comma
id|param-&gt;sglen
)paren
suffix:semicolon
id|free_sglist
(paren
id|sg
comma
id|param-&gt;sglen
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* non-queued sanity tests for control (chapter 9 subset) */
r_case
l_int|9
suffix:colon
id|retval
op_assign
l_int|0
suffix:semicolon
id|dbg
(paren
l_string|&quot;%s TEST 9:  ch9 (subset) control tests, %d times&quot;
comma
id|dev-&gt;id
comma
id|param-&gt;iterations
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|param-&gt;iterations
suffix:semicolon
id|retval
op_eq
l_int|0
op_logical_and
id|i
op_decrement
suffix:semicolon
multiline_comment|/* NOP */
)paren
id|retval
op_assign
id|ch9_postconfig
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
id|dbg
(paren
l_string|&quot;ch9 subset failed, iterations left %d&quot;
comma
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* test cases for the unlink/cancel codepaths need a thread to&n;&t; * usb_unlink_urb() or usg_sg_cancel(), and a way to check if&n;&t; * the urb/sg_request was properly canceled.&n;&t; *&n;&t; * for the unlink-queued cases, the usb_sg_*() code uses/tests&n;&t; * the &quot;streamed&quot; cleanup mode, not the &quot;packet&quot; one&n;&t; */
)brace
id|do_gettimeofday
(paren
op_amp
id|param-&gt;duration
)paren
suffix:semicolon
id|param-&gt;duration.tv_sec
op_sub_assign
id|start.tv_sec
suffix:semicolon
id|param-&gt;duration.tv_usec
op_sub_assign
id|start.tv_usec
suffix:semicolon
r_if
c_cond
(paren
id|param-&gt;duration.tv_usec
OL
l_int|0
)paren
(brace
id|param-&gt;duration.tv_usec
op_add_assign
l_int|1000
op_star
l_int|1000
suffix:semicolon
id|param-&gt;duration.tv_sec
op_sub_assign
l_int|1
suffix:semicolon
)brace
id|up
(paren
op_amp
id|dev-&gt;sem
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|variable|force_interrupt
r_static
r_int
id|force_interrupt
op_assign
l_int|0
suffix:semicolon
id|MODULE_PARM
(paren
id|force_interrupt
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
(paren
id|force_interrupt
comma
l_string|&quot;0 = test bulk (default), else interrupt&quot;
)paren
suffix:semicolon
macro_line|#ifdef&t;GENERIC
DECL|variable|vendor
r_static
r_int
id|vendor
suffix:semicolon
id|MODULE_PARM
(paren
id|vendor
comma
l_string|&quot;h&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
(paren
id|vendor
comma
l_string|&quot;vendor code (from usb-if)&quot;
)paren
suffix:semicolon
DECL|variable|product
r_static
r_int
id|product
suffix:semicolon
id|MODULE_PARM
(paren
id|product
comma
l_string|&quot;h&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
(paren
id|product
comma
l_string|&quot;product code (from vendor)&quot;
)paren
suffix:semicolon
macro_line|#endif
r_static
r_int
DECL|function|usbtest_probe
id|usbtest_probe
(paren
r_struct
id|usb_interface
op_star
id|intf
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
(brace
r_struct
id|usb_device
op_star
id|udev
suffix:semicolon
r_struct
id|usbtest_dev
op_star
id|dev
suffix:semicolon
r_struct
id|usbtest_info
op_star
id|info
suffix:semicolon
r_char
op_star
id|rtest
comma
op_star
id|wtest
suffix:semicolon
id|udev
op_assign
id|interface_to_usbdev
(paren
id|intf
)paren
suffix:semicolon
macro_line|#ifdef&t;GENERIC
multiline_comment|/* specify devices by module parameters? */
r_if
c_cond
(paren
id|id-&gt;match_flags
op_eq
l_int|0
)paren
(brace
multiline_comment|/* vendor match required, product match optional */
r_if
c_cond
(paren
op_logical_neg
id|vendor
op_logical_or
id|udev-&gt;descriptor.idVendor
op_ne
(paren
id|u16
)paren
id|vendor
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|product
op_logical_and
id|udev-&gt;descriptor.idProduct
op_ne
(paren
id|u16
)paren
id|product
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|dbg
(paren
l_string|&quot;matched module params, vend=0x%04x prod=0x%04x&quot;
comma
id|udev-&gt;descriptor.idVendor
comma
id|udev-&gt;descriptor.idProduct
)paren
suffix:semicolon
)brace
macro_line|#endif
id|dev
op_assign
id|kmalloc
(paren
r_sizeof
op_star
id|dev
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
(paren
id|dev
comma
l_int|0
comma
r_sizeof
op_star
id|dev
)paren
suffix:semicolon
id|info
op_assign
(paren
r_struct
id|usbtest_info
op_star
)paren
id|id-&gt;driver_info
suffix:semicolon
id|dev-&gt;info
op_assign
id|info
suffix:semicolon
id|init_MUTEX
(paren
op_amp
id|dev-&gt;sem
)paren
suffix:semicolon
multiline_comment|/* use the same kind of id the hid driver shows */
id|snprintf
(paren
id|dev-&gt;id
comma
r_sizeof
id|dev-&gt;id
comma
l_string|&quot;%s-%s:%d&quot;
comma
id|udev-&gt;bus-&gt;bus_name
comma
id|udev-&gt;devpath
comma
id|intf-&gt;altsetting
(braket
l_int|0
)braket
dot
id|desc.bInterfaceNumber
)paren
suffix:semicolon
id|dev-&gt;intf
op_assign
id|intf
suffix:semicolon
multiline_comment|/* cacheline-aligned scratch for i/o */
r_if
c_cond
(paren
(paren
id|dev-&gt;buf
op_assign
id|kmalloc
(paren
id|TBUF_SIZE
comma
id|SLAB_KERNEL
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|kfree
(paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* NOTE this doesn&squot;t yet test the handful of difference that are&n;&t; * visible with high speed interrupts:  bigger maxpacket (1K) and&n;&t; * &quot;high bandwidth&quot; modes (up to 3 packets/uframe).&n;&t; */
id|rtest
op_assign
id|wtest
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_if
c_cond
(paren
id|force_interrupt
op_logical_or
id|udev-&gt;speed
op_eq
id|USB_SPEED_LOW
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;ep_in
)paren
(brace
id|dev-&gt;in_pipe
op_assign
id|usb_rcvintpipe
(paren
id|udev
comma
id|info-&gt;ep_in
)paren
suffix:semicolon
id|rtest
op_assign
l_string|&quot; intr-in&quot;
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;ep_out
)paren
(brace
id|dev-&gt;out_pipe
op_assign
id|usb_sndintpipe
(paren
id|udev
comma
id|info-&gt;ep_out
)paren
suffix:semicolon
id|wtest
op_assign
l_string|&quot; intr-out&quot;
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|info-&gt;ep_in
)paren
(brace
id|dev-&gt;in_pipe
op_assign
id|usb_rcvbulkpipe
(paren
id|udev
comma
id|info-&gt;ep_in
)paren
suffix:semicolon
id|rtest
op_assign
l_string|&quot; bulk-in&quot;
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;ep_out
)paren
(brace
id|dev-&gt;out_pipe
op_assign
id|usb_sndbulkpipe
(paren
id|udev
comma
id|info-&gt;ep_out
)paren
suffix:semicolon
id|wtest
op_assign
l_string|&quot; bulk-out&quot;
suffix:semicolon
)brace
)brace
id|dev_set_drvdata
(paren
op_amp
id|intf-&gt;dev
comma
id|dev
)paren
suffix:semicolon
id|info
(paren
l_string|&quot;%s at %s ... %s speed {control%s%s} tests&quot;
comma
id|info-&gt;name
comma
id|dev-&gt;id
comma
(paren
(brace
r_char
op_star
id|tmp
suffix:semicolon
r_switch
(paren
id|udev-&gt;speed
)paren
(brace
r_case
id|USB_SPEED_LOW
suffix:colon
id|tmp
op_assign
l_string|&quot;low&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_SPEED_FULL
suffix:colon
id|tmp
op_assign
l_string|&quot;full&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_SPEED_HIGH
suffix:colon
id|tmp
op_assign
l_string|&quot;high&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|tmp
op_assign
l_string|&quot;unknown&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|tmp
suffix:semicolon
)brace
)paren
comma
id|rtest
comma
id|wtest
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usbtest_disconnect
r_static
r_void
id|usbtest_disconnect
(paren
r_struct
id|usb_interface
op_star
id|intf
)paren
(brace
r_struct
id|usbtest_dev
op_star
id|dev
op_assign
id|dev_get_drvdata
(paren
op_amp
id|intf-&gt;dev
)paren
suffix:semicolon
id|down
(paren
op_amp
id|dev-&gt;sem
)paren
suffix:semicolon
id|dev_set_drvdata
(paren
op_amp
id|intf-&gt;dev
comma
l_int|0
)paren
suffix:semicolon
id|info
(paren
l_string|&quot;unbound %s&quot;
comma
id|dev-&gt;id
)paren
suffix:semicolon
id|kfree
(paren
id|intf-&gt;private_data
)paren
suffix:semicolon
)brace
multiline_comment|/* Basic testing only needs a device that can source or sink bulk traffic.&n; * Any device can test control transfers (default with GENERIC binding).&n; *&n; * Several entries work with the default EP0 implementation that&squot;s built&n; * into EZ-USB chips.  There&squot;s a default vendor ID which can be overridden&n; * by (very) small config EEPROMS, but otherwise all these devices act&n; * identically until firmware is loaded:  only EP0 works.  It turns out&n; * to be easy to make other endpoints work, without modifying that EP0&n; * behavior.  For now, we expect that kind of firmware.&n; */
multiline_comment|/* an21xx or fx versions of ez-usb */
DECL|variable|ez1_info
r_static
r_struct
id|usbtest_info
id|ez1_info
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;EZ-USB device&quot;
comma
dot
id|ep_in
op_assign
l_int|2
comma
dot
id|ep_out
op_assign
l_int|2
comma
dot
id|alt
op_assign
l_int|1
comma
)brace
suffix:semicolon
multiline_comment|/* fx2 version of ez-usb */
DECL|variable|ez2_info
r_static
r_struct
id|usbtest_info
id|ez2_info
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;FX2 device&quot;
comma
dot
id|ep_in
op_assign
l_int|6
comma
dot
id|ep_out
op_assign
l_int|2
comma
dot
id|alt
op_assign
l_int|1
comma
)brace
suffix:semicolon
multiline_comment|/* ezusb family device with dedicated usb test firmware*/
DECL|variable|fw_info
r_static
r_struct
id|usbtest_info
id|fw_info
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;usb test device&quot;
comma
dot
id|ep_in
op_assign
l_int|2
comma
dot
id|ep_out
op_assign
l_int|2
comma
dot
id|alt
op_assign
l_int|0
comma
)brace
suffix:semicolon
macro_line|#ifdef IBOT2
multiline_comment|/* this is a nice source of high speed bulk data;&n; * uses an FX2, with firmware provided in the device&n; */
DECL|variable|ibot2_info
r_static
r_struct
id|usbtest_info
id|ibot2_info
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;iBOT2 webcam&quot;
comma
dot
id|ep_in
op_assign
l_int|2
comma
dot
id|alt
op_assign
op_minus
l_int|1
comma
)brace
suffix:semicolon
macro_line|#endif
macro_line|#ifdef GENERIC
multiline_comment|/* we can use any device to test control traffic */
DECL|variable|generic_info
r_static
r_struct
id|usbtest_info
id|generic_info
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;Generic USB device&quot;
comma
dot
id|alt
op_assign
op_minus
l_int|1
comma
)brace
suffix:semicolon
macro_line|#endif
singleline_comment|// FIXME remove this 
DECL|variable|hact_info
r_static
r_struct
id|usbtest_info
id|hact_info
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;FX2/hact&quot;
comma
singleline_comment|//.ep_in&t;&t;= 6,
dot
id|ep_out
op_assign
l_int|2
comma
dot
id|alt
op_assign
op_minus
l_int|1
comma
)brace
suffix:semicolon
DECL|variable|id_table
r_static
r_struct
id|usb_device_id
id|id_table
(braket
)braket
op_assign
(brace
(brace
id|USB_DEVICE
(paren
l_int|0x0547
comma
l_int|0x1002
)paren
comma
dot
id|driver_info
op_assign
(paren
r_int
r_int
)paren
op_amp
id|hact_info
comma
)brace
comma
multiline_comment|/*-------------------------------------------------------------*/
multiline_comment|/* EZ-USB devices which download firmware to replace (or in our&n;&t; * case augment) the default device implementation.&n;&t; */
multiline_comment|/* generic EZ-USB FX controller */
(brace
id|USB_DEVICE
(paren
l_int|0x0547
comma
l_int|0x2235
)paren
comma
dot
id|driver_info
op_assign
(paren
r_int
r_int
)paren
op_amp
id|ez1_info
comma
)brace
comma
multiline_comment|/* CY3671 development board with EZ-USB FX */
(brace
id|USB_DEVICE
(paren
l_int|0x0547
comma
l_int|0x0080
)paren
comma
dot
id|driver_info
op_assign
(paren
r_int
r_int
)paren
op_amp
id|ez1_info
comma
)brace
comma
multiline_comment|/* generic EZ-USB FX2 controller (or development board) */
(brace
id|USB_DEVICE
(paren
l_int|0x04b4
comma
l_int|0x8613
)paren
comma
dot
id|driver_info
op_assign
(paren
r_int
r_int
)paren
op_amp
id|ez2_info
comma
)brace
comma
multiline_comment|/* re-enumerated usb test device firmware */
(brace
id|USB_DEVICE
(paren
l_int|0xfff0
comma
l_int|0xfff0
)paren
comma
dot
id|driver_info
op_assign
(paren
r_int
r_int
)paren
op_amp
id|fw_info
comma
)brace
comma
macro_line|#ifdef KEYSPAN_19Qi
multiline_comment|/* Keyspan 19qi uses an21xx (original EZ-USB) */
singleline_comment|// this does not coexist with the real Keyspan 19qi driver!
(brace
id|USB_DEVICE
(paren
l_int|0x06cd
comma
l_int|0x010b
)paren
comma
dot
id|driver_info
op_assign
(paren
r_int
r_int
)paren
op_amp
id|ez1_info
comma
)brace
comma
macro_line|#endif
multiline_comment|/*-------------------------------------------------------------*/
macro_line|#ifdef IBOT2
multiline_comment|/* iBOT2 makes a nice source of high speed bulk-in data */
singleline_comment|// this does not coexist with a real iBOT2 driver!
(brace
id|USB_DEVICE
(paren
l_int|0x0b62
comma
l_int|0x0059
)paren
comma
dot
id|driver_info
op_assign
(paren
r_int
r_int
)paren
op_amp
id|ibot2_info
comma
)brace
comma
macro_line|#endif
multiline_comment|/*-------------------------------------------------------------*/
macro_line|#ifdef GENERIC
multiline_comment|/* module params can specify devices to use for control tests */
(brace
dot
id|driver_info
op_assign
(paren
r_int
r_int
)paren
op_amp
id|generic_info
comma
)brace
comma
macro_line|#endif
multiline_comment|/*-------------------------------------------------------------*/
(brace
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
(paren
id|usb
comma
id|id_table
)paren
suffix:semicolon
DECL|variable|usbtest_driver
r_static
r_struct
id|usb_driver
id|usbtest_driver
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|name
op_assign
l_string|&quot;usbtest&quot;
comma
dot
id|id_table
op_assign
id|id_table
comma
dot
id|probe
op_assign
id|usbtest_probe
comma
dot
id|ioctl
op_assign
id|usbtest_ioctl
comma
dot
id|disconnect
op_assign
id|usbtest_disconnect
comma
)brace
suffix:semicolon
multiline_comment|/*-------------------------------------------------------------------------*/
DECL|function|usbtest_init
r_static
r_int
id|__init
id|usbtest_init
(paren
r_void
)paren
(brace
macro_line|#ifdef GENERIC
r_if
c_cond
(paren
id|vendor
)paren
id|dbg
(paren
l_string|&quot;params: vend=0x%04x prod=0x%04x&quot;
comma
id|vendor
comma
id|product
)paren
suffix:semicolon
macro_line|#endif
r_return
id|usb_register
(paren
op_amp
id|usbtest_driver
)paren
suffix:semicolon
)brace
DECL|variable|usbtest_init
id|module_init
(paren
id|usbtest_init
)paren
suffix:semicolon
DECL|function|usbtest_exit
r_static
r_void
id|__exit
id|usbtest_exit
(paren
r_void
)paren
(brace
id|usb_deregister
(paren
op_amp
id|usbtest_driver
)paren
suffix:semicolon
)brace
DECL|variable|usbtest_exit
id|module_exit
(paren
id|usbtest_exit
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
(paren
l_string|&quot;USB Core/HCD Testing Driver&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
