multiline_comment|/*&n; *      Tieman Voyager braille display USB driver.&n; *&n; *      Copyright 2001-2002 Stephane Dalton &lt;sdalton@videotron.ca&gt;&n; *                      and St&#xfffd;phane Doyon  &lt;s.doyon@videotron.ca&gt;&n; *            Maintained by St&#xfffd;phane Doyon  &lt;s.doyon@videotron.ca&gt;.&n; */
multiline_comment|/*&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
multiline_comment|/* History:&n; * 0.8 April 2002: Integration into the kernel tree.&n; * 0.7 October 2001: First public release as a module, distributed with&n; *     the BRLTTY package (beta versions around 2.99y).&n; */
DECL|macro|DRIVER_VERSION
mdefine_line|#define DRIVER_VERSION &quot;v0.8&quot;
DECL|macro|DATE
mdefine_line|#define DATE &quot;April 2002&quot;
DECL|macro|DRIVER_AUTHOR
mdefine_line|#define DRIVER_AUTHOR &bslash;&n;&t;&quot;Stephane Dalton &lt;sdalton@videotron.ca&gt; &quot; &bslash;&n;&t;&quot;and St&#xfffd;phane Doyon &lt;s.doyon@videotron.ca&gt;&quot;
DECL|macro|DRIVER_DESC
mdefine_line|#define DRIVER_DESC &quot;Tieman Voyager braille display USB driver for Linux 2.4&quot;
DECL|macro|DRIVER_SHORTDESC
mdefine_line|#define DRIVER_SHORTDESC &quot;Voyager&quot;
DECL|macro|BANNER
mdefine_line|#define BANNER &bslash;&n;&t;KERN_INFO DRIVER_SHORTDESC &quot; &quot; DRIVER_VERSION &quot; (&quot; DATE &quot;)&bslash;n&quot; &bslash;&n;&t;KERN_INFO &quot;   by &quot; DRIVER_AUTHOR &quot;&bslash;n&quot;
DECL|variable|longbanner
r_static
r_const
r_char
id|longbanner
(braket
)braket
op_assign
(brace
id|DRIVER_DESC
l_string|&quot;, &quot;
id|DRIVER_VERSION
l_string|&quot; (&quot;
id|DATE
l_string|&quot;), by &quot;
id|DRIVER_AUTHOR
)brace
suffix:semicolon
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/usb.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/brlvger.h&gt;
DECL|variable|DRIVER_AUTHOR
id|MODULE_AUTHOR
c_func
(paren
id|DRIVER_AUTHOR
)paren
suffix:semicolon
DECL|variable|DRIVER_DESC
id|MODULE_DESCRIPTION
c_func
(paren
id|DRIVER_DESC
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
multiline_comment|/* Module parameters */
DECL|variable|debug
r_static
r_int
id|debug
op_assign
l_int|1
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|debug
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|debug
comma
l_string|&quot;Debug level, 0-3&quot;
)paren
suffix:semicolon
DECL|variable|write_repeats
r_static
r_int
id|write_repeats
op_assign
l_int|2
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|write_repeats
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|write_repeats
comma
l_string|&quot;Hack: repetitions for command to &quot;
l_string|&quot;display braille pattern&quot;
)paren
suffix:semicolon
multiline_comment|/* to get rid of weird extra dots (perhaps only on&n;&t;&t;    early hardware versions?) */
DECL|variable|stall_tries
r_static
r_int
id|stall_tries
op_assign
l_int|3
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|stall_tries
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|stall_tries
comma
l_string|&quot;Hack: retransmits of stalled USB &quot;
l_string|&quot;control messages&quot;
)paren
suffix:semicolon
multiline_comment|/* broken early hardware versions? */
DECL|macro|BRLVGER_RAW_VOLTAGE
mdefine_line|#define BRLVGER_RAW_VOLTAGE 89
multiline_comment|/* from 0-&gt;300V to 255-&gt;200V, we are told 265V is normal operating voltage,&n;   but we don&squot;t know the scale. Assuming it is linear. */
DECL|variable|raw_voltage
r_static
r_int
id|raw_voltage
op_assign
id|BRLVGER_RAW_VOLTAGE
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|raw_voltage
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|raw_voltage
comma
l_string|&quot;Parameter for the call to SET_DISPLAY_VOLTAGE&quot;
)paren
suffix:semicolon
multiline_comment|/* protocol and display type defines */
DECL|macro|MAX_BRLVGER_CELLS
mdefine_line|#define MAX_BRLVGER_CELLS 72
DECL|macro|MAX_INTERRUPT_DATA
mdefine_line|#define MAX_INTERRUPT_DATA 8
multiline_comment|/* control message request types */
DECL|macro|BRLVGER_READ_REQ
mdefine_line|#define BRLVGER_READ_REQ 0xC2
DECL|macro|BRLVGER_WRITE_REQ
mdefine_line|#define BRLVGER_WRITE_REQ 0x42
multiline_comment|/* control message request codes */
DECL|macro|BRLVGER_SET_DISPLAY_ON
mdefine_line|#define BRLVGER_SET_DISPLAY_ON 0
DECL|macro|BRLVGER_SET_DISPLAY_VOLTAGE
mdefine_line|#define BRLVGER_SET_DISPLAY_VOLTAGE 1
DECL|macro|BRLVGER_GET_SERIAL
mdefine_line|#define BRLVGER_GET_SERIAL 3
DECL|macro|BRLVGER_GET_HWVERSION
mdefine_line|#define BRLVGER_GET_HWVERSION 4
DECL|macro|BRLVGER_GET_FWVERSION
mdefine_line|#define BRLVGER_GET_FWVERSION 5
DECL|macro|BRLVGER_GET_LENGTH
mdefine_line|#define BRLVGER_GET_LENGTH 6
DECL|macro|BRLVGER_SEND_BRAILLE
mdefine_line|#define BRLVGER_SEND_BRAILLE 7
DECL|macro|BRLVGER_BEEP
mdefine_line|#define BRLVGER_BEEP 9
macro_line|#if 0 /* not used and not sure they&squot;re working */
mdefine_line|#define BRLVGER_GET_DISPLAY_VOLTAGE 2
mdefine_line|#define BRLVGER_GET_CURRENT 8
macro_line|#endif
multiline_comment|/* Prototypes */
r_static
r_void
op_star
id|brlvger_probe
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|ifnum
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
suffix:semicolon
r_static
r_void
id|brlvger_disconnect
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_void
op_star
id|ptr
)paren
suffix:semicolon
r_static
r_int
id|brlvger_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
id|brlvger_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
id|ssize_t
id|brlvger_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|pos
)paren
suffix:semicolon
r_static
id|ssize_t
id|brlvger_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|unused_pos
)paren
suffix:semicolon
r_static
r_int
id|brlvger_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_int
id|brlvger_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
suffix:semicolon
r_static
id|loff_t
id|brlvger_llseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|loff_t
id|offset
comma
r_int
id|orig
)paren
suffix:semicolon
r_static
r_void
id|intr_callback
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
suffix:semicolon
r_struct
id|brlvger_priv
suffix:semicolon
r_static
r_int
id|brlvger_get_hw_version
c_func
(paren
r_struct
id|brlvger_priv
op_star
id|priv
comma
r_int
r_char
op_star
id|verbuf
)paren
suffix:semicolon
r_static
r_int
id|brlvger_get_fw_version
c_func
(paren
r_struct
id|brlvger_priv
op_star
id|priv
comma
r_int
r_char
op_star
id|buf
)paren
suffix:semicolon
r_static
r_int
id|brlvger_get_serial
c_func
(paren
r_struct
id|brlvger_priv
op_star
id|priv
comma
r_int
r_char
op_star
id|buf
)paren
suffix:semicolon
r_static
r_int
id|brlvger_get_display_length
c_func
(paren
r_struct
id|brlvger_priv
op_star
id|priv
)paren
suffix:semicolon
r_static
r_int
id|brlvger_set_display_on_off
c_func
(paren
r_struct
id|brlvger_priv
op_star
id|priv
comma
id|__u16
id|on
)paren
suffix:semicolon
r_static
r_int
id|brlvger_beep
c_func
(paren
r_struct
id|brlvger_priv
op_star
id|priv
comma
id|__u16
id|duration
)paren
suffix:semicolon
r_static
r_int
id|brlvger_set_display_voltage
c_func
(paren
r_struct
id|brlvger_priv
op_star
id|priv
comma
id|__u16
id|voltage
)paren
suffix:semicolon
r_static
r_int
id|mycontrolmsg
c_func
(paren
r_const
r_char
op_star
id|funcname
comma
r_struct
id|brlvger_priv
op_star
id|priv
comma
r_int
id|pipe_dir
comma
id|__u8
id|request
comma
id|__u8
id|requesttype
comma
id|__u16
id|value
comma
id|__u16
id|index
comma
r_void
op_star
id|data
comma
id|__u16
id|size
)paren
suffix:semicolon
DECL|macro|controlmsg
mdefine_line|#define controlmsg(priv,pipe_dir,a,b,c,d,e,f) &bslash;&n;     mycontrolmsg(__FUNCTION__, priv, pipe_dir, &bslash;&n;                  a,b,c,d,e,f)
DECL|macro|sndcontrolmsg
mdefine_line|#define sndcontrolmsg(priv,a,b,c,d,e,f) &bslash;&n;    controlmsg(priv, 0, a,b,c,d,e,f)
DECL|macro|rcvcontrolmsg
mdefine_line|#define rcvcontrolmsg(priv,a,b,c,d,e,f) &bslash;&n;    controlmsg(priv, USB_DIR_IN, a,b,c,d,e,f)
r_extern
id|devfs_handle_t
id|usb_devfs_handle
suffix:semicolon
multiline_comment|/* /dev/usb dir. */
multiline_comment|/* ----------------------------------------------------------------------- */
multiline_comment|/* Data */
multiline_comment|/* key event queue size */
DECL|macro|MAX_INTERRUPT_BUFFER
mdefine_line|#define MAX_INTERRUPT_BUFFER 10
multiline_comment|/* private state */
DECL|struct|brlvger_priv
r_struct
id|brlvger_priv
(brace
DECL|member|dev
r_struct
id|usb_device
op_star
id|dev
suffix:semicolon
multiline_comment|/* USB device handle */
DECL|member|in_interrupt
r_struct
id|usb_endpoint_descriptor
op_star
id|in_interrupt
suffix:semicolon
DECL|member|intr_urb
r_struct
id|urb
op_star
id|intr_urb
suffix:semicolon
DECL|member|devfs
id|devfs_handle_t
id|devfs
suffix:semicolon
DECL|member|subminor
r_int
id|subminor
suffix:semicolon
multiline_comment|/* which minor dev #? */
DECL|member|hwver
r_int
r_char
id|hwver
(braket
id|BRLVGER_HWVER_SIZE
)braket
suffix:semicolon
multiline_comment|/* hardware version */
DECL|member|fwver
r_int
r_char
id|fwver
(braket
id|BRLVGER_FWVER_SIZE
)braket
suffix:semicolon
multiline_comment|/* firmware version */
DECL|member|serialnum
r_int
r_char
id|serialnum
(braket
id|BRLVGER_SERIAL_SIZE
)braket
suffix:semicolon
DECL|member|llength
r_int
id|llength
suffix:semicolon
multiline_comment|/* logical length */
DECL|member|plength
r_int
id|plength
suffix:semicolon
multiline_comment|/* physical length */
DECL|member|obuf
id|__u8
id|obuf
(braket
id|MAX_BRLVGER_CELLS
)braket
suffix:semicolon
DECL|member|intr_buff
id|__u8
id|intr_buff
(braket
id|MAX_INTERRUPT_DATA
)braket
suffix:semicolon
DECL|member|event_queue
id|__u8
id|event_queue
(braket
id|MAX_INTERRUPT_BUFFER
)braket
(braket
id|MAX_INTERRUPT_DATA
)braket
suffix:semicolon
DECL|member|intr_idx
DECL|member|read_idx
id|atomic_t
id|intr_idx
comma
id|read_idx
suffix:semicolon
DECL|member|intr_idx_lock
id|spinlock_t
id|intr_idx_lock
suffix:semicolon
multiline_comment|/* protects intr_idx */
DECL|member|read_wait
id|wait_queue_head_t
id|read_wait
suffix:semicolon
DECL|member|opened
r_int
id|opened
suffix:semicolon
DECL|member|open_sem
r_struct
id|semaphore
id|open_sem
suffix:semicolon
multiline_comment|/* protects -&gt;opened */
DECL|member|dev_sem
r_struct
id|semaphore
id|dev_sem
suffix:semicolon
multiline_comment|/* protects -&gt;dev */
)brace
suffix:semicolon
multiline_comment|/* Globals */
multiline_comment|/* Table of connected devices, a different minor for each. */
DECL|variable|display_table
r_static
r_struct
id|brlvger_priv
op_star
id|display_table
(braket
id|MAX_NR_BRLVGER_DEVS
)braket
suffix:semicolon
multiline_comment|/* Mutex for the operation of removing a device from display_table */
r_static
id|DECLARE_MUTEX
c_func
(paren
id|disconnect_sem
)paren
suffix:semicolon
multiline_comment|/* For blocking open */
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|open_wait
)paren
suffix:semicolon
multiline_comment|/* Some print macros */
macro_line|#ifdef dbg
DECL|macro|dbg
macro_line|#undef dbg
macro_line|#endif
macro_line|#ifdef info
DECL|macro|info
macro_line|#undef info
macro_line|#endif
macro_line|#ifdef err
DECL|macro|err
macro_line|#undef err
macro_line|#endif
DECL|macro|info
mdefine_line|#define info(args...) &bslash;&n;    ({ printk(KERN_INFO &quot;Voyager: &quot; args); &bslash;&n;       printk(&quot;&bslash;n&quot;); })
DECL|macro|err
mdefine_line|#define err(args...) &bslash;&n;    ({ printk(KERN_ERR &quot;Voyager: &quot; args); &bslash;&n;       printk(&quot;&bslash;n&quot;); })
DECL|macro|dbgprint
mdefine_line|#define dbgprint(args...) &bslash;&n;    ({ printk(KERN_DEBUG &quot;Voyager: &quot; __FUNCTION__ &quot;: &quot; args); &bslash;&n;       printk(&quot;&bslash;n&quot;); })
DECL|macro|dbg
mdefine_line|#define dbg(args...) &bslash;&n;    ({ if(debug &gt;= 1) dbgprint(args); })
DECL|macro|dbg2
mdefine_line|#define dbg2(args...) &bslash;&n;    ({ if(debug &gt;= 2) dbgprint(args); })
DECL|macro|dbg3
mdefine_line|#define dbg3(args...) &bslash;&n;    ({ if(debug &gt;= 3) dbgprint(args); })
multiline_comment|/* ----------------------------------------------------------------------- */
multiline_comment|/* Driver registration */
DECL|variable|brlvger_ids
r_static
r_struct
id|usb_device_id
id|brlvger_ids
(braket
)braket
op_assign
(brace
(brace
id|USB_DEVICE
c_func
(paren
l_int|0x0798
comma
l_int|0x0001
)paren
)brace
comma
(brace
)brace
multiline_comment|/* Terminating entry */
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
(paren
id|usb
comma
id|brlvger_ids
)paren
suffix:semicolon
DECL|variable|brlvger_fops
r_static
r_struct
id|file_operations
id|brlvger_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|llseek
suffix:colon
id|brlvger_llseek
comma
id|read
suffix:colon
id|brlvger_read
comma
id|write
suffix:colon
id|brlvger_write
comma
id|ioctl
suffix:colon
id|brlvger_ioctl
comma
id|open
suffix:colon
id|brlvger_open
comma
id|release
suffix:colon
id|brlvger_release
comma
id|poll
suffix:colon
id|brlvger_poll
comma
)brace
suffix:semicolon
DECL|variable|brlvger_driver
r_static
r_struct
id|usb_driver
id|brlvger_driver
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|name
suffix:colon
l_string|&quot;brlvger&quot;
comma
id|probe
suffix:colon
id|brlvger_probe
comma
id|disconnect
suffix:colon
id|brlvger_disconnect
comma
id|fops
suffix:colon
op_amp
id|brlvger_fops
comma
id|minor
suffix:colon
id|BRLVGER_MINOR
comma
id|num_minors
suffix:colon
id|MAX_NR_BRLVGER_DEVS
comma
id|id_table
suffix:colon
id|brlvger_ids
comma
)brace
suffix:semicolon
r_static
r_int
DECL|function|brlvger_init
id|__init
id|brlvger_init
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
id|BANNER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stall_tries
OL
l_int|1
op_logical_or
id|write_repeats
OL
l_int|1
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|display_table
comma
l_int|0
comma
r_sizeof
(paren
id|display_table
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usb_register
c_func
(paren
op_amp
id|brlvger_driver
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;USB registration failed&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|brlvger_cleanup
id|__exit
id|brlvger_cleanup
(paren
r_void
)paren
(brace
id|usb_deregister
(paren
op_amp
id|brlvger_driver
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;Driver unregistered&quot;
)paren
suffix:semicolon
)brace
DECL|variable|brlvger_init
id|module_init
(paren
id|brlvger_init
)paren
suffix:semicolon
DECL|variable|brlvger_cleanup
id|module_exit
(paren
id|brlvger_cleanup
)paren
suffix:semicolon
multiline_comment|/* ----------------------------------------------------------------------- */
multiline_comment|/* Probe and disconnect functions */
r_static
r_void
op_star
DECL|function|brlvger_probe
id|brlvger_probe
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_int
id|ifnum
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
(brace
r_struct
id|brlvger_priv
op_star
id|priv
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|endpoint
suffix:semicolon
r_struct
id|usb_interface_descriptor
op_star
id|actifsettings
suffix:semicolon
multiline_comment|/* protects against reentrance: once we&squot;ve found a free slot&n;&t;   we reserve it.*/
r_static
id|DECLARE_MUTEX
c_func
(paren
id|reserve_sem
)paren
suffix:semicolon
r_char
id|devfs_name
(braket
l_int|16
)braket
suffix:semicolon
id|actifsettings
op_assign
id|dev-&gt;actconfig-&gt;interface-&gt;altsetting
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;descriptor.bNumConfigurations
op_ne
l_int|1
op_logical_or
id|dev-&gt;config-&gt;bNumInterfaces
op_ne
l_int|1
op_logical_or
id|actifsettings-&gt;bNumEndpoints
op_ne
l_int|1
)paren
(brace
id|err
(paren
l_string|&quot;Bogus braille display config info&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|endpoint
op_assign
id|actifsettings-&gt;endpoint
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|endpoint-&gt;bEndpointAddress
op_amp
l_int|0x80
)paren
op_logical_or
(paren
(paren
id|endpoint-&gt;bmAttributes
op_amp
l_int|3
)paren
op_ne
l_int|0x03
)paren
)paren
(brace
id|err
(paren
l_string|&quot;Bogus braille display config info, wrong endpoints&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|reserve_sem
)paren
suffix:semicolon
id|retval
op_assign
id|usb_register_dev
c_func
(paren
op_amp
id|brlvger_driver
comma
l_int|1
comma
op_amp
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
r_if
c_cond
(paren
id|retval
op_ne
op_minus
id|ENODEV
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Not able to get a minor for this device.&quot;
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_NR_BRLVGER_DEVS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|display_table
(braket
id|i
)braket
op_eq
l_int|NULL
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|MAX_NR_BRLVGER_DEVS
)paren
(brace
id|err
c_func
(paren
l_string|&quot;This driver cannot handle more than %d &quot;
l_string|&quot;braille displays&quot;
comma
id|MAX_NR_BRLVGER_DEVS
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|priv
op_assign
id|kmalloc
(paren
r_sizeof
op_star
id|priv
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;No more memory&quot;
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|memset
c_func
(paren
id|priv
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|priv
)paren
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|priv-&gt;intr_idx
comma
l_int|0
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|priv-&gt;read_idx
comma
id|MAX_INTERRUPT_BUFFER
op_minus
l_int|1
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|priv-&gt;intr_idx_lock
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|priv-&gt;read_wait
)paren
suffix:semicolon
multiline_comment|/* opened is memset&squot;ed to 0 */
id|init_MUTEX
c_func
(paren
op_amp
id|priv-&gt;open_sem
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|priv-&gt;dev_sem
)paren
suffix:semicolon
id|priv-&gt;subminor
op_assign
id|i
suffix:semicolon
multiline_comment|/* we found a interrupt in endpoint */
id|priv-&gt;in_interrupt
op_assign
id|endpoint
suffix:semicolon
id|priv-&gt;dev
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|brlvger_get_hw_version
c_func
(paren
id|priv
comma
id|priv-&gt;hwver
)paren
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Unable to get hardware version&quot;
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;Hw ver %d.%d&quot;
comma
id|priv-&gt;hwver
(braket
l_int|0
)braket
comma
id|priv-&gt;hwver
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|brlvger_get_fw_version
c_func
(paren
id|priv
comma
id|priv-&gt;fwver
)paren
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Unable to get firmware version&quot;
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;Fw ver: %s&quot;
comma
id|priv-&gt;fwver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|brlvger_get_serial
c_func
(paren
id|priv
comma
id|priv-&gt;serialnum
)paren
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Unable to get serial number&quot;
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;Serial number: %s&quot;
comma
id|priv-&gt;serialnum
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|priv-&gt;llength
op_assign
id|brlvger_get_display_length
c_func
(paren
id|priv
)paren
)paren
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Unable to get display length&quot;
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|priv-&gt;llength
)paren
(brace
r_case
l_int|48
suffix:colon
id|priv-&gt;plength
op_assign
l_int|44
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|72
suffix:colon
id|priv-&gt;plength
op_assign
l_int|70
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
c_func
(paren
l_string|&quot;Unsupported display length: %d&quot;
comma
id|priv-&gt;llength
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;Display length: %d&quot;
comma
id|priv-&gt;plength
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|devfs_name
comma
l_string|&quot;brlvger%d&quot;
comma
id|priv-&gt;subminor
)paren
suffix:semicolon
id|priv-&gt;devfs
op_assign
id|devfs_register
c_func
(paren
id|usb_devfs_handle
comma
id|devfs_name
comma
id|DEVFS_FL_DEFAULT
comma
id|USB_MAJOR
comma
id|BRLVGER_MINOR
op_plus
id|priv-&gt;subminor
comma
id|S_IFCHR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
op_or
id|S_IRGRP
op_or
id|S_IWGRP
comma
op_amp
id|brlvger_fops
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|priv-&gt;devfs
)paren
(brace
macro_line|#ifdef CONFIG_DEVFS_FS
id|err
c_func
(paren
l_string|&quot;devfs node registration failed&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
id|display_table
(braket
id|i
)braket
op_assign
id|priv
suffix:semicolon
id|info
c_func
(paren
l_string|&quot;Braille display %d is device major %d minor %d&quot;
comma
id|i
comma
id|USB_MAJOR
comma
id|BRLVGER_MINOR
op_plus
id|i
)paren
suffix:semicolon
multiline_comment|/* Tell anyone waiting on a blocking open */
id|wake_up_interruptible
c_func
(paren
op_amp
id|open_wait
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|error
suffix:colon
r_if
c_cond
(paren
id|priv
)paren
(brace
id|kfree
c_func
(paren
id|priv
)paren
suffix:semicolon
id|priv
op_assign
l_int|NULL
suffix:semicolon
)brace
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|reserve_sem
)paren
suffix:semicolon
r_return
id|priv
suffix:semicolon
)brace
r_static
r_void
DECL|function|brlvger_disconnect
id|brlvger_disconnect
c_func
(paren
r_struct
id|usb_device
op_star
id|dev
comma
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|brlvger_priv
op_star
id|priv
op_assign
(paren
r_struct
id|brlvger_priv
op_star
)paren
id|ptr
suffix:semicolon
r_int
id|r
suffix:semicolon
r_if
c_cond
(paren
id|priv
)paren
(brace
id|info
c_func
(paren
l_string|&quot;Display %d disconnecting&quot;
comma
id|priv-&gt;subminor
)paren
suffix:semicolon
id|devfs_unregister
c_func
(paren
id|priv-&gt;devfs
)paren
suffix:semicolon
id|usb_deregister_dev
c_func
(paren
op_amp
id|brlvger_driver
comma
l_int|1
comma
id|priv-&gt;subminor
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|disconnect_sem
)paren
suffix:semicolon
id|display_table
(braket
id|priv-&gt;subminor
)braket
op_assign
l_int|NULL
suffix:semicolon
id|up
c_func
(paren
op_amp
id|disconnect_sem
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|priv-&gt;open_sem
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|priv-&gt;dev_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;opened
)paren
(brace
multiline_comment|/* Disable interrupts */
r_if
c_cond
(paren
(paren
id|r
op_assign
id|usb_unlink_urb
c_func
(paren
id|priv-&gt;intr_urb
)paren
)paren
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;usb_unlink_urb returns %d&quot;
comma
id|r
)paren
suffix:semicolon
)brace
id|usb_free_urb
c_func
(paren
id|priv-&gt;intr_urb
)paren
suffix:semicolon
multiline_comment|/* mark device as dead and prevent control&n;&t;&t;&t;   messages to it */
id|priv-&gt;dev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Tell anyone hung up on a read that it&n;&t;&t;&t;   won&squot;t be coming */
id|wake_up_interruptible
c_func
(paren
op_amp
id|priv-&gt;read_wait
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|priv-&gt;dev_sem
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|priv-&gt;open_sem
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* no corresponding up()s */
id|kfree
c_func
(paren
id|priv
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* ----------------------------------------------------------------------- */
multiline_comment|/* fops implementation */
r_static
r_int
DECL|function|brlvger_open
id|brlvger_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|devnum
op_assign
id|minor
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_struct
id|brlvger_priv
op_star
id|priv
suffix:semicolon
r_int
id|n
comma
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|devnum
OL
id|BRLVGER_MINOR
op_logical_or
id|devnum
op_ge
(paren
id|BRLVGER_MINOR
op_plus
id|MAX_NR_BRLVGER_DEVS
)paren
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|n
op_assign
id|devnum
op_minus
id|BRLVGER_MINOR
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_do
(brace
id|down
c_func
(paren
op_amp
id|disconnect_sem
)paren
suffix:semicolon
id|priv
op_assign
id|display_table
(braket
id|n
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|priv
)paren
(brace
id|up
c_func
(paren
op_amp
id|disconnect_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|dbg3
c_func
(paren
l_string|&quot;Failing non-blocking open: &quot;
l_string|&quot;device %d not connected&quot;
comma
id|n
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/* Blocking open. One global wait queue will&n;&t;&t;&t;   suffice. We wait until a device for the selected&n;&t;&t;&t;   minor is connected. */
id|dbg2
c_func
(paren
l_string|&quot;Waiting for device %d to be connected&quot;
comma
id|n
)paren
suffix:semicolon
id|ret
op_assign
id|wait_event_interruptible
c_func
(paren
id|open_wait
comma
id|display_table
(braket
id|n
)braket
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|dbg2
c_func
(paren
l_string|&quot;Interrupted wait for device %d&quot;
comma
id|n
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
op_logical_neg
id|priv
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* We grabbed an existing device. */
r_if
c_cond
(paren
id|down_interruptible
c_func
(paren
op_amp
id|priv-&gt;open_sem
)paren
)paren
(brace
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|disconnect_sem
)paren
suffix:semicolon
multiline_comment|/* Only one process can open each device, no sharing. */
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;opened
)paren
(brace
r_goto
id|error
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;Opening display %d&quot;
comma
id|priv-&gt;subminor
)paren
suffix:semicolon
multiline_comment|/* Setup interrupt handler for receiving key input */
id|priv-&gt;intr_urb
op_assign
id|usb_alloc_urb
c_func
(paren
l_int|0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|priv-&gt;intr_urb
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Unable to allocate URB&quot;
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|FILL_INT_URB
c_func
(paren
id|priv-&gt;intr_urb
comma
id|priv-&gt;dev
comma
id|usb_rcvintpipe
c_func
(paren
id|priv-&gt;dev
comma
id|priv-&gt;in_interrupt-&gt;bEndpointAddress
)paren
comma
id|priv-&gt;intr_buff
comma
r_sizeof
(paren
id|priv-&gt;intr_buff
)paren
comma
id|intr_callback
comma
id|priv
comma
id|priv-&gt;in_interrupt-&gt;bInterval
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|usb_submit_urb
c_func
(paren
id|priv-&gt;intr_urb
comma
id|GFP_KERNEL
)paren
)paren
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Error %d while submitting URB&quot;
comma
id|ret
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/* Set voltage */
r_if
c_cond
(paren
id|brlvger_set_display_voltage
c_func
(paren
id|priv
comma
id|raw_voltage
)paren
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Unable to set voltage&quot;
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/* Turn display on */
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|brlvger_set_display_on_off
c_func
(paren
id|priv
comma
l_int|1
)paren
)paren
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Error %d while turning display on&quot;
comma
id|ret
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/* Mark as opened, so disconnect cannot free priv. */
id|priv-&gt;opened
op_assign
l_int|1
suffix:semicolon
id|file-&gt;private_data
op_assign
id|priv
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|error
suffix:colon
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|priv-&gt;open_sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
DECL|function|brlvger_release
id|brlvger_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|brlvger_priv
op_star
id|priv
op_assign
id|file-&gt;private_data
suffix:semicolon
r_int
id|r
suffix:semicolon
multiline_comment|/* Turn display off. Safe even if disconnected. */
id|brlvger_set_display_on_off
c_func
(paren
id|priv
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* mutex with disconnect and with open */
id|down
c_func
(paren
op_amp
id|priv-&gt;open_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|priv-&gt;dev
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;Releasing disconnected device %d&quot;
comma
id|priv-&gt;subminor
)paren
suffix:semicolon
multiline_comment|/* no up(&amp;priv-&gt;open_sem) */
id|kfree
c_func
(paren
id|priv
)paren
suffix:semicolon
)brace
r_else
(brace
id|dbg
c_func
(paren
l_string|&quot;Closing display %d&quot;
comma
id|priv-&gt;subminor
)paren
suffix:semicolon
multiline_comment|/* Disable interrupts */
r_if
c_cond
(paren
(paren
id|r
op_assign
id|usb_unlink_urb
c_func
(paren
id|priv-&gt;intr_urb
)paren
)paren
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;usb_unlink_urb returns %d&quot;
comma
id|r
)paren
suffix:semicolon
)brace
id|usb_free_urb
c_func
(paren
id|priv-&gt;intr_urb
)paren
suffix:semicolon
id|priv-&gt;opened
op_assign
l_int|0
suffix:semicolon
id|up
c_func
(paren
op_amp
id|priv-&gt;open_sem
)paren
suffix:semicolon
)brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|brlvger_write
id|brlvger_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|pos
)paren
(brace
r_struct
id|brlvger_priv
op_star
id|priv
op_assign
id|file-&gt;private_data
suffix:semicolon
r_char
id|buf
(braket
id|MAX_BRLVGER_CELLS
)braket
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|rs
comma
id|off
suffix:semicolon
id|__u16
id|written
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|priv-&gt;dev
)paren
(brace
r_return
op_minus
id|ENOLINK
suffix:semicolon
)brace
id|off
op_assign
op_star
id|pos
suffix:semicolon
r_if
c_cond
(paren
id|off
OG
id|priv-&gt;plength
)paren
(brace
r_return
op_minus
id|ESPIPE
suffix:semicolon
)brace
suffix:semicolon
id|rs
op_assign
id|priv-&gt;plength
op_minus
id|off
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
id|rs
)paren
(brace
id|count
op_assign
id|rs
suffix:semicolon
)brace
id|written
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
id|buf
comma
id|buffer
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|memset
c_func
(paren
id|priv-&gt;obuf
comma
l_int|0xaa
comma
r_sizeof
(paren
id|priv-&gt;obuf
)paren
)paren
suffix:semicolon
multiline_comment|/* Firmware supports multiples of 8cells, so some cells are absent&n;&t;   and for some reason there actually are holes! euurkkk! */
r_if
c_cond
(paren
id|priv-&gt;plength
op_eq
l_int|44
)paren
(brace
multiline_comment|/* Two ghost cells at the beginning of the display, plus&n;&t;&t;   two more after the sixth physical cell. */
r_if
c_cond
(paren
id|off
OG
l_int|5
)paren
(brace
id|off
op_add_assign
l_int|4
suffix:semicolon
id|memcpy
c_func
(paren
id|priv-&gt;obuf
comma
id|buf
comma
id|count
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|firstpart
op_assign
l_int|6
op_minus
id|off
suffix:semicolon
macro_line|#ifdef WRITE_DEBUG
id|dbg3
c_func
(paren
l_string|&quot;off: %d, rs: %d, count: %d, firstpart: %d&quot;
comma
id|off
comma
id|rs
comma
id|count
comma
id|firstpart
)paren
suffix:semicolon
macro_line|#endif
id|firstpart
op_assign
(paren
id|firstpart
OL
id|count
)paren
ques
c_cond
id|firstpart
suffix:colon
id|count
suffix:semicolon
macro_line|#ifdef WRITE_DEBUG
id|dbg3
c_func
(paren
l_string|&quot;off: %d&quot;
comma
id|off
)paren
suffix:semicolon
id|dbg3
c_func
(paren
l_string|&quot;firstpart: %d&quot;
comma
id|firstpart
)paren
suffix:semicolon
macro_line|#endif
id|memcpy
c_func
(paren
id|priv-&gt;obuf
comma
id|buf
comma
id|firstpart
)paren
suffix:semicolon
r_if
c_cond
(paren
id|firstpart
op_ne
id|count
)paren
(brace
r_int
id|secondpart
op_assign
id|count
op_minus
id|firstpart
suffix:semicolon
macro_line|#ifdef WRITE_DEBUG
id|dbg3
c_func
(paren
l_string|&quot;secondpart: %d&quot;
comma
id|secondpart
)paren
suffix:semicolon
macro_line|#endif
id|memcpy
c_func
(paren
id|priv-&gt;obuf
op_plus
(paren
id|firstpart
op_plus
l_int|2
)paren
comma
id|buf
op_plus
id|firstpart
comma
id|secondpart
)paren
suffix:semicolon
id|written
op_add_assign
l_int|2
suffix:semicolon
)brace
id|off
op_add_assign
l_int|2
suffix:semicolon
macro_line|#ifdef WRITE_DEBUG
id|dbg3
c_func
(paren
l_string|&quot;off: %d, rs: %d, count: %d, firstpart: %d, &quot;
l_string|&quot;written: %d&quot;
comma
id|off
comma
id|rs
comma
id|count
comma
id|firstpart
comma
id|written
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
r_else
(brace
multiline_comment|/* Two ghost cells at the beginningg of the display. */
id|memcpy
c_func
(paren
id|priv-&gt;obuf
comma
id|buf
comma
id|count
)paren
suffix:semicolon
id|off
op_add_assign
l_int|2
suffix:semicolon
)brace
(brace
r_int
id|repeat
op_assign
id|write_repeats
suffix:semicolon
multiline_comment|/* Dirty hack: sometimes some of the dots are wrong and somehow&n;&t;&t;   right themselves if the command is repeated. */
r_while
c_loop
(paren
id|repeat
op_decrement
)paren
(brace
id|ret
op_assign
id|sndcontrolmsg
c_func
(paren
id|priv
comma
id|BRLVGER_SEND_BRAILLE
comma
id|BRLVGER_WRITE_REQ
comma
l_int|0
comma
id|off
comma
id|priv-&gt;obuf
comma
id|written
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
r_return
id|ret
suffix:semicolon
)brace
)brace
)brace
r_return
id|count
suffix:semicolon
)brace
r_static
r_int
DECL|function|read_index
id|read_index
c_func
(paren
r_struct
id|brlvger_priv
op_star
id|priv
)paren
(brace
r_int
id|intr_idx
comma
id|read_idx
suffix:semicolon
id|read_idx
op_assign
id|atomic_read
c_func
(paren
op_amp
id|priv-&gt;read_idx
)paren
suffix:semicolon
id|read_idx
op_assign
op_increment
id|read_idx
op_eq
id|MAX_INTERRUPT_BUFFER
ques
c_cond
l_int|0
suffix:colon
id|read_idx
suffix:semicolon
id|intr_idx
op_assign
id|atomic_read
c_func
(paren
op_amp
id|priv-&gt;intr_idx
)paren
suffix:semicolon
r_return
id|read_idx
op_eq
id|intr_idx
ques
c_cond
op_minus
l_int|1
suffix:colon
id|read_idx
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|brlvger_read
id|brlvger_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|unused_pos
)paren
(brace
r_struct
id|brlvger_priv
op_star
id|priv
op_assign
id|file-&gt;private_data
suffix:semicolon
r_int
id|read_idx
suffix:semicolon
r_if
c_cond
(paren
id|count
op_ne
id|MAX_INTERRUPT_DATA
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|priv-&gt;dev
)paren
(brace
r_return
op_minus
id|ENOLINK
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|read_idx
op_assign
id|read_index
c_func
(paren
id|priv
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* queue empty */
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
r_else
(brace
r_int
id|r
op_assign
id|wait_event_interruptible
c_func
(paren
id|priv-&gt;read_wait
comma
(paren
op_logical_neg
id|priv-&gt;dev
op_logical_or
(paren
id|read_idx
op_assign
id|read_index
c_func
(paren
id|priv
)paren
)paren
op_ne
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|priv-&gt;dev
)paren
(brace
r_return
op_minus
id|ENOLINK
suffix:semicolon
)brace
r_if
c_cond
(paren
id|r
)paren
(brace
r_return
id|r
suffix:semicolon
)brace
r_if
c_cond
(paren
id|read_idx
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* should not happen */
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|copy_to_user
(paren
id|buffer
comma
id|priv-&gt;event_queue
(braket
id|read_idx
)braket
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|priv-&gt;read_idx
comma
id|read_idx
)paren
suffix:semicolon
multiline_comment|/* Multiple opens are not allowed. Yet on SMP, two processes could&n;&t;   read at the same time (on a shared file descriptor); then it is not&n;&t;   deterministic whether or not they will get duplicates of a key&n;&t;   event. */
r_return
id|MAX_INTERRUPT_DATA
suffix:semicolon
)brace
r_static
r_int
DECL|function|brlvger_ioctl
id|brlvger_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|brlvger_priv
op_star
id|priv
op_assign
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|priv-&gt;dev
)paren
(brace
r_return
op_minus
id|ENOLINK
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|BRLVGER_GET_INFO
suffix:colon
(brace
r_struct
id|brlvger_info
id|vi
suffix:semicolon
id|strncpy
c_func
(paren
id|vi.driver_version
comma
id|DRIVER_VERSION
comma
r_sizeof
(paren
id|vi.driver_version
)paren
)paren
suffix:semicolon
id|vi.driver_version
(braket
r_sizeof
(paren
id|vi.driver_version
)paren
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|strncpy
c_func
(paren
id|vi.driver_banner
comma
id|longbanner
comma
r_sizeof
(paren
id|vi.driver_banner
)paren
)paren
suffix:semicolon
id|vi.driver_banner
(braket
r_sizeof
(paren
id|vi.driver_banner
)paren
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|vi.display_length
op_assign
id|priv-&gt;plength
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|vi.hwver
comma
id|priv-&gt;hwver
comma
id|BRLVGER_HWVER_SIZE
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|vi.fwver
comma
id|priv-&gt;fwver
comma
id|BRLVGER_FWVER_SIZE
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|vi.serialnum
comma
id|priv-&gt;serialnum
comma
id|BRLVGER_SERIAL_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|vi
comma
r_sizeof
(paren
id|vi
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|BRLVGER_DISPLAY_ON
suffix:colon
r_return
id|brlvger_set_display_on_off
c_func
(paren
id|priv
comma
l_int|1
)paren
suffix:semicolon
r_case
id|BRLVGER_DISPLAY_OFF
suffix:colon
r_return
id|brlvger_set_display_on_off
c_func
(paren
id|priv
comma
l_int|0
)paren
suffix:semicolon
r_case
id|BRLVGER_BUZZ
suffix:colon
(brace
id|__u16
id|duration
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|duration
comma
(paren
id|__u16
op_star
)paren
id|arg
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
id|brlvger_beep
c_func
(paren
id|priv
comma
id|duration
)paren
suffix:semicolon
)brace
macro_line|#if 0 /* Underlying commands don&squot;t seem to work for some reason; not clear if&n;&t; we&squot;d want to export these anyway. */
r_case
id|BRLVGER_SET_VOLTAGE
suffix:colon
(brace
id|__u16
id|voltage
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|voltage
comma
(paren
id|__u16
op_star
)paren
id|arg
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
id|brlvger_set_display_voltage
c_func
(paren
id|priv
comma
id|voltage
)paren
suffix:semicolon
)brace
r_case
id|BRLVGER_GET_VOLTAGE
suffix:colon
(brace
id|__u8
id|voltage
suffix:semicolon
r_int
id|r
op_assign
id|brlvger_get_display_voltage
c_func
(paren
id|priv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OL
l_int|0
)paren
(brace
r_return
id|r
suffix:semicolon
)brace
id|voltage
op_assign
id|r
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|voltage
comma
(paren
id|__u8
op_star
)paren
id|arg
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
suffix:semicolon
)brace
r_static
id|loff_t
DECL|function|brlvger_llseek
id|brlvger_llseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|loff_t
id|offset
comma
r_int
id|orig
)paren
(brace
r_struct
id|brlvger_priv
op_star
id|priv
op_assign
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|priv-&gt;dev
)paren
(brace
r_return
op_minus
id|ENOLINK
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|orig
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/*  nothing to do */
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|offset
op_add_assign
id|file-&gt;f_pos
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|offset
op_add_assign
id|priv-&gt;plength
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|offset
op_ge
id|priv-&gt;plength
)paren
op_logical_or
(paren
id|offset
OL
l_int|0
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
(paren
id|file-&gt;f_pos
op_assign
id|offset
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|brlvger_poll
id|brlvger_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_struct
id|brlvger_priv
op_star
id|priv
op_assign
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|priv-&gt;dev
)paren
(brace
r_return
id|POLLERR
op_or
id|POLLHUP
suffix:semicolon
)brace
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|priv-&gt;read_wait
comma
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|priv-&gt;dev
)paren
(brace
r_return
id|POLLERR
op_or
id|POLLHUP
suffix:semicolon
)brace
r_if
c_cond
(paren
id|read_index
c_func
(paren
id|priv
)paren
op_ne
op_minus
l_int|1
)paren
(brace
r_return
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|intr_callback
id|intr_callback
c_func
(paren
r_struct
id|urb
op_star
id|urb
)paren
(brace
r_struct
id|brlvger_priv
op_star
id|priv
op_assign
id|urb-&gt;context
suffix:semicolon
r_int
id|intr_idx
comma
id|read_idx
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;status
)paren
(brace
r_if
c_cond
(paren
id|urb-&gt;status
op_eq
op_minus
id|ETIMEDOUT
)paren
(brace
id|dbg2
c_func
(paren
l_string|&quot;Status -ETIMEDOUT, &quot;
l_string|&quot;probably disconnected&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|urb-&gt;status
op_ne
op_minus
id|ENOENT
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Status: %d&quot;
comma
id|urb-&gt;status
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
id|read_idx
op_assign
id|atomic_read
c_func
(paren
op_amp
id|priv-&gt;read_idx
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|priv-&gt;intr_idx_lock
)paren
suffix:semicolon
id|intr_idx
op_assign
id|atomic_read
c_func
(paren
op_amp
id|priv-&gt;intr_idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_idx
op_eq
id|intr_idx
)paren
(brace
id|dbg2
c_func
(paren
l_string|&quot;Queue full, dropping braille display input&quot;
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|priv-&gt;intr_idx_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* queue full */
)brace
id|memcpy
c_func
(paren
id|priv-&gt;event_queue
(braket
id|intr_idx
)braket
comma
id|urb-&gt;transfer_buffer
comma
id|MAX_INTERRUPT_DATA
)paren
suffix:semicolon
id|intr_idx
op_assign
(paren
op_increment
id|intr_idx
op_eq
id|MAX_INTERRUPT_BUFFER
)paren
ques
c_cond
l_int|0
suffix:colon
id|intr_idx
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|priv-&gt;intr_idx
comma
id|intr_idx
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|priv-&gt;intr_idx_lock
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|priv-&gt;read_wait
)paren
suffix:semicolon
)brace
multiline_comment|/* ----------------------------------------------------------------------- */
multiline_comment|/* Hardware access functions */
r_static
r_int
DECL|function|mycontrolmsg
id|mycontrolmsg
c_func
(paren
r_const
r_char
op_star
id|funcname
comma
r_struct
id|brlvger_priv
op_star
id|priv
comma
r_int
id|pipe_dir
comma
id|__u8
id|request
comma
id|__u8
id|requesttype
comma
id|__u16
id|value
comma
id|__u16
id|index
comma
r_void
op_star
id|data
comma
id|__u16
id|size
)paren
(brace
r_int
id|ret
op_assign
l_int|0
comma
id|tries
op_assign
id|stall_tries
suffix:semicolon
multiline_comment|/* Make sure the device was not disconnected */
r_if
c_cond
(paren
id|down_interruptible
c_func
(paren
op_amp
id|priv-&gt;dev_sem
)paren
)paren
(brace
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|priv-&gt;dev
)paren
(brace
id|up
c_func
(paren
op_amp
id|priv-&gt;dev_sem
)paren
suffix:semicolon
r_return
op_minus
id|ENOLINK
suffix:semicolon
)brace
multiline_comment|/* Dirty hack for retransmission: stalls and fails all the time&n;&t;   without this on the hardware we tested. */
r_while
c_loop
(paren
id|tries
op_decrement
)paren
(brace
id|ret
op_assign
id|usb_control_msg
c_func
(paren
id|priv-&gt;dev
comma
id|usb_sndctrlpipe
c_func
(paren
id|priv-&gt;dev
comma
l_int|0
)paren
op_or
id|pipe_dir
comma
id|request
comma
id|requesttype
comma
id|value
comma
id|index
comma
id|data
comma
id|size
comma
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
op_minus
id|EPIPE
)paren
(brace
r_break
suffix:semicolon
)brace
id|dbg2
c_func
(paren
l_string|&quot;Stalled, remaining %d tries&quot;
comma
id|tries
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|priv-&gt;dev_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;%s: usb_control_msg returns %d&quot;
comma
id|funcname
comma
id|ret
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|brlvger_get_hw_version
id|brlvger_get_hw_version
c_func
(paren
r_struct
id|brlvger_priv
op_star
id|priv
comma
r_int
r_char
op_star
id|verbuf
)paren
(brace
r_return
id|rcvcontrolmsg
c_func
(paren
id|priv
comma
id|BRLVGER_GET_HWVERSION
comma
id|BRLVGER_READ_REQ
comma
l_int|0
comma
l_int|0
comma
id|verbuf
comma
id|BRLVGER_HWVER_SIZE
)paren
suffix:semicolon
multiline_comment|/* verbuf should be 2 bytes */
)brace
r_static
r_int
DECL|function|brlvger_get_fw_version
id|brlvger_get_fw_version
c_func
(paren
r_struct
id|brlvger_priv
op_star
id|priv
comma
r_int
r_char
op_star
id|buf
)paren
(brace
r_int
r_char
id|rawbuf
(braket
(paren
id|BRLVGER_FWVER_SIZE
op_minus
l_int|1
)paren
op_star
l_int|2
op_plus
l_int|2
)braket
suffix:semicolon
r_int
id|i
comma
id|len
suffix:semicolon
r_int
id|r
op_assign
id|rcvcontrolmsg
c_func
(paren
id|priv
comma
id|BRLVGER_GET_FWVERSION
comma
id|BRLVGER_READ_REQ
comma
l_int|0
comma
l_int|0
comma
id|rawbuf
comma
r_sizeof
(paren
id|rawbuf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OL
l_int|0
)paren
(brace
r_return
id|r
suffix:semicolon
)brace
multiline_comment|/* If I guess correctly: succession of 16bit words, the string is&n;           formed of the first byte of each of these words. First byte in&n;           buffer indicates total length of data; not sure what second byte is&n;           for. */
id|len
op_assign
id|rawbuf
(braket
l_int|0
)braket
op_minus
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|len
op_plus
l_int|1
OG
id|BRLVGER_FWVER_SIZE
)paren
(brace
id|len
op_assign
id|BRLVGER_FWVER_SIZE
op_minus
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|buf
(braket
id|i
)braket
op_assign
id|rawbuf
(braket
l_int|2
op_plus
l_int|2
op_star
id|i
)braket
suffix:semicolon
)brace
id|buf
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|brlvger_get_serial
id|brlvger_get_serial
c_func
(paren
r_struct
id|brlvger_priv
op_star
id|priv
comma
r_int
r_char
op_star
id|buf
)paren
(brace
r_int
r_char
id|rawserial
(braket
id|BRLVGER_SERIAL_BIN_SIZE
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|r
op_assign
id|rcvcontrolmsg
c_func
(paren
id|priv
comma
id|BRLVGER_GET_SERIAL
comma
id|BRLVGER_READ_REQ
comma
l_int|0
comma
l_int|0
comma
id|rawserial
comma
r_sizeof
(paren
id|rawserial
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OL
l_int|0
)paren
(brace
r_return
id|r
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|BRLVGER_SERIAL_BIN_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
DECL|macro|NUM_TO_HEX
mdefine_line|#define NUM_TO_HEX(n) (((n)&gt;9) ? (n)+&squot;A&squot; : (n)+&squot;0&squot;)
id|buf
(braket
l_int|2
op_star
id|i
)braket
op_assign
id|NUM_TO_HEX
c_func
(paren
id|rawserial
(braket
id|i
)braket
op_rshift
l_int|4
)paren
suffix:semicolon
id|buf
(braket
l_int|2
op_star
id|i
op_plus
l_int|1
)braket
op_assign
id|NUM_TO_HEX
c_func
(paren
id|rawserial
(braket
id|i
)braket
op_amp
l_int|0xf
)paren
suffix:semicolon
)brace
id|buf
(braket
l_int|2
op_star
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|brlvger_get_display_length
id|brlvger_get_display_length
c_func
(paren
r_struct
id|brlvger_priv
op_star
id|priv
)paren
(brace
r_int
r_char
id|data
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|ret
op_assign
id|rcvcontrolmsg
c_func
(paren
id|priv
comma
id|BRLVGER_GET_LENGTH
comma
id|BRLVGER_READ_REQ
comma
l_int|0
comma
l_int|0
comma
id|data
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
r_return
id|ret
suffix:semicolon
)brace
r_return
id|data
(braket
l_int|1
)braket
suffix:semicolon
)brace
r_static
r_int
DECL|function|brlvger_beep
id|brlvger_beep
c_func
(paren
r_struct
id|brlvger_priv
op_star
id|priv
comma
id|__u16
id|duration
)paren
(brace
r_return
id|sndcontrolmsg
c_func
(paren
id|priv
comma
id|BRLVGER_BEEP
comma
id|BRLVGER_WRITE_REQ
comma
id|duration
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|brlvger_set_display_on_off
id|brlvger_set_display_on_off
c_func
(paren
r_struct
id|brlvger_priv
op_star
id|priv
comma
id|__u16
id|on
)paren
(brace
id|dbg2
c_func
(paren
l_string|&quot;Turning display %s&quot;
comma
(paren
(paren
id|on
)paren
ques
c_cond
l_string|&quot;on&quot;
suffix:colon
l_string|&quot;off&quot;
)paren
)paren
suffix:semicolon
r_return
id|sndcontrolmsg
c_func
(paren
id|priv
comma
id|BRLVGER_SET_DISPLAY_ON
comma
id|BRLVGER_WRITE_REQ
comma
id|on
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|brlvger_set_display_voltage
id|brlvger_set_display_voltage
c_func
(paren
r_struct
id|brlvger_priv
op_star
id|priv
comma
id|__u16
id|voltage
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;SET_DISPLAY_VOLTAGE to %u&quot;
comma
id|voltage
)paren
suffix:semicolon
r_return
id|sndcontrolmsg
c_func
(paren
id|priv
comma
id|BRLVGER_SET_DISPLAY_VOLTAGE
comma
id|BRLVGER_WRITE_REQ
comma
id|voltage
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#if 0 /* Had problems testing these commands. Not particularly useful anyway.*/
r_static
r_int
id|brlvger_get_display_voltage
c_func
(paren
r_struct
id|brlvger_priv
op_star
id|priv
)paren
(brace
id|__u8
id|voltage
op_assign
l_int|0
suffix:semicolon
r_int
id|ret
op_assign
id|rcvcontrolmsg
c_func
(paren
id|priv
comma
id|BRLVGER_GET_DISPLAY_VOLTAGE
comma
id|BRLVGER_READ_REQ
comma
l_int|0
comma
l_int|0
comma
op_amp
id|voltage
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
r_return
id|ret
suffix:semicolon
)brace
r_return
id|voltage
suffix:semicolon
)brace
r_static
r_int
id|brlvger_get_current
c_func
(paren
r_struct
id|brlvger_priv
op_star
id|priv
)paren
(brace
r_int
r_char
id|data
suffix:semicolon
r_int
id|ret
op_assign
id|rcvcontrolmsg
c_func
(paren
id|priv
comma
id|BRLVGER_GET_CURRENT
comma
id|BRLVGER_READ_REQ
comma
l_int|0
comma
l_int|0
comma
op_amp
id|data
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
r_return
id|ret
suffix:semicolon
)brace
r_return
id|data
suffix:semicolon
)brace
macro_line|#endif
eof
