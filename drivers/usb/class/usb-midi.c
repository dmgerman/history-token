multiline_comment|/*&n;  usb-midi.c  --  USB-MIDI driver&n;&n;  Copyright (C) 2001 &n;      NAGANO Daisuke &lt;breeze.nagano@nifty.ne.jp&gt;&n;&n;  This program is free software; you can redistribute it and/or modify&n;  it under the terms of the GNU General Public License as published by&n;  the Free Software Foundation; either version 2, or (at your option)&n;  any later version.&n;&n;  This program is distributed in the hope that it will be useful,&n;  but WITHOUT ANY WARRANTY; without even the implied warranty of&n;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;  GNU General Public License for more details.&n;&n;  You should have received a copy of the GNU General Public License&n;  along with this program; if not, write to the Free Software&n;  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n;  This driver is based on:&n;    - &squot;Universal Serial Bus Device Class Definition for MIDI Device&squot;&n;    - linux/drivers/sound/es1371.c, linux/drivers/usb/audio.c&n;    - alsa/lowlevel/pci/cs64xx.c&n;    - umidi.c for NetBSD&n; */
multiline_comment|/* ------------------------------------------------------------------------- */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/usb.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/sound.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &quot;usb-midi.h&quot;
multiline_comment|/* ------------------------------------------------------------------------- */
multiline_comment|/* More verbose on syslog */
DECL|macro|MIDI_DEBUG
macro_line|#undef MIDI_DEBUG
DECL|macro|MIDI_IN_BUFSIZ
mdefine_line|#define MIDI_IN_BUFSIZ 1024
DECL|macro|HAVE_SUPPORT_USB_MIDI_CLASS
mdefine_line|#define HAVE_SUPPORT_USB_MIDI_CLASS
DECL|macro|HAVE_SUPPORT_ALSA
macro_line|#undef HAVE_SUPPORT_ALSA
multiline_comment|/* ------------------------------------------------------------------------- */
DECL|variable|singlebyte
r_static
r_int
id|singlebyte
op_assign
l_int|0
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|singlebyte
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|singlebyte
comma
l_string|&quot;Enable sending MIDI messages with single message packet&quot;
)paren
suffix:semicolon
DECL|variable|maxdevices
r_static
r_int
id|maxdevices
op_assign
l_int|4
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|maxdevices
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|maxdevices
comma
l_string|&quot;Max number of allocatable MIDI device&quot;
)paren
suffix:semicolon
DECL|variable|uvendor
r_static
r_int
id|uvendor
op_assign
op_minus
l_int|1
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|uvendor
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|uvendor
comma
l_string|&quot;The USB Vendor ID of a semi-compliant interface&quot;
)paren
suffix:semicolon
DECL|variable|uproduct
r_static
r_int
id|uproduct
op_assign
op_minus
l_int|1
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|uproduct
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|uproduct
comma
l_string|&quot;The USB Product ID of a semi-compliant interface&quot;
)paren
suffix:semicolon
DECL|variable|uinterface
r_static
r_int
id|uinterface
op_assign
op_minus
l_int|1
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|uinterface
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|uinterface
comma
l_string|&quot;The Interface number of a semi-compliant interface&quot;
)paren
suffix:semicolon
DECL|variable|ualt
r_static
r_int
id|ualt
op_assign
op_minus
l_int|1
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|ualt
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|ualt
comma
l_string|&quot;The optional alternative setting of a semi-compliant interface&quot;
)paren
suffix:semicolon
DECL|variable|umin
r_static
r_int
id|umin
op_assign
op_minus
l_int|1
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|umin
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|umin
comma
l_string|&quot;The input endpoint of a semi-compliant interface&quot;
)paren
suffix:semicolon
DECL|variable|umout
r_static
r_int
id|umout
op_assign
op_minus
l_int|1
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|umout
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|umout
comma
l_string|&quot;The output endpoint of a semi-compliant interface&quot;
)paren
suffix:semicolon
DECL|variable|ucable
r_static
r_int
id|ucable
op_assign
op_minus
l_int|1
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|ucable
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|ucable
comma
l_string|&quot;The cable number used for a semi-compliant interface&quot;
)paren
suffix:semicolon
multiline_comment|/** Note -- the usb_string() returns only Latin-1 characters.&n; * (unicode chars &lt;= 255). To support Japanese, a unicode16LE-to-EUC or&n; * unicode16LE-to-JIS routine is needed to wrap around usb_get_string().&n; **/
DECL|variable|ulangid
r_static
r_int
r_int
id|ulangid
op_assign
l_int|0x0409
suffix:semicolon
multiline_comment|/** 0x0411 for Japanese **/
id|MODULE_PARM
c_func
(paren
id|ulangid
comma
l_string|&quot;h&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|ulangid
comma
l_string|&quot;The optional preferred USB Language ID for all devices&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;NAGANO Daisuke &lt;breeze.nagano@nifty.ne.jp&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;USB-MIDI driver&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
multiline_comment|/* ------------------------------------------------------------------------- */
multiline_comment|/** MIDIStreaming Class-Specific Interface Descriptor Subtypes **/
DECL|macro|MS_DESCRIPTOR_UNDEFINED
mdefine_line|#define MS_DESCRIPTOR_UNDEFINED&t;0
DECL|macro|MS_HEADER
mdefine_line|#define MS_HEADER&t;&t;1
DECL|macro|MIDI_IN_JACK
mdefine_line|#define MIDI_IN_JACK&t;&t;2
DECL|macro|MIDI_OUT_JACK
mdefine_line|#define MIDI_OUT_JACK&t;&t;3
multiline_comment|/* Spec reads: ELEMENT */
DECL|macro|ELEMENT_DESCRIPTOR
mdefine_line|#define ELEMENT_DESCRIPTOR   &t;4
DECL|macro|MS_HEADER_LENGTH
mdefine_line|#define MS_HEADER_LENGTH&t;7
multiline_comment|/** MIDIStreaming Class-Specific Endpoint Descriptor Subtypes **/
DECL|macro|DESCRIPTOR_UNDEFINED
mdefine_line|#define DESCRIPTOR_UNDEFINED&t;0
multiline_comment|/* Spec reads: MS_GENERAL */
DECL|macro|MS_GENERAL_ENDPOINT
mdefine_line|#define MS_GENERAL_ENDPOINT&t;1
multiline_comment|/** MIDIStreaming MIDI IN and OUT Jack Types **/
DECL|macro|JACK_TYPE_UNDEFINED
mdefine_line|#define JACK_TYPE_UNDEFINED&t;0
multiline_comment|/* Spec reads: EMBEDDED */
DECL|macro|EMBEDDED_JACK
mdefine_line|#define EMBEDDED_JACK&t;&t;1
multiline_comment|/* Spec reads: EXTERNAL */
DECL|macro|EXTERNAL_JACK
mdefine_line|#define EXTERNAL_JACK&t;&t;2
multiline_comment|/* structure summary&n;  &n;      usb_midi_state     usb_device&n;       |         |&n;      *|        *|       per ep&n;     in_ep     out_ep&n;       |         |&n;      *|        *|       per cable&n;      min       mout&n;       |         |       (cable to device pairing magic)&n;       |         |&n;       usb_midi_dev      dev_id (major,minor) == file-&gt;private_data&n;&n;*/
multiline_comment|/* usb_midi_state: corresponds to a USB-MIDI module */
DECL|struct|usb_midi_state
r_struct
id|usb_midi_state
(brace
DECL|member|mididev
r_struct
id|list_head
id|mididev
suffix:semicolon
DECL|member|usbdev
r_struct
id|usb_device
op_star
id|usbdev
suffix:semicolon
DECL|member|midiDevList
r_struct
id|list_head
id|midiDevList
suffix:semicolon
DECL|member|inEndpointList
r_struct
id|list_head
id|inEndpointList
suffix:semicolon
DECL|member|outEndpointList
r_struct
id|list_head
id|outEndpointList
suffix:semicolon
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|count
r_int
r_int
id|count
suffix:semicolon
multiline_comment|/* usage counter */
)brace
suffix:semicolon
multiline_comment|/* midi_out_endpoint: corresponds to an output endpoint */
DECL|struct|midi_out_endpoint
r_struct
id|midi_out_endpoint
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|usbdev
r_struct
id|usb_device
op_star
id|usbdev
suffix:semicolon
DECL|member|endpoint
r_int
id|endpoint
suffix:semicolon
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|wait
id|wait_queue_head_t
id|wait
suffix:semicolon
DECL|member|buf
r_int
r_char
op_star
id|buf
suffix:semicolon
DECL|member|bufWrPtr
r_int
id|bufWrPtr
suffix:semicolon
DECL|member|bufSize
r_int
id|bufSize
suffix:semicolon
DECL|member|urb
r_struct
id|urb
op_star
id|urb
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* midi_in_endpoint: corresponds to an input endpoint */
DECL|struct|midi_in_endpoint
r_struct
id|midi_in_endpoint
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|usbdev
r_struct
id|usb_device
op_star
id|usbdev
suffix:semicolon
DECL|member|endpoint
r_int
id|endpoint
suffix:semicolon
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|wait
id|wait_queue_head_t
id|wait
suffix:semicolon
DECL|member|cables
r_struct
id|usb_mididev
op_star
id|cables
(braket
l_int|16
)braket
suffix:semicolon
singleline_comment|// cables open for read
DECL|member|readers
r_int
id|readers
suffix:semicolon
singleline_comment|// number of cables open for read
DECL|member|urb
r_struct
id|urb
op_star
id|urb
suffix:semicolon
DECL|member|recvBuf
r_int
r_char
op_star
id|recvBuf
suffix:semicolon
DECL|member|recvBufSize
r_int
id|recvBufSize
suffix:semicolon
DECL|member|urbSubmitted
r_int
id|urbSubmitted
suffix:semicolon
singleline_comment|//FIXME: == readers &gt; 0
)brace
suffix:semicolon
multiline_comment|/* usb_mididev: corresponds to a logical device */
DECL|struct|usb_mididev
r_struct
id|usb_mididev
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|midi
r_struct
id|usb_midi_state
op_star
id|midi
suffix:semicolon
DECL|member|dev_midi
r_int
id|dev_midi
suffix:semicolon
DECL|member|open_mode
id|mode_t
id|open_mode
suffix:semicolon
r_struct
(brace
DECL|member|ep
r_struct
id|midi_in_endpoint
op_star
id|ep
suffix:semicolon
DECL|member|cableId
r_int
id|cableId
suffix:semicolon
singleline_comment|// as we are pushing data from usb_bulk_read to usb_midi_read,
singleline_comment|// we need a larger, cyclic buffer here.
DECL|member|buf
r_int
r_char
id|buf
(braket
id|MIDI_IN_BUFSIZ
)braket
suffix:semicolon
DECL|member|bufRdPtr
r_int
id|bufRdPtr
suffix:semicolon
DECL|member|bufWrPtr
r_int
id|bufWrPtr
suffix:semicolon
DECL|member|bufRemains
r_int
id|bufRemains
suffix:semicolon
DECL|member|min
)brace
id|min
suffix:semicolon
r_struct
(brace
DECL|member|ep
r_struct
id|midi_out_endpoint
op_star
id|ep
suffix:semicolon
DECL|member|cableId
r_int
id|cableId
suffix:semicolon
DECL|member|buf
r_int
r_char
id|buf
(braket
l_int|3
)braket
suffix:semicolon
DECL|member|bufPtr
r_int
id|bufPtr
suffix:semicolon
DECL|member|bufRemains
r_int
id|bufRemains
suffix:semicolon
DECL|member|isInExclusive
r_int
id|isInExclusive
suffix:semicolon
DECL|member|lastEvent
r_int
r_char
id|lastEvent
suffix:semicolon
DECL|member|mout
)brace
id|mout
suffix:semicolon
DECL|member|singlebyte
r_int
id|singlebyte
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/** Map the high nybble of MIDI voice messages to number of Message bytes.&n; * High nyble ranges from 0x8 to 0xe&n; */
DECL|variable|remains_80e0
r_static
r_int
id|remains_80e0
(braket
)braket
op_assign
(brace
l_int|3
comma
multiline_comment|/** 0x8X Note Off **/
l_int|3
comma
multiline_comment|/** 0x9X Note On **/
l_int|3
comma
multiline_comment|/** 0xAX Poly-key pressure **/
l_int|3
comma
multiline_comment|/** 0xBX Control Change **/
l_int|2
comma
multiline_comment|/** 0xCX Program Change **/
l_int|2
comma
multiline_comment|/** 0xDX Channel pressure **/
l_int|3
multiline_comment|/** 0xEX PitchBend Change **/
)brace
suffix:semicolon
multiline_comment|/** Map the messages to a number of Message bytes.&n; *&n; **/
DECL|variable|remains_f0f6
r_static
r_int
id|remains_f0f6
(braket
)braket
op_assign
(brace
l_int|0
comma
multiline_comment|/** 0xF0 **/
l_int|2
comma
multiline_comment|/** 0XF1 **/
l_int|3
comma
multiline_comment|/** 0XF2 **/
l_int|2
comma
multiline_comment|/** 0XF3 **/
l_int|2
comma
multiline_comment|/** 0XF4 (Undefined by MIDI Spec, and subject to change) **/
l_int|2
comma
multiline_comment|/** 0XF5 (Undefined by MIDI Spec, and subject to change) **/
l_int|1
multiline_comment|/** 0XF6 **/
)brace
suffix:semicolon
multiline_comment|/** Map the messages to a CIN (Code Index Number).&n; *&n; **/
DECL|variable|cin_f0ff
r_static
r_int
id|cin_f0ff
(braket
)braket
op_assign
(brace
l_int|4
comma
multiline_comment|/** 0xF0 System Exclusive Message Start (special cases may be 6 or 7) */
l_int|2
comma
multiline_comment|/** 0xF1 **/
l_int|3
comma
multiline_comment|/** 0xF2 **/
l_int|2
comma
multiline_comment|/** 0xF3 **/
l_int|2
comma
multiline_comment|/** 0xF4 **/
l_int|2
comma
multiline_comment|/** 0xF5 **/
l_int|5
comma
multiline_comment|/** 0xF6 **/
l_int|5
comma
multiline_comment|/** 0xF7 End of System Exclusive Message (May be 6 or 7) **/
l_int|5
comma
multiline_comment|/** 0xF8 **/
l_int|5
comma
multiline_comment|/** 0xF9 **/
l_int|5
comma
multiline_comment|/** 0xFA **/
l_int|5
comma
multiline_comment|/** 0xFB **/
l_int|5
comma
multiline_comment|/** 0xFC **/
l_int|5
comma
multiline_comment|/** 0xFD **/
l_int|5
comma
multiline_comment|/** 0xFE **/
l_int|5
multiline_comment|/** 0xFF **/
)brace
suffix:semicolon
multiline_comment|/** Map MIDIStreaming Event packet Code Index Number (low nybble of byte 0)&n; * to the number of bytes of valid MIDI data.&n; *&n; * CIN of 0 and 1 are NOT USED in MIDIStreaming 1.0.&n; *&n; **/
DECL|variable|cin_to_len
r_static
r_int
id|cin_to_len
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|2
comma
l_int|3
comma
l_int|3
comma
l_int|1
comma
l_int|2
comma
l_int|3
comma
l_int|3
comma
l_int|3
comma
l_int|3
comma
l_int|3
comma
l_int|2
comma
l_int|2
comma
l_int|3
comma
l_int|1
)brace
suffix:semicolon
multiline_comment|/* ------------------------------------------------------------------------- */
DECL|variable|mididevs
r_static
r_struct
id|list_head
id|mididevs
op_assign
id|LIST_HEAD_INIT
c_func
(paren
id|mididevs
)paren
suffix:semicolon
r_static
id|DECLARE_MUTEX
c_func
(paren
id|open_sem
)paren
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|open_wait
)paren
suffix:semicolon
multiline_comment|/* ------------------------------------------------------------------------- */
DECL|function|usb_write_callback
r_static
r_void
id|usb_write_callback
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|midi_out_endpoint
op_star
id|ep
op_assign
(paren
r_struct
id|midi_out_endpoint
op_star
)paren
id|urb-&gt;context
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|ep-&gt;wait
)paren
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|ep-&gt;wait
)paren
suffix:semicolon
)brace
DECL|function|usb_write
r_static
r_int
id|usb_write
c_func
(paren
r_struct
id|midi_out_endpoint
op_star
id|ep
comma
r_int
r_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_struct
id|usb_device
op_star
id|d
suffix:semicolon
r_int
id|pipe
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|maxretry
op_assign
l_int|50
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|ep-&gt;wait
)paren
suffix:semicolon
id|d
op_assign
id|ep-&gt;usbdev
suffix:semicolon
id|pipe
op_assign
id|usb_sndbulkpipe
c_func
(paren
id|d
comma
id|ep-&gt;endpoint
)paren
suffix:semicolon
id|usb_fill_bulk_urb
c_func
(paren
id|ep-&gt;urb
comma
id|d
comma
id|pipe
comma
(paren
r_int
r_char
op_star
)paren
id|buf
comma
id|len
comma
id|usb_write_callback
comma
id|ep
)paren
suffix:semicolon
id|status
op_assign
id|usb_submit_urb
c_func
(paren
id|ep-&gt;urb
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;usbmidi: Cannot submit urb (%d)&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|add_wait_queue
c_func
(paren
op_amp
id|ep-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_while
c_loop
(paren
id|ep-&gt;urb-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
(brace
r_if
c_cond
(paren
id|maxretry
op_decrement
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;usbmidi: usb_bulk_msg timed out&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ETIME
suffix:semicolon
r_break
suffix:semicolon
)brace
id|interruptible_sleep_on_timeout
c_func
(paren
op_amp
id|ep-&gt;wait
comma
l_int|10
)paren
suffix:semicolon
)brace
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|ep-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|error
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/** Copy data from URB to In endpoint buf.&n; * Discard if CIN == 0 or CIN = 1.&n; *&n; *&n; **/
DECL|function|usb_bulk_read
r_static
r_void
id|usb_bulk_read
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|midi_in_endpoint
op_star
id|ep
op_assign
(paren
r_struct
id|midi_in_endpoint
op_star
)paren
(paren
id|urb-&gt;context
)paren
suffix:semicolon
r_int
r_char
op_star
id|data
op_assign
id|urb-&gt;transfer_buffer
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|wake
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep-&gt;urbSubmitted
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|urb-&gt;status
op_eq
l_int|0
)paren
op_logical_and
(paren
id|urb-&gt;actual_length
OG
l_int|0
)paren
)paren
(brace
id|wake
op_assign
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|ep-&gt;lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|urb-&gt;actual_length
suffix:semicolon
id|j
op_add_assign
l_int|4
)paren
(brace
r_int
id|cin
op_assign
(paren
id|data
(braket
id|j
)braket
op_rshift
l_int|0
)paren
op_amp
l_int|0xf
suffix:semicolon
r_int
id|cab
op_assign
(paren
id|data
(braket
id|j
)braket
op_rshift
l_int|4
)paren
op_amp
l_int|0xf
suffix:semicolon
r_struct
id|usb_mididev
op_star
id|cable
op_assign
id|ep-&gt;cables
(braket
id|cab
)braket
suffix:semicolon
r_if
c_cond
(paren
id|cable
)paren
(brace
r_int
id|len
op_assign
id|cin_to_len
(braket
id|cin
)braket
suffix:semicolon
multiline_comment|/** length of MIDI data **/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cable-&gt;min.buf
(braket
id|cable-&gt;min.bufWrPtr
)braket
op_assign
id|data
(braket
l_int|1
op_plus
id|i
op_plus
id|j
)braket
suffix:semicolon
id|cable-&gt;min.bufWrPtr
op_assign
(paren
id|cable-&gt;min.bufWrPtr
op_plus
l_int|1
)paren
op_mod
id|MIDI_IN_BUFSIZ
suffix:semicolon
r_if
c_cond
(paren
id|cable-&gt;min.bufRemains
OL
id|MIDI_IN_BUFSIZ
)paren
id|cable-&gt;min.bufRemains
op_add_assign
l_int|1
suffix:semicolon
r_else
multiline_comment|/** need to drop data **/
id|cable-&gt;min.bufRdPtr
op_add_assign
(paren
id|cable-&gt;min.bufRdPtr
op_plus
l_int|1
)paren
op_mod
id|MIDI_IN_BUFSIZ
suffix:semicolon
id|wake
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
id|spin_unlock
(paren
op_amp
id|ep-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wake
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|ep-&gt;wait
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* urb-&gt;dev must be reinitialized on 2.4.x kernels */
id|urb-&gt;dev
op_assign
id|ep-&gt;usbdev
suffix:semicolon
id|urb-&gt;actual_length
op_assign
l_int|0
suffix:semicolon
id|usb_submit_urb
c_func
(paren
id|urb
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
)brace
multiline_comment|/* ------------------------------------------------------------------------- */
multiline_comment|/* This routine must be called with spin_lock */
multiline_comment|/** Wrapper around usb_write().&n; *  This routine must be called with spin_lock held on ep.&n; *  Called by midiWrite(), putOneMidiEvent(), and  usb_midi_write();&n; **/
DECL|function|flush_midi_buffer
r_static
r_int
id|flush_midi_buffer
c_func
(paren
r_struct
id|midi_out_endpoint
op_star
id|ep
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;bufWrPtr
OG
l_int|0
)paren
(brace
id|ret
op_assign
id|usb_write
c_func
(paren
id|ep
comma
id|ep-&gt;buf
comma
id|ep-&gt;bufWrPtr
)paren
suffix:semicolon
id|ep-&gt;bufWrPtr
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* ------------------------------------------------------------------------- */
multiline_comment|/** Given a MIDI Event, determine size of data to be attached to &n; * USB-MIDI packet.&n; * Returns 1, 2 or 3.&n; * Called by midiWrite();&n; * Uses remains_80e0 and remains_f0f6;&n; **/
DECL|function|get_remains
r_static
r_int
id|get_remains
c_func
(paren
r_int
id|event
)paren
(brace
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|event
OL
l_int|0x80
)paren
(brace
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|event
OL
l_int|0xf0
)paren
(brace
id|ret
op_assign
id|remains_80e0
(braket
(paren
(paren
id|event
op_minus
l_int|0x80
)paren
op_rshift
l_int|4
)paren
op_amp
l_int|0x0f
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|event
OL
l_int|0xf7
)paren
(brace
id|ret
op_assign
id|remains_f0f6
(braket
id|event
op_minus
l_int|0xf0
)braket
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/** Given the output MIDI data in the output buffer, computes a reasonable &n; * CIN.&n; * Called by putOneMidiEvent().&n; **/
DECL|function|get_CIN
r_static
r_int
id|get_CIN
c_func
(paren
r_struct
id|usb_mididev
op_star
id|m
)paren
(brace
r_int
id|cin
suffix:semicolon
r_if
c_cond
(paren
id|m-&gt;mout.buf
(braket
l_int|0
)braket
op_eq
l_int|0xf7
)paren
(brace
id|cin
op_assign
l_int|5
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|m-&gt;mout.buf
(braket
l_int|1
)braket
op_eq
l_int|0xf7
)paren
(brace
id|cin
op_assign
l_int|6
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|m-&gt;mout.buf
(braket
l_int|2
)braket
op_eq
l_int|0xf7
)paren
(brace
id|cin
op_assign
l_int|7
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|m-&gt;mout.isInExclusive
op_eq
l_int|1
)paren
(brace
id|cin
op_assign
l_int|4
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|m-&gt;mout.buf
(braket
l_int|0
)braket
OL
l_int|0x80
)paren
(brace
multiline_comment|/** One byte that we know nothing about. **/
id|cin
op_assign
l_int|0xF
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|m-&gt;mout.buf
(braket
l_int|0
)braket
OL
l_int|0xf0
)paren
(brace
multiline_comment|/** MIDI Voice messages 0x8X to 0xEX map to cin 0x8 to 0xE. **/
id|cin
op_assign
(paren
id|m-&gt;mout.buf
(braket
l_int|0
)braket
op_rshift
l_int|4
)paren
op_amp
l_int|0x0f
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/** Special lookup table exists for real-time events. **/
id|cin
op_assign
id|cin_f0ff
(braket
id|m-&gt;mout.buf
(braket
l_int|0
)braket
op_minus
l_int|0xf0
)braket
suffix:semicolon
)brace
)brace
r_return
id|cin
suffix:semicolon
)brace
multiline_comment|/* ------------------------------------------------------------------------- */
multiline_comment|/** Move data to USB endpoint buffer.&n; *&n; **/
DECL|function|put_one_midi_event
r_static
r_int
id|put_one_midi_event
c_func
(paren
r_struct
id|usb_mididev
op_star
id|m
)paren
(brace
r_int
id|cin
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|midi_out_endpoint
op_star
id|ep
op_assign
id|m-&gt;mout.ep
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|cin
op_assign
id|get_CIN
c_func
(paren
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cin
OG
l_int|0x0f
op_logical_or
id|cin
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|ep-&gt;buf
(braket
id|ep-&gt;bufWrPtr
op_increment
)braket
op_assign
(paren
id|m-&gt;mout.cableId
op_lshift
l_int|4
)paren
op_or
id|cin
suffix:semicolon
id|ep-&gt;buf
(braket
id|ep-&gt;bufWrPtr
op_increment
)braket
op_assign
id|m-&gt;mout.buf
(braket
l_int|0
)braket
suffix:semicolon
id|ep-&gt;buf
(braket
id|ep-&gt;bufWrPtr
op_increment
)braket
op_assign
id|m-&gt;mout.buf
(braket
l_int|1
)braket
suffix:semicolon
id|ep-&gt;buf
(braket
id|ep-&gt;bufWrPtr
op_increment
)braket
op_assign
id|m-&gt;mout.buf
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;bufWrPtr
op_ge
id|ep-&gt;bufSize
)paren
(brace
id|ret
op_assign
id|flush_midi_buffer
c_func
(paren
id|ep
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|m-&gt;mout.buf
(braket
l_int|0
)braket
op_assign
id|m-&gt;mout.buf
(braket
l_int|1
)braket
op_assign
id|m-&gt;mout.buf
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|m-&gt;mout.bufPtr
op_assign
l_int|0
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/** Write the MIDI message v on the midi device.&n; *  Called by usb_midi_write();&n; *  Responsible for packaging a MIDI data stream into USB-MIDI packets.&n; **/
DECL|function|midi_write
r_static
r_int
id|midi_write
c_func
(paren
r_struct
id|usb_mididev
op_star
id|m
comma
r_int
id|v
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|midi_out_endpoint
op_star
id|ep
op_assign
id|m-&gt;mout.ep
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|c
op_assign
(paren
r_int
r_char
)paren
id|v
suffix:semicolon
r_int
r_char
id|sysrt_buf
(braket
l_int|4
)braket
suffix:semicolon
r_if
c_cond
(paren
id|m-&gt;singlebyte
op_ne
l_int|0
)paren
(brace
multiline_comment|/** Simple code to handle the single-byte USB-MIDI protocol. */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;bufWrPtr
op_plus
l_int|4
OG
id|ep-&gt;bufSize
)paren
(brace
id|ret
op_assign
id|flush_midi_buffer
c_func
(paren
id|ep
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
)brace
id|ep-&gt;buf
(braket
id|ep-&gt;bufWrPtr
op_increment
)braket
op_assign
(paren
id|m-&gt;mout.cableId
op_lshift
l_int|4
)paren
op_or
l_int|0x0f
suffix:semicolon
multiline_comment|/* single byte */
id|ep-&gt;buf
(braket
id|ep-&gt;bufWrPtr
op_increment
)braket
op_assign
id|c
suffix:semicolon
id|ep-&gt;buf
(braket
id|ep-&gt;bufWrPtr
op_increment
)braket
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;buf
(braket
id|ep-&gt;bufWrPtr
op_increment
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;bufWrPtr
op_ge
id|ep-&gt;bufSize
)paren
(brace
id|ret
op_assign
id|flush_midi_buffer
c_func
(paren
id|ep
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/** Normal USB-MIDI protocol begins here. */
r_if
c_cond
(paren
id|c
OG
l_int|0xf7
)paren
(brace
multiline_comment|/* system: Realtime messages */
multiline_comment|/** Realtime messages are written IMMEDIATELY. */
id|sysrt_buf
(braket
l_int|0
)braket
op_assign
(paren
id|m-&gt;mout.cableId
op_lshift
l_int|4
)paren
op_or
l_int|0x0f
suffix:semicolon
id|sysrt_buf
(braket
l_int|1
)braket
op_assign
id|c
suffix:semicolon
id|sysrt_buf
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|sysrt_buf
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|ret
op_assign
id|usb_write
c_func
(paren
id|ep
comma
id|sysrt_buf
comma
l_int|4
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* m-&gt;mout.lastEvent = 0; */
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_ge
l_int|0x80
)paren
(brace
r_if
c_cond
(paren
id|c
OL
l_int|0xf0
)paren
(brace
id|m-&gt;mout.lastEvent
op_assign
id|c
suffix:semicolon
id|m-&gt;mout.isInExclusive
op_assign
l_int|0
suffix:semicolon
id|m-&gt;mout.bufRemains
op_assign
id|get_remains
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c
op_eq
l_int|0xf0
)paren
(brace
multiline_comment|/* m-&gt;mout.lastEvent = 0; */
id|m-&gt;mout.isInExclusive
op_assign
l_int|1
suffix:semicolon
id|m-&gt;mout.bufRemains
op_assign
id|get_remains
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c
op_eq
l_int|0xf7
op_logical_and
id|m-&gt;mout.isInExclusive
op_eq
l_int|1
)paren
(brace
multiline_comment|/* m-&gt;mout.lastEvent = 0; */
id|m-&gt;mout.isInExclusive
op_assign
l_int|0
suffix:semicolon
id|m-&gt;mout.bufRemains
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c
OG
l_int|0xf0
)paren
(brace
multiline_comment|/* m-&gt;mout.lastEvent = 0; */
id|m-&gt;mout.isInExclusive
op_assign
l_int|0
suffix:semicolon
id|m-&gt;mout.bufRemains
op_assign
id|get_remains
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|m-&gt;mout.bufRemains
op_eq
l_int|0
op_logical_and
id|m-&gt;mout.isInExclusive
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|m-&gt;mout.lastEvent
op_eq
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* discard, waiting for the first event */
)brace
multiline_comment|/** track status **/
id|m-&gt;mout.buf
(braket
l_int|0
)braket
op_assign
id|m-&gt;mout.lastEvent
suffix:semicolon
id|m-&gt;mout.bufPtr
op_assign
l_int|1
suffix:semicolon
id|m-&gt;mout.bufRemains
op_assign
id|get_remains
c_func
(paren
id|m-&gt;mout.lastEvent
)paren
op_minus
l_int|1
suffix:semicolon
)brace
id|m-&gt;mout.buf
(braket
id|m-&gt;mout.bufPtr
op_increment
)braket
op_assign
id|c
suffix:semicolon
id|m-&gt;mout.bufRemains
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|m-&gt;mout.bufRemains
op_eq
l_int|0
op_logical_or
id|m-&gt;mout.bufPtr
op_ge
l_int|3
)paren
(brace
id|ret
op_assign
id|put_one_midi_event
c_func
(paren
id|m
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* ------------------------------------------------------------------------- */
multiline_comment|/** Basic operation on /dev/midiXX as registered through struct file_operations.&n; *&n; *  Basic contract: Used to change the current read/write position in a file.&n; *  On success, the non-negative position is reported.&n; *  On failure, the negative of an error code is reported.&n; *&n; *  Because a MIDIStream is not a file, all seek operations are doomed to fail.&n; *&n; **/
DECL|function|usb_midi_llseek
r_static
id|loff_t
id|usb_midi_llseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|loff_t
id|offset
comma
r_int
id|origin
)paren
(brace
multiline_comment|/** Tell user you cannot seek on a PIPE-like device. **/
r_return
op_minus
id|ESPIPE
suffix:semicolon
)brace
multiline_comment|/** Basic operation on /dev/midiXX as registered through struct file_operations.&n; *&n; * Basic contract: Block until count bytes have been read or an error occurs.&n; *&n; **/
DECL|function|usb_midi_read
r_static
id|ssize_t
id|usb_midi_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
id|__user
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|usb_mididev
op_star
id|m
op_assign
(paren
r_struct
id|usb_mididev
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|midi_in_endpoint
op_star
id|ep
op_assign
id|m-&gt;min.ep
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppos
op_ne
op_amp
id|file-&gt;f_pos
)paren
(brace
r_return
op_minus
id|ESPIPE
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|buffer
comma
id|count
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|add_wait_queue
c_func
(paren
op_amp
id|ep-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
r_int
id|cnt
suffix:semicolon
r_int
id|d
op_assign
(paren
r_int
)paren
id|count
suffix:semicolon
id|cnt
op_assign
id|m-&gt;min.bufRemains
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OG
id|d
)paren
(brace
id|cnt
op_assign
id|d
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cnt
op_le
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_break
suffix:semicolon
)brace
id|__set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|ret
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* used to synchronize access to the endpoint */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buffer
op_plus
id|i
comma
id|m-&gt;min.buf
op_plus
id|m-&gt;min.bufRdPtr
comma
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|m-&gt;min.bufRdPtr
op_assign
(paren
id|m-&gt;min.bufRdPtr
op_plus
l_int|1
)paren
op_mod
id|MIDI_IN_BUFSIZ
suffix:semicolon
id|m-&gt;min.bufRemains
op_sub_assign
l_int|1
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|count
op_sub_assign
id|cnt
suffix:semicolon
id|buffer
op_add_assign
id|cnt
suffix:semicolon
id|ret
op_add_assign
id|cnt
suffix:semicolon
r_break
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|ep-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/** Basic operation on /dev/midiXX as registered through struct file_operations.&n; *&n; *  Basic Contract: Take MIDI data byte-by-byte and pass it to&n; *  writeMidi() which packages MIDI data into USB-MIDI stream.&n; *  Then flushMidiData() is called to ensure all bytes have been written&n; *  in a timely fashion.&n; *&n; **/
DECL|function|usb_midi_write
r_static
id|ssize_t
id|usb_midi_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
id|__user
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|usb_mididev
op_star
id|m
op_assign
(paren
r_struct
id|usb_mididev
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
r_int
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|ppos
op_ne
op_amp
id|file-&gt;f_pos
)paren
(brace
r_return
op_minus
id|ESPIPE
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|buffer
comma
id|count
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
r_int
r_char
id|c
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|c
comma
id|buffer
comma
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|midi_write
c_func
(paren
id|m
comma
(paren
r_int
)paren
id|c
)paren
)paren
(brace
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|count
op_decrement
suffix:semicolon
id|buffer
op_increment
suffix:semicolon
id|ret
op_increment
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|m-&gt;mout.ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flush_midi_buffer
c_func
(paren
id|m-&gt;mout.ep
)paren
OL
l_int|0
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|m-&gt;mout.ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/** Basic operation on /dev/midiXX as registered through struct file_operations.&n; *&n; * Basic contract:  Wait (spin) until ready to read or write on the file.&n; *&n; **/
DECL|function|usb_midi_poll
r_static
r_int
r_int
id|usb_midi_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|poll_table_struct
op_star
id|wait
)paren
(brace
r_struct
id|usb_mididev
op_star
id|m
op_assign
(paren
r_struct
id|usb_mididev
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|midi_in_endpoint
op_star
id|iep
op_assign
id|m-&gt;min.ep
suffix:semicolon
r_struct
id|midi_out_endpoint
op_star
id|oep
op_assign
id|m-&gt;mout.ep
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|mask
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|iep-&gt;wait
comma
id|wait
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|iep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m-&gt;min.bufRemains
OG
l_int|0
)paren
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|iep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|oep-&gt;wait
comma
id|wait
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|oep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oep-&gt;bufWrPtr
OL
id|oep-&gt;bufSize
)paren
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|oep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|mask
suffix:semicolon
)brace
multiline_comment|/** Basic operation on /dev/midiXX as registered through struct file_operations.&n; *&n; * Basic contract: This is always the first operation performed on the&n; * device node. If no method is defined, the open succeeds without any&n; * notification given to the module.&n; *&n; **/
DECL|function|usb_midi_open
r_static
r_int
id|usb_midi_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|minor
op_assign
id|iminor
c_func
(paren
id|inode
)paren
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_struct
id|list_head
op_star
id|devs
comma
op_star
id|mdevs
suffix:semicolon
r_struct
id|usb_midi_state
op_star
id|s
suffix:semicolon
r_struct
id|usb_mididev
op_star
id|m
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|succeed
op_assign
l_int|0
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;usb-midi: Open minor= %d.&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|down
c_func
(paren
op_amp
id|open_sem
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|devs
comma
op_amp
id|mididevs
)paren
(brace
id|s
op_assign
id|list_entry
c_func
(paren
id|devs
comma
r_struct
id|usb_midi_state
comma
id|mididev
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|mdevs
comma
op_amp
id|s-&gt;midiDevList
)paren
(brace
id|m
op_assign
id|list_entry
c_func
(paren
id|mdevs
comma
r_struct
id|usb_mididev
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|m-&gt;dev_midi
op_xor
id|minor
)paren
op_amp
op_complement
l_int|0xf
)paren
)paren
r_goto
id|device_found
suffix:semicolon
)brace
)brace
id|up
c_func
(paren
op_amp
id|open_sem
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
id|device_found
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;usbdev
)paren
(brace
id|up
c_func
(paren
op_amp
id|open_sem
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|m-&gt;open_mode
op_amp
id|file-&gt;f_mode
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|up
c_func
(paren
op_amp
id|open_sem
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|__set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|open_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|open_sem
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|open_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
)brace
id|file-&gt;private_data
op_assign
id|m
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|m-&gt;open_mode
op_amp
(paren
id|FMODE_READ
op_or
id|FMODE_WRITE
)paren
)paren
)paren
(brace
singleline_comment|//FIXME: intented semantics unclear here
id|m-&gt;min.bufRdPtr
op_assign
l_int|0
suffix:semicolon
id|m-&gt;min.bufWrPtr
op_assign
l_int|0
suffix:semicolon
id|m-&gt;min.bufRemains
op_assign
l_int|0
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|m-&gt;min.ep-&gt;lock
)paren
suffix:semicolon
id|m-&gt;mout.bufPtr
op_assign
l_int|0
suffix:semicolon
id|m-&gt;mout.bufRemains
op_assign
l_int|0
suffix:semicolon
id|m-&gt;mout.isInExclusive
op_assign
l_int|0
suffix:semicolon
id|m-&gt;mout.lastEvent
op_assign
l_int|0
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|m-&gt;mout.ep-&gt;lock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
op_logical_and
id|m-&gt;min.ep
op_ne
l_int|NULL
)paren
(brace
r_int
r_int
r_int
id|flagsep
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|m-&gt;min.ep-&gt;lock
comma
id|flagsep
)paren
suffix:semicolon
id|m-&gt;min.ep-&gt;cables
(braket
id|m-&gt;min.cableId
)braket
op_assign
id|m
suffix:semicolon
id|m-&gt;min.ep-&gt;readers
op_add_assign
l_int|1
suffix:semicolon
id|m-&gt;min.bufRdPtr
op_assign
l_int|0
suffix:semicolon
id|m-&gt;min.bufWrPtr
op_assign
l_int|0
suffix:semicolon
id|m-&gt;min.bufRemains
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|m-&gt;min.ep-&gt;lock
comma
id|flagsep
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|m-&gt;min.ep-&gt;urbSubmitted
)paren
)paren
(brace
multiline_comment|/* urb-&gt;dev must be reinitialized on 2.4.x kernels */
id|m-&gt;min.ep-&gt;urb-&gt;dev
op_assign
id|m-&gt;min.ep-&gt;usbdev
suffix:semicolon
r_if
c_cond
(paren
id|usb_submit_urb
c_func
(paren
id|m-&gt;min.ep-&gt;urb
comma
id|GFP_ATOMIC
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;usbmidi: Cannot submit urb for MIDI-IN&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|m-&gt;min.ep-&gt;urbSubmitted
op_assign
l_int|1
suffix:semicolon
)brace
id|m-&gt;open_mode
op_or_assign
id|FMODE_READ
suffix:semicolon
id|succeed
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
op_logical_and
id|m-&gt;mout.ep
op_ne
l_int|NULL
)paren
(brace
id|m-&gt;mout.bufPtr
op_assign
l_int|0
suffix:semicolon
id|m-&gt;mout.bufRemains
op_assign
l_int|0
suffix:semicolon
id|m-&gt;mout.isInExclusive
op_assign
l_int|0
suffix:semicolon
id|m-&gt;mout.lastEvent
op_assign
l_int|0
suffix:semicolon
id|m-&gt;open_mode
op_or_assign
id|FMODE_WRITE
suffix:semicolon
id|succeed
op_assign
l_int|1
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|s-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|s-&gt;count
op_increment
suffix:semicolon
id|up
c_func
(paren
op_amp
id|open_sem
)paren
suffix:semicolon
multiline_comment|/** Changed to prevent extra increments to USE_COUNT. **/
r_if
c_cond
(paren
op_logical_neg
id|succeed
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
macro_line|#if 0
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;usb-midi: Open Succeeded. minor= %d.&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
multiline_comment|/** Success. **/
)brace
multiline_comment|/** Basic operation on /dev/midiXX as registered through struct file_operations.&n; *&n; *  Basic contract: Close an opened file and deallocate anything we allocated.&n; *  Like open(), this can be missing. If open set file-&gt;private_data,&n; *  release() must clear it.&n; *&n; **/
DECL|function|usb_midi_release
r_static
r_int
id|usb_midi_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|usb_mididev
op_star
id|m
op_assign
(paren
r_struct
id|usb_mididev
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|usb_midi_state
op_star
id|s
op_assign
(paren
r_struct
id|usb_midi_state
op_star
)paren
id|m-&gt;midi
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;usb-midi: Close.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|down
c_func
(paren
op_amp
id|open_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m-&gt;open_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|m-&gt;open_mode
op_and_assign
op_complement
id|FMODE_WRITE
suffix:semicolon
id|usb_unlink_urb
c_func
(paren
id|m-&gt;mout.ep-&gt;urb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|m-&gt;open_mode
op_amp
id|FMODE_READ
)paren
(brace
r_int
r_int
r_int
id|flagsep
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|m-&gt;min.ep-&gt;lock
comma
id|flagsep
)paren
suffix:semicolon
id|m-&gt;min.ep-&gt;cables
(braket
id|m-&gt;min.cableId
)braket
op_assign
l_int|NULL
suffix:semicolon
singleline_comment|// discard cable
id|m-&gt;min.ep-&gt;readers
op_sub_assign
l_int|1
suffix:semicolon
id|m-&gt;open_mode
op_and_assign
op_complement
id|FMODE_READ
suffix:semicolon
r_if
c_cond
(paren
id|m-&gt;min.ep-&gt;readers
op_eq
l_int|0
op_logical_and
id|m-&gt;min.ep-&gt;urbSubmitted
)paren
(brace
id|m-&gt;min.ep-&gt;urbSubmitted
op_assign
l_int|0
suffix:semicolon
id|usb_unlink_urb
c_func
(paren
id|m-&gt;min.ep-&gt;urb
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|m-&gt;min.ep-&gt;lock
comma
id|flagsep
)paren
suffix:semicolon
)brace
id|s-&gt;count
op_decrement
suffix:semicolon
id|up
c_func
(paren
op_amp
id|open_sem
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|open_wait
)paren
suffix:semicolon
id|file-&gt;private_data
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|usb_midi_fops
r_static
r_struct
id|file_operations
id|usb_midi_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|llseek
op_assign
id|usb_midi_llseek
comma
dot
id|read
op_assign
id|usb_midi_read
comma
dot
id|write
op_assign
id|usb_midi_write
comma
dot
id|poll
op_assign
id|usb_midi_poll
comma
dot
id|open
op_assign
id|usb_midi_open
comma
dot
id|release
op_assign
id|usb_midi_release
comma
)brace
suffix:semicolon
multiline_comment|/* ------------------------------------------------------------------------- */
multiline_comment|/** Returns filled midi_in_endpoint structure or null on failure.&n; *&n; * Parameters:&n; *&t;d        - a usb_device&n; *&t;endPoint - An usb endpoint in the range 0 to 15.&n; * Called by allocUsbMidiDev();&n; *&n; **/
DECL|function|alloc_midi_in_endpoint
r_static
r_struct
id|midi_in_endpoint
op_star
id|alloc_midi_in_endpoint
c_func
(paren
r_struct
id|usb_device
op_star
id|d
comma
r_int
id|endPoint
)paren
(brace
r_struct
id|midi_in_endpoint
op_star
id|ep
suffix:semicolon
r_int
id|bufSize
suffix:semicolon
r_int
id|pipe
suffix:semicolon
id|endPoint
op_and_assign
l_int|0x0f
suffix:semicolon
multiline_comment|/* Silently force endPoint to lie in range 0 to 15. */
id|pipe
op_assign
id|usb_rcvbulkpipe
c_func
(paren
id|d
comma
id|endPoint
)paren
suffix:semicolon
id|bufSize
op_assign
id|usb_maxpacket
c_func
(paren
id|d
comma
id|pipe
comma
id|usb_pipein
c_func
(paren
id|pipe
)paren
)paren
suffix:semicolon
multiline_comment|/* usb_pipein() = ! usb_pipeout() = true for an in Endpoint */
id|ep
op_assign
(paren
r_struct
id|midi_in_endpoint
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|midi_in_endpoint
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;usbmidi: no memory for midi in-endpoint&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ep
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|midi_in_endpoint
)paren
)paren
suffix:semicolon
singleline_comment|//      this sets cables[] and readers to 0, too.
singleline_comment|//      for (i=0; i&lt;16; i++) ep-&gt;cables[i] = 0; // discard cable
singleline_comment|//      ep-&gt;readers = 0;
id|ep-&gt;endpoint
op_assign
id|endPoint
suffix:semicolon
id|ep-&gt;recvBuf
op_assign
(paren
r_int
r_char
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_int
r_char
)paren
op_star
(paren
id|bufSize
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep-&gt;recvBuf
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;usbmidi: no memory for midi in-endpoint buffer&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ep
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|ep-&gt;urb
op_assign
id|usb_alloc_urb
c_func
(paren
l_int|0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/* no ISO */
r_if
c_cond
(paren
op_logical_neg
id|ep-&gt;urb
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;usbmidi: no memory for midi in-endpoint urb&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ep-&gt;recvBuf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ep
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|usb_fill_bulk_urb
c_func
(paren
id|ep-&gt;urb
comma
id|d
comma
id|usb_rcvbulkpipe
c_func
(paren
id|d
comma
id|endPoint
)paren
comma
(paren
r_int
r_char
op_star
)paren
id|ep-&gt;recvBuf
comma
id|bufSize
comma
id|usb_bulk_read
comma
id|ep
)paren
suffix:semicolon
multiline_comment|/* ep-&gt;bufRdPtr     = 0; */
multiline_comment|/* ep-&gt;bufWrPtr     = 0; */
multiline_comment|/* ep-&gt;bufRemains   = 0; */
multiline_comment|/* ep-&gt;urbSubmitted = 0; */
id|ep-&gt;recvBufSize
op_assign
id|bufSize
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|ep-&gt;wait
)paren
suffix:semicolon
r_return
id|ep
suffix:semicolon
)brace
DECL|function|remove_midi_in_endpoint
r_static
r_int
id|remove_midi_in_endpoint
c_func
(paren
r_struct
id|midi_in_endpoint
op_star
id|min
)paren
(brace
id|usb_unlink_urb
c_func
(paren
id|min-&gt;urb
)paren
suffix:semicolon
id|usb_free_urb
c_func
(paren
id|min-&gt;urb
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|min-&gt;recvBuf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|min
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/** Returns filled midi_out_endpoint structure or null on failure.&n; *&n; * Parameters:&n; *&t;d        - a usb_device&n; *&t;endPoint - An usb endpoint in the range 0 to 15.&n; * Called by allocUsbMidiDev();&n; *&n; **/
DECL|function|alloc_midi_out_endpoint
r_static
r_struct
id|midi_out_endpoint
op_star
id|alloc_midi_out_endpoint
c_func
(paren
r_struct
id|usb_device
op_star
id|d
comma
r_int
id|endPoint
)paren
(brace
r_struct
id|midi_out_endpoint
op_star
id|ep
op_assign
l_int|NULL
suffix:semicolon
r_int
id|pipe
suffix:semicolon
r_int
id|bufSize
suffix:semicolon
id|endPoint
op_and_assign
l_int|0x0f
suffix:semicolon
id|pipe
op_assign
id|usb_sndbulkpipe
c_func
(paren
id|d
comma
id|endPoint
)paren
suffix:semicolon
id|bufSize
op_assign
id|usb_maxpacket
c_func
(paren
id|d
comma
id|pipe
comma
id|usb_pipeout
c_func
(paren
id|pipe
)paren
)paren
suffix:semicolon
id|ep
op_assign
(paren
r_struct
id|midi_out_endpoint
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|midi_out_endpoint
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;usbmidi: no memory for midi out-endpoint&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ep
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|midi_out_endpoint
)paren
)paren
suffix:semicolon
id|ep-&gt;endpoint
op_assign
id|endPoint
suffix:semicolon
id|ep-&gt;buf
op_assign
(paren
r_int
r_char
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_int
r_char
)paren
op_star
id|bufSize
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep-&gt;buf
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;usbmidi: no memory for midi out-endpoint buffer&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ep
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|ep-&gt;urb
op_assign
id|usb_alloc_urb
c_func
(paren
l_int|0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/* no ISO */
r_if
c_cond
(paren
op_logical_neg
id|ep-&gt;urb
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;usbmidi: no memory for midi out-endpoint urb&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ep-&gt;buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ep
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|ep-&gt;bufSize
op_assign
id|bufSize
suffix:semicolon
multiline_comment|/* ep-&gt;bufWrPtr      = 0; */
id|init_waitqueue_head
c_func
(paren
op_amp
id|ep-&gt;wait
)paren
suffix:semicolon
r_return
id|ep
suffix:semicolon
)brace
DECL|function|remove_midi_out_endpoint
r_static
r_int
id|remove_midi_out_endpoint
c_func
(paren
r_struct
id|midi_out_endpoint
op_star
id|mout
)paren
(brace
id|usb_unlink_urb
c_func
(paren
id|mout-&gt;urb
)paren
suffix:semicolon
id|usb_free_urb
c_func
(paren
id|mout-&gt;urb
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mout-&gt;buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mout
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/** Returns a filled usb_mididev structure, registered as a Linux MIDI device.&n; *&n; * Returns null if memory is not available or the device cannot be registered.&n; * Called by allocUsbMidiDev();&n; *&n; **/
DECL|function|allocMidiDev
r_static
r_struct
id|usb_mididev
op_star
id|allocMidiDev
c_func
(paren
r_struct
id|usb_midi_state
op_star
id|s
comma
r_struct
id|midi_in_endpoint
op_star
id|min
comma
r_struct
id|midi_out_endpoint
op_star
id|mout
comma
r_int
id|inCableId
comma
r_int
id|outCableId
)paren
(brace
r_struct
id|usb_mididev
op_star
id|m
suffix:semicolon
id|m
op_assign
(paren
r_struct
id|usb_mididev
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|usb_mididev
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|m
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;usbmidi: no memory for midi device&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|m
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|usb_mididev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|m-&gt;dev_midi
op_assign
id|register_sound_midi
c_func
(paren
op_amp
id|usb_midi_fops
comma
op_minus
l_int|1
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;usbmidi: cannot register midi device&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|m
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|m-&gt;midi
op_assign
id|s
suffix:semicolon
multiline_comment|/* m-&gt;open_mode          = 0; */
r_if
c_cond
(paren
id|min
)paren
(brace
id|m-&gt;min.ep
op_assign
id|min
suffix:semicolon
id|m-&gt;min.ep-&gt;usbdev
op_assign
id|s-&gt;usbdev
suffix:semicolon
id|m-&gt;min.cableId
op_assign
id|inCableId
suffix:semicolon
)brace
multiline_comment|/* m-&gt;min.bufPtr         = 0; */
multiline_comment|/* m-&gt;min.bufRemains     = 0; */
r_if
c_cond
(paren
id|mout
)paren
(brace
id|m-&gt;mout.ep
op_assign
id|mout
suffix:semicolon
id|m-&gt;mout.ep-&gt;usbdev
op_assign
id|s-&gt;usbdev
suffix:semicolon
id|m-&gt;mout.cableId
op_assign
id|outCableId
suffix:semicolon
)brace
multiline_comment|/* m-&gt;mout.bufPtr        = 0; */
multiline_comment|/* m-&gt;mout.bufRemains    = 0; */
multiline_comment|/* m-&gt;mout.isInExclusive = 0; */
multiline_comment|/* m-&gt;mout.lastEvent     = 0; */
id|m-&gt;singlebyte
op_assign
id|singlebyte
suffix:semicolon
r_return
id|m
suffix:semicolon
)brace
DECL|function|release_midi_device
r_static
r_void
id|release_midi_device
c_func
(paren
r_struct
id|usb_midi_state
op_star
id|s
)paren
(brace
r_struct
id|usb_mididev
op_star
id|m
suffix:semicolon
r_struct
id|midi_in_endpoint
op_star
id|min
suffix:semicolon
r_struct
id|midi_out_endpoint
op_star
id|mout
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;count
OG
l_int|0
)paren
(brace
id|up
c_func
(paren
op_amp
id|open_sem
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|open_sem
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|open_wait
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|s-&gt;inEndpointList
)paren
)paren
(brace
id|min
op_assign
id|list_entry
c_func
(paren
id|s-&gt;inEndpointList.next
comma
r_struct
id|midi_in_endpoint
comma
id|list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|min-&gt;list
)paren
suffix:semicolon
id|remove_midi_in_endpoint
c_func
(paren
id|min
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|s-&gt;outEndpointList
)paren
)paren
(brace
id|mout
op_assign
id|list_entry
c_func
(paren
id|s-&gt;outEndpointList.next
comma
r_struct
id|midi_out_endpoint
comma
id|list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|mout-&gt;list
)paren
suffix:semicolon
id|remove_midi_out_endpoint
c_func
(paren
id|mout
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|s-&gt;midiDevList
)paren
)paren
(brace
id|m
op_assign
id|list_entry
c_func
(paren
id|s-&gt;midiDevList.next
comma
r_struct
id|usb_mididev
comma
id|list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|m-&gt;list
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|m
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|s
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* ------------------------------------------------------------------------- */
multiline_comment|/** Utility routine to find a descriptor in a dump of many descriptors.&n; * Returns start of descriptor or NULL if not found. &n; * descStart pointer to list of interfaces.&n; * descLength length (in bytes) of dump&n; * after (ignored if NULL) this routine returns only descriptors after &quot;after&quot;&n; * dtype (mandatory) The descriptor type.&n; * iface (ignored if -1) returns descriptor at/following given interface&n; * altSetting (ignored if -1) returns descriptor at/following given altSetting&n; *&n; *&n; *  Called by parseDescriptor(), find_csinterface_descriptor();&n; *&n; */
DECL|function|find_descriptor
r_static
r_void
op_star
id|find_descriptor
c_func
(paren
r_void
op_star
id|descStart
comma
r_int
r_int
id|descLength
comma
r_void
op_star
id|after
comma
r_int
r_char
id|dtype
comma
r_int
id|iface
comma
r_int
id|altSetting
)paren
(brace
r_int
r_char
op_star
id|p
comma
op_star
id|end
comma
op_star
id|next
suffix:semicolon
r_int
id|interfaceNumber
op_assign
op_minus
l_int|1
comma
id|altSet
op_assign
op_minus
l_int|1
suffix:semicolon
id|p
op_assign
id|descStart
suffix:semicolon
id|end
op_assign
id|p
op_plus
id|descLength
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|p
OL
id|end
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|p
(braket
l_int|0
)braket
OL
l_int|2
)paren
r_return
l_int|NULL
suffix:semicolon
id|next
op_assign
id|p
op_plus
id|p
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|next
OG
id|end
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|p
(braket
l_int|1
)braket
op_eq
id|USB_DT_INTERFACE
)paren
(brace
r_if
c_cond
(paren
id|p
(braket
l_int|0
)braket
OL
id|USB_DT_INTERFACE_SIZE
)paren
r_return
l_int|NULL
suffix:semicolon
id|interfaceNumber
op_assign
id|p
(braket
l_int|2
)braket
suffix:semicolon
id|altSet
op_assign
id|p
(braket
l_int|3
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p
(braket
l_int|1
)braket
op_eq
id|dtype
op_logical_and
(paren
op_logical_neg
id|after
op_logical_or
(paren
id|p
OG
(paren
r_int
r_char
op_star
)paren
id|after
)paren
)paren
op_logical_and
(paren
(paren
id|iface
op_eq
op_minus
l_int|1
)paren
op_logical_or
(paren
id|iface
op_eq
id|interfaceNumber
)paren
)paren
op_logical_and
(paren
(paren
id|altSetting
op_eq
op_minus
l_int|1
)paren
op_logical_or
(paren
id|altSetting
op_eq
id|altSet
)paren
)paren
)paren
(brace
r_return
id|p
suffix:semicolon
)brace
id|p
op_assign
id|next
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/** Utility to find a class-specific interface descriptor.&n; *  dsubtype is a descriptor subtype&n; *  Called by parseDescriptor();&n; **/
DECL|function|find_csinterface_descriptor
r_static
r_void
op_star
id|find_csinterface_descriptor
c_func
(paren
r_void
op_star
id|descStart
comma
r_int
r_int
id|descLength
comma
r_void
op_star
id|after
comma
id|u8
id|dsubtype
comma
r_int
id|iface
comma
r_int
id|altSetting
)paren
(brace
r_int
r_char
op_star
id|p
suffix:semicolon
id|p
op_assign
id|find_descriptor
c_func
(paren
id|descStart
comma
id|descLength
comma
id|after
comma
id|USB_DT_CS_INTERFACE
comma
id|iface
comma
id|altSetting
)paren
suffix:semicolon
r_while
c_loop
(paren
id|p
)paren
(brace
r_if
c_cond
(paren
id|p
(braket
l_int|0
)braket
op_ge
l_int|3
op_logical_and
id|p
(braket
l_int|2
)braket
op_eq
id|dsubtype
)paren
r_return
id|p
suffix:semicolon
id|p
op_assign
id|find_descriptor
c_func
(paren
id|descStart
comma
id|descLength
comma
id|p
comma
id|USB_DT_CS_INTERFACE
comma
id|iface
comma
id|altSetting
)paren
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/** The magic of making a new usb_midi_device from config happens here.&n; *&n; * The caller is responsible for free-ing this return value (if not NULL).&n; *&n; **/
DECL|function|parse_descriptor
r_static
r_struct
id|usb_midi_device
op_star
id|parse_descriptor
c_func
(paren
r_struct
id|usb_device
op_star
id|d
comma
r_int
r_char
op_star
id|buffer
comma
r_int
id|bufSize
comma
r_int
r_int
id|ifnum
comma
r_int
r_int
id|altSetting
comma
r_int
id|quirks
)paren
(brace
r_struct
id|usb_midi_device
op_star
id|u
suffix:semicolon
r_int
r_char
op_star
id|p1
suffix:semicolon
r_int
r_char
op_star
id|p2
suffix:semicolon
r_int
r_char
op_star
id|next
suffix:semicolon
r_int
id|iep
comma
id|oep
suffix:semicolon
r_int
id|length
suffix:semicolon
r_int
r_int
id|longBits
suffix:semicolon
r_int
id|pins
comma
id|nbytes
comma
id|offset
comma
id|shift
comma
id|jack
suffix:semicolon
macro_line|#ifdef HAVE_JACK_STRINGS
multiline_comment|/** Jacks can have associated names.  **/
r_int
r_char
id|jack2string
(braket
l_int|256
)braket
suffix:semicolon
macro_line|#endif
id|u
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* find audiocontrol interface */
id|p1
op_assign
id|find_csinterface_descriptor
c_func
(paren
id|buffer
comma
id|bufSize
comma
l_int|NULL
comma
id|MS_HEADER
comma
id|ifnum
comma
id|altSetting
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p1
)paren
(brace
r_goto
id|error_end
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p1
(braket
l_int|0
)braket
OL
id|MS_HEADER_LENGTH
)paren
(brace
r_goto
id|error_end
suffix:semicolon
)brace
multiline_comment|/* Assume success. Since the device corresponds to USB-MIDI spec, we assume&n;&t;   that the rest of the USB 2.0 spec is obeyed. */
id|u
op_assign
(paren
r_struct
id|usb_midi_device
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|usb_midi_device
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|u
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|u-&gt;deviceName
op_assign
l_int|NULL
suffix:semicolon
id|u-&gt;idVendor
op_assign
id|d-&gt;descriptor.idVendor
suffix:semicolon
id|u-&gt;idProduct
op_assign
id|d-&gt;descriptor.idProduct
suffix:semicolon
id|u-&gt;interface
op_assign
id|ifnum
suffix:semicolon
id|u-&gt;altSetting
op_assign
id|altSetting
suffix:semicolon
id|u-&gt;in
(braket
l_int|0
)braket
dot
id|endpoint
op_assign
op_minus
l_int|1
suffix:semicolon
id|u-&gt;in
(braket
l_int|0
)braket
dot
id|cableId
op_assign
op_minus
l_int|1
suffix:semicolon
id|u-&gt;out
(braket
l_int|0
)braket
dot
id|endpoint
op_assign
op_minus
l_int|1
suffix:semicolon
id|u-&gt;out
(braket
l_int|0
)braket
dot
id|cableId
op_assign
op_minus
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;usb-midi: Found MIDIStreaming device corresponding to Release %d.%02d of spec.&bslash;n&quot;
comma
(paren
id|p1
(braket
l_int|4
)braket
op_rshift
l_int|4
)paren
op_star
l_int|10
op_plus
(paren
id|p1
(braket
l_int|4
)braket
op_amp
l_int|0x0f
)paren
comma
(paren
id|p1
(braket
l_int|3
)braket
op_rshift
l_int|4
)paren
op_star
l_int|10
op_plus
(paren
id|p1
(braket
l_int|3
)braket
op_amp
l_int|0x0f
)paren
)paren
suffix:semicolon
id|length
op_assign
id|p1
(braket
l_int|5
)braket
op_or
(paren
id|p1
(braket
l_int|6
)braket
op_lshift
l_int|8
)paren
suffix:semicolon
macro_line|#ifdef HAVE_JACK_STRINGS
id|memset
c_func
(paren
id|jack2string
comma
l_int|0
comma
r_sizeof
(paren
r_int
r_char
)paren
op_star
l_int|256
)paren
suffix:semicolon
macro_line|#endif
id|length
op_sub_assign
id|p1
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|p2
op_assign
id|p1
op_plus
id|p1
(braket
l_int|0
)braket
suffix:semicolon
id|length
OG
l_int|0
suffix:semicolon
id|p2
op_assign
id|next
)paren
(brace
id|next
op_assign
id|p2
op_plus
id|p2
(braket
l_int|0
)braket
suffix:semicolon
id|length
op_sub_assign
id|p2
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|p2
(braket
l_int|0
)braket
OL
l_int|2
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|p2
(braket
l_int|1
)braket
op_ne
id|USB_DT_CS_INTERFACE
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|p2
(braket
l_int|2
)braket
op_eq
id|MIDI_IN_JACK
op_logical_and
id|p2
(braket
l_int|0
)braket
op_ge
l_int|6
)paren
(brace
id|jack
op_assign
id|p2
(braket
l_int|4
)braket
suffix:semicolon
macro_line|#ifdef HAVE_JACK_STRINGS
id|jack2string
(braket
id|jack
)braket
op_assign
id|p2
(braket
l_int|5
)braket
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;usb-midi: Found IN Jack 0x%02x %s&bslash;n&quot;
comma
id|jack
comma
(paren
id|p2
(braket
l_int|3
)braket
op_eq
id|EMBEDDED_JACK
)paren
ques
c_cond
l_string|&quot;EMBEDDED&quot;
suffix:colon
l_string|&quot;EXTERNAL&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|p2
(braket
l_int|2
)braket
op_eq
id|MIDI_OUT_JACK
op_logical_and
id|p2
(braket
l_int|0
)braket
op_ge
l_int|6
)paren
(brace
id|pins
op_assign
id|p2
(braket
l_int|5
)braket
suffix:semicolon
r_if
c_cond
(paren
id|p2
(braket
l_int|0
)braket
OL
(paren
l_int|6
op_plus
l_int|2
op_star
id|pins
)paren
)paren
r_continue
suffix:semicolon
id|jack
op_assign
id|p2
(braket
l_int|4
)braket
suffix:semicolon
macro_line|#ifdef HAVE_JACK_STRINGS
id|jack2string
(braket
id|jack
)braket
op_assign
id|p2
(braket
l_int|5
op_plus
l_int|2
op_star
id|pins
)braket
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;usb-midi: Found OUT Jack 0x%02x %s, %d pins&bslash;n&quot;
comma
id|jack
comma
(paren
id|p2
(braket
l_int|3
)braket
op_eq
id|EMBEDDED_JACK
)paren
ques
c_cond
l_string|&quot;EMBEDDED&quot;
suffix:colon
l_string|&quot;EXTERNAL&quot;
comma
id|pins
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|p2
(braket
l_int|2
)braket
op_eq
id|ELEMENT_DESCRIPTOR
op_logical_and
id|p2
(braket
l_int|0
)braket
op_ge
l_int|10
)paren
(brace
id|pins
op_assign
id|p2
(braket
l_int|4
)braket
suffix:semicolon
r_if
c_cond
(paren
id|p2
(braket
l_int|0
)braket
OL
(paren
l_int|9
op_plus
l_int|2
op_star
id|pins
)paren
)paren
r_continue
suffix:semicolon
id|nbytes
op_assign
id|p2
(braket
l_int|8
op_plus
l_int|2
op_star
id|pins
)braket
suffix:semicolon
r_if
c_cond
(paren
id|p2
(braket
l_int|0
)braket
OL
(paren
l_int|10
op_plus
l_int|2
op_star
id|pins
op_plus
id|nbytes
)paren
)paren
r_continue
suffix:semicolon
id|longBits
op_assign
l_int|0L
suffix:semicolon
r_for
c_loop
(paren
id|offset
op_assign
l_int|0
comma
id|shift
op_assign
l_int|0
suffix:semicolon
id|offset
OL
id|nbytes
op_logical_and
id|offset
OL
l_int|8
suffix:semicolon
id|offset
op_increment
comma
id|shift
op_add_assign
l_int|8
)paren
(brace
id|longBits
op_or_assign
(paren
(paren
r_int
)paren
(paren
id|p2
(braket
l_int|9
op_plus
l_int|2
op_star
id|pins
op_plus
id|offset
)braket
)paren
)paren
op_lshift
id|shift
suffix:semicolon
)brace
id|jack
op_assign
id|p2
(braket
l_int|3
)braket
suffix:semicolon
macro_line|#ifdef HAVE_JACK_STRINGS
id|jack2string
(braket
id|jack
)braket
op_assign
id|p2
(braket
l_int|9
op_plus
l_int|2
op_star
id|pins
op_plus
id|nbytes
)braket
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;usb-midi: Found ELEMENT 0x%02x, %d/%d pins in/out, bits: 0x%016lx&bslash;n&quot;
comma
id|jack
comma
id|pins
comma
(paren
r_int
)paren
(paren
id|p2
(braket
l_int|5
op_plus
l_int|2
op_star
id|pins
)braket
)paren
comma
(paren
r_int
)paren
id|longBits
)paren
suffix:semicolon
)brace
r_else
(brace
)brace
)brace
id|iep
op_assign
l_int|0
suffix:semicolon
id|oep
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|quirks
op_eq
l_int|0
)paren
(brace
multiline_comment|/* MIDISTREAM */
id|p2
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|p1
op_assign
id|find_descriptor
c_func
(paren
id|buffer
comma
id|bufSize
comma
l_int|NULL
comma
id|USB_DT_ENDPOINT
comma
id|ifnum
comma
id|altSetting
)paren
suffix:semicolon
id|p1
suffix:semicolon
id|p1
op_assign
id|next
)paren
(brace
id|next
op_assign
id|find_descriptor
c_func
(paren
id|buffer
comma
id|bufSize
comma
id|p1
comma
id|USB_DT_ENDPOINT
comma
id|ifnum
comma
id|altSetting
)paren
suffix:semicolon
id|p2
op_assign
id|find_descriptor
c_func
(paren
id|buffer
comma
id|bufSize
comma
id|p1
comma
id|USB_DT_CS_ENDPOINT
comma
id|ifnum
comma
id|altSetting
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p2
op_logical_and
id|next
op_logical_and
(paren
id|p2
OG
id|next
)paren
)paren
id|p2
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|p1
(braket
l_int|0
)braket
OL
l_int|9
op_logical_or
op_logical_neg
id|p2
op_logical_or
id|p2
(braket
l_int|0
)braket
OL
l_int|4
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p1
(braket
l_int|2
)braket
op_amp
l_int|0x80
)paren
op_eq
l_int|0x80
)paren
(brace
r_if
c_cond
(paren
id|iep
OL
l_int|15
)paren
(brace
id|pins
op_assign
id|p2
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* not pins -- actually &quot;cables&quot; */
r_if
c_cond
(paren
id|pins
OG
l_int|16
)paren
id|pins
op_assign
l_int|16
suffix:semicolon
id|u-&gt;in
(braket
id|iep
)braket
dot
id|endpoint
op_assign
id|p1
(braket
l_int|2
)braket
suffix:semicolon
id|u-&gt;in
(braket
id|iep
)braket
dot
id|cableId
op_assign
(paren
l_int|1
op_lshift
id|pins
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|u-&gt;in
(braket
id|iep
)braket
dot
id|cableId
)paren
id|iep
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|iep
OL
l_int|15
)paren
(brace
id|u-&gt;in
(braket
id|iep
)braket
dot
id|endpoint
op_assign
op_minus
l_int|1
suffix:semicolon
id|u-&gt;in
(braket
id|iep
)braket
dot
id|cableId
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|oep
OL
l_int|15
)paren
(brace
id|pins
op_assign
id|p2
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* not pins -- actually &quot;cables&quot; */
r_if
c_cond
(paren
id|pins
OG
l_int|16
)paren
id|pins
op_assign
l_int|16
suffix:semicolon
id|u-&gt;out
(braket
id|oep
)braket
dot
id|endpoint
op_assign
id|p1
(braket
l_int|2
)braket
suffix:semicolon
id|u-&gt;out
(braket
id|oep
)braket
dot
id|cableId
op_assign
(paren
l_int|1
op_lshift
id|pins
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|u-&gt;out
(braket
id|oep
)braket
dot
id|cableId
)paren
id|oep
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|oep
OL
l_int|15
)paren
(brace
id|u-&gt;out
(braket
id|oep
)braket
dot
id|endpoint
op_assign
op_minus
l_int|1
suffix:semicolon
id|u-&gt;out
(braket
id|oep
)braket
dot
id|cableId
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|quirks
op_eq
l_int|1
)paren
(brace
multiline_comment|/* YAMAHA quirks */
r_for
c_loop
(paren
id|p1
op_assign
id|find_descriptor
c_func
(paren
id|buffer
comma
id|bufSize
comma
l_int|NULL
comma
id|USB_DT_ENDPOINT
comma
id|ifnum
comma
id|altSetting
)paren
suffix:semicolon
id|p1
suffix:semicolon
id|p1
op_assign
id|next
)paren
(brace
id|next
op_assign
id|find_descriptor
c_func
(paren
id|buffer
comma
id|bufSize
comma
id|p1
comma
id|USB_DT_ENDPOINT
comma
id|ifnum
comma
id|altSetting
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p1
(braket
l_int|0
)braket
OL
l_int|7
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p1
(braket
l_int|2
)braket
op_amp
l_int|0x80
)paren
op_eq
l_int|0x80
)paren
(brace
r_if
c_cond
(paren
id|iep
OL
l_int|15
)paren
(brace
id|pins
op_assign
id|iep
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|pins
OG
l_int|16
)paren
id|pins
op_assign
l_int|16
suffix:semicolon
id|u-&gt;in
(braket
id|iep
)braket
dot
id|endpoint
op_assign
id|p1
(braket
l_int|2
)braket
suffix:semicolon
id|u-&gt;in
(braket
id|iep
)braket
dot
id|cableId
op_assign
(paren
l_int|1
op_lshift
id|pins
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|u-&gt;in
(braket
id|iep
)braket
dot
id|cableId
)paren
id|iep
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|iep
OL
l_int|15
)paren
(brace
id|u-&gt;in
(braket
id|iep
)braket
dot
id|endpoint
op_assign
op_minus
l_int|1
suffix:semicolon
id|u-&gt;in
(braket
id|iep
)braket
dot
id|cableId
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|oep
OL
l_int|15
)paren
(brace
id|pins
op_assign
id|oep
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|pins
OG
l_int|16
)paren
id|pins
op_assign
l_int|16
suffix:semicolon
id|u-&gt;out
(braket
id|oep
)braket
dot
id|endpoint
op_assign
id|p1
(braket
l_int|2
)braket
suffix:semicolon
id|u-&gt;out
(braket
id|oep
)braket
dot
id|cableId
op_assign
(paren
l_int|1
op_lshift
id|pins
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|u-&gt;out
(braket
id|oep
)braket
dot
id|cableId
)paren
id|oep
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|oep
OL
l_int|15
)paren
(brace
id|u-&gt;out
(braket
id|oep
)braket
dot
id|endpoint
op_assign
op_minus
l_int|1
suffix:semicolon
id|u-&gt;out
(braket
id|oep
)braket
dot
id|cableId
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|iep
op_logical_and
op_logical_neg
id|oep
)paren
(brace
r_goto
id|error_end
suffix:semicolon
)brace
r_return
id|u
suffix:semicolon
id|error_end
suffix:colon
id|kfree
c_func
(paren
id|u
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* ------------------------------------------------------------------------- */
multiline_comment|/** Returns number between 0 and 16.&n; *&n; **/
DECL|function|on_bits
r_static
r_int
id|on_bits
c_func
(paren
r_int
r_int
id|v
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|v
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
id|ret
op_increment
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/** USB-device will be interrogated for altSetting.&n; *&n; * Returns negative on error.&n; * Called by allocUsbMidiDev();&n; *&n; **/
DECL|function|get_alt_setting
r_static
r_int
id|get_alt_setting
c_func
(paren
r_struct
id|usb_device
op_star
id|d
comma
r_int
id|ifnum
)paren
(brace
r_int
id|alts
comma
id|alt
op_assign
l_int|0
suffix:semicolon
r_struct
id|usb_interface
op_star
id|iface
suffix:semicolon
r_struct
id|usb_host_interface
op_star
id|interface
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|ep
suffix:semicolon
r_int
id|epin
comma
id|epout
suffix:semicolon
r_int
id|i
suffix:semicolon
id|iface
op_assign
id|usb_ifnum_to_if
c_func
(paren
id|d
comma
id|ifnum
)paren
suffix:semicolon
id|alts
op_assign
id|iface-&gt;num_altsetting
suffix:semicolon
r_for
c_loop
(paren
id|alt
op_assign
l_int|0
suffix:semicolon
id|alt
OL
id|alts
suffix:semicolon
id|alt
op_increment
)paren
(brace
id|interface
op_assign
op_amp
id|iface-&gt;altsetting
(braket
id|alt
)braket
suffix:semicolon
id|epin
op_assign
op_minus
l_int|1
suffix:semicolon
id|epout
op_assign
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|interface-&gt;desc.bNumEndpoints
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ep
op_assign
op_amp
id|interface-&gt;endpoint
(braket
id|i
)braket
dot
id|desc
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ep-&gt;bmAttributes
op_amp
id|USB_ENDPOINT_XFERTYPE_MASK
)paren
op_ne
id|USB_ENDPOINT_XFER_BULK
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ep-&gt;bEndpointAddress
op_amp
id|USB_DIR_IN
)paren
op_logical_and
id|epin
OL
l_int|0
)paren
(brace
id|epin
op_assign
id|i
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|epout
OL
l_int|0
)paren
(brace
id|epout
op_assign
id|i
suffix:semicolon
)brace
r_if
c_cond
(paren
id|epin
op_ge
l_int|0
op_logical_and
id|epout
op_ge
l_int|0
)paren
(brace
r_return
id|interface-&gt;desc.bAlternateSetting
suffix:semicolon
)brace
)brace
)brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* ------------------------------------------------------------------------- */
multiline_comment|/** Returns 0 if successful in allocating and registering internal structures.&n; * Returns negative on failure.&n; * Calls allocMidiDev which additionally registers /dev/midiXX devices.&n; * Writes messages on success to indicate which /dev/midiXX is which physical&n; * endpoint.&n; *&n; **/
DECL|function|alloc_usb_midi_device
r_static
r_int
id|alloc_usb_midi_device
c_func
(paren
r_struct
id|usb_device
op_star
id|d
comma
r_struct
id|usb_midi_state
op_star
id|s
comma
r_struct
id|usb_midi_device
op_star
id|u
)paren
(brace
r_struct
id|usb_mididev
op_star
op_star
id|mdevs
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|midi_in_endpoint
op_star
id|mins
(braket
l_int|15
)braket
comma
op_star
id|min
suffix:semicolon
r_struct
id|midi_out_endpoint
op_star
id|mouts
(braket
l_int|15
)braket
comma
op_star
id|mout
suffix:semicolon
r_int
id|inDevs
op_assign
l_int|0
comma
id|outDevs
op_assign
l_int|0
suffix:semicolon
r_int
id|inEndpoints
op_assign
l_int|0
comma
id|outEndpoints
op_assign
l_int|0
suffix:semicolon
r_int
id|inEndpoint
comma
id|outEndpoint
suffix:semicolon
r_int
id|inCableId
comma
id|outCableId
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|devices
op_assign
l_int|0
suffix:semicolon
r_int
id|alt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Obtain altSetting or die.. */
id|alt
op_assign
id|u-&gt;altSetting
suffix:semicolon
r_if
c_cond
(paren
id|alt
OL
l_int|0
)paren
(brace
id|alt
op_assign
id|get_alt_setting
c_func
(paren
id|d
comma
id|u-&gt;interface
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|alt
OL
l_int|0
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
multiline_comment|/* Configure interface */
r_if
c_cond
(paren
id|usb_set_interface
c_func
(paren
id|d
comma
id|u-&gt;interface
comma
id|alt
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|15
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mins
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|mouts
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Begin Allocation */
r_while
c_loop
(paren
id|inEndpoints
OL
l_int|15
op_logical_and
id|inDevs
OL
id|maxdevices
op_logical_and
id|u-&gt;in
(braket
id|inEndpoints
)braket
dot
id|cableId
op_ge
l_int|0
)paren
(brace
id|inDevs
op_add_assign
id|on_bits
c_func
(paren
(paren
r_int
r_int
)paren
id|u-&gt;in
(braket
id|inEndpoints
)braket
dot
id|cableId
)paren
suffix:semicolon
id|mins
(braket
id|inEndpoints
)braket
op_assign
id|alloc_midi_in_endpoint
c_func
(paren
id|d
comma
id|u-&gt;in
(braket
id|inEndpoints
)braket
dot
id|endpoint
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mins
(braket
id|inEndpoints
)braket
op_eq
l_int|NULL
)paren
r_goto
id|error_end
suffix:semicolon
id|inEndpoints
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|outEndpoints
OL
l_int|15
op_logical_and
id|outDevs
OL
id|maxdevices
op_logical_and
id|u-&gt;out
(braket
id|outEndpoints
)braket
dot
id|cableId
op_ge
l_int|0
)paren
(brace
id|outDevs
op_add_assign
id|on_bits
c_func
(paren
(paren
r_int
r_int
)paren
id|u-&gt;out
(braket
id|outEndpoints
)braket
dot
id|cableId
)paren
suffix:semicolon
id|mouts
(braket
id|outEndpoints
)braket
op_assign
id|alloc_midi_out_endpoint
c_func
(paren
id|d
comma
id|u-&gt;out
(braket
id|outEndpoints
)braket
dot
id|endpoint
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mouts
(braket
id|outEndpoints
)braket
op_eq
l_int|NULL
)paren
r_goto
id|error_end
suffix:semicolon
id|outEndpoints
op_increment
suffix:semicolon
)brace
id|devices
op_assign
id|inDevs
OG
id|outDevs
ques
c_cond
id|inDevs
suffix:colon
id|outDevs
suffix:semicolon
id|devices
op_assign
id|maxdevices
OG
id|devices
ques
c_cond
id|devices
suffix:colon
id|maxdevices
suffix:semicolon
multiline_comment|/* obtain space for device name (iProduct) if not known. */
r_if
c_cond
(paren
op_logical_neg
id|u-&gt;deviceName
)paren
(brace
id|mdevs
op_assign
(paren
r_struct
id|usb_mididev
op_star
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|usb_mididevs
op_star
)paren
op_star
id|devices
op_plus
r_sizeof
(paren
r_char
)paren
op_star
l_int|256
comma
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
r_else
(brace
id|mdevs
op_assign
(paren
r_struct
id|usb_mididev
op_star
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|usb_mididevs
op_star
)paren
op_star
id|devices
comma
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|mdevs
)paren
(brace
multiline_comment|/* devices = 0; */
multiline_comment|/* mdevs = NULL; */
r_goto
id|error_end
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|devices
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mdevs
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* obtain device name (iProduct) if not known. */
r_if
c_cond
(paren
op_logical_neg
id|u-&gt;deviceName
)paren
(brace
id|u-&gt;deviceName
op_assign
(paren
r_char
op_star
)paren
(paren
id|mdevs
op_plus
id|devices
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|d-&gt;have_langid
op_logical_and
id|d-&gt;descriptor.iProduct
)paren
(brace
id|alt
op_assign
id|usb_get_string
c_func
(paren
id|d
comma
l_int|0
comma
l_int|0
comma
id|u-&gt;deviceName
comma
l_int|250
)paren
suffix:semicolon
r_if
c_cond
(paren
id|alt
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;error getting string descriptor 0 (error=%d)&bslash;n&quot;
comma
id|alt
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|u-&gt;deviceName
(braket
l_int|0
)braket
OL
l_int|4
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;string descriptor 0 too short (length = %d)&bslash;n&quot;
comma
id|alt
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;string descriptor 0 found (length = %d)&bslash;n&quot;
comma
id|alt
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|alt
op_ge
l_int|4
suffix:semicolon
id|alt
op_sub_assign
l_int|2
)paren
(brace
id|i
op_assign
id|u-&gt;deviceName
(braket
id|alt
op_minus
l_int|2
)braket
op_or
(paren
id|u-&gt;deviceName
(braket
id|alt
op_minus
l_int|1
)braket
op_lshift
l_int|8
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;usb-midi: langid(%d) 0x%04x&bslash;n&quot;
comma
(paren
id|alt
op_minus
l_int|4
)paren
op_rshift
l_int|1
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|i
op_xor
id|ulangid
)paren
op_amp
l_int|0xff
)paren
op_eq
l_int|0
)paren
(brace
id|d-&gt;have_langid
op_assign
l_int|1
suffix:semicolon
id|d-&gt;string_langid
op_assign
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;usb-midi: langid(match) 0x%04x&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|ulangid
)paren
r_break
suffix:semicolon
)brace
)brace
)brace
)brace
id|u-&gt;deviceName
(braket
l_int|0
)braket
op_assign
(paren
r_char
)paren
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;descriptor.iProduct
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;usb-midi: fetchString(%d)&bslash;n&quot;
comma
id|d-&gt;descriptor.iProduct
)paren
suffix:semicolon
id|alt
op_assign
id|usb_string
c_func
(paren
id|d
comma
id|d-&gt;descriptor.iProduct
comma
id|u-&gt;deviceName
comma
l_int|255
)paren
suffix:semicolon
r_if
c_cond
(paren
id|alt
OL
l_int|0
)paren
(brace
id|u-&gt;deviceName
(braket
l_int|0
)braket
op_assign
(paren
r_char
)paren
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;usb-midi: fetchString = %d&bslash;n&quot;
comma
id|alt
)paren
suffix:semicolon
)brace
multiline_comment|/* Failsafe */
r_if
c_cond
(paren
op_logical_neg
id|u-&gt;deviceName
(braket
l_int|0
)braket
)paren
(brace
r_if
c_cond
(paren
id|d-&gt;descriptor.idVendor
op_eq
id|USB_VENDOR_ID_ROLAND
)paren
(brace
id|strcpy
c_func
(paren
id|u-&gt;deviceName
comma
l_string|&quot;Unknown Roland&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|d-&gt;descriptor.idVendor
op_eq
id|USB_VENDOR_ID_STEINBERG
)paren
(brace
id|strcpy
c_func
(paren
id|u-&gt;deviceName
comma
l_string|&quot;Unknown Steinberg&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|d-&gt;descriptor.idVendor
op_eq
id|USB_VENDOR_ID_YAMAHA
)paren
(brace
id|strcpy
c_func
(paren
id|u-&gt;deviceName
comma
l_string|&quot;Unknown Yamaha&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|strcpy
c_func
(paren
id|u-&gt;deviceName
comma
l_string|&quot;Unknown&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
id|inEndpoint
op_assign
l_int|0
suffix:semicolon
id|inCableId
op_assign
op_minus
l_int|1
suffix:semicolon
id|outEndpoint
op_assign
l_int|0
suffix:semicolon
id|outCableId
op_assign
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|devices
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|inCableId
op_increment
suffix:semicolon
id|inEndpoint
OL
l_int|15
op_logical_and
id|mins
(braket
id|inEndpoint
)braket
op_logical_and
op_logical_neg
(paren
id|u-&gt;in
(braket
id|inEndpoint
)braket
dot
id|cableId
op_amp
(paren
l_int|1
op_lshift
id|inCableId
)paren
)paren
suffix:semicolon
id|inCableId
op_increment
)paren
(brace
r_if
c_cond
(paren
id|inCableId
op_ge
l_int|16
)paren
(brace
id|inEndpoint
op_increment
suffix:semicolon
id|inCableId
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|min
op_assign
id|mins
(braket
id|inEndpoint
)braket
suffix:semicolon
r_for
c_loop
(paren
id|outCableId
op_increment
suffix:semicolon
id|outEndpoint
OL
l_int|15
op_logical_and
id|mouts
(braket
id|outEndpoint
)braket
op_logical_and
op_logical_neg
(paren
id|u-&gt;out
(braket
id|outEndpoint
)braket
dot
id|cableId
op_amp
(paren
l_int|1
op_lshift
id|outCableId
)paren
)paren
suffix:semicolon
id|outCableId
op_increment
)paren
(brace
r_if
c_cond
(paren
id|outCableId
op_ge
l_int|16
)paren
(brace
id|outEndpoint
op_increment
suffix:semicolon
id|outCableId
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|mout
op_assign
id|mouts
(braket
id|outEndpoint
)braket
suffix:semicolon
id|mdevs
(braket
id|i
)braket
op_assign
id|allocMidiDev
c_func
(paren
id|s
comma
id|min
comma
id|mout
comma
id|inCableId
comma
id|outCableId
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mdevs
(braket
id|i
)braket
op_eq
l_int|NULL
)paren
r_goto
id|error_end
suffix:semicolon
)brace
multiline_comment|/* Success! */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|devices
suffix:semicolon
id|i
op_increment
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
id|mdevs
(braket
id|i
)braket
op_member_access_from_pointer
id|list
comma
op_amp
id|s-&gt;midiDevList
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|inEndpoints
suffix:semicolon
id|i
op_increment
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
id|mins
(braket
id|i
)braket
op_member_access_from_pointer
id|list
comma
op_amp
id|s-&gt;inEndpointList
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|outEndpoints
suffix:semicolon
id|i
op_increment
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
id|mouts
(braket
id|i
)braket
op_member_access_from_pointer
id|list
comma
op_amp
id|s-&gt;outEndpointList
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;usbmidi: found [ %s ] (0x%04x:0x%04x), attached:&bslash;n&quot;
comma
id|u-&gt;deviceName
comma
id|u-&gt;idVendor
comma
id|u-&gt;idProduct
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|devices
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|dm
op_assign
(paren
id|mdevs
(braket
id|i
)braket
op_member_access_from_pointer
id|dev_midi
op_minus
l_int|2
)paren
op_rshift
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|mdevs
(braket
id|i
)braket
op_member_access_from_pointer
id|mout.ep
op_ne
l_int|NULL
op_logical_and
id|mdevs
(braket
id|i
)braket
op_member_access_from_pointer
id|min.ep
op_ne
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;usbmidi: /dev/midi%02d: in (ep:%02x cid:%2d bufsiz:%2d) out (ep:%02x cid:%2d bufsiz:%2d)&bslash;n&quot;
comma
id|dm
comma
id|mdevs
(braket
id|i
)braket
op_member_access_from_pointer
id|min.ep-&gt;endpoint
op_or
id|USB_DIR_IN
comma
id|mdevs
(braket
id|i
)braket
op_member_access_from_pointer
id|min.cableId
comma
id|mdevs
(braket
id|i
)braket
op_member_access_from_pointer
id|min.ep-&gt;recvBufSize
comma
id|mdevs
(braket
id|i
)braket
op_member_access_from_pointer
id|mout.ep-&gt;endpoint
comma
id|mdevs
(braket
id|i
)braket
op_member_access_from_pointer
id|mout.cableId
comma
id|mdevs
(braket
id|i
)braket
op_member_access_from_pointer
id|mout.ep-&gt;bufSize
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|mdevs
(braket
id|i
)braket
op_member_access_from_pointer
id|min.ep
op_ne
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;usbmidi: /dev/midi%02d: in (ep:%02x cid:%2d bufsiz:%02d)&bslash;n&quot;
comma
id|dm
comma
id|mdevs
(braket
id|i
)braket
op_member_access_from_pointer
id|min.ep-&gt;endpoint
op_or
id|USB_DIR_IN
comma
id|mdevs
(braket
id|i
)braket
op_member_access_from_pointer
id|min.cableId
comma
id|mdevs
(braket
id|i
)braket
op_member_access_from_pointer
id|min.ep-&gt;recvBufSize
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|mdevs
(braket
id|i
)braket
op_member_access_from_pointer
id|mout.ep
op_ne
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;usbmidi: /dev/midi%02d: out (ep:%02x cid:%2d bufsiz:%02d)&bslash;n&quot;
comma
id|dm
comma
id|mdevs
(braket
id|i
)braket
op_member_access_from_pointer
id|mout.ep-&gt;endpoint
comma
id|mdevs
(braket
id|i
)braket
op_member_access_from_pointer
id|mout.cableId
comma
id|mdevs
(braket
id|i
)braket
op_member_access_from_pointer
id|mout.ep-&gt;bufSize
)paren
suffix:semicolon
)brace
)brace
id|kfree
c_func
(paren
id|mdevs
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error_end
suffix:colon
r_if
c_cond
(paren
id|mdevs
op_ne
l_int|NULL
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|devices
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mdevs
(braket
id|i
)braket
op_ne
l_int|NULL
)paren
(brace
id|unregister_sound_midi
c_func
(paren
id|mdevs
(braket
id|i
)braket
op_member_access_from_pointer
id|dev_midi
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mdevs
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
id|kfree
c_func
(paren
id|mdevs
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|15
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mins
(braket
id|i
)braket
op_ne
l_int|NULL
)paren
(brace
id|remove_midi_in_endpoint
c_func
(paren
id|mins
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mouts
(braket
id|i
)braket
op_ne
l_int|NULL
)paren
(brace
id|remove_midi_out_endpoint
c_func
(paren
id|mouts
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* ------------------------------------------------------------------------- */
multiline_comment|/** Attempt to scan YAMAHA&squot;s device descriptor and detect correct values of&n; *  them.&n; *  Return 0 on succes, negative on failure.&n; *  Called by usb_midi_probe();&n; **/
DECL|function|detect_yamaha_device
r_static
r_int
id|detect_yamaha_device
c_func
(paren
r_struct
id|usb_device
op_star
id|d
comma
r_struct
id|usb_interface
op_star
id|iface
comma
r_int
r_int
id|ifnum
comma
r_struct
id|usb_midi_state
op_star
id|s
)paren
(brace
r_struct
id|usb_host_interface
op_star
id|interface
suffix:semicolon
r_struct
id|usb_midi_device
op_star
id|u
suffix:semicolon
r_int
r_char
op_star
id|buffer
suffix:semicolon
r_int
id|bufSize
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|alts
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;descriptor.idVendor
op_ne
id|USB_VENDOR_ID_YAMAHA
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|iface-&gt;num_altsetting
suffix:semicolon
id|i
op_increment
)paren
(brace
id|interface
op_assign
id|iface-&gt;altsetting
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|interface-&gt;desc.bInterfaceClass
op_ne
l_int|255
op_logical_or
id|interface-&gt;desc.bInterfaceSubClass
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
id|alts
op_assign
id|interface-&gt;desc.bAlternateSetting
suffix:semicolon
)brace
r_if
c_cond
(paren
id|alts
op_eq
op_minus
l_int|1
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;usb-midi: Found YAMAHA USB-MIDI device on dev %04x:%04x, iface %d&bslash;n&quot;
comma
id|d-&gt;descriptor.idVendor
comma
id|d-&gt;descriptor.idProduct
comma
id|ifnum
)paren
suffix:semicolon
id|i
op_assign
id|d-&gt;actconfig
op_minus
id|d-&gt;config
suffix:semicolon
id|buffer
op_assign
id|d-&gt;rawdescriptors
(braket
id|i
)braket
suffix:semicolon
id|bufSize
op_assign
id|d-&gt;actconfig-&gt;desc.wTotalLength
suffix:semicolon
id|u
op_assign
id|parse_descriptor
c_func
(paren
id|d
comma
id|buffer
comma
id|bufSize
comma
id|ifnum
comma
id|alts
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|u
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ret
op_assign
id|alloc_usb_midi_device
c_func
(paren
id|d
comma
id|s
comma
id|u
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|u
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/** Scan table of known devices which are only partially compliant with &n; * the MIDIStreaming specification.&n; * Called by usb_midi_probe();&n; *&n; **/
DECL|function|detect_vendor_specific_device
r_static
r_int
id|detect_vendor_specific_device
c_func
(paren
r_struct
id|usb_device
op_star
id|d
comma
r_int
r_int
id|ifnum
comma
r_struct
id|usb_midi_state
op_star
id|s
)paren
(brace
r_struct
id|usb_midi_device
op_star
id|u
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|VENDOR_SPECIFIC_USB_MIDI_DEVICES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|u
op_assign
op_amp
(paren
id|usb_midi_devices
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;descriptor.idVendor
op_ne
id|u-&gt;idVendor
op_logical_or
id|d-&gt;descriptor.idProduct
op_ne
id|u-&gt;idProduct
op_logical_or
id|ifnum
op_ne
id|u-&gt;interface
)paren
r_continue
suffix:semicolon
id|ret
op_assign
id|alloc_usb_midi_device
c_func
(paren
id|d
comma
id|s
comma
id|u
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/** Attempt to match any config of an interface to a MIDISTREAMING interface.&n; *  Returns 0 on success, negative on failure.&n; * Called by usb_midi_probe();&n; **/
DECL|function|detect_midi_subclass
r_static
r_int
id|detect_midi_subclass
c_func
(paren
r_struct
id|usb_device
op_star
id|d
comma
r_struct
id|usb_interface
op_star
id|iface
comma
r_int
r_int
id|ifnum
comma
r_struct
id|usb_midi_state
op_star
id|s
)paren
(brace
r_struct
id|usb_host_interface
op_star
id|interface
suffix:semicolon
r_struct
id|usb_midi_device
op_star
id|u
suffix:semicolon
r_int
r_char
op_star
id|buffer
suffix:semicolon
r_int
id|bufSize
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|alts
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|iface-&gt;num_altsetting
suffix:semicolon
id|i
op_increment
)paren
(brace
id|interface
op_assign
id|iface-&gt;altsetting
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|interface-&gt;desc.bInterfaceClass
op_ne
id|USB_CLASS_AUDIO
op_logical_or
id|interface-&gt;desc.bInterfaceSubClass
op_ne
id|USB_SUBCLASS_MIDISTREAMING
)paren
r_continue
suffix:semicolon
id|alts
op_assign
id|interface-&gt;desc.bAlternateSetting
suffix:semicolon
)brace
r_if
c_cond
(paren
id|alts
op_eq
op_minus
l_int|1
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;usb-midi: Found MIDISTREAMING on dev %04x:%04x, iface %d&bslash;n&quot;
comma
id|d-&gt;descriptor.idVendor
comma
id|d-&gt;descriptor.idProduct
comma
id|ifnum
)paren
suffix:semicolon
multiline_comment|/* From USB Spec v2.0, Section 9.5.&n;&t;   If the class or vendor specific descriptors use the same format&n;&t;   as standard descriptors (e.g., start with a length byte and&n;&t;   followed by a type byte), they must be returned interleaved with&n;&t;   standard descriptors in the configuration information returned by&n;&t;   a GetDescriptor(Configuration) request. In this case, the class&n;&t;   or vendor-specific descriptors must follow a related standard&n;&t;   descriptor they modify or extend.&n;&t;*/
id|i
op_assign
id|d-&gt;actconfig
op_minus
id|d-&gt;config
suffix:semicolon
id|buffer
op_assign
id|d-&gt;rawdescriptors
(braket
id|i
)braket
suffix:semicolon
id|bufSize
op_assign
id|d-&gt;actconfig-&gt;desc.wTotalLength
suffix:semicolon
id|u
op_assign
id|parse_descriptor
c_func
(paren
id|d
comma
id|buffer
comma
id|bufSize
comma
id|ifnum
comma
id|alts
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|u
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ret
op_assign
id|alloc_usb_midi_device
c_func
(paren
id|d
comma
id|s
comma
id|u
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|u
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/** When user has requested a specific device, match it exactly.&n; *&n; * Uses uvendor, uproduct, uinterface, ualt, umin, umout and ucable.&n; * Called by usb_midi_probe();&n; *&n; **/
DECL|function|detect_by_hand
r_static
r_int
id|detect_by_hand
c_func
(paren
r_struct
id|usb_device
op_star
id|d
comma
r_int
r_int
id|ifnum
comma
r_struct
id|usb_midi_state
op_star
id|s
)paren
(brace
r_struct
id|usb_midi_device
id|u
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;descriptor.idVendor
op_ne
id|uvendor
op_logical_or
id|d-&gt;descriptor.idProduct
op_ne
id|uproduct
op_logical_or
id|ifnum
op_ne
id|uinterface
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ualt
OL
l_int|0
)paren
id|ualt
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|umin
template_param
l_int|15
)paren
id|umin
op_assign
l_int|0x01
op_or
id|USB_DIR_IN
suffix:semicolon
r_if
c_cond
(paren
id|umout
template_param
l_int|15
)paren
id|umout
op_assign
l_int|0x01
suffix:semicolon
r_if
c_cond
(paren
id|ucable
template_param
l_int|15
)paren
id|ucable
op_assign
l_int|0
suffix:semicolon
id|u.deviceName
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* A flag for alloc_usb_midi_device to get device&n;&t;&t;&t;&t;name from device. */
id|u.idVendor
op_assign
id|uvendor
suffix:semicolon
id|u.idProduct
op_assign
id|uproduct
suffix:semicolon
id|u.interface
op_assign
id|uinterface
suffix:semicolon
id|u.altSetting
op_assign
id|ualt
suffix:semicolon
id|u.in
(braket
l_int|0
)braket
dot
id|endpoint
op_assign
id|umin
suffix:semicolon
id|u.in
(braket
l_int|0
)braket
dot
id|cableId
op_assign
(paren
l_int|1
op_lshift
id|ucable
)paren
suffix:semicolon
id|u.out
(braket
l_int|0
)braket
dot
id|endpoint
op_assign
id|umout
suffix:semicolon
id|u.out
(braket
l_int|0
)braket
dot
id|cableId
op_assign
(paren
l_int|1
op_lshift
id|ucable
)paren
suffix:semicolon
r_return
id|alloc_usb_midi_device
c_func
(paren
id|d
comma
id|s
comma
op_amp
id|u
)paren
suffix:semicolon
)brace
multiline_comment|/* ------------------------------------------------------------------------- */
DECL|function|usb_midi_probe
r_static
r_int
id|usb_midi_probe
c_func
(paren
r_struct
id|usb_interface
op_star
id|intf
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
(brace
r_struct
id|usb_midi_state
op_star
id|s
suffix:semicolon
r_struct
id|usb_device
op_star
id|dev
op_assign
id|interface_to_usbdev
c_func
(paren
id|intf
)paren
suffix:semicolon
r_int
id|ifnum
op_assign
id|intf-&gt;cur_altsetting-&gt;desc.bInterfaceNumber
suffix:semicolon
id|s
op_assign
(paren
r_struct
id|usb_midi_state
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|usb_midi_state
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|s
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|usb_midi_state
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|s-&gt;midiDevList
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|s-&gt;inEndpointList
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|s-&gt;outEndpointList
)paren
suffix:semicolon
id|s-&gt;usbdev
op_assign
id|dev
suffix:semicolon
id|s-&gt;count
op_assign
l_int|0
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|s-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|detect_by_hand
c_func
(paren
id|dev
comma
id|ifnum
comma
id|s
)paren
op_logical_and
id|detect_midi_subclass
c_func
(paren
id|dev
comma
id|intf
comma
id|ifnum
comma
id|s
)paren
op_logical_and
id|detect_vendor_specific_device
c_func
(paren
id|dev
comma
id|ifnum
comma
id|s
)paren
op_logical_and
id|detect_yamaha_device
c_func
(paren
id|dev
comma
id|intf
comma
id|ifnum
comma
id|s
)paren
)paren
(brace
id|kfree
c_func
(paren
id|s
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|open_sem
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|s-&gt;mididev
comma
op_amp
id|mididevs
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|open_sem
)paren
suffix:semicolon
id|usb_set_intfdata
(paren
id|intf
comma
id|s
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usb_midi_disconnect
r_static
r_void
id|usb_midi_disconnect
c_func
(paren
r_struct
id|usb_interface
op_star
id|intf
)paren
(brace
r_struct
id|usb_midi_state
op_star
id|s
op_assign
id|usb_get_intfdata
(paren
id|intf
)paren
suffix:semicolon
r_struct
id|list_head
op_star
id|list
suffix:semicolon
r_struct
id|usb_mididev
op_star
id|m
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|s
op_eq
(paren
r_struct
id|usb_midi_state
op_star
)paren
op_minus
l_int|1
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;usbdev
)paren
(brace
r_return
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|open_sem
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|s-&gt;mididev
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|s-&gt;mididev
)paren
suffix:semicolon
id|s-&gt;usbdev
op_assign
l_int|NULL
suffix:semicolon
id|usb_set_intfdata
(paren
id|intf
comma
l_int|NULL
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|list
comma
op_amp
id|s-&gt;midiDevList
)paren
(brace
id|m
op_assign
id|list_entry
c_func
(paren
id|list
comma
r_struct
id|usb_mididev
comma
id|list
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
(paren
id|m-&gt;min.ep-&gt;wait
)paren
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
(paren
id|m-&gt;mout.ep-&gt;wait
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m-&gt;dev_midi
op_ge
l_int|0
)paren
(brace
id|unregister_sound_midi
c_func
(paren
id|m-&gt;dev_midi
)paren
suffix:semicolon
)brace
id|m-&gt;dev_midi
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|release_midi_device
c_func
(paren
id|s
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|open_wait
)paren
suffix:semicolon
)brace
multiline_comment|/* we want to look at all devices by hand */
DECL|variable|id_table
r_static
r_struct
id|usb_device_id
id|id_table
(braket
)braket
op_assign
(brace
(brace
dot
id|driver_info
op_assign
l_int|42
)brace
comma
(brace
)brace
)brace
suffix:semicolon
DECL|variable|usb_midi_driver
r_static
r_struct
id|usb_driver
id|usb_midi_driver
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|name
op_assign
l_string|&quot;midi&quot;
comma
dot
id|probe
op_assign
id|usb_midi_probe
comma
dot
id|disconnect
op_assign
id|usb_midi_disconnect
comma
dot
id|id_table
op_assign
id|id_table
comma
)brace
suffix:semicolon
multiline_comment|/* ------------------------------------------------------------------------- */
DECL|function|usb_midi_init
r_static
r_int
id|__init
id|usb_midi_init
c_func
(paren
r_void
)paren
(brace
r_return
id|usb_register
c_func
(paren
op_amp
id|usb_midi_driver
)paren
suffix:semicolon
)brace
DECL|function|usb_midi_exit
r_static
r_void
id|__exit
id|usb_midi_exit
c_func
(paren
r_void
)paren
(brace
id|usb_deregister
c_func
(paren
op_amp
id|usb_midi_driver
)paren
suffix:semicolon
)brace
DECL|variable|usb_midi_init
id|module_init
c_func
(paren
id|usb_midi_init
)paren
suffix:semicolon
DECL|variable|usb_midi_exit
id|module_exit
c_func
(paren
id|usb_midi_exit
)paren
suffix:semicolon
macro_line|#ifdef HAVE_ALSA_SUPPORT
DECL|macro|SNDRV_MAIN_OBJECT_FILE
mdefine_line|#define SNDRV_MAIN_OBJECT_FILE
macro_line|#include &quot;../../include/driver.h&quot;
macro_line|#include &quot;../../include/control.h&quot;
macro_line|#include &quot;../../include/info.h&quot;
macro_line|#include &quot;../../include/cs46xx.h&quot;
multiline_comment|/* ------------------------------------------------------------------------- */
DECL|function|snd_usbmidi_input_close
r_static
r_int
id|snd_usbmidi_input_close
c_func
(paren
id|snd_rawmidi_substream_t
op_star
id|substream
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|snd_usbmidi_input_open
r_static
r_int
id|snd_usbmidi_input_open
c_func
(paren
id|snd_rawmidi_substream_t
op_star
id|substream
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|snd_usbmidi_input_trigger
r_static
r_void
id|snd_usbmidi_input_trigger
c_func
(paren
id|snd_rawmidi_substream_t
op_star
id|substream
comma
r_int
id|up
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ------------------------------------------------------------------------- */
DECL|function|snd_usbmidi_output_close
r_static
r_int
id|snd_usbmidi_output_close
c_func
(paren
id|snd_rawmidi_substream_t
op_star
id|substream
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|snd_usbmidi_output_open
r_static
r_int
id|snd_usbmidi_output_open
c_func
(paren
id|snd_rawmidi_substream_t
op_star
id|substream
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|snd_usb_midi_output_trigger
r_static
r_void
id|snd_usb_midi_output_trigger
c_func
(paren
id|snd_rawmidi_substream_t
op_star
id|substream
comma
r_int
id|up
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ------------------------------------------------------------------------- */
DECL|variable|snd_usbmidi_output
r_static
id|snd_rawmidi_ops_t
id|snd_usbmidi_output
op_assign
(brace
dot
id|open
op_assign
id|snd_usbmidi_output_open
comma
dot
id|close
op_assign
id|snd_usbmidi_output_close
comma
dot
id|trigger
op_assign
id|snd_usbmidi_output_trigger
comma
)brace
suffix:semicolon
DECL|variable|snd_usbmidi_input
r_static
id|snd_rawmidi_ops_t
id|snd_usbmidi_input
op_assign
(brace
dot
id|open
op_assign
id|snd_usbmidi_input_open
comma
dot
id|close
op_assign
id|snd_usbmidi_input_close
comma
dot
id|trigger
op_assign
id|snd_usbmidi_input_trigger
comma
)brace
suffix:semicolon
DECL|function|snd_usbmidi_midi
r_int
id|snd_usbmidi_midi
c_func
(paren
id|cs46xx_t
op_star
id|chip
comma
r_int
id|device
comma
id|snd_rawmidi_t
op_star
op_star
id|rrawmidi
)paren
(brace
id|snd_rawmidi_t
op_star
id|rmidi
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|rrawmidi
)paren
op_star
id|rrawmidi
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|snd_rawmidi_new
c_func
(paren
id|chip-&gt;card
comma
l_string|&quot;USB-MIDI&quot;
comma
id|device
comma
l_int|1
comma
l_int|1
comma
op_amp
id|rmidi
)paren
)paren
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|strcpy
c_func
(paren
id|rmidi-&gt;name
comma
l_string|&quot;USB-MIDI&quot;
)paren
suffix:semicolon
id|snd_rawmidi_set_ops
c_func
(paren
id|rmidi
comma
id|SNDRV_RAWMIDI_STREAM_OUTPUT
comma
op_amp
id|snd_usbmidi_output
)paren
suffix:semicolon
id|snd_rawmidi_set_ops
c_func
(paren
id|rmidi
comma
id|SNDRV_RAWMIDI_STREAM_INPUT
comma
op_amp
id|snd_usbmidi_input
)paren
suffix:semicolon
id|rmidi-&gt;info_flags
op_or_assign
id|SNDRV_RAWMIDI_INFO_OUTPUT
op_or
id|SNDRV_RAWMIDI_INFO_INPUT
op_or
id|SNDRV_RAWMIDI_INFO_DUPLEX
suffix:semicolon
id|rmidi-&gt;private_data
op_assign
id|chip
suffix:semicolon
id|chip-&gt;rmidi
op_assign
id|rmidi
suffix:semicolon
r_if
c_cond
(paren
id|rrawmidi
)paren
op_star
id|rrawmidi
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|snd_usbmidi_create
r_int
id|snd_usbmidi_create
c_func
(paren
id|snd_card_t
op_star
id|card
comma
r_struct
id|pci_dev
op_star
id|pci
comma
id|usbmidi_t
op_star
op_star
id|rchip
)paren
(brace
id|usbmidi_t
op_star
id|chip
suffix:semicolon
r_int
id|err
comma
id|idx
suffix:semicolon
id|snd_region_t
op_star
id|region
suffix:semicolon
r_static
id|snd_device_opt_t
id|ops
op_assign
(brace
dot
id|dev_free
op_assign
id|snd_usbmidi_dev_free
comma
)brace
suffix:semicolon
op_star
id|rchip
op_assign
l_int|NULL
suffix:semicolon
id|chip
op_assign
id|snd_magic_kcalloc
c_func
(paren
id|usbmidi_t
comma
l_int|0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chip
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
DECL|variable|snd_usbmidi_create
id|EXPORT_SYMBOL
c_func
(paren
id|snd_usbmidi_create
)paren
suffix:semicolon
DECL|variable|snd_usbmidi_midi
id|EXPORT_SYMBOL
c_func
(paren
id|snd_usbmidi_midi
)paren
suffix:semicolon
macro_line|#endif /* HAVE_ALSA_SUPPORT */
eof
