multiline_comment|/*&n; * usblp.c  Version 0.13&n; *&n; * Copyright (c) 1999 Michael Gee&t;&lt;michael@linuxspecific.com&gt;&n; * Copyright (c) 1999 Pavel Machek&t;&lt;pavel@suse.cz&gt;&n; * Copyright (c) 2000 Randy Dunlap&t;&lt;rddunlap@osdl.org&gt;&n; * Copyright (c) 2000 Vojtech Pavlik&t;&lt;vojtech@suse.cz&gt;&n; # Copyright (c) 2001 Pete Zaitcev&t;&lt;zaitcev@redhat.com&gt;&n; # Copyright (c) 2001 David Paschal&t;&lt;paschal@rcsis.com&gt;&n; *&n; * USB Printer Device Class driver for USB printers and printer cables&n; *&n; * Sponsored by SuSE&n; *&n; * ChangeLog:&n; *&t;v0.1 - thorough cleaning, URBification, almost a rewrite&n; *&t;v0.2 - some more cleanups&n; *&t;v0.3 - cleaner again, waitqueue fixes&n; *&t;v0.4 - fixes in unidirectional mode&n; *&t;v0.5 - add DEVICE_ID string support&n; *&t;v0.6 - never time out&n; *&t;v0.7 - fixed bulk-IN read and poll (David Paschal)&n; *&t;v0.8 - add devfs support&n; *&t;v0.9 - fix unplug-while-open paths&n; *&t;v0.10- remove sleep_on, fix error on oom (oliver@neukum.org)&n; *&t;v0.11 - add proto_bias option (Pete Zaitcev)&n; *&t;v0.12 - add hpoj.sourceforge.net ioctls (David Paschal)&n; *&t;v0.13 - alloc space for statusbuf (&lt;status&gt; not on stack);&n; *&t;&t;use usb_buffer_alloc() for read buf &amp; write buf;&n; */
multiline_comment|/*&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/lp.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#include &lt;linux/usb.h&gt;
multiline_comment|/*&n; * Version Information&n; */
DECL|macro|DRIVER_VERSION
mdefine_line|#define DRIVER_VERSION &quot;v0.13&quot;
DECL|macro|DRIVER_AUTHOR
mdefine_line|#define DRIVER_AUTHOR &quot;Michael Gee, Pavel Machek, Vojtech Pavlik, Randy Dunlap, Pete Zaitcev, David Paschal&quot;
DECL|macro|DRIVER_DESC
mdefine_line|#define DRIVER_DESC &quot;USB Printer Device Class driver&quot;
DECL|macro|USBLP_BUF_SIZE
mdefine_line|#define USBLP_BUF_SIZE&t;&t;8192
DECL|macro|USBLP_DEVICE_ID_SIZE
mdefine_line|#define USBLP_DEVICE_ID_SIZE&t;1024
multiline_comment|/* ioctls: */
DECL|macro|LPGETSTATUS
mdefine_line|#define LPGETSTATUS&t;&t;0x060b&t;&t;/* same as in drivers/char/lp.c */
DECL|macro|IOCNR_GET_DEVICE_ID
mdefine_line|#define IOCNR_GET_DEVICE_ID&t;&t;1
DECL|macro|IOCNR_GET_PROTOCOLS
mdefine_line|#define IOCNR_GET_PROTOCOLS&t;&t;2
DECL|macro|IOCNR_SET_PROTOCOL
mdefine_line|#define IOCNR_SET_PROTOCOL&t;&t;3
DECL|macro|IOCNR_HP_SET_CHANNEL
mdefine_line|#define IOCNR_HP_SET_CHANNEL&t;&t;4
DECL|macro|IOCNR_GET_BUS_ADDRESS
mdefine_line|#define IOCNR_GET_BUS_ADDRESS&t;&t;5
DECL|macro|IOCNR_GET_VID_PID
mdefine_line|#define IOCNR_GET_VID_PID&t;&t;6
multiline_comment|/* Get device_id string: */
DECL|macro|LPIOC_GET_DEVICE_ID
mdefine_line|#define LPIOC_GET_DEVICE_ID(len) _IOC(_IOC_READ, &squot;P&squot;, IOCNR_GET_DEVICE_ID, len)
multiline_comment|/* The following ioctls were added for http://hpoj.sourceforge.net: */
multiline_comment|/* Get two-int array:&n; * [0]=current protocol (1=7/1/1, 2=7/1/2, 3=7/1/3),&n; * [1]=supported protocol mask (mask&amp;(1&lt;&lt;n)!=0 means 7/1/n supported): */
DECL|macro|LPIOC_GET_PROTOCOLS
mdefine_line|#define LPIOC_GET_PROTOCOLS(len) _IOC(_IOC_READ, &squot;P&squot;, IOCNR_GET_PROTOCOLS, len)
multiline_comment|/* Set protocol (arg: 1=7/1/1, 2=7/1/2, 3=7/1/3): */
DECL|macro|LPIOC_SET_PROTOCOL
mdefine_line|#define LPIOC_SET_PROTOCOL _IOC(_IOC_WRITE, &squot;P&squot;, IOCNR_SET_PROTOCOL, 0)
multiline_comment|/* Set channel number (HP Vendor-specific command): */
DECL|macro|LPIOC_HP_SET_CHANNEL
mdefine_line|#define LPIOC_HP_SET_CHANNEL _IOC(_IOC_WRITE, &squot;P&squot;, IOCNR_HP_SET_CHANNEL, 0)
multiline_comment|/* Get two-int array: [0]=bus number, [1]=device address: */
DECL|macro|LPIOC_GET_BUS_ADDRESS
mdefine_line|#define LPIOC_GET_BUS_ADDRESS(len) _IOC(_IOC_READ, &squot;P&squot;, IOCNR_GET_BUS_ADDRESS, len)
multiline_comment|/* Get two-int array: [0]=vendor ID, [1]=product ID: */
DECL|macro|LPIOC_GET_VID_PID
mdefine_line|#define LPIOC_GET_VID_PID(len) _IOC(_IOC_READ, &squot;P&squot;, IOCNR_GET_VID_PID, len)
multiline_comment|/*&n; * A DEVICE_ID string may include the printer&squot;s serial number.&n; * It should end with a semi-colon (&squot;;&squot;).&n; * An example from an HP 970C DeskJet printer is (this is one long string,&n; * with the serial number changed):&n;MFG:HEWLETT-PACKARD;MDL:DESKJET 970C;CMD:MLC,PCL,PML;CLASS:PRINTER;DESCRIPTION:Hewlett-Packard DeskJet 970C;SERN:US970CSEPROF;VSTATUS:$HB0$NC0,ff,DN,IDLE,CUT,K1,C0,DP,NR,KP000,CP027;VP:0800,FL,B0;VJ:                    ;&n; */
multiline_comment|/*&n; * USB Printer Requests&n; */
DECL|macro|USBLP_REQ_GET_ID
mdefine_line|#define USBLP_REQ_GET_ID&t;&t;&t;0x00
DECL|macro|USBLP_REQ_GET_STATUS
mdefine_line|#define USBLP_REQ_GET_STATUS&t;&t;&t;0x01
DECL|macro|USBLP_REQ_RESET
mdefine_line|#define USBLP_REQ_RESET&t;&t;&t;&t;0x02
DECL|macro|USBLP_REQ_HP_CHANNEL_CHANGE_REQUEST
mdefine_line|#define USBLP_REQ_HP_CHANNEL_CHANGE_REQUEST&t;0x00&t;/* HP Vendor-specific */
macro_line|#ifdef CONFIG_USB_DYNAMIC_MINORS
DECL|macro|USBLP_MINORS
mdefine_line|#define USBLP_MINORS&t;&t;256
macro_line|#else
DECL|macro|USBLP_MINORS
mdefine_line|#define USBLP_MINORS&t;&t;16
macro_line|#endif
DECL|macro|USBLP_MINOR_BASE
mdefine_line|#define USBLP_MINOR_BASE&t;0
DECL|macro|USBLP_WRITE_TIMEOUT
mdefine_line|#define USBLP_WRITE_TIMEOUT&t;(5*HZ)&t;&t;&t;/* 5 seconds */
DECL|macro|USBLP_FIRST_PROTOCOL
mdefine_line|#define USBLP_FIRST_PROTOCOL&t;1
DECL|macro|USBLP_LAST_PROTOCOL
mdefine_line|#define USBLP_LAST_PROTOCOL&t;3
DECL|macro|USBLP_MAX_PROTOCOLS
mdefine_line|#define USBLP_MAX_PROTOCOLS&t;(USBLP_LAST_PROTOCOL+1)
multiline_comment|/*&n; * some arbitrary status buffer size;&n; * need a status buffer that is allocated via kmalloc(), not on stack&n; */
DECL|macro|STATUS_BUF_SIZE
mdefine_line|#define STATUS_BUF_SIZE&t;&t;8
DECL|struct|usblp
r_struct
id|usblp
(brace
DECL|member|dev
r_struct
id|usb_device
op_star
id|dev
suffix:semicolon
multiline_comment|/* USB device */
DECL|member|devfs
id|devfs_handle_t
id|devfs
suffix:semicolon
multiline_comment|/* devfs device */
DECL|member|sem
r_struct
id|semaphore
id|sem
suffix:semicolon
multiline_comment|/* locks this struct, especially &quot;dev&quot; */
DECL|member|writebuf
r_char
op_star
id|writebuf
suffix:semicolon
multiline_comment|/* write transfer_buffer */
DECL|member|readbuf
r_char
op_star
id|readbuf
suffix:semicolon
multiline_comment|/* read transfer_buffer */
DECL|member|statusbuf
r_char
op_star
id|statusbuf
suffix:semicolon
multiline_comment|/* status transfer_buffer */
DECL|member|readurb
DECL|member|writeurb
r_struct
id|urb
op_star
id|readurb
comma
op_star
id|writeurb
suffix:semicolon
multiline_comment|/* The urbs */
DECL|member|wait
id|wait_queue_head_t
id|wait
suffix:semicolon
multiline_comment|/* Zzzzz ... */
DECL|member|readcount
r_int
id|readcount
suffix:semicolon
multiline_comment|/* Counter for reads */
DECL|member|ifnum
r_int
id|ifnum
suffix:semicolon
multiline_comment|/* Interface number */
multiline_comment|/* Alternate-setting numbers and endpoints for each protocol&n;&t; * (7/1/{index=1,2,3}) that the device supports: */
r_struct
(brace
DECL|member|alt_setting
r_int
id|alt_setting
suffix:semicolon
DECL|member|epwrite
r_struct
id|usb_endpoint_descriptor
op_star
id|epwrite
suffix:semicolon
DECL|member|epread
r_struct
id|usb_endpoint_descriptor
op_star
id|epread
suffix:semicolon
DECL|member|protocol
)brace
id|protocol
(braket
id|USBLP_MAX_PROTOCOLS
)braket
suffix:semicolon
DECL|member|current_protocol
r_int
id|current_protocol
suffix:semicolon
DECL|member|minor
r_int
id|minor
suffix:semicolon
multiline_comment|/* minor number of device */
DECL|member|wcomplete
r_int
id|wcomplete
suffix:semicolon
multiline_comment|/* writing is completed */
DECL|member|rcomplete
r_int
id|rcomplete
suffix:semicolon
multiline_comment|/* reading is completed */
DECL|member|quirks
r_int
r_int
id|quirks
suffix:semicolon
multiline_comment|/* quirks flags */
DECL|member|used
r_int
r_char
id|used
suffix:semicolon
multiline_comment|/* True if open */
DECL|member|bidir
r_int
r_char
id|bidir
suffix:semicolon
multiline_comment|/* interface is bidirectional */
DECL|member|device_id_string
r_int
r_char
op_star
id|device_id_string
suffix:semicolon
multiline_comment|/* IEEE 1284 DEVICE ID string (ptr) */
multiline_comment|/* first 2 bytes are (big-endian) length */
)brace
suffix:semicolon
macro_line|#ifdef DEBUG
DECL|function|usblp_dump
r_static
r_void
id|usblp_dump
c_func
(paren
r_struct
id|usblp
op_star
id|usblp
)paren
(brace
r_int
id|p
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;usblp=0x%p&quot;
comma
id|usblp
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;dev=0x%p&quot;
comma
id|usblp-&gt;dev
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;devfs=0x%p&quot;
comma
id|usblp-&gt;devfs
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;buf=0x%p&quot;
comma
id|usblp-&gt;buf
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;readcount=%d&quot;
comma
id|usblp-&gt;readcount
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;ifnum=%d&quot;
comma
id|usblp-&gt;ifnum
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|USBLP_FIRST_PROTOCOL
suffix:semicolon
id|p
op_le
id|USBLP_LAST_PROTOCOL
suffix:semicolon
id|p
op_increment
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;protocol[%d].alt_setting=%d&quot;
comma
id|p
comma
id|usblp-&gt;protocol
(braket
id|p
)braket
dot
id|alt_setting
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;protocol[%d].epwrite=%p&quot;
comma
id|p
comma
id|usblp-&gt;protocol
(braket
id|p
)braket
dot
id|epwrite
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;protocol[%d].epread=%p&quot;
comma
id|p
comma
id|usblp-&gt;protocol
(braket
id|p
)braket
dot
id|epread
)paren
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;current_protocol=%d&quot;
comma
id|usblp-&gt;current_protocol
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;minor=%d&quot;
comma
id|usblp-&gt;minor
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;wcomplete=%d&quot;
comma
id|usblp-&gt;wcomplete
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;rcomplete=%d&quot;
comma
id|usblp-&gt;rcomplete
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;quirks=%d&quot;
comma
id|usblp-&gt;quirks
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;used=%d&quot;
comma
id|usblp-&gt;used
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;bidir=%d&quot;
comma
id|usblp-&gt;bidir
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;device_id_string=&bslash;&quot;%s&bslash;&quot;&quot;
comma
id|usblp-&gt;device_id_string
ques
c_cond
id|usblp-&gt;device_id_string
op_plus
l_int|2
suffix:colon
(paren
r_int
r_char
op_star
)paren
l_string|&quot;(null)&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_extern
id|devfs_handle_t
id|usb_devfs_handle
suffix:semicolon
multiline_comment|/* /dev/usb dir. */
multiline_comment|/* Quirks: various printer quirks are handled by this table &amp; its flags. */
DECL|struct|quirk_printer_struct
r_struct
id|quirk_printer_struct
(brace
DECL|member|vendorId
id|__u16
id|vendorId
suffix:semicolon
DECL|member|productId
id|__u16
id|productId
suffix:semicolon
DECL|member|quirks
r_int
r_int
id|quirks
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|USBLP_QUIRK_BIDIR
mdefine_line|#define USBLP_QUIRK_BIDIR&t;0x1&t;/* reports bidir but requires unidirectional mode (no INs/reads) */
DECL|macro|USBLP_QUIRK_USB_INIT
mdefine_line|#define USBLP_QUIRK_USB_INIT&t;0x2&t;/* needs vendor USB init string */
DECL|variable|quirk_printers
r_static
r_struct
id|quirk_printer_struct
id|quirk_printers
(braket
)braket
op_assign
(brace
(brace
l_int|0x03f0
comma
l_int|0x0004
comma
id|USBLP_QUIRK_BIDIR
)brace
comma
multiline_comment|/* HP DeskJet 895C */
(brace
l_int|0x03f0
comma
l_int|0x0104
comma
id|USBLP_QUIRK_BIDIR
)brace
comma
multiline_comment|/* HP DeskJet 880C */
(brace
l_int|0x03f0
comma
l_int|0x0204
comma
id|USBLP_QUIRK_BIDIR
)brace
comma
multiline_comment|/* HP DeskJet 815C */
(brace
l_int|0x03f0
comma
l_int|0x0304
comma
id|USBLP_QUIRK_BIDIR
)brace
comma
multiline_comment|/* HP DeskJet 810C/812C */
(brace
l_int|0x03f0
comma
l_int|0x0404
comma
id|USBLP_QUIRK_BIDIR
)brace
comma
multiline_comment|/* HP DeskJet 830C */
(brace
l_int|0x03f0
comma
l_int|0x0504
comma
id|USBLP_QUIRK_BIDIR
)brace
comma
multiline_comment|/* HP DeskJet 885C */
(brace
l_int|0x03f0
comma
l_int|0x0604
comma
id|USBLP_QUIRK_BIDIR
)brace
comma
multiline_comment|/* HP DeskJet 840C */
(brace
l_int|0x03f0
comma
l_int|0x0804
comma
id|USBLP_QUIRK_BIDIR
)brace
comma
multiline_comment|/* HP DeskJet 816C */
(brace
l_int|0x03f0
comma
l_int|0x1104
comma
id|USBLP_QUIRK_BIDIR
)brace
comma
multiline_comment|/* HP Deskjet 959C */
(brace
l_int|0x0409
comma
l_int|0xefbe
comma
id|USBLP_QUIRK_BIDIR
)brace
comma
multiline_comment|/* NEC Picty900 (HP OEM) */
(brace
l_int|0x0409
comma
l_int|0xbef4
comma
id|USBLP_QUIRK_BIDIR
)brace
comma
multiline_comment|/* NEC Picty760 (HP OEM) */
(brace
l_int|0x0409
comma
l_int|0xf0be
comma
id|USBLP_QUIRK_BIDIR
)brace
comma
multiline_comment|/* NEC Picty920 (HP OEM) */
(brace
l_int|0x0409
comma
l_int|0xf1be
comma
id|USBLP_QUIRK_BIDIR
)brace
comma
multiline_comment|/* NEC Picty800 (HP OEM) */
(brace
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
r_static
r_int
id|usblp_select_alts
c_func
(paren
r_struct
id|usblp
op_star
id|usblp
)paren
suffix:semicolon
r_static
r_int
id|usblp_set_protocol
c_func
(paren
r_struct
id|usblp
op_star
id|usblp
comma
r_int
id|protocol
)paren
suffix:semicolon
r_static
r_int
id|usblp_cache_device_id_string
c_func
(paren
r_struct
id|usblp
op_star
id|usblp
)paren
suffix:semicolon
multiline_comment|/* forward reference to make our lives easier */
r_extern
r_struct
id|usb_driver
id|usblp_driver
suffix:semicolon
multiline_comment|/*&n; * Functions for usblp control messages.&n; */
DECL|function|usblp_ctrl_msg
r_static
r_int
id|usblp_ctrl_msg
c_func
(paren
r_struct
id|usblp
op_star
id|usblp
comma
r_int
id|request
comma
r_int
id|type
comma
r_int
id|dir
comma
r_int
id|recip
comma
r_int
id|value
comma
r_void
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_int
id|retval
op_assign
id|usb_control_msg
c_func
(paren
id|usblp-&gt;dev
comma
id|dir
ques
c_cond
id|usb_rcvctrlpipe
c_func
(paren
id|usblp-&gt;dev
comma
l_int|0
)paren
suffix:colon
id|usb_sndctrlpipe
c_func
(paren
id|usblp-&gt;dev
comma
l_int|0
)paren
comma
id|request
comma
id|type
op_or
id|dir
op_or
id|recip
comma
id|value
comma
id|usblp-&gt;ifnum
comma
id|buf
comma
id|len
comma
id|USBLP_WRITE_TIMEOUT
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;usblp_control_msg: rq: 0x%02x dir: %d recip: %d value: %d len: %#x result: %d&quot;
comma
id|request
comma
op_logical_neg
op_logical_neg
id|dir
comma
id|recip
comma
id|value
comma
id|len
comma
id|retval
)paren
suffix:semicolon
r_return
id|retval
OL
l_int|0
ques
c_cond
id|retval
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|macro|usblp_read_status
mdefine_line|#define usblp_read_status(usblp, status)&bslash;&n;&t;usblp_ctrl_msg(usblp, USBLP_REQ_GET_STATUS, USB_TYPE_CLASS, USB_DIR_IN, USB_RECIP_INTERFACE, 0, status, 1)
DECL|macro|usblp_get_id
mdefine_line|#define usblp_get_id(usblp, config, id, maxlen)&bslash;&n;&t;usblp_ctrl_msg(usblp, USBLP_REQ_GET_ID, USB_TYPE_CLASS, USB_DIR_IN, USB_RECIP_INTERFACE, config, id, maxlen)
DECL|macro|usblp_reset
mdefine_line|#define usblp_reset(usblp)&bslash;&n;&t;usblp_ctrl_msg(usblp, USBLP_REQ_RESET, USB_TYPE_CLASS, USB_DIR_OUT, USB_RECIP_OTHER, 0, NULL, 0)
DECL|macro|usblp_hp_channel_change_request
mdefine_line|#define usblp_hp_channel_change_request(usblp, channel, buffer) &bslash;&n;&t;usblp_ctrl_msg(usblp, USBLP_REQ_HP_CHANNEL_CHANGE_REQUEST, USB_TYPE_VENDOR, USB_DIR_IN, USB_RECIP_INTERFACE, channel, buffer, 1)
multiline_comment|/*&n; * See the description for usblp_select_alts() below for the usage&n; * explanation.  Look into your /proc/bus/usb/devices and dmesg in&n; * case of any trouble.&n; */
DECL|variable|proto_bias
r_static
r_int
id|proto_bias
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n; * URB callback.&n; */
DECL|function|usblp_bulk_read
r_static
r_void
id|usblp_bulk_read
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|usblp
op_star
id|usblp
op_assign
id|urb-&gt;context
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|usblp
op_logical_or
op_logical_neg
id|usblp-&gt;dev
op_logical_or
op_logical_neg
id|usblp-&gt;used
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|urb-&gt;status
)paren
)paren
id|warn
c_func
(paren
l_string|&quot;usblp%d: nonzero read/write bulk status received: %d&quot;
comma
id|usblp-&gt;minor
comma
id|urb-&gt;status
)paren
suffix:semicolon
id|usblp-&gt;rcomplete
op_assign
l_int|1
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|usblp-&gt;wait
)paren
suffix:semicolon
)brace
DECL|function|usblp_bulk_write
r_static
r_void
id|usblp_bulk_write
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|usblp
op_star
id|usblp
op_assign
id|urb-&gt;context
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|usblp
op_logical_or
op_logical_neg
id|usblp-&gt;dev
op_logical_or
op_logical_neg
id|usblp-&gt;used
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|urb-&gt;status
)paren
)paren
id|warn
c_func
(paren
l_string|&quot;usblp%d: nonzero read/write bulk status received: %d&quot;
comma
id|usblp-&gt;minor
comma
id|urb-&gt;status
)paren
suffix:semicolon
id|usblp-&gt;wcomplete
op_assign
l_int|1
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|usblp-&gt;wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Get and print printer errors.&n; */
DECL|variable|usblp_messages
r_static
r_char
op_star
id|usblp_messages
(braket
)braket
op_assign
(brace
l_string|&quot;ok&quot;
comma
l_string|&quot;out of paper&quot;
comma
l_string|&quot;off-line&quot;
comma
l_string|&quot;on fire&quot;
)brace
suffix:semicolon
DECL|function|usblp_check_status
r_static
r_int
id|usblp_check_status
c_func
(paren
r_struct
id|usblp
op_star
id|usblp
comma
r_int
id|err
)paren
(brace
r_int
r_char
id|status
comma
id|newerr
op_assign
l_int|0
suffix:semicolon
r_int
id|error
suffix:semicolon
id|error
op_assign
id|usblp_read_status
(paren
id|usblp
comma
id|usblp-&gt;statusbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;usblp%d: error %d reading printer status&quot;
comma
id|usblp-&gt;minor
comma
id|error
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|status
op_assign
op_star
id|usblp-&gt;statusbuf
suffix:semicolon
r_if
c_cond
(paren
op_complement
id|status
op_amp
id|LP_PERRORP
)paren
(brace
id|newerr
op_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|LP_POUTPA
)paren
id|newerr
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_complement
id|status
op_amp
id|LP_PSELECD
)paren
id|newerr
op_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|newerr
op_ne
id|err
)paren
id|info
c_func
(paren
l_string|&quot;usblp%d: %s&quot;
comma
id|usblp-&gt;minor
comma
id|usblp_messages
(braket
id|newerr
)braket
)paren
suffix:semicolon
r_return
id|newerr
suffix:semicolon
)brace
multiline_comment|/*&n; * File op functions.&n; */
DECL|function|usblp_open
r_static
r_int
id|usblp_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|minor
op_assign
id|minor
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_struct
id|usblp
op_star
id|usblp
suffix:semicolon
r_struct
id|usb_interface
op_star
id|intf
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|minor
OL
l_int|0
op_logical_or
id|minor
op_ge
id|USBLP_MINORS
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|intf
op_assign
id|usb_find_interface
c_func
(paren
op_amp
id|usblp_driver
comma
id|mk_kdev
c_func
(paren
id|USB_MAJOR
comma
id|minor
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|intf
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
id|usblp
op_assign
id|usb_get_intfdata
(paren
id|intf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|usblp
op_logical_or
op_logical_neg
id|usblp-&gt;dev
)paren
r_goto
id|out
suffix:semicolon
id|retval
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|usblp-&gt;used
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * TODO: need to implement LP_ABORTOPEN + O_NONBLOCK as in drivers/char/lp.c ???&n;&t; * This is #if 0-ed because we *don&squot;t* want to fail an open&n;&t; * just because the printer is off-line.&n;&t; */
macro_line|#if 0
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|usblp_check_status
c_func
(paren
id|usblp
comma
l_int|0
)paren
)paren
)paren
(brace
id|retval
op_assign
id|retval
OG
l_int|1
ques
c_cond
op_minus
id|EIO
suffix:colon
op_minus
id|ENOSPC
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
macro_line|#else
id|retval
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|usblp-&gt;used
op_assign
l_int|1
suffix:semicolon
id|file-&gt;private_data
op_assign
id|usblp
suffix:semicolon
id|usblp-&gt;writeurb-&gt;transfer_buffer_length
op_assign
l_int|0
suffix:semicolon
id|usblp-&gt;writeurb-&gt;status
op_assign
l_int|0
suffix:semicolon
id|usblp-&gt;wcomplete
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* we begin writeable */
id|usblp-&gt;rcomplete
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|usblp-&gt;bidir
)paren
(brace
id|usblp-&gt;readcount
op_assign
l_int|0
suffix:semicolon
id|usblp-&gt;readurb-&gt;dev
op_assign
id|usblp-&gt;dev
suffix:semicolon
r_if
c_cond
(paren
id|usb_submit_urb
c_func
(paren
id|usblp-&gt;readurb
comma
id|GFP_KERNEL
)paren
OL
l_int|0
)paren
(brace
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
id|usblp-&gt;used
op_assign
l_int|0
suffix:semicolon
id|file-&gt;private_data
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|usblp_cleanup
r_static
r_void
id|usblp_cleanup
(paren
r_struct
id|usblp
op_star
id|usblp
)paren
(brace
id|devfs_unregister
(paren
id|usblp-&gt;devfs
)paren
suffix:semicolon
id|usb_deregister_dev
(paren
l_int|1
comma
id|usblp-&gt;minor
)paren
suffix:semicolon
id|info
c_func
(paren
l_string|&quot;usblp%d: removed&quot;
comma
id|usblp-&gt;minor
)paren
suffix:semicolon
id|usb_buffer_free
(paren
id|usblp-&gt;dev
comma
id|USBLP_BUF_SIZE
comma
id|usblp-&gt;writebuf
comma
id|usblp-&gt;writeurb-&gt;transfer_dma
)paren
suffix:semicolon
id|usb_buffer_free
(paren
id|usblp-&gt;dev
comma
id|USBLP_BUF_SIZE
comma
id|usblp-&gt;readbuf
comma
id|usblp-&gt;writeurb-&gt;transfer_dma
)paren
suffix:semicolon
id|kfree
(paren
id|usblp-&gt;device_id_string
)paren
suffix:semicolon
id|kfree
(paren
id|usblp-&gt;statusbuf
)paren
suffix:semicolon
id|usb_free_urb
c_func
(paren
id|usblp-&gt;writeurb
)paren
suffix:semicolon
id|usb_free_urb
c_func
(paren
id|usblp-&gt;readurb
)paren
suffix:semicolon
id|kfree
(paren
id|usblp
)paren
suffix:semicolon
)brace
DECL|function|usblp_unlink_urbs
r_static
r_void
id|usblp_unlink_urbs
c_func
(paren
r_struct
id|usblp
op_star
id|usblp
)paren
(brace
id|usb_unlink_urb
c_func
(paren
id|usblp-&gt;writeurb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usblp-&gt;bidir
)paren
id|usb_unlink_urb
c_func
(paren
id|usblp-&gt;readurb
)paren
suffix:semicolon
)brace
DECL|function|usblp_release
r_static
r_int
id|usblp_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|usblp
op_star
id|usblp
op_assign
id|file-&gt;private_data
suffix:semicolon
id|down
(paren
op_amp
id|usblp-&gt;sem
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|usblp-&gt;used
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|usblp-&gt;dev
)paren
(brace
id|usblp_unlink_urbs
c_func
(paren
id|usblp
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|usblp-&gt;sem
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* finish cleanup from disconnect */
id|usblp_cleanup
(paren
id|usblp
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* No kernel lock - fine */
DECL|function|usblp_poll
r_static
r_int
r_int
id|usblp_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|poll_table_struct
op_star
id|wait
)paren
(brace
r_struct
id|usblp
op_star
id|usblp
op_assign
id|file-&gt;private_data
suffix:semicolon
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|usblp-&gt;wait
comma
id|wait
)paren
suffix:semicolon
r_return
(paren
(paren
op_logical_neg
id|usblp-&gt;bidir
op_logical_or
id|usblp-&gt;readurb-&gt;status
op_eq
op_minus
id|EINPROGRESS
)paren
ques
c_cond
l_int|0
suffix:colon
id|POLLIN
op_or
id|POLLRDNORM
)paren
op_or
(paren
id|usblp-&gt;writeurb-&gt;status
op_eq
op_minus
id|EINPROGRESS
ques
c_cond
l_int|0
suffix:colon
id|POLLOUT
op_or
id|POLLWRNORM
)paren
suffix:semicolon
)brace
DECL|function|usblp_ioctl
r_static
r_int
id|usblp_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|usblp
op_star
id|usblp
op_assign
id|file-&gt;private_data
suffix:semicolon
r_int
id|length
comma
id|err
comma
id|i
suffix:semicolon
r_int
r_char
id|lpstatus
comma
id|newChannel
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|twoints
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
id|down
(paren
op_amp
id|usblp-&gt;sem
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|usblp-&gt;dev
)paren
(brace
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|_IOC_TYPE
c_func
(paren
id|cmd
)paren
op_eq
l_char|&squot;P&squot;
)paren
multiline_comment|/* new-style ioctl number */
r_switch
c_cond
(paren
id|_IOC_NR
c_func
(paren
id|cmd
)paren
)paren
(brace
r_case
id|IOCNR_GET_DEVICE_ID
suffix:colon
multiline_comment|/* get the DEVICE_ID string */
r_if
c_cond
(paren
id|_IOC_DIR
c_func
(paren
id|cmd
)paren
op_ne
id|_IOC_READ
)paren
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|length
op_assign
id|usblp_cache_device_id_string
c_func
(paren
id|usblp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|length
OL
l_int|0
)paren
(brace
id|retval
op_assign
id|length
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|length
OG
id|_IOC_SIZE
c_func
(paren
id|cmd
)paren
)paren
id|length
op_assign
id|_IOC_SIZE
c_func
(paren
id|cmd
)paren
suffix:semicolon
multiline_comment|/* truncate */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|arg
comma
id|usblp-&gt;device_id_string
comma
(paren
r_int
r_int
)paren
id|length
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|IOCNR_GET_PROTOCOLS
suffix:colon
r_if
c_cond
(paren
id|_IOC_DIR
c_func
(paren
id|cmd
)paren
op_ne
id|_IOC_READ
op_logical_or
id|_IOC_SIZE
c_func
(paren
id|cmd
)paren
OL
r_sizeof
(paren
id|twoints
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|twoints
(braket
l_int|0
)braket
op_assign
id|usblp-&gt;current_protocol
suffix:semicolon
id|twoints
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|USBLP_FIRST_PROTOCOL
suffix:semicolon
id|i
op_le
id|USBLP_LAST_PROTOCOL
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|usblp-&gt;protocol
(braket
id|i
)braket
dot
id|alt_setting
op_ge
l_int|0
)paren
id|twoints
(braket
l_int|1
)braket
op_or_assign
(paren
l_int|1
op_lshift
id|i
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|arg
comma
(paren
r_int
r_char
op_star
)paren
id|twoints
comma
r_sizeof
(paren
id|twoints
)paren
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|IOCNR_SET_PROTOCOL
suffix:colon
r_if
c_cond
(paren
id|_IOC_DIR
c_func
(paren
id|cmd
)paren
op_ne
id|_IOC_WRITE
)paren
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|arg
op_eq
op_minus
l_int|10
)paren
(brace
id|usblp_dump
c_func
(paren
id|usblp
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif
id|usblp_unlink_urbs
c_func
(paren
id|usblp
)paren
suffix:semicolon
id|retval
op_assign
id|usblp_set_protocol
c_func
(paren
id|usblp
comma
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
(brace
id|usblp_set_protocol
c_func
(paren
id|usblp
comma
id|usblp-&gt;current_protocol
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|IOCNR_HP_SET_CHANNEL
suffix:colon
r_if
c_cond
(paren
id|_IOC_DIR
c_func
(paren
id|cmd
)paren
op_ne
id|_IOC_WRITE
op_logical_or
id|usblp-&gt;dev-&gt;descriptor.idVendor
op_ne
l_int|0x03F0
op_logical_or
id|usblp-&gt;quirks
op_amp
id|USBLP_QUIRK_BIDIR
)paren
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|err
op_assign
id|usblp_hp_channel_change_request
c_func
(paren
id|usblp
comma
id|arg
comma
op_amp
id|newChannel
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;usblp%d: error = %d setting &quot;
l_string|&quot;HP channel&quot;
comma
id|usblp-&gt;minor
comma
id|err
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;usblp%d requested/got HP channel %ld/%d&quot;
comma
id|usblp-&gt;minor
comma
id|arg
comma
id|newChannel
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IOCNR_GET_BUS_ADDRESS
suffix:colon
r_if
c_cond
(paren
id|_IOC_DIR
c_func
(paren
id|cmd
)paren
op_ne
id|_IOC_READ
op_logical_or
id|_IOC_SIZE
c_func
(paren
id|cmd
)paren
OL
r_sizeof
(paren
id|twoints
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|twoints
(braket
l_int|0
)braket
op_assign
id|usblp-&gt;dev-&gt;bus-&gt;busnum
suffix:semicolon
id|twoints
(braket
l_int|1
)braket
op_assign
id|usblp-&gt;dev-&gt;devnum
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|arg
comma
(paren
r_int
r_char
op_star
)paren
id|twoints
comma
r_sizeof
(paren
id|twoints
)paren
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;usblp%d is bus=%d, device=%d&quot;
comma
id|usblp-&gt;minor
comma
id|twoints
(braket
l_int|0
)braket
comma
id|twoints
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IOCNR_GET_VID_PID
suffix:colon
r_if
c_cond
(paren
id|_IOC_DIR
c_func
(paren
id|cmd
)paren
op_ne
id|_IOC_READ
op_logical_or
id|_IOC_SIZE
c_func
(paren
id|cmd
)paren
OL
r_sizeof
(paren
id|twoints
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|twoints
(braket
l_int|0
)braket
op_assign
id|usblp-&gt;dev-&gt;descriptor.idVendor
suffix:semicolon
id|twoints
(braket
l_int|1
)braket
op_assign
id|usblp-&gt;dev-&gt;descriptor.idProduct
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|arg
comma
(paren
r_int
r_char
op_star
)paren
id|twoints
comma
r_sizeof
(paren
id|twoints
)paren
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;usblp%d is VID=0x%4.4X, PID=0x%4.4X&quot;
comma
id|usblp-&gt;minor
comma
id|twoints
(braket
l_int|0
)braket
comma
id|twoints
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
multiline_comment|/* old-style ioctl value */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|LPGETSTATUS
suffix:colon
r_if
c_cond
(paren
id|usblp_read_status
c_func
(paren
id|usblp
comma
op_amp
id|lpstatus
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;usblp%d: failed reading printer status&quot;
comma
id|usblp-&gt;minor
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|status
op_assign
id|lpstatus
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
(paren
(paren
r_int
op_star
)paren
id|arg
comma
op_amp
id|status
comma
r_sizeof
(paren
r_int
)paren
)paren
)paren
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
id|done
suffix:colon
id|up
(paren
op_amp
id|usblp-&gt;sem
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|usblp_write
r_static
id|ssize_t
id|usblp_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_struct
id|usblp
op_star
id|usblp
op_assign
id|file-&gt;private_data
suffix:semicolon
r_int
id|timeout
comma
id|err
op_assign
l_int|0
comma
id|writecount
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|writecount
OL
id|count
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|usblp-&gt;wcomplete
)paren
(brace
id|barrier
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|timeout
op_assign
id|USBLP_WRITE_TIMEOUT
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|usblp-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|remove_wait_queue
c_func
(paren
op_amp
id|usblp-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_return
id|writecount
ques
c_cond
id|writecount
suffix:colon
op_minus
id|EINTR
suffix:semicolon
)brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timeout
op_logical_and
op_logical_neg
id|usblp-&gt;wcomplete
)paren
(brace
id|timeout
op_assign
id|schedule_timeout
c_func
(paren
id|timeout
)paren
suffix:semicolon
)brace
r_else
(brace
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|usblp-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
)brace
id|down
(paren
op_amp
id|usblp-&gt;sem
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|usblp-&gt;dev
)paren
(brace
id|up
(paren
op_amp
id|usblp-&gt;sem
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|usblp-&gt;writeurb-&gt;status
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|usblp-&gt;quirks
op_amp
id|USBLP_QUIRK_BIDIR
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|usblp-&gt;wcomplete
)paren
id|err
c_func
(paren
l_string|&quot;usblp%d: error %d writing to printer&quot;
comma
id|usblp-&gt;minor
comma
id|usblp-&gt;writeurb-&gt;status
)paren
suffix:semicolon
id|err
op_assign
id|usblp-&gt;writeurb-&gt;status
suffix:semicolon
)brace
r_else
id|err
op_assign
id|usblp_check_status
c_func
(paren
id|usblp
comma
id|err
)paren
suffix:semicolon
id|up
(paren
op_amp
id|usblp-&gt;sem
)paren
suffix:semicolon
multiline_comment|/* if the fault was due to disconnect, let khubd&squot;s&n;&t;&t;&t; * call to usblp_disconnect() grab usblp-&gt;sem ...&n;&t;&t;&t; */
id|schedule
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|writecount
op_add_assign
id|usblp-&gt;writeurb-&gt;transfer_buffer_length
suffix:semicolon
id|usblp-&gt;writeurb-&gt;transfer_buffer_length
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|writecount
op_eq
id|count
)paren
(brace
id|up
(paren
op_amp
id|usblp-&gt;sem
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|usblp-&gt;writeurb-&gt;transfer_buffer_length
op_assign
(paren
id|count
op_minus
id|writecount
)paren
OL
id|USBLP_BUF_SIZE
ques
c_cond
(paren
id|count
op_minus
id|writecount
)paren
suffix:colon
id|USBLP_BUF_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|usblp-&gt;writeurb-&gt;transfer_buffer
comma
id|buffer
op_plus
id|writecount
comma
id|usblp-&gt;writeurb-&gt;transfer_buffer_length
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|usblp-&gt;sem
)paren
suffix:semicolon
r_return
id|writecount
ques
c_cond
id|writecount
suffix:colon
op_minus
id|EFAULT
suffix:semicolon
)brace
id|usblp-&gt;writeurb-&gt;dev
op_assign
id|usblp-&gt;dev
suffix:semicolon
id|usblp-&gt;wcomplete
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|usb_submit_urb
c_func
(paren
id|usblp-&gt;writeurb
comma
id|GFP_KERNEL
)paren
)paren
(brace
id|count
op_assign
op_minus
id|EIO
suffix:semicolon
id|up
(paren
op_amp
id|usblp-&gt;sem
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|up
(paren
op_amp
id|usblp-&gt;sem
)paren
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
DECL|function|usblp_read
r_static
id|ssize_t
id|usblp_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|usblp
op_star
id|usblp
op_assign
id|file-&gt;private_data
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|usblp-&gt;bidir
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|down
(paren
op_amp
id|usblp-&gt;sem
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|usblp-&gt;dev
)paren
(brace
id|count
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|usblp-&gt;rcomplete
)paren
(brace
id|barrier
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|count
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
singleline_comment|// FIXME:  only use urb-&gt;status inside completion
singleline_comment|// callbacks; this way is racey...
id|add_wait_queue
c_func
(paren
op_amp
id|usblp-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|count
op_assign
op_minus
id|EINTR
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|usblp-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|up
(paren
op_amp
id|usblp-&gt;sem
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|usblp-&gt;rcomplete
)paren
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|down
(paren
op_amp
id|usblp-&gt;sem
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|usblp-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|usblp-&gt;dev
)paren
(brace
id|count
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|usblp-&gt;readurb-&gt;status
)paren
(brace
id|err
c_func
(paren
l_string|&quot;usblp%d: error %d reading from printer&quot;
comma
id|usblp-&gt;minor
comma
id|usblp-&gt;readurb-&gt;status
)paren
suffix:semicolon
id|usblp-&gt;readurb-&gt;dev
op_assign
id|usblp-&gt;dev
suffix:semicolon
id|usblp-&gt;readcount
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|usb_submit_urb
c_func
(paren
id|usblp-&gt;readurb
comma
id|GFP_KERNEL
)paren
OL
l_int|0
)paren
id|dbg
c_func
(paren
l_string|&quot;error submitting urb&quot;
)paren
suffix:semicolon
id|count
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|count
op_assign
id|count
OL
id|usblp-&gt;readurb-&gt;actual_length
op_minus
id|usblp-&gt;readcount
ques
c_cond
id|count
suffix:colon
id|usblp-&gt;readurb-&gt;actual_length
op_minus
id|usblp-&gt;readcount
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buffer
comma
id|usblp-&gt;readurb-&gt;transfer_buffer
op_plus
id|usblp-&gt;readcount
comma
id|count
)paren
)paren
(brace
id|count
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|usblp-&gt;readcount
op_add_assign
id|count
)paren
op_eq
id|usblp-&gt;readurb-&gt;actual_length
)paren
(brace
id|usblp-&gt;readcount
op_assign
l_int|0
suffix:semicolon
id|usblp-&gt;readurb-&gt;dev
op_assign
id|usblp-&gt;dev
suffix:semicolon
id|usblp-&gt;rcomplete
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|usb_submit_urb
c_func
(paren
id|usblp-&gt;readurb
comma
id|GFP_KERNEL
)paren
)paren
(brace
id|count
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
)brace
id|done
suffix:colon
id|up
(paren
op_amp
id|usblp-&gt;sem
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/*&n; * Checks for printers that have quirks, such as requiring unidirectional&n; * communication but reporting bidirectional; currently some HP printers&n; * have this flaw (HP 810, 880, 895, etc.), or needing an init string&n; * sent at each open (like some Epsons).&n; * Returns 1 if found, 0 if not found.&n; *&n; * HP recommended that we use the bidirectional interface but&n; * don&squot;t attempt any bulk IN transfers from the IN endpoint.&n; * Here&squot;s some more detail on the problem:&n; * The problem is not that it isn&squot;t bidirectional though. The problem&n; * is that if you request a device ID, or status information, while&n; * the buffers are full, the return data will end up in the print data&n; * buffer. For example if you make sure you never request the device ID&n; * while you are sending print data, and you don&squot;t try to query the&n; * printer status every couple of milliseconds, you will probably be OK.&n; */
DECL|function|usblp_quirks
r_static
r_int
r_int
id|usblp_quirks
(paren
id|__u16
id|vendor
comma
id|__u16
id|product
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|quirk_printers
(braket
id|i
)braket
dot
id|vendorId
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|vendor
op_eq
id|quirk_printers
(braket
id|i
)braket
dot
id|vendorId
op_logical_and
id|product
op_eq
id|quirk_printers
(braket
id|i
)braket
dot
id|productId
)paren
r_return
id|quirk_printers
(braket
id|i
)braket
dot
id|quirks
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|usblp_fops
r_static
r_struct
id|file_operations
id|usblp_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|read
op_assign
id|usblp_read
comma
dot
id|write
op_assign
id|usblp_write
comma
dot
id|poll
op_assign
id|usblp_poll
comma
dot
id|ioctl
op_assign
id|usblp_ioctl
comma
dot
id|open
op_assign
id|usblp_open
comma
dot
id|release
op_assign
id|usblp_release
comma
)brace
suffix:semicolon
DECL|function|usblp_probe
r_static
r_int
id|usblp_probe
c_func
(paren
r_struct
id|usb_interface
op_star
id|intf
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
(brace
r_struct
id|usb_device
op_star
id|dev
op_assign
id|interface_to_usbdev
(paren
id|intf
)paren
suffix:semicolon
r_struct
id|usblp
op_star
id|usblp
op_assign
l_int|0
suffix:semicolon
r_int
id|protocol
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_char
id|name
(braket
l_int|6
)braket
suffix:semicolon
multiline_comment|/* Malloc and start initializing usblp structure so we can use it&n;&t; * directly. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|usblp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|usblp
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;out of memory for usblp&quot;
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|memset
c_func
(paren
id|usblp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|usblp
)paren
)paren
suffix:semicolon
id|usblp-&gt;dev
op_assign
id|dev
suffix:semicolon
id|init_MUTEX
(paren
op_amp
id|usblp-&gt;sem
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|usblp-&gt;wait
)paren
suffix:semicolon
id|usblp-&gt;ifnum
op_assign
id|intf-&gt;altsetting-&gt;desc.bInterfaceNumber
suffix:semicolon
id|retval
op_assign
id|usb_register_dev
c_func
(paren
op_amp
id|usblp_fops
comma
id|USBLP_MINOR_BASE
comma
l_int|1
comma
op_amp
id|usblp-&gt;minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|err
c_func
(paren
l_string|&quot;Not able to get a minor for this device.&quot;
)paren
suffix:semicolon
r_goto
m_abort
suffix:semicolon
)brace
id|usblp-&gt;writeurb
op_assign
id|usb_alloc_urb
c_func
(paren
l_int|0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|usblp-&gt;writeurb
)paren
(brace
id|err
c_func
(paren
l_string|&quot;out of memory&quot;
)paren
suffix:semicolon
r_goto
id|abort_minor
suffix:semicolon
)brace
id|usblp-&gt;readurb
op_assign
id|usb_alloc_urb
c_func
(paren
l_int|0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|usblp-&gt;readurb
)paren
(brace
id|err
c_func
(paren
l_string|&quot;out of memory&quot;
)paren
suffix:semicolon
r_goto
id|abort_minor
suffix:semicolon
)brace
multiline_comment|/* Malloc device ID string buffer to the largest expected length,&n;&t; * since we can re-query it on an ioctl and a dynamic string&n;&t; * could change in length. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|usblp-&gt;device_id_string
op_assign
id|kmalloc
c_func
(paren
id|USBLP_DEVICE_ID_SIZE
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;out of memory for device_id_string&quot;
)paren
suffix:semicolon
r_goto
id|abort_minor
suffix:semicolon
)brace
id|usblp-&gt;writebuf
op_assign
id|usblp-&gt;readbuf
op_assign
l_int|NULL
suffix:semicolon
id|usblp-&gt;writeurb-&gt;transfer_flags
op_assign
id|URB_NO_DMA_MAP
suffix:semicolon
id|usblp-&gt;readurb-&gt;transfer_flags
op_assign
id|URB_NO_DMA_MAP
suffix:semicolon
multiline_comment|/* Malloc write &amp; read buffers.  We somewhat wastefully&n;&t; * malloc both regardless of bidirectionality, because the&n;&t; * alternate setting can be changed later via an ioctl. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|usblp-&gt;writebuf
op_assign
id|usb_buffer_alloc
c_func
(paren
id|dev
comma
id|USBLP_BUF_SIZE
comma
id|GFP_KERNEL
comma
op_amp
id|usblp-&gt;writeurb-&gt;transfer_dma
)paren
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;out of memory for write buf&quot;
)paren
suffix:semicolon
r_goto
id|abort_minor
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|usblp-&gt;readbuf
op_assign
id|usb_buffer_alloc
c_func
(paren
id|dev
comma
id|USBLP_BUF_SIZE
comma
id|GFP_KERNEL
comma
op_amp
id|usblp-&gt;readurb-&gt;transfer_dma
)paren
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;out of memory for read buf&quot;
)paren
suffix:semicolon
r_goto
id|abort_minor
suffix:semicolon
)brace
multiline_comment|/* Allocate buffer for printer status */
id|usblp-&gt;statusbuf
op_assign
id|kmalloc
c_func
(paren
id|STATUS_BUF_SIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|usblp-&gt;statusbuf
)paren
(brace
id|err
c_func
(paren
l_string|&quot;out of memory for statusbuf&quot;
)paren
suffix:semicolon
r_goto
id|abort_minor
suffix:semicolon
)brace
multiline_comment|/* Lookup quirks for this printer. */
id|usblp-&gt;quirks
op_assign
id|usblp_quirks
c_func
(paren
id|dev-&gt;descriptor.idVendor
comma
id|dev-&gt;descriptor.idProduct
)paren
suffix:semicolon
multiline_comment|/* Analyze and pick initial alternate settings and endpoints. */
id|protocol
op_assign
id|usblp_select_alts
c_func
(paren
id|usblp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|protocol
OL
l_int|0
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;incompatible printer-class device 0x%4.4X/0x%4.4X&quot;
comma
id|dev-&gt;descriptor.idVendor
comma
id|dev-&gt;descriptor.idProduct
)paren
suffix:semicolon
r_goto
id|abort_minor
suffix:semicolon
)brace
multiline_comment|/* Setup the selected alternate setting and endpoints. */
r_if
c_cond
(paren
id|usblp_set_protocol
c_func
(paren
id|usblp
comma
id|protocol
)paren
OL
l_int|0
)paren
r_goto
id|abort_minor
suffix:semicolon
multiline_comment|/* Retrieve and store the device ID string. */
id|usblp_cache_device_id_string
c_func
(paren
id|usblp
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|usblp_check_status
c_func
(paren
id|usblp
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* If we have devfs, create with perms=660. */
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;lp%d&quot;
comma
id|usblp-&gt;minor
)paren
suffix:semicolon
id|usblp-&gt;devfs
op_assign
id|devfs_register
c_func
(paren
id|usb_devfs_handle
comma
id|name
comma
id|DEVFS_FL_DEFAULT
comma
id|USB_MAJOR
comma
id|usblp-&gt;minor
comma
id|S_IFCHR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
op_or
id|S_IRGRP
op_or
id|S_IWGRP
comma
op_amp
id|usblp_fops
comma
l_int|NULL
)paren
suffix:semicolon
id|info
c_func
(paren
l_string|&quot;usblp%d: USB %sdirectional printer dev %d &quot;
l_string|&quot;if %d alt %d proto %d vid 0x%4.4X pid 0x%4.4X&quot;
comma
id|usblp-&gt;minor
comma
id|usblp-&gt;bidir
ques
c_cond
l_string|&quot;Bi&quot;
suffix:colon
l_string|&quot;Uni&quot;
comma
id|dev-&gt;devnum
comma
id|usblp-&gt;ifnum
comma
id|usblp-&gt;protocol
(braket
id|usblp-&gt;current_protocol
)braket
dot
id|alt_setting
comma
id|usblp-&gt;current_protocol
comma
id|usblp-&gt;dev-&gt;descriptor.idVendor
comma
id|usblp-&gt;dev-&gt;descriptor.idProduct
)paren
suffix:semicolon
id|usb_set_intfdata
(paren
id|intf
comma
id|usblp
)paren
suffix:semicolon
multiline_comment|/* add device id so the device works when advertised */
id|intf-&gt;kdev
op_assign
id|mk_kdev
c_func
(paren
id|USB_MAJOR
comma
id|usblp-&gt;minor
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|abort_minor
suffix:colon
id|usb_deregister_dev
(paren
l_int|1
comma
id|usblp-&gt;minor
)paren
suffix:semicolon
m_abort
suffix:colon
r_if
c_cond
(paren
id|usblp
)paren
(brace
r_if
c_cond
(paren
id|usblp-&gt;writebuf
)paren
id|usb_buffer_free
(paren
id|usblp-&gt;dev
comma
id|USBLP_BUF_SIZE
comma
id|usblp-&gt;writebuf
comma
id|usblp-&gt;writeurb-&gt;transfer_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usblp-&gt;readbuf
)paren
id|usb_buffer_free
(paren
id|usblp-&gt;dev
comma
id|USBLP_BUF_SIZE
comma
id|usblp-&gt;readbuf
comma
id|usblp-&gt;writeurb-&gt;transfer_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usblp-&gt;statusbuf
)paren
id|kfree
c_func
(paren
id|usblp-&gt;statusbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usblp-&gt;device_id_string
)paren
id|kfree
c_func
(paren
id|usblp-&gt;device_id_string
)paren
suffix:semicolon
id|usb_free_urb
c_func
(paren
id|usblp-&gt;writeurb
)paren
suffix:semicolon
id|usb_free_urb
c_func
(paren
id|usblp-&gt;readurb
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|usblp
)paren
suffix:semicolon
)brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n; * We are a &quot;new&quot; style driver with usb_device_id table,&n; * but our requirements are too intricate for simple match to handle.&n; *&n; * The &quot;proto_bias&quot; option may be used to specify the preferred protocol&n; * for all USB printers (1=7/1/1, 2=7/1/2, 3=7/1/3).  If the device&n; * supports the preferred protocol, then we bind to it.&n; *&n; * The best interface for us is 7/1/2, because it is compatible&n; * with a stream of characters. If we find it, we bind to it.&n; *&n; * Note that the people from hpoj.sourceforge.net need to be able to&n; * bind to 7/1/3 (MLC/1284.4), so we provide them ioctls for this purpose.&n; *&n; * Failing 7/1/2, we look for 7/1/3, even though it&squot;s probably not&n; * stream-compatible, because this matches the behaviour of the old code.&n; *&n; * If nothing else, we bind to 7/1/1 - the unidirectional interface.&n; */
DECL|function|usblp_select_alts
r_static
r_int
id|usblp_select_alts
c_func
(paren
r_struct
id|usblp
op_star
id|usblp
)paren
(brace
r_struct
id|usb_interface
op_star
id|if_alt
suffix:semicolon
r_struct
id|usb_host_interface
op_star
id|ifd
suffix:semicolon
r_struct
id|usb_endpoint_descriptor
op_star
id|epd
comma
op_star
id|epwrite
comma
op_star
id|epread
suffix:semicolon
r_int
id|p
comma
id|i
comma
id|e
suffix:semicolon
id|if_alt
op_assign
op_amp
id|usblp-&gt;dev-&gt;actconfig-&gt;interface
(braket
id|usblp-&gt;ifnum
)braket
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
l_int|0
suffix:semicolon
id|p
OL
id|USBLP_MAX_PROTOCOLS
suffix:semicolon
id|p
op_increment
)paren
id|usblp-&gt;protocol
(braket
id|p
)braket
dot
id|alt_setting
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Find out what we have. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|if_alt-&gt;num_altsetting
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ifd
op_assign
op_amp
id|if_alt-&gt;altsetting
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ifd-&gt;desc.bInterfaceClass
op_ne
l_int|7
op_logical_or
id|ifd-&gt;desc.bInterfaceSubClass
op_ne
l_int|1
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|ifd-&gt;desc.bInterfaceProtocol
template_param
id|USBLP_LAST_PROTOCOL
)paren
r_continue
suffix:semicolon
multiline_comment|/* Look for bulk OUT and IN endpoints. */
id|epwrite
op_assign
id|epread
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|e
op_assign
l_int|0
suffix:semicolon
id|e
OL
id|ifd-&gt;desc.bNumEndpoints
suffix:semicolon
id|e
op_increment
)paren
(brace
id|epd
op_assign
op_amp
id|ifd-&gt;endpoint
(braket
id|e
)braket
dot
id|desc
suffix:semicolon
r_if
c_cond
(paren
(paren
id|epd-&gt;bmAttributes
op_amp
id|USB_ENDPOINT_XFERTYPE_MASK
)paren
op_ne
id|USB_ENDPOINT_XFER_BULK
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|epd-&gt;bEndpointAddress
op_amp
id|USB_ENDPOINT_DIR_MASK
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|epwrite
)paren
id|epwrite
op_assign
id|epd
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|epread
)paren
id|epread
op_assign
id|epd
suffix:semicolon
)brace
)brace
multiline_comment|/* Ignore buggy hardware without the right endpoints. */
r_if
c_cond
(paren
op_logical_neg
id|epwrite
op_logical_or
(paren
id|ifd-&gt;desc.bInterfaceProtocol
OG
l_int|1
op_logical_and
op_logical_neg
id|epread
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Turn off reads for 7/1/1 (unidirectional) interfaces&n;&t;&t; * and buggy bidirectional printers. */
r_if
c_cond
(paren
id|ifd-&gt;desc.bInterfaceProtocol
op_eq
l_int|1
)paren
(brace
id|epread
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|usblp-&gt;quirks
op_amp
id|USBLP_QUIRK_BIDIR
)paren
(brace
id|info
c_func
(paren
l_string|&quot;Disabling reads from problem bidirectional &quot;
l_string|&quot;printer on usblp%d&quot;
comma
id|usblp-&gt;minor
)paren
suffix:semicolon
id|epread
op_assign
l_int|NULL
suffix:semicolon
)brace
id|usblp-&gt;protocol
(braket
id|ifd-&gt;desc.bInterfaceProtocol
)braket
dot
id|alt_setting
op_assign
id|i
suffix:semicolon
id|usblp-&gt;protocol
(braket
id|ifd-&gt;desc.bInterfaceProtocol
)braket
dot
id|epwrite
op_assign
id|epwrite
suffix:semicolon
id|usblp-&gt;protocol
(braket
id|ifd-&gt;desc.bInterfaceProtocol
)braket
dot
id|epread
op_assign
id|epread
suffix:semicolon
)brace
multiline_comment|/* If our requested protocol is supported, then use it. */
r_if
c_cond
(paren
id|proto_bias
op_ge
id|USBLP_FIRST_PROTOCOL
op_logical_and
id|proto_bias
op_le
id|USBLP_LAST_PROTOCOL
op_logical_and
id|usblp-&gt;protocol
(braket
id|proto_bias
)braket
dot
id|alt_setting
op_ne
op_minus
l_int|1
)paren
r_return
id|proto_bias
suffix:semicolon
multiline_comment|/* Ordering is important here. */
r_if
c_cond
(paren
id|usblp-&gt;protocol
(braket
l_int|2
)braket
dot
id|alt_setting
op_ne
op_minus
l_int|1
)paren
r_return
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|usblp-&gt;protocol
(braket
l_int|1
)braket
dot
id|alt_setting
op_ne
op_minus
l_int|1
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|usblp-&gt;protocol
(braket
l_int|3
)braket
dot
id|alt_setting
op_ne
op_minus
l_int|1
)paren
r_return
l_int|3
suffix:semicolon
multiline_comment|/* If nothing is available, then don&squot;t bind to this device. */
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|usblp_set_protocol
r_static
r_int
id|usblp_set_protocol
c_func
(paren
r_struct
id|usblp
op_star
id|usblp
comma
r_int
id|protocol
)paren
(brace
r_int
id|r
comma
id|alts
suffix:semicolon
r_if
c_cond
(paren
id|protocol
template_param
id|USBLP_LAST_PROTOCOL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|alts
op_assign
id|usblp-&gt;protocol
(braket
id|protocol
)braket
dot
id|alt_setting
suffix:semicolon
r_if
c_cond
(paren
id|alts
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|r
op_assign
id|usb_set_interface
c_func
(paren
id|usblp-&gt;dev
comma
id|usblp-&gt;ifnum
comma
id|alts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;can&squot;t set desired altsetting %d on interface %d&quot;
comma
id|alts
comma
id|usblp-&gt;ifnum
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
id|usb_fill_bulk_urb
c_func
(paren
id|usblp-&gt;writeurb
comma
id|usblp-&gt;dev
comma
id|usb_sndbulkpipe
c_func
(paren
id|usblp-&gt;dev
comma
id|usblp-&gt;protocol
(braket
id|protocol
)braket
dot
id|epwrite-&gt;bEndpointAddress
)paren
comma
id|usblp-&gt;writebuf
comma
l_int|0
comma
id|usblp_bulk_write
comma
id|usblp
)paren
suffix:semicolon
id|usblp-&gt;bidir
op_assign
(paren
id|usblp-&gt;protocol
(braket
id|protocol
)braket
dot
id|epread
op_ne
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usblp-&gt;bidir
)paren
id|usb_fill_bulk_urb
c_func
(paren
id|usblp-&gt;readurb
comma
id|usblp-&gt;dev
comma
id|usb_rcvbulkpipe
c_func
(paren
id|usblp-&gt;dev
comma
id|usblp-&gt;protocol
(braket
id|protocol
)braket
dot
id|epread-&gt;bEndpointAddress
)paren
comma
id|usblp-&gt;readbuf
comma
id|USBLP_BUF_SIZE
comma
id|usblp_bulk_read
comma
id|usblp
)paren
suffix:semicolon
id|usblp-&gt;current_protocol
op_assign
id|protocol
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;usblp%d set protocol %d&quot;
comma
id|usblp-&gt;minor
comma
id|protocol
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Retrieves and caches device ID string.&n; * Returns length, including length bytes but not null terminator.&n; * On error, returns a negative errno value. */
DECL|function|usblp_cache_device_id_string
r_static
r_int
id|usblp_cache_device_id_string
c_func
(paren
r_struct
id|usblp
op_star
id|usblp
)paren
(brace
r_int
id|err
comma
id|length
suffix:semicolon
id|err
op_assign
id|usblp_get_id
c_func
(paren
id|usblp
comma
l_int|0
comma
id|usblp-&gt;device_id_string
comma
id|USBLP_DEVICE_ID_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;usblp%d: error = %d reading IEEE-1284 Device ID string&quot;
comma
id|usblp-&gt;minor
comma
id|err
)paren
suffix:semicolon
id|usblp-&gt;device_id_string
(braket
l_int|0
)braket
op_assign
id|usblp-&gt;device_id_string
(braket
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* First two bytes are length in big-endian.&n;&t; * They count themselves, and we copy them into&n;&t; * the user&squot;s buffer. */
id|length
op_assign
(paren
id|usblp-&gt;device_id_string
(braket
l_int|0
)braket
op_lshift
l_int|8
)paren
op_plus
id|usblp-&gt;device_id_string
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|length
OL
l_int|2
)paren
id|length
op_assign
l_int|2
suffix:semicolon
r_else
r_if
c_cond
(paren
id|length
op_ge
id|USBLP_DEVICE_ID_SIZE
)paren
id|length
op_assign
id|USBLP_DEVICE_ID_SIZE
op_minus
l_int|1
suffix:semicolon
id|usblp-&gt;device_id_string
(braket
id|length
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;usblp%d Device ID string [len=%d]=&bslash;&quot;%s&bslash;&quot;&quot;
comma
id|usblp-&gt;minor
comma
id|length
comma
op_amp
id|usblp-&gt;device_id_string
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_return
id|length
suffix:semicolon
)brace
DECL|function|usblp_disconnect
r_static
r_void
id|usblp_disconnect
c_func
(paren
r_struct
id|usb_interface
op_star
id|intf
)paren
(brace
r_struct
id|usblp
op_star
id|usblp
op_assign
id|usb_get_intfdata
(paren
id|intf
)paren
suffix:semicolon
multiline_comment|/* remove device id to disable open() */
id|intf-&gt;kdev
op_assign
id|NODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|usblp
op_logical_or
op_logical_neg
id|usblp-&gt;dev
)paren
(brace
id|err
c_func
(paren
l_string|&quot;bogus disconnect&quot;
)paren
suffix:semicolon
id|BUG
(paren
)paren
suffix:semicolon
)brace
id|down
(paren
op_amp
id|usblp-&gt;sem
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|usblp-&gt;dev
op_assign
l_int|NULL
suffix:semicolon
id|usb_set_intfdata
(paren
id|intf
comma
l_int|NULL
)paren
suffix:semicolon
id|usblp_unlink_urbs
c_func
(paren
id|usblp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|usblp-&gt;used
)paren
id|usblp_cleanup
(paren
id|usblp
)paren
suffix:semicolon
r_else
multiline_comment|/* cleanup later, on close */
id|up
(paren
op_amp
id|usblp-&gt;sem
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|usblp_ids
r_static
r_struct
id|usb_device_id
id|usblp_ids
(braket
)braket
op_assign
(brace
(brace
id|USB_DEVICE_INFO
c_func
(paren
l_int|7
comma
l_int|1
comma
l_int|1
)paren
)brace
comma
(brace
id|USB_DEVICE_INFO
c_func
(paren
l_int|7
comma
l_int|1
comma
l_int|2
)paren
)brace
comma
(brace
id|USB_DEVICE_INFO
c_func
(paren
l_int|7
comma
l_int|1
comma
l_int|3
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
l_int|7
comma
l_int|1
comma
l_int|1
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
l_int|7
comma
l_int|1
comma
l_int|2
)paren
)brace
comma
(brace
id|USB_INTERFACE_INFO
c_func
(paren
l_int|7
comma
l_int|1
comma
l_int|3
)paren
)brace
comma
(brace
)brace
multiline_comment|/* Terminating entry */
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
(paren
id|usb
comma
id|usblp_ids
)paren
suffix:semicolon
DECL|variable|usblp_driver
r_static
r_struct
id|usb_driver
id|usblp_driver
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|name
op_assign
l_string|&quot;usblp&quot;
comma
dot
id|probe
op_assign
id|usblp_probe
comma
dot
id|disconnect
op_assign
id|usblp_disconnect
comma
dot
id|id_table
op_assign
id|usblp_ids
comma
)brace
suffix:semicolon
DECL|function|usblp_init
r_static
r_int
id|__init
id|usblp_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|usb_register
c_func
(paren
op_amp
id|usblp_driver
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|info
c_func
(paren
id|DRIVER_VERSION
l_string|&quot;: &quot;
id|DRIVER_DESC
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usblp_exit
r_static
r_void
id|__exit
id|usblp_exit
c_func
(paren
r_void
)paren
(brace
id|usb_deregister
c_func
(paren
op_amp
id|usblp_driver
)paren
suffix:semicolon
)brace
DECL|variable|usblp_init
id|module_init
c_func
(paren
id|usblp_init
)paren
suffix:semicolon
DECL|variable|usblp_exit
id|module_exit
c_func
(paren
id|usblp_exit
)paren
suffix:semicolon
DECL|variable|DRIVER_AUTHOR
id|MODULE_AUTHOR
c_func
(paren
id|DRIVER_AUTHOR
)paren
suffix:semicolon
DECL|variable|DRIVER_DESC
id|MODULE_DESCRIPTION
c_func
(paren
id|DRIVER_DESC
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|proto_bias
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|proto_bias
comma
l_string|&quot;Favourite protocol number&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
