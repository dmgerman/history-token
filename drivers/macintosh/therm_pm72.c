multiline_comment|/*&n; * Device driver for the thermostats &amp; fan controller of  the&n; * Apple G5 &quot;PowerMac7,2&quot; desktop machines.&n; *&n; * (c) Copyright IBM Corp. 2003-2004&n; *&n; * Maintained by: Benjamin Herrenschmidt&n; *                &lt;benh@kernel.crashing.org&gt;&n; * &n; *&n; * The algorithm used is the PID control algorithm, used the same&n; * way the published Darwin code does, using the same values that&n; * are present in the Darwin 7.0 snapshot property lists.&n; *&n; * As far as the CPUs control loops are concerned, I use the&n; * calibration &amp; PID constants provided by the EEPROM,&n; * I do _not_ embed any value from the property lists, as the ones&n; * provided by Darwin 7.0 seem to always have an older version that&n; * what I&squot;ve seen on the actual computers.&n; * It would be interesting to verify that though. Darwin has a&n; * version code of 1.0.0d11 for all control loops it seems, while&n; * so far, the machines EEPROMs contain a dataset versioned 1.0.0f&n; *&n; * Darwin doesn&squot;t provide source to all parts, some missing&n; * bits like the AppleFCU driver or the actual scale of some&n; * of the values returned by sensors had to be &quot;guessed&quot; some&n; * way... or based on what Open Firmware does.&n; *&n; * I didn&squot;t yet figure out how to get the slots power consumption&n; * out of the FCU, so that part has not been implemented yet and&n; * the slots fan is set to a fixed 50% PWM, hoping this value is&n; * safe enough ...&n; *&n; * Note: I have observed strange oscillations of the CPU control&n; * loop on a dual G5 here. When idle, the CPU exhaust fan tend to&n; * oscillates slowly (over several minutes) between the minimum&n; * of 300RPMs and approx. 1000 RPMs. I don&squot;t know what is causing&n; * this, it could be some incorrect constant or an error in the&n; * way I ported the algorithm, or it could be just normal. I&n; * don&squot;t have full understanding on the way Apple tweaked the PID&n; * algorithm for the CPU control, it is definitely not a standard&n; * implementation...&n; *&n; * TODO:  - Check MPU structure version/signature&n; *        - Add things like /sbin/overtemp for non-critical&n; *          overtemp conditions so userland can take some policy&n; *          decisions, like slewing down CPUs&n; *&t;  - Deal with fan and i2c failures in a better way&n; *&n; * History:&n; *&n; *  Nov. 13, 2003 : 0.5&n; *&t;- First release&n; *&n; *  Nov. 14, 2003 : 0.6&n; *&t;- Read fan speed from FCU, low level fan routines now deal&n; *&t;  with errors &amp; check fan status, though higher level don&squot;t&n; *&t;  do much.&n; *&t;- Move a bunch of definitions to .h file&n; *&n; *  Nov. 18, 2003 : 0.7&n; *&t;- Fix build on ppc64 kernel&n; *&t;- Move back statics definitions to .c file&n; *&t;- Avoid calling schedule_timeout with a negative number&n; *&n; *  Dec. 18, 2003 : 0.8&n; *&t;- Fix typo when reading back fan speed on 2 CPU machines&n; *&n; *  Mar. 11, 2004 : 0.9&n; *&t;- Rework code accessing the ADC chips, make it more robust and&n; *&t;  closer to the chip spec. Also make sure it is configured properly,&n; *        I&squot;ve seen yet unexplained cases where on startup, I would have stale&n; *        values in the configuration register&n; *&t;- Switch back to use of target fan speed for PID, thus lowering&n; *        pressure on i2c&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/i2c.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#include &lt;linux/suspend.h&gt;
macro_line|#include &lt;linux/reboot.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;linux/i2c.h&gt;
macro_line|#include &lt;linux/i2c-dev.h&gt;
macro_line|#include &lt;asm/prom.h&gt;
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/sections.h&gt;
macro_line|#include &lt;asm/of_device.h&gt;
macro_line|#include &quot;therm_pm72.h&quot;
DECL|macro|VERSION
mdefine_line|#define VERSION &quot;0.9&quot;
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#ifdef DEBUG
DECL|macro|DBG
mdefine_line|#define DBG(args...)&t;printk(args)
macro_line|#else
DECL|macro|DBG
mdefine_line|#define DBG(args...)&t;do { } while(0)
macro_line|#endif
multiline_comment|/*&n; * Driver statics&n; */
DECL|variable|of_dev
r_static
r_struct
id|of_device
op_star
id|of_dev
suffix:semicolon
DECL|variable|u3_0
r_static
r_struct
id|i2c_adapter
op_star
id|u3_0
suffix:semicolon
DECL|variable|u3_1
r_static
r_struct
id|i2c_adapter
op_star
id|u3_1
suffix:semicolon
DECL|variable|fcu
r_static
r_struct
id|i2c_client
op_star
id|fcu
suffix:semicolon
DECL|variable|cpu_state
r_static
r_struct
id|cpu_pid_state
id|cpu_state
(braket
l_int|2
)braket
suffix:semicolon
DECL|variable|backside_state
r_static
r_struct
id|backside_pid_state
id|backside_state
suffix:semicolon
DECL|variable|drives_state
r_static
r_struct
id|drives_pid_state
id|drives_state
suffix:semicolon
DECL|variable|state
r_static
r_int
id|state
suffix:semicolon
DECL|variable|cpu_count
r_static
r_int
id|cpu_count
suffix:semicolon
DECL|variable|ctrl_task
r_static
id|pid_t
id|ctrl_task
suffix:semicolon
DECL|variable|ctrl_complete
r_static
r_struct
id|completion
id|ctrl_complete
suffix:semicolon
DECL|variable|critical_state
r_static
r_int
id|critical_state
suffix:semicolon
r_static
id|DECLARE_MUTEX
c_func
(paren
id|driver_lock
)paren
suffix:semicolon
multiline_comment|/*&n; * i2c_driver structure to attach to the host i2c controller&n; */
r_static
r_int
id|therm_pm72_attach
c_func
(paren
r_struct
id|i2c_adapter
op_star
id|adapter
)paren
suffix:semicolon
r_static
r_int
id|therm_pm72_detach
c_func
(paren
r_struct
id|i2c_adapter
op_star
id|adapter
)paren
suffix:semicolon
DECL|variable|therm_pm72_driver
r_static
r_struct
id|i2c_driver
id|therm_pm72_driver
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;therm_pm72&quot;
comma
dot
id|id
op_assign
l_int|0xDEADBEEF
comma
dot
id|flags
op_assign
id|I2C_DF_NOTIFY
comma
dot
id|attach_adapter
op_assign
id|therm_pm72_attach
comma
dot
id|detach_adapter
op_assign
id|therm_pm72_detach
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Utility function to create an i2c_client structure and&n; * attach it to one of u3 adapters&n; */
DECL|function|attach_i2c_chip
r_static
r_struct
id|i2c_client
op_star
id|attach_i2c_chip
c_func
(paren
r_int
id|id
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|i2c_client
op_star
id|clt
suffix:semicolon
r_struct
id|i2c_adapter
op_star
id|adap
suffix:semicolon
r_if
c_cond
(paren
id|id
op_amp
l_int|0x100
)paren
id|adap
op_assign
id|u3_1
suffix:semicolon
r_else
id|adap
op_assign
id|u3_0
suffix:semicolon
r_if
c_cond
(paren
id|adap
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|clt
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|i2c_client
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clt
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|clt
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|i2c_client
)paren
)paren
suffix:semicolon
id|clt-&gt;addr
op_assign
(paren
id|id
op_rshift
l_int|1
)paren
op_amp
l_int|0x7f
suffix:semicolon
id|clt-&gt;adapter
op_assign
id|adap
suffix:semicolon
id|clt-&gt;driver
op_assign
op_amp
id|therm_pm72_driver
suffix:semicolon
id|clt-&gt;id
op_assign
l_int|0xDEADBEEF
suffix:semicolon
id|strncpy
c_func
(paren
id|clt-&gt;name
comma
id|name
comma
id|I2C_NAME_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i2c_attach_client
c_func
(paren
id|clt
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;therm_pm72: Failed to attach to i2c ID 0x%x&bslash;n&quot;
comma
id|id
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|clt
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|clt
suffix:semicolon
)brace
multiline_comment|/*&n; * Utility function to get rid of the i2c_client structure&n; * (will also detach from the adapter hopepfully)&n; */
DECL|function|detach_i2c_chip
r_static
r_void
id|detach_i2c_chip
c_func
(paren
r_struct
id|i2c_client
op_star
id|clt
)paren
(brace
id|i2c_detach_client
c_func
(paren
id|clt
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|clt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Here are the i2c chip access wrappers&n; */
DECL|function|initialize_adc
r_static
r_void
id|initialize_adc
c_func
(paren
r_struct
id|cpu_pid_state
op_star
id|state
)paren
(brace
r_int
id|rc
suffix:semicolon
id|u8
id|buf
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* Read ADC the configuration register and cache it. We&n;&t; * also make sure Config2 contains proper values, I&squot;ve seen&n;&t; * cases where we got stale grabage in there, thus preventing&n;&t; * proper reading of conv. values&n;&t; */
multiline_comment|/* Clear Config2 */
id|buf
(braket
l_int|0
)braket
op_assign
l_int|5
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|i2c_master_send
c_func
(paren
id|state-&gt;monitor
comma
id|buf
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Read &amp; cache Config1 */
id|buf
(braket
l_int|0
)braket
op_assign
l_int|1
suffix:semicolon
id|rc
op_assign
id|i2c_master_send
c_func
(paren
id|state-&gt;monitor
comma
id|buf
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OG
l_int|0
)paren
(brace
id|rc
op_assign
id|i2c_master_recv
c_func
(paren
id|state-&gt;monitor
comma
id|buf
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OG
l_int|0
)paren
(brace
id|state-&gt;adc_config
op_assign
id|buf
(braket
l_int|0
)braket
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;ADC config reg: %02x&bslash;n&quot;
comma
id|state-&gt;adc_config
)paren
suffix:semicolon
multiline_comment|/* Disable shutdown mode */
id|state-&gt;adc_config
op_and_assign
l_int|0xfe
suffix:semicolon
id|buf
(braket
l_int|0
)braket
op_assign
l_int|1
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_assign
id|state-&gt;adc_config
suffix:semicolon
id|rc
op_assign
id|i2c_master_send
c_func
(paren
id|state-&gt;monitor
comma
id|buf
comma
l_int|2
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rc
op_le
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;therm_pm72: Error reading ADC config&quot;
l_string|&quot; register !&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|read_smon_adc
r_static
r_int
id|read_smon_adc
c_func
(paren
r_struct
id|cpu_pid_state
op_star
id|state
comma
r_int
id|chan
)paren
(brace
r_int
id|rc
comma
id|data
comma
id|tries
op_assign
l_int|0
suffix:semicolon
id|u8
id|buf
(braket
l_int|2
)braket
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* Set channel */
id|buf
(braket
l_int|0
)braket
op_assign
l_int|1
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_assign
(paren
id|state-&gt;adc_config
op_amp
l_int|0x1f
)paren
op_or
(paren
id|chan
op_lshift
l_int|5
)paren
suffix:semicolon
id|rc
op_assign
id|i2c_master_send
c_func
(paren
id|state-&gt;monitor
comma
id|buf
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_le
l_int|0
)paren
r_goto
id|error
suffix:semicolon
multiline_comment|/* Wait for convertion */
id|msleep
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Switch to data register */
id|buf
(braket
l_int|0
)braket
op_assign
l_int|4
suffix:semicolon
id|rc
op_assign
id|i2c_master_send
c_func
(paren
id|state-&gt;monitor
comma
id|buf
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_le
l_int|0
)paren
r_goto
id|error
suffix:semicolon
multiline_comment|/* Read result */
id|rc
op_assign
id|i2c_master_recv
c_func
(paren
id|state-&gt;monitor
comma
id|buf
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
r_goto
id|error
suffix:semicolon
id|data
op_assign
(paren
(paren
id|u16
)paren
id|buf
(braket
l_int|0
)braket
)paren
op_lshift
l_int|8
op_or
(paren
id|u16
)paren
id|buf
(braket
l_int|1
)braket
suffix:semicolon
r_return
id|data
op_rshift
l_int|6
suffix:semicolon
id|error
suffix:colon
id|DBG
c_func
(paren
l_string|&quot;Error reading ADC, retrying...&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|tries
OG
l_int|10
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;therm_pm72: Error reading ADC !&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|msleep
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
)brace
DECL|function|fan_read_reg
r_static
r_int
id|fan_read_reg
c_func
(paren
r_int
id|reg
comma
r_int
r_char
op_star
id|buf
comma
r_int
id|nb
)paren
(brace
r_int
id|tries
comma
id|nr
comma
id|nw
suffix:semicolon
id|buf
(braket
l_int|0
)braket
op_assign
id|reg
suffix:semicolon
id|tries
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|nw
op_assign
id|i2c_master_send
c_func
(paren
id|fcu
comma
id|buf
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nw
OG
l_int|0
op_logical_or
(paren
id|nw
OL
l_int|0
op_logical_and
id|nw
op_ne
op_minus
id|EIO
)paren
op_logical_or
id|tries
op_ge
l_int|100
)paren
r_break
suffix:semicolon
id|msleep
c_func
(paren
l_int|10
)paren
suffix:semicolon
op_increment
id|tries
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nw
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Failure writing address to FCU: %d&quot;
comma
id|nw
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|tries
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|nr
op_assign
id|i2c_master_recv
c_func
(paren
id|fcu
comma
id|buf
comma
id|nb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
OG
l_int|0
op_logical_or
(paren
id|nr
OL
l_int|0
op_logical_and
id|nr
op_ne
id|ENODEV
)paren
op_logical_or
id|tries
op_ge
l_int|100
)paren
r_break
suffix:semicolon
id|msleep
c_func
(paren
l_int|10
)paren
suffix:semicolon
op_increment
id|tries
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nr
op_le
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Failure reading data from FCU: %d&quot;
comma
id|nw
)paren
suffix:semicolon
r_return
id|nr
suffix:semicolon
)brace
DECL|function|fan_write_reg
r_static
r_int
id|fan_write_reg
c_func
(paren
r_int
id|reg
comma
r_const
r_int
r_char
op_star
id|ptr
comma
r_int
id|nb
)paren
(brace
r_int
id|tries
comma
id|nw
suffix:semicolon
r_int
r_char
id|buf
(braket
l_int|16
)braket
suffix:semicolon
id|buf
(braket
l_int|0
)braket
op_assign
id|reg
suffix:semicolon
id|memcpy
c_func
(paren
id|buf
op_plus
l_int|1
comma
id|ptr
comma
id|nb
)paren
suffix:semicolon
op_increment
id|nb
suffix:semicolon
id|tries
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|nw
op_assign
id|i2c_master_send
c_func
(paren
id|fcu
comma
id|buf
comma
id|nb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nw
OG
l_int|0
op_logical_or
(paren
id|nw
OL
l_int|0
op_logical_and
id|nw
op_ne
id|EIO
)paren
op_logical_or
id|tries
op_ge
l_int|100
)paren
r_break
suffix:semicolon
id|msleep
c_func
(paren
l_int|10
)paren
suffix:semicolon
op_increment
id|tries
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nw
OL
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Failure writing to FCU: %d&quot;
comma
id|nw
)paren
suffix:semicolon
r_return
id|nw
suffix:semicolon
)brace
DECL|function|start_fcu
r_static
r_int
id|start_fcu
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|buf
op_assign
l_int|0xff
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|rc
op_assign
id|fan_write_reg
c_func
(paren
l_int|0xe
comma
op_amp
id|buf
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|rc
op_assign
id|fan_write_reg
c_func
(paren
l_int|0x2e
comma
op_amp
id|buf
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|set_rpm_fan
r_static
r_int
id|set_rpm_fan
c_func
(paren
r_int
id|fan
comma
r_int
id|rpm
)paren
(brace
r_int
r_char
id|buf
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|rpm
OL
l_int|300
)paren
id|rpm
op_assign
l_int|300
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rpm
OG
l_int|8191
)paren
id|rpm
op_assign
l_int|8191
suffix:semicolon
id|buf
(braket
l_int|0
)braket
op_assign
id|rpm
op_rshift
l_int|5
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_assign
id|rpm
op_lshift
l_int|3
suffix:semicolon
id|rc
op_assign
id|fan_write_reg
c_func
(paren
l_int|0x10
op_plus
(paren
id|fan
op_star
l_int|2
)paren
comma
id|buf
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|get_rpm_fan
r_static
r_int
id|get_rpm_fan
c_func
(paren
r_int
id|fan
comma
r_int
id|programmed
)paren
(brace
r_int
r_char
id|failure
suffix:semicolon
r_int
r_char
id|active
suffix:semicolon
r_int
r_char
id|buf
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|rc
comma
id|reg_base
suffix:semicolon
id|rc
op_assign
id|fan_read_reg
c_func
(paren
l_int|0xb
comma
op_amp
id|failure
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|1
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
(paren
id|failure
op_amp
(paren
l_int|1
op_lshift
id|fan
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|rc
op_assign
id|fan_read_reg
c_func
(paren
l_int|0xd
comma
op_amp
id|active
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|1
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
(paren
id|active
op_amp
(paren
l_int|1
op_lshift
id|fan
)paren
)paren
op_eq
l_int|0
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
multiline_comment|/* Programmed value or real current speed */
id|reg_base
op_assign
id|programmed
ques
c_cond
l_int|0x10
suffix:colon
l_int|0x11
suffix:semicolon
id|rc
op_assign
id|fan_read_reg
c_func
(paren
id|reg_base
op_plus
(paren
id|fan
op_star
l_int|2
)paren
comma
id|buf
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|2
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
(paren
id|buf
(braket
l_int|0
)braket
op_lshift
l_int|5
)paren
op_or
id|buf
(braket
l_int|1
)braket
op_rshift
l_int|3
suffix:semicolon
)brace
DECL|function|set_pwm_fan
r_static
r_int
id|set_pwm_fan
c_func
(paren
r_int
id|fan
comma
r_int
id|pwm
)paren
(brace
r_int
r_char
id|buf
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|pwm
OL
l_int|10
)paren
id|pwm
op_assign
l_int|10
suffix:semicolon
r_else
r_if
c_cond
(paren
id|pwm
OG
l_int|100
)paren
id|pwm
op_assign
l_int|100
suffix:semicolon
id|pwm
op_assign
(paren
id|pwm
op_star
l_int|2559
)paren
op_div
l_int|1000
suffix:semicolon
id|buf
(braket
l_int|0
)braket
op_assign
id|pwm
suffix:semicolon
id|rc
op_assign
id|fan_write_reg
c_func
(paren
l_int|0x30
op_plus
(paren
id|fan
op_star
l_int|2
)paren
comma
id|buf
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
r_return
id|rc
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|get_pwm_fan
r_static
r_int
id|get_pwm_fan
c_func
(paren
r_int
id|fan
)paren
(brace
r_int
r_char
id|failure
suffix:semicolon
r_int
r_char
id|active
suffix:semicolon
r_int
r_char
id|buf
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|rc
op_assign
id|fan_read_reg
c_func
(paren
l_int|0x2b
comma
op_amp
id|failure
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|1
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
(paren
id|failure
op_amp
(paren
l_int|1
op_lshift
id|fan
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|rc
op_assign
id|fan_read_reg
c_func
(paren
l_int|0x2d
comma
op_amp
id|active
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|1
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
(paren
id|active
op_amp
(paren
l_int|1
op_lshift
id|fan
)paren
)paren
op_eq
l_int|0
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
multiline_comment|/* Programmed value or real current speed */
id|rc
op_assign
id|fan_read_reg
c_func
(paren
l_int|0x30
op_plus
(paren
id|fan
op_star
l_int|2
)paren
comma
id|buf
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|1
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
(paren
id|buf
(braket
l_int|0
)braket
op_star
l_int|1000
)paren
op_div
l_int|2559
suffix:semicolon
)brace
multiline_comment|/*&n; * Utility routine to read the CPU calibration EEPROM data&n; * from the device-tree&n; */
DECL|function|read_eeprom
r_static
r_int
id|read_eeprom
c_func
(paren
r_int
id|cpu
comma
r_struct
id|mpu_data
op_star
id|out
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
r_char
id|nodename
(braket
l_int|64
)braket
suffix:semicolon
id|u8
op_star
id|data
suffix:semicolon
r_int
id|len
suffix:semicolon
multiline_comment|/* prom.c routine for finding a node by path is a bit brain dead&n;&t; * and requires exact @xxx unit numbers. This is a bit ugly but&n;&t; * will work for these machines&n;&t; */
id|sprintf
c_func
(paren
id|nodename
comma
l_string|&quot;/u3@0,f8000000/i2c@f8001000/cpuid@a%d&quot;
comma
id|cpu
ques
c_cond
l_int|2
suffix:colon
l_int|0
)paren
suffix:semicolon
id|np
op_assign
id|of_find_node_by_path
c_func
(paren
id|nodename
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;therm_pm72: Failed to retreive cpuid node from device-tree&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|data
op_assign
(paren
id|u8
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;cpuid&quot;
comma
op_amp
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;therm_pm72: Failed to retreive cpuid property from device-tree&bslash;n&quot;
)paren
suffix:semicolon
id|of_node_put
c_func
(paren
id|np
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|out
comma
id|data
comma
r_sizeof
(paren
r_struct
id|mpu_data
)paren
)paren
suffix:semicolon
id|of_node_put
c_func
(paren
id|np
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * Now, unfortunately, sysfs doesn&squot;t give us a nice void * we could&n; * pass around to the attribute functions, so we don&squot;t really have&n; * choice but implement a bunch of them...&n; *&n; * That sucks a bit, we take the lock because FIX32TOPRINT evaluates&n; * the input twice... I accept patches :)&n; */
DECL|macro|BUILD_SHOW_FUNC_FIX
mdefine_line|#define BUILD_SHOW_FUNC_FIX(name, data)&t;&t;&t;&t;&bslash;&n;static ssize_t show_##name(struct device *dev, char *buf)&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ssize_t r;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;down(&amp;driver_lock);&t;&t;&t;&t;&t;&bslash;&n;&t;r = sprintf(buf, &quot;%d.%03d&quot;, FIX32TOPRINT(data));&t;&bslash;&n;&t;up(&amp;driver_lock);&t;&t;&t;&t;&t;&bslash;&n;&t;return r;&t;&t;&t;&t;&t;&t;&bslash;&n;}
DECL|macro|BUILD_SHOW_FUNC_INT
mdefine_line|#define BUILD_SHOW_FUNC_INT(name, data)&t;&t;&t;&t;&bslash;&n;static ssize_t show_##name(struct device *dev, char *buf)&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;return sprintf(buf, &quot;%d&quot;, data);&t;&t;&t;&bslash;&n;}
id|BUILD_SHOW_FUNC_FIX
c_func
(paren
id|cpu0_temperature
comma
id|cpu_state
(braket
l_int|0
)braket
dot
id|last_temp
)paren
id|BUILD_SHOW_FUNC_FIX
c_func
(paren
id|cpu0_voltage
comma
id|cpu_state
(braket
l_int|0
)braket
dot
id|voltage
)paren
id|BUILD_SHOW_FUNC_FIX
c_func
(paren
id|cpu0_current
comma
id|cpu_state
(braket
l_int|0
)braket
dot
id|current_a
)paren
id|BUILD_SHOW_FUNC_INT
c_func
(paren
id|cpu0_exhaust_fan_rpm
comma
id|cpu_state
(braket
l_int|0
)braket
dot
id|rpm
)paren
id|BUILD_SHOW_FUNC_INT
c_func
(paren
id|cpu0_intake_fan_rpm
comma
id|cpu_state
(braket
l_int|0
)braket
dot
id|intake_rpm
)paren
id|BUILD_SHOW_FUNC_FIX
c_func
(paren
id|cpu1_temperature
comma
id|cpu_state
(braket
l_int|1
)braket
dot
id|last_temp
)paren
id|BUILD_SHOW_FUNC_FIX
c_func
(paren
id|cpu1_voltage
comma
id|cpu_state
(braket
l_int|1
)braket
dot
id|voltage
)paren
id|BUILD_SHOW_FUNC_FIX
c_func
(paren
id|cpu1_current
comma
id|cpu_state
(braket
l_int|1
)braket
dot
id|current_a
)paren
id|BUILD_SHOW_FUNC_INT
c_func
(paren
id|cpu1_exhaust_fan_rpm
comma
id|cpu_state
(braket
l_int|1
)braket
dot
id|rpm
)paren
id|BUILD_SHOW_FUNC_INT
c_func
(paren
id|cpu1_intake_fan_rpm
comma
id|cpu_state
(braket
l_int|1
)braket
dot
id|intake_rpm
)paren
id|BUILD_SHOW_FUNC_FIX
c_func
(paren
id|backside_temperature
comma
id|backside_state.last_temp
)paren
id|BUILD_SHOW_FUNC_INT
c_func
(paren
id|backside_fan_pwm
comma
id|backside_state.pwm
)paren
id|BUILD_SHOW_FUNC_FIX
c_func
(paren
id|drives_temperature
comma
id|drives_state.last_temp
)paren
id|BUILD_SHOW_FUNC_INT
c_func
(paren
id|drives_fan_rpm
comma
id|drives_state.rpm
)paren
r_static
id|DEVICE_ATTR
c_func
(paren
id|cpu0_temperature
comma
id|S_IRUGO
comma
id|show_cpu0_temperature
comma
l_int|NULL
)paren
suffix:semicolon
r_static
id|DEVICE_ATTR
c_func
(paren
id|cpu0_voltage
comma
id|S_IRUGO
comma
id|show_cpu0_voltage
comma
l_int|NULL
)paren
suffix:semicolon
r_static
id|DEVICE_ATTR
c_func
(paren
id|cpu0_current
comma
id|S_IRUGO
comma
id|show_cpu0_current
comma
l_int|NULL
)paren
suffix:semicolon
r_static
id|DEVICE_ATTR
c_func
(paren
id|cpu0_exhaust_fan_rpm
comma
id|S_IRUGO
comma
id|show_cpu0_exhaust_fan_rpm
comma
l_int|NULL
)paren
suffix:semicolon
r_static
id|DEVICE_ATTR
c_func
(paren
id|cpu0_intake_fan_rpm
comma
id|S_IRUGO
comma
id|show_cpu0_intake_fan_rpm
comma
l_int|NULL
)paren
suffix:semicolon
r_static
id|DEVICE_ATTR
c_func
(paren
id|cpu1_temperature
comma
id|S_IRUGO
comma
id|show_cpu1_temperature
comma
l_int|NULL
)paren
suffix:semicolon
r_static
id|DEVICE_ATTR
c_func
(paren
id|cpu1_voltage
comma
id|S_IRUGO
comma
id|show_cpu1_voltage
comma
l_int|NULL
)paren
suffix:semicolon
r_static
id|DEVICE_ATTR
c_func
(paren
id|cpu1_current
comma
id|S_IRUGO
comma
id|show_cpu1_current
comma
l_int|NULL
)paren
suffix:semicolon
r_static
id|DEVICE_ATTR
c_func
(paren
id|cpu1_exhaust_fan_rpm
comma
id|S_IRUGO
comma
id|show_cpu1_exhaust_fan_rpm
comma
l_int|NULL
)paren
suffix:semicolon
r_static
id|DEVICE_ATTR
c_func
(paren
id|cpu1_intake_fan_rpm
comma
id|S_IRUGO
comma
id|show_cpu1_intake_fan_rpm
comma
l_int|NULL
)paren
suffix:semicolon
r_static
id|DEVICE_ATTR
c_func
(paren
id|backside_temperature
comma
id|S_IRUGO
comma
id|show_backside_temperature
comma
l_int|NULL
)paren
suffix:semicolon
r_static
id|DEVICE_ATTR
c_func
(paren
id|backside_fan_pwm
comma
id|S_IRUGO
comma
id|show_backside_fan_pwm
comma
l_int|NULL
)paren
suffix:semicolon
r_static
id|DEVICE_ATTR
c_func
(paren
id|drives_temperature
comma
id|S_IRUGO
comma
id|show_drives_temperature
comma
l_int|NULL
)paren
suffix:semicolon
r_static
id|DEVICE_ATTR
c_func
(paren
id|drives_fan_rpm
comma
id|S_IRUGO
comma
id|show_drives_fan_rpm
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n; * CPUs fans control loop&n; */
DECL|function|do_monitor_cpu
r_static
r_void
id|do_monitor_cpu
c_func
(paren
r_struct
id|cpu_pid_state
op_star
id|state
)paren
(brace
id|s32
id|temp
comma
id|voltage
comma
id|current_a
comma
id|power
comma
id|power_target
suffix:semicolon
id|s32
id|integral
comma
id|derivative
comma
id|proportional
comma
id|adj_in_target
comma
id|sval
suffix:semicolon
id|s64
id|integ_p
comma
id|deriv_p
comma
id|prop_p
comma
id|sum
suffix:semicolon
r_int
id|i
comma
id|intake
comma
id|rc
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;cpu %d:&bslash;n&quot;
comma
id|state-&gt;index
)paren
suffix:semicolon
multiline_comment|/* Read current fan status */
r_if
c_cond
(paren
id|state-&gt;index
op_eq
l_int|0
)paren
id|rc
op_assign
id|get_rpm_fan
c_func
(paren
id|CPUA_EXHAUST_FAN_RPM_ID
comma
op_logical_neg
id|RPM_PID_USE_ACTUAL_SPEED
)paren
suffix:semicolon
r_else
id|rc
op_assign
id|get_rpm_fan
c_func
(paren
id|CPUB_EXHAUST_FAN_RPM_ID
comma
op_logical_neg
id|RPM_PID_USE_ACTUAL_SPEED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Error %d reading CPU %d exhaust fan !&bslash;n&quot;
comma
id|rc
comma
id|state-&gt;index
)paren
suffix:semicolon
multiline_comment|/* XXX What do we do now ? */
)brace
r_else
id|state-&gt;rpm
op_assign
id|rc
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;  current rpm: %d&bslash;n&quot;
comma
id|state-&gt;rpm
)paren
suffix:semicolon
multiline_comment|/* Get some sensor readings and scale it */
id|temp
op_assign
id|read_smon_adc
c_func
(paren
id|state
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|temp
op_eq
op_minus
l_int|1
)paren
(brace
id|state-&gt;overtemp
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
id|voltage
op_assign
id|read_smon_adc
c_func
(paren
id|state
comma
l_int|3
)paren
suffix:semicolon
id|current_a
op_assign
id|read_smon_adc
c_func
(paren
id|state
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Fixup temperature according to diode calibration&n;&t; */
id|DBG
c_func
(paren
l_string|&quot;  temp raw: %04x, m_diode: %04x, b_diode: %04x&bslash;n&quot;
comma
id|temp
comma
id|state-&gt;mpu.mdiode
comma
id|state-&gt;mpu.bdiode
)paren
suffix:semicolon
id|temp
op_assign
(paren
(paren
id|s32
)paren
id|temp
op_star
(paren
id|s32
)paren
id|state-&gt;mpu.mdiode
op_plus
(paren
(paren
id|s32
)paren
id|state-&gt;mpu.bdiode
op_lshift
l_int|12
)paren
)paren
op_rshift
l_int|2
suffix:semicolon
id|state-&gt;last_temp
op_assign
id|temp
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;  temp: %d.%03d&bslash;n&quot;
comma
id|FIX32TOPRINT
c_func
(paren
id|temp
)paren
)paren
suffix:semicolon
multiline_comment|/* Check tmax, increment overtemp if we are there. At tmax+8, we go&n;&t; * full blown immediately and try to trigger a shutdown&n;&t; */
r_if
c_cond
(paren
id|temp
op_ge
(paren
(paren
id|state-&gt;mpu.tmax
op_plus
l_int|8
)paren
op_lshift
l_int|16
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Warning ! CPU %d temperature way above maximum&quot;
l_string|&quot; (%d) !&bslash;n&quot;
comma
id|state-&gt;index
comma
id|temp
op_rshift
l_int|16
)paren
suffix:semicolon
id|state-&gt;overtemp
op_assign
id|CPU_MAX_OVERTEMP
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|temp
OG
(paren
id|state-&gt;mpu.tmax
op_lshift
l_int|16
)paren
)paren
id|state-&gt;overtemp
op_increment
suffix:semicolon
r_else
id|state-&gt;overtemp
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;overtemp
op_ge
id|CPU_MAX_OVERTEMP
)paren
id|critical_state
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;overtemp
OG
l_int|0
)paren
(brace
id|state-&gt;rpm
op_assign
id|state-&gt;mpu.rmaxn_exhaust_fan
suffix:semicolon
id|state-&gt;intake_rpm
op_assign
id|intake
op_assign
id|state-&gt;mpu.rmaxn_intake_fan
suffix:semicolon
r_goto
id|do_set_fans
suffix:semicolon
)brace
multiline_comment|/* Scale other sensor values according to fixed scales&n;&t; * obtained in Darwin and calculate power from I and V&n;&t; */
id|state-&gt;voltage
op_assign
id|voltage
op_mul_assign
id|ADC_CPU_VOLTAGE_SCALE
suffix:semicolon
id|state-&gt;current_a
op_assign
id|current_a
op_mul_assign
id|ADC_CPU_CURRENT_SCALE
suffix:semicolon
id|power
op_assign
(paren
(paren
(paren
id|u64
)paren
id|current_a
)paren
op_star
(paren
(paren
id|u64
)paren
id|voltage
)paren
)paren
op_rshift
l_int|16
suffix:semicolon
multiline_comment|/* Calculate power target value (could be done once for all)&n;&t; * and convert to a 16.16 fp number&n;&t; */
id|power_target
op_assign
(paren
(paren
id|u32
)paren
(paren
id|state-&gt;mpu.pmaxh
op_minus
id|state-&gt;mpu.padjmax
)paren
)paren
op_lshift
l_int|16
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;  current: %d.%03d, voltage: %d.%03d&bslash;n&quot;
comma
id|FIX32TOPRINT
c_func
(paren
id|current_a
)paren
comma
id|FIX32TOPRINT
c_func
(paren
id|voltage
)paren
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;  power: %d.%03d W, target: %d.%03d, error: %d.%03d&bslash;n&quot;
comma
id|FIX32TOPRINT
c_func
(paren
id|power
)paren
comma
id|FIX32TOPRINT
c_func
(paren
id|power_target
)paren
comma
id|FIX32TOPRINT
c_func
(paren
id|power_target
op_minus
id|power
)paren
)paren
suffix:semicolon
multiline_comment|/* Store temperature and power in history array */
id|state-&gt;cur_temp
op_assign
(paren
id|state-&gt;cur_temp
op_plus
l_int|1
)paren
op_mod
id|CPU_TEMP_HISTORY_SIZE
suffix:semicolon
id|state-&gt;temp_history
(braket
id|state-&gt;cur_temp
)braket
op_assign
id|temp
suffix:semicolon
id|state-&gt;cur_power
op_assign
(paren
id|state-&gt;cur_power
op_plus
l_int|1
)paren
op_mod
id|state-&gt;count_power
suffix:semicolon
id|state-&gt;power_history
(braket
id|state-&gt;cur_power
)braket
op_assign
id|power
suffix:semicolon
id|state-&gt;error_history
(braket
id|state-&gt;cur_power
)braket
op_assign
id|power_target
op_minus
id|power
suffix:semicolon
multiline_comment|/* If first loop, fill the history table */
r_if
c_cond
(paren
id|state-&gt;first
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|state-&gt;count_power
op_minus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|state-&gt;cur_power
op_assign
(paren
id|state-&gt;cur_power
op_plus
l_int|1
)paren
op_mod
id|state-&gt;count_power
suffix:semicolon
id|state-&gt;power_history
(braket
id|state-&gt;cur_power
)braket
op_assign
id|power
suffix:semicolon
id|state-&gt;error_history
(braket
id|state-&gt;cur_power
)braket
op_assign
id|power_target
op_minus
id|power
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|CPU_TEMP_HISTORY_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|state-&gt;cur_temp
op_assign
(paren
id|state-&gt;cur_temp
op_plus
l_int|1
)paren
op_mod
id|CPU_TEMP_HISTORY_SIZE
suffix:semicolon
id|state-&gt;temp_history
(braket
id|state-&gt;cur_temp
)braket
op_assign
id|temp
suffix:semicolon
)brace
id|state-&gt;first
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Calculate the integral term normally based on the &quot;power&quot; values */
id|sum
op_assign
l_int|0
suffix:semicolon
id|integral
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|state-&gt;count_power
suffix:semicolon
id|i
op_increment
)paren
id|integral
op_add_assign
id|state-&gt;error_history
(braket
id|i
)braket
suffix:semicolon
id|integral
op_mul_assign
id|CPU_PID_INTERVAL
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;  integral: %08x&bslash;n&quot;
comma
id|integral
)paren
suffix:semicolon
multiline_comment|/* Calculate the adjusted input (sense value).&n;&t; *   G_r is 12.20&n;&t; *   integ is 16.16&n;&t; *   so the result is 28.36&n;&t; *&n;&t; * input target is mpu.ttarget, input max is mpu.tmax&n;&t; */
id|integ_p
op_assign
(paren
(paren
id|s64
)paren
id|state-&gt;mpu.pid_gr
)paren
op_star
(paren
id|s64
)paren
id|integral
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;   integ_p: %d&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|deriv_p
op_rshift
l_int|36
)paren
)paren
suffix:semicolon
id|sval
op_assign
(paren
id|state-&gt;mpu.tmax
op_lshift
l_int|16
)paren
op_minus
(paren
(paren
id|integ_p
op_rshift
l_int|20
)paren
op_amp
l_int|0xffffffff
)paren
suffix:semicolon
id|adj_in_target
op_assign
(paren
id|state-&gt;mpu.ttarget
op_lshift
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
id|adj_in_target
OG
id|sval
)paren
id|adj_in_target
op_assign
id|sval
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;   adj_in_target: %d.%03d, ttarget: %d&bslash;n&quot;
comma
id|FIX32TOPRINT
c_func
(paren
id|adj_in_target
)paren
comma
id|state-&gt;mpu.ttarget
)paren
suffix:semicolon
multiline_comment|/* Calculate the derivative term */
id|derivative
op_assign
id|state-&gt;temp_history
(braket
id|state-&gt;cur_temp
)braket
op_minus
id|state-&gt;temp_history
(braket
(paren
id|state-&gt;cur_temp
op_plus
id|CPU_TEMP_HISTORY_SIZE
op_minus
l_int|1
)paren
op_mod
id|CPU_TEMP_HISTORY_SIZE
)braket
suffix:semicolon
id|derivative
op_div_assign
id|CPU_PID_INTERVAL
suffix:semicolon
id|deriv_p
op_assign
(paren
(paren
id|s64
)paren
id|state-&gt;mpu.pid_gd
)paren
op_star
(paren
id|s64
)paren
id|derivative
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;   deriv_p: %d&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|deriv_p
op_rshift
l_int|36
)paren
)paren
suffix:semicolon
id|sum
op_add_assign
id|deriv_p
suffix:semicolon
multiline_comment|/* Calculate the proportional term */
id|proportional
op_assign
id|temp
op_minus
id|adj_in_target
suffix:semicolon
id|prop_p
op_assign
(paren
(paren
id|s64
)paren
id|state-&gt;mpu.pid_gp
)paren
op_star
(paren
id|s64
)paren
id|proportional
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;   prop_p: %d&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|prop_p
op_rshift
l_int|36
)paren
)paren
suffix:semicolon
id|sum
op_add_assign
id|prop_p
suffix:semicolon
multiline_comment|/* Scale sum */
id|sum
op_rshift_assign
l_int|36
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;   sum: %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|sum
)paren
suffix:semicolon
id|state-&gt;rpm
op_add_assign
(paren
id|s32
)paren
id|sum
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;rpm
OL
id|state-&gt;mpu.rminn_exhaust_fan
)paren
id|state-&gt;rpm
op_assign
id|state-&gt;mpu.rminn_exhaust_fan
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;rpm
OG
id|state-&gt;mpu.rmaxn_exhaust_fan
)paren
id|state-&gt;rpm
op_assign
id|state-&gt;mpu.rmaxn_exhaust_fan
suffix:semicolon
id|intake
op_assign
(paren
id|state-&gt;rpm
op_star
id|CPU_INTAKE_SCALE
)paren
op_rshift
l_int|16
suffix:semicolon
r_if
c_cond
(paren
id|intake
OL
id|state-&gt;mpu.rminn_intake_fan
)paren
id|intake
op_assign
id|state-&gt;mpu.rminn_intake_fan
suffix:semicolon
r_if
c_cond
(paren
id|intake
OG
id|state-&gt;mpu.rmaxn_intake_fan
)paren
id|intake
op_assign
id|state-&gt;mpu.rmaxn_intake_fan
suffix:semicolon
id|state-&gt;intake_rpm
op_assign
id|intake
suffix:semicolon
id|do_set_fans
suffix:colon
id|DBG
c_func
(paren
l_string|&quot;** CPU %d RPM: %d Ex, %d In, overtemp: %d&bslash;n&quot;
comma
id|state-&gt;index
comma
(paren
r_int
)paren
id|state-&gt;rpm
comma
id|intake
comma
id|state-&gt;overtemp
)paren
suffix:semicolon
multiline_comment|/* We should check for errors, shouldn&squot;t we ? But then, what&n;&t; * do we do once the error occurs ? For FCU notified fan&n;&t; * failures (-EFAULT) we probably want to notify userland&n;&t; * some way...&n;&t; */
r_if
c_cond
(paren
id|state-&gt;index
op_eq
l_int|0
)paren
(brace
id|set_rpm_fan
c_func
(paren
id|CPUA_INTAKE_FAN_RPM_ID
comma
id|intake
)paren
suffix:semicolon
id|set_rpm_fan
c_func
(paren
id|CPUA_EXHAUST_FAN_RPM_ID
comma
id|state-&gt;rpm
)paren
suffix:semicolon
)brace
r_else
(brace
id|set_rpm_fan
c_func
(paren
id|CPUB_INTAKE_FAN_RPM_ID
comma
id|intake
)paren
suffix:semicolon
id|set_rpm_fan
c_func
(paren
id|CPUB_EXHAUST_FAN_RPM_ID
comma
id|state-&gt;rpm
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Initialize the state structure for one CPU control loop&n; */
DECL|function|init_cpu_state
r_static
r_int
id|init_cpu_state
c_func
(paren
r_struct
id|cpu_pid_state
op_star
id|state
comma
r_int
id|index
)paren
(brace
id|state-&gt;index
op_assign
id|index
suffix:semicolon
id|state-&gt;first
op_assign
l_int|1
suffix:semicolon
id|state-&gt;rpm
op_assign
l_int|1000
suffix:semicolon
id|state-&gt;overtemp
op_assign
l_int|0
suffix:semicolon
id|state-&gt;adc_config
op_assign
l_int|0x00
suffix:semicolon
r_if
c_cond
(paren
id|index
op_eq
l_int|0
)paren
id|state-&gt;monitor
op_assign
id|attach_i2c_chip
c_func
(paren
id|SUPPLY_MONITOR_ID
comma
l_string|&quot;CPU0_monitor&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|index
op_eq
l_int|1
)paren
id|state-&gt;monitor
op_assign
id|attach_i2c_chip
c_func
(paren
id|SUPPLY_MONITORB_ID
comma
l_string|&quot;CPU1_monitor&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;monitor
op_eq
l_int|NULL
)paren
r_goto
id|fail
suffix:semicolon
r_if
c_cond
(paren
id|read_eeprom
c_func
(paren
id|index
comma
op_amp
id|state-&gt;mpu
)paren
)paren
r_goto
id|fail
suffix:semicolon
id|state-&gt;count_power
op_assign
id|state-&gt;mpu.tguardband
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;count_power
OG
id|CPU_POWER_HISTORY_SIZE
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Warning ! too many power history slots&bslash;n&quot;
)paren
suffix:semicolon
id|state-&gt;count_power
op_assign
id|CPU_POWER_HISTORY_SIZE
suffix:semicolon
)brace
id|DBG
c_func
(paren
l_string|&quot;CPU %d Using %d power history entries&bslash;n&quot;
comma
id|index
comma
id|state-&gt;count_power
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index
op_eq
l_int|0
)paren
(brace
id|device_create_file
c_func
(paren
op_amp
id|of_dev-&gt;dev
comma
op_amp
id|dev_attr_cpu0_temperature
)paren
suffix:semicolon
id|device_create_file
c_func
(paren
op_amp
id|of_dev-&gt;dev
comma
op_amp
id|dev_attr_cpu0_voltage
)paren
suffix:semicolon
id|device_create_file
c_func
(paren
op_amp
id|of_dev-&gt;dev
comma
op_amp
id|dev_attr_cpu0_current
)paren
suffix:semicolon
id|device_create_file
c_func
(paren
op_amp
id|of_dev-&gt;dev
comma
op_amp
id|dev_attr_cpu0_exhaust_fan_rpm
)paren
suffix:semicolon
id|device_create_file
c_func
(paren
op_amp
id|of_dev-&gt;dev
comma
op_amp
id|dev_attr_cpu0_intake_fan_rpm
)paren
suffix:semicolon
)brace
r_else
(brace
id|device_create_file
c_func
(paren
op_amp
id|of_dev-&gt;dev
comma
op_amp
id|dev_attr_cpu1_temperature
)paren
suffix:semicolon
id|device_create_file
c_func
(paren
op_amp
id|of_dev-&gt;dev
comma
op_amp
id|dev_attr_cpu1_voltage
)paren
suffix:semicolon
id|device_create_file
c_func
(paren
op_amp
id|of_dev-&gt;dev
comma
op_amp
id|dev_attr_cpu1_current
)paren
suffix:semicolon
id|device_create_file
c_func
(paren
op_amp
id|of_dev-&gt;dev
comma
op_amp
id|dev_attr_cpu1_exhaust_fan_rpm
)paren
suffix:semicolon
id|device_create_file
c_func
(paren
op_amp
id|of_dev-&gt;dev
comma
op_amp
id|dev_attr_cpu1_intake_fan_rpm
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|fail
suffix:colon
r_if
c_cond
(paren
id|state-&gt;monitor
)paren
id|detach_i2c_chip
c_func
(paren
id|state-&gt;monitor
)paren
suffix:semicolon
id|state-&gt;monitor
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n; * Dispose of the state data for one CPU control loop&n; */
DECL|function|dispose_cpu_state
r_static
r_void
id|dispose_cpu_state
c_func
(paren
r_struct
id|cpu_pid_state
op_star
id|state
)paren
(brace
r_if
c_cond
(paren
id|state-&gt;monitor
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;index
op_eq
l_int|0
)paren
(brace
id|device_remove_file
c_func
(paren
op_amp
id|of_dev-&gt;dev
comma
op_amp
id|dev_attr_cpu0_temperature
)paren
suffix:semicolon
id|device_remove_file
c_func
(paren
op_amp
id|of_dev-&gt;dev
comma
op_amp
id|dev_attr_cpu0_voltage
)paren
suffix:semicolon
id|device_remove_file
c_func
(paren
op_amp
id|of_dev-&gt;dev
comma
op_amp
id|dev_attr_cpu0_current
)paren
suffix:semicolon
id|device_remove_file
c_func
(paren
op_amp
id|of_dev-&gt;dev
comma
op_amp
id|dev_attr_cpu0_exhaust_fan_rpm
)paren
suffix:semicolon
id|device_remove_file
c_func
(paren
op_amp
id|of_dev-&gt;dev
comma
op_amp
id|dev_attr_cpu0_intake_fan_rpm
)paren
suffix:semicolon
)brace
r_else
(brace
id|device_remove_file
c_func
(paren
op_amp
id|of_dev-&gt;dev
comma
op_amp
id|dev_attr_cpu1_temperature
)paren
suffix:semicolon
id|device_remove_file
c_func
(paren
op_amp
id|of_dev-&gt;dev
comma
op_amp
id|dev_attr_cpu1_voltage
)paren
suffix:semicolon
id|device_remove_file
c_func
(paren
op_amp
id|of_dev-&gt;dev
comma
op_amp
id|dev_attr_cpu1_current
)paren
suffix:semicolon
id|device_remove_file
c_func
(paren
op_amp
id|of_dev-&gt;dev
comma
op_amp
id|dev_attr_cpu1_exhaust_fan_rpm
)paren
suffix:semicolon
id|device_remove_file
c_func
(paren
op_amp
id|of_dev-&gt;dev
comma
op_amp
id|dev_attr_cpu1_intake_fan_rpm
)paren
suffix:semicolon
)brace
id|detach_i2c_chip
c_func
(paren
id|state-&gt;monitor
)paren
suffix:semicolon
id|state-&gt;monitor
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Motherboard backside &amp; U3 heatsink fan control loop&n; */
DECL|function|do_monitor_backside
r_static
r_void
id|do_monitor_backside
c_func
(paren
r_struct
id|backside_pid_state
op_star
id|state
)paren
(brace
id|s32
id|temp
comma
id|integral
comma
id|derivative
suffix:semicolon
id|s64
id|integ_p
comma
id|deriv_p
comma
id|prop_p
comma
id|sum
suffix:semicolon
r_int
id|i
comma
id|rc
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|state-&gt;ticks
op_ne
l_int|0
)paren
r_return
suffix:semicolon
id|state-&gt;ticks
op_assign
id|BACKSIDE_PID_INTERVAL
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;backside:&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Check fan status */
id|rc
op_assign
id|get_pwm_fan
c_func
(paren
id|BACKSIDE_FAN_PWM_ID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Error %d reading backside fan !&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
multiline_comment|/* XXX What do we do now ? */
)brace
r_else
id|state-&gt;pwm
op_assign
id|rc
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;  current pwm: %d&bslash;n&quot;
comma
id|state-&gt;pwm
)paren
suffix:semicolon
multiline_comment|/* Get some sensor readings */
id|temp
op_assign
id|i2c_smbus_read_byte_data
c_func
(paren
id|state-&gt;monitor
comma
id|MAX6690_EXT_TEMP
)paren
op_lshift
l_int|16
suffix:semicolon
id|state-&gt;last_temp
op_assign
id|temp
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;  temp: %d.%03d, target: %d.%03d&bslash;n&quot;
comma
id|FIX32TOPRINT
c_func
(paren
id|temp
)paren
comma
id|FIX32TOPRINT
c_func
(paren
id|BACKSIDE_PID_INPUT_TARGET
)paren
)paren
suffix:semicolon
multiline_comment|/* Store temperature and error in history array */
id|state-&gt;cur_sample
op_assign
(paren
id|state-&gt;cur_sample
op_plus
l_int|1
)paren
op_mod
id|BACKSIDE_PID_HISTORY_SIZE
suffix:semicolon
id|state-&gt;sample_history
(braket
id|state-&gt;cur_sample
)braket
op_assign
id|temp
suffix:semicolon
id|state-&gt;error_history
(braket
id|state-&gt;cur_sample
)braket
op_assign
id|temp
op_minus
id|BACKSIDE_PID_INPUT_TARGET
suffix:semicolon
multiline_comment|/* If first loop, fill the history table */
r_if
c_cond
(paren
id|state-&gt;first
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|BACKSIDE_PID_HISTORY_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|state-&gt;cur_sample
op_assign
(paren
id|state-&gt;cur_sample
op_plus
l_int|1
)paren
op_mod
id|BACKSIDE_PID_HISTORY_SIZE
suffix:semicolon
id|state-&gt;sample_history
(braket
id|state-&gt;cur_sample
)braket
op_assign
id|temp
suffix:semicolon
id|state-&gt;error_history
(braket
id|state-&gt;cur_sample
)braket
op_assign
id|temp
op_minus
id|BACKSIDE_PID_INPUT_TARGET
suffix:semicolon
)brace
id|state-&gt;first
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Calculate the integral term */
id|sum
op_assign
l_int|0
suffix:semicolon
id|integral
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|BACKSIDE_PID_HISTORY_SIZE
suffix:semicolon
id|i
op_increment
)paren
id|integral
op_add_assign
id|state-&gt;error_history
(braket
id|i
)braket
suffix:semicolon
id|integral
op_mul_assign
id|BACKSIDE_PID_INTERVAL
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;  integral: %08x&bslash;n&quot;
comma
id|integral
)paren
suffix:semicolon
id|integ_p
op_assign
(paren
(paren
id|s64
)paren
id|BACKSIDE_PID_G_r
)paren
op_star
(paren
id|s64
)paren
id|integral
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;   integ_p: %d&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|integ_p
op_rshift
l_int|36
)paren
)paren
suffix:semicolon
id|sum
op_add_assign
id|integ_p
suffix:semicolon
multiline_comment|/* Calculate the derivative term */
id|derivative
op_assign
id|state-&gt;error_history
(braket
id|state-&gt;cur_sample
)braket
op_minus
id|state-&gt;error_history
(braket
(paren
id|state-&gt;cur_sample
op_plus
id|BACKSIDE_PID_HISTORY_SIZE
op_minus
l_int|1
)paren
op_mod
id|BACKSIDE_PID_HISTORY_SIZE
)braket
suffix:semicolon
id|derivative
op_div_assign
id|BACKSIDE_PID_INTERVAL
suffix:semicolon
id|deriv_p
op_assign
(paren
(paren
id|s64
)paren
id|BACKSIDE_PID_G_d
)paren
op_star
(paren
id|s64
)paren
id|derivative
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;   deriv_p: %d&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|deriv_p
op_rshift
l_int|36
)paren
)paren
suffix:semicolon
id|sum
op_add_assign
id|deriv_p
suffix:semicolon
multiline_comment|/* Calculate the proportional term */
id|prop_p
op_assign
(paren
(paren
id|s64
)paren
id|BACKSIDE_PID_G_p
)paren
op_star
(paren
id|s64
)paren
(paren
id|state-&gt;error_history
(braket
id|state-&gt;cur_sample
)braket
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;   prop_p: %d&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|prop_p
op_rshift
l_int|36
)paren
)paren
suffix:semicolon
id|sum
op_add_assign
id|prop_p
suffix:semicolon
multiline_comment|/* Scale sum */
id|sum
op_rshift_assign
l_int|36
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;   sum: %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|sum
)paren
suffix:semicolon
id|state-&gt;pwm
op_add_assign
(paren
id|s32
)paren
id|sum
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;pwm
OL
id|BACKSIDE_PID_OUTPUT_MIN
)paren
id|state-&gt;pwm
op_assign
id|BACKSIDE_PID_OUTPUT_MIN
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;pwm
OG
id|BACKSIDE_PID_OUTPUT_MAX
)paren
id|state-&gt;pwm
op_assign
id|BACKSIDE_PID_OUTPUT_MAX
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;** BACKSIDE PWM: %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|state-&gt;pwm
)paren
suffix:semicolon
id|set_pwm_fan
c_func
(paren
id|BACKSIDE_FAN_PWM_ID
comma
id|state-&gt;pwm
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize the state structure for the backside fan control loop&n; */
DECL|function|init_backside_state
r_static
r_int
id|init_backside_state
c_func
(paren
r_struct
id|backside_pid_state
op_star
id|state
)paren
(brace
id|state-&gt;ticks
op_assign
l_int|1
suffix:semicolon
id|state-&gt;first
op_assign
l_int|1
suffix:semicolon
id|state-&gt;pwm
op_assign
l_int|50
suffix:semicolon
id|state-&gt;monitor
op_assign
id|attach_i2c_chip
c_func
(paren
id|BACKSIDE_MAX_ID
comma
l_string|&quot;backside_temp&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;monitor
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|device_create_file
c_func
(paren
op_amp
id|of_dev-&gt;dev
comma
op_amp
id|dev_attr_backside_temperature
)paren
suffix:semicolon
id|device_create_file
c_func
(paren
op_amp
id|of_dev-&gt;dev
comma
op_amp
id|dev_attr_backside_fan_pwm
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Dispose of the state data for the backside control loop&n; */
DECL|function|dispose_backside_state
r_static
r_void
id|dispose_backside_state
c_func
(paren
r_struct
id|backside_pid_state
op_star
id|state
)paren
(brace
r_if
c_cond
(paren
id|state-&gt;monitor
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|device_remove_file
c_func
(paren
op_amp
id|of_dev-&gt;dev
comma
op_amp
id|dev_attr_backside_temperature
)paren
suffix:semicolon
id|device_remove_file
c_func
(paren
op_amp
id|of_dev-&gt;dev
comma
op_amp
id|dev_attr_backside_fan_pwm
)paren
suffix:semicolon
id|detach_i2c_chip
c_func
(paren
id|state-&gt;monitor
)paren
suffix:semicolon
id|state-&gt;monitor
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Drives bay fan control loop&n; */
DECL|function|do_monitor_drives
r_static
r_void
id|do_monitor_drives
c_func
(paren
r_struct
id|drives_pid_state
op_star
id|state
)paren
(brace
id|s32
id|temp
comma
id|integral
comma
id|derivative
suffix:semicolon
id|s64
id|integ_p
comma
id|deriv_p
comma
id|prop_p
comma
id|sum
suffix:semicolon
r_int
id|i
comma
id|rc
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|state-&gt;ticks
op_ne
l_int|0
)paren
r_return
suffix:semicolon
id|state-&gt;ticks
op_assign
id|DRIVES_PID_INTERVAL
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;drives:&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Check fan status */
id|rc
op_assign
id|get_rpm_fan
c_func
(paren
id|DRIVES_FAN_RPM_ID
comma
op_logical_neg
id|RPM_PID_USE_ACTUAL_SPEED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Error %d reading drives fan !&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
multiline_comment|/* XXX What do we do now ? */
)brace
r_else
id|state-&gt;rpm
op_assign
id|rc
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;  current rpm: %d&bslash;n&quot;
comma
id|state-&gt;rpm
)paren
suffix:semicolon
multiline_comment|/* Get some sensor readings */
id|temp
op_assign
id|le16_to_cpu
c_func
(paren
id|i2c_smbus_read_word_data
c_func
(paren
id|state-&gt;monitor
comma
id|DS1775_TEMP
)paren
)paren
op_lshift
l_int|8
suffix:semicolon
id|state-&gt;last_temp
op_assign
id|temp
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;  temp: %d.%03d, target: %d.%03d&bslash;n&quot;
comma
id|FIX32TOPRINT
c_func
(paren
id|temp
)paren
comma
id|FIX32TOPRINT
c_func
(paren
id|DRIVES_PID_INPUT_TARGET
)paren
)paren
suffix:semicolon
multiline_comment|/* Store temperature and error in history array */
id|state-&gt;cur_sample
op_assign
(paren
id|state-&gt;cur_sample
op_plus
l_int|1
)paren
op_mod
id|DRIVES_PID_HISTORY_SIZE
suffix:semicolon
id|state-&gt;sample_history
(braket
id|state-&gt;cur_sample
)braket
op_assign
id|temp
suffix:semicolon
id|state-&gt;error_history
(braket
id|state-&gt;cur_sample
)braket
op_assign
id|temp
op_minus
id|DRIVES_PID_INPUT_TARGET
suffix:semicolon
multiline_comment|/* If first loop, fill the history table */
r_if
c_cond
(paren
id|state-&gt;first
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|DRIVES_PID_HISTORY_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|state-&gt;cur_sample
op_assign
(paren
id|state-&gt;cur_sample
op_plus
l_int|1
)paren
op_mod
id|DRIVES_PID_HISTORY_SIZE
suffix:semicolon
id|state-&gt;sample_history
(braket
id|state-&gt;cur_sample
)braket
op_assign
id|temp
suffix:semicolon
id|state-&gt;error_history
(braket
id|state-&gt;cur_sample
)braket
op_assign
id|temp
op_minus
id|DRIVES_PID_INPUT_TARGET
suffix:semicolon
)brace
id|state-&gt;first
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Calculate the integral term */
id|sum
op_assign
l_int|0
suffix:semicolon
id|integral
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DRIVES_PID_HISTORY_SIZE
suffix:semicolon
id|i
op_increment
)paren
id|integral
op_add_assign
id|state-&gt;error_history
(braket
id|i
)braket
suffix:semicolon
id|integral
op_mul_assign
id|DRIVES_PID_INTERVAL
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;  integral: %08x&bslash;n&quot;
comma
id|integral
)paren
suffix:semicolon
id|integ_p
op_assign
(paren
(paren
id|s64
)paren
id|DRIVES_PID_G_r
)paren
op_star
(paren
id|s64
)paren
id|integral
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;   integ_p: %d&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|integ_p
op_rshift
l_int|36
)paren
)paren
suffix:semicolon
id|sum
op_add_assign
id|integ_p
suffix:semicolon
multiline_comment|/* Calculate the derivative term */
id|derivative
op_assign
id|state-&gt;error_history
(braket
id|state-&gt;cur_sample
)braket
op_minus
id|state-&gt;error_history
(braket
(paren
id|state-&gt;cur_sample
op_plus
id|DRIVES_PID_HISTORY_SIZE
op_minus
l_int|1
)paren
op_mod
id|DRIVES_PID_HISTORY_SIZE
)braket
suffix:semicolon
id|derivative
op_div_assign
id|DRIVES_PID_INTERVAL
suffix:semicolon
id|deriv_p
op_assign
(paren
(paren
id|s64
)paren
id|DRIVES_PID_G_d
)paren
op_star
(paren
id|s64
)paren
id|derivative
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;   deriv_p: %d&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|deriv_p
op_rshift
l_int|36
)paren
)paren
suffix:semicolon
id|sum
op_add_assign
id|deriv_p
suffix:semicolon
multiline_comment|/* Calculate the proportional term */
id|prop_p
op_assign
(paren
(paren
id|s64
)paren
id|DRIVES_PID_G_p
)paren
op_star
(paren
id|s64
)paren
(paren
id|state-&gt;error_history
(braket
id|state-&gt;cur_sample
)braket
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;   prop_p: %d&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|prop_p
op_rshift
l_int|36
)paren
)paren
suffix:semicolon
id|sum
op_add_assign
id|prop_p
suffix:semicolon
multiline_comment|/* Scale sum */
id|sum
op_rshift_assign
l_int|36
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;   sum: %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|sum
)paren
suffix:semicolon
id|state-&gt;rpm
op_add_assign
(paren
id|s32
)paren
id|sum
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;rpm
OL
id|DRIVES_PID_OUTPUT_MIN
)paren
id|state-&gt;rpm
op_assign
id|DRIVES_PID_OUTPUT_MIN
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;rpm
OG
id|DRIVES_PID_OUTPUT_MAX
)paren
id|state-&gt;rpm
op_assign
id|DRIVES_PID_OUTPUT_MAX
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;** DRIVES RPM: %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|state-&gt;rpm
)paren
suffix:semicolon
id|set_rpm_fan
c_func
(paren
id|DRIVES_FAN_RPM_ID
comma
id|state-&gt;rpm
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize the state structure for the drives bay fan control loop&n; */
DECL|function|init_drives_state
r_static
r_int
id|init_drives_state
c_func
(paren
r_struct
id|drives_pid_state
op_star
id|state
)paren
(brace
id|state-&gt;ticks
op_assign
l_int|1
suffix:semicolon
id|state-&gt;first
op_assign
l_int|1
suffix:semicolon
id|state-&gt;rpm
op_assign
l_int|1000
suffix:semicolon
id|state-&gt;monitor
op_assign
id|attach_i2c_chip
c_func
(paren
id|DRIVES_DALLAS_ID
comma
l_string|&quot;drives_temp&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;monitor
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|device_create_file
c_func
(paren
op_amp
id|of_dev-&gt;dev
comma
op_amp
id|dev_attr_drives_temperature
)paren
suffix:semicolon
id|device_create_file
c_func
(paren
op_amp
id|of_dev-&gt;dev
comma
op_amp
id|dev_attr_drives_fan_rpm
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Dispose of the state data for the drives control loop&n; */
DECL|function|dispose_drives_state
r_static
r_void
id|dispose_drives_state
c_func
(paren
r_struct
id|drives_pid_state
op_star
id|state
)paren
(brace
r_if
c_cond
(paren
id|state-&gt;monitor
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|device_remove_file
c_func
(paren
op_amp
id|of_dev-&gt;dev
comma
op_amp
id|dev_attr_drives_temperature
)paren
suffix:semicolon
id|device_remove_file
c_func
(paren
op_amp
id|of_dev-&gt;dev
comma
op_amp
id|dev_attr_drives_fan_rpm
)paren
suffix:semicolon
id|detach_i2c_chip
c_func
(paren
id|state-&gt;monitor
)paren
suffix:semicolon
id|state-&gt;monitor
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|call_critical_overtemp
r_static
r_int
id|call_critical_overtemp
c_func
(paren
r_void
)paren
(brace
r_char
op_star
id|argv
(braket
)braket
op_assign
(brace
id|critical_overtemp_path
comma
l_int|NULL
)brace
suffix:semicolon
r_static
r_char
op_star
id|envp
(braket
)braket
op_assign
(brace
l_string|&quot;HOME=/&quot;
comma
l_string|&quot;TERM=linux&quot;
comma
l_string|&quot;PATH=/sbin:/usr/sbin:/bin:/usr/bin&quot;
comma
l_int|NULL
)brace
suffix:semicolon
r_return
id|call_usermodehelper
c_func
(paren
id|critical_overtemp_path
comma
id|argv
comma
id|envp
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Here&squot;s the kernel thread that calls the various control loops&n; */
DECL|function|main_control_loop
r_static
r_int
id|main_control_loop
c_func
(paren
r_void
op_star
id|x
)paren
(brace
id|daemonize
c_func
(paren
l_string|&quot;kfand&quot;
)paren
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;main_control_loop started&bslash;n&quot;
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|driver_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start_fcu
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kfand: failed to start FCU&bslash;n&quot;
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|driver_lock
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Set the PCI fan once for now */
id|set_pwm_fan
c_func
(paren
id|SLOTS_FAN_PWM_ID
comma
id|SLOTS_FAN_DEFAULT_PWM
)paren
suffix:semicolon
multiline_comment|/* Initialize ADCs */
id|initialize_adc
c_func
(paren
op_amp
id|cpu_state
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu_state
(braket
l_int|1
)braket
dot
id|monitor
op_ne
l_int|NULL
)paren
id|initialize_adc
c_func
(paren
op_amp
id|cpu_state
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|driver_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|state
op_eq
id|state_attached
)paren
(brace
r_int
r_int
id|elapsed
comma
id|start
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;flags
op_amp
id|PF_FREEZE
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;therm_pm72: freezing thermostat&bslash;n&quot;
)paren
suffix:semicolon
id|refrigerator
c_func
(paren
id|PF_FREEZE
)paren
suffix:semicolon
)brace
id|start
op_assign
id|jiffies
suffix:semicolon
id|down
c_func
(paren
op_amp
id|driver_lock
)paren
suffix:semicolon
id|do_monitor_cpu
c_func
(paren
op_amp
id|cpu_state
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu_state
(braket
l_int|1
)braket
dot
id|monitor
op_ne
l_int|NULL
)paren
id|do_monitor_cpu
c_func
(paren
op_amp
id|cpu_state
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|do_monitor_backside
c_func
(paren
op_amp
id|backside_state
)paren
suffix:semicolon
id|do_monitor_drives
c_func
(paren
op_amp
id|drives_state
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|driver_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|critical_state
op_eq
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Temperature control detected a critical condition&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Attempting to shut down...&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|call_critical_overtemp
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Can&squot;t call %s, power off now!&bslash;n&quot;
comma
id|critical_overtemp_path
)paren
suffix:semicolon
id|machine_power_off
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|critical_state
OG
l_int|0
)paren
id|critical_state
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|critical_state
OG
id|MAX_CRITICAL_STATE
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Shutdown timed out, power off now !&bslash;n&quot;
)paren
suffix:semicolon
id|machine_power_off
c_func
(paren
)paren
suffix:semicolon
)brace
singleline_comment|// FIXME: Deal with signals
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|elapsed
op_assign
id|jiffies
op_minus
id|start
suffix:semicolon
r_if
c_cond
(paren
id|elapsed
OL
id|HZ
)paren
id|schedule_timeout
c_func
(paren
id|HZ
op_minus
id|elapsed
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|DBG
c_func
(paren
l_string|&quot;main_control_loop ended&bslash;n&quot;
)paren
suffix:semicolon
id|ctrl_task
op_assign
l_int|0
suffix:semicolon
id|complete_and_exit
c_func
(paren
op_amp
id|ctrl_complete
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Dispose the control loops when tearing down&n; */
DECL|function|dispose_control_loops
r_static
r_void
id|dispose_control_loops
c_func
(paren
r_void
)paren
(brace
id|dispose_cpu_state
c_func
(paren
op_amp
id|cpu_state
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|dispose_cpu_state
c_func
(paren
op_amp
id|cpu_state
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|dispose_backside_state
c_func
(paren
op_amp
id|backside_state
)paren
suffix:semicolon
id|dispose_drives_state
c_func
(paren
op_amp
id|drives_state
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Create the control loops. U3-0 i2c bus is up, so we can now&n; * get to the various sensors&n; */
DECL|function|create_control_loops
r_static
r_int
id|create_control_loops
c_func
(paren
r_void
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
multiline_comment|/* Count CPUs from the device-tree, we don&squot;t care how many are&n;&t; * actually used by Linux&n;&t; */
id|cpu_count
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|np
op_assign
l_int|NULL
suffix:semicolon
l_int|NULL
op_ne
(paren
id|np
op_assign
id|of_find_node_by_type
c_func
(paren
id|np
comma
l_string|&quot;cpu&quot;
)paren
)paren
suffix:semicolon
)paren
id|cpu_count
op_increment
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;counted %d CPUs in the device-tree&bslash;n&quot;
comma
id|cpu_count
)paren
suffix:semicolon
multiline_comment|/* Create control loops for everything. If any fail, everything&n;&t; * fails&n;&t; */
r_if
c_cond
(paren
id|init_cpu_state
c_func
(paren
op_amp
id|cpu_state
(braket
l_int|0
)braket
comma
l_int|0
)paren
)paren
r_goto
id|fail
suffix:semicolon
r_if
c_cond
(paren
id|cpu_count
OG
l_int|1
op_logical_and
id|init_cpu_state
c_func
(paren
op_amp
id|cpu_state
(braket
l_int|1
)braket
comma
l_int|1
)paren
)paren
r_goto
id|fail
suffix:semicolon
r_if
c_cond
(paren
id|init_backside_state
c_func
(paren
op_amp
id|backside_state
)paren
)paren
r_goto
id|fail
suffix:semicolon
r_if
c_cond
(paren
id|init_drives_state
c_func
(paren
op_amp
id|drives_state
)paren
)paren
r_goto
id|fail
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;all control loops up !&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|fail
suffix:colon
id|DBG
c_func
(paren
l_string|&quot;failure creating control loops, disposing&bslash;n&quot;
)paren
suffix:semicolon
id|dispose_control_loops
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n; * Start the control loops after everything is up, that is create&n; * the thread that will make them run&n; */
DECL|function|start_control_loops
r_static
r_void
id|start_control_loops
c_func
(paren
r_void
)paren
(brace
id|init_completion
c_func
(paren
op_amp
id|ctrl_complete
)paren
suffix:semicolon
id|ctrl_task
op_assign
id|kernel_thread
c_func
(paren
id|main_control_loop
comma
l_int|NULL
comma
id|SIGCHLD
op_or
id|CLONE_KERNEL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Stop the control loops when tearing down&n; */
DECL|function|stop_control_loops
r_static
r_void
id|stop_control_loops
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|ctrl_task
op_ne
l_int|0
)paren
id|wait_for_completion
c_func
(paren
op_amp
id|ctrl_complete
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Attach to the i2c FCU after detecting U3-1 bus&n; */
DECL|function|attach_fcu
r_static
r_int
id|attach_fcu
c_func
(paren
r_void
)paren
(brace
id|fcu
op_assign
id|attach_i2c_chip
c_func
(paren
id|FAN_CTRLER_ID
comma
l_string|&quot;fcu&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fcu
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;FCU attached&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Detach from the i2c FCU when tearing down&n; */
DECL|function|detach_fcu
r_static
r_void
id|detach_fcu
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|fcu
)paren
id|detach_i2c_chip
c_func
(paren
id|fcu
)paren
suffix:semicolon
id|fcu
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Attach to the i2c controller. We probe the various chips based&n; * on the device-tree nodes and build everything for the driver to&n; * run, we then kick the driver monitoring thread&n; */
DECL|function|therm_pm72_attach
r_static
r_int
id|therm_pm72_attach
c_func
(paren
r_struct
id|i2c_adapter
op_star
id|adapter
)paren
(brace
id|down
c_func
(paren
op_amp
id|driver_lock
)paren
suffix:semicolon
multiline_comment|/* Check state */
r_if
c_cond
(paren
id|state
op_eq
id|state_detached
)paren
id|state
op_assign
id|state_attaching
suffix:semicolon
r_if
c_cond
(paren
id|state
op_ne
id|state_attaching
)paren
(brace
id|up
c_func
(paren
op_amp
id|driver_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Check if we are looking for one of these */
r_if
c_cond
(paren
id|u3_0
op_eq
l_int|NULL
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|adapter-&gt;name
comma
l_string|&quot;u3 0&quot;
)paren
)paren
(brace
id|u3_0
op_assign
id|adapter
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;found U3-0, creating control loops&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|create_control_loops
c_func
(paren
)paren
)paren
id|u3_0
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|u3_1
op_eq
l_int|NULL
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|adapter-&gt;name
comma
l_string|&quot;u3 1&quot;
)paren
)paren
(brace
id|u3_1
op_assign
id|adapter
suffix:semicolon
id|DBG
c_func
(paren
l_string|&quot;found U3-1, attaching FCU&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|attach_fcu
c_func
(paren
)paren
)paren
id|u3_1
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* We got all we need, start control loops */
r_if
c_cond
(paren
id|u3_0
op_ne
l_int|NULL
op_logical_and
id|u3_1
op_ne
l_int|NULL
)paren
(brace
id|DBG
c_func
(paren
l_string|&quot;everything up, starting control loops&bslash;n&quot;
)paren
suffix:semicolon
id|state
op_assign
id|state_attached
suffix:semicolon
id|start_control_loops
c_func
(paren
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|driver_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Called on every adapter when the driver or the i2c controller&n; * is going away.&n; */
DECL|function|therm_pm72_detach
r_static
r_int
id|therm_pm72_detach
c_func
(paren
r_struct
id|i2c_adapter
op_star
id|adapter
)paren
(brace
id|down
c_func
(paren
op_amp
id|driver_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state
op_ne
id|state_detached
)paren
id|state
op_assign
id|state_detaching
suffix:semicolon
multiline_comment|/* Stop control loops if any */
id|DBG
c_func
(paren
l_string|&quot;stopping control loops&bslash;n&quot;
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|driver_lock
)paren
suffix:semicolon
id|stop_control_loops
c_func
(paren
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|driver_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|u3_0
op_ne
l_int|NULL
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|adapter-&gt;name
comma
l_string|&quot;u3 0&quot;
)paren
)paren
(brace
id|DBG
c_func
(paren
l_string|&quot;lost U3-0, disposing control loops&bslash;n&quot;
)paren
suffix:semicolon
id|dispose_control_loops
c_func
(paren
)paren
suffix:semicolon
id|u3_0
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|u3_1
op_ne
l_int|NULL
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|adapter-&gt;name
comma
l_string|&quot;u3 1&quot;
)paren
)paren
(brace
id|DBG
c_func
(paren
l_string|&quot;lost U3-1, detaching FCU&bslash;n&quot;
)paren
suffix:semicolon
id|detach_fcu
c_func
(paren
)paren
suffix:semicolon
id|u3_1
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|u3_0
op_eq
l_int|NULL
op_logical_and
id|u3_1
op_eq
l_int|NULL
)paren
id|state
op_assign
id|state_detached
suffix:semicolon
id|up
c_func
(paren
op_amp
id|driver_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fcu_of_probe
r_static
r_int
id|fcu_of_probe
c_func
(paren
r_struct
id|of_device
op_star
id|dev
comma
r_const
r_struct
id|of_match
op_star
id|match
)paren
(brace
r_int
id|rc
suffix:semicolon
id|state
op_assign
id|state_detached
suffix:semicolon
id|rc
op_assign
id|i2c_add_driver
c_func
(paren
op_amp
id|therm_pm72_driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
r_return
id|rc
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fcu_of_remove
r_static
r_int
id|fcu_of_remove
c_func
(paren
r_struct
id|of_device
op_star
id|dev
)paren
(brace
id|i2c_del_driver
c_func
(paren
op_amp
id|therm_pm72_driver
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|fcu_of_match
r_static
r_struct
id|of_match
id|fcu_of_match
(braket
)braket
op_assign
(brace
(brace
dot
id|name
op_assign
id|OF_ANY_MATCH
comma
dot
id|type
op_assign
l_string|&quot;fcu&quot;
comma
dot
id|compatible
op_assign
id|OF_ANY_MATCH
)brace
comma
(brace
)brace
comma
)brace
suffix:semicolon
DECL|variable|fcu_of_platform_driver
r_static
r_struct
id|of_platform_driver
id|fcu_of_platform_driver
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;temperature&quot;
comma
dot
id|match_table
op_assign
id|fcu_of_match
comma
dot
id|probe
op_assign
id|fcu_of_probe
comma
dot
id|remove
op_assign
id|fcu_of_remove
)brace
suffix:semicolon
multiline_comment|/*&n; * Check machine type, attach to i2c controller&n; */
DECL|function|therm_pm72_init
r_static
r_int
id|__init
id|therm_pm72_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|machine_is_compatible
c_func
(paren
l_string|&quot;PowerMac7,2&quot;
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;PowerMac G5 Thermal control driver %s&bslash;n&quot;
comma
id|VERSION
)paren
suffix:semicolon
id|np
op_assign
id|of_find_node_by_type
c_func
(paren
l_int|NULL
comma
l_string|&quot;fcu&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Can&squot;t find FCU in device-tree !&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|of_dev
op_assign
id|of_platform_device_create
c_func
(paren
id|np
comma
l_string|&quot;temperature&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|of_dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Can&squot;t register FCU platform device !&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|of_register_driver
c_func
(paren
op_amp
id|fcu_of_platform_driver
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|therm_pm72_exit
r_static
r_void
id|__exit
id|therm_pm72_exit
c_func
(paren
r_void
)paren
(brace
id|of_unregister_driver
c_func
(paren
op_amp
id|fcu_of_platform_driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|of_dev
)paren
id|of_device_unregister
c_func
(paren
id|of_dev
)paren
suffix:semicolon
)brace
DECL|variable|therm_pm72_init
id|module_init
c_func
(paren
id|therm_pm72_init
)paren
suffix:semicolon
DECL|variable|therm_pm72_exit
id|module_exit
c_func
(paren
id|therm_pm72_exit
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Benjamin Herrenschmidt &lt;benh@kernel.crashing.org&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Driver for Apple&squot;s PowerMac7,2 G5 thermal control&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
