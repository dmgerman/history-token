multiline_comment|/*&n; * attribute_container.c - implementation of a simple container for classes&n; *&n; * Copyright (c) 2005 - James Bottomley &lt;James.Bottomley@steeleye.com&gt;&n; *&n; * This file is licensed under GPLv2&n; *&n; * The basic idea here is to enable a device to be attached to an&n; * aritrary numer of classes without having to allocate storage for them.&n; * Instead, the contained classes select the devices they need to attach&n; * to via a matching function.&n; */
macro_line|#include &lt;linux/attribute_container.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/module.h&gt;
multiline_comment|/* This is a private structure used to tie the classdev and the&n; * container .. it should never be visible outside this file */
DECL|struct|internal_container
r_struct
id|internal_container
(brace
DECL|member|node
r_struct
id|list_head
id|node
suffix:semicolon
DECL|member|cont
r_struct
id|attribute_container
op_star
id|cont
suffix:semicolon
DECL|member|classdev
r_struct
id|class_device
id|classdev
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/**&n; * attribute_container_classdev_to_container - given a classdev, return the container&n; *&n; * @classdev: the class device created by attribute_container_add_device.&n; *&n; * Returns the container associated with this classdev.&n; */
r_struct
id|attribute_container
op_star
DECL|function|attribute_container_classdev_to_container
id|attribute_container_classdev_to_container
c_func
(paren
r_struct
id|class_device
op_star
id|classdev
)paren
(brace
r_struct
id|internal_container
op_star
id|ic
op_assign
id|container_of
c_func
(paren
id|classdev
comma
r_struct
id|internal_container
comma
id|classdev
)paren
suffix:semicolon
r_return
id|ic-&gt;cont
suffix:semicolon
)brace
DECL|variable|attribute_container_classdev_to_container
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|attribute_container_classdev_to_container
)paren
suffix:semicolon
DECL|variable|attribute_container_list
r_static
r_struct
id|list_head
id|attribute_container_list
suffix:semicolon
r_static
id|DECLARE_MUTEX
c_func
(paren
id|attribute_container_mutex
)paren
suffix:semicolon
multiline_comment|/**&n; * attribute_container_register - register an attribute container&n; *&n; * @cont: The container to register.  This must be allocated by the&n; *        callee and should also be zeroed by it.&n; */
r_int
DECL|function|attribute_container_register
id|attribute_container_register
c_func
(paren
r_struct
id|attribute_container
op_star
id|cont
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cont-&gt;node
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cont-&gt;containers
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|attribute_container_mutex
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|cont-&gt;node
comma
op_amp
id|attribute_container_list
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|attribute_container_mutex
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|attribute_container_register
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|attribute_container_register
)paren
suffix:semicolon
multiline_comment|/**&n; * attribute_container_unregister - remove a container registration&n; *&n; * @cont: previously registered container to remove&n; */
r_int
DECL|function|attribute_container_unregister
id|attribute_container_unregister
c_func
(paren
r_struct
id|attribute_container
op_star
id|cont
)paren
(brace
r_int
id|retval
op_assign
op_minus
id|EBUSY
suffix:semicolon
id|down
c_func
(paren
op_amp
id|attribute_container_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|cont-&gt;containers
)paren
)paren
r_goto
id|out
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|cont-&gt;node
)paren
suffix:semicolon
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|attribute_container_mutex
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|attribute_container_unregister
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|attribute_container_unregister
)paren
suffix:semicolon
multiline_comment|/* private function used as class release */
DECL|function|attribute_container_release
r_static
r_void
id|attribute_container_release
c_func
(paren
r_struct
id|class_device
op_star
id|classdev
)paren
(brace
r_struct
id|internal_container
op_star
id|ic
op_assign
id|container_of
c_func
(paren
id|classdev
comma
r_struct
id|internal_container
comma
id|classdev
)paren
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
id|classdev-&gt;dev
suffix:semicolon
id|kfree
c_func
(paren
id|ic
)paren
suffix:semicolon
id|put_device
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * attribute_container_add_device - see if any container is interested in dev&n; *&n; * @dev: device to add attributes to&n; * @fn:&t; function to trigger addition of class device.&n; *&n; * This function allocates storage for the class device(s) to be&n; * attached to dev (one for each matching attribute_container).  If no&n; * fn is provided, the code will simply register the class device via&n; * class_device_add.  If a function is provided, it is expected to add&n; * the class device at the appropriate time.  One of the things that&n; * might be necessary is to allocate and initialise the classdev and&n; * then add it a later time.  To do this, call this routine for&n; * allocation and initialisation and then use&n; * attribute_container_device_trigger() to call class_device_add() on&n; * it.  Note: after this, the class device contains a reference to dev&n; * which is not relinquished until the release of the classdev.&n; */
r_void
DECL|function|attribute_container_add_device
id|attribute_container_add_device
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
(paren
op_star
id|fn
)paren
(paren
r_struct
id|attribute_container
op_star
comma
r_struct
id|device
op_star
comma
r_struct
id|class_device
op_star
)paren
)paren
(brace
r_struct
id|attribute_container
op_star
id|cont
suffix:semicolon
id|down
c_func
(paren
op_amp
id|attribute_container_mutex
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|cont
comma
op_amp
id|attribute_container_list
comma
id|node
)paren
(brace
r_struct
id|internal_container
op_star
id|ic
suffix:semicolon
r_if
c_cond
(paren
id|attribute_container_no_classdevs
c_func
(paren
id|cont
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cont
op_member_access_from_pointer
id|match
c_func
(paren
id|cont
comma
id|dev
)paren
)paren
r_continue
suffix:semicolon
id|ic
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|internal_container
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ic
)paren
(brace
id|dev_printk
c_func
(paren
id|KERN_ERR
comma
id|dev
comma
l_string|&quot;failed to allocate class container&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ic
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|internal_container
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ic-&gt;node
)paren
suffix:semicolon
id|ic-&gt;cont
op_assign
id|cont
suffix:semicolon
id|class_device_initialize
c_func
(paren
op_amp
id|ic-&gt;classdev
)paren
suffix:semicolon
id|ic-&gt;classdev.dev
op_assign
id|get_device
c_func
(paren
id|dev
)paren
suffix:semicolon
id|ic-&gt;classdev
dot
r_class
op_assign
id|cont
op_member_access_from_pointer
r_class
suffix:semicolon
id|cont
op_member_access_from_pointer
r_class
op_member_access_from_pointer
id|release
op_assign
id|attribute_container_release
suffix:semicolon
id|strcpy
c_func
(paren
id|ic-&gt;classdev.class_id
comma
id|dev-&gt;bus_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fn
)paren
id|fn
c_func
(paren
id|cont
comma
id|dev
comma
op_amp
id|ic-&gt;classdev
)paren
suffix:semicolon
r_else
id|attribute_container_add_class_device
c_func
(paren
op_amp
id|ic-&gt;classdev
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|ic-&gt;node
comma
op_amp
id|cont-&gt;containers
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|attribute_container_mutex
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * attribute_container_remove_device - make device eligible for removal.&n; *&n; * @dev:  The generic device&n; * @fn:&t;  A function to call to remove the device&n; *&n; * This routine triggers device removal.  If fn is NULL, then it is&n; * simply done via class_device_unregister (note that if something&n; * still has a reference to the classdev, then the memory occupied&n; * will not be freed until the classdev is released).  If you want a&n; * two phase release: remove from visibility and then delete the&n; * device, then you should use this routine with a fn that calls&n; * class_device_del() and then use&n; * attribute_container_device_trigger() to do the final put on the&n; * classdev.&n; */
r_void
DECL|function|attribute_container_remove_device
id|attribute_container_remove_device
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_void
(paren
op_star
id|fn
)paren
(paren
r_struct
id|attribute_container
op_star
comma
r_struct
id|device
op_star
comma
r_struct
id|class_device
op_star
)paren
)paren
(brace
r_struct
id|attribute_container
op_star
id|cont
suffix:semicolon
id|down
c_func
(paren
op_amp
id|attribute_container_mutex
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|cont
comma
op_amp
id|attribute_container_list
comma
id|node
)paren
(brace
r_struct
id|internal_container
op_star
id|ic
comma
op_star
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|attribute_container_no_classdevs
c_func
(paren
id|cont
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cont
op_member_access_from_pointer
id|match
c_func
(paren
id|cont
comma
id|dev
)paren
)paren
r_continue
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|ic
comma
id|tmp
comma
op_amp
id|cont-&gt;containers
comma
id|node
)paren
(brace
r_if
c_cond
(paren
id|dev
op_ne
id|ic-&gt;classdev.dev
)paren
r_continue
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|ic-&gt;node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fn
)paren
id|fn
c_func
(paren
id|cont
comma
id|dev
comma
op_amp
id|ic-&gt;classdev
)paren
suffix:semicolon
r_else
(brace
id|attribute_container_remove_attrs
c_func
(paren
op_amp
id|ic-&gt;classdev
)paren
suffix:semicolon
id|class_device_unregister
c_func
(paren
op_amp
id|ic-&gt;classdev
)paren
suffix:semicolon
)brace
)brace
)brace
id|up
c_func
(paren
op_amp
id|attribute_container_mutex
)paren
suffix:semicolon
)brace
DECL|variable|attribute_container_remove_device
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|attribute_container_remove_device
)paren
suffix:semicolon
multiline_comment|/**&n; * attribute_container_device_trigger - execute a trigger for each matching classdev&n; *&n; * @dev:  The generic device to run the trigger for&n; * @fn&t;  the function to execute for each classdev.&n; *&n; * This funcion is for executing a trigger when you need to know both&n; * the container and the classdev.  If you only care about the&n; * container, then use attribute_container_trigger() instead.&n; */
r_void
DECL|function|attribute_container_device_trigger
id|attribute_container_device_trigger
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
(paren
op_star
id|fn
)paren
(paren
r_struct
id|attribute_container
op_star
comma
r_struct
id|device
op_star
comma
r_struct
id|class_device
op_star
)paren
)paren
(brace
r_struct
id|attribute_container
op_star
id|cont
suffix:semicolon
id|down
c_func
(paren
op_amp
id|attribute_container_mutex
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|cont
comma
op_amp
id|attribute_container_list
comma
id|node
)paren
(brace
r_struct
id|internal_container
op_star
id|ic
comma
op_star
id|tmp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cont
op_member_access_from_pointer
id|match
c_func
(paren
id|cont
comma
id|dev
)paren
)paren
r_continue
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|ic
comma
id|tmp
comma
op_amp
id|cont-&gt;containers
comma
id|node
)paren
(brace
r_if
c_cond
(paren
id|dev
op_eq
id|ic-&gt;classdev.dev
)paren
id|fn
c_func
(paren
id|cont
comma
id|dev
comma
op_amp
id|ic-&gt;classdev
)paren
suffix:semicolon
)brace
)brace
id|up
c_func
(paren
op_amp
id|attribute_container_mutex
)paren
suffix:semicolon
)brace
DECL|variable|attribute_container_device_trigger
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|attribute_container_device_trigger
)paren
suffix:semicolon
multiline_comment|/**&n; * attribute_container_trigger - trigger a function for each matching container&n; *&n; * @dev:  The generic device to activate the trigger for&n; * @fn:&t;  the function to trigger&n; *&n; * This routine triggers a function that only needs to know the&n; * matching containers (not the classdev) associated with a device.&n; * It is more lightweight than attribute_container_device_trigger, so&n; * should be used in preference unless the triggering function&n; * actually needs to know the classdev.&n; */
r_void
DECL|function|attribute_container_trigger
id|attribute_container_trigger
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
(paren
op_star
id|fn
)paren
(paren
r_struct
id|attribute_container
op_star
comma
r_struct
id|device
op_star
)paren
)paren
(brace
r_struct
id|attribute_container
op_star
id|cont
suffix:semicolon
id|down
c_func
(paren
op_amp
id|attribute_container_mutex
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|cont
comma
op_amp
id|attribute_container_list
comma
id|node
)paren
(brace
r_if
c_cond
(paren
id|cont
op_member_access_from_pointer
id|match
c_func
(paren
id|cont
comma
id|dev
)paren
)paren
id|fn
c_func
(paren
id|cont
comma
id|dev
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|attribute_container_mutex
)paren
suffix:semicolon
)brace
DECL|variable|attribute_container_trigger
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|attribute_container_trigger
)paren
suffix:semicolon
multiline_comment|/**&n; * attribute_container_add_attrs - add attributes&n; *&n; * @classdev: The class device&n; *&n; * This simply creates all the class device sysfs files from the&n; * attributes listed in the container&n; */
r_int
DECL|function|attribute_container_add_attrs
id|attribute_container_add_attrs
c_func
(paren
r_struct
id|class_device
op_star
id|classdev
)paren
(brace
r_struct
id|attribute_container
op_star
id|cont
op_assign
id|attribute_container_classdev_to_container
c_func
(paren
id|classdev
)paren
suffix:semicolon
r_struct
id|class_device_attribute
op_star
op_star
id|attrs
op_assign
id|cont-&gt;attrs
suffix:semicolon
r_int
id|i
comma
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|attrs
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|attrs
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
id|error
op_assign
id|class_device_create_file
c_func
(paren
id|classdev
comma
id|attrs
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|attribute_container_add_attrs
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|attribute_container_add_attrs
)paren
suffix:semicolon
multiline_comment|/**&n; * attribute_container_add_class_device - same function as class_device_add&n; *&n; * @classdev:&t;the class device to add&n; *&n; * This performs essentially the same function as class_device_add except for&n; * attribute containers, namely add the classdev to the system and then&n; * create the attribute files&n; */
r_int
DECL|function|attribute_container_add_class_device
id|attribute_container_add_class_device
c_func
(paren
r_struct
id|class_device
op_star
id|classdev
)paren
(brace
r_int
id|error
op_assign
id|class_device_add
c_func
(paren
id|classdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_return
id|attribute_container_add_attrs
c_func
(paren
id|classdev
)paren
suffix:semicolon
)brace
DECL|variable|attribute_container_add_class_device
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|attribute_container_add_class_device
)paren
suffix:semicolon
multiline_comment|/**&n; * attribute_container_add_class_device_adapter - simple adapter for triggers&n; *&n; * This function is identical to attribute_container_add_class_device except&n; * that it is designed to be called from the triggers&n; */
r_int
DECL|function|attribute_container_add_class_device_adapter
id|attribute_container_add_class_device_adapter
c_func
(paren
r_struct
id|attribute_container
op_star
id|cont
comma
r_struct
id|device
op_star
id|dev
comma
r_struct
id|class_device
op_star
id|classdev
)paren
(brace
r_return
id|attribute_container_add_class_device
c_func
(paren
id|classdev
)paren
suffix:semicolon
)brace
DECL|variable|attribute_container_add_class_device_adapter
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|attribute_container_add_class_device_adapter
)paren
suffix:semicolon
multiline_comment|/**&n; * attribute_container_remove_attrs - remove any attribute files&n; *&n; * @classdev: The class device to remove the files from&n; *&n; */
r_void
DECL|function|attribute_container_remove_attrs
id|attribute_container_remove_attrs
c_func
(paren
r_struct
id|class_device
op_star
id|classdev
)paren
(brace
r_struct
id|attribute_container
op_star
id|cont
op_assign
id|attribute_container_classdev_to_container
c_func
(paren
id|classdev
)paren
suffix:semicolon
r_struct
id|class_device_attribute
op_star
op_star
id|attrs
op_assign
id|cont-&gt;attrs
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|attrs
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|attrs
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
id|class_device_remove_file
c_func
(paren
id|classdev
comma
id|attrs
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
DECL|variable|attribute_container_remove_attrs
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|attribute_container_remove_attrs
)paren
suffix:semicolon
multiline_comment|/**&n; * attribute_container_class_device_del - equivalent of class_device_del&n; *&n; * @classdev: the class device&n; *&n; * This function simply removes all the attribute files and then calls&n; * class_device_del.&n; */
r_void
DECL|function|attribute_container_class_device_del
id|attribute_container_class_device_del
c_func
(paren
r_struct
id|class_device
op_star
id|classdev
)paren
(brace
id|attribute_container_remove_attrs
c_func
(paren
id|classdev
)paren
suffix:semicolon
id|class_device_del
c_func
(paren
id|classdev
)paren
suffix:semicolon
)brace
DECL|variable|attribute_container_class_device_del
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|attribute_container_class_device_del
)paren
suffix:semicolon
r_int
id|__init
DECL|function|attribute_container_init
id|attribute_container_init
c_func
(paren
r_void
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|attribute_container_list
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
