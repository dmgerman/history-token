multiline_comment|/*&n; * processor_idle - idle state submodule to the ACPI processor driver&n; *&n; *  Copyright (C) 2001, 2002 Andy Grover &lt;andrew.grover@intel.com&gt;&n; *  Copyright (C) 2001, 2002 Paul Diefenbaugh &lt;paul.s.diefenbaugh@intel.com&gt;&n; *  Copyright (C) 2004       Dominik Brodowski &lt;linux@brodo.de&gt;&n; *  Copyright (C) 2004  Anil S Keshavamurthy &lt;anil.s.keshavamurthy@intel.com&gt;&n; *  &t;&t;&t;- Added processor hotplug support&n; *&n; * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or (at&n; *  your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful, but&n; *  WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; *  General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License along&n; *  with this program; if not, write to the Free Software Foundation, Inc.,&n; *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.&n; *&n; * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/cpufreq.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;linux/acpi.h&gt;
macro_line|#include &lt;linux/dmi.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;acpi/acpi_bus.h&gt;
macro_line|#include &lt;acpi/processor.h&gt;
DECL|macro|ACPI_PROCESSOR_COMPONENT
mdefine_line|#define ACPI_PROCESSOR_COMPONENT        0x01000000
DECL|macro|ACPI_PROCESSOR_CLASS
mdefine_line|#define ACPI_PROCESSOR_CLASS            &quot;processor&quot;
DECL|macro|ACPI_PROCESSOR_DRIVER_NAME
mdefine_line|#define ACPI_PROCESSOR_DRIVER_NAME      &quot;ACPI Processor Driver&quot;
DECL|macro|_COMPONENT
mdefine_line|#define _COMPONENT              ACPI_PROCESSOR_COMPONENT
id|ACPI_MODULE_NAME
(paren
l_string|&quot;acpi_processor&quot;
)paren
DECL|macro|ACPI_PROCESSOR_FILE_POWER
mdefine_line|#define ACPI_PROCESSOR_FILE_POWER&t;&quot;power&quot;
DECL|macro|US_TO_PM_TIMER_TICKS
mdefine_line|#define US_TO_PM_TIMER_TICKS(t)&t;&t;((t * (PM_TIMER_FREQUENCY/1000)) / 1000)
DECL|macro|C2_OVERHEAD
mdefine_line|#define C2_OVERHEAD&t;&t;&t;4&t;/* 1us (3.579 ticks per us) */
DECL|macro|C3_OVERHEAD
mdefine_line|#define C3_OVERHEAD&t;&t;&t;4&t;/* 1us (3.579 ticks per us) */
DECL|variable|pm_idle_save
r_static
r_void
(paren
op_star
id|pm_idle_save
)paren
(paren
r_void
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|max_cstate
comma
id|uint
comma
l_int|0644
)paren
suffix:semicolon
DECL|variable|nocst
r_static
r_int
r_int
id|nocst
op_assign
l_int|0
suffix:semicolon
id|module_param
c_func
(paren
id|nocst
comma
id|uint
comma
l_int|0000
)paren
suffix:semicolon
multiline_comment|/*&n; * bm_history -- bit-mask with a bit per jiffy of bus-master activity&n; * 1000 HZ: 0xFFFFFFFF: 32 jiffies = 32ms&n; * 800 HZ: 0xFFFFFFFF: 32 jiffies = 40ms&n; * 100 HZ: 0x0000000F: 4 jiffies = 40ms&n; * reduce history for more aggressive entry into C3&n; */
DECL|variable|bm_history
r_static
r_int
r_int
id|bm_history
op_assign
(paren
id|HZ
op_ge
l_int|800
ques
c_cond
l_int|0xFFFFFFFF
suffix:colon
(paren
(paren
l_int|1U
op_lshift
(paren
id|HZ
op_div
l_int|25
)paren
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|bm_history
comma
id|uint
comma
l_int|0644
)paren
suffix:semicolon
multiline_comment|/* --------------------------------------------------------------------------&n;                                Power Management&n;   -------------------------------------------------------------------------- */
multiline_comment|/*&n; * IBM ThinkPad R40e crashes mysteriously when going into C2 or C3.&n; * For now disable this. Probably a bug somewhere else.&n; *&n; * To skip this limit, boot/load with a large max_cstate limit.&n; */
DECL|function|no_c2c3
r_static
r_int
id|no_c2c3
c_func
(paren
r_struct
id|dmi_system_id
op_star
id|id
)paren
(brace
r_if
c_cond
(paren
id|max_cstate
OG
id|ACPI_PROCESSOR_MAX_POWER
)paren
r_return
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
id|PREFIX
l_string|&quot;%s detected - C2,C3 disabled.&quot;
l_string|&quot; Override with &bslash;&quot;processor.max_cstate=%d&bslash;&quot;&bslash;n&quot;
comma
id|id-&gt;ident
comma
id|ACPI_PROCESSOR_MAX_POWER
op_plus
l_int|1
)paren
suffix:semicolon
id|max_cstate
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|processor_power_dmi_table
r_static
r_struct
id|dmi_system_id
id|__initdata
id|processor_power_dmi_table
(braket
)braket
op_assign
(brace
(brace
id|no_c2c3
comma
l_string|&quot;IBM ThinkPad R40e&quot;
comma
(brace
id|DMI_MATCH
c_func
(paren
id|DMI_BIOS_VENDOR
comma
l_string|&quot;IBM&quot;
)paren
comma
id|DMI_MATCH
c_func
(paren
id|DMI_BIOS_VERSION
comma
l_string|&quot;1SET60WW&quot;
)paren
)brace
)brace
comma
(brace
id|no_c2c3
comma
l_string|&quot;Medion 41700&quot;
comma
(brace
id|DMI_MATCH
c_func
(paren
id|DMI_BIOS_VENDOR
comma
l_string|&quot;Phoenix Technologies LTD&quot;
)paren
comma
id|DMI_MATCH
c_func
(paren
id|DMI_BIOS_VERSION
comma
l_string|&quot;R01-A1J&quot;
)paren
)brace
)brace
comma
(brace
)brace
comma
)brace
suffix:semicolon
r_static
r_inline
id|u32
DECL|function|ticks_elapsed
id|ticks_elapsed
(paren
id|u32
id|t1
comma
id|u32
id|t2
)paren
(brace
r_if
c_cond
(paren
id|t2
op_ge
id|t1
)paren
r_return
(paren
id|t2
op_minus
id|t1
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|acpi_fadt.tmr_val_ext
)paren
r_return
(paren
(paren
(paren
l_int|0x00FFFFFF
op_minus
id|t1
)paren
op_plus
id|t2
)paren
op_amp
l_int|0x00FFFFFF
)paren
suffix:semicolon
r_else
r_return
(paren
(paren
l_int|0xFFFFFFFF
op_minus
id|t1
)paren
op_plus
id|t2
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|acpi_processor_power_activate
id|acpi_processor_power_activate
(paren
r_struct
id|acpi_processor
op_star
id|pr
comma
r_struct
id|acpi_processor_cx
op_star
r_new
)paren
(brace
r_struct
id|acpi_processor_cx
op_star
id|old
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr
op_logical_or
op_logical_neg
r_new
)paren
r_return
suffix:semicolon
id|old
op_assign
id|pr-&gt;power.state
suffix:semicolon
r_if
c_cond
(paren
id|old
)paren
id|old-&gt;promotion.count
op_assign
l_int|0
suffix:semicolon
r_new
op_member_access_from_pointer
id|demotion.count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Cleanup from old state. */
r_if
c_cond
(paren
id|old
)paren
(brace
r_switch
c_cond
(paren
id|old-&gt;type
)paren
(brace
r_case
id|ACPI_STATE_C3
suffix:colon
multiline_comment|/* Disable bus master reload */
r_if
c_cond
(paren
r_new
op_member_access_from_pointer
id|type
op_ne
id|ACPI_STATE_C3
)paren
id|acpi_set_register
c_func
(paren
id|ACPI_BITREG_BUS_MASTER_RLD
comma
l_int|0
comma
id|ACPI_MTX_DO_NOT_LOCK
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Prepare to use new state. */
r_switch
c_cond
(paren
r_new
op_member_access_from_pointer
id|type
)paren
(brace
r_case
id|ACPI_STATE_C3
suffix:colon
multiline_comment|/* Enable bus master reload */
r_if
c_cond
(paren
id|old-&gt;type
op_ne
id|ACPI_STATE_C3
)paren
id|acpi_set_register
c_func
(paren
id|ACPI_BITREG_BUS_MASTER_RLD
comma
l_int|1
comma
id|ACPI_MTX_DO_NOT_LOCK
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|pr-&gt;power.state
op_assign
r_new
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|acpi_processor_idle
r_static
r_void
id|acpi_processor_idle
(paren
r_void
)paren
(brace
r_struct
id|acpi_processor
op_star
id|pr
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|acpi_processor_cx
op_star
id|cx
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|acpi_processor_cx
op_star
id|next_state
op_assign
l_int|NULL
suffix:semicolon
r_int
id|sleep_ticks
op_assign
l_int|0
suffix:semicolon
id|u32
id|t1
comma
id|t2
op_assign
l_int|0
suffix:semicolon
id|pr
op_assign
id|processors
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Interrupts must be disabled during bus mastering calculations and&n;&t; * for C2/C3 transitions.&n;&t; */
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check whether we truly need to go idle, or should&n;&t; * reschedule:&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|need_resched
c_func
(paren
)paren
)paren
)paren
(brace
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|cx
op_assign
id|pr-&gt;power.state
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cx
)paren
r_goto
id|easy_out
suffix:semicolon
multiline_comment|/*&n;&t; * Check BM Activity&n;&t; * -----------------&n;&t; * Check for bus mastering activity (if required), record, and check&n;&t; * for demotion.&n;&t; */
r_if
c_cond
(paren
id|pr-&gt;flags.bm_check
)paren
(brace
id|u32
id|bm_status
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|diff
op_assign
id|jiffies
op_minus
id|pr-&gt;power.bm_check_timestamp
suffix:semicolon
r_if
c_cond
(paren
id|diff
OG
l_int|32
)paren
id|diff
op_assign
l_int|32
suffix:semicolon
r_while
c_loop
(paren
id|diff
)paren
(brace
multiline_comment|/* if we didn&squot;t get called, assume there was busmaster activity */
id|diff
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|diff
)paren
id|pr-&gt;power.bm_activity
op_or_assign
l_int|0x1
suffix:semicolon
id|pr-&gt;power.bm_activity
op_lshift_assign
l_int|1
suffix:semicolon
)brace
id|acpi_get_register
c_func
(paren
id|ACPI_BITREG_BUS_MASTER_STATUS
comma
op_amp
id|bm_status
comma
id|ACPI_MTX_DO_NOT_LOCK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bm_status
)paren
(brace
id|pr-&gt;power.bm_activity
op_increment
suffix:semicolon
id|acpi_set_register
c_func
(paren
id|ACPI_BITREG_BUS_MASTER_STATUS
comma
l_int|1
comma
id|ACPI_MTX_DO_NOT_LOCK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * PIIX4 Erratum #18: Note that BM_STS doesn&squot;t always reflect&n;&t;&t; * the true state of bus mastering activity; forcing us to&n;&t;&t; * manually check the BMIDEA bit of each IDE channel.&n;&t;&t; */
r_else
r_if
c_cond
(paren
id|errata.piix4.bmisx
)paren
(brace
r_if
c_cond
(paren
(paren
id|inb_p
c_func
(paren
id|errata.piix4.bmisx
op_plus
l_int|0x02
)paren
op_amp
l_int|0x01
)paren
op_logical_or
(paren
id|inb_p
c_func
(paren
id|errata.piix4.bmisx
op_plus
l_int|0x0A
)paren
op_amp
l_int|0x01
)paren
)paren
id|pr-&gt;power.bm_activity
op_increment
suffix:semicolon
)brace
id|pr-&gt;power.bm_check_timestamp
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Apply bus mastering demotion policy.  Automatically demote&n;&t;&t; * to avoid a faulty transition.  Note that the processor&n;&t;&t; * won&squot;t enter a low-power state during this call (to this&n;&t;&t; * funciton) but should upon the next.&n;&t;&t; *&n;&t;&t; * TBD: A better policy might be to fallback to the demotion&n;&t;&t; *      state (use it for this quantum only) istead of&n;&t;&t; *      demoting -- and rely on duration as our sole demotion&n;&t;&t; *      qualification.  This may, however, introduce DMA&n;&t;&t; *      issues (e.g. floppy DMA transfer overrun/underrun).&n;&t;&t; */
r_if
c_cond
(paren
id|pr-&gt;power.bm_activity
op_amp
id|cx-&gt;demotion.threshold.bm
)paren
(brace
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
id|next_state
op_assign
id|cx-&gt;demotion.state
suffix:semicolon
r_goto
id|end
suffix:semicolon
)brace
)brace
id|cx-&gt;usage
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * Sleep:&n;&t; * ------&n;&t; * Invoke the current Cx state to put the processor to sleep.&n;&t; */
r_switch
c_cond
(paren
id|cx-&gt;type
)paren
(brace
r_case
id|ACPI_STATE_C1
suffix:colon
multiline_comment|/*&n;&t;&t; * Invoke C1.&n;&t;&t; * Use the appropriate idle routine, the one that would&n;&t;&t; * be used without acpi C-states.&n;&t;&t; */
r_if
c_cond
(paren
id|pm_idle_save
)paren
id|pm_idle_save
c_func
(paren
)paren
suffix:semicolon
r_else
id|safe_halt
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;                 * TBD: Can&squot;t get time duration while in C1, as resumes&n;&t;&t; *      go to an ISR rather than here.  Need to instrument&n;&t;&t; *      base interrupt handler.&n;&t;&t; */
id|sleep_ticks
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACPI_STATE_C2
suffix:colon
multiline_comment|/* Get start time (ticks) */
id|t1
op_assign
id|inl
c_func
(paren
id|acpi_fadt.xpm_tmr_blk.address
)paren
suffix:semicolon
multiline_comment|/* Invoke C2 */
id|inb
c_func
(paren
id|cx-&gt;address
)paren
suffix:semicolon
multiline_comment|/* Dummy op - must do something useless after P_LVL2 read */
id|t2
op_assign
id|inl
c_func
(paren
id|acpi_fadt.xpm_tmr_blk.address
)paren
suffix:semicolon
multiline_comment|/* Get end time (ticks) */
id|t2
op_assign
id|inl
c_func
(paren
id|acpi_fadt.xpm_tmr_blk.address
)paren
suffix:semicolon
multiline_comment|/* Re-enable interrupts */
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Compute time (ticks) that we were actually asleep */
id|sleep_ticks
op_assign
id|ticks_elapsed
c_func
(paren
id|t1
comma
id|t2
)paren
op_minus
id|cx-&gt;latency_ticks
op_minus
id|C2_OVERHEAD
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACPI_STATE_C3
suffix:colon
multiline_comment|/* Disable bus master arbitration */
id|acpi_set_register
c_func
(paren
id|ACPI_BITREG_ARB_DISABLE
comma
l_int|1
comma
id|ACPI_MTX_DO_NOT_LOCK
)paren
suffix:semicolon
multiline_comment|/* Get start time (ticks) */
id|t1
op_assign
id|inl
c_func
(paren
id|acpi_fadt.xpm_tmr_blk.address
)paren
suffix:semicolon
multiline_comment|/* Invoke C3 */
id|inb
c_func
(paren
id|cx-&gt;address
)paren
suffix:semicolon
multiline_comment|/* Dummy op - must do something useless after P_LVL3 read */
id|t2
op_assign
id|inl
c_func
(paren
id|acpi_fadt.xpm_tmr_blk.address
)paren
suffix:semicolon
multiline_comment|/* Get end time (ticks) */
id|t2
op_assign
id|inl
c_func
(paren
id|acpi_fadt.xpm_tmr_blk.address
)paren
suffix:semicolon
multiline_comment|/* Enable bus master arbitration */
id|acpi_set_register
c_func
(paren
id|ACPI_BITREG_ARB_DISABLE
comma
l_int|0
comma
id|ACPI_MTX_DO_NOT_LOCK
)paren
suffix:semicolon
multiline_comment|/* Re-enable interrupts */
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Compute time (ticks) that we were actually asleep */
id|sleep_ticks
op_assign
id|ticks_elapsed
c_func
(paren
id|t1
comma
id|t2
)paren
op_minus
id|cx-&gt;latency_ticks
op_minus
id|C3_OVERHEAD
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|next_state
op_assign
id|pr-&gt;power.state
suffix:semicolon
multiline_comment|/*&n;&t; * Promotion?&n;&t; * ----------&n;&t; * Track the number of longs (time asleep is greater than threshold)&n;&t; * and promote when the count threshold is reached.  Note that bus&n;&t; * mastering activity may prevent promotions.&n;&t; * Do not promote above max_cstate.&n;&t; */
r_if
c_cond
(paren
id|cx-&gt;promotion.state
op_logical_and
(paren
(paren
id|cx-&gt;promotion.state
op_minus
id|pr-&gt;power.states
)paren
op_le
id|max_cstate
)paren
)paren
(brace
r_if
c_cond
(paren
id|sleep_ticks
OG
id|cx-&gt;promotion.threshold.ticks
)paren
(brace
id|cx-&gt;promotion.count
op_increment
suffix:semicolon
id|cx-&gt;demotion.count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cx-&gt;promotion.count
op_ge
id|cx-&gt;promotion.threshold.count
)paren
(brace
r_if
c_cond
(paren
id|pr-&gt;flags.bm_check
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|pr-&gt;power.bm_activity
op_amp
id|cx-&gt;promotion.threshold.bm
)paren
)paren
(brace
id|next_state
op_assign
id|cx-&gt;promotion.state
suffix:semicolon
r_goto
id|end
suffix:semicolon
)brace
)brace
r_else
(brace
id|next_state
op_assign
id|cx-&gt;promotion.state
suffix:semicolon
r_goto
id|end
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/*&n;&t; * Demotion?&n;&t; * ---------&n;&t; * Track the number of shorts (time asleep is less than time threshold)&n;&t; * and demote when the usage threshold is reached.&n;&t; */
r_if
c_cond
(paren
id|cx-&gt;demotion.state
)paren
(brace
r_if
c_cond
(paren
id|sleep_ticks
OL
id|cx-&gt;demotion.threshold.ticks
)paren
(brace
id|cx-&gt;demotion.count
op_increment
suffix:semicolon
id|cx-&gt;promotion.count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cx-&gt;demotion.count
op_ge
id|cx-&gt;demotion.threshold.count
)paren
(brace
id|next_state
op_assign
id|cx-&gt;demotion.state
suffix:semicolon
r_goto
id|end
suffix:semicolon
)brace
)brace
)brace
id|end
suffix:colon
multiline_comment|/*&n;&t; * Demote if current state exceeds max_cstate&n;&t; */
r_if
c_cond
(paren
(paren
id|pr-&gt;power.state
op_minus
id|pr-&gt;power.states
)paren
OG
id|max_cstate
)paren
(brace
r_if
c_cond
(paren
id|cx-&gt;demotion.state
)paren
id|next_state
op_assign
id|cx-&gt;demotion.state
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * New Cx State?&n;&t; * -------------&n;&t; * If we&squot;re going to start using a new Cx state we must clean up&n;&t; * from the previous and prepare to use the new.&n;&t; */
r_if
c_cond
(paren
id|next_state
op_ne
id|pr-&gt;power.state
)paren
id|acpi_processor_power_activate
c_func
(paren
id|pr
comma
id|next_state
)paren
suffix:semicolon
r_return
suffix:semicolon
id|easy_out
suffix:colon
multiline_comment|/* do C1 instead of busy loop */
r_if
c_cond
(paren
id|pm_idle_save
)paren
id|pm_idle_save
c_func
(paren
)paren
suffix:semicolon
r_else
id|safe_halt
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_int
DECL|function|acpi_processor_set_power_policy
id|acpi_processor_set_power_policy
(paren
r_struct
id|acpi_processor
op_star
id|pr
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|state_is_set
op_assign
l_int|0
suffix:semicolon
r_struct
id|acpi_processor_cx
op_star
id|lower
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|acpi_processor_cx
op_star
id|higher
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|acpi_processor_cx
op_star
id|cx
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_set_power_policy&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr
)paren
id|return_VALUE
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This function sets the default Cx state policy (OS idle handler).&n;&t; * Our scheme is to promote quickly to C2 but more conservatively&n;&t; * to C3.  We&squot;re favoring C2  for its characteristics of low latency&n;&t; * (quick response), good power savings, and ability to allow bus&n;&t; * mastering activity.  Note that the Cx state policy is completely&n;&t; * customizable and can be altered dynamically.&n;&t; */
multiline_comment|/* startup state */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|ACPI_PROCESSOR_MAX_POWER
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cx
op_assign
op_amp
id|pr-&gt;power.states
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cx-&gt;valid
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state_is_set
)paren
id|pr-&gt;power.state
op_assign
id|cx
suffix:semicolon
id|state_is_set
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|state_is_set
)paren
id|return_VALUE
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
multiline_comment|/* demotion */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|ACPI_PROCESSOR_MAX_POWER
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cx
op_assign
op_amp
id|pr-&gt;power.states
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cx-&gt;valid
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|lower
)paren
(brace
id|cx-&gt;demotion.state
op_assign
id|lower
suffix:semicolon
id|cx-&gt;demotion.threshold.ticks
op_assign
id|cx-&gt;latency_ticks
suffix:semicolon
id|cx-&gt;demotion.threshold.count
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cx-&gt;type
op_eq
id|ACPI_STATE_C3
)paren
id|cx-&gt;demotion.threshold.bm
op_assign
id|bm_history
suffix:semicolon
)brace
id|lower
op_assign
id|cx
suffix:semicolon
)brace
multiline_comment|/* promotion */
r_for
c_loop
(paren
id|i
op_assign
(paren
id|ACPI_PROCESSOR_MAX_POWER
op_minus
l_int|1
)paren
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|cx
op_assign
op_amp
id|pr-&gt;power.states
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cx-&gt;valid
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|higher
)paren
(brace
id|cx-&gt;promotion.state
op_assign
id|higher
suffix:semicolon
id|cx-&gt;promotion.threshold.ticks
op_assign
id|cx-&gt;latency_ticks
suffix:semicolon
r_if
c_cond
(paren
id|cx-&gt;type
op_ge
id|ACPI_STATE_C2
)paren
id|cx-&gt;promotion.threshold.count
op_assign
l_int|4
suffix:semicolon
r_else
id|cx-&gt;promotion.threshold.count
op_assign
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|higher-&gt;type
op_eq
id|ACPI_STATE_C3
)paren
id|cx-&gt;promotion.threshold.bm
op_assign
id|bm_history
suffix:semicolon
)brace
id|higher
op_assign
id|cx
suffix:semicolon
)brace
id|return_VALUE
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|acpi_processor_get_power_info_fadt
r_static
r_int
id|acpi_processor_get_power_info_fadt
(paren
r_struct
id|acpi_processor
op_star
id|pr
)paren
(brace
r_int
id|i
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_get_power_info_fadt&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr
)paren
id|return_VALUE
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr-&gt;pblk
)paren
id|return_VALUE
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ACPI_PROCESSOR_MAX_POWER
suffix:semicolon
id|i
op_increment
)paren
id|memset
c_func
(paren
id|pr-&gt;power.states
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|acpi_processor_cx
)paren
)paren
suffix:semicolon
multiline_comment|/* if info is obtained from pblk/fadt, type equals state */
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C1
)braket
dot
id|type
op_assign
id|ACPI_STATE_C1
suffix:semicolon
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C2
)braket
dot
id|type
op_assign
id|ACPI_STATE_C2
suffix:semicolon
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C3
)braket
dot
id|type
op_assign
id|ACPI_STATE_C3
suffix:semicolon
multiline_comment|/* the C0 state only exists as a filler in our array,&n;&t; * and all processors need to support C1 */
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C0
)braket
dot
id|valid
op_assign
l_int|1
suffix:semicolon
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C1
)braket
dot
id|valid
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* determine C2 and C3 address from pblk */
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C2
)braket
dot
id|address
op_assign
id|pr-&gt;pblk
op_plus
l_int|4
suffix:semicolon
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C3
)braket
dot
id|address
op_assign
id|pr-&gt;pblk
op_plus
l_int|5
suffix:semicolon
multiline_comment|/* determine latencies from FADT */
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C2
)braket
dot
id|latency
op_assign
id|acpi_fadt.plvl2_lat
suffix:semicolon
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C3
)braket
dot
id|latency
op_assign
id|acpi_fadt.plvl3_lat
suffix:semicolon
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;lvl2[0x%08x] lvl3[0x%08x]&bslash;n&quot;
comma
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C2
)braket
dot
id|address
comma
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C3
)braket
dot
id|address
)paren
)paren
suffix:semicolon
id|return_VALUE
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|acpi_processor_get_power_info_cst
r_static
r_int
id|acpi_processor_get_power_info_cst
(paren
r_struct
id|acpi_processor
op_star
id|pr
)paren
(brace
id|acpi_status
id|status
op_assign
l_int|0
suffix:semicolon
id|acpi_integer
id|count
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|acpi_buffer
id|buffer
op_assign
(brace
id|ACPI_ALLOCATE_BUFFER
comma
l_int|NULL
)brace
suffix:semicolon
r_union
id|acpi_object
op_star
id|cst
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_get_power_info_cst&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|errata.smp
)paren
id|return_VALUE
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nocst
)paren
id|return_VALUE
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
id|pr-&gt;power.count
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ACPI_PROCESSOR_MAX_POWER
suffix:semicolon
id|i
op_increment
)paren
id|memset
c_func
(paren
id|pr-&gt;power.states
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|acpi_processor_cx
)paren
)paren
suffix:semicolon
id|status
op_assign
id|acpi_evaluate_object
c_func
(paren
id|pr-&gt;handle
comma
l_string|&quot;_CST&quot;
comma
l_int|NULL
comma
op_amp
id|buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
c_func
(paren
id|status
)paren
)paren
(brace
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;No _CST, giving up&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|return_VALUE
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
id|cst
op_assign
(paren
r_union
id|acpi_object
op_star
)paren
id|buffer.pointer
suffix:semicolon
multiline_comment|/* There must be at least 2 elements */
r_if
c_cond
(paren
op_logical_neg
id|cst
op_logical_or
(paren
id|cst-&gt;type
op_ne
id|ACPI_TYPE_PACKAGE
)paren
op_logical_or
id|cst-&gt;package.count
OL
l_int|2
)paren
(brace
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;not enough elements in _CST&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|end
suffix:semicolon
)brace
id|count
op_assign
id|cst-&gt;package.elements
(braket
l_int|0
)braket
dot
id|integer.value
suffix:semicolon
multiline_comment|/* Validate number of power states. */
r_if
c_cond
(paren
id|count
OL
l_int|1
op_logical_or
id|count
op_ne
id|cst-&gt;package.count
op_minus
l_int|1
)paren
(brace
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;count given by _CST is not valid&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|end
suffix:semicolon
)brace
multiline_comment|/* We support up to ACPI_PROCESSOR_MAX_POWER. */
r_if
c_cond
(paren
id|count
OG
id|ACPI_PROCESSOR_MAX_POWER
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Limiting number of power states to max (%d)&bslash;n&quot;
comma
id|ACPI_PROCESSOR_MAX_POWER
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Please increase ACPI_PROCESSOR_MAX_POWER if needed.&bslash;n&quot;
)paren
suffix:semicolon
id|count
op_assign
id|ACPI_PROCESSOR_MAX_POWER
suffix:semicolon
)brace
multiline_comment|/* Tell driver that at least _CST is supported. */
id|pr-&gt;flags.has_cst
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_union
id|acpi_object
op_star
id|element
suffix:semicolon
r_union
id|acpi_object
op_star
id|obj
suffix:semicolon
r_struct
id|acpi_power_register
op_star
id|reg
suffix:semicolon
r_struct
id|acpi_processor_cx
id|cx
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|cx
comma
l_int|0
comma
r_sizeof
(paren
id|cx
)paren
)paren
suffix:semicolon
id|element
op_assign
(paren
r_union
id|acpi_object
op_star
)paren
op_amp
(paren
id|cst-&gt;package.elements
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|element-&gt;type
op_ne
id|ACPI_TYPE_PACKAGE
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|element-&gt;package.count
op_ne
l_int|4
)paren
r_continue
suffix:semicolon
id|obj
op_assign
(paren
r_union
id|acpi_object
op_star
)paren
op_amp
(paren
id|element-&gt;package.elements
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;type
op_ne
id|ACPI_TYPE_BUFFER
)paren
r_continue
suffix:semicolon
id|reg
op_assign
(paren
r_struct
id|acpi_power_register
op_star
)paren
id|obj-&gt;buffer.pointer
suffix:semicolon
r_if
c_cond
(paren
id|reg-&gt;space_id
op_ne
id|ACPI_ADR_SPACE_SYSTEM_IO
op_logical_and
(paren
id|reg-&gt;space_id
op_ne
id|ACPI_ADR_SPACE_FIXED_HARDWARE
)paren
)paren
r_continue
suffix:semicolon
id|cx.address
op_assign
(paren
id|reg-&gt;space_id
op_eq
id|ACPI_ADR_SPACE_FIXED_HARDWARE
)paren
ques
c_cond
l_int|0
suffix:colon
id|reg-&gt;address
suffix:semicolon
multiline_comment|/* There should be an easy way to extract an integer... */
id|obj
op_assign
(paren
r_union
id|acpi_object
op_star
)paren
op_amp
(paren
id|element-&gt;package.elements
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;type
op_ne
id|ACPI_TYPE_INTEGER
)paren
r_continue
suffix:semicolon
id|cx.type
op_assign
id|obj-&gt;integer.value
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cx.type
op_ne
id|ACPI_STATE_C1
)paren
op_logical_and
(paren
id|reg-&gt;space_id
op_ne
id|ACPI_ADR_SPACE_SYSTEM_IO
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cx.type
OL
id|ACPI_STATE_C1
)paren
op_logical_or
(paren
id|cx.type
OG
id|ACPI_STATE_C3
)paren
)paren
r_continue
suffix:semicolon
id|obj
op_assign
(paren
r_union
id|acpi_object
op_star
)paren
op_amp
(paren
id|element-&gt;package.elements
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;type
op_ne
id|ACPI_TYPE_INTEGER
)paren
r_continue
suffix:semicolon
id|cx.latency
op_assign
id|obj-&gt;integer.value
suffix:semicolon
id|obj
op_assign
(paren
r_union
id|acpi_object
op_star
)paren
op_amp
(paren
id|element-&gt;package.elements
(braket
l_int|3
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|obj-&gt;type
op_ne
id|ACPI_TYPE_INTEGER
)paren
r_continue
suffix:semicolon
id|cx.power
op_assign
id|obj-&gt;integer.value
suffix:semicolon
(paren
id|pr-&gt;power.count
)paren
op_increment
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
(paren
id|pr-&gt;power.states
(braket
id|pr-&gt;power.count
)braket
)paren
comma
op_amp
id|cx
comma
r_sizeof
(paren
id|cx
)paren
)paren
suffix:semicolon
)brace
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;Found %d power states&bslash;n&quot;
comma
id|pr-&gt;power.count
)paren
)paren
suffix:semicolon
multiline_comment|/* Validate number of power states discovered */
r_if
c_cond
(paren
id|pr-&gt;power.count
OL
l_int|2
)paren
id|status
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|end
suffix:colon
id|acpi_os_free
c_func
(paren
id|buffer.pointer
)paren
suffix:semicolon
id|return_VALUE
c_func
(paren
id|status
)paren
suffix:semicolon
)brace
DECL|function|acpi_processor_power_verify_c2
r_static
r_void
id|acpi_processor_power_verify_c2
c_func
(paren
r_struct
id|acpi_processor_cx
op_star
id|cx
)paren
(brace
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_get_power_verify_c2&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cx-&gt;address
)paren
id|return_VOID
suffix:semicolon
multiline_comment|/*&n;&t; * C2 latency must be less than or equal to 100&n;&t; * microseconds.&n;&t; */
r_else
r_if
c_cond
(paren
id|cx-&gt;latency
OG
id|ACPI_PROCESSOR_MAX_C2_LATENCY
)paren
(brace
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;latency too large [%d]&bslash;n&quot;
comma
id|cx-&gt;latency
)paren
)paren
suffix:semicolon
id|return_VOID
suffix:semicolon
)brace
multiline_comment|/* We&squot;re (currently) only supporting C2 on UP */
r_else
r_if
c_cond
(paren
id|errata.smp
)paren
(brace
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;C2 not supported in SMP mode&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|return_VOID
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Otherwise we&squot;ve met all of our C2 requirements.&n;&t; * Normalize the C2 latency to expidite policy&n;&t; */
id|cx-&gt;valid
op_assign
l_int|1
suffix:semicolon
id|cx-&gt;latency_ticks
op_assign
id|US_TO_PM_TIMER_TICKS
c_func
(paren
id|cx-&gt;latency
)paren
suffix:semicolon
id|return_VOID
suffix:semicolon
)brace
DECL|function|acpi_processor_power_verify_c3
r_static
r_void
id|acpi_processor_power_verify_c3
c_func
(paren
r_struct
id|acpi_processor
op_star
id|pr
comma
r_struct
id|acpi_processor_cx
op_star
id|cx
)paren
(brace
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_get_power_verify_c3&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cx-&gt;address
)paren
id|return_VOID
suffix:semicolon
multiline_comment|/*&n;&t; * C3 latency must be less than or equal to 1000&n;&t; * microseconds.&n;&t; */
r_else
r_if
c_cond
(paren
id|cx-&gt;latency
OG
id|ACPI_PROCESSOR_MAX_C3_LATENCY
)paren
(brace
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;latency too large [%d]&bslash;n&quot;
comma
id|cx-&gt;latency
)paren
)paren
suffix:semicolon
id|return_VOID
suffix:semicolon
)brace
multiline_comment|/* bus mastering control is necessary */
r_else
r_if
c_cond
(paren
op_logical_neg
id|pr-&gt;flags.bm_control
)paren
(brace
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;C3 support requires bus mastering control&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|return_VOID
suffix:semicolon
)brace
multiline_comment|/* We&squot;re (currently) only supporting C2 on UP */
r_else
r_if
c_cond
(paren
id|errata.smp
)paren
(brace
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;C3 not supported in SMP mode&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|return_VOID
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * PIIX4 Erratum #18: We don&squot;t support C3 when Type-F (fast)&n;&t; * DMA transfers are used by any ISA device to avoid livelock.&n;&t; * Note that we could disable Type-F DMA (as recommended by&n;&t; * the erratum), but this is known to disrupt certain ISA&n;&t; * devices thus we take the conservative approach.&n;&t; */
r_else
r_if
c_cond
(paren
id|errata.piix4.fdma
)paren
(brace
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;C3 not supported on PIIX4 with Type-F DMA&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|return_VOID
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Otherwise we&squot;ve met all of our C3 requirements.&n;&t; * Normalize the C3 latency to expidite policy.  Enable&n;&t; * checking of bus mastering status (bm_check) so we can&n;&t; * use this in our C3 policy&n;&t; */
id|cx-&gt;valid
op_assign
l_int|1
suffix:semicolon
id|cx-&gt;latency_ticks
op_assign
id|US_TO_PM_TIMER_TICKS
c_func
(paren
id|cx-&gt;latency
)paren
suffix:semicolon
id|pr-&gt;flags.bm_check
op_assign
l_int|1
suffix:semicolon
id|return_VOID
suffix:semicolon
)brace
DECL|function|acpi_processor_power_verify
r_static
r_int
id|acpi_processor_power_verify
c_func
(paren
r_struct
id|acpi_processor
op_star
id|pr
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|working
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|ACPI_PROCESSOR_MAX_POWER
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|acpi_processor_cx
op_star
id|cx
op_assign
op_amp
id|pr-&gt;power.states
(braket
id|i
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|cx-&gt;type
)paren
(brace
r_case
id|ACPI_STATE_C1
suffix:colon
id|cx-&gt;valid
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACPI_STATE_C2
suffix:colon
id|acpi_processor_power_verify_c2
c_func
(paren
id|cx
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACPI_STATE_C3
suffix:colon
id|acpi_processor_power_verify_c3
c_func
(paren
id|pr
comma
id|cx
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cx-&gt;valid
)paren
id|working
op_increment
suffix:semicolon
)brace
r_return
(paren
id|working
)paren
suffix:semicolon
)brace
DECL|function|acpi_processor_get_power_info
r_static
r_int
id|acpi_processor_get_power_info
(paren
r_struct
id|acpi_processor
op_star
id|pr
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
id|result
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_get_power_info&quot;
)paren
suffix:semicolon
multiline_comment|/* NOTE: the idle thread may not be running while calling&n;&t; * this function */
id|result
op_assign
id|acpi_processor_get_power_info_cst
c_func
(paren
id|pr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
)paren
op_logical_or
(paren
id|acpi_processor_power_verify
c_func
(paren
id|pr
)paren
OL
l_int|2
)paren
)paren
(brace
id|result
op_assign
id|acpi_processor_get_power_info_fadt
c_func
(paren
id|pr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
id|return_VALUE
c_func
(paren
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acpi_processor_power_verify
c_func
(paren
id|pr
)paren
OL
l_int|2
)paren
id|return_VALUE
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Set Default Policy&n;&t; * ------------------&n;&t; * Now that we know which states are supported, set the default&n;&t; * policy.  Note that this policy can be changed dynamically&n;&t; * (e.g. encourage deeper sleeps to conserve battery life when&n;&t; * not on AC).&n;&t; */
id|result
op_assign
id|acpi_processor_set_power_policy
c_func
(paren
id|pr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
id|return_VALUE
c_func
(paren
id|result
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * if one state of type C2 or C3 is available, mark this&n;&t; * CPU as being &quot;idle manageable&quot;&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|ACPI_PROCESSOR_MAX_POWER
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pr-&gt;power.states
(braket
id|i
)braket
dot
id|valid
)paren
id|pr-&gt;power.count
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pr-&gt;power.states
(braket
id|i
)braket
dot
id|valid
)paren
op_logical_and
(paren
id|pr-&gt;power.states
(braket
id|i
)braket
dot
id|type
op_ge
id|ACPI_STATE_C2
)paren
)paren
id|pr-&gt;flags.power
op_assign
l_int|1
suffix:semicolon
)brace
id|return_VALUE
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|acpi_processor_cst_has_changed
r_int
id|acpi_processor_cst_has_changed
(paren
r_struct
id|acpi_processor
op_star
id|pr
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_cst_has_changed&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr
)paren
id|return_VALUE
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|errata.smp
op_logical_or
id|nocst
)paren
(brace
id|return_VALUE
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pr-&gt;flags.power_setup_done
)paren
id|return_VALUE
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
multiline_comment|/* Fall back to the default idle loop */
id|pm_idle
op_assign
id|pm_idle_save
suffix:semicolon
id|synchronize_kernel
c_func
(paren
)paren
suffix:semicolon
id|pr-&gt;flags.power
op_assign
l_int|0
suffix:semicolon
id|result
op_assign
id|acpi_processor_get_power_info
c_func
(paren
id|pr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pr-&gt;flags.power
op_eq
l_int|1
)paren
op_logical_and
(paren
id|pr-&gt;flags.power_setup_done
)paren
)paren
id|pm_idle
op_assign
id|acpi_processor_idle
suffix:semicolon
id|return_VALUE
c_func
(paren
id|result
)paren
suffix:semicolon
)brace
multiline_comment|/* proc interface */
DECL|function|acpi_processor_power_seq_show
r_static
r_int
id|acpi_processor_power_seq_show
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
r_void
op_star
id|offset
)paren
(brace
r_struct
id|acpi_processor
op_star
id|pr
op_assign
(paren
r_struct
id|acpi_processor
op_star
)paren
id|seq
op_member_access_from_pointer
r_private
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_power_seq_show&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr
)paren
r_goto
id|end
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;active state:            C%d&bslash;n&quot;
l_string|&quot;max_cstate:              C%d&bslash;n&quot;
l_string|&quot;bus master activity:     %08x&bslash;n&quot;
comma
id|pr-&gt;power.state
ques
c_cond
id|pr-&gt;power.state
op_minus
id|pr-&gt;power.states
suffix:colon
l_int|0
comma
id|max_cstate
comma
id|pr-&gt;power.bm_activity
)paren
suffix:semicolon
id|seq_puts
c_func
(paren
id|seq
comma
l_string|&quot;states:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
id|pr-&gt;power.count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;   %cC%d:                  &quot;
comma
(paren
op_amp
id|pr-&gt;power.states
(braket
id|i
)braket
op_eq
id|pr-&gt;power.state
ques
c_cond
l_char|&squot;*&squot;
suffix:colon
l_char|&squot; &squot;
)paren
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr-&gt;power.states
(braket
id|i
)braket
dot
id|valid
)paren
(brace
id|seq_puts
c_func
(paren
id|seq
comma
l_string|&quot;&lt;not supported&gt;&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|pr-&gt;power.states
(braket
id|i
)braket
dot
id|type
)paren
(brace
r_case
id|ACPI_STATE_C1
suffix:colon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;type[C1] &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACPI_STATE_C2
suffix:colon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;type[C2] &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACPI_STATE_C3
suffix:colon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;type[C3] &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;type[--] &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pr-&gt;power.states
(braket
id|i
)braket
dot
id|promotion.state
)paren
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;promotion[C%d] &quot;
comma
(paren
id|pr-&gt;power.states
(braket
id|i
)braket
dot
id|promotion.state
op_minus
id|pr-&gt;power.states
)paren
)paren
suffix:semicolon
r_else
id|seq_puts
c_func
(paren
id|seq
comma
l_string|&quot;promotion[--] &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pr-&gt;power.states
(braket
id|i
)braket
dot
id|demotion.state
)paren
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;demotion[C%d] &quot;
comma
(paren
id|pr-&gt;power.states
(braket
id|i
)braket
dot
id|demotion.state
op_minus
id|pr-&gt;power.states
)paren
)paren
suffix:semicolon
r_else
id|seq_puts
c_func
(paren
id|seq
comma
l_string|&quot;demotion[--] &quot;
)paren
suffix:semicolon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;latency[%03d] usage[%08d]&bslash;n&quot;
comma
id|pr-&gt;power.states
(braket
id|i
)braket
dot
id|latency
comma
id|pr-&gt;power.states
(braket
id|i
)braket
dot
id|usage
)paren
suffix:semicolon
)brace
id|end
suffix:colon
id|return_VALUE
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|acpi_processor_power_open_fs
r_static
r_int
id|acpi_processor_power_open_fs
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_return
id|single_open
c_func
(paren
id|file
comma
id|acpi_processor_power_seq_show
comma
id|PDE
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|data
)paren
suffix:semicolon
)brace
DECL|variable|acpi_processor_power_fops
r_static
r_struct
id|file_operations
id|acpi_processor_power_fops
op_assign
(brace
dot
id|open
op_assign
id|acpi_processor_power_open_fs
comma
dot
id|read
op_assign
id|seq_read
comma
dot
id|llseek
op_assign
id|seq_lseek
comma
dot
id|release
op_assign
id|single_release
comma
)brace
suffix:semicolon
DECL|function|acpi_processor_power_init
r_int
id|acpi_processor_power_init
c_func
(paren
r_struct
id|acpi_processor
op_star
id|pr
comma
r_struct
id|acpi_device
op_star
id|device
)paren
(brace
id|acpi_status
id|status
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|first_run
op_assign
l_int|0
suffix:semicolon
r_struct
id|proc_dir_entry
op_star
id|entry
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_power_init&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|first_run
)paren
(brace
id|dmi_check_system
c_func
(paren
id|processor_power_dmi_table
)paren
suffix:semicolon
r_if
c_cond
(paren
id|max_cstate
OL
id|ACPI_C_STATES_MAX
)paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ACPI: processor limited to max C-state %d&bslash;n&quot;
comma
id|max_cstate
)paren
suffix:semicolon
id|first_run
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|errata.smp
op_logical_and
(paren
id|pr-&gt;id
op_eq
l_int|0
)paren
op_logical_and
id|acpi_fadt.cst_cnt
op_logical_and
op_logical_neg
id|nocst
)paren
(brace
id|status
op_assign
id|acpi_os_write_port
c_func
(paren
id|acpi_fadt.smi_cmd
comma
id|acpi_fadt.cst_cnt
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
c_func
(paren
id|status
)paren
)paren
(brace
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;Notifying BIOS of _CST ability failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
id|acpi_processor_get_power_info
c_func
(paren
id|pr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Install the idle handler if processor power management is supported.&n;&t; * Note that we use previously set idle handler will be used on&n;&t; * platforms that only support C1.&n;&t; */
r_if
c_cond
(paren
(paren
id|pr-&gt;flags.power
)paren
op_logical_and
(paren
op_logical_neg
id|boot_option_idle_override
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|PREFIX
l_string|&quot;CPU%d (power states:&quot;
comma
id|pr-&gt;id
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
id|pr-&gt;power.count
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|pr-&gt;power.states
(braket
id|i
)braket
dot
id|valid
)paren
id|printk
c_func
(paren
l_string|&quot; C%d[C%d]&quot;
comma
id|i
comma
id|pr-&gt;power.states
(braket
id|i
)braket
dot
id|type
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;)&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pr-&gt;id
op_eq
l_int|0
)paren
(brace
id|pm_idle_save
op_assign
id|pm_idle
suffix:semicolon
id|pm_idle
op_assign
id|acpi_processor_idle
suffix:semicolon
)brace
)brace
multiline_comment|/* &squot;power&squot; [R] */
id|entry
op_assign
id|create_proc_entry
c_func
(paren
id|ACPI_PROCESSOR_FILE_POWER
comma
id|S_IRUGO
comma
id|acpi_device_dir
c_func
(paren
id|device
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;Unable to create &squot;%s&squot; fs entry&bslash;n&quot;
comma
id|ACPI_PROCESSOR_FILE_POWER
)paren
)paren
suffix:semicolon
r_else
(brace
id|entry-&gt;proc_fops
op_assign
op_amp
id|acpi_processor_power_fops
suffix:semicolon
id|entry-&gt;data
op_assign
id|acpi_driver_data
c_func
(paren
id|device
)paren
suffix:semicolon
id|entry-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
)brace
id|pr-&gt;flags.power_setup_done
op_assign
l_int|1
suffix:semicolon
id|return_VALUE
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|acpi_processor_power_exit
r_int
id|acpi_processor_power_exit
c_func
(paren
r_struct
id|acpi_processor
op_star
id|pr
comma
r_struct
id|acpi_device
op_star
id|device
)paren
(brace
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_power_exit&quot;
)paren
suffix:semicolon
id|pr-&gt;flags.power_setup_done
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|acpi_device_dir
c_func
(paren
id|device
)paren
)paren
id|remove_proc_entry
c_func
(paren
id|ACPI_PROCESSOR_FILE_POWER
comma
id|acpi_device_dir
c_func
(paren
id|device
)paren
)paren
suffix:semicolon
multiline_comment|/* Unregister the idle handler when processor #0 is removed. */
r_if
c_cond
(paren
id|pr-&gt;id
op_eq
l_int|0
)paren
(brace
id|pm_idle
op_assign
id|pm_idle_save
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We are about to unload the current idle thread pm callback&n;&t;&t; * (pm_idle), Wait for all processors to update cached/local&n;&t;&t; * copies of pm_idle before proceeding.&n;&t;&t; */
id|synchronize_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
id|return_VALUE
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
eof
