multiline_comment|/******************************************************************************&n; *&n; * Module Name: nsutils - Utilities for accessing ACPI namespace, accessing&n; *                        parents and siblings and Scope manipulation&n; *&n; *****************************************************************************/
multiline_comment|/*&n; * Copyright (C) 2000 - 2004, R. Byron Moore&n; * All rights reserved.&n; *&n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions&n; * are met:&n; * 1. Redistributions of source code must retain the above copyright&n; *    notice, this list of conditions, and the following disclaimer,&n; *    without modification.&n; * 2. Redistributions in binary form must reproduce at minimum a disclaimer&n; *    substantially similar to the &quot;NO WARRANTY&quot; disclaimer below&n; *    (&quot;Disclaimer&quot;) and any redistribution must be conditioned upon&n; *    including a substantially similar Disclaimer requirement for further&n; *    binary redistribution.&n; * 3. Neither the names of the above-listed copyright holders nor the names&n; *    of any contributors may be used to endorse or promote products derived&n; *    from this software without specific prior written permission.&n; *&n; * Alternatively, this software may be distributed under the terms of the&n; * GNU General Public License (&quot;GPL&quot;) version 2 as published by the Free&n; * Software Foundation.&n; *&n; * NO WARRANTY&n; * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS&n; * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT&n; * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR&n; * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT&n; * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL&n; * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS&n; * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)&n; * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,&n; * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING&n; * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE&n; * POSSIBILITY OF SUCH DAMAGES.&n; */
macro_line|#include &lt;acpi/acpi.h&gt;
macro_line|#include &lt;acpi/acnamesp.h&gt;
macro_line|#include &lt;acpi/amlcode.h&gt;
macro_line|#include &lt;acpi/actables.h&gt;
DECL|macro|_COMPONENT
mdefine_line|#define _COMPONENT          ACPI_NAMESPACE
id|ACPI_MODULE_NAME
(paren
l_string|&quot;nsutils&quot;
)paren
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ns_report_error&n; *&n; * PARAMETERS:  module_name         - Caller&squot;s module name (for error output)&n; *              line_number         - Caller&squot;s line number (for error output)&n; *              component_id        - Caller&squot;s component ID (for error output)&n; *              Message             - Error message to use on failure&n; *&n; * RETURN:      None&n; *&n; * DESCRIPTION: Print warning message with full pathname&n; *&n; ******************************************************************************/
r_void
DECL|function|acpi_ns_report_error
id|acpi_ns_report_error
(paren
r_char
op_star
id|module_name
comma
id|u32
id|line_number
comma
id|u32
id|component_id
comma
r_char
op_star
id|internal_name
comma
id|acpi_status
id|lookup_status
)paren
(brace
id|acpi_status
id|status
suffix:semicolon
r_char
op_star
id|name
op_assign
l_int|NULL
suffix:semicolon
id|acpi_os_printf
(paren
l_string|&quot;%8s-%04d: *** Error: Looking up &quot;
comma
id|module_name
comma
id|line_number
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lookup_status
op_eq
id|AE_BAD_CHARACTER
)paren
(brace
multiline_comment|/* There is a non-ascii character in the name */
id|acpi_os_printf
(paren
l_string|&quot;[0x%4.4X] (NON-ASCII)&bslash;n&quot;
comma
op_star
(paren
id|ACPI_CAST_PTR
(paren
id|u32
comma
id|internal_name
)paren
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Convert path to external format */
id|status
op_assign
id|acpi_ns_externalize_name
(paren
id|ACPI_UINT32_MAX
comma
id|internal_name
comma
l_int|NULL
comma
op_amp
id|name
)paren
suffix:semicolon
multiline_comment|/* Print target name */
r_if
c_cond
(paren
id|ACPI_SUCCESS
(paren
id|status
)paren
)paren
(brace
id|acpi_os_printf
(paren
l_string|&quot;[%s]&quot;
comma
id|name
)paren
suffix:semicolon
)brace
r_else
(brace
id|acpi_os_printf
(paren
l_string|&quot;[COULD NOT EXTERNALIZE NAME]&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|name
)paren
(brace
id|ACPI_MEM_FREE
(paren
id|name
)paren
suffix:semicolon
)brace
)brace
id|acpi_os_printf
(paren
l_string|&quot; in namespace, %s&bslash;n&quot;
comma
id|acpi_format_exception
(paren
id|lookup_status
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ns_report_method_error&n; *&n; * PARAMETERS:  module_name         - Caller&squot;s module name (for error output)&n; *              line_number         - Caller&squot;s line number (for error output)&n; *              component_id        - Caller&squot;s component ID (for error output)&n; *              Message             - Error message to use on failure&n; *&n; * RETURN:      None&n; *&n; * DESCRIPTION: Print warning message with full pathname&n; *&n; ******************************************************************************/
r_void
DECL|function|acpi_ns_report_method_error
id|acpi_ns_report_method_error
(paren
r_char
op_star
id|module_name
comma
id|u32
id|line_number
comma
id|u32
id|component_id
comma
r_char
op_star
id|message
comma
r_struct
id|acpi_namespace_node
op_star
id|prefix_node
comma
r_char
op_star
id|path
comma
id|acpi_status
id|method_status
)paren
(brace
id|acpi_status
id|status
suffix:semicolon
r_struct
id|acpi_namespace_node
op_star
id|node
op_assign
id|prefix_node
suffix:semicolon
r_if
c_cond
(paren
id|path
)paren
(brace
id|status
op_assign
id|acpi_ns_get_node_by_path
(paren
id|path
comma
id|prefix_node
comma
id|ACPI_NS_NO_UPSEARCH
comma
op_amp
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|acpi_os_printf
(paren
l_string|&quot;report_method_error: Could not get node&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|acpi_os_printf
(paren
l_string|&quot;%8s-%04d: *** Error: &quot;
comma
id|module_name
comma
id|line_number
)paren
suffix:semicolon
id|acpi_ns_print_node_pathname
(paren
id|node
comma
id|message
)paren
suffix:semicolon
id|acpi_os_printf
(paren
l_string|&quot;, %s&bslash;n&quot;
comma
id|acpi_format_exception
(paren
id|method_status
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ns_print_node_pathname&n; *&n; * PARAMETERS:  Node                - Object&n; *              Msg                 - Prefix message&n; *&n; * DESCRIPTION: Print an object&squot;s full namespace pathname&n; *              Manages allocation/freeing of a pathname buffer&n; *&n; ******************************************************************************/
r_void
DECL|function|acpi_ns_print_node_pathname
id|acpi_ns_print_node_pathname
(paren
r_struct
id|acpi_namespace_node
op_star
id|node
comma
r_char
op_star
id|msg
)paren
(brace
r_struct
id|acpi_buffer
id|buffer
suffix:semicolon
id|acpi_status
id|status
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|node
)paren
(brace
id|acpi_os_printf
(paren
l_string|&quot;[NULL NAME]&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Convert handle to full pathname and print it (with supplied message) */
id|buffer.length
op_assign
id|ACPI_ALLOCATE_LOCAL_BUFFER
suffix:semicolon
id|status
op_assign
id|acpi_ns_handle_to_pathname
(paren
id|node
comma
op_amp
id|buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_SUCCESS
(paren
id|status
)paren
)paren
(brace
r_if
c_cond
(paren
id|msg
)paren
(brace
id|acpi_os_printf
(paren
l_string|&quot;%s &quot;
comma
id|msg
)paren
suffix:semicolon
)brace
id|acpi_os_printf
(paren
l_string|&quot;[%s] (Node %p)&quot;
comma
(paren
r_char
op_star
)paren
id|buffer.pointer
comma
id|node
)paren
suffix:semicolon
id|ACPI_MEM_FREE
(paren
id|buffer.pointer
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ns_valid_root_prefix&n; *&n; * PARAMETERS:  Prefix          - Character to be checked&n; *&n; * RETURN:      TRUE if a valid prefix&n; *&n; * DESCRIPTION: Check if a character is a valid ACPI Root prefix&n; *&n; ******************************************************************************/
id|u8
DECL|function|acpi_ns_valid_root_prefix
id|acpi_ns_valid_root_prefix
(paren
r_char
id|prefix
)paren
(brace
r_return
(paren
(paren
id|u8
)paren
(paren
id|prefix
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ns_valid_path_separator&n; *&n; * PARAMETERS:  Sep              - Character to be checked&n; *&n; * RETURN:      TRUE if a valid path separator&n; *&n; * DESCRIPTION: Check if a character is a valid ACPI path separator&n; *&n; ******************************************************************************/
id|u8
DECL|function|acpi_ns_valid_path_separator
id|acpi_ns_valid_path_separator
(paren
r_char
id|sep
)paren
(brace
r_return
(paren
(paren
id|u8
)paren
(paren
id|sep
op_eq
l_char|&squot;.&squot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ns_get_type&n; *&n; * PARAMETERS:  Handle              - Parent Node to be examined&n; *&n; * RETURN:      Type field from Node whose handle is passed&n; *&n; ******************************************************************************/
id|acpi_object_type
DECL|function|acpi_ns_get_type
id|acpi_ns_get_type
(paren
r_struct
id|acpi_namespace_node
op_star
id|node
)paren
(brace
id|ACPI_FUNCTION_TRACE
(paren
l_string|&quot;ns_get_type&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|node
)paren
(brace
id|ACPI_REPORT_WARNING
(paren
(paren
l_string|&quot;ns_get_type: Null Node input pointer&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|return_VALUE
(paren
id|ACPI_TYPE_ANY
)paren
suffix:semicolon
)brace
id|return_VALUE
(paren
(paren
id|acpi_object_type
)paren
id|node-&gt;type
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ns_local&n; *&n; * PARAMETERS:  Type            - A namespace object type&n; *&n; * RETURN:      LOCAL if names must be found locally in objects of the&n; *              passed type, 0 if enclosing scopes should be searched&n; *&n; ******************************************************************************/
id|u32
DECL|function|acpi_ns_local
id|acpi_ns_local
(paren
id|acpi_object_type
id|type
)paren
(brace
id|ACPI_FUNCTION_TRACE
(paren
l_string|&quot;ns_local&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acpi_ut_valid_object_type
(paren
id|type
)paren
)paren
(brace
multiline_comment|/* Type code out of range  */
id|ACPI_REPORT_WARNING
(paren
(paren
l_string|&quot;ns_local: Invalid Object Type&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|return_VALUE
(paren
id|ACPI_NS_NORMAL
)paren
suffix:semicolon
)brace
id|return_VALUE
(paren
(paren
id|u32
)paren
id|acpi_gbl_ns_properties
(braket
id|type
)braket
op_amp
id|ACPI_NS_LOCAL
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ns_get_internal_name_length&n; *&n; * PARAMETERS:  Info            - Info struct initialized with the&n; *                                external name pointer.&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Calculate the length of the internal (AML) namestring&n; *              corresponding to the external (ASL) namestring.&n; *&n; ******************************************************************************/
r_void
DECL|function|acpi_ns_get_internal_name_length
id|acpi_ns_get_internal_name_length
(paren
r_struct
id|acpi_namestring_info
op_star
id|info
)paren
(brace
r_char
op_star
id|next_external_char
suffix:semicolon
id|u32
id|i
suffix:semicolon
id|ACPI_FUNCTION_ENTRY
(paren
)paren
suffix:semicolon
id|next_external_char
op_assign
id|info-&gt;external_name
suffix:semicolon
id|info-&gt;num_carats
op_assign
l_int|0
suffix:semicolon
id|info-&gt;num_segments
op_assign
l_int|0
suffix:semicolon
id|info-&gt;fully_qualified
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/*&n;&t; * For the internal name, the required length is 4 bytes per segment, plus&n;&t; * 1 each for root_prefix, multi_name_prefix_op, segment count, trailing null&n;&t; * (which is not really needed, but no there&squot;s harm in putting it there)&n;&t; *&n;&t; * strlen() + 1 covers the first name_seg, which has no path separator&n;&t; */
r_if
c_cond
(paren
id|acpi_ns_valid_root_prefix
(paren
id|next_external_char
(braket
l_int|0
)braket
)paren
)paren
(brace
id|info-&gt;fully_qualified
op_assign
id|TRUE
suffix:semicolon
id|next_external_char
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Handle Carat prefixes&n;&t;&t; */
r_while
c_loop
(paren
op_star
id|next_external_char
op_eq
l_char|&squot;^&squot;
)paren
(brace
id|info-&gt;num_carats
op_increment
suffix:semicolon
id|next_external_char
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Determine the number of ACPI name &quot;segments&quot; by counting the number of&n;&t; * path separators within the string. Start with one segment since the&n;&t; * segment count is [(# separators) + 1], and zero separators is ok.&n;&t; */
r_if
c_cond
(paren
op_star
id|next_external_char
)paren
(brace
id|info-&gt;num_segments
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|next_external_char
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|acpi_ns_valid_path_separator
(paren
id|next_external_char
(braket
id|i
)braket
)paren
)paren
(brace
id|info-&gt;num_segments
op_increment
suffix:semicolon
)brace
)brace
)brace
id|info-&gt;length
op_assign
(paren
id|ACPI_NAME_SIZE
op_star
id|info-&gt;num_segments
)paren
op_plus
l_int|4
op_plus
id|info-&gt;num_carats
suffix:semicolon
id|info-&gt;next_external_char
op_assign
id|next_external_char
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ns_build_internal_name&n; *&n; * PARAMETERS:  Info            - Info struct fully initialized&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Construct the internal (AML) namestring&n; *              corresponding to the external (ASL) namestring.&n; *&n; ******************************************************************************/
id|acpi_status
DECL|function|acpi_ns_build_internal_name
id|acpi_ns_build_internal_name
(paren
r_struct
id|acpi_namestring_info
op_star
id|info
)paren
(brace
id|u32
id|num_segments
op_assign
id|info-&gt;num_segments
suffix:semicolon
r_char
op_star
id|internal_name
op_assign
id|info-&gt;internal_name
suffix:semicolon
r_char
op_star
id|external_name
op_assign
id|info-&gt;next_external_char
suffix:semicolon
r_char
op_star
id|result
op_assign
l_int|NULL
suffix:semicolon
id|acpi_native_uint
id|i
suffix:semicolon
id|ACPI_FUNCTION_TRACE
(paren
l_string|&quot;ns_build_internal_name&quot;
)paren
suffix:semicolon
multiline_comment|/* Setup the correct prefixes, counts, and pointers */
r_if
c_cond
(paren
id|info-&gt;fully_qualified
)paren
(brace
id|internal_name
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;&bslash;&squot;
suffix:semicolon
r_if
c_cond
(paren
id|num_segments
op_le
l_int|1
)paren
(brace
id|result
op_assign
op_amp
id|internal_name
(braket
l_int|1
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|num_segments
op_eq
l_int|2
)paren
(brace
id|internal_name
(braket
l_int|1
)braket
op_assign
id|AML_DUAL_NAME_PREFIX
suffix:semicolon
id|result
op_assign
op_amp
id|internal_name
(braket
l_int|2
)braket
suffix:semicolon
)brace
r_else
(brace
id|internal_name
(braket
l_int|1
)braket
op_assign
id|AML_MULTI_NAME_PREFIX_OP
suffix:semicolon
id|internal_name
(braket
l_int|2
)braket
op_assign
(paren
r_char
)paren
id|num_segments
suffix:semicolon
id|result
op_assign
op_amp
id|internal_name
(braket
l_int|3
)braket
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Not fully qualified.&n;&t;&t; * Handle Carats first, then append the name segments&n;&t;&t; */
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;num_carats
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|info-&gt;num_carats
suffix:semicolon
id|i
op_increment
)paren
(brace
id|internal_name
(braket
id|i
)braket
op_assign
l_char|&squot;^&squot;
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|num_segments
op_le
l_int|1
)paren
(brace
id|result
op_assign
op_amp
id|internal_name
(braket
id|i
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|num_segments
op_eq
l_int|2
)paren
(brace
id|internal_name
(braket
id|i
)braket
op_assign
id|AML_DUAL_NAME_PREFIX
suffix:semicolon
id|result
op_assign
op_amp
id|internal_name
(braket
(paren
id|acpi_native_uint
)paren
(paren
id|i
op_plus
l_int|1
)paren
)braket
suffix:semicolon
)brace
r_else
(brace
id|internal_name
(braket
id|i
)braket
op_assign
id|AML_MULTI_NAME_PREFIX_OP
suffix:semicolon
id|internal_name
(braket
(paren
id|acpi_native_uint
)paren
(paren
id|i
op_plus
l_int|1
)paren
)braket
op_assign
(paren
r_char
)paren
id|num_segments
suffix:semicolon
id|result
op_assign
op_amp
id|internal_name
(braket
(paren
id|acpi_native_uint
)paren
(paren
id|i
op_plus
l_int|2
)paren
)braket
suffix:semicolon
)brace
)brace
multiline_comment|/* Build the name (minus path separators) */
r_for
c_loop
(paren
suffix:semicolon
id|num_segments
suffix:semicolon
id|num_segments
op_decrement
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ACPI_NAME_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|acpi_ns_valid_path_separator
(paren
op_star
id|external_name
)paren
op_logical_or
(paren
op_star
id|external_name
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* Pad the segment with underscore(s) if segment is short */
id|result
(braket
id|i
)braket
op_assign
l_char|&squot;_&squot;
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Convert the character to uppercase and save it */
id|result
(braket
id|i
)braket
op_assign
(paren
r_char
)paren
id|ACPI_TOUPPER
(paren
(paren
r_int
)paren
op_star
id|external_name
)paren
suffix:semicolon
id|external_name
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* Now we must have a path separator, or the pathname is bad */
r_if
c_cond
(paren
op_logical_neg
id|acpi_ns_valid_path_separator
(paren
op_star
id|external_name
)paren
op_logical_and
(paren
op_star
id|external_name
op_ne
l_int|0
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|AE_BAD_PARAMETER
)paren
suffix:semicolon
)brace
multiline_comment|/* Move on the next segment */
id|external_name
op_increment
suffix:semicolon
id|result
op_add_assign
id|ACPI_NAME_SIZE
suffix:semicolon
)brace
multiline_comment|/* Terminate the string */
op_star
id|result
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;fully_qualified
)paren
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_EXEC
comma
l_string|&quot;Returning [%p] (abs) &bslash;&quot;&bslash;&bslash;%s&bslash;&quot;&bslash;n&quot;
comma
id|internal_name
comma
id|internal_name
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_EXEC
comma
l_string|&quot;Returning [%p] (rel) &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|internal_name
comma
id|internal_name
)paren
)paren
suffix:semicolon
)brace
id|return_ACPI_STATUS
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ns_internalize_name&n; *&n; * PARAMETERS:  *external_name          - External representation of name&n; *              **Converted Name        - Where to return the resulting&n; *                                        internal represention of the name&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Convert an external representation (e.g. &quot;&bslash;_PR_.CPU0&quot;)&n; *              to internal form (e.g. 5c 2f 02 5f 50 52 5f 43 50 55 30)&n; *&n; *******************************************************************************/
id|acpi_status
DECL|function|acpi_ns_internalize_name
id|acpi_ns_internalize_name
(paren
r_char
op_star
id|external_name
comma
r_char
op_star
op_star
id|converted_name
)paren
(brace
r_char
op_star
id|internal_name
suffix:semicolon
r_struct
id|acpi_namestring_info
id|info
suffix:semicolon
id|acpi_status
id|status
suffix:semicolon
id|ACPI_FUNCTION_TRACE
(paren
l_string|&quot;ns_internalize_name&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|external_name
)paren
op_logical_or
(paren
op_star
id|external_name
op_eq
l_int|0
)paren
op_logical_or
(paren
op_logical_neg
id|converted_name
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|AE_BAD_PARAMETER
)paren
suffix:semicolon
)brace
multiline_comment|/* Get the length of the new internal name */
id|info.external_name
op_assign
id|external_name
suffix:semicolon
id|acpi_ns_get_internal_name_length
(paren
op_amp
id|info
)paren
suffix:semicolon
multiline_comment|/* We need a segment to store the internal  name */
id|internal_name
op_assign
id|ACPI_MEM_CALLOCATE
(paren
id|info.length
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|internal_name
)paren
(brace
id|return_ACPI_STATUS
(paren
id|AE_NO_MEMORY
)paren
suffix:semicolon
)brace
multiline_comment|/* Build the name */
id|info.internal_name
op_assign
id|internal_name
suffix:semicolon
id|status
op_assign
id|acpi_ns_build_internal_name
(paren
op_amp
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|ACPI_MEM_FREE
(paren
id|internal_name
)paren
suffix:semicolon
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
op_star
id|converted_name
op_assign
id|internal_name
suffix:semicolon
id|return_ACPI_STATUS
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ns_externalize_name&n; *&n; * PARAMETERS:  *internal_name         - Internal representation of name&n; *              **converted_name       - Where to return the resulting&n; *                                       external representation of name&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Convert internal name (e.g. 5c 2f 02 5f 50 52 5f 43 50 55 30)&n; *              to its external form (e.g. &quot;&bslash;_PR_.CPU0&quot;)&n; *&n; ******************************************************************************/
id|acpi_status
DECL|function|acpi_ns_externalize_name
id|acpi_ns_externalize_name
(paren
id|u32
id|internal_name_length
comma
r_char
op_star
id|internal_name
comma
id|u32
op_star
id|converted_name_length
comma
r_char
op_star
op_star
id|converted_name
)paren
(brace
id|acpi_native_uint
id|names_index
op_assign
l_int|0
suffix:semicolon
id|acpi_native_uint
id|num_segments
op_assign
l_int|0
suffix:semicolon
id|acpi_native_uint
id|required_length
suffix:semicolon
id|acpi_native_uint
id|prefix_length
op_assign
l_int|0
suffix:semicolon
id|acpi_native_uint
id|i
op_assign
l_int|0
suffix:semicolon
id|acpi_native_uint
id|j
op_assign
l_int|0
suffix:semicolon
id|ACPI_FUNCTION_TRACE
(paren
l_string|&quot;ns_externalize_name&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|internal_name_length
op_logical_or
op_logical_neg
id|internal_name
op_logical_or
op_logical_neg
id|converted_name
)paren
(brace
id|return_ACPI_STATUS
(paren
id|AE_BAD_PARAMETER
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check for a prefix (one &squot;&bslash;&squot; | one or more &squot;^&squot;).&n;&t; */
r_switch
c_cond
(paren
id|internal_name
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;&bslash;&bslash;&squot;
suffix:colon
id|prefix_length
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;^&squot;
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|internal_name_length
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|internal_name
(braket
id|i
)braket
op_eq
l_char|&squot;^&squot;
)paren
(brace
id|prefix_length
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i
op_eq
id|internal_name_length
)paren
(brace
id|prefix_length
op_assign
id|i
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check for object names.  Note that there could be 0-255 of these&n;&t; * 4-byte elements.&n;&t; */
r_if
c_cond
(paren
id|prefix_length
OL
id|internal_name_length
)paren
(brace
r_switch
c_cond
(paren
id|internal_name
(braket
id|prefix_length
)braket
)paren
(brace
r_case
id|AML_MULTI_NAME_PREFIX_OP
suffix:colon
multiline_comment|/* &lt;count&gt; 4-byte names */
id|names_index
op_assign
id|prefix_length
op_plus
l_int|2
suffix:semicolon
id|num_segments
op_assign
(paren
id|acpi_native_uint
)paren
(paren
id|u8
)paren
id|internal_name
(braket
(paren
id|acpi_native_uint
)paren
(paren
id|prefix_length
op_plus
l_int|1
)paren
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AML_DUAL_NAME_PREFIX
suffix:colon
multiline_comment|/* Two 4-byte names */
id|names_index
op_assign
id|prefix_length
op_plus
l_int|1
suffix:semicolon
id|num_segments
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
multiline_comment|/* null_name */
id|names_index
op_assign
l_int|0
suffix:semicolon
id|num_segments
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* one 4-byte name */
id|names_index
op_assign
id|prefix_length
suffix:semicolon
id|num_segments
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Calculate the length of converted_name, which equals the length&n;&t; * of the prefix, length of all object names, length of any required&n;&t; * punctuation (&squot;.&squot;) between object names, plus the NULL terminator.&n;&t; */
id|required_length
op_assign
id|prefix_length
op_plus
(paren
l_int|4
op_star
id|num_segments
)paren
op_plus
(paren
(paren
id|num_segments
OG
l_int|0
)paren
ques
c_cond
(paren
id|num_segments
op_minus
l_int|1
)paren
suffix:colon
l_int|0
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Check to see if we&squot;re still in bounds.  If not, there&squot;s a problem&n;&t; * with internal_name (invalid format).&n;&t; */
r_if
c_cond
(paren
id|required_length
OG
id|internal_name_length
)paren
(brace
id|ACPI_REPORT_ERROR
(paren
(paren
l_string|&quot;ns_externalize_name: Invalid internal name&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|return_ACPI_STATUS
(paren
id|AE_BAD_PATHNAME
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Build converted_name&n;&t; */
op_star
id|converted_name
op_assign
id|ACPI_MEM_CALLOCATE
(paren
id|required_length
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|converted_name
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|AE_NO_MEMORY
)paren
suffix:semicolon
)brace
id|j
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|prefix_length
suffix:semicolon
id|i
op_increment
)paren
(brace
(paren
op_star
id|converted_name
)paren
(braket
id|j
op_increment
)braket
op_assign
id|internal_name
(braket
id|i
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|num_segments
OG
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_segments
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
OG
l_int|0
)paren
(brace
(paren
op_star
id|converted_name
)paren
(braket
id|j
op_increment
)braket
op_assign
l_char|&squot;.&squot;
suffix:semicolon
)brace
(paren
op_star
id|converted_name
)paren
(braket
id|j
op_increment
)braket
op_assign
id|internal_name
(braket
id|names_index
op_increment
)braket
suffix:semicolon
(paren
op_star
id|converted_name
)paren
(braket
id|j
op_increment
)braket
op_assign
id|internal_name
(braket
id|names_index
op_increment
)braket
suffix:semicolon
(paren
op_star
id|converted_name
)paren
(braket
id|j
op_increment
)braket
op_assign
id|internal_name
(braket
id|names_index
op_increment
)braket
suffix:semicolon
(paren
op_star
id|converted_name
)paren
(braket
id|j
op_increment
)braket
op_assign
id|internal_name
(braket
id|names_index
op_increment
)braket
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|converted_name_length
)paren
(brace
op_star
id|converted_name_length
op_assign
(paren
id|u32
)paren
id|required_length
suffix:semicolon
)brace
id|return_ACPI_STATUS
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ns_map_handle_to_node&n; *&n; * PARAMETERS:  Handle          - Handle to be converted to an Node&n; *&n; * RETURN:      A Name table entry pointer&n; *&n; * DESCRIPTION: Convert a namespace handle to a real Node&n; *&n; * Note: Real integer handles allow for more verification&n; *       and keep all pointers within this subsystem.&n; *&n; ******************************************************************************/
r_struct
id|acpi_namespace_node
op_star
DECL|function|acpi_ns_map_handle_to_node
id|acpi_ns_map_handle_to_node
(paren
id|acpi_handle
id|handle
)paren
(brace
id|ACPI_FUNCTION_ENTRY
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Simple implementation.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|handle
)paren
(brace
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|handle
op_eq
id|ACPI_ROOT_OBJECT
)paren
(brace
r_return
(paren
id|acpi_gbl_root_node
)paren
suffix:semicolon
)brace
multiline_comment|/* We can at least attempt to verify the handle */
r_if
c_cond
(paren
id|ACPI_GET_DESCRIPTOR_TYPE
(paren
id|handle
)paren
op_ne
id|ACPI_DESC_TYPE_NAMED
)paren
(brace
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
r_return
(paren
(paren
r_struct
id|acpi_namespace_node
op_star
)paren
id|handle
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ns_convert_entry_to_handle&n; *&n; * PARAMETERS:  Node          - Node to be converted to a Handle&n; *&n; * RETURN:      A user handle&n; *&n; * DESCRIPTION: Convert a real Node to a namespace handle&n; *&n; ******************************************************************************/
id|acpi_handle
DECL|function|acpi_ns_convert_entry_to_handle
id|acpi_ns_convert_entry_to_handle
(paren
r_struct
id|acpi_namespace_node
op_star
id|node
)paren
(brace
multiline_comment|/*&n;&t; * Simple implementation for now;&n;&t; */
r_return
(paren
(paren
id|acpi_handle
)paren
id|node
)paren
suffix:semicolon
multiline_comment|/* ---------------------------------------------------&n;&n;&t;if (!Node)&n;&t;{&n;&t;&t;return (NULL);&n;&t;}&n;&n;&t;if (Node == acpi_gbl_root_node)&n;&t;{&n;&t;&t;return (ACPI_ROOT_OBJECT);&n;&t;}&n;&n;&n;&t;return ((acpi_handle) Node);&n;------------------------------------------------------*/
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ns_terminate&n; *&n; * PARAMETERS:  none&n; *&n; * RETURN:      none&n; *&n; * DESCRIPTION: free memory allocated for table storage.&n; *&n; ******************************************************************************/
r_void
DECL|function|acpi_ns_terminate
id|acpi_ns_terminate
(paren
r_void
)paren
(brace
r_union
id|acpi_operand_object
op_star
id|obj_desc
suffix:semicolon
id|ACPI_FUNCTION_TRACE
(paren
l_string|&quot;ns_terminate&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * 1) Free the entire namespace -- all nodes and objects&n;&t; *&n;&t; * Delete all object descriptors attached to namepsace nodes&n;&t; */
id|acpi_ns_delete_namespace_subtree
(paren
id|acpi_gbl_root_node
)paren
suffix:semicolon
multiline_comment|/* Detach any objects attached to the root */
id|obj_desc
op_assign
id|acpi_ns_get_attached_object
(paren
id|acpi_gbl_root_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|obj_desc
)paren
(brace
id|acpi_ns_detach_object
(paren
id|acpi_gbl_root_node
)paren
suffix:semicolon
)brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;Namespace freed&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * 2) Now we can delete the ACPI tables&n;&t; */
id|acpi_tb_delete_all_tables
(paren
)paren
suffix:semicolon
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;ACPI Tables freed&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|return_VOID
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ns_opens_scope&n; *&n; * PARAMETERS:  Type        - A valid namespace type&n; *&n; * RETURN:      NEWSCOPE if the passed type &quot;opens a name scope&quot; according&n; *              to the ACPI specification, else 0&n; *&n; ******************************************************************************/
id|u32
DECL|function|acpi_ns_opens_scope
id|acpi_ns_opens_scope
(paren
id|acpi_object_type
id|type
)paren
(brace
id|ACPI_FUNCTION_TRACE_STR
(paren
l_string|&quot;ns_opens_scope&quot;
comma
id|acpi_ut_get_type_name
(paren
id|type
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acpi_ut_valid_object_type
(paren
id|type
)paren
)paren
(brace
multiline_comment|/* type code out of range  */
id|ACPI_REPORT_WARNING
(paren
(paren
l_string|&quot;ns_opens_scope: Invalid Object Type %X&bslash;n&quot;
comma
id|type
)paren
)paren
suffix:semicolon
id|return_VALUE
(paren
id|ACPI_NS_NORMAL
)paren
suffix:semicolon
)brace
id|return_VALUE
(paren
(paren
(paren
id|u32
)paren
id|acpi_gbl_ns_properties
(braket
id|type
)braket
)paren
op_amp
id|ACPI_NS_NEWSCOPE
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ns_get_node_by_path&n; *&n; * PARAMETERS:  *Pathname   - Name to be found, in external (ASL) format. The&n; *                            &bslash; (backslash) and ^ (carat) prefixes, and the&n; *                            . (period) to separate segments are supported.&n; *              start_node  - Root of subtree to be searched, or NS_ALL for the&n; *                            root of the name space.  If Name is fully&n; *                            qualified (first s8 is &squot;&bslash;&squot;), the passed value&n; *                            of Scope will not be accessed.&n; *              Flags       - Used to indicate whether to perform upsearch or&n; *                            not.&n; *              return_node - Where the Node is returned&n; *&n; * DESCRIPTION: Look up a name relative to a given scope and return the&n; *              corresponding Node.  NOTE: Scope can be null.&n; *&n; * MUTEX:       Locks namespace&n; *&n; ******************************************************************************/
id|acpi_status
DECL|function|acpi_ns_get_node_by_path
id|acpi_ns_get_node_by_path
(paren
r_char
op_star
id|pathname
comma
r_struct
id|acpi_namespace_node
op_star
id|start_node
comma
id|u32
id|flags
comma
r_struct
id|acpi_namespace_node
op_star
op_star
id|return_node
)paren
(brace
r_union
id|acpi_generic_state
id|scope_info
suffix:semicolon
id|acpi_status
id|status
suffix:semicolon
r_char
op_star
id|internal_path
op_assign
l_int|NULL
suffix:semicolon
id|ACPI_FUNCTION_TRACE_PTR
(paren
l_string|&quot;ns_get_node_by_path&quot;
comma
id|pathname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pathname
)paren
(brace
multiline_comment|/* Convert path to internal representation */
id|status
op_assign
id|acpi_ns_internalize_name
(paren
id|pathname
comma
op_amp
id|internal_path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Must lock namespace during lookup */
id|status
op_assign
id|acpi_ut_acquire_mutex
(paren
id|ACPI_MTX_NAMESPACE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_goto
id|cleanup
suffix:semicolon
)brace
multiline_comment|/* Setup lookup scope (search starting point) */
id|scope_info.scope.node
op_assign
id|start_node
suffix:semicolon
multiline_comment|/* Lookup the name in the namespace */
id|status
op_assign
id|acpi_ns_lookup
(paren
op_amp
id|scope_info
comma
id|internal_path
comma
id|ACPI_TYPE_ANY
comma
id|ACPI_IMODE_EXECUTE
comma
(paren
id|flags
op_or
id|ACPI_NS_DONT_OPEN_SCOPE
)paren
comma
l_int|NULL
comma
id|return_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;%s, %s&bslash;n&quot;
comma
id|internal_path
comma
id|acpi_format_exception
(paren
id|status
)paren
)paren
)paren
suffix:semicolon
)brace
(paren
r_void
)paren
id|acpi_ut_release_mutex
(paren
id|ACPI_MTX_NAMESPACE
)paren
suffix:semicolon
id|cleanup
suffix:colon
multiline_comment|/* Cleanup */
r_if
c_cond
(paren
id|internal_path
)paren
(brace
id|ACPI_MEM_FREE
(paren
id|internal_path
)paren
suffix:semicolon
)brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ns_find_parent_name&n; *&n; * PARAMETERS:  *child_node            - Named Obj whose name is to be found&n; *&n; * RETURN:      The ACPI name&n; *&n; * DESCRIPTION: Search for the given obj in its parent scope and return the&n; *              name segment, or &quot;????&quot; if the parent name can&squot;t be found&n; *              (which &quot;should not happen&quot;).&n; *&n; ******************************************************************************/
id|acpi_name
DECL|function|acpi_ns_find_parent_name
id|acpi_ns_find_parent_name
(paren
r_struct
id|acpi_namespace_node
op_star
id|child_node
)paren
(brace
r_struct
id|acpi_namespace_node
op_star
id|parent_node
suffix:semicolon
id|ACPI_FUNCTION_TRACE
(paren
l_string|&quot;ns_find_parent_name&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|child_node
)paren
(brace
multiline_comment|/* Valid entry.  Get the parent Node */
id|parent_node
op_assign
id|acpi_ns_get_parent_node
(paren
id|child_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parent_node
)paren
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_EXEC
comma
l_string|&quot;Parent of %p [%4.4s] is %p [%4.4s]&bslash;n&quot;
comma
id|child_node
comma
id|acpi_ut_get_node_name
(paren
id|child_node
)paren
comma
id|parent_node
comma
id|acpi_ut_get_node_name
(paren
id|parent_node
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parent_node-&gt;name.integer
)paren
(brace
id|return_VALUE
(paren
(paren
id|acpi_name
)paren
id|parent_node-&gt;name.integer
)paren
suffix:semicolon
)brace
)brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_EXEC
comma
l_string|&quot;Unable to find parent of %p (%4.4s)&bslash;n&quot;
comma
id|child_node
comma
id|acpi_ut_get_node_name
(paren
id|child_node
)paren
)paren
)paren
suffix:semicolon
)brace
id|return_VALUE
(paren
id|ACPI_UNKNOWN_NAME
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ns_get_parent_node&n; *&n; * PARAMETERS:  Node       - Current table entry&n; *&n; * RETURN:      Parent entry of the given entry&n; *&n; * DESCRIPTION: Obtain the parent entry for a given entry in the namespace.&n; *&n; ******************************************************************************/
r_struct
id|acpi_namespace_node
op_star
DECL|function|acpi_ns_get_parent_node
id|acpi_ns_get_parent_node
(paren
r_struct
id|acpi_namespace_node
op_star
id|node
)paren
(brace
id|ACPI_FUNCTION_ENTRY
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|node
)paren
(brace
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Walk to the end of this peer list. The last entry is marked with a flag&n;&t; * and the peer pointer is really a pointer back to the parent. This saves&n;&t; * putting a parent back pointer in each and every named object!&n;&t; */
r_while
c_loop
(paren
op_logical_neg
(paren
id|node-&gt;flags
op_amp
id|ANOBJ_END_OF_PEER_LIST
)paren
)paren
(brace
id|node
op_assign
id|node-&gt;peer
suffix:semicolon
)brace
r_return
(paren
id|node-&gt;peer
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ns_get_next_valid_node&n; *&n; * PARAMETERS:  Node       - Current table entry&n; *&n; * RETURN:      Next valid Node in the linked node list. NULL if no more valid&n; *              nodes.&n; *&n; * DESCRIPTION: Find the next valid node within a name table.&n; *              Useful for implementing NULL-end-of-list loops.&n; *&n; ******************************************************************************/
r_struct
id|acpi_namespace_node
op_star
DECL|function|acpi_ns_get_next_valid_node
id|acpi_ns_get_next_valid_node
(paren
r_struct
id|acpi_namespace_node
op_star
id|node
)paren
(brace
multiline_comment|/* If we are at the end of this peer list, return NULL */
r_if
c_cond
(paren
id|node-&gt;flags
op_amp
id|ANOBJ_END_OF_PEER_LIST
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Otherwise just return the next peer */
r_return
(paren
id|node-&gt;peer
)paren
suffix:semicolon
)brace
eof
