multiline_comment|/*******************************************************************************&n; *&n; * Module Name: dbxface - AML Debugger external interfaces&n; *              $Revision: 64 $&n; *&n; ******************************************************************************/
multiline_comment|/*&n; *  Copyright (C) 2000 - 2002, R. Byron Moore&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &quot;acpi.h&quot;
macro_line|#include &quot;amlcode.h&quot;
macro_line|#include &quot;acdebug.h&quot;
macro_line|#include &quot;acdisasm.h&quot;
macro_line|#ifdef ACPI_DEBUGGER
DECL|macro|_COMPONENT
mdefine_line|#define _COMPONENT          ACPI_CA_DEBUGGER
id|ACPI_MODULE_NAME
(paren
l_string|&quot;dbxface&quot;
)paren
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_db_single_step&n; *&n; * PARAMETERS:  Walk_state      - Current walk&n; *              Op              - Current executing op&n; *              Opcode_class    - Class of the current AML Opcode&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Called just before execution of an AML opcode.&n; *&n; ******************************************************************************/
id|acpi_status
DECL|function|acpi_db_single_step
id|acpi_db_single_step
(paren
id|acpi_walk_state
op_star
id|walk_state
comma
id|acpi_parse_object
op_star
id|op
comma
id|u32
id|opcode_class
)paren
(brace
id|acpi_parse_object
op_star
id|next
suffix:semicolon
id|acpi_status
id|status
op_assign
id|AE_OK
suffix:semicolon
id|u32
id|original_debug_level
suffix:semicolon
id|acpi_parse_object
op_star
id|display_op
suffix:semicolon
id|acpi_parse_object
op_star
id|parent_op
suffix:semicolon
id|ACPI_FUNCTION_ENTRY
(paren
)paren
suffix:semicolon
multiline_comment|/* Check for single-step breakpoint */
r_if
c_cond
(paren
id|walk_state-&gt;method_breakpoint
op_logical_and
(paren
id|walk_state-&gt;method_breakpoint
op_le
id|op-&gt;common.aml_offset
)paren
)paren
(brace
multiline_comment|/* Check if the breakpoint has been reached or passed */
multiline_comment|/* Hit the breakpoint, resume single step, reset breakpoint */
id|acpi_os_printf
(paren
l_string|&quot;***Break*** at AML offset %X&bslash;n&quot;
comma
id|op-&gt;common.aml_offset
)paren
suffix:semicolon
id|acpi_gbl_cm_single_step
op_assign
id|TRUE
suffix:semicolon
id|acpi_gbl_step_to_next_call
op_assign
id|FALSE
suffix:semicolon
id|walk_state-&gt;method_breakpoint
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Check for user breakpoint (Must be on exact Aml offset) */
r_else
r_if
c_cond
(paren
id|walk_state-&gt;user_breakpoint
op_logical_and
(paren
id|walk_state-&gt;user_breakpoint
op_eq
id|op-&gt;common.aml_offset
)paren
)paren
(brace
id|acpi_os_printf
(paren
l_string|&quot;***User_breakpoint*** at AML offset %X&bslash;n&quot;
comma
id|op-&gt;common.aml_offset
)paren
suffix:semicolon
id|acpi_gbl_cm_single_step
op_assign
id|TRUE
suffix:semicolon
id|acpi_gbl_step_to_next_call
op_assign
id|FALSE
suffix:semicolon
id|walk_state-&gt;method_breakpoint
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check if this is an opcode that we are interested in --&n;&t; * namely, opcodes that have arguments&n;&t; */
r_if
c_cond
(paren
id|op-&gt;common.aml_opcode
op_eq
id|AML_INT_NAMEDFIELD_OP
)paren
(brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|opcode_class
)paren
(brace
r_case
id|AML_CLASS_UNKNOWN
suffix:colon
r_case
id|AML_CLASS_ARGUMENT
suffix:colon
multiline_comment|/* constants, literals, etc.  do nothing */
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* All other opcodes -- continue */
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Under certain debug conditions, display this opcode and its operands&n;&t; */
r_if
c_cond
(paren
(paren
id|acpi_gbl_db_output_to_file
)paren
op_logical_or
(paren
id|acpi_gbl_cm_single_step
)paren
op_logical_or
(paren
id|acpi_dbg_level
op_amp
id|ACPI_LV_PARSE
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|acpi_gbl_db_output_to_file
)paren
op_logical_or
(paren
id|acpi_dbg_level
op_amp
id|ACPI_LV_PARSE
)paren
)paren
(brace
id|acpi_os_printf
(paren
l_string|&quot;&bslash;n[Aml_debug] Next AML Opcode to execute:&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Display this op (and only this op - zero out the NEXT field temporarily,&n;&t;&t; * and disable parser trace output for the duration of the display because&n;&t;&t; * we don&squot;t want the extraneous debug output)&n;&t;&t; */
id|original_debug_level
op_assign
id|acpi_dbg_level
suffix:semicolon
id|acpi_dbg_level
op_and_assign
op_complement
(paren
id|ACPI_LV_PARSE
op_or
id|ACPI_LV_FUNCTIONS
)paren
suffix:semicolon
id|next
op_assign
id|op-&gt;common.next
suffix:semicolon
id|op-&gt;common.next
op_assign
l_int|NULL
suffix:semicolon
id|display_op
op_assign
id|op
suffix:semicolon
id|parent_op
op_assign
id|op-&gt;common.parent
suffix:semicolon
r_if
c_cond
(paren
id|parent_op
)paren
(brace
r_if
c_cond
(paren
(paren
id|walk_state-&gt;control_state
)paren
op_logical_and
(paren
id|walk_state-&gt;control_state-&gt;common.state
op_eq
id|ACPI_CONTROL_PREDICATE_EXECUTING
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * We are executing the predicate of an IF or WHILE statement&n;&t;&t;&t;&t; * Search upwards for the containing IF or WHILE so that the&n;&t;&t;&t;&t; * entire predicate can be displayed.&n;&t;&t;&t;&t; */
r_while
c_loop
(paren
id|parent_op
)paren
(brace
r_if
c_cond
(paren
(paren
id|parent_op-&gt;common.aml_opcode
op_eq
id|AML_IF_OP
)paren
op_logical_or
(paren
id|parent_op-&gt;common.aml_opcode
op_eq
id|AML_WHILE_OP
)paren
)paren
(brace
id|display_op
op_assign
id|parent_op
suffix:semicolon
r_break
suffix:semicolon
)brace
id|parent_op
op_assign
id|parent_op-&gt;common.parent
suffix:semicolon
)brace
)brace
r_else
(brace
r_while
c_loop
(paren
id|parent_op
)paren
(brace
r_if
c_cond
(paren
(paren
id|parent_op-&gt;common.aml_opcode
op_eq
id|AML_IF_OP
)paren
op_logical_or
(paren
id|parent_op-&gt;common.aml_opcode
op_eq
id|AML_ELSE_OP
)paren
op_logical_or
(paren
id|parent_op-&gt;common.aml_opcode
op_eq
id|AML_SCOPE_OP
)paren
op_logical_or
(paren
id|parent_op-&gt;common.aml_opcode
op_eq
id|AML_METHOD_OP
)paren
op_logical_or
(paren
id|parent_op-&gt;common.aml_opcode
op_eq
id|AML_WHILE_OP
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|display_op
op_assign
id|parent_op
suffix:semicolon
id|parent_op
op_assign
id|parent_op-&gt;common.parent
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Now we can display it */
id|acpi_dm_disassemble
(paren
id|walk_state
comma
id|display_op
comma
id|ACPI_UINT32_MAX
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|op-&gt;common.aml_opcode
op_eq
id|AML_IF_OP
)paren
op_logical_or
(paren
id|op-&gt;common.aml_opcode
op_eq
id|AML_WHILE_OP
)paren
)paren
(brace
r_if
c_cond
(paren
id|walk_state-&gt;control_state-&gt;common.value
)paren
(brace
id|acpi_os_printf
(paren
l_string|&quot;Predicate = [True], IF block was executed&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|acpi_os_printf
(paren
l_string|&quot;Predicate = [False], Skipping IF block&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|op-&gt;common.aml_opcode
op_eq
id|AML_ELSE_OP
)paren
(brace
id|acpi_os_printf
(paren
l_string|&quot;Predicate = [False], ELSE block was executed&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Restore everything */
id|op-&gt;common.next
op_assign
id|next
suffix:semicolon
id|acpi_os_printf
(paren
l_string|&quot;&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
id|acpi_dbg_level
op_assign
id|original_debug_level
suffix:semicolon
)brace
multiline_comment|/* If we are not single stepping, just continue executing the method */
r_if
c_cond
(paren
op_logical_neg
id|acpi_gbl_cm_single_step
)paren
(brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we are executing a step-to-call command,&n;&t; * Check if this is a method call.&n;&t; */
r_if
c_cond
(paren
id|acpi_gbl_step_to_next_call
)paren
(brace
r_if
c_cond
(paren
id|op-&gt;common.aml_opcode
op_ne
id|AML_INT_METHODCALL_OP
)paren
(brace
multiline_comment|/* Not a method call, just keep executing */
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* Found a method call, stop executing */
id|acpi_gbl_step_to_next_call
op_assign
id|FALSE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the next opcode is a method call, we will &quot;step over&quot; it&n;&t; * by default.&n;&t; */
r_if
c_cond
(paren
id|op-&gt;common.aml_opcode
op_eq
id|AML_INT_METHODCALL_OP
)paren
(brace
id|acpi_gbl_cm_single_step
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* No more single step while executing called method */
multiline_comment|/* Set the breakpoint on/before the call, it will stop execution as soon as we return */
id|walk_state-&gt;method_breakpoint
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Must be non-zero! */
)brace
multiline_comment|/* TBD: [Investigate] what are the namespace locking issues here */
multiline_comment|/* Acpi_ut_release_mutex (ACPI_MTX_NAMESPACE); */
multiline_comment|/* Go into the command loop and await next user command */
id|acpi_gbl_method_executing
op_assign
id|TRUE
suffix:semicolon
id|status
op_assign
id|AE_CTRL_TRUE
suffix:semicolon
r_while
c_loop
(paren
id|status
op_eq
id|AE_CTRL_TRUE
)paren
(brace
r_if
c_cond
(paren
id|acpi_gbl_debugger_configuration
op_eq
id|DEBUGGER_MULTI_THREADED
)paren
(brace
multiline_comment|/* Handshake with the front-end that gets user command lines */
id|status
op_assign
id|acpi_ut_release_mutex
(paren
id|ACPI_MTX_DEBUG_CMD_COMPLETE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
id|status
op_assign
id|acpi_ut_acquire_mutex
(paren
id|ACPI_MTX_DEBUG_CMD_READY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Single threaded, we must get a command line ourselves */
multiline_comment|/* Force output to console until a command is entered */
id|acpi_db_set_output_destination
(paren
id|ACPI_DB_CONSOLE_OUTPUT
)paren
suffix:semicolon
multiline_comment|/* Different prompt if method is executing */
r_if
c_cond
(paren
op_logical_neg
id|acpi_gbl_method_executing
)paren
(brace
id|acpi_os_printf
(paren
l_string|&quot;%1c &quot;
comma
id|ACPI_DEBUGGER_COMMAND_PROMPT
)paren
suffix:semicolon
)brace
r_else
(brace
id|acpi_os_printf
(paren
l_string|&quot;%1c &quot;
comma
id|ACPI_DEBUGGER_EXECUTE_PROMPT
)paren
suffix:semicolon
)brace
multiline_comment|/* Get the user input line */
(paren
r_void
)paren
id|acpi_os_get_line
(paren
id|acpi_gbl_db_line_buf
)paren
suffix:semicolon
)brace
id|status
op_assign
id|acpi_db_command_dispatch
(paren
id|acpi_gbl_db_line_buf
comma
id|walk_state
comma
id|op
)paren
suffix:semicolon
)brace
multiline_comment|/* Acpi_ut_acquire_mutex (ACPI_MTX_NAMESPACE); */
multiline_comment|/* User commands complete, continue execution of the interrupted method */
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_db_initialize&n; *&n; * PARAMETERS:  None&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Init and start debugger&n; *&n; ******************************************************************************/
id|acpi_status
DECL|function|acpi_db_initialize
id|acpi_db_initialize
(paren
r_void
)paren
(brace
id|acpi_status
id|status
suffix:semicolon
multiline_comment|/* Init globals */
id|acpi_gbl_db_buffer
op_assign
l_int|NULL
suffix:semicolon
id|acpi_gbl_db_filename
op_assign
l_int|NULL
suffix:semicolon
id|acpi_gbl_db_output_to_file
op_assign
id|FALSE
suffix:semicolon
id|acpi_gbl_db_debug_level
op_assign
id|ACPI_LV_VERBOSITY2
suffix:semicolon
id|acpi_gbl_db_console_debug_level
op_assign
id|NORMAL_DEFAULT
op_or
id|ACPI_LV_TABLES
suffix:semicolon
id|acpi_gbl_db_output_flags
op_assign
id|ACPI_DB_CONSOLE_OUTPUT
suffix:semicolon
id|acpi_gbl_db_opt_tables
op_assign
id|FALSE
suffix:semicolon
id|acpi_gbl_db_opt_disasm
op_assign
id|FALSE
suffix:semicolon
id|acpi_gbl_db_opt_stats
op_assign
id|FALSE
suffix:semicolon
id|acpi_gbl_db_opt_verbose
op_assign
id|TRUE
suffix:semicolon
id|acpi_gbl_db_opt_ini_methods
op_assign
id|TRUE
suffix:semicolon
id|acpi_gbl_db_buffer
op_assign
id|acpi_os_allocate
(paren
id|ACPI_DEBUG_BUFFER_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acpi_gbl_db_buffer
)paren
(brace
r_return
(paren
id|AE_NO_MEMORY
)paren
suffix:semicolon
)brace
id|ACPI_MEMSET
(paren
id|acpi_gbl_db_buffer
comma
l_int|0
comma
id|ACPI_DEBUG_BUFFER_SIZE
)paren
suffix:semicolon
multiline_comment|/* Initial scope is the root */
id|acpi_gbl_db_scope_buf
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;&bslash;&squot;
suffix:semicolon
id|acpi_gbl_db_scope_buf
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|acpi_gbl_db_scope_node
op_assign
id|acpi_gbl_root_node
suffix:semicolon
multiline_comment|/*&n;&t; * If configured for multi-thread support, the debug executor runs in&n;&t; * a separate thread so that the front end can be in another address&n;&t; * space, environment, or even another machine.&n;&t; */
r_if
c_cond
(paren
id|acpi_gbl_debugger_configuration
op_amp
id|DEBUGGER_MULTI_THREADED
)paren
(brace
multiline_comment|/* These were created with one unit, grab it */
id|status
op_assign
id|acpi_ut_acquire_mutex
(paren
id|ACPI_MTX_DEBUG_CMD_COMPLETE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|acpi_os_printf
(paren
l_string|&quot;Could not get debugger mutex&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
id|status
op_assign
id|acpi_ut_acquire_mutex
(paren
id|ACPI_MTX_DEBUG_CMD_READY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|acpi_os_printf
(paren
l_string|&quot;Could not get debugger mutex&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/* Create the debug execution thread to execute commands */
id|status
op_assign
id|acpi_os_queue_for_execution
(paren
l_int|0
comma
id|acpi_db_execute_thread
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|acpi_os_printf
(paren
l_string|&quot;Could not start debugger thread&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|acpi_gbl_db_opt_verbose
)paren
(brace
id|acpi_gbl_db_opt_disasm
op_assign
id|TRUE
suffix:semicolon
id|acpi_gbl_db_opt_stats
op_assign
id|FALSE
suffix:semicolon
)brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_db_terminate&n; *&n; * PARAMETERS:  None&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Stop debugger&n; *&n; ******************************************************************************/
r_void
DECL|function|acpi_db_terminate
id|acpi_db_terminate
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|acpi_gbl_db_table_ptr
)paren
(brace
id|acpi_os_free
(paren
id|acpi_gbl_db_table_ptr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|acpi_gbl_db_buffer
)paren
(brace
id|acpi_os_free
(paren
id|acpi_gbl_db_buffer
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* ACPI_DEBUGGER */
eof
