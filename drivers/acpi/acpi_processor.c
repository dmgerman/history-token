multiline_comment|/*&n; * acpi_processor.c - ACPI Processor Driver ($Revision: 50 $)&n; *&n; *  Copyright (C) 2001, 2002 Andy Grover &lt;andrew.grover@intel.com&gt;&n; *  Copyright (C) 2001, 2002 Paul Diefenbaugh &lt;paul.s.diefenbaugh@intel.com&gt;&n; *&n; * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or (at&n; *  your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful, but&n; *  WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; *  General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License along&n; *  with this program; if not, write to the Free Software Foundation, Inc.,&n; *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.&n; *&n; * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&n; *  TBD:&n; *&t;1. Make # power/performance states dynamic.&n; *&t;2. Includes support for _real_ performance states (not just throttle).&n; *&t;3. Support duty_cycle values that span bit 4.&n; *&t;4. Optimize by having scheduler determine business instead of&n; *         having us try to calculate it here.&n; *      5. Need C1 timing -- must modify kernel (IRQ handler) to get this.&n; *&t;6. Convert time values to ticks (initially) to avoid having to do&n; *         the math (acpi_get_timer_duration).&n; *      7. What is a good default value for the OS busy_metric?&n; *      8. Support both thermal and power limits.&n; *      9. Resolve PIIX4 BMISX errata issue (getting an I/O port value of 0).&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/pm.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &quot;acpi_bus.h&quot;
macro_line|#include &quot;acpi_drivers.h&quot;
DECL|macro|_COMPONENT
mdefine_line|#define _COMPONENT&t;&t;ACPI_PROCESSOR_COMPONENT
id|ACPI_MODULE_NAME
(paren
l_string|&quot;acpi_processor&quot;
)paren
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Paul Diefenbaugh&quot;
)paren
suffix:semicolon
DECL|variable|ACPI_PROCESSOR_DRIVER_NAME
id|MODULE_DESCRIPTION
c_func
(paren
id|ACPI_PROCESSOR_DRIVER_NAME
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|macro|PREFIX
mdefine_line|#define PREFIX&t;&t;&t;&t;&quot;ACPI: &quot;
DECL|macro|ACPI_PROCESSOR_MAX_POWER
mdefine_line|#define ACPI_PROCESSOR_MAX_POWER&t;ACPI_C_STATE_COUNT
DECL|macro|ACPI_PROCESSOR_MAX_C2_LATENCY
mdefine_line|#define ACPI_PROCESSOR_MAX_C2_LATENCY&t;100
DECL|macro|ACPI_PROCESSOR_MAX_C3_LATENCY
mdefine_line|#define ACPI_PROCESSOR_MAX_C3_LATENCY&t;1000
DECL|macro|ACPI_PROCESSOR_MAX_PERFORMANCE
mdefine_line|#define ACPI_PROCESSOR_MAX_PERFORMANCE&t;4
DECL|macro|ACPI_PROCESSOR_MAX_THROTTLING
mdefine_line|#define ACPI_PROCESSOR_MAX_THROTTLING&t;16
DECL|macro|ACPI_PROCESSOR_MAX_THROTTLE
mdefine_line|#define ACPI_PROCESSOR_MAX_THROTTLE&t;500&t;/* 50% */
DECL|macro|ACPI_PROCESSOR_MAX_DUTY_WIDTH
mdefine_line|#define ACPI_PROCESSOR_MAX_DUTY_WIDTH&t;4
DECL|variable|POWER_OF_2
r_const
id|u32
id|POWER_OF_2
(braket
)braket
op_assign
(brace
l_int|1
comma
l_int|2
comma
l_int|4
comma
l_int|8
comma
l_int|16
comma
l_int|32
comma
l_int|64
)brace
suffix:semicolon
DECL|macro|ACPI_PROCESSOR_MAX_LIMIT
mdefine_line|#define ACPI_PROCESSOR_MAX_LIMIT&t;20
r_static
r_int
id|acpi_processor_add
(paren
r_struct
id|acpi_device
op_star
id|device
)paren
suffix:semicolon
r_static
r_int
id|acpi_processor_remove
(paren
r_struct
id|acpi_device
op_star
id|device
comma
r_int
id|type
)paren
suffix:semicolon
DECL|variable|acpi_processor_driver
r_static
r_struct
id|acpi_driver
id|acpi_processor_driver
op_assign
(brace
id|name
suffix:colon
id|ACPI_PROCESSOR_DRIVER_NAME
comma
r_class
suffix:colon
id|ACPI_PROCESSOR_CLASS
comma
id|ids
suffix:colon
id|ACPI_PROCESSOR_HID
comma
id|ops
suffix:colon
(brace
id|add
suffix:colon
id|acpi_processor_add
comma
id|remove
suffix:colon
id|acpi_processor_remove
comma
)brace
comma
)brace
suffix:semicolon
multiline_comment|/* Power Management */
DECL|struct|acpi_processor_cx_policy
r_struct
id|acpi_processor_cx_policy
(brace
DECL|member|count
id|u32
id|count
suffix:semicolon
DECL|member|state
r_int
id|state
suffix:semicolon
r_struct
(brace
DECL|member|time
id|u32
id|time
suffix:semicolon
DECL|member|count
id|u32
id|count
suffix:semicolon
DECL|member|bm
id|u32
id|bm
suffix:semicolon
DECL|member|threshold
)brace
id|threshold
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|acpi_processor_cx
r_struct
id|acpi_processor_cx
(brace
DECL|member|valid
id|u8
id|valid
suffix:semicolon
DECL|member|address
id|u32
id|address
suffix:semicolon
DECL|member|latency
id|u32
id|latency
suffix:semicolon
DECL|member|power
id|u32
id|power
suffix:semicolon
DECL|member|usage
id|u32
id|usage
suffix:semicolon
DECL|member|promotion
r_struct
id|acpi_processor_cx_policy
id|promotion
suffix:semicolon
DECL|member|demotion
r_struct
id|acpi_processor_cx_policy
id|demotion
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|acpi_processor_power
r_struct
id|acpi_processor_power
(brace
DECL|member|state
r_int
id|state
suffix:semicolon
DECL|member|default_state
r_int
id|default_state
suffix:semicolon
DECL|member|bm_activity
id|u32
id|bm_activity
suffix:semicolon
DECL|member|busy_metric
id|u32
id|busy_metric
suffix:semicolon
DECL|member|states
r_struct
id|acpi_processor_cx
id|states
(braket
id|ACPI_PROCESSOR_MAX_POWER
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Performance Management */
DECL|struct|acpi_processor_px
r_struct
id|acpi_processor_px
(brace
DECL|member|valid
id|u8
id|valid
suffix:semicolon
DECL|member|core_frequency
id|u32
id|core_frequency
suffix:semicolon
DECL|member|power
id|u32
id|power
suffix:semicolon
DECL|member|transition_latency
id|u32
id|transition_latency
suffix:semicolon
DECL|member|bus_master_latency
id|u32
id|bus_master_latency
suffix:semicolon
DECL|member|control
id|u32
id|control
suffix:semicolon
DECL|member|status
id|u32
id|status
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|acpi_processor_performance
r_struct
id|acpi_processor_performance
(brace
DECL|member|state
r_int
id|state
suffix:semicolon
DECL|member|state_count
r_int
id|state_count
suffix:semicolon
DECL|member|states
r_struct
id|acpi_processor_px
id|states
(braket
id|ACPI_PROCESSOR_MAX_PERFORMANCE
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Throttling Control */
DECL|struct|acpi_processor_tx
r_struct
id|acpi_processor_tx
(brace
DECL|member|valid
id|u8
id|valid
suffix:semicolon
DECL|member|power
id|u16
id|power
suffix:semicolon
DECL|member|performance
id|u16
id|performance
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|acpi_processor_throttling
r_struct
id|acpi_processor_throttling
(brace
DECL|member|state
r_int
id|state
suffix:semicolon
DECL|member|address
id|u32
id|address
suffix:semicolon
DECL|member|duty_offset
id|u8
id|duty_offset
suffix:semicolon
DECL|member|duty_width
id|u8
id|duty_width
suffix:semicolon
DECL|member|state_count
r_int
id|state_count
suffix:semicolon
DECL|member|states
r_struct
id|acpi_processor_tx
id|states
(braket
id|ACPI_PROCESSOR_MAX_THROTTLING
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Limit Interface */
DECL|struct|acpi_processor_lx
r_struct
id|acpi_processor_lx
(brace
DECL|member|valid
id|u8
id|valid
suffix:semicolon
DECL|member|performance
id|u16
id|performance
suffix:semicolon
DECL|member|px
r_int
id|px
suffix:semicolon
DECL|member|tx
r_int
id|tx
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|acpi_processor_limit
r_struct
id|acpi_processor_limit
(brace
DECL|member|state
r_int
id|state
suffix:semicolon
DECL|member|state_count
r_int
id|state_count
suffix:semicolon
r_struct
(brace
DECL|member|valid
id|u8
id|valid
suffix:semicolon
DECL|member|performance
id|u16
id|performance
suffix:semicolon
DECL|member|px
r_int
id|px
suffix:semicolon
DECL|member|tx
r_int
id|tx
suffix:semicolon
DECL|member|states
)brace
id|states
(braket
id|ACPI_PROCESSOR_MAX_LIMIT
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|acpi_processor_flags
r_struct
id|acpi_processor_flags
(brace
DECL|member|bm_control
id|u8
id|bm_control
suffix:colon
l_int|1
suffix:semicolon
DECL|member|power
id|u8
id|power
suffix:colon
l_int|1
suffix:semicolon
DECL|member|performance
id|u8
id|performance
suffix:colon
l_int|1
suffix:semicolon
DECL|member|throttling
id|u8
id|throttling
suffix:colon
l_int|1
suffix:semicolon
DECL|member|limit
id|u8
id|limit
suffix:colon
l_int|1
suffix:semicolon
DECL|member|reserved
id|u8
id|reserved
suffix:colon
l_int|3
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|acpi_processor_errata
r_struct
id|acpi_processor_errata
(brace
r_struct
(brace
DECL|member|reverse_throttle
id|u8
id|reverse_throttle
suffix:semicolon
DECL|member|bmisx
id|u32
id|bmisx
suffix:semicolon
DECL|member|piix4
)brace
id|piix4
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|acpi_processor
r_struct
id|acpi_processor
(brace
DECL|member|handle
id|acpi_handle
id|handle
suffix:semicolon
DECL|member|acpi_id
id|u32
id|acpi_id
suffix:semicolon
DECL|member|id
id|u32
id|id
suffix:semicolon
DECL|member|flags
r_struct
id|acpi_processor_flags
id|flags
suffix:semicolon
DECL|member|errata
r_struct
id|acpi_processor_errata
id|errata
suffix:semicolon
DECL|member|power
r_struct
id|acpi_processor_power
id|power
suffix:semicolon
DECL|member|performance
r_struct
id|acpi_processor_performance
id|performance
suffix:semicolon
DECL|member|throttling
r_struct
id|acpi_processor_throttling
id|throttling
suffix:semicolon
DECL|member|limit
r_struct
id|acpi_processor_limit
id|limit
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|acpi_processor_smp
r_static
id|u8
id|acpi_processor_smp
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* --------------------------------------------------------------------------&n;                                Errata Handling&n;   -------------------------------------------------------------------------- */
r_int
DECL|function|acpi_processor_get_errata
id|acpi_processor_get_errata
(paren
r_struct
id|acpi_processor
op_star
id|pr
)paren
(brace
r_struct
id|pci_dev
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_get_errata&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr
)paren
id|return_VALUE
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * PIIX4&n;&t; * -----&n;&t; */
id|dev
op_assign
id|pci_find_subsys
c_func
(paren
id|PCI_VENDOR_ID_INTEL
comma
id|PCI_DEVICE_ID_INTEL_82371AB_3
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
)paren
(brace
id|u8
id|rev
op_assign
l_int|0
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|dev
comma
id|PCI_REVISION_ID
comma
op_amp
id|rev
)paren
suffix:semicolon
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;PIIX4 ACPI rev %d&bslash;n&quot;
comma
id|rev
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|rev
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* PIIX4 A-step */
r_case
l_int|1
suffix:colon
multiline_comment|/* PIIX4 B-step */
multiline_comment|/*&n;&t;&t;&t; * Workaround for reverse-notation on throttling states&n;&t;&t;&t; * used by early PIIX4 models.&n;&t;&t;&t; */
id|pr-&gt;errata.piix4.reverse_throttle
op_assign
l_int|1
suffix:semicolon
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;Reverse-throttle errata enabled&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* PIIX4E */
r_case
l_int|3
suffix:colon
multiline_comment|/* PIIX4M */
multiline_comment|/*&n;&t;&t;&t; * Workaround for errata #18 &quot;C3 Power State/BMIDE and&n;&t;&t;&t; * Type-F DMA Livelock&quot; from the July 2001 PIIX4&n;&t;&t;&t; * specification update.  Applies to all PIIX4 models.&n;&t;&t;&t; */
multiline_comment|/* TBD: Why is the bmisx value always ZERO? */
id|pr-&gt;errata.piix4.bmisx
op_assign
id|pci_resource_start
c_func
(paren
id|dev
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pr-&gt;errata.piix4.bmisx
)paren
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;BM-IDE errata enabled&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|return_VALUE
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------------&n;                                Power Management&n;   -------------------------------------------------------------------------- */
DECL|variable|acpi_processor_list
r_static
r_struct
id|acpi_processor
op_star
id|acpi_processor_list
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|variable|pm_idle_save
r_static
r_void
(paren
op_star
id|pm_idle_save
)paren
(paren
r_void
)paren
op_assign
l_int|NULL
suffix:semicolon
r_static
r_void
DECL|function|acpi_processor_power_activate
id|acpi_processor_power_activate
(paren
r_struct
id|acpi_processor
op_star
id|pr
comma
r_int
id|state
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pr
)paren
r_return
suffix:semicolon
id|pr-&gt;power.states
(braket
id|pr-&gt;power.state
)braket
dot
id|promotion.count
op_assign
l_int|0
suffix:semicolon
id|pr-&gt;power.states
(braket
id|pr-&gt;power.state
)braket
dot
id|demotion.count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Cleanup from old state. */
r_switch
c_cond
(paren
id|pr-&gt;power.state
)paren
(brace
r_case
id|ACPI_STATE_C3
suffix:colon
multiline_comment|/* Disable bus master reload */
id|acpi_hw_bit_register_write
c_func
(paren
id|ACPI_BITREG_BUS_MASTER_RLD
comma
l_int|0
comma
id|ACPI_MTX_DO_NOT_LOCK
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Prepare to use new state. */
r_switch
c_cond
(paren
id|state
)paren
(brace
r_case
id|ACPI_STATE_C3
suffix:colon
multiline_comment|/* Enable bus master reload */
id|acpi_hw_bit_register_write
c_func
(paren
id|ACPI_BITREG_BUS_MASTER_RLD
comma
l_int|1
comma
id|ACPI_MTX_DO_NOT_LOCK
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|pr-&gt;power.state
op_assign
id|state
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_void
DECL|function|acpi_processor_idle
id|acpi_processor_idle
(paren
r_void
)paren
(brace
r_struct
id|acpi_processor
op_star
id|pr
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|acpi_processor_cx
op_star
id|cx
op_assign
l_int|NULL
suffix:semicolon
r_int
id|next_state
op_assign
l_int|0
suffix:semicolon
id|u32
id|start_ticks
op_assign
l_int|0
suffix:semicolon
id|u32
id|end_ticks
op_assign
l_int|0
suffix:semicolon
id|u32
id|time_elapsed
op_assign
l_int|0
suffix:semicolon
r_static
r_int
r_int
id|last_idle_jiffies
op_assign
l_int|0
suffix:semicolon
id|pr
op_assign
id|acpi_processor_list
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Interrupts must be disabled during bus mastering calculations and&n;&t; * for C2/C3 transitions.&n;&t; */
id|__cli
c_func
(paren
)paren
suffix:semicolon
id|next_state
op_assign
id|pr-&gt;power.state
suffix:semicolon
multiline_comment|/*&n;&t; * Check OS Idleness:&n;&t; * ------------------&n;&t; * If the OS has been busy (hasn&squot;t called the idle handler in a while)&n;&t; * then automatically demote to the default power state (e.g. C1).&n;&t; *&n;&t; * TBD: Optimize by having scheduler determine business instead&n;&t; *      of having us try to calculate it here.&n;&t; */
r_if
c_cond
(paren
id|pr-&gt;power.state
op_ne
id|pr-&gt;power.default_state
)paren
(brace
r_if
c_cond
(paren
(paren
id|jiffies
op_minus
id|last_idle_jiffies
)paren
op_ge
id|pr-&gt;power.busy_metric
)paren
(brace
id|next_state
op_assign
id|pr-&gt;power.default_state
suffix:semicolon
r_if
c_cond
(paren
id|next_state
op_ne
id|pr-&gt;power.state
)paren
id|acpi_processor_power_activate
c_func
(paren
id|pr
comma
id|next_state
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Log BM Activity:&n;&t; * ----------------&n;&t; * Read BM_STS and record its value for later use by C3 policy.&n;&t; * (Note that we save the BM_STS values for the last 32 cycles).&n;&t; */
r_if
c_cond
(paren
id|pr-&gt;flags.bm_control
)paren
(brace
id|pr-&gt;power.bm_activity
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|acpi_hw_bit_register_read
c_func
(paren
id|ACPI_BITREG_BUS_MASTER_STATUS
comma
id|ACPI_MTX_DO_NOT_LOCK
)paren
)paren
(brace
id|pr-&gt;power.bm_activity
op_or_assign
l_int|1
suffix:semicolon
id|acpi_hw_bit_register_write
c_func
(paren
id|ACPI_BITREG_BUS_MASTER_STATUS
comma
l_int|1
comma
id|ACPI_MTX_DO_NOT_LOCK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * PIIX4 Errata:&n;&t;&t; * -------------&n;&t;&t; * This code is a workaround for errata #18 &quot;C3 Power State/&n;&t;&t; * BMIDE and Type-F DMA Livelock&quot; from the July &squot;01 PIIX4&n;&t;&t; * specification update.  Note that BM_STS doesn&squot;t always&n;&t;&t; * reflect the true state of bus mastering activity; forcing&n;&t;&t; * us to manually check the BMIDEA bit of each IDE channel.&n;&t;&t; */
r_else
r_if
c_cond
(paren
id|pr-&gt;errata.piix4.bmisx
)paren
(brace
r_if
c_cond
(paren
(paren
id|inb_p
c_func
(paren
id|pr-&gt;errata.piix4.bmisx
op_plus
l_int|0x02
)paren
op_amp
l_int|0x01
)paren
op_logical_or
(paren
id|inb_p
c_func
(paren
id|pr-&gt;errata.piix4.bmisx
op_plus
l_int|0x0A
)paren
op_amp
l_int|0x01
)paren
)paren
id|pr-&gt;power.bm_activity
op_or_assign
l_int|1
suffix:semicolon
)brace
)brace
id|cx
op_assign
op_amp
(paren
id|pr-&gt;power.states
(braket
id|pr-&gt;power.state
)braket
)paren
suffix:semicolon
id|cx-&gt;usage
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * Sleep:&n;&t; * ------&n;&t; * Invoke the current Cx state to put the processor to sleep.&n;&t; */
r_switch
c_cond
(paren
id|pr-&gt;power.state
)paren
(brace
r_case
id|ACPI_STATE_C1
suffix:colon
multiline_comment|/* Invoke C1. */
id|safe_halt
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;                 * TBD: Can&squot;t get time duration while in C1, as resumes&n;&t;&t; *      go to an ISR rather than here.  Need to instrument&n;&t;&t; *      base interrupt handler.&n;&t;&t; */
id|time_elapsed
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACPI_STATE_C2
suffix:colon
multiline_comment|/* See how long we&squot;re asleep for */
id|start_ticks
op_assign
id|inl
c_func
(paren
id|acpi_fadt.Xpm_tmr_blk.address
)paren
suffix:semicolon
multiline_comment|/* Invoke C2 */
id|inb
c_func
(paren
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C2
)braket
dot
id|address
)paren
suffix:semicolon
multiline_comment|/* Dummy op - must do something useless after P_LVL2 read */
id|end_ticks
op_assign
id|inl
c_func
(paren
id|acpi_fadt.Xpm_tmr_blk.address
)paren
suffix:semicolon
multiline_comment|/* Compute time elapsed */
id|end_ticks
op_assign
id|inl
c_func
(paren
id|acpi_fadt.Xpm_tmr_blk.address
)paren
suffix:semicolon
multiline_comment|/* Re-enable interrupts */
id|__sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Compute the amount of time asleep (in the Cx state).&n;&t;&t; * TBD: Convert to PM timer ticks initially to avoid having&n;&t;&t; *      to do the math (acpi_get_timer_duration).&n;&t;&t; */
id|acpi_get_timer_duration
c_func
(paren
id|start_ticks
comma
id|end_ticks
comma
op_amp
id|time_elapsed
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACPI_STATE_C3
suffix:colon
multiline_comment|/* Disable bus master arbitration */
id|acpi_hw_bit_register_write
c_func
(paren
id|ACPI_BITREG_ARB_DISABLE
comma
l_int|1
comma
id|ACPI_MTX_DO_NOT_LOCK
)paren
suffix:semicolon
multiline_comment|/* See how long we&squot;re asleep for */
id|start_ticks
op_assign
id|inl
c_func
(paren
id|acpi_fadt.Xpm_tmr_blk.address
)paren
suffix:semicolon
multiline_comment|/* Invoke C2 */
id|inb
c_func
(paren
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C3
)braket
dot
id|address
)paren
suffix:semicolon
multiline_comment|/* Dummy op - must do something useless after P_LVL3 read */
id|end_ticks
op_assign
id|inl
c_func
(paren
id|acpi_fadt.Xpm_tmr_blk.address
)paren
suffix:semicolon
multiline_comment|/* Compute time elapsed */
id|end_ticks
op_assign
id|inl
c_func
(paren
id|acpi_fadt.Xpm_tmr_blk.address
)paren
suffix:semicolon
multiline_comment|/* Enable bus master arbitration */
id|acpi_hw_bit_register_write
c_func
(paren
id|ACPI_BITREG_ARB_DISABLE
comma
l_int|0
comma
id|ACPI_MTX_DO_NOT_LOCK
)paren
suffix:semicolon
multiline_comment|/* Re-enable interrupts */
id|__sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Compute the amount of time asleep (in the Cx state).&n;&t;&t; * TBD: Convert to PM timer ticks initially to avoid having&n;&t;&t; *      to do the math (acpi_get_timer_duration).&n;&t;&t; */
id|acpi_get_timer_duration
c_func
(paren
id|start_ticks
comma
id|end_ticks
comma
op_amp
id|time_elapsed
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|__sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Promotion?&n;&t; * ----------&n;&t; * Track the number of longs (time asleep is greater than threshold)&n;&t; * and promote when the count threshold is reached.  Note that bus&n;&t; * mastering activity may prevent promotions.&n;&t; */
r_if
c_cond
(paren
id|cx-&gt;promotion.state
)paren
(brace
r_if
c_cond
(paren
id|time_elapsed
op_ge
id|cx-&gt;promotion.threshold.time
)paren
(brace
id|cx-&gt;promotion.count
op_increment
suffix:semicolon
id|cx-&gt;demotion.count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cx-&gt;promotion.count
op_ge
id|cx-&gt;promotion.threshold.count
)paren
(brace
r_if
c_cond
(paren
id|pr-&gt;flags.bm_control
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|pr-&gt;power.bm_activity
op_amp
id|cx-&gt;promotion.threshold.bm
)paren
)paren
id|next_state
op_assign
id|cx-&gt;promotion.state
suffix:semicolon
)brace
r_else
id|next_state
op_assign
id|cx-&gt;promotion.state
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * Demotion?&n;&t; * ---------&n;&t; * Track the number of shorts (time asleep is less than time threshold)&n;&t; * and demote when the usage threshold is reached.  Note that bus&n;&t; * mastering activity may cause immediate demotions.&n;&t; */
r_if
c_cond
(paren
id|cx-&gt;demotion.state
)paren
(brace
r_if
c_cond
(paren
id|time_elapsed
OL
id|cx-&gt;demotion.threshold.time
)paren
(brace
id|cx-&gt;demotion.count
op_increment
suffix:semicolon
id|cx-&gt;promotion.count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cx-&gt;demotion.count
op_ge
id|cx-&gt;demotion.threshold.count
)paren
id|next_state
op_assign
id|cx-&gt;demotion.state
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pr-&gt;flags.bm_control
)paren
(brace
r_if
c_cond
(paren
id|pr-&gt;power.bm_activity
op_amp
id|cx-&gt;demotion.threshold.bm
)paren
id|next_state
op_assign
id|cx-&gt;demotion.state
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * New Cx State?&n;&t; * -------------&n;&t; * If we&squot;re going to start using a new Cx state we must clean up&n;&t; * from the previous and prepare to use the new.&n;&t; */
r_if
c_cond
(paren
id|next_state
op_ne
id|pr-&gt;power.state
)paren
id|acpi_processor_power_activate
c_func
(paren
id|pr
comma
id|next_state
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Track OS Idleness:&n;&t; * ------------------&n;&t; * Record a jiffies timestamp to compute time elapsed between calls&n;&t; * to the idle handler.&n;&t; */
id|last_idle_jiffies
op_assign
id|jiffies
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_int
DECL|function|acpi_processor_set_power_policy
id|acpi_processor_set_power_policy
(paren
r_struct
id|acpi_processor
op_star
id|pr
)paren
(brace
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_set_power_policy&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This function sets the default Cx state policy (OS idle handler).&n;&t; * Our scheme is to promote quickly to C2 but more conservatively&n;&t; * to C3.  We&squot;re favoring C2  for its characteristics of low latency&n;&t; * (quick response), good power savings, and ability to allow bus&n;&t; * mastering activity.  Note that the Cx state policy is completely&n;&t; * customizable and can be altered dynamically.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|pr
)paren
id|return_VALUE
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The Busy Metric is used to determine when the OS has been busy&n;&t; * and thus when policy should return to using the default Cx state&n;&t; * (e.g. C1).  On Linux we use the number of jiffies (scheduler&n;&t; * quantums) that transpire between calls to the idle handler.&n;&t; *&n;&t; * TBD: What is a good value for the OS busy_metric?&n;&t; */
id|pr-&gt;power.busy_metric
op_assign
l_int|2
suffix:semicolon
multiline_comment|/*&n;&t; * C0/C1&n;&t; * -----&n;&t; */
r_if
c_cond
(paren
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C1
)braket
dot
id|valid
)paren
(brace
id|pr-&gt;power.state
op_assign
id|ACPI_STATE_C1
suffix:semicolon
id|pr-&gt;power.default_state
op_assign
id|ACPI_STATE_C1
suffix:semicolon
)brace
r_else
(brace
id|pr-&gt;power.state
op_assign
id|ACPI_STATE_C0
suffix:semicolon
id|pr-&gt;power.default_state
op_assign
id|ACPI_STATE_C0
suffix:semicolon
id|return_VALUE
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * C1/C2&n;&t; * -----&n;&t; * Set the default C1 promotion and C2 demotion policies, where we&n;&t; * promote from C1 to C2 anytime we&squot;re asleep in C1 for longer than&n;&t; * two times the C2 latency (to amortize cost of transitions). Demote&n;&t; * from C2 to C1 anytime we&squot;re asleep in C2 for less than this time.&n;&t; */
r_if
c_cond
(paren
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C2
)braket
dot
id|valid
)paren
(brace
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C1
)braket
dot
id|promotion.threshold.count
op_assign
l_int|10
suffix:semicolon
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C1
)braket
dot
id|promotion.threshold.time
op_assign
(paren
l_int|2
op_star
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C2
)braket
dot
id|latency
)paren
suffix:semicolon
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C1
)braket
dot
id|promotion.state
op_assign
id|ACPI_STATE_C2
suffix:semicolon
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C2
)braket
dot
id|demotion.threshold.count
op_assign
l_int|1
suffix:semicolon
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C2
)braket
dot
id|demotion.threshold.time
op_assign
(paren
l_int|2
op_star
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C2
)braket
dot
id|latency
)paren
suffix:semicolon
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C2
)braket
dot
id|demotion.state
op_assign
id|ACPI_STATE_C1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * C2/C3&n;&t; * -----&n;&t; * Set default C2 promotion and C3 demotion policies, where we promote&n;&t; * from C2 to C3 after 4 cycles (0x0F) of no bus mastering activity&n;&t; * (while maintaining sleep time criteria).  Demote immediately on a&n;&t; * short or whenever bus mastering activity occurs.&n;&t; */
r_if
c_cond
(paren
(paren
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C2
)braket
dot
id|valid
)paren
op_logical_and
(paren
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C3
)braket
dot
id|valid
)paren
)paren
(brace
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C2
)braket
dot
id|promotion.threshold.count
op_assign
l_int|1
suffix:semicolon
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C2
)braket
dot
id|promotion.threshold.time
op_assign
(paren
l_int|2
op_star
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C3
)braket
dot
id|latency
)paren
suffix:semicolon
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C2
)braket
dot
id|promotion.threshold.bm
op_assign
l_int|0x0F
suffix:semicolon
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C2
)braket
dot
id|promotion.state
op_assign
id|ACPI_STATE_C3
suffix:semicolon
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C3
)braket
dot
id|demotion.threshold.count
op_assign
l_int|1
suffix:semicolon
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C3
)braket
dot
id|demotion.threshold.time
op_assign
(paren
l_int|2
op_star
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C3
)braket
dot
id|latency
)paren
suffix:semicolon
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C3
)braket
dot
id|demotion.threshold.bm
op_assign
l_int|0x0F
suffix:semicolon
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C3
)braket
dot
id|demotion.state
op_assign
id|ACPI_STATE_C2
suffix:semicolon
)brace
id|return_VALUE
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_int
DECL|function|acpi_processor_get_power_info
id|acpi_processor_get_power_info
(paren
r_struct
id|acpi_processor
op_star
id|pr
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_get_power_info&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr
)paren
id|return_VALUE
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;lvl2[0x%08x] lvl3[0x%08x]&bslash;n&quot;
comma
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C2
)braket
dot
id|address
comma
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C3
)braket
dot
id|address
)paren
)paren
suffix:semicolon
multiline_comment|/* TBD: Support ACPI 2.0 objects */
multiline_comment|/*&n;&t; * C0&n;&t; * --&n;&t; * This state exists only as filler in our array.&n;&t; */
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C0
)braket
dot
id|valid
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/*&n;&t; * C1&n;&t; * --&n;&t; * ACPI requires C1 support for all processors.&n;&t; *&n;&t; * TBD: What about PROC_C1?&n;&t; */
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C1
)braket
dot
id|valid
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/*&n;&t; * C2&n;&t; * --&n;&t; * We&squot;re (currently) only supporting C2 on UP systems.&n;&t; *&n;&t; * TBD: Support for C2 on MP (P_LVL2_UP).&n;&t; */
r_if
c_cond
(paren
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C2
)braket
dot
id|address
)paren
(brace
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C2
)braket
dot
id|latency
op_assign
id|acpi_fadt.plvl2_lat
suffix:semicolon
r_if
c_cond
(paren
id|acpi_fadt.plvl2_lat
OG
id|ACPI_PROCESSOR_MAX_C2_LATENCY
)paren
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;C2 latency too large [%d]&bslash;n&quot;
comma
id|acpi_fadt.plvl2_lat
)paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|acpi_processor_smp
)paren
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C2
)braket
dot
id|valid
op_assign
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * C3&n;&t; * --&n;&t; * We&squot;re (currently) only supporting C3 on UP systems that include&n;&t; * bus mastering arbitration control.  Note that this method of&n;&t; * maintaining cache coherency (disabling of bus mastering) cannot be&n;&t; * used on SMP systems, and flushing caches (e.g. WBINVD) is simply&n;&t; * too costly (at this time).&n;&t; */
r_if
c_cond
(paren
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C3
)braket
dot
id|address
)paren
(brace
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C3
)braket
dot
id|latency
op_assign
id|acpi_fadt.plvl3_lat
suffix:semicolon
r_if
c_cond
(paren
id|acpi_fadt.plvl3_lat
OG
id|ACPI_PROCESSOR_MAX_C3_LATENCY
)paren
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;C3 latency too large [%d]&bslash;n&quot;
comma
id|acpi_fadt.plvl3_lat
)paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|acpi_processor_smp
op_logical_and
id|pr-&gt;flags.bm_control
)paren
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C3
)braket
dot
id|valid
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Set Default Policy&n;&t; * ------------------&n;&t; * Now that we know which state are supported, set the default&n;&t; * policy.  Note that this policy can be changed dynamically&n;&t; * (e.g. encourage deeper sleeps to conserve battery life when&n;&t; * not on AC).&n;&t; */
id|result
op_assign
id|acpi_processor_set_power_policy
c_func
(paren
id|pr
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_ne
id|result
)paren
id|return_VALUE
c_func
(paren
id|result
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If this processor supports C2 or C3 we denote it as being &squot;power&n;&t; * manageable&squot;.  Note that there&squot;s really no policy involved for&n;&t; * when only C1 is supported.&n;&t; */
r_if
c_cond
(paren
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C2
)braket
dot
id|valid
op_logical_or
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C3
)braket
dot
id|valid
)paren
id|pr-&gt;flags.power
op_assign
l_int|1
suffix:semicolon
id|return_VALUE
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------------&n;                              Performance Management&n;   -------------------------------------------------------------------------- */
r_static
r_int
DECL|function|acpi_processor_get_performance
id|acpi_processor_get_performance
(paren
r_struct
id|acpi_processor
op_star
id|pr
)paren
(brace
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_get_performance_state&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr
)paren
id|return_VALUE
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr-&gt;flags.performance
)paren
id|return_VALUE
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* TBD */
id|return_VALUE
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|acpi_processor_set_performance
id|acpi_processor_set_performance
(paren
r_struct
id|acpi_processor
op_star
id|pr
comma
r_int
id|state
)paren
(brace
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_set_performance_state&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr
)paren
id|return_VALUE
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr-&gt;flags.performance
)paren
id|return_VALUE
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state
op_ge
id|pr-&gt;performance.state_count
)paren
id|return_VALUE
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state
op_eq
id|pr-&gt;performance.state
)paren
id|return_VALUE
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* TBD */
id|return_VALUE
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|acpi_processor_get_performance_info
id|acpi_processor_get_performance_info
(paren
r_struct
id|acpi_processor
op_star
id|pr
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_get_performance_info&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr
)paren
id|return_VALUE
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/* TBD: Support ACPI 2.0 objects */
id|return_VALUE
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------------&n;                              Throttling Control&n;   -------------------------------------------------------------------------- */
r_static
r_int
DECL|function|acpi_processor_get_throttling
id|acpi_processor_get_throttling
(paren
r_struct
id|acpi_processor
op_star
id|pr
)paren
(brace
r_int
id|state
op_assign
l_int|0
suffix:semicolon
id|u32
id|value
op_assign
l_int|0
suffix:semicolon
id|u32
id|duty_mask
op_assign
l_int|0
suffix:semicolon
id|u32
id|duty_value
op_assign
l_int|0
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_get_throttling&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr
)paren
id|return_VALUE
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr-&gt;flags.throttling
)paren
id|return_VALUE
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
id|pr-&gt;throttling.state
op_assign
l_int|0
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
id|duty_mask
op_assign
id|pr-&gt;throttling.state_count
op_minus
l_int|1
suffix:semicolon
id|duty_mask
op_lshift_assign
id|pr-&gt;throttling.duty_offset
suffix:semicolon
id|value
op_assign
id|inb
c_func
(paren
id|pr-&gt;throttling.address
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Compute the current throttling state when throttling is enabled&n;&t; * (bit 4 is on).  Note that the reverse_throttling flag indicates&n;&t; * that the duty_value is opposite of that specified by ACPI.&n;&t; */
r_if
c_cond
(paren
id|value
op_amp
l_int|0x10
)paren
(brace
id|duty_value
op_assign
id|value
op_amp
id|duty_mask
suffix:semicolon
id|duty_value
op_rshift_assign
id|pr-&gt;throttling.duty_offset
suffix:semicolon
r_if
c_cond
(paren
id|duty_value
)paren
(brace
r_if
c_cond
(paren
id|pr-&gt;errata.piix4.reverse_throttle
)paren
id|state
op_assign
id|duty_value
suffix:semicolon
r_else
id|state
op_assign
id|pr-&gt;throttling.state_count
op_minus
id|duty_value
suffix:semicolon
)brace
)brace
id|pr-&gt;throttling.state
op_assign
id|state
suffix:semicolon
id|__sti
c_func
(paren
)paren
suffix:semicolon
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;Throttling state is T%d (%d%% throttling applied)&bslash;n&quot;
comma
id|state
comma
id|pr-&gt;throttling.states
(braket
id|state
)braket
dot
id|performance
)paren
)paren
suffix:semicolon
id|return_VALUE
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|acpi_processor_set_throttling
id|acpi_processor_set_throttling
(paren
r_struct
id|acpi_processor
op_star
id|pr
comma
r_int
id|state
)paren
(brace
id|u32
id|value
op_assign
l_int|0
suffix:semicolon
id|u32
id|duty_mask
op_assign
l_int|0
suffix:semicolon
id|u32
id|duty_value
op_assign
l_int|0
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_set_throttling&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr
)paren
id|return_VALUE
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|state
OL
l_int|0
)paren
op_logical_or
(paren
id|state
OG
(paren
id|pr-&gt;throttling.state_count
op_minus
l_int|1
)paren
)paren
)paren
id|return_VALUE
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr-&gt;flags.throttling
op_logical_or
op_logical_neg
id|pr-&gt;throttling.states
(braket
id|state
)braket
dot
id|valid
)paren
id|return_VALUE
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state
op_eq
id|pr-&gt;throttling.state
)paren
id|return_VALUE
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate the duty_value and duty_mask.  Note that the&n;&t; * reverse_throttling flag indicates that the duty_value is&n;&t; * opposite of that specified by ACPI.&n;&t; */
r_if
c_cond
(paren
id|state
)paren
(brace
r_if
c_cond
(paren
id|pr-&gt;errata.piix4.reverse_throttle
)paren
id|duty_value
op_assign
id|state
suffix:semicolon
r_else
id|duty_value
op_assign
id|pr-&gt;throttling.state_count
op_minus
id|state
suffix:semicolon
id|duty_value
op_lshift_assign
id|pr-&gt;throttling.duty_offset
suffix:semicolon
multiline_comment|/* Used to clear all duty_value bits */
id|duty_mask
op_assign
id|pr-&gt;performance.state_count
op_minus
l_int|1
suffix:semicolon
id|duty_mask
op_lshift_assign
id|acpi_fadt.duty_offset
suffix:semicolon
id|duty_mask
op_assign
op_complement
id|duty_mask
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Disable throttling by writing a 0 to bit 4.  Note that we must&n;&t; * turn it off before you can change the duty_value.&n;&t; */
id|value
op_assign
id|inb
c_func
(paren
id|pr-&gt;throttling.address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_amp
l_int|0x10
)paren
(brace
id|value
op_and_assign
l_int|0xFFFFFFEF
suffix:semicolon
id|outl
c_func
(paren
id|value
comma
id|pr-&gt;throttling.address
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Write the new duty_value and then enable throttling.  Note&n;&t; * that a state value of 0 leaves throttling disabled.&n;&t; */
r_if
c_cond
(paren
id|state
)paren
(brace
id|value
op_and_assign
id|duty_mask
suffix:semicolon
id|value
op_or_assign
id|duty_value
suffix:semicolon
id|outl
c_func
(paren
id|value
comma
id|pr-&gt;throttling.address
)paren
suffix:semicolon
id|value
op_or_assign
l_int|0x00000010
suffix:semicolon
id|outl
c_func
(paren
id|value
comma
id|pr-&gt;throttling.address
)paren
suffix:semicolon
)brace
id|pr-&gt;throttling.state
op_assign
id|state
suffix:semicolon
id|__sti
c_func
(paren
)paren
suffix:semicolon
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;Throttling state set to T%d (%d%%)&bslash;n&quot;
comma
id|state
comma
(paren
id|pr-&gt;throttling.states
(braket
id|state
)braket
dot
id|performance
ques
c_cond
id|pr-&gt;throttling.states
(braket
id|state
)braket
dot
id|performance
op_div
l_int|10
suffix:colon
l_int|0
)paren
)paren
)paren
suffix:semicolon
id|return_VALUE
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|acpi_processor_get_throttling_info
id|acpi_processor_get_throttling_info
(paren
r_struct
id|acpi_processor
op_star
id|pr
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_int
id|step
op_assign
l_int|0
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_get_throttling_info&quot;
)paren
suffix:semicolon
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;pblk_address[0x%08x] duty_offset[%d] duty_width[%d]&bslash;n&quot;
comma
id|pr-&gt;throttling.address
comma
id|pr-&gt;throttling.duty_offset
comma
id|pr-&gt;throttling.duty_width
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr
)paren
id|return_VALUE
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/* TBD: Support ACPI 2.0 objects */
r_if
c_cond
(paren
op_logical_neg
id|pr-&gt;throttling.address
)paren
(brace
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;No throttling register&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|return_VALUE
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|pr-&gt;throttling.duty_width
)paren
(brace
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_WARN
comma
l_string|&quot;Invalid duty_width&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|return_VALUE
c_func
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
)brace
multiline_comment|/* TBD: Support duty_cycle values that span bit 4. */
r_else
r_if
c_cond
(paren
(paren
id|pr-&gt;throttling.duty_offset
op_plus
id|pr-&gt;throttling.duty_width
)paren
OG
l_int|4
)paren
(brace
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;duty_cycle spans bit 4&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|return_VALUE
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|pr-&gt;throttling.state_count
op_assign
id|POWER_OF_2
(braket
id|acpi_fadt.duty_width
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Compute state values. Note that throttling displays a linear power/&n;&t; * performance relationship (at 50% performance the CPU will consume&n;&t; * 50% power).  Values are in 1/10th of a percent to preserve accuracy.&n;&t; */
id|step
op_assign
(paren
l_int|1000
op_div
id|pr-&gt;throttling.state_count
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pr-&gt;throttling.state_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pr-&gt;throttling.states
(braket
id|i
)braket
dot
id|performance
op_assign
id|step
op_star
id|i
suffix:semicolon
id|pr-&gt;throttling.states
(braket
id|i
)braket
dot
id|power
op_assign
id|step
op_star
id|i
suffix:semicolon
id|pr-&gt;throttling.states
(braket
id|i
)braket
dot
id|valid
op_assign
l_int|1
suffix:semicolon
)brace
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;Found %d throttling states&bslash;n&quot;
comma
id|pr-&gt;throttling.state_count
)paren
)paren
suffix:semicolon
id|pr-&gt;flags.throttling
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Disable throttling (if enabled).  We&squot;ll let subsequent policy (e.g. &n;&t; * thermal) decide to lower performance if it so chooses, but for now &n;&t; * we&squot;ll crank up the speed.&n;&t; */
id|result
op_assign
id|acpi_processor_get_throttling
c_func
(paren
id|pr
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_ne
id|result
)paren
r_goto
id|end
suffix:semicolon
r_if
c_cond
(paren
id|pr-&gt;throttling.state
)paren
(brace
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;Disabling throttling (was T%d)&bslash;n&quot;
comma
id|pr-&gt;throttling.state
)paren
)paren
suffix:semicolon
id|result
op_assign
id|acpi_processor_set_throttling
c_func
(paren
id|pr
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_ne
id|result
)paren
r_goto
id|end
suffix:semicolon
)brace
id|end
suffix:colon
r_if
c_cond
(paren
l_int|0
op_ne
id|result
)paren
id|pr-&gt;flags.throttling
op_assign
l_int|0
suffix:semicolon
id|return_VALUE
c_func
(paren
id|result
)paren
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------------&n;                                 Limit Interface&n;   -------------------------------------------------------------------------- */
r_int
DECL|function|acpi_processor_set_limit
id|acpi_processor_set_limit
(paren
id|acpi_handle
id|handle
comma
r_int
id|type
comma
r_int
op_star
id|state
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_struct
id|acpi_processor
op_star
id|pr
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|acpi_device
op_star
id|device
op_assign
l_int|NULL
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_set_limit&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state
)paren
id|return_VALUE
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
id|result
op_assign
id|acpi_bus_get_device
c_func
(paren
id|handle
comma
op_amp
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_ne
id|result
)paren
id|return_VALUE
c_func
(paren
id|result
)paren
suffix:semicolon
id|pr
op_assign
(paren
r_struct
id|acpi_processor
op_star
)paren
id|acpi_driver_data
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr
)paren
id|return_VALUE
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr-&gt;flags.limit
)paren
id|return_VALUE
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|ACPI_PROCESSOR_LIMIT_NONE
suffix:colon
op_star
id|state
op_assign
l_int|0
suffix:semicolon
id|pr-&gt;limit.state
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACPI_PROCESSOR_LIMIT_INCREMENT
suffix:colon
r_if
c_cond
(paren
op_star
id|state
op_eq
(paren
id|pr-&gt;limit.state_count
op_minus
l_int|1
)paren
)paren
(brace
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;Already at maximum limit state&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|return_VALUE
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
op_star
id|state
op_assign
op_increment
id|pr-&gt;limit.state
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACPI_PROCESSOR_LIMIT_DECREMENT
suffix:colon
r_if
c_cond
(paren
op_star
id|state
op_eq
l_int|0
)paren
(brace
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;Already at minimum limit state&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|return_VALUE
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
op_star
id|state
op_assign
op_decrement
id|pr-&gt;limit.state
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;Invalid limit type [%d]&bslash;n&quot;
comma
id|type
)paren
)paren
suffix:semicolon
op_star
id|state
op_assign
id|pr-&gt;limit.state
suffix:semicolon
id|return_VALUE
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pr-&gt;flags.performance
)paren
(brace
id|result
op_assign
id|acpi_processor_set_performance
c_func
(paren
id|pr
comma
id|pr-&gt;limit.states
(braket
op_star
id|state
)braket
dot
id|px
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_ne
id|result
)paren
r_goto
id|end
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pr-&gt;flags.throttling
)paren
(brace
id|result
op_assign
id|acpi_processor_set_throttling
c_func
(paren
id|pr
comma
id|pr-&gt;limit.states
(braket
op_star
id|state
)braket
dot
id|tx
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_ne
id|result
)paren
r_goto
id|end
suffix:semicolon
)brace
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;Processor [%d] limit now %d%% (P%d:T%d)&bslash;n&quot;
comma
id|pr-&gt;id
comma
id|pr-&gt;limit.states
(braket
op_star
id|state
)braket
dot
id|performance
op_div
l_int|10
comma
id|pr-&gt;limit.states
(braket
op_star
id|state
)braket
dot
id|px
comma
id|pr-&gt;limit.states
(braket
op_star
id|state
)braket
dot
id|tx
)paren
)paren
suffix:semicolon
id|end
suffix:colon
r_if
c_cond
(paren
l_int|0
op_ne
id|result
)paren
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;Unable to set limit&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|return_VALUE
c_func
(paren
id|result
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|acpi_processor_get_limit_info
id|acpi_processor_get_limit_info
(paren
r_struct
id|acpi_processor
op_star
id|pr
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|px
op_assign
l_int|0
suffix:semicolon
r_int
id|tx
op_assign
l_int|0
suffix:semicolon
r_int
id|base_perf
op_assign
l_int|1000
suffix:semicolon
r_int
id|throttle
op_assign
l_int|0
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_get_limit_info&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr
)paren
id|return_VALUE
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Limit&n;&t; * -----&n;&t; * Our default policy is to only use throttling at the lowest&n;&t; * performance state.  This is enforced by adding throttling states &n;&t; * after perormance states.  We also only expose throttling states &n;&t; * less than the maximum throttle value (e.g. 50%).&n;&t; */
r_if
c_cond
(paren
id|pr-&gt;flags.performance
)paren
(brace
r_for
c_loop
(paren
id|px
op_assign
l_int|0
suffix:semicolon
id|px
OL
id|pr-&gt;performance.state_count
suffix:semicolon
id|px
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pr-&gt;performance.states
(braket
id|px
)braket
dot
id|valid
)paren
r_continue
suffix:semicolon
id|i
op_assign
id|pr-&gt;limit.state_count
op_increment
suffix:semicolon
id|pr-&gt;limit.states
(braket
id|i
)braket
dot
id|px
op_assign
id|px
suffix:semicolon
id|pr-&gt;limit.states
(braket
id|i
)braket
dot
id|performance
op_assign
(paren
id|pr-&gt;performance.states
(braket
id|px
)braket
dot
id|core_frequency
op_div
id|pr-&gt;performance.states
(braket
l_int|0
)braket
dot
id|core_frequency
)paren
op_star
l_int|1000
suffix:semicolon
id|pr-&gt;limit.states
(braket
id|i
)braket
dot
id|valid
op_assign
l_int|1
suffix:semicolon
)brace
id|px
op_decrement
suffix:semicolon
id|base_perf
op_assign
id|pr-&gt;limit.states
(braket
id|i
)braket
dot
id|performance
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pr-&gt;flags.throttling
)paren
(brace
r_for
c_loop
(paren
id|tx
op_assign
l_int|0
suffix:semicolon
id|tx
OL
id|pr-&gt;throttling.state_count
suffix:semicolon
id|tx
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pr-&gt;throttling.states
(braket
id|tx
)braket
dot
id|valid
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pr-&gt;throttling.states
(braket
id|tx
)braket
dot
id|performance
OG
id|ACPI_PROCESSOR_MAX_THROTTLE
)paren
r_continue
suffix:semicolon
id|i
op_assign
id|pr-&gt;limit.state_count
op_increment
suffix:semicolon
id|pr-&gt;limit.states
(braket
id|i
)braket
dot
id|px
op_assign
id|px
suffix:semicolon
id|pr-&gt;limit.states
(braket
id|i
)braket
dot
id|tx
op_assign
id|tx
suffix:semicolon
id|throttle
op_assign
(paren
id|base_perf
op_star
id|pr-&gt;throttling.states
(braket
id|tx
)braket
dot
id|performance
)paren
op_div
l_int|1000
suffix:semicolon
id|pr-&gt;limit.states
(braket
id|i
)braket
dot
id|performance
op_assign
id|base_perf
op_minus
id|throttle
suffix:semicolon
id|pr-&gt;limit.states
(braket
id|i
)braket
dot
id|valid
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;Found %d limit states&bslash;n&quot;
comma
id|pr-&gt;limit.state_count
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pr-&gt;limit.state_count
)paren
id|pr-&gt;flags.limit
op_assign
l_int|1
suffix:semicolon
id|return_VALUE
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------------&n;                              FS Interface (/proc)&n;   -------------------------------------------------------------------------- */
macro_line|#include &lt;linux/compatmac.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
DECL|variable|acpi_processor_dir
r_struct
id|proc_dir_entry
op_star
id|acpi_processor_dir
op_assign
l_int|NULL
suffix:semicolon
r_static
r_int
DECL|function|acpi_processor_read_info
id|acpi_processor_read_info
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|acpi_processor
op_star
id|pr
op_assign
(paren
r_struct
id|acpi_processor
op_star
)paren
id|data
suffix:semicolon
r_char
op_star
id|p
op_assign
id|page
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_read_info&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr
op_logical_or
(paren
id|off
op_ne
l_int|0
)paren
)paren
r_goto
id|end
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;processor id:            %d&bslash;n&quot;
comma
id|pr-&gt;id
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;acpi id:                 %d&bslash;n&quot;
comma
id|pr-&gt;acpi_id
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;bus mastering control:   %s&bslash;n&quot;
comma
id|pr-&gt;flags.bm_control
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;power management:        %s&bslash;n&quot;
comma
id|pr-&gt;flags.power
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;throttling control:      %s&bslash;n&quot;
comma
id|pr-&gt;flags.throttling
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;performance management:  %s&bslash;n&quot;
comma
id|pr-&gt;flags.performance
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;limit interface:         %s&bslash;n&quot;
comma
id|pr-&gt;flags.limit
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
)paren
suffix:semicolon
id|end
suffix:colon
id|len
op_assign
(paren
id|p
op_minus
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
id|off
op_plus
id|count
)paren
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
op_star
id|start
op_assign
id|page
op_plus
id|off
suffix:semicolon
id|len
op_sub_assign
id|off
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|count
)paren
id|len
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
l_int|0
suffix:semicolon
id|return_VALUE
c_func
(paren
id|len
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|acpi_processor_read_power
id|acpi_processor_read_power
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|acpi_processor
op_star
id|pr
op_assign
(paren
r_struct
id|acpi_processor
op_star
)paren
id|data
suffix:semicolon
r_char
op_star
id|p
op_assign
id|page
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_read_power&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr
op_logical_or
(paren
id|off
op_ne
l_int|0
)paren
)paren
r_goto
id|end
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;active state:            C%d&bslash;n&quot;
comma
id|pr-&gt;power.state
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;default state:           C%d&bslash;n&quot;
comma
id|pr-&gt;power.default_state
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;bus master activity:     %08x&bslash;n&quot;
comma
id|pr-&gt;power.bm_activity
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;states:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|ACPI_C_STATE_COUNT
suffix:semicolon
id|i
op_increment
)paren
(brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;   %cC%d:                  &quot;
comma
(paren
id|i
op_eq
id|pr-&gt;power.state
ques
c_cond
l_char|&squot;*&squot;
suffix:colon
l_char|&squot; &squot;
)paren
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr-&gt;power.states
(braket
id|i
)braket
dot
id|valid
)paren
(brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&lt;not supported&gt;&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pr-&gt;power.states
(braket
id|i
)braket
dot
id|promotion.state
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;promotion[C%d] &quot;
comma
id|pr-&gt;power.states
(braket
id|i
)braket
dot
id|promotion.state
)paren
suffix:semicolon
r_else
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;promotion[--] &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pr-&gt;power.states
(braket
id|i
)braket
dot
id|demotion.state
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;demotion[C%d] &quot;
comma
id|pr-&gt;power.states
(braket
id|i
)braket
dot
id|demotion.state
)paren
suffix:semicolon
r_else
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;demotion[--] &quot;
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;latency[%03d] usage[%08d]&bslash;n&quot;
comma
id|pr-&gt;power.states
(braket
id|i
)braket
dot
id|latency
comma
id|pr-&gt;power.states
(braket
id|i
)braket
dot
id|usage
)paren
suffix:semicolon
)brace
id|end
suffix:colon
id|len
op_assign
(paren
id|p
op_minus
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
id|off
op_plus
id|count
)paren
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
op_star
id|start
op_assign
id|page
op_plus
id|off
suffix:semicolon
id|len
op_sub_assign
id|off
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|count
)paren
id|len
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
l_int|0
suffix:semicolon
id|return_VALUE
c_func
(paren
id|len
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|acpi_processor_read_performance
id|acpi_processor_read_performance
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|acpi_processor
op_star
id|pr
op_assign
(paren
r_struct
id|acpi_processor
op_star
)paren
id|data
suffix:semicolon
r_char
op_star
id|p
op_assign
id|page
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_read_performance&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr
op_logical_or
(paren
id|off
op_ne
l_int|0
)paren
)paren
r_goto
id|end
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr-&gt;flags.performance
)paren
(brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&lt;not supported&gt;&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|end
suffix:semicolon
)brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;state count:             %d&bslash;n&quot;
comma
id|pr-&gt;performance.state_count
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;active state:            P%d&bslash;n&quot;
comma
id|pr-&gt;performance.state
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;states:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pr-&gt;performance.state_count
suffix:semicolon
id|i
op_increment
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;   %cP%d:                %d Mhz, %d mW %s&bslash;n&quot;
comma
(paren
id|i
op_eq
id|pr-&gt;performance.state
ques
c_cond
l_char|&squot;*&squot;
suffix:colon
l_char|&squot; &squot;
)paren
comma
id|i
comma
id|pr-&gt;performance.states
(braket
id|i
)braket
dot
id|core_frequency
comma
id|pr-&gt;performance.states
(braket
id|i
)braket
dot
id|power
comma
(paren
id|pr-&gt;performance.states
(braket
id|i
)braket
dot
id|valid
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;(disabled)&quot;
)paren
)paren
suffix:semicolon
id|end
suffix:colon
id|len
op_assign
(paren
id|p
op_minus
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
id|off
op_plus
id|count
)paren
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
op_star
id|start
op_assign
id|page
op_plus
id|off
suffix:semicolon
id|len
op_sub_assign
id|off
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|count
)paren
id|len
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
l_int|0
suffix:semicolon
id|return_VALUE
c_func
(paren
id|len
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|acpi_processor_write_performance
id|acpi_processor_write_performance
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
r_int
id|count
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_struct
id|acpi_processor
op_star
id|pr
op_assign
(paren
r_struct
id|acpi_processor
op_star
)paren
id|data
suffix:semicolon
r_char
id|state_string
(braket
l_int|12
)braket
op_assign
(brace
l_char|&squot;&bslash;0&squot;
)brace
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_write_performance&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr
op_logical_or
(paren
id|count
OG
r_sizeof
(paren
id|state_string
)paren
op_minus
l_int|1
)paren
)paren
id|return_VALUE
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|state_string
comma
id|buffer
comma
id|count
)paren
)paren
id|return_VALUE
c_func
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
id|state_string
(braket
id|count
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|result
op_assign
id|acpi_processor_set_throttling
c_func
(paren
id|pr
comma
id|simple_strtoul
c_func
(paren
id|state_string
comma
l_int|NULL
comma
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_ne
id|result
)paren
id|return_VALUE
c_func
(paren
id|result
)paren
suffix:semicolon
id|return_VALUE
c_func
(paren
id|count
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|acpi_processor_read_throttling
id|acpi_processor_read_throttling
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|acpi_processor
op_star
id|pr
op_assign
(paren
r_struct
id|acpi_processor
op_star
)paren
id|data
suffix:semicolon
r_char
op_star
id|p
op_assign
id|page
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_read_throttling&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr
op_logical_or
(paren
id|off
op_ne
l_int|0
)paren
)paren
r_goto
id|end
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pr-&gt;throttling.state_count
OG
l_int|0
)paren
)paren
(brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&lt;not supported&gt;&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|end
suffix:semicolon
)brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;state count:             %d&bslash;n&quot;
comma
id|pr-&gt;throttling.state_count
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;active state:            T%d&bslash;n&quot;
comma
id|pr-&gt;throttling.state
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;states:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pr-&gt;throttling.state_count
suffix:semicolon
id|i
op_increment
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;   %cT%d:                  %02d%% %s&bslash;n&quot;
comma
(paren
id|i
op_eq
id|pr-&gt;throttling.state
ques
c_cond
l_char|&squot;*&squot;
suffix:colon
l_char|&squot; &squot;
)paren
comma
id|i
comma
(paren
id|pr-&gt;throttling.states
(braket
id|i
)braket
dot
id|performance
ques
c_cond
id|pr-&gt;throttling.states
(braket
id|i
)braket
dot
id|performance
op_div
l_int|10
suffix:colon
l_int|0
)paren
comma
(paren
id|pr-&gt;throttling.states
(braket
id|i
)braket
dot
id|valid
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;(disabled)&quot;
)paren
)paren
suffix:semicolon
id|end
suffix:colon
id|len
op_assign
(paren
id|p
op_minus
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
id|off
op_plus
id|count
)paren
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
op_star
id|start
op_assign
id|page
op_plus
id|off
suffix:semicolon
id|len
op_sub_assign
id|off
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|count
)paren
id|len
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
l_int|0
suffix:semicolon
id|return_VALUE
c_func
(paren
id|len
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|acpi_processor_write_throttling
id|acpi_processor_write_throttling
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
r_int
id|count
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_struct
id|acpi_processor
op_star
id|pr
op_assign
(paren
r_struct
id|acpi_processor
op_star
)paren
id|data
suffix:semicolon
r_char
id|state_string
(braket
l_int|12
)braket
op_assign
(brace
l_char|&squot;&bslash;0&squot;
)brace
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_write_throttling&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr
op_logical_or
(paren
id|count
OG
r_sizeof
(paren
id|state_string
)paren
op_minus
l_int|1
)paren
)paren
id|return_VALUE
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|state_string
comma
id|buffer
comma
id|count
)paren
)paren
id|return_VALUE
c_func
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
id|state_string
(braket
id|count
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|result
op_assign
id|acpi_processor_set_throttling
c_func
(paren
id|pr
comma
id|simple_strtoul
c_func
(paren
id|state_string
comma
l_int|NULL
comma
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_ne
id|result
)paren
id|return_VALUE
c_func
(paren
id|result
)paren
suffix:semicolon
id|return_VALUE
c_func
(paren
id|count
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|acpi_processor_read_limit
id|acpi_processor_read_limit
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|acpi_processor
op_star
id|pr
op_assign
(paren
r_struct
id|acpi_processor
op_star
)paren
id|data
suffix:semicolon
r_char
op_star
id|p
op_assign
id|page
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_read_limit&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr
op_logical_or
(paren
id|off
op_ne
l_int|0
)paren
)paren
r_goto
id|end
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr-&gt;flags.limit
)paren
(brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&lt;not supported&gt;&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|end
suffix:semicolon
)brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;state count:             %d&bslash;n&quot;
comma
id|pr-&gt;limit.state_count
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;active state:            L%d&bslash;n&quot;
comma
id|pr-&gt;limit.state
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;states:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pr-&gt;limit.state_count
suffix:semicolon
id|i
op_increment
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;   %cL%d:                  %02d%% [P%d:T%d] %s&bslash;n&quot;
comma
(paren
id|i
op_eq
id|pr-&gt;limit.state
ques
c_cond
l_char|&squot;*&squot;
suffix:colon
l_char|&squot; &squot;
)paren
comma
id|i
comma
id|pr-&gt;limit.states
(braket
id|i
)braket
dot
id|performance
op_div
l_int|10
comma
id|pr-&gt;limit.states
(braket
id|i
)braket
dot
id|px
comma
id|pr-&gt;limit.states
(braket
id|i
)braket
dot
id|tx
comma
id|pr-&gt;limit.states
(braket
id|i
)braket
dot
id|valid
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;(disabled)&quot;
)paren
suffix:semicolon
id|end
suffix:colon
id|len
op_assign
(paren
id|p
op_minus
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
id|off
op_plus
id|count
)paren
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
op_star
id|start
op_assign
id|page
op_plus
id|off
suffix:semicolon
id|len
op_sub_assign
id|off
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|count
)paren
id|len
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
l_int|0
suffix:semicolon
id|return_VALUE
c_func
(paren
id|len
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|acpi_processor_write_limit
id|acpi_processor_write_limit
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
r_int
id|count
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_struct
id|acpi_processor
op_star
id|pr
op_assign
(paren
r_struct
id|acpi_processor
op_star
)paren
id|data
suffix:semicolon
r_char
id|limit_string
(braket
l_int|12
)braket
op_assign
(brace
l_char|&squot;&bslash;0&squot;
)brace
suffix:semicolon
r_int
id|limit
op_assign
l_int|0
suffix:semicolon
r_int
id|state
op_assign
l_int|0
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_write_limit&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr
op_logical_or
(paren
id|count
OG
r_sizeof
(paren
id|limit_string
)paren
op_minus
l_int|1
)paren
)paren
id|return_VALUE
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|limit_string
comma
id|buffer
comma
id|count
)paren
)paren
id|return_VALUE
c_func
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
id|limit_string
(braket
id|count
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|limit
op_assign
id|simple_strtoul
c_func
(paren
id|limit_string
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|result
op_assign
id|acpi_processor_set_limit
c_func
(paren
id|pr-&gt;handle
comma
id|limit
comma
op_amp
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_ne
id|result
)paren
id|return_VALUE
c_func
(paren
id|result
)paren
suffix:semicolon
id|return_VALUE
c_func
(paren
id|count
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|acpi_processor_add_fs
id|acpi_processor_add_fs
(paren
r_struct
id|acpi_device
op_star
id|device
)paren
(brace
r_struct
id|proc_dir_entry
op_star
id|entry
op_assign
l_int|NULL
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_add_fs&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acpi_processor_dir
)paren
(brace
id|acpi_processor_dir
op_assign
id|proc_mkdir
c_func
(paren
id|ACPI_PROCESSOR_CLASS
comma
id|acpi_root_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acpi_processor_dir
)paren
id|return_VALUE
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|acpi_device_dir
c_func
(paren
id|device
)paren
)paren
(brace
id|acpi_device_dir
c_func
(paren
id|device
)paren
op_assign
id|proc_mkdir
c_func
(paren
id|acpi_device_bid
c_func
(paren
id|device
)paren
comma
id|acpi_processor_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acpi_device_dir
c_func
(paren
id|device
)paren
)paren
id|return_VALUE
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
multiline_comment|/* &squot;info&squot; [R] */
id|entry
op_assign
id|create_proc_entry
c_func
(paren
id|ACPI_PROCESSOR_FILE_INFO
comma
id|S_IRUGO
comma
id|acpi_device_dir
c_func
(paren
id|device
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;Unable to create &squot;%s&squot; fs entry&bslash;n&quot;
comma
id|ACPI_PROCESSOR_FILE_INFO
)paren
)paren
suffix:semicolon
r_else
(brace
id|entry-&gt;read_proc
op_assign
id|acpi_processor_read_info
suffix:semicolon
id|entry-&gt;data
op_assign
id|acpi_driver_data
c_func
(paren
id|device
)paren
suffix:semicolon
)brace
multiline_comment|/* &squot;power&squot; [R] */
id|entry
op_assign
id|create_proc_entry
c_func
(paren
id|ACPI_PROCESSOR_FILE_POWER
comma
id|S_IRUGO
comma
id|acpi_device_dir
c_func
(paren
id|device
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;Unable to create &squot;%s&squot; fs entry&bslash;n&quot;
comma
id|ACPI_PROCESSOR_FILE_POWER
)paren
)paren
suffix:semicolon
r_else
(brace
id|entry-&gt;read_proc
op_assign
id|acpi_processor_read_power
suffix:semicolon
id|entry-&gt;data
op_assign
id|acpi_driver_data
c_func
(paren
id|device
)paren
suffix:semicolon
)brace
multiline_comment|/* &squot;performance&squot; [R/W] */
id|entry
op_assign
id|create_proc_entry
c_func
(paren
id|ACPI_PROCESSOR_FILE_PERFORMANCE
comma
id|S_IFREG
op_or
id|S_IRUGO
op_or
id|S_IWUSR
comma
id|acpi_device_dir
c_func
(paren
id|device
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;Unable to create &squot;%s&squot; fs entry&bslash;n&quot;
comma
id|ACPI_PROCESSOR_FILE_PERFORMANCE
)paren
)paren
suffix:semicolon
r_else
(brace
id|entry-&gt;read_proc
op_assign
id|acpi_processor_read_performance
suffix:semicolon
id|entry-&gt;write_proc
op_assign
id|acpi_processor_write_performance
suffix:semicolon
id|entry-&gt;data
op_assign
id|acpi_driver_data
c_func
(paren
id|device
)paren
suffix:semicolon
)brace
multiline_comment|/* &squot;throttling&squot; [R/W] */
id|entry
op_assign
id|create_proc_entry
c_func
(paren
id|ACPI_PROCESSOR_FILE_THROTTLING
comma
id|S_IFREG
op_or
id|S_IRUGO
op_or
id|S_IWUSR
comma
id|acpi_device_dir
c_func
(paren
id|device
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;Unable to create &squot;%s&squot; fs entry&bslash;n&quot;
comma
id|ACPI_PROCESSOR_FILE_THROTTLING
)paren
)paren
suffix:semicolon
r_else
(brace
id|entry-&gt;read_proc
op_assign
id|acpi_processor_read_throttling
suffix:semicolon
id|entry-&gt;write_proc
op_assign
id|acpi_processor_write_throttling
suffix:semicolon
id|entry-&gt;data
op_assign
id|acpi_driver_data
c_func
(paren
id|device
)paren
suffix:semicolon
)brace
multiline_comment|/* &squot;thermal_limit&squot; [R/W] */
id|entry
op_assign
id|create_proc_entry
c_func
(paren
id|ACPI_PROCESSOR_FILE_LIMIT
comma
id|S_IFREG
op_or
id|S_IRUGO
op_or
id|S_IWUSR
comma
id|acpi_device_dir
c_func
(paren
id|device
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;Unable to create &squot;%s&squot; fs entry&bslash;n&quot;
comma
id|ACPI_PROCESSOR_FILE_LIMIT
)paren
)paren
suffix:semicolon
r_else
(brace
id|entry-&gt;read_proc
op_assign
id|acpi_processor_read_limit
suffix:semicolon
id|entry-&gt;write_proc
op_assign
id|acpi_processor_write_limit
suffix:semicolon
id|entry-&gt;data
op_assign
id|acpi_driver_data
c_func
(paren
id|device
)paren
suffix:semicolon
)brace
id|return_VALUE
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|acpi_processor_remove_fs
id|acpi_processor_remove_fs
(paren
r_struct
id|acpi_device
op_star
id|device
)paren
(brace
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_remove_fs&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acpi_processor_dir
)paren
id|return_VALUE
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acpi_device_dir
c_func
(paren
id|device
)paren
)paren
id|remove_proc_entry
c_func
(paren
id|acpi_device_bid
c_func
(paren
id|device
)paren
comma
id|acpi_processor_dir
)paren
suffix:semicolon
id|return_VALUE
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------------&n;                                 Driver Interface&n;   -------------------------------------------------------------------------- */
r_static
r_int
DECL|function|acpi_processor_get_info
id|acpi_processor_get_info
(paren
r_struct
id|acpi_processor
op_star
id|pr
)paren
(brace
id|acpi_status
id|status
op_assign
l_int|0
suffix:semicolon
id|acpi_object
id|object
op_assign
(brace
l_int|0
)brace
suffix:semicolon
id|acpi_buffer
id|buffer
op_assign
(brace
r_sizeof
(paren
id|acpi_object
)paren
comma
op_amp
id|object
)brace
suffix:semicolon
r_static
r_int
id|cpu_count
op_assign
l_int|0
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_get_info&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr
)paren
id|return_VALUE
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_if
c_cond
(paren
id|smp_num_cpus
OG
l_int|1
)paren
id|acpi_processor_smp
op_assign
id|smp_num_cpus
suffix:semicolon
macro_line|#endif
id|acpi_processor_get_errata
c_func
(paren
id|pr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check to see if we have bus mastering arbitration control.  This&n;&t; * is required for proper C3 usage (to maintain cache coherency).&n;&t; */
r_if
c_cond
(paren
id|acpi_fadt.V1_pm2_cnt_blk
op_logical_and
id|acpi_fadt.pm2_cnt_len
)paren
(brace
id|pr-&gt;flags.bm_control
op_assign
l_int|1
suffix:semicolon
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;Bus mastering arbitration control present&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;No bus mastering arbitration control&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Evalute the processor object.  Note that it is common on SMP to&n;&t; * have the first (boot) processor with a valid PBLK address while&n;&t; * all others have a NULL address.&n;&t; */
id|status
op_assign
id|acpi_evaluate_object
c_func
(paren
id|pr-&gt;handle
comma
l_int|NULL
comma
l_int|NULL
comma
op_amp
id|buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
c_func
(paren
id|status
)paren
)paren
(brace
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;Error evaluating processor object&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|return_VALUE
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * TBD: Synch processor ID (via LAPIC/LSAPIC structures) on SMP.&n;&t; *&t;&gt;&gt;&gt; &squot;acpi_get_processor_id(acpi_id, &amp;id)&squot; in arch/xxx/acpi.c&n;&t; */
id|pr-&gt;id
op_assign
id|cpu_count
op_increment
suffix:semicolon
id|pr-&gt;acpi_id
op_assign
id|object.processor.proc_id
suffix:semicolon
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;Processor [%d:%d]&bslash;n&quot;
comma
id|pr-&gt;id
comma
id|pr-&gt;acpi_id
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|object.processor.pblk_address
)paren
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;No PBLK (NULL address)&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|object.processor.pblk_length
OL
l_int|6
)paren
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;Invalid PBLK length [%d]&bslash;n&quot;
comma
id|object.processor.pblk_length
)paren
)paren
suffix:semicolon
r_else
(brace
id|pr-&gt;throttling.address
op_assign
id|object.processor.pblk_address
suffix:semicolon
id|pr-&gt;throttling.duty_offset
op_assign
id|acpi_fadt.duty_offset
suffix:semicolon
id|pr-&gt;throttling.duty_width
op_assign
id|acpi_fadt.duty_width
suffix:semicolon
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C2
)braket
dot
id|address
op_assign
id|object.processor.pblk_address
op_plus
l_int|4
suffix:semicolon
id|pr-&gt;power.states
(braket
id|ACPI_STATE_C3
)braket
dot
id|address
op_assign
id|object.processor.pblk_address
op_plus
l_int|5
suffix:semicolon
)brace
id|acpi_processor_get_power_info
c_func
(paren
id|pr
)paren
suffix:semicolon
id|acpi_processor_get_performance_info
c_func
(paren
id|pr
)paren
suffix:semicolon
id|acpi_processor_get_throttling_info
c_func
(paren
id|pr
)paren
suffix:semicolon
id|acpi_processor_get_limit_info
c_func
(paren
id|pr
)paren
suffix:semicolon
id|return_VALUE
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|acpi_processor_notify
id|acpi_processor_notify
(paren
id|acpi_handle
id|handle
comma
id|u32
id|event
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|acpi_processor
op_star
id|pr
op_assign
(paren
r_struct
id|acpi_processor
op_star
)paren
id|data
suffix:semicolon
r_struct
id|acpi_device
op_star
id|device
op_assign
l_int|NULL
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_notify&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr
)paren
id|return_VOID
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_ne
id|acpi_bus_get_device
c_func
(paren
id|pr-&gt;handle
comma
op_amp
id|device
)paren
)paren
id|return_VOID
suffix:semicolon
r_switch
c_cond
(paren
id|event
)paren
(brace
r_case
id|ACPI_PROCESSOR_NOTIFY_PERFORMANCE
suffix:colon
r_case
id|ACPI_PROCESSOR_NOTIFY_POWER
suffix:colon
id|acpi_bus_generate_event
c_func
(paren
id|device
comma
id|event
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;Unsupported event [0x%x]&bslash;n&quot;
comma
id|event
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|return_VOID
suffix:semicolon
)brace
r_static
r_int
DECL|function|acpi_processor_add
id|acpi_processor_add
(paren
r_struct
id|acpi_device
op_star
id|device
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|acpi_status
id|status
op_assign
id|AE_OK
suffix:semicolon
r_struct
id|acpi_processor
op_star
id|pr
op_assign
l_int|NULL
suffix:semicolon
id|u32
id|i
op_assign
l_int|0
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_add&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device
)paren
id|return_VALUE
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
id|pr
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|acpi_processor
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pr
)paren
id|return_VALUE
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|memset
c_func
(paren
id|pr
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|acpi_processor
)paren
)paren
suffix:semicolon
id|pr-&gt;handle
op_assign
id|device-&gt;handle
suffix:semicolon
id|sprintf
c_func
(paren
id|acpi_device_name
c_func
(paren
id|device
)paren
comma
l_string|&quot;%s&quot;
comma
id|ACPI_PROCESSOR_DEVICE_NAME
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|acpi_device_class
c_func
(paren
id|device
)paren
comma
l_string|&quot;%s&quot;
comma
id|ACPI_PROCESSOR_CLASS
)paren
suffix:semicolon
id|acpi_driver_data
c_func
(paren
id|device
)paren
op_assign
id|pr
suffix:semicolon
id|result
op_assign
id|acpi_processor_get_info
c_func
(paren
id|pr
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_ne
id|result
)paren
r_goto
id|end
suffix:semicolon
id|result
op_assign
id|acpi_processor_add_fs
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_ne
id|result
)paren
r_goto
id|end
suffix:semicolon
multiline_comment|/*&n;&t; * TBD: Fix notify handler installation for processors.&n;&t; *&n;&t;status = acpi_install_notify_handler(pr-&gt;handle, ACPI_DEVICE_NOTIFY, &n;&t;&t;acpi_processor_notify, pr);&n;&t;if (ACPI_FAILURE(status)) {&n;&t;&t;ACPI_DEBUG_PRINT((ACPI_DB_ERROR, &n;&t;&t;&t;&quot;Error installing notify handler&bslash;n&quot;));&n;&t;&t;result = -ENODEV;&n;&t;&t;goto end;&n;&t;}&n;&t;*/
id|acpi_processor_list
(braket
id|pr-&gt;id
)braket
op_assign
id|pr
suffix:semicolon
multiline_comment|/*&n;&t; * Set Idle Handler&n;&t; * ----------------&n;&t; * Install the idle handler if power management (states other than C1)&n;&t; * is supported.  Note that the default idle handler (default_idle)&n;&t; * will be used on platforms that only support C1.&n;&t; */
r_if
c_cond
(paren
(paren
id|pr-&gt;id
op_eq
l_int|0
)paren
op_logical_and
(paren
id|pr-&gt;flags.power
)paren
)paren
(brace
id|pm_idle_save
op_assign
id|pm_idle
suffix:semicolon
id|pm_idle
op_assign
id|acpi_processor_idle
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
id|PREFIX
l_string|&quot;%s [%s] (supports&quot;
comma
id|acpi_device_name
c_func
(paren
id|device
)paren
comma
id|acpi_device_bid
c_func
(paren
id|device
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|ACPI_C_STATE_COUNT
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|pr-&gt;power.states
(braket
id|i
)braket
dot
id|valid
)paren
id|printk
c_func
(paren
l_string|&quot; C%d&quot;
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pr-&gt;flags.performance
)paren
id|printk
c_func
(paren
l_string|&quot;, %d performance states&quot;
comma
id|pr-&gt;performance.state_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pr-&gt;flags.throttling
)paren
id|printk
c_func
(paren
l_string|&quot;, %d throttling states&quot;
comma
id|pr-&gt;throttling.state_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pr-&gt;errata.piix4.bmisx
)paren
id|printk
c_func
(paren
l_string|&quot;, PIIX4 errata&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;)&bslash;n&quot;
)paren
suffix:semicolon
id|end
suffix:colon
r_if
c_cond
(paren
l_int|0
op_ne
id|result
)paren
(brace
id|acpi_processor_remove_fs
c_func
(paren
id|device
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pr
)paren
suffix:semicolon
)brace
id|return_VALUE
c_func
(paren
id|result
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|acpi_processor_remove
id|acpi_processor_remove
(paren
r_struct
id|acpi_device
op_star
id|device
comma
r_int
id|type
)paren
(brace
id|acpi_status
id|status
op_assign
id|AE_OK
suffix:semicolon
r_struct
id|acpi_processor
op_star
id|pr
op_assign
l_int|NULL
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_remove&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device
op_logical_or
op_logical_neg
id|acpi_driver_data
c_func
(paren
id|device
)paren
)paren
id|return_VALUE
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
id|pr
op_assign
(paren
r_struct
id|acpi_processor
op_star
)paren
id|acpi_driver_data
c_func
(paren
id|device
)paren
suffix:semicolon
multiline_comment|/*&n;&t;status = acpi_remove_notify_handler(pr-&gt;handle, ACPI_DEVICE_NOTIFY, &n;&t;&t;acpi_processor_notify);&n;&t;if (ACPI_FAILURE(status)) {&n;&t;&t;ACPI_DEBUG_PRINT((ACPI_DB_ERROR, &n;&t;&t;&t;&quot;Error removing notify handler&bslash;n&quot;));&n;&t;&t;return_VALUE(-ENODEV);&n;&t;}&n;&t;*/
multiline_comment|/* Unregister the idle handler when processor #0 is removed. */
r_if
c_cond
(paren
id|pr-&gt;id
op_eq
l_int|0
)paren
id|pm_idle
op_assign
id|pm_idle_save
suffix:semicolon
id|acpi_processor_remove_fs
c_func
(paren
id|device
)paren
suffix:semicolon
id|acpi_processor_list
(braket
id|pr-&gt;id
)braket
op_assign
l_int|NULL
suffix:semicolon
id|kfree
c_func
(paren
id|pr
)paren
suffix:semicolon
id|return_VALUE
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
id|__init
DECL|function|acpi_processor_init
id|acpi_processor_init
(paren
r_void
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_init&quot;
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|acpi_processor_list
comma
l_int|0
comma
r_sizeof
(paren
id|acpi_processor_list
)paren
)paren
suffix:semicolon
id|result
op_assign
id|acpi_bus_register_driver
c_func
(paren
op_amp
id|acpi_processor_driver
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
OG
id|result
)paren
id|return_VALUE
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
id|return_VALUE
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_void
id|__exit
DECL|function|acpi_processor_exit
id|acpi_processor_exit
(paren
r_void
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_processor_exit&quot;
)paren
suffix:semicolon
id|result
op_assign
id|acpi_bus_unregister_driver
c_func
(paren
op_amp
id|acpi_processor_driver
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_eq
id|result
)paren
id|remove_proc_entry
c_func
(paren
id|ACPI_PROCESSOR_CLASS
comma
id|acpi_root_dir
)paren
suffix:semicolon
id|return_VOID
suffix:semicolon
)brace
DECL|variable|acpi_processor_init
id|module_init
c_func
(paren
id|acpi_processor_init
)paren
suffix:semicolon
DECL|variable|acpi_processor_exit
id|module_exit
c_func
(paren
id|acpi_processor_exit
)paren
suffix:semicolon
eof
