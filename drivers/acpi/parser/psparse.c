multiline_comment|/******************************************************************************&n; *&n; * Module Name: psparse - Parser top level AML parse routines&n; *              $Revision: 127 $&n; *&n; *****************************************************************************/
multiline_comment|/*&n; *  Copyright (C) 2000 - 2002, R. Byron Moore&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
multiline_comment|/*&n; * Parse the AML and build an operation tree as most interpreters,&n; * like Perl, do.  Parsing is done by hand rather than with a YACC&n; * generated parser to tightly constrain stack and dynamic memory&n; * usage.  At the same time, parsing is kept flexible and the code&n; * fairly compact by parsing based on a list of AML opcode&n; * templates in Aml_op_info[]&n; */
macro_line|#include &quot;acpi.h&quot;
macro_line|#include &quot;acparser.h&quot;
macro_line|#include &quot;acdispat.h&quot;
macro_line|#include &quot;amlcode.h&quot;
macro_line|#include &quot;acnamesp.h&quot;
macro_line|#include &quot;acinterp.h&quot;
DECL|macro|_COMPONENT
mdefine_line|#define _COMPONENT          ACPI_PARSER
id|ACPI_MODULE_NAME
(paren
l_string|&quot;psparse&quot;
)paren
DECL|variable|acpi_gbl_depth
r_static
id|u32
id|acpi_gbl_depth
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ps_get_opcode_size&n; *&n; * PARAMETERS:  Opcode          - An AML opcode&n; *&n; * RETURN:      Size of the opcode, in bytes (1 or 2)&n; *&n; * DESCRIPTION: Get the size of the current opcode.&n; *&n; ******************************************************************************/
id|u32
DECL|function|acpi_ps_get_opcode_size
id|acpi_ps_get_opcode_size
(paren
id|u32
id|opcode
)paren
(brace
multiline_comment|/* Extended (2-byte) opcode if &gt; 255 */
r_if
c_cond
(paren
id|opcode
OG
l_int|0x00FF
)paren
(brace
r_return
(paren
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/* Otherwise, just a single byte opcode */
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ps_peek_opcode&n; *&n; * PARAMETERS:  Parser_state        - A parser state object&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Get next AML opcode (without incrementing AML pointer)&n; *&n; ******************************************************************************/
id|u16
DECL|function|acpi_ps_peek_opcode
id|acpi_ps_peek_opcode
(paren
id|acpi_parse_state
op_star
id|parser_state
)paren
(brace
id|u8
op_star
id|aml
suffix:semicolon
id|u16
id|opcode
suffix:semicolon
id|aml
op_assign
id|parser_state-&gt;aml
suffix:semicolon
id|opcode
op_assign
(paren
id|u16
)paren
id|ACPI_GET8
(paren
id|aml
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opcode
op_eq
id|AML_EXTOP
)paren
(brace
multiline_comment|/* Extended opcode */
id|aml
op_increment
suffix:semicolon
id|opcode
op_assign
(paren
id|u16
)paren
(paren
(paren
id|opcode
op_lshift
l_int|8
)paren
op_or
id|ACPI_GET8
(paren
id|aml
)paren
)paren
suffix:semicolon
)brace
r_return
(paren
id|opcode
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ps_find_object&n; *&n; * PARAMETERS:  Opcode          - Current opcode&n; *              Parser_state    - Current state&n; *              Walk_state      - Current state&n; *              *Op             - Where found/new op is returned&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Find a named object.  Two versions - one to search the parse&n; *              tree (for parser-only applications such as acpidump), another&n; *              to search the ACPI internal namespace (the parse tree may no&n; *              longer exist)&n; *&n; ******************************************************************************/
macro_line|#ifdef PARSER_ONLY
id|acpi_status
DECL|function|acpi_ps_find_object
id|acpi_ps_find_object
(paren
id|acpi_walk_state
op_star
id|walk_state
comma
id|acpi_parse_object
op_star
op_star
id|out_op
)paren
(brace
id|NATIVE_CHAR
op_star
id|path
suffix:semicolon
multiline_comment|/* We are only interested in opcodes that have an associated name */
r_if
c_cond
(paren
op_logical_neg
(paren
id|walk_state-&gt;op_info-&gt;flags
op_amp
id|AML_NAMED
)paren
)paren
(brace
op_star
id|out_op
op_assign
id|walk_state-&gt;op
suffix:semicolon
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* Find the name in the parse tree */
id|path
op_assign
id|acpi_ps_get_next_namestring
(paren
op_amp
id|walk_state-&gt;parser_state
)paren
suffix:semicolon
op_star
id|out_op
op_assign
id|acpi_ps_find
(paren
id|acpi_ps_get_parent_scope
(paren
op_amp
id|walk_state-&gt;parser_state
)paren
comma
id|path
comma
id|walk_state-&gt;opcode
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|out_op
)paren
)paren
(brace
r_return
(paren
id|AE_NOT_FOUND
)paren
suffix:semicolon
)brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ps_complete_this_op&n; *&n; * PARAMETERS:  Walk_state      - Current State&n; *              Op              - Op to complete&n; *&n; * RETURN:      None.&n; *&n; * DESCRIPTION: Perform any cleanup at the completion of an Op.&n; *&n; ******************************************************************************/
r_void
DECL|function|acpi_ps_complete_this_op
id|acpi_ps_complete_this_op
(paren
id|acpi_walk_state
op_star
id|walk_state
comma
id|acpi_parse_object
op_star
id|op
)paren
(brace
macro_line|#ifndef PARSER_ONLY
id|acpi_parse_object
op_star
id|prev
suffix:semicolon
id|acpi_parse_object
op_star
id|next
suffix:semicolon
r_const
id|acpi_opcode_info
op_star
id|parent_info
suffix:semicolon
id|acpi_parse_object
op_star
id|replacement_op
op_assign
l_int|NULL
suffix:semicolon
id|ACPI_FUNCTION_TRACE_PTR
(paren
l_string|&quot;Ps_complete_this_op&quot;
comma
id|op
)paren
suffix:semicolon
multiline_comment|/* Check for null Op, can happen if AML code is corrupt */
r_if
c_cond
(paren
op_logical_neg
id|op
)paren
(brace
id|return_VOID
suffix:semicolon
)brace
multiline_comment|/* Delete this op and the subtree below it if asked to */
r_if
c_cond
(paren
(paren
(paren
id|walk_state-&gt;parse_flags
op_amp
id|ACPI_PARSE_TREE_MASK
)paren
op_eq
id|ACPI_PARSE_DELETE_TREE
)paren
op_logical_and
(paren
id|walk_state-&gt;op_info
op_member_access_from_pointer
r_class
op_ne
id|AML_CLASS_ARGUMENT
)paren
)paren
(brace
multiline_comment|/* Make sure that we only delete this subtree */
r_if
c_cond
(paren
id|op-&gt;common.parent
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Check if we need to replace the operator and its subtree&n;&t;&t;&t; * with a return value op (placeholder op)&n;&t;&t;&t; */
id|parent_info
op_assign
id|acpi_ps_get_opcode_info
(paren
id|op-&gt;common.parent-&gt;common.aml_opcode
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|parent_info
op_member_access_from_pointer
r_class
)paren
(brace
r_case
id|AML_CLASS_CONTROL
suffix:colon
r_break
suffix:semicolon
r_case
id|AML_CLASS_CREATE
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * These opcodes contain Term_arg operands. The current&n;&t;&t;&t;&t; * op must be replaced by a placeholder return op&n;&t;&t;&t;&t; */
id|replacement_op
op_assign
id|acpi_ps_alloc_op
(paren
id|AML_INT_RETURN_VALUE_OP
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|replacement_op
)paren
(brace
id|return_VOID
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AML_CLASS_NAMED_OBJECT
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * These opcodes contain Term_arg operands. The current&n;&t;&t;&t;&t; * op must be replaced by a placeholder return op&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|op-&gt;common.parent-&gt;common.aml_opcode
op_eq
id|AML_REGION_OP
)paren
op_logical_or
(paren
id|op-&gt;common.parent-&gt;common.aml_opcode
op_eq
id|AML_DATA_REGION_OP
)paren
op_logical_or
(paren
id|op-&gt;common.parent-&gt;common.aml_opcode
op_eq
id|AML_BUFFER_OP
)paren
op_logical_or
(paren
id|op-&gt;common.parent-&gt;common.aml_opcode
op_eq
id|AML_PACKAGE_OP
)paren
op_logical_or
(paren
id|op-&gt;common.parent-&gt;common.aml_opcode
op_eq
id|AML_VAR_PACKAGE_OP
)paren
)paren
(brace
id|replacement_op
op_assign
id|acpi_ps_alloc_op
(paren
id|AML_INT_RETURN_VALUE_OP
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|replacement_op
)paren
(brace
id|return_VOID
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|op-&gt;common.parent-&gt;common.aml_opcode
op_eq
id|AML_NAME_OP
)paren
op_logical_and
(paren
id|walk_state-&gt;descending_callback
op_ne
id|acpi_ds_exec_begin_op
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|op-&gt;common.aml_opcode
op_eq
id|AML_BUFFER_OP
)paren
op_logical_or
(paren
id|op-&gt;common.aml_opcode
op_eq
id|AML_PACKAGE_OP
)paren
op_logical_or
(paren
id|op-&gt;common.aml_opcode
op_eq
id|AML_VAR_PACKAGE_OP
)paren
)paren
(brace
id|replacement_op
op_assign
id|acpi_ps_alloc_op
(paren
id|op-&gt;common.aml_opcode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|replacement_op
)paren
(brace
id|return_VOID
suffix:semicolon
)brace
id|replacement_op-&gt;named.data
op_assign
id|op-&gt;named.data
suffix:semicolon
id|replacement_op-&gt;named.length
op_assign
id|op-&gt;named.length
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|replacement_op
op_assign
id|acpi_ps_alloc_op
(paren
id|AML_INT_RETURN_VALUE_OP
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|replacement_op
)paren
(brace
id|return_VOID
suffix:semicolon
)brace
)brace
multiline_comment|/* We must unlink this op from the parent tree */
id|prev
op_assign
id|op-&gt;common.parent-&gt;common.value.arg
suffix:semicolon
r_if
c_cond
(paren
id|prev
op_eq
id|op
)paren
(brace
multiline_comment|/* This op is the first in the list */
r_if
c_cond
(paren
id|replacement_op
)paren
(brace
id|replacement_op-&gt;common.parent
op_assign
id|op-&gt;common.parent
suffix:semicolon
id|replacement_op-&gt;common.value.arg
op_assign
l_int|NULL
suffix:semicolon
id|replacement_op-&gt;common.node
op_assign
id|op-&gt;common.node
suffix:semicolon
id|op-&gt;common.parent-&gt;common.value.arg
op_assign
id|replacement_op
suffix:semicolon
id|replacement_op-&gt;common.next
op_assign
id|op-&gt;common.next
suffix:semicolon
)brace
r_else
(brace
id|op-&gt;common.parent-&gt;common.value.arg
op_assign
id|op-&gt;common.next
suffix:semicolon
)brace
)brace
multiline_comment|/* Search the parent list */
r_else
r_while
c_loop
(paren
id|prev
)paren
(brace
multiline_comment|/* Traverse all siblings in the parent&squot;s argument list */
id|next
op_assign
id|prev-&gt;common.next
suffix:semicolon
r_if
c_cond
(paren
id|next
op_eq
id|op
)paren
(brace
r_if
c_cond
(paren
id|replacement_op
)paren
(brace
id|replacement_op-&gt;common.parent
op_assign
id|op-&gt;common.parent
suffix:semicolon
id|replacement_op-&gt;common.value.arg
op_assign
l_int|NULL
suffix:semicolon
id|replacement_op-&gt;common.node
op_assign
id|op-&gt;common.node
suffix:semicolon
id|prev-&gt;common.next
op_assign
id|replacement_op
suffix:semicolon
id|replacement_op-&gt;common.next
op_assign
id|op-&gt;common.next
suffix:semicolon
id|next
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|prev-&gt;common.next
op_assign
id|op-&gt;common.next
suffix:semicolon
id|next
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|prev
op_assign
id|next
suffix:semicolon
)brace
)brace
multiline_comment|/* Now we can actually delete the subtree rooted at op */
id|acpi_ps_delete_parse_tree
(paren
id|op
)paren
suffix:semicolon
id|return_VOID
suffix:semicolon
)brace
id|return_VOID
suffix:semicolon
macro_line|#else
r_return
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ps_next_parse_state&n; *&n; * PARAMETERS:  Parser_state        - Current parser state object&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Update the parser state based upon the return exception from&n; *              the parser callback.&n; *&n; ******************************************************************************/
id|acpi_status
DECL|function|acpi_ps_next_parse_state
id|acpi_ps_next_parse_state
(paren
id|acpi_walk_state
op_star
id|walk_state
comma
id|acpi_parse_object
op_star
id|op
comma
id|acpi_status
id|callback_status
)paren
(brace
id|acpi_parse_state
op_star
id|parser_state
op_assign
op_amp
id|walk_state-&gt;parser_state
suffix:semicolon
id|acpi_status
id|status
op_assign
id|AE_CTRL_PENDING
suffix:semicolon
id|ACPI_FUNCTION_TRACE_PTR
(paren
l_string|&quot;Ps_next_parse_state&quot;
comma
id|op
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|callback_status
)paren
(brace
r_case
id|AE_CTRL_TERMINATE
suffix:colon
multiline_comment|/*&n;&t;&t; * A control method was terminated via a RETURN statement.&n;&t;&t; * The walk of this method is complete.&n;&t;&t; */
id|parser_state-&gt;aml
op_assign
id|parser_state-&gt;aml_end
suffix:semicolon
id|status
op_assign
id|AE_CTRL_TERMINATE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AE_CTRL_BREAK
suffix:colon
id|parser_state-&gt;aml
op_assign
id|walk_state-&gt;aml_last_while
suffix:semicolon
id|walk_state-&gt;control_state-&gt;common.value
op_assign
id|FALSE
suffix:semicolon
id|status
op_assign
id|AE_CTRL_BREAK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AE_CTRL_CONTINUE
suffix:colon
id|parser_state-&gt;aml
op_assign
id|walk_state-&gt;aml_last_while
suffix:semicolon
id|status
op_assign
id|AE_CTRL_CONTINUE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AE_CTRL_PENDING
suffix:colon
id|parser_state-&gt;aml
op_assign
id|walk_state-&gt;aml_last_while
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AE_CTRL_TRUE
suffix:colon
multiline_comment|/*&n;&t;&t; * Predicate of an IF was true, and we are at the matching ELSE.&n;&t;&t; * Just close out this package&n;&t;&t; */
id|parser_state-&gt;aml
op_assign
id|acpi_ps_get_next_package_end
(paren
id|parser_state
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AE_CTRL_FALSE
suffix:colon
multiline_comment|/*&n;&t;&t; * Either an IF/WHILE Predicate was false or we encountered a BREAK&n;&t;&t; * opcode.  In both cases, we do not execute the rest of the&n;&t;&t; * package;  We simply close out the parent (finishing the walk of&n;&t;&t; * this branch of the tree) and continue execution at the parent&n;&t;&t; * level.&n;&t;&t; */
id|parser_state-&gt;aml
op_assign
id|parser_state-&gt;scope-&gt;parse_scope.pkg_end
suffix:semicolon
multiline_comment|/* In the case of a BREAK, just force a predicate (if any) to FALSE */
id|walk_state-&gt;control_state-&gt;common.value
op_assign
id|FALSE
suffix:semicolon
id|status
op_assign
id|AE_CTRL_END
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AE_CTRL_TRANSFER
suffix:colon
multiline_comment|/*&n;&t;&t; * A method call (invocation) -- transfer control&n;&t;&t; */
id|status
op_assign
id|AE_CTRL_TRANSFER
suffix:semicolon
id|walk_state-&gt;prev_op
op_assign
id|op
suffix:semicolon
id|walk_state-&gt;method_call_op
op_assign
id|op
suffix:semicolon
id|walk_state-&gt;method_call_node
op_assign
(paren
id|op-&gt;common.value.arg
)paren
op_member_access_from_pointer
id|common.node
suffix:semicolon
multiline_comment|/* Will return value (if any) be used by the caller? */
id|walk_state-&gt;return_used
op_assign
id|acpi_ds_is_result_used
(paren
id|op
comma
id|walk_state
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|status
op_assign
id|callback_status
suffix:semicolon
r_if
c_cond
(paren
(paren
id|callback_status
op_amp
id|AE_CODE_MASK
)paren
op_eq
id|AE_CODE_CONTROL
)paren
(brace
id|status
op_assign
id|AE_OK
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ps_parse_loop&n; *&n; * PARAMETERS:  Parser_state        - Current parser state object&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Parse AML (pointed to by the current parser state) and return&n; *              a tree of ops.&n; *&n; ******************************************************************************/
id|acpi_status
DECL|function|acpi_ps_parse_loop
id|acpi_ps_parse_loop
(paren
id|acpi_walk_state
op_star
id|walk_state
)paren
(brace
id|acpi_status
id|status
op_assign
id|AE_OK
suffix:semicolon
id|acpi_parse_object
op_star
id|op
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* current op */
id|acpi_parse_object
op_star
id|arg
op_assign
l_int|NULL
suffix:semicolon
id|acpi_parse_object
id|pre_op
suffix:semicolon
id|acpi_parse_state
op_star
id|parser_state
suffix:semicolon
id|u8
op_star
id|aml_op_start
op_assign
l_int|NULL
suffix:semicolon
id|ACPI_FUNCTION_TRACE_PTR
(paren
l_string|&quot;Ps_parse_loop&quot;
comma
id|walk_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|walk_state-&gt;descending_callback
op_eq
l_int|NULL
)paren
(brace
id|return_ACPI_STATUS
(paren
id|AE_BAD_PARAMETER
)paren
suffix:semicolon
)brace
id|parser_state
op_assign
op_amp
id|walk_state-&gt;parser_state
suffix:semicolon
id|walk_state-&gt;arg_types
op_assign
l_int|0
suffix:semicolon
macro_line|#ifndef PARSER_ONLY
r_if
c_cond
(paren
id|walk_state-&gt;walk_type
op_amp
id|ACPI_WALK_METHOD_RESTART
)paren
(brace
multiline_comment|/* We are restarting a preempted control method */
r_if
c_cond
(paren
id|acpi_ps_has_completed_scope
(paren
id|parser_state
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We must check if a predicate to an IF or WHILE statement&n;&t;&t;&t; * was just completed&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|parser_state-&gt;scope-&gt;parse_scope.op
)paren
op_logical_and
(paren
(paren
id|parser_state-&gt;scope-&gt;parse_scope.op-&gt;common.aml_opcode
op_eq
id|AML_IF_OP
)paren
op_logical_or
(paren
id|parser_state-&gt;scope-&gt;parse_scope.op-&gt;common.aml_opcode
op_eq
id|AML_WHILE_OP
)paren
)paren
op_logical_and
(paren
id|walk_state-&gt;control_state
)paren
op_logical_and
(paren
id|walk_state-&gt;control_state-&gt;common.state
op_eq
id|ACPI_CONTROL_PREDICATE_EXECUTING
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * A predicate was just completed, get the value of the&n;&t;&t;&t;&t; * predicate and branch based on that value&n;&t;&t;&t;&t; */
id|walk_state-&gt;op
op_assign
l_int|NULL
suffix:semicolon
id|status
op_assign
id|acpi_ds_get_predicate_value
(paren
id|walk_state
comma
id|ACPI_TO_POINTER
(paren
id|TRUE
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
op_logical_and
(paren
(paren
id|status
op_amp
id|AE_CODE_MASK
)paren
op_ne
id|AE_CODE_CONTROL
)paren
)paren
(brace
r_if
c_cond
(paren
id|status
op_eq
id|AE_AML_NO_RETURN_VALUE
)paren
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;Invoked method did not return a value, %s&bslash;n&quot;
comma
id|acpi_format_exception
(paren
id|status
)paren
)paren
)paren
suffix:semicolon
)brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;Get_predicate Failed, %s&bslash;n&quot;
comma
id|acpi_format_exception
(paren
id|status
)paren
)paren
)paren
suffix:semicolon
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
id|status
op_assign
id|acpi_ps_next_parse_state
(paren
id|walk_state
comma
id|op
comma
id|status
)paren
suffix:semicolon
)brace
id|acpi_ps_pop_scope
(paren
id|parser_state
comma
op_amp
id|op
comma
op_amp
id|walk_state-&gt;arg_types
comma
op_amp
id|walk_state-&gt;arg_count
)paren
suffix:semicolon
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_PARSE
comma
l_string|&quot;Popped scope, Op=%p&bslash;n&quot;
comma
id|op
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|walk_state-&gt;prev_op
)paren
(brace
multiline_comment|/* We were in the middle of an op */
id|op
op_assign
id|walk_state-&gt;prev_op
suffix:semicolon
id|walk_state-&gt;arg_types
op_assign
id|walk_state-&gt;prev_arg_types
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Iterative parsing loop, while there is more aml to process:&n;&t; */
r_while
c_loop
(paren
(paren
id|parser_state-&gt;aml
OL
id|parser_state-&gt;aml_end
)paren
op_logical_or
(paren
id|op
)paren
)paren
(brace
id|aml_op_start
op_assign
id|parser_state-&gt;aml
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|op
)paren
(brace
multiline_comment|/* Get the next opcode from the AML stream */
id|walk_state-&gt;aml_offset
op_assign
id|ACPI_PTR_DIFF
(paren
id|parser_state-&gt;aml
comma
id|parser_state-&gt;aml_start
)paren
suffix:semicolon
id|walk_state-&gt;opcode
op_assign
id|acpi_ps_peek_opcode
(paren
id|parser_state
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * First cut to determine what we have found:&n;&t;&t;&t; * 1) A valid AML opcode&n;&t;&t;&t; * 2) A name string&n;&t;&t;&t; * 3) An unknown/invalid opcode&n;&t;&t;&t; */
id|walk_state-&gt;op_info
op_assign
id|acpi_ps_get_opcode_info
(paren
id|walk_state-&gt;opcode
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|walk_state-&gt;op_info
op_member_access_from_pointer
r_class
)paren
(brace
r_case
id|AML_CLASS_ASCII
suffix:colon
r_case
id|AML_CLASS_PREFIX
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * Starts with a valid prefix or ASCII char, this is a name&n;&t;&t;&t;&t; * string.  Convert the bare name string to a namepath.&n;&t;&t;&t;&t; */
id|walk_state-&gt;opcode
op_assign
id|AML_INT_NAMEPATH_OP
suffix:semicolon
id|walk_state-&gt;arg_types
op_assign
id|ARGP_NAMESTRING
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AML_CLASS_UNKNOWN
suffix:colon
multiline_comment|/* The opcode is unrecognized.  Just skip unknown opcodes */
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;Found unknown opcode %X at AML address %p offset %X, ignoring&bslash;n&quot;
comma
id|walk_state-&gt;opcode
comma
id|parser_state-&gt;aml
comma
id|walk_state-&gt;aml_offset
)paren
)paren
suffix:semicolon
id|ACPI_DUMP_BUFFER
(paren
id|parser_state-&gt;aml
comma
l_int|128
)paren
suffix:semicolon
multiline_comment|/* Assume one-byte bad opcode */
id|parser_state-&gt;aml
op_increment
suffix:semicolon
r_continue
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Found opcode info, this is a normal opcode */
id|parser_state-&gt;aml
op_add_assign
id|acpi_ps_get_opcode_size
(paren
id|walk_state-&gt;opcode
)paren
suffix:semicolon
id|walk_state-&gt;arg_types
op_assign
id|walk_state-&gt;op_info-&gt;parse_args
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Create Op structure and append to parent&squot;s argument list */
r_if
c_cond
(paren
id|walk_state-&gt;op_info-&gt;flags
op_amp
id|AML_NAMED
)paren
(brace
id|pre_op.common.value.arg
op_assign
l_int|NULL
suffix:semicolon
id|pre_op.common.aml_opcode
op_assign
id|walk_state-&gt;opcode
suffix:semicolon
r_while
c_loop
(paren
id|GET_CURRENT_ARG_TYPE
(paren
id|walk_state-&gt;arg_types
)paren
op_ne
id|ARGP_NAME
)paren
(brace
id|arg
op_assign
id|acpi_ps_get_next_arg
(paren
id|parser_state
comma
id|GET_CURRENT_ARG_TYPE
(paren
id|walk_state-&gt;arg_types
)paren
comma
op_amp
id|walk_state-&gt;arg_count
)paren
suffix:semicolon
id|acpi_ps_append_arg
(paren
op_amp
id|pre_op
comma
id|arg
)paren
suffix:semicolon
id|INCREMENT_ARG_LIST
(paren
id|walk_state-&gt;arg_types
)paren
suffix:semicolon
)brace
multiline_comment|/* We know that this arg is a name, move to next arg */
id|INCREMENT_ARG_LIST
(paren
id|walk_state-&gt;arg_types
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Find the object.  This will either insert the object into&n;&t;&t;&t;&t; * the namespace or simply look it up&n;&t;&t;&t;&t; */
id|walk_state-&gt;op
op_assign
l_int|NULL
suffix:semicolon
id|status
op_assign
id|walk_state-&gt;descending_callback
(paren
id|walk_state
comma
op_amp
id|op
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;During name lookup/catalog, %s&bslash;n&quot;
comma
id|acpi_format_exception
(paren
id|status
)paren
)paren
)paren
suffix:semicolon
r_goto
id|close_this_op
suffix:semicolon
)brace
r_if
c_cond
(paren
id|op
op_eq
l_int|NULL
)paren
(brace
r_continue
suffix:semicolon
)brace
id|status
op_assign
id|acpi_ps_next_parse_state
(paren
id|walk_state
comma
id|op
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
id|AE_CTRL_PENDING
)paren
(brace
id|status
op_assign
id|AE_OK
suffix:semicolon
r_goto
id|close_this_op
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_goto
id|close_this_op
suffix:semicolon
)brace
id|acpi_ps_append_arg
(paren
id|op
comma
id|pre_op.common.value.arg
)paren
suffix:semicolon
id|acpi_gbl_depth
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|op-&gt;common.aml_opcode
op_eq
id|AML_REGION_OP
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Defer final parsing of an Operation_region body,&n;&t;&t;&t;&t;&t; * because we don&squot;t have enough info in the first pass&n;&t;&t;&t;&t;&t; * to parse it correctly (i.e., there may be method&n;&t;&t;&t;&t;&t; * calls within the Term_arg elements of the body.&n;&t;&t;&t;&t;&t; *&n;&t;&t;&t;&t;&t; * However, we must continue parsing because&n;&t;&t;&t;&t;&t; * the opregion is not a standalone package --&n;&t;&t;&t;&t;&t; * we don&squot;t know where the end is at this point.&n;&t;&t;&t;&t;&t; *&n;&t;&t;&t;&t;&t; * (Length is unknown until parse of the body complete)&n;&t;&t;&t;&t;&t; */
id|op-&gt;named.data
op_assign
id|aml_op_start
suffix:semicolon
id|op-&gt;named.length
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Not a named opcode, just allocate Op and append to parent */
id|walk_state-&gt;op_info
op_assign
id|acpi_ps_get_opcode_info
(paren
id|walk_state-&gt;opcode
)paren
suffix:semicolon
id|op
op_assign
id|acpi_ps_alloc_op
(paren
id|walk_state-&gt;opcode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|op
)paren
(brace
id|return_ACPI_STATUS
(paren
id|AE_NO_MEMORY
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|walk_state-&gt;op_info-&gt;flags
op_amp
id|AML_CREATE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Backup to beginning of Create_xXXfield declaration&n;&t;&t;&t;&t;&t; * Body_length is unknown until we parse the body&n;&t;&t;&t;&t;&t; */
id|op-&gt;named.data
op_assign
id|aml_op_start
suffix:semicolon
id|op-&gt;named.length
op_assign
l_int|0
suffix:semicolon
)brace
id|acpi_ps_append_arg
(paren
id|acpi_ps_get_parent_scope
(paren
id|parser_state
)paren
comma
id|op
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|walk_state-&gt;descending_callback
op_ne
l_int|NULL
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Find the object.  This will either insert the object into&n;&t;&t;&t;&t;&t; * the namespace or simply look it up&n;&t;&t;&t;&t;&t; */
id|walk_state-&gt;op
op_assign
id|op
suffix:semicolon
id|status
op_assign
id|walk_state-&gt;descending_callback
(paren
id|walk_state
comma
op_amp
id|op
)paren
suffix:semicolon
id|status
op_assign
id|acpi_ps_next_parse_state
(paren
id|walk_state
comma
id|op
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
id|AE_CTRL_PENDING
)paren
(brace
id|status
op_assign
id|AE_OK
suffix:semicolon
r_goto
id|close_this_op
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_goto
id|close_this_op
suffix:semicolon
)brace
)brace
)brace
id|op-&gt;common.aml_offset
op_assign
id|walk_state-&gt;aml_offset
suffix:semicolon
r_if
c_cond
(paren
id|walk_state-&gt;op_info
)paren
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_PARSE
comma
l_string|&quot;Opcode %4.4hX [%s] Op %p Aml %p Aml_offset %5.5X&bslash;n&quot;
comma
id|op-&gt;common.aml_opcode
comma
id|walk_state-&gt;op_info-&gt;name
comma
id|op
comma
id|parser_state-&gt;aml
comma
id|op-&gt;common.aml_offset
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Start Arg_count at zero because we don&squot;t know if there are any args yet */
id|walk_state-&gt;arg_count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|walk_state-&gt;arg_types
)paren
multiline_comment|/* Are there any arguments that must be processed? */
(brace
multiline_comment|/* Get arguments */
r_switch
c_cond
(paren
id|op-&gt;common.aml_opcode
)paren
(brace
r_case
id|AML_BYTE_OP
suffix:colon
multiline_comment|/* AML_BYTEDATA_ARG */
r_case
id|AML_WORD_OP
suffix:colon
multiline_comment|/* AML_WORDDATA_ARG */
r_case
id|AML_DWORD_OP
suffix:colon
multiline_comment|/* AML_DWORDATA_ARG */
r_case
id|AML_QWORD_OP
suffix:colon
multiline_comment|/* AML_QWORDATA_ARG */
r_case
id|AML_STRING_OP
suffix:colon
multiline_comment|/* AML_ASCIICHARLIST_ARG */
multiline_comment|/* Fill in constant or string argument directly */
id|acpi_ps_get_next_simple_arg
(paren
id|parser_state
comma
id|GET_CURRENT_ARG_TYPE
(paren
id|walk_state-&gt;arg_types
)paren
comma
id|op
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AML_INT_NAMEPATH_OP
suffix:colon
multiline_comment|/* AML_NAMESTRING_ARG */
id|acpi_ps_get_next_namepath
(paren
id|parser_state
comma
id|op
comma
op_amp
id|walk_state-&gt;arg_count
comma
l_int|1
)paren
suffix:semicolon
id|walk_state-&gt;arg_types
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/* Op is not a constant or string, append each argument */
r_while
c_loop
(paren
id|GET_CURRENT_ARG_TYPE
(paren
id|walk_state-&gt;arg_types
)paren
op_logical_and
op_logical_neg
id|walk_state-&gt;arg_count
)paren
(brace
id|walk_state-&gt;aml_offset
op_assign
id|ACPI_PTR_DIFF
(paren
id|parser_state-&gt;aml
comma
id|parser_state-&gt;aml_start
)paren
suffix:semicolon
id|arg
op_assign
id|acpi_ps_get_next_arg
(paren
id|parser_state
comma
id|GET_CURRENT_ARG_TYPE
(paren
id|walk_state-&gt;arg_types
)paren
comma
op_amp
id|walk_state-&gt;arg_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arg
)paren
(brace
id|arg-&gt;common.aml_offset
op_assign
id|walk_state-&gt;aml_offset
suffix:semicolon
id|acpi_ps_append_arg
(paren
id|op
comma
id|arg
)paren
suffix:semicolon
)brace
id|INCREMENT_ARG_LIST
(paren
id|walk_state-&gt;arg_types
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|op-&gt;common.aml_opcode
)paren
(brace
r_case
id|AML_METHOD_OP
suffix:colon
multiline_comment|/* For a method, save the length and address of the body */
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Skip parsing of control method or opregion body,&n;&t;&t;&t;&t;&t; * because we don&squot;t have enough info in the first pass&n;&t;&t;&t;&t;&t; * to parse them correctly.&n;&t;&t;&t;&t;&t; */
id|op-&gt;named.data
op_assign
id|parser_state-&gt;aml
suffix:semicolon
id|op-&gt;named.length
op_assign
(paren
id|u32
)paren
(paren
id|parser_state-&gt;pkg_end
op_minus
id|parser_state-&gt;aml
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Skip body of method.  For Op_regions, we must continue&n;&t;&t;&t;&t;&t; * parsing because the opregion is not a standalone&n;&t;&t;&t;&t;&t; * package (We don&squot;t know where the end is).&n;&t;&t;&t;&t;&t; */
id|parser_state-&gt;aml
op_assign
id|parser_state-&gt;pkg_end
suffix:semicolon
id|walk_state-&gt;arg_count
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AML_BUFFER_OP
suffix:colon
r_case
id|AML_PACKAGE_OP
suffix:colon
r_case
id|AML_VAR_PACKAGE_OP
suffix:colon
r_if
c_cond
(paren
(paren
id|op-&gt;common.parent
)paren
op_logical_and
(paren
id|op-&gt;common.parent-&gt;common.aml_opcode
op_eq
id|AML_NAME_OP
)paren
op_logical_and
(paren
id|walk_state-&gt;descending_callback
op_ne
id|acpi_ds_exec_begin_op
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * Skip parsing of&n;&t;&t;&t;&t;&t;&t; * because we don&squot;t have enough info in the first pass&n;&t;&t;&t;&t;&t;&t; * to parse them correctly.&n;&t;&t;&t;&t;&t;&t; */
id|op-&gt;named.data
op_assign
id|aml_op_start
suffix:semicolon
id|op-&gt;named.length
op_assign
(paren
id|u32
)paren
(paren
id|parser_state-&gt;pkg_end
op_minus
id|aml_op_start
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * Skip body&n;&t;&t;&t;&t;&t;&t; */
id|parser_state-&gt;aml
op_assign
id|parser_state-&gt;pkg_end
suffix:semicolon
id|walk_state-&gt;arg_count
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AML_WHILE_OP
suffix:colon
r_if
c_cond
(paren
id|walk_state-&gt;control_state
)paren
(brace
id|walk_state-&gt;control_state-&gt;control.package_end
op_assign
id|parser_state-&gt;pkg_end
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* No action for all other opcodes */
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Check for arguments that need to be processed */
r_if
c_cond
(paren
id|walk_state-&gt;arg_count
)paren
(brace
multiline_comment|/* There are arguments (complex ones), push Op and prepare for argument */
id|status
op_assign
id|acpi_ps_push_scope
(paren
id|parser_state
comma
id|op
comma
id|walk_state-&gt;arg_types
comma
id|walk_state-&gt;arg_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
id|op
op_assign
l_int|NULL
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* All arguments have been processed -- Op is complete, prepare for next */
id|walk_state-&gt;op_info
op_assign
id|acpi_ps_get_opcode_info
(paren
id|op-&gt;common.aml_opcode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|walk_state-&gt;op_info-&gt;flags
op_amp
id|AML_NAMED
)paren
(brace
r_if
c_cond
(paren
id|acpi_gbl_depth
)paren
(brace
id|acpi_gbl_depth
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|op-&gt;common.aml_opcode
op_eq
id|AML_REGION_OP
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Skip parsing of control method or opregion body,&n;&t;&t;&t;&t; * because we don&squot;t have enough info in the first pass&n;&t;&t;&t;&t; * to parse them correctly.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * Completed parsing an Op_region declaration, we now&n;&t;&t;&t;&t; * know the length.&n;&t;&t;&t;&t; */
id|op-&gt;named.length
op_assign
(paren
id|u32
)paren
(paren
id|parser_state-&gt;aml
op_minus
id|op-&gt;named.data
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|walk_state-&gt;op_info-&gt;flags
op_amp
id|AML_CREATE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Backup to beginning of Create_xXXfield declaration (1 for&n;&t;&t;&t; * Opcode)&n;&t;&t;&t; *&n;&t;&t;&t; * Body_length is unknown until we parse the body&n;&t;&t;&t; */
id|op-&gt;named.length
op_assign
(paren
id|u32
)paren
(paren
id|parser_state-&gt;aml
op_minus
id|op-&gt;named.data
)paren
suffix:semicolon
)brace
multiline_comment|/* This op complete, notify the dispatcher */
r_if
c_cond
(paren
id|walk_state-&gt;ascending_callback
op_ne
l_int|NULL
)paren
(brace
id|walk_state-&gt;op
op_assign
id|op
suffix:semicolon
id|walk_state-&gt;opcode
op_assign
id|op-&gt;common.aml_opcode
suffix:semicolon
id|status
op_assign
id|walk_state-&gt;ascending_callback
(paren
id|walk_state
)paren
suffix:semicolon
id|status
op_assign
id|acpi_ps_next_parse_state
(paren
id|walk_state
comma
id|op
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
id|AE_CTRL_PENDING
)paren
(brace
id|status
op_assign
id|AE_OK
suffix:semicolon
r_goto
id|close_this_op
suffix:semicolon
)brace
)brace
id|close_this_op
suffix:colon
multiline_comment|/*&n;&t;&t; * Finished one argument of the containing scope&n;&t;&t; */
id|parser_state-&gt;scope-&gt;parse_scope.arg_count
op_decrement
suffix:semicolon
multiline_comment|/* Close this Op (will result in parse subtree deletion) */
id|acpi_ps_complete_this_op
(paren
id|walk_state
comma
id|op
)paren
suffix:semicolon
id|op
op_assign
l_int|NULL
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|AE_OK
suffix:colon
r_break
suffix:semicolon
r_case
id|AE_CTRL_TRANSFER
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * We are about to transfer to a called method.&n;&t;&t;&t; */
id|walk_state-&gt;prev_op
op_assign
id|op
suffix:semicolon
id|walk_state-&gt;prev_arg_types
op_assign
id|walk_state-&gt;arg_types
suffix:semicolon
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
r_case
id|AE_CTRL_END
suffix:colon
id|acpi_ps_pop_scope
(paren
id|parser_state
comma
op_amp
id|op
comma
op_amp
id|walk_state-&gt;arg_types
comma
op_amp
id|walk_state-&gt;arg_count
)paren
suffix:semicolon
id|walk_state-&gt;op
op_assign
id|op
suffix:semicolon
id|walk_state-&gt;op_info
op_assign
id|acpi_ps_get_opcode_info
(paren
id|op-&gt;common.aml_opcode
)paren
suffix:semicolon
id|walk_state-&gt;opcode
op_assign
id|op-&gt;common.aml_opcode
suffix:semicolon
id|status
op_assign
id|walk_state-&gt;ascending_callback
(paren
id|walk_state
)paren
suffix:semicolon
id|status
op_assign
id|acpi_ps_next_parse_state
(paren
id|walk_state
comma
id|op
comma
id|status
)paren
suffix:semicolon
id|acpi_ps_complete_this_op
(paren
id|walk_state
comma
id|op
)paren
suffix:semicolon
id|op
op_assign
l_int|NULL
suffix:semicolon
id|status
op_assign
id|AE_OK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AE_CTRL_BREAK
suffix:colon
r_case
id|AE_CTRL_CONTINUE
suffix:colon
multiline_comment|/* Pop off scopes until we find the While */
r_while
c_loop
(paren
op_logical_neg
id|op
op_logical_or
(paren
id|op-&gt;common.aml_opcode
op_ne
id|AML_WHILE_OP
)paren
)paren
(brace
id|acpi_ps_pop_scope
(paren
id|parser_state
comma
op_amp
id|op
comma
op_amp
id|walk_state-&gt;arg_types
comma
op_amp
id|walk_state-&gt;arg_count
)paren
suffix:semicolon
)brace
multiline_comment|/* Close this iteration of the While loop */
id|walk_state-&gt;op
op_assign
id|op
suffix:semicolon
id|walk_state-&gt;op_info
op_assign
id|acpi_ps_get_opcode_info
(paren
id|op-&gt;common.aml_opcode
)paren
suffix:semicolon
id|walk_state-&gt;opcode
op_assign
id|op-&gt;common.aml_opcode
suffix:semicolon
id|status
op_assign
id|walk_state-&gt;ascending_callback
(paren
id|walk_state
)paren
suffix:semicolon
id|status
op_assign
id|acpi_ps_next_parse_state
(paren
id|walk_state
comma
id|op
comma
id|status
)paren
suffix:semicolon
id|acpi_ps_complete_this_op
(paren
id|walk_state
comma
id|op
)paren
suffix:semicolon
id|op
op_assign
l_int|NULL
suffix:semicolon
id|status
op_assign
id|AE_OK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AE_CTRL_TERMINATE
suffix:colon
id|status
op_assign
id|AE_OK
suffix:semicolon
multiline_comment|/* Clean up */
r_do
(brace
r_if
c_cond
(paren
id|op
)paren
(brace
id|acpi_ps_complete_this_op
(paren
id|walk_state
comma
id|op
)paren
suffix:semicolon
)brace
id|acpi_ps_pop_scope
(paren
id|parser_state
comma
op_amp
id|op
comma
op_amp
id|walk_state-&gt;arg_types
comma
op_amp
id|walk_state-&gt;arg_count
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|op
)paren
suffix:semicolon
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/* All other non-AE_OK status */
r_do
(brace
r_if
c_cond
(paren
id|op
)paren
(brace
id|acpi_ps_complete_this_op
(paren
id|walk_state
comma
id|op
)paren
suffix:semicolon
)brace
id|acpi_ps_pop_scope
(paren
id|parser_state
comma
op_amp
id|op
comma
op_amp
id|walk_state-&gt;arg_types
comma
op_amp
id|walk_state-&gt;arg_count
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|op
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * TBD: Cleanup parse ops on error&n;&t;&t;&t; */
macro_line|#if 0
r_if
c_cond
(paren
id|op
op_eq
l_int|NULL
)paren
(brace
id|acpi_ps_pop_scope
(paren
id|parser_state
comma
op_amp
id|op
comma
op_amp
id|walk_state-&gt;arg_types
comma
op_amp
id|walk_state-&gt;arg_count
)paren
suffix:semicolon
)brace
macro_line|#endif
id|walk_state-&gt;prev_op
op_assign
id|op
suffix:semicolon
id|walk_state-&gt;prev_arg_types
op_assign
id|walk_state-&gt;arg_types
suffix:semicolon
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/* This scope complete? */
r_if
c_cond
(paren
id|acpi_ps_has_completed_scope
(paren
id|parser_state
)paren
)paren
(brace
id|acpi_ps_pop_scope
(paren
id|parser_state
comma
op_amp
id|op
comma
op_amp
id|walk_state-&gt;arg_types
comma
op_amp
id|walk_state-&gt;arg_count
)paren
suffix:semicolon
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_PARSE
comma
l_string|&quot;Popped scope, Op=%p&bslash;n&quot;
comma
id|op
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|op
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* while Parser_state-&gt;Aml */
multiline_comment|/*&n;&t; * Complete the last Op (if not completed), and clear the scope stack.&n;&t; * It is easily possible to end an AML &quot;package&quot; with an unbounded number&n;&t; * of open scopes (such as when several ASL blocks are closed with&n;&t; * sequential closing braces).  We want to terminate each one cleanly.&n;&t; */
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_PARSE
comma
l_string|&quot;AML package complete at Op %p&bslash;n&quot;
comma
id|op
)paren
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|op
)paren
(brace
r_if
c_cond
(paren
id|walk_state-&gt;ascending_callback
op_ne
l_int|NULL
)paren
(brace
id|walk_state-&gt;op
op_assign
id|op
suffix:semicolon
id|walk_state-&gt;op_info
op_assign
id|acpi_ps_get_opcode_info
(paren
id|op-&gt;common.aml_opcode
)paren
suffix:semicolon
id|walk_state-&gt;opcode
op_assign
id|op-&gt;common.aml_opcode
suffix:semicolon
id|status
op_assign
id|walk_state-&gt;ascending_callback
(paren
id|walk_state
)paren
suffix:semicolon
id|status
op_assign
id|acpi_ps_next_parse_state
(paren
id|walk_state
comma
id|op
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
id|AE_CTRL_PENDING
)paren
(brace
id|status
op_assign
id|AE_OK
suffix:semicolon
r_goto
id|close_this_op
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_eq
id|AE_CTRL_TERMINATE
)paren
(brace
id|status
op_assign
id|AE_OK
suffix:semicolon
multiline_comment|/* Clean up */
r_do
(brace
r_if
c_cond
(paren
id|op
)paren
(brace
id|acpi_ps_complete_this_op
(paren
id|walk_state
comma
id|op
)paren
suffix:semicolon
)brace
id|acpi_ps_pop_scope
(paren
id|parser_state
comma
op_amp
id|op
comma
op_amp
id|walk_state-&gt;arg_types
comma
op_amp
id|walk_state-&gt;arg_count
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|op
)paren
suffix:semicolon
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|acpi_ps_complete_this_op
(paren
id|walk_state
comma
id|op
)paren
suffix:semicolon
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
)brace
id|acpi_ps_complete_this_op
(paren
id|walk_state
comma
id|op
)paren
suffix:semicolon
)brace
id|acpi_ps_pop_scope
(paren
id|parser_state
comma
op_amp
id|op
comma
op_amp
id|walk_state-&gt;arg_types
comma
op_amp
id|walk_state-&gt;arg_count
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|op
)paren
suffix:semicolon
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ps_parse_aml&n; *&n; * PARAMETERS:  Start_scope     - The starting point of the parse.  Becomes the&n; *                                root of the parsed op tree.&n; *              Aml             - Pointer to the raw AML code to parse&n; *              Aml_size        - Length of the AML to parse&n; *&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Parse raw AML and return a tree of ops&n; *&n; ******************************************************************************/
id|acpi_status
DECL|function|acpi_ps_parse_aml
id|acpi_ps_parse_aml
(paren
id|acpi_walk_state
op_star
id|walk_state
)paren
(brace
id|acpi_status
id|status
suffix:semicolon
id|ACPI_THREAD_STATE
op_star
id|thread
suffix:semicolon
id|ACPI_THREAD_STATE
op_star
id|prev_walk_list
op_assign
id|acpi_gbl_current_walk_list
suffix:semicolon
id|acpi_walk_state
op_star
id|previous_walk_state
suffix:semicolon
id|ACPI_FUNCTION_TRACE
(paren
l_string|&quot;Ps_parse_aml&quot;
)paren
suffix:semicolon
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_PARSE
comma
l_string|&quot;Entered with Walk_state=%p Aml=%p size=%X&bslash;n&quot;
comma
id|walk_state
comma
id|walk_state-&gt;parser_state.aml
comma
id|walk_state-&gt;parser_state.aml_size
)paren
)paren
suffix:semicolon
multiline_comment|/* Create and initialize a new thread state */
id|thread
op_assign
id|acpi_ut_create_thread_state
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|thread
)paren
(brace
id|return_ACPI_STATUS
(paren
id|AE_NO_MEMORY
)paren
suffix:semicolon
)brace
id|walk_state-&gt;thread
op_assign
id|thread
suffix:semicolon
id|acpi_ds_push_walk_state
(paren
id|walk_state
comma
id|thread
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This global allows the AML debugger to get a handle to the currently&n;&t; * executing control method.&n;&t; */
id|acpi_gbl_current_walk_list
op_assign
id|thread
suffix:semicolon
multiline_comment|/*&n;&t; * Execute the walk loop as long as there is a valid Walk State.  This&n;&t; * handles nested control method invocations without recursion.&n;&t; */
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_PARSE
comma
l_string|&quot;State=%p&bslash;n&quot;
comma
id|walk_state
)paren
)paren
suffix:semicolon
id|status
op_assign
id|AE_OK
suffix:semicolon
r_while
c_loop
(paren
id|walk_state
)paren
(brace
r_if
c_cond
(paren
id|ACPI_SUCCESS
(paren
id|status
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * The Parse_loop executes AML until the method terminates&n;&t;&t;&t; * or calls another method.&n;&t;&t;&t; */
id|status
op_assign
id|acpi_ps_parse_loop
(paren
id|walk_state
)paren
suffix:semicolon
)brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_PARSE
comma
l_string|&quot;Completed one call to walk loop, State=%p&bslash;n&quot;
comma
id|walk_state
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
id|AE_CTRL_TRANSFER
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * A method call was detected.&n;&t;&t;&t; * Transfer control to the called control method&n;&t;&t;&t; */
id|status
op_assign
id|acpi_ds_call_control_method
(paren
id|thread
comma
id|walk_state
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If the transfer to the new method method call worked, a new walk&n;&t;&t;&t; * state was created -- get it&n;&t;&t;&t; */
id|walk_state
op_assign
id|acpi_ds_get_current_walk_state
(paren
id|thread
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_eq
id|AE_CTRL_TERMINATE
)paren
(brace
id|status
op_assign
id|AE_OK
suffix:semicolon
)brace
multiline_comment|/* We are done with this walk, move on to the parent if any */
id|walk_state
op_assign
id|acpi_ds_pop_walk_state
(paren
id|thread
)paren
suffix:semicolon
multiline_comment|/* Reset the current scope to the beginning of scope stack */
id|acpi_ds_scope_stack_clear
(paren
id|walk_state
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we just returned from the execution of a control method,&n;&t;&t; * there&squot;s lots of cleanup to do&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|walk_state-&gt;parse_flags
op_amp
id|ACPI_PARSE_MODE_MASK
)paren
op_eq
id|ACPI_PARSE_EXECUTE
)paren
(brace
id|status
op_assign
id|acpi_ds_terminate_control_method
(paren
id|walk_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|ACPI_REPORT_ERROR
(paren
(paren
l_string|&quot;Could not terminate control method properly&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|status
op_assign
id|AE_OK
suffix:semicolon
multiline_comment|/* Ignore error and continue */
)brace
)brace
multiline_comment|/* Delete this walk state and all linked control states */
id|acpi_ps_cleanup_scope
(paren
op_amp
id|walk_state-&gt;parser_state
)paren
suffix:semicolon
id|previous_walk_state
op_assign
id|walk_state
suffix:semicolon
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_PARSE
comma
l_string|&quot;Return_value=%p, State=%p&bslash;n&quot;
comma
id|walk_state-&gt;return_desc
comma
id|walk_state
)paren
)paren
suffix:semicolon
multiline_comment|/* Check if we have restarted a preempted walk */
id|walk_state
op_assign
id|acpi_ds_get_current_walk_state
(paren
id|thread
)paren
suffix:semicolon
r_if
c_cond
(paren
id|walk_state
)paren
(brace
r_if
c_cond
(paren
id|ACPI_SUCCESS
(paren
id|status
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * There is another walk state, restart it.&n;&t;&t;&t;&t; * If the method return value is not used by the parent,&n;&t;&t;&t;&t; * The object is deleted&n;&t;&t;&t;&t; */
id|status
op_assign
id|acpi_ds_restart_control_method
(paren
id|walk_state
comma
id|previous_walk_state-&gt;return_desc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_SUCCESS
(paren
id|status
)paren
)paren
(brace
id|walk_state-&gt;walk_type
op_or_assign
id|ACPI_WALK_METHOD_RESTART
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* On error, delete any return object */
id|acpi_ut_remove_reference
(paren
id|previous_walk_state-&gt;return_desc
)paren
suffix:semicolon
id|ACPI_REPORT_ERROR
(paren
(paren
l_string|&quot;Method execution failed, %s&bslash;n&quot;
comma
id|acpi_format_exception
(paren
id|status
)paren
)paren
)paren
suffix:semicolon
id|ACPI_DUMP_PATHNAME
(paren
id|walk_state-&gt;method_node
comma
l_string|&quot;Method pathname: &quot;
comma
id|ACPI_LV_ERROR
comma
id|_COMPONENT
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Just completed a 1st-level method, save the final internal return&n;&t;&t; * value (if any)&n;&t;&t; */
r_else
r_if
c_cond
(paren
id|previous_walk_state-&gt;caller_return_desc
)paren
(brace
op_star
(paren
id|previous_walk_state-&gt;caller_return_desc
)paren
op_assign
id|previous_walk_state-&gt;return_desc
suffix:semicolon
multiline_comment|/* NULL if no return value */
)brace
r_else
r_if
c_cond
(paren
id|previous_walk_state-&gt;return_desc
)paren
(brace
multiline_comment|/* Caller doesn&squot;t want it, must delete it */
id|acpi_ut_remove_reference
(paren
id|previous_walk_state-&gt;return_desc
)paren
suffix:semicolon
)brace
id|acpi_ds_delete_walk_state
(paren
id|previous_walk_state
)paren
suffix:semicolon
)brace
multiline_comment|/* Normal exit */
id|acpi_ex_release_all_mutexes
(paren
id|thread
)paren
suffix:semicolon
id|acpi_ut_delete_generic_state
(paren
id|ACPI_CAST_PTR
(paren
id|acpi_generic_state
comma
id|thread
)paren
)paren
suffix:semicolon
id|acpi_gbl_current_walk_list
op_assign
id|prev_walk_list
suffix:semicolon
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
eof
