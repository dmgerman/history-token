multiline_comment|/******************************************************************************&n; *&n; * Module Name: bmsearch.c&n; *   $Revision: 13 $&n; *&n; *****************************************************************************/
multiline_comment|/*&n; *  Copyright (C) 2000, 2001 Andrew Grover&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &lt;acpi.h&gt;
macro_line|#include &quot;bm.h&quot;
DECL|macro|_COMPONENT
mdefine_line|#define _COMPONENT&t;&t;ACPI_BUS
id|MODULE_NAME
(paren
l_string|&quot;bmsearch&quot;
)paren
multiline_comment|/****************************************************************************&n; *                            External Functions&n; ****************************************************************************/
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    bm_compare&n; *&n; * PARAMETERS:  &n; *&n; * RETURN:      &n; *&n; * DESCRIPTION: &n; *&n; ****************************************************************************/
id|ACPI_STATUS
DECL|function|bm_compare
id|bm_compare
(paren
id|BM_DEVICE
op_star
id|device
comma
id|BM_DEVICE_ID
op_star
id|criteria
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|device
op_logical_or
op_logical_neg
id|criteria
)paren
(brace
r_return
id|AE_BAD_PARAMETER
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * Present?&n;&t; * --------&n;&t; * We&squot;re only going to match on devices that are present.&n;&t; * TBD: Optimize in bm_search (don&squot;t have to call here).&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|BM_DEVICE_PRESENT
c_func
(paren
id|device
)paren
)paren
(brace
r_return
id|AE_NOT_FOUND
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * Type?&n;&t; */
r_if
c_cond
(paren
id|criteria-&gt;type
op_logical_and
(paren
id|criteria-&gt;type
op_ne
id|device-&gt;id.type
)paren
)paren
(brace
r_return
id|AE_NOT_FOUND
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * HID?&n;&t; */
r_if
c_cond
(paren
(paren
id|criteria-&gt;hid
(braket
l_int|0
)braket
)paren
op_logical_and
(paren
l_int|0
op_ne
id|STRNCMP
c_func
(paren
id|criteria-&gt;hid
comma
id|device-&gt;id.hid
comma
r_sizeof
(paren
id|BM_DEVICE_HID
)paren
)paren
)paren
)paren
(brace
r_return
id|AE_NOT_FOUND
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * ADR?&n;&t; */
r_if
c_cond
(paren
(paren
id|criteria-&gt;adr
)paren
op_logical_and
(paren
id|criteria-&gt;adr
op_ne
id|device-&gt;id.adr
)paren
)paren
(brace
r_return
id|AE_NOT_FOUND
suffix:semicolon
)brace
r_return
id|AE_OK
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    bm_search&n; *&n; * PARAMETERS:  &n; *&n; * RETURN:      AE_BAD_PARAMETER- invalid input parameter&n; *              AE_NOT_EXIST    - start_device_handle doesn&squot;t exist&n; *              AE_NOT_FOUND    - no matches to Search_info.criteria found&n; *              AE_OK           - success&n; *&n; * DESCRIPTION: &n; *&n; ****************************************************************************/
id|ACPI_STATUS
DECL|function|bm_search
id|bm_search
c_func
(paren
id|BM_HANDLE
id|device_handle
comma
id|BM_DEVICE_ID
op_star
id|criteria
comma
id|BM_HANDLE_LIST
op_star
id|results
)paren
(brace
id|ACPI_STATUS
id|status
op_assign
id|AE_OK
suffix:semicolon
id|BM_NODE
op_star
id|node
op_assign
l_int|NULL
suffix:semicolon
id|FUNCTION_TRACE
c_func
(paren
l_string|&quot;bm_search&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|criteria
op_logical_or
op_logical_neg
id|results
)paren
(brace
id|return_ACPI_STATUS
c_func
(paren
id|AE_BAD_PARAMETER
)paren
suffix:semicolon
)brace
id|results-&gt;count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Locate Starting Point:&n;&t; * ----------------------&n;&t; * Locate the node in the hierarchy where we&squot;ll begin our search.&n;&t; */
id|status
op_assign
id|bm_get_node
c_func
(paren
id|device_handle
comma
l_int|0
comma
op_amp
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
c_func
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
c_func
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Parse Hierarchy:&n;&t; * ----------------&n;&t; * Parse through the node hierarchy looking for matches.&n;&t; */
r_while
c_loop
(paren
id|node
op_logical_and
(paren
id|results-&gt;count
op_le
id|BM_HANDLES_MAX
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Depth-first:&n;&t;&t; * ------------&n;&t;&t; * Searches are always performed depth-first.&n;&t;&t; */
r_if
c_cond
(paren
id|node-&gt;scope.head
)paren
(brace
id|status
op_assign
id|bm_compare
c_func
(paren
op_amp
(paren
id|node-&gt;device
)paren
comma
id|criteria
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_SUCCESS
c_func
(paren
id|status
)paren
)paren
(brace
id|results-&gt;handles
(braket
id|results-&gt;count
op_increment
)braket
op_assign
id|node-&gt;device.handle
suffix:semicolon
)brace
id|node
op_assign
id|node-&gt;scope.head
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Now Breadth:&n;&t;&t; * ------------&n;&t;&t; * Search all peers until scope is exhausted.&n;&t;&t; */
r_else
(brace
id|status
op_assign
id|bm_compare
c_func
(paren
op_amp
(paren
id|node-&gt;device
)paren
comma
id|criteria
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_SUCCESS
c_func
(paren
id|status
)paren
)paren
(brace
id|results-&gt;handles
(braket
id|results-&gt;count
op_increment
)braket
op_assign
id|node-&gt;device.handle
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Locate Next Device:&n;&t;&t;&t; * -------------------&n;&t;&t;&t; * The next node is either a peer at this level &n;&t;&t;&t; * (node-&gt;next is valid), or we work are way back &n;&t;&t;&t; * up the tree until we either find a non-parsed &n;&t;&t;&t; * peer or hit the top (node-&gt;parent is NULL).&n;&t;&t;&t; */
r_while
c_loop
(paren
op_logical_neg
id|node-&gt;next
op_logical_and
id|node-&gt;parent
)paren
(brace
id|node
op_assign
id|node-&gt;parent
suffix:semicolon
)brace
id|node
op_assign
id|node-&gt;next
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|results-&gt;count
op_eq
l_int|0
)paren
(brace
id|return_ACPI_STATUS
c_func
(paren
id|AE_NOT_FOUND
)paren
suffix:semicolon
)brace
r_else
(brace
id|return_ACPI_STATUS
c_func
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
)brace
eof
