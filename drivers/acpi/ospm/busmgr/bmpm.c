multiline_comment|/*****************************************************************************&n; *&n; * Module Name: bmpm.c&n; *   $Revision: 14 $&n; *&n; *****************************************************************************/
multiline_comment|/*&n; *  Copyright (C) 2000, 2001 Andrew Grover&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &lt;acpi.h&gt;
macro_line|#include &quot;bm.h&quot;
macro_line|#include &quot;bmpower.h&quot;
DECL|macro|_COMPONENT
mdefine_line|#define _COMPONENT&t;&t;ACPI_BUS
id|MODULE_NAME
(paren
l_string|&quot;bmpm&quot;
)paren
multiline_comment|/****************************************************************************&n; *                             Internal Functions&n; ****************************************************************************/
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    bm_get_inferred_power_state&n; *&n; * PARAMETERS:&n; *&n; * RETURN:&n; *&n; * DESCRIPTION:&n; *&n; ****************************************************************************/
id|acpi_status
DECL|function|bm_get_inferred_power_state
id|bm_get_inferred_power_state
(paren
id|BM_DEVICE
op_star
id|device
)paren
(brace
id|acpi_status
id|status
op_assign
id|AE_OK
suffix:semicolon
id|BM_HANDLE_LIST
id|pr_list
suffix:semicolon
id|BM_POWER_STATE
id|list_state
op_assign
id|ACPI_STATE_UNKNOWN
suffix:semicolon
r_char
id|object_name
(braket
l_int|5
)braket
op_assign
(brace
l_char|&squot;_&squot;
comma
l_char|&squot;P&squot;
comma
l_char|&squot;R&squot;
comma
l_char|&squot;0&squot;
comma
l_char|&squot;&bslash;0&squot;
)brace
suffix:semicolon
id|u32
id|i
op_assign
l_int|0
suffix:semicolon
id|FUNCTION_TRACE
c_func
(paren
l_string|&quot;bm_get_inferred_power_state&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device
)paren
(brace
id|return_ACPI_STATUS
c_func
(paren
id|AE_BAD_PARAMETER
)paren
suffix:semicolon
)brace
id|MEMSET
c_func
(paren
op_amp
id|pr_list
comma
l_int|0
comma
r_sizeof
(paren
id|BM_HANDLE_LIST
)paren
)paren
suffix:semicolon
id|device-&gt;power.state
op_assign
id|ACPI_STATE_D3
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate Power State:&n;&t; * ----------------------&n;&t; * Try to infer the devices&squot;s power state by checking the state of&n;&t; * the devices&squot;s power resources.  We start by evaluating _PR0&n;&t; * (resource requirements at D0) and work through _PR1 and _PR2.&n;&t; * We know the current devices power state when all resources (for&n;&t; * a give Dx state) are ON.  If no power resources are on then the&n;&t; * device is assumed to be off (D3).&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|ACPI_STATE_D0
suffix:semicolon
id|i
OL
id|ACPI_STATE_D3
suffix:semicolon
id|i
op_increment
)paren
(brace
id|object_name
(braket
l_int|3
)braket
op_assign
l_char|&squot;0&squot;
op_plus
id|i
suffix:semicolon
id|status
op_assign
id|bm_evaluate_reference_list
c_func
(paren
id|device-&gt;acpi_handle
comma
id|object_name
comma
op_amp
id|pr_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_SUCCESS
c_func
(paren
id|status
)paren
)paren
(brace
id|status
op_assign
id|bm_pr_list_get_state
c_func
(paren
op_amp
id|pr_list
comma
op_amp
id|list_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_SUCCESS
c_func
(paren
id|status
)paren
)paren
(brace
r_if
c_cond
(paren
id|list_state
op_eq
id|ACPI_STATE_D0
)paren
(brace
id|device-&gt;power.state
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
)brace
id|return_ACPI_STATUS
c_func
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *                             External Functions&n; ****************************************************************************/
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    bm_get_power_state&n; *&n; * PARAMETERS:&n; *&n; * RETURN:&n; *&n; * DESCRIPTION:&n; *&n; ****************************************************************************/
id|acpi_status
DECL|function|bm_get_power_state
id|bm_get_power_state
(paren
id|BM_NODE
op_star
id|node
)paren
(brace
id|acpi_status
id|status
op_assign
id|AE_OK
suffix:semicolon
id|BM_DEVICE
op_star
id|device
op_assign
l_int|NULL
suffix:semicolon
id|FUNCTION_TRACE
c_func
(paren
l_string|&quot;bm_get_power_state&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|node
op_logical_or
op_logical_neg
id|node-&gt;parent
)paren
(brace
id|return_ACPI_STATUS
c_func
(paren
id|AE_BAD_PARAMETER
)paren
suffix:semicolon
)brace
id|device
op_assign
op_amp
(paren
id|node-&gt;device
)paren
suffix:semicolon
id|device-&gt;power.state
op_assign
id|ACPI_STATE_UNKNOWN
suffix:semicolon
multiline_comment|/*&n;&t; * Power Control?&n;&t; * --------------&n;&t; * If this device isn&squot;t directly power manageable (e.g. doesn&squot;t&n;&t; * include _PR0/_PS0) then there&squot;s nothing to do (state is static).&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|BM_IS_POWER_CONTROL
c_func
(paren
id|device
)paren
)paren
(brace
id|return_ACPI_STATUS
c_func
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Parent Present?&n;&t; * ---------------&n;&t; * Make sure the parent is present before mucking with the child.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|BM_NODE_PRESENT
c_func
(paren
id|node-&gt;parent
)paren
)paren
(brace
id|return_ACPI_STATUS
c_func
(paren
id|AE_NOT_EXIST
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get Power State:&n;&t; * ----------------&n;&t; * Either directly (via _PSC) or inferred (via power resource&n;&t; * dependencies).&n;&t; */
r_if
c_cond
(paren
id|BM_IS_POWER_STATE
c_func
(paren
id|device
)paren
)paren
(brace
id|status
op_assign
id|bm_evaluate_simple_integer
c_func
(paren
id|device-&gt;acpi_handle
comma
l_string|&quot;_PSC&quot;
comma
op_amp
(paren
id|device-&gt;power.state
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
id|bm_get_inferred_power_state
c_func
(paren
id|device
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ACPI_SUCCESS
c_func
(paren
id|status
)paren
)paren
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;Device [%02x] is at power state [D%d].&bslash;n&quot;
comma
id|device-&gt;handle
comma
id|device-&gt;power.state
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;Error getting power state for device [%02x]&bslash;n&quot;
comma
id|device-&gt;handle
)paren
)paren
suffix:semicolon
)brace
id|return_ACPI_STATUS
c_func
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    bm_set_power_state&n; *&n; * PARAMETERS:&n; *&n; * RETURN:&n; *&n; * DESCRIPTION:&n; *&n; ****************************************************************************/
id|acpi_status
DECL|function|bm_set_power_state
id|bm_set_power_state
(paren
id|BM_NODE
op_star
id|node
comma
id|BM_POWER_STATE
id|state
)paren
(brace
id|acpi_status
id|status
op_assign
id|AE_OK
suffix:semicolon
id|BM_DEVICE
op_star
id|device
op_assign
l_int|NULL
suffix:semicolon
id|BM_DEVICE
op_star
id|parent_device
op_assign
l_int|NULL
suffix:semicolon
id|BM_HANDLE_LIST
id|current_list
suffix:semicolon
id|BM_HANDLE_LIST
id|target_list
suffix:semicolon
r_char
id|object_name
(braket
l_int|5
)braket
op_assign
(brace
l_char|&squot;_&squot;
comma
l_char|&squot;P&squot;
comma
l_char|&squot;R&squot;
comma
l_char|&squot;0&squot;
comma
l_char|&squot;&bslash;0&squot;
)brace
suffix:semicolon
id|FUNCTION_TRACE
c_func
(paren
l_string|&quot;bm_set_power_state&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|node
op_logical_or
op_logical_neg
id|node-&gt;parent
op_logical_or
(paren
id|state
OG
id|ACPI_STATE_D3
)paren
)paren
(brace
id|return_ACPI_STATUS
c_func
(paren
id|AE_BAD_PARAMETER
)paren
suffix:semicolon
)brace
id|MEMSET
c_func
(paren
op_amp
id|current_list
comma
l_int|0
comma
r_sizeof
(paren
id|BM_HANDLE_LIST
)paren
)paren
suffix:semicolon
id|MEMSET
c_func
(paren
op_amp
id|target_list
comma
l_int|0
comma
r_sizeof
(paren
id|BM_HANDLE_LIST
)paren
)paren
suffix:semicolon
id|device
op_assign
op_amp
(paren
id|node-&gt;device
)paren
suffix:semicolon
id|parent_device
op_assign
op_amp
(paren
id|node-&gt;parent-&gt;device
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Power Control?&n;&t; * --------------&n;&t; * If this device isn&squot;t directly power manageable (e.g. doesn&squot;t&n;&t; * include _PR0/_PS0) then return an error (can&squot;t set state).&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|BM_IS_POWER_CONTROL
c_func
(paren
id|device
)paren
)paren
(brace
id|return_ACPI_STATUS
c_func
(paren
id|AE_ERROR
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Parent Present?&n;&t; * ---------------&n;&t; * Make sure the parent is present before mucking with the child.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|BM_NODE_PRESENT
c_func
(paren
id|node-&gt;parent
)paren
)paren
(brace
id|return_ACPI_STATUS
c_func
(paren
id|AE_NOT_EXIST
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check Parent&squot;s Power State:&n;&t; * ---------------------------&n;&t; * Can&squot;t be in a higher power state (lower Dx value) than parent.&n;&t; */
r_if
c_cond
(paren
id|state
OL
id|parent_device-&gt;power.state
)paren
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_WARN
comma
l_string|&quot;Cannot set device [%02x] to a higher-powered state than parent_device.&bslash;n&quot;
comma
id|device-&gt;handle
)paren
)paren
suffix:semicolon
id|return_ACPI_STATUS
c_func
(paren
id|AE_ERROR
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get Resources:&n;&t; * --------------&n;&t; * Get the power resources associated with the device&squot;s current&n;&t; * and target power states.&n;&t; */
r_if
c_cond
(paren
id|device-&gt;power.state
op_ne
id|ACPI_STATE_UNKNOWN
)paren
(brace
id|object_name
(braket
l_int|3
)braket
op_assign
l_char|&squot;0&squot;
op_plus
id|device-&gt;power.state
suffix:semicolon
id|bm_evaluate_reference_list
c_func
(paren
id|device-&gt;acpi_handle
comma
id|object_name
comma
op_amp
id|current_list
)paren
suffix:semicolon
)brace
id|object_name
(braket
l_int|3
)braket
op_assign
l_char|&squot;0&squot;
op_plus
id|state
suffix:semicolon
id|bm_evaluate_reference_list
c_func
(paren
id|device-&gt;acpi_handle
comma
id|object_name
comma
op_amp
id|target_list
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Transition Resources:&n;&t; * ---------------------&n;&t; * Transition all power resources referenced by this device to&n;&t; * the correct power state (taking into consideration sequencing&n;&t; * and dependencies to other devices).&n;&t; */
r_if
c_cond
(paren
id|current_list.count
op_logical_or
id|target_list.count
)paren
(brace
id|status
op_assign
id|bm_pr_list_transition
c_func
(paren
op_amp
id|current_list
comma
op_amp
id|target_list
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ACPI_FAILURE
c_func
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
c_func
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Execute _PSx:&n;&t; * -------------&n;&t; * Execute the _PSx method corresponding to the target Dx state,&n;&t; * if it exists.&n;&t; */
id|object_name
(braket
l_int|2
)braket
op_assign
l_char|&squot;S&squot;
suffix:semicolon
id|object_name
(braket
l_int|3
)braket
op_assign
l_char|&squot;0&squot;
op_plus
id|state
suffix:semicolon
id|bm_evaluate_object
c_func
(paren
id|device-&gt;acpi_handle
comma
id|object_name
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_SUCCESS
c_func
(paren
id|status
)paren
)paren
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;Device [%02x] is now at [D%d].&bslash;n&quot;
comma
id|device-&gt;handle
comma
id|state
)paren
)paren
suffix:semicolon
id|device-&gt;power.state
op_assign
id|state
suffix:semicolon
)brace
id|return_ACPI_STATUS
c_func
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    bm_get_pm_capabilities&n; *&n; * PARAMETERS:&n; *&n; * RETURN:&n; *&n; * DESCRIPTION:&n; *&n; ****************************************************************************/
id|acpi_status
DECL|function|bm_get_pm_capabilities
id|bm_get_pm_capabilities
(paren
id|BM_NODE
op_star
id|node
)paren
(brace
id|acpi_status
id|status
op_assign
id|AE_OK
suffix:semicolon
id|BM_DEVICE
op_star
id|device
op_assign
l_int|NULL
suffix:semicolon
id|BM_DEVICE
op_star
id|parent_device
op_assign
l_int|NULL
suffix:semicolon
id|acpi_handle
id|acpi_handle
op_assign
l_int|NULL
suffix:semicolon
id|BM_POWER_STATE
id|dx_supported
op_assign
id|ACPI_STATE_UNKNOWN
suffix:semicolon
r_char
id|object_name
(braket
l_int|5
)braket
op_assign
(brace
l_char|&squot;_&squot;
comma
l_char|&squot;S&squot;
comma
l_char|&squot;0&squot;
comma
l_char|&squot;D&squot;
comma
l_char|&squot;&bslash;0&squot;
)brace
suffix:semicolon
id|u32
id|i
op_assign
l_int|0
suffix:semicolon
id|FUNCTION_TRACE
c_func
(paren
l_string|&quot;bm_get_pm_capabilities&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|node
op_logical_or
op_logical_neg
id|node-&gt;parent
)paren
(brace
id|return_ACPI_STATUS
c_func
(paren
id|AE_BAD_PARAMETER
)paren
suffix:semicolon
)brace
id|device
op_assign
op_amp
(paren
id|node-&gt;device
)paren
suffix:semicolon
id|parent_device
op_assign
op_amp
(paren
id|node-&gt;parent-&gt;device
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Power Management Flags:&n;&t; * -----------------------&n;&t; */
r_if
c_cond
(paren
id|ACPI_SUCCESS
c_func
(paren
id|acpi_get_handle
c_func
(paren
id|device-&gt;acpi_handle
comma
l_string|&quot;_PSC&quot;
comma
op_amp
id|acpi_handle
)paren
)paren
)paren
(brace
id|device-&gt;power.flags
op_or_assign
id|BM_FLAGS_POWER_STATE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ACPI_SUCCESS
c_func
(paren
id|acpi_get_handle
c_func
(paren
id|device-&gt;acpi_handle
comma
l_string|&quot;_IRC&quot;
comma
op_amp
id|acpi_handle
)paren
)paren
)paren
(brace
id|device-&gt;power.flags
op_or_assign
id|BM_FLAGS_INRUSH_CURRENT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ACPI_SUCCESS
c_func
(paren
id|acpi_get_handle
c_func
(paren
id|device-&gt;acpi_handle
comma
l_string|&quot;_PRW&quot;
comma
op_amp
id|acpi_handle
)paren
)paren
)paren
(brace
id|device-&gt;power.flags
op_or_assign
id|BM_FLAGS_WAKE_CAPABLE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Device Power State:&n;&t; * -------------------&n;&t; * Note that we can&squot;t get the device&squot;s power state until we&squot;ve&n;&t; * initialized all power resources, so for now we just set to&n;&t; * unknown.&n;&t; */
id|device-&gt;power.state
op_assign
id|ACPI_STATE_UNKNOWN
suffix:semicolon
multiline_comment|/*&n;&t; * Dx Supported in S0:&n;&t; * -------------------&n;&t; * Figure out which Dx states are supported by this device for the&n;&t; * S0 (working) state.  Note that D0 and D3 are required (assumed).&n;&t; */
id|device-&gt;power.dx_supported
(braket
id|ACPI_STATE_S0
)braket
op_assign
id|BM_FLAGS_D0_SUPPORT
op_or
id|BM_FLAGS_D3_SUPPORT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ACPI_SUCCESS
c_func
(paren
id|acpi_get_handle
c_func
(paren
id|device-&gt;acpi_handle
comma
l_string|&quot;_PR1&quot;
comma
op_amp
id|acpi_handle
)paren
)paren
)paren
op_logical_or
(paren
id|ACPI_SUCCESS
c_func
(paren
id|acpi_get_handle
c_func
(paren
id|device-&gt;acpi_handle
comma
l_string|&quot;_PS1&quot;
comma
op_amp
id|acpi_handle
)paren
)paren
)paren
)paren
(brace
id|device-&gt;power.dx_supported
(braket
id|ACPI_STATE_S0
)braket
op_or_assign
id|BM_FLAGS_D1_SUPPORT
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ACPI_SUCCESS
c_func
(paren
id|acpi_get_handle
c_func
(paren
id|device-&gt;acpi_handle
comma
l_string|&quot;_PR2&quot;
comma
op_amp
id|acpi_handle
)paren
)paren
)paren
op_logical_or
(paren
id|ACPI_SUCCESS
c_func
(paren
id|acpi_get_handle
c_func
(paren
id|device-&gt;acpi_handle
comma
l_string|&quot;_PS2&quot;
comma
op_amp
id|acpi_handle
)paren
)paren
)paren
)paren
(brace
id|device-&gt;power.dx_supported
(braket
id|ACPI_STATE_S0
)braket
op_or_assign
id|BM_FLAGS_D2_SUPPORT
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Dx Supported in S1-S5:&n;&t; * ----------------------&n;&t; * Figure out which Dx states are supported by this device for&n;&t; * all other Sx states.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|ACPI_STATE_S1
suffix:semicolon
id|i
op_le
id|ACPI_STATE_S5
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * D3 support is assumed (off is always possible!).&n;&t;&t; */
id|device-&gt;power.dx_supported
(braket
id|i
)braket
op_assign
id|BM_FLAGS_D3_SUPPORT
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Evalute _Sx_d:&n;&t;&t; * -------------&n;&t;&t; * Which returns the highest (power) Dx state supported in&n;&t;&t; * this system (Sx) state.  We convert this value to a bit&n;&t;&t; * mask of supported states (conceptually simpler).&n;&t;&t; */
id|status
op_assign
id|bm_evaluate_simple_integer
c_func
(paren
id|device-&gt;acpi_handle
comma
id|object_name
comma
op_amp
id|dx_supported
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_SUCCESS
c_func
(paren
id|status
)paren
)paren
(brace
r_switch
c_cond
(paren
id|dx_supported
)paren
(brace
r_case
l_int|0
suffix:colon
id|device-&gt;power.dx_supported
(braket
id|i
)braket
op_or_assign
id|BM_FLAGS_D0_SUPPORT
suffix:semicolon
multiline_comment|/* fall through */
r_case
l_int|1
suffix:colon
id|device-&gt;power.dx_supported
(braket
id|i
)braket
op_or_assign
id|BM_FLAGS_D1_SUPPORT
suffix:semicolon
multiline_comment|/* fall through */
r_case
l_int|2
suffix:colon
id|device-&gt;power.dx_supported
(braket
id|i
)braket
op_or_assign
id|BM_FLAGS_D2_SUPPORT
suffix:semicolon
multiline_comment|/* fall through */
r_case
l_int|3
suffix:colon
id|device-&gt;power.dx_supported
(braket
id|i
)braket
op_or_assign
id|BM_FLAGS_D3_SUPPORT
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Validate:&n;&t;&t;&t; * ---------&n;&t;&t;&t; * Mask of any states that _Sx_d falsely advertises&n;&t;&t;&t; * (e.g.claims D1 support but neither _PR2 or _PS2&n;&t;&t;&t; * exist).  In other words, S1-S5 can&squot;t offer a Dx&n;&t;&t;&t; * state that isn&squot;t supported by S0.&n;&t;&t;&t; */
id|device-&gt;power.dx_supported
(braket
id|i
)braket
op_and_assign
id|device-&gt;power.dx_supported
(braket
id|ACPI_STATE_S0
)braket
suffix:semicolon
)brace
id|object_name
(braket
l_int|2
)braket
op_increment
suffix:semicolon
)brace
id|return_ACPI_STATUS
c_func
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
eof
