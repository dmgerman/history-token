multiline_comment|/*****************************************************************************&n; *&n; * Module Name: prpower.c&n; *   $Revision: 30 $&n; *&n; *****************************************************************************/
multiline_comment|/*&n; *  Copyright (C) 2000, 2001 Andrew Grover&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
multiline_comment|/* TBD: Linux specific */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/pm.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;acpi.h&gt;
macro_line|#include &lt;bm.h&gt;
macro_line|#include &quot;pr.h&quot;
DECL|macro|_COMPONENT
mdefine_line|#define _COMPONENT&t;&t;ACPI_PROCESSOR
id|MODULE_NAME
(paren
l_string|&quot;prpower&quot;
)paren
multiline_comment|/****************************************************************************&n; *                                  Globals&n; ****************************************************************************/
r_extern
id|fadt_descriptor_rev2
id|acpi_fadt
suffix:semicolon
DECL|variable|last_idle_jiffies
r_static
id|u32
id|last_idle_jiffies
op_assign
l_int|0
suffix:semicolon
DECL|variable|processor_list
r_static
id|PR_CONTEXT
op_star
id|processor_list
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|variable|pr_pm_idle_save
r_static
r_void
(paren
op_star
id|pr_pm_idle_save
)paren
(paren
r_void
)paren
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|bm_control
r_static
id|u8
id|bm_control
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Used for PIIX4 errata handling. */
DECL|variable|acpi_piix4_bmisx
r_int
r_int
id|acpi_piix4_bmisx
op_assign
l_int|0
suffix:semicolon
multiline_comment|/****************************************************************************&n; *                             External Functions&n; ****************************************************************************/
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    pr_power_activate_state&n; *&n; * PARAMETERS:&n; *&n; * RETURN:&n; *&n; * DESCRIPTION:&n; *&n; ****************************************************************************/
r_void
DECL|function|pr_power_activate_state
id|pr_power_activate_state
(paren
id|PR_CONTEXT
op_star
id|processor
comma
id|u32
id|next_state
)paren
(brace
id|PROC_NAME
c_func
(paren
l_string|&quot;pr_power_activate_state&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|processor
)paren
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;Invalid (NULL) context.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|processor-&gt;power.state
(braket
id|processor-&gt;power.active_state
)braket
dot
id|promotion.count
op_assign
l_int|0
suffix:semicolon
id|processor-&gt;power.state
(braket
id|processor-&gt;power.active_state
)braket
dot
id|demotion.count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Cleanup from old state.&n;&t; */
r_switch
c_cond
(paren
id|processor-&gt;power.active_state
)paren
(brace
r_case
id|PR_C3
suffix:colon
multiline_comment|/* Disable bus master reload */
id|acpi_hw_register_bit_access
c_func
(paren
id|ACPI_WRITE
comma
id|ACPI_MTX_DO_NOT_LOCK
comma
id|BM_RLD
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Prepare to use new state.&n;&t; */
r_switch
c_cond
(paren
id|next_state
)paren
(brace
r_case
id|PR_C3
suffix:colon
multiline_comment|/* Enable bus master reload */
id|acpi_hw_register_bit_access
c_func
(paren
id|ACPI_WRITE
comma
id|ACPI_MTX_DO_NOT_LOCK
comma
id|BM_RLD
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|processor-&gt;power.active_state
op_assign
id|next_state
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    pr_power_idle&n; *&n; * PARAMETERS:  &lt;none&gt;&n; *&n; * RETURN:&n; *&n; * DESCRIPTION:&n; *&n; ****************************************************************************/
r_void
DECL|function|pr_power_idle
id|pr_power_idle
(paren
r_void
)paren
(brace
id|PR_CX
op_star
id|c_state
op_assign
l_int|NULL
suffix:semicolon
id|u32
id|next_state
op_assign
l_int|0
suffix:semicolon
id|u32
id|start_ticks
comma
id|end_ticks
comma
id|time_elapsed
suffix:semicolon
id|PR_CONTEXT
op_star
id|processor
op_assign
l_int|NULL
suffix:semicolon
id|PROC_NAME
c_func
(paren
l_string|&quot;pr_power_idle&quot;
)paren
suffix:semicolon
id|processor
op_assign
id|processor_list
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|processor
op_logical_or
id|processor-&gt;power.active_state
op_eq
id|PR_C0
)paren
(brace
r_return
suffix:semicolon
)brace
id|next_state
op_assign
id|processor-&gt;power.active_state
suffix:semicolon
multiline_comment|/*&n;&t; * Check OS Idleness:&n;&t; * ------------------&n;&t; * If the OS has been busy (hasn&squot;t called the idle handler in a while)&n;&t; * then automatically demote to the default power state (e.g. C1).&n;&t; *&n;&t; * TBD: Optimize by having scheduler determine business instead&n;&t; *      of having us try to calculate it.&n;&t; */
r_if
c_cond
(paren
id|processor-&gt;power.active_state
op_ne
id|processor-&gt;power.default_state
)paren
(brace
r_if
c_cond
(paren
(paren
id|jiffies
op_minus
id|last_idle_jiffies
)paren
op_ge
id|processor-&gt;power.busy_metric
)paren
(brace
id|next_state
op_assign
id|processor-&gt;power.default_state
suffix:semicolon
r_if
c_cond
(paren
id|next_state
op_ne
id|processor-&gt;power.active_state
)paren
(brace
id|pr_power_activate_state
c_func
(paren
id|processor
comma
id|next_state
)paren
suffix:semicolon
)brace
)brace
)brace
id|disable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Log BM Activity:&n;&t; * ----------------&n;&t; * Read BM_STS and record its value for later use by C3 policy.&n;&t; * (Note that we save the BM_STS values for the last 32 cycles).&n;&t; */
r_if
c_cond
(paren
id|bm_control
)paren
(brace
id|processor-&gt;power.bm_activity
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|acpi_hw_register_bit_access
c_func
(paren
id|ACPI_READ
comma
id|ACPI_MTX_DO_NOT_LOCK
comma
id|BM_STS
)paren
)paren
(brace
id|processor-&gt;power.bm_activity
op_or_assign
l_int|1
suffix:semicolon
id|acpi_hw_register_bit_access
c_func
(paren
id|ACPI_WRITE
comma
id|ACPI_MTX_DO_NOT_LOCK
comma
id|BM_STS
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|acpi_piix4_bmisx
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * PIIX4 Errata:&n;&t;&t;&t; * -------------&n;&t;&t;&t; * This code is a workaround for errata #18 &quot;C3 Power State/&n;&t;&t;&t; * BMIDE and Type-F DMA Livelock&quot; from the July &squot;01 PIIX4&n;&t;&t;&t; * specification update.  Note that BM_STS doesn&squot;t always&n;&t;&t;&t; * reflect the true state of bus mastering activity; forcing&n;&t;&t;&t; * us to manually check the BMIDEA bit of each IDE channel.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|inb_p
c_func
(paren
id|acpi_piix4_bmisx
op_plus
l_int|0x02
)paren
op_amp
l_int|0x01
)paren
op_logical_or
(paren
id|inb_p
c_func
(paren
id|acpi_piix4_bmisx
op_plus
l_int|0x0A
)paren
op_amp
l_int|0x01
)paren
)paren
id|processor-&gt;power.bm_activity
op_or_assign
l_int|1
suffix:semicolon
)brace
)brace
id|c_state
op_assign
op_amp
(paren
id|processor-&gt;power.state
(braket
id|processor-&gt;power.active_state
)braket
)paren
suffix:semicolon
id|c_state-&gt;utilization
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * Sleep:&n;&t; * ------&n;&t; * Invoke the current Cx state to put the processor to sleep.&n;&t; */
r_switch
c_cond
(paren
id|processor-&gt;power.active_state
)paren
(brace
r_case
id|PR_C1
suffix:colon
multiline_comment|/* Invoke C1 */
id|enable
c_func
(paren
)paren
suffix:semicolon
id|halt
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* no C1 time measurement, so just enter some number of times */
id|time_elapsed
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PR_C2
suffix:colon
multiline_comment|/* See how long we&squot;re asleep for */
id|acpi_get_timer
c_func
(paren
op_amp
id|start_ticks
)paren
suffix:semicolon
multiline_comment|/* Invoke C2 */
id|acpi_os_read_port
c_func
(paren
id|processor-&gt;power.p_lvl2
comma
l_int|NULL
comma
l_int|8
)paren
suffix:semicolon
multiline_comment|/* Dummy op - must do something useless after P_LVL2 read */
id|acpi_hw_register_bit_access
c_func
(paren
id|ACPI_READ
comma
id|ACPI_MTX_DO_NOT_LOCK
comma
id|BM_STS
)paren
suffix:semicolon
multiline_comment|/* Compute time elapsed */
id|acpi_get_timer
c_func
(paren
op_amp
id|end_ticks
)paren
suffix:semicolon
multiline_comment|/* Re-enable interrupts */
id|enable
c_func
(paren
)paren
suffix:semicolon
id|acpi_get_timer_duration
c_func
(paren
id|start_ticks
comma
id|end_ticks
comma
op_amp
id|time_elapsed
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PR_C3
suffix:colon
multiline_comment|/* Disable bus master arbitration */
id|acpi_hw_register_bit_access
c_func
(paren
id|ACPI_WRITE
comma
id|ACPI_MTX_DO_NOT_LOCK
comma
id|ARB_DIS
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* See how long we&squot;re asleep for */
id|acpi_get_timer
c_func
(paren
op_amp
id|start_ticks
)paren
suffix:semicolon
multiline_comment|/* Invoke C3 */
id|acpi_os_read_port
c_func
(paren
id|processor-&gt;power.p_lvl3
comma
l_int|NULL
comma
l_int|8
)paren
suffix:semicolon
multiline_comment|/* Dummy op - must do something useless after P_LVL3 read */
id|acpi_hw_register_bit_access
c_func
(paren
id|ACPI_READ
comma
id|ACPI_MTX_DO_NOT_LOCK
comma
id|BM_STS
)paren
suffix:semicolon
multiline_comment|/* Compute time elapsed */
id|acpi_get_timer
c_func
(paren
op_amp
id|end_ticks
)paren
suffix:semicolon
multiline_comment|/* Enable bus master arbitration */
id|acpi_hw_register_bit_access
c_func
(paren
id|ACPI_WRITE
comma
id|ACPI_MTX_DO_NOT_LOCK
comma
id|ARB_DIS
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Re-enable interrupts */
id|enable
c_func
(paren
)paren
suffix:semicolon
id|acpi_get_timer_duration
c_func
(paren
id|start_ticks
comma
id|end_ticks
comma
op_amp
id|time_elapsed
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;Attempt to use unsupported power state C%d.&bslash;n&quot;
comma
id|processor-&gt;power.active_state
)paren
)paren
suffix:semicolon
id|enable
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Promotion?&n;&t; * ----------&n;&t; * Track the number of successful sleeps (time asleep is greater&n;&t; * than time_threshold) and promote when count_threshold is&n;&t; * reached.&n;&t; */
r_if
c_cond
(paren
(paren
id|c_state-&gt;promotion.target_state
)paren
op_logical_and
(paren
id|time_elapsed
op_ge
id|c_state-&gt;promotion.time_threshold
)paren
)paren
(brace
id|c_state-&gt;promotion.count
op_increment
suffix:semicolon
id|c_state-&gt;demotion.count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|c_state-&gt;promotion.count
op_ge
id|c_state-&gt;promotion.count_threshold
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Bus Mastering Activity, if active and used&n;&t;&t;&t; * by this state&squot;s promotion policy, prevents&n;&t;&t;&t; * promotions from occuring.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|bm_control
op_logical_and
op_logical_neg
(paren
id|processor-&gt;power.bm_activity
op_amp
id|c_state-&gt;promotion.bm_threshold
)paren
)paren
(brace
id|next_state
op_assign
id|c_state-&gt;promotion.target_state
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * Demotion?&n;&t; * ---------&n;&t; * Track the number of shorts (time asleep is less than&n;&t; * time_threshold) and demote when count_threshold is reached.&n;&t; */
r_if
c_cond
(paren
id|c_state-&gt;demotion.target_state
)paren
(brace
r_if
c_cond
(paren
id|time_elapsed
OL
id|c_state-&gt;demotion.time_threshold
)paren
(brace
id|c_state-&gt;demotion.count
op_increment
suffix:semicolon
id|c_state-&gt;promotion.count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|c_state-&gt;demotion.count
op_ge
id|c_state-&gt;demotion.count_threshold
)paren
(brace
id|next_state
op_assign
id|c_state-&gt;demotion.target_state
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Bus Mastering Activity, if active and used by this&n;&t;&t; * state&squot;s promotion policy, causes an immediate demotion&n;&t;&t; * to occur.&n;&t;&t; */
r_if
c_cond
(paren
id|bm_control
op_logical_and
(paren
id|processor-&gt;power.bm_activity
op_amp
id|c_state-&gt;demotion.bm_threshold
)paren
)paren
(brace
id|next_state
op_assign
id|c_state-&gt;demotion.target_state
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * New Cx State?&n;&t; * -------------&n;&t; * If we&squot;re going to start using a new Cx state we must clean up&n;&t; * from the previous and prepare to use the new.&n;&t; */
r_if
c_cond
(paren
id|next_state
op_ne
id|processor-&gt;power.active_state
)paren
(brace
id|pr_power_activate_state
c_func
(paren
id|processor
comma
id|next_state
)paren
suffix:semicolon
id|processor-&gt;power.active_state
op_assign
id|processor-&gt;power.active_state
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Track OS Idleness:&n;&t; * ------------------&n;&t; * Record a jiffies timestamp to compute time elapsed between calls&n;&t; * to the idle handler.&n;&t; */
id|last_idle_jiffies
op_assign
id|jiffies
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * FUNCTION:    pr_power_set_default_policy&n; *&n; * PARAMETERS:&n; *&n; * RETURN:&t;&n; *&n; * DESCRIPTION: Sets the default Cx state policy (OS idle handler).  Our&n; *              scheme is to promote quickly to C2 but more conservatively&n; *              to C3.  We&squot;re favoring C2 for its characteristics of low&n; *              latency (quick response), good power savings, and ability&n; *              to allow bus mastering activity.&n; *&n; *              Note that Cx state policy is completely customizable, with&n; *              the goal of having heuristics to alter policy dynamically.&n; *&n; ****************************************************************************/
id|acpi_status
DECL|function|pr_power_set_default_policy
id|pr_power_set_default_policy
(paren
id|PR_CONTEXT
op_star
id|processor
)paren
(brace
id|FUNCTION_TRACE
c_func
(paren
l_string|&quot;pr_power_set_default_policy&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|processor
)paren
(brace
id|return_ACPI_STATUS
c_func
(paren
id|AE_BAD_PARAMETER
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Busy Metric:&n;&t; * ------------&n;&t; * Used to determine when the OS has been busy and thus when&n;&t; * policy should return to using the default Cx state (e.g. C1).&n;&t; * On Linux we use the number of jiffies (scheduler quantums)&n;&t; * that transpire between calls to the idle handler.&n;&t; *&n;&t; * TBD: Linux-specific.&n;&t; */
id|processor-&gt;power.busy_metric
op_assign
l_int|2
suffix:semicolon
multiline_comment|/*&n;&t; * C1:&n;&t; * ---&n;&t; * C1 serves as our default state.  It must be valid.&n;&t; */
r_if
c_cond
(paren
id|processor-&gt;power.state
(braket
id|PR_C1
)braket
dot
id|is_valid
)paren
(brace
id|processor-&gt;power.active_state
op_assign
id|processor-&gt;power.default_state
op_assign
id|PR_C1
suffix:semicolon
)brace
r_else
(brace
id|processor-&gt;power.active_state
op_assign
id|processor-&gt;power.default_state
op_assign
id|PR_C0
suffix:semicolon
id|return_ACPI_STATUS
c_func
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * C2:&n;&t; * ---&n;&t; * Set default C1 promotion and C2 demotion policies.&n;&t; */
r_if
c_cond
(paren
id|processor-&gt;power.state
(braket
id|PR_C2
)braket
dot
id|is_valid
)paren
(brace
multiline_comment|/*&n;&t;&t; * Promote from C1 to C2 anytime we&squot;re asleep in C1 for&n;&t;&t; * longer than two times the C2 latency (to amortize cost&n;&t;&t; * of transition).  Demote from C2 to C1 anytime we&squot;re&n;&t;&t; * asleep in C2 for less than this time.&n;&t;&t; */
id|processor-&gt;power.state
(braket
id|PR_C1
)braket
dot
id|promotion.count_threshold
op_assign
l_int|10
suffix:semicolon
id|processor-&gt;power.state
(braket
id|PR_C1
)braket
dot
id|promotion.time_threshold
op_assign
l_int|2
op_star
id|processor-&gt;power.state
(braket
id|PR_C2
)braket
dot
id|latency
suffix:semicolon
id|processor-&gt;power.state
(braket
id|PR_C1
)braket
dot
id|promotion.target_state
op_assign
id|PR_C2
suffix:semicolon
id|processor-&gt;power.state
(braket
id|PR_C2
)braket
dot
id|demotion.count_threshold
op_assign
l_int|1
suffix:semicolon
id|processor-&gt;power.state
(braket
id|PR_C2
)braket
dot
id|demotion.time_threshold
op_assign
l_int|2
op_star
id|processor-&gt;power.state
(braket
id|PR_C2
)braket
dot
id|latency
suffix:semicolon
id|processor-&gt;power.state
(braket
id|PR_C2
)braket
dot
id|demotion.target_state
op_assign
id|PR_C1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * C3:&n;&t; * ---&n;&t; * Set default C2 promotion and C3 demotion policies.&n;&t; */
r_if
c_cond
(paren
(paren
id|processor-&gt;power.state
(braket
id|PR_C2
)braket
dot
id|is_valid
)paren
op_logical_and
(paren
id|processor-&gt;power.state
(braket
id|PR_C3
)braket
dot
id|is_valid
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Promote from C2 to C3 after 4 cycles of no bus&n;&t;&t; * mastering activity (while maintaining sleep time&n;&t;&t; * criteria).  Demote immediately on a short or&n;&t;&t; * whenever bus mastering activity occurs.&n;&t;&t; */
id|processor-&gt;power.state
(braket
id|PR_C2
)braket
dot
id|promotion.count_threshold
op_assign
l_int|1
suffix:semicolon
id|processor-&gt;power.state
(braket
id|PR_C2
)braket
dot
id|promotion.time_threshold
op_assign
l_int|2
op_star
id|processor-&gt;power.state
(braket
id|PR_C3
)braket
dot
id|latency
suffix:semicolon
id|processor-&gt;power.state
(braket
id|PR_C2
)braket
dot
id|promotion.bm_threshold
op_assign
l_int|0x0000000F
suffix:semicolon
id|processor-&gt;power.state
(braket
id|PR_C2
)braket
dot
id|promotion.target_state
op_assign
id|PR_C3
suffix:semicolon
id|processor-&gt;power.state
(braket
id|PR_C3
)braket
dot
id|demotion.count_threshold
op_assign
l_int|1
suffix:semicolon
id|processor-&gt;power.state
(braket
id|PR_C3
)braket
dot
id|demotion.time_threshold
op_assign
l_int|2
op_star
id|processor-&gt;power.state
(braket
id|PR_C3
)braket
dot
id|latency
suffix:semicolon
id|processor-&gt;power.state
(braket
id|PR_C3
)braket
dot
id|demotion.bm_threshold
op_assign
l_int|0x0000000F
suffix:semicolon
id|processor-&gt;power.state
(braket
id|PR_C3
)braket
dot
id|demotion.target_state
op_assign
id|PR_C2
suffix:semicolon
)brace
id|return_ACPI_STATUS
c_func
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * FUNCTION:    pr_power_add_device&n; *&n; * PARAMETERS:  &lt;none&gt;&n; *&n; * RETURN:&n; *&n; * DESCRIPTION:&n; *&n; ****************************************************************************/
multiline_comment|/*&n; * TBD: 1. PROC_C1 support.&n; *      2. Symmetric Cx state support (different Cx states supported&n; *         by different CPUs results in lowest common denominator).&n; */
id|acpi_status
DECL|function|pr_power_add_device
id|pr_power_add_device
(paren
id|PR_CONTEXT
op_star
id|processor
)paren
(brace
id|FUNCTION_TRACE
c_func
(paren
l_string|&quot;pr_power_add_device&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|processor
)paren
(brace
id|return_ACPI_STATUS
c_func
(paren
id|AE_BAD_PARAMETER
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * State Count:&n;&t; * ------------&n;&t; * Fixed at four (C0-C3).  We use is_valid to determine whether or&n;&t; * not a state actually gets used.&n;&t; */
id|processor-&gt;power.state_count
op_assign
id|PR_MAX_POWER_STATES
suffix:semicolon
multiline_comment|/*&n;&t; * C0:&n;&t; * ---&n;&t; * C0 exists only as filler in our array. (Let&squot;s assume its valid!)&n;&t; */
id|processor-&gt;power.state
(braket
id|PR_C0
)braket
dot
id|is_valid
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/*&n;&t; * C1:&n;&t; * ---&n;&t; * ACPI states that C1 must be supported by all processors&n;&t; * with a latency so small that it can be ignored.&n;&t; *&n;&t; * TBD: What about PROC_C1 support?&n;&t; */
id|processor-&gt;power.state
(braket
id|PR_C1
)braket
dot
id|is_valid
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/*&n;&t; * C2:&n;&t; * ---&n;&t; * We&squot;re only supporting C2 on UP systems with latencies &lt;= 100us.&n;&t; *&n;&t; * TBD: Support for C2 on MP (P_LVL2_UP) -- I&squot;m taking the&n;&t; *      conservative approach for now.&n;&t; */
id|processor-&gt;power.state
(braket
id|PR_C2
)braket
dot
id|latency
op_assign
id|acpi_fadt.plvl2_lat
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_if
c_cond
(paren
id|smp_num_cpus
op_eq
l_int|1
)paren
(brace
macro_line|#endif /*CONFIG_SMP*/
r_if
c_cond
(paren
id|acpi_fadt.plvl2_lat
op_le
id|PR_MAX_C2_LATENCY
)paren
(brace
id|processor-&gt;power.state
(braket
id|PR_C2
)braket
dot
id|is_valid
op_assign
id|TRUE
suffix:semicolon
id|processor-&gt;power.p_lvl2
op_assign
id|processor-&gt;pblk.address
op_plus
l_int|4
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
)brace
macro_line|#endif /*CONFIG_SMP*/
multiline_comment|/*&n;&t; * C3:&n;&t; * ---&n;&t; * We&squot;re only supporting C3 on UP systems with latencies &lt;= 1000us,&n;&t; * and that include the ability to disable bus mastering while in&n;&t; * C3 (ARB_DIS) but allows bus mastering requests to wake the system&n;&t; * from C3 (BM_RLD).  Note his method of maintaining cache coherency&n;&t; * (disabling of bus mastering) cannot be used on SMP systems, and&n;&t; * flushing caches (e.g. WBINVD) is simply too costly at this time.&n;&t; *&n;&t; * TBD: Support for C3 on MP -- I&squot;m taking the conservative&n;&t; *      approach for now.&n;&t; */
id|processor-&gt;power.state
(braket
id|PR_C3
)braket
dot
id|latency
op_assign
id|acpi_fadt.plvl3_lat
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_if
c_cond
(paren
id|smp_num_cpus
op_eq
l_int|1
)paren
(brace
macro_line|#endif /*CONFIG_SMP*/
r_if
c_cond
(paren
(paren
id|acpi_fadt.plvl3_lat
op_le
id|PR_MAX_C3_LATENCY
)paren
op_logical_and
id|bm_control
)paren
(brace
id|processor-&gt;power.state
(braket
id|PR_C3
)braket
dot
id|is_valid
op_assign
id|TRUE
suffix:semicolon
id|processor-&gt;power.p_lvl3
op_assign
id|processor-&gt;pblk.address
op_plus
l_int|5
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
)brace
macro_line|#endif /*CONFIG_SMP*/
multiline_comment|/*&n;&t; * Set Default Policy:&n;&t; * -------------------&n;&t; * Now that we know which state are supported, set the default&n;&t; * policy.  Note that this policy can be changed dynamically&n;&t; * (e.g. encourage deeper sleeps to conserve battery life when&n;&t; * not on AC).&n;&t; */
id|pr_power_set_default_policy
c_func
(paren
id|processor
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Save Processor Context:&n;&t; * -----------------------&n;&t; * TBD: Enhance Linux idle handler to take processor context&n;&t; *      parameter.&n;&t; */
id|processor_list
(braket
id|processor-&gt;uid
)braket
op_assign
id|processor
suffix:semicolon
id|return_ACPI_STATUS
c_func
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    pr_power_remove_device&n; *&n; * PARAMETERS:&n; *&n; * RETURN:&t;&n; *&n; * DESCRIPTION:&n; *&n; ****************************************************************************/
id|acpi_status
DECL|function|pr_power_remove_device
id|pr_power_remove_device
(paren
id|PR_CONTEXT
op_star
id|processor
)paren
(brace
id|acpi_status
id|status
op_assign
id|AE_OK
suffix:semicolon
id|FUNCTION_TRACE
c_func
(paren
l_string|&quot;pr_power_remove_device&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|processor
)paren
(brace
id|return_ACPI_STATUS
c_func
(paren
id|AE_BAD_PARAMETER
)paren
suffix:semicolon
)brace
id|MEMSET
c_func
(paren
op_amp
(paren
id|processor-&gt;power
)paren
comma
l_int|0
comma
r_sizeof
(paren
id|PR_POWER
)paren
)paren
suffix:semicolon
id|processor_list
(braket
id|processor-&gt;uid
)braket
op_assign
l_int|NULL
suffix:semicolon
id|return_ACPI_STATUS
c_func
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    pr_power_initialize&n; *&n; * PARAMETERS:  &lt;none&gt;&n; *&n; * RETURN:&n; *&n; * DESCRIPTION:&n; *&n; ****************************************************************************/
id|acpi_status
DECL|function|pr_power_initialize
id|pr_power_initialize
(paren
r_void
)paren
(brace
id|u32
id|i
op_assign
l_int|0
suffix:semicolon
id|FUNCTION_TRACE
c_func
(paren
l_string|&quot;pr_power_initialize&quot;
)paren
suffix:semicolon
multiline_comment|/* TBD: Linux-specific. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|processor_list
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_INFO
comma
l_string|&quot;Max CPUs[%d], this CPU[%d].&bslash;n&quot;
comma
id|NR_CPUS
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* only use C3 if we can control busmastering */
r_if
c_cond
(paren
id|acpi_fadt.V1_pm2_cnt_blk
op_logical_and
id|acpi_fadt.pm2_cnt_len
)paren
id|bm_control
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Install idle handler.&n;&t; *&n;&t; * TBD: Linux-specific (need OSL function).&n;&t; */
id|pr_pm_idle_save
op_assign
id|pm_idle
suffix:semicolon
id|pm_idle
op_assign
id|pr_power_idle
suffix:semicolon
id|return_ACPI_STATUS
c_func
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    pr_power_terminate&n; *&n; * PARAMETERS:  &lt;none&gt;&n; *&n; * RETURN:&n; *&n; * DESCRIPTION:&n; *&n; ****************************************************************************/
id|acpi_status
DECL|function|pr_power_terminate
id|pr_power_terminate
(paren
r_void
)paren
(brace
id|FUNCTION_TRACE
c_func
(paren
l_string|&quot;pr_power_terminate&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Remove idle handler.&n;&t; *&n;&t; * TBD: Linux-specific (need OSL function).&n;&t; */
id|pm_idle
op_assign
id|pr_pm_idle_save
suffix:semicolon
id|return_ACPI_STATUS
c_func
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
eof
