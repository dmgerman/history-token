multiline_comment|/*&n; *  asus_acpi.c - Asus Laptop ACPI Extras&n; *&n; *&n; *  Copyright (C) 2002, 2003 Julien Lerouge, Karol Kozimor&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; *&n; *&n; *  The development page for this driver is located at&n; *  http://sourceforge.net/projects/acpi4asus/&n; *&n; *  Credits:&n; *  Johann Wiesner - Small compile fixes&n; *  John Belmonte  - ACPI code for Toshiba laptop was a good starting point.&n; *&n; *  TODO:&n; *  add Fn key status&n; *  Add mode selection on module loading (parameter) -&gt; still necessary?&n; *  Complete display switching -- may require dirty hacks?&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;acpi/acpi_drivers.h&gt;
macro_line|#include &lt;acpi/acpi_bus.h&gt;
DECL|macro|ASUS_ACPI_VERSION
mdefine_line|#define ASUS_ACPI_VERSION &quot;0.26&quot;
DECL|macro|PROC_ASUS
mdefine_line|#define PROC_ASUS       &quot;asus&quot;&t;
singleline_comment|//the directory
DECL|macro|PROC_MLED
mdefine_line|#define PROC_MLED       &quot;mled&quot;
DECL|macro|PROC_WLED
mdefine_line|#define PROC_WLED       &quot;wled&quot;
DECL|macro|PROC_INFOS
mdefine_line|#define PROC_INFOS      &quot;info&quot;
DECL|macro|PROC_LCD
mdefine_line|#define PROC_LCD        &quot;lcd&quot;
DECL|macro|PROC_BRN
mdefine_line|#define PROC_BRN        &quot;brn&quot;
DECL|macro|PROC_DISP
mdefine_line|#define PROC_DISP       &quot;disp&quot;
DECL|macro|ACPI_HOTK_NAME
mdefine_line|#define ACPI_HOTK_NAME          &quot;Asus Laptop ACPI Extras Driver&quot;
DECL|macro|ACPI_HOTK_CLASS
mdefine_line|#define ACPI_HOTK_CLASS         &quot;hotkey&quot;
DECL|macro|ACPI_HOTK_DEVICE_NAME
mdefine_line|#define ACPI_HOTK_DEVICE_NAME   &quot;Hotkey&quot;
DECL|macro|ACPI_HOTK_HID
mdefine_line|#define ACPI_HOTK_HID           &quot;ATK0100&quot;
multiline_comment|/*&n; * Some events we use, same for all Asus&n; */
DECL|macro|BR_UP
mdefine_line|#define BR_UP       0x10      &t;&t;
DECL|macro|BR_DOWN
mdefine_line|#define BR_DOWN     0x20
multiline_comment|/*&n; * Flags for hotk status&n; */
DECL|macro|MLED_ON
mdefine_line|#define MLED_ON     0x01&t;
singleline_comment|//is MLED ON ?
DECL|macro|WLED_ON
mdefine_line|#define WLED_ON     0x02
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Julien Lerouge, Karol Kozimor&quot;
)paren
suffix:semicolon
DECL|variable|ACPI_HOTK_NAME
id|MODULE_DESCRIPTION
c_func
(paren
id|ACPI_HOTK_NAME
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|variable|asus_uid
r_static
id|uid_t
id|asus_uid
suffix:semicolon
DECL|variable|asus_gid
r_static
id|gid_t
id|asus_gid
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|asus_uid
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|uid
comma
l_string|&quot;UID for entries in /proc/acpi/asus.&bslash;n&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|asus_gid
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|gid
comma
l_string|&quot;GID for entries in /proc/acpi/asus.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* For each model, all features implemented */
DECL|struct|model_data
r_struct
id|model_data
(brace
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
singleline_comment|//name of the laptop
DECL|member|mt_mled
r_char
op_star
id|mt_mled
suffix:semicolon
singleline_comment|//method to handle mled
DECL|member|mled_status
r_char
op_star
id|mled_status
suffix:semicolon
singleline_comment|//node to handle mled reading
DECL|member|mt_wled
r_char
op_star
id|mt_wled
suffix:semicolon
singleline_comment|//method to handle wled
DECL|member|wled_status
r_char
op_star
id|wled_status
suffix:semicolon
singleline_comment|//node to handle wled reading
DECL|member|mt_lcd_switch
r_char
op_star
id|mt_lcd_switch
suffix:semicolon
singleline_comment|//method to turn LCD ON/OFF
DECL|member|lcd_status
r_char
op_star
id|lcd_status
suffix:semicolon
singleline_comment|//node to read LCD panel state
DECL|member|brightness_up
r_char
op_star
id|brightness_up
suffix:semicolon
singleline_comment|//method to set brightness up
DECL|member|brightness_down
r_char
op_star
id|brightness_down
suffix:semicolon
singleline_comment|//guess what ?
DECL|member|brightness_set
r_char
op_star
id|brightness_set
suffix:semicolon
singleline_comment|//method to set absolute brightness
DECL|member|brightness_get
r_char
op_star
id|brightness_get
suffix:semicolon
singleline_comment|//method to get absolute brightness
DECL|member|brightness_status
r_char
op_star
id|brightness_status
suffix:semicolon
singleline_comment|//node to get brightness
DECL|member|display_set
r_char
op_star
id|display_set
suffix:semicolon
singleline_comment|//method to set video output
DECL|member|display_get
r_char
op_star
id|display_get
suffix:semicolon
singleline_comment|//method to get video output
)brace
suffix:semicolon
multiline_comment|/*&n; * This is the main structure, we can use it to store anything interesting&n; * about the hotk device&n; */
DECL|struct|asus_hotk
r_struct
id|asus_hotk
(brace
DECL|member|device
r_struct
id|acpi_device
op_star
id|device
suffix:semicolon
singleline_comment|//the device we are in
DECL|member|handle
id|acpi_handle
id|handle
suffix:semicolon
singleline_comment|//the handle of the hotk device
DECL|member|status
r_char
id|status
suffix:semicolon
singleline_comment|//status of the hotk, for LEDs, ...
DECL|member|methods
r_struct
id|model_data
op_star
id|methods
suffix:semicolon
singleline_comment|//methods available on the laptop
DECL|member|brightness
id|u8
id|brightness
suffix:semicolon
singleline_comment|//brighness level
r_enum
(brace
DECL|enumerator|A1X
id|A1X
op_assign
l_int|0
comma
singleline_comment|//A1340D, A1300F
DECL|enumerator|A2X
id|A2X
comma
singleline_comment|//A2500H
DECL|enumerator|D1X
id|D1X
comma
singleline_comment|//D1
DECL|enumerator|L1X
id|L1X
comma
singleline_comment|//L1400B
DECL|enumerator|L2X
id|L2X
comma
singleline_comment|//L2000D -&gt; TODO check Q11 (Fn+F8)
singleline_comment|//&t;   Calling this method simply hangs the
singleline_comment|//&t;   computer, ISMI method hangs the laptop.
DECL|enumerator|L3D
id|L3D
comma
singleline_comment|//L3400D
DECL|enumerator|L3X
id|L3X
comma
singleline_comment|//L3C
DECL|enumerator|L5X
id|L5X
comma
singleline_comment|//L5C TODO this model seems to have one more
singleline_comment|//         LED, add support
DECL|enumerator|M2X
id|M2X
comma
singleline_comment|//M2400E
DECL|enumerator|M3N
id|M3N
comma
singleline_comment|//M3700N, but also S1300N -&gt; TODO WLED
DECL|enumerator|S1X
id|S1X
comma
singleline_comment|//S1300A -&gt; TODO special keys do not work ?
DECL|enumerator|S2X
id|S2X
comma
singleline_comment|//S200 (J1 reported), Victor MP-XP7210
singleline_comment|//TODO  A1370D does not seem to have an ATK device 
singleline_comment|//&t;L8400 model doesn&squot;t have ATK
DECL|enumerator|END_MODEL
id|END_MODEL
DECL|member|model
)brace
id|model
suffix:semicolon
singleline_comment|//Models currently supported
DECL|member|event_count
id|u16
id|event_count
(braket
l_int|128
)braket
suffix:semicolon
singleline_comment|//count for each event TODO make this better
)brace
suffix:semicolon
multiline_comment|/* Here we go */
DECL|macro|L3X_PREFIX
mdefine_line|#define L3X_PREFIX &quot;&bslash;&bslash;_SB.PCI0.PX40.ECD0.&quot;
DECL|macro|S1X_PREFIX
mdefine_line|#define S1X_PREFIX &quot;&bslash;&bslash;_SB.PCI0.PX40.&quot;
DECL|macro|L1X_PREFIX
mdefine_line|#define L1X_PREFIX S1X_PREFIX
DECL|macro|A1X_PREFIX
mdefine_line|#define A1X_PREFIX &quot;&bslash;&bslash;_SB.PCI0.ISA.EC0.&quot;
DECL|macro|S2X_PREFIX
mdefine_line|#define S2X_PREFIX A1X_PREFIX
DECL|macro|M3N_PREFIX
mdefine_line|#define M3N_PREFIX &quot;&bslash;&bslash;_SB.PCI0.SBRG.EC0.&quot;
DECL|variable|model_conf
r_static
r_struct
id|model_data
id|model_conf
(braket
id|END_MODEL
)braket
op_assign
(brace
multiline_comment|/*&n;&t; * name|  mled |mled read|  wled |wled read| lcd sw |lcd read | &n;&t; * br up|br down | br set | br read | br status|set disp | get disp&n;&t; *&n;&t; * br set and read shall be in hotk device !&n;&t; * same for set disp&n;&t; *&n;&t; * TODO I have seen a SWBX and AIBX method on some models, like L1400B,&n;&t; * it seems to be a kind of switch, but what for ?&n;&t; *&n;&t; */
(brace
l_string|&quot;A1X&quot;
comma
l_string|&quot;MLED&quot;
comma
l_string|&quot;&bslash;&bslash;MAIL&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
id|A1X_PREFIX
l_string|&quot;_Q10&quot;
comma
l_string|&quot;&bslash;&bslash;BKLI&quot;
comma
id|A1X_PREFIX
l_string|&quot;_Q0E&quot;
comma
id|A1X_PREFIX
l_string|&quot;_Q0F&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;A2X&quot;
comma
l_string|&quot;MLED&quot;
comma
l_int|NULL
comma
l_string|&quot;WLED&quot;
comma
l_string|&quot;&bslash;&bslash;SG66&quot;
comma
l_string|&quot;&bslash;&bslash;Q10&quot;
comma
l_string|&quot;&bslash;&bslash;BAOF&quot;
comma
l_string|&quot;&bslash;&bslash;Q0E&quot;
comma
l_string|&quot;&bslash;&bslash;Q0F&quot;
comma
l_string|&quot;SPLV&quot;
comma
l_string|&quot;GPLV&quot;
comma
l_string|&quot;&bslash;&bslash;CMOD&quot;
comma
l_string|&quot;SDSP&quot;
comma
l_string|&quot;&bslash;&bslash;INFB&quot;
)brace
comma
(brace
l_string|&quot;D1X&quot;
comma
l_string|&quot;MLED&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;&bslash;&bslash;Q0D&quot;
comma
l_string|&quot;&bslash;&bslash;GP11&quot;
comma
l_string|&quot;&bslash;&bslash;Q0C&quot;
comma
l_string|&quot;&bslash;&bslash;Q0B&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;&bslash;&bslash;BLVL&quot;
comma
l_string|&quot;SDSP&quot;
comma
l_string|&quot;&bslash;&bslash;INFB&quot;
)brace
comma
(brace
l_string|&quot;L1X&quot;
comma
l_string|&quot;MLED&quot;
comma
l_int|NULL
comma
l_string|&quot;WLED&quot;
comma
l_int|NULL
comma
id|L1X_PREFIX
l_string|&quot;Q10&quot;
comma
l_string|&quot;&bslash;&bslash;PNOF&quot;
comma
id|L1X_PREFIX
l_string|&quot;Q0F&quot;
comma
id|L1X_PREFIX
l_string|&quot;Q0E&quot;
comma
l_string|&quot;SPLV&quot;
comma
l_string|&quot;GPLV&quot;
comma
l_string|&quot;&bslash;&bslash;BRIT&quot;
comma
l_int|NULL
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;L2X&quot;
comma
l_string|&quot;MLED&quot;
comma
l_string|&quot;&bslash;&bslash;SGP6&quot;
comma
l_string|&quot;WLED&quot;
comma
l_string|&quot;&bslash;&bslash;RCP3&quot;
comma
l_string|&quot;&bslash;&bslash;Q10&quot;
comma
l_string|&quot;&bslash;&bslash;SGP0&quot;
comma
l_string|&quot;&bslash;&bslash;Q0E&quot;
comma
l_string|&quot;&bslash;&bslash;Q0F&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;SDSP&quot;
comma
l_string|&quot;&bslash;&bslash;INFB&quot;
)brace
comma
(brace
l_string|&quot;L3D&quot;
comma
l_string|&quot;MLED&quot;
comma
l_string|&quot;&bslash;&bslash;MALD&quot;
comma
l_string|&quot;WLED&quot;
comma
l_int|NULL
comma
l_string|&quot;&bslash;&bslash;Q10&quot;
comma
l_string|&quot;&bslash;&bslash;BKLG&quot;
comma
l_string|&quot;&bslash;&bslash;Q0E&quot;
comma
l_string|&quot;&bslash;&bslash;Q0F&quot;
comma
l_string|&quot;SPLV&quot;
comma
l_string|&quot;GPLV&quot;
comma
l_string|&quot;&bslash;&bslash;BLVL&quot;
comma
l_string|&quot;SDSP&quot;
comma
l_string|&quot;&bslash;&bslash;INFB&quot;
)brace
comma
(brace
l_string|&quot;L3X&quot;
comma
l_string|&quot;MLED&quot;
comma
l_int|NULL
comma
l_string|&quot;WLED&quot;
comma
l_int|NULL
comma
id|L3X_PREFIX
l_string|&quot;_Q10&quot;
comma
l_string|&quot;&bslash;&bslash;GL32&quot;
comma
id|L3X_PREFIX
l_string|&quot;_Q0F&quot;
comma
id|L3X_PREFIX
l_string|&quot;_Q0E&quot;
comma
l_string|&quot;SPLV&quot;
comma
l_string|&quot;GPLV&quot;
comma
l_string|&quot;&bslash;&bslash;BLVL&quot;
comma
l_string|&quot;SDSP&quot;
comma
l_string|&quot;&bslash;&bslash;_SB.PCI0.PCI1.VGAC.NMAP&quot;
)brace
comma
(brace
l_string|&quot;L5X&quot;
comma
l_string|&quot;MLED&quot;
comma
l_int|NULL
comma
l_string|&quot;WLED&quot;
comma
l_string|&quot;WRED&quot;
comma
l_string|&quot;&bslash;&bslash;Q0D&quot;
comma
l_string|&quot;&bslash;&bslash;BAOF&quot;
comma
l_string|&quot;&bslash;&bslash;Q0C&quot;
comma
l_string|&quot;&bslash;&bslash;Q0B&quot;
comma
l_string|&quot;SPLV&quot;
comma
l_string|&quot;GPLV&quot;
comma
l_int|NULL
comma
l_string|&quot;SDSP&quot;
comma
l_string|&quot;&bslash;&bslash;INFB&quot;
)brace
comma
(brace
l_string|&quot;M2X&quot;
comma
l_string|&quot;MLED&quot;
comma
l_int|NULL
comma
l_string|&quot;WLED&quot;
comma
l_int|NULL
comma
l_string|&quot;&bslash;&bslash;Q10&quot;
comma
l_string|&quot;&bslash;&bslash;GP06&quot;
comma
l_string|&quot;&bslash;&bslash;Q0E&quot;
comma
l_string|&quot;&bslash;&bslash;Q0F&quot;
comma
l_string|&quot;SPLV&quot;
comma
l_string|&quot;GPLV&quot;
comma
l_int|NULL
comma
l_string|&quot;SDSP&quot;
comma
l_string|&quot;&bslash;&bslash;INFB&quot;
)brace
comma
(brace
l_string|&quot;M3N&quot;
comma
l_string|&quot;MLED&quot;
comma
l_int|NULL
comma
l_string|&quot;WLED&quot;
comma
l_string|&quot;&bslash;&bslash;PO33&quot;
comma
id|M3N_PREFIX
l_string|&quot;_Q10&quot;
comma
l_string|&quot;&bslash;&bslash;BKLT&quot;
comma
id|M3N_PREFIX
l_string|&quot;_Q0F&quot;
comma
id|M3N_PREFIX
l_string|&quot;_Q0E&quot;
comma
l_string|&quot;SPLV&quot;
comma
l_string|&quot;GPLV&quot;
comma
l_string|&quot;&bslash;&bslash;LBTN&quot;
comma
l_string|&quot;SDSP&quot;
comma
l_string|&quot;&bslash;&bslash;ADVG&quot;
)brace
comma
(brace
l_string|&quot;S1X&quot;
comma
l_string|&quot;MLED&quot;
comma
l_string|&quot;&bslash;&bslash;EMLE&quot;
comma
l_string|&quot;WLED&quot;
comma
l_int|NULL
comma
id|S1X_PREFIX
l_string|&quot;Q10&quot;
comma
l_string|&quot;&bslash;&bslash;PNOF&quot;
comma
id|S1X_PREFIX
l_string|&quot;Q0F&quot;
comma
id|S1X_PREFIX
l_string|&quot;Q0E&quot;
comma
l_string|&quot;SPLV&quot;
comma
l_string|&quot;GPLV&quot;
comma
l_string|&quot;&bslash;&bslash;BRIT&quot;
comma
l_int|NULL
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;S2X&quot;
comma
l_string|&quot;MLED&quot;
comma
l_string|&quot;&bslash;&bslash;MAIL&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
id|S2X_PREFIX
l_string|&quot;_Q10&quot;
comma
l_string|&quot;&bslash;&bslash;BKLI&quot;
comma
id|S2X_PREFIX
l_string|&quot;_Q0B&quot;
comma
id|S2X_PREFIX
l_string|&quot;_Q0A&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
)brace
suffix:semicolon
multiline_comment|/* procdir we use */
DECL|variable|asus_proc_dir
r_static
r_struct
id|proc_dir_entry
op_star
id|asus_proc_dir
suffix:semicolon
multiline_comment|/*&n; * This header is made available to allow proper configuration given model,&n; * revision number , ... this info cannot go in struct asus_hotk because it is&n; * available before the hotk&n; */
DECL|variable|asus_info
r_static
r_struct
id|acpi_table_header
op_star
id|asus_info
suffix:semicolon
multiline_comment|/*&n; * The hotkey driver declaration&n; */
r_static
r_int
id|asus_hotk_add
c_func
(paren
r_struct
id|acpi_device
op_star
id|device
)paren
suffix:semicolon
r_static
r_int
id|asus_hotk_remove
c_func
(paren
r_struct
id|acpi_device
op_star
id|device
comma
r_int
id|type
)paren
suffix:semicolon
DECL|variable|asus_hotk_driver
r_static
r_struct
id|acpi_driver
id|asus_hotk_driver
op_assign
(brace
dot
id|name
op_assign
id|ACPI_HOTK_NAME
comma
dot
r_class
op_assign
id|ACPI_HOTK_CLASS
comma
dot
id|ids
op_assign
id|ACPI_HOTK_HID
comma
dot
id|ops
op_assign
(brace
dot
id|add
op_assign
id|asus_hotk_add
comma
dot
id|remove
op_assign
id|asus_hotk_remove
comma
)brace
comma
)brace
suffix:semicolon
multiline_comment|/* &n; * This function evaluates an ACPI method, given an int as parameter, the&n; * method is searched within the scope of the handle, can be NULL. The output&n; * of the method is written is output, which can also be NULL&n; *&n; * returns 1 if write is successful, 0 else. &n; */
DECL|function|write_acpi_int
r_static
r_int
id|write_acpi_int
c_func
(paren
id|acpi_handle
id|handle
comma
r_const
r_char
op_star
id|method
comma
r_int
id|val
comma
r_struct
id|acpi_buffer
op_star
id|output
)paren
(brace
r_struct
id|acpi_object_list
id|params
suffix:semicolon
singleline_comment|//list of input parameters (an int here)
r_union
id|acpi_object
id|in_obj
suffix:semicolon
singleline_comment|//the only param we use
id|acpi_status
id|status
suffix:semicolon
id|params.count
op_assign
l_int|1
suffix:semicolon
id|params.pointer
op_assign
op_amp
id|in_obj
suffix:semicolon
id|in_obj.type
op_assign
id|ACPI_TYPE_INTEGER
suffix:semicolon
id|in_obj.integer.value
op_assign
id|val
suffix:semicolon
id|status
op_assign
id|acpi_evaluate_object
c_func
(paren
id|handle
comma
(paren
r_char
op_star
)paren
id|method
comma
op_amp
id|params
comma
id|output
)paren
suffix:semicolon
r_return
(paren
id|status
op_eq
id|AE_OK
)paren
suffix:semicolon
)brace
DECL|function|read_acpi_int
r_static
r_int
id|read_acpi_int
c_func
(paren
id|acpi_handle
id|handle
comma
r_const
r_char
op_star
id|method
comma
r_int
op_star
id|val
)paren
(brace
r_struct
id|acpi_buffer
id|output
suffix:semicolon
r_union
id|acpi_object
id|out_obj
suffix:semicolon
id|acpi_status
id|status
suffix:semicolon
id|output.length
op_assign
r_sizeof
(paren
id|out_obj
)paren
suffix:semicolon
id|output.pointer
op_assign
op_amp
id|out_obj
suffix:semicolon
id|status
op_assign
id|acpi_evaluate_object
c_func
(paren
id|handle
comma
(paren
r_char
op_star
)paren
id|method
comma
l_int|NULL
comma
op_amp
id|output
)paren
suffix:semicolon
op_star
id|val
op_assign
id|out_obj.integer.value
suffix:semicolon
r_return
(paren
id|status
op_eq
id|AE_OK
)paren
op_logical_and
(paren
id|out_obj.type
op_eq
id|ACPI_TYPE_INTEGER
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * We write our info in page, we begin at offset off and cannot write more&n; * than count bytes. We set eof to 1 if we handle those 2 values. We return the&n; * number of bytes written in page&n; */
r_static
r_int
DECL|function|proc_read_info
id|proc_read_info
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_int
id|sfun
suffix:semicolon
r_struct
id|asus_hotk
op_star
id|hotk
op_assign
(paren
r_struct
id|asus_hotk
op_star
)paren
id|data
suffix:semicolon
r_char
id|buf
(braket
l_int|16
)braket
suffix:semicolon
singleline_comment|//enough for all info
multiline_comment|/*&n;&t; * We use the easy way, we don&squot;t care of off and count, so we don&squot;t set eof&n;&t; * to 1&n;&t; */
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
comma
id|ACPI_HOTK_NAME
l_string|&quot; &quot;
id|ASUS_ACPI_VERSION
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;Model reference    : %s&bslash;n&quot;
comma
id|hotk-&gt;methods-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_acpi_int
c_func
(paren
id|hotk-&gt;handle
comma
l_string|&quot;SFUN&quot;
comma
op_amp
id|sfun
)paren
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;SFUN value         : 0x%04x&bslash;n&quot;
comma
id|sfun
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|asus_info
)paren
(brace
id|snprintf
c_func
(paren
id|buf
comma
l_int|16
comma
l_string|&quot;%d&quot;
comma
id|asus_info-&gt;length
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;DSDT length        : %s&bslash;n&quot;
comma
id|buf
)paren
suffix:semicolon
id|snprintf
c_func
(paren
id|buf
comma
l_int|16
comma
l_string|&quot;%d&quot;
comma
id|asus_info-&gt;checksum
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;DSDT checksum      : %s&bslash;n&quot;
comma
id|buf
)paren
suffix:semicolon
id|snprintf
c_func
(paren
id|buf
comma
l_int|16
comma
l_string|&quot;%d&quot;
comma
id|asus_info-&gt;revision
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;DSDT revision      : %s&bslash;n&quot;
comma
id|buf
)paren
suffix:semicolon
id|snprintf
c_func
(paren
id|buf
comma
l_int|7
comma
l_string|&quot;%s&quot;
comma
id|asus_info-&gt;oem_id
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;OEM id             : %s&bslash;n&quot;
comma
id|buf
)paren
suffix:semicolon
id|snprintf
c_func
(paren
id|buf
comma
l_int|9
comma
l_string|&quot;%s&quot;
comma
id|asus_info-&gt;oem_table_id
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;OEM table id       : %s&bslash;n&quot;
comma
id|buf
)paren
suffix:semicolon
id|snprintf
c_func
(paren
id|buf
comma
l_int|16
comma
l_string|&quot;%x&quot;
comma
id|asus_info-&gt;oem_revision
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;OEM revision       : 0x%s&bslash;n&quot;
comma
id|buf
)paren
suffix:semicolon
id|snprintf
c_func
(paren
id|buf
comma
l_int|5
comma
l_string|&quot;%s&quot;
comma
id|asus_info-&gt;asl_compiler_id
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;ASL comp vendor id : %s&bslash;n&quot;
comma
id|buf
)paren
suffix:semicolon
id|snprintf
c_func
(paren
id|buf
comma
l_int|16
comma
l_string|&quot;%x&quot;
comma
id|asus_info-&gt;asl_compiler_revision
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;ASL comp revision  : 0x%s&bslash;n&quot;
comma
id|buf
)paren
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/* &n; * proc file handlers&n; */
r_static
r_int
DECL|function|proc_read_mled
id|proc_read_mled
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_struct
id|asus_hotk
op_star
id|hotk
op_assign
(paren
r_struct
id|asus_hotk
op_star
)paren
id|data
suffix:semicolon
r_int
id|led_status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * We use the easy way, we don&squot;t care of off and count, so we don&squot;t set eof&n;&t; * to 1&n;&t; */
r_if
c_cond
(paren
id|hotk-&gt;methods-&gt;mled_status
)paren
(brace
r_if
c_cond
(paren
id|read_acpi_int
c_func
(paren
l_int|NULL
comma
id|hotk-&gt;methods-&gt;mled_status
comma
op_amp
id|led_status
)paren
)paren
id|len
op_assign
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|led_status
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Asus ACPI: Error reading MLED &quot;
l_string|&quot;status&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|len
op_assign
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;%d&bslash;n&quot;
comma
(paren
id|hotk-&gt;status
op_amp
id|MLED_ON
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
r_static
r_int
DECL|function|proc_write_mled
id|proc_write_mled
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
r_int
id|count
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|value
suffix:semicolon
r_int
id|led_out
op_assign
l_int|0
suffix:semicolon
r_struct
id|asus_hotk
op_star
id|hotk
op_assign
(paren
r_struct
id|asus_hotk
op_star
)paren
id|data
suffix:semicolon
multiline_comment|/* scan expression.  Multiple expressions may be delimited with ; */
r_if
c_cond
(paren
id|sscanf
c_func
(paren
id|buffer
comma
l_string|&quot;%i&quot;
comma
op_amp
id|value
)paren
op_eq
l_int|1
)paren
id|led_out
op_assign
op_complement
id|value
op_amp
l_int|1
suffix:semicolon
id|hotk-&gt;status
op_assign
(paren
id|value
)paren
ques
c_cond
(paren
id|hotk-&gt;status
op_or
id|MLED_ON
)paren
suffix:colon
(paren
id|hotk-&gt;status
op_amp
op_complement
id|MLED_ON
)paren
suffix:semicolon
multiline_comment|/* We don&squot;t have to check mt_mled exists if we are here :) */
r_if
c_cond
(paren
op_logical_neg
id|write_acpi_int
c_func
(paren
id|hotk-&gt;handle
comma
id|hotk-&gt;methods-&gt;mt_mled
comma
id|led_out
comma
l_int|NULL
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Asus ACPI: MLED write failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/*&n; * We write our info in page, we begin at offset off and cannot write more&n; * than count bytes. We set eof to 1 if we handle those 2 values. We return the&n; * number of bytes written in page&n; */
r_static
r_int
DECL|function|proc_read_wled
id|proc_read_wled
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_struct
id|asus_hotk
op_star
id|hotk
op_assign
(paren
r_struct
id|asus_hotk
op_star
)paren
id|data
suffix:semicolon
r_int
id|led_status
suffix:semicolon
r_if
c_cond
(paren
id|hotk-&gt;methods-&gt;wled_status
)paren
(brace
r_if
c_cond
(paren
id|read_acpi_int
c_func
(paren
l_int|NULL
comma
id|hotk-&gt;methods-&gt;wled_status
comma
op_amp
id|led_status
)paren
)paren
id|len
op_assign
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|led_status
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Asus ACPI: Error reading WLED &quot;
l_string|&quot;status&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|len
op_assign
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;%d&bslash;n&quot;
comma
(paren
id|hotk-&gt;status
op_amp
id|WLED_ON
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
r_static
r_int
DECL|function|proc_write_wled
id|proc_write_wled
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
r_int
id|count
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|value
suffix:semicolon
r_int
id|led_out
op_assign
l_int|0
suffix:semicolon
r_struct
id|asus_hotk
op_star
id|hotk
op_assign
(paren
r_struct
id|asus_hotk
op_star
)paren
id|data
suffix:semicolon
multiline_comment|/* scan expression.  Multiple expressions may be delimited with ; */
r_if
c_cond
(paren
id|sscanf
c_func
(paren
id|buffer
comma
l_string|&quot;%i&quot;
comma
op_amp
id|value
)paren
op_eq
l_int|1
)paren
id|led_out
op_assign
id|value
op_amp
l_int|1
suffix:semicolon
id|hotk-&gt;status
op_assign
(paren
id|value
)paren
ques
c_cond
(paren
id|hotk-&gt;status
op_or
id|WLED_ON
)paren
suffix:colon
(paren
id|hotk-&gt;status
op_amp
op_complement
id|WLED_ON
)paren
suffix:semicolon
multiline_comment|/* We don&squot;t have to check if mt_wled exists if we are here :) */
r_if
c_cond
(paren
op_logical_neg
id|write_acpi_int
c_func
(paren
id|hotk-&gt;handle
comma
id|hotk-&gt;methods-&gt;mt_wled
comma
id|led_out
comma
l_int|NULL
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Asus ACPI: WLED write failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
DECL|function|get_lcd_state
r_static
r_int
id|get_lcd_state
c_func
(paren
r_struct
id|asus_hotk
op_star
id|hotk
)paren
(brace
r_int
id|lcd
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We don&squot;t have to check anything, if we are here */
r_if
c_cond
(paren
op_logical_neg
id|read_acpi_int
c_func
(paren
l_int|NULL
comma
id|hotk-&gt;methods-&gt;lcd_status
comma
op_amp
id|lcd
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Asus ACPI: Error reading LCD status&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hotk-&gt;model
op_eq
id|L2X
)paren
id|lcd
op_assign
op_complement
id|lcd
suffix:semicolon
r_return
(paren
id|lcd
op_amp
l_int|1
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|proc_read_lcd
id|proc_read_lcd
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_return
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|get_lcd_state
c_func
(paren
(paren
r_struct
id|asus_hotk
op_star
)paren
id|data
)paren
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|proc_write_lcd
id|proc_write_lcd
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
r_int
id|count
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|value
suffix:semicolon
r_int
id|lcd
op_assign
l_int|0
suffix:semicolon
id|acpi_status
id|status
op_assign
l_int|0
suffix:semicolon
r_int
id|lcd_status
op_assign
l_int|0
suffix:semicolon
r_struct
id|asus_hotk
op_star
id|hotk
op_assign
(paren
r_struct
id|asus_hotk
op_star
)paren
id|data
suffix:semicolon
multiline_comment|/* scan expression.  Multiple expressions may be delimited with ; */
r_if
c_cond
(paren
id|sscanf
c_func
(paren
id|buffer
comma
l_string|&quot;%i&quot;
comma
op_amp
id|value
)paren
op_eq
l_int|1
)paren
id|lcd
op_assign
id|value
op_amp
l_int|1
suffix:semicolon
id|lcd_status
op_assign
id|get_lcd_state
c_func
(paren
id|hotk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lcd_status
op_ne
id|lcd
)paren
(brace
multiline_comment|/* switch */
id|status
op_assign
id|acpi_evaluate_object
c_func
(paren
l_int|NULL
comma
id|hotk-&gt;methods-&gt;mt_lcd_switch
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
c_func
(paren
id|status
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Asus ACPI: Error switching LCD&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/*&n; * Change the brightness level&n; */
DECL|function|set_brightness
r_static
r_void
id|set_brightness
c_func
(paren
r_int
id|value
comma
r_struct
id|asus_hotk
op_star
id|hotk
)paren
(brace
id|acpi_status
id|status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* SPLV laptop */
r_if
c_cond
(paren
id|hotk-&gt;methods-&gt;brightness_set
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|write_acpi_int
c_func
(paren
id|hotk-&gt;handle
comma
id|hotk-&gt;methods-&gt;brightness_set
comma
id|value
comma
l_int|NULL
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Asus ACPI: Error changing brightness&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* No SPLV method if we are here, act as appropriate */
id|value
op_sub_assign
id|hotk-&gt;brightness
suffix:semicolon
r_while
c_loop
(paren
id|value
op_ne
l_int|0
)paren
(brace
id|status
op_assign
id|acpi_evaluate_object
c_func
(paren
l_int|NULL
comma
(paren
id|value
OG
l_int|0
)paren
ques
c_cond
id|hotk-&gt;methods-&gt;brightness_up
suffix:colon
id|hotk-&gt;methods-&gt;brightness_down
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
(paren
id|value
OG
l_int|0
)paren
ques
c_cond
id|value
op_decrement
suffix:colon
id|value
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
c_func
(paren
id|status
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Asus ACPI: Error changing brightness&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|read_brightness
r_static
r_int
id|read_brightness
c_func
(paren
r_struct
id|asus_hotk
op_star
id|hotk
)paren
(brace
r_int
id|value
suffix:semicolon
r_if
c_cond
(paren
id|hotk-&gt;methods-&gt;brightness_get
)paren
(brace
multiline_comment|/* SPLV/GPLV laptop */
r_if
c_cond
(paren
op_logical_neg
id|read_acpi_int
c_func
(paren
id|hotk-&gt;handle
comma
id|hotk-&gt;methods-&gt;brightness_get
comma
op_amp
id|value
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Asus ACPI: Error reading brightness&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|hotk-&gt;methods-&gt;brightness_status
)paren
(brace
multiline_comment|/* For D1 for example */
r_if
c_cond
(paren
op_logical_neg
id|read_acpi_int
c_func
(paren
l_int|NULL
comma
id|hotk-&gt;methods-&gt;brightness_status
comma
op_amp
id|value
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Asus ACPI: Error reading brightness&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* No GPLV method */
id|value
op_assign
id|hotk-&gt;brightness
suffix:semicolon
r_return
id|value
suffix:semicolon
)brace
r_static
r_int
DECL|function|proc_read_brn
id|proc_read_brn
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|asus_hotk
op_star
id|hotk
op_assign
(paren
r_struct
id|asus_hotk
op_star
)paren
id|data
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|read_brightness
c_func
(paren
id|hotk
)paren
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|proc_write_brn
id|proc_write_brn
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
r_int
id|count
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|value
suffix:semicolon
r_struct
id|asus_hotk
op_star
id|hotk
op_assign
(paren
r_struct
id|asus_hotk
op_star
)paren
id|data
suffix:semicolon
multiline_comment|/* scan expression.  Multiple expressions may be delimited with ; */
r_if
c_cond
(paren
id|sscanf
c_func
(paren
id|buffer
comma
l_string|&quot;%d&quot;
comma
op_amp
id|value
)paren
op_eq
l_int|1
)paren
(brace
id|value
op_assign
(paren
l_int|0
OL
id|value
)paren
ques
c_cond
(paren
(paren
l_int|15
OL
id|value
)paren
ques
c_cond
l_int|15
suffix:colon
id|value
)paren
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* 0 &lt;= value &lt;= 15 */
id|set_brightness
c_func
(paren
id|value
comma
id|hotk
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Asus ACPI: Error reading user input&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
DECL|function|set_display
r_static
r_void
id|set_display
c_func
(paren
r_int
id|value
comma
r_struct
id|asus_hotk
op_star
id|hotk
)paren
(brace
multiline_comment|/* no sanity check needed for now */
r_if
c_cond
(paren
op_logical_neg
id|write_acpi_int
c_func
(paren
id|hotk-&gt;handle
comma
id|hotk-&gt;methods-&gt;display_set
comma
id|value
comma
l_int|NULL
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Asus ACPI: Error setting display&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Now, *this* one could be more user-friendly, but so far, no-one has &n; * complained. The significance of bits is the same as in proc_write_disp()&n; */
r_static
r_int
DECL|function|proc_read_disp
id|proc_read_disp
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|value
op_assign
l_int|0
suffix:semicolon
r_struct
id|asus_hotk
op_star
id|hotk
op_assign
(paren
r_struct
id|asus_hotk
op_star
)paren
id|data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|read_acpi_int
c_func
(paren
id|hotk-&gt;handle
comma
id|hotk-&gt;methods-&gt;display_get
comma
op_amp
id|value
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Asus ACPI: Error reading display status&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|value
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Experimental support for display switching. As of now: 0x01 should activate &n; * the LCD output, 0x02 should do for CRT, and 0x04 for TV-Out. Any combination &n; * (bitwise) of these will suffice. I never actually tested 3 displays hooked up &n; * simultaneously, so be warned.&n; */
r_static
r_int
DECL|function|proc_write_disp
id|proc_write_disp
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
r_int
id|count
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|value
suffix:semicolon
r_struct
id|asus_hotk
op_star
id|hotk
op_assign
(paren
r_struct
id|asus_hotk
op_star
)paren
id|data
suffix:semicolon
multiline_comment|/* scan expression.  Multiple expressions may be delimited with ; */
r_if
c_cond
(paren
id|sscanf
c_func
(paren
id|buffer
comma
l_string|&quot;%d&quot;
comma
op_amp
id|value
)paren
op_eq
l_int|1
)paren
id|set_display
c_func
(paren
id|value
comma
id|hotk
)paren
suffix:semicolon
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Asus ACPI: Error reading user input&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
DECL|function|asus_hotk_add_fs
r_static
r_int
id|__init
id|asus_hotk_add_fs
c_func
(paren
r_struct
id|acpi_device
op_star
id|device
)paren
(brace
r_struct
id|proc_dir_entry
op_star
id|proc
suffix:semicolon
r_struct
id|asus_hotk
op_star
id|hotk
op_assign
id|acpi_driver_data
c_func
(paren
id|device
)paren
suffix:semicolon
id|mode_t
id|mode
suffix:semicolon
multiline_comment|/*&n;&t; * If parameter uid or gid is not changed, keep the default setting for&n;&t; * our proc entries (-rw-rw-rw-) else, it means we care about security,&n;&t; * and then set to -rw-rw----&n;&t; */
r_if
c_cond
(paren
(paren
id|asus_uid
op_eq
l_int|0
)paren
op_logical_and
(paren
id|asus_gid
op_eq
l_int|0
)paren
)paren
(brace
id|mode
op_assign
id|S_IFREG
op_or
id|S_IRUGO
op_or
id|S_IWUGO
suffix:semicolon
)brace
r_else
(brace
id|mode
op_assign
id|S_IFREG
op_or
id|S_IRUSR
op_or
id|S_IRGRP
op_or
id|S_IWUSR
op_or
id|S_IWGRP
suffix:semicolon
)brace
id|acpi_device_dir
c_func
(paren
id|device
)paren
op_assign
id|asus_proc_dir
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acpi_device_dir
c_func
(paren
id|device
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|proc
op_assign
id|create_proc_entry
c_func
(paren
id|PROC_INFOS
comma
id|mode
comma
id|acpi_device_dir
c_func
(paren
id|device
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|proc
)paren
(brace
id|proc-&gt;read_proc
op_assign
id|proc_read_info
suffix:semicolon
id|proc-&gt;data
op_assign
id|acpi_driver_data
c_func
(paren
id|device
)paren
suffix:semicolon
id|proc-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
id|proc-&gt;uid
op_assign
id|asus_uid
suffix:semicolon
id|proc-&gt;gid
op_assign
id|asus_gid
suffix:semicolon
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;  Unable to create &quot;
id|PROC_INFOS
l_string|&quot; fs entry&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hotk-&gt;methods-&gt;mt_wled
)paren
(brace
id|proc
op_assign
id|create_proc_entry
c_func
(paren
id|PROC_WLED
comma
id|mode
comma
id|acpi_device_dir
c_func
(paren
id|device
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|proc
)paren
(brace
id|proc-&gt;write_proc
op_assign
id|proc_write_wled
suffix:semicolon
id|proc-&gt;read_proc
op_assign
id|proc_read_wled
suffix:semicolon
id|proc-&gt;data
op_assign
id|acpi_driver_data
c_func
(paren
id|device
)paren
suffix:semicolon
id|proc-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
id|proc-&gt;uid
op_assign
id|asus_uid
suffix:semicolon
id|proc-&gt;gid
op_assign
id|asus_gid
suffix:semicolon
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;  Unable to create &quot;
id|PROC_WLED
l_string|&quot; fs entry&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|hotk-&gt;methods-&gt;mt_mled
)paren
(brace
id|proc
op_assign
id|create_proc_entry
c_func
(paren
id|PROC_MLED
comma
id|mode
comma
id|acpi_device_dir
c_func
(paren
id|device
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|proc
)paren
(brace
id|proc-&gt;write_proc
op_assign
id|proc_write_mled
suffix:semicolon
id|proc-&gt;read_proc
op_assign
id|proc_read_mled
suffix:semicolon
id|proc-&gt;data
op_assign
id|acpi_driver_data
c_func
(paren
id|device
)paren
suffix:semicolon
id|proc-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
id|proc-&gt;uid
op_assign
id|asus_uid
suffix:semicolon
id|proc-&gt;gid
op_assign
id|asus_gid
suffix:semicolon
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;  Unable to create &quot;
id|PROC_MLED
l_string|&quot; fs entry&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* &n;&t; * We need both read node and write method as LCD switch is also accessible&n;&t; * from keyboard &n;&t; */
r_if
c_cond
(paren
id|hotk-&gt;methods-&gt;mt_lcd_switch
op_logical_and
id|hotk-&gt;methods-&gt;lcd_status
)paren
(brace
id|proc
op_assign
id|create_proc_entry
c_func
(paren
id|PROC_LCD
comma
id|mode
comma
id|acpi_device_dir
c_func
(paren
id|device
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|proc
)paren
(brace
id|proc-&gt;write_proc
op_assign
id|proc_write_lcd
suffix:semicolon
id|proc-&gt;read_proc
op_assign
id|proc_read_lcd
suffix:semicolon
id|proc-&gt;data
op_assign
id|acpi_driver_data
c_func
(paren
id|device
)paren
suffix:semicolon
id|proc-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
id|proc-&gt;uid
op_assign
id|asus_uid
suffix:semicolon
id|proc-&gt;gid
op_assign
id|asus_gid
suffix:semicolon
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;  Unable to create &quot;
id|PROC_LCD
l_string|&quot; fs entry&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|hotk-&gt;methods-&gt;brightness_up
op_logical_and
id|hotk-&gt;methods-&gt;brightness_down
)paren
op_logical_or
(paren
id|hotk-&gt;methods-&gt;brightness_get
op_logical_and
id|hotk-&gt;methods-&gt;brightness_get
)paren
)paren
(brace
id|proc
op_assign
id|create_proc_entry
c_func
(paren
id|PROC_BRN
comma
id|mode
comma
id|acpi_device_dir
c_func
(paren
id|device
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|proc
)paren
(brace
id|proc-&gt;write_proc
op_assign
id|proc_write_brn
suffix:semicolon
id|proc-&gt;read_proc
op_assign
id|proc_read_brn
suffix:semicolon
id|proc-&gt;data
op_assign
id|acpi_driver_data
c_func
(paren
id|device
)paren
suffix:semicolon
id|proc-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
id|proc-&gt;uid
op_assign
id|asus_uid
suffix:semicolon
id|proc-&gt;gid
op_assign
id|asus_gid
suffix:semicolon
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;  Unable to create &quot;
id|PROC_BRN
l_string|&quot; fs entry&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|hotk-&gt;methods-&gt;display_set
)paren
(brace
id|proc
op_assign
id|create_proc_entry
c_func
(paren
id|PROC_DISP
comma
id|mode
comma
id|acpi_device_dir
c_func
(paren
id|device
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|proc
)paren
(brace
id|proc-&gt;write_proc
op_assign
id|proc_write_disp
suffix:semicolon
id|proc-&gt;read_proc
op_assign
id|proc_read_disp
suffix:semicolon
id|proc-&gt;data
op_assign
id|acpi_driver_data
c_func
(paren
id|device
)paren
suffix:semicolon
id|proc-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
id|proc-&gt;uid
op_assign
id|asus_uid
suffix:semicolon
id|proc-&gt;gid
op_assign
id|asus_gid
suffix:semicolon
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;  Unable to create &quot;
id|PROC_DISP
l_string|&quot; fs entry&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|asus_hotk_notify
r_static
r_void
id|asus_hotk_notify
c_func
(paren
id|acpi_handle
id|handle
comma
id|u32
id|event
comma
r_void
op_star
id|data
)paren
(brace
multiline_comment|/* TODO Find a better way to handle events count. Here, in data, we receive&n;&t; * the hotk, so we can do anything!&n;&t; */
r_struct
id|asus_hotk
op_star
id|hotk
op_assign
(paren
r_struct
id|asus_hotk
op_star
)paren
id|data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hotk
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|event
op_amp
op_complement
(paren
(paren
id|u32
)paren
id|BR_UP
)paren
)paren
OL
l_int|16
)paren
(brace
id|hotk-&gt;brightness
op_assign
(paren
id|event
op_amp
op_complement
(paren
(paren
id|u32
)paren
id|BR_UP
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|event
op_amp
op_complement
(paren
(paren
id|u32
)paren
id|BR_DOWN
)paren
)paren
OL
l_int|16
)paren
(brace
id|hotk-&gt;brightness
op_assign
(paren
id|event
op_amp
op_complement
(paren
(paren
id|u32
)paren
id|BR_DOWN
)paren
)paren
suffix:semicolon
)brace
id|acpi_bus_generate_event
c_func
(paren
id|hotk-&gt;device
comma
id|event
comma
id|hotk-&gt;event_count
(braket
id|event
op_mod
l_int|128
)braket
op_increment
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is used to initialize the hotk with right values. In this&n; * method, we can make all the detection we want, and modify the hotk struct&n; */
DECL|function|asus_hotk_get_info
r_static
r_int
id|__init
id|asus_hotk_get_info
c_func
(paren
r_struct
id|asus_hotk
op_star
id|hotk
)paren
(brace
r_struct
id|acpi_buffer
id|buffer
op_assign
(brace
id|ACPI_ALLOCATE_BUFFER
comma
l_int|NULL
)brace
suffix:semicolon
r_struct
id|acpi_buffer
id|dsdt
op_assign
(brace
id|ACPI_ALLOCATE_BUFFER
comma
l_int|NULL
)brace
suffix:semicolon
r_union
id|acpi_object
op_star
id|model
op_assign
l_int|NULL
suffix:semicolon
r_int
id|bsts_result
suffix:semicolon
id|acpi_status
id|status
suffix:semicolon
multiline_comment|/*&n;&t; * Get DSDT headers early enough to allow for differentiating between &n;&t; * models, but late enough to allow acpi_bus_register_driver() to fail &n;&t; * before doing anything ACPI-specific. Should we encounter a machine,&n;&t; * which needs special handling (i.e. its hotkey device has a different&n;&t; * HID), this bit will be moved. A global variable asus_info contains&n;&t; * the DSDT header.&n;&t; */
id|status
op_assign
id|acpi_get_table
c_func
(paren
id|ACPI_TABLE_DSDT
comma
l_int|1
comma
op_amp
id|dsdt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
c_func
(paren
id|status
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;  Couldn&squot;t get the DSDT table header&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|asus_info
op_assign
(paren
r_struct
id|acpi_table_header
op_star
)paren
id|dsdt.pointer
suffix:semicolon
multiline_comment|/* We have to write 0 on init this far for all ASUS models */
r_if
c_cond
(paren
op_logical_neg
id|write_acpi_int
c_func
(paren
id|hotk-&gt;handle
comma
l_string|&quot;INIT&quot;
comma
l_int|0
comma
op_amp
id|buffer
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;  Hotkey initialization failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* For testing purposes */
r_if
c_cond
(paren
op_logical_neg
id|read_acpi_int
c_func
(paren
id|hotk-&gt;handle
comma
l_string|&quot;BSTS&quot;
comma
op_amp
id|bsts_result
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;  Error calling BSTS&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bsts_result
)paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;  BSTS called, 0x%02x returned&bslash;n&quot;
comma
id|bsts_result
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Here, we also use asus_info to make decision. For example, on INIT&n;&t; * method, S1X and L1X models both reports to be L84F, but they don&squot;t&n;&t; * have the same methods (L1X has WLED, S1X don&squot;t)&n;&t; */
id|model
op_assign
(paren
r_union
id|acpi_object
op_star
)paren
id|buffer.pointer
suffix:semicolon
r_if
c_cond
(paren
id|model-&gt;type
op_eq
id|ACPI_TYPE_STRING
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;  %s model detected, &quot;
comma
id|model-&gt;string.pointer
)paren
suffix:semicolon
)brace
id|hotk-&gt;model
op_assign
id|END_MODEL
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|model-&gt;string.pointer
comma
l_string|&quot;L3D&quot;
comma
l_int|3
)paren
op_eq
l_int|0
)paren
id|hotk-&gt;model
op_assign
id|L3D
suffix:semicolon
multiline_comment|/*&n;&t;&t; * L2B has same settings that L3X, except for GL32, but as&n;&t;&t; * there is no node to get the LCD status, and as GL32 is never&n;&t;&t; * used anywhere else, I assume it&squot;s safe, even if lcd get is&n;&t;&t; * broken for this model (TODO fix it ?)&n;&t;&t; */
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|model-&gt;string.pointer
comma
l_string|&quot;L3&quot;
comma
l_int|2
)paren
op_eq
l_int|0
op_logical_or
id|strncmp
c_func
(paren
id|model-&gt;string.pointer
comma
l_string|&quot;L2B&quot;
comma
l_int|3
)paren
op_eq
l_int|0
)paren
id|hotk-&gt;model
op_assign
id|L3X
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|model-&gt;string.pointer
comma
l_string|&quot;M2&quot;
comma
l_int|2
)paren
op_eq
l_int|0
)paren
id|hotk-&gt;model
op_assign
id|M2X
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|model-&gt;string.pointer
comma
l_string|&quot;M3N&quot;
comma
l_int|3
)paren
op_eq
l_int|0
op_logical_or
id|strncmp
c_func
(paren
id|model-&gt;string.pointer
comma
l_string|&quot;S1N&quot;
comma
l_int|3
)paren
op_eq
l_int|0
)paren
id|hotk-&gt;model
op_assign
id|M3N
suffix:semicolon
multiline_comment|/* S1300N is similar enough */
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|model-&gt;string.pointer
comma
l_string|&quot;L2&quot;
comma
l_int|2
)paren
op_eq
l_int|0
)paren
id|hotk-&gt;model
op_assign
id|L2X
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|model-&gt;string.pointer
comma
l_string|&quot;L8&quot;
comma
l_int|2
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* S1300A reports L84F, but L1400B too */
r_if
c_cond
(paren
id|asus_info
)paren
(brace
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|asus_info-&gt;oem_table_id
comma
l_string|&quot;L1&quot;
comma
l_int|2
)paren
op_eq
l_int|0
)paren
id|hotk-&gt;model
op_assign
id|L1X
suffix:semicolon
)brace
r_else
id|hotk-&gt;model
op_assign
id|S1X
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|model-&gt;string.pointer
comma
l_string|&quot;D1&quot;
comma
l_int|2
)paren
op_eq
l_int|0
)paren
id|hotk-&gt;model
op_assign
id|D1X
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|model-&gt;string.pointer
comma
l_string|&quot;A1&quot;
comma
l_int|2
)paren
op_eq
l_int|0
)paren
id|hotk-&gt;model
op_assign
id|A1X
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|model-&gt;string.pointer
comma
l_string|&quot;A2&quot;
comma
l_int|2
)paren
op_eq
l_int|0
)paren
id|hotk-&gt;model
op_assign
id|A2X
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|model-&gt;string.pointer
comma
l_string|&quot;J1&quot;
comma
l_int|2
)paren
op_eq
l_int|0
)paren
id|hotk-&gt;model
op_assign
id|S2X
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|model-&gt;string.pointer
comma
l_string|&quot;L5&quot;
comma
l_int|2
)paren
op_eq
l_int|0
)paren
id|hotk-&gt;model
op_assign
id|L5X
suffix:semicolon
r_if
c_cond
(paren
id|hotk-&gt;model
op_eq
id|END_MODEL
)paren
(brace
multiline_comment|/* By default use the same values, as I don&squot;t know others */
id|printk
c_func
(paren
l_string|&quot;unsupported, trying default values, supply the &quot;
l_string|&quot;developers with your DSDT&bslash;n&quot;
)paren
suffix:semicolon
id|hotk-&gt;model
op_assign
id|L2X
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;supported&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|hotk-&gt;methods
op_assign
op_amp
id|model_conf
(braket
id|hotk-&gt;model
)braket
suffix:semicolon
id|acpi_os_free
c_func
(paren
id|model
)paren
suffix:semicolon
r_return
id|AE_OK
suffix:semicolon
)brace
DECL|function|asus_hotk_check
r_static
r_int
id|__init
id|asus_hotk_check
c_func
(paren
r_struct
id|asus_hotk
op_star
id|hotk
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hotk
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|result
op_assign
id|acpi_bus_get_status
c_func
(paren
id|hotk-&gt;device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
id|hotk-&gt;device-&gt;status.present
)paren
(brace
id|result
op_assign
id|asus_hotk_get_info
c_func
(paren
id|hotk
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;  Hotkey device not present, aborting&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
DECL|function|asus_hotk_add
r_static
r_int
id|__init
id|asus_hotk_add
c_func
(paren
r_struct
id|acpi_device
op_star
id|device
)paren
(brace
r_struct
id|asus_hotk
op_star
id|hotk
op_assign
l_int|NULL
suffix:semicolon
id|acpi_status
id|status
op_assign
id|AE_OK
suffix:semicolon
r_int
id|result
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Asus Laptop ACPI Extras version %s&bslash;n&quot;
comma
id|ASUS_ACPI_VERSION
)paren
suffix:semicolon
id|hotk
op_assign
(paren
r_struct
id|asus_hotk
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|asus_hotk
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hotk
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|hotk
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|asus_hotk
)paren
)paren
suffix:semicolon
id|hotk-&gt;handle
op_assign
id|device-&gt;handle
suffix:semicolon
id|sprintf
c_func
(paren
id|acpi_device_name
c_func
(paren
id|device
)paren
comma
l_string|&quot;%s&quot;
comma
id|ACPI_HOTK_DEVICE_NAME
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|acpi_device_class
c_func
(paren
id|device
)paren
comma
l_string|&quot;%s&quot;
comma
id|ACPI_HOTK_CLASS
)paren
suffix:semicolon
id|acpi_driver_data
c_func
(paren
id|device
)paren
op_assign
id|hotk
suffix:semicolon
id|hotk-&gt;device
op_assign
id|device
suffix:semicolon
id|result
op_assign
id|asus_hotk_check
c_func
(paren
id|hotk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_goto
id|end
suffix:semicolon
id|result
op_assign
id|asus_hotk_add_fs
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_goto
id|end
suffix:semicolon
multiline_comment|/*&n;&t; * We install the handler, it will receive the hotk in parameter, so, we&n;&t; * could add other data to the hotk struct&n;&t; */
id|status
op_assign
id|acpi_install_notify_handler
c_func
(paren
id|hotk-&gt;handle
comma
id|ACPI_SYSTEM_NOTIFY
comma
id|asus_hotk_notify
comma
id|hotk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
c_func
(paren
id|status
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;  Error installing notify handler&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* For laptops without GPLV: init the hotk-&gt;brightness value */
r_if
c_cond
(paren
(paren
op_logical_neg
id|hotk-&gt;methods-&gt;brightness_get
)paren
op_logical_and
(paren
op_logical_neg
id|hotk-&gt;methods-&gt;brightness_status
)paren
op_logical_and
(paren
id|hotk-&gt;methods-&gt;brightness_up
op_logical_and
id|hotk-&gt;methods-&gt;brightness_down
)paren
)paren
(brace
id|status
op_assign
id|acpi_evaluate_object
c_func
(paren
l_int|NULL
comma
id|hotk-&gt;methods-&gt;brightness_down
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
c_func
(paren
id|status
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;  Error changing brightness&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
id|status
op_assign
id|acpi_evaluate_object
c_func
(paren
l_int|NULL
comma
id|hotk-&gt;methods-&gt;brightness_up
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
c_func
(paren
id|status
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;  Strange, error changing&quot;
l_string|&quot; brightness&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|end
suffix:colon
r_if
c_cond
(paren
id|result
)paren
(brace
id|kfree
c_func
(paren
id|hotk
)paren
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
DECL|function|asus_hotk_remove
r_static
r_int
id|asus_hotk_remove
c_func
(paren
r_struct
id|acpi_device
op_star
id|device
comma
r_int
id|type
)paren
(brace
id|acpi_status
id|status
op_assign
l_int|0
suffix:semicolon
r_struct
id|asus_hotk
op_star
id|hotk
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device
op_logical_or
op_logical_neg
id|acpi_driver_data
c_func
(paren
id|device
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|hotk
op_assign
(paren
r_struct
id|asus_hotk
op_star
)paren
id|acpi_driver_data
c_func
(paren
id|device
)paren
suffix:semicolon
id|status
op_assign
id|acpi_remove_notify_handler
c_func
(paren
id|hotk-&gt;handle
comma
id|ACPI_SYSTEM_NOTIFY
comma
id|asus_hotk_notify
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
c_func
(paren
id|status
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Asus ACPI: Error removing notify handler&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|hotk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|asus_acpi_init
r_static
r_int
id|__init
id|asus_acpi_init
c_func
(paren
r_void
)paren
(brace
r_int
id|result
suffix:semicolon
id|asus_proc_dir
op_assign
id|proc_mkdir
c_func
(paren
id|PROC_ASUS
comma
id|acpi_root_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|asus_proc_dir
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Asus ACPI: Unable to create /proc entry&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|asus_proc_dir-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
id|result
op_assign
id|acpi_bus_register_driver
c_func
(paren
op_amp
id|asus_hotk_driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|remove_proc_entry
c_func
(paren
id|PROC_ASUS
comma
id|acpi_root_dir
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|asus_acpi_exit
r_static
r_void
id|__exit
id|asus_acpi_exit
c_func
(paren
r_void
)paren
(brace
id|acpi_bus_unregister_driver
c_func
(paren
op_amp
id|asus_hotk_driver
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
id|PROC_ASUS
comma
id|acpi_root_dir
)paren
suffix:semicolon
id|acpi_os_free
c_func
(paren
id|asus_info
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|variable|asus_acpi_init
id|module_init
c_func
(paren
id|asus_acpi_init
)paren
suffix:semicolon
DECL|variable|asus_acpi_exit
id|module_exit
c_func
(paren
id|asus_acpi_exit
)paren
suffix:semicolon
eof
