multiline_comment|/*&n; * sleep.c - ACPI sleep support.&n; * &n; *  Copyright (c) 2000-2003 Patrick Mochel&n; *&n; *  Portions are&n; *  Copyright (C) 2001, 2002 Andy Grover &lt;andrew.grover@intel.com&gt;&n; *  Copyright (C) 2001, 2002 Paul Diefenbaugh &lt;paul.s.diefenbaugh@intel.com&gt;&n; */
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/irq.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/suspend.h&gt;
macro_line|#include &lt;acpi/acpi_bus.h&gt;
macro_line|#include &lt;acpi/acpi_drivers.h&gt;
macro_line|#include &quot;sleep.h&quot;
DECL|macro|_COMPONENT
mdefine_line|#define _COMPONENT&t;&t;ACPI_SYSTEM_COMPONENT
id|ACPI_MODULE_NAME
(paren
l_string|&quot;sleep&quot;
)paren
DECL|variable|sleep_states
id|u8
id|sleep_states
(braket
id|ACPI_S_STATE_COUNT
)braket
suffix:semicolon
multiline_comment|/**&n; * acpi_system_restore_state - OS-specific restoration of state&n; * @state:&t;sleep state we&squot;re exiting&n; *&n; * Note that if we&squot;re coming back from S4, the memory image should have already&n; * been loaded from the disk and is already in place. (Otherwise how else would we&n; * be here?).&n; */
id|acpi_status
DECL|function|acpi_system_restore_state
id|acpi_system_restore_state
(paren
id|u32
id|state
)paren
(brace
multiline_comment|/* restore processor state&n;&t; * We should only be here if we&squot;re coming back from STR or STD.&n;&t; * And, in the case of the latter, the memory image should have already&n;&t; * been loaded from disk.&n;&t; */
r_if
c_cond
(paren
id|state
OG
id|ACPI_STATE_S1
)paren
id|acpi_restore_state_mem
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait for power to come back */
id|mdelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* turn all the devices back on */
id|device_resume
c_func
(paren
id|RESUME_POWER_ON
)paren
suffix:semicolon
multiline_comment|/* enable interrupts once again */
id|ACPI_ENABLE_IRQS
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* restore device context */
id|device_resume
c_func
(paren
id|RESUME_RESTORE_STATE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmi_broken
op_amp
id|BROKEN_INIT_AFTER_S1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Broken toshiba laptop -&gt; kicking interrupts&bslash;n&quot;
)paren
suffix:semicolon
id|init_8259A
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|AE_OK
suffix:semicolon
)brace
multiline_comment|/**&n; * acpi_system_save_state - save OS specific state and power down devices&n; * @state:&t;sleep state we&squot;re entering.&n; *&n; * This handles saving all context to memory, and possibly disk.&n; * First, we call to the device driver layer to save device state.&n; * Once we have that, we save whatevery processor and kernel state we&n; * need to memory.&n; * If we&squot;re entering S4, we then write the memory image to disk.&n; *&n; * Only then is it safe for us to power down devices, since we may need&n; * the disks and upstream buses to write to.&n; */
id|acpi_status
DECL|function|acpi_system_save_state
id|acpi_system_save_state
c_func
(paren
id|u32
id|state
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Send notification to devices that they will be suspended.&n;&t; * If any device or driver cannot make the transition, either up&n;&t; * or down, we&squot;ll get an error back.&n;&t; */
id|error
op_assign
id|device_suspend
c_func
(paren
id|state
comma
id|SUSPEND_NOTIFY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|AE_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|state
OL
id|ACPI_STATE_S5
)paren
(brace
multiline_comment|/* Tell devices to stop I/O and actually save their state.&n;&t;&t; * It is theoretically possible that something could fail,&n;&t;&t; * so handle that gracefully..&n;&t;&t; */
id|error
op_assign
id|device_suspend
c_func
(paren
id|state
comma
id|SUSPEND_SAVE_STATE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
multiline_comment|/* tell devices to restore state if they have&n;&t;&t;&t; * it saved and to start taking I/O requests.&n;&t;&t;&t; */
id|device_resume
c_func
(paren
id|RESUME_RESTORE_STATE
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* flush caches */
id|ACPI_FLUSH_CPU_CACHE
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Do arch specific saving of state. */
r_if
c_cond
(paren
id|state
OG
id|ACPI_STATE_S1
)paren
(brace
id|error
op_assign
id|acpi_save_state_mem
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
(paren
id|state
op_eq
id|ACPI_STATE_S4
)paren
)paren
id|error
op_assign
id|acpi_save_state_disk
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|device_resume
c_func
(paren
id|RESUME_RESTORE_STATE
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* disable interrupts&n;&t; * Note that acpi_suspend -- our caller -- will do this once we return.&n;&t; * But, we want it done early, so we don&squot;t get any suprises during&n;&t; * the device suspend sequence.&n;&t; */
id|ACPI_DISABLE_IRQS
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Unconditionally turn off devices.&n;&t; * Obvious if we enter a sleep state.&n;&t; * If entering S5 (soft off), this should put devices in a&n;&t; * quiescent state.&n;&t; */
id|error
op_assign
id|device_suspend
c_func
(paren
id|state
comma
id|SUSPEND_POWER_DOWN
)paren
suffix:semicolon
multiline_comment|/* We&squot;re pretty screwed if we got an error from this.&n;&t; * We try to recover by simply calling our own restore_state&n;&t; * function; see above for definition.&n;&t; *&n;&t; * If it&squot;s S5 though, go through with it anyway..&n;&t; */
r_if
c_cond
(paren
id|error
op_logical_and
id|state
op_ne
id|ACPI_STATE_S5
)paren
id|acpi_system_restore_state
c_func
(paren
id|state
)paren
suffix:semicolon
r_return
id|error
ques
c_cond
id|AE_ERROR
suffix:colon
id|AE_OK
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    acpi_system_suspend&n; *&n; * PARAMETERS:  %state: Sleep state to enter.&n; *&n; * RETURN:      acpi_status, whether or not we successfully entered and&n; *              exited sleep.&n; *&n; * DESCRIPTION: Perform OS-specific action to enter sleep state.&n; *              This is the final step in going to sleep, per spec.  If we&n; *              know we&squot;re coming back (i.e. not entering S5), we save the&n; *              processor flags. [ We&squot;ll have to save and restore them anyway,&n; *              so we use the arch-agnostic save_flags and restore_flags&n; *              here.]  We then set the place to return to in arch-specific&n; *              globals using arch_set_return_point. Finally, we call the&n; *              ACPI function to write the proper values to I/O ports.&n; *&n; ****************************************************************************/
id|acpi_status
DECL|function|acpi_system_suspend
id|acpi_system_suspend
c_func
(paren
id|u32
id|state
)paren
(brace
id|acpi_status
id|status
op_assign
id|AE_ERROR
suffix:semicolon
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|state
)paren
(brace
r_case
id|ACPI_STATE_S1
suffix:colon
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|status
op_assign
id|acpi_enter_sleep_state
c_func
(paren
id|state
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef CONFIG_SOFTWARE_SUSPEND
r_case
id|ACPI_STATE_S2
suffix:colon
r_case
id|ACPI_STATE_S3
suffix:colon
id|do_suspend_lowlevel
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_case
id|ACPI_STATE_S4
suffix:colon
id|do_suspend_lowlevel_s4bios
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
id|PREFIX
l_string|&quot;don&squot;t know how to handle %d state.&bslash;n&quot;
comma
id|state
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Back to C!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/**&n; * acpi_suspend - OS-agnostic system suspend/resume support (S? states)&n; * @state:&t;state we&squot;re entering&n; *&n; */
id|acpi_status
DECL|function|acpi_suspend
id|acpi_suspend
(paren
id|u32
id|state
)paren
(brace
id|acpi_status
id|status
suffix:semicolon
multiline_comment|/* Suspend is hard to get right on SMP. */
r_if
c_cond
(paren
id|num_online_cpus
c_func
(paren
)paren
op_ne
l_int|1
)paren
r_return
id|AE_ERROR
suffix:semicolon
multiline_comment|/* get out if state is invalid */
r_if
c_cond
(paren
id|state
template_param
id|ACPI_STATE_S5
)paren
r_return
id|AE_ERROR
suffix:semicolon
multiline_comment|/* Since we handle S4OS via a different path (swsusp), give up if no s4bios. */
r_if
c_cond
(paren
id|state
op_eq
id|ACPI_STATE_S4
op_logical_and
op_logical_neg
id|acpi_gbl_FACS-&gt;S4bios_f
)paren
r_return
id|AE_ERROR
suffix:semicolon
multiline_comment|/*&n;&t; * TBD: S1 can be done without device_suspend.  Make a CONFIG_XX&n;&t; * to handle however when S1 failed without device_suspend.&n;&t; */
r_if
c_cond
(paren
id|freeze_processes
c_func
(paren
)paren
)paren
(brace
id|thaw_processes
c_func
(paren
)paren
suffix:semicolon
r_return
id|AE_ERROR
suffix:semicolon
multiline_comment|/* device_suspend needs processes to be stopped */
)brace
multiline_comment|/* do we have a wakeup address for S2 and S3? */
multiline_comment|/* Here, we support only S4BIOS, those we set the wakeup address */
multiline_comment|/* S4OS is only supported for now via swsusp.. */
r_if
c_cond
(paren
id|state
op_eq
id|ACPI_STATE_S2
op_logical_or
id|state
op_eq
id|ACPI_STATE_S3
op_logical_or
id|ACPI_STATE_S4
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|acpi_wakeup_address
)paren
r_return
id|AE_ERROR
suffix:semicolon
id|acpi_set_firmware_waking_vector
c_func
(paren
(paren
id|acpi_physical_address
)paren
id|acpi_wakeup_address
)paren
suffix:semicolon
)brace
id|status
op_assign
id|acpi_system_save_state
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ACPI_SUCCESS
c_func
(paren
id|status
)paren
)paren
r_return
id|status
suffix:semicolon
id|acpi_enter_sleep_state_prep
c_func
(paren
id|state
)paren
suffix:semicolon
multiline_comment|/* disable interrupts and flush caches */
id|ACPI_DISABLE_IRQS
c_func
(paren
)paren
suffix:semicolon
id|ACPI_FLUSH_CPU_CACHE
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* perform OS-specific sleep actions */
id|status
op_assign
id|acpi_system_suspend
c_func
(paren
id|state
)paren
suffix:semicolon
multiline_comment|/* Even if we failed to go to sleep, all of the devices are in an suspended&n;&t; * mode. So, we run these unconditionaly to make sure we have a usable system&n;&t; * no matter what.&n;&t; */
id|acpi_leave_sleep_state
c_func
(paren
id|state
)paren
suffix:semicolon
id|acpi_system_restore_state
c_func
(paren
id|state
)paren
suffix:semicolon
multiline_comment|/* make sure interrupts are enabled */
id|ACPI_ENABLE_IRQS
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* reset firmware waking vector */
id|acpi_set_firmware_waking_vector
c_func
(paren
(paren
id|acpi_physical_address
)paren
l_int|0
)paren
suffix:semicolon
id|thaw_processes
c_func
(paren
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
DECL|function|acpi_sleep_init
r_static
r_int
id|__init
id|acpi_sleep_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_system_add_fs&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acpi_disabled
)paren
id|return_VALUE
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|PREFIX
l_string|&quot;(supports&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ACPI_S_STATE_COUNT
suffix:semicolon
id|i
op_increment
)paren
(brace
id|acpi_status
id|status
suffix:semicolon
id|u8
id|type_a
comma
id|type_b
suffix:semicolon
id|status
op_assign
id|acpi_get_sleep_type_data
c_func
(paren
id|i
comma
op_amp
id|type_a
comma
op_amp
id|type_b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_SUCCESS
c_func
(paren
id|status
)paren
)paren
(brace
id|sleep_states
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; S%d&quot;
comma
id|i
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|ACPI_STATE_S4
op_logical_and
id|acpi_gbl_FACS-&gt;S4bios_f
)paren
(brace
id|sleep_states
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; S4bios&quot;
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;)&bslash;n&quot;
)paren
suffix:semicolon
id|return_VALUE
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|variable|acpi_sleep_init
id|late_initcall
c_func
(paren
id|acpi_sleep_init
)paren
suffix:semicolon
eof
