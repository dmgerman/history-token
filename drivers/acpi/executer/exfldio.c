multiline_comment|/******************************************************************************&n; *&n; * Module Name: exfldio - Aml Field I/O&n; *              $Revision: 84 $&n; *&n; *****************************************************************************/
multiline_comment|/*&n; *  Copyright (C) 2000 - 2002, R. Byron Moore&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &quot;acpi.h&quot;
macro_line|#include &quot;acinterp.h&quot;
macro_line|#include &quot;amlcode.h&quot;
macro_line|#include &quot;acnamesp.h&quot;
macro_line|#include &quot;achware.h&quot;
macro_line|#include &quot;acevents.h&quot;
macro_line|#include &quot;acdispat.h&quot;
DECL|macro|_COMPONENT
mdefine_line|#define _COMPONENT          ACPI_EXECUTER
id|ACPI_MODULE_NAME
(paren
l_string|&quot;exfldio&quot;
)paren
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ex_setup_region&n; *&n; * PARAMETERS:  *Obj_desc               - Field to be read or written&n; *              Field_datum_byte_offset - Byte offset of this datum within the&n; *                                        parent field&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Common processing for Acpi_ex_extract_from_field and&n; *              Acpi_ex_insert_into_field. Initialize the&n; *&n; ******************************************************************************/
id|acpi_status
DECL|function|acpi_ex_setup_region
id|acpi_ex_setup_region
(paren
id|acpi_operand_object
op_star
id|obj_desc
comma
id|u32
id|field_datum_byte_offset
)paren
(brace
id|acpi_status
id|status
op_assign
id|AE_OK
suffix:semicolon
id|acpi_operand_object
op_star
id|rgn_desc
suffix:semicolon
id|ACPI_FUNCTION_TRACE_U32
(paren
l_string|&quot;Ex_setup_region&quot;
comma
id|field_datum_byte_offset
)paren
suffix:semicolon
id|rgn_desc
op_assign
id|obj_desc-&gt;common_field.region_obj
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_TYPE_REGION
op_ne
id|rgn_desc-&gt;common.type
)paren
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;Needed Region, found type %x %s&bslash;n&quot;
comma
id|rgn_desc-&gt;common.type
comma
id|acpi_ut_get_type_name
(paren
id|rgn_desc-&gt;common.type
)paren
)paren
)paren
suffix:semicolon
id|return_ACPI_STATUS
(paren
id|AE_AML_OPERAND_TYPE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the Region Address and Length have not been previously evaluated,&n;&t; * evaluate them now and save the results.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|rgn_desc-&gt;region.flags
op_amp
id|AOPOBJ_DATA_VALID
)paren
)paren
(brace
id|status
op_assign
id|acpi_ds_get_region_arguments
(paren
id|rgn_desc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Validate the request.  The entire request from the byte offset for a&n;&t; * length of one field datum (access width) must fit within the region.&n;&t; * (Region length is specified in bytes)&n;&t; */
r_if
c_cond
(paren
id|rgn_desc-&gt;region.length
OL
(paren
id|obj_desc-&gt;common_field.base_byte_offset
op_plus
id|field_datum_byte_offset
op_plus
id|obj_desc-&gt;common_field.access_byte_width
)paren
)paren
(brace
r_if
c_cond
(paren
id|rgn_desc-&gt;region.length
OL
id|obj_desc-&gt;common_field.access_byte_width
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * This is the case where the Access_type (Acc_word, etc.) is wider&n;&t;&t;&t; * than the region itself.  For example, a region of length one&n;&t;&t;&t; * byte, and a field with Dword access specified.&n;&t;&t;&t; */
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;Field [%4.4s] access width (%d bytes) too large for region [%4.4s] (length %X)&bslash;n&quot;
comma
(paren
r_char
op_star
)paren
op_amp
id|obj_desc-&gt;common_field.node-&gt;name
comma
id|obj_desc-&gt;common_field.access_byte_width
comma
(paren
r_char
op_star
)paren
op_amp
id|rgn_desc-&gt;region.node-&gt;name
comma
id|rgn_desc-&gt;region.length
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Offset rounded up to next multiple of field width&n;&t;&t; * exceeds region length, indicate an error&n;&t;&t; */
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;Field [%4.4s] Base+Offset+Width %X+%X+%X is beyond end of region [%4.4s] (length %X)&bslash;n&quot;
comma
(paren
r_char
op_star
)paren
op_amp
id|obj_desc-&gt;common_field.node-&gt;name
comma
id|obj_desc-&gt;common_field.base_byte_offset
comma
id|field_datum_byte_offset
comma
id|obj_desc-&gt;common_field.access_byte_width
comma
(paren
r_char
op_star
)paren
op_amp
id|rgn_desc-&gt;region.node-&gt;name
comma
id|rgn_desc-&gt;region.length
)paren
)paren
suffix:semicolon
id|return_ACPI_STATUS
(paren
id|AE_AML_REGION_LIMIT
)paren
suffix:semicolon
)brace
id|return_ACPI_STATUS
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ex_access_region&n; *&n; * PARAMETERS:  *Obj_desc               - Field to be read&n; *              Field_datum_byte_offset - Byte offset of this datum within the&n; *                                        parent field&n; *              *Value                  - Where to store value (must be 32 bits)&n; *              Read_write              - Read or Write flag&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Read or Write a single field datum to an Operation Region.&n; *&n; ******************************************************************************/
id|acpi_status
DECL|function|acpi_ex_access_region
id|acpi_ex_access_region
(paren
id|acpi_operand_object
op_star
id|obj_desc
comma
id|u32
id|field_datum_byte_offset
comma
id|acpi_integer
op_star
id|value
comma
id|u32
id|read_write
)paren
(brace
id|acpi_status
id|status
suffix:semicolon
id|acpi_operand_object
op_star
id|rgn_desc
suffix:semicolon
id|ACPI_PHYSICAL_ADDRESS
id|address
suffix:semicolon
id|ACPI_FUNCTION_TRACE
(paren
l_string|&quot;Ex_access_region&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The physical address of this field datum is:&n;&t; *&n;&t; * 1) The base of the region, plus&n;&t; * 2) The base offset of the field, plus&n;&t; * 3) The current offset into the field&n;&t; */
id|rgn_desc
op_assign
id|obj_desc-&gt;common_field.region_obj
suffix:semicolon
id|address
op_assign
id|rgn_desc-&gt;region.address
op_plus
id|obj_desc-&gt;common_field.base_byte_offset
op_plus
id|field_datum_byte_offset
suffix:semicolon
r_if
c_cond
(paren
id|read_write
op_eq
id|ACPI_READ
)paren
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_BFIELD
comma
l_string|&quot;[READ]&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_BFIELD
comma
l_string|&quot;[WRITE]&quot;
)paren
)paren
suffix:semicolon
)brace
id|ACPI_DEBUG_PRINT_RAW
(paren
(paren
id|ACPI_DB_BFIELD
comma
l_string|&quot; Region[%s-%X] Access %X Base:Off %X:%X at %8.8X%8.8X&bslash;n&quot;
comma
id|acpi_ut_get_region_name
(paren
id|rgn_desc-&gt;region.space_id
)paren
comma
id|rgn_desc-&gt;region.space_id
comma
id|obj_desc-&gt;common_field.access_byte_width
comma
id|obj_desc-&gt;common_field.base_byte_offset
comma
id|field_datum_byte_offset
comma
id|ACPI_HIDWORD
(paren
id|address
)paren
comma
id|ACPI_LODWORD
(paren
id|address
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Invoke the appropriate Address_space/Op_region handler */
id|status
op_assign
id|acpi_ev_address_space_dispatch
(paren
id|rgn_desc
comma
id|read_write
comma
id|address
comma
id|ACPI_MUL_8
(paren
id|obj_desc-&gt;common_field.access_byte_width
)paren
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_if
c_cond
(paren
id|status
op_eq
id|AE_NOT_IMPLEMENTED
)paren
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;Region %s(%X) not implemented&bslash;n&quot;
comma
id|acpi_ut_get_region_name
(paren
id|rgn_desc-&gt;region.space_id
)paren
comma
id|rgn_desc-&gt;region.space_id
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_eq
id|AE_NOT_EXIST
)paren
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;Region %s(%X) has no handler&bslash;n&quot;
comma
id|acpi_ut_get_region_name
(paren
id|rgn_desc-&gt;region.space_id
)paren
comma
id|rgn_desc-&gt;region.space_id
)paren
)paren
suffix:semicolon
)brace
)brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ex_register_overflow&n; *&n; * PARAMETERS:  *Obj_desc               - Register(Field) to be written&n; *              Value                   - Value to be stored&n; *&n; * RETURN:      TRUE if value overflows the field, FALSE otherwise&n; *&n; * DESCRIPTION: Check if a value is out of range of the field being written.&n; *              Used to check if the values written to Index and Bank registers&n; *              are out of range.  Normally, the value is simply truncated&n; *              to fit the field, but this case is most likely a serious&n; *              coding error in the ASL.&n; *&n; ******************************************************************************/
id|u8
DECL|function|acpi_ex_register_overflow
id|acpi_ex_register_overflow
(paren
id|acpi_operand_object
op_star
id|obj_desc
comma
id|acpi_integer
id|value
)paren
(brace
r_if
c_cond
(paren
id|obj_desc-&gt;common_field.bit_length
op_ge
id|ACPI_INTEGER_BIT_SIZE
)paren
(brace
multiline_comment|/*&n;&t;&t; * The field is large enough to hold the maximum integer, so we can&n;&t;&t; * never overflow it.&n;&t;&t; */
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|value
op_ge
(paren
id|acpi_integer
)paren
(paren
l_int|1
op_lshift
id|obj_desc-&gt;common_field.bit_length
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * The Value is larger than the maximum value that can fit into&n;&t;&t; * the register.&n;&t;&t; */
r_return
(paren
id|TRUE
)paren
suffix:semicolon
)brace
multiline_comment|/* The Value will fit into the field with no truncation */
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ex_field_datum_io&n; *&n; * PARAMETERS:  *Obj_desc               - Field to be read&n; *              Field_datum_byte_offset - Byte offset of this datum within the&n; *                                        parent field&n; *              *Value                  - Where to store value (must be 64 bits)&n; *              Read_write              - Read or Write flag&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Read or Write a single datum of a field.  The Field_type is&n; *              demultiplexed here to handle the different types of fields&n; *              (Buffer_field, Region_field, Index_field, Bank_field)&n; *&n; ******************************************************************************/
id|acpi_status
DECL|function|acpi_ex_field_datum_io
id|acpi_ex_field_datum_io
(paren
id|acpi_operand_object
op_star
id|obj_desc
comma
id|u32
id|field_datum_byte_offset
comma
id|acpi_integer
op_star
id|value
comma
id|u32
id|read_write
)paren
(brace
id|acpi_status
id|status
suffix:semicolon
id|acpi_integer
id|local_value
suffix:semicolon
id|ACPI_FUNCTION_TRACE_U32
(paren
l_string|&quot;Ex_field_datum_io&quot;
comma
id|field_datum_byte_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_write
op_eq
id|ACPI_READ
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
(brace
id|local_value
op_assign
l_int|0
suffix:semicolon
id|value
op_assign
op_amp
id|local_value
suffix:semicolon
multiline_comment|/* To support reads without saving return value */
)brace
multiline_comment|/* Clear the entire return buffer first, [Very Important!] */
op_star
id|value
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The four types of fields are:&n;&t; *&n;&t; * Buffer_fields - Read/write from/to a Buffer&n;&t; * Region_fields - Read/write from/to a Operation Region.&n;&t; * Bank_fields  - Write to a Bank Register, then read/write from/to an Op_region&n;&t; * Index_fields - Write to an Index Register, then read/write from/to a Data Register&n;&t; */
r_switch
c_cond
(paren
id|obj_desc-&gt;common.type
)paren
(brace
r_case
id|ACPI_TYPE_BUFFER_FIELD
suffix:colon
multiline_comment|/*&n;&t;&t; * If the Buffer_field arguments have not been previously evaluated,&n;&t;&t; * evaluate them now and save the results.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|obj_desc-&gt;common.flags
op_amp
id|AOPOBJ_DATA_VALID
)paren
)paren
(brace
id|status
op_assign
id|acpi_ds_get_buffer_field_arguments
(paren
id|obj_desc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|read_write
op_eq
id|ACPI_READ
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Copy the data from the source buffer.&n;&t;&t;&t; * Length is the field width in bytes.&n;&t;&t;&t; */
id|ACPI_MEMCPY
(paren
id|value
comma
(paren
id|obj_desc-&gt;buffer_field.buffer_obj
)paren
op_member_access_from_pointer
id|buffer.pointer
op_plus
id|obj_desc-&gt;buffer_field.base_byte_offset
op_plus
id|field_datum_byte_offset
comma
id|obj_desc-&gt;common_field.access_byte_width
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Copy the data to the target buffer.&n;&t;&t;&t; * Length is the field width in bytes.&n;&t;&t;&t; */
id|ACPI_MEMCPY
(paren
(paren
id|obj_desc-&gt;buffer_field.buffer_obj
)paren
op_member_access_from_pointer
id|buffer.pointer
op_plus
id|obj_desc-&gt;buffer_field.base_byte_offset
op_plus
id|field_datum_byte_offset
comma
id|value
comma
id|obj_desc-&gt;common_field.access_byte_width
)paren
suffix:semicolon
)brace
id|status
op_assign
id|AE_OK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|INTERNAL_TYPE_BANK_FIELD
suffix:colon
multiline_comment|/* Ensure that the Bank_value is not beyond the capacity of the register */
r_if
c_cond
(paren
id|acpi_ex_register_overflow
(paren
id|obj_desc-&gt;bank_field.bank_obj
comma
id|obj_desc-&gt;bank_field.value
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|AE_AML_REGISTER_LIMIT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * For Bank_fields, we must write the Bank_value to the Bank_register&n;&t;&t; * (itself a Region_field) before we can access the data.&n;&t;&t; */
id|status
op_assign
id|acpi_ex_insert_into_field
(paren
id|obj_desc-&gt;bank_field.bank_obj
comma
op_amp
id|obj_desc-&gt;bank_field.value
comma
r_sizeof
(paren
id|obj_desc-&gt;bank_field.value
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Now that the Bank has been selected, fall through to the&n;&t;&t; * Region_field case and write the datum to the Operation Region&n;&t;&t; */
multiline_comment|/* No break; ! */
r_case
id|INTERNAL_TYPE_REGION_FIELD
suffix:colon
multiline_comment|/*&n;&t;&t; * For simple Region_fields, we just directly access the owning&n;&t;&t; * Operation Region.&n;&t;&t; */
id|status
op_assign
id|acpi_ex_setup_region
(paren
id|obj_desc
comma
id|field_datum_byte_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
id|status
op_assign
id|acpi_ex_access_region
(paren
id|obj_desc
comma
id|field_datum_byte_offset
comma
id|value
comma
id|read_write
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|INTERNAL_TYPE_INDEX_FIELD
suffix:colon
multiline_comment|/* Ensure that the Index_value is not beyond the capacity of the register */
r_if
c_cond
(paren
id|acpi_ex_register_overflow
(paren
id|obj_desc-&gt;index_field.index_obj
comma
id|obj_desc-&gt;index_field.value
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|AE_AML_REGISTER_LIMIT
)paren
suffix:semicolon
)brace
multiline_comment|/* Write the index value to the Index_register (itself a Region_field) */
id|status
op_assign
id|acpi_ex_insert_into_field
(paren
id|obj_desc-&gt;index_field.index_obj
comma
op_amp
id|obj_desc-&gt;index_field.value
comma
r_sizeof
(paren
id|obj_desc-&gt;index_field.value
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|read_write
op_eq
id|ACPI_READ
)paren
(brace
multiline_comment|/* Read the datum from the Data_register */
id|status
op_assign
id|acpi_ex_extract_from_field
(paren
id|obj_desc-&gt;index_field.data_obj
comma
id|value
comma
id|obj_desc-&gt;common_field.access_byte_width
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Write the datum to the Data register */
id|status
op_assign
id|acpi_ex_insert_into_field
(paren
id|obj_desc-&gt;index_field.data_obj
comma
id|value
comma
id|obj_desc-&gt;common_field.access_byte_width
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;%p, Wrong object type - %s&bslash;n&quot;
comma
id|obj_desc
comma
id|acpi_ut_get_type_name
(paren
id|obj_desc-&gt;common.type
)paren
)paren
)paren
suffix:semicolon
id|status
op_assign
id|AE_AML_INTERNAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ACPI_SUCCESS
(paren
id|status
)paren
)paren
(brace
r_if
c_cond
(paren
id|read_write
op_eq
id|ACPI_READ
)paren
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_BFIELD
comma
l_string|&quot;Value Read=%8.8X%8.8X&bslash;n&quot;
comma
id|ACPI_HIDWORD
(paren
op_star
id|value
)paren
comma
id|ACPI_LODWORD
(paren
op_star
id|value
)paren
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_BFIELD
comma
l_string|&quot;Value Written=%8.8X%8.8X&bslash;n&quot;
comma
id|ACPI_HIDWORD
(paren
op_star
id|value
)paren
comma
id|ACPI_LODWORD
(paren
op_star
id|value
)paren
)paren
)paren
suffix:semicolon
)brace
)brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ex_write_with_update_rule&n; *&n; * PARAMETERS:  *Obj_desc           - Field to be set&n; *              Value               - Value to store&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Apply the field update rule to a field write&n; *&n; ******************************************************************************/
id|acpi_status
DECL|function|acpi_ex_write_with_update_rule
id|acpi_ex_write_with_update_rule
(paren
id|acpi_operand_object
op_star
id|obj_desc
comma
id|acpi_integer
id|mask
comma
id|acpi_integer
id|field_value
comma
id|u32
id|field_datum_byte_offset
)paren
(brace
id|acpi_status
id|status
op_assign
id|AE_OK
suffix:semicolon
id|acpi_integer
id|merged_value
suffix:semicolon
id|acpi_integer
id|current_value
suffix:semicolon
id|ACPI_FUNCTION_TRACE_U32
(paren
l_string|&quot;Ex_write_with_update_rule&quot;
comma
id|mask
)paren
suffix:semicolon
multiline_comment|/* Start with the new bits  */
id|merged_value
op_assign
id|field_value
suffix:semicolon
multiline_comment|/* If the mask is all ones, we don&squot;t need to worry about the update rule */
r_if
c_cond
(paren
id|mask
op_ne
id|ACPI_UINT32_MAX
)paren
(brace
multiline_comment|/* Decode the update rule */
r_switch
c_cond
(paren
id|obj_desc-&gt;common_field.field_flags
op_amp
id|AML_FIELD_UPDATE_RULE_MASK
)paren
(brace
r_case
id|AML_FIELD_UPDATE_PRESERVE
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Check if update rule needs to be applied (not if mask is all&n;&t;&t;&t; * ones)  The left shift drops the bits we want to ignore.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
op_complement
id|mask
op_lshift
(paren
id|ACPI_MUL_8
(paren
r_sizeof
(paren
id|mask
)paren
)paren
op_minus
id|ACPI_MUL_8
(paren
id|obj_desc-&gt;common_field.access_byte_width
)paren
)paren
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Read the current contents of the byte/word/dword containing&n;&t;&t;&t;&t; * the field, and merge with the new field value.&n;&t;&t;&t;&t; */
id|status
op_assign
id|acpi_ex_field_datum_io
(paren
id|obj_desc
comma
id|field_datum_byte_offset
comma
op_amp
id|current_value
comma
id|ACPI_READ
)paren
suffix:semicolon
id|merged_value
op_or_assign
(paren
id|current_value
op_amp
op_complement
id|mask
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AML_FIELD_UPDATE_WRITE_AS_ONES
suffix:colon
multiline_comment|/* Set positions outside the field to all ones */
id|merged_value
op_or_assign
op_complement
id|mask
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AML_FIELD_UPDATE_WRITE_AS_ZEROS
suffix:colon
multiline_comment|/* Set positions outside the field to all zeros */
id|merged_value
op_and_assign
id|mask
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;Write_with_update_rule: Unknown Update_rule setting: %x&bslash;n&quot;
comma
(paren
id|obj_desc-&gt;common_field.field_flags
op_amp
id|AML_FIELD_UPDATE_RULE_MASK
)paren
)paren
)paren
suffix:semicolon
id|return_ACPI_STATUS
(paren
id|AE_AML_OPERAND_VALUE
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Write the merged value */
id|status
op_assign
id|acpi_ex_field_datum_io
(paren
id|obj_desc
comma
id|field_datum_byte_offset
comma
op_amp
id|merged_value
comma
id|ACPI_WRITE
)paren
suffix:semicolon
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_BFIELD
comma
l_string|&quot;Mask %8.8X%8.8X Datum_offset %X Value %8.8X%8.8X, Merged_value %8.8X%8.8X&bslash;n&quot;
comma
id|ACPI_HIDWORD
(paren
id|mask
)paren
comma
id|ACPI_LODWORD
(paren
id|mask
)paren
comma
id|field_datum_byte_offset
comma
id|ACPI_HIDWORD
(paren
id|field_value
)paren
comma
id|ACPI_LODWORD
(paren
id|field_value
)paren
comma
id|ACPI_HIDWORD
(paren
id|merged_value
)paren
comma
id|ACPI_LODWORD
(paren
id|merged_value
)paren
)paren
)paren
suffix:semicolon
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ex_get_buffer_datum&n; *&n; * PARAMETERS:  Datum               - Where the Datum is returned&n; *              Buffer              - Raw field buffer&n; *              Byte_granularity    - 1/2/4/8 Granularity of the field&n; *                                    (aka Datum Size)&n; *              Offset              - Datum offset into the buffer&n; *&n; * RETURN:      none&n; *&n; * DESCRIPTION: Get a datum from the buffer according to the buffer field&n; *              byte granularity&n; *&n; ******************************************************************************/
r_void
DECL|function|acpi_ex_get_buffer_datum
id|acpi_ex_get_buffer_datum
c_func
(paren
id|acpi_integer
op_star
id|datum
comma
r_void
op_star
id|buffer
comma
id|u32
id|byte_granularity
comma
id|u32
id|offset
)paren
(brace
id|ACPI_FUNCTION_ENTRY
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|byte_granularity
)paren
(brace
r_case
id|ACPI_FIELD_BYTE_GRANULARITY
suffix:colon
op_star
id|datum
op_assign
(paren
(paren
id|u8
op_star
)paren
id|buffer
)paren
(braket
id|offset
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACPI_FIELD_WORD_GRANULARITY
suffix:colon
id|ACPI_MOVE_UNALIGNED16_TO_32
(paren
id|datum
comma
op_amp
(paren
(paren
(paren
id|u16
op_star
)paren
id|buffer
)paren
(braket
id|offset
)braket
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACPI_FIELD_DWORD_GRANULARITY
suffix:colon
id|ACPI_MOVE_UNALIGNED32_TO_32
(paren
id|datum
comma
op_amp
(paren
(paren
(paren
id|u32
op_star
)paren
id|buffer
)paren
(braket
id|offset
)braket
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACPI_FIELD_QWORD_GRANULARITY
suffix:colon
id|ACPI_MOVE_UNALIGNED64_TO_64
(paren
id|datum
comma
op_amp
(paren
(paren
(paren
id|u64
op_star
)paren
id|buffer
)paren
(braket
id|offset
)braket
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ex_set_buffer_datum&n; *&n; * PARAMETERS:  Merged_datum        - Value to store&n; *              Buffer              - Receiving buffer&n; *              Byte_granularity    - 1/2/4/8 Granularity of the field&n; *                                    (aka Datum Size)&n; *              Offset              - Datum offset into the buffer&n; *&n; * RETURN:      none&n; *&n; * DESCRIPTION: Store the merged datum to the buffer according to the&n; *              byte granularity&n; *&n; ******************************************************************************/
r_void
DECL|function|acpi_ex_set_buffer_datum
id|acpi_ex_set_buffer_datum
(paren
id|acpi_integer
id|merged_datum
comma
r_void
op_star
id|buffer
comma
id|u32
id|byte_granularity
comma
id|u32
id|offset
)paren
(brace
id|ACPI_FUNCTION_ENTRY
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|byte_granularity
)paren
(brace
r_case
id|ACPI_FIELD_BYTE_GRANULARITY
suffix:colon
(paren
(paren
id|u8
op_star
)paren
id|buffer
)paren
(braket
id|offset
)braket
op_assign
(paren
id|u8
)paren
id|merged_datum
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACPI_FIELD_WORD_GRANULARITY
suffix:colon
id|ACPI_MOVE_UNALIGNED16_TO_16
(paren
op_amp
(paren
(paren
(paren
id|u16
op_star
)paren
id|buffer
)paren
(braket
id|offset
)braket
)paren
comma
op_amp
id|merged_datum
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACPI_FIELD_DWORD_GRANULARITY
suffix:colon
id|ACPI_MOVE_UNALIGNED32_TO_32
(paren
op_amp
(paren
(paren
(paren
id|u32
op_star
)paren
id|buffer
)paren
(braket
id|offset
)braket
)paren
comma
op_amp
id|merged_datum
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACPI_FIELD_QWORD_GRANULARITY
suffix:colon
id|ACPI_MOVE_UNALIGNED64_TO_64
(paren
op_amp
(paren
(paren
(paren
id|u64
op_star
)paren
id|buffer
)paren
(braket
id|offset
)braket
)paren
comma
op_amp
id|merged_datum
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ex_extract_from_field&n; *&n; * PARAMETERS:  *Obj_desc           - Field to be read&n; *              *Value              - Where to store value&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Retrieve the value of the given field&n; *&n; ******************************************************************************/
id|acpi_status
DECL|function|acpi_ex_extract_from_field
id|acpi_ex_extract_from_field
(paren
id|acpi_operand_object
op_star
id|obj_desc
comma
r_void
op_star
id|buffer
comma
id|u32
id|buffer_length
)paren
(brace
id|acpi_status
id|status
suffix:semicolon
id|u32
id|field_datum_byte_offset
suffix:semicolon
id|u32
id|datum_offset
suffix:semicolon
id|acpi_integer
id|previous_raw_datum
suffix:semicolon
id|acpi_integer
id|this_raw_datum
op_assign
l_int|0
suffix:semicolon
id|acpi_integer
id|merged_datum
op_assign
l_int|0
suffix:semicolon
id|u32
id|byte_field_length
suffix:semicolon
id|u32
id|datum_count
suffix:semicolon
id|ACPI_FUNCTION_TRACE
(paren
l_string|&quot;Ex_extract_from_field&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The field must fit within the caller&squot;s buffer&n;&t; */
id|byte_field_length
op_assign
id|ACPI_ROUND_BITS_UP_TO_BYTES
(paren
id|obj_desc-&gt;common_field.bit_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|byte_field_length
OG
id|buffer_length
)paren
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_BFIELD
comma
l_string|&quot;Field size %X (bytes) too large for buffer (%X)&bslash;n&quot;
comma
id|byte_field_length
comma
id|buffer_length
)paren
)paren
suffix:semicolon
id|return_ACPI_STATUS
(paren
id|AE_BUFFER_OVERFLOW
)paren
suffix:semicolon
)brace
multiline_comment|/* Convert field byte count to datum count, round up if necessary */
id|datum_count
op_assign
id|ACPI_ROUND_UP_TO
(paren
id|byte_field_length
comma
id|obj_desc-&gt;common_field.access_byte_width
)paren
suffix:semicolon
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_BFIELD
comma
l_string|&quot;Byte_len=%x, Datum_len=%x, Byte_gran=%x&bslash;n&quot;
comma
id|byte_field_length
comma
id|datum_count
comma
id|obj_desc-&gt;common_field.access_byte_width
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Clear the caller&squot;s buffer (the whole buffer length as given)&n;&t; * This is very important, especially in the cases where a byte is read,&n;&t; * but the buffer is really a u32 (4 bytes).&n;&t; */
id|ACPI_MEMSET
(paren
id|buffer
comma
l_int|0
comma
id|buffer_length
)paren
suffix:semicolon
multiline_comment|/* Read the first raw datum to prime the loop */
id|field_datum_byte_offset
op_assign
l_int|0
suffix:semicolon
id|datum_offset
op_assign
l_int|0
suffix:semicolon
id|status
op_assign
id|acpi_ex_field_datum_io
(paren
id|obj_desc
comma
id|field_datum_byte_offset
comma
op_amp
id|previous_raw_datum
comma
id|ACPI_READ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/* We might actually be done if the request fits in one datum */
r_if
c_cond
(paren
(paren
id|datum_count
op_eq
l_int|1
)paren
op_logical_and
(paren
id|obj_desc-&gt;common_field.flags
op_amp
id|AOPOBJ_SINGLE_DATUM
)paren
)paren
(brace
multiline_comment|/* 1) Shift the valid data bits down to start at bit 0 */
id|merged_datum
op_assign
(paren
id|previous_raw_datum
op_rshift
id|obj_desc-&gt;common_field.start_field_bit_offset
)paren
suffix:semicolon
multiline_comment|/* 2) Mask off any upper unused bits (bits not part of the field) */
r_if
c_cond
(paren
id|obj_desc-&gt;common_field.end_buffer_valid_bits
)paren
(brace
id|merged_datum
op_and_assign
id|ACPI_MASK_BITS_ABOVE
(paren
id|obj_desc-&gt;common_field.end_buffer_valid_bits
)paren
suffix:semicolon
)brace
multiline_comment|/* Store the datum to the caller buffer */
id|acpi_ex_set_buffer_datum
(paren
id|merged_datum
comma
id|buffer
comma
id|obj_desc-&gt;common_field.access_byte_width
comma
id|datum_offset
)paren
suffix:semicolon
id|return_ACPI_STATUS
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* We need to get more raw data to complete one or more field data */
r_while
c_loop
(paren
id|datum_offset
OL
id|datum_count
)paren
(brace
id|field_datum_byte_offset
op_add_assign
id|obj_desc-&gt;common_field.access_byte_width
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the field is aligned on a byte boundary, we don&squot;t want&n;&t;&t; * to perform a final read, since this would potentially read&n;&t;&t; * past the end of the region.&n;&t;&t; *&n;&t;&t; * We could just split the aligned and non-aligned cases since the&n;&t;&t; * aligned case is so very simple, but this would require more code.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|obj_desc-&gt;common_field.start_field_bit_offset
op_ne
l_int|0
)paren
op_logical_or
(paren
(paren
id|obj_desc-&gt;common_field.start_field_bit_offset
op_eq
l_int|0
)paren
op_logical_and
(paren
id|datum_offset
OL
(paren
id|datum_count
op_minus
l_int|1
)paren
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Get the next raw datum, it contains some or all bits&n;&t;&t;&t; * of the current field datum&n;&t;&t;&t; */
id|status
op_assign
id|acpi_ex_field_datum_io
(paren
id|obj_desc
comma
id|field_datum_byte_offset
comma
op_amp
id|this_raw_datum
comma
id|ACPI_READ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Create the (possibly) merged datum to be stored to the caller buffer&n;&t;&t; */
r_if
c_cond
(paren
id|obj_desc-&gt;common_field.start_field_bit_offset
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Field is not skewed and we can just copy the datum */
id|merged_datum
op_assign
id|previous_raw_datum
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Put together the appropriate bits of the two raw data to make a&n;&t;&t;&t; * single complete field datum&n;&t;&t;&t; *&n;&t;&t;&t; * 1) Normalize the first datum down to bit 0&n;&t;&t;&t; */
id|merged_datum
op_assign
(paren
id|previous_raw_datum
op_rshift
id|obj_desc-&gt;common_field.start_field_bit_offset
)paren
suffix:semicolon
multiline_comment|/* 2) Insert the second datum &quot;above&quot; the first datum */
id|merged_datum
op_or_assign
(paren
id|this_raw_datum
op_lshift
id|obj_desc-&gt;common_field.datum_valid_bits
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|datum_offset
op_ge
(paren
id|datum_count
op_minus
l_int|1
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * This is the last iteration of the loop.  We need to clear&n;&t;&t;&t;&t; * any unused bits (bits that are not part of this field) that&n;&t;&t;&t;&t; * came from the last raw datum before we store the final&n;&t;&t;&t;&t; * merged datum into the caller buffer.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|obj_desc-&gt;common_field.end_buffer_valid_bits
)paren
(brace
id|merged_datum
op_and_assign
id|ACPI_MASK_BITS_ABOVE
(paren
id|obj_desc-&gt;common_field.end_buffer_valid_bits
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t; * Store the merged field datum in the caller&squot;s buffer, according to&n;&t;&t; * the granularity of the field (size of each datum).&n;&t;&t; */
id|acpi_ex_set_buffer_datum
(paren
id|merged_datum
comma
id|buffer
comma
id|obj_desc-&gt;common_field.access_byte_width
comma
id|datum_offset
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Save the raw datum that was just acquired since it may contain bits&n;&t;&t; * of the *next* field datum.  Update offsets&n;&t;&t; */
id|previous_raw_datum
op_assign
id|this_raw_datum
suffix:semicolon
id|datum_offset
op_increment
suffix:semicolon
)brace
id|return_ACPI_STATUS
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ex_insert_into_field&n; *&n; * PARAMETERS:  *Obj_desc           - Field to be set&n; *              Buffer              - Value to store&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Store the value into the given field&n; *&n; ******************************************************************************/
id|acpi_status
DECL|function|acpi_ex_insert_into_field
id|acpi_ex_insert_into_field
(paren
id|acpi_operand_object
op_star
id|obj_desc
comma
r_void
op_star
id|buffer
comma
id|u32
id|buffer_length
)paren
(brace
id|acpi_status
id|status
suffix:semicolon
id|u32
id|field_datum_byte_offset
suffix:semicolon
id|u32
id|datum_offset
suffix:semicolon
id|acpi_integer
id|mask
suffix:semicolon
id|acpi_integer
id|merged_datum
suffix:semicolon
id|acpi_integer
id|previous_raw_datum
suffix:semicolon
id|acpi_integer
id|this_raw_datum
suffix:semicolon
id|u32
id|byte_field_length
suffix:semicolon
id|u32
id|datum_count
suffix:semicolon
id|ACPI_FUNCTION_TRACE
(paren
l_string|&quot;Ex_insert_into_field&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Incoming buffer must be at least as long as the field, we do not&n;&t; * allow &quot;partial&quot; field writes.  We do not care if the buffer is&n;&t; * larger than the field, this typically happens when an integer is&n;&t; * written to a field that is actually smaller than an integer.&n;&t; */
id|byte_field_length
op_assign
id|ACPI_ROUND_BITS_UP_TO_BYTES
(paren
id|obj_desc-&gt;common_field.bit_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_length
OL
id|byte_field_length
)paren
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_BFIELD
comma
l_string|&quot;Buffer length %X too small for field %X&bslash;n&quot;
comma
id|buffer_length
comma
id|byte_field_length
)paren
)paren
suffix:semicolon
id|return_ACPI_STATUS
(paren
id|AE_BUFFER_OVERFLOW
)paren
suffix:semicolon
)brace
multiline_comment|/* Convert byte count to datum count, round up if necessary */
id|datum_count
op_assign
id|ACPI_ROUND_UP_TO
(paren
id|byte_field_length
comma
id|obj_desc-&gt;common_field.access_byte_width
)paren
suffix:semicolon
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_BFIELD
comma
l_string|&quot;Byte_len=%x, Datum_len=%x, Byte_gran=%x&bslash;n&quot;
comma
id|byte_field_length
comma
id|datum_count
comma
id|obj_desc-&gt;common_field.access_byte_width
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Break the request into up to three parts (similar to an I/O request):&n;&t; * 1) non-aligned part at start&n;&t; * 2) aligned part in middle&n;&t; * 3) non-aligned part at the end&n;&t; */
id|field_datum_byte_offset
op_assign
l_int|0
suffix:semicolon
id|datum_offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Get a single datum from the caller&squot;s buffer */
id|acpi_ex_get_buffer_datum
(paren
op_amp
id|previous_raw_datum
comma
id|buffer
comma
id|obj_desc-&gt;common_field.access_byte_width
comma
id|datum_offset
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Part1:&n;&t; * Write a partial field datum if field does not begin on a datum boundary&n;&t; * Note: The code in this section also handles the aligned case&n;&t; *&n;&t; * Construct Mask with 1 bits where the field is, 0 bits elsewhere&n;&t; * (Only the bottom 5 bits of Bit_length are valid for a shift operation)&n;&t; *&n;&t; * Mask off bits that are &quot;below&quot; the field (if any)&n;&t; */
id|mask
op_assign
id|ACPI_MASK_BITS_BELOW
(paren
id|obj_desc-&gt;common_field.start_field_bit_offset
)paren
suffix:semicolon
multiline_comment|/* If the field fits in one datum, may need to mask upper bits */
r_if
c_cond
(paren
(paren
id|obj_desc-&gt;common_field.flags
op_amp
id|AOPOBJ_SINGLE_DATUM
)paren
op_logical_and
id|obj_desc-&gt;common_field.end_field_valid_bits
)paren
(brace
multiline_comment|/* There are bits above the field, mask them off also */
id|mask
op_and_assign
id|ACPI_MASK_BITS_ABOVE
(paren
id|obj_desc-&gt;common_field.end_field_valid_bits
)paren
suffix:semicolon
)brace
multiline_comment|/* Shift and mask the value into the field position */
id|merged_datum
op_assign
(paren
id|previous_raw_datum
op_lshift
id|obj_desc-&gt;common_field.start_field_bit_offset
)paren
suffix:semicolon
id|merged_datum
op_and_assign
id|mask
suffix:semicolon
multiline_comment|/* Apply the update rule (if necessary) and write the datum to the field */
id|status
op_assign
id|acpi_ex_write_with_update_rule
(paren
id|obj_desc
comma
id|mask
comma
id|merged_datum
comma
id|field_datum_byte_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/* If the entire field fits within one datum, we are done. */
r_if
c_cond
(paren
(paren
id|datum_count
op_eq
l_int|1
)paren
op_logical_and
(paren
id|obj_desc-&gt;common_field.flags
op_amp
id|AOPOBJ_SINGLE_DATUM
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Part2:&n;&t; * Write the aligned data.&n;&t; *&n;&t; * We don&squot;t need to worry about the update rule for these data, because&n;&t; * all of the bits in each datum are part of the field.&n;&t; *&n;&t; * The last datum must be special cased because it might contain bits&n;&t; * that are not part of the field -- therefore the &quot;update rule&quot; must be&n;&t; * applied in Part3 below.&n;&t; */
r_while
c_loop
(paren
id|datum_offset
OL
id|datum_count
)paren
(brace
id|datum_offset
op_increment
suffix:semicolon
id|field_datum_byte_offset
op_add_assign
id|obj_desc-&gt;common_field.access_byte_width
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Get the next raw buffer datum.  It may contain bits of the previous&n;&t;&t; * field datum&n;&t;&t; */
id|acpi_ex_get_buffer_datum
(paren
op_amp
id|this_raw_datum
comma
id|buffer
comma
id|obj_desc-&gt;common_field.access_byte_width
comma
id|datum_offset
)paren
suffix:semicolon
multiline_comment|/* Create the field datum based on the field alignment */
r_if
c_cond
(paren
id|obj_desc-&gt;common_field.start_field_bit_offset
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Put together appropriate bits of the two raw buffer data to make&n;&t;&t;&t; * a single complete field datum&n;&t;&t;&t; */
id|merged_datum
op_assign
(paren
id|previous_raw_datum
op_rshift
id|obj_desc-&gt;common_field.datum_valid_bits
)paren
op_or
(paren
id|this_raw_datum
op_lshift
id|obj_desc-&gt;common_field.start_field_bit_offset
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Field began aligned on datum boundary */
id|merged_datum
op_assign
id|this_raw_datum
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Special handling for the last datum if the field does NOT end on&n;&t;&t; * a datum boundary.  Update Rule must be applied to the bits outside&n;&t;&t; * the field.&n;&t;&t; */
r_if
c_cond
(paren
id|datum_offset
op_eq
id|datum_count
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If there are dangling non-aligned bits, perform one more merged write&n;&t;&t;&t; * Else - field is aligned at the end, no need for any more writes&n;&t;&t;&t; */
r_if
c_cond
(paren
id|obj_desc-&gt;common_field.end_field_valid_bits
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Part3:&n;&t;&t;&t;&t; * This is the last datum and the field does not end on a datum boundary.&n;&t;&t;&t;&t; * Build the partial datum and write with the update rule.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * Mask off the unused bits above (after) the end-of-field&n;&t;&t;&t;&t; */
id|mask
op_assign
id|ACPI_MASK_BITS_ABOVE
(paren
id|obj_desc-&gt;common_field.end_field_valid_bits
)paren
suffix:semicolon
id|merged_datum
op_and_assign
id|mask
suffix:semicolon
multiline_comment|/* Write the last datum with the update rule */
id|status
op_assign
id|acpi_ex_write_with_update_rule
(paren
id|obj_desc
comma
id|mask
comma
id|merged_datum
comma
id|field_datum_byte_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* Normal case -- write the completed datum */
id|status
op_assign
id|acpi_ex_field_datum_io
(paren
id|obj_desc
comma
id|field_datum_byte_offset
comma
op_amp
id|merged_datum
comma
id|ACPI_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Save the most recent datum since it may contain bits of the *next*&n;&t;&t; * field datum.  Update current byte offset.&n;&t;&t; */
id|previous_raw_datum
op_assign
id|this_raw_datum
suffix:semicolon
)brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
eof
