multiline_comment|/******************************************************************************&n; *&n; * Module Name: exfldio - Aml Field I/O&n; *&n; *****************************************************************************/
multiline_comment|/*&n; * Copyright (C) 2000 - 2005, R. Byron Moore&n; * All rights reserved.&n; *&n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions&n; * are met:&n; * 1. Redistributions of source code must retain the above copyright&n; *    notice, this list of conditions, and the following disclaimer,&n; *    without modification.&n; * 2. Redistributions in binary form must reproduce at minimum a disclaimer&n; *    substantially similar to the &quot;NO WARRANTY&quot; disclaimer below&n; *    (&quot;Disclaimer&quot;) and any redistribution must be conditioned upon&n; *    including a substantially similar Disclaimer requirement for further&n; *    binary redistribution.&n; * 3. Neither the names of the above-listed copyright holders nor the names&n; *    of any contributors may be used to endorse or promote products derived&n; *    from this software without specific prior written permission.&n; *&n; * Alternatively, this software may be distributed under the terms of the&n; * GNU General Public License (&quot;GPL&quot;) version 2 as published by the Free&n; * Software Foundation.&n; *&n; * NO WARRANTY&n; * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS&n; * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT&n; * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR&n; * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT&n; * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL&n; * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS&n; * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)&n; * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,&n; * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING&n; * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE&n; * POSSIBILITY OF SUCH DAMAGES.&n; */
macro_line|#include &lt;acpi/acpi.h&gt;
macro_line|#include &lt;acpi/acinterp.h&gt;
macro_line|#include &lt;acpi/amlcode.h&gt;
macro_line|#include &lt;acpi/acevents.h&gt;
macro_line|#include &lt;acpi/acdispat.h&gt;
DECL|macro|_COMPONENT
mdefine_line|#define _COMPONENT          ACPI_EXECUTER
id|ACPI_MODULE_NAME
(paren
l_string|&quot;exfldio&quot;
)paren
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ex_setup_region&n; *&n; * PARAMETERS:  *obj_desc               - Field to be read or written&n; *              field_datum_byte_offset - Byte offset of this datum within the&n; *                                        parent field&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Common processing for acpi_ex_extract_from_field and&n; *              acpi_ex_insert_into_field. Initialize the Region if necessary and&n; *              validate the request.&n; *&n; ******************************************************************************/
id|acpi_status
DECL|function|acpi_ex_setup_region
id|acpi_ex_setup_region
(paren
r_union
id|acpi_operand_object
op_star
id|obj_desc
comma
id|u32
id|field_datum_byte_offset
)paren
(brace
id|acpi_status
id|status
op_assign
id|AE_OK
suffix:semicolon
r_union
id|acpi_operand_object
op_star
id|rgn_desc
suffix:semicolon
id|ACPI_FUNCTION_TRACE_U32
(paren
l_string|&quot;ex_setup_region&quot;
comma
id|field_datum_byte_offset
)paren
suffix:semicolon
id|rgn_desc
op_assign
id|obj_desc-&gt;common_field.region_obj
suffix:semicolon
multiline_comment|/* We must have a valid region */
r_if
c_cond
(paren
id|ACPI_GET_OBJECT_TYPE
(paren
id|rgn_desc
)paren
op_ne
id|ACPI_TYPE_REGION
)paren
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;Needed Region, found type %X (%s)&bslash;n&quot;
comma
id|ACPI_GET_OBJECT_TYPE
(paren
id|rgn_desc
)paren
comma
id|acpi_ut_get_object_type_name
(paren
id|rgn_desc
)paren
)paren
)paren
suffix:semicolon
id|return_ACPI_STATUS
(paren
id|AE_AML_OPERAND_TYPE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the Region Address and Length have not been previously evaluated,&n;&t; * evaluate them now and save the results.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|rgn_desc-&gt;common.flags
op_amp
id|AOPOBJ_DATA_VALID
)paren
)paren
(brace
id|status
op_assign
id|acpi_ds_get_region_arguments
(paren
id|rgn_desc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rgn_desc-&gt;region.space_id
op_eq
id|ACPI_ADR_SPACE_SMBUS
)paren
(brace
multiline_comment|/* SMBus has a non-linear address space */
id|return_ACPI_STATUS
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
macro_line|#ifdef ACPI_UNDER_DEVELOPMENT
multiline_comment|/*&n;&t; * If the Field access is any_acc, we can now compute the optimal&n;&t; * access (because we know know the length of the parent region)&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|obj_desc-&gt;common.flags
op_amp
id|AOPOBJ_DATA_VALID
)paren
)paren
(brace
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Validate the request.  The entire request from the byte offset for a&n;&t; * length of one field datum (access width) must fit within the region.&n;&t; * (Region length is specified in bytes)&n;&t; */
r_if
c_cond
(paren
id|rgn_desc-&gt;region.length
OL
(paren
id|obj_desc-&gt;common_field.base_byte_offset
op_plus
id|field_datum_byte_offset
op_plus
id|obj_desc-&gt;common_field.access_byte_width
)paren
)paren
(brace
r_if
c_cond
(paren
id|acpi_gbl_enable_interpreter_slack
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Slack mode only:  We will go ahead and allow access to this&n;&t;&t;&t; * field if it is within the region length rounded up to the next&n;&t;&t;&t; * access width boundary.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ACPI_ROUND_UP
(paren
id|rgn_desc-&gt;region.length
comma
id|obj_desc-&gt;common_field.access_byte_width
)paren
op_ge
(paren
id|obj_desc-&gt;common_field.base_byte_offset
op_plus
(paren
id|acpi_native_uint
)paren
id|obj_desc-&gt;common_field.access_byte_width
op_plus
id|field_datum_byte_offset
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rgn_desc-&gt;region.length
OL
id|obj_desc-&gt;common_field.access_byte_width
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * This is the case where the access_type (acc_word, etc.) is wider&n;&t;&t;&t; * than the region itself.  For example, a region of length one&n;&t;&t;&t; * byte, and a field with Dword access specified.&n;&t;&t;&t; */
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;Field [%4.4s] access width (%d bytes) too large for region [%4.4s] (length %X)&bslash;n&quot;
comma
id|acpi_ut_get_node_name
(paren
id|obj_desc-&gt;common_field.node
)paren
comma
id|obj_desc-&gt;common_field.access_byte_width
comma
id|acpi_ut_get_node_name
(paren
id|rgn_desc-&gt;region.node
)paren
comma
id|rgn_desc-&gt;region.length
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Offset rounded up to next multiple of field width&n;&t;&t; * exceeds region length, indicate an error&n;&t;&t; */
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;Field [%4.4s] Base+Offset+Width %X+%X+%X is beyond end of region [%4.4s] (length %X)&bslash;n&quot;
comma
id|acpi_ut_get_node_name
(paren
id|obj_desc-&gt;common_field.node
)paren
comma
id|obj_desc-&gt;common_field.base_byte_offset
comma
id|field_datum_byte_offset
comma
id|obj_desc-&gt;common_field.access_byte_width
comma
id|acpi_ut_get_node_name
(paren
id|rgn_desc-&gt;region.node
)paren
comma
id|rgn_desc-&gt;region.length
)paren
)paren
suffix:semicolon
id|return_ACPI_STATUS
(paren
id|AE_AML_REGION_LIMIT
)paren
suffix:semicolon
)brace
id|return_ACPI_STATUS
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ex_access_region&n; *&n; * PARAMETERS:  *obj_desc               - Field to be read&n; *              field_datum_byte_offset - Byte offset of this datum within the&n; *                                        parent field&n; *              *Value                  - Where to store value (must at least&n; *                                        the size of acpi_integer)&n; *              Function                - Read or Write flag plus other region-&n; *                                        dependent flags&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Read or Write a single field datum to an Operation Region.&n; *&n; ******************************************************************************/
id|acpi_status
DECL|function|acpi_ex_access_region
id|acpi_ex_access_region
(paren
r_union
id|acpi_operand_object
op_star
id|obj_desc
comma
id|u32
id|field_datum_byte_offset
comma
id|acpi_integer
op_star
id|value
comma
id|u32
id|function
)paren
(brace
id|acpi_status
id|status
suffix:semicolon
r_union
id|acpi_operand_object
op_star
id|rgn_desc
suffix:semicolon
id|acpi_physical_address
id|address
suffix:semicolon
id|ACPI_FUNCTION_TRACE
(paren
l_string|&quot;ex_access_region&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ensure that the region operands are fully evaluated and verify&n;&t; * the validity of the request&n;&t; */
id|status
op_assign
id|acpi_ex_setup_region
(paren
id|obj_desc
comma
id|field_datum_byte_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The physical address of this field datum is:&n;&t; *&n;&t; * 1) The base of the region, plus&n;&t; * 2) The base offset of the field, plus&n;&t; * 3) The current offset into the field&n;&t; */
id|rgn_desc
op_assign
id|obj_desc-&gt;common_field.region_obj
suffix:semicolon
id|address
op_assign
id|rgn_desc-&gt;region.address
op_plus
id|obj_desc-&gt;common_field.base_byte_offset
op_plus
id|field_datum_byte_offset
suffix:semicolon
r_if
c_cond
(paren
(paren
id|function
op_amp
id|ACPI_IO_MASK
)paren
op_eq
id|ACPI_READ
)paren
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_BFIELD
comma
l_string|&quot;[READ]&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_BFIELD
comma
l_string|&quot;[WRITE]&quot;
)paren
)paren
suffix:semicolon
)brace
id|ACPI_DEBUG_PRINT_RAW
(paren
(paren
id|ACPI_DB_BFIELD
comma
l_string|&quot; Region [%s:%X], Width %X, byte_base %X, Offset %X at %8.8X%8.8X&bslash;n&quot;
comma
id|acpi_ut_get_region_name
(paren
id|rgn_desc-&gt;region.space_id
)paren
comma
id|rgn_desc-&gt;region.space_id
comma
id|obj_desc-&gt;common_field.access_byte_width
comma
id|obj_desc-&gt;common_field.base_byte_offset
comma
id|field_datum_byte_offset
comma
id|ACPI_FORMAT_UINT64
(paren
id|address
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Invoke the appropriate address_space/op_region handler */
id|status
op_assign
id|acpi_ev_address_space_dispatch
(paren
id|rgn_desc
comma
id|function
comma
id|address
comma
id|ACPI_MUL_8
(paren
id|obj_desc-&gt;common_field.access_byte_width
)paren
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_if
c_cond
(paren
id|status
op_eq
id|AE_NOT_IMPLEMENTED
)paren
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;Region %s(%X) not implemented&bslash;n&quot;
comma
id|acpi_ut_get_region_name
(paren
id|rgn_desc-&gt;region.space_id
)paren
comma
id|rgn_desc-&gt;region.space_id
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_eq
id|AE_NOT_EXIST
)paren
(brace
id|ACPI_REPORT_ERROR
(paren
(paren
l_string|&quot;Region %s(%X) has no handler&bslash;n&quot;
comma
id|acpi_ut_get_region_name
(paren
id|rgn_desc-&gt;region.space_id
)paren
comma
id|rgn_desc-&gt;region.space_id
)paren
)paren
suffix:semicolon
)brace
)brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ex_register_overflow&n; *&n; * PARAMETERS:  *obj_desc               - Register(Field) to be written&n; *              Value                   - Value to be stored&n; *&n; * RETURN:      TRUE if value overflows the field, FALSE otherwise&n; *&n; * DESCRIPTION: Check if a value is out of range of the field being written.&n; *              Used to check if the values written to Index and Bank registers&n; *              are out of range.  Normally, the value is simply truncated&n; *              to fit the field, but this case is most likely a serious&n; *              coding error in the ASL.&n; *&n; ******************************************************************************/
id|u8
DECL|function|acpi_ex_register_overflow
id|acpi_ex_register_overflow
(paren
r_union
id|acpi_operand_object
op_star
id|obj_desc
comma
id|acpi_integer
id|value
)paren
(brace
r_if
c_cond
(paren
id|obj_desc-&gt;common_field.bit_length
op_ge
id|ACPI_INTEGER_BIT_SIZE
)paren
(brace
multiline_comment|/*&n;&t;&t; * The field is large enough to hold the maximum integer, so we can&n;&t;&t; * never overflow it.&n;&t;&t; */
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|value
op_ge
(paren
(paren
id|acpi_integer
)paren
l_int|1
op_lshift
id|obj_desc-&gt;common_field.bit_length
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * The Value is larger than the maximum value that can fit into&n;&t;&t; * the register.&n;&t;&t; */
r_return
(paren
id|TRUE
)paren
suffix:semicolon
)brace
multiline_comment|/* The Value will fit into the field with no truncation */
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ex_field_datum_io&n; *&n; * PARAMETERS:  *obj_desc               - Field to be read&n; *              field_datum_byte_offset - Byte offset of this datum within the&n; *                                        parent field&n; *              *Value                  - Where to store value (must be 64 bits)&n; *              read_write              - Read or Write flag&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Read or Write a single datum of a field.  The field_type is&n; *              demultiplexed here to handle the different types of fields&n; *              (buffer_field, region_field, index_field, bank_field)&n; *&n; ******************************************************************************/
id|acpi_status
DECL|function|acpi_ex_field_datum_io
id|acpi_ex_field_datum_io
(paren
r_union
id|acpi_operand_object
op_star
id|obj_desc
comma
id|u32
id|field_datum_byte_offset
comma
id|acpi_integer
op_star
id|value
comma
id|u32
id|read_write
)paren
(brace
id|acpi_status
id|status
suffix:semicolon
id|acpi_integer
id|local_value
suffix:semicolon
id|ACPI_FUNCTION_TRACE_U32
(paren
l_string|&quot;ex_field_datum_io&quot;
comma
id|field_datum_byte_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_write
op_eq
id|ACPI_READ
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
(brace
id|local_value
op_assign
l_int|0
suffix:semicolon
id|value
op_assign
op_amp
id|local_value
suffix:semicolon
multiline_comment|/* To support reads without saving return value */
)brace
multiline_comment|/* Clear the entire return buffer first, [Very Important!] */
op_star
id|value
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The four types of fields are:&n;&t; *&n;&t; * buffer_field - Read/write from/to a Buffer&n;&t; * region_field - Read/write from/to a Operation Region.&n;&t; * bank_field  - Write to a Bank Register, then read/write from/to an op_region&n;&t; * index_field - Write to an Index Register, then read/write from/to a Data Register&n;&t; */
r_switch
c_cond
(paren
id|ACPI_GET_OBJECT_TYPE
(paren
id|obj_desc
)paren
)paren
(brace
r_case
id|ACPI_TYPE_BUFFER_FIELD
suffix:colon
multiline_comment|/*&n;&t;&t; * If the buffer_field arguments have not been previously evaluated,&n;&t;&t; * evaluate them now and save the results.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|obj_desc-&gt;common.flags
op_amp
id|AOPOBJ_DATA_VALID
)paren
)paren
(brace
id|status
op_assign
id|acpi_ds_get_buffer_field_arguments
(paren
id|obj_desc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|read_write
op_eq
id|ACPI_READ
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Copy the data from the source buffer.&n;&t;&t;&t; * Length is the field width in bytes.&n;&t;&t;&t; */
id|ACPI_MEMCPY
(paren
id|value
comma
(paren
id|obj_desc-&gt;buffer_field.buffer_obj
)paren
op_member_access_from_pointer
id|buffer.pointer
op_plus
id|obj_desc-&gt;buffer_field.base_byte_offset
op_plus
id|field_datum_byte_offset
comma
id|obj_desc-&gt;common_field.access_byte_width
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Copy the data to the target buffer.&n;&t;&t;&t; * Length is the field width in bytes.&n;&t;&t;&t; */
id|ACPI_MEMCPY
(paren
(paren
id|obj_desc-&gt;buffer_field.buffer_obj
)paren
op_member_access_from_pointer
id|buffer.pointer
op_plus
id|obj_desc-&gt;buffer_field.base_byte_offset
op_plus
id|field_datum_byte_offset
comma
id|value
comma
id|obj_desc-&gt;common_field.access_byte_width
)paren
suffix:semicolon
)brace
id|status
op_assign
id|AE_OK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACPI_TYPE_LOCAL_BANK_FIELD
suffix:colon
multiline_comment|/* Ensure that the bank_value is not beyond the capacity of the register */
r_if
c_cond
(paren
id|acpi_ex_register_overflow
(paren
id|obj_desc-&gt;bank_field.bank_obj
comma
(paren
id|acpi_integer
)paren
id|obj_desc-&gt;bank_field.value
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|AE_AML_REGISTER_LIMIT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * For bank_fields, we must write the bank_value to the bank_register&n;&t;&t; * (itself a region_field) before we can access the data.&n;&t;&t; */
id|status
op_assign
id|acpi_ex_insert_into_field
(paren
id|obj_desc-&gt;bank_field.bank_obj
comma
op_amp
id|obj_desc-&gt;bank_field.value
comma
r_sizeof
(paren
id|obj_desc-&gt;bank_field.value
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Now that the Bank has been selected, fall through to the&n;&t;&t; * region_field case and write the datum to the Operation Region&n;&t;&t; */
multiline_comment|/*lint -fallthrough */
r_case
id|ACPI_TYPE_LOCAL_REGION_FIELD
suffix:colon
multiline_comment|/*&n;&t;&t; * For simple region_fields, we just directly access the owning&n;&t;&t; * Operation Region.&n;&t;&t; */
id|status
op_assign
id|acpi_ex_access_region
(paren
id|obj_desc
comma
id|field_datum_byte_offset
comma
id|value
comma
id|read_write
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACPI_TYPE_LOCAL_INDEX_FIELD
suffix:colon
multiline_comment|/* Ensure that the index_value is not beyond the capacity of the register */
r_if
c_cond
(paren
id|acpi_ex_register_overflow
(paren
id|obj_desc-&gt;index_field.index_obj
comma
(paren
id|acpi_integer
)paren
id|obj_desc-&gt;index_field.value
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|AE_AML_REGISTER_LIMIT
)paren
suffix:semicolon
)brace
multiline_comment|/* Write the index value to the index_register (itself a region_field) */
id|field_datum_byte_offset
op_add_assign
id|obj_desc-&gt;index_field.value
suffix:semicolon
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_BFIELD
comma
l_string|&quot;Write to Index Register: Value %8.8X&bslash;n&quot;
comma
id|field_datum_byte_offset
)paren
)paren
suffix:semicolon
id|status
op_assign
id|acpi_ex_insert_into_field
(paren
id|obj_desc-&gt;index_field.index_obj
comma
op_amp
id|field_datum_byte_offset
comma
r_sizeof
(paren
id|field_datum_byte_offset
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_BFIELD
comma
l_string|&quot;I/O to Data Register: value_ptr %p&bslash;n&quot;
comma
id|value
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_write
op_eq
id|ACPI_READ
)paren
(brace
multiline_comment|/* Read the datum from the data_register */
id|status
op_assign
id|acpi_ex_extract_from_field
(paren
id|obj_desc-&gt;index_field.data_obj
comma
id|value
comma
r_sizeof
(paren
id|acpi_integer
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Write the datum to the data_register */
id|status
op_assign
id|acpi_ex_insert_into_field
(paren
id|obj_desc-&gt;index_field.data_obj
comma
id|value
comma
r_sizeof
(paren
id|acpi_integer
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|ACPI_REPORT_ERROR
(paren
(paren
l_string|&quot;Wrong object type in field I/O %X&bslash;n&quot;
comma
id|ACPI_GET_OBJECT_TYPE
(paren
id|obj_desc
)paren
)paren
)paren
suffix:semicolon
id|status
op_assign
id|AE_AML_INTERNAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ACPI_SUCCESS
(paren
id|status
)paren
)paren
(brace
r_if
c_cond
(paren
id|read_write
op_eq
id|ACPI_READ
)paren
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_BFIELD
comma
l_string|&quot;Value Read %8.8X%8.8X, Width %d&bslash;n&quot;
comma
id|ACPI_FORMAT_UINT64
(paren
op_star
id|value
)paren
comma
id|obj_desc-&gt;common_field.access_byte_width
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_BFIELD
comma
l_string|&quot;Value Written %8.8X%8.8X, Width %d&bslash;n&quot;
comma
id|ACPI_FORMAT_UINT64
(paren
op_star
id|value
)paren
comma
id|obj_desc-&gt;common_field.access_byte_width
)paren
)paren
suffix:semicolon
)brace
)brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ex_write_with_update_rule&n; *&n; * PARAMETERS:  *obj_desc           - Field to be set&n; *              Value               - Value to store&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Apply the field update rule to a field write&n; *&n; ******************************************************************************/
id|acpi_status
DECL|function|acpi_ex_write_with_update_rule
id|acpi_ex_write_with_update_rule
(paren
r_union
id|acpi_operand_object
op_star
id|obj_desc
comma
id|acpi_integer
id|mask
comma
id|acpi_integer
id|field_value
comma
id|u32
id|field_datum_byte_offset
)paren
(brace
id|acpi_status
id|status
op_assign
id|AE_OK
suffix:semicolon
id|acpi_integer
id|merged_value
suffix:semicolon
id|acpi_integer
id|current_value
suffix:semicolon
id|ACPI_FUNCTION_TRACE_U32
(paren
l_string|&quot;ex_write_with_update_rule&quot;
comma
id|mask
)paren
suffix:semicolon
multiline_comment|/* Start with the new bits  */
id|merged_value
op_assign
id|field_value
suffix:semicolon
multiline_comment|/* If the mask is all ones, we don&squot;t need to worry about the update rule */
r_if
c_cond
(paren
id|mask
op_ne
id|ACPI_INTEGER_MAX
)paren
(brace
multiline_comment|/* Decode the update rule */
r_switch
c_cond
(paren
id|obj_desc-&gt;common_field.field_flags
op_amp
id|AML_FIELD_UPDATE_RULE_MASK
)paren
(brace
r_case
id|AML_FIELD_UPDATE_PRESERVE
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Check if update rule needs to be applied (not if mask is all&n;&t;&t;&t; * ones)  The left shift drops the bits we want to ignore.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
op_complement
id|mask
op_lshift
(paren
id|ACPI_MUL_8
(paren
r_sizeof
(paren
id|mask
)paren
)paren
op_minus
id|ACPI_MUL_8
(paren
id|obj_desc-&gt;common_field.access_byte_width
)paren
)paren
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Read the current contents of the byte/word/dword containing&n;&t;&t;&t;&t; * the field, and merge with the new field value.&n;&t;&t;&t;&t; */
id|status
op_assign
id|acpi_ex_field_datum_io
(paren
id|obj_desc
comma
id|field_datum_byte_offset
comma
op_amp
id|current_value
comma
id|ACPI_READ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
id|merged_value
op_or_assign
(paren
id|current_value
op_amp
op_complement
id|mask
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AML_FIELD_UPDATE_WRITE_AS_ONES
suffix:colon
multiline_comment|/* Set positions outside the field to all ones */
id|merged_value
op_or_assign
op_complement
id|mask
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AML_FIELD_UPDATE_WRITE_AS_ZEROS
suffix:colon
multiline_comment|/* Set positions outside the field to all zeros */
id|merged_value
op_and_assign
id|mask
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;write_with_update_rule: Unknown update_rule setting: %X&bslash;n&quot;
comma
(paren
id|obj_desc-&gt;common_field.field_flags
op_amp
id|AML_FIELD_UPDATE_RULE_MASK
)paren
)paren
)paren
suffix:semicolon
id|return_ACPI_STATUS
(paren
id|AE_AML_OPERAND_VALUE
)paren
suffix:semicolon
)brace
)brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_BFIELD
comma
l_string|&quot;Mask %8.8X%8.8X, datum_offset %X, Width %X, Value %8.8X%8.8X, merged_value %8.8X%8.8X&bslash;n&quot;
comma
id|ACPI_FORMAT_UINT64
(paren
id|mask
)paren
comma
id|field_datum_byte_offset
comma
id|obj_desc-&gt;common_field.access_byte_width
comma
id|ACPI_FORMAT_UINT64
(paren
id|field_value
)paren
comma
id|ACPI_FORMAT_UINT64
(paren
id|merged_value
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Write the merged value */
id|status
op_assign
id|acpi_ex_field_datum_io
(paren
id|obj_desc
comma
id|field_datum_byte_offset
comma
op_amp
id|merged_value
comma
id|ACPI_WRITE
)paren
suffix:semicolon
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ex_extract_from_field&n; *&n; * PARAMETERS:  obj_desc            - Field to be read&n; *              Buffer              - Where to store the field data&n; *              buffer_length       - Length of Buffer&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Retrieve the current value of the given field&n; *&n; ******************************************************************************/
id|acpi_status
DECL|function|acpi_ex_extract_from_field
id|acpi_ex_extract_from_field
(paren
r_union
id|acpi_operand_object
op_star
id|obj_desc
comma
r_void
op_star
id|buffer
comma
id|u32
id|buffer_length
)paren
(brace
id|acpi_status
id|status
suffix:semicolon
id|acpi_integer
id|raw_datum
suffix:semicolon
id|acpi_integer
id|merged_datum
suffix:semicolon
id|u32
id|field_offset
op_assign
l_int|0
suffix:semicolon
id|u32
id|buffer_offset
op_assign
l_int|0
suffix:semicolon
id|u32
id|buffer_tail_bits
suffix:semicolon
id|u32
id|datum_count
suffix:semicolon
id|u32
id|field_datum_count
suffix:semicolon
id|u32
id|i
suffix:semicolon
id|ACPI_FUNCTION_TRACE
(paren
l_string|&quot;ex_extract_from_field&quot;
)paren
suffix:semicolon
multiline_comment|/* Validate target buffer and clear it */
r_if
c_cond
(paren
id|buffer_length
OL
id|ACPI_ROUND_BITS_UP_TO_BYTES
(paren
id|obj_desc-&gt;common_field.bit_length
)paren
)paren
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;Field size %X (bits) is too large for buffer (%X)&bslash;n&quot;
comma
id|obj_desc-&gt;common_field.bit_length
comma
id|buffer_length
)paren
)paren
suffix:semicolon
id|return_ACPI_STATUS
(paren
id|AE_BUFFER_OVERFLOW
)paren
suffix:semicolon
)brace
id|ACPI_MEMSET
(paren
id|buffer
comma
l_int|0
comma
id|buffer_length
)paren
suffix:semicolon
multiline_comment|/* Compute the number of datums (access width data items) */
id|datum_count
op_assign
id|ACPI_ROUND_UP_TO
(paren
id|obj_desc-&gt;common_field.bit_length
comma
id|obj_desc-&gt;common_field.access_bit_width
)paren
suffix:semicolon
id|field_datum_count
op_assign
id|ACPI_ROUND_UP_TO
(paren
id|obj_desc-&gt;common_field.bit_length
op_plus
id|obj_desc-&gt;common_field.start_field_bit_offset
comma
id|obj_desc-&gt;common_field.access_bit_width
)paren
suffix:semicolon
multiline_comment|/* Priming read from the field */
id|status
op_assign
id|acpi_ex_field_datum_io
(paren
id|obj_desc
comma
id|field_offset
comma
op_amp
id|raw_datum
comma
id|ACPI_READ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
id|merged_datum
op_assign
id|raw_datum
op_rshift
id|obj_desc-&gt;common_field.start_field_bit_offset
suffix:semicolon
multiline_comment|/* Read the rest of the field */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|field_datum_count
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Get next input datum from the field */
id|field_offset
op_add_assign
id|obj_desc-&gt;common_field.access_byte_width
suffix:semicolon
id|status
op_assign
id|acpi_ex_field_datum_io
(paren
id|obj_desc
comma
id|field_offset
comma
op_amp
id|raw_datum
comma
id|ACPI_READ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/* Merge with previous datum if necessary */
id|merged_datum
op_or_assign
id|raw_datum
op_lshift
(paren
id|obj_desc-&gt;common_field.access_bit_width
op_minus
id|obj_desc-&gt;common_field.start_field_bit_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|datum_count
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/* Write merged datum to target buffer */
id|ACPI_MEMCPY
(paren
(paren
(paren
r_char
op_star
)paren
id|buffer
)paren
op_plus
id|buffer_offset
comma
op_amp
id|merged_datum
comma
id|ACPI_MIN
c_func
(paren
id|obj_desc-&gt;common_field.access_byte_width
comma
id|buffer_length
op_minus
id|buffer_offset
)paren
)paren
suffix:semicolon
id|buffer_offset
op_add_assign
id|obj_desc-&gt;common_field.access_byte_width
suffix:semicolon
id|merged_datum
op_assign
id|raw_datum
op_rshift
id|obj_desc-&gt;common_field.start_field_bit_offset
suffix:semicolon
)brace
multiline_comment|/* Mask off any extra bits in the last datum */
id|buffer_tail_bits
op_assign
id|obj_desc-&gt;common_field.bit_length
op_mod
id|obj_desc-&gt;common_field.access_bit_width
suffix:semicolon
r_if
c_cond
(paren
id|buffer_tail_bits
)paren
(brace
id|merged_datum
op_and_assign
id|ACPI_MASK_BITS_ABOVE
(paren
id|buffer_tail_bits
)paren
suffix:semicolon
)brace
multiline_comment|/* Write the last datum to the buffer */
id|ACPI_MEMCPY
(paren
(paren
(paren
r_char
op_star
)paren
id|buffer
)paren
op_plus
id|buffer_offset
comma
op_amp
id|merged_datum
comma
id|ACPI_MIN
c_func
(paren
id|obj_desc-&gt;common_field.access_byte_width
comma
id|buffer_length
op_minus
id|buffer_offset
)paren
)paren
suffix:semicolon
id|return_ACPI_STATUS
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ex_insert_into_field&n; *&n; * PARAMETERS:  obj_desc            - Field to be written&n; *              Buffer              - Data to be written&n; *              buffer_length       - Length of Buffer&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Store the Buffer contents into the given field&n; *&n; ******************************************************************************/
id|acpi_status
DECL|function|acpi_ex_insert_into_field
id|acpi_ex_insert_into_field
(paren
r_union
id|acpi_operand_object
op_star
id|obj_desc
comma
r_void
op_star
id|buffer
comma
id|u32
id|buffer_length
)paren
(brace
id|acpi_status
id|status
suffix:semicolon
id|acpi_integer
id|mask
suffix:semicolon
id|acpi_integer
id|merged_datum
suffix:semicolon
id|acpi_integer
id|raw_datum
op_assign
l_int|0
suffix:semicolon
id|u32
id|field_offset
op_assign
l_int|0
suffix:semicolon
id|u32
id|buffer_offset
op_assign
l_int|0
suffix:semicolon
id|u32
id|buffer_tail_bits
suffix:semicolon
id|u32
id|datum_count
suffix:semicolon
id|u32
id|field_datum_count
suffix:semicolon
id|u32
id|i
suffix:semicolon
id|ACPI_FUNCTION_TRACE
(paren
l_string|&quot;ex_insert_into_field&quot;
)paren
suffix:semicolon
multiline_comment|/* Validate input buffer */
r_if
c_cond
(paren
id|buffer_length
OL
id|ACPI_ROUND_BITS_UP_TO_BYTES
(paren
id|obj_desc-&gt;common_field.bit_length
)paren
)paren
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;Field size %X (bits) is too large for buffer (%X)&bslash;n&quot;
comma
id|obj_desc-&gt;common_field.bit_length
comma
id|buffer_length
)paren
)paren
suffix:semicolon
id|return_ACPI_STATUS
(paren
id|AE_BUFFER_OVERFLOW
)paren
suffix:semicolon
)brace
multiline_comment|/* Compute the number of datums (access width data items) */
id|mask
op_assign
id|ACPI_MASK_BITS_BELOW
(paren
id|obj_desc-&gt;common_field.start_field_bit_offset
)paren
suffix:semicolon
id|datum_count
op_assign
id|ACPI_ROUND_UP_TO
(paren
id|obj_desc-&gt;common_field.bit_length
comma
id|obj_desc-&gt;common_field.access_bit_width
)paren
suffix:semicolon
id|field_datum_count
op_assign
id|ACPI_ROUND_UP_TO
(paren
id|obj_desc-&gt;common_field.bit_length
op_plus
id|obj_desc-&gt;common_field.start_field_bit_offset
comma
id|obj_desc-&gt;common_field.access_bit_width
)paren
suffix:semicolon
multiline_comment|/* Get initial Datum from the input buffer */
id|ACPI_MEMCPY
(paren
op_amp
id|raw_datum
comma
id|buffer
comma
id|ACPI_MIN
c_func
(paren
id|obj_desc-&gt;common_field.access_byte_width
comma
id|buffer_length
op_minus
id|buffer_offset
)paren
)paren
suffix:semicolon
id|merged_datum
op_assign
id|raw_datum
op_lshift
id|obj_desc-&gt;common_field.start_field_bit_offset
suffix:semicolon
multiline_comment|/* Write the entire field */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|field_datum_count
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Write merged datum to the target field */
id|merged_datum
op_and_assign
id|mask
suffix:semicolon
id|status
op_assign
id|acpi_ex_write_with_update_rule
(paren
id|obj_desc
comma
id|mask
comma
id|merged_datum
comma
id|field_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/* Start new output datum by merging with previous input datum */
id|field_offset
op_add_assign
id|obj_desc-&gt;common_field.access_byte_width
suffix:semicolon
id|merged_datum
op_assign
id|raw_datum
op_rshift
(paren
id|obj_desc-&gt;common_field.access_bit_width
op_minus
id|obj_desc-&gt;common_field.start_field_bit_offset
)paren
suffix:semicolon
id|mask
op_assign
id|ACPI_INTEGER_MAX
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|datum_count
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/* Get the next input datum from the buffer */
id|buffer_offset
op_add_assign
id|obj_desc-&gt;common_field.access_byte_width
suffix:semicolon
id|ACPI_MEMCPY
(paren
op_amp
id|raw_datum
comma
(paren
(paren
r_char
op_star
)paren
id|buffer
)paren
op_plus
id|buffer_offset
comma
id|ACPI_MIN
c_func
(paren
id|obj_desc-&gt;common_field.access_byte_width
comma
id|buffer_length
op_minus
id|buffer_offset
)paren
)paren
suffix:semicolon
id|merged_datum
op_or_assign
id|raw_datum
op_lshift
id|obj_desc-&gt;common_field.start_field_bit_offset
suffix:semicolon
)brace
multiline_comment|/* Mask off any extra bits in the last datum */
id|buffer_tail_bits
op_assign
(paren
id|obj_desc-&gt;common_field.bit_length
op_plus
id|obj_desc-&gt;common_field.start_field_bit_offset
)paren
op_mod
id|obj_desc-&gt;common_field.access_bit_width
suffix:semicolon
r_if
c_cond
(paren
id|buffer_tail_bits
)paren
(brace
id|mask
op_and_assign
id|ACPI_MASK_BITS_ABOVE
(paren
id|buffer_tail_bits
)paren
suffix:semicolon
)brace
multiline_comment|/* Write the last datum to the field */
id|merged_datum
op_and_assign
id|mask
suffix:semicolon
id|status
op_assign
id|acpi_ex_write_with_update_rule
(paren
id|obj_desc
comma
id|mask
comma
id|merged_datum
comma
id|field_offset
)paren
suffix:semicolon
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
eof
