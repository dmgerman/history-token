multiline_comment|/******************************************************************************&n; *&n; * Module Name: exfldio - Aml Field I/O&n; *&n; *****************************************************************************/
multiline_comment|/*&n; * Copyright (C) 2000 - 2004, R. Byron Moore&n; * All rights reserved.&n; *&n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions&n; * are met:&n; * 1. Redistributions of source code must retain the above copyright&n; *    notice, this list of conditions, and the following disclaimer,&n; *    without modification.&n; * 2. Redistributions in binary form must reproduce at minimum a disclaimer&n; *    substantially similar to the &quot;NO WARRANTY&quot; disclaimer below&n; *    (&quot;Disclaimer&quot;) and any redistribution must be conditioned upon&n; *    including a substantially similar Disclaimer requirement for further&n; *    binary redistribution.&n; * 3. Neither the names of the above-listed copyright holders nor the names&n; *    of any contributors may be used to endorse or promote products derived&n; *    from this software without specific prior written permission.&n; *&n; * Alternatively, this software may be distributed under the terms of the&n; * GNU General Public License (&quot;GPL&quot;) version 2 as published by the Free&n; * Software Foundation.&n; *&n; * NO WARRANTY&n; * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS&n; * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT&n; * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR&n; * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT&n; * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL&n; * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS&n; * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)&n; * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,&n; * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING&n; * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE&n; * POSSIBILITY OF SUCH DAMAGES.&n; */
macro_line|#include &lt;acpi/acpi.h&gt;
macro_line|#include &lt;acpi/acinterp.h&gt;
macro_line|#include &lt;acpi/amlcode.h&gt;
macro_line|#include &lt;acpi/acevents.h&gt;
macro_line|#include &lt;acpi/acdispat.h&gt;
DECL|macro|_COMPONENT
mdefine_line|#define _COMPONENT          ACPI_EXECUTER
id|ACPI_MODULE_NAME
(paren
l_string|&quot;exfldio&quot;
)paren
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ex_setup_region&n; *&n; * PARAMETERS:  *obj_desc               - Field to be read or written&n; *              field_datum_byte_offset - Byte offset of this datum within the&n; *                                        parent field&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Common processing for acpi_ex_extract_from_field and&n; *              acpi_ex_insert_into_field. Initialize the Region if necessary and&n; *              validate the request.&n; *&n; ******************************************************************************/
id|acpi_status
DECL|function|acpi_ex_setup_region
id|acpi_ex_setup_region
(paren
r_union
id|acpi_operand_object
op_star
id|obj_desc
comma
id|u32
id|field_datum_byte_offset
)paren
(brace
id|acpi_status
id|status
op_assign
id|AE_OK
suffix:semicolon
r_union
id|acpi_operand_object
op_star
id|rgn_desc
suffix:semicolon
id|ACPI_FUNCTION_TRACE_U32
(paren
l_string|&quot;ex_setup_region&quot;
comma
id|field_datum_byte_offset
)paren
suffix:semicolon
id|rgn_desc
op_assign
id|obj_desc-&gt;common_field.region_obj
suffix:semicolon
multiline_comment|/* We must have a valid region */
r_if
c_cond
(paren
id|ACPI_GET_OBJECT_TYPE
(paren
id|rgn_desc
)paren
op_ne
id|ACPI_TYPE_REGION
)paren
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;Needed Region, found type %X (%s)&bslash;n&quot;
comma
id|ACPI_GET_OBJECT_TYPE
(paren
id|rgn_desc
)paren
comma
id|acpi_ut_get_object_type_name
(paren
id|rgn_desc
)paren
)paren
)paren
suffix:semicolon
id|return_ACPI_STATUS
(paren
id|AE_AML_OPERAND_TYPE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the Region Address and Length have not been previously evaluated,&n;&t; * evaluate them now and save the results.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|rgn_desc-&gt;common.flags
op_amp
id|AOPOBJ_DATA_VALID
)paren
)paren
(brace
id|status
op_assign
id|acpi_ds_get_region_arguments
(paren
id|rgn_desc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rgn_desc-&gt;region.space_id
op_eq
id|ACPI_ADR_SPACE_SMBUS
)paren
(brace
multiline_comment|/* SMBus has a non-linear address space */
id|return_ACPI_STATUS
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
macro_line|#ifdef ACPI_UNDER_DEVELOPMENT
multiline_comment|/*&n;&t; * If the Field access is any_acc, we can now compute the optimal&n;&t; * access (because we know know the length of the parent region)&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|obj_desc-&gt;common.flags
op_amp
id|AOPOBJ_DATA_VALID
)paren
)paren
(brace
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Validate the request.  The entire request from the byte offset for a&n;&t; * length of one field datum (access width) must fit within the region.&n;&t; * (Region length is specified in bytes)&n;&t; */
r_if
c_cond
(paren
id|rgn_desc-&gt;region.length
OL
(paren
id|obj_desc-&gt;common_field.base_byte_offset
op_plus
id|field_datum_byte_offset
op_plus
id|obj_desc-&gt;common_field.access_byte_width
)paren
)paren
(brace
r_if
c_cond
(paren
id|acpi_gbl_enable_interpreter_slack
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Slack mode only:  We will go ahead and allow access to this&n;&t;&t;&t; * field if it is within the region length rounded up to the next&n;&t;&t;&t; * access width boundary.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ACPI_ROUND_UP
(paren
id|rgn_desc-&gt;region.length
comma
id|obj_desc-&gt;common_field.access_byte_width
)paren
op_ge
(paren
id|obj_desc-&gt;common_field.base_byte_offset
op_plus
id|obj_desc-&gt;common_field.access_byte_width
op_plus
id|field_datum_byte_offset
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rgn_desc-&gt;region.length
OL
id|obj_desc-&gt;common_field.access_byte_width
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * This is the case where the access_type (acc_word, etc.) is wider&n;&t;&t;&t; * than the region itself.  For example, a region of length one&n;&t;&t;&t; * byte, and a field with Dword access specified.&n;&t;&t;&t; */
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;Field [%4.4s] access width (%d bytes) too large for region [%4.4s] (length %X)&bslash;n&quot;
comma
id|acpi_ut_get_node_name
(paren
id|obj_desc-&gt;common_field.node
)paren
comma
id|obj_desc-&gt;common_field.access_byte_width
comma
id|acpi_ut_get_node_name
(paren
id|rgn_desc-&gt;region.node
)paren
comma
id|rgn_desc-&gt;region.length
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Offset rounded up to next multiple of field width&n;&t;&t; * exceeds region length, indicate an error&n;&t;&t; */
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;Field [%4.4s] Base+Offset+Width %X+%X+%X is beyond end of region [%4.4s] (length %X)&bslash;n&quot;
comma
id|acpi_ut_get_node_name
(paren
id|obj_desc-&gt;common_field.node
)paren
comma
id|obj_desc-&gt;common_field.base_byte_offset
comma
id|field_datum_byte_offset
comma
id|obj_desc-&gt;common_field.access_byte_width
comma
id|acpi_ut_get_node_name
(paren
id|rgn_desc-&gt;region.node
)paren
comma
id|rgn_desc-&gt;region.length
)paren
)paren
suffix:semicolon
id|return_ACPI_STATUS
(paren
id|AE_AML_REGION_LIMIT
)paren
suffix:semicolon
)brace
id|return_ACPI_STATUS
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ex_access_region&n; *&n; * PARAMETERS:  *obj_desc               - Field to be read&n; *              field_datum_byte_offset - Byte offset of this datum within the&n; *                                        parent field&n; *              *Value                  - Where to store value (must at least&n; *                                        the size of acpi_integer)&n; *              Function                - Read or Write flag plus other region-&n; *                                        dependent flags&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Read or Write a single field datum to an Operation Region.&n; *&n; ******************************************************************************/
id|acpi_status
DECL|function|acpi_ex_access_region
id|acpi_ex_access_region
(paren
r_union
id|acpi_operand_object
op_star
id|obj_desc
comma
id|u32
id|field_datum_byte_offset
comma
id|acpi_integer
op_star
id|value
comma
id|u32
id|function
)paren
(brace
id|acpi_status
id|status
suffix:semicolon
r_union
id|acpi_operand_object
op_star
id|rgn_desc
suffix:semicolon
id|acpi_physical_address
id|address
suffix:semicolon
id|ACPI_FUNCTION_TRACE
(paren
l_string|&quot;ex_access_region&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ensure that the region operands are fully evaluated and verify&n;&t; * the validity of the request&n;&t; */
id|status
op_assign
id|acpi_ex_setup_region
(paren
id|obj_desc
comma
id|field_datum_byte_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The physical address of this field datum is:&n;&t; *&n;&t; * 1) The base of the region, plus&n;&t; * 2) The base offset of the field, plus&n;&t; * 3) The current offset into the field&n;&t; */
id|rgn_desc
op_assign
id|obj_desc-&gt;common_field.region_obj
suffix:semicolon
id|address
op_assign
id|rgn_desc-&gt;region.address
op_plus
id|obj_desc-&gt;common_field.base_byte_offset
op_plus
id|field_datum_byte_offset
suffix:semicolon
r_if
c_cond
(paren
(paren
id|function
op_amp
id|ACPI_IO_MASK
)paren
op_eq
id|ACPI_READ
)paren
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_BFIELD
comma
l_string|&quot;[READ]&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_BFIELD
comma
l_string|&quot;[WRITE]&quot;
)paren
)paren
suffix:semicolon
)brace
id|ACPI_DEBUG_PRINT_RAW
(paren
(paren
id|ACPI_DB_BFIELD
comma
l_string|&quot; Region [%s:%X], Width %X, byte_base %X, Offset %X at %8.8X%8.8X&bslash;n&quot;
comma
id|acpi_ut_get_region_name
(paren
id|rgn_desc-&gt;region.space_id
)paren
comma
id|rgn_desc-&gt;region.space_id
comma
id|obj_desc-&gt;common_field.access_byte_width
comma
id|obj_desc-&gt;common_field.base_byte_offset
comma
id|field_datum_byte_offset
comma
id|ACPI_FORMAT_UINT64
(paren
id|address
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Invoke the appropriate address_space/op_region handler */
id|status
op_assign
id|acpi_ev_address_space_dispatch
(paren
id|rgn_desc
comma
id|function
comma
id|address
comma
id|ACPI_MUL_8
(paren
id|obj_desc-&gt;common_field.access_byte_width
)paren
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_if
c_cond
(paren
id|status
op_eq
id|AE_NOT_IMPLEMENTED
)paren
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;Region %s(%X) not implemented&bslash;n&quot;
comma
id|acpi_ut_get_region_name
(paren
id|rgn_desc-&gt;region.space_id
)paren
comma
id|rgn_desc-&gt;region.space_id
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_eq
id|AE_NOT_EXIST
)paren
(brace
id|ACPI_REPORT_ERROR
(paren
(paren
l_string|&quot;Region %s(%X) has no handler&bslash;n&quot;
comma
id|acpi_ut_get_region_name
(paren
id|rgn_desc-&gt;region.space_id
)paren
comma
id|rgn_desc-&gt;region.space_id
)paren
)paren
suffix:semicolon
)brace
)brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ex_register_overflow&n; *&n; * PARAMETERS:  *obj_desc               - Register(Field) to be written&n; *              Value                   - Value to be stored&n; *&n; * RETURN:      TRUE if value overflows the field, FALSE otherwise&n; *&n; * DESCRIPTION: Check if a value is out of range of the field being written.&n; *              Used to check if the values written to Index and Bank registers&n; *              are out of range.  Normally, the value is simply truncated&n; *              to fit the field, but this case is most likely a serious&n; *              coding error in the ASL.&n; *&n; ******************************************************************************/
id|u8
DECL|function|acpi_ex_register_overflow
id|acpi_ex_register_overflow
(paren
r_union
id|acpi_operand_object
op_star
id|obj_desc
comma
id|acpi_integer
id|value
)paren
(brace
r_if
c_cond
(paren
id|obj_desc-&gt;common_field.bit_length
op_ge
id|ACPI_INTEGER_BIT_SIZE
)paren
(brace
multiline_comment|/*&n;&t;&t; * The field is large enough to hold the maximum integer, so we can&n;&t;&t; * never overflow it.&n;&t;&t; */
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|value
op_ge
(paren
(paren
id|acpi_integer
)paren
l_int|1
op_lshift
id|obj_desc-&gt;common_field.bit_length
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * The Value is larger than the maximum value that can fit into&n;&t;&t; * the register.&n;&t;&t; */
r_return
(paren
id|TRUE
)paren
suffix:semicolon
)brace
multiline_comment|/* The Value will fit into the field with no truncation */
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ex_field_datum_io&n; *&n; * PARAMETERS:  *obj_desc               - Field to be read&n; *              field_datum_byte_offset - Byte offset of this datum within the&n; *                                        parent field&n; *              *Value                  - Where to store value (must be 64 bits)&n; *              read_write              - Read or Write flag&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Read or Write a single datum of a field.  The field_type is&n; *              demultiplexed here to handle the different types of fields&n; *              (buffer_field, region_field, index_field, bank_field)&n; *&n; ******************************************************************************/
id|acpi_status
DECL|function|acpi_ex_field_datum_io
id|acpi_ex_field_datum_io
(paren
r_union
id|acpi_operand_object
op_star
id|obj_desc
comma
id|u32
id|field_datum_byte_offset
comma
id|acpi_integer
op_star
id|value
comma
id|u32
id|read_write
)paren
(brace
id|acpi_status
id|status
suffix:semicolon
id|acpi_integer
id|local_value
suffix:semicolon
id|ACPI_FUNCTION_TRACE_U32
(paren
l_string|&quot;ex_field_datum_io&quot;
comma
id|field_datum_byte_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_write
op_eq
id|ACPI_READ
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
(brace
id|local_value
op_assign
l_int|0
suffix:semicolon
id|value
op_assign
op_amp
id|local_value
suffix:semicolon
multiline_comment|/* To support reads without saving return value */
)brace
multiline_comment|/* Clear the entire return buffer first, [Very Important!] */
op_star
id|value
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The four types of fields are:&n;&t; *&n;&t; * buffer_field - Read/write from/to a Buffer&n;&t; * region_field - Read/write from/to a Operation Region.&n;&t; * bank_field  - Write to a Bank Register, then read/write from/to an op_region&n;&t; * index_field - Write to an Index Register, then read/write from/to a Data Register&n;&t; */
r_switch
c_cond
(paren
id|ACPI_GET_OBJECT_TYPE
(paren
id|obj_desc
)paren
)paren
(brace
r_case
id|ACPI_TYPE_BUFFER_FIELD
suffix:colon
multiline_comment|/*&n;&t;&t; * If the buffer_field arguments have not been previously evaluated,&n;&t;&t; * evaluate them now and save the results.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|obj_desc-&gt;common.flags
op_amp
id|AOPOBJ_DATA_VALID
)paren
)paren
(brace
id|status
op_assign
id|acpi_ds_get_buffer_field_arguments
(paren
id|obj_desc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|read_write
op_eq
id|ACPI_READ
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Copy the data from the source buffer.&n;&t;&t;&t; * Length is the field width in bytes.&n;&t;&t;&t; */
id|ACPI_MEMCPY
(paren
id|value
comma
(paren
id|obj_desc-&gt;buffer_field.buffer_obj
)paren
op_member_access_from_pointer
id|buffer.pointer
op_plus
id|obj_desc-&gt;buffer_field.base_byte_offset
op_plus
id|field_datum_byte_offset
comma
id|obj_desc-&gt;common_field.access_byte_width
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Copy the data to the target buffer.&n;&t;&t;&t; * Length is the field width in bytes.&n;&t;&t;&t; */
id|ACPI_MEMCPY
(paren
(paren
id|obj_desc-&gt;buffer_field.buffer_obj
)paren
op_member_access_from_pointer
id|buffer.pointer
op_plus
id|obj_desc-&gt;buffer_field.base_byte_offset
op_plus
id|field_datum_byte_offset
comma
id|value
comma
id|obj_desc-&gt;common_field.access_byte_width
)paren
suffix:semicolon
)brace
id|status
op_assign
id|AE_OK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACPI_TYPE_LOCAL_BANK_FIELD
suffix:colon
multiline_comment|/* Ensure that the bank_value is not beyond the capacity of the register */
r_if
c_cond
(paren
id|acpi_ex_register_overflow
(paren
id|obj_desc-&gt;bank_field.bank_obj
comma
(paren
id|acpi_integer
)paren
id|obj_desc-&gt;bank_field.value
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|AE_AML_REGISTER_LIMIT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * For bank_fields, we must write the bank_value to the bank_register&n;&t;&t; * (itself a region_field) before we can access the data.&n;&t;&t; */
id|status
op_assign
id|acpi_ex_insert_into_field
(paren
id|obj_desc-&gt;bank_field.bank_obj
comma
op_amp
id|obj_desc-&gt;bank_field.value
comma
r_sizeof
(paren
id|obj_desc-&gt;bank_field.value
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Now that the Bank has been selected, fall through to the&n;&t;&t; * region_field case and write the datum to the Operation Region&n;&t;&t; */
multiline_comment|/*lint -fallthrough */
r_case
id|ACPI_TYPE_LOCAL_REGION_FIELD
suffix:colon
multiline_comment|/*&n;&t;&t; * For simple region_fields, we just directly access the owning&n;&t;&t; * Operation Region.&n;&t;&t; */
id|status
op_assign
id|acpi_ex_access_region
(paren
id|obj_desc
comma
id|field_datum_byte_offset
comma
id|value
comma
id|read_write
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACPI_TYPE_LOCAL_INDEX_FIELD
suffix:colon
multiline_comment|/* Ensure that the index_value is not beyond the capacity of the register */
r_if
c_cond
(paren
id|acpi_ex_register_overflow
(paren
id|obj_desc-&gt;index_field.index_obj
comma
(paren
id|acpi_integer
)paren
id|obj_desc-&gt;index_field.value
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|AE_AML_REGISTER_LIMIT
)paren
suffix:semicolon
)brace
multiline_comment|/* Write the index value to the index_register (itself a region_field) */
id|field_datum_byte_offset
op_add_assign
id|obj_desc-&gt;index_field.value
suffix:semicolon
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_BFIELD
comma
l_string|&quot;Write to Index Register: Value %8.8X&bslash;n&quot;
comma
id|field_datum_byte_offset
)paren
)paren
suffix:semicolon
id|status
op_assign
id|acpi_ex_insert_into_field
(paren
id|obj_desc-&gt;index_field.index_obj
comma
op_amp
id|field_datum_byte_offset
comma
r_sizeof
(paren
id|field_datum_byte_offset
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_BFIELD
comma
l_string|&quot;I/O to Data Register: value_ptr %p&bslash;n&quot;
comma
id|value
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_write
op_eq
id|ACPI_READ
)paren
(brace
multiline_comment|/* Read the datum from the data_register */
id|status
op_assign
id|acpi_ex_extract_from_field
(paren
id|obj_desc-&gt;index_field.data_obj
comma
id|value
comma
r_sizeof
(paren
id|acpi_integer
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Write the datum to the data_register */
id|status
op_assign
id|acpi_ex_insert_into_field
(paren
id|obj_desc-&gt;index_field.data_obj
comma
id|value
comma
r_sizeof
(paren
id|acpi_integer
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|ACPI_REPORT_ERROR
(paren
(paren
l_string|&quot;Wrong object type in field I/O %X&bslash;n&quot;
comma
id|ACPI_GET_OBJECT_TYPE
(paren
id|obj_desc
)paren
)paren
)paren
suffix:semicolon
id|status
op_assign
id|AE_AML_INTERNAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ACPI_SUCCESS
(paren
id|status
)paren
)paren
(brace
r_if
c_cond
(paren
id|read_write
op_eq
id|ACPI_READ
)paren
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_BFIELD
comma
l_string|&quot;Value Read %8.8X%8.8X, Width %d&bslash;n&quot;
comma
id|ACPI_FORMAT_UINT64
(paren
op_star
id|value
)paren
comma
id|obj_desc-&gt;common_field.access_byte_width
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_BFIELD
comma
l_string|&quot;Value Written %8.8X%8.8X, Width %d&bslash;n&quot;
comma
id|ACPI_FORMAT_UINT64
(paren
op_star
id|value
)paren
comma
id|obj_desc-&gt;common_field.access_byte_width
)paren
)paren
suffix:semicolon
)brace
)brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ex_write_with_update_rule&n; *&n; * PARAMETERS:  *obj_desc           - Field to be set&n; *              Value               - Value to store&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Apply the field update rule to a field write&n; *&n; ******************************************************************************/
id|acpi_status
DECL|function|acpi_ex_write_with_update_rule
id|acpi_ex_write_with_update_rule
(paren
r_union
id|acpi_operand_object
op_star
id|obj_desc
comma
id|acpi_integer
id|mask
comma
id|acpi_integer
id|field_value
comma
id|u32
id|field_datum_byte_offset
)paren
(brace
id|acpi_status
id|status
op_assign
id|AE_OK
suffix:semicolon
id|acpi_integer
id|merged_value
suffix:semicolon
id|acpi_integer
id|current_value
suffix:semicolon
id|ACPI_FUNCTION_TRACE_U32
(paren
l_string|&quot;ex_write_with_update_rule&quot;
comma
id|mask
)paren
suffix:semicolon
multiline_comment|/* Start with the new bits  */
id|merged_value
op_assign
id|field_value
suffix:semicolon
multiline_comment|/* If the mask is all ones, we don&squot;t need to worry about the update rule */
r_if
c_cond
(paren
id|mask
op_ne
id|ACPI_INTEGER_MAX
)paren
(brace
multiline_comment|/* Decode the update rule */
r_switch
c_cond
(paren
id|obj_desc-&gt;common_field.field_flags
op_amp
id|AML_FIELD_UPDATE_RULE_MASK
)paren
(brace
r_case
id|AML_FIELD_UPDATE_PRESERVE
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Check if update rule needs to be applied (not if mask is all&n;&t;&t;&t; * ones)  The left shift drops the bits we want to ignore.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
op_complement
id|mask
op_lshift
(paren
id|ACPI_MUL_8
(paren
r_sizeof
(paren
id|mask
)paren
)paren
op_minus
id|ACPI_MUL_8
(paren
id|obj_desc-&gt;common_field.access_byte_width
)paren
)paren
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Read the current contents of the byte/word/dword containing&n;&t;&t;&t;&t; * the field, and merge with the new field value.&n;&t;&t;&t;&t; */
id|status
op_assign
id|acpi_ex_field_datum_io
(paren
id|obj_desc
comma
id|field_datum_byte_offset
comma
op_amp
id|current_value
comma
id|ACPI_READ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
id|merged_value
op_or_assign
(paren
id|current_value
op_amp
op_complement
id|mask
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AML_FIELD_UPDATE_WRITE_AS_ONES
suffix:colon
multiline_comment|/* Set positions outside the field to all ones */
id|merged_value
op_or_assign
op_complement
id|mask
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AML_FIELD_UPDATE_WRITE_AS_ZEROS
suffix:colon
multiline_comment|/* Set positions outside the field to all zeros */
id|merged_value
op_and_assign
id|mask
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;write_with_update_rule: Unknown update_rule setting: %X&bslash;n&quot;
comma
(paren
id|obj_desc-&gt;common_field.field_flags
op_amp
id|AML_FIELD_UPDATE_RULE_MASK
)paren
)paren
)paren
suffix:semicolon
id|return_ACPI_STATUS
(paren
id|AE_AML_OPERAND_VALUE
)paren
suffix:semicolon
)brace
)brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_BFIELD
comma
l_string|&quot;Mask %8.8X%8.8X, datum_offset %X, Width %X, Value %8.8X%8.8X, merged_value %8.8X%8.8X&bslash;n&quot;
comma
id|ACPI_FORMAT_UINT64
(paren
id|mask
)paren
comma
id|field_datum_byte_offset
comma
id|obj_desc-&gt;common_field.access_byte_width
comma
id|ACPI_FORMAT_UINT64
(paren
id|field_value
)paren
comma
id|ACPI_FORMAT_UINT64
(paren
id|merged_value
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Write the merged value */
id|status
op_assign
id|acpi_ex_field_datum_io
(paren
id|obj_desc
comma
id|field_datum_byte_offset
comma
op_amp
id|merged_value
comma
id|ACPI_WRITE
)paren
suffix:semicolon
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ex_get_buffer_datum&n; *&n; * PARAMETERS:  Datum               - Where the Datum is returned&n; *              Buffer              - Raw field buffer&n; *              buffer_length       - Entire length (used for big-endian only)&n; *              byte_granularity    - 1/2/4/8 Granularity of the field&n; *                                    (aka Datum Size)&n; *              buffer_offset       - Datum offset into the buffer&n; *&n; * RETURN:      none&n; *&n; * DESCRIPTION: Get a datum from the buffer according to the buffer field&n; *              byte granularity&n; *&n; ******************************************************************************/
r_void
DECL|function|acpi_ex_get_buffer_datum
id|acpi_ex_get_buffer_datum
(paren
id|acpi_integer
op_star
id|datum
comma
r_void
op_star
id|buffer
comma
id|u32
id|buffer_length
comma
id|u32
id|byte_granularity
comma
id|u32
id|buffer_offset
)paren
(brace
id|u32
id|index
suffix:semicolon
id|ACPI_FUNCTION_TRACE_U32
(paren
l_string|&quot;ex_get_buffer_datum&quot;
comma
id|byte_granularity
)paren
suffix:semicolon
multiline_comment|/* Get proper index into buffer (handles big/little endian) */
id|index
op_assign
id|ACPI_BUFFER_INDEX
(paren
id|buffer_length
comma
id|buffer_offset
comma
id|byte_granularity
)paren
suffix:semicolon
multiline_comment|/* Move the requested number of bytes */
r_switch
c_cond
(paren
id|byte_granularity
)paren
(brace
r_case
id|ACPI_FIELD_BYTE_GRANULARITY
suffix:colon
op_star
id|datum
op_assign
(paren
(paren
id|u8
op_star
)paren
id|buffer
)paren
(braket
id|index
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACPI_FIELD_WORD_GRANULARITY
suffix:colon
id|ACPI_MOVE_16_TO_64
(paren
id|datum
comma
op_amp
(paren
(paren
(paren
id|u16
op_star
)paren
id|buffer
)paren
(braket
id|index
)braket
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACPI_FIELD_DWORD_GRANULARITY
suffix:colon
id|ACPI_MOVE_32_TO_64
(paren
id|datum
comma
op_amp
(paren
(paren
(paren
id|u32
op_star
)paren
id|buffer
)paren
(braket
id|index
)braket
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACPI_FIELD_QWORD_GRANULARITY
suffix:colon
id|ACPI_MOVE_64_TO_64
(paren
id|datum
comma
op_amp
(paren
(paren
(paren
id|u64
op_star
)paren
id|buffer
)paren
(braket
id|index
)braket
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Should not get here */
r_break
suffix:semicolon
)brace
id|return_VOID
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ex_set_buffer_datum&n; *&n; * PARAMETERS:  merged_datum        - Value to store&n; *              Buffer              - Receiving buffer&n; *              buffer_length       - Entire length (used for big-endian only)&n; *              byte_granularity    - 1/2/4/8 Granularity of the field&n; *                                    (aka Datum Size)&n; *              buffer_offset       - Datum offset into the buffer&n; *&n; * RETURN:      none&n; *&n; * DESCRIPTION: Store the merged datum to the buffer according to the&n; *              byte granularity&n; *&n; ******************************************************************************/
r_void
DECL|function|acpi_ex_set_buffer_datum
id|acpi_ex_set_buffer_datum
(paren
id|acpi_integer
id|merged_datum
comma
r_void
op_star
id|buffer
comma
id|u32
id|buffer_length
comma
id|u32
id|byte_granularity
comma
id|u32
id|buffer_offset
)paren
(brace
id|u32
id|index
suffix:semicolon
id|ACPI_FUNCTION_TRACE_U32
(paren
l_string|&quot;ex_set_buffer_datum&quot;
comma
id|byte_granularity
)paren
suffix:semicolon
multiline_comment|/* Get proper index into buffer (handles big/little endian) */
id|index
op_assign
id|ACPI_BUFFER_INDEX
(paren
id|buffer_length
comma
id|buffer_offset
comma
id|byte_granularity
)paren
suffix:semicolon
multiline_comment|/* Move the requested number of bytes */
r_switch
c_cond
(paren
id|byte_granularity
)paren
(brace
r_case
id|ACPI_FIELD_BYTE_GRANULARITY
suffix:colon
(paren
(paren
id|u8
op_star
)paren
id|buffer
)paren
(braket
id|index
)braket
op_assign
(paren
id|u8
)paren
id|merged_datum
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACPI_FIELD_WORD_GRANULARITY
suffix:colon
id|ACPI_MOVE_64_TO_16
(paren
op_amp
(paren
(paren
(paren
id|u16
op_star
)paren
id|buffer
)paren
(braket
id|index
)braket
)paren
comma
op_amp
id|merged_datum
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACPI_FIELD_DWORD_GRANULARITY
suffix:colon
id|ACPI_MOVE_64_TO_32
(paren
op_amp
(paren
(paren
(paren
id|u32
op_star
)paren
id|buffer
)paren
(braket
id|index
)braket
)paren
comma
op_amp
id|merged_datum
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACPI_FIELD_QWORD_GRANULARITY
suffix:colon
id|ACPI_MOVE_64_TO_64
(paren
op_amp
(paren
(paren
(paren
id|u64
op_star
)paren
id|buffer
)paren
(braket
id|index
)braket
)paren
comma
op_amp
id|merged_datum
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Should not get here */
r_break
suffix:semicolon
)brace
id|return_VOID
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ex_common_buffer_setup&n; *&n; * PARAMETERS:  obj_desc            - Field object&n; *              buffer_length       - Length of caller&squot;s buffer&n; *              datum_count         - Where the datum_count is returned&n; *&n; * RETURN:      Status, datum_count&n; *&n; * DESCRIPTION: Common code to validate the incoming buffer size and compute&n; *              the number of field &quot;datums&quot; that must be read or written.&n; *              A &quot;datum&quot; is the smallest unit that can be read or written&n; *              to the field, it is either 1,2,4, or 8 bytes.&n; *&n; ******************************************************************************/
id|acpi_status
DECL|function|acpi_ex_common_buffer_setup
id|acpi_ex_common_buffer_setup
(paren
r_union
id|acpi_operand_object
op_star
id|obj_desc
comma
id|u32
id|buffer_length
comma
id|u32
op_star
id|datum_count
)paren
(brace
id|u32
id|byte_field_length
suffix:semicolon
id|u32
id|actual_byte_field_length
suffix:semicolon
id|ACPI_FUNCTION_TRACE
(paren
l_string|&quot;ex_common_buffer_setup&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Incoming buffer must be at least as long as the field, we do not&n;&t; * allow &quot;partial&quot; field reads/writes.  We do not care if the buffer is&n;&t; * larger than the field, this typically happens when an integer is&n;&t; * read/written to a field that is actually smaller than an integer.&n;&t; */
id|byte_field_length
op_assign
id|ACPI_ROUND_BITS_UP_TO_BYTES
(paren
id|obj_desc-&gt;common_field.bit_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|byte_field_length
OG
id|buffer_length
)paren
(brace
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_BFIELD
comma
l_string|&quot;Field size %X (bytes) is too large for buffer (%X)&bslash;n&quot;
comma
id|byte_field_length
comma
id|buffer_length
)paren
)paren
suffix:semicolon
id|return_ACPI_STATUS
(paren
id|AE_BUFFER_OVERFLOW
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Create &quot;actual&quot; field byte count (minimum number of bytes that&n;&t; * must be read), then convert to datum count (minimum number&n;&t; * of datum-sized units that must be read)&n;&t; */
id|actual_byte_field_length
op_assign
id|ACPI_ROUND_BITS_UP_TO_BYTES
(paren
id|obj_desc-&gt;common_field.start_field_bit_offset
op_plus
id|obj_desc-&gt;common_field.bit_length
)paren
suffix:semicolon
op_star
id|datum_count
op_assign
id|ACPI_ROUND_UP_TO
(paren
id|actual_byte_field_length
comma
id|obj_desc-&gt;common_field.access_byte_width
)paren
suffix:semicolon
id|ACPI_DEBUG_PRINT
(paren
(paren
id|ACPI_DB_BFIELD
comma
l_string|&quot;buffer_bytes %X, actual_bytes %X, Datums %X, byte_gran %X&bslash;n&quot;
comma
id|byte_field_length
comma
id|actual_byte_field_length
comma
op_star
id|datum_count
comma
id|obj_desc-&gt;common_field.access_byte_width
)paren
)paren
suffix:semicolon
id|return_ACPI_STATUS
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ex_extract_from_field&n; *&n; * PARAMETERS:  obj_desc            - Field to be read&n; *              Buffer              - Where to store the field data&n; *              buffer_length       - Length of Buffer&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Retrieve the current value of the given field&n; *&n; ******************************************************************************/
id|acpi_status
DECL|function|acpi_ex_extract_from_field
id|acpi_ex_extract_from_field
(paren
r_union
id|acpi_operand_object
op_star
id|obj_desc
comma
r_void
op_star
id|buffer
comma
id|u32
id|buffer_length
)paren
(brace
id|acpi_status
id|status
suffix:semicolon
id|u32
id|field_datum_byte_offset
suffix:semicolon
id|u32
id|buffer_datum_offset
suffix:semicolon
id|acpi_integer
id|previous_raw_datum
op_assign
l_int|0
suffix:semicolon
id|acpi_integer
id|this_raw_datum
op_assign
l_int|0
suffix:semicolon
id|acpi_integer
id|merged_datum
op_assign
l_int|0
suffix:semicolon
id|u32
id|datum_count
suffix:semicolon
id|u32
id|i
suffix:semicolon
id|ACPI_FUNCTION_TRACE
(paren
l_string|&quot;ex_extract_from_field&quot;
)paren
suffix:semicolon
multiline_comment|/* Validate buffer, compute number of datums */
id|status
op_assign
id|acpi_ex_common_buffer_setup
(paren
id|obj_desc
comma
id|buffer_length
comma
op_amp
id|datum_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Clear the caller&squot;s buffer (the whole buffer length as given)&n;&t; * This is very important, especially in the cases where the buffer&n;&t; * is longer than the size of the field.&n;&t; */
id|ACPI_MEMSET
(paren
id|buffer
comma
l_int|0
comma
id|buffer_length
)paren
suffix:semicolon
id|field_datum_byte_offset
op_assign
l_int|0
suffix:semicolon
id|buffer_datum_offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Read the entire field */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|datum_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|status
op_assign
id|acpi_ex_field_datum_io
(paren
id|obj_desc
comma
id|field_datum_byte_offset
comma
op_amp
id|this_raw_datum
comma
id|ACPI_READ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/* We might actually be done if the request fits in one datum */
r_if
c_cond
(paren
(paren
id|datum_count
op_eq
l_int|1
)paren
op_logical_and
(paren
id|obj_desc-&gt;common_field.flags
op_amp
id|AOPOBJ_SINGLE_DATUM
)paren
)paren
(brace
multiline_comment|/* 1) Shift the valid data bits down to start at bit 0 */
id|merged_datum
op_assign
(paren
id|this_raw_datum
op_rshift
id|obj_desc-&gt;common_field.start_field_bit_offset
)paren
suffix:semicolon
multiline_comment|/* 2) Mask off any upper unused bits (bits not part of the field) */
r_if
c_cond
(paren
id|obj_desc-&gt;common_field.end_buffer_valid_bits
)paren
(brace
id|merged_datum
op_and_assign
id|ACPI_MASK_BITS_ABOVE
(paren
id|obj_desc-&gt;common_field.end_buffer_valid_bits
)paren
suffix:semicolon
)brace
multiline_comment|/* Store the datum to the caller buffer */
id|acpi_ex_set_buffer_datum
(paren
id|merged_datum
comma
id|buffer
comma
id|buffer_length
comma
id|obj_desc-&gt;common_field.access_byte_width
comma
id|buffer_datum_offset
)paren
suffix:semicolon
id|return_ACPI_STATUS
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* Special handling for the last datum to ignore extra bits */
r_if
c_cond
(paren
(paren
id|i
op_ge
(paren
id|datum_count
op_minus
l_int|1
)paren
)paren
op_logical_and
(paren
id|obj_desc-&gt;common_field.end_field_valid_bits
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * This is the last iteration of the loop.  We need to clear&n;&t;&t;&t; * any unused bits (bits that are not part of this field) before&n;&t;&t;&t; * we store the final merged datum into the caller buffer.&n;&t;&t;&t; */
id|this_raw_datum
op_and_assign
id|ACPI_MASK_BITS_ABOVE
(paren
id|obj_desc-&gt;common_field.end_field_valid_bits
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Create the (possibly) merged datum to be stored to the caller buffer&n;&t;&t; */
r_if
c_cond
(paren
id|obj_desc-&gt;common_field.start_field_bit_offset
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Field is not skewed and we can just copy the datum */
id|acpi_ex_set_buffer_datum
(paren
id|this_raw_datum
comma
id|buffer
comma
id|buffer_length
comma
id|obj_desc-&gt;common_field.access_byte_width
comma
id|buffer_datum_offset
)paren
suffix:semicolon
id|buffer_datum_offset
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Not aligned -- on the first iteration, just save the datum */
r_if
c_cond
(paren
id|i
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Put together the appropriate bits of the two raw data to make a&n;&t;&t;&t;&t; * single complete field datum&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * 1) Normalize the first datum down to bit 0&n;&t;&t;&t;&t; */
id|merged_datum
op_assign
(paren
id|previous_raw_datum
op_rshift
id|obj_desc-&gt;common_field.start_field_bit_offset
)paren
suffix:semicolon
multiline_comment|/* 2) Insert the second datum &quot;above&quot; the first datum */
id|merged_datum
op_or_assign
(paren
id|this_raw_datum
op_lshift
id|obj_desc-&gt;common_field.datum_valid_bits
)paren
suffix:semicolon
id|acpi_ex_set_buffer_datum
(paren
id|merged_datum
comma
id|buffer
comma
id|buffer_length
comma
id|obj_desc-&gt;common_field.access_byte_width
comma
id|buffer_datum_offset
)paren
suffix:semicolon
id|buffer_datum_offset
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Save the raw datum that was just acquired since it may contain bits&n;&t;&t;&t; * of the *next* field datum&n;&t;&t;&t; */
id|previous_raw_datum
op_assign
id|this_raw_datum
suffix:semicolon
)brace
id|field_datum_byte_offset
op_add_assign
id|obj_desc-&gt;common_field.access_byte_width
suffix:semicolon
)brace
multiline_comment|/* For non-aligned case, there is one last datum to insert */
r_if
c_cond
(paren
id|obj_desc-&gt;common_field.start_field_bit_offset
op_ne
l_int|0
)paren
(brace
id|merged_datum
op_assign
(paren
id|this_raw_datum
op_rshift
id|obj_desc-&gt;common_field.start_field_bit_offset
)paren
suffix:semicolon
id|acpi_ex_set_buffer_datum
(paren
id|merged_datum
comma
id|buffer
comma
id|buffer_length
comma
id|obj_desc-&gt;common_field.access_byte_width
comma
id|buffer_datum_offset
)paren
suffix:semicolon
)brace
id|return_ACPI_STATUS
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    acpi_ex_insert_into_field&n; *&n; * PARAMETERS:  obj_desc            - Field to be written&n; *              Buffer              - Data to be written&n; *              buffer_length       - Length of Buffer&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Store the Buffer contents into the given field&n; *&n; ******************************************************************************/
id|acpi_status
DECL|function|acpi_ex_insert_into_field
id|acpi_ex_insert_into_field
(paren
r_union
id|acpi_operand_object
op_star
id|obj_desc
comma
r_void
op_star
id|buffer
comma
id|u32
id|buffer_length
)paren
(brace
id|acpi_status
id|status
suffix:semicolon
id|u32
id|field_datum_byte_offset
suffix:semicolon
id|u32
id|datum_offset
suffix:semicolon
id|acpi_integer
id|mask
suffix:semicolon
id|acpi_integer
id|merged_datum
suffix:semicolon
id|acpi_integer
id|previous_raw_datum
suffix:semicolon
id|acpi_integer
id|this_raw_datum
suffix:semicolon
id|u32
id|datum_count
suffix:semicolon
id|ACPI_FUNCTION_TRACE
(paren
l_string|&quot;ex_insert_into_field&quot;
)paren
suffix:semicolon
multiline_comment|/* Validate buffer, compute number of datums */
id|status
op_assign
id|acpi_ex_common_buffer_setup
(paren
id|obj_desc
comma
id|buffer_length
comma
op_amp
id|datum_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Break the request into up to three parts (similar to an I/O request):&n;&t; * 1) non-aligned part at start&n;&t; * 2) aligned part in middle&n;&t; * 3) non-aligned part at the end&n;&t; */
id|field_datum_byte_offset
op_assign
l_int|0
suffix:semicolon
id|datum_offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Get a single datum from the caller&squot;s buffer */
id|acpi_ex_get_buffer_datum
(paren
op_amp
id|previous_raw_datum
comma
id|buffer
comma
id|buffer_length
comma
id|obj_desc-&gt;common_field.access_byte_width
comma
id|datum_offset
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Part1:&n;&t; * Write a partial field datum if field does not begin on a datum boundary&n;&t; * Note: The code in this section also handles the aligned case&n;&t; *&n;&t; * Construct Mask with 1 bits where the field is, 0 bits elsewhere&n;&t; * (Only the bottom 5 bits of bit_length are valid for a shift operation)&n;&t; *&n;&t; * Mask off bits that are &quot;below&quot; the field (if any)&n;&t; */
id|mask
op_assign
id|ACPI_MASK_BITS_BELOW
(paren
id|obj_desc-&gt;common_field.start_field_bit_offset
)paren
suffix:semicolon
multiline_comment|/* If the field fits in one datum, may need to mask upper bits */
r_if
c_cond
(paren
(paren
id|obj_desc-&gt;common_field.flags
op_amp
id|AOPOBJ_SINGLE_DATUM
)paren
op_logical_and
id|obj_desc-&gt;common_field.end_field_valid_bits
)paren
(brace
multiline_comment|/* There are bits above the field, mask them off also */
id|mask
op_and_assign
id|ACPI_MASK_BITS_ABOVE
(paren
id|obj_desc-&gt;common_field.end_field_valid_bits
)paren
suffix:semicolon
)brace
multiline_comment|/* Shift and mask the value into the field position */
id|merged_datum
op_assign
(paren
id|previous_raw_datum
op_lshift
id|obj_desc-&gt;common_field.start_field_bit_offset
)paren
suffix:semicolon
id|merged_datum
op_and_assign
id|mask
suffix:semicolon
multiline_comment|/* Apply the update rule (if necessary) and write the datum to the field */
id|status
op_assign
id|acpi_ex_write_with_update_rule
(paren
id|obj_desc
comma
id|mask
comma
id|merged_datum
comma
id|field_datum_byte_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/* We just wrote the first datum */
id|datum_offset
op_increment
suffix:semicolon
multiline_comment|/* If the entire field fits within one datum, we are done. */
r_if
c_cond
(paren
(paren
id|datum_count
op_eq
l_int|1
)paren
op_logical_and
(paren
id|obj_desc-&gt;common_field.flags
op_amp
id|AOPOBJ_SINGLE_DATUM
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Part2:&n;&t; * Write the aligned data.&n;&t; *&n;&t; * We don&squot;t need to worry about the update rule for these data, because&n;&t; * all of the bits in each datum are part of the field.&n;&t; *&n;&t; * The last datum must be special cased because it might contain bits&n;&t; * that are not part of the field -- therefore the &quot;update rule&quot; must be&n;&t; * applied in Part3 below.&n;&t; */
r_while
c_loop
(paren
id|datum_offset
OL
id|datum_count
)paren
(brace
id|field_datum_byte_offset
op_add_assign
id|obj_desc-&gt;common_field.access_byte_width
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Get the next raw buffer datum.  It may contain bits of the previous&n;&t;&t; * field datum&n;&t;&t; */
id|acpi_ex_get_buffer_datum
(paren
op_amp
id|this_raw_datum
comma
id|buffer
comma
id|buffer_length
comma
id|obj_desc-&gt;common_field.access_byte_width
comma
id|datum_offset
)paren
suffix:semicolon
multiline_comment|/* Create the field datum based on the field alignment */
r_if
c_cond
(paren
id|obj_desc-&gt;common_field.start_field_bit_offset
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Put together appropriate bits of the two raw buffer data to make&n;&t;&t;&t; * a single complete field datum&n;&t;&t;&t; */
id|merged_datum
op_assign
(paren
id|previous_raw_datum
op_rshift
id|obj_desc-&gt;common_field.datum_valid_bits
)paren
op_or
(paren
id|this_raw_datum
op_lshift
id|obj_desc-&gt;common_field.start_field_bit_offset
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Field began aligned on datum boundary */
id|merged_datum
op_assign
id|this_raw_datum
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Special handling for the last datum if the field does NOT end on&n;&t;&t; * a datum boundary.  Update Rule must be applied to the bits outside&n;&t;&t; * the field.&n;&t;&t; */
id|datum_offset
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|datum_offset
op_eq
id|datum_count
)paren
op_logical_and
(paren
id|obj_desc-&gt;common_field.end_field_valid_bits
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If there are dangling non-aligned bits, perform one more merged write&n;&t;&t;&t; * Else - field is aligned at the end, no need for any more writes&n;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t; * Part3:&n;&t;&t;&t; * This is the last datum and the field does not end on a datum boundary.&n;&t;&t;&t; * Build the partial datum and write with the update rule.&n;&t;&t;&t; *&n;&t;&t;&t; * Mask off the unused bits above (after) the end-of-field&n;&t;&t;&t; */
id|mask
op_assign
id|ACPI_MASK_BITS_ABOVE
(paren
id|obj_desc-&gt;common_field.end_field_valid_bits
)paren
suffix:semicolon
id|merged_datum
op_and_assign
id|mask
suffix:semicolon
multiline_comment|/* Write the last datum with the update rule */
id|status
op_assign
id|acpi_ex_write_with_update_rule
(paren
id|obj_desc
comma
id|mask
comma
id|merged_datum
comma
id|field_datum_byte_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Normal (aligned) case -- write the completed datum */
id|status
op_assign
id|acpi_ex_field_datum_io
(paren
id|obj_desc
comma
id|field_datum_byte_offset
comma
op_amp
id|merged_datum
comma
id|ACPI_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Save the most recent datum since it may contain bits of the *next*&n;&t;&t; * field datum.  Update current byte offset.&n;&t;&t; */
id|previous_raw_datum
op_assign
id|this_raw_datum
suffix:semicolon
)brace
id|return_ACPI_STATUS
(paren
id|status
)paren
suffix:semicolon
)brace
eof
