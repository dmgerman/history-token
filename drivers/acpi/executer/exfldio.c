multiline_comment|/******************************************************************************&n; *&n; * Module Name: exfldio - Aml Field I/O&n; *              $Revision: 57 $&n; *&n; *****************************************************************************/
multiline_comment|/*&n; *  Copyright (C) 2000, 2001 R. Byron Moore&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &quot;acpi.h&quot;
macro_line|#include &quot;acinterp.h&quot;
macro_line|#include &quot;amlcode.h&quot;
macro_line|#include &quot;acnamesp.h&quot;
macro_line|#include &quot;achware.h&quot;
macro_line|#include &quot;acevents.h&quot;
macro_line|#include &quot;acdispat.h&quot;
DECL|macro|_COMPONENT
mdefine_line|#define _COMPONENT          ACPI_EXECUTER
id|MODULE_NAME
(paren
l_string|&quot;exfldio&quot;
)paren
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ex_setup_field&n; *&n; * PARAMETERS:  *Obj_desc           - Field to be read or written&n; *              Field_datum_byte_offset  - Current offset into the field&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Common processing for Acpi_ex_extract_from_field and&n; *              Acpi_ex_insert_into_field&n; *&n; ******************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ex_setup_field
id|acpi_ex_setup_field
(paren
id|ACPI_OPERAND_OBJECT
op_star
id|obj_desc
comma
id|u32
id|field_datum_byte_offset
)paren
(brace
id|ACPI_STATUS
id|status
op_assign
id|AE_OK
suffix:semicolon
id|ACPI_OPERAND_OBJECT
op_star
id|rgn_desc
suffix:semicolon
multiline_comment|/* Parameter validation */
id|rgn_desc
op_assign
id|obj_desc-&gt;common_field.region_obj
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|obj_desc
op_logical_or
op_logical_neg
id|rgn_desc
)paren
(brace
r_return
(paren
id|AE_AML_NO_OPERAND
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ACPI_TYPE_REGION
op_ne
id|rgn_desc-&gt;common.type
)paren
(brace
r_return
(paren
id|AE_AML_OPERAND_TYPE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the Region Address and Length have not been previously evaluated,&n;&t; * evaluate them now and save the results.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|rgn_desc-&gt;region.flags
op_amp
id|AOPOBJ_DATA_VALID
)paren
)paren
(brace
id|status
op_assign
id|acpi_ds_get_region_arguments
(paren
id|rgn_desc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Validate the request.  The entire request from the byte offset for a&n;&t; * length of one field datum (access width) must fit within the region.&n;&t; * (Region length is specified in bytes)&n;&t; */
r_if
c_cond
(paren
id|rgn_desc-&gt;region.length
OL
(paren
id|obj_desc-&gt;common_field.base_byte_offset
op_plus
id|field_datum_byte_offset
op_plus
id|obj_desc-&gt;common_field.access_byte_width
)paren
)paren
(brace
r_if
c_cond
(paren
id|rgn_desc-&gt;region.length
OL
id|obj_desc-&gt;common_field.access_byte_width
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * This is the case where the Access_type (Acc_word, etc.) is wider&n;&t;&t;&t; * than the region itself.  For example, a region of length one&n;&t;&t;&t; * byte, and a field with Dword access specified.&n;&t;&t;&t; */
)brace
multiline_comment|/*&n;&t;&t; * Offset rounded up to next multiple of field width&n;&t;&t; * exceeds region length, indicate an error&n;&t;&t; */
r_return
(paren
id|AE_AML_REGION_LIMIT
)paren
suffix:semicolon
)brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ex_read_field_datum&n; *&n; * PARAMETERS:  *Obj_desc           - Field to be read&n; *              *Value              - Where to store value (must be 32 bits)&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Retrieve the value of the given field&n; *&n; ******************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ex_read_field_datum
id|acpi_ex_read_field_datum
(paren
id|ACPI_OPERAND_OBJECT
op_star
id|obj_desc
comma
id|u32
id|field_datum_byte_offset
comma
id|u32
op_star
id|value
)paren
(brace
id|ACPI_STATUS
id|status
suffix:semicolon
id|ACPI_OPERAND_OBJECT
op_star
id|rgn_desc
suffix:semicolon
id|ACPI_PHYSICAL_ADDRESS
id|address
suffix:semicolon
id|u32
id|local_value
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
(brace
id|local_value
op_assign
l_int|0
suffix:semicolon
id|value
op_assign
op_amp
id|local_value
suffix:semicolon
multiline_comment|/*  support reads without saving value  */
)brace
multiline_comment|/* Clear the entire return buffer first, [Very Important!] */
op_star
id|value
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Buffer_fields - Read from a Buffer&n;&t; * Other Fields - Read from a Operation Region.&n;&t; */
r_switch
c_cond
(paren
id|obj_desc-&gt;common.type
)paren
(brace
r_case
id|ACPI_TYPE_BUFFER_FIELD
suffix:colon
multiline_comment|/*&n;&t;&t; * For Buffer_fields, we only need to copy the data from the&n;&t;&t; * source buffer.  Length is the field width in bytes.&n;&t;&t; */
id|MEMCPY
(paren
id|value
comma
(paren
id|obj_desc-&gt;buffer_field.buffer_obj
)paren
op_member_access_from_pointer
id|buffer.pointer
op_plus
id|obj_desc-&gt;buffer_field.base_byte_offset
op_plus
id|field_datum_byte_offset
comma
id|obj_desc-&gt;common_field.access_byte_width
)paren
suffix:semicolon
id|status
op_assign
id|AE_OK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|INTERNAL_TYPE_REGION_FIELD
suffix:colon
r_case
id|INTERNAL_TYPE_BANK_FIELD
suffix:colon
multiline_comment|/*&n;&t;&t; * For other fields, we need to go through an Operation Region&n;&t;&t; * (Only types that will get here are Region_fields and Bank_fields)&n;&t;&t; */
id|status
op_assign
id|acpi_ex_setup_field
(paren
id|obj_desc
comma
id|field_datum_byte_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * The physical address of this field datum is:&n;&t;&t; *&n;&t;&t; * 1) The base of the region, plus&n;&t;&t; * 2) The base offset of the field, plus&n;&t;&t; * 3) The current offset into the field&n;&t;&t; */
id|rgn_desc
op_assign
id|obj_desc-&gt;common_field.region_obj
suffix:semicolon
id|address
op_assign
id|rgn_desc-&gt;region.address
op_plus
id|obj_desc-&gt;common_field.base_byte_offset
op_plus
id|field_datum_byte_offset
suffix:semicolon
multiline_comment|/* Invoke the appropriate Address_space/Op_region handler */
id|status
op_assign
id|acpi_ev_address_space_dispatch
(paren
id|rgn_desc
comma
id|ACPI_READ_ADR_SPACE
comma
id|address
comma
id|obj_desc-&gt;common_field.access_bit_width
comma
id|value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|status
op_assign
id|AE_AML_INTERNAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ex_get_buffer_datum&n; *&n; * PARAMETERS:  Merged_datum        - Value to store&n; *              Buffer              - Receiving buffer&n; *              Byte_granularity    - 1/2/4 Granularity of the field&n; *                                    (aka Datum Size)&n; *              Offset              - Datum offset into the buffer&n; *&n; * RETURN:      none&n; *&n; * DESCRIPTION: Store the merged datum to the buffer according to the&n; *              byte granularity&n; *&n; ******************************************************************************/
r_static
r_void
DECL|function|acpi_ex_get_buffer_datum
id|acpi_ex_get_buffer_datum
c_func
(paren
id|u32
op_star
id|datum
comma
r_void
op_star
id|buffer
comma
id|u32
id|byte_granularity
comma
id|u32
id|offset
)paren
(brace
r_switch
c_cond
(paren
id|byte_granularity
)paren
(brace
r_case
id|ACPI_FIELD_BYTE_GRANULARITY
suffix:colon
op_star
id|datum
op_assign
(paren
(paren
id|u8
op_star
)paren
id|buffer
)paren
(braket
id|offset
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACPI_FIELD_WORD_GRANULARITY
suffix:colon
id|MOVE_UNALIGNED16_TO_32
(paren
id|datum
comma
op_amp
(paren
(paren
(paren
id|u16
op_star
)paren
id|buffer
)paren
(braket
id|offset
)braket
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACPI_FIELD_DWORD_GRANULARITY
suffix:colon
id|MOVE_UNALIGNED32_TO_32
(paren
id|datum
comma
op_amp
(paren
(paren
(paren
id|u32
op_star
)paren
id|buffer
)paren
(braket
id|offset
)braket
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ex_set_buffer_datum&n; *&n; * PARAMETERS:  Merged_datum        - Value to store&n; *              Buffer              - Receiving buffer&n; *              Byte_granularity    - 1/2/4 Granularity of the field&n; *                                    (aka Datum Size)&n; *              Offset              - Datum offset into the buffer&n; *&n; * RETURN:      none&n; *&n; * DESCRIPTION: Store the merged datum to the buffer according to the&n; *              byte granularity&n; *&n; ******************************************************************************/
r_static
r_void
DECL|function|acpi_ex_set_buffer_datum
id|acpi_ex_set_buffer_datum
(paren
id|u32
id|merged_datum
comma
r_void
op_star
id|buffer
comma
id|u32
id|byte_granularity
comma
id|u32
id|offset
)paren
(brace
r_switch
c_cond
(paren
id|byte_granularity
)paren
(brace
r_case
id|ACPI_FIELD_BYTE_GRANULARITY
suffix:colon
(paren
(paren
id|u8
op_star
)paren
id|buffer
)paren
(braket
id|offset
)braket
op_assign
(paren
id|u8
)paren
id|merged_datum
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACPI_FIELD_WORD_GRANULARITY
suffix:colon
id|MOVE_UNALIGNED16_TO_16
(paren
op_amp
(paren
(paren
(paren
id|u16
op_star
)paren
id|buffer
)paren
(braket
id|offset
)braket
)paren
comma
op_amp
id|merged_datum
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACPI_FIELD_DWORD_GRANULARITY
suffix:colon
id|MOVE_UNALIGNED32_TO_32
(paren
op_amp
(paren
(paren
(paren
id|u32
op_star
)paren
id|buffer
)paren
(braket
id|offset
)braket
)paren
comma
op_amp
id|merged_datum
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ex_extract_from_field&n; *&n; * PARAMETERS:  *Obj_desc           - Field to be read&n; *              *Value              - Where to store value&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Retrieve the value of the given field&n; *&n; ******************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ex_extract_from_field
id|acpi_ex_extract_from_field
(paren
id|ACPI_OPERAND_OBJECT
op_star
id|obj_desc
comma
r_void
op_star
id|buffer
comma
id|u32
id|buffer_length
)paren
(brace
id|ACPI_STATUS
id|status
suffix:semicolon
id|u32
id|field_datum_byte_offset
suffix:semicolon
id|u32
id|datum_offset
suffix:semicolon
id|u32
id|previous_raw_datum
suffix:semicolon
id|u32
id|this_raw_datum
op_assign
l_int|0
suffix:semicolon
id|u32
id|merged_datum
op_assign
l_int|0
suffix:semicolon
id|u32
id|byte_field_length
suffix:semicolon
id|u32
id|datum_count
suffix:semicolon
multiline_comment|/*&n;&t; * The field must fit within the caller&squot;s buffer&n;&t; */
id|byte_field_length
op_assign
id|ROUND_BITS_UP_TO_BYTES
(paren
id|obj_desc-&gt;common_field.bit_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|byte_field_length
OG
id|buffer_length
)paren
(brace
r_return
(paren
id|AE_BUFFER_OVERFLOW
)paren
suffix:semicolon
)brace
multiline_comment|/* Convert field byte count to datum count, round up if necessary */
id|datum_count
op_assign
id|ROUND_UP_TO
(paren
id|byte_field_length
comma
id|obj_desc-&gt;common_field.access_byte_width
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Clear the caller&squot;s buffer (the whole buffer length as given)&n;&t; * This is very important, especially in the cases where a byte is read,&n;&t; * but the buffer is really a u32 (4 bytes).&n;&t; */
id|MEMSET
(paren
id|buffer
comma
l_int|0
comma
id|buffer_length
)paren
suffix:semicolon
multiline_comment|/* Read the first raw datum to prime the loop */
id|field_datum_byte_offset
op_assign
l_int|0
suffix:semicolon
id|datum_offset
op_assign
l_int|0
suffix:semicolon
id|status
op_assign
id|acpi_ex_read_field_datum
(paren
id|obj_desc
comma
id|field_datum_byte_offset
comma
op_amp
id|previous_raw_datum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/* We might actually be done if the request fits in one datum */
r_if
c_cond
(paren
(paren
id|datum_count
op_eq
l_int|1
)paren
op_logical_and
(paren
id|obj_desc-&gt;common_field.access_flags
op_amp
id|AFIELD_SINGLE_DATUM
)paren
)paren
(brace
multiline_comment|/* 1) Shift the valid data bits down to start at bit 0 */
id|merged_datum
op_assign
(paren
id|previous_raw_datum
op_rshift
id|obj_desc-&gt;common_field.start_field_bit_offset
)paren
suffix:semicolon
multiline_comment|/* 2) Mask off any upper unused bits (bits not part of the field) */
r_if
c_cond
(paren
id|obj_desc-&gt;common_field.end_buffer_valid_bits
)paren
(brace
id|merged_datum
op_and_assign
id|MASK_BITS_ABOVE
(paren
id|obj_desc-&gt;common_field.end_buffer_valid_bits
)paren
suffix:semicolon
)brace
multiline_comment|/* Store the datum to the caller buffer */
id|acpi_ex_set_buffer_datum
(paren
id|merged_datum
comma
id|buffer
comma
id|obj_desc-&gt;common_field.access_byte_width
comma
id|datum_offset
)paren
suffix:semicolon
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* We need to get more raw data to complete one or more field data */
r_while
c_loop
(paren
id|datum_offset
OL
id|datum_count
)paren
(brace
id|field_datum_byte_offset
op_add_assign
id|obj_desc-&gt;common_field.access_byte_width
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the field is aligned on a byte boundary, we don&squot;t want&n;&t;&t; * to perform a final read, since this would potentially read&n;&t;&t; * past the end of the region.&n;&t;&t; *&n;&t;&t; * TBD: [Investigate] It may make more sense to just split the aligned&n;&t;&t; * and non-aligned cases since the aligned case is so very simple,&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|obj_desc-&gt;common_field.start_field_bit_offset
op_ne
l_int|0
)paren
op_logical_or
(paren
(paren
id|obj_desc-&gt;common_field.start_field_bit_offset
op_eq
l_int|0
)paren
op_logical_and
(paren
id|datum_offset
OL
(paren
id|datum_count
op_minus
l_int|1
)paren
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Get the next raw datum, it contains some or all bits&n;&t;&t;&t; * of the current field datum&n;&t;&t;&t; */
id|status
op_assign
id|acpi_ex_read_field_datum
(paren
id|obj_desc
comma
id|field_datum_byte_offset
comma
op_amp
id|this_raw_datum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Create the (possibly) merged datum to be stored to the caller buffer&n;&t;&t; */
r_if
c_cond
(paren
id|obj_desc-&gt;common_field.start_field_bit_offset
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Field is not skewed and we can just copy the datum */
id|merged_datum
op_assign
id|previous_raw_datum
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Put together the appropriate bits of the two raw data to make a&n;&t;&t;&t; * single complete field datum&n;&t;&t;&t; *&n;&t;&t;&t; * 1) Normalize the first datum down to bit 0&n;&t;&t;&t; */
id|merged_datum
op_assign
(paren
id|previous_raw_datum
op_rshift
id|obj_desc-&gt;common_field.start_field_bit_offset
)paren
suffix:semicolon
multiline_comment|/* 2) Insert the second datum &quot;above&quot; the first datum */
id|merged_datum
op_or_assign
(paren
id|this_raw_datum
op_lshift
id|obj_desc-&gt;common_field.datum_valid_bits
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|datum_offset
op_ge
(paren
id|datum_count
op_minus
l_int|1
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * This is the last iteration of the loop.  We need to clear&n;&t;&t;&t;&t; * any unused bits (bits that are not part of this field) that&n;&t;&t;&t;&t; * came from the last raw datum before we store the final&n;&t;&t;&t;&t; * merged datum into the caller buffer.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|obj_desc-&gt;common_field.end_buffer_valid_bits
)paren
(brace
id|merged_datum
op_and_assign
id|MASK_BITS_ABOVE
(paren
id|obj_desc-&gt;common_field.end_buffer_valid_bits
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t; * Store the merged field datum in the caller&squot;s buffer, according to&n;&t;&t; * the granularity of the field (size of each datum).&n;&t;&t; */
id|acpi_ex_set_buffer_datum
(paren
id|merged_datum
comma
id|buffer
comma
id|obj_desc-&gt;common_field.access_byte_width
comma
id|datum_offset
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Save the raw datum that was just acquired since it may contain bits&n;&t;&t; * of the *next* field datum.  Update offsets&n;&t;&t; */
id|previous_raw_datum
op_assign
id|this_raw_datum
suffix:semicolon
id|datum_offset
op_increment
suffix:semicolon
)brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ex_write_field_datum&n; *&n; * PARAMETERS:  *Obj_desc           - Field to be set&n; *              Value               - Value to store&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Store the value into the given field&n; *&n; ******************************************************************************/
r_static
id|ACPI_STATUS
DECL|function|acpi_ex_write_field_datum
id|acpi_ex_write_field_datum
(paren
id|ACPI_OPERAND_OBJECT
op_star
id|obj_desc
comma
id|u32
id|field_datum_byte_offset
comma
id|u32
id|value
)paren
(brace
id|ACPI_STATUS
id|status
op_assign
id|AE_OK
suffix:semicolon
id|ACPI_OPERAND_OBJECT
op_star
id|rgn_desc
op_assign
l_int|NULL
suffix:semicolon
id|ACPI_PHYSICAL_ADDRESS
id|address
suffix:semicolon
multiline_comment|/*&n;&t; * Buffer_fields - Read from a Buffer&n;&t; * Other Fields - Read from a Operation Region.&n;&t; */
r_switch
c_cond
(paren
id|obj_desc-&gt;common.type
)paren
(brace
r_case
id|ACPI_TYPE_BUFFER_FIELD
suffix:colon
multiline_comment|/*&n;&t;&t; * For Buffer_fields, we only need to copy the data to the&n;&t;&t; * target buffer.  Length is the field width in bytes.&n;&t;&t; */
id|MEMCPY
(paren
(paren
id|obj_desc-&gt;buffer_field.buffer_obj
)paren
op_member_access_from_pointer
id|buffer.pointer
op_plus
id|obj_desc-&gt;buffer_field.base_byte_offset
op_plus
id|field_datum_byte_offset
comma
op_amp
id|value
comma
id|obj_desc-&gt;common_field.access_byte_width
)paren
suffix:semicolon
id|status
op_assign
id|AE_OK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|INTERNAL_TYPE_REGION_FIELD
suffix:colon
r_case
id|INTERNAL_TYPE_BANK_FIELD
suffix:colon
multiline_comment|/*&n;&t;&t; * For other fields, we need to go through an Operation Region&n;&t;&t; * (Only types that will get here are Region_fields and Bank_fields)&n;&t;&t; */
id|status
op_assign
id|acpi_ex_setup_field
(paren
id|obj_desc
comma
id|field_datum_byte_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * The physical address of this field datum is:&n;&t;&t; *&n;&t;&t; * 1) The base of the region, plus&n;&t;&t; * 2) The base offset of the field, plus&n;&t;&t; * 3) The current offset into the field&n;&t;&t; */
id|rgn_desc
op_assign
id|obj_desc-&gt;common_field.region_obj
suffix:semicolon
id|address
op_assign
id|rgn_desc-&gt;region.address
op_plus
id|obj_desc-&gt;common_field.base_byte_offset
op_plus
id|field_datum_byte_offset
suffix:semicolon
multiline_comment|/* Invoke the appropriate Address_space/Op_region handler */
id|status
op_assign
id|acpi_ev_address_space_dispatch
(paren
id|rgn_desc
comma
id|ACPI_WRITE_ADR_SPACE
comma
id|address
comma
id|obj_desc-&gt;common_field.access_bit_width
comma
op_amp
id|value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|status
op_assign
id|AE_AML_INTERNAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ex_write_field_datum_with_update_rule&n; *&n; * PARAMETERS:  *Obj_desc           - Field to be set&n; *              Value               - Value to store&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Apply the field update rule to a field write&n; *&n; ******************************************************************************/
r_static
id|ACPI_STATUS
DECL|function|acpi_ex_write_field_datum_with_update_rule
id|acpi_ex_write_field_datum_with_update_rule
(paren
id|ACPI_OPERAND_OBJECT
op_star
id|obj_desc
comma
id|u32
id|mask
comma
id|u32
id|field_value
comma
id|u32
id|field_datum_byte_offset
)paren
(brace
id|ACPI_STATUS
id|status
op_assign
id|AE_OK
suffix:semicolon
id|u32
id|merged_value
suffix:semicolon
id|u32
id|current_value
suffix:semicolon
multiline_comment|/* Start with the new bits  */
id|merged_value
op_assign
id|field_value
suffix:semicolon
multiline_comment|/* If the mask is all ones, we don&squot;t need to worry about the update rule */
r_if
c_cond
(paren
id|mask
op_ne
id|ACPI_UINT32_MAX
)paren
(brace
multiline_comment|/* Decode the update rule */
r_switch
c_cond
(paren
id|obj_desc-&gt;common_field.update_rule
)paren
(brace
r_case
id|UPDATE_PRESERVE
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Check if update rule needs to be applied (not if mask is all&n;&t;&t;&t; * ones)  The left shift drops the bits we want to ignore.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
op_complement
id|mask
op_lshift
(paren
r_sizeof
(paren
id|mask
)paren
op_star
l_int|8
op_minus
id|obj_desc-&gt;common_field.access_bit_width
)paren
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Read the current contents of the byte/word/dword containing&n;&t;&t;&t;&t; * the field, and merge with the new field value.&n;&t;&t;&t;&t; */
id|status
op_assign
id|acpi_ex_read_field_datum
(paren
id|obj_desc
comma
id|field_datum_byte_offset
comma
op_amp
id|current_value
)paren
suffix:semicolon
id|merged_value
op_or_assign
(paren
id|current_value
op_amp
op_complement
id|mask
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|UPDATE_WRITE_AS_ONES
suffix:colon
multiline_comment|/* Set positions outside the field to all ones */
id|merged_value
op_or_assign
op_complement
id|mask
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UPDATE_WRITE_AS_ZEROS
suffix:colon
multiline_comment|/* Set positions outside the field to all zeros */
id|merged_value
op_and_assign
id|mask
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
(paren
id|AE_AML_OPERAND_VALUE
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Write the merged value */
id|status
op_assign
id|acpi_ex_write_field_datum
(paren
id|obj_desc
comma
id|field_datum_byte_offset
comma
id|merged_value
)paren
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ex_insert_into_field&n; *&n; * PARAMETERS:  *Obj_desc           - Field to be set&n; *              Buffer              - Value to store&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Store the value into the given field&n; *&n; ******************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ex_insert_into_field
id|acpi_ex_insert_into_field
(paren
id|ACPI_OPERAND_OBJECT
op_star
id|obj_desc
comma
r_void
op_star
id|buffer
comma
id|u32
id|buffer_length
)paren
(brace
id|ACPI_STATUS
id|status
suffix:semicolon
id|u32
id|field_datum_byte_offset
suffix:semicolon
id|u32
id|datum_offset
suffix:semicolon
id|u32
id|mask
suffix:semicolon
id|u32
id|merged_datum
suffix:semicolon
id|u32
id|previous_raw_datum
suffix:semicolon
id|u32
id|this_raw_datum
suffix:semicolon
id|u32
id|byte_field_length
suffix:semicolon
id|u32
id|datum_count
suffix:semicolon
multiline_comment|/*&n;&t; * Incoming buffer must be at least as long as the field, we do not&n;&t; * allow &quot;partial&quot; field writes.  We do not care if the buffer is&n;&t; * larger than the field, this typically happens when an integer is&n;&t; * written to a field that is actually smaller than an integer.&n;&t; */
id|byte_field_length
op_assign
id|ROUND_BITS_UP_TO_BYTES
(paren
id|obj_desc-&gt;common_field.bit_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_length
OL
id|byte_field_length
)paren
(brace
multiline_comment|/* TBD: Need a better error code */
r_return
(paren
id|AE_BUFFER_OVERFLOW
)paren
suffix:semicolon
)brace
multiline_comment|/* Convert byte count to datum count, round up if necessary */
id|datum_count
op_assign
id|ROUND_UP_TO
(paren
id|byte_field_length
comma
id|obj_desc-&gt;common_field.access_byte_width
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Break the request into up to three parts (similar to an I/O request):&n;&t; * 1) non-aligned part at start&n;&t; * 2) aligned part in middle&n;&t; * 3) non-aligned part at the end&n;&t; */
id|field_datum_byte_offset
op_assign
l_int|0
suffix:semicolon
id|datum_offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Get a single datum from the caller&squot;s buffer */
id|acpi_ex_get_buffer_datum
(paren
op_amp
id|previous_raw_datum
comma
id|buffer
comma
id|obj_desc-&gt;common_field.access_byte_width
comma
id|datum_offset
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Part1:&n;&t; * Write a partial field datum if field does not begin on a datum boundary&n;&t; * Note: The code in this section also handles the aligned case&n;&t; *&n;&t; * Construct Mask with 1 bits where the field is, 0 bits elsewhere&n;&t; * (Only the bottom 5 bits of Bit_length are valid for a shift operation)&n;&t; *&n;&t; * Mask off bits that are &quot;below&quot; the field (if any)&n;&t; */
id|mask
op_assign
id|MASK_BITS_BELOW
(paren
id|obj_desc-&gt;common_field.start_field_bit_offset
)paren
suffix:semicolon
multiline_comment|/* If the field fits in one datum, may need to mask upper bits */
r_if
c_cond
(paren
(paren
id|obj_desc-&gt;common_field.access_flags
op_amp
id|AFIELD_SINGLE_DATUM
)paren
op_logical_and
id|obj_desc-&gt;common_field.end_field_valid_bits
)paren
(brace
multiline_comment|/* There are bits above the field, mask them off also */
id|mask
op_and_assign
id|MASK_BITS_ABOVE
(paren
id|obj_desc-&gt;common_field.end_field_valid_bits
)paren
suffix:semicolon
)brace
multiline_comment|/* Shift and mask the value into the field position */
id|merged_datum
op_assign
(paren
id|previous_raw_datum
op_lshift
id|obj_desc-&gt;common_field.start_field_bit_offset
)paren
suffix:semicolon
id|merged_datum
op_and_assign
id|mask
suffix:semicolon
multiline_comment|/* Apply the update rule (if necessary) and write the datum to the field */
id|status
op_assign
id|acpi_ex_write_field_datum_with_update_rule
(paren
id|obj_desc
comma
id|mask
comma
id|merged_datum
comma
id|field_datum_byte_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/* If the entire field fits within one datum, we are done. */
r_if
c_cond
(paren
(paren
id|datum_count
op_eq
l_int|1
)paren
op_logical_and
(paren
id|obj_desc-&gt;common_field.access_flags
op_amp
id|AFIELD_SINGLE_DATUM
)paren
)paren
(brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Part2:&n;&t; * Write the aligned data.&n;&t; *&n;&t; * We don&squot;t need to worry about the update rule for these data, because&n;&t; * all of the bits in each datum are part of the field.&n;&t; *&n;&t; * The last datum must be special cased because it might contain bits&n;&t; * that are not part of the field -- therefore the &quot;update rule&quot; must be&n;&t; * applied in Part3 below.&n;&t; */
r_while
c_loop
(paren
id|datum_offset
OL
id|datum_count
)paren
(brace
id|datum_offset
op_increment
suffix:semicolon
id|field_datum_byte_offset
op_add_assign
id|obj_desc-&gt;common_field.access_byte_width
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Get the next raw buffer datum.  It may contain bits of the previous&n;&t;&t; * field datum&n;&t;&t; */
id|acpi_ex_get_buffer_datum
(paren
op_amp
id|this_raw_datum
comma
id|buffer
comma
id|obj_desc-&gt;common_field.access_byte_width
comma
id|datum_offset
)paren
suffix:semicolon
multiline_comment|/* Create the field datum based on the field alignment */
r_if
c_cond
(paren
id|obj_desc-&gt;common_field.start_field_bit_offset
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Put together appropriate bits of the two raw buffer data to make&n;&t;&t;&t; * a single complete field datum&n;&t;&t;&t; */
id|merged_datum
op_assign
(paren
id|previous_raw_datum
op_rshift
id|obj_desc-&gt;common_field.datum_valid_bits
)paren
op_or
(paren
id|this_raw_datum
op_lshift
id|obj_desc-&gt;common_field.start_field_bit_offset
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Field began aligned on datum boundary */
id|merged_datum
op_assign
id|this_raw_datum
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Special handling for the last datum if the field does NOT end on&n;&t;&t; * a datum boundary.  Update Rule must be applied to the bits outside&n;&t;&t; * the field.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|datum_offset
op_eq
id|datum_count
)paren
op_logical_and
id|obj_desc-&gt;common_field.end_field_valid_bits
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Part3:&n;&t;&t;&t; * This is the last datum and the field does not end on a datum boundary.&n;&t;&t;&t; * Build the partial datum and write with the update rule.&n;&t;&t;&t; */
multiline_comment|/* Mask off the unused bits above (after) the end-of-field */
id|mask
op_assign
id|MASK_BITS_ABOVE
(paren
id|obj_desc-&gt;common_field.end_field_valid_bits
)paren
suffix:semicolon
id|merged_datum
op_and_assign
id|mask
suffix:semicolon
multiline_comment|/* Write the last datum with the update rule */
id|status
op_assign
id|acpi_ex_write_field_datum_with_update_rule
(paren
id|obj_desc
comma
id|mask
comma
id|merged_datum
comma
id|field_datum_byte_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Normal case -- write the completed datum */
id|status
op_assign
id|acpi_ex_write_field_datum
(paren
id|obj_desc
comma
id|field_datum_byte_offset
comma
id|merged_datum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Save the most recent datum since it may contain bits of the *next*&n;&t;&t; * field datum.  Update current byte offset.&n;&t;&t; */
id|previous_raw_datum
op_assign
id|this_raw_datum
suffix:semicolon
)brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
eof
