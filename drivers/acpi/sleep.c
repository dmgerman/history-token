multiline_comment|/*&n; * sleep.c - ACPI sleep support.&n; * &n; *  Copyright (c) 2000-2002 Patrick Mochel&n; *&n; *  Portions are&n; *  Copyright (C) 2001, 2002 Andy Grover &lt;andrew.grover@intel.com&gt;&n; *  Copyright (C) 2001, 2002 Paul Diefenbaugh &lt;paul.s.diefenbaugh@intel.com&gt;&n; */
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/sysrq.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/irq.h&gt;
macro_line|#include &lt;linux/pm.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/suspend.h&gt;
macro_line|#include &lt;linux/seq_file.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/acpi.h&gt;
macro_line|#include &quot;acpi_bus.h&quot;
macro_line|#include &quot;acpi_drivers.h&quot;
macro_line|#ifdef CONFIG_X86
macro_line|#include &lt;linux/mc146818rtc.h&gt;
macro_line|#endif
DECL|macro|_COMPONENT
mdefine_line|#define _COMPONENT&t;&t;ACPI_SYSTEM_COMPONENT
id|ACPI_MODULE_NAME
(paren
l_string|&quot;sleep&quot;
)paren
DECL|macro|ACPI_SYSTEM_FILE_SLEEP
mdefine_line|#define ACPI_SYSTEM_FILE_SLEEP&t;&t;&quot;sleep&quot;
DECL|macro|ACPI_SYSTEM_FILE_ALARM
mdefine_line|#define ACPI_SYSTEM_FILE_ALARM&t;&t;&quot;alarm&quot;
r_static
r_int
id|acpi_system_sleep_open_fs
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
id|acpi_system_alarm_open_fs
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
DECL|variable|sleep_states
r_static
id|u8
id|sleep_states
(braket
id|ACPI_S_STATE_COUNT
)braket
suffix:semicolon
DECL|variable|acpi_system_sleep_fops
r_static
r_struct
id|file_operations
id|acpi_system_sleep_fops
op_assign
(brace
dot
id|open
op_assign
id|acpi_system_sleep_open_fs
comma
dot
id|read
op_assign
id|seq_read
comma
dot
id|llseek
op_assign
id|seq_lseek
comma
dot
id|release
op_assign
id|single_release
comma
)brace
suffix:semicolon
DECL|variable|acpi_system_alarm_fops
r_static
r_struct
id|file_operations
id|acpi_system_alarm_fops
op_assign
(brace
dot
id|open
op_assign
id|acpi_system_alarm_open_fs
comma
dot
id|read
op_assign
id|seq_read
comma
dot
id|llseek
op_assign
id|seq_lseek
comma
dot
id|release
op_assign
id|single_release
comma
)brace
suffix:semicolon
r_static
r_void
DECL|function|acpi_power_off
id|acpi_power_off
(paren
r_void
)paren
(brace
id|acpi_enter_sleep_state_prep
c_func
(paren
id|ACPI_STATE_S5
)paren
suffix:semicolon
id|ACPI_DISABLE_IRQS
c_func
(paren
)paren
suffix:semicolon
id|acpi_enter_sleep_state
c_func
(paren
id|ACPI_STATE_S5
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * acpi_system_restore_state - OS-specific restoration of state&n; * @state:&t;sleep state we&squot;re exiting&n; *&n; * Note that if we&squot;re coming back from S4, the memory image should have already&n; * been loaded from the disk and is already in place. (Otherwise how else would we&n; * be here?).&n; */
id|acpi_status
DECL|function|acpi_system_restore_state
id|acpi_system_restore_state
(paren
id|u32
id|state
)paren
(brace
multiline_comment|/* restore processor state&n;&t; * We should only be here if we&squot;re coming back from STR or STD.&n;&t; * And, in the case of the latter, the memory image should have already&n;&t; * been loaded from disk.&n;&t; */
r_if
c_cond
(paren
id|state
OG
id|ACPI_STATE_S1
)paren
id|acpi_restore_state_mem
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait for power to come back */
id|mdelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* turn all the devices back on */
id|device_resume
c_func
(paren
id|RESUME_POWER_ON
)paren
suffix:semicolon
multiline_comment|/* enable interrupts once again */
id|ACPI_ENABLE_IRQS
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* restore device context */
id|device_resume
c_func
(paren
id|RESUME_RESTORE_STATE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmi_broken
op_amp
id|BROKEN_INIT_AFTER_S1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Broken toshiba laptop -&gt; kicking interrupts&bslash;n&quot;
)paren
suffix:semicolon
id|init_8259A
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|AE_OK
suffix:semicolon
)brace
multiline_comment|/**&n; * acpi_system_save_state - save OS specific state and power down devices&n; * @state:&t;sleep state we&squot;re entering.&n; *&n; * This handles saving all context to memory, and possibly disk.&n; * First, we call to the device driver layer to save device state.&n; * Once we have that, we save whatevery processor and kernel state we&n; * need to memory.&n; * If we&squot;re entering S4, we then write the memory image to disk.&n; *&n; * Only then is it safe for us to power down devices, since we may need&n; * the disks and upstream buses to write to.&n; */
id|acpi_status
DECL|function|acpi_system_save_state
id|acpi_system_save_state
c_func
(paren
id|u32
id|state
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Send notification to devices that they will be suspended.&n;&t; * If any device or driver cannot make the transition, either up&n;&t; * or down, we&squot;ll get an error back.&n;&t; */
id|error
op_assign
id|device_suspend
c_func
(paren
id|state
comma
id|SUSPEND_NOTIFY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|AE_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|state
OL
id|ACPI_STATE_S5
)paren
(brace
multiline_comment|/* Tell devices to stop I/O and actually save their state.&n;&t;&t; * It is theoretically possible that something could fail,&n;&t;&t; * so handle that gracefully..&n;&t;&t; */
id|error
op_assign
id|device_suspend
c_func
(paren
id|state
comma
id|SUSPEND_SAVE_STATE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
multiline_comment|/* tell devices to restore state if they have&n;&t;&t;&t; * it saved and to start taking I/O requests.&n;&t;&t;&t; */
id|device_resume
c_func
(paren
id|RESUME_RESTORE_STATE
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* flush caches */
id|ACPI_FLUSH_CPU_CACHE
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Do arch specific saving of state. */
r_if
c_cond
(paren
id|state
OG
id|ACPI_STATE_S1
)paren
(brace
id|error
op_assign
id|acpi_save_state_mem
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
(paren
id|state
op_eq
id|ACPI_STATE_S4
)paren
)paren
id|error
op_assign
id|acpi_save_state_disk
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|device_resume
c_func
(paren
id|RESUME_RESTORE_STATE
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* disable interrupts&n;&t; * Note that acpi_suspend -- our caller -- will do this once we return.&n;&t; * But, we want it done early, so we don&squot;t get any suprises during&n;&t; * the device suspend sequence.&n;&t; */
id|ACPI_DISABLE_IRQS
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Unconditionally turn off devices.&n;&t; * Obvious if we enter a sleep state.&n;&t; * If entering S5 (soft off), this should put devices in a&n;&t; * quiescent state.&n;&t; */
id|error
op_assign
id|device_suspend
c_func
(paren
id|state
comma
id|SUSPEND_POWER_DOWN
)paren
suffix:semicolon
multiline_comment|/* We&squot;re pretty screwed if we got an error from this.&n;&t; * We try to recover by simply calling our own restore_state&n;&t; * function; see above for definition.&n;&t; *&n;&t; * If it&squot;s S5 though, go through with it anyway..&n;&t; */
r_if
c_cond
(paren
id|error
op_logical_and
id|state
op_ne
id|ACPI_STATE_S5
)paren
id|acpi_system_restore_state
c_func
(paren
id|state
)paren
suffix:semicolon
r_return
id|error
ques
c_cond
id|AE_ERROR
suffix:colon
id|AE_OK
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    acpi_system_suspend&n; *&n; * PARAMETERS:  %state: Sleep state to enter.&n; *&n; * RETURN:      acpi_status, whether or not we successfully entered and&n; *              exited sleep.&n; *&n; * DESCRIPTION: Perform OS-specific action to enter sleep state.&n; *              This is the final step in going to sleep, per spec.  If we&n; *              know we&squot;re coming back (i.e. not entering S5), we save the&n; *              processor flags. [ We&squot;ll have to save and restore them anyway,&n; *              so we use the arch-agnostic save_flags and restore_flags&n; *              here.]  We then set the place to return to in arch-specific&n; *              globals using arch_set_return_point. Finally, we call the&n; *              ACPI function to write the proper values to I/O ports.&n; *&n; ****************************************************************************/
id|acpi_status
DECL|function|acpi_system_suspend
id|acpi_system_suspend
c_func
(paren
id|u32
id|state
)paren
(brace
id|acpi_status
id|status
op_assign
id|AE_ERROR
suffix:semicolon
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|state
)paren
(brace
r_case
id|ACPI_STATE_S1
suffix:colon
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|status
op_assign
id|acpi_enter_sleep_state
c_func
(paren
id|state
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACPI_STATE_S2
suffix:colon
macro_line|#ifdef CONFIG_SOFTWARE_SUSPEND
r_case
id|ACPI_STATE_S3
suffix:colon
id|do_suspend_lowlevel
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/**&n; * acpi_suspend - OS-agnostic system suspend/resume support (S? states)&n; * @state:&t;state we&squot;re entering&n; *&n; */
id|acpi_status
DECL|function|acpi_suspend
id|acpi_suspend
(paren
id|u32
id|state
)paren
(brace
id|acpi_status
id|status
suffix:semicolon
multiline_comment|/* get out if state is invalid */
r_if
c_cond
(paren
id|state
template_param
id|ACPI_STATE_S5
)paren
r_return
id|AE_ERROR
suffix:semicolon
id|freeze_processes
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* device_suspend needs processes to be stopped */
multiline_comment|/* do we have a wakeup address for S2 and S3? */
r_if
c_cond
(paren
id|state
op_eq
id|ACPI_STATE_S2
op_logical_or
id|state
op_eq
id|ACPI_STATE_S3
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|acpi_wakeup_address
)paren
r_return
id|AE_ERROR
suffix:semicolon
id|acpi_set_firmware_waking_vector
c_func
(paren
(paren
id|acpi_physical_address
)paren
id|acpi_wakeup_address
)paren
suffix:semicolon
)brace
id|acpi_enter_sleep_state_prep
c_func
(paren
id|state
)paren
suffix:semicolon
id|status
op_assign
id|acpi_system_save_state
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ACPI_SUCCESS
c_func
(paren
id|status
)paren
)paren
r_return
id|status
suffix:semicolon
multiline_comment|/* disable interrupts and flush caches */
id|ACPI_DISABLE_IRQS
c_func
(paren
)paren
suffix:semicolon
id|ACPI_FLUSH_CPU_CACHE
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* perform OS-specific sleep actions */
id|status
op_assign
id|acpi_system_suspend
c_func
(paren
id|state
)paren
suffix:semicolon
multiline_comment|/* Even if we failed to go to sleep, all of the devices are in an suspended&n;&t; * mode. So, we run these unconditionaly to make sure we have a usable system&n;&t; * no matter what.&n;&t; */
id|acpi_system_restore_state
c_func
(paren
id|state
)paren
suffix:semicolon
id|acpi_leave_sleep_state
c_func
(paren
id|state
)paren
suffix:semicolon
multiline_comment|/* make sure interrupts are enabled */
id|ACPI_ENABLE_IRQS
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* reset firmware waking vector */
id|acpi_set_firmware_waking_vector
c_func
(paren
(paren
id|acpi_physical_address
)paren
l_int|0
)paren
suffix:semicolon
id|thaw_processes
c_func
(paren
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
DECL|function|acpi_system_sleep_seq_show
r_static
r_int
id|acpi_system_sleep_seq_show
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
r_void
op_star
id|offset
)paren
(brace
r_int
id|i
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_system_sleep_seq_show&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|ACPI_STATE_S5
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sleep_states
(braket
id|i
)braket
)paren
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;S%d &quot;
comma
id|i
)paren
suffix:semicolon
)brace
id|seq_puts
c_func
(paren
id|seq
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|acpi_system_sleep_open_fs
r_static
r_int
id|acpi_system_sleep_open_fs
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_return
id|single_open
c_func
(paren
id|file
comma
id|acpi_system_sleep_seq_show
comma
id|PDE
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|data
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|acpi_system_write_sleep
id|acpi_system_write_sleep
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|acpi_status
id|status
op_assign
id|AE_OK
suffix:semicolon
r_char
id|state_string
(braket
l_int|12
)braket
op_assign
(brace
l_char|&squot;&bslash;0&squot;
)brace
suffix:semicolon
id|u32
id|state
op_assign
l_int|0
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_system_write_sleep&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
r_sizeof
(paren
id|state_string
)paren
op_minus
l_int|1
)paren
id|return_VALUE
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|state_string
comma
id|buffer
comma
id|count
)paren
)paren
id|return_VALUE
c_func
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
id|state_string
(braket
id|count
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|state
op_assign
id|simple_strtoul
c_func
(paren
id|state_string
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sleep_states
(braket
id|state
)braket
)paren
id|return_VALUE
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SOFTWARE_SUSPEND
r_if
c_cond
(paren
id|state
op_eq
l_int|4
)paren
(brace
id|software_suspend
c_func
(paren
)paren
suffix:semicolon
id|return_VALUE
c_func
(paren
id|count
)paren
suffix:semicolon
)brace
macro_line|#endif
id|status
op_assign
id|acpi_suspend
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
c_func
(paren
id|status
)paren
)paren
id|return_VALUE
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
id|return_VALUE
c_func
(paren
id|count
)paren
suffix:semicolon
)brace
DECL|function|acpi_system_alarm_seq_show
r_static
r_int
id|acpi_system_alarm_seq_show
c_func
(paren
r_struct
id|seq_file
op_star
id|seq
comma
r_void
op_star
id|offset
)paren
(brace
id|u32
id|sec
comma
id|min
comma
id|hr
suffix:semicolon
id|u32
id|day
comma
id|mo
comma
id|yr
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_system_alarm_seq_show&quot;
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
id|sec
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_SECONDS_ALARM
)paren
suffix:semicolon
id|min
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_MINUTES_ALARM
)paren
suffix:semicolon
id|hr
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_HOURS_ALARM
)paren
suffix:semicolon
macro_line|#if 0&t;/* If we ever get an FACP with proper values... */
r_if
c_cond
(paren
id|acpi_gbl_FADT-&gt;day_alrm
)paren
id|day
op_assign
id|CMOS_READ
c_func
(paren
id|acpi_gbl_FADT-&gt;day_alrm
)paren
suffix:semicolon
r_else
id|day
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_DAY_OF_MONTH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acpi_gbl_FADT-&gt;mon_alrm
)paren
id|mo
op_assign
id|CMOS_READ
c_func
(paren
id|acpi_gbl_FADT-&gt;mon_alrm
)paren
suffix:semicolon
r_else
id|mo
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_MONTH
)paren
suffix:semicolon
suffix:semicolon
r_if
c_cond
(paren
id|acpi_gbl_FADT-&gt;century
)paren
id|yr
op_assign
id|CMOS_READ
c_func
(paren
id|acpi_gbl_FADT-&gt;century
)paren
op_star
l_int|100
op_plus
id|CMOS_READ
c_func
(paren
id|RTC_YEAR
)paren
suffix:semicolon
r_else
id|yr
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_YEAR
)paren
suffix:semicolon
macro_line|#else
id|day
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_DAY_OF_MONTH
)paren
suffix:semicolon
id|mo
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_MONTH
)paren
suffix:semicolon
id|yr
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_YEAR
)paren
suffix:semicolon
macro_line|#endif
id|spin_unlock
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|sec
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|min
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|hr
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|day
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|mo
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|yr
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* we&squot;re trusting the FADT (see above)*/
macro_line|#else
multiline_comment|/* If we&squot;re not trusting the FADT, we should at least make it&n;&t; * right for _this_ century... ehm, what is _this_ century?&n;&t; *&n;&t; * TBD:&n;&t; *  ASAP: find piece of code in the kernel, e.g. star tracker driver,&n;&t; *        which we can trust to determine the century correctly. Atom&n;&t; *        watch driver would be nice, too...&n;&t; *&n;&t; *  if that has not happened, change for first release in 2050:&n; &t; *        if (yr&lt;50)&n;&t; *                yr += 2100;&n;&t; *        else&n;&t; *                yr += 2000;   // current line of code&n;&t; *&n;&t; *  if that has not happened either, please do on 2099/12/31:23:59:59&n;&t; *        s/2000/2100&n;&t; *&n;&t; */
id|yr
op_add_assign
l_int|2000
suffix:semicolon
macro_line|#endif
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;%4.4u-&quot;
comma
id|yr
)paren
suffix:semicolon
(paren
id|mo
OG
l_int|12
)paren
ques
c_cond
id|seq_puts
c_func
(paren
id|seq
comma
l_string|&quot;**-&quot;
)paren
suffix:colon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;%2.2u-&quot;
comma
id|mo
)paren
suffix:semicolon
(paren
id|day
OG
l_int|31
)paren
ques
c_cond
id|seq_puts
c_func
(paren
id|seq
comma
l_string|&quot;** &quot;
)paren
suffix:colon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;%2.2u &quot;
comma
id|day
)paren
suffix:semicolon
(paren
id|hr
OG
l_int|23
)paren
ques
c_cond
id|seq_puts
c_func
(paren
id|seq
comma
l_string|&quot;**:&quot;
)paren
suffix:colon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;%2.2u:&quot;
comma
id|hr
)paren
suffix:semicolon
(paren
id|min
OG
l_int|59
)paren
ques
c_cond
id|seq_puts
c_func
(paren
id|seq
comma
l_string|&quot;**:&quot;
)paren
suffix:colon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;%2.2u:&quot;
comma
id|min
)paren
suffix:semicolon
(paren
id|sec
OG
l_int|59
)paren
ques
c_cond
id|seq_puts
c_func
(paren
id|seq
comma
l_string|&quot;**&bslash;n&quot;
)paren
suffix:colon
id|seq_printf
c_func
(paren
id|seq
comma
l_string|&quot;%2.2u&bslash;n&quot;
comma
id|sec
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|acpi_system_alarm_open_fs
r_static
r_int
id|acpi_system_alarm_open_fs
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_return
id|single_open
c_func
(paren
id|file
comma
id|acpi_system_alarm_seq_show
comma
id|PDE
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|data
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|get_date_field
id|get_date_field
(paren
r_char
op_star
op_star
id|p
comma
id|u32
op_star
id|value
)paren
(brace
r_char
op_star
id|next
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|string_end
op_assign
l_int|NULL
suffix:semicolon
r_int
id|result
op_assign
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * Try to find delimeter, only to insert null.  The end of the&n;&t; * string won&squot;t have one, but is still valid.&n;&t; */
id|next
op_assign
id|strpbrk
c_func
(paren
op_star
id|p
comma
l_string|&quot;- :&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|next
)paren
op_star
id|next
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
op_star
id|value
op_assign
id|simple_strtoul
c_func
(paren
op_star
id|p
comma
op_amp
id|string_end
comma
l_int|10
)paren
suffix:semicolon
multiline_comment|/* Signal success if we got a good digit */
r_if
c_cond
(paren
id|string_end
op_ne
op_star
id|p
)paren
id|result
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|next
)paren
op_star
id|p
op_assign
id|next
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_static
r_int
DECL|function|acpi_system_write_alarm
id|acpi_system_write_alarm
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_char
id|alarm_string
(braket
l_int|30
)braket
op_assign
(brace
l_char|&squot;&bslash;0&squot;
)brace
suffix:semicolon
r_char
op_star
id|p
op_assign
id|alarm_string
suffix:semicolon
id|u32
id|sec
comma
id|min
comma
id|hr
comma
id|day
comma
id|mo
comma
id|yr
suffix:semicolon
r_int
id|adjust
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|rtc_control
op_assign
l_int|0
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_system_write_alarm&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
r_sizeof
(paren
id|alarm_string
)paren
op_minus
l_int|1
)paren
id|return_VALUE
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|alarm_string
comma
id|buffer
comma
id|count
)paren
)paren
id|return_VALUE
c_func
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
id|alarm_string
(braket
id|count
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* check for time adjustment */
r_if
c_cond
(paren
id|alarm_string
(braket
l_int|0
)braket
op_eq
l_char|&squot;+&squot;
)paren
(brace
id|p
op_increment
suffix:semicolon
id|adjust
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|result
op_assign
id|get_date_field
c_func
(paren
op_amp
id|p
comma
op_amp
id|yr
)paren
)paren
)paren
r_goto
id|end
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|get_date_field
c_func
(paren
op_amp
id|p
comma
op_amp
id|mo
)paren
)paren
)paren
r_goto
id|end
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|get_date_field
c_func
(paren
op_amp
id|p
comma
op_amp
id|day
)paren
)paren
)paren
r_goto
id|end
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|get_date_field
c_func
(paren
op_amp
id|p
comma
op_amp
id|hr
)paren
)paren
)paren
r_goto
id|end
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|get_date_field
c_func
(paren
op_amp
id|p
comma
op_amp
id|min
)paren
)paren
)paren
r_goto
id|end
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|get_date_field
c_func
(paren
op_amp
id|p
comma
op_amp
id|sec
)paren
)paren
)paren
r_goto
id|end
suffix:semicolon
r_if
c_cond
(paren
id|sec
OG
l_int|59
)paren
(brace
id|min
op_add_assign
l_int|1
suffix:semicolon
id|sec
op_sub_assign
l_int|60
suffix:semicolon
)brace
r_if
c_cond
(paren
id|min
OG
l_int|59
)paren
(brace
id|hr
op_add_assign
l_int|1
suffix:semicolon
id|min
op_sub_assign
l_int|60
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hr
OG
l_int|23
)paren
(brace
id|day
op_add_assign
l_int|1
suffix:semicolon
id|hr
op_sub_assign
l_int|24
suffix:semicolon
)brace
r_if
c_cond
(paren
id|day
OG
l_int|31
)paren
(brace
id|mo
op_add_assign
l_int|1
suffix:semicolon
id|day
op_sub_assign
l_int|31
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mo
OG
l_int|12
)paren
(brace
id|yr
op_add_assign
l_int|1
suffix:semicolon
id|mo
op_sub_assign
l_int|12
suffix:semicolon
)brace
id|spin_lock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
id|rtc_control
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_CONTROL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|rtc_control
op_amp
id|RTC_DM_BINARY
)paren
op_logical_or
id|RTC_ALWAYS_BCD
)paren
(brace
id|BIN_TO_BCD
c_func
(paren
id|yr
)paren
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|mo
)paren
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|day
)paren
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|hr
)paren
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|min
)paren
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|sec
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|adjust
)paren
(brace
id|yr
op_add_assign
id|CMOS_READ
c_func
(paren
id|RTC_YEAR
)paren
suffix:semicolon
id|mo
op_add_assign
id|CMOS_READ
c_func
(paren
id|RTC_MONTH
)paren
suffix:semicolon
id|day
op_add_assign
id|CMOS_READ
c_func
(paren
id|RTC_DAY_OF_MONTH
)paren
suffix:semicolon
id|hr
op_add_assign
id|CMOS_READ
c_func
(paren
id|RTC_HOURS
)paren
suffix:semicolon
id|min
op_add_assign
id|CMOS_READ
c_func
(paren
id|RTC_MINUTES
)paren
suffix:semicolon
id|sec
op_add_assign
id|CMOS_READ
c_func
(paren
id|RTC_SECONDS
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|rtc_control
op_amp
id|RTC_DM_BINARY
)paren
op_logical_or
id|RTC_ALWAYS_BCD
)paren
(brace
id|BCD_TO_BIN
c_func
(paren
id|yr
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|mo
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|day
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|hr
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|min
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|sec
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sec
OG
l_int|59
)paren
(brace
id|min
op_increment
suffix:semicolon
id|sec
op_sub_assign
l_int|60
suffix:semicolon
)brace
r_if
c_cond
(paren
id|min
OG
l_int|59
)paren
(brace
id|hr
op_increment
suffix:semicolon
id|min
op_sub_assign
l_int|60
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hr
OG
l_int|23
)paren
(brace
id|day
op_increment
suffix:semicolon
id|hr
op_sub_assign
l_int|24
suffix:semicolon
)brace
r_if
c_cond
(paren
id|day
OG
l_int|31
)paren
(brace
id|mo
op_increment
suffix:semicolon
id|day
op_sub_assign
l_int|31
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mo
OG
l_int|12
)paren
(brace
id|yr
op_increment
suffix:semicolon
id|mo
op_sub_assign
l_int|12
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|rtc_control
op_amp
id|RTC_DM_BINARY
)paren
op_logical_or
id|RTC_ALWAYS_BCD
)paren
(brace
id|BIN_TO_BCD
c_func
(paren
id|yr
)paren
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|mo
)paren
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|day
)paren
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|hr
)paren
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|min
)paren
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|sec
)paren
suffix:semicolon
)brace
id|spin_lock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
multiline_comment|/* write the fields the rtc knows about */
id|CMOS_WRITE
c_func
(paren
id|hr
comma
id|RTC_HOURS_ALARM
)paren
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
id|min
comma
id|RTC_MINUTES_ALARM
)paren
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
id|sec
comma
id|RTC_SECONDS_ALARM
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the system supports an enhanced alarm it will have non-zero&n;&t; * offsets into the CMOS RAM here -- which for some reason are pointing&n;&t; * to the RTC area of memory.&n;&t; */
macro_line|#if 0
r_if
c_cond
(paren
id|acpi_gbl_FADT-&gt;day_alrm
)paren
id|CMOS_WRITE
c_func
(paren
id|day
comma
id|acpi_gbl_FADT-&gt;day_alrm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acpi_gbl_FADT-&gt;mon_alrm
)paren
id|CMOS_WRITE
c_func
(paren
id|mo
comma
id|acpi_gbl_FADT-&gt;mon_alrm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acpi_gbl_FADT-&gt;century
)paren
id|CMOS_WRITE
c_func
(paren
id|yr
op_div
l_int|100
comma
id|acpi_gbl_FADT-&gt;century
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* enable the rtc alarm interrupt */
r_if
c_cond
(paren
op_logical_neg
(paren
id|rtc_control
op_amp
id|RTC_AIE
)paren
)paren
(brace
id|rtc_control
op_or_assign
id|RTC_AIE
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
id|rtc_control
comma
id|RTC_CONTROL
)paren
suffix:semicolon
id|CMOS_READ
c_func
(paren
id|RTC_INTR_FLAGS
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
id|acpi_set_register
c_func
(paren
id|ACPI_BITREG_RT_CLOCK_ENABLE
comma
l_int|1
comma
id|ACPI_MTX_LOCK
)paren
suffix:semicolon
id|file-&gt;f_pos
op_add_assign
id|count
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
id|end
suffix:colon
id|return_VALUE
c_func
(paren
id|result
ques
c_cond
id|result
suffix:colon
id|count
)paren
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_MAGIC_SYSRQ) &amp;&amp; defined(CONFIG_PM)
multiline_comment|/* Simple wrapper calling power down function. */
DECL|function|acpi_sysrq_power_off
r_static
r_void
id|acpi_sysrq_power_off
c_func
(paren
r_int
id|key
comma
r_struct
id|pt_regs
op_star
id|pt_regs
comma
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|acpi_power_off
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|sysrq_acpi_poweroff_op
r_struct
id|sysrq_key_op
id|sysrq_acpi_poweroff_op
op_assign
(brace
dot
id|handler
op_assign
op_amp
id|acpi_sysrq_power_off
comma
dot
id|help_msg
op_assign
l_string|&quot;Off&quot;
comma
dot
id|action_msg
op_assign
l_string|&quot;Power Off&bslash;n&quot;
)brace
suffix:semicolon
macro_line|#endif  /* CONFIG_MAGIC_SYSRQ */
DECL|function|acpi_sleep_init
r_static
r_int
id|__init
id|acpi_sleep_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|proc_dir_entry
op_star
id|entry
op_assign
l_int|NULL
suffix:semicolon
id|acpi_status
id|status
op_assign
id|AE_OK
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|ACPI_FUNCTION_TRACE
c_func
(paren
l_string|&quot;acpi_system_add_fs&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acpi_disabled
)paren
id|return_VALUE
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|PREFIX
l_string|&quot;(supports&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ACPI_S_STATE_COUNT
suffix:semicolon
id|i
op_increment
)paren
(brace
id|u8
id|type_a
comma
id|type_b
suffix:semicolon
id|status
op_assign
id|acpi_get_sleep_type_data
c_func
(paren
id|i
comma
op_amp
id|type_a
comma
op_amp
id|type_b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_SUCCESS
c_func
(paren
id|status
)paren
)paren
(brace
id|sleep_states
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; S%d&quot;
comma
id|i
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;)&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* &squot;sleep&squot; [R/W]*/
id|entry
op_assign
id|create_proc_entry
c_func
(paren
id|ACPI_SYSTEM_FILE_SLEEP
comma
id|S_IFREG
op_or
id|S_IRUGO
op_or
id|S_IWUSR
comma
id|acpi_root_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;Unable to create &squot;%s&squot; fs entry&bslash;n&quot;
comma
id|ACPI_SYSTEM_FILE_SLEEP
)paren
)paren
suffix:semicolon
r_else
(brace
id|entry-&gt;proc_fops
op_assign
op_amp
id|acpi_system_sleep_fops
suffix:semicolon
id|entry-&gt;proc_fops-&gt;write
op_assign
id|acpi_system_write_sleep
suffix:semicolon
)brace
multiline_comment|/* &squot;alarm&squot; [R/W] */
id|entry
op_assign
id|create_proc_entry
c_func
(paren
id|ACPI_SYSTEM_FILE_ALARM
comma
id|S_IFREG
op_or
id|S_IRUGO
op_or
id|S_IWUSR
comma
id|acpi_root_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
id|ACPI_DEBUG_PRINT
c_func
(paren
(paren
id|ACPI_DB_ERROR
comma
l_string|&quot;Unable to create &squot;%s&squot; fs entry&bslash;n&quot;
comma
id|ACPI_SYSTEM_FILE_ALARM
)paren
)paren
suffix:semicolon
r_else
(brace
id|entry-&gt;proc_fops
op_assign
op_amp
id|acpi_system_alarm_fops
suffix:semicolon
id|entry-&gt;proc_fops-&gt;write
op_assign
id|acpi_system_write_alarm
suffix:semicolon
)brace
multiline_comment|/* Install the soft-off (S5) handler. */
r_if
c_cond
(paren
id|sleep_states
(braket
id|ACPI_STATE_S5
)braket
)paren
(brace
id|pm_power_off
op_assign
id|acpi_power_off
suffix:semicolon
id|register_sysrq_key
c_func
(paren
l_char|&squot;o&squot;
comma
op_amp
id|sysrq_acpi_poweroff_op
)paren
suffix:semicolon
multiline_comment|/* workaround: some systems don&squot;t claim S4 support, but they&n;                   do support S5 (power-down). That is all we need, so&n;&t;&t;   indicate support. */
id|sleep_states
(braket
id|ACPI_STATE_S4
)braket
op_assign
l_int|1
suffix:semicolon
)brace
id|return_VALUE
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|variable|acpi_sleep_init
id|subsys_initcall
c_func
(paren
id|acpi_sleep_init
)paren
suffix:semicolon
eof
