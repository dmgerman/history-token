multiline_comment|/*&n; * $Id: grip_mp.c,v 1.9 2002/07/20 19:28:45 bonnland Exp $&n; *&n; *  Driver for the Gravis Grip Multiport, a gamepad &quot;hub&quot; that&n; *  connects up to four 9-pin digital gamepads/joysticks.&n; *  Driver tested on SMP and UP kernel versions 2.4.18-4 and 2.4.18-5.&n; *&n; *  Thanks to Chris Gassib for helpful advice.&n; *&n; *  Copyright (c)      2002 Brian Bonnlander, Bill Soudan&n; *  Copyright (c) 1998-2000 Vojtech Pavlik&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/gameport.h&gt;
macro_line|#include &lt;linux/input.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Brian Bonnlander&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Gravis Grip Multiport driver&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
macro_line|#ifdef GRIP_DEBUG
DECL|macro|dbg
mdefine_line|#define dbg(format, arg...) printk(KERN_ERR __FILE__ &quot;: &quot; format &quot;&bslash;n&quot; , ## arg)
macro_line|#else
DECL|macro|dbg
mdefine_line|#define dbg(format, arg...) do {} while (0)
macro_line|#endif
multiline_comment|/*&n; * Grip multiport state&n; */
DECL|struct|grip_mp
r_struct
id|grip_mp
(brace
DECL|member|gameport
r_struct
id|gameport
op_star
id|gameport
suffix:semicolon
DECL|member|timer
r_struct
id|timer_list
id|timer
suffix:semicolon
DECL|member|dev
r_struct
id|input_dev
id|dev
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|mode
r_int
id|mode
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|registered
r_int
id|registered
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|used
r_int
id|used
suffix:semicolon
DECL|member|reads
r_int
id|reads
suffix:semicolon
DECL|member|bads
r_int
id|bads
suffix:semicolon
multiline_comment|/* individual gamepad states */
DECL|member|buttons
r_int
id|buttons
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|xaxes
r_int
id|xaxes
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|yaxes
r_int
id|yaxes
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|dirty
r_int
id|dirty
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* has the state been updated? */
)brace
suffix:semicolon
multiline_comment|/*&n; * Multiport packet interpretation&n; */
DECL|macro|PACKET_FULL
mdefine_line|#define PACKET_FULL          0x80000000       /* packet is full                        */
DECL|macro|PACKET_IO_FAST
mdefine_line|#define PACKET_IO_FAST       0x40000000       /* 3 bits per gameport read              */
DECL|macro|PACKET_IO_SLOW
mdefine_line|#define PACKET_IO_SLOW       0x20000000       /* 1 bit per gameport read               */
DECL|macro|PACKET_MP_MORE
mdefine_line|#define PACKET_MP_MORE       0x04000000       /* multiport wants to send more          */
DECL|macro|PACKET_MP_DONE
mdefine_line|#define PACKET_MP_DONE       0x02000000       /* multiport done sending                */
multiline_comment|/*&n; * Packet status code interpretation&n; */
DECL|macro|IO_GOT_PACKET
mdefine_line|#define IO_GOT_PACKET        0x0100           /* Got a packet                           */
DECL|macro|IO_MODE_FAST
mdefine_line|#define IO_MODE_FAST         0x0200           /* Used 3 data bits per gameport read     */
DECL|macro|IO_SLOT_CHANGE
mdefine_line|#define IO_SLOT_CHANGE       0x0800           /* Multiport physical slot status changed */
DECL|macro|IO_DONE
mdefine_line|#define IO_DONE              0x1000           /* Multiport is done sending packets      */
DECL|macro|IO_RETRY
mdefine_line|#define IO_RETRY             0x4000           /* Try again later to get packet          */
DECL|macro|IO_RESET
mdefine_line|#define IO_RESET             0x8000           /* Force multiport to resend all packets  */
multiline_comment|/*&n; * Gamepad configuration data.  Other 9-pin digital joystick devices&n; * may work with the multiport, so this may not be an exhaustive list!&n; * Commodore 64 joystick remains untested.&n; */
DECL|macro|GRIP_INIT_DELAY
mdefine_line|#define GRIP_INIT_DELAY         2000          /*  2 ms */
DECL|macro|GRIP_REFRESH_TIME
mdefine_line|#define GRIP_REFRESH_TIME       HZ/50&t;      /* 20 ms */
DECL|macro|GRIP_MODE_NONE
mdefine_line|#define GRIP_MODE_NONE&t;&t;0
DECL|macro|GRIP_MODE_RESET
mdefine_line|#define GRIP_MODE_RESET         1
DECL|macro|GRIP_MODE_GP
mdefine_line|#define GRIP_MODE_GP&t;&t;2
DECL|macro|GRIP_MODE_C64
mdefine_line|#define GRIP_MODE_C64&t;&t;3
DECL|variable|grip_btn_gp
r_static
r_int
id|grip_btn_gp
(braket
)braket
op_assign
(brace
id|BTN_TR
comma
id|BTN_TL
comma
id|BTN_A
comma
id|BTN_B
comma
id|BTN_C
comma
id|BTN_X
comma
id|BTN_Y
comma
id|BTN_Z
comma
op_minus
l_int|1
)brace
suffix:semicolon
DECL|variable|grip_btn_c64
r_static
r_int
id|grip_btn_c64
(braket
)braket
op_assign
(brace
id|BTN_JOYSTICK
comma
op_minus
l_int|1
)brace
suffix:semicolon
DECL|variable|grip_abs_gp
r_static
r_int
id|grip_abs_gp
(braket
)braket
op_assign
(brace
id|ABS_X
comma
id|ABS_Y
comma
op_minus
l_int|1
)brace
suffix:semicolon
DECL|variable|grip_abs_c64
r_static
r_int
id|grip_abs_c64
(braket
)braket
op_assign
(brace
id|ABS_X
comma
id|ABS_Y
comma
op_minus
l_int|1
)brace
suffix:semicolon
DECL|variable|grip_abs
r_static
r_int
op_star
id|grip_abs
(braket
)braket
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
id|grip_abs_gp
comma
id|grip_abs_c64
)brace
suffix:semicolon
DECL|variable|grip_btn
r_static
r_int
op_star
id|grip_btn
(braket
)braket
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
id|grip_btn_gp
comma
id|grip_btn_c64
)brace
suffix:semicolon
DECL|variable|grip_name
r_static
r_char
op_star
id|grip_name
(braket
)braket
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;Gravis Grip Pad&quot;
comma
l_string|&quot;Commodore 64 Joystick&quot;
)brace
suffix:semicolon
DECL|variable|init_seq
r_static
r_const
r_int
id|init_seq
(braket
)braket
op_assign
(brace
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
)brace
suffix:semicolon
multiline_comment|/* Maps multiport directional values to X,Y axis values (each axis encoded in 3 bits) */
DECL|variable|axis_map
r_static
r_int
id|axis_map
(braket
)braket
op_assign
(brace
l_int|5
comma
l_int|9
comma
l_int|1
comma
l_int|5
comma
l_int|6
comma
l_int|10
comma
l_int|2
comma
l_int|6
comma
l_int|4
comma
l_int|8
comma
l_int|0
comma
l_int|4
comma
l_int|5
comma
l_int|9
comma
l_int|1
comma
l_int|5
)brace
suffix:semicolon
r_static
r_void
id|register_slot
c_func
(paren
r_int
id|i
comma
r_struct
id|grip_mp
op_star
id|grip
)paren
suffix:semicolon
multiline_comment|/*&n; * Returns whether an odd or even number of bits are on in pkt.&n; */
DECL|function|bit_parity
r_static
r_int
id|bit_parity
c_func
(paren
id|u32
id|pkt
)paren
(brace
r_int
id|x
op_assign
id|pkt
op_xor
(paren
id|pkt
op_rshift
l_int|16
)paren
suffix:semicolon
id|x
op_xor_assign
id|x
op_rshift
l_int|8
suffix:semicolon
id|x
op_xor_assign
id|x
op_rshift
l_int|4
suffix:semicolon
id|x
op_xor_assign
id|x
op_rshift
l_int|2
suffix:semicolon
id|x
op_xor_assign
id|x
op_rshift
l_int|1
suffix:semicolon
r_return
id|x
op_amp
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Poll gameport; return true if all bits set in &squot;onbits&squot; are on and&n; * all bits set in &squot;offbits&squot; are off.&n; */
DECL|function|poll_until
r_static
r_inline
r_int
id|poll_until
c_func
(paren
id|u8
id|onbits
comma
id|u8
id|offbits
comma
r_int
id|u_sec
comma
r_struct
id|gameport
op_star
id|gp
comma
id|u8
op_star
id|data
)paren
(brace
r_int
id|i
comma
id|nloops
suffix:semicolon
id|nloops
op_assign
id|gameport_time
c_func
(paren
id|gp
comma
id|u_sec
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nloops
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|data
op_assign
id|gameport_read
c_func
(paren
id|gp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|data
op_amp
id|onbits
)paren
op_eq
id|onbits
op_logical_and
(paren
op_complement
(paren
op_star
id|data
)paren
op_amp
id|offbits
)paren
op_eq
id|offbits
)paren
r_return
l_int|1
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;gameport timed out after %d microseconds.&bslash;n&quot;
comma
id|u_sec
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Gets a 28-bit packet from the multiport.&n; *&n; * After getting a packet successfully, commands encoded by sendcode may&n; * be sent to the multiport.&n; *&n; * The multiport clock value is reflected in gameport bit B4.&n; *&n; * Returns a packet status code indicating whether packet is valid, the transfer&n; * mode, and any error conditions.&n; *&n; * sendflags:      current I/O status&n; * sendcode:   data to send to the multiport if sendflags is nonzero&n; */
DECL|function|mp_io
r_static
r_int
id|mp_io
c_func
(paren
r_struct
id|gameport
op_star
id|gameport
comma
r_int
id|sendflags
comma
r_int
id|sendcode
comma
id|u32
op_star
id|packet
)paren
(brace
id|u8
id|raw_data
suffix:semicolon
multiline_comment|/* raw data from gameport */
id|u8
id|data_mask
suffix:semicolon
multiline_comment|/* packet data bits from raw_data */
id|u32
id|pkt
suffix:semicolon
multiline_comment|/* packet temporary storage */
r_int
id|bits_per_read
suffix:semicolon
multiline_comment|/* num packet bits per gameport read */
r_int
id|portvals
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* used for port value sanity check */
r_int
id|i
suffix:semicolon
multiline_comment|/* Gameport bits B0, B4, B5 should first be off, then B4 should come on. */
op_star
id|packet
op_assign
l_int|0
suffix:semicolon
id|raw_data
op_assign
id|gameport_read
c_func
(paren
id|gameport
)paren
suffix:semicolon
r_if
c_cond
(paren
id|raw_data
op_amp
l_int|1
)paren
r_return
id|IO_RETRY
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|64
suffix:semicolon
id|i
op_increment
)paren
(brace
id|raw_data
op_assign
id|gameport_read
c_func
(paren
id|gameport
)paren
suffix:semicolon
id|portvals
op_or_assign
l_int|1
op_lshift
(paren
(paren
id|raw_data
op_rshift
l_int|4
)paren
op_amp
l_int|3
)paren
suffix:semicolon
multiline_comment|/* Demux B4, B5 */
)brace
r_if
c_cond
(paren
id|portvals
op_eq
l_int|1
)paren
(brace
multiline_comment|/* B4, B5 off */
id|raw_data
op_assign
id|gameport_read
c_func
(paren
id|gameport
)paren
suffix:semicolon
id|portvals
op_assign
id|raw_data
op_amp
l_int|0xf0
suffix:semicolon
r_if
c_cond
(paren
id|raw_data
op_amp
l_int|0x31
)paren
r_return
id|IO_RESET
suffix:semicolon
id|gameport_trigger
c_func
(paren
id|gameport
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|poll_until
c_func
(paren
l_int|0x10
comma
l_int|0
comma
l_int|308
comma
id|gameport
comma
op_amp
id|raw_data
)paren
)paren
r_return
id|IO_RESET
suffix:semicolon
)brace
r_else
r_return
id|IO_RETRY
suffix:semicolon
multiline_comment|/* Determine packet transfer mode and prepare for packet construction. */
r_if
c_cond
(paren
id|raw_data
op_amp
l_int|0x20
)paren
(brace
multiline_comment|/* 3 data bits/read */
id|portvals
op_or_assign
id|raw_data
op_rshift
l_int|4
suffix:semicolon
multiline_comment|/* Compare B4-B7 before &amp; after trigger */
r_if
c_cond
(paren
id|portvals
op_ne
l_int|0xb
)paren
r_return
l_int|0
suffix:semicolon
id|data_mask
op_assign
l_int|7
suffix:semicolon
id|bits_per_read
op_assign
l_int|3
suffix:semicolon
id|pkt
op_assign
(paren
id|PACKET_FULL
op_or
id|PACKET_IO_FAST
)paren
op_rshift
l_int|28
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* 1 data bit/read */
id|data_mask
op_assign
l_int|1
suffix:semicolon
id|bits_per_read
op_assign
l_int|1
suffix:semicolon
id|pkt
op_assign
(paren
id|PACKET_FULL
op_or
id|PACKET_IO_SLOW
)paren
op_rshift
l_int|28
suffix:semicolon
)brace
multiline_comment|/* Construct a packet.  Final data bits must be zero. */
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|poll_until
c_func
(paren
l_int|0
comma
l_int|0x10
comma
l_int|77
comma
id|gameport
comma
op_amp
id|raw_data
)paren
)paren
r_return
id|IO_RESET
suffix:semicolon
id|raw_data
op_assign
(paren
id|raw_data
op_rshift
l_int|5
)paren
op_amp
id|data_mask
suffix:semicolon
r_if
c_cond
(paren
id|pkt
op_amp
id|PACKET_FULL
)paren
r_break
suffix:semicolon
id|pkt
op_assign
(paren
id|pkt
op_lshift
id|bits_per_read
)paren
op_or
id|raw_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|poll_until
c_func
(paren
l_int|0x10
comma
l_int|0
comma
l_int|77
comma
id|gameport
comma
op_amp
id|raw_data
)paren
)paren
r_return
id|IO_RESET
suffix:semicolon
)brace
r_if
c_cond
(paren
id|raw_data
)paren
r_return
id|IO_RESET
suffix:semicolon
multiline_comment|/* If 3 bits/read used, drop from 30 bits to 28. */
r_if
c_cond
(paren
id|bits_per_read
op_eq
l_int|3
)paren
(brace
id|pkt
op_assign
(paren
id|pkt
op_amp
l_int|0xffff0000
)paren
op_or
(paren
(paren
id|pkt
op_lshift
l_int|1
)paren
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|pkt
op_assign
(paren
id|pkt
op_rshift
l_int|2
)paren
op_or
l_int|0xf0000000
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bit_parity
c_func
(paren
id|pkt
)paren
op_eq
l_int|1
)paren
r_return
id|IO_RESET
suffix:semicolon
multiline_comment|/* Acknowledge packet receipt */
r_if
c_cond
(paren
op_logical_neg
id|poll_until
c_func
(paren
l_int|0x30
comma
l_int|0
comma
l_int|77
comma
id|gameport
comma
op_amp
id|raw_data
)paren
)paren
r_return
id|IO_RESET
suffix:semicolon
id|raw_data
op_assign
id|gameport_read
c_func
(paren
id|gameport
)paren
suffix:semicolon
r_if
c_cond
(paren
id|raw_data
op_amp
l_int|1
)paren
r_return
id|IO_RESET
suffix:semicolon
id|gameport_trigger
c_func
(paren
id|gameport
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|poll_until
c_func
(paren
l_int|0
comma
l_int|0x20
comma
l_int|77
comma
id|gameport
comma
op_amp
id|raw_data
)paren
)paren
r_return
id|IO_RESET
suffix:semicolon
multiline_comment|/* Return if we just wanted the packet or multiport wants to send more */
op_star
id|packet
op_assign
id|pkt
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sendflags
op_eq
l_int|0
)paren
op_logical_or
(paren
(paren
id|sendflags
op_amp
id|IO_RETRY
)paren
op_logical_and
op_logical_neg
(paren
id|pkt
op_amp
id|PACKET_MP_DONE
)paren
)paren
)paren
r_return
id|IO_GOT_PACKET
suffix:semicolon
r_if
c_cond
(paren
id|pkt
op_amp
id|PACKET_MP_MORE
)paren
r_return
id|IO_GOT_PACKET
op_or
id|IO_RETRY
suffix:semicolon
multiline_comment|/* Multiport is done sending packets and is ready to receive data */
r_if
c_cond
(paren
op_logical_neg
id|poll_until
c_func
(paren
l_int|0x20
comma
l_int|0
comma
l_int|77
comma
id|gameport
comma
op_amp
id|raw_data
)paren
)paren
r_return
id|IO_GOT_PACKET
op_or
id|IO_RESET
suffix:semicolon
id|raw_data
op_assign
id|gameport_read
c_func
(paren
id|gameport
)paren
suffix:semicolon
r_if
c_cond
(paren
id|raw_data
op_amp
l_int|1
)paren
r_return
id|IO_GOT_PACKET
op_or
id|IO_RESET
suffix:semicolon
multiline_comment|/* Trigger gameport based on bits in sendcode */
id|gameport_trigger
c_func
(paren
id|gameport
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|poll_until
c_func
(paren
l_int|0x20
comma
l_int|0x10
comma
l_int|116
comma
id|gameport
comma
op_amp
id|raw_data
)paren
)paren
r_return
id|IO_GOT_PACKET
op_or
id|IO_RESET
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|poll_until
c_func
(paren
l_int|0x30
comma
l_int|0
comma
l_int|193
comma
id|gameport
comma
op_amp
id|raw_data
)paren
)paren
r_return
id|IO_GOT_PACKET
op_or
id|IO_RESET
suffix:semicolon
r_if
c_cond
(paren
id|raw_data
op_amp
l_int|1
)paren
r_return
id|IO_GOT_PACKET
op_or
id|IO_RESET
suffix:semicolon
r_if
c_cond
(paren
id|sendcode
op_amp
l_int|1
)paren
id|gameport_trigger
c_func
(paren
id|gameport
)paren
suffix:semicolon
id|sendcode
op_rshift_assign
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
id|sendcode
)paren
suffix:semicolon
r_return
id|IO_GOT_PACKET
op_or
id|IO_MODE_FAST
suffix:semicolon
)brace
multiline_comment|/*&n; * Disables and restores interrupts for mp_io(), which does the actual I/O.&n; */
DECL|function|multiport_io
r_static
r_int
id|multiport_io
c_func
(paren
r_struct
id|gameport
op_star
id|gameport
comma
r_int
id|sendflags
comma
r_int
id|sendcode
comma
id|u32
op_star
id|packet
)paren
(brace
r_int
id|status
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|status
op_assign
id|mp_io
c_func
(paren
id|gameport
comma
id|sendflags
comma
id|sendcode
comma
id|packet
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n; * Puts multiport into digital mode.  Multiport LED turns green.&n; *&n; * Returns true if a valid digital packet was received, false otherwise.&n; */
DECL|function|dig_mode_start
r_static
r_int
id|dig_mode_start
c_func
(paren
r_struct
id|gameport
op_star
id|gameport
comma
id|u32
op_star
id|packet
)paren
(brace
r_int
id|i
comma
id|seq_len
op_assign
r_sizeof
(paren
id|init_seq
)paren
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
r_int
id|flags
comma
id|tries
op_assign
l_int|0
comma
id|bads
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|seq_len
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Send magic sequence */
r_if
c_cond
(paren
id|init_seq
(braket
id|i
)braket
)paren
id|gameport_trigger
c_func
(paren
id|gameport
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|GRIP_INIT_DELAY
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
multiline_comment|/* Wait for multiport to settle */
id|udelay
c_func
(paren
id|GRIP_INIT_DELAY
)paren
suffix:semicolon
r_while
c_loop
(paren
id|tries
OL
l_int|64
op_logical_and
id|bads
OL
l_int|8
)paren
(brace
multiline_comment|/* Reset multiport and try getting a packet */
id|flags
op_assign
id|multiport_io
c_func
(paren
id|gameport
comma
id|IO_RESET
comma
l_int|0x27
comma
id|packet
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|IO_MODE_FAST
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|IO_RETRY
)paren
id|tries
op_increment
suffix:semicolon
r_else
id|bads
op_increment
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Packet structure: B0-B15   =&gt; gamepad state&n; *                   B16-B20  =&gt; gamepad device type&n; *                   B21-B24  =&gt; multiport slot index (1-4)&n; *&n; * Known device types: 0x1f (grip pad), 0x0 (no device).  Others may exist.&n; *&n; * Returns the packet status.&n; */
DECL|function|get_and_decode_packet
r_static
r_int
id|get_and_decode_packet
c_func
(paren
r_struct
id|grip_mp
op_star
id|grip
comma
r_int
id|flags
)paren
(brace
id|u32
id|packet
suffix:semicolon
r_int
id|joytype
op_assign
l_int|0
suffix:semicolon
r_int
id|slot
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Get a packet and check for validity */
id|flags
op_and_assign
id|IO_RESET
op_or
id|IO_RETRY
suffix:semicolon
id|flags
op_assign
id|multiport_io
c_func
(paren
id|grip-&gt;gameport
comma
id|flags
comma
l_int|0
comma
op_amp
id|packet
)paren
suffix:semicolon
id|grip-&gt;reads
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|packet
op_amp
id|PACKET_MP_DONE
)paren
id|flags
op_or_assign
id|IO_DONE
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_logical_and
op_logical_neg
(paren
id|flags
op_amp
id|IO_GOT_PACKET
)paren
)paren
(brace
id|grip-&gt;bads
op_increment
suffix:semicolon
r_return
id|flags
suffix:semicolon
)brace
multiline_comment|/* Ignore non-gamepad packets, e.g. multiport hardware version */
id|slot
op_assign
(paren
(paren
id|packet
op_rshift
l_int|21
)paren
op_amp
l_int|0xf
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|slot
OL
l_int|0
)paren
op_logical_or
(paren
id|slot
OG
l_int|3
)paren
)paren
r_return
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * Handle &quot;reset&quot; packets, which occur at startup, and when gamepads&n;&t; * are removed or plugged in.  May contain configuration of a new gamepad.&n;&t; */
id|joytype
op_assign
(paren
id|packet
op_rshift
l_int|16
)paren
op_amp
l_int|0x1f
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|joytype
)paren
(brace
r_if
c_cond
(paren
id|grip-&gt;registered
(braket
id|slot
)braket
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;grip_mp: removing %s, slot %d&bslash;n&quot;
comma
id|grip_name
(braket
id|grip-&gt;mode
(braket
id|slot
)braket
)braket
comma
id|slot
)paren
suffix:semicolon
id|input_unregister_device
c_func
(paren
id|grip-&gt;dev
op_plus
id|slot
)paren
suffix:semicolon
id|grip-&gt;registered
(braket
id|slot
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|dbg
c_func
(paren
l_string|&quot;Reset: grip multiport slot %d&bslash;n&quot;
comma
id|slot
)paren
suffix:semicolon
id|grip-&gt;mode
(braket
id|slot
)braket
op_assign
id|GRIP_MODE_RESET
suffix:semicolon
id|flags
op_or_assign
id|IO_SLOT_CHANGE
suffix:semicolon
r_return
id|flags
suffix:semicolon
)brace
multiline_comment|/* Interpret a grip pad packet */
r_if
c_cond
(paren
id|joytype
op_eq
l_int|0x1f
)paren
(brace
r_int
id|dir
op_assign
(paren
id|packet
op_rshift
l_int|8
)paren
op_amp
l_int|0xf
suffix:semicolon
multiline_comment|/* eight way directional value */
id|grip-&gt;buttons
(braket
id|slot
)braket
op_assign
(paren
op_complement
id|packet
)paren
op_amp
l_int|0xff
suffix:semicolon
id|grip-&gt;yaxes
(braket
id|slot
)braket
op_assign
(paren
(paren
id|axis_map
(braket
id|dir
)braket
op_rshift
l_int|2
)paren
op_amp
l_int|3
)paren
op_minus
l_int|1
suffix:semicolon
id|grip-&gt;xaxes
(braket
id|slot
)braket
op_assign
(paren
id|axis_map
(braket
id|dir
)braket
op_amp
l_int|3
)paren
op_minus
l_int|1
suffix:semicolon
id|grip-&gt;dirty
(braket
id|slot
)braket
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|grip-&gt;mode
(braket
id|slot
)braket
op_eq
id|GRIP_MODE_RESET
)paren
id|flags
op_or_assign
id|IO_SLOT_CHANGE
suffix:semicolon
id|grip-&gt;mode
(braket
id|slot
)braket
op_assign
id|GRIP_MODE_GP
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|grip-&gt;registered
(braket
id|slot
)braket
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;New Grip pad in multiport slot %d.&bslash;n&quot;
comma
id|slot
)paren
suffix:semicolon
id|register_slot
c_func
(paren
id|slot
comma
id|grip
)paren
suffix:semicolon
)brace
r_return
id|flags
suffix:semicolon
)brace
multiline_comment|/* Handle non-grip device codes.  For now, just print diagnostics. */
(brace
r_static
r_int
id|strange_code
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|strange_code
op_ne
id|joytype
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Possible non-grip pad/joystick detected.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Got joy type 0x%x and packet 0x%x.&bslash;n&quot;
comma
id|joytype
comma
id|packet
)paren
suffix:semicolon
id|strange_code
op_assign
id|joytype
suffix:semicolon
)brace
)brace
r_return
id|flags
suffix:semicolon
)brace
multiline_comment|/*&n; * Returns true if all multiport slot states appear valid.&n; */
DECL|function|slots_valid
r_static
r_int
id|slots_valid
c_func
(paren
r_struct
id|grip_mp
op_star
id|grip
)paren
(brace
r_int
id|flags
comma
id|slot
comma
id|invalid
op_assign
l_int|0
comma
id|active
op_assign
l_int|0
suffix:semicolon
id|flags
op_assign
id|get_and_decode_packet
c_func
(paren
id|grip
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|IO_GOT_PACKET
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|slot
op_assign
l_int|0
suffix:semicolon
id|slot
OL
l_int|4
suffix:semicolon
id|slot
op_increment
)paren
(brace
r_if
c_cond
(paren
id|grip-&gt;mode
(braket
id|slot
)braket
op_eq
id|GRIP_MODE_RESET
)paren
id|invalid
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|grip-&gt;mode
(braket
id|slot
)braket
op_ne
id|GRIP_MODE_NONE
)paren
id|active
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Return true if no active slot but multiport sent all its data */
r_if
c_cond
(paren
op_logical_neg
id|active
)paren
r_return
(paren
id|flags
op_amp
id|IO_DONE
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* Return false if invalid device code received */
r_return
id|invalid
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Returns whether the multiport was placed into digital mode and&n; * able to communicate its state successfully.&n; */
DECL|function|multiport_init
r_static
r_int
id|multiport_init
c_func
(paren
r_struct
id|grip_mp
op_star
id|grip
)paren
(brace
r_int
id|dig_mode
comma
id|initialized
op_assign
l_int|0
comma
id|tries
op_assign
l_int|0
suffix:semicolon
id|u32
id|packet
suffix:semicolon
id|dig_mode
op_assign
id|dig_mode_start
c_func
(paren
id|grip-&gt;gameport
comma
op_amp
id|packet
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|dig_mode
op_logical_and
id|tries
OL
l_int|4
)paren
(brace
id|dig_mode
op_assign
id|dig_mode_start
c_func
(paren
id|grip-&gt;gameport
comma
op_amp
id|packet
)paren
suffix:semicolon
id|tries
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dig_mode
)paren
id|dbg
c_func
(paren
l_string|&quot;multiport_init(): digital mode achieved.&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
id|dbg
c_func
(paren
l_string|&quot;multiport_init(): unable to achieve digital mode.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Get packets, store multiport state, and check state&squot;s validity */
r_for
c_loop
(paren
id|tries
op_assign
l_int|0
suffix:semicolon
id|tries
OL
l_int|4096
suffix:semicolon
id|tries
op_increment
)paren
(brace
r_if
c_cond
(paren
id|slots_valid
c_func
(paren
id|grip
)paren
)paren
(brace
id|initialized
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|dbg
c_func
(paren
l_string|&quot;multiport_init(): initialized == %d&bslash;n&quot;
comma
id|initialized
)paren
suffix:semicolon
r_return
id|initialized
suffix:semicolon
)brace
multiline_comment|/*&n; * Reports joystick state to the linux input layer.&n; */
DECL|function|report_slot
r_static
r_void
id|report_slot
c_func
(paren
r_struct
id|grip_mp
op_star
id|grip
comma
r_int
id|slot
)paren
(brace
r_struct
id|input_dev
op_star
id|dev
op_assign
op_amp
(paren
id|grip-&gt;dev
(braket
id|slot
)braket
)paren
suffix:semicolon
r_int
id|i
comma
id|buttons
op_assign
id|grip-&gt;buttons
(braket
id|slot
)braket
suffix:semicolon
multiline_comment|/* Store button states with linux input driver */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
id|input_report_key
c_func
(paren
id|dev
comma
id|grip_btn_gp
(braket
id|i
)braket
comma
(paren
id|buttons
op_rshift
id|i
)paren
op_amp
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Store axis states with linux driver */
id|input_report_abs
c_func
(paren
id|dev
comma
id|ABS_X
comma
id|grip-&gt;xaxes
(braket
id|slot
)braket
)paren
suffix:semicolon
id|input_report_abs
c_func
(paren
id|dev
comma
id|ABS_Y
comma
id|grip-&gt;yaxes
(braket
id|slot
)braket
)paren
suffix:semicolon
multiline_comment|/* Tell the receiver of the events to process them */
id|input_sync
c_func
(paren
id|dev
)paren
suffix:semicolon
id|grip-&gt;dirty
(braket
id|slot
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Get the multiport state.&n; */
DECL|function|get_and_report_mp_state
r_static
r_void
id|get_and_report_mp_state
c_func
(paren
r_struct
id|grip_mp
op_star
id|grip
)paren
(brace
r_int
id|i
comma
id|npkts
comma
id|flags
suffix:semicolon
r_for
c_loop
(paren
id|npkts
op_assign
l_int|0
suffix:semicolon
id|npkts
OL
l_int|4
suffix:semicolon
id|npkts
op_increment
)paren
(brace
id|flags
op_assign
id|IO_RETRY
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
id|flags
op_assign
id|get_and_decode_packet
c_func
(paren
id|grip
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|IO_GOT_PACKET
)paren
op_logical_or
op_logical_neg
(paren
id|flags
op_amp
id|IO_RETRY
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|IO_DONE
)paren
r_break
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|grip-&gt;dirty
(braket
id|i
)braket
)paren
id|report_slot
c_func
(paren
id|grip
comma
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called when a joystick device file is opened&n; */
DECL|function|grip_open
r_static
r_int
id|grip_open
c_func
(paren
r_struct
id|input_dev
op_star
id|dev
)paren
(brace
r_struct
id|grip_mp
op_star
id|grip
op_assign
id|dev
op_member_access_from_pointer
r_private
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|grip-&gt;used
op_increment
)paren
id|mod_timer
c_func
(paren
op_amp
id|grip-&gt;timer
comma
id|jiffies
op_plus
id|GRIP_REFRESH_TIME
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Called when a joystick device file is closed&n; */
DECL|function|grip_close
r_static
r_void
id|grip_close
c_func
(paren
r_struct
id|input_dev
op_star
id|dev
)paren
(brace
r_struct
id|grip_mp
op_star
id|grip
op_assign
id|dev
op_member_access_from_pointer
r_private
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|grip-&gt;used
)paren
id|del_timer
c_func
(paren
op_amp
id|grip-&gt;timer
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Tell the linux input layer about a newly plugged-in gamepad.&n; */
DECL|function|register_slot
r_static
r_void
id|register_slot
c_func
(paren
r_int
id|slot
comma
r_struct
id|grip_mp
op_star
id|grip
)paren
(brace
r_int
id|j
comma
id|t
suffix:semicolon
id|grip-&gt;dev
(braket
id|slot
)braket
dot
r_private
op_assign
id|grip
suffix:semicolon
id|grip-&gt;dev
(braket
id|slot
)braket
dot
id|open
op_assign
id|grip_open
suffix:semicolon
id|grip-&gt;dev
(braket
id|slot
)braket
dot
id|close
op_assign
id|grip_close
suffix:semicolon
id|grip-&gt;dev
(braket
id|slot
)braket
dot
id|name
op_assign
id|grip_name
(braket
id|grip-&gt;mode
(braket
id|slot
)braket
)braket
suffix:semicolon
id|grip-&gt;dev
(braket
id|slot
)braket
dot
id|id.bustype
op_assign
id|BUS_GAMEPORT
suffix:semicolon
id|grip-&gt;dev
(braket
id|slot
)braket
dot
id|id.vendor
op_assign
id|GAMEPORT_ID_VENDOR_GRAVIS
suffix:semicolon
id|grip-&gt;dev
(braket
id|slot
)braket
dot
id|id.product
op_assign
l_int|0x0100
op_plus
id|grip-&gt;mode
(braket
id|slot
)braket
suffix:semicolon
id|grip-&gt;dev
(braket
id|slot
)braket
dot
id|id.version
op_assign
l_int|0x0100
suffix:semicolon
id|grip-&gt;dev
(braket
id|slot
)braket
dot
id|evbit
(braket
l_int|0
)braket
op_assign
id|BIT
c_func
(paren
id|EV_KEY
)paren
op_or
id|BIT
c_func
(paren
id|EV_ABS
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
(paren
id|t
op_assign
id|grip_abs
(braket
id|grip-&gt;mode
(braket
id|slot
)braket
)braket
(braket
id|j
)braket
)paren
op_ge
l_int|0
suffix:semicolon
id|j
op_increment
)paren
(brace
id|set_bit
c_func
(paren
id|t
comma
id|grip-&gt;dev
(braket
id|slot
)braket
dot
id|absbit
)paren
suffix:semicolon
id|grip-&gt;dev
(braket
id|slot
)braket
dot
id|absmin
(braket
id|t
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|grip-&gt;dev
(braket
id|slot
)braket
dot
id|absmax
(braket
id|t
)braket
op_assign
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
(paren
id|t
op_assign
id|grip_btn
(braket
id|grip-&gt;mode
(braket
id|slot
)braket
)braket
(braket
id|j
)braket
)paren
op_ge
l_int|0
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|t
OG
l_int|0
)paren
id|set_bit
c_func
(paren
id|t
comma
id|grip-&gt;dev
(braket
id|slot
)braket
dot
id|keybit
)paren
suffix:semicolon
id|input_register_device
c_func
(paren
id|grip-&gt;dev
op_plus
id|slot
)paren
suffix:semicolon
id|grip-&gt;registered
(braket
id|slot
)braket
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|grip-&gt;dirty
(braket
id|slot
)braket
)paren
multiline_comment|/* report initial state, if any */
id|report_slot
c_func
(paren
id|grip
comma
id|slot
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;grip_mp: added %s, slot %d&bslash;n&quot;
comma
id|grip_name
(braket
id|grip-&gt;mode
(braket
id|slot
)braket
)braket
comma
id|slot
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Repeatedly polls the multiport and generates events.&n; */
DECL|function|grip_timer
r_static
r_void
id|grip_timer
c_func
(paren
r_int
r_int
r_private
)paren
(brace
r_struct
id|grip_mp
op_star
id|grip
op_assign
(paren
r_void
op_star
)paren
r_private
suffix:semicolon
id|get_and_report_mp_state
c_func
(paren
id|grip
)paren
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|grip-&gt;timer
comma
id|jiffies
op_plus
id|GRIP_REFRESH_TIME
)paren
suffix:semicolon
)brace
DECL|function|grip_connect
r_static
r_void
id|grip_connect
c_func
(paren
r_struct
id|gameport
op_star
id|gameport
comma
r_struct
id|gameport_dev
op_star
id|dev
)paren
(brace
r_struct
id|grip_mp
op_star
id|grip
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|grip
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|grip_mp
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
r_return
suffix:semicolon
id|memset
c_func
(paren
id|grip
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|grip_mp
)paren
)paren
suffix:semicolon
id|gameport
op_member_access_from_pointer
r_private
op_assign
id|grip
suffix:semicolon
id|grip-&gt;gameport
op_assign
id|gameport
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|grip-&gt;timer
)paren
suffix:semicolon
id|grip-&gt;timer.data
op_assign
(paren
r_int
)paren
id|grip
suffix:semicolon
id|grip-&gt;timer.function
op_assign
id|grip_timer
suffix:semicolon
r_if
c_cond
(paren
id|gameport_open
c_func
(paren
id|gameport
comma
id|dev
comma
id|GAMEPORT_MODE_RAW
)paren
)paren
r_goto
id|fail1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|multiport_init
c_func
(paren
id|grip
)paren
)paren
r_goto
id|fail2
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|grip-&gt;mode
(braket
l_int|0
)braket
op_logical_and
op_logical_neg
id|grip-&gt;mode
(braket
l_int|1
)braket
op_logical_and
multiline_comment|/* nothing plugged in */
op_logical_neg
id|grip-&gt;mode
(braket
l_int|2
)braket
op_logical_and
op_logical_neg
id|grip-&gt;mode
(braket
l_int|3
)braket
)paren
r_goto
id|fail2
suffix:semicolon
r_return
suffix:semicolon
id|fail2
suffix:colon
id|gameport_close
c_func
(paren
id|gameport
)paren
suffix:semicolon
id|fail1
suffix:colon
id|kfree
c_func
(paren
id|grip
)paren
suffix:semicolon
)brace
DECL|function|grip_disconnect
r_static
r_void
id|grip_disconnect
c_func
(paren
r_struct
id|gameport
op_star
id|gameport
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|grip_mp
op_star
id|grip
op_assign
id|gameport
op_member_access_from_pointer
r_private
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|grip-&gt;registered
(braket
id|i
)braket
)paren
id|input_unregister_device
c_func
(paren
id|grip-&gt;dev
op_plus
id|i
)paren
suffix:semicolon
id|gameport_close
c_func
(paren
id|gameport
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|grip
)paren
suffix:semicolon
)brace
DECL|variable|grip_dev
r_static
r_struct
id|gameport_dev
id|grip_dev
op_assign
(brace
dot
id|connect
op_assign
id|grip_connect
comma
dot
id|disconnect
op_assign
id|grip_disconnect
comma
)brace
suffix:semicolon
DECL|function|grip_init
r_static
r_int
id|grip_init
c_func
(paren
r_void
)paren
(brace
id|gameport_register_device
c_func
(paren
op_amp
id|grip_dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|grip_exit
r_static
r_void
id|grip_exit
c_func
(paren
r_void
)paren
(brace
id|gameport_unregister_device
c_func
(paren
op_amp
id|grip_dev
)paren
suffix:semicolon
)brace
DECL|variable|grip_init
id|module_init
c_func
(paren
id|grip_init
)paren
suffix:semicolon
DECL|variable|grip_exit
id|module_exit
c_func
(paren
id|grip_exit
)paren
suffix:semicolon
eof
