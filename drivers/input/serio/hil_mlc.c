multiline_comment|/*&n; * HIL MLC state machine and serio interface driver&n; *&n; * Copyright (c) 2001 Brian S. Julin&n; * All rights reserved.&n; *&n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions&n; * are met:&n; * 1. Redistributions of source code must retain the above copyright&n; *    notice, this list of conditions, and the following disclaimer,&n; *    without modification.&n; * 2. The name of the author may not be used to endorse or promote products&n; *    derived from this software without specific prior written permission.&n; *&n; * Alternatively, this software may be distributed under the terms of the&n; * GNU General Public License (&quot;GPL&quot;).&n; *&n; * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&squot;&squot; AND&n; * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE&n; * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE&n; * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR&n; * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL&n; * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS&n; * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)&n; * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT&n; * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY&n; *&n; * References:&n; * HP-HIL Technical Reference Manual.  Hewlett Packard Product No. 45918A&n; *&n; *&n; *&t;Driver theory of operation:&n; *&n; *&t;Some access methods and an ISR is defined by the sub-driver &n; *&t;(e.g. hp_sdc_mlc.c).  These methods are expected to provide a &n; *&t;few bits of logic in addition to raw access to the HIL MLC, &n; *&t;specifically, the ISR, which is entirely registered by the &n; *&t;sub-driver and invoked directly, must check for record &n; *&t;termination or packet match, at which point a semaphore must&n; *&t;be cleared and then the hil_mlcs_tasklet must be scheduled.&n; *&n; *&t;The hil_mlcs_tasklet processes the state machine for all MLCs&n; *&t;each time it runs, checking each MLC&squot;s progress at the current&n; *&t;node in the state machine, and moving the MLC to subsequent nodes&n; *&t;in the state machine when appropriate.  It will reschedule&n; *&t;itself if output is pending.  (This rescheduling should be replaced&n; *&t;at some point with a sub-driver-specific mechanism.)&n; *&n; *&t;A timer task prods the tasklet once per second to prevent &n; *&t;hangups when attached devices do not return expected data&n; *&t;and to initiate probes of the loop for new devices.&n; */
macro_line|#include &lt;linux/hil_mlc.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/list.h&gt;
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Brian S. Julin &lt;bri@calyx.com&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;HIL MLC serio&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;Dual BSD/GPL&quot;
)paren
suffix:semicolon
DECL|variable|hil_mlc_register
id|EXPORT_SYMBOL
c_func
(paren
id|hil_mlc_register
)paren
suffix:semicolon
DECL|variable|hil_mlc_unregister
id|EXPORT_SYMBOL
c_func
(paren
id|hil_mlc_unregister
)paren
suffix:semicolon
DECL|macro|PREFIX
mdefine_line|#define PREFIX &quot;HIL MLC: &quot;
r_static
id|LIST_HEAD
c_func
(paren
id|hil_mlcs
)paren
suffix:semicolon
r_static
id|DEFINE_RWLOCK
c_func
(paren
id|hil_mlcs_lock
)paren
suffix:semicolon
DECL|variable|hil_mlcs_kicker
r_static
r_struct
id|timer_list
id|hil_mlcs_kicker
suffix:semicolon
DECL|variable|hil_mlcs_probe
r_static
r_int
id|hil_mlcs_probe
suffix:semicolon
r_static
r_void
id|hil_mlcs_process
c_func
(paren
r_int
r_int
id|unused
)paren
suffix:semicolon
id|DECLARE_TASKLET_DISABLED
c_func
(paren
id|hil_mlcs_tasklet
comma
id|hil_mlcs_process
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* #define HIL_MLC_DEBUG */
multiline_comment|/********************** Device info/instance management **********************/
DECL|function|hil_mlc_clear_di_map
r_static
r_void
id|hil_mlc_clear_di_map
(paren
id|hil_mlc
op_star
id|mlc
comma
r_int
id|val
)paren
(brace
r_int
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|val
suffix:semicolon
id|j
OL
l_int|7
suffix:semicolon
id|j
op_increment
)paren
(brace
id|mlc-&gt;di_map
(braket
id|j
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|hil_mlc_clear_di_scratch
r_static
r_void
id|hil_mlc_clear_di_scratch
(paren
id|hil_mlc
op_star
id|mlc
)paren
(brace
id|memset
c_func
(paren
op_amp
(paren
id|mlc-&gt;di_scratch
)paren
comma
l_int|0
comma
r_sizeof
(paren
id|mlc-&gt;di_scratch
)paren
)paren
suffix:semicolon
)brace
DECL|function|hil_mlc_copy_di_scratch
r_static
r_void
id|hil_mlc_copy_di_scratch
(paren
id|hil_mlc
op_star
id|mlc
comma
r_int
id|idx
)paren
(brace
id|memcpy
c_func
(paren
op_amp
(paren
id|mlc-&gt;di
(braket
id|idx
)braket
)paren
comma
op_amp
(paren
id|mlc-&gt;di_scratch
)paren
comma
r_sizeof
(paren
id|mlc-&gt;di_scratch
)paren
)paren
suffix:semicolon
)brace
DECL|function|hil_mlc_match_di_scratch
r_static
r_int
id|hil_mlc_match_di_scratch
(paren
id|hil_mlc
op_star
id|mlc
)paren
(brace
r_int
id|idx
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|HIL_MLC_DEVMEM
suffix:semicolon
id|idx
op_increment
)paren
(brace
r_int
id|j
comma
id|found
suffix:semicolon
multiline_comment|/* In-use slots are not eligible. */
id|found
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|7
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mlc-&gt;di_map
(braket
id|j
)braket
op_eq
id|idx
)paren
id|found
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|found
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|mlc-&gt;di
op_plus
id|idx
comma
op_amp
(paren
id|mlc-&gt;di_scratch
)paren
comma
r_sizeof
(paren
id|mlc-&gt;di_scratch
)paren
)paren
)paren
r_break
suffix:semicolon
)brace
r_return
(paren
id|idx
op_ge
id|HIL_MLC_DEVMEM
)paren
ques
c_cond
op_minus
l_int|1
suffix:colon
id|idx
suffix:semicolon
)brace
DECL|function|hil_mlc_find_free_di
r_static
r_int
id|hil_mlc_find_free_di
c_func
(paren
id|hil_mlc
op_star
id|mlc
)paren
(brace
r_int
id|idx
suffix:semicolon
multiline_comment|/* TODO: Pick all-zero slots first, failing that, &n;&t; * randomize the slot picked among those eligible. &n;&t; */
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|HIL_MLC_DEVMEM
suffix:semicolon
id|idx
op_increment
)paren
(brace
r_int
id|j
comma
id|found
suffix:semicolon
id|found
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|7
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mlc-&gt;di_map
(braket
id|j
)braket
op_eq
id|idx
)paren
id|found
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
r_break
suffix:semicolon
)brace
r_return
id|idx
suffix:semicolon
multiline_comment|/* Note: It is guaranteed at least one above will match */
)brace
DECL|function|hil_mlc_clean_serio_map
r_static
r_inline
r_void
id|hil_mlc_clean_serio_map
c_func
(paren
id|hil_mlc
op_star
id|mlc
)paren
(brace
r_int
id|idx
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|HIL_MLC_DEVMEM
suffix:semicolon
id|idx
op_increment
)paren
(brace
r_int
id|j
comma
id|found
suffix:semicolon
id|found
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|7
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mlc-&gt;di_map
(braket
id|j
)braket
op_eq
id|idx
)paren
id|found
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
id|mlc-&gt;serio_map
(braket
id|idx
)braket
dot
id|di_revmap
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|hil_mlc_send_polls
r_static
r_void
id|hil_mlc_send_polls
c_func
(paren
id|hil_mlc
op_star
id|mlc
)paren
(brace
r_int
id|did
comma
id|i
comma
id|cnt
suffix:semicolon
r_struct
id|serio
op_star
id|serio
suffix:semicolon
r_struct
id|serio_driver
op_star
id|drv
suffix:semicolon
id|i
op_assign
id|cnt
op_assign
l_int|0
suffix:semicolon
id|did
op_assign
(paren
id|mlc-&gt;ipacket
(braket
l_int|0
)braket
op_amp
id|HIL_PKT_ADDR_MASK
)paren
op_rshift
l_int|8
suffix:semicolon
id|serio
op_assign
id|did
ques
c_cond
id|mlc-&gt;serio
(braket
id|mlc-&gt;di_map
(braket
id|did
op_minus
l_int|1
)braket
)braket
suffix:colon
l_int|NULL
suffix:semicolon
id|drv
op_assign
(paren
id|serio
op_ne
l_int|NULL
)paren
ques
c_cond
id|serio-&gt;drv
suffix:colon
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|mlc-&gt;icount
OL
l_int|15
op_minus
id|i
)paren
(brace
id|hil_packet
id|p
suffix:semicolon
id|p
op_assign
id|mlc-&gt;ipacket
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|did
op_ne
(paren
id|p
op_amp
id|HIL_PKT_ADDR_MASK
)paren
op_rshift
l_int|8
)paren
(brace
r_if
c_cond
(paren
id|drv
op_eq
l_int|NULL
op_logical_or
id|drv-&gt;interrupt
op_eq
l_int|NULL
)paren
r_goto
id|skip
suffix:semicolon
id|drv
op_member_access_from_pointer
id|interrupt
c_func
(paren
id|serio
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|drv
op_member_access_from_pointer
id|interrupt
c_func
(paren
id|serio
comma
id|HIL_ERR_INT
op_rshift
l_int|16
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|drv
op_member_access_from_pointer
id|interrupt
c_func
(paren
id|serio
comma
id|HIL_PKT_CMD
op_rshift
l_int|8
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|drv
op_member_access_from_pointer
id|interrupt
c_func
(paren
id|serio
comma
id|HIL_CMD_POL
op_plus
id|cnt
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|skip
suffix:colon
id|did
op_assign
(paren
id|p
op_amp
id|HIL_PKT_ADDR_MASK
)paren
op_rshift
l_int|8
suffix:semicolon
id|serio
op_assign
id|did
ques
c_cond
id|mlc-&gt;serio
(braket
id|mlc-&gt;di_map
(braket
id|did
op_minus
l_int|1
)braket
)braket
suffix:colon
l_int|NULL
suffix:semicolon
id|drv
op_assign
(paren
id|serio
op_ne
l_int|NULL
)paren
ques
c_cond
id|serio-&gt;drv
suffix:colon
l_int|NULL
suffix:semicolon
id|cnt
op_assign
l_int|0
suffix:semicolon
)brace
id|cnt
op_increment
suffix:semicolon
id|i
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|drv
op_eq
l_int|NULL
op_logical_or
id|drv-&gt;interrupt
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|drv
op_member_access_from_pointer
id|interrupt
c_func
(paren
id|serio
comma
(paren
id|p
op_rshift
l_int|24
)paren
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|drv
op_member_access_from_pointer
id|interrupt
c_func
(paren
id|serio
comma
(paren
id|p
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|drv
op_member_access_from_pointer
id|interrupt
c_func
(paren
id|serio
comma
(paren
id|p
op_rshift
l_int|8
)paren
op_amp
op_complement
id|HIL_PKT_ADDR_MASK
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|drv
op_member_access_from_pointer
id|interrupt
c_func
(paren
id|serio
comma
id|p
op_amp
l_int|0xff
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*************************** State engine *********************************/
DECL|macro|HILSEN_SCHED
mdefine_line|#define HILSEN_SCHED&t;0x000100&t;/* Schedule the tasklet&t;&t;*/
DECL|macro|HILSEN_BREAK
mdefine_line|#define HILSEN_BREAK&t;0x000200&t;/* Wait until next pass&t;&t;*/
DECL|macro|HILSEN_UP
mdefine_line|#define HILSEN_UP&t;0x000400&t;/* relative node#, decrement&t;*/
DECL|macro|HILSEN_DOWN
mdefine_line|#define HILSEN_DOWN&t;0x000800&t;/* relative node#, increment&t;*/
DECL|macro|HILSEN_FOLLOW
mdefine_line|#define HILSEN_FOLLOW&t;0x001000&t;/* use retval as next node#&t;*/
DECL|macro|HILSEN_MASK
mdefine_line|#define HILSEN_MASK&t;0x0000ff
DECL|macro|HILSEN_START
mdefine_line|#define HILSEN_START&t;0
DECL|macro|HILSEN_RESTART
mdefine_line|#define HILSEN_RESTART&t;1
DECL|macro|HILSEN_DHR
mdefine_line|#define HILSEN_DHR&t;9
DECL|macro|HILSEN_DHR2
mdefine_line|#define HILSEN_DHR2&t;10
DECL|macro|HILSEN_IFC
mdefine_line|#define HILSEN_IFC&t;14
DECL|macro|HILSEN_HEAL0
mdefine_line|#define HILSEN_HEAL0&t;16
DECL|macro|HILSEN_HEAL
mdefine_line|#define HILSEN_HEAL&t;18
DECL|macro|HILSEN_ACF
mdefine_line|#define HILSEN_ACF      21
DECL|macro|HILSEN_ACF2
mdefine_line|#define HILSEN_ACF2&t;22
DECL|macro|HILSEN_DISC0
mdefine_line|#define HILSEN_DISC0&t;25
DECL|macro|HILSEN_DISC
mdefine_line|#define HILSEN_DISC&t;27
DECL|macro|HILSEN_MATCH
mdefine_line|#define HILSEN_MATCH&t;40
DECL|macro|HILSEN_OPERATE
mdefine_line|#define HILSEN_OPERATE&t;41
DECL|macro|HILSEN_PROBE
mdefine_line|#define HILSEN_PROBE&t;44
DECL|macro|HILSEN_DSR
mdefine_line|#define HILSEN_DSR&t;52
DECL|macro|HILSEN_REPOLL
mdefine_line|#define HILSEN_REPOLL&t;55
DECL|macro|HILSEN_IFCACF
mdefine_line|#define HILSEN_IFCACF&t;58
DECL|macro|HILSEN_END
mdefine_line|#define HILSEN_END&t;60
DECL|macro|HILSEN_NEXT
mdefine_line|#define HILSEN_NEXT&t;(HILSEN_DOWN | 1)
DECL|macro|HILSEN_SAME
mdefine_line|#define HILSEN_SAME&t;(HILSEN_DOWN | 0)
DECL|macro|HILSEN_LAST
mdefine_line|#define HILSEN_LAST&t;(HILSEN_UP | 1)
DECL|macro|HILSEN_DOZE
mdefine_line|#define HILSEN_DOZE&t;(HILSEN_SAME | HILSEN_SCHED | HILSEN_BREAK)
DECL|macro|HILSEN_SLEEP
mdefine_line|#define HILSEN_SLEEP&t;(HILSEN_SAME | HILSEN_BREAK)
DECL|function|hilse_match
r_static
r_int
id|hilse_match
c_func
(paren
id|hil_mlc
op_star
id|mlc
comma
r_int
id|unused
)paren
(brace
r_int
id|rc
suffix:semicolon
id|rc
op_assign
id|hil_mlc_match_di_scratch
c_func
(paren
id|mlc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
(brace
id|rc
op_assign
id|hil_mlc_find_free_di
c_func
(paren
id|mlc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_goto
id|err
suffix:semicolon
macro_line|#ifdef HIL_MLC_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
id|PREFIX
l_string|&quot;new in slot %i&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
macro_line|#endif
id|hil_mlc_copy_di_scratch
c_func
(paren
id|mlc
comma
id|rc
)paren
suffix:semicolon
id|mlc-&gt;di_map
(braket
id|mlc-&gt;ddi
)braket
op_assign
id|rc
suffix:semicolon
id|mlc-&gt;serio_map
(braket
id|rc
)braket
dot
id|di_revmap
op_assign
id|mlc-&gt;ddi
suffix:semicolon
id|hil_mlc_clean_serio_map
c_func
(paren
id|mlc
)paren
suffix:semicolon
id|serio_rescan
c_func
(paren
id|mlc-&gt;serio
(braket
id|rc
)braket
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|mlc-&gt;di_map
(braket
id|mlc-&gt;ddi
)braket
op_assign
id|rc
suffix:semicolon
macro_line|#ifdef HIL_MLC_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
id|PREFIX
l_string|&quot;same in slot %i&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
macro_line|#endif
id|mlc-&gt;serio_map
(braket
id|rc
)braket
dot
id|di_revmap
op_assign
id|mlc-&gt;ddi
suffix:semicolon
id|hil_mlc_clean_serio_map
c_func
(paren
id|mlc
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
id|PREFIX
l_string|&quot;Residual device slots exhausted, close some serios!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* An LCV used to prevent runaway loops, forces 5 second sleep when reset. */
DECL|function|hilse_init_lcv
r_static
r_int
id|hilse_init_lcv
c_func
(paren
id|hil_mlc
op_star
id|mlc
comma
r_int
id|unused
)paren
(brace
r_struct
id|timeval
id|tv
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
id|tv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mlc-&gt;lcv
op_eq
l_int|0
)paren
(brace
r_goto
id|restart
suffix:semicolon
)brace
multiline_comment|/* First init, no need to dally */
r_if
c_cond
(paren
id|tv.tv_sec
op_minus
id|mlc-&gt;lcv_tv.tv_sec
OL
l_int|5
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|restart
suffix:colon
id|mlc-&gt;lcv_tv
op_assign
id|tv
suffix:semicolon
id|mlc-&gt;lcv
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|hilse_inc_lcv
r_static
r_int
id|hilse_inc_lcv
c_func
(paren
id|hil_mlc
op_star
id|mlc
comma
r_int
id|lim
)paren
(brace
r_if
c_cond
(paren
id|mlc-&gt;lcv
op_increment
op_ge
id|lim
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if 0
r_static
r_int
id|hilse_set_lcv
c_func
(paren
id|hil_mlc
op_star
id|mlc
comma
r_int
id|val
)paren
(brace
id|mlc-&gt;lcv
op_assign
id|val
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Management of the discovered device index (zero based, -1 means no devs) */
DECL|function|hilse_set_ddi
r_static
r_int
id|hilse_set_ddi
c_func
(paren
id|hil_mlc
op_star
id|mlc
comma
r_int
id|val
)paren
(brace
id|mlc-&gt;ddi
op_assign
id|val
suffix:semicolon
id|hil_mlc_clear_di_map
c_func
(paren
id|mlc
comma
id|val
op_plus
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|hilse_dec_ddi
r_static
r_int
id|hilse_dec_ddi
c_func
(paren
id|hil_mlc
op_star
id|mlc
comma
r_int
id|unused
)paren
(brace
id|mlc-&gt;ddi
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|mlc-&gt;ddi
op_le
op_minus
l_int|1
)paren
(brace
id|mlc-&gt;ddi
op_assign
op_minus
l_int|1
suffix:semicolon
id|hil_mlc_clear_di_map
c_func
(paren
id|mlc
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|hil_mlc_clear_di_map
c_func
(paren
id|mlc
comma
id|mlc-&gt;ddi
op_plus
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|hilse_inc_ddi
r_static
r_int
id|hilse_inc_ddi
c_func
(paren
id|hil_mlc
op_star
id|mlc
comma
r_int
id|unused
)paren
(brace
r_if
c_cond
(paren
id|mlc-&gt;ddi
op_ge
l_int|6
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|mlc-&gt;ddi
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|hilse_take_idd
r_static
r_int
id|hilse_take_idd
c_func
(paren
id|hil_mlc
op_star
id|mlc
comma
r_int
id|unused
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Help the state engine: &n;&t; * Is this a real IDD response or just an echo? &n;&t; *&n;&t; * Real IDD response does not start with a command. &n;&t; */
r_if
c_cond
(paren
id|mlc-&gt;ipacket
(braket
l_int|0
)braket
op_amp
id|HIL_PKT_CMD
)paren
r_goto
id|bail
suffix:semicolon
multiline_comment|/* Should have the command echoed further down. */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|mlc-&gt;ipacket
(braket
id|i
)braket
op_amp
id|HIL_PKT_ADDR_MASK
)paren
op_eq
(paren
id|mlc-&gt;ipacket
(braket
l_int|0
)braket
op_amp
id|HIL_PKT_ADDR_MASK
)paren
)paren
op_logical_and
(paren
id|mlc-&gt;ipacket
(braket
id|i
)braket
op_amp
id|HIL_PKT_CMD
)paren
op_logical_and
(paren
(paren
id|mlc-&gt;ipacket
(braket
id|i
)braket
op_amp
id|HIL_PKT_DATA_MASK
)paren
op_eq
id|HIL_CMD_IDD
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OG
l_int|15
)paren
r_goto
id|bail
suffix:semicolon
multiline_comment|/* And the rest of the packets should still be clear. */
r_while
c_loop
(paren
op_increment
id|i
OL
l_int|16
)paren
(brace
r_if
c_cond
(paren
id|mlc-&gt;ipacket
(braket
id|i
)braket
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
l_int|16
)paren
r_goto
id|bail
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mlc-&gt;di_scratch.idd
(braket
id|i
)braket
op_assign
id|mlc-&gt;ipacket
(braket
id|i
)braket
op_amp
id|HIL_PKT_DATA_MASK
suffix:semicolon
)brace
multiline_comment|/* Next step is to see if RSC supported */
r_if
c_cond
(paren
id|mlc-&gt;di_scratch.idd
(braket
l_int|1
)braket
op_amp
id|HIL_IDD_HEADER_RSC
)paren
r_return
id|HILSEN_NEXT
suffix:semicolon
r_if
c_cond
(paren
id|mlc-&gt;di_scratch.idd
(braket
l_int|1
)braket
op_amp
id|HIL_IDD_HEADER_EXD
)paren
r_return
id|HILSEN_DOWN
op_or
l_int|4
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|bail
suffix:colon
id|mlc-&gt;ddi
op_decrement
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* This should send us off to ACF */
)brace
DECL|function|hilse_take_rsc
r_static
r_int
id|hilse_take_rsc
c_func
(paren
id|hil_mlc
op_star
id|mlc
comma
r_int
id|unused
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mlc-&gt;di_scratch.rsc
(braket
id|i
)braket
op_assign
id|mlc-&gt;ipacket
(braket
id|i
)braket
op_amp
id|HIL_PKT_DATA_MASK
suffix:semicolon
)brace
multiline_comment|/* Next step is to see if EXD supported (IDD has already been read) */
r_if
c_cond
(paren
id|mlc-&gt;di_scratch.idd
(braket
l_int|1
)braket
op_amp
id|HIL_IDD_HEADER_EXD
)paren
r_return
id|HILSEN_NEXT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|hilse_take_exd
r_static
r_int
id|hilse_take_exd
c_func
(paren
id|hil_mlc
op_star
id|mlc
comma
r_int
id|unused
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mlc-&gt;di_scratch.exd
(braket
id|i
)braket
op_assign
id|mlc-&gt;ipacket
(braket
id|i
)braket
op_amp
id|HIL_PKT_DATA_MASK
suffix:semicolon
)brace
multiline_comment|/* Next step is to see if RNM supported. */
r_if
c_cond
(paren
id|mlc-&gt;di_scratch.exd
(braket
l_int|0
)braket
op_amp
id|HIL_EXD_HEADER_RNM
)paren
r_return
id|HILSEN_NEXT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|hilse_take_rnm
r_static
r_int
id|hilse_take_rnm
c_func
(paren
id|hil_mlc
op_star
id|mlc
comma
r_int
id|unused
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mlc-&gt;di_scratch.rnm
(braket
id|i
)braket
op_assign
id|mlc-&gt;ipacket
(braket
id|i
)braket
op_amp
id|HIL_PKT_DATA_MASK
suffix:semicolon
)brace
r_do
(brace
r_char
id|nam
(braket
l_int|17
)braket
suffix:semicolon
id|snprintf
c_func
(paren
id|nam
comma
l_int|16
comma
l_string|&quot;%s&quot;
comma
id|mlc-&gt;di_scratch.rnm
)paren
suffix:semicolon
id|nam
(braket
l_int|16
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|PREFIX
l_string|&quot;Device name gotten: %s&bslash;n&quot;
comma
id|nam
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|hilse_operate
r_static
r_int
id|hilse_operate
c_func
(paren
id|hil_mlc
op_star
id|mlc
comma
r_int
id|repoll
)paren
(brace
r_if
c_cond
(paren
id|mlc-&gt;opercnt
op_eq
l_int|0
)paren
id|hil_mlcs_probe
op_assign
l_int|0
suffix:semicolon
id|mlc-&gt;opercnt
op_assign
l_int|1
suffix:semicolon
id|hil_mlc_send_polls
c_func
(paren
id|mlc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hil_mlcs_probe
)paren
r_return
l_int|0
suffix:semicolon
id|hil_mlcs_probe
op_assign
l_int|0
suffix:semicolon
id|mlc-&gt;opercnt
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|macro|FUNC
mdefine_line|#define FUNC(funct, funct_arg, zero_rc, neg_rc, pos_rc) &bslash;&n;{ HILSE_FUNC,&t;&t;{ func: &amp;funct }, funct_arg, zero_rc, neg_rc, pos_rc },
DECL|macro|OUT
mdefine_line|#define OUT(pack) &bslash;&n;{ HILSE_OUT,&t;&t;{ packet: pack }, 0, HILSEN_NEXT, HILSEN_DOZE, 0 },
DECL|macro|CTS
mdefine_line|#define CTS &bslash;&n;{ HILSE_CTS,&t;&t;{ packet: 0    }, 0, HILSEN_NEXT | HILSEN_SCHED | HILSEN_BREAK, HILSEN_DOZE, 0 },
DECL|macro|EXPECT
mdefine_line|#define EXPECT(comp, to, got, got_wrong, timed_out) &bslash;&n;{ HILSE_EXPECT,&t;&t;{ packet: comp }, to, got, got_wrong, timed_out },
DECL|macro|EXPECT_LAST
mdefine_line|#define EXPECT_LAST(comp, to, got, got_wrong, timed_out) &bslash;&n;{ HILSE_EXPECT_LAST,&t;{ packet: comp }, to, got, got_wrong, timed_out },
DECL|macro|EXPECT_DISC
mdefine_line|#define EXPECT_DISC(comp, to, got, got_wrong, timed_out) &bslash;&n;{ HILSE_EXPECT_DISC,&t;{ packet: comp }, to, got, got_wrong, timed_out },
DECL|macro|IN
mdefine_line|#define IN(to, got, got_error, timed_out) &bslash;&n;{ HILSE_IN,&t;&t;{ packet: 0    }, to, got, got_error, timed_out },
DECL|macro|OUT_DISC
mdefine_line|#define OUT_DISC(pack) &bslash;&n;{ HILSE_OUT_DISC,&t;{ packet: pack }, 0, 0, 0, 0 },
DECL|macro|OUT_LAST
mdefine_line|#define OUT_LAST(pack) &bslash;&n;{ HILSE_OUT_LAST,&t;{ packet: pack }, 0, 0, 0, 0 },
DECL|variable|hil_mlc_se
r_struct
id|hilse_node
id|hil_mlc_se
(braket
id|HILSEN_END
)braket
op_assign
(brace
multiline_comment|/* 0  HILSEN_START */
id|FUNC
c_func
(paren
id|hilse_init_lcv
comma
l_int|0
comma
id|HILSEN_NEXT
comma
id|HILSEN_SLEEP
comma
l_int|0
)paren
multiline_comment|/* 1  HILSEN_RESTART */
id|FUNC
c_func
(paren
id|hilse_inc_lcv
comma
l_int|10
comma
id|HILSEN_NEXT
comma
id|HILSEN_START
comma
l_int|0
)paren
id|OUT
c_func
(paren
id|HIL_CTRL_ONLY
)paren
multiline_comment|/* Disable APE */
id|CTS
DECL|macro|TEST_PACKET
mdefine_line|#define TEST_PACKET(x) &bslash;&n;(HIL_PKT_CMD | (x &lt;&lt; HIL_PKT_ADDR_SHIFT) | x &lt;&lt; 4 | x)
id|OUT
c_func
(paren
id|HIL_DO_ALTER_CTRL
op_or
id|HIL_CTRL_TEST
op_or
id|TEST_PACKET
c_func
(paren
l_int|0x5
)paren
)paren
id|EXPECT
c_func
(paren
id|HIL_ERR_INT
op_or
id|TEST_PACKET
c_func
(paren
l_int|0x5
)paren
comma
l_int|2000
comma
id|HILSEN_NEXT
comma
id|HILSEN_RESTART
comma
id|HILSEN_RESTART
)paren
id|OUT
c_func
(paren
id|HIL_DO_ALTER_CTRL
op_or
id|HIL_CTRL_TEST
op_or
id|TEST_PACKET
c_func
(paren
l_int|0xa
)paren
)paren
id|EXPECT
c_func
(paren
id|HIL_ERR_INT
op_or
id|TEST_PACKET
c_func
(paren
l_int|0xa
)paren
comma
l_int|2000
comma
id|HILSEN_NEXT
comma
id|HILSEN_RESTART
comma
id|HILSEN_RESTART
)paren
id|OUT
c_func
(paren
id|HIL_CTRL_ONLY
op_or
l_int|0
)paren
multiline_comment|/* Disable test mode */
multiline_comment|/* 9  HILSEN_DHR */
id|FUNC
c_func
(paren
id|hilse_init_lcv
comma
l_int|0
comma
id|HILSEN_NEXT
comma
id|HILSEN_SLEEP
comma
l_int|0
)paren
multiline_comment|/* 10 HILSEN_DHR2 */
id|FUNC
c_func
(paren
id|hilse_inc_lcv
comma
l_int|10
comma
id|HILSEN_NEXT
comma
id|HILSEN_START
comma
l_int|0
)paren
id|FUNC
c_func
(paren
id|hilse_set_ddi
comma
op_minus
l_int|1
comma
id|HILSEN_NEXT
comma
l_int|0
comma
l_int|0
)paren
id|OUT
c_func
(paren
id|HIL_PKT_CMD
op_or
id|HIL_CMD_DHR
)paren
id|IN
c_func
(paren
l_int|300000
comma
id|HILSEN_DHR2
comma
id|HILSEN_DHR2
comma
id|HILSEN_NEXT
)paren
multiline_comment|/* 14 HILSEN_IFC */
id|OUT
c_func
(paren
id|HIL_PKT_CMD
op_or
id|HIL_CMD_IFC
)paren
id|EXPECT
c_func
(paren
id|HIL_PKT_CMD
op_or
id|HIL_CMD_IFC
op_or
id|HIL_ERR_INT
comma
l_int|20000
comma
id|HILSEN_DISC
comma
id|HILSEN_DHR2
comma
id|HILSEN_NEXT
)paren
multiline_comment|/* If devices are there, they weren&squot;t in PUP or other loopback mode.&n;&t; * We&squot;re more concerned at this point with restoring operation&n;&t; * to devices than discovering new ones, so we try to salvage&n;&t; * the loop configuration by closing off the loop.&n;&t; */
multiline_comment|/* 16 HILSEN_HEAL0 */
id|FUNC
c_func
(paren
id|hilse_dec_ddi
comma
l_int|0
comma
id|HILSEN_NEXT
comma
id|HILSEN_ACF
comma
l_int|0
)paren
id|FUNC
c_func
(paren
id|hilse_inc_ddi
comma
l_int|0
comma
id|HILSEN_NEXT
comma
l_int|0
comma
l_int|0
)paren
multiline_comment|/* 18 HILSEN_HEAL */
id|OUT_LAST
c_func
(paren
id|HIL_CMD_ELB
)paren
id|EXPECT_LAST
c_func
(paren
id|HIL_CMD_ELB
op_or
id|HIL_ERR_INT
comma
l_int|20000
comma
id|HILSEN_REPOLL
comma
id|HILSEN_DSR
comma
id|HILSEN_NEXT
)paren
id|FUNC
c_func
(paren
id|hilse_dec_ddi
comma
l_int|0
comma
id|HILSEN_HEAL
comma
id|HILSEN_NEXT
comma
l_int|0
)paren
multiline_comment|/* 21 HILSEN_ACF */
id|FUNC
c_func
(paren
id|hilse_init_lcv
comma
l_int|0
comma
id|HILSEN_NEXT
comma
id|HILSEN_DOZE
comma
l_int|0
)paren
multiline_comment|/* 22 HILSEN_ACF2 */
id|FUNC
c_func
(paren
id|hilse_inc_lcv
comma
l_int|10
comma
id|HILSEN_NEXT
comma
id|HILSEN_START
comma
l_int|0
)paren
id|OUT
c_func
(paren
id|HIL_PKT_CMD
op_or
id|HIL_CMD_ACF
op_or
l_int|1
)paren
id|IN
c_func
(paren
l_int|20000
comma
id|HILSEN_NEXT
comma
id|HILSEN_DSR
comma
id|HILSEN_NEXT
)paren
multiline_comment|/* 25 HILSEN_DISC0 */
id|OUT_DISC
c_func
(paren
id|HIL_PKT_CMD
op_or
id|HIL_CMD_ELB
)paren
id|EXPECT_DISC
c_func
(paren
id|HIL_PKT_CMD
op_or
id|HIL_CMD_ELB
op_or
id|HIL_ERR_INT
comma
l_int|20000
comma
id|HILSEN_NEXT
comma
id|HILSEN_DSR
comma
id|HILSEN_DSR
)paren
multiline_comment|/* Only enter here if response just received */
multiline_comment|/* 27 HILSEN_DISC */
id|OUT_DISC
c_func
(paren
id|HIL_PKT_CMD
op_or
id|HIL_CMD_IDD
)paren
id|EXPECT_DISC
c_func
(paren
id|HIL_PKT_CMD
op_or
id|HIL_CMD_IDD
op_or
id|HIL_ERR_INT
comma
l_int|20000
comma
id|HILSEN_NEXT
comma
id|HILSEN_DSR
comma
id|HILSEN_START
)paren
id|FUNC
c_func
(paren
id|hilse_inc_ddi
comma
l_int|0
comma
id|HILSEN_NEXT
comma
id|HILSEN_START
comma
l_int|0
)paren
id|FUNC
c_func
(paren
id|hilse_take_idd
comma
l_int|0
comma
id|HILSEN_MATCH
comma
id|HILSEN_IFCACF
comma
id|HILSEN_FOLLOW
)paren
id|OUT_LAST
c_func
(paren
id|HIL_PKT_CMD
op_or
id|HIL_CMD_RSC
)paren
id|EXPECT_LAST
c_func
(paren
id|HIL_PKT_CMD
op_or
id|HIL_CMD_RSC
op_or
id|HIL_ERR_INT
comma
l_int|30000
comma
id|HILSEN_NEXT
comma
id|HILSEN_DSR
comma
id|HILSEN_DSR
)paren
id|FUNC
c_func
(paren
id|hilse_take_rsc
comma
l_int|0
comma
id|HILSEN_MATCH
comma
l_int|0
comma
id|HILSEN_FOLLOW
)paren
id|OUT_LAST
c_func
(paren
id|HIL_PKT_CMD
op_or
id|HIL_CMD_EXD
)paren
id|EXPECT_LAST
c_func
(paren
id|HIL_PKT_CMD
op_or
id|HIL_CMD_EXD
op_or
id|HIL_ERR_INT
comma
l_int|30000
comma
id|HILSEN_NEXT
comma
id|HILSEN_DSR
comma
id|HILSEN_DSR
)paren
id|FUNC
c_func
(paren
id|hilse_take_exd
comma
l_int|0
comma
id|HILSEN_MATCH
comma
l_int|0
comma
id|HILSEN_FOLLOW
)paren
id|OUT_LAST
c_func
(paren
id|HIL_PKT_CMD
op_or
id|HIL_CMD_RNM
)paren
id|EXPECT_LAST
c_func
(paren
id|HIL_PKT_CMD
op_or
id|HIL_CMD_RNM
op_or
id|HIL_ERR_INT
comma
l_int|30000
comma
id|HILSEN_NEXT
comma
id|HILSEN_DSR
comma
id|HILSEN_DSR
)paren
id|FUNC
c_func
(paren
id|hilse_take_rnm
comma
l_int|0
comma
id|HILSEN_MATCH
comma
l_int|0
comma
l_int|0
)paren
multiline_comment|/* 40 HILSEN_MATCH */
id|FUNC
c_func
(paren
id|hilse_match
comma
l_int|0
comma
id|HILSEN_NEXT
comma
id|HILSEN_NEXT
comma
multiline_comment|/* TODO */
l_int|0
)paren
multiline_comment|/* 41 HILSEN_OPERATE */
id|OUT
c_func
(paren
id|HIL_PKT_CMD
op_or
id|HIL_CMD_POL
)paren
id|EXPECT
c_func
(paren
id|HIL_PKT_CMD
op_or
id|HIL_CMD_POL
op_or
id|HIL_ERR_INT
comma
l_int|20000
comma
id|HILSEN_NEXT
comma
id|HILSEN_DSR
comma
id|HILSEN_NEXT
)paren
id|FUNC
c_func
(paren
id|hilse_operate
comma
l_int|0
comma
id|HILSEN_OPERATE
comma
id|HILSEN_IFC
comma
id|HILSEN_NEXT
)paren
multiline_comment|/* 44 HILSEN_PROBE */
id|OUT_LAST
c_func
(paren
id|HIL_PKT_CMD
op_or
id|HIL_CMD_EPT
)paren
id|IN
c_func
(paren
l_int|10000
comma
id|HILSEN_DISC
comma
id|HILSEN_DSR
comma
id|HILSEN_NEXT
)paren
id|OUT_DISC
c_func
(paren
id|HIL_PKT_CMD
op_or
id|HIL_CMD_ELB
)paren
id|IN
c_func
(paren
l_int|10000
comma
id|HILSEN_DISC
comma
id|HILSEN_DSR
comma
id|HILSEN_NEXT
)paren
id|OUT
c_func
(paren
id|HIL_PKT_CMD
op_or
id|HIL_CMD_ACF
op_or
l_int|1
)paren
id|IN
c_func
(paren
l_int|10000
comma
id|HILSEN_DISC0
comma
id|HILSEN_DSR
comma
id|HILSEN_NEXT
)paren
id|OUT_LAST
c_func
(paren
id|HIL_PKT_CMD
op_or
id|HIL_CMD_ELB
)paren
id|IN
c_func
(paren
l_int|10000
comma
id|HILSEN_OPERATE
comma
id|HILSEN_DSR
comma
id|HILSEN_DSR
)paren
multiline_comment|/* 52 HILSEN_DSR */
id|FUNC
c_func
(paren
id|hilse_set_ddi
comma
op_minus
l_int|1
comma
id|HILSEN_NEXT
comma
l_int|0
comma
l_int|0
)paren
id|OUT
c_func
(paren
id|HIL_PKT_CMD
op_or
id|HIL_CMD_DSR
)paren
id|IN
c_func
(paren
l_int|20000
comma
id|HILSEN_DHR
comma
id|HILSEN_DHR
comma
id|HILSEN_IFC
)paren
multiline_comment|/* 55 HILSEN_REPOLL */
id|OUT
c_func
(paren
id|HIL_PKT_CMD
op_or
id|HIL_CMD_RPL
)paren
id|EXPECT
c_func
(paren
id|HIL_PKT_CMD
op_or
id|HIL_CMD_RPL
op_or
id|HIL_ERR_INT
comma
l_int|20000
comma
id|HILSEN_NEXT
comma
id|HILSEN_DSR
comma
id|HILSEN_NEXT
)paren
id|FUNC
c_func
(paren
id|hilse_operate
comma
l_int|1
comma
id|HILSEN_OPERATE
comma
id|HILSEN_IFC
comma
id|HILSEN_PROBE
)paren
multiline_comment|/* 58 HILSEN_IFCACF */
id|OUT
c_func
(paren
id|HIL_PKT_CMD
op_or
id|HIL_CMD_IFC
)paren
id|EXPECT
c_func
(paren
id|HIL_PKT_CMD
op_or
id|HIL_CMD_IFC
op_or
id|HIL_ERR_INT
comma
l_int|20000
comma
id|HILSEN_ACF2
comma
id|HILSEN_DHR2
comma
id|HILSEN_HEAL
)paren
multiline_comment|/* 60 HILSEN_END */
)brace
suffix:semicolon
DECL|function|hilse_setup_input
r_static
r_inline
r_void
id|hilse_setup_input
c_func
(paren
id|hil_mlc
op_star
id|mlc
comma
r_struct
id|hilse_node
op_star
id|node
)paren
(brace
r_switch
c_cond
(paren
id|node-&gt;act
)paren
(brace
r_case
id|HILSE_EXPECT_DISC
suffix:colon
id|mlc-&gt;imatch
op_assign
id|node-&gt;object.packet
suffix:semicolon
id|mlc-&gt;imatch
op_or_assign
(paren
(paren
id|mlc-&gt;ddi
op_plus
l_int|2
)paren
op_lshift
id|HIL_PKT_ADDR_SHIFT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HILSE_EXPECT_LAST
suffix:colon
id|mlc-&gt;imatch
op_assign
id|node-&gt;object.packet
suffix:semicolon
id|mlc-&gt;imatch
op_or_assign
(paren
(paren
id|mlc-&gt;ddi
op_plus
l_int|1
)paren
op_lshift
id|HIL_PKT_ADDR_SHIFT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HILSE_EXPECT
suffix:colon
id|mlc-&gt;imatch
op_assign
id|node-&gt;object.packet
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HILSE_IN
suffix:colon
id|mlc-&gt;imatch
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|mlc-&gt;istarted
op_assign
l_int|1
suffix:semicolon
id|mlc-&gt;intimeout
op_assign
id|node-&gt;arg
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
(paren
id|mlc-&gt;instart
)paren
)paren
suffix:semicolon
id|mlc-&gt;icount
op_assign
l_int|15
suffix:semicolon
id|memset
c_func
(paren
id|mlc-&gt;ipacket
comma
l_int|0
comma
l_int|16
op_star
r_sizeof
(paren
id|hil_packet
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|down_trylock
c_func
(paren
op_amp
(paren
id|mlc-&gt;isem
)paren
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef HIL_MLC_DEBUG
DECL|variable|doze
r_static
r_int
id|doze
op_assign
l_int|0
suffix:semicolon
DECL|variable|seidx
r_static
r_int
id|seidx
suffix:semicolon
multiline_comment|/* For debug */
DECL|variable|kick
r_static
r_int
id|kick
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
DECL|function|hilse_donode
r_static
r_int
id|hilse_donode
(paren
id|hil_mlc
op_star
id|mlc
)paren
(brace
r_struct
id|hilse_node
op_star
id|node
suffix:semicolon
r_int
id|nextidx
op_assign
l_int|0
suffix:semicolon
r_int
id|sched_long
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef HIL_MLC_DEBUG
r_if
c_cond
(paren
id|mlc-&gt;seidx
op_logical_and
(paren
id|mlc-&gt;seidx
op_ne
id|seidx
)paren
op_logical_and
id|mlc-&gt;seidx
op_ne
l_int|41
op_logical_and
id|mlc-&gt;seidx
op_ne
l_int|42
op_logical_and
id|mlc-&gt;seidx
op_ne
l_int|43
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
id|PREFIX
l_string|&quot;z%i &bslash;n%s {%i}&quot;
comma
id|doze
comma
id|kick
ques
c_cond
l_string|&quot;K&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|mlc-&gt;seidx
)paren
suffix:semicolon
id|doze
op_assign
l_int|0
suffix:semicolon
)brace
id|kick
op_assign
l_int|0
suffix:semicolon
id|seidx
op_assign
id|mlc-&gt;seidx
suffix:semicolon
macro_line|#endif
id|node
op_assign
id|hil_mlc_se
op_plus
id|mlc-&gt;seidx
suffix:semicolon
r_switch
c_cond
(paren
id|node-&gt;act
)paren
(brace
r_int
id|rc
suffix:semicolon
id|hil_packet
id|pack
suffix:semicolon
r_case
id|HILSE_FUNC
suffix:colon
r_if
c_cond
(paren
id|node-&gt;object.func
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|rc
op_assign
id|node-&gt;object
dot
id|func
c_func
(paren
id|mlc
comma
id|node-&gt;arg
)paren
suffix:semicolon
id|nextidx
op_assign
(paren
id|rc
OG
l_int|0
)paren
ques
c_cond
id|node-&gt;ugly
suffix:colon
(paren
(paren
id|rc
OL
l_int|0
)paren
ques
c_cond
id|node-&gt;bad
suffix:colon
id|node-&gt;good
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nextidx
op_eq
id|HILSEN_FOLLOW
)paren
id|nextidx
op_assign
id|rc
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HILSE_EXPECT_LAST
suffix:colon
r_case
id|HILSE_EXPECT_DISC
suffix:colon
r_case
id|HILSE_EXPECT
suffix:colon
r_case
id|HILSE_IN
suffix:colon
multiline_comment|/* Already set up from previous HILSE_OUT_* */
id|write_lock_irqsave
c_func
(paren
op_amp
(paren
id|mlc-&gt;lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|rc
op_assign
id|mlc
op_member_access_from_pointer
id|in
c_func
(paren
id|mlc
comma
id|node-&gt;arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|2
)paren
(brace
id|nextidx
op_assign
id|HILSEN_DOZE
suffix:semicolon
id|sched_long
op_assign
l_int|1
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|mlc-&gt;lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rc
op_eq
l_int|1
)paren
id|nextidx
op_assign
id|node-&gt;ugly
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
id|nextidx
op_assign
id|node-&gt;good
suffix:semicolon
r_else
id|nextidx
op_assign
id|node-&gt;bad
suffix:semicolon
id|mlc-&gt;istarted
op_assign
l_int|0
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|mlc-&gt;lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HILSE_OUT_LAST
suffix:colon
id|write_lock_irqsave
c_func
(paren
op_amp
(paren
id|mlc-&gt;lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|pack
op_assign
id|node-&gt;object.packet
suffix:semicolon
id|pack
op_or_assign
(paren
(paren
id|mlc-&gt;ddi
op_plus
l_int|1
)paren
op_lshift
id|HIL_PKT_ADDR_SHIFT
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
r_case
id|HILSE_OUT_DISC
suffix:colon
id|write_lock_irqsave
c_func
(paren
op_amp
(paren
id|mlc-&gt;lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|pack
op_assign
id|node-&gt;object.packet
suffix:semicolon
id|pack
op_or_assign
(paren
(paren
id|mlc-&gt;ddi
op_plus
l_int|2
)paren
op_lshift
id|HIL_PKT_ADDR_SHIFT
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
r_case
id|HILSE_OUT
suffix:colon
id|write_lock_irqsave
c_func
(paren
op_amp
(paren
id|mlc-&gt;lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|pack
op_assign
id|node-&gt;object.packet
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|mlc-&gt;istarted
)paren
r_goto
id|out2
suffix:semicolon
multiline_comment|/* Prepare to receive input */
r_if
c_cond
(paren
(paren
id|node
op_plus
l_int|1
)paren
op_member_access_from_pointer
id|act
op_amp
id|HILSE_IN
)paren
id|hilse_setup_input
c_func
(paren
id|mlc
comma
id|node
op_plus
l_int|1
)paren
suffix:semicolon
id|out2
suffix:colon
id|write_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|mlc-&gt;lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|down_trylock
c_func
(paren
op_amp
id|mlc-&gt;osem
)paren
)paren
(brace
id|nextidx
op_assign
id|HILSEN_DOZE
suffix:semicolon
r_break
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|mlc-&gt;osem
)paren
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
(paren
id|mlc-&gt;lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|mlc-&gt;ostarted
)paren
)paren
(brace
id|mlc-&gt;ostarted
op_assign
l_int|1
suffix:semicolon
id|mlc-&gt;opacket
op_assign
id|pack
suffix:semicolon
id|mlc
op_member_access_from_pointer
id|out
c_func
(paren
id|mlc
)paren
suffix:semicolon
id|nextidx
op_assign
id|HILSEN_DOZE
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|mlc-&gt;lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|mlc-&gt;ostarted
op_assign
l_int|0
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
(paren
id|mlc-&gt;instart
)paren
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|mlc-&gt;lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|nextidx
op_assign
id|HILSEN_NEXT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HILSE_CTS
suffix:colon
id|nextidx
op_assign
id|mlc
op_member_access_from_pointer
id|cts
c_func
(paren
id|mlc
)paren
ques
c_cond
id|node-&gt;bad
suffix:colon
id|node-&gt;good
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|nextidx
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef HIL_MLC_DEBUG
r_if
c_cond
(paren
id|nextidx
op_eq
id|HILSEN_DOZE
)paren
id|doze
op_increment
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
id|nextidx
op_amp
id|HILSEN_SCHED
)paren
(brace
r_struct
id|timeval
id|tv
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sched_long
)paren
r_goto
id|sched
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
id|tv
)paren
suffix:semicolon
id|tv.tv_usec
op_add_assign
l_int|1000000
op_star
(paren
id|tv.tv_sec
op_minus
id|mlc-&gt;instart.tv_sec
)paren
suffix:semicolon
id|tv.tv_usec
op_sub_assign
id|mlc-&gt;instart.tv_usec
suffix:semicolon
r_if
c_cond
(paren
id|tv.tv_usec
op_ge
id|mlc-&gt;intimeout
)paren
r_goto
id|sched
suffix:semicolon
id|tv.tv_usec
op_assign
(paren
id|mlc-&gt;intimeout
op_minus
id|tv.tv_usec
)paren
op_star
id|HZ
op_div
l_int|1000000
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tv.tv_usec
)paren
r_goto
id|sched
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|hil_mlcs_kicker
comma
id|jiffies
op_plus
id|tv.tv_usec
)paren
suffix:semicolon
r_break
suffix:semicolon
id|sched
suffix:colon
id|tasklet_schedule
c_func
(paren
op_amp
id|hil_mlcs_tasklet
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nextidx
op_amp
id|HILSEN_DOWN
)paren
id|mlc-&gt;seidx
op_add_assign
id|nextidx
op_amp
id|HILSEN_MASK
suffix:semicolon
r_else
r_if
c_cond
(paren
id|nextidx
op_amp
id|HILSEN_UP
)paren
id|mlc-&gt;seidx
op_sub_assign
id|nextidx
op_amp
id|HILSEN_MASK
suffix:semicolon
r_else
id|mlc-&gt;seidx
op_assign
id|nextidx
op_amp
id|HILSEN_MASK
suffix:semicolon
r_if
c_cond
(paren
id|nextidx
op_amp
id|HILSEN_BREAK
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/******************** tasklet context functions **************************/
DECL|function|hil_mlcs_process
r_static
r_void
id|hil_mlcs_process
c_func
(paren
r_int
r_int
id|unused
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|hil_mlcs_lock
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|tmp
comma
op_amp
id|hil_mlcs
)paren
(brace
r_struct
id|hil_mlc
op_star
id|mlc
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
id|hil_mlc
comma
id|list
)paren
suffix:semicolon
r_while
c_loop
(paren
id|hilse_donode
c_func
(paren
id|mlc
)paren
op_eq
l_int|0
)paren
(brace
macro_line|#ifdef HIL_MLC_DEBUG
r_if
c_cond
(paren
id|mlc-&gt;seidx
op_ne
l_int|41
op_logical_and
id|mlc-&gt;seidx
op_ne
l_int|42
op_logical_and
id|mlc-&gt;seidx
op_ne
l_int|43
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
id|PREFIX
l_string|&quot; + &quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|hil_mlcs_lock
)paren
suffix:semicolon
)brace
multiline_comment|/************************* Keepalive timer task *********************/
DECL|function|hil_mlcs_timer
r_void
id|hil_mlcs_timer
(paren
r_int
r_int
id|data
)paren
(brace
id|hil_mlcs_probe
op_assign
l_int|1
suffix:semicolon
id|tasklet_schedule
c_func
(paren
op_amp
id|hil_mlcs_tasklet
)paren
suffix:semicolon
multiline_comment|/* Re-insert the periodic task. */
r_if
c_cond
(paren
op_logical_neg
id|timer_pending
c_func
(paren
op_amp
id|hil_mlcs_kicker
)paren
)paren
id|mod_timer
c_func
(paren
op_amp
id|hil_mlcs_kicker
comma
id|jiffies
op_plus
id|HZ
)paren
suffix:semicolon
)brace
multiline_comment|/******************** user/kernel context functions **********************/
DECL|function|hil_mlc_serio_write
r_static
r_int
id|hil_mlc_serio_write
c_func
(paren
r_struct
id|serio
op_star
id|serio
comma
r_int
r_char
id|c
)paren
(brace
r_struct
id|hil_mlc_serio_map
op_star
id|map
suffix:semicolon
r_struct
id|hil_mlc
op_star
id|mlc
suffix:semicolon
r_struct
id|serio_driver
op_star
id|drv
suffix:semicolon
r_uint8
op_star
id|idx
comma
op_star
id|last
suffix:semicolon
id|map
op_assign
id|serio-&gt;port_data
suffix:semicolon
r_if
c_cond
(paren
id|map
op_eq
l_int|NULL
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|mlc
op_assign
id|map-&gt;mlc
suffix:semicolon
r_if
c_cond
(paren
id|mlc
op_eq
l_int|NULL
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|mlc-&gt;serio_opacket
(braket
id|map-&gt;didx
)braket
op_or_assign
(paren
(paren
id|hil_packet
)paren
id|c
)paren
op_lshift
(paren
l_int|8
op_star
(paren
l_int|3
op_minus
id|mlc-&gt;serio_oidx
(braket
id|map-&gt;didx
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mlc-&gt;serio_oidx
(braket
id|map-&gt;didx
)braket
op_ge
l_int|3
)paren
(brace
multiline_comment|/* for now only commands */
r_if
c_cond
(paren
op_logical_neg
(paren
id|mlc-&gt;serio_opacket
(braket
id|map-&gt;didx
)braket
op_amp
id|HIL_PKT_CMD
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_switch
c_cond
(paren
id|mlc-&gt;serio_opacket
(braket
id|map-&gt;didx
)braket
op_amp
id|HIL_PKT_DATA_MASK
)paren
(brace
r_case
id|HIL_CMD_IDD
suffix:colon
id|idx
op_assign
id|mlc-&gt;di
(braket
id|map-&gt;didx
)braket
dot
id|idd
suffix:semicolon
r_goto
id|emu
suffix:semicolon
r_case
id|HIL_CMD_RSC
suffix:colon
id|idx
op_assign
id|mlc-&gt;di
(braket
id|map-&gt;didx
)braket
dot
id|rsc
suffix:semicolon
r_goto
id|emu
suffix:semicolon
r_case
id|HIL_CMD_EXD
suffix:colon
id|idx
op_assign
id|mlc-&gt;di
(braket
id|map-&gt;didx
)braket
dot
id|exd
suffix:semicolon
r_goto
id|emu
suffix:semicolon
r_case
id|HIL_CMD_RNM
suffix:colon
id|idx
op_assign
id|mlc-&gt;di
(braket
id|map-&gt;didx
)braket
dot
id|rnm
suffix:semicolon
r_goto
id|emu
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|mlc-&gt;serio_oidx
(braket
id|map-&gt;didx
)braket
op_assign
l_int|0
suffix:semicolon
id|mlc-&gt;serio_opacket
(braket
id|map-&gt;didx
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|mlc-&gt;serio_oidx
(braket
id|map-&gt;didx
)braket
op_increment
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
id|emu
suffix:colon
id|drv
op_assign
id|serio-&gt;drv
suffix:semicolon
r_if
c_cond
(paren
id|drv
op_eq
l_int|NULL
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|last
op_assign
id|idx
op_plus
l_int|15
suffix:semicolon
r_while
c_loop
(paren
(paren
id|last
op_ne
id|idx
)paren
op_logical_and
(paren
op_star
id|last
op_eq
l_int|0
)paren
)paren
id|last
op_decrement
suffix:semicolon
r_while
c_loop
(paren
id|idx
op_ne
id|last
)paren
(brace
id|drv
op_member_access_from_pointer
id|interrupt
c_func
(paren
id|serio
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|drv
op_member_access_from_pointer
id|interrupt
c_func
(paren
id|serio
comma
id|HIL_ERR_INT
op_rshift
l_int|16
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|drv
op_member_access_from_pointer
id|interrupt
c_func
(paren
id|serio
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|drv
op_member_access_from_pointer
id|interrupt
c_func
(paren
id|serio
comma
op_star
id|idx
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|idx
op_increment
suffix:semicolon
)brace
id|drv
op_member_access_from_pointer
id|interrupt
c_func
(paren
id|serio
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|drv
op_member_access_from_pointer
id|interrupt
c_func
(paren
id|serio
comma
id|HIL_ERR_INT
op_rshift
l_int|16
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|drv
op_member_access_from_pointer
id|interrupt
c_func
(paren
id|serio
comma
id|HIL_PKT_CMD
op_rshift
l_int|8
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|drv
op_member_access_from_pointer
id|interrupt
c_func
(paren
id|serio
comma
op_star
id|idx
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|mlc-&gt;serio_oidx
(braket
id|map-&gt;didx
)braket
op_assign
l_int|0
suffix:semicolon
id|mlc-&gt;serio_opacket
(braket
id|map-&gt;didx
)braket
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|hil_mlc_serio_open
r_static
r_int
id|hil_mlc_serio_open
c_func
(paren
r_struct
id|serio
op_star
id|serio
)paren
(brace
r_struct
id|hil_mlc_serio_map
op_star
id|map
suffix:semicolon
r_struct
id|hil_mlc
op_star
id|mlc
suffix:semicolon
r_if
c_cond
(paren
id|serio
op_member_access_from_pointer
r_private
op_ne
l_int|NULL
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|map
op_assign
id|serio-&gt;port_data
suffix:semicolon
r_if
c_cond
(paren
id|map
op_eq
l_int|NULL
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|mlc
op_assign
id|map-&gt;mlc
suffix:semicolon
r_if
c_cond
(paren
id|mlc
op_eq
l_int|NULL
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|hil_mlc_serio_close
r_static
r_void
id|hil_mlc_serio_close
c_func
(paren
r_struct
id|serio
op_star
id|serio
)paren
(brace
r_struct
id|hil_mlc_serio_map
op_star
id|map
suffix:semicolon
r_struct
id|hil_mlc
op_star
id|mlc
suffix:semicolon
id|map
op_assign
id|serio-&gt;port_data
suffix:semicolon
r_if
c_cond
(paren
id|map
op_eq
l_int|NULL
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|mlc
op_assign
id|map-&gt;mlc
suffix:semicolon
r_if
c_cond
(paren
id|mlc
op_eq
l_int|NULL
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|serio
op_member_access_from_pointer
r_private
op_assign
l_int|NULL
suffix:semicolon
id|serio-&gt;drv
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* TODO wake up interruptable */
)brace
DECL|function|hil_mlc_register
r_int
id|hil_mlc_register
c_func
(paren
id|hil_mlc
op_star
id|mlc
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|mlc
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|mlc-&gt;istarted
op_assign
l_int|0
suffix:semicolon
id|mlc-&gt;ostarted
op_assign
l_int|0
suffix:semicolon
id|rwlock_init
c_func
(paren
op_amp
id|mlc-&gt;lock
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
(paren
id|mlc-&gt;osem
)paren
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
(paren
id|mlc-&gt;isem
)paren
)paren
suffix:semicolon
id|mlc-&gt;icount
op_assign
op_minus
l_int|1
suffix:semicolon
id|mlc-&gt;imatch
op_assign
l_int|0
suffix:semicolon
id|mlc-&gt;opercnt
op_assign
l_int|0
suffix:semicolon
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
(paren
id|mlc-&gt;csem
)paren
)paren
suffix:semicolon
id|hil_mlc_clear_di_scratch
c_func
(paren
id|mlc
)paren
suffix:semicolon
id|hil_mlc_clear_di_map
c_func
(paren
id|mlc
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|HIL_MLC_DEVMEM
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|serio
op_star
id|mlc_serio
suffix:semicolon
id|hil_mlc_copy_di_scratch
c_func
(paren
id|mlc
comma
id|i
)paren
suffix:semicolon
id|mlc_serio
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|mlc_serio
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|mlc-&gt;serio
(braket
id|i
)braket
op_assign
id|mlc_serio
suffix:semicolon
id|memset
c_func
(paren
id|mlc_serio
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|mlc_serio
)paren
)paren
suffix:semicolon
id|mlc_serio-&gt;type
op_assign
id|SERIO_HIL
op_or
id|SERIO_HIL_MLC
suffix:semicolon
id|mlc_serio-&gt;write
op_assign
id|hil_mlc_serio_write
suffix:semicolon
id|mlc_serio-&gt;open
op_assign
id|hil_mlc_serio_open
suffix:semicolon
id|mlc_serio-&gt;close
op_assign
id|hil_mlc_serio_close
suffix:semicolon
id|mlc_serio-&gt;port_data
op_assign
op_amp
(paren
id|mlc-&gt;serio_map
(braket
id|i
)braket
)paren
suffix:semicolon
id|mlc-&gt;serio_map
(braket
id|i
)braket
dot
id|mlc
op_assign
id|mlc
suffix:semicolon
id|mlc-&gt;serio_map
(braket
id|i
)braket
dot
id|didx
op_assign
id|i
suffix:semicolon
id|mlc-&gt;serio_map
(braket
id|i
)braket
dot
id|di_revmap
op_assign
op_minus
l_int|1
suffix:semicolon
id|mlc-&gt;serio_opacket
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|mlc-&gt;serio_oidx
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|serio_register_port
c_func
(paren
id|mlc_serio
)paren
suffix:semicolon
)brace
id|mlc-&gt;tasklet
op_assign
op_amp
id|hil_mlcs_tasklet
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|hil_mlcs_lock
comma
id|flags
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|mlc-&gt;list
comma
op_amp
id|hil_mlcs
)paren
suffix:semicolon
id|mlc-&gt;seidx
op_assign
id|HILSEN_START
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|hil_mlcs_lock
comma
id|flags
)paren
suffix:semicolon
id|tasklet_schedule
c_func
(paren
op_amp
id|hil_mlcs_tasklet
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|hil_mlc_unregister
r_int
id|hil_mlc_unregister
c_func
(paren
id|hil_mlc
op_star
id|mlc
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|mlc
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|hil_mlcs_lock
comma
id|flags
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|tmp
comma
op_amp
id|hil_mlcs
)paren
(brace
r_if
c_cond
(paren
id|list_entry
c_func
(paren
id|tmp
comma
id|hil_mlc
comma
id|list
)paren
op_eq
id|mlc
)paren
r_goto
id|found
suffix:semicolon
)brace
multiline_comment|/* not found in list */
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|hil_mlcs_lock
comma
id|flags
)paren
suffix:semicolon
id|tasklet_schedule
c_func
(paren
op_amp
id|hil_mlcs_tasklet
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
id|found
suffix:colon
id|list_del
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|hil_mlcs_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|HIL_MLC_DEVMEM
suffix:semicolon
id|i
op_increment
)paren
(brace
id|serio_unregister_port
c_func
(paren
id|mlc-&gt;serio
(braket
id|i
)braket
)paren
suffix:semicolon
id|mlc-&gt;serio
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
id|tasklet_schedule
c_func
(paren
op_amp
id|hil_mlcs_tasklet
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**************************** Module interface *************************/
DECL|function|hil_mlc_init
r_static
r_int
id|__init
id|hil_mlc_init
c_func
(paren
r_void
)paren
(brace
id|init_timer
c_func
(paren
op_amp
id|hil_mlcs_kicker
)paren
suffix:semicolon
id|hil_mlcs_kicker.expires
op_assign
id|jiffies
op_plus
id|HZ
suffix:semicolon
id|hil_mlcs_kicker.function
op_assign
op_amp
id|hil_mlcs_timer
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|hil_mlcs_kicker
)paren
suffix:semicolon
id|tasklet_enable
c_func
(paren
op_amp
id|hil_mlcs_tasklet
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|hil_mlc_exit
r_static
r_void
id|__exit
id|hil_mlc_exit
c_func
(paren
r_void
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|hil_mlcs_kicker
)paren
suffix:semicolon
id|tasklet_disable
c_func
(paren
op_amp
id|hil_mlcs_tasklet
)paren
suffix:semicolon
id|tasklet_kill
c_func
(paren
op_amp
id|hil_mlcs_tasklet
)paren
suffix:semicolon
)brace
DECL|variable|hil_mlc_init
id|module_init
c_func
(paren
id|hil_mlc_init
)paren
suffix:semicolon
DECL|variable|hil_mlc_exit
id|module_exit
c_func
(paren
id|hil_mlc_exit
)paren
suffix:semicolon
eof
