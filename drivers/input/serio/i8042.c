multiline_comment|/*&n; *  i8042 keyboard and mouse controller driver for Linux&n; *&n; *  Copyright (c) 1999-2004 Vojtech Pavlik&n; */
multiline_comment|/*&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License version 2 as published by&n; * the Free Software Foundation.&n; */
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/serio.h&gt;
macro_line|#include &lt;linux/err.h&gt;
macro_line|#include &lt;asm/io.h&gt;
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Vojtech Pavlik &lt;vojtech@suse.cz&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;i8042 keyboard and mouse controller driver&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|variable|i8042_noaux
r_static
r_int
r_int
id|i8042_noaux
suffix:semicolon
id|module_param_named
c_func
(paren
id|noaux
comma
id|i8042_noaux
comma
r_bool
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|noaux
comma
l_string|&quot;Do not probe or use AUX (mouse) port.&quot;
)paren
suffix:semicolon
DECL|variable|i8042_nomux
r_static
r_int
r_int
id|i8042_nomux
suffix:semicolon
id|module_param_named
c_func
(paren
id|nomux
comma
id|i8042_nomux
comma
r_bool
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|nomux
comma
l_string|&quot;Do not check whether an active multiplexing conrtoller is present.&quot;
)paren
suffix:semicolon
DECL|variable|i8042_unlock
r_static
r_int
r_int
id|i8042_unlock
suffix:semicolon
id|module_param_named
c_func
(paren
id|unlock
comma
id|i8042_unlock
comma
r_bool
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|unlock
comma
l_string|&quot;Ignore keyboard lock.&quot;
)paren
suffix:semicolon
DECL|variable|i8042_reset
r_static
r_int
r_int
id|i8042_reset
suffix:semicolon
id|module_param_named
c_func
(paren
id|reset
comma
id|i8042_reset
comma
r_bool
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|reset
comma
l_string|&quot;Reset controller during init and cleanup.&quot;
)paren
suffix:semicolon
DECL|variable|i8042_direct
r_static
r_int
r_int
id|i8042_direct
suffix:semicolon
id|module_param_named
c_func
(paren
id|direct
comma
id|i8042_direct
comma
r_bool
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|direct
comma
l_string|&quot;Put keyboard port into non-translated mode.&quot;
)paren
suffix:semicolon
DECL|variable|i8042_dumbkbd
r_static
r_int
r_int
id|i8042_dumbkbd
suffix:semicolon
id|module_param_named
c_func
(paren
id|dumbkbd
comma
id|i8042_dumbkbd
comma
r_bool
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|dumbkbd
comma
l_string|&quot;Pretend that controller can only read data from keyboard&quot;
)paren
suffix:semicolon
DECL|variable|i8042_noloop
r_static
r_int
r_int
id|i8042_noloop
suffix:semicolon
id|module_param_named
c_func
(paren
id|noloop
comma
id|i8042_noloop
comma
r_bool
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|dumbkbd
comma
l_string|&quot;Disable the AUX Loopback command while probing for the AUX port&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_ACPI
DECL|variable|i8042_noacpi
r_static
r_int
id|i8042_noacpi
suffix:semicolon
id|module_param_named
c_func
(paren
id|noacpi
comma
id|i8042_noacpi
comma
r_bool
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|noacpi
comma
l_string|&quot;Do not use ACPI to detect controller settings&quot;
)paren
suffix:semicolon
macro_line|#endif
DECL|macro|DEBUG
mdefine_line|#define DEBUG
macro_line|#ifdef DEBUG
DECL|variable|i8042_debug
r_static
r_int
id|i8042_debug
suffix:semicolon
id|module_param_named
c_func
(paren
id|debug
comma
id|i8042_debug
comma
r_bool
comma
l_int|0600
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|debug
comma
l_string|&quot;Turn i8042 debugging mode on and off&quot;
)paren
suffix:semicolon
macro_line|#endif
id|__obsolete_setup
c_func
(paren
l_string|&quot;i8042_noaux&quot;
)paren
suffix:semicolon
id|__obsolete_setup
c_func
(paren
l_string|&quot;i8042_nomux&quot;
)paren
suffix:semicolon
id|__obsolete_setup
c_func
(paren
l_string|&quot;i8042_unlock&quot;
)paren
suffix:semicolon
id|__obsolete_setup
c_func
(paren
l_string|&quot;i8042_reset&quot;
)paren
suffix:semicolon
id|__obsolete_setup
c_func
(paren
l_string|&quot;i8042_direct&quot;
)paren
suffix:semicolon
id|__obsolete_setup
c_func
(paren
l_string|&quot;i8042_dumbkbd&quot;
)paren
suffix:semicolon
macro_line|#include &quot;i8042.h&quot;
DECL|variable|i8042_lock
id|DEFINE_SPINLOCK
c_func
(paren
id|i8042_lock
)paren
suffix:semicolon
DECL|struct|i8042_values
r_struct
id|i8042_values
(brace
DECL|member|irq
r_int
id|irq
suffix:semicolon
DECL|member|disable
r_int
r_char
id|disable
suffix:semicolon
DECL|member|irqen
r_int
r_char
id|irqen
suffix:semicolon
DECL|member|exists
r_int
r_char
id|exists
suffix:semicolon
DECL|member|mux
r_int
r_char
id|mux
suffix:semicolon
DECL|member|name
r_char
id|name
(braket
l_int|8
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|i8042_kbd_values
r_static
r_struct
id|i8042_values
id|i8042_kbd_values
op_assign
(brace
dot
id|disable
op_assign
id|I8042_CTR_KBDDIS
comma
dot
id|irqen
op_assign
id|I8042_CTR_KBDINT
comma
dot
id|mux
op_assign
op_minus
l_int|1
comma
dot
id|name
op_assign
l_string|&quot;KBD&quot;
comma
)brace
suffix:semicolon
DECL|variable|i8042_aux_values
r_static
r_struct
id|i8042_values
id|i8042_aux_values
op_assign
(brace
dot
id|disable
op_assign
id|I8042_CTR_AUXDIS
comma
dot
id|irqen
op_assign
id|I8042_CTR_AUXINT
comma
dot
id|mux
op_assign
op_minus
l_int|1
comma
dot
id|name
op_assign
l_string|&quot;AUX&quot;
comma
)brace
suffix:semicolon
DECL|variable|i8042_mux_values
r_static
r_struct
id|i8042_values
id|i8042_mux_values
(braket
id|I8042_NUM_MUX_PORTS
)braket
suffix:semicolon
DECL|variable|i8042_kbd_port
r_static
r_struct
id|serio
op_star
id|i8042_kbd_port
suffix:semicolon
DECL|variable|i8042_aux_port
r_static
r_struct
id|serio
op_star
id|i8042_aux_port
suffix:semicolon
DECL|variable|i8042_mux_port
r_static
r_struct
id|serio
op_star
id|i8042_mux_port
(braket
id|I8042_NUM_MUX_PORTS
)braket
suffix:semicolon
DECL|variable|i8042_initial_ctr
r_static
r_int
r_char
id|i8042_initial_ctr
suffix:semicolon
DECL|variable|i8042_ctr
r_static
r_int
r_char
id|i8042_ctr
suffix:semicolon
DECL|variable|i8042_mux_open
r_static
r_int
r_char
id|i8042_mux_open
suffix:semicolon
DECL|variable|i8042_mux_present
r_static
r_int
r_char
id|i8042_mux_present
suffix:semicolon
DECL|variable|i8042_timer
r_static
r_struct
id|timer_list
id|i8042_timer
suffix:semicolon
DECL|variable|i8042_platform_device
r_static
r_struct
id|platform_device
op_star
id|i8042_platform_device
suffix:semicolon
multiline_comment|/*&n; * Shared IRQ&squot;s require a device pointer, but this driver doesn&squot;t support&n; * multiple devices&n; */
DECL|macro|i8042_request_irq_cookie
mdefine_line|#define i8042_request_irq_cookie (&amp;i8042_timer)
r_static
id|irqreturn_t
id|i8042_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
multiline_comment|/*&n; * The i8042_wait_read() and i8042_wait_write functions wait for the i8042 to&n; * be ready for reading values from it / writing values to it.&n; * Called always with i8042_lock held.&n; */
DECL|function|i8042_wait_read
r_static
r_int
id|i8042_wait_read
c_func
(paren
r_void
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
op_complement
id|i8042_read_status
c_func
(paren
)paren
op_amp
id|I8042_STR_OBF
)paren
op_logical_and
(paren
id|i
OL
id|I8042_CTL_TIMEOUT
)paren
)paren
(brace
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_return
op_minus
(paren
id|i
op_eq
id|I8042_CTL_TIMEOUT
)paren
suffix:semicolon
)brace
DECL|function|i8042_wait_write
r_static
r_int
id|i8042_wait_write
c_func
(paren
r_void
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|i8042_read_status
c_func
(paren
)paren
op_amp
id|I8042_STR_IBF
)paren
op_logical_and
(paren
id|i
OL
id|I8042_CTL_TIMEOUT
)paren
)paren
(brace
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_return
op_minus
(paren
id|i
op_eq
id|I8042_CTL_TIMEOUT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * i8042_flush() flushes all data that may be in the keyboard and mouse buffers&n; * of the i8042 down the toilet.&n; */
DECL|function|i8042_flush
r_static
r_int
id|i8042_flush
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|data
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|i8042_lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|i8042_read_status
c_func
(paren
)paren
op_amp
id|I8042_STR_OBF
)paren
op_logical_and
(paren
id|i
op_increment
OL
id|I8042_BUFFER_SIZE
)paren
)paren
(brace
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|data
op_assign
id|i8042_read_data
c_func
(paren
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%02x &lt;- i8042 (flush, %s)&quot;
comma
id|data
comma
id|i8042_read_status
c_func
(paren
)paren
op_amp
id|I8042_STR_AUXDATA
ques
c_cond
l_string|&quot;aux&quot;
suffix:colon
l_string|&quot;kbd&quot;
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|i8042_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/*&n; * i8042_command() executes a command on the i8042. It also sends the input&n; * parameter(s) of the commands to it, and receives the output value(s). The&n; * parameters are to be stored in the param array, and the output is placed&n; * into the same array. The number of the parameters and output values is&n; * encoded in bits 8-11 of the command number.&n; */
DECL|function|i8042_command
r_static
r_int
id|i8042_command
c_func
(paren
r_int
r_char
op_star
id|param
comma
r_int
id|command
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|i8042_noloop
op_logical_and
id|command
op_eq
id|I8042_CMD_AUX_LOOP
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|i8042_lock
comma
id|flags
)paren
suffix:semicolon
id|retval
op_assign
id|i8042_wait_write
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;%02x -&gt; i8042 (command)&quot;
comma
id|command
op_amp
l_int|0xff
)paren
suffix:semicolon
id|i8042_write_command
c_func
(paren
id|command
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
(paren
id|command
op_rshift
l_int|12
)paren
op_amp
l_int|0xf
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|i8042_wait_write
c_func
(paren
)paren
)paren
)paren
r_break
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%02x -&gt; i8042 (parameter)&quot;
comma
id|param
(braket
id|i
)braket
)paren
suffix:semicolon
id|i8042_write_data
c_func
(paren
id|param
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
(paren
id|command
op_rshift
l_int|8
)paren
op_amp
l_int|0xf
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|i8042_wait_read
c_func
(paren
)paren
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i8042_read_status
c_func
(paren
)paren
op_amp
id|I8042_STR_AUXDATA
)paren
id|param
(braket
id|i
)braket
op_assign
op_complement
id|i8042_read_data
c_func
(paren
)paren
suffix:semicolon
r_else
id|param
(braket
id|i
)braket
op_assign
id|i8042_read_data
c_func
(paren
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%02x &lt;- i8042 (return)&quot;
comma
id|param
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|i8042_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
id|dbg
c_func
(paren
l_string|&quot;     -- i8042 (timeout)&quot;
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * i8042_kbd_write() sends a byte out through the keyboard interface.&n; */
DECL|function|i8042_kbd_write
r_static
r_int
id|i8042_kbd_write
c_func
(paren
r_struct
id|serio
op_star
id|port
comma
r_int
r_char
id|c
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|i8042_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|retval
op_assign
id|i8042_wait_write
c_func
(paren
)paren
)paren
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;%02x -&gt; i8042 (kbd-data)&quot;
comma
id|c
)paren
suffix:semicolon
id|i8042_write_data
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|i8042_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * i8042_aux_write() sends a byte out through the aux interface.&n; */
DECL|function|i8042_aux_write
r_static
r_int
id|i8042_aux_write
c_func
(paren
r_struct
id|serio
op_star
id|port
comma
r_int
r_char
id|c
)paren
(brace
r_struct
id|i8042_values
op_star
id|values
op_assign
id|port-&gt;port_data
suffix:semicolon
r_int
id|retval
suffix:semicolon
multiline_comment|/*&n; * Send the byte out.&n; */
r_if
c_cond
(paren
id|values-&gt;mux
op_eq
op_minus
l_int|1
)paren
id|retval
op_assign
id|i8042_command
c_func
(paren
op_amp
id|c
comma
id|I8042_CMD_AUX_SEND
)paren
suffix:semicolon
r_else
id|retval
op_assign
id|i8042_command
c_func
(paren
op_amp
id|c
comma
id|I8042_CMD_MUX_SEND
op_plus
id|values-&gt;mux
)paren
suffix:semicolon
multiline_comment|/*&n; * Make sure the interrupt happens and the character is received even&n; * in the case the IRQ isn&squot;t wired, so that we can receive further&n; * characters later.&n; */
id|i8042_interrupt
c_func
(paren
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * i8042_activate_port() enables port on a chip.&n; */
DECL|function|i8042_activate_port
r_static
r_int
id|i8042_activate_port
c_func
(paren
r_struct
id|serio
op_star
id|port
)paren
(brace
r_struct
id|i8042_values
op_star
id|values
op_assign
id|port-&gt;port_data
suffix:semicolon
id|i8042_flush
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Enable port again here because it is disabled if we are&n;&t; * resuming (normally it is enabled already).&n;&t; */
id|i8042_ctr
op_and_assign
op_complement
id|values-&gt;disable
suffix:semicolon
id|i8042_ctr
op_or_assign
id|values-&gt;irqen
suffix:semicolon
r_if
c_cond
(paren
id|i8042_command
c_func
(paren
op_amp
id|i8042_ctr
comma
id|I8042_CMD_CTL_WCTR
)paren
)paren
(brace
id|i8042_ctr
op_and_assign
op_complement
id|values-&gt;irqen
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * i8042_open() is called when a port is open by the higher layer.&n; * It allocates the interrupt and calls i8042_enable_port.&n; */
DECL|function|i8042_open
r_static
r_int
id|i8042_open
c_func
(paren
r_struct
id|serio
op_star
id|port
)paren
(brace
r_struct
id|i8042_values
op_star
id|values
op_assign
id|port-&gt;port_data
suffix:semicolon
r_if
c_cond
(paren
id|values-&gt;mux
op_ne
op_minus
l_int|1
)paren
r_if
c_cond
(paren
id|i8042_mux_open
op_increment
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|values-&gt;irq
comma
id|i8042_interrupt
comma
id|SA_SHIRQ
comma
l_string|&quot;i8042&quot;
comma
id|i8042_request_irq_cookie
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i8042.c: Can&squot;t get irq %d for %s, unregistering the port.&bslash;n&quot;
comma
id|values-&gt;irq
comma
id|values-&gt;name
)paren
suffix:semicolon
r_goto
id|irq_fail
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i8042_activate_port
c_func
(paren
id|port
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i8042.c: Can&squot;t activate %s, unregistering the port&bslash;n&quot;
comma
id|values-&gt;name
)paren
suffix:semicolon
r_goto
id|activate_fail
suffix:semicolon
)brace
id|i8042_interrupt
c_func
(paren
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|activate_fail
suffix:colon
id|free_irq
c_func
(paren
id|values-&gt;irq
comma
id|i8042_request_irq_cookie
)paren
suffix:semicolon
id|irq_fail
suffix:colon
id|values-&gt;exists
op_assign
l_int|0
suffix:semicolon
id|serio_unregister_port_delayed
c_func
(paren
id|port
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * i8042_close() frees the interrupt, so that it can possibly be used&n; * by another driver. We never know - if the user doesn&squot;t have a mouse,&n; * the BIOS could have used the AUX interrupt for PCI.&n; */
DECL|function|i8042_close
r_static
r_void
id|i8042_close
c_func
(paren
r_struct
id|serio
op_star
id|port
)paren
(brace
r_struct
id|i8042_values
op_star
id|values
op_assign
id|port-&gt;port_data
suffix:semicolon
r_if
c_cond
(paren
id|values-&gt;mux
op_ne
op_minus
l_int|1
)paren
r_if
c_cond
(paren
op_decrement
id|i8042_mux_open
)paren
r_return
suffix:semicolon
id|i8042_ctr
op_and_assign
op_complement
id|values-&gt;irqen
suffix:semicolon
r_if
c_cond
(paren
id|i8042_command
c_func
(paren
op_amp
id|i8042_ctr
comma
id|I8042_CMD_CTL_WCTR
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i8042.c: Can&squot;t write CTR while closing %s.&bslash;n&quot;
comma
id|values-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|free_irq
c_func
(paren
id|values-&gt;irq
comma
id|i8042_request_irq_cookie
)paren
suffix:semicolon
id|i8042_flush
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * i8042_interrupt() is the most important function in this driver -&n; * it handles the interrupts from the i8042, and sends incoming bytes&n; * to the upper layers.&n; */
DECL|function|i8042_interrupt
r_static
id|irqreturn_t
id|i8042_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|str
comma
id|data
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|dfl
suffix:semicolon
r_int
r_int
id|aux_idx
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|i8042_timer
comma
id|jiffies
op_plus
id|I8042_POLL_PERIOD
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|i8042_lock
comma
id|flags
)paren
suffix:semicolon
id|str
op_assign
id|i8042_read_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|str
op_amp
id|I8042_STR_OBF
)paren
id|data
op_assign
id|i8042_read_data
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|i8042_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_complement
id|str
op_amp
id|I8042_STR_OBF
)paren
(brace
r_if
c_cond
(paren
id|irq
)paren
id|dbg
c_func
(paren
l_string|&quot;Interrupt %d, without any data&quot;
comma
id|irq
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i8042_mux_present
op_logical_and
(paren
id|str
op_amp
id|I8042_STR_AUXDATA
)paren
)paren
(brace
r_static
r_int
r_int
id|last_transmit
suffix:semicolon
r_static
r_int
r_char
id|last_str
suffix:semicolon
id|dfl
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|str
op_amp
id|I8042_STR_MUXERR
)paren
(brace
id|dbg
c_func
(paren
l_string|&quot;MUX error, status is %02x, data is %02x&quot;
comma
id|str
comma
id|data
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|data
)paren
(brace
r_default
suffix:colon
(brace
)brace
multiline_comment|/*&n; * When MUXERR condition is signalled the data register can only contain&n; * 0xfd, 0xfe or 0xff if implementation follows the spec. Unfortunately&n; * it is not always the case. Some KBC just get confused which port the&n; * data came from and signal error leaving the data intact. They _do not_&n; * revert to legacy mode (actually I&squot;ve never seen KBC reverting to legacy&n; * mode yet, when we see one we&squot;ll add proper handling).&n; * Anyway, we will assume that the data came from the same serio last byte&n; * was transmitted (if transmission happened not too long ago).&n; */
r_if
c_cond
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|last_transmit
op_plus
id|HZ
op_div
l_int|10
)paren
)paren
(brace
id|str
op_assign
id|last_str
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* fall through - report timeout */
r_case
l_int|0xfd
suffix:colon
r_case
l_int|0xfe
suffix:colon
id|dfl
op_assign
id|SERIO_TIMEOUT
suffix:semicolon
id|data
op_assign
l_int|0xfe
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xff
suffix:colon
id|dfl
op_assign
id|SERIO_PARITY
suffix:semicolon
id|data
op_assign
l_int|0xfe
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|aux_idx
op_assign
(paren
id|str
op_rshift
l_int|6
)paren
op_amp
l_int|3
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%02x &lt;- i8042 (interrupt, aux%d, %d%s%s)&quot;
comma
id|data
comma
id|aux_idx
comma
id|irq
comma
id|dfl
op_amp
id|SERIO_PARITY
ques
c_cond
l_string|&quot;, bad parity&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|dfl
op_amp
id|SERIO_TIMEOUT
ques
c_cond
l_string|&quot;, timeout&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|i8042_mux_values
(braket
id|aux_idx
)braket
dot
id|exists
)paren
)paren
id|serio_interrupt
c_func
(paren
id|i8042_mux_port
(braket
id|aux_idx
)braket
comma
id|data
comma
id|dfl
comma
id|regs
)paren
suffix:semicolon
id|last_str
op_assign
id|str
suffix:semicolon
id|last_transmit
op_assign
id|jiffies
suffix:semicolon
r_goto
id|irq_ret
suffix:semicolon
)brace
id|dfl
op_assign
(paren
(paren
id|str
op_amp
id|I8042_STR_PARITY
)paren
ques
c_cond
id|SERIO_PARITY
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|str
op_amp
id|I8042_STR_TIMEOUT
)paren
ques
c_cond
id|SERIO_TIMEOUT
suffix:colon
l_int|0
)paren
suffix:semicolon
id|dbg
c_func
(paren
l_string|&quot;%02x &lt;- i8042 (interrupt, %s, %d%s%s)&quot;
comma
id|data
comma
(paren
id|str
op_amp
id|I8042_STR_AUXDATA
)paren
ques
c_cond
l_string|&quot;aux&quot;
suffix:colon
l_string|&quot;kbd&quot;
comma
id|irq
comma
id|dfl
op_amp
id|SERIO_PARITY
ques
c_cond
l_string|&quot;, bad parity&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|dfl
op_amp
id|SERIO_TIMEOUT
ques
c_cond
l_string|&quot;, timeout&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|str
op_amp
id|I8042_STR_AUXDATA
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|i8042_aux_values.exists
)paren
)paren
id|serio_interrupt
c_func
(paren
id|i8042_aux_port
comma
id|data
comma
id|dfl
comma
id|regs
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|i8042_kbd_values.exists
)paren
)paren
id|serio_interrupt
c_func
(paren
id|i8042_kbd_port
comma
id|data
comma
id|dfl
comma
id|regs
)paren
suffix:semicolon
)brace
id|irq_ret
suffix:colon
id|ret
op_assign
l_int|1
suffix:semicolon
id|out
suffix:colon
r_return
id|IRQ_RETVAL
c_func
(paren
id|ret
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * i8042_set_mux_mode checks whether the controller has an active&n; * multiplexor and puts the chip into Multiplexed (1) or Legacy (0) mode.&n; */
DECL|function|i8042_set_mux_mode
r_static
r_int
id|i8042_set_mux_mode
c_func
(paren
r_int
r_int
id|mode
comma
r_int
r_char
op_star
id|mux_version
)paren
(brace
r_int
r_char
id|param
suffix:semicolon
multiline_comment|/*&n; * Get rid of bytes in the queue.&n; */
id|i8042_flush
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n; * Internal loopback test - send three bytes, they should come back from the&n; * mouse interface, the last should be version. Note that we negate mouseport&n; * command responses for the i8042_check_aux() routine.&n; */
id|param
op_assign
l_int|0xf0
suffix:semicolon
r_if
c_cond
(paren
id|i8042_command
c_func
(paren
op_amp
id|param
comma
id|I8042_CMD_AUX_LOOP
)paren
op_logical_or
id|param
op_ne
l_int|0x0f
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|param
op_assign
id|mode
ques
c_cond
l_int|0x56
suffix:colon
l_int|0xf6
suffix:semicolon
r_if
c_cond
(paren
id|i8042_command
c_func
(paren
op_amp
id|param
comma
id|I8042_CMD_AUX_LOOP
)paren
op_logical_or
id|param
op_ne
l_int|0xa9
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|param
op_assign
id|mode
ques
c_cond
l_int|0xa4
suffix:colon
l_int|0xa5
suffix:semicolon
r_if
c_cond
(paren
id|i8042_command
c_func
(paren
op_amp
id|param
comma
id|I8042_CMD_AUX_LOOP
)paren
op_logical_or
id|param
op_eq
(paren
id|mode
ques
c_cond
l_int|0x5b
suffix:colon
l_int|0x5a
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|mux_version
)paren
op_star
id|mux_version
op_assign
op_complement
id|param
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * i8042_enable_mux_ports enables 4 individual AUX ports after&n; * the controller has been switched into Multiplexed mode&n; */
DECL|function|i8042_enable_mux_ports
r_static
r_int
id|i8042_enable_mux_ports
c_func
(paren
r_struct
id|i8042_values
op_star
id|values
)paren
(brace
r_int
r_char
id|param
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n; * Disable all muxed ports by disabling AUX.&n; */
id|i8042_ctr
op_or_assign
id|I8042_CTR_AUXDIS
suffix:semicolon
id|i8042_ctr
op_and_assign
op_complement
id|I8042_CTR_AUXINT
suffix:semicolon
r_if
c_cond
(paren
id|i8042_command
c_func
(paren
op_amp
id|i8042_ctr
comma
id|I8042_CMD_CTL_WCTR
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i8042.c: Failed to disable AUX port, can&squot;t use MUX.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Enable all muxed ports.&n; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|i8042_command
c_func
(paren
op_amp
id|param
comma
id|I8042_CMD_MUX_PFX
op_plus
id|i
)paren
suffix:semicolon
id|i8042_command
c_func
(paren
op_amp
id|param
comma
id|I8042_CMD_AUX_ENABLE
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * i8042_check_mux() checks whether the controller supports the PS/2 Active&n; * Multiplexing specification by Synaptics, Phoenix, Insyde and&n; * LCS/Telegraphics.&n; */
DECL|function|i8042_check_mux
r_static
r_int
id|__init
id|i8042_check_mux
c_func
(paren
r_struct
id|i8042_values
op_star
id|values
)paren
(brace
r_int
r_char
id|mux_version
suffix:semicolon
r_if
c_cond
(paren
id|i8042_set_mux_mode
c_func
(paren
l_int|1
comma
op_amp
id|mux_version
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Workaround for interference with USB Legacy emulation */
multiline_comment|/* that causes a v10.12 MUX to be found. */
r_if
c_cond
(paren
id|mux_version
op_eq
l_int|0xAC
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;i8042.c: Detected active multiplexing controller, rev %d.%d.&bslash;n&quot;
comma
(paren
id|mux_version
op_rshift
l_int|4
)paren
op_amp
l_int|0xf
comma
id|mux_version
op_amp
l_int|0xf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i8042_enable_mux_ports
c_func
(paren
id|values
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|i8042_mux_present
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * i8042_check_aux() applies as much paranoia as it can at detecting&n; * the presence of an AUX interface.&n; */
DECL|function|i8042_check_aux
r_static
r_int
id|__init
id|i8042_check_aux
c_func
(paren
r_struct
id|i8042_values
op_star
id|values
)paren
(brace
r_int
r_char
id|param
suffix:semicolon
r_static
r_int
id|i8042_check_aux_cookie
suffix:semicolon
multiline_comment|/*&n; * Check if AUX irq is available. If it isn&squot;t, then there is no point&n; * in trying to detect AUX presence.&n; */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|values-&gt;irq
comma
id|i8042_interrupt
comma
id|SA_SHIRQ
comma
l_string|&quot;i8042&quot;
comma
op_amp
id|i8042_check_aux_cookie
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|free_irq
c_func
(paren
id|values-&gt;irq
comma
op_amp
id|i8042_check_aux_cookie
)paren
suffix:semicolon
multiline_comment|/*&n; * Get rid of bytes in the queue.&n; */
id|i8042_flush
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n; * Internal loopback test - filters out AT-type i8042&squot;s. Unfortunately&n; * SiS screwed up and their 5597 doesn&squot;t support the LOOP command even&n; * though it has an AUX port.&n; */
id|param
op_assign
l_int|0x5a
suffix:semicolon
r_if
c_cond
(paren
id|i8042_command
c_func
(paren
op_amp
id|param
comma
id|I8042_CMD_AUX_LOOP
)paren
op_logical_or
id|param
op_ne
l_int|0xa5
)paren
(brace
multiline_comment|/*&n; * External connection test - filters out AT-soldered PS/2 i8042&squot;s&n; * 0x00 - no error, 0x01-0x03 - clock/data stuck, 0xff - general error&n; * 0xfa - no error on some notebooks which ignore the spec&n; * Because it&squot;s common for chipsets to return error on perfectly functioning&n; * AUX ports, we test for this only when the LOOP command failed.&n; */
r_if
c_cond
(paren
id|i8042_command
c_func
(paren
op_amp
id|param
comma
id|I8042_CMD_AUX_TEST
)paren
op_logical_or
(paren
id|param
op_logical_and
id|param
op_ne
l_int|0xfa
op_logical_and
id|param
op_ne
l_int|0xff
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Bit assignment test - filters out PS/2 i8042&squot;s in AT mode&n; */
r_if
c_cond
(paren
id|i8042_command
c_func
(paren
op_amp
id|param
comma
id|I8042_CMD_AUX_DISABLE
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|i8042_command
c_func
(paren
op_amp
id|param
comma
id|I8042_CMD_CTL_RCTR
)paren
op_logical_or
(paren
op_complement
id|param
op_amp
id|I8042_CTR_AUXDIS
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Failed to disable AUX port, but continuing anyway... Is this a SiS?&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;If AUX port is really absent please use the &squot;i8042.noaux&squot; option.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i8042_command
c_func
(paren
op_amp
id|param
comma
id|I8042_CMD_AUX_ENABLE
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|i8042_command
c_func
(paren
op_amp
id|param
comma
id|I8042_CMD_CTL_RCTR
)paren
op_logical_or
(paren
id|param
op_amp
id|I8042_CTR_AUXDIS
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n; * Disable the interface.&n; */
id|i8042_ctr
op_or_assign
id|I8042_CTR_AUXDIS
suffix:semicolon
id|i8042_ctr
op_and_assign
op_complement
id|I8042_CTR_AUXINT
suffix:semicolon
r_if
c_cond
(paren
id|i8042_command
c_func
(paren
op_amp
id|i8042_ctr
comma
id|I8042_CMD_CTL_WCTR
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * i8042_port_register() marks the device as existing,&n; * registers it, and reports to the user.&n; */
DECL|function|i8042_port_register
r_static
r_int
id|__init
id|i8042_port_register
c_func
(paren
r_struct
id|serio
op_star
id|port
)paren
(brace
r_struct
id|i8042_values
op_star
id|values
op_assign
id|port-&gt;port_data
suffix:semicolon
id|values-&gt;exists
op_assign
l_int|1
suffix:semicolon
id|i8042_ctr
op_and_assign
op_complement
id|values-&gt;disable
suffix:semicolon
r_if
c_cond
(paren
id|i8042_command
c_func
(paren
op_amp
id|i8042_ctr
comma
id|I8042_CMD_CTL_WCTR
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;i8042.c: Can&squot;t write CTR while registering.&bslash;n&quot;
)paren
suffix:semicolon
id|values-&gt;exists
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;serio: i8042 %s port at %#lx,%#lx irq %d&bslash;n&quot;
comma
id|values-&gt;name
comma
(paren
r_int
r_int
)paren
id|I8042_DATA_REG
comma
(paren
r_int
r_int
)paren
id|I8042_COMMAND_REG
comma
id|values-&gt;irq
)paren
suffix:semicolon
id|serio_register_port
c_func
(paren
id|port
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|i8042_timer_func
r_static
r_void
id|i8042_timer_func
c_func
(paren
r_int
r_int
id|data
)paren
(brace
id|i8042_interrupt
c_func
(paren
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * i8042_controller init initializes the i8042 controller, and,&n; * most importantly, sets it into non-xlated mode if that&squot;s&n; * desired.&n; */
DECL|function|i8042_controller_init
r_static
r_int
id|i8042_controller_init
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n; * Test the i8042. We need to know if it thinks it&squot;s working correctly&n; * before doing anything else.&n; */
id|i8042_flush
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i8042_reset
)paren
(brace
r_int
r_char
id|param
suffix:semicolon
r_if
c_cond
(paren
id|i8042_command
c_func
(paren
op_amp
id|param
comma
id|I8042_CMD_CTL_TEST
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i8042.c: i8042 controller self test timeout.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|param
op_ne
id|I8042_RET_CTL_TEST
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i8042.c: i8042 controller selftest failed. (%#x != %#x)&bslash;n&quot;
comma
id|param
comma
id|I8042_RET_CTL_TEST
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Save the CTR for restoral on unload / reboot.&n; */
r_if
c_cond
(paren
id|i8042_command
c_func
(paren
op_amp
id|i8042_ctr
comma
id|I8042_CMD_CTL_RCTR
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i8042.c: Can&squot;t read CTR while initializing i8042.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|i8042_initial_ctr
op_assign
id|i8042_ctr
suffix:semicolon
multiline_comment|/*&n; * Disable the keyboard interface and interrupt.&n; */
id|i8042_ctr
op_or_assign
id|I8042_CTR_KBDDIS
suffix:semicolon
id|i8042_ctr
op_and_assign
op_complement
id|I8042_CTR_KBDINT
suffix:semicolon
multiline_comment|/*&n; * Handle keylock.&n; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|i8042_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_complement
id|i8042_read_status
c_func
(paren
)paren
op_amp
id|I8042_STR_KEYLOCK
)paren
(brace
r_if
c_cond
(paren
id|i8042_unlock
)paren
id|i8042_ctr
op_or_assign
id|I8042_CTR_IGNKEYLOCK
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;i8042.c: Warning: Keylock active.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|i8042_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n; * If the chip is configured into nontranslated mode by the BIOS, don&squot;t&n; * bother enabling translating and be happy.&n; */
r_if
c_cond
(paren
op_complement
id|i8042_ctr
op_amp
id|I8042_CTR_XLATE
)paren
id|i8042_direct
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n; * Set nontranslated mode for the kbd interface if requested by an option.&n; * After this the kbd interface becomes a simple serial in/out, like the aux&n; * interface is. We don&squot;t do this by default, since it can confuse notebook&n; * BIOSes.&n; */
r_if
c_cond
(paren
id|i8042_direct
)paren
id|i8042_ctr
op_and_assign
op_complement
id|I8042_CTR_XLATE
suffix:semicolon
multiline_comment|/*&n; * Write CTR back.&n; */
r_if
c_cond
(paren
id|i8042_command
c_func
(paren
op_amp
id|i8042_ctr
comma
id|I8042_CMD_CTL_WCTR
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i8042.c: Can&squot;t write CTR while initializing i8042.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Reset the controller.&n; */
DECL|function|i8042_controller_reset
r_void
id|i8042_controller_reset
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|param
suffix:semicolon
multiline_comment|/*&n; * Reset the controller if requested.&n; */
r_if
c_cond
(paren
id|i8042_reset
)paren
r_if
c_cond
(paren
id|i8042_command
c_func
(paren
op_amp
id|param
comma
id|I8042_CMD_CTL_TEST
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i8042.c: i8042 controller reset timeout.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * Disable MUX mode if present.&n; */
id|i8042_set_mux_mode
c_func
(paren
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n; * Restore the original control register setting.&n; */
id|i8042_ctr
op_assign
id|i8042_initial_ctr
suffix:semicolon
r_if
c_cond
(paren
id|i8042_command
c_func
(paren
op_amp
id|i8042_ctr
comma
id|I8042_CMD_CTL_WCTR
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;i8042.c: Can&squot;t restore CTR.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Here we try to reset everything back to a state in which the BIOS will be&n; * able to talk to the hardware when rebooting.&n; */
DECL|function|i8042_controller_cleanup
r_void
id|i8042_controller_cleanup
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|i8042_flush
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n; * Reset anything that is connected to the ports.&n; */
r_if
c_cond
(paren
id|i8042_kbd_values.exists
)paren
id|serio_cleanup
c_func
(paren
id|i8042_kbd_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i8042_aux_values.exists
)paren
id|serio_cleanup
c_func
(paren
id|i8042_aux_port
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|I8042_NUM_MUX_PORTS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|i8042_mux_values
(braket
id|i
)braket
dot
id|exists
)paren
id|serio_cleanup
c_func
(paren
id|i8042_mux_port
(braket
id|i
)braket
)paren
suffix:semicolon
id|i8042_controller_reset
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|blink_frequency
r_static
r_int
id|blink_frequency
op_assign
l_int|500
suffix:semicolon
id|module_param_named
c_func
(paren
id|panicblink
comma
id|blink_frequency
comma
r_int
comma
l_int|0600
)paren
suffix:semicolon
multiline_comment|/* Catch the case when the kbd interrupt is off */
DECL|macro|DELAY
mdefine_line|#define DELAY do { mdelay(1); if (++delay &gt; 10) return delay; } while(0)
multiline_comment|/* Tell the user who may be running in X and not see the console that we have&n;   panic&squot;ed. This is to distingush panics from &quot;real&quot; lockups.  */
DECL|function|i8042_panic_blink
r_static
r_int
id|i8042_panic_blink
c_func
(paren
r_int
id|count
)paren
(brace
r_int
id|delay
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|last_blink
suffix:semicolon
r_static
r_char
id|led
suffix:semicolon
multiline_comment|/* Roughly 1/2s frequency. KDB uses about 1s. Make sure it is&n;&t;   different. */
r_if
c_cond
(paren
op_logical_neg
id|blink_frequency
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|count
op_minus
id|last_blink
OL
id|blink_frequency
)paren
r_return
l_int|0
suffix:semicolon
id|led
op_xor_assign
l_int|0x01
op_or
l_int|0x04
suffix:semicolon
r_while
c_loop
(paren
id|i8042_read_status
c_func
(paren
)paren
op_amp
id|I8042_STR_IBF
)paren
id|DELAY
suffix:semicolon
id|i8042_write_data
c_func
(paren
l_int|0xed
)paren
suffix:semicolon
multiline_comment|/* set leds */
id|DELAY
suffix:semicolon
r_while
c_loop
(paren
id|i8042_read_status
c_func
(paren
)paren
op_amp
id|I8042_STR_IBF
)paren
id|DELAY
suffix:semicolon
id|DELAY
suffix:semicolon
id|i8042_write_data
c_func
(paren
id|led
)paren
suffix:semicolon
id|DELAY
suffix:semicolon
id|last_blink
op_assign
id|count
suffix:semicolon
r_return
id|delay
suffix:semicolon
)brace
DECL|macro|DELAY
macro_line|#undef DELAY
multiline_comment|/*&n; * Here we try to restore the original BIOS settings&n; */
DECL|function|i8042_suspend
r_static
r_int
id|i8042_suspend
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|u32
id|state
comma
id|u32
id|level
)paren
(brace
r_if
c_cond
(paren
id|level
op_eq
id|SUSPEND_DISABLE
)paren
(brace
id|del_timer_sync
c_func
(paren
op_amp
id|i8042_timer
)paren
suffix:semicolon
id|i8042_controller_reset
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Here we try to reset everything back to a state in which suspended&n; */
DECL|function|i8042_resume
r_static
r_int
id|i8042_resume
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|u32
id|level
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|level
op_ne
id|RESUME_ENABLE
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|i8042_controller_init
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i8042: resume failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i8042_mux_present
)paren
r_if
c_cond
(paren
id|i8042_set_mux_mode
c_func
(paren
l_int|1
comma
l_int|NULL
)paren
op_logical_or
id|i8042_enable_mux_ports
c_func
(paren
op_amp
id|i8042_aux_values
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;i8042: failed to resume active multiplexor, mouse won&squot;t work.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Reconnect anything that was connected to the ports.&n; */
r_if
c_cond
(paren
id|i8042_kbd_values.exists
op_logical_and
id|i8042_activate_port
c_func
(paren
id|i8042_kbd_port
)paren
op_eq
l_int|0
)paren
id|serio_reconnect
c_func
(paren
id|i8042_kbd_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i8042_aux_values.exists
op_logical_and
id|i8042_activate_port
c_func
(paren
id|i8042_aux_port
)paren
op_eq
l_int|0
)paren
id|serio_reconnect
c_func
(paren
id|i8042_aux_port
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|I8042_NUM_MUX_PORTS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|i8042_mux_values
(braket
id|i
)braket
dot
id|exists
op_logical_and
id|i8042_activate_port
c_func
(paren
id|i8042_mux_port
(braket
id|i
)braket
)paren
op_eq
l_int|0
)paren
id|serio_reconnect
c_func
(paren
id|i8042_mux_port
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/*&n; * Restart timer (for polling &quot;stuck&quot; data)&n; */
id|mod_timer
c_func
(paren
op_amp
id|i8042_timer
comma
id|jiffies
op_plus
id|I8042_POLL_PERIOD
)paren
suffix:semicolon
id|panic_blink
op_assign
id|i8042_panic_blink
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * We need to reset the 8042 back to original mode on system shutdown,&n; * because otherwise BIOSes will be confused.&n; */
DECL|function|i8042_shutdown
r_static
r_void
id|i8042_shutdown
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|i8042_controller_cleanup
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|i8042_driver
r_static
r_struct
id|device_driver
id|i8042_driver
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;i8042&quot;
comma
dot
id|bus
op_assign
op_amp
id|platform_bus_type
comma
dot
id|suspend
op_assign
id|i8042_suspend
comma
dot
id|resume
op_assign
id|i8042_resume
comma
dot
id|shutdown
op_assign
id|i8042_shutdown
comma
)brace
suffix:semicolon
DECL|function|i8042_allocate_kbd_port
r_static
r_struct
id|serio
op_star
id|__init
id|i8042_allocate_kbd_port
c_func
(paren
r_void
)paren
(brace
r_struct
id|serio
op_star
id|serio
suffix:semicolon
id|serio
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|serio
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serio
)paren
(brace
id|memset
c_func
(paren
id|serio
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|serio
)paren
)paren
suffix:semicolon
id|serio-&gt;type
op_assign
id|i8042_direct
ques
c_cond
id|SERIO_8042
suffix:colon
id|SERIO_8042_XL
comma
id|serio-&gt;write
op_assign
id|i8042_dumbkbd
ques
c_cond
l_int|NULL
suffix:colon
id|i8042_kbd_write
comma
id|serio-&gt;open
op_assign
id|i8042_open
comma
id|serio-&gt;close
op_assign
id|i8042_close
comma
id|serio-&gt;port_data
op_assign
op_amp
id|i8042_kbd_values
comma
id|serio-&gt;dev.parent
op_assign
op_amp
id|i8042_platform_device-&gt;dev
suffix:semicolon
id|strlcpy
c_func
(paren
id|serio-&gt;name
comma
l_string|&quot;i8042 Kbd Port&quot;
comma
r_sizeof
(paren
id|serio-&gt;name
)paren
)paren
suffix:semicolon
id|strlcpy
c_func
(paren
id|serio-&gt;phys
comma
id|I8042_KBD_PHYS_DESC
comma
r_sizeof
(paren
id|serio-&gt;phys
)paren
)paren
suffix:semicolon
)brace
r_return
id|serio
suffix:semicolon
)brace
DECL|function|i8042_allocate_aux_port
r_static
r_struct
id|serio
op_star
id|__init
id|i8042_allocate_aux_port
c_func
(paren
r_void
)paren
(brace
r_struct
id|serio
op_star
id|serio
suffix:semicolon
id|serio
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|serio
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serio
)paren
(brace
id|memset
c_func
(paren
id|serio
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|serio
)paren
)paren
suffix:semicolon
id|serio-&gt;type
op_assign
id|SERIO_8042
suffix:semicolon
id|serio-&gt;write
op_assign
id|i8042_aux_write
suffix:semicolon
id|serio-&gt;open
op_assign
id|i8042_open
suffix:semicolon
id|serio-&gt;close
op_assign
id|i8042_close
suffix:semicolon
id|serio-&gt;port_data
op_assign
op_amp
id|i8042_aux_values
comma
id|serio-&gt;dev.parent
op_assign
op_amp
id|i8042_platform_device-&gt;dev
suffix:semicolon
id|strlcpy
c_func
(paren
id|serio-&gt;name
comma
l_string|&quot;i8042 Aux Port&quot;
comma
r_sizeof
(paren
id|serio-&gt;name
)paren
)paren
suffix:semicolon
id|strlcpy
c_func
(paren
id|serio-&gt;phys
comma
id|I8042_AUX_PHYS_DESC
comma
r_sizeof
(paren
id|serio-&gt;phys
)paren
)paren
suffix:semicolon
)brace
r_return
id|serio
suffix:semicolon
)brace
DECL|function|i8042_allocate_mux_port
r_static
r_struct
id|serio
op_star
id|__init
id|i8042_allocate_mux_port
c_func
(paren
r_int
id|index
)paren
(brace
r_struct
id|serio
op_star
id|serio
suffix:semicolon
r_struct
id|i8042_values
op_star
id|values
op_assign
op_amp
id|i8042_mux_values
(braket
id|index
)braket
suffix:semicolon
id|serio
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|serio
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serio
)paren
(brace
op_star
id|values
op_assign
id|i8042_aux_values
suffix:semicolon
id|snprintf
c_func
(paren
id|values-&gt;name
comma
r_sizeof
(paren
id|values-&gt;name
)paren
comma
l_string|&quot;AUX%d&quot;
comma
id|index
)paren
suffix:semicolon
id|values-&gt;mux
op_assign
id|index
suffix:semicolon
id|memset
c_func
(paren
id|serio
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|serio
)paren
)paren
suffix:semicolon
id|serio-&gt;type
op_assign
id|SERIO_8042
suffix:semicolon
id|serio-&gt;write
op_assign
id|i8042_aux_write
suffix:semicolon
id|serio-&gt;open
op_assign
id|i8042_open
suffix:semicolon
id|serio-&gt;close
op_assign
id|i8042_close
suffix:semicolon
id|serio-&gt;port_data
op_assign
id|values
suffix:semicolon
id|serio-&gt;dev.parent
op_assign
op_amp
id|i8042_platform_device-&gt;dev
suffix:semicolon
id|snprintf
c_func
(paren
id|serio-&gt;name
comma
r_sizeof
(paren
id|serio-&gt;name
)paren
comma
l_string|&quot;i8042 Aux-%d Port&quot;
comma
id|index
)paren
suffix:semicolon
id|snprintf
c_func
(paren
id|serio-&gt;phys
comma
r_sizeof
(paren
id|serio-&gt;phys
)paren
comma
id|I8042_MUX_PHYS_DESC
comma
id|index
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_return
id|serio
suffix:semicolon
)brace
DECL|function|i8042_init
r_int
id|__init
id|i8042_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|err
suffix:semicolon
id|dbg_init
c_func
(paren
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|i8042_timer
)paren
suffix:semicolon
id|i8042_timer.function
op_assign
id|i8042_timer_func
suffix:semicolon
r_if
c_cond
(paren
id|i8042_platform_init
c_func
(paren
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|i8042_aux_values.irq
op_assign
id|I8042_AUX_IRQ
suffix:semicolon
id|i8042_kbd_values.irq
op_assign
id|I8042_KBD_IRQ
suffix:semicolon
r_if
c_cond
(paren
id|i8042_controller_init
c_func
(paren
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|err
op_assign
id|driver_register
c_func
(paren
op_amp
id|i8042_driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|i8042_platform_device
op_assign
id|platform_device_register_simple
c_func
(paren
l_string|&quot;i8042&quot;
comma
op_minus
l_int|1
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|i8042_platform_device
)paren
)paren
(brace
id|driver_unregister
c_func
(paren
op_amp
id|i8042_driver
)paren
suffix:semicolon
r_return
id|PTR_ERR
c_func
(paren
id|i8042_platform_device
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|i8042_noaux
op_logical_and
op_logical_neg
id|i8042_check_aux
c_func
(paren
op_amp
id|i8042_aux_values
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|i8042_nomux
op_logical_and
op_logical_neg
id|i8042_check_mux
c_func
(paren
op_amp
id|i8042_aux_values
)paren
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|I8042_NUM_MUX_PORTS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|i8042_mux_port
(braket
id|i
)braket
op_assign
id|i8042_allocate_mux_port
c_func
(paren
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i8042_mux_port
(braket
id|i
)braket
)paren
id|i8042_port_register
c_func
(paren
id|i8042_mux_port
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|i8042_aux_port
op_assign
id|i8042_allocate_aux_port
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i8042_aux_port
)paren
id|i8042_port_register
c_func
(paren
id|i8042_aux_port
)paren
suffix:semicolon
)brace
)brace
id|i8042_kbd_port
op_assign
id|i8042_allocate_kbd_port
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i8042_kbd_port
)paren
id|i8042_port_register
c_func
(paren
id|i8042_kbd_port
)paren
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|i8042_timer
comma
id|jiffies
op_plus
id|I8042_POLL_PERIOD
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|i8042_exit
r_void
id|__exit
id|i8042_exit
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|i8042_controller_cleanup
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i8042_kbd_values.exists
)paren
id|serio_unregister_port
c_func
(paren
id|i8042_kbd_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i8042_aux_values.exists
)paren
id|serio_unregister_port
c_func
(paren
id|i8042_aux_port
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|I8042_NUM_MUX_PORTS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|i8042_mux_values
(braket
id|i
)braket
dot
id|exists
)paren
id|serio_unregister_port
c_func
(paren
id|i8042_mux_port
(braket
id|i
)braket
)paren
suffix:semicolon
id|del_timer_sync
c_func
(paren
op_amp
id|i8042_timer
)paren
suffix:semicolon
id|platform_device_unregister
c_func
(paren
id|i8042_platform_device
)paren
suffix:semicolon
id|driver_unregister
c_func
(paren
op_amp
id|i8042_driver
)paren
suffix:semicolon
id|i8042_platform_exit
c_func
(paren
)paren
suffix:semicolon
id|panic_blink
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|variable|i8042_init
id|module_init
c_func
(paren
id|i8042_init
)paren
suffix:semicolon
DECL|variable|i8042_exit
id|module_exit
c_func
(paren
id|i8042_exit
)paren
suffix:semicolon
eof
