multiline_comment|/*&n; * Copyright (c) 2004 Topspin Communications.  All rights reserved.&n; *&n; * This software is available to you under a choice of one of two&n; * licenses.  You may choose to be licensed under the terms of the GNU&n; * General Public License (GPL) Version 2, available from the file&n; * COPYING in the main directory of this source tree, or the&n; * OpenIB.org BSD license below:&n; *&n; *     Redistribution and use in source and binary forms, with or&n; *     without modification, are permitted provided that the following&n; *     conditions are met:&n; *&n; *      - Redistributions of source code must retain the above&n; *        copyright notice, this list of conditions and the following&n; *        disclaimer.&n; *&n; *      - Redistributions in binary form must reproduce the above&n; *        copyright notice, this list of conditions and the following&n; *        disclaimer in the documentation and/or other materials&n; *        provided with the distribution.&n; *&n; * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,&n; * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF&n; * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND&n; * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS&n; * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN&n; * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN&n; * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE&n; * SOFTWARE.&n; *&n; * $Id: fmr_pool.c 1349 2004-12-16 21:09:43Z roland $&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/jhash.h&gt;
macro_line|#include &lt;linux/kthread.h&gt;
macro_line|#include &lt;ib_fmr_pool.h&gt;
macro_line|#include &quot;core_priv.h&quot;
r_enum
(brace
DECL|enumerator|IB_FMR_MAX_REMAPS
id|IB_FMR_MAX_REMAPS
op_assign
l_int|32
comma
DECL|enumerator|IB_FMR_HASH_BITS
id|IB_FMR_HASH_BITS
op_assign
l_int|8
comma
DECL|enumerator|IB_FMR_HASH_SIZE
id|IB_FMR_HASH_SIZE
op_assign
l_int|1
op_lshift
id|IB_FMR_HASH_BITS
comma
DECL|enumerator|IB_FMR_HASH_MASK
id|IB_FMR_HASH_MASK
op_assign
id|IB_FMR_HASH_SIZE
op_minus
l_int|1
)brace
suffix:semicolon
multiline_comment|/*&n; * If an FMR is not in use, then the list member will point to either&n; * its pool&squot;s free_list (if the FMR can be mapped again; that is,&n; * remap_count &lt; IB_FMR_MAX_REMAPS) or its pool&squot;s dirty_list (if the&n; * FMR needs to be unmapped before being remapped).  In either of&n; * these cases it is a bug if the ref_count is not 0.  In other words,&n; * if ref_count is &gt; 0, then the list member must not be linked into&n; * either free_list or dirty_list.&n; *&n; * The cache_node member is used to link the FMR into a cache bucket&n; * (if caching is enabled).  This is independent of the reference&n; * count of the FMR.  When a valid FMR is released, its ref_count is&n; * decremented, and if ref_count reaches 0, the FMR is placed in&n; * either free_list or dirty_list as appropriate.  However, it is not&n; * removed from the cache and may be &quot;revived&quot; if a call to&n; * ib_fmr_register_physical() occurs before the FMR is remapped.  In&n; * this case we just increment the ref_count and remove the FMR from&n; * free_list/dirty_list.&n; *&n; * Before we remap an FMR from free_list, we remove it from the cache&n; * (to prevent another user from obtaining a stale FMR).  When an FMR&n; * is released, we add it to the tail of the free list, so that our&n; * cache eviction policy is &quot;least recently used.&quot;&n; *&n; * All manipulation of ref_count, list and cache_node is protected by&n; * pool_lock to maintain consistency.&n; */
DECL|struct|ib_fmr_pool
r_struct
id|ib_fmr_pool
(brace
DECL|member|pool_lock
id|spinlock_t
id|pool_lock
suffix:semicolon
DECL|member|pool_size
r_int
id|pool_size
suffix:semicolon
DECL|member|max_pages
r_int
id|max_pages
suffix:semicolon
DECL|member|dirty_watermark
r_int
id|dirty_watermark
suffix:semicolon
DECL|member|dirty_len
r_int
id|dirty_len
suffix:semicolon
DECL|member|free_list
r_struct
id|list_head
id|free_list
suffix:semicolon
DECL|member|dirty_list
r_struct
id|list_head
id|dirty_list
suffix:semicolon
DECL|member|cache_bucket
r_struct
id|hlist_head
op_star
id|cache_bucket
suffix:semicolon
DECL|member|flush_function
r_void
(paren
op_star
id|flush_function
)paren
(paren
r_struct
id|ib_fmr_pool
op_star
id|pool
comma
r_void
op_star
id|arg
)paren
suffix:semicolon
DECL|member|flush_arg
r_void
op_star
id|flush_arg
suffix:semicolon
DECL|member|thread
r_struct
id|task_struct
op_star
id|thread
suffix:semicolon
DECL|member|req_ser
id|atomic_t
id|req_ser
suffix:semicolon
DECL|member|flush_ser
id|atomic_t
id|flush_ser
suffix:semicolon
DECL|member|force_wait
id|wait_queue_head_t
id|force_wait
suffix:semicolon
)brace
suffix:semicolon
DECL|function|ib_fmr_hash
r_static
r_inline
id|u32
id|ib_fmr_hash
c_func
(paren
id|u64
id|first_page
)paren
(brace
r_return
id|jhash_2words
c_func
(paren
(paren
id|u32
)paren
id|first_page
comma
(paren
id|u32
)paren
(paren
id|first_page
op_rshift
l_int|32
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Caller must hold pool_lock */
DECL|function|ib_fmr_cache_lookup
r_static
r_inline
r_struct
id|ib_pool_fmr
op_star
id|ib_fmr_cache_lookup
c_func
(paren
r_struct
id|ib_fmr_pool
op_star
id|pool
comma
id|u64
op_star
id|page_list
comma
r_int
id|page_list_len
comma
id|u64
id|io_virtual_address
)paren
(brace
r_struct
id|hlist_head
op_star
id|bucket
suffix:semicolon
r_struct
id|ib_pool_fmr
op_star
id|fmr
suffix:semicolon
r_struct
id|hlist_node
op_star
id|pos
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pool-&gt;cache_bucket
)paren
r_return
l_int|NULL
suffix:semicolon
id|bucket
op_assign
id|pool-&gt;cache_bucket
op_plus
id|ib_fmr_hash
c_func
(paren
op_star
id|page_list
)paren
suffix:semicolon
id|hlist_for_each_entry
c_func
(paren
id|fmr
comma
id|pos
comma
id|bucket
comma
id|cache_node
)paren
r_if
c_cond
(paren
id|io_virtual_address
op_eq
id|fmr-&gt;io_virtual_address
op_logical_and
id|page_list_len
op_eq
id|fmr-&gt;page_list_len
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|page_list
comma
id|fmr-&gt;page_list
comma
id|page_list_len
op_star
r_sizeof
op_star
id|page_list
)paren
)paren
r_return
id|fmr
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|ib_fmr_batch_release
r_static
r_void
id|ib_fmr_batch_release
c_func
(paren
r_struct
id|ib_fmr_pool
op_star
id|pool
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|ib_pool_fmr
op_star
id|fmr
suffix:semicolon
id|LIST_HEAD
c_func
(paren
id|unmap_list
)paren
suffix:semicolon
id|LIST_HEAD
c_func
(paren
id|fmr_list
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pool-&gt;pool_lock
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|fmr
comma
op_amp
id|pool-&gt;dirty_list
comma
id|list
)paren
(brace
id|hlist_del_init
c_func
(paren
op_amp
id|fmr-&gt;cache_node
)paren
suffix:semicolon
id|fmr-&gt;remap_count
op_assign
l_int|0
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|fmr-&gt;fmr-&gt;list
comma
op_amp
id|fmr_list
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|fmr-&gt;ref_count
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Unmapping FMR 0x%08x with ref count %d&quot;
comma
id|fmr
comma
id|fmr-&gt;ref_count
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
id|list_splice
c_func
(paren
op_amp
id|pool-&gt;dirty_list
comma
op_amp
id|unmap_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|pool-&gt;dirty_list
)paren
suffix:semicolon
id|pool-&gt;dirty_len
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pool-&gt;pool_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|unmap_list
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
id|ret
op_assign
id|ib_unmap_fmr
c_func
(paren
op_amp
id|fmr_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ib_unmap_fmr returned %d&quot;
comma
id|ret
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|pool-&gt;pool_lock
)paren
suffix:semicolon
id|list_splice
c_func
(paren
op_amp
id|unmap_list
comma
op_amp
id|pool-&gt;free_list
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|pool-&gt;pool_lock
)paren
suffix:semicolon
)brace
DECL|function|ib_fmr_cleanup_thread
r_static
r_int
id|ib_fmr_cleanup_thread
c_func
(paren
r_void
op_star
id|pool_ptr
)paren
(brace
r_struct
id|ib_fmr_pool
op_star
id|pool
op_assign
id|pool_ptr
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|pool-&gt;dirty_len
op_ge
id|pool-&gt;dirty_watermark
op_logical_or
id|atomic_read
c_func
(paren
op_amp
id|pool-&gt;flush_ser
)paren
op_minus
id|atomic_read
c_func
(paren
op_amp
id|pool-&gt;req_ser
)paren
OL
l_int|0
)paren
(brace
id|ib_fmr_batch_release
c_func
(paren
id|pool
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|pool-&gt;flush_ser
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|pool-&gt;force_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pool-&gt;flush_function
)paren
id|pool
op_member_access_from_pointer
id|flush_function
c_func
(paren
id|pool
comma
id|pool-&gt;flush_arg
)paren
suffix:semicolon
)brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pool-&gt;dirty_len
OL
id|pool-&gt;dirty_watermark
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|pool-&gt;flush_ser
)paren
op_minus
id|atomic_read
c_func
(paren
op_amp
id|pool-&gt;req_ser
)paren
op_ge
l_int|0
op_logical_and
op_logical_neg
id|kthread_should_stop
c_func
(paren
)paren
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|kthread_should_stop
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * ib_create_fmr_pool - Create an FMR pool&n; * @pd:Protection domain for FMRs&n; * @params:FMR pool parameters&n; *&n; * Create a pool of FMRs.  Return value is pointer to new pool or&n; * error code if creation failed.&n; */
DECL|function|ib_create_fmr_pool
r_struct
id|ib_fmr_pool
op_star
id|ib_create_fmr_pool
c_func
(paren
r_struct
id|ib_pd
op_star
id|pd
comma
r_struct
id|ib_fmr_pool_param
op_star
id|params
)paren
(brace
r_struct
id|ib_device
op_star
id|device
suffix:semicolon
r_struct
id|ib_fmr_pool
op_star
id|pool
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|params
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
id|device
op_assign
id|pd-&gt;device
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device-&gt;alloc_fmr
op_logical_or
op_logical_neg
id|device-&gt;dealloc_fmr
op_logical_or
op_logical_neg
id|device-&gt;map_phys_fmr
op_logical_or
op_logical_neg
id|device-&gt;unmap_fmr
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Device %s does not support fast memory regions&quot;
comma
id|device-&gt;name
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOSYS
)paren
suffix:semicolon
)brace
id|pool
op_assign
id|kmalloc
c_func
(paren
r_sizeof
op_star
id|pool
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pool
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;couldn&squot;t allocate pool struct&quot;
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
id|pool-&gt;cache_bucket
op_assign
l_int|NULL
suffix:semicolon
id|pool-&gt;flush_function
op_assign
id|params-&gt;flush_function
suffix:semicolon
id|pool-&gt;flush_arg
op_assign
id|params-&gt;flush_arg
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|pool-&gt;free_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|pool-&gt;dirty_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|params-&gt;cache
)paren
(brace
id|pool-&gt;cache_bucket
op_assign
id|kmalloc
c_func
(paren
id|IB_FMR_HASH_SIZE
op_star
r_sizeof
op_star
id|pool-&gt;cache_bucket
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pool-&gt;cache_bucket
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Failed to allocate cache in pool&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out_free_pool
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IB_FMR_HASH_SIZE
suffix:semicolon
op_increment
id|i
)paren
id|INIT_HLIST_HEAD
c_func
(paren
id|pool-&gt;cache_bucket
op_plus
id|i
)paren
suffix:semicolon
)brace
id|pool-&gt;pool_size
op_assign
l_int|0
suffix:semicolon
id|pool-&gt;max_pages
op_assign
id|params-&gt;max_pages_per_fmr
suffix:semicolon
id|pool-&gt;dirty_watermark
op_assign
id|params-&gt;dirty_watermark
suffix:semicolon
id|pool-&gt;dirty_len
op_assign
l_int|0
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|pool-&gt;pool_lock
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|pool-&gt;req_ser
comma
l_int|0
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|pool-&gt;flush_ser
comma
l_int|0
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|pool-&gt;force_wait
)paren
suffix:semicolon
id|pool-&gt;thread
op_assign
id|kthread_create
c_func
(paren
id|ib_fmr_cleanup_thread
comma
id|pool
comma
l_string|&quot;ib_fmr(%s)&quot;
comma
id|device-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|pool-&gt;thread
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;couldn&squot;t start cleanup thread&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|pool-&gt;thread
)paren
suffix:semicolon
r_goto
id|out_free_pool
suffix:semicolon
)brace
(brace
r_struct
id|ib_pool_fmr
op_star
id|fmr
suffix:semicolon
r_struct
id|ib_fmr_attr
id|attr
op_assign
(brace
dot
id|max_pages
op_assign
id|params-&gt;max_pages_per_fmr
comma
dot
id|max_maps
op_assign
id|IB_FMR_MAX_REMAPS
comma
dot
id|page_size
op_assign
id|PAGE_SHIFT
)brace
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|params-&gt;pool_size
suffix:semicolon
op_increment
id|i
)paren
(brace
id|fmr
op_assign
id|kmalloc
c_func
(paren
r_sizeof
op_star
id|fmr
op_plus
id|params-&gt;max_pages_per_fmr
op_star
r_sizeof
(paren
id|u64
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fmr
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;failed to allocate fmr struct &quot;
l_string|&quot;for FMR %d&quot;
comma
id|i
)paren
suffix:semicolon
r_goto
id|out_fail
suffix:semicolon
)brace
id|fmr-&gt;pool
op_assign
id|pool
suffix:semicolon
id|fmr-&gt;remap_count
op_assign
l_int|0
suffix:semicolon
id|fmr-&gt;ref_count
op_assign
l_int|0
suffix:semicolon
id|INIT_HLIST_NODE
c_func
(paren
op_amp
id|fmr-&gt;cache_node
)paren
suffix:semicolon
id|fmr-&gt;fmr
op_assign
id|ib_alloc_fmr
c_func
(paren
id|pd
comma
id|params-&gt;access
comma
op_amp
id|attr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|fmr-&gt;fmr
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;fmr_create failed for FMR %d&quot;
comma
id|i
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|fmr
)paren
suffix:semicolon
r_goto
id|out_fail
suffix:semicolon
)brace
id|list_add_tail
c_func
(paren
op_amp
id|fmr-&gt;list
comma
op_amp
id|pool-&gt;free_list
)paren
suffix:semicolon
op_increment
id|pool-&gt;pool_size
suffix:semicolon
)brace
)brace
r_return
id|pool
suffix:semicolon
id|out_free_pool
suffix:colon
id|kfree
c_func
(paren
id|pool-&gt;cache_bucket
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pool
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
id|ret
)paren
suffix:semicolon
id|out_fail
suffix:colon
id|ib_destroy_fmr_pool
c_func
(paren
id|pool
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
DECL|variable|ib_create_fmr_pool
id|EXPORT_SYMBOL
c_func
(paren
id|ib_create_fmr_pool
)paren
suffix:semicolon
multiline_comment|/**&n; * ib_destroy_fmr_pool - Free FMR pool&n; * @pool:FMR pool to free&n; *&n; * Destroy an FMR pool and free all associated resources.&n; */
DECL|function|ib_destroy_fmr_pool
r_int
id|ib_destroy_fmr_pool
c_func
(paren
r_struct
id|ib_fmr_pool
op_star
id|pool
)paren
(brace
r_struct
id|ib_pool_fmr
op_star
id|fmr
suffix:semicolon
r_struct
id|ib_pool_fmr
op_star
id|tmp
suffix:semicolon
r_int
id|i
suffix:semicolon
id|kthread_stop
c_func
(paren
id|pool-&gt;thread
)paren
suffix:semicolon
id|ib_fmr_batch_release
c_func
(paren
id|pool
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|fmr
comma
id|tmp
comma
op_amp
id|pool-&gt;free_list
comma
id|list
)paren
(brace
id|ib_dealloc_fmr
c_func
(paren
id|fmr-&gt;fmr
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|fmr-&gt;list
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|fmr
)paren
suffix:semicolon
op_increment
id|i
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
id|pool-&gt;pool_size
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;pool still has %d regions registered&quot;
comma
id|pool-&gt;pool_size
op_minus
id|i
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pool-&gt;cache_bucket
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pool
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|ib_destroy_fmr_pool
id|EXPORT_SYMBOL
c_func
(paren
id|ib_destroy_fmr_pool
)paren
suffix:semicolon
multiline_comment|/**&n; * ib_flush_fmr_pool - Invalidate all unmapped FMRs&n; * @pool:FMR pool to flush&n; *&n; * Ensure that all unmapped FMRs are fully invalidated.&n; */
DECL|function|ib_flush_fmr_pool
r_int
id|ib_flush_fmr_pool
c_func
(paren
r_struct
id|ib_fmr_pool
op_star
id|pool
)paren
(brace
r_int
id|serial
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|pool-&gt;req_ser
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * It&squot;s OK if someone else bumps req_ser again here -- we&squot;ll&n;&t; * just wait a little longer.&n;&t; */
id|serial
op_assign
id|atomic_read
c_func
(paren
op_amp
id|pool-&gt;req_ser
)paren
suffix:semicolon
id|wake_up_process
c_func
(paren
id|pool-&gt;thread
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait_event_interruptible
c_func
(paren
id|pool-&gt;force_wait
comma
id|atomic_read
c_func
(paren
op_amp
id|pool-&gt;flush_ser
)paren
op_minus
id|atomic_read
c_func
(paren
op_amp
id|pool-&gt;req_ser
)paren
op_ge
l_int|0
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|ib_flush_fmr_pool
id|EXPORT_SYMBOL
c_func
(paren
id|ib_flush_fmr_pool
)paren
suffix:semicolon
multiline_comment|/**&n; * ib_fmr_pool_map_phys -&n; * @pool:FMR pool to allocate FMR from&n; * @page_list:List of pages to map&n; * @list_len:Number of pages in @page_list&n; * @io_virtual_address:I/O virtual address for new FMR&n; *&n; * Map an FMR from an FMR pool.&n; */
DECL|function|ib_fmr_pool_map_phys
r_struct
id|ib_pool_fmr
op_star
id|ib_fmr_pool_map_phys
c_func
(paren
r_struct
id|ib_fmr_pool
op_star
id|pool_handle
comma
id|u64
op_star
id|page_list
comma
r_int
id|list_len
comma
id|u64
op_star
id|io_virtual_address
)paren
(brace
r_struct
id|ib_fmr_pool
op_star
id|pool
op_assign
id|pool_handle
suffix:semicolon
r_struct
id|ib_pool_fmr
op_star
id|fmr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|result
suffix:semicolon
r_if
c_cond
(paren
id|list_len
template_param
id|pool-&gt;max_pages
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pool-&gt;pool_lock
comma
id|flags
)paren
suffix:semicolon
id|fmr
op_assign
id|ib_fmr_cache_lookup
c_func
(paren
id|pool
comma
id|page_list
comma
id|list_len
comma
op_star
id|io_virtual_address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fmr
)paren
(brace
multiline_comment|/* found in cache */
op_increment
id|fmr-&gt;ref_count
suffix:semicolon
r_if
c_cond
(paren
id|fmr-&gt;ref_count
op_eq
l_int|1
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|fmr-&gt;list
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pool-&gt;pool_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|fmr
suffix:semicolon
)brace
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|pool-&gt;free_list
)paren
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pool-&gt;pool_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EAGAIN
)paren
suffix:semicolon
)brace
id|fmr
op_assign
id|list_entry
c_func
(paren
id|pool-&gt;free_list.next
comma
r_struct
id|ib_pool_fmr
comma
id|list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|fmr-&gt;list
)paren
suffix:semicolon
id|hlist_del_init
c_func
(paren
op_amp
id|fmr-&gt;cache_node
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pool-&gt;pool_lock
comma
id|flags
)paren
suffix:semicolon
id|result
op_assign
id|ib_map_phys_fmr
c_func
(paren
id|fmr-&gt;fmr
comma
id|page_list
comma
id|list_len
comma
op_star
id|io_virtual_address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pool-&gt;pool_lock
comma
id|flags
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|fmr-&gt;list
comma
op_amp
id|pool-&gt;free_list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pool-&gt;pool_lock
comma
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;fmr_map returns %d&quot;
comma
id|result
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
id|result
)paren
suffix:semicolon
)brace
op_increment
id|fmr-&gt;remap_count
suffix:semicolon
id|fmr-&gt;ref_count
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|pool-&gt;cache_bucket
)paren
(brace
id|fmr-&gt;io_virtual_address
op_assign
op_star
id|io_virtual_address
suffix:semicolon
id|fmr-&gt;page_list_len
op_assign
id|list_len
suffix:semicolon
id|memcpy
c_func
(paren
id|fmr-&gt;page_list
comma
id|page_list
comma
id|list_len
op_star
r_sizeof
(paren
op_star
id|page_list
)paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pool-&gt;pool_lock
comma
id|flags
)paren
suffix:semicolon
id|hlist_add_head
c_func
(paren
op_amp
id|fmr-&gt;cache_node
comma
id|pool-&gt;cache_bucket
op_plus
id|ib_fmr_hash
c_func
(paren
id|fmr-&gt;page_list
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pool-&gt;pool_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|fmr
suffix:semicolon
)brace
DECL|variable|ib_fmr_pool_map_phys
id|EXPORT_SYMBOL
c_func
(paren
id|ib_fmr_pool_map_phys
)paren
suffix:semicolon
multiline_comment|/**&n; * ib_fmr_pool_unmap - Unmap FMR&n; * @fmr:FMR to unmap&n; *&n; * Unmap an FMR.  The FMR mapping may remain valid until the FMR is&n; * reused (or until ib_flush_fmr_pool() is called).&n; */
DECL|function|ib_fmr_pool_unmap
r_int
id|ib_fmr_pool_unmap
c_func
(paren
r_struct
id|ib_pool_fmr
op_star
id|fmr
)paren
(brace
r_struct
id|ib_fmr_pool
op_star
id|pool
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|pool
op_assign
id|fmr-&gt;pool
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pool-&gt;pool_lock
comma
id|flags
)paren
suffix:semicolon
op_decrement
id|fmr-&gt;ref_count
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fmr-&gt;ref_count
)paren
(brace
r_if
c_cond
(paren
id|fmr-&gt;remap_count
OL
id|IB_FMR_MAX_REMAPS
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
id|fmr-&gt;list
comma
op_amp
id|pool-&gt;free_list
)paren
suffix:semicolon
)brace
r_else
(brace
id|list_add_tail
c_func
(paren
op_amp
id|fmr-&gt;list
comma
op_amp
id|pool-&gt;dirty_list
)paren
suffix:semicolon
op_increment
id|pool-&gt;dirty_len
suffix:semicolon
id|wake_up_process
c_func
(paren
id|pool-&gt;thread
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|fmr-&gt;ref_count
OL
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;FMR %p has ref count %d &lt; 0&quot;
comma
id|fmr
comma
id|fmr-&gt;ref_count
)paren
suffix:semicolon
macro_line|#endif
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pool-&gt;pool_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|ib_fmr_pool_unmap
id|EXPORT_SYMBOL
c_func
(paren
id|ib_fmr_pool_unmap
)paren
suffix:semicolon
eof
