multiline_comment|/*&n; * drivers/sh/superhyway/superhyway.c&n; *&n; * SuperHyway Bus Driver&n; *&n; * Copyright (C) 2004, 2005  Paul Mundt &lt;lethal@linux-sh.org&gt;&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/superhyway.h&gt;
DECL|variable|superhyway_devices
r_static
r_int
id|superhyway_devices
suffix:semicolon
DECL|variable|superhyway_bus_device
r_static
r_struct
id|device
id|superhyway_bus_device
op_assign
(brace
dot
id|bus_id
op_assign
l_string|&quot;superhyway&quot;
comma
)brace
suffix:semicolon
DECL|function|superhyway_device_release
r_static
r_void
id|superhyway_device_release
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|kfree
c_func
(paren
id|to_superhyway_device
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * superhyway_add_device - Add a SuperHyway module&n; * @mod_id: Module ID (taken from MODULE.VCR.MOD_ID).&n; * @base: Physical address where module is mapped.&n; * @vcr: VCR value.&n; *&n; * This is responsible for adding a new SuperHyway module. This sets up a new&n; * struct superhyway_device for the module being added. Each one of @mod_id,&n; * @base, and @vcr are registered with the new device for further use&n; * elsewhere.&n; *&n; * Devices are initially added in the order that they are scanned (from the&n; * top-down of the memory map), and are assigned an ID based on the order that&n; * they are added. Any manual addition of a module will thus get the ID after&n; * the devices already discovered regardless of where it resides in memory.&n; *&n; * Further work can and should be done in superhyway_scan_bus(), to be sure&n; * that any new modules are properly discovered and subsequently registered.&n; */
DECL|function|superhyway_add_device
r_int
id|superhyway_add_device
c_func
(paren
r_int
r_int
id|mod_id
comma
r_int
r_int
id|base
comma
r_int
r_int
r_int
id|vcr
)paren
(brace
r_struct
id|superhyway_device
op_star
id|dev
suffix:semicolon
id|dev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|superhyway_device
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|dev
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|superhyway_device
)paren
)paren
suffix:semicolon
id|dev-&gt;id.id
op_assign
id|mod_id
suffix:semicolon
id|sprintf
c_func
(paren
id|dev-&gt;name
comma
l_string|&quot;SuperHyway device %04x&quot;
comma
id|dev-&gt;id.id
)paren
suffix:semicolon
id|dev-&gt;vcr
op_assign
op_star
(paren
(paren
r_struct
id|vcr_info
op_star
)paren
(paren
op_amp
id|vcr
)paren
)paren
suffix:semicolon
id|dev-&gt;resource.name
op_assign
id|dev-&gt;name
suffix:semicolon
id|dev-&gt;resource.start
op_assign
id|base
suffix:semicolon
id|dev-&gt;resource.end
op_assign
id|dev-&gt;resource.start
op_plus
l_int|0x01000000
suffix:semicolon
id|dev-&gt;dev.parent
op_assign
op_amp
id|superhyway_bus_device
suffix:semicolon
id|dev-&gt;dev.bus
op_assign
op_amp
id|superhyway_bus_type
suffix:semicolon
id|dev-&gt;dev.release
op_assign
id|superhyway_device_release
suffix:semicolon
id|sprintf
c_func
(paren
id|dev-&gt;dev.bus_id
comma
l_string|&quot;%02x&quot;
comma
id|superhyway_devices
)paren
suffix:semicolon
id|superhyway_devices
op_increment
suffix:semicolon
r_return
id|device_register
c_func
(paren
op_amp
id|dev-&gt;dev
)paren
suffix:semicolon
)brace
DECL|function|superhyway_init
r_static
r_int
id|__init
id|superhyway_init
c_func
(paren
r_void
)paren
(brace
id|device_register
c_func
(paren
op_amp
id|superhyway_bus_device
)paren
suffix:semicolon
r_return
id|superhyway_scan_bus
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|superhyway_init
id|postcore_initcall
c_func
(paren
id|superhyway_init
)paren
suffix:semicolon
r_static
r_const
r_struct
id|superhyway_device_id
op_star
DECL|function|superhyway_match_id
id|superhyway_match_id
c_func
(paren
r_const
r_struct
id|superhyway_device_id
op_star
id|ids
comma
r_struct
id|superhyway_device
op_star
id|dev
)paren
(brace
r_while
c_loop
(paren
id|ids-&gt;id
)paren
(brace
r_if
c_cond
(paren
id|ids-&gt;id
op_eq
id|dev-&gt;id.id
)paren
r_return
id|ids
suffix:semicolon
id|ids
op_increment
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|superhyway_device_probe
r_static
r_int
id|superhyway_device_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|superhyway_device
op_star
id|shyway_dev
op_assign
id|to_superhyway_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|superhyway_driver
op_star
id|shyway_drv
op_assign
id|to_superhyway_driver
c_func
(paren
id|dev-&gt;driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shyway_drv
op_logical_and
id|shyway_drv-&gt;probe
)paren
(brace
r_const
r_struct
id|superhyway_device_id
op_star
id|id
suffix:semicolon
id|id
op_assign
id|superhyway_match_id
c_func
(paren
id|shyway_drv-&gt;id_table
comma
id|shyway_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id
)paren
r_return
id|shyway_drv
op_member_access_from_pointer
id|probe
c_func
(paren
id|shyway_dev
comma
id|id
)paren
suffix:semicolon
)brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|function|superhyway_device_remove
r_static
r_int
id|superhyway_device_remove
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|superhyway_device
op_star
id|shyway_dev
op_assign
id|to_superhyway_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|superhyway_driver
op_star
id|shyway_drv
op_assign
id|to_superhyway_driver
c_func
(paren
id|dev-&gt;driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shyway_drv
op_logical_and
id|shyway_drv-&gt;remove
)paren
(brace
id|shyway_drv
op_member_access_from_pointer
id|remove
c_func
(paren
id|shyway_dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/**&n; * superhyway_register_driver - Register a new SuperHyway driver&n; * @drv: SuperHyway driver to register.&n; *&n; * This registers the passed in @drv. Any devices matching the id table will&n; * automatically be populated and handed off to the driver&squot;s specified probe&n; * routine.&n; */
DECL|function|superhyway_register_driver
r_int
id|superhyway_register_driver
c_func
(paren
r_struct
id|superhyway_driver
op_star
id|drv
)paren
(brace
id|drv-&gt;drv.name
op_assign
id|drv-&gt;name
suffix:semicolon
id|drv-&gt;drv.bus
op_assign
op_amp
id|superhyway_bus_type
suffix:semicolon
id|drv-&gt;drv.probe
op_assign
id|superhyway_device_probe
suffix:semicolon
id|drv-&gt;drv.remove
op_assign
id|superhyway_device_remove
suffix:semicolon
r_return
id|driver_register
c_func
(paren
op_amp
id|drv-&gt;drv
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * superhyway_unregister_driver - Unregister a SuperHyway driver&n; * @drv: SuperHyway driver to unregister.&n; *&n; * This cleans up after superhyway_register_driver(), and should be invoked in&n; * the exit path of any module drivers.&n; */
DECL|function|superhyway_unregister_driver
r_void
id|superhyway_unregister_driver
c_func
(paren
r_struct
id|superhyway_driver
op_star
id|drv
)paren
(brace
id|driver_unregister
c_func
(paren
op_amp
id|drv-&gt;drv
)paren
suffix:semicolon
)brace
DECL|function|superhyway_bus_match
r_static
r_int
id|superhyway_bus_match
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|device_driver
op_star
id|drv
)paren
(brace
r_struct
id|superhyway_device
op_star
id|shyway_dev
op_assign
id|to_superhyway_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|superhyway_driver
op_star
id|shyway_drv
op_assign
id|to_superhyway_driver
c_func
(paren
id|drv
)paren
suffix:semicolon
r_const
r_struct
id|superhyway_device_id
op_star
id|ids
op_assign
id|shyway_drv-&gt;id_table
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ids
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|superhyway_match_id
c_func
(paren
id|ids
comma
id|shyway_dev
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|variable|superhyway_bus_type
r_struct
id|bus_type
id|superhyway_bus_type
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;superhyway&quot;
comma
dot
id|match
op_assign
id|superhyway_bus_match
comma
macro_line|#ifdef CONFIG_SYSFS
dot
id|dev_attrs
op_assign
id|superhyway_dev_attrs
comma
macro_line|#endif
)brace
suffix:semicolon
DECL|function|superhyway_bus_init
r_static
r_int
id|__init
id|superhyway_bus_init
c_func
(paren
r_void
)paren
(brace
r_return
id|bus_register
c_func
(paren
op_amp
id|superhyway_bus_type
)paren
suffix:semicolon
)brace
DECL|function|superhyway_bus_exit
r_static
r_void
id|__exit
id|superhyway_bus_exit
c_func
(paren
r_void
)paren
(brace
id|device_unregister
c_func
(paren
op_amp
id|superhyway_bus_device
)paren
suffix:semicolon
id|bus_unregister
c_func
(paren
op_amp
id|superhyway_bus_type
)paren
suffix:semicolon
)brace
DECL|variable|superhyway_bus_init
id|core_initcall
c_func
(paren
id|superhyway_bus_init
)paren
suffix:semicolon
DECL|variable|superhyway_bus_exit
id|module_exit
c_func
(paren
id|superhyway_bus_exit
)paren
suffix:semicolon
DECL|variable|superhyway_bus_type
id|EXPORT_SYMBOL
c_func
(paren
id|superhyway_bus_type
)paren
suffix:semicolon
DECL|variable|superhyway_add_device
id|EXPORT_SYMBOL
c_func
(paren
id|superhyway_add_device
)paren
suffix:semicolon
DECL|variable|superhyway_register_driver
id|EXPORT_SYMBOL
c_func
(paren
id|superhyway_register_driver
)paren
suffix:semicolon
DECL|variable|superhyway_unregister_driver
id|EXPORT_SYMBOL
c_func
(paren
id|superhyway_unregister_driver
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
