singleline_comment|// ip2.c
singleline_comment|// This is a dummy module to make the firmware available when needed
singleline_comment|// and allows it to be unloaded when not. Rumor is the __initdata 
singleline_comment|// macro doesn&squot;t always works on all platforms so we use this kludge.
singleline_comment|// If not compiled as a module it just makes fip_firm avaliable then
singleline_comment|//  __initdata should work as advertized
singleline_comment|//
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#ifndef __init
DECL|macro|__init
mdefine_line|#define __init
macro_line|#endif
macro_line|#ifndef __initfunc
DECL|macro|__initfunc
mdefine_line|#define __initfunc(a) a
macro_line|#endif
macro_line|#ifndef __initdata
DECL|macro|__initdata
mdefine_line|#define __initdata
macro_line|#endif
macro_line|#include &quot;./ip2/ip2types.h&quot;&t;&t;
macro_line|#include &quot;./ip2/fip_firm.h&quot;&t;&t;
singleline_comment|// the meat
r_int
id|ip2_loadmain
c_func
(paren
r_int
op_star
comma
r_int
op_star
comma
r_int
r_char
op_star
comma
r_int
)paren
suffix:semicolon
singleline_comment|// ref into ip2main.c
multiline_comment|/* Note: Add compiled in defaults to these arrays, not to the structure&n;&t;in ip2/ip2.h any longer.  That structure WILL get overridden&n;&t;by these values, or command line values, or insmod values!!!  =mhw=&n;*/
DECL|variable|io
r_static
r_int
id|io
(braket
id|IP2_MAX_BOARDS
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|irq
r_static
r_int
id|irq
(braket
id|IP2_MAX_BOARDS
)braket
op_assign
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
suffix:semicolon
DECL|variable|poll_only
r_static
r_int
id|poll_only
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef MODULE
macro_line|#&t;if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,1,0)
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Doug McNash&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Computone IntelliPort Plus Driver&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|irq
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|IP2_MAX_BOARDS
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|irq
comma
l_string|&quot;Interrupts for IntelliPort Cards&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|io
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|IP2_MAX_BOARDS
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|io
comma
l_string|&quot;I/O ports for IntelliPort Cards&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|poll_only
comma
l_string|&quot;1i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|poll_only
comma
l_string|&quot;Do not use card interrupts&quot;
)paren
suffix:semicolon
macro_line|#&t;endif&t;/* LINUX_VERSION */
singleline_comment|//======================================================================
r_int
DECL|function|init_module
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|rc
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
singleline_comment|// hold till done 
r_if
c_cond
(paren
id|poll_only
)paren
(brace
multiline_comment|/* Hard lock the interrupts to zero */
id|irq
(braket
l_int|0
)braket
op_assign
id|irq
(braket
l_int|1
)braket
op_assign
id|irq
(braket
l_int|2
)braket
op_assign
id|irq
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|rc
op_assign
id|ip2_loadmain
c_func
(paren
id|io
comma
id|irq
comma
(paren
r_int
r_char
op_star
)paren
id|fip_firm
comma
r_sizeof
(paren
id|fip_firm
)paren
)paren
suffix:semicolon
singleline_comment|// The call to lock and load main, create dep 
id|MOD_DEC_USE_COUNT
suffix:semicolon
singleline_comment|//done - kerneld now can unload us
r_return
id|rc
suffix:semicolon
)brace
singleline_comment|//======================================================================
r_int
DECL|function|ip2_init
id|ip2_init
c_func
(paren
r_void
)paren
(brace
singleline_comment|// call to this is in tty_io.c so we need this
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|//======================================================================
r_void
DECL|function|cleanup_module
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
)brace
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
macro_line|#else&t;
singleline_comment|// !MODULE 
macro_line|#ifndef NULL
DECL|macro|NULL
macro_line|# define NULL&t;&t;((void *) 0)
macro_line|#endif
multiline_comment|/******************************************************************************&n; *&t;ip2_setup:&n; *&t;&t;str: kernel command line string&n; *&n; *&t;Can&squot;t autoprobe the boards so user must specify configuration on&n; *&t;kernel command line.  Sane people build it modular but the others&n; *&t;come here.&n; *&n; *&t;Alternating pairs of io,irq for up to 4 boards.&n; *&t;&t;ip2=io0,irq0,io1,irq1,io2,irq2,io3,irq3&n; *&n; *&t;&t;io=0 =&gt; No board&n; *&t;&t;io=1 =&gt; PCI&n; *&t;&t;io=2 =&gt; EISA&n; *&t;&t;else =&gt; ISA I/O address&n; *&n; *&t;&t;irq=0 or invalid for ISA will revert to polling mode&n; *&n; *&t;&t;Any value = -1, do not overwrite compiled in value.&n; *&n; ******************************************************************************/
DECL|function|ip2_setup
r_static
r_int
id|__init
id|ip2_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|ints
(braket
l_int|10
)braket
suffix:semicolon
multiline_comment|/* 4 boards, 2 parameters + 2 */
r_int
id|i
comma
id|j
suffix:semicolon
id|str
op_assign
id|get_options
(paren
id|str
comma
id|ARRAY_SIZE
c_func
(paren
id|ints
)paren
comma
id|ints
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|j
OG
id|ints
(braket
l_int|0
)braket
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ints
(braket
id|j
)braket
op_ge
l_int|0
)paren
(brace
id|io
(braket
id|i
)braket
op_assign
id|ints
(braket
id|j
)braket
suffix:semicolon
)brace
id|j
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|j
OG
id|ints
(braket
l_int|0
)braket
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ints
(braket
id|j
)braket
op_ge
l_int|0
)paren
(brace
id|irq
(braket
id|i
)braket
op_assign
id|ints
(braket
id|j
)braket
suffix:semicolon
)brace
id|j
op_increment
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_int
DECL|function|ip2_init
id|ip2_init
c_func
(paren
r_void
)paren
(brace
r_return
id|ip2_loadmain
c_func
(paren
id|io
comma
id|irq
comma
(paren
r_int
r_char
op_star
)paren
id|fip_firm
comma
r_sizeof
(paren
id|fip_firm
)paren
)paren
suffix:semicolon
)brace
macro_line|#if (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,3,13))
id|__setup
c_func
(paren
l_string|&quot;ip2=&quot;
comma
id|ip2_setup
)paren
suffix:semicolon
DECL|variable|ip2_init
id|__initcall
c_func
(paren
id|ip2_init
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif /* !MODULE */
eof
