multiline_comment|/*&n; * random.c -- A strong random number generator&n; *&n; * Version 1.89, last modified 19-Sep-99&n; *&n; * Copyright Theodore Ts&squot;o, 1994, 1995, 1996, 1997, 1998, 1999.  All&n; * rights reserved.&n; *&n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions&n; * are met:&n; * 1. Redistributions of source code must retain the above copyright&n; *    notice, and the entire permission notice in its entirety,&n; *    including the disclaimer of warranties.&n; * 2. Redistributions in binary form must reproduce the above copyright&n; *    notice, this list of conditions and the following disclaimer in the&n; *    documentation and/or other materials provided with the distribution.&n; * 3. The name of the author may not be used to endorse or promote&n; *    products derived from this software without specific prior&n; *    written permission.&n; *&n; * ALTERNATIVELY, this product may be distributed under the terms of&n; * the GNU General Public License, in which case the provisions of the GPL are&n; * required INSTEAD OF the above restrictions.  (This clause is&n; * necessary due to a potential bad interaction between the GPL and&n; * the restrictions contained in a BSD-style copyright.)&n; *&n; * THIS SOFTWARE IS PROVIDED ``AS IS&squot;&squot; AND ANY EXPRESS OR IMPLIED&n; * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES&n; * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ALL OF&n; * WHICH ARE HEREBY DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE&n; * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR&n; * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT&n; * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR&n; * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF&n; * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT&n; * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE&n; * USE OF THIS SOFTWARE, EVEN IF NOT ADVISED OF THE POSSIBILITY OF SUCH&n; * DAMAGE.&n; */
multiline_comment|/*&n; * (now, with legal B.S. out of the way.....)&n; *&n; * This routine gathers environmental noise from device drivers, etc.,&n; * and returns good random numbers, suitable for cryptographic use.&n; * Besides the obvious cryptographic uses, these numbers are also good&n; * for seeding TCP sequence numbers, and other places where it is&n; * desirable to have numbers which are not only random, but hard to&n; * predict by an attacker.&n; *&n; * Theory of operation&n; * ===================&n; *&n; * Computers are very predictable devices.  Hence it is extremely hard&n; * to produce truly random numbers on a computer --- as opposed to&n; * pseudo-random numbers, which can easily generated by using a&n; * algorithm.  Unfortunately, it is very easy for attackers to guess&n; * the sequence of pseudo-random number generators, and for some&n; * applications this is not acceptable.  So instead, we must try to&n; * gather &quot;environmental noise&quot; from the computer&squot;s environment, which&n; * must be hard for outside attackers to observe, and use that to&n; * generate random numbers.  In a Unix environment, this is best done&n; * from inside the kernel.&n; *&n; * Sources of randomness from the environment include inter-keyboard&n; * timings, inter-interrupt timings from some interrupts, and other&n; * events which are both (a) non-deterministic and (b) hard for an&n; * outside observer to measure.  Randomness from these sources are&n; * added to an &quot;entropy pool&quot;, which is mixed using a CRC-like function.&n; * This is not cryptographically strong, but it is adequate assuming&n; * the randomness is not chosen maliciously, and it is fast enough that&n; * the overhead of doing it on every interrupt is very reasonable.&n; * As random bytes are mixed into the entropy pool, the routines keep&n; * an *estimate* of how many bits of randomness have been stored into&n; * the random number generator&squot;s internal state.&n; *&n; * When random bytes are desired, they are obtained by taking the SHA&n; * hash of the contents of the &quot;entropy pool&quot;.  The SHA hash avoids&n; * exposing the internal state of the entropy pool.  It is believed to&n; * be computationally infeasible to derive any useful information&n; * about the input of SHA from its output.  Even if it is possible to&n; * analyze SHA in some clever way, as long as the amount of data&n; * returned from the generator is less than the inherent entropy in&n; * the pool, the output data is totally unpredictable.  For this&n; * reason, the routine decreases its internal estimate of how many&n; * bits of &quot;true randomness&quot; are contained in the entropy pool as it&n; * outputs random numbers.&n; *&n; * If this estimate goes to zero, the routine can still generate&n; * random numbers; however, an attacker may (at least in theory) be&n; * able to infer the future output of the generator from prior&n; * outputs.  This requires successful cryptanalysis of SHA, which is&n; * not believed to be feasible, but there is a remote possibility.&n; * Nonetheless, these numbers should be useful for the vast majority&n; * of purposes.&n; *&n; * Exported interfaces ---- output&n; * ===============================&n; *&n; * There are three exported interfaces; the first is one designed to&n; * be used from within the kernel:&n; *&n; * &t;void get_random_bytes(void *buf, int nbytes);&n; *&n; * This interface will return the requested number of random bytes,&n; * and place it in the requested buffer.&n; *&n; * The two other interfaces are two character devices /dev/random and&n; * /dev/urandom.  /dev/random is suitable for use when very high&n; * quality randomness is desired (for example, for key generation or&n; * one-time pads), as it will only return a maximum of the number of&n; * bits of randomness (as estimated by the random number generator)&n; * contained in the entropy pool.&n; *&n; * The /dev/urandom device does not have this limit, and will return&n; * as many bytes as are requested.  As more and more random bytes are&n; * requested without giving time for the entropy pool to recharge,&n; * this will result in random numbers that are merely cryptographically&n; * strong.  For many applications, however, this is acceptable.&n; *&n; * Exported interfaces ---- input&n; * ==============================&n; *&n; * The current exported interfaces for gathering environmental noise&n; * from the devices are:&n; *&n; * &t;void add_input_randomness(unsigned int type, unsigned int code,&n; *                                unsigned int value);&n; * &t;void add_interrupt_randomness(int irq);&n; *&n; * add_input_randomness() uses the input layer interrupt timing, as well as&n; * the event type information from the hardware.&n; *&n; * add_interrupt_randomness() uses the inter-interrupt timing as random&n; * inputs to the entropy pool.  Note that not all interrupts are good&n; * sources of randomness!  For example, the timer interrupts is not a&n; * good choice, because the periodicity of the interrupts is too&n; * regular, and hence predictable to an attacker.  Disk interrupts are&n; * a better measure, since the timing of the disk interrupts are more&n; * unpredictable.&n; *&n; * All of these routines try to estimate how many bits of randomness a&n; * particular randomness source.  They do this by keeping track of the&n; * first and second order deltas of the event timings.&n; *&n; * Ensuring unpredictability at system startup&n; * ============================================&n; *&n; * When any operating system starts up, it will go through a sequence&n; * of actions that are fairly predictable by an adversary, especially&n; * if the start-up does not involve interaction with a human operator.&n; * This reduces the actual number of bits of unpredictability in the&n; * entropy pool below the value in entropy_count.  In order to&n; * counteract this effect, it helps to carry information in the&n; * entropy pool across shut-downs and start-ups.  To do this, put the&n; * following lines an appropriate script which is run during the boot&n; * sequence:&n; *&n; *&t;echo &quot;Initializing random number generator...&quot;&n; *&t;random_seed=/var/run/random-seed&n; *&t;# Carry a random seed from start-up to start-up&n; *&t;# Load and then save the whole entropy pool&n; *&t;if [ -f $random_seed ]; then&n; *&t;&t;cat $random_seed &gt;/dev/urandom&n; *&t;else&n; *&t;&t;touch $random_seed&n; *&t;fi&n; *&t;chmod 600 $random_seed&n; *&t;dd if=/dev/urandom of=$random_seed count=1 bs=512&n; *&n; * and the following lines in an appropriate script which is run as&n; * the system is shutdown:&n; *&n; *&t;# Carry a random seed from shut-down to start-up&n; *&t;# Save the whole entropy pool&n; *&t;echo &quot;Saving random seed...&quot;&n; *&t;random_seed=/var/run/random-seed&n; *&t;touch $random_seed&n; *&t;chmod 600 $random_seed&n; *&t;dd if=/dev/urandom of=$random_seed count=1 bs=512&n; *&n; * For example, on most modern systems using the System V init&n; * scripts, such code fragments would be found in&n; * /etc/rc.d/init.d/random.  On older Linux systems, the correct script&n; * location might be in /etc/rcb.d/rc.local or /etc/rc.d/rc.0.&n; *&n; * Effectively, these commands cause the contents of the entropy pool&n; * to be saved at shut-down time and reloaded into the entropy pool at&n; * start-up.  (The &squot;dd&squot; in the addition to the bootup script is to&n; * make sure that /etc/random-seed is different for every start-up,&n; * even if the system crashes without executing rc.0.)  Even with&n; * complete knowledge of the start-up activities, predicting the state&n; * of the entropy pool requires knowledge of the previous history of&n; * the system.&n; *&n; * Configuring the /dev/random driver under Linux&n; * ==============================================&n; *&n; * The /dev/random driver under Linux uses minor numbers 8 and 9 of&n; * the /dev/mem major number (#1).  So if your system does not have&n; * /dev/random and /dev/urandom created already, they can be created&n; * by using the commands:&n; *&n; * &t;mknod /dev/random c 1 8&n; * &t;mknod /dev/urandom c 1 9&n; *&n; * Acknowledgements:&n; * =================&n; *&n; * Ideas for constructing this random number generator were derived&n; * from Pretty Good Privacy&squot;s random number generator, and from private&n; * discussions with Phil Karn.  Colin Plumb provided a faster random&n; * number generator, which speed up the mixing function of the entropy&n; * pool, taken from PGPfone.  Dale Worley has also contributed many&n; * useful ideas and suggestions to improve this driver.&n; *&n; * Any flaws in the design are solely my responsibility, and should&n; * not be attributed to the Phil, Colin, or any of authors of PGP.&n; *&n; * The code for SHA transform was taken from Peter Gutmann&squot;s&n; * implementation, which has been placed in the public domain.&n; *&n; * Further background information on this topic may be obtained from&n; * RFC 1750, &quot;Randomness Recommendations for Security&quot;, by Donald&n; * Eastlake, Steve Crocker, and Jeff Schiller.&n; */
macro_line|#include &lt;linux/utsname.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/random.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/workqueue.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/percpu.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/io.h&gt;
multiline_comment|/*&n; * Configuration information&n; */
DECL|macro|INPUT_POOL_WORDS
mdefine_line|#define INPUT_POOL_WORDS 128
DECL|macro|OUTPUT_POOL_WORDS
mdefine_line|#define OUTPUT_POOL_WORDS 32
DECL|macro|BATCH_ENTROPY_SIZE
mdefine_line|#define BATCH_ENTROPY_SIZE 256
DECL|macro|SEC_XFER_SIZE
mdefine_line|#define SEC_XFER_SIZE 512
multiline_comment|/*&n; * The minimum number of bits of entropy before we wake up a read on&n; * /dev/random.  Should be enough to do a significant reseed.&n; */
DECL|variable|random_read_wakeup_thresh
r_static
r_int
id|random_read_wakeup_thresh
op_assign
l_int|64
suffix:semicolon
multiline_comment|/*&n; * If the entropy count falls under this number of bits, then we&n; * should wake up processes which are selecting or polling on write&n; * access to /dev/random.&n; */
DECL|variable|random_write_wakeup_thresh
r_static
r_int
id|random_write_wakeup_thresh
op_assign
l_int|128
suffix:semicolon
multiline_comment|/*&n; * When the input pool goes over trickle_thresh, start dropping most&n; * samples to avoid wasting CPU time and reduce lock contention.&n; */
DECL|variable|trickle_thresh
r_static
r_int
id|trickle_thresh
op_assign
id|INPUT_POOL_WORDS
op_star
l_int|28
suffix:semicolon
r_static
id|DEFINE_PER_CPU
c_func
(paren
r_int
comma
id|trickle_count
)paren
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * A pool of size .poolwords is stirred with a primitive polynomial&n; * of degree .poolwords over GF(2).  The taps for various sizes are&n; * defined below.  They are chosen to be evenly spaced (minimum RMS&n; * distance from evenly spaced; the numbers in the comments are a&n; * scaled squared error sum) except for the last tap, which is 1 to&n; * get the twisting happening as fast as possible.&n; */
DECL|struct|poolinfo
r_static
r_struct
id|poolinfo
(brace
DECL|member|poolwords
r_int
id|poolwords
suffix:semicolon
DECL|member|tap1
DECL|member|tap2
DECL|member|tap3
DECL|member|tap4
DECL|member|tap5
r_int
id|tap1
comma
id|tap2
comma
id|tap3
comma
id|tap4
comma
id|tap5
suffix:semicolon
DECL|variable|poolinfo_table
)brace
id|poolinfo_table
(braket
)braket
op_assign
(brace
multiline_comment|/* x^128 + x^103 + x^76 + x^51 +x^25 + x + 1 -- 105 */
(brace
l_int|128
comma
l_int|103
comma
l_int|76
comma
l_int|51
comma
l_int|25
comma
l_int|1
)brace
comma
multiline_comment|/* x^32 + x^26 + x^20 + x^14 + x^7 + x + 1 -- 15 */
(brace
l_int|32
comma
l_int|26
comma
l_int|20
comma
l_int|14
comma
l_int|7
comma
l_int|1
)brace
comma
macro_line|#if 0
multiline_comment|/* x^2048 + x^1638 + x^1231 + x^819 + x^411 + x + 1  -- 115 */
(brace
l_int|2048
comma
l_int|1638
comma
l_int|1231
comma
l_int|819
comma
l_int|411
comma
l_int|1
)brace
comma
multiline_comment|/* x^1024 + x^817 + x^615 + x^412 + x^204 + x + 1 -- 290 */
(brace
l_int|1024
comma
l_int|817
comma
l_int|615
comma
l_int|412
comma
l_int|204
comma
l_int|1
)brace
comma
multiline_comment|/* x^1024 + x^819 + x^616 + x^410 + x^207 + x^2 + 1 -- 115 */
(brace
l_int|1024
comma
l_int|819
comma
l_int|616
comma
l_int|410
comma
l_int|207
comma
l_int|2
)brace
comma
multiline_comment|/* x^512 + x^411 + x^308 + x^208 + x^104 + x + 1 -- 225 */
(brace
l_int|512
comma
l_int|411
comma
l_int|308
comma
l_int|208
comma
l_int|104
comma
l_int|1
)brace
comma
multiline_comment|/* x^512 + x^409 + x^307 + x^206 + x^102 + x^2 + 1 -- 95 */
(brace
l_int|512
comma
l_int|409
comma
l_int|307
comma
l_int|206
comma
l_int|102
comma
l_int|2
)brace
comma
multiline_comment|/* x^512 + x^409 + x^309 + x^205 + x^103 + x^2 + 1 -- 95 */
(brace
l_int|512
comma
l_int|409
comma
l_int|309
comma
l_int|205
comma
l_int|103
comma
l_int|2
)brace
comma
multiline_comment|/* x^256 + x^205 + x^155 + x^101 + x^52 + x + 1 -- 125 */
(brace
l_int|256
comma
l_int|205
comma
l_int|155
comma
l_int|101
comma
l_int|52
comma
l_int|1
)brace
comma
multiline_comment|/* x^128 + x^103 + x^78 + x^51 + x^27 + x^2 + 1 -- 70 */
(brace
l_int|128
comma
l_int|103
comma
l_int|78
comma
l_int|51
comma
l_int|27
comma
l_int|2
)brace
comma
multiline_comment|/* x^64 + x^52 + x^39 + x^26 + x^14 + x + 1 -- 15 */
(brace
l_int|64
comma
l_int|52
comma
l_int|39
comma
l_int|26
comma
l_int|14
comma
l_int|1
)brace
comma
macro_line|#endif
)brace
suffix:semicolon
DECL|macro|POOLBITS
mdefine_line|#define POOLBITS&t;poolwords*32
DECL|macro|POOLBYTES
mdefine_line|#define POOLBYTES&t;poolwords*4
multiline_comment|/*&n; * For the purposes of better mixing, we use the CRC-32 polynomial as&n; * well to make a twisted Generalized Feedback Shift Reigster&n; *&n; * (See M. Matsumoto &amp; Y. Kurita, 1992.  Twisted GFSR generators.  ACM&n; * Transactions on Modeling and Computer Simulation 2(3):179-194.&n; * Also see M. Matsumoto &amp; Y. Kurita, 1994.  Twisted GFSR generators&n; * II.  ACM Transactions on Mdeling and Computer Simulation 4:254-266)&n; *&n; * Thanks to Colin Plumb for suggesting this.&n; *&n; * We have not analyzed the resultant polynomial to prove it primitive;&n; * in fact it almost certainly isn&squot;t.  Nonetheless, the irreducible factors&n; * of a random large-degree polynomial over GF(2) are more than large enough&n; * that periodicity is not a concern.&n; *&n; * The input hash is much less sensitive than the output hash.  All&n; * that we want of it is that it be a good non-cryptographic hash;&n; * i.e. it not produce collisions when fed &quot;random&quot; data of the sort&n; * we expect to see.  As long as the pool state differs for different&n; * inputs, we have preserved the input entropy and done a good job.&n; * The fact that an intelligent attacker can construct inputs that&n; * will produce controlled alterations to the pool&squot;s state is not&n; * important because we don&squot;t consider such inputs to contribute any&n; * randomness.  The only property we need with respect to them is that&n; * the attacker can&squot;t increase his/her knowledge of the pool&squot;s state.&n; * Since all additions are reversible (knowing the final state and the&n; * input, you can reconstruct the initial state), if an attacker has&n; * any uncertainty about the initial state, he/she can only shuffle&n; * that uncertainty about, but never cause any collisions (which would&n; * decrease the uncertainty).&n; *&n; * The chosen system lets the state of the pool be (essentially) the input&n; * modulo the generator polymnomial.  Now, for random primitive polynomials,&n; * this is a universal class of hash functions, meaning that the chance&n; * of a collision is limited by the attacker&squot;s knowledge of the generator&n; * polynomail, so if it is chosen at random, an attacker can never force&n; * a collision.  Here, we use a fixed polynomial, but we *can* assume that&n; * ###--&gt; it is unknown to the processes generating the input entropy. &lt;-###&n; * Because of this important property, this is a good, collision-resistant&n; * hash; hash collisions will occur no more often than chance.&n; */
multiline_comment|/*&n; * Static global variables&n; */
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|random_read_wait
)paren
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|random_write_wait
)paren
suffix:semicolon
DECL|function|rol32
r_static
r_inline
id|__u32
id|rol32
c_func
(paren
id|__u32
id|word
comma
r_int
id|shift
)paren
(brace
r_return
(paren
id|word
op_lshift
id|shift
)paren
op_or
(paren
id|word
op_rshift
(paren
l_int|32
op_minus
id|shift
)paren
)paren
suffix:semicolon
)brace
macro_line|#if 0
r_static
r_int
id|debug
op_assign
l_int|0
suffix:semicolon
id|module_param
c_func
(paren
id|debug
comma
r_bool
comma
l_int|0644
)paren
suffix:semicolon
mdefine_line|#define DEBUG_ENT(fmt, arg...) do { if (debug) &bslash;&n;&t;printk(KERN_DEBUG &quot;random %04d %04d %04d: &quot; &bslash;&n;&t;fmt,&bslash;&n;&t;input_pool.entropy_count,&bslash;&n;&t;blocking_pool.entropy_count,&bslash;&n;&t;nonblocking_pool.entropy_count,&bslash;&n;&t;## arg); } while (0)
macro_line|#else
DECL|macro|DEBUG_ENT
mdefine_line|#define DEBUG_ENT(fmt, arg...) do {} while (0)
macro_line|#endif
multiline_comment|/**********************************************************************&n; *&n; * OS independent entropy store.   Here are the functions which handle&n; * storing entropy in an entropy pool.&n; *&n; **********************************************************************/
r_struct
id|entropy_store
suffix:semicolon
DECL|struct|entropy_store
r_struct
id|entropy_store
(brace
multiline_comment|/* mostly-read data: */
DECL|member|poolinfo
r_struct
id|poolinfo
op_star
id|poolinfo
suffix:semicolon
DECL|member|pool
id|__u32
op_star
id|pool
suffix:semicolon
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|limit
r_int
id|limit
suffix:semicolon
DECL|member|pull
r_struct
id|entropy_store
op_star
id|pull
suffix:semicolon
multiline_comment|/* read-write data: */
DECL|member|____cacheline_aligned_in_smp
id|spinlock_t
id|lock
id|____cacheline_aligned_in_smp
suffix:semicolon
DECL|member|add_ptr
r_int
id|add_ptr
suffix:semicolon
DECL|member|entropy_count
r_int
id|entropy_count
suffix:semicolon
DECL|member|input_rotate
r_int
id|input_rotate
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|input_pool_data
r_static
id|__u32
id|input_pool_data
(braket
id|INPUT_POOL_WORDS
)braket
suffix:semicolon
DECL|variable|blocking_pool_data
r_static
id|__u32
id|blocking_pool_data
(braket
id|OUTPUT_POOL_WORDS
)braket
suffix:semicolon
DECL|variable|nonblocking_pool_data
r_static
id|__u32
id|nonblocking_pool_data
(braket
id|OUTPUT_POOL_WORDS
)braket
suffix:semicolon
DECL|variable|input_pool
r_static
r_struct
id|entropy_store
id|input_pool
op_assign
(brace
dot
id|poolinfo
op_assign
op_amp
id|poolinfo_table
(braket
l_int|0
)braket
comma
dot
id|name
op_assign
l_string|&quot;input&quot;
comma
dot
id|limit
op_assign
l_int|1
comma
dot
id|lock
op_assign
id|SPIN_LOCK_UNLOCKED
comma
dot
id|pool
op_assign
id|input_pool_data
)brace
suffix:semicolon
DECL|variable|blocking_pool
r_static
r_struct
id|entropy_store
id|blocking_pool
op_assign
(brace
dot
id|poolinfo
op_assign
op_amp
id|poolinfo_table
(braket
l_int|1
)braket
comma
dot
id|name
op_assign
l_string|&quot;blocking&quot;
comma
dot
id|limit
op_assign
l_int|1
comma
dot
id|pull
op_assign
op_amp
id|input_pool
comma
dot
id|lock
op_assign
id|SPIN_LOCK_UNLOCKED
comma
dot
id|pool
op_assign
id|blocking_pool_data
)brace
suffix:semicolon
DECL|variable|nonblocking_pool
r_static
r_struct
id|entropy_store
id|nonblocking_pool
op_assign
(brace
dot
id|poolinfo
op_assign
op_amp
id|poolinfo_table
(braket
l_int|1
)braket
comma
dot
id|name
op_assign
l_string|&quot;nonblocking&quot;
comma
dot
id|pull
op_assign
op_amp
id|input_pool
comma
dot
id|lock
op_assign
id|SPIN_LOCK_UNLOCKED
comma
dot
id|pool
op_assign
id|nonblocking_pool_data
)brace
suffix:semicolon
multiline_comment|/*&n; * This function adds a byte into the entropy &quot;pool&quot;.  It does not&n; * update the entropy estimate.  The caller should call&n; * credit_entropy_store if this is appropriate.&n; *&n; * The pool is stirred with a primitive polynomial of the appropriate&n; * degree, and then twisted.  We twist by three bits at a time because&n; * it&squot;s cheap to do so and helps slightly in the expected case where&n; * the entropy is concentrated in the low-order bits.&n; */
DECL|function|__add_entropy_words
r_static
r_void
id|__add_entropy_words
c_func
(paren
r_struct
id|entropy_store
op_star
id|r
comma
r_const
id|__u32
op_star
id|in
comma
r_int
id|nwords
comma
id|__u32
id|out
(braket
l_int|16
)braket
)paren
(brace
r_static
id|__u32
r_const
id|twist_table
(braket
l_int|8
)braket
op_assign
(brace
l_int|0x00000000
comma
l_int|0x3b6e20c8
comma
l_int|0x76dc4190
comma
l_int|0x4db26158
comma
l_int|0xedb88320
comma
l_int|0xd6d6a3e8
comma
l_int|0x9b64c2b0
comma
l_int|0xa00ae278
)brace
suffix:semicolon
r_int
r_int
id|i
comma
id|add_ptr
comma
id|tap1
comma
id|tap2
comma
id|tap3
comma
id|tap4
comma
id|tap5
suffix:semicolon
r_int
id|new_rotate
comma
id|input_rotate
suffix:semicolon
r_int
id|wordmask
op_assign
id|r-&gt;poolinfo-&gt;poolwords
op_minus
l_int|1
suffix:semicolon
id|__u32
id|w
comma
id|next_w
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Taps are constant, so we can load them without holding r-&gt;lock.  */
id|tap1
op_assign
id|r-&gt;poolinfo-&gt;tap1
suffix:semicolon
id|tap2
op_assign
id|r-&gt;poolinfo-&gt;tap2
suffix:semicolon
id|tap3
op_assign
id|r-&gt;poolinfo-&gt;tap3
suffix:semicolon
id|tap4
op_assign
id|r-&gt;poolinfo-&gt;tap4
suffix:semicolon
id|tap5
op_assign
id|r-&gt;poolinfo-&gt;tap5
suffix:semicolon
id|next_w
op_assign
op_star
id|in
op_increment
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|r-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|prefetch_range
c_func
(paren
id|r-&gt;pool
comma
id|wordmask
)paren
suffix:semicolon
id|input_rotate
op_assign
id|r-&gt;input_rotate
suffix:semicolon
id|add_ptr
op_assign
id|r-&gt;add_ptr
suffix:semicolon
r_while
c_loop
(paren
id|nwords
op_decrement
)paren
(brace
id|w
op_assign
id|rol32
c_func
(paren
id|next_w
comma
id|input_rotate
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nwords
OG
l_int|0
)paren
id|next_w
op_assign
op_star
id|in
op_increment
suffix:semicolon
id|i
op_assign
id|add_ptr
op_assign
(paren
id|add_ptr
op_minus
l_int|1
)paren
op_amp
id|wordmask
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Normally, we add 7 bits of rotation to the pool.&n;&t;&t; * At the beginning of the pool, add an extra 7 bits&n;&t;&t; * rotation, so that successive passes spread the&n;&t;&t; * input bits across the pool evenly.&n;&t;&t; */
id|new_rotate
op_assign
id|input_rotate
op_plus
l_int|14
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
id|new_rotate
op_assign
id|input_rotate
op_plus
l_int|7
suffix:semicolon
id|input_rotate
op_assign
id|new_rotate
op_amp
l_int|31
suffix:semicolon
multiline_comment|/* XOR in the various taps */
id|w
op_xor_assign
id|r-&gt;pool
(braket
(paren
id|i
op_plus
id|tap1
)paren
op_amp
id|wordmask
)braket
suffix:semicolon
id|w
op_xor_assign
id|r-&gt;pool
(braket
(paren
id|i
op_plus
id|tap2
)paren
op_amp
id|wordmask
)braket
suffix:semicolon
id|w
op_xor_assign
id|r-&gt;pool
(braket
(paren
id|i
op_plus
id|tap3
)paren
op_amp
id|wordmask
)braket
suffix:semicolon
id|w
op_xor_assign
id|r-&gt;pool
(braket
(paren
id|i
op_plus
id|tap4
)paren
op_amp
id|wordmask
)braket
suffix:semicolon
id|w
op_xor_assign
id|r-&gt;pool
(braket
(paren
id|i
op_plus
id|tap5
)paren
op_amp
id|wordmask
)braket
suffix:semicolon
id|w
op_xor_assign
id|r-&gt;pool
(braket
id|i
)braket
suffix:semicolon
id|r-&gt;pool
(braket
id|i
)braket
op_assign
(paren
id|w
op_rshift
l_int|3
)paren
op_xor
id|twist_table
(braket
id|w
op_amp
l_int|7
)braket
suffix:semicolon
)brace
id|r-&gt;input_rotate
op_assign
id|input_rotate
suffix:semicolon
id|r-&gt;add_ptr
op_assign
id|add_ptr
suffix:semicolon
r_if
c_cond
(paren
id|out
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|out
(braket
id|i
)braket
op_assign
id|r-&gt;pool
(braket
id|add_ptr
)braket
suffix:semicolon
id|add_ptr
op_assign
(paren
id|add_ptr
op_minus
l_int|1
)paren
op_amp
id|wordmask
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|r-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|add_entropy_words
r_static
r_inline
r_void
id|add_entropy_words
c_func
(paren
r_struct
id|entropy_store
op_star
id|r
comma
r_const
id|__u32
op_star
id|in
comma
r_int
id|nwords
)paren
(brace
id|__add_entropy_words
c_func
(paren
id|r
comma
id|in
comma
id|nwords
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Credit (or debit) the entropy store with n bits of entropy&n; */
DECL|function|credit_entropy_store
r_static
r_void
id|credit_entropy_store
c_func
(paren
r_struct
id|entropy_store
op_star
id|r
comma
r_int
id|nbits
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|r-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;entropy_count
op_plus
id|nbits
OL
l_int|0
)paren
(brace
id|DEBUG_ENT
c_func
(paren
l_string|&quot;negative entropy/overflow (%d+%d)&bslash;n&quot;
comma
id|r-&gt;entropy_count
comma
id|nbits
)paren
suffix:semicolon
id|r-&gt;entropy_count
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|r-&gt;entropy_count
op_plus
id|nbits
OG
id|r-&gt;poolinfo-&gt;POOLBITS
)paren
(brace
id|r-&gt;entropy_count
op_assign
id|r-&gt;poolinfo-&gt;POOLBITS
suffix:semicolon
)brace
r_else
(brace
id|r-&gt;entropy_count
op_add_assign
id|nbits
suffix:semicolon
r_if
c_cond
(paren
id|nbits
)paren
id|DEBUG_ENT
c_func
(paren
l_string|&quot;added %d entropy credits to %s&bslash;n&quot;
comma
id|nbits
comma
id|r-&gt;name
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|r-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**********************************************************************&n; *&n; * Entropy batch input management&n; *&n; * We batch entropy to be added to avoid increasing interrupt latency&n; *&n; **********************************************************************/
DECL|struct|sample
r_struct
id|sample
(brace
DECL|member|data
id|__u32
id|data
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|credit
r_int
id|credit
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|batch_entropy_pool
DECL|variable|batch_entropy_copy
r_static
r_struct
id|sample
op_star
id|batch_entropy_pool
comma
op_star
id|batch_entropy_copy
suffix:semicolon
DECL|variable|batch_head
DECL|variable|batch_tail
r_static
r_int
id|batch_head
comma
id|batch_tail
suffix:semicolon
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|batch_lock
)paren
suffix:semicolon
DECL|variable|batch_max
r_static
r_int
id|batch_max
suffix:semicolon
r_static
r_void
id|batch_entropy_process
c_func
(paren
r_void
op_star
id|private_
)paren
suffix:semicolon
r_static
id|DECLARE_WORK
c_func
(paren
id|batch_work
comma
id|batch_entropy_process
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* note: the size must be a power of 2 */
DECL|function|batch_entropy_init
r_static
r_int
id|__init
id|batch_entropy_init
c_func
(paren
r_int
id|size
comma
r_struct
id|entropy_store
op_star
id|r
)paren
(brace
id|batch_entropy_pool
op_assign
id|kmalloc
c_func
(paren
id|size
op_star
r_sizeof
(paren
r_struct
id|sample
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|batch_entropy_pool
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|batch_entropy_copy
op_assign
id|kmalloc
c_func
(paren
id|size
op_star
r_sizeof
(paren
r_struct
id|sample
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|batch_entropy_copy
)paren
(brace
id|kfree
c_func
(paren
id|batch_entropy_pool
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|batch_head
op_assign
id|batch_tail
op_assign
l_int|0
suffix:semicolon
id|batch_work.data
op_assign
id|r
suffix:semicolon
id|batch_max
op_assign
id|size
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Changes to the entropy data is put into a queue rather than being added to&n; * the entropy counts directly.  This is presumably to avoid doing heavy&n; * hashing calculations during an interrupt in add_timer_randomness().&n; * Instead, the entropy is only added to the pool by keventd.&n; */
DECL|function|batch_entropy_store
r_static
r_void
id|batch_entropy_store
c_func
(paren
id|u32
id|a
comma
id|u32
id|b
comma
r_int
id|num
)paren
(brace
r_int
r_new
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|batch_max
)paren
r_return
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|batch_lock
comma
id|flags
)paren
suffix:semicolon
id|batch_entropy_pool
(braket
id|batch_head
)braket
dot
id|data
(braket
l_int|0
)braket
op_assign
id|a
suffix:semicolon
id|batch_entropy_pool
(braket
id|batch_head
)braket
dot
id|data
(braket
l_int|1
)braket
op_assign
id|b
suffix:semicolon
id|batch_entropy_pool
(braket
id|batch_head
)braket
dot
id|credit
op_assign
id|num
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|batch_head
op_minus
id|batch_tail
)paren
op_amp
(paren
id|batch_max
op_minus
l_int|1
)paren
)paren
op_ge
(paren
id|batch_max
op_div
l_int|2
)paren
)paren
id|schedule_delayed_work
c_func
(paren
op_amp
id|batch_work
comma
l_int|1
)paren
suffix:semicolon
r_new
op_assign
(paren
id|batch_head
op_plus
l_int|1
)paren
op_amp
(paren
id|batch_max
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
op_eq
id|batch_tail
)paren
id|DEBUG_ENT
c_func
(paren
l_string|&quot;batch entropy buffer full&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|batch_head
op_assign
r_new
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|batch_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Flush out the accumulated entropy operations, adding entropy to the&n; * input pool.  If that pool has enough entropy, alternate&n; * between randomizing the data of all pools.&n; */
DECL|function|batch_entropy_process
r_static
r_void
id|batch_entropy_process
c_func
(paren
r_void
op_star
id|private_
)paren
(brace
r_struct
id|entropy_store
op_star
id|r
op_assign
(paren
r_struct
id|entropy_store
op_star
)paren
id|private_
comma
op_star
id|p
suffix:semicolon
r_int
id|max_entropy
op_assign
id|r-&gt;poolinfo-&gt;POOLBITS
suffix:semicolon
r_int
id|head
comma
id|tail
suffix:semicolon
multiline_comment|/* Mixing into the pool is expensive, so copy over the batch&n;&t; * data and release the batch lock. The pool is at least half&n;&t; * full, so don&squot;t worry too much about copying only the used&n;&t; * part.&n;&t; */
id|spin_lock_irq
c_func
(paren
op_amp
id|batch_lock
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|batch_entropy_copy
comma
id|batch_entropy_pool
comma
id|batch_max
op_star
r_sizeof
(paren
r_struct
id|sample
)paren
)paren
suffix:semicolon
id|head
op_assign
id|batch_head
suffix:semicolon
id|tail
op_assign
id|batch_tail
suffix:semicolon
id|batch_tail
op_assign
id|batch_head
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|batch_lock
)paren
suffix:semicolon
id|p
op_assign
id|r
suffix:semicolon
r_while
c_loop
(paren
id|head
op_ne
id|tail
)paren
(brace
r_if
c_cond
(paren
id|r-&gt;entropy_count
op_ge
id|max_entropy
)paren
(brace
id|r
op_assign
(paren
id|r
op_eq
op_amp
id|blocking_pool
)paren
ques
c_cond
op_amp
id|input_pool
suffix:colon
op_amp
id|blocking_pool
suffix:semicolon
id|max_entropy
op_assign
id|r-&gt;poolinfo-&gt;POOLBITS
suffix:semicolon
)brace
id|add_entropy_words
c_func
(paren
id|r
comma
id|batch_entropy_copy
(braket
id|tail
)braket
dot
id|data
comma
l_int|2
)paren
suffix:semicolon
id|credit_entropy_store
c_func
(paren
id|r
comma
id|batch_entropy_copy
(braket
id|tail
)braket
dot
id|credit
)paren
suffix:semicolon
id|tail
op_assign
(paren
id|tail
op_plus
l_int|1
)paren
op_amp
(paren
id|batch_max
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;entropy_count
op_ge
id|random_read_wakeup_thresh
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|random_read_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*********************************************************************&n; *&n; * Entropy input management&n; *&n; *********************************************************************/
multiline_comment|/* There is one of these per entropy source */
DECL|struct|timer_rand_state
r_struct
id|timer_rand_state
(brace
DECL|member|last_time
id|cycles_t
id|last_time
suffix:semicolon
DECL|member|last_delta
DECL|member|last_delta2
r_int
id|last_delta
comma
id|last_delta2
suffix:semicolon
DECL|member|dont_count_entropy
r_int
id|dont_count_entropy
suffix:colon
l_int|1
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|input_timer_state
r_static
r_struct
id|timer_rand_state
id|input_timer_state
suffix:semicolon
DECL|variable|irq_timer_state
r_static
r_struct
id|timer_rand_state
op_star
id|irq_timer_state
(braket
id|NR_IRQS
)braket
suffix:semicolon
multiline_comment|/*&n; * This function adds entropy to the entropy &quot;pool&quot; by using timing&n; * delays.  It uses the timer_rand_state structure to make an estimate&n; * of how many bits of entropy this call has added to the pool.&n; *&n; * The number &quot;num&quot; is also added to the pool - it should somehow describe&n; * the type of event which just happened.  This is currently 0-255 for&n; * keyboard scan codes, and 256 upwards for interrupts.&n; *&n; */
DECL|function|add_timer_randomness
r_static
r_void
id|add_timer_randomness
c_func
(paren
r_struct
id|timer_rand_state
op_star
id|state
comma
r_int
id|num
)paren
(brace
id|cycles_t
id|data
suffix:semicolon
r_int
id|delta
comma
id|delta2
comma
id|delta3
comma
id|time
suffix:semicolon
r_int
id|entropy
op_assign
l_int|0
suffix:semicolon
id|preempt_disable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* if over the trickle threshold, use only 1 in 4096 samples */
r_if
c_cond
(paren
id|input_pool.entropy_count
OG
id|trickle_thresh
op_logical_and
(paren
id|__get_cpu_var
c_func
(paren
id|trickle_count
)paren
op_increment
op_amp
l_int|0xfff
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate number of bits of randomness we probably added.&n;&t; * We take into account the first, second and third-order deltas&n;&t; * in order to make our estimate.&n;&t; */
id|time
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;dont_count_entropy
)paren
(brace
id|delta
op_assign
id|time
op_minus
id|state-&gt;last_time
suffix:semicolon
id|state-&gt;last_time
op_assign
id|time
suffix:semicolon
id|delta2
op_assign
id|delta
op_minus
id|state-&gt;last_delta
suffix:semicolon
id|state-&gt;last_delta
op_assign
id|delta
suffix:semicolon
id|delta3
op_assign
id|delta2
op_minus
id|state-&gt;last_delta2
suffix:semicolon
id|state-&gt;last_delta2
op_assign
id|delta2
suffix:semicolon
r_if
c_cond
(paren
id|delta
OL
l_int|0
)paren
id|delta
op_assign
op_minus
id|delta
suffix:semicolon
r_if
c_cond
(paren
id|delta2
OL
l_int|0
)paren
id|delta2
op_assign
op_minus
id|delta2
suffix:semicolon
r_if
c_cond
(paren
id|delta3
OL
l_int|0
)paren
id|delta3
op_assign
op_minus
id|delta3
suffix:semicolon
r_if
c_cond
(paren
id|delta
OG
id|delta2
)paren
id|delta
op_assign
id|delta2
suffix:semicolon
r_if
c_cond
(paren
id|delta
OG
id|delta3
)paren
id|delta
op_assign
id|delta3
suffix:semicolon
multiline_comment|/*&n;&t;&t; * delta is now minimum absolute delta.&n;&t;&t; * Round down by 1 bit on general principles,&n;&t;&t; * and limit entropy entimate to 12 bits.&n;&t;&t; */
id|entropy
op_assign
id|min_t
c_func
(paren
r_int
comma
id|fls
c_func
(paren
id|delta
op_rshift
l_int|1
)paren
comma
l_int|11
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Use get_cycles() if implemented, otherwise fall back to&n;&t; * jiffies.&n;&t; */
id|data
op_assign
id|get_cycles
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
)paren
id|num
op_xor_assign
(paren
id|u32
)paren
(paren
(paren
id|data
op_rshift
l_int|31
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
r_else
id|data
op_assign
id|time
suffix:semicolon
id|batch_entropy_store
c_func
(paren
id|num
comma
id|data
comma
id|entropy
)paren
suffix:semicolon
id|out
suffix:colon
id|preempt_enable
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|add_input_randomness
r_extern
r_void
id|add_input_randomness
c_func
(paren
r_int
r_int
id|type
comma
r_int
r_int
id|code
comma
r_int
r_int
id|value
)paren
(brace
r_static
r_int
r_char
id|last_value
suffix:semicolon
multiline_comment|/* ignore autorepeat and the like */
r_if
c_cond
(paren
id|value
op_eq
id|last_value
)paren
r_return
suffix:semicolon
id|DEBUG_ENT
c_func
(paren
l_string|&quot;input event&bslash;n&quot;
)paren
suffix:semicolon
id|last_value
op_assign
id|value
suffix:semicolon
id|add_timer_randomness
c_func
(paren
op_amp
id|input_timer_state
comma
(paren
id|type
op_lshift
l_int|4
)paren
op_xor
id|code
op_xor
(paren
id|code
op_rshift
l_int|4
)paren
op_xor
id|value
)paren
suffix:semicolon
)brace
DECL|function|add_interrupt_randomness
r_void
id|add_interrupt_randomness
c_func
(paren
r_int
id|irq
)paren
(brace
r_if
c_cond
(paren
id|irq
op_ge
id|NR_IRQS
op_logical_or
id|irq_timer_state
(braket
id|irq
)braket
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|DEBUG_ENT
c_func
(paren
l_string|&quot;irq event %d&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
id|add_timer_randomness
c_func
(paren
id|irq_timer_state
(braket
id|irq
)braket
comma
l_int|0x100
op_plus
id|irq
)paren
suffix:semicolon
)brace
DECL|function|add_disk_randomness
r_void
id|add_disk_randomness
c_func
(paren
r_struct
id|gendisk
op_star
id|disk
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|disk
op_logical_or
op_logical_neg
id|disk-&gt;random
)paren
r_return
suffix:semicolon
multiline_comment|/* first major is 1, so we get &gt;= 0x200 here */
id|DEBUG_ENT
c_func
(paren
l_string|&quot;disk event %d:%d&bslash;n&quot;
comma
id|disk-&gt;major
comma
id|disk-&gt;first_minor
)paren
suffix:semicolon
id|add_timer_randomness
c_func
(paren
id|disk-&gt;random
comma
l_int|0x100
op_plus
id|MKDEV
c_func
(paren
id|disk-&gt;major
comma
id|disk-&gt;first_minor
)paren
)paren
suffix:semicolon
)brace
DECL|variable|add_disk_randomness
id|EXPORT_SYMBOL
c_func
(paren
id|add_disk_randomness
)paren
suffix:semicolon
multiline_comment|/******************************************************************&n; *&n; * Hash function definition&n; *&n; *******************************************************************/
multiline_comment|/*&n; * This chunk of code defines a function&n; * void sha_transform(__u32 digest[HASH_BUFFER_SIZE + HASH_EXTRA_SIZE],&n; * &t;&t;__u32 const data[16])&n; *&n; * The function hashes the input data to produce a digest in the first&n; * HASH_BUFFER_SIZE words of the digest[] array, and uses HASH_EXTRA_SIZE&n; * more words for internal purposes.  (This buffer is exported so the&n; * caller can wipe it once rather than this code doing it each call,&n; * and tacking it onto the end of the digest[] array is the quick and&n; * dirty way of doing it.)&n; *&n; * For /dev/random purposes, the length of the data being hashed is&n; * fixed in length, so appending a bit count in the usual way is not&n; * cryptographically necessary.&n; */
DECL|macro|HASH_BUFFER_SIZE
mdefine_line|#define HASH_BUFFER_SIZE 5
DECL|macro|EXTRACT_SIZE
mdefine_line|#define EXTRACT_SIZE 10
DECL|macro|HASH_EXTRA_SIZE
mdefine_line|#define HASH_EXTRA_SIZE 80
multiline_comment|/* Various size/speed tradeoffs are available.  Choose 0..3. */
DECL|macro|SHA_CODE_SIZE
mdefine_line|#define SHA_CODE_SIZE 0
multiline_comment|/*&n; * SHA transform algorithm, taken from code written by Peter Gutmann,&n; * and placed in the public domain.&n; */
multiline_comment|/* The SHA f()-functions.  */
DECL|macro|f1
mdefine_line|#define f1(x,y,z)   (z ^ (x &amp; (y ^ z)))&t;&t;/* Rounds  0-19: x ? y : z */
DECL|macro|f2
mdefine_line|#define f2(x,y,z)   (x ^ y ^ z)&t;&t;&t;/* Rounds 20-39: XOR */
DECL|macro|f3
mdefine_line|#define f3(x,y,z)   ((x &amp; y) + (z &amp; (x ^ y)))&t;/* Rounds 40-59: majority */
DECL|macro|f4
mdefine_line|#define f4(x,y,z)   (x ^ y ^ z)&t;&t;&t;/* Rounds 60-79: XOR */
multiline_comment|/* The SHA Mysterious Constants */
DECL|macro|K1
mdefine_line|#define K1  0x5A827999L&t;&t;&t;/* Rounds  0-19: sqrt(2) * 2^30 */
DECL|macro|K2
mdefine_line|#define K2  0x6ED9EBA1L&t;&t;&t;/* Rounds 20-39: sqrt(3) * 2^30 */
DECL|macro|K3
mdefine_line|#define K3  0x8F1BBCDCL&t;&t;&t;/* Rounds 40-59: sqrt(5) * 2^30 */
DECL|macro|K4
mdefine_line|#define K4  0xCA62C1D6L&t;&t;&t;/* Rounds 60-79: sqrt(10) * 2^30 */
DECL|macro|subRound
mdefine_line|#define subRound(a, b, c, d, e, f, k, data) &bslash;&n;    (e += rol32(a, 5) + f(b, c, d) + k + data, b = rol32(b, 30))
DECL|function|sha_transform
r_static
r_void
id|sha_transform
c_func
(paren
id|__u32
id|digest
(braket
l_int|85
)braket
comma
id|__u32
r_const
id|data
(braket
l_int|16
)braket
)paren
(brace
id|__u32
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
suffix:semicolon
multiline_comment|/* Local vars */
id|__u32
id|TEMP
suffix:semicolon
r_int
id|i
suffix:semicolon
DECL|macro|W
mdefine_line|#define W (digest + HASH_BUFFER_SIZE)&t;/* Expanded data array */
multiline_comment|/*&n;&t; * Do the preliminary expansion of 16 to 80 words.  Doing it&n;&t; * out-of-line line this is faster than doing it in-line on&n;&t; * register-starved machines like the x86, and not really any&n;&t; * slower on real processors.&n;&t; */
id|memcpy
c_func
(paren
id|W
comma
id|data
comma
l_int|16
op_star
r_sizeof
(paren
id|__u32
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|64
suffix:semicolon
id|i
op_increment
)paren
(brace
id|TEMP
op_assign
id|W
(braket
id|i
)braket
op_xor
id|W
(braket
id|i
op_plus
l_int|2
)braket
op_xor
id|W
(braket
id|i
op_plus
l_int|8
)braket
op_xor
id|W
(braket
id|i
op_plus
l_int|13
)braket
suffix:semicolon
id|W
(braket
id|i
op_plus
l_int|16
)braket
op_assign
id|rol32
c_func
(paren
id|TEMP
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Set up first buffer and local data buffer */
id|A
op_assign
id|digest
(braket
l_int|0
)braket
suffix:semicolon
id|B
op_assign
id|digest
(braket
l_int|1
)braket
suffix:semicolon
id|C
op_assign
id|digest
(braket
l_int|2
)braket
suffix:semicolon
id|D
op_assign
id|digest
(braket
l_int|3
)braket
suffix:semicolon
id|E
op_assign
id|digest
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* Heavy mangling, in 4 sub-rounds of 20 iterations each. */
macro_line|#if SHA_CODE_SIZE == 0
multiline_comment|/*&n;&t; * Approximately 50% of the speed of the largest version, but&n;&t; * takes up 1/16 the space.  Saves about 6k on an i386 kernel.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|80
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
OL
l_int|40
)paren
(brace
r_if
c_cond
(paren
id|i
OL
l_int|20
)paren
id|TEMP
op_assign
id|f1
c_func
(paren
id|B
comma
id|C
comma
id|D
)paren
op_plus
id|K1
suffix:semicolon
r_else
id|TEMP
op_assign
id|f2
c_func
(paren
id|B
comma
id|C
comma
id|D
)paren
op_plus
id|K2
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|i
OL
l_int|60
)paren
id|TEMP
op_assign
id|f3
c_func
(paren
id|B
comma
id|C
comma
id|D
)paren
op_plus
id|K3
suffix:semicolon
r_else
id|TEMP
op_assign
id|f4
c_func
(paren
id|B
comma
id|C
comma
id|D
)paren
op_plus
id|K4
suffix:semicolon
)brace
id|TEMP
op_add_assign
id|rol32
c_func
(paren
id|A
comma
l_int|5
)paren
op_plus
id|E
op_plus
id|W
(braket
id|i
)braket
suffix:semicolon
id|E
op_assign
id|D
suffix:semicolon
id|D
op_assign
id|C
suffix:semicolon
id|C
op_assign
id|rol32
c_func
(paren
id|B
comma
l_int|30
)paren
suffix:semicolon
id|B
op_assign
id|A
suffix:semicolon
id|A
op_assign
id|TEMP
suffix:semicolon
)brace
macro_line|#elif SHA_CODE_SIZE == 1
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|20
suffix:semicolon
id|i
op_increment
)paren
(brace
id|TEMP
op_assign
id|f1
c_func
(paren
id|B
comma
id|C
comma
id|D
)paren
op_plus
id|K1
op_plus
id|rol32
c_func
(paren
id|A
comma
l_int|5
)paren
op_plus
id|E
op_plus
id|W
(braket
id|i
)braket
suffix:semicolon
id|E
op_assign
id|D
suffix:semicolon
id|D
op_assign
id|C
suffix:semicolon
id|C
op_assign
id|rol32
c_func
(paren
id|B
comma
l_int|30
)paren
suffix:semicolon
id|B
op_assign
id|A
suffix:semicolon
id|A
op_assign
id|TEMP
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
l_int|40
suffix:semicolon
id|i
op_increment
)paren
(brace
id|TEMP
op_assign
id|f2
c_func
(paren
id|B
comma
id|C
comma
id|D
)paren
op_plus
id|K2
op_plus
id|rol32
c_func
(paren
id|A
comma
l_int|5
)paren
op_plus
id|E
op_plus
id|W
(braket
id|i
)braket
suffix:semicolon
id|E
op_assign
id|D
suffix:semicolon
id|D
op_assign
id|C
suffix:semicolon
id|C
op_assign
id|rol32
c_func
(paren
id|B
comma
l_int|30
)paren
suffix:semicolon
id|B
op_assign
id|A
suffix:semicolon
id|A
op_assign
id|TEMP
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
l_int|60
suffix:semicolon
id|i
op_increment
)paren
(brace
id|TEMP
op_assign
id|f3
c_func
(paren
id|B
comma
id|C
comma
id|D
)paren
op_plus
id|K3
op_plus
id|rol32
c_func
(paren
id|A
comma
l_int|5
)paren
op_plus
id|E
op_plus
id|W
(braket
id|i
)braket
suffix:semicolon
id|E
op_assign
id|D
suffix:semicolon
id|D
op_assign
id|C
suffix:semicolon
id|C
op_assign
id|rol22
c_func
(paren
id|B
comma
l_int|30
)paren
suffix:semicolon
id|B
op_assign
id|A
suffix:semicolon
id|A
op_assign
id|TEMP
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
l_int|80
suffix:semicolon
id|i
op_increment
)paren
(brace
id|TEMP
op_assign
id|f4
c_func
(paren
id|B
comma
id|C
comma
id|D
)paren
op_plus
id|K4
op_plus
id|rol32
c_func
(paren
id|A
comma
l_int|5
)paren
op_plus
id|E
op_plus
id|W
(braket
id|i
)braket
suffix:semicolon
id|E
op_assign
id|D
suffix:semicolon
id|D
op_assign
id|C
suffix:semicolon
id|C
op_assign
id|rol32
c_func
(paren
id|B
comma
l_int|30
)paren
suffix:semicolon
id|B
op_assign
id|A
suffix:semicolon
id|A
op_assign
id|TEMP
suffix:semicolon
)brace
macro_line|#elif SHA_CODE_SIZE == 2
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|20
suffix:semicolon
id|i
op_add_assign
l_int|5
)paren
(brace
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f1
comma
id|K1
comma
id|W
(braket
id|i
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f1
comma
id|K1
comma
id|W
(braket
id|i
op_plus
l_int|1
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f1
comma
id|K1
comma
id|W
(braket
id|i
op_plus
l_int|2
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f1
comma
id|K1
comma
id|W
(braket
id|i
op_plus
l_int|3
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f1
comma
id|K1
comma
id|W
(braket
id|i
op_plus
l_int|4
)braket
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
l_int|40
suffix:semicolon
id|i
op_add_assign
l_int|5
)paren
(brace
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f2
comma
id|K2
comma
id|W
(braket
id|i
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f2
comma
id|K2
comma
id|W
(braket
id|i
op_plus
l_int|1
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f2
comma
id|K2
comma
id|W
(braket
id|i
op_plus
l_int|2
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f2
comma
id|K2
comma
id|W
(braket
id|i
op_plus
l_int|3
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f2
comma
id|K2
comma
id|W
(braket
id|i
op_plus
l_int|4
)braket
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
l_int|60
suffix:semicolon
id|i
op_add_assign
l_int|5
)paren
(brace
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f3
comma
id|K3
comma
id|W
(braket
id|i
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f3
comma
id|K3
comma
id|W
(braket
id|i
op_plus
l_int|1
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f3
comma
id|K3
comma
id|W
(braket
id|i
op_plus
l_int|2
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f3
comma
id|K3
comma
id|W
(braket
id|i
op_plus
l_int|3
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f3
comma
id|K3
comma
id|W
(braket
id|i
op_plus
l_int|4
)braket
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
l_int|80
suffix:semicolon
id|i
op_add_assign
l_int|5
)paren
(brace
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f4
comma
id|K4
comma
id|W
(braket
id|i
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f4
comma
id|K4
comma
id|W
(braket
id|i
op_plus
l_int|1
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f4
comma
id|K4
comma
id|W
(braket
id|i
op_plus
l_int|2
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f4
comma
id|K4
comma
id|W
(braket
id|i
op_plus
l_int|3
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f4
comma
id|K4
comma
id|W
(braket
id|i
op_plus
l_int|4
)braket
)paren
suffix:semicolon
)brace
macro_line|#elif SHA_CODE_SIZE == 3 /* Really large version */
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f1
comma
id|K1
comma
id|W
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f1
comma
id|K1
comma
id|W
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f1
comma
id|K1
comma
id|W
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f1
comma
id|K1
comma
id|W
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f1
comma
id|K1
comma
id|W
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f1
comma
id|K1
comma
id|W
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f1
comma
id|K1
comma
id|W
(braket
l_int|6
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f1
comma
id|K1
comma
id|W
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f1
comma
id|K1
comma
id|W
(braket
l_int|8
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f1
comma
id|K1
comma
id|W
(braket
l_int|9
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f1
comma
id|K1
comma
id|W
(braket
l_int|10
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f1
comma
id|K1
comma
id|W
(braket
l_int|11
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f1
comma
id|K1
comma
id|W
(braket
l_int|12
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f1
comma
id|K1
comma
id|W
(braket
l_int|13
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f1
comma
id|K1
comma
id|W
(braket
l_int|14
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f1
comma
id|K1
comma
id|W
(braket
l_int|15
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f1
comma
id|K1
comma
id|W
(braket
l_int|16
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f1
comma
id|K1
comma
id|W
(braket
l_int|17
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f1
comma
id|K1
comma
id|W
(braket
l_int|18
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f1
comma
id|K1
comma
id|W
(braket
l_int|19
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f2
comma
id|K2
comma
id|W
(braket
l_int|20
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f2
comma
id|K2
comma
id|W
(braket
l_int|21
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f2
comma
id|K2
comma
id|W
(braket
l_int|22
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f2
comma
id|K2
comma
id|W
(braket
l_int|23
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f2
comma
id|K2
comma
id|W
(braket
l_int|24
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f2
comma
id|K2
comma
id|W
(braket
l_int|25
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f2
comma
id|K2
comma
id|W
(braket
l_int|26
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f2
comma
id|K2
comma
id|W
(braket
l_int|27
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f2
comma
id|K2
comma
id|W
(braket
l_int|28
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f2
comma
id|K2
comma
id|W
(braket
l_int|29
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f2
comma
id|K2
comma
id|W
(braket
l_int|30
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f2
comma
id|K2
comma
id|W
(braket
l_int|31
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f2
comma
id|K2
comma
id|W
(braket
l_int|32
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f2
comma
id|K2
comma
id|W
(braket
l_int|33
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f2
comma
id|K2
comma
id|W
(braket
l_int|34
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f2
comma
id|K2
comma
id|W
(braket
l_int|35
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f2
comma
id|K2
comma
id|W
(braket
l_int|36
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f2
comma
id|K2
comma
id|W
(braket
l_int|37
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f2
comma
id|K2
comma
id|W
(braket
l_int|38
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f2
comma
id|K2
comma
id|W
(braket
l_int|39
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f3
comma
id|K3
comma
id|W
(braket
l_int|40
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f3
comma
id|K3
comma
id|W
(braket
l_int|41
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f3
comma
id|K3
comma
id|W
(braket
l_int|42
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f3
comma
id|K3
comma
id|W
(braket
l_int|43
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f3
comma
id|K3
comma
id|W
(braket
l_int|44
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f3
comma
id|K3
comma
id|W
(braket
l_int|45
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f3
comma
id|K3
comma
id|W
(braket
l_int|46
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f3
comma
id|K3
comma
id|W
(braket
l_int|47
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f3
comma
id|K3
comma
id|W
(braket
l_int|48
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f3
comma
id|K3
comma
id|W
(braket
l_int|49
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f3
comma
id|K3
comma
id|W
(braket
l_int|50
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f3
comma
id|K3
comma
id|W
(braket
l_int|51
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f3
comma
id|K3
comma
id|W
(braket
l_int|52
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f3
comma
id|K3
comma
id|W
(braket
l_int|53
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f3
comma
id|K3
comma
id|W
(braket
l_int|54
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f3
comma
id|K3
comma
id|W
(braket
l_int|55
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f3
comma
id|K3
comma
id|W
(braket
l_int|56
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f3
comma
id|K3
comma
id|W
(braket
l_int|57
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f3
comma
id|K3
comma
id|W
(braket
l_int|58
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f3
comma
id|K3
comma
id|W
(braket
l_int|59
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f4
comma
id|K4
comma
id|W
(braket
l_int|60
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f4
comma
id|K4
comma
id|W
(braket
l_int|61
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f4
comma
id|K4
comma
id|W
(braket
l_int|62
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f4
comma
id|K4
comma
id|W
(braket
l_int|63
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f4
comma
id|K4
comma
id|W
(braket
l_int|64
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f4
comma
id|K4
comma
id|W
(braket
l_int|65
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f4
comma
id|K4
comma
id|W
(braket
l_int|66
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f4
comma
id|K4
comma
id|W
(braket
l_int|67
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f4
comma
id|K4
comma
id|W
(braket
l_int|68
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f4
comma
id|K4
comma
id|W
(braket
l_int|69
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f4
comma
id|K4
comma
id|W
(braket
l_int|70
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f4
comma
id|K4
comma
id|W
(braket
l_int|71
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f4
comma
id|K4
comma
id|W
(braket
l_int|72
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f4
comma
id|K4
comma
id|W
(braket
l_int|73
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f4
comma
id|K4
comma
id|W
(braket
l_int|74
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f4
comma
id|K4
comma
id|W
(braket
l_int|75
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f4
comma
id|K4
comma
id|W
(braket
l_int|76
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f4
comma
id|K4
comma
id|W
(braket
l_int|77
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f4
comma
id|K4
comma
id|W
(braket
l_int|78
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f4
comma
id|K4
comma
id|W
(braket
l_int|79
)braket
)paren
suffix:semicolon
macro_line|#else
macro_line|#error Illegal SHA_CODE_SIZE
macro_line|#endif
multiline_comment|/* Build message digest */
id|digest
(braket
l_int|0
)braket
op_add_assign
id|A
suffix:semicolon
id|digest
(braket
l_int|1
)braket
op_add_assign
id|B
suffix:semicolon
id|digest
(braket
l_int|2
)braket
op_add_assign
id|C
suffix:semicolon
id|digest
(braket
l_int|3
)braket
op_add_assign
id|D
suffix:semicolon
id|digest
(braket
l_int|4
)braket
op_add_assign
id|E
suffix:semicolon
multiline_comment|/* W is wiped by the caller */
DECL|macro|W
macro_line|#undef W
)brace
DECL|macro|f1
macro_line|#undef f1
DECL|macro|f2
macro_line|#undef f2
DECL|macro|f3
macro_line|#undef f3
DECL|macro|f4
macro_line|#undef f4
DECL|macro|K1
macro_line|#undef K1
DECL|macro|K2
macro_line|#undef K2
DECL|macro|K3
macro_line|#undef K3
DECL|macro|K4
macro_line|#undef K4
DECL|macro|subRound
macro_line|#undef subRound
multiline_comment|/*********************************************************************&n; *&n; * Entropy extraction routines&n; *&n; *********************************************************************/
r_static
id|ssize_t
id|extract_entropy
c_func
(paren
r_struct
id|entropy_store
op_star
id|r
comma
r_void
op_star
id|buf
comma
r_int
id|nbytes
comma
r_int
id|min
comma
r_int
id|rsvd
)paren
suffix:semicolon
multiline_comment|/*&n; * This utility inline function is responsible for transfering entropy&n; * from the primary pool to the secondary extraction pool. We make&n; * sure we pull enough for a &squot;catastrophic reseed&squot;.&n; */
DECL|function|xfer_secondary_pool
r_static
r_void
id|xfer_secondary_pool
c_func
(paren
r_struct
id|entropy_store
op_star
id|r
comma
r_int
id|nbytes
)paren
(brace
id|__u32
id|tmp
(braket
id|OUTPUT_POOL_WORDS
)braket
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;pull
op_logical_and
id|r-&gt;entropy_count
OL
id|nbytes
op_star
l_int|8
op_logical_and
id|r-&gt;entropy_count
OL
id|r-&gt;poolinfo-&gt;POOLBITS
)paren
(brace
r_int
id|bytes
op_assign
id|max_t
c_func
(paren
r_int
comma
id|random_read_wakeup_thresh
op_div
l_int|8
comma
id|min_t
c_func
(paren
r_int
comma
id|nbytes
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
suffix:semicolon
r_int
id|rsvd
op_assign
id|r-&gt;limit
ques
c_cond
l_int|0
suffix:colon
id|random_read_wakeup_thresh
op_div
l_int|4
suffix:semicolon
id|DEBUG_ENT
c_func
(paren
l_string|&quot;going to reseed %s with %d bits &quot;
l_string|&quot;(%d of %d requested)&bslash;n&quot;
comma
id|r-&gt;name
comma
id|bytes
op_star
l_int|8
comma
id|nbytes
op_star
l_int|8
comma
id|r-&gt;entropy_count
)paren
suffix:semicolon
id|bytes
op_assign
id|extract_entropy
c_func
(paren
id|r-&gt;pull
comma
id|tmp
comma
id|bytes
comma
id|random_read_wakeup_thresh
op_div
l_int|8
comma
id|rsvd
)paren
suffix:semicolon
id|add_entropy_words
c_func
(paren
id|r
comma
id|tmp
comma
(paren
id|bytes
op_plus
l_int|3
)paren
op_div
l_int|4
)paren
suffix:semicolon
id|credit_entropy_store
c_func
(paren
id|r
comma
id|bytes
op_star
l_int|8
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * These functions extracts randomness from the &quot;entropy pool&quot;, and&n; * returns it in a buffer.&n; *&n; * The min parameter specifies the minimum amount we can pull before&n; * failing to avoid races that defeat catastrophic reseeding while the&n; * reserved parameter indicates how much entropy we must leave in the&n; * pool after each pull to avoid starving other readers.&n; *&n; * Note: extract_entropy() assumes that .poolwords is a multiple of 16 words.&n; */
DECL|function|account
r_static
r_int
id|account
c_func
(paren
r_struct
id|entropy_store
op_star
id|r
comma
r_int
id|nbytes
comma
r_int
id|min
comma
r_int
id|reserved
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|BUG_ON
c_func
(paren
id|r-&gt;entropy_count
OG
id|r-&gt;poolinfo-&gt;POOLBITS
)paren
suffix:semicolon
multiline_comment|/* Hold lock while accounting */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|r-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|DEBUG_ENT
c_func
(paren
l_string|&quot;trying to extract %d bits from %s&bslash;n&quot;
comma
id|nbytes
op_star
l_int|8
comma
id|r-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Can we pull enough? */
r_if
c_cond
(paren
id|r-&gt;entropy_count
op_div
l_int|8
OL
id|min
op_plus
id|reserved
)paren
(brace
id|nbytes
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* If limited, never pull more than available */
r_if
c_cond
(paren
id|r-&gt;limit
op_logical_and
id|nbytes
op_plus
id|reserved
op_ge
id|r-&gt;entropy_count
op_div
l_int|8
)paren
id|nbytes
op_assign
id|r-&gt;entropy_count
op_div
l_int|8
op_minus
id|reserved
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;entropy_count
op_div
l_int|8
op_ge
id|nbytes
op_plus
id|reserved
)paren
(brace
id|r-&gt;entropy_count
op_sub_assign
id|nbytes
op_star
l_int|8
suffix:semicolon
)brace
r_else
id|r-&gt;entropy_count
op_assign
id|reserved
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;entropy_count
OL
id|random_write_wakeup_thresh
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|random_write_wait
)paren
suffix:semicolon
)brace
id|DEBUG_ENT
c_func
(paren
l_string|&quot;debiting %d entropy credits from %s%s&bslash;n&quot;
comma
id|nbytes
op_star
l_int|8
comma
id|r-&gt;name
comma
id|r-&gt;limit
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot; (unlimited)&quot;
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|r-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|nbytes
suffix:semicolon
)brace
DECL|function|extract_buf
r_static
r_void
id|extract_buf
c_func
(paren
r_struct
id|entropy_store
op_star
id|r
comma
id|__u8
op_star
id|out
)paren
(brace
r_int
id|i
comma
id|x
suffix:semicolon
id|__u32
id|data
(braket
l_int|16
)braket
comma
id|buf
(braket
l_int|85
)braket
suffix:semicolon
multiline_comment|/* Hash the pool to get the output */
id|buf
(braket
l_int|0
)braket
op_assign
l_int|0x67452301
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_assign
l_int|0xefcdab89
suffix:semicolon
id|buf
(braket
l_int|2
)braket
op_assign
l_int|0x98badcfe
suffix:semicolon
id|buf
(braket
l_int|3
)braket
op_assign
l_int|0x10325476
suffix:semicolon
id|buf
(braket
l_int|4
)braket
op_assign
l_int|0xc3d2e1f0
suffix:semicolon
multiline_comment|/*&n;&t; * As we hash the pool, we mix intermediate values of&n;&t; * the hash back into the pool.  This eliminates&n;&t; * backtracking attacks (where the attacker knows&n;&t; * the state of the pool plus the current outputs, and&n;&t; * attempts to find previous ouputs), unless the hash&n;&t; * function can be inverted.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|x
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|r-&gt;poolinfo-&gt;poolwords
suffix:semicolon
id|i
op_add_assign
l_int|16
comma
id|x
op_add_assign
l_int|2
)paren
(brace
id|sha_transform
c_func
(paren
id|buf
comma
id|r-&gt;pool
op_plus
id|i
)paren
suffix:semicolon
id|add_entropy_words
c_func
(paren
id|r
comma
op_amp
id|buf
(braket
id|x
op_mod
l_int|5
)braket
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * To avoid duplicates, we atomically extract a&n;&t; * portion of the pool while mixing, and hash one&n;&t; * final time.&n;&t; */
id|__add_entropy_words
c_func
(paren
id|r
comma
op_amp
id|buf
(braket
id|x
op_mod
l_int|5
)braket
comma
l_int|1
comma
id|data
)paren
suffix:semicolon
id|sha_transform
c_func
(paren
id|buf
comma
id|data
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * In case the hash function has some recognizable&n;&t; * output pattern, we fold it in half.&n;&t; */
id|buf
(braket
l_int|0
)braket
op_xor_assign
id|buf
(braket
l_int|3
)braket
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_xor_assign
id|buf
(braket
l_int|4
)braket
suffix:semicolon
id|buf
(braket
l_int|0
)braket
op_xor_assign
id|rol32
c_func
(paren
id|buf
(braket
l_int|3
)braket
comma
l_int|16
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|out
comma
id|buf
comma
id|EXTRACT_SIZE
)paren
suffix:semicolon
id|memset
c_func
(paren
id|buf
comma
l_int|0
comma
r_sizeof
(paren
id|buf
)paren
)paren
suffix:semicolon
)brace
DECL|function|extract_entropy
r_static
id|ssize_t
id|extract_entropy
c_func
(paren
r_struct
id|entropy_store
op_star
id|r
comma
r_void
op_star
id|buf
comma
r_int
id|nbytes
comma
r_int
id|min
comma
r_int
id|reserved
)paren
(brace
id|ssize_t
id|ret
op_assign
l_int|0
comma
id|i
suffix:semicolon
id|__u8
id|tmp
(braket
id|EXTRACT_SIZE
)braket
suffix:semicolon
id|xfer_secondary_pool
c_func
(paren
id|r
comma
id|nbytes
)paren
suffix:semicolon
id|nbytes
op_assign
id|account
c_func
(paren
id|r
comma
id|nbytes
comma
id|min
comma
id|reserved
)paren
suffix:semicolon
r_while
c_loop
(paren
id|nbytes
)paren
(brace
id|extract_buf
c_func
(paren
id|r
comma
id|tmp
)paren
suffix:semicolon
id|i
op_assign
id|min_t
c_func
(paren
r_int
comma
id|nbytes
comma
id|EXTRACT_SIZE
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|buf
comma
id|tmp
comma
id|i
)paren
suffix:semicolon
id|nbytes
op_sub_assign
id|i
suffix:semicolon
id|buf
op_add_assign
id|i
suffix:semicolon
id|ret
op_add_assign
id|i
suffix:semicolon
)brace
multiline_comment|/* Wipe data just returned from memory */
id|memset
c_func
(paren
id|tmp
comma
l_int|0
comma
r_sizeof
(paren
id|tmp
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|extract_entropy_user
r_static
id|ssize_t
id|extract_entropy_user
c_func
(paren
r_struct
id|entropy_store
op_star
id|r
comma
r_void
id|__user
op_star
id|buf
comma
r_int
id|nbytes
)paren
(brace
id|ssize_t
id|ret
op_assign
l_int|0
comma
id|i
suffix:semicolon
id|__u8
id|tmp
(braket
id|EXTRACT_SIZE
)braket
suffix:semicolon
id|xfer_secondary_pool
c_func
(paren
id|r
comma
id|nbytes
)paren
suffix:semicolon
id|nbytes
op_assign
id|account
c_func
(paren
id|r
comma
id|nbytes
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_while
c_loop
(paren
id|nbytes
)paren
(brace
r_if
c_cond
(paren
id|need_resched
c_func
(paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|ret
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|extract_buf
c_func
(paren
id|r
comma
id|tmp
)paren
suffix:semicolon
id|i
op_assign
id|min_t
c_func
(paren
r_int
comma
id|nbytes
comma
id|EXTRACT_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
id|tmp
comma
id|i
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|nbytes
op_sub_assign
id|i
suffix:semicolon
id|buf
op_add_assign
id|i
suffix:semicolon
id|ret
op_add_assign
id|i
suffix:semicolon
)brace
multiline_comment|/* Wipe data just returned from memory */
id|memset
c_func
(paren
id|tmp
comma
l_int|0
comma
r_sizeof
(paren
id|tmp
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is the exported kernel interface.  It returns some&n; * number of good random numbers, suitable for seeding TCP sequence&n; * numbers, etc.&n; */
DECL|function|get_random_bytes
r_void
id|get_random_bytes
c_func
(paren
r_void
op_star
id|buf
comma
r_int
id|nbytes
)paren
(brace
id|extract_entropy
c_func
(paren
op_amp
id|nonblocking_pool
comma
id|buf
comma
id|nbytes
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|variable|get_random_bytes
id|EXPORT_SYMBOL
c_func
(paren
id|get_random_bytes
)paren
suffix:semicolon
multiline_comment|/*&n; * init_std_data - initialize pool with system data&n; *&n; * @r: pool to initialize&n; *&n; * This function clears the pool&squot;s entropy count and mixes some system&n; * data into the pool to prepare it for use. The pool is not cleared&n; * as that can only decrease the entropy in the pool.&n; */
DECL|function|init_std_data
r_static
r_void
id|init_std_data
c_func
(paren
r_struct
id|entropy_store
op_star
id|r
)paren
(brace
r_struct
id|timeval
id|tv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|r-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|r-&gt;entropy_count
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|r-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
id|tv
)paren
suffix:semicolon
id|add_entropy_words
c_func
(paren
id|r
comma
(paren
id|__u32
op_star
)paren
op_amp
id|tv
comma
r_sizeof
(paren
id|tv
)paren
op_div
l_int|4
)paren
suffix:semicolon
id|add_entropy_words
c_func
(paren
id|r
comma
(paren
id|__u32
op_star
)paren
op_amp
id|system_utsname
comma
r_sizeof
(paren
id|system_utsname
)paren
op_div
l_int|4
)paren
suffix:semicolon
)brace
DECL|function|rand_initialize
r_static
r_int
id|__init
id|rand_initialize
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|batch_entropy_init
c_func
(paren
id|BATCH_ENTROPY_SIZE
comma
op_amp
id|input_pool
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|init_std_data
c_func
(paren
op_amp
id|input_pool
)paren
suffix:semicolon
id|init_std_data
c_func
(paren
op_amp
id|blocking_pool
)paren
suffix:semicolon
id|init_std_data
c_func
(paren
op_amp
id|nonblocking_pool
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|rand_initialize
id|module_init
c_func
(paren
id|rand_initialize
)paren
suffix:semicolon
DECL|function|rand_initialize_irq
r_void
id|rand_initialize_irq
c_func
(paren
r_int
id|irq
)paren
(brace
r_struct
id|timer_rand_state
op_star
id|state
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ge
id|NR_IRQS
op_logical_or
id|irq_timer_state
(braket
id|irq
)braket
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * If kmalloc returns null, we just won&squot;t use that entropy&n;&t; * source.&n;&t; */
id|state
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|timer_rand_state
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|memset
c_func
(paren
id|state
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|timer_rand_state
)paren
)paren
suffix:semicolon
id|irq_timer_state
(braket
id|irq
)braket
op_assign
id|state
suffix:semicolon
)brace
)brace
DECL|function|rand_initialize_disk
r_void
id|rand_initialize_disk
c_func
(paren
r_struct
id|gendisk
op_star
id|disk
)paren
(brace
r_struct
id|timer_rand_state
op_star
id|state
suffix:semicolon
multiline_comment|/*&n;&t; * If kmalloc returns null, we just won&squot;t use that entropy&n;&t; * source.&n;&t; */
id|state
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|timer_rand_state
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|memset
c_func
(paren
id|state
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|timer_rand_state
)paren
)paren
suffix:semicolon
id|disk-&gt;random
op_assign
id|state
suffix:semicolon
)brace
)brace
r_static
id|ssize_t
DECL|function|random_read
id|random_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
id|__user
op_star
id|buf
comma
r_int
id|nbytes
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|ssize_t
id|n
comma
id|retval
op_assign
l_int|0
comma
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|nbytes
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|nbytes
OG
l_int|0
)paren
(brace
id|n
op_assign
id|nbytes
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
id|SEC_XFER_SIZE
)paren
id|n
op_assign
id|SEC_XFER_SIZE
suffix:semicolon
id|DEBUG_ENT
c_func
(paren
l_string|&quot;reading %d bits&bslash;n&quot;
comma
id|n
op_star
l_int|8
)paren
suffix:semicolon
id|n
op_assign
id|extract_entropy_user
c_func
(paren
op_amp
id|blocking_pool
comma
id|buf
comma
id|n
)paren
suffix:semicolon
id|DEBUG_ENT
c_func
(paren
l_string|&quot;read got %d bits (%d still needed)&bslash;n&quot;
comma
id|n
op_star
l_int|8
comma
(paren
id|nbytes
op_minus
id|n
)paren
op_star
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|retval
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_break
suffix:semicolon
)brace
id|DEBUG_ENT
c_func
(paren
l_string|&quot;sleeping?&bslash;n&quot;
)paren
suffix:semicolon
id|wait_event_interruptible
c_func
(paren
id|random_read_wait
comma
id|input_pool.entropy_count
op_ge
id|random_read_wakeup_thresh
)paren
suffix:semicolon
id|DEBUG_ENT
c_func
(paren
l_string|&quot;awake&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n
OL
l_int|0
)paren
(brace
id|retval
op_assign
id|n
suffix:semicolon
r_break
suffix:semicolon
)brace
id|count
op_add_assign
id|n
suffix:semicolon
id|buf
op_add_assign
id|n
suffix:semicolon
id|nbytes
op_sub_assign
id|n
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* This break makes the device work */
multiline_comment|/* like a named pipe */
)brace
multiline_comment|/*&n;&t; * If we gave the user some bytes, update the access time.&n;&t; */
r_if
c_cond
(paren
id|count
)paren
id|file_accessed
c_func
(paren
id|file
)paren
suffix:semicolon
r_return
(paren
id|count
ques
c_cond
id|count
suffix:colon
id|retval
)paren
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|urandom_read
id|urandom_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
id|__user
op_star
id|buf
comma
r_int
id|nbytes
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_return
id|extract_entropy_user
c_func
(paren
op_amp
id|nonblocking_pool
comma
id|buf
comma
id|nbytes
)paren
suffix:semicolon
)brace
r_static
r_int
r_int
DECL|function|random_poll
id|random_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_int
r_int
id|mask
suffix:semicolon
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|random_read_wait
comma
id|wait
)paren
suffix:semicolon
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|random_write_wait
comma
id|wait
)paren
suffix:semicolon
id|mask
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|input_pool.entropy_count
op_ge
id|random_read_wakeup_thresh
)paren
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
r_if
c_cond
(paren
id|input_pool.entropy_count
OL
id|random_write_wakeup_thresh
)paren
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
r_static
id|ssize_t
DECL|function|random_write
id|random_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
id|__user
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|bytes
suffix:semicolon
id|__u32
id|buf
(braket
l_int|16
)braket
suffix:semicolon
r_const
r_char
id|__user
op_star
id|p
op_assign
id|buffer
suffix:semicolon
r_int
id|c
op_assign
id|count
suffix:semicolon
r_while
c_loop
(paren
id|c
OG
l_int|0
)paren
(brace
id|bytes
op_assign
id|min
c_func
(paren
id|c
comma
r_sizeof
(paren
id|buf
)paren
)paren
suffix:semicolon
id|bytes
op_sub_assign
id|copy_from_user
c_func
(paren
op_amp
id|buf
comma
id|p
comma
id|bytes
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bytes
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|c
op_sub_assign
id|bytes
suffix:semicolon
id|p
op_add_assign
id|bytes
suffix:semicolon
id|add_entropy_words
c_func
(paren
op_amp
id|input_pool
comma
id|buf
comma
(paren
id|bytes
op_plus
l_int|3
)paren
op_div
l_int|4
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p
op_eq
id|buffer
)paren
(brace
r_return
(paren
id|ssize_t
)paren
id|ret
suffix:semicolon
)brace
r_else
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
id|inode-&gt;i_mtime
op_assign
id|current_fs_time
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|mark_inode_dirty
c_func
(paren
id|inode
)paren
suffix:semicolon
r_return
(paren
id|ssize_t
)paren
(paren
id|p
op_minus
id|buffer
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|random_ioctl
id|random_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|size
comma
id|ent_count
suffix:semicolon
r_int
id|__user
op_star
id|p
op_assign
(paren
r_int
id|__user
op_star
)paren
id|arg
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|RNDGETENTCNT
suffix:colon
id|ent_count
op_assign
id|input_pool.entropy_count
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|ent_count
comma
id|p
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|RNDADDTOENTCNT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|ent_count
comma
id|p
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|credit_entropy_store
c_func
(paren
op_amp
id|input_pool
comma
id|ent_count
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Wake up waiting processes if we have enough&n;&t;&t; * entropy.&n;&t;&t; */
r_if
c_cond
(paren
id|input_pool.entropy_count
op_ge
id|random_read_wakeup_thresh
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|random_read_wait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|RNDADDENTROPY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|ent_count
comma
id|p
op_increment
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|ent_count
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|size
comma
id|p
op_increment
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|retval
op_assign
id|random_write
c_func
(paren
id|file
comma
(paren
r_const
r_char
id|__user
op_star
)paren
id|p
comma
id|size
comma
op_amp
id|file-&gt;f_pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_return
id|retval
suffix:semicolon
id|credit_entropy_store
c_func
(paren
op_amp
id|input_pool
comma
id|ent_count
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Wake up waiting processes if we have enough&n;&t;&t; * entropy.&n;&t;&t; */
r_if
c_cond
(paren
id|input_pool.entropy_count
op_ge
id|random_read_wakeup_thresh
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|random_read_wait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|RNDZAPENTCNT
suffix:colon
r_case
id|RNDCLEARPOOL
suffix:colon
multiline_comment|/* Clear the entropy pool counters. */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|init_std_data
c_func
(paren
op_amp
id|input_pool
)paren
suffix:semicolon
id|init_std_data
c_func
(paren
op_amp
id|blocking_pool
)paren
suffix:semicolon
id|init_std_data
c_func
(paren
op_amp
id|nonblocking_pool
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
DECL|variable|random_fops
r_struct
id|file_operations
id|random_fops
op_assign
(brace
dot
id|read
op_assign
id|random_read
comma
dot
id|write
op_assign
id|random_write
comma
dot
id|poll
op_assign
id|random_poll
comma
dot
id|ioctl
op_assign
id|random_ioctl
comma
)brace
suffix:semicolon
DECL|variable|urandom_fops
r_struct
id|file_operations
id|urandom_fops
op_assign
(brace
dot
id|read
op_assign
id|urandom_read
comma
dot
id|write
op_assign
id|random_write
comma
dot
id|ioctl
op_assign
id|random_ioctl
comma
)brace
suffix:semicolon
multiline_comment|/***************************************************************&n; * Random UUID interface&n; *&n; * Used here for a Boot ID, but can be useful for other kernel&n; * drivers.&n; ***************************************************************/
multiline_comment|/*&n; * Generate random UUID&n; */
DECL|function|generate_random_uuid
r_void
id|generate_random_uuid
c_func
(paren
r_int
r_char
id|uuid_out
(braket
l_int|16
)braket
)paren
(brace
id|get_random_bytes
c_func
(paren
id|uuid_out
comma
l_int|16
)paren
suffix:semicolon
multiline_comment|/* Set UUID version to 4 --- truely random generation */
id|uuid_out
(braket
l_int|6
)braket
op_assign
(paren
id|uuid_out
(braket
l_int|6
)braket
op_amp
l_int|0x0F
)paren
op_or
l_int|0x40
suffix:semicolon
multiline_comment|/* Set the UUID variant to DCE */
id|uuid_out
(braket
l_int|8
)braket
op_assign
(paren
id|uuid_out
(braket
l_int|8
)braket
op_amp
l_int|0x3F
)paren
op_or
l_int|0x80
suffix:semicolon
)brace
DECL|variable|generate_random_uuid
id|EXPORT_SYMBOL
c_func
(paren
id|generate_random_uuid
)paren
suffix:semicolon
multiline_comment|/********************************************************************&n; *&n; * Sysctl interface&n; *&n; ********************************************************************/
macro_line|#ifdef CONFIG_SYSCTL
macro_line|#include &lt;linux/sysctl.h&gt;
DECL|variable|min_read_thresh
DECL|variable|min_write_thresh
r_static
r_int
id|min_read_thresh
op_assign
l_int|8
comma
id|min_write_thresh
suffix:semicolon
DECL|variable|max_read_thresh
r_static
r_int
id|max_read_thresh
op_assign
id|INPUT_POOL_WORDS
op_star
l_int|32
suffix:semicolon
DECL|variable|max_write_thresh
r_static
r_int
id|max_write_thresh
op_assign
id|INPUT_POOL_WORDS
op_star
l_int|32
suffix:semicolon
DECL|variable|sysctl_bootid
r_static
r_char
id|sysctl_bootid
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/*&n; * These functions is used to return both the bootid UUID, and random&n; * UUID.  The difference is in whether table-&gt;data is NULL; if it is,&n; * then a new UUID is generated and returned to the user.&n; *&n; * If the user accesses this via the proc interface, it will be returned&n; * as an ASCII string in the standard UUID format.  If accesses via the&n; * sysctl system call, it is returned as 16 bytes of binary data.&n; */
DECL|function|proc_do_uuid
r_static
r_int
id|proc_do_uuid
c_func
(paren
id|ctl_table
op_star
id|table
comma
r_int
id|write
comma
r_struct
id|file
op_star
id|filp
comma
r_void
id|__user
op_star
id|buffer
comma
r_int
op_star
id|lenp
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|ctl_table
id|fake_table
suffix:semicolon
r_int
r_char
id|buf
(braket
l_int|64
)braket
comma
id|tmp_uuid
(braket
l_int|16
)braket
comma
op_star
id|uuid
suffix:semicolon
id|uuid
op_assign
id|table-&gt;data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|uuid
)paren
(brace
id|uuid
op_assign
id|tmp_uuid
suffix:semicolon
id|uuid
(braket
l_int|8
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uuid
(braket
l_int|8
)braket
op_eq
l_int|0
)paren
id|generate_random_uuid
c_func
(paren
id|uuid
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-&quot;
l_string|&quot;%02x%02x%02x%02x%02x%02x&quot;
comma
id|uuid
(braket
l_int|0
)braket
comma
id|uuid
(braket
l_int|1
)braket
comma
id|uuid
(braket
l_int|2
)braket
comma
id|uuid
(braket
l_int|3
)braket
comma
id|uuid
(braket
l_int|4
)braket
comma
id|uuid
(braket
l_int|5
)braket
comma
id|uuid
(braket
l_int|6
)braket
comma
id|uuid
(braket
l_int|7
)braket
comma
id|uuid
(braket
l_int|8
)braket
comma
id|uuid
(braket
l_int|9
)braket
comma
id|uuid
(braket
l_int|10
)braket
comma
id|uuid
(braket
l_int|11
)braket
comma
id|uuid
(braket
l_int|12
)braket
comma
id|uuid
(braket
l_int|13
)braket
comma
id|uuid
(braket
l_int|14
)braket
comma
id|uuid
(braket
l_int|15
)braket
)paren
suffix:semicolon
id|fake_table.data
op_assign
id|buf
suffix:semicolon
id|fake_table.maxlen
op_assign
r_sizeof
(paren
id|buf
)paren
suffix:semicolon
r_return
id|proc_dostring
c_func
(paren
op_amp
id|fake_table
comma
id|write
comma
id|filp
comma
id|buffer
comma
id|lenp
comma
id|ppos
)paren
suffix:semicolon
)brace
DECL|function|uuid_strategy
r_static
r_int
id|uuid_strategy
c_func
(paren
id|ctl_table
op_star
id|table
comma
r_int
id|__user
op_star
id|name
comma
r_int
id|nlen
comma
r_void
id|__user
op_star
id|oldval
comma
r_int
id|__user
op_star
id|oldlenp
comma
r_void
id|__user
op_star
id|newval
comma
r_int
id|newlen
comma
r_void
op_star
op_star
id|context
)paren
(brace
r_int
r_char
id|tmp_uuid
(braket
l_int|16
)braket
comma
op_star
id|uuid
suffix:semicolon
r_int
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|oldval
op_logical_or
op_logical_neg
id|oldlenp
)paren
r_return
l_int|1
suffix:semicolon
id|uuid
op_assign
id|table-&gt;data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|uuid
)paren
(brace
id|uuid
op_assign
id|tmp_uuid
suffix:semicolon
id|uuid
(braket
l_int|8
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uuid
(braket
l_int|8
)braket
op_eq
l_int|0
)paren
id|generate_random_uuid
c_func
(paren
id|uuid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|len
comma
id|oldlenp
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|len
)paren
(brace
r_if
c_cond
(paren
id|len
OG
l_int|16
)paren
id|len
op_assign
l_int|16
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|oldval
comma
id|uuid
comma
id|len
)paren
op_logical_or
id|put_user
c_func
(paren
id|len
comma
id|oldlenp
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|variable|sysctl_poolsize
r_static
r_int
id|sysctl_poolsize
op_assign
id|INPUT_POOL_WORDS
op_star
l_int|32
suffix:semicolon
DECL|variable|random_table
id|ctl_table
id|random_table
(braket
)braket
op_assign
(brace
(brace
dot
id|ctl_name
op_assign
id|RANDOM_POOLSIZE
comma
dot
id|procname
op_assign
l_string|&quot;poolsize&quot;
comma
dot
id|data
op_assign
op_amp
id|sysctl_poolsize
comma
dot
id|maxlen
op_assign
r_sizeof
(paren
r_int
)paren
comma
dot
id|mode
op_assign
l_int|0444
comma
dot
id|proc_handler
op_assign
op_amp
id|proc_dointvec
comma
)brace
comma
(brace
dot
id|ctl_name
op_assign
id|RANDOM_ENTROPY_COUNT
comma
dot
id|procname
op_assign
l_string|&quot;entropy_avail&quot;
comma
dot
id|maxlen
op_assign
r_sizeof
(paren
r_int
)paren
comma
dot
id|mode
op_assign
l_int|0444
comma
dot
id|proc_handler
op_assign
op_amp
id|proc_dointvec
comma
dot
id|data
op_assign
op_amp
id|input_pool.entropy_count
comma
)brace
comma
(brace
dot
id|ctl_name
op_assign
id|RANDOM_READ_THRESH
comma
dot
id|procname
op_assign
l_string|&quot;read_wakeup_threshold&quot;
comma
dot
id|data
op_assign
op_amp
id|random_read_wakeup_thresh
comma
dot
id|maxlen
op_assign
r_sizeof
(paren
r_int
)paren
comma
dot
id|mode
op_assign
l_int|0644
comma
dot
id|proc_handler
op_assign
op_amp
id|proc_dointvec_minmax
comma
dot
id|strategy
op_assign
op_amp
id|sysctl_intvec
comma
dot
id|extra1
op_assign
op_amp
id|min_read_thresh
comma
dot
id|extra2
op_assign
op_amp
id|max_read_thresh
comma
)brace
comma
(brace
dot
id|ctl_name
op_assign
id|RANDOM_WRITE_THRESH
comma
dot
id|procname
op_assign
l_string|&quot;write_wakeup_threshold&quot;
comma
dot
id|data
op_assign
op_amp
id|random_write_wakeup_thresh
comma
dot
id|maxlen
op_assign
r_sizeof
(paren
r_int
)paren
comma
dot
id|mode
op_assign
l_int|0644
comma
dot
id|proc_handler
op_assign
op_amp
id|proc_dointvec_minmax
comma
dot
id|strategy
op_assign
op_amp
id|sysctl_intvec
comma
dot
id|extra1
op_assign
op_amp
id|min_write_thresh
comma
dot
id|extra2
op_assign
op_amp
id|max_write_thresh
comma
)brace
comma
(brace
dot
id|ctl_name
op_assign
id|RANDOM_BOOT_ID
comma
dot
id|procname
op_assign
l_string|&quot;boot_id&quot;
comma
dot
id|data
op_assign
op_amp
id|sysctl_bootid
comma
dot
id|maxlen
op_assign
l_int|16
comma
dot
id|mode
op_assign
l_int|0444
comma
dot
id|proc_handler
op_assign
op_amp
id|proc_do_uuid
comma
dot
id|strategy
op_assign
op_amp
id|uuid_strategy
comma
)brace
comma
(brace
dot
id|ctl_name
op_assign
id|RANDOM_UUID
comma
dot
id|procname
op_assign
l_string|&quot;uuid&quot;
comma
dot
id|maxlen
op_assign
l_int|16
comma
dot
id|mode
op_assign
l_int|0444
comma
dot
id|proc_handler
op_assign
op_amp
id|proc_do_uuid
comma
dot
id|strategy
op_assign
op_amp
id|uuid_strategy
comma
)brace
comma
(brace
dot
id|ctl_name
op_assign
l_int|0
)brace
)brace
suffix:semicolon
macro_line|#endif &t;/* CONFIG_SYSCTL */
multiline_comment|/********************************************************************&n; *&n; * Random funtions for networking&n; *&n; ********************************************************************/
multiline_comment|/*&n; * TCP initial sequence number picking.  This uses the random number&n; * generator to pick an initial secret value.  This value is hashed&n; * along with the TCP endpoint information to provide a unique&n; * starting point for each pair of TCP endpoints.  This defeats&n; * attacks which rely on guessing the initial TCP sequence number.&n; * This algorithm was suggested by Steve Bellovin.&n; *&n; * Using a very strong hash was taking an appreciable amount of the total&n; * TCP connection establishment time, so this is a weaker hash,&n; * compensated for by changing the secret periodically.&n; */
multiline_comment|/* F, G and H are basic MD4 functions: selection, majority, parity */
DECL|macro|F
mdefine_line|#define F(x, y, z) ((z) ^ ((x) &amp; ((y) ^ (z))))
DECL|macro|G
mdefine_line|#define G(x, y, z) (((x) &amp; (y)) + (((x) ^ (y)) &amp; (z)))
DECL|macro|H
mdefine_line|#define H(x, y, z) ((x) ^ (y) ^ (z))
multiline_comment|/*&n; * The generic round function.  The application is so specific that&n; * we don&squot;t bother protecting all the arguments with parens, as is generally&n; * good macro practice, in favor of extra legibility.&n; * Rotation is separate from addition to prevent recomputation&n; */
DECL|macro|ROUND
mdefine_line|#define ROUND(f, a, b, c, d, x, s)&t;&bslash;&n;&t;(a += f(b, c, d) + x, a = (a &lt;&lt; s) | (a &gt;&gt; (32 - s)))
DECL|macro|K1
mdefine_line|#define K1 0
DECL|macro|K2
mdefine_line|#define K2 013240474631UL
DECL|macro|K3
mdefine_line|#define K3 015666365641UL
multiline_comment|/*&n; * Basic cut-down MD4 transform.  Returns only 32 bits of result.&n; */
DECL|function|halfMD4Transform
r_static
id|__u32
id|halfMD4Transform
(paren
id|__u32
r_const
id|buf
(braket
l_int|4
)braket
comma
id|__u32
r_const
id|in
(braket
l_int|8
)braket
)paren
(brace
id|__u32
id|a
op_assign
id|buf
(braket
l_int|0
)braket
comma
id|b
op_assign
id|buf
(braket
l_int|1
)braket
comma
id|c
op_assign
id|buf
(braket
l_int|2
)braket
comma
id|d
op_assign
id|buf
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* Round 1 */
id|ROUND
c_func
(paren
id|F
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|0
)braket
op_plus
id|K1
comma
l_int|3
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|F
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|1
)braket
op_plus
id|K1
comma
l_int|7
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|F
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|2
)braket
op_plus
id|K1
comma
l_int|11
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|F
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|3
)braket
op_plus
id|K1
comma
l_int|19
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|F
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|4
)braket
op_plus
id|K1
comma
l_int|3
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|F
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|5
)braket
op_plus
id|K1
comma
l_int|7
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|F
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|6
)braket
op_plus
id|K1
comma
l_int|11
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|F
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|7
)braket
op_plus
id|K1
comma
l_int|19
)paren
suffix:semicolon
multiline_comment|/* Round 2 */
id|ROUND
c_func
(paren
id|G
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|1
)braket
op_plus
id|K2
comma
l_int|3
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|G
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|3
)braket
op_plus
id|K2
comma
l_int|5
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|G
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|5
)braket
op_plus
id|K2
comma
l_int|9
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|G
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|7
)braket
op_plus
id|K2
comma
l_int|13
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|G
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|0
)braket
op_plus
id|K2
comma
l_int|3
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|G
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|2
)braket
op_plus
id|K2
comma
l_int|5
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|G
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|4
)braket
op_plus
id|K2
comma
l_int|9
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|G
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|6
)braket
op_plus
id|K2
comma
l_int|13
)paren
suffix:semicolon
multiline_comment|/* Round 3 */
id|ROUND
c_func
(paren
id|H
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|3
)braket
op_plus
id|K3
comma
l_int|3
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|H
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|7
)braket
op_plus
id|K3
comma
l_int|9
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|H
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|2
)braket
op_plus
id|K3
comma
l_int|11
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|H
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|6
)braket
op_plus
id|K3
comma
l_int|15
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|H
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|1
)braket
op_plus
id|K3
comma
l_int|3
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|H
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|5
)braket
op_plus
id|K3
comma
l_int|9
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|H
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|0
)braket
op_plus
id|K3
comma
l_int|11
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|H
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|4
)braket
op_plus
id|K3
comma
l_int|15
)paren
suffix:semicolon
r_return
id|buf
(braket
l_int|1
)braket
op_plus
id|b
suffix:semicolon
multiline_comment|/* &quot;most hashed&quot; word */
multiline_comment|/* Alternative: return sum of all words? */
)brace
macro_line|#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
DECL|function|twothirdsMD4Transform
r_static
id|__u32
id|twothirdsMD4Transform
(paren
id|__u32
r_const
id|buf
(braket
l_int|4
)braket
comma
id|__u32
r_const
id|in
(braket
l_int|12
)braket
)paren
(brace
id|__u32
id|a
op_assign
id|buf
(braket
l_int|0
)braket
comma
id|b
op_assign
id|buf
(braket
l_int|1
)braket
comma
id|c
op_assign
id|buf
(braket
l_int|2
)braket
comma
id|d
op_assign
id|buf
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* Round 1 */
id|ROUND
c_func
(paren
id|F
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|0
)braket
op_plus
id|K1
comma
l_int|3
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|F
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|1
)braket
op_plus
id|K1
comma
l_int|7
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|F
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|2
)braket
op_plus
id|K1
comma
l_int|11
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|F
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|3
)braket
op_plus
id|K1
comma
l_int|19
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|F
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|4
)braket
op_plus
id|K1
comma
l_int|3
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|F
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|5
)braket
op_plus
id|K1
comma
l_int|7
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|F
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|6
)braket
op_plus
id|K1
comma
l_int|11
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|F
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|7
)braket
op_plus
id|K1
comma
l_int|19
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|F
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|8
)braket
op_plus
id|K1
comma
l_int|3
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|F
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|9
)braket
op_plus
id|K1
comma
l_int|7
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|F
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|10
)braket
op_plus
id|K1
comma
l_int|11
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|F
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|11
)braket
op_plus
id|K1
comma
l_int|19
)paren
suffix:semicolon
multiline_comment|/* Round 2 */
id|ROUND
c_func
(paren
id|G
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|1
)braket
op_plus
id|K2
comma
l_int|3
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|G
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|3
)braket
op_plus
id|K2
comma
l_int|5
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|G
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|5
)braket
op_plus
id|K2
comma
l_int|9
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|G
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|7
)braket
op_plus
id|K2
comma
l_int|13
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|G
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|9
)braket
op_plus
id|K2
comma
l_int|3
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|G
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|11
)braket
op_plus
id|K2
comma
l_int|5
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|G
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|0
)braket
op_plus
id|K2
comma
l_int|9
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|G
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|2
)braket
op_plus
id|K2
comma
l_int|13
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|G
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|4
)braket
op_plus
id|K2
comma
l_int|3
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|G
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|6
)braket
op_plus
id|K2
comma
l_int|5
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|G
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|8
)braket
op_plus
id|K2
comma
l_int|9
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|G
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|10
)braket
op_plus
id|K2
comma
l_int|13
)paren
suffix:semicolon
multiline_comment|/* Round 3 */
id|ROUND
c_func
(paren
id|H
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|3
)braket
op_plus
id|K3
comma
l_int|3
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|H
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|7
)braket
op_plus
id|K3
comma
l_int|9
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|H
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|11
)braket
op_plus
id|K3
comma
l_int|11
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|H
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|2
)braket
op_plus
id|K3
comma
l_int|15
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|H
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|6
)braket
op_plus
id|K3
comma
l_int|3
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|H
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|10
)braket
op_plus
id|K3
comma
l_int|9
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|H
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|1
)braket
op_plus
id|K3
comma
l_int|11
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|H
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|5
)braket
op_plus
id|K3
comma
l_int|15
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|H
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|9
)braket
op_plus
id|K3
comma
l_int|3
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|H
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|0
)braket
op_plus
id|K3
comma
l_int|9
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|H
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|4
)braket
op_plus
id|K3
comma
l_int|11
)paren
suffix:semicolon
id|ROUND
c_func
(paren
id|H
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|8
)braket
op_plus
id|K3
comma
l_int|15
)paren
suffix:semicolon
r_return
id|buf
(braket
l_int|1
)braket
op_plus
id|b
suffix:semicolon
multiline_comment|/* &quot;most hashed&quot; word */
multiline_comment|/* Alternative: return sum of all words? */
)brace
macro_line|#endif
DECL|macro|ROUND
macro_line|#undef ROUND
DECL|macro|F
macro_line|#undef F
DECL|macro|G
macro_line|#undef G
DECL|macro|H
macro_line|#undef H
DECL|macro|K1
macro_line|#undef K1
DECL|macro|K2
macro_line|#undef K2
DECL|macro|K3
macro_line|#undef K3
multiline_comment|/* This should not be decreased so low that ISNs wrap too fast. */
DECL|macro|REKEY_INTERVAL
mdefine_line|#define REKEY_INTERVAL (300 * HZ)
multiline_comment|/*&n; * Bit layout of the tcp sequence numbers (before adding current time):&n; * bit 24-31: increased after every key exchange&n; * bit 0-23: hash(source,dest)&n; *&n; * The implementation is similar to the algorithm described&n; * in the Appendix of RFC 1185, except that&n; * - it uses a 1 MHz clock instead of a 250 kHz clock&n; * - it performs a rekey every 5 minutes, which is equivalent&n; * &t;to a (source,dest) tulple dependent forward jump of the&n; * &t;clock by 0..2^(HASH_BITS+1)&n; *&n; * Thus the average ISN wraparound time is 68 minutes instead of&n; * 4.55 hours.&n; *&n; * SMP cleanup and lock avoidance with poor man&squot;s RCU.&n; * &t;&t;&t;Manfred Spraul &lt;manfred@colorfullife.com&gt;&n; *&n; */
DECL|macro|COUNT_BITS
mdefine_line|#define COUNT_BITS 8
DECL|macro|COUNT_MASK
mdefine_line|#define COUNT_MASK ((1 &lt;&lt; COUNT_BITS) - 1)
DECL|macro|HASH_BITS
mdefine_line|#define HASH_BITS 24
DECL|macro|HASH_MASK
mdefine_line|#define HASH_MASK ((1 &lt;&lt; HASH_BITS) - 1)
DECL|struct|keydata
r_static
r_struct
id|keydata
(brace
DECL|member|count
id|__u32
id|count
suffix:semicolon
multiline_comment|/* already shifted to the final position */
DECL|member|secret
id|__u32
id|secret
(braket
l_int|12
)braket
suffix:semicolon
DECL|variable|ip_keydata
)brace
id|____cacheline_aligned
id|ip_keydata
(braket
l_int|2
)braket
suffix:semicolon
DECL|variable|ip_cnt
r_static
r_int
r_int
id|ip_cnt
suffix:semicolon
r_static
r_void
id|rekey_seq_generator
c_func
(paren
r_void
op_star
id|private_
)paren
suffix:semicolon
r_static
id|DECLARE_WORK
c_func
(paren
id|rekey_work
comma
id|rekey_seq_generator
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n; * Lock avoidance:&n; * The ISN generation runs lockless - it&squot;s just a hash over random data.&n; * State changes happen every 5 minutes when the random key is replaced.&n; * Synchronization is performed by having two copies of the hash function&n; * state and rekey_seq_generator always updates the inactive copy.&n; * The copy is then activated by updating ip_cnt.&n; * The implementation breaks down if someone blocks the thread&n; * that processes SYN requests for more than 5 minutes. Should never&n; * happen, and even if that happens only a not perfectly compliant&n; * ISN is generated, nothing fatal.&n; */
DECL|function|rekey_seq_generator
r_static
r_void
id|rekey_seq_generator
c_func
(paren
r_void
op_star
id|private_
)paren
(brace
r_struct
id|keydata
op_star
id|keyptr
op_assign
op_amp
id|ip_keydata
(braket
l_int|1
op_xor
(paren
id|ip_cnt
op_amp
l_int|1
)paren
)braket
suffix:semicolon
id|get_random_bytes
c_func
(paren
id|keyptr-&gt;secret
comma
r_sizeof
(paren
id|keyptr-&gt;secret
)paren
)paren
suffix:semicolon
id|keyptr-&gt;count
op_assign
(paren
id|ip_cnt
op_amp
id|COUNT_MASK
)paren
op_lshift
id|HASH_BITS
suffix:semicolon
id|smp_wmb
c_func
(paren
)paren
suffix:semicolon
id|ip_cnt
op_increment
suffix:semicolon
id|schedule_delayed_work
c_func
(paren
op_amp
id|rekey_work
comma
id|REKEY_INTERVAL
)paren
suffix:semicolon
)brace
DECL|function|get_keyptr
r_static
r_inline
r_struct
id|keydata
op_star
id|get_keyptr
c_func
(paren
r_void
)paren
(brace
r_struct
id|keydata
op_star
id|keyptr
op_assign
op_amp
id|ip_keydata
(braket
id|ip_cnt
op_amp
l_int|1
)braket
suffix:semicolon
id|smp_rmb
c_func
(paren
)paren
suffix:semicolon
r_return
id|keyptr
suffix:semicolon
)brace
DECL|function|seqgen_init
r_static
id|__init
r_int
id|seqgen_init
c_func
(paren
r_void
)paren
(brace
id|rekey_seq_generator
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|seqgen_init
id|late_initcall
c_func
(paren
id|seqgen_init
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
DECL|function|secure_tcpv6_sequence_number
id|__u32
id|secure_tcpv6_sequence_number
c_func
(paren
id|__u32
op_star
id|saddr
comma
id|__u32
op_star
id|daddr
comma
id|__u16
id|sport
comma
id|__u16
id|dport
)paren
(brace
r_struct
id|timeval
id|tv
suffix:semicolon
id|__u32
id|seq
suffix:semicolon
id|__u32
id|hash
(braket
l_int|12
)braket
suffix:semicolon
r_struct
id|keydata
op_star
id|keyptr
op_assign
id|get_keyptr
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* The procedure is the same as for IPv4, but addresses are longer.&n;&t; * Thus we must use twothirdsMD4Transform.&n;&t; */
id|memcpy
c_func
(paren
id|hash
comma
id|saddr
comma
l_int|16
)paren
suffix:semicolon
id|hash
(braket
l_int|4
)braket
op_assign
(paren
id|sport
op_lshift
l_int|16
)paren
op_plus
id|dport
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|hash
(braket
l_int|5
)braket
comma
id|keyptr-&gt;secret
comma
r_sizeof
(paren
id|__u32
)paren
op_star
l_int|7
)paren
suffix:semicolon
id|seq
op_assign
id|twothirdsMD4Transform
c_func
(paren
id|daddr
comma
id|hash
)paren
op_amp
id|HASH_MASK
suffix:semicolon
id|seq
op_add_assign
id|keyptr-&gt;count
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
id|tv
)paren
suffix:semicolon
id|seq
op_add_assign
id|tv.tv_usec
op_plus
id|tv.tv_sec
op_star
l_int|1000000
suffix:semicolon
r_return
id|seq
suffix:semicolon
)brace
DECL|variable|secure_tcpv6_sequence_number
id|EXPORT_SYMBOL
c_func
(paren
id|secure_tcpv6_sequence_number
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*  The code below is shamelessly stolen from secure_tcp_sequence_number().&n; *  All blames to Andrey V. Savochkin &lt;saw@msu.ru&gt;.&n; */
DECL|function|secure_ip_id
id|__u32
id|secure_ip_id
c_func
(paren
id|__u32
id|daddr
)paren
(brace
r_struct
id|keydata
op_star
id|keyptr
suffix:semicolon
id|__u32
id|hash
(braket
l_int|4
)braket
suffix:semicolon
id|keyptr
op_assign
id|get_keyptr
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Pick a unique starting offset for each IP destination.&n;&t; *  The dest ip address is placed in the starting vector,&n;&t; *  which is then hashed with random data.&n;&t; */
id|hash
(braket
l_int|0
)braket
op_assign
id|daddr
suffix:semicolon
id|hash
(braket
l_int|1
)braket
op_assign
id|keyptr-&gt;secret
(braket
l_int|9
)braket
suffix:semicolon
id|hash
(braket
l_int|2
)braket
op_assign
id|keyptr-&gt;secret
(braket
l_int|10
)braket
suffix:semicolon
id|hash
(braket
l_int|3
)braket
op_assign
id|keyptr-&gt;secret
(braket
l_int|11
)braket
suffix:semicolon
r_return
id|halfMD4Transform
c_func
(paren
id|hash
comma
id|keyptr-&gt;secret
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_INET
DECL|function|secure_tcp_sequence_number
id|__u32
id|secure_tcp_sequence_number
c_func
(paren
id|__u32
id|saddr
comma
id|__u32
id|daddr
comma
id|__u16
id|sport
comma
id|__u16
id|dport
)paren
(brace
r_struct
id|timeval
id|tv
suffix:semicolon
id|__u32
id|seq
suffix:semicolon
id|__u32
id|hash
(braket
l_int|4
)braket
suffix:semicolon
r_struct
id|keydata
op_star
id|keyptr
op_assign
id|get_keyptr
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Pick a unique starting offset for each TCP connection endpoints&n;&t; *  (saddr, daddr, sport, dport).&n;&t; *  Note that the words are placed into the starting vector, which is&n;&t; *  then mixed with a partial MD4 over random data.&n;&t; */
id|hash
(braket
l_int|0
)braket
op_assign
id|saddr
suffix:semicolon
id|hash
(braket
l_int|1
)braket
op_assign
id|daddr
suffix:semicolon
id|hash
(braket
l_int|2
)braket
op_assign
(paren
id|sport
op_lshift
l_int|16
)paren
op_plus
id|dport
suffix:semicolon
id|hash
(braket
l_int|3
)braket
op_assign
id|keyptr-&gt;secret
(braket
l_int|11
)braket
suffix:semicolon
id|seq
op_assign
id|halfMD4Transform
c_func
(paren
id|hash
comma
id|keyptr-&gt;secret
)paren
op_amp
id|HASH_MASK
suffix:semicolon
id|seq
op_add_assign
id|keyptr-&gt;count
suffix:semicolon
multiline_comment|/*&n;&t; *&t;As close as possible to RFC 793, which&n;&t; *&t;suggests using a 250 kHz clock.&n;&t; *&t;Further reading shows this assumes 2 Mb/s networks.&n;&t; *&t;For 10 Mb/s Ethernet, a 1 MHz clock is appropriate.&n;&t; *&t;That&squot;s funny, Linux has one built in!  Use it!&n;&t; *&t;(Networks are faster now - should this be increased?)&n;&t; */
id|do_gettimeofday
c_func
(paren
op_amp
id|tv
)paren
suffix:semicolon
id|seq
op_add_assign
id|tv.tv_usec
op_plus
id|tv.tv_sec
op_star
l_int|1000000
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;init_seq(%lx, %lx, %d, %d) = %d&bslash;n&quot;
comma
id|saddr
comma
id|daddr
comma
id|sport
comma
id|dport
comma
id|seq
)paren
suffix:semicolon
macro_line|#endif
r_return
id|seq
suffix:semicolon
)brace
DECL|variable|secure_tcp_sequence_number
id|EXPORT_SYMBOL
c_func
(paren
id|secure_tcp_sequence_number
)paren
suffix:semicolon
multiline_comment|/* Generate secure starting point for ephemeral TCP port search */
DECL|function|secure_tcp_port_ephemeral
id|u32
id|secure_tcp_port_ephemeral
c_func
(paren
id|__u32
id|saddr
comma
id|__u32
id|daddr
comma
id|__u16
id|dport
)paren
(brace
r_struct
id|keydata
op_star
id|keyptr
op_assign
id|get_keyptr
c_func
(paren
)paren
suffix:semicolon
id|u32
id|hash
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/*&n;&t; *  Pick a unique starting offset for each ephemeral port search&n;&t; *  (saddr, daddr, dport) and 48bits of random data.&n;&t; */
id|hash
(braket
l_int|0
)braket
op_assign
id|saddr
suffix:semicolon
id|hash
(braket
l_int|1
)braket
op_assign
id|daddr
suffix:semicolon
id|hash
(braket
l_int|2
)braket
op_assign
id|dport
op_xor
id|keyptr-&gt;secret
(braket
l_int|10
)braket
suffix:semicolon
id|hash
(braket
l_int|3
)braket
op_assign
id|keyptr-&gt;secret
(braket
l_int|11
)braket
suffix:semicolon
r_return
id|halfMD4Transform
c_func
(paren
id|hash
comma
id|keyptr-&gt;secret
)paren
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
DECL|function|secure_tcpv6_port_ephemeral
id|u32
id|secure_tcpv6_port_ephemeral
c_func
(paren
r_const
id|__u32
op_star
id|saddr
comma
r_const
id|__u32
op_star
id|daddr
comma
id|__u16
id|dport
)paren
(brace
r_struct
id|keydata
op_star
id|keyptr
op_assign
id|get_keyptr
c_func
(paren
)paren
suffix:semicolon
id|u32
id|hash
(braket
l_int|12
)braket
suffix:semicolon
id|memcpy
c_func
(paren
id|hash
comma
id|saddr
comma
l_int|16
)paren
suffix:semicolon
id|hash
(braket
l_int|4
)braket
op_assign
id|dport
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|hash
(braket
l_int|5
)braket
comma
id|keyptr-&gt;secret
comma
r_sizeof
(paren
id|__u32
)paren
op_star
l_int|7
)paren
suffix:semicolon
r_return
id|twothirdsMD4Transform
c_func
(paren
id|daddr
comma
id|hash
)paren
suffix:semicolon
)brace
DECL|variable|secure_tcpv6_port_ephemeral
id|EXPORT_SYMBOL
c_func
(paren
id|secure_tcpv6_port_ephemeral
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_SYN_COOKIES
multiline_comment|/*&n; * Secure SYN cookie computation. This is the algorithm worked out by&n; * Dan Bernstein and Eric Schenk.&n; *&n; * For linux I implement the 1 minute counter by looking at the jiffies clock.&n; * The count is passed in as a parameter, so this code doesn&squot;t much care.&n; */
DECL|macro|COOKIEBITS
mdefine_line|#define COOKIEBITS 24&t;/* Upper bits store count */
DECL|macro|COOKIEMASK
mdefine_line|#define COOKIEMASK (((__u32)1 &lt;&lt; COOKIEBITS) - 1)
DECL|variable|syncookie_init
r_static
r_int
id|syncookie_init
suffix:semicolon
DECL|variable|syncookie_secret
r_static
id|__u32
id|syncookie_secret
(braket
l_int|2
)braket
(braket
l_int|16
op_minus
l_int|3
op_plus
id|HASH_BUFFER_SIZE
)braket
suffix:semicolon
DECL|function|secure_tcp_syn_cookie
id|__u32
id|secure_tcp_syn_cookie
c_func
(paren
id|__u32
id|saddr
comma
id|__u32
id|daddr
comma
id|__u16
id|sport
comma
id|__u16
id|dport
comma
id|__u32
id|sseq
comma
id|__u32
id|count
comma
id|__u32
id|data
)paren
(brace
id|__u32
id|tmp
(braket
l_int|16
op_plus
id|HASH_BUFFER_SIZE
op_plus
id|HASH_EXTRA_SIZE
)braket
suffix:semicolon
id|__u32
id|seq
suffix:semicolon
multiline_comment|/*&n;&t; * Pick two random secrets the first time we need a cookie.&n;&t; */
r_if
c_cond
(paren
id|syncookie_init
op_eq
l_int|0
)paren
(brace
id|get_random_bytes
c_func
(paren
id|syncookie_secret
comma
r_sizeof
(paren
id|syncookie_secret
)paren
)paren
suffix:semicolon
id|syncookie_init
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Compute the secure sequence number.&n;&t; * The output should be:&n;   &t; *   HASH(sec1,saddr,sport,daddr,dport,sec1) + sseq + (count * 2^24)&n;&t; *      + (HASH(sec2,saddr,sport,daddr,dport,count,sec2) % 2^24).&n;&t; * Where sseq is their sequence number and count increases every&n;&t; * minute by 1.&n;&t; * As an extra hack, we add a small &quot;data&quot; value that encodes the&n;&t; * MSS into the second hash value.&n;&t; */
id|memcpy
c_func
(paren
id|tmp
op_plus
l_int|3
comma
id|syncookie_secret
(braket
l_int|0
)braket
comma
r_sizeof
(paren
id|syncookie_secret
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|tmp
(braket
l_int|0
)braket
op_assign
id|saddr
suffix:semicolon
id|tmp
(braket
l_int|1
)braket
op_assign
id|daddr
suffix:semicolon
id|tmp
(braket
l_int|2
)braket
op_assign
(paren
id|sport
op_lshift
l_int|16
)paren
op_plus
id|dport
suffix:semicolon
id|sha_transform
c_func
(paren
id|tmp
op_plus
l_int|16
comma
id|tmp
)paren
suffix:semicolon
id|seq
op_assign
id|tmp
(braket
l_int|17
)braket
op_plus
id|sseq
op_plus
(paren
id|count
op_lshift
id|COOKIEBITS
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|tmp
op_plus
l_int|3
comma
id|syncookie_secret
(braket
l_int|1
)braket
comma
r_sizeof
(paren
id|syncookie_secret
(braket
l_int|1
)braket
)paren
)paren
suffix:semicolon
id|tmp
(braket
l_int|0
)braket
op_assign
id|saddr
suffix:semicolon
id|tmp
(braket
l_int|1
)braket
op_assign
id|daddr
suffix:semicolon
id|tmp
(braket
l_int|2
)braket
op_assign
(paren
id|sport
op_lshift
l_int|16
)paren
op_plus
id|dport
suffix:semicolon
id|tmp
(braket
l_int|3
)braket
op_assign
id|count
suffix:semicolon
multiline_comment|/* minute counter */
id|sha_transform
c_func
(paren
id|tmp
op_plus
l_int|16
comma
id|tmp
)paren
suffix:semicolon
multiline_comment|/* Add in the second hash and the data */
r_return
id|seq
op_plus
(paren
(paren
id|tmp
(braket
l_int|17
)braket
op_plus
id|data
)paren
op_amp
id|COOKIEMASK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This retrieves the small &quot;data&quot; value from the syncookie.&n; * If the syncookie is bad, the data returned will be out of&n; * range.  This must be checked by the caller.&n; *&n; * The count value used to generate the cookie must be within&n; * &quot;maxdiff&quot; if the current (passed-in) &quot;count&quot;.  The return value&n; * is (__u32)-1 if this test fails.&n; */
DECL|function|check_tcp_syn_cookie
id|__u32
id|check_tcp_syn_cookie
c_func
(paren
id|__u32
id|cookie
comma
id|__u32
id|saddr
comma
id|__u32
id|daddr
comma
id|__u16
id|sport
comma
id|__u16
id|dport
comma
id|__u32
id|sseq
comma
id|__u32
id|count
comma
id|__u32
id|maxdiff
)paren
(brace
id|__u32
id|tmp
(braket
l_int|16
op_plus
id|HASH_BUFFER_SIZE
op_plus
id|HASH_EXTRA_SIZE
)braket
suffix:semicolon
id|__u32
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|syncookie_init
op_eq
l_int|0
)paren
r_return
(paren
id|__u32
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Well, duh! */
multiline_comment|/* Strip away the layers from the cookie */
id|memcpy
c_func
(paren
id|tmp
op_plus
l_int|3
comma
id|syncookie_secret
(braket
l_int|0
)braket
comma
r_sizeof
(paren
id|syncookie_secret
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|tmp
(braket
l_int|0
)braket
op_assign
id|saddr
suffix:semicolon
id|tmp
(braket
l_int|1
)braket
op_assign
id|daddr
suffix:semicolon
id|tmp
(braket
l_int|2
)braket
op_assign
(paren
id|sport
op_lshift
l_int|16
)paren
op_plus
id|dport
suffix:semicolon
id|sha_transform
c_func
(paren
id|tmp
op_plus
l_int|16
comma
id|tmp
)paren
suffix:semicolon
id|cookie
op_sub_assign
id|tmp
(braket
l_int|17
)braket
op_plus
id|sseq
suffix:semicolon
multiline_comment|/* Cookie is now reduced to (count * 2^24) ^ (hash % 2^24) */
id|diff
op_assign
(paren
id|count
op_minus
(paren
id|cookie
op_rshift
id|COOKIEBITS
)paren
)paren
op_amp
(paren
(paren
id|__u32
)paren
op_minus
l_int|1
op_rshift
id|COOKIEBITS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|diff
op_ge
id|maxdiff
)paren
r_return
(paren
id|__u32
)paren
op_minus
l_int|1
suffix:semicolon
id|memcpy
c_func
(paren
id|tmp
op_plus
l_int|3
comma
id|syncookie_secret
(braket
l_int|1
)braket
comma
r_sizeof
(paren
id|syncookie_secret
(braket
l_int|1
)braket
)paren
)paren
suffix:semicolon
id|tmp
(braket
l_int|0
)braket
op_assign
id|saddr
suffix:semicolon
id|tmp
(braket
l_int|1
)braket
op_assign
id|daddr
suffix:semicolon
id|tmp
(braket
l_int|2
)braket
op_assign
(paren
id|sport
op_lshift
l_int|16
)paren
op_plus
id|dport
suffix:semicolon
id|tmp
(braket
l_int|3
)braket
op_assign
id|count
op_minus
id|diff
suffix:semicolon
multiline_comment|/* minute counter */
id|sha_transform
c_func
(paren
id|tmp
op_plus
l_int|16
comma
id|tmp
)paren
suffix:semicolon
r_return
(paren
id|cookie
op_minus
id|tmp
(braket
l_int|17
)braket
)paren
op_amp
id|COOKIEMASK
suffix:semicolon
multiline_comment|/* Leaving the data behind */
)brace
macro_line|#endif
macro_line|#endif /* CONFIG_INET */
multiline_comment|/*&n; * Get a random word for internal kernel use only. Similar to urandom but&n; * with the goal of minimal entropy pool depletion. As a result, the random&n; * value is not cryptographically secure but for several uses the cost of&n; * depleting entropy is too high&n; */
DECL|function|get_random_int
r_int
r_int
id|get_random_int
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; * Use IP&squot;s RNG. It suits our purpose perfectly: it re-keys itself&n;&t; * every second, from the entropy pool (and thus creates a limited&n;&t; * drain on it), and uses halfMD4Transform within the second. We&n;&t; * also mix it with jiffies and the PID:&n;&t; */
r_return
id|secure_ip_id
c_func
(paren
id|current-&gt;pid
op_plus
id|jiffies
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * randomize_range() returns a start address such that&n; *&n; *    [...... &lt;range&gt; .....]&n; *  start                  end&n; *&n; * a &lt;range&gt; with size &quot;len&quot; starting at the return value is inside in the&n; * area defined by [start, end], but is otherwise randomized.&n; */
r_int
r_int
DECL|function|randomize_range
id|randomize_range
c_func
(paren
r_int
r_int
id|start
comma
r_int
r_int
id|end
comma
r_int
r_int
id|len
)paren
(brace
r_int
r_int
id|range
op_assign
id|end
op_minus
id|len
op_minus
id|start
suffix:semicolon
r_if
c_cond
(paren
id|end
op_le
id|start
op_plus
id|len
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|PAGE_ALIGN
c_func
(paren
id|get_random_int
c_func
(paren
)paren
op_mod
id|range
op_plus
id|start
)paren
suffix:semicolon
)brace
eof
