multiline_comment|/*&n; *  linux/drivers/char/tty_io.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; */
multiline_comment|/*&n; * &squot;tty_io.c&squot; gives an orthogonal feeling to tty&squot;s, be they consoles&n; * or rs-channels. It also implements echoing, cooked mode etc.&n; *&n; * Kill-line thanks to John T Kohl, who also corrected VMIN = VTIME = 0.&n; *&n; * Modified by Theodore Ts&squot;o, 9/14/92, to dynamically allocate the&n; * tty_struct and tty_queue structures.  Previously there was an array&n; * of 256 tty_struct&squot;s which was statically allocated, and the&n; * tty_queue structures were allocated at boot time.  Both are now&n; * dynamically allocated only when the tty is open.&n; *&n; * Also restructured routines so that there is more of a separation&n; * between the high-level tty routines (tty_io.c and tty_ioctl.c) and&n; * the low-level tty routines (serial.c, pty.c, console.c).  This&n; * makes for cleaner and more compact code.  -TYT, 9/17/92 &n; *&n; * Modified by Fred N. van Kempen, 01/29/93, to add line disciplines&n; * which can be dynamically activated and de-activated by the line&n; * discipline handling modules (like SLIP).&n; *&n; * NOTE: pay no attention to the line discipline code (yet); its&n; * interface is still subject to change in this version...&n; * -- TYT, 1/31/92&n; *&n; * Added functionality to the OPOST tty handling.  No delays, but all&n; * other bits should be there.&n; *&t;-- Nick Holloway &lt;alfie@dcs.warwick.ac.uk&gt;, 27th May 1993.&n; *&n; * Rewrote canonical mode and added more termios flags.&n; * &t;-- julian@uhunix.uhcc.hawaii.edu (J. Cowley), 13Jan94&n; *&n; * Reorganized FASYNC support so mouse code can share it.&n; *&t;-- ctm@ardi.com, 9Sep95&n; *&n; * New TIOCLINUX variants added.&n; *&t;-- mj@k332.feld.cvut.cz, 19-Nov-95&n; * &n; * Restrict vt switching via ioctl()&n; *      -- grif@cs.ucr.edu, 5-Dec-95&n; *&n; * Move console and virtual terminal code to more appropriate files,&n; * implement CONFIG_VT and generalize console device interface.&n; *&t;-- Marko Kohtala &lt;Marko.Kohtala@hut.fi&gt;, March 97&n; *&n; * Rewrote init_dev and release_dev to eliminate races.&n; *&t;-- Bill Hawes &lt;whawes@star.net&gt;, June 97&n; *&n; * Added devfs support.&n; *      -- C. Scott Ananian &lt;cananian@alumni.princeton.edu&gt;, 13-Jan-1998&n; *&n; * Added support for a Unix98-style ptmx device.&n; *      -- C. Scott Ananian &lt;cananian@alumni.princeton.edu&gt;, 14-Jan-1998&n; *&n; * Reduced memory usage for older ARM systems&n; *      -- Russell King &lt;rmk@arm.linux.org.uk&gt;&n; *&n; * Move do_SAK() into process context.  Less stack use in devfs functions.&n; * alloc_tty_struct() always uses kmalloc() -- Andrew Morton &lt;andrewm@uow.edu.eu&gt; 17Mar01&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/tty_driver.h&gt;
macro_line|#include &lt;linux/tty_flip.h&gt;
macro_line|#include &lt;linux/devpts_fs.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/console.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/kd.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/idr.h&gt;
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/kbd_kern.h&gt;
macro_line|#include &lt;linux/vt_kern.h&gt;
macro_line|#include &lt;linux/selection.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
DECL|macro|TTY_DEBUG_HANGUP
macro_line|#undef TTY_DEBUG_HANGUP
DECL|macro|TTY_PARANOIA_CHECK
mdefine_line|#define TTY_PARANOIA_CHECK 1
DECL|macro|CHECK_TTY_COUNT
mdefine_line|#define CHECK_TTY_COUNT 1
DECL|variable|tty_std_termios
r_struct
id|termios
id|tty_std_termios
op_assign
(brace
multiline_comment|/* for the benefit of tty drivers  */
dot
id|c_iflag
op_assign
id|ICRNL
op_or
id|IXON
comma
dot
id|c_oflag
op_assign
id|OPOST
op_or
id|ONLCR
comma
dot
id|c_cflag
op_assign
id|B38400
op_or
id|CS8
op_or
id|CREAD
op_or
id|HUPCL
comma
dot
id|c_lflag
op_assign
id|ISIG
op_or
id|ICANON
op_or
id|ECHO
op_or
id|ECHOE
op_or
id|ECHOK
op_or
id|ECHOCTL
op_or
id|ECHOKE
op_or
id|IEXTEN
comma
dot
id|c_cc
op_assign
id|INIT_C_CC
)brace
suffix:semicolon
DECL|variable|tty_std_termios
id|EXPORT_SYMBOL
c_func
(paren
id|tty_std_termios
)paren
suffix:semicolon
multiline_comment|/* This list gets poked at by procfs and various bits of boot up code. This&n;   could do with some rationalisation such as pulling the tty proc function&n;   into this file */
DECL|variable|tty_drivers
id|LIST_HEAD
c_func
(paren
id|tty_drivers
)paren
suffix:semicolon
multiline_comment|/* linked list of tty drivers */
multiline_comment|/* Semaphore to protect creating and releasing a tty. This is shared with&n;   vt.c for deeply disgusting hack reasons */
DECL|variable|tty_sem
id|DECLARE_MUTEX
c_func
(paren
id|tty_sem
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_UNIX98_PTYS
r_extern
r_struct
id|tty_driver
op_star
id|ptm_driver
suffix:semicolon
multiline_comment|/* Unix98 pty masters; for /dev/ptmx */
r_extern
r_int
id|pty_limit
suffix:semicolon
multiline_comment|/* Config limit on Unix98 ptys */
r_static
id|DEFINE_IDR
c_func
(paren
id|allocated_ptys
)paren
suffix:semicolon
r_static
id|DECLARE_MUTEX
c_func
(paren
id|allocated_ptys_lock
)paren
suffix:semicolon
r_static
r_int
id|ptmx_open
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
)paren
suffix:semicolon
macro_line|#endif
r_extern
r_void
id|disable_early_printk
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|initialize_tty_struct
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
id|ssize_t
id|tty_read
c_func
(paren
r_struct
id|file
op_star
comma
r_char
id|__user
op_star
comma
r_int
comma
id|loff_t
op_star
)paren
suffix:semicolon
r_static
id|ssize_t
id|tty_write
c_func
(paren
r_struct
id|file
op_star
comma
r_const
r_char
id|__user
op_star
comma
r_int
comma
id|loff_t
op_star
)paren
suffix:semicolon
id|ssize_t
id|redirected_tty_write
c_func
(paren
r_struct
id|file
op_star
comma
r_const
r_char
id|__user
op_star
comma
r_int
comma
id|loff_t
op_star
)paren
suffix:semicolon
r_static
r_int
r_int
id|tty_poll
c_func
(paren
r_struct
id|file
op_star
comma
id|poll_table
op_star
)paren
suffix:semicolon
r_static
r_int
id|tty_open
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
)paren
suffix:semicolon
r_static
r_int
id|tty_release
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
)paren
suffix:semicolon
r_int
id|tty_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_int
id|tty_fasync
c_func
(paren
r_int
id|fd
comma
r_struct
id|file
op_star
id|filp
comma
r_int
id|on
)paren
suffix:semicolon
r_extern
r_void
id|rs_360_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|release_mem
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|idx
)paren
suffix:semicolon
DECL|function|alloc_tty_struct
r_static
r_struct
id|tty_struct
op_star
id|alloc_tty_struct
c_func
(paren
r_void
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
id|tty
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|tty_struct
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty
)paren
id|memset
c_func
(paren
id|tty
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|tty_struct
)paren
)paren
suffix:semicolon
r_return
id|tty
suffix:semicolon
)brace
DECL|function|free_tty_struct
r_static
r_inline
r_void
id|free_tty_struct
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|kfree
c_func
(paren
id|tty-&gt;write_buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
DECL|macro|TTY_NUMBER
mdefine_line|#define TTY_NUMBER(tty) ((tty)-&gt;index + (tty)-&gt;driver-&gt;name_base)
DECL|function|tty_name
r_char
op_star
id|tty_name
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_char
op_star
id|buf
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
multiline_comment|/* Hmm.  NULL pointer.  That&squot;s fun. */
id|strcpy
c_func
(paren
id|buf
comma
l_string|&quot;NULL tty&quot;
)paren
suffix:semicolon
r_else
id|strcpy
c_func
(paren
id|buf
comma
id|tty-&gt;name
)paren
suffix:semicolon
r_return
id|buf
suffix:semicolon
)brace
DECL|variable|tty_name
id|EXPORT_SYMBOL
c_func
(paren
id|tty_name
)paren
suffix:semicolon
DECL|function|tty_paranoia_check
r_inline
r_int
id|tty_paranoia_check
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|inode
op_star
id|inode
comma
r_const
r_char
op_star
id|routine
)paren
(brace
macro_line|#ifdef TTY_PARANOIA_CHECK
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;null TTY for (%d:%d) in %s&bslash;n&quot;
comma
id|imajor
c_func
(paren
id|inode
)paren
comma
id|iminor
c_func
(paren
id|inode
)paren
comma
id|routine
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;magic
op_ne
id|TTY_MAGIC
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;bad magic number for tty struct (%d:%d) in %s&bslash;n&quot;
comma
id|imajor
c_func
(paren
id|inode
)paren
comma
id|iminor
c_func
(paren
id|inode
)paren
comma
id|routine
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|check_tty_count
r_static
r_int
id|check_tty_count
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_const
r_char
op_star
id|routine
)paren
(brace
macro_line|#ifdef CHECK_TTY_COUNT
r_struct
id|list_head
op_star
id|p
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
id|file_list_lock
c_func
(paren
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|p
comma
op_amp
id|tty-&gt;tty_files
)paren
(brace
id|count
op_increment
suffix:semicolon
)brace
id|file_list_unlock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver-&gt;type
op_eq
id|TTY_DRIVER_TYPE_PTY
op_logical_and
id|tty-&gt;driver-&gt;subtype
op_eq
id|PTY_TYPE_SLAVE
op_logical_and
id|tty-&gt;link
op_logical_and
id|tty-&gt;link-&gt;count
)paren
id|count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;count
op_ne
id|count
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Warning: dev (%s) tty-&gt;count(%d) &quot;
l_string|&quot;!= #fd&squot;s(%d) in %s&bslash;n&quot;
comma
id|tty-&gt;name
comma
id|tty-&gt;count
comma
id|count
comma
id|routine
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This is probably overkill for real world processors but&n; *&t;they are not on hot paths so a little discipline won&squot;t do &n; *&t;any harm.&n; */
DECL|function|tty_set_termios_ldisc
r_static
r_void
id|tty_set_termios_ldisc
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|num
)paren
(brace
id|down
c_func
(paren
op_amp
id|tty-&gt;termios_sem
)paren
suffix:semicolon
id|tty-&gt;termios-&gt;c_line
op_assign
id|num
suffix:semicolon
id|up
c_func
(paren
op_amp
id|tty-&gt;termios_sem
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This guards the refcounted line discipline lists. The lock&n; *&t;must be taken with irqs off because there are hangup path&n; *&t;callers who will do ldisc lookups and cannot sleep.&n; */
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|tty_ldisc_lock
)paren
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|tty_ldisc_wait
)paren
suffix:semicolon
DECL|variable|tty_ldiscs
r_static
r_struct
id|tty_ldisc
id|tty_ldiscs
(braket
id|NR_LDISCS
)braket
suffix:semicolon
multiline_comment|/* line disc dispatch table&t;*/
DECL|function|tty_register_ldisc
r_int
id|tty_register_ldisc
c_func
(paren
r_int
id|disc
comma
r_struct
id|tty_ldisc
op_star
id|new_ldisc
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|disc
OL
id|N_TTY
op_logical_or
id|disc
op_ge
id|NR_LDISCS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tty_ldisc_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_ldisc
)paren
(brace
id|tty_ldiscs
(braket
id|disc
)braket
op_assign
op_star
id|new_ldisc
suffix:semicolon
id|tty_ldiscs
(braket
id|disc
)braket
dot
id|num
op_assign
id|disc
suffix:semicolon
id|tty_ldiscs
(braket
id|disc
)braket
dot
id|flags
op_or_assign
id|LDISC_FLAG_DEFINED
suffix:semicolon
id|tty_ldiscs
(braket
id|disc
)braket
dot
id|refcount
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|tty_ldiscs
(braket
id|disc
)braket
dot
id|refcount
)paren
(brace
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
r_else
id|tty_ldiscs
(braket
id|disc
)braket
dot
id|flags
op_and_assign
op_complement
id|LDISC_FLAG_DEFINED
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tty_ldisc_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|tty_register_ldisc
id|EXPORT_SYMBOL
c_func
(paren
id|tty_register_ldisc
)paren
suffix:semicolon
DECL|function|tty_ldisc_get
r_struct
id|tty_ldisc
op_star
id|tty_ldisc_get
c_func
(paren
r_int
id|disc
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|tty_ldisc
op_star
id|ld
suffix:semicolon
r_if
c_cond
(paren
id|disc
OL
id|N_TTY
op_logical_or
id|disc
op_ge
id|NR_LDISCS
)paren
r_return
l_int|NULL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tty_ldisc_lock
comma
id|flags
)paren
suffix:semicolon
id|ld
op_assign
op_amp
id|tty_ldiscs
(braket
id|disc
)braket
suffix:semicolon
multiline_comment|/* Check the entry is defined */
r_if
c_cond
(paren
id|ld-&gt;flags
op_amp
id|LDISC_FLAG_DEFINED
)paren
(brace
multiline_comment|/* If the module is being unloaded we can&squot;t use it */
r_if
c_cond
(paren
op_logical_neg
id|try_module_get
c_func
(paren
id|ld-&gt;owner
)paren
)paren
id|ld
op_assign
l_int|NULL
suffix:semicolon
r_else
multiline_comment|/* lock it */
id|ld-&gt;refcount
op_increment
suffix:semicolon
)brace
r_else
id|ld
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tty_ldisc_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ld
suffix:semicolon
)brace
DECL|variable|tty_ldisc_get
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|tty_ldisc_get
)paren
suffix:semicolon
DECL|function|tty_ldisc_put
r_void
id|tty_ldisc_put
c_func
(paren
r_int
id|disc
)paren
(brace
r_struct
id|tty_ldisc
op_star
id|ld
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|disc
OL
id|N_TTY
op_logical_or
id|disc
op_ge
id|NR_LDISCS
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tty_ldisc_lock
comma
id|flags
)paren
suffix:semicolon
id|ld
op_assign
op_amp
id|tty_ldiscs
(braket
id|disc
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ld-&gt;refcount
op_eq
l_int|0
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|ld-&gt;refcount
op_decrement
suffix:semicolon
id|module_put
c_func
(paren
id|ld-&gt;owner
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tty_ldisc_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|variable|tty_ldisc_put
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|tty_ldisc_put
)paren
suffix:semicolon
DECL|function|tty_ldisc_assign
r_static
r_void
id|tty_ldisc_assign
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|tty_ldisc
op_star
id|ld
)paren
(brace
id|tty-&gt;ldisc
op_assign
op_star
id|ld
suffix:semicolon
id|tty-&gt;ldisc.refcount
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;tty_ldisc_try&t;&t;-&t;internal helper&n; *&t;@tty: the tty&n; *&n; *&t;Make a single attempt to grab and bump the refcount on&n; *&t;the tty ldisc. Return 0 on failure or 1 on success. This is&n; *&t;used to implement both the waiting and non waiting versions&n; *&t;of tty_ldisc_ref&n; */
DECL|function|tty_ldisc_try
r_static
r_int
id|tty_ldisc_try
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|tty_ldisc
op_star
id|ld
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tty_ldisc_lock
comma
id|flags
)paren
suffix:semicolon
id|ld
op_assign
op_amp
id|tty-&gt;ldisc
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|TTY_LDISC
comma
op_amp
id|tty-&gt;flags
)paren
)paren
(brace
id|ld-&gt;refcount
op_increment
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tty_ldisc_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;tty_ldisc_ref_wait&t;-&t;wait for the tty ldisc&n; *&t;@tty: tty device&n; *&n; *&t;Dereference the line discipline for the terminal and take a &n; *&t;reference to it. If the line discipline is in flux then &n; *&t;wait patiently until it changes.&n; *&n; *&t;Note: Must not be called from an IRQ/timer context. The caller&n; *&t;must also be careful not to hold other locks that will deadlock&n; *&t;against a discipline change, such as an existing ldisc reference&n; *&t;(which we check for)&n; */
DECL|function|tty_ldisc_ref_wait
r_struct
id|tty_ldisc
op_star
id|tty_ldisc_ref_wait
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
multiline_comment|/* wait_event is a macro */
id|wait_event
c_func
(paren
id|tty_ldisc_wait
comma
id|tty_ldisc_try
c_func
(paren
id|tty
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;ldisc.refcount
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;tty_ldisc_ref_wait&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
op_amp
id|tty-&gt;ldisc
suffix:semicolon
)brace
DECL|variable|tty_ldisc_ref_wait
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|tty_ldisc_ref_wait
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;tty_ldisc_ref&t;&t;-&t;get the tty ldisc&n; *&t;@tty: tty device&n; *&n; *&t;Dereference the line discipline for the terminal and take a &n; *&t;reference to it. If the line discipline is in flux then &n; *&t;return NULL. Can be called from IRQ and timer functions.&n; */
DECL|function|tty_ldisc_ref
r_struct
id|tty_ldisc
op_star
id|tty_ldisc_ref
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_if
c_cond
(paren
id|tty_ldisc_try
c_func
(paren
id|tty
)paren
)paren
(brace
r_return
op_amp
id|tty-&gt;ldisc
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|variable|tty_ldisc_ref
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|tty_ldisc_ref
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;tty_ldisc_deref&t;&t;-&t;free a tty ldisc reference&n; *&t;@ld: reference to free up&n; *&n; *&t;Undoes the effect of tty_ldisc_ref or tty_ldisc_ref_wait. May&n; *&t;be called in IRQ context.&n; */
DECL|function|tty_ldisc_deref
r_void
id|tty_ldisc_deref
c_func
(paren
r_struct
id|tty_ldisc
op_star
id|ld
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|ld
op_eq
l_int|NULL
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tty_ldisc_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ld-&gt;refcount
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;tty_ldisc_deref: no references.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
id|ld-&gt;refcount
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|ld-&gt;refcount
op_eq
l_int|0
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|tty_ldisc_wait
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tty_ldisc_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|variable|tty_ldisc_deref
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|tty_ldisc_deref
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;tty_ldisc_enable&t;-&t;allow ldisc use&n; *&t;@tty: terminal to activate ldisc on&n; *&n; *&t;Set the TTY_LDISC flag when the line discipline can be called&n; *&t;again. Do neccessary wakeups for existing sleepers.&n; *&n; *&t;Note: nobody should set this bit except via this function. Clearing&n; *&t;directly is allowed.&n; */
DECL|function|tty_ldisc_enable
r_static
r_void
id|tty_ldisc_enable
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|set_bit
c_func
(paren
id|TTY_LDISC
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|tty_ldisc_wait
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;tty_set_ldisc&t;&t;-&t;set line discipline&n; *&t;@tty: the terminal to set&n; *&t;@ldisc: the line discipline&n; *&n; *&t;Set the discipline of a tty line. Must be called from a process&n; *&t;context.&n; */
DECL|function|tty_set_ldisc
r_static
r_int
id|tty_set_ldisc
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|ldisc
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_struct
id|tty_ldisc
id|o_ldisc
suffix:semicolon
r_char
id|buf
(braket
l_int|64
)braket
suffix:semicolon
r_int
id|work
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|tty_ldisc
op_star
id|ld
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ldisc
OL
id|N_TTY
)paren
op_logical_or
(paren
id|ldisc
op_ge
id|NR_LDISCS
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|restart
suffix:colon
r_if
c_cond
(paren
id|tty-&gt;ldisc.num
op_eq
id|ldisc
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* We are already in the desired discipline */
id|ld
op_assign
id|tty_ldisc_get
c_func
(paren
id|ldisc
)paren
suffix:semicolon
multiline_comment|/* Eduardo Blanco &lt;ejbs@cs.cs.com.uy&gt; */
multiline_comment|/* Cyrus Durgin &lt;cider@speakeasy.org&gt; */
r_if
c_cond
(paren
id|ld
op_eq
l_int|NULL
)paren
(brace
id|request_module
c_func
(paren
l_string|&quot;tty-ldisc-%d&quot;
comma
id|ldisc
)paren
suffix:semicolon
id|ld
op_assign
id|tty_ldisc_get
c_func
(paren
id|ldisc
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ld
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|o_ldisc
op_assign
id|tty-&gt;ldisc
suffix:semicolon
id|tty_wait_until_sent
c_func
(paren
id|tty
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Make sure we don&squot;t change while someone holds a&n;&t; *&t;reference to the line discipline. The TTY_LDISC bit&n;&t; *&t;prevents anyone taking a reference once it is clear.&n;&t; *&t;We need the lock to avoid racing reference takers.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tty_ldisc_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;ldisc.refcount
)paren
(brace
multiline_comment|/* Free the new ldisc we grabbed. Must drop the lock&n;&t;&t;   first. */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tty_ldisc_lock
comma
id|flags
)paren
suffix:semicolon
id|tty_ldisc_put
c_func
(paren
id|ldisc
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * There are several reasons we may be busy, including&n;&t;&t; * random momentary I/O traffic. We must therefore&n;&t;&t; * retry. We could distinguish between blocking ops&n;&t;&t; * and retries if we made tty_ldisc_wait() smarter. That&n;&t;&t; * is up for discussion.&n;&t;&t; */
r_if
c_cond
(paren
id|wait_event_interruptible
c_func
(paren
id|tty_ldisc_wait
comma
id|tty-&gt;ldisc.refcount
op_eq
l_int|0
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
r_goto
id|restart
suffix:semicolon
)brace
id|clear_bit
c_func
(paren
id|TTY_LDISC
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|TTY_DONT_FLIP
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tty_ldisc_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;From this point on we know nobody has an ldisc&n;&t; *&t;usage reference, nor can they obtain one until&n;&t; *&t;we say so later on.&n;&t; */
id|work
op_assign
id|cancel_delayed_work
c_func
(paren
op_amp
id|tty-&gt;flip.work
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Wait for -&gt;hangup_work and -&gt;flip.work handlers to terminate&n;&t; */
id|flush_scheduled_work
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Shutdown the current discipline. */
r_if
c_cond
(paren
id|tty-&gt;ldisc.close
)paren
(paren
id|tty-&gt;ldisc.close
)paren
(paren
id|tty
)paren
suffix:semicolon
multiline_comment|/* Now set up the new line discipline. */
id|tty_ldisc_assign
c_func
(paren
id|tty
comma
id|ld
)paren
suffix:semicolon
id|tty_set_termios_ldisc
c_func
(paren
id|tty
comma
id|ldisc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;ldisc.open
)paren
id|retval
op_assign
(paren
id|tty-&gt;ldisc.open
)paren
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
(brace
id|tty_ldisc_put
c_func
(paren
id|ldisc
)paren
suffix:semicolon
multiline_comment|/* There is an outstanding reference here so this is safe */
id|tty_ldisc_assign
c_func
(paren
id|tty
comma
id|tty_ldisc_get
c_func
(paren
id|o_ldisc.num
)paren
)paren
suffix:semicolon
id|tty_set_termios_ldisc
c_func
(paren
id|tty
comma
id|tty-&gt;ldisc.num
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;ldisc.open
op_logical_and
(paren
id|tty-&gt;ldisc
dot
id|open
c_func
(paren
id|tty
)paren
OL
l_int|0
)paren
)paren
(brace
id|tty_ldisc_put
c_func
(paren
id|o_ldisc.num
)paren
suffix:semicolon
multiline_comment|/* This driver is always present */
id|tty_ldisc_assign
c_func
(paren
id|tty
comma
id|tty_ldisc_get
c_func
(paren
id|N_TTY
)paren
)paren
suffix:semicolon
id|tty_set_termios_ldisc
c_func
(paren
id|tty
comma
id|N_TTY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;ldisc.open
)paren
(brace
r_int
id|r
op_assign
id|tty-&gt;ldisc
dot
id|open
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OL
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;Couldn&squot;t open N_TTY ldisc for &quot;
l_string|&quot;%s --- error %d.&quot;
comma
id|tty_name
c_func
(paren
id|tty
comma
id|buf
)paren
comma
id|r
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* At this point we hold a reference to the new ldisc and a&n;&t;   a reference to the old ldisc. If we ended up flipping back&n;&t;   to the existing ldisc we have two references to it */
r_if
c_cond
(paren
id|tty-&gt;ldisc.num
op_ne
id|o_ldisc.num
op_logical_and
id|tty-&gt;driver-&gt;set_ldisc
)paren
id|tty-&gt;driver
op_member_access_from_pointer
id|set_ldisc
c_func
(paren
id|tty
)paren
suffix:semicolon
id|tty_ldisc_put
c_func
(paren
id|o_ldisc.num
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Allow ldisc referencing to occur as soon as the driver&n;&t; *&t;ldisc callback completes.&n;&t; */
id|tty_ldisc_enable
c_func
(paren
id|tty
)paren
suffix:semicolon
multiline_comment|/* Restart it in case no characters kick it off. Safe if&n;&t;   already running */
r_if
c_cond
(paren
id|work
)paren
(brace
id|schedule_delayed_work
c_func
(paren
op_amp
id|tty-&gt;flip.work
comma
l_int|1
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine returns a tty driver structure, given a device number&n; */
DECL|function|get_tty_driver
r_static
r_struct
id|tty_driver
op_star
id|get_tty_driver
c_func
(paren
id|dev_t
id|device
comma
r_int
op_star
id|index
)paren
(brace
r_struct
id|tty_driver
op_star
id|p
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|p
comma
op_amp
id|tty_drivers
comma
id|tty_drivers
)paren
(brace
id|dev_t
id|base
op_assign
id|MKDEV
c_func
(paren
id|p-&gt;major
comma
id|p-&gt;minor_start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device
OL
id|base
op_logical_or
id|device
op_ge
id|base
op_plus
id|p-&gt;num
)paren
r_continue
suffix:semicolon
op_star
id|index
op_assign
id|device
op_minus
id|base
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * If we try to write to, or set the state of, a terminal and we&squot;re&n; * not in the foreground, send a SIGTTOU.  If the signal is blocked or&n; * ignored, go ahead and perform the operation.  (POSIX 7.2)&n; */
DECL|function|tty_check_change
r_int
id|tty_check_change
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_if
c_cond
(paren
id|current-&gt;signal-&gt;tty
op_ne
id|tty
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;pgrp
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;tty_check_change: tty-&gt;pgrp &lt;= 0!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|process_group
c_func
(paren
id|current
)paren
op_eq
id|tty-&gt;pgrp
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|is_ignored
c_func
(paren
id|SIGTTOU
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|is_orphaned_pgrp
c_func
(paren
id|process_group
c_func
(paren
id|current
)paren
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
(paren
r_void
)paren
id|kill_pg
c_func
(paren
id|process_group
c_func
(paren
id|current
)paren
comma
id|SIGTTOU
comma
l_int|1
)paren
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
DECL|variable|tty_check_change
id|EXPORT_SYMBOL
c_func
(paren
id|tty_check_change
)paren
suffix:semicolon
DECL|function|hung_up_tty_read
r_static
id|ssize_t
id|hung_up_tty_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
id|__user
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|hung_up_tty_write
r_static
id|ssize_t
id|hung_up_tty_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
id|__user
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* No kernel lock held - none needed ;) */
DECL|function|hung_up_tty_poll
r_static
r_int
r_int
id|hung_up_tty_poll
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_return
id|POLLIN
op_or
id|POLLOUT
op_or
id|POLLERR
op_or
id|POLLHUP
op_or
id|POLLRDNORM
op_or
id|POLLWRNORM
suffix:semicolon
)brace
DECL|function|hung_up_tty_ioctl
r_static
r_int
id|hung_up_tty_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_return
id|cmd
op_eq
id|TIOCSPGRP
ques
c_cond
op_minus
id|ENOTTY
suffix:colon
op_minus
id|EIO
suffix:semicolon
)brace
DECL|variable|tty_fops
r_static
r_struct
id|file_operations
id|tty_fops
op_assign
(brace
dot
id|llseek
op_assign
id|no_llseek
comma
dot
id|read
op_assign
id|tty_read
comma
dot
id|write
op_assign
id|tty_write
comma
dot
id|poll
op_assign
id|tty_poll
comma
dot
id|ioctl
op_assign
id|tty_ioctl
comma
dot
id|open
op_assign
id|tty_open
comma
dot
id|release
op_assign
id|tty_release
comma
dot
id|fasync
op_assign
id|tty_fasync
comma
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_UNIX98_PTYS
DECL|variable|ptmx_fops
r_static
r_struct
id|file_operations
id|ptmx_fops
op_assign
(brace
dot
id|llseek
op_assign
id|no_llseek
comma
dot
id|read
op_assign
id|tty_read
comma
dot
id|write
op_assign
id|tty_write
comma
dot
id|poll
op_assign
id|tty_poll
comma
dot
id|ioctl
op_assign
id|tty_ioctl
comma
dot
id|open
op_assign
id|ptmx_open
comma
dot
id|release
op_assign
id|tty_release
comma
dot
id|fasync
op_assign
id|tty_fasync
comma
)brace
suffix:semicolon
macro_line|#endif
DECL|variable|console_fops
r_static
r_struct
id|file_operations
id|console_fops
op_assign
(brace
dot
id|llseek
op_assign
id|no_llseek
comma
dot
id|read
op_assign
id|tty_read
comma
dot
id|write
op_assign
id|redirected_tty_write
comma
dot
id|poll
op_assign
id|tty_poll
comma
dot
id|ioctl
op_assign
id|tty_ioctl
comma
dot
id|open
op_assign
id|tty_open
comma
dot
id|release
op_assign
id|tty_release
comma
dot
id|fasync
op_assign
id|tty_fasync
comma
)brace
suffix:semicolon
DECL|variable|hung_up_tty_fops
r_static
r_struct
id|file_operations
id|hung_up_tty_fops
op_assign
(brace
dot
id|llseek
op_assign
id|no_llseek
comma
dot
id|read
op_assign
id|hung_up_tty_read
comma
dot
id|write
op_assign
id|hung_up_tty_write
comma
dot
id|poll
op_assign
id|hung_up_tty_poll
comma
dot
id|ioctl
op_assign
id|hung_up_tty_ioctl
comma
dot
id|release
op_assign
id|tty_release
comma
)brace
suffix:semicolon
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|redirect_lock
)paren
suffix:semicolon
DECL|variable|redirect
r_static
r_struct
id|file
op_star
id|redirect
suffix:semicolon
multiline_comment|/**&n; *&t;tty_wakeup&t;-&t;request more data&n; *&t;@tty: terminal&n; *&n; *&t;Internal and external helper for wakeups of tty. This function&n; *&t;informs the line discipline if present that the driver is ready&n; *&t;to receive more output data.&n; */
DECL|function|tty_wakeup
r_void
id|tty_wakeup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|tty_ldisc
op_star
id|ld
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|TTY_DO_WRITE_WAKEUP
comma
op_amp
id|tty-&gt;flags
)paren
)paren
(brace
id|ld
op_assign
id|tty_ldisc_ref
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ld
)paren
(brace
r_if
c_cond
(paren
id|ld-&gt;write_wakeup
)paren
(brace
id|ld
op_member_access_from_pointer
id|write_wakeup
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
id|tty_ldisc_deref
c_func
(paren
id|ld
)paren
suffix:semicolon
)brace
)brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
)brace
DECL|variable|tty_wakeup
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|tty_wakeup
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;tty_ldisc_flush&t;-&t;flush line discipline queue&n; *&t;@tty: tty&n; *&n; *&t;Flush the line discipline queue (if any) for this tty. If there&n; *&t;is no line discipline active this is a no-op.&n; */
DECL|function|tty_ldisc_flush
r_void
id|tty_ldisc_flush
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|tty_ldisc
op_star
id|ld
op_assign
id|tty_ldisc_ref
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ld
)paren
(brace
r_if
c_cond
(paren
id|ld-&gt;flush_buffer
)paren
(brace
id|ld
op_member_access_from_pointer
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
id|tty_ldisc_deref
c_func
(paren
id|ld
)paren
suffix:semicolon
)brace
)brace
DECL|variable|tty_ldisc_flush
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|tty_ldisc_flush
)paren
suffix:semicolon
multiline_comment|/*&n; * This can be called by the &quot;eventd&quot; kernel thread.  That is process synchronous,&n; * but doesn&squot;t hold any locks, so we need to make sure we have the appropriate&n; * locks for what we&squot;re doing..&n; */
DECL|function|do_tty_hangup
r_static
r_void
id|do_tty_hangup
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
op_assign
(paren
r_struct
id|tty_struct
op_star
)paren
id|data
suffix:semicolon
r_struct
id|file
op_star
id|cons_filp
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|file
op_star
id|filp
comma
op_star
id|f
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_struct
id|tty_ldisc
op_star
id|ld
suffix:semicolon
r_int
id|closecount
op_assign
l_int|0
comma
id|n
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
multiline_comment|/* inuse_filps is protected by the single kernel lock */
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|redirect_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|redirect
op_logical_and
id|redirect-&gt;private_data
op_eq
id|tty
)paren
(brace
id|f
op_assign
id|redirect
suffix:semicolon
id|redirect
op_assign
l_int|NULL
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|redirect_lock
)paren
suffix:semicolon
id|check_tty_count
c_func
(paren
id|tty
comma
l_string|&quot;do_tty_hangup&quot;
)paren
suffix:semicolon
id|file_list_lock
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* This breaks for file handles being sent over AF_UNIX sockets ? */
id|list_for_each_entry
c_func
(paren
id|filp
comma
op_amp
id|tty-&gt;tty_files
comma
id|f_list
)paren
(brace
r_if
c_cond
(paren
id|filp-&gt;f_op-&gt;write
op_eq
id|redirected_tty_write
)paren
id|cons_filp
op_assign
id|filp
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_op-&gt;write
op_ne
id|tty_write
)paren
r_continue
suffix:semicolon
id|closecount
op_increment
suffix:semicolon
id|tty_fasync
c_func
(paren
op_minus
l_int|1
comma
id|filp
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* can&squot;t block */
id|filp-&gt;f_op
op_assign
op_amp
id|hung_up_tty_fops
suffix:semicolon
)brace
id|file_list_unlock
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* FIXME! What are the locking issues here? This may me overdoing things..&n;&t; * this question is especially important now that we&squot;ve removed the irqlock. */
id|ld
op_assign
id|tty_ldisc_ref
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ld
op_ne
l_int|NULL
)paren
multiline_comment|/* We may have no line discipline at this point */
(brace
r_if
c_cond
(paren
id|ld-&gt;flush_buffer
)paren
id|ld
op_member_access_from_pointer
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver-&gt;flush_buffer
)paren
id|tty-&gt;driver
op_member_access_from_pointer
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|test_bit
c_func
(paren
id|TTY_DO_WRITE_WAKEUP
comma
op_amp
id|tty-&gt;flags
)paren
)paren
op_logical_and
id|ld-&gt;write_wakeup
)paren
id|ld
op_member_access_from_pointer
id|write_wakeup
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ld-&gt;hangup
)paren
id|ld
op_member_access_from_pointer
id|hangup
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/* FIXME: Once we trust the LDISC code better we can wait here for&n;&t;   ldisc completion and fix the driver call race */
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;read_wait
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Shutdown the current line discipline, and reset it to&n;&t; * N_TTY.&n;&t; */
r_if
c_cond
(paren
id|tty-&gt;driver-&gt;flags
op_amp
id|TTY_DRIVER_RESET_TERMIOS
)paren
(brace
id|down
c_func
(paren
op_amp
id|tty-&gt;termios_sem
)paren
suffix:semicolon
op_star
id|tty-&gt;termios
op_assign
id|tty-&gt;driver-&gt;init_termios
suffix:semicolon
id|up
c_func
(paren
op_amp
id|tty-&gt;termios_sem
)paren
suffix:semicolon
)brace
multiline_comment|/* Defer ldisc switch */
multiline_comment|/* tty_deferred_ldisc_switch(N_TTY);&n;&t;&n;&t;  This should get done automatically when the port closes and&n;&t;  tty_release is called */
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;session
OG
l_int|0
)paren
(brace
id|do_each_task_pid
c_func
(paren
id|tty-&gt;session
comma
id|PIDTYPE_SID
comma
id|p
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;signal-&gt;tty
op_eq
id|tty
)paren
id|p-&gt;signal-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;signal-&gt;leader
)paren
r_continue
suffix:semicolon
id|send_group_sig_info
c_func
(paren
id|SIGHUP
comma
id|SEND_SIG_PRIV
comma
id|p
)paren
suffix:semicolon
id|send_group_sig_info
c_func
(paren
id|SIGCONT
comma
id|SEND_SIG_PRIV
comma
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;pgrp
OG
l_int|0
)paren
id|p-&gt;signal-&gt;tty_old_pgrp
op_assign
id|tty-&gt;pgrp
suffix:semicolon
)brace
id|while_each_task_pid
c_func
(paren
id|tty-&gt;session
comma
id|PIDTYPE_SID
comma
id|p
)paren
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|tty-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|tty-&gt;session
op_assign
l_int|0
suffix:semicolon
id|tty-&gt;pgrp
op_assign
op_minus
l_int|1
suffix:semicolon
id|tty-&gt;ctrl_status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If one of the devices matches a console pointer, we&n;&t; *&t;cannot just call hangup() because that will cause&n;&t; *&t;tty-&gt;count and state-&gt;count to go out of sync.&n;&t; *&t;So we just call close() the right number of times.&n;&t; */
r_if
c_cond
(paren
id|cons_filp
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;driver-&gt;close
)paren
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|closecount
suffix:semicolon
id|n
op_increment
)paren
id|tty-&gt;driver
op_member_access_from_pointer
id|close
c_func
(paren
id|tty
comma
id|cons_filp
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tty-&gt;driver-&gt;hangup
)paren
(paren
id|tty-&gt;driver-&gt;hangup
)paren
(paren
id|tty
)paren
suffix:semicolon
multiline_comment|/* We don&squot;t want to have driver/ldisc interactions beyond&n;&t;   the ones we did here. The driver layer expects no&n;&t;   calls after -&gt;hangup() from the ldisc side. However we&n;&t;   can&squot;t yet guarantee all that */
id|set_bit
c_func
(paren
id|TTY_HUPPED
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ld
)paren
(brace
id|tty_ldisc_enable
c_func
(paren
id|tty
)paren
suffix:semicolon
id|tty_ldisc_deref
c_func
(paren
id|ld
)paren
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f
)paren
id|fput
c_func
(paren
id|f
)paren
suffix:semicolon
)brace
DECL|function|tty_hangup
r_void
id|tty_hangup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
macro_line|#ifdef TTY_DEBUG_HANGUP
r_char
id|buf
(braket
l_int|64
)braket
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s hangup...&bslash;n&quot;
comma
id|tty_name
c_func
(paren
id|tty
comma
id|buf
)paren
)paren
suffix:semicolon
macro_line|#endif
id|schedule_work
c_func
(paren
op_amp
id|tty-&gt;hangup_work
)paren
suffix:semicolon
)brace
DECL|variable|tty_hangup
id|EXPORT_SYMBOL
c_func
(paren
id|tty_hangup
)paren
suffix:semicolon
DECL|function|tty_vhangup
r_void
id|tty_vhangup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
macro_line|#ifdef TTY_DEBUG_HANGUP
r_char
id|buf
(braket
l_int|64
)braket
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s vhangup...&bslash;n&quot;
comma
id|tty_name
c_func
(paren
id|tty
comma
id|buf
)paren
)paren
suffix:semicolon
macro_line|#endif
id|do_tty_hangup
c_func
(paren
(paren
r_void
op_star
)paren
id|tty
)paren
suffix:semicolon
)brace
DECL|variable|tty_vhangup
id|EXPORT_SYMBOL
c_func
(paren
id|tty_vhangup
)paren
suffix:semicolon
DECL|function|tty_hung_up_p
r_int
id|tty_hung_up_p
c_func
(paren
r_struct
id|file
op_star
id|filp
)paren
(brace
r_return
(paren
id|filp-&gt;f_op
op_eq
op_amp
id|hung_up_tty_fops
)paren
suffix:semicolon
)brace
DECL|variable|tty_hung_up_p
id|EXPORT_SYMBOL
c_func
(paren
id|tty_hung_up_p
)paren
suffix:semicolon
multiline_comment|/*&n; * This function is typically called only by the session leader, when&n; * it wants to disassociate itself from its controlling tty.&n; *&n; * It performs the following functions:&n; * &t;(1)  Sends a SIGHUP and SIGCONT to the foreground process group&n; * &t;(2)  Clears the tty from being controlling the session&n; * &t;(3)  Clears the controlling tty for all processes in the&n; * &t;&t;session group.&n; *&n; * The argument on_exit is set to 1 if called when a process is&n; * exiting; it is 0 if called by the ioctl TIOCNOTTY.&n; */
DECL|function|disassociate_ctty
r_void
id|disassociate_ctty
c_func
(paren
r_int
id|on_exit
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_int
id|tty_pgrp
op_assign
op_minus
l_int|1
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|tty_sem
)paren
suffix:semicolon
id|tty
op_assign
id|current-&gt;signal-&gt;tty
suffix:semicolon
r_if
c_cond
(paren
id|tty
)paren
(brace
id|tty_pgrp
op_assign
id|tty-&gt;pgrp
suffix:semicolon
id|up
c_func
(paren
op_amp
id|tty_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|on_exit
op_logical_and
id|tty-&gt;driver-&gt;type
op_ne
id|TTY_DRIVER_TYPE_PTY
)paren
id|tty_vhangup
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|current-&gt;signal-&gt;tty_old_pgrp
)paren
(brace
id|kill_pg
c_func
(paren
id|current-&gt;signal-&gt;tty_old_pgrp
comma
id|SIGHUP
comma
id|on_exit
)paren
suffix:semicolon
id|kill_pg
c_func
(paren
id|current-&gt;signal-&gt;tty_old_pgrp
comma
id|SIGCONT
comma
id|on_exit
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|tty_sem
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty_pgrp
OG
l_int|0
)paren
(brace
id|kill_pg
c_func
(paren
id|tty_pgrp
comma
id|SIGHUP
comma
id|on_exit
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|on_exit
)paren
id|kill_pg
c_func
(paren
id|tty_pgrp
comma
id|SIGCONT
comma
id|on_exit
)paren
suffix:semicolon
)brace
multiline_comment|/* Must lock changes to tty_old_pgrp */
id|down
c_func
(paren
op_amp
id|tty_sem
)paren
suffix:semicolon
id|current-&gt;signal-&gt;tty_old_pgrp
op_assign
l_int|0
suffix:semicolon
id|tty-&gt;session
op_assign
l_int|0
suffix:semicolon
id|tty-&gt;pgrp
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Now clear signal-&gt;tty under the lock */
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|do_each_task_pid
c_func
(paren
id|current-&gt;signal-&gt;session
comma
id|PIDTYPE_SID
comma
id|p
)paren
(brace
id|p-&gt;signal-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
)brace
id|while_each_task_pid
c_func
(paren
id|current-&gt;signal-&gt;session
comma
id|PIDTYPE_SID
comma
id|p
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|tty_sem
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|stop_tty
r_void
id|stop_tty
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;stopped
)paren
r_return
suffix:semicolon
id|tty-&gt;stopped
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;link
op_logical_and
id|tty-&gt;link-&gt;packet
)paren
(brace
id|tty-&gt;ctrl_status
op_and_assign
op_complement
id|TIOCPKT_START
suffix:semicolon
id|tty-&gt;ctrl_status
op_or_assign
id|TIOCPKT_STOP
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;link-&gt;read_wait
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;driver-&gt;stop
)paren
(paren
id|tty-&gt;driver-&gt;stop
)paren
(paren
id|tty
)paren
suffix:semicolon
)brace
DECL|variable|stop_tty
id|EXPORT_SYMBOL
c_func
(paren
id|stop_tty
)paren
suffix:semicolon
DECL|function|start_tty
r_void
id|start_tty
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;stopped
op_logical_or
id|tty-&gt;flow_stopped
)paren
r_return
suffix:semicolon
id|tty-&gt;stopped
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;link
op_logical_and
id|tty-&gt;link-&gt;packet
)paren
(brace
id|tty-&gt;ctrl_status
op_and_assign
op_complement
id|TIOCPKT_STOP
suffix:semicolon
id|tty-&gt;ctrl_status
op_or_assign
id|TIOCPKT_START
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;link-&gt;read_wait
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;driver-&gt;start
)paren
(paren
id|tty-&gt;driver-&gt;start
)paren
(paren
id|tty
)paren
suffix:semicolon
multiline_comment|/* If we have a running line discipline it may need kicking */
id|tty_wakeup
c_func
(paren
id|tty
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
)brace
DECL|variable|start_tty
id|EXPORT_SYMBOL
c_func
(paren
id|start_tty
)paren
suffix:semicolon
DECL|function|tty_read
r_static
id|ssize_t
id|tty_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
id|__user
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|tty_ldisc
op_star
id|ld
suffix:semicolon
id|tty
op_assign
(paren
r_struct
id|tty_struct
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|tty_paranoia_check
c_func
(paren
id|tty
comma
id|inode
comma
l_string|&quot;tty_read&quot;
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
op_logical_or
(paren
id|test_bit
c_func
(paren
id|TTY_IO_ERROR
comma
op_amp
id|tty-&gt;flags
)paren
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* We want to wait for the line discipline to sort out in this&n;&t;   situation */
id|ld
op_assign
id|tty_ldisc_ref_wait
c_func
(paren
id|tty
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ld-&gt;read
)paren
id|i
op_assign
(paren
id|ld-&gt;read
)paren
(paren
id|tty
comma
id|file
comma
id|buf
comma
id|count
)paren
suffix:semicolon
r_else
id|i
op_assign
op_minus
id|EIO
suffix:semicolon
id|tty_ldisc_deref
c_func
(paren
id|ld
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|0
)paren
id|inode-&gt;i_atime
op_assign
id|current_fs_time
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/*&n; * Split writes up in sane blocksizes to avoid&n; * denial-of-service type attacks&n; */
DECL|function|do_tty_write
r_static
r_inline
id|ssize_t
id|do_tty_write
c_func
(paren
id|ssize_t
(paren
op_star
id|write
)paren
(paren
r_struct
id|tty_struct
op_star
comma
r_struct
id|file
op_star
comma
r_const
r_int
r_char
op_star
comma
r_int
)paren
comma
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_const
r_char
id|__user
op_star
id|buf
comma
r_int
id|count
)paren
(brace
id|ssize_t
id|ret
op_assign
l_int|0
comma
id|written
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|chunk
suffix:semicolon
r_if
c_cond
(paren
id|down_interruptible
c_func
(paren
op_amp
id|tty-&gt;atomic_write
)paren
)paren
(brace
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We chunk up writes into a temporary buffer. This&n;&t; * simplifies low-level drivers immensely, since they&n;&t; * don&squot;t have locking issues and user mode accesses.&n;&t; *&n;&t; * But if TTY_NO_WRITE_SPLIT is set, we should use a&n;&t; * big chunk-size..&n;&t; *&n;&t; * The default chunk-size is 2kB, because the NTTY&n;&t; * layer has problems with bigger chunks. It will&n;&t; * claim to be able to handle more characters than&n;&t; * it actually does.&n;&t; */
id|chunk
op_assign
l_int|2048
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|TTY_NO_WRITE_SPLIT
comma
op_amp
id|tty-&gt;flags
)paren
)paren
id|chunk
op_assign
l_int|65536
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
id|chunk
)paren
id|chunk
op_assign
id|count
suffix:semicolon
multiline_comment|/* write_buf/write_cnt is protected by the atomic_write semaphore */
r_if
c_cond
(paren
id|tty-&gt;write_cnt
OL
id|chunk
)paren
(brace
r_int
r_char
op_star
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|chunk
OL
l_int|1024
)paren
id|chunk
op_assign
l_int|1024
suffix:semicolon
id|buf
op_assign
id|kmalloc
c_func
(paren
id|chunk
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
(brace
id|up
c_func
(paren
op_amp
id|tty-&gt;atomic_write
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|tty-&gt;write_buf
)paren
suffix:semicolon
id|tty-&gt;write_cnt
op_assign
id|chunk
suffix:semicolon
id|tty-&gt;write_buf
op_assign
id|buf
suffix:semicolon
)brace
multiline_comment|/* Do the write .. */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|size
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|chunk
)paren
id|size
op_assign
id|chunk
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|tty-&gt;write_buf
comma
id|buf
comma
id|size
)paren
)paren
r_break
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|ret
op_assign
id|write
c_func
(paren
id|tty
comma
id|file
comma
id|tty-&gt;write_buf
comma
id|size
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_le
l_int|0
)paren
r_break
suffix:semicolon
id|written
op_add_assign
id|ret
suffix:semicolon
id|buf
op_add_assign
id|ret
suffix:semicolon
id|count
op_sub_assign
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
r_break
suffix:semicolon
id|ret
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|written
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
id|inode-&gt;i_mtime
op_assign
id|current_fs_time
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|ret
op_assign
id|written
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|tty-&gt;atomic_write
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|tty_write
r_static
id|ssize_t
id|tty_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
id|__user
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
r_struct
id|tty_ldisc
op_star
id|ld
suffix:semicolon
id|tty
op_assign
(paren
r_struct
id|tty_struct
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|tty_paranoia_check
c_func
(paren
id|tty
comma
id|inode
comma
l_string|&quot;tty_write&quot;
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
op_logical_or
op_logical_neg
id|tty-&gt;driver-&gt;write
op_logical_or
(paren
id|test_bit
c_func
(paren
id|TTY_IO_ERROR
comma
op_amp
id|tty-&gt;flags
)paren
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|ld
op_assign
id|tty_ldisc_ref_wait
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ld-&gt;write
)paren
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_else
id|ret
op_assign
id|do_tty_write
c_func
(paren
id|ld-&gt;write
comma
id|tty
comma
id|file
comma
id|buf
comma
id|count
)paren
suffix:semicolon
id|tty_ldisc_deref
c_func
(paren
id|ld
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|redirected_tty_write
id|ssize_t
id|redirected_tty_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
id|__user
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|file
op_star
id|p
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|redirect_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|redirect
)paren
(brace
id|get_file
c_func
(paren
id|redirect
)paren
suffix:semicolon
id|p
op_assign
id|redirect
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|redirect_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
(brace
id|ssize_t
id|res
suffix:semicolon
id|res
op_assign
id|vfs_write
c_func
(paren
id|p
comma
id|buf
comma
id|count
comma
op_amp
id|p-&gt;f_pos
)paren
suffix:semicolon
id|fput
c_func
(paren
id|p
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
r_return
id|tty_write
c_func
(paren
id|file
comma
id|buf
comma
id|count
comma
id|ppos
)paren
suffix:semicolon
)brace
DECL|variable|ptychar
r_static
r_char
id|ptychar
(braket
)braket
op_assign
l_string|&quot;pqrstuvwxyzabcde&quot;
suffix:semicolon
DECL|function|pty_line_name
r_static
r_inline
r_void
id|pty_line_name
c_func
(paren
r_struct
id|tty_driver
op_star
id|driver
comma
r_int
id|index
comma
r_char
op_star
id|p
)paren
(brace
r_int
id|i
op_assign
id|index
op_plus
id|driver-&gt;name_base
suffix:semicolon
multiline_comment|/* -&gt;name is initialized to &quot;ttyp&quot;, but &quot;tty&quot; is expected */
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%s%c%x&quot;
comma
id|driver-&gt;subtype
op_eq
id|PTY_TYPE_SLAVE
ques
c_cond
l_string|&quot;tty&quot;
suffix:colon
id|driver-&gt;name
comma
id|ptychar
(braket
id|i
op_rshift
l_int|4
op_amp
l_int|0xf
)braket
comma
id|i
op_amp
l_int|0xf
)paren
suffix:semicolon
)brace
DECL|function|tty_line_name
r_static
r_inline
r_void
id|tty_line_name
c_func
(paren
r_struct
id|tty_driver
op_star
id|driver
comma
r_int
id|index
comma
r_char
op_star
id|p
)paren
(brace
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%s%d&quot;
comma
id|driver-&gt;name
comma
id|index
op_plus
id|driver-&gt;name_base
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * WSH 06/09/97: Rewritten to remove races and properly clean up after a&n; * failed open.  The new code protects the open with a semaphore, so it&squot;s&n; * really quite straightforward.  The semaphore locking can probably be&n; * relaxed for the (most common) case of reopening a tty.&n; */
DECL|function|init_dev
r_static
r_int
id|init_dev
c_func
(paren
r_struct
id|tty_driver
op_star
id|driver
comma
r_int
id|idx
comma
r_struct
id|tty_struct
op_star
op_star
id|ret_tty
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
comma
op_star
id|o_tty
suffix:semicolon
r_struct
id|termios
op_star
id|tp
comma
op_star
op_star
id|tp_loc
comma
op_star
id|o_tp
comma
op_star
op_star
id|o_tp_loc
suffix:semicolon
r_struct
id|termios
op_star
id|ltp
comma
op_star
op_star
id|ltp_loc
comma
op_star
id|o_ltp
comma
op_star
op_star
id|o_ltp_loc
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* check whether we&squot;re reopening an existing tty */
r_if
c_cond
(paren
id|driver-&gt;flags
op_amp
id|TTY_DRIVER_DEVPTS_MEM
)paren
(brace
id|tty
op_assign
id|devpts_get_tty
c_func
(paren
id|idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty
op_logical_and
id|driver-&gt;subtype
op_eq
id|PTY_TYPE_MASTER
)paren
id|tty
op_assign
id|tty-&gt;link
suffix:semicolon
)brace
r_else
(brace
id|tty
op_assign
id|driver-&gt;ttys
(braket
id|idx
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty
)paren
r_goto
id|fast_track
suffix:semicolon
multiline_comment|/*&n;&t; * First time open is complex, especially for PTY devices.&n;&t; * This code guarantees that either everything succeeds and the&n;&t; * TTY is ready for operation, or else the table slots are vacated&n;&t; * and the allocated memory released.  (Except that the termios &n;&t; * and locked termios may be retained.)&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|try_module_get
c_func
(paren
id|driver-&gt;owner
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|end_init
suffix:semicolon
)brace
id|o_tty
op_assign
l_int|NULL
suffix:semicolon
id|tp
op_assign
id|o_tp
op_assign
l_int|NULL
suffix:semicolon
id|ltp
op_assign
id|o_ltp
op_assign
l_int|NULL
suffix:semicolon
id|tty
op_assign
id|alloc_tty_struct
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
(brace
r_goto
id|fail_no_mem
suffix:semicolon
)brace
id|initialize_tty_struct
c_func
(paren
id|tty
)paren
suffix:semicolon
id|tty-&gt;driver
op_assign
id|driver
suffix:semicolon
id|tty-&gt;index
op_assign
id|idx
suffix:semicolon
id|tty_line_name
c_func
(paren
id|driver
comma
id|idx
comma
id|tty-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver-&gt;flags
op_amp
id|TTY_DRIVER_DEVPTS_MEM
)paren
(brace
id|tp_loc
op_assign
op_amp
id|tty-&gt;termios
suffix:semicolon
id|ltp_loc
op_assign
op_amp
id|tty-&gt;termios_locked
suffix:semicolon
)brace
r_else
(brace
id|tp_loc
op_assign
op_amp
id|driver-&gt;termios
(braket
id|idx
)braket
suffix:semicolon
id|ltp_loc
op_assign
op_amp
id|driver-&gt;termios_locked
(braket
id|idx
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|tp_loc
)paren
(brace
id|tp
op_assign
(paren
r_struct
id|termios
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|termios
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tp
)paren
r_goto
id|free_mem_out
suffix:semicolon
op_star
id|tp
op_assign
id|driver-&gt;init_termios
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|ltp_loc
)paren
(brace
id|ltp
op_assign
(paren
r_struct
id|termios
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|termios
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ltp
)paren
r_goto
id|free_mem_out
suffix:semicolon
id|memset
c_func
(paren
id|ltp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|termios
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|driver-&gt;type
op_eq
id|TTY_DRIVER_TYPE_PTY
)paren
(brace
id|o_tty
op_assign
id|alloc_tty_struct
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|o_tty
)paren
r_goto
id|free_mem_out
suffix:semicolon
id|initialize_tty_struct
c_func
(paren
id|o_tty
)paren
suffix:semicolon
id|o_tty-&gt;driver
op_assign
id|driver-&gt;other
suffix:semicolon
id|o_tty-&gt;index
op_assign
id|idx
suffix:semicolon
id|tty_line_name
c_func
(paren
id|driver-&gt;other
comma
id|idx
comma
id|o_tty-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver-&gt;flags
op_amp
id|TTY_DRIVER_DEVPTS_MEM
)paren
(brace
id|o_tp_loc
op_assign
op_amp
id|o_tty-&gt;termios
suffix:semicolon
id|o_ltp_loc
op_assign
op_amp
id|o_tty-&gt;termios_locked
suffix:semicolon
)brace
r_else
(brace
id|o_tp_loc
op_assign
op_amp
id|driver-&gt;other-&gt;termios
(braket
id|idx
)braket
suffix:semicolon
id|o_ltp_loc
op_assign
op_amp
id|driver-&gt;other-&gt;termios_locked
(braket
id|idx
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|o_tp_loc
)paren
(brace
id|o_tp
op_assign
(paren
r_struct
id|termios
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|termios
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|o_tp
)paren
r_goto
id|free_mem_out
suffix:semicolon
op_star
id|o_tp
op_assign
id|driver-&gt;other-&gt;init_termios
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|o_ltp_loc
)paren
(brace
id|o_ltp
op_assign
(paren
r_struct
id|termios
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|termios
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|o_ltp
)paren
r_goto
id|free_mem_out
suffix:semicolon
id|memset
c_func
(paren
id|o_ltp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|termios
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Everything allocated ... set up the o_tty structure.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|driver-&gt;other-&gt;flags
op_amp
id|TTY_DRIVER_DEVPTS_MEM
)paren
)paren
(brace
id|driver-&gt;other-&gt;ttys
(braket
id|idx
)braket
op_assign
id|o_tty
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|o_tp_loc
)paren
op_star
id|o_tp_loc
op_assign
id|o_tp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|o_ltp_loc
)paren
op_star
id|o_ltp_loc
op_assign
id|o_ltp
suffix:semicolon
id|o_tty-&gt;termios
op_assign
op_star
id|o_tp_loc
suffix:semicolon
id|o_tty-&gt;termios_locked
op_assign
op_star
id|o_ltp_loc
suffix:semicolon
id|driver-&gt;other-&gt;refcount
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|driver-&gt;subtype
op_eq
id|PTY_TYPE_MASTER
)paren
id|o_tty-&gt;count
op_increment
suffix:semicolon
multiline_comment|/* Establish the links in both directions */
id|tty-&gt;link
op_assign
id|o_tty
suffix:semicolon
id|o_tty-&gt;link
op_assign
id|tty
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * All structures have been allocated, so now we install them.&n;&t; * Failures after this point use release_mem to clean up, so &n;&t; * there&squot;s no need to null out the local pointers.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|driver-&gt;flags
op_amp
id|TTY_DRIVER_DEVPTS_MEM
)paren
)paren
(brace
id|driver-&gt;ttys
(braket
id|idx
)braket
op_assign
id|tty
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|tp_loc
)paren
op_star
id|tp_loc
op_assign
id|tp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|ltp_loc
)paren
op_star
id|ltp_loc
op_assign
id|ltp
suffix:semicolon
id|tty-&gt;termios
op_assign
op_star
id|tp_loc
suffix:semicolon
id|tty-&gt;termios_locked
op_assign
op_star
id|ltp_loc
suffix:semicolon
id|driver-&gt;refcount
op_increment
suffix:semicolon
id|tty-&gt;count
op_increment
suffix:semicolon
multiline_comment|/* &n;&t; * Structures all installed ... call the ldisc open routines.&n;&t; * If we fail here just call release_mem to clean up.  No need&n;&t; * to decrement the use counts, as release_mem doesn&squot;t care.&n;&t; */
r_if
c_cond
(paren
id|tty-&gt;ldisc.open
)paren
(brace
id|retval
op_assign
(paren
id|tty-&gt;ldisc.open
)paren
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|release_mem_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|o_tty
op_logical_and
id|o_tty-&gt;ldisc.open
)paren
(brace
id|retval
op_assign
(paren
id|o_tty-&gt;ldisc.open
)paren
(paren
id|o_tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;ldisc.close
)paren
(paren
id|tty-&gt;ldisc.close
)paren
(paren
id|tty
)paren
suffix:semicolon
r_goto
id|release_mem_out
suffix:semicolon
)brace
id|tty_ldisc_enable
c_func
(paren
id|o_tty
)paren
suffix:semicolon
)brace
id|tty_ldisc_enable
c_func
(paren
id|tty
)paren
suffix:semicolon
r_goto
id|success
suffix:semicolon
multiline_comment|/*&n;&t; * This fast open can be used if the tty is already open.&n;&t; * No memory is allocated, and the only failures are from&n;&t; * attempting to open a closing tty or attempting multiple&n;&t; * opens on a pty master.&n;&t; */
id|fast_track
suffix:colon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|TTY_CLOSING
comma
op_amp
id|tty-&gt;flags
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|end_init
suffix:semicolon
)brace
r_if
c_cond
(paren
id|driver-&gt;type
op_eq
id|TTY_DRIVER_TYPE_PTY
op_logical_and
id|driver-&gt;subtype
op_eq
id|PTY_TYPE_MASTER
)paren
(brace
multiline_comment|/*&n;&t;&t; * special case for PTY masters: only one open permitted, &n;&t;&t; * and the slave side open count is incremented as well.&n;&t;&t; */
r_if
c_cond
(paren
id|tty-&gt;count
)paren
(brace
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|end_init
suffix:semicolon
)brace
id|tty-&gt;link-&gt;count
op_increment
suffix:semicolon
)brace
id|tty-&gt;count
op_increment
suffix:semicolon
id|tty-&gt;driver
op_assign
id|driver
suffix:semicolon
multiline_comment|/* N.B. why do this every time?? */
multiline_comment|/* FIXME */
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|TTY_LDISC
comma
op_amp
id|tty-&gt;flags
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_dev but no ldisc&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|success
suffix:colon
op_star
id|ret_tty
op_assign
id|tty
suffix:semicolon
multiline_comment|/* All paths come through here to release the semaphore */
id|end_init
suffix:colon
r_return
id|retval
suffix:semicolon
multiline_comment|/* Release locally allocated memory ... nothing placed in slots */
id|free_mem_out
suffix:colon
r_if
c_cond
(paren
id|o_tp
)paren
id|kfree
c_func
(paren
id|o_tp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|o_tty
)paren
id|free_tty_struct
c_func
(paren
id|o_tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ltp
)paren
id|kfree
c_func
(paren
id|ltp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp
)paren
id|kfree
c_func
(paren
id|tp
)paren
suffix:semicolon
id|free_tty_struct
c_func
(paren
id|tty
)paren
suffix:semicolon
id|fail_no_mem
suffix:colon
id|module_put
c_func
(paren
id|driver-&gt;owner
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|end_init
suffix:semicolon
multiline_comment|/* call the tty release_mem routine to clean out this slot */
id|release_mem_out
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;init_dev: ldisc open failed, &quot;
l_string|&quot;clearing slot %d&bslash;n&quot;
comma
id|idx
)paren
suffix:semicolon
id|release_mem
c_func
(paren
id|tty
comma
id|idx
)paren
suffix:semicolon
r_goto
id|end_init
suffix:semicolon
)brace
multiline_comment|/*&n; * Releases memory associated with a tty structure, and clears out the&n; * driver table slots.&n; */
DECL|function|release_mem
r_static
r_void
id|release_mem
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|idx
)paren
(brace
r_struct
id|tty_struct
op_star
id|o_tty
suffix:semicolon
r_struct
id|termios
op_star
id|tp
suffix:semicolon
r_int
id|devpts
op_assign
id|tty-&gt;driver-&gt;flags
op_amp
id|TTY_DRIVER_DEVPTS_MEM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|o_tty
op_assign
id|tty-&gt;link
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|devpts
)paren
id|o_tty-&gt;driver-&gt;ttys
(braket
id|idx
)braket
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|o_tty-&gt;driver-&gt;flags
op_amp
id|TTY_DRIVER_RESET_TERMIOS
)paren
(brace
id|tp
op_assign
id|o_tty-&gt;termios
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|devpts
)paren
id|o_tty-&gt;driver-&gt;termios
(braket
id|idx
)braket
op_assign
l_int|NULL
suffix:semicolon
id|kfree
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tp
op_assign
id|o_tty-&gt;termios_locked
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|devpts
)paren
id|o_tty-&gt;driver-&gt;termios_locked
(braket
id|idx
)braket
op_assign
l_int|NULL
suffix:semicolon
id|kfree
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
id|o_tty-&gt;magic
op_assign
l_int|0
suffix:semicolon
id|o_tty-&gt;driver-&gt;refcount
op_decrement
suffix:semicolon
id|file_list_lock
c_func
(paren
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|o_tty-&gt;tty_files
)paren
suffix:semicolon
id|file_list_unlock
c_func
(paren
)paren
suffix:semicolon
id|free_tty_struct
c_func
(paren
id|o_tty
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|devpts
)paren
id|tty-&gt;driver-&gt;ttys
(braket
id|idx
)braket
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver-&gt;flags
op_amp
id|TTY_DRIVER_RESET_TERMIOS
)paren
(brace
id|tp
op_assign
id|tty-&gt;termios
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|devpts
)paren
id|tty-&gt;driver-&gt;termios
(braket
id|idx
)braket
op_assign
l_int|NULL
suffix:semicolon
id|kfree
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tp
op_assign
id|tty-&gt;termios_locked
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|devpts
)paren
id|tty-&gt;driver-&gt;termios_locked
(braket
id|idx
)braket
op_assign
l_int|NULL
suffix:semicolon
id|kfree
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
id|tty-&gt;magic
op_assign
l_int|0
suffix:semicolon
id|tty-&gt;driver-&gt;refcount
op_decrement
suffix:semicolon
id|file_list_lock
c_func
(paren
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|tty-&gt;tty_files
)paren
suffix:semicolon
id|file_list_unlock
c_func
(paren
)paren
suffix:semicolon
id|module_put
c_func
(paren
id|tty-&gt;driver-&gt;owner
)paren
suffix:semicolon
id|free_tty_struct
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Even releasing the tty structures is a tricky business.. We have&n; * to be very careful that the structures are all released at the&n; * same time, as interrupts might otherwise get the wrong pointers.&n; *&n; * WSH 09/09/97: rewritten to avoid some nasty race conditions that could&n; * lead to double frees or releasing memory still in use.&n; */
DECL|function|release_dev
r_static
r_void
id|release_dev
c_func
(paren
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
comma
op_star
id|o_tty
suffix:semicolon
r_int
id|pty_master
comma
id|tty_closing
comma
id|o_tty_closing
comma
id|do_sleep
suffix:semicolon
r_int
id|devpts_master
comma
id|devpts
suffix:semicolon
r_int
id|idx
suffix:semicolon
r_char
id|buf
(braket
l_int|64
)braket
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|tty
op_assign
(paren
r_struct
id|tty_struct
op_star
)paren
id|filp-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|tty_paranoia_check
c_func
(paren
id|tty
comma
id|filp-&gt;f_dentry-&gt;d_inode
comma
l_string|&quot;release_dev&quot;
)paren
)paren
r_return
suffix:semicolon
id|check_tty_count
c_func
(paren
id|tty
comma
l_string|&quot;release_dev&quot;
)paren
suffix:semicolon
id|tty_fasync
c_func
(paren
op_minus
l_int|1
comma
id|filp
comma
l_int|0
)paren
suffix:semicolon
id|idx
op_assign
id|tty-&gt;index
suffix:semicolon
id|pty_master
op_assign
(paren
id|tty-&gt;driver-&gt;type
op_eq
id|TTY_DRIVER_TYPE_PTY
op_logical_and
id|tty-&gt;driver-&gt;subtype
op_eq
id|PTY_TYPE_MASTER
)paren
suffix:semicolon
id|devpts
op_assign
(paren
id|tty-&gt;driver-&gt;flags
op_amp
id|TTY_DRIVER_DEVPTS_MEM
)paren
op_ne
l_int|0
suffix:semicolon
id|devpts_master
op_assign
id|pty_master
op_logical_and
id|devpts
suffix:semicolon
id|o_tty
op_assign
id|tty-&gt;link
suffix:semicolon
macro_line|#ifdef TTY_PARANOIA_CHECK
r_if
c_cond
(paren
id|idx
OL
l_int|0
op_logical_or
id|idx
op_ge
id|tty-&gt;driver-&gt;num
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;release_dev: bad idx when trying to &quot;
l_string|&quot;free (%s)&bslash;n&quot;
comma
id|tty-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|tty-&gt;driver-&gt;flags
op_amp
id|TTY_DRIVER_DEVPTS_MEM
)paren
)paren
(brace
r_if
c_cond
(paren
id|tty
op_ne
id|tty-&gt;driver-&gt;ttys
(braket
id|idx
)braket
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;release_dev: driver.table[%d] not tty &quot;
l_string|&quot;for (%s)&bslash;n&quot;
comma
id|idx
comma
id|tty-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;termios
op_ne
id|tty-&gt;driver-&gt;termios
(braket
id|idx
)braket
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;release_dev: driver.termios[%d] not termios &quot;
l_string|&quot;for (%s)&bslash;n&quot;
comma
id|idx
comma
id|tty-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;termios_locked
op_ne
id|tty-&gt;driver-&gt;termios_locked
(braket
id|idx
)braket
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;release_dev: driver.termios_locked[%d] not &quot;
l_string|&quot;termios_locked for (%s)&bslash;n&quot;
comma
id|idx
comma
id|tty-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#ifdef TTY_DEBUG_HANGUP
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;release_dev of %s (tty count=%d)...&quot;
comma
id|tty_name
c_func
(paren
id|tty
comma
id|buf
)paren
comma
id|tty-&gt;count
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef TTY_PARANOIA_CHECK
r_if
c_cond
(paren
id|tty-&gt;driver-&gt;other
op_logical_and
op_logical_neg
(paren
id|tty-&gt;driver-&gt;flags
op_amp
id|TTY_DRIVER_DEVPTS_MEM
)paren
)paren
(brace
r_if
c_cond
(paren
id|o_tty
op_ne
id|tty-&gt;driver-&gt;other-&gt;ttys
(braket
id|idx
)braket
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;release_dev: other-&gt;table[%d] &quot;
l_string|&quot;not o_tty for (%s)&bslash;n&quot;
comma
id|idx
comma
id|tty-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|o_tty-&gt;termios
op_ne
id|tty-&gt;driver-&gt;other-&gt;termios
(braket
id|idx
)braket
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;release_dev: other-&gt;termios[%d] &quot;
l_string|&quot;not o_termios for (%s)&bslash;n&quot;
comma
id|idx
comma
id|tty-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|o_tty-&gt;termios_locked
op_ne
id|tty-&gt;driver-&gt;other-&gt;termios_locked
(braket
id|idx
)braket
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;release_dev: other-&gt;termios_locked[&quot;
l_string|&quot;%d] not o_termios_locked for (%s)&bslash;n&quot;
comma
id|idx
comma
id|tty-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|o_tty-&gt;link
op_ne
id|tty
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;release_dev: bad pty pointers&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
id|tty-&gt;driver-&gt;close
)paren
id|tty-&gt;driver
op_member_access_from_pointer
id|close
c_func
(paren
id|tty
comma
id|filp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Sanity check: if tty-&gt;count is going to zero, there shouldn&squot;t be&n;&t; * any waiters on tty-&gt;read_wait or tty-&gt;write_wait.  We test the&n;&t; * wait queues and kick everyone out _before_ actually starting to&n;&t; * close.  This ensures that we won&squot;t block while releasing the tty&n;&t; * structure.&n;&t; *&n;&t; * The test for the o_tty closing is necessary, since the master and&n;&t; * slave sides may close in any order.  If the slave side closes out&n;&t; * first, its count will be one, since the master side holds an open.&n;&t; * Thus this test wouldn&squot;t be triggered at the time the slave closes,&n;&t; * so we do it now.&n;&t; *&n;&t; * Note that it&squot;s possible for the tty to be opened again while we&squot;re&n;&t; * flushing out waiters.  By recalculating the closing flags before&n;&t; * each iteration we avoid any problems.&n;&t; */
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/* Guard against races with tty-&gt;count changes elsewhere and&n;&t;&t;   opens on /dev/tty */
id|down
c_func
(paren
op_amp
id|tty_sem
)paren
suffix:semicolon
id|tty_closing
op_assign
id|tty-&gt;count
op_le
l_int|1
suffix:semicolon
id|o_tty_closing
op_assign
id|o_tty
op_logical_and
(paren
id|o_tty-&gt;count
op_le
(paren
id|pty_master
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|tty_sem
)paren
suffix:semicolon
id|do_sleep
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tty_closing
)paren
(brace
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|tty-&gt;read_wait
)paren
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|tty-&gt;read_wait
)paren
suffix:semicolon
id|do_sleep
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
id|do_sleep
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|o_tty_closing
)paren
(brace
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|o_tty-&gt;read_wait
)paren
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|o_tty-&gt;read_wait
)paren
suffix:semicolon
id|do_sleep
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|o_tty-&gt;write_wait
)paren
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|o_tty-&gt;write_wait
)paren
suffix:semicolon
id|do_sleep
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|do_sleep
)paren
r_break
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;release_dev: %s: read/write wait queue &quot;
l_string|&quot;active!&bslash;n&quot;
comma
id|tty_name
c_func
(paren
id|tty
comma
id|buf
)paren
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The closing flags are now consistent with the open counts on &n;&t; * both sides, and we&squot;ve completed the last operation that could &n;&t; * block, so it&squot;s safe to proceed with closing.&n;&t; */
id|down
c_func
(paren
op_amp
id|tty_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pty_master
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|o_tty-&gt;count
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;release_dev: bad pty slave count &quot;
l_string|&quot;(%d) for %s&bslash;n&quot;
comma
id|o_tty-&gt;count
comma
id|tty_name
c_func
(paren
id|o_tty
comma
id|buf
)paren
)paren
suffix:semicolon
id|o_tty-&gt;count
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_decrement
id|tty-&gt;count
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;release_dev: bad tty-&gt;count (%d) for %s&bslash;n&quot;
comma
id|tty-&gt;count
comma
id|tty_name
c_func
(paren
id|tty
comma
id|buf
)paren
)paren
suffix:semicolon
id|tty-&gt;count
op_assign
l_int|0
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|tty_sem
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We&squot;ve decremented tty-&gt;count, so we need to remove this file&n;&t; * descriptor off the tty-&gt;tty_files list; this serves two&n;&t; * purposes:&n;&t; *  - check_tty_count sees the correct number of file descriptors&n;&t; *    associated with this tty.&n;&t; *  - do_tty_hangup no longer sees this file descriptor as&n;&t; *    something that needs to be handled for hangups.&n;&t; */
id|file_kill
c_func
(paren
id|filp
)paren
suffix:semicolon
id|filp-&gt;private_data
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Perform some housekeeping before deciding whether to return.&n;&t; *&n;&t; * Set the TTY_CLOSING flag if this was the last open.  In the&n;&t; * case of a pty we may have to wait around for the other side&n;&t; * to close, and TTY_CLOSING makes sure we can&squot;t be reopened.&n;&t; */
r_if
c_cond
(paren
id|tty_closing
)paren
(brace
id|set_bit
c_func
(paren
id|TTY_CLOSING
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|o_tty_closing
)paren
(brace
id|set_bit
c_func
(paren
id|TTY_CLOSING
comma
op_amp
id|o_tty-&gt;flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If _either_ side is closing, make sure there aren&squot;t any&n;&t; * processes that still think tty or o_tty is their controlling&n;&t; * tty.&n;&t; */
r_if
c_cond
(paren
id|tty_closing
op_logical_or
id|o_tty_closing
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|do_each_task_pid
c_func
(paren
id|tty-&gt;session
comma
id|PIDTYPE_SID
comma
id|p
)paren
(brace
id|p-&gt;signal-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
)brace
id|while_each_task_pid
c_func
(paren
id|tty-&gt;session
comma
id|PIDTYPE_SID
comma
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|o_tty
)paren
id|do_each_task_pid
c_func
(paren
id|o_tty-&gt;session
comma
id|PIDTYPE_SID
comma
id|p
)paren
(brace
id|p-&gt;signal-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
)brace
id|while_each_task_pid
c_func
(paren
id|o_tty-&gt;session
comma
id|PIDTYPE_SID
comma
id|p
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* check whether both sides are closing ... */
r_if
c_cond
(paren
op_logical_neg
id|tty_closing
op_logical_or
(paren
id|o_tty
op_logical_and
op_logical_neg
id|o_tty_closing
)paren
)paren
r_return
suffix:semicolon
macro_line|#ifdef TTY_DEBUG_HANGUP
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;freeing tty structure...&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Prevent flush_to_ldisc() from rescheduling the work for later.  Then&n;&t; * kill any delayed work. As this is the final close it does not&n;&t; * race with the set_ldisc code path.&n;&t; */
id|clear_bit
c_func
(paren
id|TTY_LDISC
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|TTY_DONT_FLIP
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
id|cancel_delayed_work
c_func
(paren
op_amp
id|tty-&gt;flip.work
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Wait for -&gt;hangup_work and -&gt;flip.work handlers to terminate&n;&t; */
id|flush_scheduled_work
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Wait for any short term users (we know they are just driver&n;&t; * side waiters as the file is closing so user count on the file&n;&t; * side is zero.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tty_ldisc_lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
id|tty-&gt;ldisc.refcount
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tty_ldisc_lock
comma
id|flags
)paren
suffix:semicolon
id|wait_event
c_func
(paren
id|tty_ldisc_wait
comma
id|tty-&gt;ldisc.refcount
op_eq
l_int|0
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tty_ldisc_lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tty_ldisc_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Shutdown the current line discipline, and reset it to N_TTY.&n;&t; * N.B. why reset ldisc when we&squot;re releasing the memory??&n;&t; *&n;&t; * FIXME: this MUST get fixed for the new reflocking&n;&t; */
r_if
c_cond
(paren
id|tty-&gt;ldisc.close
)paren
(paren
id|tty-&gt;ldisc.close
)paren
(paren
id|tty
)paren
suffix:semicolon
id|tty_ldisc_put
c_func
(paren
id|tty-&gt;ldisc.num
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Switch the line discipline back&n;&t; */
id|tty_ldisc_assign
c_func
(paren
id|tty
comma
id|tty_ldisc_get
c_func
(paren
id|N_TTY
)paren
)paren
suffix:semicolon
id|tty_set_termios_ldisc
c_func
(paren
id|tty
comma
id|N_TTY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|o_tty
)paren
(brace
multiline_comment|/* FIXME: could o_tty be in setldisc here ? */
id|clear_bit
c_func
(paren
id|TTY_LDISC
comma
op_amp
id|o_tty-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|o_tty-&gt;ldisc.close
)paren
(paren
id|o_tty-&gt;ldisc.close
)paren
(paren
id|o_tty
)paren
suffix:semicolon
id|tty_ldisc_put
c_func
(paren
id|o_tty-&gt;ldisc.num
)paren
suffix:semicolon
id|tty_ldisc_assign
c_func
(paren
id|o_tty
comma
id|tty_ldisc_get
c_func
(paren
id|N_TTY
)paren
)paren
suffix:semicolon
id|tty_set_termios_ldisc
c_func
(paren
id|o_tty
comma
id|N_TTY
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The release_mem function takes care of the details of clearing&n;&t; * the slots and preserving the termios structure.&n;&t; */
id|release_mem
c_func
(paren
id|tty
comma
id|idx
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_UNIX98_PTYS
multiline_comment|/* Make this pty number available for reallocation */
r_if
c_cond
(paren
id|devpts
)paren
(brace
id|down
c_func
(paren
op_amp
id|allocated_ptys_lock
)paren
suffix:semicolon
id|idr_remove
c_func
(paren
op_amp
id|allocated_ptys
comma
id|idx
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|allocated_ptys_lock
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n; * tty_open and tty_release keep up the tty count that contains the&n; * number of opens done on a tty. We cannot use the inode-count, as&n; * different inodes might point to the same tty.&n; *&n; * Open-counting is needed for pty masters, as well as for keeping&n; * track of serial lines: DTR is dropped when the last close happens.&n; * (This is not done solely through tty-&gt;count, now.  - Ted 1/27/92)&n; *&n; * The termios state of a pty is reset on first open so that&n; * settings don&squot;t persist across reuse.&n; */
DECL|function|tty_open
r_static
r_int
id|tty_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_int
id|noctty
comma
id|retval
suffix:semicolon
r_struct
id|tty_driver
op_star
id|driver
suffix:semicolon
r_int
id|index
suffix:semicolon
id|dev_t
id|device
op_assign
id|inode-&gt;i_rdev
suffix:semicolon
r_int
r_int
id|saved_flags
op_assign
id|filp-&gt;f_flags
suffix:semicolon
id|nonseekable_open
c_func
(paren
id|inode
comma
id|filp
)paren
suffix:semicolon
id|retry_open
suffix:colon
id|noctty
op_assign
id|filp-&gt;f_flags
op_amp
id|O_NOCTTY
suffix:semicolon
id|index
op_assign
op_minus
l_int|1
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
id|down
c_func
(paren
op_amp
id|tty_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device
op_eq
id|MKDEV
c_func
(paren
id|TTYAUX_MAJOR
comma
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|current-&gt;signal-&gt;tty
)paren
(brace
id|up
c_func
(paren
op_amp
id|tty_sem
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|driver
op_assign
id|current-&gt;signal-&gt;tty-&gt;driver
suffix:semicolon
id|index
op_assign
id|current-&gt;signal-&gt;tty-&gt;index
suffix:semicolon
id|filp-&gt;f_flags
op_or_assign
id|O_NONBLOCK
suffix:semicolon
multiline_comment|/* Don&squot;t let /dev/tty block */
multiline_comment|/* noctty = 1; */
r_goto
id|got_driver
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_VT
r_if
c_cond
(paren
id|device
op_eq
id|MKDEV
c_func
(paren
id|TTY_MAJOR
comma
l_int|0
)paren
)paren
(brace
r_extern
r_int
id|fg_console
suffix:semicolon
r_extern
r_struct
id|tty_driver
op_star
id|console_driver
suffix:semicolon
id|driver
op_assign
id|console_driver
suffix:semicolon
id|index
op_assign
id|fg_console
suffix:semicolon
id|noctty
op_assign
l_int|1
suffix:semicolon
r_goto
id|got_driver
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|device
op_eq
id|MKDEV
c_func
(paren
id|TTYAUX_MAJOR
comma
l_int|1
)paren
)paren
(brace
id|driver
op_assign
id|console_device
c_func
(paren
op_amp
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver
)paren
(brace
multiline_comment|/* Don&squot;t let /dev/console block */
id|filp-&gt;f_flags
op_or_assign
id|O_NONBLOCK
suffix:semicolon
id|noctty
op_assign
l_int|1
suffix:semicolon
r_goto
id|got_driver
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|tty_sem
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|driver
op_assign
id|get_tty_driver
c_func
(paren
id|device
comma
op_amp
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|driver
)paren
(brace
id|up
c_func
(paren
op_amp
id|tty_sem
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|got_driver
suffix:colon
id|retval
op_assign
id|init_dev
c_func
(paren
id|driver
comma
id|index
comma
op_amp
id|tty
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|tty_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|filp-&gt;private_data
op_assign
id|tty
suffix:semicolon
id|file_move
c_func
(paren
id|filp
comma
op_amp
id|tty-&gt;tty_files
)paren
suffix:semicolon
id|check_tty_count
c_func
(paren
id|tty
comma
l_string|&quot;tty_open&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver-&gt;type
op_eq
id|TTY_DRIVER_TYPE_PTY
op_logical_and
id|tty-&gt;driver-&gt;subtype
op_eq
id|PTY_TYPE_MASTER
)paren
id|noctty
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef TTY_DEBUG_HANGUP
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;opening %s...&quot;
comma
id|tty-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;driver-&gt;open
)paren
id|retval
op_assign
id|tty-&gt;driver
op_member_access_from_pointer
id|open
c_func
(paren
id|tty
comma
id|filp
)paren
suffix:semicolon
r_else
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
id|filp-&gt;f_flags
op_assign
id|saved_flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
op_logical_and
id|test_bit
c_func
(paren
id|TTY_EXCLUSIVE
comma
op_amp
id|tty-&gt;flags
)paren
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
id|retval
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
macro_line|#ifdef TTY_DEBUG_HANGUP
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;error %d in opening %s...&quot;
comma
id|retval
comma
id|tty-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|release_dev
c_func
(paren
id|filp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
op_minus
id|ERESTARTSYS
)paren
r_return
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
id|retval
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Need to reset f_op in case a hangup happened.&n;&t;&t; */
r_if
c_cond
(paren
id|filp-&gt;f_op
op_eq
op_amp
id|hung_up_tty_fops
)paren
id|filp-&gt;f_op
op_assign
op_amp
id|tty_fops
suffix:semicolon
r_goto
id|retry_open
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|noctty
op_logical_and
id|current-&gt;signal-&gt;leader
op_logical_and
op_logical_neg
id|current-&gt;signal-&gt;tty
op_logical_and
id|tty-&gt;session
op_eq
l_int|0
)paren
(brace
id|task_lock
c_func
(paren
id|current
)paren
suffix:semicolon
id|current-&gt;signal-&gt;tty
op_assign
id|tty
suffix:semicolon
id|task_unlock
c_func
(paren
id|current
)paren
suffix:semicolon
id|current-&gt;signal-&gt;tty_old_pgrp
op_assign
l_int|0
suffix:semicolon
id|tty-&gt;session
op_assign
id|current-&gt;signal-&gt;session
suffix:semicolon
id|tty-&gt;pgrp
op_assign
id|process_group
c_func
(paren
id|current
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_UNIX98_PTYS
DECL|function|ptmx_open
r_static
r_int
id|ptmx_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_int
id|index
suffix:semicolon
r_int
id|idr_ret
suffix:semicolon
id|nonseekable_open
c_func
(paren
id|inode
comma
id|filp
)paren
suffix:semicolon
multiline_comment|/* find a device that is not in use. */
id|down
c_func
(paren
op_amp
id|allocated_ptys_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|idr_pre_get
c_func
(paren
op_amp
id|allocated_ptys
comma
id|GFP_KERNEL
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|allocated_ptys_lock
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|idr_ret
op_assign
id|idr_get_new
c_func
(paren
op_amp
id|allocated_ptys
comma
l_int|NULL
comma
op_amp
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|idr_ret
OL
l_int|0
)paren
(brace
id|up
c_func
(paren
op_amp
id|allocated_ptys_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|idr_ret
op_eq
op_minus
id|EAGAIN
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|index
op_ge
id|pty_limit
)paren
(brace
id|idr_remove
c_func
(paren
op_amp
id|allocated_ptys
comma
id|index
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|allocated_ptys_lock
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|allocated_ptys_lock
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|tty_sem
)paren
suffix:semicolon
id|retval
op_assign
id|init_dev
c_func
(paren
id|ptm_driver
comma
id|index
comma
op_amp
id|tty
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|tty_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|out
suffix:semicolon
id|set_bit
c_func
(paren
id|TTY_PTY_LOCK
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
multiline_comment|/* LOCK THE SLAVE */
id|filp-&gt;private_data
op_assign
id|tty
suffix:semicolon
id|file_move
c_func
(paren
id|filp
comma
op_amp
id|tty-&gt;tty_files
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|devpts_pty_new
c_func
(paren
id|tty-&gt;link
)paren
)paren
r_goto
id|out1
suffix:semicolon
id|check_tty_count
c_func
(paren
id|tty
comma
l_string|&quot;tty_open&quot;
)paren
suffix:semicolon
id|retval
op_assign
id|ptm_driver
op_member_access_from_pointer
id|open
c_func
(paren
id|tty
comma
id|filp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
r_return
l_int|0
suffix:semicolon
id|out1
suffix:colon
id|release_dev
c_func
(paren
id|filp
)paren
suffix:semicolon
id|out
suffix:colon
id|down
c_func
(paren
op_amp
id|allocated_ptys_lock
)paren
suffix:semicolon
id|idr_remove
c_func
(paren
op_amp
id|allocated_ptys
comma
id|index
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|allocated_ptys_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
macro_line|#endif
DECL|function|tty_release
r_static
r_int
id|tty_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|release_dev
c_func
(paren
id|filp
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* No kernel lock held - fine */
DECL|function|tty_poll
r_static
r_int
r_int
id|tty_poll
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_struct
id|tty_ldisc
op_star
id|ld
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|tty
op_assign
(paren
r_struct
id|tty_struct
op_star
)paren
id|filp-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|tty_paranoia_check
c_func
(paren
id|tty
comma
id|filp-&gt;f_dentry-&gt;d_inode
comma
l_string|&quot;tty_poll&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|ld
op_assign
id|tty_ldisc_ref_wait
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ld-&gt;poll
)paren
id|ret
op_assign
(paren
id|ld-&gt;poll
)paren
(paren
id|tty
comma
id|filp
comma
id|wait
)paren
suffix:semicolon
id|tty_ldisc_deref
c_func
(paren
id|ld
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|tty_fasync
r_static
r_int
id|tty_fasync
c_func
(paren
r_int
id|fd
comma
r_struct
id|file
op_star
id|filp
comma
r_int
id|on
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|tty
op_assign
(paren
r_struct
id|tty_struct
op_star
)paren
id|filp-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|tty_paranoia_check
c_func
(paren
id|tty
comma
id|filp-&gt;f_dentry-&gt;d_inode
comma
l_string|&quot;tty_fasync&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|retval
op_assign
id|fasync_helper
c_func
(paren
id|fd
comma
id|filp
comma
id|on
comma
op_amp
id|tty-&gt;fasync
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_le
l_int|0
)paren
r_return
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|on
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|waitqueue_active
c_func
(paren
op_amp
id|tty-&gt;read_wait
)paren
)paren
id|tty-&gt;minimum_to_wake
op_assign
l_int|1
suffix:semicolon
id|retval
op_assign
id|f_setown
c_func
(paren
id|filp
comma
(paren
op_minus
id|tty-&gt;pgrp
)paren
ques
c_cond
suffix:colon
id|current-&gt;pid
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;fasync
op_logical_and
op_logical_neg
id|waitqueue_active
c_func
(paren
op_amp
id|tty-&gt;read_wait
)paren
)paren
id|tty-&gt;minimum_to_wake
op_assign
id|N_TTY_BUF_SIZE
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|tiocsti
r_static
r_int
id|tiocsti
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_char
id|__user
op_star
id|p
)paren
(brace
r_char
id|ch
comma
id|mbz
op_assign
l_int|0
suffix:semicolon
r_struct
id|tty_ldisc
op_star
id|ld
suffix:semicolon
r_if
c_cond
(paren
(paren
id|current-&gt;signal-&gt;tty
op_ne
id|tty
)paren
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|ch
comma
id|p
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ld
op_assign
id|tty_ldisc_ref_wait
c_func
(paren
id|tty
)paren
suffix:semicolon
id|ld
op_member_access_from_pointer
id|receive_buf
c_func
(paren
id|tty
comma
op_amp
id|ch
comma
op_amp
id|mbz
comma
l_int|1
)paren
suffix:semicolon
id|tty_ldisc_deref
c_func
(paren
id|ld
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|tiocgwinsz
r_static
r_int
id|tiocgwinsz
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|winsize
id|__user
op_star
id|arg
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|tty-&gt;winsize
comma
r_sizeof
(paren
op_star
id|arg
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|tiocswinsz
r_static
r_int
id|tiocswinsz
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|tty_struct
op_star
id|real_tty
comma
r_struct
id|winsize
id|__user
op_star
id|arg
)paren
(brace
r_struct
id|winsize
id|tmp_ws
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tmp_ws
comma
id|arg
comma
r_sizeof
(paren
op_star
id|arg
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
op_amp
id|tmp_ws
comma
op_amp
id|tty-&gt;winsize
comma
r_sizeof
(paren
op_star
id|arg
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_VT
r_if
c_cond
(paren
id|tty-&gt;driver-&gt;type
op_eq
id|TTY_DRIVER_TYPE_CONSOLE
)paren
(brace
r_int
r_int
id|currcons
op_assign
id|tty-&gt;index
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|acquire_console_sem
c_func
(paren
)paren
suffix:semicolon
id|rc
op_assign
id|vc_resize
c_func
(paren
id|currcons
comma
id|tmp_ws.ws_col
comma
id|tmp_ws.ws_row
)paren
suffix:semicolon
id|release_console_sem
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|tty-&gt;pgrp
OG
l_int|0
)paren
id|kill_pg
c_func
(paren
id|tty-&gt;pgrp
comma
id|SIGWINCH
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|real_tty-&gt;pgrp
op_ne
id|tty-&gt;pgrp
)paren
op_logical_and
(paren
id|real_tty-&gt;pgrp
OG
l_int|0
)paren
)paren
id|kill_pg
c_func
(paren
id|real_tty-&gt;pgrp
comma
id|SIGWINCH
comma
l_int|1
)paren
suffix:semicolon
id|tty-&gt;winsize
op_assign
id|tmp_ws
suffix:semicolon
id|real_tty-&gt;winsize
op_assign
id|tmp_ws
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|tioccons
r_static
r_int
id|tioccons
c_func
(paren
r_struct
id|file
op_star
id|file
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_op-&gt;write
op_eq
id|redirected_tty_write
)paren
(brace
r_struct
id|file
op_star
id|f
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|redirect_lock
)paren
suffix:semicolon
id|f
op_assign
id|redirect
suffix:semicolon
id|redirect
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|redirect_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f
)paren
id|fput
c_func
(paren
id|f
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|redirect_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|redirect
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|redirect_lock
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|get_file
c_func
(paren
id|file
)paren
suffix:semicolon
id|redirect
op_assign
id|file
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|redirect_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fionbio
r_static
r_int
id|fionbio
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
id|__user
op_star
id|p
)paren
(brace
r_int
id|nonblock
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|nonblock
comma
id|p
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|nonblock
)paren
id|file-&gt;f_flags
op_or_assign
id|O_NONBLOCK
suffix:semicolon
r_else
id|file-&gt;f_flags
op_and_assign
op_complement
id|O_NONBLOCK
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|tiocsctty
r_static
r_int
id|tiocsctty
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|arg
)paren
(brace
id|task_t
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal-&gt;leader
op_logical_and
(paren
id|current-&gt;signal-&gt;session
op_eq
id|tty-&gt;session
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * The process must be a session leader and&n;&t; * not have a controlling tty already.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|current-&gt;signal-&gt;leader
op_logical_or
id|current-&gt;signal-&gt;tty
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;session
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * This tty is already the controlling&n;&t;&t; * tty for another session group!&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|arg
op_eq
l_int|1
)paren
op_logical_and
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Steal it away&n;&t;&t;&t; */
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|do_each_task_pid
c_func
(paren
id|tty-&gt;session
comma
id|PIDTYPE_SID
comma
id|p
)paren
(brace
id|p-&gt;signal-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
)brace
id|while_each_task_pid
c_func
(paren
id|tty-&gt;session
comma
id|PIDTYPE_SID
comma
id|p
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|task_lock
c_func
(paren
id|current
)paren
suffix:semicolon
id|current-&gt;signal-&gt;tty
op_assign
id|tty
suffix:semicolon
id|task_unlock
c_func
(paren
id|current
)paren
suffix:semicolon
id|current-&gt;signal-&gt;tty_old_pgrp
op_assign
l_int|0
suffix:semicolon
id|tty-&gt;session
op_assign
id|current-&gt;signal-&gt;session
suffix:semicolon
id|tty-&gt;pgrp
op_assign
id|process_group
c_func
(paren
id|current
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|tiocgpgrp
r_static
r_int
id|tiocgpgrp
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|tty_struct
op_star
id|real_tty
comma
id|pid_t
id|__user
op_star
id|p
)paren
(brace
multiline_comment|/*&n;&t; * (tty == real_tty) is a cheap way of&n;&t; * testing if the tty is NOT a master pty.&n;&t; */
r_if
c_cond
(paren
id|tty
op_eq
id|real_tty
op_logical_and
id|current-&gt;signal-&gt;tty
op_ne
id|real_tty
)paren
r_return
op_minus
id|ENOTTY
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|real_tty-&gt;pgrp
comma
id|p
)paren
suffix:semicolon
)brace
DECL|function|tiocspgrp
r_static
r_int
id|tiocspgrp
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|tty_struct
op_star
id|real_tty
comma
id|pid_t
id|__user
op_star
id|p
)paren
(brace
id|pid_t
id|pgrp
suffix:semicolon
r_int
id|retval
op_assign
id|tty_check_change
c_func
(paren
id|real_tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
op_minus
id|EIO
)paren
r_return
op_minus
id|ENOTTY
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|current-&gt;signal-&gt;tty
op_logical_or
(paren
id|current-&gt;signal-&gt;tty
op_ne
id|real_tty
)paren
op_logical_or
(paren
id|real_tty-&gt;session
op_ne
id|current-&gt;signal-&gt;session
)paren
)paren
r_return
op_minus
id|ENOTTY
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|pgrp
comma
id|p
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|pgrp
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|session_of_pgrp
c_func
(paren
id|pgrp
)paren
op_ne
id|current-&gt;signal-&gt;session
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|real_tty-&gt;pgrp
op_assign
id|pgrp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|tiocgsid
r_static
r_int
id|tiocgsid
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|tty_struct
op_star
id|real_tty
comma
id|pid_t
id|__user
op_star
id|p
)paren
(brace
multiline_comment|/*&n;&t; * (tty == real_tty) is a cheap way of&n;&t; * testing if the tty is NOT a master pty.&n;&t;*/
r_if
c_cond
(paren
id|tty
op_eq
id|real_tty
op_logical_and
id|current-&gt;signal-&gt;tty
op_ne
id|real_tty
)paren
r_return
op_minus
id|ENOTTY
suffix:semicolon
r_if
c_cond
(paren
id|real_tty-&gt;session
op_le
l_int|0
)paren
r_return
op_minus
id|ENOTTY
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|real_tty-&gt;session
comma
id|p
)paren
suffix:semicolon
)brace
DECL|function|tiocsetd
r_static
r_int
id|tiocsetd
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|__user
op_star
id|p
)paren
(brace
r_int
id|ldisc
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|ldisc
comma
id|p
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|tty_set_ldisc
c_func
(paren
id|tty
comma
id|ldisc
)paren
suffix:semicolon
)brace
DECL|function|send_break
r_static
r_int
id|send_break
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|duration
)paren
(brace
id|tty-&gt;driver
op_member_access_from_pointer
id|break_ctl
c_func
(paren
id|tty
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|duration
)paren
suffix:semicolon
)brace
id|tty-&gt;driver
op_member_access_from_pointer
id|break_ctl
c_func
(paren
id|tty
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|tty_tiocmget
id|tty_tiocmget
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
id|__user
op_star
id|p
)paren
(brace
r_int
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver-&gt;tiocmget
)paren
(brace
id|retval
op_assign
id|tty-&gt;driver
op_member_access_from_pointer
id|tiocmget
c_func
(paren
id|tty
comma
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ge
l_int|0
)paren
id|retval
op_assign
id|put_user
c_func
(paren
id|retval
comma
id|p
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
r_static
r_int
DECL|function|tty_tiocmset
id|tty_tiocmset
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
id|__user
op_star
id|p
)paren
(brace
r_int
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver-&gt;tiocmset
)paren
(brace
r_int
r_int
id|set
comma
id|clear
comma
id|val
suffix:semicolon
id|retval
op_assign
id|get_user
c_func
(paren
id|val
comma
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|set
op_assign
id|clear
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TIOCMBIS
suffix:colon
id|set
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCMBIC
suffix:colon
id|clear
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCMSET
suffix:colon
id|set
op_assign
id|val
suffix:semicolon
id|clear
op_assign
op_complement
id|val
suffix:semicolon
r_break
suffix:semicolon
)brace
id|set
op_and_assign
id|TIOCM_DTR
op_or
id|TIOCM_RTS
op_or
id|TIOCM_OUT1
op_or
id|TIOCM_OUT2
op_or
id|TIOCM_LOOP
suffix:semicolon
id|clear
op_and_assign
id|TIOCM_DTR
op_or
id|TIOCM_RTS
op_or
id|TIOCM_OUT1
op_or
id|TIOCM_OUT2
op_or
id|TIOCM_LOOP
suffix:semicolon
id|retval
op_assign
id|tty-&gt;driver
op_member_access_from_pointer
id|tiocmset
c_func
(paren
id|tty
comma
id|file
comma
id|set
comma
id|clear
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Split this up, as gcc can choke on it otherwise..&n; */
DECL|function|tty_ioctl
r_int
id|tty_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
comma
op_star
id|real_tty
suffix:semicolon
r_void
id|__user
op_star
id|p
op_assign
(paren
r_void
id|__user
op_star
)paren
id|arg
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_struct
id|tty_ldisc
op_star
id|ld
suffix:semicolon
id|tty
op_assign
(paren
r_struct
id|tty_struct
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|tty_paranoia_check
c_func
(paren
id|tty
comma
id|inode
comma
l_string|&quot;tty_ioctl&quot;
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|real_tty
op_assign
id|tty
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver-&gt;type
op_eq
id|TTY_DRIVER_TYPE_PTY
op_logical_and
id|tty-&gt;driver-&gt;subtype
op_eq
id|PTY_TYPE_MASTER
)paren
id|real_tty
op_assign
id|tty-&gt;link
suffix:semicolon
multiline_comment|/*&n;&t; * Break handling by driver&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;driver-&gt;break_ctl
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TIOCSBRK
suffix:colon
r_case
id|TIOCCBRK
suffix:colon
r_if
c_cond
(paren
id|tty-&gt;driver-&gt;ioctl
)paren
r_return
id|tty-&gt;driver
op_member_access_from_pointer
id|ioctl
c_func
(paren
id|tty
comma
id|file
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* These two ioctl&squot;s always return success; even if */
multiline_comment|/* the driver doesn&squot;t support them. */
r_case
id|TCSBRK
suffix:colon
r_case
id|TCSBRKP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;driver-&gt;ioctl
)paren
r_return
l_int|0
suffix:semicolon
id|retval
op_assign
id|tty-&gt;driver
op_member_access_from_pointer
id|ioctl
c_func
(paren
id|tty
comma
id|file
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
op_minus
id|ENOIOCTLCMD
)paren
id|retval
op_assign
l_int|0
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Factor out some common prep work&n;&t; */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TIOCSETD
suffix:colon
r_case
id|TIOCSBRK
suffix:colon
r_case
id|TIOCCBRK
suffix:colon
r_case
id|TCSBRK
suffix:colon
r_case
id|TCSBRKP
suffix:colon
id|retval
op_assign
id|tty_check_change
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_ne
id|TIOCCBRK
)paren
(brace
id|tty_wait_until_sent
c_func
(paren
id|tty
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TIOCSTI
suffix:colon
r_return
id|tiocsti
c_func
(paren
id|tty
comma
id|p
)paren
suffix:semicolon
r_case
id|TIOCGWINSZ
suffix:colon
r_return
id|tiocgwinsz
c_func
(paren
id|tty
comma
id|p
)paren
suffix:semicolon
r_case
id|TIOCSWINSZ
suffix:colon
r_return
id|tiocswinsz
c_func
(paren
id|tty
comma
id|real_tty
comma
id|p
)paren
suffix:semicolon
r_case
id|TIOCCONS
suffix:colon
r_return
id|real_tty
op_ne
id|tty
ques
c_cond
op_minus
id|EINVAL
suffix:colon
id|tioccons
c_func
(paren
id|file
)paren
suffix:semicolon
r_case
id|FIONBIO
suffix:colon
r_return
id|fionbio
c_func
(paren
id|file
comma
id|p
)paren
suffix:semicolon
r_case
id|TIOCEXCL
suffix:colon
id|set_bit
c_func
(paren
id|TTY_EXCLUSIVE
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCNXCL
suffix:colon
id|clear_bit
c_func
(paren
id|TTY_EXCLUSIVE
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCNOTTY
suffix:colon
r_if
c_cond
(paren
id|current-&gt;signal-&gt;tty
op_ne
id|tty
)paren
r_return
op_minus
id|ENOTTY
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal-&gt;leader
)paren
id|disassociate_ctty
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|task_lock
c_func
(paren
id|current
)paren
suffix:semicolon
id|current-&gt;signal-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
id|task_unlock
c_func
(paren
id|current
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCSCTTY
suffix:colon
r_return
id|tiocsctty
c_func
(paren
id|tty
comma
id|arg
)paren
suffix:semicolon
r_case
id|TIOCGPGRP
suffix:colon
r_return
id|tiocgpgrp
c_func
(paren
id|tty
comma
id|real_tty
comma
id|p
)paren
suffix:semicolon
r_case
id|TIOCSPGRP
suffix:colon
r_return
id|tiocspgrp
c_func
(paren
id|tty
comma
id|real_tty
comma
id|p
)paren
suffix:semicolon
r_case
id|TIOCGSID
suffix:colon
r_return
id|tiocgsid
c_func
(paren
id|tty
comma
id|real_tty
comma
id|p
)paren
suffix:semicolon
r_case
id|TIOCGETD
suffix:colon
multiline_comment|/* FIXME: check this is ok */
r_return
id|put_user
c_func
(paren
id|tty-&gt;ldisc.num
comma
(paren
r_int
id|__user
op_star
)paren
id|p
)paren
suffix:semicolon
r_case
id|TIOCSETD
suffix:colon
r_return
id|tiocsetd
c_func
(paren
id|tty
comma
id|p
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_VT
r_case
id|TIOCLINUX
suffix:colon
r_return
id|tioclinux
c_func
(paren
id|tty
comma
id|arg
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t; * Break handling&n;&t;&t; */
r_case
id|TIOCSBRK
suffix:colon
multiline_comment|/* Turn break on, unconditionally */
id|tty-&gt;driver
op_member_access_from_pointer
id|break_ctl
c_func
(paren
id|tty
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCCBRK
suffix:colon
multiline_comment|/* Turn break off, unconditionally */
id|tty-&gt;driver
op_member_access_from_pointer
id|break_ctl
c_func
(paren
id|tty
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TCSBRK
suffix:colon
multiline_comment|/* SVID version: non-zero arg --&gt; no break */
multiline_comment|/*&n;&t;&t;&t; * XXX is the above comment correct, or the&n;&t;&t;&t; * code below correct?  Is this ioctl used at&n;&t;&t;&t; * all by anyone?&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
id|send_break
c_func
(paren
id|tty
comma
id|HZ
op_div
l_int|4
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TCSBRKP
suffix:colon
multiline_comment|/* support for POSIX tcsendbreak() */
r_return
id|send_break
c_func
(paren
id|tty
comma
id|arg
ques
c_cond
id|arg
op_star
(paren
id|HZ
op_div
l_int|10
)paren
suffix:colon
id|HZ
op_div
l_int|4
)paren
suffix:semicolon
r_case
id|TIOCMGET
suffix:colon
r_return
id|tty_tiocmget
c_func
(paren
id|tty
comma
id|file
comma
id|p
)paren
suffix:semicolon
r_case
id|TIOCMSET
suffix:colon
r_case
id|TIOCMBIC
suffix:colon
r_case
id|TIOCMBIS
suffix:colon
r_return
id|tty_tiocmset
c_func
(paren
id|tty
comma
id|file
comma
id|cmd
comma
id|p
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;driver-&gt;ioctl
)paren
(brace
id|retval
op_assign
(paren
id|tty-&gt;driver-&gt;ioctl
)paren
(paren
id|tty
comma
id|file
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
op_minus
id|ENOIOCTLCMD
)paren
r_return
id|retval
suffix:semicolon
)brace
id|ld
op_assign
id|tty_ldisc_ref_wait
c_func
(paren
id|tty
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|ld-&gt;ioctl
)paren
(brace
id|retval
op_assign
id|ld
op_member_access_from_pointer
id|ioctl
c_func
(paren
id|tty
comma
id|file
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
op_minus
id|ENOIOCTLCMD
)paren
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
id|tty_ldisc_deref
c_func
(paren
id|ld
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * This implements the &quot;Secure Attention Key&quot; ---  the idea is to&n; * prevent trojan horses by killing all processes associated with this&n; * tty when the user hits the &quot;Secure Attention Key&quot;.  Required for&n; * super-paranoid applications --- see the Orange Book for more details.&n; * &n; * This code could be nicer; ideally it should send a HUP, wait a few&n; * seconds, then send a INT, and then a KILL signal.  But you then&n; * have to coordinate with the init process, since all processes associated&n; * with the current tty must be dead before the new getty is allowed&n; * to spawn.&n; *&n; * Now, if it would be correct ;-/ The current code has a nasty hole -&n; * it doesn&squot;t catch files in flight. We may send the descriptor to ourselves&n; * via AF_UNIX socket, close it and later fetch from socket. FIXME.&n; *&n; * Nasty bug: do_SAK is being called in interrupt context.  This can&n; * deadlock.  We punt it up to process context.  AKPM - 16Mar2001&n; */
DECL|function|__do_SAK
r_static
r_void
id|__do_SAK
c_func
(paren
r_void
op_star
id|arg
)paren
(brace
macro_line|#ifdef TTY_SOFT_SAK
id|tty_hangup
c_func
(paren
id|tty
)paren
suffix:semicolon
macro_line|#else
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|arg
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_int
id|session
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_struct
id|tty_ldisc
op_star
id|disc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
id|session
op_assign
id|tty-&gt;session
suffix:semicolon
multiline_comment|/* We don&squot;t want an ldisc switch during this */
id|disc
op_assign
id|tty_ldisc_ref
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|disc
op_logical_and
id|disc-&gt;flush_buffer
)paren
id|disc
op_member_access_from_pointer
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
id|tty_ldisc_deref
c_func
(paren
id|disc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver-&gt;flush_buffer
)paren
id|tty-&gt;driver
op_member_access_from_pointer
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|do_each_task_pid
c_func
(paren
id|session
comma
id|PIDTYPE_SID
comma
id|p
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;signal-&gt;tty
op_eq
id|tty
op_logical_or
id|session
OG
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;SAK: killed process %d&quot;
l_string|&quot; (%s): p-&gt;signal-&gt;session==tty-&gt;session&bslash;n&quot;
comma
id|p-&gt;pid
comma
id|p-&gt;comm
)paren
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGKILL
comma
id|p
comma
l_int|1
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|task_lock
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;files
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|p-&gt;files-&gt;file_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|p-&gt;files-&gt;max_fds
suffix:semicolon
id|i
op_increment
)paren
(brace
id|filp
op_assign
id|fcheck_files
c_func
(paren
id|p-&gt;files
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filp
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_op-&gt;read
op_eq
id|tty_read
op_logical_and
id|filp-&gt;private_data
op_eq
id|tty
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;SAK: killed process %d&quot;
l_string|&quot; (%s): fd#%d opened to the tty&bslash;n&quot;
comma
id|p-&gt;pid
comma
id|p-&gt;comm
comma
id|i
)paren
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGKILL
comma
id|p
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|p-&gt;files-&gt;file_lock
)paren
suffix:semicolon
)brace
id|task_unlock
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
id|while_each_task_pid
c_func
(paren
id|session
comma
id|PIDTYPE_SID
comma
id|p
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * The tq handling here is a little racy - tty-&gt;SAK_work may already be queued.&n; * Fortunately we don&squot;t need to worry, because if -&gt;SAK_work is already queued,&n; * the values which we write to it will be identical to the values which it&n; * already has. --akpm&n; */
DECL|function|do_SAK
r_void
id|do_SAK
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
id|PREPARE_WORK
c_func
(paren
op_amp
id|tty-&gt;SAK_work
comma
id|__do_SAK
comma
id|tty
)paren
suffix:semicolon
id|schedule_work
c_func
(paren
op_amp
id|tty-&gt;SAK_work
)paren
suffix:semicolon
)brace
DECL|variable|do_SAK
id|EXPORT_SYMBOL
c_func
(paren
id|do_SAK
)paren
suffix:semicolon
multiline_comment|/*&n; * This routine is called out of the software interrupt to flush data&n; * from the flip buffer to the line discipline. &n; */
DECL|function|flush_to_ldisc
r_static
r_void
id|flush_to_ldisc
c_func
(paren
r_void
op_star
id|private_
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
op_assign
(paren
r_struct
id|tty_struct
op_star
)paren
id|private_
suffix:semicolon
r_int
r_char
op_star
id|cp
suffix:semicolon
r_char
op_star
id|fp
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|tty_ldisc
op_star
id|disc
suffix:semicolon
id|disc
op_assign
id|tty_ldisc_ref
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|disc
op_eq
l_int|NULL
)paren
multiline_comment|/*  !TTY_LDISC */
r_return
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|TTY_DONT_FLIP
comma
op_amp
id|tty-&gt;flags
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Do it after the next timer tick:&n;&t;&t; */
id|schedule_delayed_work
c_func
(paren
op_amp
id|tty-&gt;flip.work
comma
l_int|1
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;flip.buf_num
)paren
(brace
id|cp
op_assign
id|tty-&gt;flip.char_buf
op_plus
id|TTY_FLIPBUF_SIZE
suffix:semicolon
id|fp
op_assign
id|tty-&gt;flip.flag_buf
op_plus
id|TTY_FLIPBUF_SIZE
suffix:semicolon
id|tty-&gt;flip.buf_num
op_assign
l_int|0
suffix:semicolon
id|tty-&gt;flip.char_buf_ptr
op_assign
id|tty-&gt;flip.char_buf
suffix:semicolon
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|tty-&gt;flip.flag_buf
suffix:semicolon
)brace
r_else
(brace
id|cp
op_assign
id|tty-&gt;flip.char_buf
suffix:semicolon
id|fp
op_assign
id|tty-&gt;flip.flag_buf
suffix:semicolon
id|tty-&gt;flip.buf_num
op_assign
l_int|1
suffix:semicolon
id|tty-&gt;flip.char_buf_ptr
op_assign
id|tty-&gt;flip.char_buf
op_plus
id|TTY_FLIPBUF_SIZE
suffix:semicolon
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|tty-&gt;flip.flag_buf
op_plus
id|TTY_FLIPBUF_SIZE
suffix:semicolon
)brace
id|count
op_assign
id|tty-&gt;flip.count
suffix:semicolon
id|tty-&gt;flip.count
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
id|disc
op_member_access_from_pointer
id|receive_buf
c_func
(paren
id|tty
comma
id|cp
comma
id|fp
comma
id|count
)paren
suffix:semicolon
id|out
suffix:colon
id|tty_ldisc_deref
c_func
(paren
id|disc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Routine which returns the baud rate of the tty&n; *&n; * Note that the baud_table needs to be kept in sync with the&n; * include/asm/termbits.h file.&n; */
DECL|variable|baud_table
r_static
r_int
id|baud_table
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|50
comma
l_int|75
comma
l_int|110
comma
l_int|134
comma
l_int|150
comma
l_int|200
comma
l_int|300
comma
l_int|600
comma
l_int|1200
comma
l_int|1800
comma
l_int|2400
comma
l_int|4800
comma
l_int|9600
comma
l_int|19200
comma
l_int|38400
comma
l_int|57600
comma
l_int|115200
comma
l_int|230400
comma
l_int|460800
comma
macro_line|#ifdef __sparc__
l_int|76800
comma
l_int|153600
comma
l_int|307200
comma
l_int|614400
comma
l_int|921600
macro_line|#else
l_int|500000
comma
l_int|576000
comma
l_int|921600
comma
l_int|1000000
comma
l_int|1152000
comma
l_int|1500000
comma
l_int|2000000
comma
l_int|2500000
comma
l_int|3000000
comma
l_int|3500000
comma
l_int|4000000
macro_line|#endif
)brace
suffix:semicolon
DECL|variable|n_baud_table
r_static
r_int
id|n_baud_table
op_assign
id|ARRAY_SIZE
c_func
(paren
id|baud_table
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;tty_termios_baud_rate&n; *&t;@termios: termios structure&n; *&n; *&t;Convert termios baud rate data into a speed. This should be called&n; *&t;with the termios lock held if this termios is a terminal termios&n; *&t;structure. May change the termios data.&n; */
DECL|function|tty_termios_baud_rate
r_int
id|tty_termios_baud_rate
c_func
(paren
r_struct
id|termios
op_star
id|termios
)paren
(brace
r_int
r_int
id|cbaud
suffix:semicolon
id|cbaud
op_assign
id|termios-&gt;c_cflag
op_amp
id|CBAUD
suffix:semicolon
r_if
c_cond
(paren
id|cbaud
op_amp
id|CBAUDEX
)paren
(brace
id|cbaud
op_and_assign
op_complement
id|CBAUDEX
suffix:semicolon
r_if
c_cond
(paren
id|cbaud
template_param
id|n_baud_table
)paren
id|termios-&gt;c_cflag
op_and_assign
op_complement
id|CBAUDEX
suffix:semicolon
r_else
id|cbaud
op_add_assign
l_int|15
suffix:semicolon
)brace
r_return
id|baud_table
(braket
id|cbaud
)braket
suffix:semicolon
)brace
DECL|variable|tty_termios_baud_rate
id|EXPORT_SYMBOL
c_func
(paren
id|tty_termios_baud_rate
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;tty_get_baud_rate&t;-&t;get tty bit rates&n; *&t;@tty: tty to query&n; *&n; *&t;Returns the baud rate as an integer for this terminal. The&n; *&t;termios lock must be held by the caller and the terminal bit&n; *&t;flags may be updated.&n; */
DECL|function|tty_get_baud_rate
r_int
id|tty_get_baud_rate
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_int
id|baud
op_assign
id|tty_termios_baud_rate
c_func
(paren
id|tty-&gt;termios
)paren
suffix:semicolon
r_if
c_cond
(paren
id|baud
op_eq
l_int|38400
op_logical_and
id|tty-&gt;alt_speed
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;warned
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Use of setserial/setrocket to &quot;
l_string|&quot;set SPD_* flags is deprecated&bslash;n&quot;
)paren
suffix:semicolon
id|tty-&gt;warned
op_assign
l_int|1
suffix:semicolon
)brace
id|baud
op_assign
id|tty-&gt;alt_speed
suffix:semicolon
)brace
r_return
id|baud
suffix:semicolon
)brace
DECL|variable|tty_get_baud_rate
id|EXPORT_SYMBOL
c_func
(paren
id|tty_get_baud_rate
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;tty_flip_buffer_push&t;-&t;terminal&n; *&t;@tty: tty to push&n; *&n; *&t;Queue a push of the terminal flip buffers to the line discipline. This&n; *&t;function must not be called from IRQ context if tty-&gt;low_latency is set.&n; *&n; *&t;In the event of the queue being busy for flipping the work will be&n; *&t;held off and retried later.&n; */
DECL|function|tty_flip_buffer_push
r_void
id|tty_flip_buffer_push
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;low_latency
)paren
id|flush_to_ldisc
c_func
(paren
(paren
r_void
op_star
)paren
id|tty
)paren
suffix:semicolon
r_else
id|schedule_delayed_work
c_func
(paren
op_amp
id|tty-&gt;flip.work
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|variable|tty_flip_buffer_push
id|EXPORT_SYMBOL
c_func
(paren
id|tty_flip_buffer_push
)paren
suffix:semicolon
multiline_comment|/*&n; * This subroutine initializes a tty structure.&n; */
DECL|function|initialize_tty_struct
r_static
r_void
id|initialize_tty_struct
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|memset
c_func
(paren
id|tty
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|tty_struct
)paren
)paren
suffix:semicolon
id|tty-&gt;magic
op_assign
id|TTY_MAGIC
suffix:semicolon
id|tty_ldisc_assign
c_func
(paren
id|tty
comma
id|tty_ldisc_get
c_func
(paren
id|N_TTY
)paren
)paren
suffix:semicolon
id|tty-&gt;pgrp
op_assign
op_minus
l_int|1
suffix:semicolon
id|tty-&gt;flip.char_buf_ptr
op_assign
id|tty-&gt;flip.char_buf
suffix:semicolon
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|tty-&gt;flip.flag_buf
suffix:semicolon
id|INIT_WORK
c_func
(paren
op_amp
id|tty-&gt;flip.work
comma
id|flush_to_ldisc
comma
id|tty
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|tty-&gt;flip.pty_sem
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|tty-&gt;termios_sem
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|tty-&gt;read_wait
)paren
suffix:semicolon
id|INIT_WORK
c_func
(paren
op_amp
id|tty-&gt;hangup_work
comma
id|do_tty_hangup
comma
id|tty
)paren
suffix:semicolon
id|sema_init
c_func
(paren
op_amp
id|tty-&gt;atomic_read
comma
l_int|1
)paren
suffix:semicolon
id|sema_init
c_func
(paren
op_amp
id|tty-&gt;atomic_write
comma
l_int|1
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|tty-&gt;read_lock
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|tty-&gt;tty_files
)paren
suffix:semicolon
id|INIT_WORK
c_func
(paren
op_amp
id|tty-&gt;SAK_work
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The default put_char routine if the driver did not define one.&n; */
DECL|function|tty_default_put_char
r_static
r_void
id|tty_default_put_char
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
r_char
id|ch
)paren
(brace
id|tty-&gt;driver
op_member_access_from_pointer
id|write
c_func
(paren
id|tty
comma
op_amp
id|ch
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|variable|tty_class
r_static
r_struct
id|class_simple
op_star
id|tty_class
suffix:semicolon
multiline_comment|/**&n; * tty_register_device - register a tty device&n; * @driver: the tty driver that describes the tty device&n; * @index: the index in the tty driver for this tty device&n; * @device: a struct device that is associated with this tty device.&n; *&t;This field is optional, if there is no known struct device for this&n; *&t;tty device it can be set to NULL safely.&n; *&n; * This call is required to be made to register an individual tty device if&n; * the tty driver&squot;s flags have the TTY_DRIVER_NO_DEVFS bit set.  If that&n; * bit is not set, this function should not be called.&n; */
DECL|function|tty_register_device
r_void
id|tty_register_device
c_func
(paren
r_struct
id|tty_driver
op_star
id|driver
comma
r_int
id|index
comma
r_struct
id|device
op_star
id|device
)paren
(brace
r_char
id|name
(braket
l_int|64
)braket
suffix:semicolon
id|dev_t
id|dev
op_assign
id|MKDEV
c_func
(paren
id|driver-&gt;major
comma
id|driver-&gt;minor_start
)paren
op_plus
id|index
suffix:semicolon
r_if
c_cond
(paren
id|index
op_ge
id|driver-&gt;num
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Attempt to register invalid tty line number &quot;
l_string|&quot; (%d).&bslash;n&quot;
comma
id|index
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|devfs_mk_cdev
c_func
(paren
id|dev
comma
id|S_IFCHR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
comma
l_string|&quot;%s%d&quot;
comma
id|driver-&gt;devfs_name
comma
id|index
op_plus
id|driver-&gt;name_base
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver-&gt;type
op_eq
id|TTY_DRIVER_TYPE_PTY
)paren
id|pty_line_name
c_func
(paren
id|driver
comma
id|index
comma
id|name
)paren
suffix:semicolon
r_else
id|tty_line_name
c_func
(paren
id|driver
comma
id|index
comma
id|name
)paren
suffix:semicolon
id|class_simple_device_add
c_func
(paren
id|tty_class
comma
id|dev
comma
id|device
comma
id|name
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * tty_unregister_device - unregister a tty device&n; * @driver: the tty driver that describes the tty device&n; * @index: the index in the tty driver for this tty device&n; *&n; * If a tty device is registered with a call to tty_register_device() then&n; * this function must be made when the tty device is gone.&n; */
DECL|function|tty_unregister_device
r_void
id|tty_unregister_device
c_func
(paren
r_struct
id|tty_driver
op_star
id|driver
comma
r_int
id|index
)paren
(brace
id|devfs_remove
c_func
(paren
l_string|&quot;%s%d&quot;
comma
id|driver-&gt;devfs_name
comma
id|index
op_plus
id|driver-&gt;name_base
)paren
suffix:semicolon
id|class_simple_device_remove
c_func
(paren
id|MKDEV
c_func
(paren
id|driver-&gt;major
comma
id|driver-&gt;minor_start
)paren
op_plus
id|index
)paren
suffix:semicolon
)brace
DECL|variable|tty_register_device
id|EXPORT_SYMBOL
c_func
(paren
id|tty_register_device
)paren
suffix:semicolon
DECL|variable|tty_unregister_device
id|EXPORT_SYMBOL
c_func
(paren
id|tty_unregister_device
)paren
suffix:semicolon
DECL|function|alloc_tty_driver
r_struct
id|tty_driver
op_star
id|alloc_tty_driver
c_func
(paren
r_int
id|lines
)paren
(brace
r_struct
id|tty_driver
op_star
id|driver
suffix:semicolon
id|driver
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|tty_driver
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver
)paren
(brace
id|memset
c_func
(paren
id|driver
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|tty_driver
)paren
)paren
suffix:semicolon
id|driver-&gt;magic
op_assign
id|TTY_DRIVER_MAGIC
suffix:semicolon
id|driver-&gt;num
op_assign
id|lines
suffix:semicolon
multiline_comment|/* later we&squot;ll move allocation of tables here */
)brace
r_return
id|driver
suffix:semicolon
)brace
DECL|function|put_tty_driver
r_void
id|put_tty_driver
c_func
(paren
r_struct
id|tty_driver
op_star
id|driver
)paren
(brace
id|kfree
c_func
(paren
id|driver
)paren
suffix:semicolon
)brace
DECL|function|tty_set_operations
r_void
id|tty_set_operations
c_func
(paren
r_struct
id|tty_driver
op_star
id|driver
comma
r_struct
id|tty_operations
op_star
id|op
)paren
(brace
id|driver-&gt;open
op_assign
id|op-&gt;open
suffix:semicolon
id|driver-&gt;close
op_assign
id|op-&gt;close
suffix:semicolon
id|driver-&gt;write
op_assign
id|op-&gt;write
suffix:semicolon
id|driver-&gt;put_char
op_assign
id|op-&gt;put_char
suffix:semicolon
id|driver-&gt;flush_chars
op_assign
id|op-&gt;flush_chars
suffix:semicolon
id|driver-&gt;write_room
op_assign
id|op-&gt;write_room
suffix:semicolon
id|driver-&gt;chars_in_buffer
op_assign
id|op-&gt;chars_in_buffer
suffix:semicolon
id|driver-&gt;ioctl
op_assign
id|op-&gt;ioctl
suffix:semicolon
id|driver-&gt;set_termios
op_assign
id|op-&gt;set_termios
suffix:semicolon
id|driver-&gt;throttle
op_assign
id|op-&gt;throttle
suffix:semicolon
id|driver-&gt;unthrottle
op_assign
id|op-&gt;unthrottle
suffix:semicolon
id|driver-&gt;stop
op_assign
id|op-&gt;stop
suffix:semicolon
id|driver-&gt;start
op_assign
id|op-&gt;start
suffix:semicolon
id|driver-&gt;hangup
op_assign
id|op-&gt;hangup
suffix:semicolon
id|driver-&gt;break_ctl
op_assign
id|op-&gt;break_ctl
suffix:semicolon
id|driver-&gt;flush_buffer
op_assign
id|op-&gt;flush_buffer
suffix:semicolon
id|driver-&gt;set_ldisc
op_assign
id|op-&gt;set_ldisc
suffix:semicolon
id|driver-&gt;wait_until_sent
op_assign
id|op-&gt;wait_until_sent
suffix:semicolon
id|driver-&gt;send_xchar
op_assign
id|op-&gt;send_xchar
suffix:semicolon
id|driver-&gt;read_proc
op_assign
id|op-&gt;read_proc
suffix:semicolon
id|driver-&gt;write_proc
op_assign
id|op-&gt;write_proc
suffix:semicolon
id|driver-&gt;tiocmget
op_assign
id|op-&gt;tiocmget
suffix:semicolon
id|driver-&gt;tiocmset
op_assign
id|op-&gt;tiocmset
suffix:semicolon
)brace
DECL|variable|alloc_tty_driver
id|EXPORT_SYMBOL
c_func
(paren
id|alloc_tty_driver
)paren
suffix:semicolon
DECL|variable|put_tty_driver
id|EXPORT_SYMBOL
c_func
(paren
id|put_tty_driver
)paren
suffix:semicolon
DECL|variable|tty_set_operations
id|EXPORT_SYMBOL
c_func
(paren
id|tty_set_operations
)paren
suffix:semicolon
multiline_comment|/*&n; * Called by a tty driver to register itself.&n; */
DECL|function|tty_register_driver
r_int
id|tty_register_driver
c_func
(paren
r_struct
id|tty_driver
op_star
id|driver
)paren
(brace
r_int
id|error
suffix:semicolon
r_int
id|i
suffix:semicolon
id|dev_t
id|dev
suffix:semicolon
r_void
op_star
op_star
id|p
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|driver-&gt;flags
op_amp
id|TTY_DRIVER_INSTALLED
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|driver-&gt;flags
op_amp
id|TTY_DRIVER_DEVPTS_MEM
)paren
)paren
(brace
id|p
op_assign
id|kmalloc
c_func
(paren
id|driver-&gt;num
op_star
l_int|3
op_star
r_sizeof
(paren
r_void
op_star
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|p
comma
l_int|0
comma
id|driver-&gt;num
op_star
l_int|3
op_star
r_sizeof
(paren
r_void
op_star
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|driver-&gt;major
)paren
(brace
id|error
op_assign
id|alloc_chrdev_region
c_func
(paren
op_amp
id|dev
comma
id|driver-&gt;minor_start
comma
id|driver-&gt;num
comma
(paren
r_char
op_star
)paren
id|driver-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|driver-&gt;major
op_assign
id|MAJOR
c_func
(paren
id|dev
)paren
suffix:semicolon
id|driver-&gt;minor_start
op_assign
id|MINOR
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|dev
op_assign
id|MKDEV
c_func
(paren
id|driver-&gt;major
comma
id|driver-&gt;minor_start
)paren
suffix:semicolon
id|error
op_assign
id|register_chrdev_region
c_func
(paren
id|dev
comma
id|driver-&gt;num
comma
(paren
r_char
op_star
)paren
id|driver-&gt;name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|p
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p
)paren
(brace
id|driver-&gt;ttys
op_assign
(paren
r_struct
id|tty_struct
op_star
op_star
)paren
id|p
suffix:semicolon
id|driver-&gt;termios
op_assign
(paren
r_struct
id|termios
op_star
op_star
)paren
(paren
id|p
op_plus
id|driver-&gt;num
)paren
suffix:semicolon
id|driver-&gt;termios_locked
op_assign
(paren
r_struct
id|termios
op_star
op_star
)paren
(paren
id|p
op_plus
id|driver-&gt;num
op_star
l_int|2
)paren
suffix:semicolon
)brace
r_else
(brace
id|driver-&gt;ttys
op_assign
l_int|NULL
suffix:semicolon
id|driver-&gt;termios
op_assign
l_int|NULL
suffix:semicolon
id|driver-&gt;termios_locked
op_assign
l_int|NULL
suffix:semicolon
)brace
id|cdev_init
c_func
(paren
op_amp
id|driver-&gt;cdev
comma
op_amp
id|tty_fops
)paren
suffix:semicolon
id|driver-&gt;cdev.owner
op_assign
id|driver-&gt;owner
suffix:semicolon
id|error
op_assign
id|cdev_add
c_func
(paren
op_amp
id|driver-&gt;cdev
comma
id|dev
comma
id|driver-&gt;num
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|cdev_del
c_func
(paren
op_amp
id|driver-&gt;cdev
)paren
suffix:semicolon
id|unregister_chrdev_region
c_func
(paren
id|dev
comma
id|driver-&gt;num
)paren
suffix:semicolon
id|driver-&gt;ttys
op_assign
l_int|NULL
suffix:semicolon
id|driver-&gt;termios
op_assign
id|driver-&gt;termios_locked
op_assign
l_int|NULL
suffix:semicolon
id|kfree
c_func
(paren
id|p
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|driver-&gt;put_char
)paren
id|driver-&gt;put_char
op_assign
id|tty_default_put_char
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|driver-&gt;tty_drivers
comma
op_amp
id|tty_drivers
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|driver-&gt;flags
op_amp
id|TTY_DRIVER_NO_DEVFS
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|driver-&gt;num
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tty_register_device
c_func
(paren
id|driver
comma
id|i
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
id|proc_tty_register_driver
c_func
(paren
id|driver
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|tty_register_driver
id|EXPORT_SYMBOL
c_func
(paren
id|tty_register_driver
)paren
suffix:semicolon
multiline_comment|/*&n; * Called by a tty driver to unregister itself.&n; */
DECL|function|tty_unregister_driver
r_int
id|tty_unregister_driver
c_func
(paren
r_struct
id|tty_driver
op_star
id|driver
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|termios
op_star
id|tp
suffix:semicolon
r_void
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|driver-&gt;refcount
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|unregister_chrdev_region
c_func
(paren
id|MKDEV
c_func
(paren
id|driver-&gt;major
comma
id|driver-&gt;minor_start
)paren
comma
id|driver-&gt;num
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|driver-&gt;tty_drivers
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Free the termios and termios_locked structures because&n;&t; * we don&squot;t want to get memory leaks when modular tty&n;&t; * drivers are removed from the kernel.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|driver-&gt;num
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tp
op_assign
id|driver-&gt;termios
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|tp
)paren
(brace
id|driver-&gt;termios
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|kfree
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
id|tp
op_assign
id|driver-&gt;termios_locked
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|tp
)paren
(brace
id|driver-&gt;termios_locked
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|kfree
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|driver-&gt;flags
op_amp
id|TTY_DRIVER_NO_DEVFS
)paren
)paren
id|tty_unregister_device
c_func
(paren
id|driver
comma
id|i
)paren
suffix:semicolon
)brace
id|p
op_assign
id|driver-&gt;ttys
suffix:semicolon
id|proc_tty_unregister_driver
c_func
(paren
id|driver
)paren
suffix:semicolon
id|driver-&gt;ttys
op_assign
l_int|NULL
suffix:semicolon
id|driver-&gt;termios
op_assign
id|driver-&gt;termios_locked
op_assign
l_int|NULL
suffix:semicolon
id|kfree
c_func
(paren
id|p
)paren
suffix:semicolon
id|cdev_del
c_func
(paren
op_amp
id|driver-&gt;cdev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|tty_unregister_driver
id|EXPORT_SYMBOL
c_func
(paren
id|tty_unregister_driver
)paren
suffix:semicolon
multiline_comment|/*&n; * Initialize the console device. This is called *early*, so&n; * we can&squot;t necessarily depend on lots of kernel help here.&n; * Just do some early initializations, and do the complex setup&n; * later.&n; */
DECL|function|console_init
r_void
id|__init
id|console_init
c_func
(paren
r_void
)paren
(brace
id|initcall_t
op_star
id|call
suffix:semicolon
multiline_comment|/* Setup the default TTY line discipline. */
(paren
r_void
)paren
id|tty_register_ldisc
c_func
(paren
id|N_TTY
comma
op_amp
id|tty_ldisc_N_TTY
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set up the console device so that later boot sequences can &n;&t; * inform about problems etc..&n;&t; */
macro_line|#ifdef CONFIG_EARLY_PRINTK
id|disable_early_printk
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_SERIAL_68360
multiline_comment|/* This is not a console initcall. I know not what it&squot;s doing here.&n;&t;   So I haven&squot;t moved it. dwmw2 */
id|rs_360_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|call
op_assign
id|__con_initcall_start
suffix:semicolon
r_while
c_loop
(paren
id|call
OL
id|__con_initcall_end
)paren
(brace
(paren
op_star
id|call
)paren
(paren
)paren
suffix:semicolon
id|call
op_increment
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_VT
r_extern
r_int
id|vty_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
DECL|function|tty_class_init
r_static
r_int
id|__init
id|tty_class_init
c_func
(paren
r_void
)paren
(brace
id|tty_class
op_assign
id|class_simple_create
c_func
(paren
id|THIS_MODULE
comma
l_string|&quot;tty&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|tty_class
)paren
)paren
r_return
id|PTR_ERR
c_func
(paren
id|tty_class
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|tty_class_init
id|postcore_initcall
c_func
(paren
id|tty_class_init
)paren
suffix:semicolon
multiline_comment|/* 3/2004 jmc: why do these devices exist? */
DECL|variable|tty_cdev
DECL|variable|console_cdev
r_static
r_struct
id|cdev
id|tty_cdev
comma
id|console_cdev
suffix:semicolon
macro_line|#ifdef CONFIG_UNIX98_PTYS
DECL|variable|ptmx_cdev
r_static
r_struct
id|cdev
id|ptmx_cdev
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_VT
DECL|variable|vc0_cdev
r_static
r_struct
id|cdev
id|vc0_cdev
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Ok, now we can initialize the rest of the tty devices and can count&n; * on memory allocations, interrupts etc..&n; */
DECL|function|tty_init
r_static
r_int
id|__init
id|tty_init
c_func
(paren
r_void
)paren
(brace
id|cdev_init
c_func
(paren
op_amp
id|tty_cdev
comma
op_amp
id|tty_fops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cdev_add
c_func
(paren
op_amp
id|tty_cdev
comma
id|MKDEV
c_func
(paren
id|TTYAUX_MAJOR
comma
l_int|0
)paren
comma
l_int|1
)paren
op_logical_or
id|register_chrdev_region
c_func
(paren
id|MKDEV
c_func
(paren
id|TTYAUX_MAJOR
comma
l_int|0
)paren
comma
l_int|1
comma
l_string|&quot;/dev/tty&quot;
)paren
OL
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;Couldn&squot;t register /dev/tty driver&bslash;n&quot;
)paren
suffix:semicolon
id|devfs_mk_cdev
c_func
(paren
id|MKDEV
c_func
(paren
id|TTYAUX_MAJOR
comma
l_int|0
)paren
comma
id|S_IFCHR
op_or
id|S_IRUGO
op_or
id|S_IWUGO
comma
l_string|&quot;tty&quot;
)paren
suffix:semicolon
id|class_simple_device_add
c_func
(paren
id|tty_class
comma
id|MKDEV
c_func
(paren
id|TTYAUX_MAJOR
comma
l_int|0
)paren
comma
l_int|NULL
comma
l_string|&quot;tty&quot;
)paren
suffix:semicolon
id|cdev_init
c_func
(paren
op_amp
id|console_cdev
comma
op_amp
id|console_fops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cdev_add
c_func
(paren
op_amp
id|console_cdev
comma
id|MKDEV
c_func
(paren
id|TTYAUX_MAJOR
comma
l_int|1
)paren
comma
l_int|1
)paren
op_logical_or
id|register_chrdev_region
c_func
(paren
id|MKDEV
c_func
(paren
id|TTYAUX_MAJOR
comma
l_int|1
)paren
comma
l_int|1
comma
l_string|&quot;/dev/console&quot;
)paren
OL
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;Couldn&squot;t register /dev/console driver&bslash;n&quot;
)paren
suffix:semicolon
id|devfs_mk_cdev
c_func
(paren
id|MKDEV
c_func
(paren
id|TTYAUX_MAJOR
comma
l_int|1
)paren
comma
id|S_IFCHR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
comma
l_string|&quot;console&quot;
)paren
suffix:semicolon
id|class_simple_device_add
c_func
(paren
id|tty_class
comma
id|MKDEV
c_func
(paren
id|TTYAUX_MAJOR
comma
l_int|1
)paren
comma
l_int|NULL
comma
l_string|&quot;console&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_UNIX98_PTYS
id|cdev_init
c_func
(paren
op_amp
id|ptmx_cdev
comma
op_amp
id|ptmx_fops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cdev_add
c_func
(paren
op_amp
id|ptmx_cdev
comma
id|MKDEV
c_func
(paren
id|TTYAUX_MAJOR
comma
l_int|2
)paren
comma
l_int|1
)paren
op_logical_or
id|register_chrdev_region
c_func
(paren
id|MKDEV
c_func
(paren
id|TTYAUX_MAJOR
comma
l_int|2
)paren
comma
l_int|1
comma
l_string|&quot;/dev/ptmx&quot;
)paren
OL
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;Couldn&squot;t register /dev/ptmx driver&bslash;n&quot;
)paren
suffix:semicolon
id|devfs_mk_cdev
c_func
(paren
id|MKDEV
c_func
(paren
id|TTYAUX_MAJOR
comma
l_int|2
)paren
comma
id|S_IFCHR
op_or
id|S_IRUGO
op_or
id|S_IWUGO
comma
l_string|&quot;ptmx&quot;
)paren
suffix:semicolon
id|class_simple_device_add
c_func
(paren
id|tty_class
comma
id|MKDEV
c_func
(paren
id|TTYAUX_MAJOR
comma
l_int|2
)paren
comma
l_int|NULL
comma
l_string|&quot;ptmx&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_VT
id|cdev_init
c_func
(paren
op_amp
id|vc0_cdev
comma
op_amp
id|console_fops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cdev_add
c_func
(paren
op_amp
id|vc0_cdev
comma
id|MKDEV
c_func
(paren
id|TTY_MAJOR
comma
l_int|0
)paren
comma
l_int|1
)paren
op_logical_or
id|register_chrdev_region
c_func
(paren
id|MKDEV
c_func
(paren
id|TTY_MAJOR
comma
l_int|0
)paren
comma
l_int|1
comma
l_string|&quot;/dev/vc/0&quot;
)paren
OL
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;Couldn&squot;t register /dev/tty0 driver&bslash;n&quot;
)paren
suffix:semicolon
id|devfs_mk_cdev
c_func
(paren
id|MKDEV
c_func
(paren
id|TTY_MAJOR
comma
l_int|0
)paren
comma
id|S_IFCHR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
comma
l_string|&quot;vc/0&quot;
)paren
suffix:semicolon
id|class_simple_device_add
c_func
(paren
id|tty_class
comma
id|MKDEV
c_func
(paren
id|TTY_MAJOR
comma
l_int|0
)paren
comma
l_int|NULL
comma
l_string|&quot;tty0&quot;
)paren
suffix:semicolon
id|vty_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|tty_init
id|module_init
c_func
(paren
id|tty_init
)paren
suffix:semicolon
eof
