multiline_comment|/*&n; * C-Brick Serial Port (and console) driver for SGI Altix machines.&n; *&n; * This driver is NOT suitable for talking to the l1-controller for&n; * anything other than &squot;console activities&squot; --- please use the l1&n; * driver for that.&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (C) 2003 Silicon Graphics, Inc. All rights reserved.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/serial.h&gt;
macro_line|#include &lt;linux/console.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sysrq.h&gt;
macro_line|#include &lt;linux/circ_buf.h&gt;
macro_line|#include &lt;linux/serial_reg.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/sn/sn_sal.h&gt;
macro_line|#include &lt;asm/sn/pci/pciio.h&gt;
macro_line|#include &lt;asm/sn/simulator.h&gt;
macro_line|#include &lt;asm/sn/sn2/sn_private.h&gt;
macro_line|#if defined(CONFIG_SGI_L1_SERIAL_CONSOLE) &amp;&amp; defined(CONFIG_MAGIC_SYSRQ)
DECL|variable|sysrq_serial_str
r_static
r_char
id|sysrq_serial_str
(braket
)braket
op_assign
l_string|&quot;&bslash;eSYS&quot;
suffix:semicolon
DECL|variable|sysrq_serial_ptr
r_static
r_char
op_star
id|sysrq_serial_ptr
op_assign
id|sysrq_serial_str
suffix:semicolon
DECL|variable|sysrq_requested
r_static
r_int
r_int
id|sysrq_requested
suffix:semicolon
macro_line|#endif /* CONFIG_SGI_L1_SERIAL_CONSOLE &amp;&amp; CONFIG_MAGIC_SYSRQ */
multiline_comment|/* minor device number */
DECL|macro|SN_SAL_MINOR
mdefine_line|#define SN_SAL_MINOR 64
multiline_comment|/* number of characters left in xmit buffer before we ask for more */
DECL|macro|WAKEUP_CHARS
mdefine_line|#define WAKEUP_CHARS 128
multiline_comment|/* number of characters we can transmit to the SAL console at a time */
DECL|macro|SN_SAL_MAX_CHARS
mdefine_line|#define SN_SAL_MAX_CHARS 120
DECL|macro|SN_SAL_EVENT_WRITE_WAKEUP
mdefine_line|#define SN_SAL_EVENT_WRITE_WAKEUP 0
multiline_comment|/* 64K, when we&squot;re asynch, it must be at least printk&squot;s LOG_BUF_LEN to&n; * avoid losing chars, (always has to be a power of 2) */
DECL|macro|SN_SAL_BUFFER_SIZE
mdefine_line|#define SN_SAL_BUFFER_SIZE (64 * (1 &lt;&lt; 10))
DECL|macro|SN_SAL_UART_FIFO_DEPTH
mdefine_line|#define SN_SAL_UART_FIFO_DEPTH 16
DECL|macro|SN_SAL_UART_FIFO_SPEED_CPS
mdefine_line|#define SN_SAL_UART_FIFO_SPEED_CPS 9600/10
multiline_comment|/* we don&squot;t kmalloc/get_free_page these as we want them available&n; * before either of those are initialized */
DECL|variable|sn_xmit_buff_mem
r_static
r_char
id|sn_xmit_buff_mem
(braket
id|SN_SAL_BUFFER_SIZE
)braket
suffix:semicolon
DECL|struct|volatile_circ_buf
r_struct
id|volatile_circ_buf
(brace
DECL|member|cb_buf
r_char
op_star
id|cb_buf
suffix:semicolon
DECL|member|cb_head
r_int
id|cb_head
suffix:semicolon
DECL|member|cb_tail
r_int
id|cb_tail
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|xmit
r_static
r_struct
id|volatile_circ_buf
id|xmit
op_assign
(brace
dot
id|cb_buf
op_assign
id|sn_xmit_buff_mem
)brace
suffix:semicolon
DECL|variable|sn_tmp_buffer
r_static
r_char
id|sn_tmp_buffer
(braket
id|SN_SAL_BUFFER_SIZE
)braket
suffix:semicolon
DECL|variable|sn_sal_tty
r_static
r_struct
id|tty_struct
op_star
id|sn_sal_tty
suffix:semicolon
DECL|variable|sn_sal_timer
r_static
r_struct
id|timer_list
id|sn_sal_timer
suffix:semicolon
DECL|variable|sn_sal_event
r_static
r_int
id|sn_sal_event
suffix:semicolon
multiline_comment|/* event type for task queue */
DECL|variable|sn_sal_is_asynch
r_static
r_int
id|sn_sal_is_asynch
suffix:semicolon
DECL|variable|sn_sal_irq
r_static
r_int
id|sn_sal_irq
suffix:semicolon
DECL|variable|sn_sal_lock
r_static
id|spinlock_t
id|sn_sal_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|sn_total_tx_count
r_static
r_int
id|sn_total_tx_count
suffix:semicolon
DECL|variable|sn_total_rx_count
r_static
r_int
id|sn_total_rx_count
suffix:semicolon
r_static
r_void
id|sn_sal_tasklet_action
c_func
(paren
r_int
r_int
id|data
)paren
suffix:semicolon
r_static
id|DECLARE_TASKLET
c_func
(paren
id|sn_sal_tasklet
comma
id|sn_sal_tasklet_action
comma
l_int|0
)paren
suffix:semicolon
DECL|variable|sn_interrupt_timeout
r_static
r_int
r_int
id|sn_interrupt_timeout
suffix:semicolon
r_extern
id|u64
id|master_node_bedrock_address
suffix:semicolon
r_static
r_int
id|sn_debug_printf
c_func
(paren
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
suffix:semicolon
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#ifdef DEBUG
DECL|macro|DPRINTF
mdefine_line|#define DPRINTF(x...) sn_debug_printf(x)
macro_line|#else
DECL|macro|DPRINTF
mdefine_line|#define DPRINTF(x...) do { } while (0)
macro_line|#endif
DECL|struct|sn_sal_ops
r_struct
id|sn_sal_ops
(brace
DECL|member|sal_puts
r_int
(paren
op_star
id|sal_puts
)paren
(paren
r_const
r_char
op_star
id|s
comma
r_int
id|len
)paren
suffix:semicolon
DECL|member|sal_getc
r_int
(paren
op_star
id|sal_getc
)paren
(paren
r_void
)paren
suffix:semicolon
DECL|member|sal_input_pending
r_int
(paren
op_star
id|sal_input_pending
)paren
(paren
r_void
)paren
suffix:semicolon
DECL|member|sal_wakeup_transmit
r_void
(paren
op_star
id|sal_wakeup_transmit
)paren
(paren
r_void
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* This is the pointer used. It is assigned to point to one of&n; * the tables below.&n; */
DECL|variable|sn_func
r_static
r_struct
id|sn_sal_ops
op_star
id|sn_func
suffix:semicolon
multiline_comment|/* Prototypes */
r_static
r_void
id|__init
id|sn_sal_serial_console_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|snt_hw_puts
c_func
(paren
r_const
r_char
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|snt_poll_getc
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|snt_poll_input_pending
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|snt_sim_puts
c_func
(paren
r_const
r_char
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|snt_sim_getc
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|snt_sim_input_pending
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|snt_intr_getc
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|snt_intr_input_pending
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|sn_intr_transmit_chars
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* A table for polling */
DECL|variable|poll_ops
r_static
r_struct
id|sn_sal_ops
id|poll_ops
op_assign
(brace
dot
id|sal_puts
op_assign
id|snt_hw_puts
comma
dot
id|sal_getc
op_assign
id|snt_poll_getc
comma
dot
id|sal_input_pending
op_assign
id|snt_poll_input_pending
)brace
suffix:semicolon
multiline_comment|/* A table for the simulator */
DECL|variable|sim_ops
r_static
r_struct
id|sn_sal_ops
id|sim_ops
op_assign
(brace
dot
id|sal_puts
op_assign
id|snt_sim_puts
comma
dot
id|sal_getc
op_assign
id|snt_sim_getc
comma
dot
id|sal_input_pending
op_assign
id|snt_sim_input_pending
)brace
suffix:semicolon
multiline_comment|/* A table for interrupts enabled */
DECL|variable|intr_ops
r_static
r_struct
id|sn_sal_ops
id|intr_ops
op_assign
(brace
dot
id|sal_puts
op_assign
id|snt_hw_puts
comma
dot
id|sal_getc
op_assign
id|snt_intr_getc
comma
dot
id|sal_input_pending
op_assign
id|snt_intr_input_pending
comma
dot
id|sal_wakeup_transmit
op_assign
id|sn_intr_transmit_chars
)brace
suffix:semicolon
multiline_comment|/* the console does output in two distinctly different ways:&n; * synchronous and asynchronous (buffered).  initally, early_printk&n; * does synchronous output.  any data written goes directly to the SAL&n; * to be output (incidentally, it is internally buffered by the SAL)&n; * after interrupts and timers are initialized and available for use,&n; * the console init code switches to asynchronous output.  this is&n; * also the earliest opportunity to begin polling for console input.&n; * after console initialization, console output and tty (serial port)&n; * output is buffered and sent to the SAL asynchronously (either by&n; * timer callback or by UART interrupt) */
multiline_comment|/* routines for running the console in polling mode */
r_static
r_int
DECL|function|snt_hw_puts
id|snt_hw_puts
c_func
(paren
r_const
r_char
op_star
id|s
comma
r_int
id|len
)paren
(brace
multiline_comment|/* looking at the PROM source code, putb calls the flush&n;&t; * routine, so if we send characters in FIFO sized chunks, it&n;&t; * should go out by the next time the timer gets called */
r_return
id|ia64_sn_console_putb
c_func
(paren
id|s
comma
id|len
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|snt_poll_getc
id|snt_poll_getc
c_func
(paren
r_void
)paren
(brace
r_int
id|ch
suffix:semicolon
id|ia64_sn_console_getc
c_func
(paren
op_amp
id|ch
)paren
suffix:semicolon
r_return
id|ch
suffix:semicolon
)brace
r_static
r_int
DECL|function|snt_poll_input_pending
id|snt_poll_input_pending
c_func
(paren
r_void
)paren
(brace
r_int
id|status
comma
id|input
suffix:semicolon
id|status
op_assign
id|ia64_sn_console_check
c_func
(paren
op_amp
id|input
)paren
suffix:semicolon
r_return
op_logical_neg
id|status
op_logical_and
id|input
suffix:semicolon
)brace
multiline_comment|/* routines for running the console on the simulator */
r_static
r_int
DECL|function|snt_sim_puts
id|snt_sim_puts
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_int
id|count
)paren
(brace
r_int
id|counter
op_assign
id|count
suffix:semicolon
macro_line|#ifdef FLAG_DIRECT_CONSOLE_WRITES
multiline_comment|/* This is an easy way to pre-pend the output to know whether the output&n;&t; * was done via sal or directly */
id|writeb
c_func
(paren
l_char|&squot;[&squot;
comma
id|master_node_bedrock_address
op_plus
(paren
id|UART_TX
op_lshift
l_int|3
)paren
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_char|&squot;+&squot;
comma
id|master_node_bedrock_address
op_plus
(paren
id|UART_TX
op_lshift
l_int|3
)paren
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_char|&squot;]&squot;
comma
id|master_node_bedrock_address
op_plus
(paren
id|UART_TX
op_lshift
l_int|3
)paren
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_char|&squot; &squot;
comma
id|master_node_bedrock_address
op_plus
(paren
id|UART_TX
op_lshift
l_int|3
)paren
)paren
suffix:semicolon
macro_line|#endif /* FLAG_DIRECT_CONSOLE_WRITES */
r_while
c_loop
(paren
id|counter
OG
l_int|0
)paren
(brace
id|writeb
c_func
(paren
op_star
id|str
comma
id|master_node_bedrock_address
op_plus
(paren
id|UART_TX
op_lshift
l_int|3
)paren
)paren
suffix:semicolon
id|counter
op_decrement
suffix:semicolon
id|str
op_increment
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
r_static
r_int
DECL|function|snt_sim_getc
id|snt_sim_getc
c_func
(paren
r_void
)paren
(brace
r_return
id|readb
c_func
(paren
id|master_node_bedrock_address
op_plus
(paren
id|UART_RX
op_lshift
l_int|3
)paren
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|snt_sim_input_pending
id|snt_sim_input_pending
c_func
(paren
r_void
)paren
(brace
r_return
id|readb
c_func
(paren
id|master_node_bedrock_address
op_plus
(paren
id|UART_LSR
op_lshift
l_int|3
)paren
)paren
op_amp
id|UART_LSR_DR
suffix:semicolon
)brace
multiline_comment|/* routines for an interrupt driven console (normal) */
r_static
r_int
DECL|function|snt_intr_getc
id|snt_intr_getc
c_func
(paren
r_void
)paren
(brace
r_return
id|ia64_sn_console_readc
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|snt_intr_input_pending
id|snt_intr_input_pending
c_func
(paren
r_void
)paren
(brace
r_return
id|ia64_sn_console_intr_status
c_func
(paren
)paren
op_amp
id|SAL_CONSOLE_INTR_RECV
suffix:semicolon
)brace
multiline_comment|/* The early printk (possible setup) and function call */
r_void
DECL|function|early_printk_sn_sal
id|early_printk_sn_sal
c_func
(paren
r_const
r_char
op_star
id|s
comma
r_int
id|count
)paren
(brace
r_extern
r_void
id|early_sn_setup
c_func
(paren
r_void
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sn_func
)paren
(brace
r_if
c_cond
(paren
id|IS_RUNNING_ON_SIMULATOR
c_func
(paren
)paren
)paren
id|sn_func
op_assign
op_amp
id|sim_ops
suffix:semicolon
r_else
id|sn_func
op_assign
op_amp
id|poll_ops
suffix:semicolon
id|early_sn_setup
c_func
(paren
)paren
suffix:semicolon
)brace
id|sn_func
op_member_access_from_pointer
id|sal_puts
c_func
(paren
id|s
comma
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/* this is as &quot;close to the metal&quot; as we can get, used when the driver&n; * itself may be broken */
r_static
r_int
DECL|function|sn_debug_printf
id|sn_debug_printf
c_func
(paren
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
r_static
r_char
id|printk_buf
(braket
l_int|1024
)braket
suffix:semicolon
r_int
id|printed_len
suffix:semicolon
id|va_list
id|args
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|printed_len
op_assign
id|vsnprintf
c_func
(paren
id|printk_buf
comma
r_sizeof
(paren
id|printk_buf
)paren
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
id|early_printk_sn_sal
c_func
(paren
id|printk_buf
comma
id|printed_len
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
r_return
id|printed_len
suffix:semicolon
)brace
multiline_comment|/*&n; * Interrupt handling routines.&n; */
r_static
r_void
DECL|function|sn_sal_sched_event
id|sn_sal_sched_event
c_func
(paren
r_int
id|event
)paren
(brace
id|sn_sal_event
op_or_assign
(paren
l_int|1
op_lshift
id|event
)paren
suffix:semicolon
id|tasklet_schedule
c_func
(paren
op_amp
id|sn_sal_tasklet
)paren
suffix:semicolon
)brace
multiline_comment|/* sn_receive_chars can be called before sn_sal_tty is initialized.  in&n; * that case, its only use is to trigger sysrq and kdb */
r_static
r_void
DECL|function|sn_receive_chars
id|sn_receive_chars
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
r_int
op_star
id|flags
)paren
(brace
r_int
id|ch
suffix:semicolon
r_while
c_loop
(paren
id|sn_func
op_member_access_from_pointer
id|sal_input_pending
c_func
(paren
)paren
)paren
(brace
id|ch
op_assign
id|sn_func
op_member_access_from_pointer
id|sal_getc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sn_serial: An error occured while &quot;
l_string|&quot;obtaining data from the console (0x%0x)&bslash;n&quot;
comma
id|ch
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_SGI_L1_SERIAL_CONSOLE) &amp;&amp; defined(CONFIG_MAGIC_SYSRQ)
r_if
c_cond
(paren
id|sysrq_requested
)paren
(brace
r_int
r_int
id|sysrq_timeout
op_assign
id|sysrq_requested
op_plus
id|HZ
op_star
l_int|5
suffix:semicolon
id|sysrq_requested
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_logical_and
id|time_before
c_func
(paren
id|jiffies
comma
id|sysrq_timeout
)paren
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sn_sal_lock
comma
op_star
id|flags
)paren
suffix:semicolon
id|handle_sysrq
c_func
(paren
id|ch
comma
id|regs
comma
l_int|NULL
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sn_sal_lock
comma
op_star
id|flags
)paren
suffix:semicolon
multiline_comment|/* don&squot;t record this char */
r_continue
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ch
op_eq
op_star
id|sysrq_serial_ptr
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
op_increment
id|sysrq_serial_ptr
)paren
)paren
(brace
id|sysrq_requested
op_assign
id|jiffies
suffix:semicolon
id|sysrq_serial_ptr
op_assign
id|sysrq_serial_str
suffix:semicolon
)brace
)brace
r_else
id|sysrq_serial_ptr
op_assign
id|sysrq_serial_str
suffix:semicolon
macro_line|#endif /* CONFIG_SGI_L1_SERIAL_CONSOLE &amp;&amp; CONFIG_MAGIC_SYSRQ */
multiline_comment|/* record the character to pass up to the tty layer */
r_if
c_cond
(paren
id|sn_sal_tty
)paren
(brace
op_star
id|sn_sal_tty-&gt;flip.char_buf_ptr
op_assign
id|ch
suffix:semicolon
id|sn_sal_tty-&gt;flip.char_buf_ptr
op_increment
suffix:semicolon
id|sn_sal_tty-&gt;flip.count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|sn_sal_tty-&gt;flip.count
op_eq
id|TTY_FLIPBUF_SIZE
)paren
r_break
suffix:semicolon
)brace
id|sn_total_rx_count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sn_sal_tty
)paren
id|tty_flip_buffer_push
c_func
(paren
(paren
r_struct
id|tty_struct
op_star
)paren
id|sn_sal_tty
)paren
suffix:semicolon
)brace
multiline_comment|/* synch_flush_xmit must be called with sn_sal_lock */
r_static
r_void
DECL|function|synch_flush_xmit
id|synch_flush_xmit
c_func
(paren
r_void
)paren
(brace
r_int
id|xmit_count
comma
id|tail
comma
id|head
comma
id|loops
comma
id|ii
suffix:semicolon
r_int
id|result
suffix:semicolon
r_char
op_star
id|start
suffix:semicolon
r_if
c_cond
(paren
id|xmit.cb_head
op_eq
id|xmit.cb_tail
)paren
r_return
suffix:semicolon
multiline_comment|/* Nothing to do. */
id|head
op_assign
id|xmit.cb_head
suffix:semicolon
id|tail
op_assign
id|xmit.cb_tail
suffix:semicolon
id|start
op_assign
op_amp
id|xmit.cb_buf
(braket
id|tail
)braket
suffix:semicolon
multiline_comment|/* twice around gets the tail to the end of the buffer and&n;&t; * then to the head, if needed */
id|loops
op_assign
(paren
id|head
OL
id|tail
)paren
ques
c_cond
l_int|2
suffix:colon
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|ii
op_assign
l_int|0
suffix:semicolon
id|ii
OL
id|loops
suffix:semicolon
id|ii
op_increment
)paren
(brace
id|xmit_count
op_assign
(paren
id|head
OL
id|tail
)paren
ques
c_cond
(paren
id|SN_SAL_BUFFER_SIZE
op_minus
id|tail
)paren
suffix:colon
(paren
id|head
op_minus
id|tail
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xmit_count
OG
l_int|0
)paren
(brace
id|result
op_assign
id|sn_func
op_member_access_from_pointer
id|sal_puts
c_func
(paren
(paren
r_char
op_star
)paren
id|start
comma
id|xmit_count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
id|sn_debug_printf
c_func
(paren
l_string|&quot;&bslash;n*** synch_flush_xmit failed to flush&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OG
l_int|0
)paren
(brace
id|xmit_count
op_sub_assign
id|result
suffix:semicolon
id|sn_total_tx_count
op_add_assign
id|result
suffix:semicolon
id|tail
op_add_assign
id|result
suffix:semicolon
id|tail
op_and_assign
id|SN_SAL_BUFFER_SIZE
op_minus
l_int|1
suffix:semicolon
id|xmit.cb_tail
op_assign
id|tail
suffix:semicolon
id|start
op_assign
(paren
r_char
op_star
)paren
op_amp
id|xmit.cb_buf
(braket
id|tail
)braket
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* must be called with a lock protecting the circular buffer and&n; * sn_sal_tty */
r_static
r_void
DECL|function|sn_poll_transmit_chars
id|sn_poll_transmit_chars
c_func
(paren
r_void
)paren
(brace
r_int
id|xmit_count
comma
id|tail
comma
id|head
suffix:semicolon
r_int
id|result
suffix:semicolon
r_char
op_star
id|start
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|sn_sal_is_asynch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xmit.cb_head
op_eq
id|xmit.cb_tail
op_logical_or
(paren
id|sn_sal_tty
op_logical_and
(paren
id|sn_sal_tty-&gt;stopped
op_logical_or
id|sn_sal_tty-&gt;hw_stopped
)paren
)paren
)paren
(brace
multiline_comment|/* Nothing to do. */
r_return
suffix:semicolon
)brace
id|head
op_assign
id|xmit.cb_head
suffix:semicolon
id|tail
op_assign
id|xmit.cb_tail
suffix:semicolon
id|start
op_assign
op_amp
id|xmit.cb_buf
(braket
id|tail
)braket
suffix:semicolon
id|xmit_count
op_assign
(paren
id|head
OL
id|tail
)paren
ques
c_cond
(paren
id|SN_SAL_BUFFER_SIZE
op_minus
id|tail
)paren
suffix:colon
(paren
id|head
op_minus
id|tail
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xmit_count
op_eq
l_int|0
)paren
id|sn_debug_printf
c_func
(paren
l_string|&quot;&bslash;n*** empty xmit_count&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* use the ops, as we could be on the simulator */
id|result
op_assign
id|sn_func
op_member_access_from_pointer
id|sal_puts
c_func
(paren
(paren
r_char
op_star
)paren
id|start
comma
id|xmit_count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
id|sn_debug_printf
c_func
(paren
l_string|&quot;&bslash;n*** error in synchronous sal_puts&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* XXX chadt clean this up */
r_if
c_cond
(paren
id|result
OG
l_int|0
)paren
(brace
id|xmit_count
op_sub_assign
id|result
suffix:semicolon
id|sn_total_tx_count
op_add_assign
id|result
suffix:semicolon
id|tail
op_add_assign
id|result
suffix:semicolon
id|tail
op_and_assign
id|SN_SAL_BUFFER_SIZE
op_minus
l_int|1
suffix:semicolon
id|xmit.cb_tail
op_assign
id|tail
suffix:semicolon
id|start
op_assign
op_amp
id|xmit.cb_buf
(braket
id|tail
)braket
suffix:semicolon
)brace
multiline_comment|/* if there&squot;s few enough characters left in the xmit buffer&n;&t; * that we could stand for the upper layer to send us some&n;&t; * more, ask for it. */
r_if
c_cond
(paren
id|sn_sal_tty
)paren
r_if
c_cond
(paren
id|CIRC_CNT
c_func
(paren
id|xmit.cb_head
comma
id|xmit.cb_tail
comma
id|SN_SAL_BUFFER_SIZE
)paren
OL
id|WAKEUP_CHARS
)paren
id|sn_sal_sched_event
c_func
(paren
id|SN_SAL_EVENT_WRITE_WAKEUP
)paren
suffix:semicolon
)brace
multiline_comment|/* must be called with a lock protecting the circular buffer and&n; * sn_sal_tty */
r_static
r_void
DECL|function|sn_intr_transmit_chars
id|sn_intr_transmit_chars
c_func
(paren
r_void
)paren
(brace
r_int
id|xmit_count
comma
id|tail
comma
id|head
comma
id|loops
comma
id|ii
suffix:semicolon
r_int
id|result
suffix:semicolon
r_char
op_star
id|start
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|sn_sal_is_asynch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xmit.cb_head
op_eq
id|xmit.cb_tail
op_logical_or
(paren
id|sn_sal_tty
op_logical_and
(paren
id|sn_sal_tty-&gt;stopped
op_logical_or
id|sn_sal_tty-&gt;hw_stopped
)paren
)paren
)paren
(brace
multiline_comment|/* Nothing to do. */
r_return
suffix:semicolon
)brace
id|head
op_assign
id|xmit.cb_head
suffix:semicolon
id|tail
op_assign
id|xmit.cb_tail
suffix:semicolon
id|start
op_assign
op_amp
id|xmit.cb_buf
(braket
id|tail
)braket
suffix:semicolon
multiline_comment|/* twice around gets the tail to the end of the buffer and&n;&t; * then to the head, if needed */
id|loops
op_assign
(paren
id|head
OL
id|tail
)paren
ques
c_cond
l_int|2
suffix:colon
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|ii
op_assign
l_int|0
suffix:semicolon
id|ii
OL
id|loops
suffix:semicolon
id|ii
op_increment
)paren
(brace
id|xmit_count
op_assign
(paren
id|head
OL
id|tail
)paren
ques
c_cond
(paren
id|SN_SAL_BUFFER_SIZE
op_minus
id|tail
)paren
suffix:colon
(paren
id|head
op_minus
id|tail
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xmit_count
OG
l_int|0
)paren
(brace
id|result
op_assign
id|ia64_sn_console_xmit_chars
c_func
(paren
(paren
r_char
op_star
)paren
id|start
comma
id|xmit_count
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
id|sn_debug_printf
c_func
(paren
l_string|&quot;`&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|result
OG
l_int|0
)paren
(brace
id|xmit_count
op_sub_assign
id|result
suffix:semicolon
id|sn_total_tx_count
op_add_assign
id|result
suffix:semicolon
id|tail
op_add_assign
id|result
suffix:semicolon
id|tail
op_and_assign
id|SN_SAL_BUFFER_SIZE
op_minus
l_int|1
suffix:semicolon
id|xmit.cb_tail
op_assign
id|tail
suffix:semicolon
id|start
op_assign
op_amp
id|xmit.cb_buf
(braket
id|tail
)braket
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* if there&squot;s few enough characters left in the xmit buffer&n;&t; * that we could stand for the upper layer to send us some&n;&t; * more, ask for it. */
r_if
c_cond
(paren
id|sn_sal_tty
)paren
r_if
c_cond
(paren
id|CIRC_CNT
c_func
(paren
id|xmit.cb_head
comma
id|xmit.cb_tail
comma
id|SN_SAL_BUFFER_SIZE
)paren
OL
id|WAKEUP_CHARS
)paren
id|sn_sal_sched_event
c_func
(paren
id|SN_SAL_EVENT_WRITE_WAKEUP
)paren
suffix:semicolon
)brace
r_static
id|irqreturn_t
DECL|function|sn_sal_interrupt
id|sn_sal_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* this call is necessary to pass the interrupt back to the&n;&t; * SAL, since it doesn&squot;t intercept the UART interrupts&n;&t; * itself */
r_int
id|status
op_assign
id|ia64_sn_console_intr_status
c_func
(paren
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sn_sal_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|SAL_CONSOLE_INTR_RECV
)paren
id|sn_receive_chars
c_func
(paren
id|regs
comma
op_amp
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|SAL_CONSOLE_INTR_XMIT
)paren
id|sn_intr_transmit_chars
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sn_sal_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/* returns the console irq if interrupt is successfully registered,&n; * else 0 */
r_static
r_int
DECL|function|sn_sal_connect_interrupt
id|sn_sal_connect_interrupt
c_func
(paren
r_void
)paren
(brace
id|cpuid_t
id|intr_cpuid
suffix:semicolon
r_int
r_int
id|intr_cpuloc
suffix:semicolon
id|nasid_t
id|console_nasid
suffix:semicolon
r_int
r_int
id|console_irq
suffix:semicolon
r_int
id|result
suffix:semicolon
id|console_nasid
op_assign
id|ia64_sn_get_console_nasid
c_func
(paren
)paren
suffix:semicolon
id|intr_cpuid
op_assign
id|NODEPDA
c_func
(paren
id|NASID_TO_COMPACT_NODEID
c_func
(paren
id|console_nasid
)paren
)paren
op_member_access_from_pointer
id|node_first_cpu
suffix:semicolon
id|intr_cpuloc
op_assign
id|cpu_physical_id
c_func
(paren
id|intr_cpuid
)paren
suffix:semicolon
id|console_irq
op_assign
id|CPU_VECTOR_TO_IRQ
c_func
(paren
id|intr_cpuloc
comma
id|SGI_UART_VECTOR
)paren
suffix:semicolon
id|result
op_assign
id|intr_connect_level
c_func
(paren
id|intr_cpuid
comma
id|SGI_UART_VECTOR
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|result
op_ne
id|SGI_UART_VECTOR
)paren
suffix:semicolon
id|result
op_assign
id|request_irq
c_func
(paren
id|console_irq
comma
id|sn_sal_interrupt
comma
id|SA_INTERRUPT
comma
l_string|&quot;SAL console driver&quot;
comma
op_amp
id|sn_sal_tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ge
l_int|0
)paren
r_return
id|console_irq
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;sn_serial: console proceeding in polled mode&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|sn_sal_tasklet_action
id|sn_sal_tasklet_action
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|sn_sal_tty
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sn_sal_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sn_sal_tty
)paren
(brace
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|SN_SAL_EVENT_WRITE_WAKEUP
comma
op_amp
id|sn_sal_event
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|sn_sal_tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|sn_sal_tty-&gt;ldisc.write_wakeup
)paren
(paren
id|sn_sal_tty-&gt;ldisc.write_wakeup
)paren
(paren
(paren
r_struct
id|tty_struct
op_star
)paren
id|sn_sal_tty
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
(paren
id|wait_queue_head_t
op_star
)paren
op_amp
id|sn_sal_tty-&gt;write_wait
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sn_sal_lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This function handles polled mode.&n; */
r_static
r_void
DECL|function|sn_sal_timer_poll
id|sn_sal_timer_poll
c_func
(paren
r_int
r_int
id|dummy
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sn_sal_irq
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sn_sal_lock
comma
id|flags
)paren
suffix:semicolon
id|sn_receive_chars
c_func
(paren
l_int|NULL
comma
op_amp
id|flags
)paren
suffix:semicolon
id|sn_poll_transmit_chars
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sn_sal_lock
comma
id|flags
)paren
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|sn_sal_timer
comma
id|jiffies
op_plus
id|sn_interrupt_timeout
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * User-level console routines&n; */
r_static
r_int
DECL|function|sn_sal_open
id|sn_sal_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|DPRINTF
c_func
(paren
l_string|&quot;sn_sal_open: sn_sal_tty = %p, tty = %p, filp = %p&bslash;n&quot;
comma
id|sn_sal_tty
comma
id|tty
comma
id|filp
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sn_sal_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sn_sal_tty
)paren
id|sn_sal_tty
op_assign
id|tty
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sn_sal_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We&squot;re keeping all our resources.  We&squot;re keeping interrupts turned&n; * on.  Maybe just let the tty layer finish its stuff...? GMSH&n; */
r_static
r_void
DECL|function|sn_sal_close
id|sn_sal_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;count
op_eq
l_int|1
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|tty-&gt;closing
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver-&gt;flush_buffer
)paren
id|tty-&gt;driver
op_member_access_from_pointer
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;ldisc.flush_buffer
)paren
id|tty-&gt;ldisc
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
id|tty-&gt;closing
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sn_sal_lock
comma
id|flags
)paren
suffix:semicolon
id|sn_sal_tty
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sn_sal_lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|sn_sal_write
id|sn_sal_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
id|c
comma
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|from_user
)paren
(brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_int
id|c1
suffix:semicolon
id|c
op_assign
id|CIRC_SPACE_TO_END
c_func
(paren
id|xmit.cb_head
comma
id|xmit.cb_tail
comma
id|SN_SAL_BUFFER_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
id|c
)paren
id|c
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|c
op_le
l_int|0
)paren
r_break
suffix:semicolon
id|c
op_sub_assign
id|copy_from_user
c_func
(paren
id|sn_tmp_buffer
comma
id|buf
comma
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Turn off interrupts and see if the xmit buffer has&n;&t;&t;&t; * moved since the last time we looked.&n;&t;&t;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sn_sal_lock
comma
id|flags
)paren
suffix:semicolon
id|c1
op_assign
id|CIRC_SPACE_TO_END
c_func
(paren
id|xmit.cb_head
comma
id|xmit.cb_tail
comma
id|SN_SAL_BUFFER_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c1
OL
id|c
)paren
id|c
op_assign
id|c1
suffix:semicolon
id|memcpy
c_func
(paren
id|xmit.cb_buf
op_plus
id|xmit.cb_head
comma
id|sn_tmp_buffer
comma
id|c
)paren
suffix:semicolon
id|xmit.cb_head
op_assign
(paren
(paren
id|xmit.cb_head
op_plus
id|c
)paren
op_amp
(paren
id|SN_SAL_BUFFER_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sn_sal_lock
comma
id|flags
)paren
suffix:semicolon
id|buf
op_add_assign
id|c
suffix:semicolon
id|count
op_sub_assign
id|c
suffix:semicolon
id|ret
op_add_assign
id|c
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* The buffer passed in isn&squot;t coming from userland,&n;&t;&t; * so cut out the middleman (sn_tmp_buffer).&n;&t;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sn_sal_lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|c
op_assign
id|CIRC_SPACE_TO_END
c_func
(paren
id|xmit.cb_head
comma
id|xmit.cb_tail
comma
id|SN_SAL_BUFFER_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
id|c
)paren
id|c
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|c
op_le
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|xmit.cb_buf
op_plus
id|xmit.cb_head
comma
id|buf
comma
id|c
)paren
suffix:semicolon
id|xmit.cb_head
op_assign
(paren
(paren
id|xmit.cb_head
op_plus
id|c
)paren
op_amp
(paren
id|SN_SAL_BUFFER_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|buf
op_add_assign
id|c
suffix:semicolon
id|count
op_sub_assign
id|c
suffix:semicolon
id|ret
op_add_assign
id|c
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sn_sal_lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sn_sal_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xmit.cb_head
op_ne
id|xmit.cb_tail
op_logical_and
op_logical_neg
(paren
id|tty
op_logical_and
(paren
id|tty-&gt;stopped
op_logical_or
id|tty-&gt;hw_stopped
)paren
)paren
)paren
r_if
c_cond
(paren
id|sn_func-&gt;sal_wakeup_transmit
)paren
id|sn_func
op_member_access_from_pointer
id|sal_wakeup_transmit
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sn_sal_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_void
DECL|function|sn_sal_put_char
id|sn_sal_put_char
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
r_char
id|ch
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sn_sal_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CIRC_SPACE
c_func
(paren
id|xmit.cb_head
comma
id|xmit.cb_tail
comma
id|SN_SAL_BUFFER_SIZE
)paren
op_ne
l_int|0
)paren
(brace
id|xmit.cb_buf
(braket
id|xmit.cb_head
)braket
op_assign
id|ch
suffix:semicolon
id|xmit.cb_head
op_assign
(paren
id|xmit.cb_head
op_plus
l_int|1
)paren
op_amp
(paren
id|SN_SAL_BUFFER_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sn_func-&gt;sal_wakeup_transmit
)paren
id|sn_func
op_member_access_from_pointer
id|sal_wakeup_transmit
c_func
(paren
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sn_sal_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|sn_sal_flush_chars
id|sn_sal_flush_chars
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sn_sal_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CIRC_CNT
c_func
(paren
id|xmit.cb_head
comma
id|xmit.cb_tail
comma
id|SN_SAL_BUFFER_SIZE
)paren
)paren
r_if
c_cond
(paren
id|sn_func-&gt;sal_wakeup_transmit
)paren
id|sn_func
op_member_access_from_pointer
id|sal_wakeup_transmit
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sn_sal_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|sn_sal_write_room
id|sn_sal_write_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|space
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sn_sal_lock
comma
id|flags
)paren
suffix:semicolon
id|space
op_assign
id|CIRC_SPACE
c_func
(paren
id|xmit.cb_head
comma
id|xmit.cb_tail
comma
id|SN_SAL_BUFFER_SIZE
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sn_sal_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|space
suffix:semicolon
)brace
r_static
r_int
DECL|function|sn_sal_chars_in_buffer
id|sn_sal_chars_in_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|space
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sn_sal_lock
comma
id|flags
)paren
suffix:semicolon
id|space
op_assign
id|CIRC_CNT
c_func
(paren
id|xmit.cb_head
comma
id|xmit.cb_tail
comma
id|SN_SAL_BUFFER_SIZE
)paren
suffix:semicolon
id|DPRINTF
c_func
(paren
l_string|&quot;&lt;%d&gt;&quot;
comma
id|space
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sn_sal_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|space
suffix:semicolon
)brace
r_static
r_void
DECL|function|sn_sal_flush_buffer
id|sn_sal_flush_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* drop everything */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sn_sal_lock
comma
id|flags
)paren
suffix:semicolon
id|xmit.cb_head
op_assign
id|xmit.cb_tail
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sn_sal_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* wake up tty level */
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|sn_sal_hangup
id|sn_sal_hangup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|sn_sal_flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|sn_sal_wait_until_sent
id|sn_sal_wait_until_sent
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|timeout
)paren
(brace
multiline_comment|/* this is SAL&squot;s problem */
id|DPRINTF
c_func
(paren
l_string|&quot;&lt;sn_serial: should wait until sent&gt;&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * sn_sal_read_proc&n; *&n; * Console /proc interface&n; */
r_static
r_int
DECL|function|sn_sal_read_proc
id|sn_sal_read_proc
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|begin
op_assign
l_int|0
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;sn_serial: nasid:%d irq:%d tx:%d rx:%d&bslash;n&quot;
comma
id|ia64_sn_get_console_nasid
c_func
(paren
)paren
comma
id|sn_sal_irq
comma
id|sn_total_tx_count
comma
id|sn_total_rx_count
)paren
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|off
op_ge
id|len
op_plus
id|begin
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|start
op_assign
id|page
op_plus
(paren
id|off
op_minus
id|begin
)paren
suffix:semicolon
r_return
id|count
OL
id|begin
op_plus
id|len
op_minus
id|off
ques
c_cond
id|count
suffix:colon
id|begin
op_plus
id|len
op_minus
id|off
suffix:semicolon
)brace
DECL|variable|sn_sal_driver_ops
r_static
r_struct
id|tty_operations
id|sn_sal_driver_ops
op_assign
(brace
dot
id|open
op_assign
id|sn_sal_open
comma
dot
id|close
op_assign
id|sn_sal_close
comma
dot
id|write
op_assign
id|sn_sal_write
comma
dot
id|put_char
op_assign
id|sn_sal_put_char
comma
dot
id|flush_chars
op_assign
id|sn_sal_flush_chars
comma
dot
id|write_room
op_assign
id|sn_sal_write_room
comma
dot
id|chars_in_buffer
op_assign
id|sn_sal_chars_in_buffer
comma
dot
id|hangup
op_assign
id|sn_sal_hangup
comma
dot
id|wait_until_sent
op_assign
id|sn_sal_wait_until_sent
comma
dot
id|read_proc
op_assign
id|sn_sal_read_proc
comma
)brace
suffix:semicolon
DECL|variable|sn_sal_driver
r_static
r_struct
id|tty_driver
op_star
id|sn_sal_driver
suffix:semicolon
multiline_comment|/* sn_sal_init wishlist:&n; * - allocate sn_tmp_buffer&n; * - fix up the tty_driver struct&n; * - turn on receive interrupts&n; * - do any termios twiddling once and for all&n; */
multiline_comment|/*&n; * Boot-time initialization code&n; */
r_static
r_void
id|__init
DECL|function|sn_sal_switch_to_asynch
id|sn_sal_switch_to_asynch
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* without early_printk, we may be invoked late enough to race&n;&t; * with other cpus doing console IO at this point, however&n;&t; * console interrupts will never be enabled */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sn_sal_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sn_sal_is_asynch
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sn_sal_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sn_debug_printf
c_func
(paren
l_string|&quot;sn_serial: switch to asynchronous console&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* early_printk invocation may have done this for us */
r_if
c_cond
(paren
op_logical_neg
id|sn_func
)paren
(brace
r_if
c_cond
(paren
id|IS_RUNNING_ON_SIMULATOR
c_func
(paren
)paren
)paren
id|sn_func
op_assign
op_amp
id|sim_ops
suffix:semicolon
r_else
id|sn_func
op_assign
op_amp
id|poll_ops
suffix:semicolon
)brace
multiline_comment|/* we can&squot;t turn on the console interrupt (as request_irq&n;&t; * calls kmalloc, which isn&squot;t set up yet), so we rely on a&n;&t; * timer to poll for input and push data from the console&n;&t; * buffer.&n;&t; */
id|init_timer
c_func
(paren
op_amp
id|sn_sal_timer
)paren
suffix:semicolon
id|sn_sal_timer.function
op_assign
id|sn_sal_timer_poll
suffix:semicolon
r_if
c_cond
(paren
id|IS_RUNNING_ON_SIMULATOR
c_func
(paren
)paren
)paren
id|sn_interrupt_timeout
op_assign
l_int|6
suffix:semicolon
r_else
(brace
multiline_comment|/* 960cps / 16 char FIFO = 60HZ&n;&t;&t; * HZ / (SN_SAL_FIFO_SPEED_CPS / SN_SAL_FIFO_DEPTH) */
id|sn_interrupt_timeout
op_assign
id|HZ
op_star
id|SN_SAL_UART_FIFO_DEPTH
op_div
id|SN_SAL_UART_FIFO_SPEED_CPS
suffix:semicolon
)brace
id|mod_timer
c_func
(paren
op_amp
id|sn_sal_timer
comma
id|jiffies
op_plus
id|sn_interrupt_timeout
)paren
suffix:semicolon
id|sn_sal_is_asynch
op_assign
l_int|1
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sn_sal_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
id|__init
DECL|function|sn_sal_switch_to_interrupts
id|sn_sal_switch_to_interrupts
c_func
(paren
r_void
)paren
(brace
r_int
id|irq
suffix:semicolon
id|sn_debug_printf
c_func
(paren
l_string|&quot;sn_serial: switching to interrupt driven console&bslash;n&quot;
)paren
suffix:semicolon
id|irq
op_assign
id|sn_sal_connect_interrupt
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sn_sal_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* sn_sal_irq is a global variable.  When it&squot;s set to&n;&t;&t; * a non-zero value, we stop polling for input (since&n;&t;&t; * interrupts should now be enabled). */
id|sn_sal_irq
op_assign
id|irq
suffix:semicolon
id|sn_func
op_assign
op_amp
id|intr_ops
suffix:semicolon
multiline_comment|/* turn on receive interrupts */
id|ia64_sn_console_intr_enable
c_func
(paren
id|SAL_CONSOLE_INTR_RECV
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sn_sal_lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
id|__init
DECL|function|sn_sal_module_init
id|sn_sal_module_init
c_func
(paren
r_void
)paren
(brace
r_int
id|retval
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sn_serial: sn_sal_module_init&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ia64_platform_is
c_func
(paren
l_string|&quot;sn2&quot;
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|sn_sal_driver
op_assign
id|alloc_tty_driver
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sn_sal_driver
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|sn_sal_driver-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
id|sn_sal_driver-&gt;driver_name
op_assign
l_string|&quot;sn_serial&quot;
suffix:semicolon
id|sn_sal_driver-&gt;name
op_assign
l_string|&quot;ttyS&quot;
suffix:semicolon
id|sn_sal_driver-&gt;major
op_assign
id|TTY_MAJOR
suffix:semicolon
id|sn_sal_driver-&gt;minor_start
op_assign
id|SN_SAL_MINOR
suffix:semicolon
id|sn_sal_driver-&gt;type
op_assign
id|TTY_DRIVER_TYPE_SERIAL
suffix:semicolon
id|sn_sal_driver-&gt;subtype
op_assign
id|SERIAL_TYPE_NORMAL
suffix:semicolon
id|sn_sal_driver-&gt;flags
op_assign
id|TTY_DRIVER_REAL_RAW
op_or
id|TTY_DRIVER_NO_DEVFS
suffix:semicolon
id|tty_set_operations
c_func
(paren
id|sn_sal_driver
comma
op_amp
id|sn_sal_driver_ops
)paren
suffix:semicolon
multiline_comment|/* when this driver is compiled in, the console initialization&n;&t; * will have already switched us into asynchronous operation&n;&t; * before we get here through the module initcalls */
id|sn_sal_switch_to_asynch
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* at this point (module_init) we can try to turn on interrupts */
r_if
c_cond
(paren
op_logical_neg
id|IS_RUNNING_ON_SIMULATOR
c_func
(paren
)paren
)paren
id|sn_sal_switch_to_interrupts
c_func
(paren
)paren
suffix:semicolon
id|sn_sal_driver-&gt;init_termios
op_assign
id|tty_std_termios
suffix:semicolon
id|sn_sal_driver-&gt;init_termios.c_cflag
op_assign
id|B9600
op_or
id|CS8
op_or
id|CREAD
op_or
id|HUPCL
op_or
id|CLOCAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|tty_register_driver
c_func
(paren
id|sn_sal_driver
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sn_serial: Unable to register tty driver&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SGI_L1_SERIAL_CONSOLE
id|sn_sal_serial_console_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif&t;/* CONFIG_SGI_L1_SERIAL_CONSOLE */
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
id|__exit
DECL|function|sn_sal_module_exit
id|sn_sal_module_exit
c_func
(paren
r_void
)paren
(brace
id|del_timer_sync
c_func
(paren
op_amp
id|sn_sal_timer
)paren
suffix:semicolon
id|tty_unregister_driver
c_func
(paren
id|sn_sal_driver
)paren
suffix:semicolon
id|put_tty_driver
c_func
(paren
id|sn_sal_driver
)paren
suffix:semicolon
)brace
DECL|variable|sn_sal_module_init
id|module_init
c_func
(paren
id|sn_sal_module_init
)paren
suffix:semicolon
DECL|variable|sn_sal_module_exit
id|module_exit
c_func
(paren
id|sn_sal_module_exit
)paren
suffix:semicolon
multiline_comment|/*&n; * Kernel console definitions&n; */
macro_line|#ifdef CONFIG_SGI_L1_SERIAL_CONSOLE
multiline_comment|/*&n; * Print a string to the SAL console.  The console_lock must be held&n; * when we get here.&n; */
r_static
r_void
DECL|function|sn_sal_console_write
id|sn_sal_console_write
c_func
(paren
r_struct
id|console
op_star
id|co
comma
r_const
r_char
op_star
id|s
comma
r_int
id|count
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|sn_sal_is_asynch
)paren
suffix:semicolon
multiline_comment|/* somebody really wants this output, might be an&n;&t; * oops, kdb, panic, etc.  make sure they get it. */
r_if
c_cond
(paren
id|spin_is_locked
c_func
(paren
op_amp
id|sn_sal_lock
)paren
)paren
(brace
id|synch_flush_xmit
c_func
(paren
)paren
suffix:semicolon
id|sn_func
op_member_access_from_pointer
id|sal_puts
c_func
(paren
id|s
comma
id|count
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|in_interrupt
c_func
(paren
)paren
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sn_sal_lock
comma
id|flags
)paren
suffix:semicolon
id|synch_flush_xmit
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sn_sal_lock
comma
id|flags
)paren
suffix:semicolon
id|sn_func
op_member_access_from_pointer
id|sal_puts
c_func
(paren
id|s
comma
id|count
)paren
suffix:semicolon
)brace
r_else
id|sn_sal_write
c_func
(paren
l_int|NULL
comma
l_int|0
comma
id|s
comma
id|count
)paren
suffix:semicolon
)brace
r_static
r_struct
id|tty_driver
op_star
DECL|function|sn_sal_console_device
id|sn_sal_console_device
c_func
(paren
r_struct
id|console
op_star
id|c
comma
r_int
op_star
id|index
)paren
(brace
op_star
id|index
op_assign
id|c-&gt;index
suffix:semicolon
r_return
id|sn_sal_driver
suffix:semicolon
)brace
r_static
r_int
id|__init
DECL|function|sn_sal_console_setup
id|sn_sal_console_setup
c_func
(paren
r_struct
id|console
op_star
id|co
comma
r_char
op_star
id|options
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|sal_console
r_static
r_struct
id|console
id|sal_console
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;ttyS&quot;
comma
dot
id|write
op_assign
id|sn_sal_console_write
comma
dot
id|device
op_assign
id|sn_sal_console_device
comma
dot
id|setup
op_assign
id|sn_sal_console_setup
comma
dot
id|index
op_assign
op_minus
l_int|1
)brace
suffix:semicolon
r_static
r_void
id|__init
DECL|function|sn_sal_serial_console_init
id|sn_sal_serial_console_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|ia64_platform_is
c_func
(paren
l_string|&quot;sn2&quot;
)paren
)paren
(brace
id|sn_sal_switch_to_asynch
c_func
(paren
)paren
suffix:semicolon
id|sn_debug_printf
c_func
(paren
l_string|&quot;sn_sal_serial_console_init : register console&bslash;n&quot;
)paren
suffix:semicolon
id|register_console
c_func
(paren
op_amp
id|sal_console
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* CONFIG_SGI_L1_SERIAL_CONSOLE */
eof
