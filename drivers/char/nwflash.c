multiline_comment|/*&n; * Flash memory interface rev.5 driver for the Intel&n; * Flash chips used on the NetWinder.&n; *&n; * 20/08/2000&t;RMK&t;use __ioremap to map flash into virtual memory&n; *&t;&t;&t;make a few more places use &quot;volatile&quot;&n; * 22/05/2001&t;RMK&t;- Lock read against write&n; *&t;&t;&t;- merge printk level changes (with mods) from Alan Cox.&n; *&t;&t;&t;- use *ppos as the file position, not file-&gt;f_pos.&n; *&t;&t;&t;- fix check for out of range pos and r/w size&n; *&n; * Please note that we are tampering with the only flash chip in the&n; * machine, which contains the bootup code.  We therefore have the&n; * power to convert these machines into doorstops...&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/miscdevice.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/rwsem.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/hardware/dec21285.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/leds.h&gt;
macro_line|#include &lt;asm/mach-types.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
multiline_comment|/*****************************************************************************/
macro_line|#include &lt;asm/nwflash.h&gt;
DECL|macro|NWFLASH_VERSION
mdefine_line|#define&t;NWFLASH_VERSION &quot;6.4&quot;
r_static
r_void
id|kick_open
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|get_flash_id
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|erase_block
c_func
(paren
r_int
id|nBlock
)paren
suffix:semicolon
r_static
r_int
id|write_block
c_func
(paren
r_int
r_int
id|p
comma
r_const
r_char
id|__user
op_star
id|buf
comma
r_int
id|count
)paren
suffix:semicolon
DECL|macro|KFLASH_SIZE
mdefine_line|#define KFLASH_SIZE&t;1024*1024&t;
singleline_comment|//1 Meg
DECL|macro|KFLASH_SIZE4
mdefine_line|#define KFLASH_SIZE4&t;4*1024*1024&t;
singleline_comment|//4 Meg
DECL|macro|KFLASH_ID
mdefine_line|#define KFLASH_ID&t;0x89A6&t;&t;
singleline_comment|//Intel flash
DECL|macro|KFLASH_ID4
mdefine_line|#define KFLASH_ID4&t;0xB0D4&t;&t;
singleline_comment|//Intel flash 4Meg
DECL|variable|flashdebug
r_static
r_int
id|flashdebug
suffix:semicolon
singleline_comment|//if set - we will display progress msgs
DECL|variable|gbWriteEnable
r_static
r_int
id|gbWriteEnable
suffix:semicolon
DECL|variable|gbWriteBase64Enable
r_static
r_int
id|gbWriteBase64Enable
suffix:semicolon
DECL|variable|FLASH_BASE
r_static
r_volatile
r_int
r_char
op_star
id|FLASH_BASE
suffix:semicolon
DECL|variable|gbFlashSize
r_static
r_int
id|gbFlashSize
op_assign
id|KFLASH_SIZE
suffix:semicolon
r_static
id|DECLARE_MUTEX
c_func
(paren
id|nwflash_sem
)paren
suffix:semicolon
r_extern
id|spinlock_t
id|gpio_lock
suffix:semicolon
DECL|function|get_flash_id
r_static
r_int
id|get_flash_id
c_func
(paren
r_void
)paren
(brace
r_volatile
r_int
r_int
id|c1
comma
id|c2
suffix:semicolon
multiline_comment|/*&n;&t; * try to get flash chip ID&n;&t; */
id|kick_open
c_func
(paren
)paren
suffix:semicolon
id|c2
op_assign
id|inb
c_func
(paren
l_int|0x80
)paren
suffix:semicolon
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|FLASH_BASE
op_plus
l_int|0x8000
)paren
op_assign
l_int|0x90
suffix:semicolon
id|udelay
c_func
(paren
l_int|15
)paren
suffix:semicolon
id|c1
op_assign
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
id|FLASH_BASE
suffix:semicolon
id|c2
op_assign
id|inb
c_func
(paren
l_int|0x80
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * on 4 Meg flash the second byte is actually at offset 2...&n;&t; */
r_if
c_cond
(paren
id|c1
op_eq
l_int|0xB0
)paren
id|c2
op_assign
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|FLASH_BASE
op_plus
l_int|2
)paren
suffix:semicolon
r_else
id|c2
op_assign
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|FLASH_BASE
op_plus
l_int|1
)paren
suffix:semicolon
id|c2
op_add_assign
(paren
id|c1
op_lshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set it back to read mode&n;&t; */
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|FLASH_BASE
op_plus
l_int|0x8000
)paren
op_assign
l_int|0xFF
suffix:semicolon
r_if
c_cond
(paren
id|c2
op_eq
id|KFLASH_ID4
)paren
id|gbFlashSize
op_assign
id|KFLASH_SIZE4
suffix:semicolon
r_return
id|c2
suffix:semicolon
)brace
DECL|function|flash_ioctl
r_static
r_int
id|flash_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inodep
comma
r_struct
id|file
op_star
id|filep
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CMD_WRITE_DISABLE
suffix:colon
id|gbWriteBase64Enable
op_assign
l_int|0
suffix:semicolon
id|gbWriteEnable
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMD_WRITE_ENABLE
suffix:colon
id|gbWriteEnable
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMD_WRITE_BASE64K_ENABLE
suffix:colon
id|gbWriteBase64Enable
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|gbWriteBase64Enable
op_assign
l_int|0
suffix:semicolon
id|gbWriteEnable
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|flash_read
r_static
id|ssize_t
id|flash_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
id|__user
op_star
id|buf
comma
r_int
id|size
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_int
r_int
id|p
op_assign
op_star
id|ppos
suffix:semicolon
r_int
r_int
id|count
op_assign
id|size
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|flashdebug
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;flash_read: flash_read: offset=0x%lX, &quot;
l_string|&quot;buffer=%p, count=0x%X.&bslash;n&quot;
comma
id|p
comma
id|buf
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
id|ret
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|p
OL
id|gbFlashSize
)paren
(brace
r_if
c_cond
(paren
id|count
OG
id|gbFlashSize
op_minus
id|p
)paren
id|count
op_assign
id|gbFlashSize
op_minus
id|p
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We now lock against reads and writes. --rmk&n;&t;&t; */
r_if
c_cond
(paren
id|down_interruptible
c_func
(paren
op_amp
id|nwflash_sem
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
id|ret
op_assign
id|copy_to_user
c_func
(paren
id|buf
comma
(paren
r_void
op_star
)paren
(paren
id|FLASH_BASE
op_plus
id|p
)paren
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
id|count
suffix:semicolon
op_star
id|ppos
op_add_assign
id|count
suffix:semicolon
)brace
r_else
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|up
c_func
(paren
op_amp
id|nwflash_sem
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|flash_write
r_static
id|ssize_t
id|flash_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
id|__user
op_star
id|buf
comma
r_int
id|size
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_int
r_int
id|p
op_assign
op_star
id|ppos
suffix:semicolon
r_int
r_int
id|count
op_assign
id|size
suffix:semicolon
r_int
id|written
suffix:semicolon
r_int
id|nBlock
comma
id|temp
comma
id|rc
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_if
c_cond
(paren
id|flashdebug
)paren
id|printk
c_func
(paren
l_string|&quot;flash_write: offset=0x%lX, buffer=0x%p, count=0x%X.&bslash;n&quot;
comma
id|p
comma
id|buf
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|gbWriteEnable
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|p
OL
l_int|64
op_star
l_int|1024
op_logical_and
(paren
op_logical_neg
id|gbWriteBase64Enable
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * check for out of range pos or count&n;&t; */
r_if
c_cond
(paren
id|p
op_ge
id|gbFlashSize
)paren
r_return
id|count
ques
c_cond
op_minus
id|ENXIO
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
id|gbFlashSize
op_minus
id|p
)paren
id|count
op_assign
id|gbFlashSize
op_minus
id|p
suffix:semicolon
r_if
c_cond
(paren
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|buf
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/*&n;&t; * We now lock against reads and writes. --rmk&n;&t; */
r_if
c_cond
(paren
id|down_interruptible
c_func
(paren
op_amp
id|nwflash_sem
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
id|written
op_assign
l_int|0
suffix:semicolon
id|leds_event
c_func
(paren
id|led_claim
)paren
suffix:semicolon
id|leds_event
c_func
(paren
id|led_green_on
)paren
suffix:semicolon
id|nBlock
op_assign
(paren
r_int
)paren
id|p
op_rshift
l_int|16
suffix:semicolon
singleline_comment|//block # of 64K bytes
multiline_comment|/*&n;&t; * # of 64K blocks to erase and write&n;&t; */
id|temp
op_assign
(paren
(paren
r_int
)paren
(paren
id|p
op_plus
id|count
)paren
op_rshift
l_int|16
)paren
op_minus
id|nBlock
op_plus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * write ends at exactly 64k boundary?&n;&t; */
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
(paren
id|p
op_plus
id|count
)paren
op_amp
l_int|0xFFFF
)paren
op_eq
l_int|0
)paren
id|temp
op_sub_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|flashdebug
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;flash_write: writing %d block(s) &quot;
l_string|&quot;starting at %d.&bslash;n&quot;
comma
id|temp
comma
id|nBlock
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|temp
suffix:semicolon
id|temp
op_decrement
comma
id|nBlock
op_increment
)paren
(brace
r_if
c_cond
(paren
id|flashdebug
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;flash_write: erasing block %d.&bslash;n&quot;
comma
id|nBlock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * first we have to erase the block(s), where we will write...&n;&t;&t; */
id|i
op_assign
l_int|0
suffix:semicolon
id|j
op_assign
l_int|0
suffix:semicolon
id|RetryBlock
suffix:colon
r_do
(brace
id|rc
op_assign
id|erase_block
c_func
(paren
id|nBlock
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|rc
op_logical_and
id|i
OL
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;flash_write: erase error %x&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flashdebug
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;flash_write: writing offset %lX, &quot;
l_string|&quot;from buf %p, bytes left %X.&bslash;n&quot;
comma
id|p
comma
id|buf
comma
id|count
op_minus
id|written
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * write_block will limit write to space left in this block&n;&t;&t; */
id|rc
op_assign
id|write_block
c_func
(paren
id|p
comma
id|buf
comma
id|count
op_minus
id|written
)paren
suffix:semicolon
id|j
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * if somehow write verify failed? Can&squot;t happen??&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|rc
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * retry up to 10 times&n;&t;&t;&t; */
r_if
c_cond
(paren
id|j
OL
l_int|10
)paren
r_goto
id|RetryBlock
suffix:semicolon
r_else
multiline_comment|/*&n;&t;&t;&t;&t; * else quit with error...&n;&t;&t;&t;&t; */
id|rc
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;flash_write: write error %X&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|p
op_add_assign
id|rc
suffix:semicolon
id|buf
op_add_assign
id|rc
suffix:semicolon
id|written
op_add_assign
id|rc
suffix:semicolon
op_star
id|ppos
op_add_assign
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|flashdebug
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;flash_write: written 0x%X bytes OK.&bslash;n&quot;
comma
id|written
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * restore reg on exit&n;&t; */
id|leds_event
c_func
(paren
id|led_release
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|nwflash_sem
)paren
suffix:semicolon
r_return
id|written
suffix:semicolon
)brace
multiline_comment|/*&n; * The memory devices use the full 32/64 bits of the offset, and so we cannot&n; * check against negative addresses: they are ok. The return value is weird,&n; * though, in that case (0).&n; *&n; * also note that seeking relative to the &quot;end of file&quot; isn&squot;t supported:&n; * it has no meaning, so it returns -EINVAL.&n; */
DECL|function|flash_llseek
r_static
id|loff_t
id|flash_llseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|loff_t
id|offset
comma
r_int
id|orig
)paren
(brace
id|loff_t
id|ret
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flashdebug
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;flash_llseek: offset=0x%X, orig=0x%X.&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|offset
comma
id|orig
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|orig
)paren
(brace
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
id|offset
OL
l_int|0
)paren
(brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|offset
OG
id|gbFlashSize
)paren
(brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|file-&gt;f_pos
op_assign
(paren
r_int
r_int
)paren
id|offset
suffix:semicolon
id|ret
op_assign
id|file-&gt;f_pos
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
(paren
id|file-&gt;f_pos
op_plus
id|offset
)paren
OG
id|gbFlashSize
)paren
(brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|file-&gt;f_pos
op_plus
id|offset
)paren
OL
l_int|0
)paren
(brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|file-&gt;f_pos
op_add_assign
id|offset
suffix:semicolon
id|ret
op_assign
id|file-&gt;f_pos
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * assume that main Write routine did the parameter checking...&n; * so just go ahead and erase, what requested!&n; */
DECL|function|erase_block
r_static
r_int
id|erase_block
c_func
(paren
r_int
id|nBlock
)paren
(brace
r_volatile
r_int
r_int
id|c1
suffix:semicolon
r_volatile
r_int
r_char
op_star
id|pWritePtr
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
r_int
id|temp
comma
id|temp1
suffix:semicolon
multiline_comment|/*&n;&t; * orange LED == erase&n;&t; */
id|leds_event
c_func
(paren
id|led_amber_on
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * reset footbridge to the correct offset 0 (...0..3)&n;&t; */
op_star
id|CSR_ROMWRITEREG
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * dummy ROM read&n;&t; */
id|c1
op_assign
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|FLASH_BASE
op_plus
l_int|0x8000
)paren
suffix:semicolon
id|kick_open
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * reset status if old errors&n;&t; */
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|FLASH_BASE
op_plus
l_int|0x8000
)paren
op_assign
l_int|0x50
suffix:semicolon
multiline_comment|/*&n;&t; * erase a block...&n;&t; * aim at the middle of a current block...&n;&t; */
id|pWritePtr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
(paren
r_int
r_int
)paren
(paren
id|FLASH_BASE
op_plus
l_int|0x8000
op_plus
(paren
id|nBlock
op_lshift
l_int|16
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * dummy read&n;&t; */
id|c1
op_assign
op_star
id|pWritePtr
suffix:semicolon
id|kick_open
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * erase&n;&t; */
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
id|pWritePtr
op_assign
l_int|0x20
suffix:semicolon
multiline_comment|/*&n;&t; * confirm&n;&t; */
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
id|pWritePtr
op_assign
l_int|0xD0
suffix:semicolon
multiline_comment|/*&n;&t; * wait 10 ms&n;&t; */
id|msleep
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * wait while erasing in process (up to 10 sec)&n;&t; */
id|timeout
op_assign
id|jiffies
op_plus
l_int|10
op_star
id|HZ
suffix:semicolon
id|c1
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|c1
op_amp
l_int|0x80
)paren
op_logical_and
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
id|msleep
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * read any address&n;&t;&t; */
id|c1
op_assign
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|pWritePtr
)paren
suffix:semicolon
singleline_comment|//              printk(&quot;Flash_erase: status=%X.&bslash;n&quot;,c1);
)brace
multiline_comment|/*&n;&t; * set flash for normal read access&n;&t; */
id|kick_open
c_func
(paren
)paren
suffix:semicolon
singleline_comment|//      *(volatile unsigned char*)(FLASH_BASE+0x8000) = 0xFF;
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
id|pWritePtr
op_assign
l_int|0xFF
suffix:semicolon
singleline_comment|//back to normal operation
multiline_comment|/*&n;&t; * check if erase errors were reported&n;&t; */
r_if
c_cond
(paren
id|c1
op_amp
l_int|0x20
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;flash_erase: err at %p&bslash;n&quot;
comma
id|pWritePtr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * reset error&n;&t;&t; */
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|FLASH_BASE
op_plus
l_int|0x8000
)paren
op_assign
l_int|0x50
suffix:semicolon
r_return
op_minus
l_int|2
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * just to make sure - verify if erased OK...&n;&t; */
id|msleep
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|pWritePtr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
(paren
r_int
r_int
)paren
(paren
id|FLASH_BASE
op_plus
(paren
id|nBlock
op_lshift
l_int|16
)paren
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|temp
op_assign
l_int|0
suffix:semicolon
id|temp
OL
l_int|16
op_star
l_int|1024
suffix:semicolon
id|temp
op_increment
comma
id|pWritePtr
op_add_assign
l_int|4
)paren
(brace
r_if
c_cond
(paren
(paren
id|temp1
op_assign
op_star
(paren
r_volatile
r_int
r_int
op_star
)paren
id|pWritePtr
)paren
op_ne
l_int|0xFFFFFFFF
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;flash_erase: verify err at %p = %X&bslash;n&quot;
comma
id|pWritePtr
comma
id|temp1
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * write_block will limit number of bytes written to the space in this block&n; */
DECL|function|write_block
r_static
r_int
id|write_block
c_func
(paren
r_int
r_int
id|p
comma
r_const
r_char
id|__user
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_volatile
r_int
r_int
id|c1
suffix:semicolon
r_volatile
r_int
r_int
id|c2
suffix:semicolon
r_int
r_char
op_star
id|pWritePtr
suffix:semicolon
r_int
r_int
id|uAddress
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
r_int
r_int
id|timeout1
suffix:semicolon
multiline_comment|/*&n;&t; * red LED == write&n;&t; */
id|leds_event
c_func
(paren
id|led_amber_off
)paren
suffix:semicolon
id|leds_event
c_func
(paren
id|led_red_on
)paren
suffix:semicolon
id|pWritePtr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
(paren
r_int
r_int
)paren
(paren
id|FLASH_BASE
op_plus
id|p
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * check if write will end in this block....&n;&t; */
id|offset
op_assign
id|p
op_amp
l_int|0xFFFF
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_plus
id|count
OG
l_int|0x10000
)paren
id|count
op_assign
l_int|0x10000
op_minus
id|offset
suffix:semicolon
multiline_comment|/*&n;&t; * wait up to 30 sec for this block&n;&t; */
id|timeout
op_assign
id|jiffies
op_plus
l_int|30
op_star
id|HZ
suffix:semicolon
r_for
c_loop
(paren
id|offset
op_assign
l_int|0
suffix:semicolon
id|offset
OL
id|count
suffix:semicolon
id|offset
op_increment
comma
id|pWritePtr
op_increment
)paren
(brace
id|uAddress
op_assign
(paren
r_int
r_int
)paren
id|pWritePtr
suffix:semicolon
id|uAddress
op_and_assign
l_int|0xFFFFFFFC
suffix:semicolon
r_if
c_cond
(paren
id|__get_user
c_func
(paren
id|c2
comma
id|buf
op_plus
id|offset
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|WriteRetry
suffix:colon
multiline_comment|/*&n;&t;  &t; * dummy read&n;&t;  &t; */
id|c1
op_assign
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|FLASH_BASE
op_plus
l_int|0x8000
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * kick open the write gate&n;&t;&t; */
id|kick_open
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * program footbridge to the correct offset...0..3&n;&t;&t; */
op_star
id|CSR_ROMWRITEREG
op_assign
(paren
r_int
r_int
)paren
id|pWritePtr
op_amp
l_int|3
suffix:semicolon
multiline_comment|/*&n;&t;&t; * write cmd&n;&t;&t; */
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|uAddress
)paren
op_assign
l_int|0x40
suffix:semicolon
multiline_comment|/*&n;&t;&t; * data to write&n;&t;&t; */
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|uAddress
)paren
op_assign
id|c2
suffix:semicolon
multiline_comment|/*&n;&t;&t; * get status&n;&t;&t; */
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|FLASH_BASE
op_plus
l_int|0x10000
)paren
op_assign
l_int|0x70
suffix:semicolon
id|c1
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * wait up to 1 sec for this byte&n;&t;&t; */
id|timeout1
op_assign
id|jiffies
op_plus
l_int|1
op_star
id|HZ
suffix:semicolon
multiline_comment|/*&n;&t;&t; * while not ready...&n;&t;&t; */
r_while
c_loop
(paren
op_logical_neg
(paren
id|c1
op_amp
l_int|0x80
)paren
op_logical_and
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout1
)paren
)paren
id|c1
op_assign
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|FLASH_BASE
op_plus
l_int|0x8000
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * if timeout getting status&n;&t;&t; */
r_if
c_cond
(paren
id|time_after_eq
c_func
(paren
id|jiffies
comma
id|timeout1
)paren
)paren
(brace
id|kick_open
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * reset err&n;&t;&t;&t; */
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|FLASH_BASE
op_plus
l_int|0x8000
)paren
op_assign
l_int|0x50
suffix:semicolon
r_goto
id|WriteRetry
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * switch on read access, as a default flash operation mode&n;&t;&t; */
id|kick_open
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * read access&n;&t;&t; */
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|FLASH_BASE
op_plus
l_int|0x8000
)paren
op_assign
l_int|0xFF
suffix:semicolon
multiline_comment|/*&n;&t;&t; * if hardware reports an error writing, and not timeout - &n;&t;&t; * reset the chip and retry&n;&t;&t; */
r_if
c_cond
(paren
id|c1
op_amp
l_int|0x10
)paren
(brace
id|kick_open
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * reset err&n;&t;&t;&t; */
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|FLASH_BASE
op_plus
l_int|0x8000
)paren
op_assign
l_int|0x50
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * before timeout?&n;&t;&t;&t; */
r_if
c_cond
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
r_if
c_cond
(paren
id|flashdebug
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;write_block: Retrying write at 0x%X)n&quot;
comma
id|pWritePtr
op_minus
id|FLASH_BASE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * no LED == waiting&n;&t;&t;&t;&t; */
id|leds_event
c_func
(paren
id|led_amber_off
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * wait couple ms&n;&t;&t;&t;&t; */
id|msleep
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * red LED == write&n;&t;&t;&t;&t; */
id|leds_event
c_func
(paren
id|led_red_on
)paren
suffix:semicolon
r_goto
id|WriteRetry
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;write_block: timeout at 0x%X&bslash;n&quot;
comma
id|pWritePtr
op_minus
id|FLASH_BASE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * return error -2&n;&t;&t;&t;&t; */
r_return
op_minus
l_int|2
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * green LED == read/verify&n;&t; */
id|leds_event
c_func
(paren
id|led_amber_off
)paren
suffix:semicolon
id|leds_event
c_func
(paren
id|led_green_on
)paren
suffix:semicolon
id|msleep
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|pWritePtr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
(paren
r_int
r_int
)paren
(paren
id|FLASH_BASE
op_plus
id|p
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|offset
op_assign
l_int|0
suffix:semicolon
id|offset
OL
id|count
suffix:semicolon
id|offset
op_increment
)paren
(brace
r_char
id|c
comma
id|c1
suffix:semicolon
r_if
c_cond
(paren
id|__get_user
c_func
(paren
id|c
comma
id|buf
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|buf
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|c1
op_assign
op_star
id|pWritePtr
op_increment
)paren
op_ne
id|c
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;write_block: verify error at 0x%X (%02X!=%02X)&bslash;n&quot;
comma
id|pWritePtr
op_minus
id|FLASH_BASE
comma
id|c1
comma
id|c
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
id|count
suffix:semicolon
)brace
DECL|function|kick_open
r_static
r_void
id|kick_open
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * we want to write a bit pattern XXX1 to Xilinx to enable&n;&t; * the write gate, which will be open for about the next 2ms.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|gpio_lock
comma
id|flags
)paren
suffix:semicolon
id|cpld_modify
c_func
(paren
l_int|1
comma
l_int|1
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|gpio_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * let the ISA bus to catch on...&n;&t; */
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
)brace
DECL|variable|flash_fops
r_static
r_struct
id|file_operations
id|flash_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|llseek
op_assign
id|flash_llseek
comma
dot
id|read
op_assign
id|flash_read
comma
dot
id|write
op_assign
id|flash_write
comma
dot
id|ioctl
op_assign
id|flash_ioctl
comma
)brace
suffix:semicolon
DECL|variable|flash_miscdev
r_static
r_struct
id|miscdevice
id|flash_miscdev
op_assign
(brace
id|FLASH_MINOR
comma
l_string|&quot;nwflash&quot;
comma
op_amp
id|flash_fops
)brace
suffix:semicolon
DECL|function|nwflash_init
r_static
r_int
id|__init
id|nwflash_init
c_func
(paren
r_void
)paren
(brace
r_int
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|machine_is_netwinder
c_func
(paren
)paren
)paren
(brace
r_int
id|id
suffix:semicolon
id|FLASH_BASE
op_assign
id|ioremap
c_func
(paren
id|DC21285_FLASH
comma
id|KFLASH_SIZE4
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|FLASH_BASE
)paren
r_goto
id|out
suffix:semicolon
id|id
op_assign
id|get_flash_id
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id
op_ne
id|KFLASH_ID
)paren
op_logical_and
(paren
id|id
op_ne
id|KFLASH_ID4
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|ENXIO
suffix:semicolon
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|FLASH_BASE
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Flash: incorrect ID 0x%04X.&bslash;n&quot;
comma
id|id
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Flash ROM driver v.%s, flash device ID 0x%04X, size %d Mb.&bslash;n&quot;
comma
id|NWFLASH_VERSION
comma
id|id
comma
id|gbFlashSize
op_div
(paren
l_int|1024
op_star
l_int|1024
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|misc_register
c_func
(paren
op_amp
id|flash_miscdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|FLASH_BASE
)paren
suffix:semicolon
)brace
)brace
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|nwflash_exit
r_static
r_void
id|__exit
id|nwflash_exit
c_func
(paren
r_void
)paren
(brace
id|misc_deregister
c_func
(paren
op_amp
id|flash_miscdev
)paren
suffix:semicolon
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|FLASH_BASE
)paren
suffix:semicolon
)brace
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|flashdebug
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|variable|nwflash_init
id|module_init
c_func
(paren
id|nwflash_init
)paren
suffix:semicolon
DECL|variable|nwflash_exit
id|module_exit
c_func
(paren
id|nwflash_exit
)paren
suffix:semicolon
eof
