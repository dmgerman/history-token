multiline_comment|/*&n; * Generic parallel printer driver&n; *&n; * Copyright (C) 1992 by Jim Weigand and Linus Torvalds&n; * Copyright (C) 1992,1993 by Michael K. Johnson&n; * - Thanks much to Gunter Windau for pointing out to me where the error&n; *   checking ought to be.&n; * Copyright (C) 1993 by Nigel Gamble (added interrupt code)&n; * Copyright (C) 1994 by Alan Cox (Modularised it)&n; * LPCAREFUL, LPABORT, LPGETSTATUS added by Chris Metcalf, metcalf@lcs.mit.edu&n; * Statistics and support for slow printers by Rob Janssen, rob@knoware.nl&n; * &quot;lp=&quot; command line parameters added by Grant Guenther, grant@torque.net&n; * lp_read (Status readback) support added by Carsten Gross,&n; *                                             carsten@sol.wohnheim.uni-ulm.de&n; * Support for parport by Philip Blundell &lt;Philip.Blundell@pobox.com&gt;&n; * Parport sharing hacking by Andrea Arcangeli&n; * Fixed kernel_(to/from)_user memory copy to check for errors&n; * &t;&t;&t;&t;by Riccardo Facchetti &lt;fizban@tin.it&gt;&n; * 22-JAN-1998  Added support for devfs  Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n; * Redesigned interrupt handling for handle printers with buggy handshake&n; *&t;&t;&t;&t;by Andrea Arcangeli, 11 May 1998&n; * Full efficient handling of printer with buggy irq handshake (now I have&n; * understood the meaning of the strange handshake). This is done sending new&n; * characters if the interrupt is just happened, even if the printer say to&n; * be still BUSY. This is needed at least with Epson Stylus Color. To enable&n; * the new TRUST_IRQ mode read the `LP OPTIMIZATION&squot; section below...&n; * Fixed the irq on the rising edge of the strobe case.&n; * Obsoleted the CAREFUL flag since a printer that doesn&squot; t work with&n; * CAREFUL will block a bit after in lp_check_status().&n; *&t;&t;&t;&t;Andrea Arcangeli, 15 Oct 1998&n; * Obsoleted and removed all the lowlevel stuff implemented in the last&n; * month to use the IEEE1284 functions (that handle the _new_ compatibilty&n; * mode fine).&n; */
multiline_comment|/* This driver should, in theory, work with any parallel port that has an&n; * appropriate low-level driver; all I/O is done through the parport&n; * abstraction layer.&n; *&n; * If this driver is built into the kernel, you can configure it using the&n; * kernel command-line.  For example:&n; *&n; *&t;lp=parport1,none,parport2&t;(bind lp0 to parport1, disable lp1 and&n; *&t;&t;&t;&t;&t; bind lp2 to parport2)&n; *&n; *&t;lp=auto&t;&t;&t;&t;(assign lp devices to all ports that&n; *&t;&t;&t;&t;         have printers attached, as determined&n; *&t;&t;&t;&t;&t; by the IEEE-1284 autoprobe)&n; * &n; *&t;lp=reset&t;&t;&t;(reset the printer during &n; *&t;&t;&t;&t;&t; initialisation)&n; *&n; *&t;lp=off&t;&t;&t;&t;(disable the printer driver entirely)&n; *&n; * If the driver is loaded as a module, similar functionality is available&n; * using module parameters.  The equivalent of the above commands would be:&n; *&n; *&t;# insmod lp.o parport=1,none,2&n; *&n; *&t;# insmod lp.o parport=auto&n; *&n; *&t;# insmod lp.o reset=1&n; */
multiline_comment|/* COMPATIBILITY WITH OLD KERNELS&n; *&n; * Under Linux 2.0 and previous versions, lp devices were bound to ports at&n; * particular I/O addresses, as follows:&n; *&n; *&t;lp0&t;&t;0x3bc&n; *&t;lp1&t;&t;0x378&n; *&t;lp2&t;&t;0x278&n; *&n; * The new driver, by default, binds lp devices to parport devices as it&n; * finds them.  This means that if you only have one port, it will be bound&n; * to lp0 regardless of its I/O address.  If you need the old behaviour, you&n; * can force it using the parameters described above.&n; */
multiline_comment|/*&n; * The new interrupt handling code take care of the buggy handshake&n; * of some HP and Epson printer:&n; * ___&n; * ACK    _______________    ___________&n; *                       |__|&n; * ____&n; * BUSY   _________              _______&n; *                 |____________|&n; *&n; * I discovered this using the printer scanner that you can find at:&n; *&n; *&t;ftp://e-mind.com/pub/linux/pscan/&n; *&n; *&t;&t;&t;&t;&t;11 May 98, Andrea Arcangeli&n; *&n; * My printer scanner run on an Epson Stylus Color show that such printer&n; * generates the irq on the _rising_ edge of the STROBE. Now lp handle&n; * this case fine too.&n; *&n; *&t;&t;&t;&t;&t;15 Oct 1998, Andrea Arcangeli&n; *&n; * The so called `buggy&squot; handshake is really the well documented&n; * compatibility mode IEEE1284 handshake. They changed the well known&n; * Centronics handshake acking in the middle of busy expecting to not&n; * break drivers or legacy application, while they broken linux lp&n; * until I fixed it reverse engineering the protocol by hand some&n; * month ago...&n; *&n; *                                     14 Dec 1998, Andrea Arcangeli&n; *&n; * Copyright (C) 2000 by Tim Waugh (added LPSETTIMEOUT ioctl)&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/console.h&gt;
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/parport.h&gt;
DECL|macro|LP_STATS
macro_line|#undef LP_STATS
macro_line|#include &lt;linux/lp.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
multiline_comment|/* if you have more than 8 printers, remember to increase LP_NO */
DECL|macro|LP_NO
mdefine_line|#define LP_NO 8
multiline_comment|/* ROUND_UP macro from fs/select.c */
DECL|macro|ROUND_UP
mdefine_line|#define ROUND_UP(x,y) (((x)+(y)-1)/(y))
DECL|variable|lp_table
r_static
r_struct
id|lp_struct
id|lp_table
(braket
id|LP_NO
)braket
suffix:semicolon
DECL|variable|lp_count
r_static
r_int
r_int
id|lp_count
op_assign
l_int|0
suffix:semicolon
DECL|variable|lp_class
r_static
r_struct
id|class_simple
op_star
id|lp_class
suffix:semicolon
macro_line|#ifdef CONFIG_LP_CONSOLE
DECL|variable|console_registered
r_static
r_struct
id|parport
op_star
id|console_registered
suffix:semicolon
singleline_comment|// initially NULL
macro_line|#endif /* CONFIG_LP_CONSOLE */
DECL|macro|LP_DEBUG
macro_line|#undef LP_DEBUG
multiline_comment|/* Bits used to manage claiming the parport device */
DECL|macro|LP_PREEMPT_REQUEST
mdefine_line|#define LP_PREEMPT_REQUEST 1
DECL|macro|LP_PARPORT_CLAIMED
mdefine_line|#define LP_PARPORT_CLAIMED 2
multiline_comment|/* --- low-level port access ----------------------------------- */
DECL|macro|r_dtr
mdefine_line|#define r_dtr(x)&t;(parport_read_data(lp_table[(x)].dev-&gt;port))
DECL|macro|r_str
mdefine_line|#define r_str(x)&t;(parport_read_status(lp_table[(x)].dev-&gt;port))
DECL|macro|w_ctr
mdefine_line|#define w_ctr(x,y)&t;do { parport_write_control(lp_table[(x)].dev-&gt;port, (y)); } while (0)
DECL|macro|w_dtr
mdefine_line|#define w_dtr(x,y)&t;do { parport_write_data(lp_table[(x)].dev-&gt;port, (y)); } while (0)
multiline_comment|/* Claim the parport or block trying unless we&squot;ve already claimed it */
DECL|function|lp_claim_parport_or_block
r_static
r_void
id|lp_claim_parport_or_block
c_func
(paren
r_struct
id|lp_struct
op_star
id|this_lp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
id|LP_PARPORT_CLAIMED
comma
op_amp
id|this_lp-&gt;bits
)paren
)paren
(brace
id|parport_claim_or_block
(paren
id|this_lp-&gt;dev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Claim the parport or block trying unless we&squot;ve already claimed it */
DECL|function|lp_release_parport
r_static
r_void
id|lp_release_parport
c_func
(paren
r_struct
id|lp_struct
op_star
id|this_lp
)paren
(brace
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|LP_PARPORT_CLAIMED
comma
op_amp
id|this_lp-&gt;bits
)paren
)paren
(brace
id|parport_release
(paren
id|this_lp-&gt;dev
)paren
suffix:semicolon
)brace
)brace
DECL|function|lp_preempt
r_static
r_int
id|lp_preempt
c_func
(paren
r_void
op_star
id|handle
)paren
(brace
r_struct
id|lp_struct
op_star
id|this_lp
op_assign
(paren
r_struct
id|lp_struct
op_star
)paren
id|handle
suffix:semicolon
id|set_bit
c_func
(paren
id|LP_PREEMPT_REQUEST
comma
op_amp
id|this_lp-&gt;bits
)paren
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Try to negotiate to a new mode; if unsuccessful negotiate to&n; * compatibility mode.  Return the mode we ended up in.&n; */
DECL|function|lp_negotiate
r_static
r_int
id|lp_negotiate
c_func
(paren
r_struct
id|parport
op_star
id|port
comma
r_int
id|mode
)paren
(brace
r_if
c_cond
(paren
id|parport_negotiate
(paren
id|port
comma
id|mode
)paren
op_ne
l_int|0
)paren
(brace
id|mode
op_assign
id|IEEE1284_MODE_COMPAT
suffix:semicolon
id|parport_negotiate
(paren
id|port
comma
id|mode
)paren
suffix:semicolon
)brace
r_return
(paren
id|mode
)paren
suffix:semicolon
)brace
DECL|function|lp_reset
r_static
r_int
id|lp_reset
c_func
(paren
r_int
id|minor
)paren
(brace
r_int
id|retval
suffix:semicolon
id|lp_claim_parport_or_block
(paren
op_amp
id|lp_table
(braket
id|minor
)braket
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|minor
comma
id|LP_PSELECP
)paren
suffix:semicolon
id|udelay
(paren
id|LP_DELAY
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|minor
comma
id|LP_PSELECP
op_or
id|LP_PINITP
)paren
suffix:semicolon
id|retval
op_assign
id|r_str
c_func
(paren
id|minor
)paren
suffix:semicolon
id|lp_release_parport
(paren
op_amp
id|lp_table
(braket
id|minor
)braket
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|lp_error
r_static
r_void
id|lp_error
(paren
r_int
id|minor
)paren
(brace
r_int
id|polling
suffix:semicolon
r_if
c_cond
(paren
id|LP_F
c_func
(paren
id|minor
)paren
op_amp
id|LP_ABORT
)paren
r_return
suffix:semicolon
id|polling
op_assign
id|lp_table
(braket
id|minor
)braket
dot
id|dev-&gt;port-&gt;irq
op_eq
id|PARPORT_IRQ_NONE
suffix:semicolon
r_if
c_cond
(paren
id|polling
)paren
id|lp_release_parport
(paren
op_amp
id|lp_table
(braket
id|minor
)braket
)paren
suffix:semicolon
id|interruptible_sleep_on_timeout
(paren
op_amp
id|lp_table
(braket
id|minor
)braket
dot
id|waitq
comma
id|LP_TIMEOUT_POLLED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|polling
)paren
id|lp_claim_parport_or_block
(paren
op_amp
id|lp_table
(braket
id|minor
)braket
)paren
suffix:semicolon
r_else
id|parport_yield_blocking
(paren
id|lp_table
(braket
id|minor
)braket
dot
id|dev
)paren
suffix:semicolon
)brace
DECL|function|lp_check_status
r_static
r_int
id|lp_check_status
c_func
(paren
r_int
id|minor
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|last
op_assign
id|lp_table
(braket
id|minor
)braket
dot
id|last_error
suffix:semicolon
r_int
r_char
id|status
op_assign
id|r_str
c_func
(paren
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
id|LP_PERRORP
)paren
op_logical_and
op_logical_neg
(paren
id|LP_F
c_func
(paren
id|minor
)paren
op_amp
id|LP_CAREFUL
)paren
)paren
multiline_comment|/* No error. */
id|last
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|status
op_amp
id|LP_POUTPA
)paren
)paren
(brace
r_if
c_cond
(paren
id|last
op_ne
id|LP_POUTPA
)paren
(brace
id|last
op_assign
id|LP_POUTPA
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;lp%d out of paper&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
)brace
id|error
op_assign
op_minus
id|ENOSPC
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|LP_PSELECD
)paren
)paren
(brace
r_if
c_cond
(paren
id|last
op_ne
id|LP_PSELECD
)paren
(brace
id|last
op_assign
id|LP_PSELECD
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;lp%d off-line&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
)brace
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|LP_PERRORP
)paren
)paren
(brace
r_if
c_cond
(paren
id|last
op_ne
id|LP_PERRORP
)paren
(brace
id|last
op_assign
id|LP_PERRORP
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;lp%d on fire&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
)brace
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
id|last
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Come here if LP_CAREFUL is set and no&n;                             errors are reported. */
)brace
id|lp_table
(braket
id|minor
)braket
dot
id|last_error
op_assign
id|last
suffix:semicolon
r_if
c_cond
(paren
id|last
op_ne
l_int|0
)paren
id|lp_error
c_func
(paren
id|minor
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|lp_wait_ready
r_static
r_int
id|lp_wait_ready
c_func
(paren
r_int
id|minor
comma
r_int
id|nonblock
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If we&squot;re not in compatibility mode, we&squot;re ready now! */
r_if
c_cond
(paren
id|lp_table
(braket
id|minor
)braket
dot
id|current_mode
op_ne
id|IEEE1284_MODE_COMPAT
)paren
(brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_do
(brace
id|error
op_assign
id|lp_check_status
(paren
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_logical_and
(paren
id|nonblock
op_logical_or
(paren
id|LP_F
c_func
(paren
id|minor
)paren
op_amp
id|LP_ABORT
)paren
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
(paren
id|current
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EINTR
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|error
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|lp_write
r_static
id|ssize_t
id|lp_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
id|__user
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_int
r_int
id|minor
op_assign
id|iminor
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode
)paren
suffix:semicolon
r_struct
id|parport
op_star
id|port
op_assign
id|lp_table
(braket
id|minor
)braket
dot
id|dev-&gt;port
suffix:semicolon
r_char
op_star
id|kbuf
op_assign
id|lp_table
(braket
id|minor
)braket
dot
id|lp_buffer
suffix:semicolon
id|ssize_t
id|retv
op_assign
l_int|0
suffix:semicolon
id|ssize_t
id|written
suffix:semicolon
r_int
id|copy_size
op_assign
id|count
suffix:semicolon
r_int
id|nonblock
op_assign
(paren
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
op_logical_or
(paren
id|LP_F
c_func
(paren
id|minor
)paren
op_amp
id|LP_ABORT
)paren
)paren
suffix:semicolon
macro_line|#ifdef LP_STATS
r_if
c_cond
(paren
id|jiffies
op_minus
id|lp_table
(braket
id|minor
)braket
dot
id|lastcall
OG
id|LP_TIME
c_func
(paren
id|minor
)paren
)paren
id|lp_table
(braket
id|minor
)braket
dot
id|runchars
op_assign
l_int|0
suffix:semicolon
id|lp_table
(braket
id|minor
)braket
dot
id|lastcall
op_assign
id|jiffies
suffix:semicolon
macro_line|#endif
multiline_comment|/* Need to copy the data from user-space. */
r_if
c_cond
(paren
id|copy_size
OG
id|LP_BUFFER_SIZE
)paren
id|copy_size
op_assign
id|LP_BUFFER_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
id|kbuf
comma
id|buf
comma
id|copy_size
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|down_interruptible
(paren
op_amp
id|lp_table
(braket
id|minor
)braket
dot
id|port_mutex
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
multiline_comment|/* Claim Parport or sleep until it becomes available&n; &t; */
id|lp_claim_parport_or_block
(paren
op_amp
id|lp_table
(braket
id|minor
)braket
)paren
suffix:semicolon
multiline_comment|/* Go to the proper mode. */
id|lp_table
(braket
id|minor
)braket
dot
id|current_mode
op_assign
id|lp_negotiate
(paren
id|port
comma
id|lp_table
(braket
id|minor
)braket
dot
id|best_mode
)paren
suffix:semicolon
id|parport_set_timeout
(paren
id|lp_table
(braket
id|minor
)braket
dot
id|dev
comma
(paren
id|nonblock
ques
c_cond
id|PARPORT_INACTIVITY_O_NONBLOCK
suffix:colon
id|lp_table
(braket
id|minor
)braket
dot
id|timeout
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|retv
op_assign
id|lp_wait_ready
(paren
id|minor
comma
id|nonblock
)paren
)paren
op_eq
l_int|0
)paren
r_do
(brace
multiline_comment|/* Write the data. */
id|written
op_assign
id|parport_write
(paren
id|port
comma
id|kbuf
comma
id|copy_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|written
OG
l_int|0
)paren
(brace
id|copy_size
op_sub_assign
id|written
suffix:semicolon
id|count
op_sub_assign
id|written
suffix:semicolon
id|buf
op_add_assign
id|written
suffix:semicolon
id|retv
op_add_assign
id|written
suffix:semicolon
)brace
r_if
c_cond
(paren
id|signal_pending
(paren
id|current
)paren
)paren
(brace
r_if
c_cond
(paren
id|retv
op_eq
l_int|0
)paren
id|retv
op_assign
op_minus
id|EINTR
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_size
OG
l_int|0
)paren
(brace
multiline_comment|/* incomplete write -&gt; check error ! */
r_int
id|error
suffix:semicolon
id|parport_negotiate
(paren
id|lp_table
(braket
id|minor
)braket
dot
id|dev-&gt;port
comma
id|IEEE1284_MODE_COMPAT
)paren
suffix:semicolon
id|lp_table
(braket
id|minor
)braket
dot
id|current_mode
op_assign
id|IEEE1284_MODE_COMPAT
suffix:semicolon
id|error
op_assign
id|lp_wait_ready
(paren
id|minor
comma
id|nonblock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
id|retv
op_eq
l_int|0
)paren
id|retv
op_assign
id|error
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|nonblock
)paren
(brace
r_if
c_cond
(paren
id|retv
op_eq
l_int|0
)paren
id|retv
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_break
suffix:semicolon
)brace
id|parport_yield_blocking
(paren
id|lp_table
(braket
id|minor
)braket
dot
id|dev
)paren
suffix:semicolon
id|lp_table
(braket
id|minor
)braket
dot
id|current_mode
op_assign
id|lp_negotiate
(paren
id|port
comma
id|lp_table
(braket
id|minor
)braket
dot
id|best_mode
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|need_resched
c_func
(paren
)paren
)paren
id|schedule
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
(brace
id|copy_size
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|copy_size
OG
id|LP_BUFFER_SIZE
)paren
id|copy_size
op_assign
id|LP_BUFFER_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|kbuf
comma
id|buf
comma
id|copy_size
)paren
)paren
(brace
r_if
c_cond
(paren
id|retv
op_eq
l_int|0
)paren
id|retv
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|LP_PREEMPT_REQUEST
comma
op_amp
id|lp_table
(braket
id|minor
)braket
dot
id|bits
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;lp%d releasing parport&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
id|parport_negotiate
(paren
id|lp_table
(braket
id|minor
)braket
dot
id|dev-&gt;port
comma
id|IEEE1284_MODE_COMPAT
)paren
suffix:semicolon
id|lp_table
(braket
id|minor
)braket
dot
id|current_mode
op_assign
id|IEEE1284_MODE_COMPAT
suffix:semicolon
id|lp_release_parport
(paren
op_amp
id|lp_table
(braket
id|minor
)braket
)paren
suffix:semicolon
)brace
id|up
(paren
op_amp
id|lp_table
(braket
id|minor
)braket
dot
id|port_mutex
)paren
suffix:semicolon
r_return
id|retv
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PARPORT_1284
multiline_comment|/* Status readback conforming to ieee1284 */
DECL|function|lp_read
r_static
id|ssize_t
id|lp_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
id|__user
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_int
r_int
id|minor
op_assign
id|iminor
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode
)paren
suffix:semicolon
r_struct
id|parport
op_star
id|port
op_assign
id|lp_table
(braket
id|minor
)braket
dot
id|dev-&gt;port
suffix:semicolon
id|ssize_t
id|retval
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|kbuf
op_assign
id|lp_table
(braket
id|minor
)braket
dot
id|lp_buffer
suffix:semicolon
r_int
id|nonblock
op_assign
(paren
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
op_logical_or
(paren
id|LP_F
c_func
(paren
id|minor
)paren
op_amp
id|LP_ABORT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
id|LP_BUFFER_SIZE
)paren
id|count
op_assign
id|LP_BUFFER_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|down_interruptible
(paren
op_amp
id|lp_table
(braket
id|minor
)braket
dot
id|port_mutex
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
id|lp_claim_parport_or_block
(paren
op_amp
id|lp_table
(braket
id|minor
)braket
)paren
suffix:semicolon
id|parport_set_timeout
(paren
id|lp_table
(braket
id|minor
)braket
dot
id|dev
comma
(paren
id|nonblock
ques
c_cond
id|PARPORT_INACTIVITY_O_NONBLOCK
suffix:colon
id|lp_table
(braket
id|minor
)braket
dot
id|timeout
)paren
)paren
suffix:semicolon
id|parport_negotiate
(paren
id|lp_table
(braket
id|minor
)braket
dot
id|dev-&gt;port
comma
id|IEEE1284_MODE_COMPAT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parport_negotiate
(paren
id|lp_table
(braket
id|minor
)braket
dot
id|dev-&gt;port
comma
id|IEEE1284_MODE_NIBBLE
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_while
c_loop
(paren
id|retval
op_eq
l_int|0
)paren
(brace
id|retval
op_assign
id|parport_read
(paren
id|port
comma
id|kbuf
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OG
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|nonblock
)paren
(brace
id|retval
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Wait for data. */
r_if
c_cond
(paren
id|lp_table
(braket
id|minor
)braket
dot
id|dev-&gt;port-&gt;irq
op_eq
id|PARPORT_IRQ_NONE
)paren
(brace
id|parport_negotiate
(paren
id|lp_table
(braket
id|minor
)braket
dot
id|dev-&gt;port
comma
id|IEEE1284_MODE_COMPAT
)paren
suffix:semicolon
id|lp_error
(paren
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parport_negotiate
(paren
id|lp_table
(braket
id|minor
)braket
dot
id|dev-&gt;port
comma
id|IEEE1284_MODE_NIBBLE
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
r_else
id|interruptible_sleep_on_timeout
(paren
op_amp
id|lp_table
(braket
id|minor
)braket
dot
id|waitq
comma
id|LP_TIMEOUT_POLLED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
(paren
id|current
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
id|cond_resched
(paren
)paren
suffix:semicolon
)brace
id|parport_negotiate
(paren
id|lp_table
(braket
id|minor
)braket
dot
id|dev-&gt;port
comma
id|IEEE1284_MODE_COMPAT
)paren
suffix:semicolon
id|out
suffix:colon
id|lp_release_parport
(paren
op_amp
id|lp_table
(braket
id|minor
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OG
l_int|0
op_logical_and
id|copy_to_user
(paren
id|buf
comma
id|kbuf
comma
id|retval
)paren
)paren
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|up
(paren
op_amp
id|lp_table
(braket
id|minor
)braket
dot
id|port_mutex
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
macro_line|#endif /* IEEE 1284 support */
DECL|function|lp_open
r_static
r_int
id|lp_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
r_int
id|minor
op_assign
id|iminor
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_ge
id|LP_NO
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
(paren
id|LP_F
c_func
(paren
id|minor
)paren
op_amp
id|LP_EXIST
)paren
op_eq
l_int|0
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
id|LP_BUSY_BIT_POS
comma
op_amp
id|LP_F
c_func
(paren
id|minor
)paren
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/* If ABORTOPEN is set and the printer is offline or out of paper,&n;&t;   we may still want to open it to perform ioctl()s.  Therefore we&n;&t;   have commandeered O_NONBLOCK, even though it is being used in&n;&t;   a non-standard manner.  This is strictly a Linux hack, and&n;&t;   should most likely only ever be used by the tunelp application. */
r_if
c_cond
(paren
(paren
id|LP_F
c_func
(paren
id|minor
)paren
op_amp
id|LP_ABORTOPEN
)paren
op_logical_and
op_logical_neg
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
)paren
(brace
r_int
id|status
suffix:semicolon
id|lp_claim_parport_or_block
(paren
op_amp
id|lp_table
(braket
id|minor
)braket
)paren
suffix:semicolon
id|status
op_assign
id|r_str
c_func
(paren
id|minor
)paren
suffix:semicolon
id|lp_release_parport
(paren
op_amp
id|lp_table
(braket
id|minor
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|LP_POUTPA
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;lp%d out of paper&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
id|LP_F
c_func
(paren
id|minor
)paren
op_and_assign
op_complement
id|LP_BUSY
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|LP_PSELECD
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;lp%d off-line&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
id|LP_F
c_func
(paren
id|minor
)paren
op_and_assign
op_complement
id|LP_BUSY
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|LP_PERRORP
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;lp%d printer error&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
id|LP_F
c_func
(paren
id|minor
)paren
op_and_assign
op_complement
id|LP_BUSY
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
id|lp_table
(braket
id|minor
)braket
dot
id|lp_buffer
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|LP_BUFFER_SIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp_table
(braket
id|minor
)braket
dot
id|lp_buffer
)paren
(brace
id|LP_F
c_func
(paren
id|minor
)paren
op_and_assign
op_complement
id|LP_BUSY
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Determine if the peripheral supports ECP mode */
id|lp_claim_parport_or_block
(paren
op_amp
id|lp_table
(braket
id|minor
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lp_table
(braket
id|minor
)braket
dot
id|dev-&gt;port-&gt;modes
op_amp
id|PARPORT_MODE_ECP
)paren
op_logical_and
op_logical_neg
id|parport_negotiate
(paren
id|lp_table
(braket
id|minor
)braket
dot
id|dev-&gt;port
comma
id|IEEE1284_MODE_ECP
)paren
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;lp%d: ECP mode&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
id|lp_table
(braket
id|minor
)braket
dot
id|best_mode
op_assign
id|IEEE1284_MODE_ECP
suffix:semicolon
)brace
r_else
(brace
id|lp_table
(braket
id|minor
)braket
dot
id|best_mode
op_assign
id|IEEE1284_MODE_COMPAT
suffix:semicolon
)brace
multiline_comment|/* Leave peripheral in compatibility mode */
id|parport_negotiate
(paren
id|lp_table
(braket
id|minor
)braket
dot
id|dev-&gt;port
comma
id|IEEE1284_MODE_COMPAT
)paren
suffix:semicolon
id|lp_release_parport
(paren
op_amp
id|lp_table
(braket
id|minor
)braket
)paren
suffix:semicolon
id|lp_table
(braket
id|minor
)braket
dot
id|current_mode
op_assign
id|IEEE1284_MODE_COMPAT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|lp_release
r_static
r_int
id|lp_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
r_int
id|minor
op_assign
id|iminor
c_func
(paren
id|inode
)paren
suffix:semicolon
id|lp_claim_parport_or_block
(paren
op_amp
id|lp_table
(braket
id|minor
)braket
)paren
suffix:semicolon
id|parport_negotiate
(paren
id|lp_table
(braket
id|minor
)braket
dot
id|dev-&gt;port
comma
id|IEEE1284_MODE_COMPAT
)paren
suffix:semicolon
id|lp_table
(braket
id|minor
)braket
dot
id|current_mode
op_assign
id|IEEE1284_MODE_COMPAT
suffix:semicolon
id|lp_release_parport
(paren
op_amp
id|lp_table
(braket
id|minor
)braket
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|lp_table
(braket
id|minor
)braket
dot
id|lp_buffer
)paren
suffix:semicolon
id|lp_table
(braket
id|minor
)braket
dot
id|lp_buffer
op_assign
l_int|NULL
suffix:semicolon
id|LP_F
c_func
(paren
id|minor
)paren
op_and_assign
op_complement
id|LP_BUSY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|lp_ioctl
r_static
r_int
id|lp_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
r_int
id|minor
op_assign
id|iminor
c_func
(paren
id|inode
)paren
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_void
id|__user
op_star
id|argp
op_assign
(paren
r_void
id|__user
op_star
)paren
id|arg
suffix:semicolon
macro_line|#ifdef LP_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;lp%d ioctl, cmd: 0x%x, arg: 0x%lx&bslash;n&quot;
comma
id|minor
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|minor
op_ge
id|LP_NO
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
(paren
id|LP_F
c_func
(paren
id|minor
)paren
op_amp
id|LP_EXIST
)paren
op_eq
l_int|0
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_struct
id|timeval
id|par_timeout
suffix:semicolon
r_int
id|to_jiffies
suffix:semicolon
r_case
id|LPTIME
suffix:colon
id|LP_TIME
c_func
(paren
id|minor
)paren
op_assign
id|arg
op_star
id|HZ
op_div
l_int|100
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LPCHAR
suffix:colon
id|LP_CHAR
c_func
(paren
id|minor
)paren
op_assign
id|arg
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LPABORT
suffix:colon
r_if
c_cond
(paren
id|arg
)paren
id|LP_F
c_func
(paren
id|minor
)paren
op_or_assign
id|LP_ABORT
suffix:semicolon
r_else
id|LP_F
c_func
(paren
id|minor
)paren
op_and_assign
op_complement
id|LP_ABORT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LPABORTOPEN
suffix:colon
r_if
c_cond
(paren
id|arg
)paren
id|LP_F
c_func
(paren
id|minor
)paren
op_or_assign
id|LP_ABORTOPEN
suffix:semicolon
r_else
id|LP_F
c_func
(paren
id|minor
)paren
op_and_assign
op_complement
id|LP_ABORTOPEN
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LPCAREFUL
suffix:colon
r_if
c_cond
(paren
id|arg
)paren
id|LP_F
c_func
(paren
id|minor
)paren
op_or_assign
id|LP_CAREFUL
suffix:semicolon
r_else
id|LP_F
c_func
(paren
id|minor
)paren
op_and_assign
op_complement
id|LP_CAREFUL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LPWAIT
suffix:colon
id|LP_WAIT
c_func
(paren
id|minor
)paren
op_assign
id|arg
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LPSETIRQ
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LPGETIRQ
suffix:colon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|argp
comma
op_amp
id|LP_IRQ
c_func
(paren
id|minor
)paren
comma
r_sizeof
(paren
r_int
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LPGETSTATUS
suffix:colon
id|lp_claim_parport_or_block
(paren
op_amp
id|lp_table
(braket
id|minor
)braket
)paren
suffix:semicolon
id|status
op_assign
id|r_str
c_func
(paren
id|minor
)paren
suffix:semicolon
id|lp_release_parport
(paren
op_amp
id|lp_table
(braket
id|minor
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|argp
comma
op_amp
id|status
comma
r_sizeof
(paren
r_int
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LPRESET
suffix:colon
id|lp_reset
c_func
(paren
id|minor
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef LP_STATS
r_case
id|LPGETSTATS
suffix:colon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|argp
comma
op_amp
id|LP_STAT
c_func
(paren
id|minor
)paren
comma
r_sizeof
(paren
r_struct
id|lp_stats
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
id|memset
c_func
(paren
op_amp
id|LP_STAT
c_func
(paren
id|minor
)paren
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|lp_stats
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_case
id|LPGETFLAGS
suffix:colon
id|status
op_assign
id|LP_F
c_func
(paren
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|argp
comma
op_amp
id|status
comma
r_sizeof
(paren
r_int
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LPSETTIMEOUT
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|par_timeout
comma
id|argp
comma
r_sizeof
(paren
r_struct
id|timeval
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/* Convert to jiffies, place in lp_table */
r_if
c_cond
(paren
(paren
id|par_timeout.tv_sec
OL
l_int|0
)paren
op_logical_or
(paren
id|par_timeout.tv_usec
OL
l_int|0
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|to_jiffies
op_assign
id|ROUND_UP
c_func
(paren
id|par_timeout.tv_usec
comma
l_int|1000000
op_div
id|HZ
)paren
suffix:semicolon
id|to_jiffies
op_add_assign
id|par_timeout.tv_sec
op_star
(paren
r_int
)paren
id|HZ
suffix:semicolon
r_if
c_cond
(paren
id|to_jiffies
op_le
l_int|0
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|lp_table
(braket
id|minor
)braket
dot
id|timeout
op_assign
id|to_jiffies
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|lp_fops
r_static
r_struct
id|file_operations
id|lp_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|write
op_assign
id|lp_write
comma
dot
id|ioctl
op_assign
id|lp_ioctl
comma
dot
id|open
op_assign
id|lp_open
comma
dot
id|release
op_assign
id|lp_release
comma
macro_line|#ifdef CONFIG_PARPORT_1284
dot
id|read
op_assign
id|lp_read
comma
macro_line|#endif
)brace
suffix:semicolon
multiline_comment|/* --- support for console on the line printer ----------------- */
macro_line|#ifdef CONFIG_LP_CONSOLE
DECL|macro|CONSOLE_LP
mdefine_line|#define CONSOLE_LP 0
multiline_comment|/* If the printer is out of paper, we can either lose the messages or&n; * stall until the printer is happy again.  Define CONSOLE_LP_STRICT&n; * non-zero to get the latter behaviour. */
DECL|macro|CONSOLE_LP_STRICT
mdefine_line|#define CONSOLE_LP_STRICT 1
multiline_comment|/* The console must be locked when we get here. */
DECL|function|lp_console_write
r_static
r_void
id|lp_console_write
(paren
r_struct
id|console
op_star
id|co
comma
r_const
r_char
op_star
id|s
comma
r_int
id|count
)paren
(brace
r_struct
id|pardevice
op_star
id|dev
op_assign
id|lp_table
(braket
id|CONSOLE_LP
)braket
dot
id|dev
suffix:semicolon
r_struct
id|parport
op_star
id|port
op_assign
id|dev-&gt;port
suffix:semicolon
id|ssize_t
id|written
suffix:semicolon
r_if
c_cond
(paren
id|parport_claim
(paren
id|dev
)paren
)paren
multiline_comment|/* Nothing we can do. */
r_return
suffix:semicolon
id|parport_set_timeout
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Go to compatibility mode. */
id|parport_negotiate
(paren
id|port
comma
id|IEEE1284_MODE_COMPAT
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/* Write the data, converting LF-&gt;CRLF as we go. */
id|ssize_t
id|canwrite
op_assign
id|count
suffix:semicolon
r_char
op_star
id|lf
op_assign
id|memchr
(paren
id|s
comma
l_char|&squot;&bslash;n&squot;
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lf
)paren
id|canwrite
op_assign
id|lf
op_minus
id|s
suffix:semicolon
r_if
c_cond
(paren
id|canwrite
OG
l_int|0
)paren
(brace
id|written
op_assign
id|parport_write
(paren
id|port
comma
id|s
comma
id|canwrite
)paren
suffix:semicolon
r_if
c_cond
(paren
id|written
op_le
l_int|0
)paren
r_continue
suffix:semicolon
id|s
op_add_assign
id|written
suffix:semicolon
id|count
op_sub_assign
id|written
suffix:semicolon
id|canwrite
op_sub_assign
id|written
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lf
op_logical_and
id|canwrite
op_le
l_int|0
)paren
(brace
r_const
r_char
op_star
id|crlf
op_assign
l_string|&quot;&bslash;r&bslash;n&quot;
suffix:semicolon
r_int
id|i
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* Dodge the original &squot;&bslash;n&squot;, and put &squot;&bslash;r&bslash;n&squot; instead. */
id|s
op_increment
suffix:semicolon
id|count
op_decrement
suffix:semicolon
r_do
(brace
id|written
op_assign
id|parport_write
(paren
id|port
comma
id|crlf
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|written
OG
l_int|0
)paren
id|i
op_sub_assign
id|written
comma
id|crlf
op_add_assign
id|written
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
OG
l_int|0
op_logical_and
(paren
id|CONSOLE_LP_STRICT
op_logical_or
id|written
OG
l_int|0
)paren
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|count
OG
l_int|0
op_logical_and
(paren
id|CONSOLE_LP_STRICT
op_logical_or
id|written
OG
l_int|0
)paren
)paren
suffix:semicolon
id|parport_release
(paren
id|dev
)paren
suffix:semicolon
)brace
DECL|variable|lpcons
r_static
r_struct
id|console
id|lpcons
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;lp&quot;
comma
dot
id|write
op_assign
id|lp_console_write
comma
dot
id|flags
op_assign
id|CON_PRINTBUFFER
comma
)brace
suffix:semicolon
macro_line|#endif /* console on line printer */
multiline_comment|/* --- initialisation code ------------------------------------- */
DECL|variable|parport_nr
r_static
r_int
id|parport_nr
(braket
id|LP_NO
)braket
op_assign
(brace
(braket
l_int|0
dot
dot
dot
id|LP_NO
op_minus
l_int|1
)braket
op_assign
id|LP_PARPORT_UNSPEC
)brace
suffix:semicolon
DECL|variable|parport
r_static
r_char
op_star
id|parport
(braket
id|LP_NO
)braket
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
DECL|variable|reset
r_static
r_int
id|reset
op_assign
l_int|0
suffix:semicolon
id|module_param_array
c_func
(paren
id|parport
comma
id|charp
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|reset
comma
r_bool
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifndef MODULE
DECL|function|lp_setup
r_static
r_int
id|__init
id|lp_setup
(paren
r_char
op_star
id|str
)paren
(brace
r_static
r_int
id|parport_ptr
suffix:semicolon
singleline_comment|// initially zero
r_int
id|x
suffix:semicolon
r_if
c_cond
(paren
id|get_option
(paren
op_amp
id|str
comma
op_amp
id|x
)paren
)paren
(brace
r_if
c_cond
(paren
id|x
op_eq
l_int|0
)paren
(brace
multiline_comment|/* disable driver on &quot;lp=&quot; or &quot;lp=0&quot; */
id|parport_nr
(braket
l_int|0
)braket
op_assign
id|LP_PARPORT_OFF
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;warning: &squot;lp=0x%x&squot; is deprecated, ignored&bslash;n&quot;
comma
id|x
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|str
comma
l_string|&quot;parport&quot;
comma
l_int|7
)paren
)paren
(brace
r_int
id|n
op_assign
id|simple_strtoul
c_func
(paren
id|str
op_plus
l_int|7
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parport_ptr
OL
id|LP_NO
)paren
id|parport_nr
(braket
id|parport_ptr
op_increment
)braket
op_assign
id|n
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;lp: too many ports, %s ignored.&bslash;n&quot;
comma
id|str
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|str
comma
l_string|&quot;auto&quot;
)paren
)paren
(brace
id|parport_nr
(braket
l_int|0
)braket
op_assign
id|LP_PARPORT_AUTO
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|str
comma
l_string|&quot;none&quot;
)paren
)paren
(brace
id|parport_nr
(braket
id|parport_ptr
op_increment
)braket
op_assign
id|LP_PARPORT_NONE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|str
comma
l_string|&quot;reset&quot;
)paren
)paren
(brace
id|reset
op_assign
l_int|1
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
DECL|function|lp_register
r_static
r_int
id|lp_register
c_func
(paren
r_int
id|nr
comma
r_struct
id|parport
op_star
id|port
)paren
(brace
id|lp_table
(braket
id|nr
)braket
dot
id|dev
op_assign
id|parport_register_device
c_func
(paren
id|port
comma
l_string|&quot;lp&quot;
comma
id|lp_preempt
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|lp_table
(braket
id|nr
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp_table
(braket
id|nr
)braket
dot
id|dev
op_eq
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
id|lp_table
(braket
id|nr
)braket
dot
id|flags
op_or_assign
id|LP_EXIST
suffix:semicolon
r_if
c_cond
(paren
id|reset
)paren
id|lp_reset
c_func
(paren
id|nr
)paren
suffix:semicolon
id|class_simple_device_add
c_func
(paren
id|lp_class
comma
id|MKDEV
c_func
(paren
id|LP_MAJOR
comma
id|nr
)paren
comma
l_int|NULL
comma
l_string|&quot;lp%d&quot;
comma
id|nr
)paren
suffix:semicolon
id|devfs_mk_cdev
c_func
(paren
id|MKDEV
c_func
(paren
id|LP_MAJOR
comma
id|nr
)paren
comma
id|S_IFCHR
op_or
id|S_IRUGO
op_or
id|S_IWUGO
comma
l_string|&quot;printers/%d&quot;
comma
id|nr
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;lp%d: using %s (%s).&bslash;n&quot;
comma
id|nr
comma
id|port-&gt;name
comma
(paren
id|port-&gt;irq
op_eq
id|PARPORT_IRQ_NONE
)paren
ques
c_cond
l_string|&quot;polling&quot;
suffix:colon
l_string|&quot;interrupt-driven&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_LP_CONSOLE
r_if
c_cond
(paren
op_logical_neg
id|nr
)paren
(brace
r_if
c_cond
(paren
id|port-&gt;modes
op_amp
id|PARPORT_MODE_SAFEININT
)paren
(brace
id|register_console
(paren
op_amp
id|lpcons
)paren
suffix:semicolon
id|console_registered
op_assign
id|port
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;lp%d: console ready&bslash;n&quot;
comma
id|CONSOLE_LP
)paren
suffix:semicolon
)brace
r_else
id|printk
(paren
id|KERN_ERR
l_string|&quot;lp%d: cannot run console on %s&bslash;n&quot;
comma
id|CONSOLE_LP
comma
id|port-&gt;name
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|lp_attach
r_static
r_void
id|lp_attach
(paren
r_struct
id|parport
op_star
id|port
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_switch
c_cond
(paren
id|parport_nr
(braket
l_int|0
)braket
)paren
(brace
r_case
id|LP_PARPORT_UNSPEC
suffix:colon
r_case
id|LP_PARPORT_AUTO
suffix:colon
r_if
c_cond
(paren
id|parport_nr
(braket
l_int|0
)braket
op_eq
id|LP_PARPORT_AUTO
op_logical_and
id|port-&gt;probe_info
(braket
l_int|0
)braket
dot
r_class
op_ne
id|PARPORT_CLASS_PRINTER
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|lp_count
op_eq
id|LP_NO
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;lp: ignoring parallel port (max. %d)&bslash;n&quot;
comma
id|LP_NO
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|lp_register
c_func
(paren
id|lp_count
comma
id|port
)paren
)paren
id|lp_count
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|LP_NO
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|port-&gt;number
op_eq
id|parport_nr
(braket
id|i
)braket
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|lp_register
c_func
(paren
id|i
comma
id|port
)paren
)paren
id|lp_count
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
)brace
DECL|function|lp_detach
r_static
r_void
id|lp_detach
(paren
r_struct
id|parport
op_star
id|port
)paren
(brace
multiline_comment|/* Write this some day. */
macro_line|#ifdef CONFIG_LP_CONSOLE
r_if
c_cond
(paren
id|console_registered
op_eq
id|port
)paren
(brace
id|unregister_console
(paren
op_amp
id|lpcons
)paren
suffix:semicolon
id|console_registered
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_LP_CONSOLE */
)brace
DECL|variable|lp_driver
r_static
r_struct
id|parport_driver
id|lp_driver
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;lp&quot;
comma
dot
id|attach
op_assign
id|lp_attach
comma
dot
id|detach
op_assign
id|lp_detach
comma
)brace
suffix:semicolon
DECL|function|lp_init
r_static
r_int
id|__init
id|lp_init
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|parport_nr
(braket
l_int|0
)braket
op_eq
id|LP_PARPORT_OFF
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|LP_NO
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lp_table
(braket
id|i
)braket
dot
id|dev
op_assign
l_int|NULL
suffix:semicolon
id|lp_table
(braket
id|i
)braket
dot
id|flags
op_assign
l_int|0
suffix:semicolon
id|lp_table
(braket
id|i
)braket
dot
id|chars
op_assign
id|LP_INIT_CHAR
suffix:semicolon
id|lp_table
(braket
id|i
)braket
dot
id|time
op_assign
id|LP_INIT_TIME
suffix:semicolon
id|lp_table
(braket
id|i
)braket
dot
id|wait
op_assign
id|LP_INIT_WAIT
suffix:semicolon
id|lp_table
(braket
id|i
)braket
dot
id|lp_buffer
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef LP_STATS
id|lp_table
(braket
id|i
)braket
dot
id|lastcall
op_assign
l_int|0
suffix:semicolon
id|lp_table
(braket
id|i
)braket
dot
id|runchars
op_assign
l_int|0
suffix:semicolon
id|memset
(paren
op_amp
id|lp_table
(braket
id|i
)braket
dot
id|stats
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|lp_stats
)paren
)paren
suffix:semicolon
macro_line|#endif
id|lp_table
(braket
id|i
)braket
dot
id|last_error
op_assign
l_int|0
suffix:semicolon
id|init_waitqueue_head
(paren
op_amp
id|lp_table
(braket
id|i
)braket
dot
id|waitq
)paren
suffix:semicolon
id|init_waitqueue_head
(paren
op_amp
id|lp_table
(braket
id|i
)braket
dot
id|dataq
)paren
suffix:semicolon
id|init_MUTEX
(paren
op_amp
id|lp_table
(braket
id|i
)braket
dot
id|port_mutex
)paren
suffix:semicolon
id|lp_table
(braket
id|i
)braket
dot
id|timeout
op_assign
l_int|10
op_star
id|HZ
suffix:semicolon
)brace
r_if
c_cond
(paren
id|register_chrdev
(paren
id|LP_MAJOR
comma
l_string|&quot;lp&quot;
comma
op_amp
id|lp_fops
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;lp: unable to get major %d&bslash;n&quot;
comma
id|LP_MAJOR
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|devfs_mk_dir
c_func
(paren
l_string|&quot;printers&quot;
)paren
suffix:semicolon
id|lp_class
op_assign
id|class_simple_create
c_func
(paren
id|THIS_MODULE
comma
l_string|&quot;printer&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|lp_class
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|lp_class
)paren
suffix:semicolon
r_goto
id|out_devfs
suffix:semicolon
)brace
r_if
c_cond
(paren
id|parport_register_driver
(paren
op_amp
id|lp_driver
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;lp: unable to register with parport&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|out_class
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|lp_count
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;lp: driver loaded but no devices found&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_PARPORT_1284
r_if
c_cond
(paren
id|parport_nr
(braket
l_int|0
)braket
op_eq
id|LP_PARPORT_AUTO
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;lp: (is IEEE 1284 support enabled?)&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
r_return
l_int|0
suffix:semicolon
id|out_class
suffix:colon
id|class_simple_destroy
c_func
(paren
id|lp_class
)paren
suffix:semicolon
id|out_devfs
suffix:colon
id|devfs_remove
c_func
(paren
l_string|&quot;printers&quot;
)paren
suffix:semicolon
id|unregister_chrdev
c_func
(paren
id|LP_MAJOR
comma
l_string|&quot;lp&quot;
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|lp_init_module
r_static
r_int
id|__init
id|lp_init_module
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|parport
(braket
l_int|0
)braket
)paren
(brace
multiline_comment|/* The user gave some parameters.  Let&squot;s see what they were.  */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|parport
(braket
l_int|0
)braket
comma
l_string|&quot;auto&quot;
comma
l_int|4
)paren
)paren
id|parport_nr
(braket
l_int|0
)braket
op_assign
id|LP_PARPORT_AUTO
suffix:semicolon
r_else
(brace
r_int
id|n
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|LP_NO
op_logical_and
id|parport
(braket
id|n
)braket
suffix:semicolon
id|n
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|parport
(braket
id|n
)braket
comma
l_string|&quot;none&quot;
comma
l_int|4
)paren
)paren
id|parport_nr
(braket
id|n
)braket
op_assign
id|LP_PARPORT_NONE
suffix:semicolon
r_else
(brace
r_char
op_star
id|ep
suffix:semicolon
r_int
r_int
id|r
op_assign
id|simple_strtoul
c_func
(paren
id|parport
(braket
id|n
)braket
comma
op_amp
id|ep
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ep
op_ne
id|parport
(braket
id|n
)braket
)paren
id|parport_nr
(braket
id|n
)braket
op_assign
id|r
suffix:semicolon
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;lp: bad port specifier `%s&squot;&bslash;n&quot;
comma
id|parport
(braket
id|n
)braket
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
r_return
id|lp_init
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|lp_cleanup_module
r_static
r_void
id|lp_cleanup_module
(paren
r_void
)paren
(brace
r_int
r_int
id|offset
suffix:semicolon
id|parport_unregister_driver
(paren
op_amp
id|lp_driver
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_LP_CONSOLE
id|unregister_console
(paren
op_amp
id|lpcons
)paren
suffix:semicolon
macro_line|#endif
id|unregister_chrdev
c_func
(paren
id|LP_MAJOR
comma
l_string|&quot;lp&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|offset
op_assign
l_int|0
suffix:semicolon
id|offset
OL
id|LP_NO
suffix:semicolon
id|offset
op_increment
)paren
(brace
r_if
c_cond
(paren
id|lp_table
(braket
id|offset
)braket
dot
id|dev
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|parport_unregister_device
c_func
(paren
id|lp_table
(braket
id|offset
)braket
dot
id|dev
)paren
suffix:semicolon
id|devfs_remove
c_func
(paren
l_string|&quot;printers/%d&quot;
comma
id|offset
)paren
suffix:semicolon
id|class_simple_device_remove
c_func
(paren
id|MKDEV
c_func
(paren
id|LP_MAJOR
comma
id|offset
)paren
)paren
suffix:semicolon
)brace
id|devfs_remove
c_func
(paren
l_string|&quot;printers&quot;
)paren
suffix:semicolon
id|class_simple_destroy
c_func
(paren
id|lp_class
)paren
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;lp=&quot;
comma
id|lp_setup
)paren
suffix:semicolon
DECL|variable|lp_init_module
id|module_init
c_func
(paren
id|lp_init_module
)paren
suffix:semicolon
DECL|variable|lp_cleanup_module
id|module_exit
c_func
(paren
id|lp_cleanup_module
)paren
suffix:semicolon
DECL|variable|LP_MAJOR
id|MODULE_ALIAS_CHARDEV_MAJOR
c_func
(paren
id|LP_MAJOR
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
