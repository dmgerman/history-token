multiline_comment|/* generic HDLC line discipline for Linux&n; *&n; * Written by Paul Fulghum paulkf@microgate.com&n; * for Microgate Corporation&n; *&n; * Microgate and SyncLink are registered trademarks of Microgate Corporation&n; *&n; * Adapted from ppp.c, written by Michael Callahan &lt;callahan@maths.ox.ac.uk&gt;,&n; *&t;Al Longyear &lt;longyear@netcom.com&gt;,&n; *&t;Paul Mackerras &lt;Paul.Mackerras@cs.anu.edu.au&gt;&n; *&n; * Original release 01/11/99&n; * $Id: n_hdlc.c,v 4.8 2003/05/06 21:18:51 paulkf Exp $&n; *&n; * This code is released under the GNU General Public License (GPL)&n; *&n; * This module implements the tty line discipline N_HDLC for use with&n; * tty device drivers that support bit-synchronous HDLC communications.&n; *&n; * All HDLC data is frame oriented which means:&n; *&n; * 1. tty write calls represent one complete transmit frame of data&n; *    The device driver should accept the complete frame or none of &n; *    the frame (busy) in the write method. Each write call should have&n; *    a byte count in the range of 2-65535 bytes (2 is min HDLC frame&n; *    with 1 addr byte and 1 ctrl byte). The max byte count of 65535&n; *    should include any crc bytes required. For example, when using&n; *    CCITT CRC32, 4 crc bytes are required, so the maximum size frame&n; *    the application may transmit is limited to 65531 bytes. For CCITT&n; *    CRC16, the maximum application frame size would be 65533.&n; *&n; *&n; * 2. receive callbacks from the device driver represents&n; *    one received frame. The device driver should bypass&n; *    the tty flip buffer and call the line discipline receive&n; *    callback directly to avoid fragmenting or concatenating&n; *    multiple frames into a single receive callback.&n; *&n; *    The HDLC line discipline queues the receive frames in separate&n; *    buffers so complete receive frames can be returned by the&n; *    tty read calls.&n; *&n; * 3. tty read calls returns an entire frame of data or nothing.&n; *    &n; * 4. all send and receive data is considered raw. No processing&n; *    or translation is performed by the line discipline, regardless&n; *    of the tty flags&n; *&n; * 5. When line discipline is queried for the amount of receive&n; *    data available (FIOC), 0 is returned if no data available,&n; *    otherwise the count of the next available frame is returned.&n; *    (instead of the sum of all received frame counts).&n; *&n; * These conventions allow the standard tty programming interface&n; * to be used for synchronous HDLC applications when used with&n; * this line discipline (or another line discipline that is frame&n; * oriented such as N_PPP).&n; *&n; * The SyncLink driver (synclink.c) implements both asynchronous&n; * (using standard line discipline N_TTY) and synchronous HDLC&n; * (using N_HDLC) communications, with the latter using the above&n; * conventions.&n; *&n; * This implementation is very basic and does not maintain&n; * any statistics. The main point is to enforce the raw data&n; * and frame orientation of HDLC communications.&n; *&n; * THIS SOFTWARE IS PROVIDED ``AS IS&squot;&squot; AND ANY EXPRESS OR IMPLIED&n; * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES&n; * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE&n; * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,&n; * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES&n; * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR&n; * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)&n; * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,&n; * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)&n; * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED&n; * OF THE POSSIBILITY OF SUCH DAMAGE.&n; */
DECL|macro|HDLC_MAGIC
mdefine_line|#define HDLC_MAGIC 0x239e
DECL|macro|HDLC_VERSION
mdefine_line|#define HDLC_VERSION &quot;$Revision: 4.8 $&quot;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
DECL|macro|VERSION
macro_line|#undef VERSION
DECL|macro|VERSION
mdefine_line|#define VERSION(major,minor,patch) (((((major)&lt;&lt;8)+(minor))&lt;&lt;8)+(patch))
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/ioctl.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;&t;/* used in new tty drivers */
macro_line|#include &lt;linux/signal.h&gt;&t;/* used in new tty drivers */
macro_line|#include &lt;linux/if.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/termios.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
multiline_comment|/*&n; * Buffers for individual HDLC frames&n; */
DECL|macro|MAX_HDLC_FRAME_SIZE
mdefine_line|#define MAX_HDLC_FRAME_SIZE 65535 
DECL|macro|DEFAULT_RX_BUF_COUNT
mdefine_line|#define DEFAULT_RX_BUF_COUNT 10
DECL|macro|MAX_RX_BUF_COUNT
mdefine_line|#define MAX_RX_BUF_COUNT 60
DECL|macro|DEFAULT_TX_BUF_COUNT
mdefine_line|#define DEFAULT_TX_BUF_COUNT 1
DECL|struct|n_hdlc_buf
r_struct
id|n_hdlc_buf
(brace
DECL|member|link
r_struct
id|n_hdlc_buf
op_star
id|link
suffix:semicolon
DECL|member|count
r_int
id|count
suffix:semicolon
DECL|member|buf
r_char
id|buf
(braket
l_int|1
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|N_HDLC_BUF_SIZE
mdefine_line|#define&t;N_HDLC_BUF_SIZE&t;(sizeof(struct n_hdlc_buf) + maxframe)
DECL|struct|n_hdlc_buf_list
r_struct
id|n_hdlc_buf_list
(brace
DECL|member|head
r_struct
id|n_hdlc_buf
op_star
id|head
suffix:semicolon
DECL|member|tail
r_struct
id|n_hdlc_buf
op_star
id|tail
suffix:semicolon
DECL|member|count
r_int
id|count
suffix:semicolon
DECL|member|spinlock
id|spinlock_t
id|spinlock
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/**&n; * struct n_hdlc - per device instance data structure&n; * @magic - magic value for structure&n; * @flags - miscellaneous control flags&n; * @tty - ptr to TTY structure&n; * @backup_tty - TTY to use if tty gets closed&n; * @tbusy - reentrancy flag for tx wakeup code&n; * @woke_up - FIXME: describe this field&n; * @tbuf - currently transmitting tx buffer&n; * @tx_buf_list - list of pending transmit frame buffers&n; * @rx_buf_list - list of received frame buffers&n; * @tx_free_buf_list - list unused transmit frame buffers&n; * @rx_free_buf_list - list unused received frame buffers&n; */
DECL|struct|n_hdlc
r_struct
id|n_hdlc
(brace
DECL|member|magic
r_int
id|magic
suffix:semicolon
DECL|member|flags
id|__u32
id|flags
suffix:semicolon
DECL|member|tty
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
DECL|member|backup_tty
r_struct
id|tty_struct
op_star
id|backup_tty
suffix:semicolon
DECL|member|tbusy
r_int
id|tbusy
suffix:semicolon
DECL|member|woke_up
r_int
id|woke_up
suffix:semicolon
DECL|member|tbuf
r_struct
id|n_hdlc_buf
op_star
id|tbuf
suffix:semicolon
DECL|member|tx_buf_list
r_struct
id|n_hdlc_buf_list
id|tx_buf_list
suffix:semicolon
DECL|member|rx_buf_list
r_struct
id|n_hdlc_buf_list
id|rx_buf_list
suffix:semicolon
DECL|member|tx_free_buf_list
r_struct
id|n_hdlc_buf_list
id|tx_free_buf_list
suffix:semicolon
DECL|member|rx_free_buf_list
r_struct
id|n_hdlc_buf_list
id|rx_free_buf_list
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * HDLC buffer list manipulation functions&n; */
r_static
r_void
id|n_hdlc_buf_list_init
c_func
(paren
r_struct
id|n_hdlc_buf_list
op_star
id|list
)paren
suffix:semicolon
r_static
r_void
id|n_hdlc_buf_put
c_func
(paren
r_struct
id|n_hdlc_buf_list
op_star
id|list
comma
r_struct
id|n_hdlc_buf
op_star
id|buf
)paren
suffix:semicolon
r_static
r_struct
id|n_hdlc_buf
op_star
id|n_hdlc_buf_get
c_func
(paren
r_struct
id|n_hdlc_buf_list
op_star
id|list
)paren
suffix:semicolon
multiline_comment|/* Local functions */
r_static
r_struct
id|n_hdlc
op_star
id|n_hdlc_alloc
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* debug level can be set by insmod for debugging purposes */
DECL|macro|DEBUG_LEVEL_INFO
mdefine_line|#define DEBUG_LEVEL_INFO&t;1
DECL|variable|debuglevel
r_static
r_int
id|debuglevel
suffix:semicolon
multiline_comment|/* max frame size for memory allocations */
DECL|variable|maxframe
r_static
id|ssize_t
id|maxframe
op_assign
l_int|4096
suffix:semicolon
multiline_comment|/* TTY callbacks */
r_static
id|ssize_t
id|n_hdlc_tty_read
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
id|__u8
id|__user
op_star
id|buf
comma
r_int
id|nr
)paren
suffix:semicolon
r_static
id|ssize_t
id|n_hdlc_tty_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|nr
)paren
suffix:semicolon
r_static
r_int
id|n_hdlc_tty_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_int
r_int
id|n_hdlc_tty_poll
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
comma
id|poll_table
op_star
id|wait
)paren
suffix:semicolon
r_static
r_int
id|n_hdlc_tty_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|n_hdlc_tty_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_int
id|n_hdlc_tty_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|n_hdlc_tty_receive
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_const
id|__u8
op_star
id|cp
comma
r_char
op_star
id|fp
comma
r_int
id|count
)paren
suffix:semicolon
r_static
r_void
id|n_hdlc_tty_wakeup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
DECL|macro|bset
mdefine_line|#define bset(p,b)&t;((p)[(b) &gt;&gt; 5] |= (1 &lt;&lt; ((b) &amp; 0x1f)))
DECL|macro|tty2n_hdlc
mdefine_line|#define tty2n_hdlc(tty)&t;((struct n_hdlc *) ((tty)-&gt;disc_data))
DECL|macro|n_hdlc2tty
mdefine_line|#define n_hdlc2tty(n_hdlc)&t;((n_hdlc)-&gt;tty)
DECL|variable|n_hdlc_ldisc
r_static
r_struct
id|tty_ldisc
id|n_hdlc_ldisc
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|magic
op_assign
id|TTY_LDISC_MAGIC
comma
dot
id|name
op_assign
l_string|&quot;hdlc&quot;
comma
dot
id|open
op_assign
id|n_hdlc_tty_open
comma
dot
id|close
op_assign
id|n_hdlc_tty_close
comma
dot
id|read
op_assign
id|n_hdlc_tty_read
comma
dot
id|write
op_assign
id|n_hdlc_tty_write
comma
dot
id|ioctl
op_assign
id|n_hdlc_tty_ioctl
comma
dot
id|poll
op_assign
id|n_hdlc_tty_poll
comma
dot
id|receive_buf
op_assign
id|n_hdlc_tty_receive
comma
dot
id|receive_room
op_assign
id|n_hdlc_tty_room
comma
dot
id|write_wakeup
op_assign
id|n_hdlc_tty_wakeup
comma
)brace
suffix:semicolon
multiline_comment|/**&n; * n_hdlc_release - release an n_hdlc per device line discipline info structure&n; * @n_hdlc - per device line discipline info structure&n; */
DECL|function|n_hdlc_release
r_static
r_void
id|n_hdlc_release
c_func
(paren
r_struct
id|n_hdlc
op_star
id|n_hdlc
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|n_hdlc2tty
(paren
id|n_hdlc
)paren
suffix:semicolon
r_struct
id|n_hdlc_buf
op_star
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)n_hdlc_release() called&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
multiline_comment|/* Ensure that the n_hdlcd process is not hanging on select()/poll() */
id|wake_up_interruptible
(paren
op_amp
id|tty-&gt;read_wait
)paren
suffix:semicolon
id|wake_up_interruptible
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty
op_ne
l_int|NULL
op_logical_and
id|tty-&gt;disc_data
op_eq
id|n_hdlc
)paren
id|tty-&gt;disc_data
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Break the tty-&gt;n_hdlc link */
multiline_comment|/* Release transmit and receive buffers */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|buf
op_assign
id|n_hdlc_buf_get
c_func
(paren
op_amp
id|n_hdlc-&gt;rx_free_buf_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
)paren
(brace
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|buf
op_assign
id|n_hdlc_buf_get
c_func
(paren
op_amp
id|n_hdlc-&gt;tx_free_buf_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
)paren
(brace
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|buf
op_assign
id|n_hdlc_buf_get
c_func
(paren
op_amp
id|n_hdlc-&gt;rx_buf_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
)paren
(brace
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|buf
op_assign
id|n_hdlc_buf_get
c_func
(paren
op_amp
id|n_hdlc-&gt;tx_buf_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
)paren
(brace
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n_hdlc-&gt;tbuf
)paren
id|kfree
c_func
(paren
id|n_hdlc-&gt;tbuf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|n_hdlc
)paren
suffix:semicolon
)brace
multiline_comment|/* end of n_hdlc_release() */
multiline_comment|/**&n; * n_hdlc_tty_close - line discipline close&n; * @tty - pointer to tty info structure&n; *&n; * Called when the line discipline is changed to something&n; * else, the tty is closed, or the tty detects a hangup.&n; */
DECL|function|n_hdlc_tty_close
r_static
r_void
id|n_hdlc_tty_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|n_hdlc
op_star
id|n_hdlc
op_assign
id|tty2n_hdlc
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)n_hdlc_tty_close() called&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n_hdlc
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|n_hdlc-&gt;magic
op_ne
id|HDLC_MAGIC
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;n_hdlc: trying to close unopened tty!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#if defined(TTY_NO_WRITE_SPLIT)
id|clear_bit
c_func
(paren
id|TTY_NO_WRITE_SPLIT
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
macro_line|#endif
id|tty-&gt;disc_data
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|tty
op_eq
id|n_hdlc-&gt;backup_tty
)paren
id|n_hdlc-&gt;backup_tty
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|tty
op_ne
id|n_hdlc-&gt;tty
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|n_hdlc-&gt;backup_tty
)paren
(brace
id|n_hdlc-&gt;tty
op_assign
id|n_hdlc-&gt;backup_tty
suffix:semicolon
)brace
r_else
(brace
id|n_hdlc_release
(paren
id|n_hdlc
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)n_hdlc_tty_close() success&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
)brace
multiline_comment|/* end of n_hdlc_tty_close() */
multiline_comment|/**&n; * n_hdlc_tty_open - called when line discipline changed to n_hdlc&n; * @tty - pointer to tty info structure&n; *&n; * Returns 0 if success, otherwise error code&n; */
DECL|function|n_hdlc_tty_open
r_static
r_int
id|n_hdlc_tty_open
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|n_hdlc
op_star
id|n_hdlc
op_assign
id|tty2n_hdlc
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)n_hdlc_tty_open() called (device=%s)&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|tty-&gt;name
)paren
suffix:semicolon
multiline_comment|/* There should not be an existing table for this slot. */
r_if
c_cond
(paren
id|n_hdlc
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;n_hdlc_tty_open:tty already associated!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EEXIST
suffix:semicolon
)brace
id|n_hdlc
op_assign
id|n_hdlc_alloc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n_hdlc
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;n_hdlc_alloc failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENFILE
suffix:semicolon
)brace
id|tty-&gt;disc_data
op_assign
id|n_hdlc
suffix:semicolon
id|n_hdlc-&gt;tty
op_assign
id|tty
suffix:semicolon
macro_line|#if defined(TTY_NO_WRITE_SPLIT)
multiline_comment|/* change tty_io write() to not split large writes into 8K chunks */
id|set_bit
c_func
(paren
id|TTY_NO_WRITE_SPLIT
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Flush any pending characters in the driver and discipline. */
r_if
c_cond
(paren
id|tty-&gt;ldisc.flush_buffer
)paren
id|tty-&gt;ldisc.flush_buffer
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver-&gt;flush_buffer
)paren
id|tty-&gt;driver-&gt;flush_buffer
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)n_hdlc_tty_open() success&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end of n_tty_hdlc_open() */
multiline_comment|/**&n; * n_hdlc_send_frames - send frames on pending send buffer list&n; * @n_hdlc - pointer to ldisc instance data&n; * @tty - pointer to tty instance data&n; *&n; * Send frames on pending send buffer list until the driver does not accept a&n; * frame (busy) this function is called after adding a frame to the send buffer&n; * list and by the tty wakeup callback.&n; */
DECL|function|n_hdlc_send_frames
r_static
r_void
id|n_hdlc_send_frames
c_func
(paren
r_struct
id|n_hdlc
op_star
id|n_hdlc
comma
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_register
r_int
id|actual
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|n_hdlc_buf
op_star
id|tbuf
suffix:semicolon
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)n_hdlc_send_frames() called&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
id|check_again
suffix:colon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|n_hdlc-&gt;tx_buf_list.spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n_hdlc-&gt;tbusy
)paren
(brace
id|n_hdlc-&gt;woke_up
op_assign
l_int|1
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|n_hdlc-&gt;tx_buf_list.spinlock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|n_hdlc-&gt;tbusy
op_assign
l_int|1
suffix:semicolon
id|n_hdlc-&gt;woke_up
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|n_hdlc-&gt;tx_buf_list.spinlock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* get current transmit buffer or get new transmit */
multiline_comment|/* buffer from list of pending transmit buffers */
id|tbuf
op_assign
id|n_hdlc-&gt;tbuf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tbuf
)paren
id|tbuf
op_assign
id|n_hdlc_buf_get
c_func
(paren
op_amp
id|n_hdlc-&gt;tx_buf_list
)paren
suffix:semicolon
r_while
c_loop
(paren
id|tbuf
)paren
(brace
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)sending frame %p, count=%d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|tbuf
comma
id|tbuf-&gt;count
)paren
suffix:semicolon
multiline_comment|/* Send the next block of data to device */
id|tty-&gt;flags
op_or_assign
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
suffix:semicolon
id|actual
op_assign
id|tty-&gt;driver
op_member_access_from_pointer
id|write
c_func
(paren
id|tty
comma
id|tbuf-&gt;buf
comma
id|tbuf-&gt;count
)paren
suffix:semicolon
multiline_comment|/* if transmit error, throw frame away by */
multiline_comment|/* pretending it was accepted by driver */
r_if
c_cond
(paren
id|actual
OL
l_int|0
)paren
id|actual
op_assign
id|tbuf-&gt;count
suffix:semicolon
r_if
c_cond
(paren
id|actual
op_eq
id|tbuf-&gt;count
)paren
(brace
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)frame %p completed&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|tbuf
)paren
suffix:semicolon
multiline_comment|/* free current transmit buffer */
id|n_hdlc_buf_put
c_func
(paren
op_amp
id|n_hdlc-&gt;tx_free_buf_list
comma
id|tbuf
)paren
suffix:semicolon
multiline_comment|/* this tx buffer is done */
id|n_hdlc-&gt;tbuf
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* wait up sleeping writers */
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
multiline_comment|/* get next pending transmit buffer */
id|tbuf
op_assign
id|n_hdlc_buf_get
c_func
(paren
op_amp
id|n_hdlc-&gt;tx_buf_list
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)frame %p pending&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|tbuf
)paren
suffix:semicolon
multiline_comment|/* buffer not accepted by driver */
multiline_comment|/* set this buffer as pending buffer */
id|n_hdlc-&gt;tbuf
op_assign
id|tbuf
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|tbuf
)paren
id|tty-&gt;flags
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
suffix:semicolon
multiline_comment|/* Clear the re-entry flag */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|n_hdlc-&gt;tx_buf_list.spinlock
comma
id|flags
)paren
suffix:semicolon
id|n_hdlc-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|n_hdlc-&gt;tx_buf_list.spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n_hdlc-&gt;woke_up
)paren
r_goto
id|check_again
suffix:semicolon
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)n_hdlc_send_frames() exit&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
)brace
multiline_comment|/* end of n_hdlc_send_frames() */
multiline_comment|/**&n; * n_hdlc_tty_wakeup - Callback for transmit wakeup&n; * @tty&t;- pointer to associated tty instance data&n; *&n; * Called when low level device driver can accept more send data.&n; */
DECL|function|n_hdlc_tty_wakeup
r_static
r_void
id|n_hdlc_tty_wakeup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|n_hdlc
op_star
id|n_hdlc
op_assign
id|tty2n_hdlc
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)n_hdlc_tty_wakeup() called&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n_hdlc
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|tty
op_ne
id|n_hdlc-&gt;tty
)paren
(brace
id|tty-&gt;flags
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|n_hdlc_send_frames
(paren
id|n_hdlc
comma
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/* end of n_hdlc_tty_wakeup() */
multiline_comment|/**&n; * n_hdlc_tty_room - Return the amount of space left in the receiver&squot;s buffer&n; * @tty&t;- pointer to associated tty instance data&n; *&n; * Callback function from tty driver. Return the amount of space left in the&n; * receiver&squot;s buffer to decide if remote transmitter is to be throttled.&n; */
DECL|function|n_hdlc_tty_room
r_static
r_int
id|n_hdlc_tty_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)n_hdlc_tty_room() called&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
multiline_comment|/* always return a larger number to prevent */
multiline_comment|/* throttling of remote transmitter. */
r_return
l_int|65536
suffix:semicolon
)brace
multiline_comment|/* end of n_hdlc_tty_root() */
multiline_comment|/**&n; * n_hdlc_tty_receive - Called by tty driver when receive data is available&n; * @tty&t;- pointer to tty instance data&n; * @data - pointer to received data&n; * @flags - pointer to flags for data&n; * @count - count of received data in bytes&n; *&n; * Called by tty low level driver when receive data is available. Data is&n; * interpreted as one HDLC frame.&n; */
DECL|function|n_hdlc_tty_receive
r_static
r_void
id|n_hdlc_tty_receive
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_const
id|__u8
op_star
id|data
comma
r_char
op_star
id|flags
comma
r_int
id|count
)paren
(brace
r_register
r_struct
id|n_hdlc
op_star
id|n_hdlc
op_assign
id|tty2n_hdlc
(paren
id|tty
)paren
suffix:semicolon
r_register
r_struct
id|n_hdlc_buf
op_star
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)n_hdlc_tty_receive() called count=%d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|count
)paren
suffix:semicolon
multiline_comment|/* This can happen if stuff comes in on the backup tty */
r_if
c_cond
(paren
id|n_hdlc
op_eq
l_int|0
op_logical_or
id|tty
op_ne
id|n_hdlc-&gt;tty
)paren
r_return
suffix:semicolon
multiline_comment|/* verify line is using HDLC discipline */
r_if
c_cond
(paren
id|n_hdlc-&gt;magic
op_ne
id|HDLC_MAGIC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s(%d) line not using HDLC discipline&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OG
id|maxframe
)paren
(brace
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d) rx count&gt;maxframesize, data discarded&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* get a free HDLC buffer */
id|buf
op_assign
id|n_hdlc_buf_get
c_func
(paren
op_amp
id|n_hdlc-&gt;rx_free_buf_list
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
(brace
multiline_comment|/* no buffers in free list, attempt to allocate another rx buffer */
multiline_comment|/* unless the maximum count has been reached */
r_if
c_cond
(paren
id|n_hdlc-&gt;rx_buf_list.count
OL
id|MAX_RX_BUF_COUNT
)paren
id|buf
op_assign
id|kmalloc
c_func
(paren
id|N_HDLC_BUF_SIZE
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
(brace
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d) no more rx buffers, data discarded&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* copy received data to HDLC buffer */
id|memcpy
c_func
(paren
id|buf-&gt;buf
comma
id|data
comma
id|count
)paren
suffix:semicolon
id|buf-&gt;count
op_assign
id|count
suffix:semicolon
multiline_comment|/* add HDLC buffer to list of received frames */
id|n_hdlc_buf_put
c_func
(paren
op_amp
id|n_hdlc-&gt;rx_buf_list
comma
id|buf
)paren
suffix:semicolon
multiline_comment|/* wake up any blocked reads and perform async signalling */
id|wake_up_interruptible
(paren
op_amp
id|tty-&gt;read_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n_hdlc-&gt;tty-&gt;fasync
op_ne
l_int|NULL
)paren
id|kill_fasync
(paren
op_amp
id|n_hdlc-&gt;tty-&gt;fasync
comma
id|SIGIO
comma
id|POLL_IN
)paren
suffix:semicolon
)brace
multiline_comment|/* end of n_hdlc_tty_receive() */
multiline_comment|/**&n; * n_hdlc_tty_read - Called to retreive one frame of data (if available)&n; * @tty - pointer to tty instance data&n; * @file - pointer to open file object&n; * @buf - pointer to returned data buffer&n; * @nr - size of returned data buffer&n; * &t;&n; * Returns the number of bytes returned or error code.&n; */
DECL|function|n_hdlc_tty_read
r_static
id|ssize_t
id|n_hdlc_tty_read
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
id|__u8
id|__user
op_star
id|buf
comma
r_int
id|nr
)paren
(brace
r_struct
id|n_hdlc
op_star
id|n_hdlc
op_assign
id|tty2n_hdlc
c_func
(paren
id|tty
)paren
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_struct
id|n_hdlc_buf
op_star
id|rbuf
suffix:semicolon
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)n_hdlc_tty_read() called&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
multiline_comment|/* Validate the pointers */
r_if
c_cond
(paren
op_logical_neg
id|n_hdlc
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* verify user access to buffer */
id|error
op_assign
id|verify_area
(paren
id|VERIFY_WRITE
comma
id|buf
comma
id|nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s(%d) n_hdlc_tty_read() can&squot;t verify user &quot;
l_string|&quot;buffer&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|TTY_OTHER_CLOSED
comma
op_amp
id|tty-&gt;flags
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|n_hdlc
op_assign
id|tty2n_hdlc
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n_hdlc
op_logical_or
id|n_hdlc-&gt;magic
op_ne
id|HDLC_MAGIC
op_logical_or
id|tty
op_ne
id|n_hdlc-&gt;tty
)paren
r_return
l_int|0
suffix:semicolon
id|rbuf
op_assign
id|n_hdlc_buf_get
c_func
(paren
op_amp
id|n_hdlc-&gt;rx_buf_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rbuf
)paren
r_break
suffix:semicolon
multiline_comment|/* no data */
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|interruptible_sleep_on
(paren
op_amp
id|tty-&gt;read_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rbuf-&gt;count
OG
id|nr
)paren
multiline_comment|/* frame too large for caller&squot;s buffer (discard frame) */
id|ret
op_assign
op_minus
id|EOVERFLOW
suffix:semicolon
r_else
(brace
multiline_comment|/* Copy the data to the caller&squot;s buffer */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
id|rbuf-&gt;buf
comma
id|rbuf-&gt;count
)paren
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_else
id|ret
op_assign
id|rbuf-&gt;count
suffix:semicolon
)brace
multiline_comment|/* return HDLC buffer to free list unless the free list */
multiline_comment|/* count has exceeded the default value, in which case the */
multiline_comment|/* buffer is freed back to the OS to conserve memory */
r_if
c_cond
(paren
id|n_hdlc-&gt;rx_free_buf_list.count
OG
id|DEFAULT_RX_BUF_COUNT
)paren
id|kfree
c_func
(paren
id|rbuf
)paren
suffix:semicolon
r_else
id|n_hdlc_buf_put
c_func
(paren
op_amp
id|n_hdlc-&gt;rx_free_buf_list
comma
id|rbuf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end of n_hdlc_tty_read() */
multiline_comment|/**&n; * n_hdlc_tty_write - write a single frame of data to device&n; * @tty&t;- pointer to associated tty device instance data&n; * @file - pointer to file object data&n; * @data - pointer to transmit data (one frame)&n; * @count - size of transmit frame in bytes&n; * &t;&t;&n; * Returns the number of bytes written (or error code).&n; */
DECL|function|n_hdlc_tty_write
r_static
id|ssize_t
id|n_hdlc_tty_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_const
r_int
r_char
op_star
id|data
comma
r_int
id|count
)paren
(brace
r_struct
id|n_hdlc
op_star
id|n_hdlc
op_assign
id|tty2n_hdlc
(paren
id|tty
)paren
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_struct
id|n_hdlc_buf
op_star
id|tbuf
suffix:semicolon
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)n_hdlc_tty_write() called count=%Zd&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|count
)paren
suffix:semicolon
multiline_comment|/* Verify pointers */
r_if
c_cond
(paren
op_logical_neg
id|n_hdlc
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|n_hdlc-&gt;magic
op_ne
id|HDLC_MAGIC
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* verify frame size */
r_if
c_cond
(paren
id|count
OG
id|maxframe
)paren
(brace
r_if
c_cond
(paren
id|debuglevel
op_amp
id|DEBUG_LEVEL_INFO
)paren
id|printk
(paren
id|KERN_WARNING
l_string|&quot;n_hdlc_tty_write: truncating user packet &quot;
l_string|&quot;from %lu to %Zd&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|count
comma
id|maxframe
)paren
suffix:semicolon
id|count
op_assign
id|maxframe
suffix:semicolon
)brace
id|add_wait_queue
c_func
(paren
op_amp
id|tty-&gt;write_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
multiline_comment|/* Allocate transmit buffer */
multiline_comment|/* sleep until transmit buffer available */
r_while
c_loop
(paren
op_logical_neg
(paren
id|tbuf
op_assign
id|n_hdlc_buf_get
c_func
(paren
op_amp
id|n_hdlc-&gt;tx_free_buf_list
)paren
)paren
)paren
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|n_hdlc
op_assign
id|tty2n_hdlc
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n_hdlc
op_logical_or
id|n_hdlc-&gt;magic
op_ne
id|HDLC_MAGIC
op_logical_or
id|tty
op_ne
id|n_hdlc-&gt;tty
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;n_hdlc_tty_write: %p invalid after wait!&bslash;n&quot;
comma
id|n_hdlc
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EINTR
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|tty-&gt;write_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
multiline_comment|/* Retrieve the user&squot;s buffer */
id|memcpy
c_func
(paren
id|tbuf-&gt;buf
comma
id|data
comma
id|count
)paren
suffix:semicolon
multiline_comment|/* Send the data */
id|tbuf-&gt;count
op_assign
id|error
op_assign
id|count
suffix:semicolon
id|n_hdlc_buf_put
c_func
(paren
op_amp
id|n_hdlc-&gt;tx_buf_list
comma
id|tbuf
)paren
suffix:semicolon
id|n_hdlc_send_frames
c_func
(paren
id|n_hdlc
comma
id|tty
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* end of n_hdlc_tty_write() */
multiline_comment|/**&n; * n_hdlc_tty_ioctl - process IOCTL system call for the tty device.&n; * @tty - pointer to tty instance data&n; * @file - pointer to open file object for device&n; * @cmd - IOCTL command code&n; * @arg - argument for IOCTL call (cmd dependent)&n; *&n; * Returns command dependent result.&n; */
DECL|function|n_hdlc_tty_ioctl
r_static
r_int
id|n_hdlc_tty_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|n_hdlc
op_star
id|n_hdlc
op_assign
id|tty2n_hdlc
(paren
id|tty
)paren
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)n_hdlc_tty_ioctl() called %d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|cmd
)paren
suffix:semicolon
multiline_comment|/* Verify the status of the device */
r_if
c_cond
(paren
op_logical_neg
id|n_hdlc
op_logical_or
id|n_hdlc-&gt;magic
op_ne
id|HDLC_MAGIC
)paren
r_return
op_minus
id|EBADF
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|FIONREAD
suffix:colon
multiline_comment|/* report count of read data available */
multiline_comment|/* in next available frame (if any) */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|n_hdlc-&gt;rx_buf_list.spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n_hdlc-&gt;rx_buf_list.head
)paren
id|count
op_assign
id|n_hdlc-&gt;rx_buf_list.head-&gt;count
suffix:semicolon
r_else
id|count
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|n_hdlc-&gt;rx_buf_list.spinlock
comma
id|flags
)paren
suffix:semicolon
id|error
op_assign
id|put_user
c_func
(paren
id|count
comma
(paren
r_int
id|__user
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCOUTQ
suffix:colon
multiline_comment|/* get the pending tx byte count in the driver */
id|count
op_assign
id|tty-&gt;driver-&gt;chars_in_buffer
ques
c_cond
id|tty-&gt;driver
op_member_access_from_pointer
id|chars_in_buffer
c_func
(paren
id|tty
)paren
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* add size of next output frame in queue */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|n_hdlc-&gt;tx_buf_list.spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n_hdlc-&gt;tx_buf_list.head
)paren
id|count
op_add_assign
id|n_hdlc-&gt;tx_buf_list.head-&gt;count
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|n_hdlc-&gt;tx_buf_list.spinlock
comma
id|flags
)paren
suffix:semicolon
id|error
op_assign
id|put_user
c_func
(paren
id|count
comma
(paren
r_int
id|__user
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
id|n_tty_ioctl
(paren
id|tty
comma
id|file
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* end of n_hdlc_tty_ioctl() */
multiline_comment|/**&n; * n_hdlc_tty_poll - TTY callback for poll system call&n; * @tty - pointer to tty instance data&n; * @filp - pointer to open file object for device&n; * @poll_table - wait queue for operations&n; * &n; * Determine which operations (read/write) will not block and return info&n; * to caller.&n; * Returns a bit mask containing info on which ops will not block.&n; */
DECL|function|n_hdlc_tty_poll
r_static
r_int
r_int
id|n_hdlc_tty_poll
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_struct
id|n_hdlc
op_star
id|n_hdlc
op_assign
id|tty2n_hdlc
(paren
id|tty
)paren
suffix:semicolon
r_int
r_int
id|mask
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)n_hdlc_tty_poll() called&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n_hdlc
op_logical_and
id|n_hdlc-&gt;magic
op_eq
id|HDLC_MAGIC
op_logical_and
id|tty
op_eq
id|n_hdlc-&gt;tty
)paren
(brace
multiline_comment|/* queue current process into any wait queue that */
multiline_comment|/* may awaken in the future (read and write) */
id|poll_wait
c_func
(paren
id|filp
comma
op_amp
id|tty-&gt;read_wait
comma
id|wait
)paren
suffix:semicolon
id|poll_wait
c_func
(paren
id|filp
comma
op_amp
id|tty-&gt;write_wait
comma
id|wait
)paren
suffix:semicolon
multiline_comment|/* set bits for operations that won&squot;t block */
r_if
c_cond
(paren
id|n_hdlc-&gt;rx_buf_list.head
)paren
(brace
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
)brace
multiline_comment|/* readable */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|TTY_OTHER_CLOSED
comma
op_amp
id|tty-&gt;flags
)paren
)paren
id|mask
op_or_assign
id|POLLHUP
suffix:semicolon
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
(brace
id|mask
op_or_assign
id|POLLHUP
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n_hdlc-&gt;tx_free_buf_list.head
)paren
(brace
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
)brace
multiline_comment|/* writable */
)brace
r_return
id|mask
suffix:semicolon
)brace
multiline_comment|/* end of n_hdlc_tty_poll() */
multiline_comment|/**&n; * n_hdlc_alloc - allocate an n_hdlc instance data structure&n; *&n; * Returns a pointer to newly created structure if success, otherwise %NULL&n; */
DECL|function|n_hdlc_alloc
r_static
r_struct
id|n_hdlc
op_star
id|n_hdlc_alloc
c_func
(paren
r_void
)paren
(brace
r_struct
id|n_hdlc_buf
op_star
id|buf
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|n_hdlc
op_star
id|n_hdlc
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|n_hdlc
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n_hdlc
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|n_hdlc
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|n_hdlc
)paren
)paren
suffix:semicolon
id|n_hdlc_buf_list_init
c_func
(paren
op_amp
id|n_hdlc-&gt;rx_free_buf_list
)paren
suffix:semicolon
id|n_hdlc_buf_list_init
c_func
(paren
op_amp
id|n_hdlc-&gt;tx_free_buf_list
)paren
suffix:semicolon
id|n_hdlc_buf_list_init
c_func
(paren
op_amp
id|n_hdlc-&gt;rx_buf_list
)paren
suffix:semicolon
id|n_hdlc_buf_list_init
c_func
(paren
op_amp
id|n_hdlc-&gt;tx_buf_list
)paren
suffix:semicolon
multiline_comment|/* allocate free rx buffer list */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DEFAULT_RX_BUF_COUNT
suffix:semicolon
id|i
op_increment
)paren
(brace
id|buf
op_assign
id|kmalloc
c_func
(paren
id|N_HDLC_BUF_SIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
)paren
id|n_hdlc_buf_put
c_func
(paren
op_amp
id|n_hdlc-&gt;rx_free_buf_list
comma
id|buf
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)n_hdlc_alloc(), kalloc() failed for rx buffer %d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* allocate free tx buffer list */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DEFAULT_TX_BUF_COUNT
suffix:semicolon
id|i
op_increment
)paren
(brace
id|buf
op_assign
id|kmalloc
c_func
(paren
id|N_HDLC_BUF_SIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
)paren
id|n_hdlc_buf_put
c_func
(paren
op_amp
id|n_hdlc-&gt;tx_free_buf_list
comma
id|buf
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)n_hdlc_alloc(), kalloc() failed for tx buffer %d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* Initialize the control block */
id|n_hdlc-&gt;magic
op_assign
id|HDLC_MAGIC
suffix:semicolon
id|n_hdlc-&gt;flags
op_assign
l_int|0
suffix:semicolon
r_return
id|n_hdlc
suffix:semicolon
)brace
multiline_comment|/* end of n_hdlc_alloc() */
multiline_comment|/**&n; * n_hdlc_buf_list_init - initialize specified HDLC buffer list&n; * @list - pointer to buffer list&n; */
DECL|function|n_hdlc_buf_list_init
r_static
r_void
id|n_hdlc_buf_list_init
c_func
(paren
r_struct
id|n_hdlc_buf_list
op_star
id|list
)paren
(brace
id|memset
c_func
(paren
id|list
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|list
)paren
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|list-&gt;spinlock
)paren
suffix:semicolon
)brace
multiline_comment|/* end of n_hdlc_buf_list_init() */
multiline_comment|/**&n; * n_hdlc_buf_put - add specified HDLC buffer to tail of specified list&n; * @list - pointer to buffer list&n; * @buf&t;- pointer to buffer&n; */
DECL|function|n_hdlc_buf_put
r_static
r_void
id|n_hdlc_buf_put
c_func
(paren
r_struct
id|n_hdlc_buf_list
op_star
id|list
comma
r_struct
id|n_hdlc_buf
op_star
id|buf
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|list-&gt;spinlock
comma
id|flags
)paren
suffix:semicolon
id|buf-&gt;link
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|list-&gt;tail
)paren
(brace
id|list-&gt;tail-&gt;link
op_assign
id|buf
suffix:semicolon
)brace
r_else
id|list-&gt;head
op_assign
id|buf
suffix:semicolon
id|list-&gt;tail
op_assign
id|buf
suffix:semicolon
(paren
id|list-&gt;count
)paren
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|list-&gt;spinlock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* end of n_hdlc_buf_put() */
multiline_comment|/**&n; * n_hdlc_buf_get - remove and return an HDLC buffer from list&n; * @list - pointer to HDLC buffer list&n; * &n; * Remove and return an HDLC buffer from the head of the specified HDLC buffer&n; * list.&n; * Returns a pointer to HDLC buffer if available, otherwise %NULL.&n; */
DECL|function|n_hdlc_buf_get
r_static
r_struct
id|n_hdlc_buf
op_star
id|n_hdlc_buf_get
c_func
(paren
r_struct
id|n_hdlc_buf_list
op_star
id|list
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|n_hdlc_buf
op_star
id|buf
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|list-&gt;spinlock
comma
id|flags
)paren
suffix:semicolon
id|buf
op_assign
id|list-&gt;head
suffix:semicolon
r_if
c_cond
(paren
id|buf
)paren
(brace
id|list-&gt;head
op_assign
id|buf-&gt;link
suffix:semicolon
(paren
id|list-&gt;count
)paren
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|list-&gt;head
)paren
id|list-&gt;tail
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|list-&gt;spinlock
comma
id|flags
)paren
suffix:semicolon
r_return
id|buf
suffix:semicolon
)brace
multiline_comment|/* end of n_hdlc_buf_get() */
DECL|variable|__initdata
r_static
r_char
id|hdlc_banner
(braket
)braket
id|__initdata
op_assign
id|KERN_INFO
l_string|&quot;HDLC line discipline: version &quot;
id|HDLC_VERSION
l_string|&quot;, maxframe=%u&bslash;n&quot;
suffix:semicolon
DECL|variable|__initdata
r_static
r_char
id|hdlc_register_ok
(braket
)braket
id|__initdata
op_assign
id|KERN_INFO
l_string|&quot;N_HDLC line discipline registered.&bslash;n&quot;
suffix:semicolon
DECL|variable|__initdata
r_static
r_char
id|hdlc_register_fail
(braket
)braket
id|__initdata
op_assign
id|KERN_ERR
l_string|&quot;error registering line discipline: %d&bslash;n&quot;
suffix:semicolon
DECL|variable|__initdata
r_static
r_char
id|hdlc_init_fail
(braket
)braket
id|__initdata
op_assign
id|KERN_INFO
l_string|&quot;N_HDLC: init failure %d&bslash;n&quot;
suffix:semicolon
DECL|function|n_hdlc_init
r_static
r_int
id|__init
id|n_hdlc_init
c_func
(paren
r_void
)paren
(brace
r_int
id|status
suffix:semicolon
multiline_comment|/* range check maxframe arg */
r_if
c_cond
(paren
id|maxframe
OL
l_int|4096
)paren
id|maxframe
op_assign
l_int|4096
suffix:semicolon
r_else
r_if
c_cond
(paren
id|maxframe
OG
l_int|65535
)paren
id|maxframe
op_assign
l_int|65535
suffix:semicolon
id|printk
c_func
(paren
id|hdlc_banner
comma
id|maxframe
)paren
suffix:semicolon
id|status
op_assign
id|tty_register_ldisc
c_func
(paren
id|N_HDLC
comma
op_amp
id|n_hdlc_ldisc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
id|printk
c_func
(paren
id|hdlc_register_ok
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|hdlc_register_fail
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
id|printk
c_func
(paren
id|hdlc_init_fail
comma
id|status
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/* end of init_module() */
DECL|variable|__exitdata
r_static
r_char
id|hdlc_unregister_ok
(braket
)braket
id|__exitdata
op_assign
id|KERN_INFO
l_string|&quot;N_HDLC: line discipline unregistered&bslash;n&quot;
suffix:semicolon
DECL|variable|__exitdata
r_static
r_char
id|hdlc_unregister_fail
(braket
)braket
id|__exitdata
op_assign
id|KERN_ERR
l_string|&quot;N_HDLC: can&squot;t unregister line discipline (err = %d)&bslash;n&quot;
suffix:semicolon
DECL|function|n_hdlc_exit
r_static
r_void
id|__exit
id|n_hdlc_exit
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Release tty registration of line discipline */
r_int
id|status
op_assign
id|tty_register_ldisc
c_func
(paren
id|N_HDLC
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
id|printk
c_func
(paren
id|hdlc_unregister_fail
comma
id|status
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|hdlc_unregister_ok
)paren
suffix:semicolon
)brace
DECL|variable|n_hdlc_init
id|module_init
c_func
(paren
id|n_hdlc_init
)paren
suffix:semicolon
DECL|variable|n_hdlc_exit
id|module_exit
c_func
(paren
id|n_hdlc_exit
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Paul Fulghum paulkf@microgate.com&quot;
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|debuglevel
comma
r_int
comma
l_int|0
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|maxframe
comma
r_int
comma
l_int|0
)paren
suffix:semicolon
DECL|variable|N_HDLC
id|MODULE_ALIAS_LDISC
c_func
(paren
id|N_HDLC
)paren
suffix:semicolon
eof
