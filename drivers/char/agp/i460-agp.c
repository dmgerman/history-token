multiline_comment|/*&n; * AGPGART module version 0.99&n; * Copyright (C) 1999 Jeff Hartmann&n; * Copyright (C) 1999 Precision Insight, Inc.&n; * Copyright (C) 1999 Xi Graphics, Inc.&n; *&n; * Permission is hereby granted, free of charge, to any person obtaining a&n; * copy of this software and associated documentation files (the &quot;Software&quot;),&n; * to deal in the Software without restriction, including without limitation&n; * the rights to use, copy, modify, merge, publish, distribute, sublicense,&n; * and/or sell copies of the Software, and to permit persons to whom the&n; * Software is furnished to do so, subject to the following conditions:&n; *&n; * The above copyright notice and this permission notice shall be included&n; * in all copies or substantial portions of the Software.&n; *&n; * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS&n; * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,&n; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL&n; * JEFF HARTMANN, OR ANY OTHER CONTRIBUTORS BE LIABLE FOR ANY CLAIM, &n; * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR &n; * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE &n; * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.&n; *&n; * TODO: &n; * - Allocate more than order 0 pages to avoid too much linear map splitting.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/agp_backend.h&gt;
macro_line|#include &quot;agp.h&quot;
multiline_comment|/* BIOS configures the chipset so that one of two apbase registers are used */
DECL|variable|intel_i460_dynamic_apbase
r_static
id|u8
id|intel_i460_dynamic_apbase
op_assign
l_int|0x10
suffix:semicolon
multiline_comment|/* 460 supports multiple GART page sizes, so GART pageshift is dynamic */
DECL|variable|intel_i460_pageshift
r_static
id|u8
id|intel_i460_pageshift
op_assign
l_int|12
suffix:semicolon
DECL|variable|intel_i460_pagesize
r_static
id|u32
id|intel_i460_pagesize
suffix:semicolon
multiline_comment|/* Keep track of which is larger, chipset or kernel page size. */
DECL|variable|intel_i460_cpk
r_static
id|u32
id|intel_i460_cpk
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Structure for tracking partial use of 4MB GART pages */
DECL|variable|i460_pg_detail
r_static
id|u32
op_star
op_star
id|i460_pg_detail
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|i460_pg_count
r_static
id|u32
op_star
id|i460_pg_count
op_assign
l_int|NULL
suffix:semicolon
DECL|macro|I460_CPAGES_PER_KPAGE
mdefine_line|#define I460_CPAGES_PER_KPAGE (PAGE_SIZE &gt;&gt; intel_i460_pageshift)
DECL|macro|I460_KPAGES_PER_CPAGE
mdefine_line|#define I460_KPAGES_PER_CPAGE ((1 &lt;&lt; intel_i460_pageshift) &gt;&gt; PAGE_SHIFT)
DECL|macro|I460_SRAM_IO_DISABLE
mdefine_line|#define I460_SRAM_IO_DISABLE&t;&t;(1 &lt;&lt; 4)
DECL|macro|I460_BAPBASE_ENABLE
mdefine_line|#define I460_BAPBASE_ENABLE&t;&t;(1 &lt;&lt; 3)
DECL|macro|I460_AGPSIZ_MASK
mdefine_line|#define I460_AGPSIZ_MASK&t;&t;0x7
DECL|macro|I460_4M_PS
mdefine_line|#define I460_4M_PS&t;&t;&t;(1 &lt;&lt; 1)
DECL|macro|log2
mdefine_line|#define log2(x)&t;&t;&t;&t;ffz(~(x))
DECL|function|intel_i460_read_back
r_static
r_inline
r_void
id|intel_i460_read_back
(paren
r_volatile
id|u32
op_star
id|entry
)paren
(brace
multiline_comment|/*&n;&t; * The 460 spec says we have to read the last location written to&n;&t; * make sure that all writes have taken effect&n;&t; */
op_star
id|entry
suffix:semicolon
)brace
DECL|function|intel_i460_fetch_size
r_static
r_int
id|intel_i460_fetch_size
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|u8
id|temp
suffix:semicolon
r_struct
id|aper_size_info_8
op_star
id|values
suffix:semicolon
multiline_comment|/* Determine the GART page size */
id|pci_read_config_byte
c_func
(paren
id|agp_bridge.dev
comma
id|INTEL_I460_GXBCTL
comma
op_amp
id|temp
)paren
suffix:semicolon
id|intel_i460_pageshift
op_assign
(paren
id|temp
op_amp
id|I460_4M_PS
)paren
ques
c_cond
l_int|22
suffix:colon
l_int|12
suffix:semicolon
id|intel_i460_pagesize
op_assign
l_int|1UL
op_lshift
id|intel_i460_pageshift
suffix:semicolon
id|values
op_assign
id|A_SIZE_8
c_func
(paren
id|agp_bridge.aperture_sizes
)paren
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|agp_bridge.dev
comma
id|INTEL_I460_AGPSIZ
comma
op_amp
id|temp
)paren
suffix:semicolon
multiline_comment|/* Exit now if the IO drivers for the GART SRAMS are turned off */
r_if
c_cond
(paren
id|temp
op_amp
id|I460_SRAM_IO_DISABLE
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;GART SRAMS disabled on 460GX chipset&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;AGPGART operation not possible&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Make sure we don&squot;t try to create an 2 ^ 23 entry GATT */
r_if
c_cond
(paren
(paren
id|intel_i460_pageshift
op_eq
l_int|0
)paren
op_logical_and
(paren
(paren
id|temp
op_amp
id|I460_AGPSIZ_MASK
)paren
op_eq
l_int|4
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;We can&squot;t have a 32GB aperture with 4KB GART pages&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Determine the proper APBASE register */
r_if
c_cond
(paren
id|temp
op_amp
id|I460_BAPBASE_ENABLE
)paren
id|intel_i460_dynamic_apbase
op_assign
id|INTEL_I460_BAPBASE
suffix:semicolon
r_else
id|intel_i460_dynamic_apbase
op_assign
id|INTEL_I460_APBASE
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|agp_bridge.num_aperture_sizes
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * Dynamically calculate the proper num_entries and page_order values for&n;&t;&t; * the define aperture sizes. Take care not to shift off the end of&n;&t;&t; * values[i].size.&n;&t;&t; */
id|values
(braket
id|i
)braket
dot
id|num_entries
op_assign
(paren
id|values
(braket
id|i
)braket
dot
id|size
op_lshift
l_int|8
)paren
op_rshift
(paren
id|intel_i460_pageshift
op_minus
l_int|12
)paren
suffix:semicolon
id|values
(braket
id|i
)braket
dot
id|page_order
op_assign
id|log2
c_func
(paren
(paren
r_sizeof
(paren
id|u32
)paren
op_star
id|values
(braket
id|i
)braket
dot
id|num_entries
)paren
op_rshift
id|PAGE_SHIFT
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|agp_bridge.num_aperture_sizes
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Neglect control bits when matching up size_value */
r_if
c_cond
(paren
(paren
id|temp
op_amp
id|I460_AGPSIZ_MASK
)paren
op_eq
id|values
(braket
id|i
)braket
dot
id|size_value
)paren
(brace
id|agp_bridge.previous_size
op_assign
id|agp_bridge.current_size
op_assign
(paren
r_void
op_star
)paren
(paren
id|values
op_plus
id|i
)paren
suffix:semicolon
id|agp_bridge.aperture_size_idx
op_assign
id|i
suffix:semicolon
r_return
id|values
(braket
id|i
)braket
dot
id|size
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* There isn&squot;t anything to do here since 460 has no GART TLB. */
DECL|function|intel_i460_tlb_flush
r_static
r_void
id|intel_i460_tlb_flush
c_func
(paren
id|agp_memory
op_star
id|mem
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * This utility function is needed to prevent corruption of the control bits&n; * which are stored along with the aperture size in 460&squot;s AGPSIZ register&n; */
DECL|function|intel_i460_write_agpsiz
r_static
r_void
id|intel_i460_write_agpsiz
c_func
(paren
id|u8
id|size_value
)paren
(brace
id|u8
id|temp
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|agp_bridge.dev
comma
id|INTEL_I460_AGPSIZ
comma
op_amp
id|temp
)paren
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|agp_bridge.dev
comma
id|INTEL_I460_AGPSIZ
comma
(paren
(paren
id|temp
op_amp
op_complement
id|I460_AGPSIZ_MASK
)paren
op_or
id|size_value
)paren
)paren
suffix:semicolon
)brace
DECL|function|intel_i460_cleanup
r_static
r_void
id|intel_i460_cleanup
c_func
(paren
r_void
)paren
(brace
r_struct
id|aper_size_info_8
op_star
id|previous_size
suffix:semicolon
id|previous_size
op_assign
id|A_SIZE_8
c_func
(paren
id|agp_bridge.previous_size
)paren
suffix:semicolon
id|intel_i460_write_agpsiz
c_func
(paren
id|previous_size-&gt;size_value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intel_i460_cpk
op_eq
l_int|0
)paren
(brace
id|vfree
c_func
(paren
id|i460_pg_detail
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|i460_pg_count
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Control bits for Out-Of-GART coherency and Burst Write Combining */
DECL|macro|I460_GXBCTL_OOG
mdefine_line|#define I460_GXBCTL_OOG&t;&t;(1UL &lt;&lt; 0)
DECL|macro|I460_GXBCTL_BWC
mdefine_line|#define I460_GXBCTL_BWC&t;&t;(1UL &lt;&lt; 2)
DECL|function|intel_i460_configure
r_static
r_int
id|intel_i460_configure
c_func
(paren
r_void
)paren
(brace
r_union
(brace
id|u32
id|small
(braket
l_int|2
)braket
suffix:semicolon
id|u64
id|large
suffix:semicolon
)brace
id|temp
suffix:semicolon
id|u8
id|scratch
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|aper_size_info_8
op_star
id|current_size
suffix:semicolon
id|temp.large
op_assign
l_int|0
suffix:semicolon
id|current_size
op_assign
id|A_SIZE_8
c_func
(paren
id|agp_bridge.current_size
)paren
suffix:semicolon
id|intel_i460_write_agpsiz
c_func
(paren
id|current_size-&gt;size_value
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do the necessary rigmarole to read all eight bytes of APBASE.&n;&t; * This has to be done since the AGP aperture can be above 4GB on&n;&t; * 460 based systems.&n;&t; */
id|pci_read_config_dword
c_func
(paren
id|agp_bridge.dev
comma
id|intel_i460_dynamic_apbase
comma
op_amp
(paren
id|temp.small
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|agp_bridge.dev
comma
id|intel_i460_dynamic_apbase
op_plus
l_int|4
comma
op_amp
(paren
id|temp.small
(braket
l_int|1
)braket
)paren
)paren
suffix:semicolon
multiline_comment|/* Clear BAR control bits */
id|agp_bridge.gart_bus_addr
op_assign
id|temp.large
op_amp
op_complement
(paren
(paren
l_int|1UL
op_lshift
l_int|3
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|agp_bridge.dev
comma
id|INTEL_I460_GXBCTL
comma
op_amp
id|scratch
)paren
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|agp_bridge.dev
comma
id|INTEL_I460_GXBCTL
comma
(paren
id|scratch
op_amp
l_int|0x02
)paren
op_or
id|I460_GXBCTL_OOG
op_or
id|I460_GXBCTL_BWC
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize partial allocation trackers if a GART page is bigger than&n;&t; * a kernel page.&n;&t; */
r_if
c_cond
(paren
id|I460_CPAGES_PER_KPAGE
op_ge
l_int|1
)paren
(brace
id|intel_i460_cpk
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|intel_i460_cpk
op_assign
l_int|0
suffix:semicolon
id|i460_pg_detail
op_assign
id|vmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|i460_pg_detail
)paren
op_star
id|current_size-&gt;num_entries
)paren
suffix:semicolon
id|i460_pg_count
op_assign
id|vmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|i460_pg_count
)paren
op_star
id|current_size-&gt;num_entries
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|current_size-&gt;num_entries
suffix:semicolon
id|i
op_increment
)paren
(brace
id|i460_pg_count
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|i460_pg_detail
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|intel_i460_create_gatt_table
r_static
r_int
id|intel_i460_create_gatt_table
c_func
(paren
r_void
)paren
(brace
r_char
op_star
id|table
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|page_order
suffix:semicolon
r_int
id|num_entries
suffix:semicolon
r_void
op_star
id|temp
suffix:semicolon
multiline_comment|/*&n;&t; * Load up the fixed address of the GART SRAMS which hold our&n;&t; * GATT table.&n;&t; */
id|table
op_assign
(paren
r_char
op_star
)paren
id|__va
c_func
(paren
id|INTEL_I460_ATTBASE
)paren
suffix:semicolon
id|temp
op_assign
id|agp_bridge.current_size
suffix:semicolon
id|page_order
op_assign
id|A_SIZE_8
c_func
(paren
id|temp
)paren
op_member_access_from_pointer
id|page_order
suffix:semicolon
id|num_entries
op_assign
id|A_SIZE_8
c_func
(paren
id|temp
)paren
op_member_access_from_pointer
id|num_entries
suffix:semicolon
id|agp_bridge.gatt_table_real
op_assign
(paren
id|u32
op_star
)paren
id|table
suffix:semicolon
id|agp_bridge.gatt_table
op_assign
id|ioremap_nocache
c_func
(paren
id|virt_to_phys
c_func
(paren
id|table
)paren
comma
(paren
id|PAGE_SIZE
op_star
(paren
l_int|1
op_lshift
id|page_order
)paren
)paren
)paren
suffix:semicolon
id|agp_bridge.gatt_bus_addr
op_assign
id|virt_to_phys
c_func
(paren
id|agp_bridge.gatt_table_real
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_entries
suffix:semicolon
id|i
op_increment
)paren
(brace
id|agp_bridge.gatt_table
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|intel_i460_read_back
c_func
(paren
id|agp_bridge.gatt_table
op_plus
id|i
op_minus
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|intel_i460_free_gatt_table
r_static
r_int
id|intel_i460_free_gatt_table
c_func
(paren
r_void
)paren
(brace
r_int
id|num_entries
suffix:semicolon
r_int
id|i
suffix:semicolon
r_void
op_star
id|temp
suffix:semicolon
id|temp
op_assign
id|agp_bridge.current_size
suffix:semicolon
id|num_entries
op_assign
id|A_SIZE_8
c_func
(paren
id|temp
)paren
op_member_access_from_pointer
id|num_entries
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_entries
suffix:semicolon
id|i
op_increment
)paren
(brace
id|agp_bridge.gatt_table
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|intel_i460_read_back
c_func
(paren
id|agp_bridge.gatt_table
op_plus
id|i
op_minus
l_int|1
)paren
suffix:semicolon
id|iounmap
c_func
(paren
id|agp_bridge.gatt_table
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* These functions are called when PAGE_SIZE exceeds the GART page size */
DECL|function|intel_i460_insert_memory_cpk
r_static
r_int
id|intel_i460_insert_memory_cpk
c_func
(paren
id|agp_memory
op_star
id|mem
comma
id|off_t
id|pg_start
comma
r_int
id|type
)paren
(brace
r_int
id|i
comma
id|j
comma
id|k
comma
id|num_entries
suffix:semicolon
r_void
op_star
id|temp
suffix:semicolon
r_int
r_int
id|paddr
suffix:semicolon
multiline_comment|/*&n;&t; * The rest of the kernel will compute page offsets in terms of&n;&t; * PAGE_SIZE.&n;&t; */
id|pg_start
op_assign
id|I460_CPAGES_PER_KPAGE
op_star
id|pg_start
suffix:semicolon
id|temp
op_assign
id|agp_bridge.current_size
suffix:semicolon
id|num_entries
op_assign
id|A_SIZE_8
c_func
(paren
id|temp
)paren
op_member_access_from_pointer
id|num_entries
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pg_start
op_plus
id|I460_CPAGES_PER_KPAGE
op_star
id|mem-&gt;page_count
)paren
OG
id|num_entries
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;Looks like we&squot;re out of AGP memory&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|j
op_assign
id|pg_start
suffix:semicolon
r_while
c_loop
(paren
id|j
OL
(paren
id|pg_start
op_plus
id|I460_CPAGES_PER_KPAGE
op_star
id|mem-&gt;page_count
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|PGE_EMPTY
c_func
(paren
id|agp_bridge.gatt_table
(braket
id|j
)braket
)paren
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|j
op_increment
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* not necessary since 460 GART is operated in coherent mode... */
r_if
c_cond
(paren
id|mem-&gt;is_flushed
op_eq
id|FALSE
)paren
(brace
id|CACHE_FLUSH
c_func
(paren
)paren
suffix:semicolon
id|mem-&gt;is_flushed
op_assign
id|TRUE
suffix:semicolon
)brace
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
id|pg_start
suffix:semicolon
id|i
OL
id|mem-&gt;page_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|paddr
op_assign
id|mem-&gt;memory
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|I460_CPAGES_PER_KPAGE
suffix:semicolon
id|k
op_increment
comma
id|j
op_increment
comma
id|paddr
op_add_assign
id|intel_i460_pagesize
)paren
id|agp_bridge.gatt_table
(braket
id|j
)braket
op_assign
(paren
id|u32
)paren
id|agp_bridge
dot
id|mask_memory
c_func
(paren
id|paddr
comma
id|mem-&gt;type
)paren
suffix:semicolon
)brace
id|intel_i460_read_back
c_func
(paren
id|agp_bridge.gatt_table
op_plus
id|j
op_minus
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|intel_i460_remove_memory_cpk
r_static
r_int
id|intel_i460_remove_memory_cpk
c_func
(paren
id|agp_memory
op_star
id|mem
comma
id|off_t
id|pg_start
comma
r_int
id|type
)paren
(brace
r_int
id|i
suffix:semicolon
id|pg_start
op_assign
id|I460_CPAGES_PER_KPAGE
op_star
id|pg_start
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|pg_start
suffix:semicolon
id|i
OL
(paren
id|pg_start
op_plus
id|I460_CPAGES_PER_KPAGE
op_star
id|mem-&gt;page_count
)paren
suffix:semicolon
id|i
op_increment
)paren
id|agp_bridge.gatt_table
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|intel_i460_read_back
c_func
(paren
id|agp_bridge.gatt_table
op_plus
id|i
op_minus
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * These functions are called when the GART page size exceeds PAGE_SIZE.&n; *&n; * This situation is interesting since AGP memory allocations that are&n; * smaller than a single GART page are possible.  The structures i460_pg_count&n; * and i460_pg_detail track partial allocation of the large GART pages to&n; * work around this issue.&n; *&n; * i460_pg_count[pg_num] tracks the number of kernel pages in use within&n; * GART page pg_num.  i460_pg_detail[pg_num] is an array containing a&n; * psuedo-GART entry for each of the aforementioned kernel pages.  The whole&n; * of i460_pg_detail is equivalent to a giant GATT with page size equal to&n; * that of the kernel.&n; */
DECL|function|intel_i460_alloc_large_page
r_static
r_void
op_star
id|intel_i460_alloc_large_page
c_func
(paren
r_int
id|pg_num
)paren
(brace
r_int
id|i
suffix:semicolon
r_void
op_star
id|bp
comma
op_star
id|bp_end
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|i460_pg_detail
(braket
id|pg_num
)braket
op_assign
(paren
r_void
op_star
)paren
id|vmalloc
c_func
(paren
r_sizeof
(paren
id|u32
)paren
op_star
id|I460_KPAGES_PER_CPAGE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i460_pg_detail
(braket
id|pg_num
)braket
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;Out of memory, we&squot;re in trouble...&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|I460_KPAGES_PER_CPAGE
suffix:semicolon
id|i
op_increment
)paren
id|i460_pg_detail
(braket
id|pg_num
)braket
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|bp
op_assign
(paren
r_void
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_KERNEL
comma
id|intel_i460_pageshift
op_minus
id|PAGE_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;Couldn&squot;t alloc 4M GART page...&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|bp_end
op_assign
id|bp
op_plus
(paren
(paren
id|PAGE_SIZE
op_star
(paren
l_int|1
op_lshift
(paren
id|intel_i460_pageshift
op_minus
id|PAGE_SHIFT
)paren
)paren
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|page
op_assign
id|virt_to_page
c_func
(paren
id|bp
)paren
suffix:semicolon
id|page
op_le
id|virt_to_page
c_func
(paren
id|bp_end
)paren
suffix:semicolon
id|page
op_increment
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|agp_bridge.current_memory_agp
)paren
suffix:semicolon
)brace
r_return
id|bp
suffix:semicolon
)brace
DECL|function|intel_i460_free_large_page
r_static
r_void
id|intel_i460_free_large_page
c_func
(paren
r_int
id|pg_num
comma
r_int
r_int
id|addr
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_void
op_star
id|bp
comma
op_star
id|bp_end
suffix:semicolon
id|bp
op_assign
(paren
r_void
op_star
)paren
id|__va
c_func
(paren
id|addr
)paren
suffix:semicolon
id|bp_end
op_assign
id|bp
op_plus
(paren
id|PAGE_SIZE
op_star
(paren
l_int|1
op_lshift
(paren
id|intel_i460_pageshift
op_minus
id|PAGE_SHIFT
)paren
)paren
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|i460_pg_detail
(braket
id|pg_num
)braket
)paren
suffix:semicolon
id|i460_pg_detail
(braket
id|pg_num
)braket
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|page
op_assign
id|virt_to_page
c_func
(paren
id|bp
)paren
suffix:semicolon
id|page
OL
id|virt_to_page
c_func
(paren
id|bp_end
)paren
suffix:semicolon
id|page
op_increment
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
id|agp_bridge.current_memory_agp
)paren
suffix:semicolon
)brace
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|bp
comma
id|intel_i460_pageshift
op_minus
id|PAGE_SHIFT
)paren
suffix:semicolon
)brace
DECL|function|intel_i460_insert_memory_kpc
r_static
r_int
id|intel_i460_insert_memory_kpc
c_func
(paren
id|agp_memory
op_star
id|mem
comma
id|off_t
id|pg_start
comma
r_int
id|type
)paren
(brace
r_int
id|i
comma
id|pg
comma
id|start_pg
comma
id|end_pg
comma
id|start_offset
comma
id|end_offset
comma
id|idx
suffix:semicolon
r_int
id|num_entries
suffix:semicolon
r_void
op_star
id|temp
suffix:semicolon
r_int
r_int
id|paddr
suffix:semicolon
id|temp
op_assign
id|agp_bridge.current_size
suffix:semicolon
id|num_entries
op_assign
id|A_SIZE_8
c_func
(paren
id|temp
)paren
op_member_access_from_pointer
id|num_entries
suffix:semicolon
multiline_comment|/* Figure out what pg_start means in terms of our large GART pages */
id|start_pg
op_assign
id|pg_start
op_div
id|I460_KPAGES_PER_CPAGE
suffix:semicolon
id|start_offset
op_assign
id|pg_start
op_mod
id|I460_KPAGES_PER_CPAGE
suffix:semicolon
id|end_pg
op_assign
(paren
id|pg_start
op_plus
id|mem-&gt;page_count
op_minus
l_int|1
)paren
op_div
id|I460_KPAGES_PER_CPAGE
suffix:semicolon
id|end_offset
op_assign
(paren
id|pg_start
op_plus
id|mem-&gt;page_count
op_minus
l_int|1
)paren
op_mod
id|I460_KPAGES_PER_CPAGE
suffix:semicolon
r_if
c_cond
(paren
id|end_pg
OG
id|num_entries
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;Looks like we&squot;re out of AGP memory&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Check if the requested region of the aperture is free */
r_for
c_loop
(paren
id|pg
op_assign
id|start_pg
suffix:semicolon
id|pg
op_le
id|end_pg
suffix:semicolon
id|pg
op_increment
)paren
(brace
multiline_comment|/* Allocate new GART pages if necessary */
r_if
c_cond
(paren
id|i460_pg_detail
(braket
id|pg
)braket
op_eq
l_int|NULL
)paren
(brace
id|temp
op_assign
id|intel_i460_alloc_large_page
c_func
(paren
id|pg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|temp
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|agp_bridge.gatt_table
(braket
id|pg
)braket
op_assign
id|agp_bridge
dot
id|mask_memory
c_func
(paren
(paren
r_int
r_int
)paren
id|temp
comma
l_int|0
)paren
suffix:semicolon
id|intel_i460_read_back
c_func
(paren
id|agp_bridge.gatt_table
op_plus
id|pg
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|idx
op_assign
(paren
(paren
id|pg
op_eq
id|start_pg
)paren
ques
c_cond
id|start_offset
suffix:colon
l_int|0
)paren
suffix:semicolon
id|idx
OL
(paren
(paren
id|pg
op_eq
id|end_pg
)paren
ques
c_cond
(paren
id|end_offset
op_plus
l_int|1
)paren
suffix:colon
id|I460_KPAGES_PER_CPAGE
)paren
suffix:semicolon
id|idx
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i460_pg_detail
(braket
id|pg
)braket
(braket
id|idx
)braket
op_ne
l_int|0
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
)brace
macro_line|#if 0
multiline_comment|/* not necessary since 460 GART is operated in coherent mode... */
r_if
c_cond
(paren
id|mem-&gt;is_flushed
op_eq
id|FALSE
)paren
(brace
id|CACHE_FLUSH
c_func
(paren
)paren
suffix:semicolon
id|mem-&gt;is_flushed
op_assign
id|TRUE
suffix:semicolon
)brace
macro_line|#endif
r_for
c_loop
(paren
id|pg
op_assign
id|start_pg
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|pg
op_le
id|end_pg
suffix:semicolon
id|pg
op_increment
)paren
(brace
id|paddr
op_assign
id|agp_bridge
dot
id|unmask_memory
c_func
(paren
id|agp_bridge.gatt_table
(braket
id|pg
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
(paren
(paren
id|pg
op_eq
id|start_pg
)paren
ques
c_cond
id|start_offset
suffix:colon
l_int|0
)paren
suffix:semicolon
id|idx
OL
(paren
(paren
id|pg
op_eq
id|end_pg
)paren
ques
c_cond
(paren
id|end_offset
op_plus
l_int|1
)paren
suffix:colon
id|I460_KPAGES_PER_CPAGE
)paren
suffix:semicolon
id|idx
op_increment
comma
id|i
op_increment
)paren
(brace
id|mem-&gt;memory
(braket
id|i
)braket
op_assign
id|paddr
op_plus
(paren
id|idx
op_star
id|PAGE_SIZE
)paren
suffix:semicolon
id|i460_pg_detail
(braket
id|pg
)braket
(braket
id|idx
)braket
op_assign
id|agp_bridge
dot
id|mask_memory
c_func
(paren
id|mem-&gt;memory
(braket
id|i
)braket
comma
id|mem-&gt;type
)paren
suffix:semicolon
id|i460_pg_count
(braket
id|pg
)braket
op_increment
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|intel_i460_remove_memory_kpc
r_static
r_int
id|intel_i460_remove_memory_kpc
c_func
(paren
id|agp_memory
op_star
id|mem
comma
id|off_t
id|pg_start
comma
r_int
id|type
)paren
(brace
r_int
id|i
comma
id|pg
comma
id|start_pg
comma
id|end_pg
comma
id|start_offset
comma
id|end_offset
comma
id|idx
suffix:semicolon
r_int
id|num_entries
suffix:semicolon
r_void
op_star
id|temp
suffix:semicolon
r_int
r_int
id|paddr
suffix:semicolon
id|temp
op_assign
id|agp_bridge.current_size
suffix:semicolon
id|num_entries
op_assign
id|A_SIZE_8
c_func
(paren
id|temp
)paren
op_member_access_from_pointer
id|num_entries
suffix:semicolon
multiline_comment|/* Figure out what pg_start means in terms of our large GART pages */
id|start_pg
op_assign
id|pg_start
op_div
id|I460_KPAGES_PER_CPAGE
suffix:semicolon
id|start_offset
op_assign
id|pg_start
op_mod
id|I460_KPAGES_PER_CPAGE
suffix:semicolon
id|end_pg
op_assign
(paren
id|pg_start
op_plus
id|mem-&gt;page_count
op_minus
l_int|1
)paren
op_div
id|I460_KPAGES_PER_CPAGE
suffix:semicolon
id|end_offset
op_assign
(paren
id|pg_start
op_plus
id|mem-&gt;page_count
op_minus
l_int|1
)paren
op_mod
id|I460_KPAGES_PER_CPAGE
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|pg
op_assign
id|start_pg
suffix:semicolon
id|pg
op_le
id|end_pg
suffix:semicolon
id|pg
op_increment
)paren
(brace
r_for
c_loop
(paren
id|idx
op_assign
(paren
(paren
id|pg
op_eq
id|start_pg
)paren
ques
c_cond
id|start_offset
suffix:colon
l_int|0
)paren
suffix:semicolon
id|idx
OL
(paren
(paren
id|pg
op_eq
id|end_pg
)paren
ques
c_cond
(paren
id|end_offset
op_plus
l_int|1
)paren
suffix:colon
id|I460_KPAGES_PER_CPAGE
)paren
suffix:semicolon
id|idx
op_increment
comma
id|i
op_increment
)paren
(brace
id|mem-&gt;memory
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|i460_pg_detail
(braket
id|pg
)braket
(braket
id|idx
)braket
op_assign
l_int|0
suffix:semicolon
id|i460_pg_count
(braket
id|pg
)braket
op_decrement
suffix:semicolon
)brace
multiline_comment|/* Free GART pages if they are unused */
r_if
c_cond
(paren
id|i460_pg_count
(braket
id|pg
)braket
op_eq
l_int|0
)paren
(brace
id|paddr
op_assign
id|agp_bridge
dot
id|unmask_memory
c_func
(paren
id|agp_bridge.gatt_table
(braket
id|pg
)braket
)paren
suffix:semicolon
id|agp_bridge.gatt_table
(braket
id|pg
)braket
op_assign
id|agp_bridge.scratch_page
suffix:semicolon
id|intel_i460_read_back
c_func
(paren
id|agp_bridge.gatt_table
op_plus
id|pg
)paren
suffix:semicolon
id|intel_i460_free_large_page
c_func
(paren
id|pg
comma
id|paddr
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Dummy routines to call the approriate {cpk,kpc} function */
DECL|function|intel_i460_insert_memory
r_static
r_int
id|intel_i460_insert_memory
c_func
(paren
id|agp_memory
op_star
id|mem
comma
id|off_t
id|pg_start
comma
r_int
id|type
)paren
(brace
r_if
c_cond
(paren
id|intel_i460_cpk
)paren
r_return
id|intel_i460_insert_memory_cpk
c_func
(paren
id|mem
comma
id|pg_start
comma
id|type
)paren
suffix:semicolon
r_else
r_return
id|intel_i460_insert_memory_kpc
c_func
(paren
id|mem
comma
id|pg_start
comma
id|type
)paren
suffix:semicolon
)brace
DECL|function|intel_i460_remove_memory
r_static
r_int
id|intel_i460_remove_memory
c_func
(paren
id|agp_memory
op_star
id|mem
comma
id|off_t
id|pg_start
comma
r_int
id|type
)paren
(brace
r_if
c_cond
(paren
id|intel_i460_cpk
)paren
r_return
id|intel_i460_remove_memory_cpk
c_func
(paren
id|mem
comma
id|pg_start
comma
id|type
)paren
suffix:semicolon
r_else
r_return
id|intel_i460_remove_memory_kpc
c_func
(paren
id|mem
comma
id|pg_start
comma
id|type
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * If the kernel page size is smaller that the chipset page size, we don&squot;t&n; * want to allocate memory until we know where it is to be bound in the&n; * aperture (a multi-kernel-page alloc might fit inside of an already&n; * allocated GART page).  Consequently, don&squot;t allocate or free anything&n; * if i460_cpk (meaning chipset pages per kernel page) isn&squot;t set.&n; *&n; * Let&squot;s just hope nobody counts on the allocated AGP memory being there&n; * before bind time (I don&squot;t think current drivers do)...&n; */
DECL|function|intel_i460_alloc_page
r_static
r_void
op_star
id|intel_i460_alloc_page
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|intel_i460_cpk
)paren
r_return
id|agp_generic_alloc_page
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Returning NULL would cause problems */
multiline_comment|/* AK: really dubious code. */
r_return
(paren
r_void
op_star
)paren
op_complement
l_int|0UL
suffix:semicolon
)brace
DECL|function|intel_i460_destroy_page
r_static
r_void
id|intel_i460_destroy_page
c_func
(paren
r_void
op_star
id|page
)paren
(brace
r_if
c_cond
(paren
id|intel_i460_cpk
)paren
id|agp_generic_destroy_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
DECL|variable|intel_i460_masks
r_static
r_struct
id|gatt_mask
id|intel_i460_masks
(braket
)braket
op_assign
(brace
(brace
dot
id|mask
op_assign
id|INTEL_I460_GATT_VALID
op_or
id|INTEL_I460_GATT_COHERENT
comma
dot
id|type
op_assign
l_int|0
)brace
)brace
suffix:semicolon
DECL|function|intel_i460_mask_memory
r_static
r_int
r_int
id|intel_i460_mask_memory
c_func
(paren
r_int
r_int
id|addr
comma
r_int
id|type
)paren
(brace
multiline_comment|/* Make sure the returned address is a valid GATT entry */
r_return
(paren
id|agp_bridge.masks
(braket
l_int|0
)braket
dot
id|mask
op_or
(paren
(paren
(paren
id|addr
op_amp
op_complement
(paren
(paren
l_int|1
op_lshift
id|intel_i460_pageshift
)paren
op_minus
l_int|1
)paren
)paren
op_amp
l_int|0xffffff000
)paren
op_rshift
l_int|12
)paren
)paren
suffix:semicolon
)brace
DECL|function|intel_i460_unmask_memory
r_static
r_int
r_int
id|intel_i460_unmask_memory
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
multiline_comment|/* Turn a GATT entry into a physical address */
r_return
(paren
(paren
id|addr
op_amp
l_int|0xffffff
)paren
op_lshift
l_int|12
)paren
suffix:semicolon
)brace
DECL|variable|intel_i460_sizes
r_static
r_struct
id|aper_size_info_8
id|intel_i460_sizes
(braket
l_int|3
)braket
op_assign
(brace
multiline_comment|/*&n;&t; * The 32GB aperture is only available with a 4M GART page size.&n;&t; * Due to the dynamic GART page size, we can&squot;t figure out page_order&n;&t; * or num_entries until runtime.&n;&t; */
(brace
l_int|32768
comma
l_int|0
comma
l_int|0
comma
l_int|4
)brace
comma
(brace
l_int|1024
comma
l_int|0
comma
l_int|0
comma
l_int|2
)brace
comma
(brace
l_int|256
comma
l_int|0
comma
l_int|0
comma
l_int|1
)brace
)brace
suffix:semicolon
DECL|function|intel_i460_setup
r_int
id|__init
id|intel_i460_setup
(paren
r_struct
id|pci_dev
op_star
id|pdev
id|__attribute__
c_func
(paren
(paren
id|unused
)paren
)paren
)paren
(brace
id|agp_bridge.masks
op_assign
id|intel_i460_masks
suffix:semicolon
id|agp_bridge.aperture_sizes
op_assign
(paren
r_void
op_star
)paren
id|intel_i460_sizes
suffix:semicolon
id|agp_bridge.size_type
op_assign
id|U8_APER_SIZE
suffix:semicolon
id|agp_bridge.num_aperture_sizes
op_assign
l_int|3
suffix:semicolon
id|agp_bridge.dev_private_data
op_assign
l_int|NULL
suffix:semicolon
id|agp_bridge.needs_scratch_page
op_assign
id|FALSE
suffix:semicolon
id|agp_bridge.configure
op_assign
id|intel_i460_configure
suffix:semicolon
id|agp_bridge.fetch_size
op_assign
id|intel_i460_fetch_size
suffix:semicolon
id|agp_bridge.cleanup
op_assign
id|intel_i460_cleanup
suffix:semicolon
id|agp_bridge.tlb_flush
op_assign
id|intel_i460_tlb_flush
suffix:semicolon
id|agp_bridge.mask_memory
op_assign
id|intel_i460_mask_memory
suffix:semicolon
id|agp_bridge.unmask_memory
op_assign
id|intel_i460_unmask_memory
suffix:semicolon
id|agp_bridge.agp_enable
op_assign
id|agp_generic_agp_enable
suffix:semicolon
id|agp_bridge.cache_flush
op_assign
id|global_cache_flush
suffix:semicolon
id|agp_bridge.create_gatt_table
op_assign
id|intel_i460_create_gatt_table
suffix:semicolon
id|agp_bridge.free_gatt_table
op_assign
id|intel_i460_free_gatt_table
suffix:semicolon
id|agp_bridge.insert_memory
op_assign
id|intel_i460_insert_memory
suffix:semicolon
id|agp_bridge.remove_memory
op_assign
id|intel_i460_remove_memory
suffix:semicolon
id|agp_bridge.alloc_by_type
op_assign
id|agp_generic_alloc_by_type
suffix:semicolon
id|agp_bridge.free_by_type
op_assign
id|agp_generic_free_by_type
suffix:semicolon
id|agp_bridge.agp_alloc_page
op_assign
id|intel_i460_alloc_page
suffix:semicolon
id|agp_bridge.agp_destroy_page
op_assign
id|intel_i460_destroy_page
suffix:semicolon
id|agp_bridge.suspend
op_assign
id|agp_generic_suspend
suffix:semicolon
id|agp_bridge.resume
op_assign
id|agp_generic_resume
suffix:semicolon
id|agp_bridge.cant_use_aperture
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
