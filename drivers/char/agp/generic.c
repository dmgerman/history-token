multiline_comment|/*&n; * AGPGART driver.&n; * Copyright (C) 2002-2004 Dave Jones.&n; * Copyright (C) 1999 Jeff Hartmann.&n; * Copyright (C) 1999 Precision Insight, Inc.&n; * Copyright (C) 1999 Xi Graphics, Inc.&n; *&n; * Permission is hereby granted, free of charge, to any person obtaining a&n; * copy of this software and associated documentation files (the &quot;Software&quot;),&n; * to deal in the Software without restriction, including without limitation&n; * the rights to use, copy, modify, merge, publish, distribute, sublicense,&n; * and/or sell copies of the Software, and to permit persons to whom the&n; * Software is furnished to do so, subject to the following conditions:&n; *&n; * The above copyright notice and this permission notice shall be included&n; * in all copies or substantial portions of the Software.&n; *&n; * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS&n; * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,&n; * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL&n; * JEFF HARTMANN, OR ANY OTHER CONTRIBUTORS BE LIABLE FOR ANY CLAIM,&n; * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR&n; * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE&n; * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.&n; *&n; * TODO:&n; * - Allocate more than order 0 pages to avoid too much linear map splitting.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/miscdevice.h&gt;
macro_line|#include &lt;linux/pm.h&gt;
macro_line|#include &lt;linux/agp_backend.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/cacheflush.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &quot;agp.h&quot;
DECL|variable|agp_gatt_table
id|__u32
op_star
id|agp_gatt_table
suffix:semicolon
DECL|variable|agp_memory_reserved
r_int
id|agp_memory_reserved
suffix:semicolon
multiline_comment|/*&n; * Needed by the Nforce GART driver for the time being. Would be&n; * nice to do this some other way instead of needing this export.&n; */
DECL|variable|agp_memory_reserved
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|agp_memory_reserved
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_X86)
DECL|function|map_page_into_agp
r_int
id|map_page_into_agp
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_int
id|i
suffix:semicolon
id|i
op_assign
id|change_page_attr
c_func
(paren
id|page
comma
l_int|1
comma
id|PAGE_KERNEL_NOCACHE
)paren
suffix:semicolon
id|global_flush_tlb
c_func
(paren
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
DECL|variable|map_page_into_agp
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|map_page_into_agp
)paren
suffix:semicolon
DECL|function|unmap_page_from_agp
r_int
id|unmap_page_from_agp
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_int
id|i
suffix:semicolon
id|i
op_assign
id|change_page_attr
c_func
(paren
id|page
comma
l_int|1
comma
id|PAGE_KERNEL
)paren
suffix:semicolon
id|global_flush_tlb
c_func
(paren
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
DECL|variable|unmap_page_from_agp
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|unmap_page_from_agp
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Generic routines for handling agp_memory structures -&n; * They use the basic page allocation routines to do the brunt of the work.&n; */
DECL|function|agp_free_key
r_void
id|agp_free_key
c_func
(paren
r_int
id|key
)paren
(brace
r_if
c_cond
(paren
id|key
OL
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|key
OL
id|MAXKEY
)paren
id|clear_bit
c_func
(paren
id|key
comma
id|agp_bridge-&gt;key_list
)paren
suffix:semicolon
)brace
DECL|variable|agp_free_key
id|EXPORT_SYMBOL
c_func
(paren
id|agp_free_key
)paren
suffix:semicolon
DECL|function|agp_get_key
r_static
r_int
id|agp_get_key
c_func
(paren
r_void
)paren
(brace
r_int
id|bit
suffix:semicolon
id|bit
op_assign
id|find_first_zero_bit
c_func
(paren
id|agp_bridge-&gt;key_list
comma
id|MAXKEY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bit
OL
id|MAXKEY
)paren
(brace
id|set_bit
c_func
(paren
id|bit
comma
id|agp_bridge-&gt;key_list
)paren
suffix:semicolon
r_return
id|bit
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|agp_create_memory
r_struct
id|agp_memory
op_star
id|agp_create_memory
c_func
(paren
r_int
id|scratch_pages
)paren
(brace
r_struct
id|agp_memory
op_star
r_new
suffix:semicolon
r_new
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|agp_memory
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
r_new
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|agp_memory
)paren
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|key
op_assign
id|agp_get_key
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
op_member_access_from_pointer
id|key
OL
l_int|0
)paren
(brace
id|kfree
c_func
(paren
r_new
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_new
op_member_access_from_pointer
id|memory
op_assign
id|vmalloc
c_func
(paren
id|PAGE_SIZE
op_star
id|scratch_pages
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
op_member_access_from_pointer
id|memory
op_eq
l_int|NULL
)paren
(brace
id|agp_free_key
c_func
(paren
r_new
op_member_access_from_pointer
id|key
)paren
suffix:semicolon
id|kfree
c_func
(paren
r_new
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_new
op_member_access_from_pointer
id|num_scratch_pages
op_assign
id|scratch_pages
suffix:semicolon
r_return
r_new
suffix:semicolon
)brace
DECL|variable|agp_create_memory
id|EXPORT_SYMBOL
c_func
(paren
id|agp_create_memory
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;agp_free_memory - free memory associated with an agp_memory pointer.&n; *&n; *&t;@curr:&t;&t;agp_memory pointer to be freed.&n; *&n; *&t;It is the only function that can be called when the backend is not owned&n; *&t;by the caller.  (So it can free memory on client death.)&n; */
DECL|function|agp_free_memory
r_void
id|agp_free_memory
c_func
(paren
r_struct
id|agp_memory
op_star
id|curr
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|agp_bridge-&gt;type
op_eq
id|NOT_SUPPORTED
)paren
op_logical_or
(paren
id|curr
op_eq
l_int|NULL
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|curr-&gt;is_bound
op_eq
id|TRUE
)paren
id|agp_unbind_memory
c_func
(paren
id|curr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|curr-&gt;type
op_ne
l_int|0
)paren
(brace
id|agp_bridge-&gt;driver
op_member_access_from_pointer
id|free_by_type
c_func
(paren
id|curr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|curr-&gt;page_count
op_ne
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|curr-&gt;page_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|agp_bridge-&gt;driver
op_member_access_from_pointer
id|agp_destroy_page
c_func
(paren
id|phys_to_virt
c_func
(paren
id|curr-&gt;memory
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
)brace
)brace
id|agp_free_key
c_func
(paren
id|curr-&gt;key
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|curr-&gt;memory
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|curr
)paren
suffix:semicolon
)brace
DECL|variable|agp_free_memory
id|EXPORT_SYMBOL
c_func
(paren
id|agp_free_memory
)paren
suffix:semicolon
DECL|macro|ENTRIES_PER_PAGE
mdefine_line|#define ENTRIES_PER_PAGE&t;&t;(PAGE_SIZE / sizeof(unsigned long))
multiline_comment|/**&n; *&t;agp_allocate_memory  -  allocate a group of pages of a certain type.&n; *&n; *&t;@page_count:&t;size_t argument of the number of pages&n; *&t;@type:&t;u32 argument of the type of memory to be allocated.&n; *&n; *&t;Every agp bridge device will allow you to allocate AGP_NORMAL_MEMORY which&n; *&t;maps to physical ram.  Any other type is device dependent.&n; *&n; *&t;It returns NULL whenever memory is unavailable.&n; */
DECL|function|agp_allocate_memory
r_struct
id|agp_memory
op_star
id|agp_allocate_memory
c_func
(paren
r_int
id|page_count
comma
id|u32
id|type
)paren
(brace
r_int
id|scratch_pages
suffix:semicolon
r_struct
id|agp_memory
op_star
r_new
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|agp_bridge-&gt;type
op_eq
id|NOT_SUPPORTED
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|atomic_read
c_func
(paren
op_amp
id|agp_bridge-&gt;current_memory_agp
)paren
op_plus
id|page_count
)paren
OG
id|agp_bridge-&gt;max_memory_agp
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
l_int|0
)paren
(brace
r_new
op_assign
id|agp_bridge-&gt;driver
op_member_access_from_pointer
id|alloc_by_type
c_func
(paren
id|page_count
comma
id|type
)paren
suffix:semicolon
r_return
r_new
suffix:semicolon
)brace
id|scratch_pages
op_assign
(paren
id|page_count
op_plus
id|ENTRIES_PER_PAGE
op_minus
l_int|1
)paren
op_div
id|ENTRIES_PER_PAGE
suffix:semicolon
r_new
op_assign
id|agp_create_memory
c_func
(paren
id|scratch_pages
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|page_count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_void
op_star
id|addr
op_assign
id|agp_bridge-&gt;driver
op_member_access_from_pointer
id|agp_alloc_page
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_eq
l_int|NULL
)paren
(brace
id|agp_free_memory
c_func
(paren
r_new
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_new
op_member_access_from_pointer
id|memory
(braket
id|i
)braket
op_assign
id|virt_to_phys
c_func
(paren
id|addr
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|page_count
op_increment
suffix:semicolon
)brace
id|flush_agp_mappings
c_func
(paren
)paren
suffix:semicolon
r_return
r_new
suffix:semicolon
)brace
DECL|variable|agp_allocate_memory
id|EXPORT_SYMBOL
c_func
(paren
id|agp_allocate_memory
)paren
suffix:semicolon
multiline_comment|/* End - Generic routines for handling agp_memory structures */
DECL|function|agp_return_size
r_static
r_int
id|agp_return_size
c_func
(paren
r_void
)paren
(brace
r_int
id|current_size
suffix:semicolon
r_void
op_star
id|temp
suffix:semicolon
id|temp
op_assign
id|agp_bridge-&gt;current_size
suffix:semicolon
r_switch
c_cond
(paren
id|agp_bridge-&gt;driver-&gt;size_type
)paren
(brace
r_case
id|U8_APER_SIZE
suffix:colon
id|current_size
op_assign
id|A_SIZE_8
c_func
(paren
id|temp
)paren
op_member_access_from_pointer
id|size
suffix:semicolon
r_break
suffix:semicolon
r_case
id|U16_APER_SIZE
suffix:colon
id|current_size
op_assign
id|A_SIZE_16
c_func
(paren
id|temp
)paren
op_member_access_from_pointer
id|size
suffix:semicolon
r_break
suffix:semicolon
r_case
id|U32_APER_SIZE
suffix:colon
id|current_size
op_assign
id|A_SIZE_32
c_func
(paren
id|temp
)paren
op_member_access_from_pointer
id|size
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LVL2_APER_SIZE
suffix:colon
id|current_size
op_assign
id|A_SIZE_LVL2
c_func
(paren
id|temp
)paren
op_member_access_from_pointer
id|size
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FIXED_APER_SIZE
suffix:colon
id|current_size
op_assign
id|A_SIZE_FIX
c_func
(paren
id|temp
)paren
op_member_access_from_pointer
id|size
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|current_size
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|current_size
op_sub_assign
(paren
id|agp_memory_reserved
op_div
(paren
l_int|1024
op_star
l_int|1024
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current_size
OL
l_int|0
)paren
id|current_size
op_assign
l_int|0
suffix:semicolon
r_return
id|current_size
suffix:semicolon
)brace
DECL|function|agp_num_entries
r_int
id|agp_num_entries
c_func
(paren
r_void
)paren
(brace
r_int
id|num_entries
suffix:semicolon
r_void
op_star
id|temp
suffix:semicolon
id|temp
op_assign
id|agp_bridge-&gt;current_size
suffix:semicolon
r_switch
c_cond
(paren
id|agp_bridge-&gt;driver-&gt;size_type
)paren
(brace
r_case
id|U8_APER_SIZE
suffix:colon
id|num_entries
op_assign
id|A_SIZE_8
c_func
(paren
id|temp
)paren
op_member_access_from_pointer
id|num_entries
suffix:semicolon
r_break
suffix:semicolon
r_case
id|U16_APER_SIZE
suffix:colon
id|num_entries
op_assign
id|A_SIZE_16
c_func
(paren
id|temp
)paren
op_member_access_from_pointer
id|num_entries
suffix:semicolon
r_break
suffix:semicolon
r_case
id|U32_APER_SIZE
suffix:colon
id|num_entries
op_assign
id|A_SIZE_32
c_func
(paren
id|temp
)paren
op_member_access_from_pointer
id|num_entries
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LVL2_APER_SIZE
suffix:colon
id|num_entries
op_assign
id|A_SIZE_LVL2
c_func
(paren
id|temp
)paren
op_member_access_from_pointer
id|num_entries
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FIXED_APER_SIZE
suffix:colon
id|num_entries
op_assign
id|A_SIZE_FIX
c_func
(paren
id|temp
)paren
op_member_access_from_pointer
id|num_entries
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|num_entries
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|num_entries
op_sub_assign
id|agp_memory_reserved
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|num_entries
OL
l_int|0
)paren
id|num_entries
op_assign
l_int|0
suffix:semicolon
r_return
id|num_entries
suffix:semicolon
)brace
DECL|variable|agp_num_entries
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|agp_num_entries
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;agp_copy_info  -  copy bridge state information&n; *&n; *&t;@info:&t;&t;agp_kern_info pointer.  The caller should insure that this pointer is valid. &n; *&n; *&t;This function copies information about the agp bridge device and the state of&n; *&t;the agp backend into an agp_kern_info pointer.&n; */
DECL|function|agp_copy_info
r_int
id|agp_copy_info
c_func
(paren
r_struct
id|agp_kern_info
op_star
id|info
)paren
(brace
id|memset
c_func
(paren
id|info
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|agp_kern_info
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|agp_bridge
op_logical_or
id|agp_bridge-&gt;type
op_eq
id|NOT_SUPPORTED
op_logical_or
op_logical_neg
id|agp_bridge-&gt;version
)paren
(brace
id|info-&gt;chipset
op_assign
id|NOT_SUPPORTED
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|info-&gt;version.major
op_assign
id|agp_bridge-&gt;version-&gt;major
suffix:semicolon
id|info-&gt;version.minor
op_assign
id|agp_bridge-&gt;version-&gt;minor
suffix:semicolon
id|info-&gt;chipset
op_assign
id|agp_bridge-&gt;type
suffix:semicolon
id|info-&gt;device
op_assign
id|agp_bridge-&gt;dev
suffix:semicolon
id|info-&gt;mode
op_assign
id|agp_bridge-&gt;mode
suffix:semicolon
id|info-&gt;aper_base
op_assign
id|agp_bridge-&gt;gart_bus_addr
suffix:semicolon
id|info-&gt;aper_size
op_assign
id|agp_return_size
c_func
(paren
)paren
suffix:semicolon
id|info-&gt;max_memory
op_assign
id|agp_bridge-&gt;max_memory_agp
suffix:semicolon
id|info-&gt;current_memory
op_assign
id|atomic_read
c_func
(paren
op_amp
id|agp_bridge-&gt;current_memory_agp
)paren
suffix:semicolon
id|info-&gt;cant_use_aperture
op_assign
id|agp_bridge-&gt;driver-&gt;cant_use_aperture
suffix:semicolon
id|info-&gt;vm_ops
op_assign
id|agp_bridge-&gt;vm_ops
suffix:semicolon
id|info-&gt;page_mask
op_assign
op_complement
l_int|0UL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|agp_copy_info
id|EXPORT_SYMBOL
c_func
(paren
id|agp_copy_info
)paren
suffix:semicolon
multiline_comment|/* End - Routine to copy over information structure */
multiline_comment|/*&n; * Routines for handling swapping of agp_memory into the GATT -&n; * These routines take agp_memory and insert them into the GATT.&n; * They call device specific routines to actually write to the GATT.&n; */
multiline_comment|/**&n; *&t;agp_bind_memory  -  Bind an agp_memory structure into the GATT.&n; *&n; *&t;@curr:&t;&t;agp_memory pointer&n; *&t;@pg_start:&t;an offset into the graphics aperture translation table&n; *&n; *&t;It returns -EINVAL if the pointer == NULL.&n; *&t;It returns -EBUSY if the area of the table requested is already in use.&n; */
DECL|function|agp_bind_memory
r_int
id|agp_bind_memory
c_func
(paren
r_struct
id|agp_memory
op_star
id|curr
comma
id|off_t
id|pg_start
)paren
(brace
r_int
id|ret_val
suffix:semicolon
r_if
c_cond
(paren
(paren
id|agp_bridge-&gt;type
op_eq
id|NOT_SUPPORTED
)paren
op_logical_or
(paren
id|curr
op_eq
l_int|NULL
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|curr-&gt;is_bound
op_eq
id|TRUE
)paren
(brace
id|printk
(paren
id|KERN_INFO
id|PFX
l_string|&quot;memory %p is already bound!&bslash;n&quot;
comma
id|curr
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|curr-&gt;is_flushed
op_eq
id|FALSE
)paren
(brace
id|agp_bridge-&gt;driver
op_member_access_from_pointer
id|cache_flush
c_func
(paren
)paren
suffix:semicolon
id|curr-&gt;is_flushed
op_assign
id|TRUE
suffix:semicolon
)brace
id|ret_val
op_assign
id|agp_bridge-&gt;driver
op_member_access_from_pointer
id|insert_memory
c_func
(paren
id|curr
comma
id|pg_start
comma
id|curr-&gt;type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret_val
op_ne
l_int|0
)paren
r_return
id|ret_val
suffix:semicolon
id|curr-&gt;is_bound
op_assign
id|TRUE
suffix:semicolon
id|curr-&gt;pg_start
op_assign
id|pg_start
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|agp_bind_memory
id|EXPORT_SYMBOL
c_func
(paren
id|agp_bind_memory
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;agp_unbind_memory  -  Removes an agp_memory structure from the GATT&n; *&n; * @curr:&t;agp_memory pointer to be removed from the GATT.&n; *&n; * It returns -EINVAL if this piece of agp_memory is not currently bound to&n; * the graphics aperture translation table or if the agp_memory pointer == NULL&n; */
DECL|function|agp_unbind_memory
r_int
id|agp_unbind_memory
c_func
(paren
r_struct
id|agp_memory
op_star
id|curr
)paren
(brace
r_int
id|ret_val
suffix:semicolon
r_if
c_cond
(paren
(paren
id|agp_bridge-&gt;type
op_eq
id|NOT_SUPPORTED
)paren
op_logical_or
(paren
id|curr
op_eq
l_int|NULL
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|curr-&gt;is_bound
op_ne
id|TRUE
)paren
(brace
id|printk
(paren
id|KERN_INFO
id|PFX
l_string|&quot;memory %p was not bound!&bslash;n&quot;
comma
id|curr
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ret_val
op_assign
id|agp_bridge-&gt;driver
op_member_access_from_pointer
id|remove_memory
c_func
(paren
id|curr
comma
id|curr-&gt;pg_start
comma
id|curr-&gt;type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret_val
op_ne
l_int|0
)paren
r_return
id|ret_val
suffix:semicolon
id|curr-&gt;is_bound
op_assign
id|FALSE
suffix:semicolon
id|curr-&gt;pg_start
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|agp_unbind_memory
id|EXPORT_SYMBOL
c_func
(paren
id|agp_unbind_memory
)paren
suffix:semicolon
multiline_comment|/* End - Routines for handling swapping of agp_memory into the GATT */
multiline_comment|/* Generic Agp routines - Start */
DECL|function|agp_v2_parse_one
r_static
r_void
id|agp_v2_parse_one
c_func
(paren
id|u32
op_star
id|mode
comma
id|u32
op_star
id|cmd
comma
id|u32
op_star
id|tmp
)paren
(brace
multiline_comment|/* disable SBA if it&squot;s not supported */
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
op_star
id|cmd
op_amp
id|AGPSTAT_SBA
)paren
op_logical_and
(paren
op_star
id|tmp
op_amp
id|AGPSTAT_SBA
)paren
op_logical_and
(paren
op_star
id|mode
op_amp
id|AGPSTAT_SBA
)paren
)paren
)paren
op_star
id|cmd
op_and_assign
op_complement
id|AGPSTAT_SBA
suffix:semicolon
multiline_comment|/* Set speed */
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
op_star
id|cmd
op_amp
id|AGPSTAT2_4X
)paren
op_logical_and
(paren
op_star
id|tmp
op_amp
id|AGPSTAT2_4X
)paren
op_logical_and
(paren
op_star
id|mode
op_amp
id|AGPSTAT2_4X
)paren
)paren
)paren
op_star
id|cmd
op_and_assign
op_complement
id|AGPSTAT2_4X
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
op_star
id|cmd
op_amp
id|AGPSTAT2_2X
)paren
op_logical_and
(paren
op_star
id|tmp
op_amp
id|AGPSTAT2_2X
)paren
op_logical_and
(paren
op_star
id|mode
op_amp
id|AGPSTAT2_2X
)paren
)paren
)paren
op_star
id|cmd
op_and_assign
op_complement
id|AGPSTAT2_2X
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
op_star
id|cmd
op_amp
id|AGPSTAT2_1X
)paren
op_logical_and
(paren
op_star
id|tmp
op_amp
id|AGPSTAT2_1X
)paren
op_logical_and
(paren
op_star
id|mode
op_amp
id|AGPSTAT2_1X
)paren
)paren
)paren
op_star
id|cmd
op_and_assign
op_complement
id|AGPSTAT2_1X
suffix:semicolon
multiline_comment|/* Now we know what mode it should be, clear out the unwanted bits. */
r_if
c_cond
(paren
op_star
id|cmd
op_amp
id|AGPSTAT2_4X
)paren
op_star
id|cmd
op_and_assign
op_complement
(paren
id|AGPSTAT2_1X
op_or
id|AGPSTAT2_2X
)paren
suffix:semicolon
multiline_comment|/* 4X */
r_if
c_cond
(paren
op_star
id|cmd
op_amp
id|AGPSTAT2_2X
)paren
op_star
id|cmd
op_and_assign
op_complement
(paren
id|AGPSTAT2_1X
op_or
id|AGPSTAT2_4X
)paren
suffix:semicolon
multiline_comment|/* 2X */
r_if
c_cond
(paren
op_star
id|cmd
op_amp
id|AGPSTAT2_1X
)paren
op_star
id|cmd
op_and_assign
op_complement
(paren
id|AGPSTAT2_2X
op_or
id|AGPSTAT2_4X
)paren
suffix:semicolon
multiline_comment|/* 1X */
)brace
multiline_comment|/*&n; * mode = requested mode.&n; * cmd = PCI_AGP_STATUS from agp bridge.&n; * tmp = PCI_AGP_STATUS from graphic card.&n; */
DECL|function|agp_v3_parse_one
r_static
r_void
id|agp_v3_parse_one
c_func
(paren
id|u32
op_star
id|mode
comma
id|u32
op_star
id|cmd
comma
id|u32
op_star
id|tmp
)paren
(brace
id|u32
id|origcmd
op_assign
op_star
id|cmd
comma
id|origtmp
op_assign
op_star
id|tmp
suffix:semicolon
multiline_comment|/* ARQSZ - Set the value to the maximum one.&n;&t; * Don&squot;t allow the mode register to override values. */
op_star
id|cmd
op_assign
(paren
(paren
op_star
id|cmd
op_amp
op_complement
id|AGPSTAT_ARQSZ
)paren
op_or
id|max_t
c_func
(paren
id|u32
comma
(paren
op_star
id|cmd
op_amp
id|AGPSTAT_ARQSZ
)paren
comma
(paren
op_star
id|tmp
op_amp
id|AGPSTAT_ARQSZ
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Calibration cycle.&n;&t; * Don&squot;t allow the mode register to override values. */
op_star
id|cmd
op_assign
(paren
(paren
op_star
id|cmd
op_amp
op_complement
id|AGPSTAT_CAL_MASK
)paren
op_or
id|min_t
c_func
(paren
id|u32
comma
(paren
op_star
id|cmd
op_amp
id|AGPSTAT_CAL_MASK
)paren
comma
(paren
op_star
id|tmp
op_amp
id|AGPSTAT_CAL_MASK
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* SBA *must* be supported for AGP v3 */
op_star
id|cmd
op_or_assign
id|AGPSTAT_SBA
suffix:semicolon
multiline_comment|/*&n;&t; * Set speed.&n;&t; * Check for invalid speeds. This can happen when applications&n;&t; * written before the AGP 3.0 standard pass AGP2.x modes to AGP3 hardware&n;&t; */
r_if
c_cond
(paren
op_star
id|mode
op_amp
id|AGPSTAT_MODE_3_0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Caller hasn&squot;t a clue what its doing. We are in 3.0 mode,&n;&t;&t; * have been passed a 3.0 mode, but with 2.x speed bits set.&n;&t;&t; * AGP2.x 4x -&gt; AGP3.0 4x.&n;&t;&t; */
r_if
c_cond
(paren
op_star
id|mode
op_amp
id|AGPSTAT2_4X
)paren
(brace
id|printk
(paren
id|KERN_INFO
id|PFX
l_string|&quot;%s passes broken AGP3 flags (%x). Fixed.&bslash;n&quot;
comma
id|current-&gt;comm
comma
op_star
id|mode
)paren
suffix:semicolon
op_star
id|mode
op_and_assign
op_complement
id|AGPSTAT2_4X
suffix:semicolon
op_star
id|mode
op_or_assign
id|AGPSTAT3_4X
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * The caller doesn&squot;t know what they are doing. We are in 3.0 mode,&n;&t;&t; * but have been passed an AGP 2.x mode.&n;&t;&t; * Convert AGP 1x,2x,4x -&gt; AGP 3.0 4x.&n;&t;&t; */
id|printk
(paren
id|KERN_INFO
id|PFX
l_string|&quot;%s passes broken AGP2 flags (%x) in AGP3 mode. Fixed.&bslash;n&quot;
comma
id|current-&gt;comm
comma
op_star
id|mode
)paren
suffix:semicolon
op_star
id|mode
op_and_assign
op_complement
(paren
id|AGPSTAT2_4X
op_or
id|AGPSTAT2_2X
op_or
id|AGPSTAT2_1X
)paren
suffix:semicolon
op_star
id|mode
op_or_assign
id|AGPSTAT3_4X
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|mode
op_amp
id|AGPSTAT3_8X
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|cmd
op_amp
id|AGPSTAT3_8X
)paren
)paren
(brace
op_star
id|cmd
op_and_assign
op_complement
(paren
id|AGPSTAT3_8X
op_or
id|AGPSTAT3_RSVD
)paren
suffix:semicolon
op_star
id|cmd
op_or_assign
id|AGPSTAT3_4X
suffix:semicolon
id|printk
(paren
l_string|&quot;%s requested AGPx8 but bridge not capable.&bslash;n&quot;
comma
id|current-&gt;comm
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|tmp
op_amp
id|AGPSTAT3_8X
)paren
)paren
(brace
op_star
id|cmd
op_and_assign
op_complement
(paren
id|AGPSTAT3_8X
op_or
id|AGPSTAT3_RSVD
)paren
suffix:semicolon
op_star
id|cmd
op_or_assign
id|AGPSTAT3_4X
suffix:semicolon
id|printk
(paren
l_string|&quot;%s requested AGPx8 but graphic card not capable.&bslash;n&quot;
comma
id|current-&gt;comm
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* All set, bridge &amp; device can do AGP x8*/
op_star
id|cmd
op_and_assign
op_complement
(paren
id|AGPSTAT3_4X
op_or
id|AGPSTAT3_RSVD
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * If we didn&squot;t specify AGPx8, we can only do x4.&n;&t;&t; * If the hardware can&squot;t do x4, we&squot;re up shit creek, and never&n;&t;&t; *  should have got this far.&n;&t;&t; */
op_star
id|cmd
op_and_assign
op_complement
(paren
id|AGPSTAT3_8X
op_or
id|AGPSTAT3_RSVD
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|cmd
op_amp
id|AGPSTAT3_4X
)paren
op_logical_and
(paren
op_star
id|tmp
op_amp
id|AGPSTAT3_4X
)paren
)paren
op_star
id|cmd
op_or_assign
id|AGPSTAT3_4X
suffix:semicolon
r_else
(brace
id|printk
(paren
id|KERN_INFO
id|PFX
l_string|&quot;Badness. Don&squot;t know which AGP mode to set. &quot;
l_string|&quot;[cmd:%x tmp:%x fell back to:- cmd:%x tmp:%x]&bslash;n&quot;
comma
id|origcmd
comma
id|origtmp
comma
op_star
id|cmd
comma
op_star
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|cmd
op_amp
id|AGPSTAT3_4X
)paren
)paren
id|printk
(paren
id|KERN_INFO
id|PFX
l_string|&quot;Bridge couldn&squot;t do AGP x4.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|tmp
op_amp
id|AGPSTAT3_4X
)paren
)paren
id|printk
(paren
id|KERN_INFO
id|PFX
l_string|&quot;Graphic card couldn&squot;t do AGP x4.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
singleline_comment|//FIXME: This doesn&squot;t smell right.
singleline_comment|//We need a function we pass an agp_device to.
DECL|function|agp_collect_device_status
id|u32
id|agp_collect_device_status
c_func
(paren
id|u32
id|mode
comma
id|u32
id|cmd
)paren
(brace
r_struct
id|pci_dev
op_star
id|device
op_assign
l_int|NULL
suffix:semicolon
id|u8
id|cap_ptr
suffix:semicolon
id|u32
id|tmp
suffix:semicolon
id|u32
id|agp3
suffix:semicolon
id|for_each_pci_dev
c_func
(paren
id|device
)paren
(brace
id|cap_ptr
op_assign
id|pci_find_capability
c_func
(paren
id|device
comma
id|PCI_CAP_ID_AGP
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cap_ptr
)paren
r_continue
suffix:semicolon
singleline_comment|//FIXME: We should probably skip anything here that
singleline_comment|// isn&squot;t an AGP graphic card.
multiline_comment|/*&n;&t;&t; * Ok, here we have a AGP device. Disable impossible&n;&t;&t; * settings, and adjust the readqueue to the minimum.&n;&t;&t; */
id|pci_read_config_dword
c_func
(paren
id|device
comma
id|cap_ptr
op_plus
id|PCI_AGP_STATUS
comma
op_amp
id|tmp
)paren
suffix:semicolon
multiline_comment|/* adjust RQ depth */
id|cmd
op_assign
(paren
(paren
id|cmd
op_amp
op_complement
id|AGPSTAT_RQ_DEPTH
)paren
op_or
id|min_t
c_func
(paren
id|u32
comma
(paren
id|mode
op_amp
id|AGPSTAT_RQ_DEPTH
)paren
comma
id|min_t
c_func
(paren
id|u32
comma
(paren
id|cmd
op_amp
id|AGPSTAT_RQ_DEPTH
)paren
comma
(paren
id|tmp
op_amp
id|AGPSTAT_RQ_DEPTH
)paren
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* disable FW if it&squot;s not supported */
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|cmd
op_amp
id|AGPSTAT_FW
)paren
op_logical_and
(paren
id|tmp
op_amp
id|AGPSTAT_FW
)paren
op_logical_and
(paren
id|mode
op_amp
id|AGPSTAT_FW
)paren
)paren
)paren
id|cmd
op_and_assign
op_complement
id|AGPSTAT_FW
suffix:semicolon
multiline_comment|/* Check to see if we are operating in 3.0 mode */
id|pci_read_config_dword
c_func
(paren
id|device
comma
id|cap_ptr
op_plus
id|AGPSTAT
comma
op_amp
id|agp3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|agp3
op_amp
id|AGPSTAT_MODE_3_0
)paren
(brace
id|agp_v3_parse_one
c_func
(paren
op_amp
id|mode
comma
op_amp
id|cmd
comma
op_amp
id|tmp
)paren
suffix:semicolon
)brace
r_else
(brace
id|agp_v2_parse_one
c_func
(paren
op_amp
id|mode
comma
op_amp
id|cmd
comma
op_amp
id|tmp
)paren
suffix:semicolon
)brace
)brace
r_return
id|cmd
suffix:semicolon
)brace
DECL|variable|agp_collect_device_status
id|EXPORT_SYMBOL
c_func
(paren
id|agp_collect_device_status
)paren
suffix:semicolon
DECL|function|agp_device_command
r_void
id|agp_device_command
c_func
(paren
id|u32
id|command
comma
r_int
id|agp_v3
)paren
(brace
r_struct
id|pci_dev
op_star
id|device
op_assign
l_int|NULL
suffix:semicolon
r_int
id|mode
suffix:semicolon
id|mode
op_assign
id|command
op_amp
l_int|0x7
suffix:semicolon
r_if
c_cond
(paren
id|agp_v3
)paren
id|mode
op_mul_assign
l_int|4
suffix:semicolon
id|for_each_pci_dev
c_func
(paren
id|device
)paren
(brace
id|u8
id|agp
op_assign
id|pci_find_capability
c_func
(paren
id|device
comma
id|PCI_CAP_ID_AGP
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|agp
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|PFX
l_string|&quot;Putting AGP V%d device at %s into %dx mode&bslash;n&quot;
comma
id|agp_v3
ques
c_cond
l_int|3
suffix:colon
l_int|2
comma
id|pci_name
c_func
(paren
id|device
)paren
comma
id|mode
)paren
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|device
comma
id|agp
op_plus
id|PCI_AGP_COMMAND
comma
id|command
)paren
suffix:semicolon
)brace
)brace
DECL|variable|agp_device_command
id|EXPORT_SYMBOL
c_func
(paren
id|agp_device_command
)paren
suffix:semicolon
DECL|function|get_agp_version
r_void
id|get_agp_version
c_func
(paren
r_struct
id|agp_bridge_data
op_star
id|bridge
)paren
(brace
id|u32
id|ncapid
suffix:semicolon
multiline_comment|/* Exit early if already set by errata workarounds. */
r_if
c_cond
(paren
id|agp_bridge-&gt;major_version
op_ne
l_int|0
)paren
r_return
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|agp_bridge-&gt;dev
comma
id|agp_bridge-&gt;capndx
comma
op_amp
id|ncapid
)paren
suffix:semicolon
id|agp_bridge-&gt;major_version
op_assign
(paren
id|ncapid
op_rshift
id|AGP_MAJOR_VERSION_SHIFT
)paren
op_amp
l_int|0xf
suffix:semicolon
id|agp_bridge-&gt;minor_version
op_assign
(paren
id|ncapid
op_rshift
id|AGP_MINOR_VERSION_SHIFT
)paren
op_amp
l_int|0xf
suffix:semicolon
)brace
DECL|variable|get_agp_version
id|EXPORT_SYMBOL
c_func
(paren
id|get_agp_version
)paren
suffix:semicolon
DECL|function|agp_generic_enable
r_void
id|agp_generic_enable
c_func
(paren
id|u32
id|mode
)paren
(brace
id|u32
id|command
comma
id|temp
suffix:semicolon
id|u32
id|agp3
suffix:semicolon
id|get_agp_version
c_func
(paren
id|agp_bridge
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|PFX
l_string|&quot;Found an AGP %d.%d compliant device at %s.&bslash;n&quot;
comma
id|agp_bridge-&gt;major_version
comma
id|agp_bridge-&gt;minor_version
comma
id|pci_name
c_func
(paren
id|agp_bridge-&gt;dev
)paren
)paren
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|agp_bridge-&gt;dev
comma
id|agp_bridge-&gt;capndx
op_plus
id|PCI_AGP_STATUS
comma
op_amp
id|command
)paren
suffix:semicolon
id|command
op_assign
id|agp_collect_device_status
c_func
(paren
id|mode
comma
id|command
)paren
suffix:semicolon
id|command
op_or_assign
id|AGPSTAT_AGP_ENABLE
suffix:semicolon
multiline_comment|/* Do AGP version specific frobbing. */
r_if
c_cond
(paren
id|agp_bridge-&gt;major_version
op_ge
l_int|3
)paren
(brace
id|pci_read_config_dword
c_func
(paren
id|agp_bridge-&gt;dev
comma
id|agp_bridge-&gt;capndx
op_plus
id|AGPSTAT
comma
op_amp
id|agp3
)paren
suffix:semicolon
multiline_comment|/* Check to see if we are operating in 3.0 mode */
r_if
c_cond
(paren
id|agp3
op_amp
id|AGPSTAT_MODE_3_0
)paren
(brace
multiline_comment|/* If we have 3.5, we can do the isoch stuff. */
r_if
c_cond
(paren
id|agp_bridge-&gt;minor_version
op_ge
l_int|5
)paren
id|agp_3_5_enable
c_func
(paren
id|agp_bridge
)paren
suffix:semicolon
id|agp_device_command
c_func
(paren
id|command
comma
id|TRUE
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Disable calibration cycle in RX91&lt;1&gt; when not in AGP3.0 mode of operation.*/
id|command
op_and_assign
op_complement
(paren
l_int|7
op_lshift
l_int|10
)paren
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|agp_bridge-&gt;dev
comma
id|agp_bridge-&gt;capndx
op_plus
id|AGPCTRL
comma
op_amp
id|temp
)paren
suffix:semicolon
id|temp
op_or_assign
(paren
l_int|1
op_lshift
l_int|9
)paren
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|agp_bridge-&gt;dev
comma
id|agp_bridge-&gt;capndx
op_plus
id|AGPCTRL
comma
id|temp
)paren
suffix:semicolon
id|printk
(paren
id|KERN_INFO
id|PFX
l_string|&quot;Device is in legacy mode,&quot;
l_string|&quot; falling back to 2.x&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* AGP v&lt;3 */
id|agp_device_command
c_func
(paren
id|command
comma
id|FALSE
)paren
suffix:semicolon
)brace
DECL|variable|agp_generic_enable
id|EXPORT_SYMBOL
c_func
(paren
id|agp_generic_enable
)paren
suffix:semicolon
DECL|function|agp_generic_create_gatt_table
r_int
id|agp_generic_create_gatt_table
c_func
(paren
r_void
)paren
(brace
r_char
op_star
id|table
suffix:semicolon
r_char
op_star
id|table_end
suffix:semicolon
r_int
id|size
suffix:semicolon
r_int
id|page_order
suffix:semicolon
r_int
id|num_entries
suffix:semicolon
r_int
id|i
suffix:semicolon
r_void
op_star
id|temp
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
multiline_comment|/* The generic routines can&squot;t handle 2 level gatt&squot;s */
r_if
c_cond
(paren
id|agp_bridge-&gt;driver-&gt;size_type
op_eq
id|LVL2_APER_SIZE
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|table
op_assign
l_int|NULL
suffix:semicolon
id|i
op_assign
id|agp_bridge-&gt;aperture_size_idx
suffix:semicolon
id|temp
op_assign
id|agp_bridge-&gt;current_size
suffix:semicolon
id|size
op_assign
id|page_order
op_assign
id|num_entries
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|agp_bridge-&gt;driver-&gt;size_type
op_ne
id|FIXED_APER_SIZE
)paren
(brace
r_do
(brace
r_switch
c_cond
(paren
id|agp_bridge-&gt;driver-&gt;size_type
)paren
(brace
r_case
id|U8_APER_SIZE
suffix:colon
id|size
op_assign
id|A_SIZE_8
c_func
(paren
id|temp
)paren
op_member_access_from_pointer
id|size
suffix:semicolon
id|page_order
op_assign
id|A_SIZE_8
c_func
(paren
id|temp
)paren
op_member_access_from_pointer
id|page_order
suffix:semicolon
id|num_entries
op_assign
id|A_SIZE_8
c_func
(paren
id|temp
)paren
op_member_access_from_pointer
id|num_entries
suffix:semicolon
r_break
suffix:semicolon
r_case
id|U16_APER_SIZE
suffix:colon
id|size
op_assign
id|A_SIZE_16
c_func
(paren
id|temp
)paren
op_member_access_from_pointer
id|size
suffix:semicolon
id|page_order
op_assign
id|A_SIZE_16
c_func
(paren
id|temp
)paren
op_member_access_from_pointer
id|page_order
suffix:semicolon
id|num_entries
op_assign
id|A_SIZE_16
c_func
(paren
id|temp
)paren
op_member_access_from_pointer
id|num_entries
suffix:semicolon
r_break
suffix:semicolon
r_case
id|U32_APER_SIZE
suffix:colon
id|size
op_assign
id|A_SIZE_32
c_func
(paren
id|temp
)paren
op_member_access_from_pointer
id|size
suffix:semicolon
id|page_order
op_assign
id|A_SIZE_32
c_func
(paren
id|temp
)paren
op_member_access_from_pointer
id|page_order
suffix:semicolon
id|num_entries
op_assign
id|A_SIZE_32
c_func
(paren
id|temp
)paren
op_member_access_from_pointer
id|num_entries
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* This case will never really happen. */
r_case
id|FIXED_APER_SIZE
suffix:colon
r_case
id|LVL2_APER_SIZE
suffix:colon
r_default
suffix:colon
id|size
op_assign
id|page_order
op_assign
id|num_entries
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|table
op_assign
(paren
r_char
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_KERNEL
comma
id|page_order
)paren
suffix:semicolon
r_if
c_cond
(paren
id|table
op_eq
l_int|NULL
)paren
(brace
id|i
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|agp_bridge-&gt;driver-&gt;size_type
)paren
(brace
r_case
id|U8_APER_SIZE
suffix:colon
id|agp_bridge-&gt;current_size
op_assign
id|A_IDX8
c_func
(paren
id|agp_bridge
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|U16_APER_SIZE
suffix:colon
id|agp_bridge-&gt;current_size
op_assign
id|A_IDX16
c_func
(paren
id|agp_bridge
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|U32_APER_SIZE
suffix:colon
id|agp_bridge-&gt;current_size
op_assign
id|A_IDX32
c_func
(paren
id|agp_bridge
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* This case will never really happen. */
r_case
id|FIXED_APER_SIZE
suffix:colon
r_case
id|LVL2_APER_SIZE
suffix:colon
r_default
suffix:colon
id|agp_bridge-&gt;current_size
op_assign
id|agp_bridge-&gt;current_size
suffix:semicolon
r_break
suffix:semicolon
)brace
id|temp
op_assign
id|agp_bridge-&gt;current_size
suffix:semicolon
)brace
r_else
(brace
id|agp_bridge-&gt;aperture_size_idx
op_assign
id|i
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_logical_neg
id|table
op_logical_and
(paren
id|i
OL
id|agp_bridge-&gt;driver-&gt;num_aperture_sizes
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|size
op_assign
(paren
(paren
r_struct
id|aper_size_info_fixed
op_star
)paren
id|temp
)paren
op_member_access_from_pointer
id|size
suffix:semicolon
id|page_order
op_assign
(paren
(paren
r_struct
id|aper_size_info_fixed
op_star
)paren
id|temp
)paren
op_member_access_from_pointer
id|page_order
suffix:semicolon
id|num_entries
op_assign
(paren
(paren
r_struct
id|aper_size_info_fixed
op_star
)paren
id|temp
)paren
op_member_access_from_pointer
id|num_entries
suffix:semicolon
id|table
op_assign
(paren
r_char
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_KERNEL
comma
id|page_order
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|table
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|table_end
op_assign
id|table
op_plus
(paren
(paren
id|PAGE_SIZE
op_star
(paren
l_int|1
op_lshift
id|page_order
)paren
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|page
op_assign
id|virt_to_page
c_func
(paren
id|table
)paren
suffix:semicolon
id|page
op_le
id|virt_to_page
c_func
(paren
id|table_end
)paren
suffix:semicolon
id|page
op_increment
)paren
id|SetPageReserved
c_func
(paren
id|page
)paren
suffix:semicolon
id|agp_bridge-&gt;gatt_table_real
op_assign
(paren
id|u32
op_star
)paren
id|table
suffix:semicolon
id|agp_gatt_table
op_assign
(paren
r_void
op_star
)paren
id|table
suffix:semicolon
id|agp_bridge-&gt;driver
op_member_access_from_pointer
id|cache_flush
c_func
(paren
)paren
suffix:semicolon
id|agp_bridge-&gt;gatt_table
op_assign
id|ioremap_nocache
c_func
(paren
id|virt_to_phys
c_func
(paren
id|table
)paren
comma
(paren
id|PAGE_SIZE
op_star
(paren
l_int|1
op_lshift
id|page_order
)paren
)paren
)paren
suffix:semicolon
id|agp_bridge-&gt;driver
op_member_access_from_pointer
id|cache_flush
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|agp_bridge-&gt;gatt_table
op_eq
l_int|NULL
)paren
(brace
r_for
c_loop
(paren
id|page
op_assign
id|virt_to_page
c_func
(paren
id|table
)paren
suffix:semicolon
id|page
op_le
id|virt_to_page
c_func
(paren
id|table_end
)paren
suffix:semicolon
id|page
op_increment
)paren
id|ClearPageReserved
c_func
(paren
id|page
)paren
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|table
comma
id|page_order
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|agp_bridge-&gt;gatt_bus_addr
op_assign
id|virt_to_phys
c_func
(paren
id|agp_bridge-&gt;gatt_table_real
)paren
suffix:semicolon
multiline_comment|/* AK: bogus, should encode addresses &gt; 4GB */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_entries
suffix:semicolon
id|i
op_increment
)paren
(brace
id|writel
c_func
(paren
id|agp_bridge-&gt;scratch_page
comma
id|agp_bridge-&gt;gatt_table
op_plus
id|i
)paren
suffix:semicolon
id|readl
c_func
(paren
id|agp_bridge-&gt;gatt_table
op_plus
id|i
)paren
suffix:semicolon
multiline_comment|/* PCI Posting. */
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|agp_generic_create_gatt_table
id|EXPORT_SYMBOL
c_func
(paren
id|agp_generic_create_gatt_table
)paren
suffix:semicolon
DECL|function|agp_generic_free_gatt_table
r_int
id|agp_generic_free_gatt_table
c_func
(paren
r_void
)paren
(brace
r_int
id|page_order
suffix:semicolon
r_char
op_star
id|table
comma
op_star
id|table_end
suffix:semicolon
r_void
op_star
id|temp
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|temp
op_assign
id|agp_bridge-&gt;current_size
suffix:semicolon
r_switch
c_cond
(paren
id|agp_bridge-&gt;driver-&gt;size_type
)paren
(brace
r_case
id|U8_APER_SIZE
suffix:colon
id|page_order
op_assign
id|A_SIZE_8
c_func
(paren
id|temp
)paren
op_member_access_from_pointer
id|page_order
suffix:semicolon
r_break
suffix:semicolon
r_case
id|U16_APER_SIZE
suffix:colon
id|page_order
op_assign
id|A_SIZE_16
c_func
(paren
id|temp
)paren
op_member_access_from_pointer
id|page_order
suffix:semicolon
r_break
suffix:semicolon
r_case
id|U32_APER_SIZE
suffix:colon
id|page_order
op_assign
id|A_SIZE_32
c_func
(paren
id|temp
)paren
op_member_access_from_pointer
id|page_order
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FIXED_APER_SIZE
suffix:colon
id|page_order
op_assign
id|A_SIZE_FIX
c_func
(paren
id|temp
)paren
op_member_access_from_pointer
id|page_order
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LVL2_APER_SIZE
suffix:colon
multiline_comment|/* The generic routines can&squot;t deal with 2 level gatt&squot;s */
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|page_order
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Do not worry about freeing memory, because if this is&n;&t; * called, then all agp memory is deallocated and removed&n;&t; * from the table. */
id|iounmap
c_func
(paren
id|agp_bridge-&gt;gatt_table
)paren
suffix:semicolon
id|table
op_assign
(paren
r_char
op_star
)paren
id|agp_bridge-&gt;gatt_table_real
suffix:semicolon
id|table_end
op_assign
id|table
op_plus
(paren
(paren
id|PAGE_SIZE
op_star
(paren
l_int|1
op_lshift
id|page_order
)paren
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|page
op_assign
id|virt_to_page
c_func
(paren
id|table
)paren
suffix:semicolon
id|page
op_le
id|virt_to_page
c_func
(paren
id|table_end
)paren
suffix:semicolon
id|page
op_increment
)paren
id|ClearPageReserved
c_func
(paren
id|page
)paren
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|agp_bridge-&gt;gatt_table_real
comma
id|page_order
)paren
suffix:semicolon
id|agp_gatt_table
op_assign
l_int|NULL
suffix:semicolon
id|agp_bridge-&gt;gatt_table
op_assign
l_int|NULL
suffix:semicolon
id|agp_bridge-&gt;gatt_table_real
op_assign
l_int|NULL
suffix:semicolon
id|agp_bridge-&gt;gatt_bus_addr
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|agp_generic_free_gatt_table
id|EXPORT_SYMBOL
c_func
(paren
id|agp_generic_free_gatt_table
)paren
suffix:semicolon
DECL|function|agp_generic_insert_memory
r_int
id|agp_generic_insert_memory
c_func
(paren
r_struct
id|agp_memory
op_star
id|mem
comma
id|off_t
id|pg_start
comma
r_int
id|type
)paren
(brace
r_int
id|num_entries
suffix:semicolon
r_int
id|i
suffix:semicolon
id|off_t
id|j
suffix:semicolon
r_void
op_star
id|temp
suffix:semicolon
id|temp
op_assign
id|agp_bridge-&gt;current_size
suffix:semicolon
r_switch
c_cond
(paren
id|agp_bridge-&gt;driver-&gt;size_type
)paren
(brace
r_case
id|U8_APER_SIZE
suffix:colon
id|num_entries
op_assign
id|A_SIZE_8
c_func
(paren
id|temp
)paren
op_member_access_from_pointer
id|num_entries
suffix:semicolon
r_break
suffix:semicolon
r_case
id|U16_APER_SIZE
suffix:colon
id|num_entries
op_assign
id|A_SIZE_16
c_func
(paren
id|temp
)paren
op_member_access_from_pointer
id|num_entries
suffix:semicolon
r_break
suffix:semicolon
r_case
id|U32_APER_SIZE
suffix:colon
id|num_entries
op_assign
id|A_SIZE_32
c_func
(paren
id|temp
)paren
op_member_access_from_pointer
id|num_entries
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FIXED_APER_SIZE
suffix:colon
id|num_entries
op_assign
id|A_SIZE_FIX
c_func
(paren
id|temp
)paren
op_member_access_from_pointer
id|num_entries
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LVL2_APER_SIZE
suffix:colon
multiline_comment|/* The generic routines can&squot;t deal with 2 level gatt&squot;s */
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|num_entries
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|num_entries
op_sub_assign
id|agp_memory_reserved
op_div
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|num_entries
OL
l_int|0
)paren
id|num_entries
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
l_int|0
op_logical_or
id|mem-&gt;type
op_ne
l_int|0
)paren
(brace
multiline_comment|/* The generic routines know nothing of memory types */
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* AK: could wrap */
r_if
c_cond
(paren
(paren
id|pg_start
op_plus
id|mem-&gt;page_count
)paren
OG
id|num_entries
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|j
op_assign
id|pg_start
suffix:semicolon
r_while
c_loop
(paren
id|j
OL
(paren
id|pg_start
op_plus
id|mem-&gt;page_count
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|PGE_EMPTY
c_func
(paren
id|agp_bridge
comma
id|readl
c_func
(paren
id|agp_bridge-&gt;gatt_table
op_plus
id|j
)paren
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|j
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mem-&gt;is_flushed
op_eq
id|FALSE
)paren
(brace
id|agp_bridge-&gt;driver
op_member_access_from_pointer
id|cache_flush
c_func
(paren
)paren
suffix:semicolon
id|mem-&gt;is_flushed
op_assign
id|TRUE
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
id|pg_start
suffix:semicolon
id|i
OL
id|mem-&gt;page_count
suffix:semicolon
id|i
op_increment
comma
id|j
op_increment
)paren
(brace
id|writel
c_func
(paren
id|agp_bridge-&gt;driver
op_member_access_from_pointer
id|mask_memory
c_func
(paren
id|mem-&gt;memory
(braket
id|i
)braket
comma
id|mem-&gt;type
)paren
comma
id|agp_bridge-&gt;gatt_table
op_plus
id|j
)paren
suffix:semicolon
id|readl
c_func
(paren
id|agp_bridge-&gt;gatt_table
op_plus
id|j
)paren
suffix:semicolon
multiline_comment|/* PCI Posting. */
)brace
id|agp_bridge-&gt;driver
op_member_access_from_pointer
id|tlb_flush
c_func
(paren
id|mem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|agp_generic_insert_memory
id|EXPORT_SYMBOL
c_func
(paren
id|agp_generic_insert_memory
)paren
suffix:semicolon
DECL|function|agp_generic_remove_memory
r_int
id|agp_generic_remove_memory
c_func
(paren
r_struct
id|agp_memory
op_star
id|mem
comma
id|off_t
id|pg_start
comma
r_int
id|type
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
l_int|0
op_logical_or
id|mem-&gt;type
op_ne
l_int|0
)paren
(brace
multiline_comment|/* The generic routines know nothing of memory types */
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* AK: bogus, should encode addresses &gt; 4GB */
r_for
c_loop
(paren
id|i
op_assign
id|pg_start
suffix:semicolon
id|i
OL
(paren
id|mem-&gt;page_count
op_plus
id|pg_start
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|writel
c_func
(paren
id|agp_bridge-&gt;scratch_page
comma
id|agp_bridge-&gt;gatt_table
op_plus
id|i
)paren
suffix:semicolon
id|readl
c_func
(paren
id|agp_bridge-&gt;gatt_table
op_plus
id|i
)paren
suffix:semicolon
multiline_comment|/* PCI Posting. */
)brace
id|global_cache_flush
c_func
(paren
)paren
suffix:semicolon
id|agp_bridge-&gt;driver
op_member_access_from_pointer
id|tlb_flush
c_func
(paren
id|mem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|agp_generic_remove_memory
id|EXPORT_SYMBOL
c_func
(paren
id|agp_generic_remove_memory
)paren
suffix:semicolon
DECL|function|agp_generic_alloc_by_type
r_struct
id|agp_memory
op_star
id|agp_generic_alloc_by_type
c_func
(paren
r_int
id|page_count
comma
r_int
id|type
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|variable|agp_generic_alloc_by_type
id|EXPORT_SYMBOL
c_func
(paren
id|agp_generic_alloc_by_type
)paren
suffix:semicolon
DECL|function|agp_generic_free_by_type
r_void
id|agp_generic_free_by_type
c_func
(paren
r_struct
id|agp_memory
op_star
id|curr
)paren
(brace
r_if
c_cond
(paren
id|curr-&gt;memory
op_ne
l_int|NULL
)paren
id|vfree
c_func
(paren
id|curr-&gt;memory
)paren
suffix:semicolon
id|agp_free_key
c_func
(paren
id|curr-&gt;key
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|curr
)paren
suffix:semicolon
)brace
DECL|variable|agp_generic_free_by_type
id|EXPORT_SYMBOL
c_func
(paren
id|agp_generic_free_by_type
)paren
suffix:semicolon
multiline_comment|/*&n; * Basic Page Allocation Routines -&n; * These routines handle page allocation and by default they reserve the allocated&n; * memory.  They also handle incrementing the current_memory_agp value, Which is checked&n; * against a maximum value.&n; */
DECL|function|agp_generic_alloc_page
r_void
op_star
id|agp_generic_alloc_page
c_func
(paren
r_void
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
id|page
op_assign
id|alloc_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|map_page_into_agp
c_func
(paren
id|page
)paren
suffix:semicolon
id|get_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageLocked
c_func
(paren
id|page
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|agp_bridge-&gt;current_memory_agp
)paren
suffix:semicolon
r_return
id|page_address
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
DECL|variable|agp_generic_alloc_page
id|EXPORT_SYMBOL
c_func
(paren
id|agp_generic_alloc_page
)paren
suffix:semicolon
DECL|function|agp_generic_destroy_page
r_void
id|agp_generic_destroy_page
c_func
(paren
r_void
op_star
id|addr
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|page
op_assign
id|virt_to_page
c_func
(paren
id|addr
)paren
suffix:semicolon
id|unmap_page_from_agp
c_func
(paren
id|page
)paren
suffix:semicolon
id|put_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|addr
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|agp_bridge-&gt;current_memory_agp
)paren
suffix:semicolon
)brace
DECL|variable|agp_generic_destroy_page
id|EXPORT_SYMBOL
c_func
(paren
id|agp_generic_destroy_page
)paren
suffix:semicolon
multiline_comment|/* End Basic Page Allocation Routines */
multiline_comment|/**&n; * agp_enable  -  initialise the agp point-to-point connection.&n; *&n; * @mode:&t;agp mode register value to configure with.&n; */
DECL|function|agp_enable
r_void
id|agp_enable
c_func
(paren
id|u32
id|mode
)paren
(brace
r_if
c_cond
(paren
id|agp_bridge-&gt;type
op_eq
id|NOT_SUPPORTED
)paren
r_return
suffix:semicolon
id|agp_bridge-&gt;driver
op_member_access_from_pointer
id|agp_enable
c_func
(paren
id|mode
)paren
suffix:semicolon
)brace
DECL|variable|agp_enable
id|EXPORT_SYMBOL
c_func
(paren
id|agp_enable
)paren
suffix:semicolon
DECL|function|ipi_handler
r_static
r_void
id|ipi_handler
c_func
(paren
r_void
op_star
id|null
)paren
(brace
id|flush_agp_cache
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|global_cache_flush
r_void
id|global_cache_flush
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|on_each_cpu
c_func
(paren
id|ipi_handler
comma
l_int|NULL
comma
l_int|1
comma
l_int|1
)paren
op_ne
l_int|0
)paren
id|panic
c_func
(paren
id|PFX
l_string|&quot;timed out waiting for the other CPUs!&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|variable|global_cache_flush
id|EXPORT_SYMBOL
c_func
(paren
id|global_cache_flush
)paren
suffix:semicolon
DECL|function|agp_generic_mask_memory
r_int
r_int
id|agp_generic_mask_memory
c_func
(paren
r_int
r_int
id|addr
comma
r_int
id|type
)paren
(brace
multiline_comment|/* memory type is ignored in the generic routine */
r_if
c_cond
(paren
id|agp_bridge-&gt;driver-&gt;masks
)paren
r_return
id|addr
op_or
id|agp_bridge-&gt;driver-&gt;masks
(braket
l_int|0
)braket
dot
id|mask
suffix:semicolon
r_else
r_return
id|addr
suffix:semicolon
)brace
DECL|variable|agp_generic_mask_memory
id|EXPORT_SYMBOL
c_func
(paren
id|agp_generic_mask_memory
)paren
suffix:semicolon
multiline_comment|/*&n; * These functions are implemented according to the AGPv3 spec,&n; * which covers implementation details that had previously been&n; * left open.&n; */
DECL|function|agp3_generic_fetch_size
r_int
id|agp3_generic_fetch_size
c_func
(paren
r_void
)paren
(brace
id|u16
id|temp_size
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|aper_size_info_16
op_star
id|values
suffix:semicolon
id|pci_read_config_word
c_func
(paren
id|agp_bridge-&gt;dev
comma
id|agp_bridge-&gt;capndx
op_plus
id|AGPAPSIZE
comma
op_amp
id|temp_size
)paren
suffix:semicolon
id|values
op_assign
id|A_SIZE_16
c_func
(paren
id|agp_bridge-&gt;driver-&gt;aperture_sizes
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|agp_bridge-&gt;driver-&gt;num_aperture_sizes
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|temp_size
op_eq
id|values
(braket
id|i
)braket
dot
id|size_value
)paren
(brace
id|agp_bridge-&gt;previous_size
op_assign
id|agp_bridge-&gt;current_size
op_assign
(paren
r_void
op_star
)paren
(paren
id|values
op_plus
id|i
)paren
suffix:semicolon
id|agp_bridge-&gt;aperture_size_idx
op_assign
id|i
suffix:semicolon
r_return
id|values
(braket
id|i
)braket
dot
id|size
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|agp3_generic_fetch_size
id|EXPORT_SYMBOL
c_func
(paren
id|agp3_generic_fetch_size
)paren
suffix:semicolon
DECL|function|agp3_generic_tlbflush
r_void
id|agp3_generic_tlbflush
c_func
(paren
r_struct
id|agp_memory
op_star
id|mem
)paren
(brace
id|u32
id|ctrl
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|agp_bridge-&gt;dev
comma
id|agp_bridge-&gt;capndx
op_plus
id|AGPCTRL
comma
op_amp
id|ctrl
)paren
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|agp_bridge-&gt;dev
comma
id|agp_bridge-&gt;capndx
op_plus
id|AGPCTRL
comma
id|ctrl
op_amp
op_complement
id|AGPCTRL_GTLBEN
)paren
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|agp_bridge-&gt;dev
comma
id|agp_bridge-&gt;capndx
op_plus
id|AGPCTRL
comma
id|ctrl
)paren
suffix:semicolon
)brace
DECL|variable|agp3_generic_tlbflush
id|EXPORT_SYMBOL
c_func
(paren
id|agp3_generic_tlbflush
)paren
suffix:semicolon
DECL|function|agp3_generic_configure
r_int
id|agp3_generic_configure
c_func
(paren
r_void
)paren
(brace
id|u32
id|temp
suffix:semicolon
r_struct
id|aper_size_info_16
op_star
id|current_size
suffix:semicolon
id|current_size
op_assign
id|A_SIZE_16
c_func
(paren
id|agp_bridge-&gt;current_size
)paren
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|agp_bridge-&gt;dev
comma
id|AGP_APBASE
comma
op_amp
id|temp
)paren
suffix:semicolon
id|agp_bridge-&gt;gart_bus_addr
op_assign
(paren
id|temp
op_amp
id|PCI_BASE_ADDRESS_MEM_MASK
)paren
suffix:semicolon
multiline_comment|/* set aperture size */
id|pci_write_config_word
c_func
(paren
id|agp_bridge-&gt;dev
comma
id|agp_bridge-&gt;capndx
op_plus
id|AGPAPSIZE
comma
id|current_size-&gt;size_value
)paren
suffix:semicolon
multiline_comment|/* set gart pointer */
id|pci_write_config_dword
c_func
(paren
id|agp_bridge-&gt;dev
comma
id|agp_bridge-&gt;capndx
op_plus
id|AGPGARTLO
comma
id|agp_bridge-&gt;gatt_bus_addr
)paren
suffix:semicolon
multiline_comment|/* enable aperture and GTLB */
id|pci_read_config_dword
c_func
(paren
id|agp_bridge-&gt;dev
comma
id|agp_bridge-&gt;capndx
op_plus
id|AGPCTRL
comma
op_amp
id|temp
)paren
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|agp_bridge-&gt;dev
comma
id|agp_bridge-&gt;capndx
op_plus
id|AGPCTRL
comma
id|temp
op_or
id|AGPCTRL_APERENB
op_or
id|AGPCTRL_GTLBEN
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|agp3_generic_configure
id|EXPORT_SYMBOL
c_func
(paren
id|agp3_generic_configure
)paren
suffix:semicolon
DECL|function|agp3_generic_cleanup
r_void
id|agp3_generic_cleanup
c_func
(paren
r_void
)paren
(brace
id|u32
id|ctrl
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|agp_bridge-&gt;dev
comma
id|agp_bridge-&gt;capndx
op_plus
id|AGPCTRL
comma
op_amp
id|ctrl
)paren
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|agp_bridge-&gt;dev
comma
id|agp_bridge-&gt;capndx
op_plus
id|AGPCTRL
comma
id|ctrl
op_amp
op_complement
id|AGPCTRL_APERENB
)paren
suffix:semicolon
)brace
DECL|variable|agp3_generic_cleanup
id|EXPORT_SYMBOL
c_func
(paren
id|agp3_generic_cleanup
)paren
suffix:semicolon
DECL|variable|agp3_generic_sizes
r_struct
id|aper_size_info_16
id|agp3_generic_sizes
(braket
id|AGP_GENERIC_SIZES_ENTRIES
)braket
op_assign
(brace
(brace
l_int|4096
comma
l_int|1048576
comma
l_int|10
comma
l_int|0x000
)brace
comma
(brace
l_int|2048
comma
l_int|524288
comma
l_int|9
comma
l_int|0x800
)brace
comma
(brace
l_int|1024
comma
l_int|262144
comma
l_int|8
comma
l_int|0xc00
)brace
comma
(brace
l_int|512
comma
l_int|131072
comma
l_int|7
comma
l_int|0xe00
)brace
comma
(brace
l_int|256
comma
l_int|65536
comma
l_int|6
comma
l_int|0xf00
)brace
comma
(brace
l_int|128
comma
l_int|32768
comma
l_int|5
comma
l_int|0xf20
)brace
comma
(brace
l_int|64
comma
l_int|16384
comma
l_int|4
comma
l_int|0xf30
)brace
comma
(brace
l_int|32
comma
l_int|8192
comma
l_int|3
comma
l_int|0xf38
)brace
comma
(brace
l_int|16
comma
l_int|4096
comma
l_int|2
comma
l_int|0xf3c
)brace
comma
(brace
l_int|8
comma
l_int|2048
comma
l_int|1
comma
l_int|0xf3e
)brace
comma
(brace
l_int|4
comma
l_int|1024
comma
l_int|0
comma
l_int|0xf3f
)brace
)brace
suffix:semicolon
DECL|variable|agp3_generic_sizes
id|EXPORT_SYMBOL
c_func
(paren
id|agp3_generic_sizes
)paren
suffix:semicolon
eof
