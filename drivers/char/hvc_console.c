multiline_comment|/*&n; * Copyright (C) 2001 Anton Blanchard &lt;anton@au.ibm.com&gt;, IBM&n; * Copyright (C) 2001 Paul Mackerras &lt;paulus@au.ibm.com&gt;, IBM&n; * Copyright (C) 2004 Benjamin Herrenschmidt &lt;benh@kernel.crashing.org&gt;, IBM Corp.&n; * Copyright (C) 2004 IBM Corporation&n; *&n; * Additional Author(s):&n; *  Ryan S. Arnold &lt;rsa@us.ibm.com&gt;&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; * &n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; * &n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA&n; */
macro_line|#include &lt;linux/console.h&gt;
macro_line|#include &lt;linux/cpumask.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kbd_kern.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/kobject.h&gt;
macro_line|#include &lt;linux/kthread.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/sysrq.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/tty_flip.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/hvconsole.h&gt;
macro_line|#include &lt;asm/vio.h&gt;
DECL|macro|HVC_MAJOR
mdefine_line|#define HVC_MAJOR&t;229
DECL|macro|HVC_MINOR
mdefine_line|#define HVC_MINOR&t;0
DECL|macro|TIMEOUT
mdefine_line|#define TIMEOUT&t;&t;(10)
multiline_comment|/*&n; * Wait this long per iteration while trying to push buffered data to the&n; * hypervisor before allowing the tty to complete a close operation.&n; */
DECL|macro|HVC_CLOSE_WAIT
mdefine_line|#define HVC_CLOSE_WAIT (HZ/100) /* 1/10 of a second */
multiline_comment|/*&n; * The Linux TTY code does not support dynamic addition of tty derived devices&n; * so we need to know how many tty devices we might need when space is allocated&n; * for the tty device.  Since this driver supports hotplug of vty adapters we&n; * need to make sure we have enough allocated.&n; */
DECL|macro|HVC_ALLOC_TTY_ADAPTERS
mdefine_line|#define HVC_ALLOC_TTY_ADAPTERS&t;8
DECL|variable|hvc_driver
r_static
r_struct
id|tty_driver
op_star
id|hvc_driver
suffix:semicolon
macro_line|#ifdef CONFIG_MAGIC_SYSRQ
DECL|variable|sysrq_pressed
r_static
r_int
id|sysrq_pressed
suffix:semicolon
macro_line|#endif
DECL|macro|N_OUTBUF
mdefine_line|#define N_OUTBUF&t;16
DECL|macro|N_INBUF
mdefine_line|#define N_INBUF&t;&t;16
DECL|macro|__ALIGNED__
mdefine_line|#define __ALIGNED__&t;__attribute__((__aligned__(8)))
DECL|struct|hvc_struct
r_struct
id|hvc_struct
(brace
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|index
r_int
id|index
suffix:semicolon
DECL|member|tty
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
DECL|member|count
r_int
r_int
id|count
suffix:semicolon
DECL|member|do_wakeup
r_int
id|do_wakeup
suffix:semicolon
DECL|member|__ALIGNED__
r_char
id|outbuf
(braket
id|N_OUTBUF
)braket
id|__ALIGNED__
suffix:semicolon
DECL|member|n_outbuf
r_int
id|n_outbuf
suffix:semicolon
DECL|member|vtermno
r_uint32
id|vtermno
suffix:semicolon
DECL|member|irq_requested
r_int
id|irq_requested
suffix:semicolon
DECL|member|irq
r_int
id|irq
suffix:semicolon
DECL|member|next
r_struct
id|list_head
id|next
suffix:semicolon
DECL|member|kobj
r_struct
id|kobject
id|kobj
suffix:semicolon
multiline_comment|/* ref count &amp; hvc_struct lifetime */
DECL|member|vdev
r_struct
id|vio_dev
op_star
id|vdev
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* dynamic list of hvc_struct instances */
DECL|variable|hvc_structs
r_static
r_struct
id|list_head
id|hvc_structs
op_assign
id|LIST_HEAD_INIT
c_func
(paren
id|hvc_structs
)paren
suffix:semicolon
multiline_comment|/*&n; * Protect the list of hvc_struct instances from inserts and removals during&n; * list traversal.&n; */
DECL|variable|hvc_structs_lock
r_static
id|spinlock_t
id|hvc_structs_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n; * Initial console vtermnos for console API usage prior to full console&n; * initialization.  Any vty adapter outside this range will not have usable&n; * console interfaces but can still be used as a tty device.  This has to be&n; * static because kmalloc will not work during early console init.&n; */
DECL|variable|vtermnos
r_static
r_uint32
id|vtermnos
(braket
id|MAX_NR_HVC_CONSOLES
)braket
suffix:semicolon
multiline_comment|/* Used for accounting purposes */
DECL|variable|num_vterms
r_static
r_int
id|num_vterms
op_assign
l_int|0
suffix:semicolon
DECL|variable|hvc_task
r_static
r_struct
id|task_struct
op_star
id|hvc_task
suffix:semicolon
multiline_comment|/*&n; * This value is used to associate a tty-&gt;index value to a hvc_struct based&n; * upon order of exposure via hvc_probe().&n; */
DECL|variable|hvc_count
r_static
r_int
id|hvc_count
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Picks up late kicks after list walk but before schedule() */
DECL|variable|hvc_kicked
r_static
r_int
id|hvc_kicked
suffix:semicolon
multiline_comment|/* Wake the sleeping khvcd */
DECL|function|hvc_kick
r_static
r_void
id|hvc_kick
c_func
(paren
r_void
)paren
(brace
id|hvc_kicked
op_assign
l_int|1
suffix:semicolon
id|wake_up_process
c_func
(paren
id|hvc_task
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NOTE: This API isn&squot;t used if the console adapter doesn&squot;t support interrupts.&n; * In this case the console is poll driven.&n; */
DECL|function|hvc_handle_interrupt
r_static
id|irqreturn_t
id|hvc_handle_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_instance
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|hvc_kick
c_func
(paren
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
DECL|function|hvc_unthrottle
r_static
r_void
id|hvc_unthrottle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|hvc_kick
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Do not call this function with either the hvc_strucst_lock or the hvc_struct&n; * lock held.  If successful, this function increments the kobject reference&n; * count against the target hvc_struct so it should be released when finished.&n; */
DECL|function|hvc_get_by_index
r_struct
id|hvc_struct
op_star
id|hvc_get_by_index
c_func
(paren
r_int
id|index
)paren
(brace
r_struct
id|hvc_struct
op_star
id|hp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|hvc_structs_lock
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|hp
comma
op_amp
id|hvc_structs
comma
id|next
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hp-&gt;index
op_eq
id|index
)paren
(brace
id|kobject_get
c_func
(paren
op_amp
id|hp-&gt;kobj
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|hvc_structs_lock
)paren
suffix:semicolon
r_return
id|hp
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|hp
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|hvc_structs_lock
)paren
suffix:semicolon
r_return
id|hp
suffix:semicolon
)brace
multiline_comment|/*&n; * The TTY interface won&squot;t be used until after the vio layer has exposed the vty&n; * adapter to the kernel.&n; */
DECL|function|hvc_open
r_static
r_int
id|hvc_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|hvc_struct
op_star
id|hp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|irq
op_assign
id|NO_IRQ
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_struct
id|kobject
op_star
id|kobjp
suffix:semicolon
multiline_comment|/* Auto increments kobject reference if found. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|hp
op_assign
id|hvc_get_by_index
c_func
(paren
id|tty-&gt;index
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;hvc_console: tty open failed, no vty associated with tty.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Check and then increment for fast path open. */
r_if
c_cond
(paren
id|hp-&gt;count
op_increment
OG
l_int|0
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|hvc_kick
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* else count == 0 */
id|tty-&gt;driver_data
op_assign
id|hp
suffix:semicolon
id|hp-&gt;tty
op_assign
id|tty
suffix:semicolon
multiline_comment|/* Save for request_irq outside of spin_lock. */
id|irq
op_assign
id|hp-&gt;irq
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ne
id|NO_IRQ
)paren
id|hp-&gt;irq_requested
op_assign
l_int|1
suffix:semicolon
id|kobjp
op_assign
op_amp
id|hp-&gt;kobj
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* check error, fallback to non-irq */
r_if
c_cond
(paren
id|irq
op_ne
id|NO_IRQ
)paren
id|rc
op_assign
id|request_irq
c_func
(paren
id|irq
comma
id|hvc_handle_interrupt
comma
id|SA_INTERRUPT
comma
l_string|&quot;hvc_console&quot;
comma
id|hp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the request_irq() fails and we return an error.  The tty layer&n;&t; * will call hvc_close() after a failed open but we don&squot;t want to clean&n;&t; * up there so we&squot;ll clean up here and clear out the previously set&n;&t; * tty fields and return the kobject reference.&n;&t; */
r_if
c_cond
(paren
id|rc
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|hp-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
id|hp-&gt;irq_requested
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|tty-&gt;driver_data
op_assign
l_int|NULL
suffix:semicolon
id|kobject_put
c_func
(paren
id|kobjp
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;hvc_open: request_irq failed with rc %d.&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/* Force wakeup of the polling thread */
id|hvc_kick
c_func
(paren
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|hvc_close
r_static
r_void
id|hvc_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|hvc_struct
op_star
id|hp
suffix:semicolon
r_struct
id|kobject
op_star
id|kobjp
suffix:semicolon
r_int
id|irq
op_assign
id|NO_IRQ
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * No driver_data means that this close was issued after a failed&n;&t; * hvc_open by the tty layer&squot;s release_dev() function and we can just&n;&t; * exit cleanly because the kobject reference wasn&squot;t made.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;driver_data
)paren
r_return
suffix:semicolon
id|hp
op_assign
id|tty-&gt;driver_data
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|kobjp
op_assign
op_amp
id|hp-&gt;kobj
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|hp-&gt;count
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|hp-&gt;irq_requested
)paren
id|irq
op_assign
id|hp-&gt;irq
suffix:semicolon
id|hp-&gt;irq_requested
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We are done with the tty pointer now. */
id|hp-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Chain calls chars_in_buffer() and returns immediately if&n;&t;&t; * there is no buffered data otherwise sleeps on a wait queue&n;&t;&t; * waking periodically to check chars_in_buffer().&n;&t;&t; */
id|tty_wait_until_sent
c_func
(paren
id|tty
comma
id|HVC_CLOSE_WAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ne
id|NO_IRQ
)paren
id|free_irq
c_func
(paren
id|irq
comma
id|hp
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|hp-&gt;count
OL
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;hvc_close %X: oops, count is %d&bslash;n&quot;
comma
id|hp-&gt;vtermno
comma
id|hp-&gt;count
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|kobject_put
c_func
(paren
id|kobjp
)paren
suffix:semicolon
)brace
DECL|function|hvc_hangup
r_static
r_void
id|hvc_hangup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|hvc_struct
op_star
id|hp
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|irq
op_assign
id|NO_IRQ
suffix:semicolon
r_int
id|temp_open_count
suffix:semicolon
r_struct
id|kobject
op_star
id|kobjp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hp
)paren
r_return
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The N_TTY line discipline has problems such that in a close vs&n;&t; * open-&gt;hangup case this can be called after the final close so prevent&n;&t; * that from happening for now.&n;&t; */
r_if
c_cond
(paren
id|hp-&gt;count
op_le
l_int|0
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|kobjp
op_assign
op_amp
id|hp-&gt;kobj
suffix:semicolon
id|temp_open_count
op_assign
id|hp-&gt;count
suffix:semicolon
id|hp-&gt;count
op_assign
l_int|0
suffix:semicolon
id|hp-&gt;n_outbuf
op_assign
l_int|0
suffix:semicolon
id|hp-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|hp-&gt;irq_requested
)paren
multiline_comment|/* Saved for use outside of spin_lock. */
id|irq
op_assign
id|hp-&gt;irq
suffix:semicolon
id|hp-&gt;irq_requested
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ne
id|NO_IRQ
)paren
id|free_irq
c_func
(paren
id|irq
comma
id|hp
)paren
suffix:semicolon
r_while
c_loop
(paren
id|temp_open_count
)paren
(brace
op_decrement
id|temp_open_count
suffix:semicolon
id|kobject_put
c_func
(paren
id|kobjp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Push buffered characters whether they were just recently buffered or waiting&n; * on a blocked hypervisor.  Call this function with hp-&gt;lock held.&n; */
DECL|function|hvc_push
r_static
r_void
id|hvc_push
c_func
(paren
r_struct
id|hvc_struct
op_star
id|hp
)paren
(brace
r_int
id|n
suffix:semicolon
id|n
op_assign
id|hvc_put_chars
c_func
(paren
id|hp-&gt;vtermno
comma
id|hp-&gt;outbuf
comma
id|hp-&gt;n_outbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_le
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|n
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* throw away output on error; this happens when&n;&t;&t;   there is no session connected to the vterm. */
id|hp-&gt;n_outbuf
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|hp-&gt;n_outbuf
op_sub_assign
id|n
suffix:semicolon
r_if
c_cond
(paren
id|hp-&gt;n_outbuf
OG
l_int|0
)paren
id|memmove
c_func
(paren
id|hp-&gt;outbuf
comma
id|hp-&gt;outbuf
op_plus
id|n
comma
id|hp-&gt;n_outbuf
)paren
suffix:semicolon
r_else
id|hp-&gt;do_wakeup
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|__hvc_write_kernel
r_static
r_inline
r_int
id|__hvc_write_kernel
c_func
(paren
r_struct
id|hvc_struct
op_star
id|hp
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|rsize
comma
id|written
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Push pending writes */
r_if
c_cond
(paren
id|hp-&gt;n_outbuf
OG
l_int|0
)paren
id|hvc_push
c_func
(paren
id|hp
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
op_logical_and
(paren
id|rsize
op_assign
id|N_OUTBUF
op_minus
id|hp-&gt;n_outbuf
)paren
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|rsize
OG
id|count
)paren
id|rsize
op_assign
id|count
suffix:semicolon
id|memcpy
c_func
(paren
id|hp-&gt;outbuf
op_plus
id|hp-&gt;n_outbuf
comma
id|buf
comma
id|rsize
)paren
suffix:semicolon
id|count
op_sub_assign
id|rsize
suffix:semicolon
id|buf
op_add_assign
id|rsize
suffix:semicolon
id|hp-&gt;n_outbuf
op_add_assign
id|rsize
suffix:semicolon
id|written
op_add_assign
id|rsize
suffix:semicolon
id|hvc_push
c_func
(paren
id|hp
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|written
suffix:semicolon
)brace
DECL|function|hvc_write
r_static
r_int
id|hvc_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|hvc_struct
op_star
id|hp
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|written
suffix:semicolon
multiline_comment|/* This write was probably executed during a tty close. */
r_if
c_cond
(paren
op_logical_neg
id|hp
)paren
r_return
op_minus
id|EPIPE
suffix:semicolon
r_if
c_cond
(paren
id|hp-&gt;count
op_le
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|written
op_assign
id|__hvc_write_kernel
c_func
(paren
id|hp
comma
id|buf
comma
id|count
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Racy, but harmless, kick thread if there is still pending data.&n;&t; * There really is nothing wrong with kicking the thread, even if there&n;&t; * is no buffered data.&n;&t; */
r_if
c_cond
(paren
id|hp-&gt;n_outbuf
)paren
id|hvc_kick
c_func
(paren
)paren
suffix:semicolon
r_return
id|written
suffix:semicolon
)brace
multiline_comment|/*&n; * This is actually a contract between the driver and the tty layer outlining&n; * how much write room the driver can guarentee will be sent OR BUFFERED.  This&n; * driver MUST honor the return value.&n; */
DECL|function|hvc_write_room
r_static
r_int
id|hvc_write_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|hvc_struct
op_star
id|hp
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hp
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
id|N_OUTBUF
op_minus
id|hp-&gt;n_outbuf
suffix:semicolon
)brace
DECL|function|hvc_chars_in_buffer
r_static
r_int
id|hvc_chars_in_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|hvc_struct
op_star
id|hp
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hp
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
id|hp-&gt;n_outbuf
suffix:semicolon
)brace
DECL|macro|HVC_POLL_READ
mdefine_line|#define HVC_POLL_READ&t;0x00000001
DECL|macro|HVC_POLL_WRITE
mdefine_line|#define HVC_POLL_WRITE&t;0x00000002
DECL|macro|HVC_POLL_QUICK
mdefine_line|#define HVC_POLL_QUICK&t;0x00000004
DECL|function|hvc_poll
r_static
r_int
id|hvc_poll
c_func
(paren
r_struct
id|hvc_struct
op_star
id|hp
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_int
id|i
comma
id|n
comma
id|poll_mask
op_assign
l_int|0
suffix:semicolon
r_char
id|buf
(braket
id|N_INBUF
)braket
id|__ALIGNED__
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|read_total
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Push pending writes */
r_if
c_cond
(paren
id|hp-&gt;n_outbuf
OG
l_int|0
)paren
id|hvc_push
c_func
(paren
id|hp
)paren
suffix:semicolon
multiline_comment|/* Reschedule us if still some write pending */
r_if
c_cond
(paren
id|hp-&gt;n_outbuf
OG
l_int|0
)paren
id|poll_mask
op_or_assign
id|HVC_POLL_WRITE
suffix:semicolon
multiline_comment|/* No tty attached, just skip */
id|tty
op_assign
id|hp-&gt;tty
suffix:semicolon
r_if
c_cond
(paren
id|tty
op_eq
l_int|NULL
)paren
r_goto
id|bail
suffix:semicolon
multiline_comment|/* Now check if we can get data (are we throttled ?) */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|TTY_THROTTLED
comma
op_amp
id|tty-&gt;flags
)paren
)paren
r_goto
id|throttled
suffix:semicolon
multiline_comment|/* If we aren&squot;t interrupt driven and aren&squot;t throttled, we always&n;&t; * request a reschedule&n;&t; */
r_if
c_cond
(paren
id|hp-&gt;irq
op_eq
id|NO_IRQ
)paren
id|poll_mask
op_or_assign
id|HVC_POLL_READ
suffix:semicolon
multiline_comment|/* Read data if any */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|count
op_assign
id|N_INBUF
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
(paren
id|TTY_FLIPBUF_SIZE
op_minus
id|tty-&gt;flip.count
)paren
)paren
id|count
op_assign
id|TTY_FLIPBUF_SIZE
op_minus
id|tty-&gt;flip.count
suffix:semicolon
multiline_comment|/* If flip is full, just reschedule a later read */
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
(brace
id|poll_mask
op_or_assign
id|HVC_POLL_READ
suffix:semicolon
r_break
suffix:semicolon
)brace
id|n
op_assign
id|hvc_get_chars
c_func
(paren
id|hp-&gt;vtermno
comma
id|buf
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_le
l_int|0
)paren
(brace
multiline_comment|/* Hangup the tty when disconnected from host */
r_if
c_cond
(paren
id|n
op_eq
op_minus
id|EPIPE
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|tty_hangup
c_func
(paren
id|tty
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
op_increment
id|i
)paren
(brace
macro_line|#ifdef CONFIG_MAGIC_SYSRQ
multiline_comment|/* Handle the SysRq Hack */
r_if
c_cond
(paren
id|buf
(braket
id|i
)braket
op_eq
l_char|&squot;&bslash;x0f&squot;
)paren
(brace
multiline_comment|/* ^O -- should support a sequence */
id|sysrq_pressed
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sysrq_pressed
)paren
(brace
id|handle_sysrq
c_func
(paren
id|buf
(braket
id|i
)braket
comma
l_int|NULL
comma
id|tty
)paren
suffix:semicolon
id|sysrq_pressed
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_MAGIC_SYSRQ */
id|tty_insert_flip_char
c_func
(paren
id|tty
comma
id|buf
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;flip.count
)paren
id|tty_schedule_flip
c_func
(paren
id|tty
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Account for the total amount read in one loop, and if above&n;&t;&t; * 64 bytes, we do a quick schedule loop to let the tty grok the&n;&t;&t; * data and eventually throttle us.&n;&t;&t; */
id|read_total
op_add_assign
id|n
suffix:semicolon
r_if
c_cond
(paren
id|read_total
op_ge
l_int|64
)paren
(brace
id|poll_mask
op_or_assign
id|HVC_POLL_QUICK
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|throttled
suffix:colon
multiline_comment|/* Wakeup write queue if necessary */
r_if
c_cond
(paren
id|hp-&gt;do_wakeup
)paren
(brace
id|hp-&gt;do_wakeup
op_assign
l_int|0
suffix:semicolon
id|tty_wakeup
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
id|bail
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|poll_mask
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_XMON) &amp;&amp; defined(CONFIG_SMP)
r_extern
id|cpumask_t
id|cpus_in_xmon
suffix:semicolon
macro_line|#else
DECL|variable|cpus_in_xmon
r_static
r_const
id|cpumask_t
id|cpus_in_xmon
op_assign
id|CPU_MASK_NONE
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * This kthread is either polling or interrupt driven.  This is determined by&n; * calling hvc_poll() who determines whether a console adapter support&n; * interrupts.&n; */
DECL|function|khvcd
r_int
id|khvcd
c_func
(paren
r_void
op_star
id|unused
)paren
(brace
r_int
id|poll_mask
suffix:semicolon
r_struct
id|hvc_struct
op_star
id|hp
suffix:semicolon
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
r_do
(brace
id|poll_mask
op_assign
l_int|0
suffix:semicolon
id|hvc_kicked
op_assign
l_int|0
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpus_empty
c_func
(paren
id|cpus_in_xmon
)paren
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|hvc_structs_lock
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|hp
comma
op_amp
id|hvc_structs
comma
id|next
)paren
(brace
multiline_comment|/*hp = list_entry(node, struct hvc_struct, * next); */
id|poll_mask
op_or_assign
id|hvc_poll
c_func
(paren
id|hp
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|hvc_structs_lock
)paren
suffix:semicolon
)brace
r_else
id|poll_mask
op_or_assign
id|HVC_POLL_READ
suffix:semicolon
r_if
c_cond
(paren
id|hvc_kicked
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|poll_mask
op_amp
id|HVC_POLL_QUICK
)paren
(brace
id|yield
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hvc_kicked
)paren
(brace
r_if
c_cond
(paren
id|poll_mask
op_eq
l_int|0
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_else
id|msleep_interruptible
c_func
(paren
id|TIMEOUT
)paren
suffix:semicolon
)brace
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|kthread_should_stop
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|hvc_ops
r_static
r_struct
id|tty_operations
id|hvc_ops
op_assign
(brace
dot
id|open
op_assign
id|hvc_open
comma
dot
id|close
op_assign
id|hvc_close
comma
dot
id|write
op_assign
id|hvc_write
comma
dot
id|hangup
op_assign
id|hvc_hangup
comma
dot
id|unthrottle
op_assign
id|hvc_unthrottle
comma
dot
id|write_room
op_assign
id|hvc_write_room
comma
dot
id|chars_in_buffer
op_assign
id|hvc_chars_in_buffer
comma
)brace
suffix:semicolon
DECL|variable|hvc_driver_name
r_char
id|hvc_driver_name
(braket
)braket
op_assign
l_string|&quot;hvc_console&quot;
suffix:semicolon
DECL|variable|__devinitdata
r_static
r_struct
id|vio_device_id
id|hvc_driver_table
(braket
)braket
id|__devinitdata
op_assign
(brace
(brace
l_string|&quot;serial&quot;
comma
l_string|&quot;hvterm1&quot;
)brace
comma
(brace
l_int|NULL
comma
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
c_func
(paren
id|vio
comma
id|hvc_driver_table
)paren
suffix:semicolon
multiline_comment|/* callback when the kboject ref count reaches zero. */
DECL|function|destroy_hvc_struct
r_static
r_void
id|destroy_hvc_struct
c_func
(paren
r_struct
id|kobject
op_star
id|kobj
)paren
(brace
r_struct
id|hvc_struct
op_star
id|hp
op_assign
id|container_of
c_func
(paren
id|kobj
comma
r_struct
id|hvc_struct
comma
id|kobj
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|hvc_structs_lock
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
(paren
id|hp-&gt;next
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|hvc_structs_lock
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|hp
)paren
suffix:semicolon
)brace
DECL|variable|hvc_kobj_type
r_static
r_struct
id|kobj_type
id|hvc_kobj_type
op_assign
(brace
dot
id|release
op_assign
id|destroy_hvc_struct
comma
)brace
suffix:semicolon
DECL|function|hvc_probe
r_static
r_int
id|__devinit
id|hvc_probe
c_func
(paren
r_struct
id|vio_dev
op_star
id|dev
comma
r_const
r_struct
id|vio_device_id
op_star
id|id
)paren
(brace
r_struct
id|hvc_struct
op_star
id|hp
suffix:semicolon
multiline_comment|/* probed with invalid parameters. */
r_if
c_cond
(paren
op_logical_neg
id|dev
op_logical_or
op_logical_neg
id|id
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|hp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|hp
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hp
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|hp
comma
l_int|0x00
comma
r_sizeof
(paren
op_star
id|hp
)paren
)paren
suffix:semicolon
id|hp-&gt;vtermno
op_assign
id|dev-&gt;unit_address
suffix:semicolon
id|hp-&gt;vdev
op_assign
id|dev
suffix:semicolon
id|hp-&gt;vdev-&gt;dev.driver_data
op_assign
id|hp
suffix:semicolon
id|hp-&gt;irq
op_assign
id|dev-&gt;irq
suffix:semicolon
id|kobject_init
c_func
(paren
op_amp
id|hp-&gt;kobj
)paren
suffix:semicolon
id|hp-&gt;kobj.ktype
op_assign
op_amp
id|hvc_kobj_type
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|hp-&gt;lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|hvc_structs_lock
)paren
suffix:semicolon
id|hp-&gt;index
op_assign
op_increment
id|hvc_count
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
(paren
id|hp-&gt;next
)paren
comma
op_amp
id|hvc_structs
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|hvc_structs_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|hvc_remove
r_static
r_int
id|__devexit
id|hvc_remove
c_func
(paren
r_struct
id|vio_dev
op_star
id|dev
)paren
(brace
r_struct
id|hvc_struct
op_star
id|hp
op_assign
id|dev-&gt;dev.driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|kobject
op_star
id|kobjp
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|tty
op_assign
id|hp-&gt;tty
suffix:semicolon
id|kobjp
op_assign
op_amp
id|hp-&gt;kobj
suffix:semicolon
r_if
c_cond
(paren
id|hp-&gt;index
OL
id|MAX_NR_HVC_CONSOLES
)paren
id|vtermnos
(braket
id|hp-&gt;index
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Don&squot;t whack hp-&gt;irq because tty_hangup() will need to free the irq. */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We &squot;put&squot; the instance that was grabbed when the kobject instance&n;&t; * was intialized using kobject_init().  Let the last holder of this&n;&t; * kobject cause it to be removed, which will probably be the tty_hangup&n;&t; * below.&n;&t; */
id|kobject_put
c_func
(paren
id|kobjp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This function call will auto chain call hvc_hangup.  The tty should&n;&t; * always be valid at this time unless a simultaneous tty close already&n;&t; * cleaned up the hvc_struct.&n;&t; */
r_if
c_cond
(paren
id|tty
)paren
id|tty_hangup
c_func
(paren
id|tty
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|hvc_vio_driver
r_static
r_struct
id|vio_driver
id|hvc_vio_driver
op_assign
(brace
dot
id|name
op_assign
id|hvc_driver_name
comma
dot
id|id_table
op_assign
id|hvc_driver_table
comma
dot
id|probe
op_assign
id|hvc_probe
comma
dot
id|remove
op_assign
id|hvc_remove
comma
)brace
suffix:semicolon
multiline_comment|/* Driver initialization.  Follow console initialization.  This is where the TTY&n; * interfaces start to become available. */
DECL|function|hvc_init
r_int
id|__init
id|hvc_init
c_func
(paren
r_void
)paren
(brace
r_int
id|rc
suffix:semicolon
multiline_comment|/* We need more than num_vterms adapters due to hotplug additions. */
id|hvc_driver
op_assign
id|alloc_tty_driver
c_func
(paren
id|HVC_ALLOC_TTY_ADAPTERS
)paren
suffix:semicolon
multiline_comment|/* hvc_driver = alloc_tty_driver(num_vterms); */
r_if
c_cond
(paren
op_logical_neg
id|hvc_driver
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|hvc_driver-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
id|hvc_driver-&gt;devfs_name
op_assign
l_string|&quot;hvc/&quot;
suffix:semicolon
id|hvc_driver-&gt;driver_name
op_assign
l_string|&quot;hvc&quot;
suffix:semicolon
id|hvc_driver-&gt;name
op_assign
l_string|&quot;hvc&quot;
suffix:semicolon
id|hvc_driver-&gt;major
op_assign
id|HVC_MAJOR
suffix:semicolon
id|hvc_driver-&gt;minor_start
op_assign
id|HVC_MINOR
suffix:semicolon
id|hvc_driver-&gt;type
op_assign
id|TTY_DRIVER_TYPE_SYSTEM
suffix:semicolon
id|hvc_driver-&gt;init_termios
op_assign
id|tty_std_termios
suffix:semicolon
id|hvc_driver-&gt;flags
op_assign
id|TTY_DRIVER_REAL_RAW
suffix:semicolon
id|tty_set_operations
c_func
(paren
id|hvc_driver
comma
op_amp
id|hvc_ops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty_register_driver
c_func
(paren
id|hvc_driver
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;Couldn&squot;t register hvc console driver&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Always start the kthread because there can be hotplug vty adapters&n;&t; * added later. */
id|hvc_task
op_assign
id|kthread_run
c_func
(paren
id|khvcd
comma
l_int|NULL
comma
l_string|&quot;khvcd&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|hvc_task
)paren
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Couldn&squot;t create kthread for console.&bslash;n&quot;
)paren
suffix:semicolon
id|put_tty_driver
c_func
(paren
id|hvc_driver
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Register as a vio device to receive callbacks */
id|rc
op_assign
id|vio_register_driver
c_func
(paren
op_amp
id|hvc_vio_driver
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* This isn&squot;t particularily necessary due to this being a console driver but it&n; * is nice to be thorough */
DECL|function|hvc_exit
r_static
r_void
id|__exit
id|hvc_exit
c_func
(paren
r_void
)paren
(brace
id|kthread_stop
c_func
(paren
id|hvc_task
)paren
suffix:semicolon
id|vio_unregister_driver
c_func
(paren
op_amp
id|hvc_vio_driver
)paren
suffix:semicolon
id|tty_unregister_driver
c_func
(paren
id|hvc_driver
)paren
suffix:semicolon
multiline_comment|/* return tty_struct instances allocated in hvc_init(). */
id|put_tty_driver
c_func
(paren
id|hvc_driver
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Console APIs, NOT TTY.  These APIs are available immediately when&n; * hvc_console_setup() finds adapters.&n; */
multiline_comment|/*&n; * hvc_instantiate() is an early console discovery method which locates consoles&n; * prior to the vio subsystem discovering them.  Hotplugged vty adapters do NOT&n; * get an hvc_instantiate() callback since the appear after early console init.&n; */
DECL|function|hvc_instantiate
r_int
id|hvc_instantiate
c_func
(paren
r_uint32
id|vtermno
comma
r_int
id|index
)paren
(brace
r_if
c_cond
(paren
id|index
OL
l_int|0
op_logical_or
id|index
op_ge
id|MAX_NR_HVC_CONSOLES
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|vtermnos
(braket
id|index
)braket
op_ne
op_minus
l_int|1
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|vtermnos
(braket
id|index
)braket
op_assign
id|vtermno
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|hvc_console_print
r_void
id|hvc_console_print
c_func
(paren
r_struct
id|console
op_star
id|co
comma
r_const
r_char
op_star
id|b
comma
r_int
id|count
)paren
(brace
r_char
id|c
(braket
l_int|16
)braket
id|__ALIGNED__
suffix:semicolon
r_int
id|i
op_assign
l_int|0
comma
id|n
op_assign
l_int|0
suffix:semicolon
r_int
id|r
comma
id|donecr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Console access attempt outside of acceptable console range. */
r_if
c_cond
(paren
id|co-&gt;index
op_ge
id|MAX_NR_HVC_CONSOLES
)paren
r_return
suffix:semicolon
multiline_comment|/* This console adapter was removed so it is not useable. */
r_if
c_cond
(paren
id|vtermnos
(braket
id|co-&gt;index
)braket
OL
l_int|0
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
op_logical_or
id|i
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|count
OG
l_int|0
op_logical_and
id|i
OL
r_sizeof
(paren
id|c
)paren
)paren
(brace
r_if
c_cond
(paren
id|b
(braket
id|n
)braket
op_eq
l_char|&squot;&bslash;n&squot;
op_logical_and
op_logical_neg
id|donecr
)paren
(brace
id|c
(braket
id|i
op_increment
)braket
op_assign
l_char|&squot;&bslash;r&squot;
suffix:semicolon
id|donecr
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|c
(braket
id|i
op_increment
)braket
op_assign
id|b
(braket
id|n
op_increment
)braket
suffix:semicolon
id|donecr
op_assign
l_int|0
suffix:semicolon
op_decrement
id|count
suffix:semicolon
)brace
)brace
r_else
(brace
id|r
op_assign
id|hvc_put_chars
c_func
(paren
id|vtermnos
(braket
id|co-&gt;index
)braket
comma
id|c
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OL
l_int|0
)paren
(brace
multiline_comment|/* throw away chars on error */
id|i
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|r
OG
l_int|0
)paren
(brace
id|i
op_sub_assign
id|r
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|0
)paren
id|memmove
c_func
(paren
id|c
comma
id|c
op_plus
id|r
comma
id|i
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
DECL|function|hvc_console_device
r_static
r_struct
id|tty_driver
op_star
id|hvc_console_device
c_func
(paren
r_struct
id|console
op_star
id|c
comma
r_int
op_star
id|index
)paren
(brace
op_star
id|index
op_assign
id|c-&gt;index
suffix:semicolon
r_return
id|hvc_driver
suffix:semicolon
)brace
DECL|function|hvc_console_setup
r_static
r_int
id|__init
id|hvc_console_setup
c_func
(paren
r_struct
id|console
op_star
id|co
comma
r_char
op_star
id|options
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|hvc_con_driver
r_struct
id|console
id|hvc_con_driver
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;hvc&quot;
comma
dot
id|write
op_assign
id|hvc_console_print
comma
dot
id|device
op_assign
id|hvc_console_device
comma
dot
id|setup
op_assign
id|hvc_console_setup
comma
dot
id|flags
op_assign
id|CON_PRINTBUFFER
comma
dot
id|index
op_assign
op_minus
l_int|1
comma
)brace
suffix:semicolon
multiline_comment|/* Early console initialization.  Preceeds driver initialization. */
DECL|function|hvc_console_init
r_static
r_int
id|__init
id|hvc_console_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_NR_HVC_CONSOLES
suffix:semicolon
id|i
op_increment
)paren
id|vtermnos
(braket
id|i
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|num_vterms
op_assign
id|hvc_find_vtys
c_func
(paren
)paren
suffix:semicolon
id|register_console
c_func
(paren
op_amp
id|hvc_con_driver
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|hvc_console_init
id|console_initcall
c_func
(paren
id|hvc_console_init
)paren
suffix:semicolon
DECL|variable|hvc_init
id|module_init
c_func
(paren
id|hvc_init
)paren
suffix:semicolon
DECL|variable|hvc_exit
id|module_exit
c_func
(paren
id|hvc_exit
)paren
suffix:semicolon
eof
