multiline_comment|/*&n; * IBM eServer Hypervisor Virtual Console Server Device Driver&n; * Copyright (C) 2003, 2004 IBM Corp.&n; *  Ryan S. Arnold (rsa@us.ibm.com)&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA&n; *&n; * Author(s) :  Ryan S. Arnold &lt;rsa@us.ibm.com&gt;&n; *&n; * This is the device driver for the IBM Hypervisor Virtual Console Server,&n; * &quot;hvcs&quot;.  The IBM hvcs provides a tty driver interface to allow Linux&n; * user space applications access to the system consoles of logically&n; * partitioned operating systems, e.g. Linux, running on the same partitioned&n; * Power5 ppc64 system.  Physical hardware consoles per partition are not&n; * practical on this hardware so system consoles are accessed by this driver&n; * using inter-partition firmware interfaces to virtual terminal devices.&n; *&n; * A vty is known to the HMC as a &quot;virtual serial server adapter&quot;.  It is a&n; * virtual terminal device that is created by firmware upon partition creation&n; * to act as a partitioned OS&squot;s console device.&n; *&n; * Firmware dynamically (via hotplug) exposes vty-servers to a running ppc64&n; * Linux system upon their creation by the HMC or their exposure during boot.&n; * The non-user interactive backend of this driver is implemented as a vio&n; * device driver so that it can receive notification of vty-server lifetimes&n; * after it registers with the vio bus to handle vty-server probe and remove&n; * callbacks.&n; *&n; * Many vty-servers can be configured to connect to one vty, but a vty can&n; * only be actively connected to by a single vty-server, in any manner, at one&n; * time.  If the HMC is currently hosting the console for a target Linux&n; * partition; attempts to open the tty device to the partition&squot;s console using&n; * the hvcs on any partition will return -EBUSY with every open attempt until&n; * the HMC frees the connection between its vty-server and the desired&n; * partition&squot;s vty device.  Conversely, a vty-server may only be connected to&n; * a single vty at one time even though it may have several configured vty&n; * partner possibilities.&n; *&n; * Firmware does not provide notification of vty partner changes to this&n; * driver.  This means that an HMC Super Admin may add or remove partner vtys&n; * from a vty-server&squot;s partner list but the changes will not be signaled to&n; * the vty-server.  Firmware only notifies the driver when a vty-server is&n; * added or removed from the system.  To compensate for this deficiency, this&n; * driver implements a sysfs update attribute which provides a method for&n; * rescanning partner information upon a user&squot;s request.&n; *&n; * Each vty-server, prior to being exposed to this driver is reference counted&n; * using the 2.6 Linux kernel kobject construct.  This kobject is also used by&n; * the vio bus to provide a vio device sysfs entry that this driver attaches&n; * device specific attributes to, including partner information.  The vio bus&n; * framework also provides a sysfs entry for each vio driver.  The hvcs driver&n; * provides driver attributes in this entry.&n; *&n; * For direction on installation and usage of this driver please reference&n; * Documentation/powerpc/hvcs.txt.&n; */
macro_line|#include &lt;linux/device.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/kobject.h&gt;
macro_line|#include &lt;linux/kthread.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/tty_flip.h&gt;
macro_line|#include &lt;asm/hvconsole.h&gt;
macro_line|#include &lt;asm/hvcserver.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/vio.h&gt;
multiline_comment|/*&n; * 1.0.0 -&gt; 1.1.0 Added kernel_thread scheduling methodology to driver to&n; * replace wait_task constructs.&n; *&n; * 1.1.0 -&gt; 1.2.0 Moved pi_buff initialization out of arch code into driver code&n; * and added locking to share this buffer between hvcs_struct instances.  This&n; * is because the page_size kmalloc can&squot;t be done with a spin_lock held.&n; *&n; * Also added sysfs attribute to manually disconnect the vty-server from the vty&n; * due to stupid firmware behavior when opening the connection then sending data&n; * then then quickly closing the connection would cause data loss on the&n; * receiving side.  This required some reordering of the termination code.&n; *&n; * Fixed the hangup scenario and fixed memory leaks on module_exit.&n; *&n; * 1.2.0 -&gt; 1.3.0 Moved from manual kernel thread creation &amp; execution to&n; * kthread construct which replaced in-kernel IPC for thread termination with&n; * kthread_stop and kthread_should_stop.  Explicit wait_queue handling was&n; * removed because kthread handles this.  Minor bug fix to postpone partner_info&n; * clearing on hvcs_close until adapter removal to preserve context data for&n; * printk on partner connection free.  Added lock to protect hvcs_structs so&n; * that hvcs_struct instances aren&squot;t added or removed during list traversal.&n; * Cleaned up comment style, added spaces after commas, and broke function&n; * declaration lines to be under 80 columns.&n; */
DECL|macro|HVCS_DRIVER_VERSION
mdefine_line|#define HVCS_DRIVER_VERSION &quot;1.3.0&quot;
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Ryan S. Arnold &lt;rsa@us.ibm.com&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;IBM hvcs (Hypervisor Virtual Console Server) Driver&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|variable|HVCS_DRIVER_VERSION
id|MODULE_VERSION
c_func
(paren
id|HVCS_DRIVER_VERSION
)paren
suffix:semicolon
multiline_comment|/*&n; * Since the Linux TTY code does not currently (2-04-2004) support dynamic&n; * addition of tty derived devices and we shouldn&squot;t allocate thousands of&n; * tty_device pointers when the number of vty-server &amp; vty partner connections&n; * will most often be much lower than this, we&squot;ll arbitrarily allocate&n; * HVCS_DEFAULT_SERVER_ADAPTERS tty_structs and cdev&squot;s by default when we&n; * register the tty_driver. This can be overridden using an insmod parameter.&n; */
DECL|macro|HVCS_DEFAULT_SERVER_ADAPTERS
mdefine_line|#define HVCS_DEFAULT_SERVER_ADAPTERS&t;64
multiline_comment|/*&n; * The user can&squot;t insmod with more than HVCS_MAX_SERVER_ADAPTERS hvcs device&n; * nodes as a sanity check.  Theoretically there can be over 1 Billion&n; * vty-server &amp; vty partner connections.&n; */
DECL|macro|HVCS_MAX_SERVER_ADAPTERS
mdefine_line|#define HVCS_MAX_SERVER_ADAPTERS&t;1024
multiline_comment|/*&n; * We let Linux assign us a major number and we start the minors at zero.  There&n; * is no intuitive mapping between minor number and the target partition.  The&n; * mapping of minor number is related to the order the vty-servers are exposed&n; * to this driver via the hvcs_probe function.&n; */
DECL|macro|HVCS_MINOR_START
mdefine_line|#define HVCS_MINOR_START&t;0
multiline_comment|/*&n; * The hcall interface involves putting 8 chars into each of two registers.&n; * We load up those 2 registers (in arch/ppc64/hvconsole.c) by casting char[16]&n; * to long[2].  It would work without __ALIGNED__, but a little (tiny) bit&n; * slower because an unaligned load is slower than aligned load.&n; */
DECL|macro|__ALIGNED__
mdefine_line|#define __ALIGNED__&t;__attribute__((__aligned__(8)))
multiline_comment|/* Converged location code string length + 1 null terminator */
DECL|macro|CLC_LENGTH
mdefine_line|#define CLC_LENGTH&t;&t;80
multiline_comment|/*&n; * How much data can firmware send with each hvc_put_chars()?  Maybe this&n; * should be moved into an architecture specific area.&n; */
DECL|macro|HVCS_BUFF_LEN
mdefine_line|#define HVCS_BUFF_LEN&t;16
multiline_comment|/*&n; * This is the maximum amount of data we&squot;ll let the user send us (hvcs_write) at&n; * once in a chunk as a sanity check.&n; */
DECL|macro|HVCS_MAX_FROM_USER
mdefine_line|#define HVCS_MAX_FROM_USER&t;4096
multiline_comment|/*&n; * Be careful when adding flags to this line discipline.  Don&squot;t add anything&n; * that will cause echoing or we&squot;ll go into recursive loop echoing chars back&n; * and forth with the console drivers.&n; */
DECL|variable|hvcs_tty_termios
r_static
r_struct
id|termios
id|hvcs_tty_termios
op_assign
(brace
dot
id|c_iflag
op_assign
id|IGNBRK
op_or
id|IGNPAR
comma
dot
id|c_oflag
op_assign
id|OPOST
comma
dot
id|c_cflag
op_assign
id|B38400
op_or
id|CS8
op_or
id|CREAD
op_or
id|HUPCL
comma
dot
id|c_cc
op_assign
id|INIT_C_CC
)brace
suffix:semicolon
multiline_comment|/*&n; * This value is used to take the place of a command line parameter when the&n; * module is inserted.  It starts as -1 and stays as such if the user doesn&squot;t&n; * specify a module insmod parameter.  If they DO specify one then it is set to&n; * the value of the integer passed in.&n; */
DECL|variable|hvcs_parm_num_devs
r_static
r_int
id|hvcs_parm_num_devs
op_assign
op_minus
l_int|1
suffix:semicolon
id|module_param
c_func
(paren
id|hvcs_parm_num_devs
comma
r_int
comma
l_int|0
)paren
suffix:semicolon
DECL|variable|hvcs_driver_name
r_char
id|hvcs_driver_name
(braket
)braket
op_assign
l_string|&quot;hvcs&quot;
suffix:semicolon
DECL|variable|hvcs_device_node
r_char
id|hvcs_device_node
(braket
)braket
op_assign
l_string|&quot;hvcs&quot;
suffix:semicolon
DECL|variable|hvcs_driver_string
r_char
id|hvcs_driver_string
(braket
)braket
op_assign
l_string|&quot;IBM hvcs (Hypervisor Virtual Console Server) Driver&quot;
suffix:semicolon
multiline_comment|/* Status of partner info rescan triggered via sysfs. */
DECL|variable|hvcs_rescan_status
r_static
r_int
id|hvcs_rescan_status
op_assign
l_int|0
suffix:semicolon
DECL|variable|hvcs_tty_driver
r_static
r_struct
id|tty_driver
op_star
id|hvcs_tty_driver
suffix:semicolon
multiline_comment|/*&n; * This is used to associate a vty-server, as it is exposed to this driver, with&n; * a preallocated tty_struct.index.  The dev node and hvcs index numbers are not&n; * re-used after device removal otherwise removing and adding a new one would&n; * link a /dev/hvcs* entry to a different vty-server than it did before the&n; * removal.  Incidentally, a newly exposed vty-server will always map to an&n; * incrementally higher /dev/hvcs* entry than the last exposed vty-server.&n; */
DECL|variable|hvcs_struct_count
r_static
r_int
id|hvcs_struct_count
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n; * Used by the khvcsd to pick up I/O operations when the kernel_thread is&n; * already awake but potentially shifted to TASK_INTERRUPTIBLE state.&n; */
DECL|variable|hvcs_kicked
r_static
r_int
id|hvcs_kicked
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Used the the kthread construct for task operations */
DECL|variable|hvcs_task
r_static
r_struct
id|task_struct
op_star
id|hvcs_task
suffix:semicolon
multiline_comment|/*&n; * We allocate this for the use of all of the hvcs_structs when they fetch&n; * partner info.&n; */
DECL|variable|hvcs_pi_buff
r_static
r_int
r_int
op_star
id|hvcs_pi_buff
suffix:semicolon
DECL|variable|hvcs_pi_lock
r_static
id|spinlock_t
id|hvcs_pi_lock
suffix:semicolon
multiline_comment|/* One vty-server per hvcs_struct */
DECL|struct|hvcs_struct
r_struct
id|hvcs_struct
(brace
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
multiline_comment|/*&n;&t; * This index identifies this hvcs device as the complement to a&n;&t; * specific tty index.&n;&t; */
DECL|member|index
r_int
r_int
id|index
suffix:semicolon
DECL|member|tty
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
DECL|member|open_count
r_int
r_int
id|open_count
suffix:semicolon
multiline_comment|/*&n;&t; * Used to tell the driver kernel_thread what operations need to take&n;&t; * place upon this hvcs_struct instance.&n;&t; */
DECL|member|todo_mask
r_int
id|todo_mask
suffix:semicolon
multiline_comment|/*&n;&t; * This buffer is required so that when hvcs_write_room() reports that&n;&t; * it can send HVCS_BUFF_LEN characters that it will buffer the full&n;&t; * HVCS_BUFF_LEN characters if need be.  This is essential for opost&n;&t; * writes since they do not do high level buffering and expect to be&n;&t; * able to send what the driver commits to sending buffering&n;&t; * [e.g. tab to space conversions in n_tty.c opost()].&n;&t; */
DECL|member|buffer
r_char
id|buffer
(braket
id|HVCS_BUFF_LEN
)braket
suffix:semicolon
DECL|member|chars_in_buffer
r_int
id|chars_in_buffer
suffix:semicolon
multiline_comment|/*&n;&t; * Any variable below the kobject is valid before a tty is connected and&n;&t; * stays valid after the tty is disconnected.  These shouldn&squot;t be&n;&t; * whacked until the koject refcount reaches zero though some entries&n;&t; * may be changed via sysfs initiatives.&n;&t; */
DECL|member|kobj
r_struct
id|kobject
id|kobj
suffix:semicolon
multiline_comment|/* ref count &amp; hvcs_struct lifetime */
DECL|member|connected
r_int
id|connected
suffix:semicolon
multiline_comment|/* is the vty-server currently connected to a vty? */
DECL|member|p_unit_address
r_int
r_int
id|p_unit_address
suffix:semicolon
multiline_comment|/* partner unit address */
DECL|member|p_partition_ID
r_int
r_int
id|p_partition_ID
suffix:semicolon
multiline_comment|/* partner partition ID */
DECL|member|p_location_code
r_char
id|p_location_code
(braket
id|CLC_LENGTH
)braket
suffix:semicolon
DECL|member|next
r_struct
id|list_head
id|next
suffix:semicolon
multiline_comment|/* list management */
DECL|member|vdev
r_struct
id|vio_dev
op_star
id|vdev
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Required to back map a kobject to its containing object */
DECL|macro|from_kobj
mdefine_line|#define from_kobj(kobj) container_of(kobj, struct hvcs_struct, kobj)
DECL|variable|hvcs_structs
r_static
r_struct
id|list_head
id|hvcs_structs
op_assign
id|LIST_HEAD_INIT
c_func
(paren
id|hvcs_structs
)paren
suffix:semicolon
DECL|variable|hvcs_structs_lock
r_static
id|spinlock_t
id|hvcs_structs_lock
suffix:semicolon
r_static
r_void
id|hvcs_unthrottle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|hvcs_throttle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
id|irqreturn_t
id|hvcs_handle_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_instance
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_int
id|hvcs_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
suffix:semicolon
r_static
r_int
id|hvcs_write_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_int
id|hvcs_chars_in_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_int
id|hvcs_has_pi
c_func
(paren
r_struct
id|hvcs_struct
op_star
id|hvcsd
)paren
suffix:semicolon
r_static
r_void
id|hvcs_set_pi
c_func
(paren
r_struct
id|hvcs_partner_info
op_star
id|pi
comma
r_struct
id|hvcs_struct
op_star
id|hvcsd
)paren
suffix:semicolon
r_static
r_int
id|hvcs_get_pi
c_func
(paren
r_struct
id|hvcs_struct
op_star
id|hvcsd
)paren
suffix:semicolon
r_static
r_int
id|hvcs_rescan_devices_list
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|hvcs_partner_connect
c_func
(paren
r_struct
id|hvcs_struct
op_star
id|hvcsd
)paren
suffix:semicolon
r_static
r_void
id|hvcs_partner_free
c_func
(paren
r_struct
id|hvcs_struct
op_star
id|hvcsd
)paren
suffix:semicolon
r_static
r_int
id|hvcs_enable_device
c_func
(paren
r_struct
id|hvcs_struct
op_star
id|hvcsd
comma
r_uint32
id|unit_address
comma
r_int
r_int
id|irq
comma
r_struct
id|vio_dev
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|hvcs_final_close
c_func
(paren
r_struct
id|hvcs_struct
op_star
id|hvcsd
)paren
suffix:semicolon
r_static
r_void
id|destroy_hvcs_struct
c_func
(paren
r_struct
id|kobject
op_star
id|kobj
)paren
suffix:semicolon
r_static
r_int
id|hvcs_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_void
id|hvcs_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_void
id|hvcs_hangup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|hvcs_create_device_attrs
c_func
(paren
r_struct
id|hvcs_struct
op_star
id|hvcsd
)paren
suffix:semicolon
r_static
r_void
id|hvcs_remove_device_attrs
c_func
(paren
r_struct
id|vio_dev
op_star
id|vdev
)paren
suffix:semicolon
r_static
r_void
id|hvcs_create_driver_attrs
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|hvcs_remove_driver_attrs
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|__devinit
id|hvcs_probe
c_func
(paren
r_struct
id|vio_dev
op_star
id|dev
comma
r_const
r_struct
id|vio_device_id
op_star
id|id
)paren
suffix:semicolon
r_static
r_int
id|__devexit
id|hvcs_remove
c_func
(paren
r_struct
id|vio_dev
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|__init
id|hvcs_module_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|__exit
id|hvcs_module_exit
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|macro|HVCS_SCHED_READ
mdefine_line|#define HVCS_SCHED_READ&t;0x00000001
DECL|macro|HVCS_QUICK_READ
mdefine_line|#define HVCS_QUICK_READ&t;0x00000002
DECL|macro|HVCS_TRY_WRITE
mdefine_line|#define HVCS_TRY_WRITE&t;0x00000004
DECL|macro|HVCS_READ_MASK
mdefine_line|#define HVCS_READ_MASK&t;(HVCS_SCHED_READ | HVCS_QUICK_READ)
DECL|function|hvcs_kick
r_static
r_void
id|hvcs_kick
c_func
(paren
r_void
)paren
(brace
id|hvcs_kicked
op_assign
l_int|1
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|wake_up_process
c_func
(paren
id|hvcs_task
)paren
suffix:semicolon
)brace
DECL|function|hvcs_unthrottle
r_static
r_void
id|hvcs_unthrottle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|hvcs_struct
op_star
id|hvcsd
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|hvcsd-&gt;todo_mask
op_or_assign
id|HVCS_SCHED_READ
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|hvcs_kick
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|hvcs_throttle
r_static
r_void
id|hvcs_throttle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|hvcs_struct
op_star
id|hvcsd
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|vio_disable_interrupts
c_func
(paren
id|hvcsd-&gt;vdev
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * If the device is being removed we don&squot;t have to worry about this interrupt&n; * handler taking any further interrupts because they are disabled which means&n; * the hvcs_struct will always be valid in this handler.&n; */
DECL|function|hvcs_handle_interrupt
r_static
id|irqreturn_t
id|hvcs_handle_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_instance
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|hvcs_struct
op_star
id|hvcsd
op_assign
id|dev_instance
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|vio_disable_interrupts
c_func
(paren
id|hvcsd-&gt;vdev
)paren
suffix:semicolon
id|hvcsd-&gt;todo_mask
op_or_assign
id|HVCS_SCHED_READ
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|hvcs_kick
c_func
(paren
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/* This function must be called with the hvcsd-&gt;lock held */
DECL|function|hvcs_try_write
r_static
r_void
id|hvcs_try_write
c_func
(paren
r_struct
id|hvcs_struct
op_star
id|hvcsd
)paren
(brace
r_int
r_int
id|unit_address
op_assign
id|hvcsd-&gt;vdev-&gt;unit_address
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|hvcsd-&gt;tty
suffix:semicolon
r_int
id|sent
suffix:semicolon
r_if
c_cond
(paren
id|hvcsd-&gt;todo_mask
op_amp
id|HVCS_TRY_WRITE
)paren
(brace
multiline_comment|/* won&squot;t send partial writes */
id|sent
op_assign
id|hvc_put_chars
c_func
(paren
id|unit_address
comma
op_amp
id|hvcsd-&gt;buffer
(braket
l_int|0
)braket
comma
id|hvcsd-&gt;chars_in_buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sent
OG
l_int|0
)paren
(brace
id|hvcsd-&gt;chars_in_buffer
op_assign
l_int|0
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|hvcsd-&gt;todo_mask
op_and_assign
op_complement
(paren
id|HVCS_TRY_WRITE
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We are still obligated to deliver the data to the&n;&t;&t;&t; * hypervisor even if the tty has been closed because&n;&t;&t;&t; * we commited to delivering it.  But don&squot;t try to wake&n;&t;&t;&t; * a non-existent tty.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|tty
)paren
(brace
r_if
c_cond
(paren
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
DECL|function|hvcs_io
r_static
r_int
id|hvcs_io
c_func
(paren
r_struct
id|hvcs_struct
op_star
id|hvcsd
)paren
(brace
r_int
r_int
id|unit_address
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_char
id|buf
(braket
id|HVCS_BUFF_LEN
)braket
id|__ALIGNED__
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|got
suffix:semicolon
r_int
id|i
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|unit_address
op_assign
id|hvcsd-&gt;vdev-&gt;unit_address
suffix:semicolon
id|tty
op_assign
id|hvcsd-&gt;tty
suffix:semicolon
id|hvcs_try_write
c_func
(paren
id|hvcsd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
op_logical_or
id|test_bit
c_func
(paren
id|TTY_THROTTLED
comma
op_amp
id|tty-&gt;flags
)paren
)paren
(brace
id|hvcsd-&gt;todo_mask
op_and_assign
op_complement
(paren
id|HVCS_READ_MASK
)paren
suffix:semicolon
r_goto
id|bail
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|hvcsd-&gt;todo_mask
op_amp
(paren
id|HVCS_READ_MASK
)paren
)paren
)paren
r_goto
id|bail
suffix:semicolon
multiline_comment|/* remove the read masks */
id|hvcsd-&gt;todo_mask
op_and_assign
op_complement
(paren
id|HVCS_READ_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tty-&gt;flip.count
op_plus
id|HVCS_BUFF_LEN
)paren
OL
id|TTY_FLIPBUF_SIZE
)paren
(brace
id|got
op_assign
id|hvc_get_chars
c_func
(paren
id|unit_address
comma
op_amp
id|buf
(braket
l_int|0
)braket
comma
id|HVCS_BUFF_LEN
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|got
op_logical_and
id|i
OL
id|got
suffix:semicolon
id|i
op_increment
)paren
id|tty_insert_flip_char
c_func
(paren
id|tty
comma
id|buf
(braket
id|i
)braket
comma
id|TTY_NORMAL
)paren
suffix:semicolon
)brace
multiline_comment|/* Give the TTY time to process the data we just sent. */
r_if
c_cond
(paren
id|got
)paren
id|hvcsd-&gt;todo_mask
op_or_assign
id|HVCS_QUICK_READ
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;flip.count
)paren
(brace
multiline_comment|/* This is synch because tty-&gt;low_latency == 1 */
id|tty_flip_buffer_push
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|got
)paren
(brace
multiline_comment|/* Do this _after_ the flip_buffer_push */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|vio_enable_interrupts
c_func
(paren
id|hvcsd-&gt;vdev
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|hvcsd-&gt;todo_mask
suffix:semicolon
id|bail
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|hvcsd-&gt;todo_mask
suffix:semicolon
)brace
DECL|function|khvcsd
r_static
r_int
id|khvcsd
c_func
(paren
r_void
op_star
id|unused
)paren
(brace
r_struct
id|hvcs_struct
op_star
id|hvcsd
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|list_head
op_star
id|element
suffix:semicolon
r_struct
id|list_head
op_star
id|safe_temp
suffix:semicolon
r_int
id|hvcs_todo_mask
suffix:semicolon
r_int
r_int
id|structs_flags
suffix:semicolon
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
r_do
(brace
id|hvcs_todo_mask
op_assign
l_int|0
suffix:semicolon
id|hvcs_kicked
op_assign
l_int|0
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hvcs_structs_lock
comma
id|structs_flags
)paren
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|element
comma
id|safe_temp
comma
op_amp
id|hvcs_structs
)paren
(brace
id|hvcsd
op_assign
id|list_entry
c_func
(paren
id|element
comma
r_struct
id|hvcs_struct
comma
id|next
)paren
suffix:semicolon
id|hvcs_todo_mask
op_or_assign
id|hvcs_io
c_func
(paren
id|hvcsd
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcs_structs_lock
comma
id|structs_flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If any of the hvcs adapters want to try a write or quick read&n;&t;&t; * don&squot;t schedule(), yield a smidgen then execute the hvcs_io&n;&t;&t; * thread again for those that want the write.&n;&t;&t; */
r_if
c_cond
(paren
id|hvcs_todo_mask
op_amp
(paren
id|HVCS_TRY_WRITE
op_or
id|HVCS_QUICK_READ
)paren
)paren
(brace
id|yield
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hvcs_kicked
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|kthread_should_stop
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|__devinitdata
r_static
r_struct
id|vio_device_id
id|hvcs_driver_table
(braket
)braket
id|__devinitdata
op_assign
(brace
(brace
l_string|&quot;serial-server&quot;
comma
l_string|&quot;hvterm2&quot;
)brace
comma
(brace
l_int|0
comma
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
c_func
(paren
id|vio
comma
id|hvcs_driver_table
)paren
suffix:semicolon
multiline_comment|/* callback when the kboject ref count reaches zero */
DECL|function|destroy_hvcs_struct
r_static
r_void
id|destroy_hvcs_struct
c_func
(paren
r_struct
id|kobject
op_star
id|kobj
)paren
(brace
r_struct
id|hvcs_struct
op_star
id|hvcsd
op_assign
id|from_kobj
c_func
(paren
id|kobj
)paren
suffix:semicolon
r_struct
id|vio_dev
op_star
id|vdev
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* the list_del poisons the pointers */
id|list_del
c_func
(paren
op_amp
(paren
id|hvcsd-&gt;next
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hvcsd-&gt;connected
op_eq
l_int|1
)paren
(brace
id|hvcs_partner_free
c_func
(paren
id|hvcsd
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;HVCS: Closed vty-server@%X and&quot;
l_string|&quot; partner vty@%X:%d connection.&bslash;n&quot;
comma
id|hvcsd-&gt;vdev-&gt;unit_address
comma
id|hvcsd-&gt;p_unit_address
comma
(paren
r_int
r_int
)paren
id|hvcsd-&gt;p_partition_ID
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;HVCS: Destroyed hvcs_struct for vty-server@%X.&bslash;n&quot;
comma
id|hvcsd-&gt;vdev-&gt;unit_address
)paren
suffix:semicolon
id|vdev
op_assign
id|hvcsd-&gt;vdev
suffix:semicolon
id|hvcsd-&gt;vdev
op_assign
l_int|NULL
suffix:semicolon
id|hvcsd-&gt;p_unit_address
op_assign
l_int|0
suffix:semicolon
id|hvcsd-&gt;p_partition_ID
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|hvcsd-&gt;p_location_code
(braket
l_int|0
)braket
comma
l_int|0x00
comma
id|CLC_LENGTH
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|hvcs_remove_device_attrs
c_func
(paren
id|vdev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|hvcsd
)paren
suffix:semicolon
)brace
multiline_comment|/* This function must be called with hvcsd-&gt;lock held. */
DECL|function|hvcs_final_close
r_static
r_void
id|hvcs_final_close
c_func
(paren
r_struct
id|hvcs_struct
op_star
id|hvcsd
)paren
(brace
id|vio_disable_interrupts
c_func
(paren
id|hvcsd-&gt;vdev
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|hvcsd-&gt;vdev-&gt;irq
comma
id|hvcsd
)paren
suffix:semicolon
id|hvcsd-&gt;todo_mask
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* These two may be redundant if the operation was a close. */
r_if
c_cond
(paren
id|hvcsd-&gt;tty
)paren
(brace
id|hvcsd-&gt;tty-&gt;driver_data
op_assign
l_int|NULL
suffix:semicolon
id|hvcsd-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
)brace
id|hvcsd-&gt;open_count
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|hvcsd-&gt;buffer
(braket
l_int|0
)braket
comma
l_int|0x00
comma
id|HVCS_BUFF_LEN
)paren
suffix:semicolon
id|hvcsd-&gt;chars_in_buffer
op_assign
l_int|0
suffix:semicolon
)brace
DECL|variable|hvcs_kobj_type
r_static
r_struct
id|kobj_type
id|hvcs_kobj_type
op_assign
(brace
dot
id|release
op_assign
id|destroy_hvcs_struct
comma
)brace
suffix:semicolon
DECL|function|hvcs_probe
r_static
r_int
id|__devinit
id|hvcs_probe
c_func
(paren
r_struct
id|vio_dev
op_star
id|dev
comma
r_const
r_struct
id|vio_device_id
op_star
id|id
)paren
(brace
r_struct
id|hvcs_struct
op_star
id|hvcsd
suffix:semicolon
r_int
r_int
id|structs_flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
op_logical_or
op_logical_neg
id|id
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;HVCS: probed with invalid parameter.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|hvcsd
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|hvcsd
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hvcsd
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* hvcsd-&gt;tty is zeroed out with the memset */
id|memset
c_func
(paren
id|hvcsd
comma
l_int|0x00
comma
r_sizeof
(paren
op_star
id|hvcsd
)paren
)paren
suffix:semicolon
id|hvcsd-&gt;lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* Automatically incs the refcount the first time */
id|kobject_init
c_func
(paren
op_amp
id|hvcsd-&gt;kobj
)paren
suffix:semicolon
multiline_comment|/* Set up the callback for terminating the hvcs_struct&squot;s life */
id|hvcsd-&gt;kobj.ktype
op_assign
op_amp
id|hvcs_kobj_type
suffix:semicolon
id|hvcsd-&gt;vdev
op_assign
id|dev
suffix:semicolon
id|dev-&gt;dev.driver_data
op_assign
id|hvcsd
suffix:semicolon
id|hvcsd-&gt;index
op_assign
op_increment
id|hvcs_struct_count
suffix:semicolon
id|hvcsd-&gt;chars_in_buffer
op_assign
l_int|0
suffix:semicolon
id|hvcsd-&gt;todo_mask
op_assign
l_int|0
suffix:semicolon
id|hvcsd-&gt;connected
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * This will populate the hvcs_struct&squot;s partner info fields for the&n;&t; * first time.&n;&t; */
r_if
c_cond
(paren
id|hvcs_get_pi
c_func
(paren
id|hvcsd
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;HVCS: Failed to fetch partner&quot;
l_string|&quot; info for vty-server@%X on device probe.&bslash;n&quot;
comma
id|hvcsd-&gt;vdev-&gt;unit_address
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If a user app opens a tty that corresponds to this vty-server before&n;&t; * the hvcs_struct has been added to the devices list then the user app&n;&t; * will get -ENODEV.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hvcs_structs_lock
comma
id|structs_flags
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
(paren
id|hvcsd-&gt;next
)paren
comma
op_amp
id|hvcs_structs
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcs_structs_lock
comma
id|structs_flags
)paren
suffix:semicolon
id|hvcs_create_device_attrs
c_func
(paren
id|hvcsd
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;HVCS: Added vty-server@%X.&bslash;n&quot;
comma
id|dev-&gt;unit_address
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * DON&squot;T enable interrupts here because there is no user to receive the&n;&t; * data.&n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|hvcs_remove
r_static
r_int
id|__devexit
id|hvcs_remove
c_func
(paren
r_struct
id|vio_dev
op_star
id|dev
)paren
(brace
r_struct
id|hvcs_struct
op_star
id|hvcsd
op_assign
id|dev-&gt;dev.driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|kobject
op_star
id|kobjp
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hvcsd
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* By this time the vty-server won&squot;t be getting any more interrups */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|tty
op_assign
id|hvcsd-&gt;tty
suffix:semicolon
id|kobjp
op_assign
op_amp
id|hvcsd-&gt;kobj
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Let the last holder of this object cause it to be removed, which&n;&t; * would probably be tty_hangup below.&n;&t; */
id|kobject_put
(paren
id|kobjp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The hangup is a scheduled function which will auto chain call&n;&t; * hvcs_hangup.  The tty should always be valid at this time unless a&n;&t; * simultaneous tty close already cleaned up the hvcs_struct.&n;&t; */
r_if
c_cond
(paren
id|tty
)paren
id|tty_hangup
c_func
(paren
id|tty
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;HVCS: vty-server@%X removed from the&quot;
l_string|&quot; vio bus.&bslash;n&quot;
comma
id|dev-&gt;unit_address
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|hvcs_vio_driver
r_static
r_struct
id|vio_driver
id|hvcs_vio_driver
op_assign
(brace
dot
id|name
op_assign
id|hvcs_driver_name
comma
dot
id|id_table
op_assign
id|hvcs_driver_table
comma
dot
id|probe
op_assign
id|hvcs_probe
comma
dot
id|remove
op_assign
id|hvcs_remove
comma
)brace
suffix:semicolon
multiline_comment|/* Only called from hvcs_get_pi please */
DECL|function|hvcs_set_pi
r_static
r_void
id|hvcs_set_pi
c_func
(paren
r_struct
id|hvcs_partner_info
op_star
id|pi
comma
r_struct
id|hvcs_struct
op_star
id|hvcsd
)paren
(brace
r_int
id|clclength
suffix:semicolon
id|hvcsd-&gt;p_unit_address
op_assign
id|pi-&gt;unit_address
suffix:semicolon
id|hvcsd-&gt;p_partition_ID
op_assign
id|pi-&gt;partition_ID
suffix:semicolon
id|clclength
op_assign
id|strlen
c_func
(paren
op_amp
id|pi-&gt;location_code
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clclength
OG
id|CLC_LENGTH
op_minus
l_int|1
)paren
id|clclength
op_assign
id|CLC_LENGTH
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* copy the null-term char too */
id|strncpy
c_func
(paren
op_amp
id|hvcsd-&gt;p_location_code
(braket
l_int|0
)braket
comma
op_amp
id|pi-&gt;location_code
(braket
l_int|0
)braket
comma
id|clclength
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Traverse the list and add the partner info that is found to the hvcs_struct&n; * struct entry. NOTE: At this time I know that partner info will return a&n; * single entry but in the future there may be multiple partner info entries per&n; * vty-server and you&squot;ll want to zero out that list and reset it.  If for some&n; * reason you have an old version of this driver but there IS more than one&n; * partner info then hvcsd-&gt;p_* will hold the last partner info data from the&n; * firmware query.  A good way to update this code would be to replace the three&n; * partner info fields in hvcs_struct with a list of hvcs_partner_info&n; * instances.&n; *&n; * This function must be called with the hvcsd-&gt;lock held.&n; */
DECL|function|hvcs_get_pi
r_static
r_int
id|hvcs_get_pi
c_func
(paren
r_struct
id|hvcs_struct
op_star
id|hvcsd
)paren
(brace
multiline_comment|/* struct hvcs_partner_info *head_pi = NULL; */
r_struct
id|hvcs_partner_info
op_star
id|pi
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|unit_address
op_assign
id|hvcsd-&gt;vdev-&gt;unit_address
suffix:semicolon
r_struct
id|list_head
id|head
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hvcs_pi_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hvcs_pi_buff
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcs_pi_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|retval
op_assign
id|hvcs_get_partner_info
c_func
(paren
id|unit_address
comma
op_amp
id|head
comma
id|hvcs_pi_buff
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcs_pi_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;HVCS: Failed to fetch partner&quot;
l_string|&quot; info for vty-server@%x.&bslash;n&quot;
comma
id|unit_address
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* nixes the values if the partner vty went away */
id|hvcsd-&gt;p_unit_address
op_assign
l_int|0
suffix:semicolon
id|hvcsd-&gt;p_partition_ID
op_assign
l_int|0
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|pi
comma
op_amp
id|head
comma
id|node
)paren
id|hvcs_set_pi
c_func
(paren
id|pi
comma
id|hvcsd
)paren
suffix:semicolon
id|hvcs_free_partner_info
c_func
(paren
op_amp
id|head
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is executed by the driver &quot;rescan&quot; sysfs entry.  It shouldn&squot;t&n; * be executed elsewhere, in order to prevent deadlock issues.&n; */
DECL|function|hvcs_rescan_devices_list
r_static
r_int
id|hvcs_rescan_devices_list
c_func
(paren
r_void
)paren
(brace
r_struct
id|hvcs_struct
op_star
id|hvcsd
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|structs_flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hvcs_structs_lock
comma
id|structs_flags
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|hvcsd
comma
op_amp
id|hvcs_structs
comma
id|next
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|hvcs_get_pi
c_func
(paren
id|hvcsd
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcs_structs_lock
comma
id|structs_flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Farm this off into its own function because it could be more complex once&n; * multiple partners support is added. This function should be called with&n; * the hvcsd-&gt;lock held.&n; */
DECL|function|hvcs_has_pi
r_static
r_int
id|hvcs_has_pi
c_func
(paren
r_struct
id|hvcs_struct
op_star
id|hvcsd
)paren
(brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|hvcsd-&gt;p_unit_address
)paren
op_logical_or
(paren
op_logical_neg
id|hvcsd-&gt;p_partition_ID
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * NOTE: It is possible that the super admin removed a partner vty and then&n; * added a different vty as the new partner.&n; *&n; * This function must be called with the hvcsd-&gt;lock held.&n; */
DECL|function|hvcs_partner_connect
r_static
r_int
id|hvcs_partner_connect
c_func
(paren
r_struct
id|hvcs_struct
op_star
id|hvcsd
)paren
(brace
r_int
id|retval
suffix:semicolon
r_int
r_int
id|unit_address
op_assign
id|hvcsd-&gt;vdev-&gt;unit_address
suffix:semicolon
multiline_comment|/*&n;&t; * If there wasn&squot;t any pi when the device was added it doesn&squot;t meant&n;&t; * there isn&squot;t any now.  This driver isn&squot;t notified when a new partner&n;&t; * vty is added to a vty-server so we discover changes on our own.&n;&t; * Please see comments in hvcs_register_connection() for justification&n;&t; * of this bizarre code.&n;&t; */
id|retval
op_assign
id|hvcs_register_connection
c_func
(paren
id|unit_address
comma
id|hvcsd-&gt;p_partition_ID
comma
id|hvcsd-&gt;p_unit_address
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
(brace
id|hvcsd-&gt;connected
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|retval
op_ne
op_minus
id|EINVAL
)paren
r_return
id|retval
suffix:semicolon
multiline_comment|/*&n;&t; * As per the spec re-get the pi and try again if -EINVAL after the&n;&t; * first connection attempt.&n;&t; */
r_if
c_cond
(paren
id|hvcs_get_pi
c_func
(paren
id|hvcsd
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hvcs_has_pi
c_func
(paren
id|hvcsd
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|retval
op_assign
id|hvcs_register_connection
c_func
(paren
id|unit_address
comma
id|hvcsd-&gt;p_partition_ID
comma
id|hvcsd-&gt;p_unit_address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
op_minus
id|EINVAL
)paren
(brace
id|hvcsd-&gt;connected
op_assign
l_int|1
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * EBUSY is the most likely scenario though the vty could have been&n;&t; * removed or there really could be an hcall error due to the parameter&n;&t; * data but thanks to ambiguous firmware return codes we can&squot;t really&n;&t; * tell.&n;&t; */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;HVCS: vty-server or partner&quot;
l_string|&quot; vty is busy.  Try again later.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* This function must be called with the hvcsd-&gt;lock held */
DECL|function|hvcs_partner_free
r_static
r_void
id|hvcs_partner_free
c_func
(paren
r_struct
id|hvcs_struct
op_star
id|hvcsd
)paren
(brace
r_int
id|retval
suffix:semicolon
r_do
(brace
id|retval
op_assign
id|hvcs_free_connection
c_func
(paren
id|hvcsd-&gt;vdev-&gt;unit_address
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|retval
op_eq
op_minus
id|EBUSY
)paren
suffix:semicolon
id|hvcsd-&gt;connected
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This helper function must be called WITHOUT the hvcsd-&gt;lock held */
DECL|function|hvcs_enable_device
r_static
r_int
id|hvcs_enable_device
c_func
(paren
r_struct
id|hvcs_struct
op_star
id|hvcsd
comma
r_uint32
id|unit_address
comma
r_int
r_int
id|irq
comma
r_struct
id|vio_dev
op_star
id|vdev
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * It is possible that the vty-server was removed between the time that&n;&t; * the conn was registered and now.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|request_irq
c_func
(paren
id|irq
comma
op_amp
id|hvcs_handle_interrupt
comma
id|SA_INTERRUPT
comma
l_string|&quot;ibmhvcs&quot;
comma
id|hvcsd
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * It is possible the vty-server was removed after the irq was&n;&t;&t; * requested but before we have time to enable interrupts.&n;&t;&t; */
r_if
c_cond
(paren
id|vio_enable_interrupts
c_func
(paren
id|vdev
)paren
op_eq
id|H_Success
)paren
r_return
l_int|0
suffix:semicolon
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;HVCS: int enable failed for&quot;
l_string|&quot; vty-server@%X.&bslash;n&quot;
comma
id|unit_address
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|irq
comma
id|hvcsd
)paren
suffix:semicolon
)brace
)brace
r_else
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;HVCS: irq req failed for&quot;
l_string|&quot; vty-server@%X.&bslash;n&quot;
comma
id|unit_address
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|hvcs_partner_free
c_func
(paren
id|hvcsd
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n; * This always increments the kobject ref count if the call is successful.&n; * Please remember to dec when you are done with the instance.&n; *&n; * NOTICE: Do NOT hold either the hvcs_struct.lock or hvcs_structs_lock when&n; * calling this function or you will get deadlock.&n; */
DECL|function|hvcs_get_by_index
r_struct
id|hvcs_struct
op_star
id|hvcs_get_by_index
c_func
(paren
r_int
id|index
)paren
(brace
r_struct
id|hvcs_struct
op_star
id|hvcsd
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|list_head
op_star
id|element
suffix:semicolon
r_struct
id|list_head
op_star
id|safe_temp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|structs_flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hvcs_structs_lock
comma
id|structs_flags
)paren
suffix:semicolon
multiline_comment|/* We can immediately discard OOB requests */
r_if
c_cond
(paren
id|index
op_ge
l_int|0
op_logical_and
id|index
OL
id|HVCS_MAX_SERVER_ADAPTERS
)paren
(brace
id|list_for_each_safe
c_func
(paren
id|element
comma
id|safe_temp
comma
op_amp
id|hvcs_structs
)paren
(brace
id|hvcsd
op_assign
id|list_entry
c_func
(paren
id|element
comma
r_struct
id|hvcs_struct
comma
id|next
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hvcsd-&gt;index
op_eq
id|index
)paren
(brace
id|kobject_get
c_func
(paren
op_amp
id|hvcsd-&gt;kobj
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcs_structs_lock
comma
id|structs_flags
)paren
suffix:semicolon
r_return
id|hvcsd
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|hvcsd
op_assign
l_int|NULL
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcs_structs_lock
comma
id|structs_flags
)paren
suffix:semicolon
r_return
id|hvcsd
suffix:semicolon
)brace
multiline_comment|/*&n; * This is invoked via the tty_open interface when a user app connects to the&n; * /dev node.&n; */
DECL|function|hvcs_open
r_static
r_int
id|hvcs_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|hvcs_struct
op_star
id|hvcsd
op_assign
l_int|NULL
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|irq
suffix:semicolon
r_struct
id|vio_dev
op_star
id|vdev
suffix:semicolon
r_int
r_int
id|unit_address
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver_data
)paren
r_goto
id|fast_open
suffix:semicolon
multiline_comment|/*&n;&t; * Is there a vty-server that shares the same index?&n;&t; * This function increments the kobject index.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|hvcsd
op_assign
id|hvcs_get_by_index
c_func
(paren
id|tty-&gt;index
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;HVCS: open failed, no index.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hvcsd-&gt;connected
op_eq
l_int|0
)paren
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|hvcs_partner_connect
c_func
(paren
id|hvcsd
)paren
)paren
)paren
r_goto
id|error_release
suffix:semicolon
id|hvcsd-&gt;open_count
op_assign
l_int|1
suffix:semicolon
id|hvcsd-&gt;tty
op_assign
id|tty
suffix:semicolon
id|tty-&gt;driver_data
op_assign
id|hvcsd
suffix:semicolon
multiline_comment|/*&n;&t; * Set this driver to low latency so that we actually have a chance at&n;&t; * catching a throttled TTY after we flip_buffer_push.  Otherwise the&n;&t; * flush_to_async may not execute until after the kernel_thread has&n;&t; * yielded and resumed the next flip_buffer_push resulting in data&n;&t; * loss.&n;&t; */
id|tty-&gt;low_latency
op_assign
l_int|1
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|hvcsd-&gt;buffer
(braket
l_int|0
)braket
comma
l_int|0x3F
comma
id|HVCS_BUFF_LEN
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Save these in the spinlock for the enable operations that need them&n;&t; * outside of the spinlock.&n;&t; */
id|irq
op_assign
id|hvcsd-&gt;vdev-&gt;irq
suffix:semicolon
id|vdev
op_assign
id|hvcsd-&gt;vdev
suffix:semicolon
id|unit_address
op_assign
id|hvcsd-&gt;vdev-&gt;unit_address
suffix:semicolon
id|hvcsd-&gt;todo_mask
op_or_assign
id|HVCS_SCHED_READ
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This must be done outside of the spinlock because it requests irqs&n;&t; * and will grab the spinlcok and free the connection if it fails.&n;&t; */
r_if
c_cond
(paren
(paren
id|hvcs_enable_device
c_func
(paren
id|hvcsd
comma
id|unit_address
comma
id|irq
comma
id|vdev
)paren
)paren
)paren
(brace
id|kobject_put
c_func
(paren
op_amp
id|hvcsd-&gt;kobj
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;HVCS: enable device failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_goto
id|open_success
suffix:semicolon
id|fast_open
suffix:colon
id|hvcsd
op_assign
id|tty-&gt;driver_data
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kobject_get
c_func
(paren
op_amp
id|hvcsd-&gt;kobj
)paren
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;HVCS: Kobject of open&quot;
l_string|&quot; hvcs doesn&squot;t exist.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* Is this the right return value? */
)brace
id|hvcsd-&gt;open_count
op_increment
suffix:semicolon
id|hvcsd-&gt;todo_mask
op_or_assign
id|HVCS_SCHED_READ
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|open_success
suffix:colon
id|hvcs_kick
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;HVCS: vty-server@%X opened.&bslash;n&quot;
comma
id|hvcsd-&gt;vdev-&gt;unit_address
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error_release
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|kobject_put
c_func
(paren
op_amp
id|hvcsd-&gt;kobj
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;HVCS: HVCS partner connect failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|hvcs_close
r_static
r_void
id|hvcs_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|hvcs_struct
op_star
id|hvcsd
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|kobject
op_star
id|kobjp
suffix:semicolon
multiline_comment|/*&n;&t; * Is someone trying to close the file associated with this device after&n;&t; * we have hung up?  If so tty-&gt;driver_data wouldn&squot;t be valid.&n;&t; */
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * No driver_data means that this close was probably issued after a&n;&t; * failed hvcs_open by the tty layer&squot;s release_dev() api and we can just&n;&t; * exit cleanly.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;driver_data
)paren
r_return
suffix:semicolon
id|hvcsd
op_assign
id|tty-&gt;driver_data
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|hvcsd-&gt;open_count
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * This line is important because it tells hvcs_open that this&n;&t;&t; * device needs to be re-configured the next time hvcs_open is&n;&t;&t; * called.&n;&t;&t; */
id|hvcsd-&gt;tty-&gt;driver_data
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * NULL this early so that the kernel_thread doesn&squot;t try to&n;&t;&t; * execute any operations on the TTY even though it is obligated&n;&t;&t; * to deliver any pending I/O to the hypervisor.&n;&t;&t; */
id|hvcsd-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Block the close until all the buffered data has been&n;&t;&t; * delivered.&n;&t;&t; */
r_while
c_loop
(paren
id|hvcsd-&gt;chars_in_buffer
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Give the kernel thread the hvcs_struct so that it can&n;&t;&t;&t; * try to deliver the remaining data but block the close&n;&t;&t;&t; * operation by spinning in this function so that other&n;&t;&t;&t; * tty operations have to wait.&n;&t;&t;&t; */
id|yield
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|hvcs_final_close
c_func
(paren
id|hvcsd
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|hvcsd-&gt;open_count
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;HVCS: vty-server@%X open_count: %d&quot;
l_string|&quot; is missmanaged.&bslash;n&quot;
comma
id|hvcsd-&gt;vdev-&gt;unit_address
comma
id|hvcsd-&gt;open_count
)paren
suffix:semicolon
)brace
id|kobjp
op_assign
op_amp
id|hvcsd-&gt;kobj
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|kobject_put
c_func
(paren
id|kobjp
)paren
suffix:semicolon
)brace
DECL|function|hvcs_hangup
r_static
r_void
id|hvcs_hangup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|hvcs_struct
op_star
id|hvcsd
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|temp_open_count
suffix:semicolon
r_struct
id|kobject
op_star
id|kobjp
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Preserve this so that we know how many kobject refs to put */
id|temp_open_count
op_assign
id|hvcsd-&gt;open_count
suffix:semicolon
multiline_comment|/*&n;&t; * Don&squot;t kobject put inside the spinlock because the destruction&n;&t; * callback may use the spinlock and it may get called before the&n;&t; * spinlock has been released.  Get a pointer to the kobject and&n;&t; * kobject_put on that instead.&n;&t; */
id|kobjp
op_assign
op_amp
id|hvcsd-&gt;kobj
suffix:semicolon
multiline_comment|/* Calling this will drop any buffered data on the floor. */
id|hvcs_final_close
c_func
(paren
id|hvcsd
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We need to kobject_put() for every open_count we have since the&n;&t; * tty_hangup() function doesn&squot;t invoke a close per open connection on a&n;&t; * non-console device.&n;&t; */
r_while
c_loop
(paren
id|temp_open_count
)paren
(brace
op_decrement
id|temp_open_count
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The final put will trigger destruction of the hvcs_struct.&n;&t;&t; * NOTE:  If this hangup was signaled from user space then the&n;&t;&t; * final put will never happen.&n;&t;&t; */
id|kobject_put
c_func
(paren
id|kobjp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * NOTE: This is almost always from_user since user level apps interact with the&n; * /dev nodes. I&squot;m trusting that if hvcs_write gets called and interrupted by&n; * hvcs_remove (which removes the target device and executes tty_hangup()) that&n; * tty_hangup will allow hvcs_write time to complete execution before it&n; * terminates our device.&n; */
DECL|function|hvcs_write
r_static
r_int
id|hvcs_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|hvcs_struct
op_star
id|hvcsd
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|unit_address
suffix:semicolon
r_int
r_char
op_star
id|charbuf
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|total_sent
op_assign
l_int|0
suffix:semicolon
r_int
id|tosend
op_assign
l_int|0
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If they don&squot;t check the return code off of their open they may&n;&t; * attempt this even if there is no connected device.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|hvcsd
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* Reasonable size to prevent user level flooding */
r_if
c_cond
(paren
id|count
OG
id|HVCS_MAX_FROM_USER
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;HVCS write: count being truncated to&quot;
l_string|&quot; HVCS_MAX_FROM_USER.&bslash;n&quot;
)paren
suffix:semicolon
id|count
op_assign
id|HVCS_MAX_FROM_USER
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|from_user
)paren
id|charbuf
op_assign
(paren
r_int
r_char
op_star
)paren
id|buf
suffix:semicolon
r_else
(brace
id|charbuf
op_assign
id|kmalloc
c_func
(paren
id|count
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|charbuf
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;HVCS: write -ENOMEM.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|charbuf
comma
id|buf
comma
id|count
)paren
)paren
(brace
id|kfree
c_func
(paren
id|charbuf
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;HVCS: write -EFAULT.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Somehow an open succedded but the device was removed or the&n;&t; * connection terminated between the vty-server and partner vty during&n;&t; * the middle of a write operation?  This is a crummy place to do this&n;&t; * but we want to keep it all in the spinlock.&n;&t; */
r_if
c_cond
(paren
id|hvcsd-&gt;open_count
op_le
l_int|0
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|from_user
)paren
id|kfree
c_func
(paren
id|charbuf
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|unit_address
op_assign
id|hvcsd-&gt;vdev-&gt;unit_address
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
id|tosend
op_assign
id|min
c_func
(paren
id|count
comma
(paren
id|HVCS_BUFF_LEN
op_minus
id|hvcsd-&gt;chars_in_buffer
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * No more space, this probably means that the last call to&n;&t;&t; * hvcs_write() didn&squot;t succeed and the buffer was filled up.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|tosend
)paren
r_break
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|hvcsd-&gt;buffer
(braket
id|hvcsd-&gt;chars_in_buffer
)braket
comma
op_amp
id|charbuf
(braket
id|total_sent
)braket
comma
id|tosend
)paren
suffix:semicolon
id|hvcsd-&gt;chars_in_buffer
op_add_assign
id|tosend
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If this is true then we don&squot;t want to try writing to the&n;&t;&t; * hypervisor because that is the kernel_threads job now.  We&squot;ll&n;&t;&t; * just add to the buffer.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|hvcsd-&gt;todo_mask
op_amp
id|HVCS_TRY_WRITE
)paren
)paren
multiline_comment|/* won&squot;t send partial writes */
id|result
op_assign
id|hvc_put_chars
c_func
(paren
id|unit_address
comma
op_amp
id|hvcsd-&gt;buffer
(braket
l_int|0
)braket
comma
id|hvcsd-&gt;chars_in_buffer
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Since we know we have enough room in hvcsd-&gt;buffer for&n;&t;&t; * tosend we record that it was sent regardless of whether the&n;&t;&t; * hypervisor actually took it because we have it buffered.&n;&t;&t; */
id|total_sent
op_add_assign
id|tosend
suffix:semicolon
id|count
op_sub_assign
id|tosend
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
(brace
id|hvcsd-&gt;todo_mask
op_or_assign
id|HVCS_TRY_WRITE
suffix:semicolon
id|hvcs_kick
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|hvcsd-&gt;chars_in_buffer
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Test after the chars_in_buffer reset otherwise this could&n;&t;&t; * deadlock our writes if hvc_put_chars fails.&n;&t;&t; */
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_break
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|from_user
)paren
id|kfree
c_func
(paren
id|charbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_else
r_return
id|total_sent
suffix:semicolon
)brace
multiline_comment|/*&n; * This is really asking how much can we guarentee that we can send or that we&n; * absolutely WILL BUFFER if we can&squot;t send it.  This driver MUST honor the&n; * return value, hence the reason for hvcs_struct buffering.&n; */
DECL|function|hvcs_write_room
r_static
r_int
id|hvcs_write_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|hvcs_struct
op_star
id|hvcsd
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hvcsd
op_logical_or
id|hvcsd-&gt;open_count
op_le
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|retval
op_assign
id|HVCS_BUFF_LEN
op_minus
id|hvcsd-&gt;chars_in_buffer
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|hvcs_chars_in_buffer
r_static
r_int
id|hvcs_chars_in_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|hvcs_struct
op_star
id|hvcsd
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|retval
op_assign
id|hvcsd-&gt;chars_in_buffer
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|hvcs_ops
r_static
r_struct
id|tty_operations
id|hvcs_ops
op_assign
(brace
dot
id|open
op_assign
id|hvcs_open
comma
dot
id|close
op_assign
id|hvcs_close
comma
dot
id|hangup
op_assign
id|hvcs_hangup
comma
dot
id|write
op_assign
id|hvcs_write
comma
dot
id|write_room
op_assign
id|hvcs_write_room
comma
dot
id|chars_in_buffer
op_assign
id|hvcs_chars_in_buffer
comma
dot
id|unthrottle
op_assign
id|hvcs_unthrottle
comma
dot
id|throttle
op_assign
id|hvcs_throttle
comma
)brace
suffix:semicolon
DECL|function|hvcs_module_init
r_static
r_int
id|__init
id|hvcs_module_init
c_func
(paren
r_void
)paren
(brace
r_int
id|rc
suffix:semicolon
r_int
id|num_ttys_to_alloc
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Initializing %s&bslash;n&quot;
comma
id|hvcs_driver_string
)paren
suffix:semicolon
multiline_comment|/* Has the user specified an overload with an insmod param? */
r_if
c_cond
(paren
id|hvcs_parm_num_devs
op_le
l_int|0
op_logical_or
(paren
id|hvcs_parm_num_devs
OG
id|HVCS_MAX_SERVER_ADAPTERS
)paren
)paren
(brace
id|num_ttys_to_alloc
op_assign
id|HVCS_DEFAULT_SERVER_ADAPTERS
suffix:semicolon
)brace
r_else
id|num_ttys_to_alloc
op_assign
id|hvcs_parm_num_devs
suffix:semicolon
id|hvcs_tty_driver
op_assign
id|alloc_tty_driver
c_func
(paren
id|num_ttys_to_alloc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hvcs_tty_driver
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|hvcs_tty_driver-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
id|hvcs_tty_driver-&gt;driver_name
op_assign
id|hvcs_driver_name
suffix:semicolon
id|hvcs_tty_driver-&gt;name
op_assign
id|hvcs_device_node
suffix:semicolon
multiline_comment|/*&n;&t; * We&squot;ll let the system assign us a major number, indicated by leaving&n;&t; * it blank.&n;&t; */
id|hvcs_tty_driver-&gt;minor_start
op_assign
id|HVCS_MINOR_START
suffix:semicolon
id|hvcs_tty_driver-&gt;type
op_assign
id|TTY_DRIVER_TYPE_SYSTEM
suffix:semicolon
multiline_comment|/*&n;&t; * We role our own so that we DONT ECHO.  We can&squot;t echo because the&n;&t; * device we are connecting to already echoes by default and this would&n;&t; * throw us into a horrible recursive echo-echo-echo loop.&n;&t; */
id|hvcs_tty_driver-&gt;init_termios
op_assign
id|hvcs_tty_termios
suffix:semicolon
id|hvcs_tty_driver-&gt;flags
op_assign
id|TTY_DRIVER_REAL_RAW
suffix:semicolon
id|tty_set_operations
c_func
(paren
id|hvcs_tty_driver
comma
op_amp
id|hvcs_ops
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The following call will result in sysfs entries that denote the&n;&t; * dynamically assigned major and minor numbers for our devices.&n;&t; */
r_if
c_cond
(paren
id|tty_register_driver
c_func
(paren
id|hvcs_tty_driver
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;HVCS: registration &quot;
l_string|&quot; as a tty driver failed.&bslash;n&quot;
)paren
suffix:semicolon
id|put_tty_driver
c_func
(paren
id|hvcs_tty_driver
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
id|hvcs_structs_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|hvcs_pi_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|hvcs_pi_buff
op_assign
id|kmalloc
c_func
(paren
id|PAGE_SIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|hvcs_task
op_assign
id|kthread_run
c_func
(paren
id|khvcsd
comma
l_int|NULL
comma
l_string|&quot;khvcsd&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|hvcs_task
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;khvcsd creation failed.  Driver not loaded.&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|hvcs_pi_buff
)paren
suffix:semicolon
id|put_tty_driver
c_func
(paren
id|hvcs_tty_driver
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|rc
op_assign
id|vio_register_driver
c_func
(paren
op_amp
id|hvcs_vio_driver
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This needs to be done AFTER the vio_register_driver() call or else&n;&t; * the kobjects won&squot;t be initialized properly.&n;&t; */
id|hvcs_create_driver_attrs
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;HVCS: driver module inserted.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|hvcs_module_exit
r_static
r_void
id|__exit
id|hvcs_module_exit
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * This driver receives hvcs_remove callbacks for each device upon&n;&t; * module removal.&n;&t; */
multiline_comment|/*&n;&t; * This synchronous operation  will wake the khvcsd kthread if it is&n;&t; * asleep and will return when khvcsd has terminated.&n;&t; */
id|kthread_stop
c_func
(paren
id|hvcs_task
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hvcs_pi_lock
comma
id|flags
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|hvcs_pi_buff
)paren
suffix:semicolon
id|hvcs_pi_buff
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcs_pi_lock
comma
id|flags
)paren
suffix:semicolon
id|hvcs_remove_driver_attrs
c_func
(paren
)paren
suffix:semicolon
id|vio_unregister_driver
c_func
(paren
op_amp
id|hvcs_vio_driver
)paren
suffix:semicolon
id|tty_unregister_driver
c_func
(paren
id|hvcs_tty_driver
)paren
suffix:semicolon
id|put_tty_driver
c_func
(paren
id|hvcs_tty_driver
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;HVCS: driver module removed.&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|variable|hvcs_module_init
id|module_init
c_func
(paren
id|hvcs_module_init
)paren
suffix:semicolon
DECL|variable|hvcs_module_exit
id|module_exit
c_func
(paren
id|hvcs_module_exit
)paren
suffix:semicolon
DECL|function|from_vio_dev
r_static
r_inline
r_struct
id|hvcs_struct
op_star
id|from_vio_dev
c_func
(paren
r_struct
id|vio_dev
op_star
id|viod
)paren
(brace
r_return
id|viod-&gt;dev.driver_data
suffix:semicolon
)brace
multiline_comment|/* The sysfs interface for the driver and devices */
DECL|function|hvcs_partner_vtys_show
r_static
id|ssize_t
id|hvcs_partner_vtys_show
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|vio_dev
op_star
id|viod
op_assign
id|to_vio_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|hvcs_struct
op_star
id|hvcsd
op_assign
id|from_vio_dev
c_func
(paren
id|viod
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|retval
op_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%X&bslash;n&quot;
comma
id|hvcsd-&gt;p_unit_address
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_static
id|DEVICE_ATTR
c_func
(paren
id|partner_vtys
comma
id|S_IRUGO
comma
id|hvcs_partner_vtys_show
comma
l_int|NULL
)paren
suffix:semicolon
DECL|function|hvcs_partner_clcs_show
r_static
id|ssize_t
id|hvcs_partner_clcs_show
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|vio_dev
op_star
id|viod
op_assign
id|to_vio_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|hvcs_struct
op_star
id|hvcsd
op_assign
id|from_vio_dev
c_func
(paren
id|viod
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|retval
op_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%s&bslash;n&quot;
comma
op_amp
id|hvcsd-&gt;p_location_code
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_static
id|DEVICE_ATTR
c_func
(paren
id|partner_clcs
comma
id|S_IRUGO
comma
id|hvcs_partner_clcs_show
comma
l_int|NULL
)paren
suffix:semicolon
DECL|function|hvcs_current_vty_store
r_static
id|ssize_t
id|hvcs_current_vty_store
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
multiline_comment|/*&n;&t; * Don&squot;t need this feature at the present time because firmware doesn&squot;t&n;&t; * yet support multiple partners.&n;&t; */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;HVCS: Denied current_vty change: -EPERM.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
DECL|function|hvcs_current_vty_show
r_static
id|ssize_t
id|hvcs_current_vty_show
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|vio_dev
op_star
id|viod
op_assign
id|to_vio_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|hvcs_struct
op_star
id|hvcsd
op_assign
id|from_vio_dev
c_func
(paren
id|viod
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|retval
op_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%s&bslash;n&quot;
comma
op_amp
id|hvcsd-&gt;p_location_code
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_static
id|DEVICE_ATTR
c_func
(paren
id|current_vty
comma
id|S_IRUGO
op_or
id|S_IWUSR
comma
id|hvcs_current_vty_show
comma
id|hvcs_current_vty_store
)paren
suffix:semicolon
DECL|function|hvcs_vterm_state_store
r_static
id|ssize_t
id|hvcs_vterm_state_store
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|vio_dev
op_star
id|viod
op_assign
id|to_vio_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|hvcs_struct
op_star
id|hvcsd
op_assign
id|from_vio_dev
c_func
(paren
id|viod
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* writing a &squot;0&squot; to this sysfs entry will result in the disconnect. */
r_if
c_cond
(paren
id|simple_strtol
c_func
(paren
id|buf
comma
l_int|NULL
comma
l_int|0
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hvcsd-&gt;open_count
OG
l_int|0
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;HVCS: vterm state unchanged.  &quot;
l_string|&quot;The hvcs device node is still in use.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hvcsd-&gt;connected
op_eq
l_int|0
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;HVCS: vterm state unchanged. The&quot;
l_string|&quot; vty-server is not connected to a vty.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|hvcs_partner_free
c_func
(paren
id|hvcsd
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;HVCS: Closed vty-server@%X and&quot;
l_string|&quot; partner vty@%X:%d connection.&bslash;n&quot;
comma
id|hvcsd-&gt;vdev-&gt;unit_address
comma
id|hvcsd-&gt;p_unit_address
comma
(paren
r_int
r_int
)paren
id|hvcsd-&gt;p_partition_ID
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
DECL|function|hvcs_vterm_state_show
r_static
id|ssize_t
id|hvcs_vterm_state_show
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|vio_dev
op_star
id|viod
op_assign
id|to_vio_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|hvcs_struct
op_star
id|hvcsd
op_assign
id|from_vio_dev
c_func
(paren
id|viod
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|retval
op_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|hvcsd-&gt;connected
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|hvcsd-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_static
id|DEVICE_ATTR
c_func
(paren
id|vterm_state
comma
id|S_IRUGO
op_or
id|S_IWUSR
comma
id|hvcs_vterm_state_show
comma
id|hvcs_vterm_state_store
)paren
suffix:semicolon
DECL|variable|hvcs_attrs
r_static
r_struct
id|attribute
op_star
id|hvcs_attrs
(braket
)braket
op_assign
(brace
op_amp
id|dev_attr_partner_vtys.attr
comma
op_amp
id|dev_attr_partner_clcs.attr
comma
op_amp
id|dev_attr_current_vty.attr
comma
op_amp
id|dev_attr_vterm_state.attr
comma
l_int|NULL
comma
)brace
suffix:semicolon
DECL|variable|hvcs_attr_group
r_static
r_struct
id|attribute_group
id|hvcs_attr_group
op_assign
(brace
dot
id|attrs
op_assign
id|hvcs_attrs
comma
)brace
suffix:semicolon
DECL|function|hvcs_create_device_attrs
r_static
r_void
id|hvcs_create_device_attrs
c_func
(paren
r_struct
id|hvcs_struct
op_star
id|hvcsd
)paren
(brace
r_struct
id|vio_dev
op_star
id|vdev
op_assign
id|hvcsd-&gt;vdev
suffix:semicolon
id|sysfs_create_group
c_func
(paren
op_amp
id|vdev-&gt;dev.kobj
comma
op_amp
id|hvcs_attr_group
)paren
suffix:semicolon
)brace
DECL|function|hvcs_remove_device_attrs
r_static
r_void
id|hvcs_remove_device_attrs
c_func
(paren
r_struct
id|vio_dev
op_star
id|vdev
)paren
(brace
id|sysfs_remove_group
c_func
(paren
op_amp
id|vdev-&gt;dev.kobj
comma
op_amp
id|hvcs_attr_group
)paren
suffix:semicolon
)brace
DECL|function|hvcs_rescan_show
r_static
id|ssize_t
id|hvcs_rescan_show
c_func
(paren
r_struct
id|device_driver
op_star
id|ddp
comma
r_char
op_star
id|buf
)paren
(brace
multiline_comment|/* A 1 means it is updating, a 0 means it is done updating */
r_return
id|snprintf
c_func
(paren
id|buf
comma
id|PAGE_SIZE
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|hvcs_rescan_status
)paren
suffix:semicolon
)brace
DECL|function|hvcs_rescan_store
r_static
id|ssize_t
id|hvcs_rescan_store
c_func
(paren
r_struct
id|device_driver
op_star
id|ddp
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_if
c_cond
(paren
(paren
id|simple_strtol
c_func
(paren
id|buf
comma
l_int|NULL
comma
l_int|0
)paren
op_ne
l_int|1
)paren
op_logical_and
(paren
id|hvcs_rescan_status
op_ne
l_int|0
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|hvcs_rescan_status
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;HVCS: rescanning partner info for all&quot;
l_string|&quot; vty-servers.&bslash;n&quot;
)paren
suffix:semicolon
id|hvcs_rescan_devices_list
c_func
(paren
)paren
suffix:semicolon
id|hvcs_rescan_status
op_assign
l_int|0
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
r_static
id|DRIVER_ATTR
c_func
(paren
id|rescan
comma
id|S_IRUGO
op_or
id|S_IWUSR
comma
id|hvcs_rescan_show
comma
id|hvcs_rescan_store
)paren
suffix:semicolon
DECL|function|hvcs_create_driver_attrs
r_static
r_void
id|hvcs_create_driver_attrs
c_func
(paren
r_void
)paren
(brace
r_struct
id|device_driver
op_star
id|driverfs
op_assign
op_amp
(paren
id|hvcs_vio_driver.driver
)paren
suffix:semicolon
id|driver_create_file
c_func
(paren
id|driverfs
comma
op_amp
id|driver_attr_rescan
)paren
suffix:semicolon
)brace
DECL|function|hvcs_remove_driver_attrs
r_static
r_void
id|hvcs_remove_driver_attrs
c_func
(paren
r_void
)paren
(brace
r_struct
id|device_driver
op_star
id|driverfs
op_assign
op_amp
(paren
id|hvcs_vio_driver.driver
)paren
suffix:semicolon
id|driver_remove_file
c_func
(paren
id|driverfs
comma
op_amp
id|driver_attr_rescan
)paren
suffix:semicolon
)brace
eof
