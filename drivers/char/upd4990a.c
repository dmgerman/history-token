multiline_comment|/*&n; * NEC PC-9800 Real Time Clock interface for Linux&t;&n; *&n; * Copyright (C) 1997-2001  Linux/98 project,&n; *&t;&t;&t;    Kyoto University Microcomputer Club.&n; *&n; * Based on:&n; *&t;drivers/char/rtc.c by Paul Gortmaker&n; *&n; * Changes:&n; *  2001-02-09&t;Call check_region on rtc_init and do not request I/O 0033h.&n; *&t;&t;Call del_timer and release_region on rtc_exit. -- tak&n; *  2001-07-14&t;Rewrite &lt;linux/upd4990a.h&gt; and split to &lt;linux/upd4990a.h&gt;&n; *&t;&t;and &lt;asm-i386/upd4990a.h&gt;.&n; *&t;&t;Introduce a lot of spin_lock/unlock (&amp;rtc_lock).&n; */
DECL|macro|RTC98_VERSION
mdefine_line|#define RTC98_VERSION&t;&quot;1.2&quot;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/miscdevice.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/rtc.h&gt;
macro_line|#include &lt;linux/bcd.h&gt;
macro_line|#include &lt;linux/upd4990a.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
multiline_comment|/*&n; *&t;We sponge a minor off of the misc major. No need slurping&n; *&t;up another valuable major dev number for this. If you add&n; *&t;an ioctl, make sure you don&squot;t conflict with SPARC&squot;s RTC&n; *&t;ioctls.&n; */
DECL|variable|rtc_async_queue
r_static
r_struct
id|fasync_struct
op_star
id|rtc_async_queue
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|rtc_wait
)paren
suffix:semicolon
DECL|variable|rtc_uie_timer
r_static
r_struct
id|timer_list
id|rtc_uie_timer
suffix:semicolon
DECL|variable|old_refclk
r_static
id|u8
id|old_refclk
suffix:semicolon
r_static
r_int
id|rtc_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_int
id|rtc_read_proc
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Bits in rtc_status. (5 bits of room for future expansion)&n; */
DECL|macro|RTC_IS_OPEN
mdefine_line|#define RTC_IS_OPEN&t;&t;0x01&t;/* means /dev/rtc is in use&t;*/
DECL|macro|RTC_TIMER_ON
mdefine_line|#define RTC_TIMER_ON            0x02    /* not used */
DECL|macro|RTC_UIE_TIMER_ON
mdefine_line|#define RTC_UIE_TIMER_ON        0x04&t;/* UIE emulation timer is active */
multiline_comment|/*&n; * rtc_status is never changed by rtc_interrupt, and ioctl/open/close is&n; * protected by the big kernel lock. However, ioctl can still disable the timer&n; * in rtc_status and then with del_timer after the interrupt has read&n; * rtc_status but before mod_timer is called, which would then reenable the&n; * timer (but you would need to have an awful timing before you&squot;d trip on it)&n; */
DECL|variable|rtc_status
r_static
r_int
r_char
id|rtc_status
suffix:semicolon
multiline_comment|/* bitmapped status byte.&t;*/
DECL|variable|rtc_irq_data
r_static
r_int
r_int
id|rtc_irq_data
suffix:semicolon
multiline_comment|/* our output to the world&t;*/
DECL|variable|days_in_mo
r_static
r_const
r_int
r_char
id|days_in_mo
(braket
)braket
op_assign
(brace
l_int|31
comma
l_int|28
comma
l_int|31
comma
l_int|30
comma
l_int|31
comma
l_int|30
comma
l_int|31
comma
l_int|31
comma
l_int|30
comma
l_int|31
comma
l_int|30
comma
l_int|31
)brace
suffix:semicolon
r_extern
id|spinlock_t
id|rtc_lock
suffix:semicolon
multiline_comment|/* defined in arch/i386/kernel/time.c */
DECL|function|rtc_uie_intr
r_static
r_void
id|rtc_uie_intr
c_func
(paren
r_int
r_int
id|data
)paren
(brace
id|u8
id|refclk
comma
id|tmp
suffix:semicolon
multiline_comment|/* Kernel timer does del_timer internally before calling&n;&t;   each timer entry, so this is unnecessary.&n;&t;   del_timer(&amp;rtc_uie_timer);  */
id|spin_lock
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
multiline_comment|/* Detect rising edge of 1Hz reference clock.  */
id|refclk
op_assign
id|UPD4990A_READ_DATA
c_func
(paren
)paren
suffix:semicolon
id|tmp
op_assign
id|old_refclk
op_amp
id|refclk
suffix:semicolon
id|old_refclk
op_assign
op_complement
id|refclk
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tmp
op_amp
l_int|1
)paren
)paren
id|rtc_irq_data
op_add_assign
l_int|0x100
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tmp
op_amp
l_int|1
)paren
)paren
(brace
multiline_comment|/* Now do the rest of the actions */
id|wake_up_interruptible
c_func
(paren
op_amp
id|rtc_wait
)paren
suffix:semicolon
id|kill_fasync
c_func
(paren
op_amp
id|rtc_async_queue
comma
id|SIGIO
comma
id|POLL_IN
)paren
suffix:semicolon
)brace
id|rtc_uie_timer.expires
op_assign
id|jiffies
op_plus
l_int|1
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|rtc_uie_timer
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Now all the various file operations that we export.&n; */
DECL|function|rtc_read
r_static
id|ssize_t
id|rtc_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_int
r_int
id|data
suffix:semicolon
id|ssize_t
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
r_sizeof
(paren
r_int
r_int
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|rtc_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/* First make it right. Then make it fast. Putting this whole&n;&t;&t; * block within the parentheses of a while would be too&n;&t;&t; * confusing. And no, xchg() is not the answer. */
id|spin_lock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
id|data
op_assign
id|rtc_irq_data
suffix:semicolon
id|rtc_irq_data
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
op_ne
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|retval
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
id|retval
op_assign
id|put_user
c_func
(paren
id|data
comma
(paren
r_int
r_int
op_star
)paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|retval
op_assign
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|out
suffix:colon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|rtc_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|rtc_ioctl
r_static
r_int
id|rtc_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|rtc_time
id|wtime
suffix:semicolon
r_struct
id|upd4990a_raw_data
id|raw
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|RTC_UIE_OFF
suffix:colon
multiline_comment|/* Mask ints from RTC updates.&t;*/
id|spin_lock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtc_status
op_amp
id|RTC_UIE_TIMER_ON
)paren
(brace
id|rtc_status
op_and_assign
op_complement
id|RTC_UIE_TIMER_ON
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|rtc_uie_timer
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|RTC_UIE_ON
suffix:colon
multiline_comment|/* Allow ints for RTC updates.&t;*/
id|spin_lock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
id|rtc_irq_data
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|rtc_status
op_amp
id|RTC_UIE_TIMER_ON
)paren
)paren
(brace
id|rtc_status
op_or_assign
id|RTC_UIE_TIMER_ON
suffix:semicolon
id|rtc_uie_timer.expires
op_assign
id|jiffies
op_plus
l_int|1
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|rtc_uie_timer
)paren
suffix:semicolon
)brace
multiline_comment|/* Just in case... */
id|upd4990a_serial_command
c_func
(paren
id|UPD4990A_REGISTER_HOLD
)paren
suffix:semicolon
id|old_refclk
op_assign
op_complement
id|UPD4990A_READ_DATA
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|RTC_RD_TIME
suffix:colon
multiline_comment|/* Read the time/date from RTC&t;*/
id|spin_lock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
id|upd4990a_get_time
c_func
(paren
op_amp
id|raw
comma
l_int|0
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
id|wtime.tm_sec
op_assign
id|BCD2BIN
c_func
(paren
id|raw.sec
)paren
suffix:semicolon
id|wtime.tm_min
op_assign
id|BCD2BIN
c_func
(paren
id|raw.min
)paren
suffix:semicolon
id|wtime.tm_hour
op_assign
id|BCD2BIN
c_func
(paren
id|raw.hour
)paren
suffix:semicolon
id|wtime.tm_mday
op_assign
id|BCD2BIN
c_func
(paren
id|raw.mday
)paren
suffix:semicolon
id|wtime.tm_mon
op_assign
id|raw.mon
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* convert to 0-base */
id|wtime.tm_wday
op_assign
id|raw.wday
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Account for differences between how the RTC uses the values&n;&t;&t; * and how they are defined in a struct rtc_time;&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|wtime.tm_year
op_assign
id|BCD2BIN
c_func
(paren
id|raw.year
)paren
)paren
OL
l_int|95
)paren
id|wtime.tm_year
op_add_assign
l_int|100
suffix:semicolon
id|wtime.tm_isdst
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RTC_SET_TIME
suffix:colon
multiline_comment|/* Set the RTC */
(brace
r_int
id|leap_yr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_TIME
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|wtime
comma
(paren
r_struct
id|rtc_time
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|rtc_time
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* Valid year is 1995 - 2094, inclusive.  */
r_if
c_cond
(paren
id|wtime.tm_year
template_param
l_int|194
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|wtime.tm_mon
OG
l_int|11
op_logical_or
id|wtime.tm_mday
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* For acceptable year domain (1995 - 2094),&n;&t;&t;   this IS sufficient.  */
id|leap_yr
op_assign
op_logical_neg
(paren
id|wtime.tm_year
op_mod
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wtime.tm_mday
OG
(paren
id|days_in_mo
(braket
id|wtime.tm_mon
)braket
op_plus
(paren
id|wtime.tm_mon
op_eq
l_int|2
op_logical_and
id|leap_yr
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|wtime.tm_hour
op_ge
l_int|24
op_logical_or
id|wtime.tm_min
op_ge
l_int|60
op_logical_or
id|wtime.tm_sec
op_ge
l_int|60
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|wtime.tm_wday
OG
l_int|6
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|raw.sec
op_assign
id|BIN2BCD
c_func
(paren
id|wtime.tm_sec
)paren
suffix:semicolon
id|raw.min
op_assign
id|BIN2BCD
c_func
(paren
id|wtime.tm_min
)paren
suffix:semicolon
id|raw.hour
op_assign
id|BIN2BCD
c_func
(paren
id|wtime.tm_hour
)paren
suffix:semicolon
id|raw.mday
op_assign
id|BIN2BCD
c_func
(paren
id|wtime.tm_mday
)paren
suffix:semicolon
id|raw.mon
op_assign
id|wtime.tm_mon
op_plus
l_int|1
suffix:semicolon
id|raw.wday
op_assign
id|wtime.tm_wday
suffix:semicolon
id|raw.year
op_assign
id|BIN2BCD
c_func
(paren
id|wtime.tm_year
op_mod
l_int|100
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
id|upd4990a_set_time
c_func
(paren
op_amp
id|raw
comma
l_int|0
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|wtime
comma
r_sizeof
id|wtime
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;We enforce only one user at a time here with the open/close.&n; *&t;Also clear the previous interrupt data on an open, and clean&n; *&t;up things on a close.&n; */
DECL|function|rtc_open
r_static
r_int
id|rtc_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtc_status
op_amp
id|RTC_IS_OPEN
)paren
(brace
r_goto
id|out_busy
suffix:semicolon
)brace
id|rtc_status
op_or_assign
id|RTC_IS_OPEN
suffix:semicolon
id|rtc_irq_data
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_busy
suffix:colon
id|spin_unlock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
DECL|function|rtc_fasync
r_static
r_int
id|rtc_fasync
c_func
(paren
r_int
id|fd
comma
r_struct
id|file
op_star
id|filp
comma
r_int
id|on
)paren
(brace
r_return
id|fasync_helper
c_func
(paren
id|fd
comma
id|filp
comma
id|on
comma
op_amp
id|rtc_async_queue
)paren
suffix:semicolon
)brace
DECL|function|rtc_release
r_static
r_int
id|rtc_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|rtc_uie_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|FASYNC
)paren
id|rtc_fasync
c_func
(paren
op_minus
l_int|1
comma
id|file
comma
l_int|0
)paren
suffix:semicolon
id|rtc_irq_data
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* No need for locking -- nobody else can do anything until this rmw is&n;&t; * committed, and no timer is running. */
id|rtc_status
op_and_assign
op_complement
(paren
id|RTC_IS_OPEN
op_or
id|RTC_UIE_TIMER_ON
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|rtc_poll
r_static
r_int
r_int
id|rtc_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_int
r_int
id|l
suffix:semicolon
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|rtc_wait
comma
id|wait
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
id|l
op_assign
id|rtc_irq_data
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|l
op_ne
l_int|0
)paren
r_return
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;The various file operations we support.&n; */
DECL|variable|rtc_fops
r_static
r_struct
id|file_operations
id|rtc_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|read
op_assign
id|rtc_read
comma
dot
id|poll
op_assign
id|rtc_poll
comma
dot
id|ioctl
op_assign
id|rtc_ioctl
comma
dot
id|open
op_assign
id|rtc_open
comma
dot
id|release
op_assign
id|rtc_release
comma
dot
id|fasync
op_assign
id|rtc_fasync
comma
)brace
suffix:semicolon
DECL|variable|rtc_dev
r_static
r_struct
id|miscdevice
id|rtc_dev
op_assign
(brace
dot
id|minor
op_assign
id|RTC_MINOR
comma
dot
id|name
op_assign
l_string|&quot;rtc&quot;
comma
dot
id|fops
op_assign
op_amp
id|rtc_fops
comma
)brace
suffix:semicolon
DECL|function|rtc_init
r_static
r_int
id|__init
id|rtc_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|request_region
c_func
(paren
id|UPD4990A_IO
comma
l_int|1
comma
l_string|&quot;rtc&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;upd4990a: could not acquire I/O port %#x&bslash;n&quot;
comma
id|UPD4990A_IO
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
macro_line|#if 0
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;&bslash;xB6&bslash;xDA&bslash;xDD&bslash;xC0&bslash;xDE &bslash;xC4&bslash;xDE&bslash;xB9&bslash;xB2 Driver&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Calender Clock Driver */
macro_line|#else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Real Time Clock driver for NEC PC-9800 v&quot;
id|RTC98_VERSION
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|misc_register
c_func
(paren
op_amp
id|rtc_dev
)paren
suffix:semicolon
id|create_proc_read_entry
c_func
(paren
l_string|&quot;driver/rtc&quot;
comma
l_int|0
comma
l_int|NULL
comma
id|rtc_read_proc
comma
l_int|NULL
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|rtc_uie_timer
)paren
suffix:semicolon
id|rtc_uie_timer.function
op_assign
id|rtc_uie_intr
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|rtc_init
id|module_init
(paren
id|rtc_init
)paren
suffix:semicolon
DECL|function|rtc_exit
r_static
r_void
id|__exit
id|rtc_exit
c_func
(paren
r_void
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|rtc_uie_timer
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|UPD4990A_IO
comma
l_int|1
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
l_string|&quot;driver/rtc&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|misc_deregister
c_func
(paren
op_amp
id|rtc_dev
)paren
suffix:semicolon
)brace
DECL|variable|rtc_exit
id|module_exit
(paren
id|rtc_exit
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Info exported via &quot;/proc/driver/rtc&quot;.&n; */
DECL|function|rtc_get_status
r_static
r_inline
r_int
id|rtc_get_status
c_func
(paren
r_char
op_star
id|buf
)paren
(brace
r_char
op_star
id|p
suffix:semicolon
r_int
r_int
id|year
suffix:semicolon
r_struct
id|upd4990a_raw_data
id|data
suffix:semicolon
id|p
op_assign
id|buf
suffix:semicolon
id|upd4990a_get_time
c_func
(paren
op_amp
id|data
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * There is no way to tell if the luser has the RTC set for local&n;&t; * time or for Universal Standard Time (GMT). Probably local though.&n;&t; */
r_if
c_cond
(paren
(paren
id|year
op_assign
id|BCD2BIN
c_func
(paren
id|data.year
)paren
op_plus
l_int|1900
)paren
OL
l_int|1995
)paren
id|year
op_add_assign
l_int|100
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;rtc_time&bslash;t: %02d:%02d:%02d&bslash;n&quot;
l_string|&quot;rtc_date&bslash;t: %04d-%02d-%02d&bslash;n&quot;
comma
id|BCD2BIN
c_func
(paren
id|data.hour
)paren
comma
id|BCD2BIN
c_func
(paren
id|data.min
)paren
comma
id|BCD2BIN
c_func
(paren
id|data.sec
)paren
comma
id|year
comma
id|data.mon
comma
id|BCD2BIN
c_func
(paren
id|data.mday
)paren
)paren
suffix:semicolon
r_return
id|p
op_minus
id|buf
suffix:semicolon
)brace
DECL|function|rtc_read_proc
r_static
r_int
id|rtc_read_proc
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|len
op_assign
id|rtc_get_status
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
id|off
op_plus
id|count
)paren
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
op_star
id|start
op_assign
id|page
op_plus
id|off
suffix:semicolon
id|len
op_sub_assign
id|off
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|count
)paren
id|len
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
l_int|0
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
eof
