multiline_comment|/*&n; *  drivers/char/eventpoll.c ( Efficent event polling implementation )&n; *  Copyright (C) 2001,...,2002  Davide Libenzi&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  Davide Libenzi &lt;davidel@xmailserver.org&gt;&n; *&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/miscdevice.h&gt;
macro_line|#include &lt;linux/random.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/wrapper.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#include &lt;linux/fcblist.h&gt;
macro_line|#include &lt;linux/rwsem.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/mman.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;linux/eventpoll.h&gt;
DECL|macro|EVENTPOLLFS_MAGIC
mdefine_line|#define EVENTPOLLFS_MAGIC 0x03111965 /* My birthday should work for this :) */
DECL|macro|DEBUG_EPOLL
mdefine_line|#define DEBUG_EPOLL 0
macro_line|#if DEBUG_EPOLL &gt; 0
DECL|macro|DPRINTK
mdefine_line|#define DPRINTK(x) printk x
DECL|macro|DNPRINTK
mdefine_line|#define DNPRINTK(n, x) do { if ((n) &lt;= DEBUG_EPOLL) printk x; } while (0)
macro_line|#else /* #if DEBUG_EPOLL &gt; 0 */
DECL|macro|DPRINTK
mdefine_line|#define DPRINTK(x) (void) 0
DECL|macro|DNPRINTK
mdefine_line|#define DNPRINTK(n, x) (void) 0
macro_line|#endif /* #if DEBUG_EPOLL &gt; 0 */
DECL|macro|DEBUG_DPI
mdefine_line|#define DEBUG_DPI 0
macro_line|#if DEBUG_DPI != 0
DECL|macro|DPI_SLAB_DEBUG
mdefine_line|#define DPI_SLAB_DEBUG (SLAB_DEBUG_FREE | SLAB_RED_ZONE /* | SLAB_POISON */)
macro_line|#else /* #if DEBUG_DPI != 0 */
DECL|macro|DPI_SLAB_DEBUG
mdefine_line|#define DPI_SLAB_DEBUG 0
macro_line|#endif /* #if DEBUG_DPI != 0 */
DECL|macro|INITIAL_HASH_BITS
mdefine_line|#define INITIAL_HASH_BITS 7
DECL|macro|MAX_HASH_BITS
mdefine_line|#define MAX_HASH_BITS 18
DECL|macro|RESIZE_LENGTH
mdefine_line|#define RESIZE_LENGTH 2
DECL|macro|DPI_MEM_ALLOC
mdefine_line|#define DPI_MEM_ALLOC()&t;(struct epitem *) kmem_cache_alloc(dpi_cache, SLAB_KERNEL)
DECL|macro|DPI_MEM_FREE
mdefine_line|#define DPI_MEM_FREE(p) kmem_cache_free(dpi_cache, p)
DECL|macro|IS_FILE_EPOLL
mdefine_line|#define IS_FILE_EPOLL(f) ((f)-&gt;f_op == &amp;eventpoll_fops)
multiline_comment|/*&n; * Type used for versioning events snapshots inside the double buffer.&n; */
DECL|typedef|event_version_t
r_typedef
r_int
r_int
r_int
id|event_version_t
suffix:semicolon
multiline_comment|/*&n; * This structure is stored inside the &quot;private_data&quot; member of the file&n; * structure and rapresent the main data sructure for the eventpoll&n; * interface.&n; */
DECL|struct|eventpoll
r_struct
id|eventpoll
(brace
multiline_comment|/*&n;&t; * Protect the evenpoll interface from sys_epoll_ctl(2), ioctl(EP_POLL)&n;&t; * and -&gt;write() concurrency. It basically serialize the add/remove/edit&n;&t; * of items in the interest set.&n;&t; */
DECL|member|acsem
r_struct
id|rw_semaphore
id|acsem
suffix:semicolon
multiline_comment|/*&n;&t; * Protect the this structure access. When the &quot;acsem&quot; is acquired&n;&t; * togheter with this one, &quot;acsem&quot; should be acquired first. Or,&n;&t; * &quot;lock&quot; nests inside &quot;acsem&quot;.&n;&t; */
DECL|member|lock
id|rwlock_t
id|lock
suffix:semicolon
multiline_comment|/* Wait queue used by sys_epoll_wait() and ioctl(EP_POLL) */
DECL|member|wq
id|wait_queue_head_t
id|wq
suffix:semicolon
multiline_comment|/* Wait queue used by file-&gt;poll() */
DECL|member|poll_wait
id|wait_queue_head_t
id|poll_wait
suffix:semicolon
multiline_comment|/* This is the hash used to store the &quot;struct epitem&quot; elements */
DECL|member|hash
r_struct
id|list_head
op_star
id|hash
suffix:semicolon
DECL|member|hbits
r_int
r_int
id|hbits
suffix:semicolon
DECL|member|hmask
r_int
r_int
id|hmask
suffix:semicolon
DECL|member|hents
id|atomic_t
id|hents
suffix:semicolon
DECL|member|resize
id|atomic_t
id|resize
suffix:semicolon
multiline_comment|/* Number of pages currently allocated in each side of the double buffer */
DECL|member|numpages
r_int
id|numpages
suffix:semicolon
multiline_comment|/*&n;&t; * Current page set pointer, switched from &quot;pages0&quot; and &quot;pages1&quot; each time&n;&t; * ep_poll() returns events to the caller.&n;&t; */
DECL|member|pages
r_char
op_star
op_star
id|pages
suffix:semicolon
multiline_comment|/* Each one of these contains the pages allocated for each side of&n;&t; * the double buffer.&n;&t; */
DECL|member|pages0
r_char
op_star
id|pages0
(braket
id|MAX_EVENTPOLL_PAGES
)braket
suffix:semicolon
DECL|member|pages1
r_char
op_star
id|pages1
(braket
id|MAX_EVENTPOLL_PAGES
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Variable containing the vma base address where the double buffer&n;&t; * pages are mapped onto.&n;&t; */
DECL|member|vmabase
r_int
r_int
id|vmabase
suffix:semicolon
multiline_comment|/*&n;&t; * Certain functions cannot be called if the double buffer pages are&n;&t; * not allocated and if the memory mapping is not in place. This tells&n;&t; * us that everything is setup to fully use the interface.&n;&t; */
DECL|member|mmapped
id|atomic_t
id|mmapped
suffix:semicolon
multiline_comment|/* Number of events currently available inside the current snapshot */
DECL|member|eventcnt
r_int
id|eventcnt
suffix:semicolon
multiline_comment|/*&n;&t; * Variable storing the current &quot;version&quot; of the snapshot. It is used&n;&t; * to validate the validity of the current slot pointed by the &quot;index&quot;&n;&t; * member of a &quot;struct epitem&quot;.&n;&t; */
DECL|member|ver
id|event_version_t
id|ver
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Each file descriptor added to the eventpoll interface will&n; * have an entry of this type linked to the hash.&n; */
DECL|struct|epitem
r_struct
id|epitem
(brace
multiline_comment|/* List header used to link this structure to the eventpoll hash */
DECL|member|llink
r_struct
id|list_head
id|llink
suffix:semicolon
multiline_comment|/* The &quot;container&quot; of this item */
DECL|member|ep
r_struct
id|eventpoll
op_star
id|ep
suffix:semicolon
multiline_comment|/* The file this item refers to */
DECL|member|file
r_struct
id|file
op_star
id|file
suffix:semicolon
multiline_comment|/* The structure that describe the interested events and the source fd */
DECL|member|pfd
r_struct
id|pollfd
id|pfd
suffix:semicolon
multiline_comment|/*&n;&t; * The index inside the current double buffer that stores the active&n;&t; * event slot for this item ( file ).&n;&t; */
DECL|member|index
r_int
id|index
suffix:semicolon
multiline_comment|/*&n;&t; * The version that is used to validate if the current slot is still&n;&t; * valid or if it refers to an old snapshot. It is matches togheter&n;&t; * with the one inside the eventpoll structure.&n;&t; */
DECL|member|ver
id|event_version_t
id|ver
suffix:semicolon
)brace
suffix:semicolon
r_static
r_int
id|ep_getfd
c_func
(paren
r_int
op_star
id|efd
comma
r_struct
id|inode
op_star
op_star
id|einode
comma
r_struct
id|file
op_star
op_star
id|efile
)paren
suffix:semicolon
r_static
r_int
id|ep_alloc_pages
c_func
(paren
r_char
op_star
op_star
id|pages
comma
r_int
id|numpages
)paren
suffix:semicolon
r_static
r_int
id|ep_free_pages
c_func
(paren
r_char
op_star
op_star
id|pages
comma
r_int
id|numpages
)paren
suffix:semicolon
r_static
r_int
id|ep_init
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
)paren
suffix:semicolon
r_static
r_void
id|ep_free
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
)paren
suffix:semicolon
r_static
r_struct
id|epitem
op_star
id|ep_find_nl
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_int
id|fd
)paren
suffix:semicolon
r_static
r_struct
id|epitem
op_star
id|ep_find
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_int
id|fd
)paren
suffix:semicolon
r_static
r_int
id|ep_hashresize
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_int
r_int
op_star
id|kflags
)paren
suffix:semicolon
r_static
r_int
id|ep_insert
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|pollfd
op_star
id|pfd
)paren
suffix:semicolon
r_static
r_int
id|ep_remove
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|epitem
op_star
id|dpi
)paren
suffix:semicolon
r_static
r_void
id|notify_proc
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_void
op_star
id|data
comma
r_int
r_int
op_star
id|local
comma
r_int
op_star
id|event
)paren
suffix:semicolon
r_static
r_int
id|open_eventpoll
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
id|close_eventpoll
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
r_int
id|poll_eventpoll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
suffix:semicolon
r_static
r_int
id|write_eventpoll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
suffix:semicolon
r_static
r_int
id|ep_poll
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|evpoll
op_star
id|dvp
)paren
suffix:semicolon
r_static
r_int
id|ep_do_alloc_pages
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_int
id|numpages
)paren
suffix:semicolon
r_static
r_int
id|ioctl_eventpoll
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_void
id|eventpoll_mm_open
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
)paren
suffix:semicolon
r_static
r_void
id|eventpoll_mm_close
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
)paren
suffix:semicolon
r_static
r_int
id|mmap_eventpoll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
suffix:semicolon
r_static
r_int
id|eventpollfs_delete_dentry
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
suffix:semicolon
r_static
r_struct
id|inode
op_star
id|get_eventpoll_inode
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_struct
id|super_block
op_star
id|eventpollfs_get_sb
c_func
(paren
r_struct
id|file_system_type
op_star
id|fs_type
comma
r_int
id|flags
comma
r_char
op_star
id|dev_name
comma
r_void
op_star
id|data
)paren
suffix:semicolon
multiline_comment|/* Slab cache used to allocate &quot;struct epitem&quot; */
DECL|variable|dpi_cache
r_static
id|kmem_cache_t
op_star
id|dpi_cache
suffix:semicolon
multiline_comment|/* Virtual fs used to allocate inodes for eventpoll files */
DECL|variable|eventpoll_mnt
r_static
r_struct
id|vfsmount
op_star
id|eventpoll_mnt
suffix:semicolon
multiline_comment|/* File callbacks that implement the eventpoll file behaviour */
DECL|variable|eventpoll_fops
r_static
r_struct
id|file_operations
id|eventpoll_fops
op_assign
(brace
dot
id|write
op_assign
id|write_eventpoll
comma
dot
id|ioctl
op_assign
id|ioctl_eventpoll
comma
dot
id|mmap
op_assign
id|mmap_eventpoll
comma
dot
id|open
op_assign
id|open_eventpoll
comma
dot
id|release
op_assign
id|close_eventpoll
comma
dot
id|poll
op_assign
id|poll_eventpoll
)brace
suffix:semicolon
multiline_comment|/* Memory mapping callbacks for the eventpoll file */
DECL|variable|eventpoll_mmap_ops
r_static
r_struct
id|vm_operations_struct
id|eventpoll_mmap_ops
op_assign
(brace
dot
id|open
op_assign
id|eventpoll_mm_open
comma
dot
id|close
op_assign
id|eventpoll_mm_close
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * The &quot;struct miscdevice&quot; is used to register the eventpoll device&n; * to make it suitable to be openend from a /dev file.&n; */
DECL|variable|eventpoll_miscdev
r_static
r_struct
id|miscdevice
id|eventpoll_miscdev
op_assign
(brace
id|EVENTPOLL_MINOR
comma
l_string|&quot;eventpoll&quot;
comma
op_amp
id|eventpoll_fops
)brace
suffix:semicolon
multiline_comment|/*&n; * This is used to register the virtual file system from where&n; * eventpoll inodes are allocated.&n; */
DECL|variable|eventpoll_fs_type
r_static
r_struct
id|file_system_type
id|eventpoll_fs_type
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;eventpollfs&quot;
comma
dot
id|get_sb
op_assign
id|eventpollfs_get_sb
comma
dot
id|kill_sb
op_assign
id|kill_anon_super
comma
)brace
suffix:semicolon
multiline_comment|/* Very basic directory entry operations for the eventpoll virtual file system */
DECL|variable|eventpollfs_dentry_operations
r_static
r_struct
id|dentry_operations
id|eventpollfs_dentry_operations
op_assign
(brace
dot
id|d_delete
op_assign
id|eventpollfs_delete_dentry
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * It opens an eventpoll file descriptor by allocating space for &quot;maxfds&quot;&n; * file descriptors. It is the kernel part of the userspace epoll_create(2).&n; */
DECL|function|sys_epoll_create
id|asmlinkage
r_int
id|sys_epoll_create
c_func
(paren
r_int
id|maxfds
)paren
(brace
r_int
id|error
op_assign
op_minus
id|EINVAL
comma
id|fd
suffix:semicolon
r_int
r_int
id|addr
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|file
op_star
id|file
suffix:semicolon
r_struct
id|eventpoll
op_star
id|ep
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: sys_epoll_create(%d)&bslash;n&quot;
comma
id|current
comma
id|maxfds
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * It is not possible to store more than MAX_FDS_IN_EVENTPOLL file&n;&t; * descriptors inside the eventpoll interface.&n;&t; */
r_if
c_cond
(paren
id|maxfds
OG
id|MAX_FDS_IN_EVENTPOLL
)paren
r_goto
id|eexit_1
suffix:semicolon
multiline_comment|/*&n;&t; * Creates all the items needed to setup an eventpoll file. That is,&n;&t; * a file structure, and inode and a free file descriptor.&n;&t; */
id|error
op_assign
id|ep_getfd
c_func
(paren
op_amp
id|fd
comma
op_amp
id|inode
comma
op_amp
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|eexit_1
suffix:semicolon
multiline_comment|/*&n;&t; * Calls the code to initialize the eventpoll file. This code is&n;&t; * the same as the &quot;open&quot; file operation callback because inside&n;&t; * ep_getfd() we did what the kernel usually does before invoking&n;&t; * corresponding file &quot;open&quot; callback.&n;&t; */
id|error
op_assign
id|open_eventpoll
c_func
(paren
id|inode
comma
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|eexit_2
suffix:semicolon
multiline_comment|/* The &quot;private_data&quot; member is setup by open_eventpoll() */
id|ep
op_assign
id|file-&gt;private_data
suffix:semicolon
multiline_comment|/* Alloc pages for the event double buffer */
id|error
op_assign
id|ep_do_alloc_pages
c_func
(paren
id|ep
comma
id|EP_FDS_PAGES
c_func
(paren
id|maxfds
op_plus
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|eexit_2
suffix:semicolon
multiline_comment|/*&n;&t; * Create a user space mapping of the event double buffer to&n;&t; * avoid kernel to user space memory copy when returning events&n;&t; * to the caller.&n;&t; */
id|down_write
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
id|addr
op_assign
id|do_mmap_pgoff
c_func
(paren
id|file
comma
l_int|0
comma
id|EP_MAP_SIZE
c_func
(paren
id|maxfds
op_plus
l_int|1
)paren
comma
id|PROT_READ
comma
id|MAP_PRIVATE
comma
l_int|0
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
(paren
r_void
op_star
)paren
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
(paren
r_void
op_star
)paren
id|addr
)paren
)paren
r_goto
id|eexit_2
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: sys_epoll_create(%d) = %d&bslash;n&quot;
comma
id|current
comma
id|maxfds
comma
id|fd
)paren
)paren
suffix:semicolon
r_return
id|fd
suffix:semicolon
id|eexit_2
suffix:colon
id|sys_close
c_func
(paren
id|fd
)paren
suffix:semicolon
id|eexit_1
suffix:colon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: sys_epoll_create(%d) = %d&bslash;n&quot;
comma
id|current
comma
id|maxfds
comma
id|error
)paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * The following function implement the controller interface for the eventpoll&n; * file that enable the insertion/removal/change of file descriptors inside&n; * the interest set. It rapresents the kernel part of the user spcae epoll_ctl(2).&n; */
DECL|function|sys_epoll_ctl
id|asmlinkage
r_int
id|sys_epoll_ctl
c_func
(paren
r_int
id|epfd
comma
r_int
id|op
comma
r_int
id|fd
comma
r_int
r_int
id|events
)paren
(brace
r_int
id|error
op_assign
op_minus
id|EBADF
suffix:semicolon
r_struct
id|file
op_star
id|file
suffix:semicolon
r_struct
id|eventpoll
op_star
id|ep
suffix:semicolon
r_struct
id|epitem
op_star
id|dpi
suffix:semicolon
r_struct
id|pollfd
id|pfd
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %u)&bslash;n&quot;
comma
id|current
comma
id|epfd
comma
id|op
comma
id|fd
comma
id|events
)paren
)paren
suffix:semicolon
id|file
op_assign
id|fget
c_func
(paren
id|epfd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file
)paren
r_goto
id|eexit_1
suffix:semicolon
multiline_comment|/*&n;&t; * We have to check that the file structure underneath the file descriptor&n;&t; * the user passed to us _is_ an eventpoll file.&n;&t; */
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_FILE_EPOLL
c_func
(paren
id|file
)paren
)paren
r_goto
id|eexit_2
suffix:semicolon
multiline_comment|/*&n;&t; * At this point it is safe to assume that the &quot;private_data&quot; contains&n;&t; * our own data structure.&n;&t; */
id|ep
op_assign
id|file-&gt;private_data
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|ep-&gt;acsem
)paren
suffix:semicolon
id|pfd.fd
op_assign
id|fd
suffix:semicolon
id|pfd.events
op_assign
id|events
op_or
id|POLLERR
op_or
id|POLLHUP
suffix:semicolon
id|pfd.revents
op_assign
l_int|0
suffix:semicolon
id|dpi
op_assign
id|ep_find
c_func
(paren
id|ep
comma
id|fd
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|op
)paren
(brace
r_case
id|EP_CTL_ADD
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|dpi
)paren
id|error
op_assign
id|ep_insert
c_func
(paren
id|ep
comma
op_amp
id|pfd
)paren
suffix:semicolon
r_else
id|error
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EP_CTL_DEL
suffix:colon
r_if
c_cond
(paren
id|dpi
)paren
id|error
op_assign
id|ep_remove
c_func
(paren
id|ep
comma
id|dpi
)paren
suffix:semicolon
r_else
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EP_CTL_MOD
suffix:colon
r_if
c_cond
(paren
id|dpi
)paren
(brace
id|dpi-&gt;pfd.events
op_assign
id|events
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %u) = %d&bslash;n&quot;
comma
id|current
comma
id|epfd
comma
id|op
comma
id|fd
comma
id|events
comma
id|error
)paren
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|ep-&gt;acsem
)paren
suffix:semicolon
id|eexit_2
suffix:colon
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
id|eexit_1
suffix:colon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Implement the event wait interface for the eventpoll file. It is the kernel&n; * part of the user space epoll_wait(2).&n; */
DECL|function|sys_epoll_wait
id|asmlinkage
r_int
id|sys_epoll_wait
c_func
(paren
r_int
id|epfd
comma
r_struct
id|pollfd
r_const
op_star
op_star
id|events
comma
r_int
id|timeout
)paren
(brace
r_int
id|error
op_assign
op_minus
id|EBADF
suffix:semicolon
r_void
op_star
id|eaddr
suffix:semicolon
r_struct
id|file
op_star
id|file
suffix:semicolon
r_struct
id|eventpoll
op_star
id|ep
suffix:semicolon
r_struct
id|evpoll
id|dvp
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: sys_epoll_wait(%d, %p, %d)&bslash;n&quot;
comma
id|current
comma
id|epfd
comma
id|events
comma
id|timeout
)paren
)paren
suffix:semicolon
id|file
op_assign
id|fget
c_func
(paren
id|epfd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file
)paren
r_goto
id|eexit_1
suffix:semicolon
multiline_comment|/*&n;&t; * We have to check that the file structure underneath the file descriptor&n;&t; * the user passed to us _is_ an eventpoll file.&n;&t; */
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_FILE_EPOLL
c_func
(paren
id|file
)paren
)paren
r_goto
id|eexit_2
suffix:semicolon
multiline_comment|/*&n;&t; * At this point it is safe to assume that the &quot;private_data&quot; contains&n;&t; * our own data structure.&n;&t; */
id|ep
op_assign
id|file-&gt;private_data
suffix:semicolon
multiline_comment|/*&n;&t; * It is possible that the user created an eventpoll file by open()ing&n;&t; * the corresponding /dev/ file and he did not perform the correct&n;&t; * initialization required by the old /dev/epoll interface. This test&n;&t; * protect us from this scenario.&n;&t; */
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|ep-&gt;mmapped
)paren
)paren
r_goto
id|eexit_2
suffix:semicolon
id|dvp.ep_timeout
op_assign
id|timeout
suffix:semicolon
id|error
op_assign
id|ep_poll
c_func
(paren
id|ep
comma
op_amp
id|dvp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OG
l_int|0
)paren
(brace
id|eaddr
op_assign
(paren
r_void
op_star
)paren
(paren
id|ep-&gt;vmabase
op_plus
id|dvp.ep_resoff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|events
comma
op_amp
id|eaddr
comma
r_sizeof
(paren
r_struct
id|pollfd
op_star
)paren
)paren
)paren
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: sys_epoll_wait(%d, %p, %d) = %d&bslash;n&quot;
comma
id|current
comma
id|epfd
comma
id|events
comma
id|timeout
comma
id|error
)paren
)paren
suffix:semicolon
id|eexit_2
suffix:colon
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
id|eexit_1
suffix:colon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Creates the file descriptor to be used by the epoll interface.&n; */
DECL|function|ep_getfd
r_static
r_int
id|ep_getfd
c_func
(paren
r_int
op_star
id|efd
comma
r_struct
id|inode
op_star
op_star
id|einode
comma
r_struct
id|file
op_star
op_star
id|efile
)paren
(brace
r_struct
id|qstr
id|this
suffix:semicolon
r_char
id|name
(braket
l_int|32
)braket
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|file
op_star
id|file
suffix:semicolon
r_int
id|error
comma
id|fd
suffix:semicolon
multiline_comment|/* Get an ready to use file */
id|error
op_assign
op_minus
id|ENFILE
suffix:semicolon
id|file
op_assign
id|get_empty_filp
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file
)paren
r_goto
id|eexit_1
suffix:semicolon
multiline_comment|/* Allocates an inode from the eventpoll file system */
id|inode
op_assign
id|get_eventpoll_inode
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|inode
)paren
)paren
r_goto
id|eexit_2
suffix:semicolon
multiline_comment|/* Allocates a free descriptor to plug the file onto */
id|error
op_assign
id|get_unused_fd
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_goto
id|eexit_3
suffix:semicolon
id|fd
op_assign
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * Link the inode to a directory entry by creating a unique name&n;&t; * using the inode number.&n;&t; */
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;[%lu]&quot;
comma
id|inode-&gt;i_ino
)paren
suffix:semicolon
id|this.name
op_assign
id|name
suffix:semicolon
id|this.len
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
id|this.hash
op_assign
id|inode-&gt;i_ino
suffix:semicolon
id|dentry
op_assign
id|d_alloc
c_func
(paren
id|eventpoll_mnt-&gt;mnt_sb-&gt;s_root
comma
op_amp
id|this
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
r_goto
id|eexit_4
suffix:semicolon
id|dentry-&gt;d_op
op_assign
op_amp
id|eventpollfs_dentry_operations
suffix:semicolon
id|d_add
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
id|file-&gt;f_vfsmnt
op_assign
id|mntget
c_func
(paren
id|eventpoll_mnt
)paren
suffix:semicolon
id|file-&gt;f_dentry
op_assign
id|dget
c_func
(paren
id|dentry
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the file as read/write because it could be used&n;&t; * with write() to add/remove/change interest sets.&n;&t; */
id|file-&gt;f_pos
op_assign
l_int|0
suffix:semicolon
id|file-&gt;f_flags
op_assign
id|O_RDWR
suffix:semicolon
id|file-&gt;f_op
op_assign
op_amp
id|eventpoll_fops
suffix:semicolon
id|file-&gt;f_mode
op_assign
id|FMODE_READ
op_or
id|FMODE_WRITE
suffix:semicolon
id|file-&gt;f_version
op_assign
l_int|0
suffix:semicolon
id|file-&gt;private_data
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Install the new setup file into the allocated fd. */
id|fd_install
c_func
(paren
id|fd
comma
id|file
)paren
suffix:semicolon
op_star
id|efd
op_assign
id|fd
suffix:semicolon
op_star
id|einode
op_assign
id|inode
suffix:semicolon
op_star
id|efile
op_assign
id|file
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|eexit_4
suffix:colon
id|put_unused_fd
c_func
(paren
id|fd
)paren
suffix:semicolon
id|eexit_3
suffix:colon
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
id|eexit_2
suffix:colon
id|put_filp
c_func
(paren
id|file
)paren
suffix:semicolon
id|eexit_1
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|ep_alloc_pages
r_static
r_int
id|ep_alloc_pages
c_func
(paren
r_char
op_star
op_star
id|pages
comma
r_int
id|numpages
)paren
(brace
r_int
id|ii
suffix:semicolon
r_for
c_loop
(paren
id|ii
op_assign
l_int|0
suffix:semicolon
id|ii
OL
id|numpages
suffix:semicolon
id|ii
op_increment
)paren
(brace
id|pages
(braket
id|ii
)braket
op_assign
(paren
r_char
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_KERNEL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pages
(braket
id|ii
)braket
)paren
(brace
r_for
c_loop
(paren
op_decrement
id|ii
suffix:semicolon
id|ii
op_ge
l_int|0
suffix:semicolon
id|ii
op_decrement
)paren
(brace
id|ClearPageReserved
c_func
(paren
id|virt_to_page
c_func
(paren
id|pages
(braket
id|ii
)braket
)paren
)paren
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|pages
(braket
id|ii
)braket
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|SetPageReserved
c_func
(paren
id|virt_to_page
c_func
(paren
id|pages
(braket
id|ii
)braket
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ep_free_pages
r_static
r_int
id|ep_free_pages
c_func
(paren
r_char
op_star
op_star
id|pages
comma
r_int
id|numpages
)paren
(brace
r_int
id|ii
suffix:semicolon
r_for
c_loop
(paren
id|ii
op_assign
l_int|0
suffix:semicolon
id|ii
OL
id|numpages
suffix:semicolon
id|ii
op_increment
)paren
(brace
id|ClearPageReserved
c_func
(paren
id|virt_to_page
c_func
(paren
id|pages
(braket
id|ii
)braket
)paren
)paren
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|pages
(braket
id|ii
)braket
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ep_init
r_static
r_int
id|ep_init
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
)paren
(brace
r_int
id|ii
comma
id|hentries
suffix:semicolon
id|init_rwsem
c_func
(paren
op_amp
id|ep-&gt;acsem
)paren
suffix:semicolon
id|rwlock_init
c_func
(paren
op_amp
id|ep-&gt;lock
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|ep-&gt;wq
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|ep-&gt;poll_wait
)paren
suffix:semicolon
id|ep-&gt;hbits
op_assign
id|INITIAL_HASH_BITS
suffix:semicolon
id|ep-&gt;hmask
op_assign
(paren
l_int|1
op_lshift
id|ep-&gt;hbits
)paren
op_minus
l_int|1
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|ep-&gt;hents
comma
l_int|0
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|ep-&gt;resize
comma
l_int|0
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|ep-&gt;mmapped
comma
l_int|0
)paren
suffix:semicolon
id|ep-&gt;numpages
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;vmabase
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;pages
op_assign
id|ep-&gt;pages0
suffix:semicolon
id|ep-&gt;eventcnt
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;ver
op_assign
l_int|1
suffix:semicolon
id|hentries
op_assign
id|ep-&gt;hmask
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ep-&gt;hash
op_assign
(paren
r_struct
id|list_head
op_star
)paren
id|vmalloc
c_func
(paren
id|hentries
op_star
r_sizeof
(paren
r_struct
id|list_head
)paren
)paren
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_for
c_loop
(paren
id|ii
op_assign
l_int|0
suffix:semicolon
id|ii
OL
id|hentries
suffix:semicolon
id|ii
op_increment
)paren
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ep-&gt;hash
(braket
id|ii
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ep_free
r_static
r_void
id|ep_free
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
)paren
(brace
r_int
id|ii
suffix:semicolon
r_struct
id|list_head
op_star
id|lsthead
suffix:semicolon
multiline_comment|/*&n;&t; * Walks through the whole hash by unregistering file callbacks and&n;&t; * freeing each &quot;struct epitem&quot;.&n;&t; */
r_for
c_loop
(paren
id|ii
op_assign
l_int|0
suffix:semicolon
id|ii
op_le
id|ep-&gt;hmask
suffix:semicolon
id|ii
op_increment
)paren
(brace
id|lsthead
op_assign
op_amp
id|ep-&gt;hash
(braket
id|ii
)braket
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|lsthead
)paren
)paren
(brace
r_struct
id|epitem
op_star
id|dpi
op_assign
id|list_entry
c_func
(paren
id|lsthead-&gt;next
comma
r_struct
id|epitem
comma
id|llink
)paren
suffix:semicolon
id|file_notify_delcb
c_func
(paren
id|dpi-&gt;file
comma
id|notify_proc
)paren
suffix:semicolon
id|list_del
c_func
(paren
id|lsthead-&gt;next
)paren
suffix:semicolon
id|DPI_MEM_FREE
c_func
(paren
id|dpi
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * At this point we can free the hash and the pages used for the event&n;&t; * double buffer. The ep_free() function is called from the &quot;close&quot;&n;&t; * file operations callback, and this garanties us that the pages are&n;&t; * already unmapped.&n;&t; */
id|vfree
c_func
(paren
id|ep-&gt;hash
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;numpages
OG
l_int|0
)paren
(brace
id|ep_free_pages
c_func
(paren
id|ep-&gt;pages0
comma
id|ep-&gt;numpages
)paren
suffix:semicolon
id|ep_free_pages
c_func
(paren
id|ep-&gt;pages1
comma
id|ep-&gt;numpages
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * No lock version of ep_find(), used when the code had to acquire the lock&n; * before calling the function.&n; */
DECL|function|ep_find_nl
r_static
r_struct
id|epitem
op_star
id|ep_find_nl
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_int
id|fd
)paren
(brace
r_struct
id|epitem
op_star
id|dpi
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|list_head
op_star
id|lsthead
comma
op_star
id|lnk
suffix:semicolon
id|lsthead
op_assign
op_amp
id|ep-&gt;hash
(braket
id|fd
op_amp
id|ep-&gt;hmask
)braket
suffix:semicolon
id|list_for_each
c_func
(paren
id|lnk
comma
id|lsthead
)paren
(brace
id|dpi
op_assign
id|list_entry
c_func
(paren
id|lnk
comma
r_struct
id|epitem
comma
id|llink
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dpi-&gt;pfd.fd
op_eq
id|fd
)paren
r_break
suffix:semicolon
id|dpi
op_assign
l_int|NULL
suffix:semicolon
)brace
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: ep_find(%d) -&gt; %p&bslash;n&quot;
comma
id|current
comma
id|fd
comma
id|dpi
)paren
)paren
suffix:semicolon
r_return
id|dpi
suffix:semicolon
)brace
DECL|function|ep_find
r_static
r_struct
id|epitem
op_star
id|ep_find
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_int
id|fd
)paren
(brace
r_struct
id|epitem
op_star
id|dpi
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|read_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|dpi
op_assign
id|ep_find_nl
c_func
(paren
id|ep
comma
id|fd
)paren
suffix:semicolon
id|read_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|dpi
suffix:semicolon
)brace
DECL|function|ep_hashresize
r_static
r_int
id|ep_hashresize
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_int
r_int
op_star
id|kflags
)paren
(brace
r_struct
id|list_head
op_star
id|hash
comma
op_star
id|oldhash
suffix:semicolon
r_int
r_int
id|hbits
op_assign
id|ep-&gt;hbits
op_plus
l_int|1
suffix:semicolon
r_int
r_int
id|hmask
op_assign
(paren
l_int|1
op_lshift
id|hbits
)paren
op_minus
l_int|1
suffix:semicolon
r_int
id|ii
comma
id|res
comma
id|hentries
op_assign
id|hmask
op_plus
l_int|1
suffix:semicolon
r_int
r_int
id|flags
op_assign
op_star
id|kflags
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: ep_hashresize(%p) bits=%u&bslash;n&quot;
comma
id|current
comma
id|ep
comma
id|hbits
)paren
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|res
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|hash
op_assign
(paren
r_struct
id|list_head
op_star
)paren
id|vmalloc
c_func
(paren
id|hentries
op_star
r_sizeof
(paren
r_struct
id|list_head
)paren
)paren
)paren
)paren
(brace
id|write_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_goto
id|eexit_1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|ii
op_assign
l_int|0
suffix:semicolon
id|ii
OL
id|hentries
suffix:semicolon
id|ii
op_increment
)paren
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|hash
(braket
id|ii
)braket
)paren
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|oldhash
op_assign
id|ep-&gt;hash
suffix:semicolon
r_for
c_loop
(paren
id|ii
op_assign
l_int|0
suffix:semicolon
id|ii
op_le
id|ep-&gt;hmask
suffix:semicolon
id|ii
op_increment
)paren
(brace
r_struct
id|list_head
op_star
id|oldhead
op_assign
op_amp
id|oldhash
(braket
id|ii
)braket
comma
op_star
id|lnk
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|oldhead
)paren
)paren
(brace
r_struct
id|epitem
op_star
id|dpi
op_assign
id|list_entry
c_func
(paren
id|lnk
op_assign
id|oldhead-&gt;next
comma
r_struct
id|epitem
comma
id|llink
)paren
suffix:semicolon
id|list_del
c_func
(paren
id|lnk
)paren
suffix:semicolon
id|list_add
c_func
(paren
id|lnk
comma
op_amp
id|hash
(braket
id|dpi-&gt;pfd.fd
op_amp
id|hmask
)braket
)paren
suffix:semicolon
)brace
)brace
id|ep-&gt;hash
op_assign
id|hash
suffix:semicolon
id|ep-&gt;hbits
op_assign
id|hbits
suffix:semicolon
id|ep-&gt;hmask
op_assign
id|hmask
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|oldhash
)paren
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
id|eexit_1
suffix:colon
op_star
id|kflags
op_assign
id|flags
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|ep-&gt;resize
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|function|ep_insert
r_static
r_int
id|ep_insert
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|pollfd
op_star
id|pfd
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|epitem
op_star
id|dpi
suffix:semicolon
r_struct
id|file
op_star
id|file
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|ep-&gt;hents
)paren
op_ge
(paren
id|ep-&gt;numpages
op_star
id|POLLFD_X_PAGE
)paren
)paren
r_return
op_minus
id|E2BIG
suffix:semicolon
id|file
op_assign
id|fget
c_func
(paren
id|pfd-&gt;fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file
)paren
r_return
op_minus
id|EBADF
suffix:semicolon
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dpi
op_assign
id|DPI_MEM_ALLOC
c_func
(paren
)paren
)paren
)paren
r_goto
id|eexit_1
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|dpi-&gt;llink
)paren
suffix:semicolon
id|dpi-&gt;ep
op_assign
id|ep
suffix:semicolon
id|dpi-&gt;file
op_assign
id|file
suffix:semicolon
id|dpi-&gt;pfd
op_assign
op_star
id|pfd
suffix:semicolon
id|dpi-&gt;index
op_assign
op_minus
l_int|1
suffix:semicolon
id|dpi-&gt;ver
op_assign
id|ep-&gt;ver
op_minus
l_int|1
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|dpi-&gt;llink
comma
op_amp
id|ep-&gt;hash
(braket
id|pfd-&gt;fd
op_amp
id|ep-&gt;hmask
)braket
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|ep-&gt;hents
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|ep-&gt;resize
)paren
op_logical_and
(paren
id|atomic_read
c_func
(paren
op_amp
id|ep-&gt;hents
)paren
op_rshift
id|ep-&gt;hbits
)paren
OG
id|RESIZE_LENGTH
op_logical_and
id|ep-&gt;hbits
OL
id|MAX_HASH_BITS
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|ep-&gt;resize
)paren
suffix:semicolon
id|ep_hashresize
c_func
(paren
id|ep
comma
op_amp
id|flags
)paren
suffix:semicolon
)brace
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|file_notify_addcb
c_func
(paren
id|file
comma
id|notify_proc
comma
id|dpi
)paren
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: ep_insert(%p, %d)&bslash;n&quot;
comma
id|current
comma
id|ep
comma
id|pfd-&gt;fd
)paren
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|eexit_1
suffix:colon
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Removes a &quot;struct epitem&quot; from the eventpoll hash and deallocates&n; * all the associated resources.&n; */
DECL|function|ep_remove
r_static
r_int
id|ep_remove
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|epitem
op_star
id|dpi
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|pollfd
op_star
id|pfd
comma
op_star
id|lpfd
suffix:semicolon
r_struct
id|epitem
op_star
id|ldpi
suffix:semicolon
multiline_comment|/* First, removes the callback from the file callback list */
id|file_notify_delcb
c_func
(paren
id|dpi-&gt;file
comma
id|notify_proc
)paren
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|dpi-&gt;llink
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|ep-&gt;hents
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This is to remove stale events. We don&squot;t want that the removed file&n;&t; * has a pending event that might be associated with a file inserted&n;&t; * at a later time inside the eventpoll interface. this code checks&n;&t; * if the currently removed file has a valid pending event and, if it does,&n;&t; * manages things to remove it and decrement the currently available&n;&t; * event count.&n;&t; */
r_if
c_cond
(paren
id|dpi-&gt;index
op_ge
l_int|0
op_logical_and
id|dpi-&gt;ver
op_eq
id|ep-&gt;ver
op_logical_and
id|dpi-&gt;index
OL
id|ep-&gt;eventcnt
)paren
(brace
id|pfd
op_assign
(paren
r_struct
id|pollfd
op_star
)paren
(paren
id|ep-&gt;pages
(braket
id|EVENT_PAGE_INDEX
c_func
(paren
id|dpi-&gt;index
)paren
)braket
op_plus
id|EVENT_PAGE_OFFSET
c_func
(paren
id|dpi-&gt;index
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pfd-&gt;fd
op_eq
id|dpi-&gt;pfd.fd
op_logical_and
id|dpi-&gt;index
OL
op_decrement
id|ep-&gt;eventcnt
)paren
(brace
id|lpfd
op_assign
(paren
r_struct
id|pollfd
op_star
)paren
(paren
id|ep-&gt;pages
(braket
id|EVENT_PAGE_INDEX
c_func
(paren
id|ep-&gt;eventcnt
)paren
)braket
op_plus
id|EVENT_PAGE_OFFSET
c_func
(paren
id|ep-&gt;eventcnt
)paren
)paren
suffix:semicolon
op_star
id|pfd
op_assign
op_star
id|lpfd
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ldpi
op_assign
id|ep_find_nl
c_func
(paren
id|ep
comma
id|pfd-&gt;fd
)paren
)paren
)paren
id|ldpi-&gt;index
op_assign
id|dpi-&gt;index
suffix:semicolon
)brace
)brace
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: ep_remove(%p, %d)&bslash;n&quot;
comma
id|current
comma
id|ep
comma
id|dpi-&gt;pfd.fd
)paren
)paren
suffix:semicolon
multiline_comment|/* At this point it is safe to free the eventpoll item */
id|DPI_MEM_FREE
c_func
(paren
id|dpi
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the event notify callback that is called from fs/fcblist.c because&n; * of the registration ( file_notify_addcb() ) done in ep_insert().&n; */
DECL|function|notify_proc
r_static
r_void
id|notify_proc
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_void
op_star
id|data
comma
r_int
r_int
op_star
id|local
comma
r_int
op_star
id|event
)paren
(brace
r_struct
id|epitem
op_star
id|dpi
op_assign
id|data
suffix:semicolon
r_struct
id|eventpoll
op_star
id|ep
op_assign
id|dpi-&gt;ep
suffix:semicolon
r_struct
id|pollfd
op_star
id|pfd
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: notify(%p, %p, %ld, %ld) ep=%p&bslash;n&quot;
comma
id|current
comma
id|file
comma
id|data
comma
id|event
(braket
l_int|0
)braket
comma
id|event
(braket
l_int|1
)braket
comma
id|ep
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We don&squot;t need to disable IRQs here because the callback dispatch&n;&t; * routine inside fs/fcblist.c already call us with disabled IRQ.&n;&t; */
id|write_lock
c_func
(paren
op_amp
id|ep-&gt;lock
)paren
suffix:semicolon
multiline_comment|/* We&squot;re not expecting any of those events. Jump out soon ... */
r_if
c_cond
(paren
op_logical_neg
(paren
id|dpi-&gt;pfd.events
op_amp
id|event
(braket
l_int|1
)braket
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * This logic determins if an active even slot is available for the&n;&t; * currently signaled file, or if we have to make space for a new one&n;&t; * and increment the number of ready file descriptors ( ep-&gt;eventcnt ).&n;&t; */
r_if
c_cond
(paren
id|dpi-&gt;index
OL
l_int|0
op_logical_or
id|dpi-&gt;ver
op_ne
id|ep-&gt;ver
)paren
(brace
r_if
c_cond
(paren
id|ep-&gt;eventcnt
op_ge
(paren
id|ep-&gt;numpages
op_star
id|POLLFD_X_PAGE
)paren
)paren
r_goto
id|out
suffix:semicolon
id|dpi-&gt;index
op_assign
id|ep-&gt;eventcnt
op_increment
suffix:semicolon
id|dpi-&gt;ver
op_assign
id|ep-&gt;ver
suffix:semicolon
id|pfd
op_assign
(paren
r_struct
id|pollfd
op_star
)paren
(paren
id|ep-&gt;pages
(braket
id|EVENT_PAGE_INDEX
c_func
(paren
id|dpi-&gt;index
)paren
)braket
op_plus
id|EVENT_PAGE_OFFSET
c_func
(paren
id|dpi-&gt;index
)paren
)paren
suffix:semicolon
op_star
id|pfd
op_assign
id|dpi-&gt;pfd
suffix:semicolon
)brace
r_else
(brace
id|pfd
op_assign
(paren
r_struct
id|pollfd
op_star
)paren
(paren
id|ep-&gt;pages
(braket
id|EVENT_PAGE_INDEX
c_func
(paren
id|dpi-&gt;index
)paren
)braket
op_plus
id|EVENT_PAGE_OFFSET
c_func
(paren
id|dpi-&gt;index
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pfd-&gt;fd
op_ne
id|dpi-&gt;pfd.fd
)paren
(brace
r_if
c_cond
(paren
id|ep-&gt;eventcnt
op_ge
(paren
id|ep-&gt;numpages
op_star
id|POLLFD_X_PAGE
)paren
)paren
r_goto
id|out
suffix:semicolon
id|dpi-&gt;index
op_assign
id|ep-&gt;eventcnt
op_increment
suffix:semicolon
id|pfd
op_assign
(paren
r_struct
id|pollfd
op_star
)paren
(paren
id|ep-&gt;pages
(braket
id|EVENT_PAGE_INDEX
c_func
(paren
id|dpi-&gt;index
)paren
)braket
op_plus
id|EVENT_PAGE_OFFSET
c_func
(paren
id|dpi-&gt;index
)paren
)paren
suffix:semicolon
op_star
id|pfd
op_assign
id|dpi-&gt;pfd
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Merge event bits into the corresponding event slot inside the&n;&t; * double buffer.&n;&t; */
id|pfd-&gt;revents
op_or_assign
(paren
id|pfd-&gt;events
op_amp
id|event
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Wake up ( if active ) both the eventpoll wait list and the -&gt;poll()&n;&t; * wait list.&n;&t; */
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|ep-&gt;wq
)paren
)paren
id|wake_up
c_func
(paren
op_amp
id|ep-&gt;wq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|ep-&gt;poll_wait
)paren
)paren
id|wake_up
c_func
(paren
op_amp
id|ep-&gt;poll_wait
)paren
suffix:semicolon
id|out
suffix:colon
id|write_unlock
c_func
(paren
op_amp
id|ep-&gt;lock
)paren
suffix:semicolon
)brace
DECL|function|open_eventpoll
r_static
r_int
id|open_eventpoll
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|res
suffix:semicolon
r_struct
id|eventpoll
op_star
id|ep
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ep
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|eventpoll
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|ep
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|ep
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res
op_assign
id|ep_init
c_func
(paren
id|ep
)paren
)paren
)paren
(brace
id|kfree
c_func
(paren
id|ep
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
id|file-&gt;private_data
op_assign
id|ep
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: open() ep=%p&bslash;n&quot;
comma
id|current
comma
id|ep
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|close_eventpoll
r_static
r_int
id|close_eventpoll
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|eventpoll
op_star
id|ep
op_assign
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|ep
)paren
(brace
id|ep_free
c_func
(paren
id|ep
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ep
)paren
suffix:semicolon
)brace
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: close() ep=%p&bslash;n&quot;
comma
id|current
comma
id|ep
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|poll_eventpoll
r_static
r_int
r_int
id|poll_eventpoll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_struct
id|eventpoll
op_star
id|ep
op_assign
id|file-&gt;private_data
suffix:semicolon
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|ep-&gt;poll_wait
comma
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;eventcnt
)paren
r_return
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|write_eventpoll
r_static
r_int
id|write_eventpoll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_int
id|rcount
suffix:semicolon
r_struct
id|eventpoll
op_star
id|ep
op_assign
id|file-&gt;private_data
suffix:semicolon
r_struct
id|epitem
op_star
id|dpi
suffix:semicolon
r_struct
id|pollfd
id|pfd
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: write(%p, %d)&bslash;n&quot;
comma
id|current
comma
id|ep
comma
id|count
)paren
)paren
suffix:semicolon
multiline_comment|/* The size of the write must be a multiple of sizeof(struct pollfd) */
id|rcount
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|count
op_mod
r_sizeof
(paren
r_struct
id|pollfd
)paren
)paren
r_goto
id|eexit_1
suffix:semicolon
multiline_comment|/*&n;&t; * And we have also to verify that that area is correctly accessible&n;&t; * for the user.&n;&t; */
r_if
c_cond
(paren
(paren
id|rcount
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|buffer
comma
id|count
)paren
)paren
)paren
r_goto
id|eexit_1
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|ep-&gt;acsem
)paren
suffix:semicolon
id|rcount
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|__copy_from_user
c_func
(paren
op_amp
id|pfd
comma
id|buffer
comma
r_sizeof
(paren
id|pfd
)paren
)paren
)paren
(brace
id|rcount
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|eexit_2
suffix:semicolon
)brace
id|dpi
op_assign
id|ep_find
c_func
(paren
id|ep
comma
id|pfd.fd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pfd.fd
op_ge
id|current-&gt;files-&gt;max_fds
op_logical_or
op_logical_neg
id|current-&gt;files-&gt;fd
(braket
id|pfd.fd
)braket
)paren
id|pfd.events
op_assign
id|POLLREMOVE
suffix:semicolon
r_if
c_cond
(paren
id|pfd.events
op_amp
id|POLLREMOVE
)paren
(brace
r_if
c_cond
(paren
id|dpi
)paren
(brace
id|ep_remove
c_func
(paren
id|ep
comma
id|dpi
)paren
suffix:semicolon
id|rcount
op_add_assign
r_sizeof
(paren
id|pfd
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|dpi
)paren
(brace
id|dpi-&gt;pfd.events
op_assign
id|pfd.events
suffix:semicolon
id|rcount
op_add_assign
r_sizeof
(paren
id|pfd
)paren
suffix:semicolon
)brace
r_else
(brace
id|pfd.revents
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep_insert
c_func
(paren
id|ep
comma
op_amp
id|pfd
)paren
)paren
id|rcount
op_add_assign
r_sizeof
(paren
id|pfd
)paren
suffix:semicolon
)brace
id|buffer
op_add_assign
r_sizeof
(paren
id|pfd
)paren
suffix:semicolon
id|count
op_sub_assign
r_sizeof
(paren
id|pfd
)paren
suffix:semicolon
)brace
id|eexit_2
suffix:colon
id|up_write
c_func
(paren
op_amp
id|ep-&gt;acsem
)paren
suffix:semicolon
id|eexit_1
suffix:colon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: write(%p, %d) = %d&bslash;n&quot;
comma
id|current
comma
id|ep
comma
id|count
comma
id|rcount
)paren
)paren
suffix:semicolon
r_return
id|rcount
suffix:semicolon
)brace
DECL|function|ep_poll
r_static
r_int
id|ep_poll
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|evpoll
op_star
id|dvp
)paren
(brace
r_int
id|res
op_assign
l_int|0
suffix:semicolon
r_int
id|timeout
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|wait_queue_t
id|wait
suffix:semicolon
multiline_comment|/*&n;&t; * We don&squot;t want ep_poll() to be called if the correct sequence&n;&t; * of operations are performed to initialize it. This won&squot;t happen&n;&t; * for the system call interface but it could happen using the&n;&t; * old /dev/epoll interface, that is maintained for compatibility.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|ep-&gt;mmapped
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ep-&gt;eventcnt
)paren
(brace
multiline_comment|/*&n;&t;&t; * We don&squot;t have any available event to return to the caller.&n;&t;&t; * We need to sleep here, and we will be wake up by&n;&t;&t; * notify_proc() when events will become available.&n;&t;&t; */
id|init_waitqueue_entry
c_func
(paren
op_amp
id|wait
comma
id|current
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|ep-&gt;wq
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Calculate the timeout by checking for the &quot;infinite&quot; value ( -1 )&n;&t;&t; * and the overflow condition ( &gt; MAX_SCHEDULE_TIMEOUT / HZ ). The&n;&t;&t; * passed timeout is in milliseconds, that why (t * HZ) / 1000.&n;&t;&t; */
id|timeout
op_assign
id|dvp-&gt;ep_timeout
op_eq
op_minus
l_int|1
op_logical_or
id|dvp-&gt;ep_timeout
OG
id|MAX_SCHEDULE_TIMEOUT
op_div
id|HZ
ques
c_cond
id|MAX_SCHEDULE_TIMEOUT
suffix:colon
(paren
id|dvp-&gt;ep_timeout
op_star
id|HZ
)paren
op_div
l_int|1000
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We don&squot;t want to sleep if the notify_proc() sends us&n;&t;&t;&t; * a wakeup in between. That&squot;s why we set the task state&n;&t;&t;&t; * to TASK_INTERRUPTIBLE before doing the checks.&n;&t;&t;&t; */
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;eventcnt
op_logical_or
op_logical_neg
id|timeout
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|res
op_assign
op_minus
id|EINTR
suffix:semicolon
r_break
suffix:semicolon
)brace
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|timeout
op_assign
id|schedule_timeout
c_func
(paren
id|timeout
)paren
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|ep-&gt;wq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we&squot;ve been wake up because of events became available, we need to:&n;&t; *&n;&t; * 1) null the number of available ready file descriptors&n;&t; * 2) increment the version of the current ( next ) snapshot&n;&t; * 3) swap the double buffer to return the current one to the caller&n;&t; * 4) set the current ( for the user, previous for the interface ) offset&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|res
op_logical_and
id|ep-&gt;eventcnt
)paren
(brace
id|res
op_assign
id|ep-&gt;eventcnt
suffix:semicolon
id|ep-&gt;eventcnt
op_assign
l_int|0
suffix:semicolon
op_increment
id|ep-&gt;ver
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;pages
op_eq
id|ep-&gt;pages0
)paren
(brace
id|ep-&gt;pages
op_assign
id|ep-&gt;pages1
suffix:semicolon
id|dvp-&gt;ep_resoff
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ep-&gt;pages
op_assign
id|ep-&gt;pages0
suffix:semicolon
id|dvp-&gt;ep_resoff
op_assign
id|ep-&gt;numpages
op_star
id|PAGE_SIZE
suffix:semicolon
)brace
)brace
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|function|ep_do_alloc_pages
r_static
r_int
id|ep_do_alloc_pages
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_int
id|numpages
)paren
(brace
r_int
id|res
comma
id|pgalloc
comma
id|pgcpy
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_char
op_star
op_star
id|pages
comma
op_star
op_star
id|pages0
comma
op_star
op_star
id|pages1
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|ep-&gt;mmapped
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|numpages
OG
id|MAX_EVENTPOLL_PAGES
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|pgalloc
op_assign
id|numpages
op_minus
id|ep-&gt;numpages
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pages
op_assign
(paren
r_char
op_star
op_star
)paren
id|vmalloc
c_func
(paren
l_int|2
op_star
(paren
id|pgalloc
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_char
op_star
)paren
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|pages0
op_assign
op_amp
id|pages
(braket
l_int|0
)braket
suffix:semicolon
id|pages1
op_assign
op_amp
id|pages
(braket
id|pgalloc
op_plus
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res
op_assign
id|ep_alloc_pages
c_func
(paren
id|pages0
comma
id|pgalloc
)paren
)paren
)paren
r_goto
id|eexit_1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res
op_assign
id|ep_alloc_pages
c_func
(paren
id|pages1
comma
id|pgalloc
)paren
)paren
)paren
(brace
id|ep_free_pages
c_func
(paren
id|pages0
comma
id|pgalloc
)paren
suffix:semicolon
r_goto
id|eexit_1
suffix:semicolon
)brace
id|write_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|pgcpy
op_assign
(paren
id|ep-&gt;numpages
op_plus
id|pgalloc
)paren
OG
id|numpages
ques
c_cond
id|numpages
op_minus
id|ep-&gt;numpages
suffix:colon
id|pgalloc
suffix:semicolon
r_if
c_cond
(paren
id|pgcpy
OG
l_int|0
)paren
(brace
id|memcpy
c_func
(paren
op_amp
id|ep-&gt;pages0
(braket
id|ep-&gt;numpages
)braket
comma
id|pages0
comma
id|pgcpy
op_star
r_sizeof
(paren
r_char
op_star
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|ep-&gt;pages1
(braket
id|ep-&gt;numpages
)braket
comma
id|pages1
comma
id|pgcpy
op_star
r_sizeof
(paren
r_char
op_star
)paren
)paren
suffix:semicolon
id|ep-&gt;numpages
op_add_assign
id|pgcpy
suffix:semicolon
)brace
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pgcpy
OL
id|pgalloc
)paren
(brace
r_if
c_cond
(paren
id|pgcpy
OL
l_int|0
)paren
id|pgcpy
op_assign
l_int|0
suffix:semicolon
id|ep_free_pages
c_func
(paren
op_amp
id|pages0
(braket
id|pgcpy
)braket
comma
id|pgalloc
op_minus
id|pgcpy
)paren
suffix:semicolon
id|ep_free_pages
c_func
(paren
op_amp
id|pages1
(braket
id|pgcpy
)braket
comma
id|pgalloc
op_minus
id|pgcpy
)paren
suffix:semicolon
)brace
id|eexit_1
suffix:colon
id|vfree
c_func
(paren
id|pages
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|function|ioctl_eventpoll
r_static
r_int
id|ioctl_eventpoll
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|res
suffix:semicolon
r_struct
id|eventpoll
op_star
id|ep
op_assign
id|file-&gt;private_data
suffix:semicolon
r_struct
id|epitem
op_star
id|dpi
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|pollfd
id|pfd
suffix:semicolon
r_struct
id|evpoll
id|dvp
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|EP_ALLOC
suffix:colon
id|res
op_assign
id|ep_do_alloc_pages
c_func
(paren
id|ep
comma
id|EP_FDS_PAGES
c_func
(paren
id|arg
)paren
)paren
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: ioctl(%p, EP_ALLOC, %lu) == %d&bslash;n&quot;
comma
id|current
comma
id|ep
comma
id|arg
comma
id|res
)paren
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
r_case
id|EP_FREE
suffix:colon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|ep-&gt;mmapped
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|res
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;numpages
OG
l_int|0
)paren
(brace
id|ep_free_pages
c_func
(paren
id|ep-&gt;pages0
comma
id|ep-&gt;numpages
)paren
suffix:semicolon
id|ep_free_pages
c_func
(paren
id|ep-&gt;pages1
comma
id|ep-&gt;numpages
)paren
suffix:semicolon
id|ep-&gt;numpages
op_assign
l_int|0
suffix:semicolon
id|ep-&gt;pages
op_assign
id|ep-&gt;pages0
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
)brace
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: ioctl(%p, EP_FREE) == %d&bslash;n&quot;
comma
id|current
comma
id|ep
comma
id|res
)paren
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
r_case
id|EP_POLL
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|dvp
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|evpoll
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: ioctl(%p, EP_POLL, %d)&bslash;n&quot;
comma
id|current
comma
id|ep
comma
id|dvp.ep_timeout
)paren
)paren
suffix:semicolon
id|res
op_assign
id|ep_poll
c_func
(paren
id|ep
comma
op_amp
id|dvp
)paren
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: ioctl(%p, EP_POLL, %d) == %d&bslash;n&quot;
comma
id|current
comma
id|ep
comma
id|dvp.ep_timeout
comma
id|res
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
OG
l_int|0
op_logical_and
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|dvp
comma
r_sizeof
(paren
r_struct
id|evpoll
)paren
)paren
)paren
id|res
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_return
id|res
suffix:semicolon
r_case
id|EP_ISPOLLED
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|pfd
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|pollfd
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|read_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dpi
op_assign
id|ep_find_nl
c_func
(paren
id|ep
comma
id|pfd.fd
)paren
)paren
)paren
r_goto
id|is_not_polled
suffix:semicolon
id|pfd
op_assign
id|dpi-&gt;pfd
suffix:semicolon
id|res
op_assign
l_int|1
suffix:semicolon
id|is_not_polled
suffix:colon
id|read_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|pfd
comma
r_sizeof
(paren
r_struct
id|pollfd
)paren
)paren
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: ioctl(%p, EP_ISPOLLED, %d) == %d&bslash;n&quot;
comma
id|current
comma
id|ep
comma
id|pfd.fd
comma
id|res
)paren
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|eventpoll_mm_open
r_static
r_void
id|eventpoll_mm_open
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|file
op_star
id|file
op_assign
id|vma-&gt;vm_file
suffix:semicolon
r_struct
id|eventpoll
op_star
id|ep
op_assign
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|ep
)paren
id|atomic_inc
c_func
(paren
op_amp
id|ep-&gt;mmapped
)paren
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: mm_open(%p)&bslash;n&quot;
comma
id|current
comma
id|ep
)paren
)paren
suffix:semicolon
)brace
DECL|function|eventpoll_mm_close
r_static
r_void
id|eventpoll_mm_close
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|file
op_star
id|file
op_assign
id|vma-&gt;vm_file
suffix:semicolon
r_struct
id|eventpoll
op_star
id|ep
op_assign
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|ep
op_logical_and
id|atomic_dec_and_test
c_func
(paren
op_amp
id|ep-&gt;mmapped
)paren
)paren
id|ep-&gt;vmabase
op_assign
l_int|0
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: mm_close(%p)&bslash;n&quot;
comma
id|current
comma
id|ep
)paren
)paren
suffix:semicolon
)brace
DECL|function|mmap_eventpoll
r_static
r_int
id|mmap_eventpoll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
r_struct
id|eventpoll
op_star
id|ep
op_assign
id|file-&gt;private_data
suffix:semicolon
r_int
r_int
id|start
suffix:semicolon
r_int
id|ii
comma
id|res
comma
id|numpages
suffix:semicolon
r_int
id|mapsize
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: mmap(%p, %lx, %lx)&bslash;n&quot;
comma
id|current
comma
id|ep
comma
id|vma-&gt;vm_start
comma
id|vma-&gt;vm_pgoff
op_lshift
id|PAGE_SHIFT
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We need the eventpoll file to be RW but we don&squot;t want it to be&n;&t; * mapped RW. This test perform the test and reject RW mmaping.&n;&t; */
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_WRITE
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
(paren
id|vma-&gt;vm_pgoff
op_lshift
id|PAGE_SHIFT
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * We need to verify that the mapped area covers all the allocated&n;&t; * double buffer.&n;&t; */
id|mapsize
op_assign
id|PAGE_ALIGN
c_func
(paren
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
)paren
suffix:semicolon
id|numpages
op_assign
id|mapsize
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|res
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|numpages
op_ne
(paren
l_int|2
op_star
id|ep-&gt;numpages
)paren
)paren
r_goto
id|eexit_1
suffix:semicolon
multiline_comment|/*&n;&t; * Map the double buffer starting from &quot;vma-&gt;vm_start&quot; up to&n;&t; * &quot;vma-&gt;vm_start + ep-&gt;numpages * PAGE_SIZE&quot;.&n;&t; */
id|start
op_assign
id|vma-&gt;vm_start
suffix:semicolon
r_for
c_loop
(paren
id|ii
op_assign
l_int|0
suffix:semicolon
id|ii
OL
id|ep-&gt;numpages
suffix:semicolon
id|ii
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|res
op_assign
id|remap_page_range
c_func
(paren
id|vma
comma
id|start
comma
id|__pa
c_func
(paren
id|ep-&gt;pages0
(braket
id|ii
)braket
)paren
comma
id|PAGE_SIZE
comma
id|vma-&gt;vm_page_prot
)paren
)paren
)paren
r_goto
id|eexit_1
suffix:semicolon
id|start
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
r_for
c_loop
(paren
id|ii
op_assign
l_int|0
suffix:semicolon
id|ii
OL
id|ep-&gt;numpages
suffix:semicolon
id|ii
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|res
op_assign
id|remap_page_range
c_func
(paren
id|vma
comma
id|start
comma
id|__pa
c_func
(paren
id|ep-&gt;pages1
(braket
id|ii
)braket
)paren
comma
id|PAGE_SIZE
comma
id|vma-&gt;vm_page_prot
)paren
)paren
)paren
r_goto
id|eexit_1
suffix:semicolon
id|start
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
id|vma-&gt;vm_ops
op_assign
op_amp
id|eventpoll_mmap_ops
suffix:semicolon
multiline_comment|/* Saves the base mapping address for later use in sys_epoll_wait(2) */
id|ep-&gt;vmabase
op_assign
id|vma-&gt;vm_start
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, mapping has been done. We can open the door to functions that&n;&t; * requires the mapping to be in place.&n;&t; */
id|atomic_set
c_func
(paren
op_amp
id|ep-&gt;mmapped
comma
l_int|1
)paren
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
id|eexit_1
suffix:colon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: mmap(%p, %lx, %lx) == %d&bslash;n&quot;
comma
id|current
comma
id|ep
comma
id|vma-&gt;vm_start
comma
id|vma-&gt;vm_pgoff
op_lshift
id|PAGE_SHIFT
comma
id|res
)paren
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|function|eventpollfs_delete_dentry
r_static
r_int
id|eventpollfs_delete_dentry
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|get_eventpoll_inode
r_static
r_struct
id|inode
op_star
id|get_eventpoll_inode
c_func
(paren
r_void
)paren
(brace
r_int
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|new_inode
c_func
(paren
id|eventpoll_mnt-&gt;mnt_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_goto
id|eexit_1
suffix:semicolon
id|inode-&gt;i_fop
op_assign
op_amp
id|eventpoll_fops
suffix:semicolon
multiline_comment|/*&n;&t; * Mark the inode dirty from the very beginning,&n;&t; * that way it will never be moved to the dirty&n;&t; * list because &quot;mark_inode_dirty()&quot; will think&n;&t; * that it already _is_ on the dirty list.&n;&t; */
id|inode-&gt;i_state
op_assign
id|I_DIRTY
suffix:semicolon
id|inode-&gt;i_mode
op_assign
id|S_IRUSR
op_or
id|S_IWUSR
suffix:semicolon
id|inode-&gt;i_uid
op_assign
id|current-&gt;fsuid
suffix:semicolon
id|inode-&gt;i_gid
op_assign
id|current-&gt;fsgid
suffix:semicolon
id|inode-&gt;i_atime
op_assign
id|inode-&gt;i_mtime
op_assign
id|inode-&gt;i_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|inode-&gt;i_blksize
op_assign
id|PAGE_SIZE
suffix:semicolon
r_return
id|inode
suffix:semicolon
id|eexit_1
suffix:colon
r_return
id|ERR_PTR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
DECL|function|eventpollfs_get_sb
r_static
r_struct
id|super_block
op_star
id|eventpollfs_get_sb
c_func
(paren
r_struct
id|file_system_type
op_star
id|fs_type
comma
r_int
id|flags
comma
r_char
op_star
id|dev_name
comma
r_void
op_star
id|data
)paren
(brace
r_return
id|get_sb_pseudo
c_func
(paren
id|fs_type
comma
l_string|&quot;eventpoll:&quot;
comma
l_int|NULL
comma
id|EVENTPOLLFS_MAGIC
)paren
suffix:semicolon
)brace
DECL|function|eventpoll_init
r_static
r_int
id|__init
id|eventpoll_init
c_func
(paren
r_void
)paren
(brace
r_int
id|error
suffix:semicolon
multiline_comment|/* Allocates slab cache used to allocate &quot;struct epitem&quot; items */
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|dpi_cache
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;eventpoll&quot;
comma
r_sizeof
(paren
r_struct
id|epitem
)paren
comma
id|__alignof__
c_func
(paren
r_struct
id|epitem
)paren
comma
id|DPI_SLAB_DEBUG
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dpi_cache
)paren
r_goto
id|eexit_1
suffix:semicolon
multiline_comment|/*&n;&t; * Register the virtual file system that will be the source of inodes&n;&t; * for the eventpoll files&n;&t; */
id|error
op_assign
id|register_filesystem
c_func
(paren
op_amp
id|eventpoll_fs_type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|eexit_2
suffix:semicolon
multiline_comment|/* Mount the above commented virtual file system */
id|eventpoll_mnt
op_assign
id|kern_mount
c_func
(paren
op_amp
id|eventpoll_fs_type
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|eventpoll_mnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|eventpoll_mnt
)paren
)paren
r_goto
id|eexit_3
suffix:semicolon
multiline_comment|/*&n;&t; * This is to maintain compatibility with the old /dev/epoll interface.&n;&t; * We need to register a misc device so that the caller can open(2) it&n;&t; * through a file inside /dev.&n;&t; */
id|error
op_assign
id|misc_register
c_func
(paren
op_amp
id|eventpoll_miscdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|eexit_4
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: driver installed.&bslash;n&quot;
comma
id|current
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
id|eexit_4
suffix:colon
id|mntput
c_func
(paren
id|eventpoll_mnt
)paren
suffix:semicolon
id|eexit_3
suffix:colon
id|unregister_filesystem
c_func
(paren
op_amp
id|eventpoll_fs_type
)paren
suffix:semicolon
id|eexit_2
suffix:colon
id|kmem_cache_destroy
c_func
(paren
id|dpi_cache
)paren
suffix:semicolon
id|eexit_1
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|eventpoll_exit
r_static
r_void
id|__exit
id|eventpoll_exit
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Undo all operations done inside eventpoll_init() */
id|unregister_filesystem
c_func
(paren
op_amp
id|eventpoll_fs_type
)paren
suffix:semicolon
id|mntput
c_func
(paren
id|eventpoll_mnt
)paren
suffix:semicolon
id|misc_deregister
c_func
(paren
op_amp
id|eventpoll_miscdev
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|dpi_cache
)paren
suffix:semicolon
)brace
DECL|variable|eventpoll_init
id|module_init
c_func
(paren
id|eventpoll_init
)paren
suffix:semicolon
DECL|variable|eventpoll_exit
id|module_exit
c_func
(paren
id|eventpoll_exit
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
