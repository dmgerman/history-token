multiline_comment|/*&n; * ipmi_kcs_intf.c&n; *&n; * The interface to the IPMI driver for the KCS.&n; *&n; * Author: MontaVista Software, Inc.&n; *         Corey Minyard &lt;minyard@mvista.com&gt;&n; *         source@mvista.com&n; *&n; * Copyright 2002 MontaVista Software Inc.&n; *&n; *  This program is free software; you can redistribute it and/or modify it&n; *  under the terms of the GNU General Public License as published by the&n; *  Free Software Foundation; either version 2 of the License, or (at your&n; *  option) any later version.&n; *&n; *&n; *  THIS SOFTWARE IS PROVIDED ``AS IS&squot;&squot; AND ANY EXPRESS OR IMPLIED&n; *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&n; *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.&n; *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,&n; *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,&n; *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS&n; *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND&n; *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR&n; *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE&n; *  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n; *&n; *  You should have received a copy of the GNU General Public License along&n; *  with this program; if not, write to the Free Software Foundation, Inc.,&n; *  675 Mass Ave, Cambridge, MA 02139, USA.&n; */
multiline_comment|/*&n; * This file holds the &quot;policy&quot; for the interface to the KCS state&n; * machine.  It does the configuration, handles timers and interrupts,&n; * and drives the real KCS state machine.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#ifdef CONFIG_HIGH_RES_TIMERS
macro_line|#include &lt;linux/hrtime.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/rcupdate.h&gt;
macro_line|#include &lt;linux/ipmi_smi.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &quot;ipmi_kcs_sm.h&quot;
macro_line|#include &lt;linux/init.h&gt;
multiline_comment|/* Measure times between events in the driver. */
DECL|macro|DEBUG_TIMING
macro_line|#undef DEBUG_TIMING
multiline_comment|/* Timing parameters.  Call every 10 ms when not doing anything,&n;   otherwise call every KCS_SHORT_TIMEOUT_USEC microseconds. */
DECL|macro|KCS_TIMEOUT_TIME_USEC
mdefine_line|#define KCS_TIMEOUT_TIME_USEC&t;10000
DECL|macro|KCS_USEC_PER_JIFFY
mdefine_line|#define KCS_USEC_PER_JIFFY&t;(1000000/HZ)
DECL|macro|KCS_TIMEOUT_JIFFIES
mdefine_line|#define KCS_TIMEOUT_JIFFIES&t;(KCS_TIMEOUT_TIME_USEC/KCS_USEC_PER_JIFFY)
DECL|macro|KCS_SHORT_TIMEOUT_USEC
mdefine_line|#define KCS_SHORT_TIMEOUT_USEC  250 /* .25ms when the SM request a&n;                                       short timeout */
macro_line|#ifdef CONFIG_IPMI_KCS
multiline_comment|/* This forces a dependency to the config file for this option. */
macro_line|#endif
DECL|enum|kcs_intf_state
r_enum
id|kcs_intf_state
(brace
DECL|enumerator|KCS_NORMAL
id|KCS_NORMAL
comma
DECL|enumerator|KCS_GETTING_FLAGS
id|KCS_GETTING_FLAGS
comma
DECL|enumerator|KCS_GETTING_EVENTS
id|KCS_GETTING_EVENTS
comma
DECL|enumerator|KCS_CLEARING_FLAGS
id|KCS_CLEARING_FLAGS
comma
DECL|enumerator|KCS_CLEARING_FLAGS_THEN_SET_IRQ
id|KCS_CLEARING_FLAGS_THEN_SET_IRQ
comma
DECL|enumerator|KCS_GETTING_MESSAGES
id|KCS_GETTING_MESSAGES
comma
DECL|enumerator|KCS_ENABLE_INTERRUPTS1
id|KCS_ENABLE_INTERRUPTS1
comma
DECL|enumerator|KCS_ENABLE_INTERRUPTS2
id|KCS_ENABLE_INTERRUPTS2
multiline_comment|/* FIXME - add watchdog stuff. */
)brace
suffix:semicolon
DECL|struct|kcs_info
r_struct
id|kcs_info
(brace
DECL|member|intf
id|ipmi_smi_t
id|intf
suffix:semicolon
DECL|member|kcs_sm
r_struct
id|kcs_data
op_star
id|kcs_sm
suffix:semicolon
DECL|member|kcs_lock
id|spinlock_t
id|kcs_lock
suffix:semicolon
DECL|member|msg_lock
id|spinlock_t
id|msg_lock
suffix:semicolon
DECL|member|xmit_msgs
r_struct
id|list_head
id|xmit_msgs
suffix:semicolon
DECL|member|hp_xmit_msgs
r_struct
id|list_head
id|hp_xmit_msgs
suffix:semicolon
DECL|member|curr_msg
r_struct
id|ipmi_smi_msg
op_star
id|curr_msg
suffix:semicolon
DECL|member|kcs_state
r_enum
id|kcs_intf_state
id|kcs_state
suffix:semicolon
multiline_comment|/* Flags from the last GET_MSG_FLAGS command, used when an ATTN&n;&t;   is set to hold the flags until we are done handling everything&n;&t;   from the flags. */
DECL|macro|RECEIVE_MSG_AVAIL
mdefine_line|#define RECEIVE_MSG_AVAIL&t;0x01
DECL|macro|EVENT_MSG_BUFFER_FULL
mdefine_line|#define EVENT_MSG_BUFFER_FULL&t;0x02
DECL|macro|WDT_PRE_TIMEOUT_INT
mdefine_line|#define WDT_PRE_TIMEOUT_INT&t;0x08
DECL|member|msg_flags
r_int
r_char
id|msg_flags
suffix:semicolon
multiline_comment|/* If set to true, this will request events the next time the&n;&t;   state machine is idle. */
DECL|member|req_events
id|atomic_t
id|req_events
suffix:semicolon
multiline_comment|/* If true, run the state machine to completion on every send&n;&t;   call.  Generally used after a panic to make sure stuff goes&n;&t;   out. */
DECL|member|run_to_completion
r_int
id|run_to_completion
suffix:semicolon
multiline_comment|/* The I/O port of a KCS interface. */
DECL|member|port
r_int
id|port
suffix:semicolon
multiline_comment|/* zero if no irq; */
DECL|member|irq
r_int
id|irq
suffix:semicolon
multiline_comment|/* The physical and remapped memory addresses of a KCS interface. */
DECL|member|physaddr
r_int
r_int
id|physaddr
suffix:semicolon
DECL|member|addr
r_int
r_char
op_star
id|addr
suffix:semicolon
multiline_comment|/* The timer for this kcs. */
DECL|member|kcs_timer
r_struct
id|timer_list
id|kcs_timer
suffix:semicolon
multiline_comment|/* The time (in jiffies) the last timeout occurred at. */
DECL|member|last_timeout_jiffies
r_int
r_int
id|last_timeout_jiffies
suffix:semicolon
multiline_comment|/* Used to gracefully stop the timer without race conditions. */
DECL|member|stop_operation
r_volatile
r_int
id|stop_operation
suffix:semicolon
DECL|member|timer_stopped
r_volatile
r_int
id|timer_stopped
suffix:semicolon
multiline_comment|/* The driver will disable interrupts when it gets into a&n;&t;   situation where it cannot handle messages due to lack of&n;&t;   memory.  Once that situation clears up, it will re-enable&n;&t;   interrupts. */
DECL|member|interrupt_disabled
r_int
id|interrupt_disabled
suffix:semicolon
)brace
suffix:semicolon
r_static
r_void
id|kcs_restart_short_timer
c_func
(paren
r_struct
id|kcs_info
op_star
id|kcs_info
)paren
suffix:semicolon
DECL|function|deliver_recv_msg
r_static
r_void
id|deliver_recv_msg
c_func
(paren
r_struct
id|kcs_info
op_star
id|kcs_info
comma
r_struct
id|ipmi_smi_msg
op_star
id|msg
)paren
(brace
multiline_comment|/* Deliver the message to the upper layer with the lock&n;           released. */
id|spin_unlock
c_func
(paren
op_amp
(paren
id|kcs_info-&gt;kcs_lock
)paren
)paren
suffix:semicolon
id|ipmi_smi_msg_received
c_func
(paren
id|kcs_info-&gt;intf
comma
id|msg
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
(paren
id|kcs_info-&gt;kcs_lock
)paren
)paren
suffix:semicolon
)brace
DECL|function|return_hosed_msg
r_static
r_void
id|return_hosed_msg
c_func
(paren
r_struct
id|kcs_info
op_star
id|kcs_info
)paren
(brace
r_struct
id|ipmi_smi_msg
op_star
id|msg
op_assign
id|kcs_info-&gt;curr_msg
suffix:semicolon
multiline_comment|/* Make it a reponse */
id|msg-&gt;rsp
(braket
l_int|0
)braket
op_assign
id|msg-&gt;data
(braket
l_int|0
)braket
op_or
l_int|4
suffix:semicolon
id|msg-&gt;rsp
(braket
l_int|1
)braket
op_assign
id|msg-&gt;data
(braket
l_int|1
)braket
suffix:semicolon
id|msg-&gt;rsp
(braket
l_int|2
)braket
op_assign
l_int|0xFF
suffix:semicolon
multiline_comment|/* Unknown error. */
id|msg-&gt;rsp_size
op_assign
l_int|3
suffix:semicolon
id|kcs_info-&gt;curr_msg
op_assign
l_int|NULL
suffix:semicolon
id|deliver_recv_msg
c_func
(paren
id|kcs_info
comma
id|msg
)paren
suffix:semicolon
)brace
DECL|function|start_next_msg
r_static
r_enum
id|kcs_result
id|start_next_msg
c_func
(paren
r_struct
id|kcs_info
op_star
id|kcs_info
)paren
(brace
r_int
id|rv
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef DEBUG_TIMING
r_struct
id|timeval
id|t
suffix:semicolon
macro_line|#endif
multiline_comment|/* No need to save flags, we aleady have interrupts off and we&n;&t;   already hold the KCS lock. */
id|spin_lock
c_func
(paren
op_amp
(paren
id|kcs_info-&gt;msg_lock
)paren
)paren
suffix:semicolon
multiline_comment|/* Pick the high priority queue first. */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
(paren
id|kcs_info-&gt;hp_xmit_msgs
)paren
)paren
)paren
(brace
id|entry
op_assign
id|kcs_info-&gt;hp_xmit_msgs.next
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
(paren
id|kcs_info-&gt;xmit_msgs
)paren
)paren
)paren
(brace
id|entry
op_assign
id|kcs_info-&gt;xmit_msgs.next
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
(brace
id|kcs_info-&gt;curr_msg
op_assign
l_int|NULL
suffix:semicolon
id|rv
op_assign
id|KCS_SM_IDLE
suffix:semicolon
)brace
r_else
(brace
r_int
id|err
suffix:semicolon
id|list_del
c_func
(paren
id|entry
)paren
suffix:semicolon
id|kcs_info-&gt;curr_msg
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|ipmi_smi_msg
comma
id|link
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_TIMING
id|do_gettimeofday
c_func
(paren
op_amp
id|t
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;**Start2: %d.%9.9d&bslash;n&quot;
comma
id|t.tv_sec
comma
id|t.tv_usec
)paren
suffix:semicolon
macro_line|#endif
id|err
op_assign
id|start_kcs_transaction
c_func
(paren
id|kcs_info-&gt;kcs_sm
comma
id|kcs_info-&gt;curr_msg-&gt;data
comma
id|kcs_info-&gt;curr_msg-&gt;data_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|return_hosed_msg
c_func
(paren
id|kcs_info
)paren
suffix:semicolon
)brace
id|rv
op_assign
id|KCS_CALL_WITHOUT_DELAY
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
(paren
id|kcs_info-&gt;msg_lock
)paren
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
DECL|function|start_enable_irq
r_static
r_void
id|start_enable_irq
c_func
(paren
r_struct
id|kcs_info
op_star
id|kcs_info
)paren
(brace
r_int
r_char
id|msg
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* If we are enabling interrupts, we have to tell the&n;&t;   BMC to use them. */
id|msg
(braket
l_int|0
)braket
op_assign
(paren
id|IPMI_NETFN_APP_REQUEST
op_lshift
l_int|2
)paren
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|IPMI_GET_BMC_GLOBAL_ENABLES_CMD
suffix:semicolon
id|start_kcs_transaction
c_func
(paren
id|kcs_info-&gt;kcs_sm
comma
id|msg
comma
l_int|2
)paren
suffix:semicolon
id|kcs_info-&gt;kcs_state
op_assign
id|KCS_ENABLE_INTERRUPTS1
suffix:semicolon
)brace
DECL|function|start_clear_flags
r_static
r_void
id|start_clear_flags
c_func
(paren
r_struct
id|kcs_info
op_star
id|kcs_info
)paren
(brace
r_int
r_char
id|msg
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* Make sure the watchdog pre-timeout flag is not set at startup. */
id|msg
(braket
l_int|0
)braket
op_assign
(paren
id|IPMI_NETFN_APP_REQUEST
op_lshift
l_int|2
)paren
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|IPMI_CLEAR_MSG_FLAGS_CMD
suffix:semicolon
id|msg
(braket
l_int|2
)braket
op_assign
id|WDT_PRE_TIMEOUT_INT
suffix:semicolon
id|start_kcs_transaction
c_func
(paren
id|kcs_info-&gt;kcs_sm
comma
id|msg
comma
l_int|3
)paren
suffix:semicolon
id|kcs_info-&gt;kcs_state
op_assign
id|KCS_CLEARING_FLAGS
suffix:semicolon
)brace
multiline_comment|/* When we have a situtaion where we run out of memory and cannot&n;   allocate messages, we just leave them in the BMC and run the system&n;   polled until we can allocate some memory.  Once we have some&n;   memory, we will re-enable the interrupt. */
DECL|function|disable_kcs_irq
r_static
r_inline
r_void
id|disable_kcs_irq
c_func
(paren
r_struct
id|kcs_info
op_star
id|kcs_info
)paren
(brace
r_if
c_cond
(paren
(paren
id|kcs_info-&gt;irq
)paren
op_logical_and
(paren
op_logical_neg
id|kcs_info-&gt;interrupt_disabled
)paren
)paren
(brace
id|disable_irq_nosync
c_func
(paren
id|kcs_info-&gt;irq
)paren
suffix:semicolon
id|kcs_info-&gt;interrupt_disabled
op_assign
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|enable_kcs_irq
r_static
r_inline
r_void
id|enable_kcs_irq
c_func
(paren
r_struct
id|kcs_info
op_star
id|kcs_info
)paren
(brace
r_if
c_cond
(paren
(paren
id|kcs_info-&gt;irq
)paren
op_logical_and
(paren
id|kcs_info-&gt;interrupt_disabled
)paren
)paren
(brace
id|enable_irq
c_func
(paren
id|kcs_info-&gt;irq
)paren
suffix:semicolon
id|kcs_info-&gt;interrupt_disabled
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|handle_flags
r_static
r_void
id|handle_flags
c_func
(paren
r_struct
id|kcs_info
op_star
id|kcs_info
)paren
(brace
r_if
c_cond
(paren
id|kcs_info-&gt;msg_flags
op_amp
id|WDT_PRE_TIMEOUT_INT
)paren
(brace
multiline_comment|/* Watchdog pre-timeout */
id|start_clear_flags
c_func
(paren
id|kcs_info
)paren
suffix:semicolon
id|kcs_info-&gt;msg_flags
op_and_assign
op_complement
id|WDT_PRE_TIMEOUT_INT
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
(paren
id|kcs_info-&gt;kcs_lock
)paren
)paren
suffix:semicolon
id|ipmi_smi_watchdog_pretimeout
c_func
(paren
id|kcs_info-&gt;intf
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
(paren
id|kcs_info-&gt;kcs_lock
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|kcs_info-&gt;msg_flags
op_amp
id|RECEIVE_MSG_AVAIL
)paren
(brace
multiline_comment|/* Messages available. */
id|kcs_info-&gt;curr_msg
op_assign
id|ipmi_alloc_smi_msg
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kcs_info-&gt;curr_msg
)paren
(brace
id|disable_kcs_irq
c_func
(paren
id|kcs_info
)paren
suffix:semicolon
id|kcs_info-&gt;kcs_state
op_assign
id|KCS_NORMAL
suffix:semicolon
r_return
suffix:semicolon
)brace
id|enable_kcs_irq
c_func
(paren
id|kcs_info
)paren
suffix:semicolon
id|kcs_info-&gt;curr_msg-&gt;data
(braket
l_int|0
)braket
op_assign
(paren
id|IPMI_NETFN_APP_REQUEST
op_lshift
l_int|2
)paren
suffix:semicolon
id|kcs_info-&gt;curr_msg-&gt;data
(braket
l_int|1
)braket
op_assign
id|IPMI_GET_MSG_CMD
suffix:semicolon
id|kcs_info-&gt;curr_msg-&gt;data_size
op_assign
l_int|2
suffix:semicolon
id|start_kcs_transaction
c_func
(paren
id|kcs_info-&gt;kcs_sm
comma
id|kcs_info-&gt;curr_msg-&gt;data
comma
id|kcs_info-&gt;curr_msg-&gt;data_size
)paren
suffix:semicolon
id|kcs_info-&gt;kcs_state
op_assign
id|KCS_GETTING_MESSAGES
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|kcs_info-&gt;msg_flags
op_amp
id|EVENT_MSG_BUFFER_FULL
)paren
(brace
multiline_comment|/* Events available. */
id|kcs_info-&gt;curr_msg
op_assign
id|ipmi_alloc_smi_msg
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kcs_info-&gt;curr_msg
)paren
(brace
id|disable_kcs_irq
c_func
(paren
id|kcs_info
)paren
suffix:semicolon
id|kcs_info-&gt;kcs_state
op_assign
id|KCS_NORMAL
suffix:semicolon
r_return
suffix:semicolon
)brace
id|enable_kcs_irq
c_func
(paren
id|kcs_info
)paren
suffix:semicolon
id|kcs_info-&gt;curr_msg-&gt;data
(braket
l_int|0
)braket
op_assign
(paren
id|IPMI_NETFN_APP_REQUEST
op_lshift
l_int|2
)paren
suffix:semicolon
id|kcs_info-&gt;curr_msg-&gt;data
(braket
l_int|1
)braket
op_assign
id|IPMI_READ_EVENT_MSG_BUFFER_CMD
suffix:semicolon
id|kcs_info-&gt;curr_msg-&gt;data_size
op_assign
l_int|2
suffix:semicolon
id|start_kcs_transaction
c_func
(paren
id|kcs_info-&gt;kcs_sm
comma
id|kcs_info-&gt;curr_msg-&gt;data
comma
id|kcs_info-&gt;curr_msg-&gt;data_size
)paren
suffix:semicolon
id|kcs_info-&gt;kcs_state
op_assign
id|KCS_GETTING_EVENTS
suffix:semicolon
)brace
r_else
(brace
id|kcs_info-&gt;kcs_state
op_assign
id|KCS_NORMAL
suffix:semicolon
)brace
)brace
DECL|function|handle_transaction_done
r_static
r_void
id|handle_transaction_done
c_func
(paren
r_struct
id|kcs_info
op_star
id|kcs_info
)paren
(brace
r_struct
id|ipmi_smi_msg
op_star
id|msg
suffix:semicolon
macro_line|#ifdef DEBUG_TIMING
r_struct
id|timeval
id|t
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
id|t
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;**Done: %d.%9.9d&bslash;n&quot;
comma
id|t.tv_sec
comma
id|t.tv_usec
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|kcs_info-&gt;kcs_state
)paren
(brace
r_case
id|KCS_NORMAL
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|kcs_info-&gt;curr_msg
)paren
r_break
suffix:semicolon
id|kcs_info-&gt;curr_msg-&gt;rsp_size
op_assign
id|kcs_get_result
c_func
(paren
id|kcs_info-&gt;kcs_sm
comma
id|kcs_info-&gt;curr_msg-&gt;rsp
comma
id|IPMI_MAX_MSG_LENGTH
)paren
suffix:semicolon
multiline_comment|/* Do this here becase deliver_recv_msg() releases the&n;&t;&t;   lock, and a new message can be put in during the&n;&t;&t;   time the lock is released. */
id|msg
op_assign
id|kcs_info-&gt;curr_msg
suffix:semicolon
id|kcs_info-&gt;curr_msg
op_assign
l_int|NULL
suffix:semicolon
id|deliver_recv_msg
c_func
(paren
id|kcs_info
comma
id|msg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KCS_GETTING_FLAGS
suffix:colon
(brace
r_int
r_char
id|msg
(braket
l_int|4
)braket
suffix:semicolon
r_int
r_int
id|len
suffix:semicolon
multiline_comment|/* We got the flags from the KCS, now handle them. */
id|len
op_assign
id|kcs_get_result
c_func
(paren
id|kcs_info-&gt;kcs_sm
comma
id|msg
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg
(braket
l_int|2
)braket
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Error fetching flags, just give up for&n;&t;&t;&t;   now. */
id|kcs_info-&gt;kcs_state
op_assign
id|KCS_NORMAL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|len
OL
l_int|3
)paren
(brace
multiline_comment|/* Hmm, no flags.  That&squot;s technically illegal, but&n;&t;&t;&t;   don&squot;t use uninitialized data. */
id|kcs_info-&gt;kcs_state
op_assign
id|KCS_NORMAL
suffix:semicolon
)brace
r_else
(brace
id|kcs_info-&gt;msg_flags
op_assign
id|msg
(braket
l_int|3
)braket
suffix:semicolon
id|handle_flags
c_func
(paren
id|kcs_info
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_case
id|KCS_CLEARING_FLAGS
suffix:colon
r_case
id|KCS_CLEARING_FLAGS_THEN_SET_IRQ
suffix:colon
(brace
r_int
r_char
id|msg
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* We cleared the flags. */
id|kcs_get_result
c_func
(paren
id|kcs_info-&gt;kcs_sm
comma
id|msg
comma
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg
(braket
l_int|2
)braket
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Error clearing flags */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ipmi_kcs: Error clearing flags: %2.2x&bslash;n&quot;
comma
id|msg
(braket
l_int|2
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|kcs_info-&gt;kcs_state
op_eq
id|KCS_CLEARING_FLAGS_THEN_SET_IRQ
)paren
id|start_enable_irq
c_func
(paren
id|kcs_info
)paren
suffix:semicolon
r_else
id|kcs_info-&gt;kcs_state
op_assign
id|KCS_NORMAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|KCS_GETTING_EVENTS
suffix:colon
(brace
id|kcs_info-&gt;curr_msg-&gt;rsp_size
op_assign
id|kcs_get_result
c_func
(paren
id|kcs_info-&gt;kcs_sm
comma
id|kcs_info-&gt;curr_msg-&gt;rsp
comma
id|IPMI_MAX_MSG_LENGTH
)paren
suffix:semicolon
multiline_comment|/* Do this here becase deliver_recv_msg() releases the&n;&t;&t;   lock, and a new message can be put in during the&n;&t;&t;   time the lock is released. */
id|msg
op_assign
id|kcs_info-&gt;curr_msg
suffix:semicolon
id|kcs_info-&gt;curr_msg
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|msg-&gt;rsp
(braket
l_int|2
)braket
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Error getting event, probably done. */
id|msg
op_member_access_from_pointer
id|done
c_func
(paren
id|msg
)paren
suffix:semicolon
multiline_comment|/* Take off the event flag. */
id|kcs_info-&gt;msg_flags
op_and_assign
op_complement
id|EVENT_MSG_BUFFER_FULL
suffix:semicolon
)brace
r_else
(brace
id|deliver_recv_msg
c_func
(paren
id|kcs_info
comma
id|msg
)paren
suffix:semicolon
)brace
id|handle_flags
c_func
(paren
id|kcs_info
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|KCS_GETTING_MESSAGES
suffix:colon
(brace
id|kcs_info-&gt;curr_msg-&gt;rsp_size
op_assign
id|kcs_get_result
c_func
(paren
id|kcs_info-&gt;kcs_sm
comma
id|kcs_info-&gt;curr_msg-&gt;rsp
comma
id|IPMI_MAX_MSG_LENGTH
)paren
suffix:semicolon
multiline_comment|/* Do this here becase deliver_recv_msg() releases the&n;&t;&t;   lock, and a new message can be put in during the&n;&t;&t;   time the lock is released. */
id|msg
op_assign
id|kcs_info-&gt;curr_msg
suffix:semicolon
id|kcs_info-&gt;curr_msg
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|msg-&gt;rsp
(braket
l_int|2
)braket
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Error getting event, probably done. */
id|msg
op_member_access_from_pointer
id|done
c_func
(paren
id|msg
)paren
suffix:semicolon
multiline_comment|/* Take off the msg flag. */
id|kcs_info-&gt;msg_flags
op_and_assign
op_complement
id|RECEIVE_MSG_AVAIL
suffix:semicolon
)brace
r_else
(brace
id|deliver_recv_msg
c_func
(paren
id|kcs_info
comma
id|msg
)paren
suffix:semicolon
)brace
id|handle_flags
c_func
(paren
id|kcs_info
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|KCS_ENABLE_INTERRUPTS1
suffix:colon
(brace
r_int
r_char
id|msg
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* We got the flags from the KCS, now handle them. */
id|kcs_get_result
c_func
(paren
id|kcs_info-&gt;kcs_sm
comma
id|msg
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg
(braket
l_int|2
)braket
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ipmi_kcs: Could not enable interrupts&quot;
l_string|&quot;, failed get, using polled mode.&bslash;n&quot;
)paren
suffix:semicolon
id|kcs_info-&gt;kcs_state
op_assign
id|KCS_NORMAL
suffix:semicolon
)brace
r_else
(brace
id|msg
(braket
l_int|0
)braket
op_assign
(paren
id|IPMI_NETFN_APP_REQUEST
op_lshift
l_int|2
)paren
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|IPMI_SET_BMC_GLOBAL_ENABLES_CMD
suffix:semicolon
id|msg
(braket
l_int|2
)braket
op_assign
id|msg
(braket
l_int|3
)braket
op_or
l_int|1
suffix:semicolon
multiline_comment|/* enable msg queue int */
id|start_kcs_transaction
c_func
(paren
id|kcs_info-&gt;kcs_sm
comma
id|msg
comma
l_int|3
)paren
suffix:semicolon
id|kcs_info-&gt;kcs_state
op_assign
id|KCS_ENABLE_INTERRUPTS2
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_case
id|KCS_ENABLE_INTERRUPTS2
suffix:colon
(brace
r_int
r_char
id|msg
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* We got the flags from the KCS, now handle them. */
id|kcs_get_result
c_func
(paren
id|kcs_info-&gt;kcs_sm
comma
id|msg
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg
(braket
l_int|2
)braket
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ipmi_kcs: Could not enable interrupts&quot;
l_string|&quot;, failed set, using polled mode.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|kcs_info-&gt;kcs_state
op_assign
id|KCS_NORMAL
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Called on timeouts and events.  Timeouts should pass the elapsed&n;   time, interrupts should pass in zero. */
DECL|function|kcs_event_handler
r_static
r_enum
id|kcs_result
id|kcs_event_handler
c_func
(paren
r_struct
id|kcs_info
op_star
id|kcs_info
comma
r_int
id|time
)paren
(brace
r_enum
id|kcs_result
id|kcs_result
suffix:semicolon
id|restart
suffix:colon
multiline_comment|/* There used to be a loop here that waited a little while&n;&t;   (around 25us) before giving up.  That turned out to be&n;&t;   pointless, the minimum delays I was seeing were in the 300us&n;&t;   range, which is far too long to wait in an interrupt.  So&n;&t;   we just run until the state machine tells us something&n;&t;   happened or it needs a delay. */
id|kcs_result
op_assign
id|kcs_event
c_func
(paren
id|kcs_info-&gt;kcs_sm
comma
id|time
)paren
suffix:semicolon
id|time
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|kcs_result
op_eq
id|KCS_CALL_WITHOUT_DELAY
)paren
(brace
id|kcs_result
op_assign
id|kcs_event
c_func
(paren
id|kcs_info-&gt;kcs_sm
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|kcs_result
op_eq
id|KCS_TRANSACTION_COMPLETE
)paren
(brace
id|handle_transaction_done
c_func
(paren
id|kcs_info
)paren
suffix:semicolon
id|kcs_result
op_assign
id|kcs_event
c_func
(paren
id|kcs_info-&gt;kcs_sm
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|kcs_result
op_eq
id|KCS_SM_HOSED
)paren
(brace
r_if
c_cond
(paren
id|kcs_info-&gt;curr_msg
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* If we were handling a user message, format&n;                           a response to send to the upper layer to&n;                           tell it about the error. */
id|return_hosed_msg
c_func
(paren
id|kcs_info
)paren
suffix:semicolon
)brace
id|kcs_result
op_assign
id|kcs_event
c_func
(paren
id|kcs_info-&gt;kcs_sm
comma
l_int|0
)paren
suffix:semicolon
id|kcs_info-&gt;kcs_state
op_assign
id|KCS_NORMAL
suffix:semicolon
)brace
multiline_comment|/* We prefer handling attn over new messages. */
r_if
c_cond
(paren
id|kcs_result
op_eq
id|KCS_ATTN
)paren
(brace
r_int
r_char
id|msg
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* Got a attn, send down a get message flags to see&n;                   what&squot;s causing it.  It would be better to handle&n;                   this in the upper layer, but due to the way&n;                   interrupts work with the KCS, that&squot;s not really&n;                   possible. */
id|msg
(braket
l_int|0
)braket
op_assign
(paren
id|IPMI_NETFN_APP_REQUEST
op_lshift
l_int|2
)paren
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|IPMI_GET_MSG_FLAGS_CMD
suffix:semicolon
id|start_kcs_transaction
c_func
(paren
id|kcs_info-&gt;kcs_sm
comma
id|msg
comma
l_int|2
)paren
suffix:semicolon
id|kcs_info-&gt;kcs_state
op_assign
id|KCS_GETTING_FLAGS
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
multiline_comment|/* If we are currently idle, try to start the next message. */
r_if
c_cond
(paren
id|kcs_result
op_eq
id|KCS_SM_IDLE
)paren
(brace
id|kcs_result
op_assign
id|start_next_msg
c_func
(paren
id|kcs_info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kcs_result
op_ne
id|KCS_SM_IDLE
)paren
r_goto
id|restart
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|kcs_result
op_eq
id|KCS_SM_IDLE
)paren
op_logical_and
(paren
id|atomic_read
c_func
(paren
op_amp
id|kcs_info-&gt;req_events
)paren
)paren
)paren
(brace
multiline_comment|/* We are idle and the upper layer requested that I fetch&n;&t;&t;   events, so do so. */
r_int
r_char
id|msg
(braket
l_int|2
)braket
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|kcs_info-&gt;req_events
comma
l_int|0
)paren
suffix:semicolon
id|msg
(braket
l_int|0
)braket
op_assign
(paren
id|IPMI_NETFN_APP_REQUEST
op_lshift
l_int|2
)paren
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|IPMI_GET_MSG_FLAGS_CMD
suffix:semicolon
id|start_kcs_transaction
c_func
(paren
id|kcs_info-&gt;kcs_sm
comma
id|msg
comma
l_int|2
)paren
suffix:semicolon
id|kcs_info-&gt;kcs_state
op_assign
id|KCS_GETTING_FLAGS
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
r_return
id|kcs_result
suffix:semicolon
)brace
DECL|function|sender
r_static
r_void
id|sender
c_func
(paren
r_void
op_star
id|send_info
comma
r_struct
id|ipmi_smi_msg
op_star
id|msg
comma
r_int
id|priority
)paren
(brace
r_struct
id|kcs_info
op_star
id|kcs_info
op_assign
(paren
r_struct
id|kcs_info
op_star
)paren
id|send_info
suffix:semicolon
r_enum
id|kcs_result
id|result
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG_TIMING
r_struct
id|timeval
id|t
suffix:semicolon
macro_line|#endif
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|kcs_info-&gt;msg_lock
)paren
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_TIMING
id|do_gettimeofday
c_func
(paren
op_amp
id|t
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;**Enqueue: %d.%9.9d&bslash;n&quot;
comma
id|t.tv_sec
comma
id|t.tv_usec
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|kcs_info-&gt;run_to_completion
)paren
(brace
multiline_comment|/* If we are running to completion, then throw it in&n;&t;&t;   the list and run transactions until everything is&n;&t;&t;   clear.  Priority doesn&squot;t matter here. */
id|list_add_tail
c_func
(paren
op_amp
(paren
id|msg-&gt;link
)paren
comma
op_amp
(paren
id|kcs_info-&gt;xmit_msgs
)paren
)paren
suffix:semicolon
multiline_comment|/* We have to release the msg lock and claim the kcs&n;&t;&t;   lock in this case, because of race conditions. */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|kcs_info-&gt;msg_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|kcs_info-&gt;kcs_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|result
op_assign
id|kcs_event_handler
c_func
(paren
id|kcs_info
comma
l_int|0
)paren
suffix:semicolon
r_while
c_loop
(paren
id|result
op_ne
id|KCS_SM_IDLE
)paren
(brace
id|udelay
c_func
(paren
id|KCS_SHORT_TIMEOUT_USEC
)paren
suffix:semicolon
id|result
op_assign
id|kcs_event_handler
c_func
(paren
id|kcs_info
comma
id|KCS_SHORT_TIMEOUT_USEC
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|kcs_info-&gt;kcs_lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|priority
OG
l_int|0
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
(paren
id|msg-&gt;link
)paren
comma
op_amp
(paren
id|kcs_info-&gt;hp_xmit_msgs
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|list_add_tail
c_func
(paren
op_amp
(paren
id|msg-&gt;link
)paren
comma
op_amp
(paren
id|kcs_info-&gt;xmit_msgs
)paren
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|kcs_info-&gt;msg_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|kcs_info-&gt;kcs_lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|kcs_info-&gt;kcs_state
op_eq
id|KCS_NORMAL
)paren
op_logical_and
(paren
id|kcs_info-&gt;curr_msg
op_eq
l_int|NULL
)paren
)paren
(brace
id|start_next_msg
c_func
(paren
id|kcs_info
)paren
suffix:semicolon
id|kcs_restart_short_timer
c_func
(paren
id|kcs_info
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|kcs_info-&gt;kcs_lock
)paren
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|set_run_to_completion
r_static
r_void
id|set_run_to_completion
c_func
(paren
r_void
op_star
id|send_info
comma
r_int
id|i_run_to_completion
)paren
(brace
r_struct
id|kcs_info
op_star
id|kcs_info
op_assign
(paren
r_struct
id|kcs_info
op_star
)paren
id|send_info
suffix:semicolon
r_enum
id|kcs_result
id|result
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|kcs_info-&gt;kcs_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|kcs_info-&gt;run_to_completion
op_assign
id|i_run_to_completion
suffix:semicolon
r_if
c_cond
(paren
id|i_run_to_completion
)paren
(brace
id|result
op_assign
id|kcs_event_handler
c_func
(paren
id|kcs_info
comma
l_int|0
)paren
suffix:semicolon
r_while
c_loop
(paren
id|result
op_ne
id|KCS_SM_IDLE
)paren
(brace
id|udelay
c_func
(paren
id|KCS_SHORT_TIMEOUT_USEC
)paren
suffix:semicolon
id|result
op_assign
id|kcs_event_handler
c_func
(paren
id|kcs_info
comma
id|KCS_SHORT_TIMEOUT_USEC
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|kcs_info-&gt;kcs_lock
)paren
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|request_events
r_static
r_void
id|request_events
c_func
(paren
r_void
op_star
id|send_info
)paren
(brace
r_struct
id|kcs_info
op_star
id|kcs_info
op_assign
(paren
r_struct
id|kcs_info
op_star
)paren
id|send_info
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|kcs_info-&gt;req_events
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|variable|initialized
r_static
r_int
id|initialized
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Must be called with interrupts off and with the kcs_lock held. */
DECL|function|kcs_restart_short_timer
r_static
r_void
id|kcs_restart_short_timer
c_func
(paren
r_struct
id|kcs_info
op_star
id|kcs_info
)paren
(brace
r_if
c_cond
(paren
id|del_timer
c_func
(paren
op_amp
(paren
id|kcs_info-&gt;kcs_timer
)paren
)paren
)paren
(brace
macro_line|#ifdef CONFIG_HIGH_RES_TIMERS
r_int
r_int
id|jiffies_now
suffix:semicolon
multiline_comment|/* If we don&squot;t delete the timer, then it will go off&n;&t;&t;   immediately, anyway.  So we only process if we&n;&t;&t;   actually delete the timer. */
multiline_comment|/* We already have irqsave on, so no need for it&n;                   here. */
id|read_lock
c_func
(paren
op_amp
id|xtime_lock
)paren
suffix:semicolon
id|jiffies_now
op_assign
id|jiffies
suffix:semicolon
id|kcs_info-&gt;kcs_timer.expires
op_assign
id|jiffies_now
suffix:semicolon
id|kcs_info-&gt;kcs_timer.sub_expires
op_assign
id|quick_update_jiffies_sub
c_func
(paren
id|jiffies_now
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|xtime_lock
)paren
suffix:semicolon
id|kcs_info-&gt;kcs_timer.sub_expires
op_add_assign
id|usec_to_arch_cycles
c_func
(paren
id|KCS_SHORT_TIMEOUT_USEC
)paren
suffix:semicolon
r_while
c_loop
(paren
id|kcs_info-&gt;kcs_timer.sub_expires
op_ge
id|cycles_per_jiffies
)paren
(brace
id|kcs_info-&gt;kcs_timer.expires
op_increment
suffix:semicolon
id|kcs_info-&gt;kcs_timer.sub_expires
op_sub_assign
id|cycles_per_jiffies
suffix:semicolon
)brace
macro_line|#else
id|kcs_info-&gt;kcs_timer.expires
op_assign
id|jiffies
op_plus
l_int|1
suffix:semicolon
macro_line|#endif
id|add_timer
c_func
(paren
op_amp
(paren
id|kcs_info-&gt;kcs_timer
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|kcs_timeout
r_static
r_void
id|kcs_timeout
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|kcs_info
op_star
id|kcs_info
op_assign
(paren
r_struct
id|kcs_info
op_star
)paren
id|data
suffix:semicolon
r_enum
id|kcs_result
id|kcs_result
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|jiffies_now
suffix:semicolon
r_int
r_int
id|time_diff
suffix:semicolon
macro_line|#ifdef DEBUG_TIMING
r_struct
id|timeval
id|t
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|kcs_info-&gt;stop_operation
)paren
(brace
id|kcs_info-&gt;timer_stopped
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|kcs_info-&gt;kcs_lock
)paren
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_TIMING
id|do_gettimeofday
c_func
(paren
op_amp
id|t
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;**Timer: %d.%9.9d&bslash;n&quot;
comma
id|t.tv_sec
comma
id|t.tv_usec
)paren
suffix:semicolon
macro_line|#endif
id|jiffies_now
op_assign
id|jiffies
suffix:semicolon
id|time_diff
op_assign
(paren
(paren
id|jiffies_now
op_minus
id|kcs_info-&gt;last_timeout_jiffies
)paren
op_star
id|KCS_USEC_PER_JIFFY
)paren
suffix:semicolon
id|kcs_result
op_assign
id|kcs_event_handler
c_func
(paren
id|kcs_info
comma
id|time_diff
)paren
suffix:semicolon
id|kcs_info-&gt;last_timeout_jiffies
op_assign
id|jiffies_now
suffix:semicolon
r_if
c_cond
(paren
(paren
id|kcs_info-&gt;irq
)paren
op_logical_and
(paren
op_logical_neg
id|kcs_info-&gt;interrupt_disabled
)paren
)paren
(brace
multiline_comment|/* Running with interrupts, only do long timeouts. */
id|kcs_info-&gt;kcs_timer.expires
op_assign
id|jiffies
op_plus
id|KCS_TIMEOUT_JIFFIES
suffix:semicolon
r_goto
id|do_add_timer
suffix:semicolon
)brace
multiline_comment|/* If the state machine asks for a short delay, then shorten&n;           the timer timeout. */
macro_line|#ifdef CONFIG_HIGH_RES_TIMERS
r_if
c_cond
(paren
id|kcs_result
op_eq
id|KCS_CALL_WITH_DELAY
)paren
(brace
id|kcs_info-&gt;kcs_timer.sub_expires
op_add_assign
id|usec_to_arch_cycles
c_func
(paren
id|KCS_SHORT_TIMEOUT_USEC
)paren
suffix:semicolon
r_while
c_loop
(paren
id|kcs_info-&gt;kcs_timer.sub_expires
op_ge
id|cycles_per_jiffies
)paren
(brace
id|kcs_info-&gt;kcs_timer.expires
op_increment
suffix:semicolon
id|kcs_info-&gt;kcs_timer.sub_expires
op_sub_assign
id|cycles_per_jiffies
suffix:semicolon
)brace
)brace
r_else
(brace
id|kcs_info-&gt;kcs_timer.expires
op_assign
id|jiffies
op_plus
id|KCS_TIMEOUT_JIFFIES
suffix:semicolon
id|kcs_info-&gt;kcs_timer.sub_expires
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#else
multiline_comment|/* If requested, take the shortest delay possible */
r_if
c_cond
(paren
id|kcs_result
op_eq
id|KCS_CALL_WITH_DELAY
)paren
(brace
id|kcs_info-&gt;kcs_timer.expires
op_assign
id|jiffies
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|kcs_info-&gt;kcs_timer.expires
op_assign
id|jiffies
op_plus
id|KCS_TIMEOUT_JIFFIES
suffix:semicolon
)brace
macro_line|#endif
id|do_add_timer
suffix:colon
id|add_timer
c_func
(paren
op_amp
(paren
id|kcs_info-&gt;kcs_timer
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|kcs_info-&gt;kcs_lock
)paren
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|kcs_irq_handler
r_static
id|irqreturn_t
id|kcs_irq_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|data
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|kcs_info
op_star
id|kcs_info
op_assign
(paren
r_struct
id|kcs_info
op_star
)paren
id|data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG_TIMING
r_struct
id|timeval
id|t
suffix:semicolon
macro_line|#endif
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|kcs_info-&gt;kcs_lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kcs_info-&gt;stop_operation
)paren
r_goto
id|out
suffix:semicolon
macro_line|#ifdef DEBUG_TIMING
id|do_gettimeofday
c_func
(paren
op_amp
id|t
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;**Interrupt: %d.%9.9d&bslash;n&quot;
comma
id|t.tv_sec
comma
id|t.tv_usec
)paren
suffix:semicolon
macro_line|#endif
id|kcs_event_handler
c_func
(paren
id|kcs_info
comma
l_int|0
)paren
suffix:semicolon
id|out
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|kcs_info-&gt;kcs_lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
DECL|variable|handlers
r_static
r_struct
id|ipmi_smi_handlers
id|handlers
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|sender
op_assign
id|sender
comma
dot
id|request_events
op_assign
id|request_events
comma
dot
id|set_run_to_completion
op_assign
id|set_run_to_completion
comma
)brace
suffix:semicolon
DECL|variable|ipmi_kcs_dev_rev
r_static
r_int
r_char
id|ipmi_kcs_dev_rev
suffix:semicolon
DECL|variable|ipmi_kcs_fw_rev_major
r_static
r_int
r_char
id|ipmi_kcs_fw_rev_major
suffix:semicolon
DECL|variable|ipmi_kcs_fw_rev_minor
r_static
r_int
r_char
id|ipmi_kcs_fw_rev_minor
suffix:semicolon
DECL|variable|ipmi_version_major
r_static
r_int
r_char
id|ipmi_version_major
suffix:semicolon
DECL|variable|ipmi_version_minor
r_static
r_int
r_char
id|ipmi_version_minor
suffix:semicolon
r_extern
r_int
id|kcs_dbg
suffix:semicolon
DECL|function|ipmi_kcs_detect_hardware
r_static
r_int
id|ipmi_kcs_detect_hardware
c_func
(paren
r_int
r_int
id|port
comma
r_int
r_char
op_star
id|addr
comma
r_struct
id|kcs_data
op_star
id|data
)paren
(brace
r_int
r_char
id|msg
(braket
l_int|2
)braket
suffix:semicolon
r_int
r_char
id|resp
(braket
id|IPMI_MAX_MSG_LENGTH
)braket
suffix:semicolon
r_int
r_int
id|resp_len
suffix:semicolon
r_enum
id|kcs_result
id|kcs_result
suffix:semicolon
multiline_comment|/* It&squot;s impossible for the KCS status register to be all 1&squot;s,&n;&t;   (assuming a properly functioning, self-initialized BMC)&n;&t;   but that&squot;s what you get from reading a bogus address, so we&n;&t;   test that first. */
r_if
c_cond
(paren
id|port
)paren
(brace
r_if
c_cond
(paren
id|inb
c_func
(paren
id|port
op_plus
l_int|1
)paren
op_eq
l_int|0xff
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|readb
c_func
(paren
id|addr
op_plus
l_int|1
)paren
op_eq
l_int|0xff
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* Do a Get Device ID command, since it comes back with some&n;&t;   useful info. */
id|msg
(braket
l_int|0
)braket
op_assign
id|IPMI_NETFN_APP_REQUEST
op_lshift
l_int|2
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|IPMI_GET_DEVICE_ID_CMD
suffix:semicolon
id|start_kcs_transaction
c_func
(paren
id|data
comma
id|msg
comma
l_int|2
)paren
suffix:semicolon
id|kcs_result
op_assign
id|kcs_event
c_func
(paren
id|data
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|kcs_result
op_eq
id|KCS_CALL_WITH_DELAY
)paren
(brace
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|kcs_result
op_assign
id|kcs_event
c_func
(paren
id|data
comma
l_int|100
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|kcs_result
op_eq
id|KCS_CALL_WITHOUT_DELAY
)paren
(brace
id|kcs_result
op_assign
id|kcs_event
c_func
(paren
id|data
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|kcs_result
op_eq
id|KCS_SM_HOSED
)paren
(brace
multiline_comment|/* We couldn&squot;t get the state machine to run, so whatever&squot;s at&n;&t;&t;   the port is probably not an IPMI KCS interface. */
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* Otherwise, we got some data. */
id|resp_len
op_assign
id|kcs_get_result
c_func
(paren
id|data
comma
id|resp
comma
id|IPMI_MAX_MSG_LENGTH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|resp_len
OL
l_int|6
)paren
multiline_comment|/* That&squot;s odd, it should be longer. */
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|resp
(braket
l_int|1
)braket
op_ne
id|IPMI_GET_DEVICE_ID_CMD
)paren
op_logical_or
(paren
id|resp
(braket
l_int|2
)braket
op_ne
l_int|0
)paren
)paren
multiline_comment|/* That&squot;s odd, it shouldn&squot;t be able to fail. */
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ipmi_kcs_dev_rev
op_assign
id|resp
(braket
l_int|4
)braket
op_amp
l_int|0xf
suffix:semicolon
id|ipmi_kcs_fw_rev_major
op_assign
id|resp
(braket
l_int|5
)braket
op_amp
l_int|0x7f
suffix:semicolon
id|ipmi_kcs_fw_rev_minor
op_assign
id|resp
(braket
l_int|6
)braket
suffix:semicolon
id|ipmi_version_major
op_assign
id|resp
(braket
l_int|7
)braket
op_amp
l_int|0xf
suffix:semicolon
id|ipmi_version_minor
op_assign
id|resp
(braket
l_int|7
)braket
op_rshift
l_int|4
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* There can be 4 IO ports passed in (with or without IRQs), 4 addresses,&n;   a default IO port, and 1 ACPI/SPMI address.  That sets KCS_MAX_DRIVERS */
DECL|macro|KCS_MAX_PARMS
mdefine_line|#define KCS_MAX_PARMS 4
DECL|macro|KCS_MAX_DRIVERS
mdefine_line|#define KCS_MAX_DRIVERS ((KCS_MAX_PARMS * 2) + 2)
DECL|variable|kcs_infos
r_static
r_struct
id|kcs_info
op_star
id|kcs_infos
(braket
id|KCS_MAX_DRIVERS
)braket
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
DECL|macro|DEVICE_NAME
mdefine_line|#define DEVICE_NAME &quot;ipmi_kcs&quot;
DECL|macro|DEFAULT_IO_PORT
mdefine_line|#define DEFAULT_IO_PORT 0xca2
DECL|variable|kcs_trydefaults
r_static
r_int
id|kcs_trydefaults
op_assign
l_int|1
suffix:semicolon
DECL|variable|kcs_addrs
r_static
r_int
r_int
id|kcs_addrs
(braket
id|KCS_MAX_PARMS
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|kcs_ports
r_static
r_int
id|kcs_ports
(braket
id|KCS_MAX_PARMS
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|kcs_irqs
r_static
r_int
id|kcs_irqs
(braket
id|KCS_MAX_PARMS
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|kcs_trydefaults
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|kcs_addrs
comma
l_string|&quot;1-4l&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|kcs_irqs
comma
l_string|&quot;1-4i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|kcs_ports
comma
l_string|&quot;1-4i&quot;
)paren
suffix:semicolon
multiline_comment|/* Returns 0 if initialized, or negative on an error. */
DECL|function|init_one_kcs
r_static
r_int
id|init_one_kcs
c_func
(paren
r_int
id|kcs_port
comma
r_int
id|irq
comma
r_int
r_int
id|kcs_physaddr
comma
r_struct
id|kcs_info
op_star
op_star
id|kcs
)paren
(brace
r_int
id|rv
suffix:semicolon
r_struct
id|kcs_info
op_star
id|new_kcs
suffix:semicolon
multiline_comment|/* Did anything get passed in at all?  Both == zero disables the&n;&t;   driver. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|kcs_port
op_logical_or
id|kcs_physaddr
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* Only initialize a port OR a physical address on this call.&n;&t;   Also, IRQs can go with either ports or addresses. */
r_if
c_cond
(paren
id|kcs_port
op_logical_and
id|kcs_physaddr
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|new_kcs
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|new_kcs
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_kcs
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ipmi_kcs: out of memory&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* So we know not to free it unless we have allocated one. */
id|new_kcs-&gt;kcs_sm
op_assign
l_int|NULL
suffix:semicolon
id|new_kcs-&gt;addr
op_assign
l_int|NULL
suffix:semicolon
id|new_kcs-&gt;physaddr
op_assign
id|kcs_physaddr
suffix:semicolon
id|new_kcs-&gt;port
op_assign
id|kcs_port
suffix:semicolon
r_if
c_cond
(paren
id|kcs_port
)paren
(brace
r_if
c_cond
(paren
id|request_region
c_func
(paren
id|kcs_port
comma
l_int|2
comma
id|DEVICE_NAME
)paren
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|new_kcs
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ipmi_kcs: can&squot;t reserve port @ 0x%4.4x&bslash;n&quot;
comma
id|kcs_port
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|request_mem_region
c_func
(paren
id|kcs_physaddr
comma
l_int|2
comma
id|DEVICE_NAME
)paren
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|new_kcs
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ipmi_kcs: can&squot;t reserve memory @ 0x%lx&bslash;n&quot;
comma
id|kcs_physaddr
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|new_kcs-&gt;addr
op_assign
id|ioremap
c_func
(paren
id|kcs_physaddr
comma
l_int|2
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|new_kcs
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ipmi_kcs: can&squot;t remap memory at 0x%lx&bslash;n&quot;
comma
id|kcs_physaddr
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
id|new_kcs-&gt;kcs_sm
op_assign
id|kmalloc
c_func
(paren
id|kcs_size
c_func
(paren
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_kcs-&gt;kcs_sm
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ipmi_kcs: out of memory&bslash;n&quot;
)paren
suffix:semicolon
id|rv
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
id|init_kcs_data
c_func
(paren
id|new_kcs-&gt;kcs_sm
comma
id|kcs_port
comma
id|new_kcs-&gt;addr
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
(paren
id|new_kcs-&gt;kcs_lock
)paren
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
(paren
id|new_kcs-&gt;msg_lock
)paren
)paren
suffix:semicolon
id|rv
op_assign
id|ipmi_kcs_detect_hardware
c_func
(paren
id|kcs_port
comma
id|new_kcs-&gt;addr
comma
id|new_kcs-&gt;kcs_sm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
(brace
r_if
c_cond
(paren
id|kcs_port
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ipmi_kcs: No KCS @ port 0x%4.4x&bslash;n&quot;
comma
id|kcs_port
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ipmi_kcs: No KCS @ addr 0x%lx&bslash;n&quot;
comma
id|kcs_physaddr
)paren
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irq
op_ne
l_int|0
)paren
(brace
id|rv
op_assign
id|request_irq
c_func
(paren
id|irq
comma
id|kcs_irq_handler
comma
id|SA_INTERRUPT
comma
id|DEVICE_NAME
comma
id|new_kcs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ipmi_kcs: %s unable to claim interrupt %d,&quot;
l_string|&quot; running polled&bslash;n&quot;
comma
id|DEVICE_NAME
comma
id|irq
)paren
suffix:semicolon
id|irq
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|new_kcs-&gt;irq
op_assign
id|irq
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
(paren
id|new_kcs-&gt;xmit_msgs
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
(paren
id|new_kcs-&gt;hp_xmit_msgs
)paren
)paren
suffix:semicolon
id|new_kcs-&gt;curr_msg
op_assign
l_int|NULL
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|new_kcs-&gt;req_events
comma
l_int|0
)paren
suffix:semicolon
id|new_kcs-&gt;run_to_completion
op_assign
l_int|0
suffix:semicolon
id|start_clear_flags
c_func
(paren
id|new_kcs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
)paren
(brace
id|new_kcs-&gt;kcs_state
op_assign
id|KCS_CLEARING_FLAGS_THEN_SET_IRQ
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ipmi_kcs: Acquiring BMC @ port=0x%x irq=%d&bslash;n&quot;
comma
id|kcs_port
comma
id|irq
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|kcs_port
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ipmi_kcs: Acquiring BMC @ port=0x%x&bslash;n&quot;
comma
id|kcs_port
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ipmi_kcs: Acquiring BMC @ addr=0x%lx&bslash;n&quot;
comma
id|kcs_physaddr
)paren
suffix:semicolon
)brace
id|rv
op_assign
id|ipmi_register_smi
c_func
(paren
op_amp
id|handlers
comma
id|new_kcs
comma
id|ipmi_version_major
comma
id|ipmi_version_minor
comma
op_amp
(paren
id|new_kcs-&gt;intf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
(brace
id|free_irq
c_func
(paren
id|irq
comma
id|new_kcs
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ipmi_kcs: Unable to register device: error %d&bslash;n&quot;
comma
id|rv
)paren
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
id|new_kcs-&gt;interrupt_disabled
op_assign
l_int|0
suffix:semicolon
id|new_kcs-&gt;timer_stopped
op_assign
l_int|0
suffix:semicolon
id|new_kcs-&gt;stop_operation
op_assign
l_int|0
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
(paren
id|new_kcs-&gt;kcs_timer
)paren
)paren
suffix:semicolon
id|new_kcs-&gt;kcs_timer.data
op_assign
(paren
r_int
)paren
id|new_kcs
suffix:semicolon
id|new_kcs-&gt;kcs_timer.function
op_assign
id|kcs_timeout
suffix:semicolon
id|new_kcs-&gt;last_timeout_jiffies
op_assign
id|jiffies
suffix:semicolon
id|new_kcs-&gt;kcs_timer.expires
op_assign
id|jiffies
op_plus
id|KCS_TIMEOUT_JIFFIES
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
(paren
id|new_kcs-&gt;kcs_timer
)paren
)paren
suffix:semicolon
op_star
id|kcs
op_assign
id|new_kcs
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_err
suffix:colon
r_if
c_cond
(paren
id|kcs_port
)paren
id|release_region
(paren
id|kcs_port
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_kcs-&gt;addr
)paren
id|iounmap
c_func
(paren
id|new_kcs-&gt;addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kcs_physaddr
)paren
id|release_mem_region
c_func
(paren
id|kcs_physaddr
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_kcs-&gt;kcs_sm
)paren
id|kfree
c_func
(paren
id|new_kcs-&gt;kcs_sm
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|new_kcs
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_ACPI_INTERPRETER
macro_line|#include &lt;linux/acpi.h&gt;
DECL|struct|SPMITable
r_struct
id|SPMITable
(brace
DECL|member|Signature
id|s8
id|Signature
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|Length
id|u32
id|Length
suffix:semicolon
DECL|member|Revision
id|u8
id|Revision
suffix:semicolon
DECL|member|Checksum
id|u8
id|Checksum
suffix:semicolon
DECL|member|OEMID
id|s8
id|OEMID
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|OEMTableID
id|s8
id|OEMTableID
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|OEMRevision
id|s8
id|OEMRevision
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|CreatorID
id|s8
id|CreatorID
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|CreatorRevision
id|s8
id|CreatorRevision
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|InterfaceType
id|u8
id|InterfaceType
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|SpecificationRevision
id|s16
id|SpecificationRevision
suffix:semicolon
multiline_comment|/*&n;&t; * Bit 0 - SCI interrupt supported&n;&t; * Bit 1 - I/O APIC/SAPIC&n;&t; */
DECL|member|InterruptType
id|u8
id|InterruptType
suffix:semicolon
multiline_comment|/* If bit 0 of InterruptType is set, then this is the SCI&n;&t;   interrupt in the GPEx_STS register. */
DECL|member|GPE
id|u8
id|GPE
suffix:semicolon
DECL|member|Reserved
id|s16
id|Reserved
suffix:semicolon
multiline_comment|/* If bit 1 of InterruptType is set, then this is the I/O&n;&t;   APIC/SAPIC interrupt. */
DECL|member|GlobalSystemInterrupt
id|u32
id|GlobalSystemInterrupt
suffix:semicolon
multiline_comment|/* The actual register address. */
DECL|member|addr
r_struct
id|acpi_generic_address
id|addr
suffix:semicolon
DECL|member|UID
id|u8
id|UID
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|spmi_id
id|s8
id|spmi_id
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* A &squot;&bslash;0&squot; terminated array starts here. */
)brace
suffix:semicolon
DECL|function|acpi_find_bmc
r_static
r_int
id|acpi_find_bmc
c_func
(paren
r_int
r_int
op_star
id|physaddr
comma
r_int
op_star
id|port
)paren
(brace
id|acpi_status
id|status
suffix:semicolon
r_struct
id|SPMITable
op_star
id|spmi
suffix:semicolon
id|status
op_assign
id|acpi_get_firmware_table
c_func
(paren
l_string|&quot;SPMI&quot;
comma
l_int|1
comma
id|ACPI_LOGICAL_ADDRESSING
comma
(paren
r_struct
id|acpi_table_header
op_star
op_star
)paren
op_amp
id|spmi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
id|AE_OK
)paren
r_goto
id|not_found
suffix:semicolon
r_if
c_cond
(paren
id|spmi-&gt;InterfaceType
(braket
l_int|0
)braket
op_ne
l_int|1
)paren
multiline_comment|/* Not IPMI. */
r_goto
id|not_found
suffix:semicolon
r_if
c_cond
(paren
id|spmi-&gt;InterfaceType
(braket
l_int|1
)braket
op_ne
l_int|1
)paren
multiline_comment|/* Not KCS. */
r_goto
id|not_found
suffix:semicolon
r_if
c_cond
(paren
id|spmi-&gt;addr.address_space_id
op_eq
id|ACPI_ADR_SPACE_SYSTEM_MEMORY
)paren
(brace
op_star
id|physaddr
op_assign
id|spmi-&gt;addr.address
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ipmi_kcs_intf: Found ACPI-specified state machine&quot;
l_string|&quot; at memory address 0x%lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|spmi-&gt;addr.address
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|spmi-&gt;addr.address_space_id
op_eq
id|ACPI_ADR_SPACE_SYSTEM_IO
)paren
(brace
op_star
id|port
op_assign
id|spmi-&gt;addr.address
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ipmi_kcs_intf: Found ACPI-specified state machine&quot;
l_string|&quot; at I/O address 0x%lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|spmi-&gt;addr.address
)paren
suffix:semicolon
)brace
r_else
r_goto
id|not_found
suffix:semicolon
multiline_comment|/* Not an address type we recognise. */
r_return
l_int|0
suffix:semicolon
id|not_found
suffix:colon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
macro_line|#endif
DECL|function|init_ipmi_kcs
r_static
id|__init
r_int
id|init_ipmi_kcs
c_func
(paren
r_void
)paren
(brace
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
r_int
id|pos
op_assign
l_int|0
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_ACPI_INTERPRETER
r_int
r_int
id|physaddr
op_assign
l_int|0
suffix:semicolon
r_int
id|port
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|initialized
)paren
r_return
l_int|0
suffix:semicolon
id|initialized
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* First do the &quot;command-line&quot; parameters */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|KCS_MAX_PARMS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|rv
op_assign
id|init_one_kcs
c_func
(paren
id|kcs_ports
(braket
id|i
)braket
comma
id|kcs_irqs
(braket
id|i
)braket
comma
l_int|0
comma
op_amp
(paren
id|kcs_infos
(braket
id|pos
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
op_eq
l_int|0
)paren
id|pos
op_increment
suffix:semicolon
id|rv
op_assign
id|init_one_kcs
c_func
(paren
l_int|0
comma
id|kcs_irqs
(braket
id|i
)braket
comma
id|kcs_addrs
(braket
id|i
)braket
comma
op_amp
(paren
id|kcs_infos
(braket
id|pos
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
op_eq
l_int|0
)paren
id|pos
op_increment
suffix:semicolon
)brace
multiline_comment|/* Only try the defaults if enabled and resources are available&n;&t;   (because they weren&squot;t already specified above). */
r_if
c_cond
(paren
id|kcs_trydefaults
op_logical_and
(paren
id|pos
op_eq
l_int|0
)paren
)paren
(brace
id|rv
op_assign
op_minus
id|EINVAL
suffix:semicolon
macro_line|#ifdef CONFIG_ACPI_INTERPRETER
r_if
c_cond
(paren
id|rv
op_logical_and
(paren
id|physaddr
op_assign
id|acpi_find_bmc
c_func
(paren
op_amp
id|physaddr
comma
op_amp
id|port
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|rv
op_assign
id|init_one_kcs
c_func
(paren
id|port
comma
l_int|0
comma
id|physaddr
comma
op_amp
(paren
id|kcs_infos
(braket
id|pos
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
op_eq
l_int|0
)paren
id|pos
op_increment
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|rv
)paren
(brace
id|rv
op_assign
id|init_one_kcs
c_func
(paren
id|DEFAULT_IO_PORT
comma
l_int|0
comma
l_int|0
comma
op_amp
(paren
id|kcs_infos
(braket
id|pos
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
op_eq
l_int|0
)paren
id|pos
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|kcs_infos
(braket
l_int|0
)braket
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ipmi_kcs: Unable to find any KCS interfaces&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|init_ipmi_kcs
id|module_init
c_func
(paren
id|init_ipmi_kcs
)paren
suffix:semicolon
macro_line|#ifdef MODULE
DECL|function|cleanup_one_kcs
r_void
id|__exit
id|cleanup_one_kcs
c_func
(paren
r_struct
id|kcs_info
op_star
id|to_clean
)paren
(brace
r_int
id|rv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|to_clean
)paren
r_return
suffix:semicolon
multiline_comment|/* Tell the timer and interrupt handlers that we are shutting&n;&t;   down. */
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|to_clean-&gt;kcs_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
(paren
id|to_clean-&gt;msg_lock
)paren
)paren
suffix:semicolon
id|to_clean-&gt;stop_operation
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|to_clean-&gt;irq
op_ne
l_int|0
)paren
id|free_irq
c_func
(paren
id|to_clean-&gt;irq
comma
id|to_clean
)paren
suffix:semicolon
r_if
c_cond
(paren
id|to_clean-&gt;port
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ipmi_kcs: Releasing BMC @ port=0x%x&bslash;n&quot;
comma
id|to_clean-&gt;port
)paren
suffix:semicolon
id|release_region
(paren
id|to_clean-&gt;port
comma
l_int|2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|to_clean-&gt;addr
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ipmi_kcs: Releasing BMC @ addr=0x%lx&bslash;n&quot;
comma
id|to_clean-&gt;physaddr
)paren
suffix:semicolon
id|iounmap
c_func
(paren
id|to_clean-&gt;addr
)paren
suffix:semicolon
id|release_mem_region
c_func
(paren
id|to_clean-&gt;physaddr
comma
l_int|2
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
(paren
id|to_clean-&gt;msg_lock
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|to_clean-&gt;kcs_lock
)paren
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Wait until we know that we are out of any interrupt&n;&t;   handlers might have been running before we freed the&n;&t;   interrupt. */
id|synchronize_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Wait for the timer to stop.  This avoids problems with race&n;&t;   conditions removing the timer here. */
r_while
c_loop
(paren
op_logical_neg
id|to_clean-&gt;timer_stopped
)paren
(brace
id|schedule_timeout
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|rv
op_assign
id|ipmi_unregister_smi
c_func
(paren
id|to_clean-&gt;intf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ipmi_kcs: Unable to unregister device: errno=%d&bslash;n&quot;
comma
id|rv
)paren
suffix:semicolon
)brace
id|initialized
op_assign
l_int|0
suffix:semicolon
id|kfree
c_func
(paren
id|to_clean-&gt;kcs_sm
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|to_clean
)paren
suffix:semicolon
)brace
DECL|function|cleanup_ipmi_kcs
r_static
id|__exit
r_void
id|cleanup_ipmi_kcs
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|initialized
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|KCS_MAX_DRIVERS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cleanup_one_kcs
c_func
(paren
id|kcs_infos
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
DECL|variable|cleanup_ipmi_kcs
id|module_exit
c_func
(paren
id|cleanup_ipmi_kcs
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* Unfortunately, cmdline::get_options() only returns integers, not&n;   longs.  Since we need ulongs (64-bit physical addresses) parse the &n;   comma-separated list manually.  Arguments can be one of these forms:&n;   m0xaabbccddeeff&t;A physical memory address without an IRQ&n;   m0xaabbccddeeff:cc&t;A physical memory address with an IRQ&n;   p0xaabb&t;&t;An IO port without an IRQ&n;   p0xaabb:cc&t;&t;An IO port with an IRQ&n;   nodefaults&t;&t;Suppress trying the default IO port or ACPI address &n;&n;   For example, to pass one IO port with an IRQ, one address, and &n;   suppress the use of the default IO port and ACPI address,&n;   use this option string: ipmi_kcs=p0xCA2:5,m0xFF5B0022,nodefaults&n;&n;   Remember, ipmi_kcs_setup() is passed the string after the equal sign. */
DECL|function|ipmi_kcs_setup
r_static
r_int
id|__init
id|ipmi_kcs_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
r_int
id|val
suffix:semicolon
r_char
op_star
id|cur
comma
op_star
id|colon
suffix:semicolon
r_int
id|pos
suffix:semicolon
id|pos
op_assign
l_int|0
suffix:semicolon
id|cur
op_assign
id|strsep
c_func
(paren
op_amp
id|str
comma
l_string|&quot;,&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|cur
)paren
op_logical_and
(paren
op_star
id|cur
)paren
op_logical_and
(paren
id|pos
OL
id|KCS_MAX_PARMS
)paren
)paren
(brace
r_switch
c_cond
(paren
op_star
id|cur
)paren
(brace
r_case
l_char|&squot;n&squot;
suffix:colon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|cur
comma
l_string|&quot;nodefaults&quot;
)paren
op_eq
l_int|0
)paren
id|kcs_trydefaults
op_assign
l_int|0
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ipmi_kcs: bad parameter value %s&bslash;n&quot;
comma
id|cur
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;m&squot;
suffix:colon
r_case
l_char|&squot;p&squot;
suffix:colon
id|val
op_assign
id|simple_strtoul
c_func
(paren
id|cur
op_plus
l_int|1
comma
op_amp
id|colon
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|cur
op_eq
l_char|&squot;p&squot;
)paren
id|kcs_ports
(braket
id|pos
)braket
op_assign
id|val
suffix:semicolon
r_else
id|kcs_addrs
(braket
id|pos
)braket
op_assign
id|val
suffix:semicolon
r_if
c_cond
(paren
op_star
id|colon
op_eq
l_char|&squot;:&squot;
)paren
(brace
id|val
op_assign
id|simple_strtoul
c_func
(paren
id|colon
op_plus
l_int|1
comma
op_amp
id|colon
comma
l_int|0
)paren
suffix:semicolon
id|kcs_irqs
(braket
id|pos
)braket
op_assign
id|val
suffix:semicolon
)brace
id|pos
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ipmi_kcs: bad parameter value %s&bslash;n&quot;
comma
id|cur
)paren
suffix:semicolon
)brace
id|cur
op_assign
id|strsep
c_func
(paren
op_amp
id|str
comma
l_string|&quot;,&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;ipmi_kcs=&quot;
comma
id|ipmi_kcs_setup
)paren
suffix:semicolon
macro_line|#endif
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
