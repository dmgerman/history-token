multiline_comment|/*&n; * ipmi_si.c&n; *&n; * The interface to the IPMI driver for the system interfaces (KCS, SMIC,&n; * BT).&n; *&n; * Author: MontaVista Software, Inc.&n; *         Corey Minyard &lt;minyard@mvista.com&gt;&n; *         source@mvista.com&n; *&n; * Copyright 2002 MontaVista Software Inc.&n; *&n; *  This program is free software; you can redistribute it and/or modify it&n; *  under the terms of the GNU General Public License as published by the&n; *  Free Software Foundation; either version 2 of the License, or (at your&n; *  option) any later version.&n; *&n; *&n; *  THIS SOFTWARE IS PROVIDED ``AS IS&squot;&squot; AND ANY EXPRESS OR IMPLIED&n; *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&n; *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.&n; *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,&n; *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,&n; *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS&n; *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND&n; *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR&n; *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE&n; *  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n; *&n; *  You should have received a copy of the GNU General Public License along&n; *  with this program; if not, write to the Free Software Foundation, Inc.,&n; *  675 Mass Ave, Cambridge, MA 02139, USA.&n; */
multiline_comment|/*&n; * This file holds the &quot;policy&quot; for the interface to the SMI state&n; * machine.  It does the configuration, handles timers and interrupts,&n; * and drives the real SMI state machine.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/irq.h&gt;
macro_line|#ifdef CONFIG_HIGH_RES_TIMERS
macro_line|#include &lt;linux/hrtime.h&gt;
macro_line|# if defined(schedule_next_int)
multiline_comment|/* Old high-res timer code, do translations. */
DECL|macro|get_arch_cycles
macro_line|#  define get_arch_cycles(a) quick_update_jiffies_sub(a)
DECL|macro|arch_cycles_per_jiffy
macro_line|#  define arch_cycles_per_jiffy cycles_per_jiffies
macro_line|# endif
DECL|function|add_usec_to_timer
r_static
r_inline
r_void
id|add_usec_to_timer
c_func
(paren
r_struct
id|timer_list
op_star
id|t
comma
r_int
id|v
)paren
(brace
id|t-&gt;sub_expires
op_add_assign
id|nsec_to_arch_cycle
c_func
(paren
id|v
op_star
l_int|1000
)paren
suffix:semicolon
r_while
c_loop
(paren
id|t-&gt;sub_expires
op_ge
id|arch_cycles_per_jiffy
)paren
(brace
id|t-&gt;expires
op_increment
suffix:semicolon
id|t-&gt;sub_expires
op_sub_assign
id|arch_cycles_per_jiffy
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/rcupdate.h&gt;
macro_line|#include &lt;linux/ipmi_smi.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &quot;ipmi_si_sm.h&quot;
macro_line|#include &lt;linux/init.h&gt;
DECL|macro|IPMI_SI_VERSION
mdefine_line|#define IPMI_SI_VERSION &quot;v32&quot;
multiline_comment|/* Measure times between events in the driver. */
DECL|macro|DEBUG_TIMING
macro_line|#undef DEBUG_TIMING
multiline_comment|/* Call every 10 ms. */
DECL|macro|SI_TIMEOUT_TIME_USEC
mdefine_line|#define SI_TIMEOUT_TIME_USEC&t;10000
DECL|macro|SI_USEC_PER_JIFFY
mdefine_line|#define SI_USEC_PER_JIFFY&t;(1000000/HZ)
DECL|macro|SI_TIMEOUT_JIFFIES
mdefine_line|#define SI_TIMEOUT_JIFFIES&t;(SI_TIMEOUT_TIME_USEC/SI_USEC_PER_JIFFY)
DECL|macro|SI_SHORT_TIMEOUT_USEC
mdefine_line|#define SI_SHORT_TIMEOUT_USEC  250 /* .25ms when the SM request a&n;                                       short timeout */
DECL|enum|si_intf_state
r_enum
id|si_intf_state
(brace
DECL|enumerator|SI_NORMAL
id|SI_NORMAL
comma
DECL|enumerator|SI_GETTING_FLAGS
id|SI_GETTING_FLAGS
comma
DECL|enumerator|SI_GETTING_EVENTS
id|SI_GETTING_EVENTS
comma
DECL|enumerator|SI_CLEARING_FLAGS
id|SI_CLEARING_FLAGS
comma
DECL|enumerator|SI_CLEARING_FLAGS_THEN_SET_IRQ
id|SI_CLEARING_FLAGS_THEN_SET_IRQ
comma
DECL|enumerator|SI_GETTING_MESSAGES
id|SI_GETTING_MESSAGES
comma
DECL|enumerator|SI_ENABLE_INTERRUPTS1
id|SI_ENABLE_INTERRUPTS1
comma
DECL|enumerator|SI_ENABLE_INTERRUPTS2
id|SI_ENABLE_INTERRUPTS2
multiline_comment|/* FIXME - add watchdog stuff. */
)brace
suffix:semicolon
DECL|enum|si_type
r_enum
id|si_type
(brace
DECL|enumerator|SI_KCS
DECL|enumerator|SI_SMIC
DECL|enumerator|SI_BT
id|SI_KCS
comma
id|SI_SMIC
comma
id|SI_BT
)brace
suffix:semicolon
DECL|struct|smi_info
r_struct
id|smi_info
(brace
DECL|member|intf
id|ipmi_smi_t
id|intf
suffix:semicolon
DECL|member|si_sm
r_struct
id|si_sm_data
op_star
id|si_sm
suffix:semicolon
DECL|member|handlers
r_struct
id|si_sm_handlers
op_star
id|handlers
suffix:semicolon
DECL|member|si_type
r_enum
id|si_type
id|si_type
suffix:semicolon
DECL|member|si_lock
id|spinlock_t
id|si_lock
suffix:semicolon
DECL|member|msg_lock
id|spinlock_t
id|msg_lock
suffix:semicolon
DECL|member|xmit_msgs
r_struct
id|list_head
id|xmit_msgs
suffix:semicolon
DECL|member|hp_xmit_msgs
r_struct
id|list_head
id|hp_xmit_msgs
suffix:semicolon
DECL|member|curr_msg
r_struct
id|ipmi_smi_msg
op_star
id|curr_msg
suffix:semicolon
DECL|member|si_state
r_enum
id|si_intf_state
id|si_state
suffix:semicolon
multiline_comment|/* Used to handle the various types of I/O that can occur with&n;           IPMI */
DECL|member|io
r_struct
id|si_sm_io
id|io
suffix:semicolon
DECL|member|io_setup
r_int
(paren
op_star
id|io_setup
)paren
(paren
r_struct
id|smi_info
op_star
id|info
)paren
suffix:semicolon
DECL|member|io_cleanup
r_void
(paren
op_star
id|io_cleanup
)paren
(paren
r_struct
id|smi_info
op_star
id|info
)paren
suffix:semicolon
DECL|member|irq_setup
r_int
(paren
op_star
id|irq_setup
)paren
(paren
r_struct
id|smi_info
op_star
id|info
)paren
suffix:semicolon
DECL|member|irq_cleanup
r_void
(paren
op_star
id|irq_cleanup
)paren
(paren
r_struct
id|smi_info
op_star
id|info
)paren
suffix:semicolon
DECL|member|io_size
r_int
r_int
id|io_size
suffix:semicolon
multiline_comment|/* Flags from the last GET_MSG_FLAGS command, used when an ATTN&n;&t;   is set to hold the flags until we are done handling everything&n;&t;   from the flags. */
DECL|macro|RECEIVE_MSG_AVAIL
mdefine_line|#define RECEIVE_MSG_AVAIL&t;0x01
DECL|macro|EVENT_MSG_BUFFER_FULL
mdefine_line|#define EVENT_MSG_BUFFER_FULL&t;0x02
DECL|macro|WDT_PRE_TIMEOUT_INT
mdefine_line|#define WDT_PRE_TIMEOUT_INT&t;0x08
DECL|member|msg_flags
r_int
r_char
id|msg_flags
suffix:semicolon
multiline_comment|/* If set to true, this will request events the next time the&n;&t;   state machine is idle. */
DECL|member|req_events
id|atomic_t
id|req_events
suffix:semicolon
multiline_comment|/* If true, run the state machine to completion on every send&n;&t;   call.  Generally used after a panic to make sure stuff goes&n;&t;   out. */
DECL|member|run_to_completion
r_int
id|run_to_completion
suffix:semicolon
multiline_comment|/* The I/O port of an SI interface. */
DECL|member|port
r_int
id|port
suffix:semicolon
multiline_comment|/* zero if no irq; */
DECL|member|irq
r_int
id|irq
suffix:semicolon
multiline_comment|/* The timer for this si. */
DECL|member|si_timer
r_struct
id|timer_list
id|si_timer
suffix:semicolon
multiline_comment|/* The time (in jiffies) the last timeout occurred at. */
DECL|member|last_timeout_jiffies
r_int
r_int
id|last_timeout_jiffies
suffix:semicolon
multiline_comment|/* Used to gracefully stop the timer without race conditions. */
DECL|member|stop_operation
r_volatile
r_int
id|stop_operation
suffix:semicolon
DECL|member|timer_stopped
r_volatile
r_int
id|timer_stopped
suffix:semicolon
multiline_comment|/* The driver will disable interrupts when it gets into a&n;&t;   situation where it cannot handle messages due to lack of&n;&t;   memory.  Once that situation clears up, it will re-enable&n;&t;   interrupts. */
DECL|member|interrupt_disabled
r_int
id|interrupt_disabled
suffix:semicolon
DECL|member|ipmi_si_dev_rev
r_int
r_char
id|ipmi_si_dev_rev
suffix:semicolon
DECL|member|ipmi_si_fw_rev_major
r_int
r_char
id|ipmi_si_fw_rev_major
suffix:semicolon
DECL|member|ipmi_si_fw_rev_minor
r_int
r_char
id|ipmi_si_fw_rev_minor
suffix:semicolon
DECL|member|ipmi_version_major
r_int
r_char
id|ipmi_version_major
suffix:semicolon
DECL|member|ipmi_version_minor
r_int
r_char
id|ipmi_version_minor
suffix:semicolon
multiline_comment|/* Counters and things for the proc filesystem. */
DECL|member|count_lock
id|spinlock_t
id|count_lock
suffix:semicolon
DECL|member|short_timeouts
r_int
r_int
id|short_timeouts
suffix:semicolon
DECL|member|long_timeouts
r_int
r_int
id|long_timeouts
suffix:semicolon
DECL|member|timeout_restarts
r_int
r_int
id|timeout_restarts
suffix:semicolon
DECL|member|idles
r_int
r_int
id|idles
suffix:semicolon
DECL|member|interrupts
r_int
r_int
id|interrupts
suffix:semicolon
DECL|member|attentions
r_int
r_int
id|attentions
suffix:semicolon
DECL|member|flag_fetches
r_int
r_int
id|flag_fetches
suffix:semicolon
DECL|member|hosed_count
r_int
r_int
id|hosed_count
suffix:semicolon
DECL|member|complete_transactions
r_int
r_int
id|complete_transactions
suffix:semicolon
DECL|member|events
r_int
r_int
id|events
suffix:semicolon
DECL|member|watchdog_pretimeouts
r_int
r_int
id|watchdog_pretimeouts
suffix:semicolon
DECL|member|incoming_messages
r_int
r_int
id|incoming_messages
suffix:semicolon
)brace
suffix:semicolon
r_static
r_void
id|si_restart_short_timer
c_func
(paren
r_struct
id|smi_info
op_star
id|smi_info
)paren
suffix:semicolon
DECL|function|deliver_recv_msg
r_static
r_void
id|deliver_recv_msg
c_func
(paren
r_struct
id|smi_info
op_star
id|smi_info
comma
r_struct
id|ipmi_smi_msg
op_star
id|msg
)paren
(brace
multiline_comment|/* Deliver the message to the upper layer with the lock&n;           released. */
id|spin_unlock
c_func
(paren
op_amp
(paren
id|smi_info-&gt;si_lock
)paren
)paren
suffix:semicolon
id|ipmi_smi_msg_received
c_func
(paren
id|smi_info-&gt;intf
comma
id|msg
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
(paren
id|smi_info-&gt;si_lock
)paren
)paren
suffix:semicolon
)brace
DECL|function|return_hosed_msg
r_static
r_void
id|return_hosed_msg
c_func
(paren
r_struct
id|smi_info
op_star
id|smi_info
)paren
(brace
r_struct
id|ipmi_smi_msg
op_star
id|msg
op_assign
id|smi_info-&gt;curr_msg
suffix:semicolon
multiline_comment|/* Make it a reponse */
id|msg-&gt;rsp
(braket
l_int|0
)braket
op_assign
id|msg-&gt;data
(braket
l_int|0
)braket
op_or
l_int|4
suffix:semicolon
id|msg-&gt;rsp
(braket
l_int|1
)braket
op_assign
id|msg-&gt;data
(braket
l_int|1
)braket
suffix:semicolon
id|msg-&gt;rsp
(braket
l_int|2
)braket
op_assign
l_int|0xFF
suffix:semicolon
multiline_comment|/* Unknown error. */
id|msg-&gt;rsp_size
op_assign
l_int|3
suffix:semicolon
id|smi_info-&gt;curr_msg
op_assign
l_int|NULL
suffix:semicolon
id|deliver_recv_msg
c_func
(paren
id|smi_info
comma
id|msg
)paren
suffix:semicolon
)brace
DECL|function|start_next_msg
r_static
r_enum
id|si_sm_result
id|start_next_msg
c_func
(paren
r_struct
id|smi_info
op_star
id|smi_info
)paren
(brace
r_int
id|rv
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef DEBUG_TIMING
r_struct
id|timeval
id|t
suffix:semicolon
macro_line|#endif
multiline_comment|/* No need to save flags, we aleady have interrupts off and we&n;&t;   already hold the SMI lock. */
id|spin_lock
c_func
(paren
op_amp
(paren
id|smi_info-&gt;msg_lock
)paren
)paren
suffix:semicolon
multiline_comment|/* Pick the high priority queue first. */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
(paren
id|smi_info-&gt;hp_xmit_msgs
)paren
)paren
)paren
(brace
id|entry
op_assign
id|smi_info-&gt;hp_xmit_msgs.next
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
(paren
id|smi_info-&gt;xmit_msgs
)paren
)paren
)paren
(brace
id|entry
op_assign
id|smi_info-&gt;xmit_msgs.next
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
(brace
id|smi_info-&gt;curr_msg
op_assign
l_int|NULL
suffix:semicolon
id|rv
op_assign
id|SI_SM_IDLE
suffix:semicolon
)brace
r_else
(brace
r_int
id|err
suffix:semicolon
id|list_del
c_func
(paren
id|entry
)paren
suffix:semicolon
id|smi_info-&gt;curr_msg
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|ipmi_smi_msg
comma
id|link
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_TIMING
id|do_gettimeofday
c_func
(paren
op_amp
id|t
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;**Start2: %d.%9.9d&bslash;n&quot;
comma
id|t.tv_sec
comma
id|t.tv_usec
)paren
suffix:semicolon
macro_line|#endif
id|err
op_assign
id|smi_info-&gt;handlers
op_member_access_from_pointer
id|start_transaction
c_func
(paren
id|smi_info-&gt;si_sm
comma
id|smi_info-&gt;curr_msg-&gt;data
comma
id|smi_info-&gt;curr_msg-&gt;data_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|return_hosed_msg
c_func
(paren
id|smi_info
)paren
suffix:semicolon
)brace
id|rv
op_assign
id|SI_SM_CALL_WITHOUT_DELAY
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
(paren
id|smi_info-&gt;msg_lock
)paren
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
DECL|function|start_enable_irq
r_static
r_void
id|start_enable_irq
c_func
(paren
r_struct
id|smi_info
op_star
id|smi_info
)paren
(brace
r_int
r_char
id|msg
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* If we are enabling interrupts, we have to tell the&n;&t;   BMC to use them. */
id|msg
(braket
l_int|0
)braket
op_assign
(paren
id|IPMI_NETFN_APP_REQUEST
op_lshift
l_int|2
)paren
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|IPMI_GET_BMC_GLOBAL_ENABLES_CMD
suffix:semicolon
id|smi_info-&gt;handlers
op_member_access_from_pointer
id|start_transaction
c_func
(paren
id|smi_info-&gt;si_sm
comma
id|msg
comma
l_int|2
)paren
suffix:semicolon
id|smi_info-&gt;si_state
op_assign
id|SI_ENABLE_INTERRUPTS1
suffix:semicolon
)brace
DECL|function|start_clear_flags
r_static
r_void
id|start_clear_flags
c_func
(paren
r_struct
id|smi_info
op_star
id|smi_info
)paren
(brace
r_int
r_char
id|msg
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* Make sure the watchdog pre-timeout flag is not set at startup. */
id|msg
(braket
l_int|0
)braket
op_assign
(paren
id|IPMI_NETFN_APP_REQUEST
op_lshift
l_int|2
)paren
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|IPMI_CLEAR_MSG_FLAGS_CMD
suffix:semicolon
id|msg
(braket
l_int|2
)braket
op_assign
id|WDT_PRE_TIMEOUT_INT
suffix:semicolon
id|smi_info-&gt;handlers
op_member_access_from_pointer
id|start_transaction
c_func
(paren
id|smi_info-&gt;si_sm
comma
id|msg
comma
l_int|3
)paren
suffix:semicolon
id|smi_info-&gt;si_state
op_assign
id|SI_CLEARING_FLAGS
suffix:semicolon
)brace
multiline_comment|/* When we have a situtaion where we run out of memory and cannot&n;   allocate messages, we just leave them in the BMC and run the system&n;   polled until we can allocate some memory.  Once we have some&n;   memory, we will re-enable the interrupt. */
DECL|function|disable_si_irq
r_static
r_inline
r_void
id|disable_si_irq
c_func
(paren
r_struct
id|smi_info
op_star
id|smi_info
)paren
(brace
r_if
c_cond
(paren
(paren
id|smi_info-&gt;irq
)paren
op_logical_and
(paren
op_logical_neg
id|smi_info-&gt;interrupt_disabled
)paren
)paren
(brace
id|disable_irq_nosync
c_func
(paren
id|smi_info-&gt;irq
)paren
suffix:semicolon
id|smi_info-&gt;interrupt_disabled
op_assign
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|enable_si_irq
r_static
r_inline
r_void
id|enable_si_irq
c_func
(paren
r_struct
id|smi_info
op_star
id|smi_info
)paren
(brace
r_if
c_cond
(paren
(paren
id|smi_info-&gt;irq
)paren
op_logical_and
(paren
id|smi_info-&gt;interrupt_disabled
)paren
)paren
(brace
id|enable_irq
c_func
(paren
id|smi_info-&gt;irq
)paren
suffix:semicolon
id|smi_info-&gt;interrupt_disabled
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|handle_flags
r_static
r_void
id|handle_flags
c_func
(paren
r_struct
id|smi_info
op_star
id|smi_info
)paren
(brace
r_if
c_cond
(paren
id|smi_info-&gt;msg_flags
op_amp
id|WDT_PRE_TIMEOUT_INT
)paren
(brace
multiline_comment|/* Watchdog pre-timeout */
id|spin_lock
c_func
(paren
op_amp
id|smi_info-&gt;count_lock
)paren
suffix:semicolon
id|smi_info-&gt;watchdog_pretimeouts
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|smi_info-&gt;count_lock
)paren
suffix:semicolon
id|start_clear_flags
c_func
(paren
id|smi_info
)paren
suffix:semicolon
id|smi_info-&gt;msg_flags
op_and_assign
op_complement
id|WDT_PRE_TIMEOUT_INT
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
(paren
id|smi_info-&gt;si_lock
)paren
)paren
suffix:semicolon
id|ipmi_smi_watchdog_pretimeout
c_func
(paren
id|smi_info-&gt;intf
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
(paren
id|smi_info-&gt;si_lock
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|smi_info-&gt;msg_flags
op_amp
id|RECEIVE_MSG_AVAIL
)paren
(brace
multiline_comment|/* Messages available. */
id|smi_info-&gt;curr_msg
op_assign
id|ipmi_alloc_smi_msg
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|smi_info-&gt;curr_msg
)paren
(brace
id|disable_si_irq
c_func
(paren
id|smi_info
)paren
suffix:semicolon
id|smi_info-&gt;si_state
op_assign
id|SI_NORMAL
suffix:semicolon
r_return
suffix:semicolon
)brace
id|enable_si_irq
c_func
(paren
id|smi_info
)paren
suffix:semicolon
id|smi_info-&gt;curr_msg-&gt;data
(braket
l_int|0
)braket
op_assign
(paren
id|IPMI_NETFN_APP_REQUEST
op_lshift
l_int|2
)paren
suffix:semicolon
id|smi_info-&gt;curr_msg-&gt;data
(braket
l_int|1
)braket
op_assign
id|IPMI_GET_MSG_CMD
suffix:semicolon
id|smi_info-&gt;curr_msg-&gt;data_size
op_assign
l_int|2
suffix:semicolon
id|smi_info-&gt;handlers
op_member_access_from_pointer
id|start_transaction
c_func
(paren
id|smi_info-&gt;si_sm
comma
id|smi_info-&gt;curr_msg-&gt;data
comma
id|smi_info-&gt;curr_msg-&gt;data_size
)paren
suffix:semicolon
id|smi_info-&gt;si_state
op_assign
id|SI_GETTING_MESSAGES
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|smi_info-&gt;msg_flags
op_amp
id|EVENT_MSG_BUFFER_FULL
)paren
(brace
multiline_comment|/* Events available. */
id|smi_info-&gt;curr_msg
op_assign
id|ipmi_alloc_smi_msg
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|smi_info-&gt;curr_msg
)paren
(brace
id|disable_si_irq
c_func
(paren
id|smi_info
)paren
suffix:semicolon
id|smi_info-&gt;si_state
op_assign
id|SI_NORMAL
suffix:semicolon
r_return
suffix:semicolon
)brace
id|enable_si_irq
c_func
(paren
id|smi_info
)paren
suffix:semicolon
id|smi_info-&gt;curr_msg-&gt;data
(braket
l_int|0
)braket
op_assign
(paren
id|IPMI_NETFN_APP_REQUEST
op_lshift
l_int|2
)paren
suffix:semicolon
id|smi_info-&gt;curr_msg-&gt;data
(braket
l_int|1
)braket
op_assign
id|IPMI_READ_EVENT_MSG_BUFFER_CMD
suffix:semicolon
id|smi_info-&gt;curr_msg-&gt;data_size
op_assign
l_int|2
suffix:semicolon
id|smi_info-&gt;handlers
op_member_access_from_pointer
id|start_transaction
c_func
(paren
id|smi_info-&gt;si_sm
comma
id|smi_info-&gt;curr_msg-&gt;data
comma
id|smi_info-&gt;curr_msg-&gt;data_size
)paren
suffix:semicolon
id|smi_info-&gt;si_state
op_assign
id|SI_GETTING_EVENTS
suffix:semicolon
)brace
r_else
(brace
id|smi_info-&gt;si_state
op_assign
id|SI_NORMAL
suffix:semicolon
)brace
)brace
DECL|function|handle_transaction_done
r_static
r_void
id|handle_transaction_done
c_func
(paren
r_struct
id|smi_info
op_star
id|smi_info
)paren
(brace
r_struct
id|ipmi_smi_msg
op_star
id|msg
suffix:semicolon
macro_line|#ifdef DEBUG_TIMING
r_struct
id|timeval
id|t
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
id|t
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;**Done: %d.%9.9d&bslash;n&quot;
comma
id|t.tv_sec
comma
id|t.tv_usec
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|smi_info-&gt;si_state
)paren
(brace
r_case
id|SI_NORMAL
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|smi_info-&gt;curr_msg
)paren
r_break
suffix:semicolon
id|smi_info-&gt;curr_msg-&gt;rsp_size
op_assign
id|smi_info-&gt;handlers
op_member_access_from_pointer
id|get_result
c_func
(paren
id|smi_info-&gt;si_sm
comma
id|smi_info-&gt;curr_msg-&gt;rsp
comma
id|IPMI_MAX_MSG_LENGTH
)paren
suffix:semicolon
multiline_comment|/* Do this here becase deliver_recv_msg() releases the&n;&t;&t;   lock, and a new message can be put in during the&n;&t;&t;   time the lock is released. */
id|msg
op_assign
id|smi_info-&gt;curr_msg
suffix:semicolon
id|smi_info-&gt;curr_msg
op_assign
l_int|NULL
suffix:semicolon
id|deliver_recv_msg
c_func
(paren
id|smi_info
comma
id|msg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SI_GETTING_FLAGS
suffix:colon
(brace
r_int
r_char
id|msg
(braket
l_int|4
)braket
suffix:semicolon
r_int
r_int
id|len
suffix:semicolon
multiline_comment|/* We got the flags from the SMI, now handle them. */
id|len
op_assign
id|smi_info-&gt;handlers
op_member_access_from_pointer
id|get_result
c_func
(paren
id|smi_info-&gt;si_sm
comma
id|msg
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg
(braket
l_int|2
)braket
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Error fetching flags, just give up for&n;&t;&t;&t;   now. */
id|smi_info-&gt;si_state
op_assign
id|SI_NORMAL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|len
OL
l_int|3
)paren
(brace
multiline_comment|/* Hmm, no flags.  That&squot;s technically illegal, but&n;&t;&t;&t;   don&squot;t use uninitialized data. */
id|smi_info-&gt;si_state
op_assign
id|SI_NORMAL
suffix:semicolon
)brace
r_else
(brace
id|smi_info-&gt;msg_flags
op_assign
id|msg
(braket
l_int|3
)braket
suffix:semicolon
id|handle_flags
c_func
(paren
id|smi_info
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_case
id|SI_CLEARING_FLAGS
suffix:colon
r_case
id|SI_CLEARING_FLAGS_THEN_SET_IRQ
suffix:colon
(brace
r_int
r_char
id|msg
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* We cleared the flags. */
id|smi_info-&gt;handlers
op_member_access_from_pointer
id|get_result
c_func
(paren
id|smi_info-&gt;si_sm
comma
id|msg
comma
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg
(braket
l_int|2
)braket
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Error clearing flags */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ipmi_si: Error clearing flags: %2.2x&bslash;n&quot;
comma
id|msg
(braket
l_int|2
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|smi_info-&gt;si_state
op_eq
id|SI_CLEARING_FLAGS_THEN_SET_IRQ
)paren
id|start_enable_irq
c_func
(paren
id|smi_info
)paren
suffix:semicolon
r_else
id|smi_info-&gt;si_state
op_assign
id|SI_NORMAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|SI_GETTING_EVENTS
suffix:colon
(brace
id|smi_info-&gt;curr_msg-&gt;rsp_size
op_assign
id|smi_info-&gt;handlers
op_member_access_from_pointer
id|get_result
c_func
(paren
id|smi_info-&gt;si_sm
comma
id|smi_info-&gt;curr_msg-&gt;rsp
comma
id|IPMI_MAX_MSG_LENGTH
)paren
suffix:semicolon
multiline_comment|/* Do this here becase deliver_recv_msg() releases the&n;&t;&t;   lock, and a new message can be put in during the&n;&t;&t;   time the lock is released. */
id|msg
op_assign
id|smi_info-&gt;curr_msg
suffix:semicolon
id|smi_info-&gt;curr_msg
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|msg-&gt;rsp
(braket
l_int|2
)braket
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Error getting event, probably done. */
id|msg
op_member_access_from_pointer
id|done
c_func
(paren
id|msg
)paren
suffix:semicolon
multiline_comment|/* Take off the event flag. */
id|smi_info-&gt;msg_flags
op_and_assign
op_complement
id|EVENT_MSG_BUFFER_FULL
suffix:semicolon
)brace
r_else
(brace
id|spin_lock
c_func
(paren
op_amp
id|smi_info-&gt;count_lock
)paren
suffix:semicolon
id|smi_info-&gt;events
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|smi_info-&gt;count_lock
)paren
suffix:semicolon
id|deliver_recv_msg
c_func
(paren
id|smi_info
comma
id|msg
)paren
suffix:semicolon
)brace
id|handle_flags
c_func
(paren
id|smi_info
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|SI_GETTING_MESSAGES
suffix:colon
(brace
id|smi_info-&gt;curr_msg-&gt;rsp_size
op_assign
id|smi_info-&gt;handlers
op_member_access_from_pointer
id|get_result
c_func
(paren
id|smi_info-&gt;si_sm
comma
id|smi_info-&gt;curr_msg-&gt;rsp
comma
id|IPMI_MAX_MSG_LENGTH
)paren
suffix:semicolon
multiline_comment|/* Do this here becase deliver_recv_msg() releases the&n;&t;&t;   lock, and a new message can be put in during the&n;&t;&t;   time the lock is released. */
id|msg
op_assign
id|smi_info-&gt;curr_msg
suffix:semicolon
id|smi_info-&gt;curr_msg
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|msg-&gt;rsp
(braket
l_int|2
)braket
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Error getting event, probably done. */
id|msg
op_member_access_from_pointer
id|done
c_func
(paren
id|msg
)paren
suffix:semicolon
multiline_comment|/* Take off the msg flag. */
id|smi_info-&gt;msg_flags
op_and_assign
op_complement
id|RECEIVE_MSG_AVAIL
suffix:semicolon
)brace
r_else
(brace
id|spin_lock
c_func
(paren
op_amp
id|smi_info-&gt;count_lock
)paren
suffix:semicolon
id|smi_info-&gt;incoming_messages
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|smi_info-&gt;count_lock
)paren
suffix:semicolon
id|deliver_recv_msg
c_func
(paren
id|smi_info
comma
id|msg
)paren
suffix:semicolon
)brace
id|handle_flags
c_func
(paren
id|smi_info
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|SI_ENABLE_INTERRUPTS1
suffix:colon
(brace
r_int
r_char
id|msg
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* We got the flags from the SMI, now handle them. */
id|smi_info-&gt;handlers
op_member_access_from_pointer
id|get_result
c_func
(paren
id|smi_info-&gt;si_sm
comma
id|msg
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg
(braket
l_int|2
)braket
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ipmi_si: Could not enable interrupts&quot;
l_string|&quot;, failed get, using polled mode.&bslash;n&quot;
)paren
suffix:semicolon
id|smi_info-&gt;si_state
op_assign
id|SI_NORMAL
suffix:semicolon
)brace
r_else
(brace
id|msg
(braket
l_int|0
)braket
op_assign
(paren
id|IPMI_NETFN_APP_REQUEST
op_lshift
l_int|2
)paren
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|IPMI_SET_BMC_GLOBAL_ENABLES_CMD
suffix:semicolon
id|msg
(braket
l_int|2
)braket
op_assign
id|msg
(braket
l_int|3
)braket
op_or
l_int|1
suffix:semicolon
multiline_comment|/* enable msg queue int */
id|smi_info-&gt;handlers
op_member_access_from_pointer
id|start_transaction
c_func
(paren
id|smi_info-&gt;si_sm
comma
id|msg
comma
l_int|3
)paren
suffix:semicolon
id|smi_info-&gt;si_state
op_assign
id|SI_ENABLE_INTERRUPTS2
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_case
id|SI_ENABLE_INTERRUPTS2
suffix:colon
(brace
r_int
r_char
id|msg
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* We got the flags from the SMI, now handle them. */
id|smi_info-&gt;handlers
op_member_access_from_pointer
id|get_result
c_func
(paren
id|smi_info-&gt;si_sm
comma
id|msg
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg
(braket
l_int|2
)braket
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ipmi_si: Could not enable interrupts&quot;
l_string|&quot;, failed set, using polled mode.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|smi_info-&gt;si_state
op_assign
id|SI_NORMAL
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Called on timeouts and events.  Timeouts should pass the elapsed&n;   time, interrupts should pass in zero. */
DECL|function|smi_event_handler
r_static
r_enum
id|si_sm_result
id|smi_event_handler
c_func
(paren
r_struct
id|smi_info
op_star
id|smi_info
comma
r_int
id|time
)paren
(brace
r_enum
id|si_sm_result
id|si_sm_result
suffix:semicolon
id|restart
suffix:colon
multiline_comment|/* There used to be a loop here that waited a little while&n;&t;   (around 25us) before giving up.  That turned out to be&n;&t;   pointless, the minimum delays I was seeing were in the 300us&n;&t;   range, which is far too long to wait in an interrupt.  So&n;&t;   we just run until the state machine tells us something&n;&t;   happened or it needs a delay. */
id|si_sm_result
op_assign
id|smi_info-&gt;handlers
op_member_access_from_pointer
id|event
c_func
(paren
id|smi_info-&gt;si_sm
comma
id|time
)paren
suffix:semicolon
id|time
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|si_sm_result
op_eq
id|SI_SM_CALL_WITHOUT_DELAY
)paren
(brace
id|si_sm_result
op_assign
id|smi_info-&gt;handlers
op_member_access_from_pointer
id|event
c_func
(paren
id|smi_info-&gt;si_sm
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|si_sm_result
op_eq
id|SI_SM_TRANSACTION_COMPLETE
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|smi_info-&gt;count_lock
)paren
suffix:semicolon
id|smi_info-&gt;complete_transactions
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|smi_info-&gt;count_lock
)paren
suffix:semicolon
id|handle_transaction_done
c_func
(paren
id|smi_info
)paren
suffix:semicolon
id|si_sm_result
op_assign
id|smi_info-&gt;handlers
op_member_access_from_pointer
id|event
c_func
(paren
id|smi_info-&gt;si_sm
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|si_sm_result
op_eq
id|SI_SM_HOSED
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|smi_info-&gt;count_lock
)paren
suffix:semicolon
id|smi_info-&gt;hosed_count
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|smi_info-&gt;count_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smi_info-&gt;curr_msg
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* If we were handling a user message, format&n;                           a response to send to the upper layer to&n;                           tell it about the error. */
id|return_hosed_msg
c_func
(paren
id|smi_info
)paren
suffix:semicolon
)brace
id|si_sm_result
op_assign
id|smi_info-&gt;handlers
op_member_access_from_pointer
id|event
c_func
(paren
id|smi_info-&gt;si_sm
comma
l_int|0
)paren
suffix:semicolon
id|smi_info-&gt;si_state
op_assign
id|SI_NORMAL
suffix:semicolon
)brace
multiline_comment|/* We prefer handling attn over new messages. */
r_if
c_cond
(paren
id|si_sm_result
op_eq
id|SI_SM_ATTN
)paren
(brace
r_int
r_char
id|msg
(braket
l_int|2
)braket
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|smi_info-&gt;count_lock
)paren
suffix:semicolon
id|smi_info-&gt;attentions
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|smi_info-&gt;count_lock
)paren
suffix:semicolon
multiline_comment|/* Got a attn, send down a get message flags to see&n;                   what&squot;s causing it.  It would be better to handle&n;                   this in the upper layer, but due to the way&n;                   interrupts work with the SMI, that&squot;s not really&n;                   possible. */
id|msg
(braket
l_int|0
)braket
op_assign
(paren
id|IPMI_NETFN_APP_REQUEST
op_lshift
l_int|2
)paren
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|IPMI_GET_MSG_FLAGS_CMD
suffix:semicolon
id|smi_info-&gt;handlers
op_member_access_from_pointer
id|start_transaction
c_func
(paren
id|smi_info-&gt;si_sm
comma
id|msg
comma
l_int|2
)paren
suffix:semicolon
id|smi_info-&gt;si_state
op_assign
id|SI_GETTING_FLAGS
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
multiline_comment|/* If we are currently idle, try to start the next message. */
r_if
c_cond
(paren
id|si_sm_result
op_eq
id|SI_SM_IDLE
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|smi_info-&gt;count_lock
)paren
suffix:semicolon
id|smi_info-&gt;idles
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|smi_info-&gt;count_lock
)paren
suffix:semicolon
id|si_sm_result
op_assign
id|start_next_msg
c_func
(paren
id|smi_info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|si_sm_result
op_ne
id|SI_SM_IDLE
)paren
r_goto
id|restart
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|si_sm_result
op_eq
id|SI_SM_IDLE
)paren
op_logical_and
(paren
id|atomic_read
c_func
(paren
op_amp
id|smi_info-&gt;req_events
)paren
)paren
)paren
(brace
multiline_comment|/* We are idle and the upper layer requested that I fetch&n;&t;&t;   events, so do so. */
r_int
r_char
id|msg
(braket
l_int|2
)braket
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|smi_info-&gt;count_lock
)paren
suffix:semicolon
id|smi_info-&gt;flag_fetches
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|smi_info-&gt;count_lock
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|smi_info-&gt;req_events
comma
l_int|0
)paren
suffix:semicolon
id|msg
(braket
l_int|0
)braket
op_assign
(paren
id|IPMI_NETFN_APP_REQUEST
op_lshift
l_int|2
)paren
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|IPMI_GET_MSG_FLAGS_CMD
suffix:semicolon
id|smi_info-&gt;handlers
op_member_access_from_pointer
id|start_transaction
c_func
(paren
id|smi_info-&gt;si_sm
comma
id|msg
comma
l_int|2
)paren
suffix:semicolon
id|smi_info-&gt;si_state
op_assign
id|SI_GETTING_FLAGS
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
r_return
id|si_sm_result
suffix:semicolon
)brace
DECL|function|sender
r_static
r_void
id|sender
c_func
(paren
r_void
op_star
id|send_info
comma
r_struct
id|ipmi_smi_msg
op_star
id|msg
comma
r_int
id|priority
)paren
(brace
r_struct
id|smi_info
op_star
id|smi_info
op_assign
id|send_info
suffix:semicolon
r_enum
id|si_sm_result
id|result
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG_TIMING
r_struct
id|timeval
id|t
suffix:semicolon
macro_line|#endif
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|smi_info-&gt;msg_lock
)paren
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_TIMING
id|do_gettimeofday
c_func
(paren
op_amp
id|t
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;**Enqueue: %d.%9.9d&bslash;n&quot;
comma
id|t.tv_sec
comma
id|t.tv_usec
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|smi_info-&gt;run_to_completion
)paren
(brace
multiline_comment|/* If we are running to completion, then throw it in&n;&t;&t;   the list and run transactions until everything is&n;&t;&t;   clear.  Priority doesn&squot;t matter here. */
id|list_add_tail
c_func
(paren
op_amp
(paren
id|msg-&gt;link
)paren
comma
op_amp
(paren
id|smi_info-&gt;xmit_msgs
)paren
)paren
suffix:semicolon
multiline_comment|/* We have to release the msg lock and claim the smi&n;&t;&t;   lock in this case, because of race conditions. */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|smi_info-&gt;msg_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|smi_info-&gt;si_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|result
op_assign
id|smi_event_handler
c_func
(paren
id|smi_info
comma
l_int|0
)paren
suffix:semicolon
r_while
c_loop
(paren
id|result
op_ne
id|SI_SM_IDLE
)paren
(brace
id|udelay
c_func
(paren
id|SI_SHORT_TIMEOUT_USEC
)paren
suffix:semicolon
id|result
op_assign
id|smi_event_handler
c_func
(paren
id|smi_info
comma
id|SI_SHORT_TIMEOUT_USEC
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|smi_info-&gt;si_lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|priority
OG
l_int|0
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
(paren
id|msg-&gt;link
)paren
comma
op_amp
(paren
id|smi_info-&gt;hp_xmit_msgs
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|list_add_tail
c_func
(paren
op_amp
(paren
id|msg-&gt;link
)paren
comma
op_amp
(paren
id|smi_info-&gt;xmit_msgs
)paren
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|smi_info-&gt;msg_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|smi_info-&gt;si_lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|smi_info-&gt;si_state
op_eq
id|SI_NORMAL
)paren
op_logical_and
(paren
id|smi_info-&gt;curr_msg
op_eq
l_int|NULL
)paren
)paren
(brace
id|start_next_msg
c_func
(paren
id|smi_info
)paren
suffix:semicolon
id|si_restart_short_timer
c_func
(paren
id|smi_info
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|smi_info-&gt;si_lock
)paren
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|set_run_to_completion
r_static
r_void
id|set_run_to_completion
c_func
(paren
r_void
op_star
id|send_info
comma
r_int
id|i_run_to_completion
)paren
(brace
r_struct
id|smi_info
op_star
id|smi_info
op_assign
id|send_info
suffix:semicolon
r_enum
id|si_sm_result
id|result
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|smi_info-&gt;si_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|smi_info-&gt;run_to_completion
op_assign
id|i_run_to_completion
suffix:semicolon
r_if
c_cond
(paren
id|i_run_to_completion
)paren
(brace
id|result
op_assign
id|smi_event_handler
c_func
(paren
id|smi_info
comma
l_int|0
)paren
suffix:semicolon
r_while
c_loop
(paren
id|result
op_ne
id|SI_SM_IDLE
)paren
(brace
id|udelay
c_func
(paren
id|SI_SHORT_TIMEOUT_USEC
)paren
suffix:semicolon
id|result
op_assign
id|smi_event_handler
c_func
(paren
id|smi_info
comma
id|SI_SHORT_TIMEOUT_USEC
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|smi_info-&gt;si_lock
)paren
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|poll
r_static
r_void
id|poll
c_func
(paren
r_void
op_star
id|send_info
)paren
(brace
r_struct
id|smi_info
op_star
id|smi_info
op_assign
id|send_info
suffix:semicolon
id|smi_event_handler
c_func
(paren
id|smi_info
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|request_events
r_static
r_void
id|request_events
c_func
(paren
r_void
op_star
id|send_info
)paren
(brace
r_struct
id|smi_info
op_star
id|smi_info
op_assign
id|send_info
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|smi_info-&gt;req_events
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|variable|initialized
r_static
r_int
id|initialized
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Must be called with interrupts off and with the si_lock held. */
DECL|function|si_restart_short_timer
r_static
r_void
id|si_restart_short_timer
c_func
(paren
r_struct
id|smi_info
op_star
id|smi_info
)paren
(brace
macro_line|#if defined(CONFIG_HIGH_RES_TIMERS)
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|jiffies_now
suffix:semicolon
r_if
c_cond
(paren
id|del_timer
c_func
(paren
op_amp
(paren
id|smi_info-&gt;si_timer
)paren
)paren
)paren
(brace
multiline_comment|/* If we don&squot;t delete the timer, then it will go off&n;&t;&t;   immediately, anyway.  So we only process if we&n;&t;&t;   actually delete the timer. */
multiline_comment|/* We already have irqsave on, so no need for it&n;                   here. */
id|read_lock
c_func
(paren
op_amp
id|xtime_lock
)paren
suffix:semicolon
id|jiffies_now
op_assign
id|jiffies
suffix:semicolon
id|smi_info-&gt;si_timer.expires
op_assign
id|jiffies_now
suffix:semicolon
id|smi_info-&gt;si_timer.sub_expires
op_assign
id|get_arch_cycles
c_func
(paren
id|jiffies_now
)paren
suffix:semicolon
id|add_usec_to_timer
c_func
(paren
op_amp
id|smi_info-&gt;si_timer
comma
id|SI_SHORT_TIMEOUT_USEC
)paren
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
(paren
id|smi_info-&gt;si_timer
)paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|smi_info-&gt;count_lock
comma
id|flags
)paren
suffix:semicolon
id|smi_info-&gt;timeout_restarts
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|smi_info-&gt;count_lock
comma
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
DECL|function|smi_timeout
r_static
r_void
id|smi_timeout
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|smi_info
op_star
id|smi_info
op_assign
(paren
r_struct
id|smi_info
op_star
)paren
id|data
suffix:semicolon
r_enum
id|si_sm_result
id|smi_result
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|jiffies_now
suffix:semicolon
r_int
r_int
id|time_diff
suffix:semicolon
macro_line|#ifdef DEBUG_TIMING
r_struct
id|timeval
id|t
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|smi_info-&gt;stop_operation
)paren
(brace
id|smi_info-&gt;timer_stopped
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|smi_info-&gt;si_lock
)paren
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_TIMING
id|do_gettimeofday
c_func
(paren
op_amp
id|t
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;**Timer: %d.%9.9d&bslash;n&quot;
comma
id|t.tv_sec
comma
id|t.tv_usec
)paren
suffix:semicolon
macro_line|#endif
id|jiffies_now
op_assign
id|jiffies
suffix:semicolon
id|time_diff
op_assign
(paren
(paren
id|jiffies_now
op_minus
id|smi_info-&gt;last_timeout_jiffies
)paren
op_star
id|SI_USEC_PER_JIFFY
)paren
suffix:semicolon
id|smi_result
op_assign
id|smi_event_handler
c_func
(paren
id|smi_info
comma
id|time_diff
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|smi_info-&gt;si_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|smi_info-&gt;last_timeout_jiffies
op_assign
id|jiffies_now
suffix:semicolon
r_if
c_cond
(paren
(paren
id|smi_info-&gt;irq
)paren
op_logical_and
(paren
op_logical_neg
id|smi_info-&gt;interrupt_disabled
)paren
)paren
(brace
multiline_comment|/* Running with interrupts, only do long timeouts. */
id|smi_info-&gt;si_timer.expires
op_assign
id|jiffies
op_plus
id|SI_TIMEOUT_JIFFIES
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|smi_info-&gt;count_lock
comma
id|flags
)paren
suffix:semicolon
id|smi_info-&gt;long_timeouts
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|smi_info-&gt;count_lock
comma
id|flags
)paren
suffix:semicolon
r_goto
id|do_add_timer
suffix:semicolon
)brace
multiline_comment|/* If the state machine asks for a short delay, then shorten&n;           the timer timeout. */
r_if
c_cond
(paren
id|smi_result
op_eq
id|SI_SM_CALL_WITH_DELAY
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|smi_info-&gt;count_lock
comma
id|flags
)paren
suffix:semicolon
id|smi_info-&gt;short_timeouts
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|smi_info-&gt;count_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_HIGH_RES_TIMERS)
id|read_lock
c_func
(paren
op_amp
id|xtime_lock
)paren
suffix:semicolon
id|smi_info-&gt;si_timer.expires
op_assign
id|jiffies
suffix:semicolon
id|smi_info-&gt;si_timer.sub_expires
op_assign
id|get_arch_cycles
c_func
(paren
id|smi_info-&gt;si_timer.expires
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|xtime_lock
)paren
suffix:semicolon
id|add_usec_to_timer
c_func
(paren
op_amp
id|smi_info-&gt;si_timer
comma
id|SI_SHORT_TIMEOUT_USEC
)paren
suffix:semicolon
macro_line|#else
id|smi_info-&gt;si_timer.expires
op_assign
id|jiffies
op_plus
l_int|1
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|smi_info-&gt;count_lock
comma
id|flags
)paren
suffix:semicolon
id|smi_info-&gt;long_timeouts
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|smi_info-&gt;count_lock
comma
id|flags
)paren
suffix:semicolon
id|smi_info-&gt;si_timer.expires
op_assign
id|jiffies
op_plus
id|SI_TIMEOUT_JIFFIES
suffix:semicolon
macro_line|#if defined(CONFIG_HIGH_RES_TIMERS)
id|smi_info-&gt;si_timer.sub_expires
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
)brace
id|do_add_timer
suffix:colon
id|add_timer
c_func
(paren
op_amp
(paren
id|smi_info-&gt;si_timer
)paren
)paren
suffix:semicolon
)brace
DECL|function|si_irq_handler
r_static
id|irqreturn_t
id|si_irq_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|data
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|smi_info
op_star
id|smi_info
op_assign
id|data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG_TIMING
r_struct
id|timeval
id|t
suffix:semicolon
macro_line|#endif
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|smi_info-&gt;si_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|smi_info-&gt;count_lock
)paren
suffix:semicolon
id|smi_info-&gt;interrupts
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|smi_info-&gt;count_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smi_info-&gt;stop_operation
)paren
r_goto
id|out
suffix:semicolon
macro_line|#ifdef DEBUG_TIMING
id|do_gettimeofday
c_func
(paren
op_amp
id|t
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;**Interrupt: %d.%9.9d&bslash;n&quot;
comma
id|t.tv_sec
comma
id|t.tv_usec
)paren
suffix:semicolon
macro_line|#endif
id|smi_event_handler
c_func
(paren
id|smi_info
comma
l_int|0
)paren
suffix:semicolon
id|out
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|smi_info-&gt;si_lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
DECL|variable|handlers
r_static
r_struct
id|ipmi_smi_handlers
id|handlers
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|sender
op_assign
id|sender
comma
dot
id|request_events
op_assign
id|request_events
comma
dot
id|set_run_to_completion
op_assign
id|set_run_to_completion
comma
dot
id|poll
op_assign
id|poll
comma
)brace
suffix:semicolon
multiline_comment|/* There can be 4 IO ports passed in (with or without IRQs), 4 addresses,&n;   a default IO port, and 1 ACPI/SPMI address.  That sets SI_MAX_DRIVERS */
DECL|macro|SI_MAX_PARMS
mdefine_line|#define SI_MAX_PARMS 4
DECL|macro|SI_MAX_DRIVERS
mdefine_line|#define SI_MAX_DRIVERS ((SI_MAX_PARMS * 2) + 2)
DECL|variable|smi_infos
r_static
r_struct
id|smi_info
op_star
id|smi_infos
(braket
id|SI_MAX_DRIVERS
)braket
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
DECL|macro|DEVICE_NAME
mdefine_line|#define DEVICE_NAME &quot;ipmi_si&quot;
DECL|macro|DEFAULT_KCS_IO_PORT
mdefine_line|#define DEFAULT_KCS_IO_PORT 0xca2
DECL|macro|DEFAULT_SMIC_IO_PORT
mdefine_line|#define DEFAULT_SMIC_IO_PORT 0xca9
DECL|macro|DEFAULT_BT_IO_PORT
mdefine_line|#define DEFAULT_BT_IO_PORT   0xe4
DECL|variable|si_trydefaults
r_static
r_int
id|si_trydefaults
op_assign
l_int|1
suffix:semicolon
DECL|variable|si_type
r_static
r_char
op_star
id|si_type
(braket
id|SI_MAX_PARMS
)braket
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
DECL|macro|MAX_SI_TYPE_STR
mdefine_line|#define MAX_SI_TYPE_STR 30
DECL|variable|si_type_str
r_static
r_char
id|si_type_str
(braket
id|MAX_SI_TYPE_STR
)braket
suffix:semicolon
DECL|variable|addrs
r_static
r_int
r_int
id|addrs
(braket
id|SI_MAX_PARMS
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|num_addrs
r_static
r_int
id|num_addrs
op_assign
l_int|0
suffix:semicolon
DECL|variable|ports
r_static
r_int
r_int
id|ports
(braket
id|SI_MAX_PARMS
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|num_ports
r_static
r_int
id|num_ports
op_assign
l_int|0
suffix:semicolon
DECL|variable|irqs
r_static
r_int
id|irqs
(braket
id|SI_MAX_PARMS
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|num_irqs
r_static
r_int
id|num_irqs
op_assign
l_int|0
suffix:semicolon
id|module_param_named
c_func
(paren
id|trydefaults
comma
id|si_trydefaults
comma
r_bool
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|trydefaults
comma
l_string|&quot;Setting this to &squot;false&squot; will disable the&quot;
l_string|&quot; default scan of the KCS and SMIC interface at the standard&quot;
l_string|&quot; address&quot;
)paren
suffix:semicolon
id|module_param_string
c_func
(paren
id|type
comma
id|si_type_str
comma
id|MAX_SI_TYPE_STR
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|type
comma
l_string|&quot;Defines the type of each interface, each&quot;
l_string|&quot; interface separated by commas.  The types are &squot;kcs&squot;,&quot;
l_string|&quot; &squot;smic&squot;, and &squot;bt&squot;.  For example si_type=kcs,bt will set&quot;
l_string|&quot; the first interface to kcs and the second to bt&quot;
)paren
suffix:semicolon
id|module_param_array
c_func
(paren
id|addrs
comma
r_int
comma
id|num_addrs
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|addrs
comma
l_string|&quot;Sets the memory address of each interface, the&quot;
l_string|&quot; addresses separated by commas.  Only use if an interface&quot;
l_string|&quot; is in memory.  Otherwise, set it to zero or leave&quot;
l_string|&quot; it blank.&quot;
)paren
suffix:semicolon
id|module_param_array
c_func
(paren
id|ports
comma
r_int
comma
id|num_ports
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|ports
comma
l_string|&quot;Sets the port address of each interface, the&quot;
l_string|&quot; addresses separated by commas.  Only use if an interface&quot;
l_string|&quot; is a port.  Otherwise, set it to zero or leave&quot;
l_string|&quot; it blank.&quot;
)paren
suffix:semicolon
id|module_param_array
c_func
(paren
id|irqs
comma
r_int
comma
id|num_irqs
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|irqs
comma
l_string|&quot;Sets the interrupt of each interface, the&quot;
l_string|&quot; addresses separated by commas.  Only use if an interface&quot;
l_string|&quot; has an interrupt.  Otherwise, set it to zero or leave&quot;
l_string|&quot; it blank.&quot;
)paren
suffix:semicolon
DECL|macro|IPMI_MEM_ADDR_SPACE
mdefine_line|#define IPMI_MEM_ADDR_SPACE 1
DECL|macro|IPMI_IO_ADDR_SPACE
mdefine_line|#define IPMI_IO_ADDR_SPACE  2
macro_line|#if defined(CONFIG_ACPI_INTERPETER) || defined(CONFIG_X86) || defined(CONFIG_PCI)
DECL|function|is_new_interface
r_static
r_int
id|is_new_interface
c_func
(paren
r_int
id|intf
comma
id|u8
id|addr_space
comma
r_int
r_int
id|base_addr
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SI_MAX_PARMS
suffix:semicolon
op_increment
id|i
)paren
(brace
multiline_comment|/* Don&squot;t check our address. */
r_if
c_cond
(paren
id|i
op_eq
id|intf
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|si_type
(braket
id|i
)braket
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|addr_space
op_eq
id|IPMI_MEM_ADDR_SPACE
op_logical_and
id|base_addr
op_eq
id|addrs
(braket
id|i
)braket
)paren
op_logical_or
(paren
id|addr_space
op_eq
id|IPMI_IO_ADDR_SPACE
op_logical_and
id|base_addr
op_eq
id|ports
(braket
id|i
)braket
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
DECL|function|std_irq_setup
r_static
r_int
id|std_irq_setup
c_func
(paren
r_struct
id|smi_info
op_star
id|info
)paren
(brace
r_int
id|rv
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;irq
)paren
r_return
l_int|0
suffix:semicolon
id|rv
op_assign
id|request_irq
c_func
(paren
id|info-&gt;irq
comma
id|si_irq_handler
comma
id|SA_INTERRUPT
comma
id|DEVICE_NAME
comma
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ipmi_si: %s unable to claim interrupt %d,&quot;
l_string|&quot; running polled&bslash;n&quot;
comma
id|DEVICE_NAME
comma
id|info-&gt;irq
)paren
suffix:semicolon
id|info-&gt;irq
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;  Using irq %d&bslash;n&quot;
comma
id|info-&gt;irq
)paren
suffix:semicolon
)brace
r_return
id|rv
suffix:semicolon
)brace
DECL|function|std_irq_cleanup
r_static
r_void
id|std_irq_cleanup
c_func
(paren
r_struct
id|smi_info
op_star
id|info
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;irq
)paren
r_return
suffix:semicolon
id|free_irq
c_func
(paren
id|info-&gt;irq
comma
id|info
)paren
suffix:semicolon
)brace
DECL|function|port_inb
r_static
r_int
r_char
id|port_inb
c_func
(paren
r_struct
id|si_sm_io
op_star
id|io
comma
r_int
r_int
id|offset
)paren
(brace
r_int
r_int
op_star
id|addr
op_assign
id|io-&gt;info
suffix:semicolon
r_return
id|inb
c_func
(paren
(paren
op_star
id|addr
)paren
op_plus
id|offset
)paren
suffix:semicolon
)brace
DECL|function|port_outb
r_static
r_void
id|port_outb
c_func
(paren
r_struct
id|si_sm_io
op_star
id|io
comma
r_int
r_int
id|offset
comma
r_int
r_char
id|b
)paren
(brace
r_int
r_int
op_star
id|addr
op_assign
id|io-&gt;info
suffix:semicolon
id|outb
c_func
(paren
id|b
comma
(paren
op_star
id|addr
)paren
op_plus
id|offset
)paren
suffix:semicolon
)brace
DECL|function|port_setup
r_static
r_int
id|port_setup
c_func
(paren
r_struct
id|smi_info
op_star
id|info
)paren
(brace
r_int
r_int
op_star
id|addr
op_assign
id|info-&gt;io.info
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
op_logical_or
(paren
op_logical_neg
op_star
id|addr
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|request_region
c_func
(paren
op_star
id|addr
comma
id|info-&gt;io_size
comma
id|DEVICE_NAME
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|port_cleanup
r_static
r_void
id|port_cleanup
c_func
(paren
r_struct
id|smi_info
op_star
id|info
)paren
(brace
r_int
r_int
op_star
id|addr
op_assign
id|info-&gt;io.info
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_logical_and
(paren
op_star
id|addr
)paren
)paren
id|release_region
(paren
op_star
id|addr
comma
id|info-&gt;io_size
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
DECL|function|try_init_port
r_static
r_int
id|try_init_port
c_func
(paren
r_int
id|intf_num
comma
r_struct
id|smi_info
op_star
op_star
id|new_info
)paren
(brace
r_struct
id|smi_info
op_star
id|info
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ports
(braket
id|intf_num
)braket
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_new_interface
c_func
(paren
id|intf_num
comma
id|IPMI_IO_ADDR_SPACE
comma
id|ports
(braket
id|intf_num
)braket
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|info
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ipmi_si: Could not allocate SI data (1)&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|info
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|info
)paren
)paren
suffix:semicolon
id|info-&gt;io_setup
op_assign
id|port_setup
suffix:semicolon
id|info-&gt;io_cleanup
op_assign
id|port_cleanup
suffix:semicolon
id|info-&gt;io.inputb
op_assign
id|port_inb
suffix:semicolon
id|info-&gt;io.outputb
op_assign
id|port_outb
suffix:semicolon
id|info-&gt;io.info
op_assign
op_amp
(paren
id|ports
(braket
id|intf_num
)braket
)paren
suffix:semicolon
id|info-&gt;io.addr
op_assign
l_int|NULL
suffix:semicolon
id|info-&gt;irq
op_assign
l_int|0
suffix:semicolon
id|info-&gt;irq_setup
op_assign
l_int|NULL
suffix:semicolon
op_star
id|new_info
op_assign
id|info
suffix:semicolon
r_if
c_cond
(paren
id|si_type
(braket
id|intf_num
)braket
op_eq
l_int|NULL
)paren
id|si_type
(braket
id|intf_num
)braket
op_assign
l_string|&quot;kcs&quot;
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ipmi_si: Trying &bslash;&quot;%s&bslash;&quot; at I/O port 0x%x&bslash;n&quot;
comma
id|si_type
(braket
id|intf_num
)braket
comma
id|ports
(braket
id|intf_num
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mem_inb
r_static
r_int
r_char
id|mem_inb
c_func
(paren
r_struct
id|si_sm_io
op_star
id|io
comma
r_int
r_int
id|offset
)paren
(brace
r_return
id|readb
c_func
(paren
(paren
id|io-&gt;addr
)paren
op_plus
id|offset
)paren
suffix:semicolon
)brace
DECL|function|mem_outb
r_static
r_void
id|mem_outb
c_func
(paren
r_struct
id|si_sm_io
op_star
id|io
comma
r_int
r_int
id|offset
comma
r_int
r_char
id|b
)paren
(brace
id|writeb
c_func
(paren
id|b
comma
(paren
id|io-&gt;addr
)paren
op_plus
id|offset
)paren
suffix:semicolon
)brace
DECL|function|mem_setup
r_static
r_int
id|mem_setup
c_func
(paren
r_struct
id|smi_info
op_star
id|info
)paren
(brace
r_int
r_int
op_star
id|addr
op_assign
id|info-&gt;io.info
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
op_logical_or
(paren
op_logical_neg
op_star
id|addr
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|request_mem_region
c_func
(paren
op_star
id|addr
comma
id|info-&gt;io_size
comma
id|DEVICE_NAME
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|info-&gt;io.addr
op_assign
id|ioremap
c_func
(paren
op_star
id|addr
comma
id|info-&gt;io_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;io.addr
op_eq
l_int|NULL
)paren
(brace
id|release_mem_region
c_func
(paren
op_star
id|addr
comma
id|info-&gt;io_size
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mem_cleanup
r_static
r_void
id|mem_cleanup
c_func
(paren
r_struct
id|smi_info
op_star
id|info
)paren
(brace
r_int
r_int
op_star
id|addr
op_assign
id|info-&gt;io.info
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;io.addr
)paren
(brace
id|iounmap
c_func
(paren
id|info-&gt;io.addr
)paren
suffix:semicolon
id|release_mem_region
c_func
(paren
op_star
id|addr
comma
id|info-&gt;io_size
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
DECL|function|try_init_mem
r_static
r_int
id|try_init_mem
c_func
(paren
r_int
id|intf_num
comma
r_struct
id|smi_info
op_star
op_star
id|new_info
)paren
(brace
r_struct
id|smi_info
op_star
id|info
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addrs
(braket
id|intf_num
)braket
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_new_interface
c_func
(paren
id|intf_num
comma
id|IPMI_MEM_ADDR_SPACE
comma
id|addrs
(braket
id|intf_num
)braket
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|info
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ipmi_si: Could not allocate SI data (2)&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|info
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|info
)paren
)paren
suffix:semicolon
id|info-&gt;io_setup
op_assign
id|mem_setup
suffix:semicolon
id|info-&gt;io_cleanup
op_assign
id|mem_cleanup
suffix:semicolon
id|info-&gt;io.inputb
op_assign
id|mem_inb
suffix:semicolon
id|info-&gt;io.outputb
op_assign
id|mem_outb
suffix:semicolon
id|info-&gt;io.info
op_assign
(paren
r_void
op_star
)paren
id|addrs
(braket
id|intf_num
)braket
suffix:semicolon
id|info-&gt;io.addr
op_assign
l_int|NULL
suffix:semicolon
id|info-&gt;irq
op_assign
l_int|0
suffix:semicolon
id|info-&gt;irq_setup
op_assign
l_int|NULL
suffix:semicolon
op_star
id|new_info
op_assign
id|info
suffix:semicolon
r_if
c_cond
(paren
id|si_type
(braket
id|intf_num
)braket
op_eq
l_int|NULL
)paren
id|si_type
(braket
id|intf_num
)braket
op_assign
l_string|&quot;kcs&quot;
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ipmi_si: Trying &bslash;&quot;%s&bslash;&quot; at memory address 0x%lx&bslash;n&quot;
comma
id|si_type
(braket
id|intf_num
)braket
comma
id|addrs
(braket
id|intf_num
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_ACPI_INTERPRETER
macro_line|#include &lt;linux/acpi.h&gt;
multiline_comment|/* Once we get an ACPI failure, we don&squot;t try any more, because we go&n;   through the tables sequentially.  Once we don&squot;t find a table, there&n;   are no more. */
DECL|variable|acpi_failure
r_static
r_int
id|acpi_failure
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* For GPE-type interrupts. */
DECL|function|ipmi_acpi_gpe
r_void
id|ipmi_acpi_gpe
c_func
(paren
r_void
op_star
id|context
)paren
(brace
r_struct
id|smi_info
op_star
id|smi_info
op_assign
id|context
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG_TIMING
r_struct
id|timeval
id|t
suffix:semicolon
macro_line|#endif
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|smi_info-&gt;si_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|smi_info-&gt;count_lock
)paren
suffix:semicolon
id|smi_info-&gt;interrupts
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|smi_info-&gt;count_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smi_info-&gt;stop_operation
)paren
r_goto
id|out
suffix:semicolon
macro_line|#ifdef DEBUG_TIMING
id|do_gettimeofday
c_func
(paren
op_amp
id|t
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;**ACPI_GPE: %d.%9.9d&bslash;n&quot;
comma
id|t.tv_sec
comma
id|t.tv_usec
)paren
suffix:semicolon
macro_line|#endif
id|smi_event_handler
c_func
(paren
id|smi_info
comma
l_int|0
)paren
suffix:semicolon
id|out
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|smi_info-&gt;si_lock
)paren
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|acpi_gpe_irq_setup
r_static
r_int
id|acpi_gpe_irq_setup
c_func
(paren
r_struct
id|smi_info
op_star
id|info
)paren
(brace
id|acpi_status
id|status
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;irq
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* FIXME - is level triggered right? */
id|status
op_assign
id|acpi_install_gpe_handler
c_func
(paren
l_int|NULL
comma
id|info-&gt;irq
comma
id|ACPI_GPE_LEVEL_TRIGGERED
comma
id|ipmi_acpi_gpe
comma
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
id|AE_OK
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ipmi_si: %s unable to claim ACPI GPE %d,&quot;
l_string|&quot; running polled&bslash;n&quot;
comma
id|DEVICE_NAME
comma
id|info-&gt;irq
)paren
suffix:semicolon
id|info-&gt;irq
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;  Using ACPI GPE %d&bslash;n&quot;
comma
id|info-&gt;irq
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|acpi_gpe_irq_cleanup
r_static
r_void
id|acpi_gpe_irq_cleanup
c_func
(paren
r_struct
id|smi_info
op_star
id|info
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;irq
)paren
r_return
suffix:semicolon
id|acpi_remove_gpe_handler
c_func
(paren
l_int|NULL
comma
id|info-&gt;irq
comma
id|ipmi_acpi_gpe
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Defined at&n; * http://h21007.www2.hp.com/dspp/files/unprotected/devresource/Docs/TechPapers/IA64/hpspmi.pdf&n; */
DECL|struct|SPMITable
r_struct
id|SPMITable
(brace
DECL|member|Signature
id|s8
id|Signature
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|Length
id|u32
id|Length
suffix:semicolon
DECL|member|Revision
id|u8
id|Revision
suffix:semicolon
DECL|member|Checksum
id|u8
id|Checksum
suffix:semicolon
DECL|member|OEMID
id|s8
id|OEMID
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|OEMTableID
id|s8
id|OEMTableID
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|OEMRevision
id|s8
id|OEMRevision
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|CreatorID
id|s8
id|CreatorID
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|CreatorRevision
id|s8
id|CreatorRevision
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|InterfaceType
id|u8
id|InterfaceType
suffix:semicolon
DECL|member|IPMIlegacy
id|u8
id|IPMIlegacy
suffix:semicolon
DECL|member|SpecificationRevision
id|s16
id|SpecificationRevision
suffix:semicolon
multiline_comment|/*&n;&t; * Bit 0 - SCI interrupt supported&n;&t; * Bit 1 - I/O APIC/SAPIC&n;&t; */
DECL|member|InterruptType
id|u8
id|InterruptType
suffix:semicolon
multiline_comment|/* If bit 0 of InterruptType is set, then this is the SCI&n;           interrupt in the GPEx_STS register. */
DECL|member|GPE
id|u8
id|GPE
suffix:semicolon
DECL|member|Reserved
id|s16
id|Reserved
suffix:semicolon
multiline_comment|/* If bit 1 of InterruptType is set, then this is the I/O&n;           APIC/SAPIC interrupt. */
DECL|member|GlobalSystemInterrupt
id|u32
id|GlobalSystemInterrupt
suffix:semicolon
multiline_comment|/* The actual register address. */
DECL|member|addr
r_struct
id|acpi_generic_address
id|addr
suffix:semicolon
DECL|member|UID
id|u8
id|UID
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|spmi_id
id|s8
id|spmi_id
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* A &squot;&bslash;0&squot; terminated array starts here. */
)brace
suffix:semicolon
DECL|function|try_init_acpi
r_static
r_int
id|try_init_acpi
c_func
(paren
r_int
id|intf_num
comma
r_struct
id|smi_info
op_star
op_star
id|new_info
)paren
(brace
r_struct
id|smi_info
op_star
id|info
suffix:semicolon
id|acpi_status
id|status
suffix:semicolon
r_struct
id|SPMITable
op_star
id|spmi
suffix:semicolon
r_char
op_star
id|io_type
suffix:semicolon
id|u8
id|addr_space
suffix:semicolon
r_if
c_cond
(paren
id|acpi_failure
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|status
op_assign
id|acpi_get_firmware_table
c_func
(paren
l_string|&quot;SPMI&quot;
comma
id|intf_num
op_plus
l_int|1
comma
id|ACPI_LOGICAL_ADDRESSING
comma
(paren
r_struct
id|acpi_table_header
op_star
op_star
)paren
op_amp
id|spmi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
id|AE_OK
)paren
(brace
id|acpi_failure
op_assign
l_int|1
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|spmi-&gt;IPMIlegacy
op_ne
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;IPMI: Bad SPMI legacy %d&bslash;n&quot;
comma
id|spmi-&gt;IPMIlegacy
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|spmi-&gt;addr.address_space_id
op_eq
id|ACPI_ADR_SPACE_SYSTEM_MEMORY
)paren
id|addr_space
op_assign
id|IPMI_MEM_ADDR_SPACE
suffix:semicolon
r_else
id|addr_space
op_assign
id|IPMI_IO_ADDR_SPACE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_new_interface
c_func
(paren
op_minus
l_int|1
comma
id|addr_space
comma
id|spmi-&gt;addr.address
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* Figure out the interface type. */
r_switch
c_cond
(paren
id|spmi-&gt;InterfaceType
)paren
(brace
r_case
l_int|1
suffix:colon
multiline_comment|/* KCS */
id|si_type
(braket
id|intf_num
)braket
op_assign
l_string|&quot;kcs&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* SMIC */
id|si_type
(braket
id|intf_num
)braket
op_assign
l_string|&quot;smic&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* BT */
id|si_type
(braket
id|intf_num
)braket
op_assign
l_string|&quot;bt&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ipmi_si: Unknown ACPI/SPMI SI type %d&bslash;n&quot;
comma
id|spmi-&gt;InterfaceType
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|info
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ipmi_si: Could not allocate SI data (3)&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|info
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|info
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|spmi-&gt;InterruptType
op_amp
l_int|1
)paren
(brace
multiline_comment|/* We&squot;ve got a GPE interrupt. */
id|info-&gt;irq
op_assign
id|spmi-&gt;GPE
suffix:semicolon
id|info-&gt;irq_setup
op_assign
id|acpi_gpe_irq_setup
suffix:semicolon
id|info-&gt;irq_cleanup
op_assign
id|acpi_gpe_irq_cleanup
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|spmi-&gt;InterruptType
op_amp
l_int|2
)paren
(brace
multiline_comment|/* We&squot;ve got an APIC/SAPIC interrupt. */
id|info-&gt;irq
op_assign
id|spmi-&gt;GlobalSystemInterrupt
suffix:semicolon
id|info-&gt;irq_setup
op_assign
id|std_irq_setup
suffix:semicolon
id|info-&gt;irq_cleanup
op_assign
id|std_irq_cleanup
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Use the default interrupt setting. */
id|info-&gt;irq
op_assign
l_int|0
suffix:semicolon
id|info-&gt;irq_setup
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|spmi-&gt;addr.address_space_id
op_eq
id|ACPI_ADR_SPACE_SYSTEM_MEMORY
)paren
(brace
id|io_type
op_assign
l_string|&quot;memory&quot;
suffix:semicolon
id|info-&gt;io_setup
op_assign
id|mem_setup
suffix:semicolon
id|info-&gt;io_cleanup
op_assign
id|mem_cleanup
suffix:semicolon
id|addrs
(braket
id|intf_num
)braket
op_assign
id|spmi-&gt;addr.address
suffix:semicolon
id|info-&gt;io.inputb
op_assign
id|mem_inb
suffix:semicolon
id|info-&gt;io.outputb
op_assign
id|mem_outb
suffix:semicolon
id|info-&gt;io.info
op_assign
op_amp
(paren
id|addrs
(braket
id|intf_num
)braket
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|spmi-&gt;addr.address_space_id
op_eq
id|ACPI_ADR_SPACE_SYSTEM_IO
)paren
(brace
id|io_type
op_assign
l_string|&quot;I/O&quot;
suffix:semicolon
id|info-&gt;io_setup
op_assign
id|port_setup
suffix:semicolon
id|info-&gt;io_cleanup
op_assign
id|port_cleanup
suffix:semicolon
id|ports
(braket
id|intf_num
)braket
op_assign
id|spmi-&gt;addr.address
suffix:semicolon
id|info-&gt;io.inputb
op_assign
id|port_inb
suffix:semicolon
id|info-&gt;io.outputb
op_assign
id|port_outb
suffix:semicolon
id|info-&gt;io.info
op_assign
op_amp
(paren
id|ports
(braket
id|intf_num
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|kfree
c_func
(paren
id|info
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ipmi_si: Unknown ACPI I/O Address type&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
op_star
id|new_info
op_assign
id|info
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ipmi_si: ACPI/SPMI specifies &bslash;&quot;%s&bslash;&quot; %s SI @ 0x%lx&bslash;n&quot;
comma
id|si_type
(braket
id|intf_num
)braket
comma
id|io_type
comma
(paren
r_int
r_int
)paren
id|spmi-&gt;addr.address
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_X86
DECL|struct|dmi_ipmi_data
r_typedef
r_struct
id|dmi_ipmi_data
(brace
DECL|member|type
id|u8
id|type
suffix:semicolon
DECL|member|addr_space
id|u8
id|addr_space
suffix:semicolon
DECL|member|base_addr
r_int
r_int
id|base_addr
suffix:semicolon
DECL|member|irq
id|u8
id|irq
suffix:semicolon
DECL|typedef|dmi_ipmi_data_t
)brace
id|dmi_ipmi_data_t
suffix:semicolon
DECL|struct|dmi_header
r_typedef
r_struct
id|dmi_header
(brace
DECL|member|type
id|u8
id|type
suffix:semicolon
DECL|member|length
id|u8
id|length
suffix:semicolon
DECL|member|handle
id|u16
id|handle
suffix:semicolon
DECL|typedef|dmi_header_t
)brace
id|dmi_header_t
suffix:semicolon
DECL|function|decode_dmi
r_static
r_int
id|decode_dmi
c_func
(paren
id|dmi_header_t
op_star
id|dm
comma
id|dmi_ipmi_data_t
op_star
id|ipmi_data
)paren
(brace
id|u8
op_star
id|data
op_assign
(paren
id|u8
op_star
)paren
id|dm
suffix:semicolon
r_int
r_int
id|base_addr
suffix:semicolon
id|ipmi_data-&gt;type
op_assign
id|data
(braket
l_int|0x04
)braket
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|base_addr
comma
op_amp
id|data
(braket
l_int|0x08
)braket
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base_addr
op_amp
l_int|1
)paren
(brace
multiline_comment|/* I/O */
id|base_addr
op_and_assign
l_int|0xFFFE
suffix:semicolon
id|ipmi_data-&gt;addr_space
op_assign
id|IPMI_IO_ADDR_SPACE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Memory */
id|ipmi_data-&gt;addr_space
op_assign
id|IPMI_MEM_ADDR_SPACE
suffix:semicolon
)brace
id|ipmi_data-&gt;base_addr
op_assign
id|base_addr
suffix:semicolon
id|ipmi_data-&gt;irq
op_assign
id|data
(braket
l_int|0x11
)braket
suffix:semicolon
r_if
c_cond
(paren
id|is_new_interface
c_func
(paren
op_minus
l_int|1
comma
id|ipmi_data-&gt;addr_space
comma
id|ipmi_data-&gt;base_addr
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|ipmi_data
comma
l_int|0
comma
r_sizeof
(paren
id|dmi_ipmi_data_t
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|dmi_table
r_static
r_int
id|dmi_table
c_func
(paren
id|u32
id|base
comma
r_int
id|len
comma
r_int
id|num
comma
id|dmi_ipmi_data_t
op_star
id|ipmi_data
)paren
(brace
id|u8
op_star
id|buf
suffix:semicolon
r_struct
id|dmi_header
op_star
id|dm
suffix:semicolon
id|u8
op_star
id|data
suffix:semicolon
r_int
id|i
op_assign
l_int|1
suffix:semicolon
r_int
id|status
op_assign
op_minus
l_int|1
suffix:semicolon
id|buf
op_assign
id|ioremap
c_func
(paren
id|base
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|data
op_assign
id|buf
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
id|num
op_logical_and
(paren
id|data
op_minus
id|buf
)paren
OL
id|len
)paren
(brace
id|dm
op_assign
(paren
id|dmi_header_t
op_star
)paren
id|data
suffix:semicolon
r_if
c_cond
(paren
(paren
id|data
op_minus
id|buf
op_plus
id|dm-&gt;length
)paren
op_ge
id|len
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dm-&gt;type
op_eq
l_int|38
)paren
(brace
r_if
c_cond
(paren
id|decode_dmi
c_func
(paren
id|dm
comma
id|ipmi_data
)paren
op_eq
l_int|0
)paren
(brace
id|status
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|data
op_add_assign
id|dm-&gt;length
suffix:semicolon
r_while
c_loop
(paren
(paren
id|data
op_minus
id|buf
)paren
OL
id|len
op_logical_and
(paren
op_star
id|data
op_logical_or
id|data
(braket
l_int|1
)braket
)paren
)paren
(brace
id|data
op_increment
suffix:semicolon
)brace
id|data
op_add_assign
l_int|2
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
id|iounmap
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
DECL|function|dmi_checksum
r_inline
r_static
r_int
id|dmi_checksum
c_func
(paren
id|u8
op_star
id|buf
)paren
(brace
id|u8
id|sum
op_assign
l_int|0
suffix:semicolon
r_int
id|a
suffix:semicolon
r_for
c_loop
(paren
id|a
op_assign
l_int|0
suffix:semicolon
id|a
OL
l_int|15
suffix:semicolon
id|a
op_increment
)paren
(brace
id|sum
op_add_assign
id|buf
(braket
id|a
)braket
suffix:semicolon
)brace
r_return
(paren
id|sum
op_eq
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|dmi_iterator
r_static
r_int
id|dmi_iterator
c_func
(paren
id|dmi_ipmi_data_t
op_star
id|ipmi_data
)paren
(brace
id|u8
id|buf
(braket
l_int|15
)braket
suffix:semicolon
id|u32
id|fp
op_assign
l_int|0xF0000
suffix:semicolon
macro_line|#ifdef CONFIG_SIMNOW
r_return
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
id|fp
OL
l_int|0xFFFFF
)paren
(brace
id|isa_memcpy_fromio
c_func
(paren
id|buf
comma
id|fp
comma
l_int|15
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|buf
comma
l_string|&quot;_DMI_&quot;
comma
l_int|5
)paren
op_eq
l_int|0
op_logical_and
id|dmi_checksum
c_func
(paren
id|buf
)paren
)paren
(brace
id|u16
id|num
op_assign
id|buf
(braket
l_int|13
)braket
op_lshift
l_int|8
op_or
id|buf
(braket
l_int|12
)braket
suffix:semicolon
id|u16
id|len
op_assign
id|buf
(braket
l_int|7
)braket
op_lshift
l_int|8
op_or
id|buf
(braket
l_int|6
)braket
suffix:semicolon
id|u32
id|base
op_assign
id|buf
(braket
l_int|11
)braket
op_lshift
l_int|24
op_or
id|buf
(braket
l_int|10
)braket
op_lshift
l_int|16
op_or
id|buf
(braket
l_int|9
)braket
op_lshift
l_int|8
op_or
id|buf
(braket
l_int|8
)braket
suffix:semicolon
r_if
c_cond
(paren
id|dmi_table
c_func
(paren
id|base
comma
id|len
comma
id|num
comma
id|ipmi_data
)paren
op_eq
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|fp
op_add_assign
l_int|16
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|try_init_smbios
r_static
r_int
id|try_init_smbios
c_func
(paren
r_int
id|intf_num
comma
r_struct
id|smi_info
op_star
op_star
id|new_info
)paren
(brace
r_struct
id|smi_info
op_star
id|info
suffix:semicolon
id|dmi_ipmi_data_t
id|ipmi_data
suffix:semicolon
r_char
op_star
id|io_type
suffix:semicolon
r_int
id|status
suffix:semicolon
id|status
op_assign
id|dmi_iterator
c_func
(paren
op_amp
id|ipmi_data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_switch
c_cond
(paren
id|ipmi_data.type
)paren
(brace
r_case
l_int|0x01
suffix:colon
multiline_comment|/* KCS */
id|si_type
(braket
id|intf_num
)braket
op_assign
l_string|&quot;kcs&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x02
suffix:colon
multiline_comment|/* SMIC */
id|si_type
(braket
id|intf_num
)braket
op_assign
l_string|&quot;smic&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x03
suffix:colon
multiline_comment|/* BT */
id|si_type
(braket
id|intf_num
)braket
op_assign
l_string|&quot;bt&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ipmi_si: Unknown SMBIOS SI type.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|info
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ipmi_si: Could not allocate SI data (4)&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|info
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|info
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ipmi_data.addr_space
op_eq
l_int|1
)paren
(brace
id|io_type
op_assign
l_string|&quot;memory&quot;
suffix:semicolon
id|info-&gt;io_setup
op_assign
id|mem_setup
suffix:semicolon
id|info-&gt;io_cleanup
op_assign
id|mem_cleanup
suffix:semicolon
id|addrs
(braket
id|intf_num
)braket
op_assign
id|ipmi_data.base_addr
suffix:semicolon
id|info-&gt;io.inputb
op_assign
id|mem_inb
suffix:semicolon
id|info-&gt;io.outputb
op_assign
id|mem_outb
suffix:semicolon
id|info-&gt;io.info
op_assign
op_amp
(paren
id|addrs
(braket
id|intf_num
)braket
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ipmi_data.addr_space
op_eq
l_int|2
)paren
(brace
id|io_type
op_assign
l_string|&quot;I/O&quot;
suffix:semicolon
id|info-&gt;io_setup
op_assign
id|port_setup
suffix:semicolon
id|info-&gt;io_cleanup
op_assign
id|port_cleanup
suffix:semicolon
id|ports
(braket
id|intf_num
)braket
op_assign
id|ipmi_data.base_addr
suffix:semicolon
id|info-&gt;io.inputb
op_assign
id|port_inb
suffix:semicolon
id|info-&gt;io.outputb
op_assign
id|port_outb
suffix:semicolon
id|info-&gt;io.info
op_assign
op_amp
(paren
id|ports
(braket
id|intf_num
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|kfree
c_func
(paren
id|info
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ipmi_si: Unknown SMBIOS I/O Address type.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|irqs
(braket
id|intf_num
)braket
op_assign
id|ipmi_data.irq
suffix:semicolon
op_star
id|new_info
op_assign
id|info
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ipmi_si: Found SMBIOS-specified state machine at %s&quot;
l_string|&quot; address 0x%lx&bslash;n&quot;
comma
id|io_type
comma
(paren
r_int
r_int
)paren
id|ipmi_data.base_addr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_X86 */
macro_line|#ifdef CONFIG_PCI
DECL|macro|PCI_ERMC_CLASSCODE
mdefine_line|#define PCI_ERMC_CLASSCODE  0x0C0700
DECL|macro|PCI_HP_VENDOR_ID
mdefine_line|#define PCI_HP_VENDOR_ID    0x103C
DECL|macro|PCI_MMC_DEVICE_ID
mdefine_line|#define PCI_MMC_DEVICE_ID   0x121A
DECL|macro|PCI_MMC_ADDR_CW
mdefine_line|#define PCI_MMC_ADDR_CW     0x10
multiline_comment|/* Avoid more than one attempt to probe pci smic. */
DECL|variable|pci_smic_checked
r_static
r_int
id|pci_smic_checked
op_assign
l_int|0
suffix:semicolon
DECL|function|find_pci_smic
r_static
r_int
id|find_pci_smic
c_func
(paren
r_int
id|intf_num
comma
r_struct
id|smi_info
op_star
op_star
id|new_info
)paren
(brace
r_struct
id|smi_info
op_star
id|info
suffix:semicolon
r_int
id|error
suffix:semicolon
r_struct
id|pci_dev
op_star
id|pci_dev
op_assign
l_int|NULL
suffix:semicolon
id|u16
id|base_addr
suffix:semicolon
r_int
id|fe_rmc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pci_smic_checked
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|pci_smic_checked
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pci_dev
op_assign
id|pci_find_device
c_func
(paren
id|PCI_HP_VENDOR_ID
comma
id|PCI_MMC_DEVICE_ID
comma
l_int|NULL
)paren
)paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|pci_dev
op_assign
id|pci_find_class
c_func
(paren
id|PCI_ERMC_CLASSCODE
comma
l_int|NULL
)paren
)paren
op_logical_and
id|pci_dev-&gt;subsystem_vendor
op_eq
id|PCI_HP_VENDOR_ID
)paren
id|fe_rmc
op_assign
l_int|1
suffix:semicolon
r_else
r_return
op_minus
id|ENODEV
suffix:semicolon
id|error
op_assign
id|pci_read_config_word
c_func
(paren
id|pci_dev
comma
id|PCI_MMC_ADDR_CW
comma
op_amp
id|base_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ipmi_si: pci_read_config_word() failed (%d).&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* Bit 0: 1 specifies programmed I/O, 0 specifies memory mapped I/O */
r_if
c_cond
(paren
op_logical_neg
(paren
id|base_addr
op_amp
l_int|0x0001
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ipmi_si: memory mapped I/O not supported for PCI&quot;
l_string|&quot; smic.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|base_addr
op_and_assign
l_int|0xFFFE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fe_rmc
)paren
multiline_comment|/* Data register starts at base address + 1 in eRMC */
op_increment
id|base_addr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_new_interface
c_func
(paren
op_minus
l_int|1
comma
id|IPMI_IO_ADDR_SPACE
comma
id|base_addr
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|info
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ipmi_si: Could not allocate SI data (5)&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|info
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|info
)paren
)paren
suffix:semicolon
id|info-&gt;io_setup
op_assign
id|port_setup
suffix:semicolon
id|info-&gt;io_cleanup
op_assign
id|port_cleanup
suffix:semicolon
id|ports
(braket
id|intf_num
)braket
op_assign
id|base_addr
suffix:semicolon
id|info-&gt;io.inputb
op_assign
id|port_inb
suffix:semicolon
id|info-&gt;io.outputb
op_assign
id|port_outb
suffix:semicolon
id|info-&gt;io.info
op_assign
op_amp
(paren
id|ports
(braket
id|intf_num
)braket
)paren
suffix:semicolon
op_star
id|new_info
op_assign
id|info
suffix:semicolon
id|irqs
(braket
id|intf_num
)braket
op_assign
id|pci_dev-&gt;irq
suffix:semicolon
id|si_type
(braket
id|intf_num
)braket
op_assign
l_string|&quot;smic&quot;
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ipmi_si: Found PCI SMIC at I/O address 0x%lx&bslash;n&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|base_addr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PCI */
DECL|function|try_init_plug_and_play
r_static
r_int
id|try_init_plug_and_play
c_func
(paren
r_int
id|intf_num
comma
r_struct
id|smi_info
op_star
op_star
id|new_info
)paren
(brace
macro_line|#ifdef CONFIG_PCI
r_if
c_cond
(paren
id|find_pci_smic
c_func
(paren
id|intf_num
comma
id|new_info
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/* Include other methods here. */
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|function|try_get_dev_id
r_static
r_int
id|try_get_dev_id
c_func
(paren
r_struct
id|smi_info
op_star
id|smi_info
)paren
(brace
r_int
r_char
id|msg
(braket
l_int|2
)braket
suffix:semicolon
r_int
r_char
op_star
id|resp
suffix:semicolon
r_int
r_int
id|resp_len
suffix:semicolon
r_enum
id|si_sm_result
id|smi_result
suffix:semicolon
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
id|resp
op_assign
id|kmalloc
c_func
(paren
id|IPMI_MAX_MSG_LENGTH
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|resp
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* Do a Get Device ID command, since it comes back with some&n;&t;   useful info. */
id|msg
(braket
l_int|0
)braket
op_assign
id|IPMI_NETFN_APP_REQUEST
op_lshift
l_int|2
suffix:semicolon
id|msg
(braket
l_int|1
)braket
op_assign
id|IPMI_GET_DEVICE_ID_CMD
suffix:semicolon
id|smi_info-&gt;handlers
op_member_access_from_pointer
id|start_transaction
c_func
(paren
id|smi_info-&gt;si_sm
comma
id|msg
comma
l_int|2
)paren
suffix:semicolon
id|smi_result
op_assign
id|smi_info-&gt;handlers
op_member_access_from_pointer
id|event
c_func
(paren
id|smi_info-&gt;si_sm
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|smi_result
op_eq
id|SI_SM_CALL_WITH_DELAY
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|smi_result
op_assign
id|smi_info-&gt;handlers
op_member_access_from_pointer
id|event
c_func
(paren
id|smi_info-&gt;si_sm
comma
l_int|100
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|smi_result
op_eq
id|SI_SM_CALL_WITHOUT_DELAY
)paren
(brace
id|smi_result
op_assign
id|smi_info-&gt;handlers
op_member_access_from_pointer
id|event
c_func
(paren
id|smi_info-&gt;si_sm
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|smi_result
op_eq
id|SI_SM_HOSED
)paren
(brace
multiline_comment|/* We couldn&squot;t get the state machine to run, so whatever&squot;s at&n;&t;&t;   the port is probably not an IPMI SMI interface. */
id|rv
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Otherwise, we got some data. */
id|resp_len
op_assign
id|smi_info-&gt;handlers
op_member_access_from_pointer
id|get_result
c_func
(paren
id|smi_info-&gt;si_sm
comma
id|resp
comma
id|IPMI_MAX_MSG_LENGTH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|resp_len
OL
l_int|6
)paren
(brace
multiline_comment|/* That&squot;s odd, it should be longer. */
id|rv
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|resp
(braket
l_int|1
)braket
op_ne
id|IPMI_GET_DEVICE_ID_CMD
)paren
op_logical_or
(paren
id|resp
(braket
l_int|2
)braket
op_ne
l_int|0
)paren
)paren
(brace
multiline_comment|/* That&squot;s odd, it shouldn&squot;t be able to fail. */
id|rv
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Record info from the get device id, in case we need it. */
id|smi_info-&gt;ipmi_si_dev_rev
op_assign
id|resp
(braket
l_int|4
)braket
op_amp
l_int|0xf
suffix:semicolon
id|smi_info-&gt;ipmi_si_fw_rev_major
op_assign
id|resp
(braket
l_int|5
)braket
op_amp
l_int|0x7f
suffix:semicolon
id|smi_info-&gt;ipmi_si_fw_rev_minor
op_assign
id|resp
(braket
l_int|6
)braket
suffix:semicolon
id|smi_info-&gt;ipmi_version_major
op_assign
id|resp
(braket
l_int|7
)braket
op_amp
l_int|0xf
suffix:semicolon
id|smi_info-&gt;ipmi_version_minor
op_assign
id|resp
(braket
l_int|7
)braket
op_rshift
l_int|4
suffix:semicolon
id|out
suffix:colon
id|kfree
c_func
(paren
id|resp
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
DECL|function|type_file_read_proc
r_static
r_int
id|type_file_read_proc
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_char
op_star
id|out
op_assign
(paren
r_char
op_star
)paren
id|page
suffix:semicolon
r_struct
id|smi_info
op_star
id|smi
op_assign
id|data
suffix:semicolon
r_switch
c_cond
(paren
id|smi-&gt;si_type
)paren
(brace
r_case
id|SI_KCS
suffix:colon
r_return
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;kcs&bslash;n&quot;
)paren
suffix:semicolon
r_case
id|SI_SMIC
suffix:colon
r_return
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;smic&bslash;n&quot;
)paren
suffix:semicolon
r_case
id|SI_BT
suffix:colon
r_return
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;bt&bslash;n&quot;
)paren
suffix:semicolon
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|stat_file_read_proc
r_static
r_int
id|stat_file_read_proc
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_char
op_star
id|out
op_assign
(paren
r_char
op_star
)paren
id|page
suffix:semicolon
r_struct
id|smi_info
op_star
id|smi
op_assign
id|data
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;interrupts_enabled:    %d&bslash;n&quot;
comma
id|smi-&gt;irq
op_logical_and
op_logical_neg
id|smi-&gt;interrupt_disabled
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;short_timeouts:        %ld&bslash;n&quot;
comma
id|smi-&gt;short_timeouts
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;long_timeouts:         %ld&bslash;n&quot;
comma
id|smi-&gt;long_timeouts
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;timeout_restarts:      %ld&bslash;n&quot;
comma
id|smi-&gt;timeout_restarts
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;idles:                 %ld&bslash;n&quot;
comma
id|smi-&gt;idles
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;interrupts:            %ld&bslash;n&quot;
comma
id|smi-&gt;interrupts
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;attentions:            %ld&bslash;n&quot;
comma
id|smi-&gt;attentions
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;flag_fetches:          %ld&bslash;n&quot;
comma
id|smi-&gt;flag_fetches
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;hosed_count:           %ld&bslash;n&quot;
comma
id|smi-&gt;hosed_count
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;complete_transactions: %ld&bslash;n&quot;
comma
id|smi-&gt;complete_transactions
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;events:                %ld&bslash;n&quot;
comma
id|smi-&gt;events
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;watchdog_pretimeouts:  %ld&bslash;n&quot;
comma
id|smi-&gt;watchdog_pretimeouts
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;incoming_messages:     %ld&bslash;n&quot;
comma
id|smi-&gt;incoming_messages
)paren
suffix:semicolon
r_return
(paren
id|out
op_minus
(paren
(paren
r_char
op_star
)paren
id|page
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Returns 0 if initialized, or negative on an error. */
DECL|function|init_one_smi
r_static
r_int
id|init_one_smi
c_func
(paren
r_int
id|intf_num
comma
r_struct
id|smi_info
op_star
op_star
id|smi
)paren
(brace
r_int
id|rv
suffix:semicolon
r_struct
id|smi_info
op_star
id|new_smi
suffix:semicolon
id|rv
op_assign
id|try_init_mem
c_func
(paren
id|intf_num
comma
op_amp
id|new_smi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
id|rv
op_assign
id|try_init_port
c_func
(paren
id|intf_num
comma
op_amp
id|new_smi
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_ACPI_INTERPRETER
r_if
c_cond
(paren
(paren
id|rv
)paren
op_logical_and
(paren
id|si_trydefaults
)paren
)paren
(brace
id|rv
op_assign
id|try_init_acpi
c_func
(paren
id|intf_num
comma
op_amp
id|new_smi
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_X86
r_if
c_cond
(paren
(paren
id|rv
)paren
op_logical_and
(paren
id|si_trydefaults
)paren
)paren
(brace
id|rv
op_assign
id|try_init_smbios
c_func
(paren
id|intf_num
comma
op_amp
id|new_smi
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
(paren
id|rv
)paren
op_logical_and
(paren
id|si_trydefaults
)paren
)paren
(brace
id|rv
op_assign
id|try_init_plug_and_play
c_func
(paren
id|intf_num
comma
op_amp
id|new_smi
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rv
)paren
r_return
id|rv
suffix:semicolon
multiline_comment|/* So we know not to free it unless we have allocated one. */
id|new_smi-&gt;intf
op_assign
l_int|NULL
suffix:semicolon
id|new_smi-&gt;si_sm
op_assign
l_int|NULL
suffix:semicolon
id|new_smi-&gt;handlers
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_smi-&gt;irq_setup
)paren
(brace
id|new_smi-&gt;irq
op_assign
id|irqs
(braket
id|intf_num
)braket
suffix:semicolon
id|new_smi-&gt;irq_setup
op_assign
id|std_irq_setup
suffix:semicolon
id|new_smi-&gt;irq_cleanup
op_assign
id|std_irq_cleanup
suffix:semicolon
)brace
multiline_comment|/* Default to KCS if no type is specified. */
r_if
c_cond
(paren
id|si_type
(braket
id|intf_num
)braket
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|si_trydefaults
)paren
id|si_type
(braket
id|intf_num
)braket
op_assign
l_string|&quot;kcs&quot;
suffix:semicolon
r_else
(brace
id|rv
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
)brace
multiline_comment|/* Set up the state machine to use. */
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|si_type
(braket
id|intf_num
)braket
comma
l_string|&quot;kcs&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|new_smi-&gt;handlers
op_assign
op_amp
id|kcs_smi_handlers
suffix:semicolon
id|new_smi-&gt;si_type
op_assign
id|SI_KCS
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|si_type
(braket
id|intf_num
)braket
comma
l_string|&quot;smic&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|new_smi-&gt;handlers
op_assign
op_amp
id|smic_smi_handlers
suffix:semicolon
id|new_smi-&gt;si_type
op_assign
id|SI_SMIC
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|si_type
(braket
id|intf_num
)braket
comma
l_string|&quot;bt&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|new_smi-&gt;handlers
op_assign
op_amp
id|bt_smi_handlers
suffix:semicolon
id|new_smi-&gt;si_type
op_assign
id|SI_BT
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* No support for anything else yet. */
id|rv
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
multiline_comment|/* Allocate the state machine&squot;s data and initialize it. */
id|new_smi-&gt;si_sm
op_assign
id|kmalloc
c_func
(paren
id|new_smi-&gt;handlers
op_member_access_from_pointer
id|size
c_func
(paren
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_smi-&gt;si_sm
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; Could not allocate state machine memory&bslash;n&quot;
)paren
suffix:semicolon
id|rv
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
id|new_smi-&gt;io_size
op_assign
id|new_smi-&gt;handlers
op_member_access_from_pointer
id|init_data
c_func
(paren
id|new_smi-&gt;si_sm
comma
op_amp
id|new_smi-&gt;io
)paren
suffix:semicolon
multiline_comment|/* Now that we know the I/O size, we can set up the I/O. */
id|rv
op_assign
id|new_smi
op_member_access_from_pointer
id|io_setup
c_func
(paren
id|new_smi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; Could not set up I/O space&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
id|spin_lock_init
c_func
(paren
op_amp
(paren
id|new_smi-&gt;si_lock
)paren
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
(paren
id|new_smi-&gt;msg_lock
)paren
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
(paren
id|new_smi-&gt;count_lock
)paren
)paren
suffix:semicolon
multiline_comment|/* Do low-level detection first. */
r_if
c_cond
(paren
id|new_smi-&gt;handlers
op_member_access_from_pointer
id|detect
c_func
(paren
id|new_smi-&gt;si_sm
)paren
)paren
(brace
id|rv
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
multiline_comment|/* Attempt a get device id command.  If it fails, we probably&n;           don&squot;t have a SMI here. */
id|rv
op_assign
id|try_get_dev_id
c_func
(paren
id|new_smi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
r_goto
id|out_err
suffix:semicolon
multiline_comment|/* Try to claim any interrupts. */
id|new_smi
op_member_access_from_pointer
id|irq_setup
c_func
(paren
id|new_smi
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
(paren
id|new_smi-&gt;xmit_msgs
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
(paren
id|new_smi-&gt;hp_xmit_msgs
)paren
)paren
suffix:semicolon
id|new_smi-&gt;curr_msg
op_assign
l_int|NULL
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|new_smi-&gt;req_events
comma
l_int|0
)paren
suffix:semicolon
id|new_smi-&gt;run_to_completion
op_assign
l_int|0
suffix:semicolon
id|new_smi-&gt;interrupt_disabled
op_assign
l_int|0
suffix:semicolon
id|new_smi-&gt;timer_stopped
op_assign
l_int|0
suffix:semicolon
id|new_smi-&gt;stop_operation
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* The ipmi_register_smi() code does some operations to&n;&t;   determine the channel information, so we must be ready to&n;&t;   handle operations before it is called.  This means we have&n;&t;   to stop the timer if we get an error after this point. */
id|init_timer
c_func
(paren
op_amp
(paren
id|new_smi-&gt;si_timer
)paren
)paren
suffix:semicolon
id|new_smi-&gt;si_timer.data
op_assign
(paren
r_int
)paren
id|new_smi
suffix:semicolon
id|new_smi-&gt;si_timer.function
op_assign
id|smi_timeout
suffix:semicolon
id|new_smi-&gt;last_timeout_jiffies
op_assign
id|jiffies
suffix:semicolon
id|new_smi-&gt;si_timer.expires
op_assign
id|jiffies
op_plus
id|SI_TIMEOUT_JIFFIES
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
(paren
id|new_smi-&gt;si_timer
)paren
)paren
suffix:semicolon
id|rv
op_assign
id|ipmi_register_smi
c_func
(paren
op_amp
id|handlers
comma
id|new_smi
comma
id|new_smi-&gt;ipmi_version_major
comma
id|new_smi-&gt;ipmi_version_minor
comma
op_amp
(paren
id|new_smi-&gt;intf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ipmi_si: Unable to register device: error %d&bslash;n&quot;
comma
id|rv
)paren
suffix:semicolon
r_goto
id|out_err_stop_timer
suffix:semicolon
)brace
id|rv
op_assign
id|ipmi_smi_add_proc_entry
c_func
(paren
id|new_smi-&gt;intf
comma
l_string|&quot;type&quot;
comma
id|type_file_read_proc
comma
l_int|NULL
comma
id|new_smi
comma
id|THIS_MODULE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ipmi_si: Unable to create proc entry: %d&bslash;n&quot;
comma
id|rv
)paren
suffix:semicolon
r_goto
id|out_err_stop_timer
suffix:semicolon
)brace
id|rv
op_assign
id|ipmi_smi_add_proc_entry
c_func
(paren
id|new_smi-&gt;intf
comma
l_string|&quot;si_stats&quot;
comma
id|stat_file_read_proc
comma
l_int|NULL
comma
id|new_smi
comma
id|THIS_MODULE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ipmi_si: Unable to create proc entry: %d&bslash;n&quot;
comma
id|rv
)paren
suffix:semicolon
r_goto
id|out_err_stop_timer
suffix:semicolon
)brace
id|start_clear_flags
c_func
(paren
id|new_smi
)paren
suffix:semicolon
multiline_comment|/* IRQ is defined to be set when non-zero. */
r_if
c_cond
(paren
id|new_smi-&gt;irq
)paren
id|new_smi-&gt;si_state
op_assign
id|SI_CLEARING_FLAGS_THEN_SET_IRQ
suffix:semicolon
op_star
id|smi
op_assign
id|new_smi
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; IPMI %s interface initialized&bslash;n&quot;
comma
id|si_type
(braket
id|intf_num
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_err_stop_timer
suffix:colon
id|new_smi-&gt;stop_operation
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Wait for the timer to stop.  This avoids problems with race&n;&t;   conditions removing the timer here. */
r_while
c_loop
(paren
op_logical_neg
id|new_smi-&gt;timer_stopped
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|out_err
suffix:colon
r_if
c_cond
(paren
id|new_smi-&gt;intf
)paren
id|ipmi_unregister_smi
c_func
(paren
id|new_smi-&gt;intf
)paren
suffix:semicolon
id|new_smi
op_member_access_from_pointer
id|irq_cleanup
c_func
(paren
id|new_smi
)paren
suffix:semicolon
multiline_comment|/* Wait until we know that we are out of any interrupt&n;&t;   handlers might have been running before we freed the&n;&t;   interrupt. */
id|synchronize_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_smi-&gt;si_sm
)paren
(brace
r_if
c_cond
(paren
id|new_smi-&gt;handlers
)paren
id|new_smi-&gt;handlers
op_member_access_from_pointer
id|cleanup
c_func
(paren
id|new_smi-&gt;si_sm
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|new_smi-&gt;si_sm
)paren
suffix:semicolon
)brace
id|new_smi
op_member_access_from_pointer
id|io_cleanup
c_func
(paren
id|new_smi
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
DECL|function|init_ipmi_si
r_static
id|__init
r_int
id|init_ipmi_si
c_func
(paren
r_void
)paren
(brace
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
r_int
id|pos
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_char
op_star
id|str
suffix:semicolon
r_if
c_cond
(paren
id|initialized
)paren
r_return
l_int|0
suffix:semicolon
id|initialized
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Parse out the si_type string into its components. */
id|str
op_assign
id|si_type_str
suffix:semicolon
r_if
c_cond
(paren
op_star
id|str
op_ne
l_char|&squot;&bslash;0&squot;
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
id|SI_MAX_PARMS
)paren
op_logical_and
(paren
op_star
id|str
op_ne
l_char|&squot;&bslash;0&squot;
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|si_type
(braket
id|i
)braket
op_assign
id|str
suffix:semicolon
id|str
op_assign
id|strchr
c_func
(paren
id|str
comma
l_char|&squot;,&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|str
)paren
(brace
op_star
id|str
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|str
op_increment
suffix:semicolon
)brace
r_else
(brace
r_break
suffix:semicolon
)brace
)brace
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;IPMI System Interface driver version &quot;
id|IPMI_SI_VERSION
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kcs_smi_handlers.version
)paren
id|printk
c_func
(paren
l_string|&quot;, KCS version %s&quot;
comma
id|kcs_smi_handlers.version
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smic_smi_handlers.version
)paren
id|printk
c_func
(paren
l_string|&quot;, SMIC version %s&quot;
comma
id|smic_smi_handlers.version
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bt_smi_handlers.version
)paren
id|printk
c_func
(paren
l_string|&quot;, BT version %s&quot;
comma
id|bt_smi_handlers.version
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|rv
op_assign
id|init_one_smi
c_func
(paren
l_int|0
comma
op_amp
(paren
id|smi_infos
(braket
id|pos
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
op_logical_and
op_logical_neg
id|ports
(braket
l_int|0
)braket
op_logical_and
id|si_trydefaults
)paren
(brace
multiline_comment|/* If we are trying defaults and the initial port is&n;                   not set, then set it. */
id|si_type
(braket
l_int|0
)braket
op_assign
l_string|&quot;kcs&quot;
suffix:semicolon
id|ports
(braket
l_int|0
)braket
op_assign
id|DEFAULT_KCS_IO_PORT
suffix:semicolon
id|rv
op_assign
id|init_one_smi
c_func
(paren
l_int|0
comma
op_amp
(paren
id|smi_infos
(braket
id|pos
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
(brace
multiline_comment|/* No KCS - try SMIC */
id|si_type
(braket
l_int|0
)braket
op_assign
l_string|&quot;smic&quot;
suffix:semicolon
id|ports
(braket
l_int|0
)braket
op_assign
id|DEFAULT_SMIC_IO_PORT
suffix:semicolon
id|rv
op_assign
id|init_one_smi
c_func
(paren
l_int|0
comma
op_amp
(paren
id|smi_infos
(braket
id|pos
)braket
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rv
)paren
(brace
multiline_comment|/* No SMIC - try BT */
id|si_type
(braket
l_int|0
)braket
op_assign
l_string|&quot;bt&quot;
suffix:semicolon
id|ports
(braket
l_int|0
)braket
op_assign
id|DEFAULT_BT_IO_PORT
suffix:semicolon
id|rv
op_assign
id|init_one_smi
c_func
(paren
l_int|0
comma
op_amp
(paren
id|smi_infos
(braket
id|pos
)braket
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rv
op_eq
l_int|0
)paren
id|pos
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|SI_MAX_PARMS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|rv
op_assign
id|init_one_smi
c_func
(paren
id|i
comma
op_amp
(paren
id|smi_infos
(braket
id|pos
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
op_eq
l_int|0
)paren
id|pos
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|smi_infos
(braket
l_int|0
)braket
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ipmi_si: Unable to find any System Interface(s)&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|init_ipmi_si
id|module_init
c_func
(paren
id|init_ipmi_si
)paren
suffix:semicolon
DECL|function|cleanup_one_si
r_void
id|__exit
id|cleanup_one_si
c_func
(paren
r_struct
id|smi_info
op_star
id|to_clean
)paren
(brace
r_int
id|rv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|to_clean
)paren
r_return
suffix:semicolon
multiline_comment|/* Tell the timer and interrupt handlers that we are shutting&n;&t;   down. */
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|to_clean-&gt;si_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
(paren
id|to_clean-&gt;msg_lock
)paren
)paren
suffix:semicolon
id|to_clean-&gt;stop_operation
op_assign
l_int|1
suffix:semicolon
id|to_clean
op_member_access_from_pointer
id|irq_cleanup
c_func
(paren
id|to_clean
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
(paren
id|to_clean-&gt;msg_lock
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|to_clean-&gt;si_lock
)paren
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Wait until we know that we are out of any interrupt&n;&t;   handlers might have been running before we freed the&n;&t;   interrupt. */
id|synchronize_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Wait for the timer to stop.  This avoids problems with race&n;&t;   conditions removing the timer here. */
r_while
c_loop
(paren
op_logical_neg
id|to_clean-&gt;timer_stopped
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|rv
op_assign
id|ipmi_unregister_smi
c_func
(paren
id|to_clean-&gt;intf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ipmi_si: Unable to unregister device: errno=%d&bslash;n&quot;
comma
id|rv
)paren
suffix:semicolon
)brace
id|to_clean-&gt;handlers
op_member_access_from_pointer
id|cleanup
c_func
(paren
id|to_clean-&gt;si_sm
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|to_clean-&gt;si_sm
)paren
suffix:semicolon
id|to_clean
op_member_access_from_pointer
id|io_cleanup
c_func
(paren
id|to_clean
)paren
suffix:semicolon
)brace
DECL|function|cleanup_ipmi_si
r_static
id|__exit
r_void
id|cleanup_ipmi_si
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|initialized
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SI_MAX_DRIVERS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cleanup_one_si
c_func
(paren
id|smi_infos
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
DECL|variable|cleanup_ipmi_si
id|module_exit
c_func
(paren
id|cleanup_ipmi_si
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
