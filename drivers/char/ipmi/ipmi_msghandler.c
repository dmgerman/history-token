multiline_comment|/*&n; * ipmi_msghandler.c&n; *&n; * Incoming and outgoing message routing for an IPMI interface.&n; *&n; * Author: MontaVista Software, Inc.&n; *         Corey Minyard &lt;minyard@mvista.com&gt;&n; *         source@mvista.com&n; *&n; * Copyright 2002 MontaVista Software Inc.&n; *&n; *  This program is free software; you can redistribute it and/or modify it&n; *  under the terms of the GNU General Public License as published by the&n; *  Free Software Foundation; either version 2 of the License, or (at your&n; *  option) any later version.&n; *&n; *&n; *  THIS SOFTWARE IS PROVIDED ``AS IS&squot;&squot; AND ANY EXPRESS OR IMPLIED&n; *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&n; *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.&n; *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,&n; *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,&n; *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS&n; *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND&n; *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR&n; *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE&n; *  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n; *&n; *  You should have received a copy of the GNU General Public License along&n; *  with this program; if not, write to the Free Software Foundation, Inc.,&n; *  675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/rwsem.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/ipmi.h&gt;
macro_line|#include &lt;linux/ipmi_smi.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;linux/init.h&gt;
r_struct
id|ipmi_recv_msg
op_star
id|ipmi_alloc_recv_msg
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|ipmi_init_msghandler
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|initialized
r_static
r_int
id|initialized
op_assign
l_int|0
suffix:semicolon
DECL|macro|MAX_EVENTS_IN_QUEUE
mdefine_line|#define MAX_EVENTS_IN_QUEUE&t;25
multiline_comment|/* Don&squot;t let a message sit in a queue forever, always time it with at lest&n;   the max message timer. */
DECL|macro|MAX_MSG_TIMEOUT
mdefine_line|#define MAX_MSG_TIMEOUT&t;&t;60000
DECL|struct|ipmi_user
r_struct
id|ipmi_user
(brace
DECL|member|link
r_struct
id|list_head
id|link
suffix:semicolon
multiline_comment|/* The upper layer that handles receive messages. */
DECL|member|handler
r_struct
id|ipmi_user_hndl
op_star
id|handler
suffix:semicolon
DECL|member|handler_data
r_void
op_star
id|handler_data
suffix:semicolon
multiline_comment|/* The interface this user is bound to. */
DECL|member|intf
id|ipmi_smi_t
id|intf
suffix:semicolon
multiline_comment|/* Does this interface receive IPMI events? */
DECL|member|gets_events
r_int
id|gets_events
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|cmd_rcvr
r_struct
id|cmd_rcvr
(brace
DECL|member|link
r_struct
id|list_head
id|link
suffix:semicolon
DECL|member|user
id|ipmi_user_t
id|user
suffix:semicolon
DECL|member|netfn
r_int
r_char
id|netfn
suffix:semicolon
DECL|member|cmd
r_int
r_char
id|cmd
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|seq_table
r_struct
id|seq_table
(brace
DECL|member|inuse
r_int
id|inuse
suffix:colon
l_int|1
suffix:semicolon
DECL|member|timeout
r_int
r_int
id|timeout
suffix:semicolon
DECL|member|orig_timeout
r_int
r_int
id|orig_timeout
suffix:semicolon
DECL|member|retries_left
r_int
r_int
id|retries_left
suffix:semicolon
multiline_comment|/* To verify on an incoming send message response that this is&n;           the message that the response is for, we keep a sequence id&n;           and increment it every time we send a message. */
DECL|member|seqid
r_int
id|seqid
suffix:semicolon
multiline_comment|/* This is held so we can properly respond to the message on a&n;           timeout, and it is used to hold the temporary data for&n;           retransmission, too. */
DECL|member|recv_msg
r_struct
id|ipmi_recv_msg
op_star
id|recv_msg
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Store the information in a msgid (long) to allow us to find a&n;   sequence table entry from the msgid. */
DECL|macro|STORE_SEQ_IN_MSGID
mdefine_line|#define STORE_SEQ_IN_MSGID(seq, seqid) (((seq&amp;0xff)&lt;&lt;26) | (seqid&amp;0x3ffffff))
DECL|macro|GET_SEQ_FROM_MSGID
mdefine_line|#define GET_SEQ_FROM_MSGID(msgid, seq, seqid) &bslash;&n;&t;do {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;seq = ((msgid &gt;&gt; 26) &amp; 0x3f);&t;&t;&t;&t;&bslash;&n;&t;&t;seqid = (msgid &amp; 0x3fffff);&t;&t;&t;&t;&bslash;&n;        } while(0)
DECL|macro|NEXT_SEQID
mdefine_line|#define NEXT_SEQID(seqid) (((seqid) + 1) &amp; 0x3fffff)
DECL|macro|IPMI_IPMB_NUM_SEQ
mdefine_line|#define IPMI_IPMB_NUM_SEQ&t;64
DECL|struct|ipmi_smi
r_struct
id|ipmi_smi
(brace
multiline_comment|/* The list of upper layers that are using me.  We read-lock&n;           this when delivering messages to the upper layer to keep&n;           the user from going away while we are processing the&n;           message.  This means that you cannot add or delete a user&n;           from the receive callback. */
DECL|member|users_lock
id|rwlock_t
id|users_lock
suffix:semicolon
DECL|member|users
r_struct
id|list_head
id|users
suffix:semicolon
multiline_comment|/* The IPMI version of the BMC on the other end. */
DECL|member|version_major
r_int
r_char
id|version_major
suffix:semicolon
DECL|member|version_minor
r_int
r_char
id|version_minor
suffix:semicolon
multiline_comment|/* This is the lower-layer&squot;s sender routine. */
DECL|member|handlers
r_struct
id|ipmi_smi_handlers
op_star
id|handlers
suffix:semicolon
DECL|member|send_info
r_void
op_star
id|send_info
suffix:semicolon
multiline_comment|/* A table of sequence numbers for this interface.  We use the&n;           sequence numbers for IPMB messages that go out of the&n;           interface to match them up with their responses.  A routine&n;           is called periodically to time the items in this list. */
DECL|member|seq_lock
id|spinlock_t
id|seq_lock
suffix:semicolon
DECL|member|seq_table
r_struct
id|seq_table
id|seq_table
(braket
id|IPMI_IPMB_NUM_SEQ
)braket
suffix:semicolon
DECL|member|curr_seq
r_int
id|curr_seq
suffix:semicolon
multiline_comment|/* Messages that were delayed for some reason (out of memory,&n;           for instance), will go in here to be processed later in a&n;           periodic timer interrupt. */
DECL|member|waiting_msgs_lock
id|spinlock_t
id|waiting_msgs_lock
suffix:semicolon
DECL|member|waiting_msgs
r_struct
id|list_head
id|waiting_msgs
suffix:semicolon
multiline_comment|/* The list of command receivers that are registered for commands&n;&t;   on this interface. */
DECL|member|cmd_rcvr_lock
id|rwlock_t
id|cmd_rcvr_lock
suffix:semicolon
DECL|member|cmd_rcvrs
r_struct
id|list_head
id|cmd_rcvrs
suffix:semicolon
multiline_comment|/* Events that were queues because no one was there to receive&n;           them. */
DECL|member|events_lock
id|spinlock_t
id|events_lock
suffix:semicolon
multiline_comment|/* For dealing with event stuff. */
DECL|member|waiting_events
r_struct
id|list_head
id|waiting_events
suffix:semicolon
DECL|member|waiting_events_count
r_int
r_int
id|waiting_events_count
suffix:semicolon
multiline_comment|/* How many events in queue? */
multiline_comment|/* This will be non-null if someone registers to receive all&n;&t;   IPMI commands (this is for interface emulation).  There&n;&t;   may not be any things in the cmd_rcvrs list above when&n;&t;   this is registered. */
DECL|member|all_cmd_rcvr
id|ipmi_user_t
id|all_cmd_rcvr
suffix:semicolon
multiline_comment|/* My slave address.  This is initialized to IPMI_BMC_SLAVE_ADDR,&n;&t;   but may be changed by the user. */
DECL|member|my_address
r_int
r_char
id|my_address
suffix:semicolon
multiline_comment|/* My LUN.  This should generally stay the SMS LUN, but just in&n;&t;   case... */
DECL|member|my_lun
r_int
r_char
id|my_lun
suffix:semicolon
)brace
suffix:semicolon
r_int
DECL|function|ipmi_register_all_cmd_rcvr
id|ipmi_register_all_cmd_rcvr
c_func
(paren
id|ipmi_user_t
id|user
)paren
(brace
r_int
id|flags
suffix:semicolon
r_int
id|rv
op_assign
op_minus
id|EBUSY
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;users_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;cmd_rcvr_lock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|user-&gt;intf-&gt;all_cmd_rcvr
op_eq
l_int|NULL
)paren
op_logical_and
(paren
id|list_empty
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;cmd_rcvrs
)paren
)paren
)paren
)paren
(brace
id|user-&gt;intf-&gt;all_cmd_rcvr
op_assign
id|user
suffix:semicolon
id|rv
op_assign
l_int|0
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;cmd_rcvr_lock
)paren
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;users_lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
r_int
DECL|function|ipmi_unregister_all_cmd_rcvr
id|ipmi_unregister_all_cmd_rcvr
c_func
(paren
id|ipmi_user_t
id|user
)paren
(brace
r_int
id|flags
suffix:semicolon
r_int
id|rv
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;users_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;cmd_rcvr_lock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|user-&gt;intf-&gt;all_cmd_rcvr
op_eq
id|user
)paren
(brace
id|user-&gt;intf-&gt;all_cmd_rcvr
op_assign
l_int|NULL
suffix:semicolon
id|rv
op_assign
l_int|0
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;cmd_rcvr_lock
)paren
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;users_lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
DECL|macro|MAX_IPMI_INTERFACES
mdefine_line|#define MAX_IPMI_INTERFACES 4
DECL|variable|ipmi_interfaces
r_static
id|ipmi_smi_t
id|ipmi_interfaces
(braket
id|MAX_IPMI_INTERFACES
)braket
suffix:semicolon
multiline_comment|/* Used to keep interfaces from going away while operations are&n;   operating on interfaces.  Grab read if you are not modifying the&n;   interfaces, write if you are. */
r_static
id|DECLARE_RWSEM
c_func
(paren
id|interfaces_sem
)paren
suffix:semicolon
multiline_comment|/* Directly protects the ipmi_interfaces data structure.  This is&n;   claimed in the timer interrupt. */
DECL|variable|interfaces_lock
r_static
id|spinlock_t
id|interfaces_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* List of watchers that want to know when smi&squot;s are added and&n;   deleted. */
DECL|variable|smi_watchers
r_static
r_struct
id|list_head
id|smi_watchers
op_assign
id|LIST_HEAD_INIT
c_func
(paren
id|smi_watchers
)paren
suffix:semicolon
r_static
id|DECLARE_RWSEM
c_func
(paren
id|smi_watchers_sem
)paren
suffix:semicolon
DECL|function|ipmi_smi_watcher_register
r_int
id|ipmi_smi_watcher_register
c_func
(paren
r_struct
id|ipmi_smi_watcher
op_star
id|watcher
)paren
(brace
r_int
id|i
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|interfaces_sem
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|smi_watchers_sem
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
(paren
id|watcher-&gt;link
)paren
comma
op_amp
id|smi_watchers
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_IPMI_INTERFACES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ipmi_interfaces
(braket
id|i
)braket
op_ne
l_int|NULL
)paren
(brace
id|watcher
op_member_access_from_pointer
id|new_smi
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
)brace
id|up_write
c_func
(paren
op_amp
id|smi_watchers_sem
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|interfaces_sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ipmi_smi_watcher_unregister
r_int
id|ipmi_smi_watcher_unregister
c_func
(paren
r_struct
id|ipmi_smi_watcher
op_star
id|watcher
)paren
(brace
id|down_write
c_func
(paren
op_amp
id|smi_watchers_sem
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
(paren
id|watcher-&gt;link
)paren
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|smi_watchers_sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|ipmi_addr_equal
id|ipmi_addr_equal
c_func
(paren
r_struct
id|ipmi_addr
op_star
id|addr1
comma
r_struct
id|ipmi_addr
op_star
id|addr2
)paren
(brace
r_if
c_cond
(paren
id|addr1-&gt;addr_type
op_ne
id|addr2-&gt;addr_type
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|addr1-&gt;channel
op_ne
id|addr2-&gt;channel
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|addr1-&gt;addr_type
op_eq
id|IPMI_SYSTEM_INTERFACE_ADDR_TYPE
)paren
(brace
r_struct
id|ipmi_system_interface_addr
op_star
id|smi_addr1
op_assign
(paren
r_struct
id|ipmi_system_interface_addr
op_star
)paren
id|addr1
suffix:semicolon
r_struct
id|ipmi_system_interface_addr
op_star
id|smi_addr2
op_assign
(paren
r_struct
id|ipmi_system_interface_addr
op_star
)paren
id|addr2
suffix:semicolon
r_return
(paren
id|smi_addr1-&gt;lun
op_eq
id|smi_addr2-&gt;lun
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|addr1-&gt;addr_type
op_eq
id|IPMI_IPMB_ADDR_TYPE
)paren
op_logical_or
(paren
id|addr1-&gt;addr_type
op_eq
id|IPMI_IPMB_BROADCAST_ADDR_TYPE
)paren
)paren
(brace
r_struct
id|ipmi_ipmb_addr
op_star
id|ipmb_addr1
op_assign
(paren
r_struct
id|ipmi_ipmb_addr
op_star
)paren
id|addr1
suffix:semicolon
r_struct
id|ipmi_ipmb_addr
op_star
id|ipmb_addr2
op_assign
(paren
r_struct
id|ipmi_ipmb_addr
op_star
)paren
id|addr2
suffix:semicolon
r_return
(paren
(paren
id|ipmb_addr1-&gt;slave_addr
op_eq
id|ipmb_addr2-&gt;slave_addr
)paren
op_logical_and
(paren
id|ipmb_addr1-&gt;lun
op_eq
id|ipmb_addr2-&gt;lun
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|ipmi_validate_addr
r_int
id|ipmi_validate_addr
c_func
(paren
r_struct
id|ipmi_addr
op_star
id|addr
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|len
OL
r_sizeof
(paren
r_struct
id|ipmi_system_interface_addr
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|addr-&gt;addr_type
op_eq
id|IPMI_SYSTEM_INTERFACE_ADDR_TYPE
)paren
(brace
r_if
c_cond
(paren
id|addr-&gt;channel
op_ne
id|IPMI_BMC_CHANNEL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|addr-&gt;channel
op_eq
id|IPMI_BMC_CHANNEL
)paren
op_logical_or
(paren
id|addr-&gt;channel
op_ge
id|IPMI_NUM_CHANNELS
)paren
op_logical_or
(paren
id|addr-&gt;channel
OL
l_int|0
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|addr-&gt;addr_type
op_eq
id|IPMI_IPMB_ADDR_TYPE
)paren
op_logical_or
(paren
id|addr-&gt;addr_type
op_eq
id|IPMI_IPMB_BROADCAST_ADDR_TYPE
)paren
)paren
(brace
r_if
c_cond
(paren
id|len
OL
r_sizeof
(paren
r_struct
id|ipmi_ipmb_addr
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|ipmi_addr_length
r_int
r_int
id|ipmi_addr_length
c_func
(paren
r_int
id|addr_type
)paren
(brace
r_if
c_cond
(paren
id|addr_type
op_eq
id|IPMI_SYSTEM_INTERFACE_ADDR_TYPE
)paren
r_return
r_sizeof
(paren
r_struct
id|ipmi_system_interface_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|addr_type
op_eq
id|IPMI_IPMB_ADDR_TYPE
)paren
op_logical_or
(paren
id|addr_type
op_eq
id|IPMI_IPMB_BROADCAST_ADDR_TYPE
)paren
)paren
(brace
r_return
r_sizeof
(paren
r_struct
id|ipmi_ipmb_addr
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|deliver_response
r_static
r_void
id|deliver_response
c_func
(paren
r_struct
id|ipmi_recv_msg
op_star
id|msg
)paren
(brace
id|msg-&gt;user-&gt;handler
op_member_access_from_pointer
id|ipmi_recv_hndl
c_func
(paren
id|msg
comma
id|msg-&gt;user-&gt;handler_data
)paren
suffix:semicolon
)brace
multiline_comment|/* Find the next sequence number not being used and add the given&n;   message with the given timeout to the sequence table.  This must be&n;   called with the interface&squot;s seq_lock held. */
DECL|function|intf_next_seq
r_static
r_int
id|intf_next_seq
c_func
(paren
id|ipmi_smi_t
id|intf
comma
r_struct
id|ipmi_recv_msg
op_star
id|recv_msg
comma
r_int
r_int
id|timeout
comma
r_int
id|retries
comma
r_int
r_char
op_star
id|seq
comma
r_int
op_star
id|seqid
)paren
(brace
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|intf-&gt;curr_seq
suffix:semicolon
id|i
op_ne
(paren
id|intf-&gt;curr_seq
op_minus
l_int|1
)paren
suffix:semicolon
id|i
op_assign
(paren
id|i
op_plus
l_int|1
)paren
op_mod
id|IPMI_IPMB_NUM_SEQ
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|intf-&gt;seq_table
(braket
id|i
)braket
dot
id|inuse
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|intf-&gt;seq_table
(braket
id|i
)braket
dot
id|inuse
)paren
(brace
id|intf-&gt;seq_table
(braket
id|i
)braket
dot
id|recv_msg
op_assign
id|recv_msg
suffix:semicolon
multiline_comment|/* Start with the maximum timeout, when the send response&n;&t;&t;   comes in we will start the real timer. */
id|intf-&gt;seq_table
(braket
id|i
)braket
dot
id|timeout
op_assign
id|MAX_MSG_TIMEOUT
suffix:semicolon
id|intf-&gt;seq_table
(braket
id|i
)braket
dot
id|orig_timeout
op_assign
id|timeout
suffix:semicolon
id|intf-&gt;seq_table
(braket
id|i
)braket
dot
id|retries_left
op_assign
id|retries
suffix:semicolon
id|intf-&gt;seq_table
(braket
id|i
)braket
dot
id|inuse
op_assign
l_int|1
suffix:semicolon
id|intf-&gt;seq_table
(braket
id|i
)braket
dot
id|seqid
op_assign
id|NEXT_SEQID
c_func
(paren
id|intf-&gt;seq_table
(braket
id|i
)braket
dot
id|seqid
)paren
suffix:semicolon
op_star
id|seq
op_assign
id|i
suffix:semicolon
op_star
id|seqid
op_assign
id|intf-&gt;seq_table
(braket
id|i
)braket
dot
id|seqid
suffix:semicolon
id|intf-&gt;curr_seq
op_assign
(paren
id|i
op_plus
l_int|1
)paren
op_mod
id|IPMI_IPMB_NUM_SEQ
suffix:semicolon
)brace
r_else
(brace
id|rv
op_assign
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_return
id|rv
suffix:semicolon
)brace
multiline_comment|/* Return the receive message for the given sequence number and&n;   release the sequence number so it can be reused.  Some other data&n;   is passed in to be sure the message matches up correctly (to help&n;   guard against message coming in after their timeout and the&n;   sequence number being reused). */
DECL|function|intf_find_seq
r_static
r_int
id|intf_find_seq
c_func
(paren
id|ipmi_smi_t
id|intf
comma
r_int
r_char
id|seq
comma
r_int
id|channel
comma
r_int
r_char
id|cmd
comma
r_int
r_char
id|netfn
comma
r_struct
id|ipmi_addr
op_star
id|addr
comma
r_struct
id|ipmi_recv_msg
op_star
op_star
id|recv_msg
)paren
(brace
r_int
id|rv
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|seq
op_ge
id|IPMI_IPMB_NUM_SEQ
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|intf-&gt;seq_lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intf-&gt;seq_table
(braket
id|seq
)braket
dot
id|inuse
)paren
(brace
r_struct
id|ipmi_recv_msg
op_star
id|msg
op_assign
id|intf-&gt;seq_table
(braket
id|seq
)braket
dot
id|recv_msg
suffix:semicolon
r_if
c_cond
(paren
(paren
id|msg-&gt;addr.channel
op_eq
id|channel
)paren
op_logical_and
(paren
id|msg-&gt;msg.cmd
op_eq
id|cmd
)paren
op_logical_and
(paren
id|msg-&gt;msg.netfn
op_eq
id|netfn
)paren
op_logical_and
(paren
id|ipmi_addr_equal
c_func
(paren
id|addr
comma
op_amp
(paren
id|msg-&gt;addr
)paren
)paren
)paren
)paren
(brace
op_star
id|recv_msg
op_assign
id|msg
suffix:semicolon
id|intf-&gt;seq_table
(braket
id|seq
)braket
dot
id|inuse
op_assign
l_int|0
suffix:semicolon
id|rv
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|intf-&gt;seq_lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
multiline_comment|/* Start the timer for a specific sequence table entry. */
DECL|function|intf_start_seq_timer
r_static
r_int
id|intf_start_seq_timer
c_func
(paren
id|ipmi_smi_t
id|intf
comma
r_int
id|msgid
)paren
(brace
r_int
id|rv
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|seq
suffix:semicolon
r_int
r_int
id|seqid
suffix:semicolon
id|GET_SEQ_FROM_MSGID
c_func
(paren
id|msgid
comma
id|seq
comma
id|seqid
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|intf-&gt;seq_lock
)paren
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* We do this verification because the user can be deleted&n;           while a message is outstanding. */
r_if
c_cond
(paren
(paren
id|intf-&gt;seq_table
(braket
id|seq
)braket
dot
id|inuse
)paren
op_logical_and
(paren
id|intf-&gt;seq_table
(braket
id|seq
)braket
dot
id|seqid
op_eq
id|seqid
)paren
)paren
(brace
r_struct
id|seq_table
op_star
id|ent
op_assign
op_amp
(paren
id|intf-&gt;seq_table
(braket
id|seq
)braket
)paren
suffix:semicolon
id|ent-&gt;timeout
op_assign
id|ent-&gt;orig_timeout
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|intf-&gt;seq_lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
DECL|function|ipmi_create_user
r_int
id|ipmi_create_user
c_func
(paren
r_int
r_int
id|if_num
comma
r_struct
id|ipmi_user_hndl
op_star
id|handler
comma
r_void
op_star
id|handler_data
comma
id|ipmi_user_t
op_star
id|user
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|ipmi_user_t
id|new_user
suffix:semicolon
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* There is no module usecount here, because it&squot;s not&n;           required.  Since this can only be used by and called from&n;           other modules, they will implicitly use this module, and&n;           thus this can&squot;t be removed unless the other modules are&n;           removed. */
r_if
c_cond
(paren
id|handler
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Make sure the driver is actually initialized, this handles&n;&t;   problems with initialization order. */
r_if
c_cond
(paren
op_logical_neg
id|initialized
)paren
(brace
id|rv
op_assign
id|ipmi_init_msghandler
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
r_return
id|rv
suffix:semicolon
multiline_comment|/* The init code doesn&squot;t return an error if it was turned&n;&t;&t;   off, but it won&squot;t initialize.  Check that. */
r_if
c_cond
(paren
op_logical_neg
id|initialized
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|new_user
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|new_user
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_user
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|interfaces_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|if_num
OG
id|MAX_IPMI_INTERFACES
)paren
op_logical_or
id|ipmi_interfaces
(braket
id|if_num
)braket
op_eq
l_int|NULL
)paren
(brace
id|rv
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|new_user-&gt;handler
op_assign
id|handler
suffix:semicolon
id|new_user-&gt;handler_data
op_assign
id|handler_data
suffix:semicolon
id|new_user-&gt;intf
op_assign
id|ipmi_interfaces
(braket
id|if_num
)braket
suffix:semicolon
id|new_user-&gt;gets_events
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|try_module_get
c_func
(paren
id|new_user-&gt;intf-&gt;handlers-&gt;owner
)paren
)paren
(brace
id|rv
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|write_lock_irqsave
c_func
(paren
op_amp
id|new_user-&gt;intf-&gt;users_lock
comma
id|flags
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|new_user-&gt;link
comma
op_amp
id|new_user-&gt;intf-&gt;users
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|new_user-&gt;intf-&gt;users_lock
comma
id|flags
)paren
suffix:semicolon
id|out_unlock
suffix:colon
r_if
c_cond
(paren
id|rv
)paren
(brace
id|kfree
c_func
(paren
id|new_user
)paren
suffix:semicolon
)brace
r_else
(brace
op_star
id|user
op_assign
id|new_user
suffix:semicolon
)brace
id|up_read
c_func
(paren
op_amp
id|interfaces_sem
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
DECL|function|ipmi_destroy_user_nolock
r_static
r_int
id|ipmi_destroy_user_nolock
c_func
(paren
id|ipmi_user_t
id|user
)paren
(brace
r_int
id|rv
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|ipmi_user_t
id|t_user
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
comma
op_star
id|entry2
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Find the user and delete them from the list. */
id|list_for_each
c_func
(paren
id|entry
comma
op_amp
(paren
id|user-&gt;intf-&gt;users
)paren
)paren
(brace
id|t_user
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|ipmi_user
comma
id|link
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t_user
op_eq
id|user
)paren
(brace
id|list_del
c_func
(paren
id|entry
)paren
suffix:semicolon
id|rv
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rv
)paren
(brace
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* Remove the user from the interfaces sequence table. */
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;seq_lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IPMI_IPMB_NUM_SEQ
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|user-&gt;intf-&gt;seq_table
(braket
id|i
)braket
dot
id|inuse
op_logical_and
(paren
id|user-&gt;intf-&gt;seq_table
(braket
id|i
)braket
dot
id|recv_msg-&gt;user
op_eq
id|user
)paren
)paren
(brace
id|user-&gt;intf-&gt;seq_table
(braket
id|i
)braket
dot
id|inuse
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;seq_lock
)paren
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Remove the user from the command receiver&squot;s table. */
id|write_lock_irqsave
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;cmd_rcvr_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|entry
comma
id|entry2
comma
op_amp
(paren
id|user-&gt;intf-&gt;cmd_rcvrs
)paren
)paren
(brace
r_struct
id|cmd_rcvr
op_star
id|rcvr
suffix:semicolon
id|rcvr
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|cmd_rcvr
comma
id|link
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rcvr-&gt;user
op_eq
id|user
)paren
(brace
id|list_del
c_func
(paren
id|entry
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|rcvr
)paren
suffix:semicolon
)brace
)brace
id|write_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;cmd_rcvr_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|user
)paren
suffix:semicolon
id|out_unlock
suffix:colon
r_return
id|rv
suffix:semicolon
)brace
DECL|function|ipmi_destroy_user
r_int
id|ipmi_destroy_user
c_func
(paren
id|ipmi_user_t
id|user
)paren
(brace
r_int
id|rv
suffix:semicolon
id|ipmi_smi_t
id|intf
op_assign
id|user-&gt;intf
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|interfaces_sem
)paren
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|intf-&gt;users_lock
comma
id|flags
)paren
suffix:semicolon
id|rv
op_assign
id|ipmi_destroy_user_nolock
c_func
(paren
id|user
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rv
)paren
id|module_put
c_func
(paren
id|intf-&gt;handlers-&gt;owner
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|intf-&gt;users_lock
comma
id|flags
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|interfaces_sem
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
DECL|function|ipmi_get_version
r_void
id|ipmi_get_version
c_func
(paren
id|ipmi_user_t
id|user
comma
r_int
r_char
op_star
id|major
comma
r_int
r_char
op_star
id|minor
)paren
(brace
op_star
id|major
op_assign
id|user-&gt;intf-&gt;version_major
suffix:semicolon
op_star
id|minor
op_assign
id|user-&gt;intf-&gt;version_minor
suffix:semicolon
)brace
DECL|function|ipmi_set_my_address
r_void
id|ipmi_set_my_address
c_func
(paren
id|ipmi_user_t
id|user
comma
r_int
r_char
id|address
)paren
(brace
id|user-&gt;intf-&gt;my_address
op_assign
id|address
suffix:semicolon
)brace
DECL|function|ipmi_get_my_address
r_int
r_char
id|ipmi_get_my_address
c_func
(paren
id|ipmi_user_t
id|user
)paren
(brace
r_return
id|user-&gt;intf-&gt;my_address
suffix:semicolon
)brace
DECL|function|ipmi_set_my_LUN
r_void
id|ipmi_set_my_LUN
c_func
(paren
id|ipmi_user_t
id|user
comma
r_int
r_char
id|LUN
)paren
(brace
id|user-&gt;intf-&gt;my_lun
op_assign
id|LUN
op_amp
l_int|0x3
suffix:semicolon
)brace
DECL|function|ipmi_get_my_LUN
r_int
r_char
id|ipmi_get_my_LUN
c_func
(paren
id|ipmi_user_t
id|user
)paren
(brace
r_return
id|user-&gt;intf-&gt;my_lun
suffix:semicolon
)brace
DECL|function|ipmi_set_gets_events
r_int
id|ipmi_set_gets_events
c_func
(paren
id|ipmi_user_t
id|user
comma
r_int
id|val
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|list_head
op_star
id|e
comma
op_star
id|e2
suffix:semicolon
r_struct
id|ipmi_recv_msg
op_star
id|msg
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;users_lock
)paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;events_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|user-&gt;gets_events
op_assign
id|val
suffix:semicolon
r_if
c_cond
(paren
id|val
)paren
(brace
multiline_comment|/* Deliver any queued events. */
id|list_for_each_safe
c_func
(paren
id|e
comma
id|e2
comma
op_amp
(paren
id|user-&gt;intf-&gt;waiting_events
)paren
)paren
(brace
id|msg
op_assign
id|list_entry
c_func
(paren
id|e
comma
r_struct
id|ipmi_recv_msg
comma
id|link
)paren
suffix:semicolon
id|list_del
c_func
(paren
id|e
)paren
suffix:semicolon
id|msg-&gt;user
op_assign
id|user
suffix:semicolon
id|deliver_response
c_func
(paren
id|msg
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;events_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;users_lock
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ipmi_register_for_cmd
r_int
id|ipmi_register_for_cmd
c_func
(paren
id|ipmi_user_t
id|user
comma
r_int
r_char
id|netfn
comma
r_int
r_char
id|cmd
)paren
(brace
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|cmd_rcvr
op_star
id|rcvr
suffix:semicolon
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
id|rcvr
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|rcvr
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rcvr
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;users_lock
)paren
)paren
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;cmd_rcvr_lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|user-&gt;intf-&gt;all_cmd_rcvr
op_ne
l_int|NULL
)paren
(brace
id|rv
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* Make sure the command/netfn is not already registered. */
id|list_for_each
c_func
(paren
id|entry
comma
op_amp
(paren
id|user-&gt;intf-&gt;cmd_rcvrs
)paren
)paren
(brace
r_struct
id|cmd_rcvr
op_star
id|cmp
suffix:semicolon
id|cmp
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|cmd_rcvr
comma
id|link
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmp-&gt;netfn
op_eq
id|netfn
)paren
op_logical_and
(paren
id|cmp-&gt;cmd
op_eq
id|cmd
)paren
)paren
(brace
id|rv
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|rv
)paren
(brace
id|rcvr-&gt;cmd
op_assign
id|cmd
suffix:semicolon
id|rcvr-&gt;netfn
op_assign
id|netfn
suffix:semicolon
id|rcvr-&gt;user
op_assign
id|user
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
(paren
id|rcvr-&gt;link
)paren
comma
op_amp
(paren
id|user-&gt;intf-&gt;cmd_rcvrs
)paren
)paren
suffix:semicolon
)brace
id|out_unlock
suffix:colon
id|write_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;cmd_rcvr_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;users_lock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
id|kfree
c_func
(paren
id|rcvr
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
DECL|function|ipmi_unregister_for_cmd
r_int
id|ipmi_unregister_for_cmd
c_func
(paren
id|ipmi_user_t
id|user
comma
r_int
r_char
id|netfn
comma
r_int
r_char
id|cmd
)paren
(brace
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|cmd_rcvr
op_star
id|rcvr
suffix:semicolon
r_int
id|rv
op_assign
op_minus
id|ENOENT
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;users_lock
)paren
)paren
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;cmd_rcvr_lock
)paren
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Make sure the command/netfn is not already registered. */
id|list_for_each
c_func
(paren
id|entry
comma
op_amp
(paren
id|user-&gt;intf-&gt;cmd_rcvrs
)paren
)paren
(brace
id|rcvr
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|cmd_rcvr
comma
id|link
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rcvr-&gt;netfn
op_eq
id|netfn
)paren
op_logical_and
(paren
id|rcvr-&gt;cmd
op_eq
id|cmd
)paren
)paren
(brace
id|rv
op_assign
l_int|0
suffix:semicolon
id|list_del
c_func
(paren
id|entry
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|rcvr
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|write_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;cmd_rcvr_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;users_lock
)paren
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
r_static
r_int
r_char
DECL|function|ipmb_checksum
id|ipmb_checksum
c_func
(paren
r_int
r_char
op_star
id|data
comma
r_int
id|size
)paren
(brace
r_int
r_char
id|csum
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|size
OG
l_int|0
suffix:semicolon
id|size
op_decrement
comma
id|data
op_increment
)paren
id|csum
op_add_assign
op_star
id|data
suffix:semicolon
r_return
op_minus
id|csum
suffix:semicolon
)brace
DECL|function|format_ipmb_msg
r_static
r_inline
r_void
id|format_ipmb_msg
c_func
(paren
r_struct
id|ipmi_smi_msg
op_star
id|smi_msg
comma
r_struct
id|ipmi_msg
op_star
id|msg
comma
r_struct
id|ipmi_ipmb_addr
op_star
id|ipmb_addr
comma
r_int
id|msgid
comma
r_int
r_char
id|ipmb_seq
comma
r_int
id|broadcast
comma
r_int
r_char
id|source_address
comma
r_int
r_char
id|source_lun
)paren
(brace
r_int
id|i
op_assign
id|broadcast
suffix:semicolon
multiline_comment|/* Format the IPMB header data. */
id|smi_msg-&gt;data
(braket
l_int|0
)braket
op_assign
(paren
id|IPMI_NETFN_APP_REQUEST
op_lshift
l_int|2
)paren
suffix:semicolon
id|smi_msg-&gt;data
(braket
l_int|1
)braket
op_assign
id|IPMI_SEND_MSG_CMD
suffix:semicolon
id|smi_msg-&gt;data
(braket
l_int|2
)braket
op_assign
id|ipmb_addr-&gt;channel
suffix:semicolon
r_if
c_cond
(paren
id|broadcast
)paren
id|smi_msg-&gt;data
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|smi_msg-&gt;data
(braket
id|i
op_plus
l_int|3
)braket
op_assign
id|ipmb_addr-&gt;slave_addr
suffix:semicolon
id|smi_msg-&gt;data
(braket
id|i
op_plus
l_int|4
)braket
op_assign
(paren
id|msg-&gt;netfn
op_lshift
l_int|2
)paren
op_or
(paren
id|ipmb_addr-&gt;lun
op_amp
l_int|0x3
)paren
suffix:semicolon
id|smi_msg-&gt;data
(braket
id|i
op_plus
l_int|5
)braket
op_assign
id|ipmb_checksum
c_func
(paren
op_amp
(paren
id|smi_msg-&gt;data
(braket
id|i
op_plus
l_int|3
)braket
)paren
comma
l_int|2
)paren
suffix:semicolon
id|smi_msg-&gt;data
(braket
id|i
op_plus
l_int|6
)braket
op_assign
id|source_address
suffix:semicolon
id|smi_msg-&gt;data
(braket
id|i
op_plus
l_int|7
)braket
op_assign
(paren
id|ipmb_seq
op_lshift
l_int|2
)paren
op_or
id|source_lun
suffix:semicolon
id|smi_msg-&gt;data
(braket
id|i
op_plus
l_int|8
)braket
op_assign
id|msg-&gt;cmd
suffix:semicolon
multiline_comment|/* Now tack on the data to the message. */
r_if
c_cond
(paren
id|msg-&gt;data_len
OG
l_int|0
)paren
id|memcpy
c_func
(paren
op_amp
(paren
id|smi_msg-&gt;data
(braket
id|i
op_plus
l_int|9
)braket
)paren
comma
id|msg-&gt;data
comma
id|msg-&gt;data_len
)paren
suffix:semicolon
id|smi_msg-&gt;data_size
op_assign
id|msg-&gt;data_len
op_plus
l_int|9
suffix:semicolon
multiline_comment|/* Now calculate the checksum and tack it on. */
id|smi_msg-&gt;data
(braket
id|i
op_plus
id|smi_msg-&gt;data_size
)braket
op_assign
id|ipmb_checksum
c_func
(paren
op_amp
(paren
id|smi_msg-&gt;data
(braket
id|i
op_plus
l_int|6
)braket
)paren
comma
id|smi_msg-&gt;data_size
op_minus
l_int|6
)paren
suffix:semicolon
multiline_comment|/* Add on the checksum size and the offset from the&n;&t;   broadcast. */
id|smi_msg-&gt;data_size
op_add_assign
l_int|1
op_plus
id|i
suffix:semicolon
id|smi_msg-&gt;msgid
op_assign
id|msgid
suffix:semicolon
)brace
multiline_comment|/* Separate from ipmi_request so that the user does not have to be&n;   supplied in certain circumstances (mainly at panic time).  If&n;   messages are supplied, they will be freed, even if an error&n;   occurs. */
DECL|function|i_ipmi_request
r_static
r_inline
r_int
id|i_ipmi_request
c_func
(paren
id|ipmi_user_t
id|user
comma
id|ipmi_smi_t
id|intf
comma
r_struct
id|ipmi_addr
op_star
id|addr
comma
r_int
id|msgid
comma
r_struct
id|ipmi_msg
op_star
id|msg
comma
r_void
op_star
id|supplied_smi
comma
r_struct
id|ipmi_recv_msg
op_star
id|supplied_recv
comma
r_int
id|priority
comma
r_int
r_char
id|source_address
comma
r_int
r_char
id|source_lun
)paren
(brace
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
r_struct
id|ipmi_smi_msg
op_star
id|smi_msg
suffix:semicolon
r_struct
id|ipmi_recv_msg
op_star
id|recv_msg
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|supplied_recv
)paren
(brace
id|recv_msg
op_assign
id|supplied_recv
suffix:semicolon
)brace
r_else
(brace
id|recv_msg
op_assign
id|ipmi_alloc_recv_msg
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|recv_msg
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|supplied_smi
)paren
(brace
id|smi_msg
op_assign
(paren
r_struct
id|ipmi_smi_msg
op_star
)paren
id|supplied_smi
suffix:semicolon
)brace
r_else
(brace
id|smi_msg
op_assign
id|ipmi_alloc_smi_msg
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smi_msg
op_eq
l_int|NULL
)paren
(brace
id|ipmi_free_recv_msg
c_func
(paren
id|recv_msg
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|addr-&gt;channel
OG
id|IPMI_NUM_CHANNELS
)paren
(brace
id|rv
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
id|recv_msg-&gt;user
op_assign
id|user
suffix:semicolon
id|recv_msg-&gt;msgid
op_assign
id|msgid
suffix:semicolon
multiline_comment|/* Store the message to send in the receive message so timeout&n;&t;   responses can get the proper response data. */
id|recv_msg-&gt;msg
op_assign
op_star
id|msg
suffix:semicolon
r_if
c_cond
(paren
id|addr-&gt;addr_type
op_eq
id|IPMI_SYSTEM_INTERFACE_ADDR_TYPE
)paren
(brace
r_struct
id|ipmi_system_interface_addr
op_star
id|smi_addr
suffix:semicolon
id|smi_addr
op_assign
(paren
r_struct
id|ipmi_system_interface_addr
op_star
)paren
id|addr
suffix:semicolon
r_if
c_cond
(paren
id|smi_addr-&gt;lun
OG
l_int|3
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|recv_msg-&gt;addr
comma
id|smi_addr
comma
r_sizeof
(paren
op_star
id|smi_addr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|msg-&gt;netfn
op_eq
id|IPMI_NETFN_APP_REQUEST
)paren
op_logical_and
(paren
(paren
id|msg-&gt;cmd
op_eq
id|IPMI_SEND_MSG_CMD
)paren
op_logical_or
(paren
id|msg-&gt;cmd
op_eq
id|IPMI_GET_MSG_CMD
)paren
op_logical_or
(paren
id|msg-&gt;cmd
op_eq
id|IPMI_READ_EVENT_MSG_BUFFER_CMD
)paren
)paren
)paren
(brace
multiline_comment|/* We don&squot;t let the user do these, since we manage&n;&t;&t;&t;   the sequence numbers. */
id|rv
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|msg-&gt;data_len
op_plus
l_int|2
)paren
OG
id|IPMI_MAX_MSG_LENGTH
)paren
(brace
id|rv
op_assign
op_minus
id|EMSGSIZE
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
id|smi_msg-&gt;data
(braket
l_int|0
)braket
op_assign
(paren
id|msg-&gt;netfn
op_lshift
l_int|2
)paren
op_or
(paren
id|smi_addr-&gt;lun
op_amp
l_int|0x3
)paren
suffix:semicolon
id|smi_msg-&gt;data
(braket
l_int|1
)braket
op_assign
id|msg-&gt;cmd
suffix:semicolon
id|smi_msg-&gt;msgid
op_assign
id|msgid
suffix:semicolon
id|smi_msg-&gt;user_data
op_assign
id|recv_msg
suffix:semicolon
r_if
c_cond
(paren
id|msg-&gt;data_len
OG
l_int|0
)paren
id|memcpy
c_func
(paren
op_amp
(paren
id|smi_msg-&gt;data
(braket
l_int|2
)braket
)paren
comma
id|msg-&gt;data
comma
id|msg-&gt;data_len
)paren
suffix:semicolon
id|smi_msg-&gt;data_size
op_assign
id|msg-&gt;data_len
op_plus
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|addr-&gt;addr_type
op_eq
id|IPMI_IPMB_ADDR_TYPE
)paren
op_logical_or
(paren
id|addr-&gt;addr_type
op_eq
id|IPMI_IPMB_BROADCAST_ADDR_TYPE
)paren
)paren
(brace
r_struct
id|ipmi_ipmb_addr
op_star
id|ipmb_addr
suffix:semicolon
r_int
r_char
id|ipmb_seq
suffix:semicolon
r_int
id|seqid
suffix:semicolon
r_int
id|broadcast
suffix:semicolon
r_int
id|retries
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_eq
l_int|NULL
)paren
(brace
id|rv
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
r_if
c_cond
(paren
id|addr-&gt;addr_type
op_eq
id|IPMI_IPMB_BROADCAST_ADDR_TYPE
)paren
(brace
multiline_comment|/* Broadcasts add a zero at the beginning of the&n;&t;&t;       message, but otherwise is the same as an IPMB&n;&t;&t;       address. */
id|addr-&gt;addr_type
op_assign
id|IPMI_IPMB_ADDR_TYPE
suffix:semicolon
id|broadcast
op_assign
l_int|1
suffix:semicolon
id|retries
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Don&squot;t retry broadcasts. */
)brace
r_else
(brace
id|broadcast
op_assign
l_int|0
suffix:semicolon
id|retries
op_assign
l_int|4
suffix:semicolon
)brace
multiline_comment|/* 9 for the header and 1 for the checksum, plus&n;                   possibly one for the broadcast. */
r_if
c_cond
(paren
(paren
id|msg-&gt;data_len
op_plus
l_int|10
op_plus
id|broadcast
)paren
OG
id|IPMI_MAX_MSG_LENGTH
)paren
(brace
id|rv
op_assign
op_minus
id|EMSGSIZE
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
id|ipmb_addr
op_assign
(paren
r_struct
id|ipmi_ipmb_addr
op_star
)paren
id|addr
suffix:semicolon
r_if
c_cond
(paren
id|ipmb_addr-&gt;lun
OG
l_int|3
)paren
(brace
id|rv
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
id|memcpy
c_func
(paren
op_amp
id|recv_msg-&gt;addr
comma
id|ipmb_addr
comma
r_sizeof
(paren
op_star
id|ipmb_addr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|recv_msg-&gt;msg.netfn
op_amp
l_int|0x1
)paren
(brace
multiline_comment|/* It&squot;s a response, so use the user&squot;s sequence&n;                           from msgid. */
id|format_ipmb_msg
c_func
(paren
id|smi_msg
comma
id|msg
comma
id|ipmb_addr
comma
id|msgid
comma
id|msgid
comma
id|broadcast
comma
id|source_address
comma
id|source_lun
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* It&squot;s a command, so get a sequence for it. */
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|intf-&gt;seq_lock
)paren
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Create a sequence number with a 1 second&n;                           timeout and 4 retries. */
multiline_comment|/* FIXME - magic number for the timeout. */
id|rv
op_assign
id|intf_next_seq
c_func
(paren
id|intf
comma
id|recv_msg
comma
l_int|1000
comma
id|retries
comma
op_amp
id|ipmb_seq
comma
op_amp
id|seqid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
(brace
multiline_comment|/* We have used up all the sequence numbers,&n;&t;&t;&t;&t;   probably, so abort. */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|intf-&gt;seq_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|ipmi_free_recv_msg
c_func
(paren
id|recv_msg
)paren
suffix:semicolon
id|ipmi_free_smi_msg
c_func
(paren
id|smi_msg
)paren
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
multiline_comment|/* Store the sequence number in the message,&n;                           so that when the send message response&n;                           comes back we can start the timer. */
id|format_ipmb_msg
c_func
(paren
id|smi_msg
comma
id|msg
comma
id|ipmb_addr
comma
id|STORE_SEQ_IN_MSGID
c_func
(paren
id|ipmb_seq
comma
id|seqid
)paren
comma
id|ipmb_seq
comma
id|broadcast
comma
id|source_address
comma
id|source_lun
)paren
suffix:semicolon
multiline_comment|/* Copy the message into the recv message data, so we&n;&t;&t;&t;   can retransmit it later if necessary. */
id|memcpy
c_func
(paren
id|recv_msg-&gt;msg_data
comma
id|smi_msg-&gt;data
comma
id|smi_msg-&gt;data_size
)paren
suffix:semicolon
id|recv_msg-&gt;msg.data
op_assign
id|recv_msg-&gt;msg_data
suffix:semicolon
id|recv_msg-&gt;msg.data_len
op_assign
id|smi_msg-&gt;data_size
suffix:semicolon
multiline_comment|/* We don&squot;t unlock until here, because we need&n;                           to copy the completed message into the&n;                           recv_msg before we release the lock.&n;                           Otherwise, race conditions may bite us.  I&n;                           know that&squot;s pretty paranoid, but I prefer&n;                           to be correct. */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|intf-&gt;seq_lock
)paren
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Unknown address type. */
id|rv
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
macro_line|#if DEBUG_MSGING
(brace
r_int
id|m
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
l_int|0
suffix:semicolon
id|m
OL
id|smi_msg-&gt;data_size
suffix:semicolon
id|m
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %2.2x&quot;
comma
id|smi_msg-&gt;data
(braket
id|m
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|intf-&gt;handlers
op_member_access_from_pointer
id|sender
c_func
(paren
id|intf-&gt;send_info
comma
id|smi_msg
comma
id|priority
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_err
suffix:colon
id|ipmi_free_smi_msg
c_func
(paren
id|smi_msg
)paren
suffix:semicolon
id|ipmi_free_recv_msg
c_func
(paren
id|recv_msg
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
DECL|function|ipmi_request
r_int
id|ipmi_request
c_func
(paren
id|ipmi_user_t
id|user
comma
r_struct
id|ipmi_addr
op_star
id|addr
comma
r_int
id|msgid
comma
r_struct
id|ipmi_msg
op_star
id|msg
comma
r_int
id|priority
)paren
(brace
r_return
id|i_ipmi_request
c_func
(paren
id|user
comma
id|user-&gt;intf
comma
id|addr
comma
id|msgid
comma
id|msg
comma
l_int|NULL
comma
l_int|NULL
comma
id|priority
comma
id|user-&gt;intf-&gt;my_address
comma
id|user-&gt;intf-&gt;my_lun
)paren
suffix:semicolon
)brace
DECL|function|ipmi_request_supply_msgs
r_int
id|ipmi_request_supply_msgs
c_func
(paren
id|ipmi_user_t
id|user
comma
r_struct
id|ipmi_addr
op_star
id|addr
comma
r_int
id|msgid
comma
r_struct
id|ipmi_msg
op_star
id|msg
comma
r_void
op_star
id|supplied_smi
comma
r_struct
id|ipmi_recv_msg
op_star
id|supplied_recv
comma
r_int
id|priority
)paren
(brace
r_return
id|i_ipmi_request
c_func
(paren
id|user
comma
id|user-&gt;intf
comma
id|addr
comma
id|msgid
comma
id|msg
comma
id|supplied_smi
comma
id|supplied_recv
comma
id|priority
comma
id|user-&gt;intf-&gt;my_address
comma
id|user-&gt;intf-&gt;my_lun
)paren
suffix:semicolon
)brace
DECL|function|ipmi_request_with_source
r_int
id|ipmi_request_with_source
c_func
(paren
id|ipmi_user_t
id|user
comma
r_struct
id|ipmi_addr
op_star
id|addr
comma
r_int
id|msgid
comma
r_struct
id|ipmi_msg
op_star
id|msg
comma
r_int
id|priority
comma
r_int
r_char
id|source_address
comma
r_int
r_char
id|source_lun
)paren
(brace
r_return
id|i_ipmi_request
c_func
(paren
id|user
comma
id|user-&gt;intf
comma
id|addr
comma
id|msgid
comma
id|msg
comma
l_int|NULL
comma
l_int|NULL
comma
id|priority
comma
id|source_address
comma
id|source_lun
)paren
suffix:semicolon
)brace
DECL|function|ipmi_register_smi
r_int
id|ipmi_register_smi
c_func
(paren
r_struct
id|ipmi_smi_handlers
op_star
id|handlers
comma
r_void
op_star
id|send_info
comma
r_int
r_char
id|version_major
comma
r_int
r_char
id|version_minor
comma
id|ipmi_smi_t
op_star
id|intf
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_int
id|rv
suffix:semicolon
id|ipmi_smi_t
id|new_intf
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Make sure the driver is actually initialized, this handles&n;&t;   problems with initialization order. */
r_if
c_cond
(paren
op_logical_neg
id|initialized
)paren
(brace
id|rv
op_assign
id|ipmi_init_msghandler
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
r_return
id|rv
suffix:semicolon
multiline_comment|/* The init code doesn&squot;t return an error if it was turned&n;&t;&t;   off, but it won&squot;t initialize.  Check that. */
r_if
c_cond
(paren
op_logical_neg
id|initialized
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|new_intf
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|new_intf
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_intf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|rv
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|interfaces_sem
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_IPMI_INTERFACES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ipmi_interfaces
(braket
id|i
)braket
op_eq
l_int|NULL
)paren
(brace
id|new_intf-&gt;version_major
op_assign
id|version_major
suffix:semicolon
id|new_intf-&gt;version_minor
op_assign
id|version_minor
suffix:semicolon
id|new_intf-&gt;my_address
op_assign
id|IPMI_BMC_SLAVE_ADDR
suffix:semicolon
id|new_intf-&gt;my_lun
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* the SMS LUN. */
id|rwlock_init
c_func
(paren
op_amp
(paren
id|new_intf-&gt;users_lock
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
(paren
id|new_intf-&gt;users
)paren
)paren
suffix:semicolon
id|new_intf-&gt;handlers
op_assign
id|handlers
suffix:semicolon
id|new_intf-&gt;send_info
op_assign
id|send_info
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
(paren
id|new_intf-&gt;seq_lock
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|IPMI_IPMB_NUM_SEQ
suffix:semicolon
id|j
op_increment
)paren
(brace
id|new_intf-&gt;seq_table
(braket
id|j
)braket
dot
id|inuse
op_assign
l_int|0
suffix:semicolon
id|new_intf-&gt;seq_table
(braket
id|j
)braket
dot
id|seqid
op_assign
l_int|0
suffix:semicolon
)brace
id|new_intf-&gt;curr_seq
op_assign
l_int|0
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
(paren
id|new_intf-&gt;waiting_msgs_lock
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
(paren
id|new_intf-&gt;waiting_msgs
)paren
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
(paren
id|new_intf-&gt;events_lock
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
(paren
id|new_intf-&gt;waiting_events
)paren
)paren
suffix:semicolon
id|new_intf-&gt;waiting_events_count
op_assign
l_int|0
suffix:semicolon
id|rwlock_init
c_func
(paren
op_amp
(paren
id|new_intf-&gt;cmd_rcvr_lock
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
(paren
id|new_intf-&gt;cmd_rcvrs
)paren
)paren
suffix:semicolon
id|new_intf-&gt;all_cmd_rcvr
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|interfaces_lock
comma
id|flags
)paren
suffix:semicolon
id|ipmi_interfaces
(braket
id|i
)braket
op_assign
id|new_intf
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|interfaces_lock
comma
id|flags
)paren
suffix:semicolon
id|rv
op_assign
l_int|0
suffix:semicolon
op_star
id|intf
op_assign
id|new_intf
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|downgrade_write
c_func
(paren
op_amp
id|interfaces_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Call all the watcher interfaces to tell them that a&n;&t;&t;   new interface is available. */
id|down_read
c_func
(paren
op_amp
id|smi_watchers_sem
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|entry
comma
op_amp
id|smi_watchers
)paren
(brace
r_struct
id|ipmi_smi_watcher
op_star
id|w
suffix:semicolon
id|w
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|ipmi_smi_watcher
comma
id|link
)paren
suffix:semicolon
id|w
op_member_access_from_pointer
id|new_smi
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
id|up_read
c_func
(paren
op_amp
id|smi_watchers_sem
)paren
suffix:semicolon
)brace
id|up_read
c_func
(paren
op_amp
id|interfaces_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
id|kfree
c_func
(paren
id|new_intf
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
DECL|function|free_recv_msg_list
r_static
r_void
id|free_recv_msg_list
c_func
(paren
r_struct
id|list_head
op_star
id|q
)paren
(brace
r_struct
id|list_head
op_star
id|entry
comma
op_star
id|entry2
suffix:semicolon
r_struct
id|ipmi_recv_msg
op_star
id|msg
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|entry
comma
id|entry2
comma
id|q
)paren
(brace
id|msg
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|ipmi_recv_msg
comma
id|link
)paren
suffix:semicolon
id|list_del
c_func
(paren
id|entry
)paren
suffix:semicolon
id|ipmi_free_recv_msg
c_func
(paren
id|msg
)paren
suffix:semicolon
)brace
)brace
DECL|function|free_cmd_rcvr_list
r_static
r_void
id|free_cmd_rcvr_list
c_func
(paren
r_struct
id|list_head
op_star
id|q
)paren
(brace
r_struct
id|list_head
op_star
id|entry
comma
op_star
id|entry2
suffix:semicolon
r_struct
id|cmd_rcvr
op_star
id|rcvr
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|entry
comma
id|entry2
comma
id|q
)paren
(brace
id|rcvr
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|cmd_rcvr
comma
id|link
)paren
suffix:semicolon
id|list_del
c_func
(paren
id|entry
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|rcvr
)paren
suffix:semicolon
)brace
)brace
DECL|function|clean_up_interface_data
r_static
r_void
id|clean_up_interface_data
c_func
(paren
id|ipmi_smi_t
id|intf
)paren
(brace
r_int
id|i
suffix:semicolon
id|free_recv_msg_list
c_func
(paren
op_amp
(paren
id|intf-&gt;waiting_msgs
)paren
)paren
suffix:semicolon
id|free_recv_msg_list
c_func
(paren
op_amp
(paren
id|intf-&gt;waiting_events
)paren
)paren
suffix:semicolon
id|free_cmd_rcvr_list
c_func
(paren
op_amp
(paren
id|intf-&gt;cmd_rcvrs
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IPMI_IPMB_NUM_SEQ
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|intf-&gt;seq_table
(braket
id|i
)braket
dot
id|inuse
)paren
op_logical_and
(paren
id|intf-&gt;seq_table
(braket
id|i
)braket
dot
id|recv_msg
)paren
)paren
(brace
id|ipmi_free_recv_msg
c_func
(paren
id|intf-&gt;seq_table
(braket
id|i
)braket
dot
id|recv_msg
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|ipmi_unregister_smi
r_int
id|ipmi_unregister_smi
c_func
(paren
id|ipmi_smi_t
id|intf
)paren
(brace
r_int
id|rv
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|interfaces_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
(paren
id|intf-&gt;users
)paren
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_IPMI_INTERFACES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ipmi_interfaces
(braket
id|i
)braket
op_eq
id|intf
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|interfaces_lock
comma
id|flags
)paren
suffix:semicolon
id|ipmi_interfaces
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|clean_up_interface_data
c_func
(paren
id|intf
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|interfaces_lock
comma
id|flags
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|intf
)paren
suffix:semicolon
id|rv
op_assign
l_int|0
suffix:semicolon
r_goto
id|out_call_watcher
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|rv
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
id|up_write
c_func
(paren
op_amp
id|interfaces_sem
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
id|out_call_watcher
suffix:colon
id|downgrade_write
c_func
(paren
op_amp
id|interfaces_sem
)paren
suffix:semicolon
multiline_comment|/* Call all the watcher interfaces to tell them that&n;&t;   an interface is gone. */
id|down_read
c_func
(paren
op_amp
id|smi_watchers_sem
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|entry
comma
op_amp
id|smi_watchers
)paren
(brace
r_struct
id|ipmi_smi_watcher
op_star
id|w
suffix:semicolon
id|w
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|ipmi_smi_watcher
comma
id|link
)paren
suffix:semicolon
id|w
op_member_access_from_pointer
id|smi_gone
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
id|up_read
c_func
(paren
op_amp
id|smi_watchers_sem
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|interfaces_sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|handle_get_msg_rsp
r_static
r_int
id|handle_get_msg_rsp
c_func
(paren
id|ipmi_smi_t
id|intf
comma
r_struct
id|ipmi_smi_msg
op_star
id|msg
)paren
(brace
r_struct
id|ipmi_ipmb_addr
id|ipmb_addr
suffix:semicolon
r_struct
id|ipmi_recv_msg
op_star
id|recv_msg
suffix:semicolon
r_if
c_cond
(paren
id|msg-&gt;rsp_size
OL
l_int|11
)paren
multiline_comment|/* Message not big enough, just ignore it. */
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|msg-&gt;rsp
(braket
l_int|2
)braket
op_ne
l_int|0
)paren
multiline_comment|/* An error getting the response, just ignore it. */
r_return
l_int|0
suffix:semicolon
id|ipmb_addr.addr_type
op_assign
id|IPMI_IPMB_ADDR_TYPE
suffix:semicolon
id|ipmb_addr.slave_addr
op_assign
id|msg-&gt;rsp
(braket
l_int|6
)braket
suffix:semicolon
id|ipmb_addr.channel
op_assign
id|msg-&gt;rsp
(braket
l_int|3
)braket
op_amp
l_int|0x0f
suffix:semicolon
id|ipmb_addr.lun
op_assign
id|msg-&gt;rsp
(braket
l_int|7
)braket
op_amp
l_int|3
suffix:semicolon
multiline_comment|/* It&squot;s a response from a remote entity.  Look up the sequence&n;&t;   number and handle the response. */
r_if
c_cond
(paren
id|intf_find_seq
c_func
(paren
id|intf
comma
id|msg-&gt;rsp
(braket
l_int|7
)braket
op_rshift
l_int|2
comma
id|msg-&gt;rsp
(braket
l_int|3
)braket
op_amp
l_int|0x0f
comma
id|msg-&gt;rsp
(braket
l_int|8
)braket
comma
(paren
id|msg-&gt;rsp
(braket
l_int|4
)braket
op_rshift
l_int|2
)paren
op_amp
(paren
op_complement
l_int|1
)paren
comma
(paren
r_struct
id|ipmi_addr
op_star
)paren
op_amp
(paren
id|ipmb_addr
)paren
comma
op_amp
id|recv_msg
)paren
)paren
(brace
multiline_comment|/* We were unable to find the sequence number,&n;&t;&t;   so just nuke the message. */
r_return
l_int|0
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|recv_msg-&gt;msg_data
comma
op_amp
(paren
id|msg-&gt;rsp
(braket
l_int|9
)braket
)paren
comma
id|msg-&gt;rsp_size
op_minus
l_int|9
)paren
suffix:semicolon
multiline_comment|/* THe other fields matched, so no need to set them, except&n;           for netfn, which needs to be the response that was&n;           returned, not the request value. */
id|recv_msg-&gt;msg.netfn
op_assign
id|msg-&gt;rsp
(braket
l_int|4
)braket
op_rshift
l_int|2
suffix:semicolon
id|recv_msg-&gt;msg.data
op_assign
id|recv_msg-&gt;msg_data
suffix:semicolon
id|recv_msg-&gt;msg.data_len
op_assign
id|msg-&gt;rsp_size
op_minus
l_int|10
suffix:semicolon
id|recv_msg-&gt;recv_type
op_assign
id|IPMI_RESPONSE_RECV_TYPE
suffix:semicolon
id|deliver_response
c_func
(paren
id|recv_msg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|handle_get_msg_cmd
r_static
r_int
id|handle_get_msg_cmd
c_func
(paren
id|ipmi_smi_t
id|intf
comma
r_struct
id|ipmi_smi_msg
op_star
id|msg
)paren
(brace
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
r_struct
id|cmd_rcvr
op_star
id|rcvr
suffix:semicolon
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|netfn
suffix:semicolon
r_int
r_char
id|cmd
suffix:semicolon
id|ipmi_user_t
id|user
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ipmi_ipmb_addr
op_star
id|ipmb_addr
suffix:semicolon
r_struct
id|ipmi_recv_msg
op_star
id|recv_msg
suffix:semicolon
r_if
c_cond
(paren
id|msg-&gt;rsp_size
OL
l_int|10
)paren
multiline_comment|/* Message not big enough, just ignore it. */
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|msg-&gt;rsp
(braket
l_int|2
)braket
op_ne
l_int|0
)paren
(brace
multiline_comment|/* An error getting the response, just ignore it. */
r_return
l_int|0
suffix:semicolon
)brace
id|netfn
op_assign
id|msg-&gt;rsp
(braket
l_int|4
)braket
op_rshift
l_int|2
suffix:semicolon
id|cmd
op_assign
id|msg-&gt;rsp
(braket
l_int|8
)braket
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
(paren
id|intf-&gt;cmd_rcvr_lock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intf-&gt;all_cmd_rcvr
)paren
(brace
id|user
op_assign
id|intf-&gt;all_cmd_rcvr
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Find the command/netfn. */
id|list_for_each
c_func
(paren
id|entry
comma
op_amp
(paren
id|intf-&gt;cmd_rcvrs
)paren
)paren
(brace
id|rcvr
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|cmd_rcvr
comma
id|link
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rcvr-&gt;netfn
op_eq
id|netfn
)paren
op_logical_and
(paren
id|rcvr-&gt;cmd
op_eq
id|cmd
)paren
)paren
(brace
id|user
op_assign
id|rcvr-&gt;user
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
(paren
id|intf-&gt;cmd_rcvr_lock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|user
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* We didn&squot;t find a user, deliver an error response. */
id|msg-&gt;data
(braket
l_int|0
)braket
op_assign
(paren
id|IPMI_NETFN_APP_REQUEST
op_lshift
l_int|2
)paren
suffix:semicolon
id|msg-&gt;data
(braket
l_int|1
)braket
op_assign
id|IPMI_SEND_MSG_CMD
suffix:semicolon
id|msg-&gt;data
(braket
l_int|2
)braket
op_assign
id|msg-&gt;rsp
(braket
l_int|3
)braket
suffix:semicolon
id|msg-&gt;data
(braket
l_int|3
)braket
op_assign
id|msg-&gt;rsp
(braket
l_int|6
)braket
suffix:semicolon
id|msg-&gt;data
(braket
l_int|4
)braket
op_assign
(paren
(paren
id|netfn
op_plus
l_int|1
)paren
op_lshift
l_int|2
)paren
op_or
(paren
id|msg-&gt;rsp
(braket
l_int|7
)braket
op_amp
l_int|0x3
)paren
suffix:semicolon
id|msg-&gt;data
(braket
l_int|5
)braket
op_assign
id|ipmb_checksum
c_func
(paren
op_amp
(paren
id|msg-&gt;data
(braket
l_int|3
)braket
)paren
comma
l_int|2
)paren
suffix:semicolon
id|msg-&gt;data
(braket
l_int|6
)braket
op_assign
id|intf-&gt;my_address
suffix:semicolon
multiline_comment|/* rqseq/lun */
id|msg-&gt;data
(braket
l_int|7
)braket
op_assign
(paren
id|msg-&gt;rsp
(braket
l_int|7
)braket
op_amp
l_int|0xfc
)paren
op_or
(paren
id|msg-&gt;rsp
(braket
l_int|4
)braket
op_amp
l_int|0x3
)paren
suffix:semicolon
id|msg-&gt;data
(braket
l_int|8
)braket
op_assign
id|msg-&gt;rsp
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* cmd */
id|msg-&gt;data
(braket
l_int|9
)braket
op_assign
id|IPMI_INVALID_CMD_COMPLETION_CODE
suffix:semicolon
id|msg-&gt;data
(braket
l_int|10
)braket
op_assign
id|ipmb_checksum
c_func
(paren
op_amp
(paren
id|msg-&gt;data
(braket
l_int|6
)braket
)paren
comma
l_int|4
)paren
suffix:semicolon
id|msg-&gt;data_size
op_assign
l_int|11
suffix:semicolon
id|intf-&gt;handlers
op_member_access_from_pointer
id|sender
c_func
(paren
id|intf-&gt;send_info
comma
id|msg
comma
l_int|0
)paren
suffix:semicolon
id|rv
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* We used the message, so return the value that&n;&t;&t;&t;    causes it to not be freed or queued. */
)brace
r_else
(brace
multiline_comment|/* Deliver the message to the user. */
id|recv_msg
op_assign
id|ipmi_alloc_recv_msg
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|recv_msg
)paren
(brace
multiline_comment|/* We couldn&squot;t allocate memory for the&n;                           message, so requeue it for handling&n;                           later. */
id|rv
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|ipmb_addr
op_assign
(paren
r_struct
id|ipmi_ipmb_addr
op_star
)paren
op_amp
id|recv_msg-&gt;addr
suffix:semicolon
id|ipmb_addr-&gt;addr_type
op_assign
id|IPMI_IPMB_ADDR_TYPE
suffix:semicolon
id|ipmb_addr-&gt;slave_addr
op_assign
id|msg-&gt;rsp
(braket
l_int|6
)braket
suffix:semicolon
id|ipmb_addr-&gt;lun
op_assign
id|msg-&gt;rsp
(braket
l_int|7
)braket
op_amp
l_int|3
suffix:semicolon
id|ipmb_addr-&gt;channel
op_assign
id|msg-&gt;rsp
(braket
l_int|3
)braket
suffix:semicolon
id|recv_msg-&gt;user
op_assign
id|user
suffix:semicolon
id|recv_msg-&gt;recv_type
op_assign
id|IPMI_CMD_RECV_TYPE
suffix:semicolon
id|recv_msg-&gt;msgid
op_assign
id|msg-&gt;rsp
(braket
l_int|7
)braket
op_rshift
l_int|2
suffix:semicolon
id|recv_msg-&gt;msg.netfn
op_assign
id|msg-&gt;rsp
(braket
l_int|4
)braket
op_rshift
l_int|2
suffix:semicolon
id|recv_msg-&gt;msg.cmd
op_assign
id|msg-&gt;rsp
(braket
l_int|8
)braket
suffix:semicolon
id|recv_msg-&gt;msg.data
op_assign
id|recv_msg-&gt;msg_data
suffix:semicolon
id|recv_msg-&gt;msg.data_len
op_assign
id|msg-&gt;rsp_size
op_minus
l_int|10
suffix:semicolon
id|memcpy
c_func
(paren
id|recv_msg-&gt;msg_data
comma
op_amp
(paren
id|msg-&gt;rsp
(braket
l_int|9
)braket
)paren
comma
id|msg-&gt;rsp_size
op_minus
l_int|10
)paren
suffix:semicolon
id|deliver_response
c_func
(paren
id|recv_msg
)paren
suffix:semicolon
)brace
)brace
r_return
id|rv
suffix:semicolon
)brace
DECL|function|copy_event_into_recv_msg
r_static
r_void
id|copy_event_into_recv_msg
c_func
(paren
r_struct
id|ipmi_recv_msg
op_star
id|recv_msg
comma
r_struct
id|ipmi_smi_msg
op_star
id|msg
)paren
(brace
r_struct
id|ipmi_system_interface_addr
op_star
id|smi_addr
suffix:semicolon
id|recv_msg-&gt;msgid
op_assign
l_int|0
suffix:semicolon
id|smi_addr
op_assign
(paren
r_struct
id|ipmi_system_interface_addr
op_star
)paren
op_amp
(paren
id|recv_msg-&gt;addr
)paren
suffix:semicolon
id|smi_addr-&gt;addr_type
op_assign
id|IPMI_SYSTEM_INTERFACE_ADDR_TYPE
suffix:semicolon
id|smi_addr-&gt;channel
op_assign
id|IPMI_BMC_CHANNEL
suffix:semicolon
id|smi_addr-&gt;lun
op_assign
id|msg-&gt;rsp
(braket
l_int|0
)braket
op_amp
l_int|3
suffix:semicolon
id|recv_msg-&gt;recv_type
op_assign
id|IPMI_ASYNC_EVENT_RECV_TYPE
suffix:semicolon
id|recv_msg-&gt;msg.netfn
op_assign
id|msg-&gt;rsp
(braket
l_int|0
)braket
op_rshift
l_int|2
suffix:semicolon
id|recv_msg-&gt;msg.cmd
op_assign
id|msg-&gt;rsp
(braket
l_int|1
)braket
suffix:semicolon
id|memcpy
c_func
(paren
id|recv_msg-&gt;msg_data
comma
op_amp
(paren
id|msg-&gt;rsp
(braket
l_int|3
)braket
)paren
comma
id|msg-&gt;rsp_size
op_minus
l_int|3
)paren
suffix:semicolon
id|recv_msg-&gt;msg.data
op_assign
id|recv_msg-&gt;msg_data
suffix:semicolon
id|recv_msg-&gt;msg.data_len
op_assign
id|msg-&gt;rsp_size
op_minus
l_int|3
suffix:semicolon
)brace
multiline_comment|/* This will be called with the intf-&gt;users_lock read-locked, so no need&n;   to do that here. */
DECL|function|handle_read_event_rsp
r_static
r_int
id|handle_read_event_rsp
c_func
(paren
id|ipmi_smi_t
id|intf
comma
r_struct
id|ipmi_smi_msg
op_star
id|msg
)paren
(brace
r_struct
id|ipmi_recv_msg
op_star
id|recv_msg
suffix:semicolon
r_struct
id|list_head
id|msgs
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
comma
op_star
id|entry2
suffix:semicolon
id|ipmi_user_t
id|user
suffix:semicolon
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
r_int
id|deliver_count
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|msg-&gt;rsp_size
OL
l_int|19
)paren
(brace
multiline_comment|/* Message is too small to be an IPMB event. */
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|msg-&gt;rsp
(braket
l_int|2
)braket
op_ne
l_int|0
)paren
(brace
multiline_comment|/* An error getting the event, just ignore it. */
r_return
l_int|0
suffix:semicolon
)brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|msgs
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|intf-&gt;events_lock
)paren
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Allocate and fill in one message for every user that is getting&n;&t;   events. */
id|list_for_each
c_func
(paren
id|entry
comma
op_amp
(paren
id|intf-&gt;users
)paren
)paren
(brace
id|user
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|ipmi_user
comma
id|link
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|user-&gt;gets_events
)paren
r_continue
suffix:semicolon
id|recv_msg
op_assign
id|ipmi_alloc_recv_msg
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|recv_msg
)paren
(brace
id|list_for_each_safe
c_func
(paren
id|entry
comma
id|entry2
comma
op_amp
id|msgs
)paren
(brace
id|recv_msg
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|ipmi_recv_msg
comma
id|link
)paren
suffix:semicolon
id|list_del
c_func
(paren
id|entry
)paren
suffix:semicolon
id|ipmi_free_recv_msg
c_func
(paren
id|recv_msg
)paren
suffix:semicolon
)brace
multiline_comment|/* We couldn&squot;t allocate memory for the&n;                           message, so requeue it for handling&n;                           later. */
id|rv
op_assign
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|deliver_count
op_increment
suffix:semicolon
id|copy_event_into_recv_msg
c_func
(paren
id|recv_msg
comma
id|msg
)paren
suffix:semicolon
id|recv_msg-&gt;user
op_assign
id|user
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
(paren
id|recv_msg-&gt;link
)paren
comma
op_amp
id|msgs
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|deliver_count
)paren
(brace
multiline_comment|/* Now deliver all the messages. */
id|list_for_each_safe
c_func
(paren
id|entry
comma
id|entry2
comma
op_amp
id|msgs
)paren
(brace
id|recv_msg
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|ipmi_recv_msg
comma
id|link
)paren
suffix:semicolon
id|list_del
c_func
(paren
id|entry
)paren
suffix:semicolon
id|deliver_response
c_func
(paren
id|recv_msg
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|intf-&gt;waiting_events_count
OL
id|MAX_EVENTS_IN_QUEUE
)paren
(brace
multiline_comment|/* No one to receive the message, put it in queue if there&squot;s&n;&t;&t;   not already too many things in the queue. */
id|recv_msg
op_assign
id|ipmi_alloc_recv_msg
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|recv_msg
)paren
(brace
multiline_comment|/* We couldn&squot;t allocate memory for the&n;                           message, so requeue it for handling&n;                           later. */
id|rv
op_assign
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|copy_event_into_recv_msg
c_func
(paren
id|recv_msg
comma
id|msg
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
(paren
id|recv_msg-&gt;link
)paren
comma
op_amp
(paren
id|intf-&gt;waiting_events
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* There&squot;s too many things in the queue, discard this&n;&t;&t;   message. */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ipmi: Event queue full, discarding an&quot;
l_string|&quot; incoming event&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|intf-&gt;events_lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
DECL|function|handle_bmc_rsp
r_static
r_int
id|handle_bmc_rsp
c_func
(paren
id|ipmi_smi_t
id|intf
comma
r_struct
id|ipmi_smi_msg
op_star
id|msg
)paren
(brace
r_struct
id|ipmi_recv_msg
op_star
id|recv_msg
suffix:semicolon
r_int
id|found
op_assign
l_int|0
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
id|recv_msg
op_assign
(paren
r_struct
id|ipmi_recv_msg
op_star
)paren
id|msg-&gt;user_data
suffix:semicolon
multiline_comment|/* Make sure the user still exists. */
id|list_for_each
c_func
(paren
id|entry
comma
op_amp
(paren
id|intf-&gt;users
)paren
)paren
(brace
r_if
c_cond
(paren
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|ipmi_user
comma
id|link
)paren
op_eq
id|recv_msg-&gt;user
)paren
(brace
multiline_comment|/* Found it, so we can deliver it */
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
multiline_comment|/* The user for the message went away, so give up. */
id|ipmi_free_recv_msg
c_func
(paren
id|recv_msg
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|ipmi_system_interface_addr
op_star
id|smi_addr
suffix:semicolon
id|recv_msg-&gt;recv_type
op_assign
id|IPMI_RESPONSE_RECV_TYPE
suffix:semicolon
id|recv_msg-&gt;msgid
op_assign
id|msg-&gt;msgid
suffix:semicolon
id|smi_addr
op_assign
(paren
(paren
r_struct
id|ipmi_system_interface_addr
op_star
)paren
op_amp
(paren
id|recv_msg-&gt;addr
)paren
)paren
suffix:semicolon
id|smi_addr-&gt;addr_type
op_assign
id|IPMI_SYSTEM_INTERFACE_ADDR_TYPE
suffix:semicolon
id|smi_addr-&gt;channel
op_assign
id|IPMI_BMC_CHANNEL
suffix:semicolon
id|smi_addr-&gt;lun
op_assign
id|msg-&gt;rsp
(braket
l_int|0
)braket
op_amp
l_int|3
suffix:semicolon
id|recv_msg-&gt;msg.netfn
op_assign
id|msg-&gt;rsp
(braket
l_int|0
)braket
op_rshift
l_int|2
suffix:semicolon
id|recv_msg-&gt;msg.cmd
op_assign
id|msg-&gt;rsp
(braket
l_int|1
)braket
suffix:semicolon
id|memcpy
c_func
(paren
id|recv_msg-&gt;msg_data
comma
op_amp
(paren
id|msg-&gt;rsp
(braket
l_int|2
)braket
)paren
comma
id|msg-&gt;rsp_size
op_minus
l_int|2
)paren
suffix:semicolon
id|recv_msg-&gt;msg.data
op_assign
id|recv_msg-&gt;msg_data
suffix:semicolon
id|recv_msg-&gt;msg.data_len
op_assign
id|msg-&gt;rsp_size
op_minus
l_int|2
suffix:semicolon
id|deliver_response
c_func
(paren
id|recv_msg
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Handle a new message.  Return 1 if the message should be requeued,&n;   0 if the message should be freed, or -1 if the message should not&n;   be freed or requeued. */
DECL|function|handle_new_recv_msg
r_static
r_int
id|handle_new_recv_msg
c_func
(paren
id|ipmi_smi_t
id|intf
comma
r_struct
id|ipmi_smi_msg
op_star
id|msg
)paren
(brace
r_int
id|requeue
suffix:semicolon
r_if
c_cond
(paren
id|msg-&gt;rsp_size
OL
l_int|2
)paren
(brace
multiline_comment|/* Message is too small to be correct. */
id|requeue
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|msg-&gt;rsp
(braket
l_int|1
)braket
op_eq
id|IPMI_GET_MSG_CMD
)paren
(brace
macro_line|#if DEBUG_MSGING
r_int
id|m
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Response:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
l_int|0
suffix:semicolon
id|m
OL
id|msg-&gt;rsp_size
suffix:semicolon
id|m
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %2.2x&quot;
comma
id|msg-&gt;rsp
(braket
id|m
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* It&squot;s from the receive queue. */
r_if
c_cond
(paren
id|msg-&gt;rsp
(braket
l_int|4
)braket
op_amp
l_int|0x04
)paren
(brace
multiline_comment|/* It&squot;s a response, so find the&n;&t;&t;&t;   requesting message and send it up. */
id|requeue
op_assign
id|handle_get_msg_rsp
c_func
(paren
id|intf
comma
id|msg
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* It&squot;s a command to the SMS from some other&n;&t;&t;&t;   entity.  Handle that. */
id|requeue
op_assign
id|handle_get_msg_cmd
c_func
(paren
id|intf
comma
id|msg
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|msg-&gt;rsp
(braket
l_int|1
)braket
op_eq
id|IPMI_READ_EVENT_MSG_BUFFER_CMD
)paren
(brace
multiline_comment|/* It&squot;s an asyncronous event. */
id|requeue
op_assign
id|handle_read_event_rsp
c_func
(paren
id|intf
comma
id|msg
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* It&squot;s a response from the local BMC. */
id|requeue
op_assign
id|handle_bmc_rsp
c_func
(paren
id|intf
comma
id|msg
)paren
suffix:semicolon
)brace
r_return
id|requeue
suffix:semicolon
)brace
multiline_comment|/* Handle a new message from the lower layer. */
DECL|function|ipmi_smi_msg_received
r_void
id|ipmi_smi_msg_received
c_func
(paren
id|ipmi_smi_t
id|intf
comma
r_struct
id|ipmi_smi_msg
op_star
id|msg
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|rv
suffix:semicolon
multiline_comment|/* Lock the user lock so the user can&squot;t go away while we are&n;&t;   working on it. */
id|read_lock
c_func
(paren
op_amp
(paren
id|intf-&gt;users_lock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|msg-&gt;data_size
op_ge
l_int|2
)paren
op_logical_and
(paren
id|msg-&gt;data
(braket
l_int|1
)braket
op_eq
id|IPMI_SEND_MSG_CMD
)paren
)paren
(brace
multiline_comment|/* This is the local response to a send, start the&n;                   timer for these. */
id|intf_start_seq_timer
c_func
(paren
id|intf
comma
id|msg-&gt;msgid
)paren
suffix:semicolon
id|ipmi_free_smi_msg
c_func
(paren
id|msg
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* To preserve message order, if the list is not empty, we&n;           tack this message onto the end of the list. */
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|intf-&gt;waiting_msgs_lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
(paren
id|intf-&gt;waiting_msgs
)paren
)paren
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
(paren
id|msg-&gt;link
)paren
comma
op_amp
(paren
id|intf-&gt;waiting_msgs
)paren
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
(paren
id|intf-&gt;waiting_msgs_lock
)paren
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|intf-&gt;waiting_msgs_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|rv
op_assign
id|handle_new_recv_msg
c_func
(paren
id|intf
comma
id|msg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
OG
l_int|0
)paren
(brace
multiline_comment|/* Could not handle the message now, just add it to a&n;                   list to handle later. */
id|spin_lock
c_func
(paren
op_amp
(paren
id|intf-&gt;waiting_msgs_lock
)paren
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
(paren
id|msg-&gt;link
)paren
comma
op_amp
(paren
id|intf-&gt;waiting_msgs
)paren
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
(paren
id|intf-&gt;waiting_msgs_lock
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rv
op_eq
l_int|0
)paren
(brace
id|ipmi_free_smi_msg
c_func
(paren
id|msg
)paren
suffix:semicolon
)brace
id|out_unlock
suffix:colon
id|read_unlock
c_func
(paren
op_amp
(paren
id|intf-&gt;users_lock
)paren
)paren
suffix:semicolon
)brace
DECL|function|ipmi_smi_watchdog_pretimeout
r_void
id|ipmi_smi_watchdog_pretimeout
c_func
(paren
id|ipmi_smi_t
id|intf
)paren
(brace
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
id|ipmi_user_t
id|user
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
(paren
id|intf-&gt;users_lock
)paren
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|entry
comma
op_amp
(paren
id|intf-&gt;users
)paren
)paren
(brace
id|user
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|ipmi_user
comma
id|link
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|user-&gt;handler-&gt;ipmi_watchdog_pretimeout
)paren
r_continue
suffix:semicolon
id|user-&gt;handler
op_member_access_from_pointer
id|ipmi_watchdog_pretimeout
c_func
(paren
id|user-&gt;handler_data
)paren
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
(paren
id|intf-&gt;users_lock
)paren
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|handle_msg_timeout
id|handle_msg_timeout
c_func
(paren
r_struct
id|ipmi_recv_msg
op_star
id|msg
)paren
(brace
id|msg-&gt;recv_type
op_assign
id|IPMI_RESPONSE_RECV_TYPE
suffix:semicolon
id|msg-&gt;msg_data
(braket
l_int|0
)braket
op_assign
id|IPMI_TIMEOUT_COMPLETION_CODE
suffix:semicolon
id|msg-&gt;msg.netfn
op_or_assign
l_int|1
suffix:semicolon
multiline_comment|/* Convert to a response. */
id|msg-&gt;msg.data_len
op_assign
l_int|1
suffix:semicolon
id|msg-&gt;msg.data
op_assign
id|msg-&gt;msg_data
suffix:semicolon
id|deliver_response
c_func
(paren
id|msg
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|send_from_recv_msg
id|send_from_recv_msg
c_func
(paren
id|ipmi_smi_t
id|intf
comma
r_struct
id|ipmi_recv_msg
op_star
id|recv_msg
comma
r_struct
id|ipmi_smi_msg
op_star
id|smi_msg
comma
r_int
r_char
id|seq
comma
r_int
id|seqid
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|smi_msg
)paren
id|smi_msg
op_assign
id|ipmi_alloc_smi_msg
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|smi_msg
)paren
multiline_comment|/* If we can&squot;t allocate the message, then just return, we&n;&t;&t;   get 4 retries, so this should be ok. */
r_return
suffix:semicolon
id|memcpy
c_func
(paren
id|smi_msg-&gt;data
comma
id|recv_msg-&gt;msg.data
comma
id|recv_msg-&gt;msg.data_len
)paren
suffix:semicolon
id|smi_msg-&gt;data_size
op_assign
id|recv_msg-&gt;msg.data_len
suffix:semicolon
id|smi_msg-&gt;msgid
op_assign
id|STORE_SEQ_IN_MSGID
c_func
(paren
id|seq
comma
id|seqid
)paren
suffix:semicolon
multiline_comment|/* Send the new message.  We send with a zero priority.  It&n;&t;   timed out, I doubt time is that critical now, and high&n;&t;   priority messages are really only for messages to the local&n;&t;   MC, which don&squot;t get resent. */
id|intf-&gt;handlers
op_member_access_from_pointer
id|sender
c_func
(paren
id|intf-&gt;send_info
comma
id|smi_msg
comma
l_int|0
)paren
suffix:semicolon
macro_line|#if DEBUG_MSGING
(brace
r_int
id|m
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Resend: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
l_int|0
suffix:semicolon
id|m
OL
id|smi_msg-&gt;data_size
suffix:semicolon
id|m
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %2.2x&quot;
comma
id|smi_msg-&gt;data
(braket
id|m
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
r_static
r_void
DECL|function|ipmi_timeout_handler
id|ipmi_timeout_handler
c_func
(paren
r_int
id|timeout_period
)paren
(brace
id|ipmi_smi_t
id|intf
suffix:semicolon
r_struct
id|list_head
id|timeouts
suffix:semicolon
r_struct
id|ipmi_recv_msg
op_star
id|msg
suffix:semicolon
r_struct
id|ipmi_smi_msg
op_star
id|smi_msg
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
comma
op_star
id|entry2
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|timeouts
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|interfaces_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_IPMI_INTERFACES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|intf
op_assign
id|ipmi_interfaces
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|intf
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
(paren
id|intf-&gt;users_lock
)paren
)paren
suffix:semicolon
multiline_comment|/* See if any waiting messages need to be processed. */
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|intf-&gt;waiting_msgs_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|entry
comma
id|entry2
comma
op_amp
(paren
id|intf-&gt;waiting_msgs
)paren
)paren
(brace
id|smi_msg
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|ipmi_smi_msg
comma
id|link
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handle_new_recv_msg
c_func
(paren
id|intf
comma
id|smi_msg
)paren
)paren
(brace
id|list_del
c_func
(paren
id|entry
)paren
suffix:semicolon
id|ipmi_free_smi_msg
c_func
(paren
id|smi_msg
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* To preserve message order, quit if we&n;&t;&t;&t;&t;   can&squot;t handle a message. */
r_break
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|intf-&gt;waiting_msgs_lock
)paren
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Go through the seq table and find any messages that&n;&t;&t;   have timed out, putting them in the timeouts&n;&t;&t;   list. */
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|intf-&gt;seq_lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|IPMI_IPMB_NUM_SEQ
suffix:semicolon
id|j
op_increment
)paren
(brace
r_struct
id|seq_table
op_star
id|ent
op_assign
op_amp
(paren
id|intf-&gt;seq_table
(braket
id|j
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ent-&gt;inuse
)paren
r_continue
suffix:semicolon
id|ent-&gt;timeout
op_sub_assign
id|timeout_period
suffix:semicolon
r_if
c_cond
(paren
id|ent-&gt;timeout
OG
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|ent-&gt;retries_left
op_eq
l_int|0
)paren
(brace
multiline_comment|/* The message has used all its retries. */
id|ent-&gt;inuse
op_assign
l_int|0
suffix:semicolon
id|msg
op_assign
id|ent-&gt;recv_msg
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
(paren
id|msg-&gt;link
)paren
comma
op_amp
id|timeouts
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* More retries, send again. */
multiline_comment|/* Start with the max timer, set to normal&n;&t;&t;&t;&t;   timer after the message is sent. */
id|ent-&gt;timeout
op_assign
id|MAX_MSG_TIMEOUT
suffix:semicolon
id|ent-&gt;retries_left
op_decrement
suffix:semicolon
id|send_from_recv_msg
c_func
(paren
id|intf
comma
id|ent-&gt;recv_msg
comma
l_int|NULL
comma
id|j
comma
id|ent-&gt;seqid
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|intf-&gt;seq_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|entry
comma
id|entry2
comma
op_amp
id|timeouts
)paren
(brace
id|msg
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|ipmi_recv_msg
comma
id|link
)paren
suffix:semicolon
id|handle_msg_timeout
c_func
(paren
id|msg
)paren
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
(paren
id|intf-&gt;users_lock
)paren
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|interfaces_lock
)paren
suffix:semicolon
)brace
DECL|function|ipmi_request_event
r_static
r_void
id|ipmi_request_event
c_func
(paren
r_void
)paren
(brace
id|ipmi_smi_t
id|intf
suffix:semicolon
r_int
id|i
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|interfaces_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_IPMI_INTERFACES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|intf
op_assign
id|ipmi_interfaces
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|intf
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|intf-&gt;handlers
op_member_access_from_pointer
id|request_events
c_func
(paren
id|intf-&gt;send_info
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|interfaces_lock
)paren
suffix:semicolon
)brace
DECL|variable|ipmi_timer
r_static
r_struct
id|timer_list
id|ipmi_timer
suffix:semicolon
multiline_comment|/* Call every 100 ms. */
DECL|macro|IPMI_TIMEOUT_TIME
mdefine_line|#define IPMI_TIMEOUT_TIME&t;100
DECL|macro|IPMI_TIMEOUT_JIFFIES
mdefine_line|#define IPMI_TIMEOUT_JIFFIES&t;(IPMI_TIMEOUT_TIME/(1000/HZ))
multiline_comment|/* Request events from the queue every second.  Hopefully, in the&n;   future, IPMI will add a way to know immediately if an event is&n;   in the queue. */
DECL|macro|IPMI_REQUEST_EV_TIME
mdefine_line|#define IPMI_REQUEST_EV_TIME&t;(1000 / (IPMI_TIMEOUT_TIME))
DECL|variable|stop_operation
r_static
r_volatile
r_int
id|stop_operation
op_assign
l_int|0
suffix:semicolon
DECL|variable|timer_stopped
r_static
r_volatile
r_int
id|timer_stopped
op_assign
l_int|0
suffix:semicolon
DECL|variable|ticks_to_req_ev
r_static
r_int
r_int
id|ticks_to_req_ev
op_assign
id|IPMI_REQUEST_EV_TIME
suffix:semicolon
DECL|function|ipmi_timeout
r_static
r_void
id|ipmi_timeout
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_if
c_cond
(paren
id|stop_operation
)paren
(brace
id|timer_stopped
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ticks_to_req_ev
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|ticks_to_req_ev
op_eq
l_int|0
)paren
(brace
id|ipmi_request_event
c_func
(paren
)paren
suffix:semicolon
id|ticks_to_req_ev
op_assign
id|IPMI_REQUEST_EV_TIME
suffix:semicolon
)brace
id|ipmi_timeout_handler
c_func
(paren
id|IPMI_TIMEOUT_TIME
)paren
suffix:semicolon
id|ipmi_timer.expires
op_add_assign
id|IPMI_TIMEOUT_JIFFIES
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|ipmi_timer
)paren
suffix:semicolon
)brace
multiline_comment|/* FIXME - convert these to slabs. */
DECL|function|free_smi_msg
r_static
r_void
id|free_smi_msg
c_func
(paren
r_struct
id|ipmi_smi_msg
op_star
id|msg
)paren
(brace
id|kfree
c_func
(paren
id|msg
)paren
suffix:semicolon
)brace
DECL|function|ipmi_alloc_smi_msg
r_struct
id|ipmi_smi_msg
op_star
id|ipmi_alloc_smi_msg
c_func
(paren
r_void
)paren
(brace
r_struct
id|ipmi_smi_msg
op_star
id|rv
suffix:semicolon
id|rv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ipmi_smi_msg
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
id|rv-&gt;done
op_assign
id|free_smi_msg
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
DECL|function|free_recv_msg
r_static
r_void
id|free_recv_msg
c_func
(paren
r_struct
id|ipmi_recv_msg
op_star
id|msg
)paren
(brace
id|kfree
c_func
(paren
id|msg
)paren
suffix:semicolon
)brace
DECL|function|ipmi_alloc_recv_msg
r_struct
id|ipmi_recv_msg
op_star
id|ipmi_alloc_recv_msg
c_func
(paren
r_void
)paren
(brace
r_struct
id|ipmi_recv_msg
op_star
id|rv
suffix:semicolon
id|rv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ipmi_recv_msg
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
id|rv-&gt;done
op_assign
id|free_recv_msg
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_IPMI_PANIC_EVENT
DECL|function|dummy_smi_done_handler
r_static
r_void
id|dummy_smi_done_handler
c_func
(paren
r_struct
id|ipmi_smi_msg
op_star
id|msg
)paren
(brace
)brace
DECL|function|dummy_recv_done_handler
r_static
r_void
id|dummy_recv_done_handler
c_func
(paren
r_struct
id|ipmi_recv_msg
op_star
id|msg
)paren
(brace
)brace
DECL|function|send_panic_events
r_static
r_void
id|send_panic_events
c_func
(paren
r_void
)paren
(brace
r_struct
id|ipmi_msg
id|msg
suffix:semicolon
id|ipmi_smi_t
id|intf
suffix:semicolon
r_int
r_char
id|data
(braket
l_int|8
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|ipmi_system_interface_addr
id|addr
suffix:semicolon
r_struct
id|ipmi_smi_msg
id|smi_msg
suffix:semicolon
r_struct
id|ipmi_recv_msg
id|recv_msg
suffix:semicolon
id|addr.addr_type
op_assign
id|IPMI_SYSTEM_INTERFACE_ADDR_TYPE
suffix:semicolon
id|addr.channel
op_assign
id|IPMI_BMC_CHANNEL
suffix:semicolon
multiline_comment|/* Fill in an event telling that we have failed. */
id|msg.netfn
op_assign
l_int|0x04
suffix:semicolon
multiline_comment|/* Sensor or Event. */
id|msg.cmd
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* Platform event command. */
id|msg.data
op_assign
id|data
suffix:semicolon
id|msg.data_len
op_assign
l_int|8
suffix:semicolon
id|data
(braket
l_int|0
)braket
op_assign
l_int|0x21
suffix:semicolon
multiline_comment|/* Kernel generator ID, IPMI table 5-4 */
id|data
(braket
l_int|1
)braket
op_assign
l_int|0x03
suffix:semicolon
multiline_comment|/* This is for IPMI 1.0. */
id|data
(braket
l_int|2
)braket
op_assign
l_int|0x20
suffix:semicolon
multiline_comment|/* OS Critical Stop, IPMI table 36-3 */
id|data
(braket
l_int|4
)braket
op_assign
l_int|0x6f
suffix:semicolon
multiline_comment|/* Sensor specific, IPMI table 36-1 */
id|data
(braket
l_int|5
)braket
op_assign
l_int|0xa1
suffix:semicolon
multiline_comment|/* Runtime stop OEM bytes 2 &amp; 3. */
multiline_comment|/* These used to have the first three bytes of the panic string,&n;&t;   but not only is that not terribly useful, it&squot;s not available&n;&t;   any more. */
id|data
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|data
(braket
l_int|6
)braket
op_assign
l_int|0
suffix:semicolon
id|data
(braket
l_int|7
)braket
op_assign
l_int|0
suffix:semicolon
id|smi_msg.done
op_assign
id|dummy_smi_done_handler
suffix:semicolon
id|recv_msg.done
op_assign
id|dummy_recv_done_handler
suffix:semicolon
multiline_comment|/* For every registered interface, send the event. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_IPMI_INTERFACES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|intf
op_assign
id|ipmi_interfaces
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|intf
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|intf-&gt;handlers
op_member_access_from_pointer
id|set_run_to_completion
c_func
(paren
id|intf-&gt;send_info
comma
l_int|1
)paren
suffix:semicolon
id|i_ipmi_request
c_func
(paren
l_int|NULL
comma
id|intf
comma
(paren
r_struct
id|ipmi_addr
op_star
)paren
op_amp
id|addr
comma
l_int|0
comma
op_amp
id|msg
comma
op_amp
id|smi_msg
comma
op_amp
id|recv_msg
comma
l_int|0
comma
id|intf-&gt;my_address
comma
id|intf-&gt;my_lun
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* CONFIG_IPMI_PANIC_EVENT */
DECL|variable|has_paniced
r_static
r_int
id|has_paniced
op_assign
l_int|0
suffix:semicolon
DECL|function|panic_event
r_static
r_int
id|panic_event
c_func
(paren
r_struct
id|notifier_block
op_star
id|this
comma
r_int
r_int
id|event
comma
r_void
op_star
id|ptr
)paren
(brace
r_int
id|i
suffix:semicolon
id|ipmi_smi_t
id|intf
suffix:semicolon
r_if
c_cond
(paren
id|has_paniced
)paren
r_return
id|NOTIFY_DONE
suffix:semicolon
id|has_paniced
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* For every registered interface, set it to run to completion. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_IPMI_INTERFACES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|intf
op_assign
id|ipmi_interfaces
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|intf
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|intf-&gt;handlers
op_member_access_from_pointer
id|set_run_to_completion
c_func
(paren
id|intf-&gt;send_info
comma
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_IPMI_PANIC_EVENT
id|send_panic_events
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
DECL|variable|panic_block
r_static
r_struct
id|notifier_block
id|panic_block
op_assign
(brace
id|panic_event
comma
l_int|NULL
comma
l_int|200
multiline_comment|/* priority: INT_MAX &gt;= x &gt;= 0 */
)brace
suffix:semicolon
DECL|function|ipmi_init_msghandler
r_static
id|__init
r_int
id|ipmi_init_msghandler
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|initialized
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_IPMI_INTERFACES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ipmi_interfaces
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
id|init_timer
c_func
(paren
op_amp
id|ipmi_timer
)paren
suffix:semicolon
id|ipmi_timer.data
op_assign
l_int|0
suffix:semicolon
id|ipmi_timer.function
op_assign
id|ipmi_timeout
suffix:semicolon
id|ipmi_timer.expires
op_assign
id|jiffies
op_plus
id|IPMI_TIMEOUT_JIFFIES
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|ipmi_timer
)paren
suffix:semicolon
id|notifier_chain_register
c_func
(paren
op_amp
id|panic_notifier_list
comma
op_amp
id|panic_block
)paren
suffix:semicolon
id|initialized
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ipmi: message handler initialized&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_ipmi
r_static
id|__exit
r_void
id|cleanup_ipmi
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|initialized
)paren
r_return
suffix:semicolon
id|notifier_chain_unregister
c_func
(paren
op_amp
id|panic_notifier_list
comma
op_amp
id|panic_block
)paren
suffix:semicolon
multiline_comment|/* This can&squot;t be called if any interfaces exist, so no worry about&n;&t;   shutting down the interfaces. */
multiline_comment|/* Tell the timer to stop, then wait for it to stop.  This avoids&n;&t;   problems with race conditions removing the timer here. */
id|stop_operation
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|timer_stopped
)paren
(brace
id|schedule_timeout
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|initialized
op_assign
l_int|0
suffix:semicolon
)brace
DECL|variable|cleanup_ipmi
id|module_exit
c_func
(paren
id|cleanup_ipmi
)paren
suffix:semicolon
DECL|variable|ipmi_init_msghandler
id|module_init
c_func
(paren
id|ipmi_init_msghandler
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|variable|ipmi_alloc_recv_msg
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_alloc_recv_msg
)paren
suffix:semicolon
DECL|variable|ipmi_create_user
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_create_user
)paren
suffix:semicolon
DECL|variable|ipmi_destroy_user
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_destroy_user
)paren
suffix:semicolon
DECL|variable|ipmi_get_version
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_get_version
)paren
suffix:semicolon
DECL|variable|ipmi_request
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_request
)paren
suffix:semicolon
DECL|variable|ipmi_request_supply_msgs
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_request_supply_msgs
)paren
suffix:semicolon
DECL|variable|ipmi_request_with_source
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_request_with_source
)paren
suffix:semicolon
DECL|variable|ipmi_register_smi
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_register_smi
)paren
suffix:semicolon
DECL|variable|ipmi_unregister_smi
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_unregister_smi
)paren
suffix:semicolon
DECL|variable|ipmi_register_for_cmd
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_register_for_cmd
)paren
suffix:semicolon
DECL|variable|ipmi_unregister_for_cmd
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_unregister_for_cmd
)paren
suffix:semicolon
DECL|variable|ipmi_smi_msg_received
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_smi_msg_received
)paren
suffix:semicolon
DECL|variable|ipmi_smi_watchdog_pretimeout
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_smi_watchdog_pretimeout
)paren
suffix:semicolon
DECL|variable|ipmi_alloc_smi_msg
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_alloc_smi_msg
)paren
suffix:semicolon
DECL|variable|ipmi_register_all_cmd_rcvr
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_register_all_cmd_rcvr
)paren
suffix:semicolon
DECL|variable|ipmi_unregister_all_cmd_rcvr
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_unregister_all_cmd_rcvr
)paren
suffix:semicolon
DECL|variable|ipmi_addr_length
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_addr_length
)paren
suffix:semicolon
DECL|variable|ipmi_validate_addr
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_validate_addr
)paren
suffix:semicolon
DECL|variable|ipmi_set_gets_events
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_set_gets_events
)paren
suffix:semicolon
DECL|variable|ipmi_addr_equal
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_addr_equal
)paren
suffix:semicolon
DECL|variable|ipmi_smi_watcher_register
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_smi_watcher_register
)paren
suffix:semicolon
DECL|variable|ipmi_smi_watcher_unregister
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_smi_watcher_unregister
)paren
suffix:semicolon
DECL|variable|ipmi_set_my_address
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_set_my_address
)paren
suffix:semicolon
DECL|variable|ipmi_get_my_address
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_get_my_address
)paren
suffix:semicolon
DECL|variable|ipmi_set_my_LUN
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_set_my_LUN
)paren
suffix:semicolon
DECL|variable|ipmi_get_my_LUN
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_get_my_LUN
)paren
suffix:semicolon
eof
