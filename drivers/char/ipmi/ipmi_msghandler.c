multiline_comment|/*&n; * ipmi_msghandler.c&n; *&n; * Incoming and outgoing message routing for an IPMI interface.&n; *&n; * Author: MontaVista Software, Inc.&n; *         Corey Minyard &lt;minyard@mvista.com&gt;&n; *         source@mvista.com&n; *&n; * Copyright 2002 MontaVista Software Inc.&n; *&n; *  This program is free software; you can redistribute it and/or modify it&n; *  under the terms of the GNU General Public License as published by the&n; *  Free Software Foundation; either version 2 of the License, or (at your&n; *  option) any later version.&n; *&n; *&n; *  THIS SOFTWARE IS PROVIDED ``AS IS&squot;&squot; AND ANY EXPRESS OR IMPLIED&n; *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&n; *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.&n; *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,&n; *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,&n; *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS&n; *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND&n; *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR&n; *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE&n; *  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n; *&n; *  You should have received a copy of the GNU General Public License along&n; *  with this program; if not, write to the Free Software Foundation, Inc.,&n; *  675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/rwsem.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/ipmi.h&gt;
macro_line|#include &lt;linux/ipmi_smi.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
DECL|macro|PFX
mdefine_line|#define PFX &quot;IPMI message handler: &quot;
DECL|macro|IPMI_MSGHANDLER_VERSION
mdefine_line|#define IPMI_MSGHANDLER_VERSION &quot;v33&quot;
r_struct
id|ipmi_recv_msg
op_star
id|ipmi_alloc_recv_msg
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|ipmi_init_msghandler
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|initialized
r_static
r_int
id|initialized
op_assign
l_int|0
suffix:semicolon
DECL|variable|proc_ipmi_root
r_static
r_struct
id|proc_dir_entry
op_star
id|proc_ipmi_root
op_assign
l_int|NULL
suffix:semicolon
DECL|macro|MAX_EVENTS_IN_QUEUE
mdefine_line|#define MAX_EVENTS_IN_QUEUE&t;25
multiline_comment|/* Don&squot;t let a message sit in a queue forever, always time it with at lest&n;   the max message timer.  This is in milliseconds. */
DECL|macro|MAX_MSG_TIMEOUT
mdefine_line|#define MAX_MSG_TIMEOUT&t;&t;60000
DECL|struct|ipmi_user
r_struct
id|ipmi_user
(brace
DECL|member|link
r_struct
id|list_head
id|link
suffix:semicolon
multiline_comment|/* The upper layer that handles receive messages. */
DECL|member|handler
r_struct
id|ipmi_user_hndl
op_star
id|handler
suffix:semicolon
DECL|member|handler_data
r_void
op_star
id|handler_data
suffix:semicolon
multiline_comment|/* The interface this user is bound to. */
DECL|member|intf
id|ipmi_smi_t
id|intf
suffix:semicolon
multiline_comment|/* Does this interface receive IPMI events? */
DECL|member|gets_events
r_int
id|gets_events
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|cmd_rcvr
r_struct
id|cmd_rcvr
(brace
DECL|member|link
r_struct
id|list_head
id|link
suffix:semicolon
DECL|member|user
id|ipmi_user_t
id|user
suffix:semicolon
DECL|member|netfn
r_int
r_char
id|netfn
suffix:semicolon
DECL|member|cmd
r_int
r_char
id|cmd
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|seq_table
r_struct
id|seq_table
(brace
DECL|member|inuse
r_int
r_int
id|inuse
suffix:colon
l_int|1
suffix:semicolon
DECL|member|broadcast
r_int
r_int
id|broadcast
suffix:colon
l_int|1
suffix:semicolon
DECL|member|timeout
r_int
r_int
id|timeout
suffix:semicolon
DECL|member|orig_timeout
r_int
r_int
id|orig_timeout
suffix:semicolon
DECL|member|retries_left
r_int
r_int
id|retries_left
suffix:semicolon
multiline_comment|/* To verify on an incoming send message response that this is&n;           the message that the response is for, we keep a sequence id&n;           and increment it every time we send a message. */
DECL|member|seqid
r_int
id|seqid
suffix:semicolon
multiline_comment|/* This is held so we can properly respond to the message on a&n;           timeout, and it is used to hold the temporary data for&n;           retransmission, too. */
DECL|member|recv_msg
r_struct
id|ipmi_recv_msg
op_star
id|recv_msg
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Store the information in a msgid (long) to allow us to find a&n;   sequence table entry from the msgid. */
DECL|macro|STORE_SEQ_IN_MSGID
mdefine_line|#define STORE_SEQ_IN_MSGID(seq, seqid) (((seq&amp;0xff)&lt;&lt;26) | (seqid&amp;0x3ffffff))
DECL|macro|GET_SEQ_FROM_MSGID
mdefine_line|#define GET_SEQ_FROM_MSGID(msgid, seq, seqid) &bslash;&n;&t;do {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;seq = ((msgid &gt;&gt; 26) &amp; 0x3f);&t;&t;&t;&t;&bslash;&n;&t;&t;seqid = (msgid &amp; 0x3fffff);&t;&t;&t;&t;&bslash;&n;        } while(0)
DECL|macro|NEXT_SEQID
mdefine_line|#define NEXT_SEQID(seqid) (((seqid) + 1) &amp; 0x3fffff)
DECL|struct|ipmi_channel
r_struct
id|ipmi_channel
(brace
DECL|member|medium
r_int
r_char
id|medium
suffix:semicolon
DECL|member|protocol
r_int
r_char
id|protocol
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|ipmi_proc_entry
r_struct
id|ipmi_proc_entry
(brace
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|next
r_struct
id|ipmi_proc_entry
op_star
id|next
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|IPMI_IPMB_NUM_SEQ
mdefine_line|#define IPMI_IPMB_NUM_SEQ&t;64
DECL|macro|IPMI_MAX_CHANNELS
mdefine_line|#define IPMI_MAX_CHANNELS       8
DECL|struct|ipmi_smi
r_struct
id|ipmi_smi
(brace
multiline_comment|/* What interface number are we? */
DECL|member|intf_num
r_int
id|intf_num
suffix:semicolon
multiline_comment|/* The list of upper layers that are using me.  We read-lock&n;           this when delivering messages to the upper layer to keep&n;           the user from going away while we are processing the&n;           message.  This means that you cannot add or delete a user&n;           from the receive callback. */
DECL|member|users_lock
id|rwlock_t
id|users_lock
suffix:semicolon
DECL|member|users
r_struct
id|list_head
id|users
suffix:semicolon
multiline_comment|/* Used for wake ups at startup. */
DECL|member|waitq
id|wait_queue_head_t
id|waitq
suffix:semicolon
multiline_comment|/* The IPMI version of the BMC on the other end. */
DECL|member|version_major
r_int
r_char
id|version_major
suffix:semicolon
DECL|member|version_minor
r_int
r_char
id|version_minor
suffix:semicolon
multiline_comment|/* This is the lower-layer&squot;s sender routine. */
DECL|member|handlers
r_struct
id|ipmi_smi_handlers
op_star
id|handlers
suffix:semicolon
DECL|member|send_info
r_void
op_star
id|send_info
suffix:semicolon
multiline_comment|/* A list of proc entries for this interface.  This does not&n;&t;   need a lock, only one thread creates it and only one thread&n;&t;   destroys it. */
DECL|member|proc_entries
r_struct
id|ipmi_proc_entry
op_star
id|proc_entries
suffix:semicolon
multiline_comment|/* A table of sequence numbers for this interface.  We use the&n;           sequence numbers for IPMB messages that go out of the&n;           interface to match them up with their responses.  A routine&n;           is called periodically to time the items in this list. */
DECL|member|seq_lock
id|spinlock_t
id|seq_lock
suffix:semicolon
DECL|member|seq_table
r_struct
id|seq_table
id|seq_table
(braket
id|IPMI_IPMB_NUM_SEQ
)braket
suffix:semicolon
DECL|member|curr_seq
r_int
id|curr_seq
suffix:semicolon
multiline_comment|/* Messages that were delayed for some reason (out of memory,&n;           for instance), will go in here to be processed later in a&n;           periodic timer interrupt. */
DECL|member|waiting_msgs_lock
id|spinlock_t
id|waiting_msgs_lock
suffix:semicolon
DECL|member|waiting_msgs
r_struct
id|list_head
id|waiting_msgs
suffix:semicolon
multiline_comment|/* The list of command receivers that are registered for commands&n;&t;   on this interface. */
DECL|member|cmd_rcvr_lock
id|rwlock_t
id|cmd_rcvr_lock
suffix:semicolon
DECL|member|cmd_rcvrs
r_struct
id|list_head
id|cmd_rcvrs
suffix:semicolon
multiline_comment|/* Events that were queues because no one was there to receive&n;           them. */
DECL|member|events_lock
id|spinlock_t
id|events_lock
suffix:semicolon
multiline_comment|/* For dealing with event stuff. */
DECL|member|waiting_events
r_struct
id|list_head
id|waiting_events
suffix:semicolon
DECL|member|waiting_events_count
r_int
r_int
id|waiting_events_count
suffix:semicolon
multiline_comment|/* How many events in queue? */
multiline_comment|/* This will be non-null if someone registers to receive all&n;&t;   IPMI commands (this is for interface emulation).  There&n;&t;   may not be any things in the cmd_rcvrs list above when&n;&t;   this is registered. */
DECL|member|all_cmd_rcvr
id|ipmi_user_t
id|all_cmd_rcvr
suffix:semicolon
multiline_comment|/* My slave address.  This is initialized to IPMI_BMC_SLAVE_ADDR,&n;&t;   but may be changed by the user. */
DECL|member|my_address
r_int
r_char
id|my_address
suffix:semicolon
multiline_comment|/* My LUN.  This should generally stay the SMS LUN, but just in&n;&t;   case... */
DECL|member|my_lun
r_int
r_char
id|my_lun
suffix:semicolon
multiline_comment|/* The event receiver for my BMC, only really used at panic&n;&t;   shutdown as a place to store this. */
DECL|member|event_receiver
r_int
r_char
id|event_receiver
suffix:semicolon
DECL|member|event_receiver_lun
r_int
r_char
id|event_receiver_lun
suffix:semicolon
DECL|member|local_sel_device
r_int
r_char
id|local_sel_device
suffix:semicolon
DECL|member|local_event_generator
r_int
r_char
id|local_event_generator
suffix:semicolon
multiline_comment|/* A cheap hack, if this is non-null and a message to an&n;&t;   interface comes in with a NULL user, call this routine with&n;&t;   it.  Note that the message will still be freed by the&n;&t;   caller.  This only works on the system interface. */
DECL|member|null_user_handler
r_void
(paren
op_star
id|null_user_handler
)paren
(paren
id|ipmi_smi_t
id|intf
comma
r_struct
id|ipmi_smi_msg
op_star
id|msg
)paren
suffix:semicolon
multiline_comment|/* When we are scanning the channels for an SMI, this will&n;&t;   tell which channel we are scanning. */
DECL|member|curr_channel
r_int
id|curr_channel
suffix:semicolon
multiline_comment|/* Channel information */
DECL|member|channels
r_struct
id|ipmi_channel
id|channels
(braket
id|IPMI_MAX_CHANNELS
)braket
suffix:semicolon
multiline_comment|/* Proc FS stuff. */
DECL|member|proc_dir
r_struct
id|proc_dir_entry
op_star
id|proc_dir
suffix:semicolon
DECL|member|proc_dir_name
r_char
id|proc_dir_name
(braket
l_int|10
)braket
suffix:semicolon
DECL|member|counter_lock
id|spinlock_t
id|counter_lock
suffix:semicolon
multiline_comment|/* For making counters atomic. */
multiline_comment|/* Commands we got that were invalid. */
DECL|member|sent_invalid_commands
r_int
r_int
id|sent_invalid_commands
suffix:semicolon
multiline_comment|/* Commands we sent to the MC. */
DECL|member|sent_local_commands
r_int
r_int
id|sent_local_commands
suffix:semicolon
multiline_comment|/* Responses from the MC that were delivered to a user. */
DECL|member|handled_local_responses
r_int
r_int
id|handled_local_responses
suffix:semicolon
multiline_comment|/* Responses from the MC that were not delivered to a user. */
DECL|member|unhandled_local_responses
r_int
r_int
id|unhandled_local_responses
suffix:semicolon
multiline_comment|/* Commands we sent out to the IPMB bus. */
DECL|member|sent_ipmb_commands
r_int
r_int
id|sent_ipmb_commands
suffix:semicolon
multiline_comment|/* Commands sent on the IPMB that had errors on the SEND CMD */
DECL|member|sent_ipmb_command_errs
r_int
r_int
id|sent_ipmb_command_errs
suffix:semicolon
multiline_comment|/* Each retransmit increments this count. */
DECL|member|retransmitted_ipmb_commands
r_int
r_int
id|retransmitted_ipmb_commands
suffix:semicolon
multiline_comment|/* When a message times out (runs out of retransmits) this is&n;           incremented. */
DECL|member|timed_out_ipmb_commands
r_int
r_int
id|timed_out_ipmb_commands
suffix:semicolon
multiline_comment|/* This is like above, but for broadcasts.  Broadcasts are&n;           *not* included in the above count (they are expected to&n;           time out). */
DECL|member|timed_out_ipmb_broadcasts
r_int
r_int
id|timed_out_ipmb_broadcasts
suffix:semicolon
multiline_comment|/* Responses I have sent to the IPMB bus. */
DECL|member|sent_ipmb_responses
r_int
r_int
id|sent_ipmb_responses
suffix:semicolon
multiline_comment|/* The response was delivered to the user. */
DECL|member|handled_ipmb_responses
r_int
r_int
id|handled_ipmb_responses
suffix:semicolon
multiline_comment|/* The response had invalid data in it. */
DECL|member|invalid_ipmb_responses
r_int
r_int
id|invalid_ipmb_responses
suffix:semicolon
multiline_comment|/* The response didn&squot;t have anyone waiting for it. */
DECL|member|unhandled_ipmb_responses
r_int
r_int
id|unhandled_ipmb_responses
suffix:semicolon
multiline_comment|/* Commands we sent out to the IPMB bus. */
DECL|member|sent_lan_commands
r_int
r_int
id|sent_lan_commands
suffix:semicolon
multiline_comment|/* Commands sent on the IPMB that had errors on the SEND CMD */
DECL|member|sent_lan_command_errs
r_int
r_int
id|sent_lan_command_errs
suffix:semicolon
multiline_comment|/* Each retransmit increments this count. */
DECL|member|retransmitted_lan_commands
r_int
r_int
id|retransmitted_lan_commands
suffix:semicolon
multiline_comment|/* When a message times out (runs out of retransmits) this is&n;           incremented. */
DECL|member|timed_out_lan_commands
r_int
r_int
id|timed_out_lan_commands
suffix:semicolon
multiline_comment|/* Responses I have sent to the IPMB bus. */
DECL|member|sent_lan_responses
r_int
r_int
id|sent_lan_responses
suffix:semicolon
multiline_comment|/* The response was delivered to the user. */
DECL|member|handled_lan_responses
r_int
r_int
id|handled_lan_responses
suffix:semicolon
multiline_comment|/* The response had invalid data in it. */
DECL|member|invalid_lan_responses
r_int
r_int
id|invalid_lan_responses
suffix:semicolon
multiline_comment|/* The response didn&squot;t have anyone waiting for it. */
DECL|member|unhandled_lan_responses
r_int
r_int
id|unhandled_lan_responses
suffix:semicolon
multiline_comment|/* The command was delivered to the user. */
DECL|member|handled_commands
r_int
r_int
id|handled_commands
suffix:semicolon
multiline_comment|/* The command had invalid data in it. */
DECL|member|invalid_commands
r_int
r_int
id|invalid_commands
suffix:semicolon
multiline_comment|/* The command didn&squot;t have anyone waiting for it. */
DECL|member|unhandled_commands
r_int
r_int
id|unhandled_commands
suffix:semicolon
multiline_comment|/* Invalid data in an event. */
DECL|member|invalid_events
r_int
r_int
id|invalid_events
suffix:semicolon
multiline_comment|/* Events that were received with the proper format. */
DECL|member|events
r_int
r_int
id|events
suffix:semicolon
)brace
suffix:semicolon
r_int
DECL|function|ipmi_register_all_cmd_rcvr
id|ipmi_register_all_cmd_rcvr
c_func
(paren
id|ipmi_user_t
id|user
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|rv
op_assign
op_minus
id|EBUSY
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;users_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;cmd_rcvr_lock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|user-&gt;intf-&gt;all_cmd_rcvr
op_eq
l_int|NULL
)paren
op_logical_and
(paren
id|list_empty
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;cmd_rcvrs
)paren
)paren
)paren
)paren
(brace
id|user-&gt;intf-&gt;all_cmd_rcvr
op_assign
id|user
suffix:semicolon
id|rv
op_assign
l_int|0
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;cmd_rcvr_lock
)paren
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;users_lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
r_int
DECL|function|ipmi_unregister_all_cmd_rcvr
id|ipmi_unregister_all_cmd_rcvr
c_func
(paren
id|ipmi_user_t
id|user
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|rv
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;users_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;cmd_rcvr_lock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|user-&gt;intf-&gt;all_cmd_rcvr
op_eq
id|user
)paren
(brace
id|user-&gt;intf-&gt;all_cmd_rcvr
op_assign
l_int|NULL
suffix:semicolon
id|rv
op_assign
l_int|0
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;cmd_rcvr_lock
)paren
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;users_lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
DECL|macro|MAX_IPMI_INTERFACES
mdefine_line|#define MAX_IPMI_INTERFACES 4
DECL|variable|ipmi_interfaces
r_static
id|ipmi_smi_t
id|ipmi_interfaces
(braket
id|MAX_IPMI_INTERFACES
)braket
suffix:semicolon
multiline_comment|/* Used to keep interfaces from going away while operations are&n;   operating on interfaces.  Grab read if you are not modifying the&n;   interfaces, write if you are. */
r_static
id|DECLARE_RWSEM
c_func
(paren
id|interfaces_sem
)paren
suffix:semicolon
multiline_comment|/* Directly protects the ipmi_interfaces data structure.  This is&n;   claimed in the timer interrupt. */
DECL|variable|interfaces_lock
r_static
id|spinlock_t
id|interfaces_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* List of watchers that want to know when smi&squot;s are added and&n;   deleted. */
DECL|variable|smi_watchers
r_static
r_struct
id|list_head
id|smi_watchers
op_assign
id|LIST_HEAD_INIT
c_func
(paren
id|smi_watchers
)paren
suffix:semicolon
r_static
id|DECLARE_RWSEM
c_func
(paren
id|smi_watchers_sem
)paren
suffix:semicolon
DECL|function|ipmi_smi_watcher_register
r_int
id|ipmi_smi_watcher_register
c_func
(paren
r_struct
id|ipmi_smi_watcher
op_star
id|watcher
)paren
(brace
r_int
id|i
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|interfaces_sem
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|smi_watchers_sem
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
(paren
id|watcher-&gt;link
)paren
comma
op_amp
id|smi_watchers
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_IPMI_INTERFACES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ipmi_interfaces
(braket
id|i
)braket
op_ne
l_int|NULL
)paren
(brace
id|watcher
op_member_access_from_pointer
id|new_smi
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
)brace
id|up_write
c_func
(paren
op_amp
id|smi_watchers_sem
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|interfaces_sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ipmi_smi_watcher_unregister
r_int
id|ipmi_smi_watcher_unregister
c_func
(paren
r_struct
id|ipmi_smi_watcher
op_star
id|watcher
)paren
(brace
id|down_write
c_func
(paren
op_amp
id|smi_watchers_sem
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
(paren
id|watcher-&gt;link
)paren
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|smi_watchers_sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|call_smi_watchers
id|call_smi_watchers
c_func
(paren
r_int
id|i
)paren
(brace
r_struct
id|ipmi_smi_watcher
op_star
id|w
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|smi_watchers_sem
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|w
comma
op_amp
id|smi_watchers
comma
id|link
)paren
(brace
r_if
c_cond
(paren
id|try_module_get
c_func
(paren
id|w-&gt;owner
)paren
)paren
(brace
id|w
op_member_access_from_pointer
id|new_smi
c_func
(paren
id|i
)paren
suffix:semicolon
id|module_put
c_func
(paren
id|w-&gt;owner
)paren
suffix:semicolon
)brace
)brace
id|up_read
c_func
(paren
op_amp
id|smi_watchers_sem
)paren
suffix:semicolon
)brace
r_int
DECL|function|ipmi_addr_equal
id|ipmi_addr_equal
c_func
(paren
r_struct
id|ipmi_addr
op_star
id|addr1
comma
r_struct
id|ipmi_addr
op_star
id|addr2
)paren
(brace
r_if
c_cond
(paren
id|addr1-&gt;addr_type
op_ne
id|addr2-&gt;addr_type
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|addr1-&gt;channel
op_ne
id|addr2-&gt;channel
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|addr1-&gt;addr_type
op_eq
id|IPMI_SYSTEM_INTERFACE_ADDR_TYPE
)paren
(brace
r_struct
id|ipmi_system_interface_addr
op_star
id|smi_addr1
op_assign
(paren
r_struct
id|ipmi_system_interface_addr
op_star
)paren
id|addr1
suffix:semicolon
r_struct
id|ipmi_system_interface_addr
op_star
id|smi_addr2
op_assign
(paren
r_struct
id|ipmi_system_interface_addr
op_star
)paren
id|addr2
suffix:semicolon
r_return
(paren
id|smi_addr1-&gt;lun
op_eq
id|smi_addr2-&gt;lun
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|addr1-&gt;addr_type
op_eq
id|IPMI_IPMB_ADDR_TYPE
)paren
op_logical_or
(paren
id|addr1-&gt;addr_type
op_eq
id|IPMI_IPMB_BROADCAST_ADDR_TYPE
)paren
)paren
(brace
r_struct
id|ipmi_ipmb_addr
op_star
id|ipmb_addr1
op_assign
(paren
r_struct
id|ipmi_ipmb_addr
op_star
)paren
id|addr1
suffix:semicolon
r_struct
id|ipmi_ipmb_addr
op_star
id|ipmb_addr2
op_assign
(paren
r_struct
id|ipmi_ipmb_addr
op_star
)paren
id|addr2
suffix:semicolon
r_return
(paren
(paren
id|ipmb_addr1-&gt;slave_addr
op_eq
id|ipmb_addr2-&gt;slave_addr
)paren
op_logical_and
(paren
id|ipmb_addr1-&gt;lun
op_eq
id|ipmb_addr2-&gt;lun
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|addr1-&gt;addr_type
op_eq
id|IPMI_LAN_ADDR_TYPE
)paren
(brace
r_struct
id|ipmi_lan_addr
op_star
id|lan_addr1
op_assign
(paren
r_struct
id|ipmi_lan_addr
op_star
)paren
id|addr1
suffix:semicolon
r_struct
id|ipmi_lan_addr
op_star
id|lan_addr2
op_assign
(paren
r_struct
id|ipmi_lan_addr
op_star
)paren
id|addr2
suffix:semicolon
r_return
(paren
(paren
id|lan_addr1-&gt;remote_SWID
op_eq
id|lan_addr2-&gt;remote_SWID
)paren
op_logical_and
(paren
id|lan_addr1-&gt;local_SWID
op_eq
id|lan_addr2-&gt;local_SWID
)paren
op_logical_and
(paren
id|lan_addr1-&gt;session_handle
op_eq
id|lan_addr2-&gt;session_handle
)paren
op_logical_and
(paren
id|lan_addr1-&gt;lun
op_eq
id|lan_addr2-&gt;lun
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|ipmi_validate_addr
r_int
id|ipmi_validate_addr
c_func
(paren
r_struct
id|ipmi_addr
op_star
id|addr
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|len
OL
r_sizeof
(paren
r_struct
id|ipmi_system_interface_addr
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|addr-&gt;addr_type
op_eq
id|IPMI_SYSTEM_INTERFACE_ADDR_TYPE
)paren
(brace
r_if
c_cond
(paren
id|addr-&gt;channel
op_ne
id|IPMI_BMC_CHANNEL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|addr-&gt;channel
op_eq
id|IPMI_BMC_CHANNEL
)paren
op_logical_or
(paren
id|addr-&gt;channel
op_ge
id|IPMI_NUM_CHANNELS
)paren
op_logical_or
(paren
id|addr-&gt;channel
OL
l_int|0
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|addr-&gt;addr_type
op_eq
id|IPMI_IPMB_ADDR_TYPE
)paren
op_logical_or
(paren
id|addr-&gt;addr_type
op_eq
id|IPMI_IPMB_BROADCAST_ADDR_TYPE
)paren
)paren
(brace
r_if
c_cond
(paren
id|len
OL
r_sizeof
(paren
r_struct
id|ipmi_ipmb_addr
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|addr-&gt;addr_type
op_eq
id|IPMI_LAN_ADDR_TYPE
)paren
(brace
r_if
c_cond
(paren
id|len
OL
r_sizeof
(paren
r_struct
id|ipmi_lan_addr
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|ipmi_addr_length
r_int
r_int
id|ipmi_addr_length
c_func
(paren
r_int
id|addr_type
)paren
(brace
r_if
c_cond
(paren
id|addr_type
op_eq
id|IPMI_SYSTEM_INTERFACE_ADDR_TYPE
)paren
r_return
r_sizeof
(paren
r_struct
id|ipmi_system_interface_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|addr_type
op_eq
id|IPMI_IPMB_ADDR_TYPE
)paren
op_logical_or
(paren
id|addr_type
op_eq
id|IPMI_IPMB_BROADCAST_ADDR_TYPE
)paren
)paren
(brace
r_return
r_sizeof
(paren
r_struct
id|ipmi_ipmb_addr
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|deliver_response
r_static
r_void
id|deliver_response
c_func
(paren
r_struct
id|ipmi_recv_msg
op_star
id|msg
)paren
(brace
id|msg-&gt;user-&gt;handler
op_member_access_from_pointer
id|ipmi_recv_hndl
c_func
(paren
id|msg
comma
id|msg-&gt;user-&gt;handler_data
)paren
suffix:semicolon
)brace
multiline_comment|/* Find the next sequence number not being used and add the given&n;   message with the given timeout to the sequence table.  This must be&n;   called with the interface&squot;s seq_lock held. */
DECL|function|intf_next_seq
r_static
r_int
id|intf_next_seq
c_func
(paren
id|ipmi_smi_t
id|intf
comma
r_struct
id|ipmi_recv_msg
op_star
id|recv_msg
comma
r_int
r_int
id|timeout
comma
r_int
id|retries
comma
r_int
id|broadcast
comma
r_int
r_char
op_star
id|seq
comma
r_int
op_star
id|seqid
)paren
(brace
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|intf-&gt;curr_seq
suffix:semicolon
(paren
id|i
op_plus
l_int|1
)paren
op_mod
id|IPMI_IPMB_NUM_SEQ
op_ne
id|intf-&gt;curr_seq
suffix:semicolon
id|i
op_assign
(paren
id|i
op_plus
l_int|1
)paren
op_mod
id|IPMI_IPMB_NUM_SEQ
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|intf-&gt;seq_table
(braket
id|i
)braket
dot
id|inuse
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|intf-&gt;seq_table
(braket
id|i
)braket
dot
id|inuse
)paren
(brace
id|intf-&gt;seq_table
(braket
id|i
)braket
dot
id|recv_msg
op_assign
id|recv_msg
suffix:semicolon
multiline_comment|/* Start with the maximum timeout, when the send response&n;&t;&t;   comes in we will start the real timer. */
id|intf-&gt;seq_table
(braket
id|i
)braket
dot
id|timeout
op_assign
id|MAX_MSG_TIMEOUT
suffix:semicolon
id|intf-&gt;seq_table
(braket
id|i
)braket
dot
id|orig_timeout
op_assign
id|timeout
suffix:semicolon
id|intf-&gt;seq_table
(braket
id|i
)braket
dot
id|retries_left
op_assign
id|retries
suffix:semicolon
id|intf-&gt;seq_table
(braket
id|i
)braket
dot
id|broadcast
op_assign
id|broadcast
suffix:semicolon
id|intf-&gt;seq_table
(braket
id|i
)braket
dot
id|inuse
op_assign
l_int|1
suffix:semicolon
id|intf-&gt;seq_table
(braket
id|i
)braket
dot
id|seqid
op_assign
id|NEXT_SEQID
c_func
(paren
id|intf-&gt;seq_table
(braket
id|i
)braket
dot
id|seqid
)paren
suffix:semicolon
op_star
id|seq
op_assign
id|i
suffix:semicolon
op_star
id|seqid
op_assign
id|intf-&gt;seq_table
(braket
id|i
)braket
dot
id|seqid
suffix:semicolon
id|intf-&gt;curr_seq
op_assign
(paren
id|i
op_plus
l_int|1
)paren
op_mod
id|IPMI_IPMB_NUM_SEQ
suffix:semicolon
)brace
r_else
(brace
id|rv
op_assign
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_return
id|rv
suffix:semicolon
)brace
multiline_comment|/* Return the receive message for the given sequence number and&n;   release the sequence number so it can be reused.  Some other data&n;   is passed in to be sure the message matches up correctly (to help&n;   guard against message coming in after their timeout and the&n;   sequence number being reused). */
DECL|function|intf_find_seq
r_static
r_int
id|intf_find_seq
c_func
(paren
id|ipmi_smi_t
id|intf
comma
r_int
r_char
id|seq
comma
r_int
id|channel
comma
r_int
r_char
id|cmd
comma
r_int
r_char
id|netfn
comma
r_struct
id|ipmi_addr
op_star
id|addr
comma
r_struct
id|ipmi_recv_msg
op_star
op_star
id|recv_msg
)paren
(brace
r_int
id|rv
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|seq
op_ge
id|IPMI_IPMB_NUM_SEQ
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|intf-&gt;seq_lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intf-&gt;seq_table
(braket
id|seq
)braket
dot
id|inuse
)paren
(brace
r_struct
id|ipmi_recv_msg
op_star
id|msg
op_assign
id|intf-&gt;seq_table
(braket
id|seq
)braket
dot
id|recv_msg
suffix:semicolon
r_if
c_cond
(paren
(paren
id|msg-&gt;addr.channel
op_eq
id|channel
)paren
op_logical_and
(paren
id|msg-&gt;msg.cmd
op_eq
id|cmd
)paren
op_logical_and
(paren
id|msg-&gt;msg.netfn
op_eq
id|netfn
)paren
op_logical_and
(paren
id|ipmi_addr_equal
c_func
(paren
id|addr
comma
op_amp
(paren
id|msg-&gt;addr
)paren
)paren
)paren
)paren
(brace
op_star
id|recv_msg
op_assign
id|msg
suffix:semicolon
id|intf-&gt;seq_table
(braket
id|seq
)braket
dot
id|inuse
op_assign
l_int|0
suffix:semicolon
id|rv
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|intf-&gt;seq_lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
multiline_comment|/* Start the timer for a specific sequence table entry. */
DECL|function|intf_start_seq_timer
r_static
r_int
id|intf_start_seq_timer
c_func
(paren
id|ipmi_smi_t
id|intf
comma
r_int
id|msgid
)paren
(brace
r_int
id|rv
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|seq
suffix:semicolon
r_int
r_int
id|seqid
suffix:semicolon
id|GET_SEQ_FROM_MSGID
c_func
(paren
id|msgid
comma
id|seq
comma
id|seqid
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|intf-&gt;seq_lock
)paren
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* We do this verification because the user can be deleted&n;           while a message is outstanding. */
r_if
c_cond
(paren
(paren
id|intf-&gt;seq_table
(braket
id|seq
)braket
dot
id|inuse
)paren
op_logical_and
(paren
id|intf-&gt;seq_table
(braket
id|seq
)braket
dot
id|seqid
op_eq
id|seqid
)paren
)paren
(brace
r_struct
id|seq_table
op_star
id|ent
op_assign
op_amp
(paren
id|intf-&gt;seq_table
(braket
id|seq
)braket
)paren
suffix:semicolon
id|ent-&gt;timeout
op_assign
id|ent-&gt;orig_timeout
suffix:semicolon
id|rv
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|intf-&gt;seq_lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
multiline_comment|/* Got an error for the send message for a specific sequence number. */
DECL|function|intf_err_seq
r_static
r_int
id|intf_err_seq
c_func
(paren
id|ipmi_smi_t
id|intf
comma
r_int
id|msgid
comma
r_int
r_int
id|err
)paren
(brace
r_int
id|rv
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|seq
suffix:semicolon
r_int
r_int
id|seqid
suffix:semicolon
r_struct
id|ipmi_recv_msg
op_star
id|msg
op_assign
l_int|NULL
suffix:semicolon
id|GET_SEQ_FROM_MSGID
c_func
(paren
id|msgid
comma
id|seq
comma
id|seqid
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|intf-&gt;seq_lock
)paren
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* We do this verification because the user can be deleted&n;           while a message is outstanding. */
r_if
c_cond
(paren
(paren
id|intf-&gt;seq_table
(braket
id|seq
)braket
dot
id|inuse
)paren
op_logical_and
(paren
id|intf-&gt;seq_table
(braket
id|seq
)braket
dot
id|seqid
op_eq
id|seqid
)paren
)paren
(brace
r_struct
id|seq_table
op_star
id|ent
op_assign
op_amp
(paren
id|intf-&gt;seq_table
(braket
id|seq
)braket
)paren
suffix:semicolon
id|ent-&gt;inuse
op_assign
l_int|0
suffix:semicolon
id|msg
op_assign
id|ent-&gt;recv_msg
suffix:semicolon
id|rv
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|intf-&gt;seq_lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg
)paren
(brace
id|msg-&gt;recv_type
op_assign
id|IPMI_RESPONSE_RECV_TYPE
suffix:semicolon
id|msg-&gt;msg_data
(braket
l_int|0
)braket
op_assign
id|err
suffix:semicolon
id|msg-&gt;msg.netfn
op_or_assign
l_int|1
suffix:semicolon
multiline_comment|/* Convert to a response. */
id|msg-&gt;msg.data_len
op_assign
l_int|1
suffix:semicolon
id|msg-&gt;msg.data
op_assign
id|msg-&gt;msg_data
suffix:semicolon
id|deliver_response
c_func
(paren
id|msg
)paren
suffix:semicolon
)brace
r_return
id|rv
suffix:semicolon
)brace
DECL|function|ipmi_create_user
r_int
id|ipmi_create_user
c_func
(paren
r_int
r_int
id|if_num
comma
r_struct
id|ipmi_user_hndl
op_star
id|handler
comma
r_void
op_star
id|handler_data
comma
id|ipmi_user_t
op_star
id|user
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|ipmi_user_t
id|new_user
suffix:semicolon
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* There is no module usecount here, because it&squot;s not&n;           required.  Since this can only be used by and called from&n;           other modules, they will implicitly use this module, and&n;           thus this can&squot;t be removed unless the other modules are&n;           removed. */
r_if
c_cond
(paren
id|handler
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Make sure the driver is actually initialized, this handles&n;&t;   problems with initialization order. */
r_if
c_cond
(paren
op_logical_neg
id|initialized
)paren
(brace
id|rv
op_assign
id|ipmi_init_msghandler
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
r_return
id|rv
suffix:semicolon
multiline_comment|/* The init code doesn&squot;t return an error if it was turned&n;&t;&t;   off, but it won&squot;t initialize.  Check that. */
r_if
c_cond
(paren
op_logical_neg
id|initialized
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|new_user
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|new_user
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_user
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|interfaces_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|if_num
OG
id|MAX_IPMI_INTERFACES
)paren
op_logical_or
id|ipmi_interfaces
(braket
id|if_num
)braket
op_eq
l_int|NULL
)paren
(brace
id|rv
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|new_user-&gt;handler
op_assign
id|handler
suffix:semicolon
id|new_user-&gt;handler_data
op_assign
id|handler_data
suffix:semicolon
id|new_user-&gt;intf
op_assign
id|ipmi_interfaces
(braket
id|if_num
)braket
suffix:semicolon
id|new_user-&gt;gets_events
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|try_module_get
c_func
(paren
id|new_user-&gt;intf-&gt;handlers-&gt;owner
)paren
)paren
(brace
id|rv
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|write_lock_irqsave
c_func
(paren
op_amp
id|new_user-&gt;intf-&gt;users_lock
comma
id|flags
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|new_user-&gt;link
comma
op_amp
id|new_user-&gt;intf-&gt;users
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|new_user-&gt;intf-&gt;users_lock
comma
id|flags
)paren
suffix:semicolon
id|out_unlock
suffix:colon
r_if
c_cond
(paren
id|rv
)paren
(brace
id|kfree
c_func
(paren
id|new_user
)paren
suffix:semicolon
)brace
r_else
(brace
op_star
id|user
op_assign
id|new_user
suffix:semicolon
)brace
id|up_read
c_func
(paren
op_amp
id|interfaces_sem
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
DECL|function|ipmi_destroy_user_nolock
r_static
r_int
id|ipmi_destroy_user_nolock
c_func
(paren
id|ipmi_user_t
id|user
)paren
(brace
r_int
id|rv
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|ipmi_user_t
id|t_user
suffix:semicolon
r_struct
id|cmd_rcvr
op_star
id|rcvr
comma
op_star
id|rcvr2
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Find the user and delete them from the list. */
id|list_for_each_entry
c_func
(paren
id|t_user
comma
op_amp
(paren
id|user-&gt;intf-&gt;users
)paren
comma
id|link
)paren
(brace
r_if
c_cond
(paren
id|t_user
op_eq
id|user
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|t_user-&gt;link
)paren
suffix:semicolon
id|rv
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rv
)paren
(brace
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* Remove the user from the interfaces sequence table. */
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;seq_lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IPMI_IPMB_NUM_SEQ
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|user-&gt;intf-&gt;seq_table
(braket
id|i
)braket
dot
id|inuse
op_logical_and
(paren
id|user-&gt;intf-&gt;seq_table
(braket
id|i
)braket
dot
id|recv_msg-&gt;user
op_eq
id|user
)paren
)paren
(brace
id|user-&gt;intf-&gt;seq_table
(braket
id|i
)braket
dot
id|inuse
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;seq_lock
)paren
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Remove the user from the command receiver&squot;s table. */
id|write_lock_irqsave
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;cmd_rcvr_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|rcvr
comma
id|rcvr2
comma
op_amp
(paren
id|user-&gt;intf-&gt;cmd_rcvrs
)paren
comma
id|link
)paren
(brace
r_if
c_cond
(paren
id|rcvr-&gt;user
op_eq
id|user
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|rcvr-&gt;link
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|rcvr
)paren
suffix:semicolon
)brace
)brace
id|write_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;cmd_rcvr_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|user
)paren
suffix:semicolon
id|out_unlock
suffix:colon
r_return
id|rv
suffix:semicolon
)brace
DECL|function|ipmi_destroy_user
r_int
id|ipmi_destroy_user
c_func
(paren
id|ipmi_user_t
id|user
)paren
(brace
r_int
id|rv
suffix:semicolon
id|ipmi_smi_t
id|intf
op_assign
id|user-&gt;intf
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|interfaces_sem
)paren
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|intf-&gt;users_lock
comma
id|flags
)paren
suffix:semicolon
id|rv
op_assign
id|ipmi_destroy_user_nolock
c_func
(paren
id|user
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rv
)paren
id|module_put
c_func
(paren
id|intf-&gt;handlers-&gt;owner
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|intf-&gt;users_lock
comma
id|flags
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|interfaces_sem
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
DECL|function|ipmi_get_version
r_void
id|ipmi_get_version
c_func
(paren
id|ipmi_user_t
id|user
comma
r_int
r_char
op_star
id|major
comma
r_int
r_char
op_star
id|minor
)paren
(brace
op_star
id|major
op_assign
id|user-&gt;intf-&gt;version_major
suffix:semicolon
op_star
id|minor
op_assign
id|user-&gt;intf-&gt;version_minor
suffix:semicolon
)brace
DECL|function|ipmi_set_my_address
r_void
id|ipmi_set_my_address
c_func
(paren
id|ipmi_user_t
id|user
comma
r_int
r_char
id|address
)paren
(brace
id|user-&gt;intf-&gt;my_address
op_assign
id|address
suffix:semicolon
)brace
DECL|function|ipmi_get_my_address
r_int
r_char
id|ipmi_get_my_address
c_func
(paren
id|ipmi_user_t
id|user
)paren
(brace
r_return
id|user-&gt;intf-&gt;my_address
suffix:semicolon
)brace
DECL|function|ipmi_set_my_LUN
r_void
id|ipmi_set_my_LUN
c_func
(paren
id|ipmi_user_t
id|user
comma
r_int
r_char
id|LUN
)paren
(brace
id|user-&gt;intf-&gt;my_lun
op_assign
id|LUN
op_amp
l_int|0x3
suffix:semicolon
)brace
DECL|function|ipmi_get_my_LUN
r_int
r_char
id|ipmi_get_my_LUN
c_func
(paren
id|ipmi_user_t
id|user
)paren
(brace
r_return
id|user-&gt;intf-&gt;my_lun
suffix:semicolon
)brace
DECL|function|ipmi_set_gets_events
r_int
id|ipmi_set_gets_events
c_func
(paren
id|ipmi_user_t
id|user
comma
r_int
id|val
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|ipmi_recv_msg
op_star
id|msg
comma
op_star
id|msg2
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;users_lock
)paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;events_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|user-&gt;gets_events
op_assign
id|val
suffix:semicolon
r_if
c_cond
(paren
id|val
)paren
(brace
multiline_comment|/* Deliver any queued events. */
id|list_for_each_entry_safe
c_func
(paren
id|msg
comma
id|msg2
comma
op_amp
(paren
id|user-&gt;intf-&gt;waiting_events
)paren
comma
id|link
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|msg-&gt;link
)paren
suffix:semicolon
id|msg-&gt;user
op_assign
id|user
suffix:semicolon
id|deliver_response
c_func
(paren
id|msg
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;events_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;users_lock
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ipmi_register_for_cmd
r_int
id|ipmi_register_for_cmd
c_func
(paren
id|ipmi_user_t
id|user
comma
r_int
r_char
id|netfn
comma
r_int
r_char
id|cmd
)paren
(brace
r_struct
id|cmd_rcvr
op_star
id|cmp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|cmd_rcvr
op_star
id|rcvr
suffix:semicolon
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
id|rcvr
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|rcvr
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rcvr
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;users_lock
)paren
)paren
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;cmd_rcvr_lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|user-&gt;intf-&gt;all_cmd_rcvr
op_ne
l_int|NULL
)paren
(brace
id|rv
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* Make sure the command/netfn is not already registered. */
id|list_for_each_entry
c_func
(paren
id|cmp
comma
op_amp
(paren
id|user-&gt;intf-&gt;cmd_rcvrs
)paren
comma
id|link
)paren
(brace
r_if
c_cond
(paren
(paren
id|cmp-&gt;netfn
op_eq
id|netfn
)paren
op_logical_and
(paren
id|cmp-&gt;cmd
op_eq
id|cmd
)paren
)paren
(brace
id|rv
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|rv
)paren
(brace
id|rcvr-&gt;cmd
op_assign
id|cmd
suffix:semicolon
id|rcvr-&gt;netfn
op_assign
id|netfn
suffix:semicolon
id|rcvr-&gt;user
op_assign
id|user
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
(paren
id|rcvr-&gt;link
)paren
comma
op_amp
(paren
id|user-&gt;intf-&gt;cmd_rcvrs
)paren
)paren
suffix:semicolon
)brace
id|out_unlock
suffix:colon
id|write_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;cmd_rcvr_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;users_lock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
id|kfree
c_func
(paren
id|rcvr
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
DECL|function|ipmi_unregister_for_cmd
r_int
id|ipmi_unregister_for_cmd
c_func
(paren
id|ipmi_user_t
id|user
comma
r_int
r_char
id|netfn
comma
r_int
r_char
id|cmd
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|cmd_rcvr
op_star
id|rcvr
suffix:semicolon
r_int
id|rv
op_assign
op_minus
id|ENOENT
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;users_lock
)paren
)paren
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;cmd_rcvr_lock
)paren
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Make sure the command/netfn is not already registered. */
id|list_for_each_entry
c_func
(paren
id|rcvr
comma
op_amp
(paren
id|user-&gt;intf-&gt;cmd_rcvrs
)paren
comma
id|link
)paren
(brace
r_if
c_cond
(paren
(paren
id|rcvr-&gt;netfn
op_eq
id|netfn
)paren
op_logical_and
(paren
id|rcvr-&gt;cmd
op_eq
id|cmd
)paren
)paren
(brace
id|rv
op_assign
l_int|0
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|rcvr-&gt;link
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|rcvr
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|write_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;cmd_rcvr_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
(paren
id|user-&gt;intf-&gt;users_lock
)paren
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
DECL|function|ipmi_user_set_run_to_completion
r_void
id|ipmi_user_set_run_to_completion
c_func
(paren
id|ipmi_user_t
id|user
comma
r_int
id|val
)paren
(brace
id|user-&gt;intf-&gt;handlers
op_member_access_from_pointer
id|set_run_to_completion
c_func
(paren
id|user-&gt;intf-&gt;send_info
comma
id|val
)paren
suffix:semicolon
)brace
r_static
r_int
r_char
DECL|function|ipmb_checksum
id|ipmb_checksum
c_func
(paren
r_int
r_char
op_star
id|data
comma
r_int
id|size
)paren
(brace
r_int
r_char
id|csum
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|size
OG
l_int|0
suffix:semicolon
id|size
op_decrement
comma
id|data
op_increment
)paren
id|csum
op_add_assign
op_star
id|data
suffix:semicolon
r_return
op_minus
id|csum
suffix:semicolon
)brace
DECL|function|format_ipmb_msg
r_static
r_inline
r_void
id|format_ipmb_msg
c_func
(paren
r_struct
id|ipmi_smi_msg
op_star
id|smi_msg
comma
r_struct
id|kernel_ipmi_msg
op_star
id|msg
comma
r_struct
id|ipmi_ipmb_addr
op_star
id|ipmb_addr
comma
r_int
id|msgid
comma
r_int
r_char
id|ipmb_seq
comma
r_int
id|broadcast
comma
r_int
r_char
id|source_address
comma
r_int
r_char
id|source_lun
)paren
(brace
r_int
id|i
op_assign
id|broadcast
suffix:semicolon
multiline_comment|/* Format the IPMB header data. */
id|smi_msg-&gt;data
(braket
l_int|0
)braket
op_assign
(paren
id|IPMI_NETFN_APP_REQUEST
op_lshift
l_int|2
)paren
suffix:semicolon
id|smi_msg-&gt;data
(braket
l_int|1
)braket
op_assign
id|IPMI_SEND_MSG_CMD
suffix:semicolon
id|smi_msg-&gt;data
(braket
l_int|2
)braket
op_assign
id|ipmb_addr-&gt;channel
suffix:semicolon
r_if
c_cond
(paren
id|broadcast
)paren
id|smi_msg-&gt;data
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|smi_msg-&gt;data
(braket
id|i
op_plus
l_int|3
)braket
op_assign
id|ipmb_addr-&gt;slave_addr
suffix:semicolon
id|smi_msg-&gt;data
(braket
id|i
op_plus
l_int|4
)braket
op_assign
(paren
id|msg-&gt;netfn
op_lshift
l_int|2
)paren
op_or
(paren
id|ipmb_addr-&gt;lun
op_amp
l_int|0x3
)paren
suffix:semicolon
id|smi_msg-&gt;data
(braket
id|i
op_plus
l_int|5
)braket
op_assign
id|ipmb_checksum
c_func
(paren
op_amp
(paren
id|smi_msg-&gt;data
(braket
id|i
op_plus
l_int|3
)braket
)paren
comma
l_int|2
)paren
suffix:semicolon
id|smi_msg-&gt;data
(braket
id|i
op_plus
l_int|6
)braket
op_assign
id|source_address
suffix:semicolon
id|smi_msg-&gt;data
(braket
id|i
op_plus
l_int|7
)braket
op_assign
(paren
id|ipmb_seq
op_lshift
l_int|2
)paren
op_or
id|source_lun
suffix:semicolon
id|smi_msg-&gt;data
(braket
id|i
op_plus
l_int|8
)braket
op_assign
id|msg-&gt;cmd
suffix:semicolon
multiline_comment|/* Now tack on the data to the message. */
r_if
c_cond
(paren
id|msg-&gt;data_len
OG
l_int|0
)paren
id|memcpy
c_func
(paren
op_amp
(paren
id|smi_msg-&gt;data
(braket
id|i
op_plus
l_int|9
)braket
)paren
comma
id|msg-&gt;data
comma
id|msg-&gt;data_len
)paren
suffix:semicolon
id|smi_msg-&gt;data_size
op_assign
id|msg-&gt;data_len
op_plus
l_int|9
suffix:semicolon
multiline_comment|/* Now calculate the checksum and tack it on. */
id|smi_msg-&gt;data
(braket
id|i
op_plus
id|smi_msg-&gt;data_size
)braket
op_assign
id|ipmb_checksum
c_func
(paren
op_amp
(paren
id|smi_msg-&gt;data
(braket
id|i
op_plus
l_int|6
)braket
)paren
comma
id|smi_msg-&gt;data_size
op_minus
l_int|6
)paren
suffix:semicolon
multiline_comment|/* Add on the checksum size and the offset from the&n;&t;   broadcast. */
id|smi_msg-&gt;data_size
op_add_assign
l_int|1
op_plus
id|i
suffix:semicolon
id|smi_msg-&gt;msgid
op_assign
id|msgid
suffix:semicolon
)brace
DECL|function|format_lan_msg
r_static
r_inline
r_void
id|format_lan_msg
c_func
(paren
r_struct
id|ipmi_smi_msg
op_star
id|smi_msg
comma
r_struct
id|kernel_ipmi_msg
op_star
id|msg
comma
r_struct
id|ipmi_lan_addr
op_star
id|lan_addr
comma
r_int
id|msgid
comma
r_int
r_char
id|ipmb_seq
comma
r_int
r_char
id|source_lun
)paren
(brace
multiline_comment|/* Format the IPMB header data. */
id|smi_msg-&gt;data
(braket
l_int|0
)braket
op_assign
(paren
id|IPMI_NETFN_APP_REQUEST
op_lshift
l_int|2
)paren
suffix:semicolon
id|smi_msg-&gt;data
(braket
l_int|1
)braket
op_assign
id|IPMI_SEND_MSG_CMD
suffix:semicolon
id|smi_msg-&gt;data
(braket
l_int|2
)braket
op_assign
id|lan_addr-&gt;channel
suffix:semicolon
id|smi_msg-&gt;data
(braket
l_int|3
)braket
op_assign
id|lan_addr-&gt;session_handle
suffix:semicolon
id|smi_msg-&gt;data
(braket
l_int|4
)braket
op_assign
id|lan_addr-&gt;remote_SWID
suffix:semicolon
id|smi_msg-&gt;data
(braket
l_int|5
)braket
op_assign
(paren
id|msg-&gt;netfn
op_lshift
l_int|2
)paren
op_or
(paren
id|lan_addr-&gt;lun
op_amp
l_int|0x3
)paren
suffix:semicolon
id|smi_msg-&gt;data
(braket
l_int|6
)braket
op_assign
id|ipmb_checksum
c_func
(paren
op_amp
(paren
id|smi_msg-&gt;data
(braket
l_int|4
)braket
)paren
comma
l_int|2
)paren
suffix:semicolon
id|smi_msg-&gt;data
(braket
l_int|7
)braket
op_assign
id|lan_addr-&gt;local_SWID
suffix:semicolon
id|smi_msg-&gt;data
(braket
l_int|8
)braket
op_assign
(paren
id|ipmb_seq
op_lshift
l_int|2
)paren
op_or
id|source_lun
suffix:semicolon
id|smi_msg-&gt;data
(braket
l_int|9
)braket
op_assign
id|msg-&gt;cmd
suffix:semicolon
multiline_comment|/* Now tack on the data to the message. */
r_if
c_cond
(paren
id|msg-&gt;data_len
OG
l_int|0
)paren
id|memcpy
c_func
(paren
op_amp
(paren
id|smi_msg-&gt;data
(braket
l_int|10
)braket
)paren
comma
id|msg-&gt;data
comma
id|msg-&gt;data_len
)paren
suffix:semicolon
id|smi_msg-&gt;data_size
op_assign
id|msg-&gt;data_len
op_plus
l_int|10
suffix:semicolon
multiline_comment|/* Now calculate the checksum and tack it on. */
id|smi_msg-&gt;data
(braket
id|smi_msg-&gt;data_size
)braket
op_assign
id|ipmb_checksum
c_func
(paren
op_amp
(paren
id|smi_msg-&gt;data
(braket
l_int|7
)braket
)paren
comma
id|smi_msg-&gt;data_size
op_minus
l_int|7
)paren
suffix:semicolon
multiline_comment|/* Add on the checksum size and the offset from the&n;&t;   broadcast. */
id|smi_msg-&gt;data_size
op_add_assign
l_int|1
suffix:semicolon
id|smi_msg-&gt;msgid
op_assign
id|msgid
suffix:semicolon
)brace
multiline_comment|/* Separate from ipmi_request so that the user does not have to be&n;   supplied in certain circumstances (mainly at panic time).  If&n;   messages are supplied, they will be freed, even if an error&n;   occurs. */
DECL|function|i_ipmi_request
r_static
r_inline
r_int
id|i_ipmi_request
c_func
(paren
id|ipmi_user_t
id|user
comma
id|ipmi_smi_t
id|intf
comma
r_struct
id|ipmi_addr
op_star
id|addr
comma
r_int
id|msgid
comma
r_struct
id|kernel_ipmi_msg
op_star
id|msg
comma
r_void
op_star
id|user_msg_data
comma
r_void
op_star
id|supplied_smi
comma
r_struct
id|ipmi_recv_msg
op_star
id|supplied_recv
comma
r_int
id|priority
comma
r_int
r_char
id|source_address
comma
r_int
r_char
id|source_lun
comma
r_int
id|retries
comma
r_int
r_int
id|retry_time_ms
)paren
(brace
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
r_struct
id|ipmi_smi_msg
op_star
id|smi_msg
suffix:semicolon
r_struct
id|ipmi_recv_msg
op_star
id|recv_msg
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|supplied_recv
)paren
(brace
id|recv_msg
op_assign
id|supplied_recv
suffix:semicolon
)brace
r_else
(brace
id|recv_msg
op_assign
id|ipmi_alloc_recv_msg
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|recv_msg
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
id|recv_msg-&gt;user_msg_data
op_assign
id|user_msg_data
suffix:semicolon
r_if
c_cond
(paren
id|supplied_smi
)paren
(brace
id|smi_msg
op_assign
(paren
r_struct
id|ipmi_smi_msg
op_star
)paren
id|supplied_smi
suffix:semicolon
)brace
r_else
(brace
id|smi_msg
op_assign
id|ipmi_alloc_smi_msg
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smi_msg
op_eq
l_int|NULL
)paren
(brace
id|ipmi_free_recv_msg
c_func
(paren
id|recv_msg
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
id|recv_msg-&gt;user
op_assign
id|user
suffix:semicolon
id|recv_msg-&gt;msgid
op_assign
id|msgid
suffix:semicolon
multiline_comment|/* Store the message to send in the receive message so timeout&n;&t;   responses can get the proper response data. */
id|recv_msg-&gt;msg
op_assign
op_star
id|msg
suffix:semicolon
r_if
c_cond
(paren
id|addr-&gt;addr_type
op_eq
id|IPMI_SYSTEM_INTERFACE_ADDR_TYPE
)paren
(brace
r_struct
id|ipmi_system_interface_addr
op_star
id|smi_addr
suffix:semicolon
r_if
c_cond
(paren
id|msg-&gt;netfn
op_amp
l_int|1
)paren
(brace
multiline_comment|/* Responses are not allowed to the SMI. */
id|rv
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
id|smi_addr
op_assign
(paren
r_struct
id|ipmi_system_interface_addr
op_star
)paren
id|addr
suffix:semicolon
r_if
c_cond
(paren
id|smi_addr-&gt;lun
OG
l_int|3
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|intf-&gt;sent_invalid_commands
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|rv
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
id|memcpy
c_func
(paren
op_amp
id|recv_msg-&gt;addr
comma
id|smi_addr
comma
r_sizeof
(paren
op_star
id|smi_addr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|msg-&gt;netfn
op_eq
id|IPMI_NETFN_APP_REQUEST
)paren
op_logical_and
(paren
(paren
id|msg-&gt;cmd
op_eq
id|IPMI_SEND_MSG_CMD
)paren
op_logical_or
(paren
id|msg-&gt;cmd
op_eq
id|IPMI_GET_MSG_CMD
)paren
op_logical_or
(paren
id|msg-&gt;cmd
op_eq
id|IPMI_READ_EVENT_MSG_BUFFER_CMD
)paren
)paren
)paren
(brace
multiline_comment|/* We don&squot;t let the user do these, since we manage&n;&t;&t;&t;   the sequence numbers. */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|intf-&gt;sent_invalid_commands
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|rv
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|msg-&gt;data_len
op_plus
l_int|2
)paren
OG
id|IPMI_MAX_MSG_LENGTH
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|intf-&gt;sent_invalid_commands
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|rv
op_assign
op_minus
id|EMSGSIZE
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
id|smi_msg-&gt;data
(braket
l_int|0
)braket
op_assign
(paren
id|msg-&gt;netfn
op_lshift
l_int|2
)paren
op_or
(paren
id|smi_addr-&gt;lun
op_amp
l_int|0x3
)paren
suffix:semicolon
id|smi_msg-&gt;data
(braket
l_int|1
)braket
op_assign
id|msg-&gt;cmd
suffix:semicolon
id|smi_msg-&gt;msgid
op_assign
id|msgid
suffix:semicolon
id|smi_msg-&gt;user_data
op_assign
id|recv_msg
suffix:semicolon
r_if
c_cond
(paren
id|msg-&gt;data_len
OG
l_int|0
)paren
id|memcpy
c_func
(paren
op_amp
(paren
id|smi_msg-&gt;data
(braket
l_int|2
)braket
)paren
comma
id|msg-&gt;data
comma
id|msg-&gt;data_len
)paren
suffix:semicolon
id|smi_msg-&gt;data_size
op_assign
id|msg-&gt;data_len
op_plus
l_int|2
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|intf-&gt;sent_local_commands
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|addr-&gt;addr_type
op_eq
id|IPMI_IPMB_ADDR_TYPE
)paren
op_logical_or
(paren
id|addr-&gt;addr_type
op_eq
id|IPMI_IPMB_BROADCAST_ADDR_TYPE
)paren
)paren
(brace
r_struct
id|ipmi_ipmb_addr
op_star
id|ipmb_addr
suffix:semicolon
r_int
r_char
id|ipmb_seq
suffix:semicolon
r_int
id|seqid
suffix:semicolon
r_int
id|broadcast
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|addr-&gt;channel
OG
id|IPMI_NUM_CHANNELS
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|intf-&gt;sent_invalid_commands
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|rv
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intf-&gt;channels
(braket
id|addr-&gt;channel
)braket
dot
id|medium
op_ne
id|IPMI_CHANNEL_MEDIUM_IPMB
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|intf-&gt;sent_invalid_commands
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|rv
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retries
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|addr-&gt;addr_type
op_eq
id|IPMI_IPMB_BROADCAST_ADDR_TYPE
)paren
id|retries
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Don&squot;t retry broadcasts. */
r_else
id|retries
op_assign
l_int|4
suffix:semicolon
)brace
r_if
c_cond
(paren
id|addr-&gt;addr_type
op_eq
id|IPMI_IPMB_BROADCAST_ADDR_TYPE
)paren
(brace
multiline_comment|/* Broadcasts add a zero at the beginning of the&n;&t;&t;       message, but otherwise is the same as an IPMB&n;&t;&t;       address. */
id|addr-&gt;addr_type
op_assign
id|IPMI_IPMB_ADDR_TYPE
suffix:semicolon
id|broadcast
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Default to 1 second retries. */
r_if
c_cond
(paren
id|retry_time_ms
op_eq
l_int|0
)paren
id|retry_time_ms
op_assign
l_int|1000
suffix:semicolon
multiline_comment|/* 9 for the header and 1 for the checksum, plus&n;                   possibly one for the broadcast. */
r_if
c_cond
(paren
(paren
id|msg-&gt;data_len
op_plus
l_int|10
op_plus
id|broadcast
)paren
OG
id|IPMI_MAX_MSG_LENGTH
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|intf-&gt;sent_invalid_commands
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|rv
op_assign
op_minus
id|EMSGSIZE
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
id|ipmb_addr
op_assign
(paren
r_struct
id|ipmi_ipmb_addr
op_star
)paren
id|addr
suffix:semicolon
r_if
c_cond
(paren
id|ipmb_addr-&gt;lun
OG
l_int|3
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|intf-&gt;sent_invalid_commands
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|rv
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
id|memcpy
c_func
(paren
op_amp
id|recv_msg-&gt;addr
comma
id|ipmb_addr
comma
r_sizeof
(paren
op_star
id|ipmb_addr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|recv_msg-&gt;msg.netfn
op_amp
l_int|0x1
)paren
(brace
multiline_comment|/* It&squot;s a response, so use the user&squot;s sequence&n;                           from msgid. */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|intf-&gt;sent_ipmb_responses
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|format_ipmb_msg
c_func
(paren
id|smi_msg
comma
id|msg
comma
id|ipmb_addr
comma
id|msgid
comma
id|msgid
comma
id|broadcast
comma
id|source_address
comma
id|source_lun
)paren
suffix:semicolon
multiline_comment|/* Save the receive message so we can use it&n;&t;&t;&t;   to deliver the response. */
id|smi_msg-&gt;user_data
op_assign
id|recv_msg
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* It&squot;s a command, so get a sequence for it. */
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|intf-&gt;seq_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|intf-&gt;counter_lock
)paren
suffix:semicolon
id|intf-&gt;sent_ipmb_commands
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|intf-&gt;counter_lock
)paren
suffix:semicolon
multiline_comment|/* Create a sequence number with a 1 second&n;                           timeout and 4 retries. */
id|rv
op_assign
id|intf_next_seq
c_func
(paren
id|intf
comma
id|recv_msg
comma
id|retry_time_ms
comma
id|retries
comma
id|broadcast
comma
op_amp
id|ipmb_seq
comma
op_amp
id|seqid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
(brace
multiline_comment|/* We have used up all the sequence numbers,&n;&t;&t;&t;&t;   probably, so abort. */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|intf-&gt;seq_lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
multiline_comment|/* Store the sequence number in the message,&n;                           so that when the send message response&n;                           comes back we can start the timer. */
id|format_ipmb_msg
c_func
(paren
id|smi_msg
comma
id|msg
comma
id|ipmb_addr
comma
id|STORE_SEQ_IN_MSGID
c_func
(paren
id|ipmb_seq
comma
id|seqid
)paren
comma
id|ipmb_seq
comma
id|broadcast
comma
id|source_address
comma
id|source_lun
)paren
suffix:semicolon
multiline_comment|/* Copy the message into the recv message data, so we&n;&t;&t;&t;   can retransmit it later if necessary. */
id|memcpy
c_func
(paren
id|recv_msg-&gt;msg_data
comma
id|smi_msg-&gt;data
comma
id|smi_msg-&gt;data_size
)paren
suffix:semicolon
id|recv_msg-&gt;msg.data
op_assign
id|recv_msg-&gt;msg_data
suffix:semicolon
id|recv_msg-&gt;msg.data_len
op_assign
id|smi_msg-&gt;data_size
suffix:semicolon
multiline_comment|/* We don&squot;t unlock until here, because we need&n;                           to copy the completed message into the&n;                           recv_msg before we release the lock.&n;                           Otherwise, race conditions may bite us.  I&n;                           know that&squot;s pretty paranoid, but I prefer&n;                           to be correct. */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|intf-&gt;seq_lock
)paren
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|addr-&gt;addr_type
op_eq
id|IPMI_LAN_ADDR_TYPE
)paren
(brace
r_struct
id|ipmi_lan_addr
op_star
id|lan_addr
suffix:semicolon
r_int
r_char
id|ipmb_seq
suffix:semicolon
r_int
id|seqid
suffix:semicolon
r_if
c_cond
(paren
id|addr-&gt;channel
OG
id|IPMI_NUM_CHANNELS
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|intf-&gt;sent_invalid_commands
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|rv
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|intf-&gt;channels
(braket
id|addr-&gt;channel
)braket
dot
id|medium
op_ne
id|IPMI_CHANNEL_MEDIUM_8023LAN
)paren
op_logical_and
(paren
id|intf-&gt;channels
(braket
id|addr-&gt;channel
)braket
dot
id|medium
op_ne
id|IPMI_CHANNEL_MEDIUM_ASYNC
)paren
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|intf-&gt;sent_invalid_commands
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|rv
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
id|retries
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* Default to 1 second retries. */
r_if
c_cond
(paren
id|retry_time_ms
op_eq
l_int|0
)paren
id|retry_time_ms
op_assign
l_int|1000
suffix:semicolon
multiline_comment|/* 11 for the header and 1 for the checksum. */
r_if
c_cond
(paren
(paren
id|msg-&gt;data_len
op_plus
l_int|12
)paren
OG
id|IPMI_MAX_MSG_LENGTH
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|intf-&gt;sent_invalid_commands
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|rv
op_assign
op_minus
id|EMSGSIZE
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
id|lan_addr
op_assign
(paren
r_struct
id|ipmi_lan_addr
op_star
)paren
id|addr
suffix:semicolon
r_if
c_cond
(paren
id|lan_addr-&gt;lun
OG
l_int|3
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|intf-&gt;sent_invalid_commands
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|rv
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
id|memcpy
c_func
(paren
op_amp
id|recv_msg-&gt;addr
comma
id|lan_addr
comma
r_sizeof
(paren
op_star
id|lan_addr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|recv_msg-&gt;msg.netfn
op_amp
l_int|0x1
)paren
(brace
multiline_comment|/* It&squot;s a response, so use the user&squot;s sequence&n;                           from msgid. */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|intf-&gt;sent_lan_responses
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|format_lan_msg
c_func
(paren
id|smi_msg
comma
id|msg
comma
id|lan_addr
comma
id|msgid
comma
id|msgid
comma
id|source_lun
)paren
suffix:semicolon
multiline_comment|/* Save the receive message so we can use it&n;&t;&t;&t;   to deliver the response. */
id|smi_msg-&gt;user_data
op_assign
id|recv_msg
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* It&squot;s a command, so get a sequence for it. */
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|intf-&gt;seq_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|intf-&gt;counter_lock
)paren
suffix:semicolon
id|intf-&gt;sent_lan_commands
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|intf-&gt;counter_lock
)paren
suffix:semicolon
multiline_comment|/* Create a sequence number with a 1 second&n;                           timeout and 4 retries. */
id|rv
op_assign
id|intf_next_seq
c_func
(paren
id|intf
comma
id|recv_msg
comma
id|retry_time_ms
comma
id|retries
comma
l_int|0
comma
op_amp
id|ipmb_seq
comma
op_amp
id|seqid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
(brace
multiline_comment|/* We have used up all the sequence numbers,&n;&t;&t;&t;&t;   probably, so abort. */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|intf-&gt;seq_lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
multiline_comment|/* Store the sequence number in the message,&n;                           so that when the send message response&n;                           comes back we can start the timer. */
id|format_lan_msg
c_func
(paren
id|smi_msg
comma
id|msg
comma
id|lan_addr
comma
id|STORE_SEQ_IN_MSGID
c_func
(paren
id|ipmb_seq
comma
id|seqid
)paren
comma
id|ipmb_seq
comma
id|source_lun
)paren
suffix:semicolon
multiline_comment|/* Copy the message into the recv message data, so we&n;&t;&t;&t;   can retransmit it later if necessary. */
id|memcpy
c_func
(paren
id|recv_msg-&gt;msg_data
comma
id|smi_msg-&gt;data
comma
id|smi_msg-&gt;data_size
)paren
suffix:semicolon
id|recv_msg-&gt;msg.data
op_assign
id|recv_msg-&gt;msg_data
suffix:semicolon
id|recv_msg-&gt;msg.data_len
op_assign
id|smi_msg-&gt;data_size
suffix:semicolon
multiline_comment|/* We don&squot;t unlock until here, because we need&n;                           to copy the completed message into the&n;                           recv_msg before we release the lock.&n;                           Otherwise, race conditions may bite us.  I&n;                           know that&squot;s pretty paranoid, but I prefer&n;                           to be correct. */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|intf-&gt;seq_lock
)paren
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Unknown address type. */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|intf-&gt;sent_invalid_commands
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|rv
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_err
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_MSGING
(brace
r_int
id|m
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
l_int|0
suffix:semicolon
id|m
OL
id|smi_msg-&gt;data_size
suffix:semicolon
id|m
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %2.2x&quot;
comma
id|smi_msg-&gt;data
(braket
id|m
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|intf-&gt;handlers
op_member_access_from_pointer
id|sender
c_func
(paren
id|intf-&gt;send_info
comma
id|smi_msg
comma
id|priority
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_err
suffix:colon
id|ipmi_free_smi_msg
c_func
(paren
id|smi_msg
)paren
suffix:semicolon
id|ipmi_free_recv_msg
c_func
(paren
id|recv_msg
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
DECL|function|ipmi_request
r_int
id|ipmi_request
c_func
(paren
id|ipmi_user_t
id|user
comma
r_struct
id|ipmi_addr
op_star
id|addr
comma
r_int
id|msgid
comma
r_struct
id|kernel_ipmi_msg
op_star
id|msg
comma
r_void
op_star
id|user_msg_data
comma
r_int
id|priority
)paren
(brace
r_return
id|i_ipmi_request
c_func
(paren
id|user
comma
id|user-&gt;intf
comma
id|addr
comma
id|msgid
comma
id|msg
comma
id|user_msg_data
comma
l_int|NULL
comma
l_int|NULL
comma
id|priority
comma
id|user-&gt;intf-&gt;my_address
comma
id|user-&gt;intf-&gt;my_lun
comma
op_minus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|ipmi_request_settime
r_int
id|ipmi_request_settime
c_func
(paren
id|ipmi_user_t
id|user
comma
r_struct
id|ipmi_addr
op_star
id|addr
comma
r_int
id|msgid
comma
r_struct
id|kernel_ipmi_msg
op_star
id|msg
comma
r_void
op_star
id|user_msg_data
comma
r_int
id|priority
comma
r_int
id|retries
comma
r_int
r_int
id|retry_time_ms
)paren
(brace
r_return
id|i_ipmi_request
c_func
(paren
id|user
comma
id|user-&gt;intf
comma
id|addr
comma
id|msgid
comma
id|msg
comma
id|user_msg_data
comma
l_int|NULL
comma
l_int|NULL
comma
id|priority
comma
id|user-&gt;intf-&gt;my_address
comma
id|user-&gt;intf-&gt;my_lun
comma
id|retries
comma
id|retry_time_ms
)paren
suffix:semicolon
)brace
DECL|function|ipmi_request_supply_msgs
r_int
id|ipmi_request_supply_msgs
c_func
(paren
id|ipmi_user_t
id|user
comma
r_struct
id|ipmi_addr
op_star
id|addr
comma
r_int
id|msgid
comma
r_struct
id|kernel_ipmi_msg
op_star
id|msg
comma
r_void
op_star
id|user_msg_data
comma
r_void
op_star
id|supplied_smi
comma
r_struct
id|ipmi_recv_msg
op_star
id|supplied_recv
comma
r_int
id|priority
)paren
(brace
r_return
id|i_ipmi_request
c_func
(paren
id|user
comma
id|user-&gt;intf
comma
id|addr
comma
id|msgid
comma
id|msg
comma
id|user_msg_data
comma
id|supplied_smi
comma
id|supplied_recv
comma
id|priority
comma
id|user-&gt;intf-&gt;my_address
comma
id|user-&gt;intf-&gt;my_lun
comma
op_minus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|ipmi_request_with_source
r_int
id|ipmi_request_with_source
c_func
(paren
id|ipmi_user_t
id|user
comma
r_struct
id|ipmi_addr
op_star
id|addr
comma
r_int
id|msgid
comma
r_struct
id|kernel_ipmi_msg
op_star
id|msg
comma
r_void
op_star
id|user_msg_data
comma
r_int
id|priority
comma
r_int
r_char
id|source_address
comma
r_int
r_char
id|source_lun
)paren
(brace
r_return
id|i_ipmi_request
c_func
(paren
id|user
comma
id|user-&gt;intf
comma
id|addr
comma
id|msgid
comma
id|msg
comma
id|user_msg_data
comma
l_int|NULL
comma
l_int|NULL
comma
id|priority
comma
id|source_address
comma
id|source_lun
comma
op_minus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|ipmb_file_read_proc
r_static
r_int
id|ipmb_file_read_proc
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_char
op_star
id|out
op_assign
(paren
r_char
op_star
)paren
id|page
suffix:semicolon
id|ipmi_smi_t
id|intf
op_assign
id|data
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;%x&bslash;n&quot;
comma
id|intf-&gt;my_address
)paren
suffix:semicolon
)brace
DECL|function|version_file_read_proc
r_static
r_int
id|version_file_read_proc
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_char
op_star
id|out
op_assign
(paren
r_char
op_star
)paren
id|page
suffix:semicolon
id|ipmi_smi_t
id|intf
op_assign
id|data
suffix:semicolon
r_return
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;%d.%d&bslash;n&quot;
comma
id|intf-&gt;version_major
comma
id|intf-&gt;version_minor
)paren
suffix:semicolon
)brace
DECL|function|stat_file_read_proc
r_static
r_int
id|stat_file_read_proc
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_char
op_star
id|out
op_assign
(paren
r_char
op_star
)paren
id|page
suffix:semicolon
id|ipmi_smi_t
id|intf
op_assign
id|data
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;sent_invalid_commands:       %d&bslash;n&quot;
comma
id|intf-&gt;sent_invalid_commands
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;sent_local_commands:         %d&bslash;n&quot;
comma
id|intf-&gt;sent_local_commands
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;handled_local_responses:     %d&bslash;n&quot;
comma
id|intf-&gt;handled_local_responses
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;unhandled_local_responses:   %d&bslash;n&quot;
comma
id|intf-&gt;unhandled_local_responses
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;sent_ipmb_commands:          %d&bslash;n&quot;
comma
id|intf-&gt;sent_ipmb_commands
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;sent_ipmb_command_errs:      %d&bslash;n&quot;
comma
id|intf-&gt;sent_ipmb_command_errs
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;retransmitted_ipmb_commands: %d&bslash;n&quot;
comma
id|intf-&gt;retransmitted_ipmb_commands
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;timed_out_ipmb_commands:     %d&bslash;n&quot;
comma
id|intf-&gt;timed_out_ipmb_commands
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;timed_out_ipmb_broadcasts:   %d&bslash;n&quot;
comma
id|intf-&gt;timed_out_ipmb_broadcasts
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;sent_ipmb_responses:         %d&bslash;n&quot;
comma
id|intf-&gt;sent_ipmb_responses
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;handled_ipmb_responses:      %d&bslash;n&quot;
comma
id|intf-&gt;handled_ipmb_responses
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;invalid_ipmb_responses:      %d&bslash;n&quot;
comma
id|intf-&gt;invalid_ipmb_responses
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;unhandled_ipmb_responses:    %d&bslash;n&quot;
comma
id|intf-&gt;unhandled_ipmb_responses
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;sent_lan_commands:           %d&bslash;n&quot;
comma
id|intf-&gt;sent_lan_commands
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;sent_lan_command_errs:       %d&bslash;n&quot;
comma
id|intf-&gt;sent_lan_command_errs
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;retransmitted_lan_commands:  %d&bslash;n&quot;
comma
id|intf-&gt;retransmitted_lan_commands
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;timed_out_lan_commands:      %d&bslash;n&quot;
comma
id|intf-&gt;timed_out_lan_commands
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;sent_lan_responses:          %d&bslash;n&quot;
comma
id|intf-&gt;sent_lan_responses
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;handled_lan_responses:       %d&bslash;n&quot;
comma
id|intf-&gt;handled_lan_responses
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;invalid_lan_responses:       %d&bslash;n&quot;
comma
id|intf-&gt;invalid_lan_responses
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;unhandled_lan_responses:     %d&bslash;n&quot;
comma
id|intf-&gt;unhandled_lan_responses
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;handled_commands:            %d&bslash;n&quot;
comma
id|intf-&gt;handled_commands
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;invalid_commands:            %d&bslash;n&quot;
comma
id|intf-&gt;invalid_commands
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;unhandled_commands:          %d&bslash;n&quot;
comma
id|intf-&gt;unhandled_commands
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;invalid_events:              %d&bslash;n&quot;
comma
id|intf-&gt;invalid_events
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;events:                      %d&bslash;n&quot;
comma
id|intf-&gt;events
)paren
suffix:semicolon
r_return
(paren
id|out
op_minus
(paren
(paren
r_char
op_star
)paren
id|page
)paren
)paren
suffix:semicolon
)brace
DECL|function|ipmi_smi_add_proc_entry
r_int
id|ipmi_smi_add_proc_entry
c_func
(paren
id|ipmi_smi_t
id|smi
comma
r_char
op_star
id|name
comma
id|read_proc_t
op_star
id|read_proc
comma
id|write_proc_t
op_star
id|write_proc
comma
r_void
op_star
id|data
comma
r_struct
id|module
op_star
id|owner
)paren
(brace
r_struct
id|proc_dir_entry
op_star
id|file
suffix:semicolon
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
r_struct
id|ipmi_proc_entry
op_star
id|entry
suffix:semicolon
multiline_comment|/* Create a list element. */
id|entry
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|entry
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|entry-&gt;name
op_assign
id|kmalloc
c_func
(paren
id|strlen
c_func
(paren
id|name
)paren
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;name
)paren
(brace
id|kfree
c_func
(paren
id|entry
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|strcpy
c_func
(paren
id|entry-&gt;name
comma
id|name
)paren
suffix:semicolon
id|file
op_assign
id|create_proc_entry
c_func
(paren
id|name
comma
l_int|0
comma
id|smi-&gt;proc_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file
)paren
(brace
id|kfree
c_func
(paren
id|entry-&gt;name
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|entry
)paren
suffix:semicolon
id|rv
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
(brace
id|file-&gt;nlink
op_assign
l_int|1
suffix:semicolon
id|file-&gt;data
op_assign
id|data
suffix:semicolon
id|file-&gt;read_proc
op_assign
id|read_proc
suffix:semicolon
id|file-&gt;write_proc
op_assign
id|write_proc
suffix:semicolon
id|file-&gt;owner
op_assign
id|owner
suffix:semicolon
multiline_comment|/* Stick it on the list. */
id|entry-&gt;next
op_assign
id|smi-&gt;proc_entries
suffix:semicolon
id|smi-&gt;proc_entries
op_assign
id|entry
suffix:semicolon
)brace
r_return
id|rv
suffix:semicolon
)brace
DECL|function|add_proc_entries
r_static
r_int
id|add_proc_entries
c_func
(paren
id|ipmi_smi_t
id|smi
comma
r_int
id|num
)paren
(brace
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
id|sprintf
c_func
(paren
id|smi-&gt;proc_dir_name
comma
l_string|&quot;%d&quot;
comma
id|num
)paren
suffix:semicolon
id|smi-&gt;proc_dir
op_assign
id|proc_mkdir
c_func
(paren
id|smi-&gt;proc_dir_name
comma
id|proc_ipmi_root
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|smi-&gt;proc_dir
)paren
id|rv
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_else
(brace
id|smi-&gt;proc_dir-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rv
op_eq
l_int|0
)paren
id|rv
op_assign
id|ipmi_smi_add_proc_entry
c_func
(paren
id|smi
comma
l_string|&quot;stats&quot;
comma
id|stat_file_read_proc
comma
l_int|NULL
comma
id|smi
comma
id|THIS_MODULE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
op_eq
l_int|0
)paren
id|rv
op_assign
id|ipmi_smi_add_proc_entry
c_func
(paren
id|smi
comma
l_string|&quot;ipmb&quot;
comma
id|ipmb_file_read_proc
comma
l_int|NULL
comma
id|smi
comma
id|THIS_MODULE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
op_eq
l_int|0
)paren
id|rv
op_assign
id|ipmi_smi_add_proc_entry
c_func
(paren
id|smi
comma
l_string|&quot;version&quot;
comma
id|version_file_read_proc
comma
l_int|NULL
comma
id|smi
comma
id|THIS_MODULE
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
DECL|function|remove_proc_entries
r_static
r_void
id|remove_proc_entries
c_func
(paren
id|ipmi_smi_t
id|smi
)paren
(brace
r_struct
id|ipmi_proc_entry
op_star
id|entry
suffix:semicolon
r_while
c_loop
(paren
id|smi-&gt;proc_entries
)paren
(brace
id|entry
op_assign
id|smi-&gt;proc_entries
suffix:semicolon
id|smi-&gt;proc_entries
op_assign
id|entry-&gt;next
suffix:semicolon
id|remove_proc_entry
c_func
(paren
id|entry-&gt;name
comma
id|smi-&gt;proc_dir
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|entry-&gt;name
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|entry
)paren
suffix:semicolon
)brace
id|remove_proc_entry
c_func
(paren
id|smi-&gt;proc_dir_name
comma
id|proc_ipmi_root
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|send_channel_info_cmd
id|send_channel_info_cmd
c_func
(paren
id|ipmi_smi_t
id|intf
comma
r_int
id|chan
)paren
(brace
r_struct
id|kernel_ipmi_msg
id|msg
suffix:semicolon
r_int
r_char
id|data
(braket
l_int|1
)braket
suffix:semicolon
r_struct
id|ipmi_system_interface_addr
id|si
suffix:semicolon
id|si.addr_type
op_assign
id|IPMI_SYSTEM_INTERFACE_ADDR_TYPE
suffix:semicolon
id|si.channel
op_assign
id|IPMI_BMC_CHANNEL
suffix:semicolon
id|si.lun
op_assign
l_int|0
suffix:semicolon
id|msg.netfn
op_assign
id|IPMI_NETFN_APP_REQUEST
suffix:semicolon
id|msg.cmd
op_assign
id|IPMI_GET_CHANNEL_INFO_CMD
suffix:semicolon
id|msg.data
op_assign
id|data
suffix:semicolon
id|msg.data_len
op_assign
l_int|1
suffix:semicolon
id|data
(braket
l_int|0
)braket
op_assign
id|chan
suffix:semicolon
r_return
id|i_ipmi_request
c_func
(paren
l_int|NULL
comma
id|intf
comma
(paren
r_struct
id|ipmi_addr
op_star
)paren
op_amp
id|si
comma
l_int|0
comma
op_amp
id|msg
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
id|intf-&gt;my_address
comma
id|intf-&gt;my_lun
comma
op_minus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|channel_handler
id|channel_handler
c_func
(paren
id|ipmi_smi_t
id|intf
comma
r_struct
id|ipmi_smi_msg
op_star
id|msg
)paren
(brace
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
r_int
id|chan
suffix:semicolon
r_if
c_cond
(paren
(paren
id|msg-&gt;rsp
(braket
l_int|0
)braket
op_eq
(paren
id|IPMI_NETFN_APP_RESPONSE
op_lshift
l_int|2
)paren
)paren
op_logical_and
(paren
id|msg-&gt;rsp
(braket
l_int|1
)braket
op_eq
id|IPMI_GET_CHANNEL_INFO_CMD
)paren
)paren
(brace
multiline_comment|/* It&squot;s the one we want */
r_if
c_cond
(paren
id|msg-&gt;rsp
(braket
l_int|2
)braket
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Got an error from the channel, just go on. */
r_if
c_cond
(paren
id|msg-&gt;rsp
(braket
l_int|2
)braket
op_eq
id|IPMI_INVALID_COMMAND_ERR
)paren
(brace
multiline_comment|/* If the MC does not support this&n;&t;&t;&t;&t;   command, that is legal.  We just&n;&t;&t;&t;&t;   assume it has one IPMB at channel&n;&t;&t;&t;&t;   zero. */
id|intf-&gt;channels
(braket
l_int|0
)braket
dot
id|medium
op_assign
id|IPMI_CHANNEL_MEDIUM_IPMB
suffix:semicolon
id|intf-&gt;channels
(braket
l_int|0
)braket
dot
id|protocol
op_assign
id|IPMI_CHANNEL_PROTOCOL_IPMB
suffix:semicolon
id|rv
op_assign
op_minus
id|ENOSYS
suffix:semicolon
id|intf-&gt;curr_channel
op_assign
id|IPMI_MAX_CHANNELS
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|intf-&gt;waitq
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_goto
id|next_channel
suffix:semicolon
)brace
r_if
c_cond
(paren
id|msg-&gt;rsp_size
OL
l_int|6
)paren
(brace
multiline_comment|/* Message not big enough, just go on. */
r_goto
id|next_channel
suffix:semicolon
)brace
id|chan
op_assign
id|intf-&gt;curr_channel
suffix:semicolon
id|intf-&gt;channels
(braket
id|chan
)braket
dot
id|medium
op_assign
id|msg-&gt;rsp
(braket
l_int|4
)braket
op_amp
l_int|0x7f
suffix:semicolon
id|intf-&gt;channels
(braket
id|chan
)braket
dot
id|protocol
op_assign
id|msg-&gt;rsp
(braket
l_int|5
)braket
op_amp
l_int|0x1f
suffix:semicolon
id|next_channel
suffix:colon
id|intf-&gt;curr_channel
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|intf-&gt;curr_channel
op_ge
id|IPMI_MAX_CHANNELS
)paren
id|wake_up
c_func
(paren
op_amp
id|intf-&gt;waitq
)paren
suffix:semicolon
r_else
id|rv
op_assign
id|send_channel_info_cmd
c_func
(paren
id|intf
comma
id|intf-&gt;curr_channel
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
(brace
multiline_comment|/* Got an error somehow, just give up. */
id|intf-&gt;curr_channel
op_assign
id|IPMI_MAX_CHANNELS
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|intf-&gt;waitq
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
id|PFX
l_string|&quot;Error sending channel information: %d&bslash;n&quot;
comma
id|rv
)paren
suffix:semicolon
)brace
)brace
id|out
suffix:colon
r_return
suffix:semicolon
)brace
DECL|function|ipmi_poll_interface
r_void
id|ipmi_poll_interface
c_func
(paren
id|ipmi_user_t
id|user
)paren
(brace
id|ipmi_smi_t
id|intf
op_assign
id|user-&gt;intf
suffix:semicolon
r_if
c_cond
(paren
id|intf-&gt;handlers-&gt;poll
)paren
id|intf-&gt;handlers
op_member_access_from_pointer
id|poll
c_func
(paren
id|intf-&gt;send_info
)paren
suffix:semicolon
)brace
DECL|function|ipmi_register_smi
r_int
id|ipmi_register_smi
c_func
(paren
r_struct
id|ipmi_smi_handlers
op_star
id|handlers
comma
r_void
op_star
id|send_info
comma
r_int
r_char
id|version_major
comma
r_int
r_char
id|version_minor
comma
id|ipmi_smi_t
op_star
id|intf
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_int
id|rv
suffix:semicolon
id|ipmi_smi_t
id|new_intf
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Make sure the driver is actually initialized, this handles&n;&t;   problems with initialization order. */
r_if
c_cond
(paren
op_logical_neg
id|initialized
)paren
(brace
id|rv
op_assign
id|ipmi_init_msghandler
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
r_return
id|rv
suffix:semicolon
multiline_comment|/* The init code doesn&squot;t return an error if it was turned&n;&t;&t;   off, but it won&squot;t initialize.  Check that. */
r_if
c_cond
(paren
op_logical_neg
id|initialized
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|new_intf
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|new_intf
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_intf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|new_intf
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|new_intf
)paren
)paren
suffix:semicolon
id|new_intf-&gt;proc_dir
op_assign
l_int|NULL
suffix:semicolon
id|rv
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|interfaces_sem
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_IPMI_INTERFACES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ipmi_interfaces
(braket
id|i
)braket
op_eq
l_int|NULL
)paren
(brace
id|new_intf-&gt;intf_num
op_assign
id|i
suffix:semicolon
id|new_intf-&gt;version_major
op_assign
id|version_major
suffix:semicolon
id|new_intf-&gt;version_minor
op_assign
id|version_minor
suffix:semicolon
id|new_intf-&gt;my_address
op_assign
id|IPMI_BMC_SLAVE_ADDR
suffix:semicolon
id|new_intf-&gt;my_lun
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* the SMS LUN. */
id|rwlock_init
c_func
(paren
op_amp
(paren
id|new_intf-&gt;users_lock
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
(paren
id|new_intf-&gt;users
)paren
)paren
suffix:semicolon
id|new_intf-&gt;handlers
op_assign
id|handlers
suffix:semicolon
id|new_intf-&gt;send_info
op_assign
id|send_info
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
(paren
id|new_intf-&gt;seq_lock
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|IPMI_IPMB_NUM_SEQ
suffix:semicolon
id|j
op_increment
)paren
(brace
id|new_intf-&gt;seq_table
(braket
id|j
)braket
dot
id|inuse
op_assign
l_int|0
suffix:semicolon
id|new_intf-&gt;seq_table
(braket
id|j
)braket
dot
id|seqid
op_assign
l_int|0
suffix:semicolon
)brace
id|new_intf-&gt;curr_seq
op_assign
l_int|0
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
(paren
id|new_intf-&gt;waiting_msgs_lock
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
(paren
id|new_intf-&gt;waiting_msgs
)paren
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
(paren
id|new_intf-&gt;events_lock
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
(paren
id|new_intf-&gt;waiting_events
)paren
)paren
suffix:semicolon
id|new_intf-&gt;waiting_events_count
op_assign
l_int|0
suffix:semicolon
id|rwlock_init
c_func
(paren
op_amp
(paren
id|new_intf-&gt;cmd_rcvr_lock
)paren
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|new_intf-&gt;waitq
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
(paren
id|new_intf-&gt;cmd_rcvrs
)paren
)paren
suffix:semicolon
id|new_intf-&gt;all_cmd_rcvr
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
(paren
id|new_intf-&gt;counter_lock
)paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|interfaces_lock
comma
id|flags
)paren
suffix:semicolon
id|ipmi_interfaces
(braket
id|i
)braket
op_assign
id|new_intf
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|interfaces_lock
comma
id|flags
)paren
suffix:semicolon
id|rv
op_assign
l_int|0
suffix:semicolon
op_star
id|intf
op_assign
id|new_intf
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|downgrade_write
c_func
(paren
op_amp
id|interfaces_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
op_eq
l_int|0
)paren
id|rv
op_assign
id|add_proc_entries
c_func
(paren
op_star
id|intf
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|version_major
OG
l_int|1
)paren
op_logical_or
(paren
(paren
id|version_major
op_eq
l_int|1
)paren
op_logical_and
(paren
id|version_minor
op_ge
l_int|5
)paren
)paren
)paren
(brace
multiline_comment|/* Start scanning the channels to see what is&n;&t;&t;&t;   available. */
(paren
op_star
id|intf
)paren
op_member_access_from_pointer
id|null_user_handler
op_assign
id|channel_handler
suffix:semicolon
(paren
op_star
id|intf
)paren
op_member_access_from_pointer
id|curr_channel
op_assign
l_int|0
suffix:semicolon
id|rv
op_assign
id|send_channel_info_cmd
c_func
(paren
op_star
id|intf
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Wait for the channel info to be read. */
id|up_read
c_func
(paren
op_amp
id|interfaces_sem
)paren
suffix:semicolon
id|wait_event
c_func
(paren
(paren
op_star
id|intf
)paren
op_member_access_from_pointer
id|waitq
comma
(paren
(paren
op_star
id|intf
)paren
op_member_access_from_pointer
id|curr_channel
op_ge
id|IPMI_MAX_CHANNELS
)paren
)paren
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|interfaces_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ipmi_interfaces
(braket
id|i
)braket
op_ne
id|new_intf
)paren
multiline_comment|/* Well, it went away.  Just return. */
r_goto
id|out
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Assume a single IPMB channel at zero. */
(paren
op_star
id|intf
)paren
op_member_access_from_pointer
id|channels
(braket
l_int|0
)braket
dot
id|medium
op_assign
id|IPMI_CHANNEL_MEDIUM_IPMB
suffix:semicolon
(paren
op_star
id|intf
)paren
op_member_access_from_pointer
id|channels
(braket
l_int|0
)braket
dot
id|protocol
op_assign
id|IPMI_CHANNEL_PROTOCOL_IPMB
suffix:semicolon
)brace
multiline_comment|/* Call all the watcher interfaces to tell&n;&t;&t;   them that a new interface is available. */
id|call_smi_watchers
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|up_read
c_func
(paren
op_amp
id|interfaces_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
(brace
r_if
c_cond
(paren
id|new_intf-&gt;proc_dir
)paren
id|remove_proc_entries
c_func
(paren
id|new_intf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|new_intf
)paren
suffix:semicolon
)brace
r_return
id|rv
suffix:semicolon
)brace
DECL|function|free_recv_msg_list
r_static
r_void
id|free_recv_msg_list
c_func
(paren
r_struct
id|list_head
op_star
id|q
)paren
(brace
r_struct
id|ipmi_recv_msg
op_star
id|msg
comma
op_star
id|msg2
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|msg
comma
id|msg2
comma
id|q
comma
id|link
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|msg-&gt;link
)paren
suffix:semicolon
id|ipmi_free_recv_msg
c_func
(paren
id|msg
)paren
suffix:semicolon
)brace
)brace
DECL|function|free_cmd_rcvr_list
r_static
r_void
id|free_cmd_rcvr_list
c_func
(paren
r_struct
id|list_head
op_star
id|q
)paren
(brace
r_struct
id|cmd_rcvr
op_star
id|rcvr
comma
op_star
id|rcvr2
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|rcvr
comma
id|rcvr2
comma
id|q
comma
id|link
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|rcvr-&gt;link
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|rcvr
)paren
suffix:semicolon
)brace
)brace
DECL|function|clean_up_interface_data
r_static
r_void
id|clean_up_interface_data
c_func
(paren
id|ipmi_smi_t
id|intf
)paren
(brace
r_int
id|i
suffix:semicolon
id|free_recv_msg_list
c_func
(paren
op_amp
(paren
id|intf-&gt;waiting_msgs
)paren
)paren
suffix:semicolon
id|free_recv_msg_list
c_func
(paren
op_amp
(paren
id|intf-&gt;waiting_events
)paren
)paren
suffix:semicolon
id|free_cmd_rcvr_list
c_func
(paren
op_amp
(paren
id|intf-&gt;cmd_rcvrs
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IPMI_IPMB_NUM_SEQ
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|intf-&gt;seq_table
(braket
id|i
)braket
dot
id|inuse
)paren
op_logical_and
(paren
id|intf-&gt;seq_table
(braket
id|i
)braket
dot
id|recv_msg
)paren
)paren
(brace
id|ipmi_free_recv_msg
c_func
(paren
id|intf-&gt;seq_table
(braket
id|i
)braket
dot
id|recv_msg
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|ipmi_unregister_smi
r_int
id|ipmi_unregister_smi
c_func
(paren
id|ipmi_smi_t
id|intf
)paren
(brace
r_int
id|rv
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|ipmi_smi_watcher
op_star
id|w
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|interfaces_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
(paren
id|intf-&gt;users
)paren
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_IPMI_INTERFACES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ipmi_interfaces
(braket
id|i
)braket
op_eq
id|intf
)paren
(brace
id|remove_proc_entries
c_func
(paren
id|intf
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|interfaces_lock
comma
id|flags
)paren
suffix:semicolon
id|ipmi_interfaces
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|clean_up_interface_data
c_func
(paren
id|intf
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|interfaces_lock
comma
id|flags
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|intf
)paren
suffix:semicolon
id|rv
op_assign
l_int|0
suffix:semicolon
r_goto
id|out_call_watcher
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|rv
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
id|up_write
c_func
(paren
op_amp
id|interfaces_sem
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
id|out_call_watcher
suffix:colon
id|downgrade_write
c_func
(paren
op_amp
id|interfaces_sem
)paren
suffix:semicolon
multiline_comment|/* Call all the watcher interfaces to tell them that&n;&t;   an interface is gone. */
id|down_read
c_func
(paren
op_amp
id|smi_watchers_sem
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|w
comma
op_amp
id|smi_watchers
comma
id|link
)paren
(brace
id|w
op_member_access_from_pointer
id|smi_gone
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
id|up_read
c_func
(paren
op_amp
id|smi_watchers_sem
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|interfaces_sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|handle_ipmb_get_msg_rsp
r_static
r_int
id|handle_ipmb_get_msg_rsp
c_func
(paren
id|ipmi_smi_t
id|intf
comma
r_struct
id|ipmi_smi_msg
op_star
id|msg
)paren
(brace
r_struct
id|ipmi_ipmb_addr
id|ipmb_addr
suffix:semicolon
r_struct
id|ipmi_recv_msg
op_star
id|recv_msg
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* This is 11, not 10, because the response must contain a&n;&t; * completion code. */
r_if
c_cond
(paren
id|msg-&gt;rsp_size
OL
l_int|11
)paren
(brace
multiline_comment|/* Message not big enough, just ignore it. */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|intf-&gt;invalid_ipmb_responses
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|msg-&gt;rsp
(braket
l_int|2
)braket
op_ne
l_int|0
)paren
(brace
multiline_comment|/* An error getting the response, just ignore it. */
r_return
l_int|0
suffix:semicolon
)brace
id|ipmb_addr.addr_type
op_assign
id|IPMI_IPMB_ADDR_TYPE
suffix:semicolon
id|ipmb_addr.slave_addr
op_assign
id|msg-&gt;rsp
(braket
l_int|6
)braket
suffix:semicolon
id|ipmb_addr.channel
op_assign
id|msg-&gt;rsp
(braket
l_int|3
)braket
op_amp
l_int|0x0f
suffix:semicolon
id|ipmb_addr.lun
op_assign
id|msg-&gt;rsp
(braket
l_int|7
)braket
op_amp
l_int|3
suffix:semicolon
multiline_comment|/* It&squot;s a response from a remote entity.  Look up the sequence&n;&t;   number and handle the response. */
r_if
c_cond
(paren
id|intf_find_seq
c_func
(paren
id|intf
comma
id|msg-&gt;rsp
(braket
l_int|7
)braket
op_rshift
l_int|2
comma
id|msg-&gt;rsp
(braket
l_int|3
)braket
op_amp
l_int|0x0f
comma
id|msg-&gt;rsp
(braket
l_int|8
)braket
comma
(paren
id|msg-&gt;rsp
(braket
l_int|4
)braket
op_rshift
l_int|2
)paren
op_amp
(paren
op_complement
l_int|1
)paren
comma
(paren
r_struct
id|ipmi_addr
op_star
)paren
op_amp
(paren
id|ipmb_addr
)paren
comma
op_amp
id|recv_msg
)paren
)paren
(brace
multiline_comment|/* We were unable to find the sequence number,&n;&t;&t;   so just nuke the message. */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|intf-&gt;unhandled_ipmb_responses
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|recv_msg-&gt;msg_data
comma
op_amp
(paren
id|msg-&gt;rsp
(braket
l_int|9
)braket
)paren
comma
id|msg-&gt;rsp_size
op_minus
l_int|9
)paren
suffix:semicolon
multiline_comment|/* THe other fields matched, so no need to set them, except&n;           for netfn, which needs to be the response that was&n;           returned, not the request value. */
id|recv_msg-&gt;msg.netfn
op_assign
id|msg-&gt;rsp
(braket
l_int|4
)braket
op_rshift
l_int|2
suffix:semicolon
id|recv_msg-&gt;msg.data
op_assign
id|recv_msg-&gt;msg_data
suffix:semicolon
id|recv_msg-&gt;msg.data_len
op_assign
id|msg-&gt;rsp_size
op_minus
l_int|10
suffix:semicolon
id|recv_msg-&gt;recv_type
op_assign
id|IPMI_RESPONSE_RECV_TYPE
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|intf-&gt;handled_ipmb_responses
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|deliver_response
c_func
(paren
id|recv_msg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|handle_ipmb_get_msg_cmd
r_static
r_int
id|handle_ipmb_get_msg_cmd
c_func
(paren
id|ipmi_smi_t
id|intf
comma
r_struct
id|ipmi_smi_msg
op_star
id|msg
)paren
(brace
r_struct
id|cmd_rcvr
op_star
id|rcvr
suffix:semicolon
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|netfn
suffix:semicolon
r_int
r_char
id|cmd
suffix:semicolon
id|ipmi_user_t
id|user
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ipmi_ipmb_addr
op_star
id|ipmb_addr
suffix:semicolon
r_struct
id|ipmi_recv_msg
op_star
id|recv_msg
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|msg-&gt;rsp_size
OL
l_int|10
)paren
(brace
multiline_comment|/* Message not big enough, just ignore it. */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|intf-&gt;invalid_commands
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|msg-&gt;rsp
(braket
l_int|2
)braket
op_ne
l_int|0
)paren
(brace
multiline_comment|/* An error getting the response, just ignore it. */
r_return
l_int|0
suffix:semicolon
)brace
id|netfn
op_assign
id|msg-&gt;rsp
(braket
l_int|4
)braket
op_rshift
l_int|2
suffix:semicolon
id|cmd
op_assign
id|msg-&gt;rsp
(braket
l_int|8
)braket
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
(paren
id|intf-&gt;cmd_rcvr_lock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intf-&gt;all_cmd_rcvr
)paren
(brace
id|user
op_assign
id|intf-&gt;all_cmd_rcvr
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Find the command/netfn. */
id|list_for_each_entry
c_func
(paren
id|rcvr
comma
op_amp
(paren
id|intf-&gt;cmd_rcvrs
)paren
comma
id|link
)paren
(brace
r_if
c_cond
(paren
(paren
id|rcvr-&gt;netfn
op_eq
id|netfn
)paren
op_logical_and
(paren
id|rcvr-&gt;cmd
op_eq
id|cmd
)paren
)paren
(brace
id|user
op_assign
id|rcvr-&gt;user
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
(paren
id|intf-&gt;cmd_rcvr_lock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|user
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* We didn&squot;t find a user, deliver an error response. */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|intf-&gt;unhandled_commands
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|msg-&gt;data
(braket
l_int|0
)braket
op_assign
(paren
id|IPMI_NETFN_APP_REQUEST
op_lshift
l_int|2
)paren
suffix:semicolon
id|msg-&gt;data
(braket
l_int|1
)braket
op_assign
id|IPMI_SEND_MSG_CMD
suffix:semicolon
id|msg-&gt;data
(braket
l_int|2
)braket
op_assign
id|msg-&gt;rsp
(braket
l_int|3
)braket
suffix:semicolon
id|msg-&gt;data
(braket
l_int|3
)braket
op_assign
id|msg-&gt;rsp
(braket
l_int|6
)braket
suffix:semicolon
id|msg-&gt;data
(braket
l_int|4
)braket
op_assign
(paren
(paren
id|netfn
op_plus
l_int|1
)paren
op_lshift
l_int|2
)paren
op_or
(paren
id|msg-&gt;rsp
(braket
l_int|7
)braket
op_amp
l_int|0x3
)paren
suffix:semicolon
id|msg-&gt;data
(braket
l_int|5
)braket
op_assign
id|ipmb_checksum
c_func
(paren
op_amp
(paren
id|msg-&gt;data
(braket
l_int|3
)braket
)paren
comma
l_int|2
)paren
suffix:semicolon
id|msg-&gt;data
(braket
l_int|6
)braket
op_assign
id|intf-&gt;my_address
suffix:semicolon
multiline_comment|/* rqseq/lun */
id|msg-&gt;data
(braket
l_int|7
)braket
op_assign
(paren
id|msg-&gt;rsp
(braket
l_int|7
)braket
op_amp
l_int|0xfc
)paren
op_or
(paren
id|msg-&gt;rsp
(braket
l_int|4
)braket
op_amp
l_int|0x3
)paren
suffix:semicolon
id|msg-&gt;data
(braket
l_int|8
)braket
op_assign
id|msg-&gt;rsp
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* cmd */
id|msg-&gt;data
(braket
l_int|9
)braket
op_assign
id|IPMI_INVALID_CMD_COMPLETION_CODE
suffix:semicolon
id|msg-&gt;data
(braket
l_int|10
)braket
op_assign
id|ipmb_checksum
c_func
(paren
op_amp
(paren
id|msg-&gt;data
(braket
l_int|6
)braket
)paren
comma
l_int|4
)paren
suffix:semicolon
id|msg-&gt;data_size
op_assign
l_int|11
suffix:semicolon
macro_line|#ifdef DEBUG_MSGING
(brace
r_int
id|m
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Invalid command:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
l_int|0
suffix:semicolon
id|m
OL
id|msg-&gt;data_size
suffix:semicolon
id|m
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %2.2x&quot;
comma
id|msg-&gt;data
(braket
id|m
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|intf-&gt;handlers
op_member_access_from_pointer
id|sender
c_func
(paren
id|intf-&gt;send_info
comma
id|msg
comma
l_int|0
)paren
suffix:semicolon
id|rv
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* We used the message, so return the value that&n;&t;&t;&t;    causes it to not be freed or queued. */
)brace
r_else
(brace
multiline_comment|/* Deliver the message to the user. */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|intf-&gt;handled_commands
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|recv_msg
op_assign
id|ipmi_alloc_recv_msg
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|recv_msg
)paren
(brace
multiline_comment|/* We couldn&squot;t allocate memory for the&n;                           message, so requeue it for handling&n;                           later. */
id|rv
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Extract the source address from the data. */
id|ipmb_addr
op_assign
(paren
r_struct
id|ipmi_ipmb_addr
op_star
)paren
op_amp
id|recv_msg-&gt;addr
suffix:semicolon
id|ipmb_addr-&gt;addr_type
op_assign
id|IPMI_IPMB_ADDR_TYPE
suffix:semicolon
id|ipmb_addr-&gt;slave_addr
op_assign
id|msg-&gt;rsp
(braket
l_int|6
)braket
suffix:semicolon
id|ipmb_addr-&gt;lun
op_assign
id|msg-&gt;rsp
(braket
l_int|7
)braket
op_amp
l_int|3
suffix:semicolon
id|ipmb_addr-&gt;channel
op_assign
id|msg-&gt;rsp
(braket
l_int|3
)braket
op_amp
l_int|0xf
suffix:semicolon
multiline_comment|/* Extract the rest of the message information&n;&t;&t;&t;   from the IPMB header.*/
id|recv_msg-&gt;user
op_assign
id|user
suffix:semicolon
id|recv_msg-&gt;recv_type
op_assign
id|IPMI_CMD_RECV_TYPE
suffix:semicolon
id|recv_msg-&gt;msgid
op_assign
id|msg-&gt;rsp
(braket
l_int|7
)braket
op_rshift
l_int|2
suffix:semicolon
id|recv_msg-&gt;msg.netfn
op_assign
id|msg-&gt;rsp
(braket
l_int|4
)braket
op_rshift
l_int|2
suffix:semicolon
id|recv_msg-&gt;msg.cmd
op_assign
id|msg-&gt;rsp
(braket
l_int|8
)braket
suffix:semicolon
id|recv_msg-&gt;msg.data
op_assign
id|recv_msg-&gt;msg_data
suffix:semicolon
multiline_comment|/* We chop off 10, not 9 bytes because the checksum&n;&t;&t;&t;   at the end also needs to be removed. */
id|recv_msg-&gt;msg.data_len
op_assign
id|msg-&gt;rsp_size
op_minus
l_int|10
suffix:semicolon
id|memcpy
c_func
(paren
id|recv_msg-&gt;msg_data
comma
op_amp
(paren
id|msg-&gt;rsp
(braket
l_int|9
)braket
)paren
comma
id|msg-&gt;rsp_size
op_minus
l_int|10
)paren
suffix:semicolon
id|deliver_response
c_func
(paren
id|recv_msg
)paren
suffix:semicolon
)brace
)brace
r_return
id|rv
suffix:semicolon
)brace
DECL|function|handle_lan_get_msg_rsp
r_static
r_int
id|handle_lan_get_msg_rsp
c_func
(paren
id|ipmi_smi_t
id|intf
comma
r_struct
id|ipmi_smi_msg
op_star
id|msg
)paren
(brace
r_struct
id|ipmi_lan_addr
id|lan_addr
suffix:semicolon
r_struct
id|ipmi_recv_msg
op_star
id|recv_msg
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* This is 13, not 12, because the response must contain a&n;&t; * completion code. */
r_if
c_cond
(paren
id|msg-&gt;rsp_size
OL
l_int|13
)paren
(brace
multiline_comment|/* Message not big enough, just ignore it. */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|intf-&gt;invalid_lan_responses
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|msg-&gt;rsp
(braket
l_int|2
)braket
op_ne
l_int|0
)paren
(brace
multiline_comment|/* An error getting the response, just ignore it. */
r_return
l_int|0
suffix:semicolon
)brace
id|lan_addr.addr_type
op_assign
id|IPMI_LAN_ADDR_TYPE
suffix:semicolon
id|lan_addr.session_handle
op_assign
id|msg-&gt;rsp
(braket
l_int|4
)braket
suffix:semicolon
id|lan_addr.remote_SWID
op_assign
id|msg-&gt;rsp
(braket
l_int|8
)braket
suffix:semicolon
id|lan_addr.local_SWID
op_assign
id|msg-&gt;rsp
(braket
l_int|5
)braket
suffix:semicolon
id|lan_addr.channel
op_assign
id|msg-&gt;rsp
(braket
l_int|3
)braket
op_amp
l_int|0x0f
suffix:semicolon
id|lan_addr.privilege
op_assign
id|msg-&gt;rsp
(braket
l_int|3
)braket
op_rshift
l_int|4
suffix:semicolon
id|lan_addr.lun
op_assign
id|msg-&gt;rsp
(braket
l_int|9
)braket
op_amp
l_int|3
suffix:semicolon
multiline_comment|/* It&squot;s a response from a remote entity.  Look up the sequence&n;&t;   number and handle the response. */
r_if
c_cond
(paren
id|intf_find_seq
c_func
(paren
id|intf
comma
id|msg-&gt;rsp
(braket
l_int|9
)braket
op_rshift
l_int|2
comma
id|msg-&gt;rsp
(braket
l_int|3
)braket
op_amp
l_int|0x0f
comma
id|msg-&gt;rsp
(braket
l_int|10
)braket
comma
(paren
id|msg-&gt;rsp
(braket
l_int|6
)braket
op_rshift
l_int|2
)paren
op_amp
(paren
op_complement
l_int|1
)paren
comma
(paren
r_struct
id|ipmi_addr
op_star
)paren
op_amp
(paren
id|lan_addr
)paren
comma
op_amp
id|recv_msg
)paren
)paren
(brace
multiline_comment|/* We were unable to find the sequence number,&n;&t;&t;   so just nuke the message. */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|intf-&gt;unhandled_lan_responses
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|recv_msg-&gt;msg_data
comma
op_amp
(paren
id|msg-&gt;rsp
(braket
l_int|11
)braket
)paren
comma
id|msg-&gt;rsp_size
op_minus
l_int|11
)paren
suffix:semicolon
multiline_comment|/* The other fields matched, so no need to set them, except&n;           for netfn, which needs to be the response that was&n;           returned, not the request value. */
id|recv_msg-&gt;msg.netfn
op_assign
id|msg-&gt;rsp
(braket
l_int|6
)braket
op_rshift
l_int|2
suffix:semicolon
id|recv_msg-&gt;msg.data
op_assign
id|recv_msg-&gt;msg_data
suffix:semicolon
id|recv_msg-&gt;msg.data_len
op_assign
id|msg-&gt;rsp_size
op_minus
l_int|12
suffix:semicolon
id|recv_msg-&gt;recv_type
op_assign
id|IPMI_RESPONSE_RECV_TYPE
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|intf-&gt;handled_lan_responses
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|deliver_response
c_func
(paren
id|recv_msg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|handle_lan_get_msg_cmd
r_static
r_int
id|handle_lan_get_msg_cmd
c_func
(paren
id|ipmi_smi_t
id|intf
comma
r_struct
id|ipmi_smi_msg
op_star
id|msg
)paren
(brace
r_struct
id|cmd_rcvr
op_star
id|rcvr
suffix:semicolon
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|netfn
suffix:semicolon
r_int
r_char
id|cmd
suffix:semicolon
id|ipmi_user_t
id|user
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ipmi_lan_addr
op_star
id|lan_addr
suffix:semicolon
r_struct
id|ipmi_recv_msg
op_star
id|recv_msg
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|msg-&gt;rsp_size
OL
l_int|12
)paren
(brace
multiline_comment|/* Message not big enough, just ignore it. */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|intf-&gt;invalid_commands
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|msg-&gt;rsp
(braket
l_int|2
)braket
op_ne
l_int|0
)paren
(brace
multiline_comment|/* An error getting the response, just ignore it. */
r_return
l_int|0
suffix:semicolon
)brace
id|netfn
op_assign
id|msg-&gt;rsp
(braket
l_int|6
)braket
op_rshift
l_int|2
suffix:semicolon
id|cmd
op_assign
id|msg-&gt;rsp
(braket
l_int|10
)braket
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
(paren
id|intf-&gt;cmd_rcvr_lock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intf-&gt;all_cmd_rcvr
)paren
(brace
id|user
op_assign
id|intf-&gt;all_cmd_rcvr
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Find the command/netfn. */
id|list_for_each_entry
c_func
(paren
id|rcvr
comma
op_amp
(paren
id|intf-&gt;cmd_rcvrs
)paren
comma
id|link
)paren
(brace
r_if
c_cond
(paren
(paren
id|rcvr-&gt;netfn
op_eq
id|netfn
)paren
op_logical_and
(paren
id|rcvr-&gt;cmd
op_eq
id|cmd
)paren
)paren
(brace
id|user
op_assign
id|rcvr-&gt;user
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
(paren
id|intf-&gt;cmd_rcvr_lock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|user
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* We didn&squot;t find a user, deliver an error response. */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|intf-&gt;unhandled_commands
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|rv
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Don&squot;t do anything with these messages, just&n;&t;&t;&t;   allow them to be freed. */
)brace
r_else
(brace
multiline_comment|/* Deliver the message to the user. */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|intf-&gt;handled_commands
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|recv_msg
op_assign
id|ipmi_alloc_recv_msg
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|recv_msg
)paren
(brace
multiline_comment|/* We couldn&squot;t allocate memory for the&n;                           message, so requeue it for handling&n;                           later. */
id|rv
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Extract the source address from the data. */
id|lan_addr
op_assign
(paren
r_struct
id|ipmi_lan_addr
op_star
)paren
op_amp
id|recv_msg-&gt;addr
suffix:semicolon
id|lan_addr-&gt;addr_type
op_assign
id|IPMI_LAN_ADDR_TYPE
suffix:semicolon
id|lan_addr-&gt;session_handle
op_assign
id|msg-&gt;rsp
(braket
l_int|4
)braket
suffix:semicolon
id|lan_addr-&gt;remote_SWID
op_assign
id|msg-&gt;rsp
(braket
l_int|8
)braket
suffix:semicolon
id|lan_addr-&gt;local_SWID
op_assign
id|msg-&gt;rsp
(braket
l_int|5
)braket
suffix:semicolon
id|lan_addr-&gt;lun
op_assign
id|msg-&gt;rsp
(braket
l_int|9
)braket
op_amp
l_int|3
suffix:semicolon
id|lan_addr-&gt;channel
op_assign
id|msg-&gt;rsp
(braket
l_int|3
)braket
op_amp
l_int|0xf
suffix:semicolon
id|lan_addr-&gt;privilege
op_assign
id|msg-&gt;rsp
(braket
l_int|3
)braket
op_rshift
l_int|4
suffix:semicolon
multiline_comment|/* Extract the rest of the message information&n;&t;&t;&t;   from the IPMB header.*/
id|recv_msg-&gt;user
op_assign
id|user
suffix:semicolon
id|recv_msg-&gt;recv_type
op_assign
id|IPMI_CMD_RECV_TYPE
suffix:semicolon
id|recv_msg-&gt;msgid
op_assign
id|msg-&gt;rsp
(braket
l_int|9
)braket
op_rshift
l_int|2
suffix:semicolon
id|recv_msg-&gt;msg.netfn
op_assign
id|msg-&gt;rsp
(braket
l_int|6
)braket
op_rshift
l_int|2
suffix:semicolon
id|recv_msg-&gt;msg.cmd
op_assign
id|msg-&gt;rsp
(braket
l_int|10
)braket
suffix:semicolon
id|recv_msg-&gt;msg.data
op_assign
id|recv_msg-&gt;msg_data
suffix:semicolon
multiline_comment|/* We chop off 12, not 11 bytes because the checksum&n;&t;&t;&t;   at the end also needs to be removed. */
id|recv_msg-&gt;msg.data_len
op_assign
id|msg-&gt;rsp_size
op_minus
l_int|12
suffix:semicolon
id|memcpy
c_func
(paren
id|recv_msg-&gt;msg_data
comma
op_amp
(paren
id|msg-&gt;rsp
(braket
l_int|11
)braket
)paren
comma
id|msg-&gt;rsp_size
op_minus
l_int|12
)paren
suffix:semicolon
id|deliver_response
c_func
(paren
id|recv_msg
)paren
suffix:semicolon
)brace
)brace
r_return
id|rv
suffix:semicolon
)brace
DECL|function|copy_event_into_recv_msg
r_static
r_void
id|copy_event_into_recv_msg
c_func
(paren
r_struct
id|ipmi_recv_msg
op_star
id|recv_msg
comma
r_struct
id|ipmi_smi_msg
op_star
id|msg
)paren
(brace
r_struct
id|ipmi_system_interface_addr
op_star
id|smi_addr
suffix:semicolon
id|recv_msg-&gt;msgid
op_assign
l_int|0
suffix:semicolon
id|smi_addr
op_assign
(paren
r_struct
id|ipmi_system_interface_addr
op_star
)paren
op_amp
(paren
id|recv_msg-&gt;addr
)paren
suffix:semicolon
id|smi_addr-&gt;addr_type
op_assign
id|IPMI_SYSTEM_INTERFACE_ADDR_TYPE
suffix:semicolon
id|smi_addr-&gt;channel
op_assign
id|IPMI_BMC_CHANNEL
suffix:semicolon
id|smi_addr-&gt;lun
op_assign
id|msg-&gt;rsp
(braket
l_int|0
)braket
op_amp
l_int|3
suffix:semicolon
id|recv_msg-&gt;recv_type
op_assign
id|IPMI_ASYNC_EVENT_RECV_TYPE
suffix:semicolon
id|recv_msg-&gt;msg.netfn
op_assign
id|msg-&gt;rsp
(braket
l_int|0
)braket
op_rshift
l_int|2
suffix:semicolon
id|recv_msg-&gt;msg.cmd
op_assign
id|msg-&gt;rsp
(braket
l_int|1
)braket
suffix:semicolon
id|memcpy
c_func
(paren
id|recv_msg-&gt;msg_data
comma
op_amp
(paren
id|msg-&gt;rsp
(braket
l_int|3
)braket
)paren
comma
id|msg-&gt;rsp_size
op_minus
l_int|3
)paren
suffix:semicolon
id|recv_msg-&gt;msg.data
op_assign
id|recv_msg-&gt;msg_data
suffix:semicolon
id|recv_msg-&gt;msg.data_len
op_assign
id|msg-&gt;rsp_size
op_minus
l_int|3
suffix:semicolon
)brace
multiline_comment|/* This will be called with the intf-&gt;users_lock read-locked, so no need&n;   to do that here. */
DECL|function|handle_read_event_rsp
r_static
r_int
id|handle_read_event_rsp
c_func
(paren
id|ipmi_smi_t
id|intf
comma
r_struct
id|ipmi_smi_msg
op_star
id|msg
)paren
(brace
r_struct
id|ipmi_recv_msg
op_star
id|recv_msg
comma
op_star
id|recv_msg2
suffix:semicolon
r_struct
id|list_head
id|msgs
suffix:semicolon
id|ipmi_user_t
id|user
suffix:semicolon
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
r_int
id|deliver_count
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|msg-&gt;rsp_size
OL
l_int|19
)paren
(brace
multiline_comment|/* Message is too small to be an IPMB event. */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|intf-&gt;invalid_events
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|msg-&gt;rsp
(braket
l_int|2
)braket
op_ne
l_int|0
)paren
(brace
multiline_comment|/* An error getting the event, just ignore it. */
r_return
l_int|0
suffix:semicolon
)brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|msgs
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|intf-&gt;events_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|intf-&gt;counter_lock
)paren
suffix:semicolon
id|intf-&gt;events
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|intf-&gt;counter_lock
)paren
suffix:semicolon
multiline_comment|/* Allocate and fill in one message for every user that is getting&n;&t;   events. */
id|list_for_each_entry
c_func
(paren
id|user
comma
op_amp
(paren
id|intf-&gt;users
)paren
comma
id|link
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|user-&gt;gets_events
)paren
r_continue
suffix:semicolon
id|recv_msg
op_assign
id|ipmi_alloc_recv_msg
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|recv_msg
)paren
(brace
id|list_for_each_entry_safe
c_func
(paren
id|recv_msg
comma
id|recv_msg2
comma
op_amp
id|msgs
comma
id|link
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|recv_msg-&gt;link
)paren
suffix:semicolon
id|ipmi_free_recv_msg
c_func
(paren
id|recv_msg
)paren
suffix:semicolon
)brace
multiline_comment|/* We couldn&squot;t allocate memory for the&n;                           message, so requeue it for handling&n;                           later. */
id|rv
op_assign
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|deliver_count
op_increment
suffix:semicolon
id|copy_event_into_recv_msg
c_func
(paren
id|recv_msg
comma
id|msg
)paren
suffix:semicolon
id|recv_msg-&gt;user
op_assign
id|user
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
(paren
id|recv_msg-&gt;link
)paren
comma
op_amp
id|msgs
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|deliver_count
)paren
(brace
multiline_comment|/* Now deliver all the messages. */
id|list_for_each_entry_safe
c_func
(paren
id|recv_msg
comma
id|recv_msg2
comma
op_amp
id|msgs
comma
id|link
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|recv_msg-&gt;link
)paren
suffix:semicolon
id|deliver_response
c_func
(paren
id|recv_msg
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|intf-&gt;waiting_events_count
OL
id|MAX_EVENTS_IN_QUEUE
)paren
(brace
multiline_comment|/* No one to receive the message, put it in queue if there&squot;s&n;&t;&t;   not already too many things in the queue. */
id|recv_msg
op_assign
id|ipmi_alloc_recv_msg
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|recv_msg
)paren
(brace
multiline_comment|/* We couldn&squot;t allocate memory for the&n;                           message, so requeue it for handling&n;                           later. */
id|rv
op_assign
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|copy_event_into_recv_msg
c_func
(paren
id|recv_msg
comma
id|msg
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
(paren
id|recv_msg-&gt;link
)paren
comma
op_amp
(paren
id|intf-&gt;waiting_events
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* There&squot;s too many things in the queue, discard this&n;&t;&t;   message. */
id|printk
c_func
(paren
id|KERN_WARNING
id|PFX
l_string|&quot;Event queue full, discarding an&quot;
l_string|&quot; incoming event&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|intf-&gt;events_lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
DECL|function|handle_bmc_rsp
r_static
r_int
id|handle_bmc_rsp
c_func
(paren
id|ipmi_smi_t
id|intf
comma
r_struct
id|ipmi_smi_msg
op_star
id|msg
)paren
(brace
r_struct
id|ipmi_recv_msg
op_star
id|recv_msg
suffix:semicolon
r_int
id|found
op_assign
l_int|0
suffix:semicolon
r_struct
id|ipmi_user
op_star
id|user
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|recv_msg
op_assign
(paren
r_struct
id|ipmi_recv_msg
op_star
)paren
id|msg-&gt;user_data
suffix:semicolon
multiline_comment|/* Make sure the user still exists. */
id|list_for_each_entry
c_func
(paren
id|user
comma
op_amp
(paren
id|intf-&gt;users
)paren
comma
id|link
)paren
(brace
r_if
c_cond
(paren
id|user
op_eq
id|recv_msg-&gt;user
)paren
(brace
multiline_comment|/* Found it, so we can deliver it */
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
multiline_comment|/* Special handling for NULL users. */
r_if
c_cond
(paren
op_logical_neg
id|recv_msg-&gt;user
op_logical_and
id|intf-&gt;null_user_handler
)paren
id|intf
op_member_access_from_pointer
id|null_user_handler
c_func
(paren
id|intf
comma
id|msg
)paren
suffix:semicolon
multiline_comment|/* The user for the message went away, so give up. */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|intf-&gt;unhandled_local_responses
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|ipmi_free_recv_msg
c_func
(paren
id|recv_msg
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|ipmi_system_interface_addr
op_star
id|smi_addr
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|intf-&gt;handled_local_responses
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|recv_msg-&gt;recv_type
op_assign
id|IPMI_RESPONSE_RECV_TYPE
suffix:semicolon
id|recv_msg-&gt;msgid
op_assign
id|msg-&gt;msgid
suffix:semicolon
id|smi_addr
op_assign
(paren
(paren
r_struct
id|ipmi_system_interface_addr
op_star
)paren
op_amp
(paren
id|recv_msg-&gt;addr
)paren
)paren
suffix:semicolon
id|smi_addr-&gt;addr_type
op_assign
id|IPMI_SYSTEM_INTERFACE_ADDR_TYPE
suffix:semicolon
id|smi_addr-&gt;channel
op_assign
id|IPMI_BMC_CHANNEL
suffix:semicolon
id|smi_addr-&gt;lun
op_assign
id|msg-&gt;rsp
(braket
l_int|0
)braket
op_amp
l_int|3
suffix:semicolon
id|recv_msg-&gt;msg.netfn
op_assign
id|msg-&gt;rsp
(braket
l_int|0
)braket
op_rshift
l_int|2
suffix:semicolon
id|recv_msg-&gt;msg.cmd
op_assign
id|msg-&gt;rsp
(braket
l_int|1
)braket
suffix:semicolon
id|memcpy
c_func
(paren
id|recv_msg-&gt;msg_data
comma
op_amp
(paren
id|msg-&gt;rsp
(braket
l_int|2
)braket
)paren
comma
id|msg-&gt;rsp_size
op_minus
l_int|2
)paren
suffix:semicolon
id|recv_msg-&gt;msg.data
op_assign
id|recv_msg-&gt;msg_data
suffix:semicolon
id|recv_msg-&gt;msg.data_len
op_assign
id|msg-&gt;rsp_size
op_minus
l_int|2
suffix:semicolon
id|deliver_response
c_func
(paren
id|recv_msg
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Handle a new message.  Return 1 if the message should be requeued,&n;   0 if the message should be freed, or -1 if the message should not&n;   be freed or requeued. */
DECL|function|handle_new_recv_msg
r_static
r_int
id|handle_new_recv_msg
c_func
(paren
id|ipmi_smi_t
id|intf
comma
r_struct
id|ipmi_smi_msg
op_star
id|msg
)paren
(brace
r_int
id|requeue
suffix:semicolon
r_int
id|chan
suffix:semicolon
macro_line|#ifdef DEBUG_MSGING
r_int
id|m
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Recv:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
l_int|0
suffix:semicolon
id|m
OL
id|msg-&gt;rsp_size
suffix:semicolon
id|m
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %2.2x&quot;
comma
id|msg-&gt;rsp
(braket
id|m
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|msg-&gt;rsp_size
OL
l_int|2
)paren
(brace
multiline_comment|/* Message is too small to be correct. */
id|printk
c_func
(paren
id|KERN_WARNING
id|PFX
l_string|&quot;BMC returned to small a message&quot;
l_string|&quot; for netfn %x cmd %x, got %d bytes&bslash;n&quot;
comma
(paren
id|msg-&gt;data
(braket
l_int|0
)braket
op_rshift
l_int|2
)paren
op_or
l_int|1
comma
id|msg-&gt;data
(braket
l_int|1
)braket
comma
id|msg-&gt;rsp_size
)paren
suffix:semicolon
multiline_comment|/* Generate an error response for the message. */
id|msg-&gt;rsp
(braket
l_int|0
)braket
op_assign
id|msg-&gt;data
(braket
l_int|0
)braket
op_or
(paren
l_int|1
op_lshift
l_int|2
)paren
suffix:semicolon
id|msg-&gt;rsp
(braket
l_int|1
)braket
op_assign
id|msg-&gt;data
(braket
l_int|1
)braket
suffix:semicolon
id|msg-&gt;rsp
(braket
l_int|2
)braket
op_assign
id|IPMI_ERR_UNSPECIFIED
suffix:semicolon
id|msg-&gt;rsp_size
op_assign
l_int|3
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
(paren
id|msg-&gt;rsp
(braket
l_int|0
)braket
op_rshift
l_int|2
)paren
op_ne
(paren
(paren
id|msg-&gt;data
(braket
l_int|0
)braket
op_rshift
l_int|2
)paren
op_or
l_int|1
)paren
)paren
multiline_comment|/* Netfn */
op_logical_or
(paren
id|msg-&gt;rsp
(braket
l_int|1
)braket
op_ne
id|msg-&gt;data
(braket
l_int|1
)braket
)paren
)paren
multiline_comment|/* Command */
(brace
multiline_comment|/* The response is not even marginally correct. */
id|printk
c_func
(paren
id|KERN_WARNING
id|PFX
l_string|&quot;BMC returned incorrect response,&quot;
l_string|&quot; expected netfn %x cmd %x, got netfn %x cmd %x&bslash;n&quot;
comma
(paren
id|msg-&gt;data
(braket
l_int|0
)braket
op_rshift
l_int|2
)paren
op_or
l_int|1
comma
id|msg-&gt;data
(braket
l_int|1
)braket
comma
id|msg-&gt;rsp
(braket
l_int|0
)braket
op_rshift
l_int|2
comma
id|msg-&gt;rsp
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/* Generate an error response for the message. */
id|msg-&gt;rsp
(braket
l_int|0
)braket
op_assign
id|msg-&gt;data
(braket
l_int|0
)braket
op_or
(paren
l_int|1
op_lshift
l_int|2
)paren
suffix:semicolon
id|msg-&gt;rsp
(braket
l_int|1
)braket
op_assign
id|msg-&gt;data
(braket
l_int|1
)braket
suffix:semicolon
id|msg-&gt;rsp
(braket
l_int|2
)braket
op_assign
id|IPMI_ERR_UNSPECIFIED
suffix:semicolon
id|msg-&gt;rsp_size
op_assign
l_int|3
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|msg-&gt;rsp
(braket
l_int|0
)braket
op_eq
(paren
(paren
id|IPMI_NETFN_APP_REQUEST
op_or
l_int|1
)paren
op_lshift
l_int|2
)paren
)paren
op_logical_and
(paren
id|msg-&gt;rsp
(braket
l_int|1
)braket
op_eq
id|IPMI_SEND_MSG_CMD
)paren
op_logical_and
(paren
id|msg-&gt;user_data
op_ne
l_int|NULL
)paren
)paren
(brace
multiline_comment|/* It&squot;s a response to a response we sent.  For this we&n;&t;&t;   deliver a send message response to the user. */
r_struct
id|ipmi_recv_msg
op_star
id|recv_msg
op_assign
id|msg-&gt;user_data
suffix:semicolon
id|requeue
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|msg-&gt;rsp_size
OL
l_int|2
)paren
multiline_comment|/* Message is too small to be correct. */
r_goto
id|out
suffix:semicolon
id|chan
op_assign
id|msg-&gt;data
(braket
l_int|2
)braket
op_amp
l_int|0x0f
suffix:semicolon
r_if
c_cond
(paren
id|chan
op_ge
id|IPMI_MAX_CHANNELS
)paren
multiline_comment|/* Invalid channel number */
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|recv_msg
)paren
(brace
id|recv_msg-&gt;recv_type
op_assign
id|IPMI_RESPONSE_RESPONSE_TYPE
suffix:semicolon
id|recv_msg-&gt;msg.data
op_assign
id|recv_msg-&gt;msg_data
suffix:semicolon
id|recv_msg-&gt;msg.data_len
op_assign
l_int|1
suffix:semicolon
id|recv_msg-&gt;msg_data
(braket
l_int|0
)braket
op_assign
id|msg-&gt;rsp
(braket
l_int|2
)braket
suffix:semicolon
id|deliver_response
c_func
(paren
id|recv_msg
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|msg-&gt;rsp
(braket
l_int|0
)braket
op_eq
(paren
(paren
id|IPMI_NETFN_APP_REQUEST
op_or
l_int|1
)paren
op_lshift
l_int|2
)paren
)paren
op_logical_and
(paren
id|msg-&gt;rsp
(braket
l_int|1
)braket
op_eq
id|IPMI_GET_MSG_CMD
)paren
)paren
(brace
multiline_comment|/* It&squot;s from the receive queue. */
id|chan
op_assign
id|msg-&gt;rsp
(braket
l_int|3
)braket
op_amp
l_int|0xf
suffix:semicolon
r_if
c_cond
(paren
id|chan
op_ge
id|IPMI_MAX_CHANNELS
)paren
(brace
multiline_comment|/* Invalid channel number */
id|requeue
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|intf-&gt;channels
(braket
id|chan
)braket
dot
id|medium
)paren
(brace
r_case
id|IPMI_CHANNEL_MEDIUM_IPMB
suffix:colon
r_if
c_cond
(paren
id|msg-&gt;rsp
(braket
l_int|4
)braket
op_amp
l_int|0x04
)paren
(brace
multiline_comment|/* It&squot;s a response, so find the&n;&t;&t;&t;&t;   requesting message and send it up. */
id|requeue
op_assign
id|handle_ipmb_get_msg_rsp
c_func
(paren
id|intf
comma
id|msg
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* It&squot;s a command to the SMS from some other&n;&t;&t;&t;&t;   entity.  Handle that. */
id|requeue
op_assign
id|handle_ipmb_get_msg_cmd
c_func
(paren
id|intf
comma
id|msg
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|IPMI_CHANNEL_MEDIUM_8023LAN
suffix:colon
r_case
id|IPMI_CHANNEL_MEDIUM_ASYNC
suffix:colon
r_if
c_cond
(paren
id|msg-&gt;rsp
(braket
l_int|6
)braket
op_amp
l_int|0x04
)paren
(brace
multiline_comment|/* It&squot;s a response, so find the&n;&t;&t;&t;&t;   requesting message and send it up. */
id|requeue
op_assign
id|handle_lan_get_msg_rsp
c_func
(paren
id|intf
comma
id|msg
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* It&squot;s a command to the SMS from some other&n;&t;&t;&t;&t;   entity.  Handle that. */
id|requeue
op_assign
id|handle_lan_get_msg_cmd
c_func
(paren
id|intf
comma
id|msg
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* We don&squot;t handle the channel type, so just&n;&t;&t;&t; * free the message. */
id|requeue
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|msg-&gt;rsp
(braket
l_int|0
)braket
op_eq
(paren
(paren
id|IPMI_NETFN_APP_REQUEST
op_or
l_int|1
)paren
op_lshift
l_int|2
)paren
)paren
op_logical_and
(paren
id|msg-&gt;rsp
(braket
l_int|1
)braket
op_eq
id|IPMI_READ_EVENT_MSG_BUFFER_CMD
)paren
)paren
(brace
multiline_comment|/* It&squot;s an asyncronous event. */
id|requeue
op_assign
id|handle_read_event_rsp
c_func
(paren
id|intf
comma
id|msg
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* It&squot;s a response from the local BMC. */
id|requeue
op_assign
id|handle_bmc_rsp
c_func
(paren
id|intf
comma
id|msg
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|requeue
suffix:semicolon
)brace
multiline_comment|/* Handle a new message from the lower layer. */
DECL|function|ipmi_smi_msg_received
r_void
id|ipmi_smi_msg_received
c_func
(paren
id|ipmi_smi_t
id|intf
comma
r_struct
id|ipmi_smi_msg
op_star
id|msg
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|rv
suffix:semicolon
multiline_comment|/* Lock the user lock so the user can&squot;t go away while we are&n;&t;   working on it. */
id|read_lock
c_func
(paren
op_amp
(paren
id|intf-&gt;users_lock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|msg-&gt;data_size
op_ge
l_int|2
)paren
op_logical_and
(paren
id|msg-&gt;data
(braket
l_int|0
)braket
op_eq
(paren
id|IPMI_NETFN_APP_REQUEST
op_lshift
l_int|2
)paren
)paren
op_logical_and
(paren
id|msg-&gt;data
(braket
l_int|1
)braket
op_eq
id|IPMI_SEND_MSG_CMD
)paren
op_logical_and
(paren
id|msg-&gt;user_data
op_eq
l_int|NULL
)paren
)paren
(brace
multiline_comment|/* This is the local response to a command send, start&n;                   the timer for these.  The user_data will not be&n;                   NULL if this is a response send, and we will let&n;                   response sends just go through. */
multiline_comment|/* Check for errors, if we get certain errors (ones&n;                   that mean basically we can try again later), we&n;                   ignore them and start the timer.  Otherwise we&n;                   report the error immediately. */
r_if
c_cond
(paren
(paren
id|msg-&gt;rsp_size
op_ge
l_int|3
)paren
op_logical_and
(paren
id|msg-&gt;rsp
(braket
l_int|2
)braket
op_ne
l_int|0
)paren
op_logical_and
(paren
id|msg-&gt;rsp
(braket
l_int|2
)braket
op_ne
id|IPMI_NODE_BUSY_ERR
)paren
op_logical_and
(paren
id|msg-&gt;rsp
(braket
l_int|2
)braket
op_ne
id|IPMI_LOST_ARBITRATION_ERR
)paren
)paren
(brace
r_int
id|chan
op_assign
id|msg-&gt;rsp
(braket
l_int|3
)braket
op_amp
l_int|0xf
suffix:semicolon
multiline_comment|/* Got an error sending the message, handle it. */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chan
op_ge
id|IPMI_MAX_CHANNELS
)paren
suffix:semicolon
multiline_comment|/* This shouldn&squot;t happen */
r_else
r_if
c_cond
(paren
(paren
id|intf-&gt;channels
(braket
id|chan
)braket
dot
id|medium
op_eq
id|IPMI_CHANNEL_MEDIUM_8023LAN
)paren
op_logical_or
(paren
id|intf-&gt;channels
(braket
id|chan
)braket
dot
id|medium
op_eq
id|IPMI_CHANNEL_MEDIUM_ASYNC
)paren
)paren
id|intf-&gt;sent_lan_command_errs
op_increment
suffix:semicolon
r_else
id|intf-&gt;sent_ipmb_command_errs
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|intf-&gt;counter_lock
comma
id|flags
)paren
suffix:semicolon
id|intf_err_seq
c_func
(paren
id|intf
comma
id|msg-&gt;msgid
comma
id|msg-&gt;rsp
(braket
l_int|2
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The message was sent, start the timer. */
id|intf_start_seq_timer
c_func
(paren
id|intf
comma
id|msg-&gt;msgid
)paren
suffix:semicolon
)brace
id|ipmi_free_smi_msg
c_func
(paren
id|msg
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* To preserve message order, if the list is not empty, we&n;           tack this message onto the end of the list. */
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|intf-&gt;waiting_msgs_lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
(paren
id|intf-&gt;waiting_msgs
)paren
)paren
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
(paren
id|msg-&gt;link
)paren
comma
op_amp
(paren
id|intf-&gt;waiting_msgs
)paren
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
(paren
id|intf-&gt;waiting_msgs_lock
)paren
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|intf-&gt;waiting_msgs_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|rv
op_assign
id|handle_new_recv_msg
c_func
(paren
id|intf
comma
id|msg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
OG
l_int|0
)paren
(brace
multiline_comment|/* Could not handle the message now, just add it to a&n;                   list to handle later. */
id|spin_lock
c_func
(paren
op_amp
(paren
id|intf-&gt;waiting_msgs_lock
)paren
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
(paren
id|msg-&gt;link
)paren
comma
op_amp
(paren
id|intf-&gt;waiting_msgs
)paren
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
(paren
id|intf-&gt;waiting_msgs_lock
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rv
op_eq
l_int|0
)paren
(brace
id|ipmi_free_smi_msg
c_func
(paren
id|msg
)paren
suffix:semicolon
)brace
id|out_unlock
suffix:colon
id|read_unlock
c_func
(paren
op_amp
(paren
id|intf-&gt;users_lock
)paren
)paren
suffix:semicolon
)brace
DECL|function|ipmi_smi_watchdog_pretimeout
r_void
id|ipmi_smi_watchdog_pretimeout
c_func
(paren
id|ipmi_smi_t
id|intf
)paren
(brace
id|ipmi_user_t
id|user
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
(paren
id|intf-&gt;users_lock
)paren
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|user
comma
op_amp
(paren
id|intf-&gt;users
)paren
comma
id|link
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|user-&gt;handler-&gt;ipmi_watchdog_pretimeout
)paren
r_continue
suffix:semicolon
id|user-&gt;handler
op_member_access_from_pointer
id|ipmi_watchdog_pretimeout
c_func
(paren
id|user-&gt;handler_data
)paren
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
(paren
id|intf-&gt;users_lock
)paren
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|handle_msg_timeout
id|handle_msg_timeout
c_func
(paren
r_struct
id|ipmi_recv_msg
op_star
id|msg
)paren
(brace
id|msg-&gt;recv_type
op_assign
id|IPMI_RESPONSE_RECV_TYPE
suffix:semicolon
id|msg-&gt;msg_data
(braket
l_int|0
)braket
op_assign
id|IPMI_TIMEOUT_COMPLETION_CODE
suffix:semicolon
id|msg-&gt;msg.netfn
op_or_assign
l_int|1
suffix:semicolon
multiline_comment|/* Convert to a response. */
id|msg-&gt;msg.data_len
op_assign
l_int|1
suffix:semicolon
id|msg-&gt;msg.data
op_assign
id|msg-&gt;msg_data
suffix:semicolon
id|deliver_response
c_func
(paren
id|msg
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|send_from_recv_msg
id|send_from_recv_msg
c_func
(paren
id|ipmi_smi_t
id|intf
comma
r_struct
id|ipmi_recv_msg
op_star
id|recv_msg
comma
r_struct
id|ipmi_smi_msg
op_star
id|smi_msg
comma
r_int
r_char
id|seq
comma
r_int
id|seqid
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|smi_msg
)paren
id|smi_msg
op_assign
id|ipmi_alloc_smi_msg
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|smi_msg
)paren
multiline_comment|/* If we can&squot;t allocate the message, then just return, we&n;&t;&t;   get 4 retries, so this should be ok. */
r_return
suffix:semicolon
id|memcpy
c_func
(paren
id|smi_msg-&gt;data
comma
id|recv_msg-&gt;msg.data
comma
id|recv_msg-&gt;msg.data_len
)paren
suffix:semicolon
id|smi_msg-&gt;data_size
op_assign
id|recv_msg-&gt;msg.data_len
suffix:semicolon
id|smi_msg-&gt;msgid
op_assign
id|STORE_SEQ_IN_MSGID
c_func
(paren
id|seq
comma
id|seqid
)paren
suffix:semicolon
multiline_comment|/* Send the new message.  We send with a zero priority.  It&n;&t;   timed out, I doubt time is that critical now, and high&n;&t;   priority messages are really only for messages to the local&n;&t;   MC, which don&squot;t get resent. */
id|intf-&gt;handlers
op_member_access_from_pointer
id|sender
c_func
(paren
id|intf-&gt;send_info
comma
id|smi_msg
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_MSGING
(brace
r_int
id|m
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Resend: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
l_int|0
suffix:semicolon
id|m
OL
id|smi_msg-&gt;data_size
suffix:semicolon
id|m
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %2.2x&quot;
comma
id|smi_msg-&gt;data
(braket
id|m
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
r_static
r_void
DECL|function|ipmi_timeout_handler
id|ipmi_timeout_handler
c_func
(paren
r_int
id|timeout_period
)paren
(brace
id|ipmi_smi_t
id|intf
suffix:semicolon
r_struct
id|list_head
id|timeouts
suffix:semicolon
r_struct
id|ipmi_recv_msg
op_star
id|msg
comma
op_star
id|msg2
suffix:semicolon
r_struct
id|ipmi_smi_msg
op_star
id|smi_msg
comma
op_star
id|smi_msg2
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|timeouts
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|interfaces_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_IPMI_INTERFACES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|intf
op_assign
id|ipmi_interfaces
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|intf
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
(paren
id|intf-&gt;users_lock
)paren
)paren
suffix:semicolon
multiline_comment|/* See if any waiting messages need to be processed. */
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|intf-&gt;waiting_msgs_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|smi_msg
comma
id|smi_msg2
comma
op_amp
(paren
id|intf-&gt;waiting_msgs
)paren
comma
id|link
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|handle_new_recv_msg
c_func
(paren
id|intf
comma
id|smi_msg
)paren
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|smi_msg-&gt;link
)paren
suffix:semicolon
id|ipmi_free_smi_msg
c_func
(paren
id|smi_msg
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* To preserve message order, quit if we&n;&t;&t;&t;&t;   can&squot;t handle a message. */
r_break
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|intf-&gt;waiting_msgs_lock
)paren
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Go through the seq table and find any messages that&n;&t;&t;   have timed out, putting them in the timeouts&n;&t;&t;   list. */
id|spin_lock_irqsave
c_func
(paren
op_amp
(paren
id|intf-&gt;seq_lock
)paren
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|IPMI_IPMB_NUM_SEQ
suffix:semicolon
id|j
op_increment
)paren
(brace
r_struct
id|seq_table
op_star
id|ent
op_assign
op_amp
(paren
id|intf-&gt;seq_table
(braket
id|j
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ent-&gt;inuse
)paren
r_continue
suffix:semicolon
id|ent-&gt;timeout
op_sub_assign
id|timeout_period
suffix:semicolon
r_if
c_cond
(paren
id|ent-&gt;timeout
OG
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|ent-&gt;retries_left
op_eq
l_int|0
)paren
(brace
multiline_comment|/* The message has used all its retries. */
id|ent-&gt;inuse
op_assign
l_int|0
suffix:semicolon
id|msg
op_assign
id|ent-&gt;recv_msg
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
(paren
id|msg-&gt;link
)paren
comma
op_amp
id|timeouts
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|intf-&gt;counter_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ent-&gt;broadcast
)paren
id|intf-&gt;timed_out_ipmb_broadcasts
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ent-&gt;recv_msg-&gt;addr.addr_type
op_eq
id|IPMI_LAN_ADDR_TYPE
)paren
id|intf-&gt;timed_out_lan_commands
op_increment
suffix:semicolon
r_else
id|intf-&gt;timed_out_ipmb_commands
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|intf-&gt;counter_lock
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* More retries, send again. */
multiline_comment|/* Start with the max timer, set to normal&n;&t;&t;&t;&t;   timer after the message is sent. */
id|ent-&gt;timeout
op_assign
id|MAX_MSG_TIMEOUT
suffix:semicolon
id|ent-&gt;retries_left
op_decrement
suffix:semicolon
id|send_from_recv_msg
c_func
(paren
id|intf
comma
id|ent-&gt;recv_msg
comma
l_int|NULL
comma
id|j
comma
id|ent-&gt;seqid
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|intf-&gt;counter_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ent-&gt;recv_msg-&gt;addr.addr_type
op_eq
id|IPMI_LAN_ADDR_TYPE
)paren
id|intf-&gt;retransmitted_lan_commands
op_increment
suffix:semicolon
r_else
id|intf-&gt;retransmitted_ipmb_commands
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|intf-&gt;counter_lock
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
(paren
id|intf-&gt;seq_lock
)paren
comma
id|flags
)paren
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|msg
comma
id|msg2
comma
op_amp
id|timeouts
comma
id|link
)paren
(brace
id|handle_msg_timeout
c_func
(paren
id|msg
)paren
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
(paren
id|intf-&gt;users_lock
)paren
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|interfaces_lock
)paren
suffix:semicolon
)brace
DECL|function|ipmi_request_event
r_static
r_void
id|ipmi_request_event
c_func
(paren
r_void
)paren
(brace
id|ipmi_smi_t
id|intf
suffix:semicolon
r_int
id|i
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|interfaces_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_IPMI_INTERFACES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|intf
op_assign
id|ipmi_interfaces
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|intf
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|intf-&gt;handlers
op_member_access_from_pointer
id|request_events
c_func
(paren
id|intf-&gt;send_info
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|interfaces_lock
)paren
suffix:semicolon
)brace
DECL|variable|ipmi_timer
r_static
r_struct
id|timer_list
id|ipmi_timer
suffix:semicolon
multiline_comment|/* Call every ~100 ms. */
DECL|macro|IPMI_TIMEOUT_TIME
mdefine_line|#define IPMI_TIMEOUT_TIME&t;100
multiline_comment|/* How many jiffies does it take to get to the timeout time. */
DECL|macro|IPMI_TIMEOUT_JIFFIES
mdefine_line|#define IPMI_TIMEOUT_JIFFIES&t;((IPMI_TIMEOUT_TIME * HZ) / 1000)
multiline_comment|/* Request events from the queue every second (this is the number of&n;   IPMI_TIMEOUT_TIMES between event requests).  Hopefully, in the&n;   future, IPMI will add a way to know immediately if an event is in&n;   the queue and this silliness can go away. */
DECL|macro|IPMI_REQUEST_EV_TIME
mdefine_line|#define IPMI_REQUEST_EV_TIME&t;(1000 / (IPMI_TIMEOUT_TIME))
DECL|variable|stop_operation
r_static
r_volatile
r_int
id|stop_operation
op_assign
l_int|0
suffix:semicolon
DECL|variable|timer_stopped
r_static
r_volatile
r_int
id|timer_stopped
op_assign
l_int|0
suffix:semicolon
DECL|variable|ticks_to_req_ev
r_static
r_int
r_int
id|ticks_to_req_ev
op_assign
id|IPMI_REQUEST_EV_TIME
suffix:semicolon
DECL|function|ipmi_timeout
r_static
r_void
id|ipmi_timeout
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_if
c_cond
(paren
id|stop_operation
)paren
(brace
id|timer_stopped
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ticks_to_req_ev
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|ticks_to_req_ev
op_eq
l_int|0
)paren
(brace
id|ipmi_request_event
c_func
(paren
)paren
suffix:semicolon
id|ticks_to_req_ev
op_assign
id|IPMI_REQUEST_EV_TIME
suffix:semicolon
)brace
id|ipmi_timeout_handler
c_func
(paren
id|IPMI_TIMEOUT_TIME
)paren
suffix:semicolon
id|ipmi_timer.expires
op_add_assign
id|IPMI_TIMEOUT_JIFFIES
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|ipmi_timer
)paren
suffix:semicolon
)brace
DECL|variable|smi_msg_inuse_count
r_static
id|atomic_t
id|smi_msg_inuse_count
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|variable|recv_msg_inuse_count
r_static
id|atomic_t
id|recv_msg_inuse_count
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* FIXME - convert these to slabs. */
DECL|function|free_smi_msg
r_static
r_void
id|free_smi_msg
c_func
(paren
r_struct
id|ipmi_smi_msg
op_star
id|msg
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
id|smi_msg_inuse_count
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|msg
)paren
suffix:semicolon
)brace
DECL|function|ipmi_alloc_smi_msg
r_struct
id|ipmi_smi_msg
op_star
id|ipmi_alloc_smi_msg
c_func
(paren
r_void
)paren
(brace
r_struct
id|ipmi_smi_msg
op_star
id|rv
suffix:semicolon
id|rv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ipmi_smi_msg
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
(brace
id|rv-&gt;done
op_assign
id|free_smi_msg
suffix:semicolon
id|rv-&gt;user_data
op_assign
l_int|NULL
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|smi_msg_inuse_count
)paren
suffix:semicolon
)brace
r_return
id|rv
suffix:semicolon
)brace
DECL|function|free_recv_msg
r_static
r_void
id|free_recv_msg
c_func
(paren
r_struct
id|ipmi_recv_msg
op_star
id|msg
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
id|recv_msg_inuse_count
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|msg
)paren
suffix:semicolon
)brace
DECL|function|ipmi_alloc_recv_msg
r_struct
id|ipmi_recv_msg
op_star
id|ipmi_alloc_recv_msg
c_func
(paren
r_void
)paren
(brace
r_struct
id|ipmi_recv_msg
op_star
id|rv
suffix:semicolon
id|rv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ipmi_recv_msg
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
)paren
(brace
id|rv-&gt;done
op_assign
id|free_recv_msg
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|recv_msg_inuse_count
)paren
suffix:semicolon
)brace
r_return
id|rv
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_IPMI_PANIC_EVENT
DECL|function|dummy_smi_done_handler
r_static
r_void
id|dummy_smi_done_handler
c_func
(paren
r_struct
id|ipmi_smi_msg
op_star
id|msg
)paren
(brace
)brace
DECL|function|dummy_recv_done_handler
r_static
r_void
id|dummy_recv_done_handler
c_func
(paren
r_struct
id|ipmi_recv_msg
op_star
id|msg
)paren
(brace
)brace
macro_line|#ifdef CONFIG_IPMI_PANIC_STRING
DECL|function|event_receiver_fetcher
r_static
r_void
id|event_receiver_fetcher
c_func
(paren
id|ipmi_smi_t
id|intf
comma
r_struct
id|ipmi_smi_msg
op_star
id|msg
)paren
(brace
r_if
c_cond
(paren
(paren
id|msg-&gt;rsp
(braket
l_int|0
)braket
op_eq
(paren
id|IPMI_NETFN_SENSOR_EVENT_RESPONSE
op_lshift
l_int|2
)paren
)paren
op_logical_and
(paren
id|msg-&gt;rsp
(braket
l_int|1
)braket
op_eq
id|IPMI_GET_EVENT_RECEIVER_CMD
)paren
op_logical_and
(paren
id|msg-&gt;rsp
(braket
l_int|2
)braket
op_eq
id|IPMI_CC_NO_ERROR
)paren
)paren
(brace
multiline_comment|/* A get event receiver command, save it. */
id|intf-&gt;event_receiver
op_assign
id|msg-&gt;rsp
(braket
l_int|3
)braket
suffix:semicolon
id|intf-&gt;event_receiver_lun
op_assign
id|msg-&gt;rsp
(braket
l_int|4
)braket
op_amp
l_int|0x3
suffix:semicolon
)brace
)brace
DECL|function|device_id_fetcher
r_static
r_void
id|device_id_fetcher
c_func
(paren
id|ipmi_smi_t
id|intf
comma
r_struct
id|ipmi_smi_msg
op_star
id|msg
)paren
(brace
r_if
c_cond
(paren
(paren
id|msg-&gt;rsp
(braket
l_int|0
)braket
op_eq
(paren
id|IPMI_NETFN_APP_RESPONSE
op_lshift
l_int|2
)paren
)paren
op_logical_and
(paren
id|msg-&gt;rsp
(braket
l_int|1
)braket
op_eq
id|IPMI_GET_DEVICE_ID_CMD
)paren
op_logical_and
(paren
id|msg-&gt;rsp
(braket
l_int|2
)braket
op_eq
id|IPMI_CC_NO_ERROR
)paren
)paren
(brace
multiline_comment|/* A get device id command, save if we are an event&n;&t;&t;   receiver or generator. */
id|intf-&gt;local_sel_device
op_assign
(paren
id|msg-&gt;rsp
(braket
l_int|8
)braket
op_rshift
l_int|2
)paren
op_amp
l_int|1
suffix:semicolon
id|intf-&gt;local_event_generator
op_assign
(paren
id|msg-&gt;rsp
(braket
l_int|8
)braket
op_rshift
l_int|5
)paren
op_amp
l_int|1
suffix:semicolon
)brace
)brace
macro_line|#endif
DECL|function|send_panic_events
r_static
r_void
id|send_panic_events
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_struct
id|kernel_ipmi_msg
id|msg
suffix:semicolon
id|ipmi_smi_t
id|intf
suffix:semicolon
r_int
r_char
id|data
(braket
l_int|16
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|ipmi_system_interface_addr
op_star
id|si
suffix:semicolon
r_struct
id|ipmi_addr
id|addr
suffix:semicolon
r_struct
id|ipmi_smi_msg
id|smi_msg
suffix:semicolon
r_struct
id|ipmi_recv_msg
id|recv_msg
suffix:semicolon
id|si
op_assign
(paren
r_struct
id|ipmi_system_interface_addr
op_star
)paren
op_amp
id|addr
suffix:semicolon
id|si-&gt;addr_type
op_assign
id|IPMI_SYSTEM_INTERFACE_ADDR_TYPE
suffix:semicolon
id|si-&gt;channel
op_assign
id|IPMI_BMC_CHANNEL
suffix:semicolon
id|si-&gt;lun
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Fill in an event telling that we have failed. */
id|msg.netfn
op_assign
l_int|0x04
suffix:semicolon
multiline_comment|/* Sensor or Event. */
id|msg.cmd
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* Platform event command. */
id|msg.data
op_assign
id|data
suffix:semicolon
id|msg.data_len
op_assign
l_int|8
suffix:semicolon
id|data
(braket
l_int|0
)braket
op_assign
l_int|0x21
suffix:semicolon
multiline_comment|/* Kernel generator ID, IPMI table 5-4 */
id|data
(braket
l_int|1
)braket
op_assign
l_int|0x03
suffix:semicolon
multiline_comment|/* This is for IPMI 1.0. */
id|data
(braket
l_int|2
)braket
op_assign
l_int|0x20
suffix:semicolon
multiline_comment|/* OS Critical Stop, IPMI table 36-3 */
id|data
(braket
l_int|4
)braket
op_assign
l_int|0x6f
suffix:semicolon
multiline_comment|/* Sensor specific, IPMI table 36-1 */
id|data
(braket
l_int|5
)braket
op_assign
l_int|0xa1
suffix:semicolon
multiline_comment|/* Runtime stop OEM bytes 2 &amp; 3. */
multiline_comment|/* Put a few breadcrumbs in.  Hopefully later we can add more things&n;&t;   to make the panic events more useful. */
r_if
c_cond
(paren
id|str
)paren
(brace
id|data
(braket
l_int|3
)braket
op_assign
id|str
(braket
l_int|0
)braket
suffix:semicolon
id|data
(braket
l_int|6
)braket
op_assign
id|str
(braket
l_int|1
)braket
suffix:semicolon
id|data
(braket
l_int|7
)braket
op_assign
id|str
(braket
l_int|2
)braket
suffix:semicolon
)brace
id|smi_msg.done
op_assign
id|dummy_smi_done_handler
suffix:semicolon
id|recv_msg.done
op_assign
id|dummy_recv_done_handler
suffix:semicolon
multiline_comment|/* For every registered interface, send the event. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_IPMI_INTERFACES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|intf
op_assign
id|ipmi_interfaces
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|intf
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
multiline_comment|/* Send the event announcing the panic. */
id|intf-&gt;handlers
op_member_access_from_pointer
id|set_run_to_completion
c_func
(paren
id|intf-&gt;send_info
comma
l_int|1
)paren
suffix:semicolon
id|i_ipmi_request
c_func
(paren
l_int|NULL
comma
id|intf
comma
op_amp
id|addr
comma
l_int|0
comma
op_amp
id|msg
comma
l_int|NULL
comma
op_amp
id|smi_msg
comma
op_amp
id|recv_msg
comma
l_int|0
comma
id|intf-&gt;my_address
comma
id|intf-&gt;my_lun
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t retry, and don&squot;t wait. */
)brace
macro_line|#ifdef CONFIG_IPMI_PANIC_STRING
multiline_comment|/* On every interface, dump a bunch of OEM event holding the&n;&t;   string. */
r_if
c_cond
(paren
op_logical_neg
id|str
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_IPMI_INTERFACES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_char
op_star
id|p
op_assign
id|str
suffix:semicolon
r_struct
id|ipmi_ipmb_addr
op_star
id|ipmb
suffix:semicolon
r_int
id|j
suffix:semicolon
id|intf
op_assign
id|ipmi_interfaces
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|intf
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
multiline_comment|/* First job here is to figure out where to send the&n;&t;&t;   OEM events.  There&squot;s no way in IPMI to send OEM&n;&t;&t;   events using an event send command, so we have to&n;&t;&t;   find the SEL to put them in and stick them in&n;&t;&t;   there. */
multiline_comment|/* Get capabilities from the get device id. */
id|intf-&gt;local_sel_device
op_assign
l_int|0
suffix:semicolon
id|intf-&gt;local_event_generator
op_assign
l_int|0
suffix:semicolon
id|intf-&gt;event_receiver
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Request the device info from the local MC. */
id|msg.netfn
op_assign
id|IPMI_NETFN_APP_REQUEST
suffix:semicolon
id|msg.cmd
op_assign
id|IPMI_GET_DEVICE_ID_CMD
suffix:semicolon
id|msg.data
op_assign
l_int|NULL
suffix:semicolon
id|msg.data_len
op_assign
l_int|0
suffix:semicolon
id|intf-&gt;null_user_handler
op_assign
id|device_id_fetcher
suffix:semicolon
id|i_ipmi_request
c_func
(paren
l_int|NULL
comma
id|intf
comma
op_amp
id|addr
comma
l_int|0
comma
op_amp
id|msg
comma
l_int|NULL
comma
op_amp
id|smi_msg
comma
op_amp
id|recv_msg
comma
l_int|0
comma
id|intf-&gt;my_address
comma
id|intf-&gt;my_lun
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t retry, and don&squot;t wait. */
r_if
c_cond
(paren
id|intf-&gt;local_event_generator
)paren
(brace
multiline_comment|/* Request the event receiver from the local MC. */
id|msg.netfn
op_assign
id|IPMI_NETFN_SENSOR_EVENT_REQUEST
suffix:semicolon
id|msg.cmd
op_assign
id|IPMI_GET_EVENT_RECEIVER_CMD
suffix:semicolon
id|msg.data
op_assign
l_int|NULL
suffix:semicolon
id|msg.data_len
op_assign
l_int|0
suffix:semicolon
id|intf-&gt;null_user_handler
op_assign
id|event_receiver_fetcher
suffix:semicolon
id|i_ipmi_request
c_func
(paren
l_int|NULL
comma
id|intf
comma
op_amp
id|addr
comma
l_int|0
comma
op_amp
id|msg
comma
l_int|NULL
comma
op_amp
id|smi_msg
comma
op_amp
id|recv_msg
comma
l_int|0
comma
id|intf-&gt;my_address
comma
id|intf-&gt;my_lun
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* no retry, and no wait. */
)brace
id|intf-&gt;null_user_handler
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Validate the event receiver.  The low bit must not&n;&t;&t;   be 1 (it must be a valid IPMB address), it cannot&n;&t;&t;   be zero, and it must not be my address. */
r_if
c_cond
(paren
(paren
(paren
id|intf-&gt;event_receiver
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|intf-&gt;event_receiver
op_ne
l_int|0
)paren
op_logical_and
(paren
id|intf-&gt;event_receiver
op_ne
id|intf-&gt;my_address
)paren
)paren
(brace
multiline_comment|/* The event receiver is valid, send an IPMB&n;&t;&t;&t;   message. */
id|ipmb
op_assign
(paren
r_struct
id|ipmi_ipmb_addr
op_star
)paren
op_amp
id|addr
suffix:semicolon
id|ipmb-&gt;addr_type
op_assign
id|IPMI_IPMB_ADDR_TYPE
suffix:semicolon
id|ipmb-&gt;channel
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* FIXME - is this right? */
id|ipmb-&gt;lun
op_assign
id|intf-&gt;event_receiver_lun
suffix:semicolon
id|ipmb-&gt;slave_addr
op_assign
id|intf-&gt;event_receiver
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|intf-&gt;local_sel_device
)paren
(brace
multiline_comment|/* The event receiver was not valid (or was&n;&t;&t;&t;   me), but I am an SEL device, just dump it&n;&t;&t;&t;   in my SEL. */
id|si
op_assign
(paren
r_struct
id|ipmi_system_interface_addr
op_star
)paren
op_amp
id|addr
suffix:semicolon
id|si-&gt;addr_type
op_assign
id|IPMI_SYSTEM_INTERFACE_ADDR_TYPE
suffix:semicolon
id|si-&gt;channel
op_assign
id|IPMI_BMC_CHANNEL
suffix:semicolon
id|si-&gt;lun
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_continue
suffix:semicolon
multiline_comment|/* No where to send the event. */
id|msg.netfn
op_assign
id|IPMI_NETFN_STORAGE_REQUEST
suffix:semicolon
multiline_comment|/* Storage. */
id|msg.cmd
op_assign
id|IPMI_ADD_SEL_ENTRY_CMD
suffix:semicolon
id|msg.data
op_assign
id|data
suffix:semicolon
id|msg.data_len
op_assign
l_int|16
suffix:semicolon
id|j
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
)paren
(brace
r_int
id|size
op_assign
id|strlen
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
l_int|11
)paren
id|size
op_assign
l_int|11
suffix:semicolon
id|data
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|data
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|data
(braket
l_int|2
)braket
op_assign
l_int|0xf0
suffix:semicolon
multiline_comment|/* OEM event without timestamp. */
id|data
(braket
l_int|3
)braket
op_assign
id|intf-&gt;my_address
suffix:semicolon
id|data
(braket
l_int|4
)braket
op_assign
id|j
op_increment
suffix:semicolon
multiline_comment|/* sequence # */
multiline_comment|/* Always give 11 bytes, so strncpy will fill&n;&t;&t;&t;   it with zeroes for me. */
id|strncpy
c_func
(paren
id|data
op_plus
l_int|5
comma
id|p
comma
l_int|11
)paren
suffix:semicolon
id|p
op_add_assign
id|size
suffix:semicolon
id|i_ipmi_request
c_func
(paren
l_int|NULL
comma
id|intf
comma
op_amp
id|addr
comma
l_int|0
comma
op_amp
id|msg
comma
l_int|NULL
comma
op_amp
id|smi_msg
comma
op_amp
id|recv_msg
comma
l_int|0
comma
id|intf-&gt;my_address
comma
id|intf-&gt;my_lun
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* no retry, and no wait. */
)brace
)brace
macro_line|#endif /* CONFIG_IPMI_PANIC_STRING */
)brace
macro_line|#endif /* CONFIG_IPMI_PANIC_EVENT */
DECL|variable|has_paniced
r_static
r_int
id|has_paniced
op_assign
l_int|0
suffix:semicolon
DECL|function|panic_event
r_static
r_int
id|panic_event
c_func
(paren
r_struct
id|notifier_block
op_star
id|this
comma
r_int
r_int
id|event
comma
r_void
op_star
id|ptr
)paren
(brace
r_int
id|i
suffix:semicolon
id|ipmi_smi_t
id|intf
suffix:semicolon
r_if
c_cond
(paren
id|has_paniced
)paren
r_return
id|NOTIFY_DONE
suffix:semicolon
id|has_paniced
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* For every registered interface, set it to run to completion. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_IPMI_INTERFACES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|intf
op_assign
id|ipmi_interfaces
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|intf
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|intf-&gt;handlers
op_member_access_from_pointer
id|set_run_to_completion
c_func
(paren
id|intf-&gt;send_info
comma
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_IPMI_PANIC_EVENT
id|send_panic_events
c_func
(paren
id|ptr
)paren
suffix:semicolon
macro_line|#endif
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
DECL|variable|panic_block
r_static
r_struct
id|notifier_block
id|panic_block
op_assign
(brace
id|panic_event
comma
l_int|NULL
comma
l_int|200
multiline_comment|/* priority: INT_MAX &gt;= x &gt;= 0 */
)brace
suffix:semicolon
DECL|function|ipmi_init_msghandler
r_static
r_int
id|ipmi_init_msghandler
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|initialized
)paren
r_return
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ipmi message handler version &quot;
id|IPMI_MSGHANDLER_VERSION
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_IPMI_INTERFACES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ipmi_interfaces
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
id|proc_ipmi_root
op_assign
id|proc_mkdir
c_func
(paren
l_string|&quot;ipmi&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|proc_ipmi_root
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|PFX
l_string|&quot;Unable to create IPMI proc dir&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|proc_ipmi_root-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|ipmi_timer
)paren
suffix:semicolon
id|ipmi_timer.data
op_assign
l_int|0
suffix:semicolon
id|ipmi_timer.function
op_assign
id|ipmi_timeout
suffix:semicolon
id|ipmi_timer.expires
op_assign
id|jiffies
op_plus
id|IPMI_TIMEOUT_JIFFIES
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|ipmi_timer
)paren
suffix:semicolon
id|notifier_chain_register
c_func
(paren
op_amp
id|panic_notifier_list
comma
op_amp
id|panic_block
)paren
suffix:semicolon
id|initialized
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ipmi_init_msghandler_mod
r_static
id|__init
r_int
id|ipmi_init_msghandler_mod
c_func
(paren
r_void
)paren
(brace
id|ipmi_init_msghandler
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_ipmi
r_static
id|__exit
r_void
id|cleanup_ipmi
c_func
(paren
r_void
)paren
(brace
r_int
id|count
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|initialized
)paren
r_return
suffix:semicolon
id|notifier_chain_unregister
c_func
(paren
op_amp
id|panic_notifier_list
comma
op_amp
id|panic_block
)paren
suffix:semicolon
multiline_comment|/* This can&squot;t be called if any interfaces exist, so no worry about&n;&t;   shutting down the interfaces. */
multiline_comment|/* Tell the timer to stop, then wait for it to stop.  This avoids&n;&t;   problems with race conditions removing the timer here. */
id|stop_operation
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|timer_stopped
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|remove_proc_entry
c_func
(paren
id|proc_ipmi_root-&gt;name
comma
op_amp
id|proc_root
)paren
suffix:semicolon
id|initialized
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Check for buffer leaks. */
id|count
op_assign
id|atomic_read
c_func
(paren
op_amp
id|smi_msg_inuse_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_WARNING
id|PFX
l_string|&quot;SMI message count %d at exit&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
id|count
op_assign
id|atomic_read
c_func
(paren
op_amp
id|recv_msg_inuse_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_WARNING
id|PFX
l_string|&quot;recv message count %d at exit&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
)brace
DECL|variable|cleanup_ipmi
id|module_exit
c_func
(paren
id|cleanup_ipmi
)paren
suffix:semicolon
DECL|variable|ipmi_init_msghandler_mod
id|module_init
c_func
(paren
id|ipmi_init_msghandler_mod
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|variable|ipmi_alloc_recv_msg
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_alloc_recv_msg
)paren
suffix:semicolon
DECL|variable|ipmi_create_user
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_create_user
)paren
suffix:semicolon
DECL|variable|ipmi_destroy_user
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_destroy_user
)paren
suffix:semicolon
DECL|variable|ipmi_get_version
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_get_version
)paren
suffix:semicolon
DECL|variable|ipmi_request
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_request
)paren
suffix:semicolon
DECL|variable|ipmi_request_settime
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_request_settime
)paren
suffix:semicolon
DECL|variable|ipmi_request_supply_msgs
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_request_supply_msgs
)paren
suffix:semicolon
DECL|variable|ipmi_request_with_source
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_request_with_source
)paren
suffix:semicolon
DECL|variable|ipmi_poll_interface
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_poll_interface
)paren
suffix:semicolon
DECL|variable|ipmi_register_smi
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_register_smi
)paren
suffix:semicolon
DECL|variable|ipmi_unregister_smi
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_unregister_smi
)paren
suffix:semicolon
DECL|variable|ipmi_register_for_cmd
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_register_for_cmd
)paren
suffix:semicolon
DECL|variable|ipmi_unregister_for_cmd
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_unregister_for_cmd
)paren
suffix:semicolon
DECL|variable|ipmi_smi_msg_received
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_smi_msg_received
)paren
suffix:semicolon
DECL|variable|ipmi_smi_watchdog_pretimeout
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_smi_watchdog_pretimeout
)paren
suffix:semicolon
DECL|variable|ipmi_alloc_smi_msg
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_alloc_smi_msg
)paren
suffix:semicolon
DECL|variable|ipmi_register_all_cmd_rcvr
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_register_all_cmd_rcvr
)paren
suffix:semicolon
DECL|variable|ipmi_unregister_all_cmd_rcvr
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_unregister_all_cmd_rcvr
)paren
suffix:semicolon
DECL|variable|ipmi_addr_length
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_addr_length
)paren
suffix:semicolon
DECL|variable|ipmi_validate_addr
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_validate_addr
)paren
suffix:semicolon
DECL|variable|ipmi_set_gets_events
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_set_gets_events
)paren
suffix:semicolon
DECL|variable|ipmi_addr_equal
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_addr_equal
)paren
suffix:semicolon
DECL|variable|ipmi_smi_watcher_register
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_smi_watcher_register
)paren
suffix:semicolon
DECL|variable|ipmi_smi_watcher_unregister
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_smi_watcher_unregister
)paren
suffix:semicolon
DECL|variable|ipmi_set_my_address
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_set_my_address
)paren
suffix:semicolon
DECL|variable|ipmi_get_my_address
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_get_my_address
)paren
suffix:semicolon
DECL|variable|ipmi_set_my_LUN
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_set_my_LUN
)paren
suffix:semicolon
DECL|variable|ipmi_get_my_LUN
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_get_my_LUN
)paren
suffix:semicolon
DECL|variable|ipmi_smi_add_proc_entry
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_smi_add_proc_entry
)paren
suffix:semicolon
DECL|variable|ipmi_user_set_run_to_completion
id|EXPORT_SYMBOL
c_func
(paren
id|ipmi_user_set_run_to_completion
)paren
suffix:semicolon
eof
