multiline_comment|/*&n; *  ipmi_bt_sm.c&n; *&n; *  The state machine for an Open IPMI BT sub-driver under ipmi_si.c, part&n; *  of the driver architecture at http://sourceforge.net/project/openipmi&n; *&n; *  Author:&t;Rocky Craig &lt;first.last@hp.com&gt;&n; *&n; *  This program is free software; you can redistribute it and/or modify it&n; *  under the terms of the GNU General Public License as published by the&n; *  Free Software Foundation; either version 2 of the License, or (at your&n; *  option) any later version.&n; *&n; *  THIS SOFTWARE IS PROVIDED ``AS IS&squot;&squot; AND ANY EXPRESS OR IMPLIED&n; *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&n; *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.&n; *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,&n; *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,&n; *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS&n; *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND&n; *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR&n; *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE&n; *  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n; *&n; *  You should have received a copy of the GNU General Public License along&n; *  with this program; if not, write to the Free Software Foundation, Inc.,&n; *  675 Mass Ave, Cambridge, MA 02139, USA.  */
macro_line|#include &lt;linux/kernel.h&gt; /* For printk. */
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ipmi_msgdefs.h&gt;&t;&t;/* for completion codes */
macro_line|#include &quot;ipmi_si_sm.h&quot;
DECL|macro|IPMI_BT_VERSION
mdefine_line|#define IPMI_BT_VERSION &quot;v31&quot;
DECL|variable|bt_debug
r_static
r_int
id|bt_debug
op_assign
l_int|0x00
suffix:semicolon
multiline_comment|/* Production value 0, see following flags */
DECL|macro|BT_DEBUG_ENABLE
mdefine_line|#define&t;BT_DEBUG_ENABLE&t;1
DECL|macro|BT_DEBUG_MSG
mdefine_line|#define BT_DEBUG_MSG&t;2
DECL|macro|BT_DEBUG_STATES
mdefine_line|#define BT_DEBUG_STATES&t;4
multiline_comment|/* Typical &quot;Get BT Capabilities&quot; values are 2-3 retries, 5-10 seconds,&n;   and 64 byte buffers.  However, one HP implementation wants 255 bytes of&n;   buffer (with a documented message of 160 bytes) so go for the max.&n;   Since the Open IPMI architecture is single-message oriented at this&n;   stage, the queue depth of BT is of no concern. */
DECL|macro|BT_NORMAL_TIMEOUT
mdefine_line|#define BT_NORMAL_TIMEOUT&t;2000000&t;/* seconds in microseconds */
DECL|macro|BT_RETRY_LIMIT
mdefine_line|#define BT_RETRY_LIMIT&t;&t;2
DECL|macro|BT_RESET_DELAY
mdefine_line|#define BT_RESET_DELAY&t;&t;6000000&t;/* 6 seconds after warm reset */
DECL|enum|bt_states
r_enum
id|bt_states
(brace
DECL|enumerator|BT_STATE_IDLE
id|BT_STATE_IDLE
comma
DECL|enumerator|BT_STATE_XACTION_START
id|BT_STATE_XACTION_START
comma
DECL|enumerator|BT_STATE_WRITE_BYTES
id|BT_STATE_WRITE_BYTES
comma
DECL|enumerator|BT_STATE_WRITE_END
id|BT_STATE_WRITE_END
comma
DECL|enumerator|BT_STATE_WRITE_CONSUME
id|BT_STATE_WRITE_CONSUME
comma
DECL|enumerator|BT_STATE_B2H_WAIT
id|BT_STATE_B2H_WAIT
comma
DECL|enumerator|BT_STATE_READ_END
id|BT_STATE_READ_END
comma
DECL|enumerator|BT_STATE_RESET1
id|BT_STATE_RESET1
comma
multiline_comment|/* These must come last */
DECL|enumerator|BT_STATE_RESET2
id|BT_STATE_RESET2
comma
DECL|enumerator|BT_STATE_RESET3
id|BT_STATE_RESET3
comma
DECL|enumerator|BT_STATE_RESTART
id|BT_STATE_RESTART
comma
DECL|enumerator|BT_STATE_HOSED
id|BT_STATE_HOSED
)brace
suffix:semicolon
DECL|struct|si_sm_data
r_struct
id|si_sm_data
(brace
DECL|member|state
r_enum
id|bt_states
id|state
suffix:semicolon
DECL|member|last_state
r_enum
id|bt_states
id|last_state
suffix:semicolon
multiline_comment|/* assist printing and resets */
DECL|member|seq
r_int
r_char
id|seq
suffix:semicolon
multiline_comment|/* BT sequence number */
DECL|member|io
r_struct
id|si_sm_io
op_star
id|io
suffix:semicolon
DECL|member|write_data
r_int
r_char
id|write_data
(braket
id|IPMI_MAX_MSG_LENGTH
)braket
suffix:semicolon
DECL|member|write_count
r_int
id|write_count
suffix:semicolon
DECL|member|read_data
r_int
r_char
id|read_data
(braket
id|IPMI_MAX_MSG_LENGTH
)braket
suffix:semicolon
DECL|member|read_count
r_int
id|read_count
suffix:semicolon
DECL|member|truncated
r_int
id|truncated
suffix:semicolon
DECL|member|timeout
r_int
id|timeout
suffix:semicolon
DECL|member|error_retries
r_int
r_int
id|error_retries
suffix:semicolon
multiline_comment|/* end of &quot;common&quot; fields */
DECL|member|nonzero_status
r_int
id|nonzero_status
suffix:semicolon
multiline_comment|/* hung BMCs stay all 0 */
)brace
suffix:semicolon
DECL|macro|BT_CLR_WR_PTR
mdefine_line|#define BT_CLR_WR_PTR&t;0x01&t;/* See IPMI 1.5 table 11.6.4 */
DECL|macro|BT_CLR_RD_PTR
mdefine_line|#define BT_CLR_RD_PTR&t;0x02
DECL|macro|BT_H2B_ATN
mdefine_line|#define BT_H2B_ATN&t;0x04
DECL|macro|BT_B2H_ATN
mdefine_line|#define BT_B2H_ATN&t;0x08
DECL|macro|BT_SMS_ATN
mdefine_line|#define BT_SMS_ATN&t;0x10
DECL|macro|BT_OEM0
mdefine_line|#define BT_OEM0&t;&t;0x20
DECL|macro|BT_H_BUSY
mdefine_line|#define BT_H_BUSY&t;0x40
DECL|macro|BT_B_BUSY
mdefine_line|#define BT_B_BUSY&t;0x80
multiline_comment|/* Some bits are toggled on each write: write once to set it, once&n;   more to clear it; writing a zero does nothing.  To absolutely&n;   clear it, check its state and write if set.  This avoids the &quot;get&n;   current then use as mask&quot; scheme to modify one bit.  Note that the&n;   variable &quot;bt&quot; is hardcoded into these macros. */
DECL|macro|BT_STATUS
mdefine_line|#define BT_STATUS&t;bt-&gt;io-&gt;inputb(bt-&gt;io, 0)
DECL|macro|BT_CONTROL
mdefine_line|#define BT_CONTROL(x)&t;bt-&gt;io-&gt;outputb(bt-&gt;io, 0, x)
DECL|macro|BMC2HOST
mdefine_line|#define BMC2HOST&t;bt-&gt;io-&gt;inputb(bt-&gt;io, 1)
DECL|macro|HOST2BMC
mdefine_line|#define HOST2BMC(x)&t;bt-&gt;io-&gt;outputb(bt-&gt;io, 1, x)
DECL|macro|BT_INTMASK_R
mdefine_line|#define BT_INTMASK_R&t;bt-&gt;io-&gt;inputb(bt-&gt;io, 2)
DECL|macro|BT_INTMASK_W
mdefine_line|#define BT_INTMASK_W(x)&t;bt-&gt;io-&gt;outputb(bt-&gt;io, 2, x)
multiline_comment|/* Convenience routines for debugging.  These are not multi-open safe!&n;   Note the macros have hardcoded variables in them. */
DECL|function|state2txt
r_static
r_char
op_star
id|state2txt
c_func
(paren
r_int
r_char
id|state
)paren
(brace
r_switch
c_cond
(paren
id|state
)paren
(brace
r_case
id|BT_STATE_IDLE
suffix:colon
r_return
l_string|&quot;IDLE&quot;
suffix:semicolon
r_case
id|BT_STATE_XACTION_START
suffix:colon
r_return
l_string|&quot;XACTION&quot;
suffix:semicolon
r_case
id|BT_STATE_WRITE_BYTES
suffix:colon
r_return
l_string|&quot;WR_BYTES&quot;
suffix:semicolon
r_case
id|BT_STATE_WRITE_END
suffix:colon
r_return
l_string|&quot;WR_END&quot;
suffix:semicolon
r_case
id|BT_STATE_WRITE_CONSUME
suffix:colon
r_return
l_string|&quot;WR_CONSUME&quot;
suffix:semicolon
r_case
id|BT_STATE_B2H_WAIT
suffix:colon
r_return
l_string|&quot;B2H_WAIT&quot;
suffix:semicolon
r_case
id|BT_STATE_READ_END
suffix:colon
r_return
l_string|&quot;RD_END&quot;
suffix:semicolon
r_case
id|BT_STATE_RESET1
suffix:colon
r_return
l_string|&quot;RESET1&quot;
suffix:semicolon
r_case
id|BT_STATE_RESET2
suffix:colon
r_return
l_string|&quot;RESET2&quot;
suffix:semicolon
r_case
id|BT_STATE_RESET3
suffix:colon
r_return
l_string|&quot;RESET3&quot;
suffix:semicolon
r_case
id|BT_STATE_RESTART
suffix:colon
r_return
l_string|&quot;RESTART&quot;
suffix:semicolon
r_case
id|BT_STATE_HOSED
suffix:colon
r_return
l_string|&quot;HOSED&quot;
suffix:semicolon
)brace
r_return
l_string|&quot;BAD STATE&quot;
suffix:semicolon
)brace
DECL|macro|STATE2TXT
mdefine_line|#define STATE2TXT state2txt(bt-&gt;state)
DECL|function|status2txt
r_static
r_char
op_star
id|status2txt
c_func
(paren
r_int
r_char
id|status
comma
r_char
op_star
id|buf
)paren
(brace
id|strcpy
c_func
(paren
id|buf
comma
l_string|&quot;[ &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|BT_B_BUSY
)paren
id|strcat
c_func
(paren
id|buf
comma
l_string|&quot;B_BUSY &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|BT_H_BUSY
)paren
id|strcat
c_func
(paren
id|buf
comma
l_string|&quot;H_BUSY &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|BT_OEM0
)paren
id|strcat
c_func
(paren
id|buf
comma
l_string|&quot;OEM0 &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|BT_SMS_ATN
)paren
id|strcat
c_func
(paren
id|buf
comma
l_string|&quot;SMS &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|BT_B2H_ATN
)paren
id|strcat
c_func
(paren
id|buf
comma
l_string|&quot;B2H &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|BT_H2B_ATN
)paren
id|strcat
c_func
(paren
id|buf
comma
l_string|&quot;H2B &quot;
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|buf
comma
l_string|&quot;]&quot;
)paren
suffix:semicolon
r_return
id|buf
suffix:semicolon
)brace
DECL|macro|STATUS2TXT
mdefine_line|#define STATUS2TXT(buf) status2txt(status, buf)
multiline_comment|/* This will be called from within this module on a hosed condition */
DECL|macro|FIRST_SEQ
mdefine_line|#define FIRST_SEQ&t;0
DECL|function|bt_init_data
r_static
r_int
r_int
id|bt_init_data
c_func
(paren
r_struct
id|si_sm_data
op_star
id|bt
comma
r_struct
id|si_sm_io
op_star
id|io
)paren
(brace
id|bt-&gt;state
op_assign
id|BT_STATE_IDLE
suffix:semicolon
id|bt-&gt;last_state
op_assign
id|BT_STATE_IDLE
suffix:semicolon
id|bt-&gt;seq
op_assign
id|FIRST_SEQ
suffix:semicolon
id|bt-&gt;io
op_assign
id|io
suffix:semicolon
id|bt-&gt;write_count
op_assign
l_int|0
suffix:semicolon
id|bt-&gt;read_count
op_assign
l_int|0
suffix:semicolon
id|bt-&gt;error_retries
op_assign
l_int|0
suffix:semicolon
id|bt-&gt;nonzero_status
op_assign
l_int|0
suffix:semicolon
id|bt-&gt;truncated
op_assign
l_int|0
suffix:semicolon
id|bt-&gt;timeout
op_assign
id|BT_NORMAL_TIMEOUT
suffix:semicolon
r_return
l_int|3
suffix:semicolon
multiline_comment|/* We claim 3 bytes of space; ought to check SPMI table */
)brace
DECL|function|bt_start_transaction
r_static
r_int
id|bt_start_transaction
c_func
(paren
r_struct
id|si_sm_data
op_star
id|bt
comma
r_int
r_char
op_star
id|data
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|size
OL
l_int|2
)paren
op_logical_or
(paren
id|size
OG
id|IPMI_MAX_MSG_LENGTH
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bt-&gt;state
op_ne
id|BT_STATE_IDLE
)paren
op_logical_and
(paren
id|bt-&gt;state
op_ne
id|BT_STATE_HOSED
)paren
)paren
r_return
op_minus
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|bt_debug
op_amp
id|BT_DEBUG_MSG
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;+++++++++++++++++++++++++++++++++++++&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;BT: write seq=0x%02X:&quot;
comma
id|bt-&gt;seq
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
id|i
op_increment
)paren
id|printk
(paren
l_string|&quot; %02x&quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|bt-&gt;write_data
(braket
l_int|0
)braket
op_assign
id|size
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* all data plus seq byte */
id|bt-&gt;write_data
(braket
l_int|1
)braket
op_assign
op_star
id|data
suffix:semicolon
multiline_comment|/* NetFn/LUN */
id|bt-&gt;write_data
(braket
l_int|2
)braket
op_assign
id|bt-&gt;seq
suffix:semicolon
id|memcpy
c_func
(paren
id|bt-&gt;write_data
op_plus
l_int|3
comma
id|data
op_plus
l_int|1
comma
id|size
op_minus
l_int|1
)paren
suffix:semicolon
id|bt-&gt;write_count
op_assign
id|size
op_plus
l_int|2
suffix:semicolon
id|bt-&gt;error_retries
op_assign
l_int|0
suffix:semicolon
id|bt-&gt;nonzero_status
op_assign
l_int|0
suffix:semicolon
id|bt-&gt;read_count
op_assign
l_int|0
suffix:semicolon
id|bt-&gt;truncated
op_assign
l_int|0
suffix:semicolon
id|bt-&gt;state
op_assign
id|BT_STATE_XACTION_START
suffix:semicolon
id|bt-&gt;last_state
op_assign
id|BT_STATE_IDLE
suffix:semicolon
id|bt-&gt;timeout
op_assign
id|BT_NORMAL_TIMEOUT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* After the upper state machine has been told SI_SM_TRANSACTION_COMPLETE&n;   it calls this.  Strip out the length and seq bytes. */
DECL|function|bt_get_result
r_static
r_int
id|bt_get_result
c_func
(paren
r_struct
id|si_sm_data
op_star
id|bt
comma
r_int
r_char
op_star
id|data
comma
r_int
r_int
id|length
)paren
(brace
r_int
id|i
comma
id|msg_len
suffix:semicolon
id|msg_len
op_assign
id|bt-&gt;read_count
op_minus
l_int|2
suffix:semicolon
multiline_comment|/* account for length &amp; seq */
multiline_comment|/* Always NetFn, Cmd, cCode */
r_if
c_cond
(paren
id|msg_len
template_param
id|IPMI_MAX_MSG_LENGTH
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;BT results: bad msg_len = %d&bslash;n&quot;
comma
id|msg_len
)paren
suffix:semicolon
id|data
(braket
l_int|0
)braket
op_assign
id|bt-&gt;write_data
(braket
l_int|1
)braket
op_or
l_int|0x4
suffix:semicolon
multiline_comment|/* Kludge a response */
id|data
(braket
l_int|1
)braket
op_assign
id|bt-&gt;write_data
(braket
l_int|3
)braket
suffix:semicolon
id|data
(braket
l_int|2
)braket
op_assign
id|IPMI_ERR_UNSPECIFIED
suffix:semicolon
id|msg_len
op_assign
l_int|3
suffix:semicolon
)brace
r_else
(brace
id|data
(braket
l_int|0
)braket
op_assign
id|bt-&gt;read_data
(braket
l_int|1
)braket
suffix:semicolon
id|data
(braket
l_int|1
)braket
op_assign
id|bt-&gt;read_data
(braket
l_int|3
)braket
suffix:semicolon
r_if
c_cond
(paren
id|length
OL
id|msg_len
)paren
id|bt-&gt;truncated
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bt-&gt;truncated
)paren
(brace
multiline_comment|/* can be set in read_all_bytes() */
id|data
(braket
l_int|2
)braket
op_assign
id|IPMI_ERR_MSG_TRUNCATED
suffix:semicolon
id|msg_len
op_assign
l_int|3
suffix:semicolon
)brace
r_else
id|memcpy
c_func
(paren
id|data
op_plus
l_int|2
comma
id|bt-&gt;read_data
op_plus
l_int|4
comma
id|msg_len
op_minus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bt_debug
op_amp
id|BT_DEBUG_MSG
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;BT: res (raw)&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|msg_len
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %02x&quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|bt-&gt;read_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* paranoia */
r_return
id|msg_len
suffix:semicolon
)brace
multiline_comment|/* This bit&squot;s functionality is optional */
DECL|macro|BT_BMC_HWRST
mdefine_line|#define BT_BMC_HWRST&t;0x80
DECL|function|reset_flags
r_static
r_void
id|reset_flags
c_func
(paren
r_struct
id|si_sm_data
op_star
id|bt
)paren
(brace
r_if
c_cond
(paren
id|BT_STATUS
op_amp
id|BT_H_BUSY
)paren
id|BT_CONTROL
c_func
(paren
id|BT_H_BUSY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BT_STATUS
op_amp
id|BT_B_BUSY
)paren
id|BT_CONTROL
c_func
(paren
id|BT_B_BUSY
)paren
suffix:semicolon
id|BT_CONTROL
c_func
(paren
id|BT_CLR_WR_PTR
)paren
suffix:semicolon
id|BT_CONTROL
c_func
(paren
id|BT_SMS_ATN
)paren
suffix:semicolon
id|BT_INTMASK_W
c_func
(paren
id|BT_BMC_HWRST
)paren
suffix:semicolon
macro_line|#ifdef DEVELOPMENT_ONLY_NOT_FOR_PRODUCTION
r_if
c_cond
(paren
id|BT_STATUS
op_amp
id|BT_B2H_ATN
)paren
(brace
r_int
id|i
suffix:semicolon
id|BT_CONTROL
c_func
(paren
id|BT_H_BUSY
)paren
suffix:semicolon
id|BT_CONTROL
c_func
(paren
id|BT_B2H_ATN
)paren
suffix:semicolon
id|BT_CONTROL
c_func
(paren
id|BT_CLR_RD_PTR
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|IPMI_MAX_MSG_LENGTH
op_plus
l_int|2
suffix:semicolon
id|i
op_increment
)paren
id|BMC2HOST
suffix:semicolon
id|BT_CONTROL
c_func
(paren
id|BT_H_BUSY
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
DECL|function|write_all_bytes
r_static
r_inline
r_void
id|write_all_bytes
c_func
(paren
r_struct
id|si_sm_data
op_star
id|bt
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|bt_debug
op_amp
id|BT_DEBUG_MSG
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;BT: write %d bytes seq=0x%02X&quot;
comma
id|bt-&gt;write_count
comma
id|bt-&gt;seq
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bt-&gt;write_count
suffix:semicolon
id|i
op_increment
)paren
id|printk
(paren
l_string|&quot; %02x&quot;
comma
id|bt-&gt;write_data
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bt-&gt;write_count
suffix:semicolon
id|i
op_increment
)paren
id|HOST2BMC
c_func
(paren
id|bt-&gt;write_data
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
DECL|function|read_all_bytes
r_static
r_inline
r_int
id|read_all_bytes
c_func
(paren
r_struct
id|si_sm_data
op_star
id|bt
)paren
(brace
r_int
r_char
id|i
suffix:semicolon
id|bt-&gt;read_data
(braket
l_int|0
)braket
op_assign
id|BMC2HOST
suffix:semicolon
id|bt-&gt;read_count
op_assign
id|bt-&gt;read_data
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|bt_debug
op_amp
id|BT_DEBUG_MSG
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;BT: read %d bytes:&quot;
comma
id|bt-&gt;read_count
)paren
suffix:semicolon
multiline_comment|/* minimum: length, NetFn, Seq, Cmd, cCode == 5 total, or 4 more&n;&t;   following the length byte. */
r_if
c_cond
(paren
id|bt-&gt;read_count
OL
l_int|4
op_logical_or
id|bt-&gt;read_count
op_ge
id|IPMI_MAX_MSG_LENGTH
)paren
(brace
r_if
c_cond
(paren
id|bt_debug
op_amp
id|BT_DEBUG_MSG
)paren
id|printk
c_func
(paren
l_string|&quot;bad length %d&bslash;n&quot;
comma
id|bt-&gt;read_count
)paren
suffix:semicolon
id|bt-&gt;truncated
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* let next XACTION START clean it up */
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
id|bt-&gt;read_count
suffix:semicolon
id|i
op_increment
)paren
id|bt-&gt;read_data
(braket
id|i
)braket
op_assign
id|BMC2HOST
suffix:semicolon
id|bt-&gt;read_count
op_increment
suffix:semicolon
multiline_comment|/* account for the length byte */
r_if
c_cond
(paren
id|bt_debug
op_amp
id|BT_DEBUG_MSG
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bt-&gt;read_count
suffix:semicolon
id|i
op_increment
)paren
id|printk
(paren
l_string|&quot; %02x&quot;
comma
id|bt-&gt;read_data
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bt-&gt;seq
op_ne
id|bt-&gt;write_data
(braket
l_int|2
)braket
)paren
multiline_comment|/* idiot check */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;BT: internal error: sequence mismatch&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* per the spec, the (NetFn, Seq, Cmd) tuples should match */
r_if
c_cond
(paren
(paren
id|bt-&gt;read_data
(braket
l_int|3
)braket
op_eq
id|bt-&gt;write_data
(braket
l_int|3
)braket
)paren
op_logical_and
multiline_comment|/* Cmd */
(paren
id|bt-&gt;read_data
(braket
l_int|2
)braket
op_eq
id|bt-&gt;write_data
(braket
l_int|2
)braket
)paren
op_logical_and
multiline_comment|/* Sequence */
(paren
(paren
id|bt-&gt;read_data
(braket
l_int|1
)braket
op_amp
l_int|0xF8
)paren
op_eq
(paren
id|bt-&gt;write_data
(braket
l_int|1
)braket
op_amp
l_int|0xF8
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bt_debug
op_amp
id|BT_DEBUG_MSG
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;BT: bad packet: &quot;
l_string|&quot;want 0x(%02X, %02X, %02X) got (%02X, %02X, %02X)&bslash;n&quot;
comma
id|bt-&gt;write_data
(braket
l_int|1
)braket
comma
id|bt-&gt;write_data
(braket
l_int|2
)braket
comma
id|bt-&gt;write_data
(braket
l_int|3
)braket
comma
id|bt-&gt;read_data
(braket
l_int|1
)braket
comma
id|bt-&gt;read_data
(braket
l_int|2
)braket
comma
id|bt-&gt;read_data
(braket
l_int|3
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Modifies bt-&gt;state appropriately, need to get into the bt_event() switch */
DECL|function|error_recovery
r_static
r_void
id|error_recovery
c_func
(paren
r_struct
id|si_sm_data
op_star
id|bt
comma
r_char
op_star
id|reason
)paren
(brace
r_int
r_char
id|status
suffix:semicolon
r_char
id|buf
(braket
l_int|40
)braket
suffix:semicolon
multiline_comment|/* For getting status */
id|bt-&gt;timeout
op_assign
id|BT_NORMAL_TIMEOUT
suffix:semicolon
multiline_comment|/* various places want to retry */
id|status
op_assign
id|BT_STATUS
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;BT: %s in %s %s &quot;
comma
id|reason
comma
id|STATE2TXT
comma
id|STATUS2TXT
c_func
(paren
id|buf
)paren
)paren
suffix:semicolon
(paren
id|bt-&gt;error_retries
)paren
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bt-&gt;error_retries
OG
id|BT_RETRY_LIMIT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;retry limit (%d) exceeded&bslash;n&quot;
comma
id|BT_RETRY_LIMIT
)paren
suffix:semicolon
id|bt-&gt;state
op_assign
id|BT_STATE_HOSED
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bt-&gt;nonzero_status
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;IPMI: BT stuck, try power cycle&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bt-&gt;seq
op_eq
id|FIRST_SEQ
op_plus
id|BT_RETRY_LIMIT
)paren
(brace
multiline_comment|/* most likely during insmod */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;IPMI: BT reset (takes 5 secs)&bslash;n&quot;
)paren
suffix:semicolon
id|bt-&gt;state
op_assign
id|BT_STATE_RESET1
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Sometimes the BMC queues get in an &quot;off-by-one&quot; state...*/
r_if
c_cond
(paren
(paren
id|bt-&gt;state
op_eq
id|BT_STATE_B2H_WAIT
)paren
op_logical_and
(paren
id|status
op_amp
id|BT_B2H_ATN
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;retry B2H_WAIT&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;restart command&bslash;n&quot;
)paren
suffix:semicolon
id|bt-&gt;state
op_assign
id|BT_STATE_RESTART
suffix:semicolon
)brace
multiline_comment|/* Check the status and (possibly) advance the BT state machine.  The&n;   default return is SI_SM_CALL_WITH_DELAY. */
DECL|function|bt_event
r_static
r_enum
id|si_sm_result
id|bt_event
c_func
(paren
r_struct
id|si_sm_data
op_star
id|bt
comma
r_int
id|time
)paren
(brace
r_int
r_char
id|status
suffix:semicolon
r_char
id|buf
(braket
l_int|40
)braket
suffix:semicolon
multiline_comment|/* For getting status */
r_int
id|i
suffix:semicolon
id|status
op_assign
id|BT_STATUS
suffix:semicolon
id|bt-&gt;nonzero_status
op_or_assign
id|status
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bt_debug
op_amp
id|BT_DEBUG_STATES
)paren
op_logical_and
(paren
id|bt-&gt;state
op_ne
id|bt-&gt;last_state
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;BT: %s %s TO=%ld - %ld &bslash;n&quot;
comma
id|STATE2TXT
comma
id|STATUS2TXT
c_func
(paren
id|buf
)paren
comma
id|bt-&gt;timeout
comma
id|time
)paren
suffix:semicolon
id|bt-&gt;last_state
op_assign
id|bt-&gt;state
suffix:semicolon
r_if
c_cond
(paren
id|bt-&gt;state
op_eq
id|BT_STATE_HOSED
)paren
r_return
id|SI_SM_HOSED
suffix:semicolon
r_if
c_cond
(paren
id|bt-&gt;state
op_ne
id|BT_STATE_IDLE
)paren
(brace
multiline_comment|/* do timeout test */
multiline_comment|/* Certain states, on error conditions, can lock up a CPU&n;&t;&t;   because they are effectively in an infinite loop with&n;&t;&t;   CALL_WITHOUT_DELAY (right back here with time == 0).&n;&t;&t;   Prevent infinite lockup by ALWAYS decrementing timeout. */
multiline_comment|/* FIXME: bt_event is sometimes called with time &gt; BT_NORMAL_TIMEOUT&n;              (noticed in ipmi_smic_sm.c January 2004) */
r_if
c_cond
(paren
(paren
id|time
op_le
l_int|0
)paren
op_logical_or
(paren
id|time
op_ge
id|BT_NORMAL_TIMEOUT
)paren
)paren
id|time
op_assign
l_int|100
suffix:semicolon
id|bt-&gt;timeout
op_sub_assign
id|time
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bt-&gt;timeout
OL
l_int|0
)paren
op_logical_and
(paren
id|bt-&gt;state
OL
id|BT_STATE_RESET1
)paren
)paren
(brace
id|error_recovery
c_func
(paren
id|bt
comma
l_string|&quot;timed out&quot;
)paren
suffix:semicolon
r_return
id|SI_SM_CALL_WITHOUT_DELAY
suffix:semicolon
)brace
)brace
r_switch
c_cond
(paren
id|bt-&gt;state
)paren
(brace
r_case
id|BT_STATE_IDLE
suffix:colon
multiline_comment|/* check for asynchronous messages */
r_if
c_cond
(paren
id|status
op_amp
id|BT_SMS_ATN
)paren
(brace
id|BT_CONTROL
c_func
(paren
id|BT_SMS_ATN
)paren
suffix:semicolon
multiline_comment|/* clear it */
r_return
id|SI_SM_ATTN
suffix:semicolon
)brace
r_return
id|SI_SM_IDLE
suffix:semicolon
r_case
id|BT_STATE_XACTION_START
suffix:colon
r_if
c_cond
(paren
id|status
op_amp
id|BT_H_BUSY
)paren
(brace
id|BT_CONTROL
c_func
(paren
id|BT_H_BUSY
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|BT_B2H_ATN
)paren
r_break
suffix:semicolon
id|bt-&gt;state
op_assign
id|BT_STATE_WRITE_BYTES
suffix:semicolon
r_return
id|SI_SM_CALL_WITHOUT_DELAY
suffix:semicolon
multiline_comment|/* for logging */
r_case
id|BT_STATE_WRITE_BYTES
suffix:colon
r_if
c_cond
(paren
id|status
op_amp
(paren
id|BT_B_BUSY
op_or
id|BT_H2B_ATN
)paren
)paren
r_break
suffix:semicolon
id|BT_CONTROL
c_func
(paren
id|BT_CLR_WR_PTR
)paren
suffix:semicolon
id|write_all_bytes
c_func
(paren
id|bt
)paren
suffix:semicolon
id|BT_CONTROL
c_func
(paren
id|BT_H2B_ATN
)paren
suffix:semicolon
multiline_comment|/* clears too fast to catch? */
id|bt-&gt;state
op_assign
id|BT_STATE_WRITE_CONSUME
suffix:semicolon
r_return
id|SI_SM_CALL_WITHOUT_DELAY
suffix:semicolon
multiline_comment|/* it MIGHT sail through */
r_case
id|BT_STATE_WRITE_CONSUME
suffix:colon
multiline_comment|/* BMCs usually blow right thru here */
r_if
c_cond
(paren
id|status
op_amp
(paren
id|BT_H2B_ATN
op_or
id|BT_B_BUSY
)paren
)paren
r_break
suffix:semicolon
id|bt-&gt;state
op_assign
id|BT_STATE_B2H_WAIT
suffix:semicolon
multiline_comment|/* fall through with status */
multiline_comment|/* Stay in BT_STATE_B2H_WAIT until a packet matches.  However, spinning&n;&t;   hard here, constantly reading status, seems to hold off the&n;&t;   generation of B2H_ATN so ALWAYS return CALL_WITH_DELAY. */
r_case
id|BT_STATE_B2H_WAIT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|BT_B2H_ATN
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* Assume ordered, uncached writes: no need to wait */
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|BT_H_BUSY
)paren
)paren
id|BT_CONTROL
c_func
(paren
id|BT_H_BUSY
)paren
suffix:semicolon
multiline_comment|/* set */
id|BT_CONTROL
c_func
(paren
id|BT_B2H_ATN
)paren
suffix:semicolon
multiline_comment|/* clear it, ACK to the BMC */
id|BT_CONTROL
c_func
(paren
id|BT_CLR_RD_PTR
)paren
suffix:semicolon
multiline_comment|/* reset the queue */
id|i
op_assign
id|read_all_bytes
c_func
(paren
id|bt
)paren
suffix:semicolon
id|BT_CONTROL
c_func
(paren
id|BT_H_BUSY
)paren
suffix:semicolon
multiline_comment|/* clear */
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
r_break
suffix:semicolon
multiline_comment|/* Try this state again */
id|bt-&gt;state
op_assign
id|BT_STATE_READ_END
suffix:semicolon
r_return
id|SI_SM_CALL_WITHOUT_DELAY
suffix:semicolon
multiline_comment|/* for logging */
r_case
id|BT_STATE_READ_END
suffix:colon
multiline_comment|/* I could wait on BT_H_BUSY to go clear for a truly clean&n;&t;&t;   exit.  However, this is already done in XACTION_START&n;&t;&t;   and the (possible) extra loop/status/possible wait affects&n;&t;&t;   performance.  So, as long as it works, just ignore H_BUSY */
macro_line|#ifdef MAKE_THIS_TRUE_IF_NECESSARY
r_if
c_cond
(paren
id|status
op_amp
id|BT_H_BUSY
)paren
r_break
suffix:semicolon
macro_line|#endif
id|bt-&gt;seq
op_increment
suffix:semicolon
id|bt-&gt;state
op_assign
id|BT_STATE_IDLE
suffix:semicolon
r_return
id|SI_SM_TRANSACTION_COMPLETE
suffix:semicolon
r_case
id|BT_STATE_RESET1
suffix:colon
id|reset_flags
c_func
(paren
id|bt
)paren
suffix:semicolon
id|bt-&gt;timeout
op_assign
id|BT_RESET_DELAY
suffix:semicolon
id|bt-&gt;state
op_assign
id|BT_STATE_RESET2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BT_STATE_RESET2
suffix:colon
multiline_comment|/* Send a soft reset */
id|BT_CONTROL
c_func
(paren
id|BT_CLR_WR_PTR
)paren
suffix:semicolon
id|HOST2BMC
c_func
(paren
l_int|3
)paren
suffix:semicolon
multiline_comment|/* number of bytes following */
id|HOST2BMC
c_func
(paren
l_int|0x18
)paren
suffix:semicolon
multiline_comment|/* NetFn/LUN == Application, LUN 0 */
id|HOST2BMC
c_func
(paren
l_int|42
)paren
suffix:semicolon
multiline_comment|/* Sequence number */
id|HOST2BMC
c_func
(paren
l_int|3
)paren
suffix:semicolon
multiline_comment|/* Cmd == Soft reset */
id|BT_CONTROL
c_func
(paren
id|BT_H2B_ATN
)paren
suffix:semicolon
id|bt-&gt;state
op_assign
id|BT_STATE_RESET3
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BT_STATE_RESET3
suffix:colon
r_if
c_cond
(paren
id|bt-&gt;timeout
OG
l_int|0
)paren
r_return
id|SI_SM_CALL_WITH_DELAY
suffix:semicolon
id|bt-&gt;state
op_assign
id|BT_STATE_RESTART
suffix:semicolon
multiline_comment|/* printk in debug modes */
r_break
suffix:semicolon
r_case
id|BT_STATE_RESTART
suffix:colon
multiline_comment|/* don&squot;t reset retries! */
id|bt-&gt;write_data
(braket
l_int|2
)braket
op_assign
op_increment
id|bt-&gt;seq
suffix:semicolon
id|bt-&gt;read_count
op_assign
l_int|0
suffix:semicolon
id|bt-&gt;nonzero_status
op_assign
l_int|0
suffix:semicolon
id|bt-&gt;timeout
op_assign
id|BT_NORMAL_TIMEOUT
suffix:semicolon
id|bt-&gt;state
op_assign
id|BT_STATE_XACTION_START
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* HOSED is supposed to be caught much earlier */
id|error_recovery
c_func
(paren
id|bt
comma
l_string|&quot;internal logic error&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|SI_SM_CALL_WITH_DELAY
suffix:semicolon
)brace
DECL|function|bt_detect
r_static
r_int
id|bt_detect
c_func
(paren
r_struct
id|si_sm_data
op_star
id|bt
)paren
(brace
multiline_comment|/* It&squot;s impossible for the BT status and interrupt registers to be&n;&t;   all 1&squot;s, (assuming a properly functioning, self-initialized BMC)&n;&t;   but that&squot;s what you get from reading a bogus address, so we&n;&t;   test that first.  The calling routine uses negative logic. */
r_if
c_cond
(paren
(paren
id|BT_STATUS
op_eq
l_int|0xFF
)paren
op_logical_and
(paren
id|BT_INTMASK_R
op_eq
l_int|0xFF
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|reset_flags
c_func
(paren
id|bt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|bt_cleanup
r_static
r_void
id|bt_cleanup
c_func
(paren
r_struct
id|si_sm_data
op_star
id|bt
)paren
(brace
)brace
DECL|function|bt_size
r_static
r_int
id|bt_size
c_func
(paren
r_void
)paren
(brace
r_return
r_sizeof
(paren
r_struct
id|si_sm_data
)paren
suffix:semicolon
)brace
DECL|variable|bt_smi_handlers
r_struct
id|si_sm_handlers
id|bt_smi_handlers
op_assign
(brace
dot
id|version
op_assign
id|IPMI_BT_VERSION
comma
dot
id|init_data
op_assign
id|bt_init_data
comma
dot
id|start_transaction
op_assign
id|bt_start_transaction
comma
dot
id|get_result
op_assign
id|bt_get_result
comma
dot
id|event
op_assign
id|bt_event
comma
dot
id|detect
op_assign
id|bt_detect
comma
dot
id|cleanup
op_assign
id|bt_cleanup
comma
dot
id|size
op_assign
id|bt_size
comma
)brace
suffix:semicolon
eof
