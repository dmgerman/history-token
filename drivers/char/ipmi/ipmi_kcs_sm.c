multiline_comment|/*&n; * ipmi_kcs_sm.c&n; *&n; * State machine for handling IPMI KCS interfaces.&n; *&n; * Author: MontaVista Software, Inc.&n; *         Corey Minyard &lt;minyard@mvista.com&gt;&n; *         source@mvista.com&n; *&n; * Copyright 2002 MontaVista Software Inc.&n; *&n; *  This program is free software; you can redistribute it and/or modify it&n; *  under the terms of the GNU General Public License as published by the&n; *  Free Software Foundation; either version 2 of the License, or (at your&n; *  option) any later version.&n; *&n; *&n; *  THIS SOFTWARE IS PROVIDED ``AS IS&squot;&squot; AND ANY EXPRESS OR IMPLIED&n; *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&n; *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.&n; *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,&n; *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,&n; *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS&n; *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND&n; *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR&n; *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE&n; *  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n; *&n; *  You should have received a copy of the GNU General Public License along&n; *  with this program; if not, write to the Free Software Foundation, Inc.,&n; *  675 Mass Ave, Cambridge, MA 02139, USA.&n; */
multiline_comment|/*&n; * This state machine is taken from the state machine in the IPMI spec,&n; * pretty much verbatim.  If you have questions about the states, see&n; * that document.&n; */
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/string.h&gt;&t;&t;/* Gets rid of memcpy warning */
macro_line|#include &quot;ipmi_kcs_sm.h&quot;
multiline_comment|/* Set this if you want a printout of why the state machine was hosed&n;   when it gets hosed. */
DECL|macro|DEBUG_HOSED_REASON
mdefine_line|#define DEBUG_HOSED_REASON
multiline_comment|/* Print the state machine state on entry every time. */
DECL|macro|DEBUG_STATE
macro_line|#undef DEBUG_STATE
multiline_comment|/* The states the KCS driver may be in. */
DECL|enum|kcs_states
r_enum
id|kcs_states
(brace
DECL|enumerator|KCS_IDLE
id|KCS_IDLE
comma
multiline_comment|/* The KCS interface is currently&n;                                   doing nothing. */
DECL|enumerator|KCS_START_OP
id|KCS_START_OP
comma
multiline_comment|/* We are starting an operation.  The&n;&t;&t;&t;&t;   data is in the output buffer, but&n;&t;&t;&t;&t;   nothing has been done to the&n;&t;&t;&t;&t;   interface yet.  This was added to&n;&t;&t;&t;&t;   the state machine in the spec to&n;&t;&t;&t;&t;   wait for the initial IBF. */
DECL|enumerator|KCS_WAIT_WRITE_START
id|KCS_WAIT_WRITE_START
comma
multiline_comment|/* We have written a write cmd to the&n;&t;&t;&t;&t;   interface. */
DECL|enumerator|KCS_WAIT_WRITE
id|KCS_WAIT_WRITE
comma
multiline_comment|/* We are writing bytes to the&n;                                   interface. */
DECL|enumerator|KCS_WAIT_WRITE_END
id|KCS_WAIT_WRITE_END
comma
multiline_comment|/* We have written the write end cmd&n;                                   to the interface, and still need to&n;                                   write the last byte. */
DECL|enumerator|KCS_WAIT_READ
id|KCS_WAIT_READ
comma
multiline_comment|/* We are waiting to read data from&n;&t;&t;&t;&t;   the interface. */
DECL|enumerator|KCS_ERROR0
id|KCS_ERROR0
comma
multiline_comment|/* State to transition to the error&n;&t;&t;&t;&t;   handler, this was added to the&n;&t;&t;&t;&t;   state machine in the spec to be&n;&t;&t;&t;&t;   sure IBF was there. */
DECL|enumerator|KCS_ERROR1
id|KCS_ERROR1
comma
multiline_comment|/* First stage error handler, wait for&n;                                   the interface to respond. */
DECL|enumerator|KCS_ERROR2
id|KCS_ERROR2
comma
multiline_comment|/* The abort cmd has been written,&n;&t;&t;&t;&t;   wait for the interface to&n;&t;&t;&t;&t;   respond. */
DECL|enumerator|KCS_ERROR3
id|KCS_ERROR3
comma
multiline_comment|/* We wrote some data to the&n;&t;&t;&t;&t;   interface, wait for it to switch to&n;&t;&t;&t;&t;   read mode. */
DECL|enumerator|KCS_HOSED
id|KCS_HOSED
multiline_comment|/* The hardware failed to follow the&n;&t;&t;&t;&t;   state machine. */
)brace
suffix:semicolon
DECL|macro|MAX_KCS_READ_SIZE
mdefine_line|#define MAX_KCS_READ_SIZE 80
DECL|macro|MAX_KCS_WRITE_SIZE
mdefine_line|#define MAX_KCS_WRITE_SIZE 80
multiline_comment|/* Timeouts in microseconds. */
DECL|macro|IBF_RETRY_TIMEOUT
mdefine_line|#define IBF_RETRY_TIMEOUT 1000000
DECL|macro|OBF_RETRY_TIMEOUT
mdefine_line|#define OBF_RETRY_TIMEOUT 1000000
DECL|macro|MAX_ERROR_RETRIES
mdefine_line|#define MAX_ERROR_RETRIES 10
DECL|macro|IPMI_ERR_MSG_TRUNCATED
mdefine_line|#define IPMI_ERR_MSG_TRUNCATED&t;0xc6
DECL|macro|IPMI_ERR_UNSPECIFIED
mdefine_line|#define IPMI_ERR_UNSPECIFIED&t;0xff
DECL|struct|kcs_data
r_struct
id|kcs_data
(brace
DECL|member|state
r_enum
id|kcs_states
id|state
suffix:semicolon
DECL|member|port
r_int
r_int
id|port
suffix:semicolon
DECL|member|addr
r_int
r_char
op_star
id|addr
suffix:semicolon
DECL|member|write_data
r_int
r_char
id|write_data
(braket
id|MAX_KCS_WRITE_SIZE
)braket
suffix:semicolon
DECL|member|write_pos
r_int
id|write_pos
suffix:semicolon
DECL|member|write_count
r_int
id|write_count
suffix:semicolon
DECL|member|orig_write_count
r_int
id|orig_write_count
suffix:semicolon
DECL|member|read_data
r_int
r_char
id|read_data
(braket
id|MAX_KCS_READ_SIZE
)braket
suffix:semicolon
DECL|member|read_pos
r_int
id|read_pos
suffix:semicolon
DECL|member|truncated
r_int
id|truncated
suffix:semicolon
DECL|member|error_retries
r_int
r_int
id|error_retries
suffix:semicolon
DECL|member|ibf_timeout
r_int
id|ibf_timeout
suffix:semicolon
DECL|member|obf_timeout
r_int
id|obf_timeout
suffix:semicolon
)brace
suffix:semicolon
DECL|function|init_kcs_data
r_void
id|init_kcs_data
c_func
(paren
r_struct
id|kcs_data
op_star
id|kcs
comma
r_int
r_int
id|port
comma
r_int
r_char
op_star
id|addr
)paren
(brace
id|kcs-&gt;state
op_assign
id|KCS_IDLE
suffix:semicolon
id|kcs-&gt;port
op_assign
id|port
suffix:semicolon
id|kcs-&gt;addr
op_assign
id|addr
suffix:semicolon
id|kcs-&gt;write_pos
op_assign
l_int|0
suffix:semicolon
id|kcs-&gt;write_count
op_assign
l_int|0
suffix:semicolon
id|kcs-&gt;orig_write_count
op_assign
l_int|0
suffix:semicolon
id|kcs-&gt;read_pos
op_assign
l_int|0
suffix:semicolon
id|kcs-&gt;error_retries
op_assign
l_int|0
suffix:semicolon
id|kcs-&gt;truncated
op_assign
l_int|0
suffix:semicolon
id|kcs-&gt;ibf_timeout
op_assign
id|IBF_RETRY_TIMEOUT
suffix:semicolon
id|kcs-&gt;obf_timeout
op_assign
id|OBF_RETRY_TIMEOUT
suffix:semicolon
)brace
multiline_comment|/* Remember, init_one_kcs() insured port and addr can&squot;t both be set */
DECL|function|read_status
r_static
r_inline
r_int
r_char
id|read_status
c_func
(paren
r_struct
id|kcs_data
op_star
id|kcs
)paren
(brace
r_if
c_cond
(paren
id|kcs-&gt;port
)paren
r_return
id|inb
c_func
(paren
id|kcs-&gt;port
op_plus
l_int|1
)paren
suffix:semicolon
r_else
r_return
id|readb
c_func
(paren
id|kcs-&gt;addr
op_plus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|read_data
r_static
r_inline
r_int
r_char
id|read_data
c_func
(paren
r_struct
id|kcs_data
op_star
id|kcs
)paren
(brace
r_if
c_cond
(paren
id|kcs-&gt;port
)paren
r_return
id|inb
c_func
(paren
id|kcs-&gt;port
op_plus
l_int|0
)paren
suffix:semicolon
r_else
r_return
id|readb
c_func
(paren
id|kcs-&gt;addr
op_plus
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|write_cmd
r_static
r_inline
r_void
id|write_cmd
c_func
(paren
r_struct
id|kcs_data
op_star
id|kcs
comma
r_int
r_char
id|data
)paren
(brace
r_if
c_cond
(paren
id|kcs-&gt;port
)paren
id|outb
c_func
(paren
id|data
comma
id|kcs-&gt;port
op_plus
l_int|1
)paren
suffix:semicolon
r_else
id|writeb
c_func
(paren
id|data
comma
id|kcs-&gt;addr
op_plus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|write_data
r_static
r_inline
r_void
id|write_data
c_func
(paren
r_struct
id|kcs_data
op_star
id|kcs
comma
r_int
r_char
id|data
)paren
(brace
r_if
c_cond
(paren
id|kcs-&gt;port
)paren
id|outb
c_func
(paren
id|data
comma
id|kcs-&gt;port
op_plus
l_int|0
)paren
suffix:semicolon
r_else
id|writeb
c_func
(paren
id|data
comma
id|kcs-&gt;addr
op_plus
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Control codes. */
DECL|macro|KCS_GET_STATUS_ABORT
mdefine_line|#define KCS_GET_STATUS_ABORT&t;0x60
DECL|macro|KCS_WRITE_START
mdefine_line|#define KCS_WRITE_START&t;&t;0x61
DECL|macro|KCS_WRITE_END
mdefine_line|#define KCS_WRITE_END&t;&t;0x62
DECL|macro|KCS_READ_BYTE
mdefine_line|#define KCS_READ_BYTE&t;&t;0x68
multiline_comment|/* Status bits. */
DECL|macro|GET_STATUS_STATE
mdefine_line|#define GET_STATUS_STATE(status) (((status) &gt;&gt; 6) &amp; 0x03)
DECL|macro|KCS_IDLE_STATE
mdefine_line|#define KCS_IDLE_STATE&t;0
DECL|macro|KCS_READ_STATE
mdefine_line|#define KCS_READ_STATE&t;1
DECL|macro|KCS_WRITE_STATE
mdefine_line|#define KCS_WRITE_STATE&t;2
DECL|macro|KCS_ERROR_STATE
mdefine_line|#define KCS_ERROR_STATE&t;3
DECL|macro|GET_STATUS_ATN
mdefine_line|#define GET_STATUS_ATN(status) ((status) &amp; 0x04)
DECL|macro|GET_STATUS_IBF
mdefine_line|#define GET_STATUS_IBF(status) ((status) &amp; 0x02)
DECL|macro|GET_STATUS_OBF
mdefine_line|#define GET_STATUS_OBF(status) ((status) &amp; 0x01)
DECL|function|write_next_byte
r_static
r_inline
r_void
id|write_next_byte
c_func
(paren
r_struct
id|kcs_data
op_star
id|kcs
)paren
(brace
id|write_data
c_func
(paren
id|kcs
comma
id|kcs-&gt;write_data
(braket
id|kcs-&gt;write_pos
)braket
)paren
suffix:semicolon
(paren
id|kcs-&gt;write_pos
)paren
op_increment
suffix:semicolon
(paren
id|kcs-&gt;write_count
)paren
op_decrement
suffix:semicolon
)brace
DECL|function|start_error_recovery
r_static
r_inline
r_void
id|start_error_recovery
c_func
(paren
r_struct
id|kcs_data
op_star
id|kcs
comma
r_char
op_star
id|reason
)paren
(brace
(paren
id|kcs-&gt;error_retries
)paren
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|kcs-&gt;error_retries
OG
id|MAX_ERROR_RETRIES
)paren
(brace
macro_line|#ifdef DEBUG_HOSED_REASON
id|printk
c_func
(paren
l_string|&quot;ipmi_kcs_sm: kcs hosed: %s&bslash;n&quot;
comma
id|reason
)paren
suffix:semicolon
macro_line|#endif
id|kcs-&gt;state
op_assign
id|KCS_HOSED
suffix:semicolon
)brace
r_else
(brace
id|kcs-&gt;state
op_assign
id|KCS_ERROR0
suffix:semicolon
)brace
)brace
DECL|function|read_next_byte
r_static
r_inline
r_void
id|read_next_byte
c_func
(paren
r_struct
id|kcs_data
op_star
id|kcs
)paren
(brace
r_if
c_cond
(paren
id|kcs-&gt;read_pos
op_ge
id|MAX_KCS_READ_SIZE
)paren
(brace
multiline_comment|/* Throw the data away and mark it truncated. */
id|read_data
c_func
(paren
id|kcs
)paren
suffix:semicolon
id|kcs-&gt;truncated
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|kcs-&gt;read_data
(braket
id|kcs-&gt;read_pos
)braket
op_assign
id|read_data
c_func
(paren
id|kcs
)paren
suffix:semicolon
(paren
id|kcs-&gt;read_pos
)paren
op_increment
suffix:semicolon
)brace
id|write_data
c_func
(paren
id|kcs
comma
id|KCS_READ_BYTE
)paren
suffix:semicolon
)brace
DECL|function|check_ibf
r_static
r_inline
r_int
id|check_ibf
c_func
(paren
r_struct
id|kcs_data
op_star
id|kcs
comma
r_int
r_char
id|status
comma
r_int
id|time
)paren
(brace
r_if
c_cond
(paren
id|GET_STATUS_IBF
c_func
(paren
id|status
)paren
)paren
(brace
id|kcs-&gt;ibf_timeout
op_sub_assign
id|time
suffix:semicolon
r_if
c_cond
(paren
id|kcs-&gt;ibf_timeout
OL
l_int|0
)paren
(brace
id|start_error_recovery
c_func
(paren
id|kcs
comma
l_string|&quot;IBF not ready in time&quot;
)paren
suffix:semicolon
id|kcs-&gt;ibf_timeout
op_assign
id|IBF_RETRY_TIMEOUT
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|kcs-&gt;ibf_timeout
op_assign
id|IBF_RETRY_TIMEOUT
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|check_obf
r_static
r_inline
r_int
id|check_obf
c_func
(paren
r_struct
id|kcs_data
op_star
id|kcs
comma
r_int
r_char
id|status
comma
r_int
id|time
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|GET_STATUS_OBF
c_func
(paren
id|status
)paren
)paren
(brace
id|kcs-&gt;obf_timeout
op_sub_assign
id|time
suffix:semicolon
r_if
c_cond
(paren
id|kcs-&gt;obf_timeout
OL
l_int|0
)paren
(brace
id|start_error_recovery
c_func
(paren
id|kcs
comma
l_string|&quot;OBF not ready in time&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|kcs-&gt;obf_timeout
op_assign
id|OBF_RETRY_TIMEOUT
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|clear_obf
r_static
r_void
id|clear_obf
c_func
(paren
r_struct
id|kcs_data
op_star
id|kcs
comma
r_int
r_char
id|status
)paren
(brace
r_if
c_cond
(paren
id|GET_STATUS_OBF
c_func
(paren
id|status
)paren
)paren
id|read_data
c_func
(paren
id|kcs
)paren
suffix:semicolon
)brace
DECL|function|restart_kcs_transaction
r_static
r_void
id|restart_kcs_transaction
c_func
(paren
r_struct
id|kcs_data
op_star
id|kcs
)paren
(brace
id|kcs-&gt;write_count
op_assign
id|kcs-&gt;orig_write_count
suffix:semicolon
id|kcs-&gt;write_pos
op_assign
l_int|0
suffix:semicolon
id|kcs-&gt;read_pos
op_assign
l_int|0
suffix:semicolon
id|kcs-&gt;state
op_assign
id|KCS_WAIT_WRITE_START
suffix:semicolon
id|kcs-&gt;ibf_timeout
op_assign
id|IBF_RETRY_TIMEOUT
suffix:semicolon
id|kcs-&gt;obf_timeout
op_assign
id|OBF_RETRY_TIMEOUT
suffix:semicolon
id|write_cmd
c_func
(paren
id|kcs
comma
id|KCS_WRITE_START
)paren
suffix:semicolon
)brace
DECL|function|start_kcs_transaction
r_int
id|start_kcs_transaction
c_func
(paren
r_struct
id|kcs_data
op_star
id|kcs
comma
r_char
op_star
id|data
comma
r_int
r_int
id|size
)paren
(brace
r_if
c_cond
(paren
(paren
id|size
OL
l_int|2
)paren
op_logical_or
(paren
id|size
OG
id|MAX_KCS_WRITE_SIZE
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|kcs-&gt;state
op_ne
id|KCS_IDLE
)paren
op_logical_and
(paren
id|kcs-&gt;state
op_ne
id|KCS_HOSED
)paren
)paren
(brace
r_return
op_minus
l_int|2
suffix:semicolon
)brace
id|kcs-&gt;error_retries
op_assign
l_int|0
suffix:semicolon
id|memcpy
c_func
(paren
id|kcs-&gt;write_data
comma
id|data
comma
id|size
)paren
suffix:semicolon
id|kcs-&gt;write_count
op_assign
id|size
suffix:semicolon
id|kcs-&gt;orig_write_count
op_assign
id|size
suffix:semicolon
id|kcs-&gt;write_pos
op_assign
l_int|0
suffix:semicolon
id|kcs-&gt;read_pos
op_assign
l_int|0
suffix:semicolon
id|kcs-&gt;state
op_assign
id|KCS_START_OP
suffix:semicolon
id|kcs-&gt;ibf_timeout
op_assign
id|IBF_RETRY_TIMEOUT
suffix:semicolon
id|kcs-&gt;obf_timeout
op_assign
id|OBF_RETRY_TIMEOUT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|kcs_get_result
r_int
id|kcs_get_result
c_func
(paren
r_struct
id|kcs_data
op_star
id|kcs
comma
r_int
r_char
op_star
id|data
comma
r_int
id|length
)paren
(brace
r_if
c_cond
(paren
id|length
OL
id|kcs-&gt;read_pos
)paren
(brace
id|kcs-&gt;read_pos
op_assign
id|length
suffix:semicolon
id|kcs-&gt;truncated
op_assign
l_int|1
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|data
comma
id|kcs-&gt;read_data
comma
id|kcs-&gt;read_pos
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|length
op_ge
l_int|3
)paren
op_logical_and
(paren
id|kcs-&gt;read_pos
OL
l_int|3
)paren
)paren
(brace
multiline_comment|/* Guarantee that we return at least 3 bytes, with an&n;&t;&t;   error in the third byte if it is too short. */
id|data
(braket
l_int|2
)braket
op_assign
id|IPMI_ERR_UNSPECIFIED
suffix:semicolon
id|kcs-&gt;read_pos
op_assign
l_int|3
suffix:semicolon
)brace
r_if
c_cond
(paren
id|kcs-&gt;truncated
)paren
(brace
multiline_comment|/* Report a truncated error.  We might overwrite&n;&t;&t;   another error, but that&squot;s too bad, the user needs&n;&t;&t;   to know it was truncated. */
id|data
(braket
l_int|2
)braket
op_assign
id|IPMI_ERR_MSG_TRUNCATED
suffix:semicolon
id|kcs-&gt;truncated
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|kcs-&gt;read_pos
suffix:semicolon
)brace
multiline_comment|/* This implements the state machine defined in the IPMI manual, see&n;   that for details on how this works.  Divide that flowchart into&n;   sections delimited by &quot;Wait for IBF&quot; and this will become clear. */
DECL|function|kcs_event
r_enum
id|kcs_result
id|kcs_event
c_func
(paren
r_struct
id|kcs_data
op_star
id|kcs
comma
r_int
id|time
)paren
(brace
r_int
r_char
id|status
suffix:semicolon
r_int
r_char
id|state
suffix:semicolon
id|status
op_assign
id|read_status
c_func
(paren
id|kcs
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_STATE
id|printk
c_func
(paren
l_string|&quot;  State = %d, %x&bslash;n&quot;
comma
id|kcs-&gt;state
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* All states wait for ibf, so just do it here. */
r_if
c_cond
(paren
op_logical_neg
id|check_ibf
c_func
(paren
id|kcs
comma
id|status
comma
id|time
)paren
)paren
r_return
id|KCS_CALL_WITH_DELAY
suffix:semicolon
multiline_comment|/* Just about everything looks at the KCS state, so grab that, too. */
id|state
op_assign
id|GET_STATUS_STATE
c_func
(paren
id|status
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|kcs-&gt;state
)paren
(brace
r_case
id|KCS_IDLE
suffix:colon
multiline_comment|/* If there&squot;s and interrupt source, turn it off. */
id|clear_obf
c_func
(paren
id|kcs
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GET_STATUS_ATN
c_func
(paren
id|status
)paren
)paren
r_return
id|KCS_ATTN
suffix:semicolon
r_else
r_return
id|KCS_SM_IDLE
suffix:semicolon
r_case
id|KCS_START_OP
suffix:colon
r_if
c_cond
(paren
id|state
op_ne
id|KCS_IDLE
)paren
(brace
id|start_error_recovery
c_func
(paren
id|kcs
comma
l_string|&quot;State machine not idle at start&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|clear_obf
c_func
(paren
id|kcs
comma
id|status
)paren
suffix:semicolon
id|write_cmd
c_func
(paren
id|kcs
comma
id|KCS_WRITE_START
)paren
suffix:semicolon
id|kcs-&gt;state
op_assign
id|KCS_WAIT_WRITE_START
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KCS_WAIT_WRITE_START
suffix:colon
r_if
c_cond
(paren
id|state
op_ne
id|KCS_WRITE_STATE
)paren
(brace
id|start_error_recovery
c_func
(paren
id|kcs
comma
l_string|&quot;Not in write state at write start&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|read_data
c_func
(paren
id|kcs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kcs-&gt;write_count
op_eq
l_int|1
)paren
(brace
id|write_cmd
c_func
(paren
id|kcs
comma
id|KCS_WRITE_END
)paren
suffix:semicolon
id|kcs-&gt;state
op_assign
id|KCS_WAIT_WRITE_END
suffix:semicolon
)brace
r_else
(brace
id|write_next_byte
c_func
(paren
id|kcs
)paren
suffix:semicolon
id|kcs-&gt;state
op_assign
id|KCS_WAIT_WRITE
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|KCS_WAIT_WRITE
suffix:colon
r_if
c_cond
(paren
id|state
op_ne
id|KCS_WRITE_STATE
)paren
(brace
id|start_error_recovery
c_func
(paren
id|kcs
comma
l_string|&quot;Not in write state for write&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|clear_obf
c_func
(paren
id|kcs
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kcs-&gt;write_count
op_eq
l_int|1
)paren
(brace
id|write_cmd
c_func
(paren
id|kcs
comma
id|KCS_WRITE_END
)paren
suffix:semicolon
id|kcs-&gt;state
op_assign
id|KCS_WAIT_WRITE_END
suffix:semicolon
)brace
r_else
(brace
id|write_next_byte
c_func
(paren
id|kcs
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|KCS_WAIT_WRITE_END
suffix:colon
r_if
c_cond
(paren
id|state
op_ne
id|KCS_WRITE_STATE
)paren
(brace
id|start_error_recovery
c_func
(paren
id|kcs
comma
l_string|&quot;Not in write state for write end&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|clear_obf
c_func
(paren
id|kcs
comma
id|status
)paren
suffix:semicolon
id|write_next_byte
c_func
(paren
id|kcs
)paren
suffix:semicolon
id|kcs-&gt;state
op_assign
id|KCS_WAIT_READ
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KCS_WAIT_READ
suffix:colon
r_if
c_cond
(paren
(paren
id|state
op_ne
id|KCS_READ_STATE
)paren
op_logical_and
(paren
id|state
op_ne
id|KCS_IDLE_STATE
)paren
)paren
(brace
id|start_error_recovery
c_func
(paren
id|kcs
comma
l_string|&quot;Not in read or idle in read state&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|state
op_eq
id|KCS_READ_STATE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|check_obf
c_func
(paren
id|kcs
comma
id|status
comma
id|time
)paren
)paren
r_return
id|KCS_CALL_WITH_DELAY
suffix:semicolon
id|read_next_byte
c_func
(paren
id|kcs
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We don&squot;t implement this exactly like the state&n;&t;&t;&t;   machine in the spec.  Some broken hardware&n;&t;&t;&t;   does not write the final dummy byte to the&n;&t;&t;&t;   read register.  Thus obf will never go high&n;&t;&t;&t;   here.  We just go straight to idle, and we&n;&t;&t;&t;   handle clearing out obf in idle state if it&n;&t;&t;&t;   happens to come in. */
id|clear_obf
c_func
(paren
id|kcs
comma
id|status
)paren
suffix:semicolon
id|kcs-&gt;orig_write_count
op_assign
l_int|0
suffix:semicolon
id|kcs-&gt;state
op_assign
id|KCS_IDLE
suffix:semicolon
r_return
id|KCS_TRANSACTION_COMPLETE
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|KCS_ERROR0
suffix:colon
id|clear_obf
c_func
(paren
id|kcs
comma
id|status
)paren
suffix:semicolon
id|write_cmd
c_func
(paren
id|kcs
comma
id|KCS_GET_STATUS_ABORT
)paren
suffix:semicolon
id|kcs-&gt;state
op_assign
id|KCS_ERROR1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KCS_ERROR1
suffix:colon
id|clear_obf
c_func
(paren
id|kcs
comma
id|status
)paren
suffix:semicolon
id|write_data
c_func
(paren
id|kcs
comma
l_int|0
)paren
suffix:semicolon
id|kcs-&gt;state
op_assign
id|KCS_ERROR2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KCS_ERROR2
suffix:colon
r_if
c_cond
(paren
id|state
op_ne
id|KCS_READ_STATE
)paren
(brace
id|start_error_recovery
c_func
(paren
id|kcs
comma
l_string|&quot;Not in read state for error2&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|check_obf
c_func
(paren
id|kcs
comma
id|status
comma
id|time
)paren
)paren
r_return
id|KCS_CALL_WITH_DELAY
suffix:semicolon
id|clear_obf
c_func
(paren
id|kcs
comma
id|status
)paren
suffix:semicolon
id|write_data
c_func
(paren
id|kcs
comma
id|KCS_READ_BYTE
)paren
suffix:semicolon
id|kcs-&gt;state
op_assign
id|KCS_ERROR3
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KCS_ERROR3
suffix:colon
r_if
c_cond
(paren
id|state
op_ne
id|KCS_IDLE_STATE
)paren
(brace
id|start_error_recovery
c_func
(paren
id|kcs
comma
l_string|&quot;Not in idle state for error3&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|check_obf
c_func
(paren
id|kcs
comma
id|status
comma
id|time
)paren
)paren
r_return
id|KCS_CALL_WITH_DELAY
suffix:semicolon
id|clear_obf
c_func
(paren
id|kcs
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kcs-&gt;orig_write_count
)paren
(brace
id|restart_kcs_transaction
c_func
(paren
id|kcs
)paren
suffix:semicolon
)brace
r_else
(brace
id|kcs-&gt;state
op_assign
id|KCS_IDLE
suffix:semicolon
r_return
id|KCS_TRANSACTION_COMPLETE
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|KCS_HOSED
suffix:colon
r_return
id|KCS_SM_HOSED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|kcs-&gt;state
op_eq
id|KCS_HOSED
)paren
(brace
id|init_kcs_data
c_func
(paren
id|kcs
comma
id|kcs-&gt;port
comma
id|kcs-&gt;addr
)paren
suffix:semicolon
r_return
id|KCS_SM_HOSED
suffix:semicolon
)brace
r_return
id|KCS_CALL_WITHOUT_DELAY
suffix:semicolon
)brace
DECL|function|kcs_size
r_int
id|kcs_size
c_func
(paren
r_void
)paren
(brace
r_return
r_sizeof
(paren
r_struct
id|kcs_data
)paren
suffix:semicolon
)brace
eof
