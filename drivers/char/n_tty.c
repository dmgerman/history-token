multiline_comment|/*&n; * n_tty.c --- implements the N_TTY line discipline.&n; * &n; * This code used to be in tty_io.c, but things are getting hairy&n; * enough that it made sense to split things off.  (The N_TTY&n; * processing has changed so much that it&squot;s hardly recognizable,&n; * anyway...)&n; *&n; * Note that the open routine for N_TTY is guaranteed never to return&n; * an error.  This is because Linux will fall back to setting a line&n; * to N_TTY if it can not switch to any other line discipline.  &n; *&n; * Written by Theodore Ts&squot;o, Copyright 1994.&n; * &n; * This file also contains code originally written by Linus Torvalds,&n; * Copyright 1991, 1992, 1993, and by Julian Cowley, Copyright 1994.&n; * &n; * This file may be redistributed under the terms of the GNU General Public&n; * License.&n; *&n; * Reduced memory usage for older ARM systems  - Russell King.&n; *&n; * 2000/01/20   Fixed SMP locking on put_tty_queue using bits of &n; *&t;&t;the patch by Andrew J. Kroll &lt;ag784@freenet.buffalo.edu&gt;&n; *&t;&t;who actually finally proved there really was a race.&n; *&n; * 2002/03/18   Implemented n_tty_wakeup to send SIGIO POLL_OUTs to&n; *&t;&t;waiting writing processes-Sapan Bhatia &lt;sapan@corewars.org&gt;.&n; *&t;&t;Also fixed a bug in BLOCKING mode where write_chan returns&n; *&t;&t;EAGAIN&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
multiline_comment|/* number of characters left in xmit buffer before select has we have room */
DECL|macro|WAKEUP_CHARS
mdefine_line|#define WAKEUP_CHARS 256
multiline_comment|/*&n; * This defines the low- and high-watermarks for throttling and&n; * unthrottling the TTY driver.  These watermarks are used for&n; * controlling the space in the read buffer.&n; */
DECL|macro|TTY_THRESHOLD_THROTTLE
mdefine_line|#define TTY_THRESHOLD_THROTTLE&t;&t;128 /* now based on remaining room */
DECL|macro|TTY_THRESHOLD_UNTHROTTLE
mdefine_line|#define TTY_THRESHOLD_UNTHROTTLE &t;128
DECL|function|alloc_buf
r_static
r_inline
r_int
r_char
op_star
id|alloc_buf
c_func
(paren
r_void
)paren
(brace
r_int
id|prio
op_assign
id|in_interrupt
c_func
(paren
)paren
ques
c_cond
id|GFP_ATOMIC
suffix:colon
id|GFP_KERNEL
suffix:semicolon
r_if
c_cond
(paren
id|PAGE_SIZE
op_ne
id|N_TTY_BUF_SIZE
)paren
r_return
id|kmalloc
c_func
(paren
id|N_TTY_BUF_SIZE
comma
id|prio
)paren
suffix:semicolon
r_else
r_return
(paren
r_int
r_char
op_star
)paren
id|__get_free_page
c_func
(paren
id|prio
)paren
suffix:semicolon
)brace
DECL|function|free_buf
r_static
r_inline
r_void
id|free_buf
c_func
(paren
r_int
r_char
op_star
id|buf
)paren
(brace
r_if
c_cond
(paren
id|PAGE_SIZE
op_ne
id|N_TTY_BUF_SIZE
)paren
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
r_else
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|buf
)paren
suffix:semicolon
)brace
DECL|function|put_tty_queue_nolock
r_static
r_inline
r_void
id|put_tty_queue_nolock
c_func
(paren
r_int
r_char
id|c
comma
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;read_cnt
OL
id|N_TTY_BUF_SIZE
)paren
(brace
id|tty-&gt;read_buf
(braket
id|tty-&gt;read_head
)braket
op_assign
id|c
suffix:semicolon
id|tty-&gt;read_head
op_assign
(paren
id|tty-&gt;read_head
op_plus
l_int|1
)paren
op_amp
(paren
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|tty-&gt;read_cnt
op_increment
suffix:semicolon
)brace
)brace
DECL|function|put_tty_queue
r_static
r_inline
r_void
id|put_tty_queue
c_func
(paren
r_int
r_char
id|c
comma
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; *&t;The problem of stomping on the buffers ends here.&n;&t; *&t;Why didn&squot;t anyone see this one coming? --AJK&n;&t;*/
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
id|put_tty_queue_nolock
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;check_unthrottle&t;-&t;allow new receive data&n; *&t;@tty; tty device&n; *&n; *&t;Check whether to call the driver.unthrottle function.&n; *&t;We test the TTY_THROTTLED bit first so that it always&n; *&t;indicates the current state. The decision about whether&n; *&t;it is worth allowing more input has been taken by the caller.&n; *&t;Can sleep, may be called under the atomic_read semaphore but&n; *&t;this is not guaranteed.&n; */
DECL|function|check_unthrottle
r_static
r_void
id|check_unthrottle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;count
op_logical_and
id|test_and_clear_bit
c_func
(paren
id|TTY_THROTTLED
comma
op_amp
id|tty-&gt;flags
)paren
op_logical_and
id|tty-&gt;driver-&gt;unthrottle
)paren
id|tty-&gt;driver
op_member_access_from_pointer
id|unthrottle
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;reset_buffer_flags&t;-&t;reset buffer state&n; *&t;@tty: terminal to reset&n; *&n; *&t;Reset the read buffer counters, clear the flags, &n; *&t;and make sure the driver is unthrottled. Called&n; *&t;from n_tty_open() and n_tty_flush_buffer().&n; */
DECL|function|reset_buffer_flags
r_static
r_void
id|reset_buffer_flags
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
id|tty-&gt;read_head
op_assign
id|tty-&gt;read_tail
op_assign
id|tty-&gt;read_cnt
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
id|tty-&gt;canon_head
op_assign
id|tty-&gt;canon_data
op_assign
id|tty-&gt;erasing
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|tty-&gt;read_flags
comma
l_int|0
comma
r_sizeof
id|tty-&gt;read_flags
)paren
suffix:semicolon
id|check_unthrottle
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;n_tty_flush_buffer&t;-&t;clean input queue&n; *&t;@tty:&t;terminal device&n; *&n; *&t;Flush the input buffer. Called when the line discipline is&n; *&t;being closed, when the tty layer wants the buffer flushed (eg&n; *&t;at hangup) or when the N_TTY line discipline internally has to&n; *&t;clean the pending queue (for example some signals).&n; *&n; *&t;FIXME: tty-&gt;ctrl_status is not spinlocked and relies on&n; *&t;lock_kernel() still.&n; */
DECL|function|n_tty_flush_buffer
r_static
r_void
id|n_tty_flush_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
multiline_comment|/* clear everything and unthrottle the driver */
id|reset_buffer_flags
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;link
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;link-&gt;packet
)paren
(brace
id|tty-&gt;ctrl_status
op_or_assign
id|TIOCPKT_FLUSHREAD
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;link-&gt;read_wait
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;n_tty_chars_in_buffer&t;-&t;report available bytes&n; *&t;@tty: tty device&n; *&n; *&t;Report the number of characters buffered to be delivered to user&n; *&t;at this instant in time. &n; */
DECL|function|n_tty_chars_in_buffer
r_static
id|ssize_t
id|n_tty_chars_in_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|ssize_t
id|n
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;icanon
)paren
(brace
id|n
op_assign
id|tty-&gt;read_cnt
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tty-&gt;canon_data
)paren
(brace
id|n
op_assign
(paren
id|tty-&gt;canon_head
OG
id|tty-&gt;read_tail
)paren
ques
c_cond
id|tty-&gt;canon_head
op_minus
id|tty-&gt;read_tail
suffix:colon
id|tty-&gt;canon_head
op_plus
(paren
id|N_TTY_BUF_SIZE
op_minus
id|tty-&gt;read_tail
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;is_utf8_continuation&t;-&t;utf8 multibyte check&n; *&t;@c: byte to check&n; *&n; *&t;Returns true if the utf8 character &squot;c&squot; is a multibyte continuation&n; *&t;character. We use this to correctly compute the on screen size&n; *&t;of the character when printing&n; */
DECL|function|is_utf8_continuation
r_static
r_inline
r_int
id|is_utf8_continuation
c_func
(paren
r_int
r_char
id|c
)paren
(brace
r_return
(paren
id|c
op_amp
l_int|0xc0
)paren
op_eq
l_int|0x80
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;is_continuation&t;&t;-&t;multibyte check&n; *&t;@c: byte to check&n; *&n; *&t;Returns true if the utf8 character &squot;c&squot; is a multibyte continuation&n; *&t;character and the terminal is in unicode mode.&n; */
DECL|function|is_continuation
r_static
r_inline
r_int
id|is_continuation
c_func
(paren
r_int
r_char
id|c
comma
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_return
id|I_IUTF8
c_func
(paren
id|tty
)paren
op_logical_and
id|is_utf8_continuation
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;opost&t;&t;&t;-&t;output post processor&n; *&t;@c: character (or partial unicode symbol)&n; *&t;@tty: terminal device&n; *&n; *&t;Perform OPOST processing.  Returns -1 when the output device is&n; *&t;full and the character must be retried. Note that Linux currently&n; *&t;ignores TABDLY, CRDLY, VTDLY, FFDLY and NLDLY. They simply aren&squot;t&n; *&t;relevant in the world today. If you ever need them, add them here.&n; *&n; *&t;Called from both the receive and transmit sides and can be called&n; *&t;re-entrantly. Relies on lock_kernel() still.&n; */
DECL|function|opost
r_static
r_int
id|opost
c_func
(paren
r_int
r_char
id|c
comma
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_int
id|space
comma
id|spaces
suffix:semicolon
id|space
op_assign
id|tty-&gt;driver
op_member_access_from_pointer
id|write_room
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|space
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|O_OPOST
c_func
(paren
id|tty
)paren
)paren
(brace
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;&bslash;n&squot;
suffix:colon
r_if
c_cond
(paren
id|O_ONLRET
c_func
(paren
id|tty
)paren
)paren
id|tty-&gt;column
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|O_ONLCR
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|space
OL
l_int|2
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|tty-&gt;driver
op_member_access_from_pointer
id|put_char
c_func
(paren
id|tty
comma
l_char|&squot;&bslash;r&squot;
)paren
suffix:semicolon
id|tty-&gt;column
op_assign
l_int|0
suffix:semicolon
)brace
id|tty-&gt;canon_column
op_assign
id|tty-&gt;column
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&bslash;r&squot;
suffix:colon
r_if
c_cond
(paren
id|O_ONOCR
c_func
(paren
id|tty
)paren
op_logical_and
id|tty-&gt;column
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|O_OCRNL
c_func
(paren
id|tty
)paren
)paren
(brace
id|c
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
r_if
c_cond
(paren
id|O_ONLRET
c_func
(paren
id|tty
)paren
)paren
id|tty-&gt;canon_column
op_assign
id|tty-&gt;column
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tty-&gt;canon_column
op_assign
id|tty-&gt;column
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&bslash;t&squot;
suffix:colon
id|spaces
op_assign
l_int|8
op_minus
(paren
id|tty-&gt;column
op_amp
l_int|7
)paren
suffix:semicolon
r_if
c_cond
(paren
id|O_TABDLY
c_func
(paren
id|tty
)paren
op_eq
id|XTABS
)paren
(brace
r_if
c_cond
(paren
id|space
OL
id|spaces
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|tty-&gt;column
op_add_assign
id|spaces
suffix:semicolon
id|tty-&gt;driver
op_member_access_from_pointer
id|write
c_func
(paren
id|tty
comma
l_string|&quot;        &quot;
comma
id|spaces
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|tty-&gt;column
op_add_assign
id|spaces
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&bslash;b&squot;
suffix:colon
r_if
c_cond
(paren
id|tty-&gt;column
OG
l_int|0
)paren
id|tty-&gt;column
op_decrement
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|O_OLCUC
c_func
(paren
id|tty
)paren
)paren
id|c
op_assign
id|toupper
c_func
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|iscntrl
c_func
(paren
id|c
)paren
op_logical_and
op_logical_neg
id|is_continuation
c_func
(paren
id|c
comma
id|tty
)paren
)paren
id|tty-&gt;column
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|tty-&gt;driver
op_member_access_from_pointer
id|put_char
c_func
(paren
id|tty
comma
id|c
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;opost_block&t;&t;-&t;block postprocess&n; *&t;@tty: terminal device&n; *&t;@inbuf: user buffer&n; *&t;@nr: number of bytes&n; *&n; *&t;This path is used to speed up block console writes, among other&n; *&t;things when processing blocks of output data. It handles only&n; *&t;the simple cases normally found and helps to generate blocks of&n; *&t;symbols for the console driver and thus improve performance.&n; *&n; *&t;Called from write_chan under the tty layer write lock.&n; */
DECL|function|opost_block
r_static
id|ssize_t
id|opost_block
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
r_int
id|nr
)paren
(brace
r_int
id|space
suffix:semicolon
r_int
id|i
suffix:semicolon
r_const
r_int
r_char
op_star
id|cp
suffix:semicolon
id|space
op_assign
id|tty-&gt;driver
op_member_access_from_pointer
id|write_room
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|space
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|nr
OG
id|space
)paren
id|nr
op_assign
id|space
suffix:semicolon
r_if
c_cond
(paren
id|nr
OG
r_sizeof
(paren
id|buf
)paren
)paren
id|nr
op_assign
r_sizeof
(paren
id|buf
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|cp
op_assign
id|buf
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
comma
id|cp
op_increment
)paren
(brace
r_switch
c_cond
(paren
op_star
id|cp
)paren
(brace
r_case
l_char|&squot;&bslash;n&squot;
suffix:colon
r_if
c_cond
(paren
id|O_ONLRET
c_func
(paren
id|tty
)paren
)paren
id|tty-&gt;column
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|O_ONLCR
c_func
(paren
id|tty
)paren
)paren
r_goto
id|break_out
suffix:semicolon
id|tty-&gt;canon_column
op_assign
id|tty-&gt;column
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&bslash;r&squot;
suffix:colon
r_if
c_cond
(paren
id|O_ONOCR
c_func
(paren
id|tty
)paren
op_logical_and
id|tty-&gt;column
op_eq
l_int|0
)paren
r_goto
id|break_out
suffix:semicolon
r_if
c_cond
(paren
id|O_OCRNL
c_func
(paren
id|tty
)paren
)paren
r_goto
id|break_out
suffix:semicolon
id|tty-&gt;canon_column
op_assign
id|tty-&gt;column
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&bslash;t&squot;
suffix:colon
r_goto
id|break_out
suffix:semicolon
r_case
l_char|&squot;&bslash;b&squot;
suffix:colon
r_if
c_cond
(paren
id|tty-&gt;column
OG
l_int|0
)paren
id|tty-&gt;column
op_decrement
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|O_OLCUC
c_func
(paren
id|tty
)paren
)paren
r_goto
id|break_out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|iscntrl
c_func
(paren
op_star
id|cp
)paren
)paren
id|tty-&gt;column
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|break_out
suffix:colon
r_if
c_cond
(paren
id|tty-&gt;driver-&gt;flush_chars
)paren
id|tty-&gt;driver
op_member_access_from_pointer
id|flush_chars
c_func
(paren
id|tty
)paren
suffix:semicolon
id|i
op_assign
id|tty-&gt;driver
op_member_access_from_pointer
id|write
c_func
(paren
id|tty
comma
id|buf
comma
id|i
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;put_char&t;-&t;write character to driver&n; *&t;@c: character (or part of unicode symbol)&n; *&t;@tty: terminal device&n; *&n; *&t;Queue a byte to the driver layer for output&n; */
DECL|function|put_char
r_static
r_inline
r_void
id|put_char
c_func
(paren
r_int
r_char
id|c
comma
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|tty-&gt;driver
op_member_access_from_pointer
id|put_char
c_func
(paren
id|tty
comma
id|c
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;echo_char&t;-&t;echo characters&n; *&t;@c: unicode byte to echo&n; *&t;@tty: terminal device&n; *&n; *&t;Echo user input back onto the screen. This must be called only when &n; *&t;L_ECHO(tty) is true. Called from the driver receive_buf path.&n; */
DECL|function|echo_char
r_static
r_void
id|echo_char
c_func
(paren
r_int
r_char
id|c
comma
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_if
c_cond
(paren
id|L_ECHOCTL
c_func
(paren
id|tty
)paren
op_logical_and
id|iscntrl
c_func
(paren
id|c
)paren
op_logical_and
id|c
op_ne
l_char|&squot;&bslash;t&squot;
)paren
(brace
id|put_char
c_func
(paren
l_char|&squot;^&squot;
comma
id|tty
)paren
suffix:semicolon
id|put_char
c_func
(paren
id|c
op_xor
l_int|0100
comma
id|tty
)paren
suffix:semicolon
id|tty-&gt;column
op_add_assign
l_int|2
suffix:semicolon
)brace
r_else
id|opost
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
)brace
DECL|function|finish_erasing
r_static
r_inline
r_void
id|finish_erasing
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;erasing
)paren
(brace
id|put_char
c_func
(paren
l_char|&squot;/&squot;
comma
id|tty
)paren
suffix:semicolon
id|tty-&gt;column
op_increment
suffix:semicolon
id|tty-&gt;erasing
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;eraser&t;&t;-&t;handle erase function&n; *&t;@c: character input&n; *&t;@tty: terminal device&n; *&n; *&t;Perform erase and neccessary output when an erase character is&n; *&t;present in the stream from the driver layer. Handles the complexities&n; *&t;of UTF-8 multibyte symbols.&n; */
DECL|function|eraser
r_static
r_void
id|eraser
c_func
(paren
r_int
r_char
id|c
comma
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_enum
(brace
id|ERASE
comma
id|WERASE
comma
id|KILL
)brace
id|kill_type
suffix:semicolon
r_int
id|head
comma
id|seen_alnums
comma
id|cnt
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;read_head
op_eq
id|tty-&gt;canon_head
)paren
(brace
multiline_comment|/* opost(&squot;&bslash;a&squot;, tty); */
multiline_comment|/* what do you think? */
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
id|ERASE_CHAR
c_func
(paren
id|tty
)paren
)paren
id|kill_type
op_assign
id|ERASE
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
id|WERASE_CHAR
c_func
(paren
id|tty
)paren
)paren
id|kill_type
op_assign
id|WERASE
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|L_ECHO
c_func
(paren
id|tty
)paren
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
id|tty-&gt;read_cnt
op_sub_assign
(paren
(paren
id|tty-&gt;read_head
op_minus
id|tty-&gt;canon_head
)paren
op_amp
(paren
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|tty-&gt;read_head
op_assign
id|tty-&gt;canon_head
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|L_ECHOK
c_func
(paren
id|tty
)paren
op_logical_or
op_logical_neg
id|L_ECHOKE
c_func
(paren
id|tty
)paren
op_logical_or
op_logical_neg
id|L_ECHOE
c_func
(paren
id|tty
)paren
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
id|tty-&gt;read_cnt
op_sub_assign
(paren
(paren
id|tty-&gt;read_head
op_minus
id|tty-&gt;canon_head
)paren
op_amp
(paren
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|tty-&gt;read_head
op_assign
id|tty-&gt;canon_head
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
id|finish_erasing
c_func
(paren
id|tty
)paren
suffix:semicolon
id|echo_char
c_func
(paren
id|KILL_CHAR
c_func
(paren
id|tty
)paren
comma
id|tty
)paren
suffix:semicolon
multiline_comment|/* Add a newline if ECHOK is on and ECHOKE is off. */
r_if
c_cond
(paren
id|L_ECHOK
c_func
(paren
id|tty
)paren
)paren
id|opost
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|tty
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|kill_type
op_assign
id|KILL
suffix:semicolon
)brace
id|seen_alnums
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|tty-&gt;read_head
op_ne
id|tty-&gt;canon_head
)paren
(brace
id|head
op_assign
id|tty-&gt;read_head
suffix:semicolon
multiline_comment|/* erase a single possibly multibyte character */
r_do
(brace
id|head
op_assign
(paren
id|head
op_minus
l_int|1
)paren
op_amp
(paren
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|c
op_assign
id|tty-&gt;read_buf
(braket
id|head
)braket
suffix:semicolon
)brace
r_while
c_loop
(paren
id|is_continuation
c_func
(paren
id|c
comma
id|tty
)paren
op_logical_and
id|head
op_ne
id|tty-&gt;canon_head
)paren
suffix:semicolon
multiline_comment|/* do not partially erase */
r_if
c_cond
(paren
id|is_continuation
c_func
(paren
id|c
comma
id|tty
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|kill_type
op_eq
id|WERASE
)paren
(brace
multiline_comment|/* Equivalent to BSD&squot;s ALTWERASE. */
r_if
c_cond
(paren
id|isalnum
c_func
(paren
id|c
)paren
op_logical_or
id|c
op_eq
l_char|&squot;_&squot;
)paren
id|seen_alnums
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|seen_alnums
)paren
r_break
suffix:semicolon
)brace
id|cnt
op_assign
(paren
id|tty-&gt;read_head
op_minus
id|head
)paren
op_amp
(paren
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
id|tty-&gt;read_head
op_assign
id|head
suffix:semicolon
id|tty-&gt;read_cnt
op_sub_assign
id|cnt
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|L_ECHO
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|L_ECHOPRT
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;erasing
)paren
(brace
id|put_char
c_func
(paren
l_char|&squot;&bslash;&bslash;&squot;
comma
id|tty
)paren
suffix:semicolon
id|tty-&gt;column
op_increment
suffix:semicolon
id|tty-&gt;erasing
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* if cnt &gt; 1, output a multi-byte character */
id|echo_char
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|cnt
OG
l_int|0
)paren
(brace
id|head
op_assign
(paren
id|head
op_plus
l_int|1
)paren
op_amp
(paren
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|put_char
c_func
(paren
id|tty-&gt;read_buf
(braket
id|head
)braket
comma
id|tty
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|kill_type
op_eq
id|ERASE
op_logical_and
op_logical_neg
id|L_ECHOE
c_func
(paren
id|tty
)paren
)paren
(brace
id|echo_char
c_func
(paren
id|ERASE_CHAR
c_func
(paren
id|tty
)paren
comma
id|tty
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;t&squot;
)paren
(brace
r_int
r_int
id|col
op_assign
id|tty-&gt;canon_column
suffix:semicolon
r_int
r_int
id|tail
op_assign
id|tty-&gt;canon_head
suffix:semicolon
multiline_comment|/* Find the column of the last char. */
r_while
c_loop
(paren
id|tail
op_ne
id|tty-&gt;read_head
)paren
(brace
id|c
op_assign
id|tty-&gt;read_buf
(braket
id|tail
)braket
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|col
op_assign
(paren
id|col
op_or
l_int|7
)paren
op_plus
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|iscntrl
c_func
(paren
id|c
)paren
)paren
(brace
r_if
c_cond
(paren
id|L_ECHOCTL
c_func
(paren
id|tty
)paren
)paren
id|col
op_add_assign
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|is_continuation
c_func
(paren
id|c
comma
id|tty
)paren
)paren
id|col
op_increment
suffix:semicolon
id|tail
op_assign
(paren
id|tail
op_plus
l_int|1
)paren
op_amp
(paren
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* should never happen */
r_if
c_cond
(paren
id|tty-&gt;column
OG
l_int|0x80000000
)paren
id|tty-&gt;column
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Now backup to that column. */
r_while
c_loop
(paren
id|tty-&gt;column
OG
id|col
)paren
(brace
multiline_comment|/* Can&squot;t use opost here. */
id|put_char
c_func
(paren
l_char|&squot;&bslash;b&squot;
comma
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;column
OG
l_int|0
)paren
id|tty-&gt;column
op_decrement
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|iscntrl
c_func
(paren
id|c
)paren
op_logical_and
id|L_ECHOCTL
c_func
(paren
id|tty
)paren
)paren
(brace
id|put_char
c_func
(paren
l_char|&squot;&bslash;b&squot;
comma
id|tty
)paren
suffix:semicolon
id|put_char
c_func
(paren
l_char|&squot; &squot;
comma
id|tty
)paren
suffix:semicolon
id|put_char
c_func
(paren
l_char|&squot;&bslash;b&squot;
comma
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;column
OG
l_int|0
)paren
id|tty-&gt;column
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|iscntrl
c_func
(paren
id|c
)paren
op_logical_or
id|L_ECHOCTL
c_func
(paren
id|tty
)paren
)paren
(brace
id|put_char
c_func
(paren
l_char|&squot;&bslash;b&squot;
comma
id|tty
)paren
suffix:semicolon
id|put_char
c_func
(paren
l_char|&squot; &squot;
comma
id|tty
)paren
suffix:semicolon
id|put_char
c_func
(paren
l_char|&squot;&bslash;b&squot;
comma
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;column
OG
l_int|0
)paren
id|tty-&gt;column
op_decrement
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|kill_type
op_eq
id|ERASE
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;read_head
op_eq
id|tty-&gt;canon_head
)paren
id|finish_erasing
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;isig&t;&t;-&t;handle the ISIG optio&n; *&t;@sig: signal&n; *&t;@tty: terminal&n; *&t;@flush: force flush&n; *&n; *&t;Called when a signal is being sent due to terminal input. This&n; *&t;may caus terminal flushing to take place according to the termios&n; *&t;settings and character used. Called from the driver receive_buf&n; *&t;path so serialized.&n; */
DECL|function|isig
r_static
r_inline
r_void
id|isig
c_func
(paren
r_int
id|sig
comma
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|flush
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;pgrp
OG
l_int|0
)paren
id|kill_pg
c_func
(paren
id|tty-&gt;pgrp
comma
id|sig
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flush
op_logical_or
op_logical_neg
id|L_NOFLSH
c_func
(paren
id|tty
)paren
)paren
(brace
id|n_tty_flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver-&gt;flush_buffer
)paren
id|tty-&gt;driver
op_member_access_from_pointer
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;n_tty_receive_break&t;-&t;handle break&n; *&t;@tty: terminal&n; *&n; *&t;An RS232 break event has been hit in the incoming bitstream. This&n; *&t;can cause a variety of events depending upon the termios settings.&n; *&n; *&t;Called from the receive_buf path so single threaded.&n; */
DECL|function|n_tty_receive_break
r_static
r_inline
r_void
id|n_tty_receive_break
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_if
c_cond
(paren
id|I_IGNBRK
c_func
(paren
id|tty
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|I_BRKINT
c_func
(paren
id|tty
)paren
)paren
(brace
id|isig
c_func
(paren
id|SIGINT
comma
id|tty
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|I_PARMRK
c_func
(paren
id|tty
)paren
)paren
(brace
id|put_tty_queue
c_func
(paren
l_char|&squot;&bslash;377&squot;
comma
id|tty
)paren
suffix:semicolon
id|put_tty_queue
c_func
(paren
l_char|&squot;&bslash;0&squot;
comma
id|tty
)paren
suffix:semicolon
)brace
id|put_tty_queue
c_func
(paren
l_char|&squot;&bslash;0&squot;
comma
id|tty
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;read_wait
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;n_tty_receive_overrun&t;-&t;handle overrun reporting&n; *&t;@tty: terminal&n; *&n; *&t;Data arrived faster than we could process it. While the tty&n; *&t;driver has flagged this the bits that were missed are gone&n; *&t;forever.&n; *&n; *&t;Called from the receive_buf path so single threaded. Does not&n; *&t;need locking as num_overrun and overrun_time are function&n; *&t;private.&n; */
DECL|function|n_tty_receive_overrun
r_static
r_inline
r_void
id|n_tty_receive_overrun
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_char
id|buf
(braket
l_int|64
)braket
suffix:semicolon
id|tty-&gt;num_overrun
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|time_before
c_func
(paren
id|tty-&gt;overrun_time
comma
id|jiffies
op_minus
id|HZ
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: %d input overrun(s)&bslash;n&quot;
comma
id|tty_name
c_func
(paren
id|tty
comma
id|buf
)paren
comma
id|tty-&gt;num_overrun
)paren
suffix:semicolon
id|tty-&gt;overrun_time
op_assign
id|jiffies
suffix:semicolon
id|tty-&gt;num_overrun
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;n_tty_receive_parity_error&t;-&t;error notifier&n; *&t;@tty: terminal device&n; *&t;@c: character&n; *&n; *&t;Process a parity error and queue the right data to indicate&n; *&t;the error case if neccessary. Locking as per n_tty_receive_buf.&n; */
DECL|function|n_tty_receive_parity_error
r_static
r_inline
r_void
id|n_tty_receive_parity_error
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
r_char
id|c
)paren
(brace
r_if
c_cond
(paren
id|I_IGNPAR
c_func
(paren
id|tty
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|I_PARMRK
c_func
(paren
id|tty
)paren
)paren
(brace
id|put_tty_queue
c_func
(paren
l_char|&squot;&bslash;377&squot;
comma
id|tty
)paren
suffix:semicolon
id|put_tty_queue
c_func
(paren
l_char|&squot;&bslash;0&squot;
comma
id|tty
)paren
suffix:semicolon
id|put_tty_queue
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|I_INPCK
c_func
(paren
id|tty
)paren
)paren
id|put_tty_queue
c_func
(paren
l_char|&squot;&bslash;0&squot;
comma
id|tty
)paren
suffix:semicolon
r_else
id|put_tty_queue
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;read_wait
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;n_tty_receive_char&t;-&t;perform processing&n; *&t;@tty: terminal device&n; *&t;@c: character&n; *&n; *&t;Process an individual character of input received from the driver.&n; *&t;This is serialized with respect to itself by the rules for the &n; *&t;driver above.&n; */
DECL|function|n_tty_receive_char
r_static
r_inline
r_void
id|n_tty_receive_char
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
r_char
id|c
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;raw
)paren
(brace
id|put_tty_queue
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;stopped
op_logical_and
op_logical_neg
id|tty-&gt;flow_stopped
op_logical_and
id|I_IXON
c_func
(paren
id|tty
)paren
op_logical_and
id|I_IXANY
c_func
(paren
id|tty
)paren
)paren
(brace
id|start_tty
c_func
(paren
id|tty
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|I_ISTRIP
c_func
(paren
id|tty
)paren
)paren
id|c
op_and_assign
l_int|0x7f
suffix:semicolon
r_if
c_cond
(paren
id|I_IUCLC
c_func
(paren
id|tty
)paren
op_logical_and
id|L_IEXTEN
c_func
(paren
id|tty
)paren
)paren
id|c
op_assign
id|tolower
c_func
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;closing
)paren
(brace
r_if
c_cond
(paren
id|I_IXON
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|c
op_eq
id|START_CHAR
c_func
(paren
id|tty
)paren
)paren
id|start_tty
c_func
(paren
id|tty
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
id|STOP_CHAR
c_func
(paren
id|tty
)paren
)paren
id|stop_tty
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the previous character was LNEXT, or we know that this&n;&t; * character is not one of the characters that we&squot;ll have to&n;&t; * handle specially, do shortcut processing to speed things&n;&t; * up.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|c
comma
id|tty-&gt;process_char_map
)paren
op_logical_or
id|tty-&gt;lnext
)paren
(brace
id|finish_erasing
c_func
(paren
id|tty
)paren
suffix:semicolon
id|tty-&gt;lnext
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|L_ECHO
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;read_cnt
op_ge
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
(brace
id|put_char
c_func
(paren
l_char|&squot;&bslash;a&squot;
comma
id|tty
)paren
suffix:semicolon
multiline_comment|/* beep if no space */
r_return
suffix:semicolon
)brace
multiline_comment|/* Record the column of first canon char. */
r_if
c_cond
(paren
id|tty-&gt;canon_head
op_eq
id|tty-&gt;read_head
)paren
id|tty-&gt;canon_column
op_assign
id|tty-&gt;column
suffix:semicolon
id|echo_char
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|I_PARMRK
c_func
(paren
id|tty
)paren
op_logical_and
id|c
op_eq
(paren
r_int
r_char
)paren
l_char|&squot;&bslash;377&squot;
)paren
id|put_tty_queue
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
id|put_tty_queue
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;r&squot;
)paren
(brace
r_if
c_cond
(paren
id|I_IGNCR
c_func
(paren
id|tty
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|I_ICRNL
c_func
(paren
id|tty
)paren
)paren
id|c
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
op_logical_and
id|I_INLCR
c_func
(paren
id|tty
)paren
)paren
id|c
op_assign
l_char|&squot;&bslash;r&squot;
suffix:semicolon
r_if
c_cond
(paren
id|I_IXON
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|c
op_eq
id|START_CHAR
c_func
(paren
id|tty
)paren
)paren
(brace
id|start_tty
c_func
(paren
id|tty
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
id|STOP_CHAR
c_func
(paren
id|tty
)paren
)paren
(brace
id|stop_tty
c_func
(paren
id|tty
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|L_ISIG
c_func
(paren
id|tty
)paren
)paren
(brace
r_int
id|signal
suffix:semicolon
id|signal
op_assign
id|SIGINT
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
id|INTR_CHAR
c_func
(paren
id|tty
)paren
)paren
r_goto
id|send_signal
suffix:semicolon
id|signal
op_assign
id|SIGQUIT
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
id|QUIT_CHAR
c_func
(paren
id|tty
)paren
)paren
r_goto
id|send_signal
suffix:semicolon
id|signal
op_assign
id|SIGTSTP
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
id|SUSP_CHAR
c_func
(paren
id|tty
)paren
)paren
(brace
id|send_signal
suffix:colon
id|isig
c_func
(paren
id|signal
comma
id|tty
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tty-&gt;icanon
)paren
(brace
r_if
c_cond
(paren
id|c
op_eq
id|ERASE_CHAR
c_func
(paren
id|tty
)paren
op_logical_or
id|c
op_eq
id|KILL_CHAR
c_func
(paren
id|tty
)paren
op_logical_or
(paren
id|c
op_eq
id|WERASE_CHAR
c_func
(paren
id|tty
)paren
op_logical_and
id|L_IEXTEN
c_func
(paren
id|tty
)paren
)paren
)paren
(brace
id|eraser
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
id|LNEXT_CHAR
c_func
(paren
id|tty
)paren
op_logical_and
id|L_IEXTEN
c_func
(paren
id|tty
)paren
)paren
(brace
id|tty-&gt;lnext
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|L_ECHO
c_func
(paren
id|tty
)paren
)paren
(brace
id|finish_erasing
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|L_ECHOCTL
c_func
(paren
id|tty
)paren
)paren
(brace
id|put_char
c_func
(paren
l_char|&squot;^&squot;
comma
id|tty
)paren
suffix:semicolon
id|put_char
c_func
(paren
l_char|&squot;&bslash;b&squot;
comma
id|tty
)paren
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
id|REPRINT_CHAR
c_func
(paren
id|tty
)paren
op_logical_and
id|L_ECHO
c_func
(paren
id|tty
)paren
op_logical_and
id|L_IEXTEN
c_func
(paren
id|tty
)paren
)paren
(brace
r_int
r_int
id|tail
op_assign
id|tty-&gt;canon_head
suffix:semicolon
id|finish_erasing
c_func
(paren
id|tty
)paren
suffix:semicolon
id|echo_char
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
id|opost
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|tty
)paren
suffix:semicolon
r_while
c_loop
(paren
id|tail
op_ne
id|tty-&gt;read_head
)paren
(brace
id|echo_char
c_func
(paren
id|tty-&gt;read_buf
(braket
id|tail
)braket
comma
id|tty
)paren
suffix:semicolon
id|tail
op_assign
(paren
id|tail
op_plus
l_int|1
)paren
op_amp
(paren
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
r_if
c_cond
(paren
id|L_ECHO
c_func
(paren
id|tty
)paren
op_logical_or
id|L_ECHONL
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;read_cnt
op_ge
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
(brace
id|put_char
c_func
(paren
l_char|&squot;&bslash;a&squot;
comma
id|tty
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|opost
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|tty
)paren
suffix:semicolon
)brace
r_goto
id|handle_newline
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
id|EOF_CHAR
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;canon_head
op_ne
id|tty-&gt;read_head
)paren
id|set_bit
c_func
(paren
id|TTY_PUSH
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
id|c
op_assign
id|__DISABLED_CHAR
suffix:semicolon
r_goto
id|handle_newline
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|c
op_eq
id|EOL_CHAR
c_func
(paren
id|tty
)paren
)paren
op_logical_or
(paren
id|c
op_eq
id|EOL2_CHAR
c_func
(paren
id|tty
)paren
op_logical_and
id|L_IEXTEN
c_func
(paren
id|tty
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * XXX are EOL_CHAR and EOL2_CHAR echoed?!?&n;&t;&t;&t; */
r_if
c_cond
(paren
id|L_ECHO
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;read_cnt
op_ge
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
(brace
id|put_char
c_func
(paren
l_char|&squot;&bslash;a&squot;
comma
id|tty
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Record the column of first canon char. */
r_if
c_cond
(paren
id|tty-&gt;canon_head
op_eq
id|tty-&gt;read_head
)paren
id|tty-&gt;canon_column
op_assign
id|tty-&gt;column
suffix:semicolon
id|echo_char
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * XXX does PARMRK doubling happen for&n;&t;&t;&t; * EOL_CHAR and EOL2_CHAR?&n;&t;&t;&t; */
r_if
c_cond
(paren
id|I_PARMRK
c_func
(paren
id|tty
)paren
op_logical_and
id|c
op_eq
(paren
r_int
r_char
)paren
l_char|&squot;&bslash;377&squot;
)paren
id|put_tty_queue
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
id|handle_newline
suffix:colon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|tty-&gt;read_head
comma
id|tty-&gt;read_flags
)paren
suffix:semicolon
id|put_tty_queue_nolock
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
id|tty-&gt;canon_head
op_assign
id|tty-&gt;read_head
suffix:semicolon
id|tty-&gt;canon_data
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
id|kill_fasync
c_func
(paren
op_amp
id|tty-&gt;fasync
comma
id|SIGIO
comma
id|POLL_IN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|tty-&gt;read_wait
)paren
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;read_wait
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|finish_erasing
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|L_ECHO
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;read_cnt
op_ge
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
(brace
id|put_char
c_func
(paren
l_char|&squot;&bslash;a&squot;
comma
id|tty
)paren
suffix:semicolon
multiline_comment|/* beep if no space */
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|opost
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|tty
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/* Record the column of first canon char. */
r_if
c_cond
(paren
id|tty-&gt;canon_head
op_eq
id|tty-&gt;read_head
)paren
id|tty-&gt;canon_column
op_assign
id|tty-&gt;column
suffix:semicolon
id|echo_char
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|I_PARMRK
c_func
(paren
id|tty
)paren
op_logical_and
id|c
op_eq
(paren
r_int
r_char
)paren
l_char|&squot;&bslash;377&squot;
)paren
id|put_tty_queue
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
id|put_tty_queue
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;n_tty_receive_room&t;-&t;receive space&n; *&t;@tty: terminal&n; *&n; *&t;Called by the driver to find out how much data it is&n; *&t;permitted to feed to the line discipline without any being lost&n; *&t;and thus to manage flow control. Not serialized. Answers for the&n; *&t;&quot;instant&quot;.&n; */
DECL|function|n_tty_receive_room
r_static
r_int
id|n_tty_receive_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_int
id|left
op_assign
id|N_TTY_BUF_SIZE
op_minus
id|tty-&gt;read_cnt
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * If we are doing input canonicalization, and there are no&n;&t; * pending newlines, let characters through without limit, so&n;&t; * that erase characters will be handled.  Other excess&n;&t; * characters will be beeped.&n;&t; */
r_if
c_cond
(paren
id|tty-&gt;icanon
op_logical_and
op_logical_neg
id|tty-&gt;canon_data
)paren
r_return
id|N_TTY_BUF_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|left
OG
l_int|0
)paren
r_return
id|left
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;n_tty_write_wakeup&t;-&t;asynchronous I/O notifier&n; *&t;@tty: tty device&n; *&n; *&t;Required for the ptys, serial driver etc. since processes&n; *&t;that attach themselves to the master and rely on ASYNC&n; *&t;IO must be woken up&n; */
DECL|function|n_tty_write_wakeup
r_static
r_void
id|n_tty_write_wakeup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;fasync
)paren
(brace
id|set_bit
c_func
(paren
id|TTY_DO_WRITE_WAKEUP
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
id|kill_fasync
c_func
(paren
op_amp
id|tty-&gt;fasync
comma
id|SIGIO
comma
id|POLL_OUT
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;n_tty_receive_buf&t;-&t;data receive&n; *&t;@tty: terminal device&n; *&t;@cp: buffer&n; *&t;@fp: flag buffer&n; *&t;@count: characters&n; *&n; *&t;Called by the terminal driver when a block of characters has&n; *&t;been received. This function must be called from soft contexts&n; *&t;not from interrupt context. The driver is responsible for making&n; *&t;calls one at a time and in order (or using flush_to_ldisc)&n; */
DECL|function|n_tty_receive_buf
r_static
r_void
id|n_tty_receive_buf
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_const
r_int
r_char
op_star
id|cp
comma
r_char
op_star
id|fp
comma
r_int
id|count
)paren
(brace
r_const
r_int
r_char
op_star
id|p
suffix:semicolon
r_char
op_star
id|f
comma
id|flags
op_assign
id|TTY_NORMAL
suffix:semicolon
r_int
id|i
suffix:semicolon
r_char
id|buf
(braket
l_int|64
)braket
suffix:semicolon
r_int
r_int
id|cpuflags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;read_buf
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;real_raw
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|cpuflags
)paren
suffix:semicolon
id|i
op_assign
id|min
c_func
(paren
id|N_TTY_BUF_SIZE
op_minus
id|tty-&gt;read_cnt
comma
id|N_TTY_BUF_SIZE
op_minus
id|tty-&gt;read_head
)paren
suffix:semicolon
id|i
op_assign
id|min
c_func
(paren
id|count
comma
id|i
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|tty-&gt;read_buf
op_plus
id|tty-&gt;read_head
comma
id|cp
comma
id|i
)paren
suffix:semicolon
id|tty-&gt;read_head
op_assign
(paren
id|tty-&gt;read_head
op_plus
id|i
)paren
op_amp
(paren
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|tty-&gt;read_cnt
op_add_assign
id|i
suffix:semicolon
id|cp
op_add_assign
id|i
suffix:semicolon
id|count
op_sub_assign
id|i
suffix:semicolon
id|i
op_assign
id|min
c_func
(paren
id|N_TTY_BUF_SIZE
op_minus
id|tty-&gt;read_cnt
comma
id|N_TTY_BUF_SIZE
op_minus
id|tty-&gt;read_head
)paren
suffix:semicolon
id|i
op_assign
id|min
c_func
(paren
id|count
comma
id|i
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|tty-&gt;read_buf
op_plus
id|tty-&gt;read_head
comma
id|cp
comma
id|i
)paren
suffix:semicolon
id|tty-&gt;read_head
op_assign
(paren
id|tty-&gt;read_head
op_plus
id|i
)paren
op_amp
(paren
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|tty-&gt;read_cnt
op_add_assign
id|i
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|cpuflags
)paren
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
id|count
comma
id|p
op_assign
id|cp
comma
id|f
op_assign
id|fp
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
comma
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
id|f
)paren
id|flags
op_assign
op_star
id|f
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|flags
)paren
(brace
r_case
id|TTY_NORMAL
suffix:colon
id|n_tty_receive_char
c_func
(paren
id|tty
comma
op_star
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TTY_BREAK
suffix:colon
id|n_tty_receive_break
c_func
(paren
id|tty
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TTY_PARITY
suffix:colon
r_case
id|TTY_FRAME
suffix:colon
id|n_tty_receive_parity_error
c_func
(paren
id|tty
comma
op_star
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TTY_OVERRUN
suffix:colon
id|n_tty_receive_overrun
c_func
(paren
id|tty
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: unknown flag %d&bslash;n&quot;
comma
id|tty_name
c_func
(paren
id|tty
comma
id|buf
)paren
comma
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tty-&gt;driver-&gt;flush_chars
)paren
id|tty-&gt;driver
op_member_access_from_pointer
id|flush_chars
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;icanon
op_logical_and
(paren
id|tty-&gt;read_cnt
op_ge
id|tty-&gt;minimum_to_wake
)paren
)paren
(brace
id|kill_fasync
c_func
(paren
op_amp
id|tty-&gt;fasync
comma
id|SIGIO
comma
id|POLL_IN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|tty-&gt;read_wait
)paren
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;read_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check the remaining room for the input canonicalization&n;&t; * mode.  We don&squot;t want to throttle the driver if we&squot;re in&n;&t; * canonical mode and don&squot;t have a newline yet!&n;&t; */
r_if
c_cond
(paren
id|n_tty_receive_room
c_func
(paren
id|tty
)paren
OL
id|TTY_THRESHOLD_THROTTLE
)paren
(brace
multiline_comment|/* check TTY_THROTTLED first so it indicates our state */
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
id|TTY_THROTTLED
comma
op_amp
id|tty-&gt;flags
)paren
op_logical_and
id|tty-&gt;driver-&gt;throttle
)paren
id|tty-&gt;driver
op_member_access_from_pointer
id|throttle
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
)brace
DECL|function|is_ignored
r_int
id|is_ignored
c_func
(paren
r_int
id|sig
)paren
(brace
r_return
(paren
id|sigismember
c_func
(paren
op_amp
id|current-&gt;blocked
comma
id|sig
)paren
op_logical_or
id|current-&gt;sighand-&gt;action
(braket
id|sig
op_minus
l_int|1
)braket
dot
id|sa.sa_handler
op_eq
id|SIG_IGN
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;n_tty_set_termios&t;-&t;termios data changed&n; *&t;@tty: terminal&n; *&t;@old: previous data&n; *&n; *&t;Called by the tty layer when the user changes termios flags so&n; *&t;that the line discipline can plan ahead. This function cannot sleep&n; *&t;and is protected from re-entry by the tty layer. The user is &n; *&t;guaranteed that this function will not be re-entered or in progress&n; *&t;when the ldisc is closed.&n; */
DECL|function|n_tty_set_termios
r_static
r_void
id|n_tty_set_termios
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|termios
op_star
id|old
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
id|tty-&gt;icanon
op_assign
(paren
id|L_ICANON
c_func
(paren
id|tty
)paren
op_ne
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|TTY_HW_COOK_IN
comma
op_amp
id|tty-&gt;flags
)paren
)paren
(brace
id|tty-&gt;raw
op_assign
l_int|1
suffix:semicolon
id|tty-&gt;real_raw
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|I_ISTRIP
c_func
(paren
id|tty
)paren
op_logical_or
id|I_IUCLC
c_func
(paren
id|tty
)paren
op_logical_or
id|I_IGNCR
c_func
(paren
id|tty
)paren
op_logical_or
id|I_ICRNL
c_func
(paren
id|tty
)paren
op_logical_or
id|I_INLCR
c_func
(paren
id|tty
)paren
op_logical_or
id|L_ICANON
c_func
(paren
id|tty
)paren
op_logical_or
id|I_IXON
c_func
(paren
id|tty
)paren
op_logical_or
id|L_ISIG
c_func
(paren
id|tty
)paren
op_logical_or
id|L_ECHO
c_func
(paren
id|tty
)paren
op_logical_or
id|I_PARMRK
c_func
(paren
id|tty
)paren
)paren
(brace
id|memset
c_func
(paren
id|tty-&gt;process_char_map
comma
l_int|0
comma
l_int|256
op_div
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|I_IGNCR
c_func
(paren
id|tty
)paren
op_logical_or
id|I_ICRNL
c_func
(paren
id|tty
)paren
)paren
id|set_bit
c_func
(paren
l_char|&squot;&bslash;r&squot;
comma
id|tty-&gt;process_char_map
)paren
suffix:semicolon
r_if
c_cond
(paren
id|I_INLCR
c_func
(paren
id|tty
)paren
)paren
id|set_bit
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|tty-&gt;process_char_map
)paren
suffix:semicolon
r_if
c_cond
(paren
id|L_ICANON
c_func
(paren
id|tty
)paren
)paren
(brace
id|set_bit
c_func
(paren
id|ERASE_CHAR
c_func
(paren
id|tty
)paren
comma
id|tty-&gt;process_char_map
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|KILL_CHAR
c_func
(paren
id|tty
)paren
comma
id|tty-&gt;process_char_map
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|EOF_CHAR
c_func
(paren
id|tty
)paren
comma
id|tty-&gt;process_char_map
)paren
suffix:semicolon
id|set_bit
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|tty-&gt;process_char_map
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|EOL_CHAR
c_func
(paren
id|tty
)paren
comma
id|tty-&gt;process_char_map
)paren
suffix:semicolon
r_if
c_cond
(paren
id|L_IEXTEN
c_func
(paren
id|tty
)paren
)paren
(brace
id|set_bit
c_func
(paren
id|WERASE_CHAR
c_func
(paren
id|tty
)paren
comma
id|tty-&gt;process_char_map
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|LNEXT_CHAR
c_func
(paren
id|tty
)paren
comma
id|tty-&gt;process_char_map
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|EOL2_CHAR
c_func
(paren
id|tty
)paren
comma
id|tty-&gt;process_char_map
)paren
suffix:semicolon
r_if
c_cond
(paren
id|L_ECHO
c_func
(paren
id|tty
)paren
)paren
id|set_bit
c_func
(paren
id|REPRINT_CHAR
c_func
(paren
id|tty
)paren
comma
id|tty-&gt;process_char_map
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|I_IXON
c_func
(paren
id|tty
)paren
)paren
(brace
id|set_bit
c_func
(paren
id|START_CHAR
c_func
(paren
id|tty
)paren
comma
id|tty-&gt;process_char_map
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|STOP_CHAR
c_func
(paren
id|tty
)paren
comma
id|tty-&gt;process_char_map
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|L_ISIG
c_func
(paren
id|tty
)paren
)paren
(brace
id|set_bit
c_func
(paren
id|INTR_CHAR
c_func
(paren
id|tty
)paren
comma
id|tty-&gt;process_char_map
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|QUIT_CHAR
c_func
(paren
id|tty
)paren
comma
id|tty-&gt;process_char_map
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|SUSP_CHAR
c_func
(paren
id|tty
)paren
comma
id|tty-&gt;process_char_map
)paren
suffix:semicolon
)brace
id|clear_bit
c_func
(paren
id|__DISABLED_CHAR
comma
id|tty-&gt;process_char_map
)paren
suffix:semicolon
id|tty-&gt;raw
op_assign
l_int|0
suffix:semicolon
id|tty-&gt;real_raw
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|tty-&gt;raw
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|I_IGNBRK
c_func
(paren
id|tty
)paren
op_logical_or
(paren
op_logical_neg
id|I_BRKINT
c_func
(paren
id|tty
)paren
op_logical_and
op_logical_neg
id|I_PARMRK
c_func
(paren
id|tty
)paren
)paren
)paren
op_logical_and
(paren
id|I_IGNPAR
c_func
(paren
id|tty
)paren
op_logical_or
op_logical_neg
id|I_INPCK
c_func
(paren
id|tty
)paren
)paren
op_logical_and
(paren
id|tty-&gt;driver-&gt;flags
op_amp
id|TTY_DRIVER_REAL_RAW
)paren
)paren
id|tty-&gt;real_raw
op_assign
l_int|1
suffix:semicolon
r_else
id|tty-&gt;real_raw
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;n_tty_close&t;&t;-&t;close the ldisc for this tty&n; *&t;@tty: device&n; *&n; *&t;Called from the terminal layer when this line discipline is &n; *&t;being shut down, either because of a close or becsuse of a &n; *&t;discipline change. The function will not be called while other&n; *&t;ldisc methods are in progress.&n; */
DECL|function|n_tty_close
r_static
r_void
id|n_tty_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|n_tty_flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;read_buf
)paren
(brace
id|free_buf
c_func
(paren
id|tty-&gt;read_buf
)paren
suffix:semicolon
id|tty-&gt;read_buf
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;n_tty_open&t;&t;-&t;open an ldisc&n; *&t;@tty: terminal to open&n; *&n; *&t;Called when this line discipline is being attached to the &n; *&t;terminal device. Can sleep. Called serialized so that no&n; *&t;other events will occur in parallel. No further open will occur&n; *&t;until a close.&n; */
DECL|function|n_tty_open
r_static
r_int
id|n_tty_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* This one is ugly. Currently a malloc failure here can panic */
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;read_buf
)paren
(brace
id|tty-&gt;read_buf
op_assign
id|alloc_buf
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;read_buf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|tty-&gt;read_buf
comma
l_int|0
comma
id|N_TTY_BUF_SIZE
)paren
suffix:semicolon
id|reset_buffer_flags
c_func
(paren
id|tty
)paren
suffix:semicolon
id|tty-&gt;column
op_assign
l_int|0
suffix:semicolon
id|n_tty_set_termios
c_func
(paren
id|tty
comma
l_int|NULL
)paren
suffix:semicolon
id|tty-&gt;minimum_to_wake
op_assign
l_int|1
suffix:semicolon
id|tty-&gt;closing
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|input_available_p
r_static
r_inline
r_int
id|input_available_p
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|amt
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;icanon
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;canon_data
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tty-&gt;read_cnt
op_ge
(paren
id|amt
ques
c_cond
id|amt
suffix:colon
l_int|1
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * &t;copy_from_read_buf&t;-&t;copy read data directly&n; *&t;@tty: terminal device&n; *&t;@b: user data&n; *&t;@nr: size of data&n; *&n; *&t;Helper function to speed up read_chan.  It is only called when&n; *&t;ICANON is off; it copies characters straight from the tty queue to&n; *&t;user space directly.  It can be profitably called twice; once to&n; *&t;drain the space from the tail pointer to the (physical) end of the&n; *&t;buffer, and once to drain the space from the (physical) beginning of&n; *&t;the buffer to head pointer.&n; *&n; *&t;Called under the tty-&gt;atomic_read sem and with TTY_DONT_FLIP set&n; *&n; */
DECL|function|copy_from_read_buf
r_static
r_inline
r_int
id|copy_from_read_buf
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
r_char
id|__user
op_star
op_star
id|b
comma
r_int
op_star
id|nr
)paren
(brace
r_int
id|retval
suffix:semicolon
r_int
id|n
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
id|n
op_assign
id|min
c_func
(paren
id|tty-&gt;read_cnt
comma
id|N_TTY_BUF_SIZE
op_minus
id|tty-&gt;read_tail
)paren
suffix:semicolon
id|n
op_assign
id|min
c_func
(paren
op_star
id|nr
comma
id|n
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
)paren
(brace
id|mb
c_func
(paren
)paren
suffix:semicolon
id|retval
op_assign
id|copy_to_user
c_func
(paren
op_star
id|b
comma
op_amp
id|tty-&gt;read_buf
(braket
id|tty-&gt;read_tail
)braket
comma
id|n
)paren
suffix:semicolon
id|n
op_sub_assign
id|retval
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
id|tty-&gt;read_tail
op_assign
(paren
id|tty-&gt;read_tail
op_plus
id|n
)paren
op_amp
(paren
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|tty-&gt;read_cnt
op_sub_assign
id|n
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
op_star
id|b
op_add_assign
id|n
suffix:semicolon
op_star
id|nr
op_sub_assign
id|n
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
r_extern
id|ssize_t
id|redirected_tty_write
c_func
(paren
r_struct
id|file
op_star
comma
r_const
r_char
op_star
comma
r_int
comma
id|loff_t
op_star
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;job_control&t;&t;-&t;check job control&n; *&t;@tty: tty&n; *&t;@file: file handle&n; *&n; *&t;Perform job control management checks on this file/tty descriptor&n; *&t;and if appropriate send any needed signals and return a negative &n; *&t;error code if action should be taken.&n; */
DECL|function|job_control
r_static
r_int
id|job_control
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
)paren
(brace
multiline_comment|/* Job control check -- must be done at start and after&n;&t;   every sleep (POSIX.1 7.1.1.4). */
multiline_comment|/* NOTE: not yet done after every sleep pending a thorough&n;&t;   check of the logic of this change. -- jlc */
multiline_comment|/* don&squot;t stop on /dev/console */
r_if
c_cond
(paren
id|file-&gt;f_op-&gt;write
op_ne
id|redirected_tty_write
op_logical_and
id|current-&gt;signal-&gt;tty
op_eq
id|tty
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;pgrp
op_le
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;read_chan: tty-&gt;pgrp &lt;= 0!&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|process_group
c_func
(paren
id|current
)paren
op_ne
id|tty-&gt;pgrp
)paren
(brace
r_if
c_cond
(paren
id|is_ignored
c_func
(paren
id|SIGTTIN
)paren
op_logical_or
id|is_orphaned_pgrp
c_func
(paren
id|process_group
c_func
(paren
id|current
)paren
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|kill_pg
c_func
(paren
id|process_group
c_func
(paren
id|current
)paren
comma
id|SIGTTIN
comma
l_int|1
)paren
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;read_chan&t;&t;-&t;read function for tty&n; *&t;@tty: tty device&n; *&t;@file: file object&n; *&t;@buf: userspace buffer pointer&n; *&t;@nr: size of I/O&n; *&n; *&t;Perform reads for the line discipline. We are guaranteed that the&n; *&t;line discipline will not be closed under us but we may get multiple&n; *&t;parallel readers and must handle this ourselves. We may also get&n; *&t;a hangup. Always called in user context, may sleep.&n; *&n; *&t;This code must be sure never to sleep through a hangup.&n; */
DECL|function|read_chan
r_static
id|ssize_t
id|read_chan
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_char
id|__user
op_star
id|buf
comma
r_int
id|nr
)paren
(brace
r_int
r_char
id|__user
op_star
id|b
op_assign
id|buf
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_int
id|c
suffix:semicolon
r_int
id|minimum
comma
id|time
suffix:semicolon
id|ssize_t
id|retval
op_assign
l_int|0
suffix:semicolon
id|ssize_t
id|size
suffix:semicolon
r_int
id|timeout
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|do_it_again
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;read_buf
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;n_tty_read_chan: called with read_buf == NULL?!?&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|c
op_assign
id|job_control
c_func
(paren
id|tty
comma
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
OL
l_int|0
)paren
(brace
r_return
id|c
suffix:semicolon
)brace
id|minimum
op_assign
id|time
op_assign
l_int|0
suffix:semicolon
id|timeout
op_assign
id|MAX_SCHEDULE_TIMEOUT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;icanon
)paren
(brace
id|time
op_assign
(paren
id|HZ
op_div
l_int|10
)paren
op_star
id|TIME_CHAR
c_func
(paren
id|tty
)paren
suffix:semicolon
id|minimum
op_assign
id|MIN_CHAR
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|minimum
)paren
(brace
r_if
c_cond
(paren
id|time
)paren
id|tty-&gt;minimum_to_wake
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|waitqueue_active
c_func
(paren
op_amp
id|tty-&gt;read_wait
)paren
op_logical_or
(paren
id|tty-&gt;minimum_to_wake
OG
id|minimum
)paren
)paren
id|tty-&gt;minimum_to_wake
op_assign
id|minimum
suffix:semicolon
)brace
r_else
(brace
id|timeout
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|time
)paren
(brace
id|timeout
op_assign
id|time
suffix:semicolon
id|time
op_assign
l_int|0
suffix:semicolon
)brace
id|tty-&gt;minimum_to_wake
op_assign
id|minimum
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;Internal serialization of reads.&n;&t; */
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
r_if
c_cond
(paren
id|down_trylock
c_func
(paren
op_amp
id|tty-&gt;atomic_read
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|down_interruptible
c_func
(paren
op_amp
id|tty-&gt;atomic_read
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
id|add_wait_queue
c_func
(paren
op_amp
id|tty-&gt;read_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|TTY_DONT_FLIP
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
r_while
c_loop
(paren
id|nr
)paren
(brace
multiline_comment|/* First test for status change. */
r_if
c_cond
(paren
id|tty-&gt;packet
op_logical_and
id|tty-&gt;link-&gt;ctrl_status
)paren
(brace
r_int
r_char
id|cs
suffix:semicolon
r_if
c_cond
(paren
id|b
op_ne
id|buf
)paren
r_break
suffix:semicolon
id|cs
op_assign
id|tty-&gt;link-&gt;ctrl_status
suffix:semicolon
id|tty-&gt;link-&gt;ctrl_status
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|cs
comma
id|b
op_increment
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|b
op_decrement
suffix:semicolon
r_break
suffix:semicolon
)brace
id|nr
op_decrement
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* This statement must be first before checking for input&n;&t;&t;   so that any interrupt will set the state back to&n;&t;&t;   TASK_RUNNING. */
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|minimum
op_minus
(paren
id|b
op_minus
id|buf
)paren
)paren
OL
id|tty-&gt;minimum_to_wake
)paren
op_logical_and
(paren
(paren
id|minimum
op_minus
(paren
id|b
op_minus
id|buf
)paren
)paren
op_ge
l_int|1
)paren
)paren
id|tty-&gt;minimum_to_wake
op_assign
(paren
id|minimum
op_minus
(paren
id|b
op_minus
id|buf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|input_available_p
c_func
(paren
id|tty
comma
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|TTY_OTHER_CLOSED
comma
op_amp
id|tty-&gt;flags
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|file
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timeout
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|retval
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
id|clear_bit
c_func
(paren
id|TTY_DONT_FLIP
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
id|timeout
op_assign
id|schedule_timeout
c_func
(paren
id|timeout
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|TTY_DONT_FLIP
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
multiline_comment|/* Deal with packet mode. */
r_if
c_cond
(paren
id|tty-&gt;packet
op_logical_and
id|b
op_eq
id|buf
)paren
(brace
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|TIOCPKT_DATA
comma
id|b
op_increment
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|b
op_decrement
suffix:semicolon
r_break
suffix:semicolon
)brace
id|nr
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;icanon
)paren
(brace
multiline_comment|/* N.B. avoid overrun if nr == 0 */
r_while
c_loop
(paren
id|nr
op_logical_and
id|tty-&gt;read_cnt
)paren
(brace
r_int
id|eol
suffix:semicolon
id|eol
op_assign
id|test_and_clear_bit
c_func
(paren
id|tty-&gt;read_tail
comma
id|tty-&gt;read_flags
)paren
suffix:semicolon
id|c
op_assign
id|tty-&gt;read_buf
(braket
id|tty-&gt;read_tail
)braket
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
id|tty-&gt;read_tail
op_assign
(paren
(paren
id|tty-&gt;read_tail
op_plus
l_int|1
)paren
op_amp
(paren
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|tty-&gt;read_cnt
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|eol
)paren
(brace
multiline_comment|/* this test should be redundant:&n;&t;&t;&t;&t;&t; * we shouldn&squot;t be reading data if&n;&t;&t;&t;&t;&t; * canon_data is 0&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_decrement
id|tty-&gt;canon_data
OL
l_int|0
)paren
id|tty-&gt;canon_data
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|eol
op_logical_or
(paren
id|c
op_ne
id|__DISABLED_CHAR
)paren
)paren
(brace
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|c
comma
id|b
op_increment
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|b
op_decrement
suffix:semicolon
r_break
suffix:semicolon
)brace
id|nr
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|eol
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
)paren
r_break
suffix:semicolon
)brace
r_else
(brace
r_int
id|uncopied
suffix:semicolon
id|uncopied
op_assign
id|copy_from_read_buf
c_func
(paren
id|tty
comma
op_amp
id|b
comma
op_amp
id|nr
)paren
suffix:semicolon
id|uncopied
op_add_assign
id|copy_from_read_buf
c_func
(paren
id|tty
comma
op_amp
id|b
comma
op_amp
id|nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uncopied
)paren
(brace
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* If there is enough space in the read buffer now, let the&n;&t;&t; * low-level driver know. We use n_tty_chars_in_buffer() to&n;&t;&t; * check the buffer, as it now knows about canonical mode.&n;&t;&t; * Otherwise, if the driver is throttled and the line is&n;&t;&t; * longer than TTY_THRESHOLD_UNTHROTTLE in canonical mode,&n;&t;&t; * we won&squot;t get any more characters.&n;&t;&t; */
r_if
c_cond
(paren
id|n_tty_chars_in_buffer
c_func
(paren
id|tty
)paren
op_le
id|TTY_THRESHOLD_UNTHROTTLE
)paren
id|check_unthrottle
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|b
op_minus
id|buf
op_ge
id|minimum
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|time
)paren
id|timeout
op_assign
id|time
suffix:semicolon
)brace
id|clear_bit
c_func
(paren
id|TTY_DONT_FLIP
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|tty-&gt;atomic_read
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|tty-&gt;read_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|waitqueue_active
c_func
(paren
op_amp
id|tty-&gt;read_wait
)paren
)paren
id|tty-&gt;minimum_to_wake
op_assign
id|minimum
suffix:semicolon
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|size
op_assign
id|b
op_minus
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|size
)paren
(brace
id|retval
op_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|nr
)paren
id|clear_bit
c_func
(paren
id|TTY_PUSH
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|TTY_PUSH
comma
op_amp
id|tty-&gt;flags
)paren
)paren
r_goto
id|do_it_again
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;write_chan&t;&t;-&t;write function for tty&n; *&t;@tty: tty device&n; *&t;@file: file object&n; *&t;@buf: userspace buffer pointer&n; *&t;@nr: size of I/O&n; *&n; *&t;Write function of the terminal device. This is serialized with&n; *&t;respect to other write callers but not to termios changes, reads&n; *&t;and other such events. We must be careful with N_TTY as the receive&n; *&t;code will echo characters, thus calling driver write methods.&n; *&n; *&t;This code must be sure never to sleep through a hangup.&n; */
DECL|function|write_chan
r_static
id|ssize_t
id|write_chan
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|nr
)paren
(brace
r_const
r_int
r_char
op_star
id|b
op_assign
id|buf
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_int
id|c
suffix:semicolon
id|ssize_t
id|retval
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Job control check -- must be done at start (POSIX.1 7.1.1.4). */
r_if
c_cond
(paren
id|L_TOSTOP
c_func
(paren
id|tty
)paren
op_logical_and
id|file-&gt;f_op-&gt;write
op_ne
id|redirected_tty_write
)paren
(brace
id|retval
op_assign
id|tty_check_change
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
)brace
id|add_wait_queue
c_func
(paren
op_amp
id|tty-&gt;write_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|file
)paren
op_logical_or
(paren
id|tty-&gt;link
op_logical_and
op_logical_neg
id|tty-&gt;link-&gt;count
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|O_OPOST
c_func
(paren
id|tty
)paren
op_logical_and
op_logical_neg
(paren
id|test_bit
c_func
(paren
id|TTY_HW_COOK_OUT
comma
op_amp
id|tty-&gt;flags
)paren
)paren
)paren
(brace
r_while
c_loop
(paren
id|nr
OG
l_int|0
)paren
(brace
id|ssize_t
id|num
op_assign
id|opost_block
c_func
(paren
id|tty
comma
id|b
comma
id|nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|num
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|num
op_eq
op_minus
id|EAGAIN
)paren
r_break
suffix:semicolon
id|retval
op_assign
id|num
suffix:semicolon
r_goto
id|break_out
suffix:semicolon
)brace
id|b
op_add_assign
id|num
suffix:semicolon
id|nr
op_sub_assign
id|num
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|c
op_assign
op_star
id|b
suffix:semicolon
r_if
c_cond
(paren
id|opost
c_func
(paren
id|c
comma
id|tty
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
id|b
op_increment
suffix:semicolon
id|nr
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;driver-&gt;flush_chars
)paren
id|tty-&gt;driver
op_member_access_from_pointer
id|flush_chars
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
r_else
(brace
id|c
op_assign
id|tty-&gt;driver
op_member_access_from_pointer
id|write
c_func
(paren
id|tty
comma
id|b
comma
id|nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
OL
l_int|0
)paren
(brace
id|retval
op_assign
id|c
suffix:semicolon
r_goto
id|break_out
suffix:semicolon
)brace
id|b
op_add_assign
id|c
suffix:semicolon
id|nr
op_sub_assign
id|c
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|nr
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|retval
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_break
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|break_out
suffix:colon
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|tty-&gt;write_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_return
(paren
id|b
op_minus
id|buf
)paren
ques
c_cond
id|b
op_minus
id|buf
suffix:colon
id|retval
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;normal_poll&t;&t;-&t;poll method for N_TTY&n; *&t;@tty: terminal device&n; *&t;@file: file accessing it&n; *&t;@wait: poll table&n; *&n; *&t;Called when the line discipline is asked to poll() for data or&n; *&t;for special events. This code is not serialized with respect to&n; *&t;other events save open/close.&n; *&n; *&t;This code must be sure never to sleep through a hangup.&n; *&t;Called without the kernel lock held - fine&n; *&n; *&t;FIXME: if someone changes the VMIN or discipline settings for the&n; *&t;terminal while another process is in poll() the poll does not&n; *&t;recompute the new limits. Possibly set_termios should issue&n; *&t;a read wakeup to fix this bug.&n; */
DECL|function|normal_poll
r_static
r_int
r_int
id|normal_poll
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_int
r_int
id|mask
op_assign
l_int|0
suffix:semicolon
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|tty-&gt;read_wait
comma
id|wait
)paren
suffix:semicolon
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|tty-&gt;write_wait
comma
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|input_available_p
c_func
(paren
id|tty
comma
id|TIME_CHAR
c_func
(paren
id|tty
)paren
ques
c_cond
l_int|0
suffix:colon
id|MIN_CHAR
c_func
(paren
id|tty
)paren
)paren
)paren
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;packet
op_logical_and
id|tty-&gt;link-&gt;ctrl_status
)paren
id|mask
op_or_assign
id|POLLPRI
op_or
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|TTY_OTHER_CLOSED
comma
op_amp
id|tty-&gt;flags
)paren
)paren
id|mask
op_or_assign
id|POLLHUP
suffix:semicolon
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|file
)paren
)paren
id|mask
op_or_assign
id|POLLHUP
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|mask
op_amp
(paren
id|POLLHUP
op_or
id|POLLIN
op_or
id|POLLRDNORM
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|MIN_CHAR
c_func
(paren
id|tty
)paren
op_logical_and
op_logical_neg
id|TIME_CHAR
c_func
(paren
id|tty
)paren
)paren
id|tty-&gt;minimum_to_wake
op_assign
id|MIN_CHAR
c_func
(paren
id|tty
)paren
suffix:semicolon
r_else
id|tty-&gt;minimum_to_wake
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;driver
op_member_access_from_pointer
id|chars_in_buffer
c_func
(paren
id|tty
)paren
template_param
l_int|0
)paren
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
DECL|variable|tty_ldisc_N_TTY
r_struct
id|tty_ldisc
id|tty_ldisc_N_TTY
op_assign
(brace
id|TTY_LDISC_MAGIC
comma
multiline_comment|/* magic */
l_string|&quot;n_tty&quot;
comma
multiline_comment|/* name */
l_int|0
comma
multiline_comment|/* num */
l_int|0
comma
multiline_comment|/* flags */
id|n_tty_open
comma
multiline_comment|/* open */
id|n_tty_close
comma
multiline_comment|/* close */
id|n_tty_flush_buffer
comma
multiline_comment|/* flush_buffer */
id|n_tty_chars_in_buffer
comma
multiline_comment|/* chars_in_buffer */
id|read_chan
comma
multiline_comment|/* read */
id|write_chan
comma
multiline_comment|/* write */
id|n_tty_ioctl
comma
multiline_comment|/* ioctl */
id|n_tty_set_termios
comma
multiline_comment|/* set_termios */
id|normal_poll
comma
multiline_comment|/* poll */
l_int|NULL
comma
multiline_comment|/* hangup */
id|n_tty_receive_buf
comma
multiline_comment|/* receive_buf */
id|n_tty_receive_room
comma
multiline_comment|/* receive_room */
id|n_tty_write_wakeup
multiline_comment|/* write_wakeup */
)brace
suffix:semicolon
eof
