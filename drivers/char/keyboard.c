multiline_comment|/*&n; * linux/drivers/char/keyboard.c&n; *&n; * Written for linux by Johan Myreen as a translation from&n; * the assembly version by Linus (with diacriticals added)&n; *&n; * Some additional features added by Christoph Niemann (ChN), March 1993&n; *&n; * Loadable keymaps by Risto Kankkunen, May 1993&n; *&n; * Diacriticals redone &amp; other small changes, aeb@cwi.nl, June 1993&n; * Added decr/incr_console, dynamic keymaps, Unicode support,&n; * dynamic function/string keys, led setting,  Sept 1994&n; * `Sticky&squot; modifier keys, 951006.&n; *&n; * 11-11-96: SAK should now work in the raw mode (Martin Mares)&n; * &n; * Modified to provide &squot;generic&squot; keyboard support by Hamish Macdonald&n; * Merge with the m68k keyboard driver and split-off of the PC low-level&n; * parts by Geert Uytterhoeven, May 1997&n; *&n; * 27-05-97: Added support for the Magic SysRq Key (Martin Mares)&n; * 30-07-98: Dead keys redone, aeb@cwi.nl.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/tty_flip.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/random.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/keyboard.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;linux/console_struct.h&gt;
macro_line|#include &lt;linux/kbd_kern.h&gt;
macro_line|#include &lt;linux/kbd_diacr.h&gt;
macro_line|#include &lt;linux/vt_kern.h&gt;
macro_line|#include &lt;linux/kbd_ll.h&gt;
macro_line|#include &lt;linux/sysrq.h&gt;
macro_line|#include &lt;linux/pm.h&gt;
r_extern
r_void
id|ctrl_alt_del
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|macro|SIZE
mdefine_line|#define SIZE(x) (sizeof(x)/sizeof((x)[0]))
multiline_comment|/*&n; * Exported functions/variables&n; */
macro_line|#ifndef KBD_DEFMODE
DECL|macro|KBD_DEFMODE
mdefine_line|#define KBD_DEFMODE ((1 &lt;&lt; VC_REPEAT) | (1 &lt;&lt; VC_META))
macro_line|#endif
macro_line|#ifndef KBD_DEFLEDS
multiline_comment|/*&n; * Some laptops take the 789uiojklm,. keys as number pad when NumLock&n; * is on. This seems a good reason to start with NumLock off.&n; */
DECL|macro|KBD_DEFLEDS
mdefine_line|#define KBD_DEFLEDS 0
macro_line|#endif
macro_line|#ifndef KBD_DEFLOCK
DECL|macro|KBD_DEFLOCK
mdefine_line|#define KBD_DEFLOCK 0
macro_line|#endif
DECL|variable|kbd_ledfunc
r_void
(paren
op_star
id|kbd_ledfunc
)paren
(paren
r_int
r_int
id|led
)paren
suffix:semicolon
DECL|variable|handle_scancode
id|EXPORT_SYMBOL
c_func
(paren
id|handle_scancode
)paren
suffix:semicolon
DECL|variable|kbd_ledfunc
id|EXPORT_SYMBOL
c_func
(paren
id|kbd_ledfunc
)paren
suffix:semicolon
multiline_comment|/* kbd_pt_regs - set by keyboard_interrupt(), used by show_ptregs() */
DECL|variable|kbd_pt_regs
r_struct
id|pt_regs
op_star
id|kbd_pt_regs
suffix:semicolon
r_void
id|compute_shiftstate
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * Handler Tables.&n; */
multiline_comment|/* Key types processed even in raw modes */
DECL|macro|TYPES_ALLOWED_IN_RAW_MODE
mdefine_line|#define TYPES_ALLOWED_IN_RAW_MODE ((1 &lt;&lt; KT_SPEC) | (1 &lt;&lt; KT_SHIFT))
DECL|macro|SPECIALS_ALLOWED_IN_RAW_MODE
mdefine_line|#define SPECIALS_ALLOWED_IN_RAW_MODE (1 &lt;&lt; KVAL(K_SAK))
DECL|macro|K_HANDLERS
mdefine_line|#define K_HANDLERS&bslash;&n;&t;k_self,&t;&t;k_fn,&t;&t;k_spec,&t;&t;k_pad,&bslash;&n;&t;k_dead,&t;&t;k_cons,&t;&t;k_cur,&t;&t;k_shift,&bslash;&n;&t;k_meta,&t;&t;k_ascii,&t;k_lock,&t;&t;k_lowercase,&bslash;&n;&t;k_slock,&t;k_dead2,&t;k_ignore,&t;k_ignore&t;
DECL|typedef|k_handler_fn
r_typedef
r_void
(paren
id|k_handler_fn
)paren
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
suffix:semicolon
DECL|variable|K_HANDLERS
r_static
id|k_handler_fn
id|K_HANDLERS
suffix:semicolon
DECL|variable|k_handler
r_static
id|k_handler_fn
op_star
id|k_handler
(braket
l_int|16
)braket
op_assign
(brace
id|K_HANDLERS
)brace
suffix:semicolon
DECL|macro|FN_HANDLERS
mdefine_line|#define FN_HANDLERS&bslash;&n;&t;fn_null, &t;fn_enter,&t;fn_show_ptregs,&t;fn_show_mem,&bslash;&n;&t;fn_show_state,&t;fn_send_intr, &t;fn_lastcons, &t;fn_caps_toggle,&bslash;&n;&t;fn_num,&t;&t;fn_hold, &t;fn_scroll_forw,&t;fn_scroll_back,&bslash;&n;&t;fn_boot_it, &t;fn_caps_on, &t;fn_compose,&t;fn_SAK,&bslash;&n;&t;fn_dec_console, fn_inc_console, fn_spawn_con, &t;fn_bare_num
DECL|typedef|fn_handler_fn
r_typedef
r_void
(paren
id|fn_handler_fn
)paren
(paren
r_struct
id|vc_data
op_star
id|vc
)paren
suffix:semicolon
DECL|variable|FN_HANDLERS
r_static
id|fn_handler_fn
id|FN_HANDLERS
suffix:semicolon
DECL|variable|fn_handler
r_static
id|fn_handler_fn
op_star
id|fn_handler
(braket
)braket
op_assign
(brace
id|FN_HANDLERS
)brace
suffix:semicolon
multiline_comment|/*&n; * Variables/functions exported for vt.c&n; */
multiline_comment|/* maximum values each key_handler can handle */
DECL|variable|max_vals
r_const
r_int
id|max_vals
(braket
)braket
op_assign
(brace
l_int|255
comma
id|SIZE
c_func
(paren
id|func_table
)paren
op_minus
l_int|1
comma
id|SIZE
c_func
(paren
id|fn_handler
)paren
op_minus
l_int|1
comma
id|NR_PAD
op_minus
l_int|1
comma
id|NR_DEAD
op_minus
l_int|1
comma
l_int|255
comma
l_int|3
comma
id|NR_SHIFT
op_minus
l_int|1
comma
l_int|255
comma
id|NR_ASCII
op_minus
l_int|1
comma
id|NR_LOCK
op_minus
l_int|1
comma
l_int|255
comma
id|NR_LOCK
op_minus
l_int|1
comma
l_int|255
)brace
suffix:semicolon
DECL|variable|NR_TYPES
r_const
r_int
id|NR_TYPES
op_assign
id|SIZE
c_func
(paren
id|max_vals
)paren
suffix:semicolon
DECL|variable|spawnpid
DECL|variable|spawnsig
r_int
id|spawnpid
comma
id|spawnsig
suffix:semicolon
multiline_comment|/*&n; * Translation of escaped scancodes to keycodes.&n; * This is now user-settable (for machines were it makes sense).&n; */
DECL|function|getkeycode
r_int
id|getkeycode
c_func
(paren
r_int
r_int
id|scancode
)paren
(brace
r_return
id|kbd_getkeycode
c_func
(paren
id|scancode
)paren
suffix:semicolon
)brace
DECL|function|setkeycode
r_int
id|setkeycode
c_func
(paren
r_int
r_int
id|scancode
comma
r_int
r_int
id|keycode
)paren
(brace
r_return
id|kbd_setkeycode
c_func
(paren
id|scancode
comma
id|keycode
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Variables/function exported for console.c&n; */
DECL|variable|shift_state
r_int
id|shift_state
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Internal Data.&n; */
DECL|variable|key_down
r_static
r_int
r_int
id|key_down
(braket
l_int|256
op_div
id|BITS_PER_LONG
)braket
suffix:semicolon
multiline_comment|/* keyboard key bitmap */
DECL|variable|shift_down
r_static
r_int
r_char
id|shift_down
(braket
id|NR_SHIFT
)braket
suffix:semicolon
multiline_comment|/* shift state counters.. */
DECL|variable|dead_key_next
r_static
r_int
id|dead_key_next
suffix:semicolon
DECL|variable|npadch
r_static
r_int
id|npadch
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* -1 or number assembled on pad */
DECL|variable|diacr
r_static
r_int
r_char
id|diacr
suffix:semicolon
DECL|variable|rep
r_static
r_char
id|rep
suffix:semicolon
multiline_comment|/* flag telling character repeat */
DECL|variable|pm_kbd_request_override
id|pm_callback
id|pm_kbd_request_override
op_assign
l_int|NULL
suffix:semicolon
DECL|typedef|pm_kbd_func
r_typedef
r_void
(paren
id|pm_kbd_func
)paren
(paren
r_void
)paren
suffix:semicolon
DECL|variable|pm_kbd
r_static
r_struct
id|pm_dev
op_star
id|pm_kbd
suffix:semicolon
DECL|variable|ledstate
r_static
r_int
r_char
id|ledstate
op_assign
l_int|0xff
suffix:semicolon
multiline_comment|/* undefined */
DECL|variable|ledioctl
r_static
r_int
r_char
id|ledioctl
suffix:semicolon
DECL|struct|ledptr
r_static
r_struct
id|ledptr
(brace
DECL|member|addr
r_int
r_int
op_star
id|addr
suffix:semicolon
DECL|member|mask
r_int
r_int
id|mask
suffix:semicolon
DECL|member|valid
r_int
r_char
id|valid
suffix:colon
l_int|1
suffix:semicolon
DECL|variable|ledptrs
)brace
id|ledptrs
(braket
l_int|3
)braket
suffix:semicolon
DECL|variable|kbd_table
r_struct
id|kbd_struct
id|kbd_table
(braket
id|MAX_NR_CONSOLES
)braket
suffix:semicolon
DECL|variable|kbd
r_static
r_struct
id|kbd_struct
op_star
id|kbd
op_assign
id|kbd_table
suffix:semicolon
macro_line|#ifdef CONFIG_MAGIC_SYSRQ
DECL|variable|sysrq_pressed
r_static
r_int
id|sysrq_pressed
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Helper Functions.&n; */
DECL|function|put_queue
r_void
id|put_queue
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
id|ch
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|vc-&gt;vc_tty
suffix:semicolon
r_if
c_cond
(paren
id|tty
)paren
(brace
id|tty_insert_flip_char
c_func
(paren
id|tty
comma
id|ch
comma
l_int|0
)paren
suffix:semicolon
id|con_schedule_flip
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
)brace
DECL|function|puts_queue
r_static
r_void
id|puts_queue
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_char
op_star
id|cp
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|vc-&gt;vc_tty
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
op_star
id|cp
)paren
(brace
id|tty_insert_flip_char
c_func
(paren
id|tty
comma
op_star
id|cp
comma
l_int|0
)paren
suffix:semicolon
id|cp
op_increment
suffix:semicolon
)brace
id|con_schedule_flip
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
DECL|function|applkey
r_static
r_void
id|applkey
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
id|key
comma
r_char
id|mode
)paren
(brace
r_static
r_char
id|buf
(braket
)braket
op_assign
(brace
l_int|0x1b
comma
l_char|&squot;O&squot;
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_assign
(paren
id|mode
ques
c_cond
l_char|&squot;O&squot;
suffix:colon
l_char|&squot;[&squot;
)paren
suffix:semicolon
id|buf
(braket
l_int|2
)braket
op_assign
id|key
suffix:semicolon
id|puts_queue
c_func
(paren
id|vc
comma
id|buf
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Many other routines do put_queue, but I think either&n; * they produce ASCII, or they produce some user-assigned&n; * string, and in both cases we might assume that it is&n; * in utf-8 already. UTF-8 is defined for words of up to 31 bits,&n; * but we need only 16 bits here&n; */
DECL|function|to_utf8
r_void
id|to_utf8
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
id|ushort
id|c
)paren
(brace
r_if
c_cond
(paren
id|c
OL
l_int|0x80
)paren
multiline_comment|/*  0*******  */
id|put_queue
c_func
(paren
id|vc
comma
id|c
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
OL
l_int|0x800
)paren
(brace
multiline_comment|/*  110***** 10******  */
id|put_queue
c_func
(paren
id|vc
comma
l_int|0xc0
op_or
(paren
id|c
op_rshift
l_int|6
)paren
)paren
suffix:semicolon
id|put_queue
c_func
(paren
id|vc
comma
l_int|0x80
op_or
(paren
id|c
op_amp
l_int|0x3f
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*  1110**** 10****** 10*******/
id|put_queue
c_func
(paren
id|vc
comma
l_int|0xe0
op_or
(paren
id|c
op_rshift
l_int|12
)paren
)paren
suffix:semicolon
id|put_queue
c_func
(paren
id|vc
comma
l_int|0x80
op_or
(paren
(paren
id|c
op_rshift
l_int|6
)paren
op_amp
l_int|0x3f
)paren
)paren
suffix:semicolon
id|put_queue
c_func
(paren
id|vc
comma
l_int|0x80
op_or
(paren
id|c
op_amp
l_int|0x3f
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* called after returning from RAW mode or when changing consoles -&n;   recompute shift_down[] and shift_state from key_down[] */
multiline_comment|/* maybe called when keymap is undefined, so that shiftkey release is seen */
DECL|function|compute_shiftstate
r_void
id|compute_shiftstate
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|j
comma
id|k
comma
id|sym
comma
id|val
suffix:semicolon
id|shift_state
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|shift_down
comma
l_int|0
comma
r_sizeof
(paren
id|shift_down
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SIZE
c_func
(paren
id|key_down
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|key_down
(braket
id|i
)braket
)paren
r_continue
suffix:semicolon
id|k
op_assign
id|i
op_star
id|BITS_PER_LONG
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|BITS_PER_LONG
suffix:semicolon
id|j
op_increment
comma
id|k
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|k
comma
id|key_down
)paren
)paren
r_continue
suffix:semicolon
id|sym
op_assign
id|U
c_func
(paren
id|plain_map
(braket
id|k
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|KTYP
c_func
(paren
id|sym
)paren
op_ne
id|KT_SHIFT
op_logical_and
id|KTYP
c_func
(paren
id|sym
)paren
op_ne
id|KT_SLOCK
)paren
r_continue
suffix:semicolon
id|val
op_assign
id|KVAL
c_func
(paren
id|sym
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
op_eq
id|KVAL
c_func
(paren
id|K_CAPSSHIFT
)paren
)paren
id|val
op_assign
id|KVAL
c_func
(paren
id|K_SHIFT
)paren
suffix:semicolon
id|shift_down
(braket
id|val
)braket
op_increment
suffix:semicolon
id|shift_state
op_or_assign
(paren
l_int|1
op_lshift
id|val
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * We have a combining character DIACR here, followed by the character CH.&n; * If the combination occurs in the table, return the corresponding value.&n; * Otherwise, if CH is a space or equals DIACR, return DIACR.&n; * Otherwise, conclude that DIACR was not combining after all,&n; * queue it and return CH.&n; */
DECL|function|handle_diacr
r_int
r_char
id|handle_diacr
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_char
id|ch
)paren
(brace
r_int
id|d
op_assign
id|diacr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|diacr
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|accent_table_size
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|accent_table
(braket
id|i
)braket
dot
id|diacr
op_eq
id|d
op_logical_and
id|accent_table
(braket
id|i
)braket
dot
id|base
op_eq
id|ch
)paren
r_return
id|accent_table
(braket
id|i
)braket
dot
id|result
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot; &squot;
op_logical_or
id|ch
op_eq
id|d
)paren
r_return
id|d
suffix:semicolon
id|put_queue
c_func
(paren
id|vc
comma
id|d
)paren
suffix:semicolon
r_return
id|ch
suffix:semicolon
)brace
multiline_comment|/*&n; * Special function handlers&n; */
DECL|function|fn_enter
r_static
r_void
id|fn_enter
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
)paren
(brace
r_if
c_cond
(paren
id|diacr
)paren
(brace
id|put_queue
c_func
(paren
id|vc
comma
id|diacr
)paren
suffix:semicolon
id|diacr
op_assign
l_int|0
suffix:semicolon
)brace
id|put_queue
c_func
(paren
id|vc
comma
l_int|13
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_CRLF
)paren
)paren
id|put_queue
c_func
(paren
id|vc
comma
l_int|10
)paren
suffix:semicolon
)brace
DECL|function|fn_caps_toggle
r_static
r_void
id|fn_caps_toggle
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
)paren
(brace
r_if
c_cond
(paren
id|rep
)paren
r_return
suffix:semicolon
id|chg_vc_kbd_led
c_func
(paren
id|kbd
comma
id|VC_CAPSLOCK
)paren
suffix:semicolon
)brace
DECL|function|fn_caps_on
r_static
r_void
id|fn_caps_on
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
)paren
(brace
r_if
c_cond
(paren
id|rep
)paren
r_return
suffix:semicolon
id|set_vc_kbd_led
c_func
(paren
id|kbd
comma
id|VC_CAPSLOCK
)paren
suffix:semicolon
)brace
DECL|function|fn_show_ptregs
r_static
r_void
id|fn_show_ptregs
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
)paren
(brace
r_if
c_cond
(paren
id|kbd_pt_regs
)paren
id|show_regs
c_func
(paren
id|kbd_pt_regs
)paren
suffix:semicolon
)brace
DECL|function|fn_hold
r_static
r_void
id|fn_hold
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|vc-&gt;vc_tty
suffix:semicolon
r_if
c_cond
(paren
id|rep
op_logical_or
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Note: SCROLLOCK will be set (cleared) by stop_tty (start_tty);&n;&t; * these routines are also activated by ^S/^Q.&n;&t; * (And SCROLLOCK can also be set by the ioctl KDSKBLED.)&n;&t; */
r_if
c_cond
(paren
id|tty-&gt;stopped
)paren
id|start_tty
c_func
(paren
id|tty
)paren
suffix:semicolon
r_else
id|stop_tty
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
DECL|function|fn_num
r_static
r_void
id|fn_num
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
)paren
(brace
r_if
c_cond
(paren
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_APPLIC
)paren
)paren
id|applkey
c_func
(paren
id|vc
comma
l_char|&squot;P&squot;
comma
l_int|1
)paren
suffix:semicolon
r_else
id|fn_bare_num
c_func
(paren
id|vc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Bind this to Shift-NumLock if you work in application keypad mode&n; * but want to be able to change the NumLock flag.&n; * Bind this to NumLock if you prefer that the NumLock key always&n; * changes the NumLock flag.&n; */
DECL|function|fn_bare_num
r_static
r_void
id|fn_bare_num
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|rep
)paren
id|chg_vc_kbd_led
c_func
(paren
id|kbd
comma
id|VC_NUMLOCK
)paren
suffix:semicolon
)brace
DECL|function|fn_lastcons
r_static
r_void
id|fn_lastcons
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
)paren
(brace
multiline_comment|/* switch to the last used console, ChN */
id|set_console
c_func
(paren
id|last_console
)paren
suffix:semicolon
)brace
DECL|function|fn_dec_console
r_static
r_void
id|fn_dec_console
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|fg_console
op_minus
l_int|1
suffix:semicolon
id|i
op_ne
id|fg_console
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
op_minus
l_int|1
)paren
id|i
op_assign
id|MAX_NR_CONSOLES
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|vc_cons_allocated
c_func
(paren
id|i
)paren
)paren
r_break
suffix:semicolon
)brace
id|set_console
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
DECL|function|fn_inc_console
r_static
r_void
id|fn_inc_console
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|fg_console
op_plus
l_int|1
suffix:semicolon
id|i
op_ne
id|fg_console
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|MAX_NR_CONSOLES
)paren
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|vc_cons_allocated
c_func
(paren
id|i
)paren
)paren
r_break
suffix:semicolon
)brace
id|set_console
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
DECL|function|fn_send_intr
r_static
r_void
id|fn_send_intr
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|vc-&gt;vc_tty
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
id|tty_insert_flip_char
c_func
(paren
id|tty
comma
l_int|0
comma
id|TTY_BREAK
)paren
suffix:semicolon
id|con_schedule_flip
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
DECL|function|fn_scroll_forw
r_static
r_void
id|fn_scroll_forw
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
)paren
(brace
id|scrollfront
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|fn_scroll_back
r_static
r_void
id|fn_scroll_back
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
)paren
(brace
id|scrollback
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|fn_show_mem
r_static
r_void
id|fn_show_mem
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
)paren
(brace
id|show_mem
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|fn_show_state
r_static
r_void
id|fn_show_state
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
)paren
(brace
id|show_state
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|fn_boot_it
r_static
r_void
id|fn_boot_it
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
)paren
(brace
id|ctrl_alt_del
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|fn_compose
r_static
r_void
id|fn_compose
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
)paren
(brace
id|dead_key_next
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|fn_spawn_con
r_static
r_void
id|fn_spawn_con
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
)paren
(brace
r_if
c_cond
(paren
id|spawnpid
)paren
r_if
c_cond
(paren
id|kill_proc
c_func
(paren
id|spawnpid
comma
id|spawnsig
comma
l_int|1
)paren
)paren
(brace
id|spawnpid
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|fn_SAK
r_static
r_void
id|fn_SAK
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|vc-&gt;vc_tty
suffix:semicolon
multiline_comment|/*&n;&t; * SAK should also work in all raw modes and reset&n;&t; * them properly.&n;&t; */
r_if
c_cond
(paren
id|tty
)paren
id|do_SAK
c_func
(paren
id|tty
)paren
suffix:semicolon
id|reset_vc
c_func
(paren
id|fg_console
)paren
suffix:semicolon
macro_line|#if 0
id|do_unblank_screen
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* not in interrupt routine? */
macro_line|#endif
)brace
DECL|function|fn_null
r_static
r_void
id|fn_null
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
)paren
(brace
id|compute_shiftstate
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Special key handlers&n; */
DECL|function|k_ignore
r_static
r_void
id|k_ignore
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
)brace
DECL|function|k_spec
r_static
r_void
id|k_spec
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|value
op_ge
id|SIZE
c_func
(paren
id|fn_handler
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|kbd-&gt;kbdmode
op_eq
id|VC_RAW
op_logical_or
id|kbd-&gt;kbdmode
op_eq
id|VC_MEDIUMRAW
)paren
op_logical_and
op_logical_neg
(paren
id|SPECIALS_ALLOWED_IN_RAW_MODE
op_amp
(paren
l_int|1
op_lshift
id|value
)paren
)paren
)paren
r_return
suffix:semicolon
id|fn_handler
(braket
id|value
)braket
(paren
id|vc
)paren
suffix:semicolon
)brace
DECL|function|k_lowercase
r_static
r_void
id|k_lowercase
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;keyboard.c: do_lowercase was called - impossible&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|k_self
r_static
r_void
id|k_self
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
multiline_comment|/* no action, if this is a key release */
r_if
c_cond
(paren
id|diacr
)paren
id|value
op_assign
id|handle_diacr
c_func
(paren
id|vc
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dead_key_next
)paren
(brace
id|dead_key_next
op_assign
l_int|0
suffix:semicolon
id|diacr
op_assign
id|value
suffix:semicolon
r_return
suffix:semicolon
)brace
id|put_queue
c_func
(paren
id|vc
comma
id|value
)paren
suffix:semicolon
)brace
DECL|macro|A_GRAVE
mdefine_line|#define A_GRAVE  &squot;`&squot;
DECL|macro|A_ACUTE
mdefine_line|#define A_ACUTE  &squot;&bslash;&squot;&squot;
DECL|macro|A_CFLEX
mdefine_line|#define A_CFLEX  &squot;^&squot;
DECL|macro|A_TILDE
mdefine_line|#define A_TILDE  &squot;~&squot;
DECL|macro|A_DIAER
mdefine_line|#define A_DIAER  &squot;&quot;&squot;
DECL|macro|A_CEDIL
mdefine_line|#define A_CEDIL  &squot;,&squot;
DECL|variable|ret_diacr
r_static
r_int
r_char
id|ret_diacr
(braket
id|NR_DEAD
)braket
op_assign
(brace
id|A_GRAVE
comma
id|A_ACUTE
comma
id|A_CFLEX
comma
id|A_TILDE
comma
id|A_DIAER
comma
id|A_CEDIL
)brace
suffix:semicolon
multiline_comment|/* Obsolete - for backwards compatibility only */
DECL|function|k_dead
r_static
r_void
id|k_dead
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
id|value
op_assign
id|ret_diacr
(braket
id|value
)braket
suffix:semicolon
id|k_dead2
c_func
(paren
id|vc
comma
id|value
comma
id|up_flag
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Handle dead key. Note that we now may have several&n; * dead keys modifying the same character. Very useful&n; * for Vietnamese.&n; */
DECL|function|k_dead2
r_static
r_void
id|k_dead2
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
id|diacr
op_assign
(paren
id|diacr
ques
c_cond
id|handle_diacr
c_func
(paren
id|vc
comma
id|value
)paren
suffix:colon
id|value
)paren
suffix:semicolon
)brace
DECL|function|k_cons
r_static
r_void
id|k_cons
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
id|set_console
c_func
(paren
id|value
)paren
suffix:semicolon
)brace
DECL|function|k_fn
r_static
r_void
id|k_fn
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|value
OL
id|SIZE
c_func
(paren
id|func_table
)paren
)paren
(brace
r_if
c_cond
(paren
id|func_table
(braket
id|value
)braket
)paren
id|puts_queue
c_func
(paren
id|vc
comma
id|func_table
(braket
id|value
)braket
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;k_fn called with value=%d&bslash;n&quot;
comma
id|value
)paren
suffix:semicolon
)brace
DECL|function|k_pad
r_static
r_void
id|k_pad
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_static
r_const
r_char
op_star
id|pad_chars
op_assign
l_string|&quot;0123456789+-*/&bslash;015,.?()&quot;
suffix:semicolon
r_static
r_const
r_char
op_star
id|app_map
op_assign
l_string|&quot;pqrstuvwxylSRQMnnmPQ&quot;
suffix:semicolon
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
multiline_comment|/* no action, if this is a key release */
multiline_comment|/* kludge... shift forces cursor/number keys */
r_if
c_cond
(paren
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_APPLIC
)paren
op_logical_and
op_logical_neg
id|shift_down
(braket
id|KG_SHIFT
)braket
)paren
(brace
id|applkey
c_func
(paren
id|vc
comma
id|app_map
(braket
id|value
)braket
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|vc_kbd_led
c_func
(paren
id|kbd
comma
id|VC_NUMLOCK
)paren
)paren
r_switch
c_cond
(paren
id|value
)paren
(brace
r_case
id|KVAL
c_func
(paren
id|K_PCOMMA
)paren
suffix:colon
r_case
id|KVAL
c_func
(paren
id|K_PDOT
)paren
suffix:colon
id|k_fn
c_func
(paren
id|vc
comma
id|KVAL
c_func
(paren
id|K_REMOVE
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P0
)paren
suffix:colon
id|k_fn
c_func
(paren
id|vc
comma
id|KVAL
c_func
(paren
id|K_INSERT
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P1
)paren
suffix:colon
id|k_fn
c_func
(paren
id|vc
comma
id|KVAL
c_func
(paren
id|K_SELECT
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P2
)paren
suffix:colon
id|k_cur
c_func
(paren
id|vc
comma
id|KVAL
c_func
(paren
id|K_DOWN
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P3
)paren
suffix:colon
id|k_fn
c_func
(paren
id|vc
comma
id|KVAL
c_func
(paren
id|K_PGDN
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P4
)paren
suffix:colon
id|k_cur
c_func
(paren
id|vc
comma
id|KVAL
c_func
(paren
id|K_LEFT
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P6
)paren
suffix:colon
id|k_cur
c_func
(paren
id|vc
comma
id|KVAL
c_func
(paren
id|K_RIGHT
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P7
)paren
suffix:colon
id|k_fn
c_func
(paren
id|vc
comma
id|KVAL
c_func
(paren
id|K_FIND
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P8
)paren
suffix:colon
id|k_cur
c_func
(paren
id|vc
comma
id|KVAL
c_func
(paren
id|K_UP
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P9
)paren
suffix:colon
id|k_fn
c_func
(paren
id|vc
comma
id|KVAL
c_func
(paren
id|K_PGUP
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P5
)paren
suffix:colon
id|applkey
c_func
(paren
id|vc
comma
l_char|&squot;G&squot;
comma
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_APPLIC
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|put_queue
c_func
(paren
id|vc
comma
id|pad_chars
(braket
id|value
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_eq
id|KVAL
c_func
(paren
id|K_PENTER
)paren
op_logical_and
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_CRLF
)paren
)paren
id|put_queue
c_func
(paren
id|vc
comma
l_int|10
)paren
suffix:semicolon
)brace
DECL|function|k_cur
r_static
r_void
id|k_cur
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_static
r_const
r_char
op_star
id|cur_chars
op_assign
l_string|&quot;BDCA&quot;
suffix:semicolon
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
id|applkey
c_func
(paren
id|vc
comma
id|cur_chars
(braket
id|value
)braket
comma
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_CKMODE
)paren
)paren
suffix:semicolon
)brace
DECL|function|k_shift
r_static
r_void
id|k_shift
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_int
id|old_state
op_assign
id|shift_state
suffix:semicolon
r_if
c_cond
(paren
id|rep
)paren
r_return
suffix:semicolon
multiline_comment|/* Mimic typewriter:&n;&t;   a CapsShift key acts like Shift but undoes CapsLock */
r_if
c_cond
(paren
id|value
op_eq
id|KVAL
c_func
(paren
id|K_CAPSSHIFT
)paren
)paren
(brace
id|value
op_assign
id|KVAL
c_func
(paren
id|K_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|up_flag
)paren
id|clr_vc_kbd_led
c_func
(paren
id|kbd
comma
id|VC_CAPSLOCK
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|up_flag
)paren
(brace
multiline_comment|/* handle the case that two shift or control&n;&t;&t;   keys are depressed simultaneously */
r_if
c_cond
(paren
id|shift_down
(braket
id|value
)braket
)paren
id|shift_down
(braket
id|value
)braket
op_decrement
suffix:semicolon
)brace
r_else
id|shift_down
(braket
id|value
)braket
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|shift_down
(braket
id|value
)braket
)paren
id|shift_state
op_or_assign
(paren
l_int|1
op_lshift
id|value
)paren
suffix:semicolon
r_else
id|shift_state
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|value
)paren
suffix:semicolon
multiline_comment|/* kludge */
r_if
c_cond
(paren
id|up_flag
op_logical_and
id|shift_state
op_ne
id|old_state
op_logical_and
id|npadch
op_ne
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|kbd-&gt;kbdmode
op_eq
id|VC_UNICODE
)paren
id|to_utf8
c_func
(paren
id|vc
comma
id|npadch
op_amp
l_int|0xffff
)paren
suffix:semicolon
r_else
id|put_queue
c_func
(paren
id|vc
comma
id|npadch
op_amp
l_int|0xff
)paren
suffix:semicolon
id|npadch
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|k_meta
r_static
r_void
id|k_meta
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_META
)paren
)paren
(brace
id|put_queue
c_func
(paren
id|vc
comma
l_char|&squot;&bslash;033&squot;
)paren
suffix:semicolon
id|put_queue
c_func
(paren
id|vc
comma
id|value
)paren
suffix:semicolon
)brace
r_else
id|put_queue
c_func
(paren
id|vc
comma
id|value
op_or
l_int|0x80
)paren
suffix:semicolon
)brace
DECL|function|k_ascii
r_static
r_void
id|k_ascii
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_int
id|base
suffix:semicolon
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|value
OL
l_int|10
)paren
multiline_comment|/* decimal input of code, while Alt depressed */
id|base
op_assign
l_int|10
suffix:semicolon
r_else
(brace
multiline_comment|/* hexadecimal input of code, while AltGr depressed */
id|value
op_sub_assign
l_int|10
suffix:semicolon
id|base
op_assign
l_int|16
suffix:semicolon
)brace
r_if
c_cond
(paren
id|npadch
op_eq
op_minus
l_int|1
)paren
id|npadch
op_assign
id|value
suffix:semicolon
r_else
id|npadch
op_assign
id|npadch
op_star
id|base
op_plus
id|value
suffix:semicolon
)brace
DECL|function|k_lock
r_static
r_void
id|k_lock
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_if
c_cond
(paren
id|up_flag
op_logical_or
id|rep
)paren
r_return
suffix:semicolon
id|chg_vc_kbd_lock
c_func
(paren
id|kbd
comma
id|value
)paren
suffix:semicolon
)brace
DECL|function|k_slock
r_static
r_void
id|k_slock
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
id|k_shift
c_func
(paren
id|vc
comma
id|value
comma
id|up_flag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|up_flag
op_logical_or
id|rep
)paren
r_return
suffix:semicolon
id|chg_vc_kbd_slock
c_func
(paren
id|kbd
comma
id|value
)paren
suffix:semicolon
multiline_comment|/* try to make Alt, oops, AltGr and such work */
r_if
c_cond
(paren
op_logical_neg
id|key_maps
(braket
id|kbd-&gt;lockstate
op_xor
id|kbd-&gt;slockstate
)braket
)paren
(brace
id|kbd-&gt;slockstate
op_assign
l_int|0
suffix:semicolon
id|chg_vc_kbd_slock
c_func
(paren
id|kbd
comma
id|value
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * The leds display either (i) the status of NumLock, CapsLock, ScrollLock,&n; * or (ii) whatever pattern of lights people want to show using KDSETLED,&n; * or (iii) specified bits of specified words in kernel memory.&n; */
DECL|function|getledstate
r_int
r_char
id|getledstate
c_func
(paren
r_void
)paren
(brace
r_return
id|ledstate
suffix:semicolon
)brace
DECL|function|setledstate
r_void
id|setledstate
c_func
(paren
r_struct
id|kbd_struct
op_star
id|kbd
comma
r_int
r_int
id|led
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|led
op_amp
op_complement
l_int|7
)paren
)paren
(brace
id|ledioctl
op_assign
id|led
suffix:semicolon
id|kbd-&gt;ledmode
op_assign
id|LED_SHOW_IOCTL
suffix:semicolon
)brace
r_else
id|kbd-&gt;ledmode
op_assign
id|LED_SHOW_FLAGS
suffix:semicolon
id|set_leds
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|register_leds
r_void
id|register_leds
c_func
(paren
r_int
id|console
comma
r_int
r_int
id|led
comma
r_int
r_int
op_star
id|addr
comma
r_int
r_int
id|mask
)paren
(brace
r_struct
id|kbd_struct
op_star
id|kbd
op_assign
id|kbd_table
op_plus
id|console
suffix:semicolon
r_if
c_cond
(paren
id|led
OL
l_int|3
)paren
(brace
id|ledptrs
(braket
id|led
)braket
dot
id|addr
op_assign
id|addr
suffix:semicolon
id|ledptrs
(braket
id|led
)braket
dot
id|mask
op_assign
id|mask
suffix:semicolon
id|ledptrs
(braket
id|led
)braket
dot
id|valid
op_assign
l_int|1
suffix:semicolon
id|kbd-&gt;ledmode
op_assign
id|LED_SHOW_MEM
suffix:semicolon
)brace
r_else
id|kbd-&gt;ledmode
op_assign
id|LED_SHOW_FLAGS
suffix:semicolon
)brace
DECL|function|getleds
r_static
r_inline
r_int
r_char
(def_block
id|getleds
c_func
(paren
r_void
)paren
(brace
r_struct
id|kbd_struct
op_star
id|kbd
op_assign
id|kbd_table
op_plus
id|fg_console
suffix:semicolon
r_int
r_char
id|leds
suffix:semicolon
r_if
c_cond
(paren
id|kbd-&gt;ledmode
op_eq
id|LED_SHOW_IOCTL
)paren
r_return
id|ledioctl
suffix:semicolon
id|leds
op_assign
id|kbd-&gt;ledflagstate
suffix:semicolon
r_if
c_cond
(paren
id|kbd-&gt;ledmode
op_eq
id|LED_SHOW_MEM
)paren
(brace
r_if
c_cond
(paren
id|ledptrs
(braket
l_int|0
)braket
dot
id|valid
)paren
(brace
r_if
c_cond
(paren
op_star
id|ledptrs
(braket
l_int|0
)braket
dot
id|addr
op_amp
id|ledptrs
(braket
l_int|0
)braket
dot
id|mask
)paren
id|leds
op_or_assign
l_int|1
suffix:semicolon
r_else
id|leds
op_and_assign
op_complement
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ledptrs
(braket
l_int|1
)braket
dot
id|valid
)paren
(brace
r_if
c_cond
(paren
op_star
id|ledptrs
(braket
l_int|1
)braket
dot
id|addr
op_amp
id|ledptrs
(braket
l_int|1
)braket
dot
id|mask
)paren
id|leds
op_or_assign
l_int|2
suffix:semicolon
r_else
id|leds
op_and_assign
op_complement
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ledptrs
(braket
l_int|2
)braket
dot
id|valid
)paren
(brace
r_if
c_cond
(paren
op_star
id|ledptrs
(braket
l_int|2
)braket
dot
id|addr
op_amp
id|ledptrs
(braket
l_int|2
)braket
dot
id|mask
)paren
id|leds
op_or_assign
l_int|4
suffix:semicolon
r_else
id|leds
op_and_assign
op_complement
l_int|4
suffix:semicolon
)brace
)brace
r_return
id|leds
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * This routine is the bottom half of the keyboard interrupt&n; * routine, and runs with all interrupts enabled. It does&n; * console changing, led setting and copy_to_cooked, which can&n; * take a reasonably long time.&n; *&n; * Aside from timing (which isn&squot;t really that important for&n; * keyboard interrupts as they happen often), using the software&n; * interrupt routines for this thing allows us to easily mask&n; * this when we don&squot;t want any of the above to happen. Not yet&n; * used, but this allows for easy and efficient race-condition&n; * prevention later on.&n; */
DECL|function|kbd_bh
r_static
r_void
id|kbd_bh
c_func
(paren
r_int
r_int
id|dummy
)paren
(brace
r_int
r_char
id|leds
op_assign
id|getleds
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|leds
op_ne
id|ledstate
)paren
(brace
id|ledstate
op_assign
id|leds
suffix:semicolon
id|kbd_leds
c_func
(paren
id|leds
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kbd_ledfunc
)paren
id|kbd_ledfunc
c_func
(paren
id|leds
)paren
suffix:semicolon
)brace
)brace
DECL|variable|keyboard_tasklet
id|EXPORT_SYMBOL
c_func
(paren
id|keyboard_tasklet
)paren
suffix:semicolon
id|DECLARE_TASKLET_DISABLED
c_func
(paren
id|keyboard_tasklet
comma
id|kbd_bh
comma
l_int|0
)paren
suffix:semicolon
DECL|function|handle_scancode
r_void
id|handle_scancode
c_func
(paren
r_int
r_char
id|scancode
comma
r_int
id|down
)paren
(brace
r_struct
id|vc_data
op_star
id|vc
op_assign
id|vc_cons
(braket
id|fg_console
)braket
dot
id|d
suffix:semicolon
r_char
id|up_flag
op_assign
id|down
ques
c_cond
l_int|0
suffix:colon
l_int|0200
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_int
r_char
id|keycode
suffix:semicolon
r_char
id|raw_mode
suffix:semicolon
id|pm_access
c_func
(paren
id|pm_kbd
)paren
suffix:semicolon
id|add_keyboard_randomness
c_func
(paren
id|scancode
op_or
id|up_flag
)paren
suffix:semicolon
id|tty
op_assign
id|vc-&gt;vc_tty
suffix:semicolon
r_if
c_cond
(paren
id|tty
op_logical_and
(paren
op_logical_neg
id|tty-&gt;driver_data
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * We touch the tty structure via the ttytab array&n;&t;&t; * without knowing whether or not tty is open, which&n;&t;&t; * is inherently dangerous.  We currently rely on that&n;&t;&t; * fact that console_open sets tty-&gt;driver_data when&n;&t;&t; * it opens it, and clears it when it closes it.&n;&t;&t; */
id|tty
op_assign
l_int|NULL
suffix:semicolon
)brace
id|kbd
op_assign
id|kbd_table
op_plus
id|fg_console
suffix:semicolon
r_if
c_cond
(paren
(paren
id|raw_mode
op_assign
(paren
id|kbd-&gt;kbdmode
op_eq
id|VC_RAW
)paren
)paren
)paren
(brace
id|put_queue
c_func
(paren
id|vc
comma
id|scancode
op_or
id|up_flag
)paren
suffix:semicolon
multiline_comment|/* we do not return yet, because we want to maintain&n;&t;&t;   the key_down array, so that we have the correct&n;&t;&t;   values when finishing RAW mode or when changing VT&squot;s */
)brace
multiline_comment|/*&n;&t; *  Convert scancode to keycode&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|kbd_translate
c_func
(paren
id|scancode
comma
op_amp
id|keycode
comma
id|raw_mode
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * At this point the variable `keycode&squot; contains the keycode.&n;&t; * Note: the keycode must not be 0 (++Geert: on m68k 0 is valid).&n;&t; * We keep track of the up/down status of the key, and&n;&t; * return the keycode if in MEDIUMRAW mode.&n;&t; */
r_if
c_cond
(paren
id|up_flag
)paren
(brace
id|rep
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_and_clear_bit
c_func
(paren
id|keycode
comma
id|key_down
)paren
)paren
(brace
id|up_flag
op_assign
id|kbd_unexpected_up
c_func
(paren
id|keycode
)paren
suffix:semicolon
)brace
)brace
r_else
id|rep
op_assign
id|test_and_set_bit
c_func
(paren
id|keycode
comma
id|key_down
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MAGIC_SYSRQ&t;&t;/* Handle the SysRq Hack */
r_if
c_cond
(paren
id|keycode
op_eq
id|SYSRQ_KEY
)paren
(brace
id|sysrq_pressed
op_assign
op_logical_neg
id|up_flag
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sysrq_pressed
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|up_flag
)paren
(brace
id|handle_sysrq
c_func
(paren
id|kbd_sysrq_xlate
(braket
id|keycode
)braket
comma
id|kbd_pt_regs
comma
id|tty
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
id|kbd-&gt;kbdmode
op_eq
id|VC_MEDIUMRAW
)paren
(brace
multiline_comment|/* soon keycodes will require more than one byte */
id|put_queue
c_func
(paren
id|vc
comma
id|keycode
op_plus
id|up_flag
)paren
suffix:semicolon
id|raw_mode
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Most key classes will be ignored */
)brace
multiline_comment|/*&n;&t; * Small change in philosophy: earlier we defined repetition by&n;&t; *&t; rep = keycode == prev_keycode;&n;&t; *&t; prev_keycode = keycode;&n;&t; * but now by the fact that the depressed key was down already.&n;&t; * Does this ever make a difference? Yes.&n;&t; */
multiline_comment|/*&n;&t; *  Repeat a key only if the input buffers are empty or the&n;&t; *  characters get echoed locally. This makes key repeat usable&n;&t; *  with slow applications and under heavy loads.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|rep
op_logical_or
(paren
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_REPEAT
)paren
op_logical_and
id|tty
op_logical_and
(paren
id|L_ECHO
c_func
(paren
id|tty
)paren
op_logical_or
(paren
id|tty-&gt;driver
dot
id|chars_in_buffer
c_func
(paren
id|tty
)paren
op_eq
l_int|0
)paren
)paren
)paren
)paren
(brace
id|u_short
id|keysym
suffix:semicolon
id|u_char
id|type
suffix:semicolon
multiline_comment|/* the XOR below used to be an OR */
r_int
id|shift_final
op_assign
(paren
id|shift_state
op_or
id|kbd-&gt;slockstate
)paren
op_xor
id|kbd-&gt;lockstate
suffix:semicolon
id|ushort
op_star
id|key_map
op_assign
id|key_maps
(braket
id|shift_final
)braket
suffix:semicolon
r_if
c_cond
(paren
id|key_map
op_ne
l_int|NULL
)paren
(brace
id|keysym
op_assign
id|key_map
(braket
id|keycode
)braket
suffix:semicolon
id|type
op_assign
id|KTYP
c_func
(paren
id|keysym
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
l_int|0xf0
)paren
(brace
id|type
op_sub_assign
l_int|0xf0
suffix:semicolon
r_if
c_cond
(paren
id|raw_mode
op_logical_and
op_logical_neg
(paren
id|TYPES_ALLOWED_IN_RAW_MODE
op_amp
(paren
l_int|1
op_lshift
id|type
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|KT_LETTER
)paren
(brace
id|type
op_assign
id|KT_LATIN
suffix:semicolon
r_if
c_cond
(paren
id|vc_kbd_led
c_func
(paren
id|kbd
comma
id|VC_CAPSLOCK
)paren
)paren
(brace
id|key_map
op_assign
id|key_maps
(braket
id|shift_final
op_xor
(paren
l_int|1
op_lshift
id|KG_SHIFT
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|key_map
)paren
id|keysym
op_assign
id|key_map
(braket
id|keycode
)braket
suffix:semicolon
)brace
)brace
(paren
op_star
id|k_handler
(braket
id|type
)braket
)paren
(paren
id|vc
comma
id|keysym
op_amp
l_int|0xff
comma
id|up_flag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|KT_SLOCK
)paren
id|kbd-&gt;slockstate
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* maybe only if (kbd-&gt;kbdmode == VC_UNICODE) ? */
r_if
c_cond
(paren
op_logical_neg
id|up_flag
op_logical_and
op_logical_neg
id|raw_mode
)paren
id|to_utf8
c_func
(paren
id|vc
comma
id|keysym
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* maybe beep? */
multiline_comment|/* we have at least to update shift_state */
macro_line|#if 1&t;&t;&t;/* how? two almost equivalent choices follow */
id|compute_shiftstate
c_func
(paren
)paren
suffix:semicolon
id|kbd-&gt;slockstate
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* play it safe */
macro_line|#else
id|keysym
op_assign
id|U
c_func
(paren
id|plain_map
(braket
id|keycode
)braket
)paren
suffix:semicolon
id|type
op_assign
id|KTYP
c_func
(paren
id|keysym
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|KT_SHIFT
)paren
(paren
op_star
id|key_handler
(braket
id|type
)braket
)paren
(paren
id|keysym
op_amp
l_int|0xff
comma
id|up_flag
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
id|out
suffix:colon
id|do_poke_blanked_console
op_assign
l_int|1
suffix:semicolon
id|schedule_console_callback
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|kbd_init
r_int
id|__init
id|kbd_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|kbd_struct
id|kbd0
suffix:semicolon
id|kbd0.ledflagstate
op_assign
id|kbd0.default_ledflagstate
op_assign
id|KBD_DEFLEDS
suffix:semicolon
id|kbd0.ledmode
op_assign
id|LED_SHOW_FLAGS
suffix:semicolon
id|kbd0.lockstate
op_assign
id|KBD_DEFLOCK
suffix:semicolon
id|kbd0.slockstate
op_assign
l_int|0
suffix:semicolon
id|kbd0.modeflags
op_assign
id|KBD_DEFMODE
suffix:semicolon
id|kbd0.kbdmode
op_assign
id|VC_XLATE
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_NR_CONSOLES
suffix:semicolon
id|i
op_increment
)paren
id|kbd_table
(braket
id|i
)braket
op_assign
id|kbd0
suffix:semicolon
id|kbd_init_hw
c_func
(paren
)paren
suffix:semicolon
id|tasklet_enable
c_func
(paren
op_amp
id|keyboard_tasklet
)paren
suffix:semicolon
id|tasklet_schedule
c_func
(paren
op_amp
id|keyboard_tasklet
)paren
suffix:semicolon
id|pm_kbd
op_assign
id|pm_register
c_func
(paren
id|PM_SYS_DEV
comma
id|PM_SYS_KBC
comma
id|pm_kbd_request_override
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
