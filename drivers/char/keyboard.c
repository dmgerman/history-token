multiline_comment|/*&n; * linux/drivers/char/keyboard.c&n; *&n; * Written for linux by Johan Myreen as a translation from&n; * the assembly version by Linus (with diacriticals added)&n; *&n; * Some additional features added by Christoph Niemann (ChN), March 1993&n; *&n; * Loadable keymaps by Risto Kankkunen, May 1993&n; *&n; * Diacriticals redone &amp; other small changes, aeb@cwi.nl, June 1993&n; * Added decr/incr_console, dynamic keymaps, Unicode support,&n; * dynamic function/string keys, led setting,  Sept 1994&n; * `Sticky&squot; modifier keys, 951006.&n; *&n; * 11-11-96: SAK should now work in the raw mode (Martin Mares)&n; * &n; * Modified to provide &squot;generic&squot; keyboard support by Hamish Macdonald&n; * Merge with the m68k keyboard driver and split-off of the PC low-level&n; * parts by Geert Uytterhoeven, May 1997&n; *&n; * 27-05-97: Added support for the Magic SysRq Key (Martin Mares)&n; * 30-07-98: Dead keys redone, aeb@cwi.nl.&n; * 21-08-02: Converted to input API, major cleanup. (Vojtech Pavlik)&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/tty_flip.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/kbd_kern.h&gt;
macro_line|#include &lt;linux/kbd_diacr.h&gt;
macro_line|#include &lt;linux/vt_kern.h&gt;
macro_line|#include &lt;linux/sysrq.h&gt;
macro_line|#include &lt;linux/input.h&gt;
r_static
r_void
id|kbd_disconnect
c_func
(paren
r_struct
id|input_handle
op_star
id|handle
)paren
suffix:semicolon
r_extern
r_void
id|ctrl_alt_del
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * Exported functions/variables&n; */
DECL|macro|KBD_DEFMODE
mdefine_line|#define KBD_DEFMODE ((1 &lt;&lt; VC_REPEAT) | (1 &lt;&lt; VC_META))
multiline_comment|/*&n; * Some laptops take the 789uiojklm,. keys as number pad when NumLock is on.&n; * This seems a good reason to start with NumLock off. On HIL keyboards&n; * of PARISC machines however there is no NumLock key and everyone expects the keypad &n; * to be used for numbers.&n; */
macro_line|#if defined(CONFIG_PARISC) &amp;&amp; (defined(CONFIG_KEYBOARD_HIL) || defined(CONFIG_KEYBOARD_HIL_OLD))
DECL|macro|KBD_DEFLEDS
mdefine_line|#define KBD_DEFLEDS (1 &lt;&lt; VC_NUMLOCK)
macro_line|#else
DECL|macro|KBD_DEFLEDS
mdefine_line|#define KBD_DEFLEDS 0
macro_line|#endif
DECL|macro|KBD_DEFLOCK
mdefine_line|#define KBD_DEFLOCK 0
r_void
id|compute_shiftstate
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * Handler Tables.&n; */
DECL|macro|K_HANDLERS
mdefine_line|#define K_HANDLERS&bslash;&n;&t;k_self,&t;&t;k_fn,&t;&t;k_spec,&t;&t;k_pad,&bslash;&n;&t;k_dead,&t;&t;k_cons,&t;&t;k_cur,&t;&t;k_shift,&bslash;&n;&t;k_meta,&t;&t;k_ascii,&t;k_lock,&t;&t;k_lowercase,&bslash;&n;&t;k_slock,&t;k_dead2,&t;k_ignore,&t;k_ignore
DECL|typedef|k_handler_fn
r_typedef
r_void
(paren
id|k_handler_fn
)paren
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_char
id|value
comma
r_char
id|up_flag
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
DECL|variable|K_HANDLERS
r_static
id|k_handler_fn
id|K_HANDLERS
suffix:semicolon
DECL|variable|k_handler
r_static
id|k_handler_fn
op_star
id|k_handler
(braket
l_int|16
)braket
op_assign
(brace
id|K_HANDLERS
)brace
suffix:semicolon
DECL|macro|FN_HANDLERS
mdefine_line|#define FN_HANDLERS&bslash;&n;&t;fn_null, &t;fn_enter,&t;fn_show_ptregs,&t;fn_show_mem,&bslash;&n;&t;fn_show_state,&t;fn_send_intr, &t;fn_lastcons, &t;fn_caps_toggle,&bslash;&n;&t;fn_num,&t;&t;fn_hold, &t;fn_scroll_forw,&t;fn_scroll_back,&bslash;&n;&t;fn_boot_it, &t;fn_caps_on, &t;fn_compose,&t;fn_SAK,&bslash;&n;&t;fn_dec_console, fn_inc_console, fn_spawn_con, &t;fn_bare_num
DECL|typedef|fn_handler_fn
r_typedef
r_void
(paren
id|fn_handler_fn
)paren
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
DECL|variable|FN_HANDLERS
r_static
id|fn_handler_fn
id|FN_HANDLERS
suffix:semicolon
DECL|variable|fn_handler
r_static
id|fn_handler_fn
op_star
id|fn_handler
(braket
)braket
op_assign
(brace
id|FN_HANDLERS
)brace
suffix:semicolon
multiline_comment|/*&n; * Variables exported for vt_ioctl.c&n; */
multiline_comment|/* maximum values each key_handler can handle */
DECL|variable|max_vals
r_const
r_int
id|max_vals
(braket
)braket
op_assign
(brace
l_int|255
comma
id|ARRAY_SIZE
c_func
(paren
id|func_table
)paren
op_minus
l_int|1
comma
id|ARRAY_SIZE
c_func
(paren
id|fn_handler
)paren
op_minus
l_int|1
comma
id|NR_PAD
op_minus
l_int|1
comma
id|NR_DEAD
op_minus
l_int|1
comma
l_int|255
comma
l_int|3
comma
id|NR_SHIFT
op_minus
l_int|1
comma
l_int|255
comma
id|NR_ASCII
op_minus
l_int|1
comma
id|NR_LOCK
op_minus
l_int|1
comma
l_int|255
comma
id|NR_LOCK
op_minus
l_int|1
comma
l_int|255
)brace
suffix:semicolon
DECL|variable|NR_TYPES
r_const
r_int
id|NR_TYPES
op_assign
id|ARRAY_SIZE
c_func
(paren
id|max_vals
)paren
suffix:semicolon
DECL|variable|kbd_table
r_struct
id|kbd_struct
id|kbd_table
(braket
id|MAX_NR_CONSOLES
)braket
suffix:semicolon
DECL|variable|kbd
r_static
r_struct
id|kbd_struct
op_star
id|kbd
op_assign
id|kbd_table
suffix:semicolon
DECL|variable|kbd0
r_static
r_struct
id|kbd_struct
id|kbd0
suffix:semicolon
DECL|variable|spawnpid
DECL|variable|spawnsig
r_int
id|spawnpid
comma
id|spawnsig
suffix:semicolon
multiline_comment|/*&n; * Variables exported for vt.c&n; */
DECL|variable|shift_state
r_int
id|shift_state
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Internal Data.&n; */
DECL|variable|kbd_handler
r_static
r_struct
id|input_handler
id|kbd_handler
suffix:semicolon
DECL|variable|key_down
r_static
r_int
r_int
id|key_down
(braket
id|NBITS
c_func
(paren
id|KEY_MAX
)paren
)braket
suffix:semicolon
multiline_comment|/* keyboard key bitmap */
DECL|variable|shift_down
r_static
r_int
r_char
id|shift_down
(braket
id|NR_SHIFT
)braket
suffix:semicolon
multiline_comment|/* shift state counters.. */
DECL|variable|dead_key_next
r_static
r_int
id|dead_key_next
suffix:semicolon
DECL|variable|npadch
r_static
r_int
id|npadch
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* -1 or number assembled on pad */
DECL|variable|diacr
r_static
r_int
r_char
id|diacr
suffix:semicolon
DECL|variable|rep
r_static
r_char
id|rep
suffix:semicolon
multiline_comment|/* flag telling character repeat */
DECL|variable|ledstate
r_static
r_int
r_char
id|ledstate
op_assign
l_int|0xff
suffix:semicolon
multiline_comment|/* undefined */
DECL|variable|ledioctl
r_static
r_int
r_char
id|ledioctl
suffix:semicolon
DECL|struct|ledptr
r_static
r_struct
id|ledptr
(brace
DECL|member|addr
r_int
r_int
op_star
id|addr
suffix:semicolon
DECL|member|mask
r_int
r_int
id|mask
suffix:semicolon
DECL|member|valid
r_int
r_char
id|valid
suffix:colon
l_int|1
suffix:semicolon
DECL|variable|ledptrs
)brace
id|ledptrs
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* Simple translation table for the SysRq keys */
macro_line|#ifdef CONFIG_MAGIC_SYSRQ
DECL|variable|kbd_sysrq_xlate
r_int
r_char
id|kbd_sysrq_xlate
(braket
id|KEY_MAX
)braket
op_assign
l_string|&quot;&bslash;000&bslash;0331234567890-=&bslash;177&bslash;t&quot;
multiline_comment|/* 0x00 - 0x0f */
l_string|&quot;qwertyuiop[]&bslash;r&bslash;000as&quot;
multiline_comment|/* 0x10 - 0x1f */
l_string|&quot;dfghjkl;&squot;`&bslash;000&bslash;&bslash;zxcv&quot;
multiline_comment|/* 0x20 - 0x2f */
l_string|&quot;bnm,./&bslash;000*&bslash;000 &bslash;000&bslash;201&bslash;202&bslash;203&bslash;204&bslash;205&quot;
multiline_comment|/* 0x30 - 0x3f */
l_string|&quot;&bslash;206&bslash;207&bslash;210&bslash;211&bslash;212&bslash;000&bslash;000789-456+1&quot;
multiline_comment|/* 0x40 - 0x4f */
l_string|&quot;230&bslash;177&bslash;000&bslash;000&bslash;213&bslash;214&bslash;000&bslash;000&bslash;000&bslash;000&bslash;000&bslash;000&bslash;000&bslash;000&bslash;000&bslash;000&quot;
multiline_comment|/* 0x50 - 0x5f */
l_string|&quot;&bslash;r&bslash;000/&quot;
suffix:semicolon
multiline_comment|/* 0x60 - 0x6f */
DECL|variable|sysrq_down
r_static
r_int
id|sysrq_down
suffix:semicolon
macro_line|#endif
DECL|variable|sysrq_alt
r_static
r_int
id|sysrq_alt
suffix:semicolon
multiline_comment|/*&n; * Translation of scancodes to keycodes. We set them on only the first attached&n; * keyboard - for per-keyboard setting, /dev/input/event is more useful.&n; */
DECL|function|getkeycode
r_int
id|getkeycode
c_func
(paren
r_int
r_int
id|scancode
)paren
(brace
r_struct
id|list_head
op_star
id|node
suffix:semicolon
r_struct
id|input_dev
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
id|list_for_each
c_func
(paren
id|node
comma
op_amp
id|kbd_handler.h_list
)paren
(brace
r_struct
id|input_handle
op_star
id|handle
op_assign
id|to_handle_h
c_func
(paren
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|handle-&gt;dev-&gt;keycodesize
)paren
(brace
id|dev
op_assign
id|handle-&gt;dev
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|scancode
OL
l_int|0
op_logical_or
id|scancode
op_ge
id|dev-&gt;keycodemax
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|INPUT_KEYCODE
c_func
(paren
id|dev
comma
id|scancode
)paren
suffix:semicolon
)brace
DECL|function|setkeycode
r_int
id|setkeycode
c_func
(paren
r_int
r_int
id|scancode
comma
r_int
r_int
id|keycode
)paren
(brace
r_struct
id|list_head
op_star
id|node
suffix:semicolon
r_struct
id|input_dev
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
comma
id|oldkey
suffix:semicolon
id|list_for_each
c_func
(paren
id|node
comma
op_amp
id|kbd_handler.h_list
)paren
(brace
r_struct
id|input_handle
op_star
id|handle
op_assign
id|to_handle_h
c_func
(paren
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|handle-&gt;dev-&gt;keycodesize
)paren
(brace
id|dev
op_assign
id|handle-&gt;dev
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|scancode
OL
l_int|0
op_logical_or
id|scancode
op_ge
id|dev-&gt;keycodemax
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|keycode
template_param
id|KEY_MAX
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|oldkey
op_assign
id|SET_INPUT_KEYCODE
c_func
(paren
id|dev
comma
id|scancode
comma
id|keycode
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|oldkey
comma
id|dev-&gt;keybit
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|keycode
comma
id|dev-&gt;keybit
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;keycodemax
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|INPUT_KEYCODE
c_func
(paren
id|dev
comma
id|i
)paren
op_eq
id|oldkey
)paren
id|set_bit
c_func
(paren
id|oldkey
comma
id|dev-&gt;keybit
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Making beeps and bells. &n; */
DECL|function|kd_nosound
r_static
r_void
id|kd_nosound
c_func
(paren
r_int
r_int
id|ignored
)paren
(brace
r_struct
id|list_head
op_star
id|node
suffix:semicolon
id|list_for_each
c_func
(paren
id|node
comma
op_amp
id|kbd_handler.h_list
)paren
(brace
r_struct
id|input_handle
op_star
id|handle
op_assign
id|to_handle_h
c_func
(paren
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|EV_SND
comma
id|handle-&gt;dev-&gt;evbit
)paren
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|SND_TONE
comma
id|handle-&gt;dev-&gt;sndbit
)paren
)paren
id|input_event
c_func
(paren
id|handle-&gt;dev
comma
id|EV_SND
comma
id|SND_TONE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|SND_BELL
comma
id|handle-&gt;dev-&gt;sndbit
)paren
)paren
id|input_event
c_func
(paren
id|handle-&gt;dev
comma
id|EV_SND
comma
id|SND_BELL
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|variable|kd_mksound_timer
r_static
r_struct
id|timer_list
id|kd_mksound_timer
op_assign
id|TIMER_INITIALIZER
c_func
(paren
id|kd_nosound
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
DECL|function|kd_mksound
r_void
id|kd_mksound
c_func
(paren
r_int
r_int
id|hz
comma
r_int
r_int
id|ticks
)paren
(brace
r_struct
id|list_head
op_star
id|node
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|kd_mksound_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hz
)paren
(brace
id|list_for_each_prev
c_func
(paren
id|node
comma
op_amp
id|kbd_handler.h_list
)paren
(brace
r_struct
id|input_handle
op_star
id|handle
op_assign
id|to_handle_h
c_func
(paren
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|EV_SND
comma
id|handle-&gt;dev-&gt;evbit
)paren
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|SND_TONE
comma
id|handle-&gt;dev-&gt;sndbit
)paren
)paren
(brace
id|input_event
c_func
(paren
id|handle-&gt;dev
comma
id|EV_SND
comma
id|SND_TONE
comma
id|hz
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|SND_BELL
comma
id|handle-&gt;dev-&gt;sndbit
)paren
)paren
(brace
id|input_event
c_func
(paren
id|handle-&gt;dev
comma
id|EV_SND
comma
id|SND_BELL
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|ticks
)paren
id|mod_timer
c_func
(paren
op_amp
id|kd_mksound_timer
comma
id|jiffies
op_plus
id|ticks
)paren
suffix:semicolon
)brace
r_else
id|kd_nosound
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Setting the keyboard rate.&n; */
DECL|function|kbd_rate
r_int
id|kbd_rate
c_func
(paren
r_struct
id|kbd_repeat
op_star
id|rep
)paren
(brace
r_struct
id|list_head
op_star
id|node
suffix:semicolon
r_int
r_int
id|d
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|p
op_assign
l_int|0
suffix:semicolon
id|list_for_each
c_func
(paren
id|node
comma
op_amp
id|kbd_handler.h_list
)paren
(brace
r_struct
id|input_handle
op_star
id|handle
op_assign
id|to_handle_h
c_func
(paren
id|node
)paren
suffix:semicolon
r_struct
id|input_dev
op_star
id|dev
op_assign
id|handle-&gt;dev
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|EV_REP
comma
id|dev-&gt;evbit
)paren
)paren
(brace
r_if
c_cond
(paren
id|rep-&gt;delay
OG
l_int|0
)paren
id|input_event
c_func
(paren
id|dev
comma
id|EV_REP
comma
id|REP_DELAY
comma
id|rep-&gt;delay
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rep-&gt;period
OG
l_int|0
)paren
id|input_event
c_func
(paren
id|dev
comma
id|EV_REP
comma
id|REP_PERIOD
comma
id|rep-&gt;period
)paren
suffix:semicolon
id|d
op_assign
id|dev-&gt;rep
(braket
id|REP_DELAY
)braket
suffix:semicolon
id|p
op_assign
id|dev-&gt;rep
(braket
id|REP_PERIOD
)braket
suffix:semicolon
)brace
)brace
id|rep-&gt;delay
op_assign
id|d
suffix:semicolon
id|rep-&gt;period
op_assign
id|p
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Helper Functions.&n; */
DECL|function|put_queue
r_static
r_void
id|put_queue
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
id|ch
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|vc-&gt;vc_tty
suffix:semicolon
r_if
c_cond
(paren
id|tty
)paren
(brace
id|tty_insert_flip_char
c_func
(paren
id|tty
comma
id|ch
comma
l_int|0
)paren
suffix:semicolon
id|con_schedule_flip
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
)brace
DECL|function|puts_queue
r_static
r_void
id|puts_queue
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_char
op_star
id|cp
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|vc-&gt;vc_tty
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
op_star
id|cp
)paren
(brace
id|tty_insert_flip_char
c_func
(paren
id|tty
comma
op_star
id|cp
comma
l_int|0
)paren
suffix:semicolon
id|cp
op_increment
suffix:semicolon
)brace
id|con_schedule_flip
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
DECL|function|applkey
r_static
r_void
id|applkey
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
id|key
comma
r_char
id|mode
)paren
(brace
r_static
r_char
id|buf
(braket
)braket
op_assign
(brace
l_int|0x1b
comma
l_char|&squot;O&squot;
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_assign
(paren
id|mode
ques
c_cond
l_char|&squot;O&squot;
suffix:colon
l_char|&squot;[&squot;
)paren
suffix:semicolon
id|buf
(braket
l_int|2
)braket
op_assign
id|key
suffix:semicolon
id|puts_queue
c_func
(paren
id|vc
comma
id|buf
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Many other routines do put_queue, but I think either&n; * they produce ASCII, or they produce some user-assigned&n; * string, and in both cases we might assume that it is&n; * in utf-8 already. UTF-8 is defined for words of up to 31 bits,&n; * but we need only 16 bits here&n; */
DECL|function|to_utf8
r_static
r_void
id|to_utf8
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
id|ushort
id|c
)paren
(brace
r_if
c_cond
(paren
id|c
OL
l_int|0x80
)paren
multiline_comment|/*  0******* */
id|put_queue
c_func
(paren
id|vc
comma
id|c
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
OL
l_int|0x800
)paren
(brace
multiline_comment|/* 110***** 10****** */
id|put_queue
c_func
(paren
id|vc
comma
l_int|0xc0
op_or
(paren
id|c
op_rshift
l_int|6
)paren
)paren
suffix:semicolon
id|put_queue
c_func
(paren
id|vc
comma
l_int|0x80
op_or
(paren
id|c
op_amp
l_int|0x3f
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* 1110**** 10****** 10****** */
id|put_queue
c_func
(paren
id|vc
comma
l_int|0xe0
op_or
(paren
id|c
op_rshift
l_int|12
)paren
)paren
suffix:semicolon
id|put_queue
c_func
(paren
id|vc
comma
l_int|0x80
op_or
(paren
(paren
id|c
op_rshift
l_int|6
)paren
op_amp
l_int|0x3f
)paren
)paren
suffix:semicolon
id|put_queue
c_func
(paren
id|vc
comma
l_int|0x80
op_or
(paren
id|c
op_amp
l_int|0x3f
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * Called after returning from RAW mode or when changing consoles - recompute&n; * shift_down[] and shift_state from key_down[] maybe called when keymap is&n; * undefined, so that shiftkey release is seen&n; */
DECL|function|compute_shiftstate
r_void
id|compute_shiftstate
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|j
comma
id|k
comma
id|sym
comma
id|val
suffix:semicolon
id|shift_state
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|shift_down
comma
l_int|0
comma
r_sizeof
(paren
id|shift_down
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|key_down
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|key_down
(braket
id|i
)braket
)paren
r_continue
suffix:semicolon
id|k
op_assign
id|i
op_star
id|BITS_PER_LONG
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|BITS_PER_LONG
suffix:semicolon
id|j
op_increment
comma
id|k
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|k
comma
id|key_down
)paren
)paren
r_continue
suffix:semicolon
id|sym
op_assign
id|U
c_func
(paren
id|key_maps
(braket
l_int|0
)braket
(braket
id|k
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|KTYP
c_func
(paren
id|sym
)paren
op_ne
id|KT_SHIFT
op_logical_and
id|KTYP
c_func
(paren
id|sym
)paren
op_ne
id|KT_SLOCK
)paren
r_continue
suffix:semicolon
id|val
op_assign
id|KVAL
c_func
(paren
id|sym
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
op_eq
id|KVAL
c_func
(paren
id|K_CAPSSHIFT
)paren
)paren
id|val
op_assign
id|KVAL
c_func
(paren
id|K_SHIFT
)paren
suffix:semicolon
id|shift_down
(braket
id|val
)braket
op_increment
suffix:semicolon
id|shift_state
op_or_assign
(paren
l_int|1
op_lshift
id|val
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * We have a combining character DIACR here, followed by the character CH.&n; * If the combination occurs in the table, return the corresponding value.&n; * Otherwise, if CH is a space or equals DIACR, return DIACR.&n; * Otherwise, conclude that DIACR was not combining after all,&n; * queue it and return CH.&n; */
DECL|function|handle_diacr
r_static
r_int
r_char
id|handle_diacr
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_char
id|ch
)paren
(brace
r_int
id|d
op_assign
id|diacr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|diacr
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|accent_table_size
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|accent_table
(braket
id|i
)braket
dot
id|diacr
op_eq
id|d
op_logical_and
id|accent_table
(braket
id|i
)braket
dot
id|base
op_eq
id|ch
)paren
r_return
id|accent_table
(braket
id|i
)braket
dot
id|result
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot; &squot;
op_logical_or
id|ch
op_eq
id|d
)paren
r_return
id|d
suffix:semicolon
id|put_queue
c_func
(paren
id|vc
comma
id|d
)paren
suffix:semicolon
r_return
id|ch
suffix:semicolon
)brace
multiline_comment|/*&n; * Special function handlers&n; */
DECL|function|fn_enter
r_static
r_void
id|fn_enter
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_if
c_cond
(paren
id|diacr
)paren
(brace
id|put_queue
c_func
(paren
id|vc
comma
id|diacr
)paren
suffix:semicolon
id|diacr
op_assign
l_int|0
suffix:semicolon
)brace
id|put_queue
c_func
(paren
id|vc
comma
l_int|13
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_CRLF
)paren
)paren
id|put_queue
c_func
(paren
id|vc
comma
l_int|10
)paren
suffix:semicolon
)brace
DECL|function|fn_caps_toggle
r_static
r_void
id|fn_caps_toggle
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_if
c_cond
(paren
id|rep
)paren
r_return
suffix:semicolon
id|chg_vc_kbd_led
c_func
(paren
id|kbd
comma
id|VC_CAPSLOCK
)paren
suffix:semicolon
)brace
DECL|function|fn_caps_on
r_static
r_void
id|fn_caps_on
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_if
c_cond
(paren
id|rep
)paren
r_return
suffix:semicolon
id|set_vc_kbd_led
c_func
(paren
id|kbd
comma
id|VC_CAPSLOCK
)paren
suffix:semicolon
)brace
DECL|function|fn_show_ptregs
r_static
r_void
id|fn_show_ptregs
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_if
c_cond
(paren
id|regs
)paren
id|show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
)brace
DECL|function|fn_hold
r_static
r_void
id|fn_hold
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|vc-&gt;vc_tty
suffix:semicolon
r_if
c_cond
(paren
id|rep
op_logical_or
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Note: SCROLLOCK will be set (cleared) by stop_tty (start_tty);&n;&t; * these routines are also activated by ^S/^Q.&n;&t; * (And SCROLLOCK can also be set by the ioctl KDSKBLED.)&n;&t; */
r_if
c_cond
(paren
id|tty-&gt;stopped
)paren
id|start_tty
c_func
(paren
id|tty
)paren
suffix:semicolon
r_else
id|stop_tty
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
DECL|function|fn_num
r_static
r_void
id|fn_num
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_if
c_cond
(paren
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_APPLIC
)paren
)paren
id|applkey
c_func
(paren
id|vc
comma
l_char|&squot;P&squot;
comma
l_int|1
)paren
suffix:semicolon
r_else
id|fn_bare_num
c_func
(paren
id|vc
comma
id|regs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Bind this to Shift-NumLock if you work in application keypad mode&n; * but want to be able to change the NumLock flag.&n; * Bind this to NumLock if you prefer that the NumLock key always&n; * changes the NumLock flag.&n; */
DECL|function|fn_bare_num
r_static
r_void
id|fn_bare_num
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|rep
)paren
id|chg_vc_kbd_led
c_func
(paren
id|kbd
comma
id|VC_NUMLOCK
)paren
suffix:semicolon
)brace
DECL|function|fn_lastcons
r_static
r_void
id|fn_lastcons
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* switch to the last used console, ChN */
id|set_console
c_func
(paren
id|last_console
)paren
suffix:semicolon
)brace
DECL|function|fn_dec_console
r_static
r_void
id|fn_dec_console
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|i
comma
id|cur
op_assign
id|fg_console
suffix:semicolon
multiline_comment|/* Currently switching?  Queue this next switch relative to that. */
r_if
c_cond
(paren
id|want_console
op_ne
op_minus
l_int|1
)paren
id|cur
op_assign
id|want_console
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|cur
op_minus
l_int|1
suffix:semicolon
id|i
op_ne
id|cur
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
op_minus
l_int|1
)paren
id|i
op_assign
id|MAX_NR_CONSOLES
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|vc_cons_allocated
c_func
(paren
id|i
)paren
)paren
r_break
suffix:semicolon
)brace
id|set_console
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
DECL|function|fn_inc_console
r_static
r_void
id|fn_inc_console
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|i
comma
id|cur
op_assign
id|fg_console
suffix:semicolon
multiline_comment|/* Currently switching?  Queue this next switch relative to that. */
r_if
c_cond
(paren
id|want_console
op_ne
op_minus
l_int|1
)paren
id|cur
op_assign
id|want_console
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|cur
op_plus
l_int|1
suffix:semicolon
id|i
op_ne
id|cur
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|MAX_NR_CONSOLES
)paren
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|vc_cons_allocated
c_func
(paren
id|i
)paren
)paren
r_break
suffix:semicolon
)brace
id|set_console
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
DECL|function|fn_send_intr
r_static
r_void
id|fn_send_intr
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|vc-&gt;vc_tty
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
id|tty_insert_flip_char
c_func
(paren
id|tty
comma
l_int|0
comma
id|TTY_BREAK
)paren
suffix:semicolon
id|con_schedule_flip
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
DECL|function|fn_scroll_forw
r_static
r_void
id|fn_scroll_forw
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|scrollfront
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|fn_scroll_back
r_static
r_void
id|fn_scroll_back
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|scrollback
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|fn_show_mem
r_static
r_void
id|fn_show_mem
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|show_mem
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|fn_show_state
r_static
r_void
id|fn_show_state
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|show_state
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|fn_boot_it
r_static
r_void
id|fn_boot_it
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|ctrl_alt_del
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|fn_compose
r_static
r_void
id|fn_compose
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|dead_key_next
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|fn_spawn_con
r_static
r_void
id|fn_spawn_con
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_if
c_cond
(paren
id|spawnpid
)paren
r_if
c_cond
(paren
id|kill_proc
c_func
(paren
id|spawnpid
comma
id|spawnsig
comma
l_int|1
)paren
)paren
(brace
id|spawnpid
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|fn_SAK
r_static
r_void
id|fn_SAK
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|vc-&gt;vc_tty
suffix:semicolon
multiline_comment|/*&n;&t; * SAK should also work in all raw modes and reset&n;&t; * them properly.&n;&t; */
r_if
c_cond
(paren
id|tty
)paren
id|do_SAK
c_func
(paren
id|tty
)paren
suffix:semicolon
id|reset_vc
c_func
(paren
id|fg_console
)paren
suffix:semicolon
)brace
DECL|function|fn_null
r_static
r_void
id|fn_null
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|compute_shiftstate
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Special key handlers&n; */
DECL|function|k_ignore
r_static
r_void
id|k_ignore
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_char
id|value
comma
r_char
id|up_flag
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
)brace
DECL|function|k_spec
r_static
r_void
id|k_spec
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_char
id|value
comma
r_char
id|up_flag
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|value
op_ge
id|ARRAY_SIZE
c_func
(paren
id|fn_handler
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|kbd-&gt;kbdmode
op_eq
id|VC_RAW
op_logical_or
id|kbd-&gt;kbdmode
op_eq
id|VC_MEDIUMRAW
)paren
op_logical_and
id|value
op_ne
id|KVAL
c_func
(paren
id|K_SAK
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* SAK is allowed even in raw mode */
id|fn_handler
(braket
id|value
)braket
(paren
id|vc
comma
id|regs
)paren
suffix:semicolon
)brace
DECL|function|k_lowercase
r_static
r_void
id|k_lowercase
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_char
id|value
comma
r_char
id|up_flag
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;keyboard.c: k_lowercase was called - impossible&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|k_self
r_static
r_void
id|k_self
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_char
id|value
comma
r_char
id|up_flag
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
multiline_comment|/* no action, if this is a key release */
r_if
c_cond
(paren
id|diacr
)paren
id|value
op_assign
id|handle_diacr
c_func
(paren
id|vc
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dead_key_next
)paren
(brace
id|dead_key_next
op_assign
l_int|0
suffix:semicolon
id|diacr
op_assign
id|value
suffix:semicolon
r_return
suffix:semicolon
)brace
id|put_queue
c_func
(paren
id|vc
comma
id|value
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Handle dead key. Note that we now may have several&n; * dead keys modifying the same character. Very useful&n; * for Vietnamese.&n; */
DECL|function|k_dead2
r_static
r_void
id|k_dead2
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_char
id|value
comma
r_char
id|up_flag
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
id|diacr
op_assign
(paren
id|diacr
ques
c_cond
id|handle_diacr
c_func
(paren
id|vc
comma
id|value
)paren
suffix:colon
id|value
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Obsolete - for backwards compatibility only&n; */
DECL|function|k_dead
r_static
r_void
id|k_dead
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_char
id|value
comma
r_char
id|up_flag
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_static
r_int
r_char
id|ret_diacr
(braket
id|NR_DEAD
)braket
op_assign
(brace
l_char|&squot;`&squot;
comma
l_char|&squot;&bslash;&squot;&squot;
comma
l_char|&squot;^&squot;
comma
l_char|&squot;~&squot;
comma
l_char|&squot;&quot;&squot;
comma
l_char|&squot;,&squot;
)brace
suffix:semicolon
id|value
op_assign
id|ret_diacr
(braket
id|value
)braket
suffix:semicolon
id|k_dead2
c_func
(paren
id|vc
comma
id|value
comma
id|up_flag
comma
id|regs
)paren
suffix:semicolon
)brace
DECL|function|k_cons
r_static
r_void
id|k_cons
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_char
id|value
comma
r_char
id|up_flag
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
id|set_console
c_func
(paren
id|value
)paren
suffix:semicolon
)brace
DECL|function|k_fn
r_static
r_void
id|k_fn
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_char
id|value
comma
r_char
id|up_flag
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|v
suffix:semicolon
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
id|v
op_assign
id|value
suffix:semicolon
r_if
c_cond
(paren
id|v
OL
id|ARRAY_SIZE
c_func
(paren
id|func_table
)paren
)paren
(brace
r_if
c_cond
(paren
id|func_table
(braket
id|value
)braket
)paren
id|puts_queue
c_func
(paren
id|vc
comma
id|func_table
(braket
id|value
)braket
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;k_fn called with value=%d&bslash;n&quot;
comma
id|value
)paren
suffix:semicolon
)brace
DECL|function|k_cur
r_static
r_void
id|k_cur
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_char
id|value
comma
r_char
id|up_flag
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_static
r_const
r_char
op_star
id|cur_chars
op_assign
l_string|&quot;BDCA&quot;
suffix:semicolon
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
id|applkey
c_func
(paren
id|vc
comma
id|cur_chars
(braket
id|value
)braket
comma
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_CKMODE
)paren
)paren
suffix:semicolon
)brace
DECL|function|k_pad
r_static
r_void
id|k_pad
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_char
id|value
comma
r_char
id|up_flag
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_static
r_const
r_char
op_star
id|pad_chars
op_assign
l_string|&quot;0123456789+-*/&bslash;015,.?()#&quot;
suffix:semicolon
r_static
r_const
r_char
op_star
id|app_map
op_assign
l_string|&quot;pqrstuvwxylSRQMnnmPQS&quot;
suffix:semicolon
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
multiline_comment|/* no action, if this is a key release */
multiline_comment|/* kludge... shift forces cursor/number keys */
r_if
c_cond
(paren
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_APPLIC
)paren
op_logical_and
op_logical_neg
id|shift_down
(braket
id|KG_SHIFT
)braket
)paren
(brace
id|applkey
c_func
(paren
id|vc
comma
id|app_map
(braket
id|value
)braket
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|vc_kbd_led
c_func
(paren
id|kbd
comma
id|VC_NUMLOCK
)paren
)paren
r_switch
c_cond
(paren
id|value
)paren
(brace
r_case
id|KVAL
c_func
(paren
id|K_PCOMMA
)paren
suffix:colon
r_case
id|KVAL
c_func
(paren
id|K_PDOT
)paren
suffix:colon
id|k_fn
c_func
(paren
id|vc
comma
id|KVAL
c_func
(paren
id|K_REMOVE
)paren
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P0
)paren
suffix:colon
id|k_fn
c_func
(paren
id|vc
comma
id|KVAL
c_func
(paren
id|K_INSERT
)paren
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P1
)paren
suffix:colon
id|k_fn
c_func
(paren
id|vc
comma
id|KVAL
c_func
(paren
id|K_SELECT
)paren
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P2
)paren
suffix:colon
id|k_cur
c_func
(paren
id|vc
comma
id|KVAL
c_func
(paren
id|K_DOWN
)paren
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P3
)paren
suffix:colon
id|k_fn
c_func
(paren
id|vc
comma
id|KVAL
c_func
(paren
id|K_PGDN
)paren
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P4
)paren
suffix:colon
id|k_cur
c_func
(paren
id|vc
comma
id|KVAL
c_func
(paren
id|K_LEFT
)paren
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P6
)paren
suffix:colon
id|k_cur
c_func
(paren
id|vc
comma
id|KVAL
c_func
(paren
id|K_RIGHT
)paren
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P7
)paren
suffix:colon
id|k_fn
c_func
(paren
id|vc
comma
id|KVAL
c_func
(paren
id|K_FIND
)paren
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P8
)paren
suffix:colon
id|k_cur
c_func
(paren
id|vc
comma
id|KVAL
c_func
(paren
id|K_UP
)paren
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P9
)paren
suffix:colon
id|k_fn
c_func
(paren
id|vc
comma
id|KVAL
c_func
(paren
id|K_PGUP
)paren
comma
l_int|0
comma
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P5
)paren
suffix:colon
id|applkey
c_func
(paren
id|vc
comma
l_char|&squot;G&squot;
comma
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_APPLIC
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|put_queue
c_func
(paren
id|vc
comma
id|pad_chars
(braket
id|value
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_eq
id|KVAL
c_func
(paren
id|K_PENTER
)paren
op_logical_and
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_CRLF
)paren
)paren
id|put_queue
c_func
(paren
id|vc
comma
l_int|10
)paren
suffix:semicolon
)brace
DECL|function|k_shift
r_static
r_void
id|k_shift
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_char
id|value
comma
r_char
id|up_flag
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|old_state
op_assign
id|shift_state
suffix:semicolon
r_if
c_cond
(paren
id|rep
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Mimic typewriter:&n;&t; * a CapsShift key acts like Shift but undoes CapsLock&n;&t; */
r_if
c_cond
(paren
id|value
op_eq
id|KVAL
c_func
(paren
id|K_CAPSSHIFT
)paren
)paren
(brace
id|value
op_assign
id|KVAL
c_func
(paren
id|K_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|up_flag
)paren
id|clr_vc_kbd_led
c_func
(paren
id|kbd
comma
id|VC_CAPSLOCK
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|up_flag
)paren
(brace
multiline_comment|/*&n;&t;&t; * handle the case that two shift or control&n;&t;&t; * keys are depressed simultaneously&n;&t;&t; */
r_if
c_cond
(paren
id|shift_down
(braket
id|value
)braket
)paren
id|shift_down
(braket
id|value
)braket
op_decrement
suffix:semicolon
)brace
r_else
id|shift_down
(braket
id|value
)braket
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|shift_down
(braket
id|value
)braket
)paren
id|shift_state
op_or_assign
(paren
l_int|1
op_lshift
id|value
)paren
suffix:semicolon
r_else
id|shift_state
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|value
)paren
suffix:semicolon
multiline_comment|/* kludge */
r_if
c_cond
(paren
id|up_flag
op_logical_and
id|shift_state
op_ne
id|old_state
op_logical_and
id|npadch
op_ne
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|kbd-&gt;kbdmode
op_eq
id|VC_UNICODE
)paren
id|to_utf8
c_func
(paren
id|vc
comma
id|npadch
op_amp
l_int|0xffff
)paren
suffix:semicolon
r_else
id|put_queue
c_func
(paren
id|vc
comma
id|npadch
op_amp
l_int|0xff
)paren
suffix:semicolon
id|npadch
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|k_meta
r_static
r_void
id|k_meta
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_char
id|value
comma
r_char
id|up_flag
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_META
)paren
)paren
(brace
id|put_queue
c_func
(paren
id|vc
comma
l_char|&squot;&bslash;033&squot;
)paren
suffix:semicolon
id|put_queue
c_func
(paren
id|vc
comma
id|value
)paren
suffix:semicolon
)brace
r_else
id|put_queue
c_func
(paren
id|vc
comma
id|value
op_or
l_int|0x80
)paren
suffix:semicolon
)brace
DECL|function|k_ascii
r_static
r_void
id|k_ascii
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_char
id|value
comma
r_char
id|up_flag
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|base
suffix:semicolon
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|value
OL
l_int|10
)paren
(brace
multiline_comment|/* decimal input of code, while Alt depressed */
id|base
op_assign
l_int|10
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* hexadecimal input of code, while AltGr depressed */
id|value
op_sub_assign
l_int|10
suffix:semicolon
id|base
op_assign
l_int|16
suffix:semicolon
)brace
r_if
c_cond
(paren
id|npadch
op_eq
op_minus
l_int|1
)paren
id|npadch
op_assign
id|value
suffix:semicolon
r_else
id|npadch
op_assign
id|npadch
op_star
id|base
op_plus
id|value
suffix:semicolon
)brace
DECL|function|k_lock
r_static
r_void
id|k_lock
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_char
id|value
comma
r_char
id|up_flag
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_if
c_cond
(paren
id|up_flag
op_logical_or
id|rep
)paren
r_return
suffix:semicolon
id|chg_vc_kbd_lock
c_func
(paren
id|kbd
comma
id|value
)paren
suffix:semicolon
)brace
DECL|function|k_slock
r_static
r_void
id|k_slock
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_char
id|value
comma
r_char
id|up_flag
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|k_shift
c_func
(paren
id|vc
comma
id|value
comma
id|up_flag
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|up_flag
op_logical_or
id|rep
)paren
r_return
suffix:semicolon
id|chg_vc_kbd_slock
c_func
(paren
id|kbd
comma
id|value
)paren
suffix:semicolon
multiline_comment|/* try to make Alt, oops, AltGr and such work */
r_if
c_cond
(paren
op_logical_neg
id|key_maps
(braket
id|kbd-&gt;lockstate
op_xor
id|kbd-&gt;slockstate
)braket
)paren
(brace
id|kbd-&gt;slockstate
op_assign
l_int|0
suffix:semicolon
id|chg_vc_kbd_slock
c_func
(paren
id|kbd
comma
id|value
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * The leds display either (i) the status of NumLock, CapsLock, ScrollLock,&n; * or (ii) whatever pattern of lights people want to show using KDSETLED,&n; * or (iii) specified bits of specified words in kernel memory.&n; */
DECL|function|getledstate
r_int
r_char
id|getledstate
c_func
(paren
r_void
)paren
(brace
r_return
id|ledstate
suffix:semicolon
)brace
DECL|function|setledstate
r_void
id|setledstate
c_func
(paren
r_struct
id|kbd_struct
op_star
id|kbd
comma
r_int
r_int
id|led
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|led
op_amp
op_complement
l_int|7
)paren
)paren
(brace
id|ledioctl
op_assign
id|led
suffix:semicolon
id|kbd-&gt;ledmode
op_assign
id|LED_SHOW_IOCTL
suffix:semicolon
)brace
r_else
id|kbd-&gt;ledmode
op_assign
id|LED_SHOW_FLAGS
suffix:semicolon
id|set_leds
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|getleds
r_static
r_inline
r_int
r_char
id|getleds
c_func
(paren
r_void
)paren
(brace
r_struct
id|kbd_struct
op_star
id|kbd
op_assign
id|kbd_table
op_plus
id|fg_console
suffix:semicolon
r_int
r_char
id|leds
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|kbd-&gt;ledmode
op_eq
id|LED_SHOW_IOCTL
)paren
r_return
id|ledioctl
suffix:semicolon
id|leds
op_assign
id|kbd-&gt;ledflagstate
suffix:semicolon
r_if
c_cond
(paren
id|kbd-&gt;ledmode
op_eq
id|LED_SHOW_MEM
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|ledptrs
(braket
id|i
)braket
dot
id|valid
)paren
(brace
r_if
c_cond
(paren
op_star
id|ledptrs
(braket
id|i
)braket
dot
id|addr
op_amp
id|ledptrs
(braket
id|i
)braket
dot
id|mask
)paren
id|leds
op_or_assign
(paren
l_int|1
op_lshift
id|i
)paren
suffix:semicolon
r_else
id|leds
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|i
)paren
suffix:semicolon
)brace
)brace
r_return
id|leds
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is the bottom half of the keyboard interrupt&n; * routine, and runs with all interrupts enabled. It does&n; * console changing, led setting and copy_to_cooked, which can&n; * take a reasonably long time.&n; *&n; * Aside from timing (which isn&squot;t really that important for&n; * keyboard interrupts as they happen often), using the software&n; * interrupt routines for this thing allows us to easily mask&n; * this when we don&squot;t want any of the above to happen.&n; * This allows for easy and efficient race-condition prevention&n; * for kbd_refresh_leds =&gt; input_event(dev, EV_LED, ...) =&gt; ...&n; */
DECL|function|kbd_bh
r_static
r_void
id|kbd_bh
c_func
(paren
r_int
r_int
id|dummy
)paren
(brace
r_struct
id|list_head
op_star
id|node
suffix:semicolon
r_int
r_char
id|leds
op_assign
id|getleds
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|leds
op_ne
id|ledstate
)paren
(brace
id|list_for_each
c_func
(paren
id|node
comma
op_amp
id|kbd_handler.h_list
)paren
(brace
r_struct
id|input_handle
op_star
id|handle
op_assign
id|to_handle_h
c_func
(paren
id|node
)paren
suffix:semicolon
id|input_event
c_func
(paren
id|handle-&gt;dev
comma
id|EV_LED
comma
id|LED_SCROLLL
comma
op_logical_neg
op_logical_neg
(paren
id|leds
op_amp
l_int|0x01
)paren
)paren
suffix:semicolon
id|input_event
c_func
(paren
id|handle-&gt;dev
comma
id|EV_LED
comma
id|LED_NUML
comma
op_logical_neg
op_logical_neg
(paren
id|leds
op_amp
l_int|0x02
)paren
)paren
suffix:semicolon
id|input_event
c_func
(paren
id|handle-&gt;dev
comma
id|EV_LED
comma
id|LED_CAPSL
comma
op_logical_neg
op_logical_neg
(paren
id|leds
op_amp
l_int|0x04
)paren
)paren
suffix:semicolon
id|input_sync
c_func
(paren
id|handle-&gt;dev
)paren
suffix:semicolon
)brace
)brace
id|ledstate
op_assign
id|leds
suffix:semicolon
)brace
id|DECLARE_TASKLET_DISABLED
c_func
(paren
id|keyboard_tasklet
comma
id|kbd_bh
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n; * This allows a newly plugged keyboard to pick the LED state.&n; */
DECL|function|kbd_refresh_leds
r_static
r_void
id|kbd_refresh_leds
c_func
(paren
r_struct
id|input_handle
op_star
id|handle
)paren
(brace
r_int
r_char
id|leds
op_assign
id|ledstate
suffix:semicolon
id|tasklet_disable
c_func
(paren
op_amp
id|keyboard_tasklet
)paren
suffix:semicolon
r_if
c_cond
(paren
id|leds
op_ne
l_int|0xff
)paren
(brace
id|input_event
c_func
(paren
id|handle-&gt;dev
comma
id|EV_LED
comma
id|LED_SCROLLL
comma
op_logical_neg
op_logical_neg
(paren
id|leds
op_amp
l_int|0x01
)paren
)paren
suffix:semicolon
id|input_event
c_func
(paren
id|handle-&gt;dev
comma
id|EV_LED
comma
id|LED_NUML
comma
op_logical_neg
op_logical_neg
(paren
id|leds
op_amp
l_int|0x02
)paren
)paren
suffix:semicolon
id|input_event
c_func
(paren
id|handle-&gt;dev
comma
id|EV_LED
comma
id|LED_CAPSL
comma
op_logical_neg
op_logical_neg
(paren
id|leds
op_amp
l_int|0x04
)paren
)paren
suffix:semicolon
id|input_sync
c_func
(paren
id|handle-&gt;dev
)paren
suffix:semicolon
)brace
id|tasklet_enable
c_func
(paren
op_amp
id|keyboard_tasklet
)paren
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_X86) || defined(CONFIG_IA64) || defined(CONFIG_ALPHA) ||&bslash;&n;    defined(CONFIG_MIPS) || defined(CONFIG_PPC) || defined(CONFIG_SPARC32) ||&bslash;&n;    defined(CONFIG_SPARC64) || defined(CONFIG_PARISC) || defined(CONFIG_SUPERH) ||&bslash;&n;    (defined(CONFIG_ARM) &amp;&amp; defined(CONFIG_KEYBOARD_ATKBD) &amp;&amp; !defined(CONFIG_RPC))
DECL|macro|HW_RAW
mdefine_line|#define HW_RAW(dev) (test_bit(EV_MSC, dev-&gt;evbit) &amp;&amp; test_bit(MSC_RAW, dev-&gt;mscbit) &amp;&amp;&bslash;&n;&t;&t;&t;((dev)-&gt;id.bustype == BUS_I8042) &amp;&amp; ((dev)-&gt;id.vendor == 0x0001) &amp;&amp; ((dev)-&gt;id.product == 0x0001))
DECL|variable|x86_keycodes
r_static
r_int
r_int
id|x86_keycodes
(braket
l_int|256
)braket
op_assign
(brace
l_int|0
comma
l_int|1
comma
l_int|2
comma
l_int|3
comma
l_int|4
comma
l_int|5
comma
l_int|6
comma
l_int|7
comma
l_int|8
comma
l_int|9
comma
l_int|10
comma
l_int|11
comma
l_int|12
comma
l_int|13
comma
l_int|14
comma
l_int|15
comma
l_int|16
comma
l_int|17
comma
l_int|18
comma
l_int|19
comma
l_int|20
comma
l_int|21
comma
l_int|22
comma
l_int|23
comma
l_int|24
comma
l_int|25
comma
l_int|26
comma
l_int|27
comma
l_int|28
comma
l_int|29
comma
l_int|30
comma
l_int|31
comma
l_int|32
comma
l_int|33
comma
l_int|34
comma
l_int|35
comma
l_int|36
comma
l_int|37
comma
l_int|38
comma
l_int|39
comma
l_int|40
comma
l_int|41
comma
l_int|42
comma
l_int|43
comma
l_int|44
comma
l_int|45
comma
l_int|46
comma
l_int|47
comma
l_int|48
comma
l_int|49
comma
l_int|50
comma
l_int|51
comma
l_int|52
comma
l_int|53
comma
l_int|54
comma
l_int|55
comma
l_int|56
comma
l_int|57
comma
l_int|58
comma
l_int|59
comma
l_int|60
comma
l_int|61
comma
l_int|62
comma
l_int|63
comma
l_int|64
comma
l_int|65
comma
l_int|66
comma
l_int|67
comma
l_int|68
comma
l_int|69
comma
l_int|70
comma
l_int|71
comma
l_int|72
comma
l_int|73
comma
l_int|74
comma
l_int|75
comma
l_int|76
comma
l_int|77
comma
l_int|78
comma
l_int|79
comma
l_int|80
comma
l_int|81
comma
l_int|82
comma
l_int|83
comma
l_int|84
comma
l_int|118
comma
l_int|86
comma
l_int|87
comma
l_int|88
comma
l_int|115
comma
l_int|120
comma
l_int|119
comma
l_int|121
comma
l_int|112
comma
l_int|123
comma
l_int|92
comma
l_int|284
comma
l_int|285
comma
l_int|309
comma
l_int|298
comma
l_int|312
comma
l_int|91
comma
l_int|327
comma
l_int|328
comma
l_int|329
comma
l_int|331
comma
l_int|333
comma
l_int|335
comma
l_int|336
comma
l_int|337
comma
l_int|338
comma
l_int|339
comma
l_int|367
comma
l_int|288
comma
l_int|302
comma
l_int|304
comma
l_int|350
comma
l_int|89
comma
l_int|334
comma
l_int|326
comma
l_int|267
comma
l_int|126
comma
l_int|268
comma
l_int|269
comma
l_int|125
comma
l_int|347
comma
l_int|348
comma
l_int|349
comma
l_int|360
comma
l_int|261
comma
l_int|262
comma
l_int|263
comma
l_int|268
comma
l_int|376
comma
l_int|100
comma
l_int|101
comma
l_int|321
comma
l_int|316
comma
l_int|373
comma
l_int|286
comma
l_int|289
comma
l_int|102
comma
l_int|351
comma
l_int|355
comma
l_int|103
comma
l_int|104
comma
l_int|105
comma
l_int|275
comma
l_int|287
comma
l_int|279
comma
l_int|306
comma
l_int|106
comma
l_int|274
comma
l_int|107
comma
l_int|294
comma
l_int|364
comma
l_int|358
comma
l_int|363
comma
l_int|362
comma
l_int|361
comma
l_int|291
comma
l_int|108
comma
l_int|381
comma
l_int|281
comma
l_int|290
comma
l_int|272
comma
l_int|292
comma
l_int|305
comma
l_int|280
comma
l_int|99
comma
l_int|112
comma
l_int|257
comma
l_int|258
comma
l_int|359
comma
l_int|113
comma
l_int|114
comma
l_int|264
comma
l_int|117
comma
l_int|271
comma
l_int|374
comma
l_int|379
comma
l_int|265
comma
l_int|266
comma
l_int|93
comma
l_int|94
comma
l_int|95
comma
l_int|85
comma
l_int|259
comma
l_int|375
comma
l_int|260
comma
l_int|90
comma
l_int|116
comma
l_int|377
comma
l_int|109
comma
l_int|111
comma
l_int|277
comma
l_int|278
comma
l_int|282
comma
l_int|283
comma
l_int|295
comma
l_int|296
comma
l_int|297
comma
l_int|299
comma
l_int|300
comma
l_int|301
comma
l_int|293
comma
l_int|303
comma
l_int|307
comma
l_int|308
comma
l_int|310
comma
l_int|313
comma
l_int|314
comma
l_int|315
comma
l_int|317
comma
l_int|318
comma
l_int|319
comma
l_int|320
comma
l_int|357
comma
l_int|322
comma
l_int|323
comma
l_int|324
comma
l_int|325
comma
l_int|276
comma
l_int|330
comma
l_int|332
comma
l_int|340
comma
l_int|365
comma
l_int|342
comma
l_int|343
comma
l_int|344
comma
l_int|345
comma
l_int|346
comma
l_int|356
comma
l_int|270
comma
l_int|341
comma
l_int|368
comma
l_int|369
comma
l_int|370
comma
l_int|371
comma
l_int|372
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_MAC_EMUMOUSEBTN
r_extern
r_int
id|mac_hid_mouse_emulate_buttons
c_func
(paren
r_int
comma
r_int
comma
r_int
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_MAC_EMUMOUSEBTN */
macro_line|#if defined(CONFIG_SPARC32) || defined(CONFIG_SPARC64)
DECL|variable|sparc_l1_a_state
r_static
r_int
id|sparc_l1_a_state
op_assign
l_int|0
suffix:semicolon
r_extern
r_void
id|sun_do_break
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
DECL|function|emulate_raw
r_static
r_int
id|emulate_raw
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_int
id|keycode
comma
r_int
r_char
id|up_flag
)paren
(brace
r_if
c_cond
(paren
id|keycode
OG
l_int|255
op_logical_or
op_logical_neg
id|x86_keycodes
(braket
id|keycode
)braket
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|keycode
)paren
(brace
r_case
id|KEY_PAUSE
suffix:colon
id|put_queue
c_func
(paren
id|vc
comma
l_int|0xe1
)paren
suffix:semicolon
id|put_queue
c_func
(paren
id|vc
comma
l_int|0x1d
op_or
id|up_flag
)paren
suffix:semicolon
id|put_queue
c_func
(paren
id|vc
comma
l_int|0x45
op_or
id|up_flag
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|KEY_HANGUEL
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|up_flag
)paren
id|put_queue
c_func
(paren
id|vc
comma
l_int|0xf1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|KEY_HANJA
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|up_flag
)paren
id|put_queue
c_func
(paren
id|vc
comma
l_int|0xf2
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|keycode
op_eq
id|KEY_SYSRQ
op_logical_and
id|sysrq_alt
)paren
(brace
id|put_queue
c_func
(paren
id|vc
comma
l_int|0x54
op_or
id|up_flag
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x86_keycodes
(braket
id|keycode
)braket
op_amp
l_int|0x100
)paren
id|put_queue
c_func
(paren
id|vc
comma
l_int|0xe0
)paren
suffix:semicolon
id|put_queue
c_func
(paren
id|vc
comma
(paren
id|x86_keycodes
(braket
id|keycode
)braket
op_amp
l_int|0x7f
)paren
op_or
id|up_flag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|keycode
op_eq
id|KEY_SYSRQ
)paren
(brace
id|put_queue
c_func
(paren
id|vc
comma
l_int|0xe0
)paren
suffix:semicolon
id|put_queue
c_func
(paren
id|vc
comma
l_int|0x37
op_or
id|up_flag
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#else
DECL|macro|HW_RAW
mdefine_line|#define HW_RAW(dev)&t;0
macro_line|#warning &quot;Cannot generate rawmode keyboard for your architecture yet.&quot;
DECL|function|emulate_raw
r_static
r_int
id|emulate_raw
c_func
(paren
r_struct
id|vc_data
op_star
id|vc
comma
r_int
r_int
id|keycode
comma
r_int
r_char
id|up_flag
)paren
(brace
r_if
c_cond
(paren
id|keycode
OG
l_int|127
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|put_queue
c_func
(paren
id|vc
comma
id|keycode
op_or
id|up_flag
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
DECL|function|kbd_rawcode
r_static
r_void
id|kbd_rawcode
c_func
(paren
r_int
r_char
id|data
)paren
(brace
r_struct
id|vc_data
op_star
id|vc
op_assign
id|vc_cons
(braket
id|fg_console
)braket
dot
id|d
suffix:semicolon
id|kbd
op_assign
id|kbd_table
op_plus
id|fg_console
suffix:semicolon
r_if
c_cond
(paren
id|kbd-&gt;kbdmode
op_eq
id|VC_RAW
)paren
id|put_queue
c_func
(paren
id|vc
comma
id|data
)paren
suffix:semicolon
)brace
DECL|function|kbd_keycode
r_void
id|kbd_keycode
c_func
(paren
r_int
r_int
id|keycode
comma
r_int
id|down
comma
r_int
id|hw_raw
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|vc_data
op_star
id|vc
op_assign
id|vc_cons
(braket
id|fg_console
)braket
dot
id|d
suffix:semicolon
r_int
r_int
id|keysym
comma
op_star
id|key_map
suffix:semicolon
r_int
r_char
id|type
comma
id|raw_mode
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_int
id|shift_final
suffix:semicolon
id|tty
op_assign
id|vc-&gt;vc_tty
suffix:semicolon
r_if
c_cond
(paren
id|tty
op_logical_and
(paren
op_logical_neg
id|tty-&gt;driver_data
)paren
)paren
(brace
multiline_comment|/* No driver data? Strange. Okay we fix it then. */
id|tty-&gt;driver_data
op_assign
id|vc
suffix:semicolon
)brace
id|kbd
op_assign
id|kbd_table
op_plus
id|fg_console
suffix:semicolon
r_if
c_cond
(paren
id|keycode
op_eq
id|KEY_LEFTALT
op_logical_or
id|keycode
op_eq
id|KEY_RIGHTALT
)paren
id|sysrq_alt
op_assign
id|down
suffix:semicolon
macro_line|#if defined(CONFIG_SPARC32) || defined(CONFIG_SPARC64)
r_if
c_cond
(paren
id|keycode
op_eq
id|KEY_STOP
)paren
id|sparc_l1_a_state
op_assign
id|down
suffix:semicolon
macro_line|#endif
id|rep
op_assign
(paren
id|down
op_eq
l_int|2
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MAC_EMUMOUSEBTN
r_if
c_cond
(paren
id|mac_hid_mouse_emulate_buttons
c_func
(paren
l_int|1
comma
id|keycode
comma
id|down
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif /* CONFIG_MAC_EMUMOUSEBTN */
r_if
c_cond
(paren
(paren
id|raw_mode
op_assign
(paren
id|kbd-&gt;kbdmode
op_eq
id|VC_RAW
)paren
)paren
op_logical_and
op_logical_neg
id|hw_raw
)paren
r_if
c_cond
(paren
id|emulate_raw
c_func
(paren
id|vc
comma
id|keycode
comma
op_logical_neg
id|down
op_lshift
l_int|7
)paren
)paren
r_if
c_cond
(paren
id|keycode
OL
id|BTN_MISC
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;keyboard.c: can&squot;t emulate rawmode for keycode %d&bslash;n&quot;
comma
id|keycode
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MAGIC_SYSRQ&t;       /* Handle the SysRq Hack */
r_if
c_cond
(paren
id|keycode
op_eq
id|KEY_SYSRQ
op_logical_and
(paren
id|sysrq_down
op_logical_or
(paren
id|down
op_eq
l_int|1
op_logical_and
id|sysrq_alt
)paren
)paren
)paren
(brace
id|sysrq_down
op_assign
id|down
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sysrq_down
op_logical_and
id|down
op_logical_and
op_logical_neg
id|rep
)paren
(brace
id|handle_sysrq
c_func
(paren
id|kbd_sysrq_xlate
(braket
id|keycode
)braket
comma
id|regs
comma
id|tty
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if defined(CONFIG_SPARC32) || defined(CONFIG_SPARC64)
r_if
c_cond
(paren
id|keycode
op_eq
id|KEY_A
op_logical_and
id|sparc_l1_a_state
)paren
(brace
id|sparc_l1_a_state
op_assign
l_int|0
suffix:semicolon
id|sun_do_break
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|kbd-&gt;kbdmode
op_eq
id|VC_MEDIUMRAW
)paren
(brace
multiline_comment|/*&n;&t;&t; * This is extended medium raw mode, with keys above 127&n;&t;&t; * encoded as 0, high 7 bits, low 7 bits, with the 0 bearing&n;&t;&t; * the &squot;up&squot; flag if needed. 0 is reserved, so this shouldn&squot;t&n;&t;&t; * interfere with anything else. The two bytes after 0 will&n;&t;&t; * always have the up flag set not to interfere with older&n;&t;&t; * applications. This allows for 16384 different keycodes,&n;&t;&t; * which should be enough.&n;&t;&t; */
r_if
c_cond
(paren
id|keycode
OL
l_int|128
)paren
(brace
id|put_queue
c_func
(paren
id|vc
comma
id|keycode
op_or
(paren
op_logical_neg
id|down
op_lshift
l_int|7
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|put_queue
c_func
(paren
id|vc
comma
op_logical_neg
id|down
op_lshift
l_int|7
)paren
suffix:semicolon
id|put_queue
c_func
(paren
id|vc
comma
(paren
id|keycode
op_rshift
l_int|7
)paren
op_or
l_int|0x80
)paren
suffix:semicolon
id|put_queue
c_func
(paren
id|vc
comma
id|keycode
op_or
l_int|0x80
)paren
suffix:semicolon
)brace
id|raw_mode
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|down
)paren
id|set_bit
c_func
(paren
id|keycode
comma
id|key_down
)paren
suffix:semicolon
r_else
id|clear_bit
c_func
(paren
id|keycode
comma
id|key_down
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rep
op_logical_and
(paren
op_logical_neg
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_REPEAT
)paren
op_logical_or
(paren
id|tty
op_logical_and
(paren
op_logical_neg
id|L_ECHO
c_func
(paren
id|tty
)paren
op_logical_and
id|tty-&gt;driver
op_member_access_from_pointer
id|chars_in_buffer
c_func
(paren
id|tty
)paren
)paren
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Don&squot;t repeat a key if the input buffers are not empty and the&n;&t;&t; * characters get aren&squot;t echoed locally. This makes key repeat &n;&t;&t; * usable with slow applications and under heavy loads.&n;&t;&t; */
r_return
suffix:semicolon
)brace
id|shift_final
op_assign
(paren
id|shift_state
op_or
id|kbd-&gt;slockstate
)paren
op_xor
id|kbd-&gt;lockstate
suffix:semicolon
id|key_map
op_assign
id|key_maps
(braket
id|shift_final
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|key_map
)paren
(brace
id|compute_shiftstate
c_func
(paren
)paren
suffix:semicolon
id|kbd-&gt;slockstate
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|keycode
OG
id|NR_KEYS
)paren
r_return
suffix:semicolon
id|keysym
op_assign
id|key_map
(braket
id|keycode
)braket
suffix:semicolon
id|type
op_assign
id|KTYP
c_func
(paren
id|keysym
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
OL
l_int|0xf0
)paren
(brace
r_if
c_cond
(paren
id|down
op_logical_and
op_logical_neg
id|raw_mode
)paren
id|to_utf8
c_func
(paren
id|vc
comma
id|keysym
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|type
op_sub_assign
l_int|0xf0
suffix:semicolon
r_if
c_cond
(paren
id|raw_mode
op_logical_and
id|type
op_ne
id|KT_SPEC
op_logical_and
id|type
op_ne
id|KT_SHIFT
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|KT_LETTER
)paren
(brace
id|type
op_assign
id|KT_LATIN
suffix:semicolon
r_if
c_cond
(paren
id|vc_kbd_led
c_func
(paren
id|kbd
comma
id|VC_CAPSLOCK
)paren
)paren
(brace
id|key_map
op_assign
id|key_maps
(braket
id|shift_final
op_xor
(paren
l_int|1
op_lshift
id|KG_SHIFT
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|key_map
)paren
id|keysym
op_assign
id|key_map
(braket
id|keycode
)braket
suffix:semicolon
)brace
)brace
(paren
op_star
id|k_handler
(braket
id|type
)braket
)paren
(paren
id|vc
comma
id|keysym
op_amp
l_int|0xff
comma
op_logical_neg
id|down
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|KT_SLOCK
)paren
id|kbd-&gt;slockstate
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|kbd_event
r_static
r_void
id|kbd_event
c_func
(paren
r_struct
id|input_handle
op_star
id|handle
comma
r_int
r_int
id|event_type
comma
r_int
r_int
id|event_code
comma
r_int
id|value
)paren
(brace
r_if
c_cond
(paren
id|event_type
op_eq
id|EV_MSC
op_logical_and
id|event_code
op_eq
id|MSC_RAW
op_logical_and
id|HW_RAW
c_func
(paren
id|handle-&gt;dev
)paren
)paren
id|kbd_rawcode
c_func
(paren
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|event_type
op_eq
id|EV_KEY
)paren
id|kbd_keycode
c_func
(paren
id|event_code
comma
id|value
comma
id|HW_RAW
c_func
(paren
id|handle-&gt;dev
)paren
comma
id|handle-&gt;dev-&gt;regs
)paren
suffix:semicolon
id|tasklet_schedule
c_func
(paren
op_amp
id|keyboard_tasklet
)paren
suffix:semicolon
id|do_poke_blanked_console
op_assign
l_int|1
suffix:semicolon
id|schedule_console_callback
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|kbd_name
r_static
r_char
id|kbd_name
(braket
)braket
op_assign
l_string|&quot;kbd&quot;
suffix:semicolon
multiline_comment|/*&n; * When a keyboard (or other input device) is found, the kbd_connect&n; * function is called. The function then looks at the device, and if it&n; * likes it, it can open it and get events from it. In this (kbd_connect)&n; * function, we should decide which VT to bind that keyboard to initially.&n; */
DECL|function|kbd_connect
r_static
r_struct
id|input_handle
op_star
id|kbd_connect
c_func
(paren
r_struct
id|input_handler
op_star
id|handler
comma
r_struct
id|input_dev
op_star
id|dev
comma
r_struct
id|input_device_id
op_star
id|id
)paren
(brace
r_struct
id|input_handle
op_star
id|handle
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|KEY_RESERVED
suffix:semicolon
id|i
OL
id|BTN_MISC
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|i
comma
id|dev-&gt;keybit
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_eq
id|BTN_MISC
)paren
op_logical_and
op_logical_neg
id|test_bit
c_func
(paren
id|EV_SND
comma
id|dev-&gt;evbit
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|handle
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|input_handle
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|handle
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|input_handle
)paren
)paren
suffix:semicolon
id|handle-&gt;dev
op_assign
id|dev
suffix:semicolon
id|handle-&gt;handler
op_assign
id|handler
suffix:semicolon
id|handle-&gt;name
op_assign
id|kbd_name
suffix:semicolon
id|input_open_device
c_func
(paren
id|handle
)paren
suffix:semicolon
id|kbd_refresh_leds
c_func
(paren
id|handle
)paren
suffix:semicolon
r_return
id|handle
suffix:semicolon
)brace
DECL|function|kbd_disconnect
r_static
r_void
id|kbd_disconnect
c_func
(paren
r_struct
id|input_handle
op_star
id|handle
)paren
(brace
id|input_close_device
c_func
(paren
id|handle
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|handle
)paren
suffix:semicolon
)brace
DECL|variable|kbd_ids
r_static
r_struct
id|input_device_id
id|kbd_ids
(braket
)braket
op_assign
(brace
(brace
dot
id|flags
op_assign
id|INPUT_DEVICE_ID_MATCH_EVBIT
comma
dot
id|evbit
op_assign
(brace
id|BIT
c_func
(paren
id|EV_KEY
)paren
)brace
comma
)brace
comma
(brace
dot
id|flags
op_assign
id|INPUT_DEVICE_ID_MATCH_EVBIT
comma
dot
id|evbit
op_assign
(brace
id|BIT
c_func
(paren
id|EV_SND
)paren
)brace
comma
)brace
comma
(brace
)brace
comma
multiline_comment|/* Terminating entry */
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
c_func
(paren
id|input
comma
id|kbd_ids
)paren
suffix:semicolon
DECL|variable|kbd_handler
r_static
r_struct
id|input_handler
id|kbd_handler
op_assign
(brace
dot
id|event
op_assign
id|kbd_event
comma
dot
id|connect
op_assign
id|kbd_connect
comma
dot
id|disconnect
op_assign
id|kbd_disconnect
comma
dot
id|name
op_assign
l_string|&quot;kbd&quot;
comma
dot
id|id_table
op_assign
id|kbd_ids
comma
)brace
suffix:semicolon
DECL|function|kbd_init
r_int
id|__init
id|kbd_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|kbd0.ledflagstate
op_assign
id|kbd0.default_ledflagstate
op_assign
id|KBD_DEFLEDS
suffix:semicolon
id|kbd0.ledmode
op_assign
id|LED_SHOW_FLAGS
suffix:semicolon
id|kbd0.lockstate
op_assign
id|KBD_DEFLOCK
suffix:semicolon
id|kbd0.slockstate
op_assign
l_int|0
suffix:semicolon
id|kbd0.modeflags
op_assign
id|KBD_DEFMODE
suffix:semicolon
id|kbd0.kbdmode
op_assign
id|VC_XLATE
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_NR_CONSOLES
suffix:semicolon
id|i
op_increment
)paren
id|kbd_table
(braket
id|i
)braket
op_assign
id|kbd0
suffix:semicolon
id|input_register_handler
c_func
(paren
op_amp
id|kbd_handler
)paren
suffix:semicolon
id|tasklet_enable
c_func
(paren
op_amp
id|keyboard_tasklet
)paren
suffix:semicolon
id|tasklet_schedule
c_func
(paren
op_amp
id|keyboard_tasklet
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
