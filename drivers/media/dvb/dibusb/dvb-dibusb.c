multiline_comment|/*&n; * Driver for mobile USB Budget DVB-T devices based on reference&n; * design made by DiBcom (http://www.dibcom.fr/)&n; *&n; * dvb-dibusb.c&n; *&n; * Copyright (C) 2004 Patrick Boettcher (patrick.boettcher@desy.de)&n; *&n; * based on GPL code from DiBcom, which has&n; *&n; * Copyright (C) 2004 Amaury Demol for DiBcom (ademol@dibcom.fr)&n; *&n; *&n; * Remote control code added by David Matthews (dm@prolingua.co.uk)&n; *&n; *&t;This program is free software; you can redistribute it and/or&n; *&t;modify it under the terms of the GNU General Public License as&n; *&t;published by the Free Software Foundation, version 2.&n; *&n; * Acknowledgements&n; *&n; *  Amaury Demol (ademol@dibcom.fr) from DiBcom for providing specs and driver&n; *  sources, on which this driver (and the dib3000mb/mc/p frontends) are based.&n; *&n; * see Documentation/dvb/README.dibusb for more information&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/usb.h&gt;
macro_line|#include &lt;linux/firmware.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/input.h&gt;
macro_line|#include &quot;dmxdev.h&quot;
macro_line|#include &quot;dvb_demux.h&quot;
macro_line|#include &quot;dvb_filter.h&quot;
macro_line|#include &quot;dvb_net.h&quot;
macro_line|#include &quot;dvb_frontend.h&quot;
macro_line|#include &quot;dib3000.h&quot;
macro_line|#include &quot;dvb-dibusb.h&quot;
multiline_comment|/* debug */
macro_line|#ifdef CONFIG_DVB_DIBCOM_DEBUG
DECL|macro|dprintk
mdefine_line|#define dprintk(level,args...) &bslash;&n;&t;    do { if ((debug &amp; level)) { printk(args); } } while (0)
DECL|macro|debug_dump
mdefine_line|#define debug_dump(b,l) if (debug) {&bslash;&n;&t;int i; deb_xfer(&quot;%s: %d &gt; &quot;,__FUNCTION__,l); &bslash;&n;&t;for (i = 0; i &lt; l; i++) deb_xfer(&quot;%02x &quot;, b[i]); &bslash;&n;&t;deb_xfer(&quot;&bslash;n&quot;);&bslash;&n;}
DECL|variable|debug
r_static
r_int
id|debug
suffix:semicolon
id|module_param
c_func
(paren
id|debug
comma
r_int
comma
l_int|0x644
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|debug
comma
l_string|&quot;set debugging level (1=info,2=xfer,4=alotmore,8=ts,16=err,32=rc (|-able)).&quot;
)paren
suffix:semicolon
macro_line|#else
DECL|macro|dprintk
mdefine_line|#define dprintk(args...)
DECL|macro|debug_dump
mdefine_line|#define debug_dump(b,l)
macro_line|#endif
DECL|macro|deb_info
mdefine_line|#define deb_info(args...) dprintk(0x01,args)
DECL|macro|deb_xfer
mdefine_line|#define deb_xfer(args...) dprintk(0x02,args)
DECL|macro|deb_alot
mdefine_line|#define deb_alot(args...) dprintk(0x04,args)
DECL|macro|deb_ts
mdefine_line|#define deb_ts(args...)   dprintk(0x08,args)
DECL|macro|deb_err
mdefine_line|#define deb_err(args...)   dprintk(0x10,args)
DECL|macro|deb_rc
mdefine_line|#define deb_rc(args...)   dprintk(0x20,args)
multiline_comment|/* Version information */
DECL|macro|DRIVER_VERSION
mdefine_line|#define DRIVER_VERSION &quot;0.1&quot;
DECL|macro|DRIVER_DESC
mdefine_line|#define DRIVER_DESC &quot;Driver for DiBcom based USB Budget DVB-T device&quot;
DECL|macro|DRIVER_AUTHOR
mdefine_line|#define DRIVER_AUTHOR &quot;Patrick Boettcher, patrick.boettcher@desy.de&quot;
DECL|function|dibusb_readwrite_usb
r_static
r_int
id|dibusb_readwrite_usb
c_func
(paren
r_struct
id|usb_dibusb
op_star
id|dib
comma
id|u8
op_star
id|wbuf
comma
id|u16
id|wlen
comma
id|u8
op_star
id|rbuf
comma
id|u16
id|rlen
)paren
(brace
r_int
id|actlen
comma
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|wbuf
op_eq
l_int|NULL
op_logical_or
id|wlen
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|down_interruptible
c_func
(paren
op_amp
id|dib-&gt;usb_sem
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|dib-&gt;feedcount
op_logical_and
id|wbuf
(braket
l_int|0
)braket
op_eq
id|DIBUSB_REQ_I2C_WRITE
op_logical_and
id|dib-&gt;dibdev-&gt;parm-&gt;type
op_eq
id|DIBUSB1_1
)paren
id|deb_err
c_func
(paren
l_string|&quot;BUG: writing to i2c, while TS-streaming destroys the stream.&quot;
l_string|&quot;(%x reg: %x %x)&quot;
comma
id|wbuf
(braket
l_int|0
)braket
comma
id|wbuf
(braket
l_int|2
)braket
comma
id|wbuf
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|debug_dump
c_func
(paren
id|wbuf
comma
id|wlen
)paren
suffix:semicolon
id|ret
op_assign
id|usb_bulk_msg
c_func
(paren
id|dib-&gt;udev
comma
id|usb_sndbulkpipe
c_func
(paren
id|dib-&gt;udev
comma
id|dib-&gt;dibdev-&gt;parm-&gt;cmd_pipe
)paren
comma
id|wbuf
comma
id|wlen
comma
op_amp
id|actlen
comma
id|DIBUSB_I2C_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
id|err
c_func
(paren
l_string|&quot;bulk message failed: %d (%d/%d)&quot;
comma
id|ret
comma
id|wlen
comma
id|actlen
)paren
suffix:semicolon
r_else
id|ret
op_assign
id|actlen
op_ne
id|wlen
ques
c_cond
op_minus
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* an answer is expected, and no error before */
r_if
c_cond
(paren
op_logical_neg
id|ret
op_logical_and
id|rbuf
op_logical_and
id|rlen
)paren
(brace
id|ret
op_assign
id|usb_bulk_msg
c_func
(paren
id|dib-&gt;udev
comma
id|usb_rcvbulkpipe
c_func
(paren
id|dib-&gt;udev
comma
id|dib-&gt;dibdev-&gt;parm-&gt;result_pipe
)paren
comma
id|rbuf
comma
id|rlen
comma
op_amp
id|actlen
comma
id|DIBUSB_I2C_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
id|err
c_func
(paren
l_string|&quot;recv bulk message failed: %d&quot;
comma
id|ret
)paren
suffix:semicolon
r_else
(brace
id|deb_alot
c_func
(paren
l_string|&quot;rlen: %d&bslash;n&quot;
comma
id|rlen
)paren
suffix:semicolon
id|debug_dump
c_func
(paren
id|rbuf
comma
id|actlen
)paren
suffix:semicolon
)brace
)brace
id|up
c_func
(paren
op_amp
id|dib-&gt;usb_sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|dibusb_i2c_msg
r_static
r_int
id|dibusb_i2c_msg
c_func
(paren
r_struct
id|usb_dibusb
op_star
id|dib
comma
id|u8
id|addr
comma
id|u8
op_star
id|wbuf
comma
id|u16
id|wlen
comma
id|u8
op_star
id|rbuf
comma
id|u16
id|rlen
)paren
(brace
id|u8
id|sndbuf
(braket
id|wlen
op_plus
l_int|4
)braket
suffix:semicolon
multiline_comment|/* lead(1) devaddr,direction(1) addr(2) data(wlen) (len(2) (when reading)) */
multiline_comment|/* write only ? */
r_int
id|wo
op_assign
(paren
id|rbuf
op_eq
l_int|NULL
op_logical_or
id|rlen
op_eq
l_int|0
)paren
comma
id|len
op_assign
l_int|2
op_plus
id|wlen
op_plus
(paren
id|wo
ques
c_cond
l_int|0
suffix:colon
l_int|2
)paren
suffix:semicolon
id|deb_alot
c_func
(paren
l_string|&quot;wo: %d, wlen: %d, len: %d&bslash;n&quot;
comma
id|wo
comma
id|wlen
comma
id|len
)paren
suffix:semicolon
id|sndbuf
(braket
l_int|0
)braket
op_assign
id|wo
ques
c_cond
id|DIBUSB_REQ_I2C_WRITE
suffix:colon
id|DIBUSB_REQ_I2C_READ
suffix:semicolon
id|sndbuf
(braket
l_int|1
)braket
op_assign
(paren
id|addr
op_amp
l_int|0xfe
)paren
op_or
(paren
id|wo
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|sndbuf
(braket
l_int|2
)braket
comma
id|wbuf
comma
id|wlen
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wo
)paren
(brace
id|sndbuf
(braket
id|wlen
op_plus
l_int|2
)braket
op_assign
(paren
id|rlen
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|sndbuf
(braket
id|wlen
op_plus
l_int|3
)braket
op_assign
id|rlen
op_amp
l_int|0xff
suffix:semicolon
)brace
r_return
id|dibusb_readwrite_usb
c_func
(paren
id|dib
comma
id|sndbuf
comma
id|len
comma
id|rbuf
comma
id|rlen
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * DVB stuff&n; */
DECL|function|dibusb_urb_complete
r_static
r_void
id|dibusb_urb_complete
c_func
(paren
r_struct
id|urb
op_star
id|urb
comma
r_struct
id|pt_regs
op_star
id|ptregs
)paren
(brace
r_struct
id|usb_dibusb
op_star
id|dib
op_assign
id|urb-&gt;context
suffix:semicolon
id|deb_ts
c_func
(paren
l_string|&quot;urb complete feedcount: %d, status: %d&bslash;n&quot;
comma
id|dib-&gt;feedcount
comma
id|urb-&gt;status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dib-&gt;feedcount
OG
l_int|0
op_logical_and
id|urb-&gt;status
op_eq
l_int|0
)paren
(brace
id|deb_ts
c_func
(paren
l_string|&quot;URB return len: %d&bslash;n&quot;
comma
id|urb-&gt;actual_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|urb-&gt;actual_length
op_mod
l_int|188
)paren
id|deb_ts
c_func
(paren
l_string|&quot;TS Packets: %d, %d&bslash;n&quot;
comma
id|urb-&gt;actual_length
op_div
l_int|188
comma
id|urb-&gt;actual_length
op_mod
l_int|188
)paren
suffix:semicolon
multiline_comment|/* Francois recommends to drop not full-filled packets, even if they may &n;&t;&t; * contain valid TS packets&n;&t;&t; */
r_if
c_cond
(paren
id|urb-&gt;actual_length
op_eq
id|dib-&gt;dibdev-&gt;parm-&gt;default_size
op_logical_and
id|dib-&gt;dvb_is_ready
)paren
id|dvb_dmx_swfilter_packets
c_func
(paren
op_amp
id|dib-&gt;demux
comma
(paren
id|u8
op_star
)paren
id|urb-&gt;transfer_buffer
comma
id|urb-&gt;actual_length
op_div
l_int|188
)paren
suffix:semicolon
r_else
id|deb_ts
c_func
(paren
l_string|&quot;URB dropped because of the &quot;
l_string|&quot;actual_length or !dvb_is_ready (%d).&bslash;n&quot;
comma
id|dib-&gt;dvb_is_ready
)paren
suffix:semicolon
)brace
r_else
id|deb_ts
c_func
(paren
l_string|&quot;URB dropped because of feedcount or status.&bslash;n&quot;
)paren
suffix:semicolon
id|usb_submit_urb
c_func
(paren
id|urb
comma
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
DECL|function|dibusb_ctrl_feed
r_static
r_int
id|dibusb_ctrl_feed
c_func
(paren
r_struct
id|usb_dibusb
op_star
id|dib
comma
r_int
id|pid
comma
r_int
id|onoff
)paren
(brace
r_if
c_cond
(paren
id|dib-&gt;dibdev-&gt;parm-&gt;firmware_bug
op_logical_and
id|dib-&gt;feedcount
)paren
(brace
id|deb_ts
c_func
(paren
l_string|&quot;stop feeding&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dib-&gt;xfer_ops.fifo_ctrl
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|dib-&gt;xfer_ops
dot
id|fifo_ctrl
c_func
(paren
id|dib-&gt;fe
comma
l_int|0
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;error while inhibiting fifo.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
)brace
r_else
(brace
id|err
c_func
(paren
l_string|&quot;fifo_ctrl is not set.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
)brace
id|dib-&gt;feedcount
op_add_assign
id|onoff
ques
c_cond
l_int|1
suffix:colon
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|dib-&gt;xfer_ops.pid_ctrl
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|dib-&gt;xfer_ops
dot
id|pid_ctrl
c_func
(paren
id|dib-&gt;fe
comma
id|pid
comma
id|onoff
)paren
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;no free pid in list.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
)brace
r_else
(brace
id|err
c_func
(paren
l_string|&quot;no pid ctrl callback.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * start the feed, either if there is the firmware bug or&n;&t; * if this was the first pid to set.&n;&t; */
r_if
c_cond
(paren
id|dib-&gt;dibdev-&gt;parm-&gt;firmware_bug
op_logical_or
id|dib-&gt;feedcount
op_eq
id|onoff
)paren
(brace
id|deb_ts
c_func
(paren
l_string|&quot;start feeding&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dib-&gt;xfer_ops.fifo_ctrl
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|dib-&gt;xfer_ops
dot
id|fifo_ctrl
c_func
(paren
id|dib-&gt;fe
comma
l_int|1
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;error while enabling fifo.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
)brace
r_else
(brace
id|err
c_func
(paren
l_string|&quot;fifo_ctrl is not set.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dibusb_start_feed
r_static
r_int
id|dibusb_start_feed
c_func
(paren
r_struct
id|dvb_demux_feed
op_star
id|dvbdmxfeed
)paren
(brace
r_struct
id|usb_dibusb
op_star
id|dib
op_assign
id|dvbdmxfeed-&gt;demux-&gt;priv
suffix:semicolon
id|deb_ts
c_func
(paren
l_string|&quot;pid: 0x%04x, feedtype: %d&bslash;n&quot;
comma
id|dvbdmxfeed-&gt;pid
comma
id|dvbdmxfeed-&gt;type
)paren
suffix:semicolon
id|dvbdmxfeed-&gt;priv
op_assign
id|dib
suffix:semicolon
r_return
id|dibusb_ctrl_feed
c_func
(paren
id|dib
comma
id|dvbdmxfeed-&gt;pid
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|dibusb_stop_feed
r_static
r_int
id|dibusb_stop_feed
c_func
(paren
r_struct
id|dvb_demux_feed
op_star
id|dvbdmxfeed
)paren
(brace
r_struct
id|usb_dibusb
op_star
id|dib
op_assign
(paren
r_struct
id|usb_dibusb
op_star
)paren
id|dvbdmxfeed-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|dib
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
l_string|&quot;dib in dmxfeed-&gt;priv was NULL&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|deb_ts
c_func
(paren
l_string|&quot;dvbdmxfeed pid: 0x%04x, feedtype: %d&bslash;n&quot;
comma
id|dvbdmxfeed-&gt;pid
comma
id|dvbdmxfeed-&gt;type
)paren
suffix:semicolon
r_return
id|dibusb_ctrl_feed
c_func
(paren
id|dib
comma
id|dvbdmxfeed-&gt;pid
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Table to map raw key codes to key events.  This should not be hard-wired&n;   into the kernel.  */
DECL|member|c0
DECL|member|c1
DECL|member|c2
DECL|member|key
DECL|variable|rc_keys
r_static
r_const
r_struct
(brace
id|u8
id|c0
comma
id|c1
comma
id|c2
suffix:semicolon
r_uint32
id|key
suffix:semicolon
)brace
id|rc_keys
(braket
)braket
op_assign
(brace
multiline_comment|/* Key codes for the little Artec T1/Twinhan/HAMA/ remote. */
(brace
l_int|0x00
comma
l_int|0xff
comma
l_int|0x16
comma
id|KEY_POWER
)brace
comma
(brace
l_int|0x00
comma
l_int|0xff
comma
l_int|0x10
comma
id|KEY_MUTE
)brace
comma
(brace
l_int|0x00
comma
l_int|0xff
comma
l_int|0x03
comma
id|KEY_1
)brace
comma
(brace
l_int|0x00
comma
l_int|0xff
comma
l_int|0x01
comma
id|KEY_2
)brace
comma
(brace
l_int|0x00
comma
l_int|0xff
comma
l_int|0x06
comma
id|KEY_3
)brace
comma
(brace
l_int|0x00
comma
l_int|0xff
comma
l_int|0x09
comma
id|KEY_4
)brace
comma
(brace
l_int|0x00
comma
l_int|0xff
comma
l_int|0x1d
comma
id|KEY_5
)brace
comma
(brace
l_int|0x00
comma
l_int|0xff
comma
l_int|0x1f
comma
id|KEY_6
)brace
comma
(brace
l_int|0x00
comma
l_int|0xff
comma
l_int|0x0d
comma
id|KEY_7
)brace
comma
(brace
l_int|0x00
comma
l_int|0xff
comma
l_int|0x19
comma
id|KEY_8
)brace
comma
(brace
l_int|0x00
comma
l_int|0xff
comma
l_int|0x1b
comma
id|KEY_9
)brace
comma
(brace
l_int|0x00
comma
l_int|0xff
comma
l_int|0x15
comma
id|KEY_0
)brace
comma
(brace
l_int|0x00
comma
l_int|0xff
comma
l_int|0x05
comma
id|KEY_CHANNELUP
)brace
comma
(brace
l_int|0x00
comma
l_int|0xff
comma
l_int|0x02
comma
id|KEY_CHANNELDOWN
)brace
comma
(brace
l_int|0x00
comma
l_int|0xff
comma
l_int|0x1e
comma
id|KEY_VOLUMEUP
)brace
comma
(brace
l_int|0x00
comma
l_int|0xff
comma
l_int|0x0a
comma
id|KEY_VOLUMEDOWN
)brace
comma
(brace
l_int|0x00
comma
l_int|0xff
comma
l_int|0x11
comma
id|KEY_RECORD
)brace
comma
(brace
l_int|0x00
comma
l_int|0xff
comma
l_int|0x17
comma
id|KEY_FAVORITES
)brace
comma
multiline_comment|/* Heart symbol - Channel list. */
(brace
l_int|0x00
comma
l_int|0xff
comma
l_int|0x14
comma
id|KEY_PLAY
)brace
comma
(brace
l_int|0x00
comma
l_int|0xff
comma
l_int|0x1a
comma
id|KEY_STOP
)brace
comma
(brace
l_int|0x00
comma
l_int|0xff
comma
l_int|0x40
comma
id|KEY_REWIND
)brace
comma
(brace
l_int|0x00
comma
l_int|0xff
comma
l_int|0x12
comma
id|KEY_FASTFORWARD
)brace
comma
(brace
l_int|0x00
comma
l_int|0xff
comma
l_int|0x0e
comma
id|KEY_PREVIOUS
)brace
comma
multiline_comment|/* Recall - Previous channel. */
(brace
l_int|0x00
comma
l_int|0xff
comma
l_int|0x4c
comma
id|KEY_PAUSE
)brace
comma
(brace
l_int|0x00
comma
l_int|0xff
comma
l_int|0x4d
comma
id|KEY_SCREEN
)brace
comma
multiline_comment|/* Full screen mode. */
(brace
l_int|0x00
comma
l_int|0xff
comma
l_int|0x54
comma
id|KEY_AUDIO
)brace
comma
multiline_comment|/* MTS - Switch to secondary audio. */
multiline_comment|/* Key codes for the KWorld/ADSTech/JetWay remote. */
(brace
l_int|0x86
comma
l_int|0x6b
comma
l_int|0x12
comma
id|KEY_POWER
)brace
comma
(brace
l_int|0x86
comma
l_int|0x6b
comma
l_int|0x0f
comma
id|KEY_SELECT
)brace
comma
multiline_comment|/* source */
(brace
l_int|0x86
comma
l_int|0x6b
comma
l_int|0x0c
comma
id|KEY_UNKNOWN
)brace
comma
multiline_comment|/* scan */
(brace
l_int|0x86
comma
l_int|0x6b
comma
l_int|0x0b
comma
id|KEY_EPG
)brace
comma
(brace
l_int|0x86
comma
l_int|0x6b
comma
l_int|0x10
comma
id|KEY_MUTE
)brace
comma
(brace
l_int|0x86
comma
l_int|0x6b
comma
l_int|0x01
comma
id|KEY_1
)brace
comma
(brace
l_int|0x86
comma
l_int|0x6b
comma
l_int|0x02
comma
id|KEY_2
)brace
comma
(brace
l_int|0x86
comma
l_int|0x6b
comma
l_int|0x03
comma
id|KEY_3
)brace
comma
(brace
l_int|0x86
comma
l_int|0x6b
comma
l_int|0x04
comma
id|KEY_4
)brace
comma
(brace
l_int|0x86
comma
l_int|0x6b
comma
l_int|0x05
comma
id|KEY_5
)brace
comma
(brace
l_int|0x86
comma
l_int|0x6b
comma
l_int|0x06
comma
id|KEY_6
)brace
comma
(brace
l_int|0x86
comma
l_int|0x6b
comma
l_int|0x07
comma
id|KEY_7
)brace
comma
(brace
l_int|0x86
comma
l_int|0x6b
comma
l_int|0x08
comma
id|KEY_8
)brace
comma
(brace
l_int|0x86
comma
l_int|0x6b
comma
l_int|0x09
comma
id|KEY_9
)brace
comma
(brace
l_int|0x86
comma
l_int|0x6b
comma
l_int|0x0a
comma
id|KEY_0
)brace
comma
(brace
l_int|0x86
comma
l_int|0x6b
comma
l_int|0x18
comma
id|KEY_ZOOM
)brace
comma
(brace
l_int|0x86
comma
l_int|0x6b
comma
l_int|0x1c
comma
id|KEY_UNKNOWN
)brace
comma
multiline_comment|/* preview */
(brace
l_int|0x86
comma
l_int|0x6b
comma
l_int|0x13
comma
id|KEY_UNKNOWN
)brace
comma
multiline_comment|/* snap */
(brace
l_int|0x86
comma
l_int|0x6b
comma
l_int|0x00
comma
id|KEY_UNDO
)brace
comma
(brace
l_int|0x86
comma
l_int|0x6b
comma
l_int|0x1d
comma
id|KEY_RECORD
)brace
comma
(brace
l_int|0x86
comma
l_int|0x6b
comma
l_int|0x0d
comma
id|KEY_STOP
)brace
comma
(brace
l_int|0x86
comma
l_int|0x6b
comma
l_int|0x0e
comma
id|KEY_PAUSE
)brace
comma
(brace
l_int|0x86
comma
l_int|0x6b
comma
l_int|0x16
comma
id|KEY_PLAY
)brace
comma
(brace
l_int|0x86
comma
l_int|0x6b
comma
l_int|0x11
comma
id|KEY_BACK
)brace
comma
(brace
l_int|0x86
comma
l_int|0x6b
comma
l_int|0x19
comma
id|KEY_FORWARD
)brace
comma
(brace
l_int|0x86
comma
l_int|0x6b
comma
l_int|0x14
comma
id|KEY_UNKNOWN
)brace
comma
multiline_comment|/* pip */
(brace
l_int|0x86
comma
l_int|0x6b
comma
l_int|0x15
comma
id|KEY_ESC
)brace
comma
(brace
l_int|0x86
comma
l_int|0x6b
comma
l_int|0x1a
comma
id|KEY_UP
)brace
comma
(brace
l_int|0x86
comma
l_int|0x6b
comma
l_int|0x1e
comma
id|KEY_DOWN
)brace
comma
(brace
l_int|0x86
comma
l_int|0x6b
comma
l_int|0x1f
comma
id|KEY_LEFT
)brace
comma
(brace
l_int|0x86
comma
l_int|0x6b
comma
l_int|0x1b
comma
id|KEY_RIGHT
)brace
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Read the remote control and feed the appropriate event.&n; * NEC protocol is used for remote controls&n; */
DECL|function|dibusb_read_remote_control
r_static
r_int
id|dibusb_read_remote_control
c_func
(paren
r_struct
id|usb_dibusb
op_star
id|dib
)paren
(brace
id|u8
id|b
(braket
l_int|1
)braket
op_assign
(brace
id|DIBUSB_REQ_POLL_REMOTE
)brace
comma
id|rb
(braket
l_int|5
)braket
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|dibusb_readwrite_usb
c_func
(paren
id|dib
comma
id|b
comma
l_int|1
comma
id|rb
comma
l_int|5
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
r_switch
c_cond
(paren
id|rb
(braket
l_int|0
)braket
)paren
(brace
r_case
id|DIBUSB_RC_NEC_KEY_PRESSED
suffix:colon
multiline_comment|/* rb[1-3] is the actual key, rb[4] is a checksum */
id|deb_rc
c_func
(paren
l_string|&quot;raw key code 0x%02x, 0x%02x, 0x%02x, 0x%02x&bslash;n&quot;
comma
id|rb
(braket
l_int|1
)braket
comma
id|rb
(braket
l_int|2
)braket
comma
id|rb
(braket
l_int|3
)braket
comma
id|rb
(braket
l_int|4
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
l_int|0xff
op_minus
id|rb
(braket
l_int|3
)braket
)paren
op_ne
id|rb
(braket
l_int|4
)braket
)paren
(brace
id|deb_rc
c_func
(paren
l_string|&quot;remote control checksum failed.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* See if we can match the raw key code. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|rc_keys
)paren
op_div
r_sizeof
(paren
id|rc_keys
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|rc_keys
(braket
id|i
)braket
dot
id|c0
op_eq
id|rb
(braket
l_int|1
)braket
op_logical_and
id|rc_keys
(braket
id|i
)braket
dot
id|c1
op_eq
id|rb
(braket
l_int|2
)braket
op_logical_and
id|rc_keys
(braket
id|i
)braket
dot
id|c2
op_eq
id|rb
(braket
l_int|3
)braket
)paren
(brace
id|dib-&gt;rc_input_event
op_assign
id|rc_keys
(braket
id|i
)braket
dot
id|key
suffix:semicolon
id|deb_rc
c_func
(paren
l_string|&quot;Translated key 0x%04x&bslash;n&quot;
comma
id|dib-&gt;rc_input_event
)paren
suffix:semicolon
multiline_comment|/* Signal down and up events for this key. */
id|input_report_key
c_func
(paren
op_amp
id|dib-&gt;rc_input_dev
comma
id|dib-&gt;rc_input_event
comma
l_int|1
)paren
suffix:semicolon
id|input_report_key
c_func
(paren
op_amp
id|dib-&gt;rc_input_dev
comma
id|dib-&gt;rc_input_event
comma
l_int|0
)paren
suffix:semicolon
id|input_sync
c_func
(paren
op_amp
id|dib-&gt;rc_input_dev
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|DIBUSB_RC_NEC_EMPTY
suffix:colon
multiline_comment|/* No (more) remote control keys. */
r_break
suffix:semicolon
r_case
id|DIBUSB_RC_NEC_KEY_REPEATED
suffix:colon
multiline_comment|/* rb[1]..rb[4] are always zero.*/
multiline_comment|/* Repeats often seem to occur so for the moment just ignore this. */
id|deb_rc
c_func
(paren
l_string|&quot;Key repeat&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|RC_QUERY_INTERVAL
mdefine_line|#define RC_QUERY_INTERVAL (100)&t;/* milliseconds */
multiline_comment|/* Remote-control poll function - called every RC_QUERY_INTERVAL ms to see&n;   whether the remote control has received anything. */
DECL|function|dibusb_query_rc
r_static
r_void
id|dibusb_query_rc
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|usb_dibusb
op_star
id|dib
op_assign
(paren
r_struct
id|usb_dibusb
op_star
)paren
id|data
suffix:semicolon
multiline_comment|/* TODO: need a lock here.  We can simply skip checking for the remote control&n;&t;   if we&squot;re busy. */
id|dibusb_read_remote_control
c_func
(paren
id|dib
)paren
suffix:semicolon
id|schedule_delayed_work
c_func
(paren
op_amp
id|dib-&gt;rc_query_work
comma
id|msecs_to_jiffies
c_func
(paren
id|RC_QUERY_INTERVAL
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Cypress controls&n; */
macro_line|#if 0
multiline_comment|/*&n; * #if 0&squot;ing the following 5 functions as they are not in use _now_,&n; * but probably will be sometime.&n; */
r_static
r_int
id|dibusb_write_usb
c_func
(paren
r_struct
id|usb_dibusb
op_star
id|dib
comma
id|u8
op_star
id|buf
comma
id|u16
id|len
)paren
(brace
r_return
id|dibusb_readwrite_usb
c_func
(paren
id|dib
comma
id|buf
comma
id|len
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * do not use this, just a workaround for a bug,&n; * which will hopefully never occur :).&n; */
r_static
r_int
id|dibusb_interrupt_read_loop
c_func
(paren
r_struct
id|usb_dibusb
op_star
id|dib
)paren
(brace
id|u8
id|b
(braket
l_int|1
)braket
op_assign
(brace
id|DIBUSB_REQ_INTR_READ
)brace
suffix:semicolon
r_return
id|dibusb_write_usb
c_func
(paren
id|dib
comma
id|b
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ioctl for the firmware&n; */
r_static
r_int
id|dibusb_ioctl_cmd
c_func
(paren
r_struct
id|usb_dibusb
op_star
id|dib
comma
id|u8
id|cmd
comma
id|u8
op_star
id|param
comma
r_int
id|plen
)paren
(brace
id|u8
id|b
(braket
l_int|34
)braket
suffix:semicolon
r_int
id|size
op_assign
id|plen
OG
l_int|32
ques
c_cond
l_int|32
suffix:colon
id|plen
suffix:semicolon
id|b
(braket
l_int|0
)braket
op_assign
id|DIBUSB_REQ_SET_IOCTL
suffix:semicolon
id|b
(braket
l_int|1
)braket
op_assign
id|cmd
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|b
(braket
l_int|2
)braket
comma
id|param
comma
id|size
)paren
suffix:semicolon
r_return
id|dibusb_write_usb
c_func
(paren
id|dib
comma
id|b
comma
l_int|2
op_plus
id|size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ioctl for power control&n; */
r_static
r_int
id|dibusb_hw_sleep
c_func
(paren
r_struct
id|usb_dibusb
op_star
id|dib
)paren
(brace
id|u8
id|b
(braket
l_int|1
)braket
op_assign
(brace
id|DIBUSB_IOCTL_POWER_SLEEP
)brace
suffix:semicolon
r_return
id|dibusb_ioctl_cmd
c_func
(paren
id|dib
comma
id|DIBUSB_IOCTL_CMD_POWER_MODE
comma
id|b
comma
l_int|1
)paren
suffix:semicolon
)brace
r_static
r_int
id|dibusb_hw_wakeup
c_func
(paren
r_struct
id|usb_dibusb
op_star
id|dib
)paren
(brace
id|u8
id|b
(braket
l_int|1
)braket
op_assign
(brace
id|DIBUSB_IOCTL_POWER_WAKEUP
)brace
suffix:semicolon
r_return
id|dibusb_ioctl_cmd
c_func
(paren
id|dib
comma
id|DIBUSB_IOCTL_CMD_POWER_MODE
comma
id|b
comma
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * I2C&n; */
DECL|function|dibusb_i2c_xfer
r_static
r_int
id|dibusb_i2c_xfer
c_func
(paren
r_struct
id|i2c_adapter
op_star
id|adap
comma
r_struct
id|i2c_msg
id|msg
(braket
)braket
comma
r_int
id|num
)paren
(brace
r_struct
id|usb_dibusb
op_star
id|dib
op_assign
id|i2c_get_adapdata
c_func
(paren
id|adap
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|down_interruptible
c_func
(paren
op_amp
id|dib-&gt;i2c_sem
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* write/read request */
r_if
c_cond
(paren
id|i
op_plus
l_int|1
OL
id|num
op_logical_and
(paren
id|msg
(braket
id|i
op_plus
l_int|1
)braket
dot
id|flags
op_amp
id|I2C_M_RD
)paren
)paren
(brace
r_if
c_cond
(paren
id|dibusb_i2c_msg
c_func
(paren
id|dib
comma
id|msg
(braket
id|i
)braket
dot
id|addr
comma
id|msg
(braket
id|i
)braket
dot
id|buf
comma
id|msg
(braket
id|i
)braket
dot
id|len
comma
id|msg
(braket
id|i
op_plus
l_int|1
)braket
dot
id|buf
comma
id|msg
(braket
id|i
op_plus
l_int|1
)braket
dot
id|len
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dibusb_i2c_msg
c_func
(paren
id|dib
comma
id|msg
(braket
id|i
)braket
dot
id|addr
comma
id|msg
(braket
id|i
)braket
dot
id|buf
comma
id|msg
(braket
id|i
)braket
dot
id|len
comma
l_int|NULL
comma
l_int|0
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|dib-&gt;i2c_sem
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
DECL|function|dibusb_i2c_func
r_static
id|u32
id|dibusb_i2c_func
c_func
(paren
r_struct
id|i2c_adapter
op_star
id|adapter
)paren
(brace
r_return
id|I2C_FUNC_I2C
suffix:semicolon
)brace
r_static
r_int
id|thomson_cable_eu_pll_set
c_func
(paren
r_struct
id|dvb_frontend
op_star
id|fe
comma
r_struct
id|dvb_frontend_parameters
op_star
id|params
)paren
suffix:semicolon
DECL|variable|thomson_cable_eu_config
r_static
r_struct
id|dib3000_config
id|thomson_cable_eu_config
op_assign
(brace
dot
id|demod_address
op_assign
l_int|0x10
comma
dot
id|pll_addr
op_assign
l_int|194
comma
dot
id|pll_set
op_assign
id|thomson_cable_eu_pll_set
comma
)brace
suffix:semicolon
DECL|function|thomson_cable_eu_pll_set
r_static
r_int
id|thomson_cable_eu_pll_set
c_func
(paren
r_struct
id|dvb_frontend
op_star
id|fe
comma
r_struct
id|dvb_frontend_parameters
op_star
id|params
)paren
(brace
r_struct
id|usb_dibusb
op_star
id|dib
op_assign
(paren
r_struct
id|usb_dibusb
op_star
)paren
id|fe-&gt;dvb-&gt;priv
suffix:semicolon
id|u8
id|buf
(braket
l_int|4
)braket
suffix:semicolon
r_struct
id|i2c_msg
id|msg
op_assign
(brace
dot
id|addr
op_assign
id|thomson_cable_eu_config.pll_addr
comma
dot
id|flags
op_assign
l_int|0
comma
dot
id|buf
op_assign
id|buf
comma
dot
id|len
op_assign
r_sizeof
(paren
id|buf
)paren
)brace
suffix:semicolon
id|u32
id|tfreq
op_assign
(paren
id|params-&gt;frequency
op_plus
l_int|36125000
)paren
op_div
l_int|62500
suffix:semicolon
r_int
id|vu
comma
id|p0
comma
id|p1
comma
id|p2
suffix:semicolon
r_if
c_cond
(paren
id|params-&gt;frequency
OG
l_int|403250000
)paren
id|vu
op_assign
l_int|1
comma
id|p2
op_assign
l_int|1
comma
id|p1
op_assign
l_int|0
comma
id|p0
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|params-&gt;frequency
OG
l_int|115750000
)paren
id|vu
op_assign
l_int|0
comma
id|p2
op_assign
l_int|1
comma
id|p1
op_assign
l_int|1
comma
id|p0
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|params-&gt;frequency
OG
l_int|44250000
)paren
id|vu
op_assign
l_int|0
comma
id|p2
op_assign
l_int|0
comma
id|p1
op_assign
l_int|1
comma
id|p0
op_assign
l_int|1
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
id|buf
(braket
l_int|0
)braket
op_assign
(paren
id|tfreq
op_rshift
l_int|8
)paren
op_amp
l_int|0x7f
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_assign
id|tfreq
op_amp
l_int|0xff
suffix:semicolon
id|buf
(braket
l_int|2
)braket
op_assign
l_int|0x8e
suffix:semicolon
id|buf
(braket
l_int|3
)braket
op_assign
(paren
id|vu
op_lshift
l_int|7
)paren
op_or
(paren
id|p2
op_lshift
l_int|2
)paren
op_or
(paren
id|p1
op_lshift
l_int|1
)paren
op_or
id|p0
suffix:semicolon
r_if
c_cond
(paren
id|i2c_transfer
(paren
op_amp
id|dib-&gt;i2c_adap
comma
op_amp
id|msg
comma
l_int|1
)paren
op_ne
l_int|1
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|msleep
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|dibusb_algo
r_static
r_struct
id|i2c_algorithm
id|dibusb_algo
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;DiBcom USB i2c algorithm&quot;
comma
dot
id|id
op_assign
id|I2C_ALGO_BIT
comma
dot
id|master_xfer
op_assign
id|dibusb_i2c_xfer
comma
dot
id|functionality
op_assign
id|dibusb_i2c_func
comma
)brace
suffix:semicolon
DECL|function|frontend_init
r_static
r_void
id|frontend_init
c_func
(paren
r_struct
id|usb_dibusb
op_star
id|dib
)paren
(brace
id|dib-&gt;fe
op_assign
id|dib3000mb_attach
c_func
(paren
op_amp
id|thomson_cable_eu_config
comma
op_amp
id|dib-&gt;i2c_adap
comma
op_amp
id|dib-&gt;xfer_ops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dib-&gt;fe
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;dvb-dibusb: A frontend driver was not found for device %04x/%04x&bslash;n&quot;
comma
id|dib-&gt;udev-&gt;descriptor.idVendor
comma
id|dib-&gt;udev-&gt;descriptor.idProduct
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|dvb_register_frontend
c_func
(paren
id|dib-&gt;adapter
comma
id|dib-&gt;fe
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;dvb-dibusb: Frontend registration failed!&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dib-&gt;fe-&gt;ops-&gt;release
)paren
id|dib-&gt;fe-&gt;ops
op_member_access_from_pointer
id|release
c_func
(paren
id|dib-&gt;fe
)paren
suffix:semicolon
id|dib-&gt;fe
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
DECL|function|dibusb_dvb_init
r_static
r_int
id|dibusb_dvb_init
c_func
(paren
r_struct
id|usb_dibusb
op_star
id|dib
)paren
(brace
r_int
id|ret
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &lt;= KERNEL_VERSION(2,6,4)
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|dvb_register_adapter
c_func
(paren
op_amp
id|dib-&gt;adapter
comma
id|DRIVER_DESC
)paren
)paren
OL
l_int|0
)paren
(brace
macro_line|#else
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|dvb_register_adapter
c_func
(paren
op_amp
id|dib-&gt;adapter
comma
id|DRIVER_DESC
comma
id|THIS_MODULE
)paren
)paren
OL
l_int|0
)paren
(brace
macro_line|#endif
id|deb_info
c_func
(paren
l_string|&quot;dvb_register_adapter failed: error %d&quot;
comma
id|ret
)paren
suffix:semicolon
r_goto
id|err
suffix:semicolon
)brace
id|dib-&gt;adapter-&gt;priv
op_assign
id|dib
suffix:semicolon
id|strncpy
c_func
(paren
id|dib-&gt;i2c_adap.name
comma
id|dib-&gt;dibdev-&gt;name
comma
id|I2C_NAME_SIZE
)paren
suffix:semicolon
macro_line|#ifdef I2C_ADAP_CLASS_TV_DIGITAL
id|dib-&gt;i2c_adap
dot
r_class
op_assign
id|I2C_ADAP_CLASS_TV_DIGITAL
comma
macro_line|#else
id|dib-&gt;i2c_adap
dot
r_class
op_assign
id|I2C_CLASS_TV_DIGITAL
comma
macro_line|#endif
id|dib-&gt;i2c_adap.algo
op_assign
op_amp
id|dibusb_algo
suffix:semicolon
id|dib-&gt;i2c_adap.algo_data
op_assign
l_int|NULL
suffix:semicolon
id|dib-&gt;i2c_adap.id
op_assign
id|I2C_ALGO_BIT
suffix:semicolon
id|i2c_set_adapdata
c_func
(paren
op_amp
id|dib-&gt;i2c_adap
comma
id|dib
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i2c_add_adapter
c_func
(paren
op_amp
id|dib-&gt;i2c_adap
)paren
OL
l_int|0
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;could not add i2c adapter&quot;
)paren
suffix:semicolon
r_goto
id|err_i2c
suffix:semicolon
)brace
id|dib-&gt;demux.dmx.capabilities
op_assign
id|DMX_TS_FILTERING
op_or
id|DMX_SECTION_FILTERING
suffix:semicolon
id|dib-&gt;demux.priv
op_assign
(paren
r_void
op_star
)paren
id|dib
suffix:semicolon
multiline_comment|/* get pidcount from demod */
id|dib-&gt;demux.feednum
op_assign
id|dib-&gt;demux.filternum
op_assign
l_int|16
suffix:semicolon
id|dib-&gt;demux.start_feed
op_assign
id|dibusb_start_feed
suffix:semicolon
id|dib-&gt;demux.stop_feed
op_assign
id|dibusb_stop_feed
suffix:semicolon
id|dib-&gt;demux.write_to_decoder
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|dvb_dmx_init
c_func
(paren
op_amp
id|dib-&gt;demux
)paren
)paren
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;dvb_dmx_init failed: error %d&quot;
comma
id|ret
)paren
suffix:semicolon
r_goto
id|err_dmx
suffix:semicolon
)brace
id|dib-&gt;dmxdev.filternum
op_assign
id|dib-&gt;demux.filternum
suffix:semicolon
id|dib-&gt;dmxdev.demux
op_assign
op_amp
id|dib-&gt;demux.dmx
suffix:semicolon
id|dib-&gt;dmxdev.capabilities
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|dvb_dmxdev_init
c_func
(paren
op_amp
id|dib-&gt;dmxdev
comma
id|dib-&gt;adapter
)paren
)paren
OL
l_int|0
)paren
(brace
id|err
c_func
(paren
l_string|&quot;dvb_dmxdev_init failed: error %d&quot;
comma
id|ret
)paren
suffix:semicolon
r_goto
id|err_dmx_dev
suffix:semicolon
)brace
id|dvb_net_init
c_func
(paren
id|dib-&gt;adapter
comma
op_amp
id|dib-&gt;dvb_net
comma
op_amp
id|dib-&gt;demux.dmx
)paren
suffix:semicolon
id|frontend_init
c_func
(paren
id|dib
)paren
suffix:semicolon
multiline_comment|/* Start the remote-control polling. */
id|schedule_delayed_work
c_func
(paren
op_amp
id|dib-&gt;rc_query_work
comma
id|msecs_to_jiffies
c_func
(paren
id|RC_QUERY_INTERVAL
)paren
)paren
suffix:semicolon
r_goto
id|success
suffix:semicolon
id|err_dmx_dev
suffix:colon
id|dvb_dmx_release
c_func
(paren
op_amp
id|dib-&gt;demux
)paren
suffix:semicolon
id|err_dmx
suffix:colon
id|i2c_del_adapter
c_func
(paren
op_amp
id|dib-&gt;i2c_adap
)paren
suffix:semicolon
id|err_i2c
suffix:colon
id|dvb_unregister_adapter
c_func
(paren
id|dib-&gt;adapter
)paren
suffix:semicolon
id|err
suffix:colon
r_return
id|ret
suffix:semicolon
id|success
suffix:colon
id|dib-&gt;dvb_is_ready
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dibusb_dvb_exit
r_static
r_int
id|dibusb_dvb_exit
c_func
(paren
r_struct
id|usb_dibusb
op_star
id|dib
)paren
(brace
id|cancel_delayed_work
c_func
(paren
op_amp
id|dib-&gt;rc_query_work
)paren
suffix:semicolon
id|flush_scheduled_work
c_func
(paren
)paren
suffix:semicolon
id|input_unregister_device
c_func
(paren
op_amp
id|dib-&gt;rc_input_dev
)paren
suffix:semicolon
id|dib-&gt;dvb_is_ready
op_assign
l_int|0
suffix:semicolon
id|deb_info
c_func
(paren
l_string|&quot;unregistering DVB part&bslash;n&quot;
)paren
suffix:semicolon
id|dvb_net_release
c_func
(paren
op_amp
id|dib-&gt;dvb_net
)paren
suffix:semicolon
id|dib-&gt;demux.dmx
dot
id|close
c_func
(paren
op_amp
id|dib-&gt;demux.dmx
)paren
suffix:semicolon
id|dvb_dmxdev_release
c_func
(paren
op_amp
id|dib-&gt;dmxdev
)paren
suffix:semicolon
id|dvb_dmx_release
c_func
(paren
op_amp
id|dib-&gt;demux
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dib-&gt;fe
op_ne
l_int|NULL
)paren
id|dvb_unregister_frontend
c_func
(paren
id|dib-&gt;fe
)paren
suffix:semicolon
id|i2c_del_adapter
c_func
(paren
op_amp
id|dib-&gt;i2c_adap
)paren
suffix:semicolon
id|dvb_unregister_adapter
c_func
(paren
id|dib-&gt;adapter
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dibusb_exit
r_static
r_int
id|dibusb_exit
c_func
(paren
r_struct
id|usb_dibusb
op_star
id|dib
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|dib-&gt;urb_list
op_ne
l_int|NULL
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dib-&gt;dibdev-&gt;parm-&gt;num_urbs
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dib-&gt;urb_list
(braket
id|i
)braket
op_ne
l_int|NULL
)paren
(brace
id|deb_info
c_func
(paren
l_string|&quot;killing URB no. %d.&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
multiline_comment|/* stop the URBs */
macro_line|#if LINUX_VERSION_CODE &lt;= KERNEL_VERSION(2,6,7)
id|usb_unlink_urb
c_func
(paren
id|dib-&gt;urb_list
(braket
id|i
)braket
)paren
suffix:semicolon
macro_line|#else
id|usb_kill_urb
c_func
(paren
id|dib-&gt;urb_list
(braket
id|i
)braket
)paren
suffix:semicolon
macro_line|#endif
id|deb_info
c_func
(paren
l_string|&quot;freeing URB no. %d.&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
multiline_comment|/* free the URBs */
id|usb_free_urb
c_func
(paren
id|dib-&gt;urb_list
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* free the urb array */
id|kfree
c_func
(paren
id|dib-&gt;urb_list
)paren
suffix:semicolon
)brace
id|pci_free_consistent
c_func
(paren
l_int|NULL
comma
id|dib-&gt;dibdev-&gt;parm-&gt;urb_buf_size
op_star
id|dib-&gt;dibdev-&gt;parm-&gt;num_urbs
comma
id|dib-&gt;buffer
comma
id|dib-&gt;dma_handle
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dibusb_init
r_static
r_int
id|dibusb_init
c_func
(paren
r_struct
id|usb_dibusb
op_star
id|dib
)paren
(brace
r_int
id|ret
comma
id|i
comma
id|bufsize
suffix:semicolon
id|sema_init
c_func
(paren
op_amp
id|dib-&gt;usb_sem
comma
l_int|1
)paren
suffix:semicolon
id|sema_init
c_func
(paren
op_amp
id|dib-&gt;i2c_sem
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * when reloading the driver w/o replugging the device&n;&t; * a timeout occures, this helps&n;&t; */
id|usb_clear_halt
c_func
(paren
id|dib-&gt;udev
comma
id|usb_sndbulkpipe
c_func
(paren
id|dib-&gt;udev
comma
id|dib-&gt;dibdev-&gt;parm-&gt;cmd_pipe
)paren
)paren
suffix:semicolon
id|usb_clear_halt
c_func
(paren
id|dib-&gt;udev
comma
id|usb_rcvbulkpipe
c_func
(paren
id|dib-&gt;udev
comma
id|dib-&gt;dibdev-&gt;parm-&gt;result_pipe
)paren
)paren
suffix:semicolon
id|usb_clear_halt
c_func
(paren
id|dib-&gt;udev
comma
id|usb_rcvbulkpipe
c_func
(paren
id|dib-&gt;udev
comma
id|dib-&gt;dibdev-&gt;parm-&gt;data_pipe
)paren
)paren
suffix:semicolon
multiline_comment|/* allocate the array for the data transfer URBs */
id|dib-&gt;urb_list
op_assign
id|kmalloc
c_func
(paren
id|dib-&gt;dibdev-&gt;parm-&gt;num_urbs
op_star
r_sizeof
(paren
r_struct
id|urb
op_star
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dib-&gt;urb_list
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|dib-&gt;urb_list
comma
l_int|0
comma
id|dib-&gt;dibdev-&gt;parm-&gt;num_urbs
op_star
r_sizeof
(paren
r_struct
id|urb
op_star
)paren
)paren
suffix:semicolon
id|bufsize
op_assign
id|dib-&gt;dibdev-&gt;parm-&gt;num_urbs
op_star
id|dib-&gt;dibdev-&gt;parm-&gt;urb_buf_size
suffix:semicolon
id|deb_info
c_func
(paren
l_string|&quot;allocate %d bytes as buffersize for all URBs&bslash;n&quot;
comma
id|bufsize
)paren
suffix:semicolon
multiline_comment|/* allocate the actual buffer for the URBs */
r_if
c_cond
(paren
(paren
id|dib-&gt;buffer
op_assign
id|pci_alloc_consistent
c_func
(paren
l_int|NULL
comma
id|bufsize
comma
op_amp
id|dib-&gt;dma_handle
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|dibusb_exit
c_func
(paren
id|dib
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|dib-&gt;buffer
comma
l_int|0
comma
id|bufsize
)paren
suffix:semicolon
multiline_comment|/* allocate and submit the URBs */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dib-&gt;dibdev-&gt;parm-&gt;num_urbs
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dib-&gt;urb_list
(braket
id|i
)braket
op_assign
id|usb_alloc_urb
c_func
(paren
l_int|0
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|dibusb_exit
c_func
(paren
id|dib
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|deb_info
c_func
(paren
l_string|&quot;submitting URB no. %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|usb_fill_bulk_urb
c_func
(paren
id|dib-&gt;urb_list
(braket
id|i
)braket
comma
id|dib-&gt;udev
comma
id|usb_rcvbulkpipe
c_func
(paren
id|dib-&gt;udev
comma
id|dib-&gt;dibdev-&gt;parm-&gt;data_pipe
)paren
comma
op_amp
id|dib-&gt;buffer
(braket
id|i
op_star
id|dib-&gt;dibdev-&gt;parm-&gt;urb_buf_size
)braket
comma
id|dib-&gt;dibdev-&gt;parm-&gt;urb_buf_size
comma
id|dibusb_urb_complete
comma
id|dib
)paren
suffix:semicolon
id|dib-&gt;urb_list
(braket
id|i
)braket
op_member_access_from_pointer
id|transfer_flags
op_assign
l_int|0
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &lt;= KERNEL_VERSION(2,6,7)
id|dib-&gt;urb_list
(braket
id|i
)braket
op_member_access_from_pointer
id|timeout
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|usb_submit_urb
c_func
(paren
id|dib-&gt;urb_list
(braket
id|i
)braket
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;could not submit buffer urb no. %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|dibusb_exit
c_func
(paren
id|dib
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
)brace
id|dib-&gt;dvb_is_ready
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Initialise the remote-control structures.*/
id|init_input_dev
c_func
(paren
op_amp
id|dib-&gt;rc_input_dev
)paren
suffix:semicolon
id|dib-&gt;rc_input_dev.evbit
(braket
l_int|0
)braket
op_assign
id|BIT
c_func
(paren
id|EV_KEY
)paren
suffix:semicolon
id|dib-&gt;rc_input_dev.keycodesize
op_assign
r_sizeof
(paren
r_int
r_char
)paren
suffix:semicolon
id|dib-&gt;rc_input_dev.keycodemax
op_assign
id|KEY_MAX
suffix:semicolon
id|dib-&gt;rc_input_dev.name
op_assign
id|DRIVER_DESC
l_string|&quot; remote control&quot;
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|rc_keys
)paren
op_div
r_sizeof
(paren
id|rc_keys
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
id|set_bit
c_func
(paren
id|rc_keys
(braket
id|i
)braket
dot
id|key
comma
id|dib-&gt;rc_input_dev.keybit
)paren
suffix:semicolon
id|input_register_device
c_func
(paren
op_amp
id|dib-&gt;rc_input_dev
)paren
suffix:semicolon
id|dib-&gt;rc_input_event
op_assign
id|KEY_MAX
suffix:semicolon
id|INIT_WORK
c_func
(paren
op_amp
id|dib-&gt;rc_query_work
comma
id|dibusb_query_rc
comma
id|dib
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|dibusb_dvb_init
c_func
(paren
id|dib
)paren
)paren
)paren
(brace
id|dibusb_exit
c_func
(paren
id|dib
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * load a firmware packet to the device&n; */
DECL|function|dibusb_writemem
r_static
r_int
id|dibusb_writemem
c_func
(paren
r_struct
id|usb_device
op_star
id|udev
comma
id|u16
id|addr
comma
id|u8
op_star
id|data
comma
id|u8
id|len
)paren
(brace
r_return
id|usb_control_msg
c_func
(paren
id|udev
comma
id|usb_sndctrlpipe
c_func
(paren
id|udev
comma
l_int|0
)paren
comma
l_int|0xa0
comma
id|USB_TYPE_VENDOR
comma
id|addr
comma
l_int|0x00
comma
id|data
comma
id|len
comma
l_int|5
op_star
id|HZ
)paren
suffix:semicolon
)brace
DECL|function|dibusb_loadfirmware
r_static
r_int
id|dibusb_loadfirmware
c_func
(paren
r_struct
id|usb_device
op_star
id|udev
comma
r_struct
id|dibusb_device
op_star
id|dibdev
)paren
(brace
r_const
r_struct
id|firmware
op_star
id|fw
op_assign
l_int|NULL
suffix:semicolon
r_const
r_char
op_star
op_star
id|fws
suffix:semicolon
id|u16
id|addr
suffix:semicolon
id|u8
op_star
id|b
comma
op_star
id|p
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
comma
id|i
suffix:semicolon
id|fws
op_assign
id|dibdev-&gt;parm-&gt;fw_filenames
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|fws
)paren
op_div
r_sizeof
(paren
r_const
r_char
op_star
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|request_firmware
c_func
(paren
op_amp
id|fw
comma
id|fws
(braket
id|i
)braket
comma
op_amp
id|udev-&gt;dev
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|info
c_func
(paren
l_string|&quot;using firmware file (%s).&quot;
comma
id|fws
(braket
id|i
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|deb_info
c_func
(paren
l_string|&quot;tried to find &squot;%s&squot; firmware - unsuccessful. (%d)&bslash;n&quot;
comma
id|fws
(braket
id|i
)braket
comma
id|ret
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fw
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
l_string|&quot;did not find a valid firmware file. &quot;
l_string|&quot;Please see linux/Documentation/dvb/ for more details on firmware-problems.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|p
op_assign
id|kmalloc
c_func
(paren
id|fw-&gt;size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_ne
l_int|NULL
)paren
(brace
id|u8
id|reset
suffix:semicolon
multiline_comment|/*&n;&t;&t; * you cannot use the fw-&gt;data as buffer for&n;&t;&t; * usb_control_msg, a new buffer has to be&n;&t;&t; * created&n;&t;&t; */
id|memcpy
c_func
(paren
id|p
comma
id|fw-&gt;data
comma
id|fw-&gt;size
)paren
suffix:semicolon
multiline_comment|/* stop the CPU */
id|reset
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|dibusb_writemem
c_func
(paren
id|udev
comma
id|dibdev-&gt;parm-&gt;usb_cpu_csreg
comma
op_amp
id|reset
comma
l_int|1
)paren
)paren
op_ne
l_int|1
)paren
id|err
c_func
(paren
l_string|&quot;could not stop the USB controller CPU.&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|p
(braket
id|i
op_plus
l_int|3
)braket
op_eq
l_int|0
op_logical_and
id|i
OL
id|fw-&gt;size
suffix:semicolon
)paren
(brace
id|b
op_assign
(paren
id|u8
op_star
)paren
op_amp
id|p
(braket
id|i
)braket
suffix:semicolon
id|addr
op_assign
op_star
(paren
(paren
id|u16
op_star
)paren
op_amp
id|b
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|ret
op_assign
id|dibusb_writemem
c_func
(paren
id|udev
comma
id|addr
comma
op_amp
id|b
(braket
l_int|4
)braket
comma
id|b
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
id|b
(braket
l_int|0
)braket
)paren
(brace
id|err
c_func
(paren
l_string|&quot;error while transferring firmware &quot;
l_string|&quot;(transferred size: %d, block size: %d)&quot;
comma
id|ret
comma
id|b
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|i
op_add_assign
l_int|5
op_plus
id|b
(braket
l_int|0
)braket
suffix:semicolon
)brace
multiline_comment|/* length in ret */
r_if
c_cond
(paren
id|ret
OG
l_int|0
)paren
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* restart the CPU */
id|reset
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_logical_or
id|dibusb_writemem
c_func
(paren
id|udev
comma
id|dibdev-&gt;parm-&gt;usb_cpu_csreg
comma
op_amp
id|reset
comma
l_int|1
)paren
op_ne
l_int|1
)paren
(brace
id|err
c_func
(paren
l_string|&quot;could not restart the USB controller CPU.&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|release_firmware
c_func
(paren
id|fw
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * USB&n; */
DECL|function|dibusb_probe
r_static
r_int
id|dibusb_probe
c_func
(paren
r_struct
id|usb_interface
op_star
id|intf
comma
r_const
r_struct
id|usb_device_id
op_star
id|id
)paren
(brace
r_struct
id|usb_device
op_star
id|udev
op_assign
id|interface_to_usbdev
c_func
(paren
id|intf
)paren
suffix:semicolon
r_struct
id|usb_dibusb
op_star
id|dib
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|dibusb_device
op_star
id|dibdev
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|ENOMEM
comma
id|i
comma
id|cold
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DIBUSB_SUPPORTED_DEVICES
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|dibusb_devices
(braket
id|i
)braket
dot
id|cold_product_id
op_eq
id|udev-&gt;descriptor.idProduct
op_logical_or
id|dibusb_devices
(braket
id|i
)braket
dot
id|warm_product_id
op_eq
id|udev-&gt;descriptor.idProduct
)paren
(brace
id|dibdev
op_assign
op_amp
id|dibusb_devices
(braket
id|i
)braket
suffix:semicolon
id|cold
op_assign
id|dibdev-&gt;cold_product_id
op_eq
id|udev-&gt;descriptor.idProduct
suffix:semicolon
r_if
c_cond
(paren
id|cold
)paren
id|info
c_func
(paren
l_string|&quot;found a &squot;%s&squot; in cold state, will try to load a firmware&quot;
comma
id|dibdev-&gt;name
)paren
suffix:semicolon
r_else
id|info
c_func
(paren
l_string|&quot;found a &squot;%s&squot; in warm state.&quot;
comma
id|dibdev-&gt;name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dibdev
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
l_string|&quot;something went very wrong, &quot;
l_string|&quot;unknown product ID: %.4x&quot;
comma
id|udev-&gt;descriptor.idProduct
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cold
)paren
id|ret
op_assign
id|dibusb_loadfirmware
c_func
(paren
id|udev
comma
id|dibdev
)paren
suffix:semicolon
r_else
(brace
r_switch
c_cond
(paren
id|udev-&gt;speed
)paren
(brace
r_case
id|USB_SPEED_LOW
suffix:colon
id|err
c_func
(paren
l_string|&quot;cannot handle USB speed because it is to sLOW.&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_SPEED_FULL
suffix:colon
id|info
c_func
(paren
l_string|&quot;running at FULL speed, will use pid filter.&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_SPEED_HIGH
suffix:colon
id|info
c_func
(paren
l_string|&quot;running at HIGH speed, will deliver the complete TS.&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|USB_SPEED_UNKNOWN
suffix:colon
multiline_comment|/* fall through */
r_default
suffix:colon
id|err
c_func
(paren
l_string|&quot;cannot handle USB speed because it is unkown.&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|dib
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|usb_dibusb
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dib
op_eq
l_int|NULL
)paren
(brace
id|err
c_func
(paren
l_string|&quot;no memory&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|memset
c_func
(paren
id|dib
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|usb_dibusb
)paren
)paren
suffix:semicolon
id|dib-&gt;udev
op_assign
id|udev
suffix:semicolon
id|dib-&gt;dibdev
op_assign
id|dibdev
suffix:semicolon
id|usb_set_intfdata
c_func
(paren
id|intf
comma
id|dib
)paren
suffix:semicolon
id|ret
op_assign
id|dibusb_init
c_func
(paren
id|dib
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|info
c_func
(paren
l_string|&quot;%s successfully initialized and connected.&quot;
comma
id|dibdev-&gt;name
)paren
suffix:semicolon
r_else
id|info
c_func
(paren
l_string|&quot;%s error while loading driver (%d)&quot;
comma
id|dibdev-&gt;name
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|dibusb_disconnect
r_static
r_void
id|dibusb_disconnect
c_func
(paren
r_struct
id|usb_interface
op_star
id|intf
)paren
(brace
r_struct
id|usb_dibusb
op_star
id|dib
op_assign
id|usb_get_intfdata
c_func
(paren
id|intf
)paren
suffix:semicolon
r_const
r_char
op_star
id|name
op_assign
id|DRIVER_DESC
suffix:semicolon
id|usb_set_intfdata
c_func
(paren
id|intf
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dib
op_ne
l_int|NULL
)paren
(brace
id|name
op_assign
id|dib-&gt;dibdev-&gt;name
suffix:semicolon
id|dibusb_dvb_exit
c_func
(paren
id|dib
)paren
suffix:semicolon
id|dibusb_exit
c_func
(paren
id|dib
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dib
)paren
suffix:semicolon
)brace
id|info
c_func
(paren
l_string|&quot;%s successfully deinitialized and disconnected.&quot;
comma
id|name
)paren
suffix:semicolon
)brace
multiline_comment|/* usb specific object needed to register this driver with the usb subsystem */
DECL|variable|dibusb_driver
r_static
r_struct
id|usb_driver
id|dibusb_driver
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|name
op_assign
l_string|&quot;dvb_dibusb&quot;
comma
dot
id|probe
op_assign
id|dibusb_probe
comma
dot
id|disconnect
op_assign
id|dibusb_disconnect
comma
dot
id|id_table
op_assign
id|dibusb_table
comma
)brace
suffix:semicolon
multiline_comment|/* module stuff */
DECL|function|usb_dibusb_init
r_static
r_int
id|__init
id|usb_dibusb_init
c_func
(paren
r_void
)paren
(brace
r_int
id|result
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|usb_register
c_func
(paren
op_amp
id|dibusb_driver
)paren
)paren
)paren
(brace
id|err
c_func
(paren
l_string|&quot;usb_register failed. Error number %d&quot;
comma
id|result
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|usb_dibusb_exit
r_static
r_void
id|__exit
id|usb_dibusb_exit
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* deregister this driver from the USB subsystem */
id|usb_deregister
c_func
(paren
op_amp
id|dibusb_driver
)paren
suffix:semicolon
)brace
DECL|variable|usb_dibusb_init
id|module_init
(paren
id|usb_dibusb_init
)paren
suffix:semicolon
DECL|variable|usb_dibusb_exit
id|module_exit
(paren
id|usb_dibusb_exit
)paren
suffix:semicolon
DECL|variable|DRIVER_AUTHOR
id|MODULE_AUTHOR
c_func
(paren
id|DRIVER_AUTHOR
)paren
suffix:semicolon
DECL|variable|DRIVER_DESC
id|MODULE_DESCRIPTION
c_func
(paren
id|DRIVER_DESC
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
