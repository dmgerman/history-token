multiline_comment|/* &n; * dvb_net.c&n; *&n; * Copyright (C) 2001 Convergence integrated media GmbH&n; *                    Ralph Metzler &lt;ralph@convergence.de&gt;&n; * Copyright (C) 2002 Ralph Metzler &lt;rjkm@metzlerbros.de&gt;&n; *&n; * ULE Decapsulation code:&n; * Copyright (C) 2003, 2004 gcs - Global Communication &amp; Services GmbH.&n; *                      and Department of Scientific Computing&n; *                          Paris Lodron University of Salzburg.&n; *                    Hilmar Linder &lt;hlinder@cosy.sbg.ac.at&gt;&n; *                and Wolfram Stering &lt;wstering@cosy.sbg.ac.at&gt;&n; *&n; * ULE Decaps according to draft-ietf-ipdvb-ule-03.txt.&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version 2&n; * of the License, or (at your option) any later version.&n; * &n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; * &n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.&n; * Or, point your browser to http://www.gnu.org/copyleft/gpl.html&n; */
multiline_comment|/*&n; * ULE ChangeLog:&n; * Feb 2004: hl/ws v1: Implementing draft-fair-ipdvb-ule-01.txt&n; *&n; * Dec 2004: hl/ws v2: Implementing draft-ietf-ipdvb-ule-03.txt:&n; *                       ULE Extension header handling.&n; *                     Bugreports by Moritz Vieth and Hanno Tersteegen,&n; *                       Fraunhofer Institute for Open Communication Systems&n; *                       Competence Center for Advanced Satellite Communications.&n; *                     Bugfixes and robustness improvements.&n; *                     Filtering on dest MAC addresses, if present (D-Bit = 0)&n; *                     ULE_DEBUG compile-time option.&n; */
multiline_comment|/*&n; * FIXME / TODO (dvb_net.c):&n; *&n; * Unloading does not work for 2.6.9 kernels: a refcount doesn&squot;t go to zero.&n; *&n; * TS_FEED callback is called once for every single TS cell although it is&n; * registered (in dvb_net_feed_start()) for 100 TS cells (used for dvb_net_ule()).&n; *&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/dvb/net.h&gt;
macro_line|#include &lt;linux/uio.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/crc32.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &quot;dvb_demux.h&quot;
macro_line|#include &quot;dvb_net.h&quot;
DECL|variable|dvb_net_debug
r_static
r_int
id|dvb_net_debug
suffix:semicolon
id|module_param
c_func
(paren
id|dvb_net_debug
comma
r_int
comma
l_int|0444
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|dvb_net_debug
comma
l_string|&quot;enable debug messages&quot;
)paren
suffix:semicolon
DECL|macro|dprintk
mdefine_line|#define dprintk(x...) do { if (dvb_net_debug) printk(x); } while (0)
DECL|function|iov_crc32
r_static
r_inline
id|__u32
id|iov_crc32
c_func
(paren
id|__u32
id|c
comma
r_struct
id|kvec
op_star
id|iov
comma
r_int
r_int
id|cnt
)paren
(brace
r_int
r_int
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|cnt
suffix:semicolon
id|j
op_increment
)paren
id|c
op_assign
id|crc32_be
c_func
(paren
id|c
comma
id|iov
(braket
id|j
)braket
dot
id|iov_base
comma
id|iov
(braket
id|j
)braket
dot
id|iov_len
)paren
suffix:semicolon
r_return
id|c
suffix:semicolon
)brace
DECL|macro|DVB_NET_MULTICAST_MAX
mdefine_line|#define DVB_NET_MULTICAST_MAX 10
DECL|macro|ULE_DEBUG
macro_line|#undef ULE_DEBUG
macro_line|#ifdef ULE_DEBUG
DECL|macro|isprint
mdefine_line|#define isprint(c)&t;((c &gt;= &squot;a&squot; &amp;&amp; c &lt;= &squot;z&squot;) || (c &gt;= &squot;A&squot; &amp;&amp; c &lt;= &squot;Z&squot;) || (c &gt;= &squot;0&squot; &amp;&amp; c &lt;= &squot;9&squot;))
DECL|function|hexdump
r_static
r_void
id|hexdump
c_func
(paren
r_const
r_int
r_char
op_star
id|buf
comma
r_int
r_int
id|len
)paren
(brace
r_char
id|str
(braket
l_int|80
)braket
comma
id|octet
(braket
l_int|10
)braket
suffix:semicolon
r_int
id|ofs
comma
id|i
comma
id|l
suffix:semicolon
r_for
c_loop
(paren
id|ofs
op_assign
l_int|0
suffix:semicolon
id|ofs
OL
id|len
suffix:semicolon
id|ofs
op_add_assign
l_int|16
)paren
(brace
id|sprintf
c_func
(paren
id|str
comma
l_string|&quot;%03d: &quot;
comma
id|ofs
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_plus
id|ofs
)paren
OL
id|len
)paren
id|sprintf
c_func
(paren
id|octet
comma
l_string|&quot;%02x &quot;
comma
id|buf
(braket
id|ofs
op_plus
id|i
)braket
)paren
suffix:semicolon
r_else
id|strcpy
c_func
(paren
id|octet
comma
l_string|&quot;   &quot;
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|str
comma
id|octet
)paren
suffix:semicolon
)brace
id|strcat
c_func
(paren
id|str
comma
l_string|&quot;  &quot;
)paren
suffix:semicolon
id|l
op_assign
id|strlen
c_func
(paren
id|str
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
l_int|16
)paren
op_logical_and
(paren
(paren
id|i
op_plus
id|ofs
)paren
OL
id|len
)paren
suffix:semicolon
id|i
op_increment
)paren
id|str
(braket
id|l
op_increment
)braket
op_assign
id|isprint
c_func
(paren
id|buf
(braket
id|ofs
op_plus
id|i
)braket
)paren
ques
c_cond
id|buf
(braket
id|ofs
op_plus
id|i
)braket
suffix:colon
l_char|&squot;.&squot;
suffix:semicolon
id|str
(braket
id|l
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s&bslash;n&quot;
comma
id|str
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
DECL|struct|dvb_net_priv
r_struct
id|dvb_net_priv
(brace
DECL|member|in_use
r_int
id|in_use
suffix:semicolon
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
DECL|member|name
r_char
id|name
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|pid
id|u16
id|pid
suffix:semicolon
DECL|member|host
r_struct
id|dvb_net
op_star
id|host
suffix:semicolon
DECL|member|demux
r_struct
id|dmx_demux
op_star
id|demux
suffix:semicolon
DECL|member|secfeed
r_struct
id|dmx_section_feed
op_star
id|secfeed
suffix:semicolon
DECL|member|secfilter
r_struct
id|dmx_section_filter
op_star
id|secfilter
suffix:semicolon
DECL|member|tsfeed
r_struct
id|dmx_ts_feed
op_star
id|tsfeed
suffix:semicolon
DECL|member|multi_num
r_int
id|multi_num
suffix:semicolon
DECL|member|multi_secfilter
r_struct
id|dmx_section_filter
op_star
id|multi_secfilter
(braket
id|DVB_NET_MULTICAST_MAX
)braket
suffix:semicolon
DECL|member|multi_macs
r_int
r_char
id|multi_macs
(braket
id|DVB_NET_MULTICAST_MAX
)braket
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|rx_mode
r_int
id|rx_mode
suffix:semicolon
DECL|macro|RX_MODE_UNI
mdefine_line|#define RX_MODE_UNI 0
DECL|macro|RX_MODE_MULTI
mdefine_line|#define RX_MODE_MULTI 1
DECL|macro|RX_MODE_ALL_MULTI
mdefine_line|#define RX_MODE_ALL_MULTI 2
DECL|macro|RX_MODE_PROMISC
mdefine_line|#define RX_MODE_PROMISC 3
DECL|member|set_multicast_list_wq
r_struct
id|work_struct
id|set_multicast_list_wq
suffix:semicolon
DECL|member|restart_net_feed_wq
r_struct
id|work_struct
id|restart_net_feed_wq
suffix:semicolon
DECL|member|feedtype
r_int
r_char
id|feedtype
suffix:semicolon
multiline_comment|/* Either FEED_TYPE_ or FEED_TYPE_ULE */
DECL|member|need_pusi
r_int
id|need_pusi
suffix:semicolon
multiline_comment|/* Set to 1, if synchronization on PUSI required. */
DECL|member|tscc
r_int
r_char
id|tscc
suffix:semicolon
multiline_comment|/* TS continuity counter after sync on PUSI. */
DECL|member|ule_skb
r_struct
id|sk_buff
op_star
id|ule_skb
suffix:semicolon
multiline_comment|/* ULE SNDU decodes into this buffer. */
DECL|member|ule_next_hdr
r_int
r_char
op_star
id|ule_next_hdr
suffix:semicolon
multiline_comment|/* Pointer into skb to next ULE extension header. */
DECL|member|ule_sndu_len
r_int
r_int
id|ule_sndu_len
suffix:semicolon
multiline_comment|/* ULE SNDU length in bytes, w/o D-Bit. */
DECL|member|ule_sndu_type
r_int
r_int
id|ule_sndu_type
suffix:semicolon
multiline_comment|/* ULE SNDU type field, complete. */
DECL|member|ule_sndu_type_1
r_int
r_char
id|ule_sndu_type_1
suffix:semicolon
multiline_comment|/* ULE SNDU type field, if split across 2 TS cells. */
DECL|member|ule_dbit
r_int
r_char
id|ule_dbit
suffix:semicolon
multiline_comment|/* Whether the DestMAC address present&n;&t;&t;&t;&t;&t;&t; * or not (bit is set). */
DECL|member|ule_bridged
r_int
r_char
id|ule_bridged
suffix:semicolon
multiline_comment|/* Whether the ULE_BRIDGED extension header was found. */
DECL|member|ule_sndu_remain
r_int
id|ule_sndu_remain
suffix:semicolon
multiline_comment|/* Nr. of bytes still required for current ULE SNDU. */
DECL|member|ts_count
r_int
r_int
id|ts_count
suffix:semicolon
multiline_comment|/* Current ts cell counter. */
)brace
suffix:semicolon
multiline_comment|/**&n; *&t;Determine the packet&squot;s protocol ID. The rule here is that we &n; *&t;assume 802.3 if the type field is short enough to be a length.&n; *&t;This is normal practice and works for any &squot;now in use&squot; protocol.&n; *&n; *  stolen from eth.c out of the linux kernel, hacked for dvb-device&n; *  by Michael Holzt &lt;kju@debian.org&gt;&n; */
DECL|function|dvb_net_eth_type_trans
r_static
r_int
r_int
id|dvb_net_eth_type_trans
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ethhdr
op_star
id|eth
suffix:semicolon
r_int
r_char
op_star
id|rawp
suffix:semicolon
id|skb-&gt;mac.raw
op_assign
id|skb-&gt;data
suffix:semicolon
id|skb_pull
c_func
(paren
id|skb
comma
id|dev-&gt;hard_header_len
)paren
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &lt;= KERNEL_VERSION(2,6,8)
id|eth
op_assign
id|skb-&gt;mac.ethernet
suffix:semicolon
macro_line|#else
id|eth
op_assign
id|eth_hdr
c_func
(paren
id|skb
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_star
id|eth-&gt;h_dest
op_amp
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|eth-&gt;h_dest
comma
id|dev-&gt;broadcast
comma
id|ETH_ALEN
)paren
op_eq
l_int|0
)paren
(brace
id|skb-&gt;pkt_type
op_assign
id|PACKET_BROADCAST
suffix:semicolon
)brace
r_else
id|skb-&gt;pkt_type
op_assign
id|PACKET_MULTICAST
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ntohs
c_func
(paren
id|eth-&gt;h_proto
)paren
op_ge
l_int|1536
)paren
r_return
id|eth-&gt;h_proto
suffix:semicolon
id|rawp
op_assign
id|skb-&gt;data
suffix:semicolon
multiline_comment|/**&n;&t; *&t;This is a magic hack to spot IPX packets. Older Novell breaks&n;&t; *&t;the protocol design and runs IPX over 802.3 without an 802.2 LLC&n;&t; *&t;layer. We look for FFFF which isn&squot;t a used 802.2 SSAP/DSAP. This&n;&t; *&t;won&squot;t work for fault tolerant netware but does for the rest.&n;&t; */
r_if
c_cond
(paren
op_star
(paren
r_int
r_int
op_star
)paren
id|rawp
op_eq
l_int|0xFFFF
)paren
r_return
id|htons
c_func
(paren
id|ETH_P_802_3
)paren
suffix:semicolon
multiline_comment|/**&n;&t; *&t;Real 802.2 LLC&n;&t; */
r_return
id|htons
c_func
(paren
id|ETH_P_802_2
)paren
suffix:semicolon
)brace
DECL|macro|TS_SZ
mdefine_line|#define TS_SZ&t;188
DECL|macro|TS_SYNC
mdefine_line|#define TS_SYNC&t;0x47
DECL|macro|TS_TEI
mdefine_line|#define TS_TEI&t;0x80
DECL|macro|TS_SC
mdefine_line|#define TS_SC&t;0xC0
DECL|macro|TS_PUSI
mdefine_line|#define TS_PUSI&t;0x40
DECL|macro|TS_AF_A
mdefine_line|#define TS_AF_A&t;0x20
DECL|macro|TS_AF_D
mdefine_line|#define TS_AF_D&t;0x10
multiline_comment|/* ULE Extension Header handlers. */
DECL|macro|ULE_TEST
mdefine_line|#define ULE_TEST&t;0
DECL|macro|ULE_BRIDGED
mdefine_line|#define ULE_BRIDGED&t;1
DECL|function|ule_test_sndu
r_int
id|ule_test_sndu
c_func
(paren
r_struct
id|dvb_net_priv
op_star
id|p
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|ule_bridged_sndu
r_int
id|ule_bridged_sndu
c_func
(paren
r_struct
id|dvb_net_priv
op_star
id|p
)paren
(brace
multiline_comment|/* BRIDGE SNDU handling sucks in draft-ietf-ipdvb-ule-03.txt.&n;&t; * This has to be the last extension header, otherwise it won&squot;t work.&n;&t; * Blame the authors!&n;&t; */
id|p-&gt;ule_bridged
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/** Handle ULE extension headers.&n; *  Function is called after a successful CRC32 verification of an ULE SNDU to complete its decoding.&n; *  Returns: &gt;= 0: nr. of bytes consumed by next extension header&n; *  &t;     -1:   Mandatory extension header that is not recognized or TEST SNDU; discard.&n; */
DECL|function|handle_one_ule_extension
r_static
r_int
id|handle_one_ule_extension
c_func
(paren
r_struct
id|dvb_net_priv
op_star
id|p
)paren
(brace
multiline_comment|/* Table of mandatory extension header handlers.  The header type is the index. */
r_static
r_int
(paren
op_star
id|ule_mandatory_ext_handlers
(braket
l_int|255
)braket
)paren
(paren
r_struct
id|dvb_net_priv
op_star
id|p
)paren
op_assign
(brace
(braket
l_int|0
)braket
op_assign
id|ule_test_sndu
comma
(braket
l_int|1
)braket
op_assign
id|ule_bridged_sndu
comma
(braket
l_int|2
)braket
op_assign
l_int|NULL
comma
)brace
suffix:semicolon
multiline_comment|/* Table of optional extension header handlers.  The header type is the index. */
r_static
r_int
(paren
op_star
id|ule_optional_ext_handlers
(braket
l_int|255
)braket
)paren
(paren
r_struct
id|dvb_net_priv
op_star
id|p
)paren
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
r_int
id|ext_len
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|hlen
op_assign
(paren
id|p-&gt;ule_sndu_type
op_amp
l_int|0x0700
)paren
op_rshift
l_int|8
suffix:semicolon
r_int
r_char
id|htype
op_assign
id|p-&gt;ule_sndu_type
op_amp
l_int|0x00FF
suffix:semicolon
multiline_comment|/* Discriminate mandatory and optional extension headers. */
r_if
c_cond
(paren
id|hlen
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Mandatory extension header */
r_if
c_cond
(paren
id|ule_mandatory_ext_handlers
(braket
id|htype
)braket
)paren
(brace
id|ext_len
op_assign
id|ule_mandatory_ext_handlers
(braket
id|htype
)braket
(paren
id|p
)paren
suffix:semicolon
id|p-&gt;ule_next_hdr
op_add_assign
id|ext_len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;ule_bridged
)paren
(brace
id|p-&gt;ule_sndu_type
op_assign
id|ntohs
c_func
(paren
op_star
(paren
r_int
r_int
op_star
)paren
id|p-&gt;ule_next_hdr
)paren
suffix:semicolon
id|p-&gt;ule_next_hdr
op_add_assign
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|p-&gt;ule_sndu_type
op_assign
id|ntohs
c_func
(paren
op_star
(paren
r_int
r_int
op_star
)paren
(paren
id|p-&gt;ule_next_hdr
op_plus
(paren
(paren
id|p-&gt;ule_dbit
ques
c_cond
l_int|2
suffix:colon
l_int|3
)paren
op_star
id|ETH_ALEN
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* This assures the extension handling loop will terminate. */
)brace
)brace
r_else
id|ext_len
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* SNDU has to be discarded. */
)brace
r_else
(brace
multiline_comment|/* Optional extension header.  Calculate the length. */
id|ext_len
op_assign
id|hlen
op_lshift
l_int|2
suffix:semicolon
multiline_comment|/* Process the optional extension header according to its type. */
r_if
c_cond
(paren
id|ule_optional_ext_handlers
(braket
id|htype
)braket
)paren
(paren
r_void
)paren
id|ule_optional_ext_handlers
(braket
id|htype
)braket
(paren
id|p
)paren
suffix:semicolon
id|p-&gt;ule_next_hdr
op_add_assign
id|ext_len
suffix:semicolon
id|p-&gt;ule_sndu_type
op_assign
id|ntohs
c_func
(paren
op_star
(paren
r_int
r_int
op_star
)paren
id|p-&gt;ule_next_hdr
)paren
suffix:semicolon
id|p-&gt;ule_next_hdr
op_add_assign
l_int|2
suffix:semicolon
)brace
r_return
id|ext_len
suffix:semicolon
)brace
DECL|function|handle_ule_extensions
r_static
r_int
id|handle_ule_extensions
c_func
(paren
r_struct
id|dvb_net_priv
op_star
id|p
)paren
(brace
r_int
id|total_ext_len
op_assign
l_int|0
comma
id|l
suffix:semicolon
id|p-&gt;ule_next_hdr
op_assign
id|p-&gt;ule_skb-&gt;data
suffix:semicolon
r_do
(brace
id|l
op_assign
id|handle_one_ule_extension
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|l
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Stop extension header processing and discard SNDU. */
id|total_ext_len
op_add_assign
id|l
suffix:semicolon
)brace
r_while
c_loop
(paren
id|p-&gt;ule_sndu_type
OL
l_int|1536
)paren
suffix:semicolon
r_return
id|total_ext_len
suffix:semicolon
)brace
multiline_comment|/** Prepare for a new ULE SNDU: reset the decoder state. */
DECL|function|reset_ule
r_static
r_inline
r_void
id|reset_ule
c_func
(paren
r_struct
id|dvb_net_priv
op_star
id|p
)paren
(brace
id|p-&gt;ule_skb
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;ule_next_hdr
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;ule_sndu_len
op_assign
l_int|0
suffix:semicolon
id|p-&gt;ule_sndu_type
op_assign
l_int|0
suffix:semicolon
id|p-&gt;ule_sndu_type_1
op_assign
l_int|0
suffix:semicolon
id|p-&gt;ule_sndu_remain
op_assign
l_int|0
suffix:semicolon
id|p-&gt;ule_dbit
op_assign
l_int|0xFF
suffix:semicolon
id|p-&gt;ule_bridged
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * Decode ULE SNDUs according to draft-ietf-ipdvb-ule-03.txt from a sequence of&n; * TS cells of a single PID.&n; */
DECL|function|dvb_net_ule
r_static
r_void
id|dvb_net_ule
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_const
id|u8
op_star
id|buf
comma
r_int
id|buf_len
)paren
(brace
r_struct
id|dvb_net_priv
op_star
id|priv
op_assign
(paren
r_struct
id|dvb_net_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|skipped
op_assign
l_int|0L
suffix:semicolon
id|u8
op_star
id|ts
comma
op_star
id|ts_end
comma
op_star
id|from_where
op_assign
l_int|NULL
comma
id|ts_remain
op_assign
l_int|0
comma
id|how_much
op_assign
l_int|0
comma
id|new_ts
op_assign
l_int|1
suffix:semicolon
r_struct
id|ethhdr
op_star
id|ethh
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef ULE_DEBUG
multiline_comment|/* The code inside ULE_DEBUG keeps a history of the last 100 TS cells processed. */
r_static
r_int
r_char
id|ule_hist
(braket
l_int|100
op_star
id|TS_SZ
)braket
suffix:semicolon
r_static
r_int
r_char
op_star
id|ule_where
op_assign
id|ule_hist
comma
id|ule_dump
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;NO netdev struct!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* For all TS cells in current buffer.&n;&t; * Appearently, we are called for every single TS cell.&n;&t; */
r_for
c_loop
(paren
id|ts
op_assign
(paren
r_char
op_star
)paren
id|buf
comma
id|ts_end
op_assign
(paren
r_char
op_star
)paren
id|buf
op_plus
id|buf_len
suffix:semicolon
id|ts
OL
id|ts_end
suffix:semicolon
multiline_comment|/* no default incr. */
)paren
(brace
r_if
c_cond
(paren
id|new_ts
)paren
(brace
multiline_comment|/* We are about to process a new TS cell. */
macro_line|#ifdef ULE_DEBUG
r_if
c_cond
(paren
id|ule_where
op_ge
op_amp
id|ule_hist
(braket
l_int|100
op_star
id|TS_SZ
)braket
)paren
id|ule_where
op_assign
id|ule_hist
suffix:semicolon
id|memcpy
c_func
(paren
id|ule_where
comma
id|ts
comma
id|TS_SZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ule_dump
)paren
(brace
id|hexdump
c_func
(paren
id|ule_where
comma
id|TS_SZ
)paren
suffix:semicolon
id|ule_dump
op_assign
l_int|0
suffix:semicolon
)brace
id|ule_where
op_add_assign
id|TS_SZ
suffix:semicolon
macro_line|#endif
multiline_comment|/* Check TS error conditions: sync_byte, transport_error_indicator, scrambling_control . */
r_if
c_cond
(paren
(paren
id|ts
(braket
l_int|0
)braket
op_ne
id|TS_SYNC
)paren
op_logical_or
(paren
id|ts
(braket
l_int|1
)braket
op_amp
id|TS_TEI
)paren
op_logical_or
(paren
(paren
id|ts
(braket
l_int|3
)braket
op_amp
id|TS_SC
)paren
op_ne
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%lu: Invalid TS cell: SYNC %#x, TEI %u, SC %#x.&bslash;n&quot;
comma
id|priv-&gt;ts_count
comma
id|ts
(braket
l_int|0
)braket
comma
id|ts
(braket
l_int|1
)braket
op_amp
id|TS_TEI
op_rshift
l_int|7
comma
id|ts
(braket
l_int|3
)braket
op_amp
l_int|0xC0
op_rshift
l_int|6
)paren
suffix:semicolon
multiline_comment|/* Drop partly decoded SNDU, reset state, resync on PUSI. */
r_if
c_cond
(paren
id|priv-&gt;ule_skb
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|priv-&gt;ule_skb
)paren
suffix:semicolon
multiline_comment|/* Prepare for next SNDU. */
(paren
(paren
r_struct
id|dvb_net_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|stats.rx_errors
op_increment
suffix:semicolon
(paren
(paren
r_struct
id|dvb_net_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|stats.rx_frame_errors
op_increment
suffix:semicolon
)brace
id|reset_ule
c_func
(paren
id|priv
)paren
suffix:semicolon
id|priv-&gt;need_pusi
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Continue with next TS cell. */
id|ts
op_add_assign
id|TS_SZ
suffix:semicolon
id|priv-&gt;ts_count
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|ts_remain
op_assign
l_int|184
suffix:semicolon
id|from_where
op_assign
id|ts
op_plus
l_int|4
suffix:semicolon
)brace
multiline_comment|/* Synchronize on PUSI, if required. */
r_if
c_cond
(paren
id|priv-&gt;need_pusi
)paren
(brace
r_if
c_cond
(paren
id|ts
(braket
l_int|1
)braket
op_amp
id|TS_PUSI
)paren
(brace
multiline_comment|/* Find beginning of first ULE SNDU in current TS cell. */
multiline_comment|/* Synchronize continuity counter. */
id|priv-&gt;tscc
op_assign
id|ts
(braket
l_int|3
)braket
op_amp
l_int|0x0F
suffix:semicolon
multiline_comment|/* There is a pointer field here. */
r_if
c_cond
(paren
id|ts
(braket
l_int|4
)braket
OG
id|ts_remain
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%lu: Invalid ULE packet &quot;
l_string|&quot;(pointer field %d)&bslash;n&quot;
comma
id|priv-&gt;ts_count
comma
id|ts
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|ts
op_add_assign
id|TS_SZ
suffix:semicolon
id|priv-&gt;ts_count
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Skip to destination of pointer field. */
id|from_where
op_assign
op_amp
id|ts
(braket
l_int|5
)braket
op_plus
id|ts
(braket
l_int|4
)braket
suffix:semicolon
id|ts_remain
op_sub_assign
l_int|1
op_plus
id|ts
(braket
l_int|4
)braket
suffix:semicolon
id|skipped
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|skipped
op_increment
suffix:semicolon
id|ts
op_add_assign
id|TS_SZ
suffix:semicolon
id|priv-&gt;ts_count
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
multiline_comment|/* Check continuity counter. */
r_if
c_cond
(paren
id|new_ts
)paren
(brace
r_if
c_cond
(paren
(paren
id|ts
(braket
l_int|3
)braket
op_amp
l_int|0x0F
)paren
op_eq
id|priv-&gt;tscc
)paren
id|priv-&gt;tscc
op_assign
(paren
id|priv-&gt;tscc
op_plus
l_int|1
)paren
op_amp
l_int|0x0F
suffix:semicolon
r_else
(brace
multiline_comment|/* TS discontinuity handling: */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%lu: TS discontinuity: got %#x, &quot;
l_string|&quot;exptected %#x.&bslash;n&quot;
comma
id|priv-&gt;ts_count
comma
id|ts
(braket
l_int|3
)braket
op_amp
l_int|0x0F
comma
id|priv-&gt;tscc
)paren
suffix:semicolon
multiline_comment|/* Drop partly decoded SNDU, reset state, resync on PUSI. */
r_if
c_cond
(paren
id|priv-&gt;ule_skb
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|priv-&gt;ule_skb
)paren
suffix:semicolon
multiline_comment|/* Prepare for next SNDU. */
singleline_comment|// reset_ule(priv);  moved to below.
(paren
(paren
r_struct
id|dvb_net_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|stats.rx_errors
op_increment
suffix:semicolon
(paren
(paren
r_struct
id|dvb_net_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|stats.rx_frame_errors
op_increment
suffix:semicolon
)brace
id|reset_ule
c_func
(paren
id|priv
)paren
suffix:semicolon
multiline_comment|/* skip to next PUSI. */
id|priv-&gt;need_pusi
op_assign
l_int|1
suffix:semicolon
id|ts
op_add_assign
id|TS_SZ
suffix:semicolon
id|priv-&gt;ts_count
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* If we still have an incomplete payload, but PUSI is&n;&t;&t;&t; * set; some TS cells are missing.&n;&t;&t;&t; * This is only possible here, if we missed exactly 16 TS&n;&t;&t;&t; * cells (continuity counter wrap). */
r_if
c_cond
(paren
id|ts
(braket
l_int|1
)braket
op_amp
id|TS_PUSI
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|priv-&gt;need_pusi
)paren
(brace
r_if
c_cond
(paren
op_star
id|from_where
OG
l_int|181
)paren
(brace
multiline_comment|/* Pointer field is invalid.  Drop this TS cell and any started ULE SNDU. */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%lu: Invalid pointer &quot;
l_string|&quot;field: %u.&bslash;n&quot;
comma
id|priv-&gt;ts_count
comma
op_star
id|from_where
)paren
suffix:semicolon
multiline_comment|/* Drop partly decoded SNDU, reset state, resync on PUSI. */
r_if
c_cond
(paren
id|priv-&gt;ule_skb
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|priv-&gt;ule_skb
)paren
suffix:semicolon
(paren
(paren
r_struct
id|dvb_net_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|stats.rx_errors
op_increment
suffix:semicolon
(paren
(paren
r_struct
id|dvb_net_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|stats.rx_frame_errors
op_increment
suffix:semicolon
)brace
id|reset_ule
c_func
(paren
id|priv
)paren
suffix:semicolon
id|priv-&gt;need_pusi
op_assign
l_int|1
suffix:semicolon
id|ts
op_add_assign
id|TS_SZ
suffix:semicolon
id|priv-&gt;ts_count
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Skip pointer field (we&squot;re processing a&n;&t;&t;&t;&t;&t; * packed payload). */
id|from_where
op_add_assign
l_int|1
suffix:semicolon
id|ts_remain
op_sub_assign
l_int|1
suffix:semicolon
)brace
r_else
id|priv-&gt;need_pusi
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;ule_sndu_remain
OG
l_int|183
)paren
(brace
multiline_comment|/* Current SNDU lacks more data than there could be available in the&n;&t;&t;&t;&t;&t; * current TS cell. */
(paren
(paren
r_struct
id|dvb_net_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|stats.rx_errors
op_increment
suffix:semicolon
(paren
(paren
r_struct
id|dvb_net_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|stats.rx_length_errors
op_increment
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%lu: Expected %d more SNDU bytes, but &quot;
l_string|&quot;got PUSI (pf %d, ts_remain %d).  Flushing incomplete payload.&bslash;n&quot;
comma
id|priv-&gt;ts_count
comma
id|priv-&gt;ule_sndu_remain
comma
id|ts
(braket
l_int|4
)braket
comma
id|ts_remain
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|priv-&gt;ule_skb
)paren
suffix:semicolon
multiline_comment|/* Prepare for next SNDU. */
id|reset_ule
c_func
(paren
id|priv
)paren
suffix:semicolon
multiline_comment|/* Resync: go to where pointer field points to: start of next ULE SNDU. */
id|from_where
op_add_assign
id|ts
(braket
l_int|4
)braket
suffix:semicolon
id|ts_remain
op_sub_assign
id|ts
(braket
l_int|4
)braket
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Check if new payload needs to be started. */
r_if
c_cond
(paren
id|priv-&gt;ule_skb
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Start a new payload with skb.&n;&t;&t;&t; * Find ULE header.  It is only guaranteed that the&n;&t;&t;&t; * length field (2 bytes) is contained in the current&n;&t;&t;&t; * TS.&n;&t;&t;&t; * Check ts_remain has to be &gt;= 2 here. */
r_if
c_cond
(paren
id|ts_remain
OL
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Invalid payload packing: only %d &quot;
l_string|&quot;bytes left in TS.  Resyncing.&bslash;n&quot;
comma
id|ts_remain
)paren
suffix:semicolon
id|priv-&gt;ule_sndu_len
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;need_pusi
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|priv-&gt;ule_sndu_len
)paren
(brace
multiline_comment|/* Got at least two bytes, thus extrace the SNDU length. */
id|priv-&gt;ule_sndu_len
op_assign
id|from_where
(braket
l_int|0
)braket
op_lshift
l_int|8
op_or
id|from_where
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;ule_sndu_len
op_amp
l_int|0x8000
)paren
(brace
multiline_comment|/* D-Bit is set: no dest mac present. */
id|priv-&gt;ule_sndu_len
op_and_assign
l_int|0x7FFF
suffix:semicolon
id|priv-&gt;ule_dbit
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|priv-&gt;ule_dbit
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;ule_sndu_len
OG
l_int|32763
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%lu: Invalid ULE SNDU length %u. &quot;
l_string|&quot;Resyncing.&bslash;n&quot;
comma
id|priv-&gt;ts_count
comma
id|priv-&gt;ule_sndu_len
)paren
suffix:semicolon
id|priv-&gt;ule_sndu_len
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;need_pusi
op_assign
l_int|1
suffix:semicolon
id|new_ts
op_assign
l_int|1
suffix:semicolon
id|ts
op_add_assign
id|TS_SZ
suffix:semicolon
id|priv-&gt;ts_count
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|ts_remain
op_sub_assign
l_int|2
suffix:semicolon
multiline_comment|/* consume the 2 bytes SNDU length. */
id|from_where
op_add_assign
l_int|2
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * State of current TS:&n;&t;&t;&t; *   ts_remain (remaining bytes in the current TS cell)&n;&t;&t;&t; *   0&t;ule_type is not available now, we need the next TS cell&n;&t;&t;&t; *   1&t;the first byte of the ule_type is present&n;&t;&t;&t; * &gt;=2&t;full ULE header present, maybe some payload data as well.&n;&t;&t;&t; */
r_switch
c_cond
(paren
id|ts_remain
)paren
(brace
r_case
l_int|1
suffix:colon
id|priv-&gt;ule_sndu_type
op_assign
id|from_where
(braket
l_int|0
)braket
op_lshift
l_int|8
suffix:semicolon
id|priv-&gt;ule_sndu_type_1
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* first byte of ule_type is set. */
id|ts_remain
op_sub_assign
l_int|1
suffix:semicolon
id|from_where
op_add_assign
l_int|1
suffix:semicolon
multiline_comment|/* Continue w/ next TS. */
r_case
l_int|0
suffix:colon
id|new_ts
op_assign
l_int|1
suffix:semicolon
id|ts
op_add_assign
id|TS_SZ
suffix:semicolon
id|priv-&gt;ts_count
op_increment
suffix:semicolon
r_continue
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/* complete ULE header is present in current TS. */
multiline_comment|/* Extract ULE type field. */
r_if
c_cond
(paren
id|priv-&gt;ule_sndu_type_1
)paren
(brace
id|priv-&gt;ule_sndu_type
op_or_assign
id|from_where
(braket
l_int|0
)braket
suffix:semicolon
id|from_where
op_add_assign
l_int|1
suffix:semicolon
multiline_comment|/* points to payload start. */
id|ts_remain
op_sub_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Complete type is present in new TS. */
id|priv-&gt;ule_sndu_type
op_assign
id|from_where
(braket
l_int|0
)braket
op_lshift
l_int|8
op_or
id|from_where
(braket
l_int|1
)braket
suffix:semicolon
id|from_where
op_add_assign
l_int|2
suffix:semicolon
multiline_comment|/* points to payload start. */
id|ts_remain
op_sub_assign
l_int|2
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* Allocate the skb (decoder target buffer) with the correct size, as follows:&n;&t;&t;&t; * prepare for the largest case: bridged SNDU with MAC address (dbit = 0). */
id|priv-&gt;ule_skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|priv-&gt;ule_sndu_len
op_plus
id|ETH_HLEN
op_plus
id|ETH_ALEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;ule_skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: Memory squeeze, dropping packet.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
(paren
(paren
r_struct
id|dvb_net_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|stats.rx_dropped
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* This includes the CRC32 _and_ dest mac, if !dbit. */
id|priv-&gt;ule_sndu_remain
op_assign
id|priv-&gt;ule_sndu_len
suffix:semicolon
id|priv-&gt;ule_skb-&gt;dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/* Leave space for Ethernet or bridged SNDU header (eth hdr plus one MAC addr). */
id|skb_reserve
c_func
(paren
id|priv-&gt;ule_skb
comma
id|ETH_HLEN
op_plus
id|ETH_ALEN
)paren
suffix:semicolon
)brace
multiline_comment|/* Copy data into our current skb. */
id|how_much
op_assign
id|min
c_func
(paren
id|priv-&gt;ule_sndu_remain
comma
(paren
r_int
)paren
id|ts_remain
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|priv-&gt;ule_skb
comma
id|how_much
)paren
comma
id|from_where
comma
id|how_much
)paren
suffix:semicolon
id|priv-&gt;ule_sndu_remain
op_sub_assign
id|how_much
suffix:semicolon
id|ts_remain
op_sub_assign
id|how_much
suffix:semicolon
id|from_where
op_add_assign
id|how_much
suffix:semicolon
multiline_comment|/* Check for complete payload. */
r_if
c_cond
(paren
id|priv-&gt;ule_sndu_remain
op_le
l_int|0
)paren
(brace
multiline_comment|/* Check CRC32, we&squot;ve got it in our skb already. */
r_int
r_int
id|ulen
op_assign
id|htons
c_func
(paren
id|priv-&gt;ule_sndu_len
)paren
suffix:semicolon
r_int
r_int
id|utype
op_assign
id|htons
c_func
(paren
id|priv-&gt;ule_sndu_type
)paren
suffix:semicolon
r_struct
id|kvec
id|iov
(braket
l_int|3
)braket
op_assign
(brace
(brace
op_amp
id|ulen
comma
r_sizeof
id|ulen
)brace
comma
(brace
op_amp
id|utype
comma
r_sizeof
id|utype
)brace
comma
(brace
id|priv-&gt;ule_skb-&gt;data
comma
id|priv-&gt;ule_skb-&gt;len
op_minus
l_int|4
)brace
)brace
suffix:semicolon
r_int
r_int
id|ule_crc
op_assign
op_complement
l_int|0L
comma
id|expected_crc
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;ule_dbit
)paren
(brace
multiline_comment|/* Set D-bit for CRC32 verification,&n;&t;&t;&t;&t; * if it was set originally. */
id|ulen
op_or_assign
l_int|0x0080
suffix:semicolon
)brace
id|ule_crc
op_assign
id|iov_crc32
c_func
(paren
id|ule_crc
comma
id|iov
comma
l_int|3
)paren
suffix:semicolon
id|expected_crc
op_assign
op_star
(paren
(paren
id|u8
op_star
)paren
id|priv-&gt;ule_skb-&gt;tail
op_minus
l_int|4
)paren
op_lshift
l_int|24
op_or
op_star
(paren
(paren
id|u8
op_star
)paren
id|priv-&gt;ule_skb-&gt;tail
op_minus
l_int|3
)paren
op_lshift
l_int|16
op_or
op_star
(paren
(paren
id|u8
op_star
)paren
id|priv-&gt;ule_skb-&gt;tail
op_minus
l_int|2
)paren
op_lshift
l_int|8
op_or
op_star
(paren
(paren
id|u8
op_star
)paren
id|priv-&gt;ule_skb-&gt;tail
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ule_crc
op_ne
id|expected_crc
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%lu: CRC32 check FAILED: %#lx / %#lx, SNDU len %d type %#x, ts_remain %d, next 2: %x.&bslash;n&quot;
comma
id|priv-&gt;ts_count
comma
id|ule_crc
comma
id|expected_crc
comma
id|priv-&gt;ule_sndu_len
comma
id|priv-&gt;ule_sndu_type
comma
id|ts_remain
comma
id|ts_remain
OG
l_int|2
ques
c_cond
op_star
(paren
r_int
r_int
op_star
)paren
id|from_where
suffix:colon
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef ULE_DEBUG
id|hexdump
c_func
(paren
id|iov
(braket
l_int|0
)braket
dot
id|iov_base
comma
id|iov
(braket
l_int|0
)braket
dot
id|iov_len
)paren
suffix:semicolon
id|hexdump
c_func
(paren
id|iov
(braket
l_int|1
)braket
dot
id|iov_base
comma
id|iov
(braket
l_int|1
)braket
dot
id|iov_len
)paren
suffix:semicolon
id|hexdump
c_func
(paren
id|iov
(braket
l_int|2
)braket
dot
id|iov_base
comma
id|iov
(braket
l_int|2
)braket
dot
id|iov_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ule_where
op_eq
id|ule_hist
)paren
(brace
id|hexdump
c_func
(paren
op_amp
id|ule_hist
(braket
l_int|98
op_star
id|TS_SZ
)braket
comma
id|TS_SZ
)paren
suffix:semicolon
id|hexdump
c_func
(paren
op_amp
id|ule_hist
(braket
l_int|99
op_star
id|TS_SZ
)braket
comma
id|TS_SZ
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ule_where
op_eq
op_amp
id|ule_hist
(braket
id|TS_SZ
)braket
)paren
(brace
id|hexdump
c_func
(paren
op_amp
id|ule_hist
(braket
l_int|99
op_star
id|TS_SZ
)braket
comma
id|TS_SZ
)paren
suffix:semicolon
id|hexdump
c_func
(paren
id|ule_hist
comma
id|TS_SZ
)paren
suffix:semicolon
)brace
r_else
(brace
id|hexdump
c_func
(paren
id|ule_where
op_minus
id|TS_SZ
op_minus
id|TS_SZ
comma
id|TS_SZ
)paren
suffix:semicolon
id|hexdump
c_func
(paren
id|ule_where
op_minus
id|TS_SZ
comma
id|TS_SZ
)paren
suffix:semicolon
)brace
id|ule_dump
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
(paren
(paren
r_struct
id|dvb_net_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|stats.rx_errors
op_increment
suffix:semicolon
(paren
(paren
r_struct
id|dvb_net_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|stats.rx_crc_errors
op_increment
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|priv-&gt;ule_skb
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* CRC32 verified OK. */
multiline_comment|/* Handle ULE Extension Headers. */
r_if
c_cond
(paren
id|priv-&gt;ule_sndu_type
OL
l_int|1536
)paren
(brace
multiline_comment|/* There is an extension header.  Handle it accordingly. */
r_int
id|l
op_assign
id|handle_ule_extensions
c_func
(paren
id|priv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|l
OL
l_int|0
)paren
(brace
multiline_comment|/* Mandatory extension header unknown or TEST SNDU.  Drop it. */
singleline_comment|// printk( KERN_WARNING &quot;Dropping SNDU, extension headers.&bslash;n&quot; );
id|dev_kfree_skb
c_func
(paren
id|priv-&gt;ule_skb
)paren
suffix:semicolon
r_goto
id|sndu_done
suffix:semicolon
)brace
id|skb_pull
c_func
(paren
id|priv-&gt;ule_skb
comma
id|l
)paren
suffix:semicolon
)brace
multiline_comment|/* CRC32 was OK. Remove it from skb. */
id|priv-&gt;ule_skb-&gt;tail
op_sub_assign
l_int|4
suffix:semicolon
id|priv-&gt;ule_skb-&gt;len
op_sub_assign
l_int|4
suffix:semicolon
multiline_comment|/* Filter on receiver&squot;s destination MAC address, if present. */
r_if
c_cond
(paren
op_logical_neg
id|priv-&gt;ule_dbit
)paren
(brace
multiline_comment|/* The destination MAC address is the next data in the skb. */
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|priv-&gt;ule_skb-&gt;data
comma
id|dev-&gt;dev_addr
comma
id|ETH_ALEN
)paren
)paren
(brace
multiline_comment|/* MAC addresses don&squot;t match.  Drop SNDU. */
singleline_comment|// printk( KERN_WARNING &quot;Dropping SNDU, MAC address.&bslash;n&quot; );
id|dev_kfree_skb
c_func
(paren
id|priv-&gt;ule_skb
)paren
suffix:semicolon
r_goto
id|sndu_done
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|priv-&gt;ule_bridged
)paren
(brace
id|skb_push
c_func
(paren
id|priv-&gt;ule_skb
comma
id|ETH_ALEN
op_plus
l_int|2
)paren
suffix:semicolon
id|ethh
op_assign
(paren
r_struct
id|ethhdr
op_star
)paren
id|priv-&gt;ule_skb-&gt;data
suffix:semicolon
id|memcpy
c_func
(paren
id|ethh-&gt;h_dest
comma
id|ethh-&gt;h_source
comma
id|ETH_ALEN
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ethh-&gt;h_source
comma
l_int|0
comma
id|ETH_ALEN
)paren
suffix:semicolon
id|ethh-&gt;h_proto
op_assign
id|htons
c_func
(paren
id|priv-&gt;ule_sndu_type
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Skip the Receiver destination MAC address. */
id|skb_pull
c_func
(paren
id|priv-&gt;ule_skb
comma
id|ETH_ALEN
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|priv-&gt;ule_bridged
)paren
(brace
id|skb_push
c_func
(paren
id|priv-&gt;ule_skb
comma
id|ETH_HLEN
)paren
suffix:semicolon
id|ethh
op_assign
(paren
r_struct
id|ethhdr
op_star
)paren
id|priv-&gt;ule_skb-&gt;data
suffix:semicolon
id|memcpy
c_func
(paren
id|ethh-&gt;h_dest
comma
id|dev-&gt;dev_addr
comma
id|ETH_ALEN
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ethh-&gt;h_source
comma
l_int|0
comma
id|ETH_ALEN
)paren
suffix:semicolon
id|ethh-&gt;h_proto
op_assign
id|htons
c_func
(paren
id|priv-&gt;ule_sndu_type
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* skb is in correct state; nothing to do. */
)brace
)brace
id|priv-&gt;ule_bridged
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Stuff into kernel&squot;s protocol stack. */
id|priv-&gt;ule_skb-&gt;protocol
op_assign
id|dvb_net_eth_type_trans
c_func
(paren
id|priv-&gt;ule_skb
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/* If D-bit is set (i.e. destination MAC address not present),&n;&t;&t;&t;&t; * receive the packet anyhow. */
multiline_comment|/* if (priv-&gt;ule_dbit &amp;&amp; skb-&gt;pkt_type == PACKET_OTHERHOST)&n;&t;&t;&t;&t;&t;priv-&gt;ule_skb-&gt;pkt_type = PACKET_HOST; */
(paren
(paren
r_struct
id|dvb_net_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|stats.rx_packets
op_increment
suffix:semicolon
(paren
(paren
r_struct
id|dvb_net_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|stats.rx_bytes
op_add_assign
id|priv-&gt;ule_skb-&gt;len
suffix:semicolon
id|netif_rx
c_func
(paren
id|priv-&gt;ule_skb
)paren
suffix:semicolon
)brace
id|sndu_done
suffix:colon
multiline_comment|/* Prepare for next SNDU. */
id|reset_ule
c_func
(paren
id|priv
)paren
suffix:semicolon
)brace
multiline_comment|/* More data in current TS (look at the bytes following the CRC32)? */
r_if
c_cond
(paren
id|ts_remain
op_ge
l_int|2
op_logical_and
op_star
(paren
(paren
r_int
r_int
op_star
)paren
id|from_where
)paren
op_ne
l_int|0xFFFF
)paren
(brace
multiline_comment|/* Next ULE SNDU starts right there. */
id|new_ts
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;ule_skb
op_assign
l_int|NULL
suffix:semicolon
id|priv-&gt;ule_sndu_type_1
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;ule_sndu_len
op_assign
l_int|0
suffix:semicolon
singleline_comment|// printk(KERN_WARNING &quot;More data in current TS: [%#x %#x %#x %#x]&bslash;n&quot;,
singleline_comment|//&t;*(from_where + 0), *(from_where + 1),
singleline_comment|//&t;*(from_where + 2), *(from_where + 3));
singleline_comment|// printk(KERN_WARNING &quot;ts @ %p, stopped @ %p:&bslash;n&quot;, ts, from_where + 0);
singleline_comment|// hexdump(ts, 188);
)brace
r_else
(brace
id|new_ts
op_assign
l_int|1
suffix:semicolon
id|ts
op_add_assign
id|TS_SZ
suffix:semicolon
id|priv-&gt;ts_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;ule_skb
op_eq
l_int|NULL
)paren
(brace
id|priv-&gt;need_pusi
op_assign
l_int|1
suffix:semicolon
id|priv-&gt;ule_sndu_type_1
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;ule_sndu_len
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* for all available TS cells */
)brace
DECL|function|dvb_net_ts_callback
r_static
r_int
id|dvb_net_ts_callback
c_func
(paren
r_const
id|u8
op_star
id|buffer1
comma
r_int
id|buffer1_len
comma
r_const
id|u8
op_star
id|buffer2
comma
r_int
id|buffer2_len
comma
r_struct
id|dmx_ts_feed
op_star
id|feed
comma
r_enum
id|dmx_success
id|success
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|feed-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|buffer2
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;buffer2 not 0: %p.&bslash;n&quot;
comma
id|buffer2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer1_len
OG
l_int|32768
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;length &gt; 32k: %zu.&bslash;n&quot;
comma
id|buffer1_len
)paren
suffix:semicolon
multiline_comment|/* printk(&quot;TS callback: %u bytes, %u TS cells @ %p.&bslash;n&quot;,&n;&t;          buffer1_len, buffer1_len / TS_SZ, buffer1); */
id|dvb_net_ule
c_func
(paren
id|dev
comma
id|buffer1
comma
id|buffer1_len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dvb_net_sec
r_static
r_void
id|dvb_net_sec
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u8
op_star
id|pkt
comma
r_int
id|pkt_len
)paren
(brace
id|u8
op_star
id|eth
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_struct
id|net_device_stats
op_star
id|stats
op_assign
op_amp
(paren
(paren
(paren
r_struct
id|dvb_net_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|stats
)paren
suffix:semicolon
multiline_comment|/* note: pkt_len includes a 32bit checksum */
r_if
c_cond
(paren
id|pkt_len
OL
l_int|16
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: IP/MPE packet length = %d too small.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|pkt_len
)paren
suffix:semicolon
id|stats-&gt;rx_errors
op_increment
suffix:semicolon
id|stats-&gt;rx_length_errors
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* it seems some ISPs manage to screw up here, so we have to&n; * relax the error checks... */
macro_line|#if 0
r_if
c_cond
(paren
(paren
id|pkt
(braket
l_int|5
)braket
op_amp
l_int|0xfd
)paren
op_ne
l_int|0xc1
)paren
(brace
multiline_comment|/* drop scrambled or broken packets */
macro_line|#else
r_if
c_cond
(paren
(paren
id|pkt
(braket
l_int|5
)braket
op_amp
l_int|0x3c
)paren
op_ne
l_int|0x00
)paren
(brace
multiline_comment|/* drop scrambled */
macro_line|#endif
id|stats-&gt;rx_errors
op_increment
suffix:semicolon
id|stats-&gt;rx_crc_errors
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pkt
(braket
l_int|5
)braket
op_amp
l_int|0x02
)paren
(brace
singleline_comment|//FIXME: handle LLC/SNAP
id|stats-&gt;rx_dropped
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pkt
(braket
l_int|7
)braket
)paren
(brace
multiline_comment|/* FIXME: assemble datagram from multiple sections */
id|stats-&gt;rx_errors
op_increment
suffix:semicolon
id|stats-&gt;rx_frame_errors
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* we have 14 byte ethernet header (ip header follows);&n;&t; * 12 byte MPE header; 4 byte checksum; + 2 byte alignment&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|pkt_len
op_minus
l_int|4
op_minus
l_int|12
op_plus
l_int|14
op_plus
l_int|2
)paren
)paren
)paren
(brace
singleline_comment|//printk(KERN_NOTICE &quot;%s: Memory squeeze, dropping packet.&bslash;n&quot;, dev-&gt;name);
id|stats-&gt;rx_dropped
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* longword align L3 header */
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/* copy L3 payload */
id|eth
op_assign
(paren
id|u8
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
id|pkt_len
op_minus
l_int|12
op_minus
l_int|4
op_plus
l_int|14
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|eth
op_plus
l_int|14
comma
id|pkt
op_plus
l_int|12
comma
id|pkt_len
op_minus
l_int|12
op_minus
l_int|4
)paren
suffix:semicolon
multiline_comment|/* create ethernet header: */
id|eth
(braket
l_int|0
)braket
op_assign
id|pkt
(braket
l_int|0x0b
)braket
suffix:semicolon
id|eth
(braket
l_int|1
)braket
op_assign
id|pkt
(braket
l_int|0x0a
)braket
suffix:semicolon
id|eth
(braket
l_int|2
)braket
op_assign
id|pkt
(braket
l_int|0x09
)braket
suffix:semicolon
id|eth
(braket
l_int|3
)braket
op_assign
id|pkt
(braket
l_int|0x08
)braket
suffix:semicolon
id|eth
(braket
l_int|4
)braket
op_assign
id|pkt
(braket
l_int|0x04
)braket
suffix:semicolon
id|eth
(braket
l_int|5
)braket
op_assign
id|pkt
(braket
l_int|0x03
)braket
suffix:semicolon
id|eth
(braket
l_int|6
)braket
op_assign
id|eth
(braket
l_int|7
)braket
op_assign
id|eth
(braket
l_int|8
)braket
op_assign
id|eth
(braket
l_int|9
)braket
op_assign
id|eth
(braket
l_int|10
)braket
op_assign
id|eth
(braket
l_int|11
)braket
op_assign
l_int|0
suffix:semicolon
id|eth
(braket
l_int|12
)braket
op_assign
l_int|0x08
suffix:semicolon
multiline_comment|/* ETH_P_IP */
id|eth
(braket
l_int|13
)braket
op_assign
l_int|0x00
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|dvb_net_eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|stats-&gt;rx_packets
op_increment
suffix:semicolon
id|stats-&gt;rx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
DECL|function|dvb_net_sec_callback
r_static
r_int
id|dvb_net_sec_callback
c_func
(paren
r_const
id|u8
op_star
id|buffer1
comma
r_int
id|buffer1_len
comma
r_const
id|u8
op_star
id|buffer2
comma
r_int
id|buffer2_len
comma
r_struct
id|dmx_section_filter
op_star
id|filter
comma
r_enum
id|dmx_success
id|success
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|filter-&gt;priv
suffix:semicolon
multiline_comment|/**&n;&t; * we rely on the DVB API definition where exactly one complete&n;&t; * section is delivered in buffer1&n;&t; */
id|dvb_net_sec
(paren
id|dev
comma
(paren
id|u8
op_star
)paren
id|buffer1
comma
id|buffer1_len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dvb_net_tx
r_static
r_int
id|dvb_net_tx
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|mask_normal
r_static
id|u8
id|mask_normal
(braket
l_int|6
)braket
op_assign
initialization_block
suffix:semicolon
DECL|variable|mask_allmulti
r_static
id|u8
id|mask_allmulti
(braket
l_int|6
)braket
op_assign
initialization_block
suffix:semicolon
DECL|variable|mac_allmulti
r_static
id|u8
id|mac_allmulti
(braket
l_int|6
)braket
op_assign
initialization_block
suffix:semicolon
DECL|variable|mask_promisc
r_static
id|u8
id|mask_promisc
(braket
l_int|6
)braket
op_assign
initialization_block
suffix:semicolon
DECL|function|dvb_net_filter_sec_set
r_static
r_int
id|dvb_net_filter_sec_set
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|dmx_section_filter
op_star
op_star
id|secfilter
comma
id|u8
op_star
id|mac
comma
id|u8
op_star
id|mac_mask
)paren
(brace
r_struct
id|dvb_net_priv
op_star
id|priv
op_assign
(paren
r_struct
id|dvb_net_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ret
suffix:semicolon
op_star
id|secfilter
op_assign
l_int|NULL
suffix:semicolon
id|ret
op_assign
id|priv-&gt;secfeed
op_member_access_from_pointer
id|allocate_filter
c_func
(paren
id|priv-&gt;secfeed
comma
id|secfilter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: could not get filter&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
(paren
op_star
id|secfilter
)paren
op_member_access_from_pointer
id|priv
op_assign
(paren
r_void
op_star
)paren
id|dev
suffix:semicolon
id|memset
c_func
(paren
(paren
op_star
id|secfilter
)paren
op_member_access_from_pointer
id|filter_value
comma
l_int|0x00
comma
id|DMX_MAX_FILTER_SIZE
)paren
suffix:semicolon
id|memset
c_func
(paren
(paren
op_star
id|secfilter
)paren
op_member_access_from_pointer
id|filter_mask
comma
l_int|0x00
comma
id|DMX_MAX_FILTER_SIZE
)paren
suffix:semicolon
id|memset
c_func
(paren
(paren
op_star
id|secfilter
)paren
op_member_access_from_pointer
id|filter_mode
comma
l_int|0xff
comma
id|DMX_MAX_FILTER_SIZE
)paren
suffix:semicolon
(paren
op_star
id|secfilter
)paren
op_member_access_from_pointer
id|filter_value
(braket
l_int|0
)braket
op_assign
l_int|0x3e
suffix:semicolon
(paren
op_star
id|secfilter
)paren
op_member_access_from_pointer
id|filter_value
(braket
l_int|3
)braket
op_assign
id|mac
(braket
l_int|5
)braket
suffix:semicolon
(paren
op_star
id|secfilter
)paren
op_member_access_from_pointer
id|filter_value
(braket
l_int|4
)braket
op_assign
id|mac
(braket
l_int|4
)braket
suffix:semicolon
(paren
op_star
id|secfilter
)paren
op_member_access_from_pointer
id|filter_value
(braket
l_int|8
)braket
op_assign
id|mac
(braket
l_int|3
)braket
suffix:semicolon
(paren
op_star
id|secfilter
)paren
op_member_access_from_pointer
id|filter_value
(braket
l_int|9
)braket
op_assign
id|mac
(braket
l_int|2
)braket
suffix:semicolon
(paren
op_star
id|secfilter
)paren
op_member_access_from_pointer
id|filter_value
(braket
l_int|10
)braket
op_assign
id|mac
(braket
l_int|1
)braket
suffix:semicolon
(paren
op_star
id|secfilter
)paren
op_member_access_from_pointer
id|filter_value
(braket
l_int|11
)braket
op_assign
id|mac
(braket
l_int|0
)braket
suffix:semicolon
(paren
op_star
id|secfilter
)paren
op_member_access_from_pointer
id|filter_mask
(braket
l_int|0
)braket
op_assign
l_int|0xff
suffix:semicolon
(paren
op_star
id|secfilter
)paren
op_member_access_from_pointer
id|filter_mask
(braket
l_int|3
)braket
op_assign
id|mac_mask
(braket
l_int|5
)braket
suffix:semicolon
(paren
op_star
id|secfilter
)paren
op_member_access_from_pointer
id|filter_mask
(braket
l_int|4
)braket
op_assign
id|mac_mask
(braket
l_int|4
)braket
suffix:semicolon
(paren
op_star
id|secfilter
)paren
op_member_access_from_pointer
id|filter_mask
(braket
l_int|8
)braket
op_assign
id|mac_mask
(braket
l_int|3
)braket
suffix:semicolon
(paren
op_star
id|secfilter
)paren
op_member_access_from_pointer
id|filter_mask
(braket
l_int|9
)braket
op_assign
id|mac_mask
(braket
l_int|2
)braket
suffix:semicolon
(paren
op_star
id|secfilter
)paren
op_member_access_from_pointer
id|filter_mask
(braket
l_int|10
)braket
op_assign
id|mac_mask
(braket
l_int|1
)braket
suffix:semicolon
(paren
op_star
id|secfilter
)paren
op_member_access_from_pointer
id|filter_mask
(braket
l_int|11
)braket
op_assign
id|mac_mask
(braket
l_int|0
)braket
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;%s: filter mac=%02x %02x %02x %02x %02x %02x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|mac
(braket
l_int|0
)braket
comma
id|mac
(braket
l_int|1
)braket
comma
id|mac
(braket
l_int|2
)braket
comma
id|mac
(braket
l_int|3
)braket
comma
id|mac
(braket
l_int|4
)braket
comma
id|mac
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;%s: filter mask=%02x %02x %02x %02x %02x %02x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|mac_mask
(braket
l_int|0
)braket
comma
id|mac_mask
(braket
l_int|1
)braket
comma
id|mac_mask
(braket
l_int|2
)braket
comma
id|mac_mask
(braket
l_int|3
)braket
comma
id|mac_mask
(braket
l_int|4
)braket
comma
id|mac_mask
(braket
l_int|5
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dvb_net_feed_start
r_static
r_int
id|dvb_net_feed_start
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|ret
comma
id|i
suffix:semicolon
r_struct
id|dvb_net_priv
op_star
id|priv
op_assign
(paren
r_struct
id|dvb_net_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|dmx_demux
op_star
id|demux
op_assign
id|priv-&gt;demux
suffix:semicolon
r_int
r_char
op_star
id|mac
op_assign
(paren
r_int
r_char
op_star
)paren
id|dev-&gt;dev_addr
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;%s: rx_mode %i&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|priv-&gt;rx_mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;tsfeed
op_logical_or
id|priv-&gt;secfeed
op_logical_or
id|priv-&gt;secfilter
op_logical_or
id|priv-&gt;multi_secfilter
(braket
l_int|0
)braket
)paren
id|printk
c_func
(paren
l_string|&quot;%s: BUG %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|__LINE__
)paren
suffix:semicolon
id|priv-&gt;secfeed
op_assign
l_int|NULL
suffix:semicolon
id|priv-&gt;secfilter
op_assign
l_int|NULL
suffix:semicolon
id|priv-&gt;tsfeed
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;feedtype
op_eq
id|DVB_NET_FEEDTYPE_MPE
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;%s: alloc secfeed&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|ret
op_assign
id|demux
op_member_access_from_pointer
id|allocate_section_feed
c_func
(paren
id|demux
comma
op_amp
id|priv-&gt;secfeed
comma
id|dvb_net_sec_callback
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: could not allocate section feed&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|ret
op_assign
id|priv-&gt;secfeed
op_member_access_from_pointer
id|set
c_func
(paren
id|priv-&gt;secfeed
comma
id|priv-&gt;pid
comma
l_int|32768
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: could not set section feed&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|priv-&gt;demux
op_member_access_from_pointer
id|release_section_feed
c_func
(paren
id|priv-&gt;demux
comma
id|priv-&gt;secfeed
)paren
suffix:semicolon
id|priv-&gt;secfeed
op_assign
l_int|NULL
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|priv-&gt;rx_mode
op_ne
id|RX_MODE_PROMISC
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;%s: set secfilter&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|dvb_net_filter_sec_set
c_func
(paren
id|dev
comma
op_amp
id|priv-&gt;secfilter
comma
id|mac
comma
id|mask_normal
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|priv-&gt;rx_mode
)paren
(brace
r_case
id|RX_MODE_MULTI
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|priv-&gt;multi_num
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;%s: set multi_secfilter[%d]&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|i
)paren
suffix:semicolon
id|dvb_net_filter_sec_set
c_func
(paren
id|dev
comma
op_amp
id|priv-&gt;multi_secfilter
(braket
id|i
)braket
comma
id|priv-&gt;multi_macs
(braket
id|i
)braket
comma
id|mask_normal
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RX_MODE_ALL_MULTI
suffix:colon
id|priv-&gt;multi_num
op_assign
l_int|1
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;%s: set multi_secfilter[0]&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|dvb_net_filter_sec_set
c_func
(paren
id|dev
comma
op_amp
id|priv-&gt;multi_secfilter
(braket
l_int|0
)braket
comma
id|mac_allmulti
comma
id|mask_allmulti
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RX_MODE_PROMISC
suffix:colon
id|priv-&gt;multi_num
op_assign
l_int|0
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;%s: set secfilter&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|dvb_net_filter_sec_set
c_func
(paren
id|dev
comma
op_amp
id|priv-&gt;secfilter
comma
id|mac
comma
id|mask_promisc
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;%s: start filtering&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|priv-&gt;secfeed
op_member_access_from_pointer
id|start_filtering
c_func
(paren
id|priv-&gt;secfeed
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|priv-&gt;feedtype
op_eq
id|DVB_NET_FEEDTYPE_ULE
)paren
(brace
r_struct
id|timespec
id|timeout
op_assign
(brace
l_int|0
comma
l_int|30000000
)brace
suffix:semicolon
singleline_comment|// 30 msec
multiline_comment|/* we have payloads encapsulated in TS */
id|dprintk
c_func
(paren
l_string|&quot;%s: alloc tsfeed&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|ret
op_assign
id|demux
op_member_access_from_pointer
id|allocate_ts_feed
c_func
(paren
id|demux
comma
op_amp
id|priv-&gt;tsfeed
comma
id|dvb_net_ts_callback
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: could not allocate ts feed&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Set netdevice pointer for ts decaps callback. */
id|priv-&gt;tsfeed-&gt;priv
op_assign
(paren
r_void
op_star
)paren
id|dev
suffix:semicolon
id|ret
op_assign
id|priv-&gt;tsfeed
op_member_access_from_pointer
id|set
c_func
(paren
id|priv-&gt;tsfeed
comma
id|priv-&gt;pid
comma
id|TS_PACKET
comma
id|DMX_TS_PES_OTHER
comma
l_int|188
op_star
l_int|100
comma
multiline_comment|/* nr. of bytes delivered per callback */
l_int|32768
comma
multiline_comment|/* circular buffer size */
l_int|0
comma
multiline_comment|/* descramble */
id|timeout
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: could not set ts feed&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|priv-&gt;demux
op_member_access_from_pointer
id|release_ts_feed
c_func
(paren
id|priv-&gt;demux
comma
id|priv-&gt;tsfeed
)paren
suffix:semicolon
id|priv-&gt;tsfeed
op_assign
l_int|NULL
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;%s: start filtering&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|priv-&gt;tsfeed
op_member_access_from_pointer
id|start_filtering
c_func
(paren
id|priv-&gt;tsfeed
)paren
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dvb_net_feed_stop
r_static
r_int
id|dvb_net_feed_stop
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|dvb_net_priv
op_star
id|priv
op_assign
(paren
r_struct
id|dvb_net_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|i
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;feedtype
op_eq
id|DVB_NET_FEEDTYPE_MPE
)paren
(brace
r_if
c_cond
(paren
id|priv-&gt;secfeed
)paren
(brace
r_if
c_cond
(paren
id|priv-&gt;secfeed-&gt;is_filtering
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;%s: stop secfeed&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|priv-&gt;secfeed
op_member_access_from_pointer
id|stop_filtering
c_func
(paren
id|priv-&gt;secfeed
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|priv-&gt;secfilter
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;%s: release secfilter&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|priv-&gt;secfeed
op_member_access_from_pointer
id|release_filter
c_func
(paren
id|priv-&gt;secfeed
comma
id|priv-&gt;secfilter
)paren
suffix:semicolon
id|priv-&gt;secfilter
op_assign
l_int|NULL
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|priv-&gt;multi_num
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|priv-&gt;multi_secfilter
(braket
id|i
)braket
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;%s: release multi_filter[%d]&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|i
)paren
suffix:semicolon
id|priv-&gt;secfeed
op_member_access_from_pointer
id|release_filter
c_func
(paren
id|priv-&gt;secfeed
comma
id|priv-&gt;multi_secfilter
(braket
id|i
)braket
)paren
suffix:semicolon
id|priv-&gt;multi_secfilter
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|priv-&gt;demux
op_member_access_from_pointer
id|release_section_feed
c_func
(paren
id|priv-&gt;demux
comma
id|priv-&gt;secfeed
)paren
suffix:semicolon
id|priv-&gt;secfeed
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;%s: no feed to stop&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|priv-&gt;feedtype
op_eq
id|DVB_NET_FEEDTYPE_ULE
)paren
(brace
r_if
c_cond
(paren
id|priv-&gt;tsfeed
)paren
(brace
r_if
c_cond
(paren
id|priv-&gt;tsfeed-&gt;is_filtering
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;%s: stop tsfeed&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|priv-&gt;tsfeed
op_member_access_from_pointer
id|stop_filtering
c_func
(paren
id|priv-&gt;tsfeed
)paren
suffix:semicolon
)brace
id|priv-&gt;demux
op_member_access_from_pointer
id|release_ts_feed
c_func
(paren
id|priv-&gt;demux
comma
id|priv-&gt;tsfeed
)paren
suffix:semicolon
id|priv-&gt;tsfeed
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;%s: no ts feed to stop&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dvb_set_mc_filter
r_static
r_int
id|dvb_set_mc_filter
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|dev_mc_list
op_star
id|mc
)paren
(brace
r_struct
id|dvb_net_priv
op_star
id|priv
op_assign
(paren
r_struct
id|dvb_net_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;multi_num
op_eq
id|DVB_NET_MULTICAST_MAX
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memcpy
c_func
(paren
id|priv-&gt;multi_macs
(braket
id|priv-&gt;multi_num
)braket
comma
id|mc-&gt;dmi_addr
comma
l_int|6
)paren
suffix:semicolon
id|priv-&gt;multi_num
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|wq_set_multicast_list
r_static
r_void
id|wq_set_multicast_list
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|data
suffix:semicolon
r_struct
id|dvb_net_priv
op_star
id|priv
op_assign
(paren
r_struct
id|dvb_net_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|dvb_net_feed_stop
c_func
(paren
id|dev
)paren
suffix:semicolon
id|priv-&gt;rx_mode
op_assign
id|RX_MODE_UNI
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;%s: promiscuous mode&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|priv-&gt;rx_mode
op_assign
id|RX_MODE_PROMISC
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;%s: allmulti mode&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|priv-&gt;rx_mode
op_assign
id|RX_MODE_ALL_MULTI
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;mc_count
)paren
(brace
r_int
id|mci
suffix:semicolon
r_struct
id|dev_mc_list
op_star
id|mc
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;%s: set_mc_list, %d entries&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;mc_count
)paren
suffix:semicolon
id|priv-&gt;rx_mode
op_assign
id|RX_MODE_MULTI
suffix:semicolon
id|priv-&gt;multi_num
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|mci
op_assign
l_int|0
comma
id|mc
op_assign
id|dev-&gt;mc_list
suffix:semicolon
id|mci
OL
id|dev-&gt;mc_count
suffix:semicolon
id|mc
op_assign
id|mc-&gt;next
comma
id|mci
op_increment
)paren
(brace
id|dvb_set_mc_filter
c_func
(paren
id|dev
comma
id|mc
)paren
suffix:semicolon
)brace
)brace
id|dvb_net_feed_start
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
DECL|function|dvb_net_set_multicast_list
r_static
r_void
id|dvb_net_set_multicast_list
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|dvb_net_priv
op_star
id|priv
op_assign
(paren
r_struct
id|dvb_net_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|schedule_work
c_func
(paren
op_amp
id|priv-&gt;set_multicast_list_wq
)paren
suffix:semicolon
)brace
DECL|function|wq_restart_net_feed
r_static
r_void
id|wq_restart_net_feed
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|data
suffix:semicolon
r_if
c_cond
(paren
id|netif_running
c_func
(paren
id|dev
)paren
)paren
(brace
id|dvb_net_feed_stop
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dvb_net_feed_start
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
DECL|function|dvb_net_set_mac
r_static
r_int
id|dvb_net_set_mac
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_void
op_star
id|p
)paren
(brace
r_struct
id|dvb_net_priv
op_star
id|priv
op_assign
(paren
r_struct
id|dvb_net_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|sockaddr
op_star
id|addr
op_assign
id|p
suffix:semicolon
id|memcpy
c_func
(paren
id|dev-&gt;dev_addr
comma
id|addr-&gt;sa_data
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|netif_running
c_func
(paren
id|dev
)paren
)paren
id|schedule_work
c_func
(paren
op_amp
id|priv-&gt;restart_net_feed_wq
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dvb_net_open
r_static
r_int
id|dvb_net_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|dvb_net_priv
op_star
id|priv
op_assign
(paren
r_struct
id|dvb_net_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|priv-&gt;in_use
op_increment
suffix:semicolon
id|dvb_net_feed_start
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dvb_net_stop
r_static
r_int
id|dvb_net_stop
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|dvb_net_priv
op_star
id|priv
op_assign
(paren
r_struct
id|dvb_net_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|priv-&gt;in_use
op_decrement
suffix:semicolon
r_return
id|dvb_net_feed_stop
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
DECL|function|dvb_net_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|dvb_net_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_return
op_amp
(paren
(paren
r_struct
id|dvb_net_priv
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|stats
suffix:semicolon
)brace
DECL|function|dvb_net_setup
r_static
r_void
id|dvb_net_setup
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;open
op_assign
id|dvb_net_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|dvb_net_stop
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|dvb_net_tx
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|dvb_net_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
id|dvb_net_set_multicast_list
suffix:semicolon
id|dev-&gt;set_mac_address
op_assign
id|dvb_net_set_mac
suffix:semicolon
id|dev-&gt;mtu
op_assign
l_int|4096
suffix:semicolon
id|dev-&gt;mc_count
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;hard_header_cache
op_assign
l_int|NULL
suffix:semicolon
id|dev-&gt;flags
op_or_assign
id|IFF_NOARP
suffix:semicolon
)brace
DECL|function|get_if
r_static
r_int
id|get_if
c_func
(paren
r_struct
id|dvb_net
op_star
id|dvbnet
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DVB_NET_DEVICES_MAX
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|dvbnet-&gt;state
(braket
id|i
)braket
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|DVB_NET_DEVICES_MAX
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|dvbnet-&gt;state
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
DECL|function|dvb_net_add_if
r_static
r_int
id|dvb_net_add_if
c_func
(paren
r_struct
id|dvb_net
op_star
id|dvbnet
comma
id|u16
id|pid
comma
id|u8
id|feedtype
)paren
(brace
r_struct
id|net_device
op_star
id|net
suffix:semicolon
r_struct
id|dvb_net_priv
op_star
id|priv
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
id|if_num
suffix:semicolon
r_if
c_cond
(paren
id|feedtype
op_ne
id|DVB_NET_FEEDTYPE_MPE
op_logical_and
id|feedtype
op_ne
id|DVB_NET_FEEDTYPE_ULE
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|if_num
op_assign
id|get_if
c_func
(paren
id|dvbnet
)paren
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|net
op_assign
id|alloc_netdev
c_func
(paren
r_sizeof
(paren
r_struct
id|dvb_net_priv
)paren
comma
l_string|&quot;dvb&quot;
comma
id|dvb_net_setup
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|net
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|sprintf
c_func
(paren
id|net-&gt;name
comma
l_string|&quot;dvb%d_%d&quot;
comma
id|dvbnet-&gt;dvbdev-&gt;adapter-&gt;num
comma
id|if_num
)paren
suffix:semicolon
id|net-&gt;addr_len
op_assign
l_int|6
suffix:semicolon
id|memcpy
c_func
(paren
id|net-&gt;dev_addr
comma
id|dvbnet-&gt;dvbdev-&gt;adapter-&gt;proposed_mac
comma
l_int|6
)paren
suffix:semicolon
id|dvbnet-&gt;device
(braket
id|if_num
)braket
op_assign
id|net
suffix:semicolon
id|priv
op_assign
id|net-&gt;priv
suffix:semicolon
id|priv-&gt;demux
op_assign
id|dvbnet-&gt;demux
suffix:semicolon
id|priv-&gt;pid
op_assign
id|pid
suffix:semicolon
id|priv-&gt;rx_mode
op_assign
id|RX_MODE_UNI
suffix:semicolon
id|priv-&gt;need_pusi
op_assign
l_int|1
suffix:semicolon
id|priv-&gt;tscc
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;feedtype
op_assign
id|feedtype
suffix:semicolon
id|reset_ule
c_func
(paren
id|priv
)paren
suffix:semicolon
id|INIT_WORK
c_func
(paren
op_amp
id|priv-&gt;set_multicast_list_wq
comma
id|wq_set_multicast_list
comma
id|net
)paren
suffix:semicolon
id|INIT_WORK
c_func
(paren
op_amp
id|priv-&gt;restart_net_feed_wq
comma
id|wq_restart_net_feed
comma
id|net
)paren
suffix:semicolon
id|net-&gt;base_addr
op_assign
id|pid
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|register_netdev
c_func
(paren
id|net
)paren
)paren
OL
l_int|0
)paren
(brace
id|dvbnet-&gt;device
(braket
id|if_num
)braket
op_assign
l_int|NULL
suffix:semicolon
id|free_netdev
c_func
(paren
id|net
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_return
id|if_num
suffix:semicolon
)brace
DECL|function|dvb_net_remove_if
r_static
r_int
id|dvb_net_remove_if
c_func
(paren
r_struct
id|dvb_net
op_star
id|dvbnet
comma
r_int
id|num
)paren
(brace
r_struct
id|net_device
op_star
id|net
op_assign
id|dvbnet-&gt;device
(braket
id|num
)braket
suffix:semicolon
r_struct
id|dvb_net_priv
op_star
id|priv
op_assign
id|net-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dvbnet-&gt;state
(braket
id|num
)braket
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;in_use
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|dvb_net_stop
c_func
(paren
id|net
)paren
suffix:semicolon
id|flush_scheduled_work
c_func
(paren
)paren
suffix:semicolon
id|unregister_netdev
c_func
(paren
id|net
)paren
suffix:semicolon
id|dvbnet-&gt;state
(braket
id|num
)braket
op_assign
l_int|0
suffix:semicolon
id|dvbnet-&gt;device
(braket
id|num
)braket
op_assign
l_int|NULL
suffix:semicolon
id|free_netdev
c_func
(paren
id|net
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dvb_net_do_ioctl
r_static
r_int
id|dvb_net_do_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_void
op_star
id|parg
)paren
(brace
r_struct
id|dvb_device
op_star
id|dvbdev
op_assign
(paren
r_struct
id|dvb_device
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_struct
id|dvb_net
op_star
id|dvbnet
op_assign
(paren
r_struct
id|dvb_net
op_star
)paren
id|dvbdev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|file-&gt;f_flags
op_amp
id|O_ACCMODE
)paren
op_eq
id|O_RDONLY
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|NET_ADD_IF
suffix:colon
(brace
r_struct
id|dvb_net_if
op_star
id|dvbnetif
op_assign
(paren
r_struct
id|dvb_net_if
op_star
)paren
id|parg
suffix:semicolon
r_int
id|result
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|try_module_get
c_func
(paren
id|dvbdev-&gt;adapter-&gt;module
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|result
op_assign
id|dvb_net_add_if
c_func
(paren
id|dvbnet
comma
id|dvbnetif-&gt;pid
comma
id|dvbnetif-&gt;feedtype
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|module_put
c_func
(paren
id|dvbdev-&gt;adapter-&gt;module
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|dvbnetif-&gt;if_num
op_assign
id|result
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|NET_GET_IF
suffix:colon
(brace
r_struct
id|net_device
op_star
id|netdev
suffix:semicolon
r_struct
id|dvb_net_priv
op_star
id|priv_data
suffix:semicolon
r_struct
id|dvb_net_if
op_star
id|dvbnetif
op_assign
(paren
r_struct
id|dvb_net_if
op_star
)paren
id|parg
suffix:semicolon
r_if
c_cond
(paren
id|dvbnetif-&gt;if_num
op_ge
id|DVB_NET_DEVICES_MAX
op_logical_or
op_logical_neg
id|dvbnet-&gt;state
(braket
id|dvbnetif-&gt;if_num
)braket
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|netdev
op_assign
id|dvbnet-&gt;device
(braket
id|dvbnetif-&gt;if_num
)braket
suffix:semicolon
id|priv_data
op_assign
(paren
r_struct
id|dvb_net_priv
op_star
)paren
id|netdev-&gt;priv
suffix:semicolon
id|dvbnetif-&gt;pid
op_assign
id|priv_data-&gt;pid
suffix:semicolon
id|dvbnetif-&gt;feedtype
op_assign
id|priv_data-&gt;feedtype
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|NET_REMOVE_IF
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|module_put
c_func
(paren
id|dvbdev-&gt;adapter-&gt;module
)paren
suffix:semicolon
r_return
id|dvb_net_remove_if
c_func
(paren
id|dvbnet
comma
(paren
r_int
)paren
(paren
r_int
)paren
id|parg
)paren
suffix:semicolon
multiline_comment|/* binary compatiblity cruft */
r_case
id|__NET_ADD_IF_OLD
suffix:colon
(brace
r_struct
id|__dvb_net_if_old
op_star
id|dvbnetif
op_assign
(paren
r_struct
id|__dvb_net_if_old
op_star
)paren
id|parg
suffix:semicolon
r_int
id|result
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|try_module_get
c_func
(paren
id|dvbdev-&gt;adapter-&gt;module
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|result
op_assign
id|dvb_net_add_if
c_func
(paren
id|dvbnet
comma
id|dvbnetif-&gt;pid
comma
id|DVB_NET_FEEDTYPE_MPE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|module_put
c_func
(paren
id|dvbdev-&gt;adapter-&gt;module
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|dvbnetif-&gt;if_num
op_assign
id|result
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|__NET_GET_IF_OLD
suffix:colon
(brace
r_struct
id|net_device
op_star
id|netdev
suffix:semicolon
r_struct
id|dvb_net_priv
op_star
id|priv_data
suffix:semicolon
r_struct
id|__dvb_net_if_old
op_star
id|dvbnetif
op_assign
(paren
r_struct
id|__dvb_net_if_old
op_star
)paren
id|parg
suffix:semicolon
r_if
c_cond
(paren
id|dvbnetif-&gt;if_num
op_ge
id|DVB_NET_DEVICES_MAX
op_logical_or
op_logical_neg
id|dvbnet-&gt;state
(braket
id|dvbnetif-&gt;if_num
)braket
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|netdev
op_assign
id|dvbnet-&gt;device
(braket
id|dvbnetif-&gt;if_num
)braket
suffix:semicolon
id|priv_data
op_assign
(paren
r_struct
id|dvb_net_priv
op_star
)paren
id|netdev-&gt;priv
suffix:semicolon
id|dvbnetif-&gt;pid
op_assign
id|priv_data-&gt;pid
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
r_return
op_minus
id|ENOTTY
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dvb_net_ioctl
r_static
r_int
id|dvb_net_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_return
id|dvb_usercopy
c_func
(paren
id|inode
comma
id|file
comma
id|cmd
comma
id|arg
comma
id|dvb_net_do_ioctl
)paren
suffix:semicolon
)brace
DECL|variable|dvb_net_fops
r_static
r_struct
id|file_operations
id|dvb_net_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|ioctl
op_assign
id|dvb_net_ioctl
comma
dot
id|open
op_assign
id|dvb_generic_open
comma
dot
id|release
op_assign
id|dvb_generic_release
comma
)brace
suffix:semicolon
DECL|variable|dvbdev_net
r_static
r_struct
id|dvb_device
id|dvbdev_net
op_assign
(brace
dot
id|priv
op_assign
l_int|NULL
comma
dot
id|users
op_assign
l_int|1
comma
dot
id|writers
op_assign
l_int|1
comma
dot
id|fops
op_assign
op_amp
id|dvb_net_fops
comma
)brace
suffix:semicolon
DECL|function|dvb_net_release
r_void
id|dvb_net_release
(paren
r_struct
id|dvb_net
op_star
id|dvbnet
)paren
(brace
r_int
id|i
suffix:semicolon
id|dvb_unregister_device
c_func
(paren
id|dvbnet-&gt;dvbdev
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DVB_NET_DEVICES_MAX
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dvbnet-&gt;state
(braket
id|i
)braket
)paren
r_continue
suffix:semicolon
id|dvb_net_remove_if
c_func
(paren
id|dvbnet
comma
id|i
)paren
suffix:semicolon
)brace
)brace
DECL|variable|dvb_net_release
id|EXPORT_SYMBOL
c_func
(paren
id|dvb_net_release
)paren
suffix:semicolon
DECL|function|dvb_net_init
r_int
id|dvb_net_init
(paren
r_struct
id|dvb_adapter
op_star
id|adap
comma
r_struct
id|dvb_net
op_star
id|dvbnet
comma
r_struct
id|dmx_demux
op_star
id|dmx
)paren
(brace
r_int
id|i
suffix:semicolon
id|dvbnet-&gt;demux
op_assign
id|dmx
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DVB_NET_DEVICES_MAX
suffix:semicolon
id|i
op_increment
)paren
id|dvbnet-&gt;state
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|dvb_register_device
(paren
id|adap
comma
op_amp
id|dvbnet-&gt;dvbdev
comma
op_amp
id|dvbdev_net
comma
id|dvbnet
comma
id|DVB_DEVICE_NET
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|dvb_net_init
id|EXPORT_SYMBOL
c_func
(paren
id|dvb_net_init
)paren
suffix:semicolon
eof
