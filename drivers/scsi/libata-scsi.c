multiline_comment|/*&n;   libata-scsi.c - helper library for ATA&n;&n;   Copyright 2003-2004 Red Hat, Inc.  All rights reserved.&n;   Copyright 2003-2004 Jeff Garzik&n;&n;   The contents of this file are subject to the Open&n;   Software License version 1.1 that can be found at&n;   http://www.opensource.org/licenses/osl-1.1.txt and is included herein&n;   by reference.&n;&n;   Alternatively, the contents of this file may be used under the terms&n;   of the GNU General Public License version 2 (the &quot;GPL&quot;) as distributed&n;   in the kernel source COPYING file, in which case the provisions of&n;   the GPL are applicable instead of the above.  If you wish to allow&n;   the use of your version of this file only under the terms of the&n;   GPL and not to allow others to use your version of this file under&n;   the OSL, indicate your decision by deleting the provisions above and&n;   replace them with the notice and other provisions required by the GPL.&n;   If you do not delete the provisions above, a recipient may use your&n;   version of this file under either the OSL or the GPL.&n;&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;scsi/scsi.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &lt;scsi/scsi_host.h&gt;
macro_line|#include &lt;linux/libata.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &quot;libata.h&quot;
DECL|typedef|ata_xlat_func_t
r_typedef
r_int
r_int
(paren
op_star
id|ata_xlat_func_t
)paren
(paren
r_struct
id|ata_queued_cmd
op_star
id|qc
comma
id|u8
op_star
id|scsicmd
)paren
suffix:semicolon
r_static
r_struct
id|ata_device
op_star
id|ata_scsi_find_dev
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_struct
id|scsi_device
op_star
id|scsidev
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;ata_std_bios_param - generic bios head/sector/cylinder calculator used by sd.&n; *&t;@sdev: SCSI device for which BIOS geometry is to be determined&n; *&t;@bdev: block device associated with @sdev&n; *&t;@capacity: capacity of SCSI device&n; *&t;@geom: location to which geometry will be output&n; *&n; *&t;Generic bios head/sector/cylinder calculator&n; *&t;used by sd. Most BIOSes nowadays expect a XXX/255/16  (CHS)&n; *&t;mapping. Some situations may arise where the disk is not&n; *&t;bootable if this is not used.&n; *&n; *&t;LOCKING:&n; *&t;Defined by the SCSI layer.  We don&squot;t really care.&n; *&n; *&t;RETURNS:&n; *&t;Zero.&n; */
DECL|function|ata_std_bios_param
r_int
id|ata_std_bios_param
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
comma
r_struct
id|block_device
op_star
id|bdev
comma
id|sector_t
id|capacity
comma
r_int
id|geom
(braket
)braket
)paren
(brace
id|geom
(braket
l_int|0
)braket
op_assign
l_int|255
suffix:semicolon
id|geom
(braket
l_int|1
)braket
op_assign
l_int|63
suffix:semicolon
id|sector_div
c_func
(paren
id|capacity
comma
l_int|255
op_star
l_int|63
)paren
suffix:semicolon
id|geom
(braket
l_int|2
)braket
op_assign
id|capacity
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ata_scsi_ioctl
r_int
id|ata_scsi_ioctl
c_func
(paren
r_struct
id|scsi_device
op_star
id|scsidev
comma
r_int
id|cmd
comma
r_void
id|__user
op_star
id|arg
)paren
(brace
r_struct
id|ata_port
op_star
id|ap
suffix:semicolon
r_struct
id|ata_device
op_star
id|dev
suffix:semicolon
r_int
id|val
op_assign
op_minus
id|EINVAL
comma
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|ap
op_assign
(paren
r_struct
id|ata_port
op_star
)paren
op_amp
id|scsidev-&gt;host-&gt;hostdata
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ap
)paren
r_goto
id|out
suffix:semicolon
id|dev
op_assign
id|ata_scsi_find_dev
c_func
(paren
id|ap
comma
id|scsidev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|rc
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|ATA_IOC_GET_IO32
suffix:colon
id|val
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|val
comma
l_int|1
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|ATA_IOC_SET_IO32
suffix:colon
id|val
op_assign
(paren
r_int
r_int
)paren
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|val
op_ne
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
id|rc
op_assign
op_minus
id|ENOTTY
suffix:semicolon
r_break
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_scsi_qc_new - acquire new ata_queued_cmd reference&n; *&t;@ap: ATA port to which the new command is attached&n; *&t;@dev: ATA device to which the new command is attached&n; *&t;@cmd: SCSI command that originated this ATA command&n; *&t;@done: SCSI command completion function&n; *&n; *&t;Obtain a reference to an unused ata_queued_cmd structure,&n; *&t;which is the basic libata structure representing a single&n; *&t;ATA command sent to the hardware.&n; *&n; *&t;If a command was available, fill in the SCSI-specific&n; *&t;portions of the structure with information on the&n; *&t;current command.&n; *&n; *&t;LOCKING:&n; *&t;spin_lock_irqsave(host_set lock)&n; *&n; *&t;RETURNS:&n; *&t;Command allocated, or %NULL if none available.&n; */
DECL|function|ata_scsi_qc_new
r_struct
id|ata_queued_cmd
op_star
id|ata_scsi_qc_new
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_struct
id|ata_device
op_star
id|dev
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
r_struct
id|scsi_cmnd
op_star
)paren
)paren
(brace
r_struct
id|ata_queued_cmd
op_star
id|qc
suffix:semicolon
id|qc
op_assign
id|ata_qc_new_init
c_func
(paren
id|ap
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qc
)paren
(brace
id|qc-&gt;scsicmd
op_assign
id|cmd
suffix:semicolon
id|qc-&gt;scsidone
op_assign
id|done
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;use_sg
)paren
(brace
id|qc-&gt;sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;request_buffer
suffix:semicolon
id|qc-&gt;n_elem
op_assign
id|cmd-&gt;use_sg
suffix:semicolon
)brace
r_else
(brace
id|qc-&gt;sg
op_assign
op_amp
id|qc-&gt;sgent
suffix:semicolon
id|qc-&gt;n_elem
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|cmd-&gt;result
op_assign
(paren
id|DID_OK
op_lshift
l_int|16
)paren
op_or
(paren
id|QUEUE_FULL
op_lshift
l_int|1
)paren
suffix:semicolon
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
r_return
id|qc
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_to_sense_error - convert ATA error to SCSI error&n; *&t;@qc: Command that we are erroring out&n; *&t;@drv_stat: value contained in ATA status register&n; *&n; *&t;Converts an ATA error into a SCSI error. While we are at it&n; *&t;we decode and dump the ATA error for the user so that they&n; *&t;have some idea what really happened at the non make-believe&n; *&t;layer.&n; *&n; *&t;LOCKING:&n; *&t;spin_lock_irqsave(host_set lock)&n; */
DECL|function|ata_to_sense_error
r_void
id|ata_to_sense_error
c_func
(paren
r_struct
id|ata_queued_cmd
op_star
id|qc
comma
id|u8
id|drv_stat
)paren
(brace
r_struct
id|scsi_cmnd
op_star
id|cmd
op_assign
id|qc-&gt;scsicmd
suffix:semicolon
id|u8
id|err
op_assign
l_int|0
suffix:semicolon
r_int
r_char
op_star
id|sb
op_assign
id|cmd-&gt;sense_buffer
suffix:semicolon
multiline_comment|/* Based on the 3ware driver translation table */
r_static
r_int
r_char
id|sense_table
(braket
)braket
(braket
l_int|4
)braket
op_assign
(brace
multiline_comment|/* BBD|ECC|ID|MAR */
(brace
l_int|0xd1
comma
id|ABORTED_COMMAND
comma
l_int|0x00
comma
l_int|0x00
)brace
comma
singleline_comment|// Device busy                  Aborted command
multiline_comment|/* BBD|ECC|ID */
(brace
l_int|0xd0
comma
id|ABORTED_COMMAND
comma
l_int|0x00
comma
l_int|0x00
)brace
comma
singleline_comment|// Device busy                  Aborted command
multiline_comment|/* ECC|MC|MARK */
(brace
l_int|0x61
comma
id|HARDWARE_ERROR
comma
l_int|0x00
comma
l_int|0x00
)brace
comma
singleline_comment|// Device fault                 Hardware error
multiline_comment|/* ICRC|ABRT */
multiline_comment|/* NB: ICRC &amp; !ABRT is BBD */
(brace
l_int|0x84
comma
id|ABORTED_COMMAND
comma
l_int|0x47
comma
l_int|0x00
)brace
comma
singleline_comment|// Data CRC error               SCSI parity error
multiline_comment|/* MC|ID|ABRT|TRK0|MARK */
(brace
l_int|0x37
comma
id|NOT_READY
comma
l_int|0x04
comma
l_int|0x00
)brace
comma
singleline_comment|// Unit offline                 Not ready
multiline_comment|/* MCR|MARK */
(brace
l_int|0x09
comma
id|NOT_READY
comma
l_int|0x04
comma
l_int|0x00
)brace
comma
singleline_comment|// Unrecovered disk error       Not ready
multiline_comment|/*  Bad address mark */
(brace
l_int|0x01
comma
id|MEDIUM_ERROR
comma
l_int|0x13
comma
l_int|0x00
)brace
comma
singleline_comment|// Address mark not found       Address mark not found for data field
multiline_comment|/* TRK0 */
(brace
l_int|0x02
comma
id|HARDWARE_ERROR
comma
l_int|0x00
comma
l_int|0x00
)brace
comma
singleline_comment|// Track 0 not found&t;&t;  Hardware error
multiline_comment|/* Abort &amp; !ICRC */
(brace
l_int|0x04
comma
id|ABORTED_COMMAND
comma
l_int|0x00
comma
l_int|0x00
)brace
comma
singleline_comment|// Aborted command              Aborted command
multiline_comment|/* Media change request */
(brace
l_int|0x08
comma
id|NOT_READY
comma
l_int|0x04
comma
l_int|0x00
)brace
comma
singleline_comment|// Media change request&t;  FIXME: faking offline
multiline_comment|/* SRV */
(brace
l_int|0x10
comma
id|ABORTED_COMMAND
comma
l_int|0x14
comma
l_int|0x00
)brace
comma
singleline_comment|// ID not found                 Recorded entity not found
multiline_comment|/* Media change */
(brace
l_int|0x08
comma
id|NOT_READY
comma
l_int|0x04
comma
l_int|0x00
)brace
comma
singleline_comment|// Media change&t;&t;  FIXME: faking offline
multiline_comment|/* ECC */
(brace
l_int|0x40
comma
id|MEDIUM_ERROR
comma
l_int|0x11
comma
l_int|0x04
)brace
comma
singleline_comment|// Uncorrectable ECC error      Unrecovered read error
multiline_comment|/* BBD - block marked bad */
(brace
l_int|0x80
comma
id|MEDIUM_ERROR
comma
l_int|0x11
comma
l_int|0x04
)brace
comma
singleline_comment|// Block marked bad&t;&t;  Medium error, unrecovered read error
(brace
l_int|0xFF
comma
l_int|0xFF
comma
l_int|0xFF
comma
l_int|0xFF
)brace
comma
singleline_comment|// END mark
)brace
suffix:semicolon
r_static
r_int
r_char
id|stat_table
(braket
)braket
(braket
l_int|4
)braket
op_assign
(brace
multiline_comment|/* Must be first because BUSY means no other bits valid */
(brace
l_int|0x80
comma
id|ABORTED_COMMAND
comma
l_int|0x47
comma
l_int|0x00
)brace
comma
singleline_comment|// Busy, fake parity for now
(brace
l_int|0x20
comma
id|HARDWARE_ERROR
comma
l_int|0x00
comma
l_int|0x00
)brace
comma
singleline_comment|// Device fault
(brace
l_int|0x08
comma
id|ABORTED_COMMAND
comma
l_int|0x47
comma
l_int|0x00
)brace
comma
singleline_comment|// Timed out in xfer, fake parity for now
(brace
l_int|0x04
comma
id|RECOVERED_ERROR
comma
l_int|0x11
comma
l_int|0x00
)brace
comma
singleline_comment|// Recovered ECC error&t;  Medium error, recovered
(brace
l_int|0xFF
comma
l_int|0xFF
comma
l_int|0xFF
comma
l_int|0xFF
)brace
comma
singleline_comment|// END mark
)brace
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;result
op_assign
id|SAM_STAT_CHECK_CONDITION
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Is this an error we can process/parse&n;&t; */
r_if
c_cond
(paren
id|drv_stat
op_amp
id|ATA_ERR
)paren
(brace
multiline_comment|/* Read the err bits */
id|err
op_assign
id|ata_chk_err
c_func
(paren
id|qc-&gt;ap
)paren
suffix:semicolon
)brace
multiline_comment|/* Display the ATA level error info */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ata%u: status=0x%02x { &quot;
comma
id|qc-&gt;ap-&gt;id
comma
id|drv_stat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv_stat
op_amp
l_int|0x80
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Busy &quot;
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Data is not valid in this case */
)brace
r_else
(brace
r_if
c_cond
(paren
id|drv_stat
op_amp
l_int|0x40
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DriveReady &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|drv_stat
op_amp
l_int|0x20
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DeviceFault &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|drv_stat
op_amp
l_int|0x10
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SeekComplete &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|drv_stat
op_amp
l_int|0x08
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DataRequest &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|drv_stat
op_amp
l_int|0x04
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CorrectedError &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|drv_stat
op_amp
l_int|0x02
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Index &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|drv_stat
op_amp
l_int|0x01
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Error &quot;
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;}&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ata%u: error=0x%02x { &quot;
comma
id|qc-&gt;ap-&gt;id
comma
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
l_int|0x04
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DriveStatusError &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
op_amp
l_int|0x80
)paren
(brace
r_if
c_cond
(paren
id|err
op_amp
l_int|0x04
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;BadCRC &quot;
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;Sector &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
op_amp
l_int|0x40
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;UncorrectableError &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
op_amp
l_int|0x10
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SectorIdNotFound &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
op_amp
l_int|0x02
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;TrackZeroNotFound &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
op_amp
l_int|0x01
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;AddrMarkNotFound &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;}&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Should we dump sector info here too ?? */
)brace
multiline_comment|/* Look for err */
r_while
c_loop
(paren
id|sense_table
(braket
id|i
)braket
(braket
l_int|0
)braket
op_ne
l_int|0xFF
)paren
(brace
multiline_comment|/* Look for best matches first */
r_if
c_cond
(paren
(paren
id|sense_table
(braket
id|i
)braket
(braket
l_int|0
)braket
op_amp
id|err
)paren
op_eq
id|sense_table
(braket
id|i
)braket
(braket
l_int|0
)braket
)paren
(brace
id|sb
(braket
l_int|0
)braket
op_assign
l_int|0x70
suffix:semicolon
id|sb
(braket
l_int|2
)braket
op_assign
id|sense_table
(braket
id|i
)braket
(braket
l_int|1
)braket
suffix:semicolon
id|sb
(braket
l_int|7
)braket
op_assign
l_int|0x0a
suffix:semicolon
id|sb
(braket
l_int|12
)braket
op_assign
id|sense_table
(braket
id|i
)braket
(braket
l_int|2
)braket
suffix:semicolon
id|sb
(braket
l_int|13
)braket
op_assign
id|sense_table
(braket
id|i
)braket
(braket
l_int|3
)braket
suffix:semicolon
r_return
suffix:semicolon
)brace
id|i
op_increment
suffix:semicolon
)brace
multiline_comment|/* No immediate match */
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ata%u: no sense translation for 0x%02x&bslash;n&quot;
comma
id|qc-&gt;ap-&gt;id
comma
id|err
)paren
suffix:semicolon
)brace
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Fall back to interpreting status bits */
r_while
c_loop
(paren
id|stat_table
(braket
id|i
)braket
(braket
l_int|0
)braket
op_ne
l_int|0xFF
)paren
(brace
r_if
c_cond
(paren
id|stat_table
(braket
id|i
)braket
(braket
l_int|0
)braket
op_amp
id|drv_stat
)paren
(brace
id|sb
(braket
l_int|0
)braket
op_assign
l_int|0x70
suffix:semicolon
id|sb
(braket
l_int|2
)braket
op_assign
id|stat_table
(braket
id|i
)braket
(braket
l_int|1
)braket
suffix:semicolon
id|sb
(braket
l_int|7
)braket
op_assign
l_int|0x0a
suffix:semicolon
id|sb
(braket
l_int|12
)braket
op_assign
id|stat_table
(braket
id|i
)braket
(braket
l_int|2
)braket
suffix:semicolon
id|sb
(braket
l_int|13
)braket
op_assign
id|stat_table
(braket
id|i
)braket
(braket
l_int|3
)braket
suffix:semicolon
r_return
suffix:semicolon
)brace
id|i
op_increment
suffix:semicolon
)brace
multiline_comment|/* No error ?? */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ata%u: called with no error (%02X)!&bslash;n&quot;
comma
id|qc-&gt;ap-&gt;id
comma
id|drv_stat
)paren
suffix:semicolon
multiline_comment|/* additional-sense-code[-qualifier] */
id|sb
(braket
l_int|0
)braket
op_assign
l_int|0x70
suffix:semicolon
id|sb
(braket
l_int|2
)braket
op_assign
id|MEDIUM_ERROR
suffix:semicolon
id|sb
(braket
l_int|7
)braket
op_assign
l_int|0x0A
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;sc_data_direction
op_eq
id|SCSI_DATA_READ
)paren
(brace
id|sb
(braket
l_int|12
)braket
op_assign
l_int|0x11
suffix:semicolon
multiline_comment|/* &quot;unrecovered read error&quot; */
id|sb
(braket
l_int|13
)braket
op_assign
l_int|0x04
suffix:semicolon
)brace
r_else
(brace
id|sb
(braket
l_int|12
)braket
op_assign
l_int|0x0C
suffix:semicolon
multiline_comment|/* &quot;write error -             */
id|sb
(braket
l_int|13
)braket
op_assign
l_int|0x02
suffix:semicolon
multiline_comment|/*  auto-reallocation failed&quot; */
)brace
)brace
multiline_comment|/**&n; *&t;ata_scsi_slave_config - Set SCSI device attributes&n; *&t;@sdev: SCSI device to examine&n; *&n; *&t;This is called before we actually start reading&n; *&t;and writing to the device, to configure certain&n; *&t;SCSI mid-layer behaviors.&n; *&n; *&t;LOCKING:&n; *&t;Defined by SCSI layer.  We don&squot;t really care.&n; */
DECL|function|ata_scsi_slave_config
r_int
id|ata_scsi_slave_config
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
)paren
(brace
id|sdev-&gt;use_10_for_rw
op_assign
l_int|1
suffix:semicolon
id|sdev-&gt;use_10_for_ms
op_assign
l_int|1
suffix:semicolon
id|blk_queue_max_phys_segments
c_func
(paren
id|sdev-&gt;request_queue
comma
id|LIBATA_MAX_PRD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;id
OL
id|ATA_MAX_DEVICES
)paren
(brace
r_struct
id|ata_port
op_star
id|ap
suffix:semicolon
r_struct
id|ata_device
op_star
id|dev
suffix:semicolon
id|ap
op_assign
(paren
r_struct
id|ata_port
op_star
)paren
op_amp
id|sdev-&gt;host-&gt;hostdata
(braket
l_int|0
)braket
suffix:semicolon
id|dev
op_assign
op_amp
id|ap-&gt;device
(braket
id|sdev-&gt;id
)braket
suffix:semicolon
multiline_comment|/* TODO: 1024 is an arbitrary number, not the&n;&t;&t; * hardware maximum.  This should be increased to&n;&t;&t; * 65534 when Jens Axboe&squot;s patch for dynamically&n;&t;&t; * determining max_sectors is merged.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|ATA_DFLAG_LBA48
)paren
op_logical_and
(paren
(paren
id|dev-&gt;flags
op_amp
id|ATA_DFLAG_LOCK_SECTORS
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|sdev-&gt;host-&gt;max_sectors
op_assign
l_int|2048
suffix:semicolon
id|blk_queue_max_sectors
c_func
(paren
id|sdev-&gt;request_queue
comma
l_int|2048
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* scsi layer doesn&squot;t check return value, sigh */
)brace
multiline_comment|/**&n; *&t;ata_scsi_error - SCSI layer error handler callback&n; *&t;@host: SCSI host on which error occurred&n; *&n; *&t;Handles SCSI-layer-thrown error events.&n; *&n; *&t;LOCKING:&n; *&t;Inherited from SCSI layer (none, can sleep)&n; *&n; *&t;RETURNS:&n; *&t;Zero.&n; */
DECL|function|ata_scsi_error
r_int
id|ata_scsi_error
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_struct
id|ata_port
op_star
id|ap
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;ENTER&bslash;n&quot;
)paren
suffix:semicolon
id|ap
op_assign
(paren
r_struct
id|ata_port
op_star
)paren
op_amp
id|host-&gt;hostdata
(braket
l_int|0
)braket
suffix:semicolon
id|ap-&gt;ops
op_member_access_from_pointer
id|eng_timeout
c_func
(paren
id|ap
)paren
suffix:semicolon
multiline_comment|/* TODO: this is per-command; when queueing is supported&n;&t; * this code will either change or move to a more&n;&t; * appropriate place&n;&t; */
id|host-&gt;host_failed
op_decrement
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;EXIT&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_scsi_flush_xlat - Translate SCSI SYNCHRONIZE CACHE command&n; *&t;@qc: Storage for translated ATA taskfile&n; *&t;@scsicmd: SCSI command to translate (ignored)&n; *&n; *&t;Sets up an ATA taskfile to issue FLUSH CACHE or&n; *&t;FLUSH CACHE EXT.&n; *&n; *&t;LOCKING:&n; *&t;spin_lock_irqsave(host_set lock)&n; *&n; *&t;RETURNS:&n; *&t;Zero on success, non-zero on error.&n; */
DECL|function|ata_scsi_flush_xlat
r_static
r_int
r_int
id|ata_scsi_flush_xlat
c_func
(paren
r_struct
id|ata_queued_cmd
op_star
id|qc
comma
id|u8
op_star
id|scsicmd
)paren
(brace
r_struct
id|ata_taskfile
op_star
id|tf
op_assign
op_amp
id|qc-&gt;tf
suffix:semicolon
id|tf-&gt;flags
op_or_assign
id|ATA_TFLAG_DEVICE
suffix:semicolon
id|tf-&gt;protocol
op_assign
id|ATA_PROT_NODATA
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tf-&gt;flags
op_amp
id|ATA_TFLAG_LBA48
)paren
op_logical_and
(paren
id|ata_id_has_flush_ext
c_func
(paren
id|qc-&gt;dev-&gt;id
)paren
)paren
)paren
id|tf-&gt;command
op_assign
id|ATA_CMD_FLUSH_EXT
suffix:semicolon
r_else
id|tf-&gt;command
op_assign
id|ATA_CMD_FLUSH
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_scsi_verify_xlat - Translate SCSI VERIFY command into an ATA one&n; *&t;@qc: Storage for translated ATA taskfile&n; *&t;@scsicmd: SCSI command to translate&n; *&n; *&t;Converts SCSI VERIFY command to an ATA READ VERIFY command.&n; *&n; *&t;LOCKING:&n; *&t;spin_lock_irqsave(host_set lock)&n; *&n; *&t;RETURNS:&n; *&t;Zero on success, non-zero on error.&n; */
DECL|function|ata_scsi_verify_xlat
r_static
r_int
r_int
id|ata_scsi_verify_xlat
c_func
(paren
r_struct
id|ata_queued_cmd
op_star
id|qc
comma
id|u8
op_star
id|scsicmd
)paren
(brace
r_struct
id|ata_taskfile
op_star
id|tf
op_assign
op_amp
id|qc-&gt;tf
suffix:semicolon
r_int
r_int
id|lba48
op_assign
id|tf-&gt;flags
op_amp
id|ATA_TFLAG_LBA48
suffix:semicolon
id|u64
id|dev_sectors
op_assign
id|qc-&gt;dev-&gt;n_sectors
suffix:semicolon
id|u64
id|sect
op_assign
l_int|0
suffix:semicolon
id|u32
id|n_sect
op_assign
l_int|0
suffix:semicolon
id|tf-&gt;flags
op_or_assign
id|ATA_TFLAG_ISADDR
op_or
id|ATA_TFLAG_DEVICE
suffix:semicolon
id|tf-&gt;protocol
op_assign
id|ATA_PROT_NODATA
suffix:semicolon
id|tf-&gt;device
op_or_assign
id|ATA_LBA
suffix:semicolon
r_if
c_cond
(paren
id|scsicmd
(braket
l_int|0
)braket
op_eq
id|VERIFY
)paren
(brace
id|sect
op_or_assign
(paren
(paren
id|u64
)paren
id|scsicmd
(braket
l_int|2
)braket
)paren
op_lshift
l_int|24
suffix:semicolon
id|sect
op_or_assign
(paren
(paren
id|u64
)paren
id|scsicmd
(braket
l_int|3
)braket
)paren
op_lshift
l_int|16
suffix:semicolon
id|sect
op_or_assign
(paren
(paren
id|u64
)paren
id|scsicmd
(braket
l_int|4
)braket
)paren
op_lshift
l_int|8
suffix:semicolon
id|sect
op_or_assign
(paren
(paren
id|u64
)paren
id|scsicmd
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|n_sect
op_or_assign
(paren
(paren
id|u32
)paren
id|scsicmd
(braket
l_int|7
)braket
)paren
op_lshift
l_int|8
suffix:semicolon
id|n_sect
op_or_assign
(paren
(paren
id|u32
)paren
id|scsicmd
(braket
l_int|8
)braket
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scsicmd
(braket
l_int|0
)braket
op_eq
id|VERIFY_16
)paren
(brace
id|sect
op_or_assign
(paren
(paren
id|u64
)paren
id|scsicmd
(braket
l_int|2
)braket
)paren
op_lshift
l_int|56
suffix:semicolon
id|sect
op_or_assign
(paren
(paren
id|u64
)paren
id|scsicmd
(braket
l_int|3
)braket
)paren
op_lshift
l_int|48
suffix:semicolon
id|sect
op_or_assign
(paren
(paren
id|u64
)paren
id|scsicmd
(braket
l_int|4
)braket
)paren
op_lshift
l_int|40
suffix:semicolon
id|sect
op_or_assign
(paren
(paren
id|u64
)paren
id|scsicmd
(braket
l_int|5
)braket
)paren
op_lshift
l_int|32
suffix:semicolon
id|sect
op_or_assign
(paren
(paren
id|u64
)paren
id|scsicmd
(braket
l_int|6
)braket
)paren
op_lshift
l_int|24
suffix:semicolon
id|sect
op_or_assign
(paren
(paren
id|u64
)paren
id|scsicmd
(braket
l_int|7
)braket
)paren
op_lshift
l_int|16
suffix:semicolon
id|sect
op_or_assign
(paren
(paren
id|u64
)paren
id|scsicmd
(braket
l_int|8
)braket
)paren
op_lshift
l_int|8
suffix:semicolon
id|sect
op_or_assign
(paren
(paren
id|u64
)paren
id|scsicmd
(braket
l_int|9
)braket
)paren
suffix:semicolon
id|n_sect
op_or_assign
(paren
(paren
id|u32
)paren
id|scsicmd
(braket
l_int|10
)braket
)paren
op_lshift
l_int|24
suffix:semicolon
id|n_sect
op_or_assign
(paren
(paren
id|u32
)paren
id|scsicmd
(braket
l_int|11
)braket
)paren
op_lshift
l_int|16
suffix:semicolon
id|n_sect
op_or_assign
(paren
(paren
id|u32
)paren
id|scsicmd
(braket
l_int|12
)braket
)paren
op_lshift
l_int|8
suffix:semicolon
id|n_sect
op_or_assign
(paren
(paren
id|u32
)paren
id|scsicmd
(braket
l_int|13
)braket
)paren
suffix:semicolon
)brace
r_else
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n_sect
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sect
op_ge
id|dev_sectors
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sect
op_plus
id|n_sect
)paren
OG
id|dev_sectors
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|lba48
)paren
(brace
r_if
c_cond
(paren
id|n_sect
OG
(paren
l_int|64
op_star
l_int|1024
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|n_sect
OG
l_int|256
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lba48
)paren
(brace
id|tf-&gt;command
op_assign
id|ATA_CMD_VERIFY_EXT
suffix:semicolon
id|tf-&gt;hob_nsect
op_assign
(paren
id|n_sect
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|tf-&gt;hob_lbah
op_assign
(paren
id|sect
op_rshift
l_int|40
)paren
op_amp
l_int|0xff
suffix:semicolon
id|tf-&gt;hob_lbam
op_assign
(paren
id|sect
op_rshift
l_int|32
)paren
op_amp
l_int|0xff
suffix:semicolon
id|tf-&gt;hob_lbal
op_assign
(paren
id|sect
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
suffix:semicolon
)brace
r_else
(brace
id|tf-&gt;command
op_assign
id|ATA_CMD_VERIFY
suffix:semicolon
id|tf-&gt;device
op_or_assign
(paren
id|sect
op_rshift
l_int|24
)paren
op_amp
l_int|0xf
suffix:semicolon
)brace
id|tf-&gt;nsect
op_assign
id|n_sect
op_amp
l_int|0xff
suffix:semicolon
id|tf-&gt;lbah
op_assign
(paren
id|sect
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
id|tf-&gt;lbam
op_assign
(paren
id|sect
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|tf-&gt;lbal
op_assign
id|sect
op_amp
l_int|0xff
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_scsi_rw_xlat - Translate SCSI r/w command into an ATA one&n; *&t;@qc: Storage for translated ATA taskfile&n; *&t;@scsicmd: SCSI command to translate&n; *&n; *&t;Converts any of six SCSI read/write commands into the&n; *&t;ATA counterpart, including starting sector (LBA),&n; *&t;sector count, and taking into account the device&squot;s LBA48&n; *&t;support.&n; *&n; *&t;Commands %READ_6, %READ_10, %READ_16, %WRITE_6, %WRITE_10, and&n; *&t;%WRITE_16 are currently supported.&n; *&n; *&t;LOCKING:&n; *&t;spin_lock_irqsave(host_set lock)&n; *&n; *&t;RETURNS:&n; *&t;Zero on success, non-zero on error.&n; */
DECL|function|ata_scsi_rw_xlat
r_static
r_int
r_int
id|ata_scsi_rw_xlat
c_func
(paren
r_struct
id|ata_queued_cmd
op_star
id|qc
comma
id|u8
op_star
id|scsicmd
)paren
(brace
r_struct
id|ata_taskfile
op_star
id|tf
op_assign
op_amp
id|qc-&gt;tf
suffix:semicolon
r_int
r_int
id|lba48
op_assign
id|tf-&gt;flags
op_amp
id|ATA_TFLAG_LBA48
suffix:semicolon
id|tf-&gt;flags
op_or_assign
id|ATA_TFLAG_ISADDR
op_or
id|ATA_TFLAG_DEVICE
suffix:semicolon
id|tf-&gt;protocol
op_assign
id|qc-&gt;dev-&gt;xfer_protocol
suffix:semicolon
id|tf-&gt;device
op_or_assign
id|ATA_LBA
suffix:semicolon
r_if
c_cond
(paren
id|scsicmd
(braket
l_int|0
)braket
op_eq
id|READ_10
op_logical_or
id|scsicmd
(braket
l_int|0
)braket
op_eq
id|READ_6
op_logical_or
id|scsicmd
(braket
l_int|0
)braket
op_eq
id|READ_16
)paren
(brace
id|tf-&gt;command
op_assign
id|qc-&gt;dev-&gt;read_cmd
suffix:semicolon
)brace
r_else
(brace
id|tf-&gt;command
op_assign
id|qc-&gt;dev-&gt;write_cmd
suffix:semicolon
id|tf-&gt;flags
op_or_assign
id|ATA_TFLAG_WRITE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scsicmd
(braket
l_int|0
)braket
op_eq
id|READ_10
op_logical_or
id|scsicmd
(braket
l_int|0
)braket
op_eq
id|WRITE_10
)paren
(brace
r_if
c_cond
(paren
id|lba48
)paren
(brace
id|tf-&gt;hob_nsect
op_assign
id|scsicmd
(braket
l_int|7
)braket
suffix:semicolon
id|tf-&gt;hob_lbal
op_assign
id|scsicmd
(braket
l_int|2
)braket
suffix:semicolon
id|qc-&gt;nsect
op_assign
(paren
(paren
r_int
r_int
)paren
id|scsicmd
(braket
l_int|7
)braket
op_lshift
l_int|8
)paren
op_or
id|scsicmd
(braket
l_int|8
)braket
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* if we don&squot;t support LBA48 addressing, the request&n;&t;&t;&t; * -may- be too large. */
r_if
c_cond
(paren
(paren
id|scsicmd
(braket
l_int|2
)braket
op_amp
l_int|0xf0
)paren
op_logical_or
id|scsicmd
(braket
l_int|7
)braket
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* stores LBA27:24 in lower 4 bits of device reg */
id|tf-&gt;device
op_or_assign
id|scsicmd
(braket
l_int|2
)braket
suffix:semicolon
id|qc-&gt;nsect
op_assign
id|scsicmd
(braket
l_int|8
)braket
suffix:semicolon
)brace
id|tf-&gt;nsect
op_assign
id|scsicmd
(braket
l_int|8
)braket
suffix:semicolon
id|tf-&gt;lbal
op_assign
id|scsicmd
(braket
l_int|5
)braket
suffix:semicolon
id|tf-&gt;lbam
op_assign
id|scsicmd
(braket
l_int|4
)braket
suffix:semicolon
id|tf-&gt;lbah
op_assign
id|scsicmd
(braket
l_int|3
)braket
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;ten-byte command&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scsicmd
(braket
l_int|0
)braket
op_eq
id|READ_6
op_logical_or
id|scsicmd
(braket
l_int|0
)braket
op_eq
id|WRITE_6
)paren
(brace
id|qc-&gt;nsect
op_assign
id|tf-&gt;nsect
op_assign
id|scsicmd
(braket
l_int|4
)braket
suffix:semicolon
id|tf-&gt;lbal
op_assign
id|scsicmd
(braket
l_int|3
)braket
suffix:semicolon
id|tf-&gt;lbam
op_assign
id|scsicmd
(braket
l_int|2
)braket
suffix:semicolon
id|tf-&gt;lbah
op_assign
id|scsicmd
(braket
l_int|1
)braket
op_amp
l_int|0x1f
suffix:semicolon
multiline_comment|/* mask out reserved bits */
id|VPRINTK
c_func
(paren
l_string|&quot;six-byte command&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scsicmd
(braket
l_int|0
)braket
op_eq
id|READ_16
op_logical_or
id|scsicmd
(braket
l_int|0
)braket
op_eq
id|WRITE_16
)paren
(brace
multiline_comment|/* rule out impossible LBAs and sector counts */
r_if
c_cond
(paren
id|scsicmd
(braket
l_int|2
)braket
op_logical_or
id|scsicmd
(braket
l_int|3
)braket
op_logical_or
id|scsicmd
(braket
l_int|10
)braket
op_logical_or
id|scsicmd
(braket
l_int|11
)braket
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|lba48
)paren
(brace
id|tf-&gt;hob_nsect
op_assign
id|scsicmd
(braket
l_int|12
)braket
suffix:semicolon
id|tf-&gt;hob_lbal
op_assign
id|scsicmd
(braket
l_int|6
)braket
suffix:semicolon
id|tf-&gt;hob_lbam
op_assign
id|scsicmd
(braket
l_int|5
)braket
suffix:semicolon
id|tf-&gt;hob_lbah
op_assign
id|scsicmd
(braket
l_int|4
)braket
suffix:semicolon
id|qc-&gt;nsect
op_assign
(paren
(paren
r_int
r_int
)paren
id|scsicmd
(braket
l_int|12
)braket
op_lshift
l_int|8
)paren
op_or
id|scsicmd
(braket
l_int|13
)braket
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* once again, filter out impossible non-zero values */
r_if
c_cond
(paren
id|scsicmd
(braket
l_int|4
)braket
op_logical_or
id|scsicmd
(braket
l_int|5
)braket
op_logical_or
id|scsicmd
(braket
l_int|12
)braket
op_logical_or
(paren
id|scsicmd
(braket
l_int|6
)braket
op_amp
l_int|0xf0
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* stores LBA27:24 in lower 4 bits of device reg */
id|tf-&gt;device
op_or_assign
id|scsicmd
(braket
l_int|6
)braket
suffix:semicolon
id|qc-&gt;nsect
op_assign
id|scsicmd
(braket
l_int|13
)braket
suffix:semicolon
)brace
id|tf-&gt;nsect
op_assign
id|scsicmd
(braket
l_int|13
)braket
suffix:semicolon
id|tf-&gt;lbal
op_assign
id|scsicmd
(braket
l_int|9
)braket
suffix:semicolon
id|tf-&gt;lbam
op_assign
id|scsicmd
(braket
l_int|8
)braket
suffix:semicolon
id|tf-&gt;lbah
op_assign
id|scsicmd
(braket
l_int|7
)braket
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;sixteen-byte command&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|DPRINTK
c_func
(paren
l_string|&quot;no-byte command&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|ata_scsi_qc_complete
r_static
r_int
id|ata_scsi_qc_complete
c_func
(paren
r_struct
id|ata_queued_cmd
op_star
id|qc
comma
id|u8
id|drv_stat
)paren
(brace
r_struct
id|scsi_cmnd
op_star
id|cmd
op_assign
id|qc-&gt;scsicmd
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|drv_stat
op_amp
(paren
id|ATA_ERR
op_or
id|ATA_BUSY
op_or
id|ATA_DRQ
)paren
)paren
)paren
id|ata_to_sense_error
c_func
(paren
id|qc
comma
id|drv_stat
)paren
suffix:semicolon
r_else
id|cmd-&gt;result
op_assign
id|SAM_STAT_GOOD
suffix:semicolon
id|qc
op_member_access_from_pointer
id|scsidone
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_scsi_translate - Translate then issue SCSI command to ATA device&n; *&t;@ap: ATA port to which the command is addressed&n; *&t;@dev: ATA device to which the command is addressed&n; *&t;@cmd: SCSI command to execute&n; *&t;@done: SCSI command completion function&n; *&t;@xlat_func: Actor which translates @cmd to an ATA taskfile&n; *&n; *&t;Our -&gt;queuecommand() function has decided that the SCSI&n; *&t;command issued can be directly translated into an ATA&n; *&t;command, rather than handled internally.&n; *&n; *&t;This function sets up an ata_queued_cmd structure for the&n; *&t;SCSI command, and sends that ata_queued_cmd to the hardware.&n; *&n; *&t;LOCKING:&n; *&t;spin_lock_irqsave(host_set lock)&n; */
DECL|function|ata_scsi_translate
r_static
r_void
id|ata_scsi_translate
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_struct
id|ata_device
op_star
id|dev
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
r_struct
id|scsi_cmnd
op_star
)paren
comma
id|ata_xlat_func_t
id|xlat_func
)paren
(brace
r_struct
id|ata_queued_cmd
op_star
id|qc
suffix:semicolon
id|u8
op_star
id|scsicmd
op_assign
id|cmd-&gt;cmnd
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;ENTER&bslash;n&quot;
)paren
suffix:semicolon
id|qc
op_assign
id|ata_scsi_qc_new
c_func
(paren
id|ap
comma
id|dev
comma
id|cmd
comma
id|done
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|qc
)paren
r_return
suffix:semicolon
multiline_comment|/* data is present; dma-map it */
r_if
c_cond
(paren
id|cmd-&gt;sc_data_direction
op_eq
id|SCSI_DATA_READ
op_logical_or
id|cmd-&gt;sc_data_direction
op_eq
id|SCSI_DATA_WRITE
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|cmd-&gt;request_bufflen
OL
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ata%u(%u): WARNING: zero len r/w req&bslash;n&quot;
comma
id|ap-&gt;id
comma
id|dev-&gt;devno
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd-&gt;use_sg
)paren
id|ata_sg_init
c_func
(paren
id|qc
comma
id|cmd-&gt;request_buffer
comma
id|cmd-&gt;use_sg
)paren
suffix:semicolon
r_else
id|ata_sg_init_one
c_func
(paren
id|qc
comma
id|cmd-&gt;request_buffer
comma
id|cmd-&gt;request_bufflen
)paren
suffix:semicolon
id|qc-&gt;dma_dir
op_assign
id|cmd-&gt;sc_data_direction
suffix:semicolon
)brace
id|qc-&gt;complete_fn
op_assign
id|ata_scsi_qc_complete
suffix:semicolon
r_if
c_cond
(paren
id|xlat_func
c_func
(paren
id|qc
comma
id|scsicmd
)paren
)paren
r_goto
id|err_out
suffix:semicolon
multiline_comment|/* select device, send command to hardware */
r_if
c_cond
(paren
id|ata_qc_issue
c_func
(paren
id|qc
)paren
)paren
r_goto
id|err_out
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;EXIT&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
id|err_out
suffix:colon
id|ata_bad_cdb
c_func
(paren
id|cmd
comma
id|done
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;EXIT - badcmd&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_scsi_rbuf_get - Map response buffer.&n; *&t;@cmd: SCSI command containing buffer to be mapped.&n; *&t;@buf_out: Pointer to mapped area.&n; *&n; *&t;Maps buffer contained within SCSI command @cmd.&n; *&n; *&t;LOCKING:&n; *&t;spin_lock_irqsave(host_set lock)&n; *&n; *&t;RETURNS:&n; *&t;Length of response buffer.&n; */
DECL|function|ata_scsi_rbuf_get
r_static
r_int
r_int
id|ata_scsi_rbuf_get
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
id|u8
op_star
op_star
id|buf_out
)paren
(brace
id|u8
op_star
id|buf
suffix:semicolon
r_int
r_int
id|buflen
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;use_sg
)paren
(brace
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;request_buffer
suffix:semicolon
id|buf
op_assign
id|kmap_atomic
c_func
(paren
id|sg-&gt;page
comma
id|KM_USER0
)paren
op_plus
id|sg-&gt;offset
suffix:semicolon
id|buflen
op_assign
id|sg-&gt;length
suffix:semicolon
)brace
r_else
(brace
id|buf
op_assign
id|cmd-&gt;request_buffer
suffix:semicolon
id|buflen
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
)brace
op_star
id|buf_out
op_assign
id|buf
suffix:semicolon
r_return
id|buflen
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_scsi_rbuf_put - Unmap response buffer.&n; *&t;@cmd: SCSI command containing buffer to be unmapped.&n; *&t;@buf: buffer to unmap&n; *&n; *&t;Unmaps response buffer contained within @cmd.&n; *&n; *&t;LOCKING:&n; *&t;spin_lock_irqsave(host_set lock)&n; */
DECL|function|ata_scsi_rbuf_put
r_static
r_inline
r_void
id|ata_scsi_rbuf_put
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
id|u8
op_star
id|buf
)paren
(brace
r_if
c_cond
(paren
id|cmd-&gt;use_sg
)paren
(brace
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;request_buffer
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|buf
op_minus
id|sg-&gt;offset
comma
id|KM_USER0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;ata_scsi_rbuf_fill - wrapper for SCSI command simulators&n; *&t;@args: device IDENTIFY data / SCSI command of interest.&n; *&t;@actor: Callback hook for desired SCSI command simulator&n; *&n; *&t;Takes care of the hard work of simulating a SCSI command...&n; *&t;Mapping the response buffer, calling the command&squot;s handler,&n; *&t;and handling the handler&squot;s return value.  This return value&n; *&t;indicates whether the handler wishes the SCSI command to be&n; *&t;completed successfully, or not.&n; *&n; *&t;LOCKING:&n; *&t;spin_lock_irqsave(host_set lock)&n; */
DECL|function|ata_scsi_rbuf_fill
r_void
id|ata_scsi_rbuf_fill
c_func
(paren
r_struct
id|ata_scsi_args
op_star
id|args
comma
r_int
r_int
(paren
op_star
id|actor
)paren
(paren
r_struct
id|ata_scsi_args
op_star
id|args
comma
id|u8
op_star
id|rbuf
comma
r_int
r_int
id|buflen
)paren
)paren
(brace
id|u8
op_star
id|rbuf
suffix:semicolon
r_int
r_int
id|buflen
comma
id|rc
suffix:semicolon
r_struct
id|scsi_cmnd
op_star
id|cmd
op_assign
id|args-&gt;cmd
suffix:semicolon
id|buflen
op_assign
id|ata_scsi_rbuf_get
c_func
(paren
id|cmd
comma
op_amp
id|rbuf
)paren
suffix:semicolon
id|memset
c_func
(paren
id|rbuf
comma
l_int|0
comma
id|buflen
)paren
suffix:semicolon
id|rc
op_assign
id|actor
c_func
(paren
id|args
comma
id|rbuf
comma
id|buflen
)paren
suffix:semicolon
id|ata_scsi_rbuf_put
c_func
(paren
id|cmd
comma
id|rbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
id|ata_bad_cdb
c_func
(paren
id|cmd
comma
id|args-&gt;done
)paren
suffix:semicolon
r_else
(brace
id|cmd-&gt;result
op_assign
id|SAM_STAT_GOOD
suffix:semicolon
id|args
op_member_access_from_pointer
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;ata_scsiop_inq_std - Simulate INQUIRY command&n; *&t;@args: device IDENTIFY data / SCSI command of interest.&n; *&t;@rbuf: Response buffer, to which simulated SCSI cmd output is sent.&n; *&t;@buflen: Response buffer length.&n; *&n; *&t;Returns standard device identification data associated&n; *&t;with non-EVPD INQUIRY command output.&n; *&n; *&t;LOCKING:&n; *&t;spin_lock_irqsave(host_set lock)&n; */
DECL|function|ata_scsiop_inq_std
r_int
r_int
id|ata_scsiop_inq_std
c_func
(paren
r_struct
id|ata_scsi_args
op_star
id|args
comma
id|u8
op_star
id|rbuf
comma
r_int
r_int
id|buflen
)paren
(brace
id|u8
id|hdr
(braket
)braket
op_assign
(brace
id|TYPE_DISK
comma
l_int|0
comma
l_int|0x5
comma
multiline_comment|/* claim SPC-3 version compatibility */
l_int|2
comma
l_int|95
op_minus
l_int|4
)brace
suffix:semicolon
multiline_comment|/* set scsi removeable (RMB) bit per ata bit */
r_if
c_cond
(paren
id|ata_id_removeable
c_func
(paren
id|args-&gt;id
)paren
)paren
id|hdr
(braket
l_int|1
)braket
op_or_assign
(paren
l_int|1
op_lshift
l_int|7
)paren
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;ENTER&bslash;n&quot;
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|rbuf
comma
id|hdr
comma
r_sizeof
(paren
id|hdr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buflen
OG
l_int|35
)paren
(brace
id|memcpy
c_func
(paren
op_amp
id|rbuf
(braket
l_int|8
)braket
comma
l_string|&quot;ATA     &quot;
comma
l_int|8
)paren
suffix:semicolon
id|ata_dev_id_string
c_func
(paren
id|args-&gt;id
comma
op_amp
id|rbuf
(braket
l_int|16
)braket
comma
id|ATA_ID_PROD_OFS
comma
l_int|16
)paren
suffix:semicolon
id|ata_dev_id_string
c_func
(paren
id|args-&gt;id
comma
op_amp
id|rbuf
(braket
l_int|32
)braket
comma
id|ATA_ID_FW_REV_OFS
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rbuf
(braket
l_int|32
)braket
op_eq
l_int|0
op_logical_or
id|rbuf
(braket
l_int|32
)braket
op_eq
l_char|&squot; &squot;
)paren
id|memcpy
c_func
(paren
op_amp
id|rbuf
(braket
l_int|32
)braket
comma
l_string|&quot;n/a &quot;
comma
l_int|4
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buflen
OG
l_int|63
)paren
(brace
r_const
id|u8
id|versions
(braket
)braket
op_assign
(brace
l_int|0x60
comma
multiline_comment|/* SAM-3 (no version claimed) */
l_int|0x03
comma
l_int|0x20
comma
multiline_comment|/* SBC-2 (no version claimed) */
l_int|0x02
comma
l_int|0x60
multiline_comment|/* SPC-3 (no version claimed) */
)brace
suffix:semicolon
id|memcpy
c_func
(paren
id|rbuf
op_plus
l_int|59
comma
id|versions
comma
r_sizeof
(paren
id|versions
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_scsiop_inq_00 - Simulate INQUIRY EVPD page 0, list of pages&n; *&t;@args: device IDENTIFY data / SCSI command of interest.&n; *&t;@rbuf: Response buffer, to which simulated SCSI cmd output is sent.&n; *&t;@buflen: Response buffer length.&n; *&n; *&t;Returns list of inquiry EVPD pages available.&n; *&n; *&t;LOCKING:&n; *&t;spin_lock_irqsave(host_set lock)&n; */
DECL|function|ata_scsiop_inq_00
r_int
r_int
id|ata_scsiop_inq_00
c_func
(paren
r_struct
id|ata_scsi_args
op_star
id|args
comma
id|u8
op_star
id|rbuf
comma
r_int
r_int
id|buflen
)paren
(brace
r_const
id|u8
id|pages
(braket
)braket
op_assign
(brace
l_int|0x00
comma
multiline_comment|/* page 0x00, this page */
l_int|0x80
comma
multiline_comment|/* page 0x80, unit serial no page */
l_int|0x83
multiline_comment|/* page 0x83, device ident page */
)brace
suffix:semicolon
id|rbuf
(braket
l_int|3
)braket
op_assign
r_sizeof
(paren
id|pages
)paren
suffix:semicolon
multiline_comment|/* number of supported EVPD pages */
r_if
c_cond
(paren
id|buflen
OG
l_int|6
)paren
id|memcpy
c_func
(paren
id|rbuf
op_plus
l_int|4
comma
id|pages
comma
r_sizeof
(paren
id|pages
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_scsiop_inq_80 - Simulate INQUIRY EVPD page 80, device serial number&n; *&t;@args: device IDENTIFY data / SCSI command of interest.&n; *&t;@rbuf: Response buffer, to which simulated SCSI cmd output is sent.&n; *&t;@buflen: Response buffer length.&n; *&n; *&t;Returns ATA device serial number.&n; *&n; *&t;LOCKING:&n; *&t;spin_lock_irqsave(host_set lock)&n; */
DECL|function|ata_scsiop_inq_80
r_int
r_int
id|ata_scsiop_inq_80
c_func
(paren
r_struct
id|ata_scsi_args
op_star
id|args
comma
id|u8
op_star
id|rbuf
comma
r_int
r_int
id|buflen
)paren
(brace
r_const
id|u8
id|hdr
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|0x80
comma
multiline_comment|/* this page code */
l_int|0
comma
id|ATA_SERNO_LEN
comma
multiline_comment|/* page len */
)brace
suffix:semicolon
id|memcpy
c_func
(paren
id|rbuf
comma
id|hdr
comma
r_sizeof
(paren
id|hdr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buflen
OG
(paren
id|ATA_SERNO_LEN
op_plus
l_int|4
op_minus
l_int|1
)paren
)paren
id|ata_dev_id_string
c_func
(paren
id|args-&gt;id
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|rbuf
(braket
l_int|4
)braket
comma
id|ATA_ID_SERNO_OFS
comma
id|ATA_SERNO_LEN
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|inq_83_str
r_static
r_const
r_char
op_star
id|inq_83_str
op_assign
l_string|&quot;Linux ATA-SCSI simulator&quot;
suffix:semicolon
multiline_comment|/**&n; *&t;ata_scsiop_inq_83 - Simulate INQUIRY EVPD page 83, device identity&n; *&t;@args: device IDENTIFY data / SCSI command of interest.&n; *&t;@rbuf: Response buffer, to which simulated SCSI cmd output is sent.&n; *&t;@buflen: Response buffer length.&n; *&n; *&t;Returns device identification.  Currently hardcoded to&n; *&t;return &quot;Linux ATA-SCSI simulator&quot;.&n; *&n; *&t;LOCKING:&n; *&t;spin_lock_irqsave(host_set lock)&n; */
DECL|function|ata_scsiop_inq_83
r_int
r_int
id|ata_scsiop_inq_83
c_func
(paren
r_struct
id|ata_scsi_args
op_star
id|args
comma
id|u8
op_star
id|rbuf
comma
r_int
r_int
id|buflen
)paren
(brace
id|rbuf
(braket
l_int|1
)braket
op_assign
l_int|0x83
suffix:semicolon
multiline_comment|/* this page code */
id|rbuf
(braket
l_int|3
)braket
op_assign
l_int|4
op_plus
id|strlen
c_func
(paren
id|inq_83_str
)paren
suffix:semicolon
multiline_comment|/* page len */
multiline_comment|/* our one and only identification descriptor (vendor-specific) */
r_if
c_cond
(paren
id|buflen
OG
(paren
id|strlen
c_func
(paren
id|inq_83_str
)paren
op_plus
l_int|4
op_plus
l_int|4
op_minus
l_int|1
)paren
)paren
(brace
id|rbuf
(braket
l_int|4
op_plus
l_int|0
)braket
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* code set: ASCII */
id|rbuf
(braket
l_int|4
op_plus
l_int|3
)braket
op_assign
id|strlen
c_func
(paren
id|inq_83_str
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|rbuf
op_plus
l_int|4
op_plus
l_int|4
comma
id|inq_83_str
comma
id|strlen
c_func
(paren
id|inq_83_str
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_scsiop_noop -&n; *&t;@args: device IDENTIFY data / SCSI command of interest.&n; *&t;@rbuf: Response buffer, to which simulated SCSI cmd output is sent.&n; *&t;@buflen: Response buffer length.&n; *&n; *&t;No operation.  Simply returns success to caller, to indicate&n; *&t;that the caller should successfully complete this SCSI command.&n; *&n; *&t;LOCKING:&n; *&t;spin_lock_irqsave(host_set lock)&n; */
DECL|function|ata_scsiop_noop
r_int
r_int
id|ata_scsiop_noop
c_func
(paren
r_struct
id|ata_scsi_args
op_star
id|args
comma
id|u8
op_star
id|rbuf
comma
r_int
r_int
id|buflen
)paren
(brace
id|VPRINTK
c_func
(paren
l_string|&quot;ENTER&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_msense_push - Push data onto MODE SENSE data output buffer&n; *&t;@ptr_io: (input/output) Location to store more output data&n; *&t;@last: End of output data buffer&n; *&t;@buf: Pointer to BLOB being added to output buffer&n; *&t;@buflen: Length of BLOB&n; *&n; *&t;Store MODE SENSE data on an output buffer.&n; *&n; *&t;LOCKING:&n; *&t;None.&n; */
DECL|function|ata_msense_push
r_static
r_void
id|ata_msense_push
c_func
(paren
id|u8
op_star
op_star
id|ptr_io
comma
r_const
id|u8
op_star
id|last
comma
r_const
id|u8
op_star
id|buf
comma
r_int
r_int
id|buflen
)paren
(brace
id|u8
op_star
id|ptr
op_assign
op_star
id|ptr_io
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ptr
op_plus
id|buflen
op_minus
l_int|1
)paren
OG
id|last
)paren
r_return
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
comma
id|buf
comma
id|buflen
)paren
suffix:semicolon
id|ptr
op_add_assign
id|buflen
suffix:semicolon
op_star
id|ptr_io
op_assign
id|ptr
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_msense_caching - Simulate MODE SENSE caching info page&n; *&t;@id: device IDENTIFY data&n; *&t;@ptr_io: (input/output) Location to store more output data&n; *&t;@last: End of output data buffer&n; *&n; *&t;Generate a caching info page, which conditionally indicates&n; *&t;write caching to the SCSI layer, depending on device&n; *&t;capabilities.&n; *&n; *&t;LOCKING:&n; *&t;None.&n; */
DECL|function|ata_msense_caching
r_static
r_int
r_int
id|ata_msense_caching
c_func
(paren
id|u16
op_star
id|id
comma
id|u8
op_star
op_star
id|ptr_io
comma
r_const
id|u8
op_star
id|last
)paren
(brace
id|u8
id|page
(braket
)braket
op_assign
(brace
l_int|0x8
comma
multiline_comment|/* page code */
l_int|0x12
comma
multiline_comment|/* page length */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 10 zeroes */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
multiline_comment|/* 8 zeroes */
)brace
suffix:semicolon
r_if
c_cond
(paren
id|ata_id_wcache_enabled
c_func
(paren
id|id
)paren
)paren
id|page
(braket
l_int|2
)braket
op_or_assign
(paren
l_int|1
op_lshift
l_int|2
)paren
suffix:semicolon
multiline_comment|/* write cache enable */
r_if
c_cond
(paren
op_logical_neg
id|ata_id_rahead_enabled
c_func
(paren
id|id
)paren
)paren
id|page
(braket
l_int|12
)braket
op_or_assign
(paren
l_int|1
op_lshift
l_int|5
)paren
suffix:semicolon
multiline_comment|/* disable read ahead */
id|ata_msense_push
c_func
(paren
id|ptr_io
comma
id|last
comma
id|page
comma
r_sizeof
(paren
id|page
)paren
)paren
suffix:semicolon
r_return
r_sizeof
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_msense_ctl_mode - Simulate MODE SENSE control mode page&n; *&t;@dev: Device associated with this MODE SENSE command&n; *&t;@ptr_io: (input/output) Location to store more output data&n; *&t;@last: End of output data buffer&n; *&n; *&t;Generate a generic MODE SENSE control mode page.&n; *&n; *&t;LOCKING:&n; *&t;None.&n; */
DECL|function|ata_msense_ctl_mode
r_static
r_int
r_int
id|ata_msense_ctl_mode
c_func
(paren
id|u8
op_star
op_star
id|ptr_io
comma
r_const
id|u8
op_star
id|last
)paren
(brace
r_const
id|u8
id|page
(braket
)braket
op_assign
(brace
l_int|0xa
comma
l_int|0xa
comma
l_int|2
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0
comma
l_int|30
)brace
suffix:semicolon
id|ata_msense_push
c_func
(paren
id|ptr_io
comma
id|last
comma
id|page
comma
r_sizeof
(paren
id|page
)paren
)paren
suffix:semicolon
r_return
r_sizeof
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_msense_rw_recovery - Simulate MODE SENSE r/w error recovery page&n; *&t;@dev: Device associated with this MODE SENSE command&n; *&t;@ptr_io: (input/output) Location to store more output data&n; *&t;@last: End of output data buffer&n; *&n; *&t;Generate a generic MODE SENSE r/w error recovery page.&n; *&n; *&t;LOCKING:&n; *&t;None.&n; */
DECL|function|ata_msense_rw_recovery
r_static
r_int
r_int
id|ata_msense_rw_recovery
c_func
(paren
id|u8
op_star
op_star
id|ptr_io
comma
r_const
id|u8
op_star
id|last
)paren
(brace
r_const
id|u8
id|page
(braket
)braket
op_assign
(brace
l_int|0x1
comma
multiline_comment|/* page code */
l_int|0xa
comma
multiline_comment|/* page length */
(paren
l_int|1
op_lshift
l_int|7
)paren
op_or
(paren
l_int|1
op_lshift
l_int|6
)paren
comma
multiline_comment|/* note auto r/w reallocation */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
multiline_comment|/* 9 zeroes */
)brace
suffix:semicolon
id|ata_msense_push
c_func
(paren
id|ptr_io
comma
id|last
comma
id|page
comma
r_sizeof
(paren
id|page
)paren
)paren
suffix:semicolon
r_return
r_sizeof
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_scsiop_mode_sense - Simulate MODE SENSE 6, 10 commands&n; *&t;@args: device IDENTIFY data / SCSI command of interest.&n; *&t;@rbuf: Response buffer, to which simulated SCSI cmd output is sent.&n; *&t;@buflen: Response buffer length.&n; *&n; *&t;Simulate MODE SENSE commands.&n; *&n; *&t;LOCKING:&n; *&t;spin_lock_irqsave(host_set lock)&n; */
DECL|function|ata_scsiop_mode_sense
r_int
r_int
id|ata_scsiop_mode_sense
c_func
(paren
r_struct
id|ata_scsi_args
op_star
id|args
comma
id|u8
op_star
id|rbuf
comma
r_int
r_int
id|buflen
)paren
(brace
id|u8
op_star
id|scsicmd
op_assign
id|args-&gt;cmd-&gt;cmnd
comma
op_star
id|p
comma
op_star
id|last
suffix:semicolon
r_int
r_int
id|page_control
comma
id|six_byte
comma
id|output_len
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;ENTER&bslash;n&quot;
)paren
suffix:semicolon
id|six_byte
op_assign
(paren
id|scsicmd
(braket
l_int|0
)braket
op_eq
id|MODE_SENSE
)paren
suffix:semicolon
multiline_comment|/* we only support saved and current values (which we treat&n;&t; * in the same manner)&n;&t; */
id|page_control
op_assign
id|scsicmd
(braket
l_int|2
)braket
op_rshift
l_int|6
suffix:semicolon
r_if
c_cond
(paren
(paren
id|page_control
op_ne
l_int|0
)paren
op_logical_and
(paren
id|page_control
op_ne
l_int|3
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|six_byte
)paren
id|output_len
op_assign
l_int|4
suffix:semicolon
r_else
id|output_len
op_assign
l_int|8
suffix:semicolon
id|p
op_assign
id|rbuf
op_plus
id|output_len
suffix:semicolon
id|last
op_assign
id|rbuf
op_plus
id|buflen
op_minus
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|scsicmd
(braket
l_int|2
)braket
op_amp
l_int|0x3f
)paren
(brace
r_case
l_int|0x01
suffix:colon
multiline_comment|/* r/w error recovery */
id|output_len
op_add_assign
id|ata_msense_rw_recovery
c_func
(paren
op_amp
id|p
comma
id|last
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x08
suffix:colon
multiline_comment|/* caching */
id|output_len
op_add_assign
id|ata_msense_caching
c_func
(paren
id|args-&gt;id
comma
op_amp
id|p
comma
id|last
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x0a
suffix:colon
(brace
multiline_comment|/* control mode */
id|output_len
op_add_assign
id|ata_msense_ctl_mode
c_func
(paren
op_amp
id|p
comma
id|last
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
l_int|0x3f
suffix:colon
multiline_comment|/* all pages */
id|output_len
op_add_assign
id|ata_msense_rw_recovery
c_func
(paren
op_amp
id|p
comma
id|last
)paren
suffix:semicolon
id|output_len
op_add_assign
id|ata_msense_caching
c_func
(paren
id|args-&gt;id
comma
op_amp
id|p
comma
id|last
)paren
suffix:semicolon
id|output_len
op_add_assign
id|ata_msense_ctl_mode
c_func
(paren
op_amp
id|p
comma
id|last
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* invalid page code */
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|six_byte
)paren
(brace
id|output_len
op_decrement
suffix:semicolon
id|rbuf
(braket
l_int|0
)braket
op_assign
id|output_len
suffix:semicolon
)brace
r_else
(brace
id|output_len
op_sub_assign
l_int|2
suffix:semicolon
id|rbuf
(braket
l_int|0
)braket
op_assign
id|output_len
op_rshift
l_int|8
suffix:semicolon
id|rbuf
(braket
l_int|1
)braket
op_assign
id|output_len
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_scsiop_read_cap - Simulate READ CAPACITY[ 16] commands&n; *&t;@args: device IDENTIFY data / SCSI command of interest.&n; *&t;@rbuf: Response buffer, to which simulated SCSI cmd output is sent.&n; *&t;@buflen: Response buffer length.&n; *&n; *&t;Simulate READ CAPACITY commands.&n; *&n; *&t;LOCKING:&n; *&t;spin_lock_irqsave(host_set lock)&n; */
DECL|function|ata_scsiop_read_cap
r_int
r_int
id|ata_scsiop_read_cap
c_func
(paren
r_struct
id|ata_scsi_args
op_star
id|args
comma
id|u8
op_star
id|rbuf
comma
r_int
r_int
id|buflen
)paren
(brace
id|u64
id|n_sectors
suffix:semicolon
id|u32
id|tmp
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;ENTER&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ata_id_has_lba48
c_func
(paren
id|args-&gt;id
)paren
)paren
id|n_sectors
op_assign
id|ata_id_u64
c_func
(paren
id|args-&gt;id
comma
l_int|100
)paren
suffix:semicolon
r_else
id|n_sectors
op_assign
id|ata_id_u32
c_func
(paren
id|args-&gt;id
comma
l_int|60
)paren
suffix:semicolon
id|n_sectors
op_decrement
suffix:semicolon
multiline_comment|/* ATA TotalUserSectors - 1 */
id|tmp
op_assign
id|n_sectors
suffix:semicolon
multiline_comment|/* note: truncates, if lba48 */
r_if
c_cond
(paren
id|args-&gt;cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|READ_CAPACITY
)paren
(brace
multiline_comment|/* sector count, 32-bit */
id|rbuf
(braket
l_int|0
)braket
op_assign
id|tmp
op_rshift
(paren
l_int|8
op_star
l_int|3
)paren
suffix:semicolon
id|rbuf
(braket
l_int|1
)braket
op_assign
id|tmp
op_rshift
(paren
l_int|8
op_star
l_int|2
)paren
suffix:semicolon
id|rbuf
(braket
l_int|2
)braket
op_assign
id|tmp
op_rshift
(paren
l_int|8
op_star
l_int|1
)paren
suffix:semicolon
id|rbuf
(braket
l_int|3
)braket
op_assign
id|tmp
suffix:semicolon
multiline_comment|/* sector size */
id|tmp
op_assign
id|ATA_SECT_SIZE
suffix:semicolon
id|rbuf
(braket
l_int|6
)braket
op_assign
id|tmp
op_rshift
l_int|8
suffix:semicolon
id|rbuf
(braket
l_int|7
)braket
op_assign
id|tmp
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* sector count, 64-bit */
id|rbuf
(braket
l_int|2
)braket
op_assign
id|n_sectors
op_rshift
(paren
l_int|8
op_star
l_int|7
)paren
suffix:semicolon
id|rbuf
(braket
l_int|3
)braket
op_assign
id|n_sectors
op_rshift
(paren
l_int|8
op_star
l_int|6
)paren
suffix:semicolon
id|rbuf
(braket
l_int|4
)braket
op_assign
id|n_sectors
op_rshift
(paren
l_int|8
op_star
l_int|5
)paren
suffix:semicolon
id|rbuf
(braket
l_int|5
)braket
op_assign
id|n_sectors
op_rshift
(paren
l_int|8
op_star
l_int|4
)paren
suffix:semicolon
id|rbuf
(braket
l_int|6
)braket
op_assign
id|tmp
op_rshift
(paren
l_int|8
op_star
l_int|3
)paren
suffix:semicolon
id|rbuf
(braket
l_int|7
)braket
op_assign
id|tmp
op_rshift
(paren
l_int|8
op_star
l_int|2
)paren
suffix:semicolon
id|rbuf
(braket
l_int|8
)braket
op_assign
id|tmp
op_rshift
(paren
l_int|8
op_star
l_int|1
)paren
suffix:semicolon
id|rbuf
(braket
l_int|9
)braket
op_assign
id|tmp
suffix:semicolon
multiline_comment|/* sector size */
id|tmp
op_assign
id|ATA_SECT_SIZE
suffix:semicolon
id|rbuf
(braket
l_int|12
)braket
op_assign
id|tmp
op_rshift
l_int|8
suffix:semicolon
id|rbuf
(braket
l_int|13
)braket
op_assign
id|tmp
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_scsiop_report_luns - Simulate REPORT LUNS command&n; *&t;@args: device IDENTIFY data / SCSI command of interest.&n; *&t;@rbuf: Response buffer, to which simulated SCSI cmd output is sent.&n; *&t;@buflen: Response buffer length.&n; *&n; *&t;Simulate REPORT LUNS command.&n; *&n; *&t;LOCKING:&n; *&t;spin_lock_irqsave(host_set lock)&n; */
DECL|function|ata_scsiop_report_luns
r_int
r_int
id|ata_scsiop_report_luns
c_func
(paren
r_struct
id|ata_scsi_args
op_star
id|args
comma
id|u8
op_star
id|rbuf
comma
r_int
r_int
id|buflen
)paren
(brace
id|VPRINTK
c_func
(paren
l_string|&quot;ENTER&bslash;n&quot;
)paren
suffix:semicolon
id|rbuf
(braket
l_int|3
)braket
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* just one lun, LUN 0, size 8 bytes */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_scsi_badcmd - End a SCSI request with an error&n; *&t;@cmd: SCSI request to be handled&n; *&t;@done: SCSI command completion function&n; *&t;@asc: SCSI-defined additional sense code&n; *&t;@ascq: SCSI-defined additional sense code qualifier&n; *&n; *&t;Helper function that completes a SCSI command with&n; *&t;%SAM_STAT_CHECK_CONDITION, with a sense key %ILLEGAL_REQUEST&n; *&t;and the specified additional sense codes.&n; *&n; *&t;LOCKING:&n; *&t;spin_lock_irqsave(host_set lock)&n; */
DECL|function|ata_scsi_badcmd
r_void
id|ata_scsi_badcmd
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
r_struct
id|scsi_cmnd
op_star
)paren
comma
id|u8
id|asc
comma
id|u8
id|ascq
)paren
(brace
id|DPRINTK
c_func
(paren
l_string|&quot;ENTER&bslash;n&quot;
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
id|SAM_STAT_CHECK_CONDITION
suffix:semicolon
id|cmd-&gt;sense_buffer
(braket
l_int|0
)braket
op_assign
l_int|0x70
suffix:semicolon
id|cmd-&gt;sense_buffer
(braket
l_int|2
)braket
op_assign
id|ILLEGAL_REQUEST
suffix:semicolon
id|cmd-&gt;sense_buffer
(braket
l_int|7
)braket
op_assign
l_int|14
op_minus
l_int|8
suffix:semicolon
multiline_comment|/* addnl. sense len. FIXME: correct? */
id|cmd-&gt;sense_buffer
(braket
l_int|12
)braket
op_assign
id|asc
suffix:semicolon
id|cmd-&gt;sense_buffer
(braket
l_int|13
)braket
op_assign
id|ascq
suffix:semicolon
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
DECL|function|atapi_qc_complete
r_static
r_int
id|atapi_qc_complete
c_func
(paren
r_struct
id|ata_queued_cmd
op_star
id|qc
comma
id|u8
id|drv_stat
)paren
(brace
r_struct
id|scsi_cmnd
op_star
id|cmd
op_assign
id|qc-&gt;scsicmd
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|drv_stat
op_amp
(paren
id|ATA_ERR
op_or
id|ATA_BUSY
op_or
id|ATA_DRQ
)paren
)paren
)paren
(brace
id|DPRINTK
c_func
(paren
l_string|&quot;request check condition&bslash;n&quot;
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
id|SAM_STAT_CHECK_CONDITION
suffix:semicolon
id|qc
op_member_access_from_pointer
id|scsidone
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|u8
op_star
id|scsicmd
op_assign
id|cmd-&gt;cmnd
suffix:semicolon
r_if
c_cond
(paren
id|scsicmd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
(brace
id|u8
op_star
id|buf
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|buflen
suffix:semicolon
id|buflen
op_assign
id|ata_scsi_rbuf_get
c_func
(paren
id|cmd
comma
op_amp
id|buf
)paren
suffix:semicolon
id|buf
(braket
l_int|2
)braket
op_assign
l_int|0x5
suffix:semicolon
id|buf
(braket
l_int|3
)braket
op_assign
(paren
id|buf
(braket
l_int|3
)braket
op_amp
l_int|0xf0
)paren
op_or
l_int|2
suffix:semicolon
id|ata_scsi_rbuf_put
c_func
(paren
id|cmd
comma
id|buf
)paren
suffix:semicolon
)brace
id|cmd-&gt;result
op_assign
id|SAM_STAT_GOOD
suffix:semicolon
)brace
id|qc
op_member_access_from_pointer
id|scsidone
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;atapi_xlat - Initialize PACKET taskfile&n; *&t;@qc: command structure to be initialized&n; *&t;@scsicmd: SCSI CDB associated with this PACKET command&n; *&n; *&t;LOCKING:&n; *&t;spin_lock_irqsave(host_set lock)&n; *&n; *&t;RETURNS:&n; *&t;Zero on success, non-zero on failure.&n; */
DECL|function|atapi_xlat
r_static
r_int
r_int
id|atapi_xlat
c_func
(paren
r_struct
id|ata_queued_cmd
op_star
id|qc
comma
id|u8
op_star
id|scsicmd
)paren
(brace
r_struct
id|scsi_cmnd
op_star
id|cmd
op_assign
id|qc-&gt;scsicmd
suffix:semicolon
r_struct
id|ata_device
op_star
id|dev
op_assign
id|qc-&gt;dev
suffix:semicolon
r_int
id|using_pio
op_assign
(paren
id|dev-&gt;flags
op_amp
id|ATA_DFLAG_PIO
)paren
suffix:semicolon
r_int
id|nodata
op_assign
(paren
id|cmd-&gt;sc_data_direction
op_eq
id|SCSI_DATA_NONE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|using_pio
)paren
multiline_comment|/* Check whether ATAPI DMA is safe */
r_if
c_cond
(paren
id|ata_check_atapi_dma
c_func
(paren
id|qc
)paren
)paren
id|using_pio
op_assign
l_int|1
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|qc-&gt;cdb
comma
id|scsicmd
comma
id|qc-&gt;ap-&gt;cdb_len
)paren
suffix:semicolon
id|qc-&gt;complete_fn
op_assign
id|atapi_qc_complete
suffix:semicolon
id|qc-&gt;tf.flags
op_or_assign
id|ATA_TFLAG_ISADDR
op_or
id|ATA_TFLAG_DEVICE
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;sc_data_direction
op_eq
id|SCSI_DATA_WRITE
)paren
(brace
id|qc-&gt;tf.flags
op_or_assign
id|ATA_TFLAG_WRITE
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;direction: write&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|qc-&gt;tf.command
op_assign
id|ATA_CMD_PACKET
suffix:semicolon
multiline_comment|/* no data, or PIO data xfer */
r_if
c_cond
(paren
id|using_pio
op_logical_or
id|nodata
)paren
(brace
r_if
c_cond
(paren
id|nodata
)paren
id|qc-&gt;tf.protocol
op_assign
id|ATA_PROT_ATAPI_NODATA
suffix:semicolon
r_else
id|qc-&gt;tf.protocol
op_assign
id|ATA_PROT_ATAPI
suffix:semicolon
id|qc-&gt;tf.lbam
op_assign
(paren
l_int|8
op_star
l_int|1024
)paren
op_amp
l_int|0xff
suffix:semicolon
id|qc-&gt;tf.lbah
op_assign
(paren
l_int|8
op_star
l_int|1024
)paren
op_rshift
l_int|8
suffix:semicolon
)brace
multiline_comment|/* DMA data xfer */
r_else
(brace
id|qc-&gt;tf.protocol
op_assign
id|ATA_PROT_ATAPI_DMA
suffix:semicolon
id|qc-&gt;tf.feature
op_or_assign
id|ATAPI_PKT_DMA
suffix:semicolon
macro_line|#ifdef ATAPI_ENABLE_DMADIR
multiline_comment|/* some SATA bridges need us to indicate data xfer direction */
r_if
c_cond
(paren
id|cmd-&gt;sc_data_direction
op_ne
id|SCSI_DATA_WRITE
)paren
id|qc-&gt;tf.feature
op_or_assign
id|ATAPI_DMADIR
suffix:semicolon
macro_line|#endif
)brace
id|qc-&gt;nbytes
op_assign
id|cmd-&gt;bufflen
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_scsi_find_dev - lookup ata_device from scsi_cmnd&n; *&t;@ap: ATA port to which the device is attached&n; *&t;@scsidev: SCSI device from which we derive the ATA device&n; *&n; *&t;Given various information provided in struct scsi_cmnd,&n; *&t;map that onto an ATA bus, and using that mapping&n; *&t;determine which ata_device is associated with the&n; *&t;SCSI command to be sent.&n; *&n; *&t;LOCKING:&n; *&t;spin_lock_irqsave(host_set lock)&n; *&n; *&t;RETURNS:&n; *&t;Associated ATA device, or %NULL if not found.&n; */
r_static
r_struct
id|ata_device
op_star
DECL|function|ata_scsi_find_dev
id|ata_scsi_find_dev
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_struct
id|scsi_device
op_star
id|scsidev
)paren
(brace
r_struct
id|ata_device
op_star
id|dev
suffix:semicolon
multiline_comment|/* skip commands not addressed to targets we simulate */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|scsidev-&gt;id
OL
id|ATA_MAX_DEVICES
)paren
)paren
id|dev
op_assign
op_amp
id|ap-&gt;device
(braket
id|scsidev-&gt;id
)braket
suffix:semicolon
r_else
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|scsidev-&gt;channel
op_ne
l_int|0
)paren
op_logical_or
(paren
id|scsidev-&gt;lun
op_ne
l_int|0
)paren
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ata_dev_present
c_func
(paren
id|dev
)paren
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
macro_line|#ifndef ATA_ENABLE_ATAPI
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|dev
op_member_access_from_pointer
r_class
op_eq
id|ATA_DEV_ATAPI
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
macro_line|#endif
r_return
id|dev
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_get_xlat_func - check if SCSI to ATA translation is possible&n; *&t;@dev: ATA device&n; *&t;@cmd: SCSI command opcode to consider&n; *&n; *&t;Look up the SCSI command given, and determine whether the&n; *&t;SCSI command is to be translated or simulated.&n; *&n; *&t;RETURNS:&n; *&t;Pointer to translation function if possible, %NULL if not.&n; */
DECL|function|ata_get_xlat_func
r_static
r_inline
id|ata_xlat_func_t
id|ata_get_xlat_func
c_func
(paren
r_struct
id|ata_device
op_star
id|dev
comma
id|u8
id|cmd
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|READ_6
suffix:colon
r_case
id|READ_10
suffix:colon
r_case
id|READ_16
suffix:colon
r_case
id|WRITE_6
suffix:colon
r_case
id|WRITE_10
suffix:colon
r_case
id|WRITE_16
suffix:colon
r_return
id|ata_scsi_rw_xlat
suffix:semicolon
r_case
id|SYNCHRONIZE_CACHE
suffix:colon
r_if
c_cond
(paren
id|ata_try_flush_cache
c_func
(paren
id|dev
)paren
)paren
r_return
id|ata_scsi_flush_xlat
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VERIFY
suffix:colon
r_case
id|VERIFY_16
suffix:colon
r_return
id|ata_scsi_verify_xlat
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_scsi_dump_cdb - dump SCSI command contents to dmesg&n; *&t;@ap: ATA port to which the command was being sent&n; *&t;@cmd: SCSI command to dump&n; *&n; *&t;Prints the contents of a SCSI command via printk().&n; */
DECL|function|ata_scsi_dump_cdb
r_static
r_inline
r_void
id|ata_scsi_dump_cdb
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
macro_line|#ifdef ATA_DEBUG
r_struct
id|scsi_device
op_star
id|scsidev
op_assign
id|cmd-&gt;device
suffix:semicolon
id|u8
op_star
id|scsicmd
op_assign
id|cmd-&gt;cmnd
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;CDB (%u:%d,%d,%d) %02x %02x %02x %02x %02x %02x %02x %02x %02x&bslash;n&quot;
comma
id|ap-&gt;id
comma
id|scsidev-&gt;channel
comma
id|scsidev-&gt;id
comma
id|scsidev-&gt;lun
comma
id|scsicmd
(braket
l_int|0
)braket
comma
id|scsicmd
(braket
l_int|1
)braket
comma
id|scsicmd
(braket
l_int|2
)braket
comma
id|scsicmd
(braket
l_int|3
)braket
comma
id|scsicmd
(braket
l_int|4
)braket
comma
id|scsicmd
(braket
l_int|5
)braket
comma
id|scsicmd
(braket
l_int|6
)braket
comma
id|scsicmd
(braket
l_int|7
)braket
comma
id|scsicmd
(braket
l_int|8
)braket
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/**&n; *&t;ata_scsi_queuecmd - Issue SCSI cdb to libata-managed device&n; *&t;@cmd: SCSI command to be sent&n; *&t;@done: Completion function, called when command is complete&n; *&n; *&t;In some cases, this function translates SCSI commands into&n; *&t;ATA taskfiles, and queues the taskfiles to be sent to&n; *&t;hardware.  In other cases, this function simulates a&n; *&t;SCSI device by evaluating and responding to certain&n; *&t;SCSI commands.  This creates the overall effect of&n; *&t;ATA and ATAPI devices appearing as SCSI devices.&n; *&n; *&t;LOCKING:&n; *&t;Releases scsi-layer-held lock, and obtains host_set lock.&n; *&n; *&t;RETURNS:&n; *&t;Zero.&n; */
DECL|function|ata_scsi_queuecmd
r_int
id|ata_scsi_queuecmd
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
r_struct
id|scsi_cmnd
op_star
)paren
)paren
(brace
r_struct
id|ata_port
op_star
id|ap
suffix:semicolon
r_struct
id|ata_device
op_star
id|dev
suffix:semicolon
r_struct
id|scsi_device
op_star
id|scsidev
op_assign
id|cmd-&gt;device
suffix:semicolon
id|ap
op_assign
(paren
r_struct
id|ata_port
op_star
)paren
op_amp
id|scsidev-&gt;host-&gt;hostdata
(braket
l_int|0
)braket
suffix:semicolon
id|ata_scsi_dump_cdb
c_func
(paren
id|ap
comma
id|cmd
)paren
suffix:semicolon
id|dev
op_assign
id|ata_scsi_find_dev
c_func
(paren
id|ap
comma
id|scsidev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|dev
)paren
)paren
(brace
id|cmd-&gt;result
op_assign
(paren
id|DID_BAD_TARGET
op_lshift
l_int|16
)paren
suffix:semicolon
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
r_class
op_eq
id|ATA_DEV_ATA
)paren
(brace
id|ata_xlat_func_t
id|xlat_func
op_assign
id|ata_get_xlat_func
c_func
(paren
id|dev
comma
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xlat_func
)paren
id|ata_scsi_translate
c_func
(paren
id|ap
comma
id|dev
comma
id|cmd
comma
id|done
comma
id|xlat_func
)paren
suffix:semicolon
r_else
id|ata_scsi_simulate
c_func
(paren
id|dev-&gt;id
comma
id|cmd
comma
id|done
)paren
suffix:semicolon
)brace
r_else
id|ata_scsi_translate
c_func
(paren
id|ap
comma
id|dev
comma
id|cmd
comma
id|done
comma
id|atapi_xlat
)paren
suffix:semicolon
id|out_unlock
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_scsi_simulate - simulate SCSI command on ATA device&n; *&t;@id: current IDENTIFY data for target device.&n; *&t;@cmd: SCSI command being sent to device.&n; *&t;@done: SCSI command completion function.&n; *&n; *&t;Interprets and directly executes a select list of SCSI commands&n; *&t;that can be handled internally.&n; *&n; *&t;LOCKING:&n; *&t;spin_lock_irqsave(host_set lock)&n; */
DECL|function|ata_scsi_simulate
r_void
id|ata_scsi_simulate
c_func
(paren
id|u16
op_star
id|id
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
r_struct
id|scsi_cmnd
op_star
)paren
)paren
(brace
r_struct
id|ata_scsi_args
id|args
suffix:semicolon
id|u8
op_star
id|scsicmd
op_assign
id|cmd-&gt;cmnd
suffix:semicolon
id|args.id
op_assign
id|id
suffix:semicolon
id|args.cmd
op_assign
id|cmd
suffix:semicolon
id|args.done
op_assign
id|done
suffix:semicolon
r_switch
c_cond
(paren
id|scsicmd
(braket
l_int|0
)braket
)paren
(brace
multiline_comment|/* no-op&squot;s, complete with success */
r_case
id|SYNCHRONIZE_CACHE
suffix:colon
r_case
id|REZERO_UNIT
suffix:colon
r_case
id|SEEK_6
suffix:colon
r_case
id|SEEK_10
suffix:colon
r_case
id|TEST_UNIT_READY
suffix:colon
r_case
id|FORMAT_UNIT
suffix:colon
multiline_comment|/* FIXME: correct? */
r_case
id|SEND_DIAGNOSTIC
suffix:colon
multiline_comment|/* FIXME: correct? */
id|ata_scsi_rbuf_fill
c_func
(paren
op_amp
id|args
comma
id|ata_scsiop_noop
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|INQUIRY
suffix:colon
r_if
c_cond
(paren
id|scsicmd
(braket
l_int|1
)braket
op_amp
l_int|2
)paren
multiline_comment|/* is CmdDt set?  */
id|ata_bad_cdb
c_func
(paren
id|cmd
comma
id|done
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|scsicmd
(braket
l_int|1
)braket
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
multiline_comment|/* is EVPD clear? */
id|ata_scsi_rbuf_fill
c_func
(paren
op_amp
id|args
comma
id|ata_scsiop_inq_std
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|scsicmd
(braket
l_int|2
)braket
op_eq
l_int|0x00
)paren
id|ata_scsi_rbuf_fill
c_func
(paren
op_amp
id|args
comma
id|ata_scsiop_inq_00
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|scsicmd
(braket
l_int|2
)braket
op_eq
l_int|0x80
)paren
id|ata_scsi_rbuf_fill
c_func
(paren
op_amp
id|args
comma
id|ata_scsiop_inq_80
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|scsicmd
(braket
l_int|2
)braket
op_eq
l_int|0x83
)paren
id|ata_scsi_rbuf_fill
c_func
(paren
op_amp
id|args
comma
id|ata_scsiop_inq_83
)paren
suffix:semicolon
r_else
id|ata_bad_cdb
c_func
(paren
id|cmd
comma
id|done
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MODE_SENSE
suffix:colon
r_case
id|MODE_SENSE_10
suffix:colon
id|ata_scsi_rbuf_fill
c_func
(paren
op_amp
id|args
comma
id|ata_scsiop_mode_sense
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MODE_SELECT
suffix:colon
multiline_comment|/* unconditionally return */
r_case
id|MODE_SELECT_10
suffix:colon
multiline_comment|/* bad-field-in-cdb */
id|ata_bad_cdb
c_func
(paren
id|cmd
comma
id|done
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|READ_CAPACITY
suffix:colon
id|ata_scsi_rbuf_fill
c_func
(paren
op_amp
id|args
comma
id|ata_scsiop_read_cap
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SERVICE_ACTION_IN
suffix:colon
r_if
c_cond
(paren
(paren
id|scsicmd
(braket
l_int|1
)braket
op_amp
l_int|0x1f
)paren
op_eq
id|SAI_READ_CAPACITY_16
)paren
id|ata_scsi_rbuf_fill
c_func
(paren
op_amp
id|args
comma
id|ata_scsiop_read_cap
)paren
suffix:semicolon
r_else
id|ata_bad_cdb
c_func
(paren
id|cmd
comma
id|done
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REPORT_LUNS
suffix:colon
id|ata_scsi_rbuf_fill
c_func
(paren
op_amp
id|args
comma
id|ata_scsiop_report_luns
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* mandantory commands we haven&squot;t implemented yet */
r_case
id|REQUEST_SENSE
suffix:colon
multiline_comment|/* all other commands */
r_default
suffix:colon
id|ata_bad_scsiop
c_func
(paren
id|cmd
comma
id|done
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
eof
