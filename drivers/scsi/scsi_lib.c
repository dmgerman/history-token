multiline_comment|/*&n; *  scsi_lib.c Copyright (C) 1999 Eric Youngdale&n; *&n; *  SCSI queueing library.&n; *      Initial versions: Eric Youngdale (eric@andante.org).&n; *                        Based upon conversations with large numbers&n; *                        of people at Linux Expo.&n; */
macro_line|#include &lt;linux/bio.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/completion.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mempool.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
DECL|macro|SG_MEMPOOL_NR
mdefine_line|#define SG_MEMPOOL_NR&t;&t;5
DECL|macro|SG_MEMPOOL_SIZE
mdefine_line|#define SG_MEMPOOL_SIZE&t;&t;32
DECL|struct|scsi_host_sg_pool
r_struct
id|scsi_host_sg_pool
(brace
DECL|member|size
r_int
id|size
suffix:semicolon
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|slab
id|kmem_cache_t
op_star
id|slab
suffix:semicolon
DECL|member|pool
id|mempool_t
op_star
id|pool
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|SP
mdefine_line|#define SP(x) { x, &quot;sgpool-&quot; #x } 
DECL|variable|scsi_sg_pools
r_struct
id|scsi_host_sg_pool
id|scsi_sg_pools
(braket
id|SG_MEMPOOL_NR
)braket
op_assign
(brace
id|SP
c_func
(paren
l_int|8
)paren
comma
id|SP
c_func
(paren
l_int|16
)paren
comma
id|SP
c_func
(paren
l_int|32
)paren
comma
id|SP
c_func
(paren
l_int|64
)paren
comma
id|SP
c_func
(paren
id|MAX_PHYS_SEGMENTS
)paren
)brace
suffix:semicolon
DECL|macro|SP
macro_line|#undef SP
multiline_comment|/*&n; * Function:    scsi_insert_special_req()&n; *&n; * Purpose:     Insert pre-formed request into request queue.&n; *&n; * Arguments:   sreq&t;- request that is ready to be queued.&n; *              at_head&t;- boolean.  True if we should insert at head&n; *                        of queue, false if we should insert at tail.&n; *&n; * Lock status: Assumed that lock is not held upon entry.&n; *&n; * Returns:     Nothing&n; *&n; * Notes:       This function is called from character device and from&n; *              ioctl types of functions where the caller knows exactly&n; *              what SCSI command needs to be issued.   The idea is that&n; *              we merely inject the command into the queue (at the head&n; *              for now), and then call the queue request function to actually&n; *              process it.&n; */
DECL|function|scsi_insert_special_req
r_int
id|scsi_insert_special_req
c_func
(paren
r_struct
id|scsi_request
op_star
id|sreq
comma
r_int
id|at_head
)paren
(brace
multiline_comment|/*&n;&t; * Because users of this function are apt to reuse requests with no&n;&t; * modification, we have to sanitise the request flags here&n;&t; */
id|sreq-&gt;sr_request-&gt;flags
op_and_assign
op_complement
id|REQ_DONTPREP
suffix:semicolon
id|blk_insert_request
c_func
(paren
id|sreq-&gt;sr_device-&gt;request_queue
comma
id|sreq-&gt;sr_request
comma
id|at_head
comma
id|sreq
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_queue_insert()&n; *&n; * Purpose:     Insert a command in the midlevel queue.&n; *&n; * Arguments:   cmd    - command that we are adding to queue.&n; *              reason - why we are inserting command to queue.&n; *&n; * Lock status: Assumed that lock is not held upon entry.&n; *&n; * Returns:     Nothing.&n; *&n; * Notes:       We do this for one of two cases.  Either the host is busy&n; *              and it cannot accept any more commands for the time being,&n; *              or the device returned QUEUE_FULL and can accept no more&n; *              commands.&n; * Notes:       This could be called either from an interrupt context or a&n; *              normal process context.&n; */
DECL|function|scsi_queue_insert
r_int
id|scsi_queue_insert
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_int
id|reason
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|cmd-&gt;device-&gt;host
suffix:semicolon
r_struct
id|scsi_device
op_star
id|device
op_assign
id|cmd-&gt;device
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;Inserting command %p into mlqueue&bslash;n&quot;
comma
id|cmd
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We are inserting the command into the ml queue.  First, we&n;&t; * cancel the timer, so it doesn&squot;t time out.&n;&t; */
id|scsi_delete_timer
c_func
(paren
id|cmd
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Next, set the appropriate busy bit for the device/host.&n;&t; *&n;&t; * If the host/device isn&squot;t busy, assume that something actually&n;&t; * completed, and that we should be able to queue a command now.&n;&t; *&n;&t; * Note that the prior mid-layer assumption that any host could&n;&t; * always queue at least one command is now broken.  The mid-layer&n;&t; * will implement a user specifiable stall (see&n;&t; * scsi_host.max_host_blocked and scsi_device.max_device_blocked)&n;&t; * if a command is requeued with no other commands outstanding&n;&t; * either for the device or for the host.&n;&t; */
r_if
c_cond
(paren
id|reason
op_eq
id|SCSI_MLQUEUE_HOST_BUSY
)paren
id|host-&gt;host_blocked
op_assign
id|host-&gt;max_host_blocked
suffix:semicolon
r_else
r_if
c_cond
(paren
id|reason
op_eq
id|SCSI_MLQUEUE_DEVICE_BUSY
)paren
id|device-&gt;device_blocked
op_assign
id|device-&gt;max_device_blocked
suffix:semicolon
multiline_comment|/*&n;&t; * Register the fact that we own the thing for now.&n;&t; */
id|cmd-&gt;state
op_assign
id|SCSI_STATE_MLQUEUE
suffix:semicolon
id|cmd-&gt;owner
op_assign
id|SCSI_OWNER_MIDLEVEL
suffix:semicolon
multiline_comment|/*&n;&t; * Decrement the counters, since these commands are no longer&n;&t; * active on the host/device.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
id|device-&gt;request_queue-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
id|device-&gt;device_busy
op_decrement
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|device-&gt;request_queue-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
id|scsi_host_busy_dec_and_test
c_func
(paren
id|host
comma
id|device
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Insert this command at the head of the queue for it&squot;s device.&n;&t; * It will go before all other commands that are already in the queue.&n;&t; *&n;&t; * NOTE: there is magic here about the way the queue is plugged if&n;&t; * we have no outstanding commands.&n;&t; * &n;&t; * Although this *doesn&squot;t* plug the queue, it does call the request&n;&t; * function.  The SCSI request function detects the blocked condition&n;&t; * and plugs the queue appropriately.&n;&t; */
id|blk_insert_request
c_func
(paren
id|device-&gt;request_queue
comma
id|cmd-&gt;request
comma
l_int|1
comma
id|cmd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_do_req&n; *&n; * Purpose:     Queue a SCSI request&n; *&n; * Arguments:   sreq&t;  - command descriptor.&n; *              cmnd      - actual SCSI command to be performed.&n; *              buffer    - data buffer.&n; *              bufflen   - size of data buffer.&n; *              done      - completion function to be run.&n; *              timeout   - how long to let it run before timeout.&n; *              retries   - number of retries we allow.&n; *&n; * Lock status: No locks held upon entry.&n; *&n; * Returns:     Nothing.&n; *&n; * Notes:&t;This function is only used for queueing requests for things&n; *&t;&t;like ioctls and character device requests - this is because&n; *&t;&t;we essentially just inject a request into the queue for the&n; *&t;&t;device.&n; */
DECL|function|scsi_do_req
r_void
id|scsi_do_req
c_func
(paren
r_struct
id|scsi_request
op_star
id|sreq
comma
r_const
r_void
op_star
id|cmnd
comma
r_void
op_star
id|buffer
comma
r_int
id|bufflen
comma
r_void
(paren
op_star
id|done
)paren
(paren
r_struct
id|scsi_cmnd
op_star
)paren
comma
r_int
id|timeout
comma
r_int
id|retries
)paren
(brace
r_struct
id|request_queue
op_star
id|q
suffix:semicolon
multiline_comment|/*&n;&t; * If the upper level driver is reusing these things, then&n;&t; * we should release the low-level block now.  Another one will&n;&t; * be allocated later when this request is getting queued.&n;&t; */
r_if
c_cond
(paren
id|sreq-&gt;sr_command
)paren
(brace
id|q
op_assign
id|sreq-&gt;sr_command-&gt;device-&gt;request_queue
suffix:semicolon
id|scsi_put_command
c_func
(paren
id|sreq-&gt;sr_command
)paren
suffix:semicolon
id|sreq-&gt;sr_command
op_assign
l_int|NULL
suffix:semicolon
id|scsi_queue_next_request
c_func
(paren
id|q
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Our own function scsi_done (which marks the host as not busy,&n;&t; * disables the timeout counter, etc) will be called by us or by the&n;&t; * scsi_hosts[host].queuecommand() function needs to also call&n;&t; * the completion function for the high level driver.&n;&t; */
id|memcpy
c_func
(paren
id|sreq-&gt;sr_cmnd
comma
id|cmnd
comma
r_sizeof
(paren
id|sreq-&gt;sr_cmnd
)paren
)paren
suffix:semicolon
id|sreq-&gt;sr_bufflen
op_assign
id|bufflen
suffix:semicolon
id|sreq-&gt;sr_buffer
op_assign
id|buffer
suffix:semicolon
id|sreq-&gt;sr_allowed
op_assign
id|retries
suffix:semicolon
id|sreq-&gt;sr_done
op_assign
id|done
suffix:semicolon
id|sreq-&gt;sr_timeout_per_command
op_assign
id|timeout
suffix:semicolon
r_if
c_cond
(paren
id|sreq-&gt;sr_cmd_len
op_eq
l_int|0
)paren
id|sreq-&gt;sr_cmd_len
op_assign
id|COMMAND_SIZE
c_func
(paren
id|sreq-&gt;sr_cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * At this point, we merely set up the command, stick it in the normal&n;&t; * request queue, and return.  Eventually that request will come to the&n;&t; * top of the list, and will be dispatched.&n;&t; */
id|scsi_insert_special_req
c_func
(paren
id|sreq
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|scsi_wait_done
r_static
r_void
id|scsi_wait_done
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|request
op_star
id|req
op_assign
id|cmd-&gt;request
suffix:semicolon
r_struct
id|request_queue
op_star
id|q
op_assign
id|cmd-&gt;device-&gt;request_queue
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|req-&gt;rq_status
op_assign
id|RQ_SCSI_DONE
suffix:semicolon
multiline_comment|/* Busy, but indicate request done */
id|spin_lock_irqsave
c_func
(paren
id|q-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blk_rq_tagged
c_func
(paren
id|req
)paren
)paren
id|blk_queue_end_tag
c_func
(paren
id|q
comma
id|req
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|q-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;waiting
)paren
id|complete
c_func
(paren
id|req-&gt;waiting
)paren
suffix:semicolon
)brace
DECL|function|scsi_wait_req
r_void
id|scsi_wait_req
c_func
(paren
r_struct
id|scsi_request
op_star
id|sreq
comma
r_const
r_void
op_star
id|cmnd
comma
r_void
op_star
id|buffer
comma
r_int
id|bufflen
comma
r_int
id|timeout
comma
r_int
id|retries
)paren
(brace
r_struct
id|request_queue
op_star
id|q
suffix:semicolon
id|DECLARE_COMPLETION
c_func
(paren
id|wait
)paren
suffix:semicolon
id|sreq-&gt;sr_request-&gt;waiting
op_assign
op_amp
id|wait
suffix:semicolon
id|sreq-&gt;sr_request-&gt;rq_status
op_assign
id|RQ_SCSI_BUSY
suffix:semicolon
id|scsi_do_req
c_func
(paren
id|sreq
comma
id|cmnd
comma
id|buffer
comma
id|bufflen
comma
id|scsi_wait_done
comma
id|timeout
comma
id|retries
)paren
suffix:semicolon
id|generic_unplug_device
c_func
(paren
id|sreq-&gt;sr_device-&gt;request_queue
)paren
suffix:semicolon
id|wait_for_completion
c_func
(paren
op_amp
id|wait
)paren
suffix:semicolon
id|sreq-&gt;sr_request-&gt;waiting
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|sreq-&gt;sr_command
)paren
(brace
id|q
op_assign
id|sreq-&gt;sr_command-&gt;device-&gt;request_queue
suffix:semicolon
id|scsi_put_command
c_func
(paren
id|sreq-&gt;sr_command
)paren
suffix:semicolon
id|scsi_queue_next_request
c_func
(paren
id|q
comma
l_int|NULL
)paren
suffix:semicolon
id|sreq-&gt;sr_command
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function:    scsi_init_cmd_errh()&n; *&n; * Purpose:     Initialize cmd fields related to error handling.&n; *&n; * Arguments:   cmd&t;- command that is ready to be queued.&n; *&n; * Returns:     Nothing&n; *&n; * Notes:       This function has the job of initializing a number of&n; *              fields related to error handling.   Typically this will&n; *              be called once for each command, as required.&n; */
DECL|function|scsi_init_cmd_errh
r_static
r_int
id|scsi_init_cmd_errh
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
id|cmd-&gt;owner
op_assign
id|SCSI_OWNER_MIDLEVEL
suffix:semicolon
id|cmd-&gt;reset_chain
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;serial_number
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;serial_number_at_timeout
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;abort_reason
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|cmd-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
id|cmd-&gt;sense_buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;cmd_len
op_eq
l_int|0
)paren
id|cmd-&gt;cmd_len
op_assign
id|COMMAND_SIZE
c_func
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We need saved copies of a number of fields - this is because&n;&t; * error handling may need to overwrite these with different values&n;&t; * to run different commands, and once error handling is complete,&n;&t; * we will need to restore these values prior to running the actual&n;&t; * command.&n;&t; */
id|cmd-&gt;old_use_sg
op_assign
id|cmd-&gt;use_sg
suffix:semicolon
id|cmd-&gt;old_cmd_len
op_assign
id|cmd-&gt;cmd_len
suffix:semicolon
id|cmd-&gt;sc_old_data_direction
op_assign
id|cmd-&gt;sc_data_direction
suffix:semicolon
id|cmd-&gt;old_underflow
op_assign
id|cmd-&gt;underflow
suffix:semicolon
id|memcpy
c_func
(paren
id|cmd-&gt;data_cmnd
comma
id|cmd-&gt;cmnd
comma
r_sizeof
(paren
id|cmd-&gt;cmnd
)paren
)paren
suffix:semicolon
id|cmd-&gt;buffer
op_assign
id|cmd-&gt;request_buffer
suffix:semicolon
id|cmd-&gt;bufflen
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
id|cmd-&gt;reset_chain
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;internal_timeout
op_assign
id|NORMAL_TIMEOUT
suffix:semicolon
id|cmd-&gt;abort_reason
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:   scsi_setup_cmd_retry()&n; *&n; * Purpose:    Restore the command state for a retry&n; *&n; * Arguments:  cmd&t;- command to be restored&n; *&n; * Returns:    Nothing&n; *&n; * Notes:      Immediately prior to retrying a command, we need&n; *             to restore certain fields that we saved above.&n; */
DECL|function|scsi_setup_cmd_retry
r_void
id|scsi_setup_cmd_retry
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
id|memcpy
c_func
(paren
id|cmd-&gt;cmnd
comma
id|cmd-&gt;data_cmnd
comma
r_sizeof
(paren
id|cmd-&gt;data_cmnd
)paren
)paren
suffix:semicolon
id|cmd-&gt;request_buffer
op_assign
id|cmd-&gt;buffer
suffix:semicolon
id|cmd-&gt;request_bufflen
op_assign
id|cmd-&gt;bufflen
suffix:semicolon
id|cmd-&gt;use_sg
op_assign
id|cmd-&gt;old_use_sg
suffix:semicolon
id|cmd-&gt;cmd_len
op_assign
id|cmd-&gt;old_cmd_len
suffix:semicolon
id|cmd-&gt;sc_data_direction
op_assign
id|cmd-&gt;sc_old_data_direction
suffix:semicolon
id|cmd-&gt;underflow
op_assign
id|cmd-&gt;old_underflow
suffix:semicolon
)brace
multiline_comment|/*&n; * Called for single_lun devices. The target associated with current_sdev can&n; * only handle one active command at a time. Scan through all of the luns&n; * on the same target as current_sdev, return 1 if any are active.&n; */
DECL|function|scsi_single_lun_check
r_static
r_int
id|scsi_single_lun_check
c_func
(paren
r_struct
id|scsi_device
op_star
id|current_sdev
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|sdev
comma
op_amp
id|current_sdev-&gt;same_target_siblings
comma
id|same_target_siblings
)paren
r_if
c_cond
(paren
id|sdev-&gt;device_busy
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Called for single_lun devices on IO completion. If no requests&n; * outstanding for current_sdev, call __blk_run_queue for the next&n; * scsi_device on the same target that has requests.&n; *&n; * Called with *no* scsi locks held.&n; */
DECL|function|scsi_single_lun_run
r_static
r_void
id|scsi_single_lun_run
c_func
(paren
r_struct
id|scsi_device
op_star
id|current_sdev
comma
r_struct
id|request_queue
op_star
id|q
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shost
suffix:semicolon
id|shost
op_assign
id|current_sdev-&gt;host
suffix:semicolon
r_if
c_cond
(paren
id|blk_queue_empty
c_func
(paren
id|q
)paren
op_logical_and
id|current_sdev-&gt;device_busy
op_eq
l_int|0
op_logical_and
op_logical_neg
id|shost-&gt;host_blocked
op_logical_and
op_logical_neg
id|shost-&gt;host_self_blocked
op_logical_and
op_logical_neg
(paren
(paren
id|shost-&gt;can_queue
OG
l_int|0
)paren
op_logical_and
(paren
id|shost-&gt;host_busy
op_ge
id|shost-&gt;can_queue
)paren
)paren
)paren
id|list_for_each_entry
c_func
(paren
id|sdev
comma
op_amp
id|current_sdev-&gt;same_target_siblings
comma
id|same_target_siblings
)paren
r_if
c_cond
(paren
op_logical_neg
id|sdev-&gt;device_blocked
op_logical_and
op_logical_neg
id|blk_queue_empty
c_func
(paren
id|sdev-&gt;request_queue
)paren
)paren
(brace
id|__blk_run_queue
c_func
(paren
id|sdev-&gt;request_queue
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function:    scsi_queue_next_request()&n; *&n; * Purpose:     Handle post-processing of completed commands.&n; *&n; * Arguments:   cmd&t;- command that may need to be requeued.&n; *&n; * Returns:     Nothing&n; *&n; * Notes:       After command completion, there may be blocks left&n; *              over which weren&squot;t finished by the previous command&n; *              this can be for a number of reasons - the main one is&n; *              that a medium error occurred, and the sectors after&n; *              the bad block need to be re-read.&n; *&n; *              If cmd is NULL, it means that the previous command&n; *              was completely finished, and we should simply start&n; *              a new command, if possible.&n; *&n; *&t;&t;This is where a lot of special case code has begun to&n; *&t;&t;accumulate.  It doesn&squot;t really affect readability or&n; *&t;&t;anything, but it might be considered architecturally&n; *&t;&t;inelegant.  If more of these special cases start to&n; *&t;&t;accumulate, I am thinking along the lines of implementing&n; *&t;&t;an atexit() like technology that gets run when commands&n; *&t;&t;complete.  I am not convinced that it is worth the&n; *&t;&t;added overhead, however.  Right now as things stand,&n; *&t;&t;there are simple conditional checks, and most hosts&n; *&t;&t;would skip past.&n; *&n; *&t;&t;Another possible solution would be to tailor different&n; *&t;&t;handler functions, sort of like what we did in scsi_merge.c.&n; *&t;&t;This is probably a better solution, but the number of different&n; *&t;&t;permutations grows as 2**N, and if too many more special cases&n; *&t;&t;get added, we start to get screwed.&n; */
DECL|function|scsi_queue_next_request
r_void
id|scsi_queue_next_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
comma
op_star
id|sdev2
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shost
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * For some reason, we are not done with this request.&n;&t;&t; * This happens for I/O errors in the middle of the request,&n;&t;&t; * in which case we need to request the blocks that come after&n;&t;&t; * the bad sector.&n;&t;&t; */
id|spin_lock_irqsave
c_func
(paren
id|q-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
id|cmd-&gt;request-&gt;special
op_assign
id|cmd
suffix:semicolon
r_if
c_cond
(paren
id|blk_rq_tagged
c_func
(paren
id|cmd-&gt;request
)paren
)paren
id|blk_queue_end_tag
c_func
(paren
id|q
comma
id|cmd-&gt;request
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * set REQ_SPECIAL - we have a command&n;&t;&t; * clear REQ_DONTPREP - we assume the sg table has been &n;&t;&t; *&t;nuked so we need to set it up again.&n;&t;&t; */
id|cmd-&gt;request-&gt;flags
op_or_assign
id|REQ_SPECIAL
suffix:semicolon
id|cmd-&gt;request-&gt;flags
op_and_assign
op_complement
id|REQ_DONTPREP
suffix:semicolon
id|__elv_add_request
c_func
(paren
id|q
comma
id|cmd-&gt;request
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|q-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|sdev
op_assign
id|q-&gt;queuedata
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;single_lun
)paren
id|scsi_single_lun_run
c_func
(paren
id|sdev
comma
id|q
)paren
suffix:semicolon
id|shost
op_assign
id|sdev-&gt;host
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|shost-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|shost-&gt;starved_list
)paren
op_logical_and
op_logical_neg
id|shost-&gt;host_blocked
op_logical_and
op_logical_neg
id|shost-&gt;host_self_blocked
op_logical_and
op_logical_neg
(paren
(paren
id|shost-&gt;can_queue
OG
l_int|0
)paren
op_logical_and
(paren
id|shost-&gt;host_busy
op_ge
id|shost-&gt;can_queue
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * As long as shost is accepting commands and we have&n;&t;&t; * starved queues, call __blk_run_queue. scsi_request_fn&n;&t;&t; * drops the queue_lock and can add us back to the&n;&t;&t; * starved_list.&n;&t;&t; *&n;&t;&t; * host_lock protects the starved_list and starved_entry.&n;&t;&t; * scsi_request_fn must get the host_lock before checking&n;&t;&t; * or modifying starved_list or starved_entry.&n;&t;&t; */
id|sdev2
op_assign
id|list_entry
c_func
(paren
id|shost-&gt;starved_list.next
comma
r_struct
id|scsi_device
comma
id|starved_entry
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|sdev2-&gt;starved_entry
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|shost-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|sdev2-&gt;request_queue-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
id|__blk_run_queue
c_func
(paren
id|sdev2-&gt;request_queue
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|sdev2-&gt;request_queue-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|shost-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
id|shost-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|q-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
id|__blk_run_queue
c_func
(paren
id|q
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|q-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_end_request()&n; *&n; * Purpose:     Post-processing of completed commands called from interrupt&n; *              handler or a bottom-half handler.&n; *&n; * Arguments:   cmd&t; - command that is complete.&n; *              uptodate - 1 if I/O indicates success, 0 for I/O error.&n; *              sectors  - number of sectors we want to mark.&n; *&t;&t;requeue  - indicates whether we should requeue leftovers.&n; *&t;&t;frequeue - indicates that if we release the command block&n; *&t;&t;&t;   that the queue request function should be called.&n; *&n; * Lock status: Assumed that lock is not held upon entry.&n; *&n; * Returns:     Nothing&n; *&n; * Notes:       This is called for block device requests in order to&n; *              mark some number of sectors as complete.&n; * &n; *&t;&t;We are guaranteeing that the request queue will be goosed&n; *&t;&t;at some point during this call.&n; */
DECL|function|scsi_end_request
r_static
r_struct
id|scsi_cmnd
op_star
id|scsi_end_request
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_int
id|uptodate
comma
r_int
id|sectors
comma
r_int
id|requeue
)paren
(brace
id|request_queue_t
op_star
id|q
op_assign
id|cmd-&gt;device-&gt;request_queue
suffix:semicolon
r_struct
id|request
op_star
id|req
op_assign
id|cmd-&gt;request
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * If there are blocks left over at the end, set up the command&n;&t; * to queue the remainder of them.&n;&t; */
r_if
c_cond
(paren
id|end_that_request_first
c_func
(paren
id|req
comma
id|uptodate
comma
id|sectors
)paren
)paren
(brace
r_if
c_cond
(paren
id|requeue
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Bleah.  Leftovers again.  Stick the leftovers in&n;&t;&t;&t; * the front of the queue, and goose the queue again.&n;&t;&t;&t; */
id|scsi_queue_next_request
c_func
(paren
id|q
comma
id|cmd
)paren
suffix:semicolon
)brace
r_return
id|cmd
suffix:semicolon
)brace
id|add_disk_randomness
c_func
(paren
id|req-&gt;rq_disk
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|q-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blk_rq_tagged
c_func
(paren
id|req
)paren
)paren
id|blk_queue_end_tag
c_func
(paren
id|q
comma
id|req
)paren
suffix:semicolon
id|end_that_request_last
c_func
(paren
id|req
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|q-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This will goose the queue request function at the end, so we don&squot;t&n;&t; * need to worry about launching another command.&n;&t; */
id|scsi_put_command
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|scsi_queue_next_request
c_func
(paren
id|q
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|scsi_alloc_sgtable
r_static
r_struct
id|scatterlist
op_star
id|scsi_alloc_sgtable
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_int
id|gfp_mask
)paren
(brace
r_struct
id|scsi_host_sg_pool
op_star
id|sgp
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sgl
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|cmd-&gt;use_sg
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd-&gt;use_sg
)paren
(brace
r_case
l_int|1
dot
dot
dot
l_int|8
suffix:colon
id|cmd-&gt;sglist_len
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9
dot
dot
dot
l_int|16
suffix:colon
id|cmd-&gt;sglist_len
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|17
dot
dot
dot
l_int|32
suffix:colon
id|cmd-&gt;sglist_len
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|33
dot
dot
dot
l_int|64
suffix:colon
id|cmd-&gt;sglist_len
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|65
dot
dot
dot
id|MAX_PHYS_SEGMENTS
suffix:colon
id|cmd-&gt;sglist_len
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
id|sgp
op_assign
id|scsi_sg_pools
op_plus
id|cmd-&gt;sglist_len
suffix:semicolon
id|sgl
op_assign
id|mempool_alloc
c_func
(paren
id|sgp-&gt;pool
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sgl
)paren
id|memset
c_func
(paren
id|sgl
comma
l_int|0
comma
id|sgp-&gt;size
)paren
suffix:semicolon
r_return
id|sgl
suffix:semicolon
)brace
DECL|function|scsi_free_sgtable
r_static
r_void
id|scsi_free_sgtable
c_func
(paren
r_struct
id|scatterlist
op_star
id|sgl
comma
r_int
id|index
)paren
(brace
r_struct
id|scsi_host_sg_pool
op_star
id|sgp
suffix:semicolon
id|BUG_ON
c_func
(paren
id|index
OG
id|SG_MEMPOOL_NR
)paren
suffix:semicolon
id|sgp
op_assign
id|scsi_sg_pools
op_plus
id|index
suffix:semicolon
id|mempool_free
c_func
(paren
id|sgl
comma
id|sgp-&gt;pool
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_release_buffers()&n; *&n; * Purpose:     Completion processing for block device I/O requests.&n; *&n; * Arguments:   cmd&t;- command that we are bailing.&n; *&n; * Lock status: Assumed that no lock is held upon entry.&n; *&n; * Returns:     Nothing&n; *&n; * Notes:       In the event that an upper level driver rejects a&n; *&t;&t;command, we must release resources allocated during&n; *&t;&t;the __init_io() function.  Primarily this would involve&n; *&t;&t;the scatter-gather table, and potentially any bounce&n; *&t;&t;buffers.&n; */
DECL|function|scsi_release_buffers
r_static
r_void
id|scsi_release_buffers
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|request
op_star
id|req
op_assign
id|cmd-&gt;request
suffix:semicolon
multiline_comment|/*&n;&t; * Free up any indirection buffers we allocated for DMA purposes. &n;&t; */
r_if
c_cond
(paren
id|cmd-&gt;use_sg
)paren
id|scsi_free_sgtable
c_func
(paren
id|cmd-&gt;request_buffer
comma
id|cmd-&gt;sglist_len
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cmd-&gt;request_buffer
op_ne
id|req-&gt;buffer
)paren
id|kfree
c_func
(paren
id|cmd-&gt;request_buffer
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Zero these out.  They now point to freed memory, and it is&n;&t; * dangerous to hang onto the pointers.&n;&t; */
id|cmd-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;bufflen
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;request_buffer
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;request_bufflen
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_get_request_dev()&n; *&n; * Purpose:     Find the upper-level driver that is responsible for this&n; *              request&n; *&n; * Arguments:   request   - I/O request we are preparing to queue.&n; *&n; * Lock status: No locks assumed to be held, but as it happens the&n; *              q-&gt;queue_lock is held when this is called.&n; *&n; * Returns:     Nothing&n; *&n; * Notes:       The requests in the request queue may have originated&n; *              from any block device driver.  We need to find out which&n; *              one so that we can later form the appropriate command.&n; */
DECL|function|scsi_get_request_dev
r_static
r_struct
id|Scsi_Device_Template
op_star
id|scsi_get_request_dev
c_func
(paren
r_struct
id|request
op_star
id|req
)paren
(brace
r_struct
id|gendisk
op_star
id|p
op_assign
id|req-&gt;rq_disk
suffix:semicolon
r_return
id|p
ques
c_cond
op_star
(paren
r_struct
id|Scsi_Device_Template
op_star
op_star
)paren
id|p-&gt;private_data
suffix:colon
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_io_completion()&n; *&n; * Purpose:     Completion processing for block device I/O requests.&n; *&n; * Arguments:   cmd   - command that is finished.&n; *&n; * Lock status: Assumed that no lock is held upon entry.&n; *&n; * Returns:     Nothing&n; *&n; * Notes:       This function is matched in terms of capabilities to&n; *              the function that created the scatter-gather list.&n; *              In other words, if there are no bounce buffers&n; *              (the normal case for most drivers), we don&squot;t need&n; *              the logic to deal with cleaning up afterwards.&n; */
DECL|function|scsi_io_completion
r_void
id|scsi_io_completion
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_int
id|good_sectors
comma
r_int
id|block_sectors
)paren
(brace
r_int
id|result
op_assign
id|cmd-&gt;result
suffix:semicolon
r_int
id|this_count
op_assign
id|cmd-&gt;bufflen
op_rshift
l_int|9
suffix:semicolon
id|request_queue_t
op_star
id|q
op_assign
id|cmd-&gt;device-&gt;request_queue
suffix:semicolon
r_struct
id|request
op_star
id|req
op_assign
id|cmd-&gt;request
suffix:semicolon
r_int
id|clear_errors
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * We must do one of several things here:&n;&t; *&n;&t; *&t;Call scsi_end_request.  This will finish off the specified&n;&t; *&t;number of sectors.  If we are done, the command block will&n;&t; *&t;be released, and the queue function will be goosed.  If we&n;&t; *&t;are not done, then scsi_end_request will directly goose&n;&t; *&t;the queue.&n;&t; *&n;&t; *&t;We can just use scsi_queue_next_request() here.  This&n;&t; *&t;would be used if we just wanted to retry, for example.&n;&t; *&n;&t; */
multiline_comment|/*&n;&t; * Free up any indirection buffers we allocated for DMA purposes. &n;&t; * For the case of a READ, we need to copy the data out of the&n;&t; * bounce buffer and into the real buffer.&n;&t; */
r_if
c_cond
(paren
id|cmd-&gt;use_sg
)paren
id|scsi_free_sgtable
c_func
(paren
id|cmd-&gt;buffer
comma
id|cmd-&gt;sglist_len
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cmd-&gt;buffer
op_ne
id|req-&gt;buffer
)paren
(brace
r_if
c_cond
(paren
id|rq_data_dir
c_func
(paren
id|req
)paren
op_eq
id|READ
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_char
op_star
id|to
op_assign
id|bio_kmap_irq
c_func
(paren
id|req-&gt;bio
comma
op_amp
id|flags
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|to
comma
id|cmd-&gt;buffer
comma
id|cmd-&gt;bufflen
)paren
suffix:semicolon
id|bio_kunmap_irq
c_func
(paren
id|to
comma
op_amp
id|flags
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|cmd-&gt;buffer
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|blk_pc_request
c_func
(paren
id|req
)paren
)paren
(brace
multiline_comment|/* SG_IO ioctl from block level */
id|req-&gt;errors
op_assign
(paren
id|driver_byte
c_func
(paren
id|result
)paren
op_amp
id|DRIVER_SENSE
)paren
ques
c_cond
(paren
id|CHECK_CONDITION
op_lshift
l_int|1
)paren
suffix:colon
(paren
id|result
op_amp
l_int|0xff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
id|clear_errors
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;sense_buffer
(braket
l_int|0
)braket
op_amp
l_int|0x70
)paren
(brace
r_int
id|len
op_assign
l_int|8
op_plus
id|cmd-&gt;sense_buffer
(braket
l_int|7
)braket
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|SCSI_SENSE_BUFFERSIZE
)paren
id|len
op_assign
id|SCSI_SENSE_BUFFERSIZE
suffix:semicolon
id|memcpy
c_func
(paren
id|req-&gt;sense
comma
id|cmd-&gt;sense_buffer
comma
id|len
)paren
suffix:semicolon
id|req-&gt;sense_len
op_assign
id|len
suffix:semicolon
)brace
)brace
r_else
id|req-&gt;data_len
op_sub_assign
id|cmd-&gt;bufflen
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Zero these out.  They now point to freed memory, and it is&n;&t; * dangerous to hang onto the pointers.&n;&t; */
id|cmd-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;bufflen
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;request_buffer
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;request_bufflen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Next deal with any sectors which we were able to correctly&n;&t; * handle.&n;&t; */
r_if
c_cond
(paren
id|good_sectors
op_ge
l_int|0
)paren
(brace
id|SCSI_LOG_HLCOMPLETE
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;%ld sectors total, %d sectors done.&bslash;n&quot;
comma
id|req-&gt;nr_sectors
comma
id|good_sectors
)paren
)paren
suffix:semicolon
id|SCSI_LOG_HLCOMPLETE
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;use_sg is %d&bslash;n &quot;
comma
id|cmd-&gt;use_sg
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clear_errors
)paren
id|req-&gt;errors
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If multiple sectors are requested in one buffer, then&n;&t;&t; * they will have been finished off by the first command.&n;&t;&t; * If not, then we have a multi-buffer command.&n;&t;&t; *&n;&t;&t; * If block_sectors != 0, it means we had a medium error&n;&t;&t; * of some sort, and that we want to mark some number of&n;&t;&t; * sectors as not uptodate.  Thus we want to inhibit&n;&t;&t; * requeueing right here - we will requeue down below&n;&t;&t; * when we handle the bad sectors.&n;&t;&t; */
id|cmd
op_assign
id|scsi_end_request
c_func
(paren
id|cmd
comma
l_int|1
comma
id|good_sectors
comma
id|result
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the command completed without error, then either finish off the&n;&t;&t; * rest of the command, or start a new one.&n;&t;&t; */
r_if
c_cond
(paren
id|result
op_eq
l_int|0
op_logical_or
id|cmd
op_eq
l_int|NULL
)paren
(brace
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Now, if we were good little boys and girls, Santa left us a request&n;&t; * sense buffer.  We can extract information from this, so we&n;&t; * can choose a block to remap, etc.&n;&t; */
r_if
c_cond
(paren
id|driver_byte
c_func
(paren
id|result
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|suggestion
c_func
(paren
id|result
)paren
op_eq
id|SUGGEST_REMAP
)paren
(brace
macro_line|#ifdef REMAP
multiline_comment|/*&n;&t;&t;&t; * Not yet implemented.  A read will fail after being remapped,&n;&t;&t;&t; * a write will call the strategy routine again.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|cmd-&gt;device-&gt;remap
)paren
(brace
id|result
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
)brace
r_if
c_cond
(paren
(paren
id|cmd-&gt;sense_buffer
(braket
l_int|0
)braket
op_amp
l_int|0x7f
)paren
op_eq
l_int|0x70
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If the device is in the process of becoming ready,&n;&t;&t;&t; * retry.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|cmd-&gt;sense_buffer
(braket
l_int|12
)braket
op_eq
l_int|0x04
op_logical_and
id|cmd-&gt;sense_buffer
(braket
l_int|13
)braket
op_eq
l_int|0x01
)paren
(brace
id|scsi_queue_next_request
c_func
(paren
id|q
comma
id|cmd
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|cmd-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_eq
id|UNIT_ATTENTION
)paren
(brace
r_if
c_cond
(paren
id|cmd-&gt;device-&gt;removable
)paren
(brace
multiline_comment|/* detected disc change.  set a bit &n;&t;&t;&t;&t;&t; * and quietly refuse further access.&n;&t;&t; &t;&t;&t; */
id|cmd-&gt;device-&gt;changed
op_assign
l_int|1
suffix:semicolon
id|cmd
op_assign
id|scsi_end_request
c_func
(paren
id|cmd
comma
l_int|0
comma
id|this_count
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; &t;* Must have been a power glitch, or a&n;&t;&t;&t;&t; &t;* bus reset.  Could not have been a&n;&t;&t;&t;&t; &t;* media change, so we just retry the&n;&t;&t;&t;&t; &t;* request and see what happens.  &n;&t;&t;&t;&t; &t;*/
id|scsi_queue_next_request
c_func
(paren
id|q
comma
id|cmd
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* If we had an ILLEGAL REQUEST returned, then we may have&n;&t;&t; * performed an unsupported command.  The only thing this should be&n;&t;&t; * would be a ten byte read where only a six byte read was supported.&n;&t;&t; * Also, on a system where READ CAPACITY failed, we have have read&n;&t;&t; * past the end of the disk.&n;&t;&t; */
r_switch
c_cond
(paren
id|cmd-&gt;sense_buffer
(braket
l_int|2
)braket
)paren
(brace
r_case
id|ILLEGAL_REQUEST
suffix:colon
r_if
c_cond
(paren
id|cmd-&gt;device-&gt;ten
)paren
(brace
id|cmd-&gt;device-&gt;ten
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * This will cause a retry with a 6-byte&n;&t;&t;&t;&t; * command.&n;&t;&t;&t;&t; */
id|scsi_queue_next_request
c_func
(paren
id|q
comma
id|cmd
)paren
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|cmd
op_assign
id|scsi_end_request
c_func
(paren
id|cmd
comma
l_int|0
comma
id|this_count
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|NOT_READY
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Device %s not ready.&bslash;n&quot;
comma
id|req-&gt;rq_disk
ques
c_cond
id|req-&gt;rq_disk-&gt;disk_name
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|cmd
op_assign
id|scsi_end_request
c_func
(paren
id|cmd
comma
l_int|0
comma
id|this_count
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MEDIUM_ERROR
suffix:colon
r_case
id|VOLUME_OVERFLOW
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d: ERROR on channel %d, id %d, lun %d, CDB: &quot;
comma
id|cmd-&gt;device-&gt;host-&gt;host_no
comma
(paren
r_int
)paren
id|cmd-&gt;device-&gt;channel
comma
(paren
r_int
)paren
id|cmd-&gt;device-&gt;id
comma
(paren
r_int
)paren
id|cmd-&gt;device-&gt;lun
)paren
suffix:semicolon
id|print_command
c_func
(paren
id|cmd-&gt;data_cmnd
)paren
suffix:semicolon
id|print_sense
c_func
(paren
l_string|&quot;sd&quot;
comma
id|cmd
)paren
suffix:semicolon
id|cmd
op_assign
id|scsi_end_request
c_func
(paren
id|cmd
comma
l_int|0
comma
id|block_sectors
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* driver byte != 0 */
r_if
c_cond
(paren
id|host_byte
c_func
(paren
id|result
)paren
op_eq
id|DID_RESET
)paren
(brace
multiline_comment|/*&n;&t;&t; * Third party bus reset or reset for error&n;&t;&t; * recovery reasons.  Just retry the request&n;&t;&t; * and see what happens.  &n;&t;&t; */
id|scsi_queue_next_request
c_func
(paren
id|q
comma
id|cmd
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
)paren
(brace
r_struct
id|Scsi_Device_Template
op_star
id|sdt
suffix:semicolon
id|sdt
op_assign
id|scsi_get_request_dev
c_func
(paren
id|cmd-&gt;request
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SCSI %s error : host %d channel %d id %d lun %d return code = %x&bslash;n&quot;
comma
(paren
id|sdt
ques
c_cond
id|sdt-&gt;name
suffix:colon
l_string|&quot;device&quot;
)paren
comma
id|cmd-&gt;device-&gt;host-&gt;host_no
comma
id|cmd-&gt;device-&gt;channel
comma
id|cmd-&gt;device-&gt;id
comma
id|cmd-&gt;device-&gt;lun
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver_byte
c_func
(paren
id|result
)paren
op_amp
id|DRIVER_SENSE
)paren
id|print_sense
c_func
(paren
l_string|&quot;sd&quot;
comma
id|cmd
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Mark a single buffer as not uptodate.  Queue the remainder.&n;&t;&t; * We sometimes get this cruft in the event that a medium error&n;&t;&t; * isn&squot;t properly reported.&n;&t;&t; */
id|cmd
op_assign
id|scsi_end_request
c_func
(paren
id|cmd
comma
l_int|0
comma
id|req-&gt;current_nr_sectors
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function:    scsi_init_io()&n; *&n; * Purpose:     SCSI I/O initialize function.&n; *&n; * Arguments:   cmd   - Command descriptor we wish to initialize&n; *&n; * Returns:     0 on success&n; *&t;&t;BLKPREP_DEFER if the failure is retryable&n; *&t;&t;BLKPREP_KILL if the failure is fatal&n; */
DECL|function|scsi_init_io
r_static
r_int
id|scsi_init_io
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|request
op_star
id|req
op_assign
id|cmd-&gt;request
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sgpnt
suffix:semicolon
r_int
id|count
suffix:semicolon
multiline_comment|/*&n;&t; * if this is a rq-&gt;data based REQ_BLOCK_PC, setup for a non-sg xfer&n;&t; */
r_if
c_cond
(paren
(paren
id|req-&gt;flags
op_amp
id|REQ_BLOCK_PC
)paren
op_logical_and
op_logical_neg
id|req-&gt;bio
)paren
(brace
id|cmd-&gt;request_bufflen
op_assign
id|req-&gt;data_len
suffix:semicolon
id|cmd-&gt;request_buffer
op_assign
id|req-&gt;data
suffix:semicolon
id|req-&gt;buffer
op_assign
id|req-&gt;data
suffix:semicolon
id|cmd-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we used to not use scatter-gather for single segment request,&n;&t; * but now we do (it makes highmem I/O easier to support without&n;&t; * kmapping pages)&n;&t; */
id|cmd-&gt;use_sg
op_assign
id|req-&gt;nr_phys_segments
suffix:semicolon
multiline_comment|/*&n;&t; * if sg table allocation fails, requeue request later.&n;&t; */
id|sgpnt
op_assign
id|scsi_alloc_sgtable
c_func
(paren
id|cmd
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|sgpnt
)paren
)paren
(brace
id|req-&gt;flags
op_or_assign
id|REQ_SPECIAL
suffix:semicolon
r_return
id|BLKPREP_DEFER
suffix:semicolon
)brace
id|cmd-&gt;request_buffer
op_assign
(paren
r_char
op_star
)paren
id|sgpnt
suffix:semicolon
id|cmd-&gt;request_bufflen
op_assign
id|req-&gt;nr_sectors
op_lshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
id|blk_pc_request
c_func
(paren
id|req
)paren
)paren
id|cmd-&gt;request_bufflen
op_assign
id|req-&gt;data_len
suffix:semicolon
id|req-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* &n;&t; * Next, walk the list, and fill in the addresses and sizes of&n;&t; * each segment.&n;&t; */
id|count
op_assign
id|blk_rq_map_sg
c_func
(paren
id|req-&gt;q
comma
id|req
comma
id|cmd-&gt;request_buffer
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * mapped well, send it off&n;&t; */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|count
op_le
id|cmd-&gt;use_sg
)paren
)paren
(brace
id|cmd-&gt;use_sg
op_assign
id|count
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Incorrect number of segments after building list&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;counted %d, received %d&bslash;n&quot;
comma
id|count
comma
id|cmd-&gt;use_sg
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;req nr_sec %lu, cur_nr_sec %u&bslash;n&quot;
comma
id|req-&gt;nr_sectors
comma
id|req-&gt;current_nr_sectors
)paren
suffix:semicolon
multiline_comment|/* release the command and kill it */
id|scsi_put_command
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
id|BLKPREP_KILL
suffix:semicolon
)brace
DECL|function|scsi_prep_fn
r_static
r_int
id|scsi_prep_fn
c_func
(paren
r_struct
id|request_queue
op_star
id|q
comma
r_struct
id|request
op_star
id|req
)paren
(brace
r_struct
id|Scsi_Device_Template
op_star
id|sdt
suffix:semicolon
r_struct
id|scsi_device
op_star
id|sdev
op_assign
id|q-&gt;queuedata
suffix:semicolon
r_struct
id|scsi_cmnd
op_star
id|cmd
suffix:semicolon
multiline_comment|/*&n;&t; * Find the actual device driver associated with this command.&n;&t; * The SPECIAL requests are things like character device or&n;&t; * ioctls, which did not originate from ll_rw_blk.  Note that&n;&t; * the special field is also used to indicate the cmd for&n;&t; * the remainder of a partially fulfilled request that can &n;&t; * come up when there is a medium error.  We have to treat&n;&t; * these two cases differently.  We differentiate by looking&n;&t; * at request-&gt;cmd, as this tells us the real story.&n;&t; */
r_if
c_cond
(paren
id|req-&gt;flags
op_amp
id|REQ_SPECIAL
)paren
(brace
r_struct
id|scsi_request
op_star
id|sreq
op_assign
id|req-&gt;special
suffix:semicolon
r_if
c_cond
(paren
id|sreq-&gt;sr_magic
op_eq
id|SCSI_REQ_MAGIC
)paren
(brace
id|cmd
op_assign
id|scsi_get_command
c_func
(paren
id|sreq-&gt;sr_device
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|cmd
)paren
)paren
r_return
id|BLKPREP_DEFER
suffix:semicolon
id|scsi_init_cmd_from_req
c_func
(paren
id|cmd
comma
id|sreq
)paren
suffix:semicolon
)brace
r_else
id|cmd
op_assign
id|req-&gt;special
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|req-&gt;flags
op_amp
(paren
id|REQ_CMD
op_or
id|REQ_BLOCK_PC
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Now try and find a command block that we can use.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|req-&gt;special
)paren
(brace
id|cmd
op_assign
id|scsi_get_command
c_func
(paren
id|sdev
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|cmd
)paren
)paren
r_return
id|BLKPREP_DEFER
suffix:semicolon
)brace
r_else
id|cmd
op_assign
id|req-&gt;special
suffix:semicolon
multiline_comment|/* pull a tag out of the request if we have one */
id|cmd-&gt;tag
op_assign
id|req-&gt;tag
suffix:semicolon
)brace
r_else
(brace
id|blk_dump_rq_flags
c_func
(paren
id|req
comma
l_string|&quot;SCSI bad req&quot;
)paren
suffix:semicolon
r_return
id|BLKPREP_KILL
suffix:semicolon
)brace
multiline_comment|/* note the overloading of req-&gt;special.  When the tag&n;&t; * is active it always means cmd.  If the tag goes&n;&t; * back for re-queueing, it may be reset */
id|req-&gt;special
op_assign
id|cmd
suffix:semicolon
id|cmd-&gt;request
op_assign
id|req
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME: drop the lock here because the functions below&n;&t; * expect to be called without the queue lock held.  Also,&n;&t; * previously, we dequeued the request before dropping the&n;&t; * lock.  We hope REQ_STARTED prevents anything untoward from&n;&t; * happening now.&n;&t; */
r_if
c_cond
(paren
id|req-&gt;flags
op_amp
(paren
id|REQ_CMD
op_or
id|REQ_BLOCK_PC
)paren
)paren
(brace
r_int
id|ret
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This will do a couple of things:&n;&t;&t; *  1) Fill in the actual SCSI command.&n;&t;&t; *  2) Fill in any other upper-level specific fields&n;&t;&t; * (timeout).&n;&t;&t; *&n;&t;&t; * If this returns 0, it means that the request failed&n;&t;&t; * (reading past end of disk, reading offline device,&n;&t;&t; * etc).   This won&squot;t actually talk to the device, but&n;&t;&t; * some kinds of consistency checking may cause the&t;&n;&t;&t; * request to be rejected immediately.&n;&t;&t; */
id|sdt
op_assign
id|scsi_get_request_dev
c_func
(paren
id|req
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|sdt
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * This sets up the scatter-gather table (allocating if&n;&t;&t; * required).&n;&t;&t; */
id|ret
op_assign
id|scsi_init_io
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
multiline_comment|/* BLKPREP_KILL return also releases the command */
r_return
id|ret
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Initialize the actual SCSI command for this request.&n;&t;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|sdt
op_member_access_from_pointer
id|init_command
c_func
(paren
id|cmd
)paren
)paren
)paren
(brace
id|scsi_release_buffers
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|scsi_put_command
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
id|BLKPREP_KILL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * The request is now prepped, no need to come back here&n;&t; */
id|req-&gt;flags
op_or_assign
id|REQ_DONTPREP
suffix:semicolon
r_return
id|BLKPREP_OK
suffix:semicolon
)brace
multiline_comment|/*&n; * scsi_check_sdev: if we can send requests to sdev, return 0 else return 1.&n; *&n; * Called with the queue_lock held.&n; */
DECL|function|scsi_check_sdev
r_static
r_inline
r_int
id|scsi_check_sdev
c_func
(paren
r_struct
id|request_queue
op_star
id|q
comma
r_struct
id|scsi_device
op_star
id|sdev
)paren
(brace
r_if
c_cond
(paren
id|sdev-&gt;device_busy
op_ge
id|sdev-&gt;queue_depth
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;device_busy
op_eq
l_int|0
op_logical_and
id|sdev-&gt;device_blocked
)paren
(brace
multiline_comment|/*&n;&t;&t; * unblock after device_blocked iterates to zero&n;&t;&t; */
r_if
c_cond
(paren
op_decrement
id|sdev-&gt;device_blocked
op_eq
l_int|0
)paren
(brace
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi%d (%d:%d) unblocking device at&quot;
l_string|&quot; zero depth&bslash;n&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|blk_plug_device
c_func
(paren
id|q
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|sdev-&gt;device_blocked
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * scsi_check_shost: if we can send requests to shost, return 0 else return 1.&n; *&n; * Called with queue_lock and host_lock held.&n; */
DECL|function|scsi_check_shost
r_static
r_inline
r_int
id|scsi_check_shost
c_func
(paren
r_struct
id|request_queue
op_star
id|q
comma
r_struct
id|Scsi_Host
op_star
id|shost
comma
r_struct
id|scsi_device
op_star
id|sdev
)paren
(brace
r_if
c_cond
(paren
id|shost-&gt;in_recovery
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|shost-&gt;host_busy
op_eq
l_int|0
op_logical_and
id|shost-&gt;host_blocked
)paren
(brace
multiline_comment|/*&n;&t;&t; * unblock after host_blocked iterates to zero&n;&t;&t; */
r_if
c_cond
(paren
op_decrement
id|shost-&gt;host_blocked
op_eq
l_int|0
)paren
(brace
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi%d unblocking host at zero depth&bslash;n&quot;
comma
id|shost-&gt;host_no
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|blk_plug_device
c_func
(paren
id|q
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|sdev-&gt;starved_entry
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|shost-&gt;can_queue
OG
l_int|0
op_logical_and
id|shost-&gt;host_busy
op_ge
id|shost-&gt;can_queue
)paren
op_logical_or
id|shost-&gt;host_blocked
op_logical_or
id|shost-&gt;host_self_blocked
)paren
(brace
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;add starved dev &lt;%d,%d,%d,%d&gt;; host &quot;
l_string|&quot;limit %d, busy %d, blocked %d selfblocked %d&bslash;n&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
comma
id|shost-&gt;can_queue
comma
id|shost-&gt;host_busy
comma
id|shost-&gt;host_blocked
comma
id|shost-&gt;host_self_blocked
)paren
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|sdev-&gt;starved_entry
comma
op_amp
id|shost-&gt;starved_list
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_request_fn()&n; *&n; * Purpose:     Main strategy routine for SCSI.&n; *&n; * Arguments:   q       - Pointer to actual queue.&n; *&n; * Returns:     Nothing&n; *&n; * Lock status: IO request lock assumed to be held when called.&n; */
DECL|function|scsi_request_fn
r_static
r_void
id|scsi_request_fn
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
op_assign
id|q-&gt;queuedata
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shost
op_assign
id|sdev-&gt;host
suffix:semicolon
r_struct
id|scsi_cmnd
op_star
id|cmd
suffix:semicolon
r_struct
id|request
op_star
id|req
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * To start with, we keep looping until the queue is empty, or until&n;&t; * the host is no longer able to accept any more requests.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|blk_queue_plugged
c_func
(paren
id|q
)paren
)paren
r_goto
id|completed
suffix:semicolon
multiline_comment|/*&n;&t;&t; * get next queueable request.  We do this early to make sure&n;&t;&t; * that the request is fully prepared even if we cannot &n;&t;&t; * accept it.  If there is no request, we&squot;ll detect this&n;&t;&t; * lower down.&n;&t;&t; */
id|req
op_assign
id|elv_next_request
c_func
(paren
id|q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scsi_check_sdev
c_func
(paren
id|q
comma
id|sdev
)paren
)paren
r_goto
id|completed
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|shost-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scsi_check_shost
c_func
(paren
id|q
comma
id|shost
comma
id|sdev
)paren
)paren
r_goto
id|after_host_lock
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;single_lun
op_logical_and
id|scsi_single_lun_check
c_func
(paren
id|sdev
)paren
)paren
r_goto
id|after_host_lock
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we couldn&squot;t find a request that could be queued, then we&n;&t;&t; * can also quit.&n;&t;&t; */
r_if
c_cond
(paren
id|blk_queue_empty
c_func
(paren
id|q
)paren
)paren
r_goto
id|after_host_lock
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|req
)paren
(brace
multiline_comment|/* If the device is busy, a returning I/O&n;&t;&t;&t; * will restart the queue.  Otherwise, we have&n;&t;&t;&t; * to plug the queue */
r_if
c_cond
(paren
id|sdev-&gt;device_busy
op_eq
l_int|1
)paren
id|blk_plug_device
c_func
(paren
id|q
)paren
suffix:semicolon
r_goto
id|after_host_lock
suffix:semicolon
)brace
id|cmd
op_assign
id|req-&gt;special
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Should be impossible for a correctly prepared request&n;&t;&t; * please mail the stack trace to linux-scsi@vger.kernel.org&n;&t;&t; */
id|BUG_ON
c_func
(paren
op_logical_neg
id|cmd
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Finally, before we release the lock, we copy the&n;&t;&t; * request to the command block, and remove the&n;&t;&t; * request from the request list.  Note that we always&n;&t;&t; * operate on the queue head - there is absolutely no&n;&t;&t; * reason to search the list, because all of the&n;&t;&t; * commands in this queue are for the same device.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|blk_queue_tagged
c_func
(paren
id|q
)paren
op_logical_and
(paren
id|blk_queue_start_tag
c_func
(paren
id|q
comma
id|req
)paren
op_eq
l_int|0
)paren
)paren
)paren
id|blkdev_dequeue_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|shost-&gt;host_busy
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|shost-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|sdev-&gt;device_busy
op_increment
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
id|q-&gt;queue_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Finally, initialize any error handling parameters, and set up&n;&t;&t; * the timers for timeouts.&n;&t;&t; */
id|scsi_init_cmd_errh
c_func
(paren
id|cmd
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Dispatch the command to the low-level driver.&n;&t;&t; */
id|scsi_dispatch_cmd
c_func
(paren
id|cmd
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Now we need to grab the lock again.  We are about to mess&n;&t;&t; * with the request queue and try to find another command.&n;&t;&t; */
id|spin_lock_irq
c_func
(paren
id|q-&gt;queue_lock
)paren
suffix:semicolon
)brace
id|completed
suffix:colon
r_return
suffix:semicolon
id|after_host_lock
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
id|shost-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|scsi_calculate_bounce_limit
id|u64
id|scsi_calculate_bounce_limit
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
)paren
(brace
r_if
c_cond
(paren
id|shost-&gt;highmem_io
)paren
(brace
r_struct
id|device
op_star
id|host_dev
op_assign
id|scsi_get_device
c_func
(paren
id|shost
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PCI_DMA_BUS_IS_PHYS
op_logical_and
id|host_dev
op_logical_and
id|host_dev-&gt;dma_mask
)paren
r_return
op_star
id|host_dev-&gt;dma_mask
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Platforms with virtual-DMA translation&n; &t;&t; * hardware have no practical limit.&n;&t;&t; */
r_return
id|BLK_BOUNCE_ANY
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|shost-&gt;unchecked_isa_dma
)paren
r_return
id|BLK_BOUNCE_ISA
suffix:semicolon
r_return
id|BLK_BOUNCE_HIGH
suffix:semicolon
)brace
DECL|function|scsi_alloc_queue
id|request_queue_t
op_star
id|scsi_alloc_queue
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
)paren
(brace
id|request_queue_t
op_star
id|q
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shost
suffix:semicolon
id|q
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|q
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|q
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|q
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * XXX move host code to scsi_register&n;&t; */
id|shost
op_assign
id|sdev-&gt;host
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|shost-&gt;max_sectors
)paren
(brace
multiline_comment|/*&n;&t;&t; * Driver imposes no hard sector transfer limit.&n;&t;&t; * start at machine infinity initially.&n;&t;&t; */
id|shost-&gt;max_sectors
op_assign
id|SCSI_DEFAULT_MAX_SECTORS
suffix:semicolon
)brace
id|blk_init_queue
c_func
(paren
id|q
comma
id|scsi_request_fn
comma
op_amp
id|sdev-&gt;sdev_lock
)paren
suffix:semicolon
id|blk_queue_prep_rq
c_func
(paren
id|q
comma
id|scsi_prep_fn
)paren
suffix:semicolon
id|blk_queue_max_hw_segments
c_func
(paren
id|q
comma
id|shost-&gt;sg_tablesize
)paren
suffix:semicolon
id|blk_queue_max_phys_segments
c_func
(paren
id|q
comma
id|MAX_PHYS_SEGMENTS
)paren
suffix:semicolon
id|blk_queue_max_sectors
c_func
(paren
id|q
comma
id|shost-&gt;max_sectors
)paren
suffix:semicolon
id|blk_queue_bounce_limit
c_func
(paren
id|q
comma
id|scsi_calculate_bounce_limit
c_func
(paren
id|shost
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|shost-&gt;use_clustering
)paren
id|clear_bit
c_func
(paren
id|QUEUE_FLAG_CLUSTER
comma
op_amp
id|q-&gt;queue_flags
)paren
suffix:semicolon
r_return
id|q
suffix:semicolon
)brace
DECL|function|scsi_free_queue
r_void
id|scsi_free_queue
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
id|blk_cleanup_queue
c_func
(paren
id|q
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|q
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_block_requests()&n; *&n; * Purpose:     Utility function used by low-level drivers to prevent further&n; *&t;&t;commands from being queued to the device.&n; *&n; * Arguments:   shost       - Host in question&n; *&n; * Returns:     Nothing&n; *&n; * Lock status: No locks are assumed held.&n; *&n; * Notes:       There is no timer nor any other means by which the requests&n; *&t;&t;get unblocked other than the low-level driver calling&n; *&t;&t;scsi_unblock_requests().&n; */
DECL|function|scsi_block_requests
r_void
id|scsi_block_requests
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
)paren
(brace
id|shost-&gt;host_self_blocked
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_unblock_requests()&n; *&n; * Purpose:     Utility function used by low-level drivers to allow further&n; *&t;&t;commands from being queued to the device.&n; *&n; * Arguments:   shost       - Host in question&n; *&n; * Returns:     Nothing&n; *&n; * Lock status: No locks are assumed held.&n; *&n; * Notes:       There is no timer nor any other means by which the requests&n; *&t;&t;get unblocked other than the low-level driver calling&n; *&t;&t;scsi_unblock_requests().&n; *&n; *&t;&t;This is done as an API function so that changes to the&n; *&t;&t;internals of the scsi mid-layer won&squot;t require wholesale&n; *&t;&t;changes to drivers that use this feature.&n; */
DECL|function|scsi_unblock_requests
r_void
id|scsi_unblock_requests
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
id|shost-&gt;host_self_blocked
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Now that we are unblocked, try to start the queues.&n;&t; */
id|list_for_each_entry
c_func
(paren
id|sdev
comma
op_amp
id|shost-&gt;my_devices
comma
id|siblings
)paren
id|scsi_queue_next_request
c_func
(paren
id|sdev-&gt;request_queue
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_report_bus_reset()&n; *&n; * Purpose:     Utility function used by low-level drivers to report that&n; *&t;&t;they have observed a bus reset on the bus being handled.&n; *&n; * Arguments:   shost       - Host in question&n; *&t;&t;channel     - channel on which reset was observed.&n; *&n; * Returns:     Nothing&n; *&n; * Lock status: No locks are assumed held.&n; *&n; * Notes:       This only needs to be called if the reset is one which&n; *&t;&t;originates from an unknown location.  Resets originated&n; *&t;&t;by the mid-level itself don&squot;t need to call this, but there&n; *&t;&t;should be no harm.&n; *&n; *&t;&t;The main purpose of this is to make sure that a CHECK_CONDITION&n; *&t;&t;is properly treated.&n; */
DECL|function|scsi_report_bus_reset
r_void
id|scsi_report_bus_reset
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
comma
r_int
id|channel
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|sdev
comma
op_amp
id|shost-&gt;my_devices
comma
id|siblings
)paren
(brace
r_if
c_cond
(paren
id|channel
op_eq
id|sdev-&gt;channel
)paren
(brace
id|sdev-&gt;was_reset
op_assign
l_int|1
suffix:semicolon
id|sdev-&gt;expecting_cc_ua
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
DECL|function|scsi_init_queue
r_int
id|__init
id|scsi_init_queue
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SG_MEMPOOL_NR
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|scsi_host_sg_pool
op_star
id|sgp
op_assign
id|scsi_sg_pools
op_plus
id|i
suffix:semicolon
r_int
id|size
op_assign
id|sgp-&gt;size
op_star
r_sizeof
(paren
r_struct
id|scatterlist
)paren
suffix:semicolon
id|sgp-&gt;slab
op_assign
id|kmem_cache_create
c_func
(paren
id|sgp-&gt;name
comma
id|size
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sgp-&gt;slab
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;SCSI: can&squot;t init sg slab %s&bslash;n&quot;
comma
id|sgp-&gt;name
)paren
suffix:semicolon
)brace
id|sgp-&gt;pool
op_assign
id|mempool_create
c_func
(paren
id|SG_MEMPOOL_SIZE
comma
id|mempool_alloc_slab
comma
id|mempool_free_slab
comma
id|sgp-&gt;slab
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sgp-&gt;pool
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;SCSI: can&squot;t init sg mempool %s&bslash;n&quot;
comma
id|sgp-&gt;name
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|scsi_exit_queue
r_void
id|scsi_exit_queue
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SG_MEMPOOL_NR
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|scsi_host_sg_pool
op_star
id|sgp
op_assign
id|scsi_sg_pools
op_plus
id|i
suffix:semicolon
id|mempool_destroy
c_func
(paren
id|sgp-&gt;pool
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|sgp-&gt;slab
)paren
suffix:semicolon
)brace
)brace
eof
