multiline_comment|/*&n; *  scsi_lib.c Copyright (C) 1999 Eric Youngdale&n; *&n; *  SCSI queueing library.&n; *      Initial versions: Eric Youngdale (eric@andante.org).&n; *                        Based upon conversations with large numbers&n; *                        of people at Linux Expo.&n; */
macro_line|#include &lt;linux/bio.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/completion.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mempool.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;scsi/scsi.h&gt;
macro_line|#include &lt;scsi/scsi_dbg.h&gt;
macro_line|#include &lt;scsi/scsi_device.h&gt;
macro_line|#include &lt;scsi/scsi_driver.h&gt;
macro_line|#include &lt;scsi/scsi_eh.h&gt;
macro_line|#include &lt;scsi/scsi_host.h&gt;
macro_line|#include &lt;scsi/scsi_request.h&gt;
macro_line|#include &quot;scsi_priv.h&quot;
macro_line|#include &quot;scsi_logging.h&quot;
DECL|macro|SG_MEMPOOL_NR
mdefine_line|#define SG_MEMPOOL_NR&t;&t;(sizeof(scsi_sg_pools)/sizeof(struct scsi_host_sg_pool))
DECL|macro|SG_MEMPOOL_SIZE
mdefine_line|#define SG_MEMPOOL_SIZE&t;&t;32
DECL|struct|scsi_host_sg_pool
r_struct
id|scsi_host_sg_pool
(brace
DECL|member|size
r_int
id|size
suffix:semicolon
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|slab
id|kmem_cache_t
op_star
id|slab
suffix:semicolon
DECL|member|pool
id|mempool_t
op_star
id|pool
suffix:semicolon
)brace
suffix:semicolon
macro_line|#if (SCSI_MAX_PHYS_SEGMENTS &lt; 32)
macro_line|#error SCSI_MAX_PHYS_SEGMENTS is too small
macro_line|#endif
DECL|macro|SP
mdefine_line|#define SP(x) { x, &quot;sgpool-&quot; #x } 
DECL|variable|scsi_sg_pools
r_struct
id|scsi_host_sg_pool
id|scsi_sg_pools
(braket
)braket
op_assign
(brace
id|SP
c_func
(paren
l_int|8
)paren
comma
id|SP
c_func
(paren
l_int|16
)paren
comma
id|SP
c_func
(paren
l_int|32
)paren
comma
macro_line|#if (SCSI_MAX_PHYS_SEGMENTS &gt; 32)
id|SP
c_func
(paren
l_int|64
)paren
comma
macro_line|#if (SCSI_MAX_PHYS_SEGMENTS &gt; 64)
id|SP
c_func
(paren
l_int|128
)paren
comma
macro_line|#if (SCSI_MAX_PHYS_SEGMENTS &gt; 128)
id|SP
c_func
(paren
l_int|256
)paren
comma
macro_line|#if (SCSI_MAX_PHYS_SEGMENTS &gt; 256)
macro_line|#error SCSI_MAX_PHYS_SEGMENTS is too large
macro_line|#endif
macro_line|#endif
macro_line|#endif
macro_line|#endif
)brace
suffix:semicolon
DECL|macro|SP
macro_line|#undef SP
multiline_comment|/*&n; * Function:    scsi_insert_special_req()&n; *&n; * Purpose:     Insert pre-formed request into request queue.&n; *&n; * Arguments:   sreq&t;- request that is ready to be queued.&n; *              at_head&t;- boolean.  True if we should insert at head&n; *                        of queue, false if we should insert at tail.&n; *&n; * Lock status: Assumed that lock is not held upon entry.&n; *&n; * Returns:     Nothing&n; *&n; * Notes:       This function is called from character device and from&n; *              ioctl types of functions where the caller knows exactly&n; *              what SCSI command needs to be issued.   The idea is that&n; *              we merely inject the command into the queue (at the head&n; *              for now), and then call the queue request function to actually&n; *              process it.&n; */
DECL|function|scsi_insert_special_req
r_int
id|scsi_insert_special_req
c_func
(paren
r_struct
id|scsi_request
op_star
id|sreq
comma
r_int
id|at_head
)paren
(brace
multiline_comment|/*&n;&t; * Because users of this function are apt to reuse requests with no&n;&t; * modification, we have to sanitise the request flags here&n;&t; */
id|sreq-&gt;sr_request-&gt;flags
op_and_assign
op_complement
id|REQ_DONTPREP
suffix:semicolon
id|blk_insert_request
c_func
(paren
id|sreq-&gt;sr_device-&gt;request_queue
comma
id|sreq-&gt;sr_request
comma
id|at_head
comma
id|sreq
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_queue_insert()&n; *&n; * Purpose:     Insert a command in the midlevel queue.&n; *&n; * Arguments:   cmd    - command that we are adding to queue.&n; *              reason - why we are inserting command to queue.&n; *&n; * Lock status: Assumed that lock is not held upon entry.&n; *&n; * Returns:     Nothing.&n; *&n; * Notes:       We do this for one of two cases.  Either the host is busy&n; *              and it cannot accept any more commands for the time being,&n; *              or the device returned QUEUE_FULL and can accept no more&n; *              commands.&n; * Notes:       This could be called either from an interrupt context or a&n; *              normal process context.&n; */
DECL|function|scsi_queue_insert
r_int
id|scsi_queue_insert
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_int
id|reason
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|cmd-&gt;device-&gt;host
suffix:semicolon
r_struct
id|scsi_device
op_star
id|device
op_assign
id|cmd-&gt;device
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;Inserting command %p into mlqueue&bslash;n&quot;
comma
id|cmd
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We are inserting the command into the ml queue.  First, we&n;&t; * cancel the timer, so it doesn&squot;t time out.&n;&t; */
id|scsi_delete_timer
c_func
(paren
id|cmd
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Next, set the appropriate busy bit for the device/host.&n;&t; *&n;&t; * If the host/device isn&squot;t busy, assume that something actually&n;&t; * completed, and that we should be able to queue a command now.&n;&t; *&n;&t; * Note that the prior mid-layer assumption that any host could&n;&t; * always queue at least one command is now broken.  The mid-layer&n;&t; * will implement a user specifiable stall (see&n;&t; * scsi_host.max_host_blocked and scsi_device.max_device_blocked)&n;&t; * if a command is requeued with no other commands outstanding&n;&t; * either for the device or for the host.&n;&t; */
r_if
c_cond
(paren
id|reason
op_eq
id|SCSI_MLQUEUE_HOST_BUSY
)paren
id|host-&gt;host_blocked
op_assign
id|host-&gt;max_host_blocked
suffix:semicolon
r_else
r_if
c_cond
(paren
id|reason
op_eq
id|SCSI_MLQUEUE_DEVICE_BUSY
)paren
id|device-&gt;device_blocked
op_assign
id|device-&gt;max_device_blocked
suffix:semicolon
multiline_comment|/*&n;&t; * Register the fact that we own the thing for now.&n;&t; */
id|cmd-&gt;state
op_assign
id|SCSI_STATE_MLQUEUE
suffix:semicolon
id|cmd-&gt;owner
op_assign
id|SCSI_OWNER_MIDLEVEL
suffix:semicolon
multiline_comment|/*&n;&t; * Decrement the counters, since these commands are no longer&n;&t; * active on the host/device.&n;&t; */
id|scsi_device_unbusy
c_func
(paren
id|device
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Insert this command at the head of the queue for it&squot;s device.&n;&t; * It will go before all other commands that are already in the queue.&n;&t; *&n;&t; * NOTE: there is magic here about the way the queue is plugged if&n;&t; * we have no outstanding commands.&n;&t; * &n;&t; * Although this *doesn&squot;t* plug the queue, it does call the request&n;&t; * function.  The SCSI request function detects the blocked condition&n;&t; * and plugs the queue appropriately.&n;&t; */
id|blk_insert_request
c_func
(paren
id|device-&gt;request_queue
comma
id|cmd-&gt;request
comma
l_int|1
comma
id|cmd
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_do_req&n; *&n; * Purpose:     Queue a SCSI request&n; *&n; * Arguments:   sreq&t;  - command descriptor.&n; *              cmnd      - actual SCSI command to be performed.&n; *              buffer    - data buffer.&n; *              bufflen   - size of data buffer.&n; *              done      - completion function to be run.&n; *              timeout   - how long to let it run before timeout.&n; *              retries   - number of retries we allow.&n; *&n; * Lock status: No locks held upon entry.&n; *&n; * Returns:     Nothing.&n; *&n; * Notes:&t;This function is only used for queueing requests for things&n; *&t;&t;like ioctls and character device requests - this is because&n; *&t;&t;we essentially just inject a request into the queue for the&n; *&t;&t;device.&n; *&n; *&t;&t;In order to support the scsi_device_quiesce function, we&n; *&t;&t;now inject requests on the *head* of the device queue&n; *&t;&t;rather than the tail.&n; */
DECL|function|scsi_do_req
r_void
id|scsi_do_req
c_func
(paren
r_struct
id|scsi_request
op_star
id|sreq
comma
r_const
r_void
op_star
id|cmnd
comma
r_void
op_star
id|buffer
comma
r_int
id|bufflen
comma
r_void
(paren
op_star
id|done
)paren
(paren
r_struct
id|scsi_cmnd
op_star
)paren
comma
r_int
id|timeout
comma
r_int
id|retries
)paren
(brace
multiline_comment|/*&n;&t; * If the upper level driver is reusing these things, then&n;&t; * we should release the low-level block now.  Another one will&n;&t; * be allocated later when this request is getting queued.&n;&t; */
id|__scsi_release_request
c_func
(paren
id|sreq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Our own function scsi_done (which marks the host as not busy,&n;&t; * disables the timeout counter, etc) will be called by us or by the&n;&t; * scsi_hosts[host].queuecommand() function needs to also call&n;&t; * the completion function for the high level driver.&n;&t; */
id|memcpy
c_func
(paren
id|sreq-&gt;sr_cmnd
comma
id|cmnd
comma
r_sizeof
(paren
id|sreq-&gt;sr_cmnd
)paren
)paren
suffix:semicolon
id|sreq-&gt;sr_bufflen
op_assign
id|bufflen
suffix:semicolon
id|sreq-&gt;sr_buffer
op_assign
id|buffer
suffix:semicolon
id|sreq-&gt;sr_allowed
op_assign
id|retries
suffix:semicolon
id|sreq-&gt;sr_done
op_assign
id|done
suffix:semicolon
id|sreq-&gt;sr_timeout_per_command
op_assign
id|timeout
suffix:semicolon
r_if
c_cond
(paren
id|sreq-&gt;sr_cmd_len
op_eq
l_int|0
)paren
id|sreq-&gt;sr_cmd_len
op_assign
id|COMMAND_SIZE
c_func
(paren
id|sreq-&gt;sr_cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * head injection *required* here otherwise quiesce won&squot;t work&n;&t; */
id|scsi_insert_special_req
c_func
(paren
id|sreq
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|scsi_wait_done
r_static
r_void
id|scsi_wait_done
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|request
op_star
id|req
op_assign
id|cmd-&gt;request
suffix:semicolon
r_struct
id|request_queue
op_star
id|q
op_assign
id|cmd-&gt;device-&gt;request_queue
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|req-&gt;rq_status
op_assign
id|RQ_SCSI_DONE
suffix:semicolon
multiline_comment|/* Busy, but indicate request done */
id|spin_lock_irqsave
c_func
(paren
id|q-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blk_rq_tagged
c_func
(paren
id|req
)paren
)paren
id|blk_queue_end_tag
c_func
(paren
id|q
comma
id|req
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|q-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;waiting
)paren
id|complete
c_func
(paren
id|req-&gt;waiting
)paren
suffix:semicolon
)brace
DECL|function|scsi_wait_req
r_void
id|scsi_wait_req
c_func
(paren
r_struct
id|scsi_request
op_star
id|sreq
comma
r_const
r_void
op_star
id|cmnd
comma
r_void
op_star
id|buffer
comma
r_int
id|bufflen
comma
r_int
id|timeout
comma
r_int
id|retries
)paren
(brace
id|DECLARE_COMPLETION
c_func
(paren
id|wait
)paren
suffix:semicolon
id|sreq-&gt;sr_request-&gt;waiting
op_assign
op_amp
id|wait
suffix:semicolon
id|sreq-&gt;sr_request-&gt;rq_status
op_assign
id|RQ_SCSI_BUSY
suffix:semicolon
id|scsi_do_req
c_func
(paren
id|sreq
comma
id|cmnd
comma
id|buffer
comma
id|bufflen
comma
id|scsi_wait_done
comma
id|timeout
comma
id|retries
)paren
suffix:semicolon
id|wait_for_completion
c_func
(paren
op_amp
id|wait
)paren
suffix:semicolon
id|sreq-&gt;sr_request-&gt;waiting
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|sreq-&gt;sr_request-&gt;rq_status
op_ne
id|RQ_SCSI_DONE
)paren
id|sreq-&gt;sr_result
op_or_assign
(paren
id|DRIVER_ERROR
op_lshift
l_int|24
)paren
suffix:semicolon
id|__scsi_release_request
c_func
(paren
id|sreq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_init_cmd_errh()&n; *&n; * Purpose:     Initialize cmd fields related to error handling.&n; *&n; * Arguments:   cmd&t;- command that is ready to be queued.&n; *&n; * Returns:     Nothing&n; *&n; * Notes:       This function has the job of initializing a number of&n; *              fields related to error handling.   Typically this will&n; *              be called once for each command, as required.&n; */
DECL|function|scsi_init_cmd_errh
r_static
r_int
id|scsi_init_cmd_errh
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
id|cmd-&gt;owner
op_assign
id|SCSI_OWNER_MIDLEVEL
suffix:semicolon
id|cmd-&gt;serial_number
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;serial_number_at_timeout
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;abort_reason
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|cmd-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
id|cmd-&gt;sense_buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;cmd_len
op_eq
l_int|0
)paren
id|cmd-&gt;cmd_len
op_assign
id|COMMAND_SIZE
c_func
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We need saved copies of a number of fields - this is because&n;&t; * error handling may need to overwrite these with different values&n;&t; * to run different commands, and once error handling is complete,&n;&t; * we will need to restore these values prior to running the actual&n;&t; * command.&n;&t; */
id|cmd-&gt;old_use_sg
op_assign
id|cmd-&gt;use_sg
suffix:semicolon
id|cmd-&gt;old_cmd_len
op_assign
id|cmd-&gt;cmd_len
suffix:semicolon
id|cmd-&gt;sc_old_data_direction
op_assign
id|cmd-&gt;sc_data_direction
suffix:semicolon
id|cmd-&gt;old_underflow
op_assign
id|cmd-&gt;underflow
suffix:semicolon
id|memcpy
c_func
(paren
id|cmd-&gt;data_cmnd
comma
id|cmd-&gt;cmnd
comma
r_sizeof
(paren
id|cmd-&gt;cmnd
)paren
)paren
suffix:semicolon
id|cmd-&gt;buffer
op_assign
id|cmd-&gt;request_buffer
suffix:semicolon
id|cmd-&gt;bufflen
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
id|cmd-&gt;internal_timeout
op_assign
id|NORMAL_TIMEOUT
suffix:semicolon
id|cmd-&gt;abort_reason
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:   scsi_setup_cmd_retry()&n; *&n; * Purpose:    Restore the command state for a retry&n; *&n; * Arguments:  cmd&t;- command to be restored&n; *&n; * Returns:    Nothing&n; *&n; * Notes:      Immediately prior to retrying a command, we need&n; *             to restore certain fields that we saved above.&n; */
DECL|function|scsi_setup_cmd_retry
r_void
id|scsi_setup_cmd_retry
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
id|memcpy
c_func
(paren
id|cmd-&gt;cmnd
comma
id|cmd-&gt;data_cmnd
comma
r_sizeof
(paren
id|cmd-&gt;data_cmnd
)paren
)paren
suffix:semicolon
id|cmd-&gt;request_buffer
op_assign
id|cmd-&gt;buffer
suffix:semicolon
id|cmd-&gt;request_bufflen
op_assign
id|cmd-&gt;bufflen
suffix:semicolon
id|cmd-&gt;use_sg
op_assign
id|cmd-&gt;old_use_sg
suffix:semicolon
id|cmd-&gt;cmd_len
op_assign
id|cmd-&gt;old_cmd_len
suffix:semicolon
id|cmd-&gt;sc_data_direction
op_assign
id|cmd-&gt;sc_old_data_direction
suffix:semicolon
id|cmd-&gt;underflow
op_assign
id|cmd-&gt;old_underflow
suffix:semicolon
)brace
DECL|function|scsi_device_unbusy
r_void
id|scsi_device_unbusy
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|shost
op_assign
id|sdev-&gt;host
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|shost-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|shost-&gt;host_busy
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|test_bit
c_func
(paren
id|SHOST_RECOVERY
comma
op_amp
id|shost-&gt;shost_state
)paren
op_logical_and
id|shost-&gt;host_failed
)paren
)paren
id|scsi_eh_wakeup
c_func
(paren
id|shost
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
id|shost-&gt;host_lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|sdev-&gt;sdev_lock
)paren
suffix:semicolon
id|sdev-&gt;device_busy
op_decrement
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sdev-&gt;sdev_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called for single_lun devices on IO completion. Clear starget_sdev_user,&n; * and call blk_run_queue for all the scsi_devices on the target -&n; * including current_sdev first.&n; *&n; * Called with *no* scsi locks held.&n; */
DECL|function|scsi_single_lun_run
r_static
r_void
id|scsi_single_lun_run
c_func
(paren
r_struct
id|scsi_device
op_star
id|current_sdev
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|shost
op_assign
id|current_sdev-&gt;host
suffix:semicolon
r_struct
id|scsi_device
op_star
id|sdev
comma
op_star
id|tmp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|shost-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|scsi_target
c_func
(paren
id|current_sdev
)paren
op_member_access_from_pointer
id|starget_sdev_user
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|shost-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Call blk_run_queue for all LUNs on the target, starting with&n;&t; * current_sdev. We race with others (to set starget_sdev_user),&n;&t; * but in most cases, we will be first. Ideally, each LU on the&n;&t; * target would get some limited time or requests on the target.&n;&t; */
id|blk_run_queue
c_func
(paren
id|current_sdev-&gt;request_queue
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|shost-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scsi_target
c_func
(paren
id|current_sdev
)paren
op_member_access_from_pointer
id|starget_sdev_user
)paren
r_goto
id|out
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|sdev
comma
id|tmp
comma
op_amp
id|current_sdev-&gt;same_target_siblings
comma
id|same_target_siblings
)paren
(brace
r_if
c_cond
(paren
id|scsi_device_get
c_func
(paren
id|sdev
)paren
)paren
r_continue
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|shost-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|blk_run_queue
c_func
(paren
id|sdev-&gt;request_queue
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|shost-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|scsi_device_put
c_func
(paren
id|sdev
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
id|shost-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:&t;scsi_run_queue()&n; *&n; * Purpose:&t;Select a proper request queue to serve next&n; *&n; * Arguments:&t;q&t;- last request&squot;s queue&n; *&n; * Returns:     Nothing&n; *&n; * Notes:&t;The previous command was completely finished, start&n; *&t;&t;a new one if possible.&n; */
DECL|function|scsi_run_queue
r_static
r_void
id|scsi_run_queue
c_func
(paren
r_struct
id|request_queue
op_star
id|q
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
op_assign
id|q-&gt;queuedata
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shost
op_assign
id|sdev-&gt;host
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;single_lun
)paren
id|scsi_single_lun_run
c_func
(paren
id|sdev
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|shost-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|shost-&gt;starved_list
)paren
op_logical_and
op_logical_neg
id|shost-&gt;host_blocked
op_logical_and
op_logical_neg
id|shost-&gt;host_self_blocked
op_logical_and
op_logical_neg
(paren
(paren
id|shost-&gt;can_queue
OG
l_int|0
)paren
op_logical_and
(paren
id|shost-&gt;host_busy
op_ge
id|shost-&gt;can_queue
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * As long as shost is accepting commands and we have&n;&t;&t; * starved queues, call blk_run_queue. scsi_request_fn&n;&t;&t; * drops the queue_lock and can add us back to the&n;&t;&t; * starved_list.&n;&t;&t; *&n;&t;&t; * host_lock protects the starved_list and starved_entry.&n;&t;&t; * scsi_request_fn must get the host_lock before checking&n;&t;&t; * or modifying starved_list or starved_entry.&n;&t;&t; */
id|sdev
op_assign
id|list_entry
c_func
(paren
id|shost-&gt;starved_list.next
comma
r_struct
id|scsi_device
comma
id|starved_entry
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|sdev-&gt;starved_entry
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|shost-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|blk_run_queue
c_func
(paren
id|sdev-&gt;request_queue
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|shost-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|sdev-&gt;starved_entry
)paren
)paren
)paren
multiline_comment|/*&n;&t;&t;&t; * sdev lost a race, and was put back on the&n;&t;&t;&t; * starved list. This is unlikely but without this&n;&t;&t;&t; * in theory we could loop forever.&n;&t;&t;&t; */
r_break
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
id|shost-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|blk_run_queue
c_func
(paren
id|q
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:&t;scsi_requeue_command()&n; *&n; * Purpose:&t;Handle post-processing of completed commands.&n; *&n; * Arguments:&t;q&t;- queue to operate on&n; *&t;&t;cmd&t;- command that may need to be requeued.&n; *&n; * Returns:&t;Nothing&n; *&n; * Notes:&t;After command completion, there may be blocks left&n; *&t;&t;over which weren&squot;t finished by the previous command&n; *&t;&t;this can be for a number of reasons - the main one is&n; *&t;&t;I/O errors in the middle of the request, in which case&n; *&t;&t;we need to request the blocks that come after the bad&n; *&t;&t;sector.&n; */
DECL|function|scsi_requeue_command
r_static
r_void
id|scsi_requeue_command
c_func
(paren
r_struct
id|request_queue
op_star
id|q
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
id|cmd-&gt;request-&gt;flags
op_and_assign
op_complement
id|REQ_DONTPREP
suffix:semicolon
id|blk_insert_request
c_func
(paren
id|q
comma
id|cmd-&gt;request
comma
l_int|1
comma
id|cmd
comma
l_int|1
)paren
suffix:semicolon
id|scsi_run_queue
c_func
(paren
id|q
)paren
suffix:semicolon
)brace
DECL|function|scsi_next_command
r_void
id|scsi_next_command
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|request_queue
op_star
id|q
op_assign
id|cmd-&gt;device-&gt;request_queue
suffix:semicolon
id|scsi_put_command
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|scsi_run_queue
c_func
(paren
id|q
)paren
suffix:semicolon
)brace
DECL|function|scsi_run_host_queues
r_void
id|scsi_run_host_queues
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
id|shost_for_each_device
c_func
(paren
id|sdev
comma
id|shost
)paren
id|scsi_run_queue
c_func
(paren
id|sdev-&gt;request_queue
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_end_request()&n; *&n; * Purpose:     Post-processing of completed commands called from interrupt&n; *              handler or a bottom-half handler.&n; *&n; * Arguments:   cmd&t; - command that is complete.&n; *              uptodate - 1 if I/O indicates success, 0 for I/O error.&n; *              sectors  - number of sectors we want to mark.&n; *&t;&t;requeue  - indicates whether we should requeue leftovers.&n; *&t;&t;frequeue - indicates that if we release the command block&n; *&t;&t;&t;   that the queue request function should be called.&n; *&n; * Lock status: Assumed that lock is not held upon entry.&n; *&n; * Returns:     Nothing&n; *&n; * Notes:       This is called for block device requests in order to&n; *              mark some number of sectors as complete.&n; * &n; *&t;&t;We are guaranteeing that the request queue will be goosed&n; *&t;&t;at some point during this call.&n; */
DECL|function|scsi_end_request
r_static
r_struct
id|scsi_cmnd
op_star
id|scsi_end_request
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_int
id|uptodate
comma
r_int
id|bytes
comma
r_int
id|requeue
)paren
(brace
id|request_queue_t
op_star
id|q
op_assign
id|cmd-&gt;device-&gt;request_queue
suffix:semicolon
r_struct
id|request
op_star
id|req
op_assign
id|cmd-&gt;request
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * If there are blocks left over at the end, set up the command&n;&t; * to queue the remainder of them.&n;&t; */
r_if
c_cond
(paren
id|end_that_request_chunk
c_func
(paren
id|req
comma
id|uptodate
comma
id|bytes
)paren
)paren
(brace
r_int
id|leftover
op_assign
(paren
id|req-&gt;hard_nr_sectors
op_lshift
l_int|9
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blk_pc_request
c_func
(paren
id|req
)paren
)paren
id|leftover
op_assign
id|req-&gt;data_len
suffix:semicolon
multiline_comment|/* kill remainder if no retrys */
r_if
c_cond
(paren
op_logical_neg
id|uptodate
op_logical_and
id|blk_noretry_request
c_func
(paren
id|req
)paren
)paren
id|end_that_request_chunk
c_func
(paren
id|req
comma
l_int|0
comma
id|leftover
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|requeue
)paren
multiline_comment|/*&n;&t;&t;&t;&t; * Bleah.  Leftovers again.  Stick the&n;&t;&t;&t;&t; * leftovers in the front of the&n;&t;&t;&t;&t; * queue, and goose the queue again.&n;&t;&t;&t;&t; */
id|scsi_requeue_command
c_func
(paren
id|q
comma
id|cmd
)paren
suffix:semicolon
r_return
id|cmd
suffix:semicolon
)brace
)brace
id|add_disk_randomness
c_func
(paren
id|req-&gt;rq_disk
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|q-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blk_rq_tagged
c_func
(paren
id|req
)paren
)paren
id|blk_queue_end_tag
c_func
(paren
id|q
comma
id|req
)paren
suffix:semicolon
id|end_that_request_last
c_func
(paren
id|req
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|q-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This will goose the queue request function at the end, so we don&squot;t&n;&t; * need to worry about launching another command.&n;&t; */
id|scsi_next_command
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|scsi_alloc_sgtable
r_static
r_struct
id|scatterlist
op_star
id|scsi_alloc_sgtable
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_int
id|gfp_mask
)paren
(brace
r_struct
id|scsi_host_sg_pool
op_star
id|sgp
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sgl
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|cmd-&gt;use_sg
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd-&gt;use_sg
)paren
(brace
r_case
l_int|1
dot
dot
dot
l_int|8
suffix:colon
id|cmd-&gt;sglist_len
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9
dot
dot
dot
l_int|16
suffix:colon
id|cmd-&gt;sglist_len
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|17
dot
dot
dot
l_int|32
suffix:colon
id|cmd-&gt;sglist_len
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
macro_line|#if (SCSI_MAX_PHYS_SEGMENTS &gt; 32)
r_case
l_int|33
dot
dot
dot
l_int|64
suffix:colon
id|cmd-&gt;sglist_len
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
macro_line|#if (SCSI_MAX_PHYS_SEGMENTS &gt; 64)
r_case
l_int|65
dot
dot
dot
l_int|128
suffix:colon
id|cmd-&gt;sglist_len
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
macro_line|#if (SCSI_MAX_PHYS_SEGMENTS  &gt; 128)
r_case
l_int|129
dot
dot
dot
l_int|256
suffix:colon
id|cmd-&gt;sglist_len
op_assign
l_int|5
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#endif
macro_line|#endif
r_default
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
id|sgp
op_assign
id|scsi_sg_pools
op_plus
id|cmd-&gt;sglist_len
suffix:semicolon
id|sgl
op_assign
id|mempool_alloc
c_func
(paren
id|sgp-&gt;pool
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sgl
)paren
id|memset
c_func
(paren
id|sgl
comma
l_int|0
comma
id|sgp-&gt;size
)paren
suffix:semicolon
r_return
id|sgl
suffix:semicolon
)brace
DECL|function|scsi_free_sgtable
r_static
r_void
id|scsi_free_sgtable
c_func
(paren
r_struct
id|scatterlist
op_star
id|sgl
comma
r_int
id|index
)paren
(brace
r_struct
id|scsi_host_sg_pool
op_star
id|sgp
suffix:semicolon
id|BUG_ON
c_func
(paren
id|index
OG
id|SG_MEMPOOL_NR
)paren
suffix:semicolon
id|sgp
op_assign
id|scsi_sg_pools
op_plus
id|index
suffix:semicolon
id|mempool_free
c_func
(paren
id|sgl
comma
id|sgp-&gt;pool
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_release_buffers()&n; *&n; * Purpose:     Completion processing for block device I/O requests.&n; *&n; * Arguments:   cmd&t;- command that we are bailing.&n; *&n; * Lock status: Assumed that no lock is held upon entry.&n; *&n; * Returns:     Nothing&n; *&n; * Notes:       In the event that an upper level driver rejects a&n; *&t;&t;command, we must release resources allocated during&n; *&t;&t;the __init_io() function.  Primarily this would involve&n; *&t;&t;the scatter-gather table, and potentially any bounce&n; *&t;&t;buffers.&n; */
DECL|function|scsi_release_buffers
r_static
r_void
id|scsi_release_buffers
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|request
op_star
id|req
op_assign
id|cmd-&gt;request
suffix:semicolon
multiline_comment|/*&n;&t; * Free up any indirection buffers we allocated for DMA purposes. &n;&t; */
r_if
c_cond
(paren
id|cmd-&gt;use_sg
)paren
id|scsi_free_sgtable
c_func
(paren
id|cmd-&gt;request_buffer
comma
id|cmd-&gt;sglist_len
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cmd-&gt;request_buffer
op_ne
id|req-&gt;buffer
)paren
id|kfree
c_func
(paren
id|cmd-&gt;request_buffer
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Zero these out.  They now point to freed memory, and it is&n;&t; * dangerous to hang onto the pointers.&n;&t; */
id|cmd-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;bufflen
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;request_buffer
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;request_bufflen
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_io_completion()&n; *&n; * Purpose:     Completion processing for block device I/O requests.&n; *&n; * Arguments:   cmd   - command that is finished.&n; *&n; * Lock status: Assumed that no lock is held upon entry.&n; *&n; * Returns:     Nothing&n; *&n; * Notes:       This function is matched in terms of capabilities to&n; *              the function that created the scatter-gather list.&n; *              In other words, if there are no bounce buffers&n; *              (the normal case for most drivers), we don&squot;t need&n; *              the logic to deal with cleaning up afterwards.&n; *&n; *&t;&t;We must do one of several things here:&n; *&n; *&t;&t;a) Call scsi_end_request.  This will finish off the&n; *&t;&t;   specified number of sectors.  If we are done, the&n; *&t;&t;   command block will be released, and the queue&n; *&t;&t;   function will be goosed.  If we are not done, then&n; *&t;&t;   scsi_end_request will directly goose the queue.&n; *&n; *&t;&t;b) We can just use scsi_requeue_command() here.  This would&n; *&t;&t;   be used if we just wanted to retry, for example.&n; */
DECL|function|scsi_io_completion
r_void
id|scsi_io_completion
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_int
r_int
id|good_bytes
comma
r_int
r_int
id|block_bytes
)paren
(brace
r_int
id|result
op_assign
id|cmd-&gt;result
suffix:semicolon
r_int
id|this_count
op_assign
id|cmd-&gt;bufflen
suffix:semicolon
id|request_queue_t
op_star
id|q
op_assign
id|cmd-&gt;device-&gt;request_queue
suffix:semicolon
r_struct
id|request
op_star
id|req
op_assign
id|cmd-&gt;request
suffix:semicolon
r_int
id|clear_errors
op_assign
l_int|1
suffix:semicolon
r_struct
id|scsi_sense_hdr
id|sshdr
suffix:semicolon
multiline_comment|/*&n;&t; * Free up any indirection buffers we allocated for DMA purposes. &n;&t; * For the case of a READ, we need to copy the data out of the&n;&t; * bounce buffer and into the real buffer.&n;&t; */
r_if
c_cond
(paren
id|cmd-&gt;use_sg
)paren
id|scsi_free_sgtable
c_func
(paren
id|cmd-&gt;buffer
comma
id|cmd-&gt;sglist_len
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cmd-&gt;buffer
op_ne
id|req-&gt;buffer
)paren
(brace
r_if
c_cond
(paren
id|rq_data_dir
c_func
(paren
id|req
)paren
op_eq
id|READ
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_char
op_star
id|to
op_assign
id|bio_kmap_irq
c_func
(paren
id|req-&gt;bio
comma
op_amp
id|flags
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|to
comma
id|cmd-&gt;buffer
comma
id|cmd-&gt;bufflen
)paren
suffix:semicolon
id|bio_kunmap_irq
c_func
(paren
id|to
comma
op_amp
id|flags
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|cmd-&gt;buffer
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|blk_pc_request
c_func
(paren
id|req
)paren
)paren
(brace
multiline_comment|/* SG_IO ioctl from block level */
id|req-&gt;errors
op_assign
id|result
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
id|clear_errors
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|scsi_command_normalize_sense
c_func
(paren
id|cmd
comma
op_amp
id|sshdr
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * SG_IO wants current and deferred errors&n;&t;&t;&t;&t; */
r_int
id|len
op_assign
l_int|8
op_plus
id|cmd-&gt;sense_buffer
(braket
l_int|7
)braket
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|SCSI_SENSE_BUFFERSIZE
)paren
id|len
op_assign
id|SCSI_SENSE_BUFFERSIZE
suffix:semicolon
id|memcpy
c_func
(paren
id|req-&gt;sense
comma
id|cmd-&gt;sense_buffer
comma
id|len
)paren
suffix:semicolon
id|req-&gt;sense_len
op_assign
id|len
suffix:semicolon
)brace
)brace
r_else
id|req-&gt;data_len
op_sub_assign
id|cmd-&gt;bufflen
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Zero these out.  They now point to freed memory, and it is&n;&t; * dangerous to hang onto the pointers.&n;&t; */
id|cmd-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;bufflen
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;request_buffer
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;request_bufflen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Next deal with any sectors which we were able to correctly&n;&t; * handle.&n;&t; */
r_if
c_cond
(paren
id|good_bytes
op_ge
l_int|0
)paren
(brace
id|SCSI_LOG_HLCOMPLETE
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;%ld sectors total, %d bytes done.&bslash;n&quot;
comma
id|req-&gt;nr_sectors
comma
id|good_bytes
)paren
)paren
suffix:semicolon
id|SCSI_LOG_HLCOMPLETE
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;use_sg is %d&bslash;n&quot;
comma
id|cmd-&gt;use_sg
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clear_errors
)paren
id|req-&gt;errors
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If multiple sectors are requested in one buffer, then&n;&t;&t; * they will have been finished off by the first command.&n;&t;&t; * If not, then we have a multi-buffer command.&n;&t;&t; *&n;&t;&t; * If block_bytes != 0, it means we had a medium error&n;&t;&t; * of some sort, and that we want to mark some number of&n;&t;&t; * sectors as not uptodate.  Thus we want to inhibit&n;&t;&t; * requeueing right here - we will requeue down below&n;&t;&t; * when we handle the bad sectors.&n;&t;&t; */
id|cmd
op_assign
id|scsi_end_request
c_func
(paren
id|cmd
comma
l_int|1
comma
id|good_bytes
comma
id|result
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the command completed without error, then either finish off the&n;&t;&t; * rest of the command, or start a new one.&n;&t;&t; */
r_if
c_cond
(paren
id|result
op_eq
l_int|0
op_logical_or
id|cmd
op_eq
l_int|NULL
)paren
(brace
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Now, if we were good little boys and girls, Santa left us a request&n;&t; * sense buffer.  We can extract information from this, so we&n;&t; * can choose a block to remap, etc.&n;&t; */
r_if
c_cond
(paren
id|driver_byte
c_func
(paren
id|result
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|scsi_command_normalize_sense
c_func
(paren
id|cmd
comma
op_amp
id|sshdr
)paren
op_logical_and
op_logical_neg
id|scsi_sense_is_deferred
c_func
(paren
op_amp
id|sshdr
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If the device is in the process of becoming ready,&n;&t;&t;&t; * retry.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|sshdr.asc
op_eq
l_int|0x04
op_logical_and
id|sshdr.ascq
op_eq
l_int|0x01
)paren
(brace
id|scsi_requeue_command
c_func
(paren
id|q
comma
id|cmd
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sshdr.sense_key
op_eq
id|UNIT_ATTENTION
)paren
(brace
r_if
c_cond
(paren
id|cmd-&gt;device-&gt;removable
)paren
(brace
multiline_comment|/* detected disc change.  set a bit &n;&t;&t;&t;&t;&t; * and quietly refuse further access.&n;&t;&t; &t;&t;&t; */
id|cmd-&gt;device-&gt;changed
op_assign
l_int|1
suffix:semicolon
id|cmd
op_assign
id|scsi_end_request
c_func
(paren
id|cmd
comma
l_int|0
comma
id|this_count
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; &t;* Must have been a power glitch, or a&n;&t;&t;&t;&t; &t;* bus reset.  Could not have been a&n;&t;&t;&t;&t; &t;* media change, so we just retry the&n;&t;&t;&t;&t; &t;* request and see what happens.  &n;&t;&t;&t;&t; &t;*/
id|scsi_requeue_command
c_func
(paren
id|q
comma
id|cmd
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t; * If we had an ILLEGAL REQUEST returned, then we may have&n;&t;&t; * performed an unsupported command.  The only thing this&n;&t;&t; * should be would be a ten byte read where only a six byte&n;&t;&t; * read was supported.  Also, on a system where READ CAPACITY&n;&t;&t; * failed, we may have read past the end of the disk.&n;&t;&t; */
multiline_comment|/*&n;&t;&t; * XXX: Following is probably broken since deferred errors&n;&t;&t; *&t;fall through [dpg 20040827]&n;&t;&t; */
r_switch
c_cond
(paren
id|sshdr.sense_key
)paren
(brace
r_case
id|ILLEGAL_REQUEST
suffix:colon
r_if
c_cond
(paren
id|cmd-&gt;device-&gt;use_10_for_rw
op_logical_and
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|READ_10
op_logical_or
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|WRITE_10
)paren
)paren
(brace
id|cmd-&gt;device-&gt;use_10_for_rw
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * This will cause a retry with a 6-byte&n;&t;&t;&t;&t; * command.&n;&t;&t;&t;&t; */
id|scsi_requeue_command
c_func
(paren
id|q
comma
id|cmd
)paren
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|cmd
op_assign
id|scsi_end_request
c_func
(paren
id|cmd
comma
l_int|0
comma
id|this_count
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|NOT_READY
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Device %s not ready.&bslash;n&quot;
comma
id|req-&gt;rq_disk
ques
c_cond
id|req-&gt;rq_disk-&gt;disk_name
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|cmd
op_assign
id|scsi_end_request
c_func
(paren
id|cmd
comma
l_int|0
comma
id|this_count
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|VOLUME_OVERFLOW
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Volume overflow &lt;%d %d %d %d&gt; CDB: &quot;
comma
id|cmd-&gt;device-&gt;host-&gt;host_no
comma
(paren
r_int
)paren
id|cmd-&gt;device-&gt;channel
comma
(paren
r_int
)paren
id|cmd-&gt;device-&gt;id
comma
(paren
r_int
)paren
id|cmd-&gt;device-&gt;lun
)paren
suffix:semicolon
id|__scsi_print_command
c_func
(paren
id|cmd-&gt;data_cmnd
)paren
suffix:semicolon
id|scsi_print_sense
c_func
(paren
l_string|&quot;&quot;
comma
id|cmd
)paren
suffix:semicolon
id|cmd
op_assign
id|scsi_end_request
c_func
(paren
id|cmd
comma
l_int|0
comma
id|block_bytes
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* driver byte != 0 */
r_if
c_cond
(paren
id|host_byte
c_func
(paren
id|result
)paren
op_eq
id|DID_RESET
)paren
(brace
multiline_comment|/*&n;&t;&t; * Third party bus reset or reset for error&n;&t;&t; * recovery reasons.  Just retry the request&n;&t;&t; * and see what happens.  &n;&t;&t; */
id|scsi_requeue_command
c_func
(paren
id|q
comma
id|cmd
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;SCSI error : &lt;%d %d %d %d&gt; return code &quot;
l_string|&quot;= 0x%x&bslash;n&quot;
comma
id|cmd-&gt;device-&gt;host-&gt;host_no
comma
id|cmd-&gt;device-&gt;channel
comma
id|cmd-&gt;device-&gt;id
comma
id|cmd-&gt;device-&gt;lun
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver_byte
c_func
(paren
id|result
)paren
op_amp
id|DRIVER_SENSE
)paren
id|scsi_print_sense
c_func
(paren
l_string|&quot;&quot;
comma
id|cmd
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Mark a single buffer as not uptodate.  Queue the remainder.&n;&t;&t; * We sometimes get this cruft in the event that a medium error&n;&t;&t; * isn&squot;t properly reported.&n;&t;&t; */
id|block_bytes
op_assign
id|req-&gt;hard_cur_sectors
op_lshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|block_bytes
)paren
id|block_bytes
op_assign
id|req-&gt;data_len
suffix:semicolon
id|cmd
op_assign
id|scsi_end_request
c_func
(paren
id|cmd
comma
l_int|0
comma
id|block_bytes
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function:    scsi_init_io()&n; *&n; * Purpose:     SCSI I/O initialize function.&n; *&n; * Arguments:   cmd   - Command descriptor we wish to initialize&n; *&n; * Returns:     0 on success&n; *&t;&t;BLKPREP_DEFER if the failure is retryable&n; *&t;&t;BLKPREP_KILL if the failure is fatal&n; */
DECL|function|scsi_init_io
r_static
r_int
id|scsi_init_io
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|request
op_star
id|req
op_assign
id|cmd-&gt;request
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sgpnt
suffix:semicolon
r_int
id|count
suffix:semicolon
multiline_comment|/*&n;&t; * if this is a rq-&gt;data based REQ_BLOCK_PC, setup for a non-sg xfer&n;&t; */
r_if
c_cond
(paren
(paren
id|req-&gt;flags
op_amp
id|REQ_BLOCK_PC
)paren
op_logical_and
op_logical_neg
id|req-&gt;bio
)paren
(brace
id|cmd-&gt;request_bufflen
op_assign
id|req-&gt;data_len
suffix:semicolon
id|cmd-&gt;request_buffer
op_assign
id|req-&gt;data
suffix:semicolon
id|req-&gt;buffer
op_assign
id|req-&gt;data
suffix:semicolon
id|cmd-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we used to not use scatter-gather for single segment request,&n;&t; * but now we do (it makes highmem I/O easier to support without&n;&t; * kmapping pages)&n;&t; */
id|cmd-&gt;use_sg
op_assign
id|req-&gt;nr_phys_segments
suffix:semicolon
multiline_comment|/*&n;&t; * if sg table allocation fails, requeue request later.&n;&t; */
id|sgpnt
op_assign
id|scsi_alloc_sgtable
c_func
(paren
id|cmd
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|sgpnt
)paren
)paren
(brace
id|req-&gt;flags
op_or_assign
id|REQ_SPECIAL
suffix:semicolon
r_return
id|BLKPREP_DEFER
suffix:semicolon
)brace
id|cmd-&gt;request_buffer
op_assign
(paren
r_char
op_star
)paren
id|sgpnt
suffix:semicolon
id|cmd-&gt;request_bufflen
op_assign
id|req-&gt;nr_sectors
op_lshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
id|blk_pc_request
c_func
(paren
id|req
)paren
)paren
id|cmd-&gt;request_bufflen
op_assign
id|req-&gt;data_len
suffix:semicolon
id|req-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* &n;&t; * Next, walk the list, and fill in the addresses and sizes of&n;&t; * each segment.&n;&t; */
id|count
op_assign
id|blk_rq_map_sg
c_func
(paren
id|req-&gt;q
comma
id|req
comma
id|cmd-&gt;request_buffer
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * mapped well, send it off&n;&t; */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|count
op_le
id|cmd-&gt;use_sg
)paren
)paren
(brace
id|cmd-&gt;use_sg
op_assign
id|count
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Incorrect number of segments after building list&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;counted %d, received %d&bslash;n&quot;
comma
id|count
comma
id|cmd-&gt;use_sg
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;req nr_sec %lu, cur_nr_sec %u&bslash;n&quot;
comma
id|req-&gt;nr_sectors
comma
id|req-&gt;current_nr_sectors
)paren
suffix:semicolon
multiline_comment|/* release the command and kill it */
id|scsi_release_buffers
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|scsi_put_command
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
id|BLKPREP_KILL
suffix:semicolon
)brace
DECL|function|scsi_issue_flush_fn
r_static
r_int
id|scsi_issue_flush_fn
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|gendisk
op_star
id|disk
comma
id|sector_t
op_star
id|error_sector
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
op_assign
id|q-&gt;queuedata
suffix:semicolon
r_struct
id|scsi_driver
op_star
id|drv
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;sdev_state
op_ne
id|SDEV_RUNNING
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|drv
op_assign
op_star
(paren
r_struct
id|scsi_driver
op_star
op_star
)paren
id|disk-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;issue_flush
)paren
r_return
id|drv
op_member_access_from_pointer
id|issue_flush
c_func
(paren
op_amp
id|sdev-&gt;sdev_gendev
comma
id|error_sector
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
DECL|function|scsi_prep_fn
r_static
r_int
id|scsi_prep_fn
c_func
(paren
r_struct
id|request_queue
op_star
id|q
comma
r_struct
id|request
op_star
id|req
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
op_assign
id|q-&gt;queuedata
suffix:semicolon
r_struct
id|scsi_cmnd
op_star
id|cmd
suffix:semicolon
r_int
id|specials_only
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Just check to see if the device is online.  If it isn&squot;t, we&n;&t; * refuse to process any commands.  The device must be brought&n;&t; * online before trying any recovery commands&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|scsi_device_online
c_func
(paren
id|sdev
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;scsi%d (%d:%d): rejecting I/O to offline device&bslash;n&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
)paren
suffix:semicolon
r_return
id|BLKPREP_KILL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|sdev-&gt;sdev_state
op_ne
id|SDEV_RUNNING
)paren
)paren
(brace
multiline_comment|/* OK, we&squot;re not in a running state don&squot;t prep&n;&t;&t; * user commands */
r_if
c_cond
(paren
id|sdev-&gt;sdev_state
op_eq
id|SDEV_DEL
)paren
(brace
multiline_comment|/* Device is fully deleted, no commands&n;&t;&t;&t; * at all allowed down */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;scsi%d (%d:%d): rejecting I/O to dead device&bslash;n&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
)paren
suffix:semicolon
r_return
id|BLKPREP_KILL
suffix:semicolon
)brace
multiline_comment|/* OK, we only allow special commands (i.e. not&n;&t;&t; * user initiated ones */
id|specials_only
op_assign
id|sdev-&gt;sdev_state
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Find the actual device driver associated with this command.&n;&t; * The SPECIAL requests are things like character device or&n;&t; * ioctls, which did not originate from ll_rw_blk.  Note that&n;&t; * the special field is also used to indicate the cmd for&n;&t; * the remainder of a partially fulfilled request that can &n;&t; * come up when there is a medium error.  We have to treat&n;&t; * these two cases differently.  We differentiate by looking&n;&t; * at request-&gt;cmd, as this tells us the real story.&n;&t; */
r_if
c_cond
(paren
id|req-&gt;flags
op_amp
id|REQ_SPECIAL
)paren
(brace
r_struct
id|scsi_request
op_star
id|sreq
op_assign
id|req-&gt;special
suffix:semicolon
r_if
c_cond
(paren
id|sreq-&gt;sr_magic
op_eq
id|SCSI_REQ_MAGIC
)paren
(brace
id|cmd
op_assign
id|scsi_get_command
c_func
(paren
id|sreq-&gt;sr_device
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|cmd
)paren
)paren
r_goto
id|defer
suffix:semicolon
id|scsi_init_cmd_from_req
c_func
(paren
id|cmd
comma
id|sreq
)paren
suffix:semicolon
)brace
r_else
id|cmd
op_assign
id|req-&gt;special
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|req-&gt;flags
op_amp
(paren
id|REQ_CMD
op_or
id|REQ_BLOCK_PC
)paren
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|specials_only
)paren
)paren
(brace
r_if
c_cond
(paren
id|specials_only
op_eq
id|SDEV_QUIESCE
op_logical_or
id|specials_only
op_eq
id|SDEV_BLOCK
)paren
(brace
r_return
id|BLKPREP_DEFER
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;scsi%d (%d:%d): rejecting I/O to device being removed&bslash;n&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
)paren
suffix:semicolon
r_return
id|BLKPREP_KILL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Now try and find a command block that we can use.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|req-&gt;special
)paren
(brace
id|cmd
op_assign
id|scsi_get_command
c_func
(paren
id|sdev
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|cmd
)paren
)paren
r_goto
id|defer
suffix:semicolon
)brace
r_else
id|cmd
op_assign
id|req-&gt;special
suffix:semicolon
multiline_comment|/* pull a tag out of the request if we have one */
id|cmd-&gt;tag
op_assign
id|req-&gt;tag
suffix:semicolon
)brace
r_else
(brace
id|blk_dump_rq_flags
c_func
(paren
id|req
comma
l_string|&quot;SCSI bad req&quot;
)paren
suffix:semicolon
r_return
id|BLKPREP_KILL
suffix:semicolon
)brace
multiline_comment|/* note the overloading of req-&gt;special.  When the tag&n;&t; * is active it always means cmd.  If the tag goes&n;&t; * back for re-queueing, it may be reset */
id|req-&gt;special
op_assign
id|cmd
suffix:semicolon
id|cmd-&gt;request
op_assign
id|req
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME: drop the lock here because the functions below&n;&t; * expect to be called without the queue lock held.  Also,&n;&t; * previously, we dequeued the request before dropping the&n;&t; * lock.  We hope REQ_STARTED prevents anything untoward from&n;&t; * happening now.&n;&t; */
r_if
c_cond
(paren
id|req-&gt;flags
op_amp
(paren
id|REQ_CMD
op_or
id|REQ_BLOCK_PC
)paren
)paren
(brace
r_struct
id|scsi_driver
op_star
id|drv
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This will do a couple of things:&n;&t;&t; *  1) Fill in the actual SCSI command.&n;&t;&t; *  2) Fill in any other upper-level specific fields&n;&t;&t; * (timeout).&n;&t;&t; *&n;&t;&t; * If this returns 0, it means that the request failed&n;&t;&t; * (reading past end of disk, reading offline device,&n;&t;&t; * etc).   This won&squot;t actually talk to the device, but&n;&t;&t; * some kinds of consistency checking may cause the&t;&n;&t;&t; * request to be rejected immediately.&n;&t;&t; */
multiline_comment|/* &n;&t;&t; * This sets up the scatter-gather table (allocating if&n;&t;&t; * required).&n;&t;&t; */
id|ret
op_assign
id|scsi_init_io
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
multiline_comment|/* BLKPREP_KILL return also releases the command */
r_return
id|ret
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Initialize the actual SCSI command for this request.&n;&t;&t; */
id|drv
op_assign
op_star
(paren
r_struct
id|scsi_driver
op_star
op_star
)paren
id|req-&gt;rq_disk-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|drv
op_member_access_from_pointer
id|init_command
c_func
(paren
id|cmd
)paren
)paren
)paren
(brace
id|scsi_release_buffers
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|scsi_put_command
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
id|BLKPREP_KILL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * The request is now prepped, no need to come back here&n;&t; */
id|req-&gt;flags
op_or_assign
id|REQ_DONTPREP
suffix:semicolon
r_return
id|BLKPREP_OK
suffix:semicolon
id|defer
suffix:colon
multiline_comment|/* If we defer, the elv_next_request() returns NULL, but the&n;&t; * queue must be restarted, so we plug here if no returning&n;&t; * command will automatically do that. */
r_if
c_cond
(paren
id|sdev-&gt;device_busy
op_eq
l_int|0
)paren
id|blk_plug_device
c_func
(paren
id|q
)paren
suffix:semicolon
r_return
id|BLKPREP_DEFER
suffix:semicolon
)brace
multiline_comment|/*&n; * scsi_dev_queue_ready: if we can send requests to sdev, return 1 else&n; * return 0.&n; *&n; * Called with the queue_lock held.&n; */
DECL|function|scsi_dev_queue_ready
r_static
r_inline
r_int
id|scsi_dev_queue_ready
c_func
(paren
r_struct
id|request_queue
op_star
id|q
comma
r_struct
id|scsi_device
op_star
id|sdev
)paren
(brace
r_if
c_cond
(paren
id|sdev-&gt;device_busy
op_ge
id|sdev-&gt;queue_depth
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;device_busy
op_eq
l_int|0
op_logical_and
id|sdev-&gt;device_blocked
)paren
(brace
multiline_comment|/*&n;&t;&t; * unblock after device_blocked iterates to zero&n;&t;&t; */
r_if
c_cond
(paren
op_decrement
id|sdev-&gt;device_blocked
op_eq
l_int|0
)paren
(brace
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi%d (%d:%d) unblocking device at&quot;
l_string|&quot; zero depth&bslash;n&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|blk_plug_device
c_func
(paren
id|q
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|sdev-&gt;device_blocked
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * scsi_host_queue_ready: if we can send requests to shost, return 1 else&n; * return 0. We must end up running the queue again whenever 0 is&n; * returned, else IO can hang.&n; *&n; * Called with host_lock held.&n; */
DECL|function|scsi_host_queue_ready
r_static
r_inline
r_int
id|scsi_host_queue_ready
c_func
(paren
r_struct
id|request_queue
op_star
id|q
comma
r_struct
id|Scsi_Host
op_star
id|shost
comma
r_struct
id|scsi_device
op_star
id|sdev
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|SHOST_RECOVERY
comma
op_amp
id|shost-&gt;shost_state
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|shost-&gt;host_busy
op_eq
l_int|0
op_logical_and
id|shost-&gt;host_blocked
)paren
(brace
multiline_comment|/*&n;&t;&t; * unblock after host_blocked iterates to zero&n;&t;&t; */
r_if
c_cond
(paren
op_decrement
id|shost-&gt;host_blocked
op_eq
l_int|0
)paren
(brace
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi%d unblocking host at zero depth&bslash;n&quot;
comma
id|shost-&gt;host_no
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|blk_plug_device
c_func
(paren
id|q
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|shost-&gt;can_queue
OG
l_int|0
op_logical_and
id|shost-&gt;host_busy
op_ge
id|shost-&gt;can_queue
)paren
op_logical_or
id|shost-&gt;host_blocked
op_logical_or
id|shost-&gt;host_self_blocked
)paren
(brace
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|sdev-&gt;starved_entry
)paren
)paren
id|list_add_tail
c_func
(paren
op_amp
id|sdev-&gt;starved_entry
comma
op_amp
id|shost-&gt;starved_list
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We&squot;re OK to process the command, so we can&squot;t be starved */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|sdev-&gt;starved_entry
)paren
)paren
id|list_del_init
c_func
(paren
op_amp
id|sdev-&gt;starved_entry
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_request_fn()&n; *&n; * Purpose:     Main strategy routine for SCSI.&n; *&n; * Arguments:   q       - Pointer to actual queue.&n; *&n; * Returns:     Nothing&n; *&n; * Lock status: IO request lock assumed to be held when called.&n; */
DECL|function|scsi_request_fn
r_static
r_void
id|scsi_request_fn
c_func
(paren
r_struct
id|request_queue
op_star
id|q
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
op_assign
id|q-&gt;queuedata
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shost
op_assign
id|sdev-&gt;host
suffix:semicolon
r_struct
id|scsi_cmnd
op_star
id|cmd
suffix:semicolon
r_struct
id|request
op_star
id|req
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|get_device
c_func
(paren
op_amp
id|sdev-&gt;sdev_gendev
)paren
)paren
(brace
multiline_comment|/* We must be tearing the block queue down already */
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * To start with, we keep looping until the queue is empty, or until&n;&t; * the host is no longer able to accept any more requests.&n;&t; */
r_while
c_loop
(paren
op_logical_neg
id|blk_queue_plugged
c_func
(paren
id|q
)paren
)paren
(brace
r_int
id|rtn
suffix:semicolon
multiline_comment|/*&n;&t;&t; * get next queueable request.  We do this early to make sure&n;&t;&t; * that the request is fully prepared even if we cannot &n;&t;&t; * accept it.&n;&t;&t; */
id|req
op_assign
id|elv_next_request
c_func
(paren
id|q
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|req
op_logical_or
op_logical_neg
id|scsi_dev_queue_ready
c_func
(paren
id|q
comma
id|sdev
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|scsi_device_online
c_func
(paren
id|sdev
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;scsi%d (%d:%d): rejecting I/O to offline device&bslash;n&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
)paren
suffix:semicolon
id|blkdev_dequeue_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|req-&gt;flags
op_or_assign
id|REQ_QUIET
suffix:semicolon
r_while
c_loop
(paren
id|end_that_request_first
c_func
(paren
id|req
comma
l_int|0
comma
id|req-&gt;nr_sectors
)paren
)paren
suffix:semicolon
id|end_that_request_last
c_func
(paren
id|req
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Remove the request from the request list.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|blk_queue_tagged
c_func
(paren
id|q
)paren
op_logical_and
op_logical_neg
id|blk_queue_start_tag
c_func
(paren
id|q
comma
id|req
)paren
)paren
)paren
id|blkdev_dequeue_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|sdev-&gt;device_busy
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
id|q-&gt;queue_lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
id|shost-&gt;host_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_host_queue_ready
c_func
(paren
id|q
comma
id|shost
comma
id|sdev
)paren
)paren
r_goto
id|not_ready
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;single_lun
)paren
(brace
r_if
c_cond
(paren
id|scsi_target
c_func
(paren
id|sdev
)paren
op_member_access_from_pointer
id|starget_sdev_user
op_logical_and
id|scsi_target
c_func
(paren
id|sdev
)paren
op_member_access_from_pointer
id|starget_sdev_user
op_ne
id|sdev
)paren
r_goto
id|not_ready
suffix:semicolon
id|scsi_target
c_func
(paren
id|sdev
)paren
op_member_access_from_pointer
id|starget_sdev_user
op_assign
id|sdev
suffix:semicolon
)brace
id|shost-&gt;host_busy
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * XXX(hch): This is rather suboptimal, scsi_dispatch_cmd will&n;&t;&t; *&t;&t;take the lock again.&n;&t;&t; */
id|spin_unlock_irq
c_func
(paren
id|shost-&gt;host_lock
)paren
suffix:semicolon
id|cmd
op_assign
id|req-&gt;special
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|cmd
op_eq
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;impossible request in %s.&bslash;n&quot;
l_string|&quot;please mail a stack trace to &quot;
l_string|&quot;linux-scsi@vger.kernel.org&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Finally, initialize any error handling parameters, and set up&n;&t;&t; * the timers for timeouts.&n;&t;&t; */
id|scsi_init_cmd_errh
c_func
(paren
id|cmd
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Dispatch the command to the low-level driver.&n;&t;&t; */
id|rtn
op_assign
id|scsi_dispatch_cmd
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
id|q-&gt;queue_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
)paren
(brace
multiline_comment|/* we&squot;re refusing the command; because of&n;&t;&t;&t; * the way locks get dropped, we need to &n;&t;&t;&t; * check here if plugging is required */
r_if
c_cond
(paren
id|sdev-&gt;device_busy
op_eq
l_int|0
)paren
(brace
id|blk_plug_device
c_func
(paren
id|q
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
r_goto
id|out
suffix:semicolon
id|not_ready
suffix:colon
id|spin_unlock_irq
c_func
(paren
id|shost-&gt;host_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * lock q, handle tag, requeue req, and decrement device_busy. We&n;&t; * must return with queue_lock held.&n;&t; *&n;&t; * Decrementing device_busy without checking it is OK, as all such&n;&t; * cases (host limits or settings) should run the queue at some&n;&t; * later time.&n;&t; */
id|spin_lock_irq
c_func
(paren
id|q-&gt;queue_lock
)paren
suffix:semicolon
id|blk_requeue_request
c_func
(paren
id|q
comma
id|req
)paren
suffix:semicolon
id|sdev-&gt;device_busy
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;device_busy
op_eq
l_int|0
)paren
(brace
id|blk_plug_device
c_func
(paren
id|q
)paren
suffix:semicolon
)brace
id|out
suffix:colon
multiline_comment|/* must be careful here...if we trigger the -&gt;remove() function&n;&t; * we cannot be holding the q lock */
id|spin_unlock_irq
c_func
(paren
id|q-&gt;queue_lock
)paren
suffix:semicolon
id|put_device
c_func
(paren
op_amp
id|sdev-&gt;sdev_gendev
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
id|q-&gt;queue_lock
)paren
suffix:semicolon
)brace
DECL|function|scsi_calculate_bounce_limit
id|u64
id|scsi_calculate_bounce_limit
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
)paren
(brace
r_struct
id|device
op_star
id|host_dev
suffix:semicolon
id|u64
id|bounce_limit
op_assign
l_int|0xffffffff
suffix:semicolon
r_if
c_cond
(paren
id|shost-&gt;unchecked_isa_dma
)paren
r_return
id|BLK_BOUNCE_ISA
suffix:semicolon
multiline_comment|/*&n;&t; * Platforms with virtual-DMA translation&n;&t; * hardware have no practical limit.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|PCI_DMA_BUS_IS_PHYS
)paren
r_return
id|BLK_BOUNCE_ANY
suffix:semicolon
id|host_dev
op_assign
id|scsi_get_device
c_func
(paren
id|shost
)paren
suffix:semicolon
r_if
c_cond
(paren
id|host_dev
op_logical_and
id|host_dev-&gt;dma_mask
)paren
id|bounce_limit
op_assign
op_star
id|host_dev-&gt;dma_mask
suffix:semicolon
r_return
id|bounce_limit
suffix:semicolon
)brace
DECL|function|scsi_alloc_queue
r_struct
id|request_queue
op_star
id|scsi_alloc_queue
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|shost
op_assign
id|sdev-&gt;host
suffix:semicolon
r_struct
id|request_queue
op_star
id|q
suffix:semicolon
id|q
op_assign
id|blk_init_queue
c_func
(paren
id|scsi_request_fn
comma
op_amp
id|sdev-&gt;sdev_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q
)paren
r_return
l_int|NULL
suffix:semicolon
id|blk_queue_prep_rq
c_func
(paren
id|q
comma
id|scsi_prep_fn
)paren
suffix:semicolon
id|blk_queue_max_hw_segments
c_func
(paren
id|q
comma
id|shost-&gt;sg_tablesize
)paren
suffix:semicolon
id|blk_queue_max_phys_segments
c_func
(paren
id|q
comma
id|SCSI_MAX_PHYS_SEGMENTS
)paren
suffix:semicolon
id|blk_queue_max_sectors
c_func
(paren
id|q
comma
id|shost-&gt;max_sectors
)paren
suffix:semicolon
id|blk_queue_bounce_limit
c_func
(paren
id|q
comma
id|scsi_calculate_bounce_limit
c_func
(paren
id|shost
)paren
)paren
suffix:semicolon
id|blk_queue_segment_boundary
c_func
(paren
id|q
comma
id|shost-&gt;dma_boundary
)paren
suffix:semicolon
id|blk_queue_issue_flush_fn
c_func
(paren
id|q
comma
id|scsi_issue_flush_fn
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|shost-&gt;use_clustering
)paren
id|clear_bit
c_func
(paren
id|QUEUE_FLAG_CLUSTER
comma
op_amp
id|q-&gt;queue_flags
)paren
suffix:semicolon
r_return
id|q
suffix:semicolon
)brace
DECL|function|scsi_free_queue
r_void
id|scsi_free_queue
c_func
(paren
r_struct
id|request_queue
op_star
id|q
)paren
(brace
id|blk_cleanup_queue
c_func
(paren
id|q
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_block_requests()&n; *&n; * Purpose:     Utility function used by low-level drivers to prevent further&n; *&t;&t;commands from being queued to the device.&n; *&n; * Arguments:   shost       - Host in question&n; *&n; * Returns:     Nothing&n; *&n; * Lock status: No locks are assumed held.&n; *&n; * Notes:       There is no timer nor any other means by which the requests&n; *&t;&t;get unblocked other than the low-level driver calling&n; *&t;&t;scsi_unblock_requests().&n; */
DECL|function|scsi_block_requests
r_void
id|scsi_block_requests
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
)paren
(brace
id|shost-&gt;host_self_blocked
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_unblock_requests()&n; *&n; * Purpose:     Utility function used by low-level drivers to allow further&n; *&t;&t;commands from being queued to the device.&n; *&n; * Arguments:   shost       - Host in question&n; *&n; * Returns:     Nothing&n; *&n; * Lock status: No locks are assumed held.&n; *&n; * Notes:       There is no timer nor any other means by which the requests&n; *&t;&t;get unblocked other than the low-level driver calling&n; *&t;&t;scsi_unblock_requests().&n; *&n; *&t;&t;This is done as an API function so that changes to the&n; *&t;&t;internals of the scsi mid-layer won&squot;t require wholesale&n; *&t;&t;changes to drivers that use this feature.&n; */
DECL|function|scsi_unblock_requests
r_void
id|scsi_unblock_requests
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
)paren
(brace
id|shost-&gt;host_self_blocked
op_assign
l_int|0
suffix:semicolon
id|scsi_run_host_queues
c_func
(paren
id|shost
)paren
suffix:semicolon
)brace
DECL|function|scsi_init_queue
r_int
id|__init
id|scsi_init_queue
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SG_MEMPOOL_NR
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|scsi_host_sg_pool
op_star
id|sgp
op_assign
id|scsi_sg_pools
op_plus
id|i
suffix:semicolon
r_int
id|size
op_assign
id|sgp-&gt;size
op_star
r_sizeof
(paren
r_struct
id|scatterlist
)paren
suffix:semicolon
id|sgp-&gt;slab
op_assign
id|kmem_cache_create
c_func
(paren
id|sgp-&gt;name
comma
id|size
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sgp-&gt;slab
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;SCSI: can&squot;t init sg slab %s&bslash;n&quot;
comma
id|sgp-&gt;name
)paren
suffix:semicolon
)brace
id|sgp-&gt;pool
op_assign
id|mempool_create
c_func
(paren
id|SG_MEMPOOL_SIZE
comma
id|mempool_alloc_slab
comma
id|mempool_free_slab
comma
id|sgp-&gt;slab
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sgp-&gt;pool
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;SCSI: can&squot;t init sg mempool %s&bslash;n&quot;
comma
id|sgp-&gt;name
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|scsi_exit_queue
r_void
id|scsi_exit_queue
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SG_MEMPOOL_NR
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|scsi_host_sg_pool
op_star
id|sgp
op_assign
id|scsi_sg_pools
op_plus
id|i
suffix:semicolon
id|mempool_destroy
c_func
(paren
id|sgp-&gt;pool
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|sgp-&gt;slab
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;__scsi_mode_sense - issue a mode sense, falling back from 10 to &n; *&t;&t;six bytes if necessary.&n; *&t;@sreq:&t;SCSI request to fill in with the MODE_SENSE&n; *&t;@dbd:&t;set if mode sense will allow block descriptors to be returned&n; *&t;@modepage: mode page being requested&n; *&t;@buffer: request buffer (may not be smaller than eight bytes)&n; *&t;@len:&t;length of request buffer.&n; *&t;@timeout: command timeout&n; *&t;@retries: number of retries before failing&n; *&t;@data: returns a structure abstracting the mode header data&n; *&n; *&t;Returns zero if unsuccessful, or the header offset (either 4&n; *&t;or 8 depending on whether a six or ten byte command was&n; *&t;issued) if successful.&n; **/
r_int
DECL|function|__scsi_mode_sense
id|__scsi_mode_sense
c_func
(paren
r_struct
id|scsi_request
op_star
id|sreq
comma
r_int
id|dbd
comma
r_int
id|modepage
comma
r_int
r_char
op_star
id|buffer
comma
r_int
id|len
comma
r_int
id|timeout
comma
r_int
id|retries
comma
r_struct
id|scsi_mode_data
op_star
id|data
)paren
(brace
r_int
r_char
id|cmd
(braket
l_int|12
)braket
suffix:semicolon
r_int
id|use_10_for_ms
suffix:semicolon
r_int
id|header_length
suffix:semicolon
id|memset
c_func
(paren
id|data
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|data
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|cmd
(braket
l_int|0
)braket
comma
l_int|0
comma
l_int|12
)paren
suffix:semicolon
id|cmd
(braket
l_int|1
)braket
op_assign
id|dbd
op_amp
l_int|0x18
suffix:semicolon
multiline_comment|/* allows DBD and LLBA bits */
id|cmd
(braket
l_int|2
)braket
op_assign
id|modepage
suffix:semicolon
id|retry
suffix:colon
id|use_10_for_ms
op_assign
id|sreq-&gt;sr_device-&gt;use_10_for_ms
suffix:semicolon
r_if
c_cond
(paren
id|use_10_for_ms
)paren
(brace
r_if
c_cond
(paren
id|len
OL
l_int|8
)paren
id|len
op_assign
l_int|8
suffix:semicolon
id|cmd
(braket
l_int|0
)braket
op_assign
id|MODE_SENSE_10
suffix:semicolon
id|cmd
(braket
l_int|8
)braket
op_assign
id|len
suffix:semicolon
id|header_length
op_assign
l_int|8
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|len
OL
l_int|4
)paren
id|len
op_assign
l_int|4
suffix:semicolon
id|cmd
(braket
l_int|0
)braket
op_assign
id|MODE_SENSE
suffix:semicolon
id|cmd
(braket
l_int|4
)braket
op_assign
id|len
suffix:semicolon
id|header_length
op_assign
l_int|4
suffix:semicolon
)brace
id|sreq-&gt;sr_cmd_len
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|sreq-&gt;sr_sense_buffer
comma
l_int|0
comma
r_sizeof
(paren
id|sreq-&gt;sr_sense_buffer
)paren
)paren
suffix:semicolon
id|sreq-&gt;sr_data_direction
op_assign
id|DMA_FROM_DEVICE
suffix:semicolon
id|memset
c_func
(paren
id|buffer
comma
l_int|0
comma
id|len
)paren
suffix:semicolon
id|scsi_wait_req
c_func
(paren
id|sreq
comma
id|cmd
comma
id|buffer
comma
id|len
comma
id|timeout
comma
id|retries
)paren
suffix:semicolon
multiline_comment|/* This code looks awful: what it&squot;s doing is making sure an&n;&t; * ILLEGAL REQUEST sense return identifies the actual command&n;&t; * byte as the problem.  MODE_SENSE commands can return&n;&t; * ILLEGAL REQUEST if the code page isn&squot;t supported */
r_if
c_cond
(paren
id|use_10_for_ms
op_logical_and
op_logical_neg
id|scsi_status_is_good
c_func
(paren
id|sreq-&gt;sr_result
)paren
op_logical_and
(paren
id|driver_byte
c_func
(paren
id|sreq-&gt;sr_result
)paren
op_amp
id|DRIVER_SENSE
)paren
)paren
(brace
r_struct
id|scsi_sense_hdr
id|sshdr
suffix:semicolon
r_if
c_cond
(paren
id|scsi_request_normalize_sense
c_func
(paren
id|sreq
comma
op_amp
id|sshdr
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|sshdr.sense_key
op_eq
id|ILLEGAL_REQUEST
)paren
op_logical_and
(paren
id|sshdr.asc
op_eq
l_int|0x20
)paren
op_logical_and
(paren
id|sshdr.ascq
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t;&t;&t; * Invalid command operation code&n;&t;&t;&t;&t; */
id|sreq-&gt;sr_device-&gt;use_10_for_ms
op_assign
l_int|0
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|scsi_status_is_good
c_func
(paren
id|sreq-&gt;sr_result
)paren
)paren
(brace
id|data-&gt;header_length
op_assign
id|header_length
suffix:semicolon
r_if
c_cond
(paren
id|use_10_for_ms
)paren
(brace
id|data-&gt;length
op_assign
id|buffer
(braket
l_int|0
)braket
op_star
l_int|256
op_plus
id|buffer
(braket
l_int|1
)braket
op_plus
l_int|2
suffix:semicolon
id|data-&gt;medium_type
op_assign
id|buffer
(braket
l_int|2
)braket
suffix:semicolon
id|data-&gt;device_specific
op_assign
id|buffer
(braket
l_int|3
)braket
suffix:semicolon
id|data-&gt;longlba
op_assign
id|buffer
(braket
l_int|4
)braket
op_amp
l_int|0x01
suffix:semicolon
id|data-&gt;block_descriptor_length
op_assign
id|buffer
(braket
l_int|6
)braket
op_star
l_int|256
op_plus
id|buffer
(braket
l_int|7
)braket
suffix:semicolon
)brace
r_else
(brace
id|data-&gt;length
op_assign
id|buffer
(braket
l_int|0
)braket
op_plus
l_int|1
suffix:semicolon
id|data-&gt;medium_type
op_assign
id|buffer
(braket
l_int|1
)braket
suffix:semicolon
id|data-&gt;device_specific
op_assign
id|buffer
(braket
l_int|2
)braket
suffix:semicolon
id|data-&gt;block_descriptor_length
op_assign
id|buffer
(braket
l_int|3
)braket
suffix:semicolon
)brace
)brace
r_return
id|sreq-&gt;sr_result
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;scsi_mode_sense - issue a mode sense, falling back from 10 to &n; *&t;&t;six bytes if necessary.&n; *&t;@sdev:&t;scsi device to send command to.&n; *&t;@dbd:&t;set if mode sense will disable block descriptors in the return&n; *&t;@modepage: mode page being requested&n; *&t;@buffer: request buffer (may not be smaller than eight bytes)&n; *&t;@len:&t;length of request buffer.&n; *&t;@timeout: command timeout&n; *&t;@retries: number of retries before failing&n; *&n; *&t;Returns zero if unsuccessful, or the header offset (either 4&n; *&t;or 8 depending on whether a six or ten byte command was&n; *&t;issued) if successful.&n; **/
r_int
DECL|function|scsi_mode_sense
id|scsi_mode_sense
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
comma
r_int
id|dbd
comma
r_int
id|modepage
comma
r_int
r_char
op_star
id|buffer
comma
r_int
id|len
comma
r_int
id|timeout
comma
r_int
id|retries
comma
r_struct
id|scsi_mode_data
op_star
id|data
)paren
(brace
r_struct
id|scsi_request
op_star
id|sreq
op_assign
id|scsi_allocate_request
c_func
(paren
id|sdev
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sreq
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|ret
op_assign
id|__scsi_mode_sense
c_func
(paren
id|sreq
comma
id|dbd
comma
id|modepage
comma
id|buffer
comma
id|len
comma
id|timeout
comma
id|retries
comma
id|data
)paren
suffix:semicolon
id|scsi_release_request
c_func
(paren
id|sreq
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_int
DECL|function|scsi_test_unit_ready
id|scsi_test_unit_ready
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
comma
r_int
id|timeout
comma
r_int
id|retries
)paren
(brace
r_struct
id|scsi_request
op_star
id|sreq
suffix:semicolon
r_char
id|cmd
(braket
)braket
op_assign
(brace
id|TEST_UNIT_READY
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
)brace
suffix:semicolon
r_int
id|result
suffix:semicolon
id|sreq
op_assign
id|scsi_allocate_request
c_func
(paren
id|sdev
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sreq
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|sreq-&gt;sr_data_direction
op_assign
id|DMA_NONE
suffix:semicolon
id|scsi_wait_req
c_func
(paren
id|sreq
comma
id|cmd
comma
l_int|NULL
comma
l_int|0
comma
id|timeout
comma
id|retries
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|driver_byte
c_func
(paren
id|sreq-&gt;sr_result
)paren
op_amp
id|DRIVER_SENSE
)paren
op_logical_and
id|sdev-&gt;removable
)paren
(brace
r_struct
id|scsi_sense_hdr
id|sshdr
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scsi_request_normalize_sense
c_func
(paren
id|sreq
comma
op_amp
id|sshdr
)paren
)paren
op_logical_and
(paren
(paren
id|sshdr.sense_key
op_eq
id|UNIT_ATTENTION
)paren
op_logical_or
(paren
id|sshdr.sense_key
op_eq
id|NOT_READY
)paren
)paren
)paren
(brace
id|sdev-&gt;changed
op_assign
l_int|1
suffix:semicolon
id|sreq-&gt;sr_result
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|result
op_assign
id|sreq-&gt;sr_result
suffix:semicolon
id|scsi_release_request
c_func
(paren
id|sreq
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|variable|scsi_test_unit_ready
id|EXPORT_SYMBOL
c_func
(paren
id|scsi_test_unit_ready
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;scsi_device_set_state - Take the given device through the device&n; *&t;&t;state model.&n; *&t;@sdev:&t;scsi device to change the state of.&n; *&t;@state:&t;state to change to.&n; *&n; *&t;Returns zero if unsuccessful or an error if the requested &n; *&t;transition is illegal.&n; **/
r_int
DECL|function|scsi_device_set_state
id|scsi_device_set_state
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
comma
r_enum
id|scsi_device_state
id|state
)paren
(brace
r_enum
id|scsi_device_state
id|oldstate
op_assign
id|sdev-&gt;sdev_state
suffix:semicolon
r_if
c_cond
(paren
id|state
op_eq
id|oldstate
)paren
r_return
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|state
)paren
(brace
r_case
id|SDEV_CREATED
suffix:colon
multiline_comment|/* There are no legal states that come back to&n;&t;&t; * created.  This is the manually initialised start&n;&t;&t; * state */
r_goto
id|illegal
suffix:semicolon
r_case
id|SDEV_RUNNING
suffix:colon
r_switch
c_cond
(paren
id|oldstate
)paren
(brace
r_case
id|SDEV_CREATED
suffix:colon
r_case
id|SDEV_OFFLINE
suffix:colon
r_case
id|SDEV_QUIESCE
suffix:colon
r_case
id|SDEV_BLOCK
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_goto
id|illegal
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SDEV_QUIESCE
suffix:colon
r_switch
c_cond
(paren
id|oldstate
)paren
(brace
r_case
id|SDEV_RUNNING
suffix:colon
r_case
id|SDEV_OFFLINE
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_goto
id|illegal
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SDEV_OFFLINE
suffix:colon
r_switch
c_cond
(paren
id|oldstate
)paren
(brace
r_case
id|SDEV_CREATED
suffix:colon
r_case
id|SDEV_RUNNING
suffix:colon
r_case
id|SDEV_QUIESCE
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_goto
id|illegal
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SDEV_BLOCK
suffix:colon
r_switch
c_cond
(paren
id|oldstate
)paren
(brace
r_case
id|SDEV_CREATED
suffix:colon
r_case
id|SDEV_RUNNING
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_goto
id|illegal
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SDEV_CANCEL
suffix:colon
r_switch
c_cond
(paren
id|oldstate
)paren
(brace
r_case
id|SDEV_CREATED
suffix:colon
r_case
id|SDEV_RUNNING
suffix:colon
r_case
id|SDEV_OFFLINE
suffix:colon
r_case
id|SDEV_BLOCK
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_goto
id|illegal
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SDEV_DEL
suffix:colon
r_switch
c_cond
(paren
id|oldstate
)paren
(brace
r_case
id|SDEV_CANCEL
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_goto
id|illegal
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|sdev-&gt;sdev_state
op_assign
id|state
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|illegal
suffix:colon
id|dev_printk
c_func
(paren
id|KERN_ERR
comma
op_amp
id|sdev-&gt;sdev_gendev
comma
l_string|&quot;Illegal state transition %s-&gt;%s&bslash;n&quot;
comma
id|scsi_device_state_name
c_func
(paren
id|oldstate
)paren
comma
id|scsi_device_state_name
c_func
(paren
id|state
)paren
)paren
suffix:semicolon
id|WARN_ON
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|variable|scsi_device_set_state
id|EXPORT_SYMBOL
c_func
(paren
id|scsi_device_set_state
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;scsi_device_quiesce - Block user issued commands.&n; *&t;@sdev:&t;scsi device to quiesce.&n; *&n; *&t;This works by trying to transition to the SDEV_QUIESCE state&n; *&t;(which must be a legal transition).  When the device is in this&n; *&t;state, only special requests will be accepted, all others will&n; *&t;be deferred.  Since special requests may also be requeued requests,&n; *&t;a successful return doesn&squot;t guarantee the device will be &n; *&t;totally quiescent.&n; *&n; *&t;Must be called with user context, may sleep.&n; *&n; *&t;Returns zero if unsuccessful or an error if not.&n; **/
r_int
DECL|function|scsi_device_quiesce
id|scsi_device_quiesce
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
)paren
(brace
r_int
id|err
op_assign
id|scsi_device_set_state
c_func
(paren
id|sdev
comma
id|SDEV_QUIESCE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|scsi_run_queue
c_func
(paren
id|sdev-&gt;request_queue
)paren
suffix:semicolon
r_while
c_loop
(paren
id|sdev-&gt;device_busy
)paren
(brace
id|msleep_interruptible
c_func
(paren
l_int|200
)paren
suffix:semicolon
id|scsi_run_queue
c_func
(paren
id|sdev-&gt;request_queue
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|scsi_device_quiesce
id|EXPORT_SYMBOL
c_func
(paren
id|scsi_device_quiesce
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;scsi_device_resume - Restart user issued commands to a quiesced device.&n; *&t;@sdev:&t;scsi device to resume.&n; *&n; *&t;Moves the device from quiesced back to running and restarts the&n; *&t;queues.&n; *&n; *&t;Must be called with user context, may sleep.&n; **/
r_void
DECL|function|scsi_device_resume
id|scsi_device_resume
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
)paren
(brace
r_if
c_cond
(paren
id|scsi_device_set_state
c_func
(paren
id|sdev
comma
id|SDEV_RUNNING
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
id|scsi_run_queue
c_func
(paren
id|sdev-&gt;request_queue
)paren
suffix:semicolon
)brace
DECL|variable|scsi_device_resume
id|EXPORT_SYMBOL
c_func
(paren
id|scsi_device_resume
)paren
suffix:semicolon
r_static
r_int
DECL|function|device_quiesce_fn
id|device_quiesce_fn
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_void
op_star
id|data
)paren
(brace
id|scsi_device_quiesce
c_func
(paren
id|to_scsi_device
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|scsi_target_quiesce
id|scsi_target_quiesce
c_func
(paren
r_struct
id|scsi_target
op_star
id|starget
)paren
(brace
id|device_for_each_child
c_func
(paren
op_amp
id|starget-&gt;dev
comma
l_int|NULL
comma
id|device_quiesce_fn
)paren
suffix:semicolon
)brace
DECL|variable|scsi_target_quiesce
id|EXPORT_SYMBOL
c_func
(paren
id|scsi_target_quiesce
)paren
suffix:semicolon
r_static
r_int
DECL|function|device_resume_fn
id|device_resume_fn
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_void
op_star
id|data
)paren
(brace
id|scsi_device_resume
c_func
(paren
id|to_scsi_device
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|scsi_target_resume
id|scsi_target_resume
c_func
(paren
r_struct
id|scsi_target
op_star
id|starget
)paren
(brace
id|device_for_each_child
c_func
(paren
op_amp
id|starget-&gt;dev
comma
l_int|NULL
comma
id|device_resume_fn
)paren
suffix:semicolon
)brace
DECL|variable|scsi_target_resume
id|EXPORT_SYMBOL
c_func
(paren
id|scsi_target_resume
)paren
suffix:semicolon
multiline_comment|/**&n; * scsi_internal_device_block - internal function to put a device&n; *&t;&t;&t;&t;temporarily into the SDEV_BLOCK state&n; * @sdev:&t;device to block&n; *&n; * Block request made by scsi lld&squot;s to temporarily stop all&n; * scsi commands on the specified device.  Called from interrupt&n; * or normal process context.&n; *&n; * Returns zero if successful or error if not&n; *&n; * Notes:       &n; *&t;This routine transitions the device to the SDEV_BLOCK state&n; *&t;(which must be a legal transition).  When the device is in this&n; *&t;state, all commands are deferred until the scsi lld reenables&n; *&t;the device with scsi_device_unblock or device_block_tmo fires.&n; *&t;This routine assumes the host_lock is held on entry.&n; **/
r_int
DECL|function|scsi_internal_device_block
id|scsi_internal_device_block
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
)paren
(brace
id|request_queue_t
op_star
id|q
op_assign
id|sdev-&gt;request_queue
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
id|scsi_device_set_state
c_func
(paren
id|sdev
comma
id|SDEV_BLOCK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
multiline_comment|/* &n;&t; * The device has transitioned to SDEV_BLOCK.  Stop the&n;&t; * block layer from calling the midlayer with this device&squot;s&n;&t; * request queue. &n;&t; */
id|spin_lock_irqsave
c_func
(paren
id|q-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
id|blk_stop_queue
c_func
(paren
id|q
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|q-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|scsi_internal_device_block
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|scsi_internal_device_block
)paren
suffix:semicolon
multiline_comment|/**&n; * scsi_internal_device_unblock - resume a device after a block request&n; * @sdev:&t;device to resume&n; *&n; * Called by scsi lld&squot;s or the midlayer to restart the device queue&n; * for the previously suspended scsi device.  Called from interrupt or&n; * normal process context.&n; *&n; * Returns zero if successful or error if not.&n; *&n; * Notes:       &n; *&t;This routine transitions the device to the SDEV_RUNNING state&n; *&t;(which must be a legal transition) allowing the midlayer to&n; *&t;goose the queue for this device.  This routine assumes the &n; *&t;host_lock is held upon entry.&n; **/
r_int
DECL|function|scsi_internal_device_unblock
id|scsi_internal_device_unblock
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
)paren
(brace
id|request_queue_t
op_star
id|q
op_assign
id|sdev-&gt;request_queue
suffix:semicolon
r_int
id|err
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* &n;&t; * Try to transition the scsi device to SDEV_RUNNING&n;&t; * and goose the device queue if successful.  &n;&t; */
id|err
op_assign
id|scsi_device_set_state
c_func
(paren
id|sdev
comma
id|SDEV_RUNNING
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|q-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
id|blk_start_queue
c_func
(paren
id|q
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|q-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|scsi_internal_device_unblock
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|scsi_internal_device_unblock
)paren
suffix:semicolon
eof
