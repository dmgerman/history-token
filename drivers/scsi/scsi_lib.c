multiline_comment|/*&n; *  scsi_lib.c Copyright (C) 1999 Eric Youngdale&n; *&n; *  SCSI queueing library.&n; *      Initial versions: Eric Youngdale (eric@andante.org).&n; *                        Based upon conversations with large numbers&n; *                        of people at Linux Expo.&n; */
macro_line|#include &lt;linux/bio.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/completion.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
multiline_comment|/*&n; * Function:    scsi_insert_special_cmd()&n; *&n; * Purpose:     Insert pre-formed command into request queue.&n; *&n; * Arguments:   SCpnt   - command that is ready to be queued.&n; *              at_head - boolean.  True if we should insert at head&n; *                        of queue, false if we should insert at tail.&n; *&n; * Lock status: Assumed that lock is not held upon entry.&n; *&n; * Returns:     Nothing&n; *&n; * Notes:       This function is called from character device and from&n; *              ioctl types of functions where the caller knows exactly&n; *              what SCSI command needs to be issued.   The idea is that&n; *              we merely inject the command into the queue (at the head&n; *              for now), and then call the queue request function to actually&n; *              process it.&n; */
DECL|function|scsi_insert_special_cmd
r_int
id|scsi_insert_special_cmd
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
id|at_head
)paren
(brace
id|request_queue_t
op_star
id|q
op_assign
op_amp
id|SCpnt-&gt;device-&gt;request_queue
suffix:semicolon
id|blk_insert_request
c_func
(paren
id|q
comma
id|SCpnt-&gt;request
comma
id|at_head
comma
id|SCpnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_insert_special_req()&n; *&n; * Purpose:     Insert pre-formed request into request queue.&n; *&n; * Arguments:   SRpnt   - request that is ready to be queued.&n; *              at_head - boolean.  True if we should insert at head&n; *                        of queue, false if we should insert at tail.&n; *&n; * Lock status: Assumed that lock is not held upon entry.&n; *&n; * Returns:     Nothing&n; *&n; * Notes:       This function is called from character device and from&n; *              ioctl types of functions where the caller knows exactly&n; *              what SCSI command needs to be issued.   The idea is that&n; *              we merely inject the command into the queue (at the head&n; *              for now), and then call the queue request function to actually&n; *              process it.&n; */
DECL|function|scsi_insert_special_req
r_int
id|scsi_insert_special_req
c_func
(paren
id|Scsi_Request
op_star
id|SRpnt
comma
r_int
id|at_head
)paren
(brace
id|request_queue_t
op_star
id|q
op_assign
op_amp
id|SRpnt-&gt;sr_device-&gt;request_queue
suffix:semicolon
multiline_comment|/* This is used to insert SRpnt specials.  Because users of&n;&t; * this function are apt to reuse requests with no modification,&n;&t; * we have to sanitise the request flags here&n;&t; */
id|SRpnt-&gt;sr_request-&gt;flags
op_and_assign
op_complement
id|REQ_DONTPREP
suffix:semicolon
id|blk_insert_request
c_func
(paren
id|q
comma
id|SRpnt-&gt;sr_request
comma
id|at_head
comma
id|SRpnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_init_cmd_errh()&n; *&n; * Purpose:     Initialize SCpnt fields related to error handling.&n; *&n; * Arguments:   SCpnt   - command that is ready to be queued.&n; *&n; * Returns:     Nothing&n; *&n; * Notes:       This function has the job of initializing a number of&n; *              fields related to error handling.   Typically this will&n; *              be called once for each command, as required.&n; */
DECL|function|scsi_init_cmd_errh
r_static
r_int
id|scsi_init_cmd_errh
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_MIDLEVEL
suffix:semicolon
id|SCpnt-&gt;reset_chain
op_assign
l_int|NULL
suffix:semicolon
id|SCpnt-&gt;serial_number
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;serial_number_at_timeout
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;retries
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;abort_reason
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
id|SCpnt-&gt;sense_buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;cmd_len
op_eq
l_int|0
)paren
id|SCpnt-&gt;cmd_len
op_assign
id|COMMAND_SIZE
c_func
(paren
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We need saved copies of a number of fields - this is because&n;&t; * error handling may need to overwrite these with different values&n;&t; * to run different commands, and once error handling is complete,&n;&t; * we will need to restore these values prior to running the actual&n;&t; * command.&n;&t; */
id|SCpnt-&gt;old_use_sg
op_assign
id|SCpnt-&gt;use_sg
suffix:semicolon
id|SCpnt-&gt;old_cmd_len
op_assign
id|SCpnt-&gt;cmd_len
suffix:semicolon
id|SCpnt-&gt;sc_old_data_direction
op_assign
id|SCpnt-&gt;sc_data_direction
suffix:semicolon
id|SCpnt-&gt;old_underflow
op_assign
id|SCpnt-&gt;underflow
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;data_cmnd
comma
(paren
r_const
r_void
op_star
)paren
id|SCpnt-&gt;cmnd
comma
r_sizeof
(paren
id|SCpnt-&gt;cmnd
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;buffer
op_assign
id|SCpnt-&gt;request_buffer
suffix:semicolon
id|SCpnt-&gt;bufflen
op_assign
id|SCpnt-&gt;request_bufflen
suffix:semicolon
id|SCpnt-&gt;reset_chain
op_assign
l_int|NULL
suffix:semicolon
id|SCpnt-&gt;internal_timeout
op_assign
id|NORMAL_TIMEOUT
suffix:semicolon
id|SCpnt-&gt;abort_reason
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:   scsi_setup_cmd_retry()&n; *&n; * Purpose:    Restore the command state for a retry&n; *&n; * Arguments:  SCpnt   - command to be restored&n; *&n; * Returns:    Nothing&n; *&n; * Notes:      Immediately prior to retrying a command, we need&n; *             to restore certain fields that we saved above.&n; */
DECL|function|scsi_setup_cmd_retry
r_void
id|scsi_setup_cmd_retry
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;cmnd
comma
(paren
r_void
op_star
)paren
id|SCpnt-&gt;data_cmnd
comma
r_sizeof
(paren
id|SCpnt-&gt;data_cmnd
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
id|SCpnt-&gt;buffer
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
id|SCpnt-&gt;bufflen
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
id|SCpnt-&gt;old_use_sg
suffix:semicolon
id|SCpnt-&gt;cmd_len
op_assign
id|SCpnt-&gt;old_cmd_len
suffix:semicolon
id|SCpnt-&gt;sc_data_direction
op_assign
id|SCpnt-&gt;sc_old_data_direction
suffix:semicolon
id|SCpnt-&gt;underflow
op_assign
id|SCpnt-&gt;old_underflow
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_queue_next_request()&n; *&n; * Purpose:     Handle post-processing of completed commands.&n; *&n; * Arguments:   SCpnt   - command that may need to be requeued.&n; *&n; * Returns:     Nothing&n; *&n; * Notes:       After command completion, there may be blocks left&n; *              over which weren&squot;t finished by the previous command&n; *              this can be for a number of reasons - the main one is&n; *              that a medium error occurred, and the sectors after&n; *              the bad block need to be re-read.&n; *&n; *              If SCpnt is NULL, it means that the previous command&n; *              was completely finished, and we should simply start&n; *              a new command, if possible.&n; *&n; *&t;&t;This is where a lot of special case code has begun to&n; *&t;&t;accumulate.  It doesn&squot;t really affect readability or&n; *&t;&t;anything, but it might be considered architecturally&n; *&t;&t;inelegant.  If more of these special cases start to&n; *&t;&t;accumulate, I am thinking along the lines of implementing&n; *&t;&t;an atexit() like technology that gets run when commands&n; *&t;&t;complete.  I am not convinced that it is worth the&n; *&t;&t;added overhead, however.  Right now as things stand,&n; *&t;&t;there are simple conditional checks, and most hosts&n; *&t;&t;would skip past.&n; *&n; *&t;&t;Another possible solution would be to tailor different&n; *&t;&t;handler functions, sort of like what we did in scsi_merge.c.&n; *&t;&t;This is probably a better solution, but the number of different&n; *&t;&t;permutations grows as 2**N, and if too many more special cases&n; *&t;&t;get added, we start to get screwed.&n; */
DECL|function|scsi_queue_next_request
r_void
id|scsi_queue_next_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
id|all_clear
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|SHpnt
suffix:semicolon
id|ASSERT_LOCK
c_func
(paren
id|q-&gt;queue_lock
comma
l_int|0
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|q-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * For some reason, we are not done with this request.&n;&t;&t; * This happens for I/O errors in the middle of the request,&n;&t;&t; * in which case we need to request the blocks that come after&n;&t;&t; * the bad sector.&n;&t;&t; */
id|SCpnt-&gt;request-&gt;special
op_assign
(paren
r_void
op_star
)paren
id|SCpnt
suffix:semicolon
r_if
c_cond
(paren
id|blk_rq_tagged
c_func
(paren
id|SCpnt-&gt;request
)paren
)paren
(brace
id|blk_queue_end_tag
c_func
(paren
id|q
comma
id|SCpnt-&gt;request
)paren
suffix:semicolon
)brace
multiline_comment|/* set REQ_SPECIAL - we have a command&n;&t;&t; * clear REQ_DONTPREP - we assume the sg table has been &n;&t;&t; *&t;nuked so we need to set it up again.&n;&t;&t; */
id|SCpnt-&gt;request-&gt;flags
op_or_assign
id|REQ_SPECIAL
suffix:semicolon
id|SCpnt-&gt;request-&gt;flags
op_and_assign
op_complement
id|REQ_DONTPREP
suffix:semicolon
id|__elv_add_request
c_func
(paren
id|q
comma
id|SCpnt-&gt;request
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Just hit the requeue function for the queue.&n;&t; */
id|__blk_run_queue
c_func
(paren
id|q
)paren
suffix:semicolon
id|SDpnt
op_assign
(paren
id|Scsi_Device
op_star
)paren
id|q-&gt;queuedata
suffix:semicolon
id|SHpnt
op_assign
id|SDpnt-&gt;host
suffix:semicolon
multiline_comment|/*&n;&t; * If this is a single-lun device, and we are currently finished&n;&t; * with this device, then see if we need to get another device&n;&t; * started.  FIXME(eric) - if this function gets too cluttered&n;&t; * with special case code, then spin off separate versions and&n;&t; * use function pointers to pick the right one.&n;&t; */
r_if
c_cond
(paren
id|SDpnt-&gt;single_lun
op_logical_and
id|blk_queue_empty
c_func
(paren
id|q
)paren
op_logical_and
id|SDpnt-&gt;device_busy
op_eq
l_int|0
)paren
(brace
id|list_for_each_entry
c_func
(paren
id|SDpnt
comma
op_amp
id|SHpnt-&gt;my_devices
comma
id|siblings
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|SHpnt-&gt;can_queue
OG
l_int|0
)paren
op_logical_and
(paren
id|SHpnt-&gt;host_busy
op_ge
id|SHpnt-&gt;can_queue
)paren
)paren
op_logical_or
(paren
id|SHpnt-&gt;host_blocked
)paren
op_logical_or
(paren
id|SHpnt-&gt;host_self_blocked
)paren
op_logical_or
(paren
id|SDpnt-&gt;device_blocked
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|__blk_run_queue
c_func
(paren
op_amp
id|SDpnt-&gt;request_queue
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Now see whether there are other devices on the bus which&n;&t; * might be starved.  If so, hit the request function.  If we&n;&t; * don&squot;t find any, then it is safe to reset the flag.  If we&n;&t; * find any device that it is starved, it isn&squot;t safe to reset the&n;&t; * flag as the queue function releases the lock and thus some&n;&t; * other device might have become starved along the way.&n;&t; */
id|all_clear
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|SHpnt-&gt;some_device_starved
)paren
(brace
id|list_for_each_entry
c_func
(paren
id|SDpnt
comma
op_amp
id|SHpnt-&gt;my_devices
comma
id|siblings
)paren
(brace
r_if
c_cond
(paren
(paren
id|SHpnt-&gt;can_queue
OG
l_int|0
op_logical_and
(paren
id|SHpnt-&gt;host_busy
op_ge
id|SHpnt-&gt;can_queue
)paren
)paren
op_logical_or
(paren
id|SHpnt-&gt;host_blocked
)paren
op_logical_or
(paren
id|SHpnt-&gt;host_self_blocked
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SDpnt-&gt;device_blocked
op_logical_or
op_logical_neg
id|SDpnt-&gt;starved
)paren
(brace
r_continue
suffix:semicolon
)brace
id|__blk_run_queue
c_func
(paren
op_amp
id|SDpnt-&gt;request_queue
)paren
suffix:semicolon
id|all_clear
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SDpnt
op_eq
l_int|NULL
op_logical_and
id|all_clear
)paren
(brace
id|SHpnt-&gt;some_device_starved
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
id|q-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_end_request()&n; *&n; * Purpose:     Post-processing of completed commands called from interrupt&n; *              handler or a bottom-half handler.&n; *&n; * Arguments:   SCpnt    - command that is complete.&n; *              uptodate - 1 if I/O indicates success, 0 for I/O error.&n; *              sectors  - number of sectors we want to mark.&n; *&t;&t;requeue  - indicates whether we should requeue leftovers.&n; *&t;&t;frequeue - indicates that if we release the command block&n; *&t;&t;&t;   that the queue request function should be called.&n; *&n; * Lock status: Assumed that lock is not held upon entry.&n; *&n; * Returns:     Nothing&n; *&n; * Notes:       This is called for block device requests in order to&n; *              mark some number of sectors as complete.&n; * &n; *&t;&t;We are guaranteeing that the request queue will be goosed&n; *&t;&t;at some point during this call.&n; */
DECL|function|scsi_end_request
r_static
id|Scsi_Cmnd
op_star
id|scsi_end_request
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
id|uptodate
comma
r_int
id|sectors
comma
r_int
id|requeue
)paren
(brace
id|request_queue_t
op_star
id|q
op_assign
op_amp
id|SCpnt-&gt;device-&gt;request_queue
suffix:semicolon
r_struct
id|request
op_star
id|req
op_assign
id|SCpnt-&gt;request
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|ASSERT_LOCK
c_func
(paren
id|q-&gt;queue_lock
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If there are blocks left over at the end, set up the command&n;&t; * to queue the remainder of them.&n;&t; */
r_if
c_cond
(paren
id|end_that_request_first
c_func
(paren
id|req
comma
id|uptodate
comma
id|sectors
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|requeue
)paren
r_return
id|SCpnt
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Bleah.  Leftovers again.  Stick the leftovers in&n;&t;&t; * the front of the queue, and goose the queue again.&n;&t;&t; */
id|scsi_queue_next_request
c_func
(paren
id|q
comma
id|SCpnt
)paren
suffix:semicolon
r_return
id|SCpnt
suffix:semicolon
)brace
id|add_disk_randomness
c_func
(paren
id|req-&gt;rq_disk
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|q-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blk_rq_tagged
c_func
(paren
id|req
)paren
)paren
id|blk_queue_end_tag
c_func
(paren
id|q
comma
id|req
)paren
suffix:semicolon
id|end_that_request_last
c_func
(paren
id|req
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|q-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This will goose the queue request function at the end, so we don&squot;t&n;&t; * need to worry about launching another command.&n;&t; */
id|__scsi_release_command
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|scsi_queue_next_request
c_func
(paren
id|q
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_release_buffers()&n; *&n; * Purpose:     Completion processing for block device I/O requests.&n; *&n; * Arguments:   SCpnt   - command that we are bailing.&n; *&n; * Lock status: Assumed that no lock is held upon entry.&n; *&n; * Returns:     Nothing&n; *&n; * Notes:       In the event that an upper level driver rejects a&n; *&t;&t;command, we must release resources allocated during&n; *&t;&t;the __init_io() function.  Primarily this would involve&n; *&t;&t;the scatter-gather table, and potentially any bounce&n; *&t;&t;buffers.&n; */
DECL|function|scsi_release_buffers
r_static
r_void
id|scsi_release_buffers
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_struct
id|request
op_star
id|req
op_assign
id|SCpnt-&gt;request
suffix:semicolon
id|ASSERT_LOCK
c_func
(paren
id|SCpnt-&gt;host-&gt;host_lock
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Free up any indirection buffers we allocated for DMA purposes. &n;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;use_sg
)paren
(brace
r_struct
id|scatterlist
op_star
id|sgpnt
suffix:semicolon
id|sgpnt
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|SCpnt-&gt;request_buffer
suffix:semicolon
id|scsi_free_sgtable
c_func
(paren
id|SCpnt-&gt;request_buffer
comma
id|SCpnt-&gt;sglist_len
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;request_buffer
op_ne
id|req-&gt;buffer
)paren
id|kfree
c_func
(paren
id|SCpnt-&gt;request_buffer
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Zero these out.  They now point to freed memory, and it is&n;&t; * dangerous to hang onto the pointers.&n;&t; */
id|SCpnt-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|SCpnt-&gt;bufflen
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
l_int|NULL
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_get_request_dev()&n; *&n; * Purpose:     Find the upper-level driver that is responsible for this&n; *              request&n; *&n; * Arguments:   request   - I/O request we are preparing to queue.&n; *&n; * Lock status: No locks assumed to be held, but as it happens the&n; *              q-&gt;queue_lock is held when this is called.&n; *&n; * Returns:     Nothing&n; *&n; * Notes:       The requests in the request queue may have originated&n; *              from any block device driver.  We need to find out which&n; *              one so that we can later form the appropriate command.&n; */
DECL|function|scsi_get_request_dev
r_static
r_struct
id|Scsi_Device_Template
op_star
id|scsi_get_request_dev
c_func
(paren
r_struct
id|request
op_star
id|req
)paren
(brace
r_struct
id|gendisk
op_star
id|p
op_assign
id|req-&gt;rq_disk
suffix:semicolon
r_return
id|p
ques
c_cond
op_star
(paren
r_struct
id|Scsi_Device_Template
op_star
op_star
)paren
id|p-&gt;private_data
suffix:colon
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_io_completion()&n; *&n; * Purpose:     Completion processing for block device I/O requests.&n; *&n; * Arguments:   SCpnt   - command that is finished.&n; *&n; * Lock status: Assumed that no lock is held upon entry.&n; *&n; * Returns:     Nothing&n; *&n; * Notes:       This function is matched in terms of capabilities to&n; *              the function that created the scatter-gather list.&n; *              In other words, if there are no bounce buffers&n; *              (the normal case for most drivers), we don&squot;t need&n; *              the logic to deal with cleaning up afterwards.&n; */
DECL|function|scsi_io_completion
r_void
id|scsi_io_completion
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
id|good_sectors
comma
r_int
id|block_sectors
)paren
(brace
r_int
id|result
op_assign
id|SCpnt-&gt;result
suffix:semicolon
r_int
id|this_count
op_assign
id|SCpnt-&gt;bufflen
op_rshift
l_int|9
suffix:semicolon
id|request_queue_t
op_star
id|q
op_assign
op_amp
id|SCpnt-&gt;device-&gt;request_queue
suffix:semicolon
r_struct
id|request
op_star
id|req
op_assign
id|SCpnt-&gt;request
suffix:semicolon
multiline_comment|/*&n;&t; * We must do one of several things here:&n;&t; *&n;&t; *&t;Call scsi_end_request.  This will finish off the specified&n;&t; *&t;number of sectors.  If we are done, the command block will&n;&t; *&t;be released, and the queue function will be goosed.  If we&n;&t; *&t;are not done, then scsi_end_request will directly goose&n;&t; *&t;the queue.&n;&t; *&n;&t; *&t;We can just use scsi_queue_next_request() here.  This&n;&t; *&t;would be used if we just wanted to retry, for example.&n;&t; *&n;&t; */
id|ASSERT_LOCK
c_func
(paren
id|q-&gt;queue_lock
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Free up any indirection buffers we allocated for DMA purposes. &n;&t; * For the case of a READ, we need to copy the data out of the&n;&t; * bounce buffer and into the real buffer.&n;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;use_sg
)paren
(brace
r_struct
id|scatterlist
op_star
id|sgpnt
suffix:semicolon
id|sgpnt
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|SCpnt-&gt;buffer
suffix:semicolon
id|scsi_free_sgtable
c_func
(paren
id|SCpnt-&gt;buffer
comma
id|SCpnt-&gt;sglist_len
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;buffer
op_ne
id|req-&gt;buffer
)paren
(brace
r_if
c_cond
(paren
id|rq_data_dir
c_func
(paren
id|req
)paren
op_eq
id|READ
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_char
op_star
id|to
op_assign
id|bio_kmap_irq
c_func
(paren
id|req-&gt;bio
comma
op_amp
id|flags
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|to
comma
id|SCpnt-&gt;buffer
comma
id|SCpnt-&gt;bufflen
)paren
suffix:semicolon
id|bio_kunmap_irq
c_func
(paren
id|to
comma
op_amp
id|flags
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|SCpnt-&gt;buffer
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|blk_pc_request
c_func
(paren
id|req
)paren
)paren
(brace
id|req-&gt;errors
op_assign
id|result
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
id|req-&gt;data_len
op_sub_assign
id|SCpnt-&gt;bufflen
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Zero these out.  They now point to freed memory, and it is&n;&t; * dangerous to hang onto the pointers.&n;&t; */
id|SCpnt-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|SCpnt-&gt;bufflen
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
l_int|NULL
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Next deal with any sectors which we were able to correctly&n;&t; * handle.&n;&t; */
r_if
c_cond
(paren
id|good_sectors
op_ge
l_int|0
)paren
(brace
id|SCSI_LOG_HLCOMPLETE
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;%ld sectors total, %d sectors done.&bslash;n&quot;
comma
id|req-&gt;nr_sectors
comma
id|good_sectors
)paren
)paren
suffix:semicolon
id|SCSI_LOG_HLCOMPLETE
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;use_sg is %d&bslash;n &quot;
comma
id|SCpnt-&gt;use_sg
)paren
)paren
suffix:semicolon
id|req-&gt;errors
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If multiple sectors are requested in one buffer, then&n;&t;&t; * they will have been finished off by the first command.&n;&t;&t; * If not, then we have a multi-buffer command.&n;&t;&t; *&n;&t;&t; * If block_sectors != 0, it means we had a medium error&n;&t;&t; * of some sort, and that we want to mark some number of&n;&t;&t; * sectors as not uptodate.  Thus we want to inhibit&n;&t;&t; * requeueing right here - we will requeue down below&n;&t;&t; * when we handle the bad sectors.&n;&t;&t; */
id|SCpnt
op_assign
id|scsi_end_request
c_func
(paren
id|SCpnt
comma
l_int|1
comma
id|good_sectors
comma
id|result
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the command completed without error, then either finish off the&n;&t;&t; * rest of the command, or start a new one.&n;&t;&t; */
r_if
c_cond
(paren
id|result
op_eq
l_int|0
op_logical_or
id|SCpnt
op_eq
l_int|NULL
)paren
(brace
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Now, if we were good little boys and girls, Santa left us a request&n;&t; * sense buffer.  We can extract information from this, so we&n;&t; * can choose a block to remap, etc.&n;&t; */
r_if
c_cond
(paren
id|driver_byte
c_func
(paren
id|result
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|suggestion
c_func
(paren
id|result
)paren
op_eq
id|SUGGEST_REMAP
)paren
(brace
macro_line|#ifdef REMAP
multiline_comment|/*&n;&t;&t;&t; * Not yet implemented.  A read will fail after being remapped,&n;&t;&t;&t; * a write will call the strategy routine again.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;device-&gt;remap
)paren
(brace
id|result
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
)brace
r_if
c_cond
(paren
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|0
)braket
op_amp
l_int|0x7f
)paren
op_eq
l_int|0x70
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If the device is in the process of becoming ready,&n;&t;&t;&t; * retry.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|12
)braket
op_eq
l_int|0x04
op_logical_and
id|SCpnt-&gt;sense_buffer
(braket
l_int|13
)braket
op_eq
l_int|0x01
)paren
(brace
id|scsi_queue_next_request
c_func
(paren
id|q
comma
id|SCpnt
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_eq
id|UNIT_ATTENTION
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;device-&gt;removable
)paren
(brace
multiline_comment|/* detected disc change.  set a bit &n;&t;&t;&t;&t;&t; * and quietly refuse further access.&n;&t;&t; &t;&t;&t; */
id|SCpnt-&gt;device-&gt;changed
op_assign
l_int|1
suffix:semicolon
id|SCpnt
op_assign
id|scsi_end_request
c_func
(paren
id|SCpnt
comma
l_int|0
comma
id|this_count
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; &t;* Must have been a power glitch, or a&n;&t;&t;&t;&t; &t;* bus reset.  Could not have been a&n;&t;&t;&t;&t; &t;* media change, so we just retry the&n;&t;&t;&t;&t; &t;* request and see what happens.  &n;&t;&t;&t;&t; &t;*/
id|scsi_queue_next_request
c_func
(paren
id|q
comma
id|SCpnt
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* If we had an ILLEGAL REQUEST returned, then we may have&n;&t;&t; * performed an unsupported command.  The only thing this should be&n;&t;&t; * would be a ten byte read where only a six byte read was supported.&n;&t;&t; * Also, on a system where READ CAPACITY failed, we have have read&n;&t;&t; * past the end of the disk.&n;&t;&t; */
r_switch
c_cond
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
)paren
(brace
r_case
id|ILLEGAL_REQUEST
suffix:colon
r_if
c_cond
(paren
id|SCpnt-&gt;device-&gt;ten
)paren
(brace
id|SCpnt-&gt;device-&gt;ten
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * This will cause a retry with a 6-byte&n;&t;&t;&t;&t; * command.&n;&t;&t;&t;&t; */
id|scsi_queue_next_request
c_func
(paren
id|q
comma
id|SCpnt
)paren
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|SCpnt
op_assign
id|scsi_end_request
c_func
(paren
id|SCpnt
comma
l_int|0
comma
id|this_count
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|NOT_READY
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Device %s not ready.&bslash;n&quot;
comma
id|req-&gt;rq_disk
ques
c_cond
id|req-&gt;rq_disk-&gt;disk_name
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|SCpnt
op_assign
id|scsi_end_request
c_func
(paren
id|SCpnt
comma
l_int|0
comma
id|this_count
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MEDIUM_ERROR
suffix:colon
r_case
id|VOLUME_OVERFLOW
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d: ERROR on channel %d, id %d, lun %d, CDB: &quot;
comma
id|SCpnt-&gt;host-&gt;host_no
comma
(paren
r_int
)paren
id|SCpnt-&gt;channel
comma
(paren
r_int
)paren
id|SCpnt-&gt;target
comma
(paren
r_int
)paren
id|SCpnt-&gt;lun
)paren
suffix:semicolon
id|print_command
c_func
(paren
id|SCpnt-&gt;data_cmnd
)paren
suffix:semicolon
id|print_sense
c_func
(paren
l_string|&quot;sd&quot;
comma
id|SCpnt
)paren
suffix:semicolon
id|SCpnt
op_assign
id|scsi_end_request
c_func
(paren
id|SCpnt
comma
l_int|0
comma
id|block_sectors
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* driver byte != 0 */
r_if
c_cond
(paren
id|host_byte
c_func
(paren
id|result
)paren
op_eq
id|DID_RESET
)paren
(brace
multiline_comment|/*&n;&t;&t; * Third party bus reset or reset for error&n;&t;&t; * recovery reasons.  Just retry the request&n;&t;&t; * and see what happens.  &n;&t;&t; */
id|scsi_queue_next_request
c_func
(paren
id|q
comma
id|SCpnt
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
)paren
(brace
r_struct
id|Scsi_Device_Template
op_star
id|STpnt
suffix:semicolon
id|STpnt
op_assign
id|scsi_get_request_dev
c_func
(paren
id|SCpnt-&gt;request
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SCSI %s error : host %d channel %d id %d lun %d return code = %x&bslash;n&quot;
comma
(paren
id|STpnt
ques
c_cond
id|STpnt-&gt;name
suffix:colon
l_string|&quot;device&quot;
)paren
comma
id|SCpnt-&gt;device-&gt;host-&gt;host_no
comma
id|SCpnt-&gt;device-&gt;channel
comma
id|SCpnt-&gt;device-&gt;id
comma
id|SCpnt-&gt;device-&gt;lun
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver_byte
c_func
(paren
id|result
)paren
op_amp
id|DRIVER_SENSE
)paren
id|print_sense
c_func
(paren
l_string|&quot;sd&quot;
comma
id|SCpnt
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Mark a single buffer as not uptodate.  Queue the remainder.&n;&t;&t; * We sometimes get this cruft in the event that a medium error&n;&t;&t; * isn&squot;t properly reported.&n;&t;&t; */
id|SCpnt
op_assign
id|scsi_end_request
c_func
(paren
id|SCpnt
comma
l_int|0
comma
id|req-&gt;current_nr_sectors
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function:    scsi_init_io()&n; *&n; * Purpose:     SCSI I/O initialize function.&n; *&n; * Arguments:   SCpnt   - Command descriptor we wish to initialize&n; *&n; * Returns:     0 on success&n; *&t;&t;BLKPREP_DEFER if the failure is retryable&n; *&t;&t;BLKPREP_KILL if the failure is fatal&n; */
DECL|function|scsi_init_io
r_static
r_int
id|scsi_init_io
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_struct
id|request
op_star
id|req
op_assign
id|SCpnt-&gt;request
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sgpnt
suffix:semicolon
r_int
id|count
comma
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * if this is a rq-&gt;data based REQ_BLOCK_PC, setup for a non-sg xfer&n;&t; */
r_if
c_cond
(paren
(paren
id|req-&gt;flags
op_amp
id|REQ_BLOCK_PC
)paren
op_logical_and
op_logical_neg
id|req-&gt;bio
)paren
(brace
id|SCpnt-&gt;request_bufflen
op_assign
id|req-&gt;data_len
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
id|req-&gt;data
suffix:semicolon
id|req-&gt;buffer
op_assign
id|req-&gt;data
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we used to not use scatter-gather for single segment request,&n;&t; * but now we do (it makes highmem I/O easier to support without&n;&t; * kmapping pages)&n;&t; */
id|SCpnt-&gt;use_sg
op_assign
id|req-&gt;nr_phys_segments
suffix:semicolon
multiline_comment|/*&n;&t; * if sg table allocation fails, requeue request later.&n;&t; */
id|sgpnt
op_assign
id|scsi_alloc_sgtable
c_func
(paren
id|SCpnt
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|sgpnt
)paren
)paren
(brace
id|req-&gt;flags
op_or_assign
id|REQ_SPECIAL
suffix:semicolon
id|ret
op_assign
id|BLKPREP_DEFER
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|SCpnt-&gt;request_buffer
op_assign
(paren
r_char
op_star
)paren
id|sgpnt
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
id|req-&gt;nr_sectors
op_lshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
id|blk_pc_request
c_func
(paren
id|req
)paren
)paren
id|SCpnt-&gt;request_bufflen
op_assign
id|req-&gt;data_len
suffix:semicolon
id|req-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* &n;&t; * Next, walk the list, and fill in the addresses and sizes of&n;&t; * each segment.&n;&t; */
id|count
op_assign
id|blk_rq_map_sg
c_func
(paren
id|req-&gt;q
comma
id|req
comma
id|SCpnt-&gt;request_buffer
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * mapped well, send it off&n;&t; */
r_if
c_cond
(paren
id|count
op_le
id|SCpnt-&gt;use_sg
)paren
(brace
id|SCpnt-&gt;use_sg
op_assign
id|count
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Incorrect number of segments after building list&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;counted %d, received %d&bslash;n&quot;
comma
id|count
comma
id|SCpnt-&gt;use_sg
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;req nr_sec %lu, cur_nr_sec %u&bslash;n&quot;
comma
id|req-&gt;nr_sectors
comma
id|req-&gt;current_nr_sectors
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * kill it. there should be no leftover blocks in this request&n;&t; */
id|SCpnt
op_assign
id|scsi_end_request
c_func
(paren
id|SCpnt
comma
l_int|0
comma
id|req-&gt;nr_sectors
comma
l_int|1
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|ret
op_assign
id|BLKPREP_KILL
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|scsi_prep_fn
r_int
id|scsi_prep_fn
c_func
(paren
r_struct
id|request_queue
op_star
id|q
comma
r_struct
id|request
op_star
id|req
)paren
(brace
r_struct
id|Scsi_Device_Template
op_star
id|STpnt
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
(paren
id|Scsi_Device
op_star
)paren
id|q-&gt;queuedata
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|SDpnt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Find the actual device driver associated with this command.&n;&t; * The SPECIAL requests are things like character device or&n;&t; * ioctls, which did not originate from ll_rw_blk.  Note that&n;&t; * the special field is also used to indicate the SCpnt for&n;&t; * the remainder of a partially fulfilled request that can &n;&t; * come up when there is a medium error.  We have to treat&n;&t; * these two cases differently.  We differentiate by looking&n;&t; * at request-&gt;cmd, as this tells us the real story.&n;&t; */
r_if
c_cond
(paren
id|req-&gt;flags
op_amp
id|REQ_SPECIAL
)paren
(brace
id|Scsi_Request
op_star
id|SRpnt
suffix:semicolon
id|STpnt
op_assign
l_int|NULL
suffix:semicolon
id|SCpnt
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|req-&gt;special
suffix:semicolon
id|SRpnt
op_assign
(paren
id|Scsi_Request
op_star
)paren
id|req-&gt;special
suffix:semicolon
r_if
c_cond
(paren
id|SRpnt-&gt;sr_magic
op_eq
id|SCSI_REQ_MAGIC
)paren
(brace
id|SCpnt
op_assign
id|scsi_allocate_device
c_func
(paren
id|SRpnt-&gt;sr_device
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SCpnt
)paren
r_return
id|BLKPREP_DEFER
suffix:semicolon
id|scsi_init_cmd_from_req
c_func
(paren
id|SCpnt
comma
id|SRpnt
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|req-&gt;flags
op_amp
(paren
id|REQ_CMD
op_or
id|REQ_BLOCK_PC
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Now try and find a command block that we can use.&n;&t;&t; */
r_if
c_cond
(paren
id|req-&gt;special
)paren
(brace
id|SCpnt
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|req-&gt;special
suffix:semicolon
)brace
r_else
(brace
id|SCpnt
op_assign
id|scsi_allocate_device
c_func
(paren
id|SDpnt
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * if command allocation failure, wait a bit&n;&t;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|SCpnt
)paren
)paren
r_return
id|BLKPREP_DEFER
suffix:semicolon
multiline_comment|/* pull a tag out of the request if we have one */
id|SCpnt-&gt;tag
op_assign
id|req-&gt;tag
suffix:semicolon
)brace
r_else
(brace
id|blk_dump_rq_flags
c_func
(paren
id|req
comma
l_string|&quot;SCSI bad req&quot;
)paren
suffix:semicolon
r_return
id|BLKPREP_KILL
suffix:semicolon
)brace
multiline_comment|/* note the overloading of req-&gt;special.  When the tag&n;&t; * is active it always means SCpnt.  If the tag goes&n;&t; * back for re-queueing, it may be reset */
id|req-&gt;special
op_assign
id|SCpnt
suffix:semicolon
id|SCpnt-&gt;request
op_assign
id|req
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME: drop the lock here because the functions below&n;&t; * expect to be called without the queue lock held.  Also,&n;&t; * previously, we dequeued the request before dropping the&n;&t; * lock.  We hope REQ_STARTED prevents anything untoward from&n;&t; * happening now.&n;&t; */
r_if
c_cond
(paren
id|req-&gt;flags
op_amp
(paren
id|REQ_CMD
op_or
id|REQ_BLOCK_PC
)paren
)paren
(brace
r_int
id|ret
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This will do a couple of things:&n;&t;&t; *  1) Fill in the actual SCSI command.&n;&t;&t; *  2) Fill in any other upper-level specific fields&n;&t;&t; * (timeout).&n;&t;&t; *&n;&t;&t; * If this returns 0, it means that the request failed&n;&t;&t; * (reading past end of disk, reading offline device,&n;&t;&t; * etc).   This won&squot;t actually talk to the device, but&n;&t;&t; * some kinds of consistency checking may cause the&t;&n;&t;&t; * request to be rejected immediately.&n;&t;&t; */
id|STpnt
op_assign
id|scsi_get_request_dev
c_func
(paren
id|req
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|STpnt
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * This sets up the scatter-gather table (allocating if&n;&t;&t; * required).&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|scsi_init_io
c_func
(paren
id|SCpnt
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Initialize the actual SCSI command for this request.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|STpnt
op_member_access_from_pointer
id|init_command
c_func
(paren
id|SCpnt
)paren
)paren
(brace
id|scsi_release_buffers
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
id|BLKPREP_KILL
suffix:semicolon
)brace
)brace
multiline_comment|/* The request is now prepped, no need to come back here */
id|req-&gt;flags
op_or_assign
id|REQ_DONTPREP
suffix:semicolon
r_return
id|BLKPREP_OK
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_request_fn()&n; *&n; * Purpose:     Generic version of request function for SCSI hosts.&n; *&n; * Arguments:   q       - Pointer to actual queue.&n; *&n; * Returns:     Nothing&n; *&n; * Lock status: IO request lock assumed to be held when called.&n; *&n; * Notes:       The theory is that this function is something which individual&n; *              drivers could also supply if they wished to.   The problem&n; *              is that we have 30 some odd low-level drivers in the kernel&n; *              tree already, and it would be most difficult to retrofit&n; *              this crap into all of them.   Thus this function has the job&n; *              of acting as a generic queue manager for all of those existing&n; *              drivers.&n; */
DECL|function|scsi_request_fn
r_void
id|scsi_request_fn
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
r_struct
id|request
op_star
id|req
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|SHpnt
suffix:semicolon
id|ASSERT_LOCK
c_func
(paren
id|q-&gt;queue_lock
comma
l_int|1
)paren
suffix:semicolon
id|SDpnt
op_assign
(paren
id|Scsi_Device
op_star
)paren
id|q-&gt;queuedata
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SDpnt
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Missing device&quot;
)paren
suffix:semicolon
)brace
id|SHpnt
op_assign
id|SDpnt-&gt;host
suffix:semicolon
multiline_comment|/*&n;&t; * To start with, we keep looping until the queue is empty, or until&n;&t; * the host is no longer able to accept any more requests.&n;&t; */
r_while
c_loop
(paren
l_int|1
op_eq
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; * Check this again - each time we loop through we will have&n;&t;&t; * released the lock and grabbed it again, so each time&n;&t;&t; * we need to check to see if the queue is plugged or not.&n;&t;&t; */
r_if
c_cond
(paren
id|SHpnt-&gt;in_recovery
op_logical_or
id|blk_queue_plugged
c_func
(paren
id|q
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t;&t; * get next queueable request.  We do this early to make sure&n;&t;&t; * that the request is fully prepared even if we cannot &n;&t;&t; * accept it.  If there is no request, we&squot;ll detect this&n;&t;&t; * lower down.&n;&t;&t; */
id|req
op_assign
id|elv_next_request
c_func
(paren
id|q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SHpnt-&gt;host_busy
op_eq
l_int|0
op_logical_and
id|SHpnt-&gt;host_blocked
)paren
(brace
multiline_comment|/* unblock after host_blocked iterates to zero */
r_if
c_cond
(paren
op_decrement
id|SHpnt-&gt;host_blocked
op_eq
l_int|0
)paren
(brace
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi%d unblocking host at zero depth&bslash;n&quot;
comma
id|SHpnt-&gt;host_no
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|blk_plug_device
c_func
(paren
id|q
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|SDpnt-&gt;device_busy
op_eq
l_int|0
op_logical_and
id|SDpnt-&gt;device_blocked
)paren
(brace
multiline_comment|/* unblock after device_blocked iterates to zero */
r_if
c_cond
(paren
op_decrement
id|SDpnt-&gt;device_blocked
op_eq
l_int|0
)paren
(brace
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi%d (%d:%d) unblocking device at zero depth&bslash;n&quot;
comma
id|SHpnt-&gt;host_no
comma
id|SDpnt-&gt;id
comma
id|SDpnt-&gt;lun
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|blk_plug_device
c_func
(paren
id|q
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * If the device cannot accept another request, then quit.&n;&t;&t; */
r_if
c_cond
(paren
id|SDpnt-&gt;device_blocked
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|SHpnt-&gt;can_queue
OG
l_int|0
op_logical_and
(paren
id|SHpnt-&gt;host_busy
op_ge
id|SHpnt-&gt;can_queue
)paren
)paren
op_logical_or
(paren
id|SHpnt-&gt;host_blocked
)paren
op_logical_or
(paren
id|SHpnt-&gt;host_self_blocked
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If we are unable to process any commands at all for&n;&t;&t;&t; * this device, then we consider it to be starved.&n;&t;&t;&t; * What this means is that there are no outstanding&n;&t;&t;&t; * commands for this device and hence we need a&n;&t;&t;&t; * little help getting it started again&n;&t;&t;&t; * once the host isn&squot;t quite so busy.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|SDpnt-&gt;device_busy
op_eq
l_int|0
)paren
(brace
id|SDpnt-&gt;starved
op_assign
l_int|1
suffix:semicolon
id|SHpnt-&gt;some_device_starved
op_assign
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_else
(brace
id|SDpnt-&gt;starved
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If we couldn&squot;t find a request that could be queued, then we&n;&t;&t; * can also quit.&n;&t;&t; */
r_if
c_cond
(paren
id|blk_queue_empty
c_func
(paren
id|q
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|req
)paren
(brace
multiline_comment|/* If the device is busy, a returning I/O&n;&t;&t;&t; * will restart the queue.  Otherwise, we have&n;&t;&t;&t; * to plug the queue */
r_if
c_cond
(paren
id|SDpnt-&gt;device_busy
op_eq
l_int|0
)paren
(brace
id|blk_plug_device
c_func
(paren
id|q
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|SCpnt
op_assign
(paren
r_struct
id|scsi_cmnd
op_star
)paren
id|req-&gt;special
suffix:semicolon
multiline_comment|/* Should be impossible for a correctly prepared request&n;&t;&t; * please mail the stack trace to linux-scsi@vger.kernel.org&n;&t;&t; */
id|BUG_ON
c_func
(paren
op_logical_neg
id|SCpnt
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Finally, before we release the lock, we copy the&n;&t;&t; * request to the command block, and remove the&n;&t;&t; * request from the request list.  Note that we always&n;&t;&t; * operate on the queue head - there is absolutely no&n;&t;&t; * reason to search the list, because all of the&n;&t;&t; * commands in this queue are for the same device.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|blk_queue_tagged
c_func
(paren
id|q
)paren
op_logical_and
(paren
id|blk_queue_start_tag
c_func
(paren
id|q
comma
id|req
)paren
op_eq
l_int|0
)paren
)paren
)paren
(brace
id|blkdev_dequeue_request
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Now bump the usage count for both the host and the&n;&t;&t; * device.&n;&t;&t; */
id|SHpnt-&gt;host_busy
op_increment
suffix:semicolon
id|SDpnt-&gt;device_busy
op_increment
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
id|q-&gt;queue_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Finally, initialize any error handling parameters, and set up&n;&t;&t; * the timers for timeouts.&n;&t;&t; */
id|scsi_init_cmd_errh
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Dispatch the command to the low-level driver.&n;&t;&t; */
id|scsi_dispatch_cmd
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Now we need to grab the lock again.  We are about to mess&n;&t;&t; * with the request queue and try to find another command.&n;&t;&t; */
id|spin_lock_irq
c_func
(paren
id|q-&gt;queue_lock
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function:    scsi_block_requests()&n; *&n; * Purpose:     Utility function used by low-level drivers to prevent further&n; *&t;&t;commands from being queued to the device.&n; *&n; * Arguments:   SHpnt       - Host in question&n; *&n; * Returns:     Nothing&n; *&n; * Lock status: No locks are assumed held.&n; *&n; * Notes:       There is no timer nor any other means by which the requests&n; *&t;&t;get unblocked other than the low-level driver calling&n; *&t;&t;scsi_unblock_requests().&n; */
DECL|function|scsi_block_requests
r_void
id|scsi_block_requests
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|SHpnt
)paren
(brace
id|SHpnt-&gt;host_self_blocked
op_assign
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_unblock_requests()&n; *&n; * Purpose:     Utility function used by low-level drivers to allow further&n; *&t;&t;commands from being queued to the device.&n; *&n; * Arguments:   SHpnt       - Host in question&n; *&n; * Returns:     Nothing&n; *&n; * Lock status: No locks are assumed held.&n; *&n; * Notes:       There is no timer nor any other means by which the requests&n; *&t;&t;get unblocked other than the low-level driver calling&n; *&t;&t;scsi_unblock_requests().&n; *&n; *&t;&t;This is done as an API function so that changes to the&n; *&t;&t;internals of the scsi mid-layer won&squot;t require wholesale&n; *&t;&t;changes to drivers that use this feature.&n; */
DECL|function|scsi_unblock_requests
r_void
id|scsi_unblock_requests
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|SHpnt
)paren
(brace
id|Scsi_Device
op_star
id|SDloop
suffix:semicolon
id|SHpnt-&gt;host_self_blocked
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Now that we are unblocked, try to start the queues. */
id|list_for_each_entry
c_func
(paren
id|SDloop
comma
op_amp
id|SHpnt-&gt;my_devices
comma
id|siblings
)paren
id|scsi_queue_next_request
c_func
(paren
op_amp
id|SDloop-&gt;request_queue
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_report_bus_reset()&n; *&n; * Purpose:     Utility function used by low-level drivers to report that&n; *&t;&t;they have observed a bus reset on the bus being handled.&n; *&n; * Arguments:   SHpnt       - Host in question&n; *&t;&t;channel     - channel on which reset was observed.&n; *&n; * Returns:     Nothing&n; *&n; * Lock status: No locks are assumed held.&n; *&n; * Notes:       This only needs to be called if the reset is one which&n; *&t;&t;originates from an unknown location.  Resets originated&n; *&t;&t;by the mid-level itself don&squot;t need to call this, but there&n; *&t;&t;should be no harm.&n; *&n; *&t;&t;The main purpose of this is to make sure that a CHECK_CONDITION&n; *&t;&t;is properly treated.&n; */
DECL|function|scsi_report_bus_reset
r_void
id|scsi_report_bus_reset
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|SHpnt
comma
r_int
id|channel
)paren
(brace
id|Scsi_Device
op_star
id|SDloop
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|SDloop
comma
op_amp
id|SHpnt-&gt;my_devices
comma
id|siblings
)paren
(brace
r_if
c_cond
(paren
id|channel
op_eq
id|SDloop-&gt;channel
)paren
(brace
id|SDloop-&gt;was_reset
op_assign
l_int|1
suffix:semicolon
id|SDloop-&gt;expecting_cc_ua
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * FIXME(eric) - these are empty stubs for the moment.  I need to re-implement&n; * host blocking from scratch. The theory is that hosts that wish to block&n; * will register/deregister using these functions instead of the old way&n; * of setting the wish_block flag.&n; *&n; * The details of the implementation remain to be settled, however the&n; * stubs are here now so that the actual drivers will properly compile.&n; */
DECL|function|scsi_register_blocked_host
r_void
id|scsi_register_blocked_host
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|SHpnt
)paren
(brace
)brace
DECL|function|scsi_deregister_blocked_host
r_void
id|scsi_deregister_blocked_host
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|SHpnt
)paren
(brace
)brace
eof
