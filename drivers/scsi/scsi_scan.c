multiline_comment|/*&n; *  scsi_scan.c Copyright (C) 2000 Eric Youngdale&n; *&n; *  Bus scan logic.&n; *&n; *  This used to live in scsi.c, but that file was just a laundry basket&n; *  full of misc stuff.  This got separated out in order to make things&n; *  clearer.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;constants.h&quot;
macro_line|#ifdef CONFIG_KMOD
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#endif
multiline_comment|/*&n; * Flags for irregular SCSI devices that need special treatment&n; */
DECL|macro|BLIST_NOLUN
mdefine_line|#define BLIST_NOLUN     &t;0x001&t;/* Don&squot;t scan for LUNs */
DECL|macro|BLIST_FORCELUN
mdefine_line|#define BLIST_FORCELUN  &t;0x002&t;/* Known to have LUNs, force sanning */
DECL|macro|BLIST_BORKEN
mdefine_line|#define BLIST_BORKEN    &t;0x004&t;/* Flag for broken handshaking */
DECL|macro|BLIST_KEY
mdefine_line|#define BLIST_KEY       &t;0x008&t;/* Needs to be unlocked by special command */
DECL|macro|BLIST_SINGLELUN
mdefine_line|#define BLIST_SINGLELUN &t;0x010&t;/* LUNs should better not be used in parallel */
DECL|macro|BLIST_NOTQ
mdefine_line|#define BLIST_NOTQ&t;&t;0x020&t;/* Buggy Tagged Command Queuing */
DECL|macro|BLIST_SPARSELUN
mdefine_line|#define BLIST_SPARSELUN &t;0x040&t;/* Non consecutive LUN numbering */
DECL|macro|BLIST_MAX5LUN
mdefine_line|#define BLIST_MAX5LUN&t;&t;0x080&t;/* Avoid LUNS &gt;= 5 */
DECL|macro|BLIST_ISDISK
mdefine_line|#define BLIST_ISDISK    &t;0x100&t;/* Treat as (removable) disk */
DECL|macro|BLIST_ISROM
mdefine_line|#define BLIST_ISROM     &t;0x200&t;/* Treat as (removable) CD-ROM */
DECL|macro|BLIST_LARGELUN
mdefine_line|#define BLIST_LARGELUN&t;&t;0x400&t;/* LUNs larger than 7 despite reporting as SCSI 2 */
DECL|macro|BLIST_INQUIRY_36
mdefine_line|#define BLIST_INQUIRY_36&t;0x800&t;/* override additional length field */
DECL|macro|BLIST_INQUIRY_58
mdefine_line|#define BLIST_INQUIRY_58&t;0x1000&t;/* ... for broken inquiry responses */
multiline_comment|/*&n; * scan_scsis_single() return values.&n; */
DECL|macro|SCSI_SCAN_NO_RESPONSE
mdefine_line|#define SCSI_SCAN_NO_RESPONSE      0
DECL|macro|SCSI_SCAN_DEVICE_PRESENT
mdefine_line|#define SCSI_SCAN_DEVICE_PRESENT   1
DECL|macro|SCSI_SCAN_DEVICE_ADDED
mdefine_line|#define SCSI_SCAN_DEVICE_ADDED     2
r_static
r_void
id|print_inquiry
c_func
(paren
r_int
r_char
op_star
id|data
)paren
suffix:semicolon
r_static
r_int
id|scan_scsis_single
c_func
(paren
r_int
r_int
id|channel
comma
r_int
r_int
id|dev
comma
r_int
r_int
id|lun
comma
r_int
id|scsi_level
comma
id|Scsi_Device
op_star
op_star
id|SDpnt2
comma
r_struct
id|Scsi_Host
op_star
id|shpnt
comma
r_char
op_star
id|scsi_result
)paren
suffix:semicolon
r_static
r_void
id|scan_scsis_target
c_func
(paren
r_int
r_int
id|channel
comma
r_int
r_int
id|dev
comma
id|Scsi_Device
op_star
op_star
id|SDpnt2
comma
r_struct
id|Scsi_Host
op_star
id|shpnt
comma
r_char
op_star
id|scsi_result
)paren
suffix:semicolon
r_static
r_int
id|find_lun0_scsi_level
c_func
(paren
r_int
r_int
id|channel
comma
r_int
r_int
id|dev
comma
r_struct
id|Scsi_Host
op_star
id|shpnt
)paren
suffix:semicolon
DECL|struct|dev_info
r_struct
id|dev_info
(brace
DECL|member|vendor
r_const
r_char
op_star
id|vendor
suffix:semicolon
DECL|member|model
r_const
r_char
op_star
id|model
suffix:semicolon
DECL|member|revision
r_const
r_char
op_star
id|revision
suffix:semicolon
multiline_comment|/* Latest revision known to be bad.  Not used yet */
DECL|member|flags
r_int
id|flags
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * This is what was previously known as the blacklist.  The concept&n; * has been expanded so that we can specify other types of things we&n; * need to be aware of.&n; */
DECL|variable|device_list
r_static
r_struct
id|dev_info
id|device_list
(braket
)braket
op_assign
(brace
multiline_comment|/* The following devices are known not to tolerate a lun != 0 scan for&n; * one reason or another.  Some will respond to all luns, others will&n; * lock up.&n; */
(brace
l_string|&quot;Aashima&quot;
comma
l_string|&quot;IMAGERY 2400SP&quot;
comma
l_string|&quot;1.03&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;CHINON&quot;
comma
l_string|&quot;CD-ROM CDS-431&quot;
comma
l_string|&quot;H42&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;CHINON&quot;
comma
l_string|&quot;CD-ROM CDS-535&quot;
comma
l_string|&quot;Q14&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;DENON&quot;
comma
l_string|&quot;DRD-25X&quot;
comma
l_string|&quot;V&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if probed for lun != 0 */
(brace
l_string|&quot;HITACHI&quot;
comma
l_string|&quot;DK312C&quot;
comma
l_string|&quot;CM81&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Responds to all lun - dtg */
(brace
l_string|&quot;HITACHI&quot;
comma
l_string|&quot;DK314C&quot;
comma
l_string|&quot;CR21&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* responds to all lun */
(brace
l_string|&quot;IMS&quot;
comma
l_string|&quot;CDD521/10&quot;
comma
l_string|&quot;2.06&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks-up when LUN&gt;0 polled. */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;XT-3280&quot;
comma
l_string|&quot;PR02&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks-up when LUN&gt;0 polled. */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;XT-4380S&quot;
comma
l_string|&quot;B3C&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks-up when LUN&gt;0 polled. */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;MXT-1240S&quot;
comma
l_string|&quot;I1.2&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up when LUN&gt;0 polled */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;XT-4170S&quot;
comma
l_string|&quot;B5A&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks-up sometimes when LUN&gt;0 polled. */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;XT-8760S&quot;
comma
l_string|&quot;B7B&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* guess what? */
(brace
l_string|&quot;MEDIAVIS&quot;
comma
l_string|&quot;RENO CD-ROMX2A&quot;
comma
l_string|&quot;2.03&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/*Responds to all lun */
(brace
l_string|&quot;NEC&quot;
comma
l_string|&quot;CD-ROM DRIVE:841&quot;
comma
l_string|&quot;1.0&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks-up when LUN&gt;0 polled. */
(brace
l_string|&quot;PHILIPS&quot;
comma
l_string|&quot;PCA80SC&quot;
comma
l_string|&quot;V4-2&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Responds to all lun */
(brace
l_string|&quot;RODIME&quot;
comma
l_string|&quot;RO3000S&quot;
comma
l_string|&quot;2.33&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;SANYO&quot;
comma
l_string|&quot;CRD-250S&quot;
comma
l_string|&quot;1.20&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* causes failed REQUEST SENSE on lun 1&n;&t;&t;&t;&t;&t;&t;&t;&t; * for aha152x controller, which causes&n;&t;&t;&t;&t;&t;&t;&t;&t; * SCSI code to reset bus.*/
(brace
l_string|&quot;SEAGATE&quot;
comma
l_string|&quot;ST157N&quot;
comma
l_string|&quot;&bslash;004|j&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* causes failed REQUEST SENSE on lun 1&n;&t;&t;&t;&t;&t;&t;&t;&t; * for aha152x controller, which causes&n;&t;&t;&t;&t;&t;&t;&t;&t; * SCSI code to reset bus.*/
(brace
l_string|&quot;SEAGATE&quot;
comma
l_string|&quot;ST296&quot;
comma
l_string|&quot;921&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Responds to all lun */
(brace
l_string|&quot;SEAGATE&quot;
comma
l_string|&quot;ST1581&quot;
comma
l_string|&quot;6538&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Responds to all lun */
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-541&quot;
comma
l_string|&quot;4.3d&quot;
comma
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-55S&quot;
comma
l_string|&quot;1.0i&quot;
comma
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-561&quot;
comma
l_string|&quot;1.7x&quot;
comma
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-8012&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;TANDBERG&quot;
comma
l_string|&quot;TDC 3600&quot;
comma
l_string|&quot;U07&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;TEAC&quot;
comma
l_string|&quot;CD-R55S&quot;
comma
l_string|&quot;1.0H&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;TEAC&quot;
comma
l_string|&quot;CD-ROM&quot;
comma
l_string|&quot;1.06&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* causes failed REQUEST SENSE on lun 1&n;&t;&t;&t;&t;&t;&t;&t;&t; * for seagate controller, which causes&n;&t;&t;&t;&t;&t;&t;&t;&t; * SCSI code to reset bus.*/
(brace
l_string|&quot;TEAC&quot;
comma
l_string|&quot;MT-2ST/45S2-27&quot;
comma
l_string|&quot;RV M&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Responds to all lun */
(brace
l_string|&quot;TEXEL&quot;
comma
l_string|&quot;CD-ROM&quot;
comma
l_string|&quot;1.06&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* causes failed REQUEST SENSE on lun 1&n;&t;&t;&t;&t;&t;&t;&t;&t; * for seagate controller, which causes&n;&t;&t;&t;&t;&t;&t;&t;&t; * SCSI code to reset bus.*/
(brace
l_string|&quot;QUANTUM&quot;
comma
l_string|&quot;LPS525S&quot;
comma
l_string|&quot;3110&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks sometimes if polled for lun != 0 */
(brace
l_string|&quot;QUANTUM&quot;
comma
l_string|&quot;PD1225S&quot;
comma
l_string|&quot;3110&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks sometimes if polled for lun != 0 */
(brace
l_string|&quot;QUANTUM&quot;
comma
l_string|&quot;FIREBALL ST4.3S&quot;
comma
l_string|&quot;0F0C&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up when polled for lun != 0 */
(brace
l_string|&quot;MEDIAVIS&quot;
comma
l_string|&quot;CDR-H93MV&quot;
comma
l_string|&quot;1.31&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;SANKYO&quot;
comma
l_string|&quot;CP525&quot;
comma
l_string|&quot;6.64&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* causes failed REQ SENSE, extra reset */
(brace
l_string|&quot;HP&quot;
comma
l_string|&quot;C1750A&quot;
comma
l_string|&quot;3226&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* scanjet iic */
(brace
l_string|&quot;HP&quot;
comma
l_string|&quot;C1790A&quot;
comma
l_string|&quot;&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* scanjet iip */
(brace
l_string|&quot;HP&quot;
comma
l_string|&quot;C2500A&quot;
comma
l_string|&quot;&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* scanjet iicx */
(brace
l_string|&quot;YAMAHA&quot;
comma
l_string|&quot;CDR100&quot;
comma
l_string|&quot;1.00&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;YAMAHA&quot;
comma
l_string|&quot;CDR102&quot;
comma
l_string|&quot;1.00&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0  &n;&t;&t;&t;&t;&t;&t;&t;&t; * extra reset */
(brace
l_string|&quot;YAMAHA&quot;
comma
l_string|&quot;CRW8424S&quot;
comma
l_string|&quot;1.0&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;YAMAHA&quot;
comma
l_string|&quot;CRW6416S&quot;
comma
l_string|&quot;1.0c&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;MITSUMI&quot;
comma
l_string|&quot;CD-R CR-2201CS&quot;
comma
l_string|&quot;6119&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;RELISYS&quot;
comma
l_string|&quot;Scorpio&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* responds to all LUN */
(brace
l_string|&quot;MICROTEK&quot;
comma
l_string|&quot;ScanMaker II&quot;
comma
l_string|&quot;5.61&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* responds to all LUN */
multiline_comment|/*&n; * Other types of devices that have special flags.&n; */
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-8001&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_BORKEN
)brace
comma
(brace
l_string|&quot;TEXEL&quot;
comma
l_string|&quot;CD-ROM&quot;
comma
l_string|&quot;1.06&quot;
comma
id|BLIST_BORKEN
)brace
comma
(brace
l_string|&quot;IOMEGA&quot;
comma
l_string|&quot;Io20S         *F&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_KEY
)brace
comma
(brace
l_string|&quot;INSITE&quot;
comma
l_string|&quot;Floptical   F*8I&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_KEY
)brace
comma
(brace
l_string|&quot;INSITE&quot;
comma
l_string|&quot;I325VM&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_KEY
)brace
comma
(brace
l_string|&quot;LASOUND&quot;
comma
l_string|&quot;CDX7405&quot;
comma
l_string|&quot;3.10&quot;
comma
id|BLIST_MAX5LUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;MICROP&quot;
comma
l_string|&quot;4110&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_NOTQ
)brace
comma
multiline_comment|/* Buggy Tagged Queuing */
(brace
l_string|&quot;NRC&quot;
comma
l_string|&quot;MBR-7&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;NRC&quot;
comma
l_string|&quot;MBR-7.4&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;REGAL&quot;
comma
l_string|&quot;CDC-4X&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_MAX5LUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;NAKAMICH&quot;
comma
l_string|&quot;MJ-4.8S&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;NAKAMICH&quot;
comma
l_string|&quot;MJ-5.16S&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;PIONEER&quot;
comma
l_string|&quot;CD-ROM DRM-600&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;PIONEER&quot;
comma
l_string|&quot;CD-ROM DRM-602X&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;PIONEER&quot;
comma
l_string|&quot;CD-ROM DRM-604X&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;EMULEX&quot;
comma
l_string|&quot;MD21/S2     ESDI&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;CANON&quot;
comma
l_string|&quot;IPUBJD&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
)brace
comma
(brace
l_string|&quot;nCipher&quot;
comma
l_string|&quot;Fastness Crypto&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;DEC&quot;
comma
l_string|&quot;HSG80&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;COMPAQ&quot;
comma
l_string|&quot;LOGICAL VOLUME&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;COMPAQ&quot;
comma
l_string|&quot;CR3500&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;NEC&quot;
comma
l_string|&quot;PD-1 ODX654P&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;MATSHITA&quot;
comma
l_string|&quot;PD-1&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;iomega&quot;
comma
l_string|&quot;jaz 1GB&quot;
comma
l_string|&quot;J.86&quot;
comma
id|BLIST_NOTQ
op_or
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;TOSHIBA&quot;
comma
l_string|&quot;CDROM&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_ISROM
)brace
comma
(brace
l_string|&quot;TOSHIBA&quot;
comma
l_string|&quot;CD-ROM&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_ISROM
)brace
comma
(brace
l_string|&quot;MegaRAID&quot;
comma
l_string|&quot;LD&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;DGC&quot;
comma
l_string|&quot;RAID&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
)brace
comma
singleline_comment|// Dell PV 650F (tgt @ LUN 0)
(brace
l_string|&quot;DGC&quot;
comma
l_string|&quot;DISK&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
)brace
comma
singleline_comment|// Dell PV 650F (no tgt @ LUN 0) 
(brace
l_string|&quot;DELL&quot;
comma
l_string|&quot;PV660F&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
)brace
comma
(brace
l_string|&quot;DELL&quot;
comma
l_string|&quot;PV660F   PSEUDO&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
)brace
comma
(brace
l_string|&quot;DELL&quot;
comma
l_string|&quot;PSEUDO DEVICE .&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
)brace
comma
singleline_comment|// Dell PV 530F
(brace
l_string|&quot;DELL&quot;
comma
l_string|&quot;PV530F&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
)brace
comma
singleline_comment|// Dell PV 530F
(brace
l_string|&quot;EMC&quot;
comma
l_string|&quot;SYMMETRIX&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
op_or
id|BLIST_LARGELUN
op_or
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;HP&quot;
comma
l_string|&quot;A6189A&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
op_or
id|BLIST_LARGELUN
)brace
comma
singleline_comment|// HP VA7400, by Alar Aun
(brace
l_string|&quot;CMD&quot;
comma
l_string|&quot;CRA-7280&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
)brace
comma
singleline_comment|// CMD RAID Controller
(brace
l_string|&quot;CNSI&quot;
comma
l_string|&quot;G7324&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
)brace
comma
singleline_comment|// Chaparral G7324 RAID
(brace
l_string|&quot;CNSi&quot;
comma
l_string|&quot;G8324&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
)brace
comma
singleline_comment|// Chaparral G8324 RAID
(brace
l_string|&quot;Zzyzx&quot;
comma
l_string|&quot;RocketStor 500S&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
)brace
comma
(brace
l_string|&quot;Zzyzx&quot;
comma
l_string|&quot;RocketStor 2000&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
)brace
comma
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;TSL&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
)brace
comma
singleline_comment|// DDS3 &amp; DDS4 autoloaders
(brace
l_string|&quot;DELL&quot;
comma
l_string|&quot;PERCRAID&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;HP&quot;
comma
l_string|&quot;NetRAID-4M&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;ADAPTEC&quot;
comma
l_string|&quot;AACRAID&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;ADAPTEC&quot;
comma
l_string|&quot;Adaptec 5400S&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;COMPAQ&quot;
comma
l_string|&quot;MSA1000&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;HP&quot;
comma
l_string|&quot;C1557A&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;IBM&quot;
comma
l_string|&quot;AuSaV1S2&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_FORCELUN
)brace
comma
multiline_comment|/*&n;&t; * Must be at end of list...&n;&t; */
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
)brace
suffix:semicolon
DECL|variable|scsi_null_device_strs
r_static
r_char
op_star
id|scsi_null_device_strs
op_assign
l_string|&quot;nullnullnullnull&quot;
suffix:semicolon
DECL|macro|MAX_SCSI_LUNS
mdefine_line|#define MAX_SCSI_LUNS 0xFFFFFFFF
macro_line|#ifdef CONFIG_SCSI_MULTI_LUN
DECL|variable|max_scsi_luns
r_static
r_int
r_int
id|max_scsi_luns
op_assign
id|MAX_SCSI_LUNS
suffix:semicolon
macro_line|#else
DECL|variable|max_scsi_luns
r_static
r_int
r_int
id|max_scsi_luns
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_SCSI_REPORT_LUNS
multiline_comment|/* &n; * max_scsi_report_luns: the maximum number of LUNS that will be&n; * returned from the REPORT LUNS command. 8 times this value must&n; * be allocated. In theory this could be up to an 8 byte value, but&n; * in practice, the maximum number of LUNs suppored by any device&n; * is about 16k.&n; */
DECL|variable|max_scsi_report_luns
r_static
r_int
r_int
id|max_scsi_report_luns
op_assign
l_int|128
suffix:semicolon
macro_line|#endif
macro_line|#ifdef MODULE
id|MODULE_PARM
c_func
(paren
id|max_scsi_luns
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|max_scsi_luns
comma
l_string|&quot;last scsi LUN (should be between 1 and 2^32-1)&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SCSI_REPORT_LUNS
id|MODULE_PARM
c_func
(paren
id|max_scsi_report_luns
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|max_scsi_report_luns
comma
l_string|&quot;REPORT LUNS maximum number of LUNS received (should be between 1 and 16384)&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#else
DECL|function|scsi_luns_setup
r_static
r_int
id|__init
id|scsi_luns_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|get_option
c_func
(paren
op_amp
id|str
comma
op_amp
id|tmp
)paren
op_eq
l_int|1
)paren
(brace
id|max_scsi_luns
op_assign
id|tmp
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;scsi_luns_setup : usage max_scsi_luns=n &quot;
l_string|&quot;(n should be between 1 and 2^32-1)&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|__setup
c_func
(paren
l_string|&quot;max_scsi_luns=&quot;
comma
id|scsi_luns_setup
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SCSI_REPORT_LUNS
DECL|function|max_scsi_report_luns_setup
r_static
r_int
id|__init
id|max_scsi_report_luns_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|get_option
c_func
(paren
op_amp
id|str
comma
op_amp
id|tmp
)paren
op_eq
l_int|1
)paren
(brace
id|max_scsi_report_luns
op_assign
id|tmp
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;scsi_report_luns_setup : usage max_scsi_report_luns=n &quot;
l_string|&quot;(n should be between 1 and 16384)&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|__setup
c_func
(paren
l_string|&quot;max_scsi_report_luns=&quot;
comma
id|max_scsi_report_luns_setup
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SCSI_REPORT_LUNS */
macro_line|#endif
macro_line|#ifdef CONFIG_SCSI_REPORT_LUNS
multiline_comment|/*&n; * Function:    scsilun_to_int&n; *&n; * Purpose:     Convert ScsiLun (8 byte LUN) to an int.&n; *&n; * Arguments:   scsilun_pnt - pointer to a ScsiLun to be converted&n; *&n; * Lock status: None&n; *&n; * Returns:     cpu ordered integer containing the truncated LUN value&n; *&n; * Notes:       The ScsiLun is assumed to be four levels, with each level&n; * &t;&t;effectively containing a SCSI byte-ordered (big endidan)&n; * &t;&t;short; the addressing bits of each level are ignored (the&n; * &t;&t;highest two bits). For a description of the LUN format, post&n; * &t;&t;SCSI-3 see the SCSI Architecture Model, for SCSI-3 see the&n; * &t;&t;SCSI Controller Commands.&n; *&n; * &t;&t;Given a ScsiLun of: 0a 04 0b 03 00 00 00 00, this function&n; * &t;&t;returns the integer: 0x0b030a04&n; */
DECL|function|scsilun_to_int
r_static
r_int
id|scsilun_to_int
c_func
(paren
id|ScsiLun
op_star
id|scsilun_pnt
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|lun
suffix:semicolon
id|lun
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|lun
)paren
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
id|lun
op_assign
id|lun
op_or
(paren
(paren
(paren
id|scsilun_pnt-&gt;scsi_lun
(braket
id|i
)braket
op_lshift
l_int|8
)paren
op_or
id|scsilun_pnt-&gt;scsi_lun
(braket
id|i
op_plus
l_int|1
)braket
)paren
op_lshift
(paren
id|i
op_star
l_int|8
)paren
)paren
suffix:semicolon
r_return
id|lun
suffix:semicolon
)brace
macro_line|#endif
DECL|function|print_inquiry
r_static
r_void
id|print_inquiry
c_func
(paren
r_int
r_char
op_star
id|data
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  Vendor: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|8
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|data
(braket
id|i
)braket
op_ge
l_int|0x20
op_logical_and
id|i
OL
id|data
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;  Model: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|16
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|data
(braket
id|i
)braket
op_ge
l_int|0x20
op_logical_and
id|i
OL
id|data
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;  Rev: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|32
suffix:semicolon
id|i
OL
l_int|36
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|data
(braket
id|i
)braket
op_ge
l_int|0x20
op_logical_and
id|i
OL
id|data
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|i
op_assign
id|data
(braket
l_int|0
)braket
op_amp
l_int|0x1f
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  Type:   %s &quot;
comma
id|i
OL
id|MAX_SCSI_DEVICE_CODE
ques
c_cond
id|scsi_device_types
(braket
id|i
)braket
suffix:colon
l_string|&quot;Unknown          &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;                 ANSI SCSI revision: %02x&quot;
comma
id|data
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|data
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
op_eq
l_int|1
op_logical_and
(paren
id|data
(braket
l_int|3
)braket
op_amp
l_int|0x0f
)paren
op_eq
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot; CCS&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|get_device_flags
r_static
r_int
id|get_device_flags
c_func
(paren
r_int
r_char
op_star
id|vendor_pnt
comma
r_int
r_char
op_star
id|model_pnt
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|device_list
(braket
id|i
)braket
dot
id|vendor
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|vendor_pnt
op_logical_and
op_star
id|vendor_pnt
op_eq
l_char|&squot; &squot;
)paren
id|vendor_pnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|device_list
(braket
id|i
)braket
dot
id|vendor
comma
id|vendor_pnt
comma
id|strlen
c_func
(paren
id|device_list
(braket
id|i
)braket
dot
id|vendor
)paren
)paren
)paren
r_continue
suffix:semicolon
r_while
c_loop
(paren
op_star
id|model_pnt
op_logical_and
op_star
id|model_pnt
op_eq
l_char|&squot; &squot;
)paren
id|model_pnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|device_list
(braket
id|i
)braket
dot
id|model
comma
id|model_pnt
comma
id|strlen
c_func
(paren
id|device_list
(braket
id|i
)braket
dot
id|model
)paren
)paren
)paren
r_continue
suffix:semicolon
r_return
id|device_list
(braket
id|i
)braket
dot
id|flags
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Detecting SCSI devices :&n; *  We scan all present host adapter&squot;s busses,  from ID 0 to ID (max_id).&n; *  We use the INQUIRY command, determine device type, and pass the ID /&n; *  lun address of all sequential devices to the tape driver, all random&n; *  devices to the disk driver.&n; */
DECL|function|scan_scsis
r_void
id|scan_scsis
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shpnt
comma
id|uint
id|hardcoded
comma
id|uint
id|hchannel
comma
id|uint
id|hid
comma
id|uint
id|hlun
)paren
(brace
id|uint
id|channel
suffix:semicolon
r_int
r_int
id|dev
suffix:semicolon
r_int
r_int
id|lun
suffix:semicolon
r_int
r_char
op_star
id|scsi_result
suffix:semicolon
r_int
r_char
id|scsi_result0
(braket
l_int|256
)braket
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
id|Scsi_Device
op_star
id|SDtail
suffix:semicolon
id|scsi_result
op_assign
l_int|NULL
suffix:semicolon
id|SDpnt
op_assign
(paren
id|Scsi_Device
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|Scsi_Device
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt
)paren
(brace
id|memset
c_func
(paren
id|SDpnt
comma
l_int|0
comma
r_sizeof
(paren
id|Scsi_Device
)paren
)paren
suffix:semicolon
id|SDpnt-&gt;vendor
op_assign
id|scsi_null_device_strs
suffix:semicolon
id|SDpnt-&gt;model
op_assign
id|scsi_null_device_strs
suffix:semicolon
id|SDpnt-&gt;rev
op_assign
id|scsi_null_device_strs
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Register the queue for the device.  All I/O requests will&n;&t;&t; * come in through here.  We also need to register a pointer to&n;&t;&t; * ourselves, since the queue handler won&squot;t know what device&n;&t;&t; * the queue actually represents.   We could look it up, but it&n;&t;&t; * is pointless work.&n;&t;&t; */
id|scsi_initialize_queue
c_func
(paren
id|SDpnt
comma
id|shpnt
)paren
suffix:semicolon
id|SDpnt-&gt;request_queue.queuedata
op_assign
(paren
r_void
op_star
)paren
id|SDpnt
suffix:semicolon
multiline_comment|/* Make sure we have something that is valid for DMA purposes */
id|scsi_result
op_assign
(paren
(paren
op_logical_neg
id|shpnt-&gt;unchecked_isa_dma
)paren
ques
c_cond
op_amp
id|scsi_result0
(braket
l_int|0
)braket
suffix:colon
id|kmalloc
c_func
(paren
l_int|512
comma
id|GFP_DMA
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scsi_result
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to obtain scsi_result buffer&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|leave
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We must chain ourself in the host_queue, so commands can time out &n;&t; */
id|SDpnt-&gt;queue_depth
op_assign
l_int|1
suffix:semicolon
id|SDpnt-&gt;host
op_assign
id|shpnt
suffix:semicolon
id|SDpnt-&gt;online
op_assign
id|TRUE
suffix:semicolon
id|scsi_initialize_merge_fn
c_func
(paren
id|SDpnt
)paren
suffix:semicolon
multiline_comment|/*&n;         * Initialize the object that we will use to wait for command blocks.&n;         */
id|init_waitqueue_head
c_func
(paren
op_amp
id|SDpnt-&gt;scpnt_wait
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Next, hook the device to the host in question.&n;&t; */
id|SDpnt-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|SDpnt-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|shpnt-&gt;host_queue
op_ne
l_int|NULL
)paren
(brace
id|SDtail
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
r_while
c_loop
(paren
id|SDtail-&gt;next
op_ne
l_int|NULL
)paren
id|SDtail
op_assign
id|SDtail-&gt;next
suffix:semicolon
id|SDtail-&gt;next
op_assign
id|SDpnt
suffix:semicolon
id|SDpnt-&gt;prev
op_assign
id|SDtail
suffix:semicolon
)brace
r_else
(brace
id|shpnt-&gt;host_queue
op_assign
id|SDpnt
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We need to increment the counter for this one device so we can track&n;&t; * when things are quiet.&n;&t; */
r_if
c_cond
(paren
id|hardcoded
op_eq
l_int|1
)paren
(brace
id|Scsi_Device
op_star
id|oldSDpnt
op_assign
id|SDpnt
suffix:semicolon
r_struct
id|Scsi_Device_Template
op_star
id|sdtpnt
suffix:semicolon
r_int
r_int
id|lun0_sl
suffix:semicolon
id|channel
op_assign
id|hchannel
suffix:semicolon
r_if
c_cond
(paren
id|channel
OG
id|shpnt-&gt;max_channel
)paren
r_goto
id|leave
suffix:semicolon
id|dev
op_assign
id|hid
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_ge
id|shpnt-&gt;max_id
)paren
r_goto
id|leave
suffix:semicolon
id|lun
op_assign
id|hlun
suffix:semicolon
r_if
c_cond
(paren
id|lun
op_ge
id|shpnt-&gt;max_lun
)paren
r_goto
id|leave
suffix:semicolon
r_if
c_cond
(paren
(paren
l_int|0
op_eq
id|lun
)paren
op_logical_or
(paren
id|lun
OG
l_int|7
)paren
)paren
id|lun0_sl
op_assign
id|SCSI_3
suffix:semicolon
multiline_comment|/* actually don&squot;t care for 0 == lun */
r_else
id|lun0_sl
op_assign
id|find_lun0_scsi_level
c_func
(paren
id|channel
comma
id|dev
comma
id|shpnt
)paren
suffix:semicolon
id|scan_scsis_single
c_func
(paren
id|channel
comma
id|dev
comma
id|lun
comma
id|lun0_sl
comma
op_amp
id|SDpnt
comma
id|shpnt
comma
id|scsi_result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt
op_ne
id|oldSDpnt
)paren
(brace
multiline_comment|/* it could happen the blockdevice hasn&squot;t yet been inited */
multiline_comment|/* queue_depth() moved from scsi_proc_info() so that&n;&t;&t;&t;   it is called before scsi_build_commandblocks() */
r_if
c_cond
(paren
id|shpnt-&gt;select_queue_depths
op_ne
l_int|NULL
)paren
(paren
id|shpnt-&gt;select_queue_depths
)paren
(paren
id|shpnt
comma
id|shpnt-&gt;host_queue
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;init
op_logical_and
id|sdtpnt-&gt;dev_noticed
)paren
(paren
op_star
id|sdtpnt-&gt;init
)paren
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|sdtpnt-&gt;attach
)paren
(brace
(paren
op_star
id|sdtpnt-&gt;attach
)paren
(paren
id|oldSDpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oldSDpnt-&gt;attached
)paren
(brace
id|scsi_build_commandblocks
c_func
(paren
id|oldSDpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_eq
id|oldSDpnt-&gt;has_cmdblocks
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scan_scsis: DANGER, no command blocks&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* What to do now ?? */
)brace
)brace
)brace
)brace
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|sdtpnt-&gt;finish
op_logical_and
id|sdtpnt-&gt;nr_dev
)paren
(brace
(paren
op_star
id|sdtpnt-&gt;finish
)paren
(paren
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* Actual LUN. PC ordering is 0-&gt;n IBM/spec ordering is n-&gt;0 */
r_int
id|order_dev
suffix:semicolon
r_for
c_loop
(paren
id|channel
op_assign
l_int|0
suffix:semicolon
id|channel
op_le
id|shpnt-&gt;max_channel
suffix:semicolon
id|channel
op_increment
)paren
(brace
r_for
c_loop
(paren
id|dev
op_assign
l_int|0
suffix:semicolon
id|dev
OL
id|shpnt-&gt;max_id
suffix:semicolon
op_increment
id|dev
)paren
(brace
r_if
c_cond
(paren
id|shpnt-&gt;reverse_ordering
)paren
multiline_comment|/* Shift to scanning 15,14,13... or 7,6,5,4, */
id|order_dev
op_assign
id|shpnt-&gt;max_id
op_minus
id|dev
op_minus
l_int|1
suffix:semicolon
r_else
id|order_dev
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|shpnt-&gt;this_id
op_ne
id|order_dev
)paren
(brace
id|scan_scsis_target
c_func
(paren
id|channel
comma
id|order_dev
comma
op_amp
id|SDpnt
comma
id|shpnt
comma
id|scsi_result
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* if/else hardcoded */
id|leave
suffix:colon
(brace
multiline_comment|/* Unchain SRpnt from host_queue */
id|Scsi_Device
op_star
id|prev
comma
op_star
id|next
suffix:semicolon
id|Scsi_Device
op_star
id|dqptr
suffix:semicolon
r_for
c_loop
(paren
id|dqptr
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|dqptr
op_ne
id|SDpnt
suffix:semicolon
id|dqptr
op_assign
id|dqptr-&gt;next
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|dqptr
)paren
(brace
id|prev
op_assign
id|dqptr-&gt;prev
suffix:semicolon
id|next
op_assign
id|dqptr-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|prev
)paren
id|prev-&gt;next
op_assign
id|next
suffix:semicolon
r_else
id|shpnt-&gt;host_queue
op_assign
id|next
suffix:semicolon
r_if
c_cond
(paren
id|next
)paren
id|next-&gt;prev
op_assign
id|prev
suffix:semicolon
)brace
)brace
multiline_comment|/* Last device block does not exist.  Free memory. */
r_if
c_cond
(paren
id|SDpnt
op_ne
l_int|NULL
)paren
(brace
id|blk_cleanup_queue
c_func
(paren
op_amp
id|SDpnt-&gt;request_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt-&gt;inquiry
)paren
id|kfree
c_func
(paren
id|SDpnt-&gt;inquiry
)paren
suffix:semicolon
id|kfree
c_func
(paren
(paren
r_char
op_star
)paren
id|SDpnt
)paren
suffix:semicolon
)brace
multiline_comment|/* If we allocated a buffer so we could do DMA, free it now */
r_if
c_cond
(paren
id|scsi_result
op_ne
op_amp
id|scsi_result0
(braket
l_int|0
)braket
op_logical_and
id|scsi_result
op_ne
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|scsi_result
)paren
suffix:semicolon
)brace
(brace
id|Scsi_Device
op_star
id|sdev
suffix:semicolon
id|Scsi_Cmnd
op_star
id|scmd
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;Host status for host %p:&bslash;n&quot;
comma
id|shpnt
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sdev
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|sdev
suffix:semicolon
id|sdev
op_assign
id|sdev-&gt;next
)paren
(brace
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;Device %d %p: &quot;
comma
id|sdev-&gt;id
comma
id|sdev
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|scmd
op_assign
id|sdev-&gt;device_queue
suffix:semicolon
id|scmd
suffix:semicolon
id|scmd
op_assign
id|scmd-&gt;next
)paren
(brace
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;%p &quot;
comma
id|scmd
)paren
)paren
suffix:semicolon
)brace
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Function:    scan_scsis_single&n; *&n; * Purpose:     Determine if a SCSI device (a single LUN) exists, and&n; * &t;&t;configure it into the system.&n; *&n; * Arguments:   channel    - the host&squot;s channel&n; * &t;&t;dev        - target dev (target id)&n; * &t;&t;lun        - LUN&n; * &t;&t;scsi_level - SCSI 1, 2 or 3&n; * &t;&t;SDpnt2     - pointer to pointer of a preallocated Scsi_Device&n; * &t;&t;shpnt      - host device to use&n; * &t;&t;scsi_result - preallocated buffer for the SCSI command result&n; *&n; * Lock status: None&n; *&n; * Returns:     SCSI_SCAN_NO_RESPONSE - no valid response received from the&n; * &t;&t;device, this includes allocation failures preventing IO from&n; * &t;&t;being sent, or any general failures.&n; *&n; *&t;&t;SCSI_SCAN_DEVICE_PRESENT - device responded, SDpnt2 has all&n; *&t;&t;values needed to send IO set, plus scsi_level is set, but no&n; *&t;&t;new Scsi_Device was added/allocated.&n; *&n; *   &t;&t;SCSI_SCAN_DEVICE_ADDED - device responded, and added to list;&n; *   &t;&t;SDpnt2 filled, and pointed to new allocated Scsi_Device.&n; *&n; * Notes:       This could be cleaned up more by moving SDpnt2 and Scsi_Device&n; * &t;&t;allocation into scan_scsis_target.&n; */
DECL|function|scan_scsis_single
r_static
r_int
id|scan_scsis_single
c_func
(paren
r_int
r_int
id|channel
comma
r_int
r_int
id|dev
comma
r_int
r_int
id|lun
comma
r_int
id|scsi_level
comma
id|Scsi_Device
op_star
op_star
id|SDpnt2
comma
r_struct
id|Scsi_Host
op_star
id|shpnt
comma
r_char
op_star
id|scsi_result
)paren
(brace
r_char
id|devname
(braket
l_int|64
)braket
suffix:semicolon
r_int
r_char
id|scsi_cmd
(braket
id|MAX_COMMAND_SIZE
)braket
suffix:semicolon
r_struct
id|Scsi_Device_Template
op_star
id|sdtpnt
suffix:semicolon
id|Scsi_Device
op_star
id|SDtail
comma
op_star
id|SDpnt
op_assign
op_star
id|SDpnt2
suffix:semicolon
id|Scsi_Request
op_star
id|SRpnt
suffix:semicolon
r_int
id|bflags
comma
id|type
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|possible_inq_resp_len
suffix:semicolon
r_extern
id|devfs_handle_t
id|scsi_devfs_handle
suffix:semicolon
id|SDpnt-&gt;host
op_assign
id|shpnt
suffix:semicolon
id|SDpnt-&gt;id
op_assign
id|dev
suffix:semicolon
id|SDpnt-&gt;lun
op_assign
id|lun
suffix:semicolon
id|SDpnt-&gt;channel
op_assign
id|channel
suffix:semicolon
id|SDpnt-&gt;online
op_assign
id|TRUE
suffix:semicolon
id|scsi_build_commandblocks
c_func
(paren
id|SDpnt
)paren
suffix:semicolon
multiline_comment|/* Some low level driver could use device-&gt;type (DB) */
id|SDpnt-&gt;type
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Assume that the device will have handshaking problems, and then fix&n;&t; * this field later if it turns out it doesn&squot;t&n;&t; */
id|SDpnt-&gt;borken
op_assign
l_int|1
suffix:semicolon
id|SDpnt-&gt;was_reset
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;expecting_cc_ua
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;starved
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
(paren
id|SRpnt
op_assign
id|scsi_allocate_request
c_func
(paren
id|SDpnt
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scan_scsis_single: no memory&bslash;n&quot;
)paren
suffix:semicolon
id|scsi_release_commandblocks
c_func
(paren
id|SDpnt
)paren
suffix:semicolon
r_return
id|SCSI_SCAN_NO_RESPONSE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We used to do a TEST_UNIT_READY before the INQUIRY but that was &n;&t; * not really necessary.  Spec recommends using INQUIRY to scan for&n;&t; * devices (and TEST_UNIT_READY to poll for media change). - Paul G.&n;&t; */
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi scan: INQUIRY to host %d channel %d id %d lun %d&bslash;n&quot;
comma
id|shpnt-&gt;host_no
comma
id|channel
comma
id|dev
comma
id|lun
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Build an INQUIRY command block.&n;&t; */
id|memset
c_func
(paren
id|scsi_cmd
comma
l_int|0
comma
l_int|6
)paren
suffix:semicolon
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|INQUIRY
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lun
OG
l_int|0
)paren
op_logical_and
(paren
id|scsi_level
op_le
id|SCSI_2
)paren
)paren
id|scsi_cmd
(braket
l_int|1
)braket
op_assign
(paren
id|lun
op_lshift
l_int|5
)paren
op_amp
l_int|0xe0
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
l_int|36
suffix:semicolon
multiline_comment|/* issue conservative alloc_length */
id|SRpnt-&gt;sr_cmd_len
op_assign
l_int|0
suffix:semicolon
id|SRpnt-&gt;sr_data_direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
id|memset
c_func
(paren
id|scsi_result
comma
l_int|0
comma
l_int|36
)paren
suffix:semicolon
id|scsi_wait_req
(paren
id|SRpnt
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|scsi_result
comma
l_int|36
comma
id|SCSI_TIMEOUT
op_plus
l_int|4
op_star
id|HZ
comma
l_int|3
)paren
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi: INQUIRY %s with code 0x%x&bslash;n&quot;
comma
id|SRpnt-&gt;sr_result
ques
c_cond
l_string|&quot;failed&quot;
suffix:colon
l_string|&quot;successful&quot;
comma
id|SRpnt-&gt;sr_result
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now that we don&squot;t do TEST_UNIT_READY anymore, we must be prepared&n;&t; * for media change conditions here, so cannot require zero result.&n;&t; */
r_if
c_cond
(paren
id|SRpnt-&gt;sr_result
)paren
(brace
r_if
c_cond
(paren
(paren
id|driver_byte
c_func
(paren
id|SRpnt-&gt;sr_result
)paren
op_amp
id|DRIVER_SENSE
)paren
op_ne
l_int|0
op_logical_and
(paren
id|SRpnt-&gt;sr_sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_eq
id|UNIT_ATTENTION
op_logical_and
id|SRpnt-&gt;sr_sense_buffer
(braket
l_int|12
)braket
op_eq
l_int|0x28
op_logical_and
id|SRpnt-&gt;sr_sense_buffer
(braket
l_int|13
)braket
op_eq
l_int|0
)paren
(brace
multiline_comment|/* not-ready to ready transition - good */
multiline_comment|/* dpg: bogus? INQUIRY never returns UNIT_ATTENTION */
)brace
r_else
(brace
multiline_comment|/* assume no peripheral if any other sort of error */
id|scsi_release_request
c_func
(paren
id|SRpnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Get any flags for this device.  &n;&t; */
id|bflags
op_assign
id|get_device_flags
(paren
op_amp
id|scsi_result
(braket
l_int|8
)braket
comma
op_amp
id|scsi_result
(braket
l_int|16
)braket
)paren
suffix:semicolon
id|possible_inq_resp_len
op_assign
(paren
r_int
r_char
)paren
id|scsi_result
(braket
l_int|4
)braket
op_plus
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|BLIST_INQUIRY_36
op_amp
id|bflags
)paren
id|possible_inq_resp_len
op_assign
l_int|36
suffix:semicolon
r_else
r_if
c_cond
(paren
id|BLIST_INQUIRY_58
op_amp
id|bflags
)paren
id|possible_inq_resp_len
op_assign
l_int|58
suffix:semicolon
r_else
r_if
c_cond
(paren
id|possible_inq_resp_len
OG
l_int|255
)paren
id|possible_inq_resp_len
op_assign
l_int|36
suffix:semicolon
multiline_comment|/* sanity */
r_if
c_cond
(paren
id|possible_inq_resp_len
OG
l_int|36
)paren
(brace
multiline_comment|/* do additional INQUIRY */
id|memset
c_func
(paren
id|scsi_cmd
comma
l_int|0
comma
l_int|6
)paren
suffix:semicolon
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|INQUIRY
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lun
OG
l_int|0
)paren
op_logical_and
(paren
id|scsi_level
op_le
id|SCSI_2
)paren
)paren
id|scsi_cmd
(braket
l_int|1
)braket
op_assign
(paren
id|lun
op_lshift
l_int|5
)paren
op_amp
l_int|0xe0
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
(paren
r_int
r_char
)paren
id|possible_inq_resp_len
suffix:semicolon
id|SRpnt-&gt;sr_cmd_len
op_assign
l_int|0
suffix:semicolon
id|SRpnt-&gt;sr_data_direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
id|scsi_wait_req
(paren
id|SRpnt
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|scsi_result
comma
l_int|256
comma
id|SCSI_TIMEOUT
op_plus
l_int|4
op_star
id|HZ
comma
l_int|3
)paren
suffix:semicolon
multiline_comment|/* assume successful */
)brace
id|SDpnt-&gt;inquiry_len
op_assign
id|possible_inq_resp_len
suffix:semicolon
id|SDpnt-&gt;inquiry
op_assign
id|kmalloc
c_func
(paren
id|possible_inq_resp_len
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|SDpnt-&gt;inquiry
)paren
(brace
id|scsi_release_commandblocks
c_func
(paren
id|SDpnt
)paren
suffix:semicolon
id|scsi_release_request
c_func
(paren
id|SRpnt
)paren
suffix:semicolon
r_return
id|SCSI_SCAN_NO_RESPONSE
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|SDpnt-&gt;inquiry
comma
id|scsi_result
comma
id|possible_inq_resp_len
)paren
suffix:semicolon
id|SDpnt-&gt;vendor
op_assign
(paren
r_char
op_star
)paren
(paren
id|SDpnt-&gt;inquiry
op_plus
l_int|8
)paren
suffix:semicolon
id|SDpnt-&gt;model
op_assign
(paren
r_char
op_star
)paren
(paren
id|SDpnt-&gt;inquiry
op_plus
l_int|16
)paren
suffix:semicolon
id|SDpnt-&gt;rev
op_assign
(paren
r_char
op_star
)paren
(paren
id|SDpnt-&gt;inquiry
op_plus
l_int|32
)paren
suffix:semicolon
id|SDpnt-&gt;scsi_level
op_assign
id|scsi_result
(braket
l_int|2
)braket
op_amp
l_int|0x07
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt-&gt;scsi_level
op_ge
l_int|2
op_logical_or
(paren
id|SDpnt-&gt;scsi_level
op_eq
l_int|1
op_logical_and
(paren
id|scsi_result
(braket
l_int|3
)braket
op_amp
l_int|0x0f
)paren
op_eq
l_int|1
)paren
)paren
id|SDpnt-&gt;scsi_level
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * Check the peripheral qualifier field - this tells us whether LUNS&n;&t; * are supported here or not.&n;&t; */
r_if
c_cond
(paren
(paren
id|scsi_result
(braket
l_int|0
)braket
op_rshift
l_int|5
)paren
op_eq
l_int|3
)paren
(brace
multiline_comment|/*&n;&t;&t; * Peripheral qualifier 3 (011b): The device server is not&n;&t;&t; * capable of supporting a physical device on this logical&n;&t;&t; * unit.&n;&t;&t; */
id|scsi_release_commandblocks
c_func
(paren
id|SDpnt
)paren
suffix:semicolon
id|scsi_release_request
c_func
(paren
id|SRpnt
)paren
suffix:semicolon
r_return
id|SCSI_SCAN_DEVICE_PRESENT
suffix:semicolon
)brace
multiline_comment|/*   The Toshiba ROM was &quot;gender-changed&quot; here as an inline hack.&n;&t;      This is now much more generic.&n;&t;      This is a mess: What we really want is to leave the scsi_result&n;&t;      alone, and just change the SDpnt structure. And the SDpnt is what&n;&t;      we want print_inquiry to print.  -- REW&n;&t; */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_ISDISK
)paren
(brace
id|scsi_result
(braket
l_int|0
)braket
op_assign
id|TYPE_DISK
suffix:semicolon
id|scsi_result
(braket
l_int|1
)braket
op_or_assign
l_int|0x80
suffix:semicolon
multiline_comment|/* removable */
)brace
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_ISROM
)paren
(brace
id|scsi_result
(braket
l_int|0
)braket
op_assign
id|TYPE_ROM
suffix:semicolon
id|scsi_result
(braket
l_int|1
)braket
op_or_assign
l_int|0x80
suffix:semicolon
multiline_comment|/* removable */
)brace
id|SDpnt-&gt;removable
op_assign
(paren
l_int|0x80
op_amp
id|scsi_result
(braket
l_int|1
)braket
)paren
op_rshift
l_int|7
suffix:semicolon
multiline_comment|/* Use the peripheral qualifier field to determine online/offline */
r_if
c_cond
(paren
(paren
(paren
id|scsi_result
(braket
l_int|0
)braket
op_rshift
l_int|5
)paren
op_amp
l_int|7
)paren
op_eq
l_int|1
)paren
id|SDpnt-&gt;online
op_assign
id|FALSE
suffix:semicolon
r_else
id|SDpnt-&gt;online
op_assign
id|TRUE
suffix:semicolon
id|SDpnt-&gt;lockable
op_assign
id|SDpnt-&gt;removable
suffix:semicolon
id|SDpnt-&gt;changed
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;access_count
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;busy
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;has_cmdblocks
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Currently, all sequential devices are assumed to be tapes, all random&n;&t; * devices disk, with the appropriate read only flags set for ROM / WORM&n;&t; * treated as RO.&n;&t; */
r_switch
c_cond
(paren
id|type
op_assign
(paren
id|scsi_result
(braket
l_int|0
)braket
op_amp
l_int|0x1f
)paren
)paren
(brace
r_case
id|TYPE_TAPE
suffix:colon
r_case
id|TYPE_DISK
suffix:colon
r_case
id|TYPE_PRINTER
suffix:colon
r_case
id|TYPE_MOD
suffix:colon
r_case
id|TYPE_PROCESSOR
suffix:colon
r_case
id|TYPE_SCANNER
suffix:colon
r_case
id|TYPE_MEDIUM_CHANGER
suffix:colon
r_case
id|TYPE_ENCLOSURE
suffix:colon
r_case
id|TYPE_COMM
suffix:colon
id|SDpnt-&gt;writeable
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_WORM
suffix:colon
r_case
id|TYPE_ROM
suffix:colon
id|SDpnt-&gt;writeable
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi: unknown type %d&bslash;n&quot;
comma
id|type
)paren
suffix:semicolon
)brace
id|SDpnt-&gt;device_blocked
op_assign
id|FALSE
suffix:semicolon
id|SDpnt-&gt;device_busy
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;single_lun
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;soft_reset
op_assign
(paren
id|scsi_result
(braket
l_int|7
)braket
op_amp
l_int|1
)paren
op_logical_and
(paren
(paren
id|scsi_result
(braket
l_int|3
)braket
op_amp
l_int|7
)paren
op_eq
l_int|2
)paren
suffix:semicolon
id|SDpnt-&gt;random
op_assign
(paren
id|type
op_eq
id|TYPE_TAPE
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
id|SDpnt-&gt;type
op_assign
(paren
id|type
op_amp
l_int|0x1f
)paren
suffix:semicolon
id|print_inquiry
c_func
(paren
id|scsi_result
)paren
suffix:semicolon
id|sprintf
(paren
id|devname
comma
l_string|&quot;host%d/bus%d/target%d/lun%d&quot;
comma
id|SDpnt-&gt;host-&gt;host_no
comma
id|SDpnt-&gt;channel
comma
id|SDpnt-&gt;id
comma
id|SDpnt-&gt;lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt-&gt;de
)paren
id|printk
(paren
l_string|&quot;DEBUG: dir: &bslash;&quot;%s&bslash;&quot; already exists&bslash;n&quot;
comma
id|devname
)paren
suffix:semicolon
r_else
id|SDpnt-&gt;de
op_assign
id|devfs_mk_dir
(paren
id|scsi_devfs_handle
comma
id|devname
comma
l_int|NULL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sdtpnt
op_assign
id|scsi_devicelist
suffix:semicolon
id|sdtpnt
suffix:semicolon
id|sdtpnt
op_assign
id|sdtpnt-&gt;next
)paren
r_if
c_cond
(paren
id|sdtpnt-&gt;detect
)paren
id|SDpnt-&gt;attached
op_add_assign
(paren
op_star
id|sdtpnt-&gt;detect
)paren
(paren
id|SDpnt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Accommodate drivers that want to sleep when they should be in a polling&n;&t; * loop.&n;&t; */
id|SDpnt-&gt;disconnect
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Set the tagged_queue flag for SCSI-II devices that purport to support&n;&t; * tagged queuing in the INQUIRY data.&n;&t; */
id|SDpnt-&gt;tagged_queue
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|SDpnt-&gt;scsi_level
op_ge
id|SCSI_2
)paren
op_logical_and
(paren
id|scsi_result
(braket
l_int|7
)braket
op_amp
l_int|2
)paren
op_logical_and
op_logical_neg
(paren
id|bflags
op_amp
id|BLIST_NOTQ
)paren
)paren
(brace
id|SDpnt-&gt;tagged_supported
op_assign
l_int|1
suffix:semicolon
id|SDpnt-&gt;current_tag
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Some revisions of the Texel CD ROM drives have handshaking problems when&n;&t; * used with the Seagate controllers.  Before we know what type of device&n;&t; * we&squot;re talking to, we assume it&squot;s borken and then change it here if it&n;&t; * turns out that it isn&squot;t a TEXEL drive.&n;&t; */
r_if
c_cond
(paren
(paren
id|bflags
op_amp
id|BLIST_BORKEN
)paren
op_eq
l_int|0
)paren
id|SDpnt-&gt;borken
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If we want to only allow I/O to one of the luns attached to this device&n;&t; * at a time, then we set this flag.&n;&t; */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_SINGLELUN
)paren
id|SDpnt-&gt;single_lun
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * These devices need this &quot;key&quot; to unlock the devices so we can use it&n;&t; */
r_if
c_cond
(paren
(paren
id|bflags
op_amp
id|BLIST_KEY
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unlocked floptical drive.&bslash;n&quot;
)paren
suffix:semicolon
id|SDpnt-&gt;lockable
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|MODE_SENSE
suffix:semicolon
r_if
c_cond
(paren
id|shpnt-&gt;max_lun
op_le
l_int|8
)paren
id|scsi_cmd
(braket
l_int|1
)braket
op_assign
(paren
id|lun
op_lshift
l_int|5
)paren
op_amp
l_int|0xe0
suffix:semicolon
r_else
id|scsi_cmd
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* any other idea? */
id|scsi_cmd
(braket
l_int|2
)braket
op_assign
l_int|0x2e
suffix:semicolon
id|scsi_cmd
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
l_int|0x2a
suffix:semicolon
id|scsi_cmd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|SRpnt-&gt;sr_cmd_len
op_assign
l_int|0
suffix:semicolon
id|SRpnt-&gt;sr_data_direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
id|scsi_wait_req
(paren
id|SRpnt
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|scsi_result
comma
l_int|0x2a
comma
id|SCSI_TIMEOUT
comma
l_int|3
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * scsi_result no longer holds inquiry data.&n;&t;&t; */
)brace
id|scsi_release_request
c_func
(paren
id|SRpnt
)paren
suffix:semicolon
id|SRpnt
op_assign
l_int|NULL
suffix:semicolon
id|scsi_release_commandblocks
c_func
(paren
id|SDpnt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This device was already hooked up to the host in question,&n;&t; * so at this point we just let go of it and it should be fine.  We do need to&n;&t; * allocate a new one and attach it to the host so that we can further scan the bus.&n;&t; */
id|SDpnt
op_assign
(paren
id|Scsi_Device
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|Scsi_Device
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SDpnt
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi: scan_scsis_single: Cannot malloc&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|SCSI_SCAN_NO_RESPONSE
suffix:semicolon
)brace
id|memset
c_func
(paren
id|SDpnt
comma
l_int|0
comma
r_sizeof
(paren
id|Scsi_Device
)paren
)paren
suffix:semicolon
id|SDpnt-&gt;vendor
op_assign
id|scsi_null_device_strs
suffix:semicolon
id|SDpnt-&gt;model
op_assign
id|scsi_null_device_strs
suffix:semicolon
id|SDpnt-&gt;rev
op_assign
id|scsi_null_device_strs
suffix:semicolon
op_star
id|SDpnt2
op_assign
id|SDpnt
suffix:semicolon
id|SDpnt-&gt;queue_depth
op_assign
l_int|1
suffix:semicolon
id|SDpnt-&gt;host
op_assign
id|shpnt
suffix:semicolon
id|SDpnt-&gt;online
op_assign
id|TRUE
suffix:semicolon
id|SDpnt-&gt;scsi_level
op_assign
id|scsi_level
suffix:semicolon
multiline_comment|/*&n;&t; * Register the queue for the device.  All I/O requests will come&n;&t; * in through here.  We also need to register a pointer to&n;&t; * ourselves, since the queue handler won&squot;t know what device&n;&t; * the queue actually represents.   We could look it up, but it&n;&t; * is pointless work.&n;&t; */
id|scsi_initialize_queue
c_func
(paren
id|SDpnt
comma
id|shpnt
)paren
suffix:semicolon
id|SDpnt-&gt;host
op_assign
id|shpnt
suffix:semicolon
id|scsi_initialize_merge_fn
c_func
(paren
id|SDpnt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Mark this device as online, or otherwise we won&squot;t be able to do much with it.&n;&t; */
id|SDpnt-&gt;online
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/*&n;         * Initialize the object that we will use to wait for command blocks.&n;         */
id|init_waitqueue_head
c_func
(paren
op_amp
id|SDpnt-&gt;scpnt_wait
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Since we just found one device, there had damn well better be one in the list&n;&t; * already.&n;&t; */
r_if
c_cond
(paren
id|shpnt-&gt;host_queue
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;scan_scsis_single: Host queue == NULL&bslash;n&quot;
)paren
suffix:semicolon
id|SDtail
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
r_while
c_loop
(paren
id|SDtail-&gt;next
)paren
(brace
id|SDtail
op_assign
id|SDtail-&gt;next
suffix:semicolon
)brace
multiline_comment|/* Add this device to the linked list at the end */
id|SDtail-&gt;next
op_assign
id|SDpnt
suffix:semicolon
id|SDpnt-&gt;prev
op_assign
id|SDtail
suffix:semicolon
id|SDpnt-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_return
id|SCSI_SCAN_DEVICE_ADDED
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_report_lun_scan&n; *&n; * Purpose:     Use a SCSI REPORT LUN to determine what LUNs to scan.&n; *&n; * Arguments:   SDlun0_pnt - pointer to a Scsi_Device for LUN 0&n; * &t;&t;channel    - the host&squot;s channel&n; * &t;&t;dev        - target dev (target id)&n; * &t;&t;SDpnt2     - pointer to pointer of a preallocated Scsi_Device&n; * &t;&t;shpnt      - host device to use&n; * &t;&t;scsi_result - preallocated buffer for the SCSI command result&n; *&n; * Lock status: None&n; *&n; * Returns:     If the LUNs for device at shpnt/channel/dev are scanned,&n; * &t;&t;return 0, else return 1.&n; *&n; * Notes:       This code copies and truncates the 8 byte LUN into the&n; * &t;&t;current 4 byte (int) lun.&n; */
DECL|function|scsi_report_lun_scan
r_static
r_int
id|scsi_report_lun_scan
c_func
(paren
id|Scsi_Device
op_star
id|SDlun0_pnt
comma
r_int
r_int
id|channel
comma
r_int
r_int
id|dev
comma
id|Scsi_Device
op_star
op_star
id|SDpnt2
comma
r_struct
id|Scsi_Host
op_star
id|shpnt
comma
r_char
op_star
id|scsi_result
)paren
(brace
macro_line|#ifdef CONFIG_SCSI_REPORT_LUNS
r_char
id|devname
(braket
l_int|64
)braket
suffix:semicolon
r_int
r_char
id|scsi_cmd
(braket
id|MAX_COMMAND_SIZE
)braket
suffix:semicolon
r_int
r_int
id|length
suffix:semicolon
r_int
r_int
id|lun
suffix:semicolon
r_int
r_int
id|num_luns
suffix:semicolon
r_int
r_int
id|retries
suffix:semicolon
id|ScsiLun
op_star
id|fcp_cur_lun_pnt
comma
op_star
id|lun_data_pnt
suffix:semicolon
id|Scsi_Request
op_star
id|SRpnt
suffix:semicolon
r_int
id|scsi_level
suffix:semicolon
r_char
op_star
id|byte_pnt
suffix:semicolon
r_int
id|got_command_blocks
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Only support SCSI-3 and up devices.&n;&t; */
r_if
c_cond
(paren
id|SDlun0_pnt-&gt;scsi_level
OL
id|SCSI_3
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Note SDlun0_pnt might be invalid after scan_scsis_single is called.&n;&t; */
multiline_comment|/*&n;&t; * Command blocks might be built depending on whether LUN 0 was&n;&t; * configured or not. Checking has_cmdblocks here is ugly.&n;&t; */
r_if
c_cond
(paren
id|SDlun0_pnt-&gt;has_cmdblocks
op_eq
l_int|0
)paren
(brace
id|got_command_blocks
op_assign
l_int|1
suffix:semicolon
id|scsi_build_commandblocks
c_func
(paren
id|SDlun0_pnt
)paren
suffix:semicolon
)brace
id|SRpnt
op_assign
id|scsi_allocate_request
c_func
(paren
id|SDlun0_pnt
)paren
suffix:semicolon
id|sprintf
(paren
id|devname
comma
l_string|&quot;host %d channel %d id %d&quot;
comma
id|SDlun0_pnt-&gt;host-&gt;host_no
comma
id|SDlun0_pnt-&gt;channel
comma
id|SDlun0_pnt-&gt;id
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate enough to hold the header (the same size as one ScsiLun)&n;&t; * plus the max number of luns we are requesting.&n;&t; *&n;&t; * XXX: Maybe allocate this once, like scsi_result, and pass it down.&n;&t; * scsi_result can&squot;t be used, as it is needed for the scan INQUIRY&n;&t; * data. In addition, reallocating and trying again (with the exact&n;&t; * amount we need) would be nice, but then we need to somehow limit the&n;&t; * size allocated based on the available memory (and limits of kmalloc).&n;&t; */
id|length
op_assign
(paren
id|max_scsi_report_luns
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
id|ScsiLun
)paren
suffix:semicolon
id|lun_data_pnt
op_assign
(paren
id|ScsiLun
op_star
)paren
id|kmalloc
c_func
(paren
id|length
comma
(paren
id|shpnt-&gt;unchecked_isa_dma
ques
c_cond
id|GFP_DMA
suffix:colon
id|GFP_ATOMIC
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lun_data_pnt
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi: scsi_report_lun_scan: Cannot malloc&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|got_command_blocks
)paren
id|scsi_release_commandblocks
c_func
(paren
id|SDlun0_pnt
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|REPORT_LUNS
suffix:semicolon
multiline_comment|/*&n;&t; * bytes 1 - 5: reserved, set to zero.&n;&t; */
id|memset
c_func
(paren
op_amp
id|scsi_cmd
(braket
l_int|1
)braket
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * bytes 6 - 9: length of the command.&n;&t; */
id|scsi_cmd
(braket
l_int|6
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|length
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
suffix:semicolon
id|scsi_cmd
(braket
l_int|7
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|length
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
id|scsi_cmd
(braket
l_int|8
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|length
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|scsi_cmd
(braket
l_int|9
)braket
op_assign
(paren
r_int
r_char
)paren
id|length
op_amp
l_int|0xff
suffix:semicolon
id|scsi_cmd
(braket
l_int|10
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* reserved */
id|scsi_cmd
(braket
l_int|11
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* control */
id|SRpnt-&gt;sr_cmd_len
op_assign
l_int|0
suffix:semicolon
id|SRpnt-&gt;sr_data_direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
multiline_comment|/*&n;&t; * We can get a UNIT ATTENTION, for example a power on/reset, so retry&n;&t; * a few times (like sd.c does for TEST UNIT READY). Experience shows&n;&t; * some combinations of adapter/devices get at least two power&n;&t; * on/resets.&n;&t; *&n;&t; * Illegal requests (for devices that do not support REPORT LUNS)&n;&t; * should come through as a check condition, and will not generate a&n;&t; * retry.&n;&t; */
id|retries
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|retries
op_increment
OL
l_int|3
)paren
(brace
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi: Sending REPORT LUNS to %s (try %d)&bslash;n&quot;
comma
id|devname
comma
id|retries
)paren
)paren
suffix:semicolon
id|scsi_wait_req
(paren
id|SRpnt
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|lun_data_pnt
comma
id|length
comma
id|SCSI_TIMEOUT
op_plus
l_int|4
op_star
id|HZ
comma
l_int|3
)paren
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi: REPORT LUNS %s (try %d) result 0x%x&bslash;n&quot;
comma
id|SRpnt-&gt;sr_result
ques
c_cond
l_string|&quot;failed&quot;
suffix:colon
l_string|&quot;successful&quot;
comma
id|retries
comma
id|SRpnt-&gt;sr_result
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SRpnt-&gt;sr_result
op_eq
l_int|0
op_logical_or
id|SRpnt-&gt;sr_sense_buffer
(braket
l_int|2
)braket
op_ne
id|UNIT_ATTENTION
)paren
r_break
suffix:semicolon
)brace
id|scsi_release_request
c_func
(paren
id|SRpnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|got_command_blocks
)paren
id|scsi_release_commandblocks
c_func
(paren
id|SDlun0_pnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SRpnt-&gt;sr_result
)paren
(brace
id|kfree
c_func
(paren
(paren
r_char
op_star
)paren
id|lun_data_pnt
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get the length from the first four bytes of lun_data_pnt.&n;&t; */
id|byte_pnt
op_assign
(paren
r_char
op_star
)paren
id|lun_data_pnt-&gt;scsi_lun
suffix:semicolon
id|length
op_assign
(paren
(paren
id|byte_pnt
(braket
l_int|0
)braket
op_lshift
l_int|24
)paren
op_or
(paren
id|byte_pnt
(braket
l_int|1
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|byte_pnt
(braket
l_int|2
)braket
op_lshift
l_int|8
)paren
op_or
(paren
id|byte_pnt
(braket
l_int|3
)braket
op_lshift
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|length
op_div
r_sizeof
(paren
id|ScsiLun
)paren
)paren
OG
id|max_scsi_report_luns
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi: On %s only %d (max_scsi_report_luns) of %d luns&quot;
l_string|&quot; reported, try increasing max_scsi_report_luns.&bslash;n&quot;
comma
id|devname
comma
id|max_scsi_report_luns
comma
id|length
op_div
r_sizeof
(paren
id|ScsiLun
)paren
)paren
suffix:semicolon
id|num_luns
op_assign
id|max_scsi_report_luns
suffix:semicolon
)brace
r_else
id|num_luns
op_assign
(paren
id|length
op_div
r_sizeof
(paren
id|ScsiLun
)paren
)paren
suffix:semicolon
id|scsi_level
op_assign
id|SDlun0_pnt-&gt;scsi_level
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi: REPORT LUN scan of host %d channel %d id %d&bslash;n&quot;
comma
id|SDlun0_pnt-&gt;host-&gt;host_no
comma
id|SDlun0_pnt-&gt;channel
comma
id|SDlun0_pnt-&gt;id
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Scan the luns in lun_data_pnt. The entry at offset 0 is really&n;&t; * the header, so start at 1 and go up to and including num_luns.&n;&t; */
r_for
c_loop
(paren
id|fcp_cur_lun_pnt
op_assign
op_amp
id|lun_data_pnt
(braket
l_int|1
)braket
suffix:semicolon
id|fcp_cur_lun_pnt
op_le
op_amp
id|lun_data_pnt
(braket
id|num_luns
)braket
suffix:semicolon
id|fcp_cur_lun_pnt
op_increment
)paren
(brace
id|lun
op_assign
id|scsilun_to_int
c_func
(paren
id|fcp_cur_lun_pnt
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check if the unused part of fcp_cur_lun_pnt is non-zero,&n;&t;&t; * and so does not fit in lun.&n;&t;&t; */
r_if
c_cond
(paren
id|memcmp
c_func
(paren
op_amp
id|fcp_cur_lun_pnt-&gt;scsi_lun
(braket
r_sizeof
(paren
id|lun
)paren
)braket
comma
l_string|&quot;&bslash;0&bslash;0&bslash;0&bslash;0&quot;
comma
l_int|4
)paren
op_ne
l_int|0
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Output an error displaying the LUN in byte order,&n;&t;&t;&t; * this differs from what linux would print for the&n;&t;&t;&t; * integer LUN value.&n;&t;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;scsi: %s lun 0x&quot;
comma
id|devname
)paren
suffix:semicolon
id|byte_pnt
op_assign
(paren
r_char
op_star
)paren
id|fcp_cur_lun_pnt-&gt;scsi_lun
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|ScsiLun
)paren
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%02x&quot;
comma
id|byte_pnt
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; has a LUN larger than that supported by&quot;
l_string|&quot; the kernel&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lun
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * LUN 0 has already been scanned.&n;&t;&t;&t; */
)brace
r_else
r_if
c_cond
(paren
id|lun
OG
id|shpnt-&gt;max_lun
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi: %s lun %d has a LUN larger than allowed&quot;
l_string|&quot; by the host adapter&bslash;n&quot;
comma
id|devname
comma
id|lun
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Don&squot;t use SDlun0_pnt after this call - it can be&n;&t;&t;&t; * overwritten via SDpnt2 if there was no real device&n;&t;&t;&t; * at LUN 0.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|scan_scsis_single
c_func
(paren
id|channel
comma
id|dev
comma
id|lun
comma
id|scsi_level
comma
id|SDpnt2
comma
id|shpnt
comma
id|scsi_result
)paren
op_eq
id|SCSI_SCAN_NO_RESPONSE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Got some results, but now none, abort.&n;&t;&t;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;scsi: no response from %s lun %d while&quot;
l_string|&quot; scanning, scan aborted&bslash;n&quot;
comma
id|devname
comma
id|lun
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|kfree
c_func
(paren
(paren
r_char
op_star
)paren
id|lun_data_pnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#else
r_return
l_int|1
suffix:semicolon
macro_line|#endif&t;/* CONFIG_SCSI_REPORT_LUNS */
)brace
multiline_comment|/*&n; * Function:    scan_scsis_target&n; *&n; * Purpose:     Scan the given scsi target dev, and as needed all LUNs&n; * &t;&t;on the target dev.&n; *&n; * Arguments:   channel    - the host&squot;s channel&n; * &t;&t;dev        - target dev (target id)&n; * &t;&t;SDpnt2     - pointer to pointer of a preallocated Scsi_Device&n; * &t;&t;shpnt      - host device to use&n; * &t;&t;scsi_result - preallocated buffer for the SCSI command result&n; *&n; * Lock status: None&n; *&n; * Returns:     void&n; *&n; * Notes:       This tries to be compatible with linux 2.4.x. This function&n; * &t;&t;relies on scan_scsis_single to setup SDlun0_pnt. &n; *&n; * &t;&t;It would be better if the Scsi_Device allocation and freeing&n; * &t;&t;was done here, rather than oddly embedded in scan_scsis_single&n; * &t;&t;and scan_scsis.&n; */
DECL|function|scan_scsis_target
r_static
r_void
id|scan_scsis_target
c_func
(paren
r_int
r_int
id|channel
comma
r_int
r_int
id|dev
comma
id|Scsi_Device
op_star
op_star
id|SDpnt2
comma
r_struct
id|Scsi_Host
op_star
id|shpnt
comma
r_char
op_star
id|scsi_result
)paren
(brace
r_int
id|bflags
comma
id|scsi_level
suffix:semicolon
id|Scsi_Device
op_star
id|SDlun0_pnt
suffix:semicolon
r_int
r_int
id|sparse_lun
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|max_dev_lun
comma
id|lun
suffix:semicolon
r_int
r_int
id|sdlun0_res
suffix:semicolon
multiline_comment|/*&n;&t; * Scan lun 0, use the results to determine whether to scan further.&n;&t; * Ideally, we would not configure LUN 0 until we scan.&n;&t; */
id|SDlun0_pnt
op_assign
op_star
id|SDpnt2
suffix:semicolon
id|sdlun0_res
op_assign
id|scan_scsis_single
c_func
(paren
id|channel
comma
id|dev
comma
l_int|0
multiline_comment|/* LUN 0 */
comma
id|SCSI_2
comma
id|SDpnt2
comma
id|shpnt
comma
id|scsi_result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdlun0_res
op_eq
id|SCSI_SCAN_NO_RESPONSE
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * If no new SDpnt was allocated (SCSI_SCAN_DEVICE_PRESENT), SDlun0_pnt&n;&t; * can later be modified. It is unlikely the lun level would change,&n;&t; * but save it just in case.&n;&t; */
id|scsi_level
op_assign
id|SDlun0_pnt-&gt;scsi_level
suffix:semicolon
multiline_comment|/*&n;&t; * We could probably use and save the bflags from lun 0 for all luns&n;&t; * on a target, but be safe and match current behaviour. (LUN 0&n;&t; * bflags controls the target settings checked within this function.)&n;&t; */
id|bflags
op_assign
id|get_device_flags
(paren
id|SDlun0_pnt-&gt;vendor
comma
id|SDlun0_pnt-&gt;model
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Some scsi devices cannot be polled for lun != 0 due to firmware bugs&n;&t; */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_NOLUN
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Ending the scan here if max_scsi_luns == 1 breaks scanning of&n;&t; * SPARSE, FORCE, MAX5 LUN devices, and the report lun scans.&n;&t; */
r_if
c_cond
(paren
id|scsi_report_lun_scan
c_func
(paren
id|SDlun0_pnt
comma
id|channel
comma
id|dev
comma
id|SDpnt2
comma
id|shpnt
comma
id|scsi_result
)paren
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi: Sequential scan of host %d channel %d id %d&bslash;n&quot;
comma
id|SDlun0_pnt-&gt;host-&gt;host_no
comma
id|SDlun0_pnt-&gt;channel
comma
id|SDlun0_pnt-&gt;id
)paren
)paren
suffix:semicolon
id|max_dev_lun
op_assign
(paren
id|max_scsi_luns
OL
id|shpnt-&gt;max_lun
ques
c_cond
id|max_scsi_luns
suffix:colon
id|shpnt-&gt;max_lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If this device is known to support sparse multiple units,&n;&t; * override the other settings, and scan all of them.&n;&t; */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_SPARSELUN
)paren
(brace
id|max_dev_lun
op_assign
id|shpnt-&gt;max_lun
suffix:semicolon
id|sparse_lun
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sdlun0_res
op_eq
id|SCSI_SCAN_DEVICE_PRESENT
)paren
(brace
multiline_comment|/*&n;&t;&t; * LUN 0 responded, but no LUN 0 was added, don&squot;t scan any&n;&t;&t; * further. This matches linux 2.4.x behaviour.&n;&t;&t; */
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If less than SCSI_1_CSS, and not a forced lun scan, stop&n;&t; * scanning, this matches 2.4 behaviour, but it could be a bug&n;&t; * to scan SCSI_1_CSS devices past LUN 0.&n;&t; */
r_if
c_cond
(paren
(paren
id|scsi_level
OL
id|SCSI_1_CCS
)paren
op_logical_and
(paren
(paren
id|bflags
op_amp
(paren
id|BLIST_FORCELUN
op_or
id|BLIST_SPARSELUN
op_or
id|BLIST_MAX5LUN
)paren
)paren
op_eq
l_int|0
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * If this device is known to support multiple units, override&n;&t; * the other settings, and scan all of them.&n;&t; */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_FORCELUN
)paren
id|max_dev_lun
op_assign
id|shpnt-&gt;max_lun
suffix:semicolon
multiline_comment|/*&n;&t; * REGAL CDC-4X: avoid hang after LUN 4&n;&t; */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_MAX5LUN
)paren
id|max_dev_lun
op_assign
id|min
c_func
(paren
l_int|5U
comma
id|max_dev_lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do not scan past LUN 7.&n;&t; */
r_if
c_cond
(paren
id|scsi_level
OL
id|SCSI_3
)paren
id|max_dev_lun
op_assign
id|min
c_func
(paren
l_int|8U
comma
id|max_dev_lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We have already scanned lun 0.&n;&t; */
r_for
c_loop
(paren
id|lun
op_assign
l_int|1
suffix:semicolon
id|lun
OL
id|max_dev_lun
suffix:semicolon
op_increment
id|lun
)paren
(brace
r_int
id|res
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Scan until scan_scsis_single says stop,&n;&t;&t; * unless sparse_lun is set.&n;&t;&t; */
id|res
op_assign
id|scan_scsis_single
c_func
(paren
id|channel
comma
id|dev
comma
id|lun
comma
id|scsi_level
comma
id|SDpnt2
comma
id|shpnt
comma
id|scsi_result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_eq
id|SCSI_SCAN_NO_RESPONSE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Got a response on LUN 0, but now no response.&n;&t;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;scsi: no response from device&quot;
l_string|&quot; host%d/bus%d/target%d/lun%d&quot;
l_string|&quot; while scanning, scan aborted&bslash;n&quot;
comma
id|shpnt-&gt;host_no
comma
id|channel
comma
id|dev
comma
id|lun
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|res
op_eq
id|SCSI_SCAN_DEVICE_PRESENT
)paren
op_logical_and
op_logical_neg
id|sparse_lun
)paren
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Returns the scsi_level of lun0 on this host, channel and dev (if already&n; * known), otherwise returns SCSI_2.&n; */
DECL|function|find_lun0_scsi_level
r_static
r_int
id|find_lun0_scsi_level
c_func
(paren
r_int
r_int
id|channel
comma
r_int
r_int
id|dev
comma
r_struct
id|Scsi_Host
op_star
id|shpnt
)paren
(brace
r_int
id|res
op_assign
id|SCSI_2
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
r_for
c_loop
(paren
id|SDpnt
op_assign
id|shpnt-&gt;host_queue
suffix:semicolon
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SDpnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
l_int|0
op_eq
id|SDpnt-&gt;lun
)paren
op_logical_and
(paren
id|dev
op_eq
id|SDpnt-&gt;id
)paren
op_logical_and
(paren
id|channel
op_eq
id|SDpnt-&gt;channel
)paren
)paren
r_return
(paren
r_int
)paren
id|SDpnt-&gt;scsi_level
suffix:semicolon
)brace
multiline_comment|/* haven&squot;t found lun0, should send INQUIRY but take easy route */
r_return
id|res
suffix:semicolon
)brace
eof
