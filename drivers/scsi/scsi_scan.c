multiline_comment|/*&n; * scsi_scan.c&n; *&n; * Copyright (C) 2000 Eric Youngdale,&n; * Copyright (C) 2002 Patrick Mansfield&n; *&n; * The general scanning/probing algorithm is as follows, exceptions are&n; * made to it depending on device specific flags, compilation options, and&n; * global variable (boot or module load time) settings.&n; *&n; * A specific LUN is scanned via an INQUIRY command; if the LUN has a&n; * device attached, a Scsi_Device is allocated and setup for it.&n; *&n; * For every id of every channel on the given host:&n; *&n; * &t;Scan LUN 0; if the target responds to LUN 0 (even if there is no&n; * &t;device or storage attached to LUN 0):&n; *&n; * &t;&t;If LUN 0 has a device attached, allocate and setup a&n; * &t;&t;Scsi_Device for it.&n; *&n; * &t;&t;If target is SCSI-3 or up, issue a REPORT LUN, and scan&n; * &t;&t;all of the LUNs returned by the REPORT LUN; else,&n; * &t;&t;sequentially scan LUNs up until some maximum is reached,&n; * &t;&t;or a LUN is seen that cannot have a device attached to it.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;scsi/scsi.h&gt;
macro_line|#include &lt;scsi/scsi_device.h&gt;
macro_line|#include &lt;scsi/scsi_driver.h&gt;
macro_line|#include &lt;scsi/scsi_devinfo.h&gt;
macro_line|#include &lt;scsi/scsi_host.h&gt;
macro_line|#include &lt;scsi/scsi_request.h&gt;
macro_line|#include &lt;scsi/scsi_transport.h&gt;
macro_line|#include &lt;scsi/scsi_eh.h&gt;
macro_line|#include &quot;scsi_priv.h&quot;
macro_line|#include &quot;scsi_logging.h&quot;
DECL|macro|ALLOC_FAILURE_MSG
mdefine_line|#define ALLOC_FAILURE_MSG&t;KERN_ERR &quot;%s: Allocation failure during&quot; &bslash;&n;&t;&quot; SCSI scanning, some SCSI devices might not be configured&bslash;n&quot;
multiline_comment|/*&n; * Default timeout&n; */
DECL|macro|SCSI_TIMEOUT
mdefine_line|#define SCSI_TIMEOUT (2*HZ)
multiline_comment|/*&n; * Prefix values for the SCSI id&squot;s (stored in driverfs name field)&n; */
DECL|macro|SCSI_UID_SER_NUM
mdefine_line|#define SCSI_UID_SER_NUM &squot;S&squot;
DECL|macro|SCSI_UID_UNKNOWN
mdefine_line|#define SCSI_UID_UNKNOWN &squot;Z&squot;
multiline_comment|/*&n; * Return values of some of the scanning functions.&n; *&n; * SCSI_SCAN_NO_RESPONSE: no valid response received from the target, this&n; * includes allocation or general failures preventing IO from being sent.&n; *&n; * SCSI_SCAN_TARGET_PRESENT: target responded, but no device is available&n; * on the given LUN.&n; *&n; * SCSI_SCAN_LUN_PRESENT: target responded, and a device is available on a&n; * given LUN.&n; */
DECL|macro|SCSI_SCAN_NO_RESPONSE
mdefine_line|#define SCSI_SCAN_NO_RESPONSE&t;&t;0
DECL|macro|SCSI_SCAN_TARGET_PRESENT
mdefine_line|#define SCSI_SCAN_TARGET_PRESENT&t;1
DECL|macro|SCSI_SCAN_LUN_PRESENT
mdefine_line|#define SCSI_SCAN_LUN_PRESENT&t;&t;2
DECL|variable|scsi_null_device_strs
r_static
r_char
op_star
id|scsi_null_device_strs
op_assign
l_string|&quot;nullnullnullnull&quot;
suffix:semicolon
DECL|macro|MAX_SCSI_LUNS
mdefine_line|#define MAX_SCSI_LUNS&t;512
macro_line|#ifdef CONFIG_SCSI_MULTI_LUN
DECL|variable|max_scsi_luns
r_static
r_int
r_int
id|max_scsi_luns
op_assign
id|MAX_SCSI_LUNS
suffix:semicolon
macro_line|#else
DECL|variable|max_scsi_luns
r_static
r_int
r_int
id|max_scsi_luns
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
id|module_param_named
c_func
(paren
id|max_luns
comma
id|max_scsi_luns
comma
r_int
comma
id|S_IRUGO
op_or
id|S_IWUSR
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|max_luns
comma
l_string|&quot;last scsi LUN (should be between 1 and 2^32-1)&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * max_scsi_report_luns: the maximum number of LUNS that will be&n; * returned from the REPORT LUNS command. 8 times this value must&n; * be allocated. In theory this could be up to an 8 byte value, but&n; * in practice, the maximum number of LUNs suppored by any device&n; * is about 16k.&n; */
DECL|variable|max_scsi_report_luns
r_static
r_int
r_int
id|max_scsi_report_luns
op_assign
l_int|511
suffix:semicolon
id|module_param_named
c_func
(paren
id|max_report_luns
comma
id|max_scsi_report_luns
comma
r_int
comma
id|S_IRUGO
op_or
id|S_IWUSR
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|max_report_luns
comma
l_string|&quot;REPORT LUNS maximum number of LUNS received (should be&quot;
l_string|&quot; between 1 and 16384)&quot;
)paren
suffix:semicolon
DECL|variable|scsi_inq_timeout
r_static
r_int
r_int
id|scsi_inq_timeout
op_assign
id|SCSI_TIMEOUT
op_div
id|HZ
op_plus
l_int|3
suffix:semicolon
id|module_param_named
c_func
(paren
id|inq_timeout
comma
id|scsi_inq_timeout
comma
r_int
comma
id|S_IRUGO
op_or
id|S_IWUSR
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|inq_timeout
comma
l_string|&quot;Timeout (in seconds) waiting for devices to answer INQUIRY.&quot;
l_string|&quot; Default is 5. Some non-compliant devices need more.&quot;
)paren
suffix:semicolon
multiline_comment|/**&n; * scsi_unlock_floptical - unlock device via a special MODE SENSE command&n; * @sreq:&t;used to send the command&n; * @result:&t;area to store the result of the MODE SENSE&n; *&n; * Description:&n; *     Send a vendor specific MODE SENSE (not a MODE SELECT) command using&n; *     @sreq to unlock a device, storing the (unused) results into result.&n; *     Called for BLIST_KEY devices.&n; **/
DECL|function|scsi_unlock_floptical
r_static
r_void
id|scsi_unlock_floptical
c_func
(paren
r_struct
id|scsi_request
op_star
id|sreq
comma
r_int
r_char
op_star
id|result
)paren
(brace
r_int
r_char
id|scsi_cmd
(braket
id|MAX_COMMAND_SIZE
)braket
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;scsi: unlocking floptical drive&bslash;n&quot;
)paren
suffix:semicolon
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|MODE_SENSE
suffix:semicolon
id|scsi_cmd
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|2
)braket
op_assign
l_int|0x2e
suffix:semicolon
id|scsi_cmd
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
l_int|0x2a
suffix:semicolon
multiline_comment|/* size */
id|scsi_cmd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_cmd_len
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_data_direction
op_assign
id|DMA_FROM_DEVICE
suffix:semicolon
id|scsi_wait_req
c_func
(paren
id|sreq
comma
id|scsi_cmd
comma
id|result
comma
l_int|0x2a
multiline_comment|/* size */
comma
id|SCSI_TIMEOUT
comma
l_int|3
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * print_inquiry - printk the inquiry information&n; * @inq_result:&t;printk this SCSI INQUIRY&n; *&n; * Description:&n; *     printk the vendor, model, and other information found in the&n; *     INQUIRY data in @inq_result.&n; *&n; * Notes:&n; *     Remove this, and replace with a hotplug event that logs any&n; *     relevant information.&n; **/
DECL|function|print_inquiry
r_static
r_void
id|print_inquiry
c_func
(paren
r_int
r_char
op_star
id|inq_result
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;  Vendor: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|8
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|inq_result
(braket
id|i
)braket
op_ge
l_int|0x20
op_logical_and
id|i
OL
id|inq_result
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|inq_result
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  Model: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|16
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|inq_result
(braket
id|i
)braket
op_ge
l_int|0x20
op_logical_and
id|i
OL
id|inq_result
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|inq_result
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  Rev: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|32
suffix:semicolon
id|i
OL
l_int|36
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|inq_result
(braket
id|i
)braket
op_ge
l_int|0x20
op_logical_and
id|i
OL
id|inq_result
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|inq_result
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|i
op_assign
id|inq_result
(braket
l_int|0
)braket
op_amp
l_int|0x1f
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;  Type:   %s &quot;
comma
id|i
OL
id|MAX_SCSI_DEVICE_CODE
ques
c_cond
id|scsi_device_types
(braket
id|i
)braket
suffix:colon
l_string|&quot;Unknown          &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;                 ANSI SCSI revision: %02x&quot;
comma
id|inq_result
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inq_result
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
op_eq
l_int|1
op_logical_and
(paren
id|inq_result
(braket
l_int|3
)braket
op_amp
l_int|0x0f
)paren
op_eq
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot; CCS&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_alloc_sdev - allocate and setup a scsi_Device&n; *&n; * Description:&n; *     Allocate, initialize for io, and return a pointer to a scsi_Device.&n; *     Stores the @shost, @channel, @id, and @lun in the scsi_Device, and&n; *     adds scsi_Device to the appropriate list.&n; *&n; * Return value:&n; *     scsi_Device pointer, or NULL on failure.&n; **/
DECL|function|scsi_alloc_sdev
r_static
r_struct
id|scsi_device
op_star
id|scsi_alloc_sdev
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
comma
id|uint
id|channel
comma
id|uint
id|id
comma
id|uint
id|lun
comma
r_void
op_star
id|hostdata
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|display_failure_msg
op_assign
l_int|1
comma
id|ret
suffix:semicolon
id|sdev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|sdev
)paren
op_plus
id|shost-&gt;transportt-&gt;device_size
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sdev
)paren
r_goto
id|out
suffix:semicolon
id|memset
c_func
(paren
id|sdev
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|sdev
)paren
)paren
suffix:semicolon
id|sdev-&gt;vendor
op_assign
id|scsi_null_device_strs
suffix:semicolon
id|sdev-&gt;model
op_assign
id|scsi_null_device_strs
suffix:semicolon
id|sdev-&gt;rev
op_assign
id|scsi_null_device_strs
suffix:semicolon
id|sdev-&gt;host
op_assign
id|shost
suffix:semicolon
id|sdev-&gt;id
op_assign
id|id
suffix:semicolon
id|sdev-&gt;lun
op_assign
id|lun
suffix:semicolon
id|sdev-&gt;channel
op_assign
id|channel
suffix:semicolon
id|sdev-&gt;sdev_state
op_assign
id|SDEV_CREATED
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sdev-&gt;siblings
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sdev-&gt;same_target_siblings
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sdev-&gt;cmd_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sdev-&gt;starved_entry
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|sdev-&gt;list_lock
)paren
suffix:semicolon
multiline_comment|/* usually NULL and set by -&gt;slave_alloc instead */
id|sdev-&gt;hostdata
op_assign
id|hostdata
suffix:semicolon
multiline_comment|/* if the device needs this changing, it may do so in the&n;&t; * slave_configure function */
id|sdev-&gt;max_device_blocked
op_assign
id|SCSI_DEFAULT_DEVICE_BLOCKED
suffix:semicolon
multiline_comment|/*&n;&t; * Some low level driver could use device-&gt;type&n;&t; */
id|sdev-&gt;type
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Assume that the device will have handshaking problems,&n;&t; * and then fix this field later if it turns out it&n;&t; * doesn&squot;t&n;&t; */
id|sdev-&gt;borken
op_assign
l_int|1
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|sdev-&gt;sdev_lock
)paren
suffix:semicolon
id|sdev-&gt;request_queue
op_assign
id|scsi_alloc_queue
c_func
(paren
id|sdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sdev-&gt;request_queue
)paren
r_goto
id|out_free_dev
suffix:semicolon
id|sdev-&gt;request_queue-&gt;queuedata
op_assign
id|sdev
suffix:semicolon
id|scsi_adjust_queue_depth
c_func
(paren
id|sdev
comma
l_int|0
comma
id|sdev-&gt;host-&gt;cmd_per_lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shost-&gt;transportt-&gt;device_setup
)paren
(brace
r_if
c_cond
(paren
id|shost-&gt;transportt
op_member_access_from_pointer
id|device_setup
c_func
(paren
id|sdev
)paren
)paren
r_goto
id|out_free_queue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|shost-&gt;hostt-&gt;slave_alloc
)paren
(brace
id|ret
op_assign
id|shost-&gt;hostt
op_member_access_from_pointer
id|slave_alloc
c_func
(paren
id|sdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * if LLDD reports slave not present, don&squot;t clutter&n;&t;&t;&t; * console with alloc failure messages&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|ENXIO
)paren
id|display_failure_msg
op_assign
l_int|0
suffix:semicolon
r_goto
id|out_device_destroy
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|scsi_sysfs_device_initialize
c_func
(paren
id|sdev
)paren
op_ne
l_int|0
)paren
r_goto
id|out_cleanup_slave
suffix:semicolon
multiline_comment|/* NOTE: this target initialisation code depends critically on&n;&t; * lun scanning being sequential. */
r_if
c_cond
(paren
id|scsi_sysfs_target_initialize
c_func
(paren
id|sdev
)paren
)paren
r_goto
id|out_remove_siblings
suffix:semicolon
r_return
id|sdev
suffix:semicolon
id|out_remove_siblings
suffix:colon
id|spin_lock_irqsave
c_func
(paren
id|shost-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|sdev-&gt;siblings
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|sdev-&gt;same_target_siblings
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|shost-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|out_cleanup_slave
suffix:colon
r_if
c_cond
(paren
id|shost-&gt;hostt-&gt;slave_destroy
)paren
id|shost-&gt;hostt
op_member_access_from_pointer
id|slave_destroy
c_func
(paren
id|sdev
)paren
suffix:semicolon
id|out_device_destroy
suffix:colon
r_if
c_cond
(paren
id|shost-&gt;transportt-&gt;device_destroy
)paren
id|shost-&gt;transportt
op_member_access_from_pointer
id|device_destroy
c_func
(paren
id|sdev
)paren
suffix:semicolon
id|out_free_queue
suffix:colon
id|scsi_free_queue
c_func
(paren
id|sdev-&gt;request_queue
)paren
suffix:semicolon
id|out_free_dev
suffix:colon
id|kfree
c_func
(paren
id|sdev
)paren
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|display_failure_msg
)paren
id|printk
c_func
(paren
id|ALLOC_FAILURE_MSG
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_probe_lun - probe a single LUN using a SCSI INQUIRY&n; * @sreq:&t;used to send the INQUIRY&n; * @inq_result:&t;area to store the INQUIRY result&n; * @bflags:&t;store any bflags found here&n; *&n; * Description:&n; *     Probe the lun associated with @sreq using a standard SCSI INQUIRY;&n; *&n; *     If the INQUIRY is successful, sreq-&gt;sr_result is zero and: the&n; *     INQUIRY data is in @inq_result; the scsi_level and INQUIRY length&n; *     are copied to the Scsi_Device at @sreq-&gt;sr_device (sdev);&n; *     any flags value is stored in *@bflags.&n; **/
DECL|function|scsi_probe_lun
r_static
r_void
id|scsi_probe_lun
c_func
(paren
r_struct
id|scsi_request
op_star
id|sreq
comma
r_char
op_star
id|inq_result
comma
r_int
op_star
id|bflags
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
op_assign
id|sreq-&gt;sr_device
suffix:semicolon
multiline_comment|/* a bit ugly */
r_int
r_char
id|scsi_cmd
(braket
id|MAX_COMMAND_SIZE
)braket
suffix:semicolon
r_int
id|first_inquiry_len
comma
id|try_inquiry_len
comma
id|next_inquiry_len
suffix:semicolon
r_int
id|response_len
op_assign
l_int|0
suffix:semicolon
r_int
id|pass
comma
id|count
suffix:semicolon
r_struct
id|scsi_sense_hdr
id|sshdr
suffix:semicolon
op_star
id|bflags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Perform up to 3 passes.  The first pass uses a conservative&n;&t; * transfer length of 36 unless sdev-&gt;inquiry_len specifies a&n;&t; * different value. */
id|first_inquiry_len
op_assign
id|sdev-&gt;inquiry_len
ques
c_cond
id|sdev-&gt;inquiry_len
suffix:colon
l_int|36
suffix:semicolon
id|try_inquiry_len
op_assign
id|first_inquiry_len
suffix:semicolon
id|pass
op_assign
l_int|1
suffix:semicolon
id|next_pass
suffix:colon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi scan: INQUIRY pass %d &quot;
l_string|&quot;to host %d channel %d id %d lun %d, length %d&bslash;n&quot;
comma
id|pass
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
comma
id|try_inquiry_len
)paren
)paren
suffix:semicolon
multiline_comment|/* Each pass gets up to three chances to ignore Unit Attention */
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|3
suffix:semicolon
op_increment
id|count
)paren
(brace
id|memset
c_func
(paren
id|scsi_cmd
comma
l_int|0
comma
l_int|6
)paren
suffix:semicolon
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|INQUIRY
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
(paren
r_int
r_char
)paren
id|try_inquiry_len
suffix:semicolon
id|sreq-&gt;sr_cmd_len
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_data_direction
op_assign
id|DMA_FROM_DEVICE
suffix:semicolon
id|memset
c_func
(paren
id|inq_result
comma
l_int|0
comma
id|try_inquiry_len
)paren
suffix:semicolon
id|scsi_wait_req
c_func
(paren
id|sreq
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|inq_result
comma
id|try_inquiry_len
comma
id|HZ
op_div
l_int|2
op_plus
id|HZ
op_star
id|scsi_inq_timeout
comma
l_int|3
)paren
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi scan: INQUIRY %s &quot;
l_string|&quot;with code 0x%x&bslash;n&quot;
comma
id|sreq-&gt;sr_result
ques
c_cond
l_string|&quot;failed&quot;
suffix:colon
l_string|&quot;successful&quot;
comma
id|sreq-&gt;sr_result
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sreq-&gt;sr_result
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * not-ready to ready transition [asc/ascq=0x28/0x0]&n;&t;&t;&t; * or power-on, reset [asc/ascq=0x29/0x0], continue.&n;&t;&t;&t; * INQUIRY should not yield UNIT_ATTENTION&n;&t;&t;&t; * but many buggy devices do so anyway. &n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|driver_byte
c_func
(paren
id|sreq-&gt;sr_result
)paren
op_amp
id|DRIVER_SENSE
)paren
op_logical_and
id|scsi_request_normalize_sense
c_func
(paren
id|sreq
comma
op_amp
id|sshdr
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|sshdr.sense_key
op_eq
id|UNIT_ATTENTION
)paren
op_logical_and
(paren
(paren
id|sshdr.asc
op_eq
l_int|0x28
)paren
op_logical_or
(paren
id|sshdr.asc
op_eq
l_int|0x29
)paren
)paren
op_logical_and
(paren
id|sshdr.ascq
op_eq
l_int|0
)paren
)paren
r_continue
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sreq-&gt;sr_result
op_eq
l_int|0
)paren
(brace
id|response_len
op_assign
(paren
r_int
r_char
)paren
id|inq_result
(braket
l_int|4
)braket
op_plus
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|response_len
OG
l_int|255
)paren
id|response_len
op_assign
id|first_inquiry_len
suffix:semicolon
multiline_comment|/* sanity */
multiline_comment|/*&n;&t;&t; * Get any flags for this device.&n;&t;&t; *&n;&t;&t; * XXX add a bflags to Scsi_Device, and replace the&n;&t;&t; * corresponding bit fields in Scsi_Device, so bflags&n;&t;&t; * need not be passed as an argument.&n;&t;&t; */
op_star
id|bflags
op_assign
id|scsi_get_device_flags
c_func
(paren
id|sdev
comma
op_amp
id|inq_result
(braket
l_int|8
)braket
comma
op_amp
id|inq_result
(braket
l_int|16
)braket
)paren
suffix:semicolon
multiline_comment|/* When the first pass succeeds we gain information about&n;&t;&t; * what larger transfer lengths might work. */
r_if
c_cond
(paren
id|pass
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|BLIST_INQUIRY_36
op_amp
op_star
id|bflags
)paren
id|next_inquiry_len
op_assign
l_int|36
suffix:semicolon
r_else
r_if
c_cond
(paren
id|BLIST_INQUIRY_58
op_amp
op_star
id|bflags
)paren
id|next_inquiry_len
op_assign
l_int|58
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sdev-&gt;inquiry_len
)paren
id|next_inquiry_len
op_assign
id|sdev-&gt;inquiry_len
suffix:semicolon
r_else
id|next_inquiry_len
op_assign
id|response_len
suffix:semicolon
multiline_comment|/* If more data is available perform the second pass */
r_if
c_cond
(paren
id|next_inquiry_len
OG
id|try_inquiry_len
)paren
(brace
id|try_inquiry_len
op_assign
id|next_inquiry_len
suffix:semicolon
id|pass
op_assign
l_int|2
suffix:semicolon
r_goto
id|next_pass
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|pass
op_eq
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi scan: %d byte inquiry failed.  &quot;
l_string|&quot;Consider BLIST_INQUIRY_36 for this device&bslash;n&quot;
comma
id|try_inquiry_len
)paren
suffix:semicolon
multiline_comment|/* If this pass failed, the third pass goes back and transfers&n;&t;&t; * the same amount as we successfully got in the first pass. */
id|try_inquiry_len
op_assign
id|first_inquiry_len
suffix:semicolon
id|pass
op_assign
l_int|3
suffix:semicolon
r_goto
id|next_pass
suffix:semicolon
)brace
multiline_comment|/* If the last transfer attempt got an error, assume the&n;&t; * peripheral doesn&squot;t exist or is dead. */
r_if
c_cond
(paren
id|sreq-&gt;sr_result
)paren
r_return
suffix:semicolon
multiline_comment|/* Don&squot;t report any more data than the device says is valid */
id|sdev-&gt;inquiry_len
op_assign
id|min
c_func
(paren
id|try_inquiry_len
comma
id|response_len
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * XXX Abort if the response length is less than 36? If less than&n;&t; * 32, the lookup of the device flags (above) could be invalid,&n;&t; * and it would be possible to take an incorrect action - we do&n;&t; * not want to hang because of a short INQUIRY. On the flip side,&n;&t; * if the device is spun down or becoming ready (and so it gives a&n;&t; * short INQUIRY), an abort here prevents any further use of the&n;&t; * device, including spin up.&n;&t; *&n;&t; * Related to the above issue:&n;&t; *&n;&t; * XXX Devices (disk or all?) should be sent a TEST UNIT READY,&n;&t; * and if not ready, sent a START_STOP to start (maybe spin up) and&n;&t; * then send the INQUIRY again, since the INQUIRY can change after&n;&t; * a device is initialized.&n;&t; *&n;&t; * Ideally, start a device if explicitly asked to do so.  This&n;&t; * assumes that a device is spun up on power on, spun down on&n;&t; * request, and then spun up on request.&n;&t; */
multiline_comment|/*&n;&t; * The scanning code needs to know the scsi_level, even if no&n;&t; * device is attached at LUN 0 (SCSI_SCAN_TARGET_PRESENT) so&n;&t; * non-zero LUNs can be scanned.&n;&t; */
id|sdev-&gt;scsi_level
op_assign
id|inq_result
(braket
l_int|2
)braket
op_amp
l_int|0x07
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;scsi_level
op_ge
l_int|2
op_logical_or
(paren
id|sdev-&gt;scsi_level
op_eq
l_int|1
op_logical_and
(paren
id|inq_result
(braket
l_int|3
)braket
op_amp
l_int|0x0f
)paren
op_eq
l_int|1
)paren
)paren
id|sdev-&gt;scsi_level
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_add_lun - allocate and fully initialze a Scsi_Device&n; * @sdevscan:&t;holds information to be stored in the new Scsi_Device&n; * @sdevnew:&t;store the address of the newly allocated Scsi_Device&n; * @inq_result:&t;holds the result of a previous INQUIRY to the LUN&n; * @bflags:&t;black/white list flag&n; *&n; * Description:&n; *     Allocate and initialize a Scsi_Device matching sdevscan. Optionally&n; *     set fields based on values in *@bflags. If @sdevnew is not&n; *     NULL, store the address of the new Scsi_Device in *@sdevnew (needed&n; *     when scanning a particular LUN).&n; *&n; * Return:&n; *     SCSI_SCAN_NO_RESPONSE: could not allocate or setup a Scsi_Device&n; *     SCSI_SCAN_LUN_PRESENT: a new Scsi_Device was allocated and initialized&n; **/
DECL|function|scsi_add_lun
r_static
r_int
id|scsi_add_lun
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
comma
r_char
op_star
id|inq_result
comma
r_int
op_star
id|bflags
)paren
(brace
multiline_comment|/*&n;&t; * XXX do not save the inquiry, since it can change underneath us,&n;&t; * save just vendor/model/rev.&n;&t; *&n;&t; * Rather than save it and have an ioctl that retrieves the saved&n;&t; * value, have an ioctl that executes the same INQUIRY code used&n;&t; * in scsi_probe_lun, let user level programs doing INQUIRY&n;&t; * scanning run at their own risk, or supply a user level program&n;&t; * that can correctly scan.&n;&t; */
id|sdev-&gt;inquiry
op_assign
id|kmalloc
c_func
(paren
id|sdev-&gt;inquiry_len
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;inquiry
op_eq
l_int|NULL
)paren
(brace
r_return
id|SCSI_SCAN_NO_RESPONSE
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|sdev-&gt;inquiry
comma
id|inq_result
comma
id|sdev-&gt;inquiry_len
)paren
suffix:semicolon
id|sdev-&gt;vendor
op_assign
(paren
r_char
op_star
)paren
(paren
id|sdev-&gt;inquiry
op_plus
l_int|8
)paren
suffix:semicolon
id|sdev-&gt;model
op_assign
(paren
r_char
op_star
)paren
(paren
id|sdev-&gt;inquiry
op_plus
l_int|16
)paren
suffix:semicolon
id|sdev-&gt;rev
op_assign
(paren
r_char
op_star
)paren
(paren
id|sdev-&gt;inquiry
op_plus
l_int|32
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|bflags
op_amp
id|BLIST_ISROM
)paren
(brace
multiline_comment|/*&n;&t;&t; * It would be better to modify sdev-&gt;type, and set&n;&t;&t; * sdev-&gt;removable, but then the print_inquiry() output&n;&t;&t; * would not show TYPE_ROM; if print_inquiry() is removed&n;&t;&t; * the issue goes away.&n;&t;&t; */
id|inq_result
(braket
l_int|0
)braket
op_assign
id|TYPE_ROM
suffix:semicolon
id|inq_result
(braket
l_int|1
)braket
op_or_assign
l_int|0x80
suffix:semicolon
multiline_comment|/* removable */
)brace
r_else
r_if
c_cond
(paren
op_star
id|bflags
op_amp
id|BLIST_NO_ULD_ATTACH
)paren
id|sdev-&gt;no_uld_attach
op_assign
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|sdev-&gt;type
op_assign
(paren
id|inq_result
(braket
l_int|0
)braket
op_amp
l_int|0x1f
)paren
)paren
(brace
r_case
id|TYPE_TAPE
suffix:colon
r_case
id|TYPE_DISK
suffix:colon
r_case
id|TYPE_PRINTER
suffix:colon
r_case
id|TYPE_MOD
suffix:colon
r_case
id|TYPE_PROCESSOR
suffix:colon
r_case
id|TYPE_SCANNER
suffix:colon
r_case
id|TYPE_MEDIUM_CHANGER
suffix:colon
r_case
id|TYPE_ENCLOSURE
suffix:colon
r_case
id|TYPE_COMM
suffix:colon
id|sdev-&gt;writeable
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_WORM
suffix:colon
r_case
id|TYPE_ROM
suffix:colon
id|sdev-&gt;writeable
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi: unknown device type %d&bslash;n&quot;
comma
id|sdev-&gt;type
)paren
suffix:semicolon
)brace
id|print_inquiry
c_func
(paren
id|inq_result
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * For a peripheral qualifier (PQ) value of 1 (001b), the SCSI&n;&t; * spec says: The device server is capable of supporting the&n;&t; * specified peripheral device type on this logical unit. However,&n;&t; * the physical device is not currently connected to this logical&n;&t; * unit.&n;&t; *&n;&t; * The above is vague, as it implies that we could treat 001 and&n;&t; * 011 the same. Stay compatible with previous code, and create a&n;&t; * Scsi_Device for a PQ of 1&n;&t; *&n;&t; * Don&squot;t set the device offline here; rather let the upper&n;&t; * level drivers eval the PQ to decide whether they should&n;&t; * attach. So remove ((inq_result[0] &gt;&gt; 5) &amp; 7) == 1 check.&n;&t; */
id|sdev-&gt;inq_periph_qual
op_assign
(paren
id|inq_result
(braket
l_int|0
)braket
op_rshift
l_int|5
)paren
op_amp
l_int|7
suffix:semicolon
id|sdev-&gt;removable
op_assign
(paren
l_int|0x80
op_amp
id|inq_result
(braket
l_int|1
)braket
)paren
op_rshift
l_int|7
suffix:semicolon
id|sdev-&gt;lockable
op_assign
id|sdev-&gt;removable
suffix:semicolon
id|sdev-&gt;soft_reset
op_assign
(paren
id|inq_result
(braket
l_int|7
)braket
op_amp
l_int|1
)paren
op_logical_and
(paren
(paren
id|inq_result
(braket
l_int|3
)braket
op_amp
l_int|7
)paren
op_eq
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;scsi_level
op_ge
id|SCSI_3
op_logical_or
(paren
id|sdev-&gt;inquiry_len
OG
l_int|56
op_logical_and
id|inq_result
(braket
l_int|56
)braket
op_amp
l_int|0x04
)paren
)paren
id|sdev-&gt;ppr
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|inq_result
(braket
l_int|7
)braket
op_amp
l_int|0x60
)paren
id|sdev-&gt;wdtr
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|inq_result
(braket
l_int|7
)braket
op_amp
l_int|0x10
)paren
id|sdev-&gt;sdtr
op_assign
l_int|1
suffix:semicolon
id|sprintf
c_func
(paren
id|sdev-&gt;devfs_name
comma
l_string|&quot;scsi/host%d/bus%d/target%d/lun%d&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * End driverfs/devfs code.&n;&t; */
r_if
c_cond
(paren
(paren
id|sdev-&gt;scsi_level
op_ge
id|SCSI_2
)paren
op_logical_and
(paren
id|inq_result
(braket
l_int|7
)braket
op_amp
l_int|2
)paren
op_logical_and
op_logical_neg
(paren
op_star
id|bflags
op_amp
id|BLIST_NOTQ
)paren
)paren
id|sdev-&gt;tagged_supported
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Some devices (Texel CD ROM drives) have handshaking problems&n;&t; * when used with the Seagate controllers. borken is initialized&n;&t; * to 1, and then set it to 0 here.&n;&t; */
r_if
c_cond
(paren
(paren
op_star
id|bflags
op_amp
id|BLIST_BORKEN
)paren
op_eq
l_int|0
)paren
id|sdev-&gt;borken
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Apparently some really broken devices (contrary to the SCSI&n;&t; * standards) need to be selected without asserting ATN&n;&t; */
r_if
c_cond
(paren
op_star
id|bflags
op_amp
id|BLIST_SELECT_NO_ATN
)paren
id|sdev-&gt;select_no_atn
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Some devices may not want to have a start command automatically&n;&t; * issued when a device is added.&n;&t; */
r_if
c_cond
(paren
op_star
id|bflags
op_amp
id|BLIST_NOSTARTONADD
)paren
id|sdev-&gt;no_start_on_add
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_star
id|bflags
op_amp
id|BLIST_SINGLELUN
)paren
id|sdev-&gt;single_lun
op_assign
l_int|1
suffix:semicolon
id|sdev-&gt;use_10_for_rw
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_star
id|bflags
op_amp
id|BLIST_MS_SKIP_PAGE_08
)paren
id|sdev-&gt;skip_ms_page_8
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_star
id|bflags
op_amp
id|BLIST_MS_SKIP_PAGE_3F
)paren
id|sdev-&gt;skip_ms_page_3f
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_star
id|bflags
op_amp
id|BLIST_USE_10_BYTE_MS
)paren
id|sdev-&gt;use_10_for_ms
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* set the device running here so that slave configure&n;&t; * may do I/O */
id|scsi_device_set_state
c_func
(paren
id|sdev
comma
id|SDEV_RUNNING
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|bflags
op_amp
id|BLIST_MS_192_BYTES_FOR_3F
)paren
id|sdev-&gt;use_192_bytes_for_3f
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_star
id|bflags
op_amp
id|BLIST_NOT_LOCKABLE
)paren
id|sdev-&gt;lockable
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;host-&gt;transportt-&gt;device_configure
)paren
id|sdev-&gt;host-&gt;transportt
op_member_access_from_pointer
id|device_configure
c_func
(paren
id|sdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;host-&gt;hostt-&gt;slave_configure
)paren
id|sdev-&gt;host-&gt;hostt
op_member_access_from_pointer
id|slave_configure
c_func
(paren
id|sdev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, the device is now all set up, we can&n;&t; * register it and tell the rest of the kernel&n;&t; * about it.&n;&t; */
id|scsi_sysfs_add_sdev
c_func
(paren
id|sdev
)paren
suffix:semicolon
r_return
id|SCSI_SCAN_LUN_PRESENT
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_probe_and_add_lun - probe a LUN, if a LUN is found add it&n; * @sdevscan:&t;probe the LUN corresponding to this Scsi_Device&n; * @sdevnew:&t;store the value of any new Scsi_Device allocated&n; * @bflagsp:&t;store bflags here if not NULL&n; *&n; * Description:&n; *     Call scsi_probe_lun, if a LUN with an attached device is found,&n; *     allocate and set it up by calling scsi_add_lun.&n; *&n; * Return:&n; *     SCSI_SCAN_NO_RESPONSE: could not allocate or setup a Scsi_Device&n; *     SCSI_SCAN_TARGET_PRESENT: target responded, but no device is&n; *         attached at the LUN&n; *     SCSI_SCAN_LUN_PRESENT: a new Scsi_Device was allocated and initialized&n; **/
DECL|function|scsi_probe_and_add_lun
r_static
r_int
id|scsi_probe_and_add_lun
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
id|uint
id|channel
comma
id|uint
id|id
comma
id|uint
id|lun
comma
r_int
op_star
id|bflagsp
comma
r_struct
id|scsi_device
op_star
op_star
id|sdevp
comma
r_int
id|rescan
comma
r_void
op_star
id|hostdata
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
r_struct
id|scsi_request
op_star
id|sreq
suffix:semicolon
r_int
r_char
op_star
id|result
suffix:semicolon
r_int
id|bflags
comma
id|res
op_assign
id|SCSI_SCAN_NO_RESPONSE
suffix:semicolon
multiline_comment|/*&n;&t; * The rescan flag is used as an optimization, the first scan of a&n;&t; * host adapter calls into here with rescan == 0.&n;&t; */
r_if
c_cond
(paren
id|rescan
)paren
(brace
id|sdev
op_assign
id|scsi_device_lookup
c_func
(paren
id|host
comma
id|channel
comma
id|id
comma
id|lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev
)paren
(brace
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi scan: device exists on &lt;%d:%d:%d:%d&gt;&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|channel
comma
id|id
comma
id|lun
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdevp
)paren
op_star
id|sdevp
op_assign
id|sdev
suffix:semicolon
r_if
c_cond
(paren
id|bflagsp
)paren
op_star
id|bflagsp
op_assign
id|scsi_get_device_flags
c_func
(paren
id|sdev
comma
id|sdev-&gt;vendor
comma
id|sdev-&gt;model
)paren
suffix:semicolon
multiline_comment|/* XXX: bandaid until callers do refcounting */
id|scsi_device_put
c_func
(paren
id|sdev
)paren
suffix:semicolon
r_return
id|SCSI_SCAN_LUN_PRESENT
suffix:semicolon
)brace
)brace
id|sdev
op_assign
id|scsi_alloc_sdev
c_func
(paren
id|host
comma
id|channel
comma
id|id
comma
id|lun
comma
id|hostdata
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sdev
)paren
r_goto
id|out
suffix:semicolon
id|sreq
op_assign
id|scsi_allocate_request
c_func
(paren
id|sdev
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sreq
)paren
r_goto
id|out_free_sdev
suffix:semicolon
id|result
op_assign
id|kmalloc
c_func
(paren
l_int|256
comma
id|GFP_ATOMIC
op_or
(paren
id|host-&gt;unchecked_isa_dma
)paren
ques
c_cond
id|__GFP_DMA
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
r_goto
id|out_free_sreq
suffix:semicolon
id|scsi_probe_lun
c_func
(paren
id|sreq
comma
id|result
comma
op_amp
id|bflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sreq-&gt;sr_result
)paren
r_goto
id|out_free_result
suffix:semicolon
multiline_comment|/*&n;&t; * result contains valid SCSI INQUIRY data.&n;&t; */
r_if
c_cond
(paren
(paren
id|result
(braket
l_int|0
)braket
op_rshift
l_int|5
)paren
op_eq
l_int|3
)paren
(brace
multiline_comment|/*&n;&t;&t; * For a Peripheral qualifier 3 (011b), the SCSI&n;&t;&t; * spec says: The device server is not capable of&n;&t;&t; * supporting a physical device on this logical&n;&t;&t; * unit.&n;&t;&t; *&n;&t;&t; * For disks, this implies that there is no&n;&t;&t; * logical disk configured at sdev-&gt;lun, but there&n;&t;&t; * is a target id responding.&n;&t;&t; */
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi scan: peripheral qualifier of 3,&quot;
l_string|&quot; no device added&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|res
op_assign
id|SCSI_SCAN_TARGET_PRESENT
suffix:semicolon
r_goto
id|out_free_result
suffix:semicolon
)brace
id|res
op_assign
id|scsi_add_lun
c_func
(paren
id|sdev
comma
id|result
comma
op_amp
id|bflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_eq
id|SCSI_SCAN_LUN_PRESENT
)paren
(brace
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_KEY
)paren
(brace
id|sdev-&gt;lockable
op_assign
l_int|0
suffix:semicolon
id|scsi_unlock_floptical
c_func
(paren
id|sreq
comma
id|result
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bflagsp
)paren
op_star
id|bflagsp
op_assign
id|bflags
suffix:semicolon
)brace
id|out_free_result
suffix:colon
id|kfree
c_func
(paren
id|result
)paren
suffix:semicolon
id|out_free_sreq
suffix:colon
id|scsi_release_request
c_func
(paren
id|sreq
)paren
suffix:semicolon
id|out_free_sdev
suffix:colon
r_if
c_cond
(paren
id|res
op_eq
id|SCSI_SCAN_LUN_PRESENT
)paren
(brace
r_if
c_cond
(paren
id|sdevp
)paren
op_star
id|sdevp
op_assign
id|sdev
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|sdev-&gt;host-&gt;hostt-&gt;slave_destroy
)paren
id|sdev-&gt;host-&gt;hostt
op_member_access_from_pointer
id|slave_destroy
c_func
(paren
id|sdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;host-&gt;transportt-&gt;device_destroy
)paren
id|sdev-&gt;host-&gt;transportt
op_member_access_from_pointer
id|device_destroy
c_func
(paren
id|sdev
)paren
suffix:semicolon
id|put_device
c_func
(paren
op_amp
id|sdev-&gt;sdev_gendev
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_sequential_lun_scan - sequentially scan a SCSI target&n; * @sdevscan:&t;scan the host, channel, and id of this Scsi_Device&n; * @bflags:&t;black/white list flag for LUN 0&n; * @lun0_res:&t;result of scanning LUN 0&n; *&n; * Description:&n; *     Generally, scan from LUN 1 (LUN 0 is assumed to already have been&n; *     scanned) to some maximum lun until a LUN is found with no device&n; *     attached. Use the bflags to figure out any oddities.&n; *&n; *     Modifies sdevscan-&gt;lun.&n; **/
DECL|function|scsi_sequential_lun_scan
r_static
r_void
id|scsi_sequential_lun_scan
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
comma
id|uint
id|channel
comma
id|uint
id|id
comma
r_int
id|bflags
comma
r_int
id|lun0_res
comma
r_int
id|scsi_level
comma
r_int
id|rescan
)paren
(brace
r_int
r_int
id|sparse_lun
comma
id|lun
comma
id|max_dev_lun
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi scan: Sequential scan of&quot;
l_string|&quot; host %d channel %d id %d&bslash;n&quot;
comma
id|shost-&gt;host_no
comma
id|channel
comma
id|id
)paren
)paren
suffix:semicolon
id|max_dev_lun
op_assign
id|min
c_func
(paren
id|max_scsi_luns
comma
id|shost-&gt;max_lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If this device is known to support sparse multiple units,&n;&t; * override the other settings, and scan all of them. Normally,&n;&t; * SCSI-3 devices should be scanned via the REPORT LUNS.&n;&t; */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_SPARSELUN
)paren
(brace
id|max_dev_lun
op_assign
id|shost-&gt;max_lun
suffix:semicolon
id|sparse_lun
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|sparse_lun
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If not sparse lun and no device attached at LUN 0 do not scan&n;&t; * any further.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sparse_lun
op_logical_and
(paren
id|lun0_res
op_ne
id|SCSI_SCAN_LUN_PRESENT
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * If less than SCSI_1_CSS, and no special lun scaning, stop&n;&t; * scanning; this matches 2.4 behaviour, but could just be a bug&n;&t; * (to continue scanning a SCSI_1_CSS device).&n;&t; *&n;&t; * This test is broken.  We might not have any device on lun0 for&n;&t; * a sparselun device, and if that&squot;s the case then how would we&n;&t; * know the real scsi_level, eh?  It might make sense to just not&n;&t; * scan any SCSI_1 device for non-0 luns, but that check would best&n;&t; * go into scsi_alloc_sdev() and just have it return null when asked&n;&t; * to alloc an sdev for lun &gt; 0 on an already found SCSI_1 device.&n;&t; *&n;&t;if ((sdevscan-&gt;scsi_level &lt; SCSI_1_CCS) &amp;&amp;&n;&t;    ((bflags &amp; (BLIST_FORCELUN | BLIST_SPARSELUN | BLIST_MAX5LUN))&n;&t;     == 0))&n;&t;&t;return;&n;&t; */
multiline_comment|/*&n;&t; * If this device is known to support multiple units, override&n;&t; * the other settings, and scan all of them.&n;&t; */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_FORCELUN
)paren
id|max_dev_lun
op_assign
id|shost-&gt;max_lun
suffix:semicolon
multiline_comment|/*&n;&t; * REGAL CDC-4X: avoid hang after LUN 4&n;&t; */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_MAX5LUN
)paren
id|max_dev_lun
op_assign
id|min
c_func
(paren
l_int|5U
comma
id|max_dev_lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do not scan SCSI-2 or lower device past LUN 7, unless&n;&t; * BLIST_LARGELUN.&n;&t; */
r_if
c_cond
(paren
id|scsi_level
OL
id|SCSI_3
op_logical_and
op_logical_neg
(paren
id|bflags
op_amp
id|BLIST_LARGELUN
)paren
)paren
id|max_dev_lun
op_assign
id|min
c_func
(paren
l_int|8U
comma
id|max_dev_lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We have already scanned LUN 0, so start at LUN 1. Keep scanning&n;&t; * until we reach the max, or no LUN is found and we are not&n;&t; * sparse_lun.&n;&t; */
r_for
c_loop
(paren
id|lun
op_assign
l_int|1
suffix:semicolon
id|lun
OL
id|max_dev_lun
suffix:semicolon
op_increment
id|lun
)paren
r_if
c_cond
(paren
(paren
id|scsi_probe_and_add_lun
c_func
(paren
id|shost
comma
id|channel
comma
id|id
comma
id|lun
comma
l_int|NULL
comma
l_int|NULL
comma
id|rescan
comma
l_int|NULL
)paren
op_ne
id|SCSI_SCAN_LUN_PRESENT
)paren
op_logical_and
op_logical_neg
id|sparse_lun
)paren
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * scsilun_to_int: convert a scsi_lun to an int&n; * @scsilun:&t;struct scsi_lun to be converted.&n; *&n; * Description:&n; *     Convert @scsilun from a struct scsi_lun to a four byte host byte-ordered&n; *     integer, and return the result. The caller must check for&n; *     truncation before using this function.&n; *&n; * Notes:&n; *     The struct scsi_lun is assumed to be four levels, with each level&n; *     effectively containing a SCSI byte-ordered (big endian) short; the&n; *     addressing bits of each level are ignored (the highest two bits).&n; *     For a description of the LUN format, post SCSI-3 see the SCSI&n; *     Architecture Model, for SCSI-3 see the SCSI Controller Commands.&n; *&n; *     Given a struct scsi_lun of: 0a 04 0b 03 00 00 00 00, this function returns&n; *     the integer: 0x0b030a04&n; **/
DECL|function|scsilun_to_int
r_static
r_int
id|scsilun_to_int
c_func
(paren
r_struct
id|scsi_lun
op_star
id|scsilun
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|lun
suffix:semicolon
id|lun
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|lun
)paren
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
id|lun
op_assign
id|lun
op_or
(paren
(paren
(paren
id|scsilun-&gt;scsi_lun
(braket
id|i
)braket
op_lshift
l_int|8
)paren
op_or
id|scsilun-&gt;scsi_lun
(braket
id|i
op_plus
l_int|1
)braket
)paren
op_lshift
(paren
id|i
op_star
l_int|8
)paren
)paren
suffix:semicolon
r_return
id|lun
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_report_lun_scan - Scan using SCSI REPORT LUN results&n; * @sdevscan:&t;scan the host, channel, and id of this Scsi_Device&n; *&n; * Description:&n; *     If @sdevscan is for a SCSI-3 or up device, send a REPORT LUN&n; *     command, and scan the resulting list of LUNs by calling&n; *     scsi_probe_and_add_lun.&n; *&n; *     Modifies sdevscan-&gt;lun.&n; *&n; * Return:&n; *     0: scan completed (or no memory, so further scanning is futile)&n; *     1: no report lun scan, or not configured&n; **/
DECL|function|scsi_report_lun_scan
r_static
r_int
id|scsi_report_lun_scan
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
comma
r_int
id|bflags
comma
r_int
id|rescan
)paren
(brace
r_char
id|devname
(braket
l_int|64
)braket
suffix:semicolon
r_int
r_char
id|scsi_cmd
(braket
id|MAX_COMMAND_SIZE
)braket
suffix:semicolon
r_int
r_int
id|length
suffix:semicolon
r_int
r_int
id|lun
suffix:semicolon
r_int
r_int
id|num_luns
suffix:semicolon
r_int
r_int
id|retries
suffix:semicolon
r_struct
id|scsi_lun
op_star
id|lunp
comma
op_star
id|lun_data
suffix:semicolon
r_struct
id|scsi_request
op_star
id|sreq
suffix:semicolon
id|u8
op_star
id|data
suffix:semicolon
r_struct
id|scsi_sense_hdr
id|sshdr
suffix:semicolon
multiline_comment|/*&n;&t; * Only support SCSI-3 and up devices if BLIST_NOREPORTLUN is not set.&n;&t; * Also allow SCSI-2 if BLIST_REPORTLUN2 is set and host adapter does&n;&t; * support more than 8 LUNs.&n;&t; */
r_if
c_cond
(paren
(paren
id|bflags
op_amp
id|BLIST_NOREPORTLUN
)paren
op_logical_or
id|sdev-&gt;scsi_level
OL
id|SCSI_2
op_logical_or
(paren
id|sdev-&gt;scsi_level
OL
id|SCSI_3
op_logical_and
(paren
op_logical_neg
(paren
id|bflags
op_amp
id|BLIST_REPORTLUN2
)paren
op_logical_or
id|sdev-&gt;host-&gt;max_lun
op_le
l_int|8
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_NOLUN
)paren
r_return
l_int|0
suffix:semicolon
id|sreq
op_assign
id|scsi_allocate_request
c_func
(paren
id|sdev
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sreq
)paren
r_goto
id|out
suffix:semicolon
id|sprintf
c_func
(paren
id|devname
comma
l_string|&quot;host %d channel %d id %d&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate enough to hold the header (the same size as one scsi_lun)&n;&t; * plus the max number of luns we are requesting.&n;&t; *&n;&t; * Reallocating and trying again (with the exact amount we need)&n;&t; * would be nice, but then we need to somehow limit the size&n;&t; * allocated based on the available memory and the limits of&n;&t; * kmalloc - we don&squot;t want a kmalloc() failure of a huge value to&n;&t; * prevent us from finding any LUNs on this target.&n;&t; */
id|length
op_assign
(paren
id|max_scsi_report_luns
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_struct
id|scsi_lun
)paren
suffix:semicolon
id|lun_data
op_assign
id|kmalloc
c_func
(paren
id|length
comma
id|GFP_ATOMIC
op_or
(paren
id|sdev-&gt;host-&gt;unchecked_isa_dma
ques
c_cond
id|__GFP_DMA
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lun_data
)paren
r_goto
id|out_release_request
suffix:semicolon
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|REPORT_LUNS
suffix:semicolon
multiline_comment|/*&n;&t; * bytes 1 - 5: reserved, set to zero.&n;&t; */
id|memset
c_func
(paren
op_amp
id|scsi_cmd
(braket
l_int|1
)braket
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * bytes 6 - 9: length of the command.&n;&t; */
id|scsi_cmd
(braket
l_int|6
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|length
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
suffix:semicolon
id|scsi_cmd
(braket
l_int|7
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|length
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
id|scsi_cmd
(braket
l_int|8
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|length
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|scsi_cmd
(braket
l_int|9
)braket
op_assign
(paren
r_int
r_char
)paren
id|length
op_amp
l_int|0xff
suffix:semicolon
id|scsi_cmd
(braket
l_int|10
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* reserved */
id|scsi_cmd
(braket
l_int|11
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* control */
id|sreq-&gt;sr_cmd_len
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_data_direction
op_assign
id|DMA_FROM_DEVICE
suffix:semicolon
multiline_comment|/*&n;&t; * We can get a UNIT ATTENTION, for example a power on/reset, so&n;&t; * retry a few times (like sd.c does for TEST UNIT READY).&n;&t; * Experience shows some combinations of adapter/devices get at&n;&t; * least two power on/resets.&n;&t; *&n;&t; * Illegal requests (for devices that do not support REPORT LUNS)&n;&t; * should come through as a check condition, and will not generate&n;&t; * a retry.&n;&t; */
r_for
c_loop
(paren
id|retries
op_assign
l_int|0
suffix:semicolon
id|retries
OL
l_int|3
suffix:semicolon
id|retries
op_increment
)paren
(brace
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
(paren
id|KERN_INFO
l_string|&quot;scsi scan: Sending&quot;
l_string|&quot; REPORT LUNS to %s (try %d)&bslash;n&quot;
comma
id|devname
comma
id|retries
)paren
)paren
suffix:semicolon
id|scsi_wait_req
c_func
(paren
id|sreq
comma
id|scsi_cmd
comma
id|lun_data
comma
id|length
comma
id|SCSI_TIMEOUT
op_plus
l_int|4
op_star
id|HZ
comma
l_int|3
)paren
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
(paren
id|KERN_INFO
l_string|&quot;scsi scan: REPORT LUNS&quot;
l_string|&quot; %s (try %d) result 0x%x&bslash;n&quot;
comma
id|sreq-&gt;sr_result
ques
c_cond
l_string|&quot;failed&quot;
suffix:colon
l_string|&quot;successful&quot;
comma
id|retries
comma
id|sreq-&gt;sr_result
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sreq-&gt;sr_result
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_else
r_if
c_cond
(paren
id|scsi_request_normalize_sense
c_func
(paren
id|sreq
comma
op_amp
id|sshdr
)paren
)paren
(brace
r_if
c_cond
(paren
id|sshdr.sense_key
op_ne
id|UNIT_ATTENTION
)paren
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|sreq-&gt;sr_result
)paren
(brace
multiline_comment|/*&n;&t;&t; * The device probably does not support a REPORT LUN command&n;&t;&t; */
id|kfree
c_func
(paren
id|lun_data
)paren
suffix:semicolon
id|scsi_release_request
c_func
(paren
id|sreq
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|scsi_release_request
c_func
(paren
id|sreq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get the length from the first four bytes of lun_data.&n;&t; */
id|data
op_assign
(paren
id|u8
op_star
)paren
id|lun_data-&gt;scsi_lun
suffix:semicolon
id|length
op_assign
(paren
(paren
id|data
(braket
l_int|0
)braket
op_lshift
l_int|24
)paren
op_or
(paren
id|data
(braket
l_int|1
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|data
(braket
l_int|2
)braket
op_lshift
l_int|8
)paren
op_or
(paren
id|data
(braket
l_int|3
)braket
op_lshift
l_int|0
)paren
)paren
suffix:semicolon
id|num_luns
op_assign
(paren
id|length
op_div
r_sizeof
(paren
r_struct
id|scsi_lun
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|num_luns
OG
id|max_scsi_report_luns
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi: On %s only %d (max_scsi_report_luns)&quot;
l_string|&quot; of %d luns reported, try increasing&quot;
l_string|&quot; max_scsi_report_luns.&bslash;n&quot;
comma
id|devname
comma
id|max_scsi_report_luns
comma
id|num_luns
)paren
suffix:semicolon
id|num_luns
op_assign
id|max_scsi_report_luns
suffix:semicolon
)brace
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
(paren
id|KERN_INFO
l_string|&quot;scsi scan: REPORT LUN scan of&quot;
l_string|&quot; host %d channel %d id %d&bslash;n&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Scan the luns in lun_data. The entry at offset 0 is really&n;&t; * the header, so start at 1 and go up to and including num_luns.&n;&t; */
r_for
c_loop
(paren
id|lunp
op_assign
op_amp
id|lun_data
(braket
l_int|1
)braket
suffix:semicolon
id|lunp
op_le
op_amp
id|lun_data
(braket
id|num_luns
)braket
suffix:semicolon
id|lunp
op_increment
)paren
(brace
id|lun
op_assign
id|scsilun_to_int
c_func
(paren
id|lunp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check if the unused part of lunp is non-zero, and so&n;&t;&t; * does not fit in lun.&n;&t;&t; */
r_if
c_cond
(paren
id|memcmp
c_func
(paren
op_amp
id|lunp-&gt;scsi_lun
(braket
r_sizeof
(paren
id|lun
)paren
)braket
comma
l_string|&quot;&bslash;0&bslash;0&bslash;0&bslash;0&quot;
comma
l_int|4
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Output an error displaying the LUN in byte order,&n;&t;&t;&t; * this differs from what linux would print for the&n;&t;&t;&t; * integer LUN value.&n;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi: %s lun 0x&quot;
comma
id|devname
)paren
suffix:semicolon
id|data
op_assign
(paren
r_char
op_star
)paren
id|lunp-&gt;scsi_lun
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
r_struct
id|scsi_lun
)paren
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%02x&quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; has a LUN larger than currently supported.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lun
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * LUN 0 has already been scanned.&n;&t;&t;&t; */
)brace
r_else
r_if
c_cond
(paren
id|lun
OG
id|sdev-&gt;host-&gt;max_lun
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi: %s lun%d has a LUN larger&quot;
l_string|&quot; than allowed by the host adapter&bslash;n&quot;
comma
id|devname
comma
id|lun
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|res
suffix:semicolon
id|res
op_assign
id|scsi_probe_and_add_lun
c_func
(paren
id|sdev-&gt;host
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
comma
id|lun
comma
l_int|NULL
comma
l_int|NULL
comma
id|rescan
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_eq
id|SCSI_SCAN_NO_RESPONSE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Got some results, but now none, abort.&n;&t;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;scsi: Unexpected response&quot;
l_string|&quot; from %s lun %d while scanning, scan&quot;
l_string|&quot; aborted&bslash;n&quot;
comma
id|devname
comma
id|lun
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|kfree
c_func
(paren
id|lun_data
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_release_request
suffix:colon
id|scsi_release_request
c_func
(paren
id|sreq
)paren
suffix:semicolon
id|out
suffix:colon
multiline_comment|/*&n;&t; * We are out of memory, don&squot;t try scanning any further.&n;&t; */
id|printk
c_func
(paren
id|ALLOC_FAILURE_MSG
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|__scsi_add_device
r_struct
id|scsi_device
op_star
id|__scsi_add_device
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
comma
id|uint
id|channel
comma
id|uint
id|id
comma
id|uint
id|lun
comma
r_void
op_star
id|hostdata
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
r_int
id|res
suffix:semicolon
id|down
c_func
(paren
op_amp
id|shost-&gt;scan_mutex
)paren
suffix:semicolon
id|res
op_assign
id|scsi_probe_and_add_lun
c_func
(paren
id|shost
comma
id|channel
comma
id|id
comma
id|lun
comma
l_int|NULL
comma
op_amp
id|sdev
comma
l_int|1
comma
id|hostdata
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_ne
id|SCSI_SCAN_LUN_PRESENT
)paren
id|sdev
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|shost-&gt;scan_mutex
)paren
suffix:semicolon
r_return
id|sdev
suffix:semicolon
)brace
DECL|variable|__scsi_add_device
id|EXPORT_SYMBOL
c_func
(paren
id|__scsi_add_device
)paren
suffix:semicolon
DECL|function|scsi_rescan_device
r_void
id|scsi_rescan_device
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|scsi_driver
op_star
id|drv
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;driver
)paren
r_return
suffix:semicolon
id|drv
op_assign
id|to_scsi_driver
c_func
(paren
id|dev-&gt;driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|try_module_get
c_func
(paren
id|drv-&gt;owner
)paren
)paren
(brace
r_if
c_cond
(paren
id|drv-&gt;rescan
)paren
id|drv
op_member_access_from_pointer
id|rescan
c_func
(paren
id|dev
)paren
suffix:semicolon
id|module_put
c_func
(paren
id|drv-&gt;owner
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * scsi_scan_target - scan a target id, possibly including all LUNs on the&n; *     target.&n; * @sdevsca:&t;Scsi_Device handle for scanning&n; * @shost:&t;host to scan&n; * @channel:&t;channel to scan&n; * @id:&t;&t;target id to scan&n; *&n; * Description:&n; *     Scan the target id on @shost, @channel, and @id. Scan at least LUN&n; *     0, and possibly all LUNs on the target id.&n; *&n; *     Use the pre-allocated @sdevscan as a handle for the scanning. This&n; *     function sets sdevscan-&gt;host, sdevscan-&gt;id and sdevscan-&gt;lun; the&n; *     scanning functions modify sdevscan-&gt;lun.&n; *&n; *     First try a REPORT LUN scan, if that does not scan the target, do a&n; *     sequential scan of LUNs on the target id.&n; **/
DECL|function|scsi_scan_target
r_static
r_void
id|scsi_scan_target
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
comma
r_int
r_int
id|channel
comma
r_int
r_int
id|id
comma
r_int
r_int
id|lun
comma
r_int
id|rescan
)paren
(brace
r_int
id|bflags
op_assign
l_int|0
suffix:semicolon
r_int
id|res
suffix:semicolon
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
r_if
c_cond
(paren
id|shost-&gt;this_id
op_eq
id|id
)paren
multiline_comment|/*&n;&t;&t; * Don&squot;t scan the host adapter&n;&t;&t; */
r_return
suffix:semicolon
r_if
c_cond
(paren
id|lun
op_ne
id|SCAN_WILD_CARD
)paren
(brace
multiline_comment|/*&n;&t;&t; * Scan for a specific host/chan/id/lun.&n;&t;&t; */
id|scsi_probe_and_add_lun
c_func
(paren
id|shost
comma
id|channel
comma
id|id
comma
id|lun
comma
l_int|NULL
comma
l_int|NULL
comma
id|rescan
comma
l_int|NULL
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Scan LUN 0, if there is some response, scan further. Ideally, we&n;&t; * would not configure LUN 0 until all LUNs are scanned.&n;&t; */
id|res
op_assign
id|scsi_probe_and_add_lun
c_func
(paren
id|shost
comma
id|channel
comma
id|id
comma
l_int|0
comma
op_amp
id|bflags
comma
op_amp
id|sdev
comma
id|rescan
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_eq
id|SCSI_SCAN_LUN_PRESENT
)paren
(brace
r_if
c_cond
(paren
id|scsi_report_lun_scan
c_func
(paren
id|sdev
comma
id|bflags
comma
id|rescan
)paren
op_ne
l_int|0
)paren
multiline_comment|/*&n;&t;&t;&t; * The REPORT LUN did not scan the target,&n;&t;&t;&t; * do a sequential scan.&n;&t;&t;&t; */
id|scsi_sequential_lun_scan
c_func
(paren
id|shost
comma
id|channel
comma
id|id
comma
id|bflags
comma
id|res
comma
id|sdev-&gt;scsi_level
comma
id|rescan
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|res
op_eq
id|SCSI_SCAN_TARGET_PRESENT
)paren
(brace
multiline_comment|/*&n;&t;&t; * There&squot;s a target here, but lun 0 is offline so we&n;&t;&t; * can&squot;t use the report_lun scan.  Fall back to a&n;&t;&t; * sequential lun scan with a bflags of SPARSELUN and&n;&t;&t; * a default scsi level of SCSI_2&n;&t;&t; */
id|scsi_sequential_lun_scan
c_func
(paren
id|shost
comma
id|channel
comma
id|id
comma
id|BLIST_SPARSELUN
comma
id|SCSI_SCAN_TARGET_PRESENT
comma
id|SCSI_2
comma
id|rescan
)paren
suffix:semicolon
)brace
)brace
DECL|function|scsi_scan_channel
r_static
r_void
id|scsi_scan_channel
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
comma
r_int
r_int
id|channel
comma
r_int
r_int
id|id
comma
r_int
r_int
id|lun
comma
r_int
id|rescan
)paren
(brace
id|uint
id|order_id
suffix:semicolon
r_if
c_cond
(paren
id|id
op_eq
id|SCAN_WILD_CARD
)paren
r_for
c_loop
(paren
id|id
op_assign
l_int|0
suffix:semicolon
id|id
OL
id|shost-&gt;max_id
suffix:semicolon
op_increment
id|id
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * XXX adapter drivers when possible (FCP, iSCSI)&n;&t;&t;&t; * could modify max_id to match the current max,&n;&t;&t;&t; * not the absolute max.&n;&t;&t;&t; *&n;&t;&t;&t; * XXX add a shost id iterator, so for example,&n;&t;&t;&t; * the FC ID can be the same as a target id&n;&t;&t;&t; * without a huge overhead of sparse id&squot;s.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|shost-&gt;reverse_ordering
)paren
multiline_comment|/*&n;&t;&t;&t;&t; * Scan from high to low id.&n;&t;&t;&t;&t; */
id|order_id
op_assign
id|shost-&gt;max_id
op_minus
id|id
op_minus
l_int|1
suffix:semicolon
r_else
id|order_id
op_assign
id|id
suffix:semicolon
id|scsi_scan_target
c_func
(paren
id|shost
comma
id|channel
comma
id|order_id
comma
id|lun
comma
id|rescan
)paren
suffix:semicolon
)brace
r_else
id|scsi_scan_target
c_func
(paren
id|shost
comma
id|channel
comma
id|id
comma
id|lun
comma
id|rescan
)paren
suffix:semicolon
)brace
DECL|function|scsi_scan_host_selected
r_int
id|scsi_scan_host_selected
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
comma
r_int
r_int
id|channel
comma
r_int
r_int
id|id
comma
r_int
r_int
id|lun
comma
r_int
id|rescan
)paren
(brace
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
(paren
id|KERN_INFO
l_string|&quot;%s: &lt;%u:%u:%u:%u&gt;&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|shost-&gt;host_no
comma
id|channel
comma
id|id
comma
id|lun
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|channel
op_ne
id|SCAN_WILD_CARD
)paren
op_logical_and
(paren
id|channel
OG
id|shost-&gt;max_channel
)paren
)paren
op_logical_or
(paren
(paren
id|id
op_ne
id|SCAN_WILD_CARD
)paren
op_logical_and
(paren
id|id
OG
id|shost-&gt;max_id
)paren
)paren
op_logical_or
(paren
(paren
id|lun
op_ne
id|SCAN_WILD_CARD
)paren
op_logical_and
(paren
id|lun
OG
id|shost-&gt;max_lun
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|down
c_func
(paren
op_amp
id|shost-&gt;scan_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|channel
op_eq
id|SCAN_WILD_CARD
)paren
r_for
c_loop
(paren
id|channel
op_assign
l_int|0
suffix:semicolon
id|channel
op_le
id|shost-&gt;max_channel
suffix:semicolon
id|channel
op_increment
)paren
id|scsi_scan_channel
c_func
(paren
id|shost
comma
id|channel
comma
id|id
comma
id|lun
comma
id|rescan
)paren
suffix:semicolon
r_else
id|scsi_scan_channel
c_func
(paren
id|shost
comma
id|channel
comma
id|id
comma
id|lun
comma
id|rescan
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|shost-&gt;scan_mutex
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_scan_host - scan the given adapter&n; * @shost:&t;adapter to scan&n; **/
DECL|function|scsi_scan_host
r_void
id|scsi_scan_host
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
)paren
(brace
id|scsi_scan_host_selected
c_func
(paren
id|shost
comma
id|SCAN_WILD_CARD
comma
id|SCAN_WILD_CARD
comma
id|SCAN_WILD_CARD
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|variable|scsi_scan_host
id|EXPORT_SYMBOL
c_func
(paren
id|scsi_scan_host
)paren
suffix:semicolon
DECL|function|scsi_forget_host
r_void
id|scsi_forget_host
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
comma
op_star
id|tmp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, this look a bit strange.  We always look for the first device&n;&t; * on the list as scsi_remove_device removes them from it - thus we&n;&t; * also have to release the lock.&n;&t; * We don&squot;t need to get another reference to the device before&n;&t; * releasing the lock as we already own the reference from&n;&t; * scsi_register_device that&squot;s release in scsi_remove_device.  And&n;&t; * after that we don&squot;t look at sdev anymore.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
id|shost-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|sdev
comma
id|tmp
comma
op_amp
id|shost-&gt;__devices
comma
id|siblings
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
id|shost-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|scsi_remove_device
c_func
(paren
id|sdev
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|shost-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
id|shost-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_get_host_dev()&n; *&n; * Purpose:     Create a Scsi_Device that points to the host adapter itself.&n; *&n; * Arguments:   SHpnt   - Host that needs a Scsi_Device&n; *&n; * Lock status: None assumed.&n; *&n; * Returns:     The Scsi_Device or NULL&n; *&n; * Notes:&n; *&t;Attach a single Scsi_Device to the Scsi_Host - this should&n; *&t;be made to look like a &quot;pseudo-device&quot; that points to the&n; *&t;HA itself.&n; *&n; *&t;Note - this device is not accessible from any high-level&n; *&t;drivers (including generics), which is probably not&n; *&t;optimal.  We can add hooks later to attach &n; */
DECL|function|scsi_get_host_dev
r_struct
id|scsi_device
op_star
id|scsi_get_host_dev
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
id|sdev
op_assign
id|scsi_alloc_sdev
c_func
(paren
id|shost
comma
l_int|0
comma
id|shost-&gt;this_id
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev
)paren
(brace
id|sdev-&gt;borken
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|sdev
suffix:semicolon
)brace
DECL|variable|scsi_get_host_dev
id|EXPORT_SYMBOL
c_func
(paren
id|scsi_get_host_dev
)paren
suffix:semicolon
multiline_comment|/*&n; * Function:    scsi_free_host_dev()&n; *&n; * Purpose:     Free a scsi_device that points to the host adapter itself.&n; *&n; * Arguments:   SHpnt   - Host that needs a Scsi_Device&n; *&n; * Lock status: None assumed.&n; *&n; * Returns:     Nothing&n; *&n; * Notes:&n; */
DECL|function|scsi_free_host_dev
r_void
id|scsi_free_host_dev
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
)paren
(brace
id|BUG_ON
c_func
(paren
id|sdev-&gt;id
op_ne
id|sdev-&gt;host-&gt;this_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;host-&gt;hostt-&gt;slave_destroy
)paren
id|sdev-&gt;host-&gt;hostt
op_member_access_from_pointer
id|slave_destroy
c_func
(paren
id|sdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;host-&gt;transportt-&gt;device_destroy
)paren
id|sdev-&gt;host-&gt;transportt
op_member_access_from_pointer
id|device_destroy
c_func
(paren
id|sdev
)paren
suffix:semicolon
id|put_device
c_func
(paren
op_amp
id|sdev-&gt;sdev_gendev
)paren
suffix:semicolon
)brace
DECL|variable|scsi_free_host_dev
id|EXPORT_SYMBOL
c_func
(paren
id|scsi_free_host_dev
)paren
suffix:semicolon
eof
