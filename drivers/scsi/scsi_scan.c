multiline_comment|/*&n; * scsi_scan.c&n; *&n; * Copyright (C) 2000 Eric Youngdale,&n; * Copyright (C) 2002 Patrick Mansfield&n; *&n; * The general scanning/probing algorithm is as follows, exceptions are&n; * made to it depending on device specific flags, compilation options, and&n; * global variable (boot or module load time) settings.&n; *&n; * A specific LUN is scanned via an INQUIRY command; if the LUN has a&n; * device attached, a Scsi_Device is allocated and setup for it.&n; *&n; * For every id of every channel on the given host:&n; *&n; * &t;Scan LUN 0; if the target responds to LUN 0 (even if there is no&n; * &t;device or storage attached to LUN 0):&n; *&n; * &t;&t;If LUN 0 has a device attached, allocate and setup a&n; * &t;&t;Scsi_Device for it.&n; *&n; * &t;&t;If target is SCSI-3 or up, issue a REPORT LUN, and scan&n; * &t;&t;all of the LUNs returned by the REPORT LUN; else,&n; * &t;&t;sequentially scan LUNs up until some maximum is reached,&n; * &t;&t;or a LUN is seen that cannot have a device attached to it.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;scsi_priv.h&quot;
macro_line|#include &quot;scsi_logging.h&quot;
macro_line|#include &quot;scsi_devinfo.h&quot;
DECL|macro|ALLOC_FAILURE_MSG
mdefine_line|#define ALLOC_FAILURE_MSG&t;KERN_ERR &quot;%s: Allocation failure during&quot; &bslash;&n;&t;&quot; SCSI scanning, some SCSI devices might not be configured&bslash;n&quot;
multiline_comment|/*&n; * Prefix values for the SCSI id&squot;s (stored in driverfs name field)&n; */
DECL|macro|SCSI_UID_SER_NUM
mdefine_line|#define SCSI_UID_SER_NUM &squot;S&squot;
DECL|macro|SCSI_UID_UNKNOWN
mdefine_line|#define SCSI_UID_UNKNOWN &squot;Z&squot;
multiline_comment|/*&n; * Return values of some of the scanning functions.&n; *&n; * SCSI_SCAN_NO_RESPONSE: no valid response received from the target, this&n; * includes allocation or general failures preventing IO from being sent.&n; *&n; * SCSI_SCAN_TARGET_PRESENT: target responded, but no device is available&n; * on the given LUN.&n; *&n; * SCSI_SCAN_LUN_PRESENT: target responded, and a device is available on a&n; * given LUN.&n; */
DECL|macro|SCSI_SCAN_NO_RESPONSE
mdefine_line|#define SCSI_SCAN_NO_RESPONSE&t;&t;0
DECL|macro|SCSI_SCAN_TARGET_PRESENT
mdefine_line|#define SCSI_SCAN_TARGET_PRESENT&t;1
DECL|macro|SCSI_SCAN_LUN_PRESENT
mdefine_line|#define SCSI_SCAN_LUN_PRESENT&t;&t;2
DECL|variable|scsi_null_device_strs
r_static
r_char
op_star
id|scsi_null_device_strs
op_assign
l_string|&quot;nullnullnullnull&quot;
suffix:semicolon
DECL|macro|MAX_SCSI_LUNS
mdefine_line|#define MAX_SCSI_LUNS&t;512
macro_line|#ifdef CONFIG_SCSI_MULTI_LUN
DECL|variable|max_scsi_luns
r_static
r_int
r_int
id|max_scsi_luns
op_assign
id|MAX_SCSI_LUNS
suffix:semicolon
macro_line|#else
DECL|variable|max_scsi_luns
r_static
r_int
r_int
id|max_scsi_luns
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
macro_line|#ifdef MODULE
id|MODULE_PARM
c_func
(paren
id|max_scsi_luns
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|max_scsi_luns
comma
l_string|&quot;last scsi LUN (should be between 1 and 2^32-1)&quot;
)paren
suffix:semicolon
macro_line|#else
DECL|function|scsi_luns_setup
r_static
r_int
id|__init
id|scsi_luns_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|get_option
c_func
(paren
op_amp
id|str
comma
op_amp
id|tmp
)paren
op_eq
l_int|1
)paren
(brace
id|max_scsi_luns
op_assign
id|tmp
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi_luns_setup: usage max_scsi_luns=n &quot;
l_string|&quot;(n should be between 1 and 2^32-1)&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|__setup
c_func
(paren
l_string|&quot;max_scsi_luns=&quot;
comma
id|scsi_luns_setup
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_SCSI_REPORT_LUNS
multiline_comment|/*&n; * max_scsi_report_luns: the maximum number of LUNS that will be&n; * returned from the REPORT LUNS command. 8 times this value must&n; * be allocated. In theory this could be up to an 8 byte value, but&n; * in practice, the maximum number of LUNs suppored by any device&n; * is about 16k.&n; */
DECL|variable|max_scsi_report_luns
r_static
r_int
r_int
id|max_scsi_report_luns
op_assign
l_int|128
suffix:semicolon
macro_line|#ifdef MODULE
id|MODULE_PARM
c_func
(paren
id|max_scsi_report_luns
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|max_scsi_report_luns
comma
l_string|&quot;REPORT LUNS maximum number of LUNS received (should be&quot;
l_string|&quot; between 1 and 16384)&quot;
)paren
suffix:semicolon
macro_line|#else
DECL|function|scsi_report_luns_setup
r_static
r_int
id|__init
id|scsi_report_luns_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|get_option
c_func
(paren
op_amp
id|str
comma
op_amp
id|tmp
)paren
op_eq
l_int|1
)paren
(brace
id|max_scsi_report_luns
op_assign
id|tmp
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi_report_luns_setup: usage&quot;
l_string|&quot; max_scsi_report_luns=n (n should be between 1&quot;
l_string|&quot; and 16384)&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|__setup
c_func
(paren
l_string|&quot;max_scsi_report_luns=&quot;
comma
id|scsi_report_luns_setup
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
multiline_comment|/**&n; * scsi_unlock_floptical - unlock device via a special MODE SENSE command&n; * @sreq:&t;used to send the command&n; * @result:&t;area to store the result of the MODE SENSE&n; *&n; * Description:&n; *     Send a vendor specific MODE SENSE (not a MODE SELECT) command using&n; *     @sreq to unlock a device, storing the (unused) results into result.&n; *     Called for BLIST_KEY devices.&n; **/
DECL|function|scsi_unlock_floptical
r_static
r_void
id|scsi_unlock_floptical
c_func
(paren
id|Scsi_Request
op_star
id|sreq
comma
r_int
r_char
op_star
id|result
)paren
(brace
r_int
r_char
id|scsi_cmd
(braket
id|MAX_COMMAND_SIZE
)braket
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;scsi: unlocking floptical drive&bslash;n&quot;
)paren
suffix:semicolon
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|MODE_SENSE
suffix:semicolon
id|scsi_cmd
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|2
)braket
op_assign
l_int|0x2e
suffix:semicolon
id|scsi_cmd
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
l_int|0x2a
suffix:semicolon
multiline_comment|/* size */
id|scsi_cmd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_cmd_len
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_data_direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
id|scsi_wait_req
c_func
(paren
id|sreq
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|result
comma
l_int|0x2a
multiline_comment|/* size */
comma
id|SCSI_TIMEOUT
comma
l_int|3
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * print_inquiry - printk the inquiry information&n; * @inq_result:&t;printk this SCSI INQUIRY&n; *&n; * Description:&n; *     printk the vendor, model, and other information found in the&n; *     INQUIRY data in @inq_result.&n; *&n; * Notes:&n; *     Remove this, and replace with a hotplug event that logs any&n; *     relevant information.&n; **/
DECL|function|print_inquiry
r_static
r_void
id|print_inquiry
c_func
(paren
r_int
r_char
op_star
id|inq_result
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;  Vendor: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|8
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|inq_result
(braket
id|i
)braket
op_ge
l_int|0x20
op_logical_and
id|i
OL
id|inq_result
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|inq_result
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  Model: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|16
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|inq_result
(braket
id|i
)braket
op_ge
l_int|0x20
op_logical_and
id|i
OL
id|inq_result
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|inq_result
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  Rev: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|32
suffix:semicolon
id|i
OL
l_int|36
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|inq_result
(braket
id|i
)braket
op_ge
l_int|0x20
op_logical_and
id|i
OL
id|inq_result
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|inq_result
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|i
op_assign
id|inq_result
(braket
l_int|0
)braket
op_amp
l_int|0x1f
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;  Type:   %s &quot;
comma
id|i
OL
id|MAX_SCSI_DEVICE_CODE
ques
c_cond
id|scsi_device_types
(braket
id|i
)braket
suffix:colon
l_string|&quot;Unknown          &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;                 ANSI SCSI revision: %02x&quot;
comma
id|inq_result
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inq_result
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
op_eq
l_int|1
op_logical_and
(paren
id|inq_result
(braket
l_int|3
)braket
op_amp
l_int|0x0f
)paren
op_eq
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot; CCS&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_alloc_sdev - allocate and setup a scsi_Device&n; *&n; * Description:&n; *     Allocate, initialize for io, and return a pointer to a scsi_Device.&n; *     Stores the @shost, @channel, @id, and @lun in the scsi_Device, and&n; *     adds scsi_Device to the appropriate list.&n; *&n; * Return value:&n; *     scsi_Device pointer, or NULL on failure.&n; **/
DECL|function|scsi_alloc_sdev
r_static
r_struct
id|scsi_device
op_star
id|scsi_alloc_sdev
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
comma
id|uint
id|channel
comma
id|uint
id|id
comma
id|uint
id|lun
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
comma
op_star
id|device
suffix:semicolon
id|sdev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|sdev
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sdev
)paren
r_goto
id|out
suffix:semicolon
id|memset
c_func
(paren
id|sdev
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|sdev
)paren
)paren
suffix:semicolon
id|sdev-&gt;vendor
op_assign
id|scsi_null_device_strs
suffix:semicolon
id|sdev-&gt;model
op_assign
id|scsi_null_device_strs
suffix:semicolon
id|sdev-&gt;rev
op_assign
id|scsi_null_device_strs
suffix:semicolon
id|sdev-&gt;host
op_assign
id|shost
suffix:semicolon
id|sdev-&gt;id
op_assign
id|id
suffix:semicolon
id|sdev-&gt;lun
op_assign
id|lun
suffix:semicolon
id|sdev-&gt;channel
op_assign
id|channel
suffix:semicolon
id|sdev-&gt;online
op_assign
id|TRUE
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sdev-&gt;siblings
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sdev-&gt;same_target_siblings
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sdev-&gt;cmd_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sdev-&gt;starved_entry
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|sdev-&gt;list_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Some low level driver could use device-&gt;type&n;&t; */
id|sdev-&gt;type
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Assume that the device will have handshaking problems,&n;&t; * and then fix this field later if it turns out it&n;&t; * doesn&squot;t&n;&t; */
id|sdev-&gt;borken
op_assign
l_int|1
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|sdev-&gt;sdev_lock
)paren
suffix:semicolon
id|sdev-&gt;request_queue
op_assign
id|scsi_alloc_queue
c_func
(paren
id|sdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sdev-&gt;request_queue
)paren
r_goto
id|out_free_dev
suffix:semicolon
id|sdev-&gt;request_queue-&gt;queuedata
op_assign
id|sdev
suffix:semicolon
id|scsi_adjust_queue_depth
c_func
(paren
id|sdev
comma
l_int|0
comma
id|sdev-&gt;host-&gt;cmd_per_lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shost-&gt;hostt-&gt;slave_alloc
)paren
(brace
r_if
c_cond
(paren
id|shost-&gt;hostt
op_member_access_from_pointer
id|slave_alloc
c_func
(paren
id|sdev
)paren
)paren
r_goto
id|out_free_queue
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If there are any same target siblings, add this to the&n;&t; * sibling list&n;&t; */
id|list_for_each_entry
c_func
(paren
id|device
comma
op_amp
id|shost-&gt;my_devices
comma
id|siblings
)paren
(brace
r_if
c_cond
(paren
id|device-&gt;id
op_eq
id|sdev-&gt;id
op_logical_and
id|device-&gt;channel
op_eq
id|sdev-&gt;channel
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
id|sdev-&gt;same_target_siblings
comma
op_amp
id|device-&gt;same_target_siblings
)paren
suffix:semicolon
id|sdev-&gt;scsi_level
op_assign
id|device-&gt;scsi_level
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If there wasn&squot;t another lun already configured at this&n;&t; * target, then default this device to SCSI_2 until we&n;&t; * know better&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sdev-&gt;scsi_level
)paren
id|sdev-&gt;scsi_level
op_assign
id|SCSI_2
suffix:semicolon
multiline_comment|/*&n;&t; * Add it to the end of the shost-&gt;my_devices list.&n;&t; */
id|list_add_tail
c_func
(paren
op_amp
id|sdev-&gt;siblings
comma
op_amp
id|shost-&gt;my_devices
)paren
suffix:semicolon
r_return
id|sdev
suffix:semicolon
id|out_free_queue
suffix:colon
id|scsi_free_queue
c_func
(paren
id|sdev-&gt;request_queue
)paren
suffix:semicolon
id|out_free_dev
suffix:colon
id|kfree
c_func
(paren
id|sdev
)paren
suffix:semicolon
id|out
suffix:colon
id|printk
c_func
(paren
id|ALLOC_FAILURE_MSG
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_free_sdev - cleanup and free a scsi_device&n; * @sdev:&t;cleanup and free this scsi_device&n; *&n; * Description:&n; *     Undo the actions in scsi_alloc_sdev, including removing @sdev from&n; *     the list, and freeing @sdev.&n; **/
DECL|function|scsi_free_sdev
r_void
id|scsi_free_sdev
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|sdev-&gt;siblings
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|sdev-&gt;same_target_siblings
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;request_queue
)paren
id|scsi_free_queue
c_func
(paren
id|sdev-&gt;request_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;host-&gt;hostt-&gt;slave_destroy
)paren
id|sdev-&gt;host-&gt;hostt
op_member_access_from_pointer
id|slave_destroy
c_func
(paren
id|sdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;inquiry
)paren
id|kfree
c_func
(paren
id|sdev-&gt;inquiry
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|sdev-&gt;host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|sdev-&gt;starved_entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;single_lun
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|sdev-&gt;sdev_target-&gt;starget_refcnt
op_eq
l_int|0
)paren
id|kfree
c_func
(paren
id|sdev-&gt;sdev_target
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
id|sdev-&gt;host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sdev
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_probe_lun - probe a single LUN using a SCSI INQUIRY&n; * @sreq:&t;used to send the INQUIRY&n; * @inq_result:&t;area to store the INQUIRY result&n; * @bflags:&t;store any bflags found here&n; *&n; * Description:&n; *     Probe the lun associated with @sreq using a standard SCSI INQUIRY;&n; *&n; *     If the INQUIRY is successful, sreq-&gt;sr_result is zero and: the&n; *     INQUIRY data is in @inq_result; the scsi_level and INQUIRY length&n; *     are copied to the Scsi_Device at @sreq-&gt;sr_device (sdev);&n; *     any flags value is stored in *@bflags.&n; **/
DECL|function|scsi_probe_lun
r_static
r_void
id|scsi_probe_lun
c_func
(paren
id|Scsi_Request
op_star
id|sreq
comma
r_char
op_star
id|inq_result
comma
r_int
op_star
id|bflags
)paren
(brace
id|Scsi_Device
op_star
id|sdev
op_assign
id|sreq-&gt;sr_device
suffix:semicolon
multiline_comment|/* a bit ugly */
r_int
r_char
id|scsi_cmd
(braket
id|MAX_COMMAND_SIZE
)braket
suffix:semicolon
r_int
id|possible_inq_resp_len
suffix:semicolon
op_star
id|bflags
op_assign
l_int|0
suffix:semicolon
id|repeat_inquiry
suffix:colon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi scan: INQUIRY to host %d&quot;
l_string|&quot; channel %d id %d lun %d&bslash;n&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|scsi_cmd
comma
l_int|0
comma
l_int|6
)paren
suffix:semicolon
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|INQUIRY
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
l_int|36
suffix:semicolon
multiline_comment|/* issue conservative alloc_length */
id|sreq-&gt;sr_cmd_len
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_data_direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
id|memset
c_func
(paren
id|inq_result
comma
l_int|0
comma
l_int|36
)paren
suffix:semicolon
id|scsi_wait_req
c_func
(paren
id|sreq
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|inq_result
comma
l_int|36
comma
id|SCSI_TIMEOUT
op_plus
l_int|4
op_star
id|HZ
comma
l_int|3
)paren
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi scan: 1st INQUIRY %s with&quot;
l_string|&quot; code 0x%x&bslash;n&quot;
comma
id|sreq-&gt;sr_result
ques
c_cond
l_string|&quot;failed&quot;
suffix:colon
l_string|&quot;successful&quot;
comma
id|sreq-&gt;sr_result
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sreq-&gt;sr_result
)paren
(brace
r_if
c_cond
(paren
(paren
id|driver_byte
c_func
(paren
id|sreq-&gt;sr_result
)paren
op_amp
id|DRIVER_SENSE
)paren
op_ne
l_int|0
op_logical_and
(paren
id|sreq-&gt;sr_sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_eq
id|UNIT_ATTENTION
op_logical_and
id|sreq-&gt;sr_sense_buffer
(braket
l_int|12
)braket
op_eq
l_int|0x28
op_logical_and
id|sreq-&gt;sr_sense_buffer
(braket
l_int|13
)braket
op_eq
l_int|0
)paren
(brace
multiline_comment|/* not-ready to ready transition - good */
multiline_comment|/* dpg: bogus? INQUIRY never returns UNIT_ATTENTION */
)brace
r_else
multiline_comment|/*&n;&t;&t;&t; * assume no peripheral if any other sort of error&n;&t;&t;&t; */
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get any flags for this device.&n;&t; *&n;&t; * XXX add a bflags to Scsi_Device, and replace the corresponding&n;&t; * bit fields in Scsi_Device, so bflags need not be passed as an&n;&t; * argument.&n;&t; */
op_star
id|bflags
op_or_assign
id|scsi_get_device_flags
c_func
(paren
op_amp
id|inq_result
(braket
l_int|8
)braket
comma
op_amp
id|inq_result
(braket
l_int|16
)braket
)paren
suffix:semicolon
id|possible_inq_resp_len
op_assign
(paren
r_int
r_char
)paren
id|inq_result
(braket
l_int|4
)braket
op_plus
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|BLIST_INQUIRY_36
op_amp
op_star
id|bflags
)paren
id|possible_inq_resp_len
op_assign
l_int|36
suffix:semicolon
r_else
r_if
c_cond
(paren
id|BLIST_INQUIRY_58
op_amp
op_star
id|bflags
)paren
id|possible_inq_resp_len
op_assign
l_int|58
suffix:semicolon
r_else
r_if
c_cond
(paren
id|possible_inq_resp_len
OG
l_int|255
)paren
id|possible_inq_resp_len
op_assign
l_int|36
suffix:semicolon
multiline_comment|/* sanity */
r_if
c_cond
(paren
id|possible_inq_resp_len
OG
l_int|36
)paren
(brace
multiline_comment|/* do additional INQUIRY */
id|memset
c_func
(paren
id|scsi_cmd
comma
l_int|0
comma
l_int|6
)paren
suffix:semicolon
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|INQUIRY
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
(paren
r_int
r_char
)paren
id|possible_inq_resp_len
suffix:semicolon
id|sreq-&gt;sr_cmd_len
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_data_direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
multiline_comment|/*&n;&t;&t; * re-zero inq_result just to be safe.&n;&t;&t; */
id|memset
c_func
(paren
id|inq_result
comma
l_int|0
comma
id|possible_inq_resp_len
)paren
suffix:semicolon
id|scsi_wait_req
c_func
(paren
id|sreq
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|inq_result
comma
id|possible_inq_resp_len
comma
id|SCSI_TIMEOUT
op_plus
l_int|4
op_star
id|HZ
comma
l_int|3
)paren
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi scan: 2nd INQUIRY&quot;
l_string|&quot; %s with code 0x%x&bslash;n&quot;
comma
id|sreq-&gt;sr_result
ques
c_cond
l_string|&quot;failed&quot;
suffix:colon
l_string|&quot;successful&quot;
comma
id|sreq-&gt;sr_result
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sreq-&gt;sr_result
)paren
(brace
multiline_comment|/* if the longer inquiry has failed, flag the device&n;&t;&t;&t; * as only accepting 36 byte inquiries and retry the&n;&t;&t;&t; * 36 byte inquiry */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi scan: %d byte inquiry failed&quot;
l_string|&quot; with code %d.  Consider BLIST_INQUIRY_36 for&quot;
l_string|&quot; this device&bslash;n&quot;
comma
id|possible_inq_resp_len
comma
id|sreq-&gt;sr_result
)paren
suffix:semicolon
op_star
id|bflags
op_assign
id|BLIST_INQUIRY_36
suffix:semicolon
r_goto
id|repeat_inquiry
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * The INQUIRY can change, this means the length can change.&n;&t;&t; */
id|possible_inq_resp_len
op_assign
(paren
r_int
r_char
)paren
id|inq_result
(braket
l_int|4
)braket
op_plus
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|BLIST_INQUIRY_58
op_amp
op_star
id|bflags
)paren
id|possible_inq_resp_len
op_assign
l_int|58
suffix:semicolon
r_else
r_if
c_cond
(paren
id|possible_inq_resp_len
OG
l_int|255
)paren
id|possible_inq_resp_len
op_assign
l_int|36
suffix:semicolon
multiline_comment|/* sanity */
)brace
id|sdev-&gt;inquiry_len
op_assign
id|possible_inq_resp_len
suffix:semicolon
multiline_comment|/*&n;&t; * XXX Abort if the response length is less than 36? If less than&n;&t; * 32, the lookup of the device flags (above) could be invalid,&n;&t; * and it would be possible to take an incorrect action - we do&n;&t; * not want to hang because of a short INQUIRY. On the flip side,&n;&t; * if the device is spun down or becoming ready (and so it gives a&n;&t; * short INQUIRY), an abort here prevents any further use of the&n;&t; * device, including spin up.&n;&t; *&n;&t; * Related to the above issue:&n;&t; *&n;&t; * XXX Devices (disk or all?) should be sent a TEST UNIT READY,&n;&t; * and if not ready, sent a START_STOP to start (maybe spin up) and&n;&t; * then send the INQUIRY again, since the INQUIRY can change after&n;&t; * a device is initialized.&n;&t; *&n;&t; * Ideally, start a device if explicitly asked to do so.  This&n;&t; * assumes that a device is spun up on power on, spun down on&n;&t; * request, and then spun up on request.&n;&t; */
multiline_comment|/*&n;&t; * The scanning code needs to know the scsi_level, even if no&n;&t; * device is attached at LUN 0 (SCSI_SCAN_TARGET_PRESENT) so&n;&t; * non-zero LUNs can be scanned.&n;&t; */
id|sdev-&gt;scsi_level
op_assign
id|inq_result
(braket
l_int|2
)braket
op_amp
l_int|0x07
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;scsi_level
op_ge
l_int|2
op_logical_or
(paren
id|sdev-&gt;scsi_level
op_eq
l_int|1
op_logical_and
(paren
id|inq_result
(braket
l_int|3
)braket
op_amp
l_int|0x0f
)paren
op_eq
l_int|1
)paren
)paren
id|sdev-&gt;scsi_level
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|scsi_set_name
r_static
r_void
id|scsi_set_name
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
comma
r_char
op_star
id|inq_result
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
id|type
(braket
l_int|72
)braket
suffix:semicolon
id|i
op_assign
id|inq_result
(braket
l_int|0
)braket
op_amp
l_int|0x1f
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
id|MAX_SCSI_DEVICE_CODE
)paren
id|strcpy
c_func
(paren
id|type
comma
id|scsi_device_types
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|strcpy
c_func
(paren
id|type
comma
l_string|&quot;Unknown&quot;
)paren
suffix:semicolon
id|i
op_assign
id|strlen
c_func
(paren
id|type
)paren
op_minus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|i
op_ge
l_int|0
op_logical_and
id|type
(braket
id|i
)braket
op_eq
l_char|&squot; &squot;
)paren
id|type
(braket
id|i
op_decrement
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|snprintf
c_func
(paren
id|sdev-&gt;sdev_driverfs_dev.name
comma
id|DEVICE_NAME_SIZE
comma
l_string|&quot;SCSI %s&quot;
comma
id|type
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_add_lun - allocate and fully initialze a Scsi_Device&n; * @sdevscan:&t;holds information to be stored in the new Scsi_Device&n; * @sdevnew:&t;store the address of the newly allocated Scsi_Device&n; * @inq_result:&t;holds the result of a previous INQUIRY to the LUN&n; * @bflags:&t;black/white list flag&n; *&n; * Description:&n; *     Allocate and initialize a Scsi_Device matching sdevscan. Optionally&n; *     set fields based on values in *@bflags. If @sdevnew is not&n; *     NULL, store the address of the new Scsi_Device in *@sdevnew (needed&n; *     when scanning a particular LUN).&n; *&n; * Return:&n; *     SCSI_SCAN_NO_RESPONSE: could not allocate or setup a Scsi_Device&n; *     SCSI_SCAN_LUN_PRESENT: a new Scsi_Device was allocated and initialized&n; **/
DECL|function|scsi_add_lun
r_static
r_int
id|scsi_add_lun
c_func
(paren
id|Scsi_Device
op_star
id|sdev
comma
r_char
op_star
id|inq_result
comma
r_int
op_star
id|bflags
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev_sibling
suffix:semicolon
r_struct
id|scsi_target
op_star
id|starget
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * XXX do not save the inquiry, since it can change underneath us,&n;&t; * save just vendor/model/rev.&n;&t; *&n;&t; * Rather than save it and have an ioctl that retrieves the saved&n;&t; * value, have an ioctl that executes the same INQUIRY code used&n;&t; * in scsi_probe_lun, let user level programs doing INQUIRY&n;&t; * scanning run at their own risk, or supply a user level program&n;&t; * that can correctly scan.&n;&t; */
id|sdev-&gt;inquiry
op_assign
id|kmalloc
c_func
(paren
id|sdev-&gt;inquiry_len
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;inquiry
op_eq
l_int|NULL
)paren
(brace
r_return
id|SCSI_SCAN_NO_RESPONSE
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|sdev-&gt;inquiry
comma
id|inq_result
comma
id|sdev-&gt;inquiry_len
)paren
suffix:semicolon
id|sdev-&gt;vendor
op_assign
(paren
r_char
op_star
)paren
(paren
id|sdev-&gt;inquiry
op_plus
l_int|8
)paren
suffix:semicolon
id|sdev-&gt;model
op_assign
(paren
r_char
op_star
)paren
(paren
id|sdev-&gt;inquiry
op_plus
l_int|16
)paren
suffix:semicolon
id|sdev-&gt;rev
op_assign
(paren
r_char
op_star
)paren
(paren
id|sdev-&gt;inquiry
op_plus
l_int|32
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|bflags
op_amp
id|BLIST_ISROM
)paren
(brace
multiline_comment|/*&n;&t;&t; * It would be better to modify sdev-&gt;type, and set&n;&t;&t; * sdev-&gt;removable, but then the print_inquiry() output&n;&t;&t; * would not show TYPE_ROM; if print_inquiry() is removed&n;&t;&t; * the issue goes away.&n;&t;&t; */
id|inq_result
(braket
l_int|0
)braket
op_assign
id|TYPE_ROM
suffix:semicolon
id|inq_result
(braket
l_int|1
)braket
op_or_assign
l_int|0x80
suffix:semicolon
multiline_comment|/* removable */
)brace
r_switch
c_cond
(paren
id|sdev-&gt;type
op_assign
(paren
id|inq_result
(braket
l_int|0
)braket
op_amp
l_int|0x1f
)paren
)paren
(brace
r_case
id|TYPE_TAPE
suffix:colon
r_case
id|TYPE_DISK
suffix:colon
r_case
id|TYPE_PRINTER
suffix:colon
r_case
id|TYPE_MOD
suffix:colon
r_case
id|TYPE_PROCESSOR
suffix:colon
r_case
id|TYPE_SCANNER
suffix:colon
r_case
id|TYPE_MEDIUM_CHANGER
suffix:colon
r_case
id|TYPE_ENCLOSURE
suffix:colon
r_case
id|TYPE_COMM
suffix:colon
id|sdev-&gt;writeable
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_WORM
suffix:colon
r_case
id|TYPE_ROM
suffix:colon
id|sdev-&gt;writeable
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi: unknown device type %d&bslash;n&quot;
comma
id|sdev-&gt;type
)paren
suffix:semicolon
)brace
id|sdev-&gt;random
op_assign
(paren
id|sdev-&gt;type
op_eq
id|TYPE_TAPE
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
id|scsi_set_name
c_func
(paren
id|sdev
comma
id|inq_result
)paren
suffix:semicolon
id|print_inquiry
c_func
(paren
id|inq_result
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * For a peripheral qualifier (PQ) value of 1 (001b), the SCSI&n;&t; * spec says: The device server is capable of supporting the&n;&t; * specified peripheral device type on this logical unit. However,&n;&t; * the physical device is not currently connected to this logical&n;&t; * unit.&n;&t; *&n;&t; * The above is vague, as it implies that we could treat 001 and&n;&t; * 011 the same. Stay compatible with previous code, and create a&n;&t; * Scsi_Device for a PQ of 1&n;&t; *&n;&t; * XXX Save the PQ field let the upper layers figure out if they&n;&t; * want to attach or not to this device, do not set online FALSE;&n;&t; * otherwise, offline devices still get an sd allocated, and they&n;&t; * use up an sd slot.&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|inq_result
(braket
l_int|0
)braket
op_rshift
l_int|5
)paren
op_amp
l_int|7
)paren
op_eq
l_int|1
)paren
(brace
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi scan: peripheral&quot;
l_string|&quot; qualifier of 1, device offlined&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|sdev-&gt;online
op_assign
id|FALSE
suffix:semicolon
)brace
id|sdev-&gt;removable
op_assign
(paren
l_int|0x80
op_amp
id|inq_result
(braket
l_int|1
)braket
)paren
op_rshift
l_int|7
suffix:semicolon
id|sdev-&gt;lockable
op_assign
id|sdev-&gt;removable
suffix:semicolon
id|sdev-&gt;soft_reset
op_assign
(paren
id|inq_result
(braket
l_int|7
)braket
op_amp
l_int|1
)paren
op_logical_and
(paren
(paren
id|inq_result
(braket
l_int|3
)braket
op_amp
l_int|7
)paren
op_eq
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;scsi_level
op_ge
id|SCSI_3
op_logical_or
(paren
id|sdev-&gt;inquiry_len
OG
l_int|56
op_logical_and
id|inq_result
(braket
l_int|56
)braket
op_amp
l_int|0x04
)paren
)paren
id|sdev-&gt;ppr
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|inq_result
(braket
l_int|7
)braket
op_amp
l_int|0x60
)paren
id|sdev-&gt;wdtr
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|inq_result
(braket
l_int|7
)braket
op_amp
l_int|0x10
)paren
id|sdev-&gt;sdtr
op_assign
l_int|1
suffix:semicolon
id|sprintf
c_func
(paren
id|sdev-&gt;devfs_name
comma
l_string|&quot;scsi/host%d/bus%d/target%d/lun%d&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
)paren
suffix:semicolon
id|scsi_device_register
c_func
(paren
id|sdev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * End driverfs/devfs code.&n;&t; */
r_if
c_cond
(paren
(paren
id|sdev-&gt;scsi_level
op_ge
id|SCSI_2
)paren
op_logical_and
(paren
id|inq_result
(braket
l_int|7
)braket
op_amp
l_int|2
)paren
op_logical_and
op_logical_neg
(paren
op_star
id|bflags
op_amp
id|BLIST_NOTQ
)paren
)paren
id|sdev-&gt;tagged_supported
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Some devices (Texel CD ROM drives) have handshaking problems&n;&t; * when used with the Seagate controllers. borken is initialized&n;&t; * to 1, and then set it to 0 here.&n;&t; */
r_if
c_cond
(paren
(paren
op_star
id|bflags
op_amp
id|BLIST_BORKEN
)paren
op_eq
l_int|0
)paren
id|sdev-&gt;borken
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Some devices may not want to have a start command automatically&n;&t; * issued when a device is added.&n;&t; */
r_if
c_cond
(paren
op_star
id|bflags
op_amp
id|BLIST_NOSTARTONADD
)paren
id|sdev-&gt;no_start_on_add
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * If we need to allow I/O to only one of the luns attached to&n;&t; * this target id at a time set single_lun, and allocate or modify&n;&t; * sdev_target.&n;&t; */
r_if
c_cond
(paren
op_star
id|bflags
op_amp
id|BLIST_SINGLELUN
)paren
(brace
id|sdev-&gt;single_lun
op_assign
l_int|1
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|sdev-&gt;host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|starget
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Search for an existing target for this sdev.&n;&t;&t; */
id|list_for_each_entry
c_func
(paren
id|sdev_sibling
comma
op_amp
id|sdev-&gt;same_target_siblings
comma
id|same_target_siblings
)paren
(brace
r_if
c_cond
(paren
id|sdev_sibling-&gt;sdev_target
op_ne
l_int|NULL
)paren
(brace
id|starget
op_assign
id|sdev_sibling-&gt;sdev_target
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|starget
)paren
(brace
id|starget
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|starget
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|starget
)paren
(brace
id|printk
c_func
(paren
id|ALLOC_FAILURE_MSG
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|sdev-&gt;host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|SCSI_SCAN_NO_RESPONSE
suffix:semicolon
)brace
id|starget-&gt;starget_refcnt
op_assign
l_int|0
suffix:semicolon
id|starget-&gt;starget_sdev_user
op_assign
l_int|NULL
suffix:semicolon
)brace
id|starget-&gt;starget_refcnt
op_increment
suffix:semicolon
id|sdev-&gt;sdev_target
op_assign
id|starget
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|sdev-&gt;host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* if the device needs this changing, it may do so in the detect&n;&t; * function */
id|sdev-&gt;max_device_blocked
op_assign
id|SCSI_DEFAULT_DEVICE_BLOCKED
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;host-&gt;hostt-&gt;slave_configure
)paren
(brace
id|sdev-&gt;host-&gt;hostt
op_member_access_from_pointer
id|slave_configure
c_func
(paren
id|sdev
)paren
suffix:semicolon
)brace
r_return
id|SCSI_SCAN_LUN_PRESENT
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_probe_and_add_lun - probe a LUN, if a LUN is found add it&n; * @sdevscan:&t;probe the LUN corresponding to this Scsi_Device&n; * @sdevnew:&t;store the value of any new Scsi_Device allocated&n; * @bflagsp:&t;store bflags here if not NULL&n; *&n; * Description:&n; *     Call scsi_probe_lun, if a LUN with an attached device is found,&n; *     allocate and set it up by calling scsi_add_lun.&n; *&n; * Return:&n; *     SCSI_SCAN_NO_RESPONSE: could not allocate or setup a Scsi_Device&n; *     SCSI_SCAN_TARGET_PRESENT: target responded, but no device is&n; *         attached at the LUN&n; *     SCSI_SCAN_LUN_PRESENT: a new Scsi_Device was allocated and initialized&n; **/
DECL|function|scsi_probe_and_add_lun
r_static
r_int
id|scsi_probe_and_add_lun
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
id|uint
id|channel
comma
id|uint
id|id
comma
id|uint
id|lun
comma
r_int
op_star
id|bflagsp
comma
r_struct
id|scsi_device
op_star
op_star
id|sdevp
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
r_struct
id|scsi_request
op_star
id|sreq
suffix:semicolon
r_int
r_char
op_star
id|result
suffix:semicolon
r_int
id|bflags
comma
id|res
op_assign
id|SCSI_SCAN_NO_RESPONSE
suffix:semicolon
id|sdev
op_assign
id|scsi_alloc_sdev
c_func
(paren
id|host
comma
id|channel
comma
id|id
comma
id|lun
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sdev
)paren
r_goto
id|out
suffix:semicolon
id|sreq
op_assign
id|scsi_allocate_request
c_func
(paren
id|sdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sreq
)paren
r_goto
id|out_free_sdev
suffix:semicolon
id|result
op_assign
id|kmalloc
c_func
(paren
l_int|256
comma
id|GFP_ATOMIC
op_or
(paren
id|host-&gt;unchecked_isa_dma
)paren
ques
c_cond
id|__GFP_DMA
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
r_goto
id|out_free_sreq
suffix:semicolon
id|scsi_probe_lun
c_func
(paren
id|sreq
comma
id|result
comma
op_amp
id|bflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sreq-&gt;sr_result
)paren
r_goto
id|out_free_result
suffix:semicolon
multiline_comment|/*&n;&t; * result contains valid SCSI INQUIRY data.&n;&t; */
r_if
c_cond
(paren
(paren
id|result
(braket
l_int|0
)braket
op_rshift
l_int|5
)paren
op_eq
l_int|3
)paren
(brace
multiline_comment|/*&n;&t;&t; * For a Peripheral qualifier 3 (011b), the SCSI&n;&t;&t; * spec says: The device server is not capable of&n;&t;&t; * supporting a physical device on this logical&n;&t;&t; * unit.&n;&t;&t; *&n;&t;&t; * For disks, this implies that there is no&n;&t;&t; * logical disk configured at sdev-&gt;lun, but there&n;&t;&t; * is a target id responding.&n;&t;&t; */
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi scan: peripheral qualifier of 3,&quot;
l_string|&quot; no device added&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|res
op_assign
id|SCSI_SCAN_TARGET_PRESENT
suffix:semicolon
r_goto
id|out_free_result
suffix:semicolon
)brace
id|res
op_assign
id|scsi_add_lun
c_func
(paren
id|sdev
comma
id|result
comma
op_amp
id|bflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_eq
id|SCSI_SCAN_LUN_PRESENT
)paren
(brace
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_KEY
)paren
(brace
id|sdev-&gt;lockable
op_assign
l_int|0
suffix:semicolon
id|scsi_unlock_floptical
c_func
(paren
id|sreq
comma
id|result
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bflagsp
)paren
op_star
id|bflagsp
op_assign
id|bflags
suffix:semicolon
)brace
id|out_free_result
suffix:colon
id|kfree
c_func
(paren
id|result
)paren
suffix:semicolon
id|out_free_sreq
suffix:colon
id|scsi_release_request
c_func
(paren
id|sreq
)paren
suffix:semicolon
id|out_free_sdev
suffix:colon
r_if
c_cond
(paren
id|res
op_eq
id|SCSI_SCAN_LUN_PRESENT
)paren
(brace
r_if
c_cond
(paren
id|sdevp
)paren
op_star
id|sdevp
op_assign
id|sdev
suffix:semicolon
)brace
r_else
id|scsi_free_sdev
c_func
(paren
id|sdev
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_sequential_lun_scan - sequentially scan a SCSI target&n; * @sdevscan:&t;scan the host, channel, and id of this Scsi_Device&n; * @bflags:&t;black/white list flag for LUN 0&n; * @lun0_res:&t;result of scanning LUN 0&n; *&n; * Description:&n; *     Generally, scan from LUN 1 (LUN 0 is assumed to already have been&n; *     scanned) to some maximum lun until a LUN is found with no device&n; *     attached. Use the bflags to figure out any oddities.&n; *&n; *     Modifies sdevscan-&gt;lun.&n; **/
DECL|function|scsi_sequential_lun_scan
r_static
r_void
id|scsi_sequential_lun_scan
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
comma
id|uint
id|channel
comma
id|uint
id|id
comma
r_int
id|bflags
comma
r_int
id|lun0_res
comma
r_int
id|scsi_level
)paren
(brace
r_int
r_int
id|sparse_lun
comma
id|lun
comma
id|max_dev_lun
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi scan: Sequential scan of&quot;
l_string|&quot; host %d channel %d id %d&bslash;n&quot;
comma
id|shost-&gt;host_no
comma
id|channel
comma
id|id
)paren
)paren
suffix:semicolon
id|max_dev_lun
op_assign
id|min
c_func
(paren
id|max_scsi_luns
comma
id|shost-&gt;max_lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If this device is known to support sparse multiple units,&n;&t; * override the other settings, and scan all of them. Normally,&n;&t; * SCSI-3 devices should be scanned via the REPORT LUNS.&n;&t; */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_SPARSELUN
)paren
(brace
id|max_dev_lun
op_assign
id|shost-&gt;max_lun
suffix:semicolon
id|sparse_lun
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|sparse_lun
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If not sparse lun and no device attached at LUN 0 do not scan&n;&t; * any further.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sparse_lun
op_logical_and
(paren
id|lun0_res
op_ne
id|SCSI_SCAN_LUN_PRESENT
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * If less than SCSI_1_CSS, and no special lun scaning, stop&n;&t; * scanning; this matches 2.4 behaviour, but could just be a bug&n;&t; * (to continue scanning a SCSI_1_CSS device).&n;&t; *&n;&t; * This test is broken.  We might not have any device on lun0 for&n;&t; * a sparselun device, and if that&squot;s the case then how would we&n;&t; * know the real scsi_level, eh?  It might make sense to just not&n;&t; * scan any SCSI_1 device for non-0 luns, but that check would best&n;&t; * go into scsi_alloc_sdev() and just have it return null when asked&n;&t; * to alloc an sdev for lun &gt; 0 on an already found SCSI_1 device.&n;&t; *&n;&t;if ((sdevscan-&gt;scsi_level &lt; SCSI_1_CCS) &amp;&amp;&n;&t;    ((bflags &amp; (BLIST_FORCELUN | BLIST_SPARSELUN | BLIST_MAX5LUN))&n;&t;     == 0))&n;&t;&t;return;&n;&t; */
multiline_comment|/*&n;&t; * If this device is known to support multiple units, override&n;&t; * the other settings, and scan all of them.&n;&t; */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_FORCELUN
)paren
id|max_dev_lun
op_assign
id|shost-&gt;max_lun
suffix:semicolon
multiline_comment|/*&n;&t; * REGAL CDC-4X: avoid hang after LUN 4&n;&t; */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_MAX5LUN
)paren
id|max_dev_lun
op_assign
id|min
c_func
(paren
l_int|5U
comma
id|max_dev_lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do not scan SCSI-2 or lower device past LUN 7, unless&n;&t; * BLIST_LARGELUN.&n;&t; */
r_if
c_cond
(paren
id|scsi_level
OL
id|SCSI_3
op_logical_and
op_logical_neg
(paren
id|bflags
op_amp
id|BLIST_LARGELUN
)paren
)paren
id|max_dev_lun
op_assign
id|min
c_func
(paren
l_int|8U
comma
id|max_dev_lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We have already scanned LUN 0, so start at LUN 1. Keep scanning&n;&t; * until we reach the max, or no LUN is found and we are not&n;&t; * sparse_lun.&n;&t; */
r_for
c_loop
(paren
id|lun
op_assign
l_int|1
suffix:semicolon
id|lun
OL
id|max_dev_lun
suffix:semicolon
op_increment
id|lun
)paren
r_if
c_cond
(paren
(paren
id|scsi_probe_and_add_lun
c_func
(paren
id|shost
comma
id|channel
comma
id|id
comma
id|lun
comma
l_int|NULL
comma
l_int|NULL
)paren
op_ne
id|SCSI_SCAN_LUN_PRESENT
)paren
op_logical_and
op_logical_neg
id|sparse_lun
)paren
r_return
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SCSI_REPORT_LUNS
multiline_comment|/**&n; * scsilun_to_int: convert a scsi_lun to an int&n; * @scsilun:&t;struct scsi_lun to be converted.&n; *&n; * Description:&n; *     Convert @scsilun from a struct scsi_lun to a four byte host byte-ordered&n; *     integer, and return the result. The caller must check for&n; *     truncation before using this function.&n; *&n; * Notes:&n; *     The struct scsi_lun is assumed to be four levels, with each level&n; *     effectively containing a SCSI byte-ordered (big endian) short; the&n; *     addressing bits of each level are ignored (the highest two bits).&n; *     For a description of the LUN format, post SCSI-3 see the SCSI&n; *     Architecture Model, for SCSI-3 see the SCSI Controller Commands.&n; *&n; *     Given a struct scsi_lun of: 0a 04 0b 03 00 00 00 00, this function returns&n; *     the integer: 0x0b030a04&n; **/
DECL|function|scsilun_to_int
r_static
r_int
id|scsilun_to_int
c_func
(paren
r_struct
id|scsi_lun
op_star
id|scsilun
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|lun
suffix:semicolon
id|lun
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|lun
)paren
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
id|lun
op_assign
id|lun
op_or
(paren
(paren
(paren
id|scsilun-&gt;scsi_lun
(braket
id|i
)braket
op_lshift
l_int|8
)paren
op_or
id|scsilun-&gt;scsi_lun
(braket
id|i
op_plus
l_int|1
)braket
)paren
op_lshift
(paren
id|i
op_star
l_int|8
)paren
)paren
suffix:semicolon
r_return
id|lun
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_report_lun_scan - Scan using SCSI REPORT LUN results&n; * @sdevscan:&t;scan the host, channel, and id of this Scsi_Device&n; *&n; * Description:&n; *     If @sdevscan is for a SCSI-3 or up device, send a REPORT LUN&n; *     command, and scan the resulting list of LUNs by calling&n; *     scsi_probe_and_add_lun.&n; *&n; *     Modifies sdevscan-&gt;lun.&n; *&n; * Return:&n; *     0: scan completed (or no memory, so further scanning is futile)&n; *     1: no report lun scan, or not configured&n; **/
DECL|function|scsi_report_lun_scan
r_static
r_int
id|scsi_report_lun_scan
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
comma
r_int
id|bflags
)paren
(brace
r_char
id|devname
(braket
l_int|64
)braket
suffix:semicolon
r_int
r_char
id|scsi_cmd
(braket
id|MAX_COMMAND_SIZE
)braket
suffix:semicolon
r_int
r_int
id|length
suffix:semicolon
r_int
r_int
id|lun
suffix:semicolon
r_int
r_int
id|num_luns
suffix:semicolon
r_int
r_int
id|retries
suffix:semicolon
r_struct
id|scsi_lun
op_star
id|lunp
comma
op_star
id|lun_data
suffix:semicolon
r_struct
id|scsi_request
op_star
id|sreq
suffix:semicolon
r_char
op_star
id|data
suffix:semicolon
multiline_comment|/*&n;&t; * Only support SCSI-3 and up devices.&n;&t; */
r_if
c_cond
(paren
id|sdev-&gt;scsi_level
OL
id|SCSI_3
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_NOLUN
)paren
r_return
l_int|0
suffix:semicolon
id|sreq
op_assign
id|scsi_allocate_request
c_func
(paren
id|sdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sreq
)paren
r_goto
id|out
suffix:semicolon
id|sprintf
c_func
(paren
id|devname
comma
l_string|&quot;host %d channel %d id %d&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate enough to hold the header (the same size as one scsi_lun)&n;&t; * plus the max number of luns we are requesting.&n;&t; *&n;&t; * Reallocating and trying again (with the exact amount we need)&n;&t; * would be nice, but then we need to somehow limit the size&n;&t; * allocated based on the available memory and the limits of&n;&t; * kmalloc - we don&squot;t want a kmalloc() failure of a huge value to&n;&t; * prevent us from finding any LUNs on this target.&n;&t; */
id|length
op_assign
(paren
id|max_scsi_report_luns
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_struct
id|scsi_lun
)paren
suffix:semicolon
id|lun_data
op_assign
id|kmalloc
c_func
(paren
id|length
comma
id|GFP_ATOMIC
op_or
(paren
id|sdev-&gt;host-&gt;unchecked_isa_dma
ques
c_cond
id|__GFP_DMA
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lun_data
)paren
r_goto
id|out_release_request
suffix:semicolon
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|REPORT_LUNS
suffix:semicolon
multiline_comment|/*&n;&t; * bytes 1 - 5: reserved, set to zero.&n;&t; */
id|memset
c_func
(paren
op_amp
id|scsi_cmd
(braket
l_int|1
)braket
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * bytes 6 - 9: length of the command.&n;&t; */
id|scsi_cmd
(braket
l_int|6
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|length
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
suffix:semicolon
id|scsi_cmd
(braket
l_int|7
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|length
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
id|scsi_cmd
(braket
l_int|8
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|length
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|scsi_cmd
(braket
l_int|9
)braket
op_assign
(paren
r_int
r_char
)paren
id|length
op_amp
l_int|0xff
suffix:semicolon
id|scsi_cmd
(braket
l_int|10
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* reserved */
id|scsi_cmd
(braket
l_int|11
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* control */
id|sreq-&gt;sr_cmd_len
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_data_direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
multiline_comment|/*&n;&t; * We can get a UNIT ATTENTION, for example a power on/reset, so&n;&t; * retry a few times (like sd.c does for TEST UNIT READY).&n;&t; * Experience shows some combinations of adapter/devices get at&n;&t; * least two power on/resets.&n;&t; *&n;&t; * Illegal requests (for devices that do not support REPORT LUNS)&n;&t; * should come through as a check condition, and will not generate&n;&t; * a retry.&n;&t; */
r_for
c_loop
(paren
id|retries
op_assign
l_int|0
suffix:semicolon
id|retries
OL
l_int|3
suffix:semicolon
id|retries
op_increment
)paren
(brace
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
(paren
id|KERN_INFO
l_string|&quot;scsi scan: Sending&quot;
l_string|&quot; REPORT LUNS to %s (try %d)&bslash;n&quot;
comma
id|devname
comma
id|retries
)paren
)paren
suffix:semicolon
id|scsi_wait_req
c_func
(paren
id|sreq
comma
id|scsi_cmd
comma
id|lun_data
comma
id|length
comma
id|SCSI_TIMEOUT
op_plus
l_int|4
op_star
id|HZ
comma
l_int|3
)paren
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
(paren
id|KERN_INFO
l_string|&quot;scsi scan: REPORT LUNS&quot;
l_string|&quot; %s (try %d) result 0x%x&bslash;n&quot;
comma
id|sreq-&gt;sr_result
ques
c_cond
l_string|&quot;failed&quot;
suffix:colon
l_string|&quot;successful&quot;
comma
id|retries
comma
id|sreq-&gt;sr_result
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sreq-&gt;sr_result
op_eq
l_int|0
op_logical_or
id|sreq-&gt;sr_sense_buffer
(braket
l_int|2
)braket
op_ne
id|UNIT_ATTENTION
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sreq-&gt;sr_result
)paren
(brace
multiline_comment|/*&n;&t;&t; * The device probably does not support a REPORT LUN command&n;&t;&t; */
id|kfree
c_func
(paren
id|lun_data
)paren
suffix:semicolon
id|scsi_release_request
c_func
(paren
id|sreq
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|scsi_release_request
c_func
(paren
id|sreq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get the length from the first four bytes of lun_data.&n;&t; */
id|data
op_assign
(paren
r_char
op_star
)paren
id|lun_data-&gt;scsi_lun
suffix:semicolon
id|length
op_assign
(paren
(paren
id|data
(braket
l_int|0
)braket
op_lshift
l_int|24
)paren
op_or
(paren
id|data
(braket
l_int|1
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|data
(braket
l_int|2
)braket
op_lshift
l_int|8
)paren
op_or
(paren
id|data
(braket
l_int|3
)braket
op_lshift
l_int|0
)paren
)paren
suffix:semicolon
id|num_luns
op_assign
(paren
id|length
op_div
r_sizeof
(paren
r_struct
id|scsi_lun
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|num_luns
OG
id|max_scsi_report_luns
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi: On %s only %d (max_scsi_report_luns)&quot;
l_string|&quot; of %d luns reported, try increasing&quot;
l_string|&quot; max_scsi_report_luns.&bslash;n&quot;
comma
id|devname
comma
id|max_scsi_report_luns
comma
id|num_luns
)paren
suffix:semicolon
id|num_luns
op_assign
id|max_scsi_report_luns
suffix:semicolon
)brace
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
(paren
id|KERN_INFO
l_string|&quot;scsi scan: REPORT LUN scan of&quot;
l_string|&quot; host %d channel %d id %d&bslash;n&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Scan the luns in lun_data. The entry at offset 0 is really&n;&t; * the header, so start at 1 and go up to and including num_luns.&n;&t; */
r_for
c_loop
(paren
id|lunp
op_assign
op_amp
id|lun_data
(braket
l_int|1
)braket
suffix:semicolon
id|lunp
op_le
op_amp
id|lun_data
(braket
id|num_luns
)braket
suffix:semicolon
id|lunp
op_increment
)paren
(brace
id|lun
op_assign
id|scsilun_to_int
c_func
(paren
id|lunp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check if the unused part of lunp is non-zero, and so&n;&t;&t; * does not fit in lun.&n;&t;&t; */
r_if
c_cond
(paren
id|memcmp
c_func
(paren
op_amp
id|lunp-&gt;scsi_lun
(braket
r_sizeof
(paren
id|lun
)paren
)braket
comma
l_string|&quot;&bslash;0&bslash;0&bslash;0&bslash;0&quot;
comma
l_int|4
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Output an error displaying the LUN in byte order,&n;&t;&t;&t; * this differs from what linux would print for the&n;&t;&t;&t; * integer LUN value.&n;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi: %s lun 0x&quot;
comma
id|devname
)paren
suffix:semicolon
id|data
op_assign
(paren
r_char
op_star
)paren
id|lunp-&gt;scsi_lun
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
r_struct
id|scsi_lun
)paren
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%02x&quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; has a LUN larger than currently supported.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lun
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * LUN 0 has already been scanned.&n;&t;&t;&t; */
)brace
r_else
r_if
c_cond
(paren
id|lun
OG
id|sdev-&gt;host-&gt;max_lun
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi: %s lun%d has a LUN larger&quot;
l_string|&quot; than allowed by the host adapter&bslash;n&quot;
comma
id|devname
comma
id|lun
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|res
suffix:semicolon
id|res
op_assign
id|scsi_probe_and_add_lun
c_func
(paren
id|sdev-&gt;host
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
comma
id|lun
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_eq
id|SCSI_SCAN_NO_RESPONSE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Got some results, but now none, abort.&n;&t;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;scsi: Unexpected response&quot;
l_string|&quot; from %s lun %d while scanning, scan&quot;
l_string|&quot; aborted&bslash;n&quot;
comma
id|devname
comma
id|lun
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|kfree
c_func
(paren
id|lun_data
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_release_request
suffix:colon
id|scsi_release_request
c_func
(paren
id|sreq
)paren
suffix:semicolon
id|out
suffix:colon
multiline_comment|/*&n;&t; * We are out of memory, don&squot;t try scanning any further.&n;&t; */
id|printk
c_func
(paren
id|ALLOC_FAILURE_MSG
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#else
DECL|macro|scsi_report_lun_scan
macro_line|# define scsi_report_lun_scan(sdev, blags)&t;(1)
macro_line|#endif&t;/* CONFIG_SCSI_REPORT_LUNS */
DECL|function|scsi_add_device
r_struct
id|scsi_device
op_star
id|scsi_add_device
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
comma
id|uint
id|channel
comma
id|uint
id|id
comma
id|uint
id|lun
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
r_int
id|res
suffix:semicolon
id|res
op_assign
id|scsi_probe_and_add_lun
c_func
(paren
id|shost
comma
id|channel
comma
id|id
comma
id|lun
comma
l_int|NULL
comma
op_amp
id|sdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_ne
id|SCSI_SCAN_LUN_PRESENT
)paren
id|sdev
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
r_return
id|sdev
suffix:semicolon
)brace
DECL|function|scsi_remove_device
r_int
id|scsi_remove_device
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
)paren
(brace
id|scsi_device_unregister
c_func
(paren
id|sdev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|scsi_rescan_device
r_void
id|scsi_rescan_device
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|scsi_driver
op_star
id|drv
op_assign
id|to_scsi_driver
c_func
(paren
id|dev-&gt;driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|try_module_get
c_func
(paren
id|drv-&gt;owner
)paren
)paren
(brace
r_if
c_cond
(paren
id|drv-&gt;rescan
)paren
id|drv
op_member_access_from_pointer
id|rescan
c_func
(paren
id|dev
)paren
suffix:semicolon
id|module_put
c_func
(paren
id|drv-&gt;owner
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * scsi_scan_target - scan a target id, possibly including all LUNs on the&n; *     target.&n; * @sdevsca:&t;Scsi_Device handle for scanning&n; * @shost:&t;host to scan&n; * @channel:&t;channel to scan&n; * @id:&t;&t;target id to scan&n; *&n; * Description:&n; *     Scan the target id on @shost, @channel, and @id. Scan at least LUN&n; *     0, and possibly all LUNs on the target id.&n; *&n; *     Use the pre-allocated @sdevscan as a handle for the scanning. This&n; *     function sets sdevscan-&gt;host, sdevscan-&gt;id and sdevscan-&gt;lun; the&n; *     scanning functions modify sdevscan-&gt;lun.&n; *&n; *     First try a REPORT LUN scan, if that does not scan the target, do a&n; *     sequential scan of LUNs on the target id.&n; **/
DECL|function|scsi_scan_target
r_static
r_void
id|scsi_scan_target
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
comma
r_int
r_int
id|channel
comma
r_int
r_int
id|id
)paren
(brace
r_int
id|bflags
op_assign
l_int|0
suffix:semicolon
r_int
id|res
suffix:semicolon
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
r_if
c_cond
(paren
id|shost-&gt;this_id
op_eq
id|id
)paren
multiline_comment|/*&n;&t;&t; * Don&squot;t scan the host adapter&n;&t;&t; */
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Scan LUN 0, if there is some response, scan further. Ideally, we&n;&t; * would not configure LUN 0 until all LUNs are scanned.&n;&t; */
id|res
op_assign
id|scsi_probe_and_add_lun
c_func
(paren
id|shost
comma
id|channel
comma
id|id
comma
l_int|0
comma
op_amp
id|bflags
comma
op_amp
id|sdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_eq
id|SCSI_SCAN_LUN_PRESENT
)paren
(brace
r_if
c_cond
(paren
id|scsi_report_lun_scan
c_func
(paren
id|sdev
comma
id|bflags
)paren
op_ne
l_int|0
)paren
multiline_comment|/*&n;&t;&t;&t; * The REPORT LUN did not scan the target,&n;&t;&t;&t; * do a sequential scan.&n;&t;&t;&t; */
id|scsi_sequential_lun_scan
c_func
(paren
id|shost
comma
id|channel
comma
id|id
comma
id|bflags
comma
id|res
comma
id|sdev-&gt;scsi_level
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|res
op_eq
id|SCSI_SCAN_TARGET_PRESENT
)paren
(brace
multiline_comment|/*&n;&t;&t; * There&squot;s a target here, but lun 0 is offline so we&n;&t;&t; * can&squot;t use the report_lun scan.  Fall back to a&n;&t;&t; * sequential lun scan with a bflags of SPARSELUN and&n;&t;&t; * a default scsi level of SCSI_2&n;&t;&t; */
id|scsi_sequential_lun_scan
c_func
(paren
id|shost
comma
id|channel
comma
id|id
comma
id|BLIST_SPARSELUN
comma
id|SCSI_SCAN_TARGET_PRESENT
comma
id|SCSI_2
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * scsi_scan_host - scan the given adapter&n; * @shost:&t;adapter to scan&n; *&n; * Description:&n; *     Iterate and call scsi_scan_target to scan all possible target id&squot;s&n; *     on all possible channels.&n; **/
DECL|function|scsi_scan_host
r_void
id|scsi_scan_host
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
)paren
(brace
id|uint
id|channel
comma
id|id
comma
id|order_id
suffix:semicolon
multiline_comment|/*&n;&t; * The sdevscan host, channel, id and lun are filled in as&n;&t; * needed to scan.&n;&t; */
r_for
c_loop
(paren
id|channel
op_assign
l_int|0
suffix:semicolon
id|channel
op_le
id|shost-&gt;max_channel
suffix:semicolon
id|channel
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * XXX adapter drivers when possible (FCP, iSCSI)&n;&t;&t; * could modify max_id to match the current max,&n;&t;&t; * not the absolute max.&n;&t;&t; *&n;&t;&t; * XXX add a shost id iterator, so for example,&n;&t;&t; * the FC ID can be the same as a target id&n;&t;&t; * without a huge overhead of sparse id&squot;s.&n;&t;&t; */
r_for
c_loop
(paren
id|id
op_assign
l_int|0
suffix:semicolon
id|id
OL
id|shost-&gt;max_id
suffix:semicolon
op_increment
id|id
)paren
(brace
r_if
c_cond
(paren
id|shost-&gt;reverse_ordering
)paren
multiline_comment|/*&n;&t;&t;&t;&t; * Scan from high to low id.&n;&t;&t;&t;&t; */
id|order_id
op_assign
id|shost-&gt;max_id
op_minus
id|id
op_minus
l_int|1
suffix:semicolon
r_else
id|order_id
op_assign
id|id
suffix:semicolon
id|scsi_scan_target
c_func
(paren
id|shost
comma
id|channel
comma
id|order_id
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|scsi_forget_host
r_void
id|scsi_forget_host
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
)paren
(brace
r_struct
id|list_head
op_star
id|le
comma
op_star
id|lh
suffix:semicolon
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|le
comma
id|lh
comma
op_amp
id|shost-&gt;my_devices
)paren
(brace
id|sdev
op_assign
id|list_entry
c_func
(paren
id|le
comma
r_struct
id|scsi_device
comma
id|siblings
)paren
suffix:semicolon
id|scsi_remove_device
c_func
(paren
id|sdev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function:    scsi_get_host_dev()&n; *&n; * Purpose:     Create a Scsi_Device that points to the host adapter itself.&n; *&n; * Arguments:   SHpnt   - Host that needs a Scsi_Device&n; *&n; * Lock status: None assumed.&n; *&n; * Returns:     The Scsi_Device or NULL&n; *&n; * Notes:&n; *&t;Attach a single Scsi_Device to the Scsi_Host - this should&n; *&t;be made to look like a &quot;pseudo-device&quot; that points to the&n; *&t;HA itself.&n; *&n; *&t;Note - this device is not accessible from any high-level&n; *&t;drivers (including generics), which is probably not&n; *&t;optimal.  We can add hooks later to attach &n; */
DECL|function|scsi_get_host_dev
r_struct
id|scsi_device
op_star
id|scsi_get_host_dev
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
id|sdev
op_assign
id|scsi_alloc_sdev
c_func
(paren
id|shost
comma
l_int|0
comma
id|shost-&gt;this_id
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev
)paren
(brace
id|sdev-&gt;borken
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|sdev
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_free_host_dev()&n; *&n; * Purpose:     Free a scsi_device that points to the host adapter itself.&n; *&n; * Arguments:   SHpnt   - Host that needs a Scsi_Device&n; *&n; * Lock status: None assumed.&n; *&n; * Returns:     Nothing&n; *&n; * Notes:&n; */
DECL|function|scsi_free_host_dev
r_void
id|scsi_free_host_dev
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
)paren
(brace
id|BUG_ON
c_func
(paren
id|sdev-&gt;id
op_ne
id|sdev-&gt;host-&gt;this_id
)paren
suffix:semicolon
id|scsi_free_sdev
c_func
(paren
id|sdev
)paren
suffix:semicolon
)brace
eof
