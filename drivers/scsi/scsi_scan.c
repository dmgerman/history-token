multiline_comment|/*&n; * scsi_scan.c&n; *&n; * Copyright (C) 2000 Eric Youngdale,&n; * Copyright (C) 2002 Patrick Mansfield&n; *&n; * The general scanning/probing algorithm is as follows, exceptions are&n; * made to it depending on device specific flags, compilation options, and&n; * global variable (boot or module load time) settings.&n; *&n; * A specific LUN is scanned via an INQUIRY command; if the LUN has a&n; * device attached, a Scsi_Device is allocated and setup for it.&n; *&n; * For every id of every channel on the given host:&n; *&n; * &t;Scan LUN 0; if the target responds to LUN 0 (even if there is no&n; * &t;device or storage attached to LUN 0):&n; *&n; * &t;&t;If LUN 0 has a device attached, allocate and setup a&n; * &t;&t;Scsi_Device for it.&n; *&n; * &t;&t;If target is SCSI-3 or up, issue a REPORT LUN, and scan&n; * &t;&t;all of the LUNs returned by the REPORT LUN; else,&n; * &t;&t;sequentially scan LUNs up until some maximum is reached,&n; * &t;&t;or a LUN is seen that cannot have a device attached to it.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#ifdef CONFIG_KMOD
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#endif
multiline_comment|/*&n; * Flags for SCSI devices that need special treatment&n; */
DECL|macro|BLIST_NOLUN
mdefine_line|#define BLIST_NOLUN     &t;0x001&t;/* Only scan LUN 0 */
DECL|macro|BLIST_FORCELUN
mdefine_line|#define BLIST_FORCELUN  &t;0x002&t;/* Known to have LUNs, force scanning */
DECL|macro|BLIST_BORKEN
mdefine_line|#define BLIST_BORKEN    &t;0x004&t;/* Flag for broken handshaking */
DECL|macro|BLIST_KEY
mdefine_line|#define BLIST_KEY       &t;0x008&t;/* unlock by special command */
DECL|macro|BLIST_SINGLELUN
mdefine_line|#define BLIST_SINGLELUN &t;0x010&t;/* Do not use LUNs in parallel */
DECL|macro|BLIST_NOTQ
mdefine_line|#define BLIST_NOTQ&t;&t;0x020&t;/* Buggy Tagged Command Queuing */
DECL|macro|BLIST_SPARSELUN
mdefine_line|#define BLIST_SPARSELUN &t;0x040&t;/* Non consecutive LUN numbering */
DECL|macro|BLIST_MAX5LUN
mdefine_line|#define BLIST_MAX5LUN&t;&t;0x080&t;/* Avoid LUNS &gt;= 5 */
DECL|macro|BLIST_ISROM
mdefine_line|#define BLIST_ISROM     &t;0x100&t;/* Treat as (removable) CD-ROM */
DECL|macro|BLIST_LARGELUN
mdefine_line|#define BLIST_LARGELUN&t;&t;0x200&t;/* LUNs past 7 on a SCSI-2 device */
DECL|macro|BLIST_INQUIRY_36
mdefine_line|#define BLIST_INQUIRY_36&t;0x400&t;/* override additional length field */
DECL|macro|BLIST_INQUIRY_58
mdefine_line|#define BLIST_INQUIRY_58&t;0x800&t;/* ... for broken inquiry responses */
multiline_comment|/*&n; * scsi_static_device_list: deprecated list of devices that require&n; * settings that differ from the default, includes black-listed (broken)&n; * devices. The entries here are added to the tail of scsi_dev_info_list&n; * via scsi_dev_info_list_init.&n; *&n; * Do not add to this list, use the command line or proc interface to add&n; * to the scsi_dev_info_list. This table will eventually go away.&n; */
DECL|variable|__initdata
r_struct
id|dev_info
id|scsi_static_device_list
(braket
)braket
id|__initdata
op_assign
(brace
multiline_comment|/*&n;&t; * The following devices are known not to tolerate a lun != 0 scan&n;&t; * for one reason or another. Some will respond to all luns,&n;&t; * others will lock up.&n;&t; */
(brace
l_string|&quot;Aashima&quot;
comma
l_string|&quot;IMAGERY 2400SP&quot;
comma
l_string|&quot;1.03&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;CHINON&quot;
comma
l_string|&quot;CD-ROM CDS-431&quot;
comma
l_string|&quot;H42&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;CHINON&quot;
comma
l_string|&quot;CD-ROM CDS-535&quot;
comma
l_string|&quot;Q14&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;DENON&quot;
comma
l_string|&quot;DRD-25X&quot;
comma
l_string|&quot;V&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;HITACHI&quot;
comma
l_string|&quot;DK312C&quot;
comma
l_string|&quot;CM81&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* responds to all lun */
(brace
l_string|&quot;HITACHI&quot;
comma
l_string|&quot;DK314C&quot;
comma
l_string|&quot;CR21&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* responds to all lun */
(brace
l_string|&quot;IMS&quot;
comma
l_string|&quot;CDD521/10&quot;
comma
l_string|&quot;2.06&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;XT-3280&quot;
comma
l_string|&quot;PR02&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;XT-4380S&quot;
comma
l_string|&quot;B3C&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;MXT-1240S&quot;
comma
l_string|&quot;I1.2&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;XT-4170S&quot;
comma
l_string|&quot;B5A&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;XT-8760S&quot;
comma
l_string|&quot;B7B&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;MEDIAVIS&quot;
comma
l_string|&quot;RENO CD-ROMX2A&quot;
comma
l_string|&quot;2.03&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* responds to all lun */
(brace
l_string|&quot;NEC&quot;
comma
l_string|&quot;CD-ROM DRIVE:841&quot;
comma
l_string|&quot;1.0&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;PHILIPS&quot;
comma
l_string|&quot;PCA80SC&quot;
comma
l_string|&quot;V4-2&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* responds to all lun */
(brace
l_string|&quot;RODIME&quot;
comma
l_string|&quot;RO3000S&quot;
comma
l_string|&quot;2.33&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;SUN&quot;
comma
l_string|&quot;SENA&quot;
comma
l_int|NULL
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* responds to all luns */
multiline_comment|/*&n;&t; * The following causes a failed REQUEST SENSE on lun 1 for&n;&t; * aha152x controller, which causes SCSI code to reset bus.&n;&t; */
(brace
l_string|&quot;SANYO&quot;
comma
l_string|&quot;CRD-250S&quot;
comma
l_string|&quot;1.20&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/*&n;&t; * The following causes a failed REQUEST SENSE on lun 1 for&n;&t; * aha152x controller, which causes SCSI code to reset bus.&n;&t; */
(brace
l_string|&quot;SEAGATE&quot;
comma
l_string|&quot;ST157N&quot;
comma
l_string|&quot;&bslash;004|j&quot;
comma
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;SEAGATE&quot;
comma
l_string|&quot;ST296&quot;
comma
l_string|&quot;921&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* responds to all lun */
(brace
l_string|&quot;SEAGATE&quot;
comma
l_string|&quot;ST1581&quot;
comma
l_string|&quot;6538&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* responds to all lun */
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-541&quot;
comma
l_string|&quot;4.3d&quot;
comma
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-55S&quot;
comma
l_string|&quot;1.0i&quot;
comma
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-561&quot;
comma
l_string|&quot;1.7x&quot;
comma
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-8012&quot;
comma
l_int|NULL
comma
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;TANDBERG&quot;
comma
l_string|&quot;TDC 3600&quot;
comma
l_string|&quot;U07&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;TEAC&quot;
comma
l_string|&quot;CD-R55S&quot;
comma
l_string|&quot;1.0H&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
multiline_comment|/*&n;&t; * The following causes a failed REQUEST SENSE on lun 1 for&n;&t; * seagate controller, which causes SCSI code to reset bus.&n;&t; */
(brace
l_string|&quot;TEAC&quot;
comma
l_string|&quot;CD-ROM&quot;
comma
l_string|&quot;1.06&quot;
comma
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;TEAC&quot;
comma
l_string|&quot;MT-2ST/45S2-27&quot;
comma
l_string|&quot;RV M&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* responds to all lun */
multiline_comment|/*&n;&t; * The following causes a failed REQUEST SENSE on lun 1 for&n;&t; * seagate controller, which causes SCSI code to reset bus.&n;&t; */
(brace
l_string|&quot;TEXEL&quot;
comma
l_string|&quot;CD-ROM&quot;
comma
l_string|&quot;1.06&quot;
comma
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;QUANTUM&quot;
comma
l_string|&quot;LPS525S&quot;
comma
l_string|&quot;3110&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;QUANTUM&quot;
comma
l_string|&quot;PD1225S&quot;
comma
l_string|&quot;3110&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;QUANTUM&quot;
comma
l_string|&quot;FIREBALL ST4.3S&quot;
comma
l_string|&quot;0F0C&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;MEDIAVIS&quot;
comma
l_string|&quot;CDR-H93MV&quot;
comma
l_string|&quot;1.31&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;SANKYO&quot;
comma
l_string|&quot;CP525&quot;
comma
l_string|&quot;6.64&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* causes failed REQ SENSE, extra reset */
(brace
l_string|&quot;HP&quot;
comma
l_string|&quot;C1750A&quot;
comma
l_string|&quot;3226&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* scanjet iic */
(brace
l_string|&quot;HP&quot;
comma
l_string|&quot;C1790A&quot;
comma
l_string|&quot;&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* scanjet iip */
(brace
l_string|&quot;HP&quot;
comma
l_string|&quot;C2500A&quot;
comma
l_string|&quot;&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* scanjet iicx */
(brace
l_string|&quot;YAMAHA&quot;
comma
l_string|&quot;CDR100&quot;
comma
l_string|&quot;1.00&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;YAMAHA&quot;
comma
l_string|&quot;CDR102&quot;
comma
l_string|&quot;1.00&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;YAMAHA&quot;
comma
l_string|&quot;CRW8424S&quot;
comma
l_string|&quot;1.0&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;YAMAHA&quot;
comma
l_string|&quot;CRW6416S&quot;
comma
l_string|&quot;1.0c&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;MITSUMI&quot;
comma
l_string|&quot;CD-R CR-2201CS&quot;
comma
l_string|&quot;6119&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;RELISYS&quot;
comma
l_string|&quot;Scorpio&quot;
comma
l_int|NULL
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* responds to all lun */
(brace
l_string|&quot;MICROTEK&quot;
comma
l_string|&quot;ScanMaker II&quot;
comma
l_string|&quot;5.61&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* responds to all lun */
(brace
l_string|&quot;NEC&quot;
comma
l_string|&quot;D3856&quot;
comma
l_string|&quot;0009&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/*&n;&t; * Other types of devices that have special flags.&n;&t; */
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-8001&quot;
comma
l_int|NULL
comma
id|BLIST_BORKEN
)brace
comma
(brace
l_string|&quot;TEXEL&quot;
comma
l_string|&quot;CD-ROM&quot;
comma
l_string|&quot;1.06&quot;
comma
id|BLIST_BORKEN
)brace
comma
(brace
l_string|&quot;IOMEGA&quot;
comma
l_string|&quot;Io20S         *F&quot;
comma
l_int|NULL
comma
id|BLIST_KEY
)brace
comma
(brace
l_string|&quot;INSITE&quot;
comma
l_string|&quot;Floptical   F*8I&quot;
comma
l_int|NULL
comma
id|BLIST_KEY
)brace
comma
(brace
l_string|&quot;INSITE&quot;
comma
l_string|&quot;I325VM&quot;
comma
l_int|NULL
comma
id|BLIST_KEY
)brace
comma
(brace
l_string|&quot;LASOUND&quot;
comma
l_string|&quot;CDX7405&quot;
comma
l_string|&quot;3.10&quot;
comma
id|BLIST_MAX5LUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;MICROP&quot;
comma
l_string|&quot;4110&quot;
comma
l_int|NULL
comma
id|BLIST_NOTQ
)brace
comma
(brace
l_string|&quot;NRC&quot;
comma
l_string|&quot;MBR-7&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;NRC&quot;
comma
l_string|&quot;MBR-7.4&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;REGAL&quot;
comma
l_string|&quot;CDC-4X&quot;
comma
l_int|NULL
comma
id|BLIST_MAX5LUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;NAKAMICH&quot;
comma
l_string|&quot;MJ-4.8S&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;NAKAMICH&quot;
comma
l_string|&quot;MJ-5.16S&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;PIONEER&quot;
comma
l_string|&quot;CD-ROM DRM-600&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;PIONEER&quot;
comma
l_string|&quot;CD-ROM DRM-602X&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;PIONEER&quot;
comma
l_string|&quot;CD-ROM DRM-604X&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;EMULEX&quot;
comma
l_string|&quot;MD21/S2     ESDI&quot;
comma
l_int|NULL
comma
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;CANON&quot;
comma
l_string|&quot;IPUBJD&quot;
comma
l_int|NULL
comma
id|BLIST_SPARSELUN
)brace
comma
(brace
l_string|&quot;nCipher&quot;
comma
l_string|&quot;Fastness Crypto&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;DEC&quot;
comma
l_string|&quot;HSG80&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;COMPAQ&quot;
comma
l_string|&quot;LOGICAL VOLUME&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;COMPAQ&quot;
comma
l_string|&quot;CR3500&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;NEC&quot;
comma
l_string|&quot;PD-1 ODX654P&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;MATSHITA&quot;
comma
l_string|&quot;PD-1&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;iomega&quot;
comma
l_string|&quot;jaz 1GB&quot;
comma
l_string|&quot;J.86&quot;
comma
id|BLIST_NOTQ
op_or
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;TOSHIBA&quot;
comma
l_string|&quot;CDROM&quot;
comma
l_int|NULL
comma
id|BLIST_ISROM
)brace
comma
(brace
l_string|&quot;TOSHIBA&quot;
comma
l_string|&quot;CD-ROM&quot;
comma
l_int|NULL
comma
id|BLIST_ISROM
)brace
comma
(brace
l_string|&quot;MegaRAID&quot;
comma
l_string|&quot;LD&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;DGC&quot;
comma
l_string|&quot;RAID&quot;
comma
l_int|NULL
comma
id|BLIST_SPARSELUN
)brace
comma
multiline_comment|/* Dell PV 650F, storage on LUN 0 */
(brace
l_string|&quot;DGC&quot;
comma
l_string|&quot;DISK&quot;
comma
l_int|NULL
comma
id|BLIST_SPARSELUN
)brace
comma
multiline_comment|/* Dell PV 650F, no storage on LUN 0 */
(brace
l_string|&quot;DELL&quot;
comma
l_string|&quot;PV660F&quot;
comma
l_int|NULL
comma
id|BLIST_SPARSELUN
)brace
comma
(brace
l_string|&quot;DELL&quot;
comma
l_string|&quot;PV660F   PSEUDO&quot;
comma
l_int|NULL
comma
id|BLIST_SPARSELUN
)brace
comma
(brace
l_string|&quot;DELL&quot;
comma
l_string|&quot;PSEUDO DEVICE .&quot;
comma
l_int|NULL
comma
id|BLIST_SPARSELUN
)brace
comma
multiline_comment|/* Dell PV 530F */
(brace
l_string|&quot;DELL&quot;
comma
l_string|&quot;PV530F&quot;
comma
l_int|NULL
comma
id|BLIST_SPARSELUN
)brace
comma
(brace
l_string|&quot;EMC&quot;
comma
l_string|&quot;SYMMETRIX&quot;
comma
l_int|NULL
comma
id|BLIST_SPARSELUN
op_or
id|BLIST_LARGELUN
op_or
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;HP&quot;
comma
l_string|&quot;A6189A&quot;
comma
l_int|NULL
comma
id|BLIST_SPARSELUN
op_or
id|BLIST_LARGELUN
)brace
comma
multiline_comment|/* HP VA7400 */
(brace
l_string|&quot;HP&quot;
comma
l_string|&quot;OPEN-&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
op_or
id|BLIST_LARGELUN
)brace
comma
multiline_comment|/* HP XP Arrays */
(brace
l_string|&quot;CMD&quot;
comma
l_string|&quot;CRA-7280&quot;
comma
l_int|NULL
comma
id|BLIST_SPARSELUN
)brace
comma
multiline_comment|/* CMD RAID Controller */
(brace
l_string|&quot;CNSI&quot;
comma
l_string|&quot;G7324&quot;
comma
l_int|NULL
comma
id|BLIST_SPARSELUN
)brace
comma
multiline_comment|/* Chaparral G7324 RAID */
(brace
l_string|&quot;CNSi&quot;
comma
l_string|&quot;G8324&quot;
comma
l_int|NULL
comma
id|BLIST_SPARSELUN
)brace
comma
multiline_comment|/* Chaparral G8324 RAID */
(brace
l_string|&quot;Zzyzx&quot;
comma
l_string|&quot;RocketStor 500S&quot;
comma
l_int|NULL
comma
id|BLIST_SPARSELUN
)brace
comma
(brace
l_string|&quot;Zzyzx&quot;
comma
l_string|&quot;RocketStor 2000&quot;
comma
l_int|NULL
comma
id|BLIST_SPARSELUN
)brace
comma
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;TSL&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
)brace
comma
multiline_comment|/* DDS3 &amp; DDS4 autoloaders */
(brace
l_string|&quot;DELL&quot;
comma
l_string|&quot;PERCRAID&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;HP&quot;
comma
l_string|&quot;NetRAID-4M&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;ADAPTEC&quot;
comma
l_string|&quot;AACRAID&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;ADAPTEC&quot;
comma
l_string|&quot;Adaptec 5400S&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;COMPAQ&quot;
comma
l_string|&quot;MSA1000&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;HP&quot;
comma
l_string|&quot;C1557A&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;IBM&quot;
comma
l_string|&quot;AuSaV1S2&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;FSC&quot;
comma
l_string|&quot;CentricStor&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
op_or
id|BLIST_LARGELUN
)brace
comma
(brace
l_string|&quot;DDN&quot;
comma
l_string|&quot;SAN DataDirector&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
)brace
comma
(brace
l_string|&quot;HITACHI&quot;
comma
l_string|&quot;DF400&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
)brace
comma
(brace
l_string|&quot;HITACHI&quot;
comma
l_string|&quot;DF500&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
)brace
comma
(brace
l_string|&quot;HITACHI&quot;
comma
l_string|&quot;DF600&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
)brace
comma
(brace
l_string|&quot;IBM&quot;
comma
l_string|&quot;ProFibre 4000R&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
op_or
id|BLIST_LARGELUN
)brace
comma
(brace
l_string|&quot;SUN&quot;
comma
l_string|&quot;T300&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
)brace
comma
(brace
l_string|&quot;SUN&quot;
comma
l_string|&quot;T4&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
)brace
comma
(brace
l_string|&quot;SGI&quot;
comma
l_string|&quot;RAID3&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
)brace
comma
(brace
l_string|&quot;SGI&quot;
comma
l_string|&quot;RAID5&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
)brace
comma
(brace
l_string|&quot;SGI&quot;
comma
l_string|&quot;TP9100&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
op_or
id|BLIST_LARGELUN
)brace
comma
(brace
l_string|&quot;SGI&quot;
comma
l_string|&quot;TP9300&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
op_or
id|BLIST_LARGELUN
)brace
comma
(brace
l_string|&quot;SGI&quot;
comma
l_string|&quot;TP9400&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
op_or
id|BLIST_LARGELUN
)brace
comma
(brace
l_string|&quot;SGI&quot;
comma
l_string|&quot;TP9500&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
op_or
id|BLIST_LARGELUN
)brace
comma
(brace
l_string|&quot;MYLEX&quot;
comma
l_string|&quot;DACARMRB&quot;
comma
l_string|&quot;*&quot;
comma
id|BLIST_SPARSELUN
op_or
id|BLIST_LARGELUN
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
)brace
comma
)brace
suffix:semicolon
DECL|macro|ALLOC_FAILURE_MSG
mdefine_line|#define ALLOC_FAILURE_MSG&t;KERN_ERR &quot;%s: Allocation failure during&quot; &bslash;&n;&t;&quot; SCSI scanning, some SCSI devices might not be configured&bslash;n&quot;
multiline_comment|/*&n; * Prefix values for the SCSI id&squot;s (stored in driverfs name field)&n; */
DECL|macro|SCSI_UID_SER_NUM
mdefine_line|#define SCSI_UID_SER_NUM &squot;S&squot;
DECL|macro|SCSI_UID_UNKNOWN
mdefine_line|#define SCSI_UID_UNKNOWN &squot;Z&squot;
multiline_comment|/*&n; * Return values of some of the scanning functions.&n; *&n; * SCSI_SCAN_NO_RESPONSE: no valid response received from the target, this&n; * includes allocation or general failures preventing IO from being sent.&n; *&n; * SCSI_SCAN_TARGET_PRESENT: target responded, but no device is available&n; * on the given LUN.&n; *&n; * SCSI_SCAN_LUN_PRESENT: target responded, and a device is available on a&n; * given LUN.&n; */
DECL|macro|SCSI_SCAN_NO_RESPONSE
mdefine_line|#define SCSI_SCAN_NO_RESPONSE&t;&t;0
DECL|macro|SCSI_SCAN_TARGET_PRESENT
mdefine_line|#define SCSI_SCAN_TARGET_PRESENT&t;1
DECL|macro|SCSI_SCAN_LUN_PRESENT
mdefine_line|#define SCSI_SCAN_LUN_PRESENT&t;&t;2
DECL|variable|scsi_null_device_strs
r_static
r_char
op_star
id|scsi_null_device_strs
op_assign
l_string|&quot;nullnullnullnull&quot;
suffix:semicolon
DECL|macro|MAX_SCSI_LUNS
mdefine_line|#define MAX_SCSI_LUNS&t;512
macro_line|#ifdef CONFIG_SCSI_MULTI_LUN
DECL|variable|max_scsi_luns
r_static
r_int
r_int
id|max_scsi_luns
op_assign
id|MAX_SCSI_LUNS
suffix:semicolon
macro_line|#else
DECL|variable|max_scsi_luns
r_static
r_int
r_int
id|max_scsi_luns
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
macro_line|#ifdef MODULE
id|MODULE_PARM
c_func
(paren
id|max_scsi_luns
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|max_scsi_luns
comma
l_string|&quot;last scsi LUN (should be between 1 and 2^32-1)&quot;
)paren
suffix:semicolon
macro_line|#else
DECL|function|scsi_luns_setup
r_static
r_int
id|__init
id|scsi_luns_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|get_option
c_func
(paren
op_amp
id|str
comma
op_amp
id|tmp
)paren
op_eq
l_int|1
)paren
(brace
id|max_scsi_luns
op_assign
id|tmp
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi_luns_setup: usage max_scsi_luns=n &quot;
l_string|&quot;(n should be between 1 and 2^32-1)&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|__setup
c_func
(paren
l_string|&quot;max_scsi_luns=&quot;
comma
id|scsi_luns_setup
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_SCSI_REPORT_LUNS
multiline_comment|/*&n; * max_scsi_report_luns: the maximum number of LUNS that will be&n; * returned from the REPORT LUNS command. 8 times this value must&n; * be allocated. In theory this could be up to an 8 byte value, but&n; * in practice, the maximum number of LUNs suppored by any device&n; * is about 16k.&n; */
DECL|variable|max_scsi_report_luns
r_static
r_int
r_int
id|max_scsi_report_luns
op_assign
l_int|128
suffix:semicolon
macro_line|#ifdef MODULE
id|MODULE_PARM
c_func
(paren
id|max_scsi_report_luns
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|max_scsi_report_luns
comma
l_string|&quot;REPORT LUNS maximum number of LUNS received (should be&quot;
l_string|&quot; between 1 and 16384)&quot;
)paren
suffix:semicolon
macro_line|#else
DECL|function|scsi_report_luns_setup
r_static
r_int
id|__init
id|scsi_report_luns_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|get_option
c_func
(paren
op_amp
id|str
comma
op_amp
id|tmp
)paren
op_eq
l_int|1
)paren
(brace
id|max_scsi_report_luns
op_assign
id|tmp
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi_report_luns_setup: usage&quot;
l_string|&quot; max_scsi_report_luns=n (n should be between 1&quot;
l_string|&quot; and 16384)&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|__setup
c_func
(paren
l_string|&quot;max_scsi_report_luns=&quot;
comma
id|scsi_report_luns_setup
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
multiline_comment|/**&n; * scsi_unlock_floptical - unlock device via a special MODE SENSE command&n; * @sreq:&t;used to send the command&n; * @result:&t;area to store the result of the MODE SENSE&n; *&n; * Description:&n; *     Send a vendor specific MODE SENSE (not a MODE SELECT) command using&n; *     @sreq to unlock a device, storing the (unused) results into result.&n; *     Called for BLIST_KEY devices.&n; **/
DECL|function|scsi_unlock_floptical
r_static
r_void
id|scsi_unlock_floptical
c_func
(paren
id|Scsi_Request
op_star
id|sreq
comma
r_int
r_char
op_star
id|result
)paren
(brace
r_int
r_char
id|scsi_cmd
(braket
id|MAX_COMMAND_SIZE
)braket
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;scsi: unlocking floptical drive&bslash;n&quot;
)paren
suffix:semicolon
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|MODE_SENSE
suffix:semicolon
id|scsi_cmd
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|2
)braket
op_assign
l_int|0x2e
suffix:semicolon
id|scsi_cmd
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
l_int|0x2a
suffix:semicolon
multiline_comment|/* size */
id|scsi_cmd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_cmd_len
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_data_direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
id|scsi_wait_req
c_func
(paren
id|sreq
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|result
comma
l_int|0x2a
multiline_comment|/* size */
comma
id|SCSI_TIMEOUT
comma
l_int|3
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * print_inquiry - printk the inquiry information&n; * @inq_result:&t;printk this SCSI INQUIRY&n; *&n; * Description:&n; *     printk the vendor, model, and other information found in the&n; *     INQUIRY data in @inq_result.&n; *&n; * Notes:&n; *     Remove this, and replace with a hotplug event that logs any&n; *     relevant information.&n; **/
DECL|function|print_inquiry
r_static
r_void
id|print_inquiry
c_func
(paren
r_int
r_char
op_star
id|inq_result
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;  Vendor: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|8
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|inq_result
(braket
id|i
)braket
op_ge
l_int|0x20
op_logical_and
id|i
OL
id|inq_result
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|inq_result
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  Model: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|16
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|inq_result
(braket
id|i
)braket
op_ge
l_int|0x20
op_logical_and
id|i
OL
id|inq_result
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|inq_result
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  Rev: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|32
suffix:semicolon
id|i
OL
l_int|36
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|inq_result
(braket
id|i
)braket
op_ge
l_int|0x20
op_logical_and
id|i
OL
id|inq_result
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|inq_result
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|i
op_assign
id|inq_result
(braket
l_int|0
)braket
op_amp
l_int|0x1f
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;  Type:   %s &quot;
comma
id|i
OL
id|MAX_SCSI_DEVICE_CODE
ques
c_cond
id|scsi_device_types
(braket
id|i
)braket
suffix:colon
l_string|&quot;Unknown          &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;                 ANSI SCSI revision: %02x&quot;
comma
id|inq_result
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inq_result
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
op_eq
l_int|1
op_logical_and
(paren
id|inq_result
(braket
l_int|3
)braket
op_amp
l_int|0x0f
)paren
op_eq
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot; CCS&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_alloc_sdev - allocate and setup a Scsi_Device&n; *&n; * Description:&n; *     Allocate, initialize for io, and return a pointer to a Scsi_Device.&n; *     Stores the @shost, @channel, @id, and @lun in the Scsi_Device, and&n; *     adds Scsi_Device to the appropriate list.&n; *&n; * Return value:&n; *     Scsi_Device pointer, or NULL on failure.&n; **/
DECL|function|scsi_alloc_sdev
r_static
r_struct
id|scsi_device
op_star
id|scsi_alloc_sdev
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
comma
r_struct
id|request_queue
op_star
op_star
id|q
comma
id|uint
id|channel
comma
id|uint
id|id
comma
id|uint
id|lun
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
comma
op_star
id|device
suffix:semicolon
id|sdev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|sdev
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sdev
)paren
r_goto
id|out
suffix:semicolon
id|memset
c_func
(paren
id|sdev
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|sdev
)paren
)paren
suffix:semicolon
id|sdev-&gt;vendor
op_assign
id|scsi_null_device_strs
suffix:semicolon
id|sdev-&gt;model
op_assign
id|scsi_null_device_strs
suffix:semicolon
id|sdev-&gt;rev
op_assign
id|scsi_null_device_strs
suffix:semicolon
id|sdev-&gt;host
op_assign
id|shost
suffix:semicolon
id|sdev-&gt;id
op_assign
id|id
suffix:semicolon
id|sdev-&gt;lun
op_assign
id|lun
suffix:semicolon
id|sdev-&gt;channel
op_assign
id|channel
suffix:semicolon
id|sdev-&gt;online
op_assign
id|TRUE
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sdev-&gt;siblings
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sdev-&gt;same_target_siblings
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sdev-&gt;cmd_list
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|sdev-&gt;list_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Some low level driver could use device-&gt;type&n;&t; */
id|sdev-&gt;type
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Assume that the device will have handshaking problems,&n;&t; * and then fix this field later if it turns out it&n;&t; * doesn&squot;t&n;&t; */
id|sdev-&gt;borken
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q
op_logical_or
op_star
id|q
op_eq
l_int|NULL
)paren
(brace
id|sdev-&gt;request_queue
op_assign
id|scsi_alloc_queue
c_func
(paren
id|shost
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sdev-&gt;request_queue
)paren
r_goto
id|out_free_dev
suffix:semicolon
)brace
r_else
(brace
id|sdev-&gt;request_queue
op_assign
op_star
id|q
suffix:semicolon
op_star
id|q
op_assign
l_int|NULL
suffix:semicolon
)brace
id|sdev-&gt;request_queue-&gt;queuedata
op_assign
id|sdev
suffix:semicolon
id|scsi_adjust_queue_depth
c_func
(paren
id|sdev
comma
l_int|0
comma
id|sdev-&gt;host-&gt;cmd_per_lun
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|sdev-&gt;scpnt_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shost-&gt;hostt-&gt;slave_alloc
)paren
(brace
r_if
c_cond
(paren
id|shost-&gt;hostt
op_member_access_from_pointer
id|slave_alloc
c_func
(paren
id|sdev
)paren
)paren
r_goto
id|out_free_queue
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If there are any same target siblings, add this to the&n;&t; * sibling list&n;&t; */
id|list_for_each_entry
c_func
(paren
id|device
comma
op_amp
id|shost-&gt;my_devices
comma
id|siblings
)paren
(brace
r_if
c_cond
(paren
id|device-&gt;id
op_eq
id|sdev-&gt;id
op_logical_and
id|device-&gt;channel
op_eq
id|sdev-&gt;channel
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
id|sdev-&gt;same_target_siblings
comma
op_amp
id|device-&gt;same_target_siblings
)paren
suffix:semicolon
id|sdev-&gt;scsi_level
op_assign
id|device-&gt;scsi_level
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If there wasn&squot;t another lun already configured at this&n;&t; * target, then default this device to SCSI_2 until we&n;&t; * know better&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sdev-&gt;scsi_level
)paren
id|sdev-&gt;scsi_level
op_assign
id|SCSI_2
suffix:semicolon
multiline_comment|/*&n;&t; * Add it to the end of the shost-&gt;my_devices list.&n;&t; */
id|list_add_tail
c_func
(paren
op_amp
id|sdev-&gt;siblings
comma
op_amp
id|shost-&gt;my_devices
)paren
suffix:semicolon
r_return
id|sdev
suffix:semicolon
id|out_free_queue
suffix:colon
r_if
c_cond
(paren
id|q
op_logical_and
id|sdev-&gt;request_queue
)paren
(brace
op_star
id|q
op_assign
id|sdev-&gt;request_queue
suffix:semicolon
id|sdev-&gt;request_queue
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sdev-&gt;request_queue
)paren
id|scsi_free_queue
c_func
(paren
id|sdev-&gt;request_queue
)paren
suffix:semicolon
id|out_free_dev
suffix:colon
id|kfree
c_func
(paren
id|sdev
)paren
suffix:semicolon
id|out
suffix:colon
id|printk
c_func
(paren
id|ALLOC_FAILURE_MSG
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_free_sdev - cleanup and free a Scsi_Device&n; * @sdev:&t;cleanup and free this Scsi_Device&n; *&n; * Description:&n; *     Undo the actions in scsi_alloc_sdev, including removing @sdev from&n; *     the list, and freeing @sdev.&n; **/
DECL|function|scsi_free_sdev
r_static
r_void
id|scsi_free_sdev
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|sdev-&gt;siblings
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|sdev-&gt;same_target_siblings
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;request_queue
)paren
id|scsi_free_queue
c_func
(paren
id|sdev-&gt;request_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;host-&gt;hostt-&gt;slave_destroy
)paren
id|sdev-&gt;host-&gt;hostt
op_member_access_from_pointer
id|slave_destroy
c_func
(paren
id|sdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;inquiry
)paren
id|kfree
c_func
(paren
id|sdev-&gt;inquiry
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sdev
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_get_evpd_page - get a list of supported vpd pages&n; * @sdev:&t;Scsi_Device to send an INQUIRY VPD&n; * @sreq:&t;Scsi_Request associated with @sdev&n; *&n; * Description:&n; *     Get SCSI INQUIRY Vital Product Data page 0 - a list of supported&n; *     VPD pages.&n; *&n; * Return:&n; *     A pointer to data containing the results on success, else NULL.&n; **/
DECL|function|scsi_get_evpd_page
r_int
r_char
op_star
id|scsi_get_evpd_page
c_func
(paren
id|Scsi_Device
op_star
id|sdev
comma
id|Scsi_Request
op_star
id|sreq
)paren
(brace
r_int
r_char
op_star
id|evpd_page
suffix:semicolon
r_int
r_char
id|scsi_cmd
(braket
id|MAX_COMMAND_SIZE
)braket
suffix:semicolon
r_int
id|max_lgth
op_assign
l_int|255
suffix:semicolon
id|retry
suffix:colon
id|evpd_page
op_assign
id|kmalloc
c_func
(paren
id|max_lgth
comma
id|GFP_ATOMIC
op_or
(paren
id|sdev-&gt;host-&gt;unchecked_isa_dma
)paren
ques
c_cond
id|GFP_DMA
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|evpd_page
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi scan: Allocation failure identifying&quot;
l_string|&quot; host %d channel %d id %d lun %d, device might be&quot;
l_string|&quot; improperly identified.&bslash;n&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|scsi_cmd
comma
l_int|0
comma
id|MAX_COMMAND_SIZE
)paren
suffix:semicolon
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|INQUIRY
suffix:semicolon
id|scsi_cmd
(braket
l_int|1
)braket
op_assign
l_int|0x01
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
id|max_lgth
suffix:semicolon
id|sreq-&gt;sr_cmd_len
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_sense_buffer
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_sense_buffer
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_data_direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
id|scsi_wait_req
c_func
(paren
id|sreq
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|evpd_page
comma
id|max_lgth
comma
id|SCSI_TIMEOUT
op_plus
l_int|4
op_star
id|HZ
comma
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sreq-&gt;sr_result
)paren
(brace
id|kfree
c_func
(paren
id|evpd_page
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * check to see if response was truncated&n;&t; */
r_if
c_cond
(paren
id|evpd_page
(braket
l_int|3
)braket
OG
id|max_lgth
)paren
(brace
id|max_lgth
op_assign
id|evpd_page
(braket
l_int|3
)braket
op_plus
l_int|4
suffix:semicolon
id|kfree
c_func
(paren
id|evpd_page
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Some ill behaved devices return the standard inquiry here&n;&t; * rather than the evpd data, snoop the data to verify.&n;&t; */
r_if
c_cond
(paren
id|evpd_page
(braket
l_int|3
)braket
OG
l_int|16
)paren
(brace
multiline_comment|/*&n;&t;&t; * If the vendor id appears in the evpd page assume the&n;&t;&t; * page is invalid.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
op_amp
id|evpd_page
(braket
l_int|8
)braket
comma
id|sdev-&gt;vendor
comma
l_int|8
)paren
)paren
(brace
id|kfree
c_func
(paren
id|evpd_page
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
id|evpd_page
suffix:semicolon
)brace
multiline_comment|/*&n; * INQUIRY VPD page 0x83 identifier descriptor related values. Reference the&n; * SCSI Primary Commands specification for details.&n; *&n; * XXX The following defines should be in scsi.h&n; */
multiline_comment|/*&n; * id type values of id descriptors. These are assumed to fit in 4 bits,&n; * else the code using hex_str[id_type] needs modification.&n; */
DECL|macro|SCSI_ID_VENDOR_SPECIFIC
mdefine_line|#define SCSI_ID_VENDOR_SPECIFIC&t;0
DECL|macro|SCSI_ID_T10_VENDOR
mdefine_line|#define SCSI_ID_T10_VENDOR&t;1
DECL|macro|SCSI_ID_EUI_64
mdefine_line|#define SCSI_ID_EUI_64&t;&t;2
DECL|macro|SCSI_ID_NAA
mdefine_line|#define SCSI_ID_NAA&t;&t;3
multiline_comment|/*&n; * Supported NAA values. These fit in 4 bits, so the don&squot;t care value&n; * cannot conflict with real values.&n; *&n; */
DECL|macro|SCSI_ID_NAA_DONT_CARE
mdefine_line|#define&t;SCSI_ID_NAA_DONT_CARE&t;&t;0xff
DECL|macro|SCSI_ID_NAA_IEEE_REG
mdefine_line|#define&t;SCSI_ID_NAA_IEEE_REG&t;&t;5
DECL|macro|SCSI_ID_NAA_IEEE_REG_EXTENDED
mdefine_line|#define&t;SCSI_ID_NAA_IEEE_REG_EXTENDED&t;6
multiline_comment|/*&n; * Supported Code Set values.&n; */
DECL|macro|SCSI_ID_BINARY
mdefine_line|#define&t;SCSI_ID_BINARY&t;1
DECL|macro|SCSI_ID_ASCII
mdefine_line|#define&t;SCSI_ID_ASCII&t;2
multiline_comment|/*&n; * Use a priority based list of id, naa, and binary/ascii for the&n; * identifier descriptor in VPD page 0x83.&n; *&n; * Brute force search for a match starting with the first value in&n; * id_search_list. This is not a performance issue, since there&n; * is normally one or some small number of descriptors.&n; */
DECL|struct|scsi_id_search_values
r_struct
id|scsi_id_search_values
(brace
DECL|member|id_type
r_int
id|id_type
suffix:semicolon
DECL|member|naa_type
r_int
id|naa_type
suffix:semicolon
DECL|member|code_set
r_int
id|code_set
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|id_search_list
r_static
r_const
r_struct
id|scsi_id_search_values
id|id_search_list
(braket
)braket
op_assign
(brace
(brace
id|SCSI_ID_NAA
comma
id|SCSI_ID_NAA_IEEE_REG_EXTENDED
comma
id|SCSI_ID_BINARY
)brace
comma
(brace
id|SCSI_ID_NAA
comma
id|SCSI_ID_NAA_IEEE_REG_EXTENDED
comma
id|SCSI_ID_ASCII
)brace
comma
(brace
id|SCSI_ID_NAA
comma
id|SCSI_ID_NAA_IEEE_REG
comma
id|SCSI_ID_BINARY
)brace
comma
(brace
id|SCSI_ID_NAA
comma
id|SCSI_ID_NAA_IEEE_REG
comma
id|SCSI_ID_ASCII
)brace
comma
multiline_comment|/*&n;&t; * Devices already exist using NAA values that are now marked&n;&t; * reserved. These should not conflict with other values, or it is&n;&t; * a bug in the device. As long as we find the IEEE extended one&n;&t; * first, we really don&squot;t care what other ones are used. Using&n;&t; * don&squot;t care here means that a device that returns multiple&n;&t; * non-IEEE descriptors in a random order will get different&n;&t; * names.&n;&t; */
(brace
id|SCSI_ID_NAA
comma
id|SCSI_ID_NAA_DONT_CARE
comma
id|SCSI_ID_BINARY
)brace
comma
(brace
id|SCSI_ID_NAA
comma
id|SCSI_ID_NAA_DONT_CARE
comma
id|SCSI_ID_ASCII
)brace
comma
(brace
id|SCSI_ID_EUI_64
comma
id|SCSI_ID_NAA_DONT_CARE
comma
id|SCSI_ID_BINARY
)brace
comma
(brace
id|SCSI_ID_EUI_64
comma
id|SCSI_ID_NAA_DONT_CARE
comma
id|SCSI_ID_ASCII
)brace
comma
(brace
id|SCSI_ID_T10_VENDOR
comma
id|SCSI_ID_NAA_DONT_CARE
comma
id|SCSI_ID_BINARY
)brace
comma
(brace
id|SCSI_ID_T10_VENDOR
comma
id|SCSI_ID_NAA_DONT_CARE
comma
id|SCSI_ID_ASCII
)brace
comma
(brace
id|SCSI_ID_VENDOR_SPECIFIC
comma
id|SCSI_ID_NAA_DONT_CARE
comma
id|SCSI_ID_BINARY
)brace
comma
(brace
id|SCSI_ID_VENDOR_SPECIFIC
comma
id|SCSI_ID_NAA_DONT_CARE
comma
id|SCSI_ID_ASCII
)brace
comma
)brace
suffix:semicolon
multiline_comment|/**&n; * scsi_check_fill_deviceid - check the id and if OK fill it&n; * @sdev:&t;device to use for error messages&n; * @id_page:&t;id descriptor for INQUIRY VPD DEVICE ID, page 0x83&n; * @name:&t;store the id in name (of size DEVICE_NAME_SIZE &gt; 26)&n; * @id_search:&t;store if the id_page matches these values&n; *&n; * Description:&n; *     Check if @id_page matches the @id_search, if so store an id (uid)&n; *     into name, that is all zero on entrance.&n; *&n; * Return:&n; *     0: Success&n; *     1: No match&n; **/
DECL|function|scsi_check_fill_deviceid
r_static
r_int
id|scsi_check_fill_deviceid
c_func
(paren
id|Scsi_Device
op_star
id|sdev
comma
r_char
op_star
id|id_page
comma
r_char
op_star
id|name
comma
r_const
r_struct
id|scsi_id_search_values
op_star
id|id_search
)paren
(brace
r_static
r_const
r_char
id|hex_str
(braket
)braket
op_assign
l_string|&quot;0123456789abcdef&quot;
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
multiline_comment|/*&n;&t; * ASSOCIATION must be with the device (value 0)&n;&t; */
r_if
c_cond
(paren
(paren
id|id_page
(braket
l_int|1
)braket
op_amp
l_int|0x30
)paren
op_ne
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id_page
(braket
l_int|1
)braket
op_amp
l_int|0x0f
)paren
op_ne
id|id_search-&gt;id_type
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Possibly check NAA sub-type.&n;&t; */
r_if
c_cond
(paren
(paren
id|id_search-&gt;naa_type
op_ne
id|SCSI_ID_NAA_DONT_CARE
)paren
op_logical_and
(paren
id|id_search-&gt;naa_type
op_ne
(paren
id|id_page
(braket
l_int|4
)braket
op_amp
l_int|0xf0
)paren
op_rshift
l_int|4
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check for matching code set - ASCII or BINARY.&n;&t; */
r_if
c_cond
(paren
(paren
id|id_page
(braket
l_int|0
)braket
op_amp
l_int|0x0f
)paren
op_ne
id|id_search-&gt;code_set
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * All OK - store ID&n;&t; */
id|name
(braket
l_int|0
)braket
op_assign
id|hex_str
(braket
id|id_search-&gt;id_type
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Prepend the vendor and model before the id, since the id&n;&t; * might not be unique across all vendors and models.&n;&t; * The same code is used below, with a different size.&n;&t; */
r_if
c_cond
(paren
id|id_search-&gt;id_type
op_eq
id|SCSI_ID_VENDOR_SPECIFIC
)paren
(brace
id|strncat
c_func
(paren
id|name
comma
id|sdev-&gt;vendor
comma
l_int|8
)paren
suffix:semicolon
id|strncat
c_func
(paren
id|name
comma
id|sdev-&gt;model
comma
l_int|16
)paren
suffix:semicolon
)brace
id|i
op_assign
l_int|4
suffix:semicolon
id|j
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id_page
(braket
l_int|0
)braket
op_amp
l_int|0x0f
)paren
op_eq
id|SCSI_ID_ASCII
)paren
(brace
multiline_comment|/*&n;&t;&t; * ASCII descriptor.&n;&t;&t; */
r_while
c_loop
(paren
id|i
OL
l_int|4
op_plus
id|id_page
(braket
l_int|3
)braket
op_logical_and
id|j
OL
id|DEVICE_NAME_SIZE
op_minus
l_int|1
)paren
id|name
(braket
id|j
op_increment
)braket
op_assign
id|id_page
(braket
id|i
op_increment
)braket
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Binary descriptor, convert to ASCII, using two bytes of&n;&t;&t; * ASCII for each byte in the id_page.&n;&t;&t; */
r_while
c_loop
(paren
id|i
OL
l_int|4
op_plus
id|id_page
(braket
l_int|3
)braket
op_logical_and
id|j
OL
id|DEVICE_NAME_SIZE
op_minus
l_int|2
)paren
(brace
id|name
(braket
id|j
op_increment
)braket
op_assign
id|hex_str
(braket
(paren
id|id_page
(braket
id|i
)braket
op_amp
l_int|0xf0
)paren
op_rshift
l_int|4
)braket
suffix:semicolon
id|name
(braket
id|j
op_increment
)braket
op_assign
id|hex_str
(braket
id|id_page
(braket
id|i
)braket
op_amp
l_int|0x0f
)braket
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_get_deviceid - get a device id using INQUIRY VPD page 0x83&n; * @sdev:&t;get the identifer of this device&n; * @sreq:&t;Scsi_Requeset associated with @sdev&n; *&n; * Description:&n; *     Try to get an id (serial number) for device @sdev using a SCSI&n; *     Vital Product Data page 0x83 (device id).&n; *&n; * Return:&n; *     0: Failure&n; *     1: Success&n; **/
DECL|function|scsi_get_deviceid
r_static
r_int
id|scsi_get_deviceid
c_func
(paren
id|Scsi_Device
op_star
id|sdev
comma
id|Scsi_Request
op_star
id|sreq
)paren
(brace
r_int
r_char
op_star
id|id_page
suffix:semicolon
r_int
r_char
id|scsi_cmd
(braket
id|MAX_COMMAND_SIZE
)braket
suffix:semicolon
r_int
id|id_idx
comma
id|scnt
comma
id|ret
suffix:semicolon
r_int
id|max_lgth
op_assign
l_int|255
suffix:semicolon
id|retry
suffix:colon
id|id_page
op_assign
id|kmalloc
c_func
(paren
id|max_lgth
comma
id|GFP_ATOMIC
op_or
(paren
id|sdev-&gt;host-&gt;unchecked_isa_dma
)paren
ques
c_cond
id|GFP_DMA
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|id_page
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi scan: Allocation failure identifying&quot;
l_string|&quot; host %d channel %d id %d lun %d, device might be&quot;
l_string|&quot; improperly identified.&bslash;n&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|memset
c_func
(paren
id|scsi_cmd
comma
l_int|0
comma
id|MAX_COMMAND_SIZE
)paren
suffix:semicolon
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|INQUIRY
suffix:semicolon
id|scsi_cmd
(braket
l_int|1
)braket
op_assign
l_int|0x01
suffix:semicolon
id|scsi_cmd
(braket
l_int|2
)braket
op_assign
l_int|0x83
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
id|max_lgth
suffix:semicolon
id|sreq-&gt;sr_cmd_len
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_sense_buffer
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_sense_buffer
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_data_direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
id|scsi_wait_req
c_func
(paren
id|sreq
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|id_page
comma
id|max_lgth
comma
id|SCSI_TIMEOUT
op_plus
l_int|4
op_star
id|HZ
comma
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sreq-&gt;sr_result
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_goto
id|leave
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * check to see if response was truncated&n;&t; */
r_if
c_cond
(paren
id|id_page
(braket
l_int|3
)braket
OG
id|max_lgth
)paren
(brace
id|max_lgth
op_assign
id|id_page
(braket
l_int|3
)braket
op_plus
l_int|4
suffix:semicolon
id|kfree
c_func
(paren
id|id_page
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Search for a match in the prioritized id_search_list.&n;&t; */
r_for
c_loop
(paren
id|id_idx
op_assign
l_int|0
suffix:semicolon
id|id_idx
OL
id|ARRAY_SIZE
c_func
(paren
id|id_search_list
)paren
suffix:semicolon
id|id_idx
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * Examine each descriptor returned. There is normally only&n;&t;&t; * one or a small number of descriptors.&n;&t;&t; */
r_for
c_loop
(paren
id|scnt
op_assign
l_int|4
suffix:semicolon
id|scnt
op_le
id|id_page
(braket
l_int|3
)braket
op_plus
l_int|3
suffix:semicolon
id|scnt
op_add_assign
id|id_page
(braket
id|scnt
op_plus
l_int|3
)braket
op_plus
l_int|4
)paren
(brace
r_if
c_cond
(paren
(paren
id|scsi_check_fill_deviceid
c_func
(paren
id|sdev
comma
op_amp
id|id_page
(braket
id|scnt
)braket
comma
id|sdev-&gt;sdev_driverfs_dev.name
comma
op_amp
id|id_search_list
(braket
id|id_idx
)braket
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi scan: host %d channel %d id %d lun %d&quot;
l_string|&quot; used id desc %d/%d/%d&bslash;n&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
comma
id|id_search_list
(braket
id|id_idx
)braket
dot
id|id_type
comma
id|id_search_list
(braket
id|id_idx
)braket
dot
id|naa_type
comma
id|id_search_list
(braket
id|id_idx
)braket
dot
id|code_set
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
r_goto
id|leave
suffix:semicolon
)brace
r_else
(brace
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi scan: host %d channel %d id %d lun %d&quot;
l_string|&quot; no match/error id desc %d/%d/%d&bslash;n&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
comma
id|id_search_list
(braket
id|id_idx
)braket
dot
id|id_type
comma
id|id_search_list
(braket
id|id_idx
)braket
dot
id|naa_type
comma
id|id_search_list
(braket
id|id_idx
)braket
dot
id|code_set
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * scsi_check_fill_deviceid can fill the first&n;&t;&t;&t; * byte of name with a non-zero value, reset it.&n;&t;&t;&t; */
id|sdev-&gt;sdev_driverfs_dev.name
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
)brace
id|ret
op_assign
l_int|0
suffix:semicolon
id|leave
suffix:colon
id|kfree
c_func
(paren
id|id_page
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_get_serialnumber - get a serial number using INQUIRY page 0x80&n; * @sdev:&t;get the serial number of this device&n; * @sreq:&t;Scsi_Requeset associated with @sdev&n; *&n; * Description:&n; *     Send a SCSI INQUIRY page 0x80 to @sdev to get a serial number.&n; *&n; * Return:&n; *     0: Failure&n; *     1: Success&n; **/
DECL|function|scsi_get_serialnumber
r_int
id|scsi_get_serialnumber
c_func
(paren
id|Scsi_Device
op_star
id|sdev
comma
id|Scsi_Request
op_star
id|sreq
)paren
(brace
r_int
r_char
op_star
id|serialnumber_page
suffix:semicolon
r_int
r_char
id|scsi_cmd
(braket
id|MAX_COMMAND_SIZE
)braket
suffix:semicolon
r_const
r_int
id|max_lgth
op_assign
l_int|255
suffix:semicolon
r_int
id|len
suffix:semicolon
id|serialnumber_page
op_assign
id|kmalloc
c_func
(paren
id|max_lgth
comma
id|GFP_ATOMIC
op_or
(paren
id|sdev-&gt;host-&gt;unchecked_isa_dma
)paren
ques
c_cond
id|GFP_DMA
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|serialnumber_page
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi scan: Allocation failure identifying&quot;
l_string|&quot; host %d channel %d id %d lun %d, device might be&quot;
l_string|&quot; improperly identified.&bslash;n&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|memset
c_func
(paren
id|scsi_cmd
comma
l_int|0
comma
id|MAX_COMMAND_SIZE
)paren
suffix:semicolon
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|INQUIRY
suffix:semicolon
id|scsi_cmd
(braket
l_int|1
)braket
op_assign
l_int|0x01
suffix:semicolon
id|scsi_cmd
(braket
l_int|2
)braket
op_assign
l_int|0x80
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
id|max_lgth
suffix:semicolon
id|sreq-&gt;sr_cmd_len
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_sense_buffer
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_sense_buffer
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_data_direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
id|scsi_wait_req
c_func
(paren
id|sreq
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|serialnumber_page
comma
id|max_lgth
comma
id|SCSI_TIMEOUT
op_plus
l_int|4
op_star
id|HZ
comma
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sreq-&gt;sr_result
)paren
r_goto
id|leave
suffix:semicolon
multiline_comment|/*&n;&t; * a check to see if response was truncated is superfluous,&n;&t; * since serialnumber_page[3] cannot be larger than 255&n;&t; */
id|sdev-&gt;sdev_driverfs_dev.name
(braket
l_int|0
)braket
op_assign
id|SCSI_UID_SER_NUM
suffix:semicolon
id|strncat
c_func
(paren
id|sdev-&gt;sdev_driverfs_dev.name
comma
id|sdev-&gt;vendor
comma
l_int|8
)paren
suffix:semicolon
id|strncat
c_func
(paren
id|sdev-&gt;sdev_driverfs_dev.name
comma
id|sdev-&gt;model
comma
l_int|16
)paren
suffix:semicolon
id|len
op_assign
id|serialnumber_page
(braket
l_int|3
)braket
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|DEVICE_NAME_SIZE
op_minus
l_int|26
)paren
id|len
op_assign
id|DEVICE_NAME_SIZE
op_minus
l_int|26
suffix:semicolon
id|strncat
c_func
(paren
id|sdev-&gt;sdev_driverfs_dev.name
comma
op_amp
id|serialnumber_page
(braket
l_int|4
)braket
comma
id|len
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|serialnumber_page
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
id|leave
suffix:colon
id|memset
c_func
(paren
id|sdev-&gt;sdev_driverfs_dev.name
comma
l_int|0
comma
id|DEVICE_NAME_SIZE
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|serialnumber_page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_get_default_name - get a default name&n; * @sdev:&t;get a default name for this device&n; *&n; * Description:&n; *     Set the name of @sdev (of size DEVICE_NAME_SIZE &gt; 29) to the&n; *     concatenation of the vendor, model, and revision found in @sdev.&n; *&n; * Return:&n; *     1: Success&n; **/
DECL|function|scsi_get_default_name
r_int
id|scsi_get_default_name
c_func
(paren
id|Scsi_Device
op_star
id|sdev
)paren
(brace
id|sdev-&gt;sdev_driverfs_dev.name
(braket
l_int|0
)braket
op_assign
id|SCSI_UID_UNKNOWN
suffix:semicolon
id|strncpy
c_func
(paren
op_amp
id|sdev-&gt;sdev_driverfs_dev.name
(braket
l_int|1
)braket
comma
id|sdev-&gt;vendor
comma
l_int|8
)paren
suffix:semicolon
id|strncat
c_func
(paren
id|sdev-&gt;sdev_driverfs_dev.name
comma
id|sdev-&gt;model
comma
l_int|16
)paren
suffix:semicolon
id|strncat
c_func
(paren
id|sdev-&gt;sdev_driverfs_dev.name
comma
id|sdev-&gt;rev
comma
l_int|4
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_load_identifier:&n; * @sdev:&t;get an identifier (name) of this device&n; * @sreq:&t;Scsi_Requeset associated with @sdev&n; *&n; * Description:&n; *     Determine what INQUIRY pages are supported by @sdev, and try the&n; *     different pages until we get an identifier, or no other pages are&n; *     left. Start with page 0x83 (device id) and then try page 0x80&n; *     (serial number). If neither of these pages gets an id, use the&n; *     default naming convention.&n; *&n; *     The first character of sdev_driverfs_dev.name is SCSI_UID_SER_NUM&n; *     (S) if we used page 0x80, SCSI_UID_UNKNOWN (Z) if we used the&n; *     default name, otherwise it starts with the page 0x83 id type&n; *     (see the SCSI Primary Commands specification for details).&n; *&n; * Notes:&n; *     If a device returns the same serial number for different LUNs or&n; *     even for different LUNs on different devices, special handling must&n; *     be added to get an id, or a new black list flag must be added (so&n; *     we use the default name, or add a way to prefix the id/name with&n; *     SCSI_UID_UNKNOWN - and change the define to something meaningful&n; *     like SCSI_UID_NOT_UNIQUE). Complete user level scanning would be&n; *     nice for such devices, so we do not need device specific code in&n; *     the kernel.&n; **/
DECL|function|scsi_load_identifier
r_static
r_void
id|scsi_load_identifier
c_func
(paren
id|Scsi_Device
op_star
id|sdev
comma
id|Scsi_Request
op_star
id|sreq
)paren
(brace
r_int
r_char
op_star
id|evpd_page
op_assign
l_int|NULL
suffix:semicolon
r_int
id|cnt
suffix:semicolon
id|memset
c_func
(paren
id|sdev-&gt;sdev_driverfs_dev.name
comma
l_int|0
comma
id|DEVICE_NAME_SIZE
)paren
suffix:semicolon
id|evpd_page
op_assign
id|scsi_get_evpd_page
c_func
(paren
id|sdev
comma
id|sreq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|evpd_page
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * try to obtain serial number anyway&n;&t;&t; */
(paren
r_void
)paren
id|scsi_get_serialnumber
c_func
(paren
id|sdev
comma
id|sreq
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * XXX search high to low, since the pages are lowest to&n;&t;&t; * highest - page 0x83 will be after page 0x80.&n;&t;&t; */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|4
suffix:semicolon
id|cnt
op_le
id|evpd_page
(braket
l_int|3
)braket
op_plus
l_int|3
suffix:semicolon
id|cnt
op_increment
)paren
r_if
c_cond
(paren
id|evpd_page
(braket
id|cnt
)braket
op_eq
l_int|0x83
)paren
r_if
c_cond
(paren
id|scsi_get_deviceid
c_func
(paren
id|sdev
comma
id|sreq
)paren
)paren
r_goto
id|leave
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|4
suffix:semicolon
id|cnt
op_le
id|evpd_page
(braket
l_int|3
)braket
op_plus
l_int|3
suffix:semicolon
id|cnt
op_increment
)paren
r_if
c_cond
(paren
id|evpd_page
(braket
id|cnt
)braket
op_eq
l_int|0x80
)paren
r_if
c_cond
(paren
id|scsi_get_serialnumber
c_func
(paren
id|sdev
comma
id|sreq
)paren
)paren
r_goto
id|leave
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;sdev_driverfs_dev.name
(braket
l_int|0
)braket
op_eq
l_int|0
)paren
id|scsi_get_default_name
c_func
(paren
id|sdev
)paren
suffix:semicolon
)brace
id|leave
suffix:colon
r_if
c_cond
(paren
id|evpd_page
)paren
id|kfree
c_func
(paren
id|evpd_page
)paren
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi scan: host %d channel %d&quot;
l_string|&quot; id %d lun %d name/id: &squot;%s&squot;&bslash;n&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
comma
id|sdev-&gt;sdev_driverfs_dev.name
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_probe_lun - probe a single LUN using a SCSI INQUIRY&n; * @sreq:&t;used to send the INQUIRY&n; * @inq_result:&t;area to store the INQUIRY result&n; * @bflags:&t;store any bflags found here&n; *&n; * Description:&n; *     Probe the lun associated with @sreq using a standard SCSI INQUIRY;&n; *&n; *     If the INQUIRY is successful, sreq-&gt;sr_result is zero and: the&n; *     INQUIRY data is in @inq_result; the scsi_level and INQUIRY length&n; *     are copied to the Scsi_Device at @sreq-&gt;sr_device (sdev);&n; *     any flags value is stored in *@bflags.&n; **/
DECL|function|scsi_probe_lun
r_static
r_void
id|scsi_probe_lun
c_func
(paren
id|Scsi_Request
op_star
id|sreq
comma
r_char
op_star
id|inq_result
comma
r_int
op_star
id|bflags
)paren
(brace
id|Scsi_Device
op_star
id|sdev
op_assign
id|sreq-&gt;sr_device
suffix:semicolon
multiline_comment|/* a bit ugly */
r_int
r_char
id|scsi_cmd
(braket
id|MAX_COMMAND_SIZE
)braket
suffix:semicolon
r_int
id|possible_inq_resp_len
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi scan: INQUIRY to host %d&quot;
l_string|&quot; channel %d id %d lun %d&bslash;n&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|scsi_cmd
comma
l_int|0
comma
l_int|6
)paren
suffix:semicolon
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|INQUIRY
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
l_int|36
suffix:semicolon
multiline_comment|/* issue conservative alloc_length */
id|sreq-&gt;sr_cmd_len
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_data_direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
id|memset
c_func
(paren
id|inq_result
comma
l_int|0
comma
l_int|36
)paren
suffix:semicolon
id|scsi_wait_req
c_func
(paren
id|sreq
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|inq_result
comma
l_int|36
comma
id|SCSI_TIMEOUT
op_plus
l_int|4
op_star
id|HZ
comma
l_int|3
)paren
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi scan: 1st INQUIRY %s with&quot;
l_string|&quot; code 0x%x&bslash;n&quot;
comma
id|sreq-&gt;sr_result
ques
c_cond
l_string|&quot;failed&quot;
suffix:colon
l_string|&quot;successful&quot;
comma
id|sreq-&gt;sr_result
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sreq-&gt;sr_result
)paren
(brace
r_if
c_cond
(paren
(paren
id|driver_byte
c_func
(paren
id|sreq-&gt;sr_result
)paren
op_amp
id|DRIVER_SENSE
)paren
op_ne
l_int|0
op_logical_and
(paren
id|sreq-&gt;sr_sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_eq
id|UNIT_ATTENTION
op_logical_and
id|sreq-&gt;sr_sense_buffer
(braket
l_int|12
)braket
op_eq
l_int|0x28
op_logical_and
id|sreq-&gt;sr_sense_buffer
(braket
l_int|13
)braket
op_eq
l_int|0
)paren
(brace
multiline_comment|/* not-ready to ready transition - good */
multiline_comment|/* dpg: bogus? INQUIRY never returns UNIT_ATTENTION */
)brace
r_else
multiline_comment|/*&n;&t;&t;&t; * assume no peripheral if any other sort of error&n;&t;&t;&t; */
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get any flags for this device.&n;&t; *&n;&t; * XXX add a bflags to Scsi_Device, and replace the corresponding&n;&t; * bit fields in Scsi_Device, so bflags need not be passed as an&n;&t; * argument.&n;&t; */
id|BUG_ON
c_func
(paren
id|bflags
op_eq
l_int|NULL
)paren
suffix:semicolon
op_star
id|bflags
op_assign
id|scsi_get_device_flags
c_func
(paren
op_amp
id|inq_result
(braket
l_int|8
)braket
comma
op_amp
id|inq_result
(braket
l_int|16
)braket
)paren
suffix:semicolon
id|possible_inq_resp_len
op_assign
(paren
r_int
r_char
)paren
id|inq_result
(braket
l_int|4
)braket
op_plus
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|BLIST_INQUIRY_36
op_amp
op_star
id|bflags
)paren
id|possible_inq_resp_len
op_assign
l_int|36
suffix:semicolon
r_else
r_if
c_cond
(paren
id|BLIST_INQUIRY_58
op_amp
op_star
id|bflags
)paren
id|possible_inq_resp_len
op_assign
l_int|58
suffix:semicolon
r_else
r_if
c_cond
(paren
id|possible_inq_resp_len
OG
l_int|255
)paren
id|possible_inq_resp_len
op_assign
l_int|36
suffix:semicolon
multiline_comment|/* sanity */
r_if
c_cond
(paren
id|possible_inq_resp_len
OG
l_int|36
)paren
(brace
multiline_comment|/* do additional INQUIRY */
id|memset
c_func
(paren
id|scsi_cmd
comma
l_int|0
comma
l_int|6
)paren
suffix:semicolon
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|INQUIRY
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
(paren
r_int
r_char
)paren
id|possible_inq_resp_len
suffix:semicolon
id|sreq-&gt;sr_cmd_len
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_data_direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
multiline_comment|/*&n;&t;&t; * re-zero inq_result just to be safe.&n;&t;&t; */
id|memset
c_func
(paren
id|inq_result
comma
l_int|0
comma
id|possible_inq_resp_len
)paren
suffix:semicolon
id|scsi_wait_req
c_func
(paren
id|sreq
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|inq_result
comma
id|possible_inq_resp_len
comma
id|SCSI_TIMEOUT
op_plus
l_int|4
op_star
id|HZ
comma
l_int|3
)paren
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi scan: 2nd INQUIRY&quot;
l_string|&quot; %s with code 0x%x&bslash;n&quot;
comma
id|sreq-&gt;sr_result
ques
c_cond
l_string|&quot;failed&quot;
suffix:colon
l_string|&quot;successful&quot;
comma
id|sreq-&gt;sr_result
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sreq-&gt;sr_result
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The INQUIRY can change, this means the length can change.&n;&t;&t; */
id|possible_inq_resp_len
op_assign
(paren
r_int
r_char
)paren
id|inq_result
(braket
l_int|4
)braket
op_plus
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|BLIST_INQUIRY_58
op_amp
op_star
id|bflags
)paren
id|possible_inq_resp_len
op_assign
l_int|58
suffix:semicolon
r_else
r_if
c_cond
(paren
id|possible_inq_resp_len
OG
l_int|255
)paren
id|possible_inq_resp_len
op_assign
l_int|36
suffix:semicolon
multiline_comment|/* sanity */
)brace
id|sdev-&gt;inquiry_len
op_assign
id|possible_inq_resp_len
suffix:semicolon
multiline_comment|/*&n;&t; * XXX Abort if the response length is less than 36? If less than&n;&t; * 32, the lookup of the device flags (above) could be invalid,&n;&t; * and it would be possible to take an incorrect action - we do&n;&t; * not want to hang because of a short INQUIRY. On the flip side,&n;&t; * if the device is spun down or becoming ready (and so it gives a&n;&t; * short INQUIRY), an abort here prevents any further use of the&n;&t; * device, including spin up.&n;&t; *&n;&t; * Related to the above issue:&n;&t; *&n;&t; * XXX Devices (disk or all?) should be sent a TEST UNIT READY,&n;&t; * and if not ready, sent a START_STOP to start (maybe spin up) and&n;&t; * then send the INQUIRY again, since the INQUIRY can change after&n;&t; * a device is initialized.&n;&t; *&n;&t; * Ideally, start a device if explicitly asked to do so.  This&n;&t; * assumes that a device is spun up on power on, spun down on&n;&t; * request, and then spun up on request.&n;&t; */
multiline_comment|/*&n;&t; * The scanning code needs to know the scsi_level, even if no&n;&t; * device is attached at LUN 0 (SCSI_SCAN_TARGET_PRESENT) so&n;&t; * non-zero LUNs can be scanned.&n;&t; */
id|sdev-&gt;scsi_level
op_assign
id|inq_result
(braket
l_int|2
)braket
op_amp
l_int|0x07
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;scsi_level
op_ge
l_int|2
op_logical_or
(paren
id|sdev-&gt;scsi_level
op_eq
l_int|1
op_logical_and
(paren
id|inq_result
(braket
l_int|3
)braket
op_amp
l_int|0x0f
)paren
op_eq
l_int|1
)paren
)paren
id|sdev-&gt;scsi_level
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_add_lun - allocate and fully initialze a Scsi_Device&n; * @sdevscan:&t;holds information to be stored in the new Scsi_Device&n; * @sdevnew:&t;store the address of the newly allocated Scsi_Device&n; * @sreq:&t;scsi request used when getting an identifier&n; * @inq_result:&t;holds the result of a previous INQUIRY to the LUN&n; * @bflags:&t;black/white list flag&n; *&n; * Description:&n; *     Allocate and initialize a Scsi_Device matching sdevscan. Optionally&n; *     set fields based on values in *@bflags. If @sdevnew is not&n; *     NULL, store the address of the new Scsi_Device in *@sdevnew (needed&n; *     when scanning a particular LUN).&n; *&n; * Return:&n; *     SCSI_SCAN_NO_RESPONSE: could not allocate or setup a Scsi_Device&n; *     SCSI_SCAN_LUN_PRESENT: a new Scsi_Device was allocated and initialized&n; **/
DECL|function|scsi_add_lun
r_static
r_int
id|scsi_add_lun
c_func
(paren
id|Scsi_Device
op_star
id|sdev
comma
id|Scsi_Request
op_star
id|sreq
comma
r_char
op_star
id|inq_result
comma
r_int
op_star
id|bflags
)paren
(brace
multiline_comment|/*&n;&t; * XXX do not save the inquiry, since it can change underneath us,&n;&t; * save just vendor/model/rev.&n;&t; *&n;&t; * Rather than save it and have an ioctl that retrieves the saved&n;&t; * value, have an ioctl that executes the same INQUIRY code used&n;&t; * in scsi_probe_lun, let user level programs doing INQUIRY&n;&t; * scanning run at their own risk, or supply a user level program&n;&t; * that can correctly scan.&n;&t; */
id|sdev-&gt;inquiry
op_assign
id|kmalloc
c_func
(paren
id|sdev-&gt;inquiry_len
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;inquiry
op_eq
l_int|NULL
)paren
(brace
r_return
id|SCSI_SCAN_NO_RESPONSE
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|sdev-&gt;inquiry
comma
id|inq_result
comma
id|sdev-&gt;inquiry_len
)paren
suffix:semicolon
id|sdev-&gt;vendor
op_assign
(paren
r_char
op_star
)paren
(paren
id|sdev-&gt;inquiry
op_plus
l_int|8
)paren
suffix:semicolon
id|sdev-&gt;model
op_assign
(paren
r_char
op_star
)paren
(paren
id|sdev-&gt;inquiry
op_plus
l_int|16
)paren
suffix:semicolon
id|sdev-&gt;rev
op_assign
(paren
r_char
op_star
)paren
(paren
id|sdev-&gt;inquiry
op_plus
l_int|32
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|bflags
op_amp
id|BLIST_ISROM
)paren
(brace
multiline_comment|/*&n;&t;&t; * It would be better to modify sdev-&gt;type, and set&n;&t;&t; * sdev-&gt;removable, but then the print_inquiry() output&n;&t;&t; * would not show TYPE_ROM; if print_inquiry() is removed&n;&t;&t; * the issue goes away.&n;&t;&t; */
id|inq_result
(braket
l_int|0
)braket
op_assign
id|TYPE_ROM
suffix:semicolon
id|inq_result
(braket
l_int|1
)braket
op_or_assign
l_int|0x80
suffix:semicolon
multiline_comment|/* removable */
)brace
r_switch
c_cond
(paren
id|sdev-&gt;type
op_assign
(paren
id|inq_result
(braket
l_int|0
)braket
op_amp
l_int|0x1f
)paren
)paren
(brace
r_case
id|TYPE_TAPE
suffix:colon
r_case
id|TYPE_DISK
suffix:colon
r_case
id|TYPE_PRINTER
suffix:colon
r_case
id|TYPE_MOD
suffix:colon
r_case
id|TYPE_PROCESSOR
suffix:colon
r_case
id|TYPE_SCANNER
suffix:colon
r_case
id|TYPE_MEDIUM_CHANGER
suffix:colon
r_case
id|TYPE_ENCLOSURE
suffix:colon
r_case
id|TYPE_COMM
suffix:colon
id|sdev-&gt;writeable
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_WORM
suffix:colon
r_case
id|TYPE_ROM
suffix:colon
id|sdev-&gt;writeable
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi: unknown device type %d&bslash;n&quot;
comma
id|sdev-&gt;type
)paren
suffix:semicolon
)brace
id|sdev-&gt;random
op_assign
(paren
id|sdev-&gt;type
op_eq
id|TYPE_TAPE
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
id|print_inquiry
c_func
(paren
id|inq_result
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * For a peripheral qualifier (PQ) value of 1 (001b), the SCSI&n;&t; * spec says: The device server is capable of supporting the&n;&t; * specified peripheral device type on this logical unit. However,&n;&t; * the physical device is not currently connected to this logical&n;&t; * unit.&n;&t; *&n;&t; * The above is vague, as it implies that we could treat 001 and&n;&t; * 011 the same. Stay compatible with previous code, and create a&n;&t; * Scsi_Device for a PQ of 1&n;&t; *&n;&t; * XXX Save the PQ field let the upper layers figure out if they&n;&t; * want to attach or not to this device, do not set online FALSE;&n;&t; * otherwise, offline devices still get an sd allocated, and they&n;&t; * use up an sd slot.&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|inq_result
(braket
l_int|0
)braket
op_rshift
l_int|5
)paren
op_amp
l_int|7
)paren
op_eq
l_int|1
)paren
(brace
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi scan: peripheral&quot;
l_string|&quot; qualifier of 1, device offlined&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|sdev-&gt;online
op_assign
id|FALSE
suffix:semicolon
)brace
id|sdev-&gt;removable
op_assign
(paren
l_int|0x80
op_amp
id|inq_result
(braket
l_int|1
)braket
)paren
op_rshift
l_int|7
suffix:semicolon
id|sdev-&gt;lockable
op_assign
id|sdev-&gt;removable
suffix:semicolon
id|sdev-&gt;soft_reset
op_assign
(paren
id|inq_result
(braket
l_int|7
)braket
op_amp
l_int|1
)paren
op_logical_and
(paren
(paren
id|inq_result
(braket
l_int|3
)braket
op_amp
l_int|7
)paren
op_eq
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;scsi_level
op_ge
id|SCSI_3
op_logical_or
(paren
id|sdev-&gt;inquiry_len
OG
l_int|56
op_logical_and
id|inq_result
(braket
l_int|56
)braket
op_amp
l_int|0x04
)paren
)paren
id|sdev-&gt;ppr
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|inq_result
(braket
l_int|7
)braket
op_amp
l_int|0x60
)paren
id|sdev-&gt;wdtr
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|inq_result
(braket
l_int|7
)braket
op_amp
l_int|0x10
)paren
id|sdev-&gt;sdtr
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * XXX maybe move the identifier and driverfs/devfs setup to a new&n;&t; * function, and call them after this function is called.&n;&t; *&n;&t; * scsi_load_identifier is the only reason sreq is needed in this&n;&t; * function.&n;&t; */
id|scsi_load_identifier
c_func
(paren
id|sdev
comma
id|sreq
)paren
suffix:semicolon
id|scsi_device_register
c_func
(paren
id|sdev
)paren
suffix:semicolon
id|sdev-&gt;de
op_assign
id|devfs_mk_dir
c_func
(paren
l_string|&quot;scsi/host%d/bus%d/target%d/lun%d&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * End driverfs/devfs code.&n;&t; */
r_if
c_cond
(paren
(paren
id|sdev-&gt;scsi_level
op_ge
id|SCSI_2
)paren
op_logical_and
(paren
id|inq_result
(braket
l_int|7
)braket
op_amp
l_int|2
)paren
op_logical_and
op_logical_neg
(paren
op_star
id|bflags
op_amp
id|BLIST_NOTQ
)paren
)paren
id|sdev-&gt;tagged_supported
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Some devices (Texel CD ROM drives) have handshaking problems&n;&t; * when used with the Seagate controllers. borken is initialized&n;&t; * to 1, and then set it to 0 here.&n;&t; */
r_if
c_cond
(paren
(paren
op_star
id|bflags
op_amp
id|BLIST_BORKEN
)paren
op_eq
l_int|0
)paren
id|sdev-&gt;borken
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If we need to allow I/O to only one of the luns attached to&n;&t; * this target id at a time, then we set this flag.&n;&t; */
r_if
c_cond
(paren
op_star
id|bflags
op_amp
id|BLIST_SINGLELUN
)paren
id|sdev-&gt;single_lun
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* if the device needs this changing, it may do so in the detect&n;&t; * function */
id|sdev-&gt;max_device_blocked
op_assign
id|SCSI_DEFAULT_DEVICE_BLOCKED
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;host-&gt;hostt-&gt;slave_configure
)paren
(brace
id|sdev-&gt;host-&gt;hostt
op_member_access_from_pointer
id|slave_configure
c_func
(paren
id|sdev
)paren
suffix:semicolon
)brace
r_return
id|SCSI_SCAN_LUN_PRESENT
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_probe_and_add_lun - probe a LUN, if a LUN is found add it&n; * @sdevscan:&t;probe the LUN corresponding to this Scsi_Device&n; * @sdevnew:&t;store the value of any new Scsi_Device allocated&n; * @bflagsp:&t;store bflags here if not NULL&n; *&n; * Description:&n; *     Call scsi_probe_lun, if a LUN with an attached device is found,&n; *     allocate and set it up by calling scsi_add_lun.&n; *&n; * Return:&n; *     SCSI_SCAN_NO_RESPONSE: could not allocate or setup a Scsi_Device&n; *     SCSI_SCAN_TARGET_PRESENT: target responded, but no device is&n; *         attached at the LUN&n; *     SCSI_SCAN_LUN_PRESENT: a new Scsi_Device was allocated and initialized&n; **/
DECL|function|scsi_probe_and_add_lun
r_static
r_int
id|scsi_probe_and_add_lun
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|request_queue
op_star
op_star
id|q
comma
id|uint
id|channel
comma
id|uint
id|id
comma
id|uint
id|lun
comma
r_int
op_star
id|bflagsp
comma
r_struct
id|scsi_device
op_star
op_star
id|sdevp
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
r_struct
id|scsi_request
op_star
id|sreq
suffix:semicolon
r_int
r_char
op_star
id|result
suffix:semicolon
r_int
id|bflags
comma
id|res
op_assign
id|SCSI_SCAN_NO_RESPONSE
suffix:semicolon
id|sdev
op_assign
id|scsi_alloc_sdev
c_func
(paren
id|host
comma
id|q
comma
id|channel
comma
id|id
comma
id|lun
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sdev
)paren
r_goto
id|out
suffix:semicolon
id|sreq
op_assign
id|scsi_allocate_request
c_func
(paren
id|sdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sreq
)paren
r_goto
id|out_free_sdev
suffix:semicolon
id|result
op_assign
id|kmalloc
c_func
(paren
l_int|256
comma
id|GFP_ATOMIC
op_or
(paren
id|host-&gt;unchecked_isa_dma
)paren
ques
c_cond
id|__GFP_DMA
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
r_goto
id|out_free_sreq
suffix:semicolon
id|scsi_probe_lun
c_func
(paren
id|sreq
comma
id|result
comma
op_amp
id|bflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sreq-&gt;sr_result
)paren
r_goto
id|out_free_result
suffix:semicolon
multiline_comment|/*&n;&t; * result contains valid SCSI INQUIRY data.&n;&t; */
r_if
c_cond
(paren
(paren
id|result
(braket
l_int|0
)braket
op_rshift
l_int|5
)paren
op_eq
l_int|3
)paren
(brace
multiline_comment|/*&n;&t;&t; * For a Peripheral qualifier 3 (011b), the SCSI&n;&t;&t; * spec says: The device server is not capable of&n;&t;&t; * supporting a physical device on this logical&n;&t;&t; * unit.&n;&t;&t; *&n;&t;&t; * For disks, this implies that there is no&n;&t;&t; * logical disk configured at sdev-&gt;lun, but there&n;&t;&t; * is a target id responding.&n;&t;&t; */
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi scan: peripheral qualifier of 3,&quot;
l_string|&quot; no device added&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|res
op_assign
id|SCSI_SCAN_TARGET_PRESENT
suffix:semicolon
r_goto
id|out_free_result
suffix:semicolon
)brace
id|res
op_assign
id|scsi_add_lun
c_func
(paren
id|sdev
comma
id|sreq
comma
id|result
comma
op_amp
id|bflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_eq
id|SCSI_SCAN_LUN_PRESENT
)paren
(brace
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_KEY
)paren
(brace
id|sdev-&gt;lockable
op_assign
l_int|0
suffix:semicolon
id|scsi_unlock_floptical
c_func
(paren
id|sreq
comma
id|result
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bflagsp
)paren
op_star
id|bflagsp
op_assign
id|bflags
suffix:semicolon
)brace
id|out_free_result
suffix:colon
id|kfree
c_func
(paren
id|result
)paren
suffix:semicolon
id|out_free_sreq
suffix:colon
id|scsi_release_request
c_func
(paren
id|sreq
)paren
suffix:semicolon
id|out_free_sdev
suffix:colon
r_if
c_cond
(paren
id|res
op_eq
id|SCSI_SCAN_LUN_PRESENT
)paren
(brace
r_if
c_cond
(paren
id|sdevp
)paren
op_star
id|sdevp
op_assign
id|sdev
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|q
)paren
(brace
op_star
id|q
op_assign
id|sdev-&gt;request_queue
suffix:semicolon
id|sdev-&gt;request_queue
op_assign
l_int|NULL
suffix:semicolon
)brace
id|scsi_free_sdev
c_func
(paren
id|sdev
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_sequential_lun_scan - sequentially scan a SCSI target&n; * @sdevscan:&t;scan the host, channel, and id of this Scsi_Device&n; * @bflags:&t;black/white list flag for LUN 0&n; * @lun0_res:&t;result of scanning LUN 0&n; *&n; * Description:&n; *     Generally, scan from LUN 1 (LUN 0 is assumed to already have been&n; *     scanned) to some maximum lun until a LUN is found with no device&n; *     attached. Use the bflags to figure out any oddities.&n; *&n; *     Modifies sdevscan-&gt;lun.&n; **/
DECL|function|scsi_sequential_lun_scan
r_static
r_void
id|scsi_sequential_lun_scan
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
comma
r_struct
id|request_queue
op_star
op_star
id|q
comma
id|uint
id|channel
comma
id|uint
id|id
comma
r_int
id|bflags
comma
r_int
id|lun0_res
comma
r_int
id|scsi_level
)paren
(brace
r_int
r_int
id|sparse_lun
comma
id|lun
comma
id|max_dev_lun
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi scan: Sequential scan of&quot;
l_string|&quot; host %d channel %d id %d&bslash;n&quot;
comma
id|shost-&gt;host_no
comma
id|channel
comma
id|id
)paren
)paren
suffix:semicolon
id|max_dev_lun
op_assign
id|min
c_func
(paren
id|max_scsi_luns
comma
id|shost-&gt;max_lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If this device is known to support sparse multiple units,&n;&t; * override the other settings, and scan all of them. Normally,&n;&t; * SCSI-3 devices should be scanned via the REPORT LUNS.&n;&t; */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_SPARSELUN
)paren
(brace
id|max_dev_lun
op_assign
id|shost-&gt;max_lun
suffix:semicolon
id|sparse_lun
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|sparse_lun
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If not sparse lun and no device attached at LUN 0 do not scan&n;&t; * any further.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sparse_lun
op_logical_and
(paren
id|lun0_res
op_ne
id|SCSI_SCAN_LUN_PRESENT
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * If less than SCSI_1_CSS, and no special lun scaning, stop&n;&t; * scanning; this matches 2.4 behaviour, but could just be a bug&n;&t; * (to continue scanning a SCSI_1_CSS device).&n;&t; *&n;&t; * This test is broken.  We might not have any device on lun0 for&n;&t; * a sparselun device, and if that&squot;s the case then how would we&n;&t; * know the real scsi_level, eh?  It might make sense to just not&n;&t; * scan any SCSI_1 device for non-0 luns, but that check would best&n;&t; * go into scsi_alloc_sdev() and just have it return null when asked&n;&t; * to alloc an sdev for lun &gt; 0 on an already found SCSI_1 device.&n;&t; *&n;&t;if ((sdevscan-&gt;scsi_level &lt; SCSI_1_CCS) &amp;&amp;&n;&t;    ((bflags &amp; (BLIST_FORCELUN | BLIST_SPARSELUN | BLIST_MAX5LUN))&n;&t;     == 0))&n;&t;&t;return;&n;&t; */
multiline_comment|/*&n;&t; * If this device is known to support multiple units, override&n;&t; * the other settings, and scan all of them.&n;&t; */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_FORCELUN
)paren
id|max_dev_lun
op_assign
id|shost-&gt;max_lun
suffix:semicolon
multiline_comment|/*&n;&t; * REGAL CDC-4X: avoid hang after LUN 4&n;&t; */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_MAX5LUN
)paren
id|max_dev_lun
op_assign
id|min
c_func
(paren
l_int|5U
comma
id|max_dev_lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do not scan SCSI-2 or lower device past LUN 7, unless&n;&t; * BLIST_LARGELUN.&n;&t; */
r_if
c_cond
(paren
id|scsi_level
OL
id|SCSI_3
op_logical_and
op_logical_neg
(paren
id|bflags
op_amp
id|BLIST_LARGELUN
)paren
)paren
id|max_dev_lun
op_assign
id|min
c_func
(paren
l_int|8U
comma
id|max_dev_lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We have already scanned LUN 0, so start at LUN 1. Keep scanning&n;&t; * until we reach the max, or no LUN is found and we are not&n;&t; * sparse_lun.&n;&t; */
r_for
c_loop
(paren
id|lun
op_assign
l_int|1
suffix:semicolon
id|lun
OL
id|max_dev_lun
suffix:semicolon
op_increment
id|lun
)paren
r_if
c_cond
(paren
(paren
id|scsi_probe_and_add_lun
c_func
(paren
id|shost
comma
id|q
comma
id|channel
comma
id|id
comma
id|lun
comma
l_int|NULL
comma
l_int|NULL
)paren
op_ne
id|SCSI_SCAN_LUN_PRESENT
)paren
op_logical_and
op_logical_neg
id|sparse_lun
)paren
r_return
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SCSI_REPORT_LUNS
multiline_comment|/**&n; * scsilun_to_int: convert a ScsiLun to an int&n; * @scsilun:&t;ScsiLun to be converted.&n; *&n; * Description:&n; *     Convert @scsilun from a ScsiLun to a four byte host byte-ordered&n; *     integer, and return the result. The caller must check for&n; *     truncation before using this function.&n; *&n; * Notes:&n; *     The ScsiLun is assumed to be four levels, with each level&n; *     effectively containing a SCSI byte-ordered (big endian) short; the&n; *     addressing bits of each level are ignored (the highest two bits).&n; *     For a description of the LUN format, post SCSI-3 see the SCSI&n; *     Architecture Model, for SCSI-3 see the SCSI Controller Commands.&n; *&n; *     Given a ScsiLun of: 0a 04 0b 03 00 00 00 00, this function returns&n; *     the integer: 0x0b030a04&n; **/
DECL|function|scsilun_to_int
r_static
r_int
id|scsilun_to_int
c_func
(paren
id|ScsiLun
op_star
id|scsilun
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|lun
suffix:semicolon
id|lun
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|lun
)paren
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
id|lun
op_assign
id|lun
op_or
(paren
(paren
(paren
id|scsilun-&gt;scsi_lun
(braket
id|i
)braket
op_lshift
l_int|8
)paren
op_or
id|scsilun-&gt;scsi_lun
(braket
id|i
op_plus
l_int|1
)braket
)paren
op_lshift
(paren
id|i
op_star
l_int|8
)paren
)paren
suffix:semicolon
r_return
id|lun
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/**&n; * scsi_report_lun_scan - Scan using SCSI REPORT LUN results&n; * @sdevscan:&t;scan the host, channel, and id of this Scsi_Device&n; *&n; * Description:&n; *     If @sdevscan is for a SCSI-3 or up device, send a REPORT LUN&n; *     command, and scan the resulting list of LUNs by calling&n; *     scsi_probe_and_add_lun.&n; *&n; *     Modifies sdevscan-&gt;lun.&n; *&n; * Return:&n; *     0: scan completed (or no memory, so further scanning is futile)&n; *     1: no report lun scan, or not configured&n; **/
DECL|function|scsi_report_lun_scan
r_static
r_int
id|scsi_report_lun_scan
c_func
(paren
id|Scsi_Device
op_star
id|sdev
comma
r_struct
id|request_queue
op_star
op_star
id|q
comma
r_int
id|bflags
)paren
(brace
macro_line|#ifdef CONFIG_SCSI_REPORT_LUNS
r_char
id|devname
(braket
l_int|64
)braket
suffix:semicolon
r_int
r_char
id|scsi_cmd
(braket
id|MAX_COMMAND_SIZE
)braket
suffix:semicolon
r_int
r_int
id|length
suffix:semicolon
r_int
r_int
id|lun
suffix:semicolon
r_int
r_int
id|num_luns
suffix:semicolon
r_int
r_int
id|retries
suffix:semicolon
id|ScsiLun
op_star
id|fcp_cur_lun
comma
op_star
id|lun_data
suffix:semicolon
id|Scsi_Request
op_star
id|sreq
suffix:semicolon
r_char
op_star
id|data
suffix:semicolon
multiline_comment|/*&n;&t; * Only support SCSI-3 and up devices.&n;&t; */
r_if
c_cond
(paren
id|sdev-&gt;scsi_level
OL
id|SCSI_3
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_NOLUN
)paren
r_return
l_int|0
suffix:semicolon
id|sreq
op_assign
id|scsi_allocate_request
c_func
(paren
id|sdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sreq
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|ALLOC_FAILURE_MSG
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|devname
comma
l_string|&quot;host %d channel %d id %d&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate enough to hold the header (the same size as one ScsiLun)&n;&t; * plus the max number of luns we are requesting.&n;&t; *&n;&t; * Reallocating and trying again (with the exact amount we need)&n;&t; * would be nice, but then we need to somehow limit the size&n;&t; * allocated based on the available memory and the limits of&n;&t; * kmalloc - we don&squot;t want a kmalloc() failure of a huge value to&n;&t; * prevent us from finding any LUNs on this target.&n;&t; */
id|length
op_assign
(paren
id|max_scsi_report_luns
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
id|ScsiLun
)paren
suffix:semicolon
id|lun_data
op_assign
(paren
id|ScsiLun
op_star
)paren
id|kmalloc
c_func
(paren
id|length
comma
id|GFP_ATOMIC
op_or
(paren
id|sdev-&gt;host-&gt;unchecked_isa_dma
ques
c_cond
id|GFP_DMA
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lun_data
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|ALLOC_FAILURE_MSG
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|scsi_release_request
c_func
(paren
id|sreq
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We are out of memory, don&squot;t try scanning any further.&n;&t;&t; */
r_return
l_int|0
suffix:semicolon
)brace
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|REPORT_LUNS
suffix:semicolon
multiline_comment|/*&n;&t; * bytes 1 - 5: reserved, set to zero.&n;&t; */
id|memset
c_func
(paren
op_amp
id|scsi_cmd
(braket
l_int|1
)braket
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * bytes 6 - 9: length of the command.&n;&t; */
id|scsi_cmd
(braket
l_int|6
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|length
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
suffix:semicolon
id|scsi_cmd
(braket
l_int|7
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|length
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
id|scsi_cmd
(braket
l_int|8
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|length
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|scsi_cmd
(braket
l_int|9
)braket
op_assign
(paren
r_int
r_char
)paren
id|length
op_amp
l_int|0xff
suffix:semicolon
id|scsi_cmd
(braket
l_int|10
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* reserved */
id|scsi_cmd
(braket
l_int|11
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* control */
id|sreq-&gt;sr_cmd_len
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_data_direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
multiline_comment|/*&n;&t; * We can get a UNIT ATTENTION, for example a power on/reset, so&n;&t; * retry a few times (like sd.c does for TEST UNIT READY).&n;&t; * Experience shows some combinations of adapter/devices get at&n;&t; * least two power on/resets.&n;&t; *&n;&t; * Illegal requests (for devices that do not support REPORT LUNS)&n;&t; * should come through as a check condition, and will not generate&n;&t; * a retry.&n;&t; */
id|retries
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|retries
op_increment
OL
l_int|3
)paren
(brace
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
(paren
id|KERN_INFO
l_string|&quot;scsi scan: Sending&quot;
l_string|&quot; REPORT LUNS to %s (try %d)&bslash;n&quot;
comma
id|devname
comma
id|retries
)paren
)paren
suffix:semicolon
id|scsi_wait_req
c_func
(paren
id|sreq
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|lun_data
comma
id|length
comma
id|SCSI_TIMEOUT
op_plus
l_int|4
op_star
id|HZ
comma
l_int|3
)paren
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
(paren
id|KERN_INFO
l_string|&quot;scsi scan: REPORT LUNS&quot;
l_string|&quot; %s (try %d) result 0x%x&bslash;n&quot;
comma
id|sreq-&gt;sr_result
ques
c_cond
l_string|&quot;failed&quot;
suffix:colon
l_string|&quot;successful&quot;
comma
id|retries
comma
id|sreq-&gt;sr_result
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sreq-&gt;sr_result
op_eq
l_int|0
op_logical_or
id|sreq-&gt;sr_sense_buffer
(braket
l_int|2
)braket
op_ne
id|UNIT_ATTENTION
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sreq-&gt;sr_result
)paren
(brace
multiline_comment|/*&n;&t;&t; * The device probably does not support a REPORT LUN command&n;&t;&t; */
id|kfree
c_func
(paren
(paren
r_char
op_star
)paren
id|lun_data
)paren
suffix:semicolon
id|scsi_release_request
c_func
(paren
id|sreq
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|scsi_release_request
c_func
(paren
id|sreq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get the length from the first four bytes of lun_data.&n;&t; */
id|data
op_assign
(paren
r_char
op_star
)paren
id|lun_data-&gt;scsi_lun
suffix:semicolon
id|length
op_assign
(paren
(paren
id|data
(braket
l_int|0
)braket
op_lshift
l_int|24
)paren
op_or
(paren
id|data
(braket
l_int|1
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|data
(braket
l_int|2
)braket
op_lshift
l_int|8
)paren
op_or
(paren
id|data
(braket
l_int|3
)braket
op_lshift
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|length
op_div
r_sizeof
(paren
id|ScsiLun
)paren
)paren
OG
id|max_scsi_report_luns
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi: On %s only %d (max_scsi_report_luns)&quot;
l_string|&quot; of %d luns reported, try increasing&quot;
l_string|&quot; max_scsi_report_luns.&bslash;n&quot;
comma
id|devname
comma
id|max_scsi_report_luns
comma
id|length
op_div
r_sizeof
(paren
id|ScsiLun
)paren
)paren
suffix:semicolon
id|num_luns
op_assign
id|max_scsi_report_luns
suffix:semicolon
)brace
r_else
id|num_luns
op_assign
(paren
id|length
op_div
r_sizeof
(paren
id|ScsiLun
)paren
)paren
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
(paren
id|KERN_INFO
l_string|&quot;scsi scan: REPORT LUN scan of&quot;
l_string|&quot; host %d channel %d id %d&bslash;n&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Scan the luns in lun_data. The entry at offset 0 is really&n;&t; * the header, so start at 1 and go up to and including num_luns.&n;&t; */
r_for
c_loop
(paren
id|fcp_cur_lun
op_assign
op_amp
id|lun_data
(braket
l_int|1
)braket
suffix:semicolon
id|fcp_cur_lun
op_le
op_amp
id|lun_data
(braket
id|num_luns
)braket
suffix:semicolon
id|fcp_cur_lun
op_increment
)paren
(brace
id|lun
op_assign
id|scsilun_to_int
c_func
(paren
id|fcp_cur_lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check if the unused part of fcp_cur_lun is non-zero,&n;&t;&t; * and so does not fit in lun.&n;&t;&t; */
r_if
c_cond
(paren
id|memcmp
c_func
(paren
op_amp
id|fcp_cur_lun-&gt;scsi_lun
(braket
r_sizeof
(paren
id|lun
)paren
)braket
comma
l_string|&quot;&bslash;0&bslash;0&bslash;0&bslash;0&quot;
comma
l_int|4
)paren
op_ne
l_int|0
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Output an error displaying the LUN in byte order,&n;&t;&t;&t; * this differs from what linux would print for the&n;&t;&t;&t; * integer LUN value.&n;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi: %s lun 0x&quot;
comma
id|devname
)paren
suffix:semicolon
id|data
op_assign
(paren
r_char
op_star
)paren
id|fcp_cur_lun-&gt;scsi_lun
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|ScsiLun
)paren
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%02x&quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; has a LUN larger than currently supported.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lun
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * LUN 0 has already been scanned.&n;&t;&t;&t; */
)brace
r_else
r_if
c_cond
(paren
id|lun
OG
id|sdev-&gt;host-&gt;max_lun
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi: %s lun%d has a LUN larger&quot;
l_string|&quot; than allowed by the host adapter&bslash;n&quot;
comma
id|devname
comma
id|lun
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|res
suffix:semicolon
id|res
op_assign
id|scsi_probe_and_add_lun
c_func
(paren
id|sdev-&gt;host
comma
id|q
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
comma
id|lun
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_eq
id|SCSI_SCAN_NO_RESPONSE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Got some results, but now none, abort.&n;&t;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;scsi: Unexpected response&quot;
l_string|&quot; from %s lun %d while scanning, scan&quot;
l_string|&quot; aborted&bslash;n&quot;
comma
id|devname
comma
id|lun
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|kfree
c_func
(paren
(paren
r_char
op_star
)paren
id|lun_data
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#else
r_return
l_int|1
suffix:semicolon
macro_line|#endif&t;/* CONFIG_SCSI_REPORT_LUNS */
)brace
DECL|function|scsi_add_device
r_struct
id|scsi_device
op_star
id|scsi_add_device
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
comma
id|uint
id|channel
comma
id|uint
id|id
comma
id|uint
id|lun
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
r_int
id|error
op_assign
op_minus
id|ENODEV
comma
id|res
suffix:semicolon
id|res
op_assign
id|scsi_probe_and_add_lun
c_func
(paren
id|shost
comma
l_int|NULL
comma
id|channel
comma
id|id
comma
id|lun
comma
l_int|NULL
comma
op_amp
id|sdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_eq
id|SCSI_SCAN_LUN_PRESENT
)paren
id|error
op_assign
id|scsi_attach_device
c_func
(paren
id|sdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
id|sdev
op_assign
id|ERR_PTR
c_func
(paren
id|error
)paren
suffix:semicolon
r_return
id|sdev
suffix:semicolon
)brace
DECL|function|scsi_remove_device
r_int
id|scsi_remove_device
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
)paren
(brace
id|scsi_detach_device
c_func
(paren
id|sdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;attached
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|devfs_unregister
c_func
(paren
id|sdev-&gt;de
)paren
suffix:semicolon
id|scsi_device_unregister
c_func
(paren
id|sdev
)paren
suffix:semicolon
id|scsi_free_sdev
c_func
(paren
id|sdev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_scan_target - scan a target id, possibly including all LUNs on the&n; *     target.&n; * @sdevsca:&t;Scsi_Device handle for scanning&n; * @shost:&t;host to scan&n; * @channel:&t;channel to scan&n; * @id:&t;&t;target id to scan&n; *&n; * Description:&n; *     Scan the target id on @shost, @channel, and @id. Scan at least LUN&n; *     0, and possibly all LUNs on the target id.&n; *&n; *     Use the pre-allocated @sdevscan as a handle for the scanning. This&n; *     function sets sdevscan-&gt;host, sdevscan-&gt;id and sdevscan-&gt;lun; the&n; *     scanning functions modify sdevscan-&gt;lun.&n; *&n; *     First try a REPORT LUN scan, if that does not scan the target, do a&n; *     sequential scan of LUNs on the target id.&n; **/
DECL|function|scsi_scan_target
r_static
r_void
id|scsi_scan_target
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
comma
r_struct
id|request_queue
op_star
op_star
id|q
comma
r_int
r_int
id|channel
comma
r_int
r_int
id|id
)paren
(brace
r_int
id|bflags
op_assign
l_int|0
suffix:semicolon
r_int
id|res
suffix:semicolon
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
r_if
c_cond
(paren
id|shost-&gt;this_id
op_eq
id|id
)paren
multiline_comment|/*&n;&t;&t; * Don&squot;t scan the host adapter&n;&t;&t; */
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Scan LUN 0, if there is some response, scan further. Ideally, we&n;&t; * would not configure LUN 0 until all LUNs are scanned.&n;&t; */
id|res
op_assign
id|scsi_probe_and_add_lun
c_func
(paren
id|shost
comma
id|q
comma
id|channel
comma
id|id
comma
l_int|0
comma
op_amp
id|bflags
comma
op_amp
id|sdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_eq
id|SCSI_SCAN_LUN_PRESENT
)paren
(brace
r_if
c_cond
(paren
id|scsi_report_lun_scan
c_func
(paren
id|sdev
comma
id|q
comma
id|bflags
)paren
op_ne
l_int|0
)paren
multiline_comment|/*&n;&t;&t;&t; * The REPORT LUN did not scan the target,&n;&t;&t;&t; * do a sequential scan.&n;&t;&t;&t; */
id|scsi_sequential_lun_scan
c_func
(paren
id|shost
comma
id|q
comma
id|channel
comma
id|id
comma
id|bflags
comma
id|res
comma
id|sdev-&gt;scsi_level
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|res
op_eq
id|SCSI_SCAN_TARGET_PRESENT
)paren
(brace
multiline_comment|/*&n;&t;&t; * There&squot;s a target here, but lun 0 is offline so we&n;&t;&t; * can&squot;t use the report_lun scan.  Fall back to a&n;&t;&t; * sequential lun scan with a bflags of SPARSELUN and&n;&t;&t; * a default scsi level of SCSI_2&n;&t;&t; */
id|scsi_sequential_lun_scan
c_func
(paren
id|shost
comma
id|q
comma
id|channel
comma
id|id
comma
id|BLIST_SPARSELUN
comma
id|SCSI_SCAN_TARGET_PRESENT
comma
id|SCSI_2
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * scsi_scan_host - scan the given adapter&n; * @shost:&t;adapter to scan&n; *&n; * Description:&n; *     Iterate and call scsi_scan_target to scan all possible target id&squot;s&n; *     on all possible channels.&n; **/
DECL|function|scsi_scan_host
r_void
id|scsi_scan_host
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
)paren
(brace
r_struct
id|request_queue
op_star
id|q
op_assign
l_int|NULL
suffix:semicolon
id|uint
id|channel
comma
id|id
comma
id|order_id
suffix:semicolon
multiline_comment|/*&n;&t; * The sdevscan host, channel, id and lun are filled in as&n;&t; * needed to scan.&n;&t; */
r_for
c_loop
(paren
id|channel
op_assign
l_int|0
suffix:semicolon
id|channel
op_le
id|shost-&gt;max_channel
suffix:semicolon
id|channel
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * XXX adapter drivers when possible (FCP, iSCSI)&n;&t;&t; * could modify max_id to match the current max,&n;&t;&t; * not the absolute max.&n;&t;&t; *&n;&t;&t; * XXX add a shost id iterator, so for example,&n;&t;&t; * the FC ID can be the same as a target id&n;&t;&t; * without a huge overhead of sparse id&squot;s.&n;&t;&t; */
r_for
c_loop
(paren
id|id
op_assign
l_int|0
suffix:semicolon
id|id
OL
id|shost-&gt;max_id
suffix:semicolon
op_increment
id|id
)paren
(brace
r_if
c_cond
(paren
id|shost-&gt;reverse_ordering
)paren
multiline_comment|/*&n;&t;&t;&t;&t; * Scan from high to low id.&n;&t;&t;&t;&t; */
id|order_id
op_assign
id|shost-&gt;max_id
op_minus
id|id
op_minus
l_int|1
suffix:semicolon
r_else
id|order_id
op_assign
id|id
suffix:semicolon
id|scsi_scan_target
c_func
(paren
id|shost
comma
op_amp
id|q
comma
id|channel
comma
id|order_id
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|q
)paren
id|scsi_free_queue
c_func
(paren
id|q
)paren
suffix:semicolon
)brace
DECL|function|scsi_forget_host
r_void
id|scsi_forget_host
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
)paren
(brace
r_struct
id|list_head
op_star
id|le
comma
op_star
id|lh
suffix:semicolon
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|le
comma
id|lh
comma
op_amp
id|shost-&gt;my_devices
)paren
(brace
id|sdev
op_assign
id|list_entry
c_func
(paren
id|le
comma
r_struct
id|scsi_device
comma
id|siblings
)paren
suffix:semicolon
id|scsi_remove_device
c_func
(paren
id|sdev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function:    scsi_get_host_dev()&n; *&n; * Purpose:     Create a Scsi_Device that points to the host adapter itself.&n; *&n; * Arguments:   SHpnt   - Host that needs a Scsi_Device&n; *&n; * Lock status: None assumed.&n; *&n; * Returns:     The Scsi_Device or NULL&n; *&n; * Notes:&n; *&t;Attach a single Scsi_Device to the Scsi_Host - this should&n; *&t;be made to look like a &quot;pseudo-device&quot; that points to the&n; *&t;HA itself.&n; *&n; *&t;Note - this device is not accessible from any high-level&n; *&t;drivers (including generics), which is probably not&n; *&t;optimal.  We can add hooks later to attach &n; */
DECL|function|scsi_get_host_dev
r_struct
id|scsi_device
op_star
id|scsi_get_host_dev
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
id|sdev
op_assign
id|scsi_alloc_sdev
c_func
(paren
id|shost
comma
l_int|NULL
comma
l_int|0
comma
id|shost-&gt;this_id
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev
)paren
(brace
id|sdev-&gt;borken
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|sdev
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_free_host_dev()&n; *&n; * Purpose:     Free a scsi_device that points to the host adapter itself.&n; *&n; * Arguments:   SHpnt   - Host that needs a Scsi_Device&n; *&n; * Lock status: None assumed.&n; *&n; * Returns:     Nothing&n; *&n; * Notes:&n; */
DECL|function|scsi_free_host_dev
r_void
id|scsi_free_host_dev
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
)paren
(brace
id|BUG_ON
c_func
(paren
id|sdev-&gt;id
op_ne
id|sdev-&gt;host-&gt;this_id
)paren
suffix:semicolon
id|scsi_free_sdev
c_func
(paren
id|sdev
)paren
suffix:semicolon
)brace
eof
