multiline_comment|/*&n; * scsi_scan.c&n; *&n; * Copyright (C) 2000 Eric Youngdale,&n; * Copyright (C) 2002 Patrick Mansfield&n; *&n; * The general scanning/probing algorithm is as follows, exceptions are&n; * made to it depending on device specific flags, compilation options, and&n; * global variable (boot or module load time) settings.&n; *&n; * A specific LUN is scanned via an INQUIRY command; if the LUN has a&n; * device attached, a Scsi_Device is allocated and setup for it.&n; *&n; * For every id of every channel on the given host:&n; *&n; * &t;Scan LUN 0; if the target responds to LUN 0 (even if there is no&n; * &t;device or storage attached to LUN 0):&n; *&n; * &t;&t;If LUN 0 has a device attached, allocate and setup a&n; * &t;&t;Scsi_Device for it.&n; *&n; * &t;&t;If target is SCSI-3 or up, issue a REPORT LUN, and scan&n; * &t;&t;all of the LUNs returned by the REPORT LUN; else,&n; * &t;&t;sequentially scan LUNs up until some maximum is reached,&n; * &t;&t;or a LUN is seen that cannot have a device attached to it.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#ifdef CONFIG_KMOD
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#endif
multiline_comment|/*&n; * Flags for SCSI devices that need special treatment&n; */
DECL|macro|BLIST_NOLUN
mdefine_line|#define BLIST_NOLUN     &t;0x001&t;/* Only scan LUN 0 */
DECL|macro|BLIST_FORCELUN
mdefine_line|#define BLIST_FORCELUN  &t;0x002&t;/* Known to have LUNs, force scanning */
DECL|macro|BLIST_BORKEN
mdefine_line|#define BLIST_BORKEN    &t;0x004&t;/* Flag for broken handshaking */
DECL|macro|BLIST_KEY
mdefine_line|#define BLIST_KEY       &t;0x008&t;/* unlock by special command */
DECL|macro|BLIST_SINGLELUN
mdefine_line|#define BLIST_SINGLELUN &t;0x010&t;/* Do not use LUNs in parallel */
DECL|macro|BLIST_NOTQ
mdefine_line|#define BLIST_NOTQ&t;&t;0x020&t;/* Buggy Tagged Command Queuing */
DECL|macro|BLIST_SPARSELUN
mdefine_line|#define BLIST_SPARSELUN &t;0x040&t;/* Non consecutive LUN numbering */
DECL|macro|BLIST_MAX5LUN
mdefine_line|#define BLIST_MAX5LUN&t;&t;0x080&t;/* Avoid LUNS &gt;= 5 */
DECL|macro|BLIST_ISROM
mdefine_line|#define BLIST_ISROM     &t;0x100&t;/* Treat as (removable) CD-ROM */
DECL|macro|BLIST_LARGELUN
mdefine_line|#define BLIST_LARGELUN&t;&t;0x200&t;/* LUNs past 7 on a SCSI-2 device */
DECL|macro|BLIST_INQUIRY_36
mdefine_line|#define BLIST_INQUIRY_36&t;0x400&t;/* override additional length field */
DECL|macro|BLIST_INQUIRY_58
mdefine_line|#define BLIST_INQUIRY_58&t;0x800&t;/* ... for broken inquiry responses */
multiline_comment|/*&n; * scsi_static_device_list: deprecated list of devices that require&n; * settings that differ from the default, includes black-listed (broken)&n; * devices. The entries here are added to the tail of scsi_dev_info_list&n; * via scsi_dev_info_list_init.&n; *&n; * Do not add to this list, use the command line or proc interface to add&n; * to the scsi_dev_info_list. This table will eventually go away.&n; */
DECL|variable|__initdata
r_struct
id|dev_info
id|scsi_static_device_list
(braket
)braket
id|__initdata
op_assign
(brace
multiline_comment|/*&n;&t; * The following devices are known not to tolerate a lun != 0 scan&n;&t; * for one reason or another. Some will respond to all luns,&n;&t; * others will lock up.&n;&t; */
(brace
l_string|&quot;Aashima&quot;
comma
l_string|&quot;IMAGERY 2400SP&quot;
comma
l_string|&quot;1.03&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;CHINON&quot;
comma
l_string|&quot;CD-ROM CDS-431&quot;
comma
l_string|&quot;H42&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;CHINON&quot;
comma
l_string|&quot;CD-ROM CDS-535&quot;
comma
l_string|&quot;Q14&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;DENON&quot;
comma
l_string|&quot;DRD-25X&quot;
comma
l_string|&quot;V&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;HITACHI&quot;
comma
l_string|&quot;DK312C&quot;
comma
l_string|&quot;CM81&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* responds to all lun */
(brace
l_string|&quot;HITACHI&quot;
comma
l_string|&quot;DK314C&quot;
comma
l_string|&quot;CR21&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* responds to all lun */
(brace
l_string|&quot;IMS&quot;
comma
l_string|&quot;CDD521/10&quot;
comma
l_string|&quot;2.06&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;XT-3280&quot;
comma
l_string|&quot;PR02&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;XT-4380S&quot;
comma
l_string|&quot;B3C&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;MXT-1240S&quot;
comma
l_string|&quot;I1.2&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;XT-4170S&quot;
comma
l_string|&quot;B5A&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;MAXTOR&quot;
comma
l_string|&quot;XT-8760S&quot;
comma
l_string|&quot;B7B&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;MEDIAVIS&quot;
comma
l_string|&quot;RENO CD-ROMX2A&quot;
comma
l_string|&quot;2.03&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* responds to all lun */
(brace
l_string|&quot;NEC&quot;
comma
l_string|&quot;CD-ROM DRIVE:841&quot;
comma
l_string|&quot;1.0&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;PHILIPS&quot;
comma
l_string|&quot;PCA80SC&quot;
comma
l_string|&quot;V4-2&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* responds to all lun */
(brace
l_string|&quot;RODIME&quot;
comma
l_string|&quot;RO3000S&quot;
comma
l_string|&quot;2.33&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
multiline_comment|/*&n;&t; * The following causes a failed REQUEST SENSE on lun 1 for&n;&t; * aha152x controller, which causes SCSI code to reset bus.&n;&t; */
(brace
l_string|&quot;SANYO&quot;
comma
l_string|&quot;CRD-250S&quot;
comma
l_string|&quot;1.20&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/*&n;&t; * The following causes a failed REQUEST SENSE on lun 1 for&n;&t; * aha152x controller, which causes SCSI code to reset bus.&n;&t; */
(brace
l_string|&quot;SEAGATE&quot;
comma
l_string|&quot;ST157N&quot;
comma
l_string|&quot;&bslash;004|j&quot;
comma
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;SEAGATE&quot;
comma
l_string|&quot;ST296&quot;
comma
l_string|&quot;921&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* responds to all lun */
(brace
l_string|&quot;SEAGATE&quot;
comma
l_string|&quot;ST1581&quot;
comma
l_string|&quot;6538&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* responds to all lun */
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-541&quot;
comma
l_string|&quot;4.3d&quot;
comma
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-55S&quot;
comma
l_string|&quot;1.0i&quot;
comma
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-561&quot;
comma
l_string|&quot;1.7x&quot;
comma
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-8012&quot;
comma
l_int|NULL
comma
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;TANDBERG&quot;
comma
l_string|&quot;TDC 3600&quot;
comma
l_string|&quot;U07&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;TEAC&quot;
comma
l_string|&quot;CD-R55S&quot;
comma
l_string|&quot;1.0H&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
multiline_comment|/*&n;&t; * The following causes a failed REQUEST SENSE on lun 1 for&n;&t; * seagate controller, which causes SCSI code to reset bus.&n;&t; */
(brace
l_string|&quot;TEAC&quot;
comma
l_string|&quot;CD-ROM&quot;
comma
l_string|&quot;1.06&quot;
comma
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;TEAC&quot;
comma
l_string|&quot;MT-2ST/45S2-27&quot;
comma
l_string|&quot;RV M&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* responds to all lun */
multiline_comment|/*&n;&t; * The following causes a failed REQUEST SENSE on lun 1 for&n;&t; * seagate controller, which causes SCSI code to reset bus.&n;&t; */
(brace
l_string|&quot;TEXEL&quot;
comma
l_string|&quot;CD-ROM&quot;
comma
l_string|&quot;1.06&quot;
comma
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;QUANTUM&quot;
comma
l_string|&quot;LPS525S&quot;
comma
l_string|&quot;3110&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;QUANTUM&quot;
comma
l_string|&quot;PD1225S&quot;
comma
l_string|&quot;3110&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;QUANTUM&quot;
comma
l_string|&quot;FIREBALL ST4.3S&quot;
comma
l_string|&quot;0F0C&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;MEDIAVIS&quot;
comma
l_string|&quot;CDR-H93MV&quot;
comma
l_string|&quot;1.31&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;SANKYO&quot;
comma
l_string|&quot;CP525&quot;
comma
l_string|&quot;6.64&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* causes failed REQ SENSE, extra reset */
(brace
l_string|&quot;HP&quot;
comma
l_string|&quot;C1750A&quot;
comma
l_string|&quot;3226&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* scanjet iic */
(brace
l_string|&quot;HP&quot;
comma
l_string|&quot;C1790A&quot;
comma
l_string|&quot;&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* scanjet iip */
(brace
l_string|&quot;HP&quot;
comma
l_string|&quot;C2500A&quot;
comma
l_string|&quot;&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* scanjet iicx */
(brace
l_string|&quot;YAMAHA&quot;
comma
l_string|&quot;CDR100&quot;
comma
l_string|&quot;1.00&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;YAMAHA&quot;
comma
l_string|&quot;CDR102&quot;
comma
l_string|&quot;1.00&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;YAMAHA&quot;
comma
l_string|&quot;CRW8424S&quot;
comma
l_string|&quot;1.0&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;YAMAHA&quot;
comma
l_string|&quot;CRW6416S&quot;
comma
l_string|&quot;1.0c&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;MITSUMI&quot;
comma
l_string|&quot;CD-R CR-2201CS&quot;
comma
l_string|&quot;6119&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* locks up */
(brace
l_string|&quot;RELISYS&quot;
comma
l_string|&quot;Scorpio&quot;
comma
l_int|NULL
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* responds to all lun */
(brace
l_string|&quot;MICROTEK&quot;
comma
l_string|&quot;ScanMaker II&quot;
comma
l_string|&quot;5.61&quot;
comma
id|BLIST_NOLUN
)brace
comma
multiline_comment|/* responds to all lun */
multiline_comment|/*&n;&t; * Other types of devices that have special flags.&n;&t; */
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-8001&quot;
comma
l_int|NULL
comma
id|BLIST_BORKEN
)brace
comma
(brace
l_string|&quot;TEXEL&quot;
comma
l_string|&quot;CD-ROM&quot;
comma
l_string|&quot;1.06&quot;
comma
id|BLIST_BORKEN
)brace
comma
(brace
l_string|&quot;IOMEGA&quot;
comma
l_string|&quot;Io20S         *F&quot;
comma
l_int|NULL
comma
id|BLIST_KEY
)brace
comma
(brace
l_string|&quot;INSITE&quot;
comma
l_string|&quot;Floptical   F*8I&quot;
comma
l_int|NULL
comma
id|BLIST_KEY
)brace
comma
(brace
l_string|&quot;INSITE&quot;
comma
l_string|&quot;I325VM&quot;
comma
l_int|NULL
comma
id|BLIST_KEY
)brace
comma
(brace
l_string|&quot;LASOUND&quot;
comma
l_string|&quot;CDX7405&quot;
comma
l_string|&quot;3.10&quot;
comma
id|BLIST_MAX5LUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;MICROP&quot;
comma
l_string|&quot;4110&quot;
comma
l_int|NULL
comma
id|BLIST_NOTQ
)brace
comma
(brace
l_string|&quot;NRC&quot;
comma
l_string|&quot;MBR-7&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;NRC&quot;
comma
l_string|&quot;MBR-7.4&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;REGAL&quot;
comma
l_string|&quot;CDC-4X&quot;
comma
l_int|NULL
comma
id|BLIST_MAX5LUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;NAKAMICH&quot;
comma
l_string|&quot;MJ-4.8S&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;NAKAMICH&quot;
comma
l_string|&quot;MJ-5.16S&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;PIONEER&quot;
comma
l_string|&quot;CD-ROM DRM-600&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;PIONEER&quot;
comma
l_string|&quot;CD-ROM DRM-602X&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;PIONEER&quot;
comma
l_string|&quot;CD-ROM DRM-604X&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;EMULEX&quot;
comma
l_string|&quot;MD21/S2     ESDI&quot;
comma
l_int|NULL
comma
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;CANON&quot;
comma
l_string|&quot;IPUBJD&quot;
comma
l_int|NULL
comma
id|BLIST_SPARSELUN
)brace
comma
(brace
l_string|&quot;nCipher&quot;
comma
l_string|&quot;Fastness Crypto&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;DEC&quot;
comma
l_string|&quot;HSG80&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;COMPAQ&quot;
comma
l_string|&quot;LOGICAL VOLUME&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;COMPAQ&quot;
comma
l_string|&quot;CR3500&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;NEC&quot;
comma
l_string|&quot;PD-1 ODX654P&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;MATSHITA&quot;
comma
l_string|&quot;PD-1&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
op_or
id|BLIST_SINGLELUN
)brace
comma
(brace
l_string|&quot;iomega&quot;
comma
l_string|&quot;jaz 1GB&quot;
comma
l_string|&quot;J.86&quot;
comma
id|BLIST_NOTQ
op_or
id|BLIST_NOLUN
)brace
comma
(brace
l_string|&quot;TOSHIBA&quot;
comma
l_string|&quot;CDROM&quot;
comma
l_int|NULL
comma
id|BLIST_ISROM
)brace
comma
(brace
l_string|&quot;TOSHIBA&quot;
comma
l_string|&quot;CD-ROM&quot;
comma
l_int|NULL
comma
id|BLIST_ISROM
)brace
comma
(brace
l_string|&quot;MegaRAID&quot;
comma
l_string|&quot;LD&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;DGC&quot;
comma
l_string|&quot;RAID&quot;
comma
l_int|NULL
comma
id|BLIST_SPARSELUN
)brace
comma
multiline_comment|/* Dell PV 650F, storage on LUN 0 */
(brace
l_string|&quot;DGC&quot;
comma
l_string|&quot;DISK&quot;
comma
l_int|NULL
comma
id|BLIST_SPARSELUN
)brace
comma
multiline_comment|/* Dell PV 650F, no storage on LUN 0 */
(brace
l_string|&quot;DELL&quot;
comma
l_string|&quot;PV660F&quot;
comma
l_int|NULL
comma
id|BLIST_SPARSELUN
)brace
comma
(brace
l_string|&quot;DELL&quot;
comma
l_string|&quot;PV660F   PSEUDO&quot;
comma
l_int|NULL
comma
id|BLIST_SPARSELUN
)brace
comma
(brace
l_string|&quot;DELL&quot;
comma
l_string|&quot;PSEUDO DEVICE .&quot;
comma
l_int|NULL
comma
id|BLIST_SPARSELUN
)brace
comma
multiline_comment|/* Dell PV 530F */
(brace
l_string|&quot;DELL&quot;
comma
l_string|&quot;PV530F&quot;
comma
l_int|NULL
comma
id|BLIST_SPARSELUN
)brace
comma
(brace
l_string|&quot;EMC&quot;
comma
l_string|&quot;SYMMETRIX&quot;
comma
l_int|NULL
comma
id|BLIST_SPARSELUN
op_or
id|BLIST_LARGELUN
op_or
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;HP&quot;
comma
l_string|&quot;A6189A&quot;
comma
l_int|NULL
comma
id|BLIST_SPARSELUN
op_or
id|BLIST_LARGELUN
)brace
comma
multiline_comment|/* HP VA7400 */
(brace
l_string|&quot;CMD&quot;
comma
l_string|&quot;CRA-7280&quot;
comma
l_int|NULL
comma
id|BLIST_SPARSELUN
)brace
comma
multiline_comment|/* CMD RAID Controller */
(brace
l_string|&quot;CNSI&quot;
comma
l_string|&quot;G7324&quot;
comma
l_int|NULL
comma
id|BLIST_SPARSELUN
)brace
comma
multiline_comment|/* Chaparral G7324 RAID */
(brace
l_string|&quot;CNSi&quot;
comma
l_string|&quot;G8324&quot;
comma
l_int|NULL
comma
id|BLIST_SPARSELUN
)brace
comma
multiline_comment|/* Chaparral G8324 RAID */
(brace
l_string|&quot;Zzyzx&quot;
comma
l_string|&quot;RocketStor 500S&quot;
comma
l_int|NULL
comma
id|BLIST_SPARSELUN
)brace
comma
(brace
l_string|&quot;Zzyzx&quot;
comma
l_string|&quot;RocketStor 2000&quot;
comma
l_int|NULL
comma
id|BLIST_SPARSELUN
)brace
comma
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;TSL&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
)brace
comma
multiline_comment|/* DDS3 &amp; DDS4 autoloaders */
(brace
l_string|&quot;DELL&quot;
comma
l_string|&quot;PERCRAID&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;HP&quot;
comma
l_string|&quot;NetRAID-4M&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;ADAPTEC&quot;
comma
l_string|&quot;AACRAID&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;ADAPTEC&quot;
comma
l_string|&quot;Adaptec 5400S&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;COMPAQ&quot;
comma
l_string|&quot;MSA1000&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;HP&quot;
comma
l_string|&quot;C1557A&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_string|&quot;IBM&quot;
comma
l_string|&quot;AuSaV1S2&quot;
comma
l_int|NULL
comma
id|BLIST_FORCELUN
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
)brace
comma
)brace
suffix:semicolon
DECL|macro|ALLOC_FAILURE_MSG
mdefine_line|#define ALLOC_FAILURE_MSG&t;KERN_ERR &quot;%s: Allocation failure during&quot; &bslash;&n;&t;&quot; SCSI scanning, some SCSI devices might not be configured&bslash;n&quot;
multiline_comment|/*&n; * Prefix values for the SCSI id&squot;s (stored in driverfs name field)&n; */
DECL|macro|SCSI_UID_SER_NUM
mdefine_line|#define SCSI_UID_SER_NUM &squot;S&squot;
DECL|macro|SCSI_UID_UNKNOWN
mdefine_line|#define SCSI_UID_UNKNOWN &squot;Z&squot;
multiline_comment|/*&n; * Return values of some of the scanning functions.&n; *&n; * SCSI_SCAN_NO_RESPONSE: no valid response received from the target, this&n; * includes allocation or general failures preventing IO from being sent.&n; *&n; * SCSI_SCAN_TARGET_PRESENT: target responded, but no device is available&n; * on the given LUN.&n; *&n; * SCSI_SCAN_LUN_PRESENT: target responded, and a device is available on a&n; * given LUN.&n; */
DECL|macro|SCSI_SCAN_NO_RESPONSE
mdefine_line|#define SCSI_SCAN_NO_RESPONSE&t;&t;0
DECL|macro|SCSI_SCAN_TARGET_PRESENT
mdefine_line|#define SCSI_SCAN_TARGET_PRESENT&t;1
DECL|macro|SCSI_SCAN_LUN_PRESENT
mdefine_line|#define SCSI_SCAN_LUN_PRESENT&t;&t;2
DECL|variable|scsi_null_device_strs
r_static
r_char
op_star
id|scsi_null_device_strs
op_assign
l_string|&quot;nullnullnullnull&quot;
suffix:semicolon
DECL|macro|MAX_SCSI_LUNS
mdefine_line|#define MAX_SCSI_LUNS&t;512
macro_line|#ifdef CONFIG_SCSI_MULTI_LUN
DECL|variable|max_scsi_luns
r_static
r_int
r_int
id|max_scsi_luns
op_assign
id|MAX_SCSI_LUNS
suffix:semicolon
macro_line|#else
DECL|variable|max_scsi_luns
r_static
r_int
r_int
id|max_scsi_luns
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
macro_line|#ifdef MODULE
id|MODULE_PARM
c_func
(paren
id|max_scsi_luns
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|max_scsi_luns
comma
l_string|&quot;last scsi LUN (should be between 1 and 2^32-1)&quot;
)paren
suffix:semicolon
macro_line|#else
DECL|function|scsi_luns_setup
r_static
r_int
id|__init
id|scsi_luns_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|get_option
c_func
(paren
op_amp
id|str
comma
op_amp
id|tmp
)paren
op_eq
l_int|1
)paren
(brace
id|max_scsi_luns
op_assign
id|tmp
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi_luns_setup: usage max_scsi_luns=n &quot;
l_string|&quot;(n should be between 1 and 2^32-1)&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|__setup
c_func
(paren
l_string|&quot;max_scsi_luns=&quot;
comma
id|scsi_luns_setup
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_SCSI_REPORT_LUNS
multiline_comment|/*&n; * max_scsi_report_luns: the maximum number of LUNS that will be&n; * returned from the REPORT LUNS command. 8 times this value must&n; * be allocated. In theory this could be up to an 8 byte value, but&n; * in practice, the maximum number of LUNs suppored by any device&n; * is about 16k.&n; */
DECL|variable|max_scsi_report_luns
r_static
r_int
r_int
id|max_scsi_report_luns
op_assign
l_int|128
suffix:semicolon
macro_line|#ifdef MODULE
id|MODULE_PARM
c_func
(paren
id|max_scsi_report_luns
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|max_scsi_report_luns
comma
l_string|&quot;REPORT LUNS maximum number of LUNS received (should be&quot;
l_string|&quot; between 1 and 16384)&quot;
)paren
suffix:semicolon
macro_line|#else
DECL|function|scsi_report_luns_setup
r_static
r_int
id|__init
id|scsi_report_luns_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|get_option
c_func
(paren
op_amp
id|str
comma
op_amp
id|tmp
)paren
op_eq
l_int|1
)paren
(brace
id|max_scsi_report_luns
op_assign
id|tmp
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi_report_luns_setup: usage&quot;
l_string|&quot; max_scsi_report_luns=n (n should be between 1&quot;
l_string|&quot; and 16384)&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|__setup
c_func
(paren
l_string|&quot;max_scsi_report_luns=&quot;
comma
id|scsi_report_luns_setup
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
multiline_comment|/**&n; * scsi_unlock_floptical - unlock device via a special MODE SENSE command&n; * @sreq:&t;used to send the command&n; * @result:&t;area to store the result of the MODE SENSE&n; *&n; * Description:&n; *     Send a vendor specific MODE SENSE (not a MODE SELECT) command using&n; *     @sreq to unlock a device, storing the (unused) results into result.&n; *     Called for BLIST_KEY devices.&n; **/
DECL|function|scsi_unlock_floptical
r_static
r_void
id|scsi_unlock_floptical
c_func
(paren
id|Scsi_Request
op_star
id|sreq
comma
r_int
r_char
op_star
id|result
)paren
(brace
r_int
r_char
id|scsi_cmd
(braket
id|MAX_COMMAND_SIZE
)braket
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;scsi: unlocking floptical drive&bslash;n&quot;
)paren
suffix:semicolon
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|MODE_SENSE
suffix:semicolon
id|scsi_cmd
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|2
)braket
op_assign
l_int|0x2e
suffix:semicolon
id|scsi_cmd
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
l_int|0x2a
suffix:semicolon
multiline_comment|/* size */
id|scsi_cmd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_cmd_len
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_data_direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
id|scsi_wait_req
c_func
(paren
id|sreq
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|result
comma
l_int|0x2a
multiline_comment|/* size */
comma
id|SCSI_TIMEOUT
comma
l_int|3
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_device_type_read - copy out the SCSI type&n; * @driverfs_dev:&t;driverfs device to check&n; * @page:&t;&t;copy data into this area&n; * @count:&t;&t;number of bytes to copy&n; * @off:&t;&t;start at this offset in page&n; *&n; * Description:&n; *     Called via driverfs when the &quot;type&quot; (in scsi_device_type_file)&n; *     field is read. Copy the appropriate SCSI type string into @page,&n; *     followed by a newline and a &squot;&bslash;0&squot;. Go through gyrations so we don&squot;t&n; *     write more than @count, and we don&squot;t write past @off.&n; *&n; * Notes:&n; *     This is for the top-most scsi entry in driverfs, the upper-level&n; *     drivers have their own type file. XXX This is not part of scanning,&n; *     other than we reference the attr struct in this file, move to&n; *     scsi.c or scsi_lib.c.&n; *&n; * Return:&n; *     number of bytes written into page.&n; **/
DECL|function|scsi_device_type_read
r_static
id|ssize_t
id|scsi_device_type_read
c_func
(paren
r_struct
id|device
op_star
id|driverfs_dev
comma
r_char
op_star
id|page
comma
r_int
id|count
comma
id|loff_t
id|off
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
op_assign
id|to_scsi_device
c_func
(paren
id|driverfs_dev
)paren
suffix:semicolon
r_const
r_char
op_star
id|type
suffix:semicolon
r_int
id|size
comma
id|len
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sdev-&gt;type
OG
id|MAX_SCSI_DEVICE_CODE
)paren
op_logical_or
(paren
id|scsi_device_types
(braket
(paren
r_int
)paren
id|sdev-&gt;type
)braket
op_eq
l_int|NULL
)paren
)paren
id|type
op_assign
l_string|&quot;Unknown&quot;
suffix:semicolon
r_else
id|type
op_assign
id|scsi_device_types
(braket
(paren
r_int
)paren
id|sdev-&gt;type
)braket
suffix:semicolon
id|size
op_assign
id|strlen
c_func
(paren
id|type
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check if off is past size + 1 for newline + 1 for a &squot;&bslash;0&squot;.&n;&t; */
r_if
c_cond
(paren
id|off
op_ge
(paren
id|size
op_plus
l_int|2
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|off
)paren
(brace
id|len
op_assign
id|min
c_func
(paren
(paren
r_int
)paren
(paren
id|size
op_minus
id|off
)paren
comma
id|count
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|page
op_plus
id|off
comma
id|type
op_plus
id|off
comma
id|len
)paren
suffix:semicolon
)brace
r_else
id|len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|len
op_plus
id|off
)paren
op_eq
id|size
)paren
op_logical_and
(paren
id|len
OL
id|count
)paren
)paren
multiline_comment|/*&n;&t;&t; * We are at the end of the string and have space, add a&n;&t;&t; * new line.&n;&t;&t; */
op_star
(paren
id|page
op_plus
id|off
op_plus
id|len
op_increment
)paren
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|len
op_plus
id|off
)paren
op_eq
(paren
id|size
op_plus
l_int|1
)paren
)paren
op_logical_and
(paren
id|len
OL
id|count
)paren
)paren
multiline_comment|/*&n;&t;&t; * We are past the newline and have space, add a&n;&t;&t; * terminating &squot;&bslash;0&squot;.&n;&t;&t; */
op_star
(paren
id|page
op_plus
id|off
op_plus
id|len
op_increment
)paren
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; * Create dev_attr_type. This is different from the dev_attr_type in scsi&n; * upper level drivers.&n; */
r_static
id|DEVICE_ATTR
c_func
(paren
id|type
comma
id|S_IRUGO
comma
id|scsi_device_type_read
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/**&n; * print_inquiry - printk the inquiry information&n; * @inq_result:&t;printk this SCSI INQUIRY&n; *&n; * Description:&n; *     printk the vendor, model, and other information found in the&n; *     INQUIRY data in @inq_result.&n; *&n; * Notes:&n; *     Remove this, and replace with a hotplug event that logs any&n; *     relevant information.&n; **/
DECL|function|print_inquiry
r_static
r_void
id|print_inquiry
c_func
(paren
r_int
r_char
op_star
id|inq_result
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;  Vendor: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|8
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|inq_result
(braket
id|i
)braket
op_ge
l_int|0x20
op_logical_and
id|i
OL
id|inq_result
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|inq_result
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  Model: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|16
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|inq_result
(braket
id|i
)braket
op_ge
l_int|0x20
op_logical_and
id|i
OL
id|inq_result
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|inq_result
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  Rev: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|32
suffix:semicolon
id|i
OL
l_int|36
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|inq_result
(braket
id|i
)braket
op_ge
l_int|0x20
op_logical_and
id|i
OL
id|inq_result
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|inq_result
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|i
op_assign
id|inq_result
(braket
l_int|0
)braket
op_amp
l_int|0x1f
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;  Type:   %s &quot;
comma
id|i
OL
id|MAX_SCSI_DEVICE_CODE
ques
c_cond
id|scsi_device_types
(braket
id|i
)braket
suffix:colon
l_string|&quot;Unknown          &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;                 ANSI SCSI revision: %02x&quot;
comma
id|inq_result
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inq_result
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
op_eq
l_int|1
op_logical_and
(paren
id|inq_result
(braket
l_int|3
)braket
op_amp
l_int|0x0f
)paren
op_eq
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot; CCS&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_initialize_merge_fn() -&#x1a3;initialize merge function for a host&n; * @sd:&t;&t;host descriptor&n; */
DECL|function|scsi_initialize_merge_fn
r_static
r_void
id|scsi_initialize_merge_fn
c_func
(paren
r_struct
id|scsi_device
op_star
id|sd
)paren
(brace
id|request_queue_t
op_star
id|q
op_assign
op_amp
id|sd-&gt;request_queue
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|sh
op_assign
id|sd-&gt;host
suffix:semicolon
id|u64
id|bounce_limit
suffix:semicolon
r_if
c_cond
(paren
id|sh-&gt;highmem_io
)paren
(brace
r_if
c_cond
(paren
id|sh-&gt;pci_dev
op_logical_and
id|PCI_DMA_BUS_IS_PHYS
)paren
(brace
id|bounce_limit
op_assign
id|sh-&gt;pci_dev-&gt;dma_mask
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Platforms with virtual-DMA translation&n; &t;&t;&t; * hardware have no practical limit.&n;&t;&t;&t; */
id|bounce_limit
op_assign
id|BLK_BOUNCE_ANY
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|sh-&gt;unchecked_isa_dma
)paren
(brace
id|bounce_limit
op_assign
id|BLK_BOUNCE_ISA
suffix:semicolon
)brace
r_else
(brace
id|bounce_limit
op_assign
id|BLK_BOUNCE_HIGH
suffix:semicolon
)brace
id|blk_queue_bounce_limit
c_func
(paren
id|q
comma
id|bounce_limit
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_alloc_sdev - allocate and setup a Scsi_Device&n; *&n; * Description:&n; *     Allocate, initialize for io, and return a pointer to a Scsi_Device.&n; *     Stores the @shost, @channel, @id, and @lun in the Scsi_Device, and&n; *     adds Scsi_Device to the appropriate list.&n; *&n; * Return value:&n; *     Scsi_Device pointer, or NULL on failure.&n; **/
DECL|function|scsi_alloc_sdev
r_struct
id|scsi_device
op_star
id|scsi_alloc_sdev
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
comma
id|uint
id|channel
comma
id|uint
id|id
comma
id|uint
id|lun
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
comma
op_star
id|device
suffix:semicolon
id|sdev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|sdev
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev
op_eq
l_int|NULL
)paren
id|printk
c_func
(paren
id|ALLOC_FAILURE_MSG
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_else
(brace
id|memset
c_func
(paren
id|sdev
comma
l_int|0
comma
r_sizeof
(paren
id|Scsi_Device
)paren
)paren
suffix:semicolon
id|sdev-&gt;vendor
op_assign
id|scsi_null_device_strs
suffix:semicolon
id|sdev-&gt;model
op_assign
id|scsi_null_device_strs
suffix:semicolon
id|sdev-&gt;rev
op_assign
id|scsi_null_device_strs
suffix:semicolon
id|sdev-&gt;host
op_assign
id|shost
suffix:semicolon
id|sdev-&gt;id
op_assign
id|id
suffix:semicolon
id|sdev-&gt;lun
op_assign
id|lun
suffix:semicolon
id|sdev-&gt;channel
op_assign
id|channel
suffix:semicolon
id|sdev-&gt;online
op_assign
id|TRUE
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sdev-&gt;siblings
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|sdev-&gt;same_target_siblings
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Some low level driver could use device-&gt;type&n;&t;&t; */
id|sdev-&gt;type
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Assume that the device will have handshaking problems,&n;&t;&t; * and then fix this field later if it turns out it&n;&t;&t; * doesn&squot;t&n;&t;&t; */
id|sdev-&gt;borken
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|shost-&gt;hostt-&gt;slave_alloc
)paren
r_if
c_cond
(paren
id|shost-&gt;hostt
op_member_access_from_pointer
id|slave_alloc
c_func
(paren
id|sdev
)paren
)paren
(brace
id|kfree
c_func
(paren
id|sdev
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|scsi_initialize_queue
c_func
(paren
id|sdev
comma
id|shost
)paren
suffix:semicolon
id|sdev-&gt;request_queue.queuedata
op_assign
(paren
r_void
op_star
)paren
id|sdev
suffix:semicolon
id|scsi_initialize_merge_fn
c_func
(paren
id|sdev
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|sdev-&gt;scpnt_wait
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Add it to the end of the shost-&gt;host_queue list.&n;&t;&t; */
r_if
c_cond
(paren
id|shost-&gt;host_queue
op_ne
l_int|NULL
)paren
(brace
id|sdev-&gt;prev
op_assign
id|shost-&gt;host_queue
suffix:semicolon
r_while
c_loop
(paren
id|sdev-&gt;prev-&gt;next
op_ne
l_int|NULL
)paren
id|sdev-&gt;prev
op_assign
id|sdev-&gt;prev-&gt;next
suffix:semicolon
id|sdev-&gt;prev-&gt;next
op_assign
id|sdev
suffix:semicolon
)brace
r_else
id|shost-&gt;host_queue
op_assign
id|sdev
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|device
comma
op_amp
id|shost-&gt;my_devices
comma
id|siblings
)paren
(brace
r_if
c_cond
(paren
id|device-&gt;id
op_eq
id|sdev-&gt;id
op_logical_and
id|device-&gt;channel
op_eq
id|sdev-&gt;channel
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
id|sdev-&gt;same_target_siblings
comma
op_amp
id|device-&gt;same_target_siblings
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|list_add_tail
c_func
(paren
op_amp
id|sdev-&gt;siblings
comma
op_amp
id|shost-&gt;my_devices
)paren
suffix:semicolon
)brace
r_return
(paren
id|sdev
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_free_sdev - cleanup and free a Scsi_Device&n; * @sdev:&t;cleanup and free this Scsi_Device&n; *&n; * Description:&n; *     Undo the actions in scsi_alloc_sdev, including removing @sdev from&n; *     the list, and freeing @sdev.&n; **/
DECL|function|scsi_free_sdev
r_void
id|scsi_free_sdev
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
)paren
(brace
r_if
c_cond
(paren
id|sdev-&gt;prev
op_ne
l_int|NULL
)paren
id|sdev-&gt;prev-&gt;next
op_assign
id|sdev-&gt;next
suffix:semicolon
r_else
id|sdev-&gt;host-&gt;host_queue
op_assign
id|sdev-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;next
op_ne
l_int|NULL
)paren
id|sdev-&gt;next-&gt;prev
op_assign
id|sdev-&gt;prev
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|sdev-&gt;siblings
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|sdev-&gt;same_target_siblings
)paren
suffix:semicolon
id|blk_cleanup_queue
c_func
(paren
op_amp
id|sdev-&gt;request_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;host-&gt;hostt-&gt;slave_destroy
)paren
id|sdev-&gt;host-&gt;hostt
op_member_access_from_pointer
id|slave_destroy
c_func
(paren
id|sdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;inquiry
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|sdev-&gt;inquiry
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sdev
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_check_id_size - check if size fits in the driverfs name&n; * @sdev:&t;Scsi_Device to use for error message&n; * @size:&t;the length of the id we want to store&n; *&n; * Description:&n; *     Use a function for this since the same code is used in various&n; *     places, and we only create one string and call to printk.&n; *&n; * Return:&n; *     0 - fits&n; *     1 - size too large&n; **/
DECL|function|scsi_check_id_size
r_static
r_int
id|scsi_check_id_size
c_func
(paren
id|Scsi_Device
op_star
id|sdev
comma
r_int
id|size
)paren
(brace
r_if
c_cond
(paren
id|size
OG
id|DEVICE_NAME_SIZE
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi scan: host %d channel %d id %d lun %d&quot;
l_string|&quot; identifier too long, length %d, max %d. Device might&quot;
l_string|&quot; be improperly identified.&bslash;n&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
comma
id|size
comma
id|DEVICE_NAME_SIZE
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_get_evpd_page - get a list of supported vpd pages&n; * @sdev:&t;Scsi_Device to send an INQUIRY VPD&n; * @sreq:&t;Scsi_Request associated with @sdev&n; *&n; * Description:&n; *     Get SCSI INQUIRY Vital Product Data page 0 - a list of supported&n; *     VPD pages.&n; *&n; * Return:&n; *     A pointer to data containing the results on success, else NULL.&n; **/
DECL|function|scsi_get_evpd_page
r_int
r_char
op_star
id|scsi_get_evpd_page
c_func
(paren
id|Scsi_Device
op_star
id|sdev
comma
id|Scsi_Request
op_star
id|sreq
)paren
(brace
r_int
r_char
op_star
id|evpd_page
suffix:semicolon
r_int
r_char
id|scsi_cmd
(braket
id|MAX_COMMAND_SIZE
)braket
suffix:semicolon
r_int
id|max_lgth
op_assign
l_int|255
suffix:semicolon
id|retry
suffix:colon
id|evpd_page
op_assign
id|kmalloc
c_func
(paren
id|max_lgth
comma
id|GFP_ATOMIC
op_or
(paren
id|sdev-&gt;host-&gt;unchecked_isa_dma
)paren
ques
c_cond
id|GFP_DMA
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|evpd_page
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi scan: Allocation failure identifying&quot;
l_string|&quot; host %d channel %d id %d lun %d, device might be&quot;
l_string|&quot; improperly identified.&bslash;n&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|scsi_cmd
comma
l_int|0
comma
id|MAX_COMMAND_SIZE
)paren
suffix:semicolon
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|INQUIRY
suffix:semicolon
id|scsi_cmd
(braket
l_int|1
)braket
op_assign
l_int|0x01
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
id|max_lgth
suffix:semicolon
id|sreq-&gt;sr_cmd_len
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_sense_buffer
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_sense_buffer
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_data_direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
id|scsi_wait_req
c_func
(paren
id|sreq
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|evpd_page
comma
id|max_lgth
comma
id|SCSI_TIMEOUT
op_plus
l_int|4
op_star
id|HZ
comma
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sreq-&gt;sr_result
)paren
(brace
id|kfree
c_func
(paren
id|evpd_page
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * check to see if response was truncated&n;&t; */
r_if
c_cond
(paren
id|evpd_page
(braket
l_int|3
)braket
OG
id|max_lgth
)paren
(brace
id|max_lgth
op_assign
id|evpd_page
(braket
l_int|3
)braket
op_plus
l_int|4
suffix:semicolon
id|kfree
c_func
(paren
id|evpd_page
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Some ill behaved devices return the standard inquiry here&n;&t; * rather than the evpd data, snoop the data to verify.&n;&t; */
r_if
c_cond
(paren
id|evpd_page
(braket
l_int|3
)braket
OG
l_int|16
)paren
(brace
multiline_comment|/*&n;&t;&t; * If the vendor id appears in the evpd page assume the&n;&t;&t; * page is invalid.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
op_amp
id|evpd_page
(braket
l_int|8
)braket
comma
id|sdev-&gt;vendor
comma
l_int|8
)paren
)paren
(brace
id|kfree
c_func
(paren
id|evpd_page
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
id|evpd_page
suffix:semicolon
)brace
multiline_comment|/*&n; * INQUIRY VPD page 0x83 identifier descriptor related values. Reference the&n; * SCSI Primary Commands specification for details.&n; *&n; * XXX The following defines should be in scsi.h&n; */
multiline_comment|/*&n; * id type values of id descriptors. These are assumed to fit in 4 bits,&n; * else the code using hex_str[id_type] needs modification.&n; */
DECL|macro|SCSI_ID_VENDOR_SPECIFIC
mdefine_line|#define SCSI_ID_VENDOR_SPECIFIC&t;0
DECL|macro|SCSI_ID_T10_VENDOR
mdefine_line|#define SCSI_ID_T10_VENDOR&t;1
DECL|macro|SCSI_ID_EUI_64
mdefine_line|#define SCSI_ID_EUI_64&t;&t;2
DECL|macro|SCSI_ID_NAA
mdefine_line|#define SCSI_ID_NAA&t;&t;3
multiline_comment|/*&n; * Supported NAA values. These fit in 4 bits, so the don&squot;t care value&n; * cannot conflict with real values.&n; *&n; */
DECL|macro|SCSI_ID_NAA_DONT_CARE
mdefine_line|#define&t;SCSI_ID_NAA_DONT_CARE&t;&t;0xff
DECL|macro|SCSI_ID_NAA_IEEE_REG
mdefine_line|#define&t;SCSI_ID_NAA_IEEE_REG&t;&t;5
DECL|macro|SCSI_ID_NAA_IEEE_REG_EXTENDED
mdefine_line|#define&t;SCSI_ID_NAA_IEEE_REG_EXTENDED&t;6
multiline_comment|/*&n; * Supported Code Set values.&n; */
DECL|macro|SCSI_ID_BINARY
mdefine_line|#define&t;SCSI_ID_BINARY&t;1
DECL|macro|SCSI_ID_ASCII
mdefine_line|#define&t;SCSI_ID_ASCII&t;2
multiline_comment|/*&n; * Use a priority based list of id, naa, and binary/ascii for the&n; * identifier descriptor in VPD page 0x83.&n; *&n; * Brute force search for a match starting with the first value in&n; * id_search_list. This is not a performance issue, since there&n; * is normally one or some small number of descriptors.&n; */
DECL|struct|scsi_id_search_values
r_struct
id|scsi_id_search_values
(brace
DECL|member|id_type
r_int
id|id_type
suffix:semicolon
DECL|member|naa_type
r_int
id|naa_type
suffix:semicolon
DECL|member|code_set
r_int
id|code_set
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|id_search_list
r_static
r_const
r_struct
id|scsi_id_search_values
id|id_search_list
(braket
)braket
op_assign
(brace
(brace
id|SCSI_ID_NAA
comma
id|SCSI_ID_NAA_IEEE_REG_EXTENDED
comma
id|SCSI_ID_BINARY
)brace
comma
(brace
id|SCSI_ID_NAA
comma
id|SCSI_ID_NAA_IEEE_REG_EXTENDED
comma
id|SCSI_ID_ASCII
)brace
comma
(brace
id|SCSI_ID_NAA
comma
id|SCSI_ID_NAA_IEEE_REG
comma
id|SCSI_ID_BINARY
)brace
comma
(brace
id|SCSI_ID_NAA
comma
id|SCSI_ID_NAA_IEEE_REG
comma
id|SCSI_ID_ASCII
)brace
comma
multiline_comment|/*&n;&t; * Devices already exist using NAA values that are now marked&n;&t; * reserved. These should not conflict with other values, or it is&n;&t; * a bug in the device. As long as we find the IEEE extended one&n;&t; * first, we really don&squot;t care what other ones are used. Using&n;&t; * don&squot;t care here means that a device that returns multiple&n;&t; * non-IEEE descriptors in a random order will get different&n;&t; * names.&n;&t; */
(brace
id|SCSI_ID_NAA
comma
id|SCSI_ID_NAA_DONT_CARE
comma
id|SCSI_ID_BINARY
)brace
comma
(brace
id|SCSI_ID_NAA
comma
id|SCSI_ID_NAA_DONT_CARE
comma
id|SCSI_ID_ASCII
)brace
comma
(brace
id|SCSI_ID_EUI_64
comma
id|SCSI_ID_NAA_DONT_CARE
comma
id|SCSI_ID_BINARY
)brace
comma
(brace
id|SCSI_ID_EUI_64
comma
id|SCSI_ID_NAA_DONT_CARE
comma
id|SCSI_ID_ASCII
)brace
comma
(brace
id|SCSI_ID_T10_VENDOR
comma
id|SCSI_ID_NAA_DONT_CARE
comma
id|SCSI_ID_BINARY
)brace
comma
(brace
id|SCSI_ID_T10_VENDOR
comma
id|SCSI_ID_NAA_DONT_CARE
comma
id|SCSI_ID_ASCII
)brace
comma
(brace
id|SCSI_ID_VENDOR_SPECIFIC
comma
id|SCSI_ID_NAA_DONT_CARE
comma
id|SCSI_ID_BINARY
)brace
comma
(brace
id|SCSI_ID_VENDOR_SPECIFIC
comma
id|SCSI_ID_NAA_DONT_CARE
comma
id|SCSI_ID_ASCII
)brace
comma
)brace
suffix:semicolon
multiline_comment|/**&n; * scsi_check_fill_deviceid - check the id and if OK fill it&n; * @sdev:&t;device to use for error messages&n; * @id_page:&t;id descriptor for INQUIRY VPD DEVICE ID, page 0x83&n; * @name:&t;store the id in name&n; * @id_search:&t;store if the id_page matches these values&n; *&n; * Description:&n; *     Check if @id_page matches the @id_search, if so store an id (uid)&n; *     into name.&n; *&n; * Return:&n; *     0: Success&n; *     1: No match&n; *     2: Failure due to size constraints&n; **/
DECL|function|scsi_check_fill_deviceid
r_static
r_int
id|scsi_check_fill_deviceid
c_func
(paren
id|Scsi_Device
op_star
id|sdev
comma
r_char
op_star
id|id_page
comma
r_char
op_star
id|name
comma
r_const
r_struct
id|scsi_id_search_values
op_star
id|id_search
)paren
(brace
r_static
r_const
r_char
id|hex_str
(braket
)braket
op_assign
l_string|&quot;0123456789abcdef&quot;
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
multiline_comment|/*&n;&t; * ASSOCIATION must be with the device (value 0)&n;&t; */
r_if
c_cond
(paren
(paren
id|id_page
(braket
l_int|1
)braket
op_amp
l_int|0x30
)paren
op_ne
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id_page
(braket
l_int|1
)braket
op_amp
l_int|0x0f
)paren
op_ne
id|id_search-&gt;id_type
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Possibly check NAA sub-type.&n;&t; */
r_if
c_cond
(paren
(paren
id|id_search-&gt;naa_type
op_ne
id|SCSI_ID_NAA_DONT_CARE
)paren
op_logical_and
(paren
id|id_search-&gt;naa_type
op_ne
(paren
id|id_page
(braket
l_int|4
)braket
op_amp
l_int|0xf0
)paren
op_rshift
l_int|4
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check for matching code set - ASCII or BINARY.&n;&t; */
r_if
c_cond
(paren
(paren
id|id_page
(braket
l_int|0
)braket
op_amp
l_int|0x0f
)paren
op_ne
id|id_search-&gt;code_set
)paren
r_return
l_int|1
suffix:semicolon
id|name
(braket
l_int|0
)braket
op_assign
id|hex_str
(braket
id|id_search-&gt;id_type
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id_page
(braket
l_int|0
)braket
op_amp
l_int|0x0f
)paren
op_eq
id|SCSI_ID_ASCII
)paren
(brace
multiline_comment|/*&n;&t;&t; * ASCII descriptor.&n;&t;&t; */
r_if
c_cond
(paren
id|id_search-&gt;id_type
op_eq
id|SCSI_ID_VENDOR_SPECIFIC
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Prepend the vendor and model before the id,&n;&t;&t;&t; * since the id might not be unique across all&n;&t;&t;&t; * vendors and models. The same code is used&n;&t;&t;&t; * below, with a differnt size.&n;&t;&t;&t; *&n;&t;&t;&t; * Need 1 byte for the idtype, 1 for trailing&n;&t;&t;&t; * &squot;&bslash;0&squot;, 8 for vendor, 16 for model total 26, plus&n;&t;&t;&t; * the name descriptor length.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|scsi_check_id_size
c_func
(paren
id|sdev
comma
l_int|26
op_plus
id|id_page
(braket
l_int|3
)braket
)paren
)paren
r_return
l_int|2
suffix:semicolon
r_else
(brace
id|strncat
c_func
(paren
id|name
comma
id|sdev-&gt;vendor
comma
l_int|8
)paren
suffix:semicolon
id|strncat
c_func
(paren
id|name
comma
id|sdev-&gt;model
comma
l_int|16
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|scsi_check_id_size
(paren
id|sdev
comma
(paren
l_int|2
op_plus
id|id_page
(braket
l_int|3
)braket
)paren
)paren
)paren
multiline_comment|/*&n;&t;&t;&t; * Need 1 byte for the idtype, 1 byte for&n;&t;&t;&t; * the trailing &squot;&bslash;0&squot;, plus the descriptor length.&n;&t;&t;&t; */
r_return
l_int|2
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|name
(braket
id|strlen
c_func
(paren
id|name
)paren
)braket
comma
op_amp
id|id_page
(braket
l_int|4
)braket
comma
id|id_page
(braket
l_int|3
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|id_page
(braket
l_int|0
)braket
op_amp
l_int|0x0f
)paren
op_eq
id|SCSI_ID_BINARY
)paren
(brace
r_if
c_cond
(paren
id|id_search-&gt;id_type
op_eq
id|SCSI_ID_VENDOR_SPECIFIC
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Prepend the vendor and model before the id.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|scsi_check_id_size
c_func
(paren
id|sdev
comma
l_int|26
op_plus
(paren
id|id_page
(braket
l_int|3
)braket
op_star
l_int|2
)paren
)paren
)paren
r_return
l_int|2
suffix:semicolon
r_else
(brace
id|strncat
c_func
(paren
id|name
comma
id|sdev-&gt;vendor
comma
l_int|8
)paren
suffix:semicolon
id|strncat
c_func
(paren
id|name
comma
id|sdev-&gt;model
comma
l_int|16
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|scsi_check_id_size
c_func
(paren
id|sdev
comma
l_int|2
op_plus
(paren
id|id_page
(braket
l_int|3
)braket
op_star
l_int|2
)paren
)paren
)paren
multiline_comment|/*&n;&t;&t;&t; * Need 1 byte for the idtype, 1 for trailing&n;&t;&t;&t; * &squot;&bslash;0&squot;, 8 for vendor, 16 for model total 26, plus&n;&t;&t;&t; * the name descriptor length.&n;&t;&t;&t; */
r_return
l_int|2
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Binary descriptor, convert to ASCII, using two bytes of&n;&t;&t; * ASCII for each byte in the id_page. Store starting at&n;&t;&t; * the end of name.&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|4
comma
id|j
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
id|i
OL
l_int|4
op_plus
id|id_page
(braket
l_int|3
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
id|name
(braket
id|j
op_increment
)braket
op_assign
id|hex_str
(braket
(paren
id|id_page
(braket
id|i
)braket
op_amp
l_int|0xf0
)paren
op_rshift
l_int|4
)braket
suffix:semicolon
id|name
(braket
id|j
op_increment
)braket
op_assign
id|hex_str
(braket
id|id_page
(braket
id|i
)braket
op_amp
l_int|0x0f
)braket
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Code set must have already matched.&n;&t; */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;scsi scan: scsi_check_fill_deviceid unexpected state.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_get_deviceid - get a device id using INQUIRY VPD page 0x83&n; * @sdev:&t;get the identifer of this device&n; * @sreq:&t;Scsi_Requeset associated with @sdev&n; *&n; * Description:&n; *     Try to get an id (serial number) for device @sdev using a SCSI&n; *     Vital Product Data page 0x83 (device id).&n; *&n; * Return:&n; *     0: Failure&n; *     1: Success&n; **/
DECL|function|scsi_get_deviceid
r_int
id|scsi_get_deviceid
c_func
(paren
id|Scsi_Device
op_star
id|sdev
comma
id|Scsi_Request
op_star
id|sreq
)paren
(brace
r_int
r_char
op_star
id|id_page
suffix:semicolon
r_int
r_char
id|scsi_cmd
(braket
id|MAX_COMMAND_SIZE
)braket
suffix:semicolon
r_int
id|id_idx
comma
id|scnt
comma
id|ret
suffix:semicolon
r_int
id|max_lgth
op_assign
l_int|255
suffix:semicolon
id|retry
suffix:colon
id|id_page
op_assign
id|kmalloc
c_func
(paren
id|max_lgth
comma
id|GFP_ATOMIC
op_or
(paren
id|sdev-&gt;host-&gt;unchecked_isa_dma
)paren
ques
c_cond
id|GFP_DMA
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|id_page
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi scan: Allocation failure identifying&quot;
l_string|&quot; host %d channel %d id %d lun %d, device might be&quot;
l_string|&quot; improperly identified.&bslash;n&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|memset
c_func
(paren
id|scsi_cmd
comma
l_int|0
comma
id|MAX_COMMAND_SIZE
)paren
suffix:semicolon
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|INQUIRY
suffix:semicolon
id|scsi_cmd
(braket
l_int|1
)braket
op_assign
l_int|0x01
suffix:semicolon
id|scsi_cmd
(braket
l_int|2
)braket
op_assign
l_int|0x83
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
id|max_lgth
suffix:semicolon
id|sreq-&gt;sr_cmd_len
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_sense_buffer
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_sense_buffer
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_data_direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
id|scsi_wait_req
c_func
(paren
id|sreq
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|id_page
comma
id|max_lgth
comma
id|SCSI_TIMEOUT
op_plus
l_int|4
op_star
id|HZ
comma
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sreq-&gt;sr_result
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_goto
id|leave
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * check to see if response was truncated&n;&t; */
r_if
c_cond
(paren
id|id_page
(braket
l_int|3
)braket
OG
id|max_lgth
)paren
(brace
id|max_lgth
op_assign
id|id_page
(braket
l_int|3
)braket
op_plus
l_int|4
suffix:semicolon
id|kfree
c_func
(paren
id|id_page
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Search for a match in the proiritized id_search_list.&n;&t; */
r_for
c_loop
(paren
id|id_idx
op_assign
l_int|0
suffix:semicolon
id|id_idx
OL
id|ARRAY_SIZE
c_func
(paren
id|id_search_list
)paren
suffix:semicolon
id|id_idx
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * Examine each descriptor returned. There is normally only&n;&t;&t; * one or a small number of descriptors.&n;&t;&t; */
r_for
c_loop
(paren
id|scnt
op_assign
l_int|4
suffix:semicolon
id|scnt
op_le
id|id_page
(braket
l_int|3
)braket
op_plus
l_int|3
suffix:semicolon
id|scnt
op_add_assign
id|id_page
(braket
id|scnt
op_plus
l_int|3
)braket
op_plus
l_int|4
)paren
(brace
r_if
c_cond
(paren
(paren
id|scsi_check_fill_deviceid
c_func
(paren
id|sdev
comma
op_amp
id|id_page
(braket
id|scnt
)braket
comma
id|sdev-&gt;sdev_driverfs_dev.name
comma
op_amp
id|id_search_list
(braket
id|id_idx
)braket
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi scan: host %d channel %d id %d lun %d&quot;
l_string|&quot; used id desc %d/%d/%d&bslash;n&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
comma
id|id_search_list
(braket
id|id_idx
)braket
dot
id|id_type
comma
id|id_search_list
(braket
id|id_idx
)braket
dot
id|naa_type
comma
id|id_search_list
(braket
id|id_idx
)braket
dot
id|code_set
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
r_goto
id|leave
suffix:semicolon
)brace
r_else
(brace
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|4
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi scan: host %d channel %d id %d lun %d&quot;
l_string|&quot; no match/error id desc %d/%d/%d&bslash;n&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
comma
id|id_search_list
(braket
id|id_idx
)braket
dot
id|id_type
comma
id|id_search_list
(braket
id|id_idx
)braket
dot
id|naa_type
comma
id|id_search_list
(braket
id|id_idx
)braket
dot
id|code_set
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * scsi_check_fill_deviceid can fill the first&n;&t;&t;&t; * byte of name with a non-zero value, reset it.&n;&t;&t;&t; */
id|sdev-&gt;sdev_driverfs_dev.name
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
)brace
id|ret
op_assign
l_int|0
suffix:semicolon
id|leave
suffix:colon
id|kfree
c_func
(paren
id|id_page
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_get_serialnumber - get a serial number using INQUIRY page 0x80&n; * @sdev:&t;get the serial number of this device&n; * @sreq:&t;Scsi_Requeset associated with @sdev&n; *&n; * Description:&n; *     Send a SCSI INQUIRY page 0x80 to @sdev to get a serial number.&n; *&n; * Return:&n; *     0: Failure&n; *     1: Success&n; **/
DECL|function|scsi_get_serialnumber
r_int
id|scsi_get_serialnumber
c_func
(paren
id|Scsi_Device
op_star
id|sdev
comma
id|Scsi_Request
op_star
id|sreq
)paren
(brace
r_int
r_char
op_star
id|serialnumber_page
suffix:semicolon
r_int
r_char
id|scsi_cmd
(braket
id|MAX_COMMAND_SIZE
)braket
suffix:semicolon
r_int
id|max_lgth
op_assign
l_int|255
suffix:semicolon
id|retry
suffix:colon
id|serialnumber_page
op_assign
id|kmalloc
c_func
(paren
id|max_lgth
comma
id|GFP_ATOMIC
op_or
(paren
id|sdev-&gt;host-&gt;unchecked_isa_dma
)paren
ques
c_cond
id|GFP_DMA
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|serialnumber_page
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi scan: Allocation failure identifying&quot;
l_string|&quot; host %d channel %d id %d lun %d, device might be&quot;
l_string|&quot; improperly identified.&bslash;n&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|memset
c_func
(paren
id|scsi_cmd
comma
l_int|0
comma
id|MAX_COMMAND_SIZE
)paren
suffix:semicolon
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|INQUIRY
suffix:semicolon
id|scsi_cmd
(braket
l_int|1
)braket
op_assign
l_int|0x01
suffix:semicolon
id|scsi_cmd
(braket
l_int|2
)braket
op_assign
l_int|0x80
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
id|max_lgth
suffix:semicolon
id|sreq-&gt;sr_cmd_len
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_sense_buffer
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_sense_buffer
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_data_direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
id|scsi_wait_req
c_func
(paren
id|sreq
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|serialnumber_page
comma
id|max_lgth
comma
id|SCSI_TIMEOUT
op_plus
l_int|4
op_star
id|HZ
comma
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sreq-&gt;sr_result
)paren
r_goto
id|leave
suffix:semicolon
multiline_comment|/*&n;&t; * check to see if response was truncated&n;&t; */
r_if
c_cond
(paren
id|serialnumber_page
(braket
l_int|3
)braket
OG
id|max_lgth
)paren
(brace
id|max_lgth
op_assign
id|serialnumber_page
(braket
l_int|3
)braket
op_plus
l_int|4
suffix:semicolon
id|kfree
c_func
(paren
id|serialnumber_page
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Need 1 byte for SCSI_UID_SER_NUM, 1 for trailing &squot;&bslash;0&squot;, 8 for&n;&t; * vendor, 16 for model = 26, plus serial number size.&n;&t; */
r_if
c_cond
(paren
id|scsi_check_id_size
(paren
id|sdev
comma
(paren
l_int|26
op_plus
id|serialnumber_page
(braket
l_int|3
)braket
)paren
)paren
)paren
r_goto
id|leave
suffix:semicolon
id|sdev-&gt;sdev_driverfs_dev.name
(braket
l_int|0
)braket
op_assign
id|SCSI_UID_SER_NUM
suffix:semicolon
id|strncat
c_func
(paren
id|sdev-&gt;sdev_driverfs_dev.name
comma
id|sdev-&gt;vendor
comma
l_int|8
)paren
suffix:semicolon
id|strncat
c_func
(paren
id|sdev-&gt;sdev_driverfs_dev.name
comma
id|sdev-&gt;model
comma
l_int|16
)paren
suffix:semicolon
id|strncat
c_func
(paren
id|sdev-&gt;sdev_driverfs_dev.name
comma
op_amp
id|serialnumber_page
(braket
l_int|4
)braket
comma
id|serialnumber_page
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|serialnumber_page
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
id|leave
suffix:colon
id|memset
c_func
(paren
id|sdev-&gt;sdev_driverfs_dev.name
comma
l_int|0
comma
id|DEVICE_NAME_SIZE
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|serialnumber_page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_get_default_name - get a default name&n; * @sdev:&t;get a default name for this device&n; *&n; * Description:&n; *     Set the name of @sdev to the concatenation of the vendor, model,&n; *     and revision found in @sdev.&n; *&n; * Return:&n; *     1: Success&n; **/
DECL|function|scsi_get_default_name
r_int
id|scsi_get_default_name
c_func
(paren
id|Scsi_Device
op_star
id|sdev
)paren
(brace
r_if
c_cond
(paren
id|scsi_check_id_size
c_func
(paren
id|sdev
comma
l_int|29
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_else
(brace
id|sdev-&gt;sdev_driverfs_dev.name
(braket
l_int|0
)braket
op_assign
id|SCSI_UID_UNKNOWN
suffix:semicolon
id|strncpy
c_func
(paren
op_amp
id|sdev-&gt;sdev_driverfs_dev.name
(braket
l_int|1
)braket
comma
id|sdev-&gt;vendor
comma
l_int|8
)paren
suffix:semicolon
id|strncat
c_func
(paren
id|sdev-&gt;sdev_driverfs_dev.name
comma
id|sdev-&gt;model
comma
l_int|16
)paren
suffix:semicolon
id|strncat
c_func
(paren
id|sdev-&gt;sdev_driverfs_dev.name
comma
id|sdev-&gt;rev
comma
l_int|4
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * scsi_load_identifier:&n; * @sdev:&t;get an identifier (name) of this device&n; * @sreq:&t;Scsi_Requeset associated with @sdev&n; *&n; * Description:&n; *     Determine what INQUIRY pages are supported by @sdev, and try the&n; *     different pages until we get an identifier, or no other pages are&n; *     left. Start with page 0x83 (device id) and then try page 0x80&n; *     (serial number). If neither of these pages gets an id, use the&n; *     default naming convention.&n; *&n; *     The first character of sdev_driverfs_dev.name is SCSI_UID_SER_NUM&n; *     (S) if we used page 0x80, SCSI_UID_UNKNOWN (Z) if we used the&n; *     default name, otherwise it starts with the page 0x83 id type&n; *     (see the SCSI Primary Commands specification for details).&n; *&n; * Notes:&n; *     If a device returns the same serial number for different LUNs or&n; *     even for different LUNs on different devices, special handling must&n; *     be added to get an id, or a new black list flag must be added (so&n; *     we use the default name, or add a way to prefix the id/name with&n; *     SCSI_UID_UNKNOWN - and change the define to something meaningful&n; *     like SCSI_UID_NOT_UNIQUE). Complete user level scanning would be&n; *     nice for such devices, so we do not need device specific code in&n; *     the kernel.&n; **/
DECL|function|scsi_load_identifier
r_static
r_void
id|scsi_load_identifier
c_func
(paren
id|Scsi_Device
op_star
id|sdev
comma
id|Scsi_Request
op_star
id|sreq
)paren
(brace
r_int
r_char
op_star
id|evpd_page
op_assign
l_int|NULL
suffix:semicolon
r_int
id|cnt
suffix:semicolon
id|memset
c_func
(paren
id|sdev-&gt;sdev_driverfs_dev.name
comma
l_int|0
comma
id|DEVICE_NAME_SIZE
)paren
suffix:semicolon
id|evpd_page
op_assign
id|scsi_get_evpd_page
c_func
(paren
id|sdev
comma
id|sreq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|evpd_page
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * try to obtain serial number anyway&n;&t;&t; */
(paren
r_void
)paren
id|scsi_get_serialnumber
c_func
(paren
id|sdev
comma
id|sreq
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * XXX search high to low, since the pages are lowest to&n;&t;&t; * highest - page 0x83 will be after page 0x80.&n;&t;&t; */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|4
suffix:semicolon
id|cnt
op_le
id|evpd_page
(braket
l_int|3
)braket
op_plus
l_int|3
suffix:semicolon
id|cnt
op_increment
)paren
r_if
c_cond
(paren
id|evpd_page
(braket
id|cnt
)braket
op_eq
l_int|0x83
)paren
r_if
c_cond
(paren
id|scsi_get_deviceid
c_func
(paren
id|sdev
comma
id|sreq
)paren
)paren
r_goto
id|leave
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|4
suffix:semicolon
id|cnt
op_le
id|evpd_page
(braket
l_int|3
)braket
op_plus
l_int|3
suffix:semicolon
id|cnt
op_increment
)paren
r_if
c_cond
(paren
id|evpd_page
(braket
id|cnt
)braket
op_eq
l_int|0x80
)paren
r_if
c_cond
(paren
id|scsi_get_serialnumber
c_func
(paren
id|sdev
comma
id|sreq
)paren
)paren
r_goto
id|leave
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;sdev_driverfs_dev.name
(braket
l_int|0
)braket
op_eq
l_int|0
)paren
id|scsi_get_default_name
c_func
(paren
id|sdev
)paren
suffix:semicolon
)brace
id|leave
suffix:colon
r_if
c_cond
(paren
id|evpd_page
)paren
id|kfree
c_func
(paren
id|evpd_page
)paren
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi scan: host %d channel %d&quot;
l_string|&quot; id %d lun %d name/id: &squot;%s&squot;&bslash;n&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
comma
id|sdev-&gt;sdev_driverfs_dev.name
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_find_scsi_level - return the scsi_level of a matching target&n; *&n; * Description:&n; *     Return the scsi_level of any Scsi_Device matching @channel, @id,&n; *     and @shost.&n; * Notes:&n; *     Needs to issue an INQUIRY to LUN 0 if no Scsi_Device matches, and&n; *     if the INQUIRY can&squot;t be sent return a failure.&n; **/
DECL|function|scsi_find_scsi_level
r_static
r_int
id|scsi_find_scsi_level
c_func
(paren
r_int
r_int
id|channel
comma
r_int
r_int
id|id
comma
r_struct
id|Scsi_Host
op_star
id|shost
)paren
(brace
r_int
id|res
op_assign
id|SCSI_2
suffix:semicolon
id|Scsi_Device
op_star
id|sdev
suffix:semicolon
r_for
c_loop
(paren
id|sdev
op_assign
id|shost-&gt;host_queue
suffix:semicolon
id|sdev
suffix:semicolon
id|sdev
op_assign
id|sdev-&gt;next
)paren
r_if
c_cond
(paren
(paren
id|id
op_eq
id|sdev-&gt;id
)paren
op_logical_and
(paren
id|channel
op_eq
id|sdev-&gt;channel
)paren
)paren
r_return
(paren
r_int
)paren
id|sdev-&gt;scsi_level
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME No matching target id is configured, this needs to get&n;&t; * the INQUIRY for LUN 0, and use it to determine the scsi_level.&n;&t; */
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_probe_lun - probe a single LUN using a SCSI INQUIRY&n; * @sreq:&t;used to send the INQUIRY&n; * @inq_result:&t;area to store the INQUIRY result&n; * @bflags:&t;store any bflags found here&n; *&n; * Description:&n; *     Probe the lun associated with @sreq using a standard SCSI INQUIRY;&n; *&n; *     If the INQUIRY is successful, sreq-&gt;sr_result is zero and: the&n; *     INQUIRY data is in @inq_result; the scsi_level and INQUIRY length&n; *     are copied to the Scsi_Device at @sreq-&gt;sr_device (sdev);&n; *     any flags value is stored in *@bflags.&n; **/
DECL|function|scsi_probe_lun
r_static
r_void
id|scsi_probe_lun
c_func
(paren
id|Scsi_Request
op_star
id|sreq
comma
r_char
op_star
id|inq_result
comma
r_int
op_star
id|bflags
)paren
(brace
id|Scsi_Device
op_star
id|sdev
op_assign
id|sreq-&gt;sr_device
suffix:semicolon
multiline_comment|/* a bit ugly */
r_int
r_char
id|scsi_cmd
(braket
id|MAX_COMMAND_SIZE
)braket
suffix:semicolon
r_int
id|possible_inq_resp_len
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi scan: INQUIRY to host %d&quot;
l_string|&quot; channel %d id %d lun %d&bslash;n&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|scsi_cmd
comma
l_int|0
comma
l_int|6
)paren
suffix:semicolon
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|INQUIRY
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
l_int|36
suffix:semicolon
multiline_comment|/* issue conservative alloc_length */
id|sreq-&gt;sr_cmd_len
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_data_direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
id|memset
c_func
(paren
id|inq_result
comma
l_int|0
comma
l_int|36
)paren
suffix:semicolon
id|scsi_wait_req
c_func
(paren
id|sreq
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|inq_result
comma
l_int|36
comma
id|SCSI_TIMEOUT
op_plus
l_int|4
op_star
id|HZ
comma
l_int|3
)paren
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi scan: 1st INQUIRY %s with&quot;
l_string|&quot; code 0x%x&bslash;n&quot;
comma
id|sreq-&gt;sr_result
ques
c_cond
l_string|&quot;failed&quot;
suffix:colon
l_string|&quot;successful&quot;
comma
id|sreq-&gt;sr_result
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sreq-&gt;sr_result
)paren
(brace
r_if
c_cond
(paren
(paren
id|driver_byte
c_func
(paren
id|sreq-&gt;sr_result
)paren
op_amp
id|DRIVER_SENSE
)paren
op_ne
l_int|0
op_logical_and
(paren
id|sreq-&gt;sr_sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_eq
id|UNIT_ATTENTION
op_logical_and
id|sreq-&gt;sr_sense_buffer
(braket
l_int|12
)braket
op_eq
l_int|0x28
op_logical_and
id|sreq-&gt;sr_sense_buffer
(braket
l_int|13
)braket
op_eq
l_int|0
)paren
(brace
multiline_comment|/* not-ready to ready transition - good */
multiline_comment|/* dpg: bogus? INQUIRY never returns UNIT_ATTENTION */
)brace
r_else
multiline_comment|/*&n;&t;&t;&t; * assume no peripheral if any other sort of error&n;&t;&t;&t; */
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get any flags for this device.&n;&t; *&n;&t; * XXX add a bflags to Scsi_Device, and replace the corresponding&n;&t; * bit fields in Scsi_Device, so bflags need not be passed as an&n;&t; * argument.&n;&t; */
id|BUG_ON
c_func
(paren
id|bflags
op_eq
l_int|NULL
)paren
suffix:semicolon
op_star
id|bflags
op_assign
id|scsi_get_device_flags
c_func
(paren
op_amp
id|inq_result
(braket
l_int|8
)braket
comma
op_amp
id|inq_result
(braket
l_int|16
)braket
)paren
suffix:semicolon
id|possible_inq_resp_len
op_assign
(paren
r_int
r_char
)paren
id|inq_result
(braket
l_int|4
)braket
op_plus
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|BLIST_INQUIRY_36
op_amp
op_star
id|bflags
)paren
id|possible_inq_resp_len
op_assign
l_int|36
suffix:semicolon
r_else
r_if
c_cond
(paren
id|BLIST_INQUIRY_58
op_amp
op_star
id|bflags
)paren
id|possible_inq_resp_len
op_assign
l_int|58
suffix:semicolon
r_else
r_if
c_cond
(paren
id|possible_inq_resp_len
OG
l_int|255
)paren
id|possible_inq_resp_len
op_assign
l_int|36
suffix:semicolon
multiline_comment|/* sanity */
r_if
c_cond
(paren
id|possible_inq_resp_len
OG
l_int|36
)paren
(brace
multiline_comment|/* do additional INQUIRY */
id|memset
c_func
(paren
id|scsi_cmd
comma
l_int|0
comma
l_int|6
)paren
suffix:semicolon
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|INQUIRY
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
(paren
r_int
r_char
)paren
id|possible_inq_resp_len
suffix:semicolon
id|sreq-&gt;sr_cmd_len
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_data_direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
multiline_comment|/*&n;&t;&t; * re-zero inq_result just to be safe.&n;&t;&t; */
id|memset
c_func
(paren
id|inq_result
comma
l_int|0
comma
id|possible_inq_resp_len
)paren
suffix:semicolon
id|scsi_wait_req
c_func
(paren
id|sreq
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|inq_result
comma
id|possible_inq_resp_len
comma
id|SCSI_TIMEOUT
op_plus
l_int|4
op_star
id|HZ
comma
l_int|3
)paren
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi scan: 2nd INQUIRY&quot;
l_string|&quot; %s with code 0x%x&bslash;n&quot;
comma
id|sreq-&gt;sr_result
ques
c_cond
l_string|&quot;failed&quot;
suffix:colon
l_string|&quot;successful&quot;
comma
id|sreq-&gt;sr_result
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sreq-&gt;sr_result
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The INQUIRY can change, this means the length can change.&n;&t;&t; */
id|possible_inq_resp_len
op_assign
(paren
r_int
r_char
)paren
id|inq_result
(braket
l_int|4
)braket
op_plus
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|BLIST_INQUIRY_58
op_amp
op_star
id|bflags
)paren
id|possible_inq_resp_len
op_assign
l_int|58
suffix:semicolon
r_else
r_if
c_cond
(paren
id|possible_inq_resp_len
OG
l_int|255
)paren
id|possible_inq_resp_len
op_assign
l_int|36
suffix:semicolon
multiline_comment|/* sanity */
)brace
id|sdev-&gt;inquiry_len
op_assign
id|possible_inq_resp_len
suffix:semicolon
multiline_comment|/*&n;&t; * XXX Abort if the response length is less than 36? If less than&n;&t; * 32, the lookup of the device flags (above) could be invalid,&n;&t; * and it would be possible to take an incorrect action - we do&n;&t; * not want to hang because of a short INQUIRY. On the flip side,&n;&t; * if the device is spun down or becoming ready (and so it gives a&n;&t; * short INQUIRY), an abort here prevents any further use of the&n;&t; * device, including spin up.&n;&t; *&n;&t; * Related to the above issue:&n;&t; *&n;&t; * XXX Devices (disk or all?) should be sent a TEST UNIT READY,&n;&t; * and if not ready, sent a START_STOP to start (maybe spin up) and&n;&t; * then send the INQUIRY again, since the INQUIRY can change after&n;&t; * a device is initialized.&n;&t; *&n;&t; * Ideally, start a device if explicitly asked to do so.  This&n;&t; * assumes that a device is spun up on power on, spun down on&n;&t; * request, and then spun up on request.&n;&t; */
multiline_comment|/*&n;&t; * The scanning code needs to know the scsi_level, even if no&n;&t; * device is attached at LUN 0 (SCSI_SCAN_TARGET_PRESENT) so&n;&t; * non-zero LUNs can be scanned.&n;&t; */
id|sdev-&gt;scsi_level
op_assign
id|inq_result
(braket
l_int|2
)braket
op_amp
l_int|0x07
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;scsi_level
op_ge
l_int|2
op_logical_or
(paren
id|sdev-&gt;scsi_level
op_eq
l_int|1
op_logical_and
(paren
id|inq_result
(braket
l_int|3
)braket
op_amp
l_int|0x0f
)paren
op_eq
l_int|1
)paren
)paren
id|sdev-&gt;scsi_level
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_add_lun - allocate and fully initialze a Scsi_Device&n; * @sdevscan:&t;holds information to be stored in the new Scsi_Device&n; * @sdevnew:&t;store the address of the newly allocated Scsi_Device&n; * @sreq:&t;scsi request used when getting an identifier&n; * @inq_result:&t;holds the result of a previous INQUIRY to the LUN&n; * @bflags:&t;black/white list flag&n; *&n; * Description:&n; *     Allocate and initialize a Scsi_Device matching sdevscan. Optionally&n; *     set fields based on values in *@bflags. If @sdevnew is not&n; *     NULL, store the address of the new Scsi_Device in *@sdevnew (needed&n; *     when scanning a particular LUN).&n; *&n; * Return:&n; *     SCSI_SCAN_NO_RESPONSE: could not allocate or setup a Scsi_Device&n; *     SCSI_SCAN_LUN_PRESENT: a new Scsi_Device was allocated and initialized&n; **/
DECL|function|scsi_add_lun
r_static
r_int
id|scsi_add_lun
c_func
(paren
id|Scsi_Device
op_star
id|sdevscan
comma
id|Scsi_Device
op_star
op_star
id|sdevnew
comma
id|Scsi_Request
op_star
id|sreq
comma
r_char
op_star
id|inq_result
comma
r_int
op_star
id|bflags
)paren
(brace
id|Scsi_Device
op_star
id|sdev
suffix:semicolon
r_char
id|devname
(braket
l_int|64
)braket
suffix:semicolon
id|sdev
op_assign
id|scsi_alloc_sdev
c_func
(paren
id|sdevscan-&gt;host
comma
id|sdevscan-&gt;channel
comma
id|sdevscan-&gt;id
comma
id|sdevscan-&gt;lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev
op_eq
l_int|NULL
)paren
r_return
id|SCSI_SCAN_NO_RESPONSE
suffix:semicolon
id|sdev-&gt;scsi_level
op_assign
id|sdevscan-&gt;scsi_level
suffix:semicolon
multiline_comment|/*&n;&t; * XXX do not save the inquiry, since it can change underneath us,&n;&t; * save just vendor/model/rev.&n;&t; *&n;&t; * Rather than save it and have an ioctl that retrieves the saved&n;&t; * value, have an ioctl that executes the same INQUIRY code used&n;&t; * in scsi_probe_lun, let user level programs doing INQUIRY&n;&t; * scanning run at their own risk, or supply a user level program&n;&t; * that can correctly scan.&n;&t; */
id|sdev-&gt;inquiry_len
op_assign
id|sdevscan-&gt;inquiry_len
suffix:semicolon
id|sdev-&gt;inquiry
op_assign
id|kmalloc
c_func
(paren
id|sdev-&gt;inquiry_len
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;inquiry
op_eq
l_int|NULL
)paren
(brace
id|scsi_free_sdev
c_func
(paren
id|sdev
)paren
suffix:semicolon
r_return
id|SCSI_SCAN_NO_RESPONSE
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|sdev-&gt;inquiry
comma
id|inq_result
comma
id|sdev-&gt;inquiry_len
)paren
suffix:semicolon
id|sdev-&gt;vendor
op_assign
(paren
r_char
op_star
)paren
(paren
id|sdev-&gt;inquiry
op_plus
l_int|8
)paren
suffix:semicolon
id|sdev-&gt;model
op_assign
(paren
r_char
op_star
)paren
(paren
id|sdev-&gt;inquiry
op_plus
l_int|16
)paren
suffix:semicolon
id|sdev-&gt;rev
op_assign
(paren
r_char
op_star
)paren
(paren
id|sdev-&gt;inquiry
op_plus
l_int|32
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|bflags
op_amp
id|BLIST_ISROM
)paren
(brace
multiline_comment|/*&n;&t;&t; * It would be better to modify sdev-&gt;type, and set&n;&t;&t; * sdev-&gt;removable, but then the print_inquiry() output&n;&t;&t; * would not show TYPE_ROM; if print_inquiry() is removed&n;&t;&t; * the issue goes away.&n;&t;&t; */
id|inq_result
(braket
l_int|0
)braket
op_assign
id|TYPE_ROM
suffix:semicolon
id|inq_result
(braket
l_int|1
)braket
op_or_assign
l_int|0x80
suffix:semicolon
multiline_comment|/* removable */
)brace
r_switch
c_cond
(paren
id|sdev-&gt;type
op_assign
(paren
id|inq_result
(braket
l_int|0
)braket
op_amp
l_int|0x1f
)paren
)paren
(brace
r_case
id|TYPE_TAPE
suffix:colon
r_case
id|TYPE_DISK
suffix:colon
r_case
id|TYPE_PRINTER
suffix:colon
r_case
id|TYPE_MOD
suffix:colon
r_case
id|TYPE_PROCESSOR
suffix:colon
r_case
id|TYPE_SCANNER
suffix:colon
r_case
id|TYPE_MEDIUM_CHANGER
suffix:colon
r_case
id|TYPE_ENCLOSURE
suffix:colon
r_case
id|TYPE_COMM
suffix:colon
id|sdev-&gt;writeable
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_WORM
suffix:colon
r_case
id|TYPE_ROM
suffix:colon
id|sdev-&gt;writeable
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi: unknown device type %d&bslash;n&quot;
comma
id|sdev-&gt;type
)paren
suffix:semicolon
)brace
id|sdev-&gt;random
op_assign
(paren
id|sdev-&gt;type
op_eq
id|TYPE_TAPE
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
id|print_inquiry
c_func
(paren
id|inq_result
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * For a peripheral qualifier (PQ) value of 1 (001b), the SCSI&n;&t; * spec says: The device server is capable of supporting the&n;&t; * specified peripheral device type on this logical unit. However,&n;&t; * the physical device is not currently connected to this logical&n;&t; * unit.&n;&t; *&n;&t; * The above is vague, as it implies that we could treat 001 and&n;&t; * 011 the same. Stay compatible with previous code, and create a&n;&t; * Scsi_Device for a PQ of 1&n;&t; *&n;&t; * XXX Save the PQ field let the upper layers figure out if they&n;&t; * want to attach or not to this device, do not set online FALSE;&n;&t; * otherwise, offline devices still get an sd allocated, and they&n;&t; * use up an sd slot.&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|inq_result
(braket
l_int|0
)braket
op_rshift
l_int|5
)paren
op_amp
l_int|7
)paren
op_eq
l_int|1
)paren
(brace
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi scan: peripheral&quot;
l_string|&quot; qualifier of 1, device offlined&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|sdev-&gt;online
op_assign
id|FALSE
suffix:semicolon
)brace
id|sdev-&gt;removable
op_assign
(paren
l_int|0x80
op_amp
id|inq_result
(braket
l_int|1
)braket
)paren
op_rshift
l_int|7
suffix:semicolon
id|sdev-&gt;lockable
op_assign
id|sdev-&gt;removable
suffix:semicolon
id|sdev-&gt;soft_reset
op_assign
(paren
id|inq_result
(braket
l_int|7
)braket
op_amp
l_int|1
)paren
op_logical_and
(paren
(paren
id|inq_result
(braket
l_int|3
)braket
op_amp
l_int|7
)paren
op_eq
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;scsi_level
op_ge
id|SCSI_3
op_logical_or
(paren
id|sdev-&gt;inquiry_len
OG
l_int|56
op_logical_and
id|inq_result
(braket
l_int|56
)braket
op_amp
l_int|0x04
)paren
)paren
id|sdev-&gt;ppr
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|inq_result
(braket
l_int|7
)braket
op_amp
l_int|0x60
)paren
id|sdev-&gt;wdtr
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|inq_result
(braket
l_int|7
)braket
op_amp
l_int|0x10
)paren
id|sdev-&gt;sdtr
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * XXX maybe move the identifier and driverfs/devfs setup to a new&n;&t; * function, and call them after this function is called.&n;&t; *&n;&t; * scsi_load_identifier is the only reason sreq is needed in this&n;&t; * function.&n;&t; */
id|scsi_load_identifier
c_func
(paren
id|sdev
comma
id|sreq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * create driverfs files&n;&t; */
id|sprintf
c_func
(paren
id|sdev-&gt;sdev_driverfs_dev.bus_id
comma
l_string|&quot;%d:%d:%d:%d&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
)paren
suffix:semicolon
id|sdev-&gt;sdev_driverfs_dev.parent
op_assign
op_amp
id|sdev-&gt;host-&gt;host_driverfs_dev
suffix:semicolon
id|sdev-&gt;sdev_driverfs_dev.bus
op_assign
op_amp
id|scsi_driverfs_bus_type
suffix:semicolon
id|device_register
c_func
(paren
op_amp
id|sdev-&gt;sdev_driverfs_dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Create driverfs file entries&n;&t; */
id|device_create_file
c_func
(paren
op_amp
id|sdev-&gt;sdev_driverfs_dev
comma
op_amp
id|dev_attr_type
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|devname
comma
l_string|&quot;scsi/host%d/bus%d/target%d/lun%d&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;de
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi devfs dir: &bslash;&quot;%s&bslash;&quot; already exists&bslash;n&quot;
comma
id|devname
)paren
suffix:semicolon
r_else
id|sdev-&gt;de
op_assign
id|devfs_mk_dir
c_func
(paren
l_int|NULL
comma
id|devname
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * End driverfs/devfs code.&n;&t; */
r_if
c_cond
(paren
(paren
id|sdev-&gt;scsi_level
op_ge
id|SCSI_2
)paren
op_logical_and
(paren
id|inq_result
(braket
l_int|7
)braket
op_amp
l_int|2
)paren
op_logical_and
op_logical_neg
(paren
op_star
id|bflags
op_amp
id|BLIST_NOTQ
)paren
)paren
id|sdev-&gt;tagged_supported
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Some devices (Texel CD ROM drives) have handshaking problems&n;&t; * when used with the Seagate controllers. borken is initialized&n;&t; * to 1, and then set it to 0 here.&n;&t; */
r_if
c_cond
(paren
(paren
op_star
id|bflags
op_amp
id|BLIST_BORKEN
)paren
op_eq
l_int|0
)paren
id|sdev-&gt;borken
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If we need to allow I/O to only one of the luns attached to&n;&t; * this target id at a time, then we set this flag.&n;&t; */
r_if
c_cond
(paren
op_star
id|bflags
op_amp
id|BLIST_SINGLELUN
)paren
id|sdev-&gt;single_lun
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* if the device needs this changing, it may do so in the detect&n;&t; * function */
id|sdev-&gt;max_device_blocked
op_assign
id|SCSI_DEFAULT_DEVICE_BLOCKED
suffix:semicolon
r_if
c_cond
(paren
id|sdevnew
op_ne
l_int|NULL
)paren
op_star
id|sdevnew
op_assign
id|sdev
suffix:semicolon
r_return
id|SCSI_SCAN_LUN_PRESENT
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_probe_and_add_lun - probe a LUN, if a LUN is found add it&n; * @sdevscan:&t;probe the LUN corresponding to this Scsi_Device&n; * @sdevnew:&t;store the value of any new Scsi_Device allocated&n; * @bflagsp:&t;store bflags here if not NULL&n; *&n; * Description:&n; *     Call scsi_probe_lun, if a LUN with an attached device is found,&n; *     allocate and set it up by calling scsi_add_lun.&n; *&n; * Return:&n; *     SCSI_SCAN_NO_RESPONSE: could not allocate or setup a Scsi_Device&n; *     SCSI_SCAN_TARGET_PRESENT: target responded, but no device is&n; *         attached at the LUN&n; *     SCSI_SCAN_LUN_PRESENT: a new Scsi_Device was allocated and initialized&n; **/
DECL|function|scsi_probe_and_add_lun
r_static
r_int
id|scsi_probe_and_add_lun
c_func
(paren
id|Scsi_Device
op_star
id|sdevscan
comma
id|Scsi_Device
op_star
op_star
id|sdevnew
comma
r_int
op_star
id|bflagsp
)paren
(brace
id|Scsi_Device
op_star
id|sdev
op_assign
l_int|NULL
suffix:semicolon
id|Scsi_Request
op_star
id|sreq
op_assign
l_int|NULL
suffix:semicolon
r_int
r_char
op_star
id|scsi_result
op_assign
l_int|NULL
suffix:semicolon
r_int
id|bflags
suffix:semicolon
r_int
id|res
suffix:semicolon
multiline_comment|/*&n;&t; * Any command blocks allocated are fixed to use sdevscan-&gt;lun,&n;&t; * so they must be allocated and released if sdevscan-&gt;lun&n;&t; * changes.&n;&t; *&n;&t; * XXX optimize and don&squot;t call build/release commandblocks, instead&n;&t; * modify the LUN value of the existing command block - this means&n;&t; * the build/release calls would be moved to the alloc/free of&n;&t; * sdevscan, and the modifying function would be called here.&n;&t; *&n;&t; * XXX maybe change scsi_release_commandblocks to not reset&n;&t; * queue_depth to 0.&n;&t; */
id|sdevscan-&gt;new_queue_depth
op_assign
l_int|1
suffix:semicolon
id|scsi_build_commandblocks
c_func
(paren
id|sdevscan
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdevscan-&gt;current_queue_depth
op_eq
l_int|0
)paren
r_goto
id|alloc_failed
suffix:semicolon
multiline_comment|/*&n;&t; * Since we reuse the same sdevscan over and over with different&n;&t; * target and lun values, we have to destroy and then recreate&n;&t; * any possible low level attachments since they very will might&n;&t; * also store the id and lun numbers in some form and need updating&n;&t; * with each scan.&n;&t; */
r_if
c_cond
(paren
id|sdevscan-&gt;host-&gt;hostt-&gt;slave_destroy
)paren
id|sdevscan-&gt;host-&gt;hostt
op_member_access_from_pointer
id|slave_destroy
c_func
(paren
id|sdevscan
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdevscan-&gt;host-&gt;hostt-&gt;slave_alloc
)paren
id|sdevscan-&gt;host-&gt;hostt
op_member_access_from_pointer
id|slave_alloc
c_func
(paren
id|sdevscan
)paren
suffix:semicolon
id|sreq
op_assign
id|scsi_allocate_request
c_func
(paren
id|sdevscan
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sreq
op_eq
l_int|NULL
)paren
r_goto
id|alloc_failed
suffix:semicolon
multiline_comment|/*&n;&t; * The sreq is for use only with sdevscan.&n;&t; */
id|scsi_result
op_assign
id|kmalloc
c_func
(paren
l_int|256
comma
id|GFP_ATOMIC
op_or
(paren
id|sdevscan-&gt;host-&gt;unchecked_isa_dma
)paren
ques
c_cond
id|GFP_DMA
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scsi_result
op_eq
l_int|NULL
)paren
r_goto
id|alloc_failed
suffix:semicolon
id|scsi_probe_lun
c_func
(paren
id|sreq
comma
id|scsi_result
comma
op_amp
id|bflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sreq-&gt;sr_result
)paren
id|res
op_assign
id|SCSI_SCAN_NO_RESPONSE
suffix:semicolon
r_else
(brace
multiline_comment|/*&n;&t;&t; * scsi_result contains valid SCSI INQUIRY data.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|scsi_result
(braket
l_int|0
)braket
op_rshift
l_int|5
)paren
op_eq
l_int|3
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * For a Peripheral qualifier 3 (011b), the SCSI&n;&t;&t;&t; * spec says: The device server is not capable of&n;&t;&t;&t; * supporting a physical device on this logical&n;&t;&t;&t; * unit.&n;&t;&t;&t; *&n;&t;&t;&t; * For disks, this implies that there is no&n;&t;&t;&t; * logical disk configured at sdev-&gt;lun, but there&n;&t;&t;&t; * is a target id responding.&n;&t;&t;&t; */
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi scan: peripheral qualifier of 3,&quot;
l_string|&quot; no device added&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|res
op_assign
id|SCSI_SCAN_TARGET_PRESENT
suffix:semicolon
)brace
r_else
(brace
id|res
op_assign
id|scsi_add_lun
c_func
(paren
id|sdevscan
comma
op_amp
id|sdev
comma
id|sreq
comma
id|scsi_result
comma
op_amp
id|bflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_eq
id|SCSI_SCAN_LUN_PRESENT
)paren
(brace
id|BUG_ON
c_func
(paren
id|sdev
op_eq
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bflags
op_amp
id|BLIST_KEY
)paren
op_ne
l_int|0
)paren
(brace
id|sdev-&gt;lockable
op_assign
l_int|0
suffix:semicolon
id|scsi_unlock_floptical
c_func
(paren
id|sreq
comma
id|scsi_result
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * scsi_result no longer contains&n;&t;&t;&t;&t;&t; * the INQUIRY data.&n;&t;&t;&t;&t;&t; */
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * &quot;hardcoded&quot; scans of a single LUN need&n;&t;&t;&t;&t; * to know the sdev just allocated.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|sdevnew
op_ne
l_int|NULL
)paren
op_star
id|sdevnew
op_assign
id|sdev
suffix:semicolon
r_if
c_cond
(paren
id|bflagsp
op_ne
l_int|NULL
)paren
op_star
id|bflagsp
op_assign
id|bflags
suffix:semicolon
)brace
)brace
)brace
id|kfree
c_func
(paren
id|scsi_result
)paren
suffix:semicolon
id|scsi_release_request
c_func
(paren
id|sreq
)paren
suffix:semicolon
id|scsi_release_commandblocks
c_func
(paren
id|sdevscan
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
id|alloc_failed
suffix:colon
id|printk
c_func
(paren
id|ALLOC_FAILURE_MSG
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scsi_result
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|scsi_result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sreq
op_ne
l_int|NULL
)paren
id|scsi_release_request
c_func
(paren
id|sreq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdevscan-&gt;current_queue_depth
op_ne
l_int|0
)paren
id|scsi_release_commandblocks
c_func
(paren
id|sdevscan
)paren
suffix:semicolon
r_return
id|SCSI_SCAN_NO_RESPONSE
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_sequential_lun_scan - sequentially scan a SCSI target&n; * @sdevscan:&t;scan the host, channel, and id of this Scsi_Device&n; * @bflags:&t;black/white list flag for LUN 0&n; * @lun0_res:&t;result of scanning LUN 0&n; *&n; * Description:&n; *     Generally, scan from LUN 1 (LUN 0 is assumed to already have been&n; *     scanned) to some maximum lun until a LUN is found with no device&n; *     attached. Use the bflags to figure out any oddities.&n; *&n; *     Modifies sdevscan-&gt;lun.&n; **/
DECL|function|scsi_sequential_lun_scan
r_static
r_void
id|scsi_sequential_lun_scan
c_func
(paren
id|Scsi_Device
op_star
id|sdevscan
comma
r_int
id|bflags
comma
r_int
id|lun0_res
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|shost
op_assign
id|sdevscan-&gt;host
suffix:semicolon
r_int
r_int
id|sparse_lun
suffix:semicolon
r_int
r_int
id|max_dev_lun
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi scan: Sequential scan of&quot;
l_string|&quot; host %d channel %d id %d&bslash;n&quot;
comma
id|sdevscan-&gt;host-&gt;host_no
comma
id|sdevscan-&gt;channel
comma
id|sdevscan-&gt;id
)paren
)paren
suffix:semicolon
id|max_dev_lun
op_assign
id|min
c_func
(paren
id|max_scsi_luns
comma
id|shost-&gt;max_lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If this device is known to support sparse multiple units,&n;&t; * override the other settings, and scan all of them. Normally,&n;&t; * SCSI-3 devices should be scanned via the REPORT LUNS.&n;&t; */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_SPARSELUN
)paren
(brace
id|max_dev_lun
op_assign
id|shost-&gt;max_lun
suffix:semicolon
id|sparse_lun
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|sparse_lun
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If not sparse lun and no device attached at LUN 0 do not scan&n;&t; * any further.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sparse_lun
op_logical_and
(paren
id|lun0_res
op_ne
id|SCSI_SCAN_LUN_PRESENT
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * If less than SCSI_1_CSS, and no special lun scaning, stop&n;&t; * scanning; this matches 2.4 behaviour, but could just be a bug&n;&t; * (to continue scanning a SCSI_1_CSS device).&n;&t; */
r_if
c_cond
(paren
(paren
id|sdevscan-&gt;scsi_level
OL
id|SCSI_1_CCS
)paren
op_logical_and
(paren
(paren
id|bflags
op_amp
(paren
id|BLIST_FORCELUN
op_or
id|BLIST_SPARSELUN
op_or
id|BLIST_MAX5LUN
)paren
)paren
op_eq
l_int|0
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * If this device is known to support multiple units, override&n;&t; * the other settings, and scan all of them.&n;&t; */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_FORCELUN
)paren
id|max_dev_lun
op_assign
id|shost-&gt;max_lun
suffix:semicolon
multiline_comment|/*&n;&t; * REGAL CDC-4X: avoid hang after LUN 4&n;&t; */
r_if
c_cond
(paren
id|bflags
op_amp
id|BLIST_MAX5LUN
)paren
id|max_dev_lun
op_assign
id|min
c_func
(paren
l_int|5U
comma
id|max_dev_lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do not scan SCSI-2 or lower device past LUN 7, unless&n;&t; * BLIST_LARGELUN.&n;&t; */
r_if
c_cond
(paren
(paren
id|sdevscan-&gt;scsi_level
OL
id|SCSI_3
)paren
op_logical_and
op_logical_neg
(paren
id|bflags
op_amp
id|BLIST_LARGELUN
)paren
)paren
id|max_dev_lun
op_assign
id|min
c_func
(paren
l_int|8U
comma
id|max_dev_lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We have already scanned LUN 0, so start at LUN 1. Keep scanning&n;&t; * until we reach the max, or no LUN is found and we are not&n;&t; * sparse_lun.&n;&t; */
r_for
c_loop
(paren
id|sdevscan-&gt;lun
op_assign
l_int|1
suffix:semicolon
id|sdevscan-&gt;lun
OL
id|max_dev_lun
suffix:semicolon
op_increment
id|sdevscan-&gt;lun
)paren
r_if
c_cond
(paren
(paren
id|scsi_probe_and_add_lun
c_func
(paren
id|sdevscan
comma
l_int|NULL
comma
l_int|NULL
)paren
op_ne
id|SCSI_SCAN_LUN_PRESENT
)paren
op_logical_and
op_logical_neg
id|sparse_lun
)paren
r_return
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SCSI_REPORT_LUNS
multiline_comment|/**&n; * scsilun_to_int: convert a ScsiLun to an int&n; * @scsilun:&t;ScsiLun to be converted.&n; *&n; * Description:&n; *     Convert @scsilun from a ScsiLun to a four byte host byte-ordered&n; *     integer, and return the result. The caller must check for&n; *     truncation before using this function.&n; *&n; * Notes:&n; *     The ScsiLun is assumed to be four levels, with each level&n; *     effectively containing a SCSI byte-ordered (big endian) short; the&n; *     addressing bits of each level are ignored (the highest two bits).&n; *     For a description of the LUN format, post SCSI-3 see the SCSI&n; *     Architecture Model, for SCSI-3 see the SCSI Controller Commands.&n; *&n; *     Given a ScsiLun of: 0a 04 0b 03 00 00 00 00, this function returns&n; *     the integer: 0x0b030a04&n; **/
DECL|function|scsilun_to_int
r_static
r_int
id|scsilun_to_int
c_func
(paren
id|ScsiLun
op_star
id|scsilun
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|lun
suffix:semicolon
id|lun
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|lun
)paren
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
id|lun
op_assign
id|lun
op_or
(paren
(paren
(paren
id|scsilun-&gt;scsi_lun
(braket
id|i
)braket
op_lshift
l_int|8
)paren
op_or
id|scsilun-&gt;scsi_lun
(braket
id|i
op_plus
l_int|1
)braket
)paren
op_lshift
(paren
id|i
op_star
l_int|8
)paren
)paren
suffix:semicolon
r_return
id|lun
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/**&n; * scsi_report_lun_scan - Scan using SCSI REPORT LUN results&n; * @sdevscan:&t;scan the host, channel, and id of this Scsi_Device&n; *&n; * Description:&n; *     If @sdevscan is for a SCSI-3 or up device, send a REPORT LUN&n; *     command, and scan the resulting list of LUNs by calling&n; *     scsi_probe_and_add_lun.&n; *&n; *     Modifies sdevscan-&gt;lun.&n; *&n; * Return:&n; *     0: scan completed (or no memory, so further scanning is futile)&n; *     1: no report lun scan, or not configured&n; **/
DECL|function|scsi_report_lun_scan
r_static
r_int
id|scsi_report_lun_scan
c_func
(paren
id|Scsi_Device
op_star
id|sdevscan
)paren
(brace
macro_line|#ifdef CONFIG_SCSI_REPORT_LUNS
r_char
id|devname
(braket
l_int|64
)braket
suffix:semicolon
r_int
r_char
id|scsi_cmd
(braket
id|MAX_COMMAND_SIZE
)braket
suffix:semicolon
r_int
r_int
id|length
suffix:semicolon
r_int
r_int
id|lun
suffix:semicolon
r_int
r_int
id|num_luns
suffix:semicolon
r_int
r_int
id|retries
suffix:semicolon
id|ScsiLun
op_star
id|fcp_cur_lun
comma
op_star
id|lun_data
suffix:semicolon
id|Scsi_Request
op_star
id|sreq
suffix:semicolon
r_char
op_star
id|data
suffix:semicolon
multiline_comment|/*&n;&t; * Only support SCSI-3 and up devices.&n;&t; */
r_if
c_cond
(paren
id|sdevscan-&gt;scsi_level
OL
id|SCSI_3
)paren
r_return
l_int|1
suffix:semicolon
id|sdevscan-&gt;new_queue_depth
op_assign
l_int|1
suffix:semicolon
id|scsi_build_commandblocks
c_func
(paren
id|sdevscan
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdevscan-&gt;current_queue_depth
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|ALLOC_FAILURE_MSG
comma
id|__FUNCTION__
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We are out of memory, don&squot;t try scanning any further.&n;&t;&t; */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Since we reuse the same sdevscan over and over with different&n;&t; * target and lun values, we have to destroy and then recreate&n;&t; * any possible low level attachments since they very will might&n;&t; * also store the id and lun numbers in some form and need updating&n;&t; * with each scan.&n;&t; *&n;&t; * This is normally handled in probe_and_add_lun, but since this&n;&t; * one particular function wants to scan lun 0 on each device&n;&t; * itself and will possibly pick up a resed sdevscan when doing&n;&t; * so, it also needs this hack.&n;&t; */
r_if
c_cond
(paren
id|sdevscan-&gt;host-&gt;hostt-&gt;slave_destroy
)paren
id|sdevscan-&gt;host-&gt;hostt
op_member_access_from_pointer
id|slave_destroy
c_func
(paren
id|sdevscan
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdevscan-&gt;host-&gt;hostt-&gt;slave_alloc
)paren
id|sdevscan-&gt;host-&gt;hostt
op_member_access_from_pointer
id|slave_alloc
c_func
(paren
id|sdevscan
)paren
suffix:semicolon
id|sreq
op_assign
id|scsi_allocate_request
c_func
(paren
id|sdevscan
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|devname
comma
l_string|&quot;host %d channel %d id %d&quot;
comma
id|sdevscan-&gt;host-&gt;host_no
comma
id|sdevscan-&gt;channel
comma
id|sdevscan-&gt;id
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate enough to hold the header (the same size as one ScsiLun)&n;&t; * plus the max number of luns we are requesting.&n;&t; *&n;&t; * Reallocating and trying again (with the exact amount we need)&n;&t; * would be nice, but then we need to somehow limit the size&n;&t; * allocated based on the available memory and the limits of&n;&t; * kmalloc - we don&squot;t want a kmalloc() failure of a huge value to&n;&t; * prevent us from finding any LUNs on this target.&n;&t; */
id|length
op_assign
(paren
id|max_scsi_report_luns
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
id|ScsiLun
)paren
suffix:semicolon
id|lun_data
op_assign
(paren
id|ScsiLun
op_star
)paren
id|kmalloc
c_func
(paren
id|length
comma
id|GFP_ATOMIC
op_or
(paren
id|sdevscan-&gt;host-&gt;unchecked_isa_dma
ques
c_cond
id|GFP_DMA
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lun_data
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|ALLOC_FAILURE_MSG
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|scsi_release_commandblocks
c_func
(paren
id|sdevscan
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We are out of memory, don&squot;t try scanning any further.&n;&t;&t; */
r_return
l_int|0
suffix:semicolon
)brace
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|REPORT_LUNS
suffix:semicolon
multiline_comment|/*&n;&t; * bytes 1 - 5: reserved, set to zero.&n;&t; */
id|memset
c_func
(paren
op_amp
id|scsi_cmd
(braket
l_int|1
)braket
comma
l_int|0
comma
l_int|5
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * bytes 6 - 9: length of the command.&n;&t; */
id|scsi_cmd
(braket
l_int|6
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|length
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
suffix:semicolon
id|scsi_cmd
(braket
l_int|7
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|length
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
id|scsi_cmd
(braket
l_int|8
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|length
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|scsi_cmd
(braket
l_int|9
)braket
op_assign
(paren
r_int
r_char
)paren
id|length
op_amp
l_int|0xff
suffix:semicolon
id|scsi_cmd
(braket
l_int|10
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* reserved */
id|scsi_cmd
(braket
l_int|11
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* control */
id|sreq-&gt;sr_cmd_len
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_data_direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
multiline_comment|/*&n;&t; * We can get a UNIT ATTENTION, for example a power on/reset, so&n;&t; * retry a few times (like sd.c does for TEST UNIT READY).&n;&t; * Experience shows some combinations of adapter/devices get at&n;&t; * least two power on/resets.&n;&t; *&n;&t; * Illegal requests (for devices that do not support REPORT LUNS)&n;&t; * should come through as a check condition, and will not generate&n;&t; * a retry.&n;&t; */
id|retries
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|retries
op_increment
OL
l_int|3
)paren
(brace
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
(paren
id|KERN_INFO
l_string|&quot;scsi scan: Sending&quot;
l_string|&quot; REPORT LUNS to %s (try %d)&bslash;n&quot;
comma
id|devname
comma
id|retries
)paren
)paren
suffix:semicolon
id|scsi_wait_req
c_func
(paren
id|sreq
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|lun_data
comma
id|length
comma
id|SCSI_TIMEOUT
op_plus
l_int|4
op_star
id|HZ
comma
l_int|3
)paren
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
(paren
id|KERN_INFO
l_string|&quot;scsi scan: REPORT LUNS&quot;
l_string|&quot; %s (try %d) result 0x%x&bslash;n&quot;
comma
id|sreq-&gt;sr_result
ques
c_cond
l_string|&quot;failed&quot;
suffix:colon
l_string|&quot;successful&quot;
comma
id|retries
comma
id|sreq-&gt;sr_result
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sreq-&gt;sr_result
op_eq
l_int|0
op_logical_or
id|sreq-&gt;sr_sense_buffer
(braket
l_int|2
)braket
op_ne
id|UNIT_ATTENTION
)paren
r_break
suffix:semicolon
)brace
id|scsi_release_commandblocks
c_func
(paren
id|sdevscan
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sreq-&gt;sr_result
)paren
(brace
multiline_comment|/*&n;&t;&t; * The device probably does not support a REPORT LUN command&n;&t;&t; */
id|kfree
c_func
(paren
(paren
r_char
op_star
)paren
id|lun_data
)paren
suffix:semicolon
id|scsi_release_request
c_func
(paren
id|sreq
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|scsi_release_request
c_func
(paren
id|sreq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get the length from the first four bytes of lun_data.&n;&t; */
id|data
op_assign
(paren
r_char
op_star
)paren
id|lun_data-&gt;scsi_lun
suffix:semicolon
id|length
op_assign
(paren
(paren
id|data
(braket
l_int|0
)braket
op_lshift
l_int|24
)paren
op_or
(paren
id|data
(braket
l_int|1
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|data
(braket
l_int|2
)braket
op_lshift
l_int|8
)paren
op_or
(paren
id|data
(braket
l_int|3
)braket
op_lshift
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|length
op_div
r_sizeof
(paren
id|ScsiLun
)paren
)paren
OG
id|max_scsi_report_luns
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi: On %s only %d (max_scsi_report_luns)&quot;
l_string|&quot; of %d luns reported, try increasing&quot;
l_string|&quot; max_scsi_report_luns.&bslash;n&quot;
comma
id|devname
comma
id|max_scsi_report_luns
comma
id|length
op_div
r_sizeof
(paren
id|ScsiLun
)paren
)paren
suffix:semicolon
id|num_luns
op_assign
id|max_scsi_report_luns
suffix:semicolon
)brace
r_else
id|num_luns
op_assign
(paren
id|length
op_div
r_sizeof
(paren
id|ScsiLun
)paren
)paren
suffix:semicolon
id|SCSI_LOG_SCAN_BUS
c_func
(paren
l_int|3
comma
id|printk
(paren
id|KERN_INFO
l_string|&quot;scsi scan: REPORT LUN scan of&quot;
l_string|&quot; host %d channel %d id %d&bslash;n&quot;
comma
id|sdevscan-&gt;host-&gt;host_no
comma
id|sdevscan-&gt;channel
comma
id|sdevscan-&gt;id
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Scan the luns in lun_data. The entry at offset 0 is really&n;&t; * the header, so start at 1 and go up to and including num_luns.&n;&t; */
r_for
c_loop
(paren
id|fcp_cur_lun
op_assign
op_amp
id|lun_data
(braket
l_int|1
)braket
suffix:semicolon
id|fcp_cur_lun
op_le
op_amp
id|lun_data
(braket
id|num_luns
)braket
suffix:semicolon
id|fcp_cur_lun
op_increment
)paren
(brace
id|lun
op_assign
id|scsilun_to_int
c_func
(paren
id|fcp_cur_lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check if the unused part of fcp_cur_lun is non-zero,&n;&t;&t; * and so does not fit in lun.&n;&t;&t; */
r_if
c_cond
(paren
id|memcmp
c_func
(paren
op_amp
id|fcp_cur_lun-&gt;scsi_lun
(braket
r_sizeof
(paren
id|lun
)paren
)braket
comma
l_string|&quot;&bslash;0&bslash;0&bslash;0&bslash;0&quot;
comma
l_int|4
)paren
op_ne
l_int|0
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Output an error displaying the LUN in byte order,&n;&t;&t;&t; * this differs from what linux would print for the&n;&t;&t;&t; * integer LUN value.&n;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi: %s lun 0x&quot;
comma
id|devname
)paren
suffix:semicolon
id|data
op_assign
(paren
r_char
op_star
)paren
id|fcp_cur_lun-&gt;scsi_lun
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|ScsiLun
)paren
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%02x&quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; has a LUN larger than currently supported.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lun
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * LUN 0 has already been scanned.&n;&t;&t;&t; */
)brace
r_else
r_if
c_cond
(paren
id|lun
OG
id|sdevscan-&gt;host-&gt;max_lun
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;scsi: %s lun%d has a LUN larger&quot;
l_string|&quot; than allowed by the host adapter&bslash;n&quot;
comma
id|devname
comma
id|lun
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|res
suffix:semicolon
id|sdevscan-&gt;lun
op_assign
id|lun
suffix:semicolon
id|res
op_assign
id|scsi_probe_and_add_lun
c_func
(paren
id|sdevscan
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_eq
id|SCSI_SCAN_NO_RESPONSE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Got some results, but now none, abort.&n;&t;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;scsi: Unexpected response&quot;
l_string|&quot; from %s lun %d while scanning, scan&quot;
l_string|&quot; aborted&bslash;n&quot;
comma
id|devname
comma
id|sdevscan-&gt;lun
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|kfree
c_func
(paren
(paren
r_char
op_star
)paren
id|lun_data
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#else
r_return
l_int|1
suffix:semicolon
macro_line|#endif&t;/* CONFIG_SCSI_REPORT_LUNS */
)brace
DECL|function|scsi_add_single_device
r_int
id|scsi_add_single_device
c_func
(paren
id|uint
id|host
comma
id|uint
id|channel
comma
id|uint
id|id
comma
id|uint
id|lun
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdevscan
comma
op_star
id|sdev
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shost
suffix:semicolon
r_int
id|error
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|shost
op_assign
id|scsi_host_hn_get
c_func
(paren
id|host
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|shost
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|sdev
op_assign
id|scsi_find_device
c_func
(paren
id|shost
comma
id|channel
comma
id|id
comma
id|lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|sdevscan
op_assign
id|scsi_alloc_sdev
c_func
(paren
id|shost
comma
id|channel
comma
id|id
comma
id|lun
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sdevscan
)paren
r_goto
id|out
suffix:semicolon
id|sdevscan-&gt;scsi_level
op_assign
id|scsi_find_scsi_level
c_func
(paren
id|channel
comma
id|id
comma
id|shost
)paren
suffix:semicolon
id|error
op_assign
id|scsi_probe_and_add_lun
c_func
(paren
id|sdevscan
comma
op_amp
id|sdev
comma
l_int|NULL
)paren
suffix:semicolon
id|scsi_free_sdev
c_func
(paren
id|sdevscan
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
id|SCSI_SCAN_LUN_PRESENT
)paren
r_goto
id|out
suffix:semicolon
id|scsi_attach_device
c_func
(paren
id|sdev
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|scsi_host_put
c_func
(paren
id|shost
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|scsi_remove_single_device
r_int
id|scsi_remove_single_device
c_func
(paren
id|uint
id|host
comma
id|uint
id|channel
comma
id|uint
id|id
comma
id|uint
id|lun
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shost
suffix:semicolon
r_int
id|error
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|shost
op_assign
id|scsi_host_hn_get
c_func
(paren
id|host
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|shost
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|sdev
op_assign
id|scsi_find_device
c_func
(paren
id|shost
comma
id|channel
comma
id|id
comma
id|lun
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sdev
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;access_count
)paren
r_goto
id|out
suffix:semicolon
id|scsi_detach_device
c_func
(paren
id|sdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;attached
)paren
r_goto
id|out
suffix:semicolon
id|devfs_unregister
c_func
(paren
id|sdev-&gt;de
)paren
suffix:semicolon
id|scsi_free_sdev
c_func
(paren
id|sdev
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|scsi_host_put
c_func
(paren
id|shost
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_scan_target - scan a target id, possibly including all LUNs on the&n; *     target.&n; * @sdevsca:&t;Scsi_Device handle for scanning&n; * @shost:&t;host to scan&n; * @channel:&t;channel to scan&n; * @id:&t;&t;target id to scan&n; *&n; * Description:&n; *     Scan the target id on @shost, @channel, and @id. Scan at least LUN&n; *     0, and possibly all LUNs on the target id.&n; *&n; *     Use the pre-allocated @sdevscan as a handle for the scanning. This&n; *     function sets sdevscan-&gt;host, sdevscan-&gt;id and sdevscan-&gt;lun; the&n; *     scanning functions modify sdevscan-&gt;lun.&n; *&n; *     First try a REPORT LUN scan, if that does not scan the target, do a&n; *     sequential scan of LUNs on the target id.&n; **/
DECL|function|scsi_scan_target
r_static
r_void
id|scsi_scan_target
c_func
(paren
id|Scsi_Device
op_star
id|sdevscan
comma
r_struct
id|Scsi_Host
op_star
id|shost
comma
r_int
r_int
id|channel
comma
r_int
r_int
id|id
)paren
(brace
r_int
id|bflags
suffix:semicolon
r_int
id|res
suffix:semicolon
r_if
c_cond
(paren
id|shost-&gt;this_id
op_eq
id|id
)paren
multiline_comment|/*&n;&t;&t; * Don&squot;t scan the host adapter&n;&t;&t; */
r_return
suffix:semicolon
id|sdevscan-&gt;host
op_assign
id|shost
suffix:semicolon
id|sdevscan-&gt;id
op_assign
id|id
suffix:semicolon
id|sdevscan-&gt;channel
op_assign
id|channel
suffix:semicolon
multiline_comment|/*&n;&t; * Scan LUN 0, if there is some response, scan further. Ideally, we&n;&t; * would not configure LUN 0 until all LUNs are scanned.&n;&t; *&n;&t; * The scsi_level is set (in scsi_probe_lun) if a target responds.&n;&t; */
id|sdevscan-&gt;lun
op_assign
l_int|0
suffix:semicolon
id|res
op_assign
id|scsi_probe_and_add_lun
c_func
(paren
id|sdevscan
comma
l_int|NULL
comma
op_amp
id|bflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_ne
id|SCSI_SCAN_NO_RESPONSE
)paren
(brace
multiline_comment|/*&n;&t;&t; * Some scsi devices cannot properly handle a lun != 0.&n;&t;&t; * BLIST_NOLUN also prevents a REPORT LUN from being sent.&n;&t;&t; * Any multi-lun SCSI-3 device that hangs because of a&n;&t;&t; * REPORT LUN command is seriously broken.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|bflags
op_amp
id|BLIST_NOLUN
)paren
)paren
multiline_comment|/*&n;&t;&t;&t; * Ending the scan here if max_scsi_luns == 1&n;&t;&t;&t; * breaks scanning of SPARSE, FORCE, MAX5 LUN&n;&t;&t;&t; * devices, and the report lun scan.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|scsi_report_lun_scan
c_func
(paren
id|sdevscan
)paren
op_ne
l_int|0
)paren
multiline_comment|/*&n;&t;&t;&t;&t; * The REPORT LUN did not scan the target,&n;&t;&t;&t;&t; * do a sequential scan.&n;&t;&t;&t;&t; */
id|scsi_sequential_lun_scan
c_func
(paren
id|sdevscan
comma
id|bflags
comma
id|res
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * scsi_scan_host - scan the given adapter&n; * @shost:&t;adapter to scan&n; *&n; * Description:&n; *     Iterate and call scsi_scan_target to scan all possible target id&squot;s&n; *     on all possible channels.&n; **/
DECL|function|scsi_scan_host
r_void
id|scsi_scan_host
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdevscan
suffix:semicolon
id|uint
id|channel
comma
id|id
comma
id|order_id
suffix:semicolon
multiline_comment|/*&n;&t; * The blk layer queue allocation is a bit expensive to&n;&t; * repeat for each channel and id - for FCP max_id is near&n;&t; * 255: each call to scsi_alloc_sdev() implies a call to&n;&t; * blk_init_queue, and then blk_init_free_list, where 2 *&n;&t; * queue_nr_requests requests are allocated. Don&squot;t do so&n;&t; * here for scsi_scan_selected_lun, since we end up&n;&t; * calling select_queue_depths with an extra Scsi_Device&n;&t; * on the host_queue list.&n;&t; */
id|sdevscan
op_assign
id|scsi_alloc_sdev
c_func
(paren
id|shost
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdevscan
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * The sdevscan host, channel, id and lun are filled in as&n;&t; * needed to scan.&n;&t; */
r_for
c_loop
(paren
id|channel
op_assign
l_int|0
suffix:semicolon
id|channel
op_le
id|shost-&gt;max_channel
suffix:semicolon
id|channel
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * XXX adapter drivers when possible (FCP, iSCSI)&n;&t;&t; * could modify max_id to match the current max,&n;&t;&t; * not the absolute max.&n;&t;&t; *&n;&t;&t; * XXX add a shost id iterator, so for example,&n;&t;&t; * the FC ID can be the same as a target id&n;&t;&t; * without a huge overhead of sparse id&squot;s.&n;&t;&t; */
r_for
c_loop
(paren
id|id
op_assign
l_int|0
suffix:semicolon
id|id
OL
id|shost-&gt;max_id
suffix:semicolon
op_increment
id|id
)paren
(brace
r_if
c_cond
(paren
id|shost-&gt;reverse_ordering
)paren
multiline_comment|/*&n;&t;&t;&t;&t; * Scan from high to low id.&n;&t;&t;&t;&t; */
id|order_id
op_assign
id|shost-&gt;max_id
op_minus
id|id
op_minus
l_int|1
suffix:semicolon
r_else
id|order_id
op_assign
id|id
suffix:semicolon
id|scsi_scan_target
c_func
(paren
id|sdevscan
comma
id|shost
comma
id|channel
comma
id|order_id
)paren
suffix:semicolon
)brace
)brace
id|scsi_free_sdev
c_func
(paren
id|sdevscan
)paren
suffix:semicolon
)brace
eof
