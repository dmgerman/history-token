multiline_comment|/* imm.c   --  low level driver for the IOMEGA MatchMaker&n; * parallel port SCSI host adapter.&n; * &n; * (The IMM is the embedded controller in the ZIP Plus drive.)&n; * &n; * Current Maintainer: David Campbell (Perth, Western Australia)&n; *                     campbell@torque.net&n; *&n; * My unoffical company acronym list is 21 pages long:&n; *      FLA:    Four letter acronym with built in facility for&n; *              future expansion to five letters.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/parport.h&gt;
macro_line|#include &lt;linux/workqueue.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;scsi/scsi.h&gt;
macro_line|#include &lt;scsi/scsi_cmnd.h&gt;
macro_line|#include &lt;scsi/scsi_device.h&gt;
macro_line|#include &lt;scsi/scsi_host.h&gt;
multiline_comment|/* The following #define is to avoid a clash with hosts.c */
DECL|macro|IMM_PROBE_SPP
mdefine_line|#define IMM_PROBE_SPP   0x0001
DECL|macro|IMM_PROBE_PS2
mdefine_line|#define IMM_PROBE_PS2   0x0002
DECL|macro|IMM_PROBE_ECR
mdefine_line|#define IMM_PROBE_ECR   0x0010
DECL|macro|IMM_PROBE_EPP17
mdefine_line|#define IMM_PROBE_EPP17 0x0100
DECL|macro|IMM_PROBE_EPP19
mdefine_line|#define IMM_PROBE_EPP19 0x0200
r_typedef
r_struct
(brace
DECL|member|dev
r_struct
id|pardevice
op_star
id|dev
suffix:semicolon
multiline_comment|/* Parport device entry         */
DECL|member|base
r_int
id|base
suffix:semicolon
multiline_comment|/* Actual port address          */
DECL|member|base_hi
r_int
id|base_hi
suffix:semicolon
multiline_comment|/* Hi Base address for ECP-ISA chipset */
DECL|member|mode
r_int
id|mode
suffix:semicolon
multiline_comment|/* Transfer mode                */
DECL|member|cur_cmd
r_struct
id|scsi_cmnd
op_star
id|cur_cmd
suffix:semicolon
multiline_comment|/* Current queued command       */
DECL|member|imm_tq
r_struct
id|work_struct
id|imm_tq
suffix:semicolon
multiline_comment|/* Polling interrupt stuff       */
DECL|member|jstart
r_int
r_int
id|jstart
suffix:semicolon
multiline_comment|/* Jiffies at start             */
DECL|member|failed
r_int
id|failed
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Failure flag                 */
DECL|member|dp
r_int
id|dp
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Data phase present           */
DECL|member|rd
r_int
id|rd
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Read data in data phase      */
DECL|member|wanted
r_int
id|wanted
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Parport sharing busy flag    */
DECL|member|waiting
id|wait_queue_head_t
op_star
id|waiting
suffix:semicolon
DECL|member|host
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|typedef|imm_struct
)brace
id|imm_struct
suffix:semicolon
r_static
r_void
id|imm_reset_pulse
c_func
(paren
r_int
r_int
id|base
)paren
suffix:semicolon
r_static
r_int
id|device_check
c_func
(paren
id|imm_struct
op_star
id|dev
)paren
suffix:semicolon
macro_line|#include &quot;imm.h&quot;
DECL|function|imm_dev
r_static
r_inline
id|imm_struct
op_star
id|imm_dev
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_return
op_star
(paren
id|imm_struct
op_star
op_star
)paren
op_amp
id|host-&gt;hostdata
suffix:semicolon
)brace
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|arbitration_lock
)paren
suffix:semicolon
DECL|function|got_it
r_static
r_void
id|got_it
c_func
(paren
id|imm_struct
op_star
id|dev
)paren
(brace
id|dev-&gt;base
op_assign
id|dev-&gt;dev-&gt;port-&gt;base
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;cur_cmd
)paren
id|dev-&gt;cur_cmd-&gt;SCp.phase
op_assign
l_int|1
suffix:semicolon
r_else
id|wake_up
c_func
(paren
id|dev-&gt;waiting
)paren
suffix:semicolon
)brace
DECL|function|imm_wakeup
r_static
r_void
id|imm_wakeup
c_func
(paren
r_void
op_star
id|ref
)paren
(brace
id|imm_struct
op_star
id|dev
op_assign
(paren
id|imm_struct
op_star
)paren
id|ref
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|arbitration_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;wanted
)paren
(brace
id|parport_claim
c_func
(paren
id|dev-&gt;dev
)paren
suffix:semicolon
id|got_it
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;wanted
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|arbitration_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|imm_pb_claim
r_static
r_int
id|imm_pb_claim
c_func
(paren
id|imm_struct
op_star
id|dev
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|res
op_assign
l_int|1
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|arbitration_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parport_claim
c_func
(paren
id|dev-&gt;dev
)paren
op_eq
l_int|0
)paren
(brace
id|got_it
c_func
(paren
id|dev
)paren
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
)brace
id|dev-&gt;wanted
op_assign
id|res
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|arbitration_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|function|imm_pb_dismiss
r_static
r_void
id|imm_pb_dismiss
c_func
(paren
id|imm_struct
op_star
id|dev
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|wanted
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|arbitration_lock
comma
id|flags
)paren
suffix:semicolon
id|wanted
op_assign
id|dev-&gt;wanted
suffix:semicolon
id|dev-&gt;wanted
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|arbitration_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wanted
)paren
id|parport_release
c_func
(paren
id|dev-&gt;dev
)paren
suffix:semicolon
)brace
DECL|function|imm_pb_release
r_static
r_inline
r_void
id|imm_pb_release
c_func
(paren
id|imm_struct
op_star
id|dev
)paren
(brace
id|parport_release
c_func
(paren
id|dev-&gt;dev
)paren
suffix:semicolon
)brace
multiline_comment|/* This is to give the imm driver a way to modify the timings (and other&n; * parameters) by writing to the /proc/scsi/imm/0 file.&n; * Very simple method really... (Too simple, no error checking :( )&n; * Reason: Kernel hackers HATE having to unload and reload modules for&n; * testing...&n; * Also gives a method to use a script to obtain optimum timings (TODO)&n; */
DECL|function|imm_proc_write
r_static
r_inline
r_int
id|imm_proc_write
c_func
(paren
id|imm_struct
op_star
id|dev
comma
r_char
op_star
id|buffer
comma
r_int
id|length
)paren
(brace
r_int
r_int
id|x
suffix:semicolon
r_if
c_cond
(paren
(paren
id|length
OG
l_int|5
)paren
op_logical_and
(paren
id|strncmp
c_func
(paren
id|buffer
comma
l_string|&quot;mode=&quot;
comma
l_int|5
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|x
op_assign
id|simple_strtoul
c_func
(paren
id|buffer
op_plus
l_int|5
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|dev-&gt;mode
op_assign
id|x
suffix:semicolon
r_return
id|length
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;imm /proc: invalid variable&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
DECL|function|imm_proc_info
r_static
r_int
id|imm_proc_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|inout
)paren
(brace
id|imm_struct
op_star
id|dev
op_assign
id|imm_dev
c_func
(paren
id|host
)paren
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|inout
)paren
r_return
id|imm_proc_write
c_func
(paren
id|dev
comma
id|buffer
comma
id|length
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Version : %s&bslash;n&quot;
comma
id|IMM_VERSION
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Parport : %s&bslash;n&quot;
comma
id|dev-&gt;dev-&gt;port-&gt;name
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Mode    : %s&bslash;n&quot;
comma
id|IMM_MODE_STRING
(braket
id|dev-&gt;mode
)braket
)paren
suffix:semicolon
multiline_comment|/* Request for beyond end of buffer */
r_if
c_cond
(paren
id|offset
OG
id|len
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
id|offset
suffix:semicolon
id|len
op_sub_assign
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
macro_line|#if IMM_DEBUG &gt; 0
DECL|macro|imm_fail
mdefine_line|#define imm_fail(x,y) printk(&quot;imm: imm_fail(%i) from %s at line %d&bslash;n&quot;,&bslash;&n;&t;   y, __FUNCTION__, __LINE__); imm_fail_func(x,y);
r_static
r_inline
r_void
DECL|function|imm_fail_func
id|imm_fail_func
c_func
(paren
id|imm_struct
op_star
id|dev
comma
r_int
id|error_code
)paren
macro_line|#else
r_static
r_inline
r_void
id|imm_fail
c_func
(paren
id|imm_struct
op_star
id|dev
comma
r_int
id|error_code
)paren
macro_line|#endif
(brace
multiline_comment|/* If we fail a device then we trash status / message bytes */
r_if
c_cond
(paren
id|dev-&gt;cur_cmd
)paren
(brace
id|dev-&gt;cur_cmd-&gt;result
op_assign
id|error_code
op_lshift
l_int|16
suffix:semicolon
id|dev-&gt;failed
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Wait for the high bit to be set.&n; * &n; * In principle, this could be tied to an interrupt, but the adapter&n; * doesn&squot;t appear to be designed to support interrupts.  We spin on&n; * the 0x80 ready bit. &n; */
DECL|function|imm_wait
r_static
r_int
r_char
id|imm_wait
c_func
(paren
id|imm_struct
op_star
id|dev
)paren
(brace
r_int
id|k
suffix:semicolon
r_int
r_int
id|ppb
op_assign
id|dev-&gt;base
suffix:semicolon
r_int
r_char
id|r
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
id|k
op_assign
id|IMM_SPIN_TMO
suffix:semicolon
r_do
(brace
id|r
op_assign
id|r_str
c_func
(paren
id|ppb
)paren
suffix:semicolon
id|k
op_decrement
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|r
op_amp
l_int|0x80
)paren
op_logical_and
(paren
id|k
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * STR register (LPT base+1) to SCSI mapping:&n;&t; *&n;&t; * STR      imm     imm&n;&t; * ===================================&n;&t; * 0x80     S_REQ   S_REQ&n;&t; * 0x40     !S_BSY  (????)&n;&t; * 0x20     !S_CD   !S_CD&n;&t; * 0x10     !S_IO   !S_IO&n;&t; * 0x08     (????)  !S_BSY&n;&t; *&n;&t; * imm      imm     meaning&n;&t; * ==================================&n;&t; * 0xf0     0xb8    Bit mask&n;&t; * 0xc0     0x88    ZIP wants more data&n;&t; * 0xd0     0x98    ZIP wants to send more data&n;&t; * 0xe0     0xa8    ZIP is expecting SCSI command data&n;&t; * 0xf0     0xb8    end of transfer, ZIP is sending status&n;&t; */
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x04
)paren
suffix:semicolon
r_if
c_cond
(paren
id|k
)paren
r_return
(paren
id|r
op_amp
l_int|0xb8
)paren
suffix:semicolon
multiline_comment|/* Counter expired - Time out occurred */
id|imm_fail
c_func
(paren
id|dev
comma
id|DID_TIME_OUT
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;imm timeout in imm_wait&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* command timed out */
)brace
DECL|function|imm_negotiate
r_static
r_int
id|imm_negotiate
c_func
(paren
id|imm_struct
op_star
id|tmp
)paren
(brace
multiline_comment|/*&n;&t; * The following is supposedly the IEEE 1284-1994 negotiate&n;&t; * sequence. I have yet to obtain a copy of the above standard&n;&t; * so this is a bit of a guess...&n;&t; *&n;&t; * A fair chunk of this is based on the Linux parport implementation&n;&t; * of IEEE 1284.&n;&t; *&n;&t; * Return 0 if data available&n;&t; *        1 if no data available&n;&t; */
r_int
r_int
id|base
op_assign
id|tmp-&gt;base
suffix:semicolon
r_int
r_char
id|a
comma
id|mode
suffix:semicolon
r_switch
c_cond
(paren
id|tmp-&gt;mode
)paren
(brace
r_case
id|IMM_NIBBLE
suffix:colon
id|mode
op_assign
l_int|0x00
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IMM_PS2
suffix:colon
id|mode
op_assign
l_int|0x01
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x04
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|w_dtr
c_func
(paren
id|base
comma
id|mode
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x06
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|a
op_assign
(paren
id|r_str
c_func
(paren
id|base
)paren
op_amp
l_int|0x20
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x07
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x06
)paren
suffix:semicolon
r_if
c_cond
(paren
id|a
)paren
(brace
id|printk
(paren
l_string|&quot;IMM: IEEE1284 negotiate indicates no data available.&bslash;n&quot;
)paren
suffix:semicolon
id|imm_fail
c_func
(paren
id|tmp
comma
id|DID_ERROR
)paren
suffix:semicolon
)brace
r_return
id|a
suffix:semicolon
)brace
multiline_comment|/* &n; * Clear EPP timeout bit. &n; */
DECL|function|epp_reset
r_static
r_inline
r_void
id|epp_reset
c_func
(paren
r_int
r_int
id|ppb
)paren
(brace
r_int
id|i
suffix:semicolon
id|i
op_assign
id|r_str
c_func
(paren
id|ppb
)paren
suffix:semicolon
id|w_str
c_func
(paren
id|ppb
comma
id|i
)paren
suffix:semicolon
id|w_str
c_func
(paren
id|ppb
comma
id|i
op_amp
l_int|0xfe
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Wait for empty ECP fifo (if we are in ECP fifo mode only)&n; */
DECL|function|ecp_sync
r_static
r_inline
r_void
id|ecp_sync
c_func
(paren
id|imm_struct
op_star
id|dev
)paren
(brace
r_int
id|i
comma
id|ppb_hi
op_assign
id|dev-&gt;base_hi
suffix:semicolon
r_if
c_cond
(paren
id|ppb_hi
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r_ecr
c_func
(paren
id|ppb_hi
)paren
op_amp
l_int|0xe0
)paren
op_eq
l_int|0x60
)paren
(brace
multiline_comment|/* mode 011 == ECP fifo mode */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|100
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|r_ecr
c_func
(paren
id|ppb_hi
)paren
op_amp
l_int|0x01
)paren
r_return
suffix:semicolon
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;imm: ECP sync failed as data still present in FIFO.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|imm_byte_out
r_static
r_int
id|imm_byte_out
c_func
(paren
r_int
r_int
id|base
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x4
)paren
suffix:semicolon
multiline_comment|/* apparently a sane mode */
r_for
c_loop
(paren
id|i
op_assign
id|len
op_rshift
l_int|1
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|w_dtr
c_func
(paren
id|base
comma
op_star
id|buffer
op_increment
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x5
)paren
suffix:semicolon
multiline_comment|/* Drop STROBE low */
id|w_dtr
c_func
(paren
id|base
comma
op_star
id|buffer
op_increment
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x0
)paren
suffix:semicolon
multiline_comment|/* STROBE high + INIT low */
)brace
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x4
)paren
suffix:semicolon
multiline_comment|/* apparently a sane mode */
r_return
l_int|1
suffix:semicolon
multiline_comment|/* All went well - we hope! */
)brace
DECL|function|imm_nibble_in
r_static
r_int
id|imm_nibble_in
c_func
(paren
r_int
r_int
id|base
comma
r_char
op_star
id|buffer
comma
r_int
id|len
)paren
(brace
r_int
r_char
id|l
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * The following is based on documented timing signals&n;&t; */
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x4
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|len
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x6
)paren
suffix:semicolon
id|l
op_assign
(paren
id|r_str
c_func
(paren
id|base
)paren
op_amp
l_int|0xf0
)paren
op_rshift
l_int|4
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x5
)paren
suffix:semicolon
op_star
id|buffer
op_increment
op_assign
(paren
id|r_str
c_func
(paren
id|base
)paren
op_amp
l_int|0xf0
)paren
op_or
id|l
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x4
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* All went well - we hope! */
)brace
DECL|function|imm_byte_in
r_static
r_int
id|imm_byte_in
c_func
(paren
r_int
r_int
id|base
comma
r_char
op_star
id|buffer
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * The following is based on documented timing signals&n;&t; */
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x4
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|len
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x26
)paren
suffix:semicolon
op_star
id|buffer
op_increment
op_assign
id|r_dtr
c_func
(paren
id|base
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x25
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* All went well - we hope! */
)brace
DECL|function|imm_out
r_static
r_int
id|imm_out
c_func
(paren
id|imm_struct
op_star
id|dev
comma
r_char
op_star
id|buffer
comma
r_int
id|len
)paren
(brace
r_int
r_int
id|ppb
op_assign
id|dev-&gt;base
suffix:semicolon
r_int
id|r
op_assign
id|imm_wait
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure that:&n;&t; * a) the SCSI bus is BUSY (device still listening)&n;&t; * b) the device is listening&n;&t; */
r_if
c_cond
(paren
(paren
id|r
op_amp
l_int|0x18
)paren
op_ne
l_int|0x08
)paren
(brace
id|imm_fail
c_func
(paren
id|dev
comma
id|DID_ERROR
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;IMM: returned SCSI status %2x&bslash;n&quot;
comma
id|r
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|dev-&gt;mode
)paren
(brace
r_case
id|IMM_EPP_32
suffix:colon
r_case
id|IMM_EPP_16
suffix:colon
r_case
id|IMM_EPP_8
suffix:colon
id|epp_reset
c_func
(paren
id|ppb
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x4
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SCSI_IZIP_EPP16
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
(paren
r_int
)paren
id|buffer
op_or
id|len
)paren
op_amp
l_int|0x01
)paren
)paren
id|outsw
c_func
(paren
id|ppb
op_plus
l_int|4
comma
id|buffer
comma
id|len
op_rshift
l_int|1
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
(paren
r_int
)paren
id|buffer
op_or
id|len
)paren
op_amp
l_int|0x03
)paren
)paren
id|outsl
c_func
(paren
id|ppb
op_plus
l_int|4
comma
id|buffer
comma
id|len
op_rshift
l_int|2
)paren
suffix:semicolon
macro_line|#endif
r_else
id|outsb
c_func
(paren
id|ppb
op_plus
l_int|4
comma
id|buffer
comma
id|len
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
id|r
op_assign
op_logical_neg
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x01
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
id|ecp_sync
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IMM_NIBBLE
suffix:colon
r_case
id|IMM_PS2
suffix:colon
multiline_comment|/* 8 bit output, with a loop */
id|r
op_assign
id|imm_byte_out
c_func
(paren
id|ppb
comma
id|buffer
comma
id|len
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;IMM: bug in imm_out()&bslash;n&quot;
)paren
suffix:semicolon
id|r
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|r
suffix:semicolon
)brace
DECL|function|imm_in
r_static
r_int
id|imm_in
c_func
(paren
id|imm_struct
op_star
id|dev
comma
r_char
op_star
id|buffer
comma
r_int
id|len
)paren
(brace
r_int
r_int
id|ppb
op_assign
id|dev-&gt;base
suffix:semicolon
r_int
id|r
op_assign
id|imm_wait
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure that:&n;&t; * a) the SCSI bus is BUSY (device still listening)&n;&t; * b) the device is sending data&n;&t; */
r_if
c_cond
(paren
(paren
id|r
op_amp
l_int|0x18
)paren
op_ne
l_int|0x18
)paren
(brace
id|imm_fail
c_func
(paren
id|dev
comma
id|DID_ERROR
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|dev-&gt;mode
)paren
(brace
r_case
id|IMM_NIBBLE
suffix:colon
multiline_comment|/* 4 bit input, with a loop */
id|r
op_assign
id|imm_nibble_in
c_func
(paren
id|ppb
comma
id|buffer
comma
id|len
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IMM_PS2
suffix:colon
multiline_comment|/* 8 bit input, with a loop */
id|r
op_assign
id|imm_byte_in
c_func
(paren
id|ppb
comma
id|buffer
comma
id|len
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IMM_EPP_32
suffix:colon
r_case
id|IMM_EPP_16
suffix:colon
r_case
id|IMM_EPP_8
suffix:colon
id|epp_reset
c_func
(paren
id|ppb
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x24
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SCSI_IZIP_EPP16
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
(paren
r_int
)paren
id|buffer
op_or
id|len
)paren
op_amp
l_int|0x01
)paren
)paren
id|insw
c_func
(paren
id|ppb
op_plus
l_int|4
comma
id|buffer
comma
id|len
op_rshift
l_int|1
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
(paren
r_int
)paren
id|buffer
op_or
id|len
)paren
op_amp
l_int|0x03
)paren
)paren
id|insl
c_func
(paren
id|ppb
op_plus
l_int|4
comma
id|buffer
comma
id|len
op_rshift
l_int|2
)paren
suffix:semicolon
macro_line|#endif
r_else
id|insb
c_func
(paren
id|ppb
op_plus
l_int|4
comma
id|buffer
comma
id|len
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x2c
)paren
suffix:semicolon
id|r
op_assign
op_logical_neg
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x01
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x2c
)paren
suffix:semicolon
id|ecp_sync
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;IMM: bug in imm_ins()&bslash;n&quot;
)paren
suffix:semicolon
id|r
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|r
suffix:semicolon
)brace
DECL|function|imm_cpp
r_static
r_int
id|imm_cpp
c_func
(paren
r_int
r_int
id|ppb
comma
r_int
r_char
id|b
)paren
(brace
multiline_comment|/*&n;&t; * Comments on udelay values refer to the&n;&t; * Command Packet Protocol (CPP) timing diagram.&n;&t; */
r_int
r_char
id|s1
comma
id|s2
comma
id|s3
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
multiline_comment|/* 1 usec - infinite */
id|w_dtr
c_func
(paren
id|ppb
comma
l_int|0xaa
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* 7 usec - infinite */
id|w_dtr
c_func
(paren
id|ppb
comma
l_int|0x55
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* 7 usec - infinite */
id|w_dtr
c_func
(paren
id|ppb
comma
l_int|0x00
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* 7 usec - infinite */
id|w_dtr
c_func
(paren
id|ppb
comma
l_int|0xff
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* 7 usec - infinite */
id|s1
op_assign
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0xb8
suffix:semicolon
id|w_dtr
c_func
(paren
id|ppb
comma
l_int|0x87
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* 7 usec - infinite */
id|s2
op_assign
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0xb8
suffix:semicolon
id|w_dtr
c_func
(paren
id|ppb
comma
l_int|0x78
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* 7 usec - infinite */
id|s3
op_assign
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x38
suffix:semicolon
multiline_comment|/*&n;&t; * Values for b are:&n;&t; * 0000 00aa    Assign address aa to current device&n;&t; * 0010 00aa    Select device aa in EPP Winbond mode&n;&t; * 0010 10aa    Select device aa in EPP mode&n;&t; * 0011 xxxx    Deselect all devices&n;&t; * 0110 00aa    Test device aa&n;&t; * 1101 00aa    Select device aa in ECP mode&n;&t; * 1110 00aa    Select device aa in Compatible mode&n;&t; */
id|w_dtr
c_func
(paren
id|ppb
comma
id|b
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
multiline_comment|/* 1 usec - infinite */
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* 7 usec - infinite */
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0d
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
multiline_comment|/* 1 usec - infinite */
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* 7 usec - infinite */
id|w_dtr
c_func
(paren
id|ppb
comma
l_int|0xff
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* 7 usec - infinite */
multiline_comment|/*&n;&t; * The following table is electrical pin values.&n;&t; * (BSY is inverted at the CTR register)&n;&t; *&n;&t; *       BSY  ACK  POut SEL  Fault&n;&t; * S1    0    X    1    1    1&n;&t; * S2    1    X    0    1    1&n;&t; * S3    L    X    1    1    S&n;&t; *&n;&t; * L =&gt; Last device in chain&n;&t; * S =&gt; Selected&n;&t; *&n;&t; * Observered values for S1,S2,S3 are:&n;&t; * Disconnect =&gt; f8/58/78&n;&t; * Connect    =&gt; f8/58/70&n;&t; */
r_if
c_cond
(paren
(paren
id|s1
op_eq
l_int|0xb8
)paren
op_logical_and
(paren
id|s2
op_eq
l_int|0x18
)paren
op_logical_and
(paren
id|s3
op_eq
l_int|0x30
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Connected */
r_if
c_cond
(paren
(paren
id|s1
op_eq
l_int|0xb8
)paren
op_logical_and
(paren
id|s2
op_eq
l_int|0x18
)paren
op_logical_and
(paren
id|s3
op_eq
l_int|0x38
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Disconnected */
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* No device present */
)brace
DECL|function|imm_connect
r_static
r_inline
r_int
id|imm_connect
c_func
(paren
id|imm_struct
op_star
id|dev
comma
r_int
id|flag
)paren
(brace
r_int
r_int
id|ppb
op_assign
id|dev-&gt;base
suffix:semicolon
id|imm_cpp
c_func
(paren
id|ppb
comma
l_int|0xe0
)paren
suffix:semicolon
multiline_comment|/* Select device 0 in compatible mode */
id|imm_cpp
c_func
(paren
id|ppb
comma
l_int|0x30
)paren
suffix:semicolon
multiline_comment|/* Disconnect all devices */
r_if
c_cond
(paren
(paren
id|dev-&gt;mode
op_eq
id|IMM_EPP_8
)paren
op_logical_or
(paren
id|dev-&gt;mode
op_eq
id|IMM_EPP_16
)paren
op_logical_or
(paren
id|dev-&gt;mode
op_eq
id|IMM_EPP_32
)paren
)paren
r_return
id|imm_cpp
c_func
(paren
id|ppb
comma
l_int|0x28
)paren
suffix:semicolon
multiline_comment|/* Select device 0 in EPP mode */
r_return
id|imm_cpp
c_func
(paren
id|ppb
comma
l_int|0xe0
)paren
suffix:semicolon
multiline_comment|/* Select device 0 in compatible mode */
)brace
DECL|function|imm_disconnect
r_static
r_void
id|imm_disconnect
c_func
(paren
id|imm_struct
op_star
id|dev
)paren
(brace
id|imm_cpp
c_func
(paren
id|dev-&gt;base
comma
l_int|0x30
)paren
suffix:semicolon
multiline_comment|/* Disconnect all devices */
)brace
DECL|function|imm_select
r_static
r_int
id|imm_select
c_func
(paren
id|imm_struct
op_star
id|dev
comma
r_int
id|target
)paren
(brace
r_int
id|k
suffix:semicolon
r_int
r_int
id|ppb
op_assign
id|dev-&gt;base
suffix:semicolon
multiline_comment|/*&n;&t; * Firstly we want to make sure there is nothing&n;&t; * holding onto the SCSI bus.&n;&t; */
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
id|k
op_assign
id|IMM_SELECT_TMO
suffix:semicolon
r_do
(brace
id|k
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x08
)paren
op_logical_and
(paren
id|k
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|k
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Now assert the SCSI ID (HOST and TARGET) on the data bus&n;&t; */
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x4
)paren
suffix:semicolon
id|w_dtr
c_func
(paren
id|ppb
comma
l_int|0x80
op_or
(paren
l_int|1
op_lshift
id|target
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Deassert SELIN first followed by STROBE&n;&t; */
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xd
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * ACK should drop low while SELIN is deasserted.&n;&t; * FAULT should drop low when the SCSI device latches the bus.&n;&t; */
id|k
op_assign
id|IMM_SELECT_TMO
suffix:semicolon
r_do
(brace
id|k
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x08
)paren
op_logical_and
(paren
id|k
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Place the interface back into a sane state (status mode)&n;&t; */
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
r_return
(paren
id|k
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|imm_init
r_static
r_int
id|imm_init
c_func
(paren
id|imm_struct
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|imm_connect
c_func
(paren
id|dev
comma
l_int|0
)paren
op_ne
l_int|1
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|imm_reset_pulse
c_func
(paren
id|dev-&gt;base
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* Delay to allow devices to settle */
id|imm_disconnect
c_func
(paren
id|dev
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* Another delay to allow devices to settle */
r_return
id|device_check
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
DECL|function|imm_send_command
r_static
r_inline
r_int
id|imm_send_command
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
id|imm_struct
op_star
id|dev
op_assign
id|imm_dev
c_func
(paren
id|cmd-&gt;device-&gt;host
)paren
suffix:semicolon
r_int
id|k
suffix:semicolon
multiline_comment|/* NOTE: IMM uses byte pairs */
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|cmd-&gt;cmd_len
suffix:semicolon
id|k
op_add_assign
l_int|2
)paren
r_if
c_cond
(paren
op_logical_neg
id|imm_out
c_func
(paren
id|dev
comma
op_amp
id|cmd-&gt;cmnd
(braket
id|k
)braket
comma
l_int|2
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * The bulk flag enables some optimisations in the data transfer loops,&n; * it should be true for any command that transfers data in integral&n; * numbers of sectors.&n; * &n; * The driver appears to remain stable if we speed up the parallel port&n; * i/o in this function, but not elsewhere.&n; */
DECL|function|imm_completion
r_static
r_int
id|imm_completion
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
multiline_comment|/* Return codes:&n;&t; * -1     Error&n;&t; *  0     Told to schedule&n;&t; *  1     Finished data transfer&n;&t; */
id|imm_struct
op_star
id|dev
op_assign
id|imm_dev
c_func
(paren
id|cmd-&gt;device-&gt;host
)paren
suffix:semicolon
r_int
r_int
id|ppb
op_assign
id|dev-&gt;base
suffix:semicolon
r_int
r_int
id|start_jiffies
op_assign
id|jiffies
suffix:semicolon
r_int
r_char
id|r
comma
id|v
suffix:semicolon
r_int
id|fast
comma
id|bulk
comma
id|status
suffix:semicolon
id|v
op_assign
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
suffix:semicolon
id|bulk
op_assign
(paren
(paren
id|v
op_eq
id|READ_6
)paren
op_logical_or
(paren
id|v
op_eq
id|READ_10
)paren
op_logical_or
(paren
id|v
op_eq
id|WRITE_6
)paren
op_logical_or
(paren
id|v
op_eq
id|WRITE_10
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We only get here if the drive is ready to comunicate,&n;&t; * hence no need for a full imm_wait.&n;&t; */
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
id|r
op_assign
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0xb8
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * while (device is not ready to send status byte)&n;&t; *     loop;&n;&t; */
r_while
c_loop
(paren
id|r
op_ne
(paren
r_int
r_char
)paren
l_int|0xb8
)paren
(brace
multiline_comment|/*&n;&t;&t; * If we have been running for more than a full timer tick&n;&t;&t; * then take a rest.&n;&t;&t; */
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|start_jiffies
op_plus
l_int|1
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * FAIL if:&n;&t;&t; * a) Drive status is screwy (!ready &amp;&amp; !present)&n;&t;&t; * b) Drive is requesting/sending more data than expected&n;&t;&t; */
r_if
c_cond
(paren
(paren
(paren
id|r
op_amp
l_int|0x88
)paren
op_ne
l_int|0x88
)paren
op_logical_or
(paren
id|cmd-&gt;SCp.this_residual
op_le
l_int|0
)paren
)paren
(brace
id|imm_fail
c_func
(paren
id|dev
comma
id|DID_ERROR
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* ERROR_RETURN */
)brace
multiline_comment|/* determine if we should use burst I/O */
r_if
c_cond
(paren
id|dev-&gt;rd
op_eq
l_int|0
)paren
(brace
id|fast
op_assign
(paren
id|bulk
op_logical_and
(paren
id|cmd-&gt;SCp.this_residual
op_ge
id|IMM_BURST_SIZE
)paren
)paren
ques
c_cond
id|IMM_BURST_SIZE
suffix:colon
l_int|2
suffix:semicolon
id|status
op_assign
id|imm_out
c_func
(paren
id|dev
comma
id|cmd-&gt;SCp.ptr
comma
id|fast
)paren
suffix:semicolon
)brace
r_else
(brace
id|fast
op_assign
(paren
id|bulk
op_logical_and
(paren
id|cmd-&gt;SCp.this_residual
op_ge
id|IMM_BURST_SIZE
)paren
)paren
ques
c_cond
id|IMM_BURST_SIZE
suffix:colon
l_int|1
suffix:semicolon
id|status
op_assign
id|imm_in
c_func
(paren
id|dev
comma
id|cmd-&gt;SCp.ptr
comma
id|fast
)paren
suffix:semicolon
)brace
id|cmd-&gt;SCp.ptr
op_add_assign
id|fast
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_sub_assign
id|fast
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
id|imm_fail
c_func
(paren
id|dev
comma
id|DID_BUS_BUSY
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* ERROR_RETURN */
)brace
r_if
c_cond
(paren
id|cmd-&gt;SCp.buffer
op_logical_and
op_logical_neg
id|cmd-&gt;SCp.this_residual
)paren
(brace
multiline_comment|/* if scatter/gather, advance to the next segment */
r_if
c_cond
(paren
id|cmd-&gt;SCp.buffers_residual
op_decrement
)paren
(brace
id|cmd-&gt;SCp.buffer
op_increment
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|cmd-&gt;SCp.buffer-&gt;length
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
id|page_address
c_func
(paren
id|cmd-&gt;SCp.buffer-&gt;page
)paren
op_plus
id|cmd-&gt;SCp.buffer-&gt;offset
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Make sure that we transfer even number of bytes&n;&t;&t;&t;&t; * otherwise it makes imm_byte_out() messy.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|cmd-&gt;SCp.this_residual
op_amp
l_int|0x01
)paren
id|cmd-&gt;SCp.this_residual
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* Now check to see if the drive is ready to comunicate */
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
id|r
op_assign
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0xb8
)paren
suffix:semicolon
multiline_comment|/* If not, drop back down to the scheduler and wait a timer tick */
r_if
c_cond
(paren
op_logical_neg
(paren
id|r
op_amp
l_int|0x80
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* FINISH_RETURN */
)brace
multiline_comment|/*&n; * Since the IMM itself doesn&squot;t generate interrupts, we use&n; * the scheduler&squot;s task queue to generate a stream of call-backs and&n; * complete the request when the drive is ready.&n; */
DECL|function|imm_interrupt
r_static
r_void
id|imm_interrupt
c_func
(paren
r_void
op_star
id|data
)paren
(brace
id|imm_struct
op_star
id|dev
op_assign
(paren
id|imm_struct
op_star
)paren
id|data
suffix:semicolon
r_struct
id|scsi_cmnd
op_star
id|cmd
op_assign
id|dev-&gt;cur_cmd
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|cmd-&gt;device-&gt;host
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;IMM: bug in imm_interrupt&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|imm_engine
c_func
(paren
id|dev
comma
id|cmd
)paren
)paren
(brace
id|INIT_WORK
c_func
(paren
op_amp
id|dev-&gt;imm_tq
comma
id|imm_interrupt
comma
(paren
r_void
op_star
)paren
id|dev
)paren
suffix:semicolon
id|schedule_delayed_work
c_func
(paren
op_amp
id|dev-&gt;imm_tq
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Command must of completed hence it is safe to let go... */
macro_line|#if IMM_DEBUG &gt; 0
r_switch
c_cond
(paren
(paren
id|cmd-&gt;result
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
)paren
(brace
r_case
id|DID_OK
suffix:colon
r_break
suffix:semicolon
r_case
id|DID_NO_CONNECT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;imm: no device at SCSI ID %i&bslash;n&quot;
comma
id|cmd-&gt;device-&gt;id
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_BUS_BUSY
suffix:colon
id|printk
c_func
(paren
l_string|&quot;imm: BUS BUSY - EPP timeout detected&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_TIME_OUT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;imm: unknown timeout&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_ABORT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;imm: told to abort&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_PARITY
suffix:colon
id|printk
c_func
(paren
l_string|&quot;imm: parity error (???)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_ERROR
suffix:colon
id|printk
c_func
(paren
l_string|&quot;imm: internal driver error&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_RESET
suffix:colon
id|printk
c_func
(paren
l_string|&quot;imm: told to reset device&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_BAD_INTR
suffix:colon
id|printk
c_func
(paren
l_string|&quot;imm: bad interrupt (???)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;imm: bad return code (%02x)&bslash;n&quot;
comma
(paren
id|cmd-&gt;result
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|cmd-&gt;SCp.phase
OG
l_int|1
)paren
id|imm_disconnect
c_func
(paren
id|dev
)paren
suffix:semicolon
id|imm_pb_dismiss
c_func
(paren
id|dev
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|dev-&gt;cur_cmd
op_assign
l_int|NULL
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|imm_engine
r_static
r_int
id|imm_engine
c_func
(paren
id|imm_struct
op_star
id|dev
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_int
r_int
id|ppb
op_assign
id|dev-&gt;base
suffix:semicolon
r_int
r_char
id|l
op_assign
l_int|0
comma
id|h
op_assign
l_int|0
suffix:semicolon
r_int
id|retv
comma
id|x
suffix:semicolon
multiline_comment|/* First check for any errors that may have occurred&n;&t; * Here we check for internal errors&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;failed
)paren
r_return
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|cmd-&gt;SCp.phase
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* Phase 0 - Waiting for parport */
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|dev-&gt;jstart
op_plus
id|HZ
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We waited more than a second&n;&t;&t;&t; * for parport to call us&n;&t;&t;&t; */
id|imm_fail
c_func
(paren
id|dev
comma
id|DID_BUS_BUSY
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* wait until imm_wakeup claims parport */
multiline_comment|/* Phase 1 - Connected */
r_case
l_int|1
suffix:colon
id|imm_connect
c_func
(paren
id|dev
comma
id|CONNECT_EPP_MAYBE
)paren
suffix:semicolon
id|cmd-&gt;SCp.phase
op_increment
suffix:semicolon
multiline_comment|/* Phase 2 - We are now talking to the scsi bus */
r_case
l_int|2
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|imm_select
c_func
(paren
id|dev
comma
id|cmd-&gt;device-&gt;id
)paren
)paren
(brace
id|imm_fail
c_func
(paren
id|dev
comma
id|DID_NO_CONNECT
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|cmd-&gt;SCp.phase
op_increment
suffix:semicolon
multiline_comment|/* Phase 3 - Ready to accept a command */
r_case
l_int|3
suffix:colon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x80
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|imm_send_command
c_func
(paren
id|cmd
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|cmd-&gt;SCp.phase
op_increment
suffix:semicolon
multiline_comment|/* Phase 4 - Setup scatter/gather buffers */
r_case
l_int|4
suffix:colon
r_if
c_cond
(paren
id|cmd-&gt;use_sg
)paren
(brace
multiline_comment|/* if many buffers are available, start filling the first */
id|cmd-&gt;SCp.buffer
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;request_buffer
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|cmd-&gt;SCp.buffer-&gt;length
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
id|page_address
c_func
(paren
id|cmd-&gt;SCp.buffer-&gt;page
)paren
op_plus
id|cmd-&gt;SCp.buffer-&gt;offset
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* else fill the only available buffer */
id|cmd-&gt;SCp.buffer
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
id|cmd-&gt;request_buffer
suffix:semicolon
)brace
id|cmd-&gt;SCp.buffers_residual
op_assign
id|cmd-&gt;use_sg
op_minus
l_int|1
suffix:semicolon
id|cmd-&gt;SCp.phase
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;SCp.this_residual
op_amp
l_int|0x01
)paren
id|cmd-&gt;SCp.this_residual
op_increment
suffix:semicolon
multiline_comment|/* Phase 5 - Pre-Data transfer stage */
r_case
l_int|5
suffix:colon
multiline_comment|/* Spin lock for BUSY */
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x80
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Require negotiation for read requests */
id|x
op_assign
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0xb8
)paren
suffix:semicolon
id|dev-&gt;rd
op_assign
(paren
id|x
op_amp
l_int|0x10
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|dev-&gt;dp
op_assign
(paren
id|x
op_amp
l_int|0x20
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;dp
)paren
op_logical_and
(paren
id|dev-&gt;rd
)paren
)paren
r_if
c_cond
(paren
id|imm_negotiate
c_func
(paren
id|dev
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|cmd-&gt;SCp.phase
op_increment
suffix:semicolon
multiline_comment|/* Phase 6 - Data transfer stage */
r_case
l_int|6
suffix:colon
multiline_comment|/* Spin lock for BUSY */
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x80
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;dp
)paren
(brace
id|retv
op_assign
id|imm_completion
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retv
op_eq
op_minus
l_int|1
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|retv
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
)brace
id|cmd-&gt;SCp.phase
op_increment
suffix:semicolon
multiline_comment|/* Phase 7 - Post data transfer stage */
r_case
l_int|7
suffix:colon
r_if
c_cond
(paren
(paren
id|dev-&gt;dp
)paren
op_logical_and
(paren
id|dev-&gt;rd
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev-&gt;mode
op_eq
id|IMM_NIBBLE
)paren
op_logical_or
(paren
id|dev-&gt;mode
op_eq
id|IMM_PS2
)paren
)paren
(brace
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x4
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xe
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x4
)paren
suffix:semicolon
)brace
)brace
id|cmd-&gt;SCp.phase
op_increment
suffix:semicolon
multiline_comment|/* Phase 8 - Read status/message */
r_case
l_int|8
suffix:colon
multiline_comment|/* Check for data overrun */
r_if
c_cond
(paren
id|imm_wait
c_func
(paren
id|dev
)paren
op_ne
(paren
r_int
r_char
)paren
l_int|0xb8
)paren
(brace
id|imm_fail
c_func
(paren
id|dev
comma
id|DID_ERROR
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|imm_negotiate
c_func
(paren
id|dev
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|imm_in
c_func
(paren
id|dev
comma
op_amp
id|l
comma
l_int|1
)paren
)paren
(brace
multiline_comment|/* read status byte */
multiline_comment|/* Check for optional message byte */
r_if
c_cond
(paren
id|imm_wait
c_func
(paren
id|dev
)paren
op_eq
(paren
r_int
r_char
)paren
l_int|0xb8
)paren
id|imm_in
c_func
(paren
id|dev
comma
op_amp
id|h
comma
l_int|1
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
(paren
id|DID_OK
op_lshift
l_int|16
)paren
op_plus
(paren
id|l
op_amp
id|STATUS_MASK
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|dev-&gt;mode
op_eq
id|IMM_NIBBLE
)paren
op_logical_or
(paren
id|dev-&gt;mode
op_eq
id|IMM_PS2
)paren
)paren
(brace
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x4
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xe
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x4
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Finished */
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;imm: Invalid scsi phase&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|imm_queuecommand
r_static
r_int
id|imm_queuecommand
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
r_struct
id|scsi_cmnd
op_star
)paren
)paren
(brace
id|imm_struct
op_star
id|dev
op_assign
id|imm_dev
c_func
(paren
id|cmd-&gt;device-&gt;host
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;cur_cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;IMM: bug in imm_queuecommand&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|dev-&gt;failed
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;jstart
op_assign
id|jiffies
suffix:semicolon
id|dev-&gt;cur_cmd
op_assign
id|cmd
suffix:semicolon
id|cmd-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* default return code */
id|cmd-&gt;SCp.phase
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* bus free */
id|INIT_WORK
c_func
(paren
op_amp
id|dev-&gt;imm_tq
comma
id|imm_interrupt
comma
id|dev
)paren
suffix:semicolon
id|schedule_work
c_func
(paren
op_amp
id|dev-&gt;imm_tq
)paren
suffix:semicolon
id|imm_pb_claim
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Apparently the disk-&gt;capacity attribute is off by 1 sector &n; * for all disk drives.  We add the one here, but it should really&n; * be done in sd.c.  Even if it gets fixed there, this will still&n; * work.&n; */
DECL|function|imm_biosparam
r_static
r_int
id|imm_biosparam
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
comma
r_struct
id|block_device
op_star
id|dev
comma
id|sector_t
id|capacity
comma
r_int
id|ip
(braket
)braket
)paren
(brace
id|ip
(braket
l_int|0
)braket
op_assign
l_int|0x40
suffix:semicolon
id|ip
(braket
l_int|1
)braket
op_assign
l_int|0x20
suffix:semicolon
id|ip
(braket
l_int|2
)braket
op_assign
(paren
(paren
r_int
r_int
)paren
id|capacity
op_plus
l_int|1
)paren
op_div
(paren
id|ip
(braket
l_int|0
)braket
op_star
id|ip
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
(braket
l_int|2
)braket
OG
l_int|1024
)paren
(brace
id|ip
(braket
l_int|0
)braket
op_assign
l_int|0xff
suffix:semicolon
id|ip
(braket
l_int|1
)braket
op_assign
l_int|0x3f
suffix:semicolon
id|ip
(braket
l_int|2
)braket
op_assign
(paren
(paren
r_int
r_int
)paren
id|capacity
op_plus
l_int|1
)paren
op_div
(paren
id|ip
(braket
l_int|0
)braket
op_star
id|ip
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|imm_abort
r_static
r_int
id|imm_abort
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
id|imm_struct
op_star
id|dev
op_assign
id|imm_dev
c_func
(paren
id|cmd-&gt;device-&gt;host
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * There is no method for aborting commands since Iomega&n;&t; * have tied the SCSI_MESSAGE line high in the interface&n;&t; */
r_switch
c_cond
(paren
id|cmd-&gt;SCp.phase
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* Do not have access to parport */
r_case
l_int|1
suffix:colon
multiline_comment|/* Have not connected to interface */
id|dev-&gt;cur_cmd
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Forget the problem */
r_return
id|SUCCESS
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* SCSI command sent, can not abort */
r_return
id|FAILED
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|imm_reset_pulse
r_static
r_void
id|imm_reset_pulse
c_func
(paren
r_int
r_int
id|base
)paren
(brace
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x04
)paren
suffix:semicolon
id|w_dtr
c_func
(paren
id|base
comma
l_int|0x40
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x0c
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x0d
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x0c
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x04
)paren
suffix:semicolon
)brace
DECL|function|imm_reset
r_static
r_int
id|imm_reset
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
id|imm_struct
op_star
id|dev
op_assign
id|imm_dev
c_func
(paren
id|cmd-&gt;device-&gt;host
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;SCp.phase
)paren
id|imm_disconnect
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;cur_cmd
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Forget the problem */
id|imm_connect
c_func
(paren
id|dev
comma
id|CONNECT_NORMAL
)paren
suffix:semicolon
id|imm_reset_pulse
c_func
(paren
id|dev-&gt;base
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* device settle delay */
id|imm_disconnect
c_func
(paren
id|dev
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* device settle delay */
r_return
id|SUCCESS
suffix:semicolon
)brace
DECL|function|device_check
r_static
r_int
id|device_check
c_func
(paren
id|imm_struct
op_star
id|dev
)paren
(brace
multiline_comment|/* This routine looks for a device and then attempts to use EPP&n;&t;   to send a command. If all goes as planned then EPP is available. */
r_static
r_char
id|cmd
(braket
l_int|6
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
r_int
id|loop
comma
id|old_mode
comma
id|status
comma
id|k
comma
id|ppb
op_assign
id|dev-&gt;base
suffix:semicolon
r_int
r_char
id|l
suffix:semicolon
id|old_mode
op_assign
id|dev-&gt;mode
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
l_int|8
suffix:semicolon
id|loop
op_increment
)paren
(brace
multiline_comment|/* Attempt to use EPP for Test Unit Ready */
r_if
c_cond
(paren
(paren
id|ppb
op_amp
l_int|0x0007
)paren
op_eq
l_int|0x0000
)paren
id|dev-&gt;mode
op_assign
id|IMM_EPP_32
suffix:semicolon
id|second_pass
suffix:colon
id|imm_connect
c_func
(paren
id|dev
comma
id|CONNECT_EPP_MAYBE
)paren
suffix:semicolon
multiline_comment|/* Select SCSI device */
r_if
c_cond
(paren
op_logical_neg
id|imm_select
c_func
(paren
id|dev
comma
id|loop
)paren
)paren
(brace
id|imm_disconnect
c_func
(paren
id|dev
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;imm: Found device at ID %i, Attempting to use %s&bslash;n&quot;
comma
id|loop
comma
id|IMM_MODE_STRING
(braket
id|dev-&gt;mode
)braket
)paren
suffix:semicolon
multiline_comment|/* Send SCSI command */
id|status
op_assign
l_int|1
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
(paren
id|l
OL
l_int|3
)paren
op_logical_and
(paren
id|status
)paren
suffix:semicolon
id|l
op_increment
)paren
id|status
op_assign
id|imm_out
c_func
(paren
id|dev
comma
op_amp
id|cmd
(braket
id|l
op_lshift
l_int|1
)braket
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
id|imm_disconnect
c_func
(paren
id|dev
)paren
suffix:semicolon
id|imm_connect
c_func
(paren
id|dev
comma
id|CONNECT_EPP_MAYBE
)paren
suffix:semicolon
id|imm_reset_pulse
c_func
(paren
id|dev-&gt;base
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|imm_disconnect
c_func
(paren
id|dev
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;mode
op_eq
id|IMM_EPP_32
)paren
(brace
id|dev-&gt;mode
op_assign
id|old_mode
suffix:semicolon
r_goto
id|second_pass
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;imm: Unable to establish communication&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
id|k
op_assign
l_int|1000000
suffix:semicolon
multiline_comment|/* 1 Second */
r_do
(brace
id|l
op_assign
id|r_str
c_func
(paren
id|ppb
)paren
suffix:semicolon
id|k
op_decrement
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|l
op_amp
l_int|0x80
)paren
op_logical_and
(paren
id|k
)paren
)paren
suffix:semicolon
id|l
op_and_assign
l_int|0xb8
suffix:semicolon
r_if
c_cond
(paren
id|l
op_ne
l_int|0xb8
)paren
(brace
id|imm_disconnect
c_func
(paren
id|dev
)paren
suffix:semicolon
id|imm_connect
c_func
(paren
id|dev
comma
id|CONNECT_EPP_MAYBE
)paren
suffix:semicolon
id|imm_reset_pulse
c_func
(paren
id|dev-&gt;base
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|imm_disconnect
c_func
(paren
id|dev
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;mode
op_eq
id|IMM_EPP_32
)paren
(brace
id|dev-&gt;mode
op_assign
id|old_mode
suffix:semicolon
r_goto
id|second_pass
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;imm: Unable to establish communication&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|imm_disconnect
c_func
(paren
id|dev
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;imm: Communication established at 0x%x with ID %i using %s&bslash;n&quot;
comma
id|ppb
comma
id|loop
comma
id|IMM_MODE_STRING
(braket
id|dev-&gt;mode
)braket
)paren
suffix:semicolon
id|imm_connect
c_func
(paren
id|dev
comma
id|CONNECT_EPP_MAYBE
)paren
suffix:semicolon
id|imm_reset_pulse
c_func
(paren
id|dev-&gt;base
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|imm_disconnect
c_func
(paren
id|dev
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;imm: No devices found&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|function|imm_adjust_queue
r_static
r_int
id|imm_adjust_queue
c_func
(paren
r_struct
id|scsi_device
op_star
id|device
)paren
(brace
id|blk_queue_bounce_limit
c_func
(paren
id|device-&gt;request_queue
comma
id|BLK_BOUNCE_HIGH
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|imm_template
r_static
r_struct
id|scsi_host_template
id|imm_template
op_assign
(brace
dot
id|module
op_assign
id|THIS_MODULE
comma
dot
id|proc_name
op_assign
l_string|&quot;imm&quot;
comma
dot
id|proc_info
op_assign
id|imm_proc_info
comma
dot
id|name
op_assign
l_string|&quot;Iomega VPI2 (imm) interface&quot;
comma
dot
id|queuecommand
op_assign
id|imm_queuecommand
comma
dot
id|eh_abort_handler
op_assign
id|imm_abort
comma
dot
id|eh_bus_reset_handler
op_assign
id|imm_reset
comma
dot
id|eh_host_reset_handler
op_assign
id|imm_reset
comma
dot
id|bios_param
op_assign
id|imm_biosparam
comma
dot
id|this_id
op_assign
l_int|7
comma
dot
id|sg_tablesize
op_assign
id|SG_ALL
comma
dot
id|cmd_per_lun
op_assign
l_int|1
comma
dot
id|use_clustering
op_assign
id|ENABLE_CLUSTERING
comma
dot
id|can_queue
op_assign
l_int|1
comma
dot
id|slave_alloc
op_assign
id|imm_adjust_queue
comma
dot
id|unchecked_isa_dma
op_assign
l_int|1
comma
multiline_comment|/* imm cannot deal with highmem, so&n;&t;&t;&t;&t;      * this is an easy trick to ensure&n;&t;&t;&t;&t;      * all io pages for this host reside&n;&t;&t;&t;&t;      * in low memory */
)brace
suffix:semicolon
multiline_comment|/***************************************************************************&n; *                   Parallel port probing routines                        *&n; ***************************************************************************/
r_static
id|LIST_HEAD
c_func
(paren
id|imm_hosts
)paren
suffix:semicolon
DECL|function|__imm_attach
r_static
r_int
id|__imm_attach
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
id|imm_struct
op_star
id|dev
suffix:semicolon
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|waiting
)paren
suffix:semicolon
id|DEFINE_WAIT
c_func
(paren
id|wait
)paren
suffix:semicolon
r_int
id|ports
suffix:semicolon
r_int
id|modes
comma
id|ppb
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|waiting
)paren
suffix:semicolon
id|dev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|imm_struct
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|dev
comma
l_int|0
comma
r_sizeof
(paren
id|imm_struct
)paren
)paren
suffix:semicolon
id|dev-&gt;base
op_assign
op_minus
l_int|1
suffix:semicolon
id|dev-&gt;mode
op_assign
id|IMM_AUTODETECT
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|dev-&gt;list
)paren
suffix:semicolon
id|dev-&gt;dev
op_assign
id|parport_register_device
c_func
(paren
id|pb
comma
l_string|&quot;imm&quot;
comma
l_int|NULL
comma
id|imm_wakeup
comma
l_int|NULL
comma
l_int|0
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;dev
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Claim the bus so it remembers what we do to the control&n;&t; * registers. [ CTR and ECP ]&n;&t; */
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
id|dev-&gt;waiting
op_assign
op_amp
id|waiting
suffix:semicolon
id|prepare_to_wait
c_func
(paren
op_amp
id|waiting
comma
op_amp
id|wait
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|imm_pb_claim
c_func
(paren
id|dev
)paren
)paren
id|schedule_timeout
c_func
(paren
l_int|3
op_star
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;wanted
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;imm%d: failed to claim parport because &quot;
l_string|&quot;a pardevice is owning the port for too long &quot;
l_string|&quot;time!&bslash;n&quot;
comma
id|pb-&gt;number
)paren
suffix:semicolon
id|imm_pb_dismiss
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;waiting
op_assign
l_int|NULL
suffix:semicolon
id|finish_wait
c_func
(paren
op_amp
id|waiting
comma
op_amp
id|wait
)paren
suffix:semicolon
r_goto
id|out1
suffix:semicolon
)brace
id|dev-&gt;waiting
op_assign
l_int|NULL
suffix:semicolon
id|finish_wait
c_func
(paren
op_amp
id|waiting
comma
op_amp
id|wait
)paren
suffix:semicolon
id|ppb
op_assign
id|dev-&gt;base
op_assign
id|dev-&gt;dev-&gt;port-&gt;base
suffix:semicolon
id|dev-&gt;base_hi
op_assign
id|dev-&gt;dev-&gt;port-&gt;base_hi
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
id|modes
op_assign
id|dev-&gt;dev-&gt;port-&gt;modes
suffix:semicolon
multiline_comment|/* Mode detection works up the chain of speed&n;&t; * This avoids a nasty if-then-else-if-... tree&n;&t; */
id|dev-&gt;mode
op_assign
id|IMM_NIBBLE
suffix:semicolon
r_if
c_cond
(paren
id|modes
op_amp
id|PARPORT_MODE_TRISTATE
)paren
id|dev-&gt;mode
op_assign
id|IMM_PS2
suffix:semicolon
multiline_comment|/* Done configuration */
id|err
op_assign
id|imm_init
c_func
(paren
id|dev
)paren
suffix:semicolon
id|imm_pb_release
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out1
suffix:semicolon
multiline_comment|/* now the glue ... */
r_if
c_cond
(paren
id|dev-&gt;mode
op_eq
id|IMM_NIBBLE
op_logical_or
id|dev-&gt;mode
op_eq
id|IMM_PS2
)paren
id|ports
op_assign
l_int|3
suffix:semicolon
r_else
id|ports
op_assign
l_int|8
suffix:semicolon
id|INIT_WORK
c_func
(paren
op_amp
id|dev-&gt;imm_tq
comma
id|imm_interrupt
comma
id|dev
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|host
op_assign
id|scsi_host_alloc
c_func
(paren
op_amp
id|imm_template
comma
r_sizeof
(paren
id|imm_struct
op_star
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|host
)paren
r_goto
id|out1
suffix:semicolon
id|host-&gt;io_port
op_assign
id|pb-&gt;base
suffix:semicolon
id|host-&gt;n_io_port
op_assign
id|ports
suffix:semicolon
id|host-&gt;dma_channel
op_assign
op_minus
l_int|1
suffix:semicolon
id|host-&gt;unique_id
op_assign
id|pb-&gt;number
suffix:semicolon
op_star
(paren
id|imm_struct
op_star
op_star
)paren
op_amp
id|host-&gt;hostdata
op_assign
id|dev
suffix:semicolon
id|dev-&gt;host
op_assign
id|host
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|dev-&gt;list
comma
op_amp
id|imm_hosts
)paren
suffix:semicolon
id|err
op_assign
id|scsi_add_host
c_func
(paren
id|host
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out2
suffix:semicolon
id|scsi_scan_host
c_func
(paren
id|host
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out2
suffix:colon
id|list_del_init
c_func
(paren
op_amp
id|dev-&gt;list
)paren
suffix:semicolon
id|scsi_host_put
c_func
(paren
id|host
)paren
suffix:semicolon
id|out1
suffix:colon
id|parport_unregister_device
c_func
(paren
id|dev-&gt;dev
)paren
suffix:semicolon
id|out
suffix:colon
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|imm_attach
r_static
r_void
id|imm_attach
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
id|__imm_attach
c_func
(paren
id|pb
)paren
suffix:semicolon
)brace
DECL|function|imm_detach
r_static
r_void
id|imm_detach
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
id|imm_struct
op_star
id|dev
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|dev
comma
op_amp
id|imm_hosts
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;dev-&gt;port
op_eq
id|pb
)paren
(brace
id|list_del_init
c_func
(paren
op_amp
id|dev-&gt;list
)paren
suffix:semicolon
id|scsi_remove_host
c_func
(paren
id|dev-&gt;host
)paren
suffix:semicolon
id|scsi_host_put
c_func
(paren
id|dev-&gt;host
)paren
suffix:semicolon
id|parport_unregister_device
c_func
(paren
id|dev-&gt;dev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
DECL|variable|imm_driver
r_static
r_struct
id|parport_driver
id|imm_driver
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;imm&quot;
comma
dot
id|attach
op_assign
id|imm_attach
comma
dot
id|detach
op_assign
id|imm_detach
comma
)brace
suffix:semicolon
DECL|function|imm_driver_init
r_static
r_int
id|__init
id|imm_driver_init
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;imm: Version %s&bslash;n&quot;
comma
id|IMM_VERSION
)paren
suffix:semicolon
r_return
id|parport_register_driver
c_func
(paren
op_amp
id|imm_driver
)paren
suffix:semicolon
)brace
DECL|function|imm_driver_exit
r_static
r_void
id|__exit
id|imm_driver_exit
c_func
(paren
r_void
)paren
(brace
id|parport_unregister_driver
c_func
(paren
op_amp
id|imm_driver
)paren
suffix:semicolon
)brace
DECL|variable|imm_driver_init
id|module_init
c_func
(paren
id|imm_driver_init
)paren
suffix:semicolon
DECL|variable|imm_driver_exit
id|module_exit
c_func
(paren
id|imm_driver_exit
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
