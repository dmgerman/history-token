multiline_comment|/* &n; *  FiberChannel transport specific attributes exported to sysfs.&n; *&n; *  Copyright (c) 2003 Silicon Graphics, Inc.  All rights reserved.&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;scsi/scsi_device.h&gt;
macro_line|#include &lt;scsi/scsi_host.h&gt;
macro_line|#include &lt;scsi/scsi_transport.h&gt;
macro_line|#include &lt;scsi/scsi_transport_fc.h&gt;
macro_line|#include &quot;scsi_priv.h&quot;
DECL|macro|FC_PRINTK
mdefine_line|#define FC_PRINTK(x, l, f, a...)&t;printk(l &quot;scsi(%d:%d:%d:%d): &quot; f, (x)-&gt;host-&gt;host_no, (x)-&gt;channel, (x)-&gt;id, (x)-&gt;lun , ##a)
r_static
r_void
id|transport_class_release
c_func
(paren
r_struct
id|class_device
op_star
id|class_dev
)paren
suffix:semicolon
r_static
r_void
id|host_class_release
c_func
(paren
r_struct
id|class_device
op_star
id|class_dev
)paren
suffix:semicolon
r_static
r_void
id|fc_timeout_blocked_host
c_func
(paren
r_void
op_star
id|data
)paren
suffix:semicolon
r_static
r_void
id|fc_timeout_blocked_tgt
c_func
(paren
r_void
op_star
id|data
)paren
suffix:semicolon
DECL|macro|FC_STARGET_NUM_ATTRS
mdefine_line|#define FC_STARGET_NUM_ATTRS &t;4&t;/* increase this if you add attributes */
DECL|macro|FC_STARGET_OTHER_ATTRS
mdefine_line|#define FC_STARGET_OTHER_ATTRS &t;0&t;/* increase this if you add &quot;always on&quot;&n;&t;&t;&t;&t;&t; * attributes */
DECL|macro|FC_HOST_NUM_ATTRS
mdefine_line|#define FC_HOST_NUM_ATTRS&t;1
DECL|struct|fc_internal
r_struct
id|fc_internal
(brace
DECL|member|t
r_struct
id|scsi_transport_template
id|t
suffix:semicolon
DECL|member|f
r_struct
id|fc_function_template
op_star
id|f
suffix:semicolon
multiline_comment|/* The actual attributes */
DECL|member|private_starget_attrs
r_struct
id|class_device_attribute
id|private_starget_attrs
(braket
id|FC_STARGET_NUM_ATTRS
)braket
suffix:semicolon
multiline_comment|/* The array of null terminated pointers to attributes&n;&t; * needed by scsi_sysfs.c */
DECL|member|starget_attrs
r_struct
id|class_device_attribute
op_star
id|starget_attrs
(braket
id|FC_STARGET_NUM_ATTRS
op_plus
id|FC_STARGET_OTHER_ATTRS
op_plus
l_int|1
)braket
suffix:semicolon
DECL|member|private_host_attrs
r_struct
id|class_device_attribute
id|private_host_attrs
(braket
id|FC_HOST_NUM_ATTRS
)braket
suffix:semicolon
DECL|member|host_attrs
r_struct
id|class_device_attribute
op_star
id|host_attrs
(braket
id|FC_HOST_NUM_ATTRS
op_plus
l_int|1
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|to_fc_internal
mdefine_line|#define to_fc_internal(tmpl)&t;container_of(tmpl, struct fc_internal, t)
DECL|variable|fc_transport_class
r_struct
r_class
id|fc_transport_class
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;fc_transport&quot;
comma
dot
id|release
op_assign
id|transport_class_release
comma
)brace
suffix:semicolon
DECL|variable|fc_host_class
r_struct
r_class
id|fc_host_class
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;fc_host&quot;
comma
dot
id|release
op_assign
id|host_class_release
comma
)brace
suffix:semicolon
DECL|function|fc_transport_init
r_static
id|__init
r_int
id|fc_transport_init
c_func
(paren
r_void
)paren
(brace
r_int
id|error
op_assign
id|class_register
c_func
(paren
op_amp
id|fc_host_class
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_return
id|class_register
c_func
(paren
op_amp
id|fc_transport_class
)paren
suffix:semicolon
)brace
DECL|function|fc_transport_exit
r_static
r_void
id|__exit
id|fc_transport_exit
c_func
(paren
r_void
)paren
(brace
id|class_unregister
c_func
(paren
op_amp
id|fc_transport_class
)paren
suffix:semicolon
id|class_unregister
c_func
(paren
op_amp
id|fc_host_class
)paren
suffix:semicolon
)brace
DECL|function|fc_setup_starget_transport_attrs
r_static
r_int
id|fc_setup_starget_transport_attrs
c_func
(paren
r_struct
id|scsi_target
op_star
id|starget
)paren
(brace
multiline_comment|/* &n;&t; * Set default values easily detected by the midlayer as&n;&t; * failure cases.  The scsi lldd is responsible for initializing&n;&t; * all transport attributes to valid values per target.&n;&t; */
id|fc_starget_node_name
c_func
(paren
id|starget
)paren
op_assign
op_minus
l_int|1
suffix:semicolon
id|fc_starget_port_name
c_func
(paren
id|starget
)paren
op_assign
op_minus
l_int|1
suffix:semicolon
id|fc_starget_port_id
c_func
(paren
id|starget
)paren
op_assign
op_minus
l_int|1
suffix:semicolon
id|fc_starget_dev_loss_tmo
c_func
(paren
id|starget
)paren
op_assign
op_minus
l_int|1
suffix:semicolon
id|INIT_WORK
c_func
(paren
op_amp
id|fc_starget_dev_loss_work
c_func
(paren
id|starget
)paren
comma
id|fc_timeout_blocked_tgt
comma
id|starget
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fc_destroy_starget
r_static
r_void
id|fc_destroy_starget
c_func
(paren
r_struct
id|scsi_target
op_star
id|starget
)paren
(brace
multiline_comment|/* Stop the target timer */
r_if
c_cond
(paren
id|cancel_delayed_work
c_func
(paren
op_amp
id|fc_starget_dev_loss_work
c_func
(paren
id|starget
)paren
)paren
)paren
id|flush_scheduled_work
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|fc_setup_host_transport_attrs
r_static
r_int
id|fc_setup_host_transport_attrs
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
)paren
(brace
multiline_comment|/* &n;&t; * Set default values easily detected by the midlayer as&n;&t; * failure cases.  The scsi lldd is responsible for initializing&n;&t; * all transport attributes to valid values per host.&n;&t; */
id|fc_host_link_down_tmo
c_func
(paren
id|shost
)paren
op_assign
op_minus
l_int|1
suffix:semicolon
id|INIT_WORK
c_func
(paren
op_amp
id|fc_host_link_down_work
c_func
(paren
id|shost
)paren
comma
id|fc_timeout_blocked_host
comma
id|shost
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fc_destroy_host
r_static
r_void
id|fc_destroy_host
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
)paren
(brace
multiline_comment|/* Stop the host timer */
r_if
c_cond
(paren
id|cancel_delayed_work
c_func
(paren
op_amp
id|fc_host_link_down_work
c_func
(paren
id|shost
)paren
)paren
)paren
id|flush_scheduled_work
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|transport_class_release
r_static
r_void
id|transport_class_release
c_func
(paren
r_struct
id|class_device
op_star
id|class_dev
)paren
(brace
r_struct
id|scsi_target
op_star
id|starget
op_assign
id|transport_class_to_starget
c_func
(paren
id|class_dev
)paren
suffix:semicolon
id|put_device
c_func
(paren
op_amp
id|starget-&gt;dev
)paren
suffix:semicolon
)brace
DECL|function|host_class_release
r_static
r_void
id|host_class_release
c_func
(paren
r_struct
id|class_device
op_star
id|class_dev
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|shost
op_assign
id|transport_class_to_shost
c_func
(paren
id|class_dev
)paren
suffix:semicolon
id|put_device
c_func
(paren
op_amp
id|shost-&gt;shost_gendev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Remote Port Attribute Management&n; */
DECL|macro|fc_starget_show_function
mdefine_line|#define fc_starget_show_function(field, format_string, cast)&t;&t;&bslash;&n;static ssize_t&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;show_fc_starget_##field (struct class_device *cdev, char *buf)&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;struct scsi_target *starget = transport_class_to_starget(cdev);&t;&bslash;&n;&t;struct Scsi_Host *shost = dev_to_shost(starget-&gt;dev.parent);&t;&bslash;&n;&t;struct fc_starget_attrs *tp;&t;&t;&t;&t;&t;&bslash;&n;&t;struct fc_internal *i = to_fc_internal(shost-&gt;transportt);&t;&bslash;&n;&t;tp = (struct fc_starget_attrs *)&amp;starget-&gt;starget_data;&t;&t;&bslash;&n;&t;if (i-&gt;f-&gt;get_starget_##field)&t;&t;&t;&t;&t;&bslash;&n;&t;&t;i-&gt;f-&gt;get_starget_##field(starget);&t;&t;&t;&bslash;&n;&t;return snprintf(buf, 20, format_string, cast tp-&gt;field);&t;&bslash;&n;}
DECL|macro|fc_starget_store_function
mdefine_line|#define fc_starget_store_function(field, format_string)&t;&t;&t;&bslash;&n;static ssize_t&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;store_fc_starget_##field(struct class_device *cdev, const char *buf,&t;&bslash;&n;&t;&t;&t;   size_t count)&t;&t;&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;int val;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;struct scsi_target *starget = transport_class_to_starget(cdev);&t;&bslash;&n;&t;struct Scsi_Host *shost = dev_to_shost(starget-&gt;dev.parent);&t;&bslash;&n;&t;struct fc_internal *i = to_fc_internal(shost-&gt;transportt);&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;val = simple_strtoul(buf, NULL, 0);&t;&t;&t;&t;&bslash;&n;&t;i-&gt;f-&gt;set_starget_##field(starget, val);&t;&t;&t;&bslash;&n;&t;return count;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;}
DECL|macro|fc_starget_rd_attr
mdefine_line|#define fc_starget_rd_attr(field, format_string)&t;&t;&t;&bslash;&n;&t;fc_starget_show_function(field, format_string, )&t;&t;&bslash;&n;static CLASS_DEVICE_ATTR(field, S_IRUGO,&t;&t;&t;&t;&bslash;&n;&t;&t;&t; show_fc_starget_##field, NULL)
DECL|macro|fc_starget_rd_attr_cast
mdefine_line|#define fc_starget_rd_attr_cast(field, format_string, cast)&t;&t;&bslash;&n;&t;fc_starget_show_function(field, format_string, (cast))&t;&t;&bslash;&n;static CLASS_DEVICE_ATTR(field, S_IRUGO,&t;&t;&t;&t;&bslash;&n;&t;&t;&t;  show_fc_starget_##field, NULL)
DECL|macro|fc_starget_rw_attr
mdefine_line|#define fc_starget_rw_attr(field, format_string)&t;&t;&t;&bslash;&n;&t;fc_starget_show_function(field, format_string, )&t;&t;&bslash;&n;&t;fc_starget_store_function(field, format_string)&t;&t;&t;&bslash;&n;static CLASS_DEVICE_ATTR(field, S_IRUGO | S_IWUSR,&t;&t;&t;&bslash;&n;&t;&t;&t;show_fc_starget_##field,&t;&t;&t;&bslash;&n;&t;&t;&t;store_fc_starget_##field)
DECL|macro|SETUP_STARGET_ATTRIBUTE_RD
mdefine_line|#define SETUP_STARGET_ATTRIBUTE_RD(field)&t;&t;&t;&t;&bslash;&n;&t;i-&gt;private_starget_attrs[count] = class_device_attr_##field;&t;&bslash;&n;&t;i-&gt;private_starget_attrs[count].attr.mode = S_IRUGO;&t;&t;&bslash;&n;&t;i-&gt;private_starget_attrs[count].store = NULL;&t;&t;&t;&bslash;&n;&t;i-&gt;starget_attrs[count] = &amp;i-&gt;private_starget_attrs[count];&t;&bslash;&n;&t;if (i-&gt;f-&gt;show_starget_##field)&t;&t;&t;&t;&t;&bslash;&n;&t;&t;count++
DECL|macro|SETUP_STARGET_ATTRIBUTE_RW
mdefine_line|#define SETUP_STARGET_ATTRIBUTE_RW(field)&t;&t;&t;&t;&bslash;&n;&t;i-&gt;private_starget_attrs[count] = class_device_attr_##field;&t;&bslash;&n;&t;if (!i-&gt;f-&gt;set_starget_##field) {&t;&t;&t;&t;&bslash;&n;&t;&t;i-&gt;private_starget_attrs[count].attr.mode = S_IRUGO;&t;&bslash;&n;&t;&t;i-&gt;private_starget_attrs[count].store = NULL;&t;&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;i-&gt;starget_attrs[count] = &amp;i-&gt;private_starget_attrs[count];&t;&bslash;&n;&t;if (i-&gt;f-&gt;show_starget_##field)&t;&t;&t;&t;&t;&bslash;&n;&t;&t;count++
multiline_comment|/* The FC Tranport Remote Port (Target) Attributes: */
id|fc_starget_rd_attr_cast
c_func
(paren
id|node_name
comma
l_string|&quot;0x%llx&bslash;n&quot;
comma
r_int
r_int
r_int
)paren
suffix:semicolon
id|fc_starget_rd_attr_cast
c_func
(paren
id|port_name
comma
l_string|&quot;0x%llx&bslash;n&quot;
comma
r_int
r_int
r_int
)paren
suffix:semicolon
id|fc_starget_rd_attr
c_func
(paren
id|port_id
comma
l_string|&quot;0x%06x&bslash;n&quot;
)paren
suffix:semicolon
id|fc_starget_rw_attr
c_func
(paren
id|dev_loss_tmo
comma
l_string|&quot;%d&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * Host Attribute Management&n; */
DECL|macro|fc_host_show_function
mdefine_line|#define fc_host_show_function(field, format_string, cast)&t;&t;&bslash;&n;static ssize_t&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;show_fc_host_##field (struct class_device *cdev, char *buf)&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;struct Scsi_Host *shost = transport_class_to_shost(cdev);&t;&bslash;&n;&t;struct fc_host_attrs *tp;&t;&t;&t;&t;&t;&bslash;&n;&t;struct fc_internal *i = to_fc_internal(shost-&gt;transportt);&t;&bslash;&n;&t;tp = (struct fc_host_attrs *)shost-&gt;shost_data;&t;&t;&bslash;&n;&t;if (i-&gt;f-&gt;get_host_##field)&t;&t;&t;&t;&t;&bslash;&n;&t;&t;i-&gt;f-&gt;get_host_##field(shost);&t;&t;&t;&t;&bslash;&n;&t;return snprintf(buf, 20, format_string, cast tp-&gt;field);&t;&bslash;&n;}
DECL|macro|fc_host_store_function
mdefine_line|#define fc_host_store_function(field, format_string)&t;&t;&t;&bslash;&n;static ssize_t&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;store_fc_host_##field(struct class_device *cdev, const char *buf,&t;&bslash;&n;&t;&t;&t;   size_t count)&t;&t;&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;int val;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;struct Scsi_Host *shost = transport_class_to_shost(cdev);&t;&bslash;&n;&t;struct fc_internal *i = to_fc_internal(shost-&gt;transportt);&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;val = simple_strtoul(buf, NULL, 0);&t;&t;&t;&t;&bslash;&n;&t;i-&gt;f-&gt;set_host_##field(shost, val);&t;&t;&t;&t;&bslash;&n;&t;return count;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;}
DECL|macro|fc_host_rd_attr
mdefine_line|#define fc_host_rd_attr(field, format_string)&t;&t;&t;&t;&bslash;&n;&t;fc_host_show_function(field, format_string, )&t;&t;&t;&bslash;&n;static CLASS_DEVICE_ATTR(host_##field, S_IRUGO,&t;&t;&t;&t;&bslash;&n;&t;&t;&t; show_fc_host_##field, NULL)
DECL|macro|fc_host_rd_attr_cast
mdefine_line|#define fc_host_rd_attr_cast(field, format_string, cast)&t;&t;&bslash;&n;&t;fc_host_show_function(field, format_string, (cast))&t;&t;&bslash;&n;static CLASS_DEVICE_ATTR(host_##field, S_IRUGO,&t;&t;&t;&t;&bslash;&n;&t;&t;&t;  show_fc_host_##field, NULL)
DECL|macro|fc_host_rw_attr
mdefine_line|#define fc_host_rw_attr(field, format_string)&t;&t;&t;&t;&bslash;&n;&t;fc_host_show_function(field, format_string, )&t;&t;&t;&bslash;&n;&t;fc_host_store_function(field, format_string)&t;&t;&t;&bslash;&n;static CLASS_DEVICE_ATTR(host_##field, S_IRUGO | S_IWUSR,&t;&t;&bslash;&n;&t;&t;&t;show_fc_host_##field,&t;&t;&t;&t;&bslash;&n;&t;&t;&t;store_fc_host_##field)
DECL|macro|SETUP_HOST_ATTRIBUTE_RD
mdefine_line|#define SETUP_HOST_ATTRIBUTE_RD(field)&t;&t;&t;&t;&t;&bslash;&n;&t;i-&gt;private_host_attrs[count] = class_device_attr_host_##field;&t;&bslash;&n;&t;i-&gt;private_host_attrs[count].attr.mode = S_IRUGO;&t;&t;&bslash;&n;&t;i-&gt;private_host_attrs[count].store = NULL;&t;&t;&t;&bslash;&n;&t;i-&gt;host_attrs[count] = &amp;i-&gt;private_host_attrs[count];&t;&t;&bslash;&n;&t;if (i-&gt;f-&gt;show_host_##field)&t;&t;&t;&t;&t;&bslash;&n;&t;&t;count++
DECL|macro|SETUP_HOST_ATTRIBUTE_RW
mdefine_line|#define SETUP_HOST_ATTRIBUTE_RW(field)&t;&t;&t;&t;&t;&bslash;&n;&t;i-&gt;private_host_attrs[count] = class_device_attr_host_##field;&t;&bslash;&n;&t;if (!i-&gt;f-&gt;set_host_##field) {&t;&t;&t;&t;&t;&bslash;&n;&t;&t;i-&gt;private_host_attrs[count].attr.mode = S_IRUGO;&t;&bslash;&n;&t;&t;i-&gt;private_host_attrs[count].store = NULL;&t;&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;i-&gt;host_attrs[count] = &amp;i-&gt;private_host_attrs[count];&t;&t;&bslash;&n;&t;if (i-&gt;f-&gt;show_host_##field)&t;&t;&t;&t;&t;&bslash;&n;&t;&t;count++
multiline_comment|/* The FC Tranport Host Attributes: */
id|fc_host_rw_attr
c_func
(paren
id|link_down_tmo
comma
l_string|&quot;%d&bslash;n&quot;
)paren
suffix:semicolon
r_struct
id|scsi_transport_template
op_star
DECL|function|fc_attach_transport
id|fc_attach_transport
c_func
(paren
r_struct
id|fc_function_template
op_star
id|ft
)paren
(brace
r_struct
id|fc_internal
op_star
id|i
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|fc_internal
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|i
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|i
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|fc_internal
)paren
)paren
suffix:semicolon
id|i-&gt;t.target_attrs
op_assign
op_amp
id|i-&gt;starget_attrs
(braket
l_int|0
)braket
suffix:semicolon
id|i-&gt;t.target_class
op_assign
op_amp
id|fc_transport_class
suffix:semicolon
id|i-&gt;t.target_setup
op_assign
op_amp
id|fc_setup_starget_transport_attrs
suffix:semicolon
id|i-&gt;t.target_destroy
op_assign
op_amp
id|fc_destroy_starget
suffix:semicolon
id|i-&gt;t.target_size
op_assign
r_sizeof
(paren
r_struct
id|fc_starget_attrs
)paren
suffix:semicolon
id|i-&gt;t.host_attrs
op_assign
op_amp
id|i-&gt;host_attrs
(braket
l_int|0
)braket
suffix:semicolon
id|i-&gt;t.host_class
op_assign
op_amp
id|fc_host_class
suffix:semicolon
id|i-&gt;t.host_setup
op_assign
op_amp
id|fc_setup_host_transport_attrs
suffix:semicolon
id|i-&gt;t.host_destroy
op_assign
op_amp
id|fc_destroy_host
suffix:semicolon
id|i-&gt;t.host_size
op_assign
r_sizeof
(paren
r_struct
id|fc_host_attrs
)paren
suffix:semicolon
id|i-&gt;f
op_assign
id|ft
suffix:semicolon
multiline_comment|/*&n;&t; * setup remote port (target) attributes&n;&t; */
id|SETUP_STARGET_ATTRIBUTE_RD
c_func
(paren
id|port_id
)paren
suffix:semicolon
id|SETUP_STARGET_ATTRIBUTE_RD
c_func
(paren
id|port_name
)paren
suffix:semicolon
id|SETUP_STARGET_ATTRIBUTE_RD
c_func
(paren
id|node_name
)paren
suffix:semicolon
id|SETUP_STARGET_ATTRIBUTE_RW
c_func
(paren
id|dev_loss_tmo
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|count
OG
id|FC_STARGET_NUM_ATTRS
)paren
suffix:semicolon
multiline_comment|/* Setup the always-on attributes here */
id|i-&gt;starget_attrs
(braket
id|count
)braket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* setup host attributes */
id|count
op_assign
l_int|0
suffix:semicolon
id|SETUP_HOST_ATTRIBUTE_RW
c_func
(paren
id|link_down_tmo
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|count
OG
id|FC_HOST_NUM_ATTRS
)paren
suffix:semicolon
multiline_comment|/* Setup the always-on attributes here */
id|i-&gt;host_attrs
(braket
id|count
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
op_amp
id|i-&gt;t
suffix:semicolon
)brace
DECL|variable|fc_attach_transport
id|EXPORT_SYMBOL
c_func
(paren
id|fc_attach_transport
)paren
suffix:semicolon
DECL|function|fc_release_transport
r_void
id|fc_release_transport
c_func
(paren
r_struct
id|scsi_transport_template
op_star
id|t
)paren
(brace
r_struct
id|fc_internal
op_star
id|i
op_assign
id|to_fc_internal
c_func
(paren
id|t
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
DECL|variable|fc_release_transport
id|EXPORT_SYMBOL
c_func
(paren
id|fc_release_transport
)paren
suffix:semicolon
multiline_comment|/**&n; * fc_device_block - called by target functions to block a scsi device&n; * @dev:&t;scsi device&n; * @data:&t;unused&n; **/
DECL|function|fc_device_block
r_static
r_int
id|fc_device_block
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_void
op_star
id|data
)paren
(brace
id|scsi_internal_device_block
c_func
(paren
id|to_scsi_device
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * fc_device_unblock - called by target functions to unblock a scsi device&n; * @dev:&t;scsi device&n; * @data:&t;unused&n; **/
DECL|function|fc_device_unblock
r_static
r_int
id|fc_device_unblock
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_void
op_star
id|data
)paren
(brace
id|scsi_internal_device_unblock
c_func
(paren
id|to_scsi_device
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * fc_timeout_blocked_tgt - Timeout handler for blocked scsi targets&n; *&t;&t;&t; that fail to recover in the alloted time.&n; * @data:&t;scsi target that failed to reappear in the alloted time.&n; **/
DECL|function|fc_timeout_blocked_tgt
r_static
r_void
id|fc_timeout_blocked_tgt
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|scsi_target
op_star
id|starget
op_assign
(paren
r_struct
id|scsi_target
op_star
)paren
id|data
suffix:semicolon
id|dev_printk
c_func
(paren
id|KERN_ERR
comma
op_amp
id|starget-&gt;dev
comma
l_string|&quot;blocked target time out: target resuming&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * set the device going again ... if the scsi lld didn&squot;t&n;&t; * unblock this device, then IO errors will probably&n;&t; * result if the host still isn&squot;t ready.&n;&t; */
id|device_for_each_child
c_func
(paren
op_amp
id|starget-&gt;dev
comma
l_int|NULL
comma
id|fc_device_unblock
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * fc_target_block - block a target by temporarily putting all its scsi devices&n; *&t;&t;into the SDEV_BLOCK state.&n; * @starget:&t;scsi target managed by this fc scsi lldd.&n; *&n; * scsi lldd&squot;s with a FC transport call this routine to temporarily stop all&n; * scsi commands to all devices managed by this scsi target.  Called &n; * from interrupt or normal process context.&n; *&n; * Returns zero if successful or error if not&n; *&n; * Notes:       &n; *&t;The timeout and timer types are extracted from the fc transport &n; *&t;attributes from the caller&squot;s target pointer.  This routine assumes no&n; *&t;locks are held on entry.&n; **/
r_int
DECL|function|fc_target_block
id|fc_target_block
c_func
(paren
r_struct
id|scsi_target
op_star
id|starget
)paren
(brace
r_int
id|timeout
op_assign
id|fc_starget_dev_loss_tmo
c_func
(paren
id|starget
)paren
suffix:semicolon
r_struct
id|work_struct
op_star
id|work
op_assign
op_amp
id|fc_starget_dev_loss_work
c_func
(paren
id|starget
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timeout
template_param
id|SCSI_DEVICE_BLOCK_MAX_TIMEOUT
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|device_for_each_child
c_func
(paren
op_amp
id|starget-&gt;dev
comma
l_int|NULL
comma
id|fc_device_block
)paren
suffix:semicolon
multiline_comment|/* The scsi lld blocks this target for the timeout period only. */
id|schedule_delayed_work
c_func
(paren
id|work
comma
id|timeout
op_star
id|HZ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|fc_target_block
id|EXPORT_SYMBOL
c_func
(paren
id|fc_target_block
)paren
suffix:semicolon
multiline_comment|/**&n; * fc_target_unblock - unblock a target following a fc_target_block request.&n; * @starget:&t;scsi target managed by this fc scsi lldd.&t;&n; *&n; * scsi lld&squot;s with a FC transport call this routine to restart IO to all &n; * devices associated with the caller&squot;s scsi target following a fc_target_block&n; * request.  Called from interrupt or normal process context.&n; *&n; * Notes:       &n; *&t;This routine assumes no locks are held on entry.&n; **/
r_void
DECL|function|fc_target_unblock
id|fc_target_unblock
c_func
(paren
r_struct
id|scsi_target
op_star
id|starget
)paren
(brace
multiline_comment|/* &n;&t; * Stop the target timer first. Take no action on the del_timer&n;&t; * failure as the state machine state change will validate the&n;&t; * transaction. &n;&t; */
r_if
c_cond
(paren
id|cancel_delayed_work
c_func
(paren
op_amp
id|fc_starget_dev_loss_work
c_func
(paren
id|starget
)paren
)paren
)paren
id|flush_scheduled_work
c_func
(paren
)paren
suffix:semicolon
id|device_for_each_child
c_func
(paren
op_amp
id|starget-&gt;dev
comma
l_int|NULL
comma
id|fc_device_unblock
)paren
suffix:semicolon
)brace
DECL|variable|fc_target_unblock
id|EXPORT_SYMBOL
c_func
(paren
id|fc_target_unblock
)paren
suffix:semicolon
multiline_comment|/**&n; * fc_timeout_blocked_host - Timeout handler for blocked scsi hosts&n; *&t;&t;&t; that fail to recover in the alloted time.&n; * @data:&t;scsi host that failed to recover its devices in the alloted&n; *&t;&t;time.&n; **/
DECL|function|fc_timeout_blocked_host
r_static
r_void
id|fc_timeout_blocked_host
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|shost
op_assign
(paren
r_struct
id|Scsi_Host
op_star
)paren
id|data
suffix:semicolon
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
id|dev_printk
c_func
(paren
id|KERN_ERR
comma
op_amp
id|shost-&gt;shost_gendev
comma
l_string|&quot;blocked host time out: host resuming&bslash;n&quot;
)paren
suffix:semicolon
id|shost_for_each_device
c_func
(paren
id|sdev
comma
id|shost
)paren
(brace
multiline_comment|/* &n;&t;&t; * set the device going again ... if the scsi lld didn&squot;t&n;&t;&t; * unblock this device, then IO errors will probably&n;&t;&t; * result if the host still isn&squot;t ready.&n;&t;&t; */
id|scsi_internal_device_unblock
c_func
(paren
id|sdev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * fc_host_block - block all scsi devices managed by the calling host temporarily &n; *&t;&t;by putting each device in the SDEV_BLOCK state.&n; * @shost:&t;scsi host pointer that contains all scsi device siblings.&n; *&n; * scsi lld&squot;s with a FC transport call this routine to temporarily stop all&n; * scsi commands to all devices managed by this host.  Called &n; * from interrupt or normal process context.&n; *&n; * Returns zero if successful or error if not&n; *&n; * Notes:&n; *&t;The timeout and timer types are extracted from the fc transport &n; *&t;attributes from the caller&squot;s host pointer.  This routine assumes no&n; *&t;locks are held on entry.&n; **/
r_int
DECL|function|fc_host_block
id|fc_host_block
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
r_int
id|timeout
op_assign
id|fc_host_link_down_tmo
c_func
(paren
id|shost
)paren
suffix:semicolon
r_struct
id|work_struct
op_star
id|work
op_assign
op_amp
id|fc_host_link_down_work
c_func
(paren
id|shost
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timeout
template_param
id|SCSI_DEVICE_BLOCK_MAX_TIMEOUT
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|shost_for_each_device
c_func
(paren
id|sdev
comma
id|shost
)paren
(brace
id|scsi_internal_device_block
c_func
(paren
id|sdev
)paren
suffix:semicolon
)brace
id|schedule_delayed_work
c_func
(paren
id|work
comma
id|timeout
op_star
id|HZ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|fc_host_block
id|EXPORT_SYMBOL
c_func
(paren
id|fc_host_block
)paren
suffix:semicolon
multiline_comment|/**&n; * fc_host_unblock - unblock all devices managed by this host following a &n; *&t;&t;fc_host_block request.&n; * @shost:&t;scsi host containing all scsi device siblings to unblock.&n; *&n; * scsi lld&squot;s with a FC transport call this routine to restart IO to all scsi&n; * devices managed by the specified scsi host following an fc_host_block &n; * request.  Called from interrupt or normal process context.&n; *&n; * Notes:       &n; *&t;This routine assumes no locks are held on entry.&n; **/
r_void
DECL|function|fc_host_unblock
id|fc_host_unblock
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
multiline_comment|/* &n;&t; * Stop the host timer first. Take no action on the del_timer&n;&t; * failure as the state machine state change will validate the&n;&t; * transaction.&n;&t; */
r_if
c_cond
(paren
id|cancel_delayed_work
c_func
(paren
op_amp
id|fc_host_link_down_work
c_func
(paren
id|shost
)paren
)paren
)paren
id|flush_scheduled_work
c_func
(paren
)paren
suffix:semicolon
id|shost_for_each_device
c_func
(paren
id|sdev
comma
id|shost
)paren
(brace
id|scsi_internal_device_unblock
c_func
(paren
id|sdev
)paren
suffix:semicolon
)brace
)brace
DECL|variable|fc_host_unblock
id|EXPORT_SYMBOL
c_func
(paren
id|fc_host_unblock
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Martin Hicks&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;FC Transport Attributes&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|variable|fc_transport_init
id|module_init
c_func
(paren
id|fc_transport_init
)paren
suffix:semicolon
DECL|variable|fc_transport_exit
id|module_exit
c_func
(paren
id|fc_transport_exit
)paren
suffix:semicolon
eof
