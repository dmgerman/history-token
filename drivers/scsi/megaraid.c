multiline_comment|/*&n; *&n; *&t;&t;&t;Linux MegaRAID device driver&n; *&n; * Copyright &#xfffd; 2002  LSI Logic Corporation.&n; *&n; *&t;   This program is free software; you can redistribute it and/or&n; *&t;   modify it under the terms of the GNU General Public License&n; *&t;   as published by the Free Software Foundation; either version&n; *&t;   2 of the License, or (at your option) any later version.&n; *&n; * Copyright (c) 2002  Red Hat, Inc. All rights reserved.&n; *&t;  - fixes&n; *&t;  - speed-ups (list handling fixes, issued_list, optimizations.)&n; *&t;  - lots of cleanups.&n; *&n; * Version : v2.00.3 (Feb 19, 2003) - Atul Mukker &lt;Atul.Mukker@lsil.com&gt;&n; *&n; * Description: Linux device driver for LSI Logic MegaRAID controller&n; *&n; * Supported controllers: MegaRAID 418, 428, 438, 466, 762, 467, 471, 490, 493&n; *&t;&t;&t;&t;&t;518, 520, 531, 532&n; *&n; * This driver is supported by LSI Logic, with assistance from Red Hat, Dell,&n; * and others. Please send updates to the public mailing list&n; * linux-megaraid-devel@dell.com, and subscribe to and read archives of this&n; * list at http://lists.us.dell.com/.&n; *&n; * For history of changes, see ChangeLog.megaraid.&n; *&n; */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/reboot.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;scsi/scsicam.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;megaraid.h&quot;
id|MODULE_AUTHOR
(paren
l_string|&quot;LSI Logic Corporation&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
(paren
l_string|&quot;LSI Logic MegaRAID driver&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|variable|max_cmd_per_lun
r_static
r_int
r_int
id|max_cmd_per_lun
op_assign
id|DEF_CMD_PER_LUN
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|max_cmd_per_lun
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|max_cmd_per_lun
comma
l_string|&quot;Maximum number of commands which can be issued to a single LUN (default=DEF_CMD_PER_LUN=63)&quot;
)paren
suffix:semicolon
DECL|variable|max_sectors_per_io
r_static
r_int
r_int
r_int
id|max_sectors_per_io
op_assign
id|MAX_SECTORS_PER_IO
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|max_sectors_per_io
comma
l_string|&quot;h&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|max_sectors_per_io
comma
l_string|&quot;Maximum number of sectors per I/O request (default=MAX_SECTORS_PER_IO=128)&quot;
)paren
suffix:semicolon
DECL|variable|max_mbox_busy_wait
r_static
r_int
r_int
r_int
id|max_mbox_busy_wait
op_assign
id|MBOX_BUSY_WAIT
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|max_mbox_busy_wait
comma
l_string|&quot;h&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|max_mbox_busy_wait
comma
l_string|&quot;Maximum wait for mailbox in microseconds if busy (default=MBOX_BUSY_WAIT=10)&quot;
)paren
suffix:semicolon
DECL|macro|RDINDOOR
mdefine_line|#define RDINDOOR(adapter)&t;&t;readl((adapter)-&gt;base + 0x20)
DECL|macro|RDOUTDOOR
mdefine_line|#define RDOUTDOOR(adapter)&t;&t;readl((adapter)-&gt;base + 0x2C)
DECL|macro|WRINDOOR
mdefine_line|#define WRINDOOR(adapter,value)&t;&t;writel(value, (adapter)-&gt;base + 0x20)
DECL|macro|WROUTDOOR
mdefine_line|#define WROUTDOOR(adapter,value)&t;writel(value, (adapter)-&gt;base + 0x2C)
multiline_comment|/*&n; * Global variables&n; */
DECL|variable|hba_count
r_static
r_int
id|hba_count
suffix:semicolon
DECL|variable|hba_soft_state
r_static
id|adapter_t
op_star
id|hba_soft_state
(braket
id|MAX_CONTROLLERS
)braket
suffix:semicolon
DECL|variable|mega_proc_dir_entry
r_static
r_struct
id|proc_dir_entry
op_star
id|mega_proc_dir_entry
suffix:semicolon
DECL|variable|mega_notifier
r_static
r_struct
id|notifier_block
id|mega_notifier
op_assign
(brace
dot
id|notifier_call
op_assign
id|megaraid_reboot_notify
)brace
suffix:semicolon
multiline_comment|/* For controller re-ordering */
DECL|variable|mega_hbas
r_static
r_struct
id|mega_hbas
id|mega_hbas
(braket
id|MAX_CONTROLLERS
)braket
suffix:semicolon
multiline_comment|/*&n; * The File Operations structure for the serial/ioctl interface of the driver&n; */
DECL|variable|megadev_fops
r_static
r_struct
id|file_operations
id|megadev_fops
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|ioctl
op_assign
id|megadev_ioctl
comma
dot
id|open
op_assign
id|megadev_open
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Array to structures for storing the information about the controllers. This&n; * information is sent to the user level applications, when they do an ioctl&n; * for this information.&n; */
DECL|variable|mcontroller
r_static
r_struct
id|mcontroller
id|mcontroller
(braket
id|MAX_CONTROLLERS
)braket
suffix:semicolon
multiline_comment|/* The current driver version */
DECL|variable|driver_ver
r_static
id|u32
id|driver_ver
op_assign
l_int|0x02000000
suffix:semicolon
multiline_comment|/* major number used by the device for character interface */
DECL|variable|major
r_static
r_int
id|major
suffix:semicolon
DECL|macro|IS_RAID_CH
mdefine_line|#define IS_RAID_CH(hba, ch)&t;(((hba)-&gt;mega_ch_class &gt;&gt; (ch)) &amp; 0x01)
multiline_comment|/*&n; * Debug variable to print some diagnostic messages&n; */
DECL|variable|trace_level
r_static
r_int
id|trace_level
suffix:semicolon
multiline_comment|/*&n; * megaraid_validate_parms()&n; *&n; * Validate that any module parms passed in&n; * have proper values.&n; */
r_static
r_void
DECL|function|megaraid_validate_parms
id|megaraid_validate_parms
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
(paren
id|max_cmd_per_lun
op_le
l_int|0
)paren
op_logical_or
(paren
id|max_cmd_per_lun
OG
id|MAX_CMD_PER_LUN
)paren
)paren
(brace
id|max_cmd_per_lun
op_assign
id|MAX_CMD_PER_LUN
suffix:semicolon
)brace
r_if
c_cond
(paren
id|max_mbox_busy_wait
OG
id|MBOX_BUSY_WAIT
)paren
(brace
id|max_mbox_busy_wait
op_assign
id|MBOX_BUSY_WAIT
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * megaraid_detect()&n; * @host_template - Our soft state maintained by mid-layer&n; *&n; * the detect entry point for the mid-layer.&n; * We scan the PCI bus for our controllers and start them.&n; *&n; * Note: PCI_DEVICE_ID_PERC4_DI below represents the PERC4/Di class of&n; * products. All of them share the same vendor id, device id, and subsystem&n; * vendor id but different subsystem ids. As of now, driver does not use the&n; * subsystem id.&n; */
r_static
r_int
DECL|function|megaraid_detect
id|megaraid_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|host_template
)paren
(brace
r_int
id|i
suffix:semicolon
id|u16
id|dev_sw_table
(braket
)braket
op_assign
(brace
multiline_comment|/* Table of all supported&n;&t;&t;&t;&t;&t;   vendor/device ids */
id|PCI_VENDOR_ID_DELL
comma
id|PCI_DEVICE_ID_DISCOVERY
comma
id|PCI_VENDOR_ID_DELL
comma
id|PCI_DEVICE_ID_PERC4_DI
comma
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_PERC4_QC_VERDE
comma
id|PCI_VENDOR_ID_AMI
comma
id|PCI_DEVICE_ID_AMI_MEGARAID
comma
id|PCI_VENDOR_ID_AMI
comma
id|PCI_DEVICE_ID_AMI_MEGARAID2
comma
id|PCI_VENDOR_ID_AMI
comma
id|PCI_DEVICE_ID_AMI_MEGARAID3
comma
id|PCI_VENDOR_ID_INTEL
comma
id|PCI_DEVICE_ID_AMI_MEGARAID3
comma
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_AMI_MEGARAID3
)brace
suffix:semicolon
id|host_template-&gt;proc_name
op_assign
l_string|&quot;megaraid&quot;
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;megaraid: &quot;
id|MEGARAID_VERSION
)paren
suffix:semicolon
id|megaraid_validate_parms
c_func
(paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|mega_hbas
comma
l_int|0
comma
r_sizeof
(paren
id|mega_hbas
)paren
)paren
suffix:semicolon
id|hba_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Scan PCI bus for our all devices.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|dev_sw_table
)paren
op_div
r_sizeof
(paren
id|u16
)paren
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|mega_find_card
c_func
(paren
id|host_template
comma
id|dev_sw_table
(braket
id|i
)braket
comma
id|dev_sw_table
(braket
id|i
op_plus
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hba_count
)paren
(brace
multiline_comment|/*&n;&t;&t; * re-order hosts so that one with bootable logical drive&n;&t;&t; * comes first&n;&t;&t; */
macro_line|#ifdef CONFIG_PROC_FS
id|mega_proc_dir_entry
op_assign
id|proc_mkdir
c_func
(paren
l_string|&quot;megaraid&quot;
comma
op_amp
id|proc_root
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mega_proc_dir_entry
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;megaraid: failed to create megaraid root&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|hba_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mega_create_proc_entry
c_func
(paren
id|i
comma
id|mega_proc_dir_entry
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t;&t; * Register the driver as a character device, for applications&n;&t;&t; * to access it for ioctls.&n;&t;&t; * First argument (major) to register_chrdev implies a dynamic&n;&t;&t; * major number allocation.&n;&t;&t; */
id|major
op_assign
id|register_chrdev
c_func
(paren
l_int|0
comma
l_string|&quot;megadev&quot;
comma
op_amp
id|megadev_fops
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Register the Shutdown Notification hook in kernel&n;&t;&t; */
r_if
c_cond
(paren
id|register_reboot_notifier
c_func
(paren
op_amp
id|mega_notifier
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;MegaRAID Shutdown routine not registered!!&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_return
id|hba_count
suffix:semicolon
)brace
multiline_comment|/**&n; * mega_find_card() - find and start this controller&n; * @host_template - Our soft state maintained by mid-layer&n; * @pci_vendor - pci vendor id for this controller&n; * @pci_device - pci device id for this controller&n; *&n; * Scans the PCI bus for this vendor and device id combination, setup the&n; * resources, and register ourselves as a SCSI HBA driver, and setup all&n; * parameters for our soft state.&n; *&n; * This routine also checks for some buggy firmware and ajust the flags&n; * accordingly.&n; */
r_static
r_void
DECL|function|mega_find_card
id|mega_find_card
c_func
(paren
id|Scsi_Host_Template
op_star
id|host_template
comma
id|u16
id|pci_vendor
comma
id|u16
id|pci_device
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
l_int|NULL
suffix:semicolon
id|adapter_t
op_star
id|adapter
op_assign
l_int|NULL
suffix:semicolon
id|u32
id|magic64
suffix:semicolon
r_int
r_int
id|mega_baseport
suffix:semicolon
id|u16
id|subsysid
comma
id|subsysvid
suffix:semicolon
id|u8
id|pci_bus
suffix:semicolon
id|u8
id|pci_dev_func
suffix:semicolon
id|u8
id|irq
suffix:semicolon
r_struct
id|pci_dev
op_star
id|pdev
op_assign
l_int|NULL
suffix:semicolon
id|u8
id|did_ioremap_f
op_assign
l_int|0
suffix:semicolon
id|u8
id|did_req_region_f
op_assign
l_int|0
suffix:semicolon
id|u8
id|did_scsi_reg_f
op_assign
l_int|0
suffix:semicolon
id|u8
id|alloc_int_buf_f
op_assign
l_int|0
suffix:semicolon
id|u8
id|alloc_scb_f
op_assign
l_int|0
suffix:semicolon
id|u8
id|got_irq_f
op_assign
l_int|0
suffix:semicolon
id|u8
id|did_setup_mbox_f
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|tbase
suffix:semicolon
r_int
r_int
id|flag
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_while
c_loop
(paren
(paren
id|pdev
op_assign
id|pci_find_device
c_func
(paren
id|pci_vendor
comma
id|pci_device
comma
id|pdev
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|pci_enable_device
(paren
id|pdev
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|pci_bus
op_assign
id|pdev-&gt;bus-&gt;number
suffix:semicolon
id|pci_dev_func
op_assign
id|pdev-&gt;devfn
suffix:semicolon
multiline_comment|/*&n;&t;&t; * For these vendor and device ids, signature offsets are not&n;&t;&t; * valid and 64 bit is implicit&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|pci_vendor
op_eq
id|PCI_VENDOR_ID_DELL
op_logical_and
id|pci_device
op_eq
id|PCI_DEVICE_ID_PERC4_DI
)paren
op_logical_or
(paren
id|pci_vendor
op_eq
id|PCI_VENDOR_ID_LSI_LOGIC
op_logical_and
id|pci_device
op_eq
id|PCI_DEVICE_ID_PERC4_QC_VERDE
)paren
)paren
(brace
id|flag
op_or_assign
id|BOARD_64BIT
suffix:semicolon
)brace
r_else
(brace
id|pci_read_config_dword
c_func
(paren
id|pdev
comma
id|PCI_CONF_AMISIG64
comma
op_amp
id|magic64
)paren
suffix:semicolon
r_if
c_cond
(paren
id|magic64
op_eq
id|HBA_SIGNATURE_64BIT
)paren
id|flag
op_or_assign
id|BOARD_64BIT
suffix:semicolon
)brace
id|subsysvid
op_assign
id|pdev-&gt;subsystem_vendor
suffix:semicolon
id|subsysid
op_assign
id|pdev-&gt;subsystem_device
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we do not find the valid subsys vendor id, refuse to&n;&t;&t; * load the driver. This is part of PCI200X compliance&n;&t;&t; * We load the driver if subsysvid is 0.&n;&t;&t; */
r_if
c_cond
(paren
id|subsysvid
op_logical_and
(paren
id|subsysvid
op_ne
id|AMI_SUBSYS_VID
)paren
op_logical_and
(paren
id|subsysvid
op_ne
id|DELL_SUBSYS_VID
)paren
op_logical_and
(paren
id|subsysvid
op_ne
id|HP_SUBSYS_VID
)paren
op_logical_and
(paren
id|subsysvid
op_ne
id|LSI_SUBSYS_VID
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;megaraid: found 0x%4.04x:0x%4.04x:bus %d:&quot;
comma
id|pci_vendor
comma
id|pci_device
comma
id|pci_bus
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;slot %d:func %d&bslash;n&quot;
comma
id|PCI_SLOT
c_func
(paren
id|pci_dev_func
)paren
comma
id|PCI_FUNC
c_func
(paren
id|pci_dev_func
)paren
)paren
suffix:semicolon
multiline_comment|/* Read the base port and IRQ from PCI */
id|mega_baseport
op_assign
id|pci_resource_start
c_func
(paren
id|pdev
comma
l_int|0
)paren
suffix:semicolon
id|irq
op_assign
id|pdev-&gt;irq
suffix:semicolon
id|tbase
op_assign
id|mega_baseport
suffix:semicolon
r_if
c_cond
(paren
id|pci_resource_flags
c_func
(paren
id|pdev
comma
l_int|0
)paren
op_amp
id|IORESOURCE_MEM
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|request_mem_region
c_func
(paren
id|mega_baseport
comma
l_int|128
comma
l_string|&quot;MegaRAID: LSI Logic Corporation.&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;megaraid: mem region busy!&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|mega_baseport
op_assign
(paren
r_int
r_int
)paren
id|ioremap
c_func
(paren
id|mega_baseport
comma
l_int|128
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mega_baseport
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;megaraid: could not map hba memory&bslash;n&quot;
)paren
suffix:semicolon
id|release_mem_region
c_func
(paren
id|tbase
comma
l_int|128
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|flag
op_or_assign
id|BOARD_MEMMAP
suffix:semicolon
id|did_ioremap_f
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|mega_baseport
op_add_assign
l_int|0x10
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|request_region
c_func
(paren
id|mega_baseport
comma
l_int|16
comma
l_string|&quot;megaraid&quot;
)paren
)paren
(brace
r_goto
id|fail_attach
suffix:semicolon
)brace
id|flag
op_or_assign
id|BOARD_IOMAP
suffix:semicolon
id|did_req_region_f
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Initialize SCSI Host structure */
id|host
op_assign
id|scsi_register
c_func
(paren
id|host_template
comma
r_sizeof
(paren
id|adapter_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|host
)paren
(brace
r_goto
id|fail_attach
suffix:semicolon
)brace
id|did_scsi_reg_f
op_assign
l_int|1
suffix:semicolon
id|scsi_set_device
c_func
(paren
id|host
comma
op_amp
id|pdev-&gt;dev
)paren
suffix:semicolon
id|adapter
op_assign
(paren
id|adapter_t
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|memset
c_func
(paren
id|adapter
comma
l_int|0
comma
r_sizeof
(paren
id|adapter_t
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;scsi%d:Found MegaRAID controller at 0x%lx, IRQ:%d&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|mega_baseport
comma
id|irq
)paren
suffix:semicolon
id|adapter-&gt;base
op_assign
id|mega_baseport
suffix:semicolon
multiline_comment|/* Copy resource info into structure */
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|adapter-&gt;free_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|adapter-&gt;pending_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|adapter-&gt;completed_list
)paren
suffix:semicolon
id|adapter-&gt;flag
op_assign
id|flag
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|adapter-&gt;lock
)paren
suffix:semicolon
id|scsi_assign_lock
c_func
(paren
id|host
comma
op_amp
id|adapter-&gt;lock
)paren
suffix:semicolon
id|host-&gt;cmd_per_lun
op_assign
id|max_cmd_per_lun
suffix:semicolon
id|host-&gt;max_sectors
op_assign
id|max_sectors_per_io
suffix:semicolon
id|adapter-&gt;dev
op_assign
id|pdev
suffix:semicolon
id|adapter-&gt;host
op_assign
id|host
suffix:semicolon
id|adapter-&gt;host-&gt;irq
op_assign
id|irq
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|BOARD_MEMMAP
)paren
(brace
id|adapter-&gt;host-&gt;base
op_assign
id|tbase
suffix:semicolon
)brace
r_else
(brace
id|adapter-&gt;host-&gt;io_port
op_assign
id|tbase
suffix:semicolon
id|adapter-&gt;host-&gt;n_io_port
op_assign
l_int|16
suffix:semicolon
)brace
id|adapter-&gt;host-&gt;unique_id
op_assign
(paren
id|pci_bus
op_lshift
l_int|8
)paren
op_or
id|pci_dev_func
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Allocate buffer to issue internal commands.&n;&t;&t; */
id|adapter-&gt;mega_buffer
op_assign
id|pci_alloc_consistent
c_func
(paren
id|adapter-&gt;dev
comma
id|MEGA_BUFFER_SIZE
comma
op_amp
id|adapter-&gt;buf_dma_handle
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|adapter-&gt;mega_buffer
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;megaraid: out of RAM.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|fail_attach
suffix:semicolon
)brace
id|alloc_int_buf_f
op_assign
l_int|1
suffix:semicolon
id|adapter-&gt;scb_list
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|scb_t
)paren
op_star
id|MAX_COMMANDS
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|adapter-&gt;scb_list
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;megaraid: out of RAM.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|fail_attach
suffix:semicolon
)brace
id|alloc_scb_f
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Request our IRQ */
r_if
c_cond
(paren
id|adapter-&gt;flag
op_amp
id|BOARD_MEMMAP
)paren
(brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|irq
comma
id|megaraid_isr_memmapped
comma
id|SA_SHIRQ
comma
l_string|&quot;megaraid&quot;
comma
id|adapter
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;megaraid: Couldn&squot;t register IRQ %d!&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_goto
id|fail_attach
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|irq
comma
id|megaraid_isr_iomapped
comma
id|SA_SHIRQ
comma
l_string|&quot;megaraid&quot;
comma
id|adapter
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;megaraid: Couldn&squot;t register IRQ %d!&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_goto
id|fail_attach
suffix:semicolon
)brace
)brace
id|got_irq_f
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|mega_setup_mailbox
c_func
(paren
id|adapter
)paren
op_ne
l_int|0
)paren
(brace
r_goto
id|fail_attach
suffix:semicolon
)brace
id|did_setup_mbox_f
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|mega_query_adapter
c_func
(paren
id|adapter
)paren
op_ne
l_int|0
)paren
(brace
r_goto
id|fail_attach
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Have checks for some buggy f/w&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|subsysid
op_eq
l_int|0x1111
)paren
op_logical_and
(paren
id|subsysvid
op_eq
l_int|0x1111
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Which firmware&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|adapter-&gt;fw_version
comma
l_string|&quot;3.00&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|adapter-&gt;fw_version
comma
l_string|&quot;3.01&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;megaraid: Your  card is a Dell PERC &quot;
l_string|&quot;2/SC RAID controller with  &quot;
l_string|&quot;firmware&bslash;nmegaraid: 3.00 or 3.01.  &quot;
l_string|&quot;This driver is known to have &quot;
l_string|&quot;corruption issues&bslash;nmegaraid: with &quot;
l_string|&quot;those firmware versions on this &quot;
l_string|&quot;specific card.  In order&bslash;nmegaraid: &quot;
l_string|&quot;to protect your data, please upgrade &quot;
l_string|&quot;your firmware to version&bslash;nmegaraid: &quot;
l_string|&quot;3.10 or later, available from the &quot;
l_string|&quot;Dell Technical Support web&bslash;n&quot;
l_string|&quot;megaraid: site at&bslash;nhttp://support.&quot;
l_string|&quot;dell.com/us/en/filelib/download/&quot;
l_string|&quot;index.asp?fileid=2940&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * If we have a HP 1M(0x60E7)/2M(0x60E8) controller with&n;&t;&t; * firmware H.01.07, H.01.08, and H.01.09 disable 64 bit&n;&t;&t; * support, since this firmware cannot handle 64 bit&n;&t;&t; * addressing&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|subsysvid
op_eq
id|HP_SUBSYS_VID
)paren
op_logical_and
(paren
(paren
id|subsysid
op_eq
l_int|0x60E7
)paren
op_logical_or
(paren
id|subsysid
op_eq
l_int|0x60E8
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * which firmware&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|adapter-&gt;fw_version
comma
l_string|&quot;H01.07&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|adapter-&gt;fw_version
comma
l_string|&quot;H01.08&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|adapter-&gt;fw_version
comma
l_string|&quot;H01.09&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;megaraid: Firmware H.01.07, &quot;
l_string|&quot;H.01.08, and H.01.09 on 1M/2M &quot;
l_string|&quot;controllers&bslash;n&quot;
l_string|&quot;megaraid: do not support 64 bit &quot;
l_string|&quot;addressing.&bslash;nmegaraid: DISABLING &quot;
l_string|&quot;64 bit support.&bslash;n&quot;
)paren
suffix:semicolon
id|adapter-&gt;flag
op_and_assign
op_complement
id|BOARD_64BIT
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|mega_is_bios_enabled
c_func
(paren
id|adapter
)paren
)paren
(brace
id|mega_hbas
(braket
id|hba_count
)braket
dot
id|is_bios_enabled
op_assign
l_int|1
suffix:semicolon
)brace
id|mega_hbas
(braket
id|hba_count
)braket
dot
id|hostdata_addr
op_assign
id|adapter
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Find out which channel is raid and which is scsi. This is&n;&t;&t; * for ROMB support.&n;&t;&t; */
id|mega_enum_raid_scsi
c_func
(paren
id|adapter
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Find out if a logical drive is set as the boot drive. If&n;&t;&t; * there is one, will make that as the first logical drive.&n;&t;&t; * ROMB: Do we have to boot from a physical drive. Then all&n;&t;&t; * the physical drives would appear before the logical disks.&n;&t;&t; * Else, all the physical drives would be exported to the mid&n;&t;&t; * layer after logical drives.&n;&t;&t; */
id|mega_get_boot_drv
c_func
(paren
id|adapter
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|adapter-&gt;boot_pdrv_enabled
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NVIRT_CHAN
suffix:semicolon
id|i
op_increment
)paren
(brace
id|adapter-&gt;logdrv_chan
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
id|NVIRT_CHAN
suffix:semicolon
id|i
OL
id|MAX_CHANNELS
op_plus
id|NVIRT_CHAN
suffix:semicolon
id|i
op_increment
)paren
(brace
id|adapter-&gt;logdrv_chan
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|adapter-&gt;mega_ch_class
op_lshift_assign
id|NVIRT_CHAN
suffix:semicolon
)brace
r_else
(brace
id|j
op_assign
id|adapter-&gt;product_info.nchannels
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|j
suffix:semicolon
id|i
op_increment
)paren
(brace
id|adapter-&gt;logdrv_chan
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
id|j
suffix:semicolon
id|i
OL
id|NVIRT_CHAN
op_plus
id|j
suffix:semicolon
id|i
op_increment
)paren
(brace
id|adapter-&gt;logdrv_chan
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Do we support random deletion and addition of logical&n;&t;&t; * drives&n;&t;&t; */
id|adapter-&gt;read_ldidmap
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set it after first logdrv&n;&t;&t;&t;&t;&t;&t;   delete cmd */
id|adapter-&gt;support_random_del
op_assign
id|mega_support_random_del
c_func
(paren
id|adapter
)paren
suffix:semicolon
multiline_comment|/* Initialize SCBs */
r_if
c_cond
(paren
id|mega_init_scb
c_func
(paren
id|adapter
)paren
)paren
(brace
r_goto
id|fail_attach
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Reset the pending commands counter&n;&t;&t; */
id|atomic_set
c_func
(paren
op_amp
id|adapter-&gt;pend_cmds
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Reset the adapter quiescent flag&n;&t;&t; */
id|atomic_set
c_func
(paren
op_amp
id|adapter-&gt;quiescent
comma
l_int|0
)paren
suffix:semicolon
id|hba_soft_state
(braket
id|hba_count
)braket
op_assign
id|adapter
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Fill in the structure which needs to be passed back to the&n;&t;&t; * application when it does an ioctl() for controller related&n;&t;&t; * information.&n;&t;&t; */
id|i
op_assign
id|hba_count
suffix:semicolon
id|mcontroller
(braket
id|i
)braket
dot
id|base
op_assign
id|mega_baseport
suffix:semicolon
id|mcontroller
(braket
id|i
)braket
dot
id|irq
op_assign
id|irq
suffix:semicolon
id|mcontroller
(braket
id|i
)braket
dot
id|numldrv
op_assign
id|adapter-&gt;numldrv
suffix:semicolon
id|mcontroller
(braket
id|i
)braket
dot
id|pcibus
op_assign
id|pci_bus
suffix:semicolon
id|mcontroller
(braket
id|i
)braket
dot
id|pcidev
op_assign
id|pci_device
suffix:semicolon
id|mcontroller
(braket
id|i
)braket
dot
id|pcifun
op_assign
id|PCI_FUNC
(paren
id|pci_dev_func
)paren
suffix:semicolon
id|mcontroller
(braket
id|i
)braket
dot
id|pciid
op_assign
op_minus
l_int|1
suffix:semicolon
id|mcontroller
(braket
id|i
)braket
dot
id|pcivendor
op_assign
id|pci_vendor
suffix:semicolon
id|mcontroller
(braket
id|i
)braket
dot
id|pcislot
op_assign
id|PCI_SLOT
(paren
id|pci_dev_func
)paren
suffix:semicolon
id|mcontroller
(braket
id|i
)braket
dot
id|uid
op_assign
(paren
id|pci_bus
op_lshift
l_int|8
)paren
op_or
id|pci_dev_func
suffix:semicolon
multiline_comment|/* Set the Mode of addressing to 64 bit if we can */
r_if
c_cond
(paren
(paren
id|adapter-&gt;flag
op_amp
id|BOARD_64BIT
)paren
op_logical_and
(paren
r_sizeof
(paren
id|dma_addr_t
)paren
op_eq
l_int|8
)paren
)paren
(brace
id|pci_set_dma_mask
c_func
(paren
id|pdev
comma
l_int|0xffffffffffffffff
)paren
suffix:semicolon
id|adapter-&gt;has_64bit_addr
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|pci_set_dma_mask
c_func
(paren
id|pdev
comma
l_int|0xffffffff
)paren
suffix:semicolon
id|adapter-&gt;has_64bit_addr
op_assign
l_int|0
suffix:semicolon
)brace
id|init_MUTEX
c_func
(paren
op_amp
id|adapter-&gt;int_mtx
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|adapter-&gt;int_waitq
)paren
suffix:semicolon
id|adapter-&gt;this_id
op_assign
id|DEFAULT_INITIATOR_ID
suffix:semicolon
id|adapter-&gt;host-&gt;this_id
op_assign
id|DEFAULT_INITIATOR_ID
suffix:semicolon
macro_line|#if MEGA_HAVE_CLUSTERING
multiline_comment|/*&n;&t;&t; * Is cluster support enabled on this controller&n;&t;&t; * Note: In a cluster the HBAs ( the initiators ) will have&n;&t;&t; * different target IDs and we cannot assume it to be 7. Call&n;&t;&t; * to mega_support_cluster() will get the target ids also if&n;&t;&t; * the cluster support is available&n;&t;&t; */
id|adapter-&gt;has_cluster
op_assign
id|mega_support_cluster
c_func
(paren
id|adapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|adapter-&gt;has_cluster
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;megaraid: Cluster driver, initiator id:%d&bslash;n&quot;
comma
id|adapter-&gt;this_id
)paren
suffix:semicolon
)brace
macro_line|#endif
id|hba_count
op_increment
suffix:semicolon
r_continue
suffix:semicolon
id|fail_attach
suffix:colon
r_if
c_cond
(paren
id|did_setup_mbox_f
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|adapter-&gt;dev
comma
r_sizeof
(paren
id|mbox64_t
)paren
comma
(paren
r_void
op_star
)paren
id|adapter-&gt;una_mbox64
comma
id|adapter-&gt;una_mbox64_dma
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|got_irq_f
)paren
(brace
id|irq_disable
c_func
(paren
id|adapter
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|adapter-&gt;host-&gt;irq
comma
id|adapter
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|alloc_scb_f
)paren
(brace
id|kfree
c_func
(paren
id|adapter-&gt;scb_list
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|alloc_int_buf_f
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|adapter-&gt;dev
comma
id|MEGA_BUFFER_SIZE
comma
(paren
r_void
op_star
)paren
id|adapter-&gt;mega_buffer
comma
id|adapter-&gt;buf_dma_handle
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|did_scsi_reg_f
)paren
(brace
id|scsi_unregister
c_func
(paren
id|host
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|did_ioremap_f
)paren
(brace
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|mega_baseport
)paren
suffix:semicolon
id|release_mem_region
c_func
(paren
id|tbase
comma
l_int|128
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|did_req_region_f
)paren
(brace
id|release_region
c_func
(paren
id|mega_baseport
comma
l_int|16
)paren
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * mega_setup_mailbox()&n; * @adapter - pointer to our soft state&n; *&n; * Allocates a 8 byte aligned memory for the handshake mailbox.&n; */
r_static
r_int
DECL|function|mega_setup_mailbox
id|mega_setup_mailbox
c_func
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
r_int
r_int
id|align
suffix:semicolon
id|adapter-&gt;una_mbox64
op_assign
id|pci_alloc_consistent
c_func
(paren
id|adapter-&gt;dev
comma
r_sizeof
(paren
id|mbox64_t
)paren
comma
op_amp
id|adapter-&gt;una_mbox64_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|adapter-&gt;una_mbox64
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|adapter-&gt;mbox
op_assign
op_amp
id|adapter-&gt;una_mbox64-&gt;mbox
suffix:semicolon
id|adapter-&gt;mbox
op_assign
(paren
id|mbox_t
op_star
)paren
(paren
(paren
(paren
(paren
r_int
r_int
)paren
id|adapter-&gt;mbox
)paren
op_plus
l_int|15
)paren
op_amp
(paren
op_complement
l_int|0UL
op_xor
l_int|0xFUL
)paren
)paren
suffix:semicolon
id|adapter-&gt;mbox64
op_assign
(paren
id|mbox64_t
op_star
)paren
(paren
(paren
(paren
r_int
r_int
)paren
id|adapter-&gt;mbox
)paren
op_minus
l_int|8
)paren
suffix:semicolon
id|align
op_assign
(paren
(paren
r_void
op_star
)paren
id|adapter-&gt;mbox
)paren
op_minus
(paren
(paren
r_void
op_star
)paren
op_amp
id|adapter-&gt;una_mbox64-&gt;mbox
)paren
suffix:semicolon
id|adapter-&gt;mbox_dma
op_assign
id|adapter-&gt;una_mbox64_dma
op_plus
l_int|8
op_plus
id|align
suffix:semicolon
multiline_comment|/*&n;&t; * Register the mailbox if the controller is an io-mapped controller&n;&t; */
r_if
c_cond
(paren
id|adapter-&gt;flag
op_amp
id|BOARD_IOMAP
)paren
(brace
id|outb_p
c_func
(paren
id|adapter-&gt;mbox_dma
op_amp
l_int|0xFF
comma
id|adapter-&gt;host-&gt;io_port
op_plus
id|MBOX_PORT0
)paren
suffix:semicolon
id|outb_p
c_func
(paren
(paren
id|adapter-&gt;mbox_dma
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
comma
id|adapter-&gt;host-&gt;io_port
op_plus
id|MBOX_PORT1
)paren
suffix:semicolon
id|outb_p
c_func
(paren
(paren
id|adapter-&gt;mbox_dma
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
comma
id|adapter-&gt;host-&gt;io_port
op_plus
id|MBOX_PORT2
)paren
suffix:semicolon
id|outb_p
c_func
(paren
(paren
id|adapter-&gt;mbox_dma
op_rshift
l_int|24
)paren
op_amp
l_int|0xFF
comma
id|adapter-&gt;host-&gt;io_port
op_plus
id|MBOX_PORT3
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|ENABLE_MBOX_BYTE
comma
id|adapter-&gt;host-&gt;io_port
op_plus
id|ENABLE_MBOX_REGION
)paren
suffix:semicolon
id|irq_ack
c_func
(paren
id|adapter
)paren
suffix:semicolon
id|irq_enable
c_func
(paren
id|adapter
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * mega_query_adapter()&n; * @adapter - pointer to our soft state&n; *&n; * Issue the adapter inquiry commands to the controller and find out&n; * information and parameter about the devices attached&n; */
r_static
r_int
DECL|function|mega_query_adapter
id|mega_query_adapter
c_func
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
id|dma_addr_t
id|prod_info_dma_handle
suffix:semicolon
id|mega_inquiry3
op_star
id|inquiry3
suffix:semicolon
id|u8
id|raw_mbox
(braket
l_int|16
)braket
suffix:semicolon
id|mbox_t
op_star
id|mbox
suffix:semicolon
r_int
id|retval
suffix:semicolon
multiline_comment|/* Initialize adapter inquiry mailbox */
id|mbox
op_assign
(paren
id|mbox_t
op_star
)paren
id|raw_mbox
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|adapter-&gt;mega_buffer
comma
l_int|0
comma
id|MEGA_BUFFER_SIZE
)paren
suffix:semicolon
id|memset
c_func
(paren
id|mbox
comma
l_int|0
comma
l_int|16
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Try to issue Inquiry3 command&n;&t; * if not succeeded, then issue MEGA_MBOXCMD_ADAPTERINQ command and&n;&t; * update enquiry3 structure&n;&t; */
id|mbox-&gt;xferaddr
op_assign
(paren
id|u32
)paren
id|adapter-&gt;buf_dma_handle
suffix:semicolon
id|inquiry3
op_assign
(paren
id|mega_inquiry3
op_star
)paren
id|adapter-&gt;mega_buffer
suffix:semicolon
id|raw_mbox
(braket
l_int|0
)braket
op_assign
id|FC_NEW_CONFIG
suffix:semicolon
multiline_comment|/* i.e. mbox-&gt;cmd=0xA1 */
id|raw_mbox
(braket
l_int|2
)braket
op_assign
id|NC_SUBOP_ENQUIRY3
suffix:semicolon
multiline_comment|/* i.e. 0x0F */
id|raw_mbox
(braket
l_int|3
)braket
op_assign
id|ENQ3_GET_SOLICITED_FULL
suffix:semicolon
multiline_comment|/* i.e. 0x02 */
multiline_comment|/* Issue a blocking command to the card */
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|issue_scb_block
c_func
(paren
id|adapter
comma
id|raw_mbox
)paren
)paren
)paren
(brace
multiline_comment|/* the adapter does not support 40ld */
id|mraid_ext_inquiry
op_star
id|ext_inq
suffix:semicolon
id|mraid_inquiry
op_star
id|inq
suffix:semicolon
id|dma_addr_t
id|dma_handle
suffix:semicolon
id|ext_inq
op_assign
id|pci_alloc_consistent
c_func
(paren
id|adapter-&gt;dev
comma
r_sizeof
(paren
id|mraid_ext_inquiry
)paren
comma
op_amp
id|dma_handle
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ext_inq
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|inq
op_assign
op_amp
id|ext_inq-&gt;raid_inq
suffix:semicolon
id|mbox-&gt;xferaddr
op_assign
(paren
id|u32
)paren
id|dma_handle
suffix:semicolon
multiline_comment|/*issue old 0x04 command to adapter */
id|mbox-&gt;cmd
op_assign
id|MEGA_MBOXCMD_ADPEXTINQ
suffix:semicolon
id|issue_scb_block
c_func
(paren
id|adapter
comma
id|raw_mbox
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * update Enquiry3 and ProductInfo structures with&n;&t;&t; * mraid_inquiry structure&n;&t;&t; */
id|mega_8_to_40ld
c_func
(paren
id|inq
comma
id|inquiry3
comma
(paren
id|mega_product_info
op_star
)paren
op_amp
id|adapter-&gt;product_info
)paren
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|adapter-&gt;dev
comma
r_sizeof
(paren
id|mraid_ext_inquiry
)paren
comma
id|ext_inq
comma
id|dma_handle
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*adapter supports 40ld */
id|adapter-&gt;flag
op_or_assign
id|BOARD_40LD
suffix:semicolon
multiline_comment|/*&n;&t;&t; * get product_info, which is static information and will be&n;&t;&t; * unchanged&n;&t;&t; */
id|prod_info_dma_handle
op_assign
id|pci_map_single
c_func
(paren
id|adapter-&gt;dev
comma
(paren
r_void
op_star
)paren
op_amp
id|adapter-&gt;product_info
comma
r_sizeof
(paren
id|mega_product_info
)paren
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
id|mbox-&gt;xferaddr
op_assign
id|prod_info_dma_handle
suffix:semicolon
id|raw_mbox
(braket
l_int|0
)braket
op_assign
id|FC_NEW_CONFIG
suffix:semicolon
multiline_comment|/* i.e. mbox-&gt;cmd=0xA1 */
id|raw_mbox
(braket
l_int|2
)braket
op_assign
id|NC_SUBOP_PRODUCT_INFO
suffix:semicolon
multiline_comment|/* i.e. 0x0E */
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|issue_scb_block
c_func
(paren
id|adapter
comma
id|raw_mbox
)paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;megaraid: Product_info cmd failed with error: %d&bslash;n&quot;
comma
id|retval
)paren
suffix:semicolon
id|pci_dma_sync_single
c_func
(paren
id|adapter-&gt;dev
comma
id|prod_info_dma_handle
comma
r_sizeof
(paren
id|mega_product_info
)paren
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
id|pci_unmap_single
c_func
(paren
id|adapter-&gt;dev
comma
id|prod_info_dma_handle
comma
r_sizeof
(paren
id|mega_product_info
)paren
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * kernel scans the channels from 0 to &lt;= max_channel&n;&t; */
id|adapter-&gt;host-&gt;max_channel
op_assign
id|adapter-&gt;product_info.nchannels
op_plus
id|NVIRT_CHAN
op_minus
l_int|1
suffix:semicolon
id|adapter-&gt;host-&gt;max_id
op_assign
l_int|16
suffix:semicolon
multiline_comment|/* max targets per channel */
id|adapter-&gt;host-&gt;max_lun
op_assign
l_int|7
suffix:semicolon
multiline_comment|/* Upto 7 luns for non disk devices */
id|adapter-&gt;host-&gt;cmd_per_lun
op_assign
id|max_cmd_per_lun
suffix:semicolon
id|adapter-&gt;numldrv
op_assign
id|inquiry3-&gt;num_ldrv
suffix:semicolon
id|adapter-&gt;max_cmds
op_assign
id|adapter-&gt;product_info.max_commands
suffix:semicolon
r_if
c_cond
(paren
id|adapter-&gt;max_cmds
OG
id|MAX_COMMANDS
)paren
(brace
id|adapter-&gt;max_cmds
op_assign
id|MAX_COMMANDS
suffix:semicolon
)brace
id|adapter-&gt;host-&gt;can_queue
op_assign
id|adapter-&gt;max_cmds
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Get the maximum number of scatter-gather elements supported by this&n;&t; * firmware&n;&t; */
id|mega_get_max_sgl
c_func
(paren
id|adapter
)paren
suffix:semicolon
id|adapter-&gt;host-&gt;sg_tablesize
op_assign
id|adapter-&gt;sglen
suffix:semicolon
multiline_comment|/* use HP firmware and bios version encoding */
r_if
c_cond
(paren
id|adapter-&gt;product_info.subsysvid
op_eq
id|HP_SUBSYS_VID
)paren
(brace
id|sprintf
(paren
id|adapter-&gt;fw_version
comma
l_string|&quot;%c%d%d.%d%d&quot;
comma
id|adapter-&gt;product_info.fw_version
(braket
l_int|2
)braket
comma
id|adapter-&gt;product_info.fw_version
(braket
l_int|1
)braket
op_rshift
l_int|8
comma
id|adapter-&gt;product_info.fw_version
(braket
l_int|1
)braket
op_amp
l_int|0x0f
comma
id|adapter-&gt;product_info.fw_version
(braket
l_int|0
)braket
op_rshift
l_int|8
comma
id|adapter-&gt;product_info.fw_version
(braket
l_int|0
)braket
op_amp
l_int|0x0f
)paren
suffix:semicolon
id|sprintf
(paren
id|adapter-&gt;bios_version
comma
l_string|&quot;%c%d%d.%d%d&quot;
comma
id|adapter-&gt;product_info.bios_version
(braket
l_int|2
)braket
comma
id|adapter-&gt;product_info.bios_version
(braket
l_int|1
)braket
op_rshift
l_int|8
comma
id|adapter-&gt;product_info.bios_version
(braket
l_int|1
)braket
op_amp
l_int|0x0f
comma
id|adapter-&gt;product_info.bios_version
(braket
l_int|0
)braket
op_rshift
l_int|8
comma
id|adapter-&gt;product_info.bios_version
(braket
l_int|0
)braket
op_amp
l_int|0x0f
)paren
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|adapter-&gt;fw_version
comma
(paren
r_char
op_star
)paren
id|adapter-&gt;product_info.fw_version
comma
l_int|4
)paren
suffix:semicolon
id|adapter-&gt;fw_version
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
id|memcpy
c_func
(paren
id|adapter-&gt;bios_version
comma
(paren
r_char
op_star
)paren
id|adapter-&gt;product_info.bios_version
comma
l_int|4
)paren
suffix:semicolon
id|adapter-&gt;bios_version
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;megaraid: [%s:%s] detected %d logical drives.&bslash;n&quot;
comma
id|adapter-&gt;fw_version
comma
id|adapter-&gt;bios_version
comma
id|adapter-&gt;numldrv
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do we support extended (&gt;10 bytes) cdbs&n;&t; */
id|adapter-&gt;support_ext_cdb
op_assign
id|mega_support_ext_cdb
c_func
(paren
id|adapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|adapter-&gt;support_ext_cdb
)paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;megaraid: supports extended CDBs.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * megaraid_queue()&n; * @scmd - Issue this scsi command&n; * @done - the callback hook into the scsi mid-layer&n; *&n; * The command queuing entry point for the mid-layer.&n; */
r_static
r_int
DECL|function|megaraid_queue
id|megaraid_queue
c_func
(paren
id|Scsi_Cmnd
op_star
id|scmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
id|adapter_t
op_star
id|adapter
suffix:semicolon
id|scb_t
op_star
id|scb
suffix:semicolon
r_int
id|busy
op_assign
l_int|0
suffix:semicolon
id|adapter
op_assign
(paren
id|adapter_t
op_star
)paren
id|scmd-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
id|scmd-&gt;scsi_done
op_assign
id|done
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate and build a SCB request&n;&t; * busy flag will be set if mega_build_cmd() command could not&n;&t; * allocate scb. We will return non-zero status in that case.&n;&t; * NOTE: scb can be null even though certain commands completed&n;&t; * successfully, e.g., MODE_SENSE and TEST_UNIT_READY, we would&n;&t; * return 0 in that case.&n;&t; */
id|scb
op_assign
id|mega_build_cmd
c_func
(paren
id|adapter
comma
id|scmd
comma
op_amp
id|busy
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
)paren
(brace
id|scb-&gt;state
op_or_assign
id|SCB_PENDQ
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|scb-&gt;list
comma
op_amp
id|adapter-&gt;pending_list
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check if the HBA is in quiescent state, e.g., during a&n;&t;&t; * delete logical drive opertion. If it is, don&squot;t run&n;&t;&t; * the pending_list.&n;&t;&t; */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|adapter-&gt;quiescent
)paren
op_eq
l_int|0
)paren
(brace
id|mega_runpendq
c_func
(paren
id|adapter
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|busy
suffix:semicolon
)brace
multiline_comment|/**&n; * mega_build_cmd()&n; * @adapter - pointer to our soft state&n; * @cmd - Prepare using this scsi command&n; * @busy - busy flag if no resources&n; *&n; * Prepares a command and scatter gather list for the controller. This routine&n; * also finds out if the commands is intended for a logical drive or a&n; * physical device and prepares the controller command accordingly.&n; *&n; * We also re-order the logical drives and physical devices based on their&n; * boot settings.&n; */
r_static
id|scb_t
op_star
DECL|function|mega_build_cmd
id|mega_build_cmd
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
op_star
id|busy
)paren
(brace
id|mega_ext_passthru
op_star
id|epthru
suffix:semicolon
id|mega_passthru
op_star
id|pthru
suffix:semicolon
id|scb_t
op_star
id|scb
suffix:semicolon
id|mbox_t
op_star
id|mbox
suffix:semicolon
r_int
id|seg
suffix:semicolon
r_char
id|islogical
suffix:semicolon
r_int
id|max_ldrv_num
suffix:semicolon
r_int
id|channel
op_assign
l_int|0
suffix:semicolon
r_int
id|target
op_assign
l_int|0
suffix:semicolon
r_int
id|ldrv_num
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* logical drive number */
multiline_comment|/*&n;&t; * filter the internal and ioctl commands&n;&t; */
r_if
c_cond
(paren
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|MEGA_INTERNAL_CMD
)paren
)paren
(brace
r_return
id|cmd-&gt;buffer
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We know what channels our logical drives are on - mega_find_card()&n;&t; */
id|islogical
op_assign
id|adapter-&gt;logdrv_chan
(braket
id|cmd-&gt;device-&gt;channel
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * The theory: If physical drive is chosen for boot, all the physical&n;&t; * devices are exported before the logical drives, otherwise physical&n;&t; * devices are pushed after logical drives, in which case - Kernel sees&n;&t; * the physical devices on virtual channel which is obviously converted&n;&t; * to actual channel on the HBA.&n;&t; */
r_if
c_cond
(paren
id|adapter-&gt;boot_pdrv_enabled
)paren
(brace
r_if
c_cond
(paren
id|islogical
)paren
(brace
multiline_comment|/* logical channel */
id|channel
op_assign
id|cmd-&gt;device-&gt;channel
op_minus
id|adapter-&gt;product_info.nchannels
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* this is physical channel */
id|channel
op_assign
id|cmd-&gt;device-&gt;channel
suffix:semicolon
id|target
op_assign
id|cmd-&gt;device-&gt;id
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * boot from a physical disk, that disk needs to be&n;&t;&t;&t; * exposed first IF both the channels are SCSI, then&n;&t;&t;&t; * booting from the second channel is not allowed.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|target
op_eq
l_int|0
)paren
(brace
id|target
op_assign
id|adapter-&gt;boot_pdrv_tgt
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|target
op_eq
id|adapter-&gt;boot_pdrv_tgt
)paren
(brace
id|target
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|islogical
)paren
(brace
multiline_comment|/* this is the logical channel */
id|channel
op_assign
id|cmd-&gt;device-&gt;channel
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* physical channel */
id|channel
op_assign
id|cmd-&gt;device-&gt;channel
op_minus
id|NVIRT_CHAN
suffix:semicolon
id|target
op_assign
id|cmd-&gt;device-&gt;id
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|islogical
)paren
(brace
multiline_comment|/* have just LUN 0 for each target on virtual channels */
r_if
c_cond
(paren
id|cmd-&gt;device-&gt;lun
)paren
(brace
id|cmd-&gt;result
op_assign
(paren
id|DID_BAD_TARGET
op_lshift
l_int|16
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|ldrv_num
op_assign
id|mega_get_ldrv_num
c_func
(paren
id|adapter
comma
id|cmd
comma
id|channel
)paren
suffix:semicolon
id|max_ldrv_num
op_assign
(paren
id|adapter-&gt;flag
op_amp
id|BOARD_40LD
)paren
ques
c_cond
id|MAX_LOGICAL_DRIVES_40LD
suffix:colon
id|MAX_LOGICAL_DRIVES_8LD
suffix:semicolon
multiline_comment|/*&n;&t;&t; * max_ldrv_num increases by 0x80 if some logical drive was&n;&t;&t; * deleted.&n;&t;&t; */
r_if
c_cond
(paren
id|adapter-&gt;read_ldidmap
)paren
(brace
id|max_ldrv_num
op_add_assign
l_int|0x80
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ldrv_num
OG
id|max_ldrv_num
)paren
(brace
id|cmd-&gt;result
op_assign
(paren
id|DID_BAD_TARGET
op_lshift
l_int|16
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|cmd-&gt;device-&gt;lun
OG
l_int|7
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Do not support lun &gt;7 for physically accessed&n;&t;&t;&t; * devices&n;&t;&t;&t; */
id|cmd-&gt;result
op_assign
(paren
id|DID_BAD_TARGET
op_lshift
l_int|16
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&n;&t; * Logical drive commands&n;&t; *&n;&t; */
r_if
c_cond
(paren
id|islogical
)paren
(brace
r_switch
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
id|TEST_UNIT_READY
suffix:colon
id|memset
c_func
(paren
id|cmd-&gt;request_buffer
comma
l_int|0
comma
id|cmd-&gt;request_bufflen
)paren
suffix:semicolon
macro_line|#if MEGA_HAVE_CLUSTERING
multiline_comment|/*&n;&t;&t;&t; * Do we support clustering and is the support enabled&n;&t;&t;&t; * If no, return success always&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|adapter-&gt;has_cluster
)paren
(brace
id|cmd-&gt;result
op_assign
(paren
id|DID_OK
op_lshift
l_int|16
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|scb
op_assign
id|mega_allocate_scb
c_func
(paren
id|adapter
comma
id|cmd
)paren
)paren
)paren
(brace
id|cmd-&gt;result
op_assign
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
op_star
id|busy
op_assign
l_int|1
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|scb-&gt;raw_mbox
(braket
l_int|0
)braket
op_assign
id|MEGA_CLUSTER_CMD
suffix:semicolon
id|scb-&gt;raw_mbox
(braket
l_int|2
)braket
op_assign
id|MEGA_RESERVATION_STATUS
suffix:semicolon
id|scb-&gt;raw_mbox
(braket
l_int|3
)braket
op_assign
id|ldrv_num
suffix:semicolon
id|scb-&gt;dma_direction
op_assign
id|PCI_DMA_NONE
suffix:semicolon
r_return
id|scb
suffix:semicolon
macro_line|#else
id|cmd-&gt;result
op_assign
(paren
id|DID_OK
op_lshift
l_int|16
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
macro_line|#endif
r_case
id|MODE_SENSE
suffix:colon
id|memset
c_func
(paren
id|cmd-&gt;request_buffer
comma
l_int|0
comma
id|cmd-&gt;cmnd
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
(paren
id|DID_OK
op_lshift
l_int|16
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
r_case
id|READ_CAPACITY
suffix:colon
r_case
id|INQUIRY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|adapter-&gt;flag
op_amp
(paren
l_int|1L
op_lshift
id|cmd-&gt;device-&gt;channel
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;scsi%d: scanning scsi channel %d &quot;
comma
id|adapter-&gt;host-&gt;host_no
comma
id|cmd-&gt;device-&gt;channel
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;for logical drives.&bslash;n&quot;
)paren
suffix:semicolon
id|adapter-&gt;flag
op_or_assign
(paren
l_int|1L
op_lshift
id|cmd-&gt;device-&gt;channel
)paren
suffix:semicolon
)brace
multiline_comment|/* Allocate a SCB and initialize passthru */
r_if
c_cond
(paren
op_logical_neg
(paren
id|scb
op_assign
id|mega_allocate_scb
c_func
(paren
id|adapter
comma
id|cmd
)paren
)paren
)paren
(brace
id|cmd-&gt;result
op_assign
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
op_star
id|busy
op_assign
l_int|1
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|pthru
op_assign
id|scb-&gt;pthru
suffix:semicolon
id|mbox
op_assign
(paren
id|mbox_t
op_star
)paren
id|scb-&gt;raw_mbox
suffix:semicolon
id|memset
c_func
(paren
id|mbox
comma
l_int|0
comma
r_sizeof
(paren
id|scb-&gt;raw_mbox
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|pthru
comma
l_int|0
comma
r_sizeof
(paren
id|mega_passthru
)paren
)paren
suffix:semicolon
id|pthru-&gt;timeout
op_assign
l_int|0
suffix:semicolon
id|pthru-&gt;ars
op_assign
l_int|1
suffix:semicolon
id|pthru-&gt;reqsenselen
op_assign
l_int|14
suffix:semicolon
id|pthru-&gt;islogical
op_assign
l_int|1
suffix:semicolon
id|pthru-&gt;logdrv
op_assign
id|ldrv_num
suffix:semicolon
id|pthru-&gt;cdblen
op_assign
id|cmd-&gt;cmd_len
suffix:semicolon
id|memcpy
c_func
(paren
id|pthru-&gt;cdb
comma
id|cmd-&gt;cmnd
comma
id|cmd-&gt;cmd_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|adapter-&gt;has_64bit_addr
)paren
(brace
id|mbox-&gt;cmd
op_assign
id|MEGA_MBOXCMD_PASSTHRU64
suffix:semicolon
)brace
r_else
(brace
id|mbox-&gt;cmd
op_assign
id|MEGA_MBOXCMD_PASSTHRU
suffix:semicolon
)brace
id|scb-&gt;dma_direction
op_assign
id|PCI_DMA_FROMDEVICE
suffix:semicolon
id|pthru-&gt;numsgelements
op_assign
id|mega_build_sglist
c_func
(paren
id|adapter
comma
id|scb
comma
op_amp
id|pthru-&gt;dataxferaddr
comma
op_amp
id|pthru-&gt;dataxferlen
)paren
suffix:semicolon
id|mbox-&gt;xferaddr
op_assign
id|scb-&gt;pthru_dma_addr
suffix:semicolon
r_return
id|scb
suffix:semicolon
r_case
id|READ_6
suffix:colon
r_case
id|WRITE_6
suffix:colon
r_case
id|READ_10
suffix:colon
r_case
id|WRITE_10
suffix:colon
r_case
id|READ_12
suffix:colon
r_case
id|WRITE_12
suffix:colon
multiline_comment|/* Allocate a SCB and initialize mailbox */
r_if
c_cond
(paren
op_logical_neg
(paren
id|scb
op_assign
id|mega_allocate_scb
c_func
(paren
id|adapter
comma
id|cmd
)paren
)paren
)paren
(brace
id|cmd-&gt;result
op_assign
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
op_star
id|busy
op_assign
l_int|1
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|mbox
op_assign
(paren
id|mbox_t
op_star
)paren
id|scb-&gt;raw_mbox
suffix:semicolon
id|memset
c_func
(paren
id|mbox
comma
l_int|0
comma
r_sizeof
(paren
id|scb-&gt;raw_mbox
)paren
)paren
suffix:semicolon
id|mbox-&gt;logdrv
op_assign
id|ldrv_num
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * A little hack: 2nd bit is zero for all scsi read&n;&t;&t;&t; * commands and is set for all scsi write commands&n;&t;&t;&t; */
r_if
c_cond
(paren
id|adapter-&gt;has_64bit_addr
)paren
(brace
id|mbox-&gt;cmd
op_assign
(paren
op_star
id|cmd-&gt;cmnd
op_amp
l_int|0x02
)paren
ques
c_cond
id|MEGA_MBOXCMD_LWRITE64
suffix:colon
id|MEGA_MBOXCMD_LREAD64
suffix:semicolon
)brace
r_else
(brace
id|mbox-&gt;cmd
op_assign
(paren
op_star
id|cmd-&gt;cmnd
op_amp
l_int|0x02
)paren
ques
c_cond
id|MEGA_MBOXCMD_LWRITE
suffix:colon
id|MEGA_MBOXCMD_LREAD
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * 6-byte READ(0x08) or WRITE(0x0A) cdb&n;&t;&t;&t; */
r_if
c_cond
(paren
id|cmd-&gt;cmd_len
op_eq
l_int|6
)paren
(brace
id|mbox-&gt;numsectors
op_assign
(paren
id|u32
)paren
id|cmd-&gt;cmnd
(braket
l_int|4
)braket
suffix:semicolon
id|mbox-&gt;lba
op_assign
(paren
(paren
id|u32
)paren
id|cmd-&gt;cmnd
(braket
l_int|1
)braket
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|u32
)paren
id|cmd-&gt;cmnd
(braket
l_int|2
)braket
op_lshift
l_int|8
)paren
op_or
(paren
id|u32
)paren
id|cmd-&gt;cmnd
(braket
l_int|3
)braket
suffix:semicolon
id|mbox-&gt;lba
op_and_assign
l_int|0x1FFFFF
suffix:semicolon
macro_line|#if MEGA_HAVE_STATS
multiline_comment|/*&n;&t;&t;&t;&t; * Take modulo 0x80, since the logical drive&n;&t;&t;&t;&t; * number increases by 0x80 when a logical&n;&t;&t;&t;&t; * drive was deleted&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_star
id|cmd-&gt;cmnd
op_eq
id|READ_6
)paren
(brace
id|adapter-&gt;nreads
(braket
id|ldrv_num
op_mod
l_int|0x80
)braket
op_increment
suffix:semicolon
id|adapter-&gt;nreadblocks
(braket
id|ldrv_num
op_mod
l_int|0x80
)braket
op_add_assign
id|mbox-&gt;numsectors
suffix:semicolon
)brace
r_else
(brace
id|adapter-&gt;nwrites
(braket
id|ldrv_num
op_mod
l_int|0x80
)braket
op_increment
suffix:semicolon
id|adapter-&gt;nwriteblocks
(braket
id|ldrv_num
op_mod
l_int|0x80
)braket
op_add_assign
id|mbox-&gt;numsectors
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n;&t;&t;&t; * 10-byte READ(0x28) or WRITE(0x2A) cdb&n;&t;&t;&t; */
r_if
c_cond
(paren
id|cmd-&gt;cmd_len
op_eq
l_int|10
)paren
(brace
id|mbox-&gt;numsectors
op_assign
(paren
id|u32
)paren
id|cmd-&gt;cmnd
(braket
l_int|8
)braket
op_or
(paren
(paren
id|u32
)paren
id|cmd-&gt;cmnd
(braket
l_int|7
)braket
op_lshift
l_int|8
)paren
suffix:semicolon
id|mbox-&gt;lba
op_assign
(paren
(paren
id|u32
)paren
id|cmd-&gt;cmnd
(braket
l_int|2
)braket
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|u32
)paren
id|cmd-&gt;cmnd
(braket
l_int|3
)braket
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|u32
)paren
id|cmd-&gt;cmnd
(braket
l_int|4
)braket
op_lshift
l_int|8
)paren
op_or
(paren
id|u32
)paren
id|cmd-&gt;cmnd
(braket
l_int|5
)braket
suffix:semicolon
macro_line|#if MEGA_HAVE_STATS
r_if
c_cond
(paren
op_star
id|cmd-&gt;cmnd
op_eq
id|READ_10
)paren
(brace
id|adapter-&gt;nreads
(braket
id|ldrv_num
op_mod
l_int|0x80
)braket
op_increment
suffix:semicolon
id|adapter-&gt;nreadblocks
(braket
id|ldrv_num
op_mod
l_int|0x80
)braket
op_add_assign
id|mbox-&gt;numsectors
suffix:semicolon
)brace
r_else
(brace
id|adapter-&gt;nwrites
(braket
id|ldrv_num
op_mod
l_int|0x80
)braket
op_increment
suffix:semicolon
id|adapter-&gt;nwriteblocks
(braket
id|ldrv_num
op_mod
l_int|0x80
)braket
op_add_assign
id|mbox-&gt;numsectors
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n;&t;&t;&t; * 12-byte READ(0xA8) or WRITE(0xAA) cdb&n;&t;&t;&t; */
r_if
c_cond
(paren
id|cmd-&gt;cmd_len
op_eq
l_int|12
)paren
(brace
id|mbox-&gt;lba
op_assign
(paren
(paren
id|u32
)paren
id|cmd-&gt;cmnd
(braket
l_int|2
)braket
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|u32
)paren
id|cmd-&gt;cmnd
(braket
l_int|3
)braket
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|u32
)paren
id|cmd-&gt;cmnd
(braket
l_int|4
)braket
op_lshift
l_int|8
)paren
op_or
(paren
id|u32
)paren
id|cmd-&gt;cmnd
(braket
l_int|5
)braket
suffix:semicolon
id|mbox-&gt;numsectors
op_assign
(paren
(paren
id|u32
)paren
id|cmd-&gt;cmnd
(braket
l_int|6
)braket
op_lshift
l_int|24
)paren
op_or
(paren
(paren
id|u32
)paren
id|cmd-&gt;cmnd
(braket
l_int|7
)braket
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|u32
)paren
id|cmd-&gt;cmnd
(braket
l_int|8
)braket
op_lshift
l_int|8
)paren
op_or
(paren
id|u32
)paren
id|cmd-&gt;cmnd
(braket
l_int|9
)braket
suffix:semicolon
macro_line|#if MEGA_HAVE_STATS
r_if
c_cond
(paren
op_star
id|cmd-&gt;cmnd
op_eq
id|READ_12
)paren
(brace
id|adapter-&gt;nreads
(braket
id|ldrv_num
op_mod
l_int|0x80
)braket
op_increment
suffix:semicolon
id|adapter-&gt;nreadblocks
(braket
id|ldrv_num
op_mod
l_int|0x80
)braket
op_add_assign
id|mbox-&gt;numsectors
suffix:semicolon
)brace
r_else
(brace
id|adapter-&gt;nwrites
(braket
id|ldrv_num
op_mod
l_int|0x80
)braket
op_increment
suffix:semicolon
id|adapter-&gt;nwriteblocks
(braket
id|ldrv_num
op_mod
l_int|0x80
)braket
op_add_assign
id|mbox-&gt;numsectors
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n;&t;&t;&t; * If it is a read command&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
op_star
id|cmd-&gt;cmnd
op_amp
l_int|0x0F
)paren
op_eq
l_int|0x08
)paren
(brace
id|scb-&gt;dma_direction
op_assign
id|PCI_DMA_FROMDEVICE
suffix:semicolon
)brace
r_else
(brace
id|scb-&gt;dma_direction
op_assign
id|PCI_DMA_TODEVICE
suffix:semicolon
)brace
multiline_comment|/* Calculate Scatter-Gather info */
id|mbox-&gt;numsgelements
op_assign
id|mega_build_sglist
c_func
(paren
id|adapter
comma
id|scb
comma
(paren
id|u32
op_star
)paren
op_amp
id|mbox-&gt;xferaddr
comma
(paren
id|u32
op_star
)paren
op_amp
id|seg
)paren
suffix:semicolon
r_return
id|scb
suffix:semicolon
macro_line|#if MEGA_HAVE_CLUSTERING
r_case
id|RESERVE
suffix:colon
multiline_comment|/* Fall through */
r_case
id|RELEASE
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Do we support clustering and is the support enabled&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|adapter-&gt;has_cluster
)paren
(brace
id|cmd-&gt;result
op_assign
(paren
id|DID_BAD_TARGET
op_lshift
l_int|16
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Allocate a SCB and initialize mailbox */
r_if
c_cond
(paren
op_logical_neg
(paren
id|scb
op_assign
id|mega_allocate_scb
c_func
(paren
id|adapter
comma
id|cmd
)paren
)paren
)paren
(brace
id|cmd-&gt;result
op_assign
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
op_star
id|busy
op_assign
l_int|1
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|scb-&gt;raw_mbox
(braket
l_int|0
)braket
op_assign
id|MEGA_CLUSTER_CMD
suffix:semicolon
id|scb-&gt;raw_mbox
(braket
l_int|2
)braket
op_assign
(paren
op_star
id|cmd-&gt;cmnd
op_eq
id|RESERVE
)paren
ques
c_cond
id|MEGA_RESERVE_LD
suffix:colon
id|MEGA_RELEASE_LD
suffix:semicolon
id|scb-&gt;raw_mbox
(braket
l_int|3
)braket
op_assign
id|ldrv_num
suffix:semicolon
id|scb-&gt;dma_direction
op_assign
id|PCI_DMA_NONE
suffix:semicolon
r_return
id|scb
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
id|cmd-&gt;result
op_assign
(paren
id|DID_BAD_TARGET
op_lshift
l_int|16
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Passthru drive commands&n;&t; */
r_else
(brace
multiline_comment|/* Allocate a SCB and initialize passthru */
r_if
c_cond
(paren
op_logical_neg
(paren
id|scb
op_assign
id|mega_allocate_scb
c_func
(paren
id|adapter
comma
id|cmd
)paren
)paren
)paren
(brace
id|cmd-&gt;result
op_assign
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
op_star
id|busy
op_assign
l_int|1
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|mbox
op_assign
(paren
id|mbox_t
op_star
)paren
id|scb-&gt;raw_mbox
suffix:semicolon
id|memset
c_func
(paren
id|mbox
comma
l_int|0
comma
r_sizeof
(paren
id|scb-&gt;raw_mbox
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|adapter-&gt;support_ext_cdb
)paren
(brace
id|epthru
op_assign
id|mega_prepare_extpassthru
c_func
(paren
id|adapter
comma
id|scb
comma
id|cmd
comma
id|channel
comma
id|target
)paren
suffix:semicolon
id|mbox-&gt;cmd
op_assign
id|MEGA_MBOXCMD_EXTPTHRU
suffix:semicolon
id|mbox-&gt;xferaddr
op_assign
id|scb-&gt;epthru_dma_addr
suffix:semicolon
)brace
r_else
(brace
id|pthru
op_assign
id|mega_prepare_passthru
c_func
(paren
id|adapter
comma
id|scb
comma
id|cmd
comma
id|channel
comma
id|target
)paren
suffix:semicolon
multiline_comment|/* Initialize mailbox */
r_if
c_cond
(paren
id|adapter-&gt;has_64bit_addr
)paren
(brace
id|mbox-&gt;cmd
op_assign
id|MEGA_MBOXCMD_PASSTHRU64
suffix:semicolon
)brace
r_else
(brace
id|mbox-&gt;cmd
op_assign
id|MEGA_MBOXCMD_PASSTHRU
suffix:semicolon
)brace
id|mbox-&gt;xferaddr
op_assign
id|scb-&gt;pthru_dma_addr
suffix:semicolon
)brace
r_return
id|scb
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * mega_prepare_passthru()&n; * @adapter - pointer to our soft state&n; * @scb - our scsi control block&n; * @cmd - scsi command from the mid-layer&n; * @channel - actual channel on the controller&n; * @target - actual id on the controller.&n; *&n; * prepare a command for the scsi physical devices.&n; */
r_static
id|mega_passthru
op_star
DECL|function|mega_prepare_passthru
id|mega_prepare_passthru
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
id|scb_t
op_star
id|scb
comma
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
id|channel
comma
r_int
id|target
)paren
(brace
id|mega_passthru
op_star
id|pthru
suffix:semicolon
id|pthru
op_assign
id|scb-&gt;pthru
suffix:semicolon
id|memset
c_func
(paren
id|pthru
comma
l_int|0
comma
r_sizeof
(paren
id|mega_passthru
)paren
)paren
suffix:semicolon
multiline_comment|/* 0=6sec/1=60sec/2=10min/3=3hrs */
id|pthru-&gt;timeout
op_assign
l_int|2
suffix:semicolon
id|pthru-&gt;ars
op_assign
l_int|1
suffix:semicolon
id|pthru-&gt;reqsenselen
op_assign
l_int|14
suffix:semicolon
id|pthru-&gt;islogical
op_assign
l_int|0
suffix:semicolon
id|pthru-&gt;channel
op_assign
(paren
id|adapter-&gt;flag
op_amp
id|BOARD_40LD
)paren
ques
c_cond
l_int|0
suffix:colon
id|channel
suffix:semicolon
id|pthru-&gt;target
op_assign
(paren
id|adapter-&gt;flag
op_amp
id|BOARD_40LD
)paren
ques
c_cond
(paren
id|channel
op_lshift
l_int|4
)paren
op_or
id|target
suffix:colon
id|target
suffix:semicolon
id|pthru-&gt;cdblen
op_assign
id|cmd-&gt;cmd_len
suffix:semicolon
id|pthru-&gt;logdrv
op_assign
id|cmd-&gt;device-&gt;lun
suffix:semicolon
id|memcpy
c_func
(paren
id|pthru-&gt;cdb
comma
id|cmd-&gt;cmnd
comma
id|cmd-&gt;cmd_len
)paren
suffix:semicolon
multiline_comment|/* Not sure about the direction */
id|scb-&gt;dma_direction
op_assign
id|PCI_DMA_BIDIRECTIONAL
suffix:semicolon
multiline_comment|/* Special Code for Handling READ_CAPA/ INQ using bounce buffers */
r_switch
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
id|INQUIRY
suffix:colon
r_case
id|READ_CAPACITY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|adapter-&gt;flag
op_amp
(paren
l_int|1L
op_lshift
id|cmd-&gt;device-&gt;channel
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;scsi%d: scanning scsi channel %d [P%d] &quot;
comma
id|adapter-&gt;host-&gt;host_no
comma
id|cmd-&gt;device-&gt;channel
comma
id|channel
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;for physical devices.&bslash;n&quot;
)paren
suffix:semicolon
id|adapter-&gt;flag
op_or_assign
(paren
l_int|1L
op_lshift
id|cmd-&gt;device-&gt;channel
)paren
suffix:semicolon
)brace
multiline_comment|/* Fall through */
r_default
suffix:colon
id|pthru-&gt;numsgelements
op_assign
id|mega_build_sglist
c_func
(paren
id|adapter
comma
id|scb
comma
op_amp
id|pthru-&gt;dataxferaddr
comma
op_amp
id|pthru-&gt;dataxferlen
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|pthru
suffix:semicolon
)brace
multiline_comment|/**&n; * mega_prepare_extpassthru()&n; * @adapter - pointer to our soft state&n; * @scb - our scsi control block&n; * @cmd - scsi command from the mid-layer&n; * @channel - actual channel on the controller&n; * @target - actual id on the controller.&n; *&n; * prepare a command for the scsi physical devices. This rountine prepares&n; * commands for devices which can take extended CDBs (&gt;10 bytes)&n; */
r_static
id|mega_ext_passthru
op_star
DECL|function|mega_prepare_extpassthru
id|mega_prepare_extpassthru
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
id|scb_t
op_star
id|scb
comma
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
id|channel
comma
r_int
id|target
)paren
(brace
id|mega_ext_passthru
op_star
id|epthru
suffix:semicolon
id|epthru
op_assign
id|scb-&gt;epthru
suffix:semicolon
id|memset
c_func
(paren
id|epthru
comma
l_int|0
comma
r_sizeof
(paren
id|mega_ext_passthru
)paren
)paren
suffix:semicolon
multiline_comment|/* 0=6sec/1=60sec/2=10min/3=3hrs */
id|epthru-&gt;timeout
op_assign
l_int|2
suffix:semicolon
id|epthru-&gt;ars
op_assign
l_int|1
suffix:semicolon
id|epthru-&gt;reqsenselen
op_assign
l_int|14
suffix:semicolon
id|epthru-&gt;islogical
op_assign
l_int|0
suffix:semicolon
id|epthru-&gt;channel
op_assign
(paren
id|adapter-&gt;flag
op_amp
id|BOARD_40LD
)paren
ques
c_cond
l_int|0
suffix:colon
id|channel
suffix:semicolon
id|epthru-&gt;target
op_assign
(paren
id|adapter-&gt;flag
op_amp
id|BOARD_40LD
)paren
ques
c_cond
(paren
id|channel
op_lshift
l_int|4
)paren
op_or
id|target
suffix:colon
id|target
suffix:semicolon
id|epthru-&gt;cdblen
op_assign
id|cmd-&gt;cmd_len
suffix:semicolon
id|epthru-&gt;logdrv
op_assign
id|cmd-&gt;device-&gt;lun
suffix:semicolon
id|memcpy
c_func
(paren
id|epthru-&gt;cdb
comma
id|cmd-&gt;cmnd
comma
id|cmd-&gt;cmd_len
)paren
suffix:semicolon
multiline_comment|/* Not sure about the direction */
id|scb-&gt;dma_direction
op_assign
id|PCI_DMA_BIDIRECTIONAL
suffix:semicolon
r_switch
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
id|INQUIRY
suffix:colon
r_case
id|READ_CAPACITY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|adapter-&gt;flag
op_amp
(paren
l_int|1L
op_lshift
id|cmd-&gt;device-&gt;channel
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;scsi%d: scanning scsi channel %d [P%d] &quot;
comma
id|adapter-&gt;host-&gt;host_no
comma
id|cmd-&gt;device-&gt;channel
comma
id|channel
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;for physical devices.&bslash;n&quot;
)paren
suffix:semicolon
id|adapter-&gt;flag
op_or_assign
(paren
l_int|1L
op_lshift
id|cmd-&gt;device-&gt;channel
)paren
suffix:semicolon
)brace
multiline_comment|/* Fall through */
r_default
suffix:colon
id|epthru-&gt;numsgelements
op_assign
id|mega_build_sglist
c_func
(paren
id|adapter
comma
id|scb
comma
op_amp
id|epthru-&gt;dataxferaddr
comma
op_amp
id|epthru-&gt;dataxferlen
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|epthru
suffix:semicolon
)brace
multiline_comment|/**&n; * mega_allocate_scb()&n; * @adapter - pointer to our soft state&n; * @cmd - scsi command from the mid-layer&n; *&n; * Allocate a SCB structure. This is the central structure for controller&n; * commands.&n; */
r_static
r_inline
id|scb_t
op_star
DECL|function|mega_allocate_scb
id|mega_allocate_scb
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|list_head
op_star
id|head
op_assign
op_amp
id|adapter-&gt;free_list
suffix:semicolon
id|scb_t
op_star
id|scb
suffix:semicolon
multiline_comment|/* Unlink command from Free List */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|head
)paren
)paren
(brace
id|scb
op_assign
id|list_entry
c_func
(paren
id|head-&gt;next
comma
id|scb_t
comma
id|list
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
id|head-&gt;next
)paren
suffix:semicolon
id|scb-&gt;state
op_assign
id|SCB_ACTIVE
suffix:semicolon
id|scb-&gt;cmd
op_assign
id|cmd
suffix:semicolon
id|scb-&gt;dma_type
op_assign
id|MEGA_DMA_TYPE_NONE
suffix:semicolon
r_return
id|scb
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * mega_runpendq()&n; * @adapter - pointer to our soft state&n; *&n; * Runs through the list of pending requests.&n; */
r_static
r_inline
r_void
DECL|function|mega_runpendq
id|mega_runpendq
c_func
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|adapter-&gt;pending_list
)paren
)paren
(brace
id|__mega_runpendq
c_func
(paren
id|adapter
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|__mega_runpendq
id|__mega_runpendq
c_func
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
id|scb_t
op_star
id|scb
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
comma
op_star
id|next
suffix:semicolon
multiline_comment|/* Issue any pending commands to the card */
id|list_for_each_safe
c_func
(paren
id|pos
comma
id|next
comma
op_amp
id|adapter-&gt;pending_list
)paren
(brace
id|scb
op_assign
id|list_entry
c_func
(paren
id|pos
comma
id|scb_t
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|scb-&gt;state
op_amp
id|SCB_ISSUED
)paren
)paren
(brace
r_if
c_cond
(paren
id|issue_scb
c_func
(paren
id|adapter
comma
id|scb
)paren
op_ne
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * issue_scb()&n; * @adapter - pointer to our soft state&n; * @scb - scsi control block&n; *&n; * Post a command to the card if the mailbox is available, otherwise return&n; * busy. We also take the scb from the pending list if the mailbox is&n; * available.&n; */
r_static
r_inline
r_int
DECL|function|issue_scb
id|issue_scb
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
id|scb_t
op_star
id|scb
)paren
(brace
r_volatile
id|mbox64_t
op_star
id|mbox64
op_assign
id|adapter-&gt;mbox64
suffix:semicolon
r_volatile
id|mbox_t
op_star
id|mbox
op_assign
id|adapter-&gt;mbox
suffix:semicolon
r_int
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|mbox-&gt;busy
)paren
)paren
(brace
r_do
(brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|mbox-&gt;busy
op_logical_and
(paren
id|i
OL
id|max_mbox_busy_wait
)paren
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mbox-&gt;busy
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* Copy mailbox data into host structure */
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|mbox
comma
(paren
r_char
op_star
)paren
id|scb-&gt;raw_mbox
comma
l_int|16
)paren
suffix:semicolon
id|mbox-&gt;cmdid
op_assign
id|scb-&gt;idx
suffix:semicolon
multiline_comment|/* Set cmdid */
id|mbox-&gt;busy
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Set busy */
multiline_comment|/*&n;&t; * Increment the pending queue counter&n;&t; */
id|atomic_inc
c_func
(paren
op_amp
id|adapter-&gt;pend_cmds
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|mbox-&gt;cmd
)paren
(brace
r_case
id|MEGA_MBOXCMD_LREAD64
suffix:colon
r_case
id|MEGA_MBOXCMD_LWRITE64
suffix:colon
r_case
id|MEGA_MBOXCMD_PASSTHRU64
suffix:colon
r_case
id|MEGA_MBOXCMD_EXTPTHRU
suffix:colon
id|mbox64-&gt;xfer_segment_lo
op_assign
id|mbox-&gt;xferaddr
suffix:semicolon
id|mbox64-&gt;xfer_segment_hi
op_assign
l_int|0
suffix:semicolon
id|mbox-&gt;xferaddr
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|mbox64-&gt;xfer_segment_lo
op_assign
l_int|0
suffix:semicolon
id|mbox64-&gt;xfer_segment_hi
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * post the command&n;&t; */
id|scb-&gt;state
op_or_assign
id|SCB_ISSUED
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|adapter-&gt;flag
op_amp
id|BOARD_MEMMAP
)paren
)paren
(brace
id|mbox-&gt;poll
op_assign
l_int|0
suffix:semicolon
id|mbox-&gt;ack
op_assign
l_int|0
suffix:semicolon
id|WRINDOOR
c_func
(paren
id|adapter
comma
id|adapter-&gt;mbox_dma
op_or
l_int|0x1
)paren
suffix:semicolon
)brace
r_else
(brace
id|irq_enable
c_func
(paren
id|adapter
)paren
suffix:semicolon
id|issue_command
c_func
(paren
id|adapter
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * issue_scb_block()&n; * @adapter - pointer to our soft state&n; * @raw_mbox - the mailbox&n; *&n; * Issue a scb in synchronous and non-interrupt mode&n; */
r_static
r_int
DECL|function|issue_scb_block
id|issue_scb_block
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
id|u_char
op_star
id|raw_mbox
)paren
(brace
r_volatile
id|mbox64_t
op_star
id|mbox64
op_assign
id|adapter-&gt;mbox64
suffix:semicolon
r_volatile
id|mbox_t
op_star
id|mbox
op_assign
id|adapter-&gt;mbox
suffix:semicolon
id|u8
id|byte
suffix:semicolon
id|raw_mbox
(braket
l_int|0x1
)braket
op_assign
l_int|0xFE
suffix:semicolon
multiline_comment|/* Set cmdid */
id|raw_mbox
(braket
l_int|0xF
)braket
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Set busy */
multiline_comment|/* Wait until mailbox is free */
r_if
c_cond
(paren
id|mega_busywait_mbox
(paren
id|adapter
)paren
)paren
(brace
r_goto
id|bug_blocked_mailbox
suffix:semicolon
)brace
multiline_comment|/* Copy mailbox data into host structure */
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|mbox
comma
id|raw_mbox
comma
l_int|16
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|raw_mbox
(braket
l_int|0
)braket
)paren
(brace
r_case
id|MEGA_MBOXCMD_LREAD64
suffix:colon
r_case
id|MEGA_MBOXCMD_LWRITE64
suffix:colon
r_case
id|MEGA_MBOXCMD_PASSTHRU64
suffix:colon
r_case
id|MEGA_MBOXCMD_EXTPTHRU
suffix:colon
id|mbox64-&gt;xfer_segment_lo
op_assign
id|mbox-&gt;xferaddr
suffix:semicolon
id|mbox64-&gt;xfer_segment_hi
op_assign
l_int|0
suffix:semicolon
id|mbox-&gt;xferaddr
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|mbox64-&gt;xfer_segment_lo
op_assign
l_int|0
suffix:semicolon
id|mbox64-&gt;xfer_segment_hi
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|adapter-&gt;flag
op_amp
id|BOARD_MEMMAP
)paren
)paren
(brace
id|mbox-&gt;poll
op_assign
l_int|0
suffix:semicolon
id|mbox-&gt;ack
op_assign
l_int|0
suffix:semicolon
id|mbox-&gt;numstatus
op_assign
l_int|0xFF
suffix:semicolon
id|mbox-&gt;status
op_assign
l_int|0xFF
suffix:semicolon
id|WRINDOOR
c_func
(paren
id|adapter
comma
id|adapter-&gt;mbox_dma
op_or
l_int|0x1
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
r_volatile
id|u8
)paren
id|mbox-&gt;numstatus
op_eq
l_int|0xFF
)paren
(brace
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
)brace
id|mbox-&gt;numstatus
op_assign
l_int|0xFF
suffix:semicolon
r_while
c_loop
(paren
(paren
r_volatile
id|u8
)paren
id|mbox-&gt;poll
op_ne
l_int|0x77
)paren
(brace
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
)brace
id|mbox-&gt;poll
op_assign
l_int|0
suffix:semicolon
id|mbox-&gt;ack
op_assign
l_int|0x77
suffix:semicolon
id|WRINDOOR
c_func
(paren
id|adapter
comma
id|adapter-&gt;mbox_dma
op_or
l_int|0x2
)paren
suffix:semicolon
r_while
c_loop
(paren
id|RDINDOOR
c_func
(paren
id|adapter
)paren
op_amp
l_int|0x2
)paren
(brace
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|irq_disable
c_func
(paren
id|adapter
)paren
suffix:semicolon
id|issue_command
c_func
(paren
id|adapter
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|byte
op_assign
id|irq_state
c_func
(paren
id|adapter
)paren
)paren
op_amp
id|INTR_VALID
)paren
)paren
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
id|set_irq_state
c_func
(paren
id|adapter
comma
id|byte
)paren
suffix:semicolon
id|irq_enable
c_func
(paren
id|adapter
)paren
suffix:semicolon
id|irq_ack
c_func
(paren
id|adapter
)paren
suffix:semicolon
)brace
r_return
id|mbox-&gt;status
suffix:semicolon
id|bug_blocked_mailbox
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;megaraid: Blocked mailbox......!!&bslash;n&quot;
)paren
suffix:semicolon
id|udelay
(paren
l_int|1000
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_isr_iomapped()&n; * @irq - irq&n; * @devp - pointer to our soft state&n; * @regs - unused&n; *&n; * Interrupt service routine for io-mapped controllers.&n; * Find out if our device is interrupting. If yes, acknowledge the interrupt&n; * and service the completed commands.&n; */
r_static
id|irqreturn_t
DECL|function|megaraid_isr_iomapped
id|megaraid_isr_iomapped
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|devp
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|adapter_t
op_star
id|adapter
op_assign
id|devp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|u8
id|status
suffix:semicolon
id|u8
id|nstatus
suffix:semicolon
id|u8
id|completed
(braket
id|MAX_FIRMWARE_STATUS
)braket
suffix:semicolon
id|u8
id|byte
suffix:semicolon
r_int
id|handled
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * loop till F/W has more commands for us to complete.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|adapter-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/* Check if a valid interrupt is pending */
id|byte
op_assign
id|irq_state
c_func
(paren
id|adapter
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|byte
op_amp
id|VALID_INTR_BYTE
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * No more pending commands&n;&t;&t;&t; */
r_goto
id|out_unlock
suffix:semicolon
)brace
id|set_irq_state
c_func
(paren
id|adapter
comma
id|byte
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|nstatus
op_assign
(paren
r_volatile
id|u8
)paren
id|adapter-&gt;mbox-&gt;numstatus
)paren
op_eq
l_int|0xFF
)paren
(brace
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
)brace
id|adapter-&gt;mbox-&gt;numstatus
op_assign
l_int|0xFF
suffix:semicolon
id|status
op_assign
id|adapter-&gt;mbox-&gt;status
suffix:semicolon
multiline_comment|/*&n;&t;&t; * decrement the pending queue counter&n;&t;&t; */
id|atomic_sub
c_func
(paren
id|nstatus
comma
op_amp
id|adapter-&gt;pend_cmds
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|completed
comma
(paren
r_void
op_star
)paren
id|adapter-&gt;mbox-&gt;completed
comma
id|nstatus
)paren
suffix:semicolon
multiline_comment|/* Acknowledge interrupt */
id|irq_ack
c_func
(paren
id|adapter
)paren
suffix:semicolon
id|mega_cmd_done
c_func
(paren
id|adapter
comma
id|completed
comma
id|nstatus
comma
id|status
)paren
suffix:semicolon
id|mega_rundoneq
c_func
(paren
id|adapter
)paren
suffix:semicolon
id|handled
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Loop through any pending requests */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|adapter-&gt;quiescent
)paren
op_eq
l_int|0
)paren
(brace
id|mega_runpendq
c_func
(paren
id|adapter
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
suffix:semicolon
)brace
id|out_unlock
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|adapter-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|IRQ_RETVAL
c_func
(paren
id|handled
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_isr_memmapped()&n; * @irq - irq&n; * @devp - pointer to our soft state&n; * @regs - unused&n; *&n; * Interrupt service routine for memory-mapped controllers.&n; * Find out if our device is interrupting. If yes, acknowledge the interrupt&n; * and service the completed commands.&n; */
r_static
id|irqreturn_t
DECL|function|megaraid_isr_memmapped
id|megaraid_isr_memmapped
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|devp
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|adapter_t
op_star
id|adapter
op_assign
id|devp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|u8
id|status
suffix:semicolon
id|u32
id|dword
op_assign
l_int|0
suffix:semicolon
id|u8
id|nstatus
suffix:semicolon
id|u8
id|completed
(braket
id|MAX_FIRMWARE_STATUS
)braket
suffix:semicolon
r_int
id|handled
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * loop till F/W has more commands for us to complete.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|adapter-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/* Check if a valid interrupt is pending */
id|dword
op_assign
id|RDOUTDOOR
c_func
(paren
id|adapter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dword
op_ne
l_int|0x10001234
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * No more pending commands&n;&t;&t;&t; */
r_goto
id|out_unlock
suffix:semicolon
)brace
id|WROUTDOOR
c_func
(paren
id|adapter
comma
l_int|0x10001234
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|nstatus
op_assign
(paren
r_volatile
id|u8
)paren
id|adapter-&gt;mbox-&gt;numstatus
)paren
op_eq
l_int|0xFF
)paren
(brace
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
)brace
id|adapter-&gt;mbox-&gt;numstatus
op_assign
l_int|0xFF
suffix:semicolon
id|status
op_assign
id|adapter-&gt;mbox-&gt;status
suffix:semicolon
multiline_comment|/*&n;&t;&t; * decrement the pending queue counter&n;&t;&t; */
id|atomic_sub
c_func
(paren
id|nstatus
comma
op_amp
id|adapter-&gt;pend_cmds
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|completed
comma
(paren
r_void
op_star
)paren
id|adapter-&gt;mbox-&gt;completed
comma
id|nstatus
)paren
suffix:semicolon
multiline_comment|/* Acknowledge interrupt */
id|WRINDOOR
c_func
(paren
id|adapter
comma
l_int|0x2
)paren
suffix:semicolon
id|handled
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|RDINDOOR
c_func
(paren
id|adapter
)paren
op_amp
l_int|0x02
)paren
(brace
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
)brace
id|mega_cmd_done
c_func
(paren
id|adapter
comma
id|completed
comma
id|nstatus
comma
id|status
)paren
suffix:semicolon
id|mega_rundoneq
c_func
(paren
id|adapter
)paren
suffix:semicolon
multiline_comment|/* Loop through any pending requests */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|adapter-&gt;quiescent
)paren
op_eq
l_int|0
)paren
(brace
id|mega_runpendq
c_func
(paren
id|adapter
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
suffix:semicolon
)brace
id|out_unlock
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|adapter-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|IRQ_RETVAL
c_func
(paren
id|handled
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * mega_cmd_done()&n; * @adapter - pointer to our soft state&n; * @completed - array of ids of completed commands&n; * @nstatus - number of completed commands&n; * @status - status of the last command completed&n; *&n; * Complete the comamnds and call the scsi mid-layer callback hooks.&n; */
r_static
r_inline
r_void
DECL|function|mega_cmd_done
id|mega_cmd_done
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
id|u8
id|completed
(braket
)braket
comma
r_int
id|nstatus
comma
r_int
id|status
)paren
(brace
id|mega_ext_passthru
op_star
id|epthru
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sgl
suffix:semicolon
id|Scsi_Cmnd
op_star
id|cmd
op_assign
l_int|NULL
suffix:semicolon
id|mega_passthru
op_star
id|pthru
op_assign
l_int|NULL
suffix:semicolon
id|mbox_t
op_star
id|mbox
op_assign
l_int|NULL
suffix:semicolon
id|u8
id|c
suffix:semicolon
id|scb_t
op_star
id|scb
suffix:semicolon
r_int
id|islogical
suffix:semicolon
r_int
id|cmdid
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * for all the commands completed, call the mid-layer callback routine&n;&t; * and free the scb.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nstatus
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cmdid
op_assign
id|completed
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|cmdid
op_eq
id|CMDID_INT_CMDS
)paren
(brace
multiline_comment|/* internal command */
id|scb
op_assign
op_amp
id|adapter-&gt;int_scb
suffix:semicolon
id|cmd
op_assign
id|scb-&gt;cmd
suffix:semicolon
id|mbox
op_assign
(paren
id|mbox_t
op_star
)paren
id|scb-&gt;raw_mbox
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Internal command interface do not fire the extended&n;&t;&t;&t; * passthru or 64-bit passthru&n;&t;&t;&t; */
id|pthru
op_assign
id|scb-&gt;pthru
suffix:semicolon
)brace
r_else
(brace
id|scb
op_assign
op_amp
id|adapter-&gt;scb_list
(braket
id|cmdid
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Make sure f/w has completed a valid command&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|scb-&gt;state
op_amp
id|SCB_ISSUED
)paren
op_logical_or
id|scb-&gt;cmd
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;megaraid: invalid command &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Id %d, scb-&gt;state:%x, scsi cmd:%p&bslash;n&quot;
comma
id|cmdid
comma
id|scb-&gt;state
comma
id|scb-&gt;cmd
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Was a abort issued for this command&n;&t;&t;&t; */
r_if
c_cond
(paren
id|scb-&gt;state
op_amp
id|SCB_ABORT
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;megaraid: aborted cmd %lx[%x] complete.&bslash;n&quot;
comma
id|scb-&gt;cmd-&gt;serial_number
comma
id|scb-&gt;idx
)paren
suffix:semicolon
id|scb-&gt;cmd-&gt;result
op_assign
(paren
id|DID_ABORT
op_lshift
l_int|16
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
id|SCSI_LIST
c_func
(paren
id|scb-&gt;cmd
)paren
comma
op_amp
id|adapter-&gt;completed_list
)paren
suffix:semicolon
id|mega_free_scb
c_func
(paren
id|adapter
comma
id|scb
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Was a reset issued for this command&n;&t;&t;&t; */
r_if
c_cond
(paren
id|scb-&gt;state
op_amp
id|SCB_RESET
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;megaraid: reset cmd %lx[%x] complete.&bslash;n&quot;
comma
id|scb-&gt;cmd-&gt;serial_number
comma
id|scb-&gt;idx
)paren
suffix:semicolon
id|scb-&gt;cmd-&gt;result
op_assign
(paren
id|DID_RESET
op_lshift
l_int|16
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
id|SCSI_LIST
c_func
(paren
id|scb-&gt;cmd
)paren
comma
op_amp
id|adapter-&gt;completed_list
)paren
suffix:semicolon
id|mega_free_scb
(paren
id|adapter
comma
id|scb
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|cmd
op_assign
id|scb-&gt;cmd
suffix:semicolon
id|pthru
op_assign
id|scb-&gt;pthru
suffix:semicolon
id|epthru
op_assign
id|scb-&gt;epthru
suffix:semicolon
id|mbox
op_assign
(paren
id|mbox_t
op_star
)paren
id|scb-&gt;raw_mbox
suffix:semicolon
macro_line|#if MEGA_HAVE_STATS
(brace
r_int
id|logdrv
op_assign
id|mbox-&gt;logdrv
suffix:semicolon
id|islogical
op_assign
id|adapter-&gt;logdrv_chan
(braket
id|cmd-&gt;channel
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Maintain an error counter for the logical drive.&n;&t;&t;&t; * Some application like SNMP agent need such&n;&t;&t;&t; * statistics&n;&t;&t;&t; */
r_if
c_cond
(paren
id|status
op_logical_and
id|islogical
op_logical_and
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|READ_6
op_logical_or
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|READ_10
op_logical_or
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|READ_12
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Logical drive number increases by 0x80 when&n;&t;&t;&t;&t; * a logical drive is deleted&n;&t;&t;&t;&t; */
id|adapter-&gt;rd_errors
(braket
id|logdrv
op_mod
l_int|0x80
)braket
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_logical_and
id|islogical
op_logical_and
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|WRITE_6
op_logical_or
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|WRITE_10
op_logical_or
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|WRITE_12
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Logical drive number increases by 0x80 when&n;&t;&t;&t;&t; * a logical drive is deleted&n;&t;&t;&t;&t; */
id|adapter-&gt;wr_errors
(braket
id|logdrv
op_mod
l_int|0x80
)braket
op_increment
suffix:semicolon
)brace
)brace
macro_line|#endif
)brace
multiline_comment|/*&n;&t;&t; * Do not return the presence of hard disk on the channel so,&n;&t;&t; * inquiry sent, and returned data==hard disk or removable&n;&t;&t; * hard disk and not logical, request should return failure! -&n;&t;&t; * PJ&n;&t;&t; */
id|islogical
op_assign
id|adapter-&gt;logdrv_chan
(braket
id|cmd-&gt;device-&gt;channel
)braket
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
op_logical_and
op_logical_neg
id|islogical
)paren
(brace
r_if
c_cond
(paren
id|cmd-&gt;use_sg
)paren
(brace
id|sgl
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;request_buffer
suffix:semicolon
r_if
c_cond
(paren
id|sgl-&gt;page
)paren
(brace
id|c
op_assign
op_star
(paren
r_int
r_char
op_star
)paren
id|page_address
c_func
(paren
(paren
op_amp
id|sgl
(braket
l_int|0
)braket
)paren
op_member_access_from_pointer
id|page
)paren
op_plus
(paren
op_amp
id|sgl
(braket
l_int|0
)braket
)paren
op_member_access_from_pointer
id|offset
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;megaraid: invalid sg.&bslash;n&quot;
)paren
suffix:semicolon
id|c
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|c
op_assign
op_star
(paren
id|u8
op_star
)paren
id|cmd-&gt;request_buffer
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_RAID_CH
c_func
(paren
id|adapter
comma
id|cmd-&gt;device-&gt;channel
)paren
op_logical_and
(paren
(paren
id|c
op_amp
l_int|0x1F
)paren
op_eq
id|TYPE_DISK
)paren
)paren
(brace
id|status
op_assign
l_int|0xF0
suffix:semicolon
)brace
)brace
multiline_comment|/* clear result; otherwise, success returns corrupt value */
id|cmd-&gt;result
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Convert MegaRAID status to Linux error code */
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
l_int|0x00
suffix:colon
multiline_comment|/* SUCCESS , i.e. SCSI_STATUS_GOOD */
id|cmd-&gt;result
op_or_assign
(paren
id|DID_OK
op_lshift
l_int|16
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x02
suffix:colon
multiline_comment|/* ERROR_ABORTED, i.e.&n;&t;&t;&t;&t;   SCSI_STATUS_CHECK_CONDITION */
multiline_comment|/* set sense_buffer and result fields */
r_if
c_cond
(paren
id|mbox-&gt;cmd
op_eq
id|MEGA_MBOXCMD_PASSTHRU
op_logical_or
id|mbox-&gt;cmd
op_eq
id|MEGA_MBOXCMD_PASSTHRU64
)paren
(brace
id|memcpy
c_func
(paren
id|cmd-&gt;sense_buffer
comma
id|pthru-&gt;reqsensearea
comma
l_int|14
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
(paren
id|DRIVER_SENSE
op_lshift
l_int|24
)paren
op_or
(paren
id|DID_OK
op_lshift
l_int|16
)paren
op_or
(paren
id|CHECK_CONDITION
op_lshift
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|mbox-&gt;cmd
op_eq
id|MEGA_MBOXCMD_EXTPTHRU
)paren
(brace
id|memcpy
c_func
(paren
id|cmd-&gt;sense_buffer
comma
id|epthru-&gt;reqsensearea
comma
l_int|14
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
(paren
id|DRIVER_SENSE
op_lshift
l_int|24
)paren
op_or
(paren
id|DID_OK
op_lshift
l_int|16
)paren
op_or
(paren
id|CHECK_CONDITION
op_lshift
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|cmd-&gt;sense_buffer
(braket
l_int|0
)braket
op_assign
l_int|0x70
suffix:semicolon
id|cmd-&gt;sense_buffer
(braket
l_int|2
)braket
op_assign
id|ABORTED_COMMAND
suffix:semicolon
id|cmd-&gt;result
op_or_assign
(paren
id|CHECK_CONDITION
op_lshift
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
l_int|0x08
suffix:colon
multiline_comment|/* ERR_DEST_DRIVE_FAILED, i.e.&n;&t;&t;&t;&t;   SCSI_STATUS_BUSY */
id|cmd-&gt;result
op_or_assign
(paren
id|DID_BUS_BUSY
op_lshift
l_int|16
)paren
op_or
id|status
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
macro_line|#if MEGA_HAVE_CLUSTERING
multiline_comment|/*&n;&t;&t;&t; * If TEST_UNIT_READY fails, we know&n;&t;&t;&t; * MEGA_RESERVATION_STATUS failed&n;&t;&t;&t; */
r_if
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|TEST_UNIT_READY
)paren
(brace
id|cmd-&gt;result
op_or_assign
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
op_or
(paren
id|RESERVATION_CONFLICT
op_lshift
l_int|1
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/*&n;&t;&t;&t; * Error code returned is 1 if Reserve or Release&n;&t;&t;&t; * failed or the input parameter is invalid&n;&t;&t;&t; */
r_if
c_cond
(paren
id|status
op_eq
l_int|1
op_logical_and
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|RESERVE
op_logical_or
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|RELEASE
)paren
)paren
(brace
id|cmd-&gt;result
op_or_assign
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
op_or
(paren
id|RESERVATION_CONFLICT
op_lshift
l_int|1
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif
id|cmd-&gt;result
op_or_assign
(paren
id|DID_BAD_TARGET
op_lshift
l_int|16
)paren
op_or
id|status
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Only free SCBs for the commands coming down from the&n;&t;&t; * mid-layer, not for which were issued internally&n;&t;&t; *&n;&t;&t; * For internal command, restore the status returned by the&n;&t;&t; * firmware so that user can interpret it.&n;&t;&t; */
r_if
c_cond
(paren
id|cmdid
op_eq
id|CMDID_INT_CMDS
)paren
(brace
multiline_comment|/* internal command */
id|cmd-&gt;result
op_assign
id|status
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Remove the internal command from the pending list&n;&t;&t;&t; */
id|list_del_init
c_func
(paren
op_amp
id|scb-&gt;list
)paren
suffix:semicolon
id|scb-&gt;state
op_assign
id|SCB_FREE
suffix:semicolon
)brace
r_else
(brace
id|mega_free_scb
c_func
(paren
id|adapter
comma
id|scb
)paren
suffix:semicolon
)brace
multiline_comment|/* Add Scsi_Command to end of completed queue */
id|list_add_tail
c_func
(paren
id|SCSI_LIST
c_func
(paren
id|cmd
)paren
comma
op_amp
id|adapter-&gt;completed_list
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * mega_runpendq()&n; *&n; * Run through the list of completed requests and finish it&n; */
r_static
r_void
DECL|function|mega_rundoneq
id|mega_rundoneq
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|adapter-&gt;completed_list
)paren
(brace
id|Scsi_Pointer
op_star
id|spos
op_assign
(paren
id|Scsi_Pointer
op_star
)paren
id|pos
suffix:semicolon
id|cmd
op_assign
id|list_entry
c_func
(paren
id|spos
comma
id|Scsi_Cmnd
comma
id|SCp
)paren
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|adapter-&gt;completed_list
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Free a SCB structure&n; * Note: We assume the scsi commands associated with this scb is not free yet.&n; */
r_static
r_void
DECL|function|mega_free_scb
id|mega_free_scb
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
id|scb_t
op_star
id|scb
)paren
(brace
r_switch
c_cond
(paren
id|scb-&gt;dma_type
)paren
(brace
r_case
id|MEGA_DMA_TYPE_NONE
suffix:colon
r_break
suffix:semicolon
r_case
id|MEGA_BULK_DATA
suffix:colon
id|pci_unmap_page
c_func
(paren
id|adapter-&gt;dev
comma
id|scb-&gt;dma_h_bulkdata
comma
id|scb-&gt;cmd-&gt;request_bufflen
comma
id|scb-&gt;dma_direction
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb-&gt;dma_direction
op_eq
id|PCI_DMA_FROMDEVICE
)paren
(brace
id|pci_dma_sync_single
c_func
(paren
id|adapter-&gt;dev
comma
id|scb-&gt;dma_h_bulkdata
comma
id|scb-&gt;cmd-&gt;request_bufflen
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|MEGA_SGLIST
suffix:colon
id|pci_unmap_sg
c_func
(paren
id|adapter-&gt;dev
comma
id|scb-&gt;cmd-&gt;request_buffer
comma
id|scb-&gt;cmd-&gt;use_sg
comma
id|scb-&gt;dma_direction
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb-&gt;dma_direction
op_eq
id|PCI_DMA_FROMDEVICE
)paren
(brace
id|pci_dma_sync_sg
c_func
(paren
id|adapter-&gt;dev
comma
id|scb-&gt;cmd-&gt;request_buffer
comma
id|scb-&gt;cmd-&gt;use_sg
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Remove from the pending list&n;&t; */
id|list_del_init
c_func
(paren
op_amp
id|scb-&gt;list
)paren
suffix:semicolon
multiline_comment|/* Link the scb back into free list */
id|scb-&gt;state
op_assign
id|SCB_FREE
suffix:semicolon
id|scb-&gt;cmd
op_assign
l_int|NULL
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|scb-&gt;list
comma
op_amp
id|adapter-&gt;free_list
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait until the controller&squot;s mailbox is available&n; */
r_static
r_inline
r_int
DECL|function|mega_busywait_mbox
id|mega_busywait_mbox
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
r_if
c_cond
(paren
id|adapter-&gt;mbox-&gt;busy
)paren
r_return
id|__mega_busywait_mbox
c_func
(paren
id|adapter
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|__mega_busywait_mbox
id|__mega_busywait_mbox
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
r_volatile
id|mbox_t
op_star
id|mbox
op_assign
id|adapter-&gt;mbox
suffix:semicolon
r_int
id|counter
suffix:semicolon
r_for
c_loop
(paren
id|counter
op_assign
l_int|0
suffix:semicolon
id|counter
OL
l_int|10000
suffix:semicolon
id|counter
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mbox-&gt;busy
)paren
r_return
l_int|0
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|yield
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* give up after 1 second */
)brace
multiline_comment|/*&n; * Copies data to SGLIST&n; * Note: For 64 bit cards, we need a minimum of one SG element for read/write&n; */
r_static
r_int
DECL|function|mega_build_sglist
id|mega_build_sglist
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
id|scb_t
op_star
id|scb
comma
id|u32
op_star
id|buf
comma
id|u32
op_star
id|len
)paren
(brace
r_struct
id|scatterlist
op_star
id|sgl
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
r_int
id|sgcnt
suffix:semicolon
r_int
id|idx
suffix:semicolon
id|cmd
op_assign
id|scb-&gt;cmd
suffix:semicolon
multiline_comment|/* Scatter-gather not used */
r_if
c_cond
(paren
op_logical_neg
id|cmd-&gt;use_sg
)paren
(brace
id|page
op_assign
id|virt_to_page
c_func
(paren
id|cmd-&gt;request_buffer
)paren
suffix:semicolon
id|offset
op_assign
(paren
(paren
r_int
r_int
)paren
id|cmd-&gt;request_buffer
op_amp
op_complement
id|PAGE_MASK
)paren
suffix:semicolon
id|scb-&gt;dma_h_bulkdata
op_assign
id|pci_map_page
c_func
(paren
id|adapter-&gt;dev
comma
id|page
comma
id|offset
comma
id|cmd-&gt;request_bufflen
comma
id|scb-&gt;dma_direction
)paren
suffix:semicolon
id|scb-&gt;dma_type
op_assign
id|MEGA_BULK_DATA
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We need to handle special 64-bit commands that need a&n;&t;&t; * minimum of 1 SG&n;&t;&t; */
r_if
c_cond
(paren
id|adapter-&gt;has_64bit_addr
)paren
(brace
id|scb-&gt;sgl64
(braket
l_int|0
)braket
dot
id|address
op_assign
id|scb-&gt;dma_h_bulkdata
suffix:semicolon
id|scb-&gt;sgl64
(braket
l_int|0
)braket
dot
id|length
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
op_star
id|buf
op_assign
(paren
id|u32
)paren
id|scb-&gt;sgl_dma_addr
suffix:semicolon
op_star
id|len
op_assign
(paren
id|u32
)paren
id|cmd-&gt;request_bufflen
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
op_star
id|buf
op_assign
(paren
id|u32
)paren
id|scb-&gt;dma_h_bulkdata
suffix:semicolon
op_star
id|len
op_assign
(paren
id|u32
)paren
id|cmd-&gt;request_bufflen
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scb-&gt;dma_direction
op_eq
id|PCI_DMA_TODEVICE
)paren
(brace
id|pci_dma_sync_single
c_func
(paren
id|adapter-&gt;dev
comma
id|scb-&gt;dma_h_bulkdata
comma
id|cmd-&gt;request_bufflen
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|sgl
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;request_buffer
suffix:semicolon
multiline_comment|/*&n;&t; * Copy Scatter-Gather list info into controller structure.&n;&t; *&n;&t; * The number of sg elements returned must not exceed our limit&n;&t; */
id|sgcnt
op_assign
id|pci_map_sg
c_func
(paren
id|adapter-&gt;dev
comma
id|sgl
comma
id|cmd-&gt;use_sg
comma
id|scb-&gt;dma_direction
)paren
suffix:semicolon
id|scb-&gt;dma_type
op_assign
id|MEGA_SGLIST
suffix:semicolon
r_if
c_cond
(paren
id|sgcnt
OG
id|adapter-&gt;sglen
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|sgcnt
suffix:semicolon
id|idx
op_increment
comma
id|sgl
op_increment
)paren
(brace
r_if
c_cond
(paren
id|adapter-&gt;has_64bit_addr
)paren
(brace
id|scb-&gt;sgl64
(braket
id|idx
)braket
dot
id|address
op_assign
id|sg_dma_address
c_func
(paren
id|sgl
)paren
suffix:semicolon
id|scb-&gt;sgl64
(braket
id|idx
)braket
dot
id|length
op_assign
id|sg_dma_len
c_func
(paren
id|sgl
)paren
suffix:semicolon
)brace
r_else
(brace
id|scb-&gt;sgl
(braket
id|idx
)braket
dot
id|address
op_assign
id|sg_dma_address
c_func
(paren
id|sgl
)paren
suffix:semicolon
id|scb-&gt;sgl
(braket
id|idx
)braket
dot
id|length
op_assign
id|sg_dma_len
c_func
(paren
id|sgl
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Reset pointer and length fields */
op_star
id|buf
op_assign
id|scb-&gt;sgl_dma_addr
suffix:semicolon
multiline_comment|/*&n;&t; * For passthru command, dataxferlen must be set, even for commands&n;&t; * with a sg list&n;&t; */
op_star
id|len
op_assign
(paren
id|u32
)paren
id|cmd-&gt;request_bufflen
suffix:semicolon
r_if
c_cond
(paren
id|scb-&gt;dma_direction
op_eq
id|PCI_DMA_TODEVICE
)paren
(brace
id|pci_dma_sync_sg
c_func
(paren
id|adapter-&gt;dev
comma
id|sgl
comma
id|cmd-&gt;use_sg
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
)brace
multiline_comment|/* Return count of SG requests */
r_return
id|sgcnt
suffix:semicolon
)brace
multiline_comment|/*&n; * mega_8_to_40ld()&n; *&n; * takes all info in AdapterInquiry structure and puts it into ProductInfo and&n; * Enquiry3 structures for later use&n; */
r_static
r_void
DECL|function|mega_8_to_40ld
id|mega_8_to_40ld
c_func
(paren
id|mraid_inquiry
op_star
id|inquiry
comma
id|mega_inquiry3
op_star
id|enquiry3
comma
id|mega_product_info
op_star
id|product_info
)paren
(brace
r_int
id|i
suffix:semicolon
id|product_info-&gt;max_commands
op_assign
id|inquiry-&gt;adapter_info.max_commands
suffix:semicolon
id|enquiry3-&gt;rebuild_rate
op_assign
id|inquiry-&gt;adapter_info.rebuild_rate
suffix:semicolon
id|product_info-&gt;nchannels
op_assign
id|inquiry-&gt;adapter_info.nchannels
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|product_info-&gt;fw_version
(braket
id|i
)braket
op_assign
id|inquiry-&gt;adapter_info.fw_version
(braket
id|i
)braket
suffix:semicolon
id|product_info-&gt;bios_version
(braket
id|i
)braket
op_assign
id|inquiry-&gt;adapter_info.bios_version
(braket
id|i
)braket
suffix:semicolon
)brace
id|enquiry3-&gt;cache_flush_interval
op_assign
id|inquiry-&gt;adapter_info.cache_flush_interval
suffix:semicolon
id|product_info-&gt;dram_size
op_assign
id|inquiry-&gt;adapter_info.dram_size
suffix:semicolon
id|enquiry3-&gt;num_ldrv
op_assign
id|inquiry-&gt;logdrv_info.num_ldrv
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_LOGICAL_DRIVES_8LD
suffix:semicolon
id|i
op_increment
)paren
(brace
id|enquiry3-&gt;ldrv_size
(braket
id|i
)braket
op_assign
id|inquiry-&gt;logdrv_info.ldrv_size
(braket
id|i
)braket
suffix:semicolon
id|enquiry3-&gt;ldrv_prop
(braket
id|i
)braket
op_assign
id|inquiry-&gt;logdrv_info.ldrv_prop
(braket
id|i
)braket
suffix:semicolon
id|enquiry3-&gt;ldrv_state
(braket
id|i
)braket
op_assign
id|inquiry-&gt;logdrv_info.ldrv_state
(braket
id|i
)braket
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|MAX_PHYSICAL_DRIVES
)paren
suffix:semicolon
id|i
op_increment
)paren
id|enquiry3-&gt;pdrv_state
(braket
id|i
)braket
op_assign
id|inquiry-&gt;pdrv_info.pdrv_state
(braket
id|i
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; * megaraid_proc_info()&n; *&n; * Returns data to be displayed in /proc/scsi/megaraid/X&n; */
r_static
r_int
DECL|function|megaraid_proc_info
id|megaraid_proc_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|host_no
comma
r_int
id|inout
)paren
(brace
op_star
id|start
op_assign
id|buffer
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Release the controller&squot;s resources&n; */
r_static
r_int
DECL|function|megaraid_release
id|megaraid_release
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
id|adapter_t
op_star
id|adapter
suffix:semicolon
id|mbox_t
op_star
id|mbox
suffix:semicolon
id|u_char
id|raw_mbox
(braket
l_int|16
)braket
suffix:semicolon
r_char
id|buf
(braket
l_int|12
)braket
op_assign
(brace
l_int|0
)brace
suffix:semicolon
id|adapter
op_assign
(paren
id|adapter_t
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|mbox
op_assign
(paren
id|mbox_t
op_star
)paren
id|raw_mbox
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;megaraid: being unloaded...&quot;
)paren
suffix:semicolon
multiline_comment|/* Flush adapter cache */
id|memset
c_func
(paren
id|mbox
comma
l_int|0
comma
l_int|16
)paren
suffix:semicolon
id|raw_mbox
(braket
l_int|0
)braket
op_assign
id|FLUSH_ADAPTER
suffix:semicolon
id|irq_disable
c_func
(paren
id|adapter
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|adapter-&gt;host-&gt;irq
comma
id|adapter
)paren
suffix:semicolon
multiline_comment|/* Issue a blocking (interrupts disabled) command to the card */
id|issue_scb_block
c_func
(paren
id|adapter
comma
id|raw_mbox
)paren
suffix:semicolon
multiline_comment|/* Flush disks cache */
id|memset
c_func
(paren
id|mbox
comma
l_int|0
comma
l_int|16
)paren
suffix:semicolon
id|raw_mbox
(braket
l_int|0
)braket
op_assign
id|FLUSH_SYSTEM
suffix:semicolon
multiline_comment|/* Issue a blocking (interrupts disabled) command to the card */
id|issue_scb_block
c_func
(paren
id|adapter
comma
id|raw_mbox
)paren
suffix:semicolon
multiline_comment|/* Free our resources */
r_if
c_cond
(paren
id|adapter-&gt;flag
op_amp
id|BOARD_MEMMAP
)paren
(brace
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|adapter-&gt;base
)paren
suffix:semicolon
id|release_mem_region
c_func
(paren
id|adapter-&gt;host-&gt;base
comma
l_int|128
)paren
suffix:semicolon
)brace
r_else
(brace
id|release_region
c_func
(paren
id|adapter-&gt;base
comma
l_int|16
)paren
suffix:semicolon
)brace
id|mega_free_sgl
c_func
(paren
id|adapter
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
r_if
c_cond
(paren
id|adapter-&gt;controller_proc_dir_entry
)paren
(brace
id|remove_proc_entry
c_func
(paren
l_string|&quot;stat&quot;
comma
id|adapter-&gt;controller_proc_dir_entry
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
l_string|&quot;config&quot;
comma
id|adapter-&gt;controller_proc_dir_entry
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
l_string|&quot;mailbox&quot;
comma
id|adapter-&gt;controller_proc_dir_entry
)paren
suffix:semicolon
macro_line|#if MEGA_HAVE_ENH_PROC
id|remove_proc_entry
c_func
(paren
l_string|&quot;rebuild-rate&quot;
comma
id|adapter-&gt;controller_proc_dir_entry
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
l_string|&quot;battery-status&quot;
comma
id|adapter-&gt;controller_proc_dir_entry
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
l_string|&quot;diskdrives-ch0&quot;
comma
id|adapter-&gt;controller_proc_dir_entry
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
l_string|&quot;diskdrives-ch1&quot;
comma
id|adapter-&gt;controller_proc_dir_entry
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
l_string|&quot;diskdrives-ch2&quot;
comma
id|adapter-&gt;controller_proc_dir_entry
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
l_string|&quot;diskdrives-ch3&quot;
comma
id|adapter-&gt;controller_proc_dir_entry
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
l_string|&quot;raiddrives-0-9&quot;
comma
id|adapter-&gt;controller_proc_dir_entry
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
l_string|&quot;raiddrives-10-19&quot;
comma
id|adapter-&gt;controller_proc_dir_entry
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
l_string|&quot;raiddrives-20-29&quot;
comma
id|adapter-&gt;controller_proc_dir_entry
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
l_string|&quot;raiddrives-30-39&quot;
comma
id|adapter-&gt;controller_proc_dir_entry
)paren
suffix:semicolon
macro_line|#endif
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;hba%d&quot;
comma
id|adapter-&gt;host-&gt;host_no
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
id|buf
comma
id|mega_proc_dir_entry
)paren
suffix:semicolon
)brace
macro_line|#endif
id|pci_free_consistent
c_func
(paren
id|adapter-&gt;dev
comma
id|MEGA_BUFFER_SIZE
comma
id|adapter-&gt;mega_buffer
comma
id|adapter-&gt;buf_dma_handle
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|adapter-&gt;scb_list
)paren
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|adapter-&gt;dev
comma
r_sizeof
(paren
id|mbox64_t
)paren
comma
(paren
r_void
op_star
)paren
id|adapter-&gt;una_mbox64
comma
id|adapter-&gt;una_mbox64_dma
)paren
suffix:semicolon
id|hba_count
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|hba_count
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Unregister the character device interface to the driver.&n;&t;&t; */
id|unregister_chrdev
c_func
(paren
id|major
comma
l_string|&quot;megadev&quot;
)paren
suffix:semicolon
id|unregister_reboot_notifier
c_func
(paren
op_amp
id|mega_notifier
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
r_if
c_cond
(paren
id|adapter-&gt;controller_proc_dir_entry
)paren
(brace
id|remove_proc_entry
(paren
l_string|&quot;megaraid&quot;
comma
op_amp
id|proc_root
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n;&t; * Release the controller memory. A word of warning this frees&n;&t; * hostdata and that includes adapter-&gt; so be careful what you&n;&t; * dereference beyond this point&n;&t; */
id|scsi_unregister
c_func
(paren
id|host
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ok.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|mega_free_sgl
id|mega_free_sgl
c_func
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
id|scb_t
op_star
id|scb
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|adapter-&gt;max_cmds
suffix:semicolon
id|i
op_increment
)paren
(brace
id|scb
op_assign
op_amp
id|adapter-&gt;scb_list
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|scb-&gt;sgl64
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|adapter-&gt;dev
comma
r_sizeof
(paren
id|mega_sgl64
)paren
op_star
id|adapter-&gt;sglen
comma
id|scb-&gt;sgl64
comma
id|scb-&gt;sgl_dma_addr
)paren
suffix:semicolon
id|scb-&gt;sgl64
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scb-&gt;pthru
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|adapter-&gt;dev
comma
r_sizeof
(paren
id|mega_passthru
)paren
comma
id|scb-&gt;pthru
comma
id|scb-&gt;pthru_dma_addr
)paren
suffix:semicolon
id|scb-&gt;pthru
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scb-&gt;epthru
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|adapter-&gt;dev
comma
r_sizeof
(paren
id|mega_ext_passthru
)paren
comma
id|scb-&gt;epthru
comma
id|scb-&gt;epthru_dma_addr
)paren
suffix:semicolon
id|scb-&gt;epthru
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Get information about the card/driver&n; */
r_const
r_char
op_star
DECL|function|megaraid_info
id|megaraid_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_static
r_char
id|buffer
(braket
l_int|512
)braket
suffix:semicolon
id|adapter_t
op_star
id|adapter
suffix:semicolon
id|adapter
op_assign
(paren
id|adapter_t
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|sprintf
(paren
id|buffer
comma
l_string|&quot;LSI Logic MegaRAID %s %d commands %d targs %d chans %d luns&quot;
comma
id|adapter-&gt;fw_version
comma
id|adapter-&gt;product_info.max_commands
comma
id|adapter-&gt;host-&gt;max_id
comma
id|adapter-&gt;host-&gt;max_channel
comma
id|adapter-&gt;host-&gt;max_lun
)paren
suffix:semicolon
r_return
id|buffer
suffix:semicolon
)brace
DECL|variable|internal_done_flag
r_volatile
r_static
r_int
id|internal_done_flag
op_assign
l_int|0
suffix:semicolon
DECL|variable|internal_done_errcode
r_volatile
r_static
r_int
id|internal_done_errcode
op_assign
l_int|0
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
(paren
id|internal_wait
)paren
suffix:semicolon
DECL|function|internal_done
r_static
r_void
id|internal_done
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|internal_done_errcode
op_assign
id|cmd-&gt;result
suffix:semicolon
id|internal_done_flag
op_increment
suffix:semicolon
id|wake_up
(paren
op_amp
id|internal_wait
)paren
suffix:semicolon
)brace
multiline_comment|/* shouldn&squot;t be used, but included for completeness */
r_static
r_int
DECL|function|megaraid_command
id|megaraid_command
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|internal_done_flag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Queue command, and wait until it has completed */
id|megaraid_queue
(paren
id|cmd
comma
id|internal_done
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|internal_done_flag
)paren
id|interruptible_sleep_on
(paren
op_amp
id|internal_wait
)paren
suffix:semicolon
r_return
id|internal_done_errcode
suffix:semicolon
)brace
multiline_comment|/*&n; * Abort a previous SCSI request. Only commands on the pending list can be&n; * aborted. All the commands issued to the F/W must complete.&n; */
r_static
r_int
DECL|function|megaraid_abort
id|megaraid_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|adapter_t
op_star
id|adapter
suffix:semicolon
r_int
id|rval
suffix:semicolon
id|adapter
op_assign
(paren
id|adapter_t
op_star
)paren
id|cmd-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
id|rval
op_assign
id|megaraid_abort_and_reset
c_func
(paren
id|adapter
comma
id|cmd
comma
id|SCB_ABORT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This is required here to complete any completed requests&n;&t; * to be communicated over to the mid layer.&n;&t; */
id|mega_rundoneq
c_func
(paren
id|adapter
)paren
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
r_static
r_int
DECL|function|megaraid_reset
id|megaraid_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|adapter_t
op_star
id|adapter
suffix:semicolon
id|megacmd_t
id|mc
suffix:semicolon
r_int
id|rval
suffix:semicolon
id|adapter
op_assign
(paren
id|adapter_t
op_star
)paren
id|cmd-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
macro_line|#if MEGA_HAVE_CLUSTERING
id|mc.cmd
op_assign
id|MEGA_CLUSTER_CMD
suffix:semicolon
id|mc.opcode
op_assign
id|MEGA_RESET_RESERVATIONS
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|adapter-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mega_internal_command
c_func
(paren
id|adapter
comma
id|LOCK_INT
comma
op_amp
id|mc
comma
l_int|NULL
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;megaraid: reservation reset failed.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;megaraid: reservation reset.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|spin_lock_irq
c_func
(paren
op_amp
id|adapter-&gt;lock
)paren
suffix:semicolon
macro_line|#endif
id|rval
op_assign
id|megaraid_abort_and_reset
c_func
(paren
id|adapter
comma
id|cmd
comma
id|SCB_RESET
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This is required here to complete any completed requests&n;&t; * to be communicated over to the mid layer.&n;&t; */
id|mega_rundoneq
c_func
(paren
id|adapter
)paren
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_abort_and_reset()&n; * @adapter - megaraid soft state&n; * @cmd - scsi command to be aborted or reset&n; * @aor - abort or reset flag&n; *&n; * Try to locate the scsi command in the pending queue. If found and is not&n; * issued to the controller, abort/reset it. Otherwise return failure&n; */
r_static
r_int
DECL|function|megaraid_abort_and_reset
id|megaraid_abort_and_reset
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
id|aor
)paren
(brace
r_struct
id|list_head
op_star
id|pos
comma
op_star
id|next
suffix:semicolon
id|scb_t
op_star
id|scb
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;megaraid: %s-%lx cmd=%x &lt;c=%d t=%d l=%d&gt;&bslash;n&quot;
comma
(paren
id|aor
op_eq
id|SCB_ABORT
)paren
ques
c_cond
l_string|&quot;ABORTING&quot;
suffix:colon
l_string|&quot;RESET&quot;
comma
id|cmd-&gt;serial_number
comma
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
comma
id|cmd-&gt;device-&gt;channel
comma
id|cmd-&gt;device-&gt;id
comma
id|cmd-&gt;device-&gt;lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|adapter-&gt;pending_list
)paren
)paren
(brace
r_return
id|FALSE
suffix:semicolon
)brace
id|list_for_each_safe
c_func
(paren
id|pos
comma
id|next
comma
op_amp
id|adapter-&gt;pending_list
)paren
(brace
id|scb
op_assign
id|list_entry
c_func
(paren
id|pos
comma
id|scb_t
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb-&gt;cmd
op_eq
id|cmd
)paren
(brace
multiline_comment|/* Found command */
id|scb-&gt;state
op_or_assign
id|aor
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Check if this command has firmare owenership. If&n;&t;&t;&t; * yes, we cannot reset this command. Whenever, f/w&n;&t;&t;&t; * completes this command, we will return appropriate&n;&t;&t;&t; * status from ISR.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|scb-&gt;state
op_amp
id|SCB_ISSUED
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;megaraid: %s-%lx[%x], fw owner.&bslash;n&quot;
comma
(paren
id|aor
op_eq
id|SCB_ABORT
)paren
ques
c_cond
l_string|&quot;ABORTING&quot;
suffix:colon
l_string|&quot;RESET&quot;
comma
id|cmd-&gt;serial_number
comma
id|scb-&gt;idx
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Not yet issued! Remove from the pending&n;&t;&t;&t;&t; * list&n;&t;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;megaraid: %s-%lx[%x], driver owner.&bslash;n&quot;
comma
(paren
id|aor
op_eq
id|SCB_ABORT
)paren
ques
c_cond
l_string|&quot;ABORTING&quot;
suffix:colon
l_string|&quot;RESET&quot;
comma
id|cmd-&gt;serial_number
comma
id|scb-&gt;idx
)paren
suffix:semicolon
id|mega_free_scb
c_func
(paren
id|adapter
comma
id|scb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aor
op_eq
id|SCB_ABORT
)paren
(brace
id|cmd-&gt;result
op_assign
(paren
id|DID_ABORT
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
r_else
(brace
id|cmd-&gt;result
op_assign
(paren
id|DID_RESET
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
id|list_add_tail
c_func
(paren
id|SCSI_LIST
c_func
(paren
id|cmd
)paren
comma
op_amp
id|adapter-&gt;completed_list
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
)brace
)brace
r_return
id|FALSE
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROC_FS
multiline_comment|/* Following code handles /proc fs  */
DECL|macro|CREATE_READ_PROC
mdefine_line|#define CREATE_READ_PROC(string, func)&t;create_proc_read_entry(string,&t;&bslash;&n;&t;&t;&t;&t;&t;S_IRUSR | S_IFREG,&t;&t;&bslash;&n;&t;&t;&t;&t;&t;controller_proc_dir_entry,&t;&bslash;&n;&t;&t;&t;&t;&t;func, adapter)
multiline_comment|/**&n; * mega_create_proc_entry()&n; * @index - index in soft state array&n; * @parent - parent node for this /proc entry&n; *&n; * Creates /proc entries for our controllers.&n; */
r_static
r_void
DECL|function|mega_create_proc_entry
id|mega_create_proc_entry
c_func
(paren
r_int
id|index
comma
r_struct
id|proc_dir_entry
op_star
id|parent
)paren
(brace
r_struct
id|proc_dir_entry
op_star
id|controller_proc_dir_entry
op_assign
l_int|NULL
suffix:semicolon
id|u8
id|string
(braket
l_int|64
)braket
op_assign
(brace
l_int|0
)brace
suffix:semicolon
id|adapter_t
op_star
id|adapter
op_assign
id|hba_soft_state
(braket
id|index
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|string
comma
l_string|&quot;hba%d&quot;
comma
id|adapter-&gt;host-&gt;host_no
)paren
suffix:semicolon
id|controller_proc_dir_entry
op_assign
id|adapter-&gt;controller_proc_dir_entry
op_assign
id|proc_mkdir
c_func
(paren
id|string
comma
id|parent
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|controller_proc_dir_entry
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;&bslash;nmegaraid: proc_mkdir failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|adapter-&gt;proc_read
op_assign
id|CREATE_READ_PROC
c_func
(paren
l_string|&quot;config&quot;
comma
id|proc_read_config
)paren
suffix:semicolon
id|adapter-&gt;proc_stat
op_assign
id|CREATE_READ_PROC
c_func
(paren
l_string|&quot;stat&quot;
comma
id|proc_read_stat
)paren
suffix:semicolon
id|adapter-&gt;proc_mbox
op_assign
id|CREATE_READ_PROC
c_func
(paren
l_string|&quot;mailbox&quot;
comma
id|proc_read_mbox
)paren
suffix:semicolon
macro_line|#if MEGA_HAVE_ENH_PROC
id|adapter-&gt;proc_rr
op_assign
id|CREATE_READ_PROC
c_func
(paren
l_string|&quot;rebuild-rate&quot;
comma
id|proc_rebuild_rate
)paren
suffix:semicolon
id|adapter-&gt;proc_battery
op_assign
id|CREATE_READ_PROC
c_func
(paren
l_string|&quot;battery-status&quot;
comma
id|proc_battery
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Display each physical drive on its channel&n;&t; */
id|adapter-&gt;proc_pdrvstat
(braket
l_int|0
)braket
op_assign
id|CREATE_READ_PROC
c_func
(paren
l_string|&quot;diskdrives-ch0&quot;
comma
id|proc_pdrv_ch0
)paren
suffix:semicolon
id|adapter-&gt;proc_pdrvstat
(braket
l_int|1
)braket
op_assign
id|CREATE_READ_PROC
c_func
(paren
l_string|&quot;diskdrives-ch1&quot;
comma
id|proc_pdrv_ch1
)paren
suffix:semicolon
id|adapter-&gt;proc_pdrvstat
(braket
l_int|2
)braket
op_assign
id|CREATE_READ_PROC
c_func
(paren
l_string|&quot;diskdrives-ch2&quot;
comma
id|proc_pdrv_ch2
)paren
suffix:semicolon
id|adapter-&gt;proc_pdrvstat
(braket
l_int|3
)braket
op_assign
id|CREATE_READ_PROC
c_func
(paren
l_string|&quot;diskdrives-ch3&quot;
comma
id|proc_pdrv_ch3
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Display a set of up to 10 logical drive through each of following&n;&t; * /proc entries&n;&t; */
id|adapter-&gt;proc_rdrvstat
(braket
l_int|0
)braket
op_assign
id|CREATE_READ_PROC
c_func
(paren
l_string|&quot;raiddrives-0-9&quot;
comma
id|proc_rdrv_10
)paren
suffix:semicolon
id|adapter-&gt;proc_rdrvstat
(braket
l_int|1
)braket
op_assign
id|CREATE_READ_PROC
c_func
(paren
l_string|&quot;raiddrives-10-19&quot;
comma
id|proc_rdrv_20
)paren
suffix:semicolon
id|adapter-&gt;proc_rdrvstat
(braket
l_int|2
)braket
op_assign
id|CREATE_READ_PROC
c_func
(paren
l_string|&quot;raiddrives-20-29&quot;
comma
id|proc_rdrv_30
)paren
suffix:semicolon
id|adapter-&gt;proc_rdrvstat
(braket
l_int|3
)braket
op_assign
id|CREATE_READ_PROC
c_func
(paren
l_string|&quot;raiddrives-30-39&quot;
comma
id|proc_rdrv_40
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/**&n; * proc_read_config()&n; * @page - buffer to write the data in&n; * @start - where the actual data has been written in page&n; * @offset - same meaning as the read system call&n; * @count - same meaning as the read system call&n; * @eof - set if no more data needs to be returned&n; * @data - pointer to our soft state&n; *&n; * Display configuration information about the controller.&n; */
r_static
r_int
DECL|function|proc_read_config
id|proc_read_config
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
id|adapter_t
op_star
id|adapter
op_assign
(paren
id|adapter_t
op_star
)paren
id|data
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;%s&quot;
comma
id|MEGARAID_VERSION
)paren
suffix:semicolon
r_if
c_cond
(paren
id|adapter-&gt;product_info.product_name
(braket
l_int|0
)braket
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|adapter-&gt;product_info.product_name
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;Controller Type: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|adapter-&gt;flag
op_amp
id|BOARD_MEMMAP
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;438/466/467/471/493/518/520/531/532&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;418/428/434&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|adapter-&gt;flag
op_amp
id|BOARD_40LD
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;Controller Supports 40 Logical Drives&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|adapter-&gt;flag
op_amp
id|BOARD_64BIT
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;Controller capable of 64-bit memory addressing&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|adapter-&gt;has_64bit_addr
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;Controller using 64-bit memory addressing&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;Controller is not using 64-bit memory addressing&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;Base = %08lx, Irq = %d, &quot;
comma
id|adapter-&gt;base
comma
id|adapter-&gt;host-&gt;irq
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;Logical Drives = %d, Channels = %d&bslash;n&quot;
comma
id|adapter-&gt;numldrv
comma
id|adapter-&gt;product_info.nchannels
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;Version =%s:%s, DRAM = %dMb&bslash;n&quot;
comma
id|adapter-&gt;fw_version
comma
id|adapter-&gt;bios_version
comma
id|adapter-&gt;product_info.dram_size
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;Controller Queue Depth = %d, Driver Queue Depth = %d&bslash;n&quot;
comma
id|adapter-&gt;product_info.max_commands
comma
id|adapter-&gt;max_cmds
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;support_ext_cdb    = %d&bslash;n&quot;
comma
id|adapter-&gt;support_ext_cdb
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;support_random_del = %d&bslash;n&quot;
comma
id|adapter-&gt;support_random_del
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;boot_ldrv_enabled  = %d&bslash;n&quot;
comma
id|adapter-&gt;boot_ldrv_enabled
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;boot_ldrv          = %d&bslash;n&quot;
comma
id|adapter-&gt;boot_ldrv
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;boot_pdrv_enabled  = %d&bslash;n&quot;
comma
id|adapter-&gt;boot_pdrv_enabled
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;boot_pdrv_ch       = %d&bslash;n&quot;
comma
id|adapter-&gt;boot_pdrv_ch
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;boot_pdrv_tgt      = %d&bslash;n&quot;
comma
id|adapter-&gt;boot_pdrv_tgt
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;quiescent          = %d&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|adapter-&gt;quiescent
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;has_cluster        = %d&bslash;n&quot;
comma
id|adapter-&gt;has_cluster
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;&bslash;nModule Parameters:&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;max_cmd_per_lun    = %d&bslash;n&quot;
comma
id|max_cmd_per_lun
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;max_sectors_per_io = %d&bslash;n&quot;
comma
id|max_sectors_per_io
)paren
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/**&n; * proc_read_stat()&n; * @page - buffer to write the data in&n; * @start - where the actual data has been written in page&n; * @offset - same meaning as the read system call&n; * @count - same meaning as the read system call&n; * @eof - set if no more data needs to be returned&n; * @data - pointer to our soft state&n; *&n; * Diaplay statistical information about the I/O activity.&n; */
r_static
r_int
DECL|function|proc_read_stat
id|proc_read_stat
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
id|adapter_t
op_star
id|adapter
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
id|i
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* avoid compilation warnings */
id|len
op_assign
l_int|0
suffix:semicolon
id|adapter
op_assign
(paren
id|adapter_t
op_star
)paren
id|data
suffix:semicolon
id|len
op_assign
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;Statistical Information for this controller&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;pend_cmds = %d&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|adapter-&gt;pend_cmds
)paren
)paren
suffix:semicolon
macro_line|#if MEGA_HAVE_STATS
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|adapter-&gt;numldrv
suffix:semicolon
id|i
op_increment
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;Logical Drive %d:&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;&bslash;tReads Issued = %lu, Writes Issued = %lu&bslash;n&quot;
comma
id|adapter-&gt;nreads
(braket
id|i
)braket
comma
id|adapter-&gt;nwrites
(braket
id|i
)braket
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;&bslash;tSectors Read = %lu, Sectors Written = %lu&bslash;n&quot;
comma
id|adapter-&gt;nreadblocks
(braket
id|i
)braket
comma
id|adapter-&gt;nwriteblocks
(braket
id|i
)braket
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;&bslash;tRead errors = %lu, Write errors = %lu&bslash;n&bslash;n&quot;
comma
id|adapter-&gt;rd_errors
(braket
id|i
)braket
comma
id|adapter-&gt;wr_errors
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
macro_line|#else
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;IO and error counters not compiled in driver.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/**&n; * proc_read_mbox()&n; * @page - buffer to write the data in&n; * @start - where the actual data has been written in page&n; * @offset - same meaning as the read system call&n; * @count - same meaning as the read system call&n; * @eof - set if no more data needs to be returned&n; * @data - pointer to our soft state&n; *&n; * Display mailbox information for the last command issued. This information&n; * is good for debugging.&n; */
r_static
r_int
DECL|function|proc_read_mbox
id|proc_read_mbox
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
id|adapter_t
op_star
id|adapter
op_assign
(paren
id|adapter_t
op_star
)paren
id|data
suffix:semicolon
r_volatile
id|mbox_t
op_star
id|mbox
op_assign
id|adapter-&gt;mbox
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|len
op_assign
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;Contents of Mail Box Structure&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;  Fw Command   = 0x%02x&bslash;n&quot;
comma
id|mbox-&gt;cmd
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;  Cmd Sequence = 0x%02x&bslash;n&quot;
comma
id|mbox-&gt;cmdid
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;  No of Sectors= %04d&bslash;n&quot;
comma
id|mbox-&gt;numsectors
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;  LBA          = 0x%02x&bslash;n&quot;
comma
id|mbox-&gt;lba
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;  DTA          = 0x%08x&bslash;n&quot;
comma
id|mbox-&gt;xferaddr
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;  Logical Drive= 0x%02x&bslash;n&quot;
comma
id|mbox-&gt;logdrv
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;  No of SG Elmt= 0x%02x&bslash;n&quot;
comma
id|mbox-&gt;numsgelements
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;  Busy         = %01x&bslash;n&quot;
comma
id|mbox-&gt;busy
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;  Status       = 0x%02x&bslash;n&quot;
comma
id|mbox-&gt;status
)paren
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/**&n; * proc_rebuild_rate()&n; * @page - buffer to write the data in&n; * @start - where the actual data has been written in page&n; * @offset - same meaning as the read system call&n; * @count - same meaning as the read system call&n; * @eof - set if no more data needs to be returned&n; * @data - pointer to our soft state&n; *&n; * Display current rebuild rate&n; */
r_static
r_int
DECL|function|proc_rebuild_rate
id|proc_rebuild_rate
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
id|adapter_t
op_star
id|adapter
op_assign
(paren
id|adapter_t
op_star
)paren
id|data
suffix:semicolon
id|dma_addr_t
id|dma_handle
suffix:semicolon
id|caddr_t
id|inquiry
suffix:semicolon
r_struct
id|pci_dev
op_star
id|pdev
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|make_local_pdev
c_func
(paren
id|adapter
comma
op_amp
id|pdev
)paren
op_ne
l_int|0
)paren
(brace
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|inquiry
op_assign
id|mega_allocate_inquiry
c_func
(paren
op_amp
id|dma_handle
comma
id|pdev
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|free_local_pdev
c_func
(paren
id|pdev
)paren
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mega_adapinq
c_func
(paren
id|adapter
comma
id|dma_handle
)paren
op_ne
l_int|0
)paren
(brace
id|len
op_assign
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;Adapter inquiry failed.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;megaraid: inquiry failed.&bslash;n&quot;
)paren
suffix:semicolon
id|mega_free_inquiry
c_func
(paren
id|inquiry
comma
id|dma_handle
comma
id|pdev
)paren
suffix:semicolon
id|free_local_pdev
c_func
(paren
id|pdev
)paren
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|adapter-&gt;flag
op_amp
id|BOARD_40LD
)paren
(brace
id|len
op_assign
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;Rebuild Rate: [%d%%]&bslash;n&quot;
comma
(paren
(paren
id|mega_inquiry3
op_star
)paren
id|inquiry
)paren
op_member_access_from_pointer
id|rebuild_rate
)paren
suffix:semicolon
)brace
r_else
(brace
id|len
op_assign
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;Rebuild Rate: [%d%%]&bslash;n&quot;
comma
(paren
(paren
id|mraid_ext_inquiry
op_star
)paren
id|inquiry
)paren
op_member_access_from_pointer
id|raid_inq.adapter_info.rebuild_rate
)paren
suffix:semicolon
)brace
id|mega_free_inquiry
c_func
(paren
id|inquiry
comma
id|dma_handle
comma
id|pdev
)paren
suffix:semicolon
id|free_local_pdev
c_func
(paren
id|pdev
)paren
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/**&n; * proc_battery()&n; * @page - buffer to write the data in&n; * @start - where the actual data has been written in page&n; * @offset - same meaning as the read system call&n; * @count - same meaning as the read system call&n; * @eof - set if no more data needs to be returned&n; * @data - pointer to our soft state&n; *&n; * Display information about the battery module on the controller.&n; */
r_static
r_int
DECL|function|proc_battery
id|proc_battery
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
id|adapter_t
op_star
id|adapter
op_assign
(paren
id|adapter_t
op_star
)paren
id|data
suffix:semicolon
id|dma_addr_t
id|dma_handle
suffix:semicolon
id|caddr_t
id|inquiry
suffix:semicolon
r_struct
id|pci_dev
op_star
id|pdev
suffix:semicolon
id|u8
id|battery_status
op_assign
l_int|0
suffix:semicolon
r_char
id|str
(braket
l_int|256
)braket
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|make_local_pdev
c_func
(paren
id|adapter
comma
op_amp
id|pdev
)paren
op_ne
l_int|0
)paren
(brace
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|inquiry
op_assign
id|mega_allocate_inquiry
c_func
(paren
op_amp
id|dma_handle
comma
id|pdev
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|free_local_pdev
c_func
(paren
id|pdev
)paren
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mega_adapinq
c_func
(paren
id|adapter
comma
id|dma_handle
)paren
op_ne
l_int|0
)paren
(brace
id|len
op_assign
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;Adapter inquiry failed.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;megaraid: inquiry failed.&bslash;n&quot;
)paren
suffix:semicolon
id|mega_free_inquiry
c_func
(paren
id|inquiry
comma
id|dma_handle
comma
id|pdev
)paren
suffix:semicolon
id|free_local_pdev
c_func
(paren
id|pdev
)paren
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|adapter-&gt;flag
op_amp
id|BOARD_40LD
)paren
(brace
id|battery_status
op_assign
(paren
(paren
id|mega_inquiry3
op_star
)paren
id|inquiry
)paren
op_member_access_from_pointer
id|battery_status
suffix:semicolon
)brace
r_else
(brace
id|battery_status
op_assign
(paren
(paren
id|mraid_ext_inquiry
op_star
)paren
id|inquiry
)paren
op_member_access_from_pointer
id|raid_inq.adapter_info.battery_status
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Decode the battery status&n;&t; */
id|sprintf
c_func
(paren
id|str
comma
l_string|&quot;Battery Status:[%d]&quot;
comma
id|battery_status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|battery_status
op_eq
id|MEGA_BATT_CHARGE_DONE
)paren
(brace
id|strcat
c_func
(paren
id|str
comma
l_string|&quot; Charge Done&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|battery_status
op_amp
id|MEGA_BATT_MODULE_MISSING
)paren
(brace
id|strcat
c_func
(paren
id|str
comma
l_string|&quot; Module Missing&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|battery_status
op_amp
id|MEGA_BATT_LOW_VOLTAGE
)paren
(brace
id|strcat
c_func
(paren
id|str
comma
l_string|&quot; Low Voltage&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|battery_status
op_amp
id|MEGA_BATT_TEMP_HIGH
)paren
(brace
id|strcat
c_func
(paren
id|str
comma
l_string|&quot; Temperature High&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|battery_status
op_amp
id|MEGA_BATT_PACK_MISSING
)paren
(brace
id|strcat
c_func
(paren
id|str
comma
l_string|&quot; Pack Missing&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|battery_status
op_amp
id|MEGA_BATT_CHARGE_INPROG
)paren
(brace
id|strcat
c_func
(paren
id|str
comma
l_string|&quot; Charge In-progress&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|battery_status
op_amp
id|MEGA_BATT_CHARGE_FAIL
)paren
(brace
id|strcat
c_func
(paren
id|str
comma
l_string|&quot; Charge Fail&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|battery_status
op_amp
id|MEGA_BATT_CYCLES_EXCEEDED
)paren
(brace
id|strcat
c_func
(paren
id|str
comma
l_string|&quot; Cycles Exceeded&quot;
)paren
suffix:semicolon
)brace
id|len
op_assign
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|str
)paren
suffix:semicolon
id|mega_free_inquiry
c_func
(paren
id|inquiry
comma
id|dma_handle
comma
id|pdev
)paren
suffix:semicolon
id|free_local_pdev
c_func
(paren
id|pdev
)paren
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/**&n; * proc_pdrv_ch0()&n; * @page - buffer to write the data in&n; * @start - where the actual data has been written in page&n; * @offset - same meaning as the read system call&n; * @count - same meaning as the read system call&n; * @eof - set if no more data needs to be returned&n; * @data - pointer to our soft state&n; *&n; * Display information about the physical drives on physical channel 0.&n; */
r_static
r_int
DECL|function|proc_pdrv_ch0
id|proc_pdrv_ch0
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
id|adapter_t
op_star
id|adapter
op_assign
(paren
id|adapter_t
op_star
)paren
id|data
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
(paren
id|proc_pdrv
c_func
(paren
id|adapter
comma
id|page
comma
l_int|0
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * proc_pdrv_ch1()&n; * @page - buffer to write the data in&n; * @start - where the actual data has been written in page&n; * @offset - same meaning as the read system call&n; * @count - same meaning as the read system call&n; * @eof - set if no more data needs to be returned&n; * @data - pointer to our soft state&n; *&n; * Display information about the physical drives on physical channel 1.&n; */
r_static
r_int
DECL|function|proc_pdrv_ch1
id|proc_pdrv_ch1
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
id|adapter_t
op_star
id|adapter
op_assign
(paren
id|adapter_t
op_star
)paren
id|data
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
(paren
id|proc_pdrv
c_func
(paren
id|adapter
comma
id|page
comma
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * proc_pdrv_ch2()&n; * @page - buffer to write the data in&n; * @start - where the actual data has been written in page&n; * @offset - same meaning as the read system call&n; * @count - same meaning as the read system call&n; * @eof - set if no more data needs to be returned&n; * @data - pointer to our soft state&n; *&n; * Display information about the physical drives on physical channel 2.&n; */
r_static
r_int
DECL|function|proc_pdrv_ch2
id|proc_pdrv_ch2
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
id|adapter_t
op_star
id|adapter
op_assign
(paren
id|adapter_t
op_star
)paren
id|data
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
(paren
id|proc_pdrv
c_func
(paren
id|adapter
comma
id|page
comma
l_int|2
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * proc_pdrv_ch3()&n; * @page - buffer to write the data in&n; * @start - where the actual data has been written in page&n; * @offset - same meaning as the read system call&n; * @count - same meaning as the read system call&n; * @eof - set if no more data needs to be returned&n; * @data - pointer to our soft state&n; *&n; * Display information about the physical drives on physical channel 3.&n; */
r_static
r_int
DECL|function|proc_pdrv_ch3
id|proc_pdrv_ch3
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
id|adapter_t
op_star
id|adapter
op_assign
(paren
id|adapter_t
op_star
)paren
id|data
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
(paren
id|proc_pdrv
c_func
(paren
id|adapter
comma
id|page
comma
l_int|3
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * proc_pdrv()&n; * @page - buffer to write the data in&n; * @adapter - pointer to our soft state&n; *&n; * Display information about the physical drives.&n; */
r_static
r_int
DECL|function|proc_pdrv
id|proc_pdrv
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
r_char
op_star
id|page
comma
r_int
id|channel
)paren
(brace
id|dma_addr_t
id|dma_handle
suffix:semicolon
r_char
op_star
id|scsi_inq
suffix:semicolon
id|dma_addr_t
id|scsi_inq_dma_handle
suffix:semicolon
id|caddr_t
id|inquiry
suffix:semicolon
r_struct
id|pci_dev
op_star
id|pdev
suffix:semicolon
id|u8
op_star
id|pdrv_state
suffix:semicolon
id|u8
id|state
suffix:semicolon
r_int
id|tgt
suffix:semicolon
r_int
id|max_channels
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_char
id|str
(braket
l_int|80
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|make_local_pdev
c_func
(paren
id|adapter
comma
op_amp
id|pdev
)paren
op_ne
l_int|0
)paren
(brace
r_return
id|len
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|inquiry
op_assign
id|mega_allocate_inquiry
c_func
(paren
op_amp
id|dma_handle
comma
id|pdev
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|free_local_pdev
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mega_adapinq
c_func
(paren
id|adapter
comma
id|dma_handle
)paren
op_ne
l_int|0
)paren
(brace
id|len
op_assign
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;Adapter inquiry failed.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;megaraid: inquiry failed.&bslash;n&quot;
)paren
suffix:semicolon
id|mega_free_inquiry
c_func
(paren
id|inquiry
comma
id|dma_handle
comma
id|pdev
)paren
suffix:semicolon
id|free_local_pdev
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
id|scsi_inq
op_assign
id|pci_alloc_consistent
c_func
(paren
id|pdev
comma
l_int|256
comma
op_amp
id|scsi_inq_dma_handle
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scsi_inq
op_eq
l_int|NULL
)paren
(brace
id|len
op_assign
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;memory not available for scsi inq.&bslash;n&quot;
)paren
suffix:semicolon
id|mega_free_inquiry
c_func
(paren
id|inquiry
comma
id|dma_handle
comma
id|pdev
)paren
suffix:semicolon
id|free_local_pdev
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|adapter-&gt;flag
op_amp
id|BOARD_40LD
)paren
(brace
id|pdrv_state
op_assign
(paren
(paren
id|mega_inquiry3
op_star
)paren
id|inquiry
)paren
op_member_access_from_pointer
id|pdrv_state
suffix:semicolon
)brace
r_else
(brace
id|pdrv_state
op_assign
(paren
(paren
id|mraid_ext_inquiry
op_star
)paren
id|inquiry
)paren
op_member_access_from_pointer
id|raid_inq.pdrv_info.pdrv_state
suffix:semicolon
)brace
id|max_channels
op_assign
id|adapter-&gt;product_info.nchannels
suffix:semicolon
r_if
c_cond
(paren
id|channel
op_ge
id|max_channels
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|tgt
op_assign
l_int|0
suffix:semicolon
id|tgt
op_le
id|MAX_TARGET
suffix:semicolon
id|tgt
op_increment
)paren
(brace
id|i
op_assign
id|channel
op_star
l_int|16
op_plus
id|tgt
suffix:semicolon
id|state
op_assign
op_star
(paren
id|pdrv_state
op_plus
id|i
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|state
op_amp
l_int|0x0F
)paren
(brace
r_case
id|PDRV_ONLINE
suffix:colon
id|sprintf
c_func
(paren
id|str
comma
l_string|&quot;Channel:%2d Id:%2d State: Online&quot;
comma
id|channel
comma
id|tgt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PDRV_FAILED
suffix:colon
id|sprintf
c_func
(paren
id|str
comma
l_string|&quot;Channel:%2d Id:%2d State: Failed&quot;
comma
id|channel
comma
id|tgt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PDRV_RBLD
suffix:colon
id|sprintf
c_func
(paren
id|str
comma
l_string|&quot;Channel:%2d Id:%2d State: Rebuild&quot;
comma
id|channel
comma
id|tgt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PDRV_HOTSPARE
suffix:colon
id|sprintf
c_func
(paren
id|str
comma
l_string|&quot;Channel:%2d Id:%2d State: Hot spare&quot;
comma
id|channel
comma
id|tgt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|sprintf
c_func
(paren
id|str
comma
l_string|&quot;Channel:%2d Id:%2d State: Un-configured&quot;
comma
id|channel
comma
id|tgt
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * This interface displays inquiries for disk drives&n;&t;&t; * only. Inquries for logical drives and non-disk&n;&t;&t; * devices are available through /proc/scsi/scsi&n;&t;&t; */
id|memset
c_func
(paren
id|scsi_inq
comma
l_int|0
comma
l_int|256
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mega_internal_dev_inquiry
c_func
(paren
id|adapter
comma
id|channel
comma
id|tgt
comma
id|scsi_inq_dma_handle
)paren
op_logical_or
(paren
id|scsi_inq
(braket
l_int|0
)braket
op_amp
l_int|0x1F
)paren
op_ne
id|TYPE_DISK
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Check for overflow. We print less than 240&n;&t;&t; * characters for inquiry&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|len
op_plus
l_int|240
)paren
op_ge
id|PAGE_SIZE
)paren
(brace
r_break
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;%s.&bslash;n&quot;
comma
id|str
)paren
suffix:semicolon
id|len
op_add_assign
id|mega_print_inquiry
c_func
(paren
id|page
op_plus
id|len
comma
id|scsi_inq
)paren
suffix:semicolon
)brace
id|pci_free_consistent
c_func
(paren
id|pdev
comma
l_int|256
comma
id|scsi_inq
comma
id|scsi_inq_dma_handle
)paren
suffix:semicolon
id|mega_free_inquiry
c_func
(paren
id|inquiry
comma
id|dma_handle
comma
id|pdev
)paren
suffix:semicolon
id|free_local_pdev
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; * Display scsi inquiry&n; */
r_static
r_int
DECL|function|mega_print_inquiry
id|mega_print_inquiry
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
id|scsi_inq
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
id|len
op_assign
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;  Vendor: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|8
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;%c&quot;
comma
id|scsi_inq
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;  Model: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|16
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;%c&quot;
comma
id|scsi_inq
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;  Rev: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|32
suffix:semicolon
id|i
OL
l_int|36
suffix:semicolon
id|i
op_increment
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;%c&quot;
comma
id|scsi_inq
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|i
op_assign
id|scsi_inq
(braket
l_int|0
)braket
op_amp
l_int|0x1f
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;  Type:   %s &quot;
comma
id|i
OL
id|MAX_SCSI_DEVICE_CODE
ques
c_cond
id|scsi_device_types
(braket
id|i
)braket
suffix:colon
l_string|&quot;Unknown          &quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;                 ANSI SCSI revision: %02x&quot;
comma
id|scsi_inq
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scsi_inq
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
op_eq
l_int|1
op_logical_and
(paren
id|scsi_inq
(braket
l_int|3
)braket
op_amp
l_int|0x0f
)paren
op_eq
l_int|1
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot; CCS&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/**&n; * proc_rdrv_10()&n; * @page - buffer to write the data in&n; * @start - where the actual data has been written in page&n; * @offset - same meaning as the read system call&n; * @count - same meaning as the read system call&n; * @eof - set if no more data needs to be returned&n; * @data - pointer to our soft state&n; *&n; * Display real time information about the logical drives 0 through 9.&n; */
r_static
r_int
DECL|function|proc_rdrv_10
id|proc_rdrv_10
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
id|adapter_t
op_star
id|adapter
op_assign
(paren
id|adapter_t
op_star
)paren
id|data
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
(paren
id|proc_rdrv
c_func
(paren
id|adapter
comma
id|page
comma
l_int|0
comma
l_int|9
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * proc_rdrv_20()&n; * @page - buffer to write the data in&n; * @start - where the actual data has been written in page&n; * @offset - same meaning as the read system call&n; * @count - same meaning as the read system call&n; * @eof - set if no more data needs to be returned&n; * @data - pointer to our soft state&n; *&n; * Display real time information about the logical drives 0 through 9.&n; */
r_static
r_int
DECL|function|proc_rdrv_20
id|proc_rdrv_20
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
id|adapter_t
op_star
id|adapter
op_assign
(paren
id|adapter_t
op_star
)paren
id|data
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
(paren
id|proc_rdrv
c_func
(paren
id|adapter
comma
id|page
comma
l_int|10
comma
l_int|19
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * proc_rdrv_30()&n; * @page - buffer to write the data in&n; * @start - where the actual data has been written in page&n; * @offset - same meaning as the read system call&n; * @count - same meaning as the read system call&n; * @eof - set if no more data needs to be returned&n; * @data - pointer to our soft state&n; *&n; * Display real time information about the logical drives 0 through 9.&n; */
r_static
r_int
DECL|function|proc_rdrv_30
id|proc_rdrv_30
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
id|adapter_t
op_star
id|adapter
op_assign
(paren
id|adapter_t
op_star
)paren
id|data
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
(paren
id|proc_rdrv
c_func
(paren
id|adapter
comma
id|page
comma
l_int|20
comma
l_int|29
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * proc_rdrv_40()&n; * @page - buffer to write the data in&n; * @start - where the actual data has been written in page&n; * @offset - same meaning as the read system call&n; * @count - same meaning as the read system call&n; * @eof - set if no more data needs to be returned&n; * @data - pointer to our soft state&n; *&n; * Display real time information about the logical drives 0 through 9.&n; */
r_static
r_int
DECL|function|proc_rdrv_40
id|proc_rdrv_40
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
id|adapter_t
op_star
id|adapter
op_assign
(paren
id|adapter_t
op_star
)paren
id|data
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
(paren
id|proc_rdrv
c_func
(paren
id|adapter
comma
id|page
comma
l_int|30
comma
l_int|39
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * proc_rdrv()&n; * @page - buffer to write the data in&n; * @adapter - pointer to our soft state&n; * @start - starting logical drive to display&n; * @end - ending logical drive to display&n; *&n; * We do not print the inquiry information since its already available through&n; * /proc/scsi/scsi interface&n; */
r_static
r_int
DECL|function|proc_rdrv
id|proc_rdrv
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
r_char
op_star
id|page
comma
r_int
id|start
comma
r_int
id|end
)paren
(brace
id|dma_addr_t
id|dma_handle
suffix:semicolon
id|logdrv_param
op_star
id|lparam
suffix:semicolon
id|megacmd_t
id|mc
suffix:semicolon
r_char
op_star
id|disk_array
suffix:semicolon
id|dma_addr_t
id|disk_array_dma_handle
suffix:semicolon
id|caddr_t
id|inquiry
suffix:semicolon
r_struct
id|pci_dev
op_star
id|pdev
suffix:semicolon
id|u8
op_star
id|rdrv_state
suffix:semicolon
r_int
id|num_ldrv
suffix:semicolon
id|u32
id|array_sz
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|make_local_pdev
c_func
(paren
id|adapter
comma
op_amp
id|pdev
)paren
op_ne
l_int|0
)paren
(brace
r_return
id|len
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|inquiry
op_assign
id|mega_allocate_inquiry
c_func
(paren
op_amp
id|dma_handle
comma
id|pdev
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|free_local_pdev
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mega_adapinq
c_func
(paren
id|adapter
comma
id|dma_handle
)paren
op_ne
l_int|0
)paren
(brace
id|len
op_assign
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;Adapter inquiry failed.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;megaraid: inquiry failed.&bslash;n&quot;
)paren
suffix:semicolon
id|mega_free_inquiry
c_func
(paren
id|inquiry
comma
id|dma_handle
comma
id|pdev
)paren
suffix:semicolon
id|free_local_pdev
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
id|memset
c_func
(paren
op_amp
id|mc
comma
l_int|0
comma
r_sizeof
(paren
id|megacmd_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|adapter-&gt;flag
op_amp
id|BOARD_40LD
)paren
(brace
id|array_sz
op_assign
r_sizeof
(paren
id|disk_array_40ld
)paren
suffix:semicolon
id|rdrv_state
op_assign
(paren
(paren
id|mega_inquiry3
op_star
)paren
id|inquiry
)paren
op_member_access_from_pointer
id|ldrv_state
suffix:semicolon
id|num_ldrv
op_assign
(paren
(paren
id|mega_inquiry3
op_star
)paren
id|inquiry
)paren
op_member_access_from_pointer
id|num_ldrv
suffix:semicolon
)brace
r_else
(brace
id|array_sz
op_assign
r_sizeof
(paren
id|disk_array_8ld
)paren
suffix:semicolon
id|rdrv_state
op_assign
(paren
(paren
id|mraid_ext_inquiry
op_star
)paren
id|inquiry
)paren
op_member_access_from_pointer
id|raid_inq.logdrv_info.ldrv_state
suffix:semicolon
id|num_ldrv
op_assign
(paren
(paren
id|mraid_ext_inquiry
op_star
)paren
id|inquiry
)paren
op_member_access_from_pointer
id|raid_inq.logdrv_info.num_ldrv
suffix:semicolon
)brace
id|disk_array
op_assign
id|pci_alloc_consistent
c_func
(paren
id|pdev
comma
id|array_sz
comma
op_amp
id|disk_array_dma_handle
)paren
suffix:semicolon
r_if
c_cond
(paren
id|disk_array
op_eq
l_int|NULL
)paren
(brace
id|len
op_assign
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;memory not available.&bslash;n&quot;
)paren
suffix:semicolon
id|mega_free_inquiry
c_func
(paren
id|inquiry
comma
id|dma_handle
comma
id|pdev
)paren
suffix:semicolon
id|free_local_pdev
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
id|mc.xferaddr
op_assign
(paren
id|u32
)paren
id|disk_array_dma_handle
suffix:semicolon
r_if
c_cond
(paren
id|adapter-&gt;flag
op_amp
id|BOARD_40LD
)paren
(brace
id|mc.cmd
op_assign
id|FC_NEW_CONFIG
suffix:semicolon
id|mc.opcode
op_assign
id|OP_DCMD_READ_CONFIG
suffix:semicolon
r_if
c_cond
(paren
id|mega_internal_command
c_func
(paren
id|adapter
comma
id|LOCK_INT
comma
op_amp
id|mc
comma
l_int|NULL
)paren
)paren
(brace
id|len
op_assign
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;40LD read config failed.&bslash;n&quot;
)paren
suffix:semicolon
id|mega_free_inquiry
c_func
(paren
id|inquiry
comma
id|dma_handle
comma
id|pdev
)paren
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|pdev
comma
id|array_sz
comma
id|disk_array
comma
id|disk_array_dma_handle
)paren
suffix:semicolon
id|free_local_pdev
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
)brace
r_else
(brace
id|mc.cmd
op_assign
id|NEW_READ_CONFIG_8LD
suffix:semicolon
r_if
c_cond
(paren
id|mega_internal_command
c_func
(paren
id|adapter
comma
id|LOCK_INT
comma
op_amp
id|mc
comma
l_int|NULL
)paren
)paren
(brace
id|mc.cmd
op_assign
id|READ_CONFIG_8LD
suffix:semicolon
r_if
c_cond
(paren
id|mega_internal_command
c_func
(paren
id|adapter
comma
id|LOCK_INT
comma
op_amp
id|mc
comma
l_int|NULL
)paren
)paren
(brace
id|len
op_assign
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;8LD read config failed.&bslash;n&quot;
)paren
suffix:semicolon
id|mega_free_inquiry
c_func
(paren
id|inquiry
comma
id|dma_handle
comma
id|pdev
)paren
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|pdev
comma
id|array_sz
comma
id|disk_array
comma
id|disk_array_dma_handle
)paren
suffix:semicolon
id|free_local_pdev
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
id|start
suffix:semicolon
id|i
OL
(paren
(paren
id|end
op_plus
l_int|1
OL
id|num_ldrv
)paren
ques
c_cond
id|end
op_plus
l_int|1
suffix:colon
id|num_ldrv
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|adapter-&gt;flag
op_amp
id|BOARD_40LD
)paren
(brace
id|lparam
op_assign
op_amp
(paren
(paren
id|disk_array_40ld
op_star
)paren
id|disk_array
)paren
op_member_access_from_pointer
id|ldrv
(braket
id|i
)braket
dot
id|lparam
suffix:semicolon
)brace
r_else
(brace
id|lparam
op_assign
op_amp
(paren
(paren
id|disk_array_8ld
op_star
)paren
id|disk_array
)paren
op_member_access_from_pointer
id|ldrv
(braket
id|i
)braket
dot
id|lparam
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Check for overflow. We print less than 240 characters for&n;&t;&t; * information about each logical drive.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|len
op_plus
l_int|240
)paren
op_ge
id|PAGE_SIZE
)paren
(brace
r_break
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;Logical drive:%2d:, &quot;
comma
id|i
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|rdrv_state
(braket
id|i
)braket
op_amp
l_int|0x0F
)paren
(brace
r_case
id|RDRV_OFFLINE
suffix:colon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;state: offline&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RDRV_DEGRADED
suffix:colon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;state: degraded&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RDRV_OPTIMAL
suffix:colon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;state: optimal&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RDRV_DELETED
suffix:colon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;state: deleted&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;state: unknown&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Check if check consistency or initialization is going on&n;&t;&t; * for this logical drive.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|rdrv_state
(braket
id|i
)braket
op_amp
l_int|0xF0
)paren
op_eq
l_int|0x20
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;, check-consistency in progress&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|rdrv_state
(braket
id|i
)braket
op_amp
l_int|0xF0
)paren
op_eq
l_int|0x10
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;, initialization in progress&quot;
)paren
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;Span depth:%3d, &quot;
comma
id|lparam-&gt;span_depth
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;RAID level:%3d, &quot;
comma
id|lparam-&gt;level
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;Stripe size:%3d, &quot;
comma
id|lparam-&gt;stripe_sz
ques
c_cond
id|lparam-&gt;stripe_sz
op_div
l_int|2
suffix:colon
l_int|128
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;Row size:%3d&bslash;n&quot;
comma
id|lparam-&gt;row_size
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;Read Policy: &quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|lparam-&gt;read_ahead
)paren
(brace
r_case
id|NO_READ_AHEAD
suffix:colon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;No read ahead, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|READ_AHEAD
suffix:colon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;Read ahead, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ADAP_READ_AHEAD
suffix:colon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;Adaptive, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;Write Policy: &quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|lparam-&gt;write_mode
)paren
(brace
r_case
id|WRMODE_WRITE_THRU
suffix:colon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;Write thru, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WRMODE_WRITE_BACK
suffix:colon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;Write back, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;Cache Policy: &quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|lparam-&gt;direct_io
)paren
(brace
r_case
id|CACHED_IO
suffix:colon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;Cached IO&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DIRECT_IO
suffix:colon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|len
comma
l_string|&quot;Direct IO&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|mega_free_inquiry
c_func
(paren
id|inquiry
comma
id|dma_handle
comma
id|pdev
)paren
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|pdev
comma
id|array_sz
comma
id|disk_array
comma
id|disk_array_dma_handle
)paren
suffix:semicolon
id|free_local_pdev
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/**&n; * megaraid_biosparam()&n; *&n; * Return the disk geometry for a particular disk&n; */
r_static
r_int
DECL|function|megaraid_biosparam
id|megaraid_biosparam
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
comma
r_struct
id|block_device
op_star
id|bdev
comma
id|sector_t
id|capacity
comma
r_int
id|geom
(braket
)braket
)paren
(brace
id|adapter_t
op_star
id|adapter
suffix:semicolon
r_int
r_char
op_star
id|bh
suffix:semicolon
r_int
id|heads
suffix:semicolon
r_int
id|sectors
suffix:semicolon
r_int
id|cylinders
suffix:semicolon
r_int
id|rval
suffix:semicolon
multiline_comment|/* Get pointer to host config structure */
id|adapter
op_assign
(paren
id|adapter_t
op_star
)paren
id|sdev-&gt;host-&gt;hostdata
suffix:semicolon
r_if
c_cond
(paren
id|IS_RAID_CH
c_func
(paren
id|adapter
comma
id|sdev-&gt;channel
)paren
)paren
(brace
multiline_comment|/* Default heads (64) &amp; sectors (32) */
id|heads
op_assign
l_int|64
suffix:semicolon
id|sectors
op_assign
l_int|32
suffix:semicolon
id|cylinders
op_assign
(paren
id|ulong
)paren
id|capacity
op_div
(paren
id|heads
op_star
id|sectors
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Handle extended translation size for logical drives&n;&t;&t;&t; * &gt; 1Gb&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|ulong
)paren
id|capacity
op_ge
l_int|0x200000
)paren
(brace
id|heads
op_assign
l_int|255
suffix:semicolon
id|sectors
op_assign
l_int|63
suffix:semicolon
id|cylinders
op_assign
(paren
id|ulong
)paren
id|capacity
op_div
(paren
id|heads
op_star
id|sectors
)paren
suffix:semicolon
)brace
multiline_comment|/* return result */
id|geom
(braket
l_int|0
)braket
op_assign
id|heads
suffix:semicolon
id|geom
(braket
l_int|1
)braket
op_assign
id|sectors
suffix:semicolon
id|geom
(braket
l_int|2
)braket
op_assign
id|cylinders
suffix:semicolon
)brace
r_else
(brace
id|bh
op_assign
id|scsi_bios_ptable
c_func
(paren
id|bdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh
)paren
(brace
id|rval
op_assign
id|scsi_partsize
c_func
(paren
id|bh
comma
id|capacity
comma
op_amp
id|geom
(braket
l_int|2
)braket
comma
op_amp
id|geom
(braket
l_int|0
)braket
comma
op_amp
id|geom
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rval
op_ne
op_minus
l_int|1
)paren
(brace
r_return
id|rval
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;megaraid: invalid partition on this disk on channel %d&bslash;n&quot;
comma
id|sdev-&gt;channel
)paren
suffix:semicolon
multiline_comment|/* Default heads (64) &amp; sectors (32) */
id|heads
op_assign
l_int|64
suffix:semicolon
id|sectors
op_assign
l_int|32
suffix:semicolon
id|cylinders
op_assign
(paren
id|ulong
)paren
id|capacity
op_div
(paren
id|heads
op_star
id|sectors
)paren
suffix:semicolon
multiline_comment|/* Handle extended translation size for logical drives &gt; 1Gb */
r_if
c_cond
(paren
(paren
id|ulong
)paren
id|capacity
op_ge
l_int|0x200000
)paren
(brace
id|heads
op_assign
l_int|255
suffix:semicolon
id|sectors
op_assign
l_int|63
suffix:semicolon
id|cylinders
op_assign
(paren
id|ulong
)paren
id|capacity
op_div
(paren
id|heads
op_star
id|sectors
)paren
suffix:semicolon
)brace
multiline_comment|/* return result */
id|geom
(braket
l_int|0
)braket
op_assign
id|heads
suffix:semicolon
id|geom
(braket
l_int|1
)braket
op_assign
id|sectors
suffix:semicolon
id|geom
(braket
l_int|2
)braket
op_assign
id|cylinders
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_reboot_notify()&n; * @this - unused&n; * @code - shutdown code&n; * @unused - unused&n; *&n; * This routine will be called when the use has done a forced shutdown on the&n; * system. Flush the Adapter and disks cache.&n; */
r_static
r_int
DECL|function|megaraid_reboot_notify
id|megaraid_reboot_notify
(paren
r_struct
id|notifier_block
op_star
id|this
comma
r_int
r_int
id|code
comma
r_void
op_star
id|unused
)paren
(brace
id|adapter_t
op_star
id|adapter
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
id|u8
id|raw_mbox
(braket
l_int|16
)braket
suffix:semicolon
id|mbox_t
op_star
id|mbox
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
multiline_comment|/*&n;&t; * Flush the controller&squot;s cache irrespective of the codes coming down.&n;&t; * SYS_DOWN, SYS_HALT, SYS_RESTART, SYS_POWER_OFF&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|hba_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;megaraid: flushing adapter %d..&quot;
comma
id|i
)paren
suffix:semicolon
id|host
op_assign
id|hba_soft_state
(braket
id|i
)braket
op_member_access_from_pointer
id|host
suffix:semicolon
id|adapter
op_assign
(paren
id|adapter_t
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|mbox
op_assign
(paren
id|mbox_t
op_star
)paren
id|raw_mbox
suffix:semicolon
multiline_comment|/* Flush adapter cache */
id|memset
c_func
(paren
id|mbox
comma
l_int|0
comma
l_int|16
)paren
suffix:semicolon
id|raw_mbox
(braket
l_int|0
)braket
op_assign
id|FLUSH_ADAPTER
suffix:semicolon
id|irq_disable
c_func
(paren
id|adapter
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|adapter-&gt;host-&gt;irq
comma
id|adapter
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Issue a blocking (interrupts disabled) command to&n;&t;&t; * the card&n;&t;&t; */
id|issue_scb_block
c_func
(paren
id|adapter
comma
id|raw_mbox
)paren
suffix:semicolon
multiline_comment|/* Flush disks cache */
id|memset
c_func
(paren
id|mbox
comma
l_int|0
comma
l_int|16
)paren
suffix:semicolon
id|raw_mbox
(braket
l_int|0
)braket
op_assign
id|FLUSH_SYSTEM
suffix:semicolon
id|issue_scb_block
c_func
(paren
id|adapter
comma
id|raw_mbox
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Done.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|adapter-&gt;pend_cmds
)paren
OG
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;megaraid: pending commands!!&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Have a delibrate delay to make sure all the caches are&n;&t; * actually flushed.&n;&t; */
id|printk
c_func
(paren
l_string|&quot;megaraid: cache flush delay: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|10
suffix:semicolon
id|j
op_ge
l_int|0
suffix:semicolon
id|j
op_decrement
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;[%d] &quot;
comma
id|j
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|NOTIFY_DONE
suffix:semicolon
)brace
multiline_comment|/**&n; * mega_init_scb()&n; * @adapter - pointer to our soft state&n; *&n; * Allocate memory for the various pointers in the scb structures:&n; * scatter-gather list pointer, passthru and extended passthru structure&n; * pointers.&n; */
r_static
r_int
DECL|function|mega_init_scb
id|mega_init_scb
c_func
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
id|scb_t
op_star
id|scb
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|adapter-&gt;max_cmds
suffix:semicolon
id|i
op_increment
)paren
(brace
id|scb
op_assign
op_amp
id|adapter-&gt;scb_list
(braket
id|i
)braket
suffix:semicolon
id|scb-&gt;sgl64
op_assign
l_int|NULL
suffix:semicolon
id|scb-&gt;sgl
op_assign
l_int|NULL
suffix:semicolon
id|scb-&gt;pthru
op_assign
l_int|NULL
suffix:semicolon
id|scb-&gt;epthru
op_assign
l_int|NULL
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|adapter-&gt;max_cmds
suffix:semicolon
id|i
op_increment
)paren
(brace
id|scb
op_assign
op_amp
id|adapter-&gt;scb_list
(braket
id|i
)braket
suffix:semicolon
id|scb-&gt;idx
op_assign
id|i
suffix:semicolon
id|scb-&gt;sgl64
op_assign
id|pci_alloc_consistent
c_func
(paren
id|adapter-&gt;dev
comma
r_sizeof
(paren
id|mega_sgl64
)paren
op_star
id|adapter-&gt;sglen
comma
op_amp
id|scb-&gt;sgl_dma_addr
)paren
suffix:semicolon
id|scb-&gt;sgl
op_assign
(paren
id|mega_sglist
op_star
)paren
id|scb-&gt;sgl64
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scb-&gt;sgl
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;RAID: Can&squot;t allocate sglist.&bslash;n&quot;
)paren
suffix:semicolon
id|mega_free_sgl
c_func
(paren
id|adapter
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|scb-&gt;pthru
op_assign
id|pci_alloc_consistent
c_func
(paren
id|adapter-&gt;dev
comma
r_sizeof
(paren
id|mega_passthru
)paren
comma
op_amp
id|scb-&gt;pthru_dma_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scb-&gt;pthru
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;RAID: Can&squot;t allocate passthru.&bslash;n&quot;
)paren
suffix:semicolon
id|mega_free_sgl
c_func
(paren
id|adapter
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|scb-&gt;epthru
op_assign
id|pci_alloc_consistent
c_func
(paren
id|adapter-&gt;dev
comma
r_sizeof
(paren
id|mega_ext_passthru
)paren
comma
op_amp
id|scb-&gt;epthru_dma_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scb-&gt;epthru
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Can&squot;t allocate extended passthru.&bslash;n&quot;
)paren
suffix:semicolon
id|mega_free_sgl
c_func
(paren
id|adapter
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|scb-&gt;dma_type
op_assign
id|MEGA_DMA_TYPE_NONE
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Link to free list&n;&t;&t; * lock not required since we are loading the driver, so no&n;&t;&t; * commands possible right now.&n;&t;&t; */
id|scb-&gt;state
op_assign
id|SCB_FREE
suffix:semicolon
id|scb-&gt;cmd
op_assign
l_int|NULL
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|scb-&gt;list
comma
op_amp
id|adapter-&gt;free_list
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * megadev_open()&n; * @inode - unused&n; * @filep - unused&n; *&n; * Routines for the character/ioctl interface to the driver. Find out if this&n; * is a valid open. If yes, increment the module use count so that it cannot&n; * be unloaded.&n; */
r_static
r_int
DECL|function|megadev_open
id|megadev_open
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filep
)paren
(brace
multiline_comment|/*&n;&t; * Only allow superuser to access private ioctl interface&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
(brace
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * megadev_ioctl()&n; * @inode - Our device inode&n; * @filep - unused&n; * @cmd - ioctl command&n; * @arg - user buffer&n; *&n; * ioctl entry point for our private ioctl interface. We move the data in from&n; * the user space, prepare the command (if necessary, convert the old MIMD&n; * ioctl to new ioctl command), and issue a synchronous command to the&n; * controller.&n; */
r_static
r_int
DECL|function|megadev_ioctl
id|megadev_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filep
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
id|adapter_t
op_star
id|adapter
suffix:semicolon
id|nitioctl_t
id|uioc
suffix:semicolon
r_int
id|adapno
suffix:semicolon
r_int
id|rval
suffix:semicolon
id|mega_passthru
op_star
id|upthru
suffix:semicolon
multiline_comment|/* user address for passthru */
id|mega_passthru
op_star
id|pthru
suffix:semicolon
multiline_comment|/* copy user passthru here */
id|dma_addr_t
id|pthru_dma_hndl
suffix:semicolon
r_void
op_star
id|data
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* data to be transferred */
id|dma_addr_t
id|data_dma_hndl
suffix:semicolon
multiline_comment|/* dma handle for data xfer area */
id|megacmd_t
id|mc
suffix:semicolon
id|megastat_t
op_star
id|ustats
suffix:semicolon
r_int
id|num_ldrv
suffix:semicolon
id|u32
id|uxferaddr
op_assign
l_int|0
suffix:semicolon
r_struct
id|pci_dev
op_star
id|pdev
suffix:semicolon
id|ustats
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* avoid compilation warnings */
id|num_ldrv
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure only USCSICMD are issued through this interface.&n;&t; * MIMD application would still fire different command.&n;&t; */
r_if
c_cond
(paren
(paren
id|_IOC_TYPE
c_func
(paren
id|cmd
)paren
op_ne
id|MEGAIOC_MAGIC
)paren
op_logical_and
(paren
id|cmd
op_ne
id|USCSICMD
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check and convert a possible MIMD command to NIT command.&n;&t; * mega_m_to_n() copies the data from the user space, so we do not&n;&t; * have to do it here.&n;&t; * NOTE: We will need some user address to copyout the data, therefore&n;&t; * the inteface layer will also provide us with the required user&n;&t; * addresses.&n;&t; */
id|memset
c_func
(paren
op_amp
id|uioc
comma
l_int|0
comma
r_sizeof
(paren
id|nitioctl_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rval
op_assign
id|mega_m_to_n
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|uioc
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_return
id|rval
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|uioc.opcode
)paren
(brace
r_case
id|GET_DRIVER_VER
suffix:colon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|driver_ver
comma
(paren
id|u32
op_star
)paren
id|uioc.uioc_uaddr
)paren
)paren
(brace
r_return
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|GET_N_ADAP
suffix:colon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|hba_count
comma
(paren
id|u32
op_star
)paren
id|uioc.uioc_uaddr
)paren
)paren
(brace
r_return
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Shucks. MIMD interface returns a positive value for number&n;&t;&t; * of adapters. TODO: Change it to return 0 when there is no&n;&t;&t; * applicatio using mimd interface.&n;&t;&t; */
r_return
id|hba_count
suffix:semicolon
r_case
id|GET_ADAP_INFO
suffix:colon
multiline_comment|/*&n;&t;&t; * Which adapter&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|adapno
op_assign
id|GETADAP
c_func
(paren
id|uioc.adapno
)paren
)paren
op_ge
id|hba_count
)paren
(brace
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|uioc.uioc_uaddr
comma
id|mcontroller
op_plus
id|adapno
comma
r_sizeof
(paren
r_struct
id|mcontroller
)paren
)paren
)paren
(brace
r_return
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
macro_line|#if MEGA_HAVE_STATS
r_case
id|GET_STATS
suffix:colon
multiline_comment|/*&n;&t;&t; * Which adapter&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|adapno
op_assign
id|GETADAP
c_func
(paren
id|uioc.adapno
)paren
)paren
op_ge
id|hba_count
)paren
(brace
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
id|adapter
op_assign
id|hba_soft_state
(braket
id|adapno
)braket
suffix:semicolon
id|ustats
op_assign
(paren
id|megastat_t
op_star
)paren
id|uioc.uioc_uaddr
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|num_ldrv
comma
op_amp
id|ustats-&gt;num_ldrv
comma
r_sizeof
(paren
r_int
)paren
)paren
)paren
(brace
r_return
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Check for the validity of the logical drive number&n;&t;&t; */
r_if
c_cond
(paren
id|num_ldrv
op_ge
id|MAX_LOGICAL_DRIVES_40LD
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ustats-&gt;nreads
comma
id|adapter-&gt;nreads
comma
id|num_ldrv
op_star
r_sizeof
(paren
id|u32
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ustats-&gt;nreadblocks
comma
id|adapter-&gt;nreadblocks
comma
id|num_ldrv
op_star
r_sizeof
(paren
id|u32
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ustats-&gt;nwrites
comma
id|adapter-&gt;nwrites
comma
id|num_ldrv
op_star
r_sizeof
(paren
id|u32
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ustats-&gt;nwriteblocks
comma
id|adapter-&gt;nwriteblocks
comma
id|num_ldrv
op_star
r_sizeof
(paren
id|u32
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ustats-&gt;rd_errors
comma
id|adapter-&gt;rd_errors
comma
id|num_ldrv
op_star
r_sizeof
(paren
id|u32
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ustats-&gt;wr_errors
comma
id|adapter-&gt;wr_errors
comma
id|num_ldrv
op_star
r_sizeof
(paren
id|u32
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
macro_line|#endif
r_case
id|MBOX_CMD
suffix:colon
multiline_comment|/*&n;&t;&t; * Which adapter&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|adapno
op_assign
id|GETADAP
c_func
(paren
id|uioc.adapno
)paren
)paren
op_ge
id|hba_count
)paren
(brace
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
id|adapter
op_assign
id|hba_soft_state
(braket
id|adapno
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Deletion of logical drive is a special case. The adapter&n;&t;&t; * should be quiescent before this command is issued.&n;&t;&t; */
r_if
c_cond
(paren
id|uioc.uioc_rmbox
(braket
l_int|0
)braket
op_eq
id|FC_DEL_LOGDRV
op_logical_and
id|uioc.uioc_rmbox
(braket
l_int|2
)braket
op_eq
id|OP_DEL_LOGDRV
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Do we support this feature&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|adapter-&gt;support_random_del
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;megaraid: logdrv &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;delete on non-supporting F/W.&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
id|rval
op_assign
id|mega_del_logdrv
c_func
(paren
id|adapter
comma
id|uioc.uioc_rmbox
(braket
l_int|3
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rval
op_eq
l_int|0
)paren
(brace
id|memset
c_func
(paren
op_amp
id|mc
comma
l_int|0
comma
r_sizeof
(paren
id|megacmd_t
)paren
)paren
suffix:semicolon
id|mc.status
op_assign
id|rval
suffix:semicolon
id|rval
op_assign
id|mega_n_to_m
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|mc
)paren
suffix:semicolon
)brace
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * This interface only support the regular passthru commands.&n;&t;&t; * Reject extended passthru and 64-bit passthru&n;&t;&t; */
r_if
c_cond
(paren
id|uioc.uioc_rmbox
(braket
l_int|0
)braket
op_eq
id|MEGA_MBOXCMD_PASSTHRU64
op_logical_or
id|uioc.uioc_rmbox
(braket
l_int|0
)braket
op_eq
id|MEGA_MBOXCMD_EXTPTHRU
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;megaraid: rejected passthru.&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * For all internal commands, the buffer must be allocated in&n;&t;&t; * &lt;4GB address range&n;&t;&t; */
r_if
c_cond
(paren
id|make_local_pdev
c_func
(paren
id|adapter
comma
op_amp
id|pdev
)paren
op_ne
l_int|0
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Is it a passthru command or a DCMD */
r_if
c_cond
(paren
id|uioc.uioc_rmbox
(braket
l_int|0
)braket
op_eq
id|MEGA_MBOXCMD_PASSTHRU
)paren
(brace
multiline_comment|/* Passthru commands */
id|pthru
op_assign
id|pci_alloc_consistent
c_func
(paren
id|pdev
comma
r_sizeof
(paren
id|mega_passthru
)paren
comma
op_amp
id|pthru_dma_hndl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pthru
op_eq
l_int|NULL
)paren
(brace
id|free_local_pdev
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * The user passthru structure&n;&t;&t;&t; */
id|upthru
op_assign
(paren
id|mega_passthru
op_star
)paren
id|MBOX
c_func
(paren
id|uioc
)paren
op_member_access_from_pointer
id|xferaddr
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Copy in the user passthru here.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|pthru
comma
(paren
r_char
op_star
)paren
id|upthru
comma
r_sizeof
(paren
id|mega_passthru
)paren
)paren
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|pdev
comma
r_sizeof
(paren
id|mega_passthru
)paren
comma
id|pthru
comma
id|pthru_dma_hndl
)paren
suffix:semicolon
id|free_local_pdev
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Is there a data transfer&n;&t;&t;&t; */
r_if
c_cond
(paren
id|pthru-&gt;dataxferlen
)paren
(brace
id|data
op_assign
id|pci_alloc_consistent
c_func
(paren
id|pdev
comma
id|pthru-&gt;dataxferlen
comma
op_amp
id|data_dma_hndl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
op_eq
l_int|NULL
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|pdev
comma
r_sizeof
(paren
id|mega_passthru
)paren
comma
id|pthru
comma
id|pthru_dma_hndl
)paren
suffix:semicolon
id|free_local_pdev
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Save the user address and point the kernel&n;&t;&t;&t;&t; * address at just allocated memory&n;&t;&t;&t;&t; */
id|uxferaddr
op_assign
id|pthru-&gt;dataxferaddr
suffix:semicolon
id|pthru-&gt;dataxferaddr
op_assign
id|data_dma_hndl
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Is data coming down-stream&n;&t;&t;&t; */
r_if
c_cond
(paren
id|pthru-&gt;dataxferlen
op_logical_and
(paren
id|uioc.flags
op_amp
id|UIOC_WR
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Get the user data&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|data
comma
(paren
r_char
op_star
)paren
id|uxferaddr
comma
id|pthru-&gt;dataxferlen
)paren
)paren
(brace
id|rval
op_assign
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
r_goto
id|freemem_and_return
suffix:semicolon
)brace
)brace
id|memset
c_func
(paren
op_amp
id|mc
comma
l_int|0
comma
r_sizeof
(paren
id|megacmd_t
)paren
)paren
suffix:semicolon
id|mc.cmd
op_assign
id|MEGA_MBOXCMD_PASSTHRU
suffix:semicolon
id|mc.xferaddr
op_assign
(paren
id|u32
)paren
id|pthru_dma_hndl
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Issue the command&n;&t;&t;&t; */
id|mega_internal_command
c_func
(paren
id|adapter
comma
id|LOCK_INT
comma
op_amp
id|mc
comma
id|pthru
)paren
suffix:semicolon
id|rval
op_assign
id|mega_n_to_m
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|mc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rval
)paren
(brace
r_goto
id|freemem_and_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Is data going up-stream&n;&t;&t;&t; */
r_if
c_cond
(paren
id|pthru-&gt;dataxferlen
op_logical_and
(paren
id|uioc.flags
op_amp
id|UIOC_RD
)paren
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_char
op_star
)paren
id|uxferaddr
comma
id|data
comma
id|pthru-&gt;dataxferlen
)paren
)paren
(brace
id|rval
op_assign
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t; * Send the request sense data also, irrespective of&n;&t;&t;&t; * whether the user has asked for it or not.&n;&t;&t;&t; */
id|copy_to_user
c_func
(paren
id|upthru-&gt;reqsensearea
comma
id|pthru-&gt;reqsensearea
comma
l_int|14
)paren
suffix:semicolon
id|freemem_and_return
suffix:colon
r_if
c_cond
(paren
id|pthru-&gt;dataxferlen
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|pdev
comma
id|pthru-&gt;dataxferlen
comma
id|data
comma
id|data_dma_hndl
)paren
suffix:semicolon
)brace
id|pci_free_consistent
c_func
(paren
id|pdev
comma
r_sizeof
(paren
id|mega_passthru
)paren
comma
id|pthru
comma
id|pthru_dma_hndl
)paren
suffix:semicolon
id|free_local_pdev
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* DCMD commands */
multiline_comment|/*&n;&t;&t;&t; * Is there a data transfer&n;&t;&t;&t; */
r_if
c_cond
(paren
id|uioc.xferlen
)paren
(brace
id|data
op_assign
id|pci_alloc_consistent
c_func
(paren
id|pdev
comma
id|uioc.xferlen
comma
op_amp
id|data_dma_hndl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
op_eq
l_int|NULL
)paren
(brace
id|free_local_pdev
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
id|uxferaddr
op_assign
id|MBOX
c_func
(paren
id|uioc
)paren
op_member_access_from_pointer
id|xferaddr
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Is data coming down-stream&n;&t;&t;&t; */
r_if
c_cond
(paren
id|uioc.xferlen
op_logical_and
(paren
id|uioc.flags
op_amp
id|UIOC_WR
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Get the user data&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|data
comma
(paren
r_char
op_star
)paren
id|uxferaddr
comma
id|uioc.xferlen
)paren
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|pdev
comma
id|uioc.xferlen
comma
id|data
comma
id|data_dma_hndl
)paren
suffix:semicolon
id|free_local_pdev
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
)brace
)brace
id|memcpy
c_func
(paren
op_amp
id|mc
comma
id|MBOX
c_func
(paren
id|uioc
)paren
comma
r_sizeof
(paren
id|megacmd_t
)paren
)paren
suffix:semicolon
id|mc.xferaddr
op_assign
(paren
id|u32
)paren
id|data_dma_hndl
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Issue the command&n;&t;&t;&t; */
id|mega_internal_command
c_func
(paren
id|adapter
comma
id|LOCK_INT
comma
op_amp
id|mc
comma
l_int|NULL
)paren
suffix:semicolon
id|rval
op_assign
id|mega_n_to_m
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|mc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rval
)paren
(brace
r_if
c_cond
(paren
id|uioc.xferlen
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|pdev
comma
id|uioc.xferlen
comma
id|data
comma
id|data_dma_hndl
)paren
suffix:semicolon
)brace
id|free_local_pdev
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Is data going up-stream&n;&t;&t;&t; */
r_if
c_cond
(paren
id|uioc.xferlen
op_logical_and
(paren
id|uioc.flags
op_amp
id|UIOC_RD
)paren
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_char
op_star
)paren
id|uxferaddr
comma
id|data
comma
id|uioc.xferlen
)paren
)paren
(brace
id|rval
op_assign
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|uioc.xferlen
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|pdev
comma
id|uioc.xferlen
comma
id|data
comma
id|data_dma_hndl
)paren
suffix:semicolon
)brace
id|free_local_pdev
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
r_default
suffix:colon
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * mega_m_to_n()&n; * @arg - user address&n; * @uioc - new ioctl structure&n; *&n; * A thin layer to convert older mimd interface ioctl structure to NIT ioctl&n; * structure&n; *&n; * Converts the older mimd ioctl structure to newer NIT structure&n; */
r_static
r_int
DECL|function|mega_m_to_n
id|mega_m_to_n
c_func
(paren
r_void
op_star
id|arg
comma
id|nitioctl_t
op_star
id|uioc
)paren
(brace
r_struct
id|uioctl_t
id|uioc_mimd
suffix:semicolon
r_char
id|signature
(braket
l_int|8
)braket
op_assign
(brace
l_int|0
)brace
suffix:semicolon
id|u8
id|opcode
suffix:semicolon
id|u8
id|subopcode
suffix:semicolon
multiline_comment|/*&n;&t; * check is the application conforms to NIT. We do not have to do much&n;&t; * in that case.&n;&t; * We exploit the fact that the signature is stored in the very&n;&t; * begining of the structure.&n;&t; */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|signature
comma
(paren
r_char
op_star
)paren
id|arg
comma
l_int|7
)paren
)paren
(brace
r_return
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|signature
comma
l_string|&quot;MEGANIT&quot;
comma
l_int|7
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * NOTE NOTE: The nit ioctl is still under flux because of&n;&t;&t; * change of mailbox definition, in HPE. No applications yet&n;&t;&t; * use this interface and let&squot;s not have applications use this&n;&t;&t; * interface till the new specifitions are in place.&n;&t;&t; */
r_return
op_minus
id|EINVAL
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|uioc
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|nitioctl_t
)paren
)paren
)paren
(brace
r_return
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n;&t; * Else assume we have mimd uioctl_t as arg. Convert to nitioctl_t&n;&t; *&n;&t; * Get the user ioctl structure&n;&t; */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|uioc_mimd
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|uioctl_t
)paren
)paren
)paren
(brace
r_return
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get the opcode and subopcode for the commands&n;&t; */
id|opcode
op_assign
id|uioc_mimd.ui.fcs.opcode
suffix:semicolon
id|subopcode
op_assign
id|uioc_mimd.ui.fcs.subopcode
suffix:semicolon
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_case
l_int|0x82
suffix:colon
r_switch
c_cond
(paren
id|subopcode
)paren
(brace
r_case
id|MEGAIOC_QDRVRVER
suffix:colon
multiline_comment|/* Query driver version */
id|uioc-&gt;opcode
op_assign
id|GET_DRIVER_VER
suffix:semicolon
id|uioc-&gt;uioc_uaddr
op_assign
id|uioc_mimd.data
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MEGAIOC_QNADAP
suffix:colon
multiline_comment|/* Get # of adapters */
id|uioc-&gt;opcode
op_assign
id|GET_N_ADAP
suffix:semicolon
id|uioc-&gt;uioc_uaddr
op_assign
id|uioc_mimd.data
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MEGAIOC_QADAPINFO
suffix:colon
multiline_comment|/* Get adapter information */
id|uioc-&gt;opcode
op_assign
id|GET_ADAP_INFO
suffix:semicolon
id|uioc-&gt;adapno
op_assign
id|uioc_mimd.ui.fcs.adapno
suffix:semicolon
id|uioc-&gt;uioc_uaddr
op_assign
id|uioc_mimd.data
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0x81
suffix:colon
id|uioc-&gt;opcode
op_assign
id|MBOX_CMD
suffix:semicolon
id|uioc-&gt;adapno
op_assign
id|uioc_mimd.ui.fcs.adapno
suffix:semicolon
id|memcpy
c_func
(paren
id|uioc-&gt;uioc_rmbox
comma
id|uioc_mimd.mbox
comma
l_int|18
)paren
suffix:semicolon
id|uioc-&gt;xferlen
op_assign
id|uioc_mimd.ui.fcs.length
suffix:semicolon
r_if
c_cond
(paren
id|uioc_mimd.outlen
)paren
(brace
id|uioc-&gt;flags
op_assign
id|UIOC_RD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uioc_mimd.inlen
)paren
(brace
id|uioc-&gt;flags
op_or_assign
id|UIOC_WR
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0x80
suffix:colon
id|uioc-&gt;opcode
op_assign
id|MBOX_CMD
suffix:semicolon
id|uioc-&gt;adapno
op_assign
id|uioc_mimd.ui.fcs.adapno
suffix:semicolon
id|memcpy
c_func
(paren
id|uioc-&gt;uioc_rmbox
comma
id|uioc_mimd.mbox
comma
l_int|18
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Choose the xferlen bigger of input and output data&n;&t;&t; */
id|uioc-&gt;xferlen
op_assign
id|uioc_mimd.outlen
OG
id|uioc_mimd.inlen
ques
c_cond
id|uioc_mimd.outlen
suffix:colon
id|uioc_mimd.inlen
suffix:semicolon
r_if
c_cond
(paren
id|uioc_mimd.outlen
)paren
(brace
id|uioc-&gt;flags
op_assign
id|UIOC_RD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uioc_mimd.inlen
)paren
(brace
id|uioc-&gt;flags
op_or_assign
id|UIOC_WR
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * mega_n_to_m()&n; * @arg - user address&n; * @mc - mailbox command&n; *&n; * Updates the status information to the application, depending on application&n; * conforms to older mimd ioctl interface or newer NIT ioctl interface&n; */
r_static
r_int
DECL|function|mega_n_to_m
id|mega_n_to_m
c_func
(paren
r_void
op_star
id|arg
comma
id|megacmd_t
op_star
id|mc
)paren
(brace
id|nitioctl_t
op_star
id|uiocp
suffix:semicolon
id|megacmd_t
op_star
id|umc
suffix:semicolon
id|mega_passthru
op_star
id|upthru
suffix:semicolon
r_struct
id|uioctl_t
op_star
id|uioc_mimd
suffix:semicolon
r_char
id|signature
(braket
l_int|8
)braket
op_assign
(brace
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n;&t; * check is the application conforms to NIT.&n;&t; */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|signature
comma
(paren
r_char
op_star
)paren
id|arg
comma
l_int|7
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|signature
comma
l_string|&quot;MEGANIT&quot;
comma
l_int|7
)paren
op_eq
l_int|0
)paren
(brace
id|uiocp
op_assign
(paren
id|nitioctl_t
op_star
)paren
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|mc-&gt;status
comma
(paren
id|u8
op_star
)paren
op_amp
id|MBOX_P
c_func
(paren
id|uiocp
)paren
op_member_access_from_pointer
id|status
)paren
)paren
(brace
r_return
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mc-&gt;cmd
op_eq
id|MEGA_MBOXCMD_PASSTHRU
)paren
(brace
id|umc
op_assign
id|MBOX_P
c_func
(paren
id|uiocp
)paren
suffix:semicolon
id|upthru
op_assign
(paren
id|mega_passthru
op_star
)paren
id|umc-&gt;xferaddr
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|mc-&gt;status
comma
(paren
id|u8
op_star
)paren
op_amp
id|upthru-&gt;scsistatus
)paren
)paren
(brace
r_return
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|uioc_mimd
op_assign
(paren
r_struct
id|uioctl_t
op_star
)paren
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|mc-&gt;status
comma
(paren
id|u8
op_star
)paren
op_amp
id|uioc_mimd-&gt;mbox
(braket
l_int|17
)braket
)paren
)paren
(brace
r_return
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mc-&gt;cmd
op_eq
id|MEGA_MBOXCMD_PASSTHRU
)paren
(brace
id|umc
op_assign
(paren
id|megacmd_t
op_star
)paren
id|uioc_mimd-&gt;mbox
suffix:semicolon
id|upthru
op_assign
(paren
id|mega_passthru
op_star
)paren
id|umc-&gt;xferaddr
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|mc-&gt;status
comma
(paren
id|u8
op_star
)paren
op_amp
id|upthru-&gt;scsistatus
)paren
)paren
(brace
r_return
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * MEGARAID &squot;FW&squot; commands.&n; */
multiline_comment|/**&n; * mega_is_bios_enabled()&n; * @adapter - pointer to our soft state&n; *&n; * issue command to find out if the BIOS is enabled for this controller&n; */
r_static
r_int
DECL|function|mega_is_bios_enabled
id|mega_is_bios_enabled
c_func
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
r_int
r_char
id|raw_mbox
(braket
l_int|16
)braket
suffix:semicolon
id|mbox_t
op_star
id|mbox
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|mbox
op_assign
(paren
id|mbox_t
op_star
)paren
id|raw_mbox
suffix:semicolon
id|memset
c_func
(paren
id|mbox
comma
l_int|0
comma
r_sizeof
(paren
id|mbox
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|adapter-&gt;mega_buffer
comma
l_int|0
comma
id|MEGA_BUFFER_SIZE
)paren
suffix:semicolon
id|mbox-&gt;xferaddr
op_assign
(paren
id|u32
)paren
id|adapter-&gt;buf_dma_handle
suffix:semicolon
id|raw_mbox
(braket
l_int|0
)braket
op_assign
id|IS_BIOS_ENABLED
suffix:semicolon
id|raw_mbox
(braket
l_int|2
)braket
op_assign
id|GET_BIOS
suffix:semicolon
id|ret
op_assign
id|issue_scb_block
c_func
(paren
id|adapter
comma
id|raw_mbox
)paren
suffix:semicolon
r_return
op_star
(paren
r_char
op_star
)paren
id|adapter-&gt;mega_buffer
suffix:semicolon
)brace
multiline_comment|/**&n; * mega_enum_raid_scsi()&n; * @adapter - pointer to our soft state&n; *&n; * Find out what channels are RAID/SCSI. This information is used to&n; * differentiate the virtual channels and physical channels and to support&n; * ROMB feature and non-disk devices.&n; */
r_static
r_void
DECL|function|mega_enum_raid_scsi
id|mega_enum_raid_scsi
c_func
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
r_int
r_char
id|raw_mbox
(braket
l_int|16
)braket
suffix:semicolon
id|mbox_t
op_star
id|mbox
suffix:semicolon
r_int
id|i
suffix:semicolon
id|mbox
op_assign
(paren
id|mbox_t
op_star
)paren
id|raw_mbox
suffix:semicolon
id|memset
c_func
(paren
id|mbox
comma
l_int|0
comma
r_sizeof
(paren
id|mbox
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * issue command to find out what channels are raid/scsi&n;&t; */
id|raw_mbox
(braket
l_int|0
)braket
op_assign
id|CHNL_CLASS
suffix:semicolon
id|raw_mbox
(braket
l_int|2
)braket
op_assign
id|GET_CHNL_CLASS
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|adapter-&gt;mega_buffer
comma
l_int|0
comma
id|MEGA_BUFFER_SIZE
)paren
suffix:semicolon
id|mbox-&gt;xferaddr
op_assign
(paren
id|u32
)paren
id|adapter-&gt;buf_dma_handle
suffix:semicolon
multiline_comment|/*&n;&t; * Non-ROMB firware fail this command, so all channels&n;&t; * must be shown RAID&n;&t; */
id|adapter-&gt;mega_ch_class
op_assign
l_int|0xFF
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|issue_scb_block
c_func
(paren
id|adapter
comma
id|raw_mbox
)paren
)paren
(brace
id|adapter-&gt;mega_ch_class
op_assign
op_star
(paren
(paren
r_char
op_star
)paren
id|adapter-&gt;mega_buffer
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|adapter-&gt;product_info.nchannels
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|adapter-&gt;mega_ch_class
op_rshift
id|i
)paren
op_amp
l_int|0x01
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;megaraid: channel[%d] is raid.&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;megaraid: channel[%d] is scsi.&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * mega_get_boot_drv()&n; * @adapter - pointer to our soft state&n; *&n; * Find out which device is the boot device. Note, any logical drive or any&n; * phyical device (e.g., a CDROM) can be designated as a boot device.&n; */
r_static
r_void
DECL|function|mega_get_boot_drv
id|mega_get_boot_drv
c_func
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
r_struct
id|private_bios_data
op_star
id|prv_bios_data
suffix:semicolon
r_int
r_char
id|raw_mbox
(braket
l_int|16
)braket
suffix:semicolon
id|mbox_t
op_star
id|mbox
suffix:semicolon
id|u16
id|cksum
op_assign
l_int|0
suffix:semicolon
id|u8
op_star
id|cksum_p
suffix:semicolon
id|u8
id|boot_pdrv
suffix:semicolon
r_int
id|i
suffix:semicolon
id|mbox
op_assign
(paren
id|mbox_t
op_star
)paren
id|raw_mbox
suffix:semicolon
id|memset
c_func
(paren
id|mbox
comma
l_int|0
comma
r_sizeof
(paren
id|raw_mbox
)paren
)paren
suffix:semicolon
id|raw_mbox
(braket
l_int|0
)braket
op_assign
id|BIOS_PVT_DATA
suffix:semicolon
id|raw_mbox
(braket
l_int|2
)braket
op_assign
id|GET_BIOS_PVT_DATA
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|adapter-&gt;mega_buffer
comma
l_int|0
comma
id|MEGA_BUFFER_SIZE
)paren
suffix:semicolon
id|mbox-&gt;xferaddr
op_assign
(paren
id|u32
)paren
id|adapter-&gt;buf_dma_handle
suffix:semicolon
id|adapter-&gt;boot_ldrv_enabled
op_assign
l_int|0
suffix:semicolon
id|adapter-&gt;boot_ldrv
op_assign
l_int|0
suffix:semicolon
id|adapter-&gt;boot_pdrv_enabled
op_assign
l_int|0
suffix:semicolon
id|adapter-&gt;boot_pdrv_ch
op_assign
l_int|0
suffix:semicolon
id|adapter-&gt;boot_pdrv_tgt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|issue_scb_block
c_func
(paren
id|adapter
comma
id|raw_mbox
)paren
op_eq
l_int|0
)paren
(brace
id|prv_bios_data
op_assign
(paren
r_struct
id|private_bios_data
op_star
)paren
id|adapter-&gt;mega_buffer
suffix:semicolon
id|cksum
op_assign
l_int|0
suffix:semicolon
id|cksum_p
op_assign
(paren
r_char
op_star
)paren
id|prv_bios_data
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|14
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cksum
op_add_assign
(paren
id|u16
)paren
(paren
op_star
id|cksum_p
op_increment
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prv_bios_data-&gt;cksum
op_eq
(paren
id|u16
)paren
(paren
l_int|0
op_minus
id|cksum
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If MSB is set, a physical drive is set as boot&n;&t;&t;&t; * device&n;&t;&t;&t; */
r_if
c_cond
(paren
id|prv_bios_data-&gt;boot_drv
op_amp
l_int|0x80
)paren
(brace
id|adapter-&gt;boot_pdrv_enabled
op_assign
l_int|1
suffix:semicolon
id|boot_pdrv
op_assign
id|prv_bios_data-&gt;boot_drv
op_amp
l_int|0x7F
suffix:semicolon
id|adapter-&gt;boot_pdrv_ch
op_assign
id|boot_pdrv
op_div
l_int|16
suffix:semicolon
id|adapter-&gt;boot_pdrv_tgt
op_assign
id|boot_pdrv
op_mod
l_int|16
suffix:semicolon
)brace
r_else
(brace
id|adapter-&gt;boot_ldrv_enabled
op_assign
l_int|1
suffix:semicolon
id|adapter-&gt;boot_ldrv
op_assign
id|prv_bios_data-&gt;boot_drv
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/**&n; * mega_support_random_del()&n; * @adapter - pointer to our soft state&n; *&n; * Find out if this controller supports random deletion and addition of&n; * logical drives&n; */
r_static
r_int
DECL|function|mega_support_random_del
id|mega_support_random_del
c_func
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
r_int
r_char
id|raw_mbox
(braket
l_int|16
)braket
suffix:semicolon
id|mbox_t
op_star
id|mbox
suffix:semicolon
r_int
id|rval
suffix:semicolon
id|mbox
op_assign
(paren
id|mbox_t
op_star
)paren
id|raw_mbox
suffix:semicolon
id|memset
c_func
(paren
id|mbox
comma
l_int|0
comma
r_sizeof
(paren
id|mbox
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * issue command&n;&t; */
id|raw_mbox
(braket
l_int|0
)braket
op_assign
id|FC_DEL_LOGDRV
suffix:semicolon
id|raw_mbox
(braket
l_int|2
)braket
op_assign
id|OP_SUP_DEL_LOGDRV
suffix:semicolon
id|rval
op_assign
id|issue_scb_block
c_func
(paren
id|adapter
comma
id|raw_mbox
)paren
suffix:semicolon
r_return
op_logical_neg
id|rval
suffix:semicolon
)brace
multiline_comment|/**&n; * mega_support_ext_cdb()&n; * @adapter - pointer to our soft state&n; *&n; * Find out if this firmware support cdblen &gt; 10&n; */
r_static
r_int
DECL|function|mega_support_ext_cdb
id|mega_support_ext_cdb
c_func
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
r_int
r_char
id|raw_mbox
(braket
l_int|16
)braket
suffix:semicolon
id|mbox_t
op_star
id|mbox
suffix:semicolon
r_int
id|rval
suffix:semicolon
id|mbox
op_assign
(paren
id|mbox_t
op_star
)paren
id|raw_mbox
suffix:semicolon
id|memset
c_func
(paren
id|mbox
comma
l_int|0
comma
r_sizeof
(paren
id|mbox
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * issue command to find out if controller supports extended CDBs.&n;&t; */
id|raw_mbox
(braket
l_int|0
)braket
op_assign
l_int|0xA4
suffix:semicolon
id|raw_mbox
(braket
l_int|2
)braket
op_assign
l_int|0x16
suffix:semicolon
id|rval
op_assign
id|issue_scb_block
c_func
(paren
id|adapter
comma
id|raw_mbox
)paren
suffix:semicolon
r_return
op_logical_neg
id|rval
suffix:semicolon
)brace
multiline_comment|/**&n; * mega_del_logdrv()&n; * @adapter - pointer to our soft state&n; * @logdrv - logical drive to be deleted&n; *&n; * Delete the specified logical drive. It is the responsibility of the user&n; * app to let the OS know about this operation.&n; */
r_static
r_int
DECL|function|mega_del_logdrv
id|mega_del_logdrv
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
r_int
id|logdrv
)paren
(brace
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|wq
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|scb_t
op_star
id|scb
suffix:semicolon
r_int
id|rval
suffix:semicolon
multiline_comment|/*&n;&t; * Stop sending commands to the controller, queue them internally.&n;&t; * When deletion is complete, ISR will flush the queue.&n;&t; */
id|atomic_set
c_func
(paren
op_amp
id|adapter-&gt;quiescent
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Wait till all the issued commands are complete and there are no&n;&t; * commands in the pending queue&n;&t; */
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|adapter-&gt;pend_cmds
)paren
OG
l_int|0
op_logical_or
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|adapter-&gt;pending_list
)paren
)paren
(brace
id|sleep_on_timeout
c_func
(paren
op_amp
id|wq
comma
l_int|1
op_star
id|HZ
)paren
suffix:semicolon
multiline_comment|/* sleep for 1s */
)brace
id|rval
op_assign
id|mega_do_del_logdrv
c_func
(paren
id|adapter
comma
id|logdrv
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|adapter-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If delete operation was successful, add 0x80 to the logical drive&n;&t; * ids for commands in the pending queue.&n;&t; */
r_if
c_cond
(paren
id|adapter-&gt;read_ldidmap
)paren
(brace
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|adapter-&gt;pending_list
)paren
(brace
id|scb
op_assign
id|list_entry
c_func
(paren
id|pos
comma
id|scb_t
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb-&gt;pthru-&gt;logdrv
OL
l_int|0x80
)paren
id|scb-&gt;pthru-&gt;logdrv
op_add_assign
l_int|0x80
suffix:semicolon
)brace
)brace
id|atomic_set
c_func
(paren
op_amp
id|adapter-&gt;quiescent
comma
l_int|0
)paren
suffix:semicolon
id|mega_runpendq
c_func
(paren
id|adapter
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|adapter-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
r_static
r_int
DECL|function|mega_do_del_logdrv
id|mega_do_del_logdrv
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
r_int
id|logdrv
)paren
(brace
id|megacmd_t
id|mc
suffix:semicolon
r_int
id|rval
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|mc
comma
l_int|0
comma
r_sizeof
(paren
id|megacmd_t
)paren
)paren
suffix:semicolon
id|mc.cmd
op_assign
id|FC_DEL_LOGDRV
suffix:semicolon
id|mc.opcode
op_assign
id|OP_DEL_LOGDRV
suffix:semicolon
id|mc.subopcode
op_assign
id|logdrv
suffix:semicolon
id|rval
op_assign
id|mega_internal_command
c_func
(paren
id|adapter
comma
id|LOCK_INT
comma
op_amp
id|mc
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* log this event */
r_if
c_cond
(paren
id|rval
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;megaraid: Delete LD-%d failed.&quot;
comma
id|logdrv
)paren
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * After deleting first logical drive, the logical drives must be&n;&t; * addressed by adding 0x80 to the logical drive id.&n;&t; */
id|adapter-&gt;read_ldidmap
op_assign
l_int|1
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/**&n; * mega_get_max_sgl()&n; * @adapter - pointer to our soft state&n; *&n; * Find out the maximum number of scatter-gather elements supported by this&n; * version of the firmware&n; */
r_static
r_void
DECL|function|mega_get_max_sgl
id|mega_get_max_sgl
c_func
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
r_int
r_char
id|raw_mbox
(braket
l_int|16
)braket
suffix:semicolon
id|mbox_t
op_star
id|mbox
suffix:semicolon
id|mbox
op_assign
(paren
id|mbox_t
op_star
)paren
id|raw_mbox
suffix:semicolon
id|memset
c_func
(paren
id|mbox
comma
l_int|0
comma
r_sizeof
(paren
id|raw_mbox
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|adapter-&gt;mega_buffer
comma
l_int|0
comma
id|MEGA_BUFFER_SIZE
)paren
suffix:semicolon
id|mbox-&gt;xferaddr
op_assign
(paren
id|u32
)paren
id|adapter-&gt;buf_dma_handle
suffix:semicolon
id|raw_mbox
(braket
l_int|0
)braket
op_assign
id|MAIN_MISC_OPCODE
suffix:semicolon
id|raw_mbox
(braket
l_int|2
)braket
op_assign
id|GET_MAX_SG_SUPPORT
suffix:semicolon
r_if
c_cond
(paren
id|issue_scb_block
c_func
(paren
id|adapter
comma
id|raw_mbox
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * f/w does not support this command. Choose the default value&n;&t;&t; */
id|adapter-&gt;sglen
op_assign
id|MIN_SGLIST
suffix:semicolon
)brace
r_else
(brace
id|adapter-&gt;sglen
op_assign
op_star
(paren
(paren
r_char
op_star
)paren
id|adapter-&gt;mega_buffer
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Make sure this is not more than the resources we are&n;&t;&t; * planning to allocate&n;&t;&t; */
r_if
c_cond
(paren
id|adapter-&gt;sglen
OG
id|MAX_SGLIST
)paren
id|adapter-&gt;sglen
op_assign
id|MAX_SGLIST
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * mega_support_cluster()&n; * @adapter - pointer to our soft state&n; *&n; * Find out if this firmware support cluster calls.&n; */
r_static
r_int
DECL|function|mega_support_cluster
id|mega_support_cluster
c_func
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
r_int
r_char
id|raw_mbox
(braket
l_int|16
)braket
suffix:semicolon
id|mbox_t
op_star
id|mbox
suffix:semicolon
id|mbox
op_assign
(paren
id|mbox_t
op_star
)paren
id|raw_mbox
suffix:semicolon
id|memset
c_func
(paren
id|mbox
comma
l_int|0
comma
r_sizeof
(paren
id|raw_mbox
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|adapter-&gt;mega_buffer
comma
l_int|0
comma
id|MEGA_BUFFER_SIZE
)paren
suffix:semicolon
id|mbox-&gt;xferaddr
op_assign
(paren
id|u32
)paren
id|adapter-&gt;buf_dma_handle
suffix:semicolon
multiline_comment|/*&n;&t; * Try to get the initiator id. This command will succeed iff the&n;&t; * clustering is available on this HBA.&n;&t; */
id|raw_mbox
(braket
l_int|0
)braket
op_assign
id|MEGA_GET_TARGET_ID
suffix:semicolon
r_if
c_cond
(paren
id|issue_scb_block
c_func
(paren
id|adapter
comma
id|raw_mbox
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Cluster support available. Get the initiator target id.&n;&t;&t; * Tell our id to mid-layer too.&n;&t;&t; */
id|adapter-&gt;this_id
op_assign
op_star
(paren
id|u32
op_star
)paren
id|adapter-&gt;mega_buffer
suffix:semicolon
id|adapter-&gt;host-&gt;this_id
op_assign
id|adapter-&gt;this_id
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * mega_get_ldrv_num()&n; * @adapter - pointer to our soft state&n; * @cmd - scsi mid layer command&n; * @channel - channel on the controller&n; *&n; * Calculate the logical drive number based on the information in scsi command&n; * and the channel number.&n; */
r_static
r_inline
r_int
DECL|function|mega_get_ldrv_num
id|mega_get_ldrv_num
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
id|channel
)paren
(brace
r_int
id|tgt
suffix:semicolon
r_int
id|ldrv_num
suffix:semicolon
id|tgt
op_assign
id|cmd-&gt;device-&gt;id
suffix:semicolon
r_if
c_cond
(paren
id|tgt
OG
id|adapter-&gt;this_id
)paren
id|tgt
op_decrement
suffix:semicolon
multiline_comment|/* we do not get inquires for initiator id */
id|ldrv_num
op_assign
(paren
id|channel
op_star
l_int|15
)paren
op_plus
id|tgt
suffix:semicolon
multiline_comment|/*&n;&t; * If we have a logical drive with boot enabled, project it first&n;&t; */
r_if
c_cond
(paren
id|adapter-&gt;boot_ldrv_enabled
)paren
(brace
r_if
c_cond
(paren
id|ldrv_num
op_eq
l_int|0
)paren
(brace
id|ldrv_num
op_assign
id|adapter-&gt;boot_ldrv
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|ldrv_num
op_le
id|adapter-&gt;boot_ldrv
)paren
(brace
id|ldrv_num
op_decrement
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * If &quot;delete logical drive&quot; feature is enabled on this controller.&n;&t; * Do only if at least one delete logical drive operation was done.&n;&t; *&n;&t; * Also, after logical drive deletion, instead of logical drive number,&n;&t; * the value returned should be 0x80+logical drive id.&n;&t; *&n;&t; * These is valid only for IO commands.&n;&t; */
r_if
c_cond
(paren
id|adapter-&gt;support_random_del
op_logical_and
id|adapter-&gt;read_ldidmap
)paren
r_switch
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
id|READ_6
suffix:colon
multiline_comment|/* fall through */
r_case
id|WRITE_6
suffix:colon
multiline_comment|/* fall through */
r_case
id|READ_10
suffix:colon
multiline_comment|/* fall through */
r_case
id|WRITE_10
suffix:colon
id|ldrv_num
op_add_assign
l_int|0x80
suffix:semicolon
)brace
r_return
id|ldrv_num
suffix:semicolon
)brace
multiline_comment|/**&n; * mega_adapinq()&n; * @adapter - pointer to our soft state&n; * @dma_handle - DMA address of the buffer&n; *&n; * Issue internal comamnds while interrupts are available.&n; * We only issue direct mailbox commands from within the driver. ioctl()&n; * interface using these routines can issue passthru commands.&n; */
r_static
r_int
DECL|function|mega_adapinq
id|mega_adapinq
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
id|dma_addr_t
id|dma_handle
)paren
(brace
id|megacmd_t
id|mc
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|mc
comma
l_int|0
comma
r_sizeof
(paren
id|megacmd_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|adapter-&gt;flag
op_amp
id|BOARD_40LD
)paren
(brace
id|mc.cmd
op_assign
id|FC_NEW_CONFIG
suffix:semicolon
id|mc.opcode
op_assign
id|NC_SUBOP_ENQUIRY3
suffix:semicolon
id|mc.subopcode
op_assign
id|ENQ3_GET_SOLICITED_FULL
suffix:semicolon
)brace
r_else
(brace
id|mc.cmd
op_assign
id|MEGA_MBOXCMD_ADPEXTINQ
suffix:semicolon
)brace
id|mc.xferaddr
op_assign
(paren
id|u32
)paren
id|dma_handle
suffix:semicolon
r_if
c_cond
(paren
id|mega_internal_command
c_func
(paren
id|adapter
comma
id|LOCK_INT
comma
op_amp
id|mc
comma
l_int|NULL
)paren
op_ne
l_int|0
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * mega_allocate_inquiry()&n; * @dma_handle - handle returned for dma address&n; * @pdev - handle to pci device&n; *&n; * allocates memory for inquiry structure&n; */
r_static
r_inline
id|caddr_t
DECL|function|mega_allocate_inquiry
id|mega_allocate_inquiry
c_func
(paren
id|dma_addr_t
op_star
id|dma_handle
comma
r_struct
id|pci_dev
op_star
id|pdev
)paren
(brace
r_return
id|pci_alloc_consistent
c_func
(paren
id|pdev
comma
r_sizeof
(paren
id|mega_inquiry3
)paren
comma
id|dma_handle
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|mega_free_inquiry
id|mega_free_inquiry
c_func
(paren
id|caddr_t
id|inquiry
comma
id|dma_addr_t
id|dma_handle
comma
r_struct
id|pci_dev
op_star
id|pdev
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|pdev
comma
r_sizeof
(paren
id|mega_inquiry3
)paren
comma
id|inquiry
comma
id|dma_handle
)paren
suffix:semicolon
)brace
multiline_comment|/** mega_internal_dev_inquiry()&n; * @adapter - pointer to our soft state&n; * @ch - channel for this device&n; * @tgt - ID of this device&n; * @buf_dma_handle - DMA address of the buffer&n; *&n; * Issue the scsi inquiry for the specified device.&n; */
r_static
r_int
DECL|function|mega_internal_dev_inquiry
id|mega_internal_dev_inquiry
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
id|u8
id|ch
comma
id|u8
id|tgt
comma
id|dma_addr_t
id|buf_dma_handle
)paren
(brace
id|mega_passthru
op_star
id|pthru
suffix:semicolon
id|dma_addr_t
id|pthru_dma_handle
suffix:semicolon
id|megacmd_t
id|mc
suffix:semicolon
r_int
id|rval
suffix:semicolon
r_struct
id|pci_dev
op_star
id|pdev
suffix:semicolon
multiline_comment|/*&n;&t; * For all internal commands, the buffer must be allocated in &lt;4GB&n;&t; * address range&n;&t; */
r_if
c_cond
(paren
id|make_local_pdev
c_func
(paren
id|adapter
comma
op_amp
id|pdev
)paren
op_ne
l_int|0
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|pthru
op_assign
id|pci_alloc_consistent
c_func
(paren
id|pdev
comma
r_sizeof
(paren
id|mega_passthru
)paren
comma
op_amp
id|pthru_dma_handle
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pthru
op_eq
l_int|NULL
)paren
(brace
id|free_local_pdev
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|pthru-&gt;timeout
op_assign
l_int|2
suffix:semicolon
id|pthru-&gt;ars
op_assign
l_int|1
suffix:semicolon
id|pthru-&gt;reqsenselen
op_assign
l_int|14
suffix:semicolon
id|pthru-&gt;islogical
op_assign
l_int|0
suffix:semicolon
id|pthru-&gt;channel
op_assign
(paren
id|adapter-&gt;flag
op_amp
id|BOARD_40LD
)paren
ques
c_cond
l_int|0
suffix:colon
id|ch
suffix:semicolon
id|pthru-&gt;target
op_assign
(paren
id|adapter-&gt;flag
op_amp
id|BOARD_40LD
)paren
ques
c_cond
(paren
id|ch
op_lshift
l_int|4
)paren
op_or
id|tgt
suffix:colon
id|tgt
suffix:semicolon
id|pthru-&gt;cdblen
op_assign
l_int|6
suffix:semicolon
id|pthru-&gt;cdb
(braket
l_int|0
)braket
op_assign
id|INQUIRY
suffix:semicolon
id|pthru-&gt;cdb
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|pthru-&gt;cdb
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|pthru-&gt;cdb
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|pthru-&gt;cdb
(braket
l_int|4
)braket
op_assign
l_int|255
suffix:semicolon
id|pthru-&gt;cdb
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|pthru-&gt;dataxferaddr
op_assign
(paren
id|u32
)paren
id|buf_dma_handle
suffix:semicolon
id|pthru-&gt;dataxferlen
op_assign
l_int|256
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|mc
comma
l_int|0
comma
r_sizeof
(paren
id|megacmd_t
)paren
)paren
suffix:semicolon
id|mc.cmd
op_assign
id|MEGA_MBOXCMD_PASSTHRU
suffix:semicolon
id|mc.xferaddr
op_assign
(paren
id|u32
)paren
id|pthru_dma_handle
suffix:semicolon
id|rval
op_assign
id|mega_internal_command
c_func
(paren
id|adapter
comma
id|LOCK_INT
comma
op_amp
id|mc
comma
id|pthru
)paren
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|pdev
comma
r_sizeof
(paren
id|mega_passthru
)paren
comma
id|pthru
comma
id|pthru_dma_handle
)paren
suffix:semicolon
id|free_local_pdev
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/**&n; * mega_internal_command()&n; * @adapter - pointer to our soft state&n; * @ls - the scope of the exclusion lock.&n; * @mc - the mailbox command&n; * @pthru - Passthru structure for DCDB commands&n; *&n; * Issue the internal commands in interrupt mode.&n; * The last argument is the address of the passthru structure if the command&n; * to be fired is a passthru command&n; *&n; * lockscope specifies whether the caller has already acquired the lock. Of&n; * course, the caller must know which lock we are talking about.&n; *&n; * Note: parameter &squot;pthru&squot; is null for non-passthru commands.&n; */
r_static
r_int
DECL|function|mega_internal_command
id|mega_internal_command
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
id|lockscope_t
id|ls
comma
id|megacmd_t
op_star
id|mc
comma
id|mega_passthru
op_star
id|pthru
)paren
(brace
id|Scsi_Cmnd
op_star
id|scmd
suffix:semicolon
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
id|scb_t
op_star
id|scb
suffix:semicolon
r_int
id|rval
suffix:semicolon
multiline_comment|/*&n;&t; * The internal commands share one command id and hence are&n;&t; * serialized. This is so because we want to reserve maximum number of&n;&t; * available command ids for the I/O commands.&n;&t; */
id|down
c_func
(paren
op_amp
id|adapter-&gt;int_mtx
)paren
suffix:semicolon
id|scb
op_assign
op_amp
id|adapter-&gt;int_scb
suffix:semicolon
id|memset
c_func
(paren
id|scb
comma
l_int|0
comma
r_sizeof
(paren
id|scb_t
)paren
)paren
suffix:semicolon
id|scmd
op_assign
op_amp
id|adapter-&gt;int_scmd
suffix:semicolon
id|memset
c_func
(paren
id|scmd
comma
l_int|0
comma
r_sizeof
(paren
id|Scsi_Cmnd
)paren
)paren
suffix:semicolon
id|sdev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|scsi_device
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|sdev
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|scsi_device
)paren
)paren
suffix:semicolon
id|scmd-&gt;device
op_assign
id|sdev
suffix:semicolon
id|scmd-&gt;device-&gt;host
op_assign
id|adapter-&gt;host
suffix:semicolon
id|scmd-&gt;buffer
op_assign
(paren
r_void
op_star
)paren
id|scb
suffix:semicolon
id|scmd-&gt;cmnd
(braket
l_int|0
)braket
op_assign
id|MEGA_INTERNAL_CMD
suffix:semicolon
id|scb-&gt;state
op_or_assign
id|SCB_ACTIVE
suffix:semicolon
id|scb-&gt;cmd
op_assign
id|scmd
suffix:semicolon
id|memcpy
c_func
(paren
id|scb-&gt;raw_mbox
comma
id|mc
comma
r_sizeof
(paren
id|megacmd_t
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Is it a passthru command&n;&t; */
r_if
c_cond
(paren
id|mc-&gt;cmd
op_eq
id|MEGA_MBOXCMD_PASSTHRU
)paren
(brace
id|scb-&gt;pthru
op_assign
id|pthru
suffix:semicolon
)brace
id|scb-&gt;idx
op_assign
id|CMDID_INT_CMDS
suffix:semicolon
id|scmd-&gt;state
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Get the lock only if the caller has not acquired it already&n;&t; */
r_if
c_cond
(paren
id|ls
op_eq
id|LOCK_INT
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|adapter-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|megaraid_queue
c_func
(paren
id|scmd
comma
id|mega_internal_done
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ls
op_eq
id|LOCK_INT
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|adapter-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Wait till this command finishes. Do not use&n;&t; * wait_event_interruptible(). It causes panic if CTRL-C is hit when&n;&t; * dumping e.g., physical disk information through /proc interface.&n;&t; */
macro_line|#if 0
id|wait_event_interruptible
c_func
(paren
id|adapter-&gt;int_waitq
comma
id|scmd-&gt;state
)paren
suffix:semicolon
macro_line|#endif
id|wait_event
c_func
(paren
id|adapter-&gt;int_waitq
comma
id|scmd-&gt;state
)paren
suffix:semicolon
id|rval
op_assign
id|scmd-&gt;result
suffix:semicolon
id|mc-&gt;status
op_assign
id|scmd-&gt;result
suffix:semicolon
id|kfree
c_func
(paren
id|sdev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Print a debug message for all failed commands. Applications can use&n;&t; * this information.&n;&t; */
r_if
c_cond
(paren
id|scmd-&gt;result
op_logical_and
id|trace_level
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;megaraid: cmd [%x, %x, %x] status:[%x]&bslash;n&quot;
comma
id|mc-&gt;cmd
comma
id|mc-&gt;opcode
comma
id|mc-&gt;subopcode
comma
id|scmd-&gt;result
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|adapter-&gt;int_mtx
)paren
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/**&n; * mega_internal_done()&n; * @scmd - internal scsi command&n; *&n; * Callback routine for internal commands.&n; */
r_static
r_void
DECL|function|mega_internal_done
id|mega_internal_done
c_func
(paren
id|Scsi_Cmnd
op_star
id|scmd
)paren
(brace
id|adapter_t
op_star
id|adapter
suffix:semicolon
id|adapter
op_assign
(paren
id|adapter_t
op_star
)paren
id|scmd-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
id|scmd-&gt;state
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* thread waiting for its command to complete */
multiline_comment|/*&n;&t; * See comment in mega_internal_command() routine for&n;&t; * wait_event_interruptible()&n;&t; */
macro_line|#if 0
id|wake_up_interruptible
c_func
(paren
op_amp
id|adapter-&gt;int_waitq
)paren
suffix:semicolon
macro_line|#endif
id|wake_up
c_func
(paren
op_amp
id|adapter-&gt;int_waitq
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|make_local_pdev
id|make_local_pdev
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
r_struct
id|pci_dev
op_star
op_star
id|pdev
)paren
(brace
op_star
id|pdev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pci_dev
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pdev
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|memcpy
c_func
(paren
op_star
id|pdev
comma
id|adapter-&gt;dev
comma
r_sizeof
(paren
r_struct
id|pci_dev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_set_dma_mask
c_func
(paren
op_star
id|pdev
comma
l_int|0xffffffff
)paren
op_ne
l_int|0
)paren
(brace
id|kfree
c_func
(paren
op_star
id|pdev
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|free_local_pdev
id|free_local_pdev
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
)paren
(brace
id|kfree
c_func
(paren
id|pdev
)paren
suffix:semicolon
)brace
DECL|variable|driver_template
r_static
id|Scsi_Host_Template
id|driver_template
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;MegaRAID&quot;
comma
dot
id|proc_info
op_assign
id|megaraid_proc_info
comma
dot
id|detect
op_assign
id|megaraid_detect
comma
dot
id|release
op_assign
id|megaraid_release
comma
dot
id|info
op_assign
id|megaraid_info
comma
dot
id|command
op_assign
id|megaraid_command
comma
dot
id|queuecommand
op_assign
id|megaraid_queue
comma
dot
id|bios_param
op_assign
id|megaraid_biosparam
comma
dot
id|max_sectors
op_assign
id|MAX_SECTORS_PER_IO
comma
dot
id|can_queue
op_assign
id|MAX_COMMANDS
comma
dot
id|this_id
op_assign
id|DEFAULT_INITIATOR_ID
comma
dot
id|sg_tablesize
op_assign
id|MAX_SGLIST
comma
dot
id|cmd_per_lun
op_assign
id|DEF_CMD_PER_LUN
comma
dot
id|use_clustering
op_assign
id|ENABLE_CLUSTERING
comma
dot
id|eh_abort_handler
op_assign
id|megaraid_abort
comma
dot
id|eh_device_reset_handler
op_assign
id|megaraid_reset
comma
dot
id|eh_bus_reset_handler
op_assign
id|megaraid_reset
comma
dot
id|eh_host_reset_handler
op_assign
id|megaraid_reset
comma
dot
id|highmem_io
op_assign
l_int|1
comma
)brace
suffix:semicolon
macro_line|#include &quot;scsi_module.c&quot;
multiline_comment|/* vi: set ts=8 sw=8 tw=78: */
eof
