multiline_comment|/*----------------------------------------------------------------*/
multiline_comment|/*&n;   Qlogic linux driver - work in progress. No Warranty express or implied.&n;   Use at your own risk.  Support Tort Reform so you won&squot;t have to read all&n;   these silly disclaimers.&n;&n;   Copyright 1994, Tom Zerucha.   &n;   tz@execpc.com&n;   &n;   Additional Code, and much appreciated help by&n;   Michael A. Griffith&n;   grif@cs.ucr.edu&n;&n;   Thanks to Eric Youngdale and Dave Hinds for loadable module and PCMCIA&n;   help respectively, and for suffering through my foolishness during the&n;   debugging process.&n;&n;   Reference Qlogic FAS408 Technical Manual, 53408-510-00A, May 10, 1994&n;   (you can reference it, but it is incomplete and inaccurate in places)&n;&n;   Version 0.46 1/30/97 - kernel 1.2.0+&n;&n;   Functions as standalone, loadable, and PCMCIA driver, the latter from&n;   Dave Hinds&squot; PCMCIA package.&n;   &n;   Cleaned up 26/10/2002 by Alan Cox &lt;alan@redhat.com&gt; as part of the 2.5&n;   SCSI driver cleanup and audit. This driver still needs work on the&n;   following&n;   &t;-&t;Non terminating hardware waits&n;   &t;-&t;Some layering violations with its pcmcia stub&n;&n;   Redistributable under terms of the GNU General Public License&n;&n;   For the avoidance of doubt the &quot;preferred form&quot; of this code is one which&n;   is in an open non patent encumbered format. Where cryptographic key signing&n;   forms part of the process of creating an executable the information&n;   including keys needed to generate an equivalently functional executable&n;   are deemed to be part of the source code.&n;&n;*/
multiline_comment|/*----------------------------------------------------------------*/
multiline_comment|/* Configuration */
multiline_comment|/* Set the following to 2 to use normal interrupt (active high/totempole-&n;   tristate), otherwise use 0 (REQUIRED FOR PCMCIA) for active low, open&n;   drain */
DECL|macro|QL_INT_ACTIVE_HIGH
mdefine_line|#define QL_INT_ACTIVE_HIGH 2
multiline_comment|/* Set the following to max out the speed of the PIO PseudoDMA transfers,&n;   again, 0 tends to be slower, but more stable.  */
DECL|macro|QL_TURBO_PDMA
mdefine_line|#define QL_TURBO_PDMA 1
multiline_comment|/* This should be 1 to enable parity detection */
DECL|macro|QL_ENABLE_PARITY
mdefine_line|#define QL_ENABLE_PARITY 1
multiline_comment|/* This will reset all devices when the driver is initialized (during bootup).&n;   The other linux drivers don&squot;t do this, but the DOS drivers do, and after&n;   using DOS or some kind of crash or lockup this will bring things back&n;   without requiring a cold boot.  It does take some time to recover from a&n;   reset, so it is slower, and I have seen timeouts so that devices weren&squot;t&n;   recognized when this was set. */
DECL|macro|QL_RESET_AT_START
mdefine_line|#define QL_RESET_AT_START 0
multiline_comment|/* crystal frequency in megahertz (for offset 5 and 9)&n;   Please set this for your card.  Most Qlogic cards are 40 Mhz.  The&n;   Control Concepts ISA (not VLB) is 24 Mhz */
DECL|macro|XTALFREQ
mdefine_line|#define XTALFREQ&t;40
multiline_comment|/**********/
multiline_comment|/* DANGER! modify these at your own risk */
multiline_comment|/* SLOWCABLE can usually be reset to zero if you have a clean setup and&n;   proper termination.  The rest are for synchronous transfers and other&n;   advanced features if your device can transfer faster than 5Mb/sec.&n;   If you are really curious, email me for a quick howto until I have&n;   something official */
multiline_comment|/**********/
multiline_comment|/*****/
multiline_comment|/* config register 1 (offset 8) options */
multiline_comment|/* This needs to be set to 1 if your cabling is long or noisy */
DECL|macro|SLOWCABLE
mdefine_line|#define SLOWCABLE 1
multiline_comment|/*****/
multiline_comment|/* offset 0xc */
multiline_comment|/* This will set fast (10Mhz) synchronous timing when set to 1&n;   For this to have an effect, FASTCLK must also be 1 */
DECL|macro|FASTSCSI
mdefine_line|#define FASTSCSI 0
multiline_comment|/* This when set to 1 will set a faster sync transfer rate */
DECL|macro|FASTCLK
mdefine_line|#define FASTCLK 0&t;/*(XTALFREQ&gt;25?1:0)*/
multiline_comment|/*****/
multiline_comment|/* offset 6 */
multiline_comment|/* This is the sync transfer divisor, XTALFREQ/X will be the maximum&n;   achievable data rate (assuming the rest of the system is capable&n;   and set properly) */
DECL|macro|SYNCXFRPD
mdefine_line|#define SYNCXFRPD 5&t;/*(XTALFREQ/5)*/
multiline_comment|/*****/
multiline_comment|/* offset 7 */
multiline_comment|/* This is the count of how many synchronous transfers can take place&n;&t;i.e. how many reqs can occur before an ack is given.&n;&t;The maximum value for this is 15, the upper bits can modify&n;&t;REQ/ACK assertion and deassertion during synchronous transfers&n;&t;If this is 0, the bus will only transfer asynchronously */
DECL|macro|SYNCOFFST
mdefine_line|#define SYNCOFFST 0
multiline_comment|/* for the curious, bits 7&amp;6 control the deassertion delay in 1/2 cycles&n;&t;of the 40Mhz clock. If FASTCLK is 1, specifying 01 (1/2) will&n;&t;cause the deassertion to be early by 1/2 clock.  Bits 5&amp;4 control&n;&t;the assertion delay, also in 1/2 clocks (FASTCLK is ignored here). */
multiline_comment|/*----------------------------------------------------------------*/
macro_line|#ifdef PCMCIA
DECL|macro|QL_INT_ACTIVE_HIGH
macro_line|#undef QL_INT_ACTIVE_HIGH
DECL|macro|QL_INT_ACTIVE_HIGH
mdefine_line|#define QL_INT_ACTIVE_HIGH 0
macro_line|#endif
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;&t;&t;/* to get disk capacity */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;qlogicfas.h&quot;
multiline_comment|/*----------------------------------------------------------------*/
multiline_comment|/* driver state info, local to driver */
DECL|variable|qlcfg5
r_static
r_int
id|qlcfg5
op_assign
(paren
id|XTALFREQ
op_lshift
l_int|5
)paren
suffix:semicolon
multiline_comment|/* 15625/512 */
DECL|variable|qlcfg6
r_static
r_int
id|qlcfg6
op_assign
id|SYNCXFRPD
suffix:semicolon
DECL|variable|qlcfg7
r_static
r_int
id|qlcfg7
op_assign
id|SYNCOFFST
suffix:semicolon
DECL|variable|qlcfg8
r_static
r_int
id|qlcfg8
op_assign
(paren
id|SLOWCABLE
op_lshift
l_int|7
)paren
op_or
(paren
id|QL_ENABLE_PARITY
op_lshift
l_int|4
)paren
suffix:semicolon
DECL|variable|qlcfg9
r_static
r_int
id|qlcfg9
op_assign
(paren
(paren
id|XTALFREQ
op_plus
l_int|4
)paren
op_div
l_int|5
)paren
suffix:semicolon
DECL|variable|qlcfgc
r_static
r_int
id|qlcfgc
op_assign
(paren
id|FASTCLK
op_lshift
l_int|3
)paren
op_or
(paren
id|FASTSCSI
op_lshift
l_int|4
)paren
suffix:semicolon
DECL|variable|qlogicfas_name
r_static
r_char
id|qlogicfas_name
(braket
)braket
op_assign
l_string|&quot;qlogicfas&quot;
suffix:semicolon
r_int
id|qlogicfas_queuecommand
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
suffix:semicolon
multiline_comment|/*----------------------------------------------------------------*/
multiline_comment|/* The qlogic card uses two register maps - These macros select which one */
DECL|macro|REG0
mdefine_line|#define REG0 ( outb( inb( qbase + 0xd ) &amp; 0x7f , qbase + 0xd ), outb( 4 , qbase + 0xd ))
DECL|macro|REG1
mdefine_line|#define REG1 ( outb( inb( qbase + 0xd ) | 0x80 , qbase + 0xd ), outb( 0xb4 | QL_INT_ACTIVE_HIGH , qbase + 0xd ))
multiline_comment|/* following is watchdog timeout in microseconds */
DECL|macro|WATCHDOG
mdefine_line|#define WATCHDOG 5000000
multiline_comment|/*----------------------------------------------------------------*/
multiline_comment|/* the following will set the monitor border color (useful to find&n;   where something crashed or gets stuck at and as a simple profiler) */
macro_line|#if 0
mdefine_line|#define rtrc(i) {inb(0x3da);outb(0x31,0x3c0);outb((i),0x3c0);}
macro_line|#else
DECL|macro|rtrc
mdefine_line|#define rtrc(i) {}
macro_line|#endif
multiline_comment|/*----------------------------------------------------------------*/
multiline_comment|/* local functions */
multiline_comment|/*----------------------------------------------------------------*/
multiline_comment|/* error recovery - reset everything */
DECL|function|ql_zap
r_static
r_void
id|ql_zap
c_func
(paren
id|qlogicfas_priv_t
id|priv
)paren
(brace
r_int
id|x
suffix:semicolon
r_int
id|qbase
op_assign
id|priv-&gt;qbase
suffix:semicolon
id|x
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|0xd
)paren
suffix:semicolon
id|REG0
suffix:semicolon
id|outb
c_func
(paren
l_int|3
comma
id|qbase
op_plus
l_int|3
)paren
suffix:semicolon
multiline_comment|/* reset SCSI */
id|outb
c_func
(paren
l_int|2
comma
id|qbase
op_plus
l_int|3
)paren
suffix:semicolon
multiline_comment|/* reset chip */
r_if
c_cond
(paren
id|x
op_amp
l_int|0x80
)paren
id|REG1
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Do a pseudo-dma tranfer&n; */
DECL|function|ql_pdma
r_static
r_int
id|ql_pdma
c_func
(paren
id|qlogicfas_priv_t
id|priv
comma
r_int
id|phase
comma
r_char
op_star
id|request
comma
r_int
id|reqlen
)paren
(brace
r_int
id|j
suffix:semicolon
r_int
id|qbase
op_assign
id|priv-&gt;qbase
suffix:semicolon
id|j
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|phase
op_amp
l_int|1
)paren
(brace
multiline_comment|/* in */
macro_line|#if QL_TURBO_PDMA
id|rtrc
c_func
(paren
l_int|4
)paren
multiline_comment|/* empty fifo in large chunks */
r_if
c_cond
(paren
id|reqlen
op_ge
l_int|128
op_logical_and
(paren
id|inb
c_func
(paren
id|qbase
op_plus
l_int|8
)paren
op_amp
l_int|2
)paren
)paren
(brace
multiline_comment|/* full */
id|insl
c_func
(paren
id|qbase
op_plus
l_int|4
comma
id|request
comma
l_int|32
)paren
suffix:semicolon
id|reqlen
op_sub_assign
l_int|128
suffix:semicolon
id|request
op_add_assign
l_int|128
suffix:semicolon
)brace
r_while
c_loop
(paren
id|reqlen
op_ge
l_int|84
op_logical_and
op_logical_neg
(paren
id|j
op_amp
l_int|0xc0
)paren
)paren
multiline_comment|/* 2/3 */
r_if
c_cond
(paren
(paren
id|j
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|8
)paren
)paren
op_amp
l_int|4
)paren
(brace
id|insl
c_func
(paren
id|qbase
op_plus
l_int|4
comma
id|request
comma
l_int|21
)paren
suffix:semicolon
id|reqlen
op_sub_assign
l_int|84
suffix:semicolon
id|request
op_add_assign
l_int|84
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reqlen
op_ge
l_int|44
op_logical_and
(paren
id|inb
c_func
(paren
id|qbase
op_plus
l_int|8
)paren
op_amp
l_int|8
)paren
)paren
(brace
multiline_comment|/* 1/3 */
id|insl
c_func
(paren
id|qbase
op_plus
l_int|4
comma
id|request
comma
l_int|11
)paren
suffix:semicolon
id|reqlen
op_sub_assign
l_int|44
suffix:semicolon
id|request
op_add_assign
l_int|44
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* until both empty and int (or until reclen is 0) */
id|rtrc
c_func
(paren
l_int|7
)paren
id|j
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|reqlen
op_logical_and
op_logical_neg
(paren
(paren
id|j
op_amp
l_int|0x10
)paren
op_logical_and
(paren
id|j
op_amp
l_int|0xc0
)paren
)paren
)paren
(brace
multiline_comment|/* while bytes to receive and not empty */
id|j
op_and_assign
l_int|0xc0
suffix:semicolon
r_while
c_loop
(paren
id|reqlen
op_logical_and
op_logical_neg
(paren
(paren
id|j
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|8
)paren
)paren
op_amp
l_int|0x10
)paren
)paren
(brace
op_star
id|request
op_increment
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|4
)paren
suffix:semicolon
id|reqlen
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|j
op_amp
l_int|0x10
)paren
id|j
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|8
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* out */
macro_line|#if QL_TURBO_PDMA
id|rtrc
c_func
(paren
l_int|4
)paren
r_if
c_cond
(paren
id|reqlen
op_ge
l_int|128
op_logical_and
id|inb
c_func
(paren
id|qbase
op_plus
l_int|8
)paren
op_amp
l_int|0x10
)paren
(brace
multiline_comment|/* empty */
id|outsl
c_func
(paren
id|qbase
op_plus
l_int|4
comma
id|request
comma
l_int|32
)paren
suffix:semicolon
id|reqlen
op_sub_assign
l_int|128
suffix:semicolon
id|request
op_add_assign
l_int|128
suffix:semicolon
)brace
r_while
c_loop
(paren
id|reqlen
op_ge
l_int|84
op_logical_and
op_logical_neg
(paren
id|j
op_amp
l_int|0xc0
)paren
)paren
multiline_comment|/* 1/3 */
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|j
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|8
)paren
)paren
op_amp
l_int|8
)paren
)paren
(brace
id|outsl
c_func
(paren
id|qbase
op_plus
l_int|4
comma
id|request
comma
l_int|21
)paren
suffix:semicolon
id|reqlen
op_sub_assign
l_int|84
suffix:semicolon
id|request
op_add_assign
l_int|84
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reqlen
op_ge
l_int|40
op_logical_and
op_logical_neg
(paren
id|inb
c_func
(paren
id|qbase
op_plus
l_int|8
)paren
op_amp
l_int|4
)paren
)paren
(brace
multiline_comment|/* 2/3 */
id|outsl
c_func
(paren
id|qbase
op_plus
l_int|4
comma
id|request
comma
l_int|10
)paren
suffix:semicolon
id|reqlen
op_sub_assign
l_int|40
suffix:semicolon
id|request
op_add_assign
l_int|40
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* until full and int (or until reclen is 0) */
id|rtrc
c_func
(paren
l_int|7
)paren
id|j
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|reqlen
op_logical_and
op_logical_neg
(paren
(paren
id|j
op_amp
l_int|2
)paren
op_logical_and
(paren
id|j
op_amp
l_int|0xc0
)paren
)paren
)paren
(brace
multiline_comment|/* while bytes to send and not full */
r_while
c_loop
(paren
id|reqlen
op_logical_and
op_logical_neg
(paren
(paren
id|j
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|8
)paren
)paren
op_amp
l_int|2
)paren
)paren
(brace
id|outb
c_func
(paren
op_star
id|request
op_increment
comma
id|qbase
op_plus
l_int|4
)paren
suffix:semicolon
id|reqlen
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|j
op_amp
l_int|2
)paren
id|j
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|8
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* maybe return reqlen */
r_return
id|inb
c_func
(paren
id|qbase
op_plus
l_int|8
)paren
op_amp
l_int|0xc0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Wait for interrupt flag (polled - not real hardware interrupt) &n; */
DECL|function|ql_wai
r_static
r_int
id|ql_wai
c_func
(paren
id|qlogicfas_priv_t
id|priv
)paren
(brace
r_int
id|k
suffix:semicolon
r_int
id|qbase
op_assign
id|priv-&gt;qbase
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
id|k
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
id|jiffies
op_plus
id|WATCHDOG
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|i
)paren
op_logical_and
op_logical_neg
id|priv-&gt;qabort
op_logical_and
op_logical_neg
(paren
(paren
id|k
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|4
)paren
)paren
op_amp
l_int|0xe0
)paren
)paren
(brace
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|time_after_eq
c_func
(paren
id|jiffies
comma
id|i
)paren
)paren
r_return
(paren
id|DID_TIME_OUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;qabort
)paren
r_return
(paren
id|priv-&gt;qabort
op_eq
l_int|1
ques
c_cond
id|DID_ABORT
suffix:colon
id|DID_RESET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|k
op_amp
l_int|0x60
)paren
id|ql_zap
c_func
(paren
id|priv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|k
op_amp
l_int|0x20
)paren
r_return
(paren
id|DID_PARITY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|k
op_amp
l_int|0x40
)paren
r_return
(paren
id|DID_ERROR
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Initiate scsi command - queueing handler &n; *&t;caller must hold host lock&n; */
DECL|function|ql_icmd
r_static
r_void
id|ql_icmd
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|qlogicfas_priv_t
id|priv
op_assign
(paren
id|qlogicfas_priv_t
)paren
op_amp
(paren
id|cmd-&gt;device-&gt;host-&gt;hostdata
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_int
id|qbase
op_assign
id|priv-&gt;qbase
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
id|priv-&gt;qabort
op_assign
l_int|0
suffix:semicolon
id|REG0
suffix:semicolon
multiline_comment|/* clearing of interrupts and the fifo is needed */
id|inb
c_func
(paren
id|qbase
op_plus
l_int|5
)paren
suffix:semicolon
multiline_comment|/* clear interrupts */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|qbase
op_plus
l_int|5
)paren
)paren
multiline_comment|/* if still interrupting */
id|outb
c_func
(paren
l_int|2
comma
id|qbase
op_plus
l_int|3
)paren
suffix:semicolon
multiline_comment|/* reset chip */
r_else
r_if
c_cond
(paren
id|inb
c_func
(paren
id|qbase
op_plus
l_int|7
)paren
op_amp
l_int|0x1f
)paren
id|outb
c_func
(paren
l_int|1
comma
id|qbase
op_plus
l_int|3
)paren
suffix:semicolon
multiline_comment|/* clear fifo */
r_while
c_loop
(paren
id|inb
c_func
(paren
id|qbase
op_plus
l_int|5
)paren
)paren
suffix:semicolon
multiline_comment|/* clear ints */
id|REG1
suffix:semicolon
id|outb
c_func
(paren
l_int|1
comma
id|qbase
op_plus
l_int|8
)paren
suffix:semicolon
multiline_comment|/* set for PIO pseudo DMA */
id|outb
c_func
(paren
l_int|0
comma
id|qbase
op_plus
l_int|0xb
)paren
suffix:semicolon
multiline_comment|/* disable ints */
id|inb
c_func
(paren
id|qbase
op_plus
l_int|8
)paren
suffix:semicolon
multiline_comment|/* clear int bits */
id|REG0
suffix:semicolon
id|outb
c_func
(paren
l_int|0x40
comma
id|qbase
op_plus
l_int|0xb
)paren
suffix:semicolon
multiline_comment|/* enable features */
multiline_comment|/* configurables */
id|outb
c_func
(paren
id|qlcfgc
comma
id|qbase
op_plus
l_int|0xc
)paren
suffix:semicolon
multiline_comment|/* config: no reset interrupt, (initiator) bus id */
id|outb
c_func
(paren
l_int|0x40
op_or
id|qlcfg8
op_or
id|priv-&gt;qinitid
comma
id|qbase
op_plus
l_int|8
)paren
suffix:semicolon
id|outb
c_func
(paren
id|qlcfg7
comma
id|qbase
op_plus
l_int|7
)paren
suffix:semicolon
id|outb
c_func
(paren
id|qlcfg6
comma
id|qbase
op_plus
l_int|6
)paren
suffix:semicolon
multiline_comment|/**/
id|outb
c_func
(paren
id|qlcfg5
comma
id|qbase
op_plus
l_int|5
)paren
suffix:semicolon
multiline_comment|/* select timer */
id|outb
c_func
(paren
id|qlcfg9
op_amp
l_int|7
comma
id|qbase
op_plus
l_int|9
)paren
suffix:semicolon
multiline_comment|/* prescaler */
multiline_comment|/*&t;outb(0x99, qbase + 5);&t;*/
id|outb
c_func
(paren
id|cmd-&gt;device-&gt;id
comma
id|qbase
op_plus
l_int|4
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cmd-&gt;cmd_len
suffix:semicolon
id|i
op_increment
)paren
id|outb
c_func
(paren
id|cmd-&gt;cmnd
(braket
id|i
)braket
comma
id|qbase
op_plus
l_int|2
)paren
suffix:semicolon
id|priv-&gt;qlcmd
op_assign
id|cmd
suffix:semicolon
id|outb
c_func
(paren
l_int|0x41
comma
id|qbase
op_plus
l_int|3
)paren
suffix:semicolon
multiline_comment|/* select and send command */
)brace
multiline_comment|/*&n; *&t;Process scsi command - usually after interrupt &n; */
DECL|function|ql_pcmd
r_static
r_int
r_int
id|ql_pcmd
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
r_int
id|i
comma
id|j
suffix:semicolon
r_int
r_int
id|k
suffix:semicolon
r_int
r_int
id|result
suffix:semicolon
multiline_comment|/* ultimate return result */
r_int
r_int
id|status
suffix:semicolon
multiline_comment|/* scsi returned status */
r_int
r_int
id|message
suffix:semicolon
multiline_comment|/* scsi returned message */
r_int
r_int
id|phase
suffix:semicolon
multiline_comment|/* recorded scsi phase */
r_int
r_int
id|reqlen
suffix:semicolon
multiline_comment|/* total length of transfer */
r_struct
id|scatterlist
op_star
id|sglist
suffix:semicolon
multiline_comment|/* scatter-gather list pointer */
r_int
r_int
id|sgcount
suffix:semicolon
multiline_comment|/* sg counter */
r_char
op_star
id|buf
suffix:semicolon
id|qlogicfas_priv_t
id|priv
op_assign
(paren
id|qlogicfas_priv_t
)paren
op_amp
(paren
id|cmd-&gt;device-&gt;host-&gt;hostdata
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_int
id|qbase
op_assign
id|priv-&gt;qbase
suffix:semicolon
id|rtrc
c_func
(paren
l_int|1
)paren
id|j
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|6
)paren
suffix:semicolon
id|i
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|5
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0x20
)paren
(brace
r_return
(paren
id|DID_NO_CONNECT
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
id|i
op_or_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|5
)paren
suffix:semicolon
multiline_comment|/* the 0x10 bit can be set after the 0x08 */
r_if
c_cond
(paren
id|i
op_ne
l_int|0x18
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Ql:Bad Interrupt status:%02x&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|ql_zap
c_func
(paren
id|priv
)paren
suffix:semicolon
r_return
(paren
id|DID_BAD_INTR
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
id|j
op_and_assign
l_int|7
suffix:semicolon
multiline_comment|/* j = inb( qbase + 7 ) &gt;&gt; 5; */
multiline_comment|/* correct status is supposed to be step 4 */
multiline_comment|/* it sometimes returns step 3 but with 0 bytes left to send */
multiline_comment|/* We can try stuffing the FIFO with the max each time, but we will get a&n;&t;   sequence of 3 if any bytes are left (but we do flush the FIFO anyway */
r_if
c_cond
(paren
id|j
op_ne
l_int|3
op_logical_and
id|j
op_ne
l_int|4
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Ql:Bad sequence for command %d, int %02X, cmdleft = %d&bslash;n&quot;
comma
id|j
comma
id|i
comma
id|inb
c_func
(paren
id|qbase
op_plus
l_int|7
)paren
op_amp
l_int|0x1f
)paren
suffix:semicolon
id|ql_zap
c_func
(paren
id|priv
)paren
suffix:semicolon
r_return
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
id|result
op_assign
id|DID_OK
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|qbase
op_plus
l_int|7
)paren
op_amp
l_int|0x1f
)paren
multiline_comment|/* if some bytes in fifo */
id|outb
c_func
(paren
l_int|1
comma
id|qbase
op_plus
l_int|3
)paren
suffix:semicolon
multiline_comment|/* clear fifo */
multiline_comment|/* note that request_bufflen is the total xfer size when sg is used */
id|reqlen
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
multiline_comment|/* note that it won&squot;t work if transfers &gt; 16M are requested */
r_if
c_cond
(paren
id|reqlen
op_logical_and
op_logical_neg
(paren
(paren
id|phase
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|4
)paren
)paren
op_amp
l_int|6
)paren
)paren
(brace
multiline_comment|/* data phase */
id|rtrc
c_func
(paren
l_int|2
)paren
id|outb
c_func
(paren
id|reqlen
comma
id|qbase
)paren
suffix:semicolon
multiline_comment|/* low-mid xfer cnt */
id|outb
c_func
(paren
id|reqlen
op_rshift
l_int|8
comma
id|qbase
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* low-mid xfer cnt */
id|outb
c_func
(paren
id|reqlen
op_rshift
l_int|16
comma
id|qbase
op_plus
l_int|0xe
)paren
suffix:semicolon
multiline_comment|/* high xfer cnt */
id|outb
c_func
(paren
l_int|0x90
comma
id|qbase
op_plus
l_int|3
)paren
suffix:semicolon
multiline_comment|/* command do xfer */
multiline_comment|/* PIO pseudo DMA to buffer or sglist */
id|REG1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmd-&gt;use_sg
)paren
id|ql_pdma
c_func
(paren
id|priv
comma
id|phase
comma
id|cmd-&gt;request_buffer
comma
id|cmd-&gt;request_bufflen
)paren
suffix:semicolon
r_else
(brace
id|sgcount
op_assign
id|cmd-&gt;use_sg
suffix:semicolon
id|sglist
op_assign
id|cmd-&gt;request_buffer
suffix:semicolon
r_while
c_loop
(paren
id|sgcount
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|priv-&gt;qabort
)paren
(brace
id|REG0
suffix:semicolon
r_return
(paren
(paren
id|priv-&gt;qabort
op_eq
l_int|1
ques
c_cond
id|DID_ABORT
suffix:colon
id|DID_RESET
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
id|buf
op_assign
id|page_address
c_func
(paren
id|sglist-&gt;page
)paren
op_plus
id|sglist-&gt;offset
suffix:semicolon
r_if
c_cond
(paren
id|ql_pdma
c_func
(paren
id|priv
comma
id|phase
comma
id|buf
comma
id|sglist-&gt;length
)paren
)paren
r_break
suffix:semicolon
id|sglist
op_increment
suffix:semicolon
)brace
)brace
id|REG0
suffix:semicolon
id|rtrc
c_func
(paren
l_int|2
)paren
multiline_comment|/*&n;&t;&t; *&t;Wait for irq (split into second state of irq handler&n;&t;&t; *&t;if this can take time) &n;&t;&t; */
r_if
c_cond
(paren
(paren
id|k
op_assign
id|ql_wai
c_func
(paren
id|priv
)paren
)paren
)paren
r_return
(paren
id|k
op_lshift
l_int|16
)paren
suffix:semicolon
id|k
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|5
)paren
suffix:semicolon
multiline_comment|/* should be 0x10, bus service */
)brace
multiline_comment|/*&n;&t; *&t;Enter Status (and Message In) Phase &n;&t; */
id|k
op_assign
id|jiffies
op_plus
id|WATCHDOG
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|k
)paren
op_logical_and
op_logical_neg
id|priv-&gt;qabort
op_logical_and
op_logical_neg
(paren
id|inb
c_func
(paren
id|qbase
op_plus
l_int|4
)paren
op_amp
l_int|6
)paren
)paren
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait for status phase */
r_if
c_cond
(paren
id|time_after_eq
c_func
(paren
id|jiffies
comma
id|k
)paren
)paren
(brace
id|ql_zap
c_func
(paren
id|priv
)paren
suffix:semicolon
r_return
(paren
id|DID_TIME_OUT
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
multiline_comment|/* FIXME: timeout ?? */
r_while
c_loop
(paren
id|inb
c_func
(paren
id|qbase
op_plus
l_int|5
)paren
)paren
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* clear pending ints */
r_if
c_cond
(paren
id|priv-&gt;qabort
)paren
r_return
(paren
(paren
id|priv-&gt;qabort
op_eq
l_int|1
ques
c_cond
id|DID_ABORT
suffix:colon
id|DID_RESET
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x11
comma
id|qbase
op_plus
l_int|3
)paren
suffix:semicolon
multiline_comment|/* get status and message */
r_if
c_cond
(paren
(paren
id|k
op_assign
id|ql_wai
c_func
(paren
id|priv
)paren
)paren
)paren
r_return
(paren
id|k
op_lshift
l_int|16
)paren
suffix:semicolon
id|i
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|5
)paren
suffix:semicolon
multiline_comment|/* get chip irq stat */
id|j
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|7
)paren
op_amp
l_int|0x1f
suffix:semicolon
multiline_comment|/* and bytes rec&squot;d */
id|status
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|2
)paren
suffix:semicolon
id|message
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|2
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Should get function complete int if Status and message, else &n;&t; *&t;bus serv if only status &n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|i
op_eq
l_int|8
op_logical_and
id|j
op_eq
l_int|2
)paren
op_logical_or
(paren
id|i
op_eq
l_int|0x10
op_logical_and
id|j
op_eq
l_int|1
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Ql:Error during status phase, int=%02X, %d bytes recd&bslash;n&quot;
comma
id|i
comma
id|j
)paren
suffix:semicolon
id|result
op_assign
id|DID_ERROR
suffix:semicolon
)brace
id|outb
c_func
(paren
l_int|0x12
comma
id|qbase
op_plus
l_int|3
)paren
suffix:semicolon
multiline_comment|/* done, disconnect */
id|rtrc
c_func
(paren
l_int|1
)paren
r_if
c_cond
(paren
(paren
id|k
op_assign
id|ql_wai
c_func
(paren
id|priv
)paren
)paren
)paren
r_return
(paren
id|k
op_lshift
l_int|16
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Should get bus service interrupt and disconnect interrupt &n;&t; */
id|i
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|5
)paren
suffix:semicolon
multiline_comment|/* should be bus service */
r_while
c_loop
(paren
op_logical_neg
id|priv-&gt;qabort
op_logical_and
(paren
(paren
id|i
op_amp
l_int|0x20
)paren
op_ne
l_int|0x20
)paren
)paren
(brace
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
id|i
op_or_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|5
)paren
suffix:semicolon
)brace
id|rtrc
c_func
(paren
l_int|0
)paren
r_if
c_cond
(paren
id|priv-&gt;qabort
)paren
r_return
(paren
(paren
id|priv-&gt;qabort
op_eq
l_int|1
ques
c_cond
id|DID_ABORT
suffix:colon
id|DID_RESET
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
r_return
(paren
id|result
op_lshift
l_int|16
)paren
op_or
(paren
id|message
op_lshift
l_int|8
)paren
op_or
(paren
id|status
op_amp
id|STATUS_MASK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Interrupt handler &n; */
DECL|function|ql_ihandl
r_static
r_void
id|ql_ihandl
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|Scsi_Cmnd
op_star
id|icmd
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
op_assign
(paren
r_struct
id|Scsi_Host
op_star
)paren
id|dev_id
suffix:semicolon
id|qlogicfas_priv_t
id|priv
op_assign
(paren
id|qlogicfas_priv_t
)paren
op_amp
(paren
id|host-&gt;hostdata
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_int
id|qbase
op_assign
id|priv-&gt;qbase
suffix:semicolon
id|REG0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|qbase
op_plus
l_int|4
)paren
op_amp
l_int|0x80
)paren
)paren
multiline_comment|/* false alarm? */
r_return
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;qlcmd
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* no command to process? */
r_int
id|i
suffix:semicolon
id|i
op_assign
l_int|16
suffix:semicolon
r_while
c_loop
(paren
id|i
op_decrement
op_logical_and
id|inb
c_func
(paren
id|qbase
op_plus
l_int|5
)paren
)paren
suffix:semicolon
multiline_comment|/* maybe also ql_zap() */
r_return
suffix:semicolon
)brace
id|icmd
op_assign
id|priv-&gt;qlcmd
suffix:semicolon
id|icmd-&gt;result
op_assign
id|ql_pcmd
c_func
(paren
id|icmd
)paren
suffix:semicolon
id|priv-&gt;qlcmd
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If result is CHECK CONDITION done calls qcommand to request &n;&t; *&t;sense &n;&t; */
(paren
id|icmd-&gt;scsi_done
)paren
(paren
id|icmd
)paren
suffix:semicolon
)brace
DECL|function|do_ql_ihandl
r_static
id|irqreturn_t
id|do_ql_ihandl
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|dev_id
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|ql_ihandl
c_func
(paren
id|irq
comma
id|dev_id
comma
id|regs
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|IRQ_HANDLED
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Queued command&n; */
DECL|function|qlogicfas_queuecommand
r_int
id|qlogicfas_queuecommand
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
id|qlogicfas_priv_t
id|priv
op_assign
(paren
id|qlogicfas_priv_t
)paren
op_amp
(paren
id|cmd-&gt;device-&gt;host-&gt;hostdata
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;device-&gt;id
op_eq
id|priv-&gt;qinitid
)paren
(brace
id|cmd-&gt;result
op_assign
id|DID_BAD_TARGET
op_lshift
l_int|16
suffix:semicolon
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|cmd-&gt;scsi_done
op_assign
id|done
suffix:semicolon
multiline_comment|/* wait for the last command&squot;s interrupt to finish */
r_while
c_loop
(paren
id|priv-&gt;qlcmd
op_ne
l_int|NULL
)paren
(brace
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
)brace
id|ql_icmd
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Look for qlogic card and init if found &n; */
DECL|function|__qlogicfas_detect
r_struct
id|Scsi_Host
op_star
id|__qlogicfas_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|host
comma
r_int
id|qbase
comma
r_int
id|qlirq
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
multiline_comment|/* these are only used by IRQ detect */
r_int
id|qltyp
suffix:semicolon
multiline_comment|/* type of chip */
r_int
id|qinitid
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|hreg
suffix:semicolon
multiline_comment|/* registered host structure */
id|qlogicfas_priv_t
id|priv
suffix:semicolon
multiline_comment|/*&t;Qlogic Cards only exist at 0x230 or 0x330 (the chip itself&n;&t; *&t;decodes the address - I check 230 first since MIDI cards are&n;&t; *&t;typically at 0x330&n;&t; *&n;&t; *&t;Theoretically, two Qlogic cards can coexist in the same system.&n;&t; *&t;This should work by simply using this as a loadable module for&n;&t; *&t;the second card, but I haven&squot;t tested this.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|qbase
)paren
(brace
r_for
c_loop
(paren
id|qbase
op_assign
l_int|0x230
suffix:semicolon
id|qbase
OL
l_int|0x430
suffix:semicolon
id|qbase
op_add_assign
l_int|0x100
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|request_region
c_func
(paren
id|qbase
comma
l_int|0x10
comma
id|qlogicfas_name
)paren
)paren
r_continue
suffix:semicolon
id|REG1
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|inb
c_func
(paren
id|qbase
op_plus
l_int|0xe
)paren
op_xor
id|inb
c_func
(paren
id|qbase
op_plus
l_int|0xe
)paren
)paren
op_eq
l_int|7
)paren
op_logical_and
(paren
(paren
id|inb
c_func
(paren
id|qbase
op_plus
l_int|0xe
)paren
op_xor
id|inb
c_func
(paren
id|qbase
op_plus
l_int|0xe
)paren
)paren
op_eq
l_int|7
)paren
)paren
r_break
suffix:semicolon
id|release_region
c_func
(paren
id|qbase
comma
l_int|0x10
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|qbase
op_eq
l_int|0x430
)paren
r_return
l_int|NULL
suffix:semicolon
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Ql: Using preset base address of %03x&bslash;n&quot;
comma
id|qbase
)paren
suffix:semicolon
id|qltyp
op_assign
id|inb
c_func
(paren
id|qbase
op_plus
l_int|0xe
)paren
op_amp
l_int|0xf8
suffix:semicolon
id|qinitid
op_assign
id|host-&gt;this_id
suffix:semicolon
r_if
c_cond
(paren
id|qinitid
OL
l_int|0
)paren
id|qinitid
op_assign
l_int|7
suffix:semicolon
multiline_comment|/* if no ID, use 7 */
id|outb
c_func
(paren
l_int|1
comma
id|qbase
op_plus
l_int|8
)paren
suffix:semicolon
multiline_comment|/* set for PIO pseudo DMA */
id|REG0
suffix:semicolon
id|outb
c_func
(paren
l_int|0x40
op_or
id|qlcfg8
op_or
id|qinitid
comma
id|qbase
op_plus
l_int|8
)paren
suffix:semicolon
multiline_comment|/* (ini) bus id, disable scsi rst */
id|outb
c_func
(paren
id|qlcfg5
comma
id|qbase
op_plus
l_int|5
)paren
suffix:semicolon
multiline_comment|/* select timer */
id|outb
c_func
(paren
id|qlcfg9
comma
id|qbase
op_plus
l_int|9
)paren
suffix:semicolon
multiline_comment|/* prescaler */
macro_line|#if QL_RESET_AT_START
id|outb
c_func
(paren
l_int|3
comma
id|qbase
op_plus
l_int|3
)paren
suffix:semicolon
id|REG1
suffix:semicolon
multiline_comment|/* FIXME: timeout */
r_while
c_loop
(paren
id|inb
c_func
(paren
id|qbase
op_plus
l_int|0xf
)paren
op_amp
l_int|4
)paren
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
id|REG0
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *&t;IRQ probe - toggle pin and check request pending &n;&t; */
r_if
c_cond
(paren
id|qlirq
op_eq
op_minus
l_int|1
)paren
(brace
id|i
op_assign
l_int|0xffff
suffix:semicolon
id|j
op_assign
l_int|3
suffix:semicolon
id|outb
c_func
(paren
l_int|0x90
comma
id|qbase
op_plus
l_int|3
)paren
suffix:semicolon
multiline_comment|/* illegal command - cause interrupt */
id|REG1
suffix:semicolon
id|outb
c_func
(paren
l_int|10
comma
l_int|0x20
)paren
suffix:semicolon
multiline_comment|/* access pending interrupt map */
id|outb
c_func
(paren
l_int|10
comma
l_int|0xa0
)paren
suffix:semicolon
r_while
c_loop
(paren
id|j
op_decrement
)paren
(brace
id|outb
c_func
(paren
l_int|0xb0
op_or
id|QL_INT_ACTIVE_HIGH
comma
id|qbase
op_plus
l_int|0xd
)paren
suffix:semicolon
multiline_comment|/* int pin off */
id|i
op_and_assign
op_complement
(paren
id|inb
c_func
(paren
l_int|0x20
)paren
op_or
(paren
id|inb
c_func
(paren
l_int|0xa0
)paren
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
multiline_comment|/* find IRQ off */
id|outb
c_func
(paren
l_int|0xb4
op_or
id|QL_INT_ACTIVE_HIGH
comma
id|qbase
op_plus
l_int|0xd
)paren
suffix:semicolon
multiline_comment|/* int pin on */
id|i
op_and_assign
id|inb
c_func
(paren
l_int|0x20
)paren
op_or
(paren
id|inb
c_func
(paren
l_int|0xa0
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/* find IRQ on */
)brace
id|REG0
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|qbase
op_plus
l_int|5
)paren
)paren
suffix:semicolon
multiline_comment|/* purge int */
id|j
op_assign
op_minus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|i
)paren
multiline_comment|/* find on bit */
id|i
op_rshift_assign
l_int|1
comma
id|j
op_increment
suffix:semicolon
multiline_comment|/* should check for exactly 1 on */
id|qlirq
op_assign
id|j
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Ql: Using preset IRQ %d&bslash;n&quot;
comma
id|qlirq
)paren
suffix:semicolon
id|hreg
op_assign
id|scsi_host_alloc
c_func
(paren
id|host
comma
r_sizeof
(paren
r_struct
id|qlogicfas_priv
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hreg
)paren
r_goto
id|err_release_mem
suffix:semicolon
id|priv
op_assign
(paren
id|qlogicfas_priv_t
)paren
op_amp
(paren
id|hreg-&gt;hostdata
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|hreg-&gt;io_port
op_assign
id|qbase
suffix:semicolon
id|hreg-&gt;n_io_port
op_assign
l_int|16
suffix:semicolon
id|hreg-&gt;dma_channel
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|qlirq
op_ne
op_minus
l_int|1
)paren
id|hreg-&gt;irq
op_assign
id|qlirq
suffix:semicolon
id|priv-&gt;qbase
op_assign
id|qbase
suffix:semicolon
id|priv-&gt;qlirq
op_assign
id|qlirq
suffix:semicolon
id|priv-&gt;qinitid
op_assign
id|qinitid
suffix:semicolon
id|sprintf
c_func
(paren
id|priv-&gt;qinfo
comma
l_string|&quot;Qlogicfas Driver version 0.46, chip %02X at %03X, IRQ %d, TPdma:%d&quot;
comma
id|qltyp
comma
id|qbase
comma
id|qlirq
comma
id|QL_TURBO_PDMA
)paren
suffix:semicolon
id|host-&gt;name
op_assign
id|qlogicfas_name
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|qlirq
comma
id|do_ql_ihandl
comma
l_int|0
comma
id|qlogicfas_name
comma
id|hreg
)paren
)paren
r_goto
id|free_scsi_host
suffix:semicolon
r_if
c_cond
(paren
id|scsi_add_host
c_func
(paren
id|hreg
comma
l_int|NULL
)paren
)paren
r_goto
id|free_interrupt
suffix:semicolon
id|scsi_scan_host
c_func
(paren
id|hreg
)paren
suffix:semicolon
r_return
id|hreg
suffix:semicolon
id|free_interrupt
suffix:colon
id|free_irq
c_func
(paren
id|qlirq
comma
id|hreg
)paren
suffix:semicolon
id|free_scsi_host
suffix:colon
id|scsi_host_put
c_func
(paren
id|hreg
)paren
suffix:semicolon
id|err_release_mem
suffix:colon
id|release_region
c_func
(paren
id|qbase
comma
l_int|0x10
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|macro|MAX_QLOGICFAS
mdefine_line|#define MAX_QLOGICFAS&t;8
DECL|variable|iobase
r_static
r_int
id|iobase
(braket
id|MAX_QLOGICFAS
)braket
suffix:semicolon
DECL|variable|irq
r_static
r_int
id|irq
(braket
id|MAX_QLOGICFAS
)braket
op_assign
(brace
(braket
l_int|0
dot
dot
dot
id|MAX_QLOGICFAS
op_minus
l_int|1
)braket
op_assign
op_minus
l_int|1
)brace
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|iobase
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|MAX_QLOGICFAS
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|irq
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|MAX_QLOGICFAS
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|iobase
comma
l_string|&quot;I/O address&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|irq
comma
l_string|&quot;IRQ&quot;
)paren
suffix:semicolon
DECL|function|qlogicfas_detect
r_int
id|__devinit
id|qlogicfas_detect
c_func
(paren
id|Scsi_Host_Template
op_star
id|sht
)paren
(brace
r_int
id|i
comma
id|num
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_QLOGICFAS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|__qlogicfas_detect
c_func
(paren
id|sht
comma
id|iobase
(braket
id|num
)braket
comma
id|irq
(braket
id|num
)braket
)paren
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* no more devices */
r_break
suffix:semicolon
)brace
id|num
op_increment
suffix:semicolon
)brace
r_return
id|num
suffix:semicolon
)brace
DECL|function|qlogicfas_release
r_static
r_int
id|qlogicfas_release
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
)paren
(brace
id|qlogicfas_priv_t
id|priv
op_assign
(paren
id|qlogicfas_priv_t
)paren
op_amp
(paren
id|shost-&gt;hostdata
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_int
id|qbase
op_assign
id|priv-&gt;qbase
suffix:semicolon
r_if
c_cond
(paren
id|shost-&gt;irq
)paren
(brace
id|REG1
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|qbase
op_plus
l_int|0xb
)paren
suffix:semicolon
multiline_comment|/* disable ints */
id|free_irq
c_func
(paren
id|shost-&gt;irq
comma
id|shost
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|shost-&gt;dma_channel
op_ne
l_int|0xff
)paren
id|free_dma
c_func
(paren
id|shost-&gt;dma_channel
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shost-&gt;io_port
op_logical_and
id|shost-&gt;n_io_port
)paren
id|release_region
c_func
(paren
id|shost-&gt;io_port
comma
id|shost-&gt;n_io_port
)paren
suffix:semicolon
id|scsi_remove_host
c_func
(paren
id|shost
)paren
suffix:semicolon
id|scsi_host_put
c_func
(paren
id|shost
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;Return bios parameters &n; */
DECL|function|qlogicfas_biosparam
r_int
id|qlogicfas_biosparam
c_func
(paren
r_struct
id|scsi_device
op_star
id|disk
comma
r_struct
id|block_device
op_star
id|dev
comma
id|sector_t
id|capacity
comma
r_int
id|ip
(braket
)braket
)paren
(brace
multiline_comment|/* This should mimic the DOS Qlogic driver&squot;s behavior exactly */
id|ip
(braket
l_int|0
)braket
op_assign
l_int|0x40
suffix:semicolon
id|ip
(braket
l_int|1
)braket
op_assign
l_int|0x20
suffix:semicolon
id|ip
(braket
l_int|2
)braket
op_assign
(paren
r_int
r_int
)paren
id|capacity
op_div
(paren
id|ip
(braket
l_int|0
)braket
op_star
id|ip
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
(braket
l_int|2
)braket
OG
l_int|1024
)paren
(brace
id|ip
(braket
l_int|0
)braket
op_assign
l_int|0xff
suffix:semicolon
id|ip
(braket
l_int|1
)braket
op_assign
l_int|0x3f
suffix:semicolon
id|ip
(braket
l_int|2
)braket
op_assign
(paren
r_int
r_int
)paren
id|capacity
op_div
(paren
id|ip
(braket
l_int|0
)braket
op_star
id|ip
(braket
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|ip
(braket
l_int|2
)braket
OG
l_int|1023
)paren
id|ip
(braket
l_int|2
)braket
op_assign
l_int|1023
suffix:semicolon
macro_line|#endif
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Abort a command in progress&n; */
DECL|function|qlogicfas_abort
r_static
r_int
id|qlogicfas_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|qlogicfas_priv_t
id|priv
op_assign
(paren
id|qlogicfas_priv_t
)paren
op_amp
(paren
id|cmd-&gt;device-&gt;host-&gt;hostdata
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|priv-&gt;qabort
op_assign
l_int|1
suffix:semicolon
id|ql_zap
c_func
(paren
id|priv
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;Reset SCSI bus&n; *&t;FIXME: This function is invoked with cmd = NULL directly by&n; *&t;the PCMCIA qlogic_stub code. This wants fixing&n; */
DECL|function|qlogicfas_bus_reset
r_int
id|qlogicfas_bus_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
id|qlogicfas_priv_t
id|priv
op_assign
(paren
id|qlogicfas_priv_t
)paren
op_amp
(paren
id|cmd-&gt;device-&gt;host-&gt;hostdata
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|priv-&gt;qabort
op_assign
l_int|2
suffix:semicolon
id|ql_zap
c_func
(paren
id|priv
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;Reset SCSI host controller&n; */
DECL|function|qlogicfas_host_reset
r_static
r_int
id|qlogicfas_host_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_return
id|FAILED
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;Reset SCSI device&n; */
DECL|function|qlogicfas_device_reset
r_static
r_int
id|qlogicfas_device_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_return
id|FAILED
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Return info string&n; */
DECL|function|qlogicfas_info
r_static
r_const
r_char
op_star
id|qlogicfas_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
id|qlogicfas_priv_t
id|priv
op_assign
(paren
id|qlogicfas_priv_t
)paren
op_amp
(paren
id|host-&gt;hostdata
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
id|priv-&gt;qinfo
suffix:semicolon
)brace
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Tom Zerucha, Michael Griffith&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Driver for the Qlogic FAS SCSI controllers&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;The driver template is also needed for PCMCIA&n; */
DECL|variable|qlogicfas_driver_template
id|Scsi_Host_Template
id|qlogicfas_driver_template
op_assign
(brace
dot
id|module
op_assign
id|THIS_MODULE
comma
dot
id|name
op_assign
id|qlogicfas_name
comma
dot
id|proc_name
op_assign
id|qlogicfas_name
comma
dot
id|detect
op_assign
id|qlogicfas_detect
comma
dot
id|release
op_assign
id|qlogicfas_release
comma
dot
id|info
op_assign
id|qlogicfas_info
comma
dot
id|queuecommand
op_assign
id|qlogicfas_queuecommand
comma
dot
id|eh_abort_handler
op_assign
id|qlogicfas_abort
comma
dot
id|eh_bus_reset_handler
op_assign
id|qlogicfas_bus_reset
comma
dot
id|eh_device_reset_handler
op_assign
id|qlogicfas_device_reset
comma
dot
id|eh_host_reset_handler
op_assign
id|qlogicfas_host_reset
comma
dot
id|bios_param
op_assign
id|qlogicfas_biosparam
comma
dot
id|can_queue
op_assign
l_int|1
comma
dot
id|this_id
op_assign
op_minus
l_int|1
comma
dot
id|sg_tablesize
op_assign
id|SG_ALL
comma
dot
id|cmd_per_lun
op_assign
l_int|1
comma
dot
id|use_clustering
op_assign
id|DISABLE_CLUSTERING
comma
)brace
suffix:semicolon
macro_line|#ifndef PCMCIA
DECL|macro|driver_template
mdefine_line|#define driver_template qlogicfas_driver_template
macro_line|#include &quot;scsi_module.c&quot;
macro_line|#endif
eof
