multiline_comment|/*&n;   libata-core.c - helper library for ATA&n;&n;   Copyright 2003-2004 Red Hat, Inc.  All rights reserved.&n;   Copyright 2003-2004 Jeff Garzik&n;&n;   The contents of this file are subject to the Open&n;   Software License version 1.1 that can be found at&n;   http://www.opensource.org/licenses/osl-1.1.txt and is included herein&n;   by reference.&n;&n;   Alternatively, the contents of this file may be used under the terms&n;   of the GNU General Public License version 2 (the &quot;GPL&quot;) as distributed&n;   in the kernel source COPYING file, in which case the provisions of&n;   the GPL are applicable instead of the above.  If you wish to allow&n;   the use of your version of this file only under the terms of the&n;   GPL and not to allow others to use your version of this file under&n;   the OSL, indicate your decision by deleting the provisions above and&n;   replace them with the notice and other provisions required by the GPL.&n;   If you do not delete the provisions above, a recipient may use your&n;   version of this file under either the OSL or the GPL.&n;&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/completion.h&gt;
macro_line|#include &lt;linux/suspend.h&gt;
macro_line|#include &lt;linux/workqueue.h&gt;
macro_line|#include &lt;scsi/scsi.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;scsi_priv.h&quot;
macro_line|#include &lt;scsi/scsi_host.h&gt;
macro_line|#include &lt;linux/libata.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &quot;libata.h&quot;
r_static
r_int
r_int
id|ata_busy_sleep
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_int
r_int
id|tmout_pat
comma
r_int
r_int
id|tmout
)paren
suffix:semicolon
r_static
r_void
id|ata_set_mode
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
)paren
suffix:semicolon
r_static
r_void
id|ata_dev_set_xfermode
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_struct
id|ata_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
r_int
id|ata_get_mode_mask
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_int
id|shift
)paren
suffix:semicolon
r_static
r_int
id|fgb
c_func
(paren
id|u32
id|bitmap
)paren
suffix:semicolon
r_static
r_int
id|ata_choose_xfer_mode
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
id|u8
op_star
id|xfer_mode_out
comma
r_int
r_int
op_star
id|xfer_shift_out
)paren
suffix:semicolon
r_static
r_int
id|ata_qc_complete_noop
c_func
(paren
r_struct
id|ata_queued_cmd
op_star
id|qc
comma
id|u8
id|drv_stat
)paren
suffix:semicolon
r_static
r_void
id|__ata_qc_complete
c_func
(paren
r_struct
id|ata_queued_cmd
op_star
id|qc
)paren
suffix:semicolon
DECL|variable|ata_unique_id
r_static
r_int
r_int
id|ata_unique_id
op_assign
l_int|1
suffix:semicolon
DECL|variable|ata_wq
r_static
r_struct
id|workqueue_struct
op_star
id|ata_wq
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Jeff Garzik&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Library module for ATA devices&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|variable|DRV_VERSION
id|MODULE_VERSION
c_func
(paren
id|DRV_VERSION
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;ata_tf_load - send taskfile registers to host controller&n; *&t;@ap: Port to which output is sent&n; *&t;@tf: ATA taskfile register set&n; *&n; *&t;Outputs ATA taskfile to standard ATA host controller.&n; *&n; *&t;LOCKING:&n; *&t;Inherited from caller.&n; */
DECL|function|ata_tf_load_pio
r_static
r_void
id|ata_tf_load_pio
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_struct
id|ata_taskfile
op_star
id|tf
)paren
(brace
r_struct
id|ata_ioports
op_star
id|ioaddr
op_assign
op_amp
id|ap-&gt;ioaddr
suffix:semicolon
r_int
r_int
id|is_addr
op_assign
id|tf-&gt;flags
op_amp
id|ATA_TFLAG_ISADDR
suffix:semicolon
r_if
c_cond
(paren
id|tf-&gt;ctl
op_ne
id|ap-&gt;last_ctl
)paren
(brace
id|outb
c_func
(paren
id|tf-&gt;ctl
comma
id|ioaddr-&gt;ctl_addr
)paren
suffix:semicolon
id|ap-&gt;last_ctl
op_assign
id|tf-&gt;ctl
suffix:semicolon
id|ata_wait_idle
c_func
(paren
id|ap
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_addr
op_logical_and
(paren
id|tf-&gt;flags
op_amp
id|ATA_TFLAG_LBA48
)paren
)paren
(brace
id|outb
c_func
(paren
id|tf-&gt;hob_feature
comma
id|ioaddr-&gt;feature_addr
)paren
suffix:semicolon
id|outb
c_func
(paren
id|tf-&gt;hob_nsect
comma
id|ioaddr-&gt;nsect_addr
)paren
suffix:semicolon
id|outb
c_func
(paren
id|tf-&gt;hob_lbal
comma
id|ioaddr-&gt;lbal_addr
)paren
suffix:semicolon
id|outb
c_func
(paren
id|tf-&gt;hob_lbam
comma
id|ioaddr-&gt;lbam_addr
)paren
suffix:semicolon
id|outb
c_func
(paren
id|tf-&gt;hob_lbah
comma
id|ioaddr-&gt;lbah_addr
)paren
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;hob: feat 0x%X nsect 0x%X, lba 0x%X 0x%X 0x%X&bslash;n&quot;
comma
id|tf-&gt;hob_feature
comma
id|tf-&gt;hob_nsect
comma
id|tf-&gt;hob_lbal
comma
id|tf-&gt;hob_lbam
comma
id|tf-&gt;hob_lbah
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_addr
)paren
(brace
id|outb
c_func
(paren
id|tf-&gt;feature
comma
id|ioaddr-&gt;feature_addr
)paren
suffix:semicolon
id|outb
c_func
(paren
id|tf-&gt;nsect
comma
id|ioaddr-&gt;nsect_addr
)paren
suffix:semicolon
id|outb
c_func
(paren
id|tf-&gt;lbal
comma
id|ioaddr-&gt;lbal_addr
)paren
suffix:semicolon
id|outb
c_func
(paren
id|tf-&gt;lbam
comma
id|ioaddr-&gt;lbam_addr
)paren
suffix:semicolon
id|outb
c_func
(paren
id|tf-&gt;lbah
comma
id|ioaddr-&gt;lbah_addr
)paren
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;feat 0x%X nsect 0x%X lba 0x%X 0x%X 0x%X&bslash;n&quot;
comma
id|tf-&gt;feature
comma
id|tf-&gt;nsect
comma
id|tf-&gt;lbal
comma
id|tf-&gt;lbam
comma
id|tf-&gt;lbah
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tf-&gt;flags
op_amp
id|ATA_TFLAG_DEVICE
)paren
(brace
id|outb
c_func
(paren
id|tf-&gt;device
comma
id|ioaddr-&gt;device_addr
)paren
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;device 0x%X&bslash;n&quot;
comma
id|tf-&gt;device
)paren
suffix:semicolon
)brace
id|ata_wait_idle
c_func
(paren
id|ap
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_tf_load_mmio - send taskfile registers to host controller&n; *&t;@ap: Port to which output is sent&n; *&t;@tf: ATA taskfile register set&n; *&n; *&t;Outputs ATA taskfile to standard ATA host controller using MMIO.&n; *&n; *&t;LOCKING:&n; *&t;Inherited from caller.&n; */
DECL|function|ata_tf_load_mmio
r_static
r_void
id|ata_tf_load_mmio
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_struct
id|ata_taskfile
op_star
id|tf
)paren
(brace
r_struct
id|ata_ioports
op_star
id|ioaddr
op_assign
op_amp
id|ap-&gt;ioaddr
suffix:semicolon
r_int
r_int
id|is_addr
op_assign
id|tf-&gt;flags
op_amp
id|ATA_TFLAG_ISADDR
suffix:semicolon
r_if
c_cond
(paren
id|tf-&gt;ctl
op_ne
id|ap-&gt;last_ctl
)paren
(brace
id|writeb
c_func
(paren
id|tf-&gt;ctl
comma
(paren
r_void
id|__iomem
op_star
)paren
id|ap-&gt;ioaddr.ctl_addr
)paren
suffix:semicolon
id|ap-&gt;last_ctl
op_assign
id|tf-&gt;ctl
suffix:semicolon
id|ata_wait_idle
c_func
(paren
id|ap
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_addr
op_logical_and
(paren
id|tf-&gt;flags
op_amp
id|ATA_TFLAG_LBA48
)paren
)paren
(brace
id|writeb
c_func
(paren
id|tf-&gt;hob_feature
comma
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;feature_addr
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|tf-&gt;hob_nsect
comma
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;nsect_addr
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|tf-&gt;hob_lbal
comma
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;lbal_addr
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|tf-&gt;hob_lbam
comma
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;lbam_addr
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|tf-&gt;hob_lbah
comma
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;lbah_addr
)paren
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;hob: feat 0x%X nsect 0x%X, lba 0x%X 0x%X 0x%X&bslash;n&quot;
comma
id|tf-&gt;hob_feature
comma
id|tf-&gt;hob_nsect
comma
id|tf-&gt;hob_lbal
comma
id|tf-&gt;hob_lbam
comma
id|tf-&gt;hob_lbah
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_addr
)paren
(brace
id|writeb
c_func
(paren
id|tf-&gt;feature
comma
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;feature_addr
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|tf-&gt;nsect
comma
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;nsect_addr
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|tf-&gt;lbal
comma
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;lbal_addr
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|tf-&gt;lbam
comma
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;lbam_addr
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|tf-&gt;lbah
comma
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;lbah_addr
)paren
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;feat 0x%X nsect 0x%X lba 0x%X 0x%X 0x%X&bslash;n&quot;
comma
id|tf-&gt;feature
comma
id|tf-&gt;nsect
comma
id|tf-&gt;lbal
comma
id|tf-&gt;lbam
comma
id|tf-&gt;lbah
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tf-&gt;flags
op_amp
id|ATA_TFLAG_DEVICE
)paren
(brace
id|writeb
c_func
(paren
id|tf-&gt;device
comma
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;device_addr
)paren
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;device 0x%X&bslash;n&quot;
comma
id|tf-&gt;device
)paren
suffix:semicolon
)brace
id|ata_wait_idle
c_func
(paren
id|ap
)paren
suffix:semicolon
)brace
DECL|function|ata_tf_load
r_void
id|ata_tf_load
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_struct
id|ata_taskfile
op_star
id|tf
)paren
(brace
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|ATA_FLAG_MMIO
)paren
id|ata_tf_load_mmio
c_func
(paren
id|ap
comma
id|tf
)paren
suffix:semicolon
r_else
id|ata_tf_load_pio
c_func
(paren
id|ap
comma
id|tf
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_exec_command - issue ATA command to host controller&n; *&t;@ap: port to which command is being issued&n; *&t;@tf: ATA taskfile register set&n; *&n; *&t;Issues PIO/MMIO write to ATA command register, with proper&n; *&t;synchronization with interrupt handler / other threads.&n; *&n; *&t;LOCKING:&n; *&t;spin_lock_irqsave(host_set lock)&n; */
DECL|function|ata_exec_command_pio
r_static
r_void
id|ata_exec_command_pio
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_struct
id|ata_taskfile
op_star
id|tf
)paren
(brace
id|DPRINTK
c_func
(paren
l_string|&quot;ata%u: cmd 0x%X&bslash;n&quot;
comma
id|ap-&gt;id
comma
id|tf-&gt;command
)paren
suffix:semicolon
id|outb
c_func
(paren
id|tf-&gt;command
comma
id|ap-&gt;ioaddr.command_addr
)paren
suffix:semicolon
id|ata_pause
c_func
(paren
id|ap
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_exec_command_mmio - issue ATA command to host controller&n; *&t;@ap: port to which command is being issued&n; *&t;@tf: ATA taskfile register set&n; *&n; *&t;Issues MMIO write to ATA command register, with proper&n; *&t;synchronization with interrupt handler / other threads.&n; *&n; *&t;LOCKING:&n; *&t;spin_lock_irqsave(host_set lock)&n; */
DECL|function|ata_exec_command_mmio
r_static
r_void
id|ata_exec_command_mmio
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_struct
id|ata_taskfile
op_star
id|tf
)paren
(brace
id|DPRINTK
c_func
(paren
l_string|&quot;ata%u: cmd 0x%X&bslash;n&quot;
comma
id|ap-&gt;id
comma
id|tf-&gt;command
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|tf-&gt;command
comma
(paren
r_void
id|__iomem
op_star
)paren
id|ap-&gt;ioaddr.command_addr
)paren
suffix:semicolon
id|ata_pause
c_func
(paren
id|ap
)paren
suffix:semicolon
)brace
DECL|function|ata_exec_command
r_void
id|ata_exec_command
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_struct
id|ata_taskfile
op_star
id|tf
)paren
(brace
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|ATA_FLAG_MMIO
)paren
id|ata_exec_command_mmio
c_func
(paren
id|ap
comma
id|tf
)paren
suffix:semicolon
r_else
id|ata_exec_command_pio
c_func
(paren
id|ap
comma
id|tf
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_exec - issue ATA command to host controller&n; *&t;@ap: port to which command is being issued&n; *&t;@tf: ATA taskfile register set&n; *&n; *&t;Issues PIO/MMIO write to ATA command register, with proper&n; *&t;synchronization with interrupt handler / other threads.&n; *&n; *&t;LOCKING:&n; *&t;Obtains host_set lock.&n; */
DECL|function|ata_exec
r_static
r_inline
r_void
id|ata_exec
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_struct
id|ata_taskfile
op_star
id|tf
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;ata%u: cmd 0x%X&bslash;n&quot;
comma
id|ap-&gt;id
comma
id|tf-&gt;command
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ap-&gt;host_set-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|ap-&gt;ops
op_member_access_from_pointer
id|exec_command
c_func
(paren
id|ap
comma
id|tf
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ap-&gt;host_set-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_tf_to_host - issue ATA taskfile to host controller&n; *&t;@ap: port to which command is being issued&n; *&t;@tf: ATA taskfile register set&n; *&n; *&t;Issues ATA taskfile register set to ATA host controller,&n; *&t;with proper synchronization with interrupt handler and&n; *&t;other threads.&n; *&n; *&t;LOCKING:&n; *&t;Obtains host_set lock.&n; */
DECL|function|ata_tf_to_host
r_static
r_void
id|ata_tf_to_host
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_struct
id|ata_taskfile
op_star
id|tf
)paren
(brace
id|ap-&gt;ops
op_member_access_from_pointer
id|tf_load
c_func
(paren
id|ap
comma
id|tf
)paren
suffix:semicolon
id|ata_exec
c_func
(paren
id|ap
comma
id|tf
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_tf_to_host_nolock - issue ATA taskfile to host controller&n; *&t;@ap: port to which command is being issued&n; *&t;@tf: ATA taskfile register set&n; *&n; *&t;Issues ATA taskfile register set to ATA host controller,&n; *&t;with proper synchronization with interrupt handler and&n; *&t;other threads.&n; *&n; *&t;LOCKING:&n; *&t;spin_lock_irqsave(host_set lock)&n; */
DECL|function|ata_tf_to_host_nolock
r_void
id|ata_tf_to_host_nolock
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_struct
id|ata_taskfile
op_star
id|tf
)paren
(brace
id|ap-&gt;ops
op_member_access_from_pointer
id|tf_load
c_func
(paren
id|ap
comma
id|tf
)paren
suffix:semicolon
id|ap-&gt;ops
op_member_access_from_pointer
id|exec_command
c_func
(paren
id|ap
comma
id|tf
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_tf_read - input device&squot;s ATA taskfile shadow registers&n; *&t;@ap: Port from which input is read&n; *&t;@tf: ATA taskfile register set for storing input&n; *&n; *&t;Reads ATA taskfile registers for currently-selected device&n; *&t;into @tf.&n; *&n; *&t;LOCKING:&n; *&t;Inherited from caller.&n; */
DECL|function|ata_tf_read_pio
r_static
r_void
id|ata_tf_read_pio
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_struct
id|ata_taskfile
op_star
id|tf
)paren
(brace
r_struct
id|ata_ioports
op_star
id|ioaddr
op_assign
op_amp
id|ap-&gt;ioaddr
suffix:semicolon
id|tf-&gt;nsect
op_assign
id|inb
c_func
(paren
id|ioaddr-&gt;nsect_addr
)paren
suffix:semicolon
id|tf-&gt;lbal
op_assign
id|inb
c_func
(paren
id|ioaddr-&gt;lbal_addr
)paren
suffix:semicolon
id|tf-&gt;lbam
op_assign
id|inb
c_func
(paren
id|ioaddr-&gt;lbam_addr
)paren
suffix:semicolon
id|tf-&gt;lbah
op_assign
id|inb
c_func
(paren
id|ioaddr-&gt;lbah_addr
)paren
suffix:semicolon
id|tf-&gt;device
op_assign
id|inb
c_func
(paren
id|ioaddr-&gt;device_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tf-&gt;flags
op_amp
id|ATA_TFLAG_LBA48
)paren
(brace
id|outb
c_func
(paren
id|tf-&gt;ctl
op_or
id|ATA_HOB
comma
id|ioaddr-&gt;ctl_addr
)paren
suffix:semicolon
id|tf-&gt;hob_feature
op_assign
id|inb
c_func
(paren
id|ioaddr-&gt;error_addr
)paren
suffix:semicolon
id|tf-&gt;hob_nsect
op_assign
id|inb
c_func
(paren
id|ioaddr-&gt;nsect_addr
)paren
suffix:semicolon
id|tf-&gt;hob_lbal
op_assign
id|inb
c_func
(paren
id|ioaddr-&gt;lbal_addr
)paren
suffix:semicolon
id|tf-&gt;hob_lbam
op_assign
id|inb
c_func
(paren
id|ioaddr-&gt;lbam_addr
)paren
suffix:semicolon
id|tf-&gt;hob_lbah
op_assign
id|inb
c_func
(paren
id|ioaddr-&gt;lbah_addr
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;ata_tf_read_mmio - input device&squot;s ATA taskfile shadow registers&n; *&t;@ap: Port from which input is read&n; *&t;@tf: ATA taskfile register set for storing input&n; *&n; *&t;Reads ATA taskfile registers for currently-selected device&n; *&t;into @tf via MMIO.&n; *&n; *&t;LOCKING:&n; *&t;Inherited from caller.&n; */
DECL|function|ata_tf_read_mmio
r_static
r_void
id|ata_tf_read_mmio
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_struct
id|ata_taskfile
op_star
id|tf
)paren
(brace
r_struct
id|ata_ioports
op_star
id|ioaddr
op_assign
op_amp
id|ap-&gt;ioaddr
suffix:semicolon
id|tf-&gt;nsect
op_assign
id|readb
c_func
(paren
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;nsect_addr
)paren
suffix:semicolon
id|tf-&gt;lbal
op_assign
id|readb
c_func
(paren
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;lbal_addr
)paren
suffix:semicolon
id|tf-&gt;lbam
op_assign
id|readb
c_func
(paren
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;lbam_addr
)paren
suffix:semicolon
id|tf-&gt;lbah
op_assign
id|readb
c_func
(paren
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;lbah_addr
)paren
suffix:semicolon
id|tf-&gt;device
op_assign
id|readb
c_func
(paren
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;device_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tf-&gt;flags
op_amp
id|ATA_TFLAG_LBA48
)paren
(brace
id|writeb
c_func
(paren
id|tf-&gt;ctl
op_or
id|ATA_HOB
comma
(paren
r_void
id|__iomem
op_star
)paren
id|ap-&gt;ioaddr.ctl_addr
)paren
suffix:semicolon
id|tf-&gt;hob_feature
op_assign
id|readb
c_func
(paren
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;error_addr
)paren
suffix:semicolon
id|tf-&gt;hob_nsect
op_assign
id|readb
c_func
(paren
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;nsect_addr
)paren
suffix:semicolon
id|tf-&gt;hob_lbal
op_assign
id|readb
c_func
(paren
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;lbal_addr
)paren
suffix:semicolon
id|tf-&gt;hob_lbam
op_assign
id|readb
c_func
(paren
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;lbam_addr
)paren
suffix:semicolon
id|tf-&gt;hob_lbah
op_assign
id|readb
c_func
(paren
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;lbah_addr
)paren
suffix:semicolon
)brace
)brace
DECL|function|ata_tf_read
r_void
id|ata_tf_read
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_struct
id|ata_taskfile
op_star
id|tf
)paren
(brace
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|ATA_FLAG_MMIO
)paren
id|ata_tf_read_mmio
c_func
(paren
id|ap
comma
id|tf
)paren
suffix:semicolon
r_else
id|ata_tf_read_pio
c_func
(paren
id|ap
comma
id|tf
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_check_status - Read device status reg &amp; clear interrupt&n; *&t;@ap: port where the device is&n; *&n; *&t;Reads ATA taskfile status register for currently-selected device&n; *&t;and return it&squot;s value. This also clears pending interrupts&n; *      from this device&n; *&n; *&t;LOCKING:&n; *&t;Inherited from caller.&n; */
DECL|function|ata_check_status_pio
r_static
id|u8
id|ata_check_status_pio
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
)paren
(brace
r_return
id|inb
c_func
(paren
id|ap-&gt;ioaddr.status_addr
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_check_status_mmio - Read device status reg &amp; clear interrupt&n; *&t;@ap: port where the device is&n; *&n; *&t;Reads ATA taskfile status register for currently-selected device&n; *&t;via MMIO and return it&squot;s value. This also clears pending interrupts&n; *      from this device&n; *&n; *&t;LOCKING:&n; *&t;Inherited from caller.&n; */
DECL|function|ata_check_status_mmio
r_static
id|u8
id|ata_check_status_mmio
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
)paren
(brace
r_return
id|readb
c_func
(paren
(paren
r_void
id|__iomem
op_star
)paren
id|ap-&gt;ioaddr.status_addr
)paren
suffix:semicolon
)brace
DECL|function|ata_check_status
id|u8
id|ata_check_status
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
)paren
(brace
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|ATA_FLAG_MMIO
)paren
r_return
id|ata_check_status_mmio
c_func
(paren
id|ap
)paren
suffix:semicolon
r_return
id|ata_check_status_pio
c_func
(paren
id|ap
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_tf_to_fis - Convert ATA taskfile to SATA FIS structure&n; *&t;@tf: Taskfile to convert&n; *&t;@fis: Buffer into which data will output&n; *&t;@pmp: Port multiplier port&n; *&n; *&t;Converts a standard ATA taskfile to a Serial ATA&n; *&t;FIS structure (Register - Host to Device).&n; *&n; *&t;LOCKING:&n; *&t;Inherited from caller.&n; */
DECL|function|ata_tf_to_fis
r_void
id|ata_tf_to_fis
c_func
(paren
r_struct
id|ata_taskfile
op_star
id|tf
comma
id|u8
op_star
id|fis
comma
id|u8
id|pmp
)paren
(brace
id|fis
(braket
l_int|0
)braket
op_assign
l_int|0x27
suffix:semicolon
multiline_comment|/* Register - Host to Device FIS */
id|fis
(braket
l_int|1
)braket
op_assign
(paren
id|pmp
op_amp
l_int|0xf
)paren
op_or
(paren
l_int|1
op_lshift
l_int|7
)paren
suffix:semicolon
multiline_comment|/* Port multiplier number,&n;&t;&t;&t;&t;&t;    bit 7 indicates Command FIS */
id|fis
(braket
l_int|2
)braket
op_assign
id|tf-&gt;command
suffix:semicolon
id|fis
(braket
l_int|3
)braket
op_assign
id|tf-&gt;feature
suffix:semicolon
id|fis
(braket
l_int|4
)braket
op_assign
id|tf-&gt;lbal
suffix:semicolon
id|fis
(braket
l_int|5
)braket
op_assign
id|tf-&gt;lbam
suffix:semicolon
id|fis
(braket
l_int|6
)braket
op_assign
id|tf-&gt;lbah
suffix:semicolon
id|fis
(braket
l_int|7
)braket
op_assign
id|tf-&gt;device
suffix:semicolon
id|fis
(braket
l_int|8
)braket
op_assign
id|tf-&gt;hob_lbal
suffix:semicolon
id|fis
(braket
l_int|9
)braket
op_assign
id|tf-&gt;hob_lbam
suffix:semicolon
id|fis
(braket
l_int|10
)braket
op_assign
id|tf-&gt;hob_lbah
suffix:semicolon
id|fis
(braket
l_int|11
)braket
op_assign
id|tf-&gt;hob_feature
suffix:semicolon
id|fis
(braket
l_int|12
)braket
op_assign
id|tf-&gt;nsect
suffix:semicolon
id|fis
(braket
l_int|13
)braket
op_assign
id|tf-&gt;hob_nsect
suffix:semicolon
id|fis
(braket
l_int|14
)braket
op_assign
l_int|0
suffix:semicolon
id|fis
(braket
l_int|15
)braket
op_assign
id|tf-&gt;ctl
suffix:semicolon
id|fis
(braket
l_int|16
)braket
op_assign
l_int|0
suffix:semicolon
id|fis
(braket
l_int|17
)braket
op_assign
l_int|0
suffix:semicolon
id|fis
(braket
l_int|18
)braket
op_assign
l_int|0
suffix:semicolon
id|fis
(braket
l_int|19
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_tf_from_fis - Convert SATA FIS to ATA taskfile&n; *&t;@fis: Buffer from which data will be input&n; *&t;@tf: Taskfile to output&n; *&n; *&t;Converts a standard ATA taskfile to a Serial ATA&n; *&t;FIS structure (Register - Host to Device).&n; *&n; *&t;LOCKING:&n; *&t;Inherited from caller.&n; */
DECL|function|ata_tf_from_fis
r_void
id|ata_tf_from_fis
c_func
(paren
id|u8
op_star
id|fis
comma
r_struct
id|ata_taskfile
op_star
id|tf
)paren
(brace
id|tf-&gt;command
op_assign
id|fis
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* status */
id|tf-&gt;feature
op_assign
id|fis
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* error */
id|tf-&gt;lbal
op_assign
id|fis
(braket
l_int|4
)braket
suffix:semicolon
id|tf-&gt;lbam
op_assign
id|fis
(braket
l_int|5
)braket
suffix:semicolon
id|tf-&gt;lbah
op_assign
id|fis
(braket
l_int|6
)braket
suffix:semicolon
id|tf-&gt;device
op_assign
id|fis
(braket
l_int|7
)braket
suffix:semicolon
id|tf-&gt;hob_lbal
op_assign
id|fis
(braket
l_int|8
)braket
suffix:semicolon
id|tf-&gt;hob_lbam
op_assign
id|fis
(braket
l_int|9
)braket
suffix:semicolon
id|tf-&gt;hob_lbah
op_assign
id|fis
(braket
l_int|10
)braket
suffix:semicolon
id|tf-&gt;nsect
op_assign
id|fis
(braket
l_int|12
)braket
suffix:semicolon
id|tf-&gt;hob_nsect
op_assign
id|fis
(braket
l_int|13
)braket
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_prot_to_cmd - determine which read/write opcodes to use&n; *&t;@protocol: ATA_PROT_xxx taskfile protocol&n; *&t;@lba48: true is lba48 is present&n; *&n; *&t;Given necessary input, determine which read/write commands&n; *&t;to use to transfer data.&n; *&n; *&t;LOCKING:&n; *&t;None.&n; */
DECL|function|ata_prot_to_cmd
r_static
r_int
id|ata_prot_to_cmd
c_func
(paren
r_int
id|protocol
comma
r_int
id|lba48
)paren
(brace
r_int
id|rcmd
op_assign
l_int|0
comma
id|wcmd
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|protocol
)paren
(brace
r_case
id|ATA_PROT_PIO
suffix:colon
r_if
c_cond
(paren
id|lba48
)paren
(brace
id|rcmd
op_assign
id|ATA_CMD_PIO_READ_EXT
suffix:semicolon
id|wcmd
op_assign
id|ATA_CMD_PIO_WRITE_EXT
suffix:semicolon
)brace
r_else
(brace
id|rcmd
op_assign
id|ATA_CMD_PIO_READ
suffix:semicolon
id|wcmd
op_assign
id|ATA_CMD_PIO_WRITE
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ATA_PROT_DMA
suffix:colon
r_if
c_cond
(paren
id|lba48
)paren
(brace
id|rcmd
op_assign
id|ATA_CMD_READ_EXT
suffix:semicolon
id|wcmd
op_assign
id|ATA_CMD_WRITE_EXT
suffix:semicolon
)brace
r_else
(brace
id|rcmd
op_assign
id|ATA_CMD_READ
suffix:semicolon
id|wcmd
op_assign
id|ATA_CMD_WRITE
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|rcmd
op_or
(paren
id|wcmd
op_lshift
l_int|8
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_dev_set_protocol - set taskfile protocol and r/w commands&n; *&t;@dev: device to examine and configure&n; *&n; *&t;Examine the device configuration, after we have&n; *&t;read the identify-device page and configured the&n; *&t;data transfer mode.  Set internal state related to&n; *&t;the ATA taskfile protocol (pio, pio mult, dma, etc.)&n; *&t;and calculate the proper read/write commands to use.&n; *&n; *&t;LOCKING:&n; *&t;caller.&n; */
DECL|function|ata_dev_set_protocol
r_static
r_void
id|ata_dev_set_protocol
c_func
(paren
r_struct
id|ata_device
op_star
id|dev
)paren
(brace
r_int
id|pio
op_assign
(paren
id|dev-&gt;flags
op_amp
id|ATA_DFLAG_PIO
)paren
suffix:semicolon
r_int
id|lba48
op_assign
(paren
id|dev-&gt;flags
op_amp
id|ATA_DFLAG_LBA48
)paren
suffix:semicolon
r_int
id|proto
comma
id|cmd
suffix:semicolon
r_if
c_cond
(paren
id|pio
)paren
id|proto
op_assign
id|dev-&gt;xfer_protocol
op_assign
id|ATA_PROT_PIO
suffix:semicolon
r_else
id|proto
op_assign
id|dev-&gt;xfer_protocol
op_assign
id|ATA_PROT_DMA
suffix:semicolon
id|cmd
op_assign
id|ata_prot_to_cmd
c_func
(paren
id|proto
comma
id|lba48
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
OL
l_int|0
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|dev-&gt;read_cmd
op_assign
id|cmd
op_amp
l_int|0xff
suffix:semicolon
id|dev-&gt;write_cmd
op_assign
(paren
id|cmd
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
)brace
DECL|variable|xfer_mode_str
r_static
r_const
r_char
op_star
id|xfer_mode_str
(braket
)braket
op_assign
(brace
l_string|&quot;UDMA/16&quot;
comma
l_string|&quot;UDMA/25&quot;
comma
l_string|&quot;UDMA/33&quot;
comma
l_string|&quot;UDMA/44&quot;
comma
l_string|&quot;UDMA/66&quot;
comma
l_string|&quot;UDMA/100&quot;
comma
l_string|&quot;UDMA/133&quot;
comma
l_string|&quot;UDMA7&quot;
comma
l_string|&quot;MWDMA0&quot;
comma
l_string|&quot;MWDMA1&quot;
comma
l_string|&quot;MWDMA2&quot;
comma
l_string|&quot;PIO0&quot;
comma
l_string|&quot;PIO1&quot;
comma
l_string|&quot;PIO2&quot;
comma
l_string|&quot;PIO3&quot;
comma
l_string|&quot;PIO4&quot;
comma
)brace
suffix:semicolon
multiline_comment|/**&n; *&t;ata_udma_string - convert UDMA bit offset to string&n; *&t;@udma_mask: mask of bits supported; only highest bit counts.&n; *&n; *&t;Determine string which represents the highest speed&n; *&t;(highest bit in @udma_mask).&n; *&n; *&t;LOCKING:&n; *&t;None.&n; *&n; *&t;RETURNS:&n; *&t;Constant C string representing highest speed listed in&n; *&t;@udma_mask, or the constant C string &quot;&lt;n/a&gt;&quot;.&n; */
DECL|function|ata_mode_string
r_static
r_const
r_char
op_star
id|ata_mode_string
c_func
(paren
r_int
r_int
id|mask
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|7
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
r_if
c_cond
(paren
id|mask
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
r_goto
id|out
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|ATA_SHIFT_MWDMA
op_plus
l_int|2
suffix:semicolon
id|i
op_ge
id|ATA_SHIFT_MWDMA
suffix:semicolon
id|i
op_decrement
)paren
r_if
c_cond
(paren
id|mask
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
r_goto
id|out
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|ATA_SHIFT_PIO
op_plus
l_int|4
suffix:semicolon
id|i
op_ge
id|ATA_SHIFT_PIO
suffix:semicolon
id|i
op_decrement
)paren
r_if
c_cond
(paren
id|mask
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
r_goto
id|out
suffix:semicolon
r_return
l_string|&quot;&lt;n/a&gt;&quot;
suffix:semicolon
id|out
suffix:colon
r_return
id|xfer_mode_str
(braket
id|i
)braket
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_pio_devchk - PATA device presence detection&n; *&t;@ap: ATA channel to examine&n; *&t;@device: Device to examine (starting at zero)&n; *&n; *&t;This technique was originally described in&n; *&t;Hale Landis&squot;s ATADRVR (www.ata-atapi.com), and&n; *&t;later found its way into the ATA/ATAPI spec.&n; *&n; *&t;Write a pattern to the ATA shadow registers,&n; *&t;and if a device is present, it will respond by&n; *&t;correctly storing and echoing back the&n; *&t;ATA shadow register contents.&n; *&n; *&t;LOCKING:&n; *&t;caller.&n; */
DECL|function|ata_pio_devchk
r_static
r_int
r_int
id|ata_pio_devchk
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_int
r_int
id|device
)paren
(brace
r_struct
id|ata_ioports
op_star
id|ioaddr
op_assign
op_amp
id|ap-&gt;ioaddr
suffix:semicolon
id|u8
id|nsect
comma
id|lbal
suffix:semicolon
id|ap-&gt;ops
op_member_access_from_pointer
id|dev_select
c_func
(paren
id|ap
comma
id|device
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x55
comma
id|ioaddr-&gt;nsect_addr
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xaa
comma
id|ioaddr-&gt;lbal_addr
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xaa
comma
id|ioaddr-&gt;nsect_addr
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x55
comma
id|ioaddr-&gt;lbal_addr
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x55
comma
id|ioaddr-&gt;nsect_addr
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xaa
comma
id|ioaddr-&gt;lbal_addr
)paren
suffix:semicolon
id|nsect
op_assign
id|inb
c_func
(paren
id|ioaddr-&gt;nsect_addr
)paren
suffix:semicolon
id|lbal
op_assign
id|inb
c_func
(paren
id|ioaddr-&gt;lbal_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|nsect
op_eq
l_int|0x55
)paren
op_logical_and
(paren
id|lbal
op_eq
l_int|0xaa
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* we found a device */
r_return
l_int|0
suffix:semicolon
multiline_comment|/* nothing found */
)brace
multiline_comment|/**&n; *&t;ata_mmio_devchk - PATA device presence detection&n; *&t;@ap: ATA channel to examine&n; *&t;@device: Device to examine (starting at zero)&n; *&n; *&t;This technique was originally described in&n; *&t;Hale Landis&squot;s ATADRVR (www.ata-atapi.com), and&n; *&t;later found its way into the ATA/ATAPI spec.&n; *&n; *&t;Write a pattern to the ATA shadow registers,&n; *&t;and if a device is present, it will respond by&n; *&t;correctly storing and echoing back the&n; *&t;ATA shadow register contents.&n; *&n; *&t;LOCKING:&n; *&t;caller.&n; */
DECL|function|ata_mmio_devchk
r_static
r_int
r_int
id|ata_mmio_devchk
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_int
r_int
id|device
)paren
(brace
r_struct
id|ata_ioports
op_star
id|ioaddr
op_assign
op_amp
id|ap-&gt;ioaddr
suffix:semicolon
id|u8
id|nsect
comma
id|lbal
suffix:semicolon
id|ap-&gt;ops
op_member_access_from_pointer
id|dev_select
c_func
(paren
id|ap
comma
id|device
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0x55
comma
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;nsect_addr
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0xaa
comma
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;lbal_addr
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0xaa
comma
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;nsect_addr
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0x55
comma
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;lbal_addr
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0x55
comma
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;nsect_addr
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0xaa
comma
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;lbal_addr
)paren
suffix:semicolon
id|nsect
op_assign
id|readb
c_func
(paren
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;nsect_addr
)paren
suffix:semicolon
id|lbal
op_assign
id|readb
c_func
(paren
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;lbal_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|nsect
op_eq
l_int|0x55
)paren
op_logical_and
(paren
id|lbal
op_eq
l_int|0xaa
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* we found a device */
r_return
l_int|0
suffix:semicolon
multiline_comment|/* nothing found */
)brace
multiline_comment|/**&n; *&t;ata_devchk - PATA device presence detection&n; *&t;@ap: ATA channel to examine&n; *&t;@device: Device to examine (starting at zero)&n; *&n; *&t;Dispatch ATA device presence detection, depending&n; *&t;on whether we are using PIO or MMIO to talk to the&n; *&t;ATA shadow registers.&n; *&n; *&t;LOCKING:&n; *&t;caller.&n; */
DECL|function|ata_devchk
r_static
r_int
r_int
id|ata_devchk
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_int
r_int
id|device
)paren
(brace
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|ATA_FLAG_MMIO
)paren
r_return
id|ata_mmio_devchk
c_func
(paren
id|ap
comma
id|device
)paren
suffix:semicolon
r_return
id|ata_pio_devchk
c_func
(paren
id|ap
comma
id|device
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_dev_classify - determine device type based on ATA-spec signature&n; *&t;@tf: ATA taskfile register set for device to be identified&n; *&n; *&t;Determine from taskfile register contents whether a device is&n; *&t;ATA or ATAPI, as per &quot;Signature and persistence&quot; section&n; *&t;of ATA/PI spec (volume 1, sect 5.14).&n; *&n; *&t;LOCKING:&n; *&t;None.&n; *&n; *&t;RETURNS:&n; *&t;Device type, %ATA_DEV_ATA, %ATA_DEV_ATAPI, or %ATA_DEV_UNKNOWN&n; *&t;the event of failure.&n; */
DECL|function|ata_dev_classify
r_int
r_int
id|ata_dev_classify
c_func
(paren
r_struct
id|ata_taskfile
op_star
id|tf
)paren
(brace
multiline_comment|/* Apple&squot;s open source Darwin code hints that some devices only&n;&t; * put a proper signature into the LBA mid/high registers,&n;&t; * So, we only check those.  It&squot;s sufficient for uniqueness.&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|tf-&gt;lbam
op_eq
l_int|0
)paren
op_logical_and
(paren
id|tf-&gt;lbah
op_eq
l_int|0
)paren
)paren
op_logical_or
(paren
(paren
id|tf-&gt;lbam
op_eq
l_int|0x3c
)paren
op_logical_and
(paren
id|tf-&gt;lbah
op_eq
l_int|0xc3
)paren
)paren
)paren
(brace
id|DPRINTK
c_func
(paren
l_string|&quot;found ATA device by sig&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ATA_DEV_ATA
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|tf-&gt;lbam
op_eq
l_int|0x14
)paren
op_logical_and
(paren
id|tf-&gt;lbah
op_eq
l_int|0xeb
)paren
)paren
op_logical_or
(paren
(paren
id|tf-&gt;lbam
op_eq
l_int|0x69
)paren
op_logical_and
(paren
id|tf-&gt;lbah
op_eq
l_int|0x96
)paren
)paren
)paren
(brace
id|DPRINTK
c_func
(paren
l_string|&quot;found ATAPI device by sig&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ATA_DEV_ATAPI
suffix:semicolon
)brace
id|DPRINTK
c_func
(paren
l_string|&quot;unknown device&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ATA_DEV_UNKNOWN
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_dev_try_classify - Parse returned ATA device signature&n; *&t;@ap: ATA channel to examine&n; *&t;@device: Device to examine (starting at zero)&n; *&n; *&t;After an event -- SRST, E.D.D., or SATA COMRESET -- occurs,&n; *&t;an ATA/ATAPI-defined set of values is placed in the ATA&n; *&t;shadow registers, indicating the results of device detection&n; *&t;and diagnostics.&n; *&n; *&t;Select the ATA device, and read the values from the ATA shadow&n; *&t;registers.  Then parse according to the Error register value,&n; *&t;and the spec-defined values examined by ata_dev_classify().&n; *&n; *&t;LOCKING:&n; *&t;caller.&n; */
DECL|function|ata_dev_try_classify
r_static
id|u8
id|ata_dev_try_classify
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_int
r_int
id|device
)paren
(brace
r_struct
id|ata_device
op_star
id|dev
op_assign
op_amp
id|ap-&gt;device
(braket
id|device
)braket
suffix:semicolon
r_struct
id|ata_taskfile
id|tf
suffix:semicolon
r_int
r_int
r_class
suffix:semicolon
id|u8
id|err
suffix:semicolon
id|ap-&gt;ops
op_member_access_from_pointer
id|dev_select
c_func
(paren
id|ap
comma
id|device
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|tf
comma
l_int|0
comma
r_sizeof
(paren
id|tf
)paren
)paren
suffix:semicolon
id|err
op_assign
id|ata_chk_err
c_func
(paren
id|ap
)paren
suffix:semicolon
id|ap-&gt;ops
op_member_access_from_pointer
id|tf_read
c_func
(paren
id|ap
comma
op_amp
id|tf
)paren
suffix:semicolon
id|dev
op_member_access_from_pointer
r_class
op_assign
id|ATA_DEV_NONE
suffix:semicolon
multiline_comment|/* see if device passed diags */
r_if
c_cond
(paren
id|err
op_eq
l_int|1
)paren
multiline_comment|/* do nothing */
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|device
op_eq
l_int|0
)paren
op_logical_and
(paren
id|err
op_eq
l_int|0x81
)paren
)paren
multiline_comment|/* do nothing */
suffix:semicolon
r_else
r_return
id|err
suffix:semicolon
multiline_comment|/* determine if device if ATA or ATAPI */
r_class
op_assign
id|ata_dev_classify
c_func
(paren
op_amp
id|tf
)paren
suffix:semicolon
r_if
c_cond
(paren
r_class
op_eq
id|ATA_DEV_UNKNOWN
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
r_class
op_eq
id|ATA_DEV_ATA
)paren
op_logical_and
(paren
id|ata_chk_status
c_func
(paren
id|ap
)paren
op_eq
l_int|0
)paren
)paren
r_return
id|err
suffix:semicolon
id|dev
op_member_access_from_pointer
r_class
op_assign
r_class
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_dev_id_string - Convert IDENTIFY DEVICE page into string&n; *&t;@dev: Device whose IDENTIFY DEVICE results we will examine&n; *&t;@s: string into which data is output&n; *&t;@ofs: offset into identify device page&n; *&t;@len: length of string to return. must be an even number.&n; *&n; *&t;The strings in the IDENTIFY DEVICE page are broken up into&n; *&t;16-bit chunks.  Run through the string, and output each&n; *&t;8-bit chunk linearly, regardless of platform.&n; *&n; *&t;LOCKING:&n; *&t;caller.&n; */
DECL|function|ata_dev_id_string
r_void
id|ata_dev_id_string
c_func
(paren
id|u16
op_star
id|id
comma
r_int
r_char
op_star
id|s
comma
r_int
r_int
id|ofs
comma
r_int
r_int
id|len
)paren
(brace
r_int
r_int
id|c
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
id|c
op_assign
id|id
(braket
id|ofs
)braket
op_rshift
l_int|8
suffix:semicolon
op_star
id|s
op_assign
id|c
suffix:semicolon
id|s
op_increment
suffix:semicolon
id|c
op_assign
id|id
(braket
id|ofs
)braket
op_amp
l_int|0xff
suffix:semicolon
op_star
id|s
op_assign
id|c
suffix:semicolon
id|s
op_increment
suffix:semicolon
id|ofs
op_increment
suffix:semicolon
id|len
op_sub_assign
l_int|2
suffix:semicolon
)brace
)brace
DECL|function|ata_noop_dev_select
r_void
id|ata_noop_dev_select
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_int
r_int
id|device
)paren
(brace
)brace
multiline_comment|/**&n; *&t;ata_std_dev_select - Select device 0/1 on ATA bus&n; *&t;@ap: ATA channel to manipulate&n; *&t;@device: ATA device (numbered from zero) to select&n; *&n; *&t;Use the method defined in the ATA specification to&n; *&t;make either device 0, or device 1, active on the&n; *&t;ATA channel.&n; *&n; *&t;LOCKING:&n; *&t;caller.&n; */
DECL|function|ata_std_dev_select
r_void
id|ata_std_dev_select
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_int
r_int
id|device
)paren
(brace
id|u8
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|device
op_eq
l_int|0
)paren
id|tmp
op_assign
id|ATA_DEVICE_OBS
suffix:semicolon
r_else
id|tmp
op_assign
id|ATA_DEVICE_OBS
op_or
id|ATA_DEV1
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|ATA_FLAG_MMIO
)paren
(brace
id|writeb
c_func
(paren
id|tmp
comma
(paren
r_void
id|__iomem
op_star
)paren
id|ap-&gt;ioaddr.device_addr
)paren
suffix:semicolon
)brace
r_else
(brace
id|outb
c_func
(paren
id|tmp
comma
id|ap-&gt;ioaddr.device_addr
)paren
suffix:semicolon
)brace
id|ata_pause
c_func
(paren
id|ap
)paren
suffix:semicolon
multiline_comment|/* needed; also flushes, for mmio */
)brace
multiline_comment|/**&n; *&t;ata_dev_select - Select device 0/1 on ATA bus&n; *&t;@ap: ATA channel to manipulate&n; *&t;@device: ATA device (numbered from zero) to select&n; *&t;@wait: non-zero to wait for Status register BSY bit to clear&n; *&t;@can_sleep: non-zero if context allows sleeping&n; *&n; *&t;Use the method defined in the ATA specification to&n; *&t;make either device 0, or device 1, active on the&n; *&t;ATA channel.&n; *&n; *&t;This is a high-level version of ata_std_dev_select(),&n; *&t;which additionally provides the services of inserting&n; *&t;the proper pauses and status polling, where needed.&n; *&n; *&t;LOCKING:&n; *&t;caller.&n; */
DECL|function|ata_dev_select
r_void
id|ata_dev_select
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_int
r_int
id|device
comma
r_int
r_int
id|wait
comma
r_int
r_int
id|can_sleep
)paren
(brace
id|VPRINTK
c_func
(paren
l_string|&quot;ENTER, ata%u: device %u, wait %u&bslash;n&quot;
comma
id|ap-&gt;id
comma
id|device
comma
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait
)paren
id|ata_wait_idle
c_func
(paren
id|ap
)paren
suffix:semicolon
id|ap-&gt;ops
op_member_access_from_pointer
id|dev_select
c_func
(paren
id|ap
comma
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait
)paren
(brace
r_if
c_cond
(paren
id|can_sleep
op_logical_and
id|ap-&gt;device
(braket
id|device
)braket
dot
r_class
op_eq
id|ATA_DEV_ATAPI
)paren
id|msleep
c_func
(paren
l_int|150
)paren
suffix:semicolon
id|ata_wait_idle
c_func
(paren
id|ap
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;ata_dump_id - IDENTIFY DEVICE info debugging output&n; *&t;@dev: Device whose IDENTIFY DEVICE page we will dump&n; *&n; *&t;Dump selected 16-bit words from a detected device&squot;s&n; *&t;IDENTIFY PAGE page.&n; *&n; *&t;LOCKING:&n; *&t;caller.&n; */
DECL|function|ata_dump_id
r_static
r_inline
r_void
id|ata_dump_id
c_func
(paren
r_struct
id|ata_device
op_star
id|dev
)paren
(brace
id|DPRINTK
c_func
(paren
l_string|&quot;49==0x%04x  &quot;
l_string|&quot;53==0x%04x  &quot;
l_string|&quot;63==0x%04x  &quot;
l_string|&quot;64==0x%04x  &quot;
l_string|&quot;75==0x%04x  &bslash;n&quot;
comma
id|dev-&gt;id
(braket
l_int|49
)braket
comma
id|dev-&gt;id
(braket
l_int|53
)braket
comma
id|dev-&gt;id
(braket
l_int|63
)braket
comma
id|dev-&gt;id
(braket
l_int|64
)braket
comma
id|dev-&gt;id
(braket
l_int|75
)braket
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;80==0x%04x  &quot;
l_string|&quot;81==0x%04x  &quot;
l_string|&quot;82==0x%04x  &quot;
l_string|&quot;83==0x%04x  &quot;
l_string|&quot;84==0x%04x  &bslash;n&quot;
comma
id|dev-&gt;id
(braket
l_int|80
)braket
comma
id|dev-&gt;id
(braket
l_int|81
)braket
comma
id|dev-&gt;id
(braket
l_int|82
)braket
comma
id|dev-&gt;id
(braket
l_int|83
)braket
comma
id|dev-&gt;id
(braket
l_int|84
)braket
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;88==0x%04x  &quot;
l_string|&quot;93==0x%04x&bslash;n&quot;
comma
id|dev-&gt;id
(braket
l_int|88
)braket
comma
id|dev-&gt;id
(braket
l_int|93
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_dev_identify - obtain IDENTIFY x DEVICE page&n; *&t;@ap: port on which device we wish to probe resides&n; *&t;@device: device bus address, starting at zero&n; *&n; *&t;Following bus reset, we issue the IDENTIFY [PACKET] DEVICE&n; *&t;command, and read back the 512-byte device information page.&n; *&t;The device information page is fed to us via the standard&n; *&t;PIO-IN protocol, but we hand-code it here. (TODO: investigate&n; *&t;using standard PIO-IN paths)&n; *&n; *&t;After reading the device information page, we use several&n; *&t;bits of information from it to initialize data structures&n; *&t;that will be used during the lifetime of the ata_device.&n; *&t;Other data from the info page is used to disqualify certain&n; *&t;older ATA devices we do not wish to support.&n; *&n; *&t;LOCKING:&n; *&t;Inherited from caller.  Some functions called by this function&n; *&t;obtain the host_set lock.&n; */
DECL|function|ata_dev_identify
r_static
r_void
id|ata_dev_identify
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_int
r_int
id|device
)paren
(brace
r_struct
id|ata_device
op_star
id|dev
op_assign
op_amp
id|ap-&gt;device
(braket
id|device
)braket
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
id|u16
id|tmp
suffix:semicolon
r_int
r_int
id|xfer_modes
suffix:semicolon
id|u8
id|status
suffix:semicolon
r_int
r_int
id|using_edd
suffix:semicolon
id|DECLARE_COMPLETION
c_func
(paren
id|wait
)paren
suffix:semicolon
r_struct
id|ata_queued_cmd
op_star
id|qc
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ata_dev_present
c_func
(paren
id|dev
)paren
)paren
(brace
id|DPRINTK
c_func
(paren
l_string|&quot;ENTER/EXIT (host %u, dev %u) -- nodev&bslash;n&quot;
comma
id|ap-&gt;id
comma
id|device
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
(paren
id|ATA_FLAG_SRST
op_or
id|ATA_FLAG_SATA_RESET
)paren
)paren
id|using_edd
op_assign
l_int|0
suffix:semicolon
r_else
id|using_edd
op_assign
l_int|1
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;ENTER, host %u, dev %u&bslash;n&quot;
comma
id|ap-&gt;id
comma
id|device
)paren
suffix:semicolon
m_assert
(paren
id|dev
op_member_access_from_pointer
r_class
op_eq
id|ATA_DEV_ATA
op_logical_or
id|dev
op_member_access_from_pointer
r_class
op_eq
id|ATA_DEV_ATAPI
op_logical_or
id|dev
op_member_access_from_pointer
r_class
op_eq
id|ATA_DEV_NONE
)paren
suffix:semicolon
id|ata_dev_select
c_func
(paren
id|ap
comma
id|device
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* select device 0/1 */
id|qc
op_assign
id|ata_qc_new_init
c_func
(paren
id|ap
comma
id|dev
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|qc
op_eq
l_int|NULL
)paren
suffix:semicolon
id|ata_sg_init_one
c_func
(paren
id|qc
comma
id|dev-&gt;id
comma
r_sizeof
(paren
id|dev-&gt;id
)paren
)paren
suffix:semicolon
id|qc-&gt;dma_dir
op_assign
id|DMA_FROM_DEVICE
suffix:semicolon
id|qc-&gt;tf.protocol
op_assign
id|ATA_PROT_PIO
suffix:semicolon
id|qc-&gt;nsect
op_assign
l_int|1
suffix:semicolon
id|retry
suffix:colon
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
r_class
op_eq
id|ATA_DEV_ATA
)paren
(brace
id|qc-&gt;tf.command
op_assign
id|ATA_CMD_ID_ATA
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;do ATA identify&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|qc-&gt;tf.command
op_assign
id|ATA_CMD_ID_ATAPI
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;do ATAPI identify&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|qc-&gt;waiting
op_assign
op_amp
id|wait
suffix:semicolon
id|qc-&gt;complete_fn
op_assign
id|ata_qc_complete_noop
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ap-&gt;host_set-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|rc
op_assign
id|ata_qc_issue
c_func
(paren
id|qc
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ap-&gt;host_set-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|err_out
suffix:semicolon
r_else
id|wait_for_completion
c_func
(paren
op_amp
id|wait
)paren
suffix:semicolon
id|status
op_assign
id|ata_chk_status
c_func
(paren
id|ap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|ATA_ERR
)paren
(brace
multiline_comment|/*&n;&t;&t; * arg!  EDD works for all test cases, but seems to return&n;&t;&t; * the ATA signature for some ATAPI devices.  Until the&n;&t;&t; * reason for this is found and fixed, we fix up the mess&n;&t;&t; * here.  If IDENTIFY DEVICE returns command aborted&n;&t;&t; * (as ATAPI devices do), then we issue an&n;&t;&t; * IDENTIFY PACKET DEVICE.&n;&t;&t; *&n;&t;&t; * ATA software reset (SRST, the default) does not appear&n;&t;&t; * to have this problem.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|using_edd
)paren
op_logical_and
(paren
id|qc-&gt;tf.command
op_eq
id|ATA_CMD_ID_ATA
)paren
)paren
(brace
id|u8
id|err
op_assign
id|ata_chk_err
c_func
(paren
id|ap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|ATA_ABORTED
)paren
(brace
id|dev
op_member_access_from_pointer
r_class
op_assign
id|ATA_DEV_ATAPI
suffix:semicolon
id|qc-&gt;cursg
op_assign
l_int|0
suffix:semicolon
id|qc-&gt;cursg_ofs
op_assign
l_int|0
suffix:semicolon
id|qc-&gt;cursect
op_assign
l_int|0
suffix:semicolon
id|qc-&gt;nsect
op_assign
l_int|1
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
)brace
r_goto
id|err_out
suffix:semicolon
)brace
id|swap_buf_le16
c_func
(paren
id|dev-&gt;id
comma
id|ATA_ID_WORDS
)paren
suffix:semicolon
multiline_comment|/* print device capabilities */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ata%u: dev %u cfg &quot;
l_string|&quot;49:%04x 82:%04x 83:%04x 84:%04x 85:%04x 86:%04x 87:%04x 88:%04x&bslash;n&quot;
comma
id|ap-&gt;id
comma
id|device
comma
id|dev-&gt;id
(braket
l_int|49
)braket
comma
id|dev-&gt;id
(braket
l_int|82
)braket
comma
id|dev-&gt;id
(braket
l_int|83
)braket
comma
id|dev-&gt;id
(braket
l_int|84
)braket
comma
id|dev-&gt;id
(braket
l_int|85
)braket
comma
id|dev-&gt;id
(braket
l_int|86
)braket
comma
id|dev-&gt;id
(braket
l_int|87
)braket
comma
id|dev-&gt;id
(braket
l_int|88
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * common ATA, ATAPI feature tests&n;&t; */
multiline_comment|/* we require LBA and DMA support (bits 8 &amp; 9 of word 49) */
r_if
c_cond
(paren
op_logical_neg
id|ata_id_has_dma
c_func
(paren
id|dev-&gt;id
)paren
op_logical_or
op_logical_neg
id|ata_id_has_lba
c_func
(paren
id|dev-&gt;id
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ata%u: no dma/lba&bslash;n&quot;
comma
id|ap-&gt;id
)paren
suffix:semicolon
r_goto
id|err_out_nosup
suffix:semicolon
)brace
multiline_comment|/* quick-n-dirty find max transfer mode; for printk only */
id|xfer_modes
op_assign
id|dev-&gt;id
(braket
id|ATA_ID_UDMA_MODES
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xfer_modes
)paren
id|xfer_modes
op_assign
(paren
id|dev-&gt;id
(braket
id|ATA_ID_MWDMA_MODES
)braket
)paren
op_lshift
id|ATA_SHIFT_MWDMA
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xfer_modes
)paren
(brace
id|xfer_modes
op_assign
(paren
id|dev-&gt;id
(braket
id|ATA_ID_PIO_MODES
)braket
)paren
op_lshift
(paren
id|ATA_SHIFT_PIO
op_plus
l_int|3
)paren
suffix:semicolon
id|xfer_modes
op_or_assign
(paren
l_int|0x7
op_lshift
id|ATA_SHIFT_PIO
)paren
suffix:semicolon
)brace
id|ata_dump_id
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* ATA-specific feature tests */
r_if
c_cond
(paren
id|dev
op_member_access_from_pointer
r_class
op_eq
id|ATA_DEV_ATA
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ata_id_is_ata
c_func
(paren
id|dev-&gt;id
)paren
)paren
multiline_comment|/* sanity check */
r_goto
id|err_out_nosup
suffix:semicolon
id|tmp
op_assign
id|dev-&gt;id
(braket
id|ATA_ID_MAJOR_VER
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|14
suffix:semicolon
id|i
op_ge
l_int|1
suffix:semicolon
id|i
op_decrement
)paren
r_if
c_cond
(paren
id|tmp
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* we require at least ATA-3 */
r_if
c_cond
(paren
id|i
OL
l_int|3
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ata%u: no ATA-3&bslash;n&quot;
comma
id|ap-&gt;id
)paren
suffix:semicolon
r_goto
id|err_out_nosup
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ata_id_has_lba48
c_func
(paren
id|dev-&gt;id
)paren
)paren
(brace
id|dev-&gt;flags
op_or_assign
id|ATA_DFLAG_LBA48
suffix:semicolon
id|dev-&gt;n_sectors
op_assign
id|ata_id_u64
c_func
(paren
id|dev-&gt;id
comma
l_int|100
)paren
suffix:semicolon
)brace
r_else
(brace
id|dev-&gt;n_sectors
op_assign
id|ata_id_u32
c_func
(paren
id|dev-&gt;id
comma
l_int|60
)paren
suffix:semicolon
)brace
id|ap-&gt;host-&gt;max_cmd_len
op_assign
l_int|16
suffix:semicolon
multiline_comment|/* print device info to dmesg */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ata%u: dev %u ATA, max %s, %Lu sectors:%s&bslash;n&quot;
comma
id|ap-&gt;id
comma
id|device
comma
id|ata_mode_string
c_func
(paren
id|xfer_modes
)paren
comma
(paren
r_int
r_int
r_int
)paren
id|dev-&gt;n_sectors
comma
id|dev-&gt;flags
op_amp
id|ATA_DFLAG_LBA48
ques
c_cond
l_string|&quot; lba48&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* ATAPI-specific feature tests */
r_else
(brace
r_if
c_cond
(paren
id|ata_id_is_ata
c_func
(paren
id|dev-&gt;id
)paren
)paren
multiline_comment|/* sanity check */
r_goto
id|err_out_nosup
suffix:semicolon
id|rc
op_assign
id|atapi_cdb_len
c_func
(paren
id|dev-&gt;id
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
OL
l_int|12
)paren
op_logical_or
(paren
id|rc
OG
id|ATAPI_CDB_LEN
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ata%u: unsupported CDB len&bslash;n&quot;
comma
id|ap-&gt;id
)paren
suffix:semicolon
r_goto
id|err_out_nosup
suffix:semicolon
)brace
id|ap-&gt;cdb_len
op_assign
(paren
r_int
r_int
)paren
id|rc
suffix:semicolon
id|ap-&gt;host-&gt;max_cmd_len
op_assign
(paren
r_int
r_char
)paren
id|ap-&gt;cdb_len
suffix:semicolon
multiline_comment|/* print device info to dmesg */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ata%u: dev %u ATAPI, max %s&bslash;n&quot;
comma
id|ap-&gt;id
comma
id|device
comma
id|ata_mode_string
c_func
(paren
id|xfer_modes
)paren
)paren
suffix:semicolon
)brace
id|DPRINTK
c_func
(paren
l_string|&quot;EXIT, drv_stat = 0x%x&bslash;n&quot;
comma
id|ata_chk_status
c_func
(paren
id|ap
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
id|err_out_nosup
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ata%u: dev %u not supported, ignoring&bslash;n&quot;
comma
id|ap-&gt;id
comma
id|device
)paren
suffix:semicolon
id|err_out
suffix:colon
id|ata_irq_on
c_func
(paren
id|ap
)paren
suffix:semicolon
multiline_comment|/* re-enable interrupts */
id|dev
op_member_access_from_pointer
r_class
op_increment
suffix:semicolon
multiline_comment|/* converts ATA_DEV_xxx into ATA_DEV_xxx_UNSUP */
id|DPRINTK
c_func
(paren
l_string|&quot;EXIT, err&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_bus_probe - Reset and probe ATA bus&n; *&t;@ap: Bus to probe&n; *&n; *&t;LOCKING:&n; *&n; *&t;RETURNS:&n; *&t;Zero on success, non-zero on error.&n; */
DECL|function|ata_bus_probe
r_static
r_int
id|ata_bus_probe
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
)paren
(brace
r_int
r_int
id|i
comma
id|found
op_assign
l_int|0
suffix:semicolon
id|ap-&gt;ops
op_member_access_from_pointer
id|phy_reset
c_func
(paren
id|ap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|ATA_FLAG_PORT_DISABLED
)paren
r_goto
id|err_out
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ATA_MAX_DEVICES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ata_dev_identify
c_func
(paren
id|ap
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ata_dev_present
c_func
(paren
op_amp
id|ap-&gt;device
(braket
id|i
)braket
)paren
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;ops-&gt;dev_config
)paren
id|ap-&gt;ops
op_member_access_from_pointer
id|dev_config
c_func
(paren
id|ap
comma
op_amp
id|ap-&gt;device
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|found
)paren
op_logical_or
(paren
id|ap-&gt;flags
op_amp
id|ATA_FLAG_PORT_DISABLED
)paren
)paren
r_goto
id|err_out_disable
suffix:semicolon
id|ata_set_mode
c_func
(paren
id|ap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|ATA_FLAG_PORT_DISABLED
)paren
r_goto
id|err_out_disable
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err_out_disable
suffix:colon
id|ap-&gt;ops
op_member_access_from_pointer
id|port_disable
c_func
(paren
id|ap
)paren
suffix:semicolon
id|err_out
suffix:colon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_port_probe -&n; *&t;@ap:&n; *&n; *&t;LOCKING:&n; */
DECL|function|ata_port_probe
r_void
id|ata_port_probe
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
)paren
(brace
id|ap-&gt;flags
op_and_assign
op_complement
id|ATA_FLAG_PORT_DISABLED
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;__sata_phy_reset -&n; *&t;@ap:&n; *&n; *&t;LOCKING:&n; *&n; */
DECL|function|__sata_phy_reset
r_void
id|__sata_phy_reset
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
)paren
(brace
id|u32
id|sstatus
suffix:semicolon
r_int
r_int
id|timeout
op_assign
id|jiffies
op_plus
(paren
id|HZ
op_star
l_int|5
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|ATA_FLAG_SATA_RESET
)paren
(brace
id|scr_write
c_func
(paren
id|ap
comma
id|SCR_CONTROL
comma
l_int|0x301
)paren
suffix:semicolon
multiline_comment|/* issue phy wake/reset */
id|scr_read
c_func
(paren
id|ap
comma
id|SCR_STATUS
)paren
suffix:semicolon
multiline_comment|/* dummy read; flush */
id|udelay
c_func
(paren
l_int|400
)paren
suffix:semicolon
multiline_comment|/* FIXME: a guess */
)brace
id|scr_write
c_func
(paren
id|ap
comma
id|SCR_CONTROL
comma
l_int|0x300
)paren
suffix:semicolon
multiline_comment|/* issue phy wake/clear reset */
multiline_comment|/* wait for phy to become ready, if necessary */
r_do
(brace
id|msleep
c_func
(paren
l_int|200
)paren
suffix:semicolon
id|sstatus
op_assign
id|scr_read
c_func
(paren
id|ap
comma
id|SCR_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sstatus
op_amp
l_int|0xf
)paren
op_ne
l_int|1
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
suffix:semicolon
multiline_comment|/* TODO: phy layer with polling, timeouts, etc. */
r_if
c_cond
(paren
id|sata_dev_present
c_func
(paren
id|ap
)paren
)paren
id|ata_port_probe
c_func
(paren
id|ap
)paren
suffix:semicolon
r_else
(brace
id|sstatus
op_assign
id|scr_read
c_func
(paren
id|ap
comma
id|SCR_STATUS
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ata%u: no device found (phy stat %08x)&bslash;n&quot;
comma
id|ap-&gt;id
comma
id|sstatus
)paren
suffix:semicolon
id|ata_port_disable
c_func
(paren
id|ap
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|ATA_FLAG_PORT_DISABLED
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|ata_busy_sleep
c_func
(paren
id|ap
comma
id|ATA_TMOUT_BOOT_QUICK
comma
id|ATA_TMOUT_BOOT
)paren
)paren
(brace
id|ata_port_disable
c_func
(paren
id|ap
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ap-&gt;cbl
op_assign
id|ATA_CBL_SATA
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;__sata_phy_reset -&n; *&t;@ap:&n; *&n; *&t;LOCKING:&n; *&n; */
DECL|function|sata_phy_reset
r_void
id|sata_phy_reset
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
)paren
(brace
id|__sata_phy_reset
c_func
(paren
id|ap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|ATA_FLAG_PORT_DISABLED
)paren
r_return
suffix:semicolon
id|ata_bus_reset
c_func
(paren
id|ap
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_port_disable -&n; *&t;@ap:&n; *&n; *&t;LOCKING:&n; */
DECL|function|ata_port_disable
r_void
id|ata_port_disable
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
)paren
(brace
id|ap-&gt;device
(braket
l_int|0
)braket
dot
r_class
op_assign
id|ATA_DEV_NONE
suffix:semicolon
id|ap-&gt;device
(braket
l_int|1
)braket
dot
r_class
op_assign
id|ATA_DEV_NONE
suffix:semicolon
id|ap-&gt;flags
op_or_assign
id|ATA_FLAG_PORT_DISABLED
suffix:semicolon
)brace
r_static
r_struct
(brace
DECL|member|shift
r_int
r_int
id|shift
suffix:semicolon
DECL|member|base
id|u8
id|base
suffix:semicolon
DECL|variable|xfer_mode_classes
)brace
id|xfer_mode_classes
(braket
)braket
op_assign
(brace
(brace
id|ATA_SHIFT_UDMA
comma
id|XFER_UDMA_0
)brace
comma
(brace
id|ATA_SHIFT_MWDMA
comma
id|XFER_MW_DMA_0
)brace
comma
(brace
id|ATA_SHIFT_PIO
comma
id|XFER_PIO_0
)brace
comma
)brace
suffix:semicolon
DECL|function|base_from_shift
r_static
r_inline
id|u8
id|base_from_shift
c_func
(paren
r_int
r_int
id|shift
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|xfer_mode_classes
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|xfer_mode_classes
(braket
id|i
)braket
dot
id|shift
op_eq
id|shift
)paren
r_return
id|xfer_mode_classes
(braket
id|i
)braket
dot
id|base
suffix:semicolon
r_return
l_int|0xff
suffix:semicolon
)brace
DECL|function|ata_dev_set_mode
r_static
r_void
id|ata_dev_set_mode
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_struct
id|ata_device
op_star
id|dev
)paren
(brace
r_int
id|ofs
comma
id|idx
suffix:semicolon
id|u8
id|base
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ata_dev_present
c_func
(paren
id|dev
)paren
op_logical_or
(paren
id|ap-&gt;flags
op_amp
id|ATA_FLAG_PORT_DISABLED
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;xfer_shift
op_eq
id|ATA_SHIFT_PIO
)paren
id|dev-&gt;flags
op_or_assign
id|ATA_DFLAG_PIO
suffix:semicolon
id|ata_dev_set_xfermode
c_func
(paren
id|ap
comma
id|dev
)paren
suffix:semicolon
id|base
op_assign
id|base_from_shift
c_func
(paren
id|dev-&gt;xfer_shift
)paren
suffix:semicolon
id|ofs
op_assign
id|dev-&gt;xfer_mode
op_minus
id|base
suffix:semicolon
id|idx
op_assign
id|ofs
op_plus
id|dev-&gt;xfer_shift
suffix:semicolon
id|WARN_ON
c_func
(paren
id|idx
op_ge
id|ARRAY_SIZE
c_func
(paren
id|xfer_mode_str
)paren
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;idx=%d xfer_shift=%u, xfer_mode=0x%x, base=0x%x, offset=%d&bslash;n&quot;
comma
id|idx
comma
id|dev-&gt;xfer_shift
comma
(paren
r_int
)paren
id|dev-&gt;xfer_mode
comma
(paren
r_int
)paren
id|base
comma
id|ofs
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ata%u: dev %u configured for %s&bslash;n&quot;
comma
id|ap-&gt;id
comma
id|dev-&gt;devno
comma
id|xfer_mode_str
(braket
id|idx
)braket
)paren
suffix:semicolon
)brace
DECL|function|ata_host_set_pio
r_static
r_int
id|ata_host_set_pio
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
)paren
(brace
r_int
r_int
id|mask
suffix:semicolon
r_int
id|x
comma
id|i
suffix:semicolon
id|u8
id|base
comma
id|xfer_mode
suffix:semicolon
id|mask
op_assign
id|ata_get_mode_mask
c_func
(paren
id|ap
comma
id|ATA_SHIFT_PIO
)paren
suffix:semicolon
id|x
op_assign
id|fgb
c_func
(paren
id|mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ata%u: no PIO support&bslash;n&quot;
comma
id|ap-&gt;id
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|base
op_assign
id|base_from_shift
c_func
(paren
id|ATA_SHIFT_PIO
)paren
suffix:semicolon
id|xfer_mode
op_assign
id|base
op_plus
id|x
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;base 0x%x xfer_mode 0x%x mask 0x%x x %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|base
comma
(paren
r_int
)paren
id|xfer_mode
comma
id|mask
comma
id|x
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ATA_MAX_DEVICES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ata_device
op_star
id|dev
op_assign
op_amp
id|ap-&gt;device
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ata_dev_present
c_func
(paren
id|dev
)paren
)paren
(brace
id|dev-&gt;pio_mode
op_assign
id|xfer_mode
suffix:semicolon
id|dev-&gt;xfer_mode
op_assign
id|xfer_mode
suffix:semicolon
id|dev-&gt;xfer_shift
op_assign
id|ATA_SHIFT_PIO
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;ops-&gt;set_piomode
)paren
id|ap-&gt;ops
op_member_access_from_pointer
id|set_piomode
c_func
(paren
id|ap
comma
id|dev
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ata_host_set_dma
r_static
r_void
id|ata_host_set_dma
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
id|u8
id|xfer_mode
comma
r_int
r_int
id|xfer_shift
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ATA_MAX_DEVICES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ata_device
op_star
id|dev
op_assign
op_amp
id|ap-&gt;device
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ata_dev_present
c_func
(paren
id|dev
)paren
)paren
(brace
id|dev-&gt;dma_mode
op_assign
id|xfer_mode
suffix:semicolon
id|dev-&gt;xfer_mode
op_assign
id|xfer_mode
suffix:semicolon
id|dev-&gt;xfer_shift
op_assign
id|xfer_shift
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;ops-&gt;set_dmamode
)paren
id|ap-&gt;ops
op_member_access_from_pointer
id|set_dmamode
c_func
(paren
id|ap
comma
id|dev
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/**&n; *&t;ata_set_mode - Program timings and issue SET FEATURES - XFER&n; *&t;@ap: port on which timings will be programmed&n; *&n; *&t;LOCKING:&n; *&n; */
DECL|function|ata_set_mode
r_static
r_void
id|ata_set_mode
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
)paren
(brace
r_int
r_int
id|i
comma
id|xfer_shift
suffix:semicolon
id|u8
id|xfer_mode
suffix:semicolon
r_int
id|rc
suffix:semicolon
multiline_comment|/* step 1: always set host PIO timings */
id|rc
op_assign
id|ata_host_set_pio
c_func
(paren
id|ap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|err_out
suffix:semicolon
multiline_comment|/* step 2: choose the best data xfer mode */
id|xfer_mode
op_assign
id|xfer_shift
op_assign
l_int|0
suffix:semicolon
id|rc
op_assign
id|ata_choose_xfer_mode
c_func
(paren
id|ap
comma
op_amp
id|xfer_mode
comma
op_amp
id|xfer_shift
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|err_out
suffix:semicolon
multiline_comment|/* step 3: if that xfer mode isn&squot;t PIO, set host DMA timings */
r_if
c_cond
(paren
id|xfer_shift
op_ne
id|ATA_SHIFT_PIO
)paren
id|ata_host_set_dma
c_func
(paren
id|ap
comma
id|xfer_mode
comma
id|xfer_shift
)paren
suffix:semicolon
multiline_comment|/* step 4: update devices&squot; xfer mode */
id|ata_dev_set_mode
c_func
(paren
id|ap
comma
op_amp
id|ap-&gt;device
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|ata_dev_set_mode
c_func
(paren
id|ap
comma
op_amp
id|ap-&gt;device
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|ATA_FLAG_PORT_DISABLED
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;ops-&gt;post_set_mode
)paren
id|ap-&gt;ops
op_member_access_from_pointer
id|post_set_mode
c_func
(paren
id|ap
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ata_device
op_star
id|dev
op_assign
op_amp
id|ap-&gt;device
(braket
id|i
)braket
suffix:semicolon
id|ata_dev_set_protocol
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
id|err_out
suffix:colon
id|ata_port_disable
c_func
(paren
id|ap
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_busy_sleep - sleep until BSY clears, or timeout&n; *&t;@ap: port containing status register to be polled&n; *&t;@tmout_pat: impatience timeout&n; *&t;@tmout: overall timeout&n; *&n; *&t;LOCKING:&n; *&n; */
DECL|function|ata_busy_sleep
r_static
r_int
r_int
id|ata_busy_sleep
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_int
r_int
id|tmout_pat
comma
r_int
r_int
id|tmout
)paren
(brace
r_int
r_int
id|timer_start
comma
id|timeout
suffix:semicolon
id|u8
id|status
suffix:semicolon
id|status
op_assign
id|ata_busy_wait
c_func
(paren
id|ap
comma
id|ATA_BUSY
comma
l_int|300
)paren
suffix:semicolon
id|timer_start
op_assign
id|jiffies
suffix:semicolon
id|timeout
op_assign
id|timer_start
op_plus
id|tmout_pat
suffix:semicolon
r_while
c_loop
(paren
(paren
id|status
op_amp
id|ATA_BUSY
)paren
op_logical_and
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
)paren
(brace
id|msleep
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|status
op_assign
id|ata_busy_wait
c_func
(paren
id|ap
comma
id|ATA_BUSY
comma
l_int|3
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|ATA_BUSY
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ata%u is slow to respond, &quot;
l_string|&quot;please be patient&bslash;n&quot;
comma
id|ap-&gt;id
)paren
suffix:semicolon
id|timeout
op_assign
id|timer_start
op_plus
id|tmout
suffix:semicolon
r_while
c_loop
(paren
(paren
id|status
op_amp
id|ATA_BUSY
)paren
op_logical_and
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
)paren
(brace
id|msleep
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|status
op_assign
id|ata_chk_status
c_func
(paren
id|ap
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|ATA_BUSY
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ata%u failed to respond (%lu secs)&bslash;n&quot;
comma
id|ap-&gt;id
comma
id|tmout
op_div
id|HZ
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ata_bus_post_reset
r_static
r_void
id|ata_bus_post_reset
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_int
r_int
id|devmask
)paren
(brace
r_struct
id|ata_ioports
op_star
id|ioaddr
op_assign
op_amp
id|ap-&gt;ioaddr
suffix:semicolon
r_int
r_int
id|dev0
op_assign
id|devmask
op_amp
(paren
l_int|1
op_lshift
l_int|0
)paren
suffix:semicolon
r_int
r_int
id|dev1
op_assign
id|devmask
op_amp
(paren
l_int|1
op_lshift
l_int|1
)paren
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
multiline_comment|/* if device 0 was found in ata_devchk, wait for its&n;&t; * BSY bit to clear&n;&t; */
r_if
c_cond
(paren
id|dev0
)paren
id|ata_busy_sleep
c_func
(paren
id|ap
comma
id|ATA_TMOUT_BOOT_QUICK
comma
id|ATA_TMOUT_BOOT
)paren
suffix:semicolon
multiline_comment|/* if device 1 was found in ata_devchk, wait for&n;&t; * register access, then wait for BSY to clear&n;&t; */
id|timeout
op_assign
id|jiffies
op_plus
id|ATA_TMOUT_BOOT
suffix:semicolon
r_while
c_loop
(paren
id|dev1
)paren
(brace
id|u8
id|nsect
comma
id|lbal
suffix:semicolon
id|ap-&gt;ops
op_member_access_from_pointer
id|dev_select
c_func
(paren
id|ap
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|ATA_FLAG_MMIO
)paren
(brace
id|nsect
op_assign
id|readb
c_func
(paren
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;nsect_addr
)paren
suffix:semicolon
id|lbal
op_assign
id|readb
c_func
(paren
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;lbal_addr
)paren
suffix:semicolon
)brace
r_else
(brace
id|nsect
op_assign
id|inb
c_func
(paren
id|ioaddr-&gt;nsect_addr
)paren
suffix:semicolon
id|lbal
op_assign
id|inb
c_func
(paren
id|ioaddr-&gt;lbal_addr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|nsect
op_eq
l_int|1
)paren
op_logical_and
(paren
id|lbal
op_eq
l_int|1
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
id|dev1
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|msleep
c_func
(paren
l_int|50
)paren
suffix:semicolon
multiline_comment|/* give drive a breather */
)brace
r_if
c_cond
(paren
id|dev1
)paren
id|ata_busy_sleep
c_func
(paren
id|ap
comma
id|ATA_TMOUT_BOOT_QUICK
comma
id|ATA_TMOUT_BOOT
)paren
suffix:semicolon
multiline_comment|/* is all this really necessary? */
id|ap-&gt;ops
op_member_access_from_pointer
id|dev_select
c_func
(paren
id|ap
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev1
)paren
id|ap-&gt;ops
op_member_access_from_pointer
id|dev_select
c_func
(paren
id|ap
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev0
)paren
id|ap-&gt;ops
op_member_access_from_pointer
id|dev_select
c_func
(paren
id|ap
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_bus_edd -&n; *&t;@ap:&n; *&n; *&t;LOCKING:&n; *&n; */
DECL|function|ata_bus_edd
r_static
r_int
r_int
id|ata_bus_edd
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
)paren
(brace
r_struct
id|ata_taskfile
id|tf
suffix:semicolon
multiline_comment|/* set up execute-device-diag (bus reset) taskfile */
multiline_comment|/* also, take interrupts to a known state (disabled) */
id|DPRINTK
c_func
(paren
l_string|&quot;execute-device-diag&bslash;n&quot;
)paren
suffix:semicolon
id|ata_tf_init
c_func
(paren
id|ap
comma
op_amp
id|tf
comma
l_int|0
)paren
suffix:semicolon
id|tf.ctl
op_or_assign
id|ATA_NIEN
suffix:semicolon
id|tf.command
op_assign
id|ATA_CMD_EDD
suffix:semicolon
id|tf.protocol
op_assign
id|ATA_PROT_NODATA
suffix:semicolon
multiline_comment|/* do bus reset */
id|ata_tf_to_host
c_func
(paren
id|ap
comma
op_amp
id|tf
)paren
suffix:semicolon
multiline_comment|/* spec says at least 2ms.  but who knows with those&n;&t; * crazy ATAPI devices...&n;&t; */
id|msleep
c_func
(paren
l_int|150
)paren
suffix:semicolon
r_return
id|ata_busy_sleep
c_func
(paren
id|ap
comma
id|ATA_TMOUT_BOOT_QUICK
comma
id|ATA_TMOUT_BOOT
)paren
suffix:semicolon
)brace
DECL|function|ata_bus_softreset
r_static
r_int
r_int
id|ata_bus_softreset
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_int
r_int
id|devmask
)paren
(brace
r_struct
id|ata_ioports
op_star
id|ioaddr
op_assign
op_amp
id|ap-&gt;ioaddr
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;ata%u: bus reset via SRST&bslash;n&quot;
comma
id|ap-&gt;id
)paren
suffix:semicolon
multiline_comment|/* software reset.  causes dev0 to be selected */
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|ATA_FLAG_MMIO
)paren
(brace
id|writeb
c_func
(paren
id|ap-&gt;ctl
comma
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;ctl_addr
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
multiline_comment|/* FIXME: flush */
id|writeb
c_func
(paren
id|ap-&gt;ctl
op_or
id|ATA_SRST
comma
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;ctl_addr
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
multiline_comment|/* FIXME: flush */
id|writeb
c_func
(paren
id|ap-&gt;ctl
comma
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;ctl_addr
)paren
suffix:semicolon
)brace
r_else
(brace
id|outb
c_func
(paren
id|ap-&gt;ctl
comma
id|ioaddr-&gt;ctl_addr
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ap-&gt;ctl
op_or
id|ATA_SRST
comma
id|ioaddr-&gt;ctl_addr
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ap-&gt;ctl
comma
id|ioaddr-&gt;ctl_addr
)paren
suffix:semicolon
)brace
multiline_comment|/* spec mandates &quot;&gt;= 2ms&quot; before checking status.&n;&t; * We wait 150ms, because that was the magic delay used for&n;&t; * ATAPI devices in Hale Landis&squot;s ATADRVR, for the period of time&n;&t; * between when the ATA command register is written, and then&n;&t; * status is checked.  Because waiting for &quot;a while&quot; before&n;&t; * checking status is fine, post SRST, we perform this magic&n;&t; * delay here as well.&n;&t; */
id|msleep
c_func
(paren
l_int|150
)paren
suffix:semicolon
id|ata_bus_post_reset
c_func
(paren
id|ap
comma
id|devmask
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_bus_reset - reset host port and associated ATA channel&n; *&t;@ap: port to reset&n; *&n; *&t;This is typically the first time we actually start issuing&n; *&t;commands to the ATA channel.  We wait for BSY to clear, then&n; *&t;issue EXECUTE DEVICE DIAGNOSTIC command, polling for its&n; *&t;result.  Determine what devices, if any, are on the channel&n; *&t;by looking at the device 0/1 error register.  Look at the signature&n; *&t;stored in each device&squot;s taskfile registers, to determine if&n; *&t;the device is ATA or ATAPI.&n; *&n; *&t;LOCKING:&n; *&t;Inherited from caller.  Some functions called by this function&n; *&t;obtain the host_set lock.&n; *&n; *&t;SIDE EFFECTS:&n; *&t;Sets ATA_FLAG_PORT_DISABLED if bus reset fails.&n; */
DECL|function|ata_bus_reset
r_void
id|ata_bus_reset
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
)paren
(brace
r_struct
id|ata_ioports
op_star
id|ioaddr
op_assign
op_amp
id|ap-&gt;ioaddr
suffix:semicolon
r_int
r_int
id|slave_possible
op_assign
id|ap-&gt;flags
op_amp
id|ATA_FLAG_SLAVE_POSS
suffix:semicolon
id|u8
id|err
suffix:semicolon
r_int
r_int
id|dev0
comma
id|dev1
op_assign
l_int|0
comma
id|rc
op_assign
l_int|0
comma
id|devmask
op_assign
l_int|0
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;ENTER, host %u, port %u&bslash;n&quot;
comma
id|ap-&gt;id
comma
id|ap-&gt;port_no
)paren
suffix:semicolon
multiline_comment|/* determine if device 0/1 are present */
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|ATA_FLAG_SATA_RESET
)paren
id|dev0
op_assign
l_int|1
suffix:semicolon
r_else
(brace
id|dev0
op_assign
id|ata_devchk
c_func
(paren
id|ap
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slave_possible
)paren
id|dev1
op_assign
id|ata_devchk
c_func
(paren
id|ap
comma
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev0
)paren
id|devmask
op_or_assign
(paren
l_int|1
op_lshift
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev1
)paren
id|devmask
op_or_assign
(paren
l_int|1
op_lshift
l_int|1
)paren
suffix:semicolon
multiline_comment|/* select device 0 again */
id|ap-&gt;ops
op_member_access_from_pointer
id|dev_select
c_func
(paren
id|ap
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* issue bus reset */
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|ATA_FLAG_SRST
)paren
id|rc
op_assign
id|ata_bus_softreset
c_func
(paren
id|ap
comma
id|devmask
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|ap-&gt;flags
op_amp
id|ATA_FLAG_SATA_RESET
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* set up device control */
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|ATA_FLAG_MMIO
)paren
id|writeb
c_func
(paren
id|ap-&gt;ctl
comma
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;ctl_addr
)paren
suffix:semicolon
r_else
id|outb
c_func
(paren
id|ap-&gt;ctl
comma
id|ioaddr-&gt;ctl_addr
)paren
suffix:semicolon
id|rc
op_assign
id|ata_bus_edd
c_func
(paren
id|ap
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|err_out
suffix:semicolon
multiline_comment|/*&n;&t; * determine by signature whether we have ATA or ATAPI devices&n;&t; */
id|err
op_assign
id|ata_dev_try_classify
c_func
(paren
id|ap
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|slave_possible
)paren
op_logical_and
(paren
id|err
op_ne
l_int|0x81
)paren
)paren
id|ata_dev_try_classify
c_func
(paren
id|ap
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* re-enable interrupts */
id|ata_irq_on
c_func
(paren
id|ap
)paren
suffix:semicolon
multiline_comment|/* is double-select really necessary? */
r_if
c_cond
(paren
id|ap-&gt;device
(braket
l_int|1
)braket
dot
r_class
op_ne
id|ATA_DEV_NONE
)paren
id|ap-&gt;ops
op_member_access_from_pointer
id|dev_select
c_func
(paren
id|ap
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;device
(braket
l_int|0
)braket
dot
r_class
op_ne
id|ATA_DEV_NONE
)paren
id|ap-&gt;ops
op_member_access_from_pointer
id|dev_select
c_func
(paren
id|ap
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* if no devices were detected, disable this port */
r_if
c_cond
(paren
(paren
id|ap-&gt;device
(braket
l_int|0
)braket
dot
r_class
op_eq
id|ATA_DEV_NONE
)paren
op_logical_and
(paren
id|ap-&gt;device
(braket
l_int|1
)braket
dot
r_class
op_eq
id|ATA_DEV_NONE
)paren
)paren
r_goto
id|err_out
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
(paren
id|ATA_FLAG_SATA_RESET
op_or
id|ATA_FLAG_SRST
)paren
)paren
(brace
multiline_comment|/* set up device control for ATA_FLAG_SATA_RESET */
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|ATA_FLAG_MMIO
)paren
id|writeb
c_func
(paren
id|ap-&gt;ctl
comma
(paren
r_void
id|__iomem
op_star
)paren
id|ioaddr-&gt;ctl_addr
)paren
suffix:semicolon
r_else
id|outb
c_func
(paren
id|ap-&gt;ctl
comma
id|ioaddr-&gt;ctl_addr
)paren
suffix:semicolon
)brace
id|DPRINTK
c_func
(paren
l_string|&quot;EXIT&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
id|err_out
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ata%u: disabling port&bslash;n&quot;
comma
id|ap-&gt;id
)paren
suffix:semicolon
id|ap-&gt;ops
op_member_access_from_pointer
id|port_disable
c_func
(paren
id|ap
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;EXIT&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|ata_get_mode_mask
r_static
r_int
r_int
id|ata_get_mode_mask
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_int
id|shift
)paren
(brace
r_struct
id|ata_device
op_star
id|master
comma
op_star
id|slave
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
id|master
op_assign
op_amp
id|ap-&gt;device
(braket
l_int|0
)braket
suffix:semicolon
id|slave
op_assign
op_amp
id|ap-&gt;device
(braket
l_int|1
)braket
suffix:semicolon
m_assert
(paren
id|ata_dev_present
c_func
(paren
id|master
)paren
op_logical_or
id|ata_dev_present
c_func
(paren
id|slave
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shift
op_eq
id|ATA_SHIFT_UDMA
)paren
(brace
id|mask
op_assign
id|ap-&gt;udma_mask
suffix:semicolon
r_if
c_cond
(paren
id|ata_dev_present
c_func
(paren
id|master
)paren
)paren
id|mask
op_and_assign
(paren
id|master-&gt;id
(braket
id|ATA_ID_UDMA_MODES
)braket
op_amp
l_int|0xff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ata_dev_present
c_func
(paren
id|slave
)paren
)paren
id|mask
op_and_assign
(paren
id|slave-&gt;id
(braket
id|ATA_ID_UDMA_MODES
)braket
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|shift
op_eq
id|ATA_SHIFT_MWDMA
)paren
(brace
id|mask
op_assign
id|ap-&gt;mwdma_mask
suffix:semicolon
r_if
c_cond
(paren
id|ata_dev_present
c_func
(paren
id|master
)paren
)paren
id|mask
op_and_assign
(paren
id|master-&gt;id
(braket
id|ATA_ID_MWDMA_MODES
)braket
op_amp
l_int|0x07
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ata_dev_present
c_func
(paren
id|slave
)paren
)paren
id|mask
op_and_assign
(paren
id|slave-&gt;id
(braket
id|ATA_ID_MWDMA_MODES
)braket
op_amp
l_int|0x07
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|shift
op_eq
id|ATA_SHIFT_PIO
)paren
(brace
id|mask
op_assign
id|ap-&gt;pio_mask
suffix:semicolon
r_if
c_cond
(paren
id|ata_dev_present
c_func
(paren
id|master
)paren
)paren
(brace
multiline_comment|/* spec doesn&squot;t return explicit support for&n;&t;&t;&t; * PIO0-2, so we fake it&n;&t;&t;&t; */
id|u16
id|tmp_mode
op_assign
id|master-&gt;id
(braket
id|ATA_ID_PIO_MODES
)braket
op_amp
l_int|0x03
suffix:semicolon
id|tmp_mode
op_lshift_assign
l_int|3
suffix:semicolon
id|tmp_mode
op_or_assign
l_int|0x7
suffix:semicolon
id|mask
op_and_assign
id|tmp_mode
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ata_dev_present
c_func
(paren
id|slave
)paren
)paren
(brace
multiline_comment|/* spec doesn&squot;t return explicit support for&n;&t;&t;&t; * PIO0-2, so we fake it&n;&t;&t;&t; */
id|u16
id|tmp_mode
op_assign
id|slave-&gt;id
(braket
id|ATA_ID_PIO_MODES
)braket
op_amp
l_int|0x03
suffix:semicolon
id|tmp_mode
op_lshift_assign
l_int|3
suffix:semicolon
id|tmp_mode
op_or_assign
l_int|0x7
suffix:semicolon
id|mask
op_and_assign
id|tmp_mode
suffix:semicolon
)brace
)brace
r_else
(brace
id|mask
op_assign
l_int|0xffffffff
suffix:semicolon
multiline_comment|/* shut up compiler warning */
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|mask
suffix:semicolon
)brace
multiline_comment|/* find greatest bit */
DECL|function|fgb
r_static
r_int
id|fgb
c_func
(paren
id|u32
id|bitmap
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
id|x
op_assign
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|bitmap
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
id|x
op_assign
id|i
suffix:semicolon
r_return
id|x
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_choose_xfer_mode -&n; *&t;@ap:&n; *&n; *&t;LOCKING:&n; *&n; *&t;RETURNS:&n; *&t;Zero on success, negative on error.&n; */
DECL|function|ata_choose_xfer_mode
r_static
r_int
id|ata_choose_xfer_mode
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
id|u8
op_star
id|xfer_mode_out
comma
r_int
r_int
op_star
id|xfer_shift_out
)paren
(brace
r_int
r_int
id|mask
comma
id|shift
suffix:semicolon
r_int
id|x
comma
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|xfer_mode_classes
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|shift
op_assign
id|xfer_mode_classes
(braket
id|i
)braket
dot
id|shift
suffix:semicolon
id|mask
op_assign
id|ata_get_mode_mask
c_func
(paren
id|ap
comma
id|shift
)paren
suffix:semicolon
id|x
op_assign
id|fgb
c_func
(paren
id|mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x
op_ge
l_int|0
)paren
(brace
op_star
id|xfer_mode_out
op_assign
id|xfer_mode_classes
(braket
id|i
)braket
dot
id|base
op_plus
id|x
suffix:semicolon
op_star
id|xfer_shift_out
op_assign
id|shift
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_dev_set_xfermode - Issue SET FEATURES - XFER MODE command&n; *&t;@ap: Port associated with device @dev&n; *&t;@dev: Device to which command will be sent&n; *&n; *&t;LOCKING:&n; */
DECL|function|ata_dev_set_xfermode
r_static
r_void
id|ata_dev_set_xfermode
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_struct
id|ata_device
op_star
id|dev
)paren
(brace
id|DECLARE_COMPLETION
c_func
(paren
id|wait
)paren
suffix:semicolon
r_struct
id|ata_queued_cmd
op_star
id|qc
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* set up set-features taskfile */
id|DPRINTK
c_func
(paren
l_string|&quot;set features - xfer mode&bslash;n&quot;
)paren
suffix:semicolon
id|qc
op_assign
id|ata_qc_new_init
c_func
(paren
id|ap
comma
id|dev
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|qc
op_eq
l_int|NULL
)paren
suffix:semicolon
id|qc-&gt;tf.command
op_assign
id|ATA_CMD_SET_FEATURES
suffix:semicolon
id|qc-&gt;tf.feature
op_assign
id|SETFEATURES_XFER
suffix:semicolon
id|qc-&gt;tf.flags
op_or_assign
id|ATA_TFLAG_ISADDR
op_or
id|ATA_TFLAG_DEVICE
suffix:semicolon
id|qc-&gt;tf.protocol
op_assign
id|ATA_PROT_NODATA
suffix:semicolon
id|qc-&gt;tf.nsect
op_assign
id|dev-&gt;xfer_mode
suffix:semicolon
id|qc-&gt;waiting
op_assign
op_amp
id|wait
suffix:semicolon
id|qc-&gt;complete_fn
op_assign
id|ata_qc_complete_noop
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ap-&gt;host_set-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|rc
op_assign
id|ata_qc_issue
c_func
(paren
id|qc
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ap-&gt;host_set-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
id|ata_port_disable
c_func
(paren
id|ap
)paren
suffix:semicolon
r_else
id|wait_for_completion
c_func
(paren
op_amp
id|wait
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;EXIT&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_sg_clean -&n; *&t;@qc:&n; *&n; *&t;LOCKING:&n; */
DECL|function|ata_sg_clean
r_static
r_void
id|ata_sg_clean
c_func
(paren
r_struct
id|ata_queued_cmd
op_star
id|qc
)paren
(brace
r_struct
id|ata_port
op_star
id|ap
op_assign
id|qc-&gt;ap
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
op_assign
id|qc-&gt;sg
suffix:semicolon
r_int
id|dir
op_assign
id|qc-&gt;dma_dir
suffix:semicolon
m_assert
(paren
id|qc-&gt;flags
op_amp
id|ATA_QCFLAG_DMAMAP
)paren
suffix:semicolon
m_assert
(paren
id|sg
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qc-&gt;flags
op_amp
id|ATA_QCFLAG_SINGLE
)paren
m_assert
(paren
id|qc-&gt;n_elem
op_eq
l_int|1
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;unmapping %u sg elements&bslash;n&quot;
comma
id|qc-&gt;n_elem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qc-&gt;flags
op_amp
id|ATA_QCFLAG_SG
)paren
id|dma_unmap_sg
c_func
(paren
id|ap-&gt;host_set-&gt;dev
comma
id|sg
comma
id|qc-&gt;n_elem
comma
id|dir
)paren
suffix:semicolon
r_else
id|dma_unmap_single
c_func
(paren
id|ap-&gt;host_set-&gt;dev
comma
id|sg_dma_address
c_func
(paren
op_amp
id|sg
(braket
l_int|0
)braket
)paren
comma
id|sg_dma_len
c_func
(paren
op_amp
id|sg
(braket
l_int|0
)braket
)paren
comma
id|dir
)paren
suffix:semicolon
id|qc-&gt;flags
op_and_assign
op_complement
id|ATA_QCFLAG_DMAMAP
suffix:semicolon
id|qc-&gt;sg
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_fill_sg - Fill PCI IDE PRD table&n; *&t;@qc: Metadata associated with taskfile to be transferred&n; *&n; *&t;LOCKING:&n; *&n; */
DECL|function|ata_fill_sg
r_static
r_void
id|ata_fill_sg
c_func
(paren
r_struct
id|ata_queued_cmd
op_star
id|qc
)paren
(brace
r_struct
id|scatterlist
op_star
id|sg
op_assign
id|qc-&gt;sg
suffix:semicolon
r_struct
id|ata_port
op_star
id|ap
op_assign
id|qc-&gt;ap
suffix:semicolon
r_int
r_int
id|idx
comma
id|nelem
suffix:semicolon
m_assert
(paren
id|sg
op_ne
l_int|NULL
)paren
suffix:semicolon
m_assert
(paren
id|qc-&gt;n_elem
OG
l_int|0
)paren
suffix:semicolon
id|idx
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|nelem
op_assign
id|qc-&gt;n_elem
suffix:semicolon
id|nelem
suffix:semicolon
id|nelem
op_decrement
comma
id|sg
op_increment
)paren
(brace
id|u32
id|addr
comma
id|offset
suffix:semicolon
id|u32
id|sg_len
comma
id|len
suffix:semicolon
multiline_comment|/* determine if physical DMA addr spans 64K boundary.&n;&t;&t; * Note h/w doesn&squot;t support 64-bit, so we unconditionally&n;&t;&t; * truncate dma_addr_t to u32.&n;&t;&t; */
id|addr
op_assign
(paren
id|u32
)paren
id|sg_dma_address
c_func
(paren
id|sg
)paren
suffix:semicolon
id|sg_len
op_assign
id|sg_dma_len
c_func
(paren
id|sg
)paren
suffix:semicolon
r_while
c_loop
(paren
id|sg_len
)paren
(brace
id|offset
op_assign
id|addr
op_amp
l_int|0xffff
suffix:semicolon
id|len
op_assign
id|sg_len
suffix:semicolon
r_if
c_cond
(paren
(paren
id|offset
op_plus
id|sg_len
)paren
OG
l_int|0x10000
)paren
id|len
op_assign
l_int|0x10000
op_minus
id|offset
suffix:semicolon
id|ap-&gt;prd
(braket
id|idx
)braket
dot
id|addr
op_assign
id|cpu_to_le32
c_func
(paren
id|addr
)paren
suffix:semicolon
id|ap-&gt;prd
(braket
id|idx
)braket
dot
id|flags_len
op_assign
id|cpu_to_le32
c_func
(paren
id|len
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;PRD[%u] = (0x%X, 0x%X)&bslash;n&quot;
comma
id|idx
comma
id|addr
comma
id|len
)paren
suffix:semicolon
id|idx
op_increment
suffix:semicolon
id|sg_len
op_sub_assign
id|len
suffix:semicolon
id|addr
op_add_assign
id|len
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|idx
)paren
id|ap-&gt;prd
(braket
id|idx
op_minus
l_int|1
)braket
dot
id|flags_len
op_or_assign
id|cpu_to_le32
c_func
(paren
id|ATA_PRD_EOT
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_qc_prep - Prepare taskfile for submission&n; *&t;@qc: Metadata associated with taskfile to be prepared&n; *&n; *&t;LOCKING:&n; *&t;spin_lock_irqsave(host_set lock)&n; */
DECL|function|ata_qc_prep
r_void
id|ata_qc_prep
c_func
(paren
r_struct
id|ata_queued_cmd
op_star
id|qc
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|qc-&gt;flags
op_amp
id|ATA_QCFLAG_DMAMAP
)paren
)paren
r_return
suffix:semicolon
id|ata_fill_sg
c_func
(paren
id|qc
)paren
suffix:semicolon
)brace
DECL|function|ata_sg_init_one
r_void
id|ata_sg_init_one
c_func
(paren
r_struct
id|ata_queued_cmd
op_star
id|qc
comma
r_void
op_star
id|buf
comma
r_int
r_int
id|buflen
)paren
(brace
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
id|qc-&gt;flags
op_or_assign
id|ATA_QCFLAG_SINGLE
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|qc-&gt;sgent
comma
l_int|0
comma
r_sizeof
(paren
id|qc-&gt;sgent
)paren
)paren
suffix:semicolon
id|qc-&gt;sg
op_assign
op_amp
id|qc-&gt;sgent
suffix:semicolon
id|qc-&gt;n_elem
op_assign
l_int|1
suffix:semicolon
id|qc-&gt;buf_virt
op_assign
id|buf
suffix:semicolon
id|sg
op_assign
id|qc-&gt;sg
suffix:semicolon
id|sg-&gt;page
op_assign
id|virt_to_page
c_func
(paren
id|buf
)paren
suffix:semicolon
id|sg-&gt;offset
op_assign
(paren
r_int
r_int
)paren
id|buf
op_amp
op_complement
id|PAGE_MASK
suffix:semicolon
id|sg_dma_len
c_func
(paren
id|sg
)paren
op_assign
id|buflen
suffix:semicolon
id|WARN_ON
c_func
(paren
id|buflen
OG
id|PAGE_SIZE
)paren
suffix:semicolon
)brace
DECL|function|ata_sg_init
r_void
id|ata_sg_init
c_func
(paren
r_struct
id|ata_queued_cmd
op_star
id|qc
comma
r_struct
id|scatterlist
op_star
id|sg
comma
r_int
r_int
id|n_elem
)paren
(brace
id|qc-&gt;flags
op_or_assign
id|ATA_QCFLAG_SG
suffix:semicolon
id|qc-&gt;sg
op_assign
id|sg
suffix:semicolon
id|qc-&gt;n_elem
op_assign
id|n_elem
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_sg_setup_one -&n; *&t;@qc:&n; *&n; *&t;LOCKING:&n; *&t;spin_lock_irqsave(host_set lock)&n; *&n; *&t;RETURNS:&n; *&n; */
DECL|function|ata_sg_setup_one
r_static
r_int
id|ata_sg_setup_one
c_func
(paren
r_struct
id|ata_queued_cmd
op_star
id|qc
)paren
(brace
r_struct
id|ata_port
op_star
id|ap
op_assign
id|qc-&gt;ap
suffix:semicolon
r_int
id|dir
op_assign
id|qc-&gt;dma_dir
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
op_assign
id|qc-&gt;sg
suffix:semicolon
id|dma_addr_t
id|dma_address
suffix:semicolon
id|dma_address
op_assign
id|dma_map_single
c_func
(paren
id|ap-&gt;host_set-&gt;dev
comma
id|qc-&gt;buf_virt
comma
id|sg_dma_len
c_func
(paren
id|sg
)paren
comma
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma_mapping_error
c_func
(paren
id|dma_address
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|sg_dma_address
c_func
(paren
id|sg
)paren
op_assign
id|dma_address
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;mapped buffer of %d bytes for %s&bslash;n&quot;
comma
id|sg_dma_len
c_func
(paren
id|sg
)paren
comma
id|qc-&gt;tf.flags
op_amp
id|ATA_TFLAG_WRITE
ques
c_cond
l_string|&quot;write&quot;
suffix:colon
l_string|&quot;read&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_sg_setup -&n; *&t;@qc:&n; *&n; *&t;LOCKING:&n; *&t;spin_lock_irqsave(host_set lock)&n; *&n; *&t;RETURNS:&n; *&n; */
DECL|function|ata_sg_setup
r_static
r_int
id|ata_sg_setup
c_func
(paren
r_struct
id|ata_queued_cmd
op_star
id|qc
)paren
(brace
r_struct
id|ata_port
op_star
id|ap
op_assign
id|qc-&gt;ap
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
op_assign
id|qc-&gt;sg
suffix:semicolon
r_int
id|n_elem
comma
id|dir
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;ENTER, ata%u&bslash;n&quot;
comma
id|ap-&gt;id
)paren
suffix:semicolon
m_assert
(paren
id|qc-&gt;flags
op_amp
id|ATA_QCFLAG_SG
)paren
suffix:semicolon
id|dir
op_assign
id|qc-&gt;dma_dir
suffix:semicolon
id|n_elem
op_assign
id|dma_map_sg
c_func
(paren
id|ap-&gt;host_set-&gt;dev
comma
id|sg
comma
id|qc-&gt;n_elem
comma
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n_elem
OL
l_int|1
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;%d sg elements mapped&bslash;n&quot;
comma
id|n_elem
)paren
suffix:semicolon
id|qc-&gt;n_elem
op_assign
id|n_elem
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_pio_poll -&n; *&t;@ap:&n; *&n; *&t;LOCKING:&n; *&n; *&t;RETURNS:&n; *&n; */
DECL|function|ata_pio_poll
r_static
r_int
r_int
id|ata_pio_poll
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
)paren
(brace
id|u8
id|status
suffix:semicolon
r_int
r_int
id|poll_state
op_assign
id|PIO_ST_UNKNOWN
suffix:semicolon
r_int
r_int
id|reg_state
op_assign
id|PIO_ST_UNKNOWN
suffix:semicolon
r_const
r_int
r_int
id|tmout_state
op_assign
id|PIO_ST_TMOUT
suffix:semicolon
r_switch
c_cond
(paren
id|ap-&gt;pio_task_state
)paren
(brace
r_case
id|PIO_ST
suffix:colon
r_case
id|PIO_ST_POLL
suffix:colon
id|poll_state
op_assign
id|PIO_ST_POLL
suffix:semicolon
id|reg_state
op_assign
id|PIO_ST
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIO_ST_LAST
suffix:colon
r_case
id|PIO_ST_LAST_POLL
suffix:colon
id|poll_state
op_assign
id|PIO_ST_LAST_POLL
suffix:semicolon
id|reg_state
op_assign
id|PIO_ST_LAST
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|status
op_assign
id|ata_chk_status
c_func
(paren
id|ap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|ATA_BUSY
)paren
(brace
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|ap-&gt;pio_task_timeout
)paren
)paren
(brace
id|ap-&gt;pio_task_state
op_assign
id|tmout_state
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ap-&gt;pio_task_state
op_assign
id|poll_state
suffix:semicolon
r_return
id|ATA_SHORT_PAUSE
suffix:semicolon
)brace
id|ap-&gt;pio_task_state
op_assign
id|reg_state
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_pio_complete -&n; *&t;@ap:&n; *&n; *&t;LOCKING:&n; */
DECL|function|ata_pio_complete
r_static
r_void
id|ata_pio_complete
(paren
r_struct
id|ata_port
op_star
id|ap
)paren
(brace
r_struct
id|ata_queued_cmd
op_star
id|qc
suffix:semicolon
id|u8
id|drv_stat
suffix:semicolon
multiline_comment|/*&n;&t; * This is purely hueristic.  This is a fast path.&n;&t; * Sometimes when we enter, BSY will be cleared in&n;&t; * a chk-status or two.  If not, the drive is probably seeking&n;&t; * or something.  Snooze for a couple msecs, then&n;&t; * chk-status again.  If still busy, fall back to&n;&t; * PIO_ST_POLL state.&n;&t; */
id|drv_stat
op_assign
id|ata_busy_wait
c_func
(paren
id|ap
comma
id|ATA_BUSY
op_or
id|ATA_DRQ
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv_stat
op_amp
(paren
id|ATA_BUSY
op_or
id|ATA_DRQ
)paren
)paren
(brace
id|msleep
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|drv_stat
op_assign
id|ata_busy_wait
c_func
(paren
id|ap
comma
id|ATA_BUSY
op_or
id|ATA_DRQ
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv_stat
op_amp
(paren
id|ATA_BUSY
op_or
id|ATA_DRQ
)paren
)paren
(brace
id|ap-&gt;pio_task_state
op_assign
id|PIO_ST_LAST_POLL
suffix:semicolon
id|ap-&gt;pio_task_timeout
op_assign
id|jiffies
op_plus
id|ATA_TMOUT_PIO
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|drv_stat
op_assign
id|ata_wait_idle
c_func
(paren
id|ap
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ata_ok
c_func
(paren
id|drv_stat
)paren
)paren
(brace
id|ap-&gt;pio_task_state
op_assign
id|PIO_ST_ERR
suffix:semicolon
r_return
suffix:semicolon
)brace
id|qc
op_assign
id|ata_qc_from_tag
c_func
(paren
id|ap
comma
id|ap-&gt;active_tag
)paren
suffix:semicolon
m_assert
(paren
id|qc
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ap-&gt;pio_task_state
op_assign
id|PIO_ST_IDLE
suffix:semicolon
id|ata_irq_on
c_func
(paren
id|ap
)paren
suffix:semicolon
id|ata_qc_complete
c_func
(paren
id|qc
comma
id|drv_stat
)paren
suffix:semicolon
)brace
DECL|function|swap_buf_le16
r_void
id|swap_buf_le16
c_func
(paren
id|u16
op_star
id|buf
comma
r_int
r_int
id|buf_words
)paren
(brace
macro_line|#ifdef __BIG_ENDIAN
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|buf_words
suffix:semicolon
id|i
op_increment
)paren
id|buf
(braket
id|i
)braket
op_assign
id|le16_to_cpu
c_func
(paren
id|buf
(braket
id|i
)braket
)paren
suffix:semicolon
macro_line|#endif /* __BIG_ENDIAN */
)brace
DECL|function|ata_mmio_data_xfer
r_static
r_void
id|ata_mmio_data_xfer
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_int
r_char
op_star
id|buf
comma
r_int
r_int
id|buflen
comma
r_int
id|write_data
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|words
op_assign
id|buflen
op_rshift
l_int|1
suffix:semicolon
id|u16
op_star
id|buf16
op_assign
(paren
id|u16
op_star
)paren
id|buf
suffix:semicolon
r_void
id|__iomem
op_star
id|mmio
op_assign
(paren
r_void
id|__iomem
op_star
)paren
id|ap-&gt;ioaddr.data_addr
suffix:semicolon
r_if
c_cond
(paren
id|write_data
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|words
suffix:semicolon
id|i
op_increment
)paren
id|writew
c_func
(paren
id|le16_to_cpu
c_func
(paren
id|buf16
(braket
id|i
)braket
)paren
comma
id|mmio
)paren
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|words
suffix:semicolon
id|i
op_increment
)paren
id|buf16
(braket
id|i
)braket
op_assign
id|cpu_to_le16
c_func
(paren
id|readw
c_func
(paren
id|mmio
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|ata_pio_data_xfer
r_static
r_void
id|ata_pio_data_xfer
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_int
r_char
op_star
id|buf
comma
r_int
r_int
id|buflen
comma
r_int
id|write_data
)paren
(brace
r_int
r_int
id|dwords
op_assign
id|buflen
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|write_data
)paren
id|outsw
c_func
(paren
id|ap-&gt;ioaddr.data_addr
comma
id|buf
comma
id|dwords
)paren
suffix:semicolon
r_else
id|insw
c_func
(paren
id|ap-&gt;ioaddr.data_addr
comma
id|buf
comma
id|dwords
)paren
suffix:semicolon
)brace
DECL|function|ata_data_xfer
r_static
r_void
id|ata_data_xfer
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_int
r_char
op_star
id|buf
comma
r_int
r_int
id|buflen
comma
r_int
id|do_write
)paren
(brace
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|ATA_FLAG_MMIO
)paren
id|ata_mmio_data_xfer
c_func
(paren
id|ap
comma
id|buf
comma
id|buflen
comma
id|do_write
)paren
suffix:semicolon
r_else
id|ata_pio_data_xfer
c_func
(paren
id|ap
comma
id|buf
comma
id|buflen
comma
id|do_write
)paren
suffix:semicolon
)brace
DECL|function|ata_pio_sector
r_static
r_void
id|ata_pio_sector
c_func
(paren
r_struct
id|ata_queued_cmd
op_star
id|qc
)paren
(brace
r_int
id|do_write
op_assign
(paren
id|qc-&gt;tf.flags
op_amp
id|ATA_TFLAG_WRITE
)paren
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
op_assign
id|qc-&gt;sg
suffix:semicolon
r_struct
id|ata_port
op_star
id|ap
op_assign
id|qc-&gt;ap
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
r_int
r_char
op_star
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|qc-&gt;cursect
op_eq
(paren
id|qc-&gt;nsect
op_minus
l_int|1
)paren
)paren
id|ap-&gt;pio_task_state
op_assign
id|PIO_ST_LAST
suffix:semicolon
id|page
op_assign
id|sg
(braket
id|qc-&gt;cursg
)braket
dot
id|page
suffix:semicolon
id|offset
op_assign
id|sg
(braket
id|qc-&gt;cursg
)braket
dot
id|offset
op_plus
id|qc-&gt;cursg_ofs
op_star
id|ATA_SECT_SIZE
suffix:semicolon
multiline_comment|/* get the current page and offset */
id|page
op_assign
id|nth_page
c_func
(paren
id|page
comma
(paren
id|offset
op_rshift
id|PAGE_SHIFT
)paren
)paren
suffix:semicolon
id|offset
op_mod_assign
id|PAGE_SIZE
suffix:semicolon
id|buf
op_assign
id|kmap
c_func
(paren
id|page
)paren
op_plus
id|offset
suffix:semicolon
id|qc-&gt;cursect
op_increment
suffix:semicolon
id|qc-&gt;cursg_ofs
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|qc-&gt;cursg_ofs
op_star
id|ATA_SECT_SIZE
)paren
op_eq
id|sg_dma_len
c_func
(paren
op_amp
id|sg
(braket
id|qc-&gt;cursg
)braket
)paren
)paren
(brace
id|qc-&gt;cursg
op_increment
suffix:semicolon
id|qc-&gt;cursg_ofs
op_assign
l_int|0
suffix:semicolon
)brace
id|DPRINTK
c_func
(paren
l_string|&quot;data %s&bslash;n&quot;
comma
id|qc-&gt;tf.flags
op_amp
id|ATA_TFLAG_WRITE
ques
c_cond
l_string|&quot;write&quot;
suffix:colon
l_string|&quot;read&quot;
)paren
suffix:semicolon
multiline_comment|/* do the actual data transfer */
id|do_write
op_assign
(paren
id|qc-&gt;tf.flags
op_amp
id|ATA_TFLAG_WRITE
)paren
suffix:semicolon
id|ata_data_xfer
c_func
(paren
id|ap
comma
id|buf
comma
id|ATA_SECT_SIZE
comma
id|do_write
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
DECL|function|__atapi_pio_bytes
r_static
r_void
id|__atapi_pio_bytes
c_func
(paren
r_struct
id|ata_queued_cmd
op_star
id|qc
comma
r_int
r_int
id|bytes
)paren
(brace
r_int
id|do_write
op_assign
(paren
id|qc-&gt;tf.flags
op_amp
id|ATA_TFLAG_WRITE
)paren
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sg
op_assign
id|qc-&gt;sg
suffix:semicolon
r_struct
id|ata_port
op_star
id|ap
op_assign
id|qc-&gt;ap
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_char
op_star
id|buf
suffix:semicolon
r_int
r_int
id|offset
comma
id|count
suffix:semicolon
r_if
c_cond
(paren
id|qc-&gt;curbytes
op_eq
id|qc-&gt;nbytes
op_minus
id|bytes
)paren
id|ap-&gt;pio_task_state
op_assign
id|PIO_ST_LAST
suffix:semicolon
id|next_sg
suffix:colon
id|sg
op_assign
op_amp
id|qc-&gt;sg
(braket
id|qc-&gt;cursg
)braket
suffix:semicolon
id|next_page
suffix:colon
id|page
op_assign
id|sg-&gt;page
suffix:semicolon
id|offset
op_assign
id|sg-&gt;offset
op_plus
id|qc-&gt;cursg_ofs
suffix:semicolon
multiline_comment|/* get the current page and offset */
id|page
op_assign
id|nth_page
c_func
(paren
id|page
comma
(paren
id|offset
op_rshift
id|PAGE_SHIFT
)paren
)paren
suffix:semicolon
id|offset
op_mod_assign
id|PAGE_SIZE
suffix:semicolon
id|count
op_assign
id|min
c_func
(paren
id|sg_dma_len
c_func
(paren
id|sg
)paren
op_minus
id|qc-&gt;cursg_ofs
comma
id|bytes
)paren
suffix:semicolon
multiline_comment|/* don&squot;t cross page boundaries */
id|count
op_assign
id|min
c_func
(paren
id|count
comma
(paren
r_int
r_int
)paren
id|PAGE_SIZE
op_minus
id|offset
)paren
suffix:semicolon
id|buf
op_assign
id|kmap
c_func
(paren
id|page
)paren
op_plus
id|offset
suffix:semicolon
id|bytes
op_sub_assign
id|count
suffix:semicolon
id|qc-&gt;curbytes
op_add_assign
id|count
suffix:semicolon
id|qc-&gt;cursg_ofs
op_add_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|qc-&gt;cursg_ofs
op_eq
id|sg_dma_len
c_func
(paren
id|sg
)paren
)paren
(brace
id|qc-&gt;cursg
op_increment
suffix:semicolon
id|qc-&gt;cursg_ofs
op_assign
l_int|0
suffix:semicolon
)brace
id|DPRINTK
c_func
(paren
l_string|&quot;data %s&bslash;n&quot;
comma
id|qc-&gt;tf.flags
op_amp
id|ATA_TFLAG_WRITE
ques
c_cond
l_string|&quot;write&quot;
suffix:colon
l_string|&quot;read&quot;
)paren
suffix:semicolon
multiline_comment|/* do the actual data transfer */
id|ata_data_xfer
c_func
(paren
id|ap
comma
id|buf
comma
id|count
comma
id|do_write
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bytes
)paren
(brace
r_if
c_cond
(paren
id|qc-&gt;cursg_ofs
OL
id|sg_dma_len
c_func
(paren
id|sg
)paren
)paren
r_goto
id|next_page
suffix:semicolon
r_goto
id|next_sg
suffix:semicolon
)brace
)brace
DECL|function|atapi_pio_bytes
r_static
r_void
id|atapi_pio_bytes
c_func
(paren
r_struct
id|ata_queued_cmd
op_star
id|qc
)paren
(brace
r_struct
id|ata_port
op_star
id|ap
op_assign
id|qc-&gt;ap
suffix:semicolon
r_struct
id|ata_device
op_star
id|dev
op_assign
id|qc-&gt;dev
suffix:semicolon
r_int
r_int
id|ireason
comma
id|bc_lo
comma
id|bc_hi
comma
id|bytes
suffix:semicolon
r_int
id|i_write
comma
id|do_write
op_assign
(paren
id|qc-&gt;tf.flags
op_amp
id|ATA_TFLAG_WRITE
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|ap-&gt;ops
op_member_access_from_pointer
id|tf_read
c_func
(paren
id|ap
comma
op_amp
id|qc-&gt;tf
)paren
suffix:semicolon
id|ireason
op_assign
id|qc-&gt;tf.nsect
suffix:semicolon
id|bc_lo
op_assign
id|qc-&gt;tf.lbam
suffix:semicolon
id|bc_hi
op_assign
id|qc-&gt;tf.lbah
suffix:semicolon
id|bytes
op_assign
(paren
id|bc_hi
op_lshift
l_int|8
)paren
op_or
id|bc_lo
suffix:semicolon
multiline_comment|/* shall be cleared to zero, indicating xfer of data */
r_if
c_cond
(paren
id|ireason
op_amp
(paren
l_int|1
op_lshift
l_int|0
)paren
)paren
r_goto
id|err_out
suffix:semicolon
multiline_comment|/* make sure transfer direction matches expected */
id|i_write
op_assign
(paren
(paren
id|ireason
op_amp
(paren
l_int|1
op_lshift
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|do_write
op_ne
id|i_write
)paren
r_goto
id|err_out
suffix:semicolon
id|__atapi_pio_bytes
c_func
(paren
id|qc
comma
id|bytes
)paren
suffix:semicolon
r_return
suffix:semicolon
id|err_out
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ata%u: dev %u: ATAPI check failed&bslash;n&quot;
comma
id|ap-&gt;id
comma
id|dev-&gt;devno
)paren
suffix:semicolon
id|ap-&gt;pio_task_state
op_assign
id|PIO_ST_ERR
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_pio_sector -&n; *&t;@ap:&n; *&n; *&t;LOCKING:&n; */
DECL|function|ata_pio_block
r_static
r_void
id|ata_pio_block
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
)paren
(brace
r_struct
id|ata_queued_cmd
op_star
id|qc
suffix:semicolon
id|u8
id|status
suffix:semicolon
multiline_comment|/*&n;&t; * This is purely hueristic.  This is a fast path.&n;&t; * Sometimes when we enter, BSY will be cleared in&n;&t; * a chk-status or two.  If not, the drive is probably seeking&n;&t; * or something.  Snooze for a couple msecs, then&n;&t; * chk-status again.  If still busy, fall back to&n;&t; * PIO_ST_POLL state.&n;&t; */
id|status
op_assign
id|ata_busy_wait
c_func
(paren
id|ap
comma
id|ATA_BUSY
comma
l_int|5
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|ATA_BUSY
)paren
(brace
id|msleep
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|status
op_assign
id|ata_busy_wait
c_func
(paren
id|ap
comma
id|ATA_BUSY
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|ATA_BUSY
)paren
(brace
id|ap-&gt;pio_task_state
op_assign
id|PIO_ST_POLL
suffix:semicolon
id|ap-&gt;pio_task_timeout
op_assign
id|jiffies
op_plus
id|ATA_TMOUT_PIO
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|qc
op_assign
id|ata_qc_from_tag
c_func
(paren
id|ap
comma
id|ap-&gt;active_tag
)paren
suffix:semicolon
m_assert
(paren
id|qc
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_atapi_taskfile
c_func
(paren
op_amp
id|qc-&gt;tf
)paren
)paren
(brace
multiline_comment|/* no more data to transfer or unsupported ATAPI command */
r_if
c_cond
(paren
(paren
id|status
op_amp
id|ATA_DRQ
)paren
op_eq
l_int|0
)paren
(brace
id|ap-&gt;pio_task_state
op_assign
id|PIO_ST_IDLE
suffix:semicolon
id|ata_irq_on
c_func
(paren
id|ap
)paren
suffix:semicolon
id|ata_qc_complete
c_func
(paren
id|qc
comma
id|status
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|atapi_pio_bytes
c_func
(paren
id|qc
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* handle BSY=0, DRQ=0 as error */
r_if
c_cond
(paren
(paren
id|status
op_amp
id|ATA_DRQ
)paren
op_eq
l_int|0
)paren
(brace
id|ap-&gt;pio_task_state
op_assign
id|PIO_ST_ERR
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ata_pio_sector
c_func
(paren
id|qc
)paren
suffix:semicolon
)brace
)brace
DECL|function|ata_pio_error
r_static
r_void
id|ata_pio_error
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
)paren
(brace
r_struct
id|ata_queued_cmd
op_star
id|qc
suffix:semicolon
id|u8
id|drv_stat
suffix:semicolon
id|qc
op_assign
id|ata_qc_from_tag
c_func
(paren
id|ap
comma
id|ap-&gt;active_tag
)paren
suffix:semicolon
m_assert
(paren
id|qc
op_ne
l_int|NULL
)paren
suffix:semicolon
id|drv_stat
op_assign
id|ata_chk_status
c_func
(paren
id|ap
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ata%u: PIO error, drv_stat 0x%x&bslash;n&quot;
comma
id|ap-&gt;id
comma
id|drv_stat
)paren
suffix:semicolon
id|ap-&gt;pio_task_state
op_assign
id|PIO_ST_IDLE
suffix:semicolon
id|ata_irq_on
c_func
(paren
id|ap
)paren
suffix:semicolon
id|ata_qc_complete
c_func
(paren
id|qc
comma
id|drv_stat
op_or
id|ATA_ERR
)paren
suffix:semicolon
)brace
DECL|function|ata_pio_task
r_static
r_void
id|ata_pio_task
c_func
(paren
r_void
op_star
id|_data
)paren
(brace
r_struct
id|ata_port
op_star
id|ap
op_assign
id|_data
suffix:semicolon
r_int
r_int
id|timeout
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|ap-&gt;pio_task_state
)paren
(brace
r_case
id|PIO_ST
suffix:colon
id|ata_pio_block
c_func
(paren
id|ap
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIO_ST_LAST
suffix:colon
id|ata_pio_complete
c_func
(paren
id|ap
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIO_ST_POLL
suffix:colon
r_case
id|PIO_ST_LAST_POLL
suffix:colon
id|timeout
op_assign
id|ata_pio_poll
c_func
(paren
id|ap
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PIO_ST_TMOUT
suffix:colon
r_case
id|PIO_ST_ERR
suffix:colon
id|ata_pio_error
c_func
(paren
id|ap
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ap-&gt;pio_task_state
op_ne
id|PIO_ST_IDLE
)paren
op_logical_and
(paren
id|ap-&gt;pio_task_state
op_ne
id|PIO_ST_TMOUT
)paren
op_logical_and
(paren
id|ap-&gt;pio_task_state
op_ne
id|PIO_ST_ERR
)paren
)paren
(brace
r_if
c_cond
(paren
id|timeout
)paren
id|queue_delayed_work
c_func
(paren
id|ata_wq
comma
op_amp
id|ap-&gt;pio_task
comma
id|timeout
)paren
suffix:semicolon
r_else
id|queue_work
c_func
(paren
id|ata_wq
comma
op_amp
id|ap-&gt;pio_task
)paren
suffix:semicolon
)brace
)brace
DECL|function|atapi_request_sense
r_static
r_void
id|atapi_request_sense
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_struct
id|ata_device
op_star
id|dev
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
id|DECLARE_COMPLETION
c_func
(paren
id|wait
)paren
suffix:semicolon
r_struct
id|ata_queued_cmd
op_star
id|qc
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|using_pio
op_assign
id|dev-&gt;flags
op_amp
id|ATA_DFLAG_PIO
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;ATAPI request sense&bslash;n&quot;
)paren
suffix:semicolon
id|qc
op_assign
id|ata_qc_new_init
c_func
(paren
id|ap
comma
id|dev
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|qc
op_eq
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* FIXME: is this needed? */
id|memset
c_func
(paren
id|cmd-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
)paren
suffix:semicolon
id|ata_sg_init_one
c_func
(paren
id|qc
comma
id|cmd-&gt;sense_buffer
comma
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
)paren
suffix:semicolon
id|qc-&gt;dma_dir
op_assign
id|DMA_FROM_DEVICE
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|qc-&gt;cdb
comma
l_int|0
comma
r_sizeof
(paren
id|ap-&gt;cdb_len
)paren
)paren
suffix:semicolon
id|qc-&gt;cdb
(braket
l_int|0
)braket
op_assign
id|REQUEST_SENSE
suffix:semicolon
id|qc-&gt;cdb
(braket
l_int|4
)braket
op_assign
id|SCSI_SENSE_BUFFERSIZE
suffix:semicolon
id|qc-&gt;tf.flags
op_or_assign
id|ATA_TFLAG_ISADDR
op_or
id|ATA_TFLAG_DEVICE
suffix:semicolon
id|qc-&gt;tf.command
op_assign
id|ATA_CMD_PACKET
suffix:semicolon
r_if
c_cond
(paren
id|using_pio
)paren
(brace
id|qc-&gt;tf.protocol
op_assign
id|ATA_PROT_ATAPI
suffix:semicolon
id|qc-&gt;tf.lbam
op_assign
(paren
l_int|8
op_star
l_int|1024
)paren
op_amp
l_int|0xff
suffix:semicolon
id|qc-&gt;tf.lbah
op_assign
(paren
l_int|8
op_star
l_int|1024
)paren
op_rshift
l_int|8
suffix:semicolon
id|qc-&gt;nbytes
op_assign
id|SCSI_SENSE_BUFFERSIZE
suffix:semicolon
)brace
r_else
(brace
id|qc-&gt;tf.protocol
op_assign
id|ATA_PROT_ATAPI_DMA
suffix:semicolon
id|qc-&gt;tf.feature
op_or_assign
id|ATAPI_PKT_DMA
suffix:semicolon
)brace
id|qc-&gt;waiting
op_assign
op_amp
id|wait
suffix:semicolon
id|qc-&gt;complete_fn
op_assign
id|ata_qc_complete_noop
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ap-&gt;host_set-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|rc
op_assign
id|ata_qc_issue
c_func
(paren
id|qc
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ap-&gt;host_set-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
id|ata_port_disable
c_func
(paren
id|ap
)paren
suffix:semicolon
r_else
id|wait_for_completion
c_func
(paren
op_amp
id|wait
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;EXIT&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_qc_timeout - Handle timeout of queued command&n; *&t;@qc: Command that timed out&n; *&n; *&t;Some part of the kernel (currently, only the SCSI layer)&n; *&t;has noticed that the active command on port @ap has not&n; *&t;completed after a specified length of time.  Handle this&n; *&t;condition by disabling DMA (if necessary) and completing&n; *&t;transactions, with error if necessary.&n; *&n; *&t;This also handles the case of the &quot;lost interrupt&quot;, where&n; *&t;for some reason (possibly hardware bug, possibly driver bug)&n; *&t;an interrupt was not delivered to the driver, even though the&n; *&t;transaction completed successfully.&n; *&n; *&t;LOCKING:&n; */
DECL|function|ata_qc_timeout
r_static
r_void
id|ata_qc_timeout
c_func
(paren
r_struct
id|ata_queued_cmd
op_star
id|qc
)paren
(brace
r_struct
id|ata_port
op_star
id|ap
op_assign
id|qc-&gt;ap
suffix:semicolon
r_struct
id|ata_device
op_star
id|dev
op_assign
id|qc-&gt;dev
suffix:semicolon
id|u8
id|host_stat
op_assign
l_int|0
comma
id|drv_stat
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;ENTER&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* FIXME: doesn&squot;t this conflict with timeout handling? */
r_if
c_cond
(paren
id|qc-&gt;dev
op_member_access_from_pointer
r_class
op_eq
id|ATA_DEV_ATAPI
op_logical_and
id|qc-&gt;scsicmd
)paren
(brace
r_struct
id|scsi_cmnd
op_star
id|cmd
op_assign
id|qc-&gt;scsicmd
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_eh_eflags_chk
c_func
(paren
id|cmd
comma
id|SCSI_EH_CANCEL_CMD
)paren
)paren
(brace
multiline_comment|/* finish completing original command */
id|__ata_qc_complete
c_func
(paren
id|qc
)paren
suffix:semicolon
id|atapi_request_sense
c_func
(paren
id|ap
comma
id|dev
comma
id|cmd
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
(paren
id|CHECK_CONDITION
op_lshift
l_int|1
)paren
op_or
(paren
id|DID_OK
op_lshift
l_int|16
)paren
suffix:semicolon
id|scsi_finish_command
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
multiline_comment|/* hack alert!  We cannot use the supplied completion&n;&t; * function from inside the -&gt;eh_strategy_handler() thread.&n;&t; * libata is the only user of -&gt;eh_strategy_handler() in&n;&t; * any kernel, so the default scsi_done() assumes it is&n;&t; * not being called from the SCSI EH.&n;&t; */
id|qc-&gt;scsidone
op_assign
id|scsi_finish_command
suffix:semicolon
r_switch
c_cond
(paren
id|qc-&gt;tf.protocol
)paren
(brace
r_case
id|ATA_PROT_DMA
suffix:colon
r_case
id|ATA_PROT_ATAPI_DMA
suffix:colon
id|host_stat
op_assign
id|ata_bmdma_status
c_func
(paren
id|ap
)paren
suffix:semicolon
multiline_comment|/* before we do anything else, clear DMA-Start bit */
id|ata_bmdma_stop
c_func
(paren
id|ap
)paren
suffix:semicolon
multiline_comment|/* fall through */
r_default
suffix:colon
id|ata_altstatus
c_func
(paren
id|ap
)paren
suffix:semicolon
id|drv_stat
op_assign
id|ata_chk_status
c_func
(paren
id|ap
)paren
suffix:semicolon
multiline_comment|/* ack bmdma irq events */
id|ata_bmdma_ack_irq
c_func
(paren
id|ap
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ata%u: command 0x%x timeout, stat 0x%x host_stat 0x%x&bslash;n&quot;
comma
id|ap-&gt;id
comma
id|qc-&gt;tf.command
comma
id|drv_stat
comma
id|host_stat
)paren
suffix:semicolon
multiline_comment|/* complete taskfile transaction */
id|ata_qc_complete
c_func
(paren
id|qc
comma
id|drv_stat
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|out
suffix:colon
id|DPRINTK
c_func
(paren
l_string|&quot;EXIT&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_eng_timeout - Handle timeout of queued command&n; *&t;@ap: Port on which timed-out command is active&n; *&n; *&t;Some part of the kernel (currently, only the SCSI layer)&n; *&t;has noticed that the active command on port @ap has not&n; *&t;completed after a specified length of time.  Handle this&n; *&t;condition by disabling DMA (if necessary) and completing&n; *&t;transactions, with error if necessary.&n; *&n; *&t;This also handles the case of the &quot;lost interrupt&quot;, where&n; *&t;for some reason (possibly hardware bug, possibly driver bug)&n; *&t;an interrupt was not delivered to the driver, even though the&n; *&t;transaction completed successfully.&n; *&n; *&t;LOCKING:&n; *&t;Inherited from SCSI layer (none, can sleep)&n; */
DECL|function|ata_eng_timeout
r_void
id|ata_eng_timeout
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
)paren
(brace
r_struct
id|ata_queued_cmd
op_star
id|qc
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;ENTER&bslash;n&quot;
)paren
suffix:semicolon
id|qc
op_assign
id|ata_qc_from_tag
c_func
(paren
id|ap
comma
id|ap-&gt;active_tag
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|qc
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ata%u: BUG: timeout without command&bslash;n&quot;
comma
id|ap-&gt;id
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|ata_qc_timeout
c_func
(paren
id|qc
)paren
suffix:semicolon
id|out
suffix:colon
id|DPRINTK
c_func
(paren
l_string|&quot;EXIT&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_qc_new - Request an available ATA command, for queueing&n; *&t;@ap: Port associated with device @dev&n; *&t;@dev: Device from whom we request an available command structure&n; *&n; *&t;LOCKING:&n; */
DECL|function|ata_qc_new
r_static
r_struct
id|ata_queued_cmd
op_star
id|ata_qc_new
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
)paren
(brace
r_struct
id|ata_queued_cmd
op_star
id|qc
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ATA_MAX_QUEUE
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
id|i
comma
op_amp
id|ap-&gt;qactive
)paren
)paren
(brace
id|qc
op_assign
id|ata_qc_from_tag
c_func
(paren
id|ap
comma
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|qc
)paren
id|qc-&gt;tag
op_assign
id|i
suffix:semicolon
r_return
id|qc
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_qc_new_init - Request an available ATA command, and initialize it&n; *&t;@ap: Port associated with device @dev&n; *&t;@dev: Device from whom we request an available command structure&n; *&n; *&t;LOCKING:&n; */
DECL|function|ata_qc_new_init
r_struct
id|ata_queued_cmd
op_star
id|ata_qc_new_init
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_struct
id|ata_device
op_star
id|dev
)paren
(brace
r_struct
id|ata_queued_cmd
op_star
id|qc
suffix:semicolon
id|qc
op_assign
id|ata_qc_new
c_func
(paren
id|ap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qc
)paren
(brace
id|qc-&gt;sg
op_assign
l_int|NULL
suffix:semicolon
id|qc-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|qc-&gt;scsicmd
op_assign
l_int|NULL
suffix:semicolon
id|qc-&gt;ap
op_assign
id|ap
suffix:semicolon
id|qc-&gt;dev
op_assign
id|dev
suffix:semicolon
id|qc-&gt;cursect
op_assign
id|qc-&gt;cursg
op_assign
id|qc-&gt;cursg_ofs
op_assign
l_int|0
suffix:semicolon
id|qc-&gt;nsect
op_assign
l_int|0
suffix:semicolon
id|qc-&gt;nbytes
op_assign
id|qc-&gt;curbytes
op_assign
l_int|0
suffix:semicolon
id|ata_tf_init
c_func
(paren
id|ap
comma
op_amp
id|qc-&gt;tf
comma
id|dev-&gt;devno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|ATA_DFLAG_LBA48
)paren
id|qc-&gt;tf.flags
op_or_assign
id|ATA_TFLAG_LBA48
suffix:semicolon
)brace
r_return
id|qc
suffix:semicolon
)brace
DECL|function|ata_qc_complete_noop
r_static
r_int
id|ata_qc_complete_noop
c_func
(paren
r_struct
id|ata_queued_cmd
op_star
id|qc
comma
id|u8
id|drv_stat
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|__ata_qc_complete
r_static
r_void
id|__ata_qc_complete
c_func
(paren
r_struct
id|ata_queued_cmd
op_star
id|qc
)paren
(brace
r_struct
id|ata_port
op_star
id|ap
op_assign
id|qc-&gt;ap
suffix:semicolon
r_int
r_int
id|tag
comma
id|do_clear
op_assign
l_int|0
suffix:semicolon
id|qc-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|tag
op_assign
id|qc-&gt;tag
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|ata_tag_valid
c_func
(paren
id|tag
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|tag
op_eq
id|ap-&gt;active_tag
)paren
id|ap-&gt;active_tag
op_assign
id|ATA_TAG_POISON
suffix:semicolon
id|qc-&gt;tag
op_assign
id|ATA_TAG_POISON
suffix:semicolon
id|do_clear
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|qc-&gt;waiting
)paren
(brace
r_struct
id|completion
op_star
id|waiting
op_assign
id|qc-&gt;waiting
suffix:semicolon
id|qc-&gt;waiting
op_assign
l_int|NULL
suffix:semicolon
id|complete
c_func
(paren
id|waiting
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|do_clear
)paren
)paren
id|clear_bit
c_func
(paren
id|tag
comma
op_amp
id|ap-&gt;qactive
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_qc_complete - Complete an active ATA command&n; *&t;@qc: Command to complete&n; *&t;@drv_stat: ATA status register contents&n; *&n; *&t;LOCKING:&n; *&n; */
DECL|function|ata_qc_complete
r_void
id|ata_qc_complete
c_func
(paren
r_struct
id|ata_queued_cmd
op_star
id|qc
comma
id|u8
id|drv_stat
)paren
(brace
r_int
id|rc
suffix:semicolon
m_assert
(paren
id|qc
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* ata_qc_from_tag _might_ return NULL */
m_assert
(paren
id|qc-&gt;flags
op_amp
id|ATA_QCFLAG_ACTIVE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|qc-&gt;flags
op_amp
id|ATA_QCFLAG_DMAMAP
)paren
)paren
id|ata_sg_clean
c_func
(paren
id|qc
)paren
suffix:semicolon
multiline_comment|/* call completion callback */
id|rc
op_assign
id|qc
op_member_access_from_pointer
id|complete_fn
c_func
(paren
id|qc
comma
id|drv_stat
)paren
suffix:semicolon
multiline_comment|/* if callback indicates not to complete command (non-zero),&n;&t; * return immediately&n;&t; */
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
r_return
suffix:semicolon
id|__ata_qc_complete
c_func
(paren
id|qc
)paren
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;EXIT&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_qc_issue - issue taskfile to device&n; *&t;@qc: command to issue to device&n; *&n; *&t;Prepare an ATA command to submission to device.&n; *&t;This includes mapping the data into a DMA-able&n; *&t;area, filling in the S/G table, and finally&n; *&t;writing the taskfile to hardware, starting the command.&n; *&n; *&t;LOCKING:&n; *&t;spin_lock_irqsave(host_set lock)&n; *&n; *&t;RETURNS:&n; *&t;Zero on success, negative on error.&n; */
DECL|function|ata_qc_issue
r_int
id|ata_qc_issue
c_func
(paren
r_struct
id|ata_queued_cmd
op_star
id|qc
)paren
(brace
r_struct
id|ata_port
op_star
id|ap
op_assign
id|qc-&gt;ap
suffix:semicolon
r_if
c_cond
(paren
id|qc-&gt;flags
op_amp
id|ATA_QCFLAG_SG
)paren
(brace
r_if
c_cond
(paren
id|ata_sg_setup
c_func
(paren
id|qc
)paren
)paren
r_goto
id|err_out
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|qc-&gt;flags
op_amp
id|ATA_QCFLAG_SINGLE
)paren
(brace
r_if
c_cond
(paren
id|ata_sg_setup_one
c_func
(paren
id|qc
)paren
)paren
r_goto
id|err_out
suffix:semicolon
)brace
id|ap-&gt;ops
op_member_access_from_pointer
id|qc_prep
c_func
(paren
id|qc
)paren
suffix:semicolon
id|qc-&gt;ap-&gt;active_tag
op_assign
id|qc-&gt;tag
suffix:semicolon
id|qc-&gt;flags
op_or_assign
id|ATA_QCFLAG_ACTIVE
suffix:semicolon
r_return
id|ap-&gt;ops
op_member_access_from_pointer
id|qc_issue
c_func
(paren
id|qc
)paren
suffix:semicolon
id|err_out
suffix:colon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_qc_issue_prot - issue taskfile to device in proto-dependent manner&n; *&t;@qc: command to issue to device&n; *&n; *&t;Using various libata functions and hooks, this function&n; *&t;starts an ATA command.  ATA commands are grouped into&n; *&t;classes called &quot;protocols&quot;, and issuing each type of protocol&n; *&t;is slightly different.&n; *&n; *&t;LOCKING:&n; *&t;spin_lock_irqsave(host_set lock)&n; *&n; *&t;RETURNS:&n; *&t;Zero on success, negative on error.&n; */
DECL|function|ata_qc_issue_prot
r_int
id|ata_qc_issue_prot
c_func
(paren
r_struct
id|ata_queued_cmd
op_star
id|qc
)paren
(brace
r_struct
id|ata_port
op_star
id|ap
op_assign
id|qc-&gt;ap
suffix:semicolon
id|ata_dev_select
c_func
(paren
id|ap
comma
id|qc-&gt;dev-&gt;devno
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|qc-&gt;tf.protocol
)paren
(brace
r_case
id|ATA_PROT_NODATA
suffix:colon
id|ata_tf_to_host_nolock
c_func
(paren
id|ap
comma
op_amp
id|qc-&gt;tf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ATA_PROT_DMA
suffix:colon
id|ap-&gt;ops
op_member_access_from_pointer
id|tf_load
c_func
(paren
id|ap
comma
op_amp
id|qc-&gt;tf
)paren
suffix:semicolon
multiline_comment|/* load tf registers */
id|ap-&gt;ops
op_member_access_from_pointer
id|bmdma_setup
c_func
(paren
id|qc
)paren
suffix:semicolon
multiline_comment|/* set up bmdma */
id|ap-&gt;ops
op_member_access_from_pointer
id|bmdma_start
c_func
(paren
id|qc
)paren
suffix:semicolon
multiline_comment|/* initiate bmdma */
r_break
suffix:semicolon
r_case
id|ATA_PROT_PIO
suffix:colon
multiline_comment|/* load tf registers, initiate polling pio */
id|ata_qc_set_polling
c_func
(paren
id|qc
)paren
suffix:semicolon
id|ata_tf_to_host_nolock
c_func
(paren
id|ap
comma
op_amp
id|qc-&gt;tf
)paren
suffix:semicolon
id|ap-&gt;pio_task_state
op_assign
id|PIO_ST
suffix:semicolon
id|queue_work
c_func
(paren
id|ata_wq
comma
op_amp
id|ap-&gt;pio_task
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ATA_PROT_ATAPI
suffix:colon
id|ata_qc_set_polling
c_func
(paren
id|qc
)paren
suffix:semicolon
id|ata_tf_to_host_nolock
c_func
(paren
id|ap
comma
op_amp
id|qc-&gt;tf
)paren
suffix:semicolon
id|queue_work
c_func
(paren
id|ata_wq
comma
op_amp
id|ap-&gt;packet_task
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ATA_PROT_ATAPI_NODATA
suffix:colon
id|ata_tf_to_host_nolock
c_func
(paren
id|ap
comma
op_amp
id|qc-&gt;tf
)paren
suffix:semicolon
id|queue_work
c_func
(paren
id|ata_wq
comma
op_amp
id|ap-&gt;packet_task
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ATA_PROT_ATAPI_DMA
suffix:colon
id|ap-&gt;ops
op_member_access_from_pointer
id|tf_load
c_func
(paren
id|ap
comma
op_amp
id|qc-&gt;tf
)paren
suffix:semicolon
multiline_comment|/* load tf registers */
id|ap-&gt;ops
op_member_access_from_pointer
id|bmdma_setup
c_func
(paren
id|qc
)paren
suffix:semicolon
multiline_comment|/* set up bmdma */
id|queue_work
c_func
(paren
id|ata_wq
comma
op_amp
id|ap-&gt;packet_task
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|WARN_ON
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_bmdma_setup - Set up PCI IDE BMDMA transaction&n; *&t;@qc: Info associated with this ATA transaction.&n; *&n; *&t;LOCKING:&n; *&t;spin_lock_irqsave(host_set lock)&n; */
DECL|function|ata_bmdma_setup_mmio
r_static
r_void
id|ata_bmdma_setup_mmio
(paren
r_struct
id|ata_queued_cmd
op_star
id|qc
)paren
(brace
r_struct
id|ata_port
op_star
id|ap
op_assign
id|qc-&gt;ap
suffix:semicolon
r_int
r_int
id|rw
op_assign
(paren
id|qc-&gt;tf.flags
op_amp
id|ATA_TFLAG_WRITE
)paren
suffix:semicolon
id|u8
id|dmactl
suffix:semicolon
r_void
id|__iomem
op_star
id|mmio
op_assign
(paren
r_void
id|__iomem
op_star
)paren
id|ap-&gt;ioaddr.bmdma_addr
suffix:semicolon
multiline_comment|/* load PRD table addr. */
id|mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* make sure PRD table writes are visible to controller */
id|writel
c_func
(paren
id|ap-&gt;prd_dma
comma
id|mmio
op_plus
id|ATA_DMA_TABLE_OFS
)paren
suffix:semicolon
multiline_comment|/* specify data direction, triple-check start bit is clear */
id|dmactl
op_assign
id|readb
c_func
(paren
id|mmio
op_plus
id|ATA_DMA_CMD
)paren
suffix:semicolon
id|dmactl
op_and_assign
op_complement
(paren
id|ATA_DMA_WR
op_or
id|ATA_DMA_START
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rw
)paren
id|dmactl
op_or_assign
id|ATA_DMA_WR
suffix:semicolon
id|writeb
c_func
(paren
id|dmactl
comma
id|mmio
op_plus
id|ATA_DMA_CMD
)paren
suffix:semicolon
multiline_comment|/* issue r/w command */
id|ap-&gt;ops
op_member_access_from_pointer
id|exec_command
c_func
(paren
id|ap
comma
op_amp
id|qc-&gt;tf
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_bmdma_start - Start a PCI IDE BMDMA transaction&n; *&t;@qc: Info associated with this ATA transaction.&n; *&n; *&t;LOCKING:&n; *&t;spin_lock_irqsave(host_set lock)&n; */
DECL|function|ata_bmdma_start_mmio
r_static
r_void
id|ata_bmdma_start_mmio
(paren
r_struct
id|ata_queued_cmd
op_star
id|qc
)paren
(brace
r_struct
id|ata_port
op_star
id|ap
op_assign
id|qc-&gt;ap
suffix:semicolon
r_void
id|__iomem
op_star
id|mmio
op_assign
(paren
r_void
id|__iomem
op_star
)paren
id|ap-&gt;ioaddr.bmdma_addr
suffix:semicolon
id|u8
id|dmactl
suffix:semicolon
multiline_comment|/* start host DMA transaction */
id|dmactl
op_assign
id|readb
c_func
(paren
id|mmio
op_plus
id|ATA_DMA_CMD
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|dmactl
op_or
id|ATA_DMA_START
comma
id|mmio
op_plus
id|ATA_DMA_CMD
)paren
suffix:semicolon
multiline_comment|/* Strictly, one may wish to issue a readb() here, to&n;&t; * flush the mmio write.  However, control also passes&n;&t; * to the hardware at this point, and it will interrupt&n;&t; * us when we are to resume control.  So, in effect,&n;&t; * we don&squot;t care when the mmio write flushes.&n;&t; * Further, a read of the DMA status register _immediately_&n;&t; * following the write may not be what certain flaky hardware&n;&t; * is expected, so I think it is best to not add a readb()&n;&t; * without first all the MMIO ATA cards/mobos.&n;&t; * Or maybe I&squot;m just being paranoid.&n;&t; */
)brace
multiline_comment|/**&n; *&t;ata_bmdma_setup_pio - Set up PCI IDE BMDMA transaction (PIO)&n; *&t;@qc: Info associated with this ATA transaction.&n; *&n; *&t;LOCKING:&n; *&t;spin_lock_irqsave(host_set lock)&n; */
DECL|function|ata_bmdma_setup_pio
r_static
r_void
id|ata_bmdma_setup_pio
(paren
r_struct
id|ata_queued_cmd
op_star
id|qc
)paren
(brace
r_struct
id|ata_port
op_star
id|ap
op_assign
id|qc-&gt;ap
suffix:semicolon
r_int
r_int
id|rw
op_assign
(paren
id|qc-&gt;tf.flags
op_amp
id|ATA_TFLAG_WRITE
)paren
suffix:semicolon
id|u8
id|dmactl
suffix:semicolon
multiline_comment|/* load PRD table addr. */
id|outl
c_func
(paren
id|ap-&gt;prd_dma
comma
id|ap-&gt;ioaddr.bmdma_addr
op_plus
id|ATA_DMA_TABLE_OFS
)paren
suffix:semicolon
multiline_comment|/* specify data direction, triple-check start bit is clear */
id|dmactl
op_assign
id|inb
c_func
(paren
id|ap-&gt;ioaddr.bmdma_addr
op_plus
id|ATA_DMA_CMD
)paren
suffix:semicolon
id|dmactl
op_and_assign
op_complement
(paren
id|ATA_DMA_WR
op_or
id|ATA_DMA_START
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rw
)paren
id|dmactl
op_or_assign
id|ATA_DMA_WR
suffix:semicolon
id|outb
c_func
(paren
id|dmactl
comma
id|ap-&gt;ioaddr.bmdma_addr
op_plus
id|ATA_DMA_CMD
)paren
suffix:semicolon
multiline_comment|/* issue r/w command */
id|ap-&gt;ops
op_member_access_from_pointer
id|exec_command
c_func
(paren
id|ap
comma
op_amp
id|qc-&gt;tf
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_bmdma_start_pio - Start a PCI IDE BMDMA transaction (PIO)&n; *&t;@qc: Info associated with this ATA transaction.&n; *&n; *&t;LOCKING:&n; *&t;spin_lock_irqsave(host_set lock)&n; */
DECL|function|ata_bmdma_start_pio
r_static
r_void
id|ata_bmdma_start_pio
(paren
r_struct
id|ata_queued_cmd
op_star
id|qc
)paren
(brace
r_struct
id|ata_port
op_star
id|ap
op_assign
id|qc-&gt;ap
suffix:semicolon
id|u8
id|dmactl
suffix:semicolon
multiline_comment|/* start host DMA transaction */
id|dmactl
op_assign
id|inb
c_func
(paren
id|ap-&gt;ioaddr.bmdma_addr
op_plus
id|ATA_DMA_CMD
)paren
suffix:semicolon
id|outb
c_func
(paren
id|dmactl
op_or
id|ATA_DMA_START
comma
id|ap-&gt;ioaddr.bmdma_addr
op_plus
id|ATA_DMA_CMD
)paren
suffix:semicolon
)brace
DECL|function|ata_bmdma_start
r_void
id|ata_bmdma_start
c_func
(paren
r_struct
id|ata_queued_cmd
op_star
id|qc
)paren
(brace
r_if
c_cond
(paren
id|qc-&gt;ap-&gt;flags
op_amp
id|ATA_FLAG_MMIO
)paren
id|ata_bmdma_start_mmio
c_func
(paren
id|qc
)paren
suffix:semicolon
r_else
id|ata_bmdma_start_pio
c_func
(paren
id|qc
)paren
suffix:semicolon
)brace
DECL|function|ata_bmdma_setup
r_void
id|ata_bmdma_setup
c_func
(paren
r_struct
id|ata_queued_cmd
op_star
id|qc
)paren
(brace
r_if
c_cond
(paren
id|qc-&gt;ap-&gt;flags
op_amp
id|ATA_FLAG_MMIO
)paren
id|ata_bmdma_setup_mmio
c_func
(paren
id|qc
)paren
suffix:semicolon
r_else
id|ata_bmdma_setup_pio
c_func
(paren
id|qc
)paren
suffix:semicolon
)brace
DECL|function|ata_bmdma_irq_clear
r_void
id|ata_bmdma_irq_clear
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
)paren
(brace
id|ata_bmdma_ack_irq
c_func
(paren
id|ap
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_host_intr - Handle host interrupt for given (port, task)&n; *&t;@ap: Port on which interrupt arrived (possibly...)&n; *&t;@qc: Taskfile currently active in engine&n; *&n; *&t;Handle host interrupt for given queued command.  Currently,&n; *&t;only DMA interrupts are handled.  All other commands are&n; *&t;handled via polling with interrupts disabled (nIEN bit).&n; *&n; *&t;LOCKING:&n; *&t;spin_lock_irqsave(host_set lock)&n; *&n; *&t;RETURNS:&n; *&t;One if interrupt was handled, zero if not (shared irq).&n; */
DECL|function|ata_host_intr
r_inline
r_int
r_int
id|ata_host_intr
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_struct
id|ata_queued_cmd
op_star
id|qc
)paren
(brace
id|u8
id|status
comma
id|host_stat
suffix:semicolon
r_switch
c_cond
(paren
id|qc-&gt;tf.protocol
)paren
(brace
r_case
id|ATA_PROT_DMA
suffix:colon
r_case
id|ATA_PROT_ATAPI_DMA
suffix:colon
r_case
id|ATA_PROT_ATAPI
suffix:colon
multiline_comment|/* check status of DMA engine */
id|host_stat
op_assign
id|ata_bmdma_status
c_func
(paren
id|ap
)paren
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;ata%u: host_stat 0x%X&bslash;n&quot;
comma
id|ap-&gt;id
comma
id|host_stat
)paren
suffix:semicolon
multiline_comment|/* if it&squot;s not our irq... */
r_if
c_cond
(paren
op_logical_neg
(paren
id|host_stat
op_amp
id|ATA_DMA_INTR
)paren
)paren
r_goto
id|idle_irq
suffix:semicolon
multiline_comment|/* before we do anything else, clear DMA-Start bit */
id|ata_bmdma_stop
c_func
(paren
id|ap
)paren
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|ATA_PROT_ATAPI_NODATA
suffix:colon
r_case
id|ATA_PROT_NODATA
suffix:colon
multiline_comment|/* check altstatus */
id|status
op_assign
id|ata_altstatus
c_func
(paren
id|ap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|ATA_BUSY
)paren
r_goto
id|idle_irq
suffix:semicolon
multiline_comment|/* check main status, clearing INTRQ */
id|status
op_assign
id|ata_chk_status
c_func
(paren
id|ap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|status
op_amp
id|ATA_BUSY
)paren
)paren
r_goto
id|idle_irq
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;ata%u: protocol %d (dev_stat 0x%X)&bslash;n&quot;
comma
id|ap-&gt;id
comma
id|qc-&gt;tf.protocol
comma
id|status
)paren
suffix:semicolon
multiline_comment|/* ack bmdma irq events */
id|ata_bmdma_ack_irq
c_func
(paren
id|ap
)paren
suffix:semicolon
multiline_comment|/* complete taskfile transaction */
id|ata_qc_complete
c_func
(paren
id|qc
comma
id|status
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_goto
id|idle_irq
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* irq handled */
id|idle_irq
suffix:colon
id|ap-&gt;stats.idle_irq
op_increment
suffix:semicolon
macro_line|#ifdef ATA_IRQ_TRAP
r_if
c_cond
(paren
(paren
id|ap-&gt;stats.idle_irq
op_mod
l_int|1000
)paren
op_eq
l_int|0
)paren
(brace
id|handled
op_assign
l_int|1
suffix:semicolon
id|ata_irq_ack
c_func
(paren
id|ap
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* debug trap */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ata%d: irq trap&bslash;n&quot;
comma
id|ap-&gt;id
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
multiline_comment|/* irq not handled */
)brace
multiline_comment|/**&n; *&t;ata_interrupt - Default ATA host interrupt handler&n; *&t;@irq: irq line&n; *&t;@dev_instance: pointer to our host information structure&n; *&t;@regs: unused&n; *&n; *&t;LOCKING:&n; *&n; *&t;RETURNS:&n; *&n; */
DECL|function|ata_interrupt
id|irqreturn_t
id|ata_interrupt
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_instance
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|ata_host_set
op_star
id|host_set
op_assign
id|dev_instance
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|handled
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* TODO: make _irqsave conditional on x86 PCI IDE legacy mode */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|host_set-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|host_set-&gt;n_ports
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ata_port
op_star
id|ap
suffix:semicolon
id|ap
op_assign
id|host_set-&gt;ports
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ap
op_logical_and
(paren
op_logical_neg
(paren
id|ap-&gt;flags
op_amp
id|ATA_FLAG_PORT_DISABLED
)paren
)paren
)paren
(brace
r_struct
id|ata_queued_cmd
op_star
id|qc
suffix:semicolon
id|qc
op_assign
id|ata_qc_from_tag
c_func
(paren
id|ap
comma
id|ap-&gt;active_tag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qc
op_logical_and
(paren
op_logical_neg
(paren
id|qc-&gt;tf.ctl
op_amp
id|ATA_NIEN
)paren
)paren
)paren
id|handled
op_or_assign
id|ata_host_intr
c_func
(paren
id|ap
comma
id|qc
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|host_set-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|IRQ_RETVAL
c_func
(paren
id|handled
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;atapi_packet_task - Write CDB bytes to hardware&n; *&t;@_data: Port to which ATAPI device is attached.&n; *&n; *&t;When device has indicated its readiness to accept&n; *&t;a CDB, this function is called.  Send the CDB.&n; *&t;If DMA is to be performed, exit immediately.&n; *&t;Otherwise, we are in polling mode, so poll&n; *&t;status under operation succeeds or fails.&n; *&n; *&t;LOCKING:&n; *&t;Kernel thread context (may sleep)&n; */
DECL|function|atapi_packet_task
r_static
r_void
id|atapi_packet_task
c_func
(paren
r_void
op_star
id|_data
)paren
(brace
r_struct
id|ata_port
op_star
id|ap
op_assign
id|_data
suffix:semicolon
r_struct
id|ata_queued_cmd
op_star
id|qc
suffix:semicolon
id|u8
id|status
suffix:semicolon
id|qc
op_assign
id|ata_qc_from_tag
c_func
(paren
id|ap
comma
id|ap-&gt;active_tag
)paren
suffix:semicolon
m_assert
(paren
id|qc
op_ne
l_int|NULL
)paren
suffix:semicolon
m_assert
(paren
id|qc-&gt;flags
op_amp
id|ATA_QCFLAG_ACTIVE
)paren
suffix:semicolon
multiline_comment|/* sleep-wait for BSY to clear */
id|DPRINTK
c_func
(paren
l_string|&quot;busy wait&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ata_busy_sleep
c_func
(paren
id|ap
comma
id|ATA_TMOUT_CDB_QUICK
comma
id|ATA_TMOUT_CDB
)paren
)paren
r_goto
id|err_out
suffix:semicolon
multiline_comment|/* make sure DRQ is set */
id|status
op_assign
id|ata_chk_status
c_func
(paren
id|ap
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
(paren
id|ATA_BUSY
op_or
id|ATA_DRQ
)paren
)paren
op_ne
id|ATA_DRQ
)paren
r_goto
id|err_out
suffix:semicolon
multiline_comment|/* send SCSI cdb */
id|DPRINTK
c_func
(paren
l_string|&quot;send cdb&bslash;n&quot;
)paren
suffix:semicolon
m_assert
(paren
id|ap-&gt;cdb_len
op_ge
l_int|12
)paren
suffix:semicolon
id|ata_data_xfer
c_func
(paren
id|ap
comma
id|qc-&gt;cdb
comma
id|ap-&gt;cdb_len
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* if we are DMA&squot;ing, irq handler takes over from here */
r_if
c_cond
(paren
id|qc-&gt;tf.protocol
op_eq
id|ATA_PROT_ATAPI_DMA
)paren
id|ap-&gt;ops
op_member_access_from_pointer
id|bmdma_start
c_func
(paren
id|qc
)paren
suffix:semicolon
multiline_comment|/* initiate bmdma */
multiline_comment|/* non-data commands are also handled via irq */
r_else
r_if
c_cond
(paren
id|qc-&gt;tf.protocol
op_eq
id|ATA_PROT_ATAPI_NODATA
)paren
(brace
multiline_comment|/* do nothing */
)brace
multiline_comment|/* PIO commands are handled by polling */
r_else
(brace
id|ap-&gt;pio_task_state
op_assign
id|PIO_ST
suffix:semicolon
id|queue_work
c_func
(paren
id|ata_wq
comma
op_amp
id|ap-&gt;pio_task
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
id|err_out
suffix:colon
id|ata_qc_complete
c_func
(paren
id|qc
comma
id|ATA_ERR
)paren
suffix:semicolon
)brace
DECL|function|ata_port_start
r_int
id|ata_port_start
(paren
r_struct
id|ata_port
op_star
id|ap
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
id|ap-&gt;host_set-&gt;dev
suffix:semicolon
id|ap-&gt;prd
op_assign
id|dma_alloc_coherent
c_func
(paren
id|dev
comma
id|ATA_PRD_TBL_SZ
comma
op_amp
id|ap-&gt;prd_dma
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ap-&gt;prd
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;prd alloc, virt %p, dma %llx&bslash;n&quot;
comma
id|ap-&gt;prd
comma
(paren
r_int
r_int
r_int
)paren
id|ap-&gt;prd_dma
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ata_port_stop
r_void
id|ata_port_stop
(paren
r_struct
id|ata_port
op_star
id|ap
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
id|ap-&gt;host_set-&gt;dev
suffix:semicolon
id|dma_free_coherent
c_func
(paren
id|dev
comma
id|ATA_PRD_TBL_SZ
comma
id|ap-&gt;prd
comma
id|ap-&gt;prd_dma
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_host_remove - Unregister SCSI host structure with upper layers&n; *&t;@ap: Port to unregister&n; *&t;@do_unregister: 1 if we fully unregister, 0 to just stop the port&n; *&n; *&t;LOCKING:&n; */
DECL|function|ata_host_remove
r_static
r_void
id|ata_host_remove
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_int
r_int
id|do_unregister
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|sh
op_assign
id|ap-&gt;host
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;ENTER&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|do_unregister
)paren
id|scsi_remove_host
c_func
(paren
id|sh
)paren
suffix:semicolon
id|ap-&gt;ops
op_member_access_from_pointer
id|port_stop
c_func
(paren
id|ap
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_host_init - Initialize an ata_port structure&n; *&t;@ap: Structure to initialize&n; *&t;@host: associated SCSI mid-layer structure&n; *&t;@host_set: Collection of hosts to which @ap belongs&n; *&t;@ent: Probe information provided by low-level driver&n; *&t;@port_no: Port number associated with this ata_port&n; *&n; *&t;LOCKING:&n; *&n; */
DECL|function|ata_host_init
r_static
r_void
id|ata_host_init
c_func
(paren
r_struct
id|ata_port
op_star
id|ap
comma
r_struct
id|Scsi_Host
op_star
id|host
comma
r_struct
id|ata_host_set
op_star
id|host_set
comma
r_struct
id|ata_probe_ent
op_star
id|ent
comma
r_int
r_int
id|port_no
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
id|host-&gt;max_id
op_assign
l_int|16
suffix:semicolon
id|host-&gt;max_lun
op_assign
l_int|1
suffix:semicolon
id|host-&gt;max_channel
op_assign
l_int|1
suffix:semicolon
id|host-&gt;unique_id
op_assign
id|ata_unique_id
op_increment
suffix:semicolon
id|host-&gt;max_cmd_len
op_assign
l_int|12
suffix:semicolon
id|scsi_set_device
c_func
(paren
id|host
comma
id|ent-&gt;dev
)paren
suffix:semicolon
id|scsi_assign_lock
c_func
(paren
id|host
comma
op_amp
id|host_set-&gt;lock
)paren
suffix:semicolon
id|ap-&gt;flags
op_assign
id|ATA_FLAG_PORT_DISABLED
suffix:semicolon
id|ap-&gt;id
op_assign
id|host-&gt;unique_id
suffix:semicolon
id|ap-&gt;host
op_assign
id|host
suffix:semicolon
id|ap-&gt;ctl
op_assign
id|ATA_DEVCTL_OBS
suffix:semicolon
id|ap-&gt;host_set
op_assign
id|host_set
suffix:semicolon
id|ap-&gt;port_no
op_assign
id|port_no
suffix:semicolon
id|ap-&gt;hard_port_no
op_assign
id|ent-&gt;legacy_mode
ques
c_cond
id|ent-&gt;hard_port_no
suffix:colon
id|port_no
suffix:semicolon
id|ap-&gt;pio_mask
op_assign
id|ent-&gt;pio_mask
suffix:semicolon
id|ap-&gt;mwdma_mask
op_assign
id|ent-&gt;mwdma_mask
suffix:semicolon
id|ap-&gt;udma_mask
op_assign
id|ent-&gt;udma_mask
suffix:semicolon
id|ap-&gt;flags
op_or_assign
id|ent-&gt;host_flags
suffix:semicolon
id|ap-&gt;ops
op_assign
id|ent-&gt;port_ops
suffix:semicolon
id|ap-&gt;cbl
op_assign
id|ATA_CBL_NONE
suffix:semicolon
id|ap-&gt;active_tag
op_assign
id|ATA_TAG_POISON
suffix:semicolon
id|ap-&gt;last_ctl
op_assign
l_int|0xFF
suffix:semicolon
id|INIT_WORK
c_func
(paren
op_amp
id|ap-&gt;packet_task
comma
id|atapi_packet_task
comma
id|ap
)paren
suffix:semicolon
id|INIT_WORK
c_func
(paren
op_amp
id|ap-&gt;pio_task
comma
id|ata_pio_task
comma
id|ap
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ATA_MAX_DEVICES
suffix:semicolon
id|i
op_increment
)paren
id|ap-&gt;device
(braket
id|i
)braket
dot
id|devno
op_assign
id|i
suffix:semicolon
macro_line|#ifdef ATA_IRQ_TRAP
id|ap-&gt;stats.unhandled_irq
op_assign
l_int|1
suffix:semicolon
id|ap-&gt;stats.idle_irq
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
id|memcpy
c_func
(paren
op_amp
id|ap-&gt;ioaddr
comma
op_amp
id|ent-&gt;port
(braket
id|port_no
)braket
comma
r_sizeof
(paren
r_struct
id|ata_ioports
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_host_add - Attach low-level ATA driver to system&n; *&t;@ent: Information provided by low-level driver&n; *&t;@host_set: Collections of ports to which we add&n; *&t;@port_no: Port number associated with this host&n; *&n; *&t;LOCKING:&n; *&n; *&t;RETURNS:&n; *&n; */
DECL|function|ata_host_add
r_static
r_struct
id|ata_port
op_star
id|ata_host_add
c_func
(paren
r_struct
id|ata_probe_ent
op_star
id|ent
comma
r_struct
id|ata_host_set
op_star
id|host_set
comma
r_int
r_int
id|port_no
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
r_struct
id|ata_port
op_star
id|ap
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;ENTER&bslash;n&quot;
)paren
suffix:semicolon
id|host
op_assign
id|scsi_host_alloc
c_func
(paren
id|ent-&gt;sht
comma
r_sizeof
(paren
r_struct
id|ata_port
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|host
)paren
r_return
l_int|NULL
suffix:semicolon
id|ap
op_assign
(paren
r_struct
id|ata_port
op_star
)paren
op_amp
id|host-&gt;hostdata
(braket
l_int|0
)braket
suffix:semicolon
id|ata_host_init
c_func
(paren
id|ap
comma
id|host
comma
id|host_set
comma
id|ent
comma
id|port_no
)paren
suffix:semicolon
id|rc
op_assign
id|ap-&gt;ops
op_member_access_from_pointer
id|port_start
c_func
(paren
id|ap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|err_out
suffix:semicolon
r_return
id|ap
suffix:semicolon
id|err_out
suffix:colon
id|scsi_host_put
c_func
(paren
id|host
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_device_add -&n; *&t;@ent:&n; *&n; *&t;LOCKING:&n; *&n; *&t;RETURNS:&n; *&n; */
DECL|function|ata_device_add
r_int
id|ata_device_add
c_func
(paren
r_struct
id|ata_probe_ent
op_star
id|ent
)paren
(brace
r_int
r_int
id|count
op_assign
l_int|0
comma
id|i
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
id|ent-&gt;dev
suffix:semicolon
r_struct
id|ata_host_set
op_star
id|host_set
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;ENTER&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* alloc a container for our list of ATA ports (buses) */
id|host_set
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ata_host_set
)paren
op_plus
(paren
id|ent-&gt;n_ports
op_star
r_sizeof
(paren
r_void
op_star
)paren
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|host_set
)paren
r_return
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|host_set
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ata_host_set
)paren
op_plus
(paren
id|ent-&gt;n_ports
op_star
r_sizeof
(paren
r_void
op_star
)paren
)paren
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|host_set-&gt;lock
)paren
suffix:semicolon
id|host_set-&gt;dev
op_assign
id|dev
suffix:semicolon
id|host_set-&gt;n_ports
op_assign
id|ent-&gt;n_ports
suffix:semicolon
id|host_set-&gt;irq
op_assign
id|ent-&gt;irq
suffix:semicolon
id|host_set-&gt;mmio_base
op_assign
id|ent-&gt;mmio_base
suffix:semicolon
id|host_set-&gt;private_data
op_assign
id|ent-&gt;private_data
suffix:semicolon
id|host_set-&gt;ops
op_assign
id|ent-&gt;port_ops
suffix:semicolon
multiline_comment|/* register each port bound to this device */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ent-&gt;n_ports
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ata_port
op_star
id|ap
suffix:semicolon
r_int
r_int
id|xfer_mode_mask
suffix:semicolon
id|ap
op_assign
id|ata_host_add
c_func
(paren
id|ent
comma
id|host_set
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ap
)paren
r_goto
id|err_out
suffix:semicolon
id|host_set-&gt;ports
(braket
id|i
)braket
op_assign
id|ap
suffix:semicolon
id|xfer_mode_mask
op_assign
(paren
id|ap-&gt;udma_mask
op_lshift
id|ATA_SHIFT_UDMA
)paren
op_or
(paren
id|ap-&gt;mwdma_mask
op_lshift
id|ATA_SHIFT_MWDMA
)paren
op_or
(paren
id|ap-&gt;pio_mask
op_lshift
id|ATA_SHIFT_PIO
)paren
suffix:semicolon
multiline_comment|/* print per-port info to dmesg */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ata%u: %cATA max %s cmd 0x%lX ctl 0x%lX &quot;
l_string|&quot;bmdma 0x%lX irq %lu&bslash;n&quot;
comma
id|ap-&gt;id
comma
id|ap-&gt;flags
op_amp
id|ATA_FLAG_SATA
ques
c_cond
l_char|&squot;S&squot;
suffix:colon
l_char|&squot;P&squot;
comma
id|ata_mode_string
c_func
(paren
id|xfer_mode_mask
)paren
comma
id|ap-&gt;ioaddr.cmd_addr
comma
id|ap-&gt;ioaddr.ctl_addr
comma
id|ap-&gt;ioaddr.bmdma_addr
comma
id|ent-&gt;irq
)paren
suffix:semicolon
id|ata_chk_status
c_func
(paren
id|ap
)paren
suffix:semicolon
id|host_set-&gt;ops
op_member_access_from_pointer
id|irq_clear
c_func
(paren
id|ap
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
(brace
id|kfree
c_func
(paren
id|host_set
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* obtain irq, that is shared between channels */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|ent-&gt;irq
comma
id|ent-&gt;port_ops-&gt;irq_handler
comma
id|ent-&gt;irq_flags
comma
id|DRV_NAME
comma
id|host_set
)paren
)paren
r_goto
id|err_out
suffix:semicolon
multiline_comment|/* perform each probe synchronously */
id|DPRINTK
c_func
(paren
l_string|&quot;probe begin&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ata_port
op_star
id|ap
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|ap
op_assign
id|host_set-&gt;ports
(braket
id|i
)braket
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;ata%u: probe begin&bslash;n&quot;
comma
id|ap-&gt;id
)paren
suffix:semicolon
id|rc
op_assign
id|ata_bus_probe
c_func
(paren
id|ap
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;ata%u: probe end&bslash;n&quot;
comma
id|ap-&gt;id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
multiline_comment|/* FIXME: do something useful here?&n;&t;&t;&t; * Current libata behavior will&n;&t;&t;&t; * tear down everything when&n;&t;&t;&t; * the module is removed&n;&t;&t;&t; * or the h/w is unplugged.&n;&t;&t;&t; */
)brace
id|rc
op_assign
id|scsi_add_host
c_func
(paren
id|ap-&gt;host
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ata%u: scsi_add_host failed&bslash;n&quot;
comma
id|ap-&gt;id
)paren
suffix:semicolon
multiline_comment|/* FIXME: do something useful here */
multiline_comment|/* FIXME: handle unconditional calls to&n;&t;&t;&t; * scsi_scan_host and ata_host_remove, below,&n;&t;&t;&t; * at the very least&n;&t;&t;&t; */
)brace
)brace
multiline_comment|/* probes are done, now scan each port&squot;s disk(s) */
id|DPRINTK
c_func
(paren
l_string|&quot;probe begin&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ata_port
op_star
id|ap
op_assign
id|host_set-&gt;ports
(braket
id|i
)braket
suffix:semicolon
id|scsi_scan_host
c_func
(paren
id|ap-&gt;host
)paren
suffix:semicolon
)brace
id|dev_set_drvdata
c_func
(paren
id|dev
comma
id|host_set
)paren
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;EXIT, returning %u&bslash;n&quot;
comma
id|ent-&gt;n_ports
)paren
suffix:semicolon
r_return
id|ent-&gt;n_ports
suffix:semicolon
multiline_comment|/* success */
id|err_out
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ata_host_remove
c_func
(paren
id|host_set-&gt;ports
(braket
id|i
)braket
comma
l_int|1
)paren
suffix:semicolon
id|scsi_host_put
c_func
(paren
id|host_set-&gt;ports
(braket
id|i
)braket
op_member_access_from_pointer
id|host
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|host_set
)paren
suffix:semicolon
id|VPRINTK
c_func
(paren
l_string|&quot;EXIT, returning 0&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_scsi_release - SCSI layer callback hook for host unload&n; *&t;@host: libata host to be unloaded&n; *&n; *&t;Performs all duties necessary to shut down a libata port...&n; *&t;Kill port kthread, disable port, and release resources.&n; *&n; *&t;LOCKING:&n; *&t;Inherited from SCSI layer.&n; *&n; *&t;RETURNS:&n; *&t;One.&n; */
DECL|function|ata_scsi_release
r_int
id|ata_scsi_release
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_struct
id|ata_port
op_star
id|ap
op_assign
(paren
r_struct
id|ata_port
op_star
)paren
op_amp
id|host-&gt;hostdata
(braket
l_int|0
)braket
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;ENTER&bslash;n&quot;
)paren
suffix:semicolon
id|ap-&gt;ops
op_member_access_from_pointer
id|port_disable
c_func
(paren
id|ap
)paren
suffix:semicolon
id|ata_host_remove
c_func
(paren
id|ap
comma
l_int|0
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;EXIT&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_std_ports - initialize ioaddr with standard port offsets.&n; *&t;@ioaddr: IO address structure to be initialized&n; */
DECL|function|ata_std_ports
r_void
id|ata_std_ports
c_func
(paren
r_struct
id|ata_ioports
op_star
id|ioaddr
)paren
(brace
id|ioaddr-&gt;data_addr
op_assign
id|ioaddr-&gt;cmd_addr
op_plus
id|ATA_REG_DATA
suffix:semicolon
id|ioaddr-&gt;error_addr
op_assign
id|ioaddr-&gt;cmd_addr
op_plus
id|ATA_REG_ERR
suffix:semicolon
id|ioaddr-&gt;feature_addr
op_assign
id|ioaddr-&gt;cmd_addr
op_plus
id|ATA_REG_FEATURE
suffix:semicolon
id|ioaddr-&gt;nsect_addr
op_assign
id|ioaddr-&gt;cmd_addr
op_plus
id|ATA_REG_NSECT
suffix:semicolon
id|ioaddr-&gt;lbal_addr
op_assign
id|ioaddr-&gt;cmd_addr
op_plus
id|ATA_REG_LBAL
suffix:semicolon
id|ioaddr-&gt;lbam_addr
op_assign
id|ioaddr-&gt;cmd_addr
op_plus
id|ATA_REG_LBAM
suffix:semicolon
id|ioaddr-&gt;lbah_addr
op_assign
id|ioaddr-&gt;cmd_addr
op_plus
id|ATA_REG_LBAH
suffix:semicolon
id|ioaddr-&gt;device_addr
op_assign
id|ioaddr-&gt;cmd_addr
op_plus
id|ATA_REG_DEVICE
suffix:semicolon
id|ioaddr-&gt;status_addr
op_assign
id|ioaddr-&gt;cmd_addr
op_plus
id|ATA_REG_STATUS
suffix:semicolon
id|ioaddr-&gt;command_addr
op_assign
id|ioaddr-&gt;cmd_addr
op_plus
id|ATA_REG_CMD
suffix:semicolon
)brace
r_static
r_struct
id|ata_probe_ent
op_star
DECL|function|ata_probe_ent_alloc
id|ata_probe_ent_alloc
c_func
(paren
r_int
id|n
comma
r_struct
id|device
op_star
id|dev
comma
r_struct
id|ata_port_info
op_star
op_star
id|port
)paren
(brace
r_struct
id|ata_probe_ent
op_star
id|probe_ent
suffix:semicolon
r_int
id|i
suffix:semicolon
id|probe_ent
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|probe_ent
)paren
op_star
id|n
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|probe_ent
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|DRV_NAME
l_string|&quot;(%s): out of memory&bslash;n&quot;
comma
id|kobject_name
c_func
(paren
op_amp
(paren
id|dev-&gt;kobj
)paren
)paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|probe_ent
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|probe_ent
)paren
op_star
id|n
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|probe_ent
(braket
id|i
)braket
dot
id|node
)paren
suffix:semicolon
id|probe_ent
(braket
id|i
)braket
dot
id|dev
op_assign
id|dev
suffix:semicolon
id|probe_ent
(braket
id|i
)braket
dot
id|sht
op_assign
id|port
(braket
id|i
)braket
op_member_access_from_pointer
id|sht
suffix:semicolon
id|probe_ent
(braket
id|i
)braket
dot
id|host_flags
op_assign
id|port
(braket
id|i
)braket
op_member_access_from_pointer
id|host_flags
suffix:semicolon
id|probe_ent
(braket
id|i
)braket
dot
id|pio_mask
op_assign
id|port
(braket
id|i
)braket
op_member_access_from_pointer
id|pio_mask
suffix:semicolon
id|probe_ent
(braket
id|i
)braket
dot
id|mwdma_mask
op_assign
id|port
(braket
id|i
)braket
op_member_access_from_pointer
id|mwdma_mask
suffix:semicolon
id|probe_ent
(braket
id|i
)braket
dot
id|udma_mask
op_assign
id|port
(braket
id|i
)braket
op_member_access_from_pointer
id|udma_mask
suffix:semicolon
id|probe_ent
(braket
id|i
)braket
dot
id|port_ops
op_assign
id|port
(braket
id|i
)braket
op_member_access_from_pointer
id|port_ops
suffix:semicolon
)brace
r_return
id|probe_ent
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PCI
r_struct
id|ata_probe_ent
op_star
DECL|function|ata_pci_init_native_mode
id|ata_pci_init_native_mode
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_struct
id|ata_port_info
op_star
op_star
id|port
)paren
(brace
r_struct
id|ata_probe_ent
op_star
id|probe_ent
op_assign
id|ata_probe_ent_alloc
c_func
(paren
l_int|1
comma
id|pci_dev_to_dev
c_func
(paren
id|pdev
)paren
comma
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|probe_ent
)paren
r_return
l_int|NULL
suffix:semicolon
id|probe_ent-&gt;n_ports
op_assign
l_int|2
suffix:semicolon
id|probe_ent-&gt;irq
op_assign
id|pdev-&gt;irq
suffix:semicolon
id|probe_ent-&gt;irq_flags
op_assign
id|SA_SHIRQ
suffix:semicolon
id|probe_ent-&gt;port
(braket
l_int|0
)braket
dot
id|cmd_addr
op_assign
id|pci_resource_start
c_func
(paren
id|pdev
comma
l_int|0
)paren
suffix:semicolon
id|probe_ent-&gt;port
(braket
l_int|0
)braket
dot
id|altstatus_addr
op_assign
id|probe_ent-&gt;port
(braket
l_int|0
)braket
dot
id|ctl_addr
op_assign
id|pci_resource_start
c_func
(paren
id|pdev
comma
l_int|1
)paren
op_or
id|ATA_PCI_CTL_OFS
suffix:semicolon
id|probe_ent-&gt;port
(braket
l_int|0
)braket
dot
id|bmdma_addr
op_assign
id|pci_resource_start
c_func
(paren
id|pdev
comma
l_int|4
)paren
suffix:semicolon
id|probe_ent-&gt;port
(braket
l_int|1
)braket
dot
id|cmd_addr
op_assign
id|pci_resource_start
c_func
(paren
id|pdev
comma
l_int|2
)paren
suffix:semicolon
id|probe_ent-&gt;port
(braket
l_int|1
)braket
dot
id|altstatus_addr
op_assign
id|probe_ent-&gt;port
(braket
l_int|1
)braket
dot
id|ctl_addr
op_assign
id|pci_resource_start
c_func
(paren
id|pdev
comma
l_int|3
)paren
op_or
id|ATA_PCI_CTL_OFS
suffix:semicolon
id|probe_ent-&gt;port
(braket
l_int|1
)braket
dot
id|bmdma_addr
op_assign
id|pci_resource_start
c_func
(paren
id|pdev
comma
l_int|4
)paren
op_plus
l_int|8
suffix:semicolon
id|ata_std_ports
c_func
(paren
op_amp
id|probe_ent-&gt;port
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|ata_std_ports
c_func
(paren
op_amp
id|probe_ent-&gt;port
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
id|probe_ent
suffix:semicolon
)brace
r_struct
id|ata_probe_ent
op_star
DECL|function|ata_pci_init_legacy_mode
id|ata_pci_init_legacy_mode
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_struct
id|ata_port_info
op_star
op_star
id|port
)paren
(brace
r_struct
id|ata_probe_ent
op_star
id|probe_ent
op_assign
id|ata_probe_ent_alloc
c_func
(paren
l_int|2
comma
id|pci_dev_to_dev
c_func
(paren
id|pdev
)paren
comma
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|probe_ent
)paren
r_return
l_int|NULL
suffix:semicolon
id|probe_ent
(braket
l_int|0
)braket
dot
id|n_ports
op_assign
l_int|1
suffix:semicolon
id|probe_ent
(braket
l_int|0
)braket
dot
id|irq
op_assign
l_int|14
suffix:semicolon
id|probe_ent
(braket
l_int|0
)braket
dot
id|hard_port_no
op_assign
l_int|0
suffix:semicolon
id|probe_ent
(braket
l_int|0
)braket
dot
id|legacy_mode
op_assign
l_int|1
suffix:semicolon
id|probe_ent
(braket
l_int|1
)braket
dot
id|n_ports
op_assign
l_int|1
suffix:semicolon
id|probe_ent
(braket
l_int|1
)braket
dot
id|irq
op_assign
l_int|15
suffix:semicolon
id|probe_ent
(braket
l_int|1
)braket
dot
id|hard_port_no
op_assign
l_int|1
suffix:semicolon
id|probe_ent
(braket
l_int|1
)braket
dot
id|legacy_mode
op_assign
l_int|1
suffix:semicolon
id|probe_ent
(braket
l_int|0
)braket
dot
id|port
(braket
l_int|0
)braket
dot
id|cmd_addr
op_assign
l_int|0x1f0
suffix:semicolon
id|probe_ent
(braket
l_int|0
)braket
dot
id|port
(braket
l_int|0
)braket
dot
id|altstatus_addr
op_assign
id|probe_ent
(braket
l_int|0
)braket
dot
id|port
(braket
l_int|0
)braket
dot
id|ctl_addr
op_assign
l_int|0x3f6
suffix:semicolon
id|probe_ent
(braket
l_int|0
)braket
dot
id|port
(braket
l_int|0
)braket
dot
id|bmdma_addr
op_assign
id|pci_resource_start
c_func
(paren
id|pdev
comma
l_int|4
)paren
suffix:semicolon
id|probe_ent
(braket
l_int|1
)braket
dot
id|port
(braket
l_int|0
)braket
dot
id|cmd_addr
op_assign
l_int|0x170
suffix:semicolon
id|probe_ent
(braket
l_int|1
)braket
dot
id|port
(braket
l_int|0
)braket
dot
id|altstatus_addr
op_assign
id|probe_ent
(braket
l_int|1
)braket
dot
id|port
(braket
l_int|0
)braket
dot
id|ctl_addr
op_assign
l_int|0x376
suffix:semicolon
id|probe_ent
(braket
l_int|1
)braket
dot
id|port
(braket
l_int|0
)braket
dot
id|bmdma_addr
op_assign
id|pci_resource_start
c_func
(paren
id|pdev
comma
l_int|4
)paren
op_plus
l_int|8
suffix:semicolon
id|ata_std_ports
c_func
(paren
op_amp
id|probe_ent
(braket
l_int|0
)braket
dot
id|port
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|ata_std_ports
c_func
(paren
op_amp
id|probe_ent
(braket
l_int|1
)braket
dot
id|port
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
id|probe_ent
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_pci_init_one - Initialize/register PCI IDE host controller&n; *&t;@pdev: Controller to be initialized&n; *&t;@port_info: Information from low-level host driver&n; *&t;@n_ports: Number of ports attached to host controller&n; *&n; *&t;LOCKING:&n; *&t;Inherited from PCI layer (may sleep).&n; *&n; *&t;RETURNS:&n; *&n; */
DECL|function|ata_pci_init_one
r_int
id|ata_pci_init_one
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_struct
id|ata_port_info
op_star
op_star
id|port_info
comma
r_int
r_int
id|n_ports
)paren
(brace
r_struct
id|ata_probe_ent
op_star
id|probe_ent
comma
op_star
id|probe_ent2
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ata_port_info
op_star
id|port
(braket
l_int|2
)braket
suffix:semicolon
id|u8
id|tmp8
comma
id|mask
suffix:semicolon
r_int
r_int
id|legacy_mode
op_assign
l_int|0
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|DPRINTK
c_func
(paren
l_string|&quot;ENTER&bslash;n&quot;
)paren
suffix:semicolon
id|port
(braket
l_int|0
)braket
op_assign
id|port_info
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|n_ports
OG
l_int|1
)paren
id|port
(braket
l_int|1
)braket
op_assign
id|port_info
(braket
l_int|1
)braket
suffix:semicolon
r_else
id|port
(braket
l_int|1
)braket
op_assign
id|port
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|port
(braket
l_int|0
)braket
op_member_access_from_pointer
id|host_flags
op_amp
id|ATA_FLAG_NO_LEGACY
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* TODO: support transitioning to native mode? */
id|pci_read_config_byte
c_func
(paren
id|pdev
comma
id|PCI_CLASS_PROG
comma
op_amp
id|tmp8
)paren
suffix:semicolon
id|mask
op_assign
(paren
l_int|1
op_lshift
l_int|2
)paren
op_or
(paren
l_int|1
op_lshift
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp8
op_amp
id|mask
)paren
op_ne
id|mask
)paren
id|legacy_mode
op_assign
(paren
l_int|1
op_lshift
l_int|3
)paren
suffix:semicolon
)brace
multiline_comment|/* FIXME... */
r_if
c_cond
(paren
(paren
op_logical_neg
id|legacy_mode
)paren
op_logical_and
(paren
id|n_ports
OG
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ata: BUG: native mode, n_ports &gt; 1&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|rc
op_assign
id|pci_enable_device
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|rc
op_assign
id|pci_request_regions
c_func
(paren
id|pdev
comma
id|DRV_NAME
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|err_out
suffix:semicolon
r_if
c_cond
(paren
id|legacy_mode
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|request_region
c_func
(paren
l_int|0x1f0
comma
l_int|8
comma
l_string|&quot;libata&quot;
)paren
)paren
(brace
r_struct
id|resource
op_star
id|conflict
comma
id|res
suffix:semicolon
id|res.start
op_assign
l_int|0x1f0
suffix:semicolon
id|res.end
op_assign
l_int|0x1f0
op_plus
l_int|8
op_minus
l_int|1
suffix:semicolon
id|conflict
op_assign
id|____request_resource
c_func
(paren
op_amp
id|ioport_resource
comma
op_amp
id|res
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|conflict-&gt;name
comma
l_string|&quot;libata&quot;
)paren
)paren
id|legacy_mode
op_or_assign
(paren
l_int|1
op_lshift
l_int|0
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ata: 0x1f0 IDE port busy&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
id|legacy_mode
op_or_assign
(paren
l_int|1
op_lshift
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|request_region
c_func
(paren
l_int|0x170
comma
l_int|8
comma
l_string|&quot;libata&quot;
)paren
)paren
(brace
r_struct
id|resource
op_star
id|conflict
comma
id|res
suffix:semicolon
id|res.start
op_assign
l_int|0x170
suffix:semicolon
id|res.end
op_assign
l_int|0x170
op_plus
l_int|8
op_minus
l_int|1
suffix:semicolon
id|conflict
op_assign
id|____request_resource
c_func
(paren
op_amp
id|ioport_resource
comma
op_amp
id|res
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|conflict-&gt;name
comma
l_string|&quot;libata&quot;
)paren
)paren
id|legacy_mode
op_or_assign
(paren
l_int|1
op_lshift
l_int|1
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ata: 0x170 IDE port busy&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
id|legacy_mode
op_or_assign
(paren
l_int|1
op_lshift
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* we have legacy mode, but all ports are unavailable */
r_if
c_cond
(paren
id|legacy_mode
op_eq
(paren
l_int|1
op_lshift
l_int|3
)paren
)paren
(brace
id|rc
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|err_out_regions
suffix:semicolon
)brace
id|rc
op_assign
id|pci_set_dma_mask
c_func
(paren
id|pdev
comma
id|ATA_DMA_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|err_out_regions
suffix:semicolon
id|rc
op_assign
id|pci_set_consistent_dma_mask
c_func
(paren
id|pdev
comma
id|ATA_DMA_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|err_out_regions
suffix:semicolon
r_if
c_cond
(paren
id|legacy_mode
)paren
(brace
id|probe_ent
op_assign
id|ata_pci_init_legacy_mode
c_func
(paren
id|pdev
comma
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|probe_ent
)paren
id|probe_ent2
op_assign
op_amp
id|probe_ent
(braket
l_int|1
)braket
suffix:semicolon
)brace
r_else
id|probe_ent
op_assign
id|ata_pci_init_native_mode
c_func
(paren
id|pdev
comma
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|probe_ent
)paren
(brace
id|rc
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err_out_regions
suffix:semicolon
)brace
id|pci_set_master
c_func
(paren
id|pdev
)paren
suffix:semicolon
multiline_comment|/* FIXME: check ata_device_add return */
r_if
c_cond
(paren
id|legacy_mode
)paren
(brace
r_if
c_cond
(paren
id|legacy_mode
op_amp
(paren
l_int|1
op_lshift
l_int|0
)paren
)paren
id|ata_device_add
c_func
(paren
id|probe_ent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|legacy_mode
op_amp
(paren
l_int|1
op_lshift
l_int|1
)paren
)paren
id|ata_device_add
c_func
(paren
id|probe_ent2
)paren
suffix:semicolon
)brace
r_else
(brace
id|ata_device_add
c_func
(paren
id|probe_ent
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|probe_ent
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err_out_regions
suffix:colon
r_if
c_cond
(paren
id|legacy_mode
op_amp
(paren
l_int|1
op_lshift
l_int|0
)paren
)paren
id|release_region
c_func
(paren
l_int|0x1f0
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|legacy_mode
op_amp
(paren
l_int|1
op_lshift
l_int|1
)paren
)paren
id|release_region
c_func
(paren
l_int|0x170
comma
l_int|8
)paren
suffix:semicolon
id|pci_release_regions
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|err_out
suffix:colon
id|pci_disable_device
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;ata_pci_remove_one - PCI layer callback for device removal&n; *&t;@pdev: PCI device that was removed&n; *&n; *&t;PCI layer indicates to libata via this hook that&n; *&t;hot-unplug or module unload event has occured.&n; *&t;Handle this by unregistering all objects associated&n; *&t;with this PCI device.  Free those objects.  Then finally&n; *&t;release PCI resources and disable device.&n; *&n; *&t;LOCKING:&n; *&t;Inherited from PCI layer (may sleep).&n; */
DECL|function|ata_pci_remove_one
r_void
id|ata_pci_remove_one
(paren
r_struct
id|pci_dev
op_star
id|pdev
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
id|pci_dev_to_dev
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_struct
id|ata_host_set
op_star
id|host_set
op_assign
id|dev_get_drvdata
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|ata_port
op_star
id|ap
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|host_set-&gt;n_ports
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ap
op_assign
id|host_set-&gt;ports
(braket
id|i
)braket
suffix:semicolon
id|scsi_remove_host
c_func
(paren
id|ap-&gt;host
)paren
suffix:semicolon
)brace
id|free_irq
c_func
(paren
id|host_set-&gt;irq
comma
id|host_set
)paren
suffix:semicolon
r_if
c_cond
(paren
id|host_set-&gt;ops-&gt;host_stop
)paren
id|host_set-&gt;ops
op_member_access_from_pointer
id|host_stop
c_func
(paren
id|host_set
)paren
suffix:semicolon
r_if
c_cond
(paren
id|host_set-&gt;mmio_base
)paren
id|iounmap
c_func
(paren
id|host_set-&gt;mmio_base
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|host_set-&gt;n_ports
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ap
op_assign
id|host_set-&gt;ports
(braket
id|i
)braket
suffix:semicolon
id|ata_scsi_release
c_func
(paren
id|ap-&gt;host
)paren
suffix:semicolon
id|scsi_host_put
c_func
(paren
id|ap-&gt;host
)paren
suffix:semicolon
)brace
id|pci_release_regions
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|host_set-&gt;n_ports
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ata_ioports
op_star
id|ioaddr
suffix:semicolon
id|ap
op_assign
id|host_set-&gt;ports
(braket
id|i
)braket
suffix:semicolon
id|ioaddr
op_assign
op_amp
id|ap-&gt;ioaddr
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ap-&gt;flags
op_amp
id|ATA_FLAG_NO_LEGACY
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ioaddr-&gt;cmd_addr
op_eq
l_int|0x1f0
)paren
id|release_region
c_func
(paren
l_int|0x1f0
comma
l_int|8
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ioaddr-&gt;cmd_addr
op_eq
l_int|0x170
)paren
id|release_region
c_func
(paren
l_int|0x170
comma
l_int|8
)paren
suffix:semicolon
)brace
)brace
id|kfree
c_func
(paren
id|host_set
)paren
suffix:semicolon
id|pci_disable_device
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|dev_set_drvdata
c_func
(paren
id|dev
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* move to PCI subsystem */
DECL|function|pci_test_config_bits
r_int
id|pci_test_config_bits
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_struct
id|pci_bits
op_star
id|bits
)paren
(brace
r_int
r_int
id|tmp
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|bits-&gt;width
)paren
(brace
r_case
l_int|1
suffix:colon
(brace
id|u8
id|tmp8
op_assign
l_int|0
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|pdev
comma
id|bits-&gt;reg
comma
op_amp
id|tmp8
)paren
suffix:semicolon
id|tmp
op_assign
id|tmp8
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
l_int|2
suffix:colon
(brace
id|u16
id|tmp16
op_assign
l_int|0
suffix:semicolon
id|pci_read_config_word
c_func
(paren
id|pdev
comma
id|bits-&gt;reg
comma
op_amp
id|tmp16
)paren
suffix:semicolon
id|tmp
op_assign
id|tmp16
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
l_int|4
suffix:colon
(brace
id|u32
id|tmp32
op_assign
l_int|0
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|pdev
comma
id|bits-&gt;reg
comma
op_amp
id|tmp32
)paren
suffix:semicolon
id|tmp
op_assign
id|tmp32
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|tmp
op_and_assign
id|bits-&gt;mask
suffix:semicolon
r_return
(paren
id|tmp
op_eq
id|bits-&gt;val
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PCI */
multiline_comment|/**&n; *&t;ata_init -&n; *&n; *&t;LOCKING:&n; *&n; *&t;RETURNS:&n; *&n; */
DECL|function|ata_init
r_static
r_int
id|__init
id|ata_init
c_func
(paren
r_void
)paren
(brace
id|ata_wq
op_assign
id|create_workqueue
c_func
(paren
l_string|&quot;ata&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ata_wq
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;libata version &quot;
id|DRV_VERSION
l_string|&quot; loaded.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ata_exit
r_static
r_void
id|__exit
id|ata_exit
c_func
(paren
r_void
)paren
(brace
id|destroy_workqueue
c_func
(paren
id|ata_wq
)paren
suffix:semicolon
)brace
DECL|variable|ata_init
id|module_init
c_func
(paren
id|ata_init
)paren
suffix:semicolon
DECL|variable|ata_exit
id|module_exit
c_func
(paren
id|ata_exit
)paren
suffix:semicolon
multiline_comment|/*&n; * libata is essentially a library of internal helper functions for&n; * low-level ATA host controller drivers.  As such, the API/ABI is&n; * likely to change as new drivers are added and updated.&n; * Do not depend on ABI/API stability.&n; */
DECL|variable|ata_std_bios_param
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_std_bios_param
)paren
suffix:semicolon
DECL|variable|ata_std_ports
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_std_ports
)paren
suffix:semicolon
DECL|variable|ata_device_add
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_device_add
)paren
suffix:semicolon
DECL|variable|ata_sg_init
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_sg_init
)paren
suffix:semicolon
DECL|variable|ata_sg_init_one
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_sg_init_one
)paren
suffix:semicolon
DECL|variable|ata_qc_complete
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_qc_complete
)paren
suffix:semicolon
DECL|variable|ata_qc_issue_prot
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_qc_issue_prot
)paren
suffix:semicolon
DECL|variable|ata_eng_timeout
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_eng_timeout
)paren
suffix:semicolon
DECL|variable|ata_tf_load
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_tf_load
)paren
suffix:semicolon
DECL|variable|ata_tf_read
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_tf_read
)paren
suffix:semicolon
DECL|variable|ata_noop_dev_select
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_noop_dev_select
)paren
suffix:semicolon
DECL|variable|ata_std_dev_select
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_std_dev_select
)paren
suffix:semicolon
DECL|variable|ata_tf_to_fis
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_tf_to_fis
)paren
suffix:semicolon
DECL|variable|ata_tf_from_fis
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_tf_from_fis
)paren
suffix:semicolon
DECL|variable|ata_check_status
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_check_status
)paren
suffix:semicolon
DECL|variable|ata_exec_command
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_exec_command
)paren
suffix:semicolon
DECL|variable|ata_port_start
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_port_start
)paren
suffix:semicolon
DECL|variable|ata_port_stop
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_port_stop
)paren
suffix:semicolon
DECL|variable|ata_interrupt
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_interrupt
)paren
suffix:semicolon
DECL|variable|ata_qc_prep
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_qc_prep
)paren
suffix:semicolon
DECL|variable|ata_bmdma_setup
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_bmdma_setup
)paren
suffix:semicolon
DECL|variable|ata_bmdma_start
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_bmdma_start
)paren
suffix:semicolon
DECL|variable|ata_bmdma_irq_clear
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_bmdma_irq_clear
)paren
suffix:semicolon
DECL|variable|ata_port_probe
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_port_probe
)paren
suffix:semicolon
DECL|variable|sata_phy_reset
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|sata_phy_reset
)paren
suffix:semicolon
DECL|variable|__sata_phy_reset
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|__sata_phy_reset
)paren
suffix:semicolon
DECL|variable|ata_bus_reset
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_bus_reset
)paren
suffix:semicolon
DECL|variable|ata_port_disable
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_port_disable
)paren
suffix:semicolon
DECL|variable|ata_scsi_ioctl
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_scsi_ioctl
)paren
suffix:semicolon
DECL|variable|ata_scsi_queuecmd
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_scsi_queuecmd
)paren
suffix:semicolon
DECL|variable|ata_scsi_error
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_scsi_error
)paren
suffix:semicolon
DECL|variable|ata_scsi_slave_config
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_scsi_slave_config
)paren
suffix:semicolon
DECL|variable|ata_scsi_release
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_scsi_release
)paren
suffix:semicolon
DECL|variable|ata_host_intr
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_host_intr
)paren
suffix:semicolon
DECL|variable|ata_dev_classify
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_dev_classify
)paren
suffix:semicolon
DECL|variable|ata_dev_id_string
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_dev_id_string
)paren
suffix:semicolon
DECL|variable|ata_scsi_simulate
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_scsi_simulate
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PCI
DECL|variable|pci_test_config_bits
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|pci_test_config_bits
)paren
suffix:semicolon
DECL|variable|ata_pci_init_legacy_mode
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_pci_init_legacy_mode
)paren
suffix:semicolon
DECL|variable|ata_pci_init_native_mode
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_pci_init_native_mode
)paren
suffix:semicolon
DECL|variable|ata_pci_init_one
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_pci_init_one
)paren
suffix:semicolon
DECL|variable|ata_pci_remove_one
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|ata_pci_remove_one
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_PCI */
eof
