multiline_comment|/*&n; *  scsi.c Copyright (C) 1992 Drew Eckhardt&n; *         Copyright (C) 1993, 1994, 1995, 1999 Eric Youngdale&n; *&n; *  generic mid-level SCSI driver&n; *      Initial versions: Drew Eckhardt&n; *      Subsequent revisions: Eric Youngdale&n; *&n; *  &lt;drew@colorado.edu&gt;&n; *&n; *  Bug correction thanks go to :&n; *      Rik Faith &lt;faith@cs.unc.edu&gt;&n; *      Tommy Thorn &lt;tthorn&gt;&n; *      Thomas Wuensche &lt;tw@fgb1.fgb.mw.tu-muenchen.de&gt;&n; *&n; *  Modified by Eric Youngdale eric@andante.org or ericy@gnu.ai.mit.edu to&n; *  add scatter-gather, multiple outstanding request, and other&n; *  enhancements.&n; *&n; *  Native multichannel, wide scsi, /proc/scsi and hot plugging&n; *  support added by Michael Neuffer &lt;mike@i-connect.net&gt;&n; *&n; *  Added request_module(&quot;scsi_hostadapter&quot;) for kerneld:&n; *  (Put an &quot;alias scsi_hostadapter your_hostadapter&quot; in /etc/modules.conf)&n; *  Bjorn Ekwall  &lt;bj0rn@blox.se&gt;&n; *  (changed to kmod)&n; *&n; *  Major improvements to the timeout, abort, and reset processing,&n; *  as well as performance modifications for large queue depths by&n; *  Leonard N. Zubkoff &lt;lnz@dandelion.com&gt;&n; *&n; *  Converted cli() code to spinlocks, Ingo Molnar&n; *&n; *  Jiffies wrap fixes (host-&gt;resetting), 3 Dec 1998 Andrea Arcangeli&n; *&n; *  out_of_space hacks, D. Gilbert (dpg) 990608&n; */
DECL|macro|REVISION
mdefine_line|#define REVISION&t;&quot;Revision: 1.00&quot;
DECL|macro|VERSION
mdefine_line|#define VERSION&t;&t;&quot;Id: scsi.c 1.00 2000/09/26&quot;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/completion.h&gt;
macro_line|#include &lt;linux/mempool.h&gt;
DECL|macro|__KERNEL_SYSCALLS__
mdefine_line|#define __KERNEL_SYSCALLS__
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#ifdef CONFIG_KMOD
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#endif
DECL|macro|SG_MEMPOOL_NR
mdefine_line|#define SG_MEMPOOL_NR&t;&t;5
DECL|macro|SG_MEMPOOL_SIZE
mdefine_line|#define SG_MEMPOOL_SIZE&t;&t;32
DECL|struct|scsi_host_sg_pool
r_struct
id|scsi_host_sg_pool
(brace
DECL|member|size
r_int
id|size
suffix:semicolon
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|slab
id|kmem_cache_t
op_star
id|slab
suffix:semicolon
DECL|member|pool
id|mempool_t
op_star
id|pool
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|SP
mdefine_line|#define SP(x) { x, &quot;sgpool-&quot; #x } 
DECL|variable|scsi_sg_pools
r_struct
id|scsi_host_sg_pool
id|scsi_sg_pools
(braket
id|SG_MEMPOOL_NR
)braket
op_assign
(brace
id|SP
c_func
(paren
l_int|8
)paren
comma
id|SP
c_func
(paren
l_int|16
)paren
comma
id|SP
c_func
(paren
l_int|32
)paren
comma
id|SP
c_func
(paren
l_int|64
)paren
comma
id|SP
c_func
(paren
id|MAX_PHYS_SEGMENTS
)paren
)brace
suffix:semicolon
DECL|macro|SP
macro_line|#undef SP &t;
multiline_comment|/*&n;   static const char RCSid[] = &quot;$Header: /vger/u4/cvs/linux/drivers/scsi/scsi.c,v 1.38 1997/01/19 23:07:18 davem Exp $&quot;;&n; */
multiline_comment|/*&n; * Definitions and constants.&n; */
DECL|macro|MIN_RESET_DELAY
mdefine_line|#define MIN_RESET_DELAY (2*HZ)
multiline_comment|/* Do not call reset on error if we just did a reset within 15 sec. */
DECL|macro|MIN_RESET_PERIOD
mdefine_line|#define MIN_RESET_PERIOD (15*HZ)
multiline_comment|/*&n; * Macro to determine the size of SCSI command. This macro takes vendor&n; * unique commands into account. SCSI commands in groups 6 and 7 are&n; * vendor unique and we will depend upon the command length being&n; * supplied correctly in cmd_len.&n; */
DECL|macro|CDB_SIZE
mdefine_line|#define CDB_SIZE(SCpnt)&t;((((SCpnt-&gt;cmnd[0] &gt;&gt; 5) &amp; 7) &lt; 6) ? &bslash;&n;&t;&t;&t;&t;COMMAND_SIZE(SCpnt-&gt;cmnd[0]) : SCpnt-&gt;cmd_len)
multiline_comment|/*&n; * Data declarations.&n; */
DECL|variable|scsi_pid
r_int
r_int
id|scsi_pid
suffix:semicolon
DECL|variable|last_cmnd
id|Scsi_Cmnd
op_star
id|last_cmnd
suffix:semicolon
DECL|variable|serial_number
r_static
r_int
r_int
id|serial_number
suffix:semicolon
DECL|struct|softscsi_data
r_struct
id|softscsi_data
(brace
DECL|member|head
id|Scsi_Cmnd
op_star
id|head
suffix:semicolon
DECL|member|tail
id|Scsi_Cmnd
op_star
id|tail
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|__cacheline_aligned
r_static
r_struct
id|softscsi_data
id|softscsi_data
(braket
id|NR_CPUS
)braket
id|__cacheline_aligned
suffix:semicolon
multiline_comment|/*&n; * List of all highlevel drivers.&n; */
DECL|variable|scsi_devicelist
id|LIST_HEAD
c_func
(paren
id|scsi_devicelist
)paren
suffix:semicolon
r_static
id|DECLARE_RWSEM
c_func
(paren
id|scsi_devicelist_mutex
)paren
suffix:semicolon
multiline_comment|/*&n; * Note - the initial logging level can be set here to log events at boot time.&n; * After the system is up, you may enable logging via the /proc interface.&n; */
DECL|variable|scsi_logging_level
r_int
r_int
id|scsi_logging_level
suffix:semicolon
DECL|variable|scsi_device_types
r_const
r_char
op_star
r_const
id|scsi_device_types
(braket
id|MAX_SCSI_DEVICE_CODE
)braket
op_assign
(brace
l_string|&quot;Direct-Access    &quot;
comma
l_string|&quot;Sequential-Access&quot;
comma
l_string|&quot;Printer          &quot;
comma
l_string|&quot;Processor        &quot;
comma
l_string|&quot;WORM             &quot;
comma
l_string|&quot;CD-ROM           &quot;
comma
l_string|&quot;Scanner          &quot;
comma
l_string|&quot;Optical Device   &quot;
comma
l_string|&quot;Medium Changer   &quot;
comma
l_string|&quot;Communications   &quot;
comma
l_string|&quot;Unknown          &quot;
comma
l_string|&quot;Unknown          &quot;
comma
l_string|&quot;Unknown          &quot;
comma
l_string|&quot;Enclosure        &quot;
comma
)brace
suffix:semicolon
DECL|variable|spaces
r_static
r_const
r_char
op_star
r_const
id|spaces
op_assign
l_string|&quot;                &quot;
suffix:semicolon
multiline_comment|/* 16 of them */
DECL|variable|scsi_default_dev_flags
r_static
r_int
id|scsi_default_dev_flags
suffix:semicolon
DECL|variable|scsi_dev_info_list
id|LIST_HEAD
c_func
(paren
id|scsi_dev_info_list
)paren
suffix:semicolon
multiline_comment|/* &n; * Function prototypes.&n; */
r_extern
r_void
id|scsi_times_out
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
suffix:semicolon
r_void
id|scsi_build_commandblocks
c_func
(paren
id|Scsi_Device
op_star
id|SDpnt
)paren
suffix:semicolon
multiline_comment|/*&n; * Function:    scsi_initialize_queue()&n; *&n; * Purpose:     Selects queue handler function for a device.&n; *&n; * Arguments:   SDpnt   - device for which we need a handler function.&n; *&n; * Returns:     Nothing&n; *&n; * Lock status: No locking assumed or required.&n; *&n; * Notes:       Most devices will end up using scsi_request_fn for the&n; *              handler function (at least as things are done now).&n; *              The &quot;block&quot; feature basically ensures that only one of&n; *              the blocked hosts is active at one time, mainly to work around&n; *              buggy DMA chipsets where the memory gets starved.&n; *              For this case, we have a special handler function, which&n; *              does some checks and ultimately calls scsi_request_fn.&n; *&n; *              The single_lun feature is a similar special case.&n; *&n; *              We handle these things by stacking the handlers.  The&n; *              special case handlers simply check a few conditions,&n; *              and return if they are not supposed to do anything.&n; *              In the event that things are OK, then they call the next&n; *              handler in the list - ultimately they call scsi_request_fn&n; *              to do the dirty deed.&n; */
DECL|function|scsi_initialize_queue
r_void
id|scsi_initialize_queue
c_func
(paren
id|Scsi_Device
op_star
id|SDpnt
comma
r_struct
id|Scsi_Host
op_star
id|SHpnt
)paren
(brace
id|request_queue_t
op_star
id|q
op_assign
op_amp
id|SDpnt-&gt;request_queue
suffix:semicolon
multiline_comment|/*&n;&t; * tell block layer about assigned host_lock for this host&n;&t; */
id|blk_init_queue
c_func
(paren
id|q
comma
id|scsi_request_fn
comma
id|SHpnt-&gt;host_lock
)paren
suffix:semicolon
id|q-&gt;queuedata
op_assign
(paren
r_void
op_star
)paren
id|SDpnt
suffix:semicolon
multiline_comment|/* Hardware imposed limit. */
id|blk_queue_max_hw_segments
c_func
(paren
id|q
comma
id|SHpnt-&gt;sg_tablesize
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * scsi_alloc_sgtable max&n;&t; */
id|blk_queue_max_phys_segments
c_func
(paren
id|q
comma
id|MAX_PHYS_SEGMENTS
)paren
suffix:semicolon
id|blk_queue_max_sectors
c_func
(paren
id|q
comma
id|SHpnt-&gt;max_sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SHpnt-&gt;use_clustering
)paren
id|clear_bit
c_func
(paren
id|QUEUE_FLAG_CLUSTER
comma
op_amp
id|q-&gt;queue_flags
)paren
suffix:semicolon
id|blk_queue_prep_rq
c_func
(paren
id|q
comma
id|scsi_prep_fn
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
id|MODULE_PARM
c_func
(paren
id|scsi_logging_level
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|scsi_logging_level
comma
l_string|&quot;SCSI logging level; should be zero or nonzero&quot;
)paren
suffix:semicolon
macro_line|#else
DECL|function|scsi_logging_setup
r_static
r_int
id|__init
id|scsi_logging_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|get_option
c_func
(paren
op_amp
id|str
comma
op_amp
id|tmp
)paren
op_eq
l_int|1
)paren
(brace
id|scsi_logging_level
op_assign
(paren
id|tmp
ques
c_cond
op_complement
l_int|0
suffix:colon
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi_logging_setup : usage scsi_logging_level=n &quot;
l_string|&quot;(n should be 0 or non-zero)&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|__setup
c_func
(paren
l_string|&quot;scsi_logging=&quot;
comma
id|scsi_logging_setup
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; *&t;Issue a command and wait for it to complete&n; */
DECL|function|scsi_wait_done
r_static
r_void
id|scsi_wait_done
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_struct
id|request
op_star
id|req
op_assign
id|SCpnt-&gt;request
suffix:semicolon
r_struct
id|request_queue
op_star
id|q
op_assign
op_amp
id|SCpnt-&gt;device-&gt;request_queue
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|ASSERT_LOCK
c_func
(paren
id|q-&gt;queue_lock
comma
l_int|0
)paren
suffix:semicolon
id|req-&gt;rq_status
op_assign
id|RQ_SCSI_DONE
suffix:semicolon
multiline_comment|/* Busy, but indicate request done */
id|spin_lock_irqsave
c_func
(paren
id|q-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blk_rq_tagged
c_func
(paren
id|req
)paren
)paren
(brace
id|blk_queue_end_tag
c_func
(paren
id|q
comma
id|req
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
id|q-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;waiting
)paren
id|complete
c_func
(paren
id|req-&gt;waiting
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This lock protects the freelist for all devices on the system.&n; * We could make this finer grained by having a single lock per&n; * device if it is ever found that there is excessive contention&n; * on this lock.&n; */
DECL|variable|device_request_lock
r_static
id|spinlock_t
id|device_request_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n; * Function:    scsi_allocate_request&n; *&n; * Purpose:     Allocate a request descriptor.&n; *&n; * Arguments:   device    - device for which we want a request&n; *&n; * Lock status: No locks assumed to be held.  This function is SMP-safe.&n; *&n; * Returns:     Pointer to request block.&n; *&n; * Notes:       With the new queueing code, it becomes important&n; *              to track the difference between a command and a&n; *              request.  A request is a pending item in the queue that&n; *              has not yet reached the top of the queue.&n; */
DECL|function|scsi_allocate_request
id|Scsi_Request
op_star
id|scsi_allocate_request
c_func
(paren
id|Scsi_Device
op_star
id|device
)paren
(brace
id|Scsi_Request
op_star
id|SRpnt
op_assign
l_int|NULL
suffix:semicolon
r_const
r_int
id|offset
op_assign
id|ALIGN
c_func
(paren
r_sizeof
(paren
id|Scsi_Request
)paren
comma
l_int|4
)paren
suffix:semicolon
r_const
r_int
id|size
op_assign
id|offset
op_plus
r_sizeof
(paren
r_struct
id|request
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|device
)paren
id|panic
c_func
(paren
l_string|&quot;No device passed to scsi_allocate_request().&bslash;n&quot;
)paren
suffix:semicolon
id|SRpnt
op_assign
(paren
id|Scsi_Request
op_star
)paren
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SRpnt
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|SRpnt
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
id|SRpnt-&gt;sr_request
op_assign
(paren
r_struct
id|request
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|SRpnt
)paren
op_plus
id|offset
)paren
suffix:semicolon
id|SRpnt-&gt;sr_device
op_assign
id|device
suffix:semicolon
id|SRpnt-&gt;sr_host
op_assign
id|device-&gt;host
suffix:semicolon
id|SRpnt-&gt;sr_magic
op_assign
id|SCSI_REQ_MAGIC
suffix:semicolon
id|SRpnt-&gt;sr_data_direction
op_assign
id|SCSI_DATA_UNKNOWN
suffix:semicolon
r_return
id|SRpnt
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_release_request&n; *&n; * Purpose:     Release a request descriptor.&n; *&n; * Arguments:   device    - device for which we want a request&n; *&n; * Lock status: No locks assumed to be held.  This function is SMP-safe.&n; *&n; * Returns:     Pointer to request block.&n; *&n; * Notes:       With the new queueing code, it becomes important&n; *              to track the difference between a command and a&n; *              request.  A request is a pending item in the queue that&n; *              has not yet reached the top of the queue.  We still need&n; *              to free a request when we are done with it, of course.&n; */
DECL|function|scsi_release_request
r_void
id|scsi_release_request
c_func
(paren
id|Scsi_Request
op_star
id|req
)paren
(brace
r_if
c_cond
(paren
id|req-&gt;sr_command
op_ne
l_int|NULL
)paren
(brace
id|scsi_release_command
c_func
(paren
id|req-&gt;sr_command
)paren
suffix:semicolon
id|req-&gt;sr_command
op_assign
l_int|NULL
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * FIXME(eric) - this is not at all optimal.  Given that&n; * single lun devices are rare and usually slow&n; * (i.e. CD changers), this is good enough for now, but&n; * we may want to come back and optimize this later.&n; *&n; * Scan through all of the devices attached to this&n; * host, and see if any are active or not.  If so,&n; * we need to defer this command.&n; *&n; * We really need a busy counter per device.  This would&n; * allow us to more easily figure out whether we should&n; * do anything here or not.&n; */
DECL|function|check_all_luns
r_static
r_int
id|check_all_luns
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
comma
r_struct
id|scsi_device
op_star
id|myself
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|sdev
comma
op_amp
id|myself-&gt;same_target_siblings
comma
id|same_target_siblings
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sdev-&gt;device_active
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_allocate_device&n; *&n; * Purpose:     Allocate a command descriptor.&n; *&n; * Arguments:   device    - device for which we want a command descriptor&n; *              wait      - 1 if we should wait in the event that none&n; *                          are available.&n; *              interruptible - 1 if we should unblock and return NULL&n; *                          in the event that we must wait, and a signal&n; *                          arrives.&n; *&n; * Lock status: No locks assumed to be held.  This function is SMP-safe.&n; *&n; * Returns:     Pointer to command descriptor.&n; *&n; * Notes:       Prior to the new queue code, this function was not SMP-safe.&n; *&n; *              If the wait flag is true, and we are waiting for a free&n; *              command block, this function will interrupt and return&n; *              NULL in the event that a signal arrives that needs to&n; *              be handled.&n; *&n; *              This function is deprecated, and drivers should be&n; *              rewritten to use Scsi_Request instead of Scsi_Cmnd.&n; */
DECL|function|scsi_allocate_device
r_struct
id|scsi_cmnd
op_star
id|scsi_allocate_device
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
comma
r_int
id|wait
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wq
comma
id|current
)paren
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shost
op_assign
id|sdev-&gt;host
suffix:semicolon
r_struct
id|scsi_cmnd
op_star
id|scmnd
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|sdev-&gt;device_blocked
)paren
r_goto
id|busy
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;single_lun
op_logical_and
id|check_all_luns
c_func
(paren
id|shost
comma
id|sdev
)paren
)paren
r_goto
id|busy
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Now we can check for a free command block for this device.&n;&t;&t; */
r_for
c_loop
(paren
id|scmnd
op_assign
id|sdev-&gt;device_queue
suffix:semicolon
id|scmnd
suffix:semicolon
id|scmnd
op_assign
id|scmnd-&gt;next
)paren
r_if
c_cond
(paren
op_logical_neg
id|scmnd-&gt;request
)paren
r_goto
id|found
suffix:semicolon
id|busy
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|wait
)paren
r_goto
id|fail
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We need to wait for a free commandblock.  We need to&n;&t;&t; * insert ourselves into the list before we release the&n;&t;&t; * lock.  This way if a block were released the same&n;&t;&t; * microsecond that we released the lock, the call&n;&t;&t; * to schedule() wouldn&squot;t block (well, it might switch,&n;&t;&t; * but the current task will still be schedulable.&n;&t;&t; */
id|add_wait_queue
c_func
(paren
op_amp
id|sdev-&gt;scpnt_wait
comma
op_amp
id|wq
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|sdev-&gt;scpnt_wait
comma
op_amp
id|wq
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
)brace
id|found
suffix:colon
id|scmnd-&gt;request
op_assign
l_int|NULL
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|scmnd-&gt;host-&gt;host_active
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|scmnd-&gt;device-&gt;device_active
)paren
suffix:semicolon
id|scmnd-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|scmnd-&gt;bufflen
op_assign
l_int|0
suffix:semicolon
id|scmnd-&gt;request_buffer
op_assign
l_int|NULL
suffix:semicolon
id|scmnd-&gt;request_bufflen
op_assign
l_int|0
suffix:semicolon
id|scmnd-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Reset the scatter-gather flag */
id|scmnd-&gt;old_use_sg
op_assign
l_int|0
suffix:semicolon
id|scmnd-&gt;transfersize
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* No default transfer size */
id|scmnd-&gt;cmd_len
op_assign
l_int|0
suffix:semicolon
id|scmnd-&gt;sc_data_direction
op_assign
id|SCSI_DATA_UNKNOWN
suffix:semicolon
id|scmnd-&gt;sc_request
op_assign
l_int|NULL
suffix:semicolon
id|scmnd-&gt;sc_magic
op_assign
id|SCSI_CMND_MAGIC
suffix:semicolon
id|scmnd-&gt;result
op_assign
l_int|0
suffix:semicolon
id|scmnd-&gt;underflow
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Do not flag underflow conditions */
id|scmnd-&gt;old_underflow
op_assign
l_int|0
suffix:semicolon
id|scmnd-&gt;resid
op_assign
l_int|0
suffix:semicolon
id|scmnd-&gt;state
op_assign
id|SCSI_STATE_INITIALIZING
suffix:semicolon
id|scmnd-&gt;owner
op_assign
id|SCSI_OWNER_HIGHLEVEL
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;Activating command for device %d (%d)&bslash;n&quot;
comma
id|scmnd-&gt;target
comma
id|atomic_read
c_func
(paren
op_amp
id|scmnd-&gt;host-&gt;host_active
)paren
)paren
)paren
suffix:semicolon
r_return
id|scmnd
suffix:semicolon
id|fail
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|__scsi_release_command
r_inline
r_void
id|__scsi_release_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
r_int
id|alloc_cmd
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
id|SDpnt
op_assign
id|SCpnt-&gt;device
suffix:semicolon
id|SCpnt-&gt;request
op_assign
l_int|NULL
suffix:semicolon
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_UNUSED
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_NOBODY
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|SCpnt-&gt;host-&gt;host_active
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|SDpnt-&gt;device_active
)paren
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;Deactivating command for device %d (active=%d, failed=%d)&bslash;n&quot;
comma
id|SCpnt-&gt;target
comma
id|atomic_read
c_func
(paren
op_amp
id|SCpnt-&gt;host-&gt;host_active
)paren
comma
id|SCpnt-&gt;host-&gt;host_failed
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt-&gt;current_queue_depth
OG
id|SDpnt-&gt;new_queue_depth
)paren
(brace
id|Scsi_Cmnd
op_star
id|prev
comma
op_star
id|next
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Release the command block and decrement the queue&n;&t;&t; * depth.&n;&t;&t; */
r_for
c_loop
(paren
id|prev
op_assign
l_int|NULL
comma
id|next
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|next
op_ne
id|SCpnt
suffix:semicolon
id|prev
op_assign
id|next
comma
id|next
op_assign
id|next-&gt;next
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prev
op_eq
l_int|NULL
)paren
(brace
id|SDpnt-&gt;device_queue
op_assign
id|next-&gt;next
suffix:semicolon
)brace
r_else
id|prev-&gt;next
op_assign
id|next-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
(paren
r_char
op_star
)paren
id|SCpnt
)paren
suffix:semicolon
id|SDpnt-&gt;current_queue_depth
op_decrement
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|SDpnt-&gt;current_queue_depth
OL
id|SDpnt-&gt;new_queue_depth
)paren
(brace
id|alloc_cmd
op_assign
l_int|1
suffix:semicolon
id|SDpnt-&gt;current_queue_depth
op_increment
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;         * Wake up anyone waiting for this device.  Do this after we&n;         * have released the lock, as they will need it as soon as&n;         * they wake up.  &n;         */
id|wake_up
c_func
(paren
op_amp
id|SDpnt-&gt;scpnt_wait
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We are happy to release command blocks in the scope of the&n;&t; * device_request_lock since that&squot;s nice and quick, but allocation&n;&t; * can take more time so do it outside that scope instead.&n;&t; */
r_if
c_cond
(paren
id|alloc_cmd
)paren
(brace
id|Scsi_Cmnd
op_star
id|newSCpnt
suffix:semicolon
id|newSCpnt
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|Scsi_Cmnd
)paren
comma
id|GFP_ATOMIC
op_or
(paren
id|SDpnt-&gt;host-&gt;unchecked_isa_dma
ques
c_cond
id|GFP_DMA
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newSCpnt
)paren
(brace
id|memset
c_func
(paren
id|newSCpnt
comma
l_int|0
comma
r_sizeof
(paren
id|Scsi_Cmnd
)paren
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|newSCpnt-&gt;eh_timeout
)paren
suffix:semicolon
id|newSCpnt-&gt;host
op_assign
id|SDpnt-&gt;host
suffix:semicolon
id|newSCpnt-&gt;device
op_assign
id|SDpnt
suffix:semicolon
id|newSCpnt-&gt;target
op_assign
id|SDpnt-&gt;id
suffix:semicolon
id|newSCpnt-&gt;lun
op_assign
id|SDpnt-&gt;lun
suffix:semicolon
id|newSCpnt-&gt;channel
op_assign
id|SDpnt-&gt;channel
suffix:semicolon
id|newSCpnt-&gt;request
op_assign
l_int|NULL
suffix:semicolon
id|newSCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
id|newSCpnt-&gt;old_use_sg
op_assign
l_int|0
suffix:semicolon
id|newSCpnt-&gt;old_cmd_len
op_assign
l_int|0
suffix:semicolon
id|newSCpnt-&gt;underflow
op_assign
l_int|0
suffix:semicolon
id|newSCpnt-&gt;old_underflow
op_assign
l_int|0
suffix:semicolon
id|newSCpnt-&gt;transfersize
op_assign
l_int|0
suffix:semicolon
id|newSCpnt-&gt;resid
op_assign
l_int|0
suffix:semicolon
id|newSCpnt-&gt;serial_number
op_assign
l_int|0
suffix:semicolon
id|newSCpnt-&gt;serial_number_at_timeout
op_assign
l_int|0
suffix:semicolon
id|newSCpnt-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|newSCpnt-&gt;state
op_assign
id|SCSI_STATE_UNUSED
suffix:semicolon
id|newSCpnt-&gt;owner
op_assign
id|SCSI_OWNER_NOBODY
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
id|newSCpnt-&gt;next
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SDpnt-&gt;device_queue
op_assign
id|newSCpnt
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
id|SDpnt-&gt;current_queue_depth
op_decrement
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Function:    scsi_mlqueue_insert()&n; *&n; * Purpose:     Insert a command in the midlevel queue.&n; *&n; * Arguments:   cmd    - command that we are adding to queue.&n; *              reason - why we are inserting command to queue.&n; *&n; * Lock status: Assumed that lock is not held upon entry.&n; *&n; * Returns:     Nothing.&n; *&n; * Notes:       We do this for one of two cases.  Either the host is busy&n; *              and it cannot accept any more commands for the time being,&n; *              or the device returned QUEUE_FULL and can accept no more&n; *              commands.&n; * Notes:       This could be called either from an interrupt context or a&n; *              normal process context.&n; */
DECL|function|scsi_mlqueue_insert
r_int
id|scsi_mlqueue_insert
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_int
id|reason
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|cmd-&gt;host
suffix:semicolon
r_struct
id|scsi_device
op_star
id|device
op_assign
id|cmd-&gt;device
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;Inserting command %p into mlqueue&bslash;n&quot;
comma
id|cmd
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We are inserting the command into the ml queue.  First, we&n;&t; * cancel the timer, so it doesn&squot;t time out.&n;&t; */
id|scsi_delete_timer
c_func
(paren
id|cmd
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Next, set the appropriate busy bit for the device/host.&n;&t; *&n;&t; * If the host/device isn&squot;t busy, assume that something actually&n;&t; * completed, and that we should be able to queue a command now.&n;&t; *&n;&t; * Note that the prior mid-layer assumption that any host could&n;&t; * always queue at least one command is now broken.  The mid-layer&n;&t; * will implement a user specifiable stall (see&n;&t; * scsi_host.max_host_blocked and scsi_device.max_device_blocked)&n;&t; * if a command is requeued with no other commands outstanding&n;&t; * either for the device or for the host.&n;&t; */
r_if
c_cond
(paren
id|reason
op_eq
id|SCSI_MLQUEUE_HOST_BUSY
)paren
(brace
id|host-&gt;host_blocked
op_assign
id|host-&gt;max_host_blocked
suffix:semicolon
)brace
r_else
(brace
id|device-&gt;device_blocked
op_assign
id|device-&gt;max_device_blocked
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Register the fact that we own the thing for now.&n;&t; */
id|cmd-&gt;state
op_assign
id|SCSI_STATE_MLQUEUE
suffix:semicolon
id|cmd-&gt;owner
op_assign
id|SCSI_OWNER_MIDLEVEL
suffix:semicolon
id|cmd-&gt;bh_next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Decrement the counters, since these commands are no longer&n;&t; * active on the host/device.&n;&t; */
id|scsi_host_busy_dec_and_test
c_func
(paren
id|host
comma
id|device
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Insert this command at the head of the queue for it&squot;s device.&n;&t; * It will go before all other commands that are already in the queue.&n;&t; *&n;&t; * NOTE: there is magic here about the way the queue is&n;&t; * plugged if we have no outstanding commands.&n;&t; * scsi_insert_special_cmd eventually calls&n;&t; * blk_queue_insert().  Although this *doesn&squot;t* plug the&n;&t; * queue, it does call the request function.  The SCSI request&n;&t; * function detects the blocked condition and plugs the queue&n;&t; * appropriately.&n;&t; */
id|scsi_insert_special_cmd
c_func
(paren
id|cmd
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_release_command&n; *&n; * Purpose:     Release a command block.&n; *&n; * Arguments:   SCpnt - command block we are releasing.&n; *&n; * Notes:       The command block can no longer be used by the caller once&n; *              this funciton is called.  This is in effect the inverse&n; *              of scsi_allocate_device.  Note that we also must perform&n; *              a couple of additional tasks.  We must first wake up any&n; *              processes that might have blocked waiting for a command&n; *              block, and secondly we must hit the queue handler function&n; *              to make sure that the device is busy.  Note - there is an&n; *              option to not do this - there were instances where we could&n; *              recurse too deeply and blow the stack if this happened&n; *              when we were indirectly called from the request function&n; *              itself.&n; *&n; *              The idea is that a lot of the mid-level internals gunk&n; *              gets hidden in this function.  Upper level drivers don&squot;t&n; *              have any chickens to wave in the air to get things to&n; *              work reliably.&n; *&n; *              This function is deprecated, and drivers should be&n; *              rewritten to use Scsi_Request instead of Scsi_Cmnd.&n; */
DECL|function|scsi_release_command
r_void
id|scsi_release_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|request_queue_t
op_star
id|q
suffix:semicolon
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
id|SDpnt
op_assign
id|SCpnt-&gt;device
suffix:semicolon
id|__scsi_release_command
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
multiline_comment|/*&n;         * Finally, hit the queue request function to make sure that&n;         * the device is actually busy if there are requests present.&n;         * This won&squot;t block - if the device cannot take any more, life&n;         * will go on.  &n;         */
id|q
op_assign
op_amp
id|SDpnt-&gt;request_queue
suffix:semicolon
id|scsi_queue_next_request
c_func
(paren
id|q
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_dispatch_command&n; *&n; * Purpose:     Dispatch a command to the low-level driver.&n; *&n; * Arguments:   SCpnt - command block we are dispatching.&n; *&n; * Notes:&n; */
DECL|function|scsi_dispatch_cmd
r_int
id|scsi_dispatch_cmd
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
macro_line|#ifdef DEBUG_DELAY
r_int
r_int
id|clock
suffix:semicolon
macro_line|#endif
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
r_int
id|rtn
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
macro_line|#if DEBUG
r_int
r_int
op_star
id|ret
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef __mips__
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;move&bslash;t%0,$31&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|ret
)paren
)paren
suffix:semicolon
macro_line|#else
id|ret
op_assign
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
id|host
op_assign
id|SCpnt-&gt;host
suffix:semicolon
id|ASSERT_LOCK
c_func
(paren
id|host-&gt;host_lock
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Assign a unique nonzero serial_number. */
r_if
c_cond
(paren
op_increment
id|serial_number
op_eq
l_int|0
)paren
id|serial_number
op_assign
l_int|1
suffix:semicolon
id|SCpnt-&gt;serial_number
op_assign
id|serial_number
suffix:semicolon
id|SCpnt-&gt;pid
op_assign
id|scsi_pid
op_increment
suffix:semicolon
multiline_comment|/* &n;&t; * If SCSI-2 or lower, store the LUN value in cmnd.&n;&t; */
r_if
c_cond
(paren
id|SCpnt-&gt;device-&gt;scsi_level
op_le
id|SCSI_2
)paren
id|SCpnt-&gt;cmnd
(braket
l_int|1
)braket
op_assign
(paren
id|SCpnt-&gt;cmnd
(braket
l_int|1
)braket
op_amp
l_int|0x1f
)paren
op_or
(paren
id|SCpnt-&gt;lun
op_lshift
l_int|5
op_amp
l_int|0xe0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We will wait MIN_RESET_DELAY clock ticks after the last reset so&n;&t; * we can avoid the drive not being ready.&n;&t; */
id|timeout
op_assign
id|host-&gt;last_reset
op_plus
id|MIN_RESET_DELAY
suffix:semicolon
r_if
c_cond
(paren
id|host-&gt;resetting
op_logical_and
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
r_int
id|ticks_remaining
op_assign
id|timeout
op_minus
id|jiffies
suffix:semicolon
multiline_comment|/*&n;&t;&t; * NOTE: This may be executed from within an interrupt&n;&t;&t; * handler!  This is bad, but for now, it&squot;ll do.  The irq&n;&t;&t; * level of the interrupt handler has been masked out by the&n;&t;&t; * platform dependent interrupt handling code already, so the&n;&t;&t; * sti() here will not cause another call to the SCSI host&squot;s&n;&t;&t; * interrupt handler (assuming there is one irq-level per&n;&t;&t; * host).&n;&t;&t; */
r_while
c_loop
(paren
op_decrement
id|ticks_remaining
op_ge
l_int|0
)paren
id|mdelay
c_func
(paren
l_int|1
op_plus
l_int|999
op_div
id|HZ
)paren
suffix:semicolon
id|host-&gt;resetting
op_assign
l_int|0
suffix:semicolon
)brace
id|scsi_add_timer
c_func
(paren
id|SCpnt
comma
id|SCpnt-&gt;timeout_per_command
comma
id|scsi_times_out
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We will use a queued command if possible, otherwise we will emulate the&n;&t; * queuing and calling of completion function ourselves.&n;&t; */
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi_dispatch_cmnd (host = %d, channel = %d, target = %d, &quot;
l_string|&quot;command = %p, buffer = %p, &bslash;nbufflen = %d, done = %p)&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;host_no
comma
id|SCpnt-&gt;channel
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;cmnd
comma
id|SCpnt-&gt;buffer
comma
id|SCpnt-&gt;bufflen
comma
id|SCpnt-&gt;done
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_QUEUED
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_LOWLEVEL
suffix:semicolon
r_if
c_cond
(paren
id|host-&gt;can_queue
)paren
(brace
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;queuecommand : routine at %p&bslash;n&quot;
comma
id|host-&gt;hostt-&gt;queuecommand
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Before we queue this command, check if the command&n;&t;&t; * length exceeds what the host adapter can handle.&n;&t;&t; */
r_if
c_cond
(paren
id|CDB_SIZE
c_func
(paren
id|SCpnt
)paren
op_le
id|SCpnt-&gt;host-&gt;max_cmd_len
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
id|host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|rtn
op_assign
id|host-&gt;hostt
op_member_access_from_pointer
id|queuecommand
c_func
(paren
id|SCpnt
comma
id|scsi_done
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_ne
l_int|0
)paren
(brace
id|scsi_mlqueue_insert
c_func
(paren
id|SCpnt
comma
id|rtn
op_eq
id|SCSI_MLQUEUE_DEVICE_BUSY
ques
c_cond
id|rtn
suffix:colon
id|SCSI_MLQUEUE_HOST_BUSY
)paren
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;queuecommand : request rejected&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;queuecommand : command too long.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
(paren
id|DID_ABORT
op_lshift
l_int|16
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|scsi_done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|rtn
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
r_int
id|temp
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;command() :  routine at %p&bslash;n&quot;
comma
id|host-&gt;hostt-&gt;command
)paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|temp
op_assign
id|host-&gt;hostt
op_member_access_from_pointer
id|command
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|temp
suffix:semicolon
macro_line|#ifdef DEBUG_DELAY
id|spin_unlock_irqrestore
c_func
(paren
id|host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|clock
op_assign
id|jiffies
op_plus
l_int|4
op_star
id|HZ
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|clock
)paren
)paren
(brace
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|cpu_relax
c_func
(paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;done(host = %d, result = %04x) : routine at %p&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|temp
comma
id|host-&gt;hostt-&gt;command
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#endif
id|scsi_done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;leaving scsi_dispatch_cmnd()&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|rtn
suffix:semicolon
)brace
DECL|variable|scsi_devfs_handle
id|devfs_handle_t
id|scsi_devfs_handle
suffix:semicolon
multiline_comment|/*&n; * scsi_do_cmd sends all the commands out to the low-level driver.  It&n; * handles the specifics required for each low level driver - ie queued&n; * or non queued.  It also prevents conflicts when different high level&n; * drivers go for the same host at the same time.&n; */
DECL|function|scsi_wait_req
r_void
id|scsi_wait_req
(paren
id|Scsi_Request
op_star
id|SRpnt
comma
r_const
r_void
op_star
id|cmnd
comma
r_void
op_star
id|buffer
comma
r_int
id|bufflen
comma
r_int
id|timeout
comma
r_int
id|retries
)paren
(brace
id|DECLARE_COMPLETION
c_func
(paren
id|wait
)paren
suffix:semicolon
id|request_queue_t
op_star
id|q
op_assign
op_amp
id|SRpnt-&gt;sr_device-&gt;request_queue
suffix:semicolon
id|SRpnt-&gt;sr_request-&gt;waiting
op_assign
op_amp
id|wait
suffix:semicolon
id|SRpnt-&gt;sr_request-&gt;rq_status
op_assign
id|RQ_SCSI_BUSY
suffix:semicolon
id|scsi_do_req
(paren
id|SRpnt
comma
(paren
r_void
op_star
)paren
id|cmnd
comma
id|buffer
comma
id|bufflen
comma
id|scsi_wait_done
comma
id|timeout
comma
id|retries
)paren
suffix:semicolon
id|generic_unplug_device
c_func
(paren
id|q
)paren
suffix:semicolon
id|wait_for_completion
c_func
(paren
op_amp
id|wait
)paren
suffix:semicolon
id|SRpnt-&gt;sr_request-&gt;waiting
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|SRpnt-&gt;sr_command
op_ne
l_int|NULL
)paren
(brace
id|scsi_release_command
c_func
(paren
id|SRpnt-&gt;sr_command
)paren
suffix:semicolon
id|SRpnt-&gt;sr_command
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function:    scsi_do_req&n; *&n; * Purpose:     Queue a SCSI request&n; *&n; * Arguments:   SRpnt     - command descriptor.&n; *              cmnd      - actual SCSI command to be performed.&n; *              buffer    - data buffer.&n; *              bufflen   - size of data buffer.&n; *              done      - completion function to be run.&n; *              timeout   - how long to let it run before timeout.&n; *              retries   - number of retries we allow.&n; *&n; * Lock status: With the new queueing code, this is SMP-safe, and no locks&n; *              need be held upon entry.   The old queueing code the lock was&n; *              assumed to be held upon entry.&n; *&n; * Returns:     Nothing.&n; *&n; * Notes:       Prior to the new queue code, this function was not SMP-safe.&n; *              Also, this function is now only used for queueing requests&n; *              for things like ioctls and character device requests - this&n; *              is because we essentially just inject a request into the&n; *              queue for the device. Normal block device handling manipulates&n; *              the queue directly.&n; */
DECL|function|scsi_do_req
r_void
id|scsi_do_req
c_func
(paren
id|Scsi_Request
op_star
id|SRpnt
comma
r_const
r_void
op_star
id|cmnd
comma
r_void
op_star
id|buffer
comma
r_int
id|bufflen
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
comma
r_int
id|timeout
comma
r_int
id|retries
)paren
(brace
id|Scsi_Device
op_star
id|SDpnt
op_assign
id|SRpnt-&gt;sr_device
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|SDpnt-&gt;host
suffix:semicolon
id|ASSERT_LOCK
c_func
(paren
id|host-&gt;host_lock
comma
l_int|0
)paren
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|4
comma
(brace
r_int
id|i
suffix:semicolon
r_int
id|target
op_assign
id|SDpnt-&gt;id
suffix:semicolon
r_int
id|size
op_assign
id|COMMAND_SIZE
c_func
(paren
(paren
(paren
r_const
r_int
r_char
op_star
)paren
id|cmnd
)paren
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi_do_req (host = %d, channel = %d target = %d, &quot;
l_string|&quot;buffer =%p, bufflen = %d, done = %p, timeout = %d, &quot;
l_string|&quot;retries = %d)&bslash;n&quot;
l_string|&quot;command : &quot;
comma
id|host-&gt;host_no
comma
id|SDpnt-&gt;channel
comma
id|target
comma
id|buffer
comma
id|bufflen
comma
id|done
comma
id|timeout
comma
id|retries
)paren
suffix:semicolon
r_for
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
op_increment
id|i
)paren
id|printk
c_func
(paren
l_string|&quot;%02x  &quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|cmnd
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|host
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Invalid or not present host.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the upper level driver is reusing these things, then&n;&t; * we should release the low-level block now.  Another one will&n;&t; * be allocated later when this request is getting queued.&n;&t; */
r_if
c_cond
(paren
id|SRpnt-&gt;sr_command
op_ne
l_int|NULL
)paren
(brace
id|scsi_release_command
c_func
(paren
id|SRpnt-&gt;sr_command
)paren
suffix:semicolon
id|SRpnt-&gt;sr_command
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We must prevent reentrancy to the lowlevel host driver.  This prevents&n;&t; * it - we enter a loop until the host we want to talk to is not busy.&n;&t; * Race conditions are prevented, as interrupts are disabled in between the&n;&t; * time we check for the host being not busy, and the time we mark it busy&n;&t; * ourselves.&n;&t; */
multiline_comment|/*&n;&t; * Our own function scsi_done (which marks the host as not busy, disables&n;&t; * the timeout counter, etc) will be called by us or by the&n;&t; * scsi_hosts[host].queuecommand() function needs to also call&n;&t; * the completion function for the high level driver.&n;&t; */
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|SRpnt-&gt;sr_cmnd
comma
(paren
r_const
r_void
op_star
)paren
id|cmnd
comma
r_sizeof
(paren
id|SRpnt-&gt;sr_cmnd
)paren
)paren
suffix:semicolon
id|SRpnt-&gt;sr_bufflen
op_assign
id|bufflen
suffix:semicolon
id|SRpnt-&gt;sr_buffer
op_assign
id|buffer
suffix:semicolon
id|SRpnt-&gt;sr_allowed
op_assign
id|retries
suffix:semicolon
id|SRpnt-&gt;sr_done
op_assign
id|done
suffix:semicolon
id|SRpnt-&gt;sr_timeout_per_command
op_assign
id|timeout
suffix:semicolon
r_if
c_cond
(paren
id|SRpnt-&gt;sr_cmd_len
op_eq
l_int|0
)paren
id|SRpnt-&gt;sr_cmd_len
op_assign
id|COMMAND_SIZE
c_func
(paren
id|SRpnt-&gt;sr_cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * At this point, we merely set up the command, stick it in the normal&n;&t; * request queue, and return.  Eventually that request will come to the&n;&t; * top of the list, and will be dispatched.&n;&t; */
id|scsi_insert_special_req
c_func
(paren
id|SRpnt
comma
l_int|0
)paren
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Leaving scsi_do_req()&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_init_cmd_from_req&n; *&n; * Purpose:     Queue a SCSI command&n; * Purpose:     Initialize a Scsi_Cmnd from a Scsi_Request&n; *&n; * Arguments:   SCpnt     - command descriptor.&n; *              SRpnt     - Request from the queue.&n; *&n; * Lock status: None needed.&n; *&n; * Returns:     Nothing.&n; *&n; * Notes:       Mainly transfer data from the request structure to the&n; *              command structure.  The request structure is allocated&n; *              using the normal memory allocator, and requests can pile&n; *              up to more or less any depth.  The command structure represents&n; *              a consumable resource, as these are allocated into a pool&n; *              when the SCSI subsystem initializes.  The preallocation is&n; *              required so that in low-memory situations a disk I/O request&n; *              won&squot;t cause the memory manager to try and write out a page.&n; *              The request structure is generally used by ioctls and character&n; *              devices.&n; */
DECL|function|scsi_init_cmd_from_req
r_void
id|scsi_init_cmd_from_req
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
id|Scsi_Request
op_star
id|SRpnt
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|SCpnt-&gt;host
suffix:semicolon
id|ASSERT_LOCK
c_func
(paren
id|host-&gt;host_lock
comma
l_int|0
)paren
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_MIDLEVEL
suffix:semicolon
id|SRpnt-&gt;sr_command
op_assign
id|SCpnt
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|host
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Invalid or not present host.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|SCpnt-&gt;cmd_len
op_assign
id|SRpnt-&gt;sr_cmd_len
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
id|SRpnt-&gt;sr_use_sg
suffix:semicolon
id|SCpnt-&gt;request
op_assign
id|SRpnt-&gt;sr_request
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;data_cmnd
comma
(paren
r_const
r_void
op_star
)paren
id|SRpnt-&gt;sr_cmnd
comma
r_sizeof
(paren
id|SCpnt-&gt;data_cmnd
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;reset_chain
op_assign
l_int|NULL
suffix:semicolon
id|SCpnt-&gt;serial_number
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;serial_number_at_timeout
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;bufflen
op_assign
id|SRpnt-&gt;sr_bufflen
suffix:semicolon
id|SCpnt-&gt;buffer
op_assign
id|SRpnt-&gt;sr_buffer
suffix:semicolon
id|SCpnt-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;retries
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;allowed
op_assign
id|SRpnt-&gt;sr_allowed
suffix:semicolon
id|SCpnt-&gt;done
op_assign
id|SRpnt-&gt;sr_done
suffix:semicolon
id|SCpnt-&gt;timeout_per_command
op_assign
id|SRpnt-&gt;sr_timeout_per_command
suffix:semicolon
id|SCpnt-&gt;sc_data_direction
op_assign
id|SRpnt-&gt;sr_data_direction
suffix:semicolon
id|SCpnt-&gt;sglist_len
op_assign
id|SRpnt-&gt;sr_sglist_len
suffix:semicolon
id|SCpnt-&gt;underflow
op_assign
id|SRpnt-&gt;sr_underflow
suffix:semicolon
id|SCpnt-&gt;sc_request
op_assign
id|SRpnt
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;cmnd
comma
(paren
r_const
r_void
op_star
)paren
id|SRpnt-&gt;sr_cmnd
comma
r_sizeof
(paren
id|SCpnt-&gt;cmnd
)paren
)paren
suffix:semicolon
multiline_comment|/* Zero the sense buffer.  Some host adapters automatically request&n;&t; * sense on error.  0 is not a valid sense code.&n;&t; */
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
id|SCpnt-&gt;sense_buffer
)paren
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
id|SRpnt-&gt;sr_buffer
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
id|SRpnt-&gt;sr_bufflen
suffix:semicolon
id|SCpnt-&gt;old_use_sg
op_assign
id|SCpnt-&gt;use_sg
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;cmd_len
op_eq
l_int|0
)paren
id|SCpnt-&gt;cmd_len
op_assign
id|COMMAND_SIZE
c_func
(paren
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|SCpnt-&gt;old_cmd_len
op_assign
id|SCpnt-&gt;cmd_len
suffix:semicolon
id|SCpnt-&gt;sc_old_data_direction
op_assign
id|SCpnt-&gt;sc_data_direction
suffix:semicolon
id|SCpnt-&gt;old_underflow
op_assign
id|SCpnt-&gt;underflow
suffix:semicolon
multiline_comment|/* Start the timer ticking.  */
id|SCpnt-&gt;internal_timeout
op_assign
id|NORMAL_TIMEOUT
suffix:semicolon
id|SCpnt-&gt;abort_reason
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;result
op_assign
l_int|0
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Leaving scsi_init_cmd_from_req()&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_do_cmd&n; *&n; * Purpose:     Queue a SCSI command&n; *&n; * Arguments:   SCpnt     - command descriptor.&n; *              cmnd      - actual SCSI command to be performed.&n; *              buffer    - data buffer.&n; *              bufflen   - size of data buffer.&n; *              done      - completion function to be run.&n; *              timeout   - how long to let it run before timeout.&n; *              retries   - number of retries we allow.&n; *&n; * Lock status: With the new queueing code, this is SMP-safe, and no locks&n; *              need be held upon entry.   The old queueing code the lock was&n; *              assumed to be held upon entry.&n; *&n; * Returns:     Nothing.&n; *&n; * Notes:       Prior to the new queue code, this function was not SMP-safe.&n; *              Also, this function is now only used for queueing requests&n; *              for things like ioctls and character device requests - this&n; *              is because we essentially just inject a request into the&n; *              queue for the device. Normal block device handling manipulates&n; *              the queue directly.&n; */
DECL|function|scsi_do_cmd
r_void
id|scsi_do_cmd
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_const
r_void
op_star
id|cmnd
comma
r_void
op_star
id|buffer
comma
r_int
id|bufflen
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
comma
r_int
id|timeout
comma
r_int
id|retries
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|SCpnt-&gt;host
suffix:semicolon
id|ASSERT_LOCK
c_func
(paren
id|host-&gt;host_lock
comma
l_int|0
)paren
suffix:semicolon
id|SCpnt-&gt;pid
op_assign
id|scsi_pid
op_increment
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_MIDLEVEL
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|4
comma
(brace
r_int
id|i
suffix:semicolon
r_int
id|target
op_assign
id|SCpnt-&gt;target
suffix:semicolon
r_int
id|size
op_assign
id|COMMAND_SIZE
c_func
(paren
(paren
(paren
r_const
r_int
r_char
op_star
)paren
id|cmnd
)paren
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi_do_cmd (host = %d, channel = %d target = %d, &quot;
l_string|&quot;buffer =%p, bufflen = %d, done = %p, timeout = %d, &quot;
l_string|&quot;retries = %d)&bslash;n&quot;
l_string|&quot;command : &quot;
comma
id|host-&gt;host_no
comma
id|SCpnt-&gt;channel
comma
id|target
comma
id|buffer
comma
id|bufflen
comma
id|done
comma
id|timeout
comma
id|retries
)paren
suffix:semicolon
r_for
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
op_increment
id|i
)paren
id|printk
c_func
(paren
l_string|&quot;%02x  &quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|cmnd
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|host
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Invalid or not present host.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We must prevent reentrancy to the lowlevel host driver.  This prevents&n;&t; * it - we enter a loop until the host we want to talk to is not busy.&n;&t; * Race conditions are prevented, as interrupts are disabled in between the&n;&t; * time we check for the host being not busy, and the time we mark it busy&n;&t; * ourselves.&n;&t; */
multiline_comment|/*&n;&t; * Our own function scsi_done (which marks the host as not busy, disables&n;&t; * the timeout counter, etc) will be called by us or by the&n;&t; * scsi_hosts[host].queuecommand() function needs to also call&n;&t; * the completion function for the high level driver.&n;&t; */
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;data_cmnd
comma
(paren
r_const
r_void
op_star
)paren
id|cmnd
comma
r_sizeof
(paren
id|SCpnt-&gt;data_cmnd
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;reset_chain
op_assign
l_int|NULL
suffix:semicolon
id|SCpnt-&gt;serial_number
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;serial_number_at_timeout
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;bufflen
op_assign
id|bufflen
suffix:semicolon
id|SCpnt-&gt;buffer
op_assign
id|buffer
suffix:semicolon
id|SCpnt-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;retries
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;allowed
op_assign
id|retries
suffix:semicolon
id|SCpnt-&gt;done
op_assign
id|done
suffix:semicolon
id|SCpnt-&gt;timeout_per_command
op_assign
id|timeout
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;cmnd
comma
(paren
r_const
r_void
op_star
)paren
id|cmnd
comma
r_sizeof
(paren
id|SCpnt-&gt;cmnd
)paren
)paren
suffix:semicolon
multiline_comment|/* Zero the sense buffer.  Some host adapters automatically request&n;&t; * sense on error.  0 is not a valid sense code.&n;&t; */
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
id|SCpnt-&gt;sense_buffer
)paren
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
id|buffer
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
id|bufflen
suffix:semicolon
id|SCpnt-&gt;old_use_sg
op_assign
id|SCpnt-&gt;use_sg
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;cmd_len
op_eq
l_int|0
)paren
id|SCpnt-&gt;cmd_len
op_assign
id|COMMAND_SIZE
c_func
(paren
id|SCpnt-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|SCpnt-&gt;old_cmd_len
op_assign
id|SCpnt-&gt;cmd_len
suffix:semicolon
id|SCpnt-&gt;sc_old_data_direction
op_assign
id|SCpnt-&gt;sc_data_direction
suffix:semicolon
id|SCpnt-&gt;old_underflow
op_assign
id|SCpnt-&gt;underflow
suffix:semicolon
multiline_comment|/* Start the timer ticking.  */
id|SCpnt-&gt;internal_timeout
op_assign
id|NORMAL_TIMEOUT
suffix:semicolon
id|SCpnt-&gt;abort_reason
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;result
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * At this point, we merely set up the command, stick it in the normal&n;&t; * request queue, and return.  Eventually that request will come to the&n;&t; * top of the list, and will be dispatched.&n;&t; */
id|scsi_insert_special_cmd
c_func
(paren
id|SCpnt
comma
l_int|0
)paren
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Leaving scsi_do_cmd()&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_done - Mark this command as done&n; * @SCpnt: The SCSI Command which we think we&squot;ve completed.&n; *&n; * This function is the mid-level interrupt routine, which decides how&n; * to handle error conditions.  Each invocation of this function must&n; * do one and *only* one of the following:&n; *&n; *      1) Insert command in BH queue.&n; *      2) Activate error handler for host.&n; *&n; * There is no longer a problem with stack overflow.  Interrupts queue&n; * Scsi_Cmnd on a per-CPU queue and the softirq handler removes them&n; * from the queue one at a time.&n; *&n; * This function is sometimes called from interrupt context, but sometimes&n; * from task context.&n; */
DECL|function|scsi_done
r_void
id|scsi_done
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|cpu
comma
id|tstatus
suffix:semicolon
r_struct
id|softscsi_data
op_star
id|queue
suffix:semicolon
multiline_comment|/*&n;&t; * We don&squot;t have to worry about this one timing out any more.&n;&t; */
id|tstatus
op_assign
id|scsi_delete_timer
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we are unable to remove the timer, it means that the command&n;&t; * has already timed out.  In this case, we have no choice but to&n;&t; * let the timeout function run, as we have no idea where in fact&n;&t; * that function could really be.  It might be on another processor,&n;&t; * etc, etc.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|tstatus
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Set the serial numbers back to zero */
id|SCpnt-&gt;serial_number
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;serial_number_at_timeout
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_BHQUEUE
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_BH_HANDLER
suffix:semicolon
id|SCpnt-&gt;bh_next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Next, put this command in the softirq queue.&n;&t; *&n;&t; * This is a per-CPU queue, so we just disable local interrupts&n;&t; * and need no spinlock.&n;&t; */
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|queue
op_assign
op_amp
id|softscsi_data
(braket
id|cpu
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|queue-&gt;head
)paren
(brace
id|queue-&gt;head
op_assign
id|SCpnt
suffix:semicolon
id|queue-&gt;tail
op_assign
id|SCpnt
suffix:semicolon
)brace
r_else
(brace
id|queue-&gt;tail-&gt;bh_next
op_assign
id|SCpnt
suffix:semicolon
id|queue-&gt;tail
op_assign
id|SCpnt
suffix:semicolon
)brace
id|cpu_raise_softirq
c_func
(paren
id|cpu
comma
id|SCSI_SOFTIRQ
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_softirq - Perform post-interrupt handling for completed commands&n; *&n; * This is called with all interrupts enabled.  This should reduce&n; * interrupt latency, stack depth, and reentrancy of the low-level&n; * drivers.&n; */
DECL|function|scsi_softirq
r_static
r_void
id|scsi_softirq
c_func
(paren
r_struct
id|softirq_action
op_star
id|h
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_struct
id|softscsi_data
op_star
id|queue
op_assign
op_amp
id|softscsi_data
(braket
id|cpu
)braket
suffix:semicolon
r_while
c_loop
(paren
id|queue-&gt;head
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCpnt
comma
op_star
id|SCnext
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|SCpnt
op_assign
id|queue-&gt;head
suffix:semicolon
id|queue-&gt;head
op_assign
l_int|NULL
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCnext
)paren
(brace
id|SCnext
op_assign
id|SCpnt-&gt;bh_next
suffix:semicolon
r_switch
c_cond
(paren
id|scsi_decide_disposition
c_func
(paren
id|SCpnt
)paren
)paren
(brace
r_case
id|SUCCESS
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * Add to BH queue.&n;&t;&t;&t;&t; */
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Command finished %d %d 0x%x&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;host_busy
comma
id|SCpnt-&gt;host-&gt;host_failed
comma
id|SCpnt-&gt;result
)paren
)paren
suffix:semicolon
id|scsi_finish_command
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NEEDS_RETRY
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * We only come in here if we want to retry a&n;&t;&t;&t;&t; * command.  The test to see whether the&n;&t;&t;&t;&t; * command should be retried should be keeping&n;&t;&t;&t;&t; * track of the number of tries, so we don&squot;t&n;&t;&t;&t;&t; * end up looping, of course.&n;&t;&t;&t;&t; */
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Command needs retry %d %d 0x%x&bslash;n&quot;
comma
id|SCpnt-&gt;host-&gt;host_busy
comma
id|SCpnt-&gt;host-&gt;host_failed
comma
id|SCpnt-&gt;result
)paren
)paren
suffix:semicolon
id|scsi_retry_command
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ADD_TO_MLQUEUE
suffix:colon
multiline_comment|/* &n;&t;&t;&t;&t; * This typically happens for a QUEUE_FULL&n;&t;&t;&t;&t; * message - typically only when the queue&n;&t;&t;&t;&t; * depth is only approximate for a given&n;&t;&t;&t;&t; * device.  Adding a command to the queue for&n;&t;&t;&t;&t; * the device will prevent further commands&n;&t;&t;&t;&t; * from being sent to the device, so we&n;&t;&t;&t;&t; * shouldn&squot;t end up with tons of things being&n;&t;&t;&t;&t; * sent down that shouldn&squot;t be.&n;&t;&t;&t;&t; */
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Command rejected as device queue full, put on ml queue %p&bslash;n&quot;
comma
id|SCpnt
)paren
)paren
suffix:semicolon
id|scsi_mlqueue_insert
c_func
(paren
id|SCpnt
comma
id|SCSI_MLQUEUE_DEVICE_BUSY
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * Here we have a fatal error of some sort.&n;&t;&t;&t;&t; * Turn it over to the error handler.&n;&t;&t;&t;&t; */
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Command failed %p %x active=%d busy=%d failed=%d&bslash;n&quot;
comma
id|SCpnt
comma
id|SCpnt-&gt;result
comma
id|atomic_read
c_func
(paren
op_amp
id|SCpnt-&gt;host-&gt;host_active
)paren
comma
id|SCpnt-&gt;host-&gt;host_busy
comma
id|SCpnt-&gt;host-&gt;host_failed
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Dump the sense information too.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|status_byte
c_func
(paren
id|SCpnt-&gt;result
)paren
op_amp
id|CHECK_CONDITION
)paren
op_ne
l_int|0
)paren
(brace
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|3
comma
id|print_sense
c_func
(paren
l_string|&quot;bh&quot;
comma
id|SCpnt
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCpnt-&gt;host-&gt;eh_wait
op_ne
l_int|NULL
)paren
(brace
id|scsi_eh_eflags_set
c_func
(paren
id|SCpnt
comma
id|SCSI_EH_CMD_FAILED
op_or
id|SCSI_EH_CMD_ERR
)paren
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_ERROR_HANDLER
suffix:semicolon
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_FAILED
suffix:semicolon
id|scsi_host_failed_inc_and_test
c_func
(paren
id|SCpnt-&gt;host
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * We only get here if the error&n;&t;&t;&t;&t;&t; * recovery thread has died.&n;&t;&t;&t;&t;&t; */
id|scsi_finish_command
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* switch */
)brace
multiline_comment|/* for(; SCpnt...) */
)brace
multiline_comment|/* while(queue-&gt;head) */
)brace
multiline_comment|/*&n; * Function:    scsi_retry_command&n; *&n; * Purpose:     Send a command back to the low level to be retried.&n; *&n; * Notes:       This command is always executed in the context of the&n; *              bottom half handler, or the error handler thread. Low&n; *              level drivers should not become re-entrant as a result of&n; *              this.&n; */
DECL|function|scsi_retry_command
r_int
id|scsi_retry_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
multiline_comment|/*&n;&t; * Restore the SCSI command state.&n;&t; */
id|scsi_setup_cmd_retry
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
multiline_comment|/*&n;         * Zero the sense information from the last time we tried&n;         * this command.&n;         */
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
id|SCpnt-&gt;sense_buffer
)paren
suffix:semicolon
r_return
id|scsi_dispatch_cmd
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_finish_command&n; *&n; * Purpose:     Pass command off to upper layer for finishing of I/O&n; *              request, waking processes that are waiting on results,&n; *              etc.&n; */
DECL|function|scsi_finish_command
r_void
id|scsi_finish_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
id|Scsi_Device
op_star
id|device
suffix:semicolon
id|Scsi_Request
op_star
id|SRpnt
suffix:semicolon
id|host
op_assign
id|SCpnt-&gt;host
suffix:semicolon
id|device
op_assign
id|SCpnt-&gt;device
suffix:semicolon
id|ASSERT_LOCK
c_func
(paren
id|host-&gt;host_lock
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;         * We need to protect the decrement, as otherwise a race condition&n;         * would exist.  Fiddling with SCpnt isn&squot;t a problem as the&n;         * design only allows a single SCpnt to be active in only&n;         * one execution context, but the device and host structures are&n;         * shared.&n;         */
id|scsi_host_busy_dec_and_test
c_func
(paren
id|host
comma
id|device
)paren
suffix:semicolon
multiline_comment|/*&n;         * Clear the flags which say that the device/host is no longer&n;         * capable of accepting new commands.  These are set in scsi_queue.c&n;         * for both the queue full condition on a device, and for a&n;         * host full condition on the host.&n;         */
id|host-&gt;host_blocked
op_assign
l_int|0
suffix:semicolon
id|device-&gt;device_blocked
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If we have valid sense information, then some kind of recovery&n;&t; * must have taken place.  Make a note of this.&n;&t; */
r_if
c_cond
(paren
id|SCSI_SENSE_VALID
c_func
(paren
id|SCpnt
)paren
)paren
(brace
id|SCpnt-&gt;result
op_or_assign
(paren
id|DRIVER_SENSE
op_lshift
l_int|24
)paren
suffix:semicolon
)brace
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Notifying upper driver of completion for device %d %x&bslash;n&quot;
comma
id|SCpnt-&gt;device-&gt;id
comma
id|SCpnt-&gt;result
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_HIGHLEVEL
suffix:semicolon
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_FINISHED
suffix:semicolon
multiline_comment|/* We can get here with use_sg=0, causing a panic in the upper level (DB) */
id|SCpnt-&gt;use_sg
op_assign
id|SCpnt-&gt;old_use_sg
suffix:semicolon
multiline_comment|/*&n;&t;* If there is an associated request structure, copy the data over before we call the&n;&t;* completion function.&n;&t;*/
id|SRpnt
op_assign
id|SCpnt-&gt;sc_request
suffix:semicolon
r_if
c_cond
(paren
id|SRpnt
op_ne
l_int|NULL
)paren
(brace
id|SRpnt-&gt;sr_result
op_assign
id|SRpnt-&gt;sr_command-&gt;result
suffix:semicolon
r_if
c_cond
(paren
id|SRpnt-&gt;sr_result
op_ne
l_int|0
)paren
(brace
id|memcpy
c_func
(paren
id|SRpnt-&gt;sr_sense_buffer
comma
id|SRpnt-&gt;sr_command-&gt;sense_buffer
comma
r_sizeof
(paren
id|SRpnt-&gt;sr_sense_buffer
)paren
)paren
suffix:semicolon
)brace
)brace
id|SCpnt
op_member_access_from_pointer
id|done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_release_commandblocks()&n; *&n; * Purpose:     Release command blocks associated with a device.&n; *&n; * Arguments:   SDpnt   - device&n; *&n; * Returns:     Nothing&n; *&n; * Lock status: No locking assumed or required.&n; *&n; * Notes:&n; */
DECL|function|scsi_release_commandblocks
r_void
id|scsi_release_commandblocks
c_func
(paren
id|Scsi_Device
op_star
id|SDpnt
)paren
(brace
id|Scsi_Cmnd
op_star
id|SCpnt
comma
op_star
id|SCnext
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|SCpnt
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SCpnt
suffix:semicolon
id|SCpnt
op_assign
id|SCnext
)paren
(brace
id|SDpnt-&gt;device_queue
op_assign
id|SCnext
op_assign
id|SCpnt-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
(paren
r_char
op_star
)paren
id|SCpnt
)paren
suffix:semicolon
)brace
id|SDpnt-&gt;current_queue_depth
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;new_queue_depth
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_build_commandblocks()&n; *&n; * Purpose:     Allocate command blocks associated with a device.&n; *&n; * Arguments:   SDpnt   - device&n; *&n; * Returns:     Nothing&n; *&n; * Lock status: No locking assumed or required.&n; *&n; * Notes:&t;We really only allocate one command here.  We will allocate&n; *&t;&t;more commands as needed once the device goes into real use.&n; */
DECL|function|scsi_build_commandblocks
r_void
id|scsi_build_commandblocks
c_func
(paren
id|Scsi_Device
op_star
id|SDpnt
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt-&gt;current_queue_depth
op_ne
l_int|0
)paren
r_return
suffix:semicolon
id|SCpnt
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|Scsi_Cmnd
)paren
comma
id|GFP_ATOMIC
op_or
(paren
id|SDpnt-&gt;host-&gt;unchecked_isa_dma
ques
c_cond
id|GFP_DMA
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|SCpnt
)paren
(brace
multiline_comment|/*&n;&t;&t; * Since we don&squot;t currently have *any* command blocks on this&n;&t;&t; * device, go ahead and try an atomic allocation...&n;&t;&t; */
id|SCpnt
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|Scsi_Cmnd
)paren
comma
id|GFP_ATOMIC
op_or
(paren
id|SDpnt-&gt;host-&gt;unchecked_isa_dma
ques
c_cond
id|GFP_DMA
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|SCpnt
)paren
r_return
suffix:semicolon
multiline_comment|/* Oops, we aren&squot;t going anywhere for now */
)brace
id|memset
c_func
(paren
id|SCpnt
comma
l_int|0
comma
r_sizeof
(paren
id|Scsi_Cmnd
)paren
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|SCpnt-&gt;eh_timeout
)paren
suffix:semicolon
id|SCpnt-&gt;host
op_assign
id|SDpnt-&gt;host
suffix:semicolon
id|SCpnt-&gt;device
op_assign
id|SDpnt
suffix:semicolon
id|SCpnt-&gt;target
op_assign
id|SDpnt-&gt;id
suffix:semicolon
id|SCpnt-&gt;lun
op_assign
id|SDpnt-&gt;lun
suffix:semicolon
id|SCpnt-&gt;channel
op_assign
id|SDpnt-&gt;channel
suffix:semicolon
id|SCpnt-&gt;request
op_assign
l_int|NULL
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;old_use_sg
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;old_cmd_len
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;underflow
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;old_underflow
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;transfersize
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;resid
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;serial_number
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;serial_number_at_timeout
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|SCpnt-&gt;state
op_assign
id|SCSI_STATE_UNUSED
suffix:semicolon
id|SCpnt-&gt;owner
op_assign
id|SCSI_OWNER_NOBODY
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SDpnt-&gt;new_queue_depth
op_eq
l_int|0
)paren
(brace
id|SDpnt-&gt;new_queue_depth
op_assign
l_int|1
suffix:semicolon
)brace
id|SDpnt-&gt;current_queue_depth
op_increment
suffix:semicolon
id|SCpnt-&gt;next
op_assign
id|SDpnt-&gt;device_queue
suffix:semicolon
id|SDpnt-&gt;device_queue
op_assign
id|SCpnt
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:&t;scsi_adjust_queue_depth()&n; *&n; * Purpose:&t;Allow low level drivers to tell us to change the queue depth&n; * &t;&t;on a specific SCSI device&n; *&n; * Arguments:&t;SDpnt&t;- SCSI Device in question&n; * &t;&t;tagged&t;- Do we use tagged queueing (non-0) or do we treat&n; * &t;&t;&t;  this device as an untagged device (0)&n; * &t;&t;tags&t;- Number of tags allowed if tagged queueing enabled,&n; * &t;&t;&t;  or number of commands the low level driver can&n; * &t;&t;&t;  queue up in non-tagged mode (as per cmd_per_lun).&n; *&n; * Returns:&t;Nothing&n; *&n; * Lock Status:&t;None held on entry&n; *&n; * Notes:&t;Low level drivers may call this at any time and we will do&n; * &t;&t;the right thing depending on whether or not the device is&n; * &t;&t;currently active and whether or not it even has the&n; * &t;&t;command blocks built yet.&n; *&n; * &t;&t;If cmdblocks != 0 then we are a live device.  We just set the&n; * &t;&t;new_queue_depth variable and when the scsi completion handler&n; * &t;&t;notices that current_queue_depth != new_queue_depth it will&n; * &t;&t;work to rectify the situation.  If new_queue_depth is less than&n; * &t;&t;current_queue_depth, then it will free the completed command&n; * &t;&t;instead of putting it back on the free list and dec&n; * &t;&t;current_queue_depth.  Otherwise&t;it will try to allocate a new&n; * &t;&t;command block for the device and put it on the free list along&n; * &t;&t;with the command that is being&n; *&t;&t;completed.  Obviously, if the device isn&squot;t doing anything then&n; *&t;&t;neither is this code, so it will bring the devices queue depth&n; *&t;&t;back into line when the device is actually being used.  This&n; *&t;&t;keeps us from needing to fire off a kernel thread or some such&n; *&t;&t;nonsense (this routine can be called from interrupt code, so&n; *&t;&t;handling allocations here would be tricky and risky, making&n; *&t;&t;a kernel thread a much safer way to go if we wanted to handle&n; *&t;&t;the work immediately instead of letting it get done a little&n; *&t;&t;at a time in the completion handler).&n; */
DECL|function|scsi_adjust_queue_depth
r_void
id|scsi_adjust_queue_depth
c_func
(paren
id|Scsi_Device
op_star
id|SDpnt
comma
r_int
id|tagged
comma
r_int
id|tags
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * refuse to set tagged depth to an unworkable size&n;&t; */
r_if
c_cond
(paren
id|tags
op_le
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Limit max queue depth on a single lun to 256 for now.  Remember,&n;&t; * we allocate a struct scsi_command for each of these and keep it&n;&t; * around forever.  Too deep of a depth just wastes memory.&n;&t; */
r_if
c_cond
(paren
id|tags
OG
l_int|256
)paren
(brace
r_return
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
id|SDpnt-&gt;new_queue_depth
op_assign
id|tags
suffix:semicolon
r_switch
c_cond
(paren
id|tagged
)paren
(brace
r_case
id|MSG_ORDERED_TAG
suffix:colon
id|SDpnt-&gt;ordered_tags
op_assign
l_int|1
suffix:semicolon
id|SDpnt-&gt;simple_tags
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MSG_SIMPLE_TAG
suffix:colon
id|SDpnt-&gt;ordered_tags
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;simple_tags
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;(scsi%d:%d:%d:%d) &quot;
l_string|&quot;scsi_adjust_queue_depth, bad queue type, &quot;
l_string|&quot;disabled&bslash;n&quot;
comma
id|SDpnt-&gt;host-&gt;host_no
comma
id|SDpnt-&gt;channel
comma
id|SDpnt-&gt;id
comma
id|SDpnt-&gt;lun
)paren
suffix:semicolon
r_case
l_int|0
suffix:colon
id|SDpnt-&gt;ordered_tags
op_assign
id|SDpnt-&gt;simple_tags
op_assign
l_int|0
suffix:semicolon
id|SDpnt-&gt;new_queue_depth
op_assign
id|tags
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:&t;scsi_track_queue_full()&n; *&n; * Purpose:&t;This function will track successive QUEUE_FULL events on a&n; * &t;&t;specific SCSI device to determine if and when there is a&n; * &t;&t;need to adjust the queue depth on the device.&n; *&n; * Arguments:&t;SDpnt&t;- SCSI Device in question&n; * &t;&t;depth&t;- Current number of outstanding SCSI commands on&n; * &t;&t;&t;  this device, not counting the one returned as&n; * &t;&t;&t;  QUEUE_FULL.&n; *&n; * Returns:&t;0 - No change needed&n; * &t;&t;&gt;0 - Adjust queue depth to this new depth&n; * &t;&t;-1 - Drop back to untagged operation using host-&gt;cmd_per_lun&n; * &t;&t;&t;as the untagged command depth&n; *&n; * Lock Status:&t;None held on entry&n; *&n; * Notes:&t;Low level drivers may call this at any time and we will do&n; * &t;&t;&quot;The Right Thing.&quot;  We are interrupt context safe.&n; */
DECL|function|scsi_track_queue_full
r_int
id|scsi_track_queue_full
c_func
(paren
id|Scsi_Device
op_star
id|SDptr
comma
r_int
id|depth
)paren
(brace
r_if
c_cond
(paren
(paren
id|jiffies
op_rshift
l_int|4
)paren
op_ne
id|SDptr-&gt;last_queue_full_time
)paren
(brace
id|SDptr-&gt;last_queue_full_time
op_assign
(paren
id|jiffies
op_rshift
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SDptr-&gt;last_queue_full_depth
op_eq
id|depth
)paren
(brace
id|SDptr-&gt;last_queue_full_count
op_increment
suffix:semicolon
)brace
r_else
(brace
id|SDptr-&gt;last_queue_full_count
op_assign
l_int|1
suffix:semicolon
id|SDptr-&gt;last_queue_full_depth
op_assign
id|depth
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SDptr-&gt;last_queue_full_count
OG
l_int|10
)paren
(brace
r_if
c_cond
(paren
id|SDptr-&gt;last_queue_full_depth
OL
l_int|8
)paren
(brace
multiline_comment|/* Drop back to untagged */
id|scsi_adjust_queue_depth
c_func
(paren
id|SDptr
comma
l_int|0
multiline_comment|/* untagged */
comma
id|SDptr-&gt;host-&gt;cmd_per_lun
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SDptr-&gt;ordered_tags
)paren
(brace
id|scsi_adjust_queue_depth
c_func
(paren
id|SDptr
comma
id|MSG_ORDERED_TAG
comma
id|depth
)paren
suffix:semicolon
)brace
r_else
id|scsi_adjust_queue_depth
c_func
(paren
id|SDptr
comma
id|MSG_SIMPLE_TAG
comma
id|depth
)paren
suffix:semicolon
r_return
id|depth
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * scsi_strcpy_devinfo: called from scsi_dev_info_list_add to copy into&n; * devinfo vendor and model strings.&n; */
DECL|function|scsi_strcpy_devinfo
r_static
r_void
id|scsi_strcpy_devinfo
c_func
(paren
r_char
op_star
id|name
comma
r_char
op_star
id|to
comma
r_int
id|to_length
comma
r_char
op_star
id|from
comma
r_int
id|compatible
)paren
(brace
r_int
id|from_length
suffix:semicolon
id|from_length
op_assign
id|strlen
c_func
(paren
id|from
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|to
comma
id|from
comma
id|min
c_func
(paren
id|to_length
comma
id|from_length
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|from_length
OL
id|to_length
)paren
(brace
r_if
c_cond
(paren
id|compatible
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * NUL terminate the string if it is short.&n;&t;&t;&t; */
id|to
(braket
id|from_length
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* &n;&t;&t;&t; * space pad the string if it is short. &n;&t;&t;&t; */
id|strncpy
c_func
(paren
op_amp
id|to
(braket
id|from_length
)braket
comma
id|spaces
comma
id|to_length
op_minus
id|from_length
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|from_length
OG
id|to_length
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: %s string &squot;%s&squot; is too long&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|name
comma
id|from
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_dev_info_list_add: add one dev_info list entry.&n; * @vendor:&t;vendor string&n; * @model:&t;model (product) string&n; * @strflags:&t;integer string&n; * @flag:&t;if strflags NULL, use this flag value&n; *&n; * Description:&n; * &t;Create and add one dev_info entry for @vendor, @model, @strflags or&n; * &t;@flag. If @compatible, add to the tail of the list, do not space&n; * &t;pad, and set devinfo-&gt;compatible. The scsi_static_device_list entries&n; * &t;are added with @compatible 1 and @clfags NULL.&n; *&n; * Returns: 0 OK, -error on failure.&n; **/
DECL|function|scsi_dev_info_list_add
r_static
r_int
id|scsi_dev_info_list_add
c_func
(paren
r_int
id|compatible
comma
r_char
op_star
id|vendor
comma
r_char
op_star
id|model
comma
r_char
op_star
id|strflags
comma
r_int
id|flags
)paren
(brace
r_struct
id|scsi_dev_info_list
op_star
id|devinfo
suffix:semicolon
id|devinfo
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|devinfo
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|devinfo
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: no memory&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|scsi_strcpy_devinfo
c_func
(paren
l_string|&quot;vendor&quot;
comma
id|devinfo-&gt;vendor
comma
r_sizeof
(paren
id|devinfo-&gt;vendor
)paren
comma
id|vendor
comma
id|compatible
)paren
suffix:semicolon
id|scsi_strcpy_devinfo
c_func
(paren
l_string|&quot;model&quot;
comma
id|devinfo-&gt;model
comma
r_sizeof
(paren
id|devinfo-&gt;model
)paren
comma
id|model
comma
id|compatible
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strflags
)paren
id|devinfo-&gt;flags
op_assign
id|simple_strtoul
c_func
(paren
id|strflags
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_else
id|devinfo-&gt;flags
op_assign
id|flags
suffix:semicolon
id|devinfo-&gt;compatible
op_assign
id|compatible
suffix:semicolon
r_if
c_cond
(paren
id|compatible
)paren
id|list_add_tail
c_func
(paren
op_amp
id|devinfo-&gt;dev_info_list
comma
op_amp
id|scsi_dev_info_list
)paren
suffix:semicolon
r_else
id|list_add
c_func
(paren
op_amp
id|devinfo-&gt;dev_info_list
comma
op_amp
id|scsi_dev_info_list
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_dev_info_list_add_str: parse dev_list and add to the&n; * scsi_dev_info_list.&n; * @dev_list:&t;string of device flags to add&n; *&n; * Description:&n; * &t;Parse dev_list, and add entries to the scsi_dev_info_list.&n; * &t;dev_list is of the form &quot;vendor:product:flag,vendor:product:flag&quot;.&n; * &t;dev_list is modified via strsep. Can be called for command line&n; * &t;addition, for proc or mabye a sysfs interface.&n; *&n; * Returns: 0 if OK, -error on failure.&n; **/
DECL|function|scsi_dev_info_list_add_str
r_int
id|scsi_dev_info_list_add_str
(paren
r_char
op_star
id|dev_list
)paren
(brace
r_char
op_star
id|vendor
comma
op_star
id|model
comma
op_star
id|strflags
comma
op_star
id|next
suffix:semicolon
r_char
op_star
id|next_check
suffix:semicolon
r_int
id|res
op_assign
l_int|0
suffix:semicolon
id|next
op_assign
id|dev_list
suffix:semicolon
r_if
c_cond
(paren
id|next
op_logical_and
id|next
(braket
l_int|0
)braket
op_eq
l_char|&squot;&quot;&squot;
)paren
(brace
multiline_comment|/*&n;&t;&t; * Ignore both the leading and trailing quote.&n;&t;&t; */
id|next
op_increment
suffix:semicolon
id|next_check
op_assign
l_string|&quot;,&bslash;&quot;&quot;
suffix:semicolon
)brace
r_else
(brace
id|next_check
op_assign
l_string|&quot;,&quot;
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * For the leading and trailing &squot;&quot;&squot; case, the for loop comes&n;&t; * through the last time with vendor[0] == &squot;&bslash;0&squot;.&n;&t; */
r_for
c_loop
(paren
id|vendor
op_assign
id|strsep
c_func
(paren
op_amp
id|next
comma
l_string|&quot;:&quot;
)paren
suffix:semicolon
id|vendor
op_logical_and
(paren
id|vendor
(braket
l_int|0
)braket
op_ne
l_char|&squot;&bslash;0&squot;
)paren
op_logical_and
(paren
id|res
op_eq
l_int|0
)paren
suffix:semicolon
id|vendor
op_assign
id|strsep
c_func
(paren
op_amp
id|next
comma
l_string|&quot;:&quot;
)paren
)paren
(brace
id|strflags
op_assign
l_int|NULL
suffix:semicolon
id|model
op_assign
id|strsep
c_func
(paren
op_amp
id|next
comma
l_string|&quot;:&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|model
)paren
id|strflags
op_assign
id|strsep
c_func
(paren
op_amp
id|next
comma
id|next_check
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|model
op_logical_or
op_logical_neg
id|strflags
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: bad dev info string &squot;%s&squot; &squot;%s&squot;&quot;
l_string|&quot; &squot;%s&squot;&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|vendor
comma
id|model
comma
id|strflags
)paren
suffix:semicolon
id|res
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
id|res
op_assign
id|scsi_dev_info_list_add
c_func
(paren
l_int|0
multiline_comment|/* compatible */
comma
id|vendor
comma
id|model
comma
id|strflags
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_dev_list_init: set up the dynamic device list.&n; * @dev_list:&t;string of device flags to add&n; *&n; * Description:&n; * &t;Add command line @dev_list entries, then add&n; * &t;scsi_static_device_list entries to the scsi device info list.&n; **/
DECL|function|scsi_dev_info_list_init
r_static
r_void
id|scsi_dev_info_list_init
(paren
r_char
op_star
id|dev_list
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|scsi_dev_info_list_add_str
c_func
(paren
id|dev_list
)paren
op_eq
op_minus
id|ENOMEM
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|scsi_static_device_list
(braket
id|i
)braket
dot
id|vendor
op_ne
l_int|NULL
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|scsi_dev_info_list_add
c_func
(paren
l_int|1
multiline_comment|/* compatibile */
comma
id|scsi_static_device_list
(braket
id|i
)braket
dot
id|vendor
comma
id|scsi_static_device_list
(braket
id|i
)braket
dot
id|model
comma
l_int|NULL
comma
id|scsi_static_device_list
(braket
id|i
)braket
dot
id|flags
)paren
op_eq
op_minus
id|ENOMEM
)paren
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_dev_info_list_delete: called from scsi.c:exit_scsi to remove&n; * &t;the scsi_dev_info_list.&n; **/
DECL|function|scsi_dev_info_list_delete
r_static
r_void
id|scsi_dev_info_list_delete
(paren
r_void
)paren
(brace
r_struct
id|list_head
op_star
id|lh
comma
op_star
id|lh_next
suffix:semicolon
r_struct
id|scsi_dev_info_list
op_star
id|devinfo
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|lh
comma
id|lh_next
comma
op_amp
id|scsi_dev_info_list
)paren
(brace
id|devinfo
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|scsi_dev_info_list
comma
id|dev_info_list
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|devinfo
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * get_device_flags - get device specific flags from the dynamic device&n; * list. Called during scan time.&n; * @vendor:&t;vendor name&n; * @model:&t;model name&n; *&n; * Description:&n; *     Search the scsi_dev_info_list for an entry matching @vendor and&n; *     @model, if found, return the matching flags value, else return&n; *     scsi_default_dev_flags.&n; **/
DECL|function|scsi_get_device_flags
r_int
id|scsi_get_device_flags
c_func
(paren
r_int
r_char
op_star
id|vendor
comma
r_int
r_char
op_star
id|model
)paren
(brace
r_struct
id|scsi_dev_info_list
op_star
id|devinfo
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|devinfo
comma
op_amp
id|scsi_dev_info_list
comma
id|dev_info_list
)paren
(brace
r_if
c_cond
(paren
id|devinfo-&gt;compatible
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Behave like the older version of get_device_flags.&n;&t;&t;&t; */
r_int
id|max
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * XXX why skip leading spaces? If an odd INQUIRY&n;&t;&t;&t; * value, that should have been part of the&n;&t;&t;&t; * scsi_static_device_list[] entry, such as &quot;  FOO&quot;&n;&t;&t;&t; * rather than &quot;FOO&quot;. Since this code is already&n;&t;&t;&t; * here, and we don&squot;t know what device it is&n;&t;&t;&t; * trying to work with, leave it as-is.&n;&t;&t;&t; */
id|max
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* max length of vendor */
r_while
c_loop
(paren
(paren
id|max
OG
l_int|0
)paren
op_logical_and
op_star
id|vendor
op_eq
l_char|&squot; &squot;
)paren
(brace
id|max
op_decrement
suffix:semicolon
id|vendor
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * XXX removing the following strlen() would be&n;&t;&t;&t; * good, using it means that for a an entry not in&n;&t;&t;&t; * the list, we scan every byte of every vendor&n;&t;&t;&t; * listed in scsi_static_device_list[], and never match&n;&t;&t;&t; * a single one (and still have to compare at&n;&t;&t;&t; * least the first byte of each vendor).&n;&t;&t;&t; */
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|devinfo-&gt;vendor
comma
id|vendor
comma
id|min
c_func
(paren
id|max
comma
id|strlen
c_func
(paren
id|devinfo-&gt;vendor
)paren
)paren
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Skip spaces again.&n;&t;&t;&t; */
id|max
op_assign
l_int|16
suffix:semicolon
multiline_comment|/* max length of model */
r_while
c_loop
(paren
(paren
id|max
OG
l_int|0
)paren
op_logical_and
op_star
id|model
op_eq
l_char|&squot; &squot;
)paren
(brace
id|max
op_decrement
suffix:semicolon
id|model
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|devinfo-&gt;model
comma
id|model
comma
id|min
c_func
(paren
id|max
comma
id|strlen
c_func
(paren
id|devinfo-&gt;model
)paren
)paren
)paren
)paren
r_continue
suffix:semicolon
r_return
id|devinfo-&gt;flags
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|devinfo-&gt;vendor
comma
id|vendor
comma
r_sizeof
(paren
id|devinfo-&gt;vendor
)paren
)paren
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|devinfo-&gt;model
comma
id|model
comma
r_sizeof
(paren
id|devinfo-&gt;model
)paren
)paren
)paren
r_return
id|devinfo-&gt;flags
suffix:semicolon
)brace
)brace
r_return
id|scsi_default_dev_flags
suffix:semicolon
)brace
DECL|function|scsi_attach_device
r_int
id|scsi_attach_device
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
)paren
(brace
r_struct
id|Scsi_Device_Template
op_star
id|sdt
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|scsi_devicelist_mutex
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|sdt
comma
op_amp
id|scsi_devicelist
comma
id|list
)paren
r_if
c_cond
(paren
id|sdt-&gt;attach
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * XXX check result when the upper level attach&n;&t;&t;&t; * return values are fixed, and on failure goto&n;&t;&t;&t; * fail.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|try_module_get
c_func
(paren
id|sdt-&gt;module
)paren
)paren
(brace
(paren
op_star
id|sdt-&gt;attach
)paren
(paren
id|sdev
)paren
suffix:semicolon
id|module_put
c_func
(paren
id|sdt-&gt;module
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;SCSI module %s not ready, skipping attach.&bslash;n&quot;
comma
id|sdt-&gt;name
)paren
suffix:semicolon
)brace
)brace
id|up_read
c_func
(paren
op_amp
id|scsi_devicelist_mutex
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|scsi_detach_device
r_void
id|scsi_detach_device
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
)paren
(brace
r_struct
id|Scsi_Device_Template
op_star
id|sdt
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|scsi_devicelist_mutex
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|sdt
comma
op_amp
id|scsi_devicelist
comma
id|list
)paren
r_if
c_cond
(paren
id|sdt-&gt;detach
)paren
(brace
r_if
c_cond
(paren
id|try_module_get
c_func
(paren
id|sdt-&gt;module
)paren
)paren
(brace
(paren
op_star
id|sdt-&gt;detach
)paren
(paren
id|sdev
)paren
suffix:semicolon
id|module_put
c_func
(paren
id|sdt-&gt;module
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;SCSI module %s not ready, skipping detach.&bslash;n&quot;
comma
id|sdt-&gt;name
)paren
suffix:semicolon
)brace
)brace
id|up_read
c_func
(paren
op_amp
id|scsi_devicelist_mutex
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:&t;scsi_slave_attach()&n; *&n; * Purpose:&t;Called from the upper level driver attach to handle common&n; * &t;&t;attach code.&n; *&n; * Arguments:&t;sdev - scsi_device to attach&n; *&n; * Returns:&t;1 on error, 0 on succes&n; *&n; * Lock Status:&t;Protected via scsi_devicelist_mutex.&n; */
DECL|function|scsi_slave_attach
r_int
id|scsi_slave_attach
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
)paren
(brace
r_if
c_cond
(paren
id|sdev-&gt;attached
op_increment
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * No one was attached.&n;&t;&t; */
id|scsi_build_commandblocks
c_func
(paren
id|sdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;current_queue_depth
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;scsi: Allocation failure during&quot;
l_string|&quot; attach, some SCSI devices might not be&quot;
l_string|&quot; configured&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sdev-&gt;host-&gt;hostt-&gt;slave_configure
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|sdev-&gt;host-&gt;hostt
op_member_access_from_pointer
id|slave_configure
c_func
(paren
id|sdev
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi: failed low level driver&quot;
l_string|&quot; attach, some SCSI device might not be&quot;
l_string|&quot; configured&bslash;n&quot;
)paren
suffix:semicolon
id|scsi_release_commandblocks
c_func
(paren
id|sdev
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|sdev-&gt;host-&gt;cmd_per_lun
op_ne
l_int|0
)paren
id|scsi_adjust_queue_depth
c_func
(paren
id|sdev
comma
l_int|0
comma
id|sdev-&gt;host-&gt;cmd_per_lun
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:&t;scsi_slave_detach()&n; *&n; * Purpose:&t;Called from the upper level driver attach to handle common&n; * &t;&t;detach code.&n; *&n; * Arguments:&t;sdev - struct scsi_device to detach&n; *&n; * Lock Status:&t;Protected via scsi_devicelist_mutex.&n; */
DECL|function|scsi_slave_detach
r_void
id|scsi_slave_detach
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|sdev-&gt;attached
op_eq
l_int|0
)paren
(brace
id|scsi_release_commandblocks
c_func
(paren
id|sdev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This entry point should be called by a loadable module if it is trying&n; * add a high level scsi driver to the system.&n; *&n; * This entry point is called from the upper level module&squot;s module_init()&n; * routine.  That implies that when this function is called, the&n; * scsi_mod module is locked down because of upper module layering and&n; * that the high level driver module is locked down by being in it&squot;s&n; * init routine.  So, the *only* thing we have to do to protect adds &n; * we perform in this function is to make sure that all call&squot;s&n; * to the high level driver&squot;s attach() and detach() call in points, other&n; * than via scsi_register_device and scsi_unregister_device which are in&n; * the module_init and module_exit code respectively and therefore already&n; * locked down by the kernel module loader, are wrapped by try_module_get()&n; * and module_put() to avoid races on device adds and removes.&n; */
DECL|function|scsi_register_device
r_int
id|scsi_register_device
c_func
(paren
r_struct
id|Scsi_Device_Template
op_star
id|tpnt
)paren
(brace
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
macro_line|#ifdef CONFIG_KMOD
r_if
c_cond
(paren
id|scsi_host_get_next
c_func
(paren
l_int|NULL
)paren
op_eq
l_int|NULL
)paren
id|request_module
c_func
(paren
l_string|&quot;scsi_hostadapter&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|tpnt-&gt;list
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|scsi_devicelist_mutex
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|tpnt-&gt;list
comma
op_amp
id|scsi_devicelist
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|scsi_devicelist_mutex
)paren
suffix:semicolon
id|tpnt-&gt;scsi_driverfs_driver.name
op_assign
(paren
r_char
op_star
)paren
id|tpnt-&gt;tag
suffix:semicolon
id|tpnt-&gt;scsi_driverfs_driver.bus
op_assign
op_amp
id|scsi_driverfs_bus_type
suffix:semicolon
id|driver_register
c_func
(paren
op_amp
id|tpnt-&gt;scsi_driverfs_driver
)paren
suffix:semicolon
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_host_get_next
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|scsi_host_get_next
c_func
(paren
id|shpnt
)paren
)paren
id|list_for_each_entry
(paren
id|SDpnt
comma
op_amp
id|shpnt-&gt;my_devices
comma
id|siblings
)paren
(paren
op_star
id|tpnt-&gt;attach
)paren
(paren
id|SDpnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|scsi_unregister_device
r_int
id|scsi_unregister_device
c_func
(paren
r_struct
id|Scsi_Device_Template
op_star
id|tpnt
)paren
(brace
id|Scsi_Device
op_star
id|SDpnt
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shpnt
suffix:semicolon
id|driver_unregister
c_func
(paren
op_amp
id|tpnt-&gt;scsi_driverfs_driver
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Next, detach the devices from the driver.&n;&t; */
r_for
c_loop
(paren
id|shpnt
op_assign
id|scsi_host_get_next
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
id|shpnt
suffix:semicolon
id|shpnt
op_assign
id|scsi_host_get_next
c_func
(paren
id|shpnt
)paren
)paren
(brace
id|list_for_each_entry
c_func
(paren
id|SDpnt
comma
op_amp
id|shpnt-&gt;my_devices
comma
id|siblings
)paren
(paren
op_star
id|tpnt-&gt;detach
)paren
(paren
id|SDpnt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Extract the template from the linked list.&n;&t; */
id|down_write
c_func
(paren
op_amp
id|scsi_devicelist_mutex
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|tpnt-&gt;list
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|scsi_devicelist_mutex
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Final cleanup for the driver is done in the driver sources in the&n;&t; * cleanup function.&n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|scsi_dev_flags
r_static
r_char
op_star
id|scsi_dev_flags
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|scsi_dev_flags
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|scsi_dev_flags
comma
l_string|&quot;Given scsi_dev_flags=vendor:model:flags, add a black/white list&quot;
l_string|&quot; entry for vendor and model with an integer value of flags&quot;
l_string|&quot; to the scsi device info list&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|scsi_default_dev_flags
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|scsi_default_dev_flags
comma
l_string|&quot;scsi default device flag integer value&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;SCSI core&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
macro_line|#ifndef MODULE
DECL|function|setup_scsi_dev_flags
r_int
id|__init
id|setup_scsi_dev_flags
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|scsi_dev_flags
op_assign
id|str
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;scsi_dev_flags=&quot;
comma
id|setup_scsi_dev_flags
)paren
suffix:semicolon
DECL|function|setup_scsi_default_dev_flags
r_static
r_int
id|__init
id|setup_scsi_default_dev_flags
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|get_option
c_func
(paren
op_amp
id|str
comma
op_amp
id|tmp
)paren
op_eq
l_int|1
)paren
(brace
id|scsi_default_dev_flags
op_assign
id|tmp
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|scsi_default_dev_flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: usage scsi_default_dev_flags=intr&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|__setup
c_func
(paren
l_string|&quot;scsi_default_dev_flags=&quot;
comma
id|setup_scsi_default_dev_flags
)paren
suffix:semicolon
macro_line|#endif
DECL|function|scsi_pool_alloc
r_static
r_void
op_star
id|scsi_pool_alloc
c_func
(paren
r_int
id|gfp_mask
comma
r_void
op_star
id|data
)paren
(brace
r_return
id|kmem_cache_alloc
c_func
(paren
id|data
comma
id|gfp_mask
)paren
suffix:semicolon
)brace
DECL|function|scsi_pool_free
r_static
r_void
id|scsi_pool_free
c_func
(paren
r_void
op_star
id|ptr
comma
r_void
op_star
id|data
)paren
(brace
id|kmem_cache_free
c_func
(paren
id|data
comma
id|ptr
)paren
suffix:semicolon
)brace
DECL|function|scsi_alloc_sgtable
r_struct
id|scatterlist
op_star
id|scsi_alloc_sgtable
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
id|gfp_mask
)paren
(brace
r_struct
id|scsi_host_sg_pool
op_star
id|sgp
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sgl
suffix:semicolon
r_int
id|pf_flags
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|SCpnt-&gt;use_sg
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|SCpnt-&gt;use_sg
)paren
(brace
r_case
l_int|1
dot
dot
dot
l_int|8
suffix:colon
id|SCpnt-&gt;sglist_len
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9
dot
dot
dot
l_int|16
suffix:colon
id|SCpnt-&gt;sglist_len
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|17
dot
dot
dot
l_int|32
suffix:colon
id|SCpnt-&gt;sglist_len
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|33
dot
dot
dot
l_int|64
suffix:colon
id|SCpnt-&gt;sglist_len
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|65
dot
dot
dot
id|MAX_PHYS_SEGMENTS
suffix:colon
id|SCpnt-&gt;sglist_len
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
id|sgp
op_assign
id|scsi_sg_pools
op_plus
id|SCpnt-&gt;sglist_len
suffix:semicolon
id|pf_flags
op_assign
id|current-&gt;flags
suffix:semicolon
id|current-&gt;flags
op_or_assign
id|PF_NOWARN
suffix:semicolon
id|sgl
op_assign
id|mempool_alloc
c_func
(paren
id|sgp-&gt;pool
comma
id|gfp_mask
)paren
suffix:semicolon
id|current-&gt;flags
op_assign
id|pf_flags
suffix:semicolon
r_if
c_cond
(paren
id|sgl
)paren
(brace
id|memset
c_func
(paren
id|sgl
comma
l_int|0
comma
id|sgp-&gt;size
)paren
suffix:semicolon
r_return
id|sgl
suffix:semicolon
)brace
r_return
id|sgl
suffix:semicolon
)brace
DECL|function|scsi_free_sgtable
r_void
id|scsi_free_sgtable
c_func
(paren
r_struct
id|scatterlist
op_star
id|sgl
comma
r_int
id|index
)paren
(brace
r_struct
id|scsi_host_sg_pool
op_star
id|sgp
op_assign
id|scsi_sg_pools
op_plus
id|index
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|index
OG
id|SG_MEMPOOL_NR
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi_free_sgtable: mempool %d&bslash;n&quot;
comma
id|index
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|mempool_free
c_func
(paren
id|sgl
comma
id|sgp-&gt;pool
)paren
suffix:semicolon
)brace
DECL|function|scsi_bus_match
r_static
r_int
id|scsi_bus_match
c_func
(paren
r_struct
id|device
op_star
id|scsi_driverfs_dev
comma
r_struct
id|device_driver
op_star
id|scsi_driverfs_drv
)paren
(brace
r_char
op_star
id|p
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;sd&quot;
comma
id|scsi_driverfs_drv-&gt;name
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|p
op_assign
id|strstr
c_func
(paren
id|scsi_driverfs_dev-&gt;bus_id
comma
l_string|&quot;:disc&quot;
)paren
)paren
op_logical_or
(paren
id|p
op_assign
id|strstr
c_func
(paren
id|scsi_driverfs_dev-&gt;bus_id
comma
l_string|&quot;:p&quot;
)paren
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;sg&quot;
comma
id|scsi_driverfs_drv-&gt;name
)paren
)paren
(brace
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|scsi_driverfs_dev-&gt;bus_id
comma
l_string|&quot;:gen&quot;
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;sr&quot;
comma
id|scsi_driverfs_drv-&gt;name
)paren
)paren
(brace
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|scsi_driverfs_dev-&gt;bus_id
comma
l_string|&quot;:cd&quot;
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
l_string|&quot;st&quot;
comma
id|scsi_driverfs_drv-&gt;name
)paren
)paren
(brace
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|scsi_driverfs_dev-&gt;bus_id
comma
l_string|&quot;:mt&quot;
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|scsi_driverfs_bus_type
r_struct
id|bus_type
id|scsi_driverfs_bus_type
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;scsi&quot;
comma
dot
id|match
op_assign
id|scsi_bus_match
comma
)brace
suffix:semicolon
DECL|function|init_scsi
r_static
r_int
id|__init
id|init_scsi
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;SCSI subsystem driver &quot;
id|REVISION
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * setup sg memory pools&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SG_MEMPOOL_NR
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|scsi_host_sg_pool
op_star
id|sgp
op_assign
id|scsi_sg_pools
op_plus
id|i
suffix:semicolon
r_int
id|size
op_assign
id|sgp-&gt;size
op_star
r_sizeof
(paren
r_struct
id|scatterlist
)paren
suffix:semicolon
id|sgp-&gt;slab
op_assign
id|kmem_cache_create
c_func
(paren
id|sgp-&gt;name
comma
id|size
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sgp-&gt;slab
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;SCSI: can&squot;t init sg slab %s&bslash;n&quot;
comma
id|sgp-&gt;name
)paren
suffix:semicolon
id|sgp-&gt;pool
op_assign
id|mempool_create
c_func
(paren
id|SG_MEMPOOL_SIZE
comma
id|scsi_pool_alloc
comma
id|scsi_pool_free
comma
id|sgp-&gt;slab
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sgp-&gt;pool
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;SCSI: can&squot;t init sg mempool %s&bslash;n&quot;
comma
id|sgp-&gt;name
)paren
suffix:semicolon
)brace
id|scsi_init_procfs
c_func
(paren
)paren
suffix:semicolon
id|scsi_devfs_handle
op_assign
id|devfs_mk_dir
c_func
(paren
l_int|NULL
comma
l_string|&quot;scsi&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|scsi_host_init
c_func
(paren
)paren
suffix:semicolon
id|scsi_dev_info_list_init
c_func
(paren
id|scsi_dev_flags
)paren
suffix:semicolon
id|bus_register
c_func
(paren
op_amp
id|scsi_driverfs_bus_type
)paren
suffix:semicolon
id|open_softirq
c_func
(paren
id|SCSI_SOFTIRQ
comma
id|scsi_softirq
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|exit_scsi
r_static
r_void
id|__exit
id|exit_scsi
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|bus_unregister
c_func
(paren
op_amp
id|scsi_driverfs_bus_type
)paren
suffix:semicolon
id|scsi_dev_info_list_delete
c_func
(paren
)paren
suffix:semicolon
id|devfs_unregister
c_func
(paren
id|scsi_devfs_handle
)paren
suffix:semicolon
id|scsi_exit_procfs
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SG_MEMPOOL_NR
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|scsi_host_sg_pool
op_star
id|sgp
op_assign
id|scsi_sg_pools
op_plus
id|i
suffix:semicolon
id|mempool_destroy
c_func
(paren
id|sgp-&gt;pool
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|sgp-&gt;slab
)paren
suffix:semicolon
id|sgp-&gt;pool
op_assign
l_int|NULL
suffix:semicolon
id|sgp-&gt;slab
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|variable|init_scsi
id|module_init
c_func
(paren
id|init_scsi
)paren
suffix:semicolon
DECL|variable|exit_scsi
id|module_exit
c_func
(paren
id|exit_scsi
)paren
suffix:semicolon
eof
