multiline_comment|/*&n; *  scsi.c Copyright (C) 1992 Drew Eckhardt&n; *         Copyright (C) 1993, 1994, 1995, 1999 Eric Youngdale&n; *&n; *  generic mid-level SCSI driver&n; *      Initial versions: Drew Eckhardt&n; *      Subsequent revisions: Eric Youngdale&n; *&n; *  &lt;drew@colorado.edu&gt;&n; *&n; *  Bug correction thanks go to :&n; *      Rik Faith &lt;faith@cs.unc.edu&gt;&n; *      Tommy Thorn &lt;tthorn&gt;&n; *      Thomas Wuensche &lt;tw@fgb1.fgb.mw.tu-muenchen.de&gt;&n; *&n; *  Modified by Eric Youngdale eric@andante.org or ericy@gnu.ai.mit.edu to&n; *  add scatter-gather, multiple outstanding request, and other&n; *  enhancements.&n; *&n; *  Native multichannel, wide scsi, /proc/scsi and hot plugging&n; *  support added by Michael Neuffer &lt;mike@i-connect.net&gt;&n; *&n; *  Added request_module(&quot;scsi_hostadapter&quot;) for kerneld:&n; *  (Put an &quot;alias scsi_hostadapter your_hostadapter&quot; in /etc/modules.conf)&n; *  Bjorn Ekwall  &lt;bj0rn@blox.se&gt;&n; *  (changed to kmod)&n; *&n; *  Major improvements to the timeout, abort, and reset processing,&n; *  as well as performance modifications for large queue depths by&n; *  Leonard N. Zubkoff &lt;lnz@dandelion.com&gt;&n; *&n; *  Converted cli() code to spinlocks, Ingo Molnar&n; *&n; *  Jiffies wrap fixes (host-&gt;resetting), 3 Dec 1998 Andrea Arcangeli&n; *&n; *  out_of_space hacks, D. Gilbert (dpg) 990608&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/completion.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;scsi_priv.h&quot;
macro_line|#include &quot;scsi_logging.h&quot;
multiline_comment|/*&n; * Definitions and constants.&n; */
DECL|macro|MIN_RESET_DELAY
mdefine_line|#define MIN_RESET_DELAY (2*HZ)
multiline_comment|/* Do not call reset on error if we just did a reset within 15 sec. */
DECL|macro|MIN_RESET_PERIOD
mdefine_line|#define MIN_RESET_PERIOD (15*HZ)
multiline_comment|/*&n; * Macro to determine the size of SCSI command. This macro takes vendor&n; * unique commands into account. SCSI commands in groups 6 and 7 are&n; * vendor unique and we will depend upon the command length being&n; * supplied correctly in cmd_len.&n; */
DECL|macro|CDB_SIZE
mdefine_line|#define CDB_SIZE(cmd)&t;(((((cmd)-&gt;cmnd[0] &gt;&gt; 5) &amp; 7) &lt; 6) ? &bslash;&n;&t;&t;&t;&t;COMMAND_SIZE((cmd)-&gt;cmnd[0]) : (cmd)-&gt;cmd_len)
multiline_comment|/*&n; * Data declarations.&n; */
DECL|variable|scsi_pid
r_int
r_int
id|scsi_pid
suffix:semicolon
DECL|variable|serial_number
r_static
r_int
r_int
id|serial_number
suffix:semicolon
multiline_comment|/*&n; * Note - the initial logging level can be set here to log events at boot time.&n; * After the system is up, you may enable logging via the /proc interface.&n; */
DECL|variable|scsi_logging_level
r_int
r_int
id|scsi_logging_level
suffix:semicolon
DECL|variable|scsi_device_types
r_const
r_char
op_star
r_const
id|scsi_device_types
(braket
id|MAX_SCSI_DEVICE_CODE
)braket
op_assign
(brace
l_string|&quot;Direct-Access    &quot;
comma
l_string|&quot;Sequential-Access&quot;
comma
l_string|&quot;Printer          &quot;
comma
l_string|&quot;Processor        &quot;
comma
l_string|&quot;WORM             &quot;
comma
l_string|&quot;CD-ROM           &quot;
comma
l_string|&quot;Scanner          &quot;
comma
l_string|&quot;Optical Device   &quot;
comma
l_string|&quot;Medium Changer   &quot;
comma
l_string|&quot;Communications   &quot;
comma
l_string|&quot;Unknown          &quot;
comma
l_string|&quot;Unknown          &quot;
comma
l_string|&quot;Unknown          &quot;
comma
l_string|&quot;Enclosure        &quot;
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Function:    scsi_allocate_request&n; *&n; * Purpose:     Allocate a request descriptor.&n; *&n; * Arguments:   device    - device for which we want a request&n; *&n; * Lock status: No locks assumed to be held.  This function is SMP-safe.&n; *&n; * Returns:     Pointer to request block.&n; *&n; * Notes:       With the new queueing code, it becomes important&n; *              to track the difference between a command and a&n; *              request.  A request is a pending item in the queue that&n; *              has not yet reached the top of the queue.&n; *&n; * XXX(hch):&t;Need to add a gfp_mask argument.&n; */
DECL|function|scsi_allocate_request
r_struct
id|scsi_request
op_star
id|scsi_allocate_request
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
)paren
(brace
r_const
r_int
id|offset
op_assign
id|ALIGN
c_func
(paren
r_sizeof
(paren
r_struct
id|scsi_request
)paren
comma
l_int|4
)paren
suffix:semicolon
r_const
r_int
id|size
op_assign
id|offset
op_plus
r_sizeof
(paren
r_struct
id|request
)paren
suffix:semicolon
r_struct
id|scsi_request
op_star
id|sreq
suffix:semicolon
id|sreq
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|sreq
op_ne
l_int|NULL
)paren
)paren
(brace
id|memset
c_func
(paren
id|sreq
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
id|sreq-&gt;sr_request
op_assign
(paren
r_struct
id|request
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|sreq
)paren
op_plus
id|offset
)paren
suffix:semicolon
id|sreq-&gt;sr_device
op_assign
id|sdev
suffix:semicolon
id|sreq-&gt;sr_host
op_assign
id|sdev-&gt;host
suffix:semicolon
id|sreq-&gt;sr_magic
op_assign
id|SCSI_REQ_MAGIC
suffix:semicolon
id|sreq-&gt;sr_data_direction
op_assign
id|DMA_BIDIRECTIONAL
suffix:semicolon
)brace
r_return
id|sreq
suffix:semicolon
)brace
DECL|function|__scsi_release_request
r_void
id|__scsi_release_request
c_func
(paren
r_struct
id|scsi_request
op_star
id|sreq
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|sreq-&gt;sr_command
op_ne
l_int|NULL
)paren
)paren
(brace
r_struct
id|scsi_cmnd
op_star
id|cmd
op_assign
id|sreq-&gt;sr_command
suffix:semicolon
id|sreq-&gt;sr_command
op_assign
l_int|NULL
suffix:semicolon
id|scsi_next_command
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function:    scsi_release_request&n; *&n; * Purpose:     Release a request descriptor.&n; *&n; * Arguments:   sreq    - request to release&n; *&n; * Lock status: No locks assumed to be held.  This function is SMP-safe.&n; */
DECL|function|scsi_release_request
r_void
id|scsi_release_request
c_func
(paren
r_struct
id|scsi_request
op_star
id|sreq
)paren
(brace
id|__scsi_release_request
c_func
(paren
id|sreq
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sreq
)paren
suffix:semicolon
)brace
DECL|struct|scsi_host_cmd_pool
r_struct
id|scsi_host_cmd_pool
(brace
DECL|member|slab
id|kmem_cache_t
op_star
id|slab
suffix:semicolon
DECL|member|users
r_int
r_int
id|users
suffix:semicolon
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|slab_flags
r_int
r_int
id|slab_flags
suffix:semicolon
DECL|member|gfp_mask
r_int
r_int
id|gfp_mask
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|scsi_cmd_pool
r_static
r_struct
id|scsi_host_cmd_pool
id|scsi_cmd_pool
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;scsi_cmd_cache&quot;
comma
dot
id|slab_flags
op_assign
id|SLAB_HWCACHE_ALIGN
comma
)brace
suffix:semicolon
DECL|variable|scsi_cmd_dma_pool
r_static
r_struct
id|scsi_host_cmd_pool
id|scsi_cmd_dma_pool
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;scsi_cmd_cache(DMA)&quot;
comma
dot
id|slab_flags
op_assign
id|SLAB_HWCACHE_ALIGN
op_or
id|SLAB_CACHE_DMA
comma
dot
id|gfp_mask
op_assign
id|__GFP_DMA
comma
)brace
suffix:semicolon
r_static
id|DECLARE_MUTEX
c_func
(paren
id|host_cmd_pool_mutex
)paren
suffix:semicolon
DECL|function|__scsi_get_command
r_static
r_struct
id|scsi_cmnd
op_star
id|__scsi_get_command
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
comma
r_int
id|gfp_mask
)paren
(brace
r_struct
id|scsi_cmnd
op_star
id|cmd
suffix:semicolon
id|cmd
op_assign
id|kmem_cache_alloc
c_func
(paren
id|shost-&gt;cmd_pool-&gt;slab
comma
id|gfp_mask
op_or
id|shost-&gt;cmd_pool-&gt;gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|cmd
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|shost-&gt;free_list_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|shost-&gt;free_list
)paren
)paren
)paren
(brace
id|cmd
op_assign
id|list_entry
c_func
(paren
id|shost-&gt;free_list.next
comma
r_struct
id|scsi_cmnd
comma
id|list
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|cmd-&gt;list
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|shost-&gt;free_list_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|cmd
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:&t;scsi_get_command()&n; *&n; * Purpose:&t;Allocate and setup a scsi command block&n; *&n; * Arguments:&t;dev&t;- parent scsi device&n; *&t;&t;gfp_mask- allocator flags&n; *&n; * Returns:&t;The allocated scsi command structure.&n; */
DECL|function|scsi_get_command
r_struct
id|scsi_cmnd
op_star
id|scsi_get_command
c_func
(paren
r_struct
id|scsi_device
op_star
id|dev
comma
r_int
id|gfp_mask
)paren
(brace
r_struct
id|scsi_cmnd
op_star
id|cmd
op_assign
id|__scsi_get_command
c_func
(paren
id|dev-&gt;host
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|cmd
op_ne
l_int|NULL
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|memset
c_func
(paren
id|cmd
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|cmd
)paren
)paren
suffix:semicolon
id|cmd-&gt;device
op_assign
id|dev
suffix:semicolon
id|cmd-&gt;state
op_assign
id|SCSI_STATE_UNUSED
suffix:semicolon
id|cmd-&gt;owner
op_assign
id|SCSI_OWNER_NOBODY
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|cmd-&gt;eh_timeout
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cmd-&gt;list
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|dev-&gt;list_lock
comma
id|flags
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|cmd-&gt;list
comma
op_amp
id|dev-&gt;cmd_list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|dev-&gt;list_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|cmd
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:&t;scsi_put_command()&n; *&n; * Purpose:&t;Free a scsi command block&n; *&n; * Arguments:&t;cmd&t;- command block to free&n; *&n; * Returns:&t;Nothing.&n; *&n; * Notes:&t;The command must not belong to any lists.&n; */
DECL|function|scsi_put_command
r_void
id|scsi_put_command
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|shost
op_assign
id|cmd-&gt;device-&gt;host
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* serious error if the command hasn&squot;t come from a device list */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|cmd-&gt;device-&gt;list_lock
comma
id|flags
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|list_empty
c_func
(paren
op_amp
id|cmd-&gt;list
)paren
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|cmd-&gt;list
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|cmd-&gt;device-&gt;list_lock
)paren
suffix:semicolon
multiline_comment|/* changing locks here, don&squot;t need to restore the irq state */
id|spin_lock
c_func
(paren
op_amp
id|shost-&gt;free_list_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|list_empty
c_func
(paren
op_amp
id|shost-&gt;free_list
)paren
)paren
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|cmd-&gt;list
comma
op_amp
id|shost-&gt;free_list
)paren
suffix:semicolon
id|cmd
op_assign
l_int|NULL
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|shost-&gt;free_list_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|cmd
op_ne
l_int|NULL
)paren
)paren
id|kmem_cache_free
c_func
(paren
id|shost-&gt;cmd_pool-&gt;slab
comma
id|cmd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:&t;scsi_setup_command_freelist()&n; *&n; * Purpose:&t;Setup the command freelist for a scsi host.&n; *&n; * Arguments:&t;shost&t;- host to allocate the freelist for.&n; *&n; * Returns:&t;Nothing.&n; */
DECL|function|scsi_setup_command_freelist
r_int
id|scsi_setup_command_freelist
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
)paren
(brace
r_struct
id|scsi_host_cmd_pool
op_star
id|pool
suffix:semicolon
r_struct
id|scsi_cmnd
op_star
id|cmd
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|shost-&gt;free_list_lock
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|shost-&gt;free_list
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Select a command slab for this host and create it if not&n;&t; * yet existant.&n;&t; */
id|down
c_func
(paren
op_amp
id|host_cmd_pool_mutex
)paren
suffix:semicolon
id|pool
op_assign
(paren
id|shost-&gt;unchecked_isa_dma
ques
c_cond
op_amp
id|scsi_cmd_dma_pool
suffix:colon
op_amp
id|scsi_cmd_pool
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pool-&gt;users
)paren
(brace
id|pool-&gt;slab
op_assign
id|kmem_cache_create
c_func
(paren
id|pool-&gt;name
comma
r_sizeof
(paren
r_struct
id|scsi_cmnd
)paren
comma
l_int|0
comma
id|pool-&gt;slab_flags
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pool-&gt;slab
)paren
r_goto
id|fail
suffix:semicolon
)brace
id|pool-&gt;users
op_increment
suffix:semicolon
id|shost-&gt;cmd_pool
op_assign
id|pool
suffix:semicolon
id|up
c_func
(paren
op_amp
id|host_cmd_pool_mutex
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get one backup command for this host.&n;&t; */
id|cmd
op_assign
id|kmem_cache_alloc
c_func
(paren
id|shost-&gt;cmd_pool-&gt;slab
comma
id|GFP_KERNEL
op_or
id|shost-&gt;cmd_pool-&gt;gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmd
)paren
r_goto
id|fail2
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|cmd-&gt;list
comma
op_amp
id|shost-&gt;free_list
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|fail2
suffix:colon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|pool-&gt;users
)paren
id|kmem_cache_destroy
c_func
(paren
id|pool-&gt;slab
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|fail
suffix:colon
id|up
c_func
(paren
op_amp
id|host_cmd_pool_mutex
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:&t;scsi_destroy_command_freelist()&n; *&n; * Purpose:&t;Release the command freelist for a scsi host.&n; *&n; * Arguments:&t;shost&t;- host that&squot;s freelist is going to be destroyed&n; */
DECL|function|scsi_destroy_command_freelist
r_void
id|scsi_destroy_command_freelist
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|shost-&gt;free_list
)paren
)paren
(brace
r_struct
id|scsi_cmnd
op_star
id|cmd
suffix:semicolon
id|cmd
op_assign
id|list_entry
c_func
(paren
id|shost-&gt;free_list.next
comma
r_struct
id|scsi_cmnd
comma
id|list
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|cmd-&gt;list
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|shost-&gt;cmd_pool-&gt;slab
comma
id|cmd
)paren
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|host_cmd_pool_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|shost-&gt;cmd_pool-&gt;users
)paren
id|kmem_cache_destroy
c_func
(paren
id|shost-&gt;cmd_pool-&gt;slab
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|host_cmd_pool_mutex
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_dispatch_command&n; *&n; * Purpose:     Dispatch a command to the low-level driver.&n; *&n; * Arguments:   cmd - command block we are dispatching.&n; *&n; * Notes:&n; */
DECL|function|scsi_dispatch_cmd
r_int
id|scsi_dispatch_cmd
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|cmd-&gt;device-&gt;host
suffix:semicolon
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
r_int
id|rtn
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Assign a unique nonzero serial_number. */
multiline_comment|/* XXX(hch): this is racy */
r_if
c_cond
(paren
op_increment
id|serial_number
op_eq
l_int|0
)paren
id|serial_number
op_assign
l_int|1
suffix:semicolon
id|cmd-&gt;serial_number
op_assign
id|serial_number
suffix:semicolon
id|cmd-&gt;pid
op_assign
id|scsi_pid
op_increment
suffix:semicolon
multiline_comment|/* &n;&t; * If SCSI-2 or lower, store the LUN value in cmnd.&n;&t; */
r_if
c_cond
(paren
id|cmd-&gt;device-&gt;scsi_level
op_le
id|SCSI_2
)paren
(brace
id|cmd-&gt;cmnd
(braket
l_int|1
)braket
op_assign
(paren
id|cmd-&gt;cmnd
(braket
l_int|1
)braket
op_amp
l_int|0x1f
)paren
op_or
(paren
id|cmd-&gt;device-&gt;lun
op_lshift
l_int|5
op_amp
l_int|0xe0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We will wait MIN_RESET_DELAY clock ticks after the last reset so&n;&t; * we can avoid the drive not being ready.&n;&t; */
id|timeout
op_assign
id|host-&gt;last_reset
op_plus
id|MIN_RESET_DELAY
suffix:semicolon
r_if
c_cond
(paren
id|host-&gt;resetting
op_logical_and
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
r_int
id|ticks_remaining
op_assign
id|timeout
op_minus
id|jiffies
suffix:semicolon
multiline_comment|/*&n;&t;&t; * NOTE: This may be executed from within an interrupt&n;&t;&t; * handler!  This is bad, but for now, it&squot;ll do.  The irq&n;&t;&t; * level of the interrupt handler has been masked out by the&n;&t;&t; * platform dependent interrupt handling code already, so the&n;&t;&t; * sti() here will not cause another call to the SCSI host&squot;s&n;&t;&t; * interrupt handler (assuming there is one irq-level per&n;&t;&t; * host).&n;&t;&t; */
r_while
c_loop
(paren
op_decrement
id|ticks_remaining
op_ge
l_int|0
)paren
id|mdelay
c_func
(paren
l_int|1
op_plus
l_int|999
op_div
id|HZ
)paren
suffix:semicolon
id|host-&gt;resetting
op_assign
l_int|0
suffix:semicolon
)brace
id|scsi_add_timer
c_func
(paren
id|cmd
comma
id|cmd-&gt;timeout_per_command
comma
id|scsi_times_out
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We will use a queued command if possible, otherwise we will&n;&t; * emulate the queuing and calling of completion function ourselves.&n;&t; */
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;scsi_dispatch_cmnd (host = %d, &quot;
l_string|&quot;channel = %d, target = %d, command = %p, &quot;
l_string|&quot;buffer = %p, &bslash;nbufflen = %d, done = %p)&bslash;n&quot;
comma
id|host-&gt;host_no
comma
id|cmd-&gt;device-&gt;channel
comma
id|cmd-&gt;device-&gt;id
comma
id|cmd-&gt;cmnd
comma
id|cmd-&gt;buffer
comma
id|cmd-&gt;bufflen
comma
id|cmd-&gt;done
)paren
)paren
suffix:semicolon
id|cmd-&gt;state
op_assign
id|SCSI_STATE_QUEUED
suffix:semicolon
id|cmd-&gt;owner
op_assign
id|SCSI_OWNER_LOWLEVEL
suffix:semicolon
multiline_comment|/*&n;&t; * Before we queue this command, check if the command&n;&t; * length exceeds what the host adapter can handle.&n;&t; */
r_if
c_cond
(paren
id|CDB_SIZE
c_func
(paren
id|cmd
)paren
OG
id|cmd-&gt;device-&gt;host-&gt;max_cmd_len
)paren
(brace
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;queuecommand : command too long.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
(paren
id|DID_ABORT
op_lshift
l_int|16
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;queuecommand : routine at %p&bslash;n&quot;
comma
id|host-&gt;hostt-&gt;queuecommand
)paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|test_bit
c_func
(paren
id|SHOST_CANCEL
comma
op_amp
id|host-&gt;shost_state
)paren
)paren
)paren
(brace
id|cmd-&gt;result
op_assign
(paren
id|DID_NO_CONNECT
op_lshift
l_int|16
)paren
suffix:semicolon
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
r_else
(brace
id|rtn
op_assign
id|host-&gt;hostt
op_member_access_from_pointer
id|queuecommand
c_func
(paren
id|cmd
comma
id|scsi_done
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
id|host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
)paren
(brace
id|scsi_queue_insert
c_func
(paren
id|cmd
comma
(paren
id|rtn
op_eq
id|SCSI_MLQUEUE_DEVICE_BUSY
)paren
ques
c_cond
id|rtn
suffix:colon
id|SCSI_MLQUEUE_HOST_BUSY
)paren
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;queuecommand : request rejected&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;leaving scsi_dispatch_cmnd()&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|rtn
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_init_cmd_from_req&n; *&n; * Purpose:     Queue a SCSI command&n; * Purpose:     Initialize a struct scsi_cmnd from a struct scsi_request&n; *&n; * Arguments:   cmd       - command descriptor.&n; *              sreq      - Request from the queue.&n; *&n; * Lock status: None needed.&n; *&n; * Returns:     Nothing.&n; *&n; * Notes:       Mainly transfer data from the request structure to the&n; *              command structure.  The request structure is allocated&n; *              using the normal memory allocator, and requests can pile&n; *              up to more or less any depth.  The command structure represents&n; *              a consumable resource, as these are allocated into a pool&n; *              when the SCSI subsystem initializes.  The preallocation is&n; *              required so that in low-memory situations a disk I/O request&n; *              won&squot;t cause the memory manager to try and write out a page.&n; *              The request structure is generally used by ioctls and character&n; *              devices.&n; */
DECL|function|scsi_init_cmd_from_req
r_void
id|scsi_init_cmd_from_req
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_struct
id|scsi_request
op_star
id|sreq
)paren
(brace
id|sreq-&gt;sr_command
op_assign
id|cmd
suffix:semicolon
id|cmd-&gt;owner
op_assign
id|SCSI_OWNER_MIDLEVEL
suffix:semicolon
id|cmd-&gt;cmd_len
op_assign
id|sreq-&gt;sr_cmd_len
suffix:semicolon
id|cmd-&gt;use_sg
op_assign
id|sreq-&gt;sr_use_sg
suffix:semicolon
id|cmd-&gt;request
op_assign
id|sreq-&gt;sr_request
suffix:semicolon
id|memcpy
c_func
(paren
id|cmd-&gt;data_cmnd
comma
id|sreq-&gt;sr_cmnd
comma
r_sizeof
(paren
id|cmd-&gt;data_cmnd
)paren
)paren
suffix:semicolon
id|cmd-&gt;serial_number
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;serial_number_at_timeout
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;bufflen
op_assign
id|sreq-&gt;sr_bufflen
suffix:semicolon
id|cmd-&gt;buffer
op_assign
id|sreq-&gt;sr_buffer
suffix:semicolon
id|cmd-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;retries
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;allowed
op_assign
id|sreq-&gt;sr_allowed
suffix:semicolon
id|cmd-&gt;done
op_assign
id|sreq-&gt;sr_done
suffix:semicolon
id|cmd-&gt;timeout_per_command
op_assign
id|sreq-&gt;sr_timeout_per_command
suffix:semicolon
id|cmd-&gt;sc_data_direction
op_assign
id|sreq-&gt;sr_data_direction
suffix:semicolon
id|cmd-&gt;sglist_len
op_assign
id|sreq-&gt;sr_sglist_len
suffix:semicolon
id|cmd-&gt;underflow
op_assign
id|sreq-&gt;sr_underflow
suffix:semicolon
id|cmd-&gt;sc_request
op_assign
id|sreq
suffix:semicolon
id|memcpy
c_func
(paren
id|cmd-&gt;cmnd
comma
id|sreq-&gt;sr_cmnd
comma
r_sizeof
(paren
id|sreq-&gt;sr_cmnd
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Zero the sense buffer.  Some host adapters automatically request&n;&t; * sense on error.  0 is not a valid sense code.&n;&t; */
id|memset
c_func
(paren
id|cmd-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
(paren
id|sreq-&gt;sr_sense_buffer
)paren
)paren
suffix:semicolon
id|cmd-&gt;request_buffer
op_assign
id|sreq-&gt;sr_buffer
suffix:semicolon
id|cmd-&gt;request_bufflen
op_assign
id|sreq-&gt;sr_bufflen
suffix:semicolon
id|cmd-&gt;old_use_sg
op_assign
id|cmd-&gt;use_sg
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;cmd_len
op_eq
l_int|0
)paren
id|cmd-&gt;cmd_len
op_assign
id|COMMAND_SIZE
c_func
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|cmd-&gt;old_cmd_len
op_assign
id|cmd-&gt;cmd_len
suffix:semicolon
id|cmd-&gt;sc_old_data_direction
op_assign
id|cmd-&gt;sc_data_direction
suffix:semicolon
id|cmd-&gt;old_underflow
op_assign
id|cmd-&gt;underflow
suffix:semicolon
multiline_comment|/*&n;&t; * Start the timer ticking.&n;&t; */
id|cmd-&gt;internal_timeout
op_assign
id|NORMAL_TIMEOUT
suffix:semicolon
id|cmd-&gt;abort_reason
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;result
op_assign
l_int|0
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Leaving scsi_init_cmd_from_req()&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Per-CPU I/O completion queue.&n; */
DECL|variable|__cacheline_aligned
r_static
r_struct
id|list_head
id|done_q
(braket
id|NR_CPUS
)braket
id|__cacheline_aligned
suffix:semicolon
multiline_comment|/**&n; * scsi_done - Enqueue the finished SCSI command into the done queue.&n; * @cmd: The SCSI Command for which a low-level device driver (LLDD) gives&n; * ownership back to SCSI Core -- i.e. the LLDD has finished with it.&n; *&n; * This function is the mid-level&squot;s (SCSI Core) interrupt routine, which&n; * regains ownership of the SCSI command (de facto) from a LLDD, and enqueues&n; * the command to the done queue for further processing.&n; *&n; * This is the producer of the done queue who enqueues at the tail.&n; *&n; * This function is interrupt context safe.&n; */
DECL|function|scsi_done
r_void
id|scsi_done
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|cpu
suffix:semicolon
multiline_comment|/*&n;&t; * We don&squot;t have to worry about this one timing out any more.&n;&t; * If we are unable to remove the timer, then the command&n;&t; * has already timed out.  In which case, we have no choice but to&n;&t; * let the timeout function run, as we have no idea where in fact&n;&t; * that function could really be.  It might be on another processor,&n;&t; * etc, etc.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|scsi_delete_timer
c_func
(paren
id|cmd
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Set the serial numbers back to zero&n;&t; */
id|cmd-&gt;serial_number
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;serial_number_at_timeout
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;state
op_assign
id|SCSI_STATE_BHQUEUE
suffix:semicolon
id|cmd-&gt;owner
op_assign
id|SCSI_OWNER_BH_HANDLER
suffix:semicolon
multiline_comment|/*&n;&t; * Next, enqueue the command into the done queue.&n;&t; * It is a per-CPU queue, so we just disable local interrupts&n;&t; * and need no spinlock.&n;&t; */
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|cmd-&gt;eh_entry
comma
op_amp
id|done_q
(braket
id|cpu
)braket
)paren
suffix:semicolon
id|raise_softirq_irqoff
c_func
(paren
id|SCSI_SOFTIRQ
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_softirq - Perform post-interrupt processing of finished SCSI commands.&n; *&n; * This is the consumer of the done queue.&n; *&n; * This is called with all interrupts enabled.  This should reduce&n; * interrupt latency, stack depth, and reentrancy of the low-level&n; * drivers.&n; */
DECL|function|scsi_softirq
r_static
r_void
id|scsi_softirq
c_func
(paren
r_struct
id|softirq_action
op_star
id|h
)paren
(brace
id|LIST_HEAD
c_func
(paren
id|local_q
)paren
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|list_splice_init
c_func
(paren
op_amp
id|done_q
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
comma
op_amp
id|local_q
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|local_q
)paren
)paren
(brace
r_struct
id|scsi_cmnd
op_star
id|cmd
op_assign
id|list_entry
c_func
(paren
id|local_q.next
comma
r_struct
id|scsi_cmnd
comma
id|eh_entry
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|cmd-&gt;eh_entry
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|scsi_decide_disposition
c_func
(paren
id|cmd
)paren
)paren
(brace
r_case
id|SUCCESS
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Add to BH queue.&n;&t;&t;&t; */
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Command finished %d %d &quot;
l_string|&quot;0x%x&bslash;n&quot;
comma
id|cmd-&gt;device-&gt;host-&gt;host_busy
comma
id|cmd-&gt;device-&gt;host-&gt;host_failed
comma
id|cmd-&gt;result
)paren
)paren
suffix:semicolon
id|scsi_finish_command
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NEEDS_RETRY
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * We only come in here if we want to retry a&n;&t;&t;&t; * command.  The test to see whether the&n;&t;&t;&t; * command should be retried should be keeping&n;&t;&t;&t; * track of the number of tries, so we don&squot;t&n;&t;&t;&t; * end up looping, of course.&n;&t;&t;&t; */
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Command needs retry &quot;
l_string|&quot;%d %d 0x%x&bslash;n&quot;
comma
id|cmd-&gt;device-&gt;host-&gt;host_busy
comma
id|cmd-&gt;device-&gt;host-&gt;host_failed
comma
id|cmd-&gt;result
)paren
)paren
suffix:semicolon
id|scsi_retry_command
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ADD_TO_MLQUEUE
suffix:colon
multiline_comment|/* &n;&t;&t;&t; * This typically happens for a QUEUE_FULL&n;&t;&t;&t; * message - typically only when the queue&n;&t;&t;&t; * depth is only approximate for a given&n;&t;&t;&t; * device.  Adding a command to the queue for&n;&t;&t;&t; * the device will prevent further commands&n;&t;&t;&t; * from being sent to the device, so we&n;&t;&t;&t; * shouldn&squot;t end up with tons of things being&n;&t;&t;&t; * sent down that shouldn&squot;t be.&n;&t;&t;&t; */
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Command rejected as &quot;
l_string|&quot;device queue full, &quot;
l_string|&quot;put on ml queue %p&bslash;n&quot;
comma
id|cmd
)paren
)paren
suffix:semicolon
id|scsi_queue_insert
c_func
(paren
id|cmd
comma
id|SCSI_MLQUEUE_DEVICE_BUSY
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Here we have a fatal error of some sort.&n;&t;&t;&t; * Turn it over to the error handler.&n;&t;&t;&t; */
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Command failed %p %x &quot;
l_string|&quot;busy=%d failed=%d&bslash;n&quot;
comma
id|cmd
comma
id|cmd-&gt;result
comma
id|cmd-&gt;device-&gt;host-&gt;host_busy
comma
id|cmd-&gt;device-&gt;host-&gt;host_failed
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Dump the sense information too.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|status_byte
c_func
(paren
id|cmd-&gt;result
)paren
op_amp
id|CHECK_CONDITION
)paren
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|3
comma
id|print_sense
c_func
(paren
l_string|&quot;bh&quot;
comma
id|cmd
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We only fail here if the error recovery thread&n;&t;&t;&t; * has died.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|scsi_eh_scmd_add
c_func
(paren
id|cmd
comma
l_int|0
)paren
)paren
id|scsi_finish_command
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Function:    scsi_retry_command&n; *&n; * Purpose:     Send a command back to the low level to be retried.&n; *&n; * Notes:       This command is always executed in the context of the&n; *              bottom half handler, or the error handler thread. Low&n; *              level drivers should not become re-entrant as a result of&n; *              this.&n; */
DECL|function|scsi_retry_command
r_int
id|scsi_retry_command
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
multiline_comment|/*&n;&t; * Restore the SCSI command state.&n;&t; */
id|scsi_setup_cmd_retry
c_func
(paren
id|cmd
)paren
suffix:semicolon
multiline_comment|/*&n;         * Zero the sense information from the last time we tried&n;         * this command.&n;         */
id|memset
c_func
(paren
id|cmd-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
)paren
suffix:semicolon
r_return
id|scsi_dispatch_cmd
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_finish_command&n; *&n; * Purpose:     Pass command off to upper layer for finishing of I/O&n; *              request, waking processes that are waiting on results,&n; *              etc.&n; */
DECL|function|scsi_finish_command
r_void
id|scsi_finish_command
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
op_assign
id|cmd-&gt;device
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shost
op_assign
id|sdev-&gt;host
suffix:semicolon
r_struct
id|scsi_request
op_star
id|sreq
suffix:semicolon
id|scsi_device_unbusy
c_func
(paren
id|sdev
)paren
suffix:semicolon
multiline_comment|/*&n;         * Clear the flags which say that the device/host is no longer&n;         * capable of accepting new commands.  These are set in scsi_queue.c&n;         * for both the queue full condition on a device, and for a&n;         * host full condition on the host.&n;&t; *&n;&t; * XXX(hch): What about locking?&n;         */
id|shost-&gt;host_blocked
op_assign
l_int|0
suffix:semicolon
id|sdev-&gt;device_blocked
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If we have valid sense information, then some kind of recovery&n;&t; * must have taken place.  Make a note of this.&n;&t; */
r_if
c_cond
(paren
id|SCSI_SENSE_VALID
c_func
(paren
id|cmd
)paren
)paren
id|cmd-&gt;result
op_or_assign
(paren
id|DRIVER_SENSE
op_lshift
l_int|24
)paren
suffix:semicolon
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Notifying upper driver of completion &quot;
l_string|&quot;for device %d %x&bslash;n&quot;
comma
id|sdev-&gt;id
comma
id|cmd-&gt;result
)paren
)paren
suffix:semicolon
id|cmd-&gt;owner
op_assign
id|SCSI_OWNER_HIGHLEVEL
suffix:semicolon
id|cmd-&gt;state
op_assign
id|SCSI_STATE_FINISHED
suffix:semicolon
multiline_comment|/*&n;&t; * We can get here with use_sg=0, causing a panic in the upper level&n;&t; */
id|cmd-&gt;use_sg
op_assign
id|cmd-&gt;old_use_sg
suffix:semicolon
multiline_comment|/*&n;&t; * If there is an associated request structure, copy the data over&n;&t; * before we call the completion function.&n;&t; */
id|sreq
op_assign
id|cmd-&gt;sc_request
suffix:semicolon
r_if
c_cond
(paren
id|sreq
)paren
(brace
id|sreq-&gt;sr_result
op_assign
id|sreq-&gt;sr_command-&gt;result
suffix:semicolon
r_if
c_cond
(paren
id|sreq-&gt;sr_result
)paren
(brace
id|memcpy
c_func
(paren
id|sreq-&gt;sr_sense_buffer
comma
id|sreq-&gt;sr_command-&gt;sense_buffer
comma
r_sizeof
(paren
id|sreq-&gt;sr_sense_buffer
)paren
)paren
suffix:semicolon
)brace
)brace
id|cmd
op_member_access_from_pointer
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:&t;scsi_adjust_queue_depth()&n; *&n; * Purpose:&t;Allow low level drivers to tell us to change the queue depth&n; * &t;&t;on a specific SCSI device&n; *&n; * Arguments:&t;sdev&t;- SCSI Device in question&n; * &t;&t;tagged&t;- Do we use tagged queueing (non-0) or do we treat&n; * &t;&t;&t;  this device as an untagged device (0)&n; * &t;&t;tags&t;- Number of tags allowed if tagged queueing enabled,&n; * &t;&t;&t;  or number of commands the low level driver can&n; * &t;&t;&t;  queue up in non-tagged mode (as per cmd_per_lun).&n; *&n; * Returns:&t;Nothing&n; *&n; * Lock Status:&t;None held on entry&n; *&n; * Notes:&t;Low level drivers may call this at any time and we will do&n; * &t;&t;the right thing depending on whether or not the device is&n; * &t;&t;currently active and whether or not it even has the&n; * &t;&t;command blocks built yet.&n; *&n; * XXX(hch):&t;What exactly is device_request_lock trying to protect?&n; */
DECL|function|scsi_adjust_queue_depth
r_void
id|scsi_adjust_queue_depth
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
comma
r_int
id|tagged
comma
r_int
id|tags
)paren
(brace
r_static
id|spinlock_t
id|device_request_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * refuse to set tagged depth to an unworkable size&n;&t; */
r_if
c_cond
(paren
id|tags
op_le
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Limit max queue depth on a single lun to 256 for now.  Remember,&n;&t; * we allocate a struct scsi_command for each of these and keep it&n;&t; * around forever.  Too deep of a depth just wastes memory.&n;&t; */
r_if
c_cond
(paren
id|tags
OG
l_int|256
)paren
r_return
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
id|sdev-&gt;queue_depth
op_assign
id|tags
suffix:semicolon
r_switch
c_cond
(paren
id|tagged
)paren
(brace
r_case
id|MSG_ORDERED_TAG
suffix:colon
id|sdev-&gt;ordered_tags
op_assign
l_int|1
suffix:semicolon
id|sdev-&gt;simple_tags
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MSG_SIMPLE_TAG
suffix:colon
id|sdev-&gt;ordered_tags
op_assign
l_int|0
suffix:semicolon
id|sdev-&gt;simple_tags
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;(scsi%d:%d:%d:%d) &quot;
l_string|&quot;scsi_adjust_queue_depth, bad queue type, &quot;
l_string|&quot;disabled&bslash;n&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
)paren
suffix:semicolon
r_case
l_int|0
suffix:colon
id|sdev-&gt;ordered_tags
op_assign
id|sdev-&gt;simple_tags
op_assign
l_int|0
suffix:semicolon
id|sdev-&gt;queue_depth
op_assign
id|tags
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:&t;scsi_track_queue_full()&n; *&n; * Purpose:&t;This function will track successive QUEUE_FULL events on a&n; * &t;&t;specific SCSI device to determine if and when there is a&n; * &t;&t;need to adjust the queue depth on the device.&n; *&n; * Arguments:&t;sdev&t;- SCSI Device in question&n; * &t;&t;depth&t;- Current number of outstanding SCSI commands on&n; * &t;&t;&t;  this device, not counting the one returned as&n; * &t;&t;&t;  QUEUE_FULL.&n; *&n; * Returns:&t;0 - No change needed&n; * &t;&t;&gt;0 - Adjust queue depth to this new depth&n; * &t;&t;-1 - Drop back to untagged operation using host-&gt;cmd_per_lun&n; * &t;&t;&t;as the untagged command depth&n; *&n; * Lock Status:&t;None held on entry&n; *&n; * Notes:&t;Low level drivers may call this at any time and we will do&n; * &t;&t;&quot;The Right Thing.&quot;  We are interrupt context safe.&n; */
DECL|function|scsi_track_queue_full
r_int
id|scsi_track_queue_full
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
comma
r_int
id|depth
)paren
(brace
r_if
c_cond
(paren
(paren
id|jiffies
op_rshift
l_int|4
)paren
op_eq
id|sdev-&gt;last_queue_full_time
)paren
r_return
l_int|0
suffix:semicolon
id|sdev-&gt;last_queue_full_time
op_assign
(paren
id|jiffies
op_rshift
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;last_queue_full_depth
op_ne
id|depth
)paren
(brace
id|sdev-&gt;last_queue_full_count
op_assign
l_int|1
suffix:semicolon
id|sdev-&gt;last_queue_full_depth
op_assign
id|depth
suffix:semicolon
)brace
r_else
(brace
id|sdev-&gt;last_queue_full_count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sdev-&gt;last_queue_full_count
op_le
l_int|10
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;last_queue_full_depth
OL
l_int|8
)paren
(brace
multiline_comment|/* Drop back to untagged */
id|scsi_adjust_queue_depth
c_func
(paren
id|sdev
comma
l_int|0
comma
id|sdev-&gt;host-&gt;cmd_per_lun
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sdev-&gt;ordered_tags
)paren
id|scsi_adjust_queue_depth
c_func
(paren
id|sdev
comma
id|MSG_ORDERED_TAG
comma
id|depth
)paren
suffix:semicolon
r_else
id|scsi_adjust_queue_depth
c_func
(paren
id|sdev
comma
id|MSG_SIMPLE_TAG
comma
id|depth
)paren
suffix:semicolon
r_return
id|depth
suffix:semicolon
)brace
DECL|function|scsi_device_get
r_int
id|scsi_device_get
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
)paren
(brace
r_struct
r_class
op_star
r_class
op_assign
id|class_get
c_func
(paren
op_amp
id|sdev_class
)paren
suffix:semicolon
r_int
id|error
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
r_class
)paren
(brace
id|down_write
c_func
(paren
op_amp
r_class
op_member_access_from_pointer
id|subsys.rwsem
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|SDEV_DEL
comma
op_amp
id|sdev-&gt;sdev_state
)paren
)paren
r_if
c_cond
(paren
id|try_module_get
c_func
(paren
id|sdev-&gt;host-&gt;hostt-&gt;module
)paren
)paren
r_if
c_cond
(paren
id|get_device
c_func
(paren
op_amp
id|sdev-&gt;sdev_gendev
)paren
)paren
(brace
id|sdev-&gt;access_count
op_increment
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
)brace
id|up_write
c_func
(paren
op_amp
r_class
op_member_access_from_pointer
id|subsys.rwsem
)paren
suffix:semicolon
id|class_put
c_func
(paren
op_amp
id|sdev_class
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
DECL|function|scsi_device_put
r_void
id|scsi_device_put
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
)paren
(brace
r_struct
r_class
op_star
r_class
op_assign
id|class_get
c_func
(paren
op_amp
id|sdev_class
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_class
)paren
r_return
suffix:semicolon
id|down_write
c_func
(paren
op_amp
r_class
op_member_access_from_pointer
id|subsys.rwsem
)paren
suffix:semicolon
id|module_put
c_func
(paren
id|sdev-&gt;host-&gt;hostt-&gt;module
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|sdev-&gt;access_count
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|SDEV_DEL
comma
op_amp
id|sdev-&gt;sdev_state
)paren
)paren
id|device_del
c_func
(paren
op_amp
id|sdev-&gt;sdev_gendev
)paren
suffix:semicolon
)brace
id|put_device
c_func
(paren
op_amp
id|sdev-&gt;sdev_gendev
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
r_class
op_member_access_from_pointer
id|subsys.rwsem
)paren
suffix:semicolon
id|class_put
c_func
(paren
op_amp
id|sdev_class
)paren
suffix:semicolon
)brace
DECL|function|scsi_device_cancel_cb
r_int
id|scsi_device_cancel_cb
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
op_assign
id|to_scsi_device
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
id|recovery
op_assign
op_star
(paren
r_int
op_star
)paren
id|data
suffix:semicolon
r_return
id|scsi_device_cancel
c_func
(paren
id|sdev
comma
id|recovery
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_device_cancel - cancel outstanding IO to this device&n; * @sdev:&t;pointer to struct scsi_device&n; * @data:&t;pointer to cancel value.&n; *&n; **/
DECL|function|scsi_device_cancel
r_int
id|scsi_device_cancel
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
comma
r_int
id|recovery
)paren
(brace
r_struct
id|scsi_cmnd
op_star
id|scmd
suffix:semicolon
id|LIST_HEAD
c_func
(paren
id|active_list
)paren
suffix:semicolon
r_struct
id|list_head
op_star
id|lh
comma
op_star
id|lh_sf
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|set_bit
c_func
(paren
id|SDEV_CANCEL
comma
op_amp
id|sdev-&gt;sdev_state
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sdev-&gt;list_lock
comma
id|flags
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|scmd
comma
op_amp
id|sdev-&gt;cmd_list
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|scmd-&gt;request
op_logical_and
id|scmd-&gt;request-&gt;rq_status
op_ne
id|RQ_INACTIVE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If we are unable to remove the timer, it means&n;&t;&t;&t; * that the command has already timed out or&n;&t;&t;&t; * finished.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|scsi_delete_timer
c_func
(paren
id|scmd
)paren
)paren
r_continue
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|scmd-&gt;eh_entry
comma
op_amp
id|active_list
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sdev-&gt;list_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|active_list
)paren
)paren
(brace
id|list_for_each_safe
c_func
(paren
id|lh
comma
id|lh_sf
comma
op_amp
id|active_list
)paren
(brace
id|scmd
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|scsi_cmnd
comma
id|eh_entry
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
id|lh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|recovery
)paren
(brace
id|scsi_eh_scmd_add
c_func
(paren
id|scmd
comma
id|SCSI_EH_CANCEL_CMD
)paren
suffix:semicolon
)brace
r_else
(brace
id|scmd-&gt;result
op_assign
(paren
id|DID_ABORT
op_lshift
l_int|16
)paren
suffix:semicolon
id|scsi_finish_command
c_func
(paren
id|scmd
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;SCSI core&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|scsi_logging_level
comma
r_int
comma
id|S_IRUGO
op_or
id|S_IWUSR
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|scsi_logging_level
comma
l_string|&quot;a bit mask of logging levels&quot;
)paren
suffix:semicolon
DECL|function|init_scsi
r_static
r_int
id|__init
id|init_scsi
c_func
(paren
r_void
)paren
(brace
r_int
id|error
comma
id|i
suffix:semicolon
id|error
op_assign
id|scsi_init_queue
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|error
op_assign
id|scsi_init_procfs
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|cleanup_queue
suffix:semicolon
id|error
op_assign
id|scsi_init_devinfo
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|cleanup_procfs
suffix:semicolon
id|error
op_assign
id|scsi_sysfs_register
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|cleanup_devlist
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|done_q
(braket
id|i
)braket
)paren
suffix:semicolon
id|devfs_mk_dir
c_func
(paren
l_string|&quot;scsi&quot;
)paren
suffix:semicolon
id|open_softirq
c_func
(paren
id|SCSI_SOFTIRQ
comma
id|scsi_softirq
comma
l_int|NULL
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;SCSI subsystem initialized&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|cleanup_devlist
suffix:colon
id|scsi_exit_devinfo
c_func
(paren
)paren
suffix:semicolon
id|cleanup_procfs
suffix:colon
id|scsi_exit_procfs
c_func
(paren
)paren
suffix:semicolon
id|cleanup_queue
suffix:colon
id|scsi_exit_queue
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;SCSI subsystem failed to initialize, error = %d&bslash;n&quot;
comma
op_minus
id|error
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|exit_scsi
r_static
r_void
id|__exit
id|exit_scsi
c_func
(paren
r_void
)paren
(brace
id|scsi_sysfs_unregister
c_func
(paren
)paren
suffix:semicolon
id|scsi_exit_devinfo
c_func
(paren
)paren
suffix:semicolon
id|devfs_remove
c_func
(paren
l_string|&quot;scsi&quot;
)paren
suffix:semicolon
id|scsi_exit_procfs
c_func
(paren
)paren
suffix:semicolon
id|scsi_exit_queue
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|init_scsi
id|subsys_initcall
c_func
(paren
id|init_scsi
)paren
suffix:semicolon
DECL|variable|exit_scsi
id|module_exit
c_func
(paren
id|exit_scsi
)paren
suffix:semicolon
eof
