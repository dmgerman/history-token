multiline_comment|/*&n; *  scsi.c Copyright (C) 1992 Drew Eckhardt&n; *         Copyright (C) 1993, 1994, 1995, 1999 Eric Youngdale&n; *         Copyright (C) 2002, 2003 Christoph Hellwig&n; *&n; *  generic mid-level SCSI driver&n; *      Initial versions: Drew Eckhardt&n; *      Subsequent revisions: Eric Youngdale&n; *&n; *  &lt;drew@colorado.edu&gt;&n; *&n; *  Bug correction thanks go to :&n; *      Rik Faith &lt;faith@cs.unc.edu&gt;&n; *      Tommy Thorn &lt;tthorn&gt;&n; *      Thomas Wuensche &lt;tw@fgb1.fgb.mw.tu-muenchen.de&gt;&n; *&n; *  Modified by Eric Youngdale eric@andante.org or ericy@gnu.ai.mit.edu to&n; *  add scatter-gather, multiple outstanding request, and other&n; *  enhancements.&n; *&n; *  Native multichannel, wide scsi, /proc/scsi and hot plugging&n; *  support added by Michael Neuffer &lt;mike@i-connect.net&gt;&n; *&n; *  Added request_module(&quot;scsi_hostadapter&quot;) for kerneld:&n; *  (Put an &quot;alias scsi_hostadapter your_hostadapter&quot; in /etc/modprobe.conf)&n; *  Bjorn Ekwall  &lt;bj0rn@blox.se&gt;&n; *  (changed to kmod)&n; *&n; *  Major improvements to the timeout, abort, and reset processing,&n; *  as well as performance modifications for large queue depths by&n; *  Leonard N. Zubkoff &lt;lnz@dandelion.com&gt;&n; *&n; *  Converted cli() code to spinlocks, Ingo Molnar&n; *&n; *  Jiffies wrap fixes (host-&gt;resetting), 3 Dec 1998 Andrea Arcangeli&n; *&n; *  out_of_space hacks, D. Gilbert (dpg) 990608&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/moduleparam.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/completion.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;linux/cpu.h&gt;
macro_line|#include &lt;scsi/scsi.h&gt;
macro_line|#include &lt;scsi/scsi_cmnd.h&gt;
macro_line|#include &lt;scsi/scsi_dbg.h&gt;
macro_line|#include &lt;scsi/scsi_device.h&gt;
macro_line|#include &lt;scsi/scsi_eh.h&gt;
macro_line|#include &lt;scsi/scsi_host.h&gt;
macro_line|#include &lt;scsi/scsi_tcq.h&gt;
macro_line|#include &lt;scsi/scsi_request.h&gt;
macro_line|#include &quot;scsi_priv.h&quot;
macro_line|#include &quot;scsi_logging.h&quot;
multiline_comment|/*&n; * Definitions and constants.&n; */
DECL|macro|MIN_RESET_DELAY
mdefine_line|#define MIN_RESET_DELAY (2*HZ)
multiline_comment|/* Do not call reset on error if we just did a reset within 15 sec. */
DECL|macro|MIN_RESET_PERIOD
mdefine_line|#define MIN_RESET_PERIOD (15*HZ)
multiline_comment|/*&n; * Macro to determine the size of SCSI command. This macro takes vendor&n; * unique commands into account. SCSI commands in groups 6 and 7 are&n; * vendor unique and we will depend upon the command length being&n; * supplied correctly in cmd_len.&n; */
DECL|macro|CDB_SIZE
mdefine_line|#define CDB_SIZE(cmd)&t;(((((cmd)-&gt;cmnd[0] &gt;&gt; 5) &amp; 7) &lt; 6) ? &bslash;&n;&t;&t;&t;&t;COMMAND_SIZE((cmd)-&gt;cmnd[0]) : (cmd)-&gt;cmd_len)
multiline_comment|/*&n; * Data declarations.&n; */
DECL|variable|scsi_pid
r_int
r_int
id|scsi_pid
suffix:semicolon
DECL|variable|serial_number
r_static
r_int
r_int
id|serial_number
suffix:semicolon
multiline_comment|/*&n; * Note - the initial logging level can be set here to log events at boot time.&n; * After the system is up, you may enable logging via the /proc interface.&n; */
DECL|variable|scsi_logging_level
r_int
r_int
id|scsi_logging_level
suffix:semicolon
macro_line|#if defined(CONFIG_SCSI_LOGGING)
DECL|variable|scsi_logging_level
id|EXPORT_SYMBOL
c_func
(paren
id|scsi_logging_level
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|scsi_device_types
r_const
r_char
op_star
r_const
id|scsi_device_types
(braket
id|MAX_SCSI_DEVICE_CODE
)braket
op_assign
(brace
l_string|&quot;Direct-Access    &quot;
comma
l_string|&quot;Sequential-Access&quot;
comma
l_string|&quot;Printer          &quot;
comma
l_string|&quot;Processor        &quot;
comma
l_string|&quot;WORM             &quot;
comma
l_string|&quot;CD-ROM           &quot;
comma
l_string|&quot;Scanner          &quot;
comma
l_string|&quot;Optical Device   &quot;
comma
l_string|&quot;Medium Changer   &quot;
comma
l_string|&quot;Communications   &quot;
comma
l_string|&quot;Unknown          &quot;
comma
l_string|&quot;Unknown          &quot;
comma
l_string|&quot;RAID             &quot;
comma
l_string|&quot;Enclosure        &quot;
comma
)brace
suffix:semicolon
DECL|variable|scsi_device_types
id|EXPORT_SYMBOL
c_func
(paren
id|scsi_device_types
)paren
suffix:semicolon
multiline_comment|/*&n; * Function:    scsi_allocate_request&n; *&n; * Purpose:     Allocate a request descriptor.&n; *&n; * Arguments:   device&t;&t;- device for which we want a request&n; *&t;&t;gfp_mask&t;- allocation flags passed to kmalloc&n; *&n; * Lock status: No locks assumed to be held.  This function is SMP-safe.&n; *&n; * Returns:     Pointer to request block.&n; */
DECL|function|scsi_allocate_request
r_struct
id|scsi_request
op_star
id|scsi_allocate_request
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
comma
r_int
id|gfp_mask
)paren
(brace
r_const
r_int
id|offset
op_assign
id|ALIGN
c_func
(paren
r_sizeof
(paren
r_struct
id|scsi_request
)paren
comma
l_int|4
)paren
suffix:semicolon
r_const
r_int
id|size
op_assign
id|offset
op_plus
r_sizeof
(paren
r_struct
id|request
)paren
suffix:semicolon
r_struct
id|scsi_request
op_star
id|sreq
suffix:semicolon
id|sreq
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|sreq
op_ne
l_int|NULL
)paren
)paren
(brace
id|memset
c_func
(paren
id|sreq
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
id|sreq-&gt;sr_request
op_assign
(paren
r_struct
id|request
op_star
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|sreq
)paren
op_plus
id|offset
)paren
suffix:semicolon
id|sreq-&gt;sr_device
op_assign
id|sdev
suffix:semicolon
id|sreq-&gt;sr_host
op_assign
id|sdev-&gt;host
suffix:semicolon
id|sreq-&gt;sr_magic
op_assign
id|SCSI_REQ_MAGIC
suffix:semicolon
id|sreq-&gt;sr_data_direction
op_assign
id|DMA_BIDIRECTIONAL
suffix:semicolon
)brace
r_return
id|sreq
suffix:semicolon
)brace
DECL|variable|scsi_allocate_request
id|EXPORT_SYMBOL
c_func
(paren
id|scsi_allocate_request
)paren
suffix:semicolon
DECL|function|__scsi_release_request
r_void
id|__scsi_release_request
c_func
(paren
r_struct
id|scsi_request
op_star
id|sreq
)paren
(brace
r_struct
id|request
op_star
id|req
op_assign
id|sreq-&gt;sr_request
suffix:semicolon
multiline_comment|/* unlikely because the tag was usually ended earlier by the&n;&t; * mid-layer. However, for layering reasons ULD&squot;s don&squot;t end&n;&t; * the tag of commands they generate. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|blk_rq_tagged
c_func
(paren
id|req
)paren
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|request_queue
op_star
id|q
op_assign
id|req-&gt;q
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|q-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
id|blk_queue_end_tag
c_func
(paren
id|q
comma
id|req
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|q-&gt;queue_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|sreq-&gt;sr_command
op_ne
l_int|NULL
)paren
)paren
(brace
r_struct
id|scsi_cmnd
op_star
id|cmd
op_assign
id|sreq-&gt;sr_command
suffix:semicolon
id|sreq-&gt;sr_command
op_assign
l_int|NULL
suffix:semicolon
id|scsi_next_command
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Function:    scsi_release_request&n; *&n; * Purpose:     Release a request descriptor.&n; *&n; * Arguments:   sreq    - request to release&n; *&n; * Lock status: No locks assumed to be held.  This function is SMP-safe.&n; */
DECL|function|scsi_release_request
r_void
id|scsi_release_request
c_func
(paren
r_struct
id|scsi_request
op_star
id|sreq
)paren
(brace
id|__scsi_release_request
c_func
(paren
id|sreq
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sreq
)paren
suffix:semicolon
)brace
DECL|variable|scsi_release_request
id|EXPORT_SYMBOL
c_func
(paren
id|scsi_release_request
)paren
suffix:semicolon
DECL|struct|scsi_host_cmd_pool
r_struct
id|scsi_host_cmd_pool
(brace
DECL|member|slab
id|kmem_cache_t
op_star
id|slab
suffix:semicolon
DECL|member|users
r_int
r_int
id|users
suffix:semicolon
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|slab_flags
r_int
r_int
id|slab_flags
suffix:semicolon
DECL|member|gfp_mask
r_int
r_int
id|gfp_mask
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|scsi_cmd_pool
r_static
r_struct
id|scsi_host_cmd_pool
id|scsi_cmd_pool
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;scsi_cmd_cache&quot;
comma
dot
id|slab_flags
op_assign
id|SLAB_HWCACHE_ALIGN
comma
)brace
suffix:semicolon
DECL|variable|scsi_cmd_dma_pool
r_static
r_struct
id|scsi_host_cmd_pool
id|scsi_cmd_dma_pool
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;scsi_cmd_cache(DMA)&quot;
comma
dot
id|slab_flags
op_assign
id|SLAB_HWCACHE_ALIGN
op_or
id|SLAB_CACHE_DMA
comma
dot
id|gfp_mask
op_assign
id|__GFP_DMA
comma
)brace
suffix:semicolon
r_static
id|DECLARE_MUTEX
c_func
(paren
id|host_cmd_pool_mutex
)paren
suffix:semicolon
DECL|function|__scsi_get_command
r_static
r_struct
id|scsi_cmnd
op_star
id|__scsi_get_command
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
comma
r_int
id|gfp_mask
)paren
(brace
r_struct
id|scsi_cmnd
op_star
id|cmd
suffix:semicolon
id|cmd
op_assign
id|kmem_cache_alloc
c_func
(paren
id|shost-&gt;cmd_pool-&gt;slab
comma
id|gfp_mask
op_or
id|shost-&gt;cmd_pool-&gt;gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|cmd
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|shost-&gt;free_list_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|shost-&gt;free_list
)paren
)paren
)paren
(brace
id|cmd
op_assign
id|list_entry
c_func
(paren
id|shost-&gt;free_list.next
comma
r_struct
id|scsi_cmnd
comma
id|list
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|cmd-&gt;list
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|shost-&gt;free_list_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|cmd
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:&t;scsi_get_command()&n; *&n; * Purpose:&t;Allocate and setup a scsi command block&n; *&n; * Arguments:&t;dev&t;- parent scsi device&n; *&t;&t;gfp_mask- allocator flags&n; *&n; * Returns:&t;The allocated scsi command structure.&n; */
DECL|function|scsi_get_command
r_struct
id|scsi_cmnd
op_star
id|scsi_get_command
c_func
(paren
r_struct
id|scsi_device
op_star
id|dev
comma
r_int
id|gfp_mask
)paren
(brace
r_struct
id|scsi_cmnd
op_star
id|cmd
suffix:semicolon
multiline_comment|/* Bail if we can&squot;t get a reference to the device */
r_if
c_cond
(paren
op_logical_neg
id|get_device
c_func
(paren
op_amp
id|dev-&gt;sdev_gendev
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|cmd
op_assign
id|__scsi_get_command
c_func
(paren
id|dev-&gt;host
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|cmd
op_ne
l_int|NULL
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|memset
c_func
(paren
id|cmd
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|cmd
)paren
)paren
suffix:semicolon
id|cmd-&gt;device
op_assign
id|dev
suffix:semicolon
id|cmd-&gt;state
op_assign
id|SCSI_STATE_UNUSED
suffix:semicolon
id|cmd-&gt;owner
op_assign
id|SCSI_OWNER_NOBODY
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|cmd-&gt;eh_timeout
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|cmd-&gt;list
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|dev-&gt;list_lock
comma
id|flags
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|cmd-&gt;list
comma
op_amp
id|dev-&gt;cmd_list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|dev-&gt;list_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
id|put_device
c_func
(paren
op_amp
id|dev-&gt;sdev_gendev
)paren
suffix:semicolon
r_return
id|cmd
suffix:semicolon
)brace
DECL|variable|scsi_get_command
id|EXPORT_SYMBOL
c_func
(paren
id|scsi_get_command
)paren
suffix:semicolon
multiline_comment|/*&n; * Function:&t;scsi_put_command()&n; *&n; * Purpose:&t;Free a scsi command block&n; *&n; * Arguments:&t;cmd&t;- command block to free&n; *&n; * Returns:&t;Nothing.&n; *&n; * Notes:&t;The command must not belong to any lists.&n; */
DECL|function|scsi_put_command
r_void
id|scsi_put_command
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
op_assign
id|cmd-&gt;device
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shost
op_assign
id|sdev-&gt;host
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* serious error if the command hasn&squot;t come from a device list */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|cmd-&gt;device-&gt;list_lock
comma
id|flags
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|list_empty
c_func
(paren
op_amp
id|cmd-&gt;list
)paren
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|cmd-&gt;list
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|cmd-&gt;device-&gt;list_lock
)paren
suffix:semicolon
multiline_comment|/* changing locks here, don&squot;t need to restore the irq state */
id|spin_lock
c_func
(paren
op_amp
id|shost-&gt;free_list_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|list_empty
c_func
(paren
op_amp
id|shost-&gt;free_list
)paren
)paren
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|cmd-&gt;list
comma
op_amp
id|shost-&gt;free_list
)paren
suffix:semicolon
id|cmd
op_assign
l_int|NULL
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|shost-&gt;free_list_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|cmd
op_ne
l_int|NULL
)paren
)paren
id|kmem_cache_free
c_func
(paren
id|shost-&gt;cmd_pool-&gt;slab
comma
id|cmd
)paren
suffix:semicolon
id|put_device
c_func
(paren
op_amp
id|sdev-&gt;sdev_gendev
)paren
suffix:semicolon
)brace
DECL|variable|scsi_put_command
id|EXPORT_SYMBOL
c_func
(paren
id|scsi_put_command
)paren
suffix:semicolon
multiline_comment|/*&n; * Function:&t;scsi_setup_command_freelist()&n; *&n; * Purpose:&t;Setup the command freelist for a scsi host.&n; *&n; * Arguments:&t;shost&t;- host to allocate the freelist for.&n; *&n; * Returns:&t;Nothing.&n; */
DECL|function|scsi_setup_command_freelist
r_int
id|scsi_setup_command_freelist
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
)paren
(brace
r_struct
id|scsi_host_cmd_pool
op_star
id|pool
suffix:semicolon
r_struct
id|scsi_cmnd
op_star
id|cmd
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|shost-&gt;free_list_lock
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|shost-&gt;free_list
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Select a command slab for this host and create it if not&n;&t; * yet existant.&n;&t; */
id|down
c_func
(paren
op_amp
id|host_cmd_pool_mutex
)paren
suffix:semicolon
id|pool
op_assign
(paren
id|shost-&gt;unchecked_isa_dma
ques
c_cond
op_amp
id|scsi_cmd_dma_pool
suffix:colon
op_amp
id|scsi_cmd_pool
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pool-&gt;users
)paren
(brace
id|pool-&gt;slab
op_assign
id|kmem_cache_create
c_func
(paren
id|pool-&gt;name
comma
r_sizeof
(paren
r_struct
id|scsi_cmnd
)paren
comma
l_int|0
comma
id|pool-&gt;slab_flags
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pool-&gt;slab
)paren
r_goto
id|fail
suffix:semicolon
)brace
id|pool-&gt;users
op_increment
suffix:semicolon
id|shost-&gt;cmd_pool
op_assign
id|pool
suffix:semicolon
id|up
c_func
(paren
op_amp
id|host_cmd_pool_mutex
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get one backup command for this host.&n;&t; */
id|cmd
op_assign
id|kmem_cache_alloc
c_func
(paren
id|shost-&gt;cmd_pool-&gt;slab
comma
id|GFP_KERNEL
op_or
id|shost-&gt;cmd_pool-&gt;gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmd
)paren
r_goto
id|fail2
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|cmd-&gt;list
comma
op_amp
id|shost-&gt;free_list
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|fail2
suffix:colon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|pool-&gt;users
)paren
id|kmem_cache_destroy
c_func
(paren
id|pool-&gt;slab
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|fail
suffix:colon
id|up
c_func
(paren
op_amp
id|host_cmd_pool_mutex
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:&t;scsi_destroy_command_freelist()&n; *&n; * Purpose:&t;Release the command freelist for a scsi host.&n; *&n; * Arguments:&t;shost&t;- host that&squot;s freelist is going to be destroyed&n; */
DECL|function|scsi_destroy_command_freelist
r_void
id|scsi_destroy_command_freelist
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|shost-&gt;free_list
)paren
)paren
(brace
r_struct
id|scsi_cmnd
op_star
id|cmd
suffix:semicolon
id|cmd
op_assign
id|list_entry
c_func
(paren
id|shost-&gt;free_list.next
comma
r_struct
id|scsi_cmnd
comma
id|list
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|cmd-&gt;list
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|shost-&gt;cmd_pool-&gt;slab
comma
id|cmd
)paren
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|host_cmd_pool_mutex
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|shost-&gt;cmd_pool-&gt;users
)paren
id|kmem_cache_destroy
c_func
(paren
id|shost-&gt;cmd_pool-&gt;slab
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|host_cmd_pool_mutex
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SCSI_LOGGING
DECL|function|scsi_log_send
r_void
id|scsi_log_send
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_int
r_int
id|level
suffix:semicolon
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
multiline_comment|/*&n;&t; * If ML QUEUE log level is greater than or equal to:&n;&t; *&n;&t; * 1: nothing (match completion)&n;&t; *&n;&t; * 2: log opcode + command of all commands&n;&t; *&n;&t; * 3: same as 2 plus dump cmd address&n;&t; *&n;&t; * 4: same as 3 plus dump extra junk&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|scsi_logging_level
)paren
)paren
(brace
id|level
op_assign
id|SCSI_LOG_LEVEL
c_func
(paren
id|SCSI_LOG_MLQUEUE_SHIFT
comma
id|SCSI_LOG_MLQUEUE_BITS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|level
OG
l_int|1
)paren
(brace
id|sdev
op_assign
id|cmd-&gt;device
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi &lt;%d:%d:%d:%d&gt; send &quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|level
OG
l_int|2
)paren
id|printk
c_func
(paren
l_string|&quot;0x%p &quot;
comma
id|cmd
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * spaces to match disposition and cmd-&gt;result&n;&t;&t;&t; * output in scsi_log_completion.&n;&t;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;                 &quot;
)paren
suffix:semicolon
id|scsi_print_command
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|level
OG
l_int|3
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;buffer = 0x%p, bufflen = %d,&quot;
l_string|&quot; done = 0x%p, queuecommand 0x%p&bslash;n&quot;
comma
id|cmd-&gt;buffer
comma
id|cmd-&gt;bufflen
comma
id|cmd-&gt;done
comma
id|sdev-&gt;host-&gt;hostt-&gt;queuecommand
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
DECL|function|scsi_log_completion
r_void
id|scsi_log_completion
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_int
id|disposition
)paren
(brace
r_int
r_int
id|level
suffix:semicolon
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
multiline_comment|/*&n;&t; * If ML COMPLETE log level is greater than or equal to:&n;&t; *&n;&t; * 1: log disposition, result, opcode + command, and conditionally&n;&t; * sense data for failures or non SUCCESS dispositions.&n;&t; *&n;&t; * 2: same as 1 but for all command completions.&n;&t; *&n;&t; * 3: same as 2 plus dump cmd address&n;&t; *&n;&t; * 4: same as 3 plus dump extra junk&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|scsi_logging_level
)paren
)paren
(brace
id|level
op_assign
id|SCSI_LOG_LEVEL
c_func
(paren
id|SCSI_LOG_MLCOMPLETE_SHIFT
comma
id|SCSI_LOG_MLCOMPLETE_BITS
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|level
OG
l_int|0
)paren
op_logical_and
(paren
id|cmd-&gt;result
op_logical_or
id|disposition
op_ne
id|SUCCESS
)paren
)paren
op_logical_or
(paren
id|level
OG
l_int|1
)paren
)paren
(brace
id|sdev
op_assign
id|cmd-&gt;device
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi &lt;%d:%d:%d:%d&gt; done &quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|level
OG
l_int|2
)paren
id|printk
c_func
(paren
l_string|&quot;0x%p &quot;
comma
id|cmd
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Dump truncated values, so we usually fit within&n;&t;&t;&t; * 80 chars.&n;&t;&t;&t; */
r_switch
c_cond
(paren
id|disposition
)paren
(brace
r_case
id|SUCCESS
suffix:colon
id|printk
c_func
(paren
l_string|&quot;SUCCESS&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NEEDS_RETRY
suffix:colon
id|printk
c_func
(paren
l_string|&quot;RETRY  &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ADD_TO_MLQUEUE
suffix:colon
id|printk
c_func
(paren
l_string|&quot;MLQUEUE&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FAILED
suffix:colon
id|printk
c_func
(paren
l_string|&quot;FAILED &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIMEOUT_ERROR
suffix:colon
multiline_comment|/* &n;&t;&t;&t;&t; * If called via scsi_times_out.&n;&t;&t;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;TIMEOUT&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;UNKNOWN&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; %8x &quot;
comma
id|cmd-&gt;result
)paren
suffix:semicolon
id|scsi_print_command
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status_byte
c_func
(paren
id|cmd-&gt;result
)paren
op_amp
id|CHECK_CONDITION
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * XXX The print_sense formatting/prefix&n;&t;&t;&t;&t; * doesn&squot;t match this function.&n;&t;&t;&t;&t; */
id|scsi_print_sense
c_func
(paren
l_string|&quot;&quot;
comma
id|cmd
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|level
OG
l_int|3
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi host busy %d failed %d&bslash;n&quot;
comma
id|sdev-&gt;host-&gt;host_busy
comma
id|sdev-&gt;host-&gt;host_failed
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
macro_line|#endif
multiline_comment|/*&n; * Function:    scsi_dispatch_command&n; *&n; * Purpose:     Dispatch a command to the low-level driver.&n; *&n; * Arguments:   cmd - command block we are dispatching.&n; *&n; * Notes:&n; */
DECL|function|scsi_dispatch_cmd
r_int
id|scsi_dispatch_cmd
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|cmd-&gt;device-&gt;host
suffix:semicolon
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
r_int
id|rtn
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* check if the device is still usable */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|cmd-&gt;device-&gt;sdev_state
op_eq
id|SDEV_DEL
)paren
)paren
(brace
multiline_comment|/* in SDEV_DEL we error all commands. DID_NO_CONNECT&n;&t;&t; * returns an immediate error upwards, and signals&n;&t;&t; * that the device is no longer present */
id|cmd-&gt;result
op_assign
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
multiline_comment|/* return 0 (because the command has been processed) */
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Check to see if the scsi lld put this device into state SDEV_BLOCK. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|cmd-&gt;device-&gt;sdev_state
op_eq
id|SDEV_BLOCK
)paren
)paren
(brace
multiline_comment|/* &n;&t;&t; * in SDEV_BLOCK, the command is just put back on the device&n;&t;&t; * queue.  The suspend state has already blocked the queue so&n;&t;&t; * future requests should not occur until the device &n;&t;&t; * transitions out of the suspend state.&n;&t;&t; */
id|scsi_queue_insert
c_func
(paren
id|cmd
comma
id|SCSI_MLQUEUE_DEVICE_BUSY
)paren
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;queuecommand : device blocked &bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * NOTE: rtn is still zero here because we don&squot;t need the&n;&t;&t; * queue to be plugged on return (it&squot;s already stopped)&n;&t;&t; */
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Assign a unique nonzero serial_number. */
multiline_comment|/* XXX(hch): this is racy */
r_if
c_cond
(paren
op_increment
id|serial_number
op_eq
l_int|0
)paren
id|serial_number
op_assign
l_int|1
suffix:semicolon
id|cmd-&gt;serial_number
op_assign
id|serial_number
suffix:semicolon
id|cmd-&gt;pid
op_assign
id|scsi_pid
op_increment
suffix:semicolon
multiline_comment|/* &n;&t; * If SCSI-2 or lower, store the LUN value in cmnd.&n;&t; */
r_if
c_cond
(paren
id|cmd-&gt;device-&gt;scsi_level
op_le
id|SCSI_2
)paren
(brace
id|cmd-&gt;cmnd
(braket
l_int|1
)braket
op_assign
(paren
id|cmd-&gt;cmnd
(braket
l_int|1
)braket
op_amp
l_int|0x1f
)paren
op_or
(paren
id|cmd-&gt;device-&gt;lun
op_lshift
l_int|5
op_amp
l_int|0xe0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We will wait MIN_RESET_DELAY clock ticks after the last reset so&n;&t; * we can avoid the drive not being ready.&n;&t; */
id|timeout
op_assign
id|host-&gt;last_reset
op_plus
id|MIN_RESET_DELAY
suffix:semicolon
r_if
c_cond
(paren
id|host-&gt;resetting
op_logical_and
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
r_int
id|ticks_remaining
op_assign
id|timeout
op_minus
id|jiffies
suffix:semicolon
multiline_comment|/*&n;&t;&t; * NOTE: This may be executed from within an interrupt&n;&t;&t; * handler!  This is bad, but for now, it&squot;ll do.  The irq&n;&t;&t; * level of the interrupt handler has been masked out by the&n;&t;&t; * platform dependent interrupt handling code already, so the&n;&t;&t; * sti() here will not cause another call to the SCSI host&squot;s&n;&t;&t; * interrupt handler (assuming there is one irq-level per&n;&t;&t; * host).&n;&t;&t; */
r_while
c_loop
(paren
op_decrement
id|ticks_remaining
op_ge
l_int|0
)paren
id|mdelay
c_func
(paren
l_int|1
op_plus
l_int|999
op_div
id|HZ
)paren
suffix:semicolon
id|host-&gt;resetting
op_assign
l_int|0
suffix:semicolon
)brace
id|scsi_add_timer
c_func
(paren
id|cmd
comma
id|cmd-&gt;timeout_per_command
comma
id|scsi_times_out
)paren
suffix:semicolon
id|scsi_log_send
c_func
(paren
id|cmd
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We will use a queued command if possible, otherwise we will&n;&t; * emulate the queuing and calling of completion function ourselves.&n;&t; */
id|cmd-&gt;state
op_assign
id|SCSI_STATE_QUEUED
suffix:semicolon
id|cmd-&gt;owner
op_assign
id|SCSI_OWNER_LOWLEVEL
suffix:semicolon
multiline_comment|/*&n;&t; * Before we queue this command, check if the command&n;&t; * length exceeds what the host adapter can handle.&n;&t; */
r_if
c_cond
(paren
id|CDB_SIZE
c_func
(paren
id|cmd
)paren
OG
id|cmd-&gt;device-&gt;host-&gt;max_cmd_len
)paren
(brace
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;queuecommand : command too long.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
(paren
id|DID_ABORT
op_lshift
l_int|16
)paren
suffix:semicolon
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
id|host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|test_bit
c_func
(paren
id|SHOST_CANCEL
comma
op_amp
id|host-&gt;shost_state
)paren
)paren
)paren
(brace
id|cmd-&gt;result
op_assign
(paren
id|DID_NO_CONNECT
op_lshift
l_int|16
)paren
suffix:semicolon
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
r_else
(brace
id|rtn
op_assign
id|host-&gt;hostt
op_member_access_from_pointer
id|queuecommand
c_func
(paren
id|cmd
comma
id|scsi_done
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
id|host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
)paren
(brace
id|scsi_queue_insert
c_func
(paren
id|cmd
comma
(paren
id|rtn
op_eq
id|SCSI_MLQUEUE_DEVICE_BUSY
)paren
ques
c_cond
id|rtn
suffix:colon
id|SCSI_MLQUEUE_HOST_BUSY
)paren
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;queuecommand : request rejected&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;leaving scsi_dispatch_cmnd()&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|rtn
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_init_cmd_from_req&n; *&n; * Purpose:     Queue a SCSI command&n; * Purpose:     Initialize a struct scsi_cmnd from a struct scsi_request&n; *&n; * Arguments:   cmd       - command descriptor.&n; *              sreq      - Request from the queue.&n; *&n; * Lock status: None needed.&n; *&n; * Returns:     Nothing.&n; *&n; * Notes:       Mainly transfer data from the request structure to the&n; *              command structure.  The request structure is allocated&n; *              using the normal memory allocator, and requests can pile&n; *              up to more or less any depth.  The command structure represents&n; *              a consumable resource, as these are allocated into a pool&n; *              when the SCSI subsystem initializes.  The preallocation is&n; *              required so that in low-memory situations a disk I/O request&n; *              won&squot;t cause the memory manager to try and write out a page.&n; *              The request structure is generally used by ioctls and character&n; *              devices.&n; */
DECL|function|scsi_init_cmd_from_req
r_void
id|scsi_init_cmd_from_req
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_struct
id|scsi_request
op_star
id|sreq
)paren
(brace
id|sreq-&gt;sr_command
op_assign
id|cmd
suffix:semicolon
id|cmd-&gt;owner
op_assign
id|SCSI_OWNER_MIDLEVEL
suffix:semicolon
id|cmd-&gt;cmd_len
op_assign
id|sreq-&gt;sr_cmd_len
suffix:semicolon
id|cmd-&gt;use_sg
op_assign
id|sreq-&gt;sr_use_sg
suffix:semicolon
id|cmd-&gt;request
op_assign
id|sreq-&gt;sr_request
suffix:semicolon
id|memcpy
c_func
(paren
id|cmd-&gt;data_cmnd
comma
id|sreq-&gt;sr_cmnd
comma
r_sizeof
(paren
id|cmd-&gt;data_cmnd
)paren
)paren
suffix:semicolon
id|cmd-&gt;serial_number
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;serial_number_at_timeout
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;bufflen
op_assign
id|sreq-&gt;sr_bufflen
suffix:semicolon
id|cmd-&gt;buffer
op_assign
id|sreq-&gt;sr_buffer
suffix:semicolon
id|cmd-&gt;retries
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;allowed
op_assign
id|sreq-&gt;sr_allowed
suffix:semicolon
id|cmd-&gt;done
op_assign
id|sreq-&gt;sr_done
suffix:semicolon
id|cmd-&gt;timeout_per_command
op_assign
id|sreq-&gt;sr_timeout_per_command
suffix:semicolon
id|cmd-&gt;sc_data_direction
op_assign
id|sreq-&gt;sr_data_direction
suffix:semicolon
id|cmd-&gt;sglist_len
op_assign
id|sreq-&gt;sr_sglist_len
suffix:semicolon
id|cmd-&gt;underflow
op_assign
id|sreq-&gt;sr_underflow
suffix:semicolon
id|cmd-&gt;sc_request
op_assign
id|sreq
suffix:semicolon
id|memcpy
c_func
(paren
id|cmd-&gt;cmnd
comma
id|sreq-&gt;sr_cmnd
comma
r_sizeof
(paren
id|sreq-&gt;sr_cmnd
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Zero the sense buffer.  Some host adapters automatically request&n;&t; * sense on error.  0 is not a valid sense code.&n;&t; */
id|memset
c_func
(paren
id|cmd-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
(paren
id|sreq-&gt;sr_sense_buffer
)paren
)paren
suffix:semicolon
id|cmd-&gt;request_buffer
op_assign
id|sreq-&gt;sr_buffer
suffix:semicolon
id|cmd-&gt;request_bufflen
op_assign
id|sreq-&gt;sr_bufflen
suffix:semicolon
id|cmd-&gt;old_use_sg
op_assign
id|cmd-&gt;use_sg
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;cmd_len
op_eq
l_int|0
)paren
id|cmd-&gt;cmd_len
op_assign
id|COMMAND_SIZE
c_func
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|cmd-&gt;old_cmd_len
op_assign
id|cmd-&gt;cmd_len
suffix:semicolon
id|cmd-&gt;sc_old_data_direction
op_assign
id|cmd-&gt;sc_data_direction
suffix:semicolon
id|cmd-&gt;old_underflow
op_assign
id|cmd-&gt;underflow
suffix:semicolon
multiline_comment|/*&n;&t; * Start the timer ticking.&n;&t; */
id|cmd-&gt;internal_timeout
op_assign
id|NORMAL_TIMEOUT
suffix:semicolon
id|cmd-&gt;abort_reason
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;result
op_assign
l_int|0
suffix:semicolon
id|SCSI_LOG_MLQUEUE
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Leaving scsi_init_cmd_from_req()&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Per-CPU I/O completion queue.&n; */
r_static
id|DEFINE_PER_CPU
c_func
(paren
r_struct
id|list_head
comma
id|scsi_done_q
)paren
suffix:semicolon
multiline_comment|/**&n; * scsi_done - Enqueue the finished SCSI command into the done queue.&n; * @cmd: The SCSI Command for which a low-level device driver (LLDD) gives&n; * ownership back to SCSI Core -- i.e. the LLDD has finished with it.&n; *&n; * This function is the mid-level&squot;s (SCSI Core) interrupt routine, which&n; * regains ownership of the SCSI command (de facto) from a LLDD, and enqueues&n; * the command to the done queue for further processing.&n; *&n; * This is the producer of the done queue who enqueues at the tail.&n; *&n; * This function is interrupt context safe.&n; */
DECL|function|scsi_done
r_void
id|scsi_done
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
multiline_comment|/*&n;&t; * We don&squot;t have to worry about this one timing out any more.&n;&t; * If we are unable to remove the timer, then the command&n;&t; * has already timed out.  In which case, we have no choice but to&n;&t; * let the timeout function run, as we have no idea where in fact&n;&t; * that function could really be.  It might be on another processor,&n;&t; * etc, etc.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|scsi_delete_timer
c_func
(paren
id|cmd
)paren
)paren
r_return
suffix:semicolon
id|__scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
multiline_comment|/* Private entry to scsi_done() to complete a command when the timer&n; * isn&squot;t running --- used by scsi_times_out */
DECL|function|__scsi_done
r_void
id|__scsi_done
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * Set the serial numbers back to zero&n;&t; */
id|cmd-&gt;serial_number
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;serial_number_at_timeout
op_assign
l_int|0
suffix:semicolon
id|cmd-&gt;state
op_assign
id|SCSI_STATE_BHQUEUE
suffix:semicolon
id|cmd-&gt;owner
op_assign
id|SCSI_OWNER_BH_HANDLER
suffix:semicolon
multiline_comment|/*&n;&t; * Next, enqueue the command into the done queue.&n;&t; * It is a per-CPU queue, so we just disable local interrupts&n;&t; * and need no spinlock.&n;&t; */
id|local_irq_save
c_func
(paren
id|flags
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|cmd-&gt;eh_entry
comma
op_amp
id|__get_cpu_var
c_func
(paren
id|scsi_done_q
)paren
)paren
suffix:semicolon
id|raise_softirq_irqoff
c_func
(paren
id|SCSI_SOFTIRQ
)paren
suffix:semicolon
id|local_irq_restore
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_softirq - Perform post-interrupt processing of finished SCSI commands.&n; *&n; * This is the consumer of the done queue.&n; *&n; * This is called with all interrupts enabled.  This should reduce&n; * interrupt latency, stack depth, and reentrancy of the low-level&n; * drivers.&n; */
DECL|function|scsi_softirq
r_static
r_void
id|scsi_softirq
c_func
(paren
r_struct
id|softirq_action
op_star
id|h
)paren
(brace
r_int
id|disposition
suffix:semicolon
id|LIST_HEAD
c_func
(paren
id|local_q
)paren
suffix:semicolon
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|list_splice_init
c_func
(paren
op_amp
id|__get_cpu_var
c_func
(paren
id|scsi_done_q
)paren
comma
op_amp
id|local_q
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|local_q
)paren
)paren
(brace
r_struct
id|scsi_cmnd
op_star
id|cmd
op_assign
id|list_entry
c_func
(paren
id|local_q.next
comma
r_struct
id|scsi_cmnd
comma
id|eh_entry
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|cmd-&gt;eh_entry
)paren
suffix:semicolon
id|disposition
op_assign
id|scsi_decide_disposition
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|scsi_log_completion
c_func
(paren
id|cmd
comma
id|disposition
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|disposition
)paren
(brace
r_case
id|SUCCESS
suffix:colon
id|scsi_finish_command
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NEEDS_RETRY
suffix:colon
id|scsi_retry_command
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ADD_TO_MLQUEUE
suffix:colon
id|scsi_queue_insert
c_func
(paren
id|cmd
comma
id|SCSI_MLQUEUE_DEVICE_BUSY
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|scsi_eh_scmd_add
c_func
(paren
id|cmd
comma
l_int|0
)paren
)paren
id|scsi_finish_command
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Function:    scsi_retry_command&n; *&n; * Purpose:     Send a command back to the low level to be retried.&n; *&n; * Notes:       This command is always executed in the context of the&n; *              bottom half handler, or the error handler thread. Low&n; *              level drivers should not become re-entrant as a result of&n; *              this.&n; */
DECL|function|scsi_retry_command
r_int
id|scsi_retry_command
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
multiline_comment|/*&n;&t; * Restore the SCSI command state.&n;&t; */
id|scsi_setup_cmd_retry
c_func
(paren
id|cmd
)paren
suffix:semicolon
multiline_comment|/*&n;         * Zero the sense information from the last time we tried&n;         * this command.&n;         */
id|memset
c_func
(paren
id|cmd-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
)paren
suffix:semicolon
r_return
id|scsi_queue_insert
c_func
(paren
id|cmd
comma
id|SCSI_MLQUEUE_EH_RETRY
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_finish_command&n; *&n; * Purpose:     Pass command off to upper layer for finishing of I/O&n; *              request, waking processes that are waiting on results,&n; *              etc.&n; */
DECL|function|scsi_finish_command
r_void
id|scsi_finish_command
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
op_assign
id|cmd-&gt;device
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|shost
op_assign
id|sdev-&gt;host
suffix:semicolon
r_struct
id|scsi_request
op_star
id|sreq
suffix:semicolon
id|scsi_device_unbusy
c_func
(paren
id|sdev
)paren
suffix:semicolon
multiline_comment|/*&n;         * Clear the flags which say that the device/host is no longer&n;         * capable of accepting new commands.  These are set in scsi_queue.c&n;         * for both the queue full condition on a device, and for a&n;         * host full condition on the host.&n;&t; *&n;&t; * XXX(hch): What about locking?&n;         */
id|shost-&gt;host_blocked
op_assign
l_int|0
suffix:semicolon
id|sdev-&gt;device_blocked
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If we have valid sense information, then some kind of recovery&n;&t; * must have taken place.  Make a note of this.&n;&t; */
r_if
c_cond
(paren
id|SCSI_SENSE_VALID
c_func
(paren
id|cmd
)paren
)paren
id|cmd-&gt;result
op_or_assign
(paren
id|DRIVER_SENSE
op_lshift
l_int|24
)paren
suffix:semicolon
id|SCSI_LOG_MLCOMPLETE
c_func
(paren
l_int|4
comma
id|printk
c_func
(paren
l_string|&quot;Notifying upper driver of completion &quot;
l_string|&quot;for device %d %x&bslash;n&quot;
comma
id|sdev-&gt;id
comma
id|cmd-&gt;result
)paren
)paren
suffix:semicolon
id|cmd-&gt;owner
op_assign
id|SCSI_OWNER_HIGHLEVEL
suffix:semicolon
id|cmd-&gt;state
op_assign
id|SCSI_STATE_FINISHED
suffix:semicolon
multiline_comment|/*&n;&t; * We can get here with use_sg=0, causing a panic in the upper level&n;&t; */
id|cmd-&gt;use_sg
op_assign
id|cmd-&gt;old_use_sg
suffix:semicolon
multiline_comment|/*&n;&t; * If there is an associated request structure, copy the data over&n;&t; * before we call the completion function.&n;&t; */
id|sreq
op_assign
id|cmd-&gt;sc_request
suffix:semicolon
r_if
c_cond
(paren
id|sreq
)paren
(brace
id|sreq-&gt;sr_result
op_assign
id|sreq-&gt;sr_command-&gt;result
suffix:semicolon
r_if
c_cond
(paren
id|sreq-&gt;sr_result
)paren
(brace
id|memcpy
c_func
(paren
id|sreq-&gt;sr_sense_buffer
comma
id|sreq-&gt;sr_command-&gt;sense_buffer
comma
r_sizeof
(paren
id|sreq-&gt;sr_sense_buffer
)paren
)paren
suffix:semicolon
)brace
)brace
id|cmd
op_member_access_from_pointer
id|done
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
DECL|variable|scsi_finish_command
id|EXPORT_SYMBOL
c_func
(paren
id|scsi_finish_command
)paren
suffix:semicolon
multiline_comment|/*&n; * Function:&t;scsi_adjust_queue_depth()&n; *&n; * Purpose:&t;Allow low level drivers to tell us to change the queue depth&n; * &t;&t;on a specific SCSI device&n; *&n; * Arguments:&t;sdev&t;- SCSI Device in question&n; * &t;&t;tagged&t;- Do we use tagged queueing (non-0) or do we treat&n; * &t;&t;&t;  this device as an untagged device (0)&n; * &t;&t;tags&t;- Number of tags allowed if tagged queueing enabled,&n; * &t;&t;&t;  or number of commands the low level driver can&n; * &t;&t;&t;  queue up in non-tagged mode (as per cmd_per_lun).&n; *&n; * Returns:&t;Nothing&n; *&n; * Lock Status:&t;None held on entry&n; *&n; * Notes:&t;Low level drivers may call this at any time and we will do&n; * &t;&t;the right thing depending on whether or not the device is&n; * &t;&t;currently active and whether or not it even has the&n; * &t;&t;command blocks built yet.&n; *&n; * XXX(hch):&t;What exactly is device_request_lock trying to protect?&n; */
DECL|function|scsi_adjust_queue_depth
r_void
id|scsi_adjust_queue_depth
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
comma
r_int
id|tagged
comma
r_int
id|tags
)paren
(brace
r_static
id|spinlock_t
id|device_request_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * refuse to set tagged depth to an unworkable size&n;&t; */
r_if
c_cond
(paren
id|tags
op_le
l_int|0
)paren
r_return
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
id|sdev-&gt;request_queue-&gt;queue_lock
)paren
suffix:semicolon
multiline_comment|/* Check to see if the queue is managed by the block layer&n;&t; * if it is, and we fail to adjust the depth, exit */
r_if
c_cond
(paren
id|blk_queue_tagged
c_func
(paren
id|sdev-&gt;request_queue
)paren
op_logical_and
id|blk_queue_resize_tags
c_func
(paren
id|sdev-&gt;request_queue
comma
id|tags
)paren
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|sdev-&gt;queue_depth
op_assign
id|tags
suffix:semicolon
r_switch
c_cond
(paren
id|tagged
)paren
(brace
r_case
id|MSG_ORDERED_TAG
suffix:colon
id|sdev-&gt;ordered_tags
op_assign
l_int|1
suffix:semicolon
id|sdev-&gt;simple_tags
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MSG_SIMPLE_TAG
suffix:colon
id|sdev-&gt;ordered_tags
op_assign
l_int|0
suffix:semicolon
id|sdev-&gt;simple_tags
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;(scsi%d:%d:%d:%d) &quot;
l_string|&quot;scsi_adjust_queue_depth, bad queue type, &quot;
l_string|&quot;disabled&bslash;n&quot;
comma
id|sdev-&gt;host-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
)paren
suffix:semicolon
r_case
l_int|0
suffix:colon
id|sdev-&gt;ordered_tags
op_assign
id|sdev-&gt;simple_tags
op_assign
l_int|0
suffix:semicolon
id|sdev-&gt;queue_depth
op_assign
id|tags
suffix:semicolon
r_break
suffix:semicolon
)brace
id|out
suffix:colon
id|spin_unlock
c_func
(paren
id|sdev-&gt;request_queue-&gt;queue_lock
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|device_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|variable|scsi_adjust_queue_depth
id|EXPORT_SYMBOL
c_func
(paren
id|scsi_adjust_queue_depth
)paren
suffix:semicolon
multiline_comment|/*&n; * Function:&t;scsi_track_queue_full()&n; *&n; * Purpose:&t;This function will track successive QUEUE_FULL events on a&n; * &t;&t;specific SCSI device to determine if and when there is a&n; * &t;&t;need to adjust the queue depth on the device.&n; *&n; * Arguments:&t;sdev&t;- SCSI Device in question&n; * &t;&t;depth&t;- Current number of outstanding SCSI commands on&n; * &t;&t;&t;  this device, not counting the one returned as&n; * &t;&t;&t;  QUEUE_FULL.&n; *&n; * Returns:&t;0 - No change needed&n; * &t;&t;&gt;0 - Adjust queue depth to this new depth&n; * &t;&t;-1 - Drop back to untagged operation using host-&gt;cmd_per_lun&n; * &t;&t;&t;as the untagged command depth&n; *&n; * Lock Status:&t;None held on entry&n; *&n; * Notes:&t;Low level drivers may call this at any time and we will do&n; * &t;&t;&quot;The Right Thing.&quot;  We are interrupt context safe.&n; */
DECL|function|scsi_track_queue_full
r_int
id|scsi_track_queue_full
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
comma
r_int
id|depth
)paren
(brace
r_if
c_cond
(paren
(paren
id|jiffies
op_rshift
l_int|4
)paren
op_eq
id|sdev-&gt;last_queue_full_time
)paren
r_return
l_int|0
suffix:semicolon
id|sdev-&gt;last_queue_full_time
op_assign
(paren
id|jiffies
op_rshift
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;last_queue_full_depth
op_ne
id|depth
)paren
(brace
id|sdev-&gt;last_queue_full_count
op_assign
l_int|1
suffix:semicolon
id|sdev-&gt;last_queue_full_depth
op_assign
id|depth
suffix:semicolon
)brace
r_else
(brace
id|sdev-&gt;last_queue_full_count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sdev-&gt;last_queue_full_count
op_le
l_int|10
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sdev-&gt;last_queue_full_depth
OL
l_int|8
)paren
(brace
multiline_comment|/* Drop back to untagged */
id|scsi_adjust_queue_depth
c_func
(paren
id|sdev
comma
l_int|0
comma
id|sdev-&gt;host-&gt;cmd_per_lun
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sdev-&gt;ordered_tags
)paren
id|scsi_adjust_queue_depth
c_func
(paren
id|sdev
comma
id|MSG_ORDERED_TAG
comma
id|depth
)paren
suffix:semicolon
r_else
id|scsi_adjust_queue_depth
c_func
(paren
id|sdev
comma
id|MSG_SIMPLE_TAG
comma
id|depth
)paren
suffix:semicolon
r_return
id|depth
suffix:semicolon
)brace
DECL|variable|scsi_track_queue_full
id|EXPORT_SYMBOL
c_func
(paren
id|scsi_track_queue_full
)paren
suffix:semicolon
multiline_comment|/**&n; * scsi_device_get  -  get an addition reference to a scsi_device&n; * @sdev:&t;device to get a reference to&n; *&n; * Gets a reference to the scsi_device and increments the use count&n; * of the underlying LLDD module.  You must hold host_lock of the&n; * parent Scsi_Host or already have a reference when calling this.&n; */
DECL|function|scsi_device_get
r_int
id|scsi_device_get
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
)paren
(brace
r_if
c_cond
(paren
id|sdev-&gt;sdev_state
op_eq
id|SDEV_DEL
op_logical_or
id|sdev-&gt;sdev_state
op_eq
id|SDEV_CANCEL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|get_device
c_func
(paren
op_amp
id|sdev-&gt;sdev_gendev
)paren
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|try_module_get
c_func
(paren
id|sdev-&gt;host-&gt;hostt-&gt;module
)paren
)paren
(brace
id|put_device
c_func
(paren
op_amp
id|sdev-&gt;sdev_gendev
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|scsi_device_get
id|EXPORT_SYMBOL
c_func
(paren
id|scsi_device_get
)paren
suffix:semicolon
multiline_comment|/**&n; * scsi_device_put  -  release a reference to a scsi_device&n; * @sdev:&t;device to release a reference on.&n; *&n; * Release a reference to the scsi_device and decrements the use count&n; * of the underlying LLDD module.  The device is freed once the last&n; * user vanishes.&n; */
DECL|function|scsi_device_put
r_void
id|scsi_device_put
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
)paren
(brace
id|module_put
c_func
(paren
id|sdev-&gt;host-&gt;hostt-&gt;module
)paren
suffix:semicolon
id|put_device
c_func
(paren
op_amp
id|sdev-&gt;sdev_gendev
)paren
suffix:semicolon
)brace
DECL|variable|scsi_device_put
id|EXPORT_SYMBOL
c_func
(paren
id|scsi_device_put
)paren
suffix:semicolon
multiline_comment|/* helper for shost_for_each_device, thus not documented */
DECL|function|__scsi_iterate_devices
r_struct
id|scsi_device
op_star
id|__scsi_iterate_devices
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
comma
r_struct
id|scsi_device
op_star
id|prev
)paren
(brace
r_struct
id|list_head
op_star
id|list
op_assign
(paren
id|prev
ques
c_cond
op_amp
id|prev-&gt;siblings
suffix:colon
op_amp
id|shost-&gt;__devices
)paren
suffix:semicolon
r_struct
id|scsi_device
op_star
id|next
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|shost-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
id|list-&gt;next
op_ne
op_amp
id|shost-&gt;__devices
)paren
(brace
id|next
op_assign
id|list_entry
c_func
(paren
id|list-&gt;next
comma
r_struct
id|scsi_device
comma
id|siblings
)paren
suffix:semicolon
multiline_comment|/* skip devices that we can&squot;t get a reference to */
r_if
c_cond
(paren
op_logical_neg
id|scsi_device_get
c_func
(paren
id|next
)paren
)paren
r_break
suffix:semicolon
id|next
op_assign
l_int|NULL
suffix:semicolon
id|list
op_assign
id|list-&gt;next
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
id|shost-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prev
)paren
id|scsi_device_put
c_func
(paren
id|prev
)paren
suffix:semicolon
r_return
id|next
suffix:semicolon
)brace
DECL|variable|__scsi_iterate_devices
id|EXPORT_SYMBOL
c_func
(paren
id|__scsi_iterate_devices
)paren
suffix:semicolon
multiline_comment|/**&n; * starget_for_each_device  -  helper to walk all devices of a target&n; * @starget:&t;target whose devices we want to iterate over.&n; *&n; * This traverses over each devices of @shost.  The devices have&n; * a reference that must be released by scsi_host_put when breaking&n; * out of the loop.&n; */
DECL|function|starget_for_each_device
r_void
id|starget_for_each_device
c_func
(paren
r_struct
id|scsi_target
op_star
id|starget
comma
r_void
op_star
id|data
comma
r_void
(paren
op_star
id|fn
)paren
(paren
r_struct
id|scsi_device
op_star
comma
r_void
op_star
)paren
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|shost
op_assign
id|dev_to_shost
c_func
(paren
id|starget-&gt;dev.parent
)paren
suffix:semicolon
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
id|shost_for_each_device
c_func
(paren
id|sdev
comma
id|shost
)paren
(brace
r_if
c_cond
(paren
(paren
id|sdev-&gt;channel
op_eq
id|starget-&gt;channel
)paren
op_logical_and
(paren
id|sdev-&gt;id
op_eq
id|starget-&gt;id
)paren
)paren
id|fn
c_func
(paren
id|sdev
comma
id|data
)paren
suffix:semicolon
)brace
)brace
DECL|variable|starget_for_each_device
id|EXPORT_SYMBOL
c_func
(paren
id|starget_for_each_device
)paren
suffix:semicolon
multiline_comment|/**&n; * scsi_device_lookup - find a device given the host (UNLOCKED)&n; * @shost:&t;SCSI host pointer&n; * @channel:&t;SCSI channel (zero if only one channel)&n; * @pun:&t;SCSI target number (physical unit number)&n; * @lun:&t;SCSI Logical Unit Number&n; *&n; * Looks up the scsi_device with the specified @channel, @id, @lun for a&n; * give host. The returned scsi_device does not have an additional reference.&n; * You must hold the host&squot;s host_lock over this call and any access to the&n; * returned scsi_device.&n; *&n; * Note:  The only reason why drivers would want to use this is because&n; * they&squot;re need to access the device list in irq context.  Otherwise you&n; * really want to use scsi_device_lookup instead.&n; **/
DECL|function|__scsi_device_lookup
r_struct
id|scsi_device
op_star
id|__scsi_device_lookup
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
comma
id|uint
id|channel
comma
id|uint
id|id
comma
id|uint
id|lun
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|sdev
comma
op_amp
id|shost-&gt;__devices
comma
id|siblings
)paren
(brace
r_if
c_cond
(paren
id|sdev-&gt;channel
op_eq
id|channel
op_logical_and
id|sdev-&gt;id
op_eq
id|id
op_logical_and
id|sdev-&gt;lun
op_eq
id|lun
)paren
r_return
id|sdev
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|variable|__scsi_device_lookup
id|EXPORT_SYMBOL
c_func
(paren
id|__scsi_device_lookup
)paren
suffix:semicolon
multiline_comment|/**&n; * scsi_device_lookup - find a device given the host&n; * @shost:&t;SCSI host pointer&n; * @channel:&t;SCSI channel (zero if only one channel)&n; * @id:&t;&t;SCSI target number (physical unit number)&n; * @lun:&t;SCSI Logical Unit Number&n; *&n; * Looks up the scsi_device with the specified @channel, @id, @lun for a&n; * give host.  The returned scsi_device has an additional reference that&n; * needs to be release with scsi_host_put once you&squot;re done with it.&n; **/
DECL|function|scsi_device_lookup
r_struct
id|scsi_device
op_star
id|scsi_device_lookup
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
comma
id|uint
id|channel
comma
id|uint
id|id
comma
id|uint
id|lun
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|shost-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|sdev
op_assign
id|__scsi_device_lookup
c_func
(paren
id|shost
comma
id|channel
comma
id|id
comma
id|lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdev
op_logical_and
id|scsi_device_get
c_func
(paren
id|sdev
)paren
)paren
id|sdev
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|shost-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|sdev
suffix:semicolon
)brace
DECL|variable|scsi_device_lookup
id|EXPORT_SYMBOL
c_func
(paren
id|scsi_device_lookup
)paren
suffix:semicolon
multiline_comment|/**&n; * scsi_device_cancel - cancel outstanding IO to this device&n; * @sdev:&t;Pointer to struct scsi_device&n; * @recovery:&t;Boolean instructing function to recover device or not.&n; *&n; **/
DECL|function|scsi_device_cancel
r_int
id|scsi_device_cancel
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
comma
r_int
id|recovery
)paren
(brace
r_struct
id|scsi_cmnd
op_star
id|scmd
suffix:semicolon
id|LIST_HEAD
c_func
(paren
id|active_list
)paren
suffix:semicolon
r_struct
id|list_head
op_star
id|lh
comma
op_star
id|lh_sf
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|scsi_device_set_state
c_func
(paren
id|sdev
comma
id|SDEV_CANCEL
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sdev-&gt;list_lock
comma
id|flags
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|scmd
comma
op_amp
id|sdev-&gt;cmd_list
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|scmd-&gt;request
op_logical_and
id|scmd-&gt;request-&gt;rq_status
op_ne
id|RQ_INACTIVE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If we are unable to remove the timer, it means&n;&t;&t;&t; * that the command has already timed out or&n;&t;&t;&t; * finished.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|scsi_delete_timer
c_func
(paren
id|scmd
)paren
)paren
r_continue
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|scmd-&gt;eh_entry
comma
op_amp
id|active_list
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sdev-&gt;list_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|active_list
)paren
)paren
(brace
id|list_for_each_safe
c_func
(paren
id|lh
comma
id|lh_sf
comma
op_amp
id|active_list
)paren
(brace
id|scmd
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|scsi_cmnd
comma
id|eh_entry
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
id|lh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|recovery
)paren
(brace
id|scsi_eh_scmd_add
c_func
(paren
id|scmd
comma
id|SCSI_EH_CANCEL_CMD
)paren
suffix:semicolon
)brace
r_else
(brace
id|scmd-&gt;result
op_assign
(paren
id|DID_ABORT
op_lshift
l_int|16
)paren
suffix:semicolon
id|scsi_finish_command
c_func
(paren
id|scmd
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|scsi_device_cancel
id|EXPORT_SYMBOL
c_func
(paren
id|scsi_device_cancel
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_HOTPLUG_CPU
DECL|function|scsi_cpu_notify
r_static
r_int
id|scsi_cpu_notify
c_func
(paren
r_struct
id|notifier_block
op_star
id|self
comma
r_int
r_int
id|action
comma
r_void
op_star
id|hcpu
)paren
(brace
r_int
id|cpu
op_assign
(paren
r_int
r_int
)paren
id|hcpu
suffix:semicolon
r_switch
c_cond
(paren
id|action
)paren
(brace
r_case
id|CPU_DEAD
suffix:colon
multiline_comment|/* Drain scsi_done_q. */
id|local_irq_disable
c_func
(paren
)paren
suffix:semicolon
id|list_splice_init
c_func
(paren
op_amp
id|per_cpu
c_func
(paren
id|scsi_done_q
comma
id|cpu
)paren
comma
op_amp
id|__get_cpu_var
c_func
(paren
id|scsi_done_q
)paren
)paren
suffix:semicolon
id|raise_softirq_irqoff
c_func
(paren
id|SCSI_SOFTIRQ
)paren
suffix:semicolon
id|local_irq_enable
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
id|NOTIFY_OK
suffix:semicolon
)brace
DECL|variable|scsi_cpu_nb
r_static
r_struct
id|notifier_block
id|__devinitdata
id|scsi_cpu_nb
op_assign
(brace
dot
id|notifier_call
op_assign
id|scsi_cpu_notify
comma
)brace
suffix:semicolon
DECL|macro|register_scsi_cpu
mdefine_line|#define register_scsi_cpu() register_cpu_notifier(&amp;scsi_cpu_nb)
DECL|macro|unregister_scsi_cpu
mdefine_line|#define unregister_scsi_cpu() unregister_cpu_notifier(&amp;scsi_cpu_nb)
macro_line|#else
DECL|macro|register_scsi_cpu
mdefine_line|#define register_scsi_cpu()
DECL|macro|unregister_scsi_cpu
mdefine_line|#define unregister_scsi_cpu()
macro_line|#endif /* CONFIG_HOTPLUG_CPU */
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;SCSI core&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|module_param
c_func
(paren
id|scsi_logging_level
comma
r_int
comma
id|S_IRUGO
op_or
id|S_IWUSR
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|scsi_logging_level
comma
l_string|&quot;a bit mask of logging levels&quot;
)paren
suffix:semicolon
DECL|function|init_scsi
r_static
r_int
id|__init
id|init_scsi
c_func
(paren
r_void
)paren
(brace
r_int
id|error
comma
id|i
suffix:semicolon
id|error
op_assign
id|scsi_init_queue
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|error
op_assign
id|scsi_init_procfs
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|cleanup_queue
suffix:semicolon
id|error
op_assign
id|scsi_init_devinfo
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|cleanup_procfs
suffix:semicolon
id|error
op_assign
id|scsi_init_hosts
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|cleanup_devlist
suffix:semicolon
id|error
op_assign
id|scsi_init_sysctl
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|cleanup_hosts
suffix:semicolon
id|error
op_assign
id|scsi_sysfs_register
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|cleanup_sysctl
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|per_cpu
c_func
(paren
id|scsi_done_q
comma
id|i
)paren
)paren
suffix:semicolon
id|devfs_mk_dir
c_func
(paren
l_string|&quot;scsi&quot;
)paren
suffix:semicolon
id|open_softirq
c_func
(paren
id|SCSI_SOFTIRQ
comma
id|scsi_softirq
comma
l_int|NULL
)paren
suffix:semicolon
id|register_scsi_cpu
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;SCSI subsystem initialized&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|cleanup_sysctl
suffix:colon
id|scsi_exit_sysctl
c_func
(paren
)paren
suffix:semicolon
id|cleanup_hosts
suffix:colon
id|scsi_exit_hosts
c_func
(paren
)paren
suffix:semicolon
id|cleanup_devlist
suffix:colon
id|scsi_exit_devinfo
c_func
(paren
)paren
suffix:semicolon
id|cleanup_procfs
suffix:colon
id|scsi_exit_procfs
c_func
(paren
)paren
suffix:semicolon
id|cleanup_queue
suffix:colon
id|scsi_exit_queue
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;SCSI subsystem failed to initialize, error = %d&bslash;n&quot;
comma
op_minus
id|error
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|exit_scsi
r_static
r_void
id|__exit
id|exit_scsi
c_func
(paren
r_void
)paren
(brace
id|scsi_sysfs_unregister
c_func
(paren
)paren
suffix:semicolon
id|scsi_exit_sysctl
c_func
(paren
)paren
suffix:semicolon
id|scsi_exit_hosts
c_func
(paren
)paren
suffix:semicolon
id|scsi_exit_devinfo
c_func
(paren
)paren
suffix:semicolon
id|devfs_remove
c_func
(paren
l_string|&quot;scsi&quot;
)paren
suffix:semicolon
id|scsi_exit_procfs
c_func
(paren
)paren
suffix:semicolon
id|scsi_exit_queue
c_func
(paren
)paren
suffix:semicolon
id|unregister_scsi_cpu
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|init_scsi
id|subsys_initcall
c_func
(paren
id|init_scsi
)paren
suffix:semicolon
DECL|variable|exit_scsi
id|module_exit
c_func
(paren
id|exit_scsi
)paren
suffix:semicolon
eof
