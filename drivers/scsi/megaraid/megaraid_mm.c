multiline_comment|/*&n; *&n; *&t;&t;&t;Linux MegaRAID device driver&n; *&n; * Copyright (c) 2003-2004  LSI Logic Corporation.&n; *&n; *&t;   This program is free software; you can redistribute it and/or&n; *&t;   modify it under the terms of the GNU General Public License&n; *&t;   as published by the Free Software Foundation; either version&n; *&t;   2 of the License, or (at your option) any later version.&n; *&n; * FILE&t;&t;: megaraid_mm.c&n; * Version&t;: v2.20.2.2 (Nov 04 2004)&n; *&n; * Common management module&n; */
macro_line|#include &quot;megaraid_mm.h&quot;
singleline_comment|// Entry points for char node driver
r_static
r_int
id|mraid_mm_open
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
)paren
suffix:semicolon
r_static
r_int
id|mraid_mm_ioctl
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
comma
id|uint
comma
r_int
r_int
)paren
suffix:semicolon
singleline_comment|// routines to convert to and from the old the format
r_static
r_int
id|mimd_to_kioc
c_func
(paren
id|mimd_t
id|__user
op_star
comma
id|mraid_mmadp_t
op_star
comma
id|uioc_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|kioc_to_mimd
c_func
(paren
id|uioc_t
op_star
comma
id|mimd_t
id|__user
op_star
)paren
suffix:semicolon
singleline_comment|// Helper functions
r_static
r_int
id|handle_drvrcmd
c_func
(paren
r_void
id|__user
op_star
comma
r_uint8
comma
r_int
op_star
)paren
suffix:semicolon
r_static
r_int
id|lld_ioctl
c_func
(paren
id|mraid_mmadp_t
op_star
comma
id|uioc_t
op_star
)paren
suffix:semicolon
r_static
r_void
id|ioctl_done
c_func
(paren
id|uioc_t
op_star
)paren
suffix:semicolon
r_static
r_void
id|lld_timedout
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|hinfo_to_cinfo
c_func
(paren
id|mraid_hba_info_t
op_star
comma
id|mcontroller_t
op_star
)paren
suffix:semicolon
r_static
id|mraid_mmadp_t
op_star
id|mraid_mm_get_adapter
c_func
(paren
id|mimd_t
id|__user
op_star
comma
r_int
op_star
)paren
suffix:semicolon
r_static
id|uioc_t
op_star
id|mraid_mm_alloc_kioc
c_func
(paren
id|mraid_mmadp_t
op_star
)paren
suffix:semicolon
r_static
r_void
id|mraid_mm_dealloc_kioc
c_func
(paren
id|mraid_mmadp_t
op_star
comma
id|uioc_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|mraid_mm_attach_buf
c_func
(paren
id|mraid_mmadp_t
op_star
comma
id|uioc_t
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|mraid_mm_setup_dma_pools
c_func
(paren
id|mraid_mmadp_t
op_star
)paren
suffix:semicolon
r_static
r_void
id|mraid_mm_free_adp_resources
c_func
(paren
id|mraid_mmadp_t
op_star
)paren
suffix:semicolon
r_static
r_void
id|mraid_mm_teardown_dma_pools
c_func
(paren
id|mraid_mmadp_t
op_star
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_COMPAT
r_static
r_int
id|mraid_mm_compat_ioctl
c_func
(paren
r_int
r_int
comma
r_int
r_int
comma
r_int
r_int
comma
r_struct
id|file
op_star
)paren
suffix:semicolon
macro_line|#endif
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;LSI Logic Corporation&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;LSI Logic Management Module&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|variable|LSI_COMMON_MOD_VERSION
id|MODULE_VERSION
c_func
(paren
id|LSI_COMMON_MOD_VERSION
)paren
suffix:semicolon
DECL|variable|dbglevel
r_static
r_int
id|dbglevel
op_assign
id|CL_ANN
suffix:semicolon
id|module_param_named
c_func
(paren
id|dlevel
comma
id|dbglevel
comma
r_int
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|dlevel
comma
l_string|&quot;Debug level (default=0)&quot;
)paren
suffix:semicolon
DECL|variable|mraid_mm_register_adp
id|EXPORT_SYMBOL
c_func
(paren
id|mraid_mm_register_adp
)paren
suffix:semicolon
DECL|variable|mraid_mm_unregister_adp
id|EXPORT_SYMBOL
c_func
(paren
id|mraid_mm_unregister_adp
)paren
suffix:semicolon
DECL|variable|majorno
r_static
r_int
id|majorno
suffix:semicolon
DECL|variable|drvr_ver
r_static
r_uint32
id|drvr_ver
op_assign
l_int|0x02200201
suffix:semicolon
DECL|variable|adapters_count_g
r_static
r_int
id|adapters_count_g
suffix:semicolon
DECL|variable|adapters_list_g
r_static
r_struct
id|list_head
id|adapters_list_g
suffix:semicolon
DECL|variable|wait_q
id|wait_queue_head_t
id|wait_q
suffix:semicolon
DECL|variable|lsi_fops
r_static
r_struct
id|file_operations
id|lsi_fops
op_assign
(brace
dot
id|open
op_assign
id|mraid_mm_open
comma
dot
id|ioctl
op_assign
id|mraid_mm_ioctl
comma
dot
id|owner
op_assign
id|THIS_MODULE
comma
)brace
suffix:semicolon
multiline_comment|/**&n; * mraid_mm_open - open routine for char node interface&n; * @inod&t;: unused&n; * @filep&t;: unused&n; *&n; * allow ioctl operations by apps only if they superuser privilege&n; */
r_static
r_int
DECL|function|mraid_mm_open
id|mraid_mm_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filep
)paren
(brace
multiline_comment|/*&n;&t; * Only allow superuser to access private ioctl interface&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
(paren
op_minus
id|EACCES
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * mraid_mm_ioctl - module entry-point for ioctls&n; * @inode&t;: inode (ignored)&n; * @filep&t;: file operations pointer (ignored)&n; * @cmd&t;&t;: ioctl command&n; * @arg&t;&t;: user ioctl packet&n; */
r_static
r_int
DECL|function|mraid_mm_ioctl
id|mraid_mm_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filep
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
id|uioc_t
op_star
id|kioc
suffix:semicolon
r_char
id|signature
(braket
id|EXT_IOCTL_SIGN_SZ
)braket
op_assign
(brace
l_int|0
)brace
suffix:semicolon
r_int
id|rval
suffix:semicolon
id|mraid_mmadp_t
op_star
id|adp
suffix:semicolon
r_uint8
id|old_ioctl
suffix:semicolon
r_int
id|drvrcmd_rval
suffix:semicolon
r_void
id|__user
op_star
id|argp
op_assign
(paren
r_void
id|__user
op_star
)paren
id|arg
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure only USCSICMD are issued through this interface.&n;&t; * MIMD application would still fire different command.&n;&t; */
r_if
c_cond
(paren
(paren
id|_IOC_TYPE
c_func
(paren
id|cmd
)paren
op_ne
id|MEGAIOC_MAGIC
)paren
op_logical_and
(paren
id|cmd
op_ne
id|USCSICMD
)paren
)paren
(brace
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Look for signature to see if this is the new or old ioctl format.&n;&t; */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|signature
comma
id|argp
comma
id|EXT_IOCTL_SIGN_SZ
)paren
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid cmm: copy from usr addr failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|signature
comma
id|EXT_IOCTL_SIGN
comma
id|EXT_IOCTL_SIGN_SZ
)paren
op_eq
l_int|0
)paren
id|old_ioctl
op_assign
l_int|0
suffix:semicolon
r_else
id|old_ioctl
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * At present, we don&squot;t support the new ioctl packet&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|old_ioctl
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If it is a driver ioctl (as opposed to fw ioctls), then we can&n;&t; * handle the command locally. rval &gt; 0 means it is not a drvr cmd&n;&t; */
id|rval
op_assign
id|handle_drvrcmd
c_func
(paren
id|argp
comma
id|old_ioctl
comma
op_amp
id|drvrcmd_rval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rval
OL
l_int|0
)paren
r_return
id|rval
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rval
op_eq
l_int|0
)paren
r_return
id|drvrcmd_rval
suffix:semicolon
id|rval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|adp
op_assign
id|mraid_mm_get_adapter
c_func
(paren
id|argp
comma
op_amp
id|rval
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check if adapter can accept ioctl. We may have marked it offline&n;&t; * if any previous kioc had timedout on this controller.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|adp-&gt;quiescent
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid cmm: controller cannot accept cmds due to &quot;
l_string|&quot;earlier errors&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The following call will block till a kioc is available&n;&t; */
id|kioc
op_assign
id|mraid_mm_alloc_kioc
c_func
(paren
id|adp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * User sent the old mimd_t ioctl packet. Convert it to uioc_t.&n;&t; */
r_if
c_cond
(paren
(paren
id|rval
op_assign
id|mimd_to_kioc
c_func
(paren
id|argp
comma
id|adp
comma
id|kioc
)paren
)paren
)paren
(brace
id|mraid_mm_dealloc_kioc
c_func
(paren
id|adp
comma
id|kioc
)paren
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
id|kioc-&gt;done
op_assign
id|ioctl_done
suffix:semicolon
multiline_comment|/*&n;&t; * Issue the IOCTL to the low level driver. After the IOCTL completes&n;&t; * release the kioc if and only if it was _not_ timedout. If it was&n;&t; * timedout, that means that resources are still with low level driver.&n;&t; */
r_if
c_cond
(paren
(paren
id|rval
op_assign
id|lld_ioctl
c_func
(paren
id|adp
comma
id|kioc
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|kioc-&gt;timedout
)paren
id|mraid_mm_dealloc_kioc
c_func
(paren
id|adp
comma
id|kioc
)paren
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Convert the kioc back to user space&n;&t; */
id|rval
op_assign
id|kioc_to_mimd
c_func
(paren
id|kioc
comma
id|argp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Return the kioc to free pool&n;&t; */
id|mraid_mm_dealloc_kioc
c_func
(paren
id|adp
comma
id|kioc
)paren
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/**&n; * mraid_mm_get_adapter - Returns corresponding adapters for the mimd packet&n; * @umimd&t;: User space mimd_t ioctl packet&n; * @adapter&t;: pointer to the adapter (OUT)&n; */
r_static
id|mraid_mmadp_t
op_star
DECL|function|mraid_mm_get_adapter
id|mraid_mm_get_adapter
c_func
(paren
id|mimd_t
id|__user
op_star
id|umimd
comma
r_int
op_star
id|rval
)paren
(brace
id|mraid_mmadp_t
op_star
id|adapter
suffix:semicolon
id|mimd_t
id|mimd
suffix:semicolon
r_uint32
id|adapno
suffix:semicolon
r_int
id|iterator
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|mimd
comma
id|umimd
comma
r_sizeof
(paren
id|mimd_t
)paren
)paren
)paren
(brace
op_star
id|rval
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|adapno
op_assign
id|GETADAP
c_func
(paren
id|mimd.ui.fcs.adapno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|adapno
op_ge
id|adapters_count_g
)paren
(brace
op_star
id|rval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|adapter
op_assign
l_int|NULL
suffix:semicolon
id|iterator
op_assign
l_int|0
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|adapter
comma
op_amp
id|adapters_list_g
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|iterator
op_increment
op_eq
id|adapno
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|adapter
)paren
(brace
op_star
id|rval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|adapter
suffix:semicolon
)brace
multiline_comment|/*&n; * handle_drvrcmd - This routine checks if the opcode is a driver&n; * &t;&t;&t;  cmd and if it is, handles it.&n; * @arg&t;&t;: packet sent by the user app&n; * @old_ioctl&t;: mimd if 1; uioc otherwise&n; */
r_static
r_int
DECL|function|handle_drvrcmd
id|handle_drvrcmd
c_func
(paren
r_void
id|__user
op_star
id|arg
comma
r_uint8
id|old_ioctl
comma
r_int
op_star
id|rval
)paren
(brace
id|mimd_t
id|__user
op_star
id|umimd
suffix:semicolon
id|mimd_t
id|kmimd
suffix:semicolon
r_uint8
id|opcode
suffix:semicolon
r_uint8
id|subopcode
suffix:semicolon
r_if
c_cond
(paren
id|old_ioctl
)paren
r_goto
id|old_packet
suffix:semicolon
r_else
r_goto
id|new_packet
suffix:semicolon
id|new_packet
suffix:colon
r_return
(paren
op_minus
id|ENOTSUPP
)paren
suffix:semicolon
id|old_packet
suffix:colon
op_star
id|rval
op_assign
l_int|0
suffix:semicolon
id|umimd
op_assign
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|kmimd
comma
id|umimd
comma
r_sizeof
(paren
id|mimd_t
)paren
)paren
)paren
r_return
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
id|opcode
op_assign
id|kmimd.ui.fcs.opcode
suffix:semicolon
id|subopcode
op_assign
id|kmimd.ui.fcs.subopcode
suffix:semicolon
multiline_comment|/*&n;&t; * If the opcode is 0x82 and the subopcode is either GET_DRVRVER or&n;&t; * GET_NUMADP, then we can handle. Otherwise we should return 1 to&n;&t; * indicate that we cannot handle this.&n;&t; */
r_if
c_cond
(paren
id|opcode
op_ne
l_int|0x82
)paren
r_return
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|subopcode
)paren
(brace
r_case
id|MEGAIOC_QDRVRVER
suffix:colon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|kmimd.data
comma
op_amp
id|drvr_ver
comma
r_sizeof
(paren
r_uint32
)paren
)paren
)paren
r_return
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|MEGAIOC_QNADAP
suffix:colon
op_star
id|rval
op_assign
id|adapters_count_g
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|kmimd.data
comma
op_amp
id|adapters_count_g
comma
r_sizeof
(paren
r_uint32
)paren
)paren
)paren
r_return
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* cannot handle */
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * mimd_to_kioc&t;- Converter from old to new ioctl format&n; *&n; * @umimd&t;: user space old MIMD IOCTL&n; * @kioc&t;: kernel space new format IOCTL&n; *&n; * Routine to convert MIMD interface IOCTL to new interface IOCTL packet. The&n; * new packet is in kernel space so that driver can perform operations on it&n; * freely.&n; */
r_static
r_int
DECL|function|mimd_to_kioc
id|mimd_to_kioc
c_func
(paren
id|mimd_t
id|__user
op_star
id|umimd
comma
id|mraid_mmadp_t
op_star
id|adp
comma
id|uioc_t
op_star
id|kioc
)paren
(brace
id|mbox64_t
op_star
id|mbox64
suffix:semicolon
id|mbox_t
op_star
id|mbox
suffix:semicolon
id|mraid_passthru_t
op_star
id|pthru32
suffix:semicolon
r_uint32
id|adapno
suffix:semicolon
r_uint8
id|opcode
suffix:semicolon
r_uint8
id|subopcode
suffix:semicolon
id|mimd_t
id|mimd
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|mimd
comma
id|umimd
comma
r_sizeof
(paren
id|mimd_t
)paren
)paren
)paren
r_return
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Applications are not allowed to send extd pthru&n;&t; */
r_if
c_cond
(paren
(paren
id|mimd.mbox
(braket
l_int|0
)braket
op_eq
id|MBOXCMD_PASSTHRU64
)paren
op_logical_or
(paren
id|mimd.mbox
(braket
l_int|0
)braket
op_eq
id|MBOXCMD_EXTPTHRU
)paren
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
id|opcode
op_assign
id|mimd.ui.fcs.opcode
suffix:semicolon
id|subopcode
op_assign
id|mimd.ui.fcs.subopcode
suffix:semicolon
id|adapno
op_assign
id|GETADAP
c_func
(paren
id|mimd.ui.fcs.adapno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|adapno
op_ge
id|adapters_count_g
)paren
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
id|kioc-&gt;adapno
op_assign
id|adapno
suffix:semicolon
id|kioc-&gt;mb_type
op_assign
id|MBOX_LEGACY
suffix:semicolon
id|kioc-&gt;app_type
op_assign
id|APPTYPE_MIMD
suffix:semicolon
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_case
l_int|0x82
suffix:colon
r_if
c_cond
(paren
id|subopcode
op_eq
id|MEGAIOC_QADAPINFO
)paren
(brace
id|kioc-&gt;opcode
op_assign
id|GET_ADAP_INFO
suffix:semicolon
id|kioc-&gt;data_dir
op_assign
id|UIOC_RD
suffix:semicolon
id|kioc-&gt;xferlen
op_assign
r_sizeof
(paren
id|mraid_hba_info_t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mraid_mm_attach_buf
c_func
(paren
id|adp
comma
id|kioc
comma
id|kioc-&gt;xferlen
)paren
)paren
r_return
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
r_else
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid cmm: Invalid subop&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0x81
suffix:colon
id|kioc-&gt;opcode
op_assign
id|MBOX_CMD
suffix:semicolon
id|kioc-&gt;xferlen
op_assign
id|mimd.ui.fcs.length
suffix:semicolon
id|kioc-&gt;user_data_len
op_assign
id|kioc-&gt;xferlen
suffix:semicolon
id|kioc-&gt;user_data
op_assign
id|mimd.ui.fcs.buffer
suffix:semicolon
r_if
c_cond
(paren
id|mraid_mm_attach_buf
c_func
(paren
id|adp
comma
id|kioc
comma
id|kioc-&gt;xferlen
)paren
)paren
r_return
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mimd.outlen
)paren
id|kioc-&gt;data_dir
op_assign
id|UIOC_RD
suffix:semicolon
r_if
c_cond
(paren
id|mimd.inlen
)paren
id|kioc-&gt;data_dir
op_or_assign
id|UIOC_WR
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x80
suffix:colon
id|kioc-&gt;opcode
op_assign
id|MBOX_CMD
suffix:semicolon
id|kioc-&gt;xferlen
op_assign
(paren
id|mimd.outlen
OG
id|mimd.inlen
)paren
ques
c_cond
id|mimd.outlen
suffix:colon
id|mimd.inlen
suffix:semicolon
id|kioc-&gt;user_data_len
op_assign
id|kioc-&gt;xferlen
suffix:semicolon
id|kioc-&gt;user_data
op_assign
id|mimd.data
suffix:semicolon
r_if
c_cond
(paren
id|mraid_mm_attach_buf
c_func
(paren
id|adp
comma
id|kioc
comma
id|kioc-&gt;xferlen
)paren
)paren
r_return
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mimd.outlen
)paren
id|kioc-&gt;data_dir
op_assign
id|UIOC_RD
suffix:semicolon
r_if
c_cond
(paren
id|mimd.inlen
)paren
id|kioc-&gt;data_dir
op_or_assign
id|UIOC_WR
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If driver command, nothing else to do&n;&t; */
r_if
c_cond
(paren
id|opcode
op_eq
l_int|0x82
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * This is a mailbox cmd; copy the mailbox from mimd&n;&t; */
id|mbox64
op_assign
(paren
id|mbox64_t
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|kioc-&gt;cmdbuf
)paren
suffix:semicolon
id|mbox
op_assign
op_amp
id|mbox64-&gt;mbox32
suffix:semicolon
id|memcpy
c_func
(paren
id|mbox
comma
id|mimd.mbox
comma
l_int|14
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mbox-&gt;cmd
op_ne
id|MBOXCMD_PASSTHRU
)paren
(brace
singleline_comment|// regular DCMD
id|mbox-&gt;xferaddr
op_assign
(paren
r_uint32
)paren
id|kioc-&gt;buf_paddr
suffix:semicolon
r_if
c_cond
(paren
id|kioc-&gt;data_dir
op_amp
id|UIOC_WR
)paren
(brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|kioc-&gt;buf_vaddr
comma
id|kioc-&gt;user_data
comma
id|kioc-&gt;xferlen
)paren
)paren
(brace
r_return
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * This is a regular 32-bit pthru cmd; mbox points to pthru struct.&n;&t; * Just like in above case, the beginning for memblk is treated as&n;&t; * a mailbox. The passthru will begin at next 1K boundary. And the&n;&t; * data will start 1K after that.&n;&t; */
id|pthru32
op_assign
id|kioc-&gt;pthru32
suffix:semicolon
id|kioc-&gt;user_pthru
op_assign
op_amp
id|umimd-&gt;pthru
suffix:semicolon
id|mbox-&gt;xferaddr
op_assign
(paren
r_uint32
)paren
id|kioc-&gt;pthru32_h
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|pthru32
comma
id|kioc-&gt;user_pthru
comma
r_sizeof
(paren
id|mraid_passthru_t
)paren
)paren
)paren
(brace
r_return
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
)brace
id|pthru32-&gt;dataxferaddr
op_assign
id|kioc-&gt;buf_paddr
suffix:semicolon
r_if
c_cond
(paren
id|kioc-&gt;data_dir
op_amp
id|UIOC_WR
)paren
(brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|kioc-&gt;buf_vaddr
comma
id|kioc-&gt;user_data
comma
id|pthru32-&gt;dataxferlen
)paren
)paren
(brace
r_return
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * mraid_mm_attch_buf - Attach a free dma buffer for required size&n; *&n; * @adp&t;&t;: Adapter softstate&n; * @kioc&t;: kioc that the buffer needs to be attached to&n; * @xferlen&t;: required length for buffer&n; *&n; * First we search for a pool with smallest buffer that is &gt;= @xferlen. If&n; * that pool has no free buffer, we will try for the next bigger size. If none&n; * is available, we will try to allocate the smallest buffer that is &gt;=&n; * @xferlen and attach it the pool.&n; */
r_static
r_int
DECL|function|mraid_mm_attach_buf
id|mraid_mm_attach_buf
c_func
(paren
id|mraid_mmadp_t
op_star
id|adp
comma
id|uioc_t
op_star
id|kioc
comma
r_int
id|xferlen
)paren
(brace
id|mm_dmapool_t
op_star
id|pool
suffix:semicolon
r_int
id|right_pool
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
id|kioc-&gt;pool_index
op_assign
op_minus
l_int|1
suffix:semicolon
id|kioc-&gt;buf_vaddr
op_assign
l_int|NULL
suffix:semicolon
id|kioc-&gt;buf_paddr
op_assign
l_int|0
suffix:semicolon
id|kioc-&gt;free_buf
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * We need xferlen amount of memory. See if we can get it from our&n;&t; * dma pools. If we don&squot;t get exact size, we will try bigger buffer&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_DMA_POOLS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pool
op_assign
op_amp
id|adp-&gt;dma_pool_list
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|xferlen
OG
id|pool-&gt;buf_size
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|right_pool
op_eq
op_minus
l_int|1
)paren
id|right_pool
op_assign
id|i
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pool-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pool-&gt;in_use
)paren
(brace
id|pool-&gt;in_use
op_assign
l_int|1
suffix:semicolon
id|kioc-&gt;pool_index
op_assign
id|i
suffix:semicolon
id|kioc-&gt;buf_vaddr
op_assign
id|pool-&gt;vaddr
suffix:semicolon
id|kioc-&gt;buf_paddr
op_assign
id|pool-&gt;paddr
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pool-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pool-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If xferlen doesn&squot;t match any of our pools, return error&n;&t; */
r_if
c_cond
(paren
id|right_pool
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * We did not get any buffer from the preallocated pool. Let us try&n;&t; * to allocate one new buffer. NOTE: This is a blocking call.&n;&t; */
id|pool
op_assign
op_amp
id|adp-&gt;dma_pool_list
(braket
id|right_pool
)braket
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pool-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|kioc-&gt;pool_index
op_assign
id|right_pool
suffix:semicolon
id|kioc-&gt;free_buf
op_assign
l_int|1
suffix:semicolon
id|kioc-&gt;buf_vaddr
op_assign
id|pci_pool_alloc
c_func
(paren
id|pool-&gt;handle
comma
id|GFP_KERNEL
comma
op_amp
id|kioc-&gt;buf_paddr
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pool-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kioc-&gt;buf_vaddr
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * mraid_mm_alloc_kioc - Returns a uioc_t from free list&n; * @adp&t;: Adapter softstate for this module&n; *&n; * The kioc_semaphore is initialized with number of kioc nodes in the&n; * free kioc pool. If the kioc pool is empty, this function blocks till&n; * a kioc becomes free.&n; */
r_static
id|uioc_t
op_star
DECL|function|mraid_mm_alloc_kioc
id|mraid_mm_alloc_kioc
c_func
(paren
id|mraid_mmadp_t
op_star
id|adp
)paren
(brace
id|uioc_t
op_star
id|kioc
suffix:semicolon
r_struct
id|list_head
op_star
id|head
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|down
c_func
(paren
op_amp
id|adp-&gt;kioc_semaphore
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|adp-&gt;kioc_pool_lock
comma
id|flags
)paren
suffix:semicolon
id|head
op_assign
op_amp
id|adp-&gt;kioc_pool
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
id|head
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|adp-&gt;kioc_semaphore
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|adp-&gt;kioc_pool_lock
comma
id|flags
)paren
suffix:semicolon
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
l_string|&quot;megaraid cmm: kioc list empty!&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|kioc
op_assign
id|list_entry
c_func
(paren
id|head-&gt;next
comma
id|uioc_t
comma
id|list
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|kioc-&gt;list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|adp-&gt;kioc_pool_lock
comma
id|flags
)paren
suffix:semicolon
id|memset
c_func
(paren
(paren
id|caddr_t
)paren
(paren
r_int
r_int
)paren
id|kioc-&gt;cmdbuf
comma
l_int|0
comma
r_sizeof
(paren
id|mbox64_t
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
(paren
id|caddr_t
)paren
id|kioc-&gt;pthru32
comma
l_int|0
comma
r_sizeof
(paren
id|mraid_passthru_t
)paren
)paren
suffix:semicolon
id|kioc-&gt;buf_vaddr
op_assign
l_int|NULL
suffix:semicolon
id|kioc-&gt;buf_paddr
op_assign
l_int|0
suffix:semicolon
id|kioc-&gt;pool_index
op_assign
op_minus
l_int|1
suffix:semicolon
id|kioc-&gt;free_buf
op_assign
l_int|0
suffix:semicolon
id|kioc-&gt;user_data
op_assign
l_int|NULL
suffix:semicolon
id|kioc-&gt;user_data_len
op_assign
l_int|0
suffix:semicolon
id|kioc-&gt;user_pthru
op_assign
l_int|NULL
suffix:semicolon
id|kioc-&gt;timedout
op_assign
l_int|0
suffix:semicolon
r_return
id|kioc
suffix:semicolon
)brace
multiline_comment|/**&n; * mraid_mm_dealloc_kioc - Return kioc to free pool&n; *&n; * @adp&t;&t;: Adapter softstate&n; * @kioc&t;: uioc_t node to be returned to free pool&n; */
r_static
r_void
DECL|function|mraid_mm_dealloc_kioc
id|mraid_mm_dealloc_kioc
c_func
(paren
id|mraid_mmadp_t
op_star
id|adp
comma
id|uioc_t
op_star
id|kioc
)paren
(brace
id|mm_dmapool_t
op_star
id|pool
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|pool
op_assign
op_amp
id|adp-&gt;dma_pool_list
(braket
id|kioc-&gt;pool_index
)braket
suffix:semicolon
multiline_comment|/* This routine may be called in non-isr context also */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pool-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * While attaching the dma buffer, if we didn&squot;t get the required&n;&t; * buffer from the pool, we would have allocated it at the run time&n;&t; * and set the free_buf flag. We must free that buffer. Otherwise,&n;&t; * just mark that the buffer is not in use&n;&t; */
r_if
c_cond
(paren
id|kioc-&gt;free_buf
op_eq
l_int|1
)paren
id|pci_pool_free
c_func
(paren
id|pool-&gt;handle
comma
id|kioc-&gt;buf_vaddr
comma
id|kioc-&gt;buf_paddr
)paren
suffix:semicolon
r_else
id|pool-&gt;in_use
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pool-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Return the kioc to the free pool */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|adp-&gt;kioc_pool_lock
comma
id|flags
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|kioc-&gt;list
comma
op_amp
id|adp-&gt;kioc_pool
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|adp-&gt;kioc_pool_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* increment the free kioc count */
id|up
c_func
(paren
op_amp
id|adp-&gt;kioc_semaphore
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * lld_ioctl - Routine to issue ioctl to low level drvr&n; *&n; * @adp&t;&t;: The adapter handle&n; * @kioc&t;: The ioctl packet with kernel addresses&n; */
r_static
r_int
DECL|function|lld_ioctl
id|lld_ioctl
c_func
(paren
id|mraid_mmadp_t
op_star
id|adp
comma
id|uioc_t
op_star
id|kioc
)paren
(brace
r_int
id|rval
suffix:semicolon
r_struct
id|timer_list
id|timer
suffix:semicolon
r_struct
id|timer_list
op_star
id|tp
op_assign
l_int|NULL
suffix:semicolon
id|kioc-&gt;status
op_assign
op_minus
id|ENODATA
suffix:semicolon
id|rval
op_assign
id|adp
op_member_access_from_pointer
id|issue_uioc
c_func
(paren
id|adp-&gt;drvr_data
comma
id|kioc
comma
id|IOCTL_ISSUE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rval
)paren
r_return
id|rval
suffix:semicolon
multiline_comment|/*&n;&t; * Start the timer&n;&t; */
r_if
c_cond
(paren
id|adp-&gt;timeout
OG
l_int|0
)paren
(brace
id|tp
op_assign
op_amp
id|timer
suffix:semicolon
id|init_timer
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tp-&gt;function
op_assign
id|lld_timedout
suffix:semicolon
id|tp-&gt;data
op_assign
(paren
r_int
r_int
)paren
id|kioc
suffix:semicolon
id|tp-&gt;expires
op_assign
id|jiffies
op_plus
id|adp-&gt;timeout
op_star
id|HZ
suffix:semicolon
id|add_timer
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Wait till the low level driver completes the ioctl. After this&n;&t; * call, the ioctl either completed successfully or timedout.&n;&t; */
id|wait_event
c_func
(paren
id|wait_q
comma
(paren
id|kioc-&gt;status
op_ne
op_minus
id|ENODATA
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp
)paren
(brace
id|del_timer_sync
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the command had timedout, we mark the controller offline&n;&t; * before returning&n;&t; */
r_if
c_cond
(paren
id|kioc-&gt;timedout
)paren
(brace
id|adp-&gt;quiescent
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|kioc-&gt;status
suffix:semicolon
)brace
multiline_comment|/**&n; * ioctl_done - callback from the low level driver&n; *&n; * @kioc&t;: completed ioctl packet&n; */
r_static
r_void
DECL|function|ioctl_done
id|ioctl_done
c_func
(paren
id|uioc_t
op_star
id|kioc
)paren
(brace
r_uint32
id|adapno
suffix:semicolon
r_int
id|iterator
suffix:semicolon
id|mraid_mmadp_t
op_star
id|adapter
suffix:semicolon
multiline_comment|/*&n;&t; * When the kioc returns from driver, make sure it still doesn&squot;t&n;&t; * have ENODATA in status. Otherwise, driver will hang on wait_event&n;&t; * forever&n;&t; */
r_if
c_cond
(paren
id|kioc-&gt;status
op_eq
op_minus
id|ENODATA
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid cmm: lld didn&squot;t change status!&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|kioc-&gt;status
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check if this kioc was timedout before. If so, nobody is waiting&n;&t; * on this kioc. We don&squot;t have to wake up anybody. Instead, we just&n;&t; * have to free the kioc&n;&t; */
r_if
c_cond
(paren
id|kioc-&gt;timedout
)paren
(brace
id|iterator
op_assign
l_int|0
suffix:semicolon
id|adapter
op_assign
l_int|NULL
suffix:semicolon
id|adapno
op_assign
id|kioc-&gt;adapno
suffix:semicolon
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid cmm: completed &quot;
l_string|&quot;ioctl that was timedout before&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|adapter
comma
op_amp
id|adapters_list_g
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|iterator
op_increment
op_eq
id|adapno
)paren
r_break
suffix:semicolon
)brace
id|kioc-&gt;timedout
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|adapter
)paren
(brace
id|mraid_mm_dealloc_kioc
c_func
(paren
id|adapter
comma
id|kioc
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|wake_up
c_func
(paren
op_amp
id|wait_q
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * lld_timedout&t;: callback from the expired timer&n; *&n; * @ptr&t;&t;: ioctl packet that timed out&n; */
r_static
r_void
DECL|function|lld_timedout
id|lld_timedout
c_func
(paren
r_int
r_int
id|ptr
)paren
(brace
id|uioc_t
op_star
id|kioc
op_assign
(paren
id|uioc_t
op_star
)paren
id|ptr
suffix:semicolon
id|kioc-&gt;status
op_assign
op_minus
id|ETIME
suffix:semicolon
id|kioc-&gt;timedout
op_assign
l_int|1
suffix:semicolon
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid cmm: ioctl timed out&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|wait_q
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * kioc_to_mimd&t;: Converter from new back to old format&n; *&n; * @kioc&t;: Kernel space IOCTL packet (successfully issued)&n; * @mimd&t;: User space MIMD packet&n; */
r_static
r_int
DECL|function|kioc_to_mimd
id|kioc_to_mimd
c_func
(paren
id|uioc_t
op_star
id|kioc
comma
id|mimd_t
id|__user
op_star
id|mimd
)paren
(brace
id|mimd_t
id|kmimd
suffix:semicolon
r_uint8
id|opcode
suffix:semicolon
r_uint8
id|subopcode
suffix:semicolon
id|mbox64_t
op_star
id|mbox64
suffix:semicolon
id|mraid_passthru_t
id|__user
op_star
id|upthru32
suffix:semicolon
id|mraid_passthru_t
op_star
id|kpthru32
suffix:semicolon
id|mcontroller_t
id|cinfo
suffix:semicolon
id|mraid_hba_info_t
op_star
id|hinfo
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|kmimd
comma
id|mimd
comma
r_sizeof
(paren
id|mimd_t
)paren
)paren
)paren
r_return
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
id|opcode
op_assign
id|kmimd.ui.fcs.opcode
suffix:semicolon
id|subopcode
op_assign
id|kmimd.ui.fcs.subopcode
suffix:semicolon
r_if
c_cond
(paren
id|opcode
op_eq
l_int|0x82
)paren
(brace
r_switch
c_cond
(paren
id|subopcode
)paren
(brace
r_case
id|MEGAIOC_QADAPINFO
suffix:colon
id|hinfo
op_assign
(paren
id|mraid_hba_info_t
op_star
)paren
(paren
r_int
r_int
)paren
id|kioc-&gt;buf_vaddr
suffix:semicolon
id|hinfo_to_cinfo
c_func
(paren
id|hinfo
comma
op_amp
id|cinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|kmimd.data
comma
op_amp
id|cinfo
comma
r_sizeof
(paren
id|cinfo
)paren
)paren
)paren
r_return
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|mbox64
op_assign
(paren
id|mbox64_t
op_star
)paren
(paren
r_int
r_int
)paren
id|kioc-&gt;cmdbuf
suffix:semicolon
r_if
c_cond
(paren
id|kioc-&gt;user_pthru
)paren
(brace
id|upthru32
op_assign
id|kioc-&gt;user_pthru
suffix:semicolon
id|kpthru32
op_assign
id|kioc-&gt;pthru32
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
op_amp
id|upthru32-&gt;scsistatus
comma
op_amp
id|kpthru32-&gt;scsistatus
comma
r_sizeof
(paren
r_uint8
)paren
)paren
)paren
(brace
r_return
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|kioc-&gt;user_data
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|kioc-&gt;user_data
comma
id|kioc-&gt;buf_vaddr
comma
id|kioc-&gt;user_data_len
)paren
)paren
(brace
r_return
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
op_amp
id|mimd-&gt;mbox
(braket
l_int|17
)braket
comma
op_amp
id|mbox64-&gt;mbox32.status
comma
r_sizeof
(paren
r_uint8
)paren
)paren
)paren
(brace
r_return
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * hinfo_to_cinfo - Convert new format hba info into old format&n; *&n; * @hinfo&t;: New format, more comprehensive adapter info&n; * @cinfo&t;: Old format adapter info to support mimd_t apps&n; */
r_static
r_void
DECL|function|hinfo_to_cinfo
id|hinfo_to_cinfo
c_func
(paren
id|mraid_hba_info_t
op_star
id|hinfo
comma
id|mcontroller_t
op_star
id|cinfo
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|hinfo
op_logical_or
op_logical_neg
id|cinfo
)paren
r_return
suffix:semicolon
id|cinfo-&gt;base
op_assign
id|hinfo-&gt;baseport
suffix:semicolon
id|cinfo-&gt;irq
op_assign
id|hinfo-&gt;irq
suffix:semicolon
id|cinfo-&gt;numldrv
op_assign
id|hinfo-&gt;num_ldrv
suffix:semicolon
id|cinfo-&gt;pcibus
op_assign
id|hinfo-&gt;pci_bus
suffix:semicolon
id|cinfo-&gt;pcidev
op_assign
id|hinfo-&gt;pci_slot
suffix:semicolon
id|cinfo-&gt;pcifun
op_assign
id|PCI_FUNC
c_func
(paren
id|hinfo-&gt;pci_dev_fn
)paren
suffix:semicolon
id|cinfo-&gt;pciid
op_assign
id|hinfo-&gt;pci_device_id
suffix:semicolon
id|cinfo-&gt;pcivendor
op_assign
id|hinfo-&gt;pci_vendor_id
suffix:semicolon
id|cinfo-&gt;pcislot
op_assign
id|hinfo-&gt;pci_slot
suffix:semicolon
id|cinfo-&gt;uid
op_assign
id|hinfo-&gt;unique_id
suffix:semicolon
)brace
multiline_comment|/*&n; * mraid_mm_register_adp - Registration routine for low level drvrs&n; *&n; * @adp&t;: Adapter objejct&n; */
r_int
DECL|function|mraid_mm_register_adp
id|mraid_mm_register_adp
c_func
(paren
id|mraid_mmadp_t
op_star
id|lld_adp
)paren
(brace
id|mraid_mmadp_t
op_star
id|adapter
suffix:semicolon
id|mbox64_t
op_star
id|mbox_list
suffix:semicolon
id|uioc_t
op_star
id|kioc
suffix:semicolon
r_uint32
id|rval
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|lld_adp-&gt;drvr_type
op_ne
id|DRVRTYPE_MBOX
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
id|adapter
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|mraid_mmadp_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|adapter
)paren
(brace
id|rval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|memalloc_error
suffix:semicolon
)brace
id|memset
c_func
(paren
id|adapter
comma
l_int|0
comma
r_sizeof
(paren
id|mraid_mmadp_t
)paren
)paren
suffix:semicolon
id|adapter-&gt;unique_id
op_assign
id|lld_adp-&gt;unique_id
suffix:semicolon
id|adapter-&gt;drvr_type
op_assign
id|lld_adp-&gt;drvr_type
suffix:semicolon
id|adapter-&gt;drvr_data
op_assign
id|lld_adp-&gt;drvr_data
suffix:semicolon
id|adapter-&gt;pdev
op_assign
id|lld_adp-&gt;pdev
suffix:semicolon
id|adapter-&gt;issue_uioc
op_assign
id|lld_adp-&gt;issue_uioc
suffix:semicolon
id|adapter-&gt;timeout
op_assign
id|lld_adp-&gt;timeout
suffix:semicolon
id|adapter-&gt;max_kioc
op_assign
id|lld_adp-&gt;max_kioc
suffix:semicolon
id|adapter-&gt;quiescent
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate single blocks of memory for all required kiocs,&n;&t; * mailboxes and passthru structures.&n;&t; */
id|adapter-&gt;kioc_list
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|uioc_t
)paren
op_star
id|lld_adp-&gt;max_kioc
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|adapter-&gt;mbox_list
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|mbox64_t
)paren
op_star
id|lld_adp-&gt;max_kioc
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|adapter-&gt;pthru_dma_pool
op_assign
id|pci_pool_create
c_func
(paren
l_string|&quot;megaraid mm pthru pool&quot;
comma
id|adapter-&gt;pdev
comma
r_sizeof
(paren
id|mraid_passthru_t
)paren
comma
l_int|16
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|adapter-&gt;kioc_list
op_logical_or
op_logical_neg
id|adapter-&gt;mbox_list
op_logical_or
op_logical_neg
id|adapter-&gt;pthru_dma_pool
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid cmm: out of memory, %s %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|__LINE__
)paren
)paren
suffix:semicolon
id|rval
op_assign
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
r_goto
id|memalloc_error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Slice kioc_list and make a kioc_pool with the individiual kiocs&n;&t; */
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|adapter-&gt;kioc_pool
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|adapter-&gt;kioc_pool_lock
)paren
suffix:semicolon
id|sema_init
c_func
(paren
op_amp
id|adapter-&gt;kioc_semaphore
comma
id|lld_adp-&gt;max_kioc
)paren
suffix:semicolon
id|mbox_list
op_assign
(paren
id|mbox64_t
op_star
)paren
id|adapter-&gt;mbox_list
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lld_adp-&gt;max_kioc
suffix:semicolon
id|i
op_increment
)paren
(brace
id|kioc
op_assign
id|adapter-&gt;kioc_list
op_plus
id|i
suffix:semicolon
id|kioc-&gt;cmdbuf
op_assign
(paren
r_uint64
)paren
(paren
r_int
r_int
)paren
(paren
id|mbox_list
op_plus
id|i
)paren
suffix:semicolon
id|kioc-&gt;pthru32
op_assign
id|pci_pool_alloc
c_func
(paren
id|adapter-&gt;pthru_dma_pool
comma
id|GFP_KERNEL
comma
op_amp
id|kioc-&gt;pthru32_h
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kioc-&gt;pthru32
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid cmm: out of memory, %s %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|__LINE__
)paren
)paren
suffix:semicolon
id|rval
op_assign
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
r_goto
id|pthru_dma_pool_error
suffix:semicolon
)brace
id|list_add_tail
c_func
(paren
op_amp
id|kioc-&gt;list
comma
op_amp
id|adapter-&gt;kioc_pool
)paren
suffix:semicolon
)brace
singleline_comment|// Setup the dma pools for data buffers
r_if
c_cond
(paren
(paren
id|rval
op_assign
id|mraid_mm_setup_dma_pools
c_func
(paren
id|adapter
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_goto
id|dma_pool_error
suffix:semicolon
)brace
id|list_add_tail
c_func
(paren
op_amp
id|adapter-&gt;list
comma
op_amp
id|adapters_list_g
)paren
suffix:semicolon
id|adapters_count_g
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|dma_pool_error
suffix:colon
multiline_comment|/* Do nothing */
id|pthru_dma_pool_error
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lld_adp-&gt;max_kioc
suffix:semicolon
id|i
op_increment
)paren
(brace
id|kioc
op_assign
id|adapter-&gt;kioc_list
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|kioc-&gt;pthru32
)paren
(brace
id|pci_pool_free
c_func
(paren
id|adapter-&gt;pthru_dma_pool
comma
id|kioc-&gt;pthru32
comma
id|kioc-&gt;pthru32_h
)paren
suffix:semicolon
)brace
)brace
id|memalloc_error
suffix:colon
r_if
c_cond
(paren
id|adapter-&gt;kioc_list
)paren
id|kfree
c_func
(paren
id|adapter-&gt;kioc_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|adapter-&gt;mbox_list
)paren
id|kfree
c_func
(paren
id|adapter-&gt;mbox_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|adapter-&gt;pthru_dma_pool
)paren
id|pci_pool_destroy
c_func
(paren
id|adapter-&gt;pthru_dma_pool
)paren
suffix:semicolon
r_if
c_cond
(paren
id|adapter
)paren
id|kfree
c_func
(paren
id|adapter
)paren
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/**&n; * mraid_mm_setup_dma_pools - Set up dma buffer pools per adapter&n; *&n; * @adp&t;: Adapter softstate&n; *&n; * We maintain a pool of dma buffers per each adapter. Each pool has one&n; * buffer. E.g, we may have 5 dma pools - one each for 4k, 8k ... 64k buffers.&n; * We have just one 4k buffer in 4k pool, one 8k buffer in 8k pool etc. We&n; * dont&squot; want to waste too much memory by allocating more buffers per each&n; * pool.&n; */
r_static
r_int
DECL|function|mraid_mm_setup_dma_pools
id|mraid_mm_setup_dma_pools
c_func
(paren
id|mraid_mmadp_t
op_star
id|adp
)paren
(brace
id|mm_dmapool_t
op_star
id|pool
suffix:semicolon
r_int
id|bufsize
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * Create MAX_DMA_POOLS number of pools&n;&t; */
id|bufsize
op_assign
id|MRAID_MM_INIT_BUFF_SIZE
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_DMA_POOLS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pool
op_assign
op_amp
id|adp-&gt;dma_pool_list
(braket
id|i
)braket
suffix:semicolon
id|pool-&gt;buf_size
op_assign
id|bufsize
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|pool-&gt;lock
)paren
suffix:semicolon
id|pool-&gt;handle
op_assign
id|pci_pool_create
c_func
(paren
l_string|&quot;megaraid mm data buffer&quot;
comma
id|adp-&gt;pdev
comma
id|bufsize
comma
l_int|16
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pool-&gt;handle
)paren
(brace
r_goto
id|dma_pool_setup_error
suffix:semicolon
)brace
id|pool-&gt;vaddr
op_assign
id|pci_pool_alloc
c_func
(paren
id|pool-&gt;handle
comma
id|GFP_KERNEL
comma
op_amp
id|pool-&gt;paddr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pool-&gt;vaddr
)paren
r_goto
id|dma_pool_setup_error
suffix:semicolon
id|bufsize
op_assign
id|bufsize
op_star
l_int|2
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|dma_pool_setup_error
suffix:colon
id|mraid_mm_teardown_dma_pools
c_func
(paren
id|adp
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * mraid_mm_unregister_adp - Unregister routine for low level drivers&n; *&t;&t;&t;&t;  Assume no outstanding ioctls to llds.&n; *&n; * @unique_id&t;: UID of the adpater&n; */
r_int
DECL|function|mraid_mm_unregister_adp
id|mraid_mm_unregister_adp
c_func
(paren
r_uint32
id|unique_id
)paren
(brace
id|mraid_mmadp_t
op_star
id|adapter
suffix:semicolon
id|mraid_mmadp_t
op_star
id|tmp
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|adapter
comma
id|tmp
comma
op_amp
id|adapters_list_g
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|adapter-&gt;unique_id
op_eq
id|unique_id
)paren
(brace
id|adapters_count_g
op_decrement
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|adapter-&gt;list
)paren
suffix:semicolon
id|mraid_mm_free_adp_resources
c_func
(paren
id|adapter
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|adapter
)paren
suffix:semicolon
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
l_string|&quot;megaraid cmm: Unregistered one adapter:%#x&bslash;n&quot;
comma
id|unique_id
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * mraid_mm_free_adp_resources - Free adapter softstate&n; *&n; * @adp&t;: Adapter softstate&n; */
r_static
r_void
DECL|function|mraid_mm_free_adp_resources
id|mraid_mm_free_adp_resources
c_func
(paren
id|mraid_mmadp_t
op_star
id|adp
)paren
(brace
id|uioc_t
op_star
id|kioc
suffix:semicolon
r_int
id|i
suffix:semicolon
id|mraid_mm_teardown_dma_pools
c_func
(paren
id|adp
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|adp-&gt;max_kioc
suffix:semicolon
id|i
op_increment
)paren
(brace
id|kioc
op_assign
id|adp-&gt;kioc_list
op_plus
id|i
suffix:semicolon
id|pci_pool_free
c_func
(paren
id|adp-&gt;pthru_dma_pool
comma
id|kioc-&gt;pthru32
comma
id|kioc-&gt;pthru32_h
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|adp-&gt;kioc_list
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|adp-&gt;mbox_list
)paren
suffix:semicolon
id|pci_pool_destroy
c_func
(paren
id|adp-&gt;pthru_dma_pool
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * mraid_mm_teardown_dma_pools - Free all per adapter dma buffers&n; *&n; * @adp&t;: Adapter softstate&n; */
r_static
r_void
DECL|function|mraid_mm_teardown_dma_pools
id|mraid_mm_teardown_dma_pools
c_func
(paren
id|mraid_mmadp_t
op_star
id|adp
)paren
(brace
r_int
id|i
suffix:semicolon
id|mm_dmapool_t
op_star
id|pool
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_DMA_POOLS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pool
op_assign
op_amp
id|adp-&gt;dma_pool_list
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pool-&gt;handle
)paren
(brace
r_if
c_cond
(paren
id|pool-&gt;vaddr
)paren
id|pci_pool_free
c_func
(paren
id|pool-&gt;handle
comma
id|pool-&gt;vaddr
comma
id|pool-&gt;paddr
)paren
suffix:semicolon
id|pci_pool_destroy
c_func
(paren
id|pool-&gt;handle
)paren
suffix:semicolon
id|pool-&gt;handle
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * mraid_mm_init&t;: Module entry point&n; */
r_static
r_int
id|__init
DECL|function|mraid_mm_init
id|mraid_mm_init
c_func
(paren
r_void
)paren
(brace
singleline_comment|// Announce the driver version
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_INFO
l_string|&quot;megaraid cmm: %s %s&bslash;n&quot;
comma
id|LSI_COMMON_MOD_VERSION
comma
id|LSI_COMMON_MOD_EXT_VERSION
)paren
)paren
suffix:semicolon
id|majorno
op_assign
id|register_chrdev
c_func
(paren
l_int|0
comma
l_string|&quot;megadev&quot;
comma
op_amp
id|lsi_fops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|majorno
OL
l_int|0
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
l_string|&quot;megaraid cmm: cannot get major&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|majorno
suffix:semicolon
)brace
id|init_waitqueue_head
c_func
(paren
op_amp
id|wait_q
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|adapters_list_g
)paren
suffix:semicolon
id|register_ioctl32_conversion
c_func
(paren
id|MEGAIOCCMD
comma
id|mraid_mm_compat_ioctl
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * mraid_mm_compat_ioctl&t;: 32bit to 64bit ioctl conversion routine&n; */
macro_line|#ifdef CONFIG_COMPAT
r_static
r_int
DECL|function|mraid_mm_compat_ioctl
id|mraid_mm_compat_ioctl
c_func
(paren
r_int
r_int
id|fd
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
comma
r_struct
id|file
op_star
id|filep
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|filep-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_return
id|mraid_mm_ioctl
c_func
(paren
id|inode
comma
id|filep
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/**&n; * mraid_mm_exit&t;: Module exit point&n; */
r_static
r_void
id|__exit
DECL|function|mraid_mm_exit
id|mraid_mm_exit
c_func
(paren
r_void
)paren
(brace
id|con_log
c_func
(paren
id|CL_DLEVEL1
comma
(paren
l_string|&quot;exiting common mod&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|unregister_chrdev
c_func
(paren
id|majorno
comma
l_string|&quot;megadev&quot;
)paren
suffix:semicolon
id|unregister_ioctl32_conversion
c_func
(paren
id|MEGAIOCCMD
)paren
suffix:semicolon
)brace
DECL|variable|mraid_mm_init
id|module_init
c_func
(paren
id|mraid_mm_init
)paren
suffix:semicolon
DECL|variable|mraid_mm_exit
id|module_exit
c_func
(paren
id|mraid_mm_exit
)paren
suffix:semicolon
multiline_comment|/* vi: set ts=8 sw=8 tw=78: */
eof
