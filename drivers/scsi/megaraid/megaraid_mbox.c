multiline_comment|/*&n; *&n; *&t;&t;&t;Linux MegaRAID device driver&n; *&n; * Copyright (c) 2003-2004  LSI Logic Corporation.&n; *&n; *&t;   This program is free software; you can redistribute it and/or&n; *&t;   modify it under the terms of the GNU General Public License&n; *&t;   as published by the Free Software Foundation; either version&n; *&t;   2 of the License, or (at your option) any later version.&n; *&n; * FILE&t;&t;: megaraid_mbox.c&n; * Version&t;: v2.20.4.1 (Nov 04 2004)&n; *&n; * Authors:&n; * &t;Atul Mukker&t;&t;&lt;Atul.Mukker@lsil.com&gt;&n; * &t;Sreenivas Bagalkote&t;&lt;Sreenivas.Bagalkote@lsil.com&gt;&n; * &t;Manoj Jose&t;&t;&lt;Manoj.Jose@lsil.com&gt;&n; *&n; * List of supported controllers&n; *&n; * OEM&t;Product Name&t;&t;&t;VID&t;DID&t;SSVID&t;SSID&n; * ---&t;------------&t;&t;&t;---&t;---&t;----&t;----&n; * Dell PERC3/QC&t;&t;&t;101E&t;1960&t;1028&t;0471&n; * Dell PERC3/DC&t;&t;&t;101E&t;1960&t;1028&t;0493&n; * Dell PERC3/SC&t;&t;&t;101E&t;1960&t;1028&t;0475&n; * Dell PERC3/Di&t;&t;&t;1028&t;1960&t;1028&t;0123&n; * Dell PERC4/SC&t;&t;&t;1000&t;1960&t;1028&t;0520&n; * Dell PERC4/DC&t;&t;&t;1000&t;1960&t;1028&t;0518&n; * Dell PERC4/QC&t;&t;&t;1000&t;0407&t;1028&t;0531&n; * Dell PERC4/Di&t;&t;&t;1028&t;000F&t;1028&t;014A&n; * Dell PERC 4e/Si&t;&t;&t;1028&t;0013&t;1028&t;016c&n; * Dell PERC 4e/Di&t;&t;&t;1028&t;0013&t;1028&t;016d&n; * Dell PERC 4e/Di&t;&t;&t;1028&t;0013&t;1028&t;016e&n; * Dell PERC 4e/Di&t;&t;&t;1028&t;0013&t;1028&t;016f&n; * Dell PERC 4e/Di&t;&t;&t;1028&t;0013&t;1028&t;0170&n; * Dell PERC 4e/DC&t;&t;&t;1000&t;0408&t;1028&t;0002&n; * Dell PERC 4e/SC&t;&t;&t;1000&t;0408&t;1028&t;0001&n; *&n; *&n; * LSI MegaRAID SCSI 320-0&t;&t;1000&t;1960&t;1000&t;A520&n; * LSI MegaRAID SCSI 320-1&t;&t;1000&t;1960&t;1000&t;0520&n; * LSI MegaRAID SCSI 320-2&t;&t;1000&t;1960&t;1000&t;0518&n; * LSI MegaRAID SCSI 320-0X&t;&t;1000&t;0407&t;1000&t;0530&n; * LSI MegaRAID SCSI 320-2X&t;&t;1000&t;0407&t;1000&t;0532&n; * LSI MegaRAID SCSI 320-4X&t;&t;1000&t;0407&t;1000&t;0531&n; * LSI MegaRAID SCSI 320-1E&t;&t;1000&t;0408&t;1000&t;0001&n; * LSI MegaRAID SCSI 320-2E&t;&t;1000&t;0408&t;1000&t;0002&n; * LSI MegaRAID SATA 150-4&t;&t;1000&t;1960&t;1000&t;4523&n; * LSI MegaRAID SATA 150-6&t;&t;1000&t;1960&t;1000&t;0523&n; * LSI MegaRAID SATA 300-4X&t;&t;1000&t;0409&t;1000&t;3004&n; * LSI MegaRAID SATA 300-8X&t;&t;1000&t;0409&t;1000&t;3008&n; *&n; * INTEL RAID Controller SRCU42X&t;1000&t;0407&t;8086&t;0532&n; * INTEL RAID Controller SRCS16&t;&t;1000&t;1960&t;8086&t;0523&n; * INTEL RAID Controller SRCU42E&t;1000&t;0408&t;8086&t;0002&n; * INTEL RAID Controller SRCZCRX&t;1000&t;0407&t;8086&t;0530&n; * INTEL RAID Controller SRCS28X&t;1000&t;0409&t;8086&t;3008&n; * INTEL RAID Controller SROMBU42E&t;1000&t;0408&t;8086&t;3431&n; * INTEL RAID Controller SROMBU42E&t;1000&t;0408&t;8086&t;3499&n; * INTEL RAID Controller SRCU51L&t;1000&t;1960&t;8086&t;0520&n; *&n; *&n; * FSC&t;MegaRAID PCI Express ROMB&t;1000&t;0408&t;1734&t;1065&n; *&n; *&n; * ACER&t;MegaRAID ROMB-2E&t;&t;1000&t;0408&t;1025&t;004D&n; *&n; *&n; * For history of changes, see Documentation/ChangeLog.megaraid&n; */
macro_line|#include &quot;megaraid_mbox.h&quot;
r_static
r_int
id|megaraid_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|megaraid_exit
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|megaraid_probe_one
c_func
(paren
r_struct
id|pci_dev
op_star
comma
r_const
r_struct
id|pci_device_id
op_star
)paren
suffix:semicolon
r_static
r_void
id|megaraid_detach_one
c_func
(paren
r_struct
id|pci_dev
op_star
)paren
suffix:semicolon
r_static
r_void
id|megaraid_mbox_shutdown
c_func
(paren
r_struct
id|device
op_star
)paren
suffix:semicolon
r_static
r_int
id|megaraid_io_attach
c_func
(paren
id|adapter_t
op_star
)paren
suffix:semicolon
r_static
r_void
id|megaraid_io_detach
c_func
(paren
id|adapter_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|megaraid_init_mbox
c_func
(paren
id|adapter_t
op_star
)paren
suffix:semicolon
r_static
r_void
id|megaraid_fini_mbox
c_func
(paren
id|adapter_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|megaraid_alloc_cmd_packets
c_func
(paren
id|adapter_t
op_star
)paren
suffix:semicolon
r_static
r_void
id|megaraid_free_cmd_packets
c_func
(paren
id|adapter_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|megaraid_mbox_setup_dma_pools
c_func
(paren
id|adapter_t
op_star
)paren
suffix:semicolon
r_static
r_void
id|megaraid_mbox_teardown_dma_pools
c_func
(paren
id|adapter_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|megaraid_abort_handler
c_func
(paren
r_struct
id|scsi_cmnd
op_star
)paren
suffix:semicolon
r_static
r_int
id|megaraid_reset_handler
c_func
(paren
r_struct
id|scsi_cmnd
op_star
)paren
suffix:semicolon
r_static
r_int
id|mbox_post_sync_cmd
c_func
(paren
id|adapter_t
op_star
comma
r_uint8
(braket
)braket
)paren
suffix:semicolon
r_static
r_int
id|mbox_post_sync_cmd_fast
c_func
(paren
id|adapter_t
op_star
comma
r_uint8
(braket
)braket
)paren
suffix:semicolon
r_static
r_int
id|megaraid_busywait_mbox
c_func
(paren
id|mraid_device_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|megaraid_mbox_product_info
c_func
(paren
id|adapter_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|megaraid_mbox_extended_cdb
c_func
(paren
id|adapter_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|megaraid_mbox_support_ha
c_func
(paren
id|adapter_t
op_star
comma
r_uint16
op_star
)paren
suffix:semicolon
r_static
r_int
id|megaraid_mbox_support_random_del
c_func
(paren
id|adapter_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|megaraid_mbox_get_max_sg
c_func
(paren
id|adapter_t
op_star
)paren
suffix:semicolon
r_static
r_void
id|megaraid_mbox_enum_raid_scsi
c_func
(paren
id|adapter_t
op_star
)paren
suffix:semicolon
r_static
r_void
id|megaraid_mbox_flush_cache
c_func
(paren
id|adapter_t
op_star
)paren
suffix:semicolon
r_static
r_void
id|megaraid_mbox_display_scb
c_func
(paren
id|adapter_t
op_star
comma
id|scb_t
op_star
)paren
suffix:semicolon
r_static
r_void
id|megaraid_mbox_setup_device_map
c_func
(paren
id|adapter_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|megaraid_queue_command
c_func
(paren
r_struct
id|scsi_cmnd
op_star
comma
r_void
(paren
op_star
)paren
(paren
r_struct
id|scsi_cmnd
op_star
)paren
)paren
suffix:semicolon
r_static
id|scb_t
op_star
id|megaraid_mbox_build_cmd
c_func
(paren
id|adapter_t
op_star
comma
r_struct
id|scsi_cmnd
op_star
comma
r_int
op_star
)paren
suffix:semicolon
r_static
r_void
id|megaraid_mbox_runpendq
c_func
(paren
id|adapter_t
op_star
comma
id|scb_t
op_star
)paren
suffix:semicolon
r_static
r_void
id|megaraid_mbox_prepare_pthru
c_func
(paren
id|adapter_t
op_star
comma
id|scb_t
op_star
comma
r_struct
id|scsi_cmnd
op_star
)paren
suffix:semicolon
r_static
r_void
id|megaraid_mbox_prepare_epthru
c_func
(paren
id|adapter_t
op_star
comma
id|scb_t
op_star
comma
r_struct
id|scsi_cmnd
op_star
)paren
suffix:semicolon
r_static
id|irqreturn_t
id|megaraid_isr
c_func
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_static
r_void
id|megaraid_mbox_dpc
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_int
id|megaraid_cmm_register
c_func
(paren
id|adapter_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|megaraid_cmm_unregister
c_func
(paren
id|adapter_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|megaraid_mbox_mm_handler
c_func
(paren
r_int
r_int
comma
id|uioc_t
op_star
comma
r_uint32
)paren
suffix:semicolon
r_static
r_int
id|megaraid_mbox_mm_command
c_func
(paren
id|adapter_t
op_star
comma
id|uioc_t
op_star
)paren
suffix:semicolon
r_static
r_void
id|megaraid_mbox_mm_done
c_func
(paren
id|adapter_t
op_star
comma
id|scb_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|gather_hbainfo
c_func
(paren
id|adapter_t
op_star
comma
id|mraid_hba_info_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|wait_till_fw_empty
c_func
(paren
id|adapter_t
op_star
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;LSI Logic Corporation&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;LSI Logic MegaRAID Mailbox Driver&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|variable|MEGARAID_VERSION
id|MODULE_VERSION
c_func
(paren
id|MEGARAID_VERSION
)paren
suffix:semicolon
multiline_comment|/*&n; * ### modules parameters for driver ###&n; */
multiline_comment|/**&n; * Set to enable driver to expose unconfigured disk to kernel&n; */
DECL|variable|megaraid_expose_unconf_disks
r_static
r_int
id|megaraid_expose_unconf_disks
op_assign
l_int|0
suffix:semicolon
id|module_param_named
c_func
(paren
id|unconf_disks
comma
id|megaraid_expose_unconf_disks
comma
r_int
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|unconf_disks
comma
l_string|&quot;Set to expose unconfigured disks to kernel (default=0)&quot;
)paren
suffix:semicolon
multiline_comment|/**&n; * driver wait time if the adapter&squot;s mailbox is busy&n; */
DECL|variable|max_mbox_busy_wait
r_static
r_int
r_int
id|max_mbox_busy_wait
op_assign
id|MBOX_BUSY_WAIT
suffix:semicolon
id|module_param_named
c_func
(paren
id|busy_wait
comma
id|max_mbox_busy_wait
comma
r_int
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|busy_wait
comma
l_string|&quot;Max wait for mailbox in microseconds if busy (default=10)&quot;
)paren
suffix:semicolon
multiline_comment|/**&n; * number of sectors per IO command&n; */
DECL|variable|megaraid_max_sectors
r_static
r_int
r_int
id|megaraid_max_sectors
op_assign
id|MBOX_MAX_SECTORS
suffix:semicolon
id|module_param_named
c_func
(paren
id|max_sectors
comma
id|megaraid_max_sectors
comma
r_int
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|max_sectors
comma
l_string|&quot;Maximum number of sectors per IO command (default=128)&quot;
)paren
suffix:semicolon
multiline_comment|/**&n; * number of commands per logical unit&n; */
DECL|variable|megaraid_cmd_per_lun
r_static
r_int
r_int
id|megaraid_cmd_per_lun
op_assign
id|MBOX_DEF_CMD_PER_LUN
suffix:semicolon
id|module_param_named
c_func
(paren
id|cmd_per_lun
comma
id|megaraid_cmd_per_lun
comma
r_int
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|cmd_per_lun
comma
l_string|&quot;Maximum number of commands per logical unit (default=64)&quot;
)paren
suffix:semicolon
multiline_comment|/**&n; * Fast driver load option, skip scanning for physical devices during load.&n; * This would result in non-disk devices being skipped during driver load&n; * time. These can be later added though, using /proc/scsi/scsi&n; */
DECL|variable|megaraid_fast_load
r_static
r_int
r_int
id|megaraid_fast_load
op_assign
l_int|0
suffix:semicolon
id|module_param_named
c_func
(paren
id|fast_load
comma
id|megaraid_fast_load
comma
r_int
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|fast_load
comma
l_string|&quot;Faster loading of the driver, skips physical devices! (default=0)&quot;
)paren
suffix:semicolon
multiline_comment|/**&n; * mraid_debug level - threshold for amount of information to be displayed by&n; * the driver. This level can be changed through modules parameters, ioctl or&n; * sysfs/proc interface. By default, print the announcement messages only.&n; */
DECL|variable|mraid_debug_level
r_int
id|mraid_debug_level
op_assign
id|CL_ANN
suffix:semicolon
id|module_param_named
c_func
(paren
id|debug_level
comma
id|mraid_debug_level
comma
r_int
comma
l_int|0
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|debug_level
comma
l_string|&quot;Debug level for driver (default=0)&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * ### global data ###&n; */
DECL|variable|megaraid_mbox_version
r_static
r_uint8
id|megaraid_mbox_version
(braket
l_int|8
)braket
op_assign
(brace
l_int|0x02
comma
l_int|0x20
comma
l_int|0x04
comma
l_int|0x00
comma
l_int|9
comma
l_int|27
comma
l_int|20
comma
l_int|4
)brace
suffix:semicolon
multiline_comment|/*&n; * PCI table for all supported controllers.&n; */
DECL|variable|pci_id_table_g
r_static
r_struct
id|pci_device_id
id|pci_id_table_g
(braket
)braket
op_assign
(brace
(brace
id|PCI_VENDOR_ID_DELL
comma
id|PCI_DEVICE_ID_PERC4_DI_DISCOVERY
comma
id|PCI_VENDOR_ID_DELL
comma
id|PCI_SUBSYS_ID_PERC4_DI_DISCOVERY
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_PERC4_SC
comma
id|PCI_VENDOR_ID_DELL
comma
id|PCI_SUBSYS_ID_PERC4_SC
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_PERC4_DC
comma
id|PCI_VENDOR_ID_DELL
comma
id|PCI_SUBSYS_ID_PERC4_DC
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_PERC4_QC
comma
id|PCI_VENDOR_ID_DELL
comma
id|PCI_SUBSYS_ID_PERC4_QC
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_DELL
comma
id|PCI_DEVICE_ID_PERC4_DI_EVERGLADES
comma
id|PCI_VENDOR_ID_DELL
comma
id|PCI_SUBSYS_ID_PERC4_DI_EVERGLADES
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_DELL
comma
id|PCI_DEVICE_ID_PERC4E_SI_BIGBEND
comma
id|PCI_VENDOR_ID_DELL
comma
id|PCI_SUBSYS_ID_PERC4E_SI_BIGBEND
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_DELL
comma
id|PCI_DEVICE_ID_PERC4E_DI_KOBUK
comma
id|PCI_VENDOR_ID_DELL
comma
id|PCI_SUBSYS_ID_PERC4E_DI_KOBUK
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_DELL
comma
id|PCI_DEVICE_ID_PERC4E_DI_CORVETTE
comma
id|PCI_VENDOR_ID_DELL
comma
id|PCI_SUBSYS_ID_PERC4E_DI_CORVETTE
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_DELL
comma
id|PCI_DEVICE_ID_PERC4E_DI_EXPEDITION
comma
id|PCI_VENDOR_ID_DELL
comma
id|PCI_SUBSYS_ID_PERC4E_DI_EXPEDITION
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_DELL
comma
id|PCI_DEVICE_ID_PERC4E_DI_GUADALUPE
comma
id|PCI_VENDOR_ID_DELL
comma
id|PCI_SUBSYS_ID_PERC4E_DI_GUADALUPE
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_PERC4E_DC_320_2E
comma
id|PCI_VENDOR_ID_DELL
comma
id|PCI_SUBSYS_ID_PERC4E_DC_320_2E
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_PERC4E_SC_320_1E
comma
id|PCI_VENDOR_ID_DELL
comma
id|PCI_SUBSYS_ID_PERC4E_SC_320_1E
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_AMI
comma
id|PCI_DEVICE_ID_AMI_MEGARAID3
comma
id|PCI_VENDOR_ID_DELL
comma
id|PCI_SUBSYS_ID_PERC3_QC
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_AMI
comma
id|PCI_DEVICE_ID_AMI_MEGARAID3
comma
id|PCI_VENDOR_ID_DELL
comma
id|PCI_SUBSYS_ID_PERC3_DC
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_AMI
comma
id|PCI_DEVICE_ID_AMI_MEGARAID3
comma
id|PCI_VENDOR_ID_DELL
comma
id|PCI_SUBSYS_ID_PERC3_SC
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_AMI
comma
id|PCI_DEVICE_ID_AMI_MEGARAID3
comma
id|PCI_VENDOR_ID_AMI
comma
id|PCI_SUBSYS_ID_PERC3_SC
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_MEGARAID_SCSI_320_0
comma
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_SUBSYS_ID_MEGARAID_SCSI_320_0
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_MEGARAID_SCSI_320_1
comma
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_SUBSYS_ID_MEGARAID_SCSI_320_1
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_MEGARAID_SCSI_320_2
comma
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_SUBSYS_ID_MEGARAID_SCSI_320_2
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_MEGARAID_SCSI_320_0x
comma
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_SUBSYS_ID_MEGARAID_SCSI_320_0x
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_MEGARAID_SCSI_320_2x
comma
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_SUBSYS_ID_MEGARAID_SCSI_320_2x
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_MEGARAID_SCSI_320_4x
comma
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_SUBSYS_ID_MEGARAID_SCSI_320_4x
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_MEGARAID_SCSI_320_1E
comma
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_SUBSYS_ID_MEGARAID_SCSI_320_1E
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_MEGARAID_SCSI_320_2E
comma
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_SUBSYS_ID_MEGARAID_SCSI_320_2E
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_MEGARAID_I4_133_RAID
comma
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_SUBSYS_ID_MEGARAID_I4_133_RAID
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_MEGARAID_SATA_150_4
comma
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_SUBSYS_ID_MEGARAID_SATA_150_4
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_MEGARAID_SATA_150_6
comma
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_SUBSYS_ID_MEGARAID_SATA_150_6
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_MEGARAID_SATA_300_4x
comma
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_SUBSYS_ID_MEGARAID_SATA_300_4x
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_MEGARAID_SATA_300_8x
comma
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_SUBSYS_ID_MEGARAID_SATA_300_8x
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_INTEL_RAID_SRCU42X
comma
id|PCI_VENDOR_ID_INTEL
comma
id|PCI_SUBSYS_ID_INTEL_RAID_SRCU42X
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_INTEL_RAID_SRCS16
comma
id|PCI_VENDOR_ID_INTEL
comma
id|PCI_SUBSYS_ID_INTEL_RAID_SRCS16
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_INTEL_RAID_SRCU42E
comma
id|PCI_VENDOR_ID_INTEL
comma
id|PCI_SUBSYS_ID_INTEL_RAID_SRCU42E
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_INTEL_RAID_SRCZCRX
comma
id|PCI_VENDOR_ID_INTEL
comma
id|PCI_SUBSYS_ID_INTEL_RAID_SRCZCRX
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_INTEL_RAID_SRCS28X
comma
id|PCI_VENDOR_ID_INTEL
comma
id|PCI_SUBSYS_ID_INTEL_RAID_SRCS28X
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_INTEL_RAID_SROMBU42E_ALIEF
comma
id|PCI_VENDOR_ID_INTEL
comma
id|PCI_SUBSYS_ID_INTEL_RAID_SROMBU42E_ALIEF
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_INTEL_RAID_SROMBU42E_HARWICH
comma
id|PCI_VENDOR_ID_INTEL
comma
id|PCI_SUBSYS_ID_INTEL_RAID_SROMBU42E_HARWICH
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_INTEL_RAID_SRCU41L_LAKE_SHETEK
comma
id|PCI_VENDOR_ID_INTEL
comma
id|PCI_SUBSYS_ID_INTEL_RAID_SRCU41L_LAKE_SHETEK
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_FSC_MEGARAID_PCI_EXPRESS_ROMB
comma
id|PCI_SUBSYS_ID_FSC
comma
id|PCI_SUBSYS_ID_FSC_MEGARAID_PCI_EXPRESS_ROMB
comma
)brace
comma
(brace
id|PCI_VENDOR_ID_LSI_LOGIC
comma
id|PCI_DEVICE_ID_MEGARAID_ACER_ROMB_2E
comma
id|PCI_VENDOR_ID_AI
comma
id|PCI_SUBSYS_ID_MEGARAID_ACER_ROMB_2E
comma
)brace
comma
(brace
l_int|0
)brace
multiline_comment|/* Terminating entry */
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
c_func
(paren
id|pci
comma
id|pci_id_table_g
)paren
suffix:semicolon
DECL|variable|megaraid_pci_driver_g
r_static
r_struct
id|pci_driver
id|megaraid_pci_driver_g
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;megaraid&quot;
comma
dot
id|id_table
op_assign
id|pci_id_table_g
comma
dot
id|probe
op_assign
id|megaraid_probe_one
comma
dot
id|remove
op_assign
id|__devexit_p
c_func
(paren
id|megaraid_detach_one
)paren
comma
dot
id|driver
op_assign
(brace
dot
id|shutdown
op_assign
id|megaraid_mbox_shutdown
comma
)brace
)brace
suffix:semicolon
multiline_comment|/*&n; * Scsi host template for megaraid unified driver&n; */
DECL|variable|megaraid_template_g
r_static
r_struct
id|scsi_host_template
id|megaraid_template_g
op_assign
(brace
dot
id|module
op_assign
id|THIS_MODULE
comma
dot
id|name
op_assign
l_string|&quot;LSI Logic MegaRAID driver&quot;
comma
dot
id|proc_name
op_assign
l_string|&quot;megaraid&quot;
comma
dot
id|queuecommand
op_assign
id|megaraid_queue_command
comma
dot
id|eh_abort_handler
op_assign
id|megaraid_abort_handler
comma
dot
id|eh_device_reset_handler
op_assign
id|megaraid_reset_handler
comma
dot
id|eh_bus_reset_handler
op_assign
id|megaraid_reset_handler
comma
dot
id|eh_host_reset_handler
op_assign
id|megaraid_reset_handler
comma
dot
id|use_clustering
op_assign
id|ENABLE_CLUSTERING
comma
)brace
suffix:semicolon
multiline_comment|/**&n; * megaraid_init - module load hook&n; *&n; * We register ourselves as hotplug enabled module and let PCI subsystem&n; * discover our adaters&n; **/
r_static
r_int
id|__init
DECL|function|megaraid_init
id|megaraid_init
c_func
(paren
r_void
)paren
(brace
r_int
id|rval
suffix:semicolon
singleline_comment|// Announce the driver version
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_INFO
l_string|&quot;megaraid: %s %s&bslash;n&quot;
comma
id|MEGARAID_VERSION
comma
id|MEGARAID_EXT_VERSION
)paren
)paren
suffix:semicolon
singleline_comment|// check validity of module parameters
r_if
c_cond
(paren
id|megaraid_cmd_per_lun
OG
id|MBOX_MAX_SCSI_CMDS
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid mailbox: max commands per lun reset to %d&bslash;n&quot;
comma
id|MBOX_MAX_SCSI_CMDS
)paren
)paren
suffix:semicolon
id|megaraid_cmd_per_lun
op_assign
id|MBOX_MAX_SCSI_CMDS
suffix:semicolon
)brace
singleline_comment|// register as a PCI hot-plug driver module
r_if
c_cond
(paren
(paren
id|rval
op_assign
id|pci_module_init
c_func
(paren
op_amp
id|megaraid_pci_driver_g
)paren
)paren
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid: could not register hotplug support.&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_exit - driver unload entry point&n; *&n; * We simply unwrap the megaraid_init routine here&n; */
r_static
r_void
id|__exit
DECL|function|megaraid_exit
id|megaraid_exit
c_func
(paren
r_void
)paren
(brace
id|con_log
c_func
(paren
id|CL_DLEVEL1
comma
(paren
id|KERN_NOTICE
l_string|&quot;megaraid: unloading framework&bslash;n&quot;
)paren
)paren
suffix:semicolon
singleline_comment|// unregister as PCI hotplug driver
id|pci_unregister_driver
c_func
(paren
op_amp
id|megaraid_pci_driver_g
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_probe_one - PCI hotplug entry point&n; * @param pdev&t;: handle to this controller&squot;s PCI configuration space&n; * @param id&t;: pci device id of the class of controllers&n; *&n; * This routine should be called whenever a new adapter is detected by the&n; * PCI hotplug susbsytem.&n; **/
r_static
r_int
id|__devinit
DECL|function|megaraid_probe_one
id|megaraid_probe_one
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_const
r_struct
id|pci_device_id
op_star
id|id
)paren
(brace
id|adapter_t
op_star
id|adapter
suffix:semicolon
singleline_comment|// detected a new controller
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_INFO
l_string|&quot;megaraid: probe new device %#4.04x:%#4.04x:%#4.04x:%#4.04x: &quot;
comma
id|pdev-&gt;vendor
comma
id|pdev-&gt;device
comma
id|pdev-&gt;subsystem_vendor
comma
id|pdev-&gt;subsystem_device
)paren
)paren
suffix:semicolon
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
l_string|&quot;bus %d:slot %d:func %d&bslash;n&quot;
comma
id|pdev-&gt;bus-&gt;number
comma
id|PCI_SLOT
c_func
(paren
id|pdev-&gt;devfn
)paren
comma
id|PCI_FUNC
c_func
(paren
id|pdev-&gt;devfn
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|pdev
)paren
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid: pci_enable_device failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
singleline_comment|// Enable bus-mastering on this controller
id|pci_set_master
c_func
(paren
id|pdev
)paren
suffix:semicolon
singleline_comment|// Allocate the per driver initialization structure
id|adapter
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|adapter_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|adapter
op_eq
l_int|NULL
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid: out of memory, %s %d.&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|__LINE__
)paren
)paren
suffix:semicolon
r_goto
id|out_probe_one
suffix:semicolon
)brace
id|memset
c_func
(paren
id|adapter
comma
l_int|0
comma
r_sizeof
(paren
id|adapter_t
)paren
)paren
suffix:semicolon
singleline_comment|// set up PCI related soft state and other pre-known parameters
id|adapter-&gt;unique_id
op_assign
id|pdev-&gt;bus-&gt;number
op_lshift
l_int|8
op_or
id|pdev-&gt;devfn
suffix:semicolon
id|adapter-&gt;irq
op_assign
id|pdev-&gt;irq
suffix:semicolon
id|adapter-&gt;pdev
op_assign
id|pdev
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|adapter-&gt;being_detached
comma
l_int|0
)paren
suffix:semicolon
singleline_comment|// Setup the default DMA mask. This would be changed later on
singleline_comment|// depending on hardware capabilities
r_if
c_cond
(paren
id|pci_set_dma_mask
c_func
(paren
id|adapter-&gt;pdev
comma
l_int|0xFFFFFFFF
)paren
op_ne
l_int|0
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid: pci_set_dma_mask failed:%d&bslash;n&quot;
comma
id|__LINE__
)paren
)paren
suffix:semicolon
r_goto
id|out_free_adapter
suffix:semicolon
)brace
singleline_comment|// Initialize the synchronization lock for kernel and LLD
id|spin_lock_init
c_func
(paren
op_amp
id|adapter-&gt;lock
)paren
suffix:semicolon
id|adapter-&gt;host_lock
op_assign
op_amp
id|adapter-&gt;lock
suffix:semicolon
singleline_comment|// Initialize the command queues: the list of free SCBs and the list
singleline_comment|// of pending SCBs.
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|adapter-&gt;kscb_pool
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
id|SCSI_FREE_LIST_LOCK
c_func
(paren
id|adapter
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|adapter-&gt;pend_list
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
id|PENDING_LIST_LOCK
c_func
(paren
id|adapter
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|adapter-&gt;completed_list
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
id|COMPLETED_LIST_LOCK
c_func
(paren
id|adapter
)paren
)paren
suffix:semicolon
singleline_comment|// Start the mailbox based controller
r_if
c_cond
(paren
id|megaraid_init_mbox
c_func
(paren
id|adapter
)paren
op_ne
l_int|0
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid: maibox adapter did not initialize&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_goto
id|out_free_adapter
suffix:semicolon
)brace
singleline_comment|// Register with LSI Common Management Module
r_if
c_cond
(paren
id|megaraid_cmm_register
c_func
(paren
id|adapter
)paren
op_ne
l_int|0
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid: could not register with management module&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_goto
id|out_fini_mbox
suffix:semicolon
)brace
singleline_comment|// setup adapter handle in PCI soft state
id|pci_set_drvdata
c_func
(paren
id|pdev
comma
id|adapter
)paren
suffix:semicolon
singleline_comment|// attach with scsi mid-layer
r_if
c_cond
(paren
id|megaraid_io_attach
c_func
(paren
id|adapter
)paren
op_ne
l_int|0
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid: io attach failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_goto
id|out_cmm_unreg
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|out_cmm_unreg
suffix:colon
id|pci_set_drvdata
c_func
(paren
id|pdev
comma
l_int|NULL
)paren
suffix:semicolon
id|megaraid_cmm_unregister
c_func
(paren
id|adapter
)paren
suffix:semicolon
id|out_fini_mbox
suffix:colon
id|megaraid_fini_mbox
c_func
(paren
id|adapter
)paren
suffix:semicolon
id|out_free_adapter
suffix:colon
id|kfree
c_func
(paren
id|adapter
)paren
suffix:semicolon
id|out_probe_one
suffix:colon
id|pci_disable_device
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_detach_one - release the framework resources and call LLD release&n; * routine&n; * @param pdev&t;: handle for our PCI cofiguration space&n; *&n; * This routine is called during driver unload. We free all the allocated&n; * resources and call the corresponding LLD so that it can also release all&n; * its resources.&n; *&n; * This routine is also called from the PCI hotplug system&n; **/
r_static
r_void
DECL|function|megaraid_detach_one
id|megaraid_detach_one
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
)paren
(brace
id|adapter_t
op_star
id|adapter
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
singleline_comment|// Start a rollback on this adapter
id|adapter
op_assign
id|pci_get_drvdata
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|adapter
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_CRIT
l_string|&quot;megaraid: Invalid detach on %#4.04x:%#4.04x:%#4.04x:%#4.04x&bslash;n&quot;
comma
id|pdev-&gt;vendor
comma
id|pdev-&gt;device
comma
id|pdev-&gt;subsystem_vendor
comma
id|pdev-&gt;subsystem_device
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_NOTICE
l_string|&quot;megaraid: detaching device %#4.04x:%#4.04x:%#4.04x:%#4.04x&bslash;n&quot;
comma
id|pdev-&gt;vendor
comma
id|pdev-&gt;device
comma
id|pdev-&gt;subsystem_vendor
comma
id|pdev-&gt;subsystem_device
)paren
)paren
suffix:semicolon
)brace
id|host
op_assign
id|adapter-&gt;host
suffix:semicolon
singleline_comment|// do not allow any more requests from the management module for this
singleline_comment|// adapter.
singleline_comment|// FIXME: How do we account for the request which might still be
singleline_comment|// pending with us?
id|atomic_set
c_func
(paren
op_amp
id|adapter-&gt;being_detached
comma
l_int|1
)paren
suffix:semicolon
singleline_comment|// detach from the IO sub-system
id|megaraid_io_detach
c_func
(paren
id|adapter
)paren
suffix:semicolon
singleline_comment|// reset the device state in the PCI structure. We check this
singleline_comment|// condition when we enter here. If the device state is NULL,
singleline_comment|// that would mean the device has already been removed
id|pci_set_drvdata
c_func
(paren
id|pdev
comma
l_int|NULL
)paren
suffix:semicolon
singleline_comment|// Unregister from common management module
singleline_comment|//
singleline_comment|// FIXME: this must return success or failure for conditions if there
singleline_comment|// is a command pending with LLD or not.
id|megaraid_cmm_unregister
c_func
(paren
id|adapter
)paren
suffix:semicolon
singleline_comment|// finalize the mailbox based controller and release all resources
id|megaraid_fini_mbox
c_func
(paren
id|adapter
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|adapter
)paren
suffix:semicolon
id|scsi_host_put
c_func
(paren
id|host
)paren
suffix:semicolon
id|pci_disable_device
c_func
(paren
id|pdev
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_mbox_shutdown - PCI shutdown for megaraid HBA&n; * @param device&t;: generice driver model device&n; *&n; * Shutdown notification, perform flush cache&n; */
r_static
r_void
DECL|function|megaraid_mbox_shutdown
id|megaraid_mbox_shutdown
c_func
(paren
r_struct
id|device
op_star
id|device
)paren
(brace
id|adapter_t
op_star
id|adapter
op_assign
id|pci_get_drvdata
c_func
(paren
id|to_pci_dev
c_func
(paren
id|device
)paren
)paren
suffix:semicolon
r_static
r_int
id|counter
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|adapter
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid: null device in shutdown&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
singleline_comment|// flush caches now
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_INFO
l_string|&quot;megaraid: flushing adapter %d...&quot;
comma
id|counter
op_increment
)paren
)paren
suffix:semicolon
id|megaraid_mbox_flush_cache
c_func
(paren
id|adapter
)paren
suffix:semicolon
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
l_string|&quot;done&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_io_attach - attach a device with the IO subsystem&n; * @param adapter&t;: controller&squot;s soft state&n; *&n; * Attach this device with the IO subsystem&n; **/
r_static
r_int
DECL|function|megaraid_io_attach
id|megaraid_io_attach
c_func
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
singleline_comment|// Initialize SCSI Host structure
id|host
op_assign
id|scsi_host_alloc
c_func
(paren
op_amp
id|megaraid_template_g
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|host
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid mbox: scsi_register failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|SCSIHOST2ADAP
c_func
(paren
id|host
)paren
op_assign
(paren
id|caddr_t
)paren
id|adapter
suffix:semicolon
id|adapter-&gt;host
op_assign
id|host
suffix:semicolon
singleline_comment|// export the parameters required by the mid-layer
id|scsi_assign_lock
c_func
(paren
id|host
comma
id|adapter-&gt;host_lock
)paren
suffix:semicolon
id|scsi_set_device
c_func
(paren
id|host
comma
op_amp
id|adapter-&gt;pdev-&gt;dev
)paren
suffix:semicolon
id|host-&gt;irq
op_assign
id|adapter-&gt;irq
suffix:semicolon
id|host-&gt;unique_id
op_assign
id|adapter-&gt;unique_id
suffix:semicolon
id|host-&gt;can_queue
op_assign
id|adapter-&gt;max_cmds
suffix:semicolon
id|host-&gt;this_id
op_assign
id|adapter-&gt;init_id
suffix:semicolon
id|host-&gt;sg_tablesize
op_assign
id|adapter-&gt;sglen
suffix:semicolon
id|host-&gt;max_sectors
op_assign
id|adapter-&gt;max_sectors
suffix:semicolon
id|host-&gt;cmd_per_lun
op_assign
id|adapter-&gt;cmd_per_lun
suffix:semicolon
id|host-&gt;max_channel
op_assign
id|adapter-&gt;max_channel
suffix:semicolon
id|host-&gt;max_id
op_assign
id|adapter-&gt;max_target
suffix:semicolon
id|host-&gt;max_lun
op_assign
id|adapter-&gt;max_lun
suffix:semicolon
singleline_comment|// notify mid-layer about the new controller
r_if
c_cond
(paren
id|scsi_add_host
c_func
(paren
id|host
comma
op_amp
id|adapter-&gt;pdev-&gt;dev
)paren
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid mbox: scsi_add_host failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|scsi_host_put
c_func
(paren
id|host
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|scsi_scan_host
c_func
(paren
id|host
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_io_detach - detach a device from the IO subsystem&n; * @param adapter&t;: controller&squot;s soft state&n; *&n; * Detach this device from the IO subsystem&n; **/
r_static
r_void
DECL|function|megaraid_io_detach
id|megaraid_io_detach
c_func
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
id|con_log
c_func
(paren
id|CL_DLEVEL1
comma
(paren
id|KERN_INFO
l_string|&quot;megaraid: io detach&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|host
op_assign
id|adapter-&gt;host
suffix:semicolon
id|scsi_remove_host
c_func
(paren
id|host
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * START: Mailbox Low Level Driver&n; *&n; * This is section specific to the single mailbox based controllers&n; */
multiline_comment|/**&n; * megaraid_init_mbox - initialize controller&n; * @param adapter&t;- our soft state&n; *&n; * . Allocate 16-byte aligned mailbox memory for firmware handshake&n; * . Allocate controller&squot;s memory resources&n; * . Find out all initialization data&n; * . Allocate memory required for all the commands&n; * . Use internal library of FW routines, build up complete soft state&n; */
r_static
r_int
id|__init
DECL|function|megaraid_init_mbox
id|megaraid_init_mbox
c_func
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
r_struct
id|pci_dev
op_star
id|pdev
suffix:semicolon
id|mraid_device_t
op_star
id|raid_dev
suffix:semicolon
r_int
id|i
suffix:semicolon
id|adapter-&gt;ito
op_assign
id|MBOX_TIMEOUT
suffix:semicolon
id|pdev
op_assign
id|adapter-&gt;pdev
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate and initialize the init data structure for mailbox&n;&t; * controllers&n;&t; */
id|raid_dev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|mraid_device_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|raid_dev
op_eq
l_int|NULL
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|memset
c_func
(paren
id|raid_dev
comma
l_int|0
comma
r_sizeof
(paren
id|mraid_device_t
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Attach the adapter soft state to raid device soft state&n;&t; */
id|adapter-&gt;raid_device
op_assign
(paren
id|caddr_t
)paren
id|raid_dev
suffix:semicolon
id|raid_dev-&gt;fast_load
op_assign
id|megaraid_fast_load
suffix:semicolon
singleline_comment|// our baseport
id|raid_dev-&gt;baseport
op_assign
id|pci_resource_start
c_func
(paren
id|pdev
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_request_regions
c_func
(paren
id|pdev
comma
l_string|&quot;MegaRAID: LSI Logic Corporation&quot;
)paren
op_ne
l_int|0
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid: mem region busy&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_goto
id|out_free_raid_dev
suffix:semicolon
)brace
id|raid_dev-&gt;baseaddr
op_assign
id|ioremap_nocache
c_func
(paren
id|raid_dev-&gt;baseport
comma
l_int|128
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|raid_dev-&gt;baseaddr
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid: could not map hba memory&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_goto
id|out_release_regions
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// Setup the rest of the soft state using the library of FW routines
singleline_comment|//
singleline_comment|// request IRQ and register the interrupt service routine
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|adapter-&gt;irq
comma
id|megaraid_isr
comma
id|SA_SHIRQ
comma
l_string|&quot;megaraid&quot;
comma
id|adapter
)paren
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid: Couldn&squot;t register IRQ %d!&bslash;n&quot;
comma
id|adapter-&gt;irq
)paren
)paren
suffix:semicolon
r_goto
id|out_iounmap
suffix:semicolon
)brace
singleline_comment|// initialize the mutual exclusion lock for the mailbox
id|spin_lock_init
c_func
(paren
op_amp
id|raid_dev-&gt;mailbox_lock
)paren
suffix:semicolon
singleline_comment|// allocate memory required for commands
r_if
c_cond
(paren
id|megaraid_alloc_cmd_packets
c_func
(paren
id|adapter
)paren
op_ne
l_int|0
)paren
(brace
r_goto
id|out_free_irq
suffix:semicolon
)brace
singleline_comment|// Product info
r_if
c_cond
(paren
id|megaraid_mbox_product_info
c_func
(paren
id|adapter
)paren
op_ne
l_int|0
)paren
(brace
r_goto
id|out_alloc_cmds
suffix:semicolon
)brace
singleline_comment|// Do we support extended CDBs
id|adapter-&gt;max_cdb_sz
op_assign
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|megaraid_mbox_extended_cdb
c_func
(paren
id|adapter
)paren
op_eq
l_int|0
)paren
(brace
id|adapter-&gt;max_cdb_sz
op_assign
l_int|16
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Do we support cluster environment, if we do, what is the initiator&n;&t; * id.&n;&t; * NOTE: In a non-cluster aware firmware environment, the LLD should&n;&t; * return 7 as initiator id.&n;&t; */
id|adapter-&gt;ha
op_assign
l_int|0
suffix:semicolon
id|adapter-&gt;init_id
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|megaraid_mbox_support_ha
c_func
(paren
id|adapter
comma
op_amp
id|adapter-&gt;init_id
)paren
op_eq
l_int|0
)paren
(brace
id|adapter-&gt;ha
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Prepare the device ids array to have the mapping between the kernel&n;&t; * device address and megaraid device address.&n;&t; * We export the physical devices on their actual addresses. The&n;&t; * logical drives are exported on a virtual SCSI channel&n;&t; */
id|megaraid_mbox_setup_device_map
c_func
(paren
id|adapter
)paren
suffix:semicolon
singleline_comment|// If the firmware supports random deletion, update the device id map
r_if
c_cond
(paren
id|megaraid_mbox_support_random_del
c_func
(paren
id|adapter
)paren
)paren
(brace
singleline_comment|// Change the logical drives numbers in device_ids array one
singleline_comment|// slot in device_ids is reserved for target id, that&squot;s why
singleline_comment|// &quot;&lt;=&quot; below
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|MAX_LOGICAL_DRIVES_40LD
suffix:semicolon
id|i
op_increment
)paren
(brace
id|adapter-&gt;device_ids
(braket
id|adapter-&gt;max_channel
)braket
(braket
id|i
)braket
op_add_assign
l_int|0x80
suffix:semicolon
)brace
id|adapter-&gt;device_ids
(braket
id|adapter-&gt;max_channel
)braket
(braket
id|adapter-&gt;init_id
)braket
op_assign
l_int|0xFF
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * find out the maximum number of scatter-gather elements supported by&n;&t; * this firmware&n;&t; */
id|adapter-&gt;sglen
op_assign
id|megaraid_mbox_get_max_sg
c_func
(paren
id|adapter
)paren
suffix:semicolon
singleline_comment|// enumerate RAID and SCSI channels so that all devices on SCSI
singleline_comment|// channels can later be exported, including disk devices
id|megaraid_mbox_enum_raid_scsi
c_func
(paren
id|adapter
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Other parameters required by upper layer&n;&t; *&n;&t; * maximum number of sectors per IO command&n;&t; */
id|adapter-&gt;max_sectors
op_assign
id|megaraid_max_sectors
suffix:semicolon
multiline_comment|/*&n;&t; * number of queued commands per LUN.&n;&t; */
id|adapter-&gt;cmd_per_lun
op_assign
id|megaraid_cmd_per_lun
suffix:semicolon
singleline_comment|// Set the DMA mask to 64-bit. All supported controllers as capable of
singleline_comment|// DMA in this range
r_if
c_cond
(paren
id|pci_set_dma_mask
c_func
(paren
id|adapter-&gt;pdev
comma
l_int|0xFFFFFFFFFFFFFFFFULL
)paren
op_ne
l_int|0
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid: could not set DMA mask for 64-bit.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_goto
id|out_alloc_cmds
suffix:semicolon
)brace
singleline_comment|// setup tasklet for DPC
id|tasklet_init
c_func
(paren
op_amp
id|adapter-&gt;dpc_h
comma
id|megaraid_mbox_dpc
comma
(paren
r_int
r_int
)paren
id|adapter
)paren
suffix:semicolon
id|con_log
c_func
(paren
id|CL_DLEVEL1
comma
(paren
id|KERN_INFO
l_string|&quot;megaraid mbox hba successfully initialized&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_alloc_cmds
suffix:colon
id|megaraid_free_cmd_packets
c_func
(paren
id|adapter
)paren
suffix:semicolon
id|out_free_irq
suffix:colon
id|free_irq
c_func
(paren
id|adapter-&gt;irq
comma
id|adapter
)paren
suffix:semicolon
id|out_iounmap
suffix:colon
id|iounmap
c_func
(paren
id|raid_dev-&gt;baseaddr
)paren
suffix:semicolon
id|out_release_regions
suffix:colon
id|pci_release_regions
c_func
(paren
id|pdev
)paren
suffix:semicolon
id|out_free_raid_dev
suffix:colon
id|kfree
c_func
(paren
id|raid_dev
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_fini_mbox - undo controller initialization&n; * @param adapter&t;: our soft state&n; */
r_static
r_void
DECL|function|megaraid_fini_mbox
id|megaraid_fini_mbox
c_func
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
id|mraid_device_t
op_star
id|raid_dev
op_assign
id|ADAP2RAIDDEV
c_func
(paren
id|adapter
)paren
suffix:semicolon
singleline_comment|// flush all caches
id|megaraid_mbox_flush_cache
c_func
(paren
id|adapter
)paren
suffix:semicolon
id|tasklet_kill
c_func
(paren
op_amp
id|adapter-&gt;dpc_h
)paren
suffix:semicolon
id|megaraid_free_cmd_packets
c_func
(paren
id|adapter
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|adapter-&gt;irq
comma
id|adapter
)paren
suffix:semicolon
id|iounmap
c_func
(paren
id|raid_dev-&gt;baseaddr
)paren
suffix:semicolon
id|pci_release_regions
c_func
(paren
id|adapter-&gt;pdev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|raid_dev
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_alloc_cmd_packets - allocate shared mailbox&n; * @param adapter&t;: soft state of the raid controller&n; *&n; * Allocate and align the shared mailbox. This maibox is used to issue&n; * all the commands. For IO based controllers, the mailbox is also regsitered&n; * with the FW. Allocate memory for all commands as well.&n; * This is our big allocator&n; */
r_static
r_int
DECL|function|megaraid_alloc_cmd_packets
id|megaraid_alloc_cmd_packets
c_func
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
id|mraid_device_t
op_star
id|raid_dev
op_assign
id|ADAP2RAIDDEV
c_func
(paren
id|adapter
)paren
suffix:semicolon
r_struct
id|pci_dev
op_star
id|pdev
suffix:semicolon
r_int
r_int
id|align
suffix:semicolon
id|scb_t
op_star
id|scb
suffix:semicolon
id|mbox_ccb_t
op_star
id|ccb
suffix:semicolon
r_struct
id|mraid_pci_blk
op_star
id|epthru_pci_blk
suffix:semicolon
r_struct
id|mraid_pci_blk
op_star
id|sg_pci_blk
suffix:semicolon
r_struct
id|mraid_pci_blk
op_star
id|mbox_pci_blk
suffix:semicolon
r_int
id|i
suffix:semicolon
id|pdev
op_assign
id|adapter-&gt;pdev
suffix:semicolon
multiline_comment|/*&n;&t; * Setup the mailbox&n;&t; * Allocate the common 16-byte aligned memory for the handshake&n;&t; * mailbox.&n;&t; */
id|raid_dev-&gt;una_mbox64
op_assign
id|pci_alloc_consistent
c_func
(paren
id|adapter-&gt;pdev
comma
r_sizeof
(paren
id|mbox64_t
)paren
comma
op_amp
id|raid_dev-&gt;una_mbox64_dma
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|raid_dev-&gt;una_mbox64
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid: out of memory, %s %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|__LINE__
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|memset
c_func
(paren
id|raid_dev-&gt;una_mbox64
comma
l_int|0
comma
r_sizeof
(paren
id|mbox64_t
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Align the mailbox at 16-byte boundary&n;&t; */
id|raid_dev-&gt;mbox
op_assign
op_amp
id|raid_dev-&gt;una_mbox64-&gt;mbox32
suffix:semicolon
id|raid_dev-&gt;mbox
op_assign
(paren
id|mbox_t
op_star
)paren
(paren
(paren
(paren
(paren
r_int
r_int
)paren
id|raid_dev-&gt;mbox
)paren
op_plus
l_int|15
)paren
op_amp
(paren
op_complement
l_int|0UL
op_xor
l_int|0xFUL
)paren
)paren
suffix:semicolon
id|raid_dev-&gt;mbox64
op_assign
(paren
id|mbox64_t
op_star
)paren
(paren
(paren
(paren
r_int
r_int
)paren
id|raid_dev-&gt;mbox
)paren
op_minus
l_int|8
)paren
suffix:semicolon
id|align
op_assign
(paren
(paren
r_void
op_star
)paren
id|raid_dev-&gt;mbox
op_minus
(paren
(paren
r_void
op_star
)paren
op_amp
id|raid_dev-&gt;una_mbox64-&gt;mbox32
)paren
)paren
suffix:semicolon
id|raid_dev-&gt;mbox_dma
op_assign
(paren
r_int
r_int
)paren
id|raid_dev-&gt;una_mbox64_dma
op_plus
l_int|8
op_plus
id|align
suffix:semicolon
singleline_comment|// Allocate memory for commands issued internally
id|adapter-&gt;ibuf
op_assign
id|pci_alloc_consistent
c_func
(paren
id|pdev
comma
id|MBOX_IBUF_SIZE
comma
op_amp
id|adapter-&gt;ibuf_dma_h
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|adapter-&gt;ibuf
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid: out of memory, %s %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|__LINE__
)paren
)paren
suffix:semicolon
r_goto
id|out_free_common_mbox
suffix:semicolon
)brace
id|memset
c_func
(paren
id|adapter-&gt;ibuf
comma
l_int|0
comma
id|MBOX_IBUF_SIZE
)paren
suffix:semicolon
singleline_comment|// Allocate memory for our SCSI Command Blocks and their associated
singleline_comment|// memory
multiline_comment|/*&n;&t; * Allocate memory for the base list of scb. Later allocate memory for&n;&t; * CCBs and embedded components of each CCB and point the pointers in&n;&t; * scb to the allocated components&n;&t; * NOTE: The code to allocate SCB will be duplicated in all the LLD&n;&t; * since the calling routine does not yet know the number of available&n;&t; * commands.&n;&t; */
id|adapter-&gt;kscb_list
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|scb_t
)paren
op_star
id|MBOX_MAX_SCSI_CMDS
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|adapter-&gt;kscb_list
op_eq
l_int|NULL
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid: out of memory, %s %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|__LINE__
)paren
)paren
suffix:semicolon
r_goto
id|out_free_ibuf
suffix:semicolon
)brace
id|memset
c_func
(paren
id|adapter-&gt;kscb_list
comma
l_int|0
comma
r_sizeof
(paren
id|scb_t
)paren
op_star
id|MBOX_MAX_SCSI_CMDS
)paren
suffix:semicolon
singleline_comment|// memory allocation for our command packets
r_if
c_cond
(paren
id|megaraid_mbox_setup_dma_pools
c_func
(paren
id|adapter
)paren
op_ne
l_int|0
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid: out of memory, %s %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|__LINE__
)paren
)paren
suffix:semicolon
r_goto
id|out_free_scb_list
suffix:semicolon
)brace
singleline_comment|// Adjust the scb pointers and link in the free pool
id|epthru_pci_blk
op_assign
id|raid_dev-&gt;epthru_pool
suffix:semicolon
id|sg_pci_blk
op_assign
id|raid_dev-&gt;sg_pool
suffix:semicolon
id|mbox_pci_blk
op_assign
id|raid_dev-&gt;mbox_pool
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MBOX_MAX_SCSI_CMDS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|scb
op_assign
id|adapter-&gt;kscb_list
op_plus
id|i
suffix:semicolon
id|ccb
op_assign
id|raid_dev-&gt;ccb_list
op_plus
id|i
suffix:semicolon
id|ccb-&gt;mbox
op_assign
(paren
id|mbox_t
op_star
)paren
(paren
id|mbox_pci_blk
(braket
id|i
)braket
dot
id|vaddr
op_plus
l_int|16
)paren
suffix:semicolon
id|ccb-&gt;raw_mbox
op_assign
(paren
r_uint8
op_star
)paren
id|ccb-&gt;mbox
suffix:semicolon
id|ccb-&gt;mbox64
op_assign
(paren
id|mbox64_t
op_star
)paren
(paren
id|mbox_pci_blk
(braket
id|i
)braket
dot
id|vaddr
op_plus
l_int|8
)paren
suffix:semicolon
id|ccb-&gt;mbox_dma_h
op_assign
(paren
r_int
r_int
)paren
id|mbox_pci_blk
(braket
id|i
)braket
dot
id|dma_addr
op_plus
l_int|16
suffix:semicolon
singleline_comment|// make sure the mailbox is aligned properly
r_if
c_cond
(paren
id|ccb-&gt;mbox_dma_h
op_amp
l_int|0x0F
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_CRIT
l_string|&quot;megaraid mbox: not aligned on 16-bytes&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_goto
id|out_teardown_dma_pools
suffix:semicolon
)brace
id|ccb-&gt;epthru
op_assign
(paren
id|mraid_epassthru_t
op_star
)paren
id|epthru_pci_blk
(braket
id|i
)braket
dot
id|vaddr
suffix:semicolon
id|ccb-&gt;epthru_dma_h
op_assign
id|epthru_pci_blk
(braket
id|i
)braket
dot
id|dma_addr
suffix:semicolon
id|ccb-&gt;pthru
op_assign
(paren
id|mraid_passthru_t
op_star
)paren
id|ccb-&gt;epthru
suffix:semicolon
id|ccb-&gt;pthru_dma_h
op_assign
id|ccb-&gt;epthru_dma_h
suffix:semicolon
id|ccb-&gt;sgl64
op_assign
(paren
id|mbox_sgl64
op_star
)paren
id|sg_pci_blk
(braket
id|i
)braket
dot
id|vaddr
suffix:semicolon
id|ccb-&gt;sgl_dma_h
op_assign
id|sg_pci_blk
(braket
id|i
)braket
dot
id|dma_addr
suffix:semicolon
id|ccb-&gt;sgl32
op_assign
(paren
id|mbox_sgl32
op_star
)paren
id|ccb-&gt;sgl64
suffix:semicolon
id|scb-&gt;ccb
op_assign
(paren
id|caddr_t
)paren
id|ccb
suffix:semicolon
id|scb-&gt;gp
op_assign
l_int|0
suffix:semicolon
id|scb-&gt;sno
op_assign
id|i
suffix:semicolon
singleline_comment|// command index
id|scb-&gt;scp
op_assign
l_int|NULL
suffix:semicolon
id|scb-&gt;state
op_assign
id|SCB_FREE
suffix:semicolon
id|scb-&gt;dma_direction
op_assign
id|PCI_DMA_NONE
suffix:semicolon
id|scb-&gt;dma_type
op_assign
id|MRAID_DMA_NONE
suffix:semicolon
id|scb-&gt;dev_channel
op_assign
op_minus
l_int|1
suffix:semicolon
id|scb-&gt;dev_target
op_assign
op_minus
l_int|1
suffix:semicolon
singleline_comment|// put scb in the free pool
id|list_add_tail
c_func
(paren
op_amp
id|scb-&gt;list
comma
op_amp
id|adapter-&gt;kscb_pool
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|out_teardown_dma_pools
suffix:colon
id|megaraid_mbox_teardown_dma_pools
c_func
(paren
id|adapter
)paren
suffix:semicolon
id|out_free_scb_list
suffix:colon
id|kfree
c_func
(paren
id|adapter-&gt;kscb_list
)paren
suffix:semicolon
id|out_free_ibuf
suffix:colon
id|pci_free_consistent
c_func
(paren
id|pdev
comma
id|MBOX_IBUF_SIZE
comma
(paren
r_void
op_star
)paren
id|adapter-&gt;ibuf
comma
id|adapter-&gt;ibuf_dma_h
)paren
suffix:semicolon
id|out_free_common_mbox
suffix:colon
id|pci_free_consistent
c_func
(paren
id|adapter-&gt;pdev
comma
r_sizeof
(paren
id|mbox64_t
)paren
comma
(paren
id|caddr_t
)paren
id|raid_dev-&gt;una_mbox64
comma
id|raid_dev-&gt;una_mbox64_dma
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_free_cmd_packets - free memory&n; * @param adapter&t;: soft state of the raid controller&n; *&n; * Release memory resources allocated for commands&n; */
r_static
r_void
DECL|function|megaraid_free_cmd_packets
id|megaraid_free_cmd_packets
c_func
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
id|mraid_device_t
op_star
id|raid_dev
op_assign
id|ADAP2RAIDDEV
c_func
(paren
id|adapter
)paren
suffix:semicolon
id|megaraid_mbox_teardown_dma_pools
c_func
(paren
id|adapter
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|adapter-&gt;kscb_list
)paren
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|adapter-&gt;pdev
comma
id|MBOX_IBUF_SIZE
comma
(paren
r_void
op_star
)paren
id|adapter-&gt;ibuf
comma
id|adapter-&gt;ibuf_dma_h
)paren
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|adapter-&gt;pdev
comma
r_sizeof
(paren
id|mbox64_t
)paren
comma
(paren
id|caddr_t
)paren
id|raid_dev-&gt;una_mbox64
comma
id|raid_dev-&gt;una_mbox64_dma
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_mbox_setup_dma_pools - setup dma pool for command packets&n; * @param adapter&t;: HBA soft state&n; *&n; * setup the dma pools for mailbox, passthru and extended passthru structures,&n; * and scatter-gather lists&n; */
r_static
r_int
DECL|function|megaraid_mbox_setup_dma_pools
id|megaraid_mbox_setup_dma_pools
c_func
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
id|mraid_device_t
op_star
id|raid_dev
op_assign
id|ADAP2RAIDDEV
c_func
(paren
id|adapter
)paren
suffix:semicolon
r_struct
id|mraid_pci_blk
op_star
id|epthru_pci_blk
suffix:semicolon
r_struct
id|mraid_pci_blk
op_star
id|sg_pci_blk
suffix:semicolon
r_struct
id|mraid_pci_blk
op_star
id|mbox_pci_blk
suffix:semicolon
r_int
id|i
suffix:semicolon
singleline_comment|// Allocate memory for 16-bytes aligned mailboxes
id|raid_dev-&gt;mbox_pool_handle
op_assign
id|pci_pool_create
c_func
(paren
l_string|&quot;megaraid mbox pool&quot;
comma
id|adapter-&gt;pdev
comma
r_sizeof
(paren
id|mbox64_t
)paren
op_plus
l_int|16
comma
l_int|16
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|raid_dev-&gt;mbox_pool_handle
op_eq
l_int|NULL
)paren
(brace
r_goto
id|fail_setup_dma_pool
suffix:semicolon
)brace
id|mbox_pci_blk
op_assign
id|raid_dev-&gt;mbox_pool
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MBOX_MAX_SCSI_CMDS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mbox_pci_blk
(braket
id|i
)braket
dot
id|vaddr
op_assign
id|pci_pool_alloc
c_func
(paren
id|raid_dev-&gt;mbox_pool_handle
comma
id|GFP_KERNEL
comma
op_amp
id|mbox_pci_blk
(braket
id|i
)braket
dot
id|dma_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mbox_pci_blk
(braket
id|i
)braket
dot
id|vaddr
)paren
(brace
r_goto
id|fail_setup_dma_pool
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Allocate memory for each embedded passthru strucuture pointer&n;&t; * Request for a 128 bytes aligned structure for each passthru command&n;&t; * structure&n;&t; * Since passthru and extended passthru commands are exclusive, they&n;&t; * share common memory pool. Passthru structures piggyback on memory&n;&t; * allocted to extended passthru since passthru is smaller of the two&n;&t; */
id|raid_dev-&gt;epthru_pool_handle
op_assign
id|pci_pool_create
c_func
(paren
l_string|&quot;megaraid mbox pthru&quot;
comma
id|adapter-&gt;pdev
comma
r_sizeof
(paren
id|mraid_epassthru_t
)paren
comma
l_int|128
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|raid_dev-&gt;epthru_pool_handle
op_eq
l_int|NULL
)paren
(brace
r_goto
id|fail_setup_dma_pool
suffix:semicolon
)brace
id|epthru_pci_blk
op_assign
id|raid_dev-&gt;epthru_pool
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MBOX_MAX_SCSI_CMDS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|epthru_pci_blk
(braket
id|i
)braket
dot
id|vaddr
op_assign
id|pci_pool_alloc
c_func
(paren
id|raid_dev-&gt;epthru_pool_handle
comma
id|GFP_KERNEL
comma
op_amp
id|epthru_pci_blk
(braket
id|i
)braket
dot
id|dma_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|epthru_pci_blk
(braket
id|i
)braket
dot
id|vaddr
)paren
(brace
r_goto
id|fail_setup_dma_pool
suffix:semicolon
)brace
)brace
singleline_comment|// Allocate memory for each scatter-gather list. Request for 512 bytes
singleline_comment|// alignment for each sg list
id|raid_dev-&gt;sg_pool_handle
op_assign
id|pci_pool_create
c_func
(paren
l_string|&quot;megaraid mbox sg&quot;
comma
id|adapter-&gt;pdev
comma
r_sizeof
(paren
id|mbox_sgl64
)paren
op_star
id|MBOX_MAX_SG_SIZE
comma
l_int|512
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|raid_dev-&gt;sg_pool_handle
op_eq
l_int|NULL
)paren
(brace
r_goto
id|fail_setup_dma_pool
suffix:semicolon
)brace
id|sg_pci_blk
op_assign
id|raid_dev-&gt;sg_pool
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MBOX_MAX_SCSI_CMDS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sg_pci_blk
(braket
id|i
)braket
dot
id|vaddr
op_assign
id|pci_pool_alloc
c_func
(paren
id|raid_dev-&gt;sg_pool_handle
comma
id|GFP_KERNEL
comma
op_amp
id|sg_pci_blk
(braket
id|i
)braket
dot
id|dma_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sg_pci_blk
(braket
id|i
)braket
dot
id|vaddr
)paren
(brace
r_goto
id|fail_setup_dma_pool
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
id|fail_setup_dma_pool
suffix:colon
id|megaraid_mbox_teardown_dma_pools
c_func
(paren
id|adapter
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_mbox_teardown_dma_pools - teardown dma pools for command packets&n; * @param adapter&t;: HBA soft state&n; *&n; * teardown the dma pool for mailbox, passthru and extended passthru&n; * structures, and scatter-gather lists&n; */
r_static
r_void
DECL|function|megaraid_mbox_teardown_dma_pools
id|megaraid_mbox_teardown_dma_pools
c_func
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
id|mraid_device_t
op_star
id|raid_dev
op_assign
id|ADAP2RAIDDEV
c_func
(paren
id|adapter
)paren
suffix:semicolon
r_struct
id|mraid_pci_blk
op_star
id|epthru_pci_blk
suffix:semicolon
r_struct
id|mraid_pci_blk
op_star
id|sg_pci_blk
suffix:semicolon
r_struct
id|mraid_pci_blk
op_star
id|mbox_pci_blk
suffix:semicolon
r_int
id|i
suffix:semicolon
id|sg_pci_blk
op_assign
id|raid_dev-&gt;sg_pool
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MBOX_MAX_SCSI_CMDS
op_logical_and
id|sg_pci_blk
(braket
id|i
)braket
dot
id|vaddr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pci_pool_free
c_func
(paren
id|raid_dev-&gt;sg_pool_handle
comma
id|sg_pci_blk
(braket
id|i
)braket
dot
id|vaddr
comma
id|sg_pci_blk
(braket
id|i
)braket
dot
id|dma_addr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|raid_dev-&gt;sg_pool_handle
)paren
id|pci_pool_destroy
c_func
(paren
id|raid_dev-&gt;sg_pool_handle
)paren
suffix:semicolon
id|epthru_pci_blk
op_assign
id|raid_dev-&gt;epthru_pool
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MBOX_MAX_SCSI_CMDS
op_logical_and
id|epthru_pci_blk
(braket
id|i
)braket
dot
id|vaddr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pci_pool_free
c_func
(paren
id|raid_dev-&gt;epthru_pool_handle
comma
id|epthru_pci_blk
(braket
id|i
)braket
dot
id|vaddr
comma
id|epthru_pci_blk
(braket
id|i
)braket
dot
id|dma_addr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|raid_dev-&gt;epthru_pool_handle
)paren
id|pci_pool_destroy
c_func
(paren
id|raid_dev-&gt;epthru_pool_handle
)paren
suffix:semicolon
id|mbox_pci_blk
op_assign
id|raid_dev-&gt;mbox_pool
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MBOX_MAX_SCSI_CMDS
op_logical_and
id|mbox_pci_blk
(braket
id|i
)braket
dot
id|vaddr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pci_pool_free
c_func
(paren
id|raid_dev-&gt;mbox_pool_handle
comma
id|mbox_pci_blk
(braket
id|i
)braket
dot
id|vaddr
comma
id|mbox_pci_blk
(braket
id|i
)braket
dot
id|dma_addr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|raid_dev-&gt;mbox_pool_handle
)paren
id|pci_pool_destroy
c_func
(paren
id|raid_dev-&gt;mbox_pool_handle
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_alloc_scb - detach and return a scb from the free list&n; * @adapter&t;: controller&squot;s soft state&n; *&n; * return the scb from the head of the free list. NULL if there are none&n; * available&n; **/
r_static
r_inline
id|scb_t
op_star
DECL|function|megaraid_alloc_scb
id|megaraid_alloc_scb
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
r_struct
id|scsi_cmnd
op_star
id|scp
)paren
(brace
r_struct
id|list_head
op_star
id|head
op_assign
op_amp
id|adapter-&gt;kscb_pool
suffix:semicolon
id|scb_t
op_star
id|scb
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
singleline_comment|// detach scb from free pool
id|spin_lock_irqsave
c_func
(paren
id|SCSI_FREE_LIST_LOCK
c_func
(paren
id|adapter
)paren
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
id|head
)paren
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
id|SCSI_FREE_LIST_LOCK
c_func
(paren
id|adapter
)paren
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|scb
op_assign
id|list_entry
c_func
(paren
id|head-&gt;next
comma
id|scb_t
comma
id|list
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|scb-&gt;list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|SCSI_FREE_LIST_LOCK
c_func
(paren
id|adapter
)paren
comma
id|flags
)paren
suffix:semicolon
id|scb-&gt;state
op_assign
id|SCB_ACTIVE
suffix:semicolon
id|scb-&gt;scp
op_assign
id|scp
suffix:semicolon
id|scb-&gt;dma_type
op_assign
id|MRAID_DMA_NONE
suffix:semicolon
r_return
id|scb
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_dealloc_scb - return the scb to the free pool&n; * @adapter&t;: controller&squot;s soft state&n; * @scb&t;&t;: scb to be freed&n; *&n; * return the scb back to the free list of scbs. The caller must &squot;flush&squot; the&n; * SCB before calling us. E.g., performing pci_unamp and/or pci_sync etc.&n; * NOTE NOTE: Make sure the scb is not on any list before calling this&n; * routine.&n; **/
r_static
r_inline
r_void
DECL|function|megaraid_dealloc_scb
id|megaraid_dealloc_scb
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
id|scb_t
op_star
id|scb
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
singleline_comment|// put scb in the free pool
id|scb-&gt;state
op_assign
id|SCB_FREE
suffix:semicolon
id|scb-&gt;scp
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|SCSI_FREE_LIST_LOCK
c_func
(paren
id|adapter
)paren
comma
id|flags
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|scb-&gt;list
comma
op_amp
id|adapter-&gt;kscb_pool
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|SCSI_FREE_LIST_LOCK
c_func
(paren
id|adapter
)paren
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_mbox_mksgl - make the scatter-gather list&n; * @adapter&t;- controller&squot;s soft state&n; * @scb&t;&t;- scsi control block&n; *&n; * prepare the scatter-gather list&n; */
r_static
r_inline
r_int
DECL|function|megaraid_mbox_mksgl
id|megaraid_mbox_mksgl
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
id|scb_t
op_star
id|scb
)paren
(brace
r_struct
id|scatterlist
op_star
id|sgl
suffix:semicolon
id|mbox_ccb_t
op_star
id|ccb
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
r_struct
id|scsi_cmnd
op_star
id|scp
suffix:semicolon
r_int
id|sgcnt
suffix:semicolon
r_int
id|i
suffix:semicolon
id|scp
op_assign
id|scb-&gt;scp
suffix:semicolon
id|ccb
op_assign
(paren
id|mbox_ccb_t
op_star
)paren
id|scb-&gt;ccb
suffix:semicolon
singleline_comment|// no mapping required if no data to be transferred
r_if
c_cond
(paren
op_logical_neg
id|scp-&gt;request_buffer
op_logical_or
op_logical_neg
id|scp-&gt;request_bufflen
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scp-&gt;use_sg
)paren
(brace
multiline_comment|/* scatter-gather list not used */
id|page
op_assign
id|virt_to_page
c_func
(paren
id|scp-&gt;request_buffer
)paren
suffix:semicolon
id|offset
op_assign
(paren
(paren
r_int
r_int
)paren
id|scp-&gt;request_buffer
op_amp
op_complement
id|PAGE_MASK
)paren
suffix:semicolon
id|ccb-&gt;buf_dma_h
op_assign
id|pci_map_page
c_func
(paren
id|adapter-&gt;pdev
comma
id|page
comma
id|offset
comma
id|scp-&gt;request_bufflen
comma
id|scb-&gt;dma_direction
)paren
suffix:semicolon
id|scb-&gt;dma_type
op_assign
id|MRAID_DMA_WBUF
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We need to handle special 64-bit commands that need a&n;&t;&t; * minimum of 1 SG&n;&t;&t; */
id|sgcnt
op_assign
l_int|1
suffix:semicolon
id|ccb-&gt;sgl64
(braket
l_int|0
)braket
dot
id|address
op_assign
id|ccb-&gt;buf_dma_h
suffix:semicolon
id|ccb-&gt;sgl64
(braket
l_int|0
)braket
dot
id|length
op_assign
id|scp-&gt;request_bufflen
suffix:semicolon
r_return
id|sgcnt
suffix:semicolon
)brace
id|sgl
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|scp-&gt;request_buffer
suffix:semicolon
singleline_comment|// The number of sg elements returned must not exceed our limit
id|sgcnt
op_assign
id|pci_map_sg
c_func
(paren
id|adapter-&gt;pdev
comma
id|sgl
comma
id|scp-&gt;use_sg
comma
id|scb-&gt;dma_direction
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sgcnt
OG
id|adapter-&gt;sglen
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_CRIT
l_string|&quot;megaraid critical: too many sg elements:%d&bslash;n&quot;
comma
id|sgcnt
)paren
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|scb-&gt;dma_type
op_assign
id|MRAID_DMA_WSG
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sgcnt
suffix:semicolon
id|i
op_increment
comma
id|sgl
op_increment
)paren
(brace
id|ccb-&gt;sgl64
(braket
id|i
)braket
dot
id|address
op_assign
id|sg_dma_address
c_func
(paren
id|sgl
)paren
suffix:semicolon
id|ccb-&gt;sgl64
(braket
id|i
)braket
dot
id|length
op_assign
id|sg_dma_len
c_func
(paren
id|sgl
)paren
suffix:semicolon
)brace
singleline_comment|// Return count of SG nodes
r_return
id|sgcnt
suffix:semicolon
)brace
multiline_comment|/**&n; * mbox_post_cmd - issue a mailbox command&n; * @adapter&t;- controller&squot;s soft state&n; * @scb&t;&t;- command to be issued&n; *&n; * post the command to the controller if mailbox is availble.&n; */
r_static
r_inline
r_int
DECL|function|mbox_post_cmd
id|mbox_post_cmd
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
id|scb_t
op_star
id|scb
)paren
(brace
id|mraid_device_t
op_star
id|raid_dev
op_assign
id|ADAP2RAIDDEV
c_func
(paren
id|adapter
)paren
suffix:semicolon
id|mbox64_t
op_star
id|mbox64
suffix:semicolon
id|mbox_t
op_star
id|mbox
suffix:semicolon
id|mbox_ccb_t
op_star
id|ccb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|ccb
op_assign
(paren
id|mbox_ccb_t
op_star
)paren
id|scb-&gt;ccb
suffix:semicolon
id|mbox
op_assign
id|raid_dev-&gt;mbox
suffix:semicolon
id|mbox64
op_assign
id|raid_dev-&gt;mbox64
suffix:semicolon
multiline_comment|/*&n;&t; * Check for busy mailbox. If it is, return failure - the caller&n;&t; * should retry later.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
id|MAILBOX_LOCK
c_func
(paren
id|raid_dev
)paren
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|mbox-&gt;busy
)paren
)paren
(brace
r_do
(brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|rmb
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|mbox-&gt;busy
op_logical_and
(paren
id|i
OL
id|max_mbox_busy_wait
)paren
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mbox-&gt;busy
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
id|MAILBOX_LOCK
c_func
(paren
id|raid_dev
)paren
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
singleline_comment|// Copy this command&squot;s mailbox data into &quot;adapter&squot;s&quot; mailbox
id|memcpy
c_func
(paren
(paren
id|caddr_t
)paren
id|mbox64
comma
(paren
id|caddr_t
)paren
id|ccb-&gt;mbox64
comma
l_int|22
)paren
suffix:semicolon
id|mbox-&gt;cmdid
op_assign
id|scb-&gt;sno
suffix:semicolon
id|adapter-&gt;outstanding_cmds
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|scb-&gt;dma_direction
op_eq
id|PCI_DMA_TODEVICE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|scb-&gt;scp-&gt;use_sg
)paren
(brace
singleline_comment|// sg list not used
id|pci_dma_sync_single_for_device
c_func
(paren
id|adapter-&gt;pdev
comma
id|ccb-&gt;buf_dma_h
comma
id|scb-&gt;scp-&gt;request_bufflen
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
)brace
r_else
(brace
id|pci_dma_sync_sg_for_device
c_func
(paren
id|adapter-&gt;pdev
comma
id|scb-&gt;scp-&gt;request_buffer
comma
id|scb-&gt;scp-&gt;use_sg
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
)brace
)brace
id|mbox-&gt;busy
op_assign
l_int|1
suffix:semicolon
singleline_comment|// Set busy
id|mbox-&gt;poll
op_assign
l_int|0
suffix:semicolon
id|mbox-&gt;ack
op_assign
l_int|0
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|WRINDOOR
c_func
(paren
id|raid_dev
comma
id|raid_dev-&gt;mbox_dma
op_or
l_int|0x1
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|MAILBOX_LOCK
c_func
(paren
id|raid_dev
)paren
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_queue_command - generic queue entry point for all LLDs&n; * @scp&t;&t;: pointer to the scsi command to be executed&n; * @done&t;: callback routine to be called after the cmd has be completed&n; *&n; * Queue entry point for mailbox based controllers.&n; */
r_static
r_int
DECL|function|megaraid_queue_command
id|megaraid_queue_command
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|scp
comma
r_void
(paren
op_star
id|done
)paren
(paren
r_struct
id|scsi_cmnd
op_star
)paren
)paren
(brace
id|adapter_t
op_star
id|adapter
suffix:semicolon
id|scb_t
op_star
id|scb
suffix:semicolon
r_int
id|if_busy
suffix:semicolon
id|adapter
op_assign
id|SCP2ADAPTER
c_func
(paren
id|scp
)paren
suffix:semicolon
id|scp-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|scp-&gt;result
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|spin_is_locked
c_func
(paren
id|adapter-&gt;host_lock
)paren
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
id|adapter-&gt;host_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate and build a SCB request&n;&t; * if_busy flag will be set if megaraid_mbox_build_cmd() command could&n;&t; * not allocate scb. We will return non-zero status in that case.&n;&t; * NOTE: scb can be null even though certain commands completed&n;&t; * successfully, e.g., MODE_SENSE and TEST_UNIT_READY, it would&n;&t; * return 0 in that case, and we would do the callback right away.&n;&t; */
id|if_busy
op_assign
l_int|0
suffix:semicolon
id|scb
op_assign
id|megaraid_mbox_build_cmd
c_func
(paren
id|adapter
comma
id|scp
comma
op_amp
id|if_busy
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
)paren
(brace
id|megaraid_mbox_runpendq
c_func
(paren
id|adapter
comma
id|scb
)paren
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
id|adapter-&gt;host_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scb
)paren
(brace
singleline_comment|// command already completed
id|done
c_func
(paren
id|scp
)paren
suffix:semicolon
)brace
r_return
id|if_busy
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_mbox_build_cmd - transform the mid-layer scsi command to megaraid&n; * firmware lingua&n; * @adapter&t;- controller&squot;s soft state&n; * @scp&t;&t;- mid-layer scsi command pointer&n; * @busy&t;- set if request could not be completed because of lack of&n; *&t;&t;resources&n; *&n; * convert the command issued by mid-layer to format understood by megaraid&n; * firmware. We also complete certain command without sending them to firmware&n; */
r_static
id|scb_t
op_star
DECL|function|megaraid_mbox_build_cmd
id|megaraid_mbox_build_cmd
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
r_struct
id|scsi_cmnd
op_star
id|scp
comma
r_int
op_star
id|busy
)paren
(brace
id|mraid_device_t
op_star
id|rdev
op_assign
id|ADAP2RAIDDEV
c_func
(paren
id|adapter
)paren
suffix:semicolon
r_int
id|channel
suffix:semicolon
r_int
id|target
suffix:semicolon
r_int
id|islogical
suffix:semicolon
id|mbox_ccb_t
op_star
id|ccb
suffix:semicolon
id|mraid_passthru_t
op_star
id|pthru
suffix:semicolon
id|mbox64_t
op_star
id|mbox64
suffix:semicolon
id|mbox_t
op_star
id|mbox
suffix:semicolon
id|scb_t
op_star
id|scb
suffix:semicolon
r_char
id|skip
(braket
)braket
op_assign
l_string|&quot;skipping&quot;
suffix:semicolon
r_char
id|scan
(braket
)braket
op_assign
l_string|&quot;scanning&quot;
suffix:semicolon
r_char
op_star
id|ss
suffix:semicolon
multiline_comment|/*&n;&t; * Get the appropriate device map for the device this command is&n;&t; * intended for&n;&t; */
id|MRAID_GET_DEVICE_MAP
c_func
(paren
id|adapter
comma
id|scp
comma
id|channel
comma
id|target
comma
id|islogical
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Logical drive commands&n;&t; */
r_if
c_cond
(paren
id|islogical
)paren
(brace
r_switch
c_cond
(paren
id|scp-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
id|TEST_UNIT_READY
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Do we support clustering and is the support enabled&n;&t;&t;&t; * If no, return success always&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|adapter-&gt;ha
)paren
(brace
id|scp-&gt;result
op_assign
(paren
id|DID_OK
op_lshift
l_int|16
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|scb
op_assign
id|megaraid_alloc_scb
c_func
(paren
id|adapter
comma
id|scp
)paren
)paren
)paren
(brace
id|scp-&gt;result
op_assign
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
op_star
id|busy
op_assign
l_int|1
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|scb-&gt;dma_direction
op_assign
id|scp-&gt;sc_data_direction
suffix:semicolon
id|scb-&gt;dev_channel
op_assign
l_int|0xFF
suffix:semicolon
id|scb-&gt;dev_target
op_assign
id|target
suffix:semicolon
id|ccb
op_assign
(paren
id|mbox_ccb_t
op_star
)paren
id|scb-&gt;ccb
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * The command id will be provided by the command&n;&t;&t;&t; * issuance routine&n;&t;&t;&t; */
id|ccb-&gt;raw_mbox
(braket
l_int|0
)braket
op_assign
id|CLUSTER_CMD
suffix:semicolon
id|ccb-&gt;raw_mbox
(braket
l_int|2
)braket
op_assign
id|RESERVATION_STATUS
suffix:semicolon
id|ccb-&gt;raw_mbox
(braket
l_int|3
)braket
op_assign
id|target
suffix:semicolon
r_return
id|scb
suffix:semicolon
r_case
id|MODE_SENSE
suffix:colon
r_if
c_cond
(paren
id|scp-&gt;use_sg
)paren
(brace
r_struct
id|scatterlist
op_star
id|sgl
suffix:semicolon
id|caddr_t
id|vaddr
suffix:semicolon
id|sgl
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|scp-&gt;request_buffer
suffix:semicolon
r_if
c_cond
(paren
id|sgl-&gt;page
)paren
(brace
id|vaddr
op_assign
(paren
id|caddr_t
)paren
(paren
id|page_address
c_func
(paren
(paren
op_amp
id|sgl
(braket
l_int|0
)braket
)paren
op_member_access_from_pointer
id|page
)paren
op_plus
(paren
op_amp
id|sgl
(braket
l_int|0
)braket
)paren
op_member_access_from_pointer
id|offset
)paren
suffix:semicolon
id|memset
c_func
(paren
id|vaddr
comma
l_int|0
comma
id|scp-&gt;cmnd
(braket
l_int|4
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid mailbox: invalid sg:%d&bslash;n&quot;
comma
id|__LINE__
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|memset
c_func
(paren
id|scp-&gt;request_buffer
comma
l_int|0
comma
id|scp-&gt;cmnd
(braket
l_int|4
)braket
)paren
suffix:semicolon
)brace
id|scp-&gt;result
op_assign
(paren
id|DID_OK
op_lshift
l_int|16
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
r_case
id|INQUIRY
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Display the channel scan for logical drives&n;&t;&t;&t; * Do not display scan for a channel if already done.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|rdev-&gt;last_disp
op_amp
(paren
l_int|1L
op_lshift
id|SCP2CHANNEL
c_func
(paren
id|scp
)paren
)paren
)paren
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_INFO
l_string|&quot;scsi[%d]: scanning scsi channel %d&quot;
comma
id|adapter-&gt;host-&gt;host_no
comma
id|SCP2CHANNEL
c_func
(paren
id|scp
)paren
)paren
)paren
suffix:semicolon
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
l_string|&quot; [virtual] for logical drives&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|rdev-&gt;last_disp
op_or_assign
(paren
l_int|1L
op_lshift
id|SCP2CHANNEL
c_func
(paren
id|scp
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Fall through */
r_case
id|READ_CAPACITY
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Do not allow LUN &gt; 0 for logical drives and&n;&t;&t;&t; * requests for more than 40 logical drives&n;&t;&t;&t; */
r_if
c_cond
(paren
id|SCP2LUN
c_func
(paren
id|scp
)paren
)paren
(brace
id|scp-&gt;result
op_assign
(paren
id|DID_BAD_TARGET
op_lshift
l_int|16
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|target
op_mod
l_int|0x80
)paren
op_ge
id|MAX_LOGICAL_DRIVES_40LD
)paren
(brace
id|scp-&gt;result
op_assign
(paren
id|DID_BAD_TARGET
op_lshift
l_int|16
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Allocate a SCB and initialize passthru */
r_if
c_cond
(paren
op_logical_neg
(paren
id|scb
op_assign
id|megaraid_alloc_scb
c_func
(paren
id|adapter
comma
id|scp
)paren
)paren
)paren
(brace
id|scp-&gt;result
op_assign
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
op_star
id|busy
op_assign
l_int|1
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|ccb
op_assign
(paren
id|mbox_ccb_t
op_star
)paren
id|scb-&gt;ccb
suffix:semicolon
id|scb-&gt;dev_channel
op_assign
l_int|0xFF
suffix:semicolon
id|scb-&gt;dev_target
op_assign
id|target
suffix:semicolon
id|pthru
op_assign
id|ccb-&gt;pthru
suffix:semicolon
id|mbox
op_assign
id|ccb-&gt;mbox
suffix:semicolon
id|mbox64
op_assign
id|ccb-&gt;mbox64
suffix:semicolon
id|pthru-&gt;timeout
op_assign
l_int|0
suffix:semicolon
id|pthru-&gt;ars
op_assign
l_int|1
suffix:semicolon
id|pthru-&gt;reqsenselen
op_assign
l_int|14
suffix:semicolon
id|pthru-&gt;islogical
op_assign
l_int|1
suffix:semicolon
id|pthru-&gt;logdrv
op_assign
id|target
suffix:semicolon
id|pthru-&gt;cdblen
op_assign
id|scp-&gt;cmd_len
suffix:semicolon
id|memcpy
c_func
(paren
id|pthru-&gt;cdb
comma
id|scp-&gt;cmnd
comma
id|scp-&gt;cmd_len
)paren
suffix:semicolon
id|mbox-&gt;cmd
op_assign
id|MBOXCMD_PASSTHRU64
suffix:semicolon
id|scb-&gt;dma_direction
op_assign
id|scp-&gt;sc_data_direction
suffix:semicolon
id|pthru-&gt;dataxferlen
op_assign
id|scp-&gt;request_bufflen
suffix:semicolon
id|pthru-&gt;dataxferaddr
op_assign
id|ccb-&gt;sgl_dma_h
suffix:semicolon
id|pthru-&gt;numsge
op_assign
id|megaraid_mbox_mksgl
c_func
(paren
id|adapter
comma
id|scb
)paren
suffix:semicolon
id|mbox-&gt;xferaddr
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
id|mbox64-&gt;xferaddr_lo
op_assign
(paren
r_uint32
)paren
id|ccb-&gt;pthru_dma_h
suffix:semicolon
id|mbox64-&gt;xferaddr_hi
op_assign
l_int|0
suffix:semicolon
r_return
id|scb
suffix:semicolon
r_case
id|READ_6
suffix:colon
r_case
id|WRITE_6
suffix:colon
r_case
id|READ_10
suffix:colon
r_case
id|WRITE_10
suffix:colon
r_case
id|READ_12
suffix:colon
r_case
id|WRITE_12
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Allocate a SCB and initialize mailbox&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|scb
op_assign
id|megaraid_alloc_scb
c_func
(paren
id|adapter
comma
id|scp
)paren
)paren
)paren
(brace
id|scp-&gt;result
op_assign
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
op_star
id|busy
op_assign
l_int|1
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|ccb
op_assign
(paren
id|mbox_ccb_t
op_star
)paren
id|scb-&gt;ccb
suffix:semicolon
id|scb-&gt;dev_channel
op_assign
l_int|0xFF
suffix:semicolon
id|scb-&gt;dev_target
op_assign
id|target
suffix:semicolon
id|mbox
op_assign
id|ccb-&gt;mbox
suffix:semicolon
id|mbox64
op_assign
id|ccb-&gt;mbox64
suffix:semicolon
id|mbox-&gt;logdrv
op_assign
id|target
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * A little HACK: 2nd bit is zero for all scsi read&n;&t;&t;&t; * commands and is set for all scsi write commands&n;&t;&t;&t; */
id|mbox-&gt;cmd
op_assign
(paren
id|scp-&gt;cmnd
(braket
l_int|0
)braket
op_amp
l_int|0x02
)paren
ques
c_cond
id|MBOXCMD_LWRITE64
suffix:colon
id|MBOXCMD_LREAD64
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * 6-byte READ(0x08) or WRITE(0x0A) cdb&n;&t;&t;&t; */
r_if
c_cond
(paren
id|scp-&gt;cmd_len
op_eq
l_int|6
)paren
(brace
id|mbox-&gt;numsectors
op_assign
(paren
r_uint32
)paren
id|scp-&gt;cmnd
(braket
l_int|4
)braket
suffix:semicolon
id|mbox-&gt;lba
op_assign
(paren
(paren
r_uint32
)paren
id|scp-&gt;cmnd
(braket
l_int|1
)braket
op_lshift
l_int|16
)paren
op_or
(paren
(paren
r_uint32
)paren
id|scp-&gt;cmnd
(braket
l_int|2
)braket
op_lshift
l_int|8
)paren
op_or
(paren
r_uint32
)paren
id|scp-&gt;cmnd
(braket
l_int|3
)braket
suffix:semicolon
id|mbox-&gt;lba
op_and_assign
l_int|0x1FFFFF
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * 10-byte READ(0x28) or WRITE(0x2A) cdb&n;&t;&t;&t; */
r_else
r_if
c_cond
(paren
id|scp-&gt;cmd_len
op_eq
l_int|10
)paren
(brace
id|mbox-&gt;numsectors
op_assign
(paren
r_uint32
)paren
id|scp-&gt;cmnd
(braket
l_int|8
)braket
op_or
(paren
(paren
r_uint32
)paren
id|scp-&gt;cmnd
(braket
l_int|7
)braket
op_lshift
l_int|8
)paren
suffix:semicolon
id|mbox-&gt;lba
op_assign
(paren
(paren
r_uint32
)paren
id|scp-&gt;cmnd
(braket
l_int|2
)braket
op_lshift
l_int|24
)paren
op_or
(paren
(paren
r_uint32
)paren
id|scp-&gt;cmnd
(braket
l_int|3
)braket
op_lshift
l_int|16
)paren
op_or
(paren
(paren
r_uint32
)paren
id|scp-&gt;cmnd
(braket
l_int|4
)braket
op_lshift
l_int|8
)paren
op_or
(paren
r_uint32
)paren
id|scp-&gt;cmnd
(braket
l_int|5
)braket
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * 12-byte READ(0xA8) or WRITE(0xAA) cdb&n;&t;&t;&t; */
r_else
r_if
c_cond
(paren
id|scp-&gt;cmd_len
op_eq
l_int|12
)paren
(brace
id|mbox-&gt;lba
op_assign
(paren
(paren
r_uint32
)paren
id|scp-&gt;cmnd
(braket
l_int|2
)braket
op_lshift
l_int|24
)paren
op_or
(paren
(paren
r_uint32
)paren
id|scp-&gt;cmnd
(braket
l_int|3
)braket
op_lshift
l_int|16
)paren
op_or
(paren
(paren
r_uint32
)paren
id|scp-&gt;cmnd
(braket
l_int|4
)braket
op_lshift
l_int|8
)paren
op_or
(paren
r_uint32
)paren
id|scp-&gt;cmnd
(braket
l_int|5
)braket
suffix:semicolon
id|mbox-&gt;numsectors
op_assign
(paren
(paren
r_uint32
)paren
id|scp-&gt;cmnd
(braket
l_int|6
)braket
op_lshift
l_int|24
)paren
op_or
(paren
(paren
r_uint32
)paren
id|scp-&gt;cmnd
(braket
l_int|7
)braket
op_lshift
l_int|16
)paren
op_or
(paren
(paren
r_uint32
)paren
id|scp-&gt;cmnd
(braket
l_int|8
)braket
op_lshift
l_int|8
)paren
op_or
(paren
r_uint32
)paren
id|scp-&gt;cmnd
(braket
l_int|9
)braket
suffix:semicolon
)brace
r_else
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid: unsupported CDB length&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|megaraid_dealloc_scb
c_func
(paren
id|adapter
comma
id|scb
)paren
suffix:semicolon
id|scp-&gt;result
op_assign
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|scb-&gt;dma_direction
op_assign
id|scp-&gt;sc_data_direction
suffix:semicolon
singleline_comment|// Calculate Scatter-Gather info
id|mbox64-&gt;xferaddr_lo
op_assign
(paren
r_uint32
)paren
id|ccb-&gt;sgl_dma_h
suffix:semicolon
id|mbox-&gt;numsge
op_assign
id|megaraid_mbox_mksgl
c_func
(paren
id|adapter
comma
id|scb
)paren
suffix:semicolon
id|mbox-&gt;xferaddr
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
id|mbox64-&gt;xferaddr_hi
op_assign
l_int|0
suffix:semicolon
r_return
id|scb
suffix:semicolon
r_case
id|RESERVE
suffix:colon
r_case
id|RELEASE
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Do we support clustering and is the support enabled&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|adapter-&gt;ha
)paren
(brace
id|scp-&gt;result
op_assign
(paren
id|DID_BAD_TARGET
op_lshift
l_int|16
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Allocate a SCB and initialize mailbox&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|scb
op_assign
id|megaraid_alloc_scb
c_func
(paren
id|adapter
comma
id|scp
)paren
)paren
)paren
(brace
id|scp-&gt;result
op_assign
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
op_star
id|busy
op_assign
l_int|1
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|ccb
op_assign
(paren
id|mbox_ccb_t
op_star
)paren
id|scb-&gt;ccb
suffix:semicolon
id|scb-&gt;dev_channel
op_assign
l_int|0xFF
suffix:semicolon
id|scb-&gt;dev_target
op_assign
id|target
suffix:semicolon
id|ccb-&gt;raw_mbox
(braket
l_int|0
)braket
op_assign
id|CLUSTER_CMD
suffix:semicolon
id|ccb-&gt;raw_mbox
(braket
l_int|2
)braket
op_assign
(paren
id|scp-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|RESERVE
)paren
ques
c_cond
id|RESERVE_LD
suffix:colon
id|RELEASE_LD
suffix:semicolon
id|ccb-&gt;raw_mbox
(braket
l_int|3
)braket
op_assign
id|target
suffix:semicolon
id|scb-&gt;dma_direction
op_assign
id|scp-&gt;sc_data_direction
suffix:semicolon
r_return
id|scb
suffix:semicolon
r_default
suffix:colon
id|scp-&gt;result
op_assign
(paren
id|DID_BAD_TARGET
op_lshift
l_int|16
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
(brace
singleline_comment|// Passthru device commands
singleline_comment|// Do not allow access to target id &gt; 15 or LUN &gt; 7
r_if
c_cond
(paren
id|target
OG
l_int|15
op_logical_or
id|SCP2LUN
c_func
(paren
id|scp
)paren
OG
l_int|7
)paren
(brace
id|scp-&gt;result
op_assign
(paren
id|DID_BAD_TARGET
op_lshift
l_int|16
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
singleline_comment|// if fast load option was set and scan for last device is
singleline_comment|// over, reset the fast_load flag so that during a possible
singleline_comment|// next scan, devices can be made available
r_if
c_cond
(paren
id|rdev-&gt;fast_load
op_logical_and
(paren
id|target
op_eq
l_int|15
)paren
op_logical_and
(paren
id|SCP2CHANNEL
c_func
(paren
id|scp
)paren
op_eq
id|adapter-&gt;max_channel
op_minus
l_int|1
)paren
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_INFO
l_string|&quot;megaraid[%d]: physical device scan re-enabled&bslash;n&quot;
comma
id|adapter-&gt;host-&gt;host_no
)paren
)paren
suffix:semicolon
id|rdev-&gt;fast_load
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Display the channel scan for physical devices&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|rdev-&gt;last_disp
op_amp
(paren
l_int|1L
op_lshift
id|SCP2CHANNEL
c_func
(paren
id|scp
)paren
)paren
)paren
)paren
(brace
id|ss
op_assign
id|rdev-&gt;fast_load
ques
c_cond
id|skip
suffix:colon
id|scan
suffix:semicolon
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_INFO
l_string|&quot;scsi[%d]: %s scsi channel %d [Phy %d]&quot;
comma
id|adapter-&gt;host-&gt;host_no
comma
id|ss
comma
id|SCP2CHANNEL
c_func
(paren
id|scp
)paren
comma
id|channel
)paren
)paren
suffix:semicolon
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
l_string|&quot; for non-raid devices&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|rdev-&gt;last_disp
op_or_assign
(paren
l_int|1L
op_lshift
id|SCP2CHANNEL
c_func
(paren
id|scp
)paren
)paren
suffix:semicolon
)brace
singleline_comment|// disable channel sweep if fast load option given
r_if
c_cond
(paren
id|rdev-&gt;fast_load
)paren
(brace
id|scp-&gt;result
op_assign
(paren
id|DID_BAD_TARGET
op_lshift
l_int|16
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
singleline_comment|// Allocate a SCB and initialize passthru
r_if
c_cond
(paren
op_logical_neg
(paren
id|scb
op_assign
id|megaraid_alloc_scb
c_func
(paren
id|adapter
comma
id|scp
)paren
)paren
)paren
(brace
id|scp-&gt;result
op_assign
(paren
id|DID_ERROR
op_lshift
l_int|16
)paren
suffix:semicolon
op_star
id|busy
op_assign
l_int|1
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|ccb
op_assign
(paren
id|mbox_ccb_t
op_star
)paren
id|scb-&gt;ccb
suffix:semicolon
id|scb-&gt;dev_channel
op_assign
id|channel
suffix:semicolon
id|scb-&gt;dev_target
op_assign
id|target
suffix:semicolon
id|scb-&gt;dma_direction
op_assign
id|scp-&gt;sc_data_direction
suffix:semicolon
id|mbox
op_assign
id|ccb-&gt;mbox
suffix:semicolon
id|mbox64
op_assign
id|ccb-&gt;mbox64
suffix:semicolon
singleline_comment|// Does this firmware support extended CDBs
r_if
c_cond
(paren
id|adapter-&gt;max_cdb_sz
op_eq
l_int|16
)paren
(brace
id|mbox-&gt;cmd
op_assign
id|MBOXCMD_EXTPTHRU
suffix:semicolon
id|megaraid_mbox_prepare_epthru
c_func
(paren
id|adapter
comma
id|scb
comma
id|scp
)paren
suffix:semicolon
id|mbox64-&gt;xferaddr_lo
op_assign
(paren
r_uint32
)paren
id|ccb-&gt;epthru_dma_h
suffix:semicolon
id|mbox64-&gt;xferaddr_hi
op_assign
l_int|0
suffix:semicolon
id|mbox-&gt;xferaddr
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
)brace
r_else
(brace
id|mbox-&gt;cmd
op_assign
id|MBOXCMD_PASSTHRU64
suffix:semicolon
id|megaraid_mbox_prepare_pthru
c_func
(paren
id|adapter
comma
id|scb
comma
id|scp
)paren
suffix:semicolon
id|mbox64-&gt;xferaddr_lo
op_assign
(paren
r_uint32
)paren
id|ccb-&gt;pthru_dma_h
suffix:semicolon
id|mbox64-&gt;xferaddr_hi
op_assign
l_int|0
suffix:semicolon
id|mbox-&gt;xferaddr
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
)brace
r_return
id|scb
suffix:semicolon
)brace
singleline_comment|// NOT REACHED
)brace
multiline_comment|/**&n; * megaraid_mbox_runpendq - execute commands queued in the pending queue&n; * @adapter&t;: controller&squot;s soft state&n; * @scb&t;&t;: SCB to be queued in the pending list&n; *&n; * scan the pending list for commands which are not yet issued and try to&n; * post to the controller. The SCB can be a null pointer, which would indicate&n; * no SCB to be queue, just try to execute the ones in the pending list.&n; *&n; * NOTE: We do not actually traverse the pending list. The SCBs are plucked&n; * out from the head of the pending list. If it is successfully issued, the&n; * next SCB is at the head now.&n; */
r_static
r_void
DECL|function|megaraid_mbox_runpendq
id|megaraid_mbox_runpendq
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
id|scb_t
op_star
id|scb_q
)paren
(brace
id|scb_t
op_star
id|scb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|PENDING_LIST_LOCK
c_func
(paren
id|adapter
)paren
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb_q
)paren
(brace
id|scb_q-&gt;state
op_assign
id|SCB_PENDQ
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|scb_q-&gt;list
comma
op_amp
id|adapter-&gt;pend_list
)paren
suffix:semicolon
)brace
singleline_comment|// if the adapter in not in quiescent mode, post the commands to FW
r_if
c_cond
(paren
id|adapter-&gt;quiescent
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
id|PENDING_LIST_LOCK
c_func
(paren
id|adapter
)paren
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|adapter-&gt;pend_list
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|spin_is_locked
c_func
(paren
id|PENDING_LIST_LOCK
c_func
(paren
id|adapter
)paren
)paren
)paren
suffix:semicolon
id|scb
op_assign
id|list_entry
c_func
(paren
id|adapter-&gt;pend_list.next
comma
id|scb_t
comma
id|list
)paren
suffix:semicolon
singleline_comment|// remove the scb from the pending list and try to
singleline_comment|// issue. If we are unable to issue it, put back in
singleline_comment|// the pending list and return
id|list_del_init
c_func
(paren
op_amp
id|scb-&gt;list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|PENDING_LIST_LOCK
c_func
(paren
id|adapter
)paren
comma
id|flags
)paren
suffix:semicolon
singleline_comment|// if mailbox was busy, return SCB back to pending
singleline_comment|// list. Make sure to add at the head, since that&squot;s
singleline_comment|// where it would have been removed from
id|scb-&gt;state
op_assign
id|SCB_ISSUED
suffix:semicolon
r_if
c_cond
(paren
id|mbox_post_cmd
c_func
(paren
id|adapter
comma
id|scb
)paren
op_ne
l_int|0
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
id|PENDING_LIST_LOCK
c_func
(paren
id|adapter
)paren
comma
id|flags
)paren
suffix:semicolon
id|scb-&gt;state
op_assign
id|SCB_PENDQ
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|scb-&gt;list
comma
op_amp
id|adapter-&gt;pend_list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|PENDING_LIST_LOCK
c_func
(paren
id|adapter
)paren
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
id|PENDING_LIST_LOCK
c_func
(paren
id|adapter
)paren
comma
id|flags
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
id|PENDING_LIST_LOCK
c_func
(paren
id|adapter
)paren
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_mbox_prepare_pthru - prepare a command for physical devices&n; * @adapter&t;- pointer to controller&squot;s soft state&n; * @scb&t;&t;- scsi control block&n; * @scp&t;&t;- scsi command from the mid-layer&n; *&n; * prepare a command for the scsi physical devices&n; */
r_static
r_void
DECL|function|megaraid_mbox_prepare_pthru
id|megaraid_mbox_prepare_pthru
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
id|scb_t
op_star
id|scb
comma
r_struct
id|scsi_cmnd
op_star
id|scp
)paren
(brace
id|mbox_ccb_t
op_star
id|ccb
suffix:semicolon
id|mraid_passthru_t
op_star
id|pthru
suffix:semicolon
r_uint8
id|channel
suffix:semicolon
r_uint8
id|target
suffix:semicolon
id|ccb
op_assign
(paren
id|mbox_ccb_t
op_star
)paren
id|scb-&gt;ccb
suffix:semicolon
id|pthru
op_assign
id|ccb-&gt;pthru
suffix:semicolon
id|channel
op_assign
id|scb-&gt;dev_channel
suffix:semicolon
id|target
op_assign
id|scb-&gt;dev_target
suffix:semicolon
id|pthru-&gt;timeout
op_assign
l_int|1
suffix:semicolon
singleline_comment|// 0=6sec, 1=60sec, 2=10min, 3=3hrs
id|pthru-&gt;ars
op_assign
l_int|1
suffix:semicolon
id|pthru-&gt;islogical
op_assign
l_int|0
suffix:semicolon
id|pthru-&gt;channel
op_assign
l_int|0
suffix:semicolon
id|pthru-&gt;target
op_assign
(paren
id|channel
op_lshift
l_int|4
)paren
op_or
id|target
suffix:semicolon
id|pthru-&gt;logdrv
op_assign
id|SCP2LUN
c_func
(paren
id|scp
)paren
suffix:semicolon
id|pthru-&gt;reqsenselen
op_assign
l_int|14
suffix:semicolon
id|pthru-&gt;cdblen
op_assign
id|scp-&gt;cmd_len
suffix:semicolon
id|memcpy
c_func
(paren
id|pthru-&gt;cdb
comma
id|scp-&gt;cmnd
comma
id|scp-&gt;cmd_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scp-&gt;request_bufflen
)paren
(brace
id|pthru-&gt;dataxferlen
op_assign
id|scp-&gt;request_bufflen
suffix:semicolon
id|pthru-&gt;dataxferaddr
op_assign
id|ccb-&gt;sgl_dma_h
suffix:semicolon
id|pthru-&gt;numsge
op_assign
id|megaraid_mbox_mksgl
c_func
(paren
id|adapter
comma
id|scb
)paren
suffix:semicolon
)brace
r_else
(brace
id|pthru-&gt;dataxferaddr
op_assign
l_int|0
suffix:semicolon
id|pthru-&gt;dataxferlen
op_assign
l_int|0
suffix:semicolon
id|pthru-&gt;numsge
op_assign
l_int|0
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_mbox_prepare_epthru - prepare a command for physical devices&n; * @adapter&t;- pointer to controller&squot;s soft state&n; * @scb&t;&t;- scsi control block&n; * @scp&t;&t;- scsi command from the mid-layer&n; *&n; * prepare a command for the scsi physical devices. This rountine prepares&n; * commands for devices which can take extended CDBs (&gt;10 bytes)&n; */
r_static
r_void
DECL|function|megaraid_mbox_prepare_epthru
id|megaraid_mbox_prepare_epthru
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
id|scb_t
op_star
id|scb
comma
r_struct
id|scsi_cmnd
op_star
id|scp
)paren
(brace
id|mbox_ccb_t
op_star
id|ccb
suffix:semicolon
id|mraid_epassthru_t
op_star
id|epthru
suffix:semicolon
r_uint8
id|channel
suffix:semicolon
r_uint8
id|target
suffix:semicolon
id|ccb
op_assign
(paren
id|mbox_ccb_t
op_star
)paren
id|scb-&gt;ccb
suffix:semicolon
id|epthru
op_assign
id|ccb-&gt;epthru
suffix:semicolon
id|channel
op_assign
id|scb-&gt;dev_channel
suffix:semicolon
id|target
op_assign
id|scb-&gt;dev_target
suffix:semicolon
id|epthru-&gt;timeout
op_assign
l_int|1
suffix:semicolon
singleline_comment|// 0=6sec, 1=60sec, 2=10min, 3=3hrs
id|epthru-&gt;ars
op_assign
l_int|1
suffix:semicolon
id|epthru-&gt;islogical
op_assign
l_int|0
suffix:semicolon
id|epthru-&gt;channel
op_assign
l_int|0
suffix:semicolon
id|epthru-&gt;target
op_assign
(paren
id|channel
op_lshift
l_int|4
)paren
op_or
id|target
suffix:semicolon
id|epthru-&gt;logdrv
op_assign
id|SCP2LUN
c_func
(paren
id|scp
)paren
suffix:semicolon
id|epthru-&gt;reqsenselen
op_assign
l_int|14
suffix:semicolon
id|epthru-&gt;cdblen
op_assign
id|scp-&gt;cmd_len
suffix:semicolon
id|memcpy
c_func
(paren
id|epthru-&gt;cdb
comma
id|scp-&gt;cmnd
comma
id|scp-&gt;cmd_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scp-&gt;request_bufflen
)paren
(brace
id|epthru-&gt;dataxferlen
op_assign
id|scp-&gt;request_bufflen
suffix:semicolon
id|epthru-&gt;dataxferaddr
op_assign
id|ccb-&gt;sgl_dma_h
suffix:semicolon
id|epthru-&gt;numsge
op_assign
id|megaraid_mbox_mksgl
c_func
(paren
id|adapter
comma
id|scb
)paren
suffix:semicolon
)brace
r_else
(brace
id|epthru-&gt;dataxferaddr
op_assign
l_int|0
suffix:semicolon
id|epthru-&gt;dataxferlen
op_assign
l_int|0
suffix:semicolon
id|epthru-&gt;numsge
op_assign
l_int|0
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_ack_sequence - interrupt ack sequence for memory mapped HBAs&n; * @adapter&t;- controller&squot;s soft state&n; *&n; * Interrupt ackrowledgement sequence for memory mapped HBAs. Find out the&n; * completed command and put them on the completed list for later processing.&n; *&n; * Returns:&t;1 if the interrupt is valid, 0 otherwise&n; */
r_static
r_inline
r_int
DECL|function|megaraid_ack_sequence
id|megaraid_ack_sequence
c_func
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
id|mraid_device_t
op_star
id|raid_dev
op_assign
id|ADAP2RAIDDEV
c_func
(paren
id|adapter
)paren
suffix:semicolon
id|mbox_t
op_star
id|mbox
suffix:semicolon
id|scb_t
op_star
id|scb
suffix:semicolon
r_uint8
id|nstatus
suffix:semicolon
r_uint8
id|completed
(braket
id|MBOX_MAX_FIRMWARE_STATUS
)braket
suffix:semicolon
r_struct
id|list_head
id|clist
suffix:semicolon
r_int
id|handled
suffix:semicolon
r_uint32
id|dword
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
id|mbox
op_assign
id|raid_dev-&gt;mbox
suffix:semicolon
singleline_comment|// move the SCBs from the firmware completed array to our local list
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|clist
)paren
suffix:semicolon
singleline_comment|// loop till F/W has more commands for us to complete
id|handled
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|MAILBOX_LOCK
c_func
(paren
id|raid_dev
)paren
comma
id|flags
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/*&n;&t;&t; * Check if a valid interrupt is pending. If found, force the&n;&t;&t; * interrupt line low.&n;&t;&t; */
id|dword
op_assign
id|RDOUTDOOR
c_func
(paren
id|raid_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dword
op_ne
l_int|0x10001234
)paren
r_break
suffix:semicolon
id|handled
op_assign
l_int|1
suffix:semicolon
id|WROUTDOOR
c_func
(paren
id|raid_dev
comma
l_int|0x10001234
)paren
suffix:semicolon
id|nstatus
op_assign
l_int|0
suffix:semicolon
singleline_comment|// wait for valid numstatus to post
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|0xFFFFF
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mbox-&gt;numstatus
op_ne
l_int|0xFF
)paren
(brace
id|nstatus
op_assign
id|mbox-&gt;numstatus
suffix:semicolon
r_break
suffix:semicolon
)brace
id|rmb
c_func
(paren
)paren
suffix:semicolon
)brace
id|mbox-&gt;numstatus
op_assign
l_int|0xFF
suffix:semicolon
id|adapter-&gt;outstanding_cmds
op_sub_assign
id|nstatus
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nstatus
suffix:semicolon
id|i
op_increment
)paren
(brace
singleline_comment|// wait for valid command index to post
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|0xFFFFF
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mbox-&gt;completed
(braket
id|i
)braket
op_ne
l_int|0xFF
)paren
r_break
suffix:semicolon
id|rmb
c_func
(paren
)paren
suffix:semicolon
)brace
id|completed
(braket
id|i
)braket
op_assign
id|mbox-&gt;completed
(braket
id|i
)braket
suffix:semicolon
id|mbox-&gt;completed
(braket
id|i
)braket
op_assign
l_int|0xFF
suffix:semicolon
r_if
c_cond
(paren
id|completed
(braket
id|i
)braket
op_eq
l_int|0xFF
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_CRIT
l_string|&quot;megaraid: command posting timed out&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
singleline_comment|// Get SCB associated with this command id
r_if
c_cond
(paren
id|completed
(braket
id|i
)braket
op_ge
id|MBOX_MAX_SCSI_CMDS
)paren
(brace
singleline_comment|// a cmm command
id|scb
op_assign
id|adapter-&gt;uscb_list
op_plus
(paren
id|completed
(braket
id|i
)braket
op_minus
id|MBOX_MAX_SCSI_CMDS
)paren
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// an os command
id|scb
op_assign
id|adapter-&gt;kscb_list
op_plus
id|completed
(braket
id|i
)braket
suffix:semicolon
)brace
id|scb-&gt;status
op_assign
id|mbox-&gt;status
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|scb-&gt;list
comma
op_amp
id|clist
)paren
suffix:semicolon
)brace
singleline_comment|// Acknowledge interrupt
id|WRINDOOR
c_func
(paren
id|raid_dev
comma
l_int|0x02
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
id|MAILBOX_LOCK
c_func
(paren
id|raid_dev
)paren
comma
id|flags
)paren
suffix:semicolon
singleline_comment|// put the completed commands in the completed list. DPC would
singleline_comment|// complete these commands later
id|spin_lock_irqsave
c_func
(paren
id|COMPLETED_LIST_LOCK
c_func
(paren
id|adapter
)paren
comma
id|flags
)paren
suffix:semicolon
id|list_splice
c_func
(paren
op_amp
id|clist
comma
op_amp
id|adapter-&gt;completed_list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|COMPLETED_LIST_LOCK
c_func
(paren
id|adapter
)paren
comma
id|flags
)paren
suffix:semicolon
singleline_comment|// schedule the DPC if there is some work for it
r_if
c_cond
(paren
id|handled
)paren
id|tasklet_schedule
c_func
(paren
op_amp
id|adapter-&gt;dpc_h
)paren
suffix:semicolon
r_return
id|handled
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_isr - isr for memory based mailbox based controllers&n; * @irq&t;&t;- irq&n; * @devp&t;- pointer to our soft state&n; * @regs&t;- unused&n; *&n; * Interrupt service routine for memory-mapped mailbox controllers.&n; */
r_static
id|irqreturn_t
DECL|function|megaraid_isr
id|megaraid_isr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|devp
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|adapter_t
op_star
id|adapter
op_assign
id|devp
suffix:semicolon
r_int
id|handled
suffix:semicolon
id|handled
op_assign
id|megaraid_ack_sequence
c_func
(paren
id|adapter
)paren
suffix:semicolon
multiline_comment|/* Loop through any pending requests */
r_if
c_cond
(paren
op_logical_neg
id|adapter-&gt;quiescent
)paren
(brace
id|megaraid_mbox_runpendq
c_func
(paren
id|adapter
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_return
id|IRQ_RETVAL
c_func
(paren
id|handled
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_mbox_sync_scb - sync kernel buffers&n; * @adapter&t;: controller&squot;s soft state&n; * @scb&t;&t;: pointer to the resource packet&n; *&n; * DMA sync if required.&n; */
r_static
r_inline
r_void
DECL|function|megaraid_mbox_sync_scb
id|megaraid_mbox_sync_scb
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
id|scb_t
op_star
id|scb
)paren
(brace
id|mbox_ccb_t
op_star
id|ccb
suffix:semicolon
id|ccb
op_assign
(paren
id|mbox_ccb_t
op_star
)paren
id|scb-&gt;ccb
suffix:semicolon
r_switch
c_cond
(paren
id|scb-&gt;dma_type
)paren
(brace
r_case
id|MRAID_DMA_WBUF
suffix:colon
r_if
c_cond
(paren
id|scb-&gt;dma_direction
op_eq
id|PCI_DMA_FROMDEVICE
)paren
(brace
id|pci_dma_sync_single_for_cpu
c_func
(paren
id|adapter-&gt;pdev
comma
id|ccb-&gt;buf_dma_h
comma
id|scb-&gt;scp-&gt;request_bufflen
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
)brace
id|pci_unmap_page
c_func
(paren
id|adapter-&gt;pdev
comma
id|ccb-&gt;buf_dma_h
comma
id|scb-&gt;scp-&gt;request_bufflen
comma
id|scb-&gt;dma_direction
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MRAID_DMA_WSG
suffix:colon
r_if
c_cond
(paren
id|scb-&gt;dma_direction
op_eq
id|PCI_DMA_FROMDEVICE
)paren
(brace
id|pci_dma_sync_sg_for_cpu
c_func
(paren
id|adapter-&gt;pdev
comma
id|scb-&gt;scp-&gt;request_buffer
comma
id|scb-&gt;scp-&gt;use_sg
comma
id|PCI_DMA_FROMDEVICE
)paren
suffix:semicolon
)brace
id|pci_unmap_sg
c_func
(paren
id|adapter-&gt;pdev
comma
id|scb-&gt;scp-&gt;request_buffer
comma
id|scb-&gt;scp-&gt;use_sg
comma
id|scb-&gt;dma_direction
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_mbox_dpc - the tasklet to complete the commands from completed list&n; * @devp&t;: pointer to HBA soft state&n; *&n; * Pick up the commands from the completed list and send back to the owners.&n; * This is a reentrant function and does not assume any locks are held while&n; * it is being called.&n; */
r_static
r_void
DECL|function|megaraid_mbox_dpc
id|megaraid_mbox_dpc
c_func
(paren
r_int
r_int
id|devp
)paren
(brace
id|adapter_t
op_star
id|adapter
op_assign
(paren
id|adapter_t
op_star
)paren
id|devp
suffix:semicolon
id|mraid_device_t
op_star
id|raid_dev
suffix:semicolon
r_struct
id|list_head
id|clist
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sgl
suffix:semicolon
id|scb_t
op_star
id|scb
suffix:semicolon
id|scb_t
op_star
id|tmp
suffix:semicolon
r_struct
id|scsi_cmnd
op_star
id|scp
suffix:semicolon
id|mraid_passthru_t
op_star
id|pthru
suffix:semicolon
id|mraid_epassthru_t
op_star
id|epthru
suffix:semicolon
id|mbox_ccb_t
op_star
id|ccb
suffix:semicolon
r_int
id|islogical
suffix:semicolon
r_int
id|pdev_index
suffix:semicolon
r_int
id|pdev_state
suffix:semicolon
id|mbox_t
op_star
id|mbox
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_uint8
id|c
suffix:semicolon
r_int
id|status
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|adapter
)paren
r_return
suffix:semicolon
id|raid_dev
op_assign
id|ADAP2RAIDDEV
c_func
(paren
id|adapter
)paren
suffix:semicolon
singleline_comment|// move the SCBs from the completed list to our local list
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|clist
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|COMPLETED_LIST_LOCK
c_func
(paren
id|adapter
)paren
comma
id|flags
)paren
suffix:semicolon
id|list_splice_init
c_func
(paren
op_amp
id|adapter-&gt;completed_list
comma
op_amp
id|clist
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|COMPLETED_LIST_LOCK
c_func
(paren
id|adapter
)paren
comma
id|flags
)paren
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|scb
comma
id|tmp
comma
op_amp
id|clist
comma
id|list
)paren
(brace
id|status
op_assign
id|scb-&gt;status
suffix:semicolon
id|scp
op_assign
id|scb-&gt;scp
suffix:semicolon
id|ccb
op_assign
(paren
id|mbox_ccb_t
op_star
)paren
id|scb-&gt;ccb
suffix:semicolon
id|pthru
op_assign
id|ccb-&gt;pthru
suffix:semicolon
id|epthru
op_assign
id|ccb-&gt;epthru
suffix:semicolon
id|mbox
op_assign
id|ccb-&gt;mbox
suffix:semicolon
singleline_comment|// Make sure f/w has completed a valid command
r_if
c_cond
(paren
id|scb-&gt;state
op_ne
id|SCB_ISSUED
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_CRIT
l_string|&quot;megaraid critical err: invalid command %d:%d:%p&bslash;n&quot;
comma
id|scb-&gt;sno
comma
id|scb-&gt;state
comma
id|scp
)paren
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
singleline_comment|// Must never happen!
)brace
singleline_comment|// check for the management command and complete it right away
r_if
c_cond
(paren
id|scb-&gt;sno
op_ge
id|MBOX_MAX_SCSI_CMDS
)paren
(brace
id|scb-&gt;state
op_assign
id|SCB_FREE
suffix:semicolon
id|scb-&gt;status
op_assign
id|status
suffix:semicolon
singleline_comment|// remove from local clist
id|list_del_init
c_func
(paren
op_amp
id|scb-&gt;list
)paren
suffix:semicolon
id|megaraid_mbox_mm_done
c_func
(paren
id|adapter
comma
id|scb
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
singleline_comment|// Was an abort issued for this command earlier
r_if
c_cond
(paren
id|scb-&gt;state
op_amp
id|SCB_ABORT
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_NOTICE
l_string|&quot;megaraid: aborted cmd %lx[%x] completed&bslash;n&quot;
comma
id|scp-&gt;serial_number
comma
id|scb-&gt;sno
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If the inquiry came of a disk drive which is not part of&n;&t;&t; * any RAID array, expose it to the kernel. For this to be&n;&t;&t; * enabled, user must set the &quot;megaraid_expose_unconf_disks&quot;&n;&t;&t; * flag to 1 by specifying it on module parameter list.&n;&t;&t; * This would enable data migration off drives from other&n;&t;&t; * configurations.&n;&t;&t; */
id|islogical
op_assign
id|MRAID_IS_LOGICAL
c_func
(paren
id|adapter
comma
id|scp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scp-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
op_logical_and
id|status
op_eq
l_int|0
op_logical_and
id|islogical
op_eq
l_int|0
op_logical_and
id|IS_RAID_CH
c_func
(paren
id|raid_dev
comma
id|scb-&gt;dev_channel
)paren
)paren
(brace
r_if
c_cond
(paren
id|scp-&gt;use_sg
)paren
(brace
id|sgl
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|scp-&gt;request_buffer
suffix:semicolon
r_if
c_cond
(paren
id|sgl-&gt;page
)paren
(brace
id|c
op_assign
op_star
(paren
r_int
r_char
op_star
)paren
(paren
id|page_address
c_func
(paren
(paren
op_amp
id|sgl
(braket
l_int|0
)braket
)paren
op_member_access_from_pointer
id|page
)paren
op_plus
(paren
op_amp
id|sgl
(braket
l_int|0
)braket
)paren
op_member_access_from_pointer
id|offset
)paren
suffix:semicolon
)brace
r_else
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid mailbox: invalid sg:%d&bslash;n&quot;
comma
id|__LINE__
)paren
)paren
suffix:semicolon
id|c
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|c
op_assign
op_star
(paren
r_uint8
op_star
)paren
id|scp-&gt;request_buffer
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|c
op_amp
l_int|0x1F
)paren
op_eq
id|TYPE_DISK
)paren
(brace
id|pdev_index
op_assign
(paren
id|scb-&gt;dev_channel
op_star
l_int|16
)paren
op_plus
id|scb-&gt;dev_target
suffix:semicolon
id|pdev_state
op_assign
id|raid_dev-&gt;pdrv_state
(braket
id|pdev_index
)braket
op_amp
l_int|0x0F
suffix:semicolon
r_if
c_cond
(paren
id|pdev_state
op_eq
id|PDRV_ONLINE
op_logical_or
id|pdev_state
op_eq
id|PDRV_FAILED
op_logical_or
id|pdev_state
op_eq
id|PDRV_RBLD
op_logical_or
id|pdev_state
op_eq
id|PDRV_HOTSPARE
op_logical_or
id|megaraid_expose_unconf_disks
op_eq
l_int|0
)paren
(brace
id|status
op_assign
l_int|0xF0
suffix:semicolon
)brace
)brace
)brace
singleline_comment|// Convert MegaRAID status to Linux error code
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
l_int|0x00
suffix:colon
id|scp-&gt;result
op_assign
(paren
id|DID_OK
op_lshift
l_int|16
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x02
suffix:colon
multiline_comment|/* set sense_buffer and result fields */
r_if
c_cond
(paren
id|mbox-&gt;cmd
op_eq
id|MBOXCMD_PASSTHRU
op_logical_or
id|mbox-&gt;cmd
op_eq
id|MBOXCMD_PASSTHRU64
)paren
(brace
id|memcpy
c_func
(paren
id|scp-&gt;sense_buffer
comma
id|pthru-&gt;reqsensearea
comma
l_int|14
)paren
suffix:semicolon
id|scp-&gt;result
op_assign
id|DRIVER_SENSE
op_lshift
l_int|24
op_or
id|DID_OK
op_lshift
l_int|16
op_or
id|CHECK_CONDITION
op_lshift
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|mbox-&gt;cmd
op_eq
id|MBOXCMD_EXTPTHRU
)paren
(brace
id|memcpy
c_func
(paren
id|scp-&gt;sense_buffer
comma
id|epthru-&gt;reqsensearea
comma
l_int|14
)paren
suffix:semicolon
id|scp-&gt;result
op_assign
id|DRIVER_SENSE
op_lshift
l_int|24
op_or
id|DID_OK
op_lshift
l_int|16
op_or
id|CHECK_CONDITION
op_lshift
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|scp-&gt;sense_buffer
(braket
l_int|0
)braket
op_assign
l_int|0x70
suffix:semicolon
id|scp-&gt;sense_buffer
(braket
l_int|2
)braket
op_assign
id|ABORTED_COMMAND
suffix:semicolon
id|scp-&gt;result
op_assign
id|CHECK_CONDITION
op_lshift
l_int|1
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
l_int|0x08
suffix:colon
id|scp-&gt;result
op_assign
id|DID_BUS_BUSY
op_lshift
l_int|16
op_or
id|status
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/*&n;&t;&t;&t; * If TEST_UNIT_READY fails, we know RESERVATION_STATUS&n;&t;&t;&t; * failed&n;&t;&t;&t; */
r_if
c_cond
(paren
id|scp-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|TEST_UNIT_READY
)paren
(brace
id|scp-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
op_or
id|RESERVATION_CONFLICT
op_lshift
l_int|1
suffix:semicolon
)brace
r_else
multiline_comment|/*&n;&t;&t;&t; * Error code returned is 1 if Reserve or Release&n;&t;&t;&t; * failed or the input parameter is invalid&n;&t;&t;&t; */
r_if
c_cond
(paren
id|status
op_eq
l_int|1
op_logical_and
(paren
id|scp-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|RESERVE
op_logical_or
id|scp-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|RELEASE
)paren
)paren
(brace
id|scp-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
op_or
id|RESERVATION_CONFLICT
op_lshift
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|scp-&gt;result
op_assign
id|DID_BAD_TARGET
op_lshift
l_int|16
op_or
id|status
suffix:semicolon
)brace
)brace
singleline_comment|// print a debug message for all failed commands
r_if
c_cond
(paren
id|status
)paren
(brace
id|megaraid_mbox_display_scb
c_func
(paren
id|adapter
comma
id|scb
)paren
suffix:semicolon
)brace
singleline_comment|// Free our internal resources and call the mid-layer callback
singleline_comment|// routine
id|megaraid_mbox_sync_scb
c_func
(paren
id|adapter
comma
id|scb
)paren
suffix:semicolon
singleline_comment|// remove from local clist
id|list_del_init
c_func
(paren
op_amp
id|scb-&gt;list
)paren
suffix:semicolon
singleline_comment|// put back in free list
id|megaraid_dealloc_scb
c_func
(paren
id|adapter
comma
id|scb
)paren
suffix:semicolon
singleline_comment|// send the scsi packet back to kernel
id|spin_lock
c_func
(paren
id|adapter-&gt;host_lock
)paren
suffix:semicolon
id|scp
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|scp
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
id|adapter-&gt;host_lock
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_abort_handler - abort the scsi command&n; * @scp&t;&t;: command to be aborted&n; *&n; * Abort a previous SCSI request. Only commands on the pending list can be&n; * aborted. All the commands issued to the F/W must complete.&n; **/
r_static
r_int
DECL|function|megaraid_abort_handler
id|megaraid_abort_handler
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|scp
)paren
(brace
id|adapter_t
op_star
id|adapter
suffix:semicolon
id|mraid_device_t
op_star
id|raid_dev
suffix:semicolon
id|scb_t
op_star
id|scb
suffix:semicolon
id|scb_t
op_star
id|tmp
suffix:semicolon
r_int
id|found
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
id|adapter
op_assign
id|SCP2ADAPTER
c_func
(paren
id|scp
)paren
suffix:semicolon
id|raid_dev
op_assign
id|ADAP2RAIDDEV
c_func
(paren
id|adapter
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|spin_is_locked
c_func
(paren
id|adapter-&gt;host_lock
)paren
)paren
suffix:semicolon
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid: aborting-%ld cmd=%x &lt;c=%d t=%d l=%d&gt;&bslash;n&quot;
comma
id|scp-&gt;serial_number
comma
id|scp-&gt;cmnd
(braket
l_int|0
)braket
comma
id|SCP2CHANNEL
c_func
(paren
id|scp
)paren
comma
id|SCP2TARGET
c_func
(paren
id|scp
)paren
comma
id|SCP2LUN
c_func
(paren
id|scp
)paren
)paren
)paren
suffix:semicolon
singleline_comment|// If FW has stopped responding, simply return failure
r_if
c_cond
(paren
id|raid_dev-&gt;hw_error
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_NOTICE
l_string|&quot;megaraid: hw error, not aborting&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|FAILED
suffix:semicolon
)brace
singleline_comment|// There might a race here, where the command was completed by the
singleline_comment|// firmware and now it is on the completed list. Before we could
singleline_comment|// complete the command to the kernel in dpc, the abort came.
singleline_comment|// Find out if this is the case to avoid the race.
id|scb
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|COMPLETED_LIST_LOCK
c_func
(paren
id|adapter
)paren
comma
id|flags
)paren
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|scb
comma
id|tmp
comma
op_amp
id|adapter-&gt;completed_list
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|scb-&gt;scp
op_eq
id|scp
)paren
(brace
singleline_comment|// Found command
id|list_del_init
c_func
(paren
op_amp
id|scb-&gt;list
)paren
suffix:semicolon
singleline_comment|// from completed list
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid: %ld:%d[%d:%d], abort from completed list&bslash;n&quot;
comma
id|scp-&gt;serial_number
comma
id|scb-&gt;sno
comma
id|scb-&gt;dev_channel
comma
id|scb-&gt;dev_target
)paren
)paren
suffix:semicolon
id|scp-&gt;result
op_assign
(paren
id|DID_ABORT
op_lshift
l_int|16
)paren
suffix:semicolon
id|scp
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|scp
)paren
suffix:semicolon
id|megaraid_dealloc_scb
c_func
(paren
id|adapter
comma
id|scb
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|COMPLETED_LIST_LOCK
c_func
(paren
id|adapter
)paren
comma
id|flags
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
id|COMPLETED_LIST_LOCK
c_func
(paren
id|adapter
)paren
comma
id|flags
)paren
suffix:semicolon
singleline_comment|// Find out if this command is still on the pending list. If it is and
singleline_comment|// was never issued, abort and return success. If the command is owned
singleline_comment|// by the firmware, we must wait for it to complete by the FW.
id|spin_lock_irqsave
c_func
(paren
id|PENDING_LIST_LOCK
c_func
(paren
id|adapter
)paren
comma
id|flags
)paren
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|scb
comma
id|tmp
comma
op_amp
id|adapter-&gt;pend_list
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|scb-&gt;scp
op_eq
id|scp
)paren
(brace
singleline_comment|// Found command
id|list_del_init
c_func
(paren
op_amp
id|scb-&gt;list
)paren
suffix:semicolon
singleline_comment|// from pending list
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|scb-&gt;state
op_amp
id|SCB_ISSUED
)paren
)paren
suffix:semicolon
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid abort: %ld[%d:%d], driver owner&bslash;n&quot;
comma
id|scp-&gt;serial_number
comma
id|scb-&gt;dev_channel
comma
id|scb-&gt;dev_target
)paren
)paren
suffix:semicolon
id|scp-&gt;result
op_assign
(paren
id|DID_ABORT
op_lshift
l_int|16
)paren
suffix:semicolon
id|scp
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|scp
)paren
suffix:semicolon
id|megaraid_dealloc_scb
c_func
(paren
id|adapter
comma
id|scb
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|PENDING_LIST_LOCK
c_func
(paren
id|adapter
)paren
comma
id|flags
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
id|PENDING_LIST_LOCK
c_func
(paren
id|adapter
)paren
comma
id|flags
)paren
suffix:semicolon
singleline_comment|// Check do we even own this command, in which case this would be
singleline_comment|// owned by the firmware. The only way to locate the FW scb is to
singleline_comment|// traverse through the list of all SCB, since driver does not
singleline_comment|// maintain these SCBs on any list
id|found
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MBOX_MAX_SCSI_CMDS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|scb
op_assign
id|adapter-&gt;kscb_list
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|scb-&gt;scp
op_eq
id|scp
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|scb-&gt;state
op_amp
id|SCB_ISSUED
)paren
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid abort: %ld%d[%d:%d], invalid state&bslash;n&quot;
comma
id|scp-&gt;serial_number
comma
id|scb-&gt;sno
comma
id|scb-&gt;dev_channel
comma
id|scb-&gt;dev_target
)paren
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid abort: %ld:%d[%d:%d], fw owner&bslash;n&quot;
comma
id|scp-&gt;serial_number
comma
id|scb-&gt;sno
comma
id|scb-&gt;dev_channel
comma
id|scb-&gt;dev_target
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid abort: scsi cmd:%ld, do now own&bslash;n&quot;
comma
id|scp-&gt;serial_number
)paren
)paren
suffix:semicolon
singleline_comment|// FIXME: Should there be a callback for this command?
r_return
id|SUCCESS
suffix:semicolon
)brace
singleline_comment|// We cannot actually abort a command owned by firmware, return
singleline_comment|// failure and wait for reset. In host reset handler, we will find out
singleline_comment|// if the HBA is still live
r_return
id|FAILED
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_reset_handler - device reset hadler for mailbox based driver&n; * @scp&t;&t;: reference command&n; *&n; * Reset handler for the mailbox based controller. First try to find out if&n; * the FW is still live, in which case the outstanding commands counter mut go&n; * down to 0. If that happens, also issue the reservation reset command to&n; * relinquish (possible) reservations on the logical drives connected to this&n; * host&n; **/
r_static
r_int
DECL|function|megaraid_reset_handler
id|megaraid_reset_handler
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|scp
)paren
(brace
id|adapter_t
op_star
id|adapter
suffix:semicolon
id|scb_t
op_star
id|scb
suffix:semicolon
id|scb_t
op_star
id|tmp
suffix:semicolon
id|mraid_device_t
op_star
id|raid_dev
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_uint8
id|raw_mbox
(braket
r_sizeof
(paren
id|mbox_t
)paren
)braket
suffix:semicolon
r_int
id|rval
suffix:semicolon
r_int
id|recovery_window
suffix:semicolon
r_int
id|recovering
suffix:semicolon
r_int
id|i
suffix:semicolon
id|adapter
op_assign
id|SCP2ADAPTER
c_func
(paren
id|scp
)paren
suffix:semicolon
id|raid_dev
op_assign
id|ADAP2RAIDDEV
c_func
(paren
id|adapter
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|spin_is_locked
c_func
(paren
id|adapter-&gt;host_lock
)paren
)paren
suffix:semicolon
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid: reseting the host...&bslash;n&quot;
)paren
)paren
suffix:semicolon
singleline_comment|// return failure if adapter is not responding
r_if
c_cond
(paren
id|raid_dev-&gt;hw_error
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_NOTICE
l_string|&quot;megaraid: hw error, cannot reset&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|FAILED
suffix:semicolon
)brace
singleline_comment|// Under exceptional conditions, FW can take up to 3 minutes to
singleline_comment|// complete command processing. Wait for additional 2 minutes for the
singleline_comment|// pending commands counter to go down to 0. If it doesn&squot;t, let the
singleline_comment|// controller be marked offline
singleline_comment|// Also, reset all the commands currently owned by the driver
id|spin_lock_irqsave
c_func
(paren
id|PENDING_LIST_LOCK
c_func
(paren
id|adapter
)paren
comma
id|flags
)paren
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|scb
comma
id|tmp
comma
op_amp
id|adapter-&gt;pend_list
comma
id|list
)paren
(brace
id|list_del_init
c_func
(paren
op_amp
id|scb-&gt;list
)paren
suffix:semicolon
singleline_comment|// from pending list
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid: %ld:%d[%d:%d], reset from pending list&bslash;n&quot;
comma
id|scp-&gt;serial_number
comma
id|scb-&gt;sno
comma
id|scb-&gt;dev_channel
comma
id|scb-&gt;dev_target
)paren
)paren
suffix:semicolon
id|scp-&gt;result
op_assign
(paren
id|DID_RESET
op_lshift
l_int|16
)paren
suffix:semicolon
id|scp
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|scp
)paren
suffix:semicolon
id|megaraid_dealloc_scb
c_func
(paren
id|adapter
comma
id|scb
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
id|PENDING_LIST_LOCK
c_func
(paren
id|adapter
)paren
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|adapter-&gt;outstanding_cmds
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_NOTICE
l_string|&quot;megaraid: %d outstanding commands. Max wait %d sec&bslash;n&quot;
comma
id|adapter-&gt;outstanding_cmds
comma
id|MBOX_RESET_WAIT
)paren
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
id|adapter-&gt;host_lock
)paren
suffix:semicolon
id|recovery_window
op_assign
id|MBOX_RESET_WAIT
op_plus
id|MBOX_RESET_EXT_WAIT
suffix:semicolon
id|recovering
op_assign
id|adapter-&gt;outstanding_cmds
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|recovery_window
op_logical_and
id|adapter-&gt;outstanding_cmds
suffix:semicolon
id|i
op_increment
)paren
(brace
id|megaraid_ack_sequence
c_func
(paren
id|adapter
)paren
suffix:semicolon
singleline_comment|// print a message once every 5 seconds only
r_if
c_cond
(paren
op_logical_neg
(paren
id|i
op_mod
l_int|5
)paren
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
l_string|&quot;megaraid mbox: Wait for %d commands to complete:%d&bslash;n&quot;
comma
id|adapter-&gt;outstanding_cmds
comma
id|MBOX_RESET_WAIT
op_minus
id|i
)paren
)paren
suffix:semicolon
)brace
singleline_comment|// bailout if no recovery happended in reset time
r_if
c_cond
(paren
(paren
id|i
op_eq
id|MBOX_RESET_WAIT
)paren
op_logical_and
(paren
id|recovering
op_eq
id|adapter-&gt;outstanding_cmds
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|msleep
c_func
(paren
l_int|1000
)paren
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
id|adapter-&gt;host_lock
)paren
suffix:semicolon
singleline_comment|// If still outstanding commands, bail out
r_if
c_cond
(paren
id|adapter-&gt;outstanding_cmds
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid mbox: critical hardware error!&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|raid_dev-&gt;hw_error
op_assign
l_int|1
suffix:semicolon
r_return
id|FAILED
suffix:semicolon
)brace
r_else
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_NOTICE
l_string|&quot;megaraid mbox: reset sequence completed sucessfully&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
singleline_comment|// If the controller supports clustering, reset reservations
r_if
c_cond
(paren
op_logical_neg
id|adapter-&gt;ha
)paren
r_return
id|SUCCESS
suffix:semicolon
singleline_comment|// clear reservations if any
id|raw_mbox
(braket
l_int|0
)braket
op_assign
id|CLUSTER_CMD
suffix:semicolon
id|raw_mbox
(braket
l_int|2
)braket
op_assign
id|RESET_RESERVATIONS
suffix:semicolon
id|rval
op_assign
id|SUCCESS
suffix:semicolon
r_if
c_cond
(paren
id|mbox_post_sync_cmd_fast
c_func
(paren
id|adapter
comma
id|raw_mbox
)paren
op_eq
l_int|0
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_INFO
l_string|&quot;megaraid: reservation reset&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|rval
op_assign
id|FAILED
suffix:semicolon
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid: reservation reset failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/*&n; * START: internal commands library&n; *&n; * This section of the driver has the common routine used by the driver and&n; * also has all the FW routines&n; */
multiline_comment|/**&n; * mbox_post_sync_cmd() - blocking command to the mailbox based controllers&n; * @adapter&t;- controller&squot;s soft state&n; * @raw_mbox&t;- the mailbox&n; *&n; * Issue a scb in synchronous and non-interrupt mode for mailbox based&n; * controllers&n; */
r_static
r_int
DECL|function|mbox_post_sync_cmd
id|mbox_post_sync_cmd
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
r_uint8
id|raw_mbox
(braket
)braket
)paren
(brace
id|mraid_device_t
op_star
id|raid_dev
op_assign
id|ADAP2RAIDDEV
c_func
(paren
id|adapter
)paren
suffix:semicolon
id|mbox64_t
op_star
id|mbox64
suffix:semicolon
id|mbox_t
op_star
id|mbox
suffix:semicolon
r_uint8
id|status
suffix:semicolon
r_int
id|i
suffix:semicolon
id|mbox64
op_assign
id|raid_dev-&gt;mbox64
suffix:semicolon
id|mbox
op_assign
id|raid_dev-&gt;mbox
suffix:semicolon
multiline_comment|/*&n;&t; * Wait until mailbox is free&n;&t; */
r_if
c_cond
(paren
id|megaraid_busywait_mbox
c_func
(paren
id|raid_dev
)paren
op_ne
l_int|0
)paren
r_goto
id|blocked_mailbox
suffix:semicolon
multiline_comment|/*&n;&t; * Copy mailbox data into host structure&n;&t; */
id|memcpy
c_func
(paren
(paren
id|caddr_t
)paren
id|mbox
comma
(paren
id|caddr_t
)paren
id|raw_mbox
comma
l_int|16
)paren
suffix:semicolon
id|mbox-&gt;cmdid
op_assign
l_int|0xFE
suffix:semicolon
id|mbox-&gt;busy
op_assign
l_int|1
suffix:semicolon
id|mbox-&gt;poll
op_assign
l_int|0
suffix:semicolon
id|mbox-&gt;ack
op_assign
l_int|0
suffix:semicolon
id|mbox-&gt;numstatus
op_assign
l_int|0xFF
suffix:semicolon
id|mbox-&gt;status
op_assign
l_int|0xFF
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|WRINDOOR
c_func
(paren
id|raid_dev
comma
id|raid_dev-&gt;mbox_dma
op_or
l_int|0x1
)paren
suffix:semicolon
singleline_comment|// wait for maximum 1 second for status to post. If the status is not
singleline_comment|// available within 1 second, assume FW is initializing and wait
singleline_comment|// for an extended amount of time
r_if
c_cond
(paren
id|mbox-&gt;numstatus
op_eq
l_int|0xFF
)paren
(brace
singleline_comment|// status not yet available
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mbox-&gt;numstatus
op_eq
l_int|0xFF
op_logical_and
id|i
OL
l_int|1000
suffix:semicolon
id|i
op_increment
)paren
(brace
id|rmb
c_func
(paren
)paren
suffix:semicolon
id|msleep
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|1000
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_NOTICE
l_string|&quot;megaraid mailbox: wait for FW to boot      &quot;
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|mbox-&gt;numstatus
op_eq
l_int|0xFF
)paren
op_logical_and
(paren
id|i
OL
id|MBOX_RESET_WAIT
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|rmb
c_func
(paren
)paren
suffix:semicolon
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
l_string|&quot;&bslash;b&bslash;b&bslash;b&bslash;b&bslash;b[%03d]&quot;
comma
id|MBOX_RESET_WAIT
op_minus
id|i
)paren
)paren
suffix:semicolon
id|msleep
c_func
(paren
l_int|1000
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|MBOX_RESET_WAIT
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
l_string|&quot;&bslash;nmegaraid mailbox: status not available&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
l_string|&quot;&bslash;b&bslash;b&bslash;b&bslash;b&bslash;b[ok] &bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
singleline_comment|// wait for maximum 1 second for poll semaphore
r_if
c_cond
(paren
id|mbox-&gt;poll
op_ne
l_int|0x77
)paren
(brace
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|mbox-&gt;poll
op_ne
l_int|0x77
)paren
op_logical_and
(paren
id|i
OL
l_int|1000
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|rmb
c_func
(paren
)paren
suffix:semicolon
id|msleep
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|1000
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid mailbox: could not get poll semaphore&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
id|WRINDOOR
c_func
(paren
id|raid_dev
comma
id|raid_dev-&gt;mbox_dma
op_or
l_int|0x2
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
singleline_comment|// wait for maximum 1 second for acknowledgement
r_if
c_cond
(paren
id|RDINDOOR
c_func
(paren
id|raid_dev
)paren
op_amp
l_int|0x2
)paren
(brace
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|RDINDOOR
c_func
(paren
id|raid_dev
)paren
op_amp
l_int|0x2
)paren
op_logical_and
(paren
id|i
OL
l_int|1000
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|rmb
c_func
(paren
)paren
suffix:semicolon
id|msleep
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|1000
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid mailbox: could not acknowledge&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
id|mbox-&gt;poll
op_assign
l_int|0
suffix:semicolon
id|mbox-&gt;ack
op_assign
l_int|0x77
suffix:semicolon
id|status
op_assign
id|mbox-&gt;status
suffix:semicolon
singleline_comment|// invalidate the completed command id array. After command
singleline_comment|// completion, firmware would write the valid id.
id|mbox-&gt;numstatus
op_assign
l_int|0xFF
suffix:semicolon
id|mbox-&gt;status
op_assign
l_int|0xFF
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MBOX_MAX_FIRMWARE_STATUS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mbox-&gt;completed
(braket
id|i
)braket
op_assign
l_int|0xFF
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
id|blocked_mailbox
suffix:colon
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid: blocked mailbox&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * mbox_post_sync_cmd_fast - blocking command to the mailbox based controllers&n; * @adapter&t;- controller&squot;s soft state&n; * @raw_mbox&t;- the mailbox&n; *&n; * Issue a scb in synchronous and non-interrupt mode for mailbox based&n; * controllers. This is a faster version of the synchronous command and&n; * therefore can be called in interrupt-context as well&n; */
r_static
r_int
DECL|function|mbox_post_sync_cmd_fast
id|mbox_post_sync_cmd_fast
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
r_uint8
id|raw_mbox
(braket
)braket
)paren
(brace
id|mraid_device_t
op_star
id|raid_dev
op_assign
id|ADAP2RAIDDEV
c_func
(paren
id|adapter
)paren
suffix:semicolon
id|mbox_t
op_star
id|mbox
suffix:semicolon
r_int
id|i
suffix:semicolon
id|mbox
op_assign
id|raid_dev-&gt;mbox
suffix:semicolon
singleline_comment|// return immediately if the mailbox is busy
r_if
c_cond
(paren
id|mbox-&gt;busy
)paren
r_return
op_minus
l_int|1
suffix:semicolon
singleline_comment|// Copy mailbox data into host structure
id|memcpy
c_func
(paren
(paren
id|caddr_t
)paren
id|mbox
comma
(paren
id|caddr_t
)paren
id|raw_mbox
comma
l_int|14
)paren
suffix:semicolon
id|mbox-&gt;cmdid
op_assign
l_int|0xFE
suffix:semicolon
id|mbox-&gt;busy
op_assign
l_int|1
suffix:semicolon
id|mbox-&gt;poll
op_assign
l_int|0
suffix:semicolon
id|mbox-&gt;ack
op_assign
l_int|0
suffix:semicolon
id|mbox-&gt;numstatus
op_assign
l_int|0xFF
suffix:semicolon
id|mbox-&gt;status
op_assign
l_int|0xFF
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|WRINDOOR
c_func
(paren
id|raid_dev
comma
id|raid_dev-&gt;mbox_dma
op_or
l_int|0x1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|0xFFFFF
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mbox-&gt;numstatus
op_ne
l_int|0xFF
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|0xFFFFF
)paren
(brace
singleline_comment|// We may need to re-calibrate the counter
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_CRIT
l_string|&quot;megaraid: fast sync command timed out&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
id|WRINDOOR
c_func
(paren
id|raid_dev
comma
id|raid_dev-&gt;mbox_dma
op_or
l_int|0x2
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
r_return
id|mbox-&gt;status
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_busywait_mbox() - Wait until the controller&squot;s mailbox is available&n; * @raid_dev&t;- RAID device (HBA) soft state&n; *&n; * wait until the controller&squot;s mailbox is available to accept more commands.&n; * wait for at most 1 second&n; */
r_static
r_int
DECL|function|megaraid_busywait_mbox
id|megaraid_busywait_mbox
c_func
(paren
id|mraid_device_t
op_star
id|raid_dev
)paren
(brace
id|mbox_t
op_star
id|mbox
op_assign
id|raid_dev-&gt;mbox
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mbox-&gt;busy
)paren
(brace
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mbox-&gt;busy
op_logical_and
id|i
OL
l_int|1000
suffix:semicolon
id|i
op_increment
)paren
id|msleep
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
l_int|1000
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_mbox_product_info - some static information about the controller&n; * @adapter&t;- our soft state&n; *&n; * issue commands to the controller to grab some parameters required by our&n; * caller.&n; */
r_static
r_int
DECL|function|megaraid_mbox_product_info
id|megaraid_mbox_product_info
c_func
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
id|mraid_device_t
op_star
id|raid_dev
op_assign
id|ADAP2RAIDDEV
c_func
(paren
id|adapter
)paren
suffix:semicolon
id|mbox_t
op_star
id|mbox
suffix:semicolon
r_uint8
id|raw_mbox
(braket
r_sizeof
(paren
id|mbox_t
)paren
)braket
suffix:semicolon
id|mraid_pinfo_t
op_star
id|pinfo
suffix:semicolon
id|dma_addr_t
id|pinfo_dma_h
suffix:semicolon
id|mraid_inquiry3_t
op_star
id|mraid_inq3
suffix:semicolon
r_int
id|i
suffix:semicolon
id|memset
c_func
(paren
(paren
id|caddr_t
)paren
id|raw_mbox
comma
l_int|0
comma
r_sizeof
(paren
id|raw_mbox
)paren
)paren
suffix:semicolon
id|mbox
op_assign
(paren
id|mbox_t
op_star
)paren
id|raw_mbox
suffix:semicolon
multiline_comment|/*&n;&t; * Issue an ENQUIRY3 command to find out certain adapter parameters,&n;&t; * e.g., max channels, max commands etc.&n;&t; */
id|pinfo
op_assign
id|pci_alloc_consistent
c_func
(paren
id|adapter-&gt;pdev
comma
r_sizeof
(paren
id|mraid_pinfo_t
)paren
comma
op_amp
id|pinfo_dma_h
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pinfo
op_eq
l_int|NULL
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid: out of memory, %s %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|__LINE__
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|memset
c_func
(paren
id|pinfo
comma
l_int|0
comma
r_sizeof
(paren
id|mraid_pinfo_t
)paren
)paren
suffix:semicolon
id|mbox-&gt;xferaddr
op_assign
(paren
r_uint32
)paren
id|adapter-&gt;ibuf_dma_h
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|adapter-&gt;ibuf
comma
l_int|0
comma
id|MBOX_IBUF_SIZE
)paren
suffix:semicolon
id|raw_mbox
(braket
l_int|0
)braket
op_assign
id|FC_NEW_CONFIG
suffix:semicolon
id|raw_mbox
(braket
l_int|2
)braket
op_assign
id|NC_SUBOP_ENQUIRY3
suffix:semicolon
id|raw_mbox
(braket
l_int|3
)braket
op_assign
id|ENQ3_GET_SOLICITED_FULL
suffix:semicolon
singleline_comment|// Issue the command
r_if
c_cond
(paren
id|mbox_post_sync_cmd
c_func
(paren
id|adapter
comma
id|raw_mbox
)paren
op_ne
l_int|0
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid: Inquiry3 failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|adapter-&gt;pdev
comma
r_sizeof
(paren
id|mraid_pinfo_t
)paren
comma
id|pinfo
comma
id|pinfo_dma_h
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Collect information about state of each physical drive&n;&t; * attached to the controller. We will expose all the disks&n;&t; * which are not part of RAID&n;&t; */
id|mraid_inq3
op_assign
(paren
id|mraid_inquiry3_t
op_star
)paren
id|adapter-&gt;ibuf
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MBOX_MAX_PHYSICAL_DRIVES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|raid_dev-&gt;pdrv_state
(braket
id|i
)braket
op_assign
id|mraid_inq3-&gt;pdrv_state
(braket
id|i
)braket
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get product info for information like number of channels,&n;&t; * maximum commands supported.&n;&t; */
id|memset
c_func
(paren
(paren
id|caddr_t
)paren
id|raw_mbox
comma
l_int|0
comma
r_sizeof
(paren
id|raw_mbox
)paren
)paren
suffix:semicolon
id|mbox-&gt;xferaddr
op_assign
(paren
r_uint32
)paren
id|pinfo_dma_h
suffix:semicolon
id|raw_mbox
(braket
l_int|0
)braket
op_assign
id|FC_NEW_CONFIG
suffix:semicolon
id|raw_mbox
(braket
l_int|2
)braket
op_assign
id|NC_SUBOP_PRODUCT_INFO
suffix:semicolon
r_if
c_cond
(paren
id|mbox_post_sync_cmd
c_func
(paren
id|adapter
comma
id|raw_mbox
)paren
op_ne
l_int|0
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid: product info failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|adapter-&gt;pdev
comma
r_sizeof
(paren
id|mraid_pinfo_t
)paren
comma
id|pinfo
comma
id|pinfo_dma_h
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Setup some parameters for host, as required by our caller&n;&t; */
id|adapter-&gt;max_channel
op_assign
id|pinfo-&gt;nchannels
suffix:semicolon
multiline_comment|/*&n;&t; * we will export all the logical drives on a single channel.&n;&t; * Add 1 since inquires do not come for inititor ID&n;&t; */
id|adapter-&gt;max_target
op_assign
id|MAX_LOGICAL_DRIVES_40LD
op_plus
l_int|1
suffix:semicolon
id|adapter-&gt;max_lun
op_assign
l_int|8
suffix:semicolon
singleline_comment|// up to 8 LUNs for non-disk devices
multiline_comment|/*&n;&t; * These are the maximum outstanding commands for the scsi-layer&n;&t; */
id|adapter-&gt;max_cmds
op_assign
id|MBOX_MAX_SCSI_CMDS
suffix:semicolon
id|memset
c_func
(paren
id|adapter-&gt;fw_version
comma
l_int|0
comma
id|VERSION_SIZE
)paren
suffix:semicolon
id|memset
c_func
(paren
id|adapter-&gt;bios_version
comma
l_int|0
comma
id|VERSION_SIZE
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|adapter-&gt;fw_version
comma
id|pinfo-&gt;fw_version
comma
l_int|4
)paren
suffix:semicolon
id|adapter-&gt;fw_version
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
id|memcpy
c_func
(paren
id|adapter-&gt;bios_version
comma
id|pinfo-&gt;bios_version
comma
l_int|4
)paren
suffix:semicolon
id|adapter-&gt;bios_version
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_NOTICE
l_string|&quot;megaraid: fw version:[%s] bios version:[%s]&bslash;n&quot;
comma
id|adapter-&gt;fw_version
comma
id|adapter-&gt;bios_version
)paren
)paren
suffix:semicolon
id|pci_free_consistent
c_func
(paren
id|adapter-&gt;pdev
comma
r_sizeof
(paren
id|mraid_pinfo_t
)paren
comma
id|pinfo
comma
id|pinfo_dma_h
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_mbox_extended_cdb - check for support for extended CDBs&n; * @adapter&t;- soft state for the controller&n; *&n; * this routine check whether the controller in question supports extended&n; * ( &gt; 10 bytes ) CDBs&n; */
r_static
r_int
DECL|function|megaraid_mbox_extended_cdb
id|megaraid_mbox_extended_cdb
c_func
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
id|mbox_t
op_star
id|mbox
suffix:semicolon
r_uint8
id|raw_mbox
(braket
r_sizeof
(paren
id|mbox_t
)paren
)braket
suffix:semicolon
r_int
id|rval
suffix:semicolon
id|mbox
op_assign
(paren
id|mbox_t
op_star
)paren
id|raw_mbox
suffix:semicolon
id|memset
c_func
(paren
(paren
id|caddr_t
)paren
id|raw_mbox
comma
l_int|0
comma
r_sizeof
(paren
id|raw_mbox
)paren
)paren
suffix:semicolon
id|mbox-&gt;xferaddr
op_assign
(paren
r_uint32
)paren
id|adapter-&gt;ibuf_dma_h
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|adapter-&gt;ibuf
comma
l_int|0
comma
id|MBOX_IBUF_SIZE
)paren
suffix:semicolon
id|raw_mbox
(braket
l_int|0
)braket
op_assign
id|MAIN_MISC_OPCODE
suffix:semicolon
id|raw_mbox
(braket
l_int|2
)braket
op_assign
id|SUPPORT_EXT_CDB
suffix:semicolon
multiline_comment|/*&n;&t; * Issue the command&n;&t; */
id|rval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mbox_post_sync_cmd
c_func
(paren
id|adapter
comma
id|raw_mbox
)paren
op_ne
l_int|0
)paren
(brace
id|rval
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_mbox_support_ha - Do we support clustering&n; * @adapter&t;- soft state for the controller&n; * @init_id&t;- ID of the initiator&n; *&n; * Determine if the firmware supports clustering and the ID of the initiator.&n; */
r_static
r_int
DECL|function|megaraid_mbox_support_ha
id|megaraid_mbox_support_ha
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
r_uint16
op_star
id|init_id
)paren
(brace
id|mbox_t
op_star
id|mbox
suffix:semicolon
r_uint8
id|raw_mbox
(braket
r_sizeof
(paren
id|mbox_t
)paren
)braket
suffix:semicolon
r_int
id|rval
suffix:semicolon
id|mbox
op_assign
(paren
id|mbox_t
op_star
)paren
id|raw_mbox
suffix:semicolon
id|memset
c_func
(paren
(paren
id|caddr_t
)paren
id|raw_mbox
comma
l_int|0
comma
r_sizeof
(paren
id|raw_mbox
)paren
)paren
suffix:semicolon
id|mbox-&gt;xferaddr
op_assign
(paren
r_uint32
)paren
id|adapter-&gt;ibuf_dma_h
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|adapter-&gt;ibuf
comma
l_int|0
comma
id|MBOX_IBUF_SIZE
)paren
suffix:semicolon
id|raw_mbox
(braket
l_int|0
)braket
op_assign
id|GET_TARGET_ID
suffix:semicolon
singleline_comment|// Issue the command
op_star
id|init_id
op_assign
l_int|7
suffix:semicolon
id|rval
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|mbox_post_sync_cmd
c_func
(paren
id|adapter
comma
id|raw_mbox
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|init_id
op_assign
op_star
(paren
r_uint8
op_star
)paren
id|adapter-&gt;ibuf
suffix:semicolon
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_INFO
l_string|&quot;megaraid: cluster firmware, initiator ID: %d&bslash;n&quot;
comma
op_star
id|init_id
)paren
)paren
suffix:semicolon
id|rval
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_mbox_support_random_del - Do we support random deletion&n; * @adapter&t;- soft state for the controller&n; *&n; * Determine if the firmware supports random deletion&n; * Return:&t;1 is operation supported, 0 otherwise&n; */
r_static
r_int
DECL|function|megaraid_mbox_support_random_del
id|megaraid_mbox_support_random_del
c_func
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
id|mbox_t
op_star
id|mbox
suffix:semicolon
r_uint8
id|raw_mbox
(braket
r_sizeof
(paren
id|mbox_t
)paren
)braket
suffix:semicolon
r_int
id|rval
suffix:semicolon
id|mbox
op_assign
(paren
id|mbox_t
op_star
)paren
id|raw_mbox
suffix:semicolon
id|memset
c_func
(paren
(paren
id|caddr_t
)paren
id|raw_mbox
comma
l_int|0
comma
r_sizeof
(paren
id|mbox_t
)paren
)paren
suffix:semicolon
id|raw_mbox
(braket
l_int|0
)braket
op_assign
id|FC_DEL_LOGDRV
suffix:semicolon
id|raw_mbox
(braket
l_int|0
)braket
op_assign
id|OP_SUP_DEL_LOGDRV
suffix:semicolon
singleline_comment|// Issue the command
id|rval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mbox_post_sync_cmd
c_func
(paren
id|adapter
comma
id|raw_mbox
)paren
op_eq
l_int|0
)paren
(brace
id|con_log
c_func
(paren
id|CL_DLEVEL1
comma
(paren
l_string|&quot;megaraid: supports random deletion&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|rval
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_mbox_get_max_sg - maximum sg elements supported by the firmware&n; * @adapter&t;- soft state for the controller&n; *&n; * Find out the maximum number of scatter-gather elements supported by the&n; * firmware&n; */
r_static
r_int
DECL|function|megaraid_mbox_get_max_sg
id|megaraid_mbox_get_max_sg
c_func
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
id|mbox_t
op_star
id|mbox
suffix:semicolon
r_uint8
id|raw_mbox
(braket
r_sizeof
(paren
id|mbox_t
)paren
)braket
suffix:semicolon
r_int
id|nsg
suffix:semicolon
id|mbox
op_assign
(paren
id|mbox_t
op_star
)paren
id|raw_mbox
suffix:semicolon
id|memset
c_func
(paren
(paren
id|caddr_t
)paren
id|raw_mbox
comma
l_int|0
comma
r_sizeof
(paren
id|mbox_t
)paren
)paren
suffix:semicolon
id|mbox-&gt;xferaddr
op_assign
(paren
r_uint32
)paren
id|adapter-&gt;ibuf_dma_h
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|adapter-&gt;ibuf
comma
l_int|0
comma
id|MBOX_IBUF_SIZE
)paren
suffix:semicolon
id|raw_mbox
(braket
l_int|0
)braket
op_assign
id|MAIN_MISC_OPCODE
suffix:semicolon
id|raw_mbox
(braket
l_int|2
)braket
op_assign
id|GET_MAX_SG_SUPPORT
suffix:semicolon
singleline_comment|// Issue the command
r_if
c_cond
(paren
id|mbox_post_sync_cmd
c_func
(paren
id|adapter
comma
id|raw_mbox
)paren
op_eq
l_int|0
)paren
(brace
id|nsg
op_assign
op_star
(paren
r_uint8
op_star
)paren
id|adapter-&gt;ibuf
suffix:semicolon
)brace
r_else
(brace
id|nsg
op_assign
id|MBOX_DEFAULT_SG_SIZE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nsg
OG
id|MBOX_MAX_SG_SIZE
)paren
id|nsg
op_assign
id|MBOX_MAX_SG_SIZE
suffix:semicolon
r_return
id|nsg
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_mbox_enum_raid_scsi - enumerate the RAID and SCSI channels&n; * @adapter&t;- soft state for the controller&n; *&n; * Enumerate the RAID and SCSI channels for ROMB platoforms so that channels&n; * can be exported as regular SCSI channels&n; */
r_static
r_void
DECL|function|megaraid_mbox_enum_raid_scsi
id|megaraid_mbox_enum_raid_scsi
c_func
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
id|mraid_device_t
op_star
id|raid_dev
op_assign
id|ADAP2RAIDDEV
c_func
(paren
id|adapter
)paren
suffix:semicolon
id|mbox_t
op_star
id|mbox
suffix:semicolon
r_uint8
id|raw_mbox
(braket
r_sizeof
(paren
id|mbox_t
)paren
)braket
suffix:semicolon
id|mbox
op_assign
(paren
id|mbox_t
op_star
)paren
id|raw_mbox
suffix:semicolon
id|memset
c_func
(paren
(paren
id|caddr_t
)paren
id|raw_mbox
comma
l_int|0
comma
r_sizeof
(paren
id|mbox_t
)paren
)paren
suffix:semicolon
id|mbox-&gt;xferaddr
op_assign
(paren
r_uint32
)paren
id|adapter-&gt;ibuf_dma_h
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|adapter-&gt;ibuf
comma
l_int|0
comma
id|MBOX_IBUF_SIZE
)paren
suffix:semicolon
id|raw_mbox
(braket
l_int|0
)braket
op_assign
id|CHNL_CLASS
suffix:semicolon
id|raw_mbox
(braket
l_int|2
)braket
op_assign
id|GET_CHNL_CLASS
suffix:semicolon
singleline_comment|// Issue the command. If the command fails, all channels are RAID
singleline_comment|// channels
id|raid_dev-&gt;channel_class
op_assign
l_int|0xFF
suffix:semicolon
r_if
c_cond
(paren
id|mbox_post_sync_cmd
c_func
(paren
id|adapter
comma
id|raw_mbox
)paren
op_eq
l_int|0
)paren
(brace
id|raid_dev-&gt;channel_class
op_assign
op_star
(paren
r_uint8
op_star
)paren
id|adapter-&gt;ibuf
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_mbox_flush_cache - flush adapter and disks cache&n; * @param adapter&t;: soft state for the controller&n; *&n; * Flush adapter cache followed by disks cache&n; */
r_static
r_void
DECL|function|megaraid_mbox_flush_cache
id|megaraid_mbox_flush_cache
c_func
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
id|mbox_t
op_star
id|mbox
suffix:semicolon
r_uint8
id|raw_mbox
(braket
r_sizeof
(paren
id|mbox_t
)paren
)braket
suffix:semicolon
id|mbox
op_assign
(paren
id|mbox_t
op_star
)paren
id|raw_mbox
suffix:semicolon
id|memset
c_func
(paren
(paren
id|caddr_t
)paren
id|raw_mbox
comma
l_int|0
comma
r_sizeof
(paren
id|mbox_t
)paren
)paren
suffix:semicolon
id|raw_mbox
(braket
l_int|0
)braket
op_assign
id|FLUSH_ADAPTER
suffix:semicolon
r_if
c_cond
(paren
id|mbox_post_sync_cmd
c_func
(paren
id|adapter
comma
id|raw_mbox
)paren
op_ne
l_int|0
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
l_string|&quot;megaraid: flush adapter failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
id|raw_mbox
(braket
l_int|0
)braket
op_assign
id|FLUSH_SYSTEM
suffix:semicolon
r_if
c_cond
(paren
id|mbox_post_sync_cmd
c_func
(paren
id|adapter
comma
id|raw_mbox
)paren
op_ne
l_int|0
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
l_string|&quot;megaraid: flush disks cache failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_mbox_display_scb - display SCB information, mostly debug purposes&n; * @param adapter&t;: controllers&squot; soft state&n; * @param scb&t;&t;: SCB to be displayed&n; * @param level&t;: debug level for console print&n; *&n; * Diplay information about the given SCB iff the current debug level is&n; * verbose&n; */
r_static
r_void
DECL|function|megaraid_mbox_display_scb
id|megaraid_mbox_display_scb
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
id|scb_t
op_star
id|scb
)paren
(brace
id|mbox_ccb_t
op_star
id|ccb
suffix:semicolon
r_struct
id|scsi_cmnd
op_star
id|scp
suffix:semicolon
id|mbox_t
op_star
id|mbox
suffix:semicolon
r_int
id|level
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ccb
op_assign
(paren
id|mbox_ccb_t
op_star
)paren
id|scb-&gt;ccb
suffix:semicolon
id|scp
op_assign
id|scb-&gt;scp
suffix:semicolon
id|mbox
op_assign
id|ccb-&gt;mbox
suffix:semicolon
id|level
op_assign
id|CL_DLEVEL3
suffix:semicolon
id|con_log
c_func
(paren
id|level
comma
(paren
id|KERN_NOTICE
l_string|&quot;megaraid mailbox: status:%#x cmd:%#x id:%#x &quot;
comma
id|scb-&gt;status
comma
id|mbox-&gt;cmd
comma
id|scb-&gt;sno
)paren
)paren
suffix:semicolon
id|con_log
c_func
(paren
id|level
comma
(paren
l_string|&quot;sec:%#x lba:%#x addr:%#x ld:%d sg:%d&bslash;n&quot;
comma
id|mbox-&gt;numsectors
comma
id|mbox-&gt;lba
comma
id|mbox-&gt;xferaddr
comma
id|mbox-&gt;logdrv
comma
id|mbox-&gt;numsge
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scp
)paren
r_return
suffix:semicolon
id|con_log
c_func
(paren
id|level
comma
(paren
id|KERN_NOTICE
l_string|&quot;scsi cmnd: &quot;
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|scp-&gt;cmd_len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|con_log
c_func
(paren
id|level
comma
(paren
l_string|&quot;%#2.02x &quot;
comma
id|scp-&gt;cmnd
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
)brace
id|con_log
c_func
(paren
id|level
comma
(paren
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_mbox_setup_device_map - manage device ids&n; * @adapter&t;: Driver&squot;s soft state&n; *&n; * Manange the device ids to have an appropraite mapping between the kernel&n; * scsi addresses and megaraid scsi and logical drive addresses. We export&n; * scsi devices on their actual addresses, whereas the logical drives are&n; * exported on a virtual scsi channel.&n; **/
r_static
r_void
DECL|function|megaraid_mbox_setup_device_map
id|megaraid_mbox_setup_device_map
c_func
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
r_uint8
id|c
suffix:semicolon
r_uint8
id|t
suffix:semicolon
multiline_comment|/*&n;&t; * First fill the values on the logical drive channel&n;&t; */
r_for
c_loop
(paren
id|t
op_assign
l_int|0
suffix:semicolon
id|t
OL
id|LSI_MAX_LOGICAL_DRIVES_64LD
suffix:semicolon
id|t
op_increment
)paren
id|adapter-&gt;device_ids
(braket
id|adapter-&gt;max_channel
)braket
(braket
id|t
)braket
op_assign
(paren
id|t
OL
id|adapter-&gt;init_id
)paren
ques
c_cond
id|t
suffix:colon
id|t
op_minus
l_int|1
suffix:semicolon
id|adapter-&gt;device_ids
(braket
id|adapter-&gt;max_channel
)braket
(braket
id|adapter-&gt;init_id
)braket
op_assign
l_int|0xFF
suffix:semicolon
multiline_comment|/*&n;&t; * Fill the values on the physical devices channels&n;&t; */
r_for
c_loop
(paren
id|c
op_assign
l_int|0
suffix:semicolon
id|c
OL
id|adapter-&gt;max_channel
suffix:semicolon
id|c
op_increment
)paren
r_for
c_loop
(paren
id|t
op_assign
l_int|0
suffix:semicolon
id|t
OL
id|LSI_MAX_LOGICAL_DRIVES_64LD
suffix:semicolon
id|t
op_increment
)paren
id|adapter-&gt;device_ids
(braket
id|c
)braket
(braket
id|t
)braket
op_assign
(paren
id|c
op_lshift
l_int|8
)paren
op_or
id|t
suffix:semicolon
)brace
multiline_comment|/*&n; * END: internal commands library&n; */
multiline_comment|/*&n; * START: Interface for the common management module&n; *&n; * This is the module, which interfaces with the common mangement module to&n; * provide support for ioctl and sysfs&n; */
multiline_comment|/**&n; * megaraid_cmm_register - register with the mangement module&n; * @param adapter&t;: HBA soft state&n; *&n; * Register with the management module, which allows applications to issue&n; * ioctl calls to the drivers. This interface is used by the management module&n; * to setup sysfs support as well.&n; */
r_static
r_int
DECL|function|megaraid_cmm_register
id|megaraid_cmm_register
c_func
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
id|mraid_device_t
op_star
id|raid_dev
op_assign
id|ADAP2RAIDDEV
c_func
(paren
id|adapter
)paren
suffix:semicolon
id|mraid_mmadp_t
id|adp
suffix:semicolon
id|scb_t
op_star
id|scb
suffix:semicolon
id|mbox_ccb_t
op_star
id|ccb
suffix:semicolon
r_int
id|rval
suffix:semicolon
r_int
id|i
suffix:semicolon
singleline_comment|// Allocate memory for the base list of scb for management module.
id|adapter-&gt;uscb_list
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|scb_t
)paren
op_star
id|MBOX_MAX_USER_CMDS
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|adapter-&gt;uscb_list
op_eq
l_int|NULL
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid: out of memory, %s %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|__LINE__
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|memset
c_func
(paren
id|adapter-&gt;uscb_list
comma
l_int|0
comma
r_sizeof
(paren
id|scb_t
)paren
op_star
id|MBOX_MAX_USER_CMDS
)paren
suffix:semicolon
singleline_comment|// Initialize the synchronization parameters for resources for
singleline_comment|// commands for management module
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|adapter-&gt;uscb_pool
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
id|USER_FREE_LIST_LOCK
c_func
(paren
id|adapter
)paren
)paren
suffix:semicolon
singleline_comment|// link all the packets. Note, CCB for commands, coming from the
singleline_comment|// commom management module, mailbox physical address are already
singleline_comment|// setup by it. We just need placeholder for that in our local command
singleline_comment|// control blocks
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MBOX_MAX_USER_CMDS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|scb
op_assign
id|adapter-&gt;uscb_list
op_plus
id|i
suffix:semicolon
id|ccb
op_assign
id|raid_dev-&gt;uccb_list
op_plus
id|i
suffix:semicolon
id|scb-&gt;ccb
op_assign
(paren
id|caddr_t
)paren
id|ccb
suffix:semicolon
id|ccb-&gt;mbox64
op_assign
id|raid_dev-&gt;umbox64
op_plus
id|i
suffix:semicolon
id|ccb-&gt;mbox
op_assign
op_amp
id|ccb-&gt;mbox64-&gt;mbox32
suffix:semicolon
id|ccb-&gt;raw_mbox
op_assign
(paren
r_uint8
op_star
)paren
id|ccb-&gt;mbox
suffix:semicolon
id|scb-&gt;gp
op_assign
l_int|0
suffix:semicolon
singleline_comment|// COMMAND ID 0 - (MBOX_MAX_SCSI_CMDS-1) ARE RESERVED FOR
singleline_comment|// COMMANDS COMING FROM IO SUBSYSTEM (MID-LAYER)
id|scb-&gt;sno
op_assign
id|i
op_plus
id|MBOX_MAX_SCSI_CMDS
suffix:semicolon
id|scb-&gt;scp
op_assign
l_int|NULL
suffix:semicolon
id|scb-&gt;state
op_assign
id|SCB_FREE
suffix:semicolon
id|scb-&gt;dma_direction
op_assign
id|PCI_DMA_NONE
suffix:semicolon
id|scb-&gt;dma_type
op_assign
id|MRAID_DMA_NONE
suffix:semicolon
id|scb-&gt;dev_channel
op_assign
op_minus
l_int|1
suffix:semicolon
id|scb-&gt;dev_target
op_assign
op_minus
l_int|1
suffix:semicolon
singleline_comment|// put scb in the free pool
id|list_add_tail
c_func
(paren
op_amp
id|scb-&gt;list
comma
op_amp
id|adapter-&gt;uscb_pool
)paren
suffix:semicolon
)brace
id|adp.unique_id
op_assign
id|adapter-&gt;unique_id
suffix:semicolon
id|adp.drvr_type
op_assign
id|DRVRTYPE_MBOX
suffix:semicolon
id|adp.drvr_data
op_assign
(paren
r_int
r_int
)paren
id|adapter
suffix:semicolon
id|adp.pdev
op_assign
id|adapter-&gt;pdev
suffix:semicolon
id|adp.issue_uioc
op_assign
id|megaraid_mbox_mm_handler
suffix:semicolon
id|adp.timeout
op_assign
l_int|300
suffix:semicolon
id|adp.max_kioc
op_assign
id|MBOX_MAX_USER_CMDS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rval
op_assign
id|mraid_mm_register_adp
c_func
(paren
op_amp
id|adp
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid mbox: did not register with CMM&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|adapter-&gt;uscb_list
)paren
suffix:semicolon
)brace
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_cmm_unregister - un-register with the mangement module&n; * @param adapter&t;: HBA soft state&n; *&n; * Un-register with the management module.&n; * FIXME: mgmt module must return failure for unregister if it has pending&n; * commands in LLD&n; */
r_static
r_int
DECL|function|megaraid_cmm_unregister
id|megaraid_cmm_unregister
c_func
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
id|kfree
c_func
(paren
id|adapter-&gt;uscb_list
)paren
suffix:semicolon
id|mraid_mm_unregister_adp
c_func
(paren
id|adapter-&gt;unique_id
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_mbox_mm_handler - interface for CMM to issue commands to LLD&n; * @param drvr_data&t;: LLD specific data&n; * @param kioc&t;&t;: CMM interface packet&n; * @param action&t;: command action&n; *&n; * This routine is invoked whenever the Common Mangement Module (CMM) has a&n; * command for us. The &squot;action&squot; parameter specifies if this is a new command&n; * or otherwise.&n; */
r_static
r_int
DECL|function|megaraid_mbox_mm_handler
id|megaraid_mbox_mm_handler
c_func
(paren
r_int
r_int
id|drvr_data
comma
id|uioc_t
op_star
id|kioc
comma
r_uint32
id|action
)paren
(brace
id|adapter_t
op_star
id|adapter
suffix:semicolon
r_if
c_cond
(paren
id|action
op_ne
id|IOCTL_ISSUE
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid: unsupported management action:%#2x&bslash;n&quot;
comma
id|action
)paren
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENOTSUPP
)paren
suffix:semicolon
)brace
id|adapter
op_assign
(paren
id|adapter_t
op_star
)paren
id|drvr_data
suffix:semicolon
singleline_comment|// make sure this adapter is not being detached right now.
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|adapter-&gt;being_detached
)paren
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid: reject management request, detaching&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|kioc-&gt;opcode
)paren
(brace
r_case
id|GET_ADAP_INFO
suffix:colon
id|kioc-&gt;status
op_assign
id|gather_hbainfo
c_func
(paren
id|adapter
comma
(paren
id|mraid_hba_info_t
op_star
)paren
(paren
r_int
r_int
)paren
id|kioc-&gt;buf_vaddr
)paren
suffix:semicolon
id|kioc
op_member_access_from_pointer
id|done
c_func
(paren
id|kioc
)paren
suffix:semicolon
r_return
id|kioc-&gt;status
suffix:semicolon
r_case
id|MBOX_CMD
suffix:colon
r_return
id|megaraid_mbox_mm_command
c_func
(paren
id|adapter
comma
id|kioc
)paren
suffix:semicolon
r_default
suffix:colon
id|kioc-&gt;status
op_assign
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
id|kioc
op_member_access_from_pointer
id|done
c_func
(paren
id|kioc
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
singleline_comment|// not reached
)brace
multiline_comment|/**&n; * megaraid_mbox_mm_command - issues commands routed through CMM&n; * @param adapter&t;: HBA soft state&n; * @param kioc&t;&t;: management command packet&n; *&n; * Issues commands, which are routed through the management module.&n; */
r_static
r_int
DECL|function|megaraid_mbox_mm_command
id|megaraid_mbox_mm_command
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
id|uioc_t
op_star
id|kioc
)paren
(brace
r_struct
id|list_head
op_star
id|head
op_assign
op_amp
id|adapter-&gt;uscb_pool
suffix:semicolon
id|mbox64_t
op_star
id|mbox64
suffix:semicolon
r_uint8
op_star
id|raw_mbox
suffix:semicolon
id|scb_t
op_star
id|scb
suffix:semicolon
id|mbox_ccb_t
op_star
id|ccb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
singleline_comment|// detach one scb from free pool
id|spin_lock_irqsave
c_func
(paren
id|USER_FREE_LIST_LOCK
c_func
(paren
id|adapter
)paren
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
id|head
)paren
)paren
(brace
singleline_comment|// should never happen because of CMM
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_WARNING
l_string|&quot;megaraid mbox: bug in cmm handler, lost resources&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|USER_FREE_LIST_LOCK
c_func
(paren
id|adapter
)paren
comma
id|flags
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
id|scb
op_assign
id|list_entry
c_func
(paren
id|head-&gt;next
comma
id|scb_t
comma
id|list
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|scb-&gt;list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|USER_FREE_LIST_LOCK
c_func
(paren
id|adapter
)paren
comma
id|flags
)paren
suffix:semicolon
id|scb-&gt;state
op_assign
id|SCB_ACTIVE
suffix:semicolon
id|scb-&gt;dma_type
op_assign
id|MRAID_DMA_NONE
suffix:semicolon
id|ccb
op_assign
(paren
id|mbox_ccb_t
op_star
)paren
id|scb-&gt;ccb
suffix:semicolon
id|mbox64
op_assign
(paren
id|mbox64_t
op_star
)paren
(paren
r_int
r_int
)paren
id|kioc-&gt;cmdbuf
suffix:semicolon
id|raw_mbox
op_assign
(paren
r_uint8
op_star
)paren
op_amp
id|mbox64-&gt;mbox32
suffix:semicolon
id|memcpy
c_func
(paren
id|ccb-&gt;mbox64
comma
id|mbox64
comma
r_sizeof
(paren
id|mbox64_t
)paren
)paren
suffix:semicolon
id|scb-&gt;gp
op_assign
(paren
r_int
r_int
)paren
id|kioc
suffix:semicolon
multiline_comment|/*&n;&t; * If it is a logdrv random delete operation, we have to wait till&n;&t; * there are no outstanding cmds at the fw and then issue it directly&n;&t; */
r_if
c_cond
(paren
id|raw_mbox
(braket
l_int|0
)braket
op_eq
id|FC_DEL_LOGDRV
op_logical_and
id|raw_mbox
(braket
l_int|2
)braket
op_eq
id|OP_DEL_LOGDRV
)paren
(brace
r_if
c_cond
(paren
id|wait_till_fw_empty
c_func
(paren
id|adapter
)paren
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_NOTICE
l_string|&quot;megaraid mbox: LD delete, timed out&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|kioc-&gt;status
op_assign
op_minus
id|ETIME
suffix:semicolon
id|scb-&gt;status
op_assign
op_minus
l_int|1
suffix:semicolon
id|megaraid_mbox_mm_done
c_func
(paren
id|adapter
comma
id|scb
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ETIME
)paren
suffix:semicolon
)brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|scb-&gt;list
)paren
suffix:semicolon
id|scb-&gt;state
op_assign
id|SCB_ISSUED
suffix:semicolon
r_if
c_cond
(paren
id|mbox_post_cmd
c_func
(paren
id|adapter
comma
id|scb
)paren
op_ne
l_int|0
)paren
(brace
id|con_log
c_func
(paren
id|CL_ANN
comma
(paren
id|KERN_NOTICE
l_string|&quot;megaraid mbox: LD delete, mailbox busy&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|kioc-&gt;status
op_assign
op_minus
id|EBUSY
suffix:semicolon
id|scb-&gt;status
op_assign
op_minus
l_int|1
suffix:semicolon
id|megaraid_mbox_mm_done
c_func
(paren
id|adapter
comma
id|scb
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EBUSY
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|// put the command on the pending list and execute
id|megaraid_mbox_runpendq
c_func
(paren
id|adapter
comma
id|scb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|wait_till_fw_empty
id|wait_till_fw_empty
c_func
(paren
id|adapter_t
op_star
id|adapter
)paren
(brace
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * Set the quiescent flag to stop issuing cmds to FW.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
id|adapter-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|adapter-&gt;quiescent
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|adapter-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Wait till there are no more cmds outstanding at FW. Try for at most&n;&t; * 60 seconds&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|60
op_logical_and
id|adapter-&gt;outstanding_cmds
suffix:semicolon
id|i
op_increment
)paren
(brace
id|con_log
c_func
(paren
id|CL_DLEVEL1
comma
(paren
id|KERN_INFO
l_string|&quot;megaraid: FW has %d pending commands&bslash;n&quot;
comma
id|adapter-&gt;outstanding_cmds
)paren
)paren
suffix:semicolon
id|msleep
c_func
(paren
l_int|1000
)paren
suffix:semicolon
)brace
r_return
id|adapter-&gt;outstanding_cmds
suffix:semicolon
)brace
multiline_comment|/**&n; * megaraid_mbox_mm_done - callback for CMM commands&n; * @adapter&t;: HBA soft state&n; * @scb&t;&t;: completed command&n; *&n; * Callback routine for internal commands originated from the management&n; * module.&n; */
r_static
r_void
DECL|function|megaraid_mbox_mm_done
id|megaraid_mbox_mm_done
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
id|scb_t
op_star
id|scb
)paren
(brace
id|uioc_t
op_star
id|kioc
suffix:semicolon
id|mbox64_t
op_star
id|mbox64
suffix:semicolon
r_uint8
op_star
id|raw_mbox
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|kioc
op_assign
(paren
id|uioc_t
op_star
)paren
id|scb-&gt;gp
suffix:semicolon
id|kioc-&gt;status
op_assign
l_int|0
suffix:semicolon
id|mbox64
op_assign
(paren
id|mbox64_t
op_star
)paren
(paren
r_int
r_int
)paren
id|kioc-&gt;cmdbuf
suffix:semicolon
id|mbox64-&gt;mbox32.status
op_assign
id|scb-&gt;status
suffix:semicolon
id|raw_mbox
op_assign
(paren
r_uint8
op_star
)paren
op_amp
id|mbox64-&gt;mbox32
suffix:semicolon
singleline_comment|// put scb in the free pool
id|scb-&gt;state
op_assign
id|SCB_FREE
suffix:semicolon
id|scb-&gt;scp
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|USER_FREE_LIST_LOCK
c_func
(paren
id|adapter
)paren
comma
id|flags
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|scb-&gt;list
comma
op_amp
id|adapter-&gt;uscb_pool
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|USER_FREE_LIST_LOCK
c_func
(paren
id|adapter
)paren
comma
id|flags
)paren
suffix:semicolon
singleline_comment|// if a delete logical drive operation succeeded, restart the
singleline_comment|// controller
r_if
c_cond
(paren
id|raw_mbox
(braket
l_int|0
)braket
op_eq
id|FC_DEL_LOGDRV
op_logical_and
id|raw_mbox
(braket
l_int|2
)braket
op_eq
id|OP_DEL_LOGDRV
)paren
(brace
id|adapter-&gt;quiescent
op_decrement
suffix:semicolon
id|megaraid_mbox_runpendq
c_func
(paren
id|adapter
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|kioc
op_member_access_from_pointer
id|done
c_func
(paren
id|kioc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * gather_hbainfo - HBA characteristics for the applications&n; * @param adapter&t;: HBA soft state&n; * @param hinfo&t;&t;: pointer to the caller&squot;s host info strucuture&n; */
r_static
r_int
DECL|function|gather_hbainfo
id|gather_hbainfo
c_func
(paren
id|adapter_t
op_star
id|adapter
comma
id|mraid_hba_info_t
op_star
id|hinfo
)paren
(brace
r_uint8
id|dmajor
suffix:semicolon
id|dmajor
op_assign
id|megaraid_mbox_version
(braket
l_int|0
)braket
suffix:semicolon
id|hinfo-&gt;pci_vendor_id
op_assign
id|adapter-&gt;pdev-&gt;vendor
suffix:semicolon
id|hinfo-&gt;pci_device_id
op_assign
id|adapter-&gt;pdev-&gt;device
suffix:semicolon
id|hinfo-&gt;subsys_vendor_id
op_assign
id|adapter-&gt;pdev-&gt;subsystem_vendor
suffix:semicolon
id|hinfo-&gt;subsys_device_id
op_assign
id|adapter-&gt;pdev-&gt;subsystem_device
suffix:semicolon
id|hinfo-&gt;pci_bus
op_assign
id|adapter-&gt;pdev-&gt;bus-&gt;number
suffix:semicolon
id|hinfo-&gt;pci_dev_fn
op_assign
id|adapter-&gt;pdev-&gt;devfn
suffix:semicolon
id|hinfo-&gt;pci_slot
op_assign
id|PCI_SLOT
c_func
(paren
id|adapter-&gt;pdev-&gt;devfn
)paren
suffix:semicolon
id|hinfo-&gt;irq
op_assign
id|adapter-&gt;host-&gt;irq
suffix:semicolon
id|hinfo-&gt;baseport
op_assign
id|ADAP2RAIDDEV
c_func
(paren
id|adapter
)paren
op_member_access_from_pointer
id|baseport
suffix:semicolon
id|hinfo-&gt;unique_id
op_assign
(paren
id|hinfo-&gt;pci_bus
op_lshift
l_int|8
)paren
op_or
id|adapter-&gt;pdev-&gt;devfn
suffix:semicolon
id|hinfo-&gt;host_no
op_assign
id|adapter-&gt;host-&gt;host_no
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * END: Interface for the common management module&n; */
multiline_comment|/*&n; * END: Mailbox Low Level Driver&n; */
DECL|variable|megaraid_init
id|module_init
c_func
(paren
id|megaraid_init
)paren
suffix:semicolon
DECL|variable|megaraid_exit
id|module_exit
c_func
(paren
id|megaraid_exit
)paren
suffix:semicolon
multiline_comment|/* vim: set ts=8 sw=8 tw=78 ai si: */
eof
