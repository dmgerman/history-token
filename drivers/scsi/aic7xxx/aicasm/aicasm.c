multiline_comment|/*&n; * Aic7xxx SCSI host adapter firmware asssembler&n; *&n; * Copyright (c) 1997, 1998, 2000, 2001 Justin T. Gibbs.&n; * Copyright (c) 2001 Adaptec Inc.&n; * All rights reserved.&n; *&n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions&n; * are met:&n; * 1. Redistributions of source code must retain the above copyright&n; *    notice, this list of conditions, and the following disclaimer,&n; *    without modification.&n; * 2. Redistributions in binary form must reproduce at minimum a disclaimer&n; *    substantially similar to the &quot;NO WARRANTY&quot; disclaimer below&n; *    (&quot;Disclaimer&quot;) and any redistribution must be conditioned upon&n; *    including a substantially similar Disclaimer requirement for further&n; *    binary redistribution.&n; * 3. Neither the names of the above-listed copyright holders nor the names&n; *    of any contributors may be used to endorse or promote products derived&n; *    from this software without specific prior written permission.&n; *&n; * Alternatively, this software may be distributed under the terms of the&n; * GNU General Public License (&quot;GPL&quot;) version 2 as published by the Free&n; * Software Foundation.&n; *&n; * NO WARRANTY&n; * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS&n; * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT&n; * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR&n; * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT&n; * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL&n; * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS&n; * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)&n; * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,&n; * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING&n; * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE&n; * POSSIBILITY OF SUCH DAMAGES.&n; *&n; * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm.c#11 $&n; *&n; * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm.c,v 1.29 2000/10/05 04:25:42 gibbs Exp $&n; */
macro_line|#include &lt;sys/types.h&gt;
macro_line|#include &lt;sys/mman.h&gt;
macro_line|#include &lt;ctype.h&gt;
macro_line|#include &lt;inttypes.h&gt;
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &lt;sysexits.h&gt;
macro_line|#include &lt;unistd.h&gt;
macro_line|#if linux
macro_line|#include &lt;endian.h&gt;
macro_line|#else
macro_line|#include &lt;machine/endian.h&gt;
macro_line|#endif
macro_line|#include &quot;aicasm.h&quot;
macro_line|#include &quot;aicasm_symbol.h&quot;
macro_line|#include &quot;aicasm_insformat.h&quot;
DECL|struct|patch
r_typedef
r_struct
id|patch
(brace
id|STAILQ_ENTRY
c_func
(paren
id|patch
)paren
id|links
suffix:semicolon
DECL|member|patch_func
r_int
id|patch_func
suffix:semicolon
DECL|member|begin
id|u_int
id|begin
suffix:semicolon
DECL|member|skip_instr
id|u_int
id|skip_instr
suffix:semicolon
DECL|member|skip_patch
id|u_int
id|skip_patch
suffix:semicolon
DECL|typedef|patch_t
)brace
id|patch_t
suffix:semicolon
id|STAILQ_HEAD
c_func
(paren
id|patch_list
comma
id|patch
)paren
id|patches
suffix:semicolon
r_static
r_void
id|usage
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|back_patch
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|output_code
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|output_listing
c_func
(paren
r_char
op_star
id|ifilename
)paren
suffix:semicolon
r_static
r_void
id|dump_scope
c_func
(paren
id|scope_t
op_star
id|scope
)paren
suffix:semicolon
r_static
r_void
id|emit_patch
c_func
(paren
id|scope_t
op_star
id|scope
comma
r_int
id|patch
)paren
suffix:semicolon
r_static
r_int
id|check_patch
c_func
(paren
id|patch_t
op_star
op_star
id|start_patch
comma
r_int
id|start_instr
comma
r_int
op_star
id|skip_addr
comma
r_int
op_star
id|func_vals
)paren
suffix:semicolon
DECL|variable|search_path
r_struct
id|path_list
id|search_path
suffix:semicolon
DECL|variable|includes_search_curdir
r_int
id|includes_search_curdir
suffix:semicolon
DECL|variable|appname
r_char
op_star
id|appname
suffix:semicolon
DECL|variable|ofile
id|FILE
op_star
id|ofile
suffix:semicolon
DECL|variable|ofilename
r_char
op_star
id|ofilename
suffix:semicolon
DECL|variable|regfilename
r_char
op_star
id|regfilename
suffix:semicolon
DECL|variable|regfile
id|FILE
op_star
id|regfile
suffix:semicolon
DECL|variable|listfilename
r_char
op_star
id|listfilename
suffix:semicolon
DECL|variable|listfile
id|FILE
op_star
id|listfile
suffix:semicolon
r_static
id|STAILQ_HEAD
c_func
(paren
comma
id|instruction
)paren
id|seq_program
suffix:semicolon
DECL|variable|cs_tailq
r_struct
id|cs_tailq
id|cs_tailq
suffix:semicolon
DECL|variable|scope_stack
r_struct
id|scope_list
id|scope_stack
suffix:semicolon
DECL|variable|patch_functions
id|symlist_t
id|patch_functions
suffix:semicolon
macro_line|#if DEBUG
r_extern
r_int
id|yy_flex_debug
suffix:semicolon
r_extern
r_int
id|yydebug
suffix:semicolon
macro_line|#endif
r_extern
id|FILE
op_star
id|yyin
suffix:semicolon
r_extern
r_int
id|yyparse
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
id|main
c_func
(paren
r_int
id|argc
comma
r_char
op_star
id|argv
(braket
)braket
)paren
suffix:semicolon
r_int
DECL|function|main
id|main
c_func
(paren
r_int
id|argc
comma
r_char
op_star
id|argv
(braket
)braket
)paren
(brace
r_extern
r_char
op_star
id|optarg
suffix:semicolon
r_extern
r_int
id|optind
suffix:semicolon
r_int
id|ch
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_char
op_star
id|inputfilename
suffix:semicolon
id|scope_t
op_star
id|sentinal
suffix:semicolon
id|STAILQ_INIT
c_func
(paren
op_amp
id|patches
)paren
suffix:semicolon
id|SLIST_INIT
c_func
(paren
op_amp
id|search_path
)paren
suffix:semicolon
id|STAILQ_INIT
c_func
(paren
op_amp
id|seq_program
)paren
suffix:semicolon
id|TAILQ_INIT
c_func
(paren
op_amp
id|cs_tailq
)paren
suffix:semicolon
id|SLIST_INIT
c_func
(paren
op_amp
id|scope_stack
)paren
suffix:semicolon
multiline_comment|/* Set Sentinal scope node */
id|sentinal
op_assign
id|scope_alloc
c_func
(paren
)paren
suffix:semicolon
id|sentinal-&gt;type
op_assign
id|SCOPE_ROOT
suffix:semicolon
id|includes_search_curdir
op_assign
l_int|1
suffix:semicolon
id|appname
op_assign
op_star
id|argv
suffix:semicolon
id|regfile
op_assign
l_int|NULL
suffix:semicolon
id|listfile
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if DEBUG
id|yy_flex_debug
op_assign
l_int|0
suffix:semicolon
id|yydebug
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
(paren
id|ch
op_assign
id|getopt
c_func
(paren
id|argc
comma
id|argv
comma
l_string|&quot;d:l:n:o:r:I:O:&quot;
)paren
)paren
op_ne
op_minus
l_int|1
)paren
(brace
r_switch
c_cond
(paren
id|ch
)paren
(brace
r_case
l_char|&squot;d&squot;
suffix:colon
macro_line|#if DEBUG
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|optarg
comma
l_string|&quot;s&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|yy_flex_debug
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|optarg
comma
l_string|&quot;p&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|yydebug
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: -d Requires either an &quot;
l_string|&quot;&squot;s&squot; or &squot;p&squot; argument&bslash;n&quot;
comma
id|appname
)paren
suffix:semicolon
id|usage
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#else
id|stop
c_func
(paren
l_string|&quot;-d: Assembler not built with debugging &quot;
l_string|&quot;information&quot;
comma
id|EX_SOFTWARE
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
l_char|&squot;l&squot;
suffix:colon
multiline_comment|/* Create a program listing */
r_if
c_cond
(paren
(paren
id|listfile
op_assign
id|fopen
c_func
(paren
id|optarg
comma
l_string|&quot;w&quot;
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|perror
c_func
(paren
id|optarg
)paren
suffix:semicolon
id|stop
c_func
(paren
l_int|NULL
comma
id|EX_CANTCREAT
)paren
suffix:semicolon
)brace
id|listfilename
op_assign
id|optarg
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;n&squot;
suffix:colon
multiline_comment|/* Don&squot;t complain about the -nostdinc directrive */
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|optarg
comma
l_string|&quot;ostdinc&quot;
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: Unknown option -%c%s&bslash;n&quot;
comma
id|appname
comma
id|ch
comma
id|optarg
)paren
suffix:semicolon
id|usage
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* NOTREACHED */
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;o&squot;
suffix:colon
r_if
c_cond
(paren
(paren
id|ofile
op_assign
id|fopen
c_func
(paren
id|optarg
comma
l_string|&quot;w&quot;
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|perror
c_func
(paren
id|optarg
)paren
suffix:semicolon
id|stop
c_func
(paren
l_int|NULL
comma
id|EX_CANTCREAT
)paren
suffix:semicolon
)brace
id|ofilename
op_assign
id|optarg
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;r&squot;
suffix:colon
r_if
c_cond
(paren
(paren
id|regfile
op_assign
id|fopen
c_func
(paren
id|optarg
comma
l_string|&quot;w&quot;
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|perror
c_func
(paren
id|optarg
)paren
suffix:semicolon
id|stop
c_func
(paren
l_int|NULL
comma
id|EX_CANTCREAT
)paren
suffix:semicolon
)brace
id|regfilename
op_assign
id|optarg
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;I&squot;
suffix:colon
(brace
id|path_entry_t
id|include_dir
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|optarg
comma
l_string|&quot;-&quot;
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|includes_search_curdir
op_eq
l_int|0
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: Warning - &squot;-I-&squot; &quot;
l_string|&quot;specified multiple &quot;
l_string|&quot;times&bslash;n&quot;
comma
id|appname
)paren
suffix:semicolon
)brace
id|includes_search_curdir
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|include_dir
op_assign
id|SLIST_FIRST
c_func
(paren
op_amp
id|search_path
)paren
suffix:semicolon
id|include_dir
op_ne
l_int|NULL
suffix:semicolon
id|include_dir
op_assign
id|SLIST_NEXT
c_func
(paren
id|include_dir
comma
id|links
)paren
)paren
multiline_comment|/*&n;&t;&t;&t;&t;&t; * All entries before a &squot;-I-&squot; only&n;&t;&t;&t;&t;&t; * apply to includes specified with&n;&t;&t;&t;&t;&t; * quotes instead of &quot;&lt;&gt;&quot;.&n;&t;&t;&t;&t;&t; */
id|include_dir-&gt;quoted_includes_only
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|include_dir
op_assign
(paren
id|path_entry_t
)paren
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|include_dir
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|include_dir
op_eq
l_int|NULL
)paren
(brace
id|perror
c_func
(paren
id|optarg
)paren
suffix:semicolon
id|stop
c_func
(paren
l_int|NULL
comma
id|EX_OSERR
)paren
suffix:semicolon
)brace
id|include_dir-&gt;directory
op_assign
id|strdup
c_func
(paren
id|optarg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|include_dir-&gt;directory
op_eq
l_int|NULL
)paren
(brace
id|perror
c_func
(paren
id|optarg
)paren
suffix:semicolon
id|stop
c_func
(paren
l_int|NULL
comma
id|EX_OSERR
)paren
suffix:semicolon
)brace
id|include_dir-&gt;quoted_includes_only
op_assign
l_int|0
suffix:semicolon
id|SLIST_INSERT_HEAD
c_func
(paren
op_amp
id|search_path
comma
id|include_dir
comma
id|links
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_case
l_char|&squot;?&squot;
suffix:colon
r_default
suffix:colon
id|usage
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* NOTREACHED */
)brace
)brace
id|argc
op_sub_assign
id|optind
suffix:semicolon
id|argv
op_add_assign
id|optind
suffix:semicolon
r_if
c_cond
(paren
id|argc
op_ne
l_int|1
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: No input file specifiled&bslash;n&quot;
comma
id|appname
)paren
suffix:semicolon
id|usage
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* NOTREACHED */
)brace
id|symtable_open
c_func
(paren
)paren
suffix:semicolon
id|inputfilename
op_assign
op_star
id|argv
suffix:semicolon
id|include_file
c_func
(paren
op_star
id|argv
comma
id|SOURCE_FILE
)paren
suffix:semicolon
id|retval
op_assign
id|yyparse
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|SLIST_FIRST
c_func
(paren
op_amp
id|scope_stack
)paren
op_eq
l_int|NULL
op_logical_or
id|SLIST_FIRST
c_func
(paren
op_amp
id|scope_stack
)paren
op_member_access_from_pointer
id|type
op_ne
id|SCOPE_ROOT
)paren
(brace
id|stop
c_func
(paren
l_string|&quot;Unterminated conditional expression&quot;
comma
id|EX_DATAERR
)paren
suffix:semicolon
multiline_comment|/* NOTREACHED */
)brace
multiline_comment|/* Process outmost scope */
id|process_scope
c_func
(paren
id|SLIST_FIRST
c_func
(paren
op_amp
id|scope_stack
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Decend the tree of scopes and insert/emit&n;&t;&t; * patches as appropriate.  We perform a depth first&n;&t;&t; * tranversal, recursively handling each scope.&n;&t;&t; */
multiline_comment|/* start at the root scope */
id|dump_scope
c_func
(paren
id|SLIST_FIRST
c_func
(paren
op_amp
id|scope_stack
)paren
)paren
suffix:semicolon
multiline_comment|/* Patch up forward jump addresses */
id|back_patch
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ofile
op_ne
l_int|NULL
)paren
id|output_code
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regfile
op_ne
l_int|NULL
)paren
(brace
id|symtable_dump
c_func
(paren
id|regfile
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|listfile
op_ne
l_int|NULL
)paren
id|output_listing
c_func
(paren
id|inputfilename
)paren
suffix:semicolon
)brace
id|stop
c_func
(paren
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* NOTREACHED */
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|usage
id|usage
c_func
(paren
)paren
(brace
(paren
r_void
)paren
id|fprintf
c_func
(paren
id|stderr
comma
"&quot;"
id|usage
suffix:colon
op_mod
op_minus
l_int|16
id|s
(braket
op_minus
id|nostdinc
)braket
(braket
op_minus
id|I
op_minus
)braket
(braket
op_minus
id|I
id|directory
)braket
(braket
op_minus
id|o
id|output_file
)braket
(braket
op_minus
id|r
id|register_output_file
)braket
(braket
op_minus
id|l
id|program_list_file
)braket
id|input_file
"&bslash;"
id|n
"&quot;"
comma
id|appname
)paren
suffix:semicolon
m_exit
(paren
id|EX_USAGE
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|back_patch
id|back_patch
c_func
(paren
)paren
(brace
r_struct
id|instruction
op_star
id|cur_instr
suffix:semicolon
r_for
c_loop
(paren
id|cur_instr
op_assign
id|STAILQ_FIRST
c_func
(paren
op_amp
id|seq_program
)paren
suffix:semicolon
id|cur_instr
op_ne
l_int|NULL
suffix:semicolon
id|cur_instr
op_assign
id|STAILQ_NEXT
c_func
(paren
id|cur_instr
comma
id|links
)paren
)paren
(brace
r_if
c_cond
(paren
id|cur_instr-&gt;patch_label
op_ne
l_int|NULL
)paren
(brace
r_struct
id|ins_format3
op_star
id|f3_instr
suffix:semicolon
id|u_int
id|address
suffix:semicolon
r_if
c_cond
(paren
id|cur_instr-&gt;patch_label-&gt;type
op_ne
id|LABEL
)paren
(brace
r_char
id|buf
(braket
l_int|255
)braket
suffix:semicolon
id|snprintf
c_func
(paren
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
l_string|&quot;Undefined label %s&quot;
comma
id|cur_instr-&gt;patch_label-&gt;name
)paren
suffix:semicolon
id|stop
c_func
(paren
id|buf
comma
id|EX_DATAERR
)paren
suffix:semicolon
multiline_comment|/* NOTREACHED */
)brace
id|f3_instr
op_assign
op_amp
id|cur_instr-&gt;format.format3
suffix:semicolon
id|address
op_assign
id|f3_instr-&gt;address
suffix:semicolon
id|address
op_add_assign
id|cur_instr-&gt;patch_label-&gt;info.linfo-&gt;address
suffix:semicolon
id|f3_instr-&gt;address
op_assign
id|address
suffix:semicolon
)brace
)brace
)brace
r_static
r_void
DECL|function|output_code
id|output_code
c_func
(paren
)paren
(brace
r_struct
id|instruction
op_star
id|cur_instr
suffix:semicolon
id|patch_t
op_star
id|cur_patch
suffix:semicolon
id|critical_section_t
op_star
id|cs
suffix:semicolon
id|symbol_node_t
op_star
id|cur_node
suffix:semicolon
r_int
id|instrcount
suffix:semicolon
id|instrcount
op_assign
l_int|0
suffix:semicolon
id|fprintf
c_func
(paren
id|ofile
comma
"&quot;"
multiline_comment|/*&n; * DO NOT EDIT - This file is automatically generated&n; *&t;&t; from the following source files:&n; *&n;%s */
"&bslash;"
id|n
"&quot;"
comma
id|versions
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|ofile
comma
l_string|&quot;static uint8_t seqprog[] = {&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cur_instr
op_assign
id|STAILQ_FIRST
c_func
(paren
op_amp
id|seq_program
)paren
suffix:semicolon
id|cur_instr
op_ne
l_int|NULL
suffix:semicolon
id|cur_instr
op_assign
id|STAILQ_NEXT
c_func
(paren
id|cur_instr
comma
id|links
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|ofile
comma
l_string|&quot;%s&bslash;t0x%02x, 0x%02x, 0x%02x, 0x%02x&quot;
comma
id|cur_instr
op_eq
id|STAILQ_FIRST
c_func
(paren
op_amp
id|seq_program
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;,&bslash;n&quot;
comma
macro_line|#if BYTE_ORDER == LITTLE_ENDIAN
id|cur_instr-&gt;format.bytes
(braket
l_int|0
)braket
comma
id|cur_instr-&gt;format.bytes
(braket
l_int|1
)braket
comma
id|cur_instr-&gt;format.bytes
(braket
l_int|2
)braket
comma
id|cur_instr-&gt;format.bytes
(braket
l_int|3
)braket
)paren
suffix:semicolon
macro_line|#else
id|cur_instr-&gt;format.bytes
(braket
l_int|3
)braket
comma
id|cur_instr-&gt;format.bytes
(braket
l_int|2
)braket
comma
id|cur_instr-&gt;format.bytes
(braket
l_int|1
)braket
comma
id|cur_instr-&gt;format.bytes
(braket
l_int|0
)braket
)paren
suffix:semicolon
macro_line|#endif
id|instrcount
op_increment
suffix:semicolon
)brace
id|fprintf
c_func
(paren
id|ofile
comma
l_string|&quot;&bslash;n};&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Output patch information.  Patch functions first.&n;&t; */
r_for
c_loop
(paren
id|cur_node
op_assign
id|SLIST_FIRST
c_func
(paren
op_amp
id|patch_functions
)paren
suffix:semicolon
id|cur_node
op_ne
l_int|NULL
suffix:semicolon
id|cur_node
op_assign
id|SLIST_NEXT
c_func
(paren
id|cur_node
comma
id|links
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|ofile
comma
"&quot;"
r_static
r_int
id|ahc_patch
op_mod
id|d_func
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
suffix:semicolon
r_static
r_int
id|ahc_patch
op_mod
id|d_func
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_return
(paren
op_mod
id|s
)paren
suffix:semicolon
)brace
"&bslash;"
id|n
"&bslash;"
id|n
"&quot;"
comma
id|cur_node-&gt;symbol-&gt;info.condinfo-&gt;func_num
comma
id|cur_node-&gt;symbol-&gt;info.condinfo-&gt;func_num
comma
id|cur_node-&gt;symbol-&gt;name
)paren
suffix:semicolon
)brace
id|fprintf
(paren
id|ofile
comma
"&quot;"
r_typedef
r_int
id|patch_func_t
(paren
r_struct
id|ahc_softc
op_star
)paren
suffix:semicolon
r_struct
id|patch
(brace
id|patch_func_t
op_star
id|patch_func
suffix:semicolon
r_uint32
id|begin
suffix:colon
l_int|10
comma
id|skip_instr
suffix:colon
l_int|10
comma
id|skip_patch
suffix:colon
l_int|12
suffix:semicolon
)brace
id|patches
(braket
)braket
op_assign
(brace
"&bslash;"
id|n
"&quot;"
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cur_patch
op_assign
id|STAILQ_FIRST
c_func
(paren
op_amp
id|patches
)paren
suffix:semicolon
id|cur_patch
op_ne
l_int|NULL
suffix:semicolon
id|cur_patch
op_assign
id|STAILQ_NEXT
c_func
(paren
id|cur_patch
comma
id|links
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|ofile
comma
l_string|&quot;%s&bslash;t{ ahc_patch%d_func, %d, %d, %d }&quot;
comma
id|cur_patch
op_eq
id|STAILQ_FIRST
c_func
(paren
op_amp
id|patches
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;,&bslash;n&quot;
comma
id|cur_patch-&gt;patch_func
comma
id|cur_patch-&gt;begin
comma
id|cur_patch-&gt;skip_instr
comma
id|cur_patch-&gt;skip_patch
)paren
suffix:semicolon
)brace
id|fprintf
c_func
(paren
id|ofile
comma
l_string|&quot;&bslash;n};&bslash;n&quot;
)paren
suffix:semicolon
id|fprintf
(paren
id|ofile
comma
"&quot;"
r_struct
id|cs
(brace
id|u_int16_t
id|begin
suffix:semicolon
id|u_int16_t
id|end
suffix:semicolon
)brace
id|critical_sections
(braket
)braket
op_assign
(brace
"&bslash;"
id|n
"&quot;"
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cs
op_assign
id|TAILQ_FIRST
c_func
(paren
op_amp
id|cs_tailq
)paren
suffix:semicolon
id|cs
op_ne
l_int|NULL
suffix:semicolon
id|cs
op_assign
id|TAILQ_NEXT
c_func
(paren
id|cs
comma
id|links
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|ofile
comma
l_string|&quot;%s&bslash;t{ %d, %d }&quot;
comma
id|cs
op_eq
id|TAILQ_FIRST
c_func
(paren
op_amp
id|cs_tailq
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;,&bslash;n&quot;
comma
id|cs-&gt;begin_addr
comma
id|cs-&gt;end_addr
)paren
suffix:semicolon
)brace
id|fprintf
c_func
(paren
id|ofile
comma
l_string|&quot;&bslash;n};&bslash;n&quot;
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|ofile
comma
"&quot;"
r_const
r_int
id|num_critical_sections
op_assign
r_sizeof
(paren
id|critical_sections
)paren
op_div
r_sizeof
(paren
op_star
id|critical_sections
)paren
suffix:semicolon
"&bslash;"
id|n
"&quot;"
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: %d instructions used&bslash;n&quot;
comma
id|appname
comma
id|instrcount
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|dump_scope
id|dump_scope
c_func
(paren
id|scope_t
op_star
id|scope
)paren
(brace
id|scope_t
op_star
id|cur_scope
suffix:semicolon
multiline_comment|/*&n;&t; * Emit the first patch for this scope&n;&t; */
id|emit_patch
c_func
(paren
id|scope
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Dump each scope within this one.&n;&t; */
id|cur_scope
op_assign
id|TAILQ_FIRST
c_func
(paren
op_amp
id|scope-&gt;inner_scope
)paren
suffix:semicolon
r_while
c_loop
(paren
id|cur_scope
op_ne
l_int|NULL
)paren
(brace
id|dump_scope
c_func
(paren
id|cur_scope
)paren
suffix:semicolon
id|cur_scope
op_assign
id|TAILQ_NEXT
c_func
(paren
id|cur_scope
comma
id|scope_links
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Emit the second, closing, patch for this scope&n;&t; */
id|emit_patch
c_func
(paren
id|scope
comma
l_int|1
)paren
suffix:semicolon
)brace
r_void
DECL|function|emit_patch
id|emit_patch
c_func
(paren
id|scope_t
op_star
id|scope
comma
r_int
id|patch
)paren
(brace
id|patch_info_t
op_star
id|pinfo
suffix:semicolon
id|patch_t
op_star
id|new_patch
suffix:semicolon
id|pinfo
op_assign
op_amp
id|scope-&gt;patches
(braket
id|patch
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pinfo-&gt;skip_instr
op_eq
l_int|0
)paren
multiline_comment|/* No-Op patch */
r_return
suffix:semicolon
id|new_patch
op_assign
(paren
id|patch_t
op_star
)paren
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|new_patch
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_patch
op_eq
l_int|NULL
)paren
id|stop
c_func
(paren
l_string|&quot;Could not malloc patch structure&quot;
comma
id|EX_OSERR
)paren
suffix:semicolon
id|memset
c_func
(paren
id|new_patch
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|new_patch
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|patch
op_eq
l_int|0
)paren
(brace
id|new_patch-&gt;patch_func
op_assign
id|scope-&gt;func_num
suffix:semicolon
id|new_patch-&gt;begin
op_assign
id|scope-&gt;begin_addr
suffix:semicolon
)brace
r_else
(brace
id|new_patch-&gt;patch_func
op_assign
l_int|0
suffix:semicolon
id|new_patch-&gt;begin
op_assign
id|scope-&gt;end_addr
suffix:semicolon
)brace
id|new_patch-&gt;skip_instr
op_assign
id|pinfo-&gt;skip_instr
suffix:semicolon
id|new_patch-&gt;skip_patch
op_assign
id|pinfo-&gt;skip_patch
suffix:semicolon
id|STAILQ_INSERT_TAIL
c_func
(paren
op_amp
id|patches
comma
id|new_patch
comma
id|links
)paren
suffix:semicolon
)brace
r_void
DECL|function|output_listing
id|output_listing
c_func
(paren
r_char
op_star
id|ifilename
)paren
(brace
r_char
id|buf
(braket
l_int|1024
)braket
suffix:semicolon
id|FILE
op_star
id|ifile
suffix:semicolon
r_struct
id|instruction
op_star
id|cur_instr
suffix:semicolon
id|patch_t
op_star
id|cur_patch
suffix:semicolon
id|symbol_node_t
op_star
id|cur_func
suffix:semicolon
r_int
op_star
id|func_values
suffix:semicolon
r_int
id|instrcount
suffix:semicolon
r_int
id|instrptr
suffix:semicolon
r_int
id|line
suffix:semicolon
r_int
id|func_count
suffix:semicolon
r_int
id|skip_addr
suffix:semicolon
id|instrcount
op_assign
l_int|0
suffix:semicolon
id|instrptr
op_assign
l_int|0
suffix:semicolon
id|line
op_assign
l_int|1
suffix:semicolon
id|skip_addr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ifile
op_assign
id|fopen
c_func
(paren
id|ifilename
comma
l_string|&quot;r&quot;
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|perror
c_func
(paren
id|ifilename
)paren
suffix:semicolon
id|stop
c_func
(paren
l_int|NULL
comma
id|EX_DATAERR
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Determine which options to apply to this listing.&n;&t; */
r_for
c_loop
(paren
id|func_count
op_assign
l_int|0
comma
id|cur_func
op_assign
id|SLIST_FIRST
c_func
(paren
op_amp
id|patch_functions
)paren
suffix:semicolon
id|cur_func
op_ne
l_int|NULL
suffix:semicolon
id|cur_func
op_assign
id|SLIST_NEXT
c_func
(paren
id|cur_func
comma
id|links
)paren
)paren
id|func_count
op_increment
suffix:semicolon
id|func_values
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|func_count
op_ne
l_int|0
)paren
(brace
id|func_values
op_assign
(paren
r_int
op_star
)paren
id|malloc
c_func
(paren
id|func_count
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|func_values
op_eq
l_int|NULL
)paren
id|stop
c_func
(paren
l_string|&quot;Could not malloc&quot;
comma
id|EX_OSERR
)paren
suffix:semicolon
id|func_values
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* FALSE func */
id|func_count
op_decrement
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Ask the user to fill in the return values for&n;&t;&t; * the rest of the functions.&n;&t;&t; */
r_for
c_loop
(paren
id|cur_func
op_assign
id|SLIST_FIRST
c_func
(paren
op_amp
id|patch_functions
)paren
suffix:semicolon
id|cur_func
op_ne
l_int|NULL
op_logical_and
id|SLIST_NEXT
c_func
(paren
id|cur_func
comma
id|links
)paren
op_ne
l_int|NULL
suffix:semicolon
id|cur_func
op_assign
id|SLIST_NEXT
c_func
(paren
id|cur_func
comma
id|links
)paren
comma
id|func_count
op_decrement
)paren
(brace
r_int
id|input
suffix:semicolon
id|fprintf
c_func
(paren
id|stdout
comma
l_string|&quot;&bslash;n(%s)&bslash;n&quot;
comma
id|cur_func-&gt;symbol-&gt;name
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stdout
comma
l_string|&quot;Enter the return value for &quot;
l_string|&quot;this expression[T/F]:&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|input
op_assign
id|getchar
c_func
(paren
)paren
suffix:semicolon
id|input
op_assign
id|toupper
c_func
(paren
id|input
)paren
suffix:semicolon
r_if
c_cond
(paren
id|input
op_eq
l_char|&squot;T&squot;
)paren
(brace
id|func_values
(braket
id|func_count
)braket
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|input
op_eq
l_char|&squot;F&squot;
)paren
(brace
id|func_values
(braket
id|func_count
)braket
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|isatty
c_func
(paren
id|fileno
c_func
(paren
id|stdin
)paren
)paren
op_eq
l_int|0
)paren
id|putchar
c_func
(paren
id|input
)paren
suffix:semicolon
)brace
id|fprintf
c_func
(paren
id|stdout
comma
l_string|&quot;&bslash;nThanks!&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Now output the listing */
id|cur_patch
op_assign
id|STAILQ_FIRST
c_func
(paren
op_amp
id|patches
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cur_instr
op_assign
id|STAILQ_FIRST
c_func
(paren
op_amp
id|seq_program
)paren
suffix:semicolon
id|cur_instr
op_ne
l_int|NULL
suffix:semicolon
id|cur_instr
op_assign
id|STAILQ_NEXT
c_func
(paren
id|cur_instr
comma
id|links
)paren
comma
id|instrcount
op_increment
)paren
(brace
r_if
c_cond
(paren
id|check_patch
c_func
(paren
op_amp
id|cur_patch
comma
id|instrcount
comma
op_amp
id|skip_addr
comma
id|func_values
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Don&squot;t count this instruction as it is in a patch&n;&t;&t;&t; * that was removed.&n;&t;&t;&t; */
r_continue
suffix:semicolon
)brace
r_while
c_loop
(paren
id|line
OL
id|cur_instr-&gt;srcline
)paren
(brace
id|fgets
c_func
(paren
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
id|ifile
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|listfile
comma
l_string|&quot;&bslash;t&bslash;t%s&quot;
comma
id|buf
)paren
suffix:semicolon
id|line
op_increment
suffix:semicolon
)brace
id|fprintf
c_func
(paren
id|listfile
comma
l_string|&quot;%03x %02x%02x%02x%02x&quot;
comma
id|instrptr
comma
macro_line|#if BYTE_ORDER == LITTLE_ENDIAN
id|cur_instr-&gt;format.bytes
(braket
l_int|0
)braket
comma
id|cur_instr-&gt;format.bytes
(braket
l_int|1
)braket
comma
id|cur_instr-&gt;format.bytes
(braket
l_int|2
)braket
comma
id|cur_instr-&gt;format.bytes
(braket
l_int|3
)braket
)paren
suffix:semicolon
macro_line|#else
id|cur_instr-&gt;format.bytes
(braket
l_int|3
)braket
comma
id|cur_instr-&gt;format.bytes
(braket
l_int|2
)braket
comma
id|cur_instr-&gt;format.bytes
(braket
l_int|1
)braket
comma
id|cur_instr-&gt;format.bytes
(braket
l_int|0
)braket
)paren
suffix:semicolon
macro_line|#endif
id|fgets
c_func
(paren
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
id|ifile
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|listfile
comma
l_string|&quot;&bslash;t%s&quot;
comma
id|buf
)paren
suffix:semicolon
id|line
op_increment
suffix:semicolon
id|instrptr
op_increment
suffix:semicolon
)brace
multiline_comment|/* Dump the remainder of the file */
r_while
c_loop
(paren
id|fgets
c_func
(paren
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
id|ifile
)paren
op_ne
l_int|NULL
)paren
(brace
id|fprintf
c_func
(paren
id|listfile
comma
l_string|&quot;&bslash;t&bslash;t%s&quot;
comma
id|buf
)paren
suffix:semicolon
)brace
id|fclose
c_func
(paren
id|ifile
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|check_patch
id|check_patch
c_func
(paren
id|patch_t
op_star
op_star
id|start_patch
comma
r_int
id|start_instr
comma
r_int
op_star
id|skip_addr
comma
r_int
op_star
id|func_vals
)paren
(brace
id|patch_t
op_star
id|cur_patch
suffix:semicolon
id|cur_patch
op_assign
op_star
id|start_patch
suffix:semicolon
r_while
c_loop
(paren
id|cur_patch
op_ne
l_int|NULL
op_logical_and
id|start_instr
op_eq
id|cur_patch-&gt;begin
)paren
(brace
r_if
c_cond
(paren
id|func_vals
(braket
id|cur_patch-&gt;patch_func
)braket
op_eq
l_int|0
)paren
(brace
r_int
id|skip
suffix:semicolon
multiline_comment|/* Start rejecting code */
op_star
id|skip_addr
op_assign
id|start_instr
op_plus
id|cur_patch-&gt;skip_instr
suffix:semicolon
r_for
c_loop
(paren
id|skip
op_assign
id|cur_patch-&gt;skip_patch
suffix:semicolon
id|skip
OG
l_int|0
op_logical_and
id|cur_patch
op_ne
l_int|NULL
suffix:semicolon
id|skip
op_decrement
)paren
id|cur_patch
op_assign
id|STAILQ_NEXT
c_func
(paren
id|cur_patch
comma
id|links
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Accepted this patch.  Advance to the next&n;&t;&t;&t; * one and wait for our intruction pointer to&n;&t;&t;&t; * hit this point.&n;&t;&t;&t; */
id|cur_patch
op_assign
id|STAILQ_NEXT
c_func
(paren
id|cur_patch
comma
id|links
)paren
suffix:semicolon
)brace
)brace
op_star
id|start_patch
op_assign
id|cur_patch
suffix:semicolon
r_if
c_cond
(paren
id|start_instr
OL
op_star
id|skip_addr
)paren
multiline_comment|/* Still skipping */
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Print out error information if appropriate, and clean up before&n; * terminating the program.&n; */
r_void
DECL|function|stop
id|stop
c_func
(paren
r_const
r_char
op_star
id|string
comma
r_int
id|err_code
)paren
(brace
r_if
c_cond
(paren
id|string
op_ne
l_int|NULL
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: &quot;
comma
id|appname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|yyfilename
op_ne
l_int|NULL
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Stopped at file %s, line %d - &quot;
comma
id|yyfilename
comma
id|yylineno
)paren
suffix:semicolon
)brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s&bslash;n&quot;
comma
id|string
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ofile
op_ne
l_int|NULL
)paren
(brace
id|fclose
c_func
(paren
id|ofile
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err_code
op_ne
l_int|0
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: Removing %s due to error&bslash;n&quot;
comma
id|appname
comma
id|ofilename
)paren
suffix:semicolon
id|unlink
c_func
(paren
id|ofilename
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|regfile
op_ne
l_int|NULL
)paren
(brace
id|fclose
c_func
(paren
id|regfile
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err_code
op_ne
l_int|0
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: Removing %s due to error&bslash;n&quot;
comma
id|appname
comma
id|regfilename
)paren
suffix:semicolon
id|unlink
c_func
(paren
id|regfilename
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|listfile
op_ne
l_int|NULL
)paren
(brace
id|fclose
c_func
(paren
id|listfile
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err_code
op_ne
l_int|0
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: Removing %s due to error&bslash;n&quot;
comma
id|appname
comma
id|listfilename
)paren
suffix:semicolon
id|unlink
c_func
(paren
id|listfilename
)paren
suffix:semicolon
)brace
)brace
id|symlist_free
c_func
(paren
op_amp
id|patch_functions
)paren
suffix:semicolon
id|symtable_close
c_func
(paren
)paren
suffix:semicolon
m_exit
(paren
id|err_code
)paren
suffix:semicolon
)brace
r_struct
id|instruction
op_star
DECL|function|seq_alloc
id|seq_alloc
c_func
(paren
)paren
(brace
r_struct
id|instruction
op_star
id|new_instr
suffix:semicolon
id|new_instr
op_assign
(paren
r_struct
id|instruction
op_star
)paren
id|malloc
c_func
(paren
r_sizeof
(paren
r_struct
id|instruction
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_instr
op_eq
l_int|NULL
)paren
id|stop
c_func
(paren
l_string|&quot;Unable to malloc instruction object&quot;
comma
id|EX_SOFTWARE
)paren
suffix:semicolon
id|memset
c_func
(paren
id|new_instr
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|new_instr
)paren
)paren
suffix:semicolon
id|STAILQ_INSERT_TAIL
c_func
(paren
op_amp
id|seq_program
comma
id|new_instr
comma
id|links
)paren
suffix:semicolon
id|new_instr-&gt;srcline
op_assign
id|yylineno
suffix:semicolon
r_return
id|new_instr
suffix:semicolon
)brace
id|critical_section_t
op_star
DECL|function|cs_alloc
id|cs_alloc
c_func
(paren
)paren
(brace
id|critical_section_t
op_star
id|new_cs
suffix:semicolon
id|new_cs
op_assign
(paren
id|critical_section_t
op_star
)paren
id|malloc
c_func
(paren
r_sizeof
(paren
id|critical_section_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_cs
op_eq
l_int|NULL
)paren
id|stop
c_func
(paren
l_string|&quot;Unable to malloc critical_section object&quot;
comma
id|EX_SOFTWARE
)paren
suffix:semicolon
id|memset
c_func
(paren
id|new_cs
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|new_cs
)paren
)paren
suffix:semicolon
id|TAILQ_INSERT_TAIL
c_func
(paren
op_amp
id|cs_tailq
comma
id|new_cs
comma
id|links
)paren
suffix:semicolon
r_return
id|new_cs
suffix:semicolon
)brace
id|scope_t
op_star
DECL|function|scope_alloc
id|scope_alloc
c_func
(paren
)paren
(brace
id|scope_t
op_star
id|new_scope
suffix:semicolon
id|new_scope
op_assign
(paren
id|scope_t
op_star
)paren
id|malloc
c_func
(paren
r_sizeof
(paren
id|scope_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_scope
op_eq
l_int|NULL
)paren
id|stop
c_func
(paren
l_string|&quot;Unable to malloc scope object&quot;
comma
id|EX_SOFTWARE
)paren
suffix:semicolon
id|memset
c_func
(paren
id|new_scope
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|new_scope
)paren
)paren
suffix:semicolon
id|TAILQ_INIT
c_func
(paren
op_amp
id|new_scope-&gt;inner_scope
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SLIST_FIRST
c_func
(paren
op_amp
id|scope_stack
)paren
op_ne
l_int|NULL
)paren
(brace
id|TAILQ_INSERT_TAIL
c_func
(paren
op_amp
id|SLIST_FIRST
c_func
(paren
op_amp
id|scope_stack
)paren
op_member_access_from_pointer
id|inner_scope
comma
id|new_scope
comma
id|scope_links
)paren
suffix:semicolon
)brace
multiline_comment|/* This patch is now the current scope */
id|SLIST_INSERT_HEAD
c_func
(paren
op_amp
id|scope_stack
comma
id|new_scope
comma
id|scope_stack_links
)paren
suffix:semicolon
r_return
id|new_scope
suffix:semicolon
)brace
r_void
DECL|function|process_scope
id|process_scope
c_func
(paren
id|scope_t
op_star
id|scope
)paren
(brace
multiline_comment|/*&n;&t; * We are &quot;leaving&quot; this scope.  We should now have&n;&t; * enough information to process the lists of scopes&n;&t; * we encapsulate.&n;&t; */
id|scope_t
op_star
id|cur_scope
suffix:semicolon
id|u_int
id|skip_patch_count
suffix:semicolon
id|u_int
id|skip_instr_count
suffix:semicolon
id|cur_scope
op_assign
id|TAILQ_LAST
c_func
(paren
op_amp
id|scope-&gt;inner_scope
comma
id|scope_tailq
)paren
suffix:semicolon
id|skip_patch_count
op_assign
l_int|0
suffix:semicolon
id|skip_instr_count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|cur_scope
op_ne
l_int|NULL
)paren
(brace
id|u_int
id|patch0_patch_skip
suffix:semicolon
id|patch0_patch_skip
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|cur_scope-&gt;type
)paren
(brace
r_case
id|SCOPE_IF
suffix:colon
r_case
id|SCOPE_ELSE_IF
suffix:colon
r_if
c_cond
(paren
id|skip_instr_count
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Create a tail patch */
id|patch0_patch_skip
op_increment
suffix:semicolon
id|cur_scope-&gt;patches
(braket
l_int|1
)braket
dot
id|skip_patch
op_assign
id|skip_patch_count
op_plus
l_int|1
suffix:semicolon
id|cur_scope-&gt;patches
(braket
l_int|1
)braket
dot
id|skip_instr
op_assign
id|skip_instr_count
suffix:semicolon
)brace
multiline_comment|/* Count Head patch */
id|patch0_patch_skip
op_increment
suffix:semicolon
multiline_comment|/* Count any patches contained in our inner scope */
id|patch0_patch_skip
op_add_assign
id|cur_scope-&gt;inner_scope_patches
suffix:semicolon
id|cur_scope-&gt;patches
(braket
l_int|0
)braket
dot
id|skip_patch
op_assign
id|patch0_patch_skip
suffix:semicolon
id|cur_scope-&gt;patches
(braket
l_int|0
)braket
dot
id|skip_instr
op_assign
id|cur_scope-&gt;end_addr
op_minus
id|cur_scope-&gt;begin_addr
suffix:semicolon
id|skip_instr_count
op_add_assign
id|cur_scope-&gt;patches
(braket
l_int|0
)braket
dot
id|skip_instr
suffix:semicolon
id|skip_patch_count
op_add_assign
id|patch0_patch_skip
suffix:semicolon
r_if
c_cond
(paren
id|cur_scope-&gt;type
op_eq
id|SCOPE_IF
)paren
(brace
id|scope-&gt;inner_scope_patches
op_add_assign
id|skip_patch_count
suffix:semicolon
id|skip_patch_count
op_assign
l_int|0
suffix:semicolon
id|skip_instr_count
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SCOPE_ELSE
suffix:colon
multiline_comment|/* Count any patches contained in our innter scope */
id|skip_patch_count
op_add_assign
id|cur_scope-&gt;inner_scope_patches
suffix:semicolon
id|skip_instr_count
op_add_assign
id|cur_scope-&gt;end_addr
op_minus
id|cur_scope-&gt;begin_addr
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCOPE_ROOT
suffix:colon
id|stop
c_func
(paren
l_string|&quot;Unexpected scope type encountered&quot;
comma
id|EX_SOFTWARE
)paren
suffix:semicolon
multiline_comment|/* NOTREACHED */
)brace
id|cur_scope
op_assign
id|TAILQ_PREV
c_func
(paren
id|cur_scope
comma
id|scope_tailq
comma
id|scope_links
)paren
suffix:semicolon
)brace
)brace
eof
