multiline_comment|/*&n; * Core routines and tables shareable across OS platforms.&n; *&n; * Copyright (c) 1994-2002 Justin T. Gibbs.&n; * Copyright (c) 2000-2002 Adaptec Inc.&n; * All rights reserved.&n; *&n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions&n; * are met:&n; * 1. Redistributions of source code must retain the above copyright&n; *    notice, this list of conditions, and the following disclaimer,&n; *    without modification.&n; * 2. Redistributions in binary form must reproduce at minimum a disclaimer&n; *    substantially similar to the &quot;NO WARRANTY&quot; disclaimer below&n; *    (&quot;Disclaimer&quot;) and any redistribution must be conditioned upon&n; *    including a substantially similar Disclaimer requirement for further&n; *    binary redistribution.&n; * 3. Neither the names of the above-listed copyright holders nor the names&n; *    of any contributors may be used to endorse or promote products derived&n; *    from this software without specific prior written permission.&n; *&n; * Alternatively, this software may be distributed under the terms of the&n; * GNU General Public License (&quot;GPL&quot;) version 2 as published by the Free&n; * Software Foundation.&n; *&n; * NO WARRANTY&n; * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS&n; * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT&n; * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR&n; * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT&n; * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL&n; * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS&n; * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)&n; * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,&n; * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING&n; * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE&n; * POSSIBILITY OF SUCH DAMAGES.&n; *&n; * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.c#103 $&n; *&n; * $FreeBSD$&n; */
macro_line|#ifdef __linux__
macro_line|#include &quot;aic7xxx_osm.h&quot;
macro_line|#include &quot;aic7xxx_inline.h&quot;
macro_line|#include &quot;aicasm/aicasm_insformat.h&quot;
macro_line|#else
macro_line|#include &lt;dev/aic7xxx/aic7xxx_osm.h&gt;
macro_line|#include &lt;dev/aic7xxx/aic7xxx_inline.h&gt;
macro_line|#include &lt;dev/aic7xxx/aicasm/aicasm_insformat.h&gt;
macro_line|#endif
multiline_comment|/****************************** Softc Data ************************************/
DECL|variable|ahc_tailq
r_struct
id|ahc_softc_tailq
id|ahc_tailq
op_assign
id|TAILQ_HEAD_INITIALIZER
c_func
(paren
id|ahc_tailq
)paren
suffix:semicolon
multiline_comment|/***************************** Lookup Tables **********************************/
DECL|variable|ahc_chip_names
r_char
op_star
id|ahc_chip_names
(braket
)braket
op_assign
(brace
l_string|&quot;NONE&quot;
comma
l_string|&quot;aic7770&quot;
comma
l_string|&quot;aic7850&quot;
comma
l_string|&quot;aic7855&quot;
comma
l_string|&quot;aic7859&quot;
comma
l_string|&quot;aic7860&quot;
comma
l_string|&quot;aic7870&quot;
comma
l_string|&quot;aic7880&quot;
comma
l_string|&quot;aic7895&quot;
comma
l_string|&quot;aic7895C&quot;
comma
l_string|&quot;aic7890/91&quot;
comma
l_string|&quot;aic7896/97&quot;
comma
l_string|&quot;aic7892&quot;
comma
l_string|&quot;aic7899&quot;
)brace
suffix:semicolon
DECL|variable|num_chip_names
r_static
r_const
id|u_int
id|num_chip_names
op_assign
id|NUM_ELEMENTS
c_func
(paren
id|ahc_chip_names
)paren
suffix:semicolon
multiline_comment|/*&n; * Hardware error codes.&n; */
DECL|struct|ahc_hard_error_entry
r_struct
id|ahc_hard_error_entry
(brace
DECL|member|errno
r_uint8
id|errno
suffix:semicolon
DECL|member|errmesg
r_char
op_star
id|errmesg
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|ahc_hard_errors
r_static
r_struct
id|ahc_hard_error_entry
id|ahc_hard_errors
(braket
)braket
op_assign
(brace
(brace
id|ILLHADDR
comma
l_string|&quot;Illegal Host Access&quot;
)brace
comma
(brace
id|ILLSADDR
comma
l_string|&quot;Illegal Sequencer Address referrenced&quot;
)brace
comma
(brace
id|ILLOPCODE
comma
l_string|&quot;Illegal Opcode in sequencer program&quot;
)brace
comma
(brace
id|SQPARERR
comma
l_string|&quot;Sequencer Parity Error&quot;
)brace
comma
(brace
id|DPARERR
comma
l_string|&quot;Data-path Parity Error&quot;
)brace
comma
(brace
id|MPARERR
comma
l_string|&quot;Scratch or SCB Memory Parity Error&quot;
)brace
comma
(brace
id|PCIERRSTAT
comma
l_string|&quot;PCI Error detected&quot;
)brace
comma
(brace
id|CIOPARERR
comma
l_string|&quot;CIOBUS Parity Error&quot;
)brace
comma
)brace
suffix:semicolon
DECL|variable|num_errors
r_static
r_const
id|u_int
id|num_errors
op_assign
id|NUM_ELEMENTS
c_func
(paren
id|ahc_hard_errors
)paren
suffix:semicolon
DECL|variable|ahc_phase_table
r_static
r_struct
id|ahc_phase_table_entry
id|ahc_phase_table
(braket
)braket
op_assign
(brace
(brace
id|P_DATAOUT
comma
id|MSG_NOOP
comma
l_string|&quot;in Data-out phase&quot;
)brace
comma
(brace
id|P_DATAIN
comma
id|MSG_INITIATOR_DET_ERR
comma
l_string|&quot;in Data-in phase&quot;
)brace
comma
(brace
id|P_DATAOUT_DT
comma
id|MSG_NOOP
comma
l_string|&quot;in DT Data-out phase&quot;
)brace
comma
(brace
id|P_DATAIN_DT
comma
id|MSG_INITIATOR_DET_ERR
comma
l_string|&quot;in DT Data-in phase&quot;
)brace
comma
(brace
id|P_COMMAND
comma
id|MSG_NOOP
comma
l_string|&quot;in Command phase&quot;
)brace
comma
(brace
id|P_MESGOUT
comma
id|MSG_NOOP
comma
l_string|&quot;in Message-out phase&quot;
)brace
comma
(brace
id|P_STATUS
comma
id|MSG_INITIATOR_DET_ERR
comma
l_string|&quot;in Status phase&quot;
)brace
comma
(brace
id|P_MESGIN
comma
id|MSG_PARITY_ERROR
comma
l_string|&quot;in Message-in phase&quot;
)brace
comma
(brace
id|P_BUSFREE
comma
id|MSG_NOOP
comma
l_string|&quot;while idle&quot;
)brace
comma
(brace
l_int|0
comma
id|MSG_NOOP
comma
l_string|&quot;in unknown phase&quot;
)brace
)brace
suffix:semicolon
multiline_comment|/*&n; * In most cases we only wish to itterate over real phases, so&n; * exclude the last element from the count.&n; */
DECL|variable|num_phases
r_static
r_const
id|u_int
id|num_phases
op_assign
id|NUM_ELEMENTS
c_func
(paren
id|ahc_phase_table
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n; * Valid SCSIRATE values.  (p. 3-17)&n; * Provides a mapping of tranfer periods in ns to the proper value to&n; * stick in the scsixfer reg.&n; */
DECL|variable|ahc_syncrates
r_static
r_struct
id|ahc_syncrate
id|ahc_syncrates
(braket
)braket
op_assign
(brace
multiline_comment|/* ultra2    fast/ultra  period     rate */
(brace
l_int|0x42
comma
l_int|0x000
comma
l_int|9
comma
l_string|&quot;80.0&quot;
)brace
comma
(brace
l_int|0x03
comma
l_int|0x000
comma
l_int|10
comma
l_string|&quot;40.0&quot;
)brace
comma
(brace
l_int|0x04
comma
l_int|0x000
comma
l_int|11
comma
l_string|&quot;33.0&quot;
)brace
comma
(brace
l_int|0x05
comma
l_int|0x100
comma
l_int|12
comma
l_string|&quot;20.0&quot;
)brace
comma
(brace
l_int|0x06
comma
l_int|0x110
comma
l_int|15
comma
l_string|&quot;16.0&quot;
)brace
comma
(brace
l_int|0x07
comma
l_int|0x120
comma
l_int|18
comma
l_string|&quot;13.4&quot;
)brace
comma
(brace
l_int|0x08
comma
l_int|0x000
comma
l_int|25
comma
l_string|&quot;10.0&quot;
)brace
comma
(brace
l_int|0x19
comma
l_int|0x010
comma
l_int|31
comma
l_string|&quot;8.0&quot;
)brace
comma
(brace
l_int|0x1a
comma
l_int|0x020
comma
l_int|37
comma
l_string|&quot;6.67&quot;
)brace
comma
(brace
l_int|0x1b
comma
l_int|0x030
comma
l_int|43
comma
l_string|&quot;5.7&quot;
)brace
comma
(brace
l_int|0x1c
comma
l_int|0x040
comma
l_int|50
comma
l_string|&quot;5.0&quot;
)brace
comma
(brace
l_int|0x00
comma
l_int|0x050
comma
l_int|56
comma
l_string|&quot;4.4&quot;
)brace
comma
(brace
l_int|0x00
comma
l_int|0x060
comma
l_int|62
comma
l_string|&quot;4.0&quot;
)brace
comma
(brace
l_int|0x00
comma
l_int|0x070
comma
l_int|68
comma
l_string|&quot;3.6&quot;
)brace
comma
(brace
l_int|0x00
comma
l_int|0x000
comma
l_int|0
comma
l_int|NULL
)brace
)brace
suffix:semicolon
multiline_comment|/* Our Sequencer Program */
macro_line|#include &quot;aic7xxx_seq.h&quot;
multiline_comment|/**************************** Function Declarations ***************************/
r_static
r_void
id|ahc_force_renegotiation
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
suffix:semicolon
r_static
r_struct
id|ahc_tmode_tstate
op_star
id|ahc_alloc_tstate
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|u_int
id|scsi_id
comma
r_char
id|channel
)paren
suffix:semicolon
macro_line|#ifdef AHC_TARGET_MODE
r_static
r_void
id|ahc_free_tstate
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|u_int
id|scsi_id
comma
r_char
id|channel
comma
r_int
id|force
)paren
suffix:semicolon
macro_line|#endif
r_static
r_struct
id|ahc_syncrate
op_star
id|ahc_devlimited_syncrate
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_initiator_tinfo
op_star
comma
id|u_int
op_star
id|period
comma
id|u_int
op_star
id|ppr_options
comma
id|role_t
id|role
)paren
suffix:semicolon
r_static
r_void
id|ahc_update_pending_scbs
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
suffix:semicolon
r_static
r_void
id|ahc_fetch_devinfo
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
)paren
suffix:semicolon
r_static
r_void
id|ahc_scb_devinfo
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
comma
r_struct
id|scb
op_star
id|scb
)paren
suffix:semicolon
r_static
r_void
id|ahc_assert_atn
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
suffix:semicolon
r_static
r_void
id|ahc_setup_initiator_msgout
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
comma
r_struct
id|scb
op_star
id|scb
)paren
suffix:semicolon
r_static
r_void
id|ahc_build_transfer_msg
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
)paren
suffix:semicolon
r_static
r_void
id|ahc_construct_sdtr
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
comma
id|u_int
id|period
comma
id|u_int
id|offset
)paren
suffix:semicolon
r_static
r_void
id|ahc_construct_wdtr
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
comma
id|u_int
id|bus_width
)paren
suffix:semicolon
r_static
r_void
id|ahc_construct_ppr
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
comma
id|u_int
id|period
comma
id|u_int
id|offset
comma
id|u_int
id|bus_width
comma
id|u_int
id|ppr_options
)paren
suffix:semicolon
r_static
r_void
id|ahc_clear_msg_state
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
suffix:semicolon
r_static
r_void
id|ahc_handle_proto_violation
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
suffix:semicolon
r_static
r_void
id|ahc_handle_message_phase
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
suffix:semicolon
r_typedef
r_enum
(brace
DECL|enumerator|AHCMSG_1B
id|AHCMSG_1B
comma
DECL|enumerator|AHCMSG_2B
id|AHCMSG_2B
comma
DECL|enumerator|AHCMSG_EXT
id|AHCMSG_EXT
DECL|typedef|ahc_msgtype
)brace
id|ahc_msgtype
suffix:semicolon
r_static
r_int
id|ahc_sent_msg
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|ahc_msgtype
id|type
comma
id|u_int
id|msgval
comma
r_int
id|full
)paren
suffix:semicolon
r_static
r_int
id|ahc_parse_msg
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
)paren
suffix:semicolon
r_static
r_int
id|ahc_handle_msg_reject
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
)paren
suffix:semicolon
r_static
r_void
id|ahc_handle_ign_wide_residue
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
)paren
suffix:semicolon
r_static
r_void
id|ahc_reinitialize_dataptrs
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
suffix:semicolon
r_static
r_void
id|ahc_handle_devreset
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
comma
id|cam_status
id|status
comma
r_char
op_star
id|message
comma
r_int
id|verbose_level
)paren
suffix:semicolon
macro_line|#if AHC_TARGET_MODE
r_static
r_void
id|ahc_setup_target_msgin
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
comma
r_struct
id|scb
op_star
id|scb
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|ahc_dmamap_cb
r_static
id|bus_dmamap_callback_t
id|ahc_dmamap_cb
suffix:semicolon
r_static
r_void
id|ahc_build_free_scb_list
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
suffix:semicolon
r_static
r_int
id|ahc_init_scbdata
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
suffix:semicolon
r_static
r_void
id|ahc_fini_scbdata
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
suffix:semicolon
r_static
r_void
id|ahc_qinfifo_requeue
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|scb
op_star
id|prev_scb
comma
r_struct
id|scb
op_star
id|scb
)paren
suffix:semicolon
r_static
r_int
id|ahc_qinfifo_count
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
suffix:semicolon
r_static
id|u_int
id|ahc_rem_scb_from_disc_list
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|u_int
id|prev
comma
id|u_int
id|scbptr
)paren
suffix:semicolon
r_static
r_void
id|ahc_add_curscb_to_free_list
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
suffix:semicolon
r_static
id|u_int
id|ahc_rem_wscb
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|u_int
id|scbpos
comma
id|u_int
id|prev
)paren
suffix:semicolon
r_static
r_void
id|ahc_reset_current_bus
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
suffix:semicolon
macro_line|#ifdef AHC_DUMP_SEQ
r_static
r_void
id|ahc_dumpseq
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
suffix:semicolon
macro_line|#endif
r_static
r_void
id|ahc_loadseq
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
suffix:semicolon
r_static
r_int
id|ahc_check_patch
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|patch
op_star
op_star
id|start_patch
comma
id|u_int
id|start_instr
comma
id|u_int
op_star
id|skip_addr
)paren
suffix:semicolon
r_static
r_void
id|ahc_download_instr
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|u_int
id|instrptr
comma
r_uint8
op_star
id|dconsts
)paren
suffix:semicolon
r_static
r_int
id|ahc_probe_stack_size
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
suffix:semicolon
macro_line|#ifdef AHC_TARGET_MODE
r_static
r_void
id|ahc_queue_lstate_event
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_tmode_lstate
op_star
id|lstate
comma
id|u_int
id|initiator_id
comma
id|u_int
id|event_type
comma
id|u_int
id|event_arg
)paren
suffix:semicolon
r_static
r_void
id|ahc_update_scsiid
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|u_int
id|targid_mask
)paren
suffix:semicolon
r_static
r_int
id|ahc_handle_target_cmd
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|target_cmd
op_star
id|cmd
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/************************* Sequencer Execution Control ************************/
multiline_comment|/*&n; * Restart the sequencer program from address zero&n; */
r_void
DECL|function|ahc_restart
id|ahc_restart
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
id|ahc_pause
c_func
(paren
id|ahc
)paren
suffix:semicolon
multiline_comment|/* No more pending messages. */
id|ahc_clear_msg_state
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSISIGO
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* De-assert BSY */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|MSG_OUT
comma
id|MSG_NOOP
)paren
suffix:semicolon
multiline_comment|/* No message to send */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SXFRCTL1
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SXFRCTL1
)paren
op_amp
op_complement
id|BITBUCKET
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|LASTPHASE
comma
id|P_BUSFREE
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SAVED_SCSIID
comma
l_int|0xFF
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SAVED_LUN
comma
l_int|0xFF
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ensure that the sequencer&squot;s idea of TQINPOS&n;&t; * matches our own.  The sequencer increments TQINPOS&n;&t; * only after it sees a DMA complete and a reset could&n;&t; * occur before the increment leaving the kernel to believe&n;&t; * the command arrived but the sequencer to not.&n;&t; */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|TQINPOS
comma
id|ahc-&gt;tqinfifonext
)paren
suffix:semicolon
multiline_comment|/* Always allow reselection */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSISEQ
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSISEQ_TEMPLATE
)paren
op_amp
(paren
id|ENSELI
op_or
id|ENRSELI
op_or
id|ENAUTOATNP
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_CMD_CHAN
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Ensure that no DMA operations are in progress */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CCSCBCNT
comma
l_int|0
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CCSGCTL
comma
l_int|0
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CCSCBCTL
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we were in the process of DMA&squot;ing SCB data into&n;&t; * an SCB, replace that SCB on the free list.  This prevents&n;&t; * an SCB leak.&n;&t; */
r_if
c_cond
(paren
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SEQ_FLAGS2
)paren
op_amp
id|SCB_DMA
)paren
op_ne
l_int|0
)paren
(brace
id|ahc_add_curscb_to_free_list
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SEQ_FLAGS2
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SEQ_FLAGS2
)paren
op_amp
op_complement
id|SCB_DMA
)paren
suffix:semicolon
)brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|MWI_RESIDUAL
comma
l_int|0
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SEQCTL
comma
id|FASTMODE
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SEQADDR0
comma
l_int|0
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SEQADDR1
comma
l_int|0
)paren
suffix:semicolon
id|ahc_unpause
c_func
(paren
id|ahc
)paren
suffix:semicolon
)brace
multiline_comment|/************************* Input/Output Queues ********************************/
r_void
DECL|function|ahc_run_qoutfifo
id|ahc_run_qoutfifo
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_struct
id|scb
op_star
id|scb
suffix:semicolon
id|u_int
id|scb_index
suffix:semicolon
id|ahc_sync_qoutfifo
c_func
(paren
id|ahc
comma
id|BUS_DMASYNC_POSTREAD
)paren
suffix:semicolon
r_while
c_loop
(paren
id|ahc-&gt;qoutfifo
(braket
id|ahc-&gt;qoutfifonext
)braket
op_ne
id|SCB_LIST_NULL
)paren
(brace
id|scb_index
op_assign
id|ahc-&gt;qoutfifo
(braket
id|ahc-&gt;qoutfifonext
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;qoutfifonext
op_amp
l_int|0x03
)paren
op_eq
l_int|0x03
)paren
(brace
id|u_int
id|modnext
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Clear 32bits of QOUTFIFO at a time&n;&t;&t;&t; * so that we don&squot;t clobber an incoming&n;&t;&t;&t; * byte DMA to the array on architectures&n;&t;&t;&t; * that only support 32bit load and store&n;&t;&t;&t; * operations.&n;&t;&t;&t; */
id|modnext
op_assign
id|ahc-&gt;qoutfifonext
op_amp
op_complement
l_int|0x3
suffix:semicolon
op_star
(paren
(paren
r_uint32
op_star
)paren
(paren
op_amp
id|ahc-&gt;qoutfifo
(braket
id|modnext
)braket
)paren
)paren
op_assign
l_int|0xFFFFFFFFUL
suffix:semicolon
id|ahc_dmamap_sync
c_func
(paren
id|ahc
comma
id|ahc-&gt;shared_data_dmat
comma
id|ahc-&gt;shared_data_dmamap
comma
multiline_comment|/*offset*/
id|modnext
comma
multiline_comment|/*len*/
l_int|4
comma
id|BUS_DMASYNC_PREREAD
)paren
suffix:semicolon
)brace
id|ahc-&gt;qoutfifonext
op_increment
suffix:semicolon
id|scb
op_assign
id|ahc_lookup_scb
c_func
(paren
id|ahc
comma
id|scb_index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: WARNING no command for scb %d &quot;
l_string|&quot;(cmdcmplt)&bslash;nQOUTPOS = %d&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|scb_index
comma
(paren
id|ahc-&gt;qoutfifonext
op_minus
l_int|1
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Save off the residual&n;&t;&t; * if there is one.&n;&t;&t; */
id|ahc_update_residual
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|ahc_done
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
)brace
)brace
r_void
DECL|function|ahc_run_untagged_queues
id|ahc_run_untagged_queues
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
id|ahc_run_untagged_queue
c_func
(paren
id|ahc
comma
op_amp
id|ahc-&gt;untagged_queues
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahc_run_untagged_queue
id|ahc_run_untagged_queue
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|scb_tailq
op_star
id|queue
)paren
(brace
r_struct
id|scb
op_star
id|scb
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;untagged_queue_lock
op_ne
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb
op_assign
id|TAILQ_FIRST
c_func
(paren
id|queue
)paren
)paren
op_ne
l_int|NULL
op_logical_and
(paren
id|scb-&gt;flags
op_amp
id|SCB_ACTIVE
)paren
op_eq
l_int|0
)paren
(brace
id|scb-&gt;flags
op_or_assign
id|SCB_ACTIVE
suffix:semicolon
id|ahc_queue_scb
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/************************* Interrupt Handling *********************************/
r_void
DECL|function|ahc_handle_brkadrint
id|ahc_handle_brkadrint
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
multiline_comment|/*&n;&t; * We upset the sequencer :-(&n;&t; * Lookup the error message&n;&t; */
r_int
id|i
suffix:semicolon
r_int
id|error
suffix:semicolon
id|error
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|ERROR
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|error
op_ne
l_int|1
op_logical_and
id|i
OL
id|num_errors
suffix:semicolon
id|i
op_increment
)paren
id|error
op_rshift_assign
l_int|1
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s: brkadrint, %s at seqaddr = 0x%x&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|ahc_hard_errors
(braket
id|i
)braket
dot
id|errmesg
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SEQADDR0
)paren
op_or
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SEQADDR1
)paren
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
id|ahc_dump_card_state
c_func
(paren
id|ahc
)paren
suffix:semicolon
multiline_comment|/* Tell everyone that this HBA is no longer availible */
id|ahc_abort_scbs
c_func
(paren
id|ahc
comma
id|CAM_TARGET_WILDCARD
comma
id|ALL_CHANNELS
comma
id|CAM_LUN_WILDCARD
comma
id|SCB_LIST_NULL
comma
id|ROLE_UNKNOWN
comma
id|CAM_NO_HBA
)paren
suffix:semicolon
multiline_comment|/* Disable all interrupt sources by resetting the controller */
id|ahc_shutdown
c_func
(paren
id|ahc
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahc_handle_seqint
id|ahc_handle_seqint
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|u_int
id|intstat
)paren
(brace
r_struct
id|scb
op_star
id|scb
suffix:semicolon
r_struct
id|ahc_devinfo
id|devinfo
suffix:semicolon
id|ahc_fetch_devinfo
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Clear the upper byte that holds SEQINT status&n;&t; * codes and clear the SEQINT bit. We will unpause&n;&t; * the sequencer, if appropriate, after servicing&n;&t; * the request.&n;&t; */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CLRINT
comma
id|CLRSEQINT
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|intstat
op_amp
id|SEQINT_MASK
)paren
(brace
r_case
id|BAD_STATUS
suffix:colon
(brace
id|u_int
id|scb_index
suffix:semicolon
r_struct
id|hardware_scb
op_star
id|hscb
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Set the default return value to 0 (don&squot;t&n;&t;&t; * send sense).  The sense code will change&n;&t;&t; * this if needed.&n;&t;&t; */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|RETURN_1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The sequencer will notify us when a command&n;&t;&t; * has an error that would be of interest to&n;&t;&t; * the kernel.  This allows us to leave the sequencer&n;&t;&t; * running in the common case of command completes&n;&t;&t; * without error.  The sequencer will already have&n;&t;&t; * dma&squot;d the SCB back up to us, so we can reference&n;&t;&t; * the in kernel copy directly.&n;&t;&t; */
id|scb_index
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_TAG
)paren
suffix:semicolon
id|scb
op_assign
id|ahc_lookup_scb
c_func
(paren
id|ahc
comma
id|scb_index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
id|ahc_print_devinfo
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;ahc_intr - referenced scb &quot;
l_string|&quot;not valid during seqint 0x%x scb(%d)&bslash;n&quot;
comma
id|intstat
comma
id|scb_index
)paren
suffix:semicolon
id|ahc_dump_card_state
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;for safety&quot;
)paren
suffix:semicolon
r_goto
id|unpause
suffix:semicolon
)brace
id|hscb
op_assign
id|scb-&gt;hscb
suffix:semicolon
multiline_comment|/* Don&squot;t want to clobber the original sense code */
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_SENSE
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Clear the SCB_SENSE Flag and have&n;&t;&t;&t; * the sequencer do a normal command&n;&t;&t;&t; * complete.&n;&t;&t;&t; */
id|scb-&gt;flags
op_and_assign
op_complement
id|SCB_SENSE
suffix:semicolon
id|ahc_set_transaction_status
c_func
(paren
id|scb
comma
id|CAM_AUTOSENSE_FAIL
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ahc_set_transaction_status
c_func
(paren
id|scb
comma
id|CAM_SCSI_STATUS_ERROR
)paren
suffix:semicolon
multiline_comment|/* Freeze the queue until the client sees the error. */
id|ahc_freeze_devq
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|ahc_freeze_scb
c_func
(paren
id|scb
)paren
suffix:semicolon
id|ahc_set_scsi_status
c_func
(paren
id|scb
comma
id|hscb-&gt;shared_data.status.scsi_status
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|hscb-&gt;shared_data.status.scsi_status
)paren
(brace
r_case
id|SCSI_STATUS_OK
suffix:colon
id|printf
c_func
(paren
l_string|&quot;%s: Interrupted for staus of 0???&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCSI_STATUS_CMD_TERMINATED
suffix:colon
r_case
id|SCSI_STATUS_CHECK_COND
suffix:colon
(brace
r_struct
id|ahc_dma_seg
op_star
id|sg
suffix:semicolon
r_struct
id|scsi_sense
op_star
id|sc
suffix:semicolon
r_struct
id|ahc_initiator_tinfo
op_star
id|targ_info
suffix:semicolon
r_struct
id|ahc_tmode_tstate
op_star
id|tstate
suffix:semicolon
r_struct
id|ahc_transinfo
op_star
id|tinfo
suffix:semicolon
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_SENSE
)paren
(brace
id|ahc_print_path
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;SCB %d: requests Check Status&bslash;n&quot;
comma
id|scb-&gt;hscb-&gt;tag
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|ahc_perform_autosense
c_func
(paren
id|scb
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|targ_info
op_assign
id|ahc_fetch_transinfo
c_func
(paren
id|ahc
comma
id|devinfo.channel
comma
id|devinfo.our_scsiid
comma
id|devinfo.target
comma
op_amp
id|tstate
)paren
suffix:semicolon
id|tinfo
op_assign
op_amp
id|targ_info-&gt;curr
suffix:semicolon
id|sg
op_assign
id|scb-&gt;sg_list
suffix:semicolon
id|sc
op_assign
(paren
r_struct
id|scsi_sense
op_star
)paren
(paren
op_amp
id|hscb-&gt;shared_data.cdb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Save off the residual if there is one.&n;&t;&t;&t; */
id|ahc_update_residual
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_SENSE
)paren
(brace
id|ahc_print_path
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Sending Sense&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|sg-&gt;addr
op_assign
id|ahc_get_sense_bufaddr
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|sg-&gt;len
op_assign
id|ahc_get_sense_bufsize
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|sg-&gt;len
op_or_assign
id|AHC_DMA_LAST_SEG
suffix:semicolon
multiline_comment|/* Fixup byte order */
id|sg-&gt;addr
op_assign
id|ahc_htole32
c_func
(paren
id|sg-&gt;addr
)paren
suffix:semicolon
id|sg-&gt;len
op_assign
id|ahc_htole32
c_func
(paren
id|sg-&gt;len
)paren
suffix:semicolon
id|sc-&gt;opcode
op_assign
id|REQUEST_SENSE
suffix:semicolon
id|sc-&gt;byte2
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tinfo-&gt;protocol_version
op_le
id|SCSI_REV_2
op_logical_and
id|SCB_GET_LUN
c_func
(paren
id|scb
)paren
OL
l_int|8
)paren
id|sc-&gt;byte2
op_assign
id|SCB_GET_LUN
c_func
(paren
id|scb
)paren
op_lshift
l_int|5
suffix:semicolon
id|sc-&gt;unused
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|sc-&gt;unused
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|sc-&gt;length
op_assign
id|sg-&gt;len
suffix:semicolon
id|sc-&gt;control
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We can&squot;t allow the target to disconnect.&n;&t;&t;&t; * This will be an untagged transaction and&n;&t;&t;&t; * having the target disconnect will make this&n;&t;&t;&t; * transaction indestinguishable from outstanding&n;&t;&t;&t; * tagged transactions.&n;&t;&t;&t; */
id|hscb-&gt;control
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * This request sense could be because the&n;&t;&t;&t; * the device lost power or in some other&n;&t;&t;&t; * way has lost our transfer negotiations.&n;&t;&t;&t; * Renegotiate if appropriate.  Unit attention&n;&t;&t;&t; * errors will be reported before any data&n;&t;&t;&t; * phases occur.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ahc_get_residual
c_func
(paren
id|scb
)paren
op_eq
id|ahc_get_transfer_length
c_func
(paren
id|scb
)paren
)paren
(brace
id|ahc_update_neg_request
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
comma
id|tstate
comma
id|targ_info
comma
id|AHC_NEG_IF_NON_ASYNC
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tstate-&gt;auto_negotiate
op_amp
id|devinfo.target_mask
)paren
(brace
id|hscb-&gt;control
op_or_assign
id|MK_MESSAGE
suffix:semicolon
id|scb-&gt;flags
op_and_assign
op_complement
id|SCB_NEGOTIATE
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_AUTO_NEGOTIATE
suffix:semicolon
)brace
id|hscb-&gt;cdb_len
op_assign
r_sizeof
(paren
op_star
id|sc
)paren
suffix:semicolon
id|hscb-&gt;dataptr
op_assign
id|sg-&gt;addr
suffix:semicolon
id|hscb-&gt;datacnt
op_assign
id|sg-&gt;len
suffix:semicolon
id|hscb-&gt;sgptr
op_assign
id|scb-&gt;sg_list_phys
op_or
id|SG_FULL_RESID
suffix:semicolon
id|hscb-&gt;sgptr
op_assign
id|ahc_htole32
c_func
(paren
id|hscb-&gt;sgptr
)paren
suffix:semicolon
id|scb-&gt;sg_count
op_assign
l_int|1
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_SENSE
suffix:semicolon
id|ahc_qinfifo_requeue_tail
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|RETURN_1
comma
id|SEND_SENSE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Ensure we have enough time to actually&n;&t;&t;&t; * retrieve the sense.&n;&t;&t;&t; */
id|ahc_scb_timer_reset
c_func
(paren
id|scb
comma
l_int|5
op_star
l_int|1000000
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_case
id|NO_MATCH
suffix:colon
(brace
multiline_comment|/* Ensure we don&squot;t leave the selection hardware on */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSISEQ
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSISEQ
)paren
op_amp
(paren
id|ENSELI
op_or
id|ENRSELI
op_or
id|ENAUTOATNP
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s:%c:%d: no active SCB for reconnecting &quot;
l_string|&quot;target - issuing BUS DEVICE RESET&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|devinfo.channel
comma
id|devinfo.target
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;SAVED_SCSIID == 0x%x, SAVED_LUN == 0x%x, &quot;
l_string|&quot;ARG_1 == 0x%x ACCUM = 0x%x&bslash;n&quot;
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SAVED_SCSIID
)paren
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SAVED_LUN
)paren
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|ARG_1
)paren
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|ACCUM
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;SEQ_FLAGS == 0x%x, SCBPTR == 0x%x, BTT == 0x%x, &quot;
l_string|&quot;SINDEX == 0x%x&bslash;n&quot;
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SEQ_FLAGS
)paren
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCBPTR
)paren
comma
id|ahc_index_busy_tcl
c_func
(paren
id|ahc
comma
id|BUILD_TCL
c_func
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SAVED_SCSIID
)paren
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SAVED_LUN
)paren
)paren
)paren
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SINDEX
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;SCSIID == 0x%x, SCB_SCSIID == 0x%x, SCB_LUN == 0x%x, &quot;
l_string|&quot;SCB_TAG == 0x%x, SCB_CONTROL == 0x%x&bslash;n&quot;
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSIID
)paren
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_SCSIID
)paren
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_LUN
)paren
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_TAG
)paren
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_CONTROL
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;SCSIBUSL == 0x%x, SCSISIGI == 0x%x&bslash;n&quot;
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSIBUSL
)paren
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSISIGI
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;SXFRCTL0 == 0x%x&bslash;n&quot;
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SXFRCTL0
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;SEQCTL == 0x%x&bslash;n&quot;
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SEQCTL
)paren
)paren
suffix:semicolon
id|ahc_dump_card_state
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc-&gt;msgout_buf
(braket
l_int|0
)braket
op_assign
id|MSG_BUS_DEV_RESET
suffix:semicolon
id|ahc-&gt;msgout_len
op_assign
l_int|1
suffix:semicolon
id|ahc-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|ahc-&gt;msg_type
op_assign
id|MSG_TYPE_INITIATOR_MSGOUT
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|MSG_OUT
comma
id|HOST_MSG
)paren
suffix:semicolon
id|ahc_assert_atn
c_func
(paren
id|ahc
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|SEND_REJECT
suffix:colon
(brace
id|u_int
id|rejbyte
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|ACCUM
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s:%c:%d: Warning - unknown message received from &quot;
l_string|&quot;target (0x%x).  Rejecting&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|devinfo.channel
comma
id|devinfo.target
comma
id|rejbyte
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|PROTO_VIOLATION
suffix:colon
(brace
id|ahc_handle_proto_violation
c_func
(paren
id|ahc
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|IGN_WIDE_RES
suffix:colon
id|ahc_handle_ign_wide_residue
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PDATA_REINIT
suffix:colon
id|ahc_reinitialize_dataptrs
c_func
(paren
id|ahc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BAD_PHASE
suffix:colon
(brace
id|u_int
id|lastphase
suffix:semicolon
id|lastphase
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|LASTPHASE
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s:%c:%d: unknown scsi bus phase %x, &quot;
l_string|&quot;lastphase = 0x%x.  Attempting to continue&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|devinfo.channel
comma
id|devinfo.target
comma
id|lastphase
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSISIGI
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MISSED_BUSFREE
suffix:colon
(brace
id|u_int
id|lastphase
suffix:semicolon
id|lastphase
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|LASTPHASE
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s:%c:%d: Missed busfree. &quot;
l_string|&quot;Lastphase = 0x%x, Curphase = 0x%x&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|devinfo.channel
comma
id|devinfo.target
comma
id|lastphase
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSISIGI
)paren
)paren
suffix:semicolon
id|ahc_restart
c_func
(paren
id|ahc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_case
id|HOST_MSG_LOOP
suffix:colon
(brace
multiline_comment|/*&n;&t;&t; * The sequencer has encountered a message phase&n;&t;&t; * that requires host assistance for completion.&n;&t;&t; * While handling the message phase(s), we will be&n;&t;&t; * notified by the sequencer after each byte is&n;&t;&t; * transfered so we can track bus phase changes.&n;&t;&t; *&n;&t;&t; * If this is the first time we&squot;ve seen a HOST_MSG_LOOP&n;&t;&t; * interrupt, initialize the state of the host message&n;&t;&t; * loop.&n;&t;&t; */
r_if
c_cond
(paren
id|ahc-&gt;msg_type
op_eq
id|MSG_TYPE_NONE
)paren
(brace
r_struct
id|scb
op_star
id|scb
suffix:semicolon
id|u_int
id|scb_index
suffix:semicolon
id|u_int
id|bus_phase
suffix:semicolon
id|bus_phase
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSISIGI
)paren
op_amp
id|PHASE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|bus_phase
op_ne
id|P_MESGIN
op_logical_and
id|bus_phase
op_ne
id|P_MESGOUT
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;ahc_intr: HOST_MSG_LOOP bad &quot;
l_string|&quot;phase 0x%x&bslash;n&quot;
comma
id|bus_phase
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Probably transitioned to bus free before&n;&t;&t;&t;&t; * we got here.  Just punt the message.&n;&t;&t;&t;&t; */
id|ahc_clear_intstat
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_restart
c_func
(paren
id|ahc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|scb_index
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_TAG
)paren
suffix:semicolon
id|scb
op_assign
id|ahc_lookup_scb
c_func
(paren
id|ahc
comma
id|scb_index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devinfo.role
op_eq
id|ROLE_INITIATOR
)paren
(brace
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;HOST_MSG_LOOP with &quot;
l_string|&quot;invalid SCB %x&bslash;n&quot;
comma
id|scb_index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bus_phase
op_eq
id|P_MESGOUT
)paren
id|ahc_setup_initiator_msgout
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
comma
id|scb
)paren
suffix:semicolon
r_else
(brace
id|ahc-&gt;msg_type
op_assign
id|MSG_TYPE_INITIATOR_MSGIN
suffix:semicolon
id|ahc-&gt;msgin_index
op_assign
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#if AHC_TARGET_MODE
r_else
(brace
r_if
c_cond
(paren
id|bus_phase
op_eq
id|P_MESGOUT
)paren
(brace
id|ahc-&gt;msg_type
op_assign
id|MSG_TYPE_TARGET_MSGOUT
suffix:semicolon
id|ahc-&gt;msgin_index
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|ahc_setup_target_msgin
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
comma
id|scb
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
id|ahc_handle_message_phase
c_func
(paren
id|ahc
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|PERR_DETECTED
suffix:colon
(brace
multiline_comment|/*&n;&t;&t; * If we&squot;ve cleared the parity error interrupt&n;&t;&t; * but the sequencer still believes that SCSIPERR&n;&t;&t; * is true, it must be that the parity error is&n;&t;&t; * for the currently presented byte on the bus,&n;&t;&t; * and we are not in a phase (data-in) where we will&n;&t;&t; * eventually ack this byte.  Ack the byte and&n;&t;&t; * throw it away in the hope that the target will&n;&t;&t; * take us to message out to deliver the appropriate&n;&t;&t; * error message.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|intstat
op_amp
id|SCSIINT
)paren
op_eq
l_int|0
op_logical_and
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SSTAT1
)paren
op_amp
id|SCSIPERR
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_DT
)paren
op_eq
l_int|0
)paren
(brace
id|u_int
id|curphase
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * The hardware will only let you ack bytes&n;&t;&t;&t;&t; * if the expected phase in SCSISIGO matches&n;&t;&t;&t;&t; * the current phase.  Make sure this is&n;&t;&t;&t;&t; * currently the case.&n;&t;&t;&t;&t; */
id|curphase
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSISIGI
)paren
op_amp
id|PHASE_MASK
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|LASTPHASE
comma
id|curphase
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSISIGO
comma
id|curphase
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSISIGI
)paren
op_amp
(paren
id|CDI
op_or
id|MSGI
)paren
)paren
op_eq
l_int|0
)paren
(brace
r_int
id|wait
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * In a data phase.  Faster to bitbucket&n;&t;&t;&t;&t; * the data than to individually ack each&n;&t;&t;&t;&t; * byte.  This is also the only strategy&n;&t;&t;&t;&t; * that will work with AUTOACK enabled.&n;&t;&t;&t;&t; */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SXFRCTL1
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SXFRCTL1
)paren
op_or
id|BITBUCKET
)paren
suffix:semicolon
id|wait
op_assign
l_int|5000
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|wait
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSISIGI
)paren
op_amp
(paren
id|CDI
op_or
id|MSGI
)paren
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
id|ahc_delay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SXFRCTL1
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SXFRCTL1
)paren
op_amp
op_complement
id|BITBUCKET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait
op_eq
l_int|0
)paren
(brace
r_struct
id|scb
op_star
id|scb
suffix:semicolon
id|u_int
id|scb_index
suffix:semicolon
id|ahc_print_devinfo
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Unable to clear parity error.  &quot;
l_string|&quot;Resetting bus.&bslash;n&quot;
)paren
suffix:semicolon
id|scb_index
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_TAG
)paren
suffix:semicolon
id|scb
op_assign
id|ahc_lookup_scb
c_func
(paren
id|ahc
comma
id|scb_index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_ne
l_int|NULL
)paren
id|ahc_set_transaction_status
c_func
(paren
id|scb
comma
id|CAM_UNCOR_PARITY
)paren
suffix:semicolon
id|ahc_reset_channel
c_func
(paren
id|ahc
comma
id|devinfo.channel
comma
multiline_comment|/*init reset*/
id|TRUE
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSIDATL
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
r_case
id|DATA_OVERRUN
suffix:colon
(brace
multiline_comment|/*&n;&t;&t; * When the sequencer detects an overrun, it&n;&t;&t; * places the controller in &quot;BITBUCKET&quot; mode&n;&t;&t; * and allows the target to complete its transfer.&n;&t;&t; * Unfortunately, none of the counters get updated&n;&t;&t; * when the controller is in this mode, so we have&n;&t;&t; * no way of knowing how large the overrun was.&n;&t;&t; */
id|u_int
id|scbindex
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_TAG
)paren
suffix:semicolon
id|u_int
id|lastphase
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|LASTPHASE
)paren
suffix:semicolon
id|u_int
id|i
suffix:semicolon
id|scb
op_assign
id|ahc_lookup_scb
c_func
(paren
id|ahc
comma
id|scbindex
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_phases
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|lastphase
op_eq
id|ahc_phase_table
(braket
id|i
)braket
dot
id|phase
)paren
r_break
suffix:semicolon
)brace
id|ahc_print_path
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;data overrun detected %s.&quot;
l_string|&quot;  Tag == 0x%x.&bslash;n&quot;
comma
id|ahc_phase_table
(braket
id|i
)braket
dot
id|phasemsg
comma
id|scb-&gt;hscb-&gt;tag
)paren
suffix:semicolon
id|ahc_print_path
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s seen Data Phase.  Length = %ld.  NumSGs = %d.&bslash;n&quot;
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SEQ_FLAGS
)paren
op_amp
id|DPHASE
ques
c_cond
l_string|&quot;Have&quot;
suffix:colon
l_string|&quot;Haven&squot;t&quot;
comma
id|ahc_get_transfer_length
c_func
(paren
id|scb
)paren
comma
id|scb-&gt;sg_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb-&gt;sg_count
OG
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|scb-&gt;sg_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;sg[%d] - Addr 0x%x%x : Length %d&bslash;n&quot;
comma
id|i
comma
(paren
id|ahc_le32toh
c_func
(paren
id|scb-&gt;sg_list
(braket
id|i
)braket
dot
id|len
)paren
op_rshift
l_int|24
op_amp
id|SG_HIGH_ADDR_BITS
)paren
comma
id|ahc_le32toh
c_func
(paren
id|scb-&gt;sg_list
(braket
id|i
)braket
dot
id|addr
)paren
comma
id|ahc_le32toh
c_func
(paren
id|scb-&gt;sg_list
(braket
id|i
)braket
dot
id|len
)paren
op_amp
id|AHC_SG_LEN_MASK
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Set this and it will take effect when the&n;&t;&t; * target does a command complete.&n;&t;&t; */
id|ahc_freeze_devq
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_SENSE
)paren
op_eq
l_int|0
)paren
(brace
id|ahc_set_transaction_status
c_func
(paren
id|scb
comma
id|CAM_DATA_RUN_ERR
)paren
suffix:semicolon
)brace
r_else
(brace
id|scb-&gt;flags
op_and_assign
op_complement
id|SCB_SENSE
suffix:semicolon
id|ahc_set_transaction_status
c_func
(paren
id|scb
comma
id|CAM_AUTOSENSE_FAIL
)paren
suffix:semicolon
)brace
id|ahc_freeze_scb
c_func
(paren
id|scb
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Clear the channel in case we return&n;&t;&t;&t; * to data phase later.&n;&t;&t;&t; */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SXFRCTL0
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SXFRCTL0
)paren
op_or
id|CLRSTCNT
op_or
id|CLRCHN
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SXFRCTL0
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SXFRCTL0
)paren
op_or
id|CLRSTCNT
op_or
id|CLRCHN
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ahc-&gt;flags
op_amp
id|AHC_39BIT_ADDRESSING
)paren
op_ne
l_int|0
)paren
(brace
id|u_int
id|dscommand1
suffix:semicolon
multiline_comment|/* Ensure HHADDR is 0 for future DMA operations. */
id|dscommand1
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|DSCOMMAND1
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|DSCOMMAND1
comma
id|dscommand1
op_or
id|HADDLDSEL0
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|HADDR
comma
l_int|0
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|DSCOMMAND1
comma
id|dscommand1
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_case
id|MKMSG_FAILED
suffix:colon
(brace
id|u_int
id|scbindex
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s:%c:%d:%d: Attempt to issue message failed&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|devinfo.channel
comma
id|devinfo.target
comma
id|devinfo.lun
)paren
suffix:semicolon
id|scbindex
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_TAG
)paren
suffix:semicolon
id|scb
op_assign
id|ahc_lookup_scb
c_func
(paren
id|ahc
comma
id|scbindex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_ne
l_int|NULL
op_logical_and
(paren
id|scb-&gt;flags
op_amp
id|SCB_RECOVERY_SCB
)paren
op_ne
l_int|0
)paren
multiline_comment|/*&n;&t;&t;&t; * Ensure that we didn&squot;t put a second instance of this&n;&t;&t;&t; * SCB into the QINFIFO.&n;&t;&t;&t; */
id|ahc_search_qinfifo
c_func
(paren
id|ahc
comma
id|SCB_GET_TARGET
c_func
(paren
id|ahc
comma
id|scb
)paren
comma
id|SCB_GET_CHANNEL
c_func
(paren
id|ahc
comma
id|scb
)paren
comma
id|SCB_GET_LUN
c_func
(paren
id|scb
)paren
comma
id|scb-&gt;hscb-&gt;tag
comma
id|ROLE_INITIATOR
comma
multiline_comment|/*status*/
l_int|0
comma
id|SEARCH_REMOVE
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|NO_FREE_SCB
suffix:colon
(brace
id|printf
c_func
(paren
l_string|&quot;%s: No free or disconnected SCBs&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
)paren
suffix:semicolon
id|ahc_dump_card_state
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;for safety&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|SCB_MISMATCH
suffix:colon
(brace
id|u_int
id|scbptr
suffix:semicolon
id|scbptr
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCBPTR
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Bogus TAG after DMA.  SCBPTR %d, tag %d, our tag %d&bslash;n&quot;
comma
id|scbptr
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|ARG_1
)paren
comma
id|ahc-&gt;scb_data-&gt;hscbs
(braket
id|scbptr
)braket
dot
id|tag
)paren
suffix:semicolon
id|ahc_dump_card_state
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;for saftey&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|OUT_OF_RANGE
suffix:colon
(brace
id|printf
c_func
(paren
l_string|&quot;%s: BTT calculation out of range&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;SAVED_SCSIID == 0x%x, SAVED_LUN == 0x%x, &quot;
l_string|&quot;ARG_1 == 0x%x ACCUM = 0x%x&bslash;n&quot;
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SAVED_SCSIID
)paren
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SAVED_LUN
)paren
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|ARG_1
)paren
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|ACCUM
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;SEQ_FLAGS == 0x%x, SCBPTR == 0x%x, BTT == 0x%x, &quot;
l_string|&quot;SINDEX == 0x%x&bslash;n, A == 0x%x&bslash;n&quot;
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SEQ_FLAGS
)paren
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCBPTR
)paren
comma
id|ahc_index_busy_tcl
c_func
(paren
id|ahc
comma
id|BUILD_TCL
c_func
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SAVED_SCSIID
)paren
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SAVED_LUN
)paren
)paren
)paren
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SINDEX
)paren
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|ACCUM
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;SCSIID == 0x%x, SCB_SCSIID == 0x%x, SCB_LUN == 0x%x, &quot;
l_string|&quot;SCB_TAG == 0x%x, SCB_CONTROL == 0x%x&bslash;n&quot;
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSIID
)paren
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_SCSIID
)paren
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_LUN
)paren
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_TAG
)paren
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_CONTROL
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;SCSIBUSL == 0x%x, SCSISIGI == 0x%x&bslash;n&quot;
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSIBUSL
)paren
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSISIGI
)paren
)paren
suffix:semicolon
id|ahc_dump_card_state
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;for safety&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
id|printf
c_func
(paren
l_string|&quot;ahc_intr: seqint, &quot;
l_string|&quot;intstat == 0x%x, scsisigi = 0x%x&bslash;n&quot;
comma
id|intstat
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSISIGI
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|unpause
suffix:colon
multiline_comment|/*&n;&t; *  The sequencer is paused immediately on&n;&t; *  a SEQINT, so we should restart it when&n;&t; *  we&squot;re done.&n;&t; */
id|ahc_unpause
c_func
(paren
id|ahc
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahc_handle_scsiint
id|ahc_handle_scsiint
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|u_int
id|intstat
)paren
(brace
id|u_int
id|scb_index
suffix:semicolon
id|u_int
id|status0
suffix:semicolon
id|u_int
id|status
suffix:semicolon
r_struct
id|scb
op_star
id|scb
suffix:semicolon
r_char
id|cur_channel
suffix:semicolon
r_char
id|intr_channel
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_TWIN
)paren
op_ne
l_int|0
op_logical_and
(paren
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SBLKCTL
)paren
op_amp
id|SELBUSB
)paren
op_ne
l_int|0
)paren
)paren
id|cur_channel
op_assign
l_char|&squot;B&squot;
suffix:semicolon
r_else
id|cur_channel
op_assign
l_char|&squot;A&squot;
suffix:semicolon
id|intr_channel
op_assign
id|cur_channel
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_ne
l_int|0
)paren
id|status0
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SSTAT0
)paren
op_amp
id|IOERR
suffix:semicolon
r_else
id|status0
op_assign
l_int|0
suffix:semicolon
id|status
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SSTAT1
)paren
op_amp
(paren
id|SELTO
op_or
id|SCSIRSTI
op_or
id|BUSFREE
op_or
id|SCSIPERR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
l_int|0
op_logical_and
id|status0
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_TWIN
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Try the other channel */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SBLKCTL
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SBLKCTL
)paren
op_xor
id|SELBUSB
)paren
suffix:semicolon
id|status
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SSTAT1
)paren
op_amp
(paren
id|SELTO
op_or
id|SCSIRSTI
op_or
id|BUSFREE
op_or
id|SCSIPERR
)paren
suffix:semicolon
id|intr_channel
op_assign
(paren
id|cur_channel
op_eq
l_char|&squot;A&squot;
)paren
ques
c_cond
l_char|&squot;B&squot;
suffix:colon
l_char|&squot;A&squot;
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: Spurious SCSI interrupt&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CLRINT
comma
id|CLRSCSIINT
)paren
suffix:semicolon
id|ahc_unpause
c_func
(paren
id|ahc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* Make sure the sequencer is in a safe location. */
id|ahc_clear_critical_section
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|scb_index
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_TAG
)paren
suffix:semicolon
id|scb
op_assign
id|ahc_lookup_scb
c_func
(paren
id|ahc
comma
id|scb_index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_ne
l_int|NULL
op_logical_and
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SEQ_FLAGS
)paren
op_amp
id|NOT_IDENTIFIED
)paren
op_ne
l_int|0
)paren
id|scb
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_ne
l_int|0
op_logical_and
(paren
id|status0
op_amp
id|IOERR
)paren
op_ne
l_int|0
)paren
(brace
r_int
id|now_lvd
suffix:semicolon
id|now_lvd
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SBLKCTL
)paren
op_amp
id|ENAB40
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s: Transceiver State Has Changed to %s mode&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|now_lvd
ques
c_cond
l_string|&quot;LVD&quot;
suffix:colon
l_string|&quot;SE&quot;
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CLRSINT0
comma
id|CLRIOERR
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * When transitioning to SE mode, the reset line&n;&t;&t; * glitches, triggering an arbitration bug in some&n;&t;&t; * Ultra2 controllers.  This bug is cleared when we&n;&t;&t; * assert the reset line.  Since a reset glitch has&n;&t;&t; * already occurred with this transition and a&n;&t;&t; * transceiver state change is handled just like&n;&t;&t; * a bus reset anyway, asserting the reset line&n;&t;&t; * ourselves is safe.&n;&t;&t; */
id|ahc_reset_channel
c_func
(paren
id|ahc
comma
id|intr_channel
comma
multiline_comment|/*Initiate Reset*/
id|now_lvd
op_eq
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|status
op_amp
id|SCSIRSTI
)paren
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: Someone reset channel %c&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|intr_channel
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intr_channel
op_ne
id|cur_channel
)paren
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SBLKCTL
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SBLKCTL
)paren
op_xor
id|SELBUSB
)paren
suffix:semicolon
id|ahc_reset_channel
c_func
(paren
id|ahc
comma
id|intr_channel
comma
multiline_comment|/*Initiate Reset*/
id|FALSE
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|status
op_amp
id|SCSIPERR
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Determine the bus phase and queue an appropriate message.&n;&t;&t; * SCSIPERR is latched true as soon as a parity error&n;&t;&t; * occurs.  If the sequencer acked the transfer that&n;&t;&t; * caused the parity error and the currently presented&n;&t;&t; * transfer on the bus has correct parity, SCSIPERR will&n;&t;&t; * be cleared by CLRSCSIPERR.  Use this to determine if&n;&t;&t; * we should look at the last phase the sequencer recorded,&n;&t;&t; * or the current phase presented on the bus.&n;&t;&t; */
id|u_int
id|mesg_out
suffix:semicolon
id|u_int
id|curphase
suffix:semicolon
id|u_int
id|errorphase
suffix:semicolon
id|u_int
id|lastphase
suffix:semicolon
id|u_int
id|scsirate
suffix:semicolon
id|u_int
id|i
suffix:semicolon
id|u_int
id|sstat2
suffix:semicolon
r_int
id|silent
suffix:semicolon
id|lastphase
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|LASTPHASE
)paren
suffix:semicolon
id|curphase
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSISIGI
)paren
op_amp
id|PHASE_MASK
suffix:semicolon
id|sstat2
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SSTAT2
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CLRSINT1
comma
id|CLRSCSIPERR
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * For all phases save DATA, the sequencer won&squot;t&n;&t;&t; * automatically ack a byte that has a parity error&n;&t;&t; * in it.  So the only way that the current phase&n;&t;&t; * could be &squot;data-in&squot; is if the parity error is for&n;&t;&t; * an already acked byte in the data phase.  During&n;&t;&t; * synchronous data-in transfers, we may actually&n;&t;&t; * ack bytes before latching the current phase in&n;&t;&t; * LASTPHASE, leading to the discrepancy between&n;&t;&t; * curphase and lastphase.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SSTAT1
)paren
op_amp
id|SCSIPERR
)paren
op_ne
l_int|0
op_logical_or
id|curphase
op_eq
id|P_DATAIN
op_logical_or
id|curphase
op_eq
id|P_DATAIN_DT
)paren
id|errorphase
op_assign
id|curphase
suffix:semicolon
r_else
id|errorphase
op_assign
id|lastphase
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_phases
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|errorphase
op_eq
id|ahc_phase_table
(braket
id|i
)braket
dot
id|phase
)paren
r_break
suffix:semicolon
)brace
id|mesg_out
op_assign
id|ahc_phase_table
(braket
id|i
)braket
dot
id|mesg_out
suffix:semicolon
id|silent
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|SCB_IS_SILENT
c_func
(paren
id|scb
)paren
)paren
id|silent
op_assign
id|TRUE
suffix:semicolon
r_else
id|ahc_print_path
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_TRANSMISSION_ERROR
suffix:semicolon
)brace
r_else
id|printf
c_func
(paren
l_string|&quot;%s:%c:%d: &quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|intr_channel
comma
id|SCSIID_TARGET
c_func
(paren
id|ahc
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SAVED_SCSIID
)paren
)paren
)paren
suffix:semicolon
id|scsirate
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSIRATE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|silent
op_eq
id|FALSE
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;parity error detected %s. &quot;
l_string|&quot;SEQADDR(0x%x) SCSIRATE(0x%x)&bslash;n&quot;
comma
id|ahc_phase_table
(braket
id|i
)braket
dot
id|phasemsg
comma
id|ahc_inw
c_func
(paren
id|ahc
comma
id|SEQADDR0
)paren
comma
id|scsirate
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_DT
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|sstat2
op_amp
id|CRCVALERR
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;tCRC Value Mismatch&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sstat2
op_amp
id|CRCENDERR
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;tNo terminal CRC packet &quot;
l_string|&quot;recevied&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sstat2
op_amp
id|CRCREQERR
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;tIllegal CRC packet &quot;
l_string|&quot;request&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sstat2
op_amp
id|DUAL_EDGE_ERR
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;tUnexpected %sDT Data Phase&bslash;n&quot;
comma
(paren
id|scsirate
op_amp
id|SINGLE_EDGE
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;non-&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_DT
)paren
op_ne
l_int|0
op_logical_and
(paren
id|sstat2
op_amp
id|DUAL_EDGE_ERR
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * This error applies regardless of&n;&t;&t;&t; * data direction, so ignore the value&n;&t;&t;&t; * in the phase table.&n;&t;&t;&t; */
id|mesg_out
op_assign
id|MSG_INITIATOR_DET_ERR
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * We&squot;ve set the hardware to assert ATN if we   &n;&t;&t; * get a parity error on &quot;in&quot; phases, so all we  &n;&t;&t; * need to do is stuff the message buffer with&n;&t;&t; * the appropriate message.  &quot;In&quot; phases have set&n;&t;&t; * mesg_out to something other than MSG_NOP.&n;&t;&t; */
r_if
c_cond
(paren
id|mesg_out
op_ne
id|MSG_NOOP
)paren
(brace
r_if
c_cond
(paren
id|ahc-&gt;msg_type
op_ne
id|MSG_TYPE_NONE
)paren
id|ahc-&gt;send_msg_perror
op_assign
id|TRUE
suffix:semicolon
r_else
id|ahc_outb
c_func
(paren
id|ahc
comma
id|MSG_OUT
comma
id|mesg_out
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Force a renegotiation with this target just in&n;&t;&t; * case we are out of sync for some external reason&n;&t;&t; * unknown (or unreported) by the target.&n;&t;&t; */
id|ahc_force_renegotiation
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CLRINT
comma
id|CLRSCSIINT
)paren
suffix:semicolon
id|ahc_unpause
c_func
(paren
id|ahc
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|status
op_amp
id|SELTO
)paren
op_ne
l_int|0
)paren
(brace
id|u_int
id|scbptr
suffix:semicolon
multiline_comment|/* Stop the selection */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSISEQ
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* No more pending messages */
id|ahc_clear_msg_state
c_func
(paren
id|ahc
)paren
suffix:semicolon
multiline_comment|/* Clear interrupt state */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SIMODE1
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SIMODE1
)paren
op_amp
op_complement
id|ENBUSFREE
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CLRSINT1
comma
id|CLRSELTIMEO
op_or
id|CLRBUSFREE
op_or
id|CLRSCSIPERR
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Although the driver does not care about the&n;&t;&t; * &squot;Selection in Progress&squot; status bit, the busy&n;&t;&t; * LED does.  SELINGO is only cleared by a sucessfull&n;&t;&t; * selection, so we must manually clear it to insure&n;&t;&t; * the LED turns off just incase no future successful&n;&t;&t; * selections occur (e.g. no devices on the bus).&n;&t;&t; */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CLRSINT0
comma
id|CLRSELINGO
)paren
suffix:semicolon
id|scbptr
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|WAITING_SCBH
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBPTR
comma
id|scbptr
)paren
suffix:semicolon
id|scb_index
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_TAG
)paren
suffix:semicolon
id|scb
op_assign
id|ahc_lookup_scb
c_func
(paren
id|ahc
comma
id|scb_index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: ahc_intr - referenced scb not &quot;
l_string|&quot;valid during SELTO scb(%d, %d)&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|scbptr
comma
id|scb_index
)paren
suffix:semicolon
id|ahc_dump_card_state
c_func
(paren
id|ahc
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Force a renegotiation with this target just in&n;&t;&t;&t; * case the cable was pulled and will later be&n;&t;&t;&t; * re-attached.  The target may forget its negotiation&n;&t;&t;&t; * settings with us should it attempt to reselect&n;&t;&t;&t; * during the interruption.  The target will not issue&n;&t;&t;&t; * a unit attention in this case, so we must always&n;&t;&t;&t; * renegotiate.&n;&t;&t;&t; */
id|ahc_force_renegotiation
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_set_transaction_status
c_func
(paren
id|scb
comma
id|CAM_SEL_TIMEOUT
)paren
suffix:semicolon
id|ahc_freeze_devq
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_SELTO
)paren
op_ne
l_int|0
)paren
(brace
id|ahc_print_path
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Saw Selection Timeout for SCB 0x%x&bslash;n&quot;
comma
id|scb_index
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CLRINT
comma
id|CLRSCSIINT
)paren
suffix:semicolon
id|ahc_restart
c_func
(paren
id|ahc
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|status
op_amp
id|BUSFREE
)paren
op_ne
l_int|0
op_logical_and
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SIMODE1
)paren
op_amp
id|ENBUSFREE
)paren
op_ne
l_int|0
)paren
(brace
id|u_int
id|lastphase
suffix:semicolon
id|u_int
id|saved_scsiid
suffix:semicolon
id|u_int
id|saved_lun
suffix:semicolon
id|u_int
id|target
suffix:semicolon
id|u_int
id|initiator_role_id
suffix:semicolon
r_char
id|channel
suffix:semicolon
r_int
id|printerror
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Clear our selection hardware as soon as possible.&n;&t;&t; * We may have an entry in the waiting Q for this target,&n;&t;&t; * that is affected by this busfree and we don&squot;t want to&n;&t;&t; * go about selecting the target while we handle the event.&n;&t;&t; */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSISEQ
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSISEQ
)paren
op_amp
(paren
id|ENSELI
op_or
id|ENRSELI
op_or
id|ENAUTOATNP
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Disable busfree interrupts and clear the busfree&n;&t;&t; * interrupt status.  We do this here so that several&n;&t;&t; * bus transactions occur prior to clearing the SCSIINT&n;&t;&t; * latch.  It can take a bit for the clearing to take effect.&n;&t;&t; */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SIMODE1
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SIMODE1
)paren
op_amp
op_complement
id|ENBUSFREE
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CLRSINT1
comma
id|CLRBUSFREE
op_or
id|CLRSCSIPERR
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Look at what phase we were last in.&n;&t;&t; * If its message out, chances are pretty good&n;&t;&t; * that the busfree was in response to one of&n;&t;&t; * our abort requests.&n;&t;&t; */
id|lastphase
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|LASTPHASE
)paren
suffix:semicolon
id|saved_scsiid
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SAVED_SCSIID
)paren
suffix:semicolon
id|saved_lun
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SAVED_LUN
)paren
suffix:semicolon
id|target
op_assign
id|SCSIID_TARGET
c_func
(paren
id|ahc
comma
id|saved_scsiid
)paren
suffix:semicolon
id|initiator_role_id
op_assign
id|SCSIID_OUR_ID
c_func
(paren
id|saved_scsiid
)paren
suffix:semicolon
id|channel
op_assign
id|SCSIID_CHANNEL
c_func
(paren
id|ahc
comma
id|saved_scsiid
)paren
suffix:semicolon
id|printerror
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|lastphase
op_eq
id|P_MESGOUT
)paren
(brace
r_struct
id|ahc_devinfo
id|devinfo
suffix:semicolon
id|u_int
id|tag
suffix:semicolon
id|ahc_fetch_devinfo
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
)paren
suffix:semicolon
id|tag
op_assign
id|SCB_LIST_NULL
suffix:semicolon
r_if
c_cond
(paren
id|ahc_sent_msg
c_func
(paren
id|ahc
comma
id|AHCMSG_1B
comma
id|MSG_ABORT_TAG
comma
id|TRUE
)paren
op_logical_or
id|ahc_sent_msg
c_func
(paren
id|ahc
comma
id|AHCMSG_1B
comma
id|MSG_ABORT
comma
id|TRUE
)paren
)paren
(brace
r_if
c_cond
(paren
id|ahc-&gt;msgout_buf
(braket
id|ahc-&gt;msgout_index
op_minus
l_int|1
)braket
op_eq
id|MSG_ABORT_TAG
)paren
id|tag
op_assign
id|scb-&gt;hscb-&gt;tag
suffix:semicolon
id|ahc_print_path
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;SCB %d - Abort%s Completed.&bslash;n&quot;
comma
id|scb-&gt;hscb-&gt;tag
comma
id|tag
op_eq
id|SCB_LIST_NULL
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot; Tag&quot;
)paren
suffix:semicolon
id|ahc_abort_scbs
c_func
(paren
id|ahc
comma
id|target
comma
id|channel
comma
id|saved_lun
comma
id|tag
comma
id|ROLE_INITIATOR
comma
id|CAM_REQ_ABORTED
)paren
suffix:semicolon
id|printerror
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ahc_sent_msg
c_func
(paren
id|ahc
comma
id|AHCMSG_1B
comma
id|MSG_BUS_DEV_RESET
comma
id|TRUE
)paren
)paren
(brace
macro_line|#ifdef __FreeBSD__
multiline_comment|/*&n;&t;&t;&t;&t; * Don&squot;t mark the user&squot;s request for this BDR&n;&t;&t;&t;&t; * as completing with CAM_BDR_SENT.  CAM3&n;&t;&t;&t;&t; * specifies CAM_REQ_CMP.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|scb
op_ne
l_int|NULL
op_logical_and
id|scb-&gt;io_ctx-&gt;ccb_h.func_code
op_eq
id|XPT_RESET_DEV
op_logical_and
id|ahc_match_scb
c_func
(paren
id|ahc
comma
id|scb
comma
id|target
comma
id|channel
comma
id|CAM_LUN_WILDCARD
comma
id|SCB_LIST_NULL
comma
id|ROLE_INITIATOR
)paren
)paren
(brace
id|ahc_set_transaction_status
c_func
(paren
id|scb
comma
id|CAM_REQ_CMP
)paren
suffix:semicolon
)brace
macro_line|#endif
id|ahc_compile_devinfo
c_func
(paren
op_amp
id|devinfo
comma
id|initiator_role_id
comma
id|target
comma
id|CAM_LUN_WILDCARD
comma
id|channel
comma
id|ROLE_INITIATOR
)paren
suffix:semicolon
id|ahc_handle_devreset
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
comma
id|CAM_BDR_SENT
comma
l_string|&quot;Bus Device Reset&quot;
comma
multiline_comment|/*verbose_level*/
l_int|0
)paren
suffix:semicolon
id|printerror
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ahc_sent_msg
c_func
(paren
id|ahc
comma
id|AHCMSG_EXT
comma
id|MSG_EXT_PPR
comma
id|FALSE
)paren
)paren
(brace
r_struct
id|ahc_initiator_tinfo
op_star
id|tinfo
suffix:semicolon
r_struct
id|ahc_tmode_tstate
op_star
id|tstate
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * PPR Rejected.  Try non-ppr negotiation&n;&t;&t;&t;&t; * and retry command.&n;&t;&t;&t;&t; */
id|tinfo
op_assign
id|ahc_fetch_transinfo
c_func
(paren
id|ahc
comma
id|devinfo.channel
comma
id|devinfo.our_scsiid
comma
id|devinfo.target
comma
op_amp
id|tstate
)paren
suffix:semicolon
id|tinfo-&gt;curr.transport_version
op_assign
l_int|2
suffix:semicolon
id|tinfo-&gt;goal.transport_version
op_assign
l_int|2
suffix:semicolon
id|tinfo-&gt;goal.ppr_options
op_assign
l_int|0
suffix:semicolon
id|ahc_qinfifo_requeue_tail
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|printerror
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ahc_sent_msg
c_func
(paren
id|ahc
comma
id|AHCMSG_EXT
comma
id|MSG_EXT_WDTR
comma
id|FALSE
)paren
op_logical_or
id|ahc_sent_msg
c_func
(paren
id|ahc
comma
id|AHCMSG_EXT
comma
id|MSG_EXT_SDTR
comma
id|FALSE
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Negotiation Rejected.  Go-async and&n;&t;&t;&t;&t; * retry command.&n;&t;&t;&t;&t; */
id|ahc_set_width
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
comma
id|MSG_EXT_WDTR_BUS_8_BIT
comma
id|AHC_TRANS_CUR
op_or
id|AHC_TRANS_GOAL
comma
multiline_comment|/*paused*/
id|TRUE
)paren
suffix:semicolon
id|ahc_set_syncrate
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
comma
multiline_comment|/*syncrate*/
l_int|NULL
comma
multiline_comment|/*period*/
l_int|0
comma
multiline_comment|/*offset*/
l_int|0
comma
multiline_comment|/*ppr_options*/
l_int|0
comma
id|AHC_TRANS_CUR
op_or
id|AHC_TRANS_GOAL
comma
multiline_comment|/*paused*/
id|TRUE
)paren
suffix:semicolon
id|ahc_qinfifo_requeue_tail
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|printerror
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|printerror
op_ne
l_int|0
)paren
(brace
id|u_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_ne
l_int|NULL
)paren
(brace
id|u_int
id|tag
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb-&gt;hscb-&gt;control
op_amp
id|TAG_ENB
)paren
op_ne
l_int|0
)paren
id|tag
op_assign
id|scb-&gt;hscb-&gt;tag
suffix:semicolon
r_else
id|tag
op_assign
id|SCB_LIST_NULL
suffix:semicolon
id|ahc_print_path
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|ahc_abort_scbs
c_func
(paren
id|ahc
comma
id|target
comma
id|channel
comma
id|SCB_GET_LUN
c_func
(paren
id|scb
)paren
comma
id|tag
comma
id|ROLE_INITIATOR
comma
id|CAM_UNEXP_BUSFREE
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * We had not fully identified this connection,&n;&t;&t;&t;&t; * so we cannot abort anything.&n;&t;&t;&t;&t; */
id|printf
c_func
(paren
l_string|&quot;%s: &quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_phases
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|lastphase
op_eq
id|ahc_phase_table
(braket
id|i
)braket
dot
id|phase
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Renegotiate with this device at the&n;&t;&t;&t; * next oportunity just in case this busfree&n;&t;&t;&t; * is due to a negotiation mismatch with the&n;&t;&t;&t; * device.&n;&t;&t;&t; */
id|ahc_force_renegotiation
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Unexpected busfree %s&bslash;n&quot;
l_string|&quot;SEQADDR == 0x%x&bslash;n&quot;
comma
id|ahc_phase_table
(braket
id|i
)braket
dot
id|phasemsg
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SEQADDR0
)paren
op_or
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SEQADDR1
)paren
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
)brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CLRINT
comma
id|CLRSCSIINT
)paren
suffix:semicolon
id|ahc_restart
c_func
(paren
id|ahc
)paren
suffix:semicolon
)brace
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;%s: Missing case in ahc_handle_scsiint. status = %x&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|status
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CLRINT
comma
id|CLRSCSIINT
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Force renegotiation to occur the next time we initiate&n; * a command to the current device.&n; */
r_static
r_void
DECL|function|ahc_force_renegotiation
id|ahc_force_renegotiation
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_struct
id|ahc_devinfo
id|devinfo
suffix:semicolon
r_struct
id|ahc_initiator_tinfo
op_star
id|targ_info
suffix:semicolon
r_struct
id|ahc_tmode_tstate
op_star
id|tstate
suffix:semicolon
id|ahc_fetch_devinfo
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
)paren
suffix:semicolon
id|targ_info
op_assign
id|ahc_fetch_transinfo
c_func
(paren
id|ahc
comma
id|devinfo.channel
comma
id|devinfo.our_scsiid
comma
id|devinfo.target
comma
op_amp
id|tstate
)paren
suffix:semicolon
id|ahc_update_neg_request
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
comma
id|tstate
comma
id|targ_info
comma
id|AHC_NEG_IF_NON_ASYNC
)paren
suffix:semicolon
)brace
DECL|macro|AHC_MAX_STEPS
mdefine_line|#define AHC_MAX_STEPS 2000
r_void
DECL|function|ahc_clear_critical_section
id|ahc_clear_critical_section
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_int
id|stepping
suffix:semicolon
r_int
id|steps
suffix:semicolon
id|u_int
id|simode0
suffix:semicolon
id|u_int
id|simode1
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;num_critical_sections
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|stepping
op_assign
id|FALSE
suffix:semicolon
id|steps
op_assign
l_int|0
suffix:semicolon
id|simode0
op_assign
l_int|0
suffix:semicolon
id|simode1
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|cs
op_star
id|cs
suffix:semicolon
id|u_int
id|seqaddr
suffix:semicolon
id|u_int
id|i
suffix:semicolon
id|seqaddr
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SEQADDR0
)paren
op_or
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SEQADDR1
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Seqaddr represents the next instruction to execute, &n;&t;&t; * so we are really executing the instruction just&n;&t;&t; * before it.&n;&t;&t; */
r_if
c_cond
(paren
id|seqaddr
op_ne
l_int|0
)paren
id|seqaddr
op_sub_assign
l_int|1
suffix:semicolon
id|cs
op_assign
id|ahc-&gt;critical_sections
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ahc-&gt;num_critical_sections
suffix:semicolon
id|i
op_increment
comma
id|cs
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cs-&gt;begin
OL
id|seqaddr
op_logical_and
id|cs-&gt;end
op_ge
id|seqaddr
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|ahc-&gt;num_critical_sections
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|steps
OG
id|AHC_MAX_STEPS
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: Infinite loop in critical section&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
)paren
suffix:semicolon
id|ahc_dump_card_state
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;critical section loop&quot;
)paren
suffix:semicolon
)brace
id|steps
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|stepping
op_eq
id|FALSE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Disable all interrupt sources so that the&n;&t;&t;&t; * sequencer will not be stuck by a pausing&n;&t;&t;&t; * interrupt condition while we attempt to&n;&t;&t;&t; * leave a critical section.&n;&t;&t;&t; */
id|simode0
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SIMODE0
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SIMODE0
comma
l_int|0
)paren
suffix:semicolon
id|simode1
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SIMODE1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_DT
)paren
op_ne
l_int|0
)paren
multiline_comment|/*&n;&t;&t;&t;&t; * On DT class controllers, we&n;&t;&t;&t;&t; * use the enhanced busfree logic.&n;&t;&t;&t;&t; * Unfortunately we cannot re-enable&n;&t;&t;&t;&t; * busfree detection within the&n;&t;&t;&t;&t; * current connection, so we must&n;&t;&t;&t;&t; * leave it on while single stepping.&n;&t;&t;&t;&t; */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SIMODE1
comma
id|ENBUSFREE
)paren
suffix:semicolon
r_else
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SIMODE1
comma
l_int|0
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CLRINT
comma
id|CLRSCSIINT
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SEQCTL
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SEQCTL
)paren
op_or
id|STEP
)paren
suffix:semicolon
id|stepping
op_assign
id|TRUE
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_DT
)paren
op_ne
l_int|0
)paren
(brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CLRSINT1
comma
id|CLRBUSFREE
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CLRINT
comma
id|CLRSCSIINT
)paren
suffix:semicolon
)brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|HCNTRL
comma
id|ahc-&gt;unpause
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|ahc_is_paused
c_func
(paren
id|ahc
)paren
)paren
id|ahc_delay
c_func
(paren
l_int|200
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stepping
)paren
(brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SIMODE0
comma
id|simode0
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SIMODE1
comma
id|simode1
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SEQCTL
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SEQCTL
)paren
op_amp
op_complement
id|STEP
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Clear any pending interrupt status.&n; */
r_void
DECL|function|ahc_clear_intstat
id|ahc_clear_intstat
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
multiline_comment|/* Clear any interrupt conditions this may have caused */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CLRSINT1
comma
id|CLRSELTIMEO
op_or
id|CLRATNO
op_or
id|CLRSCSIRSTI
op_or
id|CLRBUSFREE
op_or
id|CLRSCSIPERR
op_or
id|CLRPHASECHG
op_or
id|CLRREQINIT
)paren
suffix:semicolon
id|ahc_flush_device_writes
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CLRSINT0
comma
id|CLRSELDO
op_or
id|CLRSELDI
op_or
id|CLRSELINGO
)paren
suffix:semicolon
id|ahc_flush_device_writes
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CLRINT
comma
id|CLRSCSIINT
)paren
suffix:semicolon
id|ahc_flush_device_writes
c_func
(paren
id|ahc
)paren
suffix:semicolon
)brace
multiline_comment|/**************************** Debugging Routines ******************************/
macro_line|#ifdef AHC_DEBUG
DECL|variable|ahc_debug
r_uint32
id|ahc_debug
op_assign
id|AHC_DEBUG_OPTS
suffix:semicolon
macro_line|#endif
r_void
DECL|function|ahc_print_scb
id|ahc_print_scb
c_func
(paren
r_struct
id|scb
op_star
id|scb
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|hardware_scb
op_star
id|hscb
op_assign
id|scb-&gt;hscb
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;scb:%p control:0x%x scsiid:0x%x lun:%d cdb_len:%d&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|scb
comma
id|hscb-&gt;control
comma
id|hscb-&gt;scsiid
comma
id|hscb-&gt;lun
comma
id|hscb-&gt;cdb_len
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Shared Data: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|hscb-&gt;shared_data.cdb
)paren
suffix:semicolon
id|i
op_increment
)paren
id|printf
c_func
(paren
l_string|&quot;%#02x&quot;
comma
id|hscb-&gt;shared_data.cdb
(braket
id|i
)braket
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;        dataptr:%#x datacnt:%#x sgptr:%#x tag:%#x&bslash;n&quot;
comma
id|ahc_le32toh
c_func
(paren
id|hscb-&gt;dataptr
)paren
comma
id|ahc_le32toh
c_func
(paren
id|hscb-&gt;datacnt
)paren
comma
id|ahc_le32toh
c_func
(paren
id|hscb-&gt;sgptr
)paren
comma
id|hscb-&gt;tag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb-&gt;sg_count
OG
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|scb-&gt;sg_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;sg[%d] - Addr 0x%x%x : Length %d&bslash;n&quot;
comma
id|i
comma
(paren
id|ahc_le32toh
c_func
(paren
id|scb-&gt;sg_list
(braket
id|i
)braket
dot
id|len
)paren
op_rshift
l_int|24
op_amp
id|SG_HIGH_ADDR_BITS
)paren
comma
id|ahc_le32toh
c_func
(paren
id|scb-&gt;sg_list
(braket
id|i
)braket
dot
id|addr
)paren
comma
id|ahc_le32toh
c_func
(paren
id|scb-&gt;sg_list
(braket
id|i
)braket
dot
id|len
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/************************* Transfer Negotiation *******************************/
multiline_comment|/*&n; * Allocate per target mode instance (ID we respond to as a target)&n; * transfer negotiation data structures.&n; */
r_static
r_struct
id|ahc_tmode_tstate
op_star
DECL|function|ahc_alloc_tstate
id|ahc_alloc_tstate
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|u_int
id|scsi_id
comma
r_char
id|channel
)paren
(brace
r_struct
id|ahc_tmode_tstate
op_star
id|master_tstate
suffix:semicolon
r_struct
id|ahc_tmode_tstate
op_star
id|tstate
suffix:semicolon
r_int
id|i
suffix:semicolon
id|master_tstate
op_assign
id|ahc-&gt;enabled_targets
(braket
id|ahc-&gt;our_id
)braket
suffix:semicolon
r_if
c_cond
(paren
id|channel
op_eq
l_char|&squot;B&squot;
)paren
(brace
id|scsi_id
op_add_assign
l_int|8
suffix:semicolon
id|master_tstate
op_assign
id|ahc-&gt;enabled_targets
(braket
id|ahc-&gt;our_id_b
op_plus
l_int|8
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ahc-&gt;enabled_targets
(braket
id|scsi_id
)braket
op_ne
l_int|NULL
op_logical_and
id|ahc-&gt;enabled_targets
(braket
id|scsi_id
)braket
op_ne
id|master_tstate
)paren
id|panic
c_func
(paren
l_string|&quot;%s: ahc_alloc_tstate - Target already allocated&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
)paren
suffix:semicolon
id|tstate
op_assign
(paren
r_struct
id|ahc_tmode_tstate
op_star
)paren
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|tstate
)paren
comma
id|M_DEVBUF
comma
id|M_NOWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tstate
op_eq
l_int|NULL
)paren
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we have allocated a master tstate, copy user settings from&n;&t; * the master tstate (taken from SRAM or the EEPROM) for this&n;&t; * channel, but reset our current and goal settings to async/narrow&n;&t; * until an initiator talks to us.&n;&t; */
r_if
c_cond
(paren
id|master_tstate
op_ne
l_int|NULL
)paren
(brace
id|memcpy
c_func
(paren
id|tstate
comma
id|master_tstate
comma
r_sizeof
(paren
op_star
id|tstate
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|tstate-&gt;enabled_luns
comma
l_int|0
comma
r_sizeof
(paren
id|tstate-&gt;enabled_luns
)paren
)paren
suffix:semicolon
id|tstate-&gt;ultraenb
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AHC_NUM_TARGETS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|memset
c_func
(paren
op_amp
id|tstate-&gt;transinfo
(braket
id|i
)braket
dot
id|curr
comma
l_int|0
comma
r_sizeof
(paren
id|tstate-&gt;transinfo
(braket
id|i
)braket
dot
id|curr
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|tstate-&gt;transinfo
(braket
id|i
)braket
dot
id|goal
comma
l_int|0
comma
r_sizeof
(paren
id|tstate-&gt;transinfo
(braket
id|i
)braket
dot
id|goal
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
id|memset
c_func
(paren
id|tstate
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|tstate
)paren
)paren
suffix:semicolon
id|ahc-&gt;enabled_targets
(braket
id|scsi_id
)braket
op_assign
id|tstate
suffix:semicolon
r_return
(paren
id|tstate
)paren
suffix:semicolon
)brace
macro_line|#ifdef AHC_TARGET_MODE
multiline_comment|/*&n; * Free per target mode instance (ID we respond to as a target)&n; * transfer negotiation data structures.&n; */
r_static
r_void
DECL|function|ahc_free_tstate
id|ahc_free_tstate
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|u_int
id|scsi_id
comma
r_char
id|channel
comma
r_int
id|force
)paren
(brace
r_struct
id|ahc_tmode_tstate
op_star
id|tstate
suffix:semicolon
multiline_comment|/*&n;&t; * Don&squot;t clean up our &quot;master&quot; tstate.&n;&t; * It has our default user settings.&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|channel
op_eq
l_char|&squot;B&squot;
op_logical_and
id|scsi_id
op_eq
id|ahc-&gt;our_id_b
)paren
op_logical_or
(paren
id|channel
op_eq
l_char|&squot;A&squot;
op_logical_and
id|scsi_id
op_eq
id|ahc-&gt;our_id
)paren
)paren
op_logical_and
id|force
op_eq
id|FALSE
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|channel
op_eq
l_char|&squot;B&squot;
)paren
id|scsi_id
op_add_assign
l_int|8
suffix:semicolon
id|tstate
op_assign
id|ahc-&gt;enabled_targets
(braket
id|scsi_id
)braket
suffix:semicolon
r_if
c_cond
(paren
id|tstate
op_ne
l_int|NULL
)paren
id|free
c_func
(paren
id|tstate
comma
id|M_DEVBUF
)paren
suffix:semicolon
id|ahc-&gt;enabled_targets
(braket
id|scsi_id
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Called when we have an active connection to a target on the bus,&n; * this function finds the nearest syncrate to the input period limited&n; * by the capabilities of the bus connectivity of and sync settings for&n; * the target.&n; */
r_struct
id|ahc_syncrate
op_star
DECL|function|ahc_devlimited_syncrate
id|ahc_devlimited_syncrate
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_initiator_tinfo
op_star
id|tinfo
comma
id|u_int
op_star
id|period
comma
id|u_int
op_star
id|ppr_options
comma
id|role_t
id|role
)paren
(brace
r_struct
id|ahc_transinfo
op_star
id|transinfo
suffix:semicolon
id|u_int
id|maxsync
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SBLKCTL
)paren
op_amp
id|ENAB40
)paren
op_ne
l_int|0
op_logical_and
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SSTAT2
)paren
op_amp
id|EXP_ACTIVE
)paren
op_eq
l_int|0
)paren
(brace
id|maxsync
op_assign
id|AHC_SYNCRATE_DT
suffix:semicolon
)brace
r_else
(brace
id|maxsync
op_assign
id|AHC_SYNCRATE_ULTRA
suffix:semicolon
multiline_comment|/* Can&squot;t do DT on an SE bus */
op_star
id|ppr_options
op_and_assign
op_complement
id|MSG_EXT_PPR_DT_REQ
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_ULTRA
)paren
op_ne
l_int|0
)paren
(brace
id|maxsync
op_assign
id|AHC_SYNCRATE_ULTRA
suffix:semicolon
)brace
r_else
(brace
id|maxsync
op_assign
id|AHC_SYNCRATE_FAST
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Never allow a value higher than our current goal&n;&t; * period otherwise we may allow a target initiated&n;&t; * negotiation to go above the limit as set by the&n;&t; * user.  In the case of an initiator initiated&n;&t; * sync negotiation, we limit based on the user&n;&t; * setting.  This allows the system to still accept&n;&t; * incoming negotiations even if target initiated&n;&t; * negotiation is not performed.&n;&t; */
r_if
c_cond
(paren
id|role
op_eq
id|ROLE_TARGET
)paren
id|transinfo
op_assign
op_amp
id|tinfo-&gt;user
suffix:semicolon
r_else
id|transinfo
op_assign
op_amp
id|tinfo-&gt;goal
suffix:semicolon
op_star
id|ppr_options
op_and_assign
id|transinfo-&gt;ppr_options
suffix:semicolon
r_if
c_cond
(paren
id|transinfo-&gt;width
op_eq
id|MSG_EXT_WDTR_BUS_8_BIT
)paren
(brace
id|maxsync
op_assign
id|MAX
c_func
(paren
id|maxsync
comma
id|AHC_SYNCRATE_ULTRA2
)paren
suffix:semicolon
op_star
id|ppr_options
op_and_assign
op_complement
id|MSG_EXT_PPR_DT_REQ
suffix:semicolon
)brace
r_if
c_cond
(paren
id|transinfo-&gt;period
op_eq
l_int|0
)paren
(brace
op_star
id|period
op_assign
l_int|0
suffix:semicolon
op_star
id|ppr_options
op_assign
l_int|0
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
op_star
id|period
op_assign
id|MAX
c_func
(paren
op_star
id|period
comma
id|transinfo-&gt;period
)paren
suffix:semicolon
r_return
(paren
id|ahc_find_syncrate
c_func
(paren
id|ahc
comma
id|period
comma
id|ppr_options
comma
id|maxsync
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Look up the valid period to SCSIRATE conversion in our table.&n; * Return the period and offset that should be sent to the target&n; * if this was the beginning of an SDTR.&n; */
r_struct
id|ahc_syncrate
op_star
DECL|function|ahc_find_syncrate
id|ahc_find_syncrate
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|u_int
op_star
id|period
comma
id|u_int
op_star
id|ppr_options
comma
id|u_int
id|maxsync
)paren
(brace
r_struct
id|ahc_syncrate
op_star
id|syncrate
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_DT
)paren
op_eq
l_int|0
)paren
op_star
id|ppr_options
op_and_assign
op_complement
id|MSG_EXT_PPR_DT_REQ
suffix:semicolon
multiline_comment|/* Skip all DT only entries if DT is not available */
r_if
c_cond
(paren
(paren
op_star
id|ppr_options
op_amp
id|MSG_EXT_PPR_DT_REQ
)paren
op_eq
l_int|0
op_logical_and
id|maxsync
OL
id|AHC_SYNCRATE_ULTRA2
)paren
id|maxsync
op_assign
id|AHC_SYNCRATE_ULTRA2
suffix:semicolon
r_for
c_loop
(paren
id|syncrate
op_assign
op_amp
id|ahc_syncrates
(braket
id|maxsync
)braket
suffix:semicolon
id|syncrate-&gt;rate
op_ne
l_int|NULL
suffix:semicolon
id|syncrate
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * The Ultra2 table doesn&squot;t go as low&n;&t;&t; * as for the Fast/Ultra cards.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_ne
l_int|0
op_logical_and
(paren
id|syncrate-&gt;sxfr_u2
op_eq
l_int|0
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_star
id|period
op_le
id|syncrate-&gt;period
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * When responding to a target that requests&n;&t;&t;&t; * sync, the requested rate may fall between&n;&t;&t;&t; * two rates that we can output, but still be&n;&t;&t;&t; * a rate that we can receive.  Because of this,&n;&t;&t;&t; * we want to respond to the target with&n;&t;&t;&t; * the same rate that it sent to us even&n;&t;&t;&t; * if the period we use to send data to it&n;&t;&t;&t; * is lower.  Only lower the response period&n;&t;&t;&t; * if we must.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|syncrate
op_eq
op_amp
id|ahc_syncrates
(braket
id|maxsync
)braket
)paren
op_star
id|period
op_assign
id|syncrate-&gt;period
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * At some speeds, we only support&n;&t;&t;&t; * ST transfers.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|syncrate-&gt;sxfr_u2
op_amp
id|ST_SXFR
)paren
op_ne
l_int|0
)paren
op_star
id|ppr_options
op_and_assign
op_complement
id|MSG_EXT_PPR_DT_REQ
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
op_star
id|period
op_eq
l_int|0
)paren
op_logical_or
(paren
id|syncrate-&gt;rate
op_eq
l_int|NULL
)paren
op_logical_or
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_ne
l_int|0
op_logical_and
(paren
id|syncrate-&gt;sxfr_u2
op_eq
l_int|0
)paren
)paren
)paren
(brace
multiline_comment|/* Use asynchronous transfers. */
op_star
id|period
op_assign
l_int|0
suffix:semicolon
id|syncrate
op_assign
l_int|NULL
suffix:semicolon
op_star
id|ppr_options
op_and_assign
op_complement
id|MSG_EXT_PPR_DT_REQ
suffix:semicolon
)brace
r_return
(paren
id|syncrate
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert from an entry in our syncrate table to the SCSI equivalent&n; * sync &quot;period&quot; factor.&n; */
id|u_int
DECL|function|ahc_find_period
id|ahc_find_period
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|u_int
id|scsirate
comma
id|u_int
id|maxsync
)paren
(brace
r_struct
id|ahc_syncrate
op_star
id|syncrate
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_ne
l_int|0
)paren
id|scsirate
op_and_assign
id|SXFR_ULTRA2
suffix:semicolon
r_else
id|scsirate
op_and_assign
id|SXFR
suffix:semicolon
id|syncrate
op_assign
op_amp
id|ahc_syncrates
(braket
id|maxsync
)braket
suffix:semicolon
r_while
c_loop
(paren
id|syncrate-&gt;rate
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|syncrate-&gt;sxfr_u2
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_else
r_if
c_cond
(paren
id|scsirate
op_eq
(paren
id|syncrate-&gt;sxfr_u2
op_amp
id|SXFR_ULTRA2
)paren
)paren
r_return
(paren
id|syncrate-&gt;period
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scsirate
op_eq
(paren
id|syncrate-&gt;sxfr
op_amp
id|SXFR
)paren
)paren
(brace
r_return
(paren
id|syncrate-&gt;period
)paren
suffix:semicolon
)brace
id|syncrate
op_increment
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* async */
)brace
multiline_comment|/*&n; * Truncate the given synchronous offset to a value the&n; * current adapter type and syncrate are capable of.&n; */
r_void
DECL|function|ahc_validate_offset
id|ahc_validate_offset
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_initiator_tinfo
op_star
id|tinfo
comma
r_struct
id|ahc_syncrate
op_star
id|syncrate
comma
id|u_int
op_star
id|offset
comma
r_int
id|wide
comma
id|role_t
id|role
)paren
(brace
id|u_int
id|maxoffset
suffix:semicolon
multiline_comment|/* Limit offset to what we can do */
r_if
c_cond
(paren
id|syncrate
op_eq
l_int|NULL
)paren
(brace
id|maxoffset
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_ne
l_int|0
)paren
(brace
id|maxoffset
op_assign
id|MAX_OFFSET_ULTRA2
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|wide
)paren
id|maxoffset
op_assign
id|MAX_OFFSET_16BIT
suffix:semicolon
r_else
id|maxoffset
op_assign
id|MAX_OFFSET_8BIT
suffix:semicolon
)brace
op_star
id|offset
op_assign
id|MIN
c_func
(paren
op_star
id|offset
comma
id|maxoffset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tinfo
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|role
op_eq
id|ROLE_TARGET
)paren
op_star
id|offset
op_assign
id|MIN
c_func
(paren
op_star
id|offset
comma
id|tinfo-&gt;user.offset
)paren
suffix:semicolon
r_else
op_star
id|offset
op_assign
id|MIN
c_func
(paren
op_star
id|offset
comma
id|tinfo-&gt;goal.offset
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Truncate the given transfer width parameter to a value the&n; * current adapter type is capable of.&n; */
r_void
DECL|function|ahc_validate_width
id|ahc_validate_width
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_initiator_tinfo
op_star
id|tinfo
comma
id|u_int
op_star
id|bus_width
comma
id|role_t
id|role
)paren
(brace
r_switch
c_cond
(paren
op_star
id|bus_width
)paren
(brace
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|ahc-&gt;features
op_amp
id|AHC_WIDE
)paren
(brace
multiline_comment|/* Respond Wide */
op_star
id|bus_width
op_assign
id|MSG_EXT_WDTR_BUS_16_BIT
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* FALLTHROUGH */
r_case
id|MSG_EXT_WDTR_BUS_8_BIT
suffix:colon
op_star
id|bus_width
op_assign
id|MSG_EXT_WDTR_BUS_8_BIT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tinfo
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|role
op_eq
id|ROLE_TARGET
)paren
op_star
id|bus_width
op_assign
id|MIN
c_func
(paren
id|tinfo-&gt;user.width
comma
op_star
id|bus_width
)paren
suffix:semicolon
r_else
op_star
id|bus_width
op_assign
id|MIN
c_func
(paren
id|tinfo-&gt;goal.width
comma
op_star
id|bus_width
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Update the bitmask of targets for which the controller should&n; * negotiate with at the next convenient oportunity.  This currently&n; * means the next time we send the initial identify messages for&n; * a new transaction.&n; */
r_int
DECL|function|ahc_update_neg_request
id|ahc_update_neg_request
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
comma
r_struct
id|ahc_tmode_tstate
op_star
id|tstate
comma
r_struct
id|ahc_initiator_tinfo
op_star
id|tinfo
comma
id|ahc_neg_type
id|neg_type
)paren
(brace
id|u_int
id|auto_negotiate_orig
suffix:semicolon
id|auto_negotiate_orig
op_assign
id|tstate-&gt;auto_negotiate
suffix:semicolon
r_if
c_cond
(paren
id|neg_type
op_eq
id|AHC_NEG_ALWAYS
)paren
(brace
multiline_comment|/*&n;&t;&t; * Force our &quot;current&quot; settings to be&n;&t;&t; * unknown so that unless a bus reset&n;&t;&t; * occurs the need to renegotiate is&n;&t;&t; * recorded persistently.&n;&t;&t; */
id|tinfo-&gt;curr.period
op_assign
id|AHC_PERIOD_UNKNOWN
suffix:semicolon
id|tinfo-&gt;curr.width
op_assign
id|AHC_WIDTH_UNKNOWN
suffix:semicolon
id|tinfo-&gt;curr.offset
op_assign
id|AHC_OFFSET_UNKNOWN
suffix:semicolon
id|tinfo-&gt;curr.ppr_options
op_assign
id|AHC_OFFSET_UNKNOWN
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tinfo-&gt;curr.period
op_ne
id|tinfo-&gt;goal.period
op_logical_or
id|tinfo-&gt;curr.width
op_ne
id|tinfo-&gt;goal.width
op_logical_or
id|tinfo-&gt;curr.offset
op_ne
id|tinfo-&gt;goal.offset
op_logical_or
id|tinfo-&gt;curr.ppr_options
op_ne
id|tinfo-&gt;goal.ppr_options
op_logical_or
(paren
id|neg_type
op_eq
id|AHC_NEG_IF_NON_ASYNC
op_logical_and
(paren
id|tinfo-&gt;goal.offset
op_ne
l_int|0
op_logical_or
id|tinfo-&gt;goal.width
op_ne
id|MSG_EXT_WDTR_BUS_8_BIT
op_logical_or
id|tinfo-&gt;goal.ppr_options
op_ne
l_int|0
)paren
)paren
)paren
id|tstate-&gt;auto_negotiate
op_or_assign
id|devinfo-&gt;target_mask
suffix:semicolon
r_else
id|tstate-&gt;auto_negotiate
op_and_assign
op_complement
id|devinfo-&gt;target_mask
suffix:semicolon
r_return
(paren
id|auto_negotiate_orig
op_ne
id|tstate-&gt;auto_negotiate
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Update the user/goal/curr tables of synchronous negotiation&n; * parameters as well as, in the case of a current or active update,&n; * any data structures on the host controller.  In the case of an&n; * active update, the specified target is currently talking to us on&n; * the bus, so the transfer parameter update must take effect&n; * immediately.&n; */
r_void
DECL|function|ahc_set_syncrate
id|ahc_set_syncrate
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
comma
r_struct
id|ahc_syncrate
op_star
id|syncrate
comma
id|u_int
id|period
comma
id|u_int
id|offset
comma
id|u_int
id|ppr_options
comma
id|u_int
id|type
comma
r_int
id|paused
)paren
(brace
r_struct
id|ahc_initiator_tinfo
op_star
id|tinfo
suffix:semicolon
r_struct
id|ahc_tmode_tstate
op_star
id|tstate
suffix:semicolon
id|u_int
id|old_period
suffix:semicolon
id|u_int
id|old_offset
suffix:semicolon
id|u_int
id|old_ppr
suffix:semicolon
r_int
id|active
suffix:semicolon
r_int
id|update_needed
suffix:semicolon
id|active
op_assign
(paren
id|type
op_amp
id|AHC_TRANS_ACTIVE
)paren
op_eq
id|AHC_TRANS_ACTIVE
suffix:semicolon
id|update_needed
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|syncrate
op_eq
l_int|NULL
)paren
(brace
id|period
op_assign
l_int|0
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
)brace
id|tinfo
op_assign
id|ahc_fetch_transinfo
c_func
(paren
id|ahc
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;our_scsiid
comma
id|devinfo-&gt;target
comma
op_amp
id|tstate
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|type
op_amp
id|AHC_TRANS_USER
)paren
op_ne
l_int|0
)paren
(brace
id|tinfo-&gt;user.period
op_assign
id|period
suffix:semicolon
id|tinfo-&gt;user.offset
op_assign
id|offset
suffix:semicolon
id|tinfo-&gt;user.ppr_options
op_assign
id|ppr_options
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|type
op_amp
id|AHC_TRANS_GOAL
)paren
op_ne
l_int|0
)paren
(brace
id|tinfo-&gt;goal.period
op_assign
id|period
suffix:semicolon
id|tinfo-&gt;goal.offset
op_assign
id|offset
suffix:semicolon
id|tinfo-&gt;goal.ppr_options
op_assign
id|ppr_options
suffix:semicolon
)brace
id|old_period
op_assign
id|tinfo-&gt;curr.period
suffix:semicolon
id|old_offset
op_assign
id|tinfo-&gt;curr.offset
suffix:semicolon
id|old_ppr
op_assign
id|tinfo-&gt;curr.ppr_options
suffix:semicolon
r_if
c_cond
(paren
(paren
id|type
op_amp
id|AHC_TRANS_CUR
)paren
op_ne
l_int|0
op_logical_and
(paren
id|old_period
op_ne
id|period
op_logical_or
id|old_offset
op_ne
id|offset
op_logical_or
id|old_ppr
op_ne
id|ppr_options
)paren
)paren
(brace
id|u_int
id|scsirate
suffix:semicolon
id|update_needed
op_increment
suffix:semicolon
id|scsirate
op_assign
id|tinfo-&gt;scsirate
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_ne
l_int|0
)paren
(brace
id|scsirate
op_and_assign
op_complement
(paren
id|SXFR_ULTRA2
op_or
id|SINGLE_EDGE
op_or
id|ENABLE_CRC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|syncrate
op_ne
l_int|NULL
)paren
(brace
id|scsirate
op_or_assign
id|syncrate-&gt;sxfr_u2
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ppr_options
op_amp
id|MSG_EXT_PPR_DT_REQ
)paren
op_ne
l_int|0
)paren
id|scsirate
op_or_assign
id|ENABLE_CRC
suffix:semicolon
r_else
id|scsirate
op_or_assign
id|SINGLE_EDGE
suffix:semicolon
)brace
)brace
r_else
(brace
id|scsirate
op_and_assign
op_complement
(paren
id|SXFR
op_or
id|SOFS
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Ensure Ultra mode is set properly for&n;&t;&t;&t; * this target.&n;&t;&t;&t; */
id|tstate-&gt;ultraenb
op_and_assign
op_complement
id|devinfo-&gt;target_mask
suffix:semicolon
r_if
c_cond
(paren
id|syncrate
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|syncrate-&gt;sxfr
op_amp
id|ULTRA_SXFR
)paren
(brace
id|tstate-&gt;ultraenb
op_or_assign
id|devinfo-&gt;target_mask
suffix:semicolon
)brace
id|scsirate
op_or_assign
id|syncrate-&gt;sxfr
op_amp
id|SXFR
suffix:semicolon
id|scsirate
op_or_assign
id|offset
op_amp
id|SOFS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|active
)paren
(brace
id|u_int
id|sxfrctl0
suffix:semicolon
id|sxfrctl0
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SXFRCTL0
)paren
suffix:semicolon
id|sxfrctl0
op_and_assign
op_complement
id|FAST20
suffix:semicolon
r_if
c_cond
(paren
id|tstate-&gt;ultraenb
op_amp
id|devinfo-&gt;target_mask
)paren
id|sxfrctl0
op_or_assign
id|FAST20
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SXFRCTL0
comma
id|sxfrctl0
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|active
)paren
(brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSIRATE
comma
id|scsirate
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_ne
l_int|0
)paren
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSIOFFSET
comma
id|offset
)paren
suffix:semicolon
)brace
id|tinfo-&gt;scsirate
op_assign
id|scsirate
suffix:semicolon
id|tinfo-&gt;curr.period
op_assign
id|period
suffix:semicolon
id|tinfo-&gt;curr.offset
op_assign
id|offset
suffix:semicolon
id|tinfo-&gt;curr.ppr_options
op_assign
id|ppr_options
suffix:semicolon
id|ahc_send_async
c_func
(paren
id|ahc
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|CAM_LUN_WILDCARD
comma
id|AC_TRANSFER_NEG
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
)paren
(brace
r_if
c_cond
(paren
id|offset
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: target %d synchronous at %sMHz%s, &quot;
l_string|&quot;offset = 0x%x&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|devinfo-&gt;target
comma
id|syncrate-&gt;rate
comma
(paren
id|ppr_options
op_amp
id|MSG_EXT_PPR_DT_REQ
)paren
ques
c_cond
l_string|&quot; DT&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|offset
)paren
suffix:semicolon
)brace
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;%s: target %d using &quot;
l_string|&quot;asynchronous transfers&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|devinfo-&gt;target
)paren
suffix:semicolon
)brace
)brace
)brace
id|update_needed
op_add_assign
id|ahc_update_neg_request
c_func
(paren
id|ahc
comma
id|devinfo
comma
id|tstate
comma
id|tinfo
comma
id|AHC_NEG_TO_GOAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|update_needed
)paren
id|ahc_update_pending_scbs
c_func
(paren
id|ahc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Update the user/goal/curr tables of wide negotiation&n; * parameters as well as, in the case of a current or active update,&n; * any data structures on the host controller.  In the case of an&n; * active update, the specified target is currently talking to us on&n; * the bus, so the transfer parameter update must take effect&n; * immediately.&n; */
r_void
DECL|function|ahc_set_width
id|ahc_set_width
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
comma
id|u_int
id|width
comma
id|u_int
id|type
comma
r_int
id|paused
)paren
(brace
r_struct
id|ahc_initiator_tinfo
op_star
id|tinfo
suffix:semicolon
r_struct
id|ahc_tmode_tstate
op_star
id|tstate
suffix:semicolon
id|u_int
id|oldwidth
suffix:semicolon
r_int
id|active
suffix:semicolon
r_int
id|update_needed
suffix:semicolon
id|active
op_assign
(paren
id|type
op_amp
id|AHC_TRANS_ACTIVE
)paren
op_eq
id|AHC_TRANS_ACTIVE
suffix:semicolon
id|update_needed
op_assign
l_int|0
suffix:semicolon
id|tinfo
op_assign
id|ahc_fetch_transinfo
c_func
(paren
id|ahc
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;our_scsiid
comma
id|devinfo-&gt;target
comma
op_amp
id|tstate
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|type
op_amp
id|AHC_TRANS_USER
)paren
op_ne
l_int|0
)paren
id|tinfo-&gt;user.width
op_assign
id|width
suffix:semicolon
r_if
c_cond
(paren
(paren
id|type
op_amp
id|AHC_TRANS_GOAL
)paren
op_ne
l_int|0
)paren
id|tinfo-&gt;goal.width
op_assign
id|width
suffix:semicolon
id|oldwidth
op_assign
id|tinfo-&gt;curr.width
suffix:semicolon
r_if
c_cond
(paren
(paren
id|type
op_amp
id|AHC_TRANS_CUR
)paren
op_ne
l_int|0
op_logical_and
id|oldwidth
op_ne
id|width
)paren
(brace
id|u_int
id|scsirate
suffix:semicolon
id|update_needed
op_increment
suffix:semicolon
id|scsirate
op_assign
id|tinfo-&gt;scsirate
suffix:semicolon
id|scsirate
op_and_assign
op_complement
id|WIDEXFER
suffix:semicolon
r_if
c_cond
(paren
id|width
op_eq
id|MSG_EXT_WDTR_BUS_16_BIT
)paren
id|scsirate
op_or_assign
id|WIDEXFER
suffix:semicolon
id|tinfo-&gt;scsirate
op_assign
id|scsirate
suffix:semicolon
r_if
c_cond
(paren
id|active
)paren
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSIRATE
comma
id|scsirate
)paren
suffix:semicolon
id|tinfo-&gt;curr.width
op_assign
id|width
suffix:semicolon
id|ahc_send_async
c_func
(paren
id|ahc
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|CAM_LUN_WILDCARD
comma
id|AC_TRANSFER_NEG
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: target %d using %dbit transfers&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|devinfo-&gt;target
comma
l_int|8
op_star
(paren
l_int|0x01
op_lshift
id|width
)paren
)paren
suffix:semicolon
)brace
)brace
id|update_needed
op_add_assign
id|ahc_update_neg_request
c_func
(paren
id|ahc
comma
id|devinfo
comma
id|tstate
comma
id|tinfo
comma
id|AHC_NEG_TO_GOAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|update_needed
)paren
id|ahc_update_pending_scbs
c_func
(paren
id|ahc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Update the current state of tagged queuing for a given target.&n; */
r_void
DECL|function|ahc_set_tags
id|ahc_set_tags
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
comma
id|ahc_queue_alg
id|alg
)paren
(brace
id|ahc_platform_set_tags
c_func
(paren
id|ahc
comma
id|devinfo
comma
id|alg
)paren
suffix:semicolon
id|ahc_send_async
c_func
(paren
id|ahc
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
comma
id|AC_TRANSFER_NEG
comma
op_amp
id|alg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * When the transfer settings for a connection change, update any&n; * in-transit SCBs to contain the new data so the hardware will&n; * be set correctly during future (re)selections.&n; */
r_static
r_void
DECL|function|ahc_update_pending_scbs
id|ahc_update_pending_scbs
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_struct
id|scb
op_star
id|pending_scb
suffix:semicolon
r_int
id|pending_scb_count
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|paused
suffix:semicolon
id|u_int
id|saved_scbptr
suffix:semicolon
multiline_comment|/*&n;&t; * Traverse the pending SCB list and ensure that all of the&n;&t; * SCBs there have the proper settings.&n;&t; */
id|pending_scb_count
op_assign
l_int|0
suffix:semicolon
id|LIST_FOREACH
c_func
(paren
id|pending_scb
comma
op_amp
id|ahc-&gt;pending_scbs
comma
id|pending_links
)paren
(brace
r_struct
id|ahc_devinfo
id|devinfo
suffix:semicolon
r_struct
id|hardware_scb
op_star
id|pending_hscb
suffix:semicolon
r_struct
id|ahc_initiator_tinfo
op_star
id|tinfo
suffix:semicolon
r_struct
id|ahc_tmode_tstate
op_star
id|tstate
suffix:semicolon
id|ahc_scb_devinfo
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
comma
id|pending_scb
)paren
suffix:semicolon
id|tinfo
op_assign
id|ahc_fetch_transinfo
c_func
(paren
id|ahc
comma
id|devinfo.channel
comma
id|devinfo.our_scsiid
comma
id|devinfo.target
comma
op_amp
id|tstate
)paren
suffix:semicolon
id|pending_hscb
op_assign
id|pending_scb-&gt;hscb
suffix:semicolon
id|pending_hscb-&gt;control
op_and_assign
op_complement
id|ULTRAENB
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tstate-&gt;ultraenb
op_amp
id|devinfo.target_mask
)paren
op_ne
l_int|0
)paren
id|pending_hscb-&gt;control
op_or_assign
id|ULTRAENB
suffix:semicolon
id|pending_hscb-&gt;scsirate
op_assign
id|tinfo-&gt;scsirate
suffix:semicolon
id|pending_hscb-&gt;scsioffset
op_assign
id|tinfo-&gt;curr.offset
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tstate-&gt;auto_negotiate
op_amp
id|devinfo.target_mask
)paren
op_eq
l_int|0
op_logical_and
(paren
id|pending_scb-&gt;flags
op_amp
id|SCB_AUTO_NEGOTIATE
)paren
op_ne
l_int|0
)paren
(brace
id|pending_scb-&gt;flags
op_and_assign
op_complement
id|SCB_AUTO_NEGOTIATE
suffix:semicolon
id|pending_hscb-&gt;control
op_and_assign
op_complement
id|MK_MESSAGE
suffix:semicolon
)brace
id|ahc_sync_scb
c_func
(paren
id|ahc
comma
id|pending_scb
comma
id|BUS_DMASYNC_PREREAD
op_or
id|BUS_DMASYNC_PREWRITE
)paren
suffix:semicolon
id|pending_scb_count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pending_scb_count
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|ahc_is_paused
c_func
(paren
id|ahc
)paren
)paren
(brace
id|paused
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|paused
op_assign
l_int|0
suffix:semicolon
id|ahc_pause
c_func
(paren
id|ahc
)paren
suffix:semicolon
)brace
id|saved_scbptr
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCBPTR
)paren
suffix:semicolon
multiline_comment|/* Ensure that the hscbs down on the card match the new information */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ahc-&gt;scb_data-&gt;maxhscbs
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|hardware_scb
op_star
id|pending_hscb
suffix:semicolon
id|u_int
id|control
suffix:semicolon
id|u_int
id|scb_tag
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBPTR
comma
id|i
)paren
suffix:semicolon
id|scb_tag
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_TAG
)paren
suffix:semicolon
id|pending_scb
op_assign
id|ahc_lookup_scb
c_func
(paren
id|ahc
comma
id|scb_tag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pending_scb
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|pending_hscb
op_assign
id|pending_scb-&gt;hscb
suffix:semicolon
id|control
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_CONTROL
)paren
suffix:semicolon
id|control
op_and_assign
op_complement
(paren
id|ULTRAENB
op_or
id|MK_MESSAGE
)paren
suffix:semicolon
id|control
op_or_assign
id|pending_hscb-&gt;control
op_amp
(paren
id|ULTRAENB
op_or
id|MK_MESSAGE
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCB_CONTROL
comma
id|control
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCB_SCSIRATE
comma
id|pending_hscb-&gt;scsirate
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCB_SCSIOFFSET
comma
id|pending_hscb-&gt;scsioffset
)paren
suffix:semicolon
)brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBPTR
comma
id|saved_scbptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|paused
op_eq
l_int|0
)paren
id|ahc_unpause
c_func
(paren
id|ahc
)paren
suffix:semicolon
)brace
multiline_comment|/**************************** Pathing Information *****************************/
r_static
r_void
DECL|function|ahc_fetch_devinfo
id|ahc_fetch_devinfo
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
)paren
(brace
id|u_int
id|saved_scsiid
suffix:semicolon
id|role_t
id|role
suffix:semicolon
r_int
id|our_id
suffix:semicolon
r_if
c_cond
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SSTAT0
)paren
op_amp
id|TARGET
)paren
id|role
op_assign
id|ROLE_TARGET
suffix:semicolon
r_else
id|role
op_assign
id|ROLE_INITIATOR
suffix:semicolon
r_if
c_cond
(paren
id|role
op_eq
id|ROLE_TARGET
op_logical_and
(paren
id|ahc-&gt;features
op_amp
id|AHC_MULTI_TID
)paren
op_ne
l_int|0
op_logical_and
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SEQ_FLAGS
)paren
op_amp
(paren
id|CMDPHASE_PENDING
op_or
id|TARG_CMD_PENDING
op_or
id|NO_DISCONNECT
)paren
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* We were selected, so pull our id from TARGIDIN */
id|our_id
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|TARGIDIN
)paren
op_amp
id|OID
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_ne
l_int|0
)paren
id|our_id
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSIID_ULTRA2
)paren
op_amp
id|OID
suffix:semicolon
r_else
id|our_id
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSIID
)paren
op_amp
id|OID
suffix:semicolon
id|saved_scsiid
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SAVED_SCSIID
)paren
suffix:semicolon
id|ahc_compile_devinfo
c_func
(paren
id|devinfo
comma
id|our_id
comma
id|SCSIID_TARGET
c_func
(paren
id|ahc
comma
id|saved_scsiid
)paren
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SAVED_LUN
)paren
comma
id|SCSIID_CHANNEL
c_func
(paren
id|ahc
comma
id|saved_scsiid
)paren
comma
id|role
)paren
suffix:semicolon
)brace
r_struct
id|ahc_phase_table_entry
op_star
DECL|function|ahc_lookup_phase_entry
id|ahc_lookup_phase_entry
c_func
(paren
r_int
id|phase
)paren
(brace
r_struct
id|ahc_phase_table_entry
op_star
id|entry
suffix:semicolon
r_struct
id|ahc_phase_table_entry
op_star
id|last_entry
suffix:semicolon
multiline_comment|/*&n;&t; * num_phases doesn&squot;t include the default entry which&n;&t; * will be returned if the phase doesn&squot;t match.&n;&t; */
id|last_entry
op_assign
op_amp
id|ahc_phase_table
(braket
id|num_phases
)braket
suffix:semicolon
r_for
c_loop
(paren
id|entry
op_assign
id|ahc_phase_table
suffix:semicolon
id|entry
OL
id|last_entry
suffix:semicolon
id|entry
op_increment
)paren
(brace
r_if
c_cond
(paren
id|phase
op_eq
id|entry-&gt;phase
)paren
r_break
suffix:semicolon
)brace
r_return
(paren
id|entry
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahc_compile_devinfo
id|ahc_compile_devinfo
c_func
(paren
r_struct
id|ahc_devinfo
op_star
id|devinfo
comma
id|u_int
id|our_id
comma
id|u_int
id|target
comma
id|u_int
id|lun
comma
r_char
id|channel
comma
id|role_t
id|role
)paren
(brace
id|devinfo-&gt;our_scsiid
op_assign
id|our_id
suffix:semicolon
id|devinfo-&gt;target
op_assign
id|target
suffix:semicolon
id|devinfo-&gt;lun
op_assign
id|lun
suffix:semicolon
id|devinfo-&gt;target_offset
op_assign
id|target
suffix:semicolon
id|devinfo-&gt;channel
op_assign
id|channel
suffix:semicolon
id|devinfo-&gt;role
op_assign
id|role
suffix:semicolon
r_if
c_cond
(paren
id|channel
op_eq
l_char|&squot;B&squot;
)paren
id|devinfo-&gt;target_offset
op_add_assign
l_int|8
suffix:semicolon
id|devinfo-&gt;target_mask
op_assign
(paren
l_int|0x01
op_lshift
id|devinfo-&gt;target_offset
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahc_print_devinfo
id|ahc_print_devinfo
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s:%c:%d:%d: &quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahc_scb_devinfo
id|ahc_scb_devinfo
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
comma
r_struct
id|scb
op_star
id|scb
)paren
(brace
id|role_t
id|role
suffix:semicolon
r_int
id|our_id
suffix:semicolon
id|our_id
op_assign
id|SCSIID_OUR_ID
c_func
(paren
id|scb-&gt;hscb-&gt;scsiid
)paren
suffix:semicolon
id|role
op_assign
id|ROLE_INITIATOR
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_TARGET_SCB
)paren
op_ne
l_int|0
)paren
id|role
op_assign
id|ROLE_TARGET
suffix:semicolon
id|ahc_compile_devinfo
c_func
(paren
id|devinfo
comma
id|our_id
comma
id|SCB_GET_TARGET
c_func
(paren
id|ahc
comma
id|scb
)paren
comma
id|SCB_GET_LUN
c_func
(paren
id|scb
)paren
comma
id|SCB_GET_CHANNEL
c_func
(paren
id|ahc
comma
id|scb
)paren
comma
id|role
)paren
suffix:semicolon
)brace
multiline_comment|/************************ Message Phase Processing ****************************/
r_static
r_void
DECL|function|ahc_assert_atn
id|ahc_assert_atn
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
id|u_int
id|scsisigo
suffix:semicolon
id|scsisigo
op_assign
id|ATNO
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_DT
)paren
op_eq
l_int|0
)paren
id|scsisigo
op_or_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSISIGI
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSISIGO
comma
id|scsisigo
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * When an initiator transaction with the MK_MESSAGE flag either reconnects&n; * or enters the initial message out phase, we are interrupted.  Fill our&n; * outgoing message buffer with the appropriate message and beging handing&n; * the message phase(s) manually.&n; */
r_static
r_void
DECL|function|ahc_setup_initiator_msgout
id|ahc_setup_initiator_msgout
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
comma
r_struct
id|scb
op_star
id|scb
)paren
(brace
multiline_comment|/*&n;&t; * To facilitate adding multiple messages together,&n;&t; * each routine should increment the index and len&n;&t; * variables instead of setting them explicitly.&n;&t; */
id|ahc-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|ahc-&gt;msgout_len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_DEVICE_RESET
)paren
op_eq
l_int|0
op_logical_and
id|ahc_inb
c_func
(paren
id|ahc
comma
id|MSG_OUT
)paren
op_eq
id|MSG_IDENTIFYFLAG
)paren
(brace
id|u_int
id|identify_msg
suffix:semicolon
id|identify_msg
op_assign
id|MSG_IDENTIFYFLAG
op_or
id|SCB_GET_LUN
c_func
(paren
id|scb
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb-&gt;hscb-&gt;control
op_amp
id|DISCENB
)paren
op_ne
l_int|0
)paren
id|identify_msg
op_or_assign
id|MSG_IDENTIFY_DISCFLAG
suffix:semicolon
id|ahc-&gt;msgout_buf
(braket
id|ahc-&gt;msgout_index
op_increment
)braket
op_assign
id|identify_msg
suffix:semicolon
id|ahc-&gt;msgout_len
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb-&gt;hscb-&gt;control
op_amp
id|TAG_ENB
)paren
op_ne
l_int|0
)paren
(brace
id|ahc-&gt;msgout_buf
(braket
id|ahc-&gt;msgout_index
op_increment
)braket
op_assign
id|scb-&gt;hscb-&gt;control
op_amp
(paren
id|TAG_ENB
op_or
id|SCB_TAG_TYPE
)paren
suffix:semicolon
id|ahc-&gt;msgout_buf
(braket
id|ahc-&gt;msgout_index
op_increment
)braket
op_assign
id|scb-&gt;hscb-&gt;tag
suffix:semicolon
id|ahc-&gt;msgout_len
op_add_assign
l_int|2
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_DEVICE_RESET
)paren
(brace
id|ahc-&gt;msgout_buf
(braket
id|ahc-&gt;msgout_index
op_increment
)braket
op_assign
id|MSG_BUS_DEV_RESET
suffix:semicolon
id|ahc-&gt;msgout_len
op_increment
suffix:semicolon
id|ahc_print_path
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Bus Device Reset Message Sent&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Clear our selection hardware in advance of&n;&t;&t; * the busfree.  We may have an entry in the waiting&n;&t;&t; * Q for this target, and we don&squot;t want to go about&n;&t;&t; * selecting while we handle the busfree and blow it&n;&t;&t; * away.&n;&t;&t; */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSISEQ
comma
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSISEQ
)paren
op_amp
op_complement
id|ENSELO
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_ABORT
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|scb-&gt;hscb-&gt;control
op_amp
id|TAG_ENB
)paren
op_ne
l_int|0
)paren
id|ahc-&gt;msgout_buf
(braket
id|ahc-&gt;msgout_index
op_increment
)braket
op_assign
id|MSG_ABORT_TAG
suffix:semicolon
r_else
id|ahc-&gt;msgout_buf
(braket
id|ahc-&gt;msgout_index
op_increment
)braket
op_assign
id|MSG_ABORT
suffix:semicolon
id|ahc-&gt;msgout_len
op_increment
suffix:semicolon
id|ahc_print_path
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Abort%s Message Sent&bslash;n&quot;
comma
(paren
id|scb-&gt;hscb-&gt;control
op_amp
id|TAG_ENB
)paren
op_ne
l_int|0
ques
c_cond
l_string|&quot; Tag&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Clear our selection hardware in advance of&n;&t;&t; * the busfree.  We may have an entry in the waiting&n;&t;&t; * Q for this target, and we don&squot;t want to go about&n;&t;&t; * selecting while we handle the busfree and blow it&n;&t;&t; * away.&n;&t;&t; */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSISEQ
comma
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSISEQ
)paren
op_amp
op_complement
id|ENSELO
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
(paren
id|SCB_AUTO_NEGOTIATE
op_or
id|SCB_NEGOTIATE
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|ahc_build_transfer_msg
c_func
(paren
id|ahc
comma
id|devinfo
)paren
suffix:semicolon
)brace
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;ahc_intr: AWAITING_MSG for an SCB that &quot;
l_string|&quot;does not have a waiting message&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;SCSIID = %x, target_mask = %x&bslash;n&quot;
comma
id|scb-&gt;hscb-&gt;scsiid
comma
id|devinfo-&gt;target_mask
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;SCB = %d, SCB Control = %x, MSG_OUT = %x &quot;
l_string|&quot;SCB flags = %x&quot;
comma
id|scb-&gt;hscb-&gt;tag
comma
id|scb-&gt;hscb-&gt;control
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|MSG_OUT
)paren
comma
id|scb-&gt;flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Clear the MK_MESSAGE flag from the SCB so we aren&squot;t&n;&t; * asked to send this message again.&n;&t; */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCB_CONTROL
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_CONTROL
)paren
op_amp
op_complement
id|MK_MESSAGE
)paren
suffix:semicolon
id|scb-&gt;hscb-&gt;control
op_and_assign
op_complement
id|MK_MESSAGE
suffix:semicolon
id|ahc-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|ahc-&gt;msg_type
op_assign
id|MSG_TYPE_INITIATOR_MSGOUT
suffix:semicolon
)brace
multiline_comment|/*&n; * Build an appropriate transfer negotiation message for the&n; * currently active target.&n; */
r_static
r_void
DECL|function|ahc_build_transfer_msg
id|ahc_build_transfer_msg
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
)paren
(brace
multiline_comment|/*&n;&t; * We need to initiate transfer negotiations.&n;&t; * If our current and goal settings are identical,&n;&t; * we want to renegotiate due to a check condition.&n;&t; */
r_struct
id|ahc_initiator_tinfo
op_star
id|tinfo
suffix:semicolon
r_struct
id|ahc_tmode_tstate
op_star
id|tstate
suffix:semicolon
r_struct
id|ahc_syncrate
op_star
id|rate
suffix:semicolon
r_int
id|dowide
suffix:semicolon
r_int
id|dosync
suffix:semicolon
r_int
id|doppr
suffix:semicolon
id|u_int
id|period
suffix:semicolon
id|u_int
id|ppr_options
suffix:semicolon
id|u_int
id|offset
suffix:semicolon
id|tinfo
op_assign
id|ahc_fetch_transinfo
c_func
(paren
id|ahc
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;our_scsiid
comma
id|devinfo-&gt;target
comma
op_amp
id|tstate
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Filter our period based on the current connection.&n;&t; * If we can&squot;t perform DT transfers on this segment (not in LVD&n;&t; * mode for instance), then our decision to issue a PPR message&n;&t; * may change.&n;&t; */
id|period
op_assign
id|tinfo-&gt;goal.period
suffix:semicolon
id|ppr_options
op_assign
id|tinfo-&gt;goal.ppr_options
suffix:semicolon
multiline_comment|/* Target initiated PPR is not allowed in the SCSI spec */
r_if
c_cond
(paren
id|devinfo-&gt;role
op_eq
id|ROLE_TARGET
)paren
id|ppr_options
op_assign
l_int|0
suffix:semicolon
id|rate
op_assign
id|ahc_devlimited_syncrate
c_func
(paren
id|ahc
comma
id|tinfo
comma
op_amp
id|period
comma
op_amp
id|ppr_options
comma
id|devinfo-&gt;role
)paren
suffix:semicolon
id|dowide
op_assign
id|tinfo-&gt;curr.width
op_ne
id|tinfo-&gt;goal.width
suffix:semicolon
id|dosync
op_assign
id|tinfo-&gt;curr.period
op_ne
id|period
suffix:semicolon
multiline_comment|/*&n;&t; * Only use PPR if we have options that need it, even if the device&n;&t; * claims to support it.  There might be an expander in the way&n;&t; * that doesn&squot;t.&n;&t; */
id|doppr
op_assign
id|ppr_options
op_ne
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dowide
op_logical_and
op_logical_neg
id|dosync
op_logical_and
op_logical_neg
id|doppr
)paren
(brace
id|dowide
op_assign
id|tinfo-&gt;goal.width
op_ne
id|MSG_EXT_WDTR_BUS_8_BIT
suffix:semicolon
id|dosync
op_assign
id|tinfo-&gt;goal.offset
op_ne
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dowide
op_logical_and
op_logical_neg
id|dosync
op_logical_and
op_logical_neg
id|doppr
)paren
(brace
multiline_comment|/*&n;&t;&t; * Force async with a WDTR message if we have a wide bus,&n;&t;&t; * or just issue an SDTR with a 0 offset.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_WIDE
)paren
op_ne
l_int|0
)paren
id|dowide
op_assign
l_int|1
suffix:semicolon
r_else
id|dosync
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
)paren
(brace
id|ahc_print_devinfo
c_func
(paren
id|ahc
comma
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Ensuring async&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Target initiated PPR is not allowed in the SCSI spec */
r_if
c_cond
(paren
id|devinfo-&gt;role
op_eq
id|ROLE_TARGET
)paren
id|doppr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Both the PPR message and SDTR message require the&n;&t; * goal syncrate to be limited to what the target device&n;&t; * is capable of handling (based on whether an LVD-&gt;SE&n;&t; * expander is on the bus), so combine these two cases.&n;&t; * Regardless, guarantee that if we are using WDTR and SDTR&n;&t; * messages that WDTR comes first.&n;&t; */
r_if
c_cond
(paren
id|doppr
op_logical_or
(paren
id|dosync
op_logical_and
op_logical_neg
id|dowide
)paren
)paren
(brace
id|offset
op_assign
id|tinfo-&gt;goal.offset
suffix:semicolon
id|ahc_validate_offset
c_func
(paren
id|ahc
comma
id|tinfo
comma
id|rate
comma
op_amp
id|offset
comma
id|doppr
ques
c_cond
id|tinfo-&gt;goal.width
suffix:colon
id|tinfo-&gt;curr.width
comma
id|devinfo-&gt;role
)paren
suffix:semicolon
r_if
c_cond
(paren
id|doppr
)paren
(brace
id|ahc_construct_ppr
c_func
(paren
id|ahc
comma
id|devinfo
comma
id|period
comma
id|offset
comma
id|tinfo-&gt;goal.width
comma
id|ppr_options
)paren
suffix:semicolon
)brace
r_else
(brace
id|ahc_construct_sdtr
c_func
(paren
id|ahc
comma
id|devinfo
comma
id|period
comma
id|offset
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|ahc_construct_wdtr
c_func
(paren
id|ahc
comma
id|devinfo
comma
id|tinfo-&gt;goal.width
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Build a synchronous negotiation message in our message&n; * buffer based on the input parameters.&n; */
r_static
r_void
DECL|function|ahc_construct_sdtr
id|ahc_construct_sdtr
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
comma
id|u_int
id|period
comma
id|u_int
id|offset
)paren
(brace
r_if
c_cond
(paren
id|offset
op_eq
l_int|0
)paren
id|period
op_assign
id|AHC_ASYNC_XFER_PERIOD
suffix:semicolon
id|ahc-&gt;msgout_buf
(braket
id|ahc-&gt;msgout_index
op_increment
)braket
op_assign
id|MSG_EXTENDED
suffix:semicolon
id|ahc-&gt;msgout_buf
(braket
id|ahc-&gt;msgout_index
op_increment
)braket
op_assign
id|MSG_EXT_SDTR_LEN
suffix:semicolon
id|ahc-&gt;msgout_buf
(braket
id|ahc-&gt;msgout_index
op_increment
)braket
op_assign
id|MSG_EXT_SDTR
suffix:semicolon
id|ahc-&gt;msgout_buf
(braket
id|ahc-&gt;msgout_index
op_increment
)braket
op_assign
id|period
suffix:semicolon
id|ahc-&gt;msgout_buf
(braket
id|ahc-&gt;msgout_index
op_increment
)braket
op_assign
id|offset
suffix:semicolon
id|ahc-&gt;msgout_len
op_add_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;(%s:%c:%d:%d): Sending SDTR period %x, offset %x&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
comma
id|period
comma
id|offset
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Build a wide negotiation message in our message&n; * buffer based on the input parameters.&n; */
r_static
r_void
DECL|function|ahc_construct_wdtr
id|ahc_construct_wdtr
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
comma
id|u_int
id|bus_width
)paren
(brace
id|ahc-&gt;msgout_buf
(braket
id|ahc-&gt;msgout_index
op_increment
)braket
op_assign
id|MSG_EXTENDED
suffix:semicolon
id|ahc-&gt;msgout_buf
(braket
id|ahc-&gt;msgout_index
op_increment
)braket
op_assign
id|MSG_EXT_WDTR_LEN
suffix:semicolon
id|ahc-&gt;msgout_buf
(braket
id|ahc-&gt;msgout_index
op_increment
)braket
op_assign
id|MSG_EXT_WDTR
suffix:semicolon
id|ahc-&gt;msgout_buf
(braket
id|ahc-&gt;msgout_index
op_increment
)braket
op_assign
id|bus_width
suffix:semicolon
id|ahc-&gt;msgout_len
op_add_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;(%s:%c:%d:%d): Sending WDTR %x&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
comma
id|bus_width
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Build a parallel protocol request message in our message&n; * buffer based on the input parameters.&n; */
r_static
r_void
DECL|function|ahc_construct_ppr
id|ahc_construct_ppr
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
comma
id|u_int
id|period
comma
id|u_int
id|offset
comma
id|u_int
id|bus_width
comma
id|u_int
id|ppr_options
)paren
(brace
r_if
c_cond
(paren
id|offset
op_eq
l_int|0
)paren
id|period
op_assign
id|AHC_ASYNC_XFER_PERIOD
suffix:semicolon
id|ahc-&gt;msgout_buf
(braket
id|ahc-&gt;msgout_index
op_increment
)braket
op_assign
id|MSG_EXTENDED
suffix:semicolon
id|ahc-&gt;msgout_buf
(braket
id|ahc-&gt;msgout_index
op_increment
)braket
op_assign
id|MSG_EXT_PPR_LEN
suffix:semicolon
id|ahc-&gt;msgout_buf
(braket
id|ahc-&gt;msgout_index
op_increment
)braket
op_assign
id|MSG_EXT_PPR
suffix:semicolon
id|ahc-&gt;msgout_buf
(braket
id|ahc-&gt;msgout_index
op_increment
)braket
op_assign
id|period
suffix:semicolon
id|ahc-&gt;msgout_buf
(braket
id|ahc-&gt;msgout_index
op_increment
)braket
op_assign
l_int|0
suffix:semicolon
id|ahc-&gt;msgout_buf
(braket
id|ahc-&gt;msgout_index
op_increment
)braket
op_assign
id|offset
suffix:semicolon
id|ahc-&gt;msgout_buf
(braket
id|ahc-&gt;msgout_index
op_increment
)braket
op_assign
id|bus_width
suffix:semicolon
id|ahc-&gt;msgout_buf
(braket
id|ahc-&gt;msgout_index
op_increment
)braket
op_assign
id|ppr_options
suffix:semicolon
id|ahc-&gt;msgout_len
op_add_assign
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;(%s:%c:%d:%d): Sending PPR bus_width %x, period %x, &quot;
l_string|&quot;offset %x, ppr_options %x&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
comma
id|bus_width
comma
id|period
comma
id|offset
comma
id|ppr_options
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Clear any active message state.&n; */
r_static
r_void
DECL|function|ahc_clear_msg_state
id|ahc_clear_msg_state
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
id|ahc-&gt;msgout_len
op_assign
l_int|0
suffix:semicolon
id|ahc-&gt;msgin_index
op_assign
l_int|0
suffix:semicolon
id|ahc-&gt;msg_type
op_assign
id|MSG_TYPE_NONE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSISIGI
)paren
op_amp
id|ATNI
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * The target didn&squot;t care to respond to our&n;&t;&t; * message request, so clear ATN.&n;&t;&t; */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CLRSINT1
comma
id|CLRATNO
)paren
suffix:semicolon
)brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|MSG_OUT
comma
id|MSG_NOOP
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SEQ_FLAGS2
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SEQ_FLAGS2
)paren
op_amp
op_complement
id|TARGET_MSG_PENDING
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahc_handle_proto_violation
id|ahc_handle_proto_violation
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_struct
id|ahc_devinfo
id|devinfo
suffix:semicolon
r_struct
id|scb
op_star
id|scb
suffix:semicolon
id|u_int
id|scbid
suffix:semicolon
id|u_int
id|seq_flags
suffix:semicolon
id|u_int
id|curphase
suffix:semicolon
id|u_int
id|lastphase
suffix:semicolon
r_int
id|found
suffix:semicolon
id|ahc_fetch_devinfo
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
)paren
suffix:semicolon
id|scbid
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_TAG
)paren
suffix:semicolon
id|scb
op_assign
id|ahc_lookup_scb
c_func
(paren
id|ahc
comma
id|scbid
)paren
suffix:semicolon
id|seq_flags
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SEQ_FLAGS
)paren
suffix:semicolon
id|curphase
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSISIGI
)paren
op_amp
id|PHASE_MASK
suffix:semicolon
id|lastphase
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|LASTPHASE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|seq_flags
op_amp
id|NOT_IDENTIFIED
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * The reconnecting target either did not send an&n;&t;&t; * identify message, or did, but we didn&squot;t find an SCB&n;&t;&t; * to match.&n;&t;&t; */
id|ahc_print_devinfo
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Target did not send an IDENTIFY message. &quot;
l_string|&quot;LASTPHASE = 0x%x.&bslash;n&quot;
comma
id|lastphase
)paren
suffix:semicolon
id|scb
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * We don&squot;t seem to have an SCB active for this&n;&t;&t; * transaction.  Print an error and reset the bus.&n;&t;&t; */
id|ahc_print_devinfo
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;No SCB found during protocol violation&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|proto_violation_reset
suffix:semicolon
)brace
r_else
(brace
id|ahc_set_transaction_status
c_func
(paren
id|scb
comma
id|CAM_SEQUENCE_FAIL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|seq_flags
op_amp
id|NO_CDB_SENT
)paren
op_ne
l_int|0
)paren
(brace
id|ahc_print_path
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;No or incomplete CDB sent to device.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_CONTROL
)paren
op_amp
id|STATUS_RCVD
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * The target never bothered to provide status to&n;&t;&t;&t; * us prior to completing the command.  Since we don&squot;t&n;&t;&t;&t; * know the disposition of this command, we must attempt&n;&t;&t;&t; * to abort it.  Assert ATN and prepare to send an abort&n;&t;&t;&t; * message.&n;&t;&t;&t; */
id|ahc_print_path
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Completed command without status.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|ahc_print_path
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Unknown protocol violation.&bslash;n&quot;
)paren
suffix:semicolon
id|ahc_dump_card_state
c_func
(paren
id|ahc
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|lastphase
op_amp
op_complement
id|P_DATAIN_DT
)paren
op_eq
l_int|0
op_logical_or
id|lastphase
op_eq
id|P_COMMAND
)paren
(brace
id|proto_violation_reset
suffix:colon
multiline_comment|/*&n;&t;&t; * Target either went directly to data/command&n;&t;&t; * phase or didn&squot;t respond to our ATN.&n;&t;&t; * The only safe thing to do is to blow&n;&t;&t; * it away with a bus reset.&n;&t;&t; */
id|found
op_assign
id|ahc_reset_channel
c_func
(paren
id|ahc
comma
l_char|&squot;A&squot;
comma
id|TRUE
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s: Issued Channel %c Bus Reset. &quot;
l_string|&quot;%d SCBs aborted&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
l_char|&squot;A&squot;
comma
id|found
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Leave the selection hardware off in case&n;&t;&t; * this abort attempt will affect yet to&n;&t;&t; * be sent commands.&n;&t;&t; */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSISEQ
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSISEQ
)paren
op_amp
op_complement
id|ENSELO
)paren
suffix:semicolon
id|ahc_assert_atn
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|MSG_OUT
comma
id|HOST_MSG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
id|ahc_print_devinfo
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
)paren
suffix:semicolon
id|ahc-&gt;msgout_buf
(braket
l_int|0
)braket
op_assign
id|MSG_ABORT_TASK
suffix:semicolon
id|ahc-&gt;msgout_len
op_assign
l_int|1
suffix:semicolon
id|ahc-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|ahc-&gt;msg_type
op_assign
id|MSG_TYPE_INITIATOR_MSGOUT
suffix:semicolon
)brace
r_else
(brace
id|ahc_print_path
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_ABORT
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;Protocol violation %s.  Attempting to abort.&bslash;n&quot;
comma
id|ahc_lookup_phase_entry
c_func
(paren
id|curphase
)paren
op_member_access_from_pointer
id|phasemsg
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Manual message loop handler.&n; */
r_static
r_void
DECL|function|ahc_handle_message_phase
id|ahc_handle_message_phase
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_struct
id|ahc_devinfo
id|devinfo
suffix:semicolon
id|u_int
id|bus_phase
suffix:semicolon
r_int
id|end_session
suffix:semicolon
id|ahc_fetch_devinfo
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
)paren
suffix:semicolon
id|end_session
op_assign
id|FALSE
suffix:semicolon
id|bus_phase
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSISIGI
)paren
op_amp
id|PHASE_MASK
suffix:semicolon
id|reswitch
suffix:colon
r_switch
c_cond
(paren
id|ahc-&gt;msg_type
)paren
(brace
r_case
id|MSG_TYPE_INITIATOR_MSGOUT
suffix:colon
(brace
r_int
id|lastbyte
suffix:semicolon
r_int
id|phasemis
suffix:semicolon
r_int
id|msgdone
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;msgout_len
op_eq
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;HOST_MSG_LOOP interrupt with no active message&quot;
)paren
suffix:semicolon
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_MESSAGES
)paren
op_ne
l_int|0
)paren
(brace
id|ahc_print_devinfo
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;INITIATOR_MSG_OUT&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|phasemis
op_assign
id|bus_phase
op_ne
id|P_MESGOUT
suffix:semicolon
r_if
c_cond
(paren
id|phasemis
)paren
(brace
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_MESSAGES
)paren
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot; PHASEMIS %s&bslash;n&quot;
comma
id|ahc_lookup_phase_entry
c_func
(paren
id|bus_phase
)paren
op_member_access_from_pointer
id|phasemsg
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|bus_phase
op_eq
id|P_MESGIN
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Change gears and see if&n;&t;&t;&t;&t; * this messages is of interest to&n;&t;&t;&t;&t; * us or should be passed back to&n;&t;&t;&t;&t; * the sequencer.&n;&t;&t;&t;&t; */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CLRSINT1
comma
id|CLRATNO
)paren
suffix:semicolon
id|ahc-&gt;send_msg_perror
op_assign
id|FALSE
suffix:semicolon
id|ahc-&gt;msg_type
op_assign
id|MSG_TYPE_INITIATOR_MSGIN
suffix:semicolon
id|ahc-&gt;msgin_index
op_assign
l_int|0
suffix:semicolon
r_goto
id|reswitch
suffix:semicolon
)brace
id|end_session
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ahc-&gt;send_msg_perror
)paren
(brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CLRSINT1
comma
id|CLRATNO
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CLRSINT1
comma
id|CLRREQINIT
)paren
suffix:semicolon
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_MESSAGES
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot; byte 0x%x&bslash;n&quot;
comma
id|ahc-&gt;send_msg_perror
)paren
suffix:semicolon
macro_line|#endif
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSIDATL
comma
id|MSG_PARITY_ERROR
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|msgdone
op_assign
id|ahc-&gt;msgout_index
op_eq
id|ahc-&gt;msgout_len
suffix:semicolon
r_if
c_cond
(paren
id|msgdone
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * The target has requested a retry.&n;&t;&t;&t; * Re-assert ATN, reset our message index to&n;&t;&t;&t; * 0, and try again.&n;&t;&t;&t; */
id|ahc-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|ahc_assert_atn
c_func
(paren
id|ahc
)paren
suffix:semicolon
)brace
id|lastbyte
op_assign
id|ahc-&gt;msgout_index
op_eq
(paren
id|ahc-&gt;msgout_len
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lastbyte
)paren
(brace
multiline_comment|/* Last byte is signified by dropping ATN */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CLRSINT1
comma
id|CLRATNO
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Clear our interrupt status and present&n;&t;&t; * the next byte on the bus.&n;&t;&t; */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CLRSINT1
comma
id|CLRREQINIT
)paren
suffix:semicolon
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_MESSAGES
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot; byte 0x%x&bslash;n&quot;
comma
id|ahc-&gt;msgout_buf
(braket
id|ahc-&gt;msgout_index
)braket
)paren
suffix:semicolon
macro_line|#endif
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSIDATL
comma
id|ahc-&gt;msgout_buf
(braket
id|ahc-&gt;msgout_index
op_increment
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MSG_TYPE_INITIATOR_MSGIN
suffix:colon
(brace
r_int
id|phasemis
suffix:semicolon
r_int
id|message_done
suffix:semicolon
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_MESSAGES
)paren
op_ne
l_int|0
)paren
(brace
id|ahc_print_devinfo
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;INITIATOR_MSG_IN&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|phasemis
op_assign
id|bus_phase
op_ne
id|P_MESGIN
suffix:semicolon
r_if
c_cond
(paren
id|phasemis
)paren
(brace
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_MESSAGES
)paren
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot; PHASEMIS %s&bslash;n&quot;
comma
id|ahc_lookup_phase_entry
c_func
(paren
id|bus_phase
)paren
op_member_access_from_pointer
id|phasemsg
)paren
suffix:semicolon
)brace
macro_line|#endif
id|ahc-&gt;msgin_index
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|bus_phase
op_eq
id|P_MESGOUT
op_logical_and
(paren
id|ahc-&gt;send_msg_perror
op_eq
id|TRUE
op_logical_or
(paren
id|ahc-&gt;msgout_len
op_ne
l_int|0
op_logical_and
id|ahc-&gt;msgout_index
op_eq
l_int|0
)paren
)paren
)paren
(brace
id|ahc-&gt;msg_type
op_assign
id|MSG_TYPE_INITIATOR_MSGOUT
suffix:semicolon
r_goto
id|reswitch
suffix:semicolon
)brace
id|end_session
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Pull the byte in without acking it */
id|ahc-&gt;msgin_buf
(braket
id|ahc-&gt;msgin_index
)braket
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSIBUSL
)paren
suffix:semicolon
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_MESSAGES
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot; byte 0x%x&bslash;n&quot;
comma
id|ahc-&gt;msgin_buf
(braket
id|ahc-&gt;msgin_index
)braket
)paren
suffix:semicolon
macro_line|#endif
id|message_done
op_assign
id|ahc_parse_msg
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|message_done
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Clear our incoming message buffer in case there&n;&t;&t;&t; * is another message following this one.&n;&t;&t;&t; */
id|ahc-&gt;msgin_index
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If this message illicited a response,&n;&t;&t;&t; * assert ATN so the target takes us to the&n;&t;&t;&t; * message out phase.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ahc-&gt;msgout_len
op_ne
l_int|0
)paren
(brace
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_MESSAGES
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;Asserting ATN for response&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
r_else
id|ahc-&gt;msgin_index
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|message_done
op_eq
id|MSGLOOP_TERMINATED
)paren
(brace
id|end_session
op_assign
id|TRUE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Ack the byte */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CLRSINT1
comma
id|CLRREQINIT
)paren
suffix:semicolon
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSIDATL
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_case
id|MSG_TYPE_TARGET_MSGIN
suffix:colon
(brace
r_int
id|msgdone
suffix:semicolon
r_int
id|msgout_request
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;msgout_len
op_eq
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;Target MSGIN with no active message&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we interrupted a mesgout session, the initiator&n;&t;&t; * will not know this until our first REQ.  So, we&n;&t;&t; * only honor mesgout requests after we&squot;ve sent our&n;&t;&t; * first byte.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSISIGI
)paren
op_amp
id|ATNI
)paren
op_ne
l_int|0
op_logical_and
id|ahc-&gt;msgout_index
OG
l_int|0
)paren
id|msgout_request
op_assign
id|TRUE
suffix:semicolon
r_else
id|msgout_request
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|msgout_request
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Change gears and see if&n;&t;&t;&t; * this messages is of interest to&n;&t;&t;&t; * us or should be passed back to&n;&t;&t;&t; * the sequencer.&n;&t;&t;&t; */
id|ahc-&gt;msg_type
op_assign
id|MSG_TYPE_TARGET_MSGOUT
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSISIGO
comma
id|P_MESGOUT
op_or
id|BSYO
)paren
suffix:semicolon
id|ahc-&gt;msgin_index
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Dummy read to REQ for first byte */
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSIDATL
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SXFRCTL0
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SXFRCTL0
)paren
op_or
id|SPIOEN
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|msgdone
op_assign
id|ahc-&gt;msgout_index
op_eq
id|ahc-&gt;msgout_len
suffix:semicolon
r_if
c_cond
(paren
id|msgdone
)paren
(brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SXFRCTL0
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SXFRCTL0
)paren
op_amp
op_complement
id|SPIOEN
)paren
suffix:semicolon
id|end_session
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Present the next byte on the bus.&n;&t;&t; */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SXFRCTL0
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SXFRCTL0
)paren
op_or
id|SPIOEN
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSIDATL
comma
id|ahc-&gt;msgout_buf
(braket
id|ahc-&gt;msgout_index
op_increment
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MSG_TYPE_TARGET_MSGOUT
suffix:colon
(brace
r_int
id|lastbyte
suffix:semicolon
r_int
id|msgdone
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The initiator signals that this is&n;&t;&t; * the last byte by dropping ATN.&n;&t;&t; */
id|lastbyte
op_assign
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSISIGI
)paren
op_amp
id|ATNI
)paren
op_eq
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Read the latched byte, but turn off SPIOEN first&n;&t;&t; * so that we don&squot;t inadvertently cause a REQ for the&n;&t;&t; * next byte.&n;&t;&t; */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SXFRCTL0
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SXFRCTL0
)paren
op_amp
op_complement
id|SPIOEN
)paren
suffix:semicolon
id|ahc-&gt;msgin_buf
(braket
id|ahc-&gt;msgin_index
)braket
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSIDATL
)paren
suffix:semicolon
id|msgdone
op_assign
id|ahc_parse_msg
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msgdone
op_eq
id|MSGLOOP_TERMINATED
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * The message is *really* done in that it caused&n;&t;&t;&t; * us to go to bus free.  The sequencer has already&n;&t;&t;&t; * been reset at this point, so pull the ejection&n;&t;&t;&t; * handle.&n;&t;&t;&t; */
r_return
suffix:semicolon
)brace
id|ahc-&gt;msgin_index
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * XXX Read spec about initiator dropping ATN too soon&n;&t;&t; *     and use msgdone to detect it.&n;&t;&t; */
r_if
c_cond
(paren
id|msgdone
op_eq
id|MSGLOOP_MSGCOMPLETE
)paren
(brace
id|ahc-&gt;msgin_index
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If this message illicited a response, transition&n;&t;&t;&t; * to the Message in phase and send it.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ahc-&gt;msgout_len
op_ne
l_int|0
)paren
(brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSISIGO
comma
id|P_MESGIN
op_or
id|BSYO
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SXFRCTL0
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SXFRCTL0
)paren
op_or
id|SPIOEN
)paren
suffix:semicolon
id|ahc-&gt;msg_type
op_assign
id|MSG_TYPE_TARGET_MSGIN
suffix:semicolon
id|ahc-&gt;msgin_index
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|lastbyte
)paren
id|end_session
op_assign
id|TRUE
suffix:semicolon
r_else
(brace
multiline_comment|/* Ask for the next byte. */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SXFRCTL0
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SXFRCTL0
)paren
op_or
id|SPIOEN
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;Unknown REQINIT message type&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|end_session
)paren
(brace
id|ahc_clear_msg_state
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|RETURN_1
comma
id|EXIT_MSG_LOOP
)paren
suffix:semicolon
)brace
r_else
id|ahc_outb
c_func
(paren
id|ahc
comma
id|RETURN_1
comma
id|CONT_MSG_LOOP
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * See if we sent a particular extended message to the target.&n; * If &quot;full&quot; is true, return true only if the target saw the full&n; * message.  If &quot;full&quot; is false, return true if the target saw at&n; * least the first byte of the message.&n; */
r_static
r_int
DECL|function|ahc_sent_msg
id|ahc_sent_msg
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|ahc_msgtype
id|type
comma
id|u_int
id|msgval
comma
r_int
id|full
)paren
(brace
r_int
id|found
suffix:semicolon
id|u_int
id|index
suffix:semicolon
id|found
op_assign
id|FALSE
suffix:semicolon
id|index
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|index
OL
id|ahc-&gt;msgout_len
)paren
(brace
r_if
c_cond
(paren
id|ahc-&gt;msgout_buf
(braket
id|index
)braket
op_eq
id|MSG_EXTENDED
)paren
(brace
id|u_int
id|end_index
suffix:semicolon
id|end_index
op_assign
id|index
op_plus
l_int|1
op_plus
id|ahc-&gt;msgout_buf
(braket
id|index
op_plus
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;msgout_buf
(braket
id|index
op_plus
l_int|2
)braket
op_eq
id|msgval
op_logical_and
id|type
op_eq
id|AHCMSG_EXT
)paren
(brace
r_if
c_cond
(paren
id|full
)paren
(brace
r_if
c_cond
(paren
id|ahc-&gt;msgout_index
OG
id|end_index
)paren
id|found
op_assign
id|TRUE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ahc-&gt;msgout_index
OG
id|index
)paren
id|found
op_assign
id|TRUE
suffix:semicolon
)brace
id|index
op_assign
id|end_index
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ahc-&gt;msgout_buf
(braket
id|index
)braket
op_ge
id|MSG_SIMPLE_TASK
op_logical_and
id|ahc-&gt;msgout_buf
(braket
id|index
)braket
op_le
id|MSG_IGN_WIDE_RESIDUE
)paren
(brace
multiline_comment|/* Skip tag type and tag id or residue param*/
id|index
op_add_assign
l_int|2
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Single byte message */
r_if
c_cond
(paren
id|type
op_eq
id|AHCMSG_1B
op_logical_and
id|ahc-&gt;msgout_buf
(braket
id|index
)braket
op_eq
id|msgval
op_logical_and
id|ahc-&gt;msgout_index
OG
id|index
)paren
id|found
op_assign
id|TRUE
suffix:semicolon
id|index
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|found
)paren
r_break
suffix:semicolon
)brace
r_return
(paren
id|found
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait for a complete incoming message, parse it, and respond accordingly.&n; */
r_static
r_int
DECL|function|ahc_parse_msg
id|ahc_parse_msg
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
)paren
(brace
r_struct
id|ahc_initiator_tinfo
op_star
id|tinfo
suffix:semicolon
r_struct
id|ahc_tmode_tstate
op_star
id|tstate
suffix:semicolon
r_int
id|reject
suffix:semicolon
r_int
id|done
suffix:semicolon
r_int
id|response
suffix:semicolon
id|u_int
id|targ_scsirate
suffix:semicolon
id|done
op_assign
id|MSGLOOP_IN_PROG
suffix:semicolon
id|response
op_assign
id|FALSE
suffix:semicolon
id|reject
op_assign
id|FALSE
suffix:semicolon
id|tinfo
op_assign
id|ahc_fetch_transinfo
c_func
(paren
id|ahc
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;our_scsiid
comma
id|devinfo-&gt;target
comma
op_amp
id|tstate
)paren
suffix:semicolon
id|targ_scsirate
op_assign
id|tinfo-&gt;scsirate
suffix:semicolon
multiline_comment|/*&n;&t; * Parse as much of the message as is availible,&n;&t; * rejecting it if we don&squot;t support it.  When&n;&t; * the entire message is availible and has been&n;&t; * handled, return MSGLOOP_MSGCOMPLETE, indicating&n;&t; * that we have parsed an entire message.&n;&t; *&n;&t; * In the case of extended messages, we accept the length&n;&t; * byte outright and perform more checking once we know the&n;&t; * extended message type.&n;&t; */
r_switch
c_cond
(paren
id|ahc-&gt;msgin_buf
(braket
l_int|0
)braket
)paren
(brace
r_case
id|MSG_DISCONNECT
suffix:colon
r_case
id|MSG_SAVEDATAPOINTER
suffix:colon
r_case
id|MSG_CMDCOMPLETE
suffix:colon
r_case
id|MSG_RESTOREPOINTERS
suffix:colon
r_case
id|MSG_IGN_WIDE_RESIDUE
suffix:colon
multiline_comment|/*&n;&t;&t; * End our message loop as these are messages&n;&t;&t; * the sequencer handles on its own.&n;&t;&t; */
id|done
op_assign
id|MSGLOOP_TERMINATED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MSG_MESSAGE_REJECT
suffix:colon
id|response
op_assign
id|ahc_handle_msg_reject
c_func
(paren
id|ahc
comma
id|devinfo
)paren
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_case
id|MSG_NOOP
suffix:colon
id|done
op_assign
id|MSGLOOP_MSGCOMPLETE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MSG_EXTENDED
suffix:colon
(brace
multiline_comment|/* Wait for enough of the message to begin validation */
r_if
c_cond
(paren
id|ahc-&gt;msgin_index
OL
l_int|2
)paren
r_break
suffix:semicolon
r_switch
c_cond
(paren
id|ahc-&gt;msgin_buf
(braket
l_int|2
)braket
)paren
(brace
r_case
id|MSG_EXT_SDTR
suffix:colon
(brace
r_struct
id|ahc_syncrate
op_star
id|syncrate
suffix:semicolon
id|u_int
id|period
suffix:semicolon
id|u_int
id|ppr_options
suffix:semicolon
id|u_int
id|offset
suffix:semicolon
id|u_int
id|saved_offset
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;msgin_buf
(braket
l_int|1
)braket
op_ne
id|MSG_EXT_SDTR_LEN
)paren
(brace
id|reject
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Wait until we have both args before validating&n;&t;&t;&t; * and acting on this message.&n;&t;&t;&t; *&n;&t;&t;&t; * Add one to MSG_EXT_SDTR_LEN to account for&n;&t;&t;&t; * the extended message preamble.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ahc-&gt;msgin_index
OL
(paren
id|MSG_EXT_SDTR_LEN
op_plus
l_int|1
)paren
)paren
r_break
suffix:semicolon
id|period
op_assign
id|ahc-&gt;msgin_buf
(braket
l_int|3
)braket
suffix:semicolon
id|ppr_options
op_assign
l_int|0
suffix:semicolon
id|saved_offset
op_assign
id|offset
op_assign
id|ahc-&gt;msgin_buf
(braket
l_int|4
)braket
suffix:semicolon
id|syncrate
op_assign
id|ahc_devlimited_syncrate
c_func
(paren
id|ahc
comma
id|tinfo
comma
op_amp
id|period
comma
op_amp
id|ppr_options
comma
id|devinfo-&gt;role
)paren
suffix:semicolon
id|ahc_validate_offset
c_func
(paren
id|ahc
comma
id|tinfo
comma
id|syncrate
comma
op_amp
id|offset
comma
id|targ_scsirate
op_amp
id|WIDEXFER
comma
id|devinfo-&gt;role
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;(%s:%c:%d:%d): Received &quot;
l_string|&quot;SDTR period %x, offset %x&bslash;n&bslash;t&quot;
l_string|&quot;Filtered to period %x, offset %x&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
comma
id|ahc-&gt;msgin_buf
(braket
l_int|3
)braket
comma
id|saved_offset
comma
id|period
comma
id|offset
)paren
suffix:semicolon
)brace
id|ahc_set_syncrate
c_func
(paren
id|ahc
comma
id|devinfo
comma
id|syncrate
comma
id|period
comma
id|offset
comma
id|ppr_options
comma
id|AHC_TRANS_ACTIVE
op_or
id|AHC_TRANS_GOAL
comma
multiline_comment|/*paused*/
id|TRUE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * See if we initiated Sync Negotiation&n;&t;&t;&t; * and didn&squot;t have to fall down to async&n;&t;&t;&t; * transfers.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ahc_sent_msg
c_func
(paren
id|ahc
comma
id|AHCMSG_EXT
comma
id|MSG_EXT_SDTR
comma
id|TRUE
)paren
)paren
(brace
multiline_comment|/* We started it */
r_if
c_cond
(paren
id|saved_offset
op_ne
id|offset
)paren
(brace
multiline_comment|/* Went too low - force async */
id|reject
op_assign
id|TRUE
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Send our own SDTR in reply&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|bootverbose
op_logical_and
id|devinfo-&gt;role
op_eq
id|ROLE_INITIATOR
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;(%s:%c:%d:%d): Target &quot;
l_string|&quot;Initiated SDTR&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
)paren
suffix:semicolon
)brace
id|ahc-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|ahc-&gt;msgout_len
op_assign
l_int|0
suffix:semicolon
id|ahc_construct_sdtr
c_func
(paren
id|ahc
comma
id|devinfo
comma
id|period
comma
id|offset
)paren
suffix:semicolon
id|ahc-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|response
op_assign
id|TRUE
suffix:semicolon
)brace
id|done
op_assign
id|MSGLOOP_MSGCOMPLETE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MSG_EXT_WDTR
suffix:colon
(brace
id|u_int
id|bus_width
suffix:semicolon
id|u_int
id|saved_width
suffix:semicolon
id|u_int
id|sending_reply
suffix:semicolon
id|sending_reply
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;msgin_buf
(braket
l_int|1
)braket
op_ne
id|MSG_EXT_WDTR_LEN
)paren
(brace
id|reject
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Wait until we have our arg before validating&n;&t;&t;&t; * and acting on this message.&n;&t;&t;&t; *&n;&t;&t;&t; * Add one to MSG_EXT_WDTR_LEN to account for&n;&t;&t;&t; * the extended message preamble.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ahc-&gt;msgin_index
OL
(paren
id|MSG_EXT_WDTR_LEN
op_plus
l_int|1
)paren
)paren
r_break
suffix:semicolon
id|bus_width
op_assign
id|ahc-&gt;msgin_buf
(braket
l_int|3
)braket
suffix:semicolon
id|saved_width
op_assign
id|bus_width
suffix:semicolon
id|ahc_validate_width
c_func
(paren
id|ahc
comma
id|tinfo
comma
op_amp
id|bus_width
comma
id|devinfo-&gt;role
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;(%s:%c:%d:%d): Received WDTR &quot;
l_string|&quot;%x filtered to %x&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
comma
id|saved_width
comma
id|bus_width
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ahc_sent_msg
c_func
(paren
id|ahc
comma
id|AHCMSG_EXT
comma
id|MSG_EXT_WDTR
comma
id|TRUE
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Don&squot;t send a WDTR back to the&n;&t;&t;&t;&t; * target, since we asked first.&n;&t;&t;&t;&t; * If the width went higher than our&n;&t;&t;&t;&t; * request, reject it.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|saved_width
OG
id|bus_width
)paren
(brace
id|reject
op_assign
id|TRUE
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;(%s:%c:%d:%d): requested %dBit &quot;
l_string|&quot;transfers.  Rejecting...&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
comma
l_int|8
op_star
(paren
l_int|0x01
op_lshift
id|bus_width
)paren
)paren
suffix:semicolon
id|bus_width
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Send our own WDTR in reply&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|bootverbose
op_logical_and
id|devinfo-&gt;role
op_eq
id|ROLE_INITIATOR
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;(%s:%c:%d:%d): Target &quot;
l_string|&quot;Initiated WDTR&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
)paren
suffix:semicolon
)brace
id|ahc-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|ahc-&gt;msgout_len
op_assign
l_int|0
suffix:semicolon
id|ahc_construct_wdtr
c_func
(paren
id|ahc
comma
id|devinfo
comma
id|bus_width
)paren
suffix:semicolon
id|ahc-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|response
op_assign
id|TRUE
suffix:semicolon
id|sending_reply
op_assign
id|TRUE
suffix:semicolon
)brace
id|ahc_set_width
c_func
(paren
id|ahc
comma
id|devinfo
comma
id|bus_width
comma
id|AHC_TRANS_ACTIVE
op_or
id|AHC_TRANS_GOAL
comma
multiline_comment|/*paused*/
id|TRUE
)paren
suffix:semicolon
multiline_comment|/* After a wide message, we are async */
id|ahc_set_syncrate
c_func
(paren
id|ahc
comma
id|devinfo
comma
multiline_comment|/*syncrate*/
l_int|NULL
comma
multiline_comment|/*period*/
l_int|0
comma
multiline_comment|/*offset*/
l_int|0
comma
multiline_comment|/*ppr_options*/
l_int|0
comma
id|AHC_TRANS_ACTIVE
comma
multiline_comment|/*paused*/
id|TRUE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sending_reply
op_eq
id|FALSE
op_logical_and
id|reject
op_eq
id|FALSE
)paren
(brace
r_if
c_cond
(paren
id|tinfo-&gt;goal.offset
)paren
(brace
id|ahc-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|ahc-&gt;msgout_len
op_assign
l_int|0
suffix:semicolon
id|ahc_build_transfer_msg
c_func
(paren
id|ahc
comma
id|devinfo
)paren
suffix:semicolon
id|ahc-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|response
op_assign
id|TRUE
suffix:semicolon
)brace
)brace
id|done
op_assign
id|MSGLOOP_MSGCOMPLETE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MSG_EXT_PPR
suffix:colon
(brace
r_struct
id|ahc_syncrate
op_star
id|syncrate
suffix:semicolon
id|u_int
id|period
suffix:semicolon
id|u_int
id|offset
suffix:semicolon
id|u_int
id|bus_width
suffix:semicolon
id|u_int
id|ppr_options
suffix:semicolon
id|u_int
id|saved_width
suffix:semicolon
id|u_int
id|saved_offset
suffix:semicolon
id|u_int
id|saved_ppr_options
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;msgin_buf
(braket
l_int|1
)braket
op_ne
id|MSG_EXT_PPR_LEN
)paren
(brace
id|reject
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Wait until we have all args before validating&n;&t;&t;&t; * and acting on this message.&n;&t;&t;&t; *&n;&t;&t;&t; * Add one to MSG_EXT_PPR_LEN to account for&n;&t;&t;&t; * the extended message preamble.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ahc-&gt;msgin_index
OL
(paren
id|MSG_EXT_PPR_LEN
op_plus
l_int|1
)paren
)paren
r_break
suffix:semicolon
id|period
op_assign
id|ahc-&gt;msgin_buf
(braket
l_int|3
)braket
suffix:semicolon
id|offset
op_assign
id|ahc-&gt;msgin_buf
(braket
l_int|5
)braket
suffix:semicolon
id|bus_width
op_assign
id|ahc-&gt;msgin_buf
(braket
l_int|6
)braket
suffix:semicolon
id|saved_width
op_assign
id|bus_width
suffix:semicolon
id|ppr_options
op_assign
id|ahc-&gt;msgin_buf
(braket
l_int|7
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * According to the spec, a DT only&n;&t;&t;&t; * period factor with no DT option&n;&t;&t;&t; * set implies async.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|ppr_options
op_amp
id|MSG_EXT_PPR_DT_REQ
)paren
op_eq
l_int|0
op_logical_and
id|period
op_eq
l_int|9
)paren
id|offset
op_assign
l_int|0
suffix:semicolon
id|saved_ppr_options
op_assign
id|ppr_options
suffix:semicolon
id|saved_offset
op_assign
id|offset
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Mask out any options we don&squot;t support&n;&t;&t;&t; * on any controller.  Transfer options are&n;&t;&t;&t; * only available if we are negotiating wide.&n;&t;&t;&t; */
id|ppr_options
op_and_assign
id|MSG_EXT_PPR_DT_REQ
suffix:semicolon
r_if
c_cond
(paren
id|bus_width
op_eq
l_int|0
)paren
id|ppr_options
op_assign
l_int|0
suffix:semicolon
id|ahc_validate_width
c_func
(paren
id|ahc
comma
id|tinfo
comma
op_amp
id|bus_width
comma
id|devinfo-&gt;role
)paren
suffix:semicolon
id|syncrate
op_assign
id|ahc_devlimited_syncrate
c_func
(paren
id|ahc
comma
id|tinfo
comma
op_amp
id|period
comma
op_amp
id|ppr_options
comma
id|devinfo-&gt;role
)paren
suffix:semicolon
id|ahc_validate_offset
c_func
(paren
id|ahc
comma
id|tinfo
comma
id|syncrate
comma
op_amp
id|offset
comma
id|bus_width
comma
id|devinfo-&gt;role
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc_sent_msg
c_func
(paren
id|ahc
comma
id|AHCMSG_EXT
comma
id|MSG_EXT_PPR
comma
id|TRUE
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * If we are unable to do any of the&n;&t;&t;&t;&t; * requested options (we went too low),&n;&t;&t;&t;&t; * then we&squot;ll have to reject the message.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|saved_width
OG
id|bus_width
op_logical_or
id|saved_offset
op_ne
id|offset
op_logical_or
id|saved_ppr_options
op_ne
id|ppr_options
)paren
(brace
id|reject
op_assign
id|TRUE
suffix:semicolon
id|period
op_assign
l_int|0
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
id|bus_width
op_assign
l_int|0
suffix:semicolon
id|ppr_options
op_assign
l_int|0
suffix:semicolon
id|syncrate
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|devinfo-&gt;role
op_ne
id|ROLE_TARGET
)paren
id|printf
c_func
(paren
l_string|&quot;(%s:%c:%d:%d): Target &quot;
l_string|&quot;Initiated PPR&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot;(%s:%c:%d:%d): Initiator &quot;
l_string|&quot;Initiated PPR&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
)paren
suffix:semicolon
id|ahc-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|ahc-&gt;msgout_len
op_assign
l_int|0
suffix:semicolon
id|ahc_construct_ppr
c_func
(paren
id|ahc
comma
id|devinfo
comma
id|period
comma
id|offset
comma
id|bus_width
comma
id|ppr_options
)paren
suffix:semicolon
id|ahc-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|response
op_assign
id|TRUE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bootverbose
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;(%s:%c:%d:%d): Received PPR width %x, &quot;
l_string|&quot;period %x, offset %x,options %x&bslash;n&quot;
l_string|&quot;&bslash;tFiltered to width %x, period %x, &quot;
l_string|&quot;offset %x, options %x&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
comma
id|saved_width
comma
id|ahc-&gt;msgin_buf
(braket
l_int|3
)braket
comma
id|saved_offset
comma
id|saved_ppr_options
comma
id|bus_width
comma
id|period
comma
id|offset
comma
id|ppr_options
)paren
suffix:semicolon
)brace
id|ahc_set_width
c_func
(paren
id|ahc
comma
id|devinfo
comma
id|bus_width
comma
id|AHC_TRANS_ACTIVE
op_or
id|AHC_TRANS_GOAL
comma
multiline_comment|/*paused*/
id|TRUE
)paren
suffix:semicolon
id|ahc_set_syncrate
c_func
(paren
id|ahc
comma
id|devinfo
comma
id|syncrate
comma
id|period
comma
id|offset
comma
id|ppr_options
comma
id|AHC_TRANS_ACTIVE
op_or
id|AHC_TRANS_GOAL
comma
multiline_comment|/*paused*/
id|TRUE
)paren
suffix:semicolon
id|done
op_assign
id|MSGLOOP_MSGCOMPLETE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
multiline_comment|/* Unknown extended message.  Reject it. */
id|reject
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
macro_line|#ifdef AHC_TARGET_MODE
r_case
id|MSG_BUS_DEV_RESET
suffix:colon
id|ahc_handle_devreset
c_func
(paren
id|ahc
comma
id|devinfo
comma
id|CAM_BDR_SENT
comma
l_string|&quot;Bus Device Reset Received&quot;
comma
multiline_comment|/*verbose_level*/
l_int|0
)paren
suffix:semicolon
id|ahc_restart
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|done
op_assign
id|MSGLOOP_TERMINATED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MSG_ABORT_TAG
suffix:colon
r_case
id|MSG_ABORT
suffix:colon
r_case
id|MSG_CLEAR_QUEUE
suffix:colon
(brace
r_int
id|tag
suffix:semicolon
multiline_comment|/* Target mode messages */
r_if
c_cond
(paren
id|devinfo-&gt;role
op_ne
id|ROLE_TARGET
)paren
(brace
id|reject
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tag
op_assign
id|SCB_LIST_NULL
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;msgin_buf
(braket
l_int|0
)braket
op_eq
id|MSG_ABORT_TAG
)paren
id|tag
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|INITIATOR_TAG
)paren
suffix:semicolon
id|ahc_abort_scbs
c_func
(paren
id|ahc
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;lun
comma
id|tag
comma
id|ROLE_TARGET
comma
id|CAM_REQ_ABORTED
)paren
suffix:semicolon
id|tstate
op_assign
id|ahc-&gt;enabled_targets
(braket
id|devinfo-&gt;our_scsiid
)braket
suffix:semicolon
r_if
c_cond
(paren
id|tstate
op_ne
l_int|NULL
)paren
(brace
r_struct
id|ahc_tmode_lstate
op_star
id|lstate
suffix:semicolon
id|lstate
op_assign
id|tstate-&gt;enabled_luns
(braket
id|devinfo-&gt;lun
)braket
suffix:semicolon
r_if
c_cond
(paren
id|lstate
op_ne
l_int|NULL
)paren
(brace
id|ahc_queue_lstate_event
c_func
(paren
id|ahc
comma
id|lstate
comma
id|devinfo-&gt;our_scsiid
comma
id|ahc-&gt;msgin_buf
(braket
l_int|0
)braket
comma
multiline_comment|/*arg*/
id|tag
)paren
suffix:semicolon
id|ahc_send_lstate_events
c_func
(paren
id|ahc
comma
id|lstate
)paren
suffix:semicolon
)brace
)brace
id|ahc_restart
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|done
op_assign
id|MSGLOOP_TERMINATED
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif
r_case
id|MSG_TERM_IO_PROC
suffix:colon
r_default
suffix:colon
id|reject
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reject
)paren
(brace
multiline_comment|/*&n;&t;&t; * Setup to reject the message.&n;&t;&t; */
id|ahc-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|ahc-&gt;msgout_len
op_assign
l_int|1
suffix:semicolon
id|ahc-&gt;msgout_buf
(braket
l_int|0
)braket
op_assign
id|MSG_MESSAGE_REJECT
suffix:semicolon
id|done
op_assign
id|MSGLOOP_MSGCOMPLETE
suffix:semicolon
id|response
op_assign
id|TRUE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|done
op_ne
id|MSGLOOP_IN_PROG
op_logical_and
op_logical_neg
id|response
)paren
multiline_comment|/* Clear the outgoing message buffer */
id|ahc-&gt;msgout_len
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|done
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Process a message reject message.&n; */
r_static
r_int
DECL|function|ahc_handle_msg_reject
id|ahc_handle_msg_reject
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
)paren
(brace
multiline_comment|/*&n;&t; * What we care about here is if we had an&n;&t; * outstanding SDTR or WDTR message for this&n;&t; * target.  If we did, this is a signal that&n;&t; * the target is refusing negotiation.&n;&t; */
r_struct
id|scb
op_star
id|scb
suffix:semicolon
r_struct
id|ahc_initiator_tinfo
op_star
id|tinfo
suffix:semicolon
r_struct
id|ahc_tmode_tstate
op_star
id|tstate
suffix:semicolon
id|u_int
id|scb_index
suffix:semicolon
id|u_int
id|last_msg
suffix:semicolon
r_int
id|response
op_assign
l_int|0
suffix:semicolon
id|scb_index
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_TAG
)paren
suffix:semicolon
id|scb
op_assign
id|ahc_lookup_scb
c_func
(paren
id|ahc
comma
id|scb_index
)paren
suffix:semicolon
id|tinfo
op_assign
id|ahc_fetch_transinfo
c_func
(paren
id|ahc
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;our_scsiid
comma
id|devinfo-&gt;target
comma
op_amp
id|tstate
)paren
suffix:semicolon
multiline_comment|/* Might be necessary */
id|last_msg
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|LAST_MSG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc_sent_msg
c_func
(paren
id|ahc
comma
id|AHCMSG_EXT
comma
id|MSG_EXT_PPR
comma
multiline_comment|/*full*/
id|FALSE
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Target does not support the PPR message.&n;&t;&t; * Attempt to negotiate SPI-2 style.&n;&t;&t; */
r_if
c_cond
(paren
id|bootverbose
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;(%s:%c:%d:%d): PPR Rejected. &quot;
l_string|&quot;Trying WDTR/SDTR&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
)paren
suffix:semicolon
)brace
id|tinfo-&gt;goal.ppr_options
op_assign
l_int|0
suffix:semicolon
id|tinfo-&gt;curr.transport_version
op_assign
l_int|2
suffix:semicolon
id|tinfo-&gt;goal.transport_version
op_assign
l_int|2
suffix:semicolon
id|ahc-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|ahc-&gt;msgout_len
op_assign
l_int|0
suffix:semicolon
id|ahc_build_transfer_msg
c_func
(paren
id|ahc
comma
id|devinfo
)paren
suffix:semicolon
id|ahc-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|response
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ahc_sent_msg
c_func
(paren
id|ahc
comma
id|AHCMSG_EXT
comma
id|MSG_EXT_WDTR
comma
multiline_comment|/*full*/
id|FALSE
)paren
)paren
(brace
multiline_comment|/* note 8bit xfers */
id|printf
c_func
(paren
l_string|&quot;(%s:%c:%d:%d): refuses WIDE negotiation.  Using &quot;
l_string|&quot;8bit transfers&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
)paren
suffix:semicolon
id|ahc_set_width
c_func
(paren
id|ahc
comma
id|devinfo
comma
id|MSG_EXT_WDTR_BUS_8_BIT
comma
id|AHC_TRANS_ACTIVE
op_or
id|AHC_TRANS_GOAL
comma
multiline_comment|/*paused*/
id|TRUE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * No need to clear the sync rate.  If the target&n;&t;&t; * did not accept the command, our syncrate is&n;&t;&t; * unaffected.  If the target started the negotiation,&n;&t;&t; * but rejected our response, we already cleared the&n;&t;&t; * sync rate before sending our WDTR.&n;&t;&t; */
r_if
c_cond
(paren
id|tinfo-&gt;goal.offset
)paren
(brace
multiline_comment|/* Start the sync negotiation */
id|ahc-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|ahc-&gt;msgout_len
op_assign
l_int|0
suffix:semicolon
id|ahc_build_transfer_msg
c_func
(paren
id|ahc
comma
id|devinfo
)paren
suffix:semicolon
id|ahc-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|response
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|ahc_sent_msg
c_func
(paren
id|ahc
comma
id|AHCMSG_EXT
comma
id|MSG_EXT_SDTR
comma
multiline_comment|/*full*/
id|FALSE
)paren
)paren
(brace
multiline_comment|/* note asynch xfers and clear flag */
id|ahc_set_syncrate
c_func
(paren
id|ahc
comma
id|devinfo
comma
multiline_comment|/*syncrate*/
l_int|NULL
comma
multiline_comment|/*period*/
l_int|0
comma
multiline_comment|/*offset*/
l_int|0
comma
multiline_comment|/*ppr_options*/
l_int|0
comma
id|AHC_TRANS_ACTIVE
op_or
id|AHC_TRANS_GOAL
comma
multiline_comment|/*paused*/
id|TRUE
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;(%s:%c:%d:%d): refuses synchronous negotiation. &quot;
l_string|&quot;Using asynchronous transfers&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|scb-&gt;hscb-&gt;control
op_amp
id|MSG_SIMPLE_TASK
)paren
op_ne
l_int|0
)paren
(brace
r_int
id|tag_type
suffix:semicolon
r_int
id|mask
suffix:semicolon
id|tag_type
op_assign
(paren
id|scb-&gt;hscb-&gt;control
op_amp
id|MSG_SIMPLE_TASK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tag_type
op_eq
id|MSG_SIMPLE_TASK
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;(%s:%c:%d:%d): refuses tagged commands.  &quot;
l_string|&quot;Performing non-tagged I/O&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
)paren
suffix:semicolon
id|ahc_set_tags
c_func
(paren
id|ahc
comma
id|devinfo
comma
id|AHC_QUEUE_NONE
)paren
suffix:semicolon
id|mask
op_assign
op_complement
l_int|0x23
suffix:semicolon
)brace
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;(%s:%c:%d:%d): refuses %s tagged commands.  &quot;
l_string|&quot;Performing simple queue tagged I/O only&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
comma
id|tag_type
op_eq
id|MSG_ORDERED_TASK
ques
c_cond
l_string|&quot;ordered&quot;
suffix:colon
l_string|&quot;head of queue&quot;
)paren
suffix:semicolon
id|ahc_set_tags
c_func
(paren
id|ahc
comma
id|devinfo
comma
id|AHC_QUEUE_BASIC
)paren
suffix:semicolon
id|mask
op_assign
op_complement
l_int|0x03
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Resend the identify for this CCB as the target&n;&t;&t; * may believe that the selection is invalid otherwise.&n;&t;&t; */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCB_CONTROL
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_CONTROL
)paren
op_amp
id|mask
)paren
suffix:semicolon
id|scb-&gt;hscb-&gt;control
op_and_assign
id|mask
suffix:semicolon
id|ahc_set_transaction_tag
c_func
(paren
id|scb
comma
multiline_comment|/*enabled*/
id|FALSE
comma
multiline_comment|/*type*/
id|MSG_SIMPLE_TASK
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|MSG_OUT
comma
id|MSG_IDENTIFYFLAG
)paren
suffix:semicolon
id|ahc_assert_atn
c_func
(paren
id|ahc
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This transaction is now at the head of&n;&t;&t; * the untagged queue for this target.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ahc-&gt;flags
op_amp
id|AHC_SCB_BTT
)paren
op_eq
l_int|0
)paren
(brace
r_struct
id|scb_tailq
op_star
id|untagged_q
suffix:semicolon
id|untagged_q
op_assign
op_amp
(paren
id|ahc-&gt;untagged_queues
(braket
id|devinfo-&gt;target_offset
)braket
)paren
suffix:semicolon
id|TAILQ_INSERT_HEAD
c_func
(paren
id|untagged_q
comma
id|scb
comma
id|links.tqe
)paren
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_UNTAGGEDQ
suffix:semicolon
)brace
id|ahc_busy_tcl
c_func
(paren
id|ahc
comma
id|BUILD_TCL
c_func
(paren
id|scb-&gt;hscb-&gt;scsiid
comma
id|devinfo-&gt;lun
)paren
comma
id|scb-&gt;hscb-&gt;tag
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Requeue all tagged commands for this target&n;&t;&t; * currently in our posession so they can be&n;&t;&t; * converted to untagged commands.&n;&t;&t; */
id|ahc_search_qinfifo
c_func
(paren
id|ahc
comma
id|SCB_GET_TARGET
c_func
(paren
id|ahc
comma
id|scb
)paren
comma
id|SCB_GET_CHANNEL
c_func
(paren
id|ahc
comma
id|scb
)paren
comma
id|SCB_GET_LUN
c_func
(paren
id|scb
)paren
comma
multiline_comment|/*tag*/
id|SCB_LIST_NULL
comma
id|ROLE_INITIATOR
comma
id|CAM_REQUEUE_REQ
comma
id|SEARCH_COMPLETE
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Otherwise, we ignore it.&n;&t;&t; */
id|printf
c_func
(paren
l_string|&quot;%s:%c:%d: Message reject for %x -- ignored&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|last_msg
)paren
suffix:semicolon
)brace
r_return
(paren
id|response
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Process an ingnore wide residue message.&n; */
r_static
r_void
DECL|function|ahc_handle_ign_wide_residue
id|ahc_handle_ign_wide_residue
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
)paren
(brace
id|u_int
id|scb_index
suffix:semicolon
r_struct
id|scb
op_star
id|scb
suffix:semicolon
id|scb_index
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_TAG
)paren
suffix:semicolon
id|scb
op_assign
id|ahc_lookup_scb
c_func
(paren
id|ahc
comma
id|scb_index
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * XXX Actually check data direction in the sequencer?&n;&t; * Perhaps add datadir to some spare bits in the hscb?&n;&t; */
r_if
c_cond
(paren
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SEQ_FLAGS
)paren
op_amp
id|DPHASE
)paren
op_eq
l_int|0
op_logical_or
id|ahc_get_transfer_dir
c_func
(paren
id|scb
)paren
op_ne
id|CAM_DIR_IN
)paren
(brace
multiline_comment|/*&n;&t;&t; * Ignore the message if we haven&squot;t&n;&t;&t; * seen an appropriate data phase yet.&n;&t;&t; */
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * If the residual occurred on the last&n;&t;&t; * transfer and the transfer request was&n;&t;&t; * expected to end on an odd count, do&n;&t;&t; * nothing.  Otherwise, subtract a byte&n;&t;&t; * and update the residual count accordingly.&n;&t;&t; */
r_uint32
id|sgptr
suffix:semicolon
id|sgptr
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_RESIDUAL_SGPTR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sgptr
op_amp
id|SG_LIST_NULL
)paren
op_ne
l_int|0
op_logical_and
id|ahc_inb
c_func
(paren
id|ahc
comma
id|DATA_COUNT_ODD
)paren
op_eq
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If the residual occurred on the last&n;&t;&t;&t; * transfer and the transfer request was&n;&t;&t;&t; * expected to end on an odd count, do&n;&t;&t;&t; * nothing.&n;&t;&t;&t; */
)brace
r_else
(brace
r_struct
id|ahc_dma_seg
op_star
id|sg
suffix:semicolon
r_uint32
id|data_cnt
suffix:semicolon
r_uint32
id|data_addr
suffix:semicolon
r_uint32
id|sglen
suffix:semicolon
multiline_comment|/* Pull in the rest of the sgptr */
id|sgptr
op_or_assign
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_RESIDUAL_SGPTR
op_plus
l_int|3
)paren
op_lshift
l_int|24
)paren
op_or
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_RESIDUAL_SGPTR
op_plus
l_int|2
)paren
op_lshift
l_int|16
)paren
op_or
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_RESIDUAL_SGPTR
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
id|sgptr
op_and_assign
id|SG_PTR_MASK
suffix:semicolon
id|data_cnt
op_assign
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_RESIDUAL_DATACNT
op_plus
l_int|3
)paren
op_lshift
l_int|24
)paren
op_or
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_RESIDUAL_DATACNT
op_plus
l_int|2
)paren
op_lshift
l_int|16
)paren
op_or
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_RESIDUAL_DATACNT
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_RESIDUAL_DATACNT
)paren
)paren
suffix:semicolon
id|data_addr
op_assign
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SHADDR
op_plus
l_int|3
)paren
op_lshift
l_int|24
)paren
op_or
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SHADDR
op_plus
l_int|2
)paren
op_lshift
l_int|16
)paren
op_or
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SHADDR
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SHADDR
)paren
)paren
suffix:semicolon
id|data_cnt
op_add_assign
l_int|1
suffix:semicolon
id|data_addr
op_sub_assign
l_int|1
suffix:semicolon
id|sg
op_assign
id|ahc_sg_bus_to_virt
c_func
(paren
id|scb
comma
id|sgptr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * The residual sg ptr points to the next S/G&n;&t;&t;&t; * to load so we must go back one.&n;&t;&t;&t; */
id|sg
op_decrement
suffix:semicolon
id|sglen
op_assign
id|ahc_le32toh
c_func
(paren
id|sg-&gt;len
)paren
op_amp
id|AHC_SG_LEN_MASK
suffix:semicolon
r_if
c_cond
(paren
id|sg
op_ne
id|scb-&gt;sg_list
op_logical_and
id|sglen
OL
(paren
id|data_cnt
op_amp
id|AHC_SG_LEN_MASK
)paren
)paren
(brace
id|sg
op_decrement
suffix:semicolon
id|sglen
op_assign
id|ahc_le32toh
c_func
(paren
id|sg-&gt;len
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Preserve High Address and SG_LIST bits&n;&t;&t;&t;&t; * while setting the count to 1.&n;&t;&t;&t;&t; */
id|data_cnt
op_assign
l_int|1
op_or
(paren
id|sglen
op_amp
(paren
op_complement
id|AHC_SG_LEN_MASK
)paren
)paren
suffix:semicolon
id|data_addr
op_assign
id|ahc_le32toh
c_func
(paren
id|sg-&gt;addr
)paren
op_plus
(paren
id|sglen
op_amp
id|AHC_SG_LEN_MASK
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Increment sg so it points to the&n;&t;&t;&t;&t; * &quot;next&quot; sg.&n;&t;&t;&t;&t; */
id|sg
op_increment
suffix:semicolon
id|sgptr
op_assign
id|ahc_sg_virt_to_bus
c_func
(paren
id|scb
comma
id|sg
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCB_RESIDUAL_SGPTR
op_plus
l_int|3
comma
id|sgptr
op_rshift
l_int|24
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCB_RESIDUAL_SGPTR
op_plus
l_int|2
comma
id|sgptr
op_rshift
l_int|16
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCB_RESIDUAL_SGPTR
op_plus
l_int|1
comma
id|sgptr
op_rshift
l_int|8
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCB_RESIDUAL_SGPTR
comma
id|sgptr
)paren
suffix:semicolon
)brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCB_RESIDUAL_DATACNT
op_plus
l_int|3
comma
id|data_cnt
op_rshift
l_int|24
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCB_RESIDUAL_DATACNT
op_plus
l_int|2
comma
id|data_cnt
op_rshift
l_int|16
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCB_RESIDUAL_DATACNT
op_plus
l_int|1
comma
id|data_cnt
op_rshift
l_int|8
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCB_RESIDUAL_DATACNT
comma
id|data_cnt
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Reinitialize the data pointers for the active transfer&n; * based on its current residual.&n; */
r_static
r_void
DECL|function|ahc_reinitialize_dataptrs
id|ahc_reinitialize_dataptrs
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_struct
id|scb
op_star
id|scb
suffix:semicolon
r_struct
id|ahc_dma_seg
op_star
id|sg
suffix:semicolon
id|u_int
id|scb_index
suffix:semicolon
r_uint32
id|sgptr
suffix:semicolon
r_uint32
id|resid
suffix:semicolon
r_uint32
id|dataptr
suffix:semicolon
id|scb_index
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_TAG
)paren
suffix:semicolon
id|scb
op_assign
id|ahc_lookup_scb
c_func
(paren
id|ahc
comma
id|scb_index
)paren
suffix:semicolon
id|sgptr
op_assign
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_RESIDUAL_SGPTR
op_plus
l_int|3
)paren
op_lshift
l_int|24
)paren
op_or
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_RESIDUAL_SGPTR
op_plus
l_int|2
)paren
op_lshift
l_int|16
)paren
op_or
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_RESIDUAL_SGPTR
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
op_or
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_RESIDUAL_SGPTR
)paren
suffix:semicolon
id|sgptr
op_and_assign
id|SG_PTR_MASK
suffix:semicolon
id|sg
op_assign
id|ahc_sg_bus_to_virt
c_func
(paren
id|scb
comma
id|sgptr
)paren
suffix:semicolon
multiline_comment|/* The residual sg_ptr always points to the next sg */
id|sg
op_decrement
suffix:semicolon
id|resid
op_assign
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_RESIDUAL_DATACNT
op_plus
l_int|2
)paren
op_lshift
l_int|16
)paren
op_or
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_RESIDUAL_DATACNT
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
op_or
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_RESIDUAL_DATACNT
)paren
suffix:semicolon
id|dataptr
op_assign
id|ahc_le32toh
c_func
(paren
id|sg-&gt;addr
)paren
op_plus
(paren
id|ahc_le32toh
c_func
(paren
id|sg-&gt;len
)paren
op_amp
id|AHC_SG_LEN_MASK
)paren
op_minus
id|resid
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;flags
op_amp
id|AHC_39BIT_ADDRESSING
)paren
op_ne
l_int|0
)paren
(brace
id|u_int
id|dscommand1
suffix:semicolon
id|dscommand1
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|DSCOMMAND1
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|DSCOMMAND1
comma
id|dscommand1
op_or
id|HADDLDSEL0
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|HADDR
comma
(paren
id|ahc_le32toh
c_func
(paren
id|sg-&gt;len
)paren
op_rshift
l_int|24
)paren
op_amp
id|SG_HIGH_ADDR_BITS
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|DSCOMMAND1
comma
id|dscommand1
)paren
suffix:semicolon
)brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|HADDR
op_plus
l_int|3
comma
id|dataptr
op_rshift
l_int|24
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|HADDR
op_plus
l_int|2
comma
id|dataptr
op_rshift
l_int|16
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|HADDR
op_plus
l_int|1
comma
id|dataptr
op_rshift
l_int|8
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|HADDR
comma
id|dataptr
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|HCNT
op_plus
l_int|2
comma
id|resid
op_rshift
l_int|16
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|HCNT
op_plus
l_int|1
comma
id|resid
op_rshift
l_int|8
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|HCNT
comma
id|resid
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_eq
l_int|0
)paren
(brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|STCNT
op_plus
l_int|2
comma
id|resid
op_rshift
l_int|16
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|STCNT
op_plus
l_int|1
comma
id|resid
op_rshift
l_int|8
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|STCNT
comma
id|resid
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Handle the effects of issuing a bus device reset message.&n; */
r_static
r_void
DECL|function|ahc_handle_devreset
id|ahc_handle_devreset
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
comma
id|cam_status
id|status
comma
r_char
op_star
id|message
comma
r_int
id|verbose_level
)paren
(brace
macro_line|#ifdef AHC_TARGET_MODE
r_struct
id|ahc_tmode_tstate
op_star
id|tstate
suffix:semicolon
id|u_int
id|lun
suffix:semicolon
macro_line|#endif
r_int
id|found
suffix:semicolon
id|found
op_assign
id|ahc_abort_scbs
c_func
(paren
id|ahc
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;channel
comma
id|CAM_LUN_WILDCARD
comma
id|SCB_LIST_NULL
comma
id|devinfo-&gt;role
comma
id|status
)paren
suffix:semicolon
macro_line|#ifdef AHC_TARGET_MODE
multiline_comment|/*&n;&t; * Send an immediate notify ccb to all target mord peripheral&n;&t; * drivers affected by this action.&n;&t; */
id|tstate
op_assign
id|ahc-&gt;enabled_targets
(braket
id|devinfo-&gt;our_scsiid
)braket
suffix:semicolon
r_if
c_cond
(paren
id|tstate
op_ne
l_int|NULL
)paren
(brace
r_for
c_loop
(paren
id|lun
op_assign
l_int|0
suffix:semicolon
id|lun
OL
id|AHC_NUM_LUNS
suffix:semicolon
id|lun
op_increment
)paren
(brace
r_struct
id|ahc_tmode_lstate
op_star
id|lstate
suffix:semicolon
id|lstate
op_assign
id|tstate-&gt;enabled_luns
(braket
id|lun
)braket
suffix:semicolon
r_if
c_cond
(paren
id|lstate
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|ahc_queue_lstate_event
c_func
(paren
id|ahc
comma
id|lstate
comma
id|devinfo-&gt;our_scsiid
comma
id|MSG_BUS_DEV_RESET
comma
multiline_comment|/*arg*/
l_int|0
)paren
suffix:semicolon
id|ahc_send_lstate_events
c_func
(paren
id|ahc
comma
id|lstate
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Go back to async/narrow transfers and renegotiate.&n;&t; */
id|ahc_set_width
c_func
(paren
id|ahc
comma
id|devinfo
comma
id|MSG_EXT_WDTR_BUS_8_BIT
comma
id|AHC_TRANS_CUR
comma
multiline_comment|/*paused*/
id|TRUE
)paren
suffix:semicolon
id|ahc_set_syncrate
c_func
(paren
id|ahc
comma
id|devinfo
comma
multiline_comment|/*syncrate*/
l_int|NULL
comma
multiline_comment|/*period*/
l_int|0
comma
multiline_comment|/*offset*/
l_int|0
comma
multiline_comment|/*ppr_options*/
l_int|0
comma
id|AHC_TRANS_CUR
comma
multiline_comment|/*paused*/
id|TRUE
)paren
suffix:semicolon
id|ahc_send_async
c_func
(paren
id|ahc
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|CAM_LUN_WILDCARD
comma
id|AC_SENT_BDR
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|message
op_ne
l_int|NULL
op_logical_and
(paren
id|verbose_level
op_le
id|bootverbose
)paren
)paren
id|printf
c_func
(paren
l_string|&quot;%s: %s on %c:%d. %d SCBs aborted&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|message
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|found
)paren
suffix:semicolon
)brace
macro_line|#ifdef AHC_TARGET_MODE
r_static
r_void
DECL|function|ahc_setup_target_msgin
id|ahc_setup_target_msgin
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
comma
r_struct
id|scb
op_star
id|scb
)paren
(brace
multiline_comment|/*              &n;&t; * To facilitate adding multiple messages together,&n;&t; * each routine should increment the index and len&n;&t; * variables instead of setting them explicitly.&n;&t; */
id|ahc-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|ahc-&gt;msgout_len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_ne
l_int|NULL
op_logical_and
(paren
id|scb-&gt;flags
op_amp
id|SCB_AUTO_NEGOTIATE
)paren
op_ne
l_int|0
)paren
id|ahc_build_transfer_msg
c_func
(paren
id|ahc
comma
id|devinfo
)paren
suffix:semicolon
r_else
id|panic
c_func
(paren
l_string|&quot;ahc_intr: AWAITING target message with no message&quot;
)paren
suffix:semicolon
id|ahc-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|ahc-&gt;msg_type
op_assign
id|MSG_TYPE_TARGET_MSGIN
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/**************************** Initialization **********************************/
multiline_comment|/*&n; * Allocate a controller structure for a new device&n; * and perform initial initializion.&n; */
r_struct
id|ahc_softc
op_star
DECL|function|ahc_alloc
id|ahc_alloc
c_func
(paren
r_void
op_star
id|platform_arg
comma
r_char
op_star
id|name
)paren
(brace
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#ifndef&t;__FreeBSD__
id|ahc
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|ahc
)paren
comma
id|M_DEVBUF
comma
id|M_NOWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ahc
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;aic7xxx: cannot malloc softc!&bslash;n&quot;
)paren
suffix:semicolon
id|free
c_func
(paren
id|name
comma
id|M_DEVBUF
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#else
id|ahc
op_assign
id|device_get_softc
c_func
(paren
(paren
id|device_t
)paren
id|platform_arg
)paren
suffix:semicolon
macro_line|#endif
id|memset
c_func
(paren
id|ahc
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|ahc
)paren
)paren
suffix:semicolon
id|ahc-&gt;seep_config
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|ahc-&gt;seep_config
)paren
comma
id|M_DEVBUF
comma
id|M_NOWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;seep_config
op_eq
l_int|NULL
)paren
(brace
macro_line|#ifndef&t;__FreeBSD__
id|free
c_func
(paren
id|ahc
comma
id|M_DEVBUF
)paren
suffix:semicolon
macro_line|#endif
id|free
c_func
(paren
id|name
comma
id|M_DEVBUF
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
id|LIST_INIT
c_func
(paren
op_amp
id|ahc-&gt;pending_scbs
)paren
suffix:semicolon
multiline_comment|/* We don&squot;t know our unit number until the OSM sets it */
id|ahc-&gt;name
op_assign
id|name
suffix:semicolon
id|ahc-&gt;unit
op_assign
op_minus
l_int|1
suffix:semicolon
id|ahc-&gt;description
op_assign
l_int|NULL
suffix:semicolon
id|ahc-&gt;channel
op_assign
l_char|&squot;A&squot;
suffix:semicolon
id|ahc-&gt;channel_b
op_assign
l_char|&squot;B&squot;
suffix:semicolon
id|ahc-&gt;chip
op_assign
id|AHC_NONE
suffix:semicolon
id|ahc-&gt;features
op_assign
id|AHC_FENONE
suffix:semicolon
id|ahc-&gt;bugs
op_assign
id|AHC_BUGNONE
suffix:semicolon
id|ahc-&gt;flags
op_assign
id|AHC_FNONE
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AHC_NUM_TARGETS
suffix:semicolon
id|i
op_increment
)paren
id|TAILQ_INIT
c_func
(paren
op_amp
id|ahc-&gt;untagged_queues
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc_platform_alloc
c_func
(paren
id|ahc
comma
id|platform_arg
)paren
op_ne
l_int|0
)paren
(brace
id|ahc_free
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
(paren
id|ahc
)paren
suffix:semicolon
)brace
r_int
DECL|function|ahc_softc_init
id|ahc_softc_init
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
multiline_comment|/* The IRQMS bit is only valid on VL and EISA chips */
r_if
c_cond
(paren
(paren
id|ahc-&gt;chip
op_amp
id|AHC_PCI
)paren
op_eq
l_int|0
)paren
id|ahc-&gt;unpause
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|HCNTRL
)paren
op_amp
id|IRQMS
suffix:semicolon
r_else
id|ahc-&gt;unpause
op_assign
l_int|0
suffix:semicolon
id|ahc-&gt;pause
op_assign
id|ahc-&gt;unpause
op_or
id|PAUSE
suffix:semicolon
multiline_comment|/* XXX The shared scb data stuff should be deprecated */
r_if
c_cond
(paren
id|ahc-&gt;scb_data
op_eq
l_int|NULL
)paren
(brace
id|ahc-&gt;scb_data
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|ahc-&gt;scb_data
)paren
comma
id|M_DEVBUF
comma
id|M_NOWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;scb_data
op_eq
l_int|NULL
)paren
r_return
(paren
id|ENOMEM
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ahc-&gt;scb_data
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|ahc-&gt;scb_data
)paren
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahc_softc_insert
id|ahc_softc_insert
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_struct
id|ahc_softc
op_star
id|list_ahc
suffix:semicolon
macro_line|#if AHC_PCI_CONFIG &gt; 0
multiline_comment|/*&n;&t; * Second Function PCI devices need to inherit some&n;&t; * settings from function 0.&n;&t; */
r_if
c_cond
(paren
(paren
id|ahc-&gt;chip
op_amp
id|AHC_BUS_MASK
)paren
op_eq
id|AHC_PCI
op_logical_and
(paren
id|ahc-&gt;features
op_amp
id|AHC_MULTI_FUNC
)paren
op_ne
l_int|0
)paren
(brace
id|TAILQ_FOREACH
c_func
(paren
id|list_ahc
comma
op_amp
id|ahc_tailq
comma
id|links
)paren
(brace
id|ahc_dev_softc_t
id|list_pci
suffix:semicolon
id|ahc_dev_softc_t
id|pci
suffix:semicolon
id|list_pci
op_assign
id|list_ahc-&gt;dev_softc
suffix:semicolon
id|pci
op_assign
id|ahc-&gt;dev_softc
suffix:semicolon
r_if
c_cond
(paren
id|ahc_get_pci_slot
c_func
(paren
id|list_pci
)paren
op_eq
id|ahc_get_pci_slot
c_func
(paren
id|pci
)paren
op_logical_and
id|ahc_get_pci_bus
c_func
(paren
id|list_pci
)paren
op_eq
id|ahc_get_pci_bus
c_func
(paren
id|pci
)paren
)paren
(brace
r_struct
id|ahc_softc
op_star
id|master
suffix:semicolon
r_struct
id|ahc_softc
op_star
id|slave
suffix:semicolon
r_if
c_cond
(paren
id|ahc_get_pci_function
c_func
(paren
id|list_pci
)paren
op_eq
l_int|0
)paren
(brace
id|master
op_assign
id|list_ahc
suffix:semicolon
id|slave
op_assign
id|ahc
suffix:semicolon
)brace
r_else
(brace
id|master
op_assign
id|ahc
suffix:semicolon
id|slave
op_assign
id|list_ahc
suffix:semicolon
)brace
id|slave-&gt;flags
op_and_assign
op_complement
id|AHC_BIOS_ENABLED
suffix:semicolon
id|slave-&gt;flags
op_or_assign
id|master-&gt;flags
op_amp
id|AHC_BIOS_ENABLED
suffix:semicolon
id|slave-&gt;flags
op_and_assign
op_complement
id|AHC_PRIMARY_CHANNEL
suffix:semicolon
id|slave-&gt;flags
op_or_assign
id|master-&gt;flags
op_amp
id|AHC_PRIMARY_CHANNEL
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Insertion sort into our list of softcs.&n;&t; */
id|list_ahc
op_assign
id|TAILQ_FIRST
c_func
(paren
op_amp
id|ahc_tailq
)paren
suffix:semicolon
r_while
c_loop
(paren
id|list_ahc
op_ne
l_int|NULL
op_logical_and
id|ahc_softc_comp
c_func
(paren
id|list_ahc
comma
id|ahc
)paren
op_le
l_int|0
)paren
id|list_ahc
op_assign
id|TAILQ_NEXT
c_func
(paren
id|list_ahc
comma
id|links
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_ahc
op_ne
l_int|NULL
)paren
id|TAILQ_INSERT_BEFORE
c_func
(paren
id|list_ahc
comma
id|ahc
comma
id|links
)paren
suffix:semicolon
r_else
id|TAILQ_INSERT_TAIL
c_func
(paren
op_amp
id|ahc_tailq
comma
id|ahc
comma
id|links
)paren
suffix:semicolon
id|ahc-&gt;init_level
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; * Verify that the passed in softc pointer is for a&n; * controller that is still configured.&n; */
r_struct
id|ahc_softc
op_star
DECL|function|ahc_find_softc
id|ahc_find_softc
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_struct
id|ahc_softc
op_star
id|list_ahc
suffix:semicolon
id|TAILQ_FOREACH
c_func
(paren
id|list_ahc
comma
op_amp
id|ahc_tailq
comma
id|links
)paren
(brace
r_if
c_cond
(paren
id|list_ahc
op_eq
id|ahc
)paren
r_return
(paren
id|ahc
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahc_set_unit
id|ahc_set_unit
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_int
id|unit
)paren
(brace
id|ahc-&gt;unit
op_assign
id|unit
suffix:semicolon
)brace
r_void
DECL|function|ahc_set_name
id|ahc_set_name
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_char
op_star
id|name
)paren
(brace
r_if
c_cond
(paren
id|ahc-&gt;name
op_ne
l_int|NULL
)paren
id|free
c_func
(paren
id|ahc-&gt;name
comma
id|M_DEVBUF
)paren
suffix:semicolon
id|ahc-&gt;name
op_assign
id|name
suffix:semicolon
)brace
r_void
DECL|function|ahc_free
id|ahc_free
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_int
id|i
suffix:semicolon
id|ahc_fini_scbdata
c_func
(paren
id|ahc
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ahc-&gt;init_level
)paren
(brace
r_default
suffix:colon
r_case
l_int|5
suffix:colon
id|ahc_shutdown
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|TAILQ_REMOVE
c_func
(paren
op_amp
id|ahc_tailq
comma
id|ahc
comma
id|links
)paren
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_case
l_int|4
suffix:colon
id|ahc_dmamap_unload
c_func
(paren
id|ahc
comma
id|ahc-&gt;shared_data_dmat
comma
id|ahc-&gt;shared_data_dmamap
)paren
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_case
l_int|3
suffix:colon
id|ahc_dmamem_free
c_func
(paren
id|ahc
comma
id|ahc-&gt;shared_data_dmat
comma
id|ahc-&gt;qoutfifo
comma
id|ahc-&gt;shared_data_dmamap
)paren
suffix:semicolon
id|ahc_dmamap_destroy
c_func
(paren
id|ahc
comma
id|ahc-&gt;shared_data_dmat
comma
id|ahc-&gt;shared_data_dmamap
)paren
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_case
l_int|2
suffix:colon
id|ahc_dma_tag_destroy
c_func
(paren
id|ahc
comma
id|ahc-&gt;shared_data_dmat
)paren
suffix:semicolon
r_case
l_int|1
suffix:colon
macro_line|#ifndef __linux__
id|ahc_dma_tag_destroy
c_func
(paren
id|ahc
comma
id|ahc-&gt;buffer_dmat
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
)brace
macro_line|#ifndef __linux__
id|ahc_dma_tag_destroy
c_func
(paren
id|ahc
comma
id|ahc-&gt;parent_dmat
)paren
suffix:semicolon
macro_line|#endif
id|ahc_platform_free
c_func
(paren
id|ahc
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AHC_NUM_TARGETS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ahc_tmode_tstate
op_star
id|tstate
suffix:semicolon
id|tstate
op_assign
id|ahc-&gt;enabled_targets
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|tstate
op_ne
l_int|NULL
)paren
(brace
macro_line|#if AHC_TARGET_MODE
r_int
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|AHC_NUM_LUNS
suffix:semicolon
id|j
op_increment
)paren
(brace
r_struct
id|ahc_tmode_lstate
op_star
id|lstate
suffix:semicolon
id|lstate
op_assign
id|tstate-&gt;enabled_luns
(braket
id|j
)braket
suffix:semicolon
r_if
c_cond
(paren
id|lstate
op_ne
l_int|NULL
)paren
(brace
id|xpt_free_path
c_func
(paren
id|lstate-&gt;path
)paren
suffix:semicolon
id|free
c_func
(paren
id|lstate
comma
id|M_DEVBUF
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
id|free
c_func
(paren
id|tstate
comma
id|M_DEVBUF
)paren
suffix:semicolon
)brace
)brace
macro_line|#if AHC_TARGET_MODE
r_if
c_cond
(paren
id|ahc-&gt;black_hole
op_ne
l_int|NULL
)paren
(brace
id|xpt_free_path
c_func
(paren
id|ahc-&gt;black_hole-&gt;path
)paren
suffix:semicolon
id|free
c_func
(paren
id|ahc-&gt;black_hole
comma
id|M_DEVBUF
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|ahc-&gt;name
op_ne
l_int|NULL
)paren
id|free
c_func
(paren
id|ahc-&gt;name
comma
id|M_DEVBUF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;seep_config
op_ne
l_int|NULL
)paren
id|free
c_func
(paren
id|ahc-&gt;seep_config
comma
id|M_DEVBUF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;saved_stack
op_ne
l_int|NULL
)paren
id|free
c_func
(paren
id|ahc-&gt;saved_stack
comma
id|M_DEVBUF
)paren
suffix:semicolon
macro_line|#ifndef __FreeBSD__
id|free
c_func
(paren
id|ahc
comma
id|M_DEVBUF
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
r_void
DECL|function|ahc_shutdown
id|ahc_shutdown
c_func
(paren
r_void
op_star
id|arg
)paren
(brace
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ahc
op_assign
(paren
r_struct
id|ahc_softc
op_star
)paren
id|arg
suffix:semicolon
multiline_comment|/* This will reset most registers to 0, but not all */
id|ahc_reset
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSISEQ
comma
l_int|0
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SXFRCTL0
comma
l_int|0
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|DSPCISTATUS
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|TARG_SCSIRATE
suffix:semicolon
id|i
OL
id|SCSICONF
suffix:semicolon
id|i
op_increment
)paren
id|ahc_outb
c_func
(paren
id|ahc
comma
id|i
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Reset the controller and record some information about it&n; * that is only available just after a reset.&n; */
r_int
DECL|function|ahc_reset
id|ahc_reset
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
id|u_int
id|sblkctl
suffix:semicolon
id|u_int
id|sxfrctl1_a
comma
id|sxfrctl1_b
suffix:semicolon
r_int
id|wait
suffix:semicolon
multiline_comment|/*&n;&t; * Preserve the value of the SXFRCTL1 register for all channels.&n;&t; * It contains settings that affect termination and we don&squot;t want&n;&t; * to disturb the integrity of the bus.&n;&t; */
id|ahc_pause
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|sxfrctl1_b
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;chip
op_amp
id|AHC_CHIPID_MASK
)paren
op_eq
id|AHC_AIC7770
)paren
(brace
id|u_int
id|sblkctl
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Save channel B&squot;s settings in case this chip&n;&t;&t; * is setup for TWIN channel operation.&n;&t;&t; */
id|sblkctl
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SBLKCTL
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SBLKCTL
comma
id|sblkctl
op_or
id|SELBUSB
)paren
suffix:semicolon
id|sxfrctl1_b
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SXFRCTL1
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SBLKCTL
comma
id|sblkctl
op_amp
op_complement
id|SELBUSB
)paren
suffix:semicolon
)brace
id|sxfrctl1_a
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SXFRCTL1
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|HCNTRL
comma
id|CHIPRST
op_or
id|ahc-&gt;pause
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ensure that the reset has finished.  We delay 1000us&n;&t; * prior to reading the register to make sure the chip&n;&t; * has sufficiently completed its reset to handle register&n;&t; * accesses.&n;&t; */
id|wait
op_assign
l_int|1000
suffix:semicolon
r_do
(brace
id|ahc_delay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|wait
op_logical_and
op_logical_neg
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|HCNTRL
)paren
op_amp
id|CHIPRSTACK
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: WARNING - Failed chip reset!  &quot;
l_string|&quot;Trying to initialize anyway.&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
)paren
suffix:semicolon
)brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|HCNTRL
comma
id|ahc-&gt;pause
)paren
suffix:semicolon
multiline_comment|/* Determine channel configuration */
id|sblkctl
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SBLKCTL
)paren
op_amp
(paren
id|SELBUSB
op_or
id|SELWIDE
)paren
suffix:semicolon
multiline_comment|/* No Twin Channel PCI cards */
r_if
c_cond
(paren
(paren
id|ahc-&gt;chip
op_amp
id|AHC_PCI
)paren
op_ne
l_int|0
)paren
id|sblkctl
op_and_assign
op_complement
id|SELBUSB
suffix:semicolon
r_switch
c_cond
(paren
id|sblkctl
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* Single Narrow Channel */
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* Wide Channel */
id|ahc-&gt;features
op_or_assign
id|AHC_WIDE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
multiline_comment|/* Twin Channel */
id|ahc-&gt;features
op_or_assign
id|AHC_TWIN
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printf
c_func
(paren
l_string|&quot; Unsupported adapter type.  Ignoring&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Reload sxfrctl1.&n;&t; *&n;&t; * We must always initialize STPWEN to 1 before we&n;&t; * restore the saved values.  STPWEN is initialized&n;&t; * to a tri-state condition which can only be cleared&n;&t; * by turning it on.&n;&t; */
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_TWIN
)paren
op_ne
l_int|0
)paren
(brace
id|u_int
id|sblkctl
suffix:semicolon
id|sblkctl
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SBLKCTL
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SBLKCTL
comma
id|sblkctl
op_or
id|SELBUSB
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SXFRCTL1
comma
id|sxfrctl1_b
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SBLKCTL
comma
id|sblkctl
op_amp
op_complement
id|SELBUSB
)paren
suffix:semicolon
)brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SXFRCTL1
comma
id|sxfrctl1_a
)paren
suffix:semicolon
macro_line|#ifdef AHC_DUMP_SEQ
r_if
c_cond
(paren
id|ahc-&gt;init_level
op_eq
l_int|0
)paren
id|ahc_dumpseq
c_func
(paren
id|ahc
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Determine the number of SCBs available on the controller&n; */
r_int
DECL|function|ahc_probe_scbs
id|ahc_probe_scbs
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AHC_SCB_MAX
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBPTR
comma
id|i
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCB_BASE
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_BASE
)paren
op_ne
id|i
)paren
r_break
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBPTR
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_BASE
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_return
(paren
id|i
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahc_dmamap_cb
id|ahc_dmamap_cb
c_func
(paren
r_void
op_star
id|arg
comma
id|bus_dma_segment_t
op_star
id|segs
comma
r_int
id|nseg
comma
r_int
id|error
)paren
(brace
id|bus_addr_t
op_star
id|baddr
suffix:semicolon
id|baddr
op_assign
(paren
id|bus_addr_t
op_star
)paren
id|arg
suffix:semicolon
op_star
id|baddr
op_assign
id|segs-&gt;ds_addr
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahc_build_free_scb_list
id|ahc_build_free_scb_list
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_int
id|scbsize
suffix:semicolon
r_int
id|i
suffix:semicolon
id|scbsize
op_assign
l_int|32
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;flags
op_amp
id|AHC_LSCBS_ENABLED
)paren
op_ne
l_int|0
)paren
id|scbsize
op_assign
l_int|64
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ahc-&gt;scb_data-&gt;maxhscbs
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|j
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBPTR
comma
id|i
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Touch all SCB bytes to avoid parity errors&n;&t;&t; * should one of our debugging routines read&n;&t;&t; * an otherwise uninitiatlized byte.&n;&t;&t; */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|scbsize
suffix:semicolon
id|j
op_increment
)paren
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCB_BASE
op_plus
id|j
comma
l_int|0xFF
)paren
suffix:semicolon
multiline_comment|/* Clear the control byte. */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCB_CONTROL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Set the next pointer */
r_if
c_cond
(paren
(paren
id|ahc-&gt;flags
op_amp
id|AHC_PAGESCBS
)paren
op_ne
l_int|0
)paren
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCB_NEXT
comma
id|i
op_plus
l_int|1
)paren
suffix:semicolon
r_else
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCB_NEXT
comma
id|SCB_LIST_NULL
)paren
suffix:semicolon
multiline_comment|/* Make the tag number, SCSIID, and lun invalid */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCB_TAG
comma
id|SCB_LIST_NULL
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCB_SCSIID
comma
l_int|0xFF
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCB_LUN
comma
l_int|0xFF
)paren
suffix:semicolon
)brace
multiline_comment|/* Make sure that the last SCB terminates the free list */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBPTR
comma
id|i
op_minus
l_int|1
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCB_NEXT
comma
id|SCB_LIST_NULL
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|ahc_init_scbdata
id|ahc_init_scbdata
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_struct
id|scb_data
op_star
id|scb_data
suffix:semicolon
id|scb_data
op_assign
id|ahc-&gt;scb_data
suffix:semicolon
id|SLIST_INIT
c_func
(paren
op_amp
id|scb_data-&gt;free_scbs
)paren
suffix:semicolon
id|SLIST_INIT
c_func
(paren
op_amp
id|scb_data-&gt;sg_maps
)paren
suffix:semicolon
multiline_comment|/* Allocate SCB resources */
id|scb_data-&gt;scbarray
op_assign
(paren
r_struct
id|scb
op_star
)paren
id|malloc
c_func
(paren
r_sizeof
(paren
r_struct
id|scb
)paren
op_star
id|AHC_SCB_MAX_ALLOC
comma
id|M_DEVBUF
comma
id|M_NOWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb_data-&gt;scbarray
op_eq
l_int|NULL
)paren
r_return
(paren
id|ENOMEM
)paren
suffix:semicolon
id|memset
c_func
(paren
id|scb_data-&gt;scbarray
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|scb
)paren
op_star
id|AHC_SCB_MAX_ALLOC
)paren
suffix:semicolon
multiline_comment|/* Determine the number of hardware SCBs and initialize them */
id|scb_data-&gt;maxhscbs
op_assign
id|ahc_probe_scbs
c_func
(paren
id|ahc
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;flags
op_amp
id|AHC_PAGESCBS
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* SCB 0 heads the free list */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|FREE_SCBH
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|FREE_SCBH
comma
id|SCB_LIST_NULL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ahc-&gt;scb_data-&gt;maxhscbs
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: No SCB space found&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
)paren
suffix:semicolon
r_return
(paren
id|ENXIO
)paren
suffix:semicolon
)brace
id|ahc_build_free_scb_list
c_func
(paren
id|ahc
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Create our DMA tags.  These tags define the kinds of device&n;&t; * accessible memory allocations and memory mappings we will&n;&t; * need to perform during normal operation.&n;&t; *&n;&t; * Unless we need to further restrict the allocation, we rely&n;&t; * on the restrictions of the parent dmat, hence the common&n;&t; * use of MAXADDR and MAXSIZE.&n;&t; */
multiline_comment|/* DMA tag for our hardware scb structures */
r_if
c_cond
(paren
id|ahc_dma_tag_create
c_func
(paren
id|ahc
comma
id|ahc-&gt;parent_dmat
comma
multiline_comment|/*alignment*/
l_int|1
comma
multiline_comment|/*boundary*/
id|BUS_SPACE_MAXADDR_32BIT
op_plus
l_int|1
comma
multiline_comment|/*lowaddr*/
id|BUS_SPACE_MAXADDR_32BIT
comma
multiline_comment|/*highaddr*/
id|BUS_SPACE_MAXADDR
comma
multiline_comment|/*filter*/
l_int|NULL
comma
multiline_comment|/*filterarg*/
l_int|NULL
comma
id|AHC_SCB_MAX_ALLOC
op_star
r_sizeof
(paren
r_struct
id|hardware_scb
)paren
comma
multiline_comment|/*nsegments*/
l_int|1
comma
multiline_comment|/*maxsegsz*/
id|BUS_SPACE_MAXSIZE_32BIT
comma
multiline_comment|/*flags*/
l_int|0
comma
op_amp
id|scb_data-&gt;hscb_dmat
)paren
op_ne
l_int|0
)paren
(brace
r_goto
id|error_exit
suffix:semicolon
)brace
id|scb_data-&gt;init_level
op_increment
suffix:semicolon
multiline_comment|/* Allocation for our hscbs */
r_if
c_cond
(paren
id|ahc_dmamem_alloc
c_func
(paren
id|ahc
comma
id|scb_data-&gt;hscb_dmat
comma
(paren
r_void
op_star
op_star
)paren
op_amp
id|scb_data-&gt;hscbs
comma
id|BUS_DMA_NOWAIT
comma
op_amp
id|scb_data-&gt;hscb_dmamap
)paren
op_ne
l_int|0
)paren
(brace
r_goto
id|error_exit
suffix:semicolon
)brace
id|scb_data-&gt;init_level
op_increment
suffix:semicolon
multiline_comment|/* And permanently map them */
id|ahc_dmamap_load
c_func
(paren
id|ahc
comma
id|scb_data-&gt;hscb_dmat
comma
id|scb_data-&gt;hscb_dmamap
comma
id|scb_data-&gt;hscbs
comma
id|AHC_SCB_MAX_ALLOC
op_star
r_sizeof
(paren
r_struct
id|hardware_scb
)paren
comma
id|ahc_dmamap_cb
comma
op_amp
id|scb_data-&gt;hscb_busaddr
comma
multiline_comment|/*flags*/
l_int|0
)paren
suffix:semicolon
id|scb_data-&gt;init_level
op_increment
suffix:semicolon
multiline_comment|/* DMA tag for our sense buffers */
r_if
c_cond
(paren
id|ahc_dma_tag_create
c_func
(paren
id|ahc
comma
id|ahc-&gt;parent_dmat
comma
multiline_comment|/*alignment*/
l_int|1
comma
multiline_comment|/*boundary*/
id|BUS_SPACE_MAXADDR_32BIT
op_plus
l_int|1
comma
multiline_comment|/*lowaddr*/
id|BUS_SPACE_MAXADDR_32BIT
comma
multiline_comment|/*highaddr*/
id|BUS_SPACE_MAXADDR
comma
multiline_comment|/*filter*/
l_int|NULL
comma
multiline_comment|/*filterarg*/
l_int|NULL
comma
id|AHC_SCB_MAX_ALLOC
op_star
r_sizeof
(paren
r_struct
id|scsi_sense_data
)paren
comma
multiline_comment|/*nsegments*/
l_int|1
comma
multiline_comment|/*maxsegsz*/
id|BUS_SPACE_MAXSIZE_32BIT
comma
multiline_comment|/*flags*/
l_int|0
comma
op_amp
id|scb_data-&gt;sense_dmat
)paren
op_ne
l_int|0
)paren
(brace
r_goto
id|error_exit
suffix:semicolon
)brace
id|scb_data-&gt;init_level
op_increment
suffix:semicolon
multiline_comment|/* Allocate them */
r_if
c_cond
(paren
id|ahc_dmamem_alloc
c_func
(paren
id|ahc
comma
id|scb_data-&gt;sense_dmat
comma
(paren
r_void
op_star
op_star
)paren
op_amp
id|scb_data-&gt;sense
comma
id|BUS_DMA_NOWAIT
comma
op_amp
id|scb_data-&gt;sense_dmamap
)paren
op_ne
l_int|0
)paren
(brace
r_goto
id|error_exit
suffix:semicolon
)brace
id|scb_data-&gt;init_level
op_increment
suffix:semicolon
multiline_comment|/* And permanently map them */
id|ahc_dmamap_load
c_func
(paren
id|ahc
comma
id|scb_data-&gt;sense_dmat
comma
id|scb_data-&gt;sense_dmamap
comma
id|scb_data-&gt;sense
comma
id|AHC_SCB_MAX_ALLOC
op_star
r_sizeof
(paren
r_struct
id|scsi_sense_data
)paren
comma
id|ahc_dmamap_cb
comma
op_amp
id|scb_data-&gt;sense_busaddr
comma
multiline_comment|/*flags*/
l_int|0
)paren
suffix:semicolon
id|scb_data-&gt;init_level
op_increment
suffix:semicolon
multiline_comment|/* DMA tag for our S/G structures.  We allocate in page sized chunks */
r_if
c_cond
(paren
id|ahc_dma_tag_create
c_func
(paren
id|ahc
comma
id|ahc-&gt;parent_dmat
comma
multiline_comment|/*alignment*/
l_int|8
comma
multiline_comment|/*boundary*/
id|BUS_SPACE_MAXADDR_32BIT
op_plus
l_int|1
comma
multiline_comment|/*lowaddr*/
id|BUS_SPACE_MAXADDR_32BIT
comma
multiline_comment|/*highaddr*/
id|BUS_SPACE_MAXADDR
comma
multiline_comment|/*filter*/
l_int|NULL
comma
multiline_comment|/*filterarg*/
l_int|NULL
comma
id|PAGE_SIZE
comma
multiline_comment|/*nsegments*/
l_int|1
comma
multiline_comment|/*maxsegsz*/
id|BUS_SPACE_MAXSIZE_32BIT
comma
multiline_comment|/*flags*/
l_int|0
comma
op_amp
id|scb_data-&gt;sg_dmat
)paren
op_ne
l_int|0
)paren
(brace
r_goto
id|error_exit
suffix:semicolon
)brace
id|scb_data-&gt;init_level
op_increment
suffix:semicolon
multiline_comment|/* Perform initial CCB allocation */
id|memset
c_func
(paren
id|scb_data-&gt;hscbs
comma
l_int|0
comma
id|AHC_SCB_MAX_ALLOC
op_star
r_sizeof
(paren
r_struct
id|hardware_scb
)paren
)paren
suffix:semicolon
id|ahc_alloc_scbs
c_func
(paren
id|ahc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb_data-&gt;numscbs
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: ahc_init_scbdata - &quot;
l_string|&quot;Unable to allocate initial scbs&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
)paren
suffix:semicolon
r_goto
id|error_exit
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Tell the sequencer which SCB will be the next one it receives.&n;&t; */
id|ahc-&gt;next_queued_scb
op_assign
id|ahc_get_scb
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|NEXT_QUEUED_SCB
comma
id|ahc-&gt;next_queued_scb-&gt;hscb-&gt;tag
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Note that we were successfull&n;&t; */
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|error_exit
suffix:colon
r_return
(paren
id|ENOMEM
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahc_fini_scbdata
id|ahc_fini_scbdata
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_struct
id|scb_data
op_star
id|scb_data
suffix:semicolon
id|scb_data
op_assign
id|ahc-&gt;scb_data
suffix:semicolon
r_if
c_cond
(paren
id|scb_data
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_switch
c_cond
(paren
id|scb_data-&gt;init_level
)paren
(brace
r_default
suffix:colon
(brace
)brace
r_case
l_int|7
suffix:colon
(brace
r_struct
id|sg_map_node
op_star
id|sg_map
suffix:semicolon
r_while
c_loop
(paren
(paren
id|sg_map
op_assign
id|SLIST_FIRST
c_func
(paren
op_amp
id|scb_data-&gt;sg_maps
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|SLIST_REMOVE_HEAD
c_func
(paren
op_amp
id|scb_data-&gt;sg_maps
comma
id|links
)paren
suffix:semicolon
id|ahc_dmamap_unload
c_func
(paren
id|ahc
comma
id|scb_data-&gt;sg_dmat
comma
id|sg_map-&gt;sg_dmamap
)paren
suffix:semicolon
id|ahc_dmamem_free
c_func
(paren
id|ahc
comma
id|scb_data-&gt;sg_dmat
comma
id|sg_map-&gt;sg_vaddr
comma
id|sg_map-&gt;sg_dmamap
)paren
suffix:semicolon
id|free
c_func
(paren
id|sg_map
comma
id|M_DEVBUF
)paren
suffix:semicolon
)brace
id|ahc_dma_tag_destroy
c_func
(paren
id|ahc
comma
id|scb_data-&gt;sg_dmat
)paren
suffix:semicolon
)brace
r_case
l_int|6
suffix:colon
id|ahc_dmamap_unload
c_func
(paren
id|ahc
comma
id|scb_data-&gt;sense_dmat
comma
id|scb_data-&gt;sense_dmamap
)paren
suffix:semicolon
r_case
l_int|5
suffix:colon
id|ahc_dmamem_free
c_func
(paren
id|ahc
comma
id|scb_data-&gt;sense_dmat
comma
id|scb_data-&gt;sense
comma
id|scb_data-&gt;sense_dmamap
)paren
suffix:semicolon
id|ahc_dmamap_destroy
c_func
(paren
id|ahc
comma
id|scb_data-&gt;sense_dmat
comma
id|scb_data-&gt;sense_dmamap
)paren
suffix:semicolon
r_case
l_int|4
suffix:colon
id|ahc_dma_tag_destroy
c_func
(paren
id|ahc
comma
id|scb_data-&gt;sense_dmat
)paren
suffix:semicolon
r_case
l_int|3
suffix:colon
id|ahc_dmamap_unload
c_func
(paren
id|ahc
comma
id|scb_data-&gt;hscb_dmat
comma
id|scb_data-&gt;hscb_dmamap
)paren
suffix:semicolon
r_case
l_int|2
suffix:colon
id|ahc_dmamem_free
c_func
(paren
id|ahc
comma
id|scb_data-&gt;hscb_dmat
comma
id|scb_data-&gt;hscbs
comma
id|scb_data-&gt;hscb_dmamap
)paren
suffix:semicolon
id|ahc_dmamap_destroy
c_func
(paren
id|ahc
comma
id|scb_data-&gt;hscb_dmat
comma
id|scb_data-&gt;hscb_dmamap
)paren
suffix:semicolon
r_case
l_int|1
suffix:colon
id|ahc_dma_tag_destroy
c_func
(paren
id|ahc
comma
id|scb_data-&gt;hscb_dmat
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scb_data-&gt;scbarray
op_ne
l_int|NULL
)paren
id|free
c_func
(paren
id|scb_data-&gt;scbarray
comma
id|M_DEVBUF
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahc_alloc_scbs
id|ahc_alloc_scbs
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_struct
id|scb_data
op_star
id|scb_data
suffix:semicolon
r_struct
id|scb
op_star
id|next_scb
suffix:semicolon
r_struct
id|sg_map_node
op_star
id|sg_map
suffix:semicolon
id|bus_addr_t
id|physaddr
suffix:semicolon
r_struct
id|ahc_dma_seg
op_star
id|segs
suffix:semicolon
r_int
id|newcount
suffix:semicolon
r_int
id|i
suffix:semicolon
id|scb_data
op_assign
id|ahc-&gt;scb_data
suffix:semicolon
r_if
c_cond
(paren
id|scb_data-&gt;numscbs
op_ge
id|AHC_SCB_MAX_ALLOC
)paren
multiline_comment|/* Can&squot;t allocate any more */
r_return
suffix:semicolon
id|next_scb
op_assign
op_amp
id|scb_data-&gt;scbarray
(braket
id|scb_data-&gt;numscbs
)braket
suffix:semicolon
id|sg_map
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|sg_map
)paren
comma
id|M_DEVBUF
comma
id|M_NOWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sg_map
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
multiline_comment|/* Allocate S/G space for the next batch of SCBS */
r_if
c_cond
(paren
id|ahc_dmamem_alloc
c_func
(paren
id|ahc
comma
id|scb_data-&gt;sg_dmat
comma
(paren
r_void
op_star
op_star
)paren
op_amp
id|sg_map-&gt;sg_vaddr
comma
id|BUS_DMA_NOWAIT
comma
op_amp
id|sg_map-&gt;sg_dmamap
)paren
op_ne
l_int|0
)paren
(brace
id|free
c_func
(paren
id|sg_map
comma
id|M_DEVBUF
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|SLIST_INSERT_HEAD
c_func
(paren
op_amp
id|scb_data-&gt;sg_maps
comma
id|sg_map
comma
id|links
)paren
suffix:semicolon
id|ahc_dmamap_load
c_func
(paren
id|ahc
comma
id|scb_data-&gt;sg_dmat
comma
id|sg_map-&gt;sg_dmamap
comma
id|sg_map-&gt;sg_vaddr
comma
id|PAGE_SIZE
comma
id|ahc_dmamap_cb
comma
op_amp
id|sg_map-&gt;sg_physaddr
comma
multiline_comment|/*flags*/
l_int|0
)paren
suffix:semicolon
id|segs
op_assign
id|sg_map-&gt;sg_vaddr
suffix:semicolon
id|physaddr
op_assign
id|sg_map-&gt;sg_physaddr
suffix:semicolon
id|newcount
op_assign
(paren
id|PAGE_SIZE
op_div
(paren
id|AHC_NSEG
op_star
r_sizeof
(paren
r_struct
id|ahc_dma_seg
)paren
)paren
)paren
suffix:semicolon
id|newcount
op_assign
id|MIN
c_func
(paren
id|newcount
comma
(paren
id|AHC_SCB_MAX_ALLOC
op_minus
id|scb_data-&gt;numscbs
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|newcount
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|scb_platform_data
op_star
id|pdata
suffix:semicolon
macro_line|#ifndef __linux__
r_int
id|error
suffix:semicolon
macro_line|#endif
id|pdata
op_assign
(paren
r_struct
id|scb_platform_data
op_star
)paren
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|pdata
)paren
comma
id|M_DEVBUF
comma
id|M_NOWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pdata
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|next_scb-&gt;platform_data
op_assign
id|pdata
suffix:semicolon
id|next_scb-&gt;sg_map
op_assign
id|sg_map
suffix:semicolon
id|next_scb-&gt;sg_list
op_assign
id|segs
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The sequencer always starts with the second entry.&n;&t;&t; * The first entry is embedded in the scb.&n;&t;&t; */
id|next_scb-&gt;sg_list_phys
op_assign
id|physaddr
op_plus
r_sizeof
(paren
r_struct
id|ahc_dma_seg
)paren
suffix:semicolon
id|next_scb-&gt;ahc_softc
op_assign
id|ahc
suffix:semicolon
id|next_scb-&gt;flags
op_assign
id|SCB_FREE
suffix:semicolon
macro_line|#ifndef __linux__
id|error
op_assign
id|ahc_dmamap_create
c_func
(paren
id|ahc
comma
id|ahc-&gt;buffer_dmat
comma
multiline_comment|/*flags*/
l_int|0
comma
op_amp
id|next_scb-&gt;dmamap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
r_break
suffix:semicolon
macro_line|#endif
id|next_scb-&gt;hscb
op_assign
op_amp
id|scb_data-&gt;hscbs
(braket
id|scb_data-&gt;numscbs
)braket
suffix:semicolon
id|next_scb-&gt;hscb-&gt;tag
op_assign
id|ahc-&gt;scb_data-&gt;numscbs
suffix:semicolon
id|SLIST_INSERT_HEAD
c_func
(paren
op_amp
id|ahc-&gt;scb_data-&gt;free_scbs
comma
id|next_scb
comma
id|links.sle
)paren
suffix:semicolon
id|segs
op_add_assign
id|AHC_NSEG
suffix:semicolon
id|physaddr
op_add_assign
(paren
id|AHC_NSEG
op_star
r_sizeof
(paren
r_struct
id|ahc_dma_seg
)paren
)paren
suffix:semicolon
id|next_scb
op_increment
suffix:semicolon
id|ahc-&gt;scb_data-&gt;numscbs
op_increment
suffix:semicolon
)brace
)brace
r_void
DECL|function|ahc_controller_info
id|ahc_controller_info
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_char
op_star
id|buf
)paren
(brace
r_int
id|len
suffix:semicolon
id|len
op_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%s: &quot;
comma
id|ahc_chip_names
(braket
id|ahc-&gt;chip
op_amp
id|AHC_CHIPID_MASK
)braket
)paren
suffix:semicolon
id|buf
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_TWIN
)paren
op_ne
l_int|0
)paren
id|len
op_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;Twin Channel, A SCSI Id=%d, &quot;
l_string|&quot;B SCSI Id=%d, primary %c, &quot;
comma
id|ahc-&gt;our_id
comma
id|ahc-&gt;our_id_b
comma
(paren
id|ahc-&gt;flags
op_amp
id|AHC_PRIMARY_CHANNEL
)paren
op_plus
l_char|&squot;A&squot;
)paren
suffix:semicolon
r_else
(brace
r_const
r_char
op_star
id|speed
suffix:semicolon
r_const
r_char
op_star
id|type
suffix:semicolon
id|speed
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_ULTRA
)paren
op_ne
l_int|0
)paren
(brace
id|speed
op_assign
l_string|&quot;Ultra &quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_DT
)paren
op_ne
l_int|0
)paren
(brace
id|speed
op_assign
l_string|&quot;Ultra160 &quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_ne
l_int|0
)paren
(brace
id|speed
op_assign
l_string|&quot;Ultra2 &quot;
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_WIDE
)paren
op_ne
l_int|0
)paren
(brace
id|type
op_assign
l_string|&quot;Wide&quot;
suffix:semicolon
)brace
r_else
(brace
id|type
op_assign
l_string|&quot;Single&quot;
suffix:semicolon
)brace
id|len
op_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%s%s Channel %c, SCSI Id=%d, &quot;
comma
id|speed
comma
id|type
comma
id|ahc-&gt;channel
comma
id|ahc-&gt;our_id
)paren
suffix:semicolon
)brace
id|buf
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;flags
op_amp
id|AHC_PAGESCBS
)paren
op_ne
l_int|0
)paren
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%d/%d SCBs&quot;
comma
id|ahc-&gt;scb_data-&gt;maxhscbs
comma
id|AHC_MAX_QUEUE
)paren
suffix:semicolon
r_else
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%d SCBs&quot;
comma
id|ahc-&gt;scb_data-&gt;maxhscbs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Start the board, ready for normal operation&n; */
r_int
DECL|function|ahc_init
id|ahc_init
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_int
id|max_targ
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|term
suffix:semicolon
id|u_int
id|scsi_conf
suffix:semicolon
id|u_int
id|scsiseq_template
suffix:semicolon
id|u_int
id|ultraenb
suffix:semicolon
id|u_int
id|discenable
suffix:semicolon
id|u_int
id|tagenable
suffix:semicolon
r_int
id|driver_data_size
suffix:semicolon
r_uint32
id|physaddr
suffix:semicolon
id|ahc-&gt;stack_size
op_assign
id|ahc_probe_stack_size
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc-&gt;saved_stack
op_assign
id|malloc
c_func
(paren
id|ahc-&gt;stack_size
op_star
r_sizeof
(paren
r_uint16
)paren
comma
id|M_DEVBUF
comma
id|M_NOWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;saved_stack
op_eq
l_int|NULL
)paren
r_return
(paren
id|ENOMEM
)paren
suffix:semicolon
macro_line|#ifdef AHC_DEBUG_SEQUENCER
id|ahc-&gt;flags
op_or_assign
id|AHC_SEQUENCER_DEBUG
suffix:semicolon
macro_line|#endif
macro_line|#ifdef AHC_PRINT_SRAM
id|printf
c_func
(paren
l_string|&quot;Scratch Ram:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0x20
suffix:semicolon
id|i
OL
l_int|0x5f
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|i
op_mod
l_int|8
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|i
op_ne
l_int|0
)paren
)paren
(brace
id|printf
(paren
l_string|&quot;&bslash;n              &quot;
)paren
suffix:semicolon
)brace
id|printf
(paren
l_string|&quot; 0x%x&quot;
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|i
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_MORE_SRAM
)paren
op_ne
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0x70
suffix:semicolon
id|i
OL
l_int|0x7f
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|i
op_mod
l_int|8
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|i
op_ne
l_int|0
)paren
)paren
(brace
id|printf
(paren
l_string|&quot;&bslash;n              &quot;
)paren
suffix:semicolon
)brace
id|printf
(paren
l_string|&quot; 0x%x&quot;
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|i
)paren
)paren
suffix:semicolon
)brace
)brace
id|printf
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Reading uninitialized scratch ram may&n;&t; * generate parity errors.&n;&t; */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CLRINT
comma
id|CLRPARERR
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CLRINT
comma
id|CLRBRKADRINT
)paren
suffix:semicolon
macro_line|#endif
id|max_targ
op_assign
l_int|15
suffix:semicolon
multiline_comment|/*&n;&t; * Assume we have a board at this stage and it has been reset.&n;&t; */
r_if
c_cond
(paren
(paren
id|ahc-&gt;flags
op_amp
id|AHC_USEDEFAULTS
)paren
op_ne
l_int|0
)paren
id|ahc-&gt;our_id
op_assign
id|ahc-&gt;our_id_b
op_assign
l_int|7
suffix:semicolon
multiline_comment|/*&n;&t; * Default to allowing initiator operations.&n;&t; */
id|ahc-&gt;flags
op_or_assign
id|AHC_INITIATORROLE
suffix:semicolon
multiline_comment|/*&n;&t; * Only allow target mode features if this unit has them enabled.&n;&t; */
r_if
c_cond
(paren
(paren
id|AHC_TMODE_ENABLE
op_amp
(paren
l_int|0x1
op_lshift
id|ahc-&gt;unit
)paren
)paren
op_eq
l_int|0
)paren
id|ahc-&gt;features
op_and_assign
op_complement
id|AHC_TARGETMODE
suffix:semicolon
macro_line|#ifndef __linux__
multiline_comment|/* DMA tag for mapping buffers into device visible space. */
r_if
c_cond
(paren
id|ahc_dma_tag_create
c_func
(paren
id|ahc
comma
id|ahc-&gt;parent_dmat
comma
multiline_comment|/*alignment*/
l_int|1
comma
multiline_comment|/*boundary*/
id|BUS_SPACE_MAXADDR_32BIT
op_plus
l_int|1
comma
multiline_comment|/*lowaddr*/
id|BUS_SPACE_MAXADDR
comma
multiline_comment|/*highaddr*/
id|BUS_SPACE_MAXADDR
comma
multiline_comment|/*filter*/
l_int|NULL
comma
multiline_comment|/*filterarg*/
l_int|NULL
comma
multiline_comment|/*maxsize*/
id|MAXBSIZE
comma
multiline_comment|/*nsegments*/
id|AHC_NSEG
comma
multiline_comment|/*maxsegsz*/
id|AHC_MAXTRANSFER_SIZE
comma
multiline_comment|/*flags*/
id|BUS_DMA_ALLOCNOW
comma
op_amp
id|ahc-&gt;buffer_dmat
)paren
op_ne
l_int|0
)paren
(brace
r_return
(paren
id|ENOMEM
)paren
suffix:semicolon
)brace
macro_line|#endif
id|ahc-&gt;init_level
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * DMA tag for our command fifos and other data in system memory&n;&t; * the card&squot;s sequencer must be able to access.  For initiator&n;&t; * roles, we need to allocate space for the qinfifo and qoutfifo.&n;&t; * The qinfifo and qoutfifo are composed of 256 1 byte elements. &n;&t; * When providing for the target mode role, we must additionally&n;&t; * provide space for the incoming target command fifo and an extra&n;&t; * byte to deal with a dma bug in some chip versions.&n;&t; */
id|driver_data_size
op_assign
l_int|2
op_star
l_int|256
op_star
r_sizeof
(paren
r_uint8
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_TARGETMODE
)paren
op_ne
l_int|0
)paren
id|driver_data_size
op_add_assign
id|AHC_TMODE_CMDS
op_star
r_sizeof
(paren
r_struct
id|target_cmd
)paren
op_plus
multiline_comment|/*DMA WideOdd Bug Buffer*/
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ahc_dma_tag_create
c_func
(paren
id|ahc
comma
id|ahc-&gt;parent_dmat
comma
multiline_comment|/*alignment*/
l_int|1
comma
multiline_comment|/*boundary*/
id|BUS_SPACE_MAXADDR_32BIT
op_plus
l_int|1
comma
multiline_comment|/*lowaddr*/
id|BUS_SPACE_MAXADDR_32BIT
comma
multiline_comment|/*highaddr*/
id|BUS_SPACE_MAXADDR
comma
multiline_comment|/*filter*/
l_int|NULL
comma
multiline_comment|/*filterarg*/
l_int|NULL
comma
id|driver_data_size
comma
multiline_comment|/*nsegments*/
l_int|1
comma
multiline_comment|/*maxsegsz*/
id|BUS_SPACE_MAXSIZE_32BIT
comma
multiline_comment|/*flags*/
l_int|0
comma
op_amp
id|ahc-&gt;shared_data_dmat
)paren
op_ne
l_int|0
)paren
(brace
r_return
(paren
id|ENOMEM
)paren
suffix:semicolon
)brace
id|ahc-&gt;init_level
op_increment
suffix:semicolon
multiline_comment|/* Allocation of driver data */
r_if
c_cond
(paren
id|ahc_dmamem_alloc
c_func
(paren
id|ahc
comma
id|ahc-&gt;shared_data_dmat
comma
(paren
r_void
op_star
op_star
)paren
op_amp
id|ahc-&gt;qoutfifo
comma
id|BUS_DMA_NOWAIT
comma
op_amp
id|ahc-&gt;shared_data_dmamap
)paren
op_ne
l_int|0
)paren
(brace
r_return
(paren
id|ENOMEM
)paren
suffix:semicolon
)brace
id|ahc-&gt;init_level
op_increment
suffix:semicolon
multiline_comment|/* And permanently map it in */
id|ahc_dmamap_load
c_func
(paren
id|ahc
comma
id|ahc-&gt;shared_data_dmat
comma
id|ahc-&gt;shared_data_dmamap
comma
id|ahc-&gt;qoutfifo
comma
id|driver_data_size
comma
id|ahc_dmamap_cb
comma
op_amp
id|ahc-&gt;shared_data_busaddr
comma
multiline_comment|/*flags*/
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_TARGETMODE
)paren
op_ne
l_int|0
)paren
(brace
id|ahc-&gt;targetcmds
op_assign
(paren
r_struct
id|target_cmd
op_star
)paren
id|ahc-&gt;qoutfifo
suffix:semicolon
id|ahc-&gt;qoutfifo
op_assign
(paren
r_uint8
op_star
)paren
op_amp
id|ahc-&gt;targetcmds
(braket
id|AHC_TMODE_CMDS
)braket
suffix:semicolon
id|ahc-&gt;dma_bug_buf
op_assign
id|ahc-&gt;shared_data_busaddr
op_plus
id|driver_data_size
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* All target command blocks start out invalid. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AHC_TMODE_CMDS
suffix:semicolon
id|i
op_increment
)paren
id|ahc-&gt;targetcmds
(braket
id|i
)braket
dot
id|cmd_valid
op_assign
l_int|0
suffix:semicolon
id|ahc_sync_tqinfifo
c_func
(paren
id|ahc
comma
id|BUS_DMASYNC_PREREAD
)paren
suffix:semicolon
id|ahc-&gt;tqinfifonext
op_assign
l_int|1
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|KERNEL_TQINPOS
comma
id|ahc-&gt;tqinfifonext
op_minus
l_int|1
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|TQINPOS
comma
id|ahc-&gt;tqinfifonext
)paren
suffix:semicolon
id|ahc-&gt;qoutfifo
op_assign
(paren
r_uint8
op_star
)paren
op_amp
id|ahc-&gt;targetcmds
(braket
l_int|256
)braket
suffix:semicolon
)brace
id|ahc-&gt;qinfifo
op_assign
op_amp
id|ahc-&gt;qoutfifo
(braket
l_int|256
)braket
suffix:semicolon
id|ahc-&gt;init_level
op_increment
suffix:semicolon
multiline_comment|/* Allocate SCB data now that buffer_dmat is initialized */
r_if
c_cond
(paren
id|ahc-&gt;scb_data-&gt;maxhscbs
op_eq
l_int|0
)paren
r_if
c_cond
(paren
id|ahc_init_scbdata
c_func
(paren
id|ahc
)paren
op_ne
l_int|0
)paren
r_return
(paren
id|ENOMEM
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate a tstate to house information for our&n;&t; * initiator presence on the bus as well as the user&n;&t; * data for any target mode initiator.&n;&t; */
r_if
c_cond
(paren
id|ahc_alloc_tstate
c_func
(paren
id|ahc
comma
id|ahc-&gt;our_id
comma
l_char|&squot;A&squot;
)paren
op_eq
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: unable to allocate ahc_tmode_tstate.  &quot;
l_string|&quot;Failing attach&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
)paren
suffix:semicolon
r_return
(paren
id|ENOMEM
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_TWIN
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ahc_alloc_tstate
c_func
(paren
id|ahc
comma
id|ahc-&gt;our_id_b
comma
l_char|&squot;B&squot;
)paren
op_eq
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: unable to allocate ahc_tmode_tstate.  &quot;
l_string|&quot;Failing attach&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
)paren
suffix:semicolon
r_return
(paren
id|ENOMEM
)paren
suffix:semicolon
)brace
)brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SEQ_FLAGS
comma
l_int|0
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SEQ_FLAGS2
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;scb_data-&gt;maxhscbs
OL
id|AHC_SCB_MAX_ALLOC
)paren
(brace
id|ahc-&gt;flags
op_or_assign
id|AHC_PAGESCBS
suffix:semicolon
)brace
r_else
(brace
id|ahc-&gt;flags
op_and_assign
op_complement
id|AHC_PAGESCBS
suffix:semicolon
)brace
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_MISC
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: hardware scb %d bytes; kernel scb %d bytes; &quot;
l_string|&quot;ahc_dma %d bytes&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
r_sizeof
(paren
r_struct
id|hardware_scb
)paren
comma
r_sizeof
(paren
r_struct
id|scb
)paren
comma
r_sizeof
(paren
r_struct
id|ahc_dma_seg
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* AHC_DEBUG */
multiline_comment|/* Set the SCSI Id, SXFRCTL0, SXFRCTL1, and SIMODE1, for both channels*/
r_if
c_cond
(paren
id|ahc-&gt;features
op_amp
id|AHC_TWIN
)paren
(brace
multiline_comment|/*&n;&t;&t; * The device is gated to channel B after a chip reset,&n;&t;&t; * so set those values first&n;&t;&t; */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SBLKCTL
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SBLKCTL
)paren
op_or
id|SELBUSB
)paren
suffix:semicolon
id|term
op_assign
(paren
id|ahc-&gt;flags
op_amp
id|AHC_TERM_ENB_B
)paren
op_ne
l_int|0
ques
c_cond
id|STPWEN
suffix:colon
l_int|0
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSIID
comma
id|ahc-&gt;our_id_b
)paren
suffix:semicolon
id|scsi_conf
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSICONF
op_plus
l_int|1
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SXFRCTL1
comma
(paren
id|scsi_conf
op_amp
(paren
id|ENSPCHK
op_or
id|STIMESEL
)paren
)paren
op_or
id|term
op_or
id|ahc-&gt;seltime_b
op_or
id|ENSTIMER
op_or
id|ACTNEGEN
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_ne
l_int|0
)paren
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SIMODE0
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SIMODE0
)paren
op_or
id|ENIOERR
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SIMODE1
comma
id|ENSELTIMO
op_or
id|ENSCSIRST
op_or
id|ENSCSIPERR
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SXFRCTL0
comma
id|DFON
op_or
id|SPIOEN
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scsi_conf
op_amp
id|RESET_SCSI
)paren
op_ne
l_int|0
op_logical_and
(paren
id|ahc-&gt;flags
op_amp
id|AHC_INITIATORROLE
)paren
op_ne
l_int|0
)paren
id|ahc-&gt;flags
op_or_assign
id|AHC_RESET_BUS_B
suffix:semicolon
multiline_comment|/* Select Channel A */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SBLKCTL
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SBLKCTL
)paren
op_amp
op_complement
id|SELBUSB
)paren
suffix:semicolon
)brace
id|term
op_assign
(paren
id|ahc-&gt;flags
op_amp
id|AHC_TERM_ENB_A
)paren
op_ne
l_int|0
ques
c_cond
id|STPWEN
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_ne
l_int|0
)paren
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSIID_ULTRA2
comma
id|ahc-&gt;our_id
)paren
suffix:semicolon
r_else
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSIID
comma
id|ahc-&gt;our_id
)paren
suffix:semicolon
id|scsi_conf
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSICONF
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SXFRCTL1
comma
(paren
id|scsi_conf
op_amp
(paren
id|ENSPCHK
op_or
id|STIMESEL
)paren
)paren
op_or
id|term
op_or
id|ahc-&gt;seltime
op_or
id|ENSTIMER
op_or
id|ACTNEGEN
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_ne
l_int|0
)paren
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SIMODE0
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SIMODE0
)paren
op_or
id|ENIOERR
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SIMODE1
comma
id|ENSELTIMO
op_or
id|ENSCSIRST
op_or
id|ENSCSIPERR
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SXFRCTL0
comma
id|DFON
op_or
id|SPIOEN
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scsi_conf
op_amp
id|RESET_SCSI
)paren
op_ne
l_int|0
op_logical_and
(paren
id|ahc-&gt;flags
op_amp
id|AHC_INITIATORROLE
)paren
op_ne
l_int|0
)paren
id|ahc-&gt;flags
op_or_assign
id|AHC_RESET_BUS_A
suffix:semicolon
multiline_comment|/*&n;&t; * Look at the information that board initialization or&n;&t; * the board bios has left us.&n;&t; */
id|ultraenb
op_assign
l_int|0
suffix:semicolon
id|tagenable
op_assign
id|ALL_TARGETS_MASK
suffix:semicolon
multiline_comment|/* Grab the disconnection disable table and invert it for our needs */
r_if
c_cond
(paren
(paren
id|ahc-&gt;flags
op_amp
id|AHC_USEDEFAULTS
)paren
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: Host Adapter Bios disabled.  Using default SCSI &quot;
l_string|&quot;device parameters&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
)paren
suffix:semicolon
id|ahc-&gt;flags
op_or_assign
id|AHC_EXTENDED_TRANS_A
op_or
id|AHC_EXTENDED_TRANS_B
op_or
id|AHC_TERM_ENB_A
op_or
id|AHC_TERM_ENB_B
suffix:semicolon
id|discenable
op_assign
id|ALL_TARGETS_MASK
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_ULTRA
)paren
op_ne
l_int|0
)paren
id|ultraenb
op_assign
id|ALL_TARGETS_MASK
suffix:semicolon
)brace
r_else
(brace
id|discenable
op_assign
op_complement
(paren
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|DISC_DSB
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
op_or
id|ahc_inb
c_func
(paren
id|ahc
comma
id|DISC_DSB
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
(paren
id|AHC_ULTRA
op_or
id|AHC_ULTRA2
)paren
)paren
op_ne
l_int|0
)paren
id|ultraenb
op_assign
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|ULTRA_ENB
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
op_or
id|ahc_inb
c_func
(paren
id|ahc
comma
id|ULTRA_ENB
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
(paren
id|AHC_WIDE
op_or
id|AHC_TWIN
)paren
)paren
op_eq
l_int|0
)paren
id|max_targ
op_assign
l_int|7
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|max_targ
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ahc_initiator_tinfo
op_star
id|tinfo
suffix:semicolon
r_struct
id|ahc_tmode_tstate
op_star
id|tstate
suffix:semicolon
id|u_int
id|our_id
suffix:semicolon
id|u_int
id|target_id
suffix:semicolon
r_char
id|channel
suffix:semicolon
id|channel
op_assign
l_char|&squot;A&squot;
suffix:semicolon
id|our_id
op_assign
id|ahc-&gt;our_id
suffix:semicolon
id|target_id
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|7
op_logical_and
(paren
id|ahc-&gt;features
op_amp
id|AHC_TWIN
)paren
op_ne
l_int|0
)paren
(brace
id|channel
op_assign
l_char|&squot;B&squot;
suffix:semicolon
id|our_id
op_assign
id|ahc-&gt;our_id_b
suffix:semicolon
id|target_id
op_assign
id|i
op_mod
l_int|8
suffix:semicolon
)brace
id|tinfo
op_assign
id|ahc_fetch_transinfo
c_func
(paren
id|ahc
comma
id|channel
comma
id|our_id
comma
id|target_id
comma
op_amp
id|tstate
)paren
suffix:semicolon
multiline_comment|/* Default to async narrow across the board */
id|memset
c_func
(paren
id|tinfo
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|tinfo
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;flags
op_amp
id|AHC_USEDEFAULTS
)paren
(brace
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_WIDE
)paren
op_ne
l_int|0
)paren
id|tinfo-&gt;user.width
op_assign
id|MSG_EXT_WDTR_BUS_16_BIT
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * These will be truncated when we determine the&n;&t;&t;&t; * connection type we have with the target.&n;&t;&t;&t; */
id|tinfo-&gt;user.period
op_assign
id|ahc_syncrates-&gt;period
suffix:semicolon
id|tinfo-&gt;user.offset
op_assign
op_complement
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|u_int
id|scsirate
suffix:semicolon
r_uint16
id|mask
suffix:semicolon
multiline_comment|/* Take the settings leftover in scratch RAM. */
id|scsirate
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|TARG_SCSIRATE
op_plus
id|i
)paren
suffix:semicolon
id|mask
op_assign
(paren
l_int|0x01
op_lshift
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_ne
l_int|0
)paren
(brace
id|u_int
id|offset
suffix:semicolon
id|u_int
id|maxsync
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scsirate
op_amp
id|SOFS
)paren
op_eq
l_int|0x0F
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Haven&squot;t negotiated yet,&n;&t;&t;&t;&t;&t; * so the format is different.&n;&t;&t;&t;&t;&t; */
id|scsirate
op_assign
(paren
id|scsirate
op_amp
id|SXFR
)paren
op_rshift
l_int|4
op_or
(paren
id|ultraenb
op_amp
id|mask
)paren
ques
c_cond
l_int|0x08
suffix:colon
l_int|0x0
op_or
(paren
id|scsirate
op_amp
id|WIDEXFER
)paren
suffix:semicolon
id|offset
op_assign
id|MAX_OFFSET_ULTRA2
suffix:semicolon
)brace
r_else
id|offset
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|TARG_OFFSET
op_plus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scsirate
op_amp
op_complement
id|WIDEXFER
)paren
op_eq
l_int|0
op_logical_and
id|offset
op_ne
l_int|0
)paren
multiline_comment|/* Set to the lowest sync rate, 5MHz */
id|scsirate
op_or_assign
l_int|0x1c
suffix:semicolon
id|maxsync
op_assign
id|AHC_SYNCRATE_ULTRA2
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_DT
)paren
op_ne
l_int|0
)paren
id|maxsync
op_assign
id|AHC_SYNCRATE_DT
suffix:semicolon
id|tinfo-&gt;user.period
op_assign
id|ahc_find_period
c_func
(paren
id|ahc
comma
id|scsirate
comma
id|maxsync
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_eq
l_int|0
)paren
id|tinfo-&gt;user.period
op_assign
l_int|0
suffix:semicolon
r_else
id|tinfo-&gt;user.offset
op_assign
op_complement
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scsirate
op_amp
id|SXFR_ULTRA2
)paren
op_le
l_int|8
multiline_comment|/*10MHz*/
op_logical_and
(paren
id|ahc-&gt;features
op_amp
id|AHC_DT
)paren
op_ne
l_int|0
)paren
id|tinfo-&gt;user.ppr_options
op_assign
id|MSG_EXT_PPR_DT_REQ
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|scsirate
op_amp
id|SOFS
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|scsirate
op_amp
id|SXFR
)paren
op_eq
l_int|0x40
op_logical_and
(paren
id|ultraenb
op_amp
id|mask
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Treat 10MHz as a non-ultra speed */
id|scsirate
op_and_assign
op_complement
id|SXFR
suffix:semicolon
id|ultraenb
op_and_assign
op_complement
id|mask
suffix:semicolon
)brace
id|tinfo-&gt;user.period
op_assign
id|ahc_find_period
c_func
(paren
id|ahc
comma
id|scsirate
comma
(paren
id|ultraenb
op_amp
id|mask
)paren
ques
c_cond
id|AHC_SYNCRATE_ULTRA
suffix:colon
id|AHC_SYNCRATE_FAST
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tinfo-&gt;user.period
op_ne
l_int|0
)paren
id|tinfo-&gt;user.offset
op_assign
op_complement
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tinfo-&gt;user.period
op_eq
l_int|0
)paren
id|tinfo-&gt;user.offset
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scsirate
op_amp
id|WIDEXFER
)paren
op_ne
l_int|0
op_logical_and
(paren
id|ahc-&gt;features
op_amp
id|AHC_WIDE
)paren
op_ne
l_int|0
)paren
id|tinfo-&gt;user.width
op_assign
id|MSG_EXT_WDTR_BUS_16_BIT
suffix:semicolon
id|tinfo-&gt;user.protocol_version
op_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_DT
)paren
op_ne
l_int|0
)paren
id|tinfo-&gt;user.transport_version
op_assign
l_int|3
suffix:semicolon
r_else
id|tinfo-&gt;user.transport_version
op_assign
l_int|2
suffix:semicolon
id|tinfo-&gt;goal.protocol_version
op_assign
l_int|2
suffix:semicolon
id|tinfo-&gt;goal.transport_version
op_assign
l_int|2
suffix:semicolon
id|tinfo-&gt;curr.protocol_version
op_assign
l_int|2
suffix:semicolon
id|tinfo-&gt;curr.transport_version
op_assign
l_int|2
suffix:semicolon
)brace
id|tstate-&gt;ultraenb
op_assign
id|ultraenb
suffix:semicolon
)brace
id|ahc-&gt;user_discenable
op_assign
id|discenable
suffix:semicolon
id|ahc-&gt;user_tagenable
op_assign
id|tagenable
suffix:semicolon
multiline_comment|/* There are no untagged SCBs active yet. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ahc_unbusy_tcl
c_func
(paren
id|ahc
comma
id|BUILD_TCL
c_func
(paren
id|i
op_lshift
l_int|4
comma
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;flags
op_amp
id|AHC_SCB_BTT
)paren
op_ne
l_int|0
)paren
(brace
r_int
id|lun
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * The SCB based BTT allows an entry per&n;&t;&t;&t; * target and lun pair.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|lun
op_assign
l_int|1
suffix:semicolon
id|lun
OL
id|AHC_NUM_LUNS
suffix:semicolon
id|lun
op_increment
)paren
id|ahc_unbusy_tcl
c_func
(paren
id|ahc
comma
id|BUILD_TCL
c_func
(paren
id|i
op_lshift
l_int|4
comma
id|lun
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* All of our queues are empty */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
id|ahc-&gt;qoutfifo
(braket
id|i
)braket
op_assign
id|SCB_LIST_NULL
suffix:semicolon
id|ahc_sync_qoutfifo
c_func
(paren
id|ahc
comma
id|BUS_DMASYNC_PREREAD
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
id|ahc-&gt;qinfifo
(braket
id|i
)braket
op_assign
id|SCB_LIST_NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_MULTI_TID
)paren
op_ne
l_int|0
)paren
(brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|TARGID
comma
l_int|0
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|TARGID
op_plus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Tell the sequencer where it can find our arrays in memory.&n;&t; */
id|physaddr
op_assign
id|ahc-&gt;scb_data-&gt;hscb_busaddr
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|HSCB_ADDR
comma
id|physaddr
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|HSCB_ADDR
op_plus
l_int|1
comma
(paren
id|physaddr
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|HSCB_ADDR
op_plus
l_int|2
comma
(paren
id|physaddr
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|HSCB_ADDR
op_plus
l_int|3
comma
(paren
id|physaddr
op_rshift
l_int|24
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|physaddr
op_assign
id|ahc-&gt;shared_data_busaddr
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SHARED_DATA_ADDR
comma
id|physaddr
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SHARED_DATA_ADDR
op_plus
l_int|1
comma
(paren
id|physaddr
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SHARED_DATA_ADDR
op_plus
l_int|2
comma
(paren
id|physaddr
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SHARED_DATA_ADDR
op_plus
l_int|3
comma
(paren
id|physaddr
op_rshift
l_int|24
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the group code to command length table.&n;&t; * This overrides the values in TARG_SCSIRATE, so only&n;&t; * setup the table after we have processed that information.&n;&t; */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CMDSIZE_TABLE
comma
l_int|5
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CMDSIZE_TABLE
op_plus
l_int|1
comma
l_int|9
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CMDSIZE_TABLE
op_plus
l_int|2
comma
l_int|9
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CMDSIZE_TABLE
op_plus
l_int|3
comma
l_int|0
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CMDSIZE_TABLE
op_plus
l_int|4
comma
l_int|15
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CMDSIZE_TABLE
op_plus
l_int|5
comma
l_int|11
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CMDSIZE_TABLE
op_plus
l_int|6
comma
l_int|0
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CMDSIZE_TABLE
op_plus
l_int|7
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Tell the sequencer of our initial queue positions */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|KERNEL_QINPOS
comma
l_int|0
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|QINPOS
comma
l_int|0
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|QOUTPOS
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Use the built in queue management registers&n;&t; * if they are available.&n;&t; */
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_QUEUE_REGS
)paren
op_ne
l_int|0
)paren
(brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|QOFF_CTLSTA
comma
id|SCB_QSIZE_256
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SDSCB_QOFF
comma
l_int|0
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SNSCB_QOFF
comma
l_int|0
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|HNSCB_QOFF
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* We don&squot;t have any waiting selections */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|WAITING_SCBH
comma
id|SCB_LIST_NULL
)paren
suffix:semicolon
multiline_comment|/* Our disconnection list is empty too */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|DISCONNECTED_SCBH
comma
id|SCB_LIST_NULL
)paren
suffix:semicolon
multiline_comment|/* Message out buffer starts empty */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|MSG_OUT
comma
id|MSG_NOOP
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Setup the allowed SCSI Sequences based on operational mode.&n;&t; * If we are a target, we&squot;ll enalbe select in operations once&n;&t; * we&squot;ve had a lun enabled.&n;&t; */
id|scsiseq_template
op_assign
id|ENSELO
op_or
id|ENAUTOATNO
op_or
id|ENAUTOATNP
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;flags
op_amp
id|AHC_INITIATORROLE
)paren
op_ne
l_int|0
)paren
id|scsiseq_template
op_or_assign
id|ENRSELI
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSISEQ_TEMPLATE
comma
id|scsiseq_template
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Load the Sequencer program and Enable the adapter&n;&t; * in &quot;fast&quot; mode.&n;&t; */
r_if
c_cond
(paren
id|bootverbose
)paren
id|printf
c_func
(paren
l_string|&quot;%s: Downloading Sequencer Program...&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
)paren
suffix:semicolon
id|ahc_loadseq
c_func
(paren
id|ahc
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_ne
l_int|0
)paren
(brace
r_int
id|wait
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Wait for up to 500ms for our transceivers&n;&t;&t; * to settle.  If the adapter does not have&n;&t;&t; * a cable attached, the tranceivers may&n;&t;&t; * never settle, so don&squot;t complain if we&n;&t;&t; * fail here.&n;&t;&t; */
id|ahc_pause
c_func
(paren
id|ahc
)paren
suffix:semicolon
r_for
c_loop
(paren
id|wait
op_assign
l_int|5000
suffix:semicolon
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SBLKCTL
)paren
op_amp
(paren
id|ENAB40
op_or
id|ENAB20
)paren
)paren
op_eq
l_int|0
op_logical_and
id|wait
suffix:semicolon
id|wait
op_decrement
)paren
id|ahc_delay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|ahc_unpause
c_func
(paren
id|ahc
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahc_intr_enable
id|ahc_intr_enable
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_int
id|enable
)paren
(brace
id|u_int
id|hcntrl
suffix:semicolon
id|hcntrl
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|HCNTRL
)paren
suffix:semicolon
id|hcntrl
op_and_assign
op_complement
id|INTEN
suffix:semicolon
id|ahc-&gt;pause
op_and_assign
op_complement
id|INTEN
suffix:semicolon
id|ahc-&gt;unpause
op_and_assign
op_complement
id|INTEN
suffix:semicolon
r_if
c_cond
(paren
id|enable
)paren
(brace
id|hcntrl
op_or_assign
id|INTEN
suffix:semicolon
id|ahc-&gt;pause
op_or_assign
id|INTEN
suffix:semicolon
id|ahc-&gt;unpause
op_or_assign
id|INTEN
suffix:semicolon
)brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|HCNTRL
comma
id|hcntrl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Ensure that the card is paused in a location&n; * outside of all critical sections and that all&n; * pending work is completed prior to returning.&n; * This routine should only be called from outside&n; * an interrupt context.&n; */
r_void
DECL|function|ahc_pause_and_flushwork
id|ahc_pause_and_flushwork
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_int
id|intstat
suffix:semicolon
r_int
id|maxloops
suffix:semicolon
r_int
id|paused
suffix:semicolon
id|maxloops
op_assign
l_int|1000
suffix:semicolon
id|ahc-&gt;flags
op_or_assign
id|AHC_ALL_INTERRUPTS
suffix:semicolon
id|intstat
op_assign
l_int|0
suffix:semicolon
id|paused
op_assign
id|FALSE
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|paused
)paren
id|ahc_unpause
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_intr
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_pause
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|paused
op_assign
id|TRUE
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSISEQ
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSISEQ
)paren
op_amp
op_complement
id|ENSELO
)paren
suffix:semicolon
id|ahc_clear_critical_section
c_func
(paren
id|ahc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|intstat
op_eq
l_int|0xFF
op_logical_and
(paren
id|ahc-&gt;features
op_amp
id|AHC_REMOVABLE
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|maxloops
op_logical_and
(paren
(paren
(paren
id|intstat
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|INTSTAT
)paren
)paren
op_amp
id|INT_PEND
)paren
op_ne
l_int|0
op_logical_or
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SSTAT0
)paren
op_amp
(paren
id|SELDO
op_or
id|SELINGO
)paren
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|maxloops
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Infinite interrupt loop, INTSTAT = %x&quot;
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|INTSTAT
)paren
)paren
suffix:semicolon
)brace
id|ahc_platform_flushwork
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc-&gt;flags
op_and_assign
op_complement
id|AHC_ALL_INTERRUPTS
suffix:semicolon
)brace
r_int
DECL|function|ahc_suspend
id|ahc_suspend
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_uint8
op_star
id|ptr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ahc_pause_and_flushwork
c_func
(paren
id|ahc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|LIST_FIRST
c_func
(paren
op_amp
id|ahc-&gt;pending_scbs
)paren
op_ne
l_int|NULL
)paren
r_return
(paren
id|EBUSY
)paren
suffix:semicolon
macro_line|#if AHC_TARGET_MODE
multiline_comment|/*&n;&t; * XXX What about ATIOs that have not yet been serviced?&n;&t; * Perhaps we should just refuse to be suspended if we&n;&t; * are acting in a target role.&n;&t; */
r_if
c_cond
(paren
id|ahc-&gt;pending_device
op_ne
l_int|NULL
)paren
r_return
(paren
id|EBUSY
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Save volatile registers */
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_TWIN
)paren
op_ne
l_int|0
)paren
(brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SBLKCTL
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SBLKCTL
)paren
op_or
id|SELBUSB
)paren
suffix:semicolon
id|ahc-&gt;suspend_state.channel
(braket
l_int|1
)braket
dot
id|scsiseq
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSISEQ
)paren
suffix:semicolon
id|ahc-&gt;suspend_state.channel
(braket
l_int|1
)braket
dot
id|sxfrctl0
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SXFRCTL0
)paren
suffix:semicolon
id|ahc-&gt;suspend_state.channel
(braket
l_int|1
)braket
dot
id|sxfrctl1
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SXFRCTL1
)paren
suffix:semicolon
id|ahc-&gt;suspend_state.channel
(braket
l_int|1
)braket
dot
id|simode0
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SIMODE0
)paren
suffix:semicolon
id|ahc-&gt;suspend_state.channel
(braket
l_int|1
)braket
dot
id|simode1
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SIMODE1
)paren
suffix:semicolon
id|ahc-&gt;suspend_state.channel
(braket
l_int|1
)braket
dot
id|seltimer
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SELTIMER
)paren
suffix:semicolon
id|ahc-&gt;suspend_state.channel
(braket
l_int|1
)braket
dot
id|seqctl
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SEQCTL
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SBLKCTL
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SBLKCTL
)paren
op_amp
op_complement
id|SELBUSB
)paren
suffix:semicolon
)brace
id|ahc-&gt;suspend_state.channel
(braket
l_int|0
)braket
dot
id|scsiseq
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSISEQ
)paren
suffix:semicolon
id|ahc-&gt;suspend_state.channel
(braket
l_int|0
)braket
dot
id|sxfrctl0
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SXFRCTL0
)paren
suffix:semicolon
id|ahc-&gt;suspend_state.channel
(braket
l_int|0
)braket
dot
id|sxfrctl1
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SXFRCTL1
)paren
suffix:semicolon
id|ahc-&gt;suspend_state.channel
(braket
l_int|0
)braket
dot
id|simode0
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SIMODE0
)paren
suffix:semicolon
id|ahc-&gt;suspend_state.channel
(braket
l_int|0
)braket
dot
id|simode1
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SIMODE1
)paren
suffix:semicolon
id|ahc-&gt;suspend_state.channel
(braket
l_int|0
)braket
dot
id|seltimer
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SELTIMER
)paren
suffix:semicolon
id|ahc-&gt;suspend_state.channel
(braket
l_int|0
)braket
dot
id|seqctl
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SEQCTL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;chip
op_amp
id|AHC_PCI
)paren
op_ne
l_int|0
)paren
(brace
id|ahc-&gt;suspend_state.dscommand0
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|DSCOMMAND0
)paren
suffix:semicolon
id|ahc-&gt;suspend_state.dspcistatus
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|DSPCISTATUS
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_DT
)paren
op_ne
l_int|0
)paren
(brace
id|u_int
id|sfunct
suffix:semicolon
id|sfunct
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SFUNCT
)paren
op_amp
op_complement
id|ALT_MODE
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SFUNCT
comma
id|sfunct
op_or
id|ALT_MODE
)paren
suffix:semicolon
id|ahc-&gt;suspend_state.optionmode
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|OPTIONMODE
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SFUNCT
comma
id|sfunct
)paren
suffix:semicolon
id|ahc-&gt;suspend_state.crccontrol1
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|CRCCONTROL1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_MULTI_FUNC
)paren
op_ne
l_int|0
)paren
id|ahc-&gt;suspend_state.scbbaddr
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCBBADDR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_ne
l_int|0
)paren
id|ahc-&gt;suspend_state.dff_thrsh
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|DFF_THRSH
)paren
suffix:semicolon
id|ptr
op_assign
id|ahc-&gt;suspend_state.scratch_ram
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|64
suffix:semicolon
id|i
op_increment
)paren
op_star
id|ptr
op_increment
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SRAM_BASE
op_plus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_MORE_SRAM
)paren
op_ne
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
op_star
id|ptr
op_increment
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|TARG_OFFSET
op_plus
id|i
)paren
suffix:semicolon
)brace
id|ptr
op_assign
id|ahc-&gt;suspend_state.btt
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;flags
op_amp
id|AHC_SCB_BTT
)paren
op_ne
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AHC_NUM_TARGETS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|AHC_NUM_LUNS
suffix:semicolon
id|j
op_increment
)paren
(brace
id|u_int
id|tcl
suffix:semicolon
id|tcl
op_assign
id|BUILD_TCL
c_func
(paren
id|i
op_lshift
l_int|4
comma
id|j
)paren
suffix:semicolon
op_star
id|ptr
op_assign
id|ahc_index_busy_tcl
c_func
(paren
id|ahc
comma
id|tcl
)paren
suffix:semicolon
)brace
)brace
)brace
id|ahc_shutdown
c_func
(paren
id|ahc
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_int
DECL|function|ahc_resume
id|ahc_resume
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_uint8
op_star
id|ptr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ahc_reset
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_build_free_scb_list
c_func
(paren
id|ahc
)paren
suffix:semicolon
multiline_comment|/* Restore volatile registers */
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_TWIN
)paren
op_ne
l_int|0
)paren
(brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SBLKCTL
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SBLKCTL
)paren
op_or
id|SELBUSB
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSIID
comma
id|ahc-&gt;our_id
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSISEQ
comma
id|ahc-&gt;suspend_state.channel
(braket
l_int|1
)braket
dot
id|scsiseq
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SXFRCTL0
comma
id|ahc-&gt;suspend_state.channel
(braket
l_int|1
)braket
dot
id|sxfrctl0
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SXFRCTL1
comma
id|ahc-&gt;suspend_state.channel
(braket
l_int|1
)braket
dot
id|sxfrctl1
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SIMODE0
comma
id|ahc-&gt;suspend_state.channel
(braket
l_int|1
)braket
dot
id|simode0
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SIMODE1
comma
id|ahc-&gt;suspend_state.channel
(braket
l_int|1
)braket
dot
id|simode1
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SELTIMER
comma
id|ahc-&gt;suspend_state.channel
(braket
l_int|1
)braket
dot
id|seltimer
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SEQCTL
comma
id|ahc-&gt;suspend_state.channel
(braket
l_int|1
)braket
dot
id|seqctl
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SBLKCTL
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SBLKCTL
)paren
op_amp
op_complement
id|SELBUSB
)paren
suffix:semicolon
)brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSISEQ
comma
id|ahc-&gt;suspend_state.channel
(braket
l_int|0
)braket
dot
id|scsiseq
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SXFRCTL0
comma
id|ahc-&gt;suspend_state.channel
(braket
l_int|0
)braket
dot
id|sxfrctl0
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SXFRCTL1
comma
id|ahc-&gt;suspend_state.channel
(braket
l_int|0
)braket
dot
id|sxfrctl1
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SIMODE0
comma
id|ahc-&gt;suspend_state.channel
(braket
l_int|0
)braket
dot
id|simode0
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SIMODE1
comma
id|ahc-&gt;suspend_state.channel
(braket
l_int|0
)braket
dot
id|simode1
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SELTIMER
comma
id|ahc-&gt;suspend_state.channel
(braket
l_int|0
)braket
dot
id|seltimer
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SEQCTL
comma
id|ahc-&gt;suspend_state.channel
(braket
l_int|0
)braket
dot
id|seqctl
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_ne
l_int|0
)paren
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSIID_ULTRA2
comma
id|ahc-&gt;our_id
)paren
suffix:semicolon
r_else
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSIID
comma
id|ahc-&gt;our_id
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;chip
op_amp
id|AHC_PCI
)paren
op_ne
l_int|0
)paren
(brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|DSCOMMAND0
comma
id|ahc-&gt;suspend_state.dscommand0
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|DSPCISTATUS
comma
id|ahc-&gt;suspend_state.dspcistatus
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_DT
)paren
op_ne
l_int|0
)paren
(brace
id|u_int
id|sfunct
suffix:semicolon
id|sfunct
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SFUNCT
)paren
op_amp
op_complement
id|ALT_MODE
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SFUNCT
comma
id|sfunct
op_or
id|ALT_MODE
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|OPTIONMODE
comma
id|ahc-&gt;suspend_state.optionmode
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SFUNCT
comma
id|sfunct
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|CRCCONTROL1
comma
id|ahc-&gt;suspend_state.crccontrol1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_MULTI_FUNC
)paren
op_ne
l_int|0
)paren
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBBADDR
comma
id|ahc-&gt;suspend_state.scbbaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_ne
l_int|0
)paren
id|ahc_outb
c_func
(paren
id|ahc
comma
id|DFF_THRSH
comma
id|ahc-&gt;suspend_state.dff_thrsh
)paren
suffix:semicolon
id|ptr
op_assign
id|ahc-&gt;suspend_state.scratch_ram
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|64
suffix:semicolon
id|i
op_increment
)paren
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SRAM_BASE
op_plus
id|i
comma
op_star
id|ptr
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_MORE_SRAM
)paren
op_ne
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
id|ahc_outb
c_func
(paren
id|ahc
comma
id|TARG_OFFSET
op_plus
id|i
comma
op_star
id|ptr
op_increment
)paren
suffix:semicolon
)brace
id|ptr
op_assign
id|ahc-&gt;suspend_state.btt
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;flags
op_amp
id|AHC_SCB_BTT
)paren
op_ne
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AHC_NUM_TARGETS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|AHC_NUM_LUNS
suffix:semicolon
id|j
op_increment
)paren
(brace
id|u_int
id|tcl
suffix:semicolon
id|tcl
op_assign
id|BUILD_TCL
c_func
(paren
id|i
op_lshift
l_int|4
comma
id|j
)paren
suffix:semicolon
id|ahc_busy_tcl
c_func
(paren
id|ahc
comma
id|tcl
comma
op_star
id|ptr
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/************************** Busy Target Table *********************************/
multiline_comment|/*&n; * Return the untagged transaction id for a given target/channel lun.&n; * Optionally, clear the entry.&n; */
id|u_int
DECL|function|ahc_index_busy_tcl
id|ahc_index_busy_tcl
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|u_int
id|tcl
)paren
(brace
id|u_int
id|scbid
suffix:semicolon
id|u_int
id|target_offset
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;flags
op_amp
id|AHC_SCB_BTT
)paren
op_ne
l_int|0
)paren
(brace
id|u_int
id|saved_scbptr
suffix:semicolon
id|saved_scbptr
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCBPTR
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBPTR
comma
id|TCL_LUN
c_func
(paren
id|tcl
)paren
)paren
suffix:semicolon
id|scbid
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_64_BTT
op_plus
id|TCL_TARGET_OFFSET
c_func
(paren
id|tcl
)paren
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBPTR
comma
id|saved_scbptr
)paren
suffix:semicolon
)brace
r_else
(brace
id|target_offset
op_assign
id|TCL_TARGET_OFFSET
c_func
(paren
id|tcl
)paren
suffix:semicolon
id|scbid
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|BUSY_TARGETS
op_plus
id|target_offset
)paren
suffix:semicolon
)brace
r_return
(paren
id|scbid
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahc_unbusy_tcl
id|ahc_unbusy_tcl
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|u_int
id|tcl
)paren
(brace
id|u_int
id|target_offset
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;flags
op_amp
id|AHC_SCB_BTT
)paren
op_ne
l_int|0
)paren
(brace
id|u_int
id|saved_scbptr
suffix:semicolon
id|saved_scbptr
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCBPTR
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBPTR
comma
id|TCL_LUN
c_func
(paren
id|tcl
)paren
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCB_64_BTT
op_plus
id|TCL_TARGET_OFFSET
c_func
(paren
id|tcl
)paren
comma
id|SCB_LIST_NULL
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBPTR
comma
id|saved_scbptr
)paren
suffix:semicolon
)brace
r_else
(brace
id|target_offset
op_assign
id|TCL_TARGET_OFFSET
c_func
(paren
id|tcl
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|BUSY_TARGETS
op_plus
id|target_offset
comma
id|SCB_LIST_NULL
)paren
suffix:semicolon
)brace
)brace
r_void
DECL|function|ahc_busy_tcl
id|ahc_busy_tcl
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|u_int
id|tcl
comma
id|u_int
id|scbid
)paren
(brace
id|u_int
id|target_offset
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;flags
op_amp
id|AHC_SCB_BTT
)paren
op_ne
l_int|0
)paren
(brace
id|u_int
id|saved_scbptr
suffix:semicolon
id|saved_scbptr
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCBPTR
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBPTR
comma
id|TCL_LUN
c_func
(paren
id|tcl
)paren
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCB_64_BTT
op_plus
id|TCL_TARGET_OFFSET
c_func
(paren
id|tcl
)paren
comma
id|scbid
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBPTR
comma
id|saved_scbptr
)paren
suffix:semicolon
)brace
r_else
(brace
id|target_offset
op_assign
id|TCL_TARGET_OFFSET
c_func
(paren
id|tcl
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|BUSY_TARGETS
op_plus
id|target_offset
comma
id|scbid
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/************************** SCB and SCB queue management **********************/
r_int
DECL|function|ahc_match_scb
id|ahc_match_scb
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|scb
op_star
id|scb
comma
r_int
id|target
comma
r_char
id|channel
comma
r_int
id|lun
comma
id|u_int
id|tag
comma
id|role_t
id|role
)paren
(brace
r_int
id|targ
op_assign
id|SCB_GET_TARGET
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
r_char
id|chan
op_assign
id|SCB_GET_CHANNEL
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
r_int
id|slun
op_assign
id|SCB_GET_LUN
c_func
(paren
id|scb
)paren
suffix:semicolon
r_int
id|match
suffix:semicolon
id|match
op_assign
(paren
(paren
id|chan
op_eq
id|channel
)paren
op_logical_or
(paren
id|channel
op_eq
id|ALL_CHANNELS
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|match
op_ne
l_int|0
)paren
id|match
op_assign
(paren
(paren
id|targ
op_eq
id|target
)paren
op_logical_or
(paren
id|target
op_eq
id|CAM_TARGET_WILDCARD
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|match
op_ne
l_int|0
)paren
id|match
op_assign
(paren
(paren
id|lun
op_eq
id|slun
)paren
op_logical_or
(paren
id|lun
op_eq
id|CAM_LUN_WILDCARD
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|match
op_ne
l_int|0
)paren
(brace
macro_line|#if AHC_TARGET_MODE
r_int
id|group
suffix:semicolon
id|group
op_assign
id|XPT_FC_GROUP
c_func
(paren
id|scb-&gt;io_ctx-&gt;ccb_h.func_code
)paren
suffix:semicolon
r_if
c_cond
(paren
id|role
op_eq
id|ROLE_INITIATOR
)paren
(brace
id|match
op_assign
(paren
id|group
op_ne
id|XPT_FC_GROUP_TMODE
)paren
op_logical_and
(paren
(paren
id|tag
op_eq
id|scb-&gt;hscb-&gt;tag
)paren
op_logical_or
(paren
id|tag
op_eq
id|SCB_LIST_NULL
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|role
op_eq
id|ROLE_TARGET
)paren
(brace
id|match
op_assign
(paren
id|group
op_eq
id|XPT_FC_GROUP_TMODE
)paren
op_logical_and
(paren
(paren
id|tag
op_eq
id|scb-&gt;io_ctx-&gt;csio.tag_id
)paren
op_logical_or
(paren
id|tag
op_eq
id|SCB_LIST_NULL
)paren
)paren
suffix:semicolon
)brace
macro_line|#else /* !AHC_TARGET_MODE */
id|match
op_assign
(paren
(paren
id|tag
op_eq
id|scb-&gt;hscb-&gt;tag
)paren
op_logical_or
(paren
id|tag
op_eq
id|SCB_LIST_NULL
)paren
)paren
suffix:semicolon
macro_line|#endif /* AHC_TARGET_MODE */
)brace
r_return
id|match
suffix:semicolon
)brace
r_void
DECL|function|ahc_freeze_devq
id|ahc_freeze_devq
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|scb
op_star
id|scb
)paren
(brace
r_int
id|target
suffix:semicolon
r_char
id|channel
suffix:semicolon
r_int
id|lun
suffix:semicolon
id|target
op_assign
id|SCB_GET_TARGET
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|lun
op_assign
id|SCB_GET_LUN
c_func
(paren
id|scb
)paren
suffix:semicolon
id|channel
op_assign
id|SCB_GET_CHANNEL
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|ahc_search_qinfifo
c_func
(paren
id|ahc
comma
id|target
comma
id|channel
comma
id|lun
comma
multiline_comment|/*tag*/
id|SCB_LIST_NULL
comma
id|ROLE_UNKNOWN
comma
id|CAM_REQUEUE_REQ
comma
id|SEARCH_COMPLETE
)paren
suffix:semicolon
id|ahc_platform_freeze_devq
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahc_qinfifo_requeue_tail
id|ahc_qinfifo_requeue_tail
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|scb
op_star
id|scb
)paren
(brace
r_struct
id|scb
op_star
id|prev_scb
suffix:semicolon
id|prev_scb
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|ahc_qinfifo_count
c_func
(paren
id|ahc
)paren
op_ne
l_int|0
)paren
(brace
id|u_int
id|prev_tag
suffix:semicolon
r_uint8
id|prev_pos
suffix:semicolon
id|prev_pos
op_assign
id|ahc-&gt;qinfifonext
op_minus
l_int|1
suffix:semicolon
id|prev_tag
op_assign
id|ahc-&gt;qinfifo
(braket
id|prev_pos
)braket
suffix:semicolon
id|prev_scb
op_assign
id|ahc_lookup_scb
c_func
(paren
id|ahc
comma
id|prev_tag
)paren
suffix:semicolon
)brace
id|ahc_qinfifo_requeue
c_func
(paren
id|ahc
comma
id|prev_scb
comma
id|scb
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_QUEUE_REGS
)paren
op_ne
l_int|0
)paren
(brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|HNSCB_QOFF
comma
id|ahc-&gt;qinfifonext
)paren
suffix:semicolon
)brace
r_else
(brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|KERNEL_QINPOS
comma
id|ahc-&gt;qinfifonext
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|ahc_qinfifo_requeue
id|ahc_qinfifo_requeue
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|scb
op_star
id|prev_scb
comma
r_struct
id|scb
op_star
id|scb
)paren
(brace
r_if
c_cond
(paren
id|prev_scb
op_eq
l_int|NULL
)paren
(brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|NEXT_QUEUED_SCB
comma
id|scb-&gt;hscb-&gt;tag
)paren
suffix:semicolon
)brace
r_else
(brace
id|prev_scb-&gt;hscb-&gt;next
op_assign
id|scb-&gt;hscb-&gt;tag
suffix:semicolon
id|ahc_sync_scb
c_func
(paren
id|ahc
comma
id|prev_scb
comma
id|BUS_DMASYNC_PREREAD
op_or
id|BUS_DMASYNC_PREWRITE
)paren
suffix:semicolon
)brace
id|ahc-&gt;qinfifo
(braket
id|ahc-&gt;qinfifonext
op_increment
)braket
op_assign
id|scb-&gt;hscb-&gt;tag
suffix:semicolon
id|scb-&gt;hscb-&gt;next
op_assign
id|ahc-&gt;next_queued_scb-&gt;hscb-&gt;tag
suffix:semicolon
id|ahc_sync_scb
c_func
(paren
id|ahc
comma
id|scb
comma
id|BUS_DMASYNC_PREREAD
op_or
id|BUS_DMASYNC_PREWRITE
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|ahc_qinfifo_count
id|ahc_qinfifo_count
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_uint8
id|qinpos
suffix:semicolon
r_uint8
id|diff
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_QUEUE_REGS
)paren
op_ne
l_int|0
)paren
(brace
id|qinpos
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SNSCB_QOFF
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SNSCB_QOFF
comma
id|qinpos
)paren
suffix:semicolon
)brace
r_else
id|qinpos
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|QINPOS
)paren
suffix:semicolon
id|diff
op_assign
id|ahc-&gt;qinfifonext
op_minus
id|qinpos
suffix:semicolon
r_return
(paren
id|diff
)paren
suffix:semicolon
)brace
r_int
DECL|function|ahc_search_qinfifo
id|ahc_search_qinfifo
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_int
id|target
comma
r_char
id|channel
comma
r_int
id|lun
comma
id|u_int
id|tag
comma
id|role_t
id|role
comma
r_uint32
id|status
comma
id|ahc_search_action
id|action
)paren
(brace
r_struct
id|scb
op_star
id|scb
suffix:semicolon
r_struct
id|scb
op_star
id|prev_scb
suffix:semicolon
r_uint8
id|qinstart
suffix:semicolon
r_uint8
id|qinpos
suffix:semicolon
r_uint8
id|qintail
suffix:semicolon
r_uint8
id|next
suffix:semicolon
r_uint8
id|prev
suffix:semicolon
r_uint8
id|curscbptr
suffix:semicolon
r_int
id|found
suffix:semicolon
r_int
id|have_qregs
suffix:semicolon
id|qintail
op_assign
id|ahc-&gt;qinfifonext
suffix:semicolon
id|have_qregs
op_assign
(paren
id|ahc-&gt;features
op_amp
id|AHC_QUEUE_REGS
)paren
op_ne
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|have_qregs
)paren
(brace
id|qinstart
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SNSCB_QOFF
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SNSCB_QOFF
comma
id|qinstart
)paren
suffix:semicolon
)brace
r_else
id|qinstart
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|QINPOS
)paren
suffix:semicolon
id|qinpos
op_assign
id|qinstart
suffix:semicolon
id|found
op_assign
l_int|0
suffix:semicolon
id|prev_scb
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|action
op_eq
id|SEARCH_COMPLETE
)paren
(brace
multiline_comment|/*&n;&t;&t; * Don&squot;t attempt to run any queued untagged transactions&n;&t;&t; * until we are done with the abort process.&n;&t;&t; */
id|ahc_freeze_untagged_queues
c_func
(paren
id|ahc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Start with an empty queue.  Entries that are not chosen&n;&t; * for removal will be re-added to the queue as we go.&n;&t; */
id|ahc-&gt;qinfifonext
op_assign
id|qinpos
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|NEXT_QUEUED_SCB
comma
id|ahc-&gt;next_queued_scb-&gt;hscb-&gt;tag
)paren
suffix:semicolon
r_while
c_loop
(paren
id|qinpos
op_ne
id|qintail
)paren
(brace
id|scb
op_assign
id|ahc_lookup_scb
c_func
(paren
id|ahc
comma
id|ahc-&gt;qinfifo
(braket
id|qinpos
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;qinpos = %d, SCB index = %d&bslash;n&quot;
comma
id|qinpos
comma
id|ahc-&gt;qinfifo
(braket
id|qinpos
)braket
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;Loop 1&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ahc_match_scb
c_func
(paren
id|ahc
comma
id|scb
comma
id|target
comma
id|channel
comma
id|lun
comma
id|tag
comma
id|role
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We found an scb that needs to be acted on.&n;&t;&t;&t; */
id|found
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|action
)paren
(brace
r_case
id|SEARCH_COMPLETE
suffix:colon
(brace
id|cam_status
id|ostat
suffix:semicolon
id|cam_status
id|cstat
suffix:semicolon
id|ostat
op_assign
id|ahc_get_transaction_status
c_func
(paren
id|scb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ostat
op_eq
id|CAM_REQ_INPROG
)paren
id|ahc_set_transaction_status
c_func
(paren
id|scb
comma
id|status
)paren
suffix:semicolon
id|cstat
op_assign
id|ahc_get_transaction_status
c_func
(paren
id|scb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cstat
op_ne
id|CAM_REQ_CMP
)paren
id|ahc_freeze_scb
c_func
(paren
id|scb
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_ACTIVE
)paren
op_eq
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;Inactive SCB in qinfifo&bslash;n&quot;
)paren
suffix:semicolon
id|ahc_done
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
)brace
r_case
id|SEARCH_REMOVE
suffix:colon
r_break
suffix:semicolon
r_case
id|SEARCH_COUNT
suffix:colon
id|ahc_qinfifo_requeue
c_func
(paren
id|ahc
comma
id|prev_scb
comma
id|scb
)paren
suffix:semicolon
id|prev_scb
op_assign
id|scb
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|ahc_qinfifo_requeue
c_func
(paren
id|ahc
comma
id|prev_scb
comma
id|scb
)paren
suffix:semicolon
id|prev_scb
op_assign
id|scb
suffix:semicolon
)brace
id|qinpos
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_QUEUE_REGS
)paren
op_ne
l_int|0
)paren
(brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|HNSCB_QOFF
comma
id|ahc-&gt;qinfifonext
)paren
suffix:semicolon
)brace
r_else
(brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|KERNEL_QINPOS
comma
id|ahc-&gt;qinfifonext
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|action
op_ne
id|SEARCH_COUNT
op_logical_and
(paren
id|found
op_ne
l_int|0
)paren
op_logical_and
(paren
id|qinstart
op_ne
id|ahc-&gt;qinfifonext
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * The sequencer may be in the process of dmaing&n;&t;&t; * down the SCB at the beginning of the queue.&n;&t;&t; * This could be problematic if either the first,&n;&t;&t; * or the second SCB is removed from the queue&n;&t;&t; * (the first SCB includes a pointer to the &quot;next&quot;&n;&t;&t; * SCB to dma). If we have removed any entries, swap&n;&t;&t; * the first element in the queue with the next HSCB&n;&t;&t; * so the sequencer will notice that NEXT_QUEUED_SCB&n;&t;&t; * has changed during its dma attempt and will retry&n;&t;&t; * the DMA.&n;&t;&t; */
id|scb
op_assign
id|ahc_lookup_scb
c_func
(paren
id|ahc
comma
id|ahc-&gt;qinfifo
(braket
id|qinstart
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;found = %d, qinstart = %d, qinfifionext = %d&bslash;n&quot;
comma
id|found
comma
id|qinstart
comma
id|ahc-&gt;qinfifonext
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;First/Second Qinfifo fixup&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * ahc_swap_with_next_hscb forces our next pointer to&n;&t;&t; * point to the reserved SCB for future commands.  Save&n;&t;&t; * and restore our original next pointer to maintain&n;&t;&t; * queue integrity.&n;&t;&t; */
id|next
op_assign
id|scb-&gt;hscb-&gt;next
suffix:semicolon
id|ahc-&gt;scb_data-&gt;scbindex
(braket
id|scb-&gt;hscb-&gt;tag
)braket
op_assign
l_int|NULL
suffix:semicolon
id|ahc_swap_with_next_hscb
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|scb-&gt;hscb-&gt;next
op_assign
id|next
suffix:semicolon
id|ahc-&gt;qinfifo
(braket
id|qinstart
)braket
op_assign
id|scb-&gt;hscb-&gt;tag
suffix:semicolon
multiline_comment|/* Tell the card about the new head of the qinfifo. */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|NEXT_QUEUED_SCB
comma
id|scb-&gt;hscb-&gt;tag
)paren
suffix:semicolon
multiline_comment|/* Fixup the tail &quot;next&quot; pointer. */
id|qintail
op_assign
id|ahc-&gt;qinfifonext
op_minus
l_int|1
suffix:semicolon
id|scb
op_assign
id|ahc_lookup_scb
c_func
(paren
id|ahc
comma
id|ahc-&gt;qinfifo
(braket
id|qintail
)braket
)paren
suffix:semicolon
id|scb-&gt;hscb-&gt;next
op_assign
id|ahc-&gt;next_queued_scb-&gt;hscb-&gt;tag
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Search waiting for selection list.&n;&t; */
id|curscbptr
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCBPTR
)paren
suffix:semicolon
id|next
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|WAITING_SCBH
)paren
suffix:semicolon
multiline_comment|/* Start at head of list. */
id|prev
op_assign
id|SCB_LIST_NULL
suffix:semicolon
r_while
c_loop
(paren
id|next
op_ne
id|SCB_LIST_NULL
)paren
(brace
r_uint8
id|scb_index
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBPTR
comma
id|next
)paren
suffix:semicolon
id|scb_index
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_TAG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb_index
op_ge
id|ahc-&gt;scb_data-&gt;numscbs
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Waiting List inconsistency. &quot;
l_string|&quot;SCB index == %d, yet numscbs == %d.&quot;
comma
id|scb_index
comma
id|ahc-&gt;scb_data-&gt;numscbs
)paren
suffix:semicolon
id|ahc_dump_card_state
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;for safety&quot;
)paren
suffix:semicolon
)brace
id|scb
op_assign
id|ahc_lookup_scb
c_func
(paren
id|ahc
comma
id|scb_index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;scb_index = %d, next = %d&bslash;n&quot;
comma
id|scb_index
comma
id|next
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;Waiting List traversal&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ahc_match_scb
c_func
(paren
id|ahc
comma
id|scb
comma
id|target
comma
id|channel
comma
id|lun
comma
id|SCB_LIST_NULL
comma
id|role
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We found an scb that needs to be acted on.&n;&t;&t;&t; */
id|found
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|action
)paren
(brace
r_case
id|SEARCH_COMPLETE
suffix:colon
(brace
id|cam_status
id|ostat
suffix:semicolon
id|cam_status
id|cstat
suffix:semicolon
id|ostat
op_assign
id|ahc_get_transaction_status
c_func
(paren
id|scb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ostat
op_eq
id|CAM_REQ_INPROG
)paren
id|ahc_set_transaction_status
c_func
(paren
id|scb
comma
id|status
)paren
suffix:semicolon
id|cstat
op_assign
id|ahc_get_transaction_status
c_func
(paren
id|scb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cstat
op_ne
id|CAM_REQ_CMP
)paren
id|ahc_freeze_scb
c_func
(paren
id|scb
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_ACTIVE
)paren
op_eq
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;Inactive SCB in Waiting List&bslash;n&quot;
)paren
suffix:semicolon
id|ahc_done
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
)brace
r_case
id|SEARCH_REMOVE
suffix:colon
id|next
op_assign
id|ahc_rem_wscb
c_func
(paren
id|ahc
comma
id|next
comma
id|prev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SEARCH_COUNT
suffix:colon
id|prev
op_assign
id|next
suffix:semicolon
id|next
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_NEXT
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|prev
op_assign
id|next
suffix:semicolon
id|next
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_NEXT
)paren
suffix:semicolon
)brace
)brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBPTR
comma
id|curscbptr
)paren
suffix:semicolon
id|found
op_add_assign
id|ahc_search_untagged_queues
c_func
(paren
id|ahc
comma
multiline_comment|/*ahc_io_ctx_t*/
l_int|NULL
comma
id|target
comma
id|channel
comma
id|lun
comma
id|status
comma
id|action
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action
op_eq
id|SEARCH_COMPLETE
)paren
id|ahc_release_untagged_queues
c_func
(paren
id|ahc
)paren
suffix:semicolon
r_return
(paren
id|found
)paren
suffix:semicolon
)brace
r_int
DECL|function|ahc_search_untagged_queues
id|ahc_search_untagged_queues
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|ahc_io_ctx_t
id|ctx
comma
r_int
id|target
comma
r_char
id|channel
comma
r_int
id|lun
comma
r_uint32
id|status
comma
id|ahc_search_action
id|action
)paren
(brace
r_struct
id|scb
op_star
id|scb
suffix:semicolon
r_int
id|maxtarget
suffix:semicolon
r_int
id|found
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|action
op_eq
id|SEARCH_COMPLETE
)paren
(brace
multiline_comment|/*&n;&t;&t; * Don&squot;t attempt to run any queued untagged transactions&n;&t;&t; * until we are done with the abort process.&n;&t;&t; */
id|ahc_freeze_untagged_queues
c_func
(paren
id|ahc
)paren
suffix:semicolon
)brace
id|found
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;flags
op_amp
id|AHC_SCB_BTT
)paren
op_eq
l_int|0
)paren
(brace
id|maxtarget
op_assign
l_int|16
suffix:semicolon
r_if
c_cond
(paren
id|target
op_ne
id|CAM_TARGET_WILDCARD
)paren
(brace
id|i
op_assign
id|target
suffix:semicolon
r_if
c_cond
(paren
id|channel
op_eq
l_char|&squot;B&squot;
)paren
id|i
op_add_assign
l_int|8
suffix:semicolon
id|maxtarget
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|maxtarget
op_assign
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|maxtarget
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|scb_tailq
op_star
id|untagged_q
suffix:semicolon
r_struct
id|scb
op_star
id|next_scb
suffix:semicolon
id|untagged_q
op_assign
op_amp
(paren
id|ahc-&gt;untagged_queues
(braket
id|i
)braket
)paren
suffix:semicolon
id|next_scb
op_assign
id|TAILQ_FIRST
c_func
(paren
id|untagged_q
)paren
suffix:semicolon
r_while
c_loop
(paren
id|next_scb
op_ne
l_int|NULL
)paren
(brace
id|scb
op_assign
id|next_scb
suffix:semicolon
id|next_scb
op_assign
id|TAILQ_NEXT
c_func
(paren
id|scb
comma
id|links.tqe
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * The head of the list may be the currently&n;&t;&t;&t; * active untagged command for a device.&n;&t;&t;&t; * We&squot;re only searching for commands that&n;&t;&t;&t; * have not been started.  A transaction&n;&t;&t;&t; * marked active but still in the qinfifo&n;&t;&t;&t; * is removed by the qinfifo scanning code&n;&t;&t;&t; * above.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_ACTIVE
)paren
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|ahc_match_scb
c_func
(paren
id|ahc
comma
id|scb
comma
id|target
comma
id|channel
comma
id|lun
comma
id|SCB_LIST_NULL
comma
id|ROLE_INITIATOR
)paren
op_eq
l_int|0
op_logical_or
(paren
id|ctx
op_ne
l_int|NULL
op_logical_and
id|ctx
op_ne
id|scb-&gt;io_ctx
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We found an scb that needs to be acted on.&n;&t;&t;&t; */
id|found
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|action
)paren
(brace
r_case
id|SEARCH_COMPLETE
suffix:colon
(brace
id|cam_status
id|ostat
suffix:semicolon
id|cam_status
id|cstat
suffix:semicolon
id|ostat
op_assign
id|ahc_get_transaction_status
c_func
(paren
id|scb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ostat
op_eq
id|CAM_REQ_INPROG
)paren
id|ahc_set_transaction_status
c_func
(paren
id|scb
comma
id|status
)paren
suffix:semicolon
id|cstat
op_assign
id|ahc_get_transaction_status
c_func
(paren
id|scb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cstat
op_ne
id|CAM_REQ_CMP
)paren
id|ahc_freeze_scb
c_func
(paren
id|scb
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_ACTIVE
)paren
op_eq
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;Inactive SCB in untaggedQ&bslash;n&quot;
)paren
suffix:semicolon
id|ahc_done
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|SEARCH_REMOVE
suffix:colon
id|scb-&gt;flags
op_and_assign
op_complement
id|SCB_UNTAGGEDQ
suffix:semicolon
id|TAILQ_REMOVE
c_func
(paren
id|untagged_q
comma
id|scb
comma
id|links.tqe
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SEARCH_COUNT
suffix:colon
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|action
op_eq
id|SEARCH_COMPLETE
)paren
id|ahc_release_untagged_queues
c_func
(paren
id|ahc
)paren
suffix:semicolon
r_return
(paren
id|found
)paren
suffix:semicolon
)brace
r_int
DECL|function|ahc_search_disc_list
id|ahc_search_disc_list
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_int
id|target
comma
r_char
id|channel
comma
r_int
id|lun
comma
id|u_int
id|tag
comma
r_int
id|stop_on_first
comma
r_int
id|remove
comma
r_int
id|save_state
)paren
(brace
r_struct
id|scb
op_star
id|scbp
suffix:semicolon
id|u_int
id|next
suffix:semicolon
id|u_int
id|prev
suffix:semicolon
id|u_int
id|count
suffix:semicolon
id|u_int
id|active_scb
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
id|next
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|DISCONNECTED_SCBH
)paren
suffix:semicolon
id|prev
op_assign
id|SCB_LIST_NULL
suffix:semicolon
r_if
c_cond
(paren
id|save_state
)paren
(brace
multiline_comment|/* restore this when we&squot;re done */
id|active_scb
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCBPTR
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* Silence compiler */
id|active_scb
op_assign
id|SCB_LIST_NULL
suffix:semicolon
r_while
c_loop
(paren
id|next
op_ne
id|SCB_LIST_NULL
)paren
(brace
id|u_int
id|scb_index
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBPTR
comma
id|next
)paren
suffix:semicolon
id|scb_index
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_TAG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb_index
op_ge
id|ahc-&gt;scb_data-&gt;numscbs
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Disconnected List inconsistency. &quot;
l_string|&quot;SCB index == %d, yet numscbs == %d.&quot;
comma
id|scb_index
comma
id|ahc-&gt;scb_data-&gt;numscbs
)paren
suffix:semicolon
id|ahc_dump_card_state
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;for safety&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|next
op_eq
id|prev
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Disconnected List Loop. &quot;
l_string|&quot;cur SCBPTR == %x, prev SCBPTR == %x.&quot;
comma
id|next
comma
id|prev
)paren
suffix:semicolon
)brace
id|scbp
op_assign
id|ahc_lookup_scb
c_func
(paren
id|ahc
comma
id|scb_index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc_match_scb
c_func
(paren
id|ahc
comma
id|scbp
comma
id|target
comma
id|channel
comma
id|lun
comma
id|tag
comma
id|ROLE_INITIATOR
)paren
)paren
(brace
id|count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|remove
)paren
(brace
id|next
op_assign
id|ahc_rem_scb_from_disc_list
c_func
(paren
id|ahc
comma
id|prev
comma
id|next
)paren
suffix:semicolon
)brace
r_else
(brace
id|prev
op_assign
id|next
suffix:semicolon
id|next
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_NEXT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stop_on_first
)paren
r_break
suffix:semicolon
)brace
r_else
(brace
id|prev
op_assign
id|next
suffix:semicolon
id|next
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_NEXT
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|save_state
)paren
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBPTR
comma
id|active_scb
)paren
suffix:semicolon
r_return
(paren
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove an SCB from the on chip list of disconnected transactions.&n; * This is empty/unused if we are not performing SCB paging.&n; */
r_static
id|u_int
DECL|function|ahc_rem_scb_from_disc_list
id|ahc_rem_scb_from_disc_list
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|u_int
id|prev
comma
id|u_int
id|scbptr
)paren
(brace
id|u_int
id|next
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBPTR
comma
id|scbptr
)paren
suffix:semicolon
id|next
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_NEXT
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCB_CONTROL
comma
l_int|0
)paren
suffix:semicolon
id|ahc_add_curscb_to_free_list
c_func
(paren
id|ahc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prev
op_ne
id|SCB_LIST_NULL
)paren
(brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBPTR
comma
id|prev
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCB_NEXT
comma
id|next
)paren
suffix:semicolon
)brace
r_else
id|ahc_outb
c_func
(paren
id|ahc
comma
id|DISCONNECTED_SCBH
comma
id|next
)paren
suffix:semicolon
r_return
(paren
id|next
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Add the SCB as selected by SCBPTR onto the on chip list of&n; * free hardware SCBs.  This list is empty/unused if we are not&n; * performing SCB paging.&n; */
r_static
r_void
DECL|function|ahc_add_curscb_to_free_list
id|ahc_add_curscb_to_free_list
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
multiline_comment|/*&n;&t; * Invalidate the tag so that our abort&n;&t; * routines don&squot;t think it&squot;s active.&n;&t; */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCB_TAG
comma
id|SCB_LIST_NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;flags
op_amp
id|AHC_PAGESCBS
)paren
op_ne
l_int|0
)paren
(brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCB_NEXT
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|FREE_SCBH
)paren
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|FREE_SCBH
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCBPTR
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Manipulate the waiting for selection list and return the&n; * scb that follows the one that we remove.&n; */
r_static
id|u_int
DECL|function|ahc_rem_wscb
id|ahc_rem_wscb
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|u_int
id|scbpos
comma
id|u_int
id|prev
)paren
(brace
id|u_int
id|curscb
comma
id|next
suffix:semicolon
multiline_comment|/*&n;&t; * Select the SCB we want to abort and&n;&t; * pull the next pointer out of it.&n;&t; */
id|curscb
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCBPTR
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBPTR
comma
id|scbpos
)paren
suffix:semicolon
id|next
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_NEXT
)paren
suffix:semicolon
multiline_comment|/* Clear the necessary fields */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCB_CONTROL
comma
l_int|0
)paren
suffix:semicolon
id|ahc_add_curscb_to_free_list
c_func
(paren
id|ahc
)paren
suffix:semicolon
multiline_comment|/* update the waiting list */
r_if
c_cond
(paren
id|prev
op_eq
id|SCB_LIST_NULL
)paren
(brace
multiline_comment|/* First in the list */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|WAITING_SCBH
comma
id|next
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Ensure we aren&squot;t attempting to perform&n;&t;&t; * selection for this entry.&n;&t;&t; */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSISEQ
comma
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSISEQ
)paren
op_amp
op_complement
id|ENSELO
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Select the scb that pointed to us &n;&t;&t; * and update its next pointer.&n;&t;&t; */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBPTR
comma
id|prev
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCB_NEXT
comma
id|next
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Point us back at the original scb position.&n;&t; */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBPTR
comma
id|curscb
)paren
suffix:semicolon
r_return
id|next
suffix:semicolon
)brace
multiline_comment|/******************************** Error Handling ******************************/
multiline_comment|/*&n; * Abort all SCBs that match the given description (target/channel/lun/tag),&n; * setting their status to the passed in status if the status has not already&n; * been modified from CAM_REQ_INPROG.  This routine assumes that the sequencer&n; * is paused before it is called.&n; */
r_int
DECL|function|ahc_abort_scbs
id|ahc_abort_scbs
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_int
id|target
comma
r_char
id|channel
comma
r_int
id|lun
comma
id|u_int
id|tag
comma
id|role_t
id|role
comma
r_uint32
id|status
)paren
(brace
r_struct
id|scb
op_star
id|scbp
suffix:semicolon
r_struct
id|scb
op_star
id|scbp_next
suffix:semicolon
id|u_int
id|active_scb
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_int
id|maxtarget
suffix:semicolon
r_int
id|minlun
suffix:semicolon
r_int
id|maxlun
suffix:semicolon
r_int
id|found
suffix:semicolon
multiline_comment|/*&n;&t; * Don&squot;t attempt to run any queued untagged transactions&n;&t; * until we are done with the abort process.&n;&t; */
id|ahc_freeze_untagged_queues
c_func
(paren
id|ahc
)paren
suffix:semicolon
multiline_comment|/* restore this when we&squot;re done */
id|active_scb
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCBPTR
)paren
suffix:semicolon
id|found
op_assign
id|ahc_search_qinfifo
c_func
(paren
id|ahc
comma
id|target
comma
id|channel
comma
id|lun
comma
id|SCB_LIST_NULL
comma
id|role
comma
id|CAM_REQUEUE_REQ
comma
id|SEARCH_COMPLETE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Clean out the busy target table for any untagged commands.&n;&t; */
id|i
op_assign
l_int|0
suffix:semicolon
id|maxtarget
op_assign
l_int|16
suffix:semicolon
r_if
c_cond
(paren
id|target
op_ne
id|CAM_TARGET_WILDCARD
)paren
(brace
id|i
op_assign
id|target
suffix:semicolon
r_if
c_cond
(paren
id|channel
op_eq
l_char|&squot;B&squot;
)paren
id|i
op_add_assign
l_int|8
suffix:semicolon
id|maxtarget
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lun
op_eq
id|CAM_LUN_WILDCARD
)paren
(brace
multiline_comment|/*&n;&t;&t; * Unless we are using an SCB based&n;&t;&t; * busy targets table, there is only&n;&t;&t; * one table entry for all luns of&n;&t;&t; * a target.&n;&t;&t; */
id|minlun
op_assign
l_int|0
suffix:semicolon
id|maxlun
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;flags
op_amp
id|AHC_SCB_BTT
)paren
op_ne
l_int|0
)paren
id|maxlun
op_assign
id|AHC_NUM_LUNS
suffix:semicolon
)brace
r_else
(brace
id|minlun
op_assign
id|lun
suffix:semicolon
id|maxlun
op_assign
id|lun
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|role
op_ne
id|ROLE_TARGET
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|maxtarget
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
id|minlun
suffix:semicolon
id|j
OL
id|maxlun
suffix:semicolon
id|j
op_increment
)paren
(brace
id|u_int
id|scbid
suffix:semicolon
id|u_int
id|tcl
suffix:semicolon
id|tcl
op_assign
id|BUILD_TCL
c_func
(paren
id|i
op_lshift
l_int|4
comma
id|j
)paren
suffix:semicolon
id|scbid
op_assign
id|ahc_index_busy_tcl
c_func
(paren
id|ahc
comma
id|tcl
)paren
suffix:semicolon
id|scbp
op_assign
id|ahc_lookup_scb
c_func
(paren
id|ahc
comma
id|scbid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scbp
op_eq
l_int|NULL
op_logical_or
id|ahc_match_scb
c_func
(paren
id|ahc
comma
id|scbp
comma
id|target
comma
id|channel
comma
id|lun
comma
id|tag
comma
id|role
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|ahc_unbusy_tcl
c_func
(paren
id|ahc
comma
id|BUILD_TCL
c_func
(paren
id|i
op_lshift
l_int|4
comma
id|j
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Go through the disconnected list and remove any entries we&n;&t;&t; * have queued for completion, 0&squot;ing their control byte too.&n;&t;&t; * We save the active SCB and restore it ourselves, so there&n;&t;&t; * is no reason for this search to restore it too.&n;&t;&t; */
id|ahc_search_disc_list
c_func
(paren
id|ahc
comma
id|target
comma
id|channel
comma
id|lun
comma
id|tag
comma
multiline_comment|/*stop_on_first*/
id|FALSE
comma
multiline_comment|/*remove*/
id|TRUE
comma
multiline_comment|/*save_state*/
id|FALSE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Go through the hardware SCB array looking for commands that&n;&t; * were active but not on any list.  In some cases, these remnants&n;&t; * might not still have mappings in the scbindex array (e.g. unexpected&n;&t; * bus free with the same scb queued for an abort).  Don&squot;t hold this&n;&t; * against them.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ahc-&gt;scb_data-&gt;maxhscbs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|u_int
id|scbid
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBPTR
comma
id|i
)paren
suffix:semicolon
id|scbid
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_TAG
)paren
suffix:semicolon
id|scbp
op_assign
id|ahc_lookup_scb
c_func
(paren
id|ahc
comma
id|scbid
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scbp
op_eq
l_int|NULL
op_logical_and
id|scbid
op_ne
id|SCB_LIST_NULL
)paren
op_logical_or
(paren
id|scbp
op_ne
l_int|NULL
op_logical_and
id|ahc_match_scb
c_func
(paren
id|ahc
comma
id|scbp
comma
id|target
comma
id|channel
comma
id|lun
comma
id|tag
comma
id|role
)paren
)paren
)paren
id|ahc_add_curscb_to_free_list
c_func
(paren
id|ahc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Go through the pending CCB list and look for&n;&t; * commands for this target that are still active.&n;&t; * These are other tagged commands that were&n;&t; * disconnected when the reset occurred.&n;&t; */
id|scbp_next
op_assign
id|LIST_FIRST
c_func
(paren
op_amp
id|ahc-&gt;pending_scbs
)paren
suffix:semicolon
r_while
c_loop
(paren
id|scbp_next
op_ne
l_int|NULL
)paren
(brace
id|scbp
op_assign
id|scbp_next
suffix:semicolon
id|scbp_next
op_assign
id|LIST_NEXT
c_func
(paren
id|scbp
comma
id|pending_links
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc_match_scb
c_func
(paren
id|ahc
comma
id|scbp
comma
id|target
comma
id|channel
comma
id|lun
comma
id|tag
comma
id|role
)paren
)paren
(brace
id|cam_status
id|ostat
suffix:semicolon
id|ostat
op_assign
id|ahc_get_transaction_status
c_func
(paren
id|scbp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ostat
op_eq
id|CAM_REQ_INPROG
)paren
id|ahc_set_transaction_status
c_func
(paren
id|scbp
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc_get_transaction_status
c_func
(paren
id|scbp
)paren
op_ne
id|CAM_REQ_CMP
)paren
id|ahc_freeze_scb
c_func
(paren
id|scbp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scbp-&gt;flags
op_amp
id|SCB_ACTIVE
)paren
op_eq
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;Inactive SCB on pending list&bslash;n&quot;
)paren
suffix:semicolon
id|ahc_done
c_func
(paren
id|ahc
comma
id|scbp
)paren
suffix:semicolon
id|found
op_increment
suffix:semicolon
)brace
)brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBPTR
comma
id|active_scb
)paren
suffix:semicolon
id|ahc_platform_abort_scbs
c_func
(paren
id|ahc
comma
id|target
comma
id|channel
comma
id|lun
comma
id|tag
comma
id|role
comma
id|status
)paren
suffix:semicolon
id|ahc_release_untagged_queues
c_func
(paren
id|ahc
)paren
suffix:semicolon
r_return
id|found
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahc_reset_current_bus
id|ahc_reset_current_bus
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_uint8
id|scsiseq
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SIMODE1
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SIMODE1
)paren
op_amp
op_complement
id|ENSCSIRST
)paren
suffix:semicolon
id|scsiseq
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSISEQ
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSISEQ
comma
id|scsiseq
op_or
id|SCSIRSTO
)paren
suffix:semicolon
id|ahc_flush_device_writes
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_delay
c_func
(paren
id|AHC_BUSRESET_DELAY
)paren
suffix:semicolon
multiline_comment|/* Turn off the bus reset */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSISEQ
comma
id|scsiseq
op_amp
op_complement
id|SCSIRSTO
)paren
suffix:semicolon
id|ahc_clear_intstat
c_func
(paren
id|ahc
)paren
suffix:semicolon
multiline_comment|/* Re-enable reset interrupts */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SIMODE1
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SIMODE1
)paren
op_or
id|ENSCSIRST
)paren
suffix:semicolon
)brace
r_int
DECL|function|ahc_reset_channel
id|ahc_reset_channel
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_char
id|channel
comma
r_int
id|initiate_reset
)paren
(brace
r_struct
id|ahc_devinfo
id|devinfo
suffix:semicolon
id|u_int
id|initiator
comma
id|target
comma
id|max_scsiid
suffix:semicolon
id|u_int
id|sblkctl
suffix:semicolon
id|u_int
id|scsiseq
suffix:semicolon
id|u_int
id|simode1
suffix:semicolon
r_int
id|found
suffix:semicolon
r_int
id|restart_needed
suffix:semicolon
r_char
id|cur_channel
suffix:semicolon
id|ahc-&gt;pending_device
op_assign
l_int|NULL
suffix:semicolon
id|ahc_compile_devinfo
c_func
(paren
op_amp
id|devinfo
comma
id|CAM_TARGET_WILDCARD
comma
id|CAM_TARGET_WILDCARD
comma
id|CAM_LUN_WILDCARD
comma
id|channel
comma
id|ROLE_UNKNOWN
)paren
suffix:semicolon
id|ahc_pause
c_func
(paren
id|ahc
)paren
suffix:semicolon
multiline_comment|/* Make sure the sequencer is in a safe location. */
id|ahc_clear_critical_section
c_func
(paren
id|ahc
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Run our command complete fifos to ensure that we perform&n;&t; * completion processing on any commands that &squot;completed&squot;&n;&t; * before the reset occurred.&n;&t; */
id|ahc_run_qoutfifo
c_func
(paren
id|ahc
)paren
suffix:semicolon
macro_line|#if AHC_TARGET_MODE
multiline_comment|/*&n;&t; * XXX - In Twin mode, the tqinfifo may have commands&n;&t; *&t; for an unaffected channel in it.  However, if&n;&t; *&t; we have run out of ATIO resources to drain that&n;&t; *&t; queue, we may not get them all out here.  Further,&n;&t; *&t; the blocked transactions for the reset channel&n;&t; *&t; should just be killed off, irrespecitve of whether&n;&t; *&t; we are blocked on ATIO resources.  Write a routine&n;&t; *&t; to compact the tqinfifo appropriately.&n;&t; */
r_if
c_cond
(paren
(paren
id|ahc-&gt;flags
op_amp
id|AHC_TARGETROLE
)paren
op_ne
l_int|0
)paren
(brace
id|ahc_run_tqinfifo
c_func
(paren
id|ahc
comma
multiline_comment|/*paused*/
id|TRUE
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Reset the bus if we are initiating this reset&n;&t; */
id|sblkctl
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SBLKCTL
)paren
suffix:semicolon
id|cur_channel
op_assign
l_char|&squot;A&squot;
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_TWIN
)paren
op_ne
l_int|0
op_logical_and
(paren
(paren
id|sblkctl
op_amp
id|SELBUSB
)paren
op_ne
l_int|0
)paren
)paren
id|cur_channel
op_assign
l_char|&squot;B&squot;
suffix:semicolon
id|scsiseq
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSISEQ_TEMPLATE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur_channel
op_ne
id|channel
)paren
(brace
multiline_comment|/* Case 1: Command for another bus is active&n;&t;&t; * Stealthily reset the other bus without&n;&t;&t; * upsetting the current bus.&n;&t;&t; */
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SBLKCTL
comma
id|sblkctl
op_xor
id|SELBUSB
)paren
suffix:semicolon
id|simode1
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SIMODE1
)paren
op_amp
op_complement
(paren
id|ENBUSFREE
op_or
id|ENSCSIRST
)paren
suffix:semicolon
macro_line|#if AHC_TARGET_MODE
multiline_comment|/*&n;&t;&t; * Bus resets clear ENSELI, so we cannot&n;&t;&t; * defer re-enabling bus reset interrupts&n;&t;&t; * if we are in target mode.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ahc-&gt;flags
op_amp
id|AHC_TARGETROLE
)paren
op_ne
l_int|0
)paren
id|simode1
op_or_assign
id|ENSCSIRST
suffix:semicolon
macro_line|#endif
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SIMODE1
comma
id|simode1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|initiate_reset
)paren
id|ahc_reset_current_bus
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_clear_intstat
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSISEQ
comma
id|scsiseq
op_amp
(paren
id|ENSELI
op_or
id|ENRSELI
op_or
id|ENAUTOATNP
)paren
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SBLKCTL
comma
id|sblkctl
)paren
suffix:semicolon
id|restart_needed
op_assign
id|FALSE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Case 2: A command from this bus is active or we&squot;re idle */
id|simode1
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SIMODE1
)paren
op_amp
op_complement
(paren
id|ENBUSFREE
op_or
id|ENSCSIRST
)paren
suffix:semicolon
macro_line|#if AHC_TARGET_MODE
multiline_comment|/*&n;&t;&t; * Bus resets clear ENSELI, so we cannot&n;&t;&t; * defer re-enabling bus reset interrupts&n;&t;&t; * if we are in target mode.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ahc-&gt;flags
op_amp
id|AHC_TARGETROLE
)paren
op_ne
l_int|0
)paren
id|simode1
op_or_assign
id|ENSCSIRST
suffix:semicolon
macro_line|#endif
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SIMODE1
comma
id|simode1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|initiate_reset
)paren
id|ahc_reset_current_bus
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_clear_intstat
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSISEQ
comma
id|scsiseq
op_amp
(paren
id|ENSELI
op_or
id|ENRSELI
op_or
id|ENAUTOATNP
)paren
)paren
suffix:semicolon
id|restart_needed
op_assign
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Clean up all the state information for the&n;&t; * pending transactions on this bus.&n;&t; */
id|found
op_assign
id|ahc_abort_scbs
c_func
(paren
id|ahc
comma
id|CAM_TARGET_WILDCARD
comma
id|channel
comma
id|CAM_LUN_WILDCARD
comma
id|SCB_LIST_NULL
comma
id|ROLE_UNKNOWN
comma
id|CAM_SCSI_BUS_RESET
)paren
suffix:semicolon
id|max_scsiid
op_assign
(paren
id|ahc-&gt;features
op_amp
id|AHC_WIDE
)paren
ques
c_cond
l_int|15
suffix:colon
l_int|7
suffix:semicolon
macro_line|#ifdef AHC_TARGET_MODE
multiline_comment|/*&n;&t; * Send an immediate notify ccb to all target more peripheral&n;&t; * drivers affected by this action.&n;&t; */
r_for
c_loop
(paren
id|target
op_assign
l_int|0
suffix:semicolon
id|target
op_le
id|max_scsiid
suffix:semicolon
id|target
op_increment
)paren
(brace
r_struct
id|ahc_tmode_tstate
op_star
id|tstate
suffix:semicolon
id|u_int
id|lun
suffix:semicolon
id|tstate
op_assign
id|ahc-&gt;enabled_targets
(braket
id|target
)braket
suffix:semicolon
r_if
c_cond
(paren
id|tstate
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|lun
op_assign
l_int|0
suffix:semicolon
id|lun
OL
id|AHC_NUM_LUNS
suffix:semicolon
id|lun
op_increment
)paren
(brace
r_struct
id|ahc_tmode_lstate
op_star
id|lstate
suffix:semicolon
id|lstate
op_assign
id|tstate-&gt;enabled_luns
(braket
id|lun
)braket
suffix:semicolon
r_if
c_cond
(paren
id|lstate
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|ahc_queue_lstate_event
c_func
(paren
id|ahc
comma
id|lstate
comma
id|CAM_TARGET_WILDCARD
comma
id|EVENT_TYPE_BUS_RESET
comma
multiline_comment|/*arg*/
l_int|0
)paren
suffix:semicolon
id|ahc_send_lstate_events
c_func
(paren
id|ahc
comma
id|lstate
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/* Notify the XPT that a bus reset occurred */
id|ahc_send_async
c_func
(paren
id|ahc
comma
id|devinfo.channel
comma
id|CAM_TARGET_WILDCARD
comma
id|CAM_LUN_WILDCARD
comma
id|AC_BUS_RESET
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Revert to async/narrow transfers until we renegotiate.&n;&t; */
r_for
c_loop
(paren
id|target
op_assign
l_int|0
suffix:semicolon
id|target
op_le
id|max_scsiid
suffix:semicolon
id|target
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ahc-&gt;enabled_targets
(braket
id|target
)braket
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|initiator
op_assign
l_int|0
suffix:semicolon
id|initiator
op_le
id|max_scsiid
suffix:semicolon
id|initiator
op_increment
)paren
(brace
r_struct
id|ahc_devinfo
id|devinfo
suffix:semicolon
id|ahc_compile_devinfo
c_func
(paren
op_amp
id|devinfo
comma
id|target
comma
id|initiator
comma
id|CAM_LUN_WILDCARD
comma
id|channel
comma
id|ROLE_UNKNOWN
)paren
suffix:semicolon
id|ahc_set_width
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
comma
id|MSG_EXT_WDTR_BUS_8_BIT
comma
id|AHC_TRANS_CUR
comma
multiline_comment|/*paused*/
id|TRUE
)paren
suffix:semicolon
id|ahc_set_syncrate
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
comma
multiline_comment|/*syncrate*/
l_int|NULL
comma
multiline_comment|/*period*/
l_int|0
comma
multiline_comment|/*offset*/
l_int|0
comma
multiline_comment|/*ppr_options*/
l_int|0
comma
id|AHC_TRANS_CUR
comma
multiline_comment|/*paused*/
id|TRUE
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|restart_needed
)paren
id|ahc_restart
c_func
(paren
id|ahc
)paren
suffix:semicolon
r_else
id|ahc_unpause
c_func
(paren
id|ahc
)paren
suffix:semicolon
r_return
id|found
suffix:semicolon
)brace
multiline_comment|/***************************** Residual Processing ****************************/
multiline_comment|/*&n; * Calculate the residual for a just completed SCB.&n; */
r_void
DECL|function|ahc_calc_residual
id|ahc_calc_residual
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|scb
op_star
id|scb
)paren
(brace
r_struct
id|hardware_scb
op_star
id|hscb
suffix:semicolon
r_struct
id|status_pkt
op_star
id|spkt
suffix:semicolon
r_uint32
id|sgptr
suffix:semicolon
r_uint32
id|resid_sgptr
suffix:semicolon
r_uint32
id|resid
suffix:semicolon
multiline_comment|/*&n;&t; * 5 cases.&n;&t; * 1) No residual.&n;&t; *    SG_RESID_VALID clear in sgptr.&n;&t; * 2) Transferless command&n;&t; * 3) Never performed any transfers.&n;&t; *    sgptr has SG_FULL_RESID set.&n;&t; * 4) No residual but target did not&n;&t; *    save data pointers after the&n;&t; *    last transfer, so sgptr was&n;&t; *    never updated.&n;&t; * 5) We have a partial residual.&n;&t; *    Use residual_sgptr to determine&n;&t; *    where we are.&n;&t; */
id|hscb
op_assign
id|scb-&gt;hscb
suffix:semicolon
id|sgptr
op_assign
id|ahc_le32toh
c_func
(paren
id|hscb-&gt;sgptr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sgptr
op_amp
id|SG_RESID_VALID
)paren
op_eq
l_int|0
)paren
multiline_comment|/* Case 1 */
r_return
suffix:semicolon
id|sgptr
op_and_assign
op_complement
id|SG_RESID_VALID
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sgptr
op_amp
id|SG_LIST_NULL
)paren
op_ne
l_int|0
)paren
multiline_comment|/* Case 2 */
r_return
suffix:semicolon
id|spkt
op_assign
op_amp
id|hscb-&gt;shared_data.status
suffix:semicolon
id|resid_sgptr
op_assign
id|ahc_le32toh
c_func
(paren
id|spkt-&gt;residual_sg_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sgptr
op_amp
id|SG_FULL_RESID
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Case 3 */
id|resid
op_assign
id|ahc_get_transfer_length
c_func
(paren
id|scb
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|resid_sgptr
op_amp
id|SG_LIST_NULL
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Case 4 */
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|resid_sgptr
op_amp
op_complement
id|SG_PTR_MASK
)paren
op_ne
l_int|0
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Bogus resid sgptr value 0x%x&bslash;n&quot;
comma
id|resid_sgptr
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|ahc_dma_seg
op_star
id|sg
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Remainder of the SG where the transfer&n;&t;&t; * stopped.  &n;&t;&t; */
id|resid
op_assign
id|ahc_le32toh
c_func
(paren
id|spkt-&gt;residual_datacnt
)paren
op_amp
id|AHC_SG_LEN_MASK
suffix:semicolon
id|sg
op_assign
id|ahc_sg_bus_to_virt
c_func
(paren
id|scb
comma
id|resid_sgptr
op_amp
id|SG_PTR_MASK
)paren
suffix:semicolon
multiline_comment|/* The residual sg_ptr always points to the next sg */
id|sg
op_decrement
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Add up the contents of all residual&n;&t;&t; * SG segments that are after the SG where&n;&t;&t; * the transfer stopped.&n;&t;&t; */
r_while
c_loop
(paren
(paren
id|ahc_le32toh
c_func
(paren
id|sg-&gt;len
)paren
op_amp
id|AHC_DMA_LAST_SEG
)paren
op_eq
l_int|0
)paren
(brace
id|sg
op_increment
suffix:semicolon
id|resid
op_add_assign
id|ahc_le32toh
c_func
(paren
id|sg-&gt;len
)paren
op_amp
id|AHC_SG_LEN_MASK
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_SENSE
)paren
op_eq
l_int|0
)paren
id|ahc_set_residual
c_func
(paren
id|scb
comma
id|resid
)paren
suffix:semicolon
r_else
id|ahc_set_sense_residual
c_func
(paren
id|scb
comma
id|resid
)paren
suffix:semicolon
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_MISC
)paren
op_ne
l_int|0
)paren
(brace
id|ahc_print_path
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Handled Residual of %d bytes&bslash;n&quot;
comma
id|resid
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/******************************* Target Mode **********************************/
macro_line|#ifdef AHC_TARGET_MODE
multiline_comment|/*&n; * Add a target mode event to this lun&squot;s queue&n; */
r_static
r_void
DECL|function|ahc_queue_lstate_event
id|ahc_queue_lstate_event
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_tmode_lstate
op_star
id|lstate
comma
id|u_int
id|initiator_id
comma
id|u_int
id|event_type
comma
id|u_int
id|event_arg
)paren
(brace
r_struct
id|ahc_tmode_event
op_star
id|event
suffix:semicolon
r_int
id|pending
suffix:semicolon
id|xpt_freeze_devq
c_func
(paren
id|lstate-&gt;path
comma
multiline_comment|/*count*/
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lstate-&gt;event_w_idx
op_ge
id|lstate-&gt;event_r_idx
)paren
id|pending
op_assign
id|lstate-&gt;event_w_idx
op_minus
id|lstate-&gt;event_r_idx
suffix:semicolon
r_else
id|pending
op_assign
id|AHC_TMODE_EVENT_BUFFER_SIZE
op_plus
l_int|1
op_minus
(paren
id|lstate-&gt;event_r_idx
op_minus
id|lstate-&gt;event_w_idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|event_type
op_eq
id|EVENT_TYPE_BUS_RESET
op_logical_or
id|event_type
op_eq
id|MSG_BUS_DEV_RESET
)paren
(brace
multiline_comment|/*&n;&t;&t; * Any earlier events are irrelevant, so reset our buffer.&n;&t;&t; * This has the effect of allowing us to deal with reset&n;&t;&t; * floods (an external device holding down the reset line)&n;&t;&t; * without losing the event that is really interesting.&n;&t;&t; */
id|lstate-&gt;event_r_idx
op_assign
l_int|0
suffix:semicolon
id|lstate-&gt;event_w_idx
op_assign
l_int|0
suffix:semicolon
id|xpt_release_devq
c_func
(paren
id|lstate-&gt;path
comma
id|pending
comma
multiline_comment|/*runqueue*/
id|FALSE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pending
op_eq
id|AHC_TMODE_EVENT_BUFFER_SIZE
)paren
(brace
id|xpt_print_path
c_func
(paren
id|lstate-&gt;path
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;immediate event %x:%x lost&bslash;n&quot;
comma
id|lstate-&gt;event_buffer
(braket
id|lstate-&gt;event_r_idx
)braket
dot
id|event_type
comma
id|lstate-&gt;event_buffer
(braket
id|lstate-&gt;event_r_idx
)braket
dot
id|event_arg
)paren
suffix:semicolon
id|lstate-&gt;event_r_idx
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|lstate-&gt;event_r_idx
op_eq
id|AHC_TMODE_EVENT_BUFFER_SIZE
)paren
id|lstate-&gt;event_r_idx
op_assign
l_int|0
suffix:semicolon
id|xpt_release_devq
c_func
(paren
id|lstate-&gt;path
comma
multiline_comment|/*count*/
l_int|1
comma
multiline_comment|/*runqueue*/
id|FALSE
)paren
suffix:semicolon
)brace
id|event
op_assign
op_amp
id|lstate-&gt;event_buffer
(braket
id|lstate-&gt;event_w_idx
)braket
suffix:semicolon
id|event-&gt;initiator_id
op_assign
id|initiator_id
suffix:semicolon
id|event-&gt;event_type
op_assign
id|event_type
suffix:semicolon
id|event-&gt;event_arg
op_assign
id|event_arg
suffix:semicolon
id|lstate-&gt;event_w_idx
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|lstate-&gt;event_w_idx
op_eq
id|AHC_TMODE_EVENT_BUFFER_SIZE
)paren
id|lstate-&gt;event_w_idx
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Send any target mode events queued up waiting&n; * for immediate notify resources.&n; */
r_void
DECL|function|ahc_send_lstate_events
id|ahc_send_lstate_events
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_tmode_lstate
op_star
id|lstate
)paren
(brace
r_struct
id|ccb_hdr
op_star
id|ccbh
suffix:semicolon
r_struct
id|ccb_immed_notify
op_star
id|inot
suffix:semicolon
r_while
c_loop
(paren
id|lstate-&gt;event_r_idx
op_ne
id|lstate-&gt;event_w_idx
op_logical_and
(paren
id|ccbh
op_assign
id|SLIST_FIRST
c_func
(paren
op_amp
id|lstate-&gt;immed_notifies
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_struct
id|ahc_tmode_event
op_star
id|event
suffix:semicolon
id|event
op_assign
op_amp
id|lstate-&gt;event_buffer
(braket
id|lstate-&gt;event_r_idx
)braket
suffix:semicolon
id|SLIST_REMOVE_HEAD
c_func
(paren
op_amp
id|lstate-&gt;immed_notifies
comma
id|sim_links.sle
)paren
suffix:semicolon
id|inot
op_assign
(paren
r_struct
id|ccb_immed_notify
op_star
)paren
id|ccbh
suffix:semicolon
r_switch
c_cond
(paren
id|event-&gt;event_type
)paren
(brace
r_case
id|EVENT_TYPE_BUS_RESET
suffix:colon
id|ccbh-&gt;status
op_assign
id|CAM_SCSI_BUS_RESET
op_or
id|CAM_DEV_QFRZN
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ccbh-&gt;status
op_assign
id|CAM_MESSAGE_RECV
op_or
id|CAM_DEV_QFRZN
suffix:semicolon
id|inot-&gt;message_args
(braket
l_int|0
)braket
op_assign
id|event-&gt;event_type
suffix:semicolon
id|inot-&gt;message_args
(braket
l_int|1
)braket
op_assign
id|event-&gt;event_arg
suffix:semicolon
r_break
suffix:semicolon
)brace
id|inot-&gt;initiator_id
op_assign
id|event-&gt;initiator_id
suffix:semicolon
id|inot-&gt;sense_len
op_assign
l_int|0
suffix:semicolon
id|xpt_done
c_func
(paren
(paren
r_union
id|ccb
op_star
)paren
id|inot
)paren
suffix:semicolon
id|lstate-&gt;event_r_idx
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|lstate-&gt;event_r_idx
op_eq
id|AHC_TMODE_EVENT_BUFFER_SIZE
)paren
id|lstate-&gt;event_r_idx
op_assign
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/******************** Sequencer Program Patching/Download *********************/
macro_line|#ifdef AHC_DUMP_SEQ
r_void
DECL|function|ahc_dumpseq
id|ahc_dumpseq
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|max_prog
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;chip
op_amp
id|AHC_BUS_MASK
)paren
OL
id|AHC_PCI
)paren
id|max_prog
op_assign
l_int|448
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_ne
l_int|0
)paren
id|max_prog
op_assign
l_int|768
suffix:semicolon
r_else
id|max_prog
op_assign
l_int|512
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SEQCTL
comma
id|PERRORDIS
op_or
id|FAILDIS
op_or
id|FASTMODE
op_or
id|LOADRAM
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SEQADDR0
comma
l_int|0
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SEQADDR1
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max_prog
suffix:semicolon
id|i
op_increment
)paren
(brace
r_uint8
id|ins_bytes
(braket
l_int|4
)braket
suffix:semicolon
id|ahc_insb
c_func
(paren
id|ahc
comma
id|SEQRAM
comma
id|ins_bytes
comma
l_int|4
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;0x%08x&bslash;n&quot;
comma
id|ins_bytes
(braket
l_int|0
)braket
op_lshift
l_int|24
op_or
id|ins_bytes
(braket
l_int|1
)braket
op_lshift
l_int|16
op_or
id|ins_bytes
(braket
l_int|2
)braket
op_lshift
l_int|8
op_or
id|ins_bytes
(braket
l_int|3
)braket
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
r_static
r_void
DECL|function|ahc_loadseq
id|ahc_loadseq
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_struct
id|cs
id|cs_table
(braket
id|num_critical_sections
)braket
suffix:semicolon
id|u_int
id|begin_set
(braket
id|num_critical_sections
)braket
suffix:semicolon
id|u_int
id|end_set
(braket
id|num_critical_sections
)braket
suffix:semicolon
r_struct
id|patch
op_star
id|cur_patch
suffix:semicolon
id|u_int
id|cs_count
suffix:semicolon
id|u_int
id|cur_cs
suffix:semicolon
id|u_int
id|i
suffix:semicolon
r_int
id|downloaded
suffix:semicolon
id|u_int
id|skip_addr
suffix:semicolon
id|u_int
id|sg_prefetch_cnt
suffix:semicolon
r_uint8
id|download_consts
(braket
l_int|7
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Start out with 0 critical sections&n;&t; * that apply to this firmware load.&n;&t; */
id|cs_count
op_assign
l_int|0
suffix:semicolon
id|cur_cs
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|begin_set
comma
l_int|0
comma
r_sizeof
(paren
id|begin_set
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|end_set
comma
l_int|0
comma
r_sizeof
(paren
id|end_set
)paren
)paren
suffix:semicolon
multiline_comment|/* Setup downloadable constant table */
id|download_consts
(braket
id|QOUTFIFO_OFFSET
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;targetcmds
op_ne
l_int|NULL
)paren
id|download_consts
(braket
id|QOUTFIFO_OFFSET
)braket
op_add_assign
l_int|32
suffix:semicolon
id|download_consts
(braket
id|QINFIFO_OFFSET
)braket
op_assign
id|download_consts
(braket
id|QOUTFIFO_OFFSET
)braket
op_plus
l_int|1
suffix:semicolon
id|download_consts
(braket
id|CACHESIZE_MASK
)braket
op_assign
id|ahc-&gt;pci_cachesize
op_minus
l_int|1
suffix:semicolon
id|download_consts
(braket
id|INVERTED_CACHESIZE_MASK
)braket
op_assign
op_complement
(paren
id|ahc-&gt;pci_cachesize
op_minus
l_int|1
)paren
suffix:semicolon
id|sg_prefetch_cnt
op_assign
id|ahc-&gt;pci_cachesize
suffix:semicolon
r_if
c_cond
(paren
id|sg_prefetch_cnt
OL
(paren
l_int|2
op_star
r_sizeof
(paren
r_struct
id|ahc_dma_seg
)paren
)paren
)paren
id|sg_prefetch_cnt
op_assign
l_int|2
op_star
r_sizeof
(paren
r_struct
id|ahc_dma_seg
)paren
suffix:semicolon
id|download_consts
(braket
id|SG_PREFETCH_CNT
)braket
op_assign
id|sg_prefetch_cnt
suffix:semicolon
id|download_consts
(braket
id|SG_PREFETCH_ALIGN_MASK
)braket
op_assign
op_complement
(paren
id|sg_prefetch_cnt
op_minus
l_int|1
)paren
suffix:semicolon
id|download_consts
(braket
id|SG_PREFETCH_ADDR_MASK
)braket
op_assign
(paren
id|sg_prefetch_cnt
op_minus
l_int|1
)paren
suffix:semicolon
id|cur_patch
op_assign
id|patches
suffix:semicolon
id|downloaded
op_assign
l_int|0
suffix:semicolon
id|skip_addr
op_assign
l_int|0
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SEQCTL
comma
id|PERRORDIS
op_or
id|FAILDIS
op_or
id|FASTMODE
op_or
id|LOADRAM
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SEQADDR0
comma
l_int|0
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SEQADDR1
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|seqprog
)paren
op_div
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ahc_check_patch
c_func
(paren
id|ahc
comma
op_amp
id|cur_patch
comma
id|i
comma
op_amp
id|skip_addr
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Don&squot;t download this instruction as it&n;&t;&t;&t; * is in a patch that was removed.&n;&t;&t;&t; */
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Move through the CS table until we find a CS&n;&t;&t; * that might apply to this instruction.&n;&t;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|cur_cs
OL
id|num_critical_sections
suffix:semicolon
id|cur_cs
op_increment
)paren
(brace
r_if
c_cond
(paren
id|critical_sections
(braket
id|cur_cs
)braket
dot
id|end
op_le
id|i
)paren
(brace
r_if
c_cond
(paren
id|begin_set
(braket
id|cs_count
)braket
op_eq
id|TRUE
op_logical_and
id|end_set
(braket
id|cs_count
)braket
op_eq
id|FALSE
)paren
(brace
id|cs_table
(braket
id|cs_count
)braket
dot
id|end
op_assign
id|downloaded
suffix:semicolon
id|end_set
(braket
id|cs_count
)braket
op_assign
id|TRUE
suffix:semicolon
id|cs_count
op_increment
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|critical_sections
(braket
id|cur_cs
)braket
dot
id|begin
op_le
id|i
op_logical_and
id|begin_set
(braket
id|cs_count
)braket
op_eq
id|FALSE
)paren
(brace
id|cs_table
(braket
id|cs_count
)braket
dot
id|begin
op_assign
id|downloaded
suffix:semicolon
id|begin_set
(braket
id|cs_count
)braket
op_assign
id|TRUE
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|ahc_download_instr
c_func
(paren
id|ahc
comma
id|i
comma
id|download_consts
)paren
suffix:semicolon
id|downloaded
op_increment
suffix:semicolon
)brace
id|ahc-&gt;num_critical_sections
op_assign
id|cs_count
suffix:semicolon
r_if
c_cond
(paren
id|cs_count
op_ne
l_int|0
)paren
(brace
id|cs_count
op_mul_assign
r_sizeof
(paren
r_struct
id|cs
)paren
suffix:semicolon
id|ahc-&gt;critical_sections
op_assign
id|malloc
c_func
(paren
id|cs_count
comma
id|M_DEVBUF
comma
id|M_NOWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;critical_sections
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;ahc_loadseq: Could not malloc&quot;
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ahc-&gt;critical_sections
comma
id|cs_table
comma
id|cs_count
)paren
suffix:semicolon
)brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SEQCTL
comma
id|PERRORDIS
op_or
id|FAILDIS
op_or
id|FASTMODE
)paren
suffix:semicolon
id|ahc_restart
c_func
(paren
id|ahc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
)paren
id|printf
c_func
(paren
l_string|&quot; %d instructions downloaded&bslash;n&quot;
comma
id|downloaded
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|ahc_check_patch
id|ahc_check_patch
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|patch
op_star
op_star
id|start_patch
comma
id|u_int
id|start_instr
comma
id|u_int
op_star
id|skip_addr
)paren
(brace
r_struct
id|patch
op_star
id|cur_patch
suffix:semicolon
r_struct
id|patch
op_star
id|last_patch
suffix:semicolon
id|u_int
id|num_patches
suffix:semicolon
id|num_patches
op_assign
r_sizeof
(paren
id|patches
)paren
op_div
r_sizeof
(paren
r_struct
id|patch
)paren
suffix:semicolon
id|last_patch
op_assign
op_amp
id|patches
(braket
id|num_patches
)braket
suffix:semicolon
id|cur_patch
op_assign
op_star
id|start_patch
suffix:semicolon
r_while
c_loop
(paren
id|cur_patch
OL
id|last_patch
op_logical_and
id|start_instr
op_eq
id|cur_patch-&gt;begin
)paren
(brace
r_if
c_cond
(paren
id|cur_patch
op_member_access_from_pointer
id|patch_func
c_func
(paren
id|ahc
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Start rejecting code */
op_star
id|skip_addr
op_assign
id|start_instr
op_plus
id|cur_patch-&gt;skip_instr
suffix:semicolon
id|cur_patch
op_add_assign
id|cur_patch-&gt;skip_patch
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Accepted this patch.  Advance to the next&n;&t;&t;&t; * one and wait for our intruction pointer to&n;&t;&t;&t; * hit this point.&n;&t;&t;&t; */
id|cur_patch
op_increment
suffix:semicolon
)brace
)brace
op_star
id|start_patch
op_assign
id|cur_patch
suffix:semicolon
r_if
c_cond
(paren
id|start_instr
OL
op_star
id|skip_addr
)paren
multiline_comment|/* Still skipping */
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahc_download_instr
id|ahc_download_instr
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|u_int
id|instrptr
comma
r_uint8
op_star
id|dconsts
)paren
(brace
r_union
id|ins_formats
id|instr
suffix:semicolon
r_struct
id|ins_format1
op_star
id|fmt1_ins
suffix:semicolon
r_struct
id|ins_format3
op_star
id|fmt3_ins
suffix:semicolon
id|u_int
id|opcode
suffix:semicolon
multiline_comment|/*&n;&t; * The firmware is always compiled into a little endian format.&n;&t; */
id|instr.integer
op_assign
id|ahc_le32toh
c_func
(paren
op_star
(paren
r_uint32
op_star
)paren
op_amp
id|seqprog
(braket
id|instrptr
op_star
l_int|4
)braket
)paren
suffix:semicolon
id|fmt1_ins
op_assign
op_amp
id|instr.format1
suffix:semicolon
id|fmt3_ins
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Pull the opcode */
id|opcode
op_assign
id|instr.format1.opcode
suffix:semicolon
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_case
id|AIC_OP_JMP
suffix:colon
r_case
id|AIC_OP_JC
suffix:colon
r_case
id|AIC_OP_JNC
suffix:colon
r_case
id|AIC_OP_CALL
suffix:colon
r_case
id|AIC_OP_JNE
suffix:colon
r_case
id|AIC_OP_JNZ
suffix:colon
r_case
id|AIC_OP_JE
suffix:colon
r_case
id|AIC_OP_JZ
suffix:colon
(brace
r_struct
id|patch
op_star
id|cur_patch
suffix:semicolon
r_int
id|address_offset
suffix:semicolon
id|u_int
id|address
suffix:semicolon
id|u_int
id|skip_addr
suffix:semicolon
id|u_int
id|i
suffix:semicolon
id|fmt3_ins
op_assign
op_amp
id|instr.format3
suffix:semicolon
id|address_offset
op_assign
l_int|0
suffix:semicolon
id|address
op_assign
id|fmt3_ins-&gt;address
suffix:semicolon
id|cur_patch
op_assign
id|patches
suffix:semicolon
id|skip_addr
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|address
suffix:semicolon
)paren
(brace
id|ahc_check_patch
c_func
(paren
id|ahc
comma
op_amp
id|cur_patch
comma
id|i
comma
op_amp
id|skip_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skip_addr
OG
id|i
)paren
(brace
r_int
id|end_addr
suffix:semicolon
id|end_addr
op_assign
id|MIN
c_func
(paren
id|address
comma
id|skip_addr
)paren
suffix:semicolon
id|address_offset
op_add_assign
id|end_addr
op_minus
id|i
suffix:semicolon
id|i
op_assign
id|skip_addr
suffix:semicolon
)brace
r_else
(brace
id|i
op_increment
suffix:semicolon
)brace
)brace
id|address
op_sub_assign
id|address_offset
suffix:semicolon
id|fmt3_ins-&gt;address
op_assign
id|address
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
)brace
r_case
id|AIC_OP_OR
suffix:colon
r_case
id|AIC_OP_AND
suffix:colon
r_case
id|AIC_OP_XOR
suffix:colon
r_case
id|AIC_OP_ADD
suffix:colon
r_case
id|AIC_OP_ADC
suffix:colon
r_case
id|AIC_OP_BMOV
suffix:colon
r_if
c_cond
(paren
id|fmt1_ins-&gt;parity
op_ne
l_int|0
)paren
(brace
id|fmt1_ins-&gt;immediate
op_assign
id|dconsts
(braket
id|fmt1_ins-&gt;immediate
)braket
suffix:semicolon
)brace
id|fmt1_ins-&gt;parity
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_CMD_CHAN
)paren
op_eq
l_int|0
op_logical_and
id|opcode
op_eq
id|AIC_OP_BMOV
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Block move was added at the same time&n;&t;&t;&t; * as the command channel.  Verify that&n;&t;&t;&t; * this is only a move of a single element&n;&t;&t;&t; * and convert the BMOV to a MOV&n;&t;&t;&t; * (AND with an immediate of FF).&n;&t;&t;&t; */
r_if
c_cond
(paren
id|fmt1_ins-&gt;immediate
op_ne
l_int|1
)paren
id|panic
c_func
(paren
l_string|&quot;%s: BMOV not supported&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
)paren
suffix:semicolon
id|fmt1_ins-&gt;opcode
op_assign
id|AIC_OP_AND
suffix:semicolon
id|fmt1_ins-&gt;immediate
op_assign
l_int|0xff
suffix:semicolon
)brace
multiline_comment|/* FALLTHROUGH */
r_case
id|AIC_OP_ROL
suffix:colon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_ne
l_int|0
)paren
(brace
r_int
id|i
comma
id|count
suffix:semicolon
multiline_comment|/* Calculate odd parity for the instruction */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|count
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|31
suffix:semicolon
id|i
op_increment
)paren
(brace
r_uint32
id|mask
suffix:semicolon
id|mask
op_assign
l_int|0x01
op_lshift
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|instr.integer
op_amp
id|mask
)paren
op_ne
l_int|0
)paren
id|count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|count
op_amp
l_int|0x01
)paren
op_eq
l_int|0
)paren
id|instr.format1.parity
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Compress the instruction for older sequencers */
r_if
c_cond
(paren
id|fmt3_ins
op_ne
l_int|NULL
)paren
(brace
id|instr.integer
op_assign
id|fmt3_ins-&gt;immediate
op_or
(paren
id|fmt3_ins-&gt;source
op_lshift
l_int|8
)paren
op_or
(paren
id|fmt3_ins-&gt;address
op_lshift
l_int|16
)paren
op_or
(paren
id|fmt3_ins-&gt;opcode
op_lshift
l_int|25
)paren
suffix:semicolon
)brace
r_else
(brace
id|instr.integer
op_assign
id|fmt1_ins-&gt;immediate
op_or
(paren
id|fmt1_ins-&gt;source
op_lshift
l_int|8
)paren
op_or
(paren
id|fmt1_ins-&gt;destination
op_lshift
l_int|16
)paren
op_or
(paren
id|fmt1_ins-&gt;ret
op_lshift
l_int|24
)paren
op_or
(paren
id|fmt1_ins-&gt;opcode
op_lshift
l_int|25
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* The sequencer is a little endian cpu */
id|instr.integer
op_assign
id|ahc_htole32
c_func
(paren
id|instr.integer
)paren
suffix:semicolon
id|ahc_outsb
c_func
(paren
id|ahc
comma
id|SEQRAM
comma
id|instr.bytes
comma
l_int|4
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;Unknown opcode encountered in seq program&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|ahc_probe_stack_size
id|ahc_probe_stack_size
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_int
id|last_probe
suffix:semicolon
id|last_probe
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We avoid using 0 as a pattern to avoid&n;&t;&t; * confusion if the stack implementation&n;&t;&t; * &quot;back-fills&quot; with zeros when &quot;poping&squot;&n;&t;&t; * entries.&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
id|last_probe
op_plus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|STACK
comma
id|i
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|STACK
comma
(paren
id|i
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
)brace
multiline_comment|/* Verify */
r_for
c_loop
(paren
id|i
op_assign
id|last_probe
op_plus
l_int|1
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|u_int
id|stack_entry
suffix:semicolon
id|stack_entry
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|STACK
)paren
op_or
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|STACK
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stack_entry
op_ne
id|i
)paren
r_goto
id|sized
suffix:semicolon
)brace
id|last_probe
op_increment
suffix:semicolon
)brace
id|sized
suffix:colon
r_return
(paren
id|last_probe
)paren
suffix:semicolon
)brace
r_int
DECL|function|ahc_print_register
id|ahc_print_register
c_func
(paren
id|ahc_reg_parse_entry_t
op_star
id|table
comma
id|u_int
id|num_entries
comma
r_const
r_char
op_star
id|name
comma
id|u_int
id|address
comma
id|u_int
id|value
comma
id|u_int
op_star
id|cur_column
comma
id|u_int
id|wrap_point
)paren
(brace
r_int
id|printed
suffix:semicolon
id|u_int
id|printed_mask
suffix:semicolon
r_if
c_cond
(paren
id|cur_column
op_ne
l_int|NULL
op_logical_and
op_star
id|cur_column
op_ge
id|wrap_point
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|cur_column
op_assign
l_int|0
suffix:semicolon
)brace
id|printed
op_assign
id|printf
c_func
(paren
l_string|&quot;%s[0x%x]&quot;
comma
id|name
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|table
op_eq
l_int|NULL
)paren
(brace
id|printed
op_add_assign
id|printf
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
op_star
id|cur_column
op_add_assign
id|printed
suffix:semicolon
r_return
(paren
id|printed
)paren
suffix:semicolon
)brace
id|printed_mask
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|printed_mask
op_ne
l_int|0xFF
)paren
(brace
r_int
id|entry
suffix:semicolon
r_for
c_loop
(paren
id|entry
op_assign
l_int|0
suffix:semicolon
id|entry
OL
id|num_entries
suffix:semicolon
id|entry
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|value
op_amp
id|table
(braket
id|entry
)braket
dot
id|mask
)paren
op_ne
id|table
(braket
id|entry
)braket
dot
id|value
)paren
op_logical_or
(paren
(paren
id|printed_mask
op_amp
id|table
(braket
id|entry
)braket
dot
id|mask
)paren
op_eq
id|table
(braket
id|entry
)braket
dot
id|mask
)paren
)paren
r_continue
suffix:semicolon
id|printed
op_add_assign
id|printf
c_func
(paren
l_string|&quot;%s%s&quot;
comma
id|printed_mask
op_eq
l_int|0
ques
c_cond
l_string|&quot;:(&quot;
suffix:colon
l_string|&quot;|&quot;
comma
id|table
(braket
id|entry
)braket
dot
id|name
)paren
suffix:semicolon
id|printed_mask
op_or_assign
id|table
(braket
id|entry
)braket
dot
id|mask
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry
op_ge
id|num_entries
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|printed_mask
op_ne
l_int|0
)paren
id|printed
op_add_assign
id|printf
c_func
(paren
l_string|&quot;) &quot;
)paren
suffix:semicolon
r_else
id|printed
op_add_assign
id|printf
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur_column
op_ne
l_int|NULL
)paren
op_star
id|cur_column
op_add_assign
id|printed
suffix:semicolon
r_return
(paren
id|printed
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahc_dump_card_state
id|ahc_dump_card_state
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_struct
id|scb
op_star
id|scb
suffix:semicolon
r_struct
id|scb_tailq
op_star
id|untagged_q
suffix:semicolon
id|u_int
id|cur_col
suffix:semicolon
r_int
id|target
suffix:semicolon
r_int
id|maxtarget
suffix:semicolon
r_int
id|i
suffix:semicolon
r_uint8
id|last_phase
suffix:semicolon
r_uint8
id|qinpos
suffix:semicolon
r_uint8
id|qintail
suffix:semicolon
r_uint8
id|qoutpos
suffix:semicolon
r_uint8
id|scb_index
suffix:semicolon
r_uint8
id|saved_scbptr
suffix:semicolon
id|saved_scbptr
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCBPTR
)paren
suffix:semicolon
id|last_phase
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|LASTPHASE
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s: Dumping Card State %s, at SEQADDR 0x%x&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|ahc_lookup_phase_entry
c_func
(paren
id|last_phase
)paren
op_member_access_from_pointer
id|phasemsg
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SEQADDR0
)paren
op_or
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SEQADDR1
)paren
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;ACCUM = 0x%x, SINDEX = 0x%x, DINDEX = 0x%x, ARG_2 = 0x%x&bslash;n&quot;
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|ACCUM
)paren
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SINDEX
)paren
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|DINDEX
)paren
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|ARG_2
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;HCNT = 0x%x SCBPTR = 0x%x&bslash;n&quot;
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|HCNT
)paren
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCBPTR
)paren
)paren
suffix:semicolon
id|cur_col
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_DT
)paren
op_ne
l_int|0
)paren
id|ahc_scsisigi_print
c_func
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSISIGI
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahc_scsiphase_print
c_func
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSIPHASE
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahc_scsibusl_print
c_func
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSIBUSL
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahc_lastphase_print
c_func
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|LASTPHASE
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahc_scsiseq_print
c_func
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSISEQ
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahc_sblkctl_print
c_func
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SBLKCTL
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahc_seqctl_print
c_func
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SEQCTL
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahc_seq_flags_print
c_func
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SEQ_FLAGS
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahc_sstat0_print
c_func
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SSTAT0
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahc_sstat1_print
c_func
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SSTAT1
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahc_sstat2_print
c_func
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SSTAT2
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahc_sstat3_print
c_func
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SSTAT3
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahc_simode0_print
c_func
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SIMODE0
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahc_simode1_print
c_func
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SIMODE1
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahc_sxfrctl0_print
c_func
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SXFRCTL0
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahc_dfcntrl_print
c_func
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|DFCNTRL
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahc_dfstatus_print
c_func
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|DFSTATUS
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur_col
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;STACK:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ahc-&gt;stack_size
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ahc-&gt;saved_stack
(braket
id|i
)braket
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|STACK
)paren
op_or
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|STACK
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot; 0x%x&quot;
comma
id|ahc-&gt;saved_stack
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;nSCB count = %d&bslash;n&quot;
comma
id|ahc-&gt;scb_data-&gt;numscbs
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Kernel NEXTQSCB = %d&bslash;n&quot;
comma
id|ahc-&gt;next_queued_scb-&gt;hscb-&gt;tag
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Card NEXTQSCB = %d&bslash;n&quot;
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|NEXT_QUEUED_SCB
)paren
)paren
suffix:semicolon
multiline_comment|/* QINFIFO */
id|printf
c_func
(paren
l_string|&quot;QINFIFO entries: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_QUEUE_REGS
)paren
op_ne
l_int|0
)paren
(brace
id|qinpos
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SNSCB_QOFF
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SNSCB_QOFF
comma
id|qinpos
)paren
suffix:semicolon
)brace
r_else
id|qinpos
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|QINPOS
)paren
suffix:semicolon
id|qintail
op_assign
id|ahc-&gt;qinfifonext
suffix:semicolon
r_while
c_loop
(paren
id|qinpos
op_ne
id|qintail
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%d &quot;
comma
id|ahc-&gt;qinfifo
(braket
id|qinpos
)braket
)paren
suffix:semicolon
id|qinpos
op_increment
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Waiting Queue entries: &quot;
)paren
suffix:semicolon
id|scb_index
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|WAITING_SCBH
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|scb_index
op_ne
id|SCB_LIST_NULL
op_logical_and
id|i
op_increment
OL
l_int|256
)paren
(brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBPTR
comma
id|scb_index
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%d:%d &quot;
comma
id|scb_index
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_TAG
)paren
)paren
suffix:semicolon
id|scb_index
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_NEXT
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Disconnected Queue entries: &quot;
)paren
suffix:semicolon
id|scb_index
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|DISCONNECTED_SCBH
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|scb_index
op_ne
id|SCB_LIST_NULL
op_logical_and
id|i
op_increment
OL
l_int|256
)paren
(brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBPTR
comma
id|scb_index
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%d:%d &quot;
comma
id|scb_index
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_TAG
)paren
)paren
suffix:semicolon
id|scb_index
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_NEXT
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|ahc_sync_qoutfifo
c_func
(paren
id|ahc
comma
id|BUS_DMASYNC_POSTREAD
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;QOUTFIFO entries: &quot;
)paren
suffix:semicolon
id|qoutpos
op_assign
id|ahc-&gt;qoutfifonext
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|ahc-&gt;qoutfifo
(braket
id|qoutpos
)braket
op_ne
id|SCB_LIST_NULL
op_logical_and
id|i
op_increment
OL
l_int|256
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%d &quot;
comma
id|ahc-&gt;qoutfifo
(braket
id|qoutpos
)braket
)paren
suffix:semicolon
id|qoutpos
op_increment
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Sequencer Free SCB List: &quot;
)paren
suffix:semicolon
id|scb_index
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|FREE_SCBH
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|scb_index
op_ne
id|SCB_LIST_NULL
op_logical_and
id|i
op_increment
OL
l_int|256
)paren
(brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBPTR
comma
id|scb_index
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%d &quot;
comma
id|scb_index
)paren
suffix:semicolon
id|scb_index
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_NEXT
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Sequencer SCB Info: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ahc-&gt;scb_data-&gt;maxhscbs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBPTR
comma
id|i
)paren
suffix:semicolon
id|cur_col
op_assign
id|printf
c_func
(paren
l_string|&quot;&bslash;n%3d &quot;
comma
id|i
)paren
suffix:semicolon
id|ahc_scb_control_print
c_func
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_CONTROL
)paren
comma
op_amp
id|cur_col
comma
l_int|60
)paren
suffix:semicolon
id|ahc_scb_scsiid_print
c_func
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_SCSIID
)paren
comma
op_amp
id|cur_col
comma
l_int|60
)paren
suffix:semicolon
id|ahc_scb_lun_print
c_func
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_LUN
)paren
comma
op_amp
id|cur_col
comma
l_int|60
)paren
suffix:semicolon
id|ahc_scb_tag_print
c_func
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_TAG
)paren
comma
op_amp
id|cur_col
comma
l_int|60
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Pending list: &quot;
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
id|LIST_FOREACH
c_func
(paren
id|scb
comma
op_amp
id|ahc-&gt;pending_scbs
comma
id|pending_links
)paren
(brace
r_if
c_cond
(paren
id|i
op_increment
OG
l_int|256
)paren
r_break
suffix:semicolon
id|cur_col
op_assign
id|printf
c_func
(paren
l_string|&quot;&bslash;n%3d &quot;
comma
id|scb-&gt;hscb-&gt;tag
)paren
suffix:semicolon
id|ahc_scb_control_print
c_func
(paren
id|scb-&gt;hscb-&gt;control
comma
op_amp
id|cur_col
comma
l_int|60
)paren
suffix:semicolon
id|ahc_scb_scsiid_print
c_func
(paren
id|scb-&gt;hscb-&gt;scsiid
comma
op_amp
id|cur_col
comma
l_int|60
)paren
suffix:semicolon
id|ahc_scb_lun_print
c_func
(paren
id|scb-&gt;hscb-&gt;lun
comma
op_amp
id|cur_col
comma
l_int|60
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;flags
op_amp
id|AHC_PAGESCBS
)paren
op_eq
l_int|0
)paren
(brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBPTR
comma
id|scb-&gt;hscb-&gt;tag
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;(&quot;
)paren
suffix:semicolon
id|ahc_scb_control_print
c_func
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_CONTROL
)paren
comma
op_amp
id|cur_col
comma
l_int|60
)paren
suffix:semicolon
id|ahc_scb_tag_print
c_func
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_TAG
)paren
comma
op_amp
id|cur_col
comma
l_int|60
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;)&quot;
)paren
suffix:semicolon
)brace
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Kernel Free SCB list: &quot;
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
id|SLIST_FOREACH
c_func
(paren
id|scb
comma
op_amp
id|ahc-&gt;scb_data-&gt;free_scbs
comma
id|links.sle
)paren
(brace
r_if
c_cond
(paren
id|i
op_increment
OG
l_int|256
)paren
r_break
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%d &quot;
comma
id|scb-&gt;hscb-&gt;tag
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|maxtarget
op_assign
(paren
id|ahc-&gt;features
op_amp
(paren
id|AHC_WIDE
op_or
id|AHC_TWIN
)paren
)paren
ques
c_cond
l_int|15
suffix:colon
l_int|7
suffix:semicolon
r_for
c_loop
(paren
id|target
op_assign
l_int|0
suffix:semicolon
id|target
op_le
id|maxtarget
suffix:semicolon
id|target
op_increment
)paren
(brace
id|untagged_q
op_assign
op_amp
id|ahc-&gt;untagged_queues
(braket
id|target
)braket
suffix:semicolon
r_if
c_cond
(paren
id|TAILQ_FIRST
c_func
(paren
id|untagged_q
)paren
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Untagged Q(%d): &quot;
comma
id|target
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
id|TAILQ_FOREACH
c_func
(paren
id|scb
comma
id|untagged_q
comma
id|links.tqe
)paren
(brace
r_if
c_cond
(paren
id|i
op_increment
OG
l_int|256
)paren
r_break
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%d &quot;
comma
id|scb-&gt;hscb-&gt;tag
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|ahc_platform_dump_card_state
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBPTR
comma
id|saved_scbptr
)paren
suffix:semicolon
)brace
multiline_comment|/************************* Target Mode ****************************************/
macro_line|#ifdef AHC_TARGET_MODE
id|cam_status
DECL|function|ahc_find_tmode_devs
id|ahc_find_tmode_devs
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|cam_sim
op_star
id|sim
comma
r_union
id|ccb
op_star
id|ccb
comma
r_struct
id|ahc_tmode_tstate
op_star
op_star
id|tstate
comma
r_struct
id|ahc_tmode_lstate
op_star
op_star
id|lstate
comma
r_int
id|notfound_failure
)paren
(brace
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_TARGETMODE
)paren
op_eq
l_int|0
)paren
r_return
(paren
id|CAM_REQ_INVALID
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Handle the &squot;black hole&squot; device that sucks up&n;&t; * requests to unattached luns on enabled targets.&n;&t; */
r_if
c_cond
(paren
id|ccb-&gt;ccb_h.target_id
op_eq
id|CAM_TARGET_WILDCARD
op_logical_and
id|ccb-&gt;ccb_h.target_lun
op_eq
id|CAM_LUN_WILDCARD
)paren
(brace
op_star
id|tstate
op_assign
l_int|NULL
suffix:semicolon
op_star
id|lstate
op_assign
id|ahc-&gt;black_hole
suffix:semicolon
)brace
r_else
(brace
id|u_int
id|max_id
suffix:semicolon
id|max_id
op_assign
(paren
id|ahc-&gt;features
op_amp
id|AHC_WIDE
)paren
ques
c_cond
l_int|15
suffix:colon
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|ccb-&gt;ccb_h.target_id
OG
id|max_id
)paren
r_return
(paren
id|CAM_TID_INVALID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccb-&gt;ccb_h.target_lun
op_ge
id|AHC_NUM_LUNS
)paren
r_return
(paren
id|CAM_LUN_INVALID
)paren
suffix:semicolon
op_star
id|tstate
op_assign
id|ahc-&gt;enabled_targets
(braket
id|ccb-&gt;ccb_h.target_id
)braket
suffix:semicolon
op_star
id|lstate
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_star
id|tstate
op_ne
l_int|NULL
)paren
op_star
id|lstate
op_assign
(paren
op_star
id|tstate
)paren
op_member_access_from_pointer
id|enabled_luns
(braket
id|ccb-&gt;ccb_h.target_lun
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|notfound_failure
op_ne
l_int|0
op_logical_and
op_star
id|lstate
op_eq
l_int|NULL
)paren
r_return
(paren
id|CAM_PATH_INVALID
)paren
suffix:semicolon
r_return
(paren
id|CAM_REQ_CMP
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahc_handle_en_lun
id|ahc_handle_en_lun
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|cam_sim
op_star
id|sim
comma
r_union
id|ccb
op_star
id|ccb
)paren
(brace
r_struct
id|ahc_tmode_tstate
op_star
id|tstate
suffix:semicolon
r_struct
id|ahc_tmode_lstate
op_star
id|lstate
suffix:semicolon
r_struct
id|ccb_en_lun
op_star
id|cel
suffix:semicolon
id|cam_status
id|status
suffix:semicolon
id|u_int
id|target
suffix:semicolon
id|u_int
id|lun
suffix:semicolon
id|u_int
id|target_mask
suffix:semicolon
id|u_int
id|our_id
suffix:semicolon
id|u_long
id|s
suffix:semicolon
r_char
id|channel
suffix:semicolon
id|status
op_assign
id|ahc_find_tmode_devs
c_func
(paren
id|ahc
comma
id|sim
comma
id|ccb
comma
op_amp
id|tstate
comma
op_amp
id|lstate
comma
multiline_comment|/*notfound_failure*/
id|FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
id|CAM_REQ_CMP
)paren
(brace
id|ccb-&gt;ccb_h.status
op_assign
id|status
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cam_sim_bus
c_func
(paren
id|sim
)paren
op_eq
l_int|0
)paren
id|our_id
op_assign
id|ahc-&gt;our_id
suffix:semicolon
r_else
id|our_id
op_assign
id|ahc-&gt;our_id_b
suffix:semicolon
r_if
c_cond
(paren
id|ccb-&gt;ccb_h.target_id
op_ne
id|our_id
)paren
(brace
multiline_comment|/*&n;&t;&t; * our_id represents our initiator ID, or&n;&t;&t; * the ID of the first target to have an&n;&t;&t; * enabled lun in target mode.  There are&n;&t;&t; * two cases that may preclude enabling a&n;&t;&t; * target id other than our_id.&n;&t;&t; *&n;&t;&t; *   o our_id is for an active initiator role.&n;&t;&t; *     Since the hardware does not support&n;&t;&t; *     reselections to the initiator role at&n;&t;&t; *     anything other than our_id, and our_id&n;&t;&t; *     is used by the hardware to indicate the&n;&t;&t; *     ID to use for both select-out and&n;&t;&t; *     reselect-out operations, the only target&n;&t;&t; *     ID we can support in this mode is our_id.&n;&t;&t; *&n;&t;&t; *   o The MULTARGID feature is not available and&n;&t;&t; *     a previous target mode ID has been enabled.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_MULTIROLE
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_MULTI_TID
)paren
op_ne
l_int|0
op_logical_and
(paren
id|ahc-&gt;flags
op_amp
id|AHC_INITIATORROLE
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Only allow additional targets if&n;&t;&t;&t;&t; * the initiator role is disabled.&n;&t;&t;&t;&t; * The hardware cannot handle a re-select-in&n;&t;&t;&t;&t; * on the initiator id during a re-select-out&n;&t;&t;&t;&t; * on a different target id.&n;&t;&t;&t;&t; */
id|status
op_assign
id|CAM_TID_INVALID
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|ahc-&gt;flags
op_amp
id|AHC_INITIATORROLE
)paren
op_ne
l_int|0
op_logical_or
id|ahc-&gt;enabled_luns
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Only allow our target id to change&n;&t;&t;&t;&t; * if the initiator role is not configured&n;&t;&t;&t;&t; * and there are no enabled luns which&n;&t;&t;&t;&t; * are attached to the currently registered&n;&t;&t;&t;&t; * scsi id.&n;&t;&t;&t;&t; */
id|status
op_assign
id|CAM_TID_INVALID
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_MULTI_TID
)paren
op_eq
l_int|0
op_logical_and
id|ahc-&gt;enabled_luns
OG
l_int|0
)paren
(brace
id|status
op_assign
id|CAM_TID_INVALID
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|status
op_ne
id|CAM_REQ_CMP
)paren
(brace
id|ccb-&gt;ccb_h.status
op_assign
id|status
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We now have an id that is valid.&n;&t; * If we aren&squot;t in target mode, switch modes.&n;&t; */
r_if
c_cond
(paren
(paren
id|ahc-&gt;flags
op_amp
id|AHC_TARGETROLE
)paren
op_eq
l_int|0
op_logical_and
id|ccb-&gt;ccb_h.target_id
op_ne
id|CAM_TARGET_WILDCARD
)paren
(brace
id|u_long
id|s
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Configuring Target Mode&bslash;n&quot;
)paren
suffix:semicolon
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|LIST_FIRST
c_func
(paren
op_amp
id|ahc-&gt;pending_scbs
)paren
op_ne
l_int|NULL
)paren
(brace
id|ccb-&gt;ccb_h.status
op_assign
id|CAM_BUSY
suffix:semicolon
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ahc-&gt;flags
op_or_assign
id|AHC_TARGETROLE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_MULTIROLE
)paren
op_eq
l_int|0
)paren
id|ahc-&gt;flags
op_and_assign
op_complement
id|AHC_INITIATORROLE
suffix:semicolon
id|ahc_pause
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_loadseq
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
)brace
id|cel
op_assign
op_amp
id|ccb-&gt;cel
suffix:semicolon
id|target
op_assign
id|ccb-&gt;ccb_h.target_id
suffix:semicolon
id|lun
op_assign
id|ccb-&gt;ccb_h.target_lun
suffix:semicolon
id|channel
op_assign
id|SIM_CHANNEL
c_func
(paren
id|ahc
comma
id|sim
)paren
suffix:semicolon
id|target_mask
op_assign
l_int|0x01
op_lshift
id|target
suffix:semicolon
r_if
c_cond
(paren
id|channel
op_eq
l_char|&squot;B&squot;
)paren
id|target_mask
op_lshift_assign
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|cel-&gt;enable
op_ne
l_int|0
)paren
(brace
id|u_int
id|scsiseq
suffix:semicolon
multiline_comment|/* Are we already enabled?? */
r_if
c_cond
(paren
id|lstate
op_ne
l_int|NULL
)paren
(brace
id|xpt_print_path
c_func
(paren
id|ccb-&gt;ccb_h.path
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Lun already enabled&bslash;n&quot;
)paren
suffix:semicolon
id|ccb-&gt;ccb_h.status
op_assign
id|CAM_LUN_ALRDY_ENA
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cel-&gt;grp6_len
op_ne
l_int|0
op_logical_or
id|cel-&gt;grp7_len
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Don&squot;t (yet?) support vendor&n;&t;&t;&t; * specific commands.&n;&t;&t;&t; */
id|ccb-&gt;ccb_h.status
op_assign
id|CAM_REQ_INVALID
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Non-zero Group Codes&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Seems to be okay.&n;&t;&t; * Setup our data structures.&n;&t;&t; */
r_if
c_cond
(paren
id|target
op_ne
id|CAM_TARGET_WILDCARD
op_logical_and
id|tstate
op_eq
l_int|NULL
)paren
(brace
id|tstate
op_assign
id|ahc_alloc_tstate
c_func
(paren
id|ahc
comma
id|target
comma
id|channel
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tstate
op_eq
l_int|NULL
)paren
(brace
id|xpt_print_path
c_func
(paren
id|ccb-&gt;ccb_h.path
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Couldn&squot;t allocate tstate&bslash;n&quot;
)paren
suffix:semicolon
id|ccb-&gt;ccb_h.status
op_assign
id|CAM_RESRC_UNAVAIL
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|lstate
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|lstate
)paren
comma
id|M_DEVBUF
comma
id|M_NOWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lstate
op_eq
l_int|NULL
)paren
(brace
id|xpt_print_path
c_func
(paren
id|ccb-&gt;ccb_h.path
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Couldn&squot;t allocate lstate&bslash;n&quot;
)paren
suffix:semicolon
id|ccb-&gt;ccb_h.status
op_assign
id|CAM_RESRC_UNAVAIL
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memset
c_func
(paren
id|lstate
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|lstate
)paren
)paren
suffix:semicolon
id|status
op_assign
id|xpt_create_path
c_func
(paren
op_amp
id|lstate-&gt;path
comma
multiline_comment|/*periph*/
l_int|NULL
comma
id|xpt_path_path_id
c_func
(paren
id|ccb-&gt;ccb_h.path
)paren
comma
id|xpt_path_target_id
c_func
(paren
id|ccb-&gt;ccb_h.path
)paren
comma
id|xpt_path_lun_id
c_func
(paren
id|ccb-&gt;ccb_h.path
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
id|CAM_REQ_CMP
)paren
(brace
id|free
c_func
(paren
id|lstate
comma
id|M_DEVBUF
)paren
suffix:semicolon
id|xpt_print_path
c_func
(paren
id|ccb-&gt;ccb_h.path
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Couldn&squot;t allocate path&bslash;n&quot;
)paren
suffix:semicolon
id|ccb-&gt;ccb_h.status
op_assign
id|CAM_RESRC_UNAVAIL
suffix:semicolon
r_return
suffix:semicolon
)brace
id|SLIST_INIT
c_func
(paren
op_amp
id|lstate-&gt;accept_tios
)paren
suffix:semicolon
id|SLIST_INIT
c_func
(paren
op_amp
id|lstate-&gt;immed_notifies
)paren
suffix:semicolon
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
id|ahc_pause
c_func
(paren
id|ahc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|target
op_ne
id|CAM_TARGET_WILDCARD
)paren
(brace
id|tstate-&gt;enabled_luns
(braket
id|lun
)braket
op_assign
id|lstate
suffix:semicolon
id|ahc-&gt;enabled_luns
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_MULTI_TID
)paren
op_ne
l_int|0
)paren
(brace
id|u_int
id|targid_mask
suffix:semicolon
id|targid_mask
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|TARGID
)paren
op_or
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|TARGID
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
id|targid_mask
op_or_assign
id|target_mask
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|TARGID
comma
id|targid_mask
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|TARGID
op_plus
l_int|1
comma
(paren
id|targid_mask
op_rshift
l_int|8
)paren
)paren
suffix:semicolon
id|ahc_update_scsiid
c_func
(paren
id|ahc
comma
id|targid_mask
)paren
suffix:semicolon
)brace
r_else
(brace
id|u_int
id|our_id
suffix:semicolon
r_char
id|channel
suffix:semicolon
id|channel
op_assign
id|SIM_CHANNEL
c_func
(paren
id|ahc
comma
id|sim
)paren
suffix:semicolon
id|our_id
op_assign
id|SIM_SCSI_ID
c_func
(paren
id|ahc
comma
id|sim
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * This can only happen if selections&n;&t;&t;&t;&t; * are not enabled&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|target
op_ne
id|our_id
)paren
(brace
id|u_int
id|sblkctl
suffix:semicolon
r_char
id|cur_channel
suffix:semicolon
r_int
id|swap
suffix:semicolon
id|sblkctl
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SBLKCTL
)paren
suffix:semicolon
id|cur_channel
op_assign
(paren
id|sblkctl
op_amp
id|SELBUSB
)paren
ques
c_cond
l_char|&squot;B&squot;
suffix:colon
l_char|&squot;A&squot;
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_TWIN
)paren
op_eq
l_int|0
)paren
id|cur_channel
op_assign
l_char|&squot;A&squot;
suffix:semicolon
id|swap
op_assign
id|cur_channel
op_ne
id|channel
suffix:semicolon
r_if
c_cond
(paren
id|channel
op_eq
l_char|&squot;A&squot;
)paren
id|ahc-&gt;our_id
op_assign
id|target
suffix:semicolon
r_else
id|ahc-&gt;our_id_b
op_assign
id|target
suffix:semicolon
r_if
c_cond
(paren
id|swap
)paren
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SBLKCTL
comma
id|sblkctl
op_xor
id|SELBUSB
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSIID
comma
id|target
)paren
suffix:semicolon
r_if
c_cond
(paren
id|swap
)paren
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SBLKCTL
comma
id|sblkctl
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
id|ahc-&gt;black_hole
op_assign
id|lstate
suffix:semicolon
multiline_comment|/* Allow select-in operations */
r_if
c_cond
(paren
id|ahc-&gt;black_hole
op_ne
l_int|NULL
op_logical_and
id|ahc-&gt;enabled_luns
OG
l_int|0
)paren
(brace
id|scsiseq
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSISEQ_TEMPLATE
)paren
suffix:semicolon
id|scsiseq
op_or_assign
id|ENSELI
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSISEQ_TEMPLATE
comma
id|scsiseq
)paren
suffix:semicolon
id|scsiseq
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSISEQ
)paren
suffix:semicolon
id|scsiseq
op_or_assign
id|ENSELI
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSISEQ
comma
id|scsiseq
)paren
suffix:semicolon
)brace
id|ahc_unpause
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
id|ccb-&gt;ccb_h.status
op_assign
id|CAM_REQ_CMP
suffix:semicolon
id|xpt_print_path
c_func
(paren
id|ccb-&gt;ccb_h.path
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Lun now enabled for target mode&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|scb
op_star
id|scb
suffix:semicolon
r_int
id|i
comma
id|empty
suffix:semicolon
r_if
c_cond
(paren
id|lstate
op_eq
l_int|NULL
)paren
(brace
id|ccb-&gt;ccb_h.status
op_assign
id|CAM_LUN_INVALID
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
id|ccb-&gt;ccb_h.status
op_assign
id|CAM_REQ_CMP
suffix:semicolon
id|LIST_FOREACH
c_func
(paren
id|scb
comma
op_amp
id|ahc-&gt;pending_scbs
comma
id|pending_links
)paren
(brace
r_struct
id|ccb_hdr
op_star
id|ccbh
suffix:semicolon
id|ccbh
op_assign
op_amp
id|scb-&gt;io_ctx-&gt;ccb_h
suffix:semicolon
r_if
c_cond
(paren
id|ccbh-&gt;func_code
op_eq
id|XPT_CONT_TARGET_IO
op_logical_and
op_logical_neg
id|xpt_path_comp
c_func
(paren
id|ccbh-&gt;path
comma
id|ccb-&gt;ccb_h.path
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;CTIO pending&bslash;n&quot;
)paren
suffix:semicolon
id|ccb-&gt;ccb_h.status
op_assign
id|CAM_REQ_INVALID
suffix:semicolon
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|SLIST_FIRST
c_func
(paren
op_amp
id|lstate-&gt;accept_tios
)paren
op_ne
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;ATIOs pending&bslash;n&quot;
)paren
suffix:semicolon
id|ccb-&gt;ccb_h.status
op_assign
id|CAM_REQ_INVALID
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SLIST_FIRST
c_func
(paren
op_amp
id|lstate-&gt;immed_notifies
)paren
op_ne
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;INOTs pending&bslash;n&quot;
)paren
suffix:semicolon
id|ccb-&gt;ccb_h.status
op_assign
id|CAM_REQ_INVALID
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ccb-&gt;ccb_h.status
op_ne
id|CAM_REQ_CMP
)paren
(brace
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|xpt_print_path
c_func
(paren
id|ccb-&gt;ccb_h.path
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Target mode disabled&bslash;n&quot;
)paren
suffix:semicolon
id|xpt_free_path
c_func
(paren
id|lstate-&gt;path
)paren
suffix:semicolon
id|free
c_func
(paren
id|lstate
comma
id|M_DEVBUF
)paren
suffix:semicolon
id|ahc_pause
c_func
(paren
id|ahc
)paren
suffix:semicolon
multiline_comment|/* Can we clean up the target too? */
r_if
c_cond
(paren
id|target
op_ne
id|CAM_TARGET_WILDCARD
)paren
(brace
id|tstate-&gt;enabled_luns
(braket
id|lun
)braket
op_assign
l_int|NULL
suffix:semicolon
id|ahc-&gt;enabled_luns
op_decrement
suffix:semicolon
r_for
c_loop
(paren
id|empty
op_assign
l_int|1
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|tstate-&gt;enabled_luns
(braket
id|i
)braket
op_ne
l_int|NULL
)paren
(brace
id|empty
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|empty
)paren
(brace
id|ahc_free_tstate
c_func
(paren
id|ahc
comma
id|target
comma
id|channel
comma
multiline_comment|/*force*/
id|FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;features
op_amp
id|AHC_MULTI_TID
)paren
(brace
id|u_int
id|targid_mask
suffix:semicolon
id|targid_mask
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|TARGID
)paren
op_or
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|TARGID
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
id|targid_mask
op_and_assign
op_complement
id|target_mask
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|TARGID
comma
id|targid_mask
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|TARGID
op_plus
l_int|1
comma
(paren
id|targid_mask
op_rshift
l_int|8
)paren
)paren
suffix:semicolon
id|ahc_update_scsiid
c_func
(paren
id|ahc
comma
id|targid_mask
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|ahc-&gt;black_hole
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We can&squot;t allow selections without&n;&t;&t;&t; * our black hole device.&n;&t;&t;&t; */
id|empty
op_assign
id|TRUE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ahc-&gt;enabled_luns
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Disallow select-in */
id|u_int
id|scsiseq
suffix:semicolon
id|scsiseq
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSISEQ_TEMPLATE
)paren
suffix:semicolon
id|scsiseq
op_and_assign
op_complement
id|ENSELI
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSISEQ_TEMPLATE
comma
id|scsiseq
)paren
suffix:semicolon
id|scsiseq
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSISEQ
)paren
suffix:semicolon
id|scsiseq
op_and_assign
op_complement
id|ENSELI
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSISEQ
comma
id|scsiseq
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_MULTIROLE
)paren
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Configuring Initiator Mode&bslash;n&quot;
)paren
suffix:semicolon
id|ahc-&gt;flags
op_and_assign
op_complement
id|AHC_TARGETROLE
suffix:semicolon
id|ahc-&gt;flags
op_or_assign
id|AHC_INITIATORROLE
suffix:semicolon
id|ahc_pause
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_loadseq
c_func
(paren
id|ahc
)paren
suffix:semicolon
)brace
)brace
id|ahc_unpause
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|ahc_update_scsiid
id|ahc_update_scsiid
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|u_int
id|targid_mask
)paren
(brace
id|u_int
id|scsiid_mask
suffix:semicolon
id|u_int
id|scsiid
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_MULTI_TID
)paren
op_eq
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;ahc_update_scsiid called on non-multitid unit&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Since we will rely on the TARGID mask&n;&t; * for selection enables, ensure that OID&n;&t; * in SCSIID is not set to some other ID&n;&t; * that we don&squot;t want to allow selections on.&n;&t; */
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_ne
l_int|0
)paren
id|scsiid
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSIID_ULTRA2
)paren
suffix:semicolon
r_else
id|scsiid
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCSIID
)paren
suffix:semicolon
id|scsiid_mask
op_assign
l_int|0x1
op_lshift
(paren
id|scsiid
op_amp
id|OID
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|targid_mask
op_amp
id|scsiid_mask
)paren
op_eq
l_int|0
)paren
(brace
id|u_int
id|our_id
suffix:semicolon
multiline_comment|/* ffs counts from 1 */
id|our_id
op_assign
id|ffs
c_func
(paren
id|targid_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|our_id
op_eq
l_int|0
)paren
id|our_id
op_assign
id|ahc-&gt;our_id
suffix:semicolon
r_else
id|our_id
op_decrement
suffix:semicolon
id|scsiid
op_and_assign
id|TID
suffix:semicolon
id|scsiid
op_or_assign
id|our_id
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_ne
l_int|0
)paren
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSIID_ULTRA2
comma
id|scsiid
)paren
suffix:semicolon
r_else
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSIID
comma
id|scsiid
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahc_run_tqinfifo
id|ahc_run_tqinfifo
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_int
id|paused
)paren
(brace
r_struct
id|target_cmd
op_star
id|cmd
suffix:semicolon
multiline_comment|/*&n;&t; * If the card supports auto-access pause,&n;&t; * we can access the card directly regardless&n;&t; * of whether it is paused or not.&n;&t; */
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_AUTOPAUSE
)paren
op_ne
l_int|0
)paren
id|paused
op_assign
id|TRUE
suffix:semicolon
id|ahc_sync_tqinfifo
c_func
(paren
id|ahc
comma
id|BUS_DMASYNC_POSTREAD
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|cmd
op_assign
op_amp
id|ahc-&gt;targetcmds
(braket
id|ahc-&gt;tqinfifonext
)braket
)paren
op_member_access_from_pointer
id|cmd_valid
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Only advance through the queue if we&n;&t;&t; * have the resources to process the command.&n;&t;&t; */
r_if
c_cond
(paren
id|ahc_handle_target_cmd
c_func
(paren
id|ahc
comma
id|cmd
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
id|cmd-&gt;cmd_valid
op_assign
l_int|0
suffix:semicolon
id|ahc_dmamap_sync
c_func
(paren
id|ahc
comma
id|ahc-&gt;shared_data_dmat
comma
id|ahc-&gt;shared_data_dmamap
comma
id|ahc_targetcmd_offset
c_func
(paren
id|ahc
comma
id|ahc-&gt;tqinfifonext
)paren
comma
r_sizeof
(paren
r_struct
id|target_cmd
)paren
comma
id|BUS_DMASYNC_PREREAD
)paren
suffix:semicolon
id|ahc-&gt;tqinfifonext
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Lazily update our position in the target mode incoming&n;&t;&t; * command queue as seen by the sequencer.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ahc-&gt;tqinfifonext
op_amp
(paren
id|HOST_TQINPOS
op_minus
l_int|1
)paren
)paren
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_HS_MAILBOX
)paren
op_ne
l_int|0
)paren
(brace
id|u_int
id|hs_mailbox
suffix:semicolon
id|hs_mailbox
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|HS_MAILBOX
)paren
suffix:semicolon
id|hs_mailbox
op_and_assign
op_complement
id|HOST_TQINPOS
suffix:semicolon
id|hs_mailbox
op_or_assign
id|ahc-&gt;tqinfifonext
op_amp
id|HOST_TQINPOS
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|HS_MAILBOX
comma
id|hs_mailbox
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|paused
)paren
id|ahc_pause
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|KERNEL_TQINPOS
comma
id|ahc-&gt;tqinfifonext
op_amp
id|HOST_TQINPOS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|paused
)paren
id|ahc_unpause
c_func
(paren
id|ahc
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_static
r_int
DECL|function|ahc_handle_target_cmd
id|ahc_handle_target_cmd
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|target_cmd
op_star
id|cmd
)paren
(brace
r_struct
id|ahc_tmode_tstate
op_star
id|tstate
suffix:semicolon
r_struct
id|ahc_tmode_lstate
op_star
id|lstate
suffix:semicolon
r_struct
id|ccb_accept_tio
op_star
id|atio
suffix:semicolon
r_uint8
op_star
id|byte
suffix:semicolon
r_int
id|initiator
suffix:semicolon
r_int
id|target
suffix:semicolon
r_int
id|lun
suffix:semicolon
id|initiator
op_assign
id|SCSIID_TARGET
c_func
(paren
id|ahc
comma
id|cmd-&gt;scsiid
)paren
suffix:semicolon
id|target
op_assign
id|SCSIID_OUR_ID
c_func
(paren
id|cmd-&gt;scsiid
)paren
suffix:semicolon
id|lun
op_assign
(paren
id|cmd-&gt;identify
op_amp
id|MSG_IDENTIFY_LUNMASK
)paren
suffix:semicolon
id|byte
op_assign
id|cmd-&gt;bytes
suffix:semicolon
id|tstate
op_assign
id|ahc-&gt;enabled_targets
(braket
id|target
)braket
suffix:semicolon
id|lstate
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|tstate
op_ne
l_int|NULL
)paren
id|lstate
op_assign
id|tstate-&gt;enabled_luns
(braket
id|lun
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Commands for disabled luns go to the black hole driver.&n;&t; */
r_if
c_cond
(paren
id|lstate
op_eq
l_int|NULL
)paren
id|lstate
op_assign
id|ahc-&gt;black_hole
suffix:semicolon
id|atio
op_assign
(paren
r_struct
id|ccb_accept_tio
op_star
)paren
id|SLIST_FIRST
c_func
(paren
op_amp
id|lstate-&gt;accept_tios
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atio
op_eq
l_int|NULL
)paren
(brace
id|ahc-&gt;flags
op_or_assign
id|AHC_TQINFIFO_BLOCKED
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Wait for more ATIOs from the peripheral driver for this lun.&n;&t;&t; */
r_if
c_cond
(paren
id|bootverbose
)paren
id|printf
c_func
(paren
l_string|&quot;%s: ATIOs exhausted&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_else
id|ahc-&gt;flags
op_and_assign
op_complement
id|AHC_TQINFIFO_BLOCKED
suffix:semicolon
macro_line|#if 0
id|printf
c_func
(paren
l_string|&quot;Incoming command from %d for %d:%d%s&bslash;n&quot;
comma
id|initiator
comma
id|target
comma
id|lun
comma
id|lstate
op_eq
id|ahc-&gt;black_hole
ques
c_cond
l_string|&quot;(Black Holed)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
macro_line|#endif
id|SLIST_REMOVE_HEAD
c_func
(paren
op_amp
id|lstate-&gt;accept_tios
comma
id|sim_links.sle
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lstate
op_eq
id|ahc-&gt;black_hole
)paren
(brace
multiline_comment|/* Fill in the wildcards */
id|atio-&gt;ccb_h.target_id
op_assign
id|target
suffix:semicolon
id|atio-&gt;ccb_h.target_lun
op_assign
id|lun
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Package it up and send it off to&n;&t; * whomever has this lun enabled.&n;&t; */
id|atio-&gt;sense_len
op_assign
l_int|0
suffix:semicolon
id|atio-&gt;init_id
op_assign
id|initiator
suffix:semicolon
r_if
c_cond
(paren
id|byte
(braket
l_int|0
)braket
op_ne
l_int|0xFF
)paren
(brace
multiline_comment|/* Tag was included */
id|atio-&gt;tag_action
op_assign
op_star
id|byte
op_increment
suffix:semicolon
id|atio-&gt;tag_id
op_assign
op_star
id|byte
op_increment
suffix:semicolon
id|atio-&gt;ccb_h.flags
op_assign
id|CAM_TAG_ACTION_VALID
suffix:semicolon
)brace
r_else
(brace
id|atio-&gt;ccb_h.flags
op_assign
l_int|0
suffix:semicolon
)brace
id|byte
op_increment
suffix:semicolon
multiline_comment|/* Okay.  Now determine the cdb size based on the command code */
r_switch
c_cond
(paren
op_star
id|byte
op_rshift
id|CMD_GROUP_CODE_SHIFT
)paren
(brace
r_case
l_int|0
suffix:colon
id|atio-&gt;cdb_len
op_assign
l_int|6
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
r_case
l_int|2
suffix:colon
id|atio-&gt;cdb_len
op_assign
l_int|10
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|atio-&gt;cdb_len
op_assign
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|atio-&gt;cdb_len
op_assign
l_int|12
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
r_default
suffix:colon
multiline_comment|/* Only copy the opcode. */
id|atio-&gt;cdb_len
op_assign
l_int|1
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Reserved or VU command code type encountered&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|atio-&gt;cdb_io.cdb_bytes
comma
id|byte
comma
id|atio-&gt;cdb_len
)paren
suffix:semicolon
id|atio-&gt;ccb_h.status
op_or_assign
id|CAM_CDB_RECVD
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmd-&gt;identify
op_amp
id|MSG_IDENTIFY_DISCFLAG
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * We weren&squot;t allowed to disconnect.&n;&t;&t; * We&squot;re hanging on the bus until a&n;&t;&t; * continue target I/O comes in response&n;&t;&t; * to this accept tio.&n;&t;&t; */
macro_line|#if 0
id|printf
c_func
(paren
l_string|&quot;Received Immediate Command %d:%d:%d - %p&bslash;n&quot;
comma
id|initiator
comma
id|target
comma
id|lun
comma
id|ahc-&gt;pending_device
)paren
suffix:semicolon
macro_line|#endif
id|ahc-&gt;pending_device
op_assign
id|lstate
suffix:semicolon
id|ahc_freeze_ccb
c_func
(paren
(paren
r_union
id|ccb
op_star
)paren
id|atio
)paren
suffix:semicolon
id|atio-&gt;ccb_h.flags
op_or_assign
id|CAM_DIS_DISCONNECT
suffix:semicolon
)brace
id|xpt_done
c_func
(paren
(paren
r_union
id|ccb
op_star
)paren
id|atio
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
