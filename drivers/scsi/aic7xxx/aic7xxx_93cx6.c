multiline_comment|/*&n; * Interface for the 93C66/56/46/26/06 serial eeprom parts.&n; *&n; * Copyright (c) 1995, 1996 Daniel M. Eischen&n; * All rights reserved.&n; *&n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions&n; * are met:&n; * 1. Redistributions of source code must retain the above copyright&n; *    notice, this list of conditions, and the following disclaimer,&n; *    without modification.&n; * 2. The name of the author may not be used to endorse or promote products&n; *    derived from this software without specific prior written permission.&n; *&n; * Alternatively, this software may be distributed under the terms of the&n; * GNU General Public License (&quot;GPL&quot;).&n; *&n; * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&squot;&squot; AND&n; * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE&n; * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE&n; * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR&n; * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL&n; * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS&n; * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)&n; * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT&n; * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY&n; * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF&n; * SUCH DAMAGE.&n; *&n; * $Id: //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.c#17 $&n; *&n; * $FreeBSD$&n; */
multiline_comment|/*&n; *   The instruction set of the 93C66/56/46/26/06 chips are as follows:&n; *&n; *               Start  OP&t;    *&n; *     Function   Bit  Code  Address**  Data     Description&n; *     -------------------------------------------------------------------&n; *     READ        1    10   A5 - A0             Reads data stored in memory,&n; *                                               starting at specified address&n; *     EWEN        1    00   11XXXX              Write enable must precede&n; *                                               all programming modes&n; *     ERASE       1    11   A5 - A0             Erase register A5A4A3A2A1A0&n; *     WRITE       1    01   A5 - A0   D15 - D0  Writes register&n; *     ERAL        1    00   10XXXX              Erase all registers&n; *     WRAL        1    00   01XXXX    D15 - D0  Writes to all registers&n; *     EWDS        1    00   00XXXX              Disables all programming&n; *                                               instructions&n; *     *Note: A value of X for address is a don&squot;t care condition.&n; *    **Note: There are 8 address bits for the 93C56/66 chips unlike&n; *&t;      the 93C46/26/06 chips which have 6 address bits.&n; *&n; *   The 93C46 has a four wire interface: clock, chip select, data in, and&n; *   data out.  In order to perform one of the above functions, you need&n; *   to enable the chip select for a clock period (typically a minimum of&n; *   1 usec, with the clock high and low a minimum of 750 and 250 nsec&n; *   respectively).  While the chip select remains high, you can clock in&n; *   the instructions (above) starting with the start bit, followed by the&n; *   OP code, Address, and Data (if needed).  For the READ instruction, the&n; *   requested 16-bit register contents is read from the data out line but&n; *   is preceded by an initial zero (leading 0, followed by 16-bits, MSB&n; *   first).  The clock cycling from low to high initiates the next data&n; *   bit to be sent from the chip.&n; *&n; */
macro_line|#ifdef __linux__
macro_line|#include &quot;aic7xxx_osm.h&quot;
macro_line|#include &quot;aic7xxx_inline.h&quot;
macro_line|#include &quot;aic7xxx_93cx6.h&quot;
macro_line|#else
macro_line|#include &lt;dev/aic7xxx/aic7xxx_osm.h&gt;
macro_line|#include &lt;dev/aic7xxx/aic7xxx_inline.h&gt;
macro_line|#include &lt;dev/aic7xxx/aic7xxx_93cx6.h&gt;
macro_line|#endif
multiline_comment|/*&n; * Right now, we only have to read the SEEPROM.  But we make it easier to&n; * add other 93Cx6 functions.&n; */
DECL|struct|seeprom_cmd
r_static
r_struct
id|seeprom_cmd
(brace
DECL|member|len
r_uint8
id|len
suffix:semicolon
DECL|member|bits
r_uint8
id|bits
(braket
l_int|9
)braket
suffix:semicolon
DECL|variable|seeprom_read
)brace
id|seeprom_read
op_assign
(brace
l_int|3
comma
(brace
l_int|1
comma
l_int|1
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|seeprom_ewen
r_static
r_struct
id|seeprom_cmd
id|seeprom_ewen
op_assign
(brace
l_int|9
comma
(brace
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|seeprom_ewds
r_static
r_struct
id|seeprom_cmd
id|seeprom_ewds
op_assign
(brace
l_int|9
comma
(brace
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|seeprom_write
r_static
r_struct
id|seeprom_cmd
id|seeprom_write
op_assign
(brace
l_int|3
comma
(brace
l_int|1
comma
l_int|0
comma
l_int|1
)brace
)brace
suffix:semicolon
multiline_comment|/*&n; * Wait for the SEERDY to go high; about 800 ns.&n; */
DECL|macro|CLOCK_PULSE
mdefine_line|#define CLOCK_PULSE(sd, rdy)&t;&t;&t;&t;&bslash;&n;&t;while ((SEEPROM_STATUS_INB(sd) &amp; rdy) == 0) {&t;&bslash;&n;&t;&t;;  /* Do nothing */&t;&t;&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&bslash;&n;&t;(void)SEEPROM_INB(sd);&t;/* Clear clock */
multiline_comment|/*&n; * Send a START condition and the given command&n; */
r_static
r_void
DECL|function|send_seeprom_cmd
id|send_seeprom_cmd
c_func
(paren
r_struct
id|seeprom_descriptor
op_star
id|sd
comma
r_struct
id|seeprom_cmd
op_star
id|cmd
)paren
(brace
r_uint8
id|temp
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Send chip select for one clock cycle. */
id|temp
op_assign
id|sd-&gt;sd_MS
op_xor
id|sd-&gt;sd_CS
suffix:semicolon
id|SEEPROM_OUTB
c_func
(paren
id|sd
comma
id|temp
op_xor
id|sd-&gt;sd_CK
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|sd
comma
id|sd-&gt;sd_RDY
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cmd-&gt;len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cmd-&gt;bits
(braket
id|i
)braket
op_ne
l_int|0
)paren
id|temp
op_xor_assign
id|sd-&gt;sd_DO
suffix:semicolon
id|SEEPROM_OUTB
c_func
(paren
id|sd
comma
id|temp
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|sd
comma
id|sd-&gt;sd_RDY
)paren
suffix:semicolon
id|SEEPROM_OUTB
c_func
(paren
id|sd
comma
id|temp
op_xor
id|sd-&gt;sd_CK
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|sd
comma
id|sd-&gt;sd_RDY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;bits
(braket
id|i
)braket
op_ne
l_int|0
)paren
id|temp
op_xor_assign
id|sd-&gt;sd_DO
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Clear CS put the chip in the reset state, where it can wait for new commands.&n; */
r_static
r_void
DECL|function|reset_seeprom
id|reset_seeprom
c_func
(paren
r_struct
id|seeprom_descriptor
op_star
id|sd
)paren
(brace
r_uint8
id|temp
suffix:semicolon
id|temp
op_assign
id|sd-&gt;sd_MS
suffix:semicolon
id|SEEPROM_OUTB
c_func
(paren
id|sd
comma
id|temp
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|sd
comma
id|sd-&gt;sd_RDY
)paren
suffix:semicolon
id|SEEPROM_OUTB
c_func
(paren
id|sd
comma
id|temp
op_xor
id|sd-&gt;sd_CK
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|sd
comma
id|sd-&gt;sd_RDY
)paren
suffix:semicolon
id|SEEPROM_OUTB
c_func
(paren
id|sd
comma
id|temp
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|sd
comma
id|sd-&gt;sd_RDY
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Read the serial EEPROM and returns 1 if successful and 0 if&n; * not successful.&n; */
r_int
DECL|function|ahc_read_seeprom
id|ahc_read_seeprom
c_func
(paren
r_struct
id|seeprom_descriptor
op_star
id|sd
comma
r_uint16
op_star
id|buf
comma
id|u_int
id|start_addr
comma
id|u_int
id|count
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|u_int
id|k
op_assign
l_int|0
suffix:semicolon
r_uint16
id|v
suffix:semicolon
r_uint8
id|temp
suffix:semicolon
multiline_comment|/*&n;&t; * Read the requested registers of the seeprom.  The loop&n;&t; * will range from 0 to count-1.&n;&t; */
r_for
c_loop
(paren
id|k
op_assign
id|start_addr
suffix:semicolon
id|k
OL
id|count
op_plus
id|start_addr
suffix:semicolon
id|k
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * Now we&squot;re ready to send the read command followed by the&n;&t;&t; * address of the 16-bit register we want to read.&n;&t;&t; */
id|send_seeprom_cmd
c_func
(paren
id|sd
comma
op_amp
id|seeprom_read
)paren
suffix:semicolon
multiline_comment|/* Send the 6 or 8 bit address (MSB first, LSB last). */
id|temp
op_assign
id|sd-&gt;sd_MS
op_xor
id|sd-&gt;sd_CS
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
(paren
id|sd-&gt;sd_chip
op_minus
l_int|1
)paren
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
(paren
id|k
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
op_ne
l_int|0
)paren
id|temp
op_xor_assign
id|sd-&gt;sd_DO
suffix:semicolon
id|SEEPROM_OUTB
c_func
(paren
id|sd
comma
id|temp
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|sd
comma
id|sd-&gt;sd_RDY
)paren
suffix:semicolon
id|SEEPROM_OUTB
c_func
(paren
id|sd
comma
id|temp
op_xor
id|sd-&gt;sd_CK
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|sd
comma
id|sd-&gt;sd_RDY
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|k
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
op_ne
l_int|0
)paren
id|temp
op_xor_assign
id|sd-&gt;sd_DO
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Now read the 16 bit register.  An initial 0 precedes the&n;&t;&t; * register contents which begins with bit 15 (MSB) and ends&n;&t;&t; * with bit 0 (LSB).  The initial 0 will be shifted off the&n;&t;&t; * top of our word as we let the loop run from 0 to 16.&n;&t;&t; */
id|v
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|16
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|SEEPROM_OUTB
c_func
(paren
id|sd
comma
id|temp
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|sd
comma
id|sd-&gt;sd_RDY
)paren
suffix:semicolon
id|v
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|SEEPROM_DATA_INB
c_func
(paren
id|sd
)paren
op_amp
id|sd-&gt;sd_DI
)paren
id|v
op_or_assign
l_int|1
suffix:semicolon
id|SEEPROM_OUTB
c_func
(paren
id|sd
comma
id|temp
op_xor
id|sd-&gt;sd_CK
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|sd
comma
id|sd-&gt;sd_RDY
)paren
suffix:semicolon
)brace
id|buf
(braket
id|k
op_minus
id|start_addr
)braket
op_assign
id|v
suffix:semicolon
multiline_comment|/* Reset the chip select for the next command cycle. */
id|reset_seeprom
c_func
(paren
id|sd
)paren
suffix:semicolon
)brace
macro_line|#ifdef AHC_DUMP_EEPROM
id|printf
c_func
(paren
l_string|&quot;&bslash;nSerial EEPROM:&bslash;n&bslash;t&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|count
suffix:semicolon
id|k
op_assign
id|k
op_plus
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|k
op_mod
l_int|8
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|k
op_ne
l_int|0
)paren
)paren
(brace
id|printf
(paren
l_string|&quot;&bslash;n&bslash;t&quot;
)paren
suffix:semicolon
)brace
id|printf
(paren
l_string|&quot; 0x%x&quot;
comma
id|buf
(braket
id|k
)braket
)paren
suffix:semicolon
)brace
id|printf
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Write the serial EEPROM and return 1 if successful and 0 if&n; * not successful.&n; */
r_int
DECL|function|ahc_write_seeprom
id|ahc_write_seeprom
c_func
(paren
r_struct
id|seeprom_descriptor
op_star
id|sd
comma
r_uint16
op_star
id|buf
comma
id|u_int
id|start_addr
comma
id|u_int
id|count
)paren
(brace
r_uint16
id|v
suffix:semicolon
r_uint8
id|temp
suffix:semicolon
r_int
id|i
comma
id|k
suffix:semicolon
multiline_comment|/* Place the chip into write-enable mode */
id|send_seeprom_cmd
c_func
(paren
id|sd
comma
op_amp
id|seeprom_ewen
)paren
suffix:semicolon
id|reset_seeprom
c_func
(paren
id|sd
)paren
suffix:semicolon
multiline_comment|/* Write all requested data out to the seeprom. */
id|temp
op_assign
id|sd-&gt;sd_MS
op_xor
id|sd-&gt;sd_CS
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
id|start_addr
suffix:semicolon
id|k
OL
id|count
op_plus
id|start_addr
suffix:semicolon
id|k
op_increment
)paren
(brace
multiline_comment|/* Send the write command */
id|send_seeprom_cmd
c_func
(paren
id|sd
comma
op_amp
id|seeprom_write
)paren
suffix:semicolon
multiline_comment|/* Send the 6 or 8 bit address (MSB first). */
r_for
c_loop
(paren
id|i
op_assign
(paren
id|sd-&gt;sd_chip
op_minus
l_int|1
)paren
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
(paren
id|k
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
op_ne
l_int|0
)paren
id|temp
op_xor_assign
id|sd-&gt;sd_DO
suffix:semicolon
id|SEEPROM_OUTB
c_func
(paren
id|sd
comma
id|temp
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|sd
comma
id|sd-&gt;sd_RDY
)paren
suffix:semicolon
id|SEEPROM_OUTB
c_func
(paren
id|sd
comma
id|temp
op_xor
id|sd-&gt;sd_CK
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|sd
comma
id|sd-&gt;sd_RDY
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|k
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
op_ne
l_int|0
)paren
id|temp
op_xor_assign
id|sd-&gt;sd_DO
suffix:semicolon
)brace
multiline_comment|/* Write the 16 bit value, MSB first */
id|v
op_assign
id|buf
(braket
id|k
op_minus
id|start_addr
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|15
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
(paren
id|v
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
op_ne
l_int|0
)paren
id|temp
op_xor_assign
id|sd-&gt;sd_DO
suffix:semicolon
id|SEEPROM_OUTB
c_func
(paren
id|sd
comma
id|temp
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|sd
comma
id|sd-&gt;sd_RDY
)paren
suffix:semicolon
id|SEEPROM_OUTB
c_func
(paren
id|sd
comma
id|temp
op_xor
id|sd-&gt;sd_CK
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|sd
comma
id|sd-&gt;sd_RDY
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|v
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
op_ne
l_int|0
)paren
id|temp
op_xor_assign
id|sd-&gt;sd_DO
suffix:semicolon
)brace
multiline_comment|/* Wait for the chip to complete the write */
id|temp
op_assign
id|sd-&gt;sd_MS
suffix:semicolon
id|SEEPROM_OUTB
c_func
(paren
id|sd
comma
id|temp
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|sd
comma
id|sd-&gt;sd_RDY
)paren
suffix:semicolon
id|temp
op_assign
id|sd-&gt;sd_MS
op_xor
id|sd-&gt;sd_CS
suffix:semicolon
r_do
(brace
id|SEEPROM_OUTB
c_func
(paren
id|sd
comma
id|temp
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|sd
comma
id|sd-&gt;sd_RDY
)paren
suffix:semicolon
id|SEEPROM_OUTB
c_func
(paren
id|sd
comma
id|temp
op_xor
id|sd-&gt;sd_CK
)paren
suffix:semicolon
id|CLOCK_PULSE
c_func
(paren
id|sd
comma
id|sd-&gt;sd_RDY
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|SEEPROM_DATA_INB
c_func
(paren
id|sd
)paren
op_amp
id|sd-&gt;sd_DI
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|reset_seeprom
c_func
(paren
id|sd
)paren
suffix:semicolon
)brace
multiline_comment|/* Put the chip back into write-protect mode */
id|send_seeprom_cmd
c_func
(paren
id|sd
comma
op_amp
id|seeprom_ewds
)paren
suffix:semicolon
id|reset_seeprom
c_func
(paren
id|sd
)paren
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_int
DECL|function|ahc_verify_cksum
id|ahc_verify_cksum
c_func
(paren
r_struct
id|seeprom_config
op_star
id|sc
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|maxaddr
suffix:semicolon
r_uint32
id|checksum
suffix:semicolon
r_uint16
op_star
id|scarray
suffix:semicolon
id|maxaddr
op_assign
(paren
r_sizeof
(paren
op_star
id|sc
)paren
op_div
l_int|2
)paren
op_minus
l_int|1
suffix:semicolon
id|checksum
op_assign
l_int|0
suffix:semicolon
id|scarray
op_assign
(paren
r_uint16
op_star
)paren
id|sc
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|maxaddr
suffix:semicolon
id|i
op_increment
)paren
id|checksum
op_assign
id|checksum
op_plus
id|scarray
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|checksum
op_eq
l_int|0
op_logical_or
(paren
id|checksum
op_amp
l_int|0xFFFF
)paren
op_ne
id|sc-&gt;checksum
)paren
(brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|1
suffix:semicolon
)brace
)brace
eof
