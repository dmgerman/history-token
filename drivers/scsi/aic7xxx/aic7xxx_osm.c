multiline_comment|/*&n; * Adaptec AIC7xxx device driver for Linux.&n; *&n; * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#235 $&n; *&n; * Copyright (c) 1994 John Aycock&n; *   The University of Calgary Department of Computer Science.&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; see the file COPYING.  If not, write to&n; * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; * Sources include the Adaptec 1740 driver (aha1740.c), the Ultrastor 24F&n; * driver (ultrastor.c), various Linux kernel source, the Adaptec EISA&n; * config file (!adp7771.cfg), the Adaptec AHA-2740A Series User&squot;s Guide,&n; * the Linux Kernel Hacker&squot;s Guide, Writing a SCSI Device Driver for Linux,&n; * the Adaptec 1542 driver (aha1542.c), the Adaptec EISA overlay file&n; * (adp7770.ovl), the Adaptec AHA-2740 Series Technical Reference Manual,&n; * the Adaptec AIC-7770 Data Book, the ANSI SCSI specification, the&n; * ANSI SCSI-2 specification (draft 10c), ...&n; *&n; * --------------------------------------------------------------------------&n; *&n; *  Modifications by Daniel M. Eischen (deischen@iworks.InterWorks.org):&n; *&n; *  Substantially modified to include support for wide and twin bus&n; *  adapters, DMAing of SCBs, tagged queueing, IRQ sharing, bug fixes,&n; *  SCB paging, and other rework of the code.&n; *&n; * --------------------------------------------------------------------------&n; * Copyright (c) 1994-2000 Justin T. Gibbs.&n; * Copyright (c) 2000-2001 Adaptec Inc.&n; * All rights reserved.&n; *&n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions&n; * are met:&n; * 1. Redistributions of source code must retain the above copyright&n; *    notice, this list of conditions, and the following disclaimer,&n; *    without modification.&n; * 2. Redistributions in binary form must reproduce at minimum a disclaimer&n; *    substantially similar to the &quot;NO WARRANTY&quot; disclaimer below&n; *    (&quot;Disclaimer&quot;) and any redistribution must be conditioned upon&n; *    including a substantially similar Disclaimer requirement for further&n; *    binary redistribution.&n; * 3. Neither the names of the above-listed copyright holders nor the names&n; *    of any contributors may be used to endorse or promote products derived&n; *    from this software without specific prior written permission.&n; *&n; * Alternatively, this software may be distributed under the terms of the&n; * GNU General Public License (&quot;GPL&quot;) version 2 as published by the Free&n; * Software Foundation.&n; *&n; * NO WARRANTY&n; * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS&n; * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT&n; * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR&n; * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT&n; * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL&n; * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS&n; * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)&n; * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,&n; * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING&n; * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE&n; * POSSIBILITY OF SUCH DAMAGES.&n; *&n; *---------------------------------------------------------------------------&n; *&n; *  Thanks also go to (in alphabetical order) the following:&n; *&n; *    Rory Bolt     - Sequencer bug fixes&n; *    Jay Estabrook - Initial DEC Alpha support&n; *    Doug Ledford  - Much needed abort/reset bug fixes&n; *    Kai Makisara  - DMAing of SCBs&n; *&n; *  A Boot time option was also added for not resetting the scsi bus.&n; *&n; *    Form:  aic7xxx=extended&n; *           aic7xxx=no_reset&n; *           aic7xxx=verbose&n; *&n; *  Daniel M. Eischen, deischen@iworks.InterWorks.org, 1/23/97&n; *&n; *  Id: aic7xxx.c,v 4.1 1997/06/12 08:23:42 deang Exp&n; */
multiline_comment|/*&n; * Further driver modifications made by Doug Ledford &lt;dledford@redhat.com&gt;&n; *&n; * Copyright (c) 1997-1999 Doug Ledford&n; *&n; * These changes are released under the same licensing terms as the FreeBSD&n; * driver written by Justin Gibbs.  Please see his Copyright notice above&n; * for the exact terms and conditions covering my changes as well as the&n; * warranty statement.&n; *&n; * Modifications made to the aic7xxx.c,v 4.1 driver from Dan Eischen include&n; * but are not limited to:&n; *&n; *  1: Import of the latest FreeBSD sequencer code for this driver&n; *  2: Modification of kernel code to accommodate different sequencer semantics&n; *  3: Extensive changes throughout kernel portion of driver to improve&n; *     abort/reset processing and error hanndling&n; *  4: Other work contributed by various people on the Internet&n; *  5: Changes to printk information and verbosity selection code&n; *  6: General reliability related changes, especially in IRQ management&n; *  7: Modifications to the default probe/attach order for supported cards&n; *  8: SMP friendliness has been improved&n; *&n; */
macro_line|#include &quot;aic7xxx_osm.h&quot;
macro_line|#include &quot;aic7xxx_inline.h&quot;
macro_line|#include &lt;scsi/scsicam.h&gt;
multiline_comment|/*&n; * Include aiclib.c as part of our&n; * &quot;module dependencies are hard&quot; work around.&n; */
macro_line|#include &quot;aiclib.c&quot;
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,3,0)
macro_line|#include &lt;linux/init.h&gt;&t;&t;/* __setup */
macro_line|#endif
macro_line|#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,5,0)
macro_line|#include &quot;sd.h&quot;&t;&t;&t;/* For geometry detection */
macro_line|#endif
macro_line|#include &lt;linux/mm.h&gt;&t;&t;/* For fetching system memory size */
macro_line|#include &lt;linux/blkdev.h&gt;&t;&t;/* For block_size() */
multiline_comment|/*&n; * Lock protecting manipulation of the ahc softc list.&n; */
DECL|variable|ahc_list_spinlock
id|spinlock_t
id|ahc_list_spinlock
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,5,0)
multiline_comment|/* For dynamic sglist size calculation. */
DECL|variable|ahc_linux_nseg
id|u_int
id|ahc_linux_nseg
suffix:semicolon
macro_line|#endif
macro_line|#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,3,0)
DECL|variable|proc_scsi_aic7xxx
r_struct
id|proc_dir_entry
id|proc_scsi_aic7xxx
op_assign
(brace
id|PROC_SCSI_AIC7XXX
comma
l_int|7
comma
l_string|&quot;aic7xxx&quot;
comma
id|S_IFDIR
op_or
id|S_IRUGO
op_or
id|S_IXUGO
comma
l_int|2
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Set this to the delay in seconds after SCSI bus reset.&n; * Note, we honor this only for the initial bus reset.&n; * The scsi error recovery code performs its own bus settle&n; * delay handling for error recovery actions.&n; */
macro_line|#ifdef CONFIG_AIC7XXX_RESET_DELAY_MS
DECL|macro|AIC7XXX_RESET_DELAY
mdefine_line|#define AIC7XXX_RESET_DELAY CONFIG_AIC7XXX_RESET_DELAY_MS
macro_line|#else
DECL|macro|AIC7XXX_RESET_DELAY
mdefine_line|#define AIC7XXX_RESET_DELAY 5000
macro_line|#endif
multiline_comment|/*&n; * Control collection of SCSI transfer statistics for the /proc filesystem.&n; *&n; * NOTE: Do NOT enable this when running on kernels version 1.2.x and below.&n; * NOTE: This does affect performance since it has to maintain statistics.&n; */
macro_line|#ifdef CONFIG_AIC7XXX_PROC_STATS
DECL|macro|AIC7XXX_PROC_STATS
mdefine_line|#define AIC7XXX_PROC_STATS
macro_line|#endif
multiline_comment|/*&n; * To change the default number of tagged transactions allowed per-device,&n; * add a line to the lilo.conf file like:&n; * append=&quot;aic7xxx=verbose,tag_info:{{32,32,32,32},{32,32,32,32}}&quot;&n; * which will result in the first four devices on the first two&n; * controllers being set to a tagged queue depth of 32.&n; *&n; * The tag_commands is an array of 16 to allow for wide and twin adapters.&n; * Twin adapters will use indexes 0-7 for channel 0, and indexes 8-15&n; * for channel 1.&n; */
r_typedef
r_struct
(brace
DECL|member|tag_commands
r_uint8
id|tag_commands
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* Allow for wide/twin adapters. */
DECL|typedef|adapter_tag_info_t
)brace
id|adapter_tag_info_t
suffix:semicolon
multiline_comment|/*&n; * Modify this as you see fit for your system.&n; *&n; * 0&t;&t;&t;tagged queuing disabled&n; * 1 &lt;= n &lt;= 253&t;n == max tags ever dispatched.&n; *&n; * The driver will throttle the number of commands dispatched to a&n; * device if it returns queue full.  For devices with a fixed maximum&n; * queue depth, the driver will eventually determine this depth and&n; * lock it in (a console message is printed to indicate that a lock&n; * has occurred).  On some devices, queue full is returned for a temporary&n; * resource shortage.  These devices will return queue full at varying&n; * depths.  The driver will throttle back when the queue fulls occur and&n; * attempt to slowly increase the depth over time as the device recovers&n; * from the resource shortage.&n; *&n; * In this example, the first line will disable tagged queueing for all&n; * the devices on the first probed aic7xxx adapter.&n; *&n; * The second line enables tagged queueing with 4 commands/LUN for IDs&n; * (0, 2-11, 13-15), disables tagged queueing for ID 12, and tells the&n; * driver to attempt to use up to 64 tags for ID 1.&n; *&n; * The third line is the same as the first line.&n; *&n; * The fourth line disables tagged queueing for devices 0 and 3.  It&n; * enables tagged queueing for the other IDs, with 16 commands/LUN&n; * for IDs 1 and 4, 127 commands/LUN for ID 8, and 4 commands/LUN for&n; * IDs 2, 5-7, and 9-15.&n; */
multiline_comment|/*&n; * NOTE: The below structure is for reference only, the actual structure&n; *       to modify in order to change things is just below this comment block.&n;adapter_tag_info_t aic7xxx_tag_info[] =&n;{&n;&t;{{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},&n;&t;{{4, 64, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 4, 4, 4}},&n;&t;{{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},&n;&t;{{0, 16, 4, 0, 16, 4, 4, 4, 127, 4, 4, 4, 4, 4, 4, 4}}&n;};&n;*/
macro_line|#ifdef CONFIG_AIC7XXX_CMDS_PER_DEVICE
DECL|macro|AIC7XXX_CMDS_PER_DEVICE
mdefine_line|#define AIC7XXX_CMDS_PER_DEVICE CONFIG_AIC7XXX_CMDS_PER_DEVICE
macro_line|#else
DECL|macro|AIC7XXX_CMDS_PER_DEVICE
mdefine_line|#define AIC7XXX_CMDS_PER_DEVICE AHC_MAX_QUEUE
macro_line|#endif
DECL|macro|AIC7XXX_CONFIGED_TAG_COMMANDS
mdefine_line|#define AIC7XXX_CONFIGED_TAG_COMMANDS {&t;&t;&t;&t;&t;&bslash;&n;&t;AIC7XXX_CMDS_PER_DEVICE, AIC7XXX_CMDS_PER_DEVICE,&t;&t;&bslash;&n;&t;AIC7XXX_CMDS_PER_DEVICE, AIC7XXX_CMDS_PER_DEVICE,&t;&t;&bslash;&n;&t;AIC7XXX_CMDS_PER_DEVICE, AIC7XXX_CMDS_PER_DEVICE,&t;&t;&bslash;&n;&t;AIC7XXX_CMDS_PER_DEVICE, AIC7XXX_CMDS_PER_DEVICE,&t;&t;&bslash;&n;&t;AIC7XXX_CMDS_PER_DEVICE, AIC7XXX_CMDS_PER_DEVICE,&t;&t;&bslash;&n;&t;AIC7XXX_CMDS_PER_DEVICE, AIC7XXX_CMDS_PER_DEVICE,&t;&t;&bslash;&n;&t;AIC7XXX_CMDS_PER_DEVICE, AIC7XXX_CMDS_PER_DEVICE,&t;&t;&bslash;&n;&t;AIC7XXX_CMDS_PER_DEVICE, AIC7XXX_CMDS_PER_DEVICE&t;&t;&bslash;&n;}
multiline_comment|/*&n; * By default, use the number of commands specified by&n; * the users kernel configuration.&n; */
DECL|variable|aic7xxx_tag_info
r_static
id|adapter_tag_info_t
id|aic7xxx_tag_info
(braket
)braket
op_assign
(brace
(brace
id|AIC7XXX_CONFIGED_TAG_COMMANDS
)brace
comma
(brace
id|AIC7XXX_CONFIGED_TAG_COMMANDS
)brace
comma
(brace
id|AIC7XXX_CONFIGED_TAG_COMMANDS
)brace
comma
(brace
id|AIC7XXX_CONFIGED_TAG_COMMANDS
)brace
comma
(brace
id|AIC7XXX_CONFIGED_TAG_COMMANDS
)brace
comma
(brace
id|AIC7XXX_CONFIGED_TAG_COMMANDS
)brace
comma
(brace
id|AIC7XXX_CONFIGED_TAG_COMMANDS
)brace
comma
(brace
id|AIC7XXX_CONFIGED_TAG_COMMANDS
)brace
comma
(brace
id|AIC7XXX_CONFIGED_TAG_COMMANDS
)brace
comma
(brace
id|AIC7XXX_CONFIGED_TAG_COMMANDS
)brace
comma
(brace
id|AIC7XXX_CONFIGED_TAG_COMMANDS
)brace
comma
(brace
id|AIC7XXX_CONFIGED_TAG_COMMANDS
)brace
comma
(brace
id|AIC7XXX_CONFIGED_TAG_COMMANDS
)brace
comma
(brace
id|AIC7XXX_CONFIGED_TAG_COMMANDS
)brace
comma
(brace
id|AIC7XXX_CONFIGED_TAG_COMMANDS
)brace
comma
(brace
id|AIC7XXX_CONFIGED_TAG_COMMANDS
)brace
)brace
suffix:semicolon
multiline_comment|/*&n; * DV option:&n; *&n; * positive value = DV Enabled&n; * zero&t;&t;  = DV Disabled&n; * negative value = DV Default for adapter type/seeprom&n; */
macro_line|#ifdef CONFIG_AIC7XXX_DV_SETTING
DECL|macro|AIC7XXX_CONFIGED_DV
mdefine_line|#define AIC7XXX_CONFIGED_DV CONFIG_AIC7XXX_DV_SETTING
macro_line|#else
DECL|macro|AIC7XXX_CONFIGED_DV
mdefine_line|#define AIC7XXX_CONFIGED_DV -1
macro_line|#endif
DECL|variable|aic7xxx_dv_settings
r_static
r_int8
id|aic7xxx_dv_settings
(braket
)braket
op_assign
(brace
id|AIC7XXX_CONFIGED_DV
comma
id|AIC7XXX_CONFIGED_DV
comma
id|AIC7XXX_CONFIGED_DV
comma
id|AIC7XXX_CONFIGED_DV
comma
id|AIC7XXX_CONFIGED_DV
comma
id|AIC7XXX_CONFIGED_DV
comma
id|AIC7XXX_CONFIGED_DV
comma
id|AIC7XXX_CONFIGED_DV
comma
id|AIC7XXX_CONFIGED_DV
comma
id|AIC7XXX_CONFIGED_DV
comma
id|AIC7XXX_CONFIGED_DV
comma
id|AIC7XXX_CONFIGED_DV
comma
id|AIC7XXX_CONFIGED_DV
comma
id|AIC7XXX_CONFIGED_DV
comma
id|AIC7XXX_CONFIGED_DV
comma
id|AIC7XXX_CONFIGED_DV
)brace
suffix:semicolon
multiline_comment|/*&n; * There should be a specific return value for this in scsi.h, but&n; * it seems that most drivers ignore it.&n; */
DECL|macro|DID_UNDERFLOW
mdefine_line|#define DID_UNDERFLOW   DID_ERROR
r_void
DECL|function|ahc_print_path
id|ahc_print_path
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|scb
op_star
id|scb
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;(scsi%d:%c:%d:%d): &quot;
comma
id|ahc-&gt;platform_data-&gt;host-&gt;host_no
comma
id|scb
op_ne
l_int|NULL
ques
c_cond
id|SCB_GET_CHANNEL
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:colon
l_char|&squot;X&squot;
comma
id|scb
op_ne
l_int|NULL
ques
c_cond
id|SCB_GET_TARGET
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:colon
op_minus
l_int|1
comma
id|scb
op_ne
l_int|NULL
ques
c_cond
id|SCB_GET_LUN
c_func
(paren
id|scb
)paren
suffix:colon
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * XXX - these options apply unilaterally to _all_ 274x/284x/294x&n; *       cards in the system.  This should be fixed.  Exceptions to this&n; *       rule are noted in the comments.&n; */
multiline_comment|/*&n; * Skip the scsi bus reset.  Non 0 make us skip the reset at startup.  This&n; * has no effect on any later resets that might occur due to things like&n; * SCSI bus timeouts.&n; */
DECL|variable|aic7xxx_no_reset
r_static
r_uint32
id|aic7xxx_no_reset
suffix:semicolon
multiline_comment|/*&n; * Certain PCI motherboards will scan PCI devices from highest to lowest,&n; * others scan from lowest to highest, and they tend to do all kinds of&n; * strange things when they come into contact with PCI bridge chips.  The&n; * net result of all this is that the PCI card that is actually used to boot&n; * the machine is very hard to detect.  Most motherboards go from lowest&n; * PCI slot number to highest, and the first SCSI controller found is the&n; * one you boot from.  The only exceptions to this are when a controller&n; * has its BIOS disabled.  So, we by default sort all of our SCSI controllers&n; * from lowest PCI slot number to highest PCI slot number.  We also force&n; * all controllers with their BIOS disabled to the end of the list.  This&n; * works on *almost* all computers.  Where it doesn&squot;t work, we have this&n; * option.  Setting this option to non-0 will reverse the order of the sort&n; * to highest first, then lowest, but will still leave cards with their BIOS&n; * disabled at the very end.  That should fix everyone up unless there are&n; * really strange cirumstances.&n; */
DECL|variable|aic7xxx_reverse_scan
r_static
r_uint32
id|aic7xxx_reverse_scan
suffix:semicolon
multiline_comment|/*&n; * Should we force EXTENDED translation on a controller.&n; *     0 == Use whatever is in the SEEPROM or default to off&n; *     1 == Use whatever is in the SEEPROM or default to on&n; */
DECL|variable|aic7xxx_extended
r_static
r_uint32
id|aic7xxx_extended
suffix:semicolon
multiline_comment|/*&n; * PCI bus parity checking of the Adaptec controllers.  This is somewhat&n; * dubious at best.  To my knowledge, this option has never actually&n; * solved a PCI parity problem, but on certain machines with broken PCI&n; * chipset configurations where stray PCI transactions with bad parity are&n; * the norm rather than the exception, the error messages can be overwelming.&n; * It&squot;s included in the driver for completeness.&n; *   0&t;   = Shut off PCI parity check&n; *   non-0 = reverse polarity pci parity checking&n; */
DECL|variable|aic7xxx_pci_parity
r_static
r_uint32
id|aic7xxx_pci_parity
op_assign
op_complement
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Certain newer motherboards have put new PCI based devices into the&n; * IO spaces that used to typically be occupied by VLB or EISA cards.&n; * This overlap can cause these newer motherboards to lock up when scanned&n; * for older EISA and VLB devices.  Setting this option to non-0 will&n; * cause the driver to skip scanning for any VLB or EISA controllers and&n; * only support the PCI controllers.  NOTE: this means that if the kernel&n; * os compiled with PCI support disabled, then setting this to non-0&n; * would result in never finding any devices :)&n; */
macro_line|#ifndef CONFIG_AIC7XXX_PROBE_EISA_VL
DECL|variable|aic7xxx_probe_eisa_vl
r_uint32
id|aic7xxx_probe_eisa_vl
suffix:semicolon
macro_line|#else
DECL|variable|aic7xxx_probe_eisa_vl
r_uint32
id|aic7xxx_probe_eisa_vl
op_assign
op_complement
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * There are lots of broken chipsets in the world.  Some of them will&n; * violate the PCI spec when we issue byte sized memory writes to our&n; * controller.  I/O mapped register access, if allowed by the given&n; * platform, will work in almost all cases.&n; */
DECL|variable|aic7xxx_allow_memio
r_uint32
id|aic7xxx_allow_memio
op_assign
op_complement
l_int|0
suffix:semicolon
multiline_comment|/*&n; * aic7xxx_detect() has been run, so register all device arrivals&n; * immediately with the system rather than deferring to the sorted&n; * attachment performed by aic7xxx_detect().&n; */
DECL|variable|aic7xxx_detect_complete
r_int
id|aic7xxx_detect_complete
suffix:semicolon
multiline_comment|/*&n; * So that we can set how long each device is given as a selection timeout.&n; * The table of values goes like this:&n; *   0 - 256ms&n; *   1 - 128ms&n; *   2 - 64ms&n; *   3 - 32ms&n; * We default to 256ms because some older devices need a longer time&n; * to respond to initial selection.&n; */
DECL|variable|aic7xxx_seltime
r_static
r_uint32
id|aic7xxx_seltime
suffix:semicolon
multiline_comment|/*&n; * Certain devices do not perform any aging on commands.  Should the&n; * device be saturated by commands in one portion of the disk, it is&n; * possible for transactions on far away sectors to never be serviced.&n; * To handle these devices, we can periodically send an ordered tag to&n; * force all outstanding transactions to be serviced prior to a new&n; * transaction.&n; */
DECL|variable|aic7xxx_periodic_otag
r_uint32
id|aic7xxx_periodic_otag
suffix:semicolon
multiline_comment|/*&n; * Module information and settable options.&n; */
macro_line|#ifdef MODULE
DECL|variable|aic7xxx
r_static
r_char
op_star
id|aic7xxx
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n; * Just in case someone uses commas to separate items on the insmod&n; * command line, we define a dummy buffer here to avoid having insmod&n; * write wild stuff into our code segment&n; */
DECL|variable|dummy_buffer
r_static
r_char
id|dummy_buffer
(braket
l_int|60
)braket
op_assign
l_string|&quot;Please don&squot;t trounce on me insmod!!&bslash;n&quot;
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Maintainer: Justin T. Gibbs &lt;gibbs@scsiguy.com&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Adaptec Aic77XX/78XX SCSI Host Bus Adapter driver&quot;
)paren
suffix:semicolon
macro_line|#ifdef MODULE_LICENSE
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;Dual BSD/GPL&quot;
)paren
suffix:semicolon
macro_line|#endif
id|MODULE_PARM
c_func
(paren
id|aic7xxx
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|aic7xxx
comma
l_string|&quot;period delimited, options string.&bslash;n&quot;
l_string|&quot;&t;verbose&t;&t;&t;Enable verbose/diagnostic logging&bslash;n&quot;
l_string|&quot;&t;allow_memio&t;&t;Allow device registers to be memory mapped&bslash;n&quot;
l_string|&quot;&t;debug&t;&t;&t;Bitmask of debug values to enable&bslash;n&quot;
l_string|&quot;&t;no_probe&t;&t;Toggle EISA/VLB controller probing&bslash;n&quot;
l_string|&quot;&t;probe_eisa_vl&t;&t;Toggle EISA/VLB controller probing&bslash;n&quot;
l_string|&quot;&t;no_reset&t;&t;Supress initial bus resets&bslash;n&quot;
l_string|&quot;&t;extended&t;&t;Enable extended geometry on all controllers&bslash;n&quot;
l_string|&quot;&t;periodic_otag&t;&t;Send an ordered tagged transaction&bslash;n&quot;
l_string|&quot;&t;&t;&t;&t;periodically to prevent tag starvation.&bslash;n&quot;
l_string|&quot;&t;&t;&t;&t;This may be required by some older disk&bslash;n&quot;
l_string|&quot;&t;&t;&t;&t;drives or RAID arrays.&bslash;n&quot;
l_string|&quot;&t;reverse_scan&t;&t;Sort PCI devices highest Bus/Slot to lowest&bslash;n&quot;
l_string|&quot;&t;tag_info:&lt;tag_str&gt;&t;Set per-target tag depth&bslash;n&quot;
l_string|&quot;&t;global_tag_depth:&lt;int&gt;&t;Global tag depth for every target&bslash;n&quot;
l_string|&quot;&t;&t;&t;&t;on every bus&bslash;n&quot;
l_string|&quot;&t;dv:&lt;dv_settings&gt;&t;Set per-controller Domain Validation Setting.&bslash;n&quot;
l_string|&quot;&t;seltime:&lt;int&gt;&t;&t;Selection Timeout&bslash;n&quot;
l_string|&quot;&t;&t;&t;&t;(0/256ms,1/128ms,2/64ms,3/32ms)&bslash;n&quot;
l_string|&quot;&bslash;n&quot;
l_string|&quot;&t;Sample /etc/modprobe.conf line:&bslash;n&quot;
l_string|&quot;&t;&t;Toggle EISA/VLB probing&bslash;n&quot;
l_string|&quot;&t;&t;Set tag depth on Controller 1/Target 1 to 10 tags&bslash;n&quot;
l_string|&quot;&t;&t;Shorten the selection timeout to 128ms&bslash;n&quot;
l_string|&quot;&bslash;n&quot;
l_string|&quot;&t;options aic7xxx &squot;aic7xxx=probe_eisa_vl.tag_info:{{}.{.10}}.seltime:1&squot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_static
r_void
id|ahc_linux_handle_scsi_status
c_func
(paren
r_struct
id|ahc_softc
op_star
comma
r_struct
id|ahc_linux_device
op_star
comma
r_struct
id|scb
op_star
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_queue_cmd_complete
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_filter_inquiry
c_func
(paren
r_struct
id|ahc_softc
op_star
comma
r_struct
id|ahc_devinfo
op_star
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_sem_timeout
c_func
(paren
id|u_long
id|arg
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_freeze_simq
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_release_simq
c_func
(paren
id|u_long
id|arg
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_dev_timed_unfreeze
c_func
(paren
id|u_long
id|arg
)paren
suffix:semicolon
r_static
r_int
id|ahc_linux_queue_recovery_cmd
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
id|scb_flag
id|flag
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_initialize_scsi_bus
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_size_nseg
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_thread_run_complete_queue
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_start_dv
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_dv_timeout
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
suffix:semicolon
r_static
r_int
id|ahc_linux_dv_thread
c_func
(paren
r_void
op_star
id|data
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_kill_dv_thread
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_dv_target
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|u_int
id|target
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_dv_transition
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
comma
r_struct
id|ahc_linux_target
op_star
id|targ
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_dv_fill_cmd
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_dv_inq
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
comma
r_struct
id|ahc_linux_target
op_star
id|targ
comma
id|u_int
id|request_length
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_dv_tur
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_dv_rebd
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
comma
r_struct
id|ahc_linux_target
op_star
id|targ
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_dv_web
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
comma
r_struct
id|ahc_linux_target
op_star
id|targ
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_dv_reb
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
comma
r_struct
id|ahc_linux_target
op_star
id|targ
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_dv_su
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
comma
r_struct
id|ahc_linux_target
op_star
id|targ
)paren
suffix:semicolon
r_static
r_int
id|ahc_linux_fallback
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_dv_complete
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_generate_dv_pattern
c_func
(paren
r_struct
id|ahc_linux_target
op_star
id|targ
)paren
suffix:semicolon
r_static
id|u_int
id|ahc_linux_user_tagdepth
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
)paren
suffix:semicolon
r_static
id|u_int
id|ahc_linux_user_dv_setting
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_device_queue_depth
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_linux_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|ahc_linux_target
op_star
id|ahc_linux_alloc_target
c_func
(paren
r_struct
id|ahc_softc
op_star
comma
id|u_int
comma
id|u_int
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_free_target
c_func
(paren
r_struct
id|ahc_softc
op_star
comma
r_struct
id|ahc_linux_target
op_star
)paren
suffix:semicolon
r_static
r_struct
id|ahc_linux_device
op_star
id|ahc_linux_alloc_device
c_func
(paren
r_struct
id|ahc_softc
op_star
comma
r_struct
id|ahc_linux_target
op_star
comma
id|u_int
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_free_device
c_func
(paren
r_struct
id|ahc_softc
op_star
comma
r_struct
id|ahc_linux_device
op_star
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_run_device_queue
c_func
(paren
r_struct
id|ahc_softc
op_star
comma
r_struct
id|ahc_linux_device
op_star
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_setup_tag_info_global
c_func
(paren
r_char
op_star
id|p
)paren
suffix:semicolon
DECL|variable|ahc_linux_setup_tag_info
r_static
id|aic_option_callback_t
id|ahc_linux_setup_tag_info
suffix:semicolon
DECL|variable|ahc_linux_setup_dv
r_static
id|aic_option_callback_t
id|ahc_linux_setup_dv
suffix:semicolon
r_static
r_int
id|aic7xxx_setup
c_func
(paren
r_char
op_star
id|s
)paren
suffix:semicolon
r_static
r_int
id|ahc_linux_next_unit
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|ahc_runq_tasklet
c_func
(paren
r_int
r_int
id|data
)paren
suffix:semicolon
r_static
r_struct
id|ahc_cmd
op_star
id|ahc_linux_run_complete_queue
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
suffix:semicolon
multiline_comment|/********************************* Inlines ************************************/
r_static
id|__inline
r_void
id|ahc_schedule_runq
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
suffix:semicolon
r_static
id|__inline
r_struct
id|ahc_linux_device
op_star
id|ahc_linux_get_device
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|u_int
id|channel
comma
id|u_int
id|target
comma
id|u_int
id|lun
comma
r_int
id|alloc
)paren
suffix:semicolon
r_static
id|__inline
r_void
id|ahc_schedule_completeq
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
suffix:semicolon
r_static
id|__inline
r_void
id|ahc_linux_check_device_queue
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_linux_device
op_star
id|dev
)paren
suffix:semicolon
r_static
id|__inline
r_struct
id|ahc_linux_device
op_star
id|ahc_linux_next_device_to_run
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
suffix:semicolon
r_static
id|__inline
r_void
id|ahc_linux_run_device_queues
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
suffix:semicolon
r_static
id|__inline
r_void
id|ahc_linux_unmap_scb
c_func
(paren
r_struct
id|ahc_softc
op_star
comma
r_struct
id|scb
op_star
)paren
suffix:semicolon
r_static
id|__inline
r_int
id|ahc_linux_map_seg
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|scb
op_star
id|scb
comma
r_struct
id|ahc_dma_seg
op_star
id|sg
comma
id|bus_addr_t
id|addr
comma
id|bus_size_t
id|len
)paren
suffix:semicolon
r_static
id|__inline
r_void
DECL|function|ahc_schedule_completeq
id|ahc_schedule_completeq
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_if
c_cond
(paren
(paren
id|ahc-&gt;platform_data-&gt;flags
op_amp
id|AHC_RUN_CMPLT_Q_TIMER
)paren
op_eq
l_int|0
)paren
(brace
id|ahc-&gt;platform_data-&gt;flags
op_or_assign
id|AHC_RUN_CMPLT_Q_TIMER
suffix:semicolon
id|ahc-&gt;platform_data-&gt;completeq_timer.expires
op_assign
id|jiffies
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;completeq_timer
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Must be called with our lock held.&n; */
r_static
id|__inline
r_void
DECL|function|ahc_schedule_runq
id|ahc_schedule_runq
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,4,0)
id|tasklet_schedule
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;runq_tasklet
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/*&n;&t; * Tasklets are not available, so run inline.&n;&t; */
id|ahc_runq_tasklet
c_func
(paren
(paren
r_int
r_int
)paren
id|ahc
)paren
suffix:semicolon
macro_line|#endif
)brace
r_static
id|__inline
r_struct
id|ahc_linux_device
op_star
DECL|function|ahc_linux_get_device
id|ahc_linux_get_device
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|u_int
id|channel
comma
id|u_int
id|target
comma
id|u_int
id|lun
comma
r_int
id|alloc
)paren
(brace
r_struct
id|ahc_linux_target
op_star
id|targ
suffix:semicolon
r_struct
id|ahc_linux_device
op_star
id|dev
suffix:semicolon
id|u_int
id|target_offset
suffix:semicolon
id|target_offset
op_assign
id|target
suffix:semicolon
r_if
c_cond
(paren
id|channel
op_ne
l_int|0
)paren
id|target_offset
op_add_assign
l_int|8
suffix:semicolon
id|targ
op_assign
id|ahc-&gt;platform_data-&gt;targets
(braket
id|target_offset
)braket
suffix:semicolon
r_if
c_cond
(paren
id|targ
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|alloc
op_ne
l_int|0
)paren
(brace
id|targ
op_assign
id|ahc_linux_alloc_target
c_func
(paren
id|ahc
comma
id|channel
comma
id|target
)paren
suffix:semicolon
r_if
c_cond
(paren
id|targ
op_eq
l_int|NULL
)paren
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
id|dev
op_assign
id|targ-&gt;devices
(braket
id|lun
)braket
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
op_logical_and
id|alloc
op_ne
l_int|0
)paren
id|dev
op_assign
id|ahc_linux_alloc_device
c_func
(paren
id|ahc
comma
id|targ
comma
id|lun
)paren
suffix:semicolon
r_return
(paren
id|dev
)paren
suffix:semicolon
)brace
DECL|macro|AHC_LINUX_MAX_RETURNED_ERRORS
mdefine_line|#define AHC_LINUX_MAX_RETURNED_ERRORS 4
r_static
r_struct
id|ahc_cmd
op_star
DECL|function|ahc_linux_run_complete_queue
id|ahc_linux_run_complete_queue
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_struct
id|ahc_cmd
op_star
id|acmd
suffix:semicolon
id|u_long
id|done_flags
suffix:semicolon
r_int
id|with_errors
suffix:semicolon
id|with_errors
op_assign
l_int|0
suffix:semicolon
id|ahc_done_lock
c_func
(paren
id|ahc
comma
op_amp
id|done_flags
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|acmd
op_assign
id|TAILQ_FIRST
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;completeq
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
r_if
c_cond
(paren
id|with_errors
OG
id|AHC_LINUX_MAX_RETURNED_ERRORS
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Linux uses stack recursion to requeue&n;&t;&t;&t; * commands that need to be retried.  Avoid&n;&t;&t;&t; * blowing out the stack by &quot;spoon feeding&quot;&n;&t;&t;&t; * commands that completed with error back&n;&t;&t;&t; * the operating system in case they are going&n;&t;&t;&t; * to be retried. &quot;ick&quot;&n;&t;&t;&t; */
id|ahc_schedule_completeq
c_func
(paren
id|ahc
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|TAILQ_REMOVE
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;completeq
comma
id|acmd
comma
id|acmd_links.tqe
)paren
suffix:semicolon
id|cmd
op_assign
op_amp
id|acmd_scsi_cmd
c_func
(paren
id|acmd
)paren
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|ahc_cmd_get_transaction_status
c_func
(paren
id|cmd
)paren
op_ne
id|DID_OK
op_logical_or
(paren
id|cmd-&gt;result
op_amp
l_int|0xFF
)paren
op_ne
id|SCSI_STATUS_OK
)paren
id|with_errors
op_increment
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
id|ahc_done_unlock
c_func
(paren
id|ahc
comma
op_amp
id|done_flags
)paren
suffix:semicolon
r_return
(paren
id|acmd
)paren
suffix:semicolon
)brace
r_static
id|__inline
r_void
DECL|function|ahc_linux_check_device_queue
id|ahc_linux_check_device_queue
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_linux_device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|AHC_DEV_FREEZE_TIL_EMPTY
)paren
op_ne
l_int|0
op_logical_and
id|dev-&gt;active
op_eq
l_int|0
)paren
(brace
id|dev-&gt;flags
op_and_assign
op_complement
id|AHC_DEV_FREEZE_TIL_EMPTY
suffix:semicolon
id|dev-&gt;qfrozen
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TAILQ_FIRST
c_func
(paren
op_amp
id|dev-&gt;busyq
)paren
op_eq
l_int|NULL
op_logical_or
id|dev-&gt;openings
op_eq
l_int|0
op_logical_or
id|dev-&gt;qfrozen
op_ne
l_int|0
)paren
r_return
suffix:semicolon
id|ahc_linux_run_device_queue
c_func
(paren
id|ahc
comma
id|dev
)paren
suffix:semicolon
)brace
r_static
id|__inline
r_struct
id|ahc_linux_device
op_star
DECL|function|ahc_linux_next_device_to_run
id|ahc_linux_next_device_to_run
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_if
c_cond
(paren
(paren
id|ahc-&gt;flags
op_amp
id|AHC_RESOURCE_SHORTAGE
)paren
op_ne
l_int|0
op_logical_or
(paren
id|ahc-&gt;platform_data-&gt;qfrozen
op_ne
l_int|0
op_logical_and
id|AHC_DV_SIMQ_FROZEN
c_func
(paren
id|ahc
)paren
op_eq
l_int|0
)paren
)paren
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
r_return
(paren
id|TAILQ_FIRST
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;device_runq
)paren
)paren
suffix:semicolon
)brace
r_static
id|__inline
r_void
DECL|function|ahc_linux_run_device_queues
id|ahc_linux_run_device_queues
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_struct
id|ahc_linux_device
op_star
id|dev
suffix:semicolon
r_while
c_loop
(paren
(paren
id|dev
op_assign
id|ahc_linux_next_device_to_run
c_func
(paren
id|ahc
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|TAILQ_REMOVE
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;device_runq
comma
id|dev
comma
id|links
)paren
suffix:semicolon
id|dev-&gt;flags
op_and_assign
op_complement
id|AHC_DEV_ON_RUN_LIST
suffix:semicolon
id|ahc_linux_check_device_queue
c_func
(paren
id|ahc
comma
id|dev
)paren
suffix:semicolon
)brace
)brace
r_static
id|__inline
r_void
DECL|function|ahc_linux_unmap_scb
id|ahc_linux_unmap_scb
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|scb
op_star
id|scb
)paren
(brace
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
id|cmd
op_assign
id|scb-&gt;io_ctx
suffix:semicolon
id|ahc_sync_sglist
c_func
(paren
id|ahc
comma
id|scb
comma
id|BUS_DMASYNC_POSTWRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;use_sg
op_ne
l_int|0
)paren
(brace
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;request_buffer
suffix:semicolon
id|pci_unmap_sg
c_func
(paren
id|ahc-&gt;dev_softc
comma
id|sg
comma
id|cmd-&gt;use_sg
comma
id|scsi_to_pci_dma_dir
c_func
(paren
id|cmd-&gt;sc_data_direction
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmd-&gt;request_bufflen
op_ne
l_int|0
)paren
(brace
id|pci_unmap_single
c_func
(paren
id|ahc-&gt;dev_softc
comma
id|scb-&gt;platform_data-&gt;buf_busaddr
comma
id|cmd-&gt;request_bufflen
comma
id|scsi_to_pci_dma_dir
c_func
(paren
id|cmd-&gt;sc_data_direction
)paren
)paren
suffix:semicolon
)brace
)brace
r_static
id|__inline
r_int
DECL|function|ahc_linux_map_seg
id|ahc_linux_map_seg
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|scb
op_star
id|scb
comma
r_struct
id|ahc_dma_seg
op_star
id|sg
comma
id|bus_addr_t
id|addr
comma
id|bus_size_t
id|len
)paren
(brace
r_int
id|consumed
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb-&gt;sg_count
op_plus
l_int|1
)paren
OG
id|AHC_NSEG
)paren
id|panic
c_func
(paren
l_string|&quot;Too few segs for dma mapping.  &quot;
l_string|&quot;Increase AHC_NSEG&bslash;n&quot;
)paren
suffix:semicolon
id|consumed
op_assign
l_int|1
suffix:semicolon
id|sg-&gt;addr
op_assign
id|ahc_htole32
c_func
(paren
id|addr
op_amp
l_int|0xFFFFFFFF
)paren
suffix:semicolon
id|scb-&gt;platform_data-&gt;xfer_len
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
r_sizeof
(paren
id|bus_addr_t
)paren
OG
l_int|4
op_logical_and
(paren
id|ahc-&gt;flags
op_amp
id|AHC_39BIT_ADDRESSING
)paren
op_ne
l_int|0
)paren
id|len
op_or_assign
(paren
id|addr
op_rshift
l_int|8
)paren
op_amp
id|AHC_SG_HIGH_ADDR_MASK
suffix:semicolon
id|sg-&gt;len
op_assign
id|ahc_htole32
c_func
(paren
id|len
)paren
suffix:semicolon
r_return
(paren
id|consumed
)paren
suffix:semicolon
)brace
multiline_comment|/************************  Host template entry points *************************/
r_static
r_int
id|ahc_linux_detect
c_func
(paren
id|Scsi_Host_Template
op_star
)paren
suffix:semicolon
r_static
r_int
id|ahc_linux_queue
c_func
(paren
id|Scsi_Cmnd
op_star
comma
r_void
(paren
op_star
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
suffix:semicolon
r_static
r_const
r_char
op_star
id|ahc_linux_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
)paren
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,5,0)
r_static
r_int
id|ahc_linux_slave_alloc
c_func
(paren
id|Scsi_Device
op_star
)paren
suffix:semicolon
r_static
r_int
id|ahc_linux_slave_configure
c_func
(paren
id|Scsi_Device
op_star
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_slave_destroy
c_func
(paren
id|Scsi_Device
op_star
)paren
suffix:semicolon
macro_line|#if defined(__i386__)
r_static
r_int
id|ahc_linux_biosparam
c_func
(paren
r_struct
id|scsi_device
op_star
comma
r_struct
id|block_device
op_star
comma
id|sector_t
comma
r_int
(braket
)braket
)paren
suffix:semicolon
macro_line|#endif
macro_line|#else
r_static
r_int
id|ahc_linux_release
c_func
(paren
r_struct
id|Scsi_Host
op_star
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_select_queue_depth
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
id|Scsi_Device
op_star
id|scsi_devs
)paren
suffix:semicolon
macro_line|#if defined(__i386__)
r_static
r_int
id|ahc_linux_biosparam
c_func
(paren
id|Disk
op_star
comma
id|kdev_t
comma
r_int
(braket
)braket
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
r_static
r_int
id|ahc_linux_bus_reset
c_func
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
r_static
r_int
id|ahc_linux_dev_reset
c_func
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
r_static
r_int
id|ahc_linux_abort
c_func
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * Calculate a safe value for AHC_NSEG (as expressed through ahc_linux_nseg).&n; *&n; * In pre-2.5.X...&n; * The midlayer allocates an S/G array dynamically when a command is issued&n; * using SCSI malloc.  This array, which is in an OS dependent format that&n; * must later be copied to our private S/G list, is sized to house just the&n; * number of segments needed for the current transfer.  Since the code that&n; * sizes the SCSI malloc pool does not take into consideration fragmentation&n; * of the pool, executing transactions numbering just a fraction of our&n; * concurrent transaction limit with list lengths aproaching AHC_NSEG will&n; * quickly depleat the SCSI malloc pool of usable space.  Unfortunately, the&n; * mid-layer does not properly handle this scsi malloc failures for the S/G&n; * array and the result can be a lockup of the I/O subsystem.  We try to size&n; * our S/G list so that it satisfies our drivers allocation requirements in&n; * addition to avoiding fragmentation of the SCSI malloc pool.&n; */
r_static
r_void
DECL|function|ahc_linux_size_nseg
id|ahc_linux_size_nseg
c_func
(paren
r_void
)paren
(brace
macro_line|#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,5,0)
id|u_int
id|cur_size
suffix:semicolon
id|u_int
id|best_size
suffix:semicolon
multiline_comment|/*&n;&t; * The SCSI allocator rounds to the nearest 512 bytes&n;&t; * an cannot allocate across a page boundary.  Our algorithm&n;&t; * is to start at 1K of scsi malloc space per-command and&n;&t; * loop through all factors of the PAGE_SIZE and pick the best.&n;&t; */
id|best_size
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|cur_size
op_assign
l_int|1024
suffix:semicolon
id|cur_size
op_le
id|PAGE_SIZE
suffix:semicolon
id|cur_size
op_mul_assign
l_int|2
)paren
(brace
id|u_int
id|nseg
suffix:semicolon
id|nseg
op_assign
id|cur_size
op_div
r_sizeof
(paren
r_struct
id|scatterlist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nseg
OL
id|AHC_LINUX_MIN_NSEG
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|best_size
op_eq
l_int|0
)paren
(brace
id|best_size
op_assign
id|cur_size
suffix:semicolon
id|ahc_linux_nseg
op_assign
id|nseg
suffix:semicolon
)brace
r_else
(brace
id|u_int
id|best_rem
suffix:semicolon
id|u_int
id|cur_rem
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Compare the traits of the current &quot;best_size&quot;&n;&t;&t;&t; * with the current size to determine if the&n;&t;&t;&t; * current size is a better size.&n;&t;&t;&t; */
id|best_rem
op_assign
id|best_size
op_mod
r_sizeof
(paren
r_struct
id|scatterlist
)paren
suffix:semicolon
id|cur_rem
op_assign
id|cur_size
op_mod
r_sizeof
(paren
r_struct
id|scatterlist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur_rem
OL
id|best_rem
)paren
(brace
id|best_size
op_assign
id|cur_size
suffix:semicolon
id|ahc_linux_nseg
op_assign
id|nseg
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
)brace
multiline_comment|/*&n; * Try to detect an Adaptec 7XXX controller.&n; */
r_static
r_int
DECL|function|ahc_linux_detect
id|ahc_linux_detect
c_func
(paren
id|Scsi_Host_Template
op_star
r_template
)paren
(brace
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
r_int
id|found
op_assign
l_int|0
suffix:semicolon
r_int
id|eisa_err
comma
id|pci_err
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,5,0)
multiline_comment|/*&n;&t; * It is a bug that the upper layer takes&n;&t; * this lock just prior to calling us.&n;&t; */
id|spin_unlock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Sanity checking of Linux SCSI data structures so&n;&t; * that some of our hacks^H^H^H^H^Hassumptions aren&squot;t&n;&t; * violated.&n;&t; */
r_if
c_cond
(paren
m_offsetof
(paren
r_struct
id|ahc_cmd_internal
comma
id|end
)paren
OG
m_offsetof
(paren
r_struct
id|scsi_cmnd
comma
id|host_scribble
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;ahc_linux_detect: SCSI data structures changed.&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;ahc_linux_detect: Unable to attach&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|ahc_linux_size_nseg
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef MODULE
multiline_comment|/*&n;&t; * If we&squot;ve been passed any parameters, process them now.&n;&t; */
r_if
c_cond
(paren
id|aic7xxx
)paren
id|aic7xxx_setup
c_func
(paren
id|aic7xxx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dummy_buffer
(braket
l_int|0
)braket
op_ne
l_char|&squot;P&squot;
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;aic7xxx: Please read the file /usr/src/linux/drivers/scsi/README.aic7xxx&bslash;n&quot;
l_string|&quot;aic7xxx: to see the proper way to specify options to the aic7xxx module&bslash;n&quot;
l_string|&quot;aic7xxx: Specifically, don&squot;t use any commas when passing arguments to&bslash;n&quot;
l_string|&quot;aic7xxx: insmod or else it might trash certain memory areas.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,3,0)
r_template
op_member_access_from_pointer
id|proc_name
op_assign
l_string|&quot;aic7xxx&quot;
suffix:semicolon
macro_line|#else
r_template
op_member_access_from_pointer
id|proc_dir
op_assign
op_amp
id|proc_scsi_aic7xxx
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Initialize our softc list lock prior to&n;&t; * probing for any adapters.&n;&t; */
id|ahc_list_lockinit
c_func
(paren
)paren
suffix:semicolon
id|pci_err
op_assign
id|ahc_linux_pci_init
c_func
(paren
)paren
suffix:semicolon
id|eisa_err
op_assign
id|ahc_linux_eisa_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_err
op_logical_and
id|eisa_err
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Register with the SCSI layer all&n;&t; * controllers we&squot;ve found.&n;&t; */
id|TAILQ_FOREACH
c_func
(paren
id|ahc
comma
op_amp
id|ahc_tailq
comma
id|links
)paren
(brace
r_if
c_cond
(paren
id|ahc_linux_register_host
c_func
(paren
id|ahc
comma
r_template
)paren
op_eq
l_int|0
)paren
id|found
op_increment
suffix:semicolon
)brace
id|out
suffix:colon
macro_line|#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,5,0)
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
macro_line|#endif
id|aic7xxx_detect_complete
op_increment
suffix:semicolon
r_return
(paren
id|found
)paren
suffix:semicolon
)brace
macro_line|#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,5,0)
multiline_comment|/*&n; * Free the passed in Scsi_Host memory structures prior to unloading the&n; * module.&n; */
r_int
DECL|function|ahc_linux_release
id|ahc_linux_release
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
id|u_long
id|l
suffix:semicolon
id|ahc_list_lock
c_func
(paren
op_amp
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|host
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * We should be able to just perform&n;&t;&t; * the free directly, but check our&n;&t;&t; * list for extra sanity.&n;&t;&t; */
id|ahc
op_assign
id|ahc_find_softc
c_func
(paren
op_star
(paren
r_struct
id|ahc_softc
op_star
op_star
)paren
id|host-&gt;hostdata
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc
op_ne
l_int|NULL
)paren
(brace
id|u_long
id|s
suffix:semicolon
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
id|ahc_intr_enable
c_func
(paren
id|ahc
comma
id|FALSE
)paren
suffix:semicolon
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
id|ahc_free
c_func
(paren
id|ahc
)paren
suffix:semicolon
)brace
)brace
id|ahc_list_unlock
c_func
(paren
op_amp
id|l
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Return a string describing the driver.&n; */
r_static
r_const
r_char
op_star
DECL|function|ahc_linux_info
id|ahc_linux_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_static
r_char
id|buffer
(braket
l_int|512
)braket
suffix:semicolon
r_char
id|ahc_info
(braket
l_int|256
)braket
suffix:semicolon
r_char
op_star
id|bp
suffix:semicolon
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
id|bp
op_assign
op_amp
id|buffer
(braket
l_int|0
)braket
suffix:semicolon
id|ahc
op_assign
op_star
(paren
r_struct
id|ahc_softc
op_star
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|memset
c_func
(paren
id|bp
comma
l_int|0
comma
r_sizeof
(paren
id|buffer
)paren
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|bp
comma
l_string|&quot;Adaptec AIC7XXX EISA/VLB/PCI SCSI HBA DRIVER, Rev &quot;
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
id|AIC7XXX_DRIVER_VERSION
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
l_string|&quot;        &lt;&quot;
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
id|ahc-&gt;description
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
l_string|&quot;&gt;&bslash;n&quot;
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
l_string|&quot;        &quot;
)paren
suffix:semicolon
id|ahc_controller_info
c_func
(paren
id|ahc
comma
id|ahc_info
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
id|ahc_info
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
id|bp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Queue an SCB to the controller.&n; */
r_static
r_int
DECL|function|ahc_linux_queue
id|ahc_linux_queue
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|scsi_done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
r_struct
id|ahc_linux_device
op_star
id|dev
suffix:semicolon
id|u_long
id|flags
suffix:semicolon
id|ahc
op_assign
op_star
(paren
r_struct
id|ahc_softc
op_star
op_star
)paren
id|cmd-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
multiline_comment|/*&n;&t; * Save the callback on completion function.&n;&t; */
id|cmd-&gt;scsi_done
op_assign
id|scsi_done
suffix:semicolon
id|ahc_midlayer_entrypoint_lock
c_func
(paren
id|ahc
comma
op_amp
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Close the race of a command that was in the process of&n;&t; * being queued to us just as our simq was frozen.  Let&n;&t; * DV commands through so long as we are only frozen to&n;&t; * perform DV.&n;&t; */
r_if
c_cond
(paren
id|ahc-&gt;platform_data-&gt;qfrozen
op_ne
l_int|0
op_logical_and
id|AHC_DV_CMD
c_func
(paren
id|cmd
)paren
op_eq
l_int|0
)paren
(brace
id|ahc_cmd_set_transaction_status
c_func
(paren
id|cmd
comma
id|CAM_REQUEUE_REQ
)paren
suffix:semicolon
id|ahc_linux_queue_cmd_complete
c_func
(paren
id|ahc
comma
id|cmd
)paren
suffix:semicolon
id|ahc_schedule_completeq
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_midlayer_entrypoint_unlock
c_func
(paren
id|ahc
comma
op_amp
id|flags
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|dev
op_assign
id|ahc_linux_get_device
c_func
(paren
id|ahc
comma
id|cmd-&gt;device-&gt;channel
comma
id|cmd-&gt;device-&gt;id
comma
id|cmd-&gt;device-&gt;lun
comma
multiline_comment|/*alloc*/
id|TRUE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|ahc_cmd_set_transaction_status
c_func
(paren
id|cmd
comma
id|CAM_RESRC_UNAVAIL
)paren
suffix:semicolon
id|ahc_linux_queue_cmd_complete
c_func
(paren
id|ahc
comma
id|cmd
)paren
suffix:semicolon
id|ahc_schedule_completeq
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_midlayer_entrypoint_unlock
c_func
(paren
id|ahc
comma
op_amp
id|flags
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s: aic7xxx_linux_queue - Unable to allocate device!&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|cmd-&gt;result
op_assign
id|CAM_REQ_INPROG
op_lshift
l_int|16
suffix:semicolon
id|TAILQ_INSERT_TAIL
c_func
(paren
op_amp
id|dev-&gt;busyq
comma
(paren
r_struct
id|ahc_cmd
op_star
)paren
id|cmd
comma
id|acmd_links.tqe
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|AHC_DEV_ON_RUN_LIST
)paren
op_eq
l_int|0
)paren
(brace
id|TAILQ_INSERT_TAIL
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;device_runq
comma
id|dev
comma
id|links
)paren
suffix:semicolon
id|dev-&gt;flags
op_or_assign
id|AHC_DEV_ON_RUN_LIST
suffix:semicolon
id|ahc_linux_run_device_queues
c_func
(paren
id|ahc
)paren
suffix:semicolon
)brace
id|ahc_midlayer_entrypoint_unlock
c_func
(paren
id|ahc
comma
op_amp
id|flags
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,5,0)
r_static
r_int
DECL|function|ahc_linux_slave_alloc
id|ahc_linux_slave_alloc
c_func
(paren
id|Scsi_Device
op_star
id|device
)paren
(brace
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
id|ahc
op_assign
op_star
(paren
(paren
r_struct
id|ahc_softc
op_star
op_star
)paren
id|device-&gt;host-&gt;hostdata
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
)paren
id|printf
c_func
(paren
l_string|&quot;%s: Slave Alloc %d&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|device-&gt;id
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|ahc_linux_slave_configure
id|ahc_linux_slave_configure
c_func
(paren
id|Scsi_Device
op_star
id|device
)paren
(brace
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
r_struct
id|ahc_linux_device
op_star
id|dev
suffix:semicolon
id|u_long
id|flags
suffix:semicolon
id|ahc
op_assign
op_star
(paren
(paren
r_struct
id|ahc_softc
op_star
op_star
)paren
id|device-&gt;host-&gt;hostdata
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
)paren
id|printf
c_func
(paren
l_string|&quot;%s: Slave Configure %d&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|device-&gt;id
)paren
suffix:semicolon
id|ahc_midlayer_entrypoint_lock
c_func
(paren
id|ahc
comma
op_amp
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Since Linux has attached to the device, configure&n;&t; * it so we don&squot;t free and allocate the device&n;&t; * structure on every command.&n;&t; */
id|dev
op_assign
id|ahc_linux_get_device
c_func
(paren
id|ahc
comma
id|device-&gt;channel
comma
id|device-&gt;id
comma
id|device-&gt;lun
comma
multiline_comment|/*alloc*/
id|TRUE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_ne
l_int|NULL
)paren
(brace
id|dev-&gt;flags
op_and_assign
op_complement
id|AHC_DEV_UNCONFIGURED
suffix:semicolon
id|dev-&gt;scsi_device
op_assign
id|device
suffix:semicolon
id|ahc_linux_device_queue_depth
c_func
(paren
id|ahc
comma
id|dev
)paren
suffix:semicolon
)brace
id|ahc_midlayer_entrypoint_unlock
c_func
(paren
id|ahc
comma
op_amp
id|flags
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahc_linux_slave_destroy
id|ahc_linux_slave_destroy
c_func
(paren
id|Scsi_Device
op_star
id|device
)paren
(brace
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
r_struct
id|ahc_linux_device
op_star
id|dev
suffix:semicolon
id|u_long
id|flags
suffix:semicolon
id|ahc
op_assign
op_star
(paren
(paren
r_struct
id|ahc_softc
op_star
op_star
)paren
id|device-&gt;host-&gt;hostdata
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
)paren
id|printf
c_func
(paren
l_string|&quot;%s: Slave Destroy %d&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|device-&gt;id
)paren
suffix:semicolon
id|ahc_midlayer_entrypoint_lock
c_func
(paren
id|ahc
comma
op_amp
id|flags
)paren
suffix:semicolon
id|dev
op_assign
id|ahc_linux_get_device
c_func
(paren
id|ahc
comma
id|device-&gt;channel
comma
id|device-&gt;id
comma
id|device-&gt;lun
comma
multiline_comment|/*alloc*/
id|FALSE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Filter out &quot;silly&quot; deletions of real devices by only&n;&t; * deleting devices that have had slave_configure()&n;&t; * called on them.  All other devices that have not&n;&t; * been configured will automatically be deleted by&n;&t; * the refcounting process.&n;&t; */
r_if
c_cond
(paren
id|dev
op_ne
l_int|NULL
op_logical_and
(paren
id|dev-&gt;flags
op_amp
id|AHC_DEV_SLAVE_CONFIGURED
)paren
op_ne
l_int|0
)paren
(brace
id|dev-&gt;flags
op_or_assign
id|AHC_DEV_UNCONFIGURED
suffix:semicolon
r_if
c_cond
(paren
id|TAILQ_EMPTY
c_func
(paren
op_amp
id|dev-&gt;busyq
)paren
op_logical_and
id|dev-&gt;active
op_eq
l_int|0
op_logical_and
(paren
id|dev-&gt;flags
op_amp
id|AHC_DEV_TIMER_ACTIVE
)paren
op_eq
l_int|0
)paren
id|ahc_linux_free_device
c_func
(paren
id|ahc
comma
id|dev
)paren
suffix:semicolon
)brace
id|ahc_midlayer_entrypoint_unlock
c_func
(paren
id|ahc
comma
op_amp
id|flags
)paren
suffix:semicolon
)brace
macro_line|#else
multiline_comment|/*&n; * Sets the queue depth for each SCSI device hanging&n; * off the input host adapter.&n; */
r_static
r_void
DECL|function|ahc_linux_select_queue_depth
id|ahc_linux_select_queue_depth
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
id|Scsi_Device
op_star
id|scsi_devs
)paren
(brace
id|Scsi_Device
op_star
id|device
suffix:semicolon
id|Scsi_Device
op_star
id|ldev
suffix:semicolon
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
id|u_long
id|flags
suffix:semicolon
id|ahc
op_assign
op_star
(paren
(paren
r_struct
id|ahc_softc
op_star
op_star
)paren
id|host-&gt;hostdata
)paren
suffix:semicolon
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|device
op_assign
id|scsi_devs
suffix:semicolon
id|device
op_ne
l_int|NULL
suffix:semicolon
id|device
op_assign
id|device-&gt;next
)paren
(brace
multiline_comment|/*&n;&t;&t; * Watch out for duplicate devices.  This works around&n;&t;&t; * some quirks in how the SCSI scanning code does its&n;&t;&t; * device management.&n;&t;&t; */
r_for
c_loop
(paren
id|ldev
op_assign
id|scsi_devs
suffix:semicolon
id|ldev
op_ne
id|device
suffix:semicolon
id|ldev
op_assign
id|ldev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|ldev-&gt;host
op_eq
id|device-&gt;host
op_logical_and
id|ldev-&gt;channel
op_eq
id|device-&gt;channel
op_logical_and
id|ldev-&gt;id
op_eq
id|device-&gt;id
op_logical_and
id|ldev-&gt;lun
op_eq
id|device-&gt;lun
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* Skip duplicate. */
r_if
c_cond
(paren
id|ldev
op_ne
id|device
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;host
op_eq
id|host
)paren
(brace
r_struct
id|ahc_linux_device
op_star
id|dev
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Since Linux has attached to the device, configure&n;&t;&t;&t; * it so we don&squot;t free and allocate the device&n;&t;&t;&t; * structure on every command.&n;&t;&t;&t; */
id|dev
op_assign
id|ahc_linux_get_device
c_func
(paren
id|ahc
comma
id|device-&gt;channel
comma
id|device-&gt;id
comma
id|device-&gt;lun
comma
multiline_comment|/*alloc*/
id|TRUE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_ne
l_int|NULL
)paren
(brace
id|dev-&gt;flags
op_and_assign
op_complement
id|AHC_DEV_UNCONFIGURED
suffix:semicolon
id|dev-&gt;scsi_device
op_assign
id|device
suffix:semicolon
id|ahc_linux_device_queue_depth
c_func
(paren
id|ahc
comma
id|dev
)paren
suffix:semicolon
id|device-&gt;queue_depth
op_assign
id|dev-&gt;openings
op_plus
id|dev-&gt;active
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
(paren
id|AHC_DEV_Q_BASIC
op_or
id|AHC_DEV_Q_TAGGED
)paren
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * We allow the OS to queue 2 untagged&n;&t;&t;&t;&t;&t; * transactions to us at any time even&n;&t;&t;&t;&t;&t; * though we can only execute them&n;&t;&t;&t;&t;&t; * serially on the controller/device.&n;&t;&t;&t;&t;&t; * This should remove some latency.&n;&t;&t;&t;&t;&t; */
id|device-&gt;queue_depth
op_assign
l_int|2
suffix:semicolon
)brace
)brace
)brace
)brace
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if defined(__i386__)
multiline_comment|/*&n; * Return the disk geometry for the given SCSI device.&n; */
r_static
r_int
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,5,0)
DECL|function|ahc_linux_biosparam
id|ahc_linux_biosparam
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
comma
r_struct
id|block_device
op_star
id|bdev
comma
id|sector_t
id|capacity
comma
r_int
id|geom
(braket
)braket
)paren
(brace
r_uint8
op_star
id|bh
suffix:semicolon
macro_line|#else
id|ahc_linux_biosparam
c_func
(paren
id|Disk
op_star
id|disk
comma
id|kdev_t
id|dev
comma
r_int
id|geom
(braket
)braket
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
op_assign
id|disk-&gt;device
suffix:semicolon
id|u_long
id|capacity
op_assign
id|disk-&gt;capacity
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
macro_line|#endif
r_int
id|heads
suffix:semicolon
r_int
id|sectors
suffix:semicolon
r_int
id|cylinders
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|extended
suffix:semicolon
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
id|u_int
id|channel
suffix:semicolon
id|ahc
op_assign
op_star
(paren
(paren
r_struct
id|ahc_softc
op_star
op_star
)paren
id|sdev-&gt;host-&gt;hostdata
)paren
suffix:semicolon
id|channel
op_assign
id|sdev-&gt;channel
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,5,0)
id|bh
op_assign
id|scsi_bios_ptable
c_func
(paren
id|bdev
)paren
suffix:semicolon
macro_line|#elif LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,4,17)
id|bh
op_assign
id|bread
c_func
(paren
id|MKDEV
c_func
(paren
id|MAJOR
c_func
(paren
id|dev
)paren
comma
id|MINOR
c_func
(paren
id|dev
)paren
op_amp
op_complement
l_int|0xf
)paren
comma
l_int|0
comma
id|block_size
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
macro_line|#else
id|bh
op_assign
id|bread
c_func
(paren
id|MKDEV
c_func
(paren
id|MAJOR
c_func
(paren
id|dev
)paren
comma
id|MINOR
c_func
(paren
id|dev
)paren
op_amp
op_complement
l_int|0xf
)paren
comma
l_int|0
comma
l_int|1024
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|bh
)paren
(brace
id|ret
op_assign
id|scsi_partsize
c_func
(paren
id|bh
comma
id|capacity
comma
op_amp
id|geom
(braket
l_int|2
)braket
comma
op_amp
id|geom
(braket
l_int|0
)braket
comma
op_amp
id|geom
(braket
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,5,0)
id|kfree
c_func
(paren
id|bh
)paren
suffix:semicolon
macro_line|#else
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|ret
op_ne
op_minus
l_int|1
)paren
r_return
(paren
id|ret
)paren
suffix:semicolon
)brace
id|heads
op_assign
l_int|64
suffix:semicolon
id|sectors
op_assign
l_int|32
suffix:semicolon
id|cylinders
op_assign
id|aic_sector_div
c_func
(paren
id|capacity
comma
id|heads
comma
id|sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_extended
op_ne
l_int|0
)paren
id|extended
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|channel
op_eq
l_int|0
)paren
id|extended
op_assign
(paren
id|ahc-&gt;flags
op_amp
id|AHC_EXTENDED_TRANS_A
)paren
op_ne
l_int|0
suffix:semicolon
r_else
id|extended
op_assign
(paren
id|ahc-&gt;flags
op_amp
id|AHC_EXTENDED_TRANS_B
)paren
op_ne
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|extended
op_logical_and
id|cylinders
op_ge
l_int|1024
)paren
(brace
id|heads
op_assign
l_int|255
suffix:semicolon
id|sectors
op_assign
l_int|63
suffix:semicolon
id|cylinders
op_assign
id|aic_sector_div
c_func
(paren
id|capacity
comma
id|heads
comma
id|sectors
)paren
suffix:semicolon
)brace
id|geom
(braket
l_int|0
)braket
op_assign
id|heads
suffix:semicolon
id|geom
(braket
l_int|1
)braket
op_assign
id|sectors
suffix:semicolon
id|geom
(braket
l_int|2
)braket
op_assign
id|cylinders
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Abort the current SCSI command(s).&n; */
r_static
r_int
DECL|function|ahc_linux_abort
id|ahc_linux_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|error
suffix:semicolon
id|error
op_assign
id|ahc_linux_queue_recovery_cmd
c_func
(paren
id|cmd
comma
id|SCB_ABORT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;aic7xxx_abort returns 0x%x&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Attempt to send a target reset message to the device that timed out.&n; */
r_static
r_int
DECL|function|ahc_linux_dev_reset
id|ahc_linux_dev_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|error
suffix:semicolon
id|error
op_assign
id|ahc_linux_queue_recovery_cmd
c_func
(paren
id|cmd
comma
id|SCB_DEVICE_RESET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;aic7xxx_dev_reset returns 0x%x&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Reset the SCSI bus.&n; */
r_static
r_int
DECL|function|ahc_linux_bus_reset
id|ahc_linux_bus_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
id|u_long
id|s
suffix:semicolon
r_int
id|found
suffix:semicolon
id|ahc
op_assign
op_star
(paren
r_struct
id|ahc_softc
op_star
op_star
)paren
id|cmd-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
id|ahc_midlayer_entrypoint_lock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
id|found
op_assign
id|ahc_reset_channel
c_func
(paren
id|ahc
comma
id|cmd-&gt;device-&gt;channel
op_plus
l_char|&squot;A&squot;
comma
multiline_comment|/*initiate reset*/
id|TRUE
)paren
suffix:semicolon
id|ahc_linux_run_complete_queue
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_midlayer_entrypoint_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
)paren
id|printf
c_func
(paren
l_string|&quot;%s: SCSI bus reset delivered. &quot;
l_string|&quot;%d SCBs aborted.&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|found
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
DECL|variable|aic7xxx_driver_template
id|Scsi_Host_Template
id|aic7xxx_driver_template
op_assign
(brace
dot
id|module
op_assign
id|THIS_MODULE
comma
dot
id|name
op_assign
l_string|&quot;aic7xxx&quot;
comma
dot
id|proc_info
op_assign
id|ahc_linux_proc_info
comma
dot
id|info
op_assign
id|ahc_linux_info
comma
dot
id|queuecommand
op_assign
id|ahc_linux_queue
comma
dot
id|eh_abort_handler
op_assign
id|ahc_linux_abort
comma
dot
id|eh_device_reset_handler
op_assign
id|ahc_linux_dev_reset
comma
dot
id|eh_bus_reset_handler
op_assign
id|ahc_linux_bus_reset
comma
macro_line|#if defined(__i386__)
dot
id|bios_param
op_assign
id|ahc_linux_biosparam
comma
macro_line|#endif
dot
id|can_queue
op_assign
id|AHC_MAX_QUEUE
comma
dot
id|this_id
op_assign
op_minus
l_int|1
comma
dot
id|cmd_per_lun
op_assign
l_int|2
comma
dot
id|use_clustering
op_assign
id|ENABLE_CLUSTERING
comma
dot
id|slave_alloc
op_assign
id|ahc_linux_slave_alloc
comma
dot
id|slave_configure
op_assign
id|ahc_linux_slave_configure
comma
dot
id|slave_destroy
op_assign
id|ahc_linux_slave_destroy
comma
)brace
suffix:semicolon
multiline_comment|/**************************** Tasklet Handler *********************************/
multiline_comment|/*&n; * In 2.4.X and above, this routine is called from a tasklet,&n; * so we must re-acquire our lock prior to executing this code.&n; * In all prior kernels, ahc_schedule_runq() calls this routine&n; * directly and ahc_schedule_runq() is called with our lock held.&n; */
r_static
r_void
DECL|function|ahc_runq_tasklet
id|ahc_runq_tasklet
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
r_struct
id|ahc_linux_device
op_star
id|dev
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,4,0)
id|u_long
id|flags
suffix:semicolon
macro_line|#endif
id|ahc
op_assign
(paren
r_struct
id|ahc_softc
op_star
)paren
id|data
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,4,0)
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|flags
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
(paren
id|dev
op_assign
id|ahc_linux_next_device_to_run
c_func
(paren
id|ahc
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|TAILQ_REMOVE
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;device_runq
comma
id|dev
comma
id|links
)paren
suffix:semicolon
id|dev-&gt;flags
op_and_assign
op_complement
id|AHC_DEV_ON_RUN_LIST
suffix:semicolon
id|ahc_linux_check_device_queue
c_func
(paren
id|ahc
comma
id|dev
)paren
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,4,0)
multiline_comment|/* Yeild to our interrupt handler */
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|flags
)paren
suffix:semicolon
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|flags
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,4,0)
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|flags
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/******************************** Macros **************************************/
DECL|macro|BUILD_SCSIID
mdefine_line|#define BUILD_SCSIID(ahc, cmd)&t;&t;&t;&t;&t;&t;    &bslash;&n;&t;((((cmd)-&gt;device-&gt;id &lt;&lt; TID_SHIFT) &amp; TID)&t;&t;&t;    &bslash;&n;&t;| (((cmd)-&gt;device-&gt;channel == 0) ? (ahc)-&gt;our_id : (ahc)-&gt;our_id_b) &bslash;&n;&t;| (((cmd)-&gt;device-&gt;channel == 0) ? 0 : TWIN_CHNLB))
multiline_comment|/******************************** Bus DMA *************************************/
r_int
DECL|function|ahc_dma_tag_create
id|ahc_dma_tag_create
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|bus_dma_tag_t
id|parent
comma
id|bus_size_t
id|alignment
comma
id|bus_size_t
id|boundary
comma
id|bus_addr_t
id|lowaddr
comma
id|bus_addr_t
id|highaddr
comma
id|bus_dma_filter_t
op_star
id|filter
comma
r_void
op_star
id|filterarg
comma
id|bus_size_t
id|maxsize
comma
r_int
id|nsegments
comma
id|bus_size_t
id|maxsegsz
comma
r_int
id|flags
comma
id|bus_dma_tag_t
op_star
id|ret_tag
)paren
(brace
id|bus_dma_tag_t
id|dmat
suffix:semicolon
id|dmat
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|dmat
)paren
comma
id|M_DEVBUF
comma
id|M_NOWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmat
op_eq
l_int|NULL
)paren
r_return
(paren
id|ENOMEM
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Linux is very simplistic about DMA memory.  For now don&squot;t&n;&t; * maintain all specification information.  Once Linux supplies&n;&t; * better facilities for doing these operations, or the&n;&t; * needs of this particular driver change, we might need to do&n;&t; * more here.&n;&t; */
id|dmat-&gt;alignment
op_assign
id|alignment
suffix:semicolon
id|dmat-&gt;boundary
op_assign
id|boundary
suffix:semicolon
id|dmat-&gt;maxsize
op_assign
id|maxsize
suffix:semicolon
op_star
id|ret_tag
op_assign
id|dmat
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahc_dma_tag_destroy
id|ahc_dma_tag_destroy
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|bus_dma_tag_t
id|dmat
)paren
(brace
id|free
c_func
(paren
id|dmat
comma
id|M_DEVBUF
)paren
suffix:semicolon
)brace
r_int
DECL|function|ahc_dmamem_alloc
id|ahc_dmamem_alloc
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|bus_dma_tag_t
id|dmat
comma
r_void
op_star
op_star
id|vaddr
comma
r_int
id|flags
comma
id|bus_dmamap_t
op_star
id|mapp
)paren
(brace
id|bus_dmamap_t
id|map
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,3,0)
id|map
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|map
)paren
comma
id|M_DEVBUF
comma
id|M_NOWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|map
op_eq
l_int|NULL
)paren
r_return
(paren
id|ENOMEM
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Although we can dma data above 4GB, our&n;&t; * &quot;consistent&quot; memory is below 4GB for&n;&t; * space efficiency reasons (only need a 4byte&n;&t; * address).  For this reason, we have to reset&n;&t; * our dma mask when doing allocations.&n;&t; */
r_if
c_cond
(paren
id|ahc-&gt;dev_softc
op_ne
l_int|NULL
)paren
r_if
c_cond
(paren
id|ahc_pci_set_dma_mask
c_func
(paren
id|ahc-&gt;dev_softc
comma
l_int|0xFFFFFFFF
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;aic7xxx: No suitable DMA available.&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
id|ENODEV
)paren
suffix:semicolon
)brace
op_star
id|vaddr
op_assign
id|pci_alloc_consistent
c_func
(paren
id|ahc-&gt;dev_softc
comma
id|dmat-&gt;maxsize
comma
op_amp
id|map-&gt;bus_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;dev_softc
op_ne
l_int|NULL
)paren
r_if
c_cond
(paren
id|ahc_pci_set_dma_mask
c_func
(paren
id|ahc-&gt;dev_softc
comma
id|ahc-&gt;platform_data-&gt;hw_dma_mask
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;aic7xxx: No suitable DMA available.&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
id|ENODEV
)paren
suffix:semicolon
)brace
macro_line|#else /* LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,3,0) */
multiline_comment|/*&n;&t; * At least in 2.2.14, malloc is a slab allocator so all&n;&t; * allocations are aligned.  We assume for these kernel versions&n;&t; * that all allocations will be bellow 4Gig, physically contiguous,&n;&t; * and accessible via DMA by the controller.&n;&t; */
id|map
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* No additional information to store */
op_star
id|vaddr
op_assign
id|malloc
c_func
(paren
id|dmat-&gt;maxsize
comma
id|M_DEVBUF
comma
id|M_NOWAIT
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_star
id|vaddr
op_eq
l_int|NULL
)paren
r_return
(paren
id|ENOMEM
)paren
suffix:semicolon
op_star
id|mapp
op_assign
id|map
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|ahc_dmamem_free
id|ahc_dmamem_free
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|bus_dma_tag_t
id|dmat
comma
r_void
op_star
id|vaddr
comma
id|bus_dmamap_t
id|map
)paren
(brace
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,3,0)
id|pci_free_consistent
c_func
(paren
id|ahc-&gt;dev_softc
comma
id|dmat-&gt;maxsize
comma
id|vaddr
comma
id|map-&gt;bus_addr
)paren
suffix:semicolon
macro_line|#else
id|free
c_func
(paren
id|vaddr
comma
id|M_DEVBUF
)paren
suffix:semicolon
macro_line|#endif
)brace
r_int
DECL|function|ahc_dmamap_load
id|ahc_dmamap_load
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|bus_dma_tag_t
id|dmat
comma
id|bus_dmamap_t
id|map
comma
r_void
op_star
id|buf
comma
id|bus_size_t
id|buflen
comma
id|bus_dmamap_callback_t
op_star
id|cb
comma
r_void
op_star
id|cb_arg
comma
r_int
id|flags
)paren
(brace
multiline_comment|/*&n;&t; * Assume for now that this will only be used during&n;&t; * initialization and not for per-transaction buffer mapping.&n;&t; */
id|bus_dma_segment_t
id|stack_sg
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,3,0)
id|stack_sg.ds_addr
op_assign
id|map-&gt;bus_addr
suffix:semicolon
macro_line|#else
mdefine_line|#define VIRT_TO_BUS(a) (uint32_t)virt_to_bus((void *)(a))
id|stack_sg.ds_addr
op_assign
id|VIRT_TO_BUS
c_func
(paren
id|buf
)paren
suffix:semicolon
macro_line|#endif
id|stack_sg.ds_len
op_assign
id|dmat-&gt;maxsize
suffix:semicolon
id|cb
c_func
(paren
id|cb_arg
comma
op_amp
id|stack_sg
comma
multiline_comment|/*nseg*/
l_int|1
comma
multiline_comment|/*error*/
l_int|0
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahc_dmamap_destroy
id|ahc_dmamap_destroy
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|bus_dma_tag_t
id|dmat
comma
id|bus_dmamap_t
id|map
)paren
(brace
multiline_comment|/*&n;&t; * The map may is NULL in our &lt; 2.3.X implementation.&n;&t; */
r_if
c_cond
(paren
id|map
op_ne
l_int|NULL
)paren
id|free
c_func
(paren
id|map
comma
id|M_DEVBUF
)paren
suffix:semicolon
)brace
r_int
DECL|function|ahc_dmamap_unload
id|ahc_dmamap_unload
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|bus_dma_tag_t
id|dmat
comma
id|bus_dmamap_t
id|map
)paren
(brace
multiline_comment|/* Nothing to do */
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/********************* Platform Dependent Functions ***************************/
multiline_comment|/*&n; * Compare &quot;left hand&quot; softc with &quot;right hand&quot; softc, returning:&n; * &lt; 0 - lahc has a lower priority than rahc&n; *   0 - Softcs are equal&n; * &gt; 0 - lahc has a higher priority than rahc&n; */
r_int
DECL|function|ahc_softc_comp
id|ahc_softc_comp
c_func
(paren
r_struct
id|ahc_softc
op_star
id|lahc
comma
r_struct
id|ahc_softc
op_star
id|rahc
)paren
(brace
r_int
id|value
suffix:semicolon
r_int
id|rvalue
suffix:semicolon
r_int
id|lvalue
suffix:semicolon
multiline_comment|/*&n;&t; * Under Linux, cards are ordered as follows:&n;&t; *&t;1) VLB/EISA BIOS enabled devices sorted by BIOS address.&n;&t; *&t;2) PCI devices with BIOS enabled sorted by bus/slot/func.&n;&t; *&t;3) All remaining VLB/EISA devices sorted by ioport.&n;&t; *&t;4) All remaining PCI devices sorted by bus/slot/func.&n;&t; */
id|value
op_assign
(paren
id|lahc-&gt;flags
op_amp
id|AHC_BIOS_ENABLED
)paren
op_minus
(paren
id|rahc-&gt;flags
op_amp
id|AHC_BIOS_ENABLED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_ne
l_int|0
)paren
multiline_comment|/* Controllers with BIOS enabled have a *higher* priority */
r_return
(paren
id|value
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Same BIOS setting, now sort based on bus type.&n;&t; * EISA and VL controllers sort together.  EISA/VL&n;&t; * have higher priority than PCI.&n;&t; */
id|rvalue
op_assign
(paren
id|rahc-&gt;chip
op_amp
id|AHC_BUS_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rvalue
op_eq
id|AHC_VL
)paren
id|rvalue
op_assign
id|AHC_EISA
suffix:semicolon
id|lvalue
op_assign
(paren
id|lahc-&gt;chip
op_amp
id|AHC_BUS_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lvalue
op_eq
id|AHC_VL
)paren
id|lvalue
op_assign
id|AHC_EISA
suffix:semicolon
id|value
op_assign
id|rvalue
op_minus
id|lvalue
suffix:semicolon
r_if
c_cond
(paren
id|value
op_ne
l_int|0
)paren
r_return
(paren
id|value
)paren
suffix:semicolon
multiline_comment|/* Still equal.  Sort by BIOS address, ioport, or bus/slot/func. */
r_switch
c_cond
(paren
id|rvalue
)paren
(brace
macro_line|#ifdef CONFIG_PCI
r_case
id|AHC_PCI
suffix:colon
(brace
r_char
id|primary_channel
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_reverse_scan
op_ne
l_int|0
)paren
id|value
op_assign
id|ahc_get_pci_bus
c_func
(paren
id|lahc-&gt;dev_softc
)paren
op_minus
id|ahc_get_pci_bus
c_func
(paren
id|rahc-&gt;dev_softc
)paren
suffix:semicolon
r_else
id|value
op_assign
id|ahc_get_pci_bus
c_func
(paren
id|rahc-&gt;dev_softc
)paren
op_minus
id|ahc_get_pci_bus
c_func
(paren
id|lahc-&gt;dev_softc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_ne
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_reverse_scan
op_ne
l_int|0
)paren
id|value
op_assign
id|ahc_get_pci_slot
c_func
(paren
id|lahc-&gt;dev_softc
)paren
op_minus
id|ahc_get_pci_slot
c_func
(paren
id|rahc-&gt;dev_softc
)paren
suffix:semicolon
r_else
id|value
op_assign
id|ahc_get_pci_slot
c_func
(paren
id|rahc-&gt;dev_softc
)paren
op_minus
id|ahc_get_pci_slot
c_func
(paren
id|lahc-&gt;dev_softc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_ne
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * On multi-function devices, the user can choose&n;&t;&t; * to have function 1 probed before function 0.&n;&t;&t; * Give whichever channel is the primary channel&n;&t;&t; * the highest priority.&n;&t;&t; */
id|primary_channel
op_assign
(paren
id|lahc-&gt;flags
op_amp
id|AHC_PRIMARY_CHANNEL
)paren
op_plus
l_char|&squot;A&squot;
suffix:semicolon
id|value
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|lahc-&gt;channel
op_eq
id|primary_channel
)paren
id|value
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif
r_case
id|AHC_EISA
suffix:colon
r_if
c_cond
(paren
(paren
id|rahc-&gt;flags
op_amp
id|AHC_BIOS_ENABLED
)paren
op_ne
l_int|0
)paren
(brace
id|value
op_assign
id|rahc-&gt;platform_data-&gt;bios_address
op_minus
id|lahc-&gt;platform_data-&gt;bios_address
suffix:semicolon
)brace
r_else
(brace
id|value
op_assign
id|rahc-&gt;bsh.ioport
op_minus
id|lahc-&gt;bsh.ioport
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;ahc_softc_sort: invalid bus type&quot;
)paren
suffix:semicolon
)brace
r_return
(paren
id|value
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahc_linux_setup_tag_info_global
id|ahc_linux_setup_tag_info_global
c_func
(paren
r_char
op_star
id|p
)paren
(brace
r_int
id|tags
comma
id|i
comma
id|j
suffix:semicolon
id|tags
op_assign
id|simple_strtoul
c_func
(paren
id|p
op_plus
l_int|1
comma
l_int|NULL
comma
l_int|0
)paren
op_amp
l_int|0xff
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Setting Global Tags= %d&bslash;n&quot;
comma
id|tags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_ELEMENTS
c_func
(paren
id|aic7xxx_tag_info
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|AHC_NUM_TARGETS
suffix:semicolon
id|j
op_increment
)paren
(brace
id|aic7xxx_tag_info
(braket
id|i
)braket
dot
id|tag_commands
(braket
id|j
)braket
op_assign
id|tags
suffix:semicolon
)brace
)brace
)brace
r_static
r_void
DECL|function|ahc_linux_setup_tag_info
id|ahc_linux_setup_tag_info
c_func
(paren
id|u_long
id|arg
comma
r_int
id|instance
comma
r_int
id|targ
comma
r_int32
id|value
)paren
(brace
r_if
c_cond
(paren
(paren
id|instance
op_ge
l_int|0
)paren
op_logical_and
(paren
id|targ
op_ge
l_int|0
)paren
op_logical_and
(paren
id|instance
OL
id|NUM_ELEMENTS
c_func
(paren
id|aic7xxx_tag_info
)paren
)paren
op_logical_and
(paren
id|targ
OL
id|AHC_NUM_TARGETS
)paren
)paren
(brace
id|aic7xxx_tag_info
(braket
id|instance
)braket
dot
id|tag_commands
(braket
id|targ
)braket
op_assign
id|value
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
)paren
id|printf
c_func
(paren
l_string|&quot;tag_info[%d:%d] = %d&bslash;n&quot;
comma
id|instance
comma
id|targ
comma
id|value
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|ahc_linux_setup_dv
id|ahc_linux_setup_dv
c_func
(paren
id|u_long
id|arg
comma
r_int
id|instance
comma
r_int
id|targ
comma
r_int32
id|value
)paren
(brace
r_if
c_cond
(paren
(paren
id|instance
op_ge
l_int|0
)paren
op_logical_and
(paren
id|instance
OL
id|NUM_ELEMENTS
c_func
(paren
id|aic7xxx_dv_settings
)paren
)paren
)paren
(brace
id|aic7xxx_dv_settings
(braket
id|instance
)braket
op_assign
id|value
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
)paren
id|printf
c_func
(paren
l_string|&quot;dv[%d] = %d&bslash;n&quot;
comma
id|instance
comma
id|value
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Handle Linux boot parameters. This routine allows for assigning a value&n; * to a parameter with a &squot;:&squot; between the parameter and the value.&n; * ie. aic7xxx=stpwlev:1,extended&n; */
r_static
r_int
DECL|function|aic7xxx_setup
id|aic7xxx_setup
c_func
(paren
r_char
op_star
id|s
)paren
(brace
r_int
id|i
comma
id|n
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
r_char
op_star
id|end
suffix:semicolon
r_static
r_struct
(brace
r_const
r_char
op_star
id|name
suffix:semicolon
r_uint32
op_star
id|flag
suffix:semicolon
)brace
id|options
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;extended&quot;
comma
op_amp
id|aic7xxx_extended
)brace
comma
(brace
l_string|&quot;no_reset&quot;
comma
op_amp
id|aic7xxx_no_reset
)brace
comma
(brace
l_string|&quot;verbose&quot;
comma
op_amp
id|aic7xxx_verbose
)brace
comma
(brace
l_string|&quot;allow_memio&quot;
comma
op_amp
id|aic7xxx_allow_memio
)brace
comma
macro_line|#ifdef AHC_DEBUG
(brace
l_string|&quot;debug&quot;
comma
op_amp
id|ahc_debug
)brace
comma
macro_line|#endif
(brace
l_string|&quot;reverse_scan&quot;
comma
op_amp
id|aic7xxx_reverse_scan
)brace
comma
(brace
l_string|&quot;no_probe&quot;
comma
op_amp
id|aic7xxx_probe_eisa_vl
)brace
comma
(brace
l_string|&quot;probe_eisa_vl&quot;
comma
op_amp
id|aic7xxx_probe_eisa_vl
)brace
comma
(brace
l_string|&quot;periodic_otag&quot;
comma
op_amp
id|aic7xxx_periodic_otag
)brace
comma
(brace
l_string|&quot;pci_parity&quot;
comma
op_amp
id|aic7xxx_pci_parity
)brace
comma
(brace
l_string|&quot;seltime&quot;
comma
op_amp
id|aic7xxx_seltime
)brace
comma
(brace
l_string|&quot;tag_info&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;global_tag_depth&quot;
comma
l_int|NULL
)brace
comma
(brace
l_string|&quot;dv&quot;
comma
l_int|NULL
)brace
)brace
suffix:semicolon
id|end
op_assign
id|strchr
c_func
(paren
id|s
comma
l_char|&squot;&bslash;0&squot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * XXX ia64 gcc isn&squot;t smart enough to know that NUM_ELEMENTS&n;&t; * will never be 0 in this case.&n;&t; */
id|n
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|p
op_assign
id|strsep
c_func
(paren
op_amp
id|s
comma
l_string|&quot;,.&quot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_star
id|p
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_ELEMENTS
c_func
(paren
id|options
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|n
op_assign
id|strlen
c_func
(paren
id|options
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|options
(braket
id|i
)braket
dot
id|name
comma
id|p
comma
id|n
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|NUM_ELEMENTS
c_func
(paren
id|options
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|p
comma
l_string|&quot;global_tag_depth&quot;
comma
id|n
)paren
op_eq
l_int|0
)paren
(brace
id|ahc_linux_setup_tag_info_global
c_func
(paren
id|p
op_plus
id|n
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|p
comma
l_string|&quot;tag_info&quot;
comma
id|n
)paren
op_eq
l_int|0
)paren
(brace
id|s
op_assign
id|aic_parse_brace_option
c_func
(paren
l_string|&quot;tag_info&quot;
comma
id|p
op_plus
id|n
comma
id|end
comma
l_int|2
comma
id|ahc_linux_setup_tag_info
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|p
comma
l_string|&quot;dv&quot;
comma
id|n
)paren
op_eq
l_int|0
)paren
(brace
id|s
op_assign
id|aic_parse_brace_option
c_func
(paren
l_string|&quot;dv&quot;
comma
id|p
op_plus
id|n
comma
id|end
comma
l_int|1
comma
id|ahc_linux_setup_dv
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|p
(braket
id|n
)braket
op_eq
l_char|&squot;:&squot;
)paren
(brace
op_star
(paren
id|options
(braket
id|i
)braket
dot
id|flag
)paren
op_assign
id|simple_strtoul
c_func
(paren
id|p
op_plus
id|n
op_plus
l_int|1
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|p
comma
l_string|&quot;verbose&quot;
comma
id|n
)paren
op_eq
l_int|0
)paren
(brace
op_star
(paren
id|options
(braket
id|i
)braket
dot
id|flag
)paren
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
op_star
(paren
id|options
(braket
id|i
)braket
dot
id|flag
)paren
op_xor_assign
l_int|0xFFFFFFFF
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#if LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,3,0)
id|__setup
c_func
(paren
l_string|&quot;aic7xxx=&quot;
comma
id|aic7xxx_setup
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|aic7xxx_verbose
r_uint32
id|aic7xxx_verbose
suffix:semicolon
r_int
DECL|function|ahc_linux_register_host
id|ahc_linux_register_host
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|Scsi_Host_Template
op_star
r_template
)paren
(brace
r_char
id|buf
(braket
l_int|80
)braket
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
r_char
op_star
id|new_name
suffix:semicolon
id|u_long
id|s
suffix:semicolon
id|u_int
id|targ_offset
suffix:semicolon
r_template
op_member_access_from_pointer
id|name
op_assign
id|ahc-&gt;description
suffix:semicolon
id|host
op_assign
id|scsi_host_alloc
c_func
(paren
r_template
comma
r_sizeof
(paren
r_struct
id|ahc_softc
op_star
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|host
op_eq
l_int|NULL
)paren
r_return
(paren
id|ENOMEM
)paren
suffix:semicolon
op_star
(paren
(paren
r_struct
id|ahc_softc
op_star
op_star
)paren
id|host-&gt;hostdata
)paren
op_assign
id|ahc
suffix:semicolon
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,5,0)
id|scsi_assign_lock
c_func
(paren
id|host
comma
op_amp
id|ahc-&gt;platform_data-&gt;spin_lock
)paren
suffix:semicolon
macro_line|#elif AHC_SCSI_HAS_HOST_LOCK != 0
id|host-&gt;lock
op_assign
op_amp
id|ahc-&gt;platform_data-&gt;spin_lock
suffix:semicolon
macro_line|#endif
id|ahc-&gt;platform_data-&gt;host
op_assign
id|host
suffix:semicolon
id|host-&gt;can_queue
op_assign
id|AHC_MAX_QUEUE
suffix:semicolon
id|host-&gt;cmd_per_lun
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* XXX No way to communicate the ID for multiple channels */
id|host-&gt;this_id
op_assign
id|ahc-&gt;our_id
suffix:semicolon
id|host-&gt;irq
op_assign
id|ahc-&gt;platform_data-&gt;irq
suffix:semicolon
id|host-&gt;max_id
op_assign
(paren
id|ahc-&gt;features
op_amp
id|AHC_WIDE
)paren
ques
c_cond
l_int|16
suffix:colon
l_int|8
suffix:semicolon
id|host-&gt;max_lun
op_assign
id|AHC_NUM_LUNS
suffix:semicolon
id|host-&gt;max_channel
op_assign
(paren
id|ahc-&gt;features
op_amp
id|AHC_TWIN
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|host-&gt;sg_tablesize
op_assign
id|AHC_NSEG
suffix:semicolon
id|ahc_set_unit
c_func
(paren
id|ahc
comma
id|ahc_linux_next_unit
c_func
(paren
)paren
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;scsi%d&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|new_name
op_assign
id|malloc
c_func
(paren
id|strlen
c_func
(paren
id|buf
)paren
op_plus
l_int|1
comma
id|M_DEVBUF
comma
id|M_NOWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_name
op_ne
l_int|NULL
)paren
(brace
id|strcpy
c_func
(paren
id|new_name
comma
id|buf
)paren
suffix:semicolon
id|ahc_set_name
c_func
(paren
id|ahc
comma
id|new_name
)paren
suffix:semicolon
)brace
id|host-&gt;unique_id
op_assign
id|ahc-&gt;unit
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,4,4) &amp;&amp; &bslash;&n;    LINUX_VERSION_CODE  &lt; KERNEL_VERSION(2,5,0)
id|scsi_set_pci_device
c_func
(paren
id|host
comma
id|ahc-&gt;dev_softc
)paren
suffix:semicolon
macro_line|#endif
id|ahc_linux_initialize_scsi_bus
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
id|ahc-&gt;platform_data-&gt;dv_pid
op_assign
id|kernel_thread
c_func
(paren
id|ahc_linux_dv_thread
comma
id|ahc
comma
l_int|0
)paren
suffix:semicolon
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;platform_data-&gt;dv_pid
OL
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: Failed to create DV thread, error= %d&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|ahc-&gt;platform_data-&gt;dv_pid
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ahc-&gt;platform_data-&gt;dv_pid
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Initially allocate *all* of our linux target objects&n;&t; * so that the DV thread will scan them all in parallel&n;&t; * just after driver initialization.  Any device that&n;&t; * does not exist will have its target object destroyed&n;&t; * by the selection timeout handler.  In the case of a&n;&t; * device that appears after the initial DV scan, async&n;&t; * negotiation will occur for the first command, and DV&n;&t; * will comence should that first command be successful.&n;&t; */
r_for
c_loop
(paren
id|targ_offset
op_assign
l_int|0
suffix:semicolon
id|targ_offset
OL
id|host-&gt;max_id
op_star
(paren
id|host-&gt;max_channel
op_plus
l_int|1
)paren
suffix:semicolon
id|targ_offset
op_increment
)paren
(brace
id|u_int
id|channel
suffix:semicolon
id|u_int
id|target
suffix:semicolon
id|channel
op_assign
l_int|0
suffix:semicolon
id|target
op_assign
id|targ_offset
suffix:semicolon
r_if
c_cond
(paren
id|target
OG
l_int|7
op_logical_and
(paren
id|ahc-&gt;features
op_amp
id|AHC_TWIN
)paren
op_ne
l_int|0
)paren
(brace
id|channel
op_assign
l_int|1
suffix:semicolon
id|target
op_and_assign
l_int|0x7
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Skip our own ID.  Some Compaq/HP storage devices&n;&t;&t; * have enclosure management devices that respond to&n;&t;&t; * single bit selection (i.e. selecting ourselves).&n;&t;&t; * It is expected that either an external application&n;&t;&t; * or a modified kernel will be used to probe this&n;&t;&t; * ID if it is appropriate.  To accommodate these&n;&t;&t; * installations, ahc_linux_alloc_target() will allocate&n;&t;&t; * for our ID if asked to do so.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|channel
op_eq
l_int|0
op_logical_and
id|target
op_eq
id|ahc-&gt;our_id
)paren
op_logical_or
(paren
id|channel
op_eq
l_int|1
op_logical_and
id|target
op_eq
id|ahc-&gt;our_id_b
)paren
)paren
r_continue
suffix:semicolon
id|ahc_linux_alloc_target
c_func
(paren
id|ahc
comma
id|channel
comma
id|target
)paren
suffix:semicolon
)brace
id|ahc_intr_enable
c_func
(paren
id|ahc
comma
id|TRUE
)paren
suffix:semicolon
id|ahc_linux_start_dv
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,5,0)
id|scsi_add_host
c_func
(paren
id|host
comma
(paren
id|ahc-&gt;dev_softc
ques
c_cond
op_amp
id|ahc-&gt;dev_softc-&gt;dev
suffix:colon
l_int|NULL
)paren
)paren
suffix:semicolon
multiline_comment|/* XXX handle failure */
id|scsi_scan_host
c_func
(paren
id|host
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_uint64
DECL|function|ahc_linux_get_memsize
id|ahc_linux_get_memsize
c_func
(paren
r_void
)paren
(brace
r_struct
id|sysinfo
id|si
suffix:semicolon
id|si_meminfo
c_func
(paren
op_amp
id|si
)paren
suffix:semicolon
r_return
(paren
(paren
r_uint64
)paren
id|si.totalram
op_lshift
id|PAGE_SHIFT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Find the smallest available unit number to use&n; * for a new device.  We don&squot;t just use a static&n; * count to handle the &quot;repeated hot-(un)plug&quot;&n; * scenario.&n; */
r_static
r_int
DECL|function|ahc_linux_next_unit
id|ahc_linux_next_unit
c_func
(paren
r_void
)paren
(brace
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
r_int
id|unit
suffix:semicolon
id|unit
op_assign
l_int|0
suffix:semicolon
id|retry
suffix:colon
id|TAILQ_FOREACH
c_func
(paren
id|ahc
comma
op_amp
id|ahc_tailq
comma
id|links
)paren
(brace
r_if
c_cond
(paren
id|ahc-&gt;unit
op_eq
id|unit
)paren
(brace
id|unit
op_increment
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
)brace
r_return
(paren
id|unit
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Place the SCSI bus into a known state by either resetting it,&n; * or forcing transfer negotiations on the next command to any&n; * target.&n; */
r_void
DECL|function|ahc_linux_initialize_scsi_bus
id|ahc_linux_initialize_scsi_bus
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|numtarg
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
id|numtarg
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_no_reset
op_ne
l_int|0
)paren
id|ahc-&gt;flags
op_and_assign
op_complement
(paren
id|AHC_RESET_BUS_A
op_or
id|AHC_RESET_BUS_B
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;flags
op_amp
id|AHC_RESET_BUS_A
)paren
op_ne
l_int|0
)paren
id|ahc_reset_channel
c_func
(paren
id|ahc
comma
l_char|&squot;A&squot;
comma
multiline_comment|/*initiate_reset*/
id|TRUE
)paren
suffix:semicolon
r_else
id|numtarg
op_assign
(paren
id|ahc-&gt;features
op_amp
id|AHC_WIDE
)paren
ques
c_cond
l_int|16
suffix:colon
l_int|8
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_TWIN
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|ahc-&gt;flags
op_amp
id|AHC_RESET_BUS_B
)paren
op_ne
l_int|0
)paren
(brace
id|ahc_reset_channel
c_func
(paren
id|ahc
comma
l_char|&squot;B&squot;
comma
multiline_comment|/*initiate_reset*/
id|TRUE
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|numtarg
op_eq
l_int|0
)paren
id|i
op_assign
l_int|8
suffix:semicolon
id|numtarg
op_add_assign
l_int|8
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Force negotiation to async for all targets that&n;&t; * will not see an initial bus reset.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|numtarg
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ahc_devinfo
id|devinfo
suffix:semicolon
r_struct
id|ahc_initiator_tinfo
op_star
id|tinfo
suffix:semicolon
r_struct
id|ahc_tmode_tstate
op_star
id|tstate
suffix:semicolon
id|u_int
id|our_id
suffix:semicolon
id|u_int
id|target_id
suffix:semicolon
r_char
id|channel
suffix:semicolon
id|channel
op_assign
l_char|&squot;A&squot;
suffix:semicolon
id|our_id
op_assign
id|ahc-&gt;our_id
suffix:semicolon
id|target_id
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|7
op_logical_and
(paren
id|ahc-&gt;features
op_amp
id|AHC_TWIN
)paren
op_ne
l_int|0
)paren
(brace
id|channel
op_assign
l_char|&squot;B&squot;
suffix:semicolon
id|our_id
op_assign
id|ahc-&gt;our_id_b
suffix:semicolon
id|target_id
op_assign
id|i
op_mod
l_int|8
suffix:semicolon
)brace
id|tinfo
op_assign
id|ahc_fetch_transinfo
c_func
(paren
id|ahc
comma
id|channel
comma
id|our_id
comma
id|target_id
comma
op_amp
id|tstate
)paren
suffix:semicolon
id|ahc_compile_devinfo
c_func
(paren
op_amp
id|devinfo
comma
id|our_id
comma
id|target_id
comma
id|CAM_LUN_WILDCARD
comma
id|channel
comma
id|ROLE_INITIATOR
)paren
suffix:semicolon
id|ahc_update_neg_request
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
comma
id|tstate
comma
id|tinfo
comma
id|AHC_NEG_ALWAYS
)paren
suffix:semicolon
)brace
multiline_comment|/* Give the bus some time to recover */
r_if
c_cond
(paren
(paren
id|ahc-&gt;flags
op_amp
(paren
id|AHC_RESET_BUS_A
op_or
id|AHC_RESET_BUS_B
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|ahc_linux_freeze_simq
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;reset_timer
)paren
suffix:semicolon
id|ahc-&gt;platform_data-&gt;reset_timer.data
op_assign
(paren
id|u_long
)paren
id|ahc
suffix:semicolon
id|ahc-&gt;platform_data-&gt;reset_timer.expires
op_assign
id|jiffies
op_plus
(paren
id|AIC7XXX_RESET_DELAY
op_star
id|HZ
)paren
op_div
l_int|1000
suffix:semicolon
id|ahc-&gt;platform_data-&gt;reset_timer.function
op_assign
id|ahc_linux_release_simq
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;reset_timer
)paren
suffix:semicolon
)brace
)brace
r_int
DECL|function|ahc_platform_alloc
id|ahc_platform_alloc
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_void
op_star
id|platform_arg
)paren
(brace
id|ahc-&gt;platform_data
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ahc_platform_data
)paren
comma
id|M_DEVBUF
comma
id|M_NOWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;platform_data
op_eq
l_int|NULL
)paren
r_return
(paren
id|ENOMEM
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ahc-&gt;platform_data
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ahc_platform_data
)paren
)paren
suffix:semicolon
id|TAILQ_INIT
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;completeq
)paren
suffix:semicolon
id|TAILQ_INIT
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;device_runq
)paren
suffix:semicolon
id|ahc-&gt;platform_data-&gt;irq
op_assign
id|AHC_LINUX_NOIRQ
suffix:semicolon
id|ahc-&gt;platform_data-&gt;hw_dma_mask
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
id|ahc_lockinit
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_done_lockinit
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;completeq_timer
)paren
suffix:semicolon
id|ahc-&gt;platform_data-&gt;completeq_timer.data
op_assign
(paren
id|u_long
)paren
id|ahc
suffix:semicolon
id|ahc-&gt;platform_data-&gt;completeq_timer.function
op_assign
(paren
id|ahc_linux_callback_t
op_star
)paren
id|ahc_linux_thread_run_complete_queue
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,3,0)
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;eh_sem
)paren
suffix:semicolon
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;dv_sem
)paren
suffix:semicolon
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;dv_cmd_sem
)paren
suffix:semicolon
macro_line|#else
id|ahc-&gt;platform_data-&gt;eh_sem
op_assign
id|MUTEX_LOCKED
suffix:semicolon
id|ahc-&gt;platform_data-&gt;dv_sem
op_assign
id|MUTEX_LOCKED
suffix:semicolon
id|ahc-&gt;platform_data-&gt;dv_cmd_sem
op_assign
id|MUTEX_LOCKED
suffix:semicolon
macro_line|#endif
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,4,0)
id|tasklet_init
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;runq_tasklet
comma
id|ahc_runq_tasklet
comma
(paren
r_int
r_int
)paren
id|ahc
)paren
suffix:semicolon
macro_line|#endif
id|ahc-&gt;seltime
op_assign
(paren
id|aic7xxx_seltime
op_amp
l_int|0x3
)paren
op_lshift
l_int|4
suffix:semicolon
id|ahc-&gt;seltime_b
op_assign
(paren
id|aic7xxx_seltime
op_amp
l_int|0x3
)paren
op_lshift
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_pci_parity
op_eq
l_int|0
)paren
id|ahc-&gt;flags
op_or_assign
id|AHC_DISABLE_PCI_PERR
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahc_platform_free
id|ahc_platform_free
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_struct
id|ahc_linux_target
op_star
id|targ
suffix:semicolon
r_struct
id|ahc_linux_device
op_star
id|dev
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;platform_data
op_ne
l_int|NULL
)paren
(brace
id|del_timer_sync
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;completeq_timer
)paren
suffix:semicolon
id|ahc_linux_kill_dv_thread
c_func
(paren
id|ahc
)paren
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,4,0)
id|tasklet_kill
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;runq_tasklet
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|ahc-&gt;platform_data-&gt;host
op_ne
l_int|NULL
)paren
(brace
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,5,0)
id|scsi_remove_host
c_func
(paren
id|ahc-&gt;platform_data-&gt;host
)paren
suffix:semicolon
macro_line|#endif
id|scsi_host_put
c_func
(paren
id|ahc-&gt;platform_data-&gt;host
)paren
suffix:semicolon
)brace
multiline_comment|/* destroy all of the device and target objects */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AHC_NUM_TARGETS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|targ
op_assign
id|ahc-&gt;platform_data-&gt;targets
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|targ
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Keep target around through the loop. */
id|targ-&gt;refcount
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|AHC_NUM_LUNS
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|targ-&gt;devices
(braket
id|j
)braket
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|dev
op_assign
id|targ-&gt;devices
(braket
id|j
)braket
suffix:semicolon
id|ahc_linux_free_device
c_func
(paren
id|ahc
comma
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Forcibly free the target now that&n;&t;&t;&t;&t; * all devices are gone.&n;&t;&t;&t;&t; */
id|ahc_linux_free_target
c_func
(paren
id|ahc
comma
id|targ
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ahc-&gt;platform_data-&gt;irq
op_ne
id|AHC_LINUX_NOIRQ
)paren
id|free_irq
c_func
(paren
id|ahc-&gt;platform_data-&gt;irq
comma
id|ahc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;tag
op_eq
id|BUS_SPACE_PIO
op_logical_and
id|ahc-&gt;bsh.ioport
op_ne
l_int|0
)paren
id|release_region
c_func
(paren
id|ahc-&gt;bsh.ioport
comma
l_int|256
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;tag
op_eq
id|BUS_SPACE_MEMIO
op_logical_and
id|ahc-&gt;bsh.maddr
op_ne
l_int|NULL
)paren
(brace
id|u_long
id|base_addr
suffix:semicolon
id|base_addr
op_assign
(paren
id|u_long
)paren
id|ahc-&gt;bsh.maddr
suffix:semicolon
id|base_addr
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|base_addr
)paren
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,4,0)
id|release_mem_region
c_func
(paren
id|ahc-&gt;platform_data-&gt;mem_busaddr
comma
l_int|0x1000
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,4,0) &amp;&amp; &bslash;&n;    LINUX_VERSION_CODE  &lt; KERNEL_VERSION(2,5,0)
multiline_comment|/*&n;&t;&t; * In 2.4 we detach from the scsi midlayer before the PCI&n;&t;&t; * layer invokes our remove callback.  No per-instance&n;&t;&t; * detach is provided, so we must reach inside the PCI&n;&t;&t; * subsystem&squot;s internals and detach our driver manually.&n;&t;&t; */
r_if
c_cond
(paren
id|ahc-&gt;dev_softc
op_ne
l_int|NULL
)paren
id|ahc-&gt;dev_softc-&gt;driver
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
id|free
c_func
(paren
id|ahc-&gt;platform_data
comma
id|M_DEVBUF
)paren
suffix:semicolon
)brace
)brace
r_void
DECL|function|ahc_platform_freeze_devq
id|ahc_platform_freeze_devq
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|scb
op_star
id|scb
)paren
(brace
id|ahc_platform_abort_scbs
c_func
(paren
id|ahc
comma
id|SCB_GET_TARGET
c_func
(paren
id|ahc
comma
id|scb
)paren
comma
id|SCB_GET_CHANNEL
c_func
(paren
id|ahc
comma
id|scb
)paren
comma
id|SCB_GET_LUN
c_func
(paren
id|scb
)paren
comma
id|SCB_LIST_NULL
comma
id|ROLE_UNKNOWN
comma
id|CAM_REQUEUE_REQ
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahc_platform_set_tags
id|ahc_platform_set_tags
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
comma
id|ahc_queue_alg
id|alg
)paren
(brace
r_struct
id|ahc_linux_device
op_star
id|dev
suffix:semicolon
r_int
id|was_queuing
suffix:semicolon
r_int
id|now_queuing
suffix:semicolon
id|dev
op_assign
id|ahc_linux_get_device
c_func
(paren
id|ahc
comma
id|devinfo-&gt;channel
op_minus
l_char|&squot;A&squot;
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
comma
multiline_comment|/*alloc*/
id|FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|was_queuing
op_assign
id|dev-&gt;flags
op_amp
(paren
id|AHC_DEV_Q_BASIC
op_or
id|AHC_DEV_Q_TAGGED
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|alg
)paren
(brace
r_default
suffix:colon
r_case
id|AHC_QUEUE_NONE
suffix:colon
id|now_queuing
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AHC_QUEUE_BASIC
suffix:colon
id|now_queuing
op_assign
id|AHC_DEV_Q_BASIC
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AHC_QUEUE_TAGGED
suffix:colon
id|now_queuing
op_assign
id|AHC_DEV_Q_TAGGED
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|AHC_DEV_FREEZE_TIL_EMPTY
)paren
op_eq
l_int|0
op_logical_and
(paren
id|was_queuing
op_ne
id|now_queuing
)paren
op_logical_and
(paren
id|dev-&gt;active
op_ne
l_int|0
)paren
)paren
(brace
id|dev-&gt;flags
op_or_assign
id|AHC_DEV_FREEZE_TIL_EMPTY
suffix:semicolon
id|dev-&gt;qfrozen
op_increment
suffix:semicolon
)brace
id|dev-&gt;flags
op_and_assign
op_complement
(paren
id|AHC_DEV_Q_BASIC
op_or
id|AHC_DEV_Q_TAGGED
op_or
id|AHC_DEV_PERIODIC_OTAG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|now_queuing
)paren
(brace
id|u_int
id|usertags
suffix:semicolon
id|usertags
op_assign
id|ahc_linux_user_tagdepth
c_func
(paren
id|ahc
comma
id|devinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|was_queuing
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Start out agressively and allow our&n;&t;&t;&t; * dynamic queue depth algorithm to take&n;&t;&t;&t; * care of the rest.&n;&t;&t;&t; */
id|dev-&gt;maxtags
op_assign
id|usertags
suffix:semicolon
id|dev-&gt;openings
op_assign
id|dev-&gt;maxtags
op_minus
id|dev-&gt;active
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;maxtags
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Queueing is disabled by the user.&n;&t;&t;&t; */
id|dev-&gt;openings
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|alg
op_eq
id|AHC_QUEUE_TAGGED
)paren
(brace
id|dev-&gt;flags
op_or_assign
id|AHC_DEV_Q_TAGGED
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_periodic_otag
op_ne
l_int|0
)paren
id|dev-&gt;flags
op_or_assign
id|AHC_DEV_PERIODIC_OTAG
suffix:semicolon
)brace
r_else
id|dev-&gt;flags
op_or_assign
id|AHC_DEV_Q_BASIC
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We can only have one opening. */
id|dev-&gt;maxtags
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;openings
op_assign
l_int|1
op_minus
id|dev-&gt;active
suffix:semicolon
)brace
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,5,0)
r_if
c_cond
(paren
id|dev-&gt;scsi_device
op_ne
l_int|NULL
)paren
(brace
r_switch
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
(paren
id|AHC_DEV_Q_BASIC
op_or
id|AHC_DEV_Q_TAGGED
)paren
)paren
)paren
(brace
r_case
id|AHC_DEV_Q_BASIC
suffix:colon
id|scsi_adjust_queue_depth
c_func
(paren
id|dev-&gt;scsi_device
comma
id|MSG_SIMPLE_TASK
comma
id|dev-&gt;openings
op_plus
id|dev-&gt;active
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AHC_DEV_Q_TAGGED
suffix:colon
id|scsi_adjust_queue_depth
c_func
(paren
id|dev-&gt;scsi_device
comma
id|MSG_ORDERED_TASK
comma
id|dev-&gt;openings
op_plus
id|dev-&gt;active
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * We allow the OS to queue 2 untagged transactions to&n;&t;&t;&t; * us at any time even though we can only execute them&n;&t;&t;&t; * serially on the controller/device.  This should&n;&t;&t;&t; * remove some latency.&n;&t;&t;&t; */
id|scsi_adjust_queue_depth
c_func
(paren
id|dev-&gt;scsi_device
comma
multiline_comment|/*NON-TAGGED*/
l_int|0
comma
multiline_comment|/*queue depth*/
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#endif
)brace
r_int
DECL|function|ahc_platform_abort_scbs
id|ahc_platform_abort_scbs
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_int
id|target
comma
r_char
id|channel
comma
r_int
id|lun
comma
id|u_int
id|tag
comma
id|role_t
id|role
comma
r_uint32
id|status
)paren
(brace
r_int
id|chan
suffix:semicolon
r_int
id|maxchan
suffix:semicolon
r_int
id|targ
suffix:semicolon
r_int
id|maxtarg
suffix:semicolon
r_int
id|clun
suffix:semicolon
r_int
id|maxlun
suffix:semicolon
r_int
id|count
suffix:semicolon
r_if
c_cond
(paren
id|tag
op_ne
id|SCB_LIST_NULL
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|chan
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|channel
op_ne
id|ALL_CHANNELS
)paren
(brace
id|chan
op_assign
id|channel
op_minus
l_char|&squot;A&squot;
suffix:semicolon
id|maxchan
op_assign
id|chan
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|maxchan
op_assign
(paren
id|ahc-&gt;features
op_amp
id|AHC_TWIN
)paren
ques
c_cond
l_int|2
suffix:colon
l_int|1
suffix:semicolon
)brace
id|targ
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|target
op_ne
id|CAM_TARGET_WILDCARD
)paren
(brace
id|targ
op_assign
id|target
suffix:semicolon
id|maxtarg
op_assign
id|targ
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|maxtarg
op_assign
(paren
id|ahc-&gt;features
op_amp
id|AHC_WIDE
)paren
ques
c_cond
l_int|16
suffix:colon
l_int|8
suffix:semicolon
)brace
id|clun
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|lun
op_ne
id|CAM_LUN_WILDCARD
)paren
(brace
id|clun
op_assign
id|lun
suffix:semicolon
id|maxlun
op_assign
id|clun
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|maxlun
op_assign
id|AHC_NUM_LUNS
suffix:semicolon
)brace
id|count
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|chan
OL
id|maxchan
suffix:semicolon
id|chan
op_increment
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|targ
OL
id|maxtarg
suffix:semicolon
id|targ
op_increment
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|clun
OL
id|maxlun
suffix:semicolon
id|clun
op_increment
)paren
(brace
r_struct
id|ahc_linux_device
op_star
id|dev
suffix:semicolon
r_struct
id|ahc_busyq
op_star
id|busyq
suffix:semicolon
r_struct
id|ahc_cmd
op_star
id|acmd
suffix:semicolon
id|dev
op_assign
id|ahc_linux_get_device
c_func
(paren
id|ahc
comma
id|chan
comma
id|targ
comma
id|clun
comma
multiline_comment|/*alloc*/
id|FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|busyq
op_assign
op_amp
id|dev-&gt;busyq
suffix:semicolon
r_while
c_loop
(paren
(paren
id|acmd
op_assign
id|TAILQ_FIRST
c_func
(paren
id|busyq
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
id|cmd
op_assign
op_amp
id|acmd_scsi_cmd
c_func
(paren
id|acmd
)paren
suffix:semicolon
id|TAILQ_REMOVE
c_func
(paren
id|busyq
comma
id|acmd
comma
id|acmd_links.tqe
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
id|cmd-&gt;result
op_assign
id|status
op_lshift
l_int|16
suffix:semicolon
id|ahc_linux_queue_cmd_complete
c_func
(paren
id|ahc
comma
id|cmd
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_return
(paren
id|count
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahc_linux_thread_run_complete_queue
id|ahc_linux_thread_run_complete_queue
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
id|u_long
id|flags
suffix:semicolon
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|flags
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;completeq_timer
)paren
suffix:semicolon
id|ahc-&gt;platform_data-&gt;flags
op_and_assign
op_complement
id|AHC_RUN_CMPLT_Q_TIMER
suffix:semicolon
id|ahc_linux_run_complete_queue
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahc_linux_start_dv
id|ahc_linux_start_dv
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
multiline_comment|/*&n;&t; * Freeze the simq and signal ahc_linux_queue to not let any&n;&t; * more commands through.&n;&t; */
r_if
c_cond
(paren
(paren
id|ahc-&gt;platform_data-&gt;flags
op_amp
id|AHC_DV_ACTIVE
)paren
op_eq
l_int|0
)paren
(brace
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_DV
)paren
id|printf
c_func
(paren
l_string|&quot;%s: Waking DV thread&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
)paren
suffix:semicolon
macro_line|#endif
id|ahc-&gt;platform_data-&gt;flags
op_or_assign
id|AHC_DV_ACTIVE
suffix:semicolon
id|ahc_linux_freeze_simq
c_func
(paren
id|ahc
)paren
suffix:semicolon
multiline_comment|/* Wake up the DV kthread */
id|up
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;dv_sem
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|ahc_linux_kill_dv_thread
id|ahc_linux_kill_dv_thread
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
id|u_long
id|s
suffix:semicolon
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;platform_data-&gt;dv_pid
op_ne
l_int|0
)paren
(brace
id|ahc-&gt;platform_data-&gt;flags
op_or_assign
id|AHC_DV_SHUTDOWN
suffix:semicolon
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;dv_sem
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Use the eh_sem as an indicator that the&n;&t;&t; * dv thread is exiting.  Note that the dv&n;&t;&t; * thread must still return after performing&n;&t;&t; * the up on our semaphore before it has&n;&t;&t; * completely exited this module.  Unfortunately,&n;&t;&t; * there seems to be no easy way to wait for the&n;&t;&t; * exit of a thread for which you are not the&n;&t;&t; * parent (dv threads are parented by init).&n;&t;&t; * Cross your fingers...&n;&t;&t; */
id|down
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;eh_sem
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Mark the dv thread as already dead.  This&n;&t;&t; * avoids attempting to kill it a second time.&n;&t;&t; * This is necessary because we must kill the&n;&t;&t; * DV thread before calling ahc_free() in the&n;&t;&t; * module shutdown case to avoid bogus locking&n;&t;&t; * in the SCSI mid-layer, but we ahc_free() is&n;&t;&t; * called without killing the DV thread in the&n;&t;&t; * instance detach case, so ahc_platform_free()&n;&t;&t; * calls us again to verify that the DV thread&n;&t;&t; * is dead.&n;&t;&t; */
id|ahc-&gt;platform_data-&gt;dv_pid
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|ahc_linux_dv_thread
id|ahc_linux_dv_thread
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
r_int
id|target
suffix:semicolon
id|u_long
id|s
suffix:semicolon
id|ahc
op_assign
(paren
r_struct
id|ahc_softc
op_star
)paren
id|data
suffix:semicolon
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_DV
)paren
id|printf
c_func
(paren
l_string|&quot;Launching DV Thread&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Complete thread creation.&n;&t; */
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,5,0)
multiline_comment|/*&n;&t; * Don&squot;t care about any signals.&n;&t; */
id|siginitsetinv
c_func
(paren
op_amp
id|current-&gt;blocked
comma
l_int|0
)paren
suffix:semicolon
id|daemonize
c_func
(paren
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|current-&gt;comm
comma
l_string|&quot;ahc_dv_%d&quot;
comma
id|ahc-&gt;unit
)paren
suffix:semicolon
macro_line|#else
id|daemonize
c_func
(paren
l_string|&quot;ahc_dv_%d&quot;
comma
id|ahc-&gt;unit
)paren
suffix:semicolon
macro_line|#endif
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; * Use down_interruptible() rather than down() to&n;&t;&t; * avoid inclusion in the load average.&n;&t;&t; */
id|down_interruptible
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;dv_sem
)paren
suffix:semicolon
multiline_comment|/* Check to see if we&squot;ve been signaled to exit */
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;platform_data-&gt;flags
op_amp
id|AHC_DV_SHUTDOWN
)paren
op_ne
l_int|0
)paren
(brace
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_DV
)paren
id|printf
c_func
(paren
l_string|&quot;%s: Beginning Domain Validation&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t; * Wait for any pending commands to drain before proceeding.&n;&t;&t; */
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
r_while
c_loop
(paren
id|LIST_FIRST
c_func
(paren
op_amp
id|ahc-&gt;pending_scbs
)paren
op_ne
l_int|NULL
)paren
(brace
id|ahc-&gt;platform_data-&gt;flags
op_or_assign
id|AHC_DV_WAIT_SIMQ_EMPTY
suffix:semicolon
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
id|down_interruptible
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;dv_sem
)paren
suffix:semicolon
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Wait for the SIMQ to be released so that DV is the&n;&t;&t; * only reason the queue is frozen.&n;&t;&t; */
r_while
c_loop
(paren
id|AHC_DV_SIMQ_FROZEN
c_func
(paren
id|ahc
)paren
op_eq
l_int|0
)paren
(brace
id|ahc-&gt;platform_data-&gt;flags
op_or_assign
id|AHC_DV_WAIT_SIMQ_RELEASE
suffix:semicolon
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
id|down_interruptible
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;dv_sem
)paren
suffix:semicolon
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
)brace
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
r_for
c_loop
(paren
id|target
op_assign
l_int|0
suffix:semicolon
id|target
OL
id|AHC_NUM_TARGETS
suffix:semicolon
id|target
op_increment
)paren
id|ahc_linux_dv_target
c_func
(paren
id|ahc
comma
id|target
)paren
suffix:semicolon
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
id|ahc-&gt;platform_data-&gt;flags
op_and_assign
op_complement
id|AHC_DV_ACTIVE
suffix:semicolon
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Release the SIMQ so that normal commands are&n;&t;&t; * allowed to continue on the bus.&n;&t;&t; */
id|ahc_linux_release_simq
c_func
(paren
(paren
id|u_long
)paren
id|ahc
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;eh_sem
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|macro|AHC_LINUX_DV_INQ_SHORT_LEN
mdefine_line|#define AHC_LINUX_DV_INQ_SHORT_LEN&t;36
DECL|macro|AHC_LINUX_DV_INQ_LEN
mdefine_line|#define AHC_LINUX_DV_INQ_LEN&t;&t;256
DECL|macro|AHC_LINUX_DV_TIMEOUT
mdefine_line|#define AHC_LINUX_DV_TIMEOUT&t;&t;(HZ / 4)
DECL|macro|AHC_SET_DV_STATE
mdefine_line|#define AHC_SET_DV_STATE(ahc, targ, newstate) &bslash;&n;&t;ahc_set_dv_state(ahc, targ, newstate, __LINE__)
r_static
id|__inline
r_void
DECL|function|ahc_set_dv_state
id|ahc_set_dv_state
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_linux_target
op_star
id|targ
comma
id|ahc_dv_state
id|newstate
comma
id|u_int
id|line
)paren
(brace
id|ahc_dv_state
id|oldstate
suffix:semicolon
id|oldstate
op_assign
id|targ-&gt;dv_state
suffix:semicolon
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_DV
)paren
id|printf
c_func
(paren
l_string|&quot;%s:%d: Going from state %d to state %d&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|line
comma
id|oldstate
comma
id|newstate
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|oldstate
op_eq
id|newstate
)paren
id|targ-&gt;dv_state_retry
op_increment
suffix:semicolon
r_else
id|targ-&gt;dv_state_retry
op_assign
l_int|0
suffix:semicolon
id|targ-&gt;dv_state
op_assign
id|newstate
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahc_linux_dv_target
id|ahc_linux_dv_target
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|u_int
id|target_offset
)paren
(brace
r_struct
id|ahc_devinfo
id|devinfo
suffix:semicolon
r_struct
id|ahc_linux_target
op_star
id|targ
suffix:semicolon
r_struct
id|scsi_cmnd
op_star
id|cmd
suffix:semicolon
r_struct
id|scsi_device
op_star
id|scsi_dev
suffix:semicolon
r_struct
id|scsi_sense_data
op_star
id|sense
suffix:semicolon
r_uint8
op_star
id|buffer
suffix:semicolon
id|u_long
id|s
suffix:semicolon
id|u_int
id|timeout
suffix:semicolon
r_int
id|echo_size
suffix:semicolon
id|sense
op_assign
l_int|NULL
suffix:semicolon
id|buffer
op_assign
l_int|NULL
suffix:semicolon
id|echo_size
op_assign
l_int|0
suffix:semicolon
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
id|targ
op_assign
id|ahc-&gt;platform_data-&gt;targets
(braket
id|target_offset
)braket
suffix:semicolon
r_if
c_cond
(paren
id|targ
op_eq
l_int|NULL
op_logical_or
(paren
id|targ-&gt;flags
op_amp
id|AHC_DV_REQUIRED
)paren
op_eq
l_int|0
)paren
(brace
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ahc_compile_devinfo
c_func
(paren
op_amp
id|devinfo
comma
id|targ-&gt;channel
op_eq
l_int|0
ques
c_cond
id|ahc-&gt;our_id
suffix:colon
id|ahc-&gt;our_id_b
comma
id|targ-&gt;target
comma
multiline_comment|/*lun*/
l_int|0
comma
id|targ-&gt;channel
op_plus
l_char|&squot;A&squot;
comma
id|ROLE_INITIATOR
)paren
suffix:semicolon
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_DV
)paren
(brace
id|ahc_print_devinfo
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Performing DV&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
id|cmd
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
r_struct
id|scsi_cmnd
)paren
comma
id|M_DEVBUF
comma
id|M_WAITOK
)paren
suffix:semicolon
id|scsi_dev
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
r_struct
id|scsi_device
)paren
comma
id|M_DEVBUF
comma
id|M_WAITOK
)paren
suffix:semicolon
id|scsi_dev-&gt;host
op_assign
id|ahc-&gt;platform_data-&gt;host
suffix:semicolon
id|scsi_dev-&gt;id
op_assign
id|devinfo.target
suffix:semicolon
id|scsi_dev-&gt;lun
op_assign
id|devinfo.lun
suffix:semicolon
id|scsi_dev-&gt;channel
op_assign
id|devinfo.channel
op_minus
l_char|&squot;A&squot;
suffix:semicolon
id|ahc-&gt;platform_data-&gt;dv_scsi_dev
op_assign
id|scsi_dev
suffix:semicolon
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_INQ_SHORT_ASYNC
)paren
suffix:semicolon
r_while
c_loop
(paren
id|targ-&gt;dv_state
op_ne
id|AHC_DV_STATE_EXIT
)paren
(brace
id|timeout
op_assign
id|AHC_LINUX_DV_TIMEOUT
suffix:semicolon
r_switch
c_cond
(paren
id|targ-&gt;dv_state
)paren
(brace
r_case
id|AHC_DV_STATE_INQ_SHORT_ASYNC
suffix:colon
r_case
id|AHC_DV_STATE_INQ_ASYNC
suffix:colon
r_case
id|AHC_DV_STATE_INQ_ASYNC_VERIFY
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Set things to async narrow to reduce the&n;&t;&t;&t; * chance that the INQ will fail.&n;&t;&t;&t; */
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
id|ahc_set_syncrate
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|AHC_TRANS_GOAL
comma
multiline_comment|/*paused*/
id|FALSE
)paren
suffix:semicolon
id|ahc_set_width
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
comma
id|MSG_EXT_WDTR_BUS_8_BIT
comma
id|AHC_TRANS_GOAL
comma
multiline_comment|/*paused*/
id|FALSE
)paren
suffix:semicolon
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
id|timeout
op_assign
l_int|10
op_star
id|HZ
suffix:semicolon
id|targ-&gt;flags
op_and_assign
op_complement
id|AHC_INQ_VALID
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_case
id|AHC_DV_STATE_INQ_VERIFY
suffix:colon
(brace
id|u_int
id|inq_len
suffix:semicolon
r_if
c_cond
(paren
id|targ-&gt;dv_state
op_eq
id|AHC_DV_STATE_INQ_SHORT_ASYNC
)paren
id|inq_len
op_assign
id|AHC_LINUX_DV_INQ_SHORT_LEN
suffix:semicolon
r_else
id|inq_len
op_assign
id|targ-&gt;inq_data-&gt;additional_length
op_plus
l_int|5
suffix:semicolon
id|ahc_linux_dv_inq
c_func
(paren
id|ahc
comma
id|cmd
comma
op_amp
id|devinfo
comma
id|targ
comma
id|inq_len
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|AHC_DV_STATE_TUR
suffix:colon
r_case
id|AHC_DV_STATE_BUSY
suffix:colon
id|timeout
op_assign
l_int|5
op_star
id|HZ
suffix:semicolon
id|ahc_linux_dv_tur
c_func
(paren
id|ahc
comma
id|cmd
comma
op_amp
id|devinfo
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AHC_DV_STATE_REBD
suffix:colon
id|ahc_linux_dv_rebd
c_func
(paren
id|ahc
comma
id|cmd
comma
op_amp
id|devinfo
comma
id|targ
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AHC_DV_STATE_WEB
suffix:colon
id|ahc_linux_dv_web
c_func
(paren
id|ahc
comma
id|cmd
comma
op_amp
id|devinfo
comma
id|targ
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AHC_DV_STATE_REB
suffix:colon
id|ahc_linux_dv_reb
c_func
(paren
id|ahc
comma
id|cmd
comma
op_amp
id|devinfo
comma
id|targ
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AHC_DV_STATE_SU
suffix:colon
id|ahc_linux_dv_su
c_func
(paren
id|ahc
comma
id|cmd
comma
op_amp
id|devinfo
comma
id|targ
)paren
suffix:semicolon
id|timeout
op_assign
l_int|50
op_star
id|HZ
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ahc_print_devinfo
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Unknown DV state %d&bslash;n&quot;
comma
id|targ-&gt;dv_state
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Queue the command and wait for it to complete */
multiline_comment|/* Abuse eh_timeout in the scsi_cmnd struct for our purposes */
id|init_timer
c_func
(paren
op_amp
id|cmd-&gt;eh_timeout
)paren
suffix:semicolon
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_MESSAGES
)paren
op_ne
l_int|0
)paren
multiline_comment|/*&n;&t;&t;&t; * All of the printfs during negotiation&n;&t;&t;&t; * really slow down the negotiation.&n;&t;&t;&t; * Add a bit of time just to be safe.&n;&t;&t;&t; */
id|timeout
op_add_assign
id|HZ
suffix:semicolon
macro_line|#endif
id|scsi_add_timer
c_func
(paren
id|cmd
comma
id|timeout
comma
id|ahc_linux_dv_timeout
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * In 2.5.X, it is assumed that all calls from the&n;&t;&t; * &quot;midlayer&quot; (which we are emulating) will have the&n;&t;&t; * ahc host lock held.  For other kernels, the&n;&t;&t; * io_request_lock must be held.&n;&t;&t; */
macro_line|#if AHC_SCSI_HAS_HOST_LOCK != 0
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
macro_line|#else
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|s
)paren
suffix:semicolon
macro_line|#endif
id|ahc_linux_queue
c_func
(paren
id|cmd
comma
id|ahc_linux_dv_complete
)paren
suffix:semicolon
macro_line|#if AHC_SCSI_HAS_HOST_LOCK != 0
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
macro_line|#else
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|s
)paren
suffix:semicolon
macro_line|#endif
id|down_interruptible
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;dv_cmd_sem
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Wait for the SIMQ to be released so that DV is the&n;&t;&t; * only reason the queue is frozen.&n;&t;&t; */
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
r_while
c_loop
(paren
id|AHC_DV_SIMQ_FROZEN
c_func
(paren
id|ahc
)paren
op_eq
l_int|0
)paren
(brace
id|ahc-&gt;platform_data-&gt;flags
op_or_assign
id|AHC_DV_WAIT_SIMQ_RELEASE
suffix:semicolon
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
id|down_interruptible
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;dv_sem
)paren
suffix:semicolon
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
)brace
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
id|ahc_linux_dv_transition
c_func
(paren
id|ahc
comma
id|cmd
comma
op_amp
id|devinfo
comma
id|targ
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_if
c_cond
(paren
(paren
id|targ-&gt;flags
op_amp
id|AHC_INQ_VALID
)paren
op_ne
l_int|0
op_logical_and
id|ahc_linux_get_device
c_func
(paren
id|ahc
comma
id|devinfo.channel
op_minus
l_char|&squot;A&squot;
comma
id|devinfo.target
comma
id|devinfo.lun
comma
multiline_comment|/*alloc*/
id|FALSE
)paren
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * The DV state machine failed to configure this device.  &n;&t;&t; * This is normal if DV is disabled.  Since we have inquiry&n;&t;&t; * data, filter it and use the &quot;optimistic&quot; negotiation&n;&t;&t; * parameters found in the inquiry string.&n;&t;&t; */
id|ahc_linux_filter_inquiry
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|targ-&gt;flags
op_amp
(paren
id|AHC_BASIC_DV
op_or
id|AHC_ENHANCED_DV
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|ahc_print_devinfo
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;DV failed to configure device.  &quot;
l_string|&quot;Please file a bug report against &quot;
l_string|&quot;this driver.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cmd
op_ne
l_int|NULL
)paren
id|free
c_func
(paren
id|cmd
comma
id|M_DEVBUF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;platform_data-&gt;dv_scsi_dev
op_ne
l_int|NULL
)paren
(brace
id|free
c_func
(paren
id|ahc-&gt;platform_data-&gt;dv_scsi_dev
comma
id|M_DEVBUF
)paren
suffix:semicolon
id|ahc-&gt;platform_data-&gt;dv_scsi_dev
op_assign
l_int|NULL
suffix:semicolon
)brace
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|targ-&gt;dv_buffer
op_ne
l_int|NULL
)paren
(brace
id|free
c_func
(paren
id|targ-&gt;dv_buffer
comma
id|M_DEVBUF
)paren
suffix:semicolon
id|targ-&gt;dv_buffer
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|targ-&gt;dv_buffer1
op_ne
l_int|NULL
)paren
(brace
id|free
c_func
(paren
id|targ-&gt;dv_buffer1
comma
id|M_DEVBUF
)paren
suffix:semicolon
id|targ-&gt;dv_buffer1
op_assign
l_int|NULL
suffix:semicolon
)brace
id|targ-&gt;flags
op_and_assign
op_complement
id|AHC_DV_REQUIRED
suffix:semicolon
r_if
c_cond
(paren
id|targ-&gt;refcount
op_eq
l_int|0
)paren
id|ahc_linux_free_target
c_func
(paren
id|ahc
comma
id|targ
)paren
suffix:semicolon
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahc_linux_dv_transition
id|ahc_linux_dv_transition
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
comma
r_struct
id|ahc_linux_target
op_star
id|targ
)paren
(brace
id|u_int32_t
id|status
suffix:semicolon
id|status
op_assign
id|aic_error_action
c_func
(paren
id|cmd
comma
id|targ-&gt;inq_data
comma
id|ahc_cmd_get_transaction_status
c_func
(paren
id|cmd
)paren
comma
id|ahc_cmd_get_scsi_status
c_func
(paren
id|cmd
)paren
)paren
suffix:semicolon
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_DV
)paren
(brace
id|ahc_print_devinfo
c_func
(paren
id|ahc
comma
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Entering ahc_linux_dv_transition, state= %d, &quot;
l_string|&quot;status= 0x%x, cmd-&gt;result= 0x%x&bslash;n&quot;
comma
id|targ-&gt;dv_state
comma
id|status
comma
id|cmd-&gt;result
)paren
suffix:semicolon
)brace
macro_line|#endif
r_switch
c_cond
(paren
id|targ-&gt;dv_state
)paren
(brace
r_case
id|AHC_DV_STATE_INQ_SHORT_ASYNC
suffix:colon
r_case
id|AHC_DV_STATE_INQ_ASYNC
suffix:colon
r_switch
c_cond
(paren
id|status
op_amp
id|SS_MASK
)paren
(brace
r_case
id|SS_NOP
suffix:colon
(brace
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|targ-&gt;dv_state
op_plus
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|SS_INQ_REFRESH
suffix:colon
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_INQ_SHORT_ASYNC
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SS_TUR
suffix:colon
r_case
id|SS_RETRY
suffix:colon
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|targ-&gt;dv_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc_cmd_get_transaction_status
c_func
(paren
id|cmd
)paren
op_eq
id|CAM_REQUEUE_REQ
)paren
id|targ-&gt;dv_state_retry
op_decrement
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
id|SS_ERRMASK
)paren
op_eq
id|EBUSY
)paren
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_BUSY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|targ-&gt;dv_state_retry
OL
l_int|10
)paren
r_break
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_default
suffix:colon
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_EXIT
)paren
suffix:semicolon
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_DV
)paren
(brace
id|ahc_print_devinfo
c_func
(paren
id|ahc
comma
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Failed DV inquiry, skipping&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AHC_DV_STATE_INQ_ASYNC_VERIFY
suffix:colon
r_switch
c_cond
(paren
id|status
op_amp
id|SS_MASK
)paren
(brace
r_case
id|SS_NOP
suffix:colon
(brace
id|u_int
id|xportflags
suffix:semicolon
id|u_int
id|spi3data
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|targ-&gt;inq_data
comma
id|targ-&gt;dv_buffer
comma
id|AHC_LINUX_DV_INQ_LEN
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Inquiry data must have changed.&n;&t;&t;&t;&t; * Try from the top again.&n;&t;&t;&t;&t; */
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_INQ_SHORT_ASYNC
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|targ-&gt;dv_state
op_plus
l_int|1
)paren
suffix:semicolon
id|targ-&gt;flags
op_or_assign
id|AHC_INQ_VALID
suffix:semicolon
r_if
c_cond
(paren
id|ahc_linux_user_dv_setting
c_func
(paren
id|ahc
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|xportflags
op_assign
id|targ-&gt;inq_data-&gt;flags
suffix:semicolon
r_if
c_cond
(paren
(paren
id|xportflags
op_amp
(paren
id|SID_Sync
op_or
id|SID_WBus16
)paren
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|spi3data
op_assign
id|targ-&gt;inq_data-&gt;spi3data
suffix:semicolon
r_switch
c_cond
(paren
id|spi3data
op_amp
id|SID_SPI_CLOCK_DT_ST
)paren
(brace
r_default
suffix:colon
r_case
id|SID_SPI_CLOCK_ST
suffix:colon
multiline_comment|/* Assume only basic DV is supported. */
id|targ-&gt;flags
op_or_assign
id|AHC_BASIC_DV
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SID_SPI_CLOCK_DT
suffix:colon
r_case
id|SID_SPI_CLOCK_DT_ST
suffix:colon
id|targ-&gt;flags
op_or_assign
id|AHC_ENHANCED_DV
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_case
id|SS_INQ_REFRESH
suffix:colon
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_INQ_SHORT_ASYNC
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SS_TUR
suffix:colon
r_case
id|SS_RETRY
suffix:colon
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|targ-&gt;dv_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc_cmd_get_transaction_status
c_func
(paren
id|cmd
)paren
op_eq
id|CAM_REQUEUE_REQ
)paren
id|targ-&gt;dv_state_retry
op_decrement
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
id|SS_ERRMASK
)paren
op_eq
id|EBUSY
)paren
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_BUSY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|targ-&gt;dv_state_retry
OL
l_int|10
)paren
r_break
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_default
suffix:colon
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_EXIT
)paren
suffix:semicolon
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_DV
)paren
(brace
id|ahc_print_devinfo
c_func
(paren
id|ahc
comma
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Failed DV inquiry, skipping&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AHC_DV_STATE_INQ_VERIFY
suffix:colon
r_switch
c_cond
(paren
id|status
op_amp
id|SS_MASK
)paren
(brace
r_case
id|SS_NOP
suffix:colon
(brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|targ-&gt;inq_data
comma
id|targ-&gt;dv_buffer
comma
id|AHC_LINUX_DV_INQ_LEN
)paren
op_eq
l_int|0
)paren
(brace
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_EXIT
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_DV
)paren
(brace
r_int
id|i
suffix:semicolon
id|ahc_print_devinfo
c_func
(paren
id|ahc
comma
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Inquiry buffer mismatch:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AHC_LINUX_DV_INQ_LEN
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_amp
l_int|0xF
)paren
op_eq
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;n        &quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;0x%x:0x0%x &quot;
comma
(paren
(paren
r_uint8
op_star
)paren
id|targ-&gt;inq_data
)paren
(braket
id|i
)braket
comma
id|targ-&gt;dv_buffer
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|ahc_linux_fallback
c_func
(paren
id|ahc
comma
id|devinfo
)paren
op_ne
l_int|0
)paren
(brace
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_EXIT
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Do not count &quot;falling back&quot;&n;&t;&t;&t; * against our retries.&n;&t;&t;&t; */
id|targ-&gt;dv_state_retry
op_assign
l_int|0
suffix:semicolon
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|targ-&gt;dv_state
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|SS_INQ_REFRESH
suffix:colon
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_INQ_SHORT_ASYNC
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SS_TUR
suffix:colon
r_case
id|SS_RETRY
suffix:colon
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|targ-&gt;dv_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc_cmd_get_transaction_status
c_func
(paren
id|cmd
)paren
op_eq
id|CAM_REQUEUE_REQ
)paren
(brace
id|targ-&gt;dv_state_retry
op_decrement
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|status
op_amp
id|SSQ_FALLBACK
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ahc_linux_fallback
c_func
(paren
id|ahc
comma
id|devinfo
)paren
op_ne
l_int|0
)paren
(brace
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_EXIT
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Do not count &quot;falling back&quot;&n;&t;&t;&t;&t; * against our retries.&n;&t;&t;&t;&t; */
id|targ-&gt;dv_state_retry
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|status
op_amp
id|SS_ERRMASK
)paren
op_eq
id|EBUSY
)paren
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_BUSY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|targ-&gt;dv_state_retry
OL
l_int|10
)paren
r_break
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_default
suffix:colon
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_EXIT
)paren
suffix:semicolon
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_DV
)paren
(brace
id|ahc_print_devinfo
c_func
(paren
id|ahc
comma
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Failed DV inquiry, skipping&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AHC_DV_STATE_TUR
suffix:colon
r_switch
c_cond
(paren
id|status
op_amp
id|SS_MASK
)paren
(brace
r_case
id|SS_NOP
suffix:colon
r_if
c_cond
(paren
(paren
id|targ-&gt;flags
op_amp
id|AHC_BASIC_DV
)paren
op_ne
l_int|0
)paren
(brace
id|ahc_linux_filter_inquiry
c_func
(paren
id|ahc
comma
id|devinfo
)paren
suffix:semicolon
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_INQ_VERIFY
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|targ-&gt;flags
op_amp
id|AHC_ENHANCED_DV
)paren
op_ne
l_int|0
)paren
(brace
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_REBD
)paren
suffix:semicolon
)brace
r_else
(brace
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_EXIT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SS_RETRY
suffix:colon
r_case
id|SS_TUR
suffix:colon
r_if
c_cond
(paren
(paren
id|status
op_amp
id|SS_ERRMASK
)paren
op_eq
id|EBUSY
)paren
(brace
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_BUSY
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|targ-&gt;dv_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc_cmd_get_transaction_status
c_func
(paren
id|cmd
)paren
op_eq
id|CAM_REQUEUE_REQ
)paren
(brace
id|targ-&gt;dv_state_retry
op_decrement
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|status
op_amp
id|SSQ_FALLBACK
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ahc_linux_fallback
c_func
(paren
id|ahc
comma
id|devinfo
)paren
op_ne
l_int|0
)paren
(brace
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_EXIT
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Do not count &quot;falling back&quot;&n;&t;&t;&t;&t; * against our retries.&n;&t;&t;&t;&t; */
id|targ-&gt;dv_state_retry
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|targ-&gt;dv_state_retry
op_ge
l_int|10
)paren
(brace
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_DV
)paren
(brace
id|ahc_print_devinfo
c_func
(paren
id|ahc
comma
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;DV TUR reties exhausted&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_EXIT
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|SSQ_DELAY
)paren
id|scsi_sleep
c_func
(paren
l_int|1
op_star
id|HZ
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SS_START
suffix:colon
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_SU
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SS_INQ_REFRESH
suffix:colon
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_INQ_SHORT_ASYNC
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_EXIT
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AHC_DV_STATE_REBD
suffix:colon
r_switch
c_cond
(paren
id|status
op_amp
id|SS_MASK
)paren
(brace
r_case
id|SS_NOP
suffix:colon
(brace
r_uint32
id|echo_size
suffix:semicolon
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_WEB
)paren
suffix:semicolon
id|echo_size
op_assign
id|scsi_3btoul
c_func
(paren
op_amp
id|targ-&gt;dv_buffer
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|echo_size
op_and_assign
l_int|0x1FFF
suffix:semicolon
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_DV
)paren
(brace
id|ahc_print_devinfo
c_func
(paren
id|ahc
comma
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Echo buffer size= %d&bslash;n&quot;
comma
id|echo_size
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|echo_size
op_eq
l_int|0
)paren
(brace
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_EXIT
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Generate the buffer pattern */
id|targ-&gt;dv_echo_size
op_assign
id|echo_size
suffix:semicolon
id|ahc_linux_generate_dv_pattern
c_func
(paren
id|targ
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Setup initial negotiation values.&n;&t;&t;&t; */
id|ahc_linux_filter_inquiry
c_func
(paren
id|ahc
comma
id|devinfo
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|SS_INQ_REFRESH
suffix:colon
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_INQ_SHORT_ASYNC
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SS_RETRY
suffix:colon
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|targ-&gt;dv_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc_cmd_get_transaction_status
c_func
(paren
id|cmd
)paren
op_eq
id|CAM_REQUEUE_REQ
)paren
id|targ-&gt;dv_state_retry
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|targ-&gt;dv_state_retry
op_le
l_int|10
)paren
r_break
suffix:semicolon
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_DV
)paren
(brace
id|ahc_print_devinfo
c_func
(paren
id|ahc
comma
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;DV REBD reties exhausted&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* FALLTHROUGH */
r_case
id|SS_FATAL
suffix:colon
r_default
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Setup initial negotiation values&n;&t;&t;&t; * and try level 1 DV.&n;&t;&t;&t; */
id|ahc_linux_filter_inquiry
c_func
(paren
id|ahc
comma
id|devinfo
)paren
suffix:semicolon
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_INQ_VERIFY
)paren
suffix:semicolon
id|targ-&gt;dv_echo_size
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AHC_DV_STATE_WEB
suffix:colon
r_switch
c_cond
(paren
id|status
op_amp
id|SS_MASK
)paren
(brace
r_case
id|SS_NOP
suffix:colon
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_REB
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SS_INQ_REFRESH
suffix:colon
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_INQ_SHORT_ASYNC
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SS_RETRY
suffix:colon
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|targ-&gt;dv_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc_cmd_get_transaction_status
c_func
(paren
id|cmd
)paren
op_eq
id|CAM_REQUEUE_REQ
)paren
(brace
id|targ-&gt;dv_state_retry
op_decrement
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|status
op_amp
id|SSQ_FALLBACK
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ahc_linux_fallback
c_func
(paren
id|ahc
comma
id|devinfo
)paren
op_ne
l_int|0
)paren
(brace
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_EXIT
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Do not count &quot;falling back&quot;&n;&t;&t;&t;&t; * against our retries.&n;&t;&t;&t;&t; */
id|targ-&gt;dv_state_retry
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|targ-&gt;dv_state_retry
op_le
l_int|10
)paren
r_break
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_DV
)paren
(brace
id|ahc_print_devinfo
c_func
(paren
id|ahc
comma
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;DV WEB reties exhausted&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_default
suffix:colon
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_EXIT
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AHC_DV_STATE_REB
suffix:colon
r_switch
c_cond
(paren
id|status
op_amp
id|SS_MASK
)paren
(brace
r_case
id|SS_NOP
suffix:colon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|targ-&gt;dv_buffer
comma
id|targ-&gt;dv_buffer1
comma
id|targ-&gt;dv_echo_size
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ahc_linux_fallback
c_func
(paren
id|ahc
comma
id|devinfo
)paren
op_ne
l_int|0
)paren
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_EXIT
)paren
suffix:semicolon
r_else
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_WEB
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|targ-&gt;dv_buffer
op_ne
l_int|NULL
)paren
(brace
id|free
c_func
(paren
id|targ-&gt;dv_buffer
comma
id|M_DEVBUF
)paren
suffix:semicolon
id|targ-&gt;dv_buffer
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|targ-&gt;dv_buffer1
op_ne
l_int|NULL
)paren
(brace
id|free
c_func
(paren
id|targ-&gt;dv_buffer1
comma
id|M_DEVBUF
)paren
suffix:semicolon
id|targ-&gt;dv_buffer1
op_assign
l_int|NULL
suffix:semicolon
)brace
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_EXIT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SS_INQ_REFRESH
suffix:colon
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_INQ_SHORT_ASYNC
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SS_RETRY
suffix:colon
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|targ-&gt;dv_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc_cmd_get_transaction_status
c_func
(paren
id|cmd
)paren
op_eq
id|CAM_REQUEUE_REQ
)paren
(brace
id|targ-&gt;dv_state_retry
op_decrement
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|status
op_amp
id|SSQ_FALLBACK
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ahc_linux_fallback
c_func
(paren
id|ahc
comma
id|devinfo
)paren
op_ne
l_int|0
)paren
(brace
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_EXIT
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_WEB
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|targ-&gt;dv_state_retry
op_le
l_int|10
)paren
(brace
r_if
c_cond
(paren
(paren
id|status
op_amp
(paren
id|SSQ_DELAY_RANDOM
op_or
id|SSQ_DELAY
)paren
)paren
op_ne
l_int|0
)paren
id|scsi_sleep
c_func
(paren
id|ahc-&gt;our_id
op_star
id|HZ
op_div
l_int|10
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_DV
)paren
(brace
id|ahc_print_devinfo
c_func
(paren
id|ahc
comma
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;DV REB reties exhausted&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* FALLTHROUGH */
r_default
suffix:colon
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_EXIT
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AHC_DV_STATE_SU
suffix:colon
r_switch
c_cond
(paren
id|status
op_amp
id|SS_MASK
)paren
(brace
r_case
id|SS_NOP
suffix:colon
r_case
id|SS_INQ_REFRESH
suffix:colon
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_INQ_SHORT_ASYNC
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_EXIT
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AHC_DV_STATE_BUSY
suffix:colon
r_switch
c_cond
(paren
id|status
op_amp
id|SS_MASK
)paren
(brace
r_case
id|SS_NOP
suffix:colon
r_case
id|SS_INQ_REFRESH
suffix:colon
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_INQ_SHORT_ASYNC
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SS_TUR
suffix:colon
r_case
id|SS_RETRY
suffix:colon
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|targ-&gt;dv_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc_cmd_get_transaction_status
c_func
(paren
id|cmd
)paren
op_eq
id|CAM_REQUEUE_REQ
)paren
(brace
id|targ-&gt;dv_state_retry
op_decrement
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|targ-&gt;dv_state_retry
OL
l_int|60
)paren
(brace
r_if
c_cond
(paren
(paren
id|status
op_amp
id|SSQ_DELAY
)paren
op_ne
l_int|0
)paren
id|scsi_sleep
c_func
(paren
l_int|1
op_star
id|HZ
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_DV
)paren
(brace
id|ahc_print_devinfo
c_func
(paren
id|ahc
comma
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;DV BUSY reties exhausted&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_EXIT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_EXIT
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|printf
c_func
(paren
l_string|&quot;%s: Invalid DV completion state %d&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|targ-&gt;dv_state
)paren
suffix:semicolon
id|AHC_SET_DV_STATE
c_func
(paren
id|ahc
comma
id|targ
comma
id|AHC_DV_STATE_EXIT
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|ahc_linux_dv_fill_cmd
id|ahc_linux_dv_fill_cmd
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
)paren
(brace
id|memset
c_func
(paren
id|cmd
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|scsi_cmnd
)paren
)paren
suffix:semicolon
id|cmd-&gt;device
op_assign
id|ahc-&gt;platform_data-&gt;dv_scsi_dev
suffix:semicolon
id|cmd-&gt;scsi_done
op_assign
id|ahc_linux_dv_complete
suffix:semicolon
)brace
multiline_comment|/*&n; * Synthesize an inquiry command.  On the return trip, it&squot;ll be&n; * sniffed and the device transfer settings set for us.&n; */
r_static
r_void
DECL|function|ahc_linux_dv_inq
id|ahc_linux_dv_inq
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
comma
r_struct
id|ahc_linux_target
op_star
id|targ
comma
id|u_int
id|request_length
)paren
(brace
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_DV
)paren
(brace
id|ahc_print_devinfo
c_func
(paren
id|ahc
comma
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Sending INQ&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|targ-&gt;inq_data
op_eq
l_int|NULL
)paren
id|targ-&gt;inq_data
op_assign
id|malloc
c_func
(paren
id|AHC_LINUX_DV_INQ_LEN
comma
id|M_DEVBUF
comma
id|M_WAITOK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|targ-&gt;dv_state
OG
id|AHC_DV_STATE_INQ_ASYNC
)paren
(brace
r_if
c_cond
(paren
id|targ-&gt;dv_buffer
op_ne
l_int|NULL
)paren
id|free
c_func
(paren
id|targ-&gt;dv_buffer
comma
id|M_DEVBUF
)paren
suffix:semicolon
id|targ-&gt;dv_buffer
op_assign
id|malloc
c_func
(paren
id|AHC_LINUX_DV_INQ_LEN
comma
id|M_DEVBUF
comma
id|M_WAITOK
)paren
suffix:semicolon
)brace
id|ahc_linux_dv_fill_cmd
c_func
(paren
id|ahc
comma
id|cmd
comma
id|devinfo
)paren
suffix:semicolon
id|cmd-&gt;sc_data_direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
id|cmd-&gt;cmd_len
op_assign
l_int|6
suffix:semicolon
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_assign
id|INQUIRY
suffix:semicolon
id|cmd-&gt;cmnd
(braket
l_int|4
)braket
op_assign
id|request_length
suffix:semicolon
id|cmd-&gt;request_bufflen
op_assign
id|request_length
suffix:semicolon
r_if
c_cond
(paren
id|targ-&gt;dv_state
OG
id|AHC_DV_STATE_INQ_ASYNC
)paren
id|cmd-&gt;request_buffer
op_assign
id|targ-&gt;dv_buffer
suffix:semicolon
r_else
id|cmd-&gt;request_buffer
op_assign
id|targ-&gt;inq_data
suffix:semicolon
id|memset
c_func
(paren
id|cmd-&gt;request_buffer
comma
l_int|0
comma
id|AHC_LINUX_DV_INQ_LEN
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahc_linux_dv_tur
id|ahc_linux_dv_tur
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
)paren
(brace
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_DV
)paren
(brace
id|ahc_print_devinfo
c_func
(paren
id|ahc
comma
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Sending TUR&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Do a TUR to clear out any non-fatal transitional state */
id|ahc_linux_dv_fill_cmd
c_func
(paren
id|ahc
comma
id|cmd
comma
id|devinfo
)paren
suffix:semicolon
id|cmd-&gt;sc_data_direction
op_assign
id|SCSI_DATA_NONE
suffix:semicolon
id|cmd-&gt;cmd_len
op_assign
l_int|6
suffix:semicolon
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_assign
id|TEST_UNIT_READY
suffix:semicolon
)brace
DECL|macro|AHC_REBD_LEN
mdefine_line|#define AHC_REBD_LEN 4
r_static
r_void
DECL|function|ahc_linux_dv_rebd
id|ahc_linux_dv_rebd
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
comma
r_struct
id|ahc_linux_target
op_star
id|targ
)paren
(brace
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_DV
)paren
(brace
id|ahc_print_devinfo
c_func
(paren
id|ahc
comma
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Sending REBD&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|targ-&gt;dv_buffer
op_ne
l_int|NULL
)paren
id|free
c_func
(paren
id|targ-&gt;dv_buffer
comma
id|M_DEVBUF
)paren
suffix:semicolon
id|targ-&gt;dv_buffer
op_assign
id|malloc
c_func
(paren
id|AHC_REBD_LEN
comma
id|M_DEVBUF
comma
id|M_WAITOK
)paren
suffix:semicolon
id|ahc_linux_dv_fill_cmd
c_func
(paren
id|ahc
comma
id|cmd
comma
id|devinfo
)paren
suffix:semicolon
id|cmd-&gt;sc_data_direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
id|cmd-&gt;cmd_len
op_assign
l_int|10
suffix:semicolon
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_assign
id|READ_BUFFER
suffix:semicolon
id|cmd-&gt;cmnd
(braket
l_int|1
)braket
op_assign
l_int|0x0b
suffix:semicolon
id|scsi_ulto3b
c_func
(paren
id|AHC_REBD_LEN
comma
op_amp
id|cmd-&gt;cmnd
(braket
l_int|6
)braket
)paren
suffix:semicolon
id|cmd-&gt;request_bufflen
op_assign
id|AHC_REBD_LEN
suffix:semicolon
id|cmd-&gt;underflow
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
id|cmd-&gt;request_buffer
op_assign
id|targ-&gt;dv_buffer
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahc_linux_dv_web
id|ahc_linux_dv_web
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
comma
r_struct
id|ahc_linux_target
op_star
id|targ
)paren
(brace
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_DV
)paren
(brace
id|ahc_print_devinfo
c_func
(paren
id|ahc
comma
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Sending WEB&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|ahc_linux_dv_fill_cmd
c_func
(paren
id|ahc
comma
id|cmd
comma
id|devinfo
)paren
suffix:semicolon
id|cmd-&gt;sc_data_direction
op_assign
id|SCSI_DATA_WRITE
suffix:semicolon
id|cmd-&gt;cmd_len
op_assign
l_int|10
suffix:semicolon
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_assign
id|WRITE_BUFFER
suffix:semicolon
id|cmd-&gt;cmnd
(braket
l_int|1
)braket
op_assign
l_int|0x0a
suffix:semicolon
id|scsi_ulto3b
c_func
(paren
id|targ-&gt;dv_echo_size
comma
op_amp
id|cmd-&gt;cmnd
(braket
l_int|6
)braket
)paren
suffix:semicolon
id|cmd-&gt;request_bufflen
op_assign
id|targ-&gt;dv_echo_size
suffix:semicolon
id|cmd-&gt;underflow
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
id|cmd-&gt;request_buffer
op_assign
id|targ-&gt;dv_buffer
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahc_linux_dv_reb
id|ahc_linux_dv_reb
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
comma
r_struct
id|ahc_linux_target
op_star
id|targ
)paren
(brace
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_DV
)paren
(brace
id|ahc_print_devinfo
c_func
(paren
id|ahc
comma
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Sending REB&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|ahc_linux_dv_fill_cmd
c_func
(paren
id|ahc
comma
id|cmd
comma
id|devinfo
)paren
suffix:semicolon
id|cmd-&gt;sc_data_direction
op_assign
id|SCSI_DATA_READ
suffix:semicolon
id|cmd-&gt;cmd_len
op_assign
l_int|10
suffix:semicolon
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_assign
id|READ_BUFFER
suffix:semicolon
id|cmd-&gt;cmnd
(braket
l_int|1
)braket
op_assign
l_int|0x0a
suffix:semicolon
id|scsi_ulto3b
c_func
(paren
id|targ-&gt;dv_echo_size
comma
op_amp
id|cmd-&gt;cmnd
(braket
l_int|6
)braket
)paren
suffix:semicolon
id|cmd-&gt;request_bufflen
op_assign
id|targ-&gt;dv_echo_size
suffix:semicolon
id|cmd-&gt;underflow
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
id|cmd-&gt;request_buffer
op_assign
id|targ-&gt;dv_buffer1
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahc_linux_dv_su
id|ahc_linux_dv_su
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
comma
r_struct
id|ahc_linux_target
op_star
id|targ
)paren
(brace
id|u_int
id|le
suffix:semicolon
id|le
op_assign
id|SID_IS_REMOVABLE
c_func
(paren
id|targ-&gt;inq_data
)paren
ques
c_cond
id|SSS_LOEJ
suffix:colon
l_int|0
suffix:semicolon
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_DV
)paren
(brace
id|ahc_print_devinfo
c_func
(paren
id|ahc
comma
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Sending SU&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|ahc_linux_dv_fill_cmd
c_func
(paren
id|ahc
comma
id|cmd
comma
id|devinfo
)paren
suffix:semicolon
id|cmd-&gt;sc_data_direction
op_assign
id|SCSI_DATA_NONE
suffix:semicolon
id|cmd-&gt;cmd_len
op_assign
l_int|6
suffix:semicolon
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_assign
id|START_STOP_UNIT
suffix:semicolon
id|cmd-&gt;cmnd
(braket
l_int|4
)braket
op_assign
id|le
op_or
id|SSS_START
suffix:semicolon
)brace
r_static
r_int
DECL|function|ahc_linux_fallback
id|ahc_linux_fallback
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
)paren
(brace
r_struct
id|ahc_linux_target
op_star
id|targ
suffix:semicolon
r_struct
id|ahc_initiator_tinfo
op_star
id|tinfo
suffix:semicolon
r_struct
id|ahc_transinfo
op_star
id|goal
suffix:semicolon
r_struct
id|ahc_tmode_tstate
op_star
id|tstate
suffix:semicolon
r_struct
id|ahc_syncrate
op_star
id|syncrate
suffix:semicolon
id|u_long
id|s
suffix:semicolon
id|u_int
id|width
suffix:semicolon
id|u_int
id|period
suffix:semicolon
id|u_int
id|offset
suffix:semicolon
id|u_int
id|ppr_options
suffix:semicolon
id|u_int
id|cur_speed
suffix:semicolon
id|u_int
id|wide_speed
suffix:semicolon
id|u_int
id|narrow_speed
suffix:semicolon
id|u_int
id|fallback_speed
suffix:semicolon
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_DV
)paren
(brace
id|ahc_print_devinfo
c_func
(paren
id|ahc
comma
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Trying to fallback&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
id|targ
op_assign
id|ahc-&gt;platform_data-&gt;targets
(braket
id|devinfo-&gt;target_offset
)braket
suffix:semicolon
id|tinfo
op_assign
id|ahc_fetch_transinfo
c_func
(paren
id|ahc
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;our_scsiid
comma
id|devinfo-&gt;target
comma
op_amp
id|tstate
)paren
suffix:semicolon
id|goal
op_assign
op_amp
id|tinfo-&gt;goal
suffix:semicolon
id|width
op_assign
id|goal-&gt;width
suffix:semicolon
id|period
op_assign
id|goal-&gt;period
suffix:semicolon
id|offset
op_assign
id|goal-&gt;offset
suffix:semicolon
id|ppr_options
op_assign
id|goal-&gt;ppr_options
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_eq
l_int|0
)paren
id|period
op_assign
id|AHC_ASYNC_XFER_PERIOD
suffix:semicolon
r_if
c_cond
(paren
id|targ-&gt;dv_next_narrow_period
op_eq
l_int|0
)paren
id|targ-&gt;dv_next_narrow_period
op_assign
id|MAX
c_func
(paren
id|period
comma
id|AHC_SYNCRATE_ULTRA2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|targ-&gt;dv_next_wide_period
op_eq
l_int|0
)paren
id|targ-&gt;dv_next_wide_period
op_assign
id|period
suffix:semicolon
r_if
c_cond
(paren
id|targ-&gt;dv_max_width
op_eq
l_int|0
)paren
id|targ-&gt;dv_max_width
op_assign
id|width
suffix:semicolon
r_if
c_cond
(paren
id|targ-&gt;dv_max_ppr_options
op_eq
l_int|0
)paren
id|targ-&gt;dv_max_ppr_options
op_assign
id|ppr_options
suffix:semicolon
r_if
c_cond
(paren
id|targ-&gt;dv_last_ppr_options
op_eq
l_int|0
)paren
id|targ-&gt;dv_last_ppr_options
op_assign
id|ppr_options
suffix:semicolon
id|cur_speed
op_assign
id|aic_calc_speed
c_func
(paren
id|width
comma
id|period
comma
id|offset
comma
id|AHC_SYNCRATE_MIN
)paren
suffix:semicolon
id|wide_speed
op_assign
id|aic_calc_speed
c_func
(paren
id|MSG_EXT_WDTR_BUS_16_BIT
comma
id|targ-&gt;dv_next_wide_period
comma
id|MAX_OFFSET
comma
id|AHC_SYNCRATE_MIN
)paren
suffix:semicolon
id|narrow_speed
op_assign
id|aic_calc_speed
c_func
(paren
id|MSG_EXT_WDTR_BUS_8_BIT
comma
id|targ-&gt;dv_next_narrow_period
comma
id|MAX_OFFSET
comma
id|AHC_SYNCRATE_MIN
)paren
suffix:semicolon
id|fallback_speed
op_assign
id|aic_calc_speed
c_func
(paren
id|width
comma
id|period
op_plus
l_int|1
comma
id|offset
comma
id|AHC_SYNCRATE_MIN
)paren
suffix:semicolon
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_DV
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;cur_speed= %d, wide_speed= %d, narrow_speed= %d, &quot;
l_string|&quot;fallback_speed= %d&bslash;n&quot;
comma
id|cur_speed
comma
id|wide_speed
comma
id|narrow_speed
comma
id|fallback_speed
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|cur_speed
OG
l_int|160000
)paren
(brace
multiline_comment|/*&n;&t;&t; * Paced/DT/IU_REQ only transfer speeds.  All we&n;&t;&t; * can do is fallback in terms of syncrate.&n;&t;&t; */
id|period
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cur_speed
OG
l_int|80000
)paren
(brace
r_if
c_cond
(paren
(paren
id|ppr_options
op_amp
id|MSG_EXT_PPR_IU_REQ
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Try without IU_REQ as it may be confusing&n;&t;&t;&t; * an expander.&n;&t;&t;&t; */
id|ppr_options
op_and_assign
op_complement
id|MSG_EXT_PPR_IU_REQ
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Paced/DT only transfer speeds.  All we&n;&t;&t;&t; * can do is fallback in terms of syncrate.&n;&t;&t;&t; */
id|period
op_increment
suffix:semicolon
id|ppr_options
op_assign
id|targ-&gt;dv_max_ppr_options
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|cur_speed
OG
l_int|3300
)paren
(brace
multiline_comment|/*&n;&t;&t; * In this range we the following&n;&t;&t; * options ordered from highest to&n;&t;&t; * lowest desireability:&n;&t;&t; *&n;&t;&t; * o Wide/DT&n;&t;&t; * o Wide/non-DT&n;&t;&t; * o Narrow at a potentally higher sync rate.&n;&t;&t; *&n;&t;&t; * All modes are tested with and without IU_REQ&n;&t;&t; * set since using IUs may confuse an expander.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ppr_options
op_amp
id|MSG_EXT_PPR_IU_REQ
)paren
op_ne
l_int|0
)paren
(brace
id|ppr_options
op_and_assign
op_complement
id|MSG_EXT_PPR_IU_REQ
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|ppr_options
op_amp
id|MSG_EXT_PPR_DT_REQ
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Try going non-DT.&n;&t;&t;&t; */
id|ppr_options
op_assign
id|targ-&gt;dv_max_ppr_options
suffix:semicolon
id|ppr_options
op_and_assign
op_complement
id|MSG_EXT_PPR_DT_REQ
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|targ-&gt;dv_last_ppr_options
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Try without QAS or any other PPR options.&n;&t;&t;&t; * We may need a non-PPR message to work with&n;&t;&t;&t; * an expander.  We look at the &quot;last PPR options&quot;&n;&t;&t;&t; * so we will perform this fallback even if the&n;&t;&t;&t; * target responded to our PPR negotiation with&n;&t;&t;&t; * no option bits set.&n;&t;&t;&t; */
id|ppr_options
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|width
op_eq
id|MSG_EXT_WDTR_BUS_16_BIT
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If the next narrow speed is greater than&n;&t;&t;&t; * the next wide speed, fallback to narrow.&n;&t;&t;&t; * Otherwise fallback to the next DT/Wide setting.&n;&t;&t;&t; * The narrow async speed will always be smaller&n;&t;&t;&t; * than the wide async speed, so handle this case&n;&t;&t;&t; * specifically.&n;&t;&t;&t; */
id|ppr_options
op_assign
id|targ-&gt;dv_max_ppr_options
suffix:semicolon
r_if
c_cond
(paren
id|narrow_speed
OG
id|fallback_speed
op_logical_or
id|period
op_ge
id|AHC_ASYNC_XFER_PERIOD
)paren
(brace
id|targ-&gt;dv_next_wide_period
op_assign
id|period
op_plus
l_int|1
suffix:semicolon
id|width
op_assign
id|MSG_EXT_WDTR_BUS_8_BIT
suffix:semicolon
id|period
op_assign
id|targ-&gt;dv_next_narrow_period
suffix:semicolon
)brace
r_else
(brace
id|period
op_increment
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_WIDE
)paren
op_ne
l_int|0
op_logical_and
id|targ-&gt;dv_max_width
op_ne
l_int|0
op_logical_and
id|wide_speed
op_ge
id|fallback_speed
op_logical_and
(paren
id|targ-&gt;dv_next_wide_period
op_le
id|AHC_ASYNC_XFER_PERIOD
op_logical_or
id|period
op_ge
id|AHC_ASYNC_XFER_PERIOD
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We are narrow.  Try falling back&n;&t;&t;&t; * to the next wide speed with &n;&t;&t;&t; * all supported ppr options set.&n;&t;&t;&t; */
id|targ-&gt;dv_next_narrow_period
op_assign
id|period
op_plus
l_int|1
suffix:semicolon
id|width
op_assign
id|MSG_EXT_WDTR_BUS_16_BIT
suffix:semicolon
id|period
op_assign
id|targ-&gt;dv_next_wide_period
suffix:semicolon
id|ppr_options
op_assign
id|targ-&gt;dv_max_ppr_options
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Only narrow fallback is allowed. */
id|period
op_increment
suffix:semicolon
id|ppr_options
op_assign
id|targ-&gt;dv_max_ppr_options
suffix:semicolon
)brace
)brace
r_else
(brace
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|offset
op_assign
id|MAX_OFFSET
suffix:semicolon
id|syncrate
op_assign
id|ahc_find_syncrate
c_func
(paren
id|ahc
comma
op_amp
id|period
comma
op_amp
id|ppr_options
comma
id|AHC_SYNCRATE_DT
)paren
suffix:semicolon
id|ahc_set_width
c_func
(paren
id|ahc
comma
id|devinfo
comma
id|width
comma
id|AHC_TRANS_GOAL
comma
id|FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|period
op_eq
l_int|0
)paren
(brace
id|period
op_assign
l_int|0
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
id|ppr_options
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|width
op_eq
id|MSG_EXT_WDTR_BUS_8_BIT
)paren
id|targ-&gt;dv_next_narrow_period
op_assign
id|AHC_ASYNC_XFER_PERIOD
suffix:semicolon
r_else
id|targ-&gt;dv_next_wide_period
op_assign
id|AHC_ASYNC_XFER_PERIOD
suffix:semicolon
)brace
id|ahc_set_syncrate
c_func
(paren
id|ahc
comma
id|devinfo
comma
id|syncrate
comma
id|period
comma
id|offset
comma
id|ppr_options
comma
id|AHC_TRANS_GOAL
comma
id|FALSE
)paren
suffix:semicolon
id|targ-&gt;dv_last_ppr_options
op_assign
id|ppr_options
suffix:semicolon
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahc_linux_dv_timeout
id|ahc_linux_dv_timeout
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
r_struct
id|scb
op_star
id|scb
suffix:semicolon
id|u_long
id|flags
suffix:semicolon
id|ahc
op_assign
op_star
(paren
(paren
r_struct
id|ahc_softc
op_star
op_star
)paren
id|cmd-&gt;device-&gt;host-&gt;hostdata
)paren
suffix:semicolon
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|flags
)paren
suffix:semicolon
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_DV
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: Timeout while doing DV command %x.&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|ahc_dump_card_state
c_func
(paren
id|ahc
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Guard against &quot;done race&quot;.  No action is&n;&t; * required if we just completed.&n;&t; */
r_if
c_cond
(paren
(paren
id|scb
op_assign
(paren
r_struct
id|scb
op_star
)paren
id|cmd-&gt;host_scribble
)paren
op_eq
l_int|NULL
)paren
(brace
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Command has not completed.  Mark this&n;&t; * SCB as having failing status prior to&n;&t; * resetting the bus, so we get the correct&n;&t; * error code.&n;&t; */
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_SENSE
)paren
op_ne
l_int|0
)paren
id|ahc_set_transaction_status
c_func
(paren
id|scb
comma
id|CAM_AUTOSENSE_FAIL
)paren
suffix:semicolon
r_else
id|ahc_set_transaction_status
c_func
(paren
id|scb
comma
id|CAM_CMD_TIMEOUT
)paren
suffix:semicolon
id|ahc_reset_channel
c_func
(paren
id|ahc
comma
id|cmd-&gt;device-&gt;channel
op_plus
l_char|&squot;A&squot;
comma
multiline_comment|/*initiate*/
id|TRUE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Add a minimal bus settle delay for devices that are slow to&n;&t; * respond after bus resets.&n;&t; */
id|ahc_linux_freeze_simq
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;reset_timer
)paren
suffix:semicolon
id|ahc-&gt;platform_data-&gt;reset_timer.data
op_assign
(paren
id|u_long
)paren
id|ahc
suffix:semicolon
id|ahc-&gt;platform_data-&gt;reset_timer.expires
op_assign
id|jiffies
op_plus
id|HZ
op_div
l_int|2
suffix:semicolon
id|ahc-&gt;platform_data-&gt;reset_timer.function
op_assign
(paren
id|ahc_linux_callback_t
op_star
)paren
id|ahc_linux_release_simq
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;reset_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc_linux_next_device_to_run
c_func
(paren
id|ahc
)paren
op_ne
l_int|NULL
)paren
id|ahc_schedule_runq
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_linux_run_complete_queue
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahc_linux_dv_complete
id|ahc_linux_dv_complete
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
id|ahc
op_assign
op_star
(paren
(paren
r_struct
id|ahc_softc
op_star
op_star
)paren
id|cmd-&gt;device-&gt;host-&gt;hostdata
)paren
suffix:semicolon
multiline_comment|/* Delete the DV timer before it goes off! */
id|scsi_delete_timer
c_func
(paren
id|cmd
)paren
suffix:semicolon
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_DV
)paren
id|printf
c_func
(paren
l_string|&quot;%s:%d:%d: Command completed, status= 0x%x&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|cmd-&gt;device-&gt;channel
comma
id|cmd-&gt;device-&gt;id
comma
id|cmd-&gt;result
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Wake up the state machine */
id|up
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;dv_cmd_sem
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahc_linux_generate_dv_pattern
id|ahc_linux_generate_dv_pattern
c_func
(paren
r_struct
id|ahc_linux_target
op_star
id|targ
)paren
(brace
r_uint16
id|b
suffix:semicolon
id|u_int
id|i
suffix:semicolon
id|u_int
id|j
suffix:semicolon
r_if
c_cond
(paren
id|targ-&gt;dv_buffer
op_ne
l_int|NULL
)paren
id|free
c_func
(paren
id|targ-&gt;dv_buffer
comma
id|M_DEVBUF
)paren
suffix:semicolon
id|targ-&gt;dv_buffer
op_assign
id|malloc
c_func
(paren
id|targ-&gt;dv_echo_size
comma
id|M_DEVBUF
comma
id|M_WAITOK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|targ-&gt;dv_buffer1
op_ne
l_int|NULL
)paren
id|free
c_func
(paren
id|targ-&gt;dv_buffer1
comma
id|M_DEVBUF
)paren
suffix:semicolon
id|targ-&gt;dv_buffer1
op_assign
id|malloc
c_func
(paren
id|targ-&gt;dv_echo_size
comma
id|M_DEVBUF
comma
id|M_WAITOK
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
id|b
op_assign
l_int|0x0001
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|targ-&gt;dv_echo_size
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|j
OL
l_int|32
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * 32bytes of sequential numbers.&n;&t;&t;&t; */
id|targ-&gt;dv_buffer
(braket
id|i
op_increment
)braket
op_assign
id|j
op_amp
l_int|0xff
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|j
OL
l_int|48
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * 32bytes of repeating 0x0000, 0xffff.&n;&t;&t;&t; */
id|targ-&gt;dv_buffer
(braket
id|i
op_increment
)braket
op_assign
(paren
id|j
op_amp
l_int|0x02
)paren
ques
c_cond
l_int|0xff
suffix:colon
l_int|0x00
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|j
OL
l_int|64
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * 32bytes of repeating 0x5555, 0xaaaa.&n;&t;&t;&t; */
id|targ-&gt;dv_buffer
(braket
id|i
op_increment
)braket
op_assign
(paren
id|j
op_amp
l_int|0x02
)paren
ques
c_cond
l_int|0xaa
suffix:colon
l_int|0x55
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Remaining buffer is filled with a repeating&n;&t;&t;&t; * patter of:&n;&t;&t;&t; *&n;&t;&t;&t; *&t; 0xffff&n;&t;&t;&t; *&t;~0x0001 &lt;&lt; shifted once in each loop.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|j
op_amp
l_int|0x02
)paren
(brace
r_if
c_cond
(paren
id|j
op_amp
l_int|0x01
)paren
(brace
id|targ-&gt;dv_buffer
(braket
id|i
op_increment
)braket
op_assign
op_complement
(paren
id|b
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|b
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|b
op_eq
l_int|0x0000
)paren
id|b
op_assign
l_int|0x0001
suffix:semicolon
)brace
r_else
(brace
id|targ-&gt;dv_buffer
(braket
id|i
op_increment
)braket
op_assign
(paren
op_complement
id|b
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|targ-&gt;dv_buffer
(braket
id|i
op_increment
)braket
op_assign
l_int|0xff
suffix:semicolon
)brace
)brace
)brace
)brace
r_static
id|u_int
DECL|function|ahc_linux_user_tagdepth
id|ahc_linux_user_tagdepth
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
)paren
(brace
r_static
r_int
id|warned_user
suffix:semicolon
id|u_int
id|tags
suffix:semicolon
id|tags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;user_discenable
op_amp
id|devinfo-&gt;target_mask
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ahc-&gt;unit
op_ge
id|NUM_ELEMENTS
c_func
(paren
id|aic7xxx_tag_info
)paren
)paren
(brace
r_if
c_cond
(paren
id|warned_user
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
id|KERN_WARNING
l_string|&quot;aic7xxx: WARNING: Insufficient tag_info instances&bslash;n&quot;
l_string|&quot;aic7xxx: for installed controllers. Using defaults&bslash;n&quot;
l_string|&quot;aic7xxx: Please update the aic7xxx_tag_info array in&bslash;n&quot;
l_string|&quot;aic7xxx: the aic7xxx_osm..c source file.&bslash;n&quot;
)paren
suffix:semicolon
id|warned_user
op_increment
suffix:semicolon
)brace
id|tags
op_assign
id|AHC_MAX_QUEUE
suffix:semicolon
)brace
r_else
(brace
id|adapter_tag_info_t
op_star
id|tag_info
suffix:semicolon
id|tag_info
op_assign
op_amp
id|aic7xxx_tag_info
(braket
id|ahc-&gt;unit
)braket
suffix:semicolon
id|tags
op_assign
id|tag_info-&gt;tag_commands
(braket
id|devinfo-&gt;target_offset
)braket
suffix:semicolon
r_if
c_cond
(paren
id|tags
OG
id|AHC_MAX_QUEUE
)paren
id|tags
op_assign
id|AHC_MAX_QUEUE
suffix:semicolon
)brace
)brace
r_return
(paren
id|tags
)paren
suffix:semicolon
)brace
r_static
id|u_int
DECL|function|ahc_linux_user_dv_setting
id|ahc_linux_user_dv_setting
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_static
r_int
id|warned_user
suffix:semicolon
r_int
id|dv
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;unit
op_ge
id|NUM_ELEMENTS
c_func
(paren
id|aic7xxx_dv_settings
)paren
)paren
(brace
r_if
c_cond
(paren
id|warned_user
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
id|KERN_WARNING
l_string|&quot;aic7xxx: WARNING: Insufficient dv settings instances&bslash;n&quot;
l_string|&quot;aic7xxx: for installed controllers. Using defaults&bslash;n&quot;
l_string|&quot;aic7xxx: Please update the aic7xxx_dv_settings array&bslash;n&quot;
l_string|&quot;aic7xxx: in the aic7xxx_osm.c source file.&bslash;n&quot;
)paren
suffix:semicolon
id|warned_user
op_increment
suffix:semicolon
)brace
id|dv
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|dv
op_assign
id|aic7xxx_dv_settings
(braket
id|ahc-&gt;unit
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dv
OL
l_int|0
)paren
(brace
id|u_long
id|s
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Apply the default.&n;&t;&t; */
multiline_comment|/*&n;&t;&t; * XXX - Enable DV on non-U160 controllers once it&n;&t;&t; *       has been tested there.&n;&t;&t; */
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
id|dv
op_assign
(paren
id|ahc-&gt;features
op_amp
id|AHC_DT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;seep_config
op_ne
l_int|0
op_logical_and
id|ahc-&gt;seep_config-&gt;signature
op_ge
id|CFSIGNATURE2
)paren
id|dv
op_assign
(paren
id|ahc-&gt;seep_config-&gt;adapter_control
op_amp
id|CFENABLEDV
)paren
suffix:semicolon
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
)brace
r_return
(paren
id|dv
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Determines the queue depth for a given device.&n; */
r_static
r_void
DECL|function|ahc_linux_device_queue_depth
id|ahc_linux_device_queue_depth
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_linux_device
op_star
id|dev
)paren
(brace
r_struct
id|ahc_devinfo
id|devinfo
suffix:semicolon
id|u_int
id|tags
suffix:semicolon
id|ahc_compile_devinfo
c_func
(paren
op_amp
id|devinfo
comma
id|dev-&gt;target-&gt;channel
op_eq
l_int|0
ques
c_cond
id|ahc-&gt;our_id
suffix:colon
id|ahc-&gt;our_id_b
comma
id|dev-&gt;target-&gt;target
comma
id|dev-&gt;lun
comma
id|dev-&gt;target-&gt;channel
op_eq
l_int|0
ques
c_cond
l_char|&squot;A&squot;
suffix:colon
l_char|&squot;B&squot;
comma
id|ROLE_INITIATOR
)paren
suffix:semicolon
id|tags
op_assign
id|ahc_linux_user_tagdepth
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tags
op_ne
l_int|0
op_logical_and
id|dev-&gt;scsi_device
op_ne
l_int|NULL
op_logical_and
id|dev-&gt;scsi_device-&gt;tagged_supported
op_ne
l_int|0
)paren
(brace
id|ahc_set_tags
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
comma
id|AHC_QUEUE_TAGGED
)paren
suffix:semicolon
id|ahc_print_devinfo
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Tagged Queuing enabled.  Depth %d&bslash;n&quot;
comma
id|tags
)paren
suffix:semicolon
)brace
r_else
(brace
id|ahc_set_tags
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
comma
id|AHC_QUEUE_NONE
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|ahc_linux_run_device_queue
id|ahc_linux_run_device_queue
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_linux_device
op_star
id|dev
)paren
(brace
r_struct
id|ahc_cmd
op_star
id|acmd
suffix:semicolon
r_struct
id|scsi_cmnd
op_star
id|cmd
suffix:semicolon
r_struct
id|scb
op_star
id|scb
suffix:semicolon
r_struct
id|hardware_scb
op_star
id|hscb
suffix:semicolon
r_struct
id|ahc_initiator_tinfo
op_star
id|tinfo
suffix:semicolon
r_struct
id|ahc_tmode_tstate
op_star
id|tstate
suffix:semicolon
r_uint16
id|mask
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|AHC_DEV_ON_RUN_LIST
)paren
op_ne
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;running device on run list&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|acmd
op_assign
id|TAILQ_FIRST
c_func
(paren
op_amp
id|dev-&gt;busyq
)paren
)paren
op_ne
l_int|NULL
op_logical_and
id|dev-&gt;openings
OG
l_int|0
op_logical_and
id|dev-&gt;qfrozen
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Schedule us to run later.  The only reason we are not&n;&t;&t; * running is because the whole controller Q is frozen.&n;&t;&t; */
r_if
c_cond
(paren
id|ahc-&gt;platform_data-&gt;qfrozen
op_ne
l_int|0
op_logical_and
id|AHC_DV_SIMQ_FROZEN
c_func
(paren
id|ahc
)paren
op_eq
l_int|0
)paren
(brace
id|TAILQ_INSERT_TAIL
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;device_runq
comma
id|dev
comma
id|links
)paren
suffix:semicolon
id|dev-&gt;flags
op_or_assign
id|AHC_DEV_ON_RUN_LIST
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Get an scb to use.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|scb
op_assign
id|ahc_get_scb
c_func
(paren
id|ahc
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|TAILQ_INSERT_TAIL
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;device_runq
comma
id|dev
comma
id|links
)paren
suffix:semicolon
id|dev-&gt;flags
op_or_assign
id|AHC_DEV_ON_RUN_LIST
suffix:semicolon
id|ahc-&gt;flags
op_or_assign
id|AHC_RESOURCE_SHORTAGE
suffix:semicolon
r_return
suffix:semicolon
)brace
id|TAILQ_REMOVE
c_func
(paren
op_amp
id|dev-&gt;busyq
comma
id|acmd
comma
id|acmd_links.tqe
)paren
suffix:semicolon
id|cmd
op_assign
op_amp
id|acmd_scsi_cmd
c_func
(paren
id|acmd
)paren
suffix:semicolon
id|scb-&gt;io_ctx
op_assign
id|cmd
suffix:semicolon
id|scb-&gt;platform_data-&gt;dev
op_assign
id|dev
suffix:semicolon
id|hscb
op_assign
id|scb-&gt;hscb
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
(paren
r_char
op_star
)paren
id|scb
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Fill out basics of the HSCB.&n;&t;&t; */
id|hscb-&gt;control
op_assign
l_int|0
suffix:semicolon
id|hscb-&gt;scsiid
op_assign
id|BUILD_SCSIID
c_func
(paren
id|ahc
comma
id|cmd
)paren
suffix:semicolon
id|hscb-&gt;lun
op_assign
id|cmd-&gt;device-&gt;lun
suffix:semicolon
id|mask
op_assign
id|SCB_GET_TARGET_MASK
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|tinfo
op_assign
id|ahc_fetch_transinfo
c_func
(paren
id|ahc
comma
id|SCB_GET_CHANNEL
c_func
(paren
id|ahc
comma
id|scb
)paren
comma
id|SCB_GET_OUR_ID
c_func
(paren
id|scb
)paren
comma
id|SCB_GET_TARGET
c_func
(paren
id|ahc
comma
id|scb
)paren
comma
op_amp
id|tstate
)paren
suffix:semicolon
id|hscb-&gt;scsirate
op_assign
id|tinfo-&gt;scsirate
suffix:semicolon
id|hscb-&gt;scsioffset
op_assign
id|tinfo-&gt;curr.offset
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tstate-&gt;ultraenb
op_amp
id|mask
)paren
op_ne
l_int|0
)paren
id|hscb-&gt;control
op_or_assign
id|ULTRAENB
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;user_discenable
op_amp
id|mask
)paren
op_ne
l_int|0
)paren
id|hscb-&gt;control
op_or_assign
id|DISCENB
suffix:semicolon
r_if
c_cond
(paren
id|AHC_DV_CMD
c_func
(paren
id|cmd
)paren
op_ne
l_int|0
)paren
id|scb-&gt;flags
op_or_assign
id|SCB_SILENT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tstate-&gt;auto_negotiate
op_amp
id|mask
)paren
op_ne
l_int|0
)paren
(brace
id|scb-&gt;flags
op_or_assign
id|SCB_AUTO_NEGOTIATE
suffix:semicolon
id|scb-&gt;hscb-&gt;control
op_or_assign
id|MK_MESSAGE
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
(paren
id|AHC_DEV_Q_TAGGED
op_or
id|AHC_DEV_Q_BASIC
)paren
)paren
op_ne
l_int|0
)paren
(brace
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,5,0)
r_int
id|msg_bytes
suffix:semicolon
r_uint8
id|tag_msgs
(braket
l_int|2
)braket
suffix:semicolon
id|msg_bytes
op_assign
id|scsi_populate_tag_msg
c_func
(paren
id|cmd
comma
id|tag_msgs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg_bytes
op_logical_and
id|tag_msgs
(braket
l_int|0
)braket
op_ne
id|MSG_SIMPLE_TASK
)paren
(brace
id|hscb-&gt;control
op_or_assign
id|tag_msgs
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|tag_msgs
(braket
l_int|0
)braket
op_eq
id|MSG_ORDERED_TASK
)paren
id|dev-&gt;commands_since_idle_or_otag
op_assign
l_int|0
suffix:semicolon
)brace
r_else
macro_line|#endif
r_if
c_cond
(paren
id|dev-&gt;commands_since_idle_or_otag
op_eq
id|AHC_OTAG_THRESH
op_logical_and
(paren
id|dev-&gt;flags
op_amp
id|AHC_DEV_Q_TAGGED
)paren
op_ne
l_int|0
)paren
(brace
id|hscb-&gt;control
op_or_assign
id|MSG_ORDERED_TASK
suffix:semicolon
id|dev-&gt;commands_since_idle_or_otag
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|hscb-&gt;control
op_or_assign
id|MSG_SIMPLE_TASK
suffix:semicolon
)brace
)brace
id|hscb-&gt;cdb_len
op_assign
id|cmd-&gt;cmd_len
suffix:semicolon
r_if
c_cond
(paren
id|hscb-&gt;cdb_len
op_le
l_int|12
)paren
(brace
id|memcpy
c_func
(paren
id|hscb-&gt;shared_data.cdb
comma
id|cmd-&gt;cmnd
comma
id|hscb-&gt;cdb_len
)paren
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|hscb-&gt;cdb32
comma
id|cmd-&gt;cmnd
comma
id|hscb-&gt;cdb_len
)paren
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_CDB32_PTR
suffix:semicolon
)brace
id|scb-&gt;platform_data-&gt;xfer_len
op_assign
l_int|0
suffix:semicolon
id|ahc_set_residual
c_func
(paren
id|scb
comma
l_int|0
)paren
suffix:semicolon
id|ahc_set_sense_residual
c_func
(paren
id|scb
comma
l_int|0
)paren
suffix:semicolon
id|scb-&gt;sg_count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;use_sg
op_ne
l_int|0
)paren
(brace
r_struct
id|ahc_dma_seg
op_star
id|sg
suffix:semicolon
r_struct
id|scatterlist
op_star
id|cur_seg
suffix:semicolon
r_struct
id|scatterlist
op_star
id|end_seg
suffix:semicolon
r_int
id|nseg
suffix:semicolon
id|cur_seg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;request_buffer
suffix:semicolon
id|nseg
op_assign
id|pci_map_sg
c_func
(paren
id|ahc-&gt;dev_softc
comma
id|cur_seg
comma
id|cmd-&gt;use_sg
comma
id|scsi_to_pci_dma_dir
c_func
(paren
id|cmd-&gt;sc_data_direction
)paren
)paren
suffix:semicolon
id|end_seg
op_assign
id|cur_seg
op_plus
id|nseg
suffix:semicolon
multiline_comment|/* Copy the segments into the SG list. */
id|sg
op_assign
id|scb-&gt;sg_list
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * The sg_count may be larger than nseg if&n;&t;&t;&t; * a transfer crosses a 32bit page.&n;&t;&t;&t; */
r_while
c_loop
(paren
id|cur_seg
OL
id|end_seg
)paren
(brace
id|bus_addr_t
id|addr
suffix:semicolon
id|bus_size_t
id|len
suffix:semicolon
r_int
id|consumed
suffix:semicolon
id|addr
op_assign
id|sg_dma_address
c_func
(paren
id|cur_seg
)paren
suffix:semicolon
id|len
op_assign
id|sg_dma_len
c_func
(paren
id|cur_seg
)paren
suffix:semicolon
id|consumed
op_assign
id|ahc_linux_map_seg
c_func
(paren
id|ahc
comma
id|scb
comma
id|sg
comma
id|addr
comma
id|len
)paren
suffix:semicolon
id|sg
op_add_assign
id|consumed
suffix:semicolon
id|scb-&gt;sg_count
op_add_assign
id|consumed
suffix:semicolon
id|cur_seg
op_increment
suffix:semicolon
)brace
id|sg
op_decrement
suffix:semicolon
id|sg-&gt;len
op_or_assign
id|ahc_htole32
c_func
(paren
id|AHC_DMA_LAST_SEG
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Reset the sg list pointer.&n;&t;&t;&t; */
id|scb-&gt;hscb-&gt;sgptr
op_assign
id|ahc_htole32
c_func
(paren
id|scb-&gt;sg_list_phys
op_or
id|SG_FULL_RESID
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Copy the first SG into the &quot;current&quot;&n;&t;&t;&t; * data pointer area.&n;&t;&t;&t; */
id|scb-&gt;hscb-&gt;dataptr
op_assign
id|scb-&gt;sg_list-&gt;addr
suffix:semicolon
id|scb-&gt;hscb-&gt;datacnt
op_assign
id|scb-&gt;sg_list-&gt;len
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmd-&gt;request_bufflen
op_ne
l_int|0
)paren
(brace
r_struct
id|ahc_dma_seg
op_star
id|sg
suffix:semicolon
id|bus_addr_t
id|addr
suffix:semicolon
id|sg
op_assign
id|scb-&gt;sg_list
suffix:semicolon
id|addr
op_assign
id|pci_map_single
c_func
(paren
id|ahc-&gt;dev_softc
comma
id|cmd-&gt;request_buffer
comma
id|cmd-&gt;request_bufflen
comma
id|scsi_to_pci_dma_dir
c_func
(paren
id|cmd-&gt;sc_data_direction
)paren
)paren
suffix:semicolon
id|scb-&gt;platform_data-&gt;buf_busaddr
op_assign
id|addr
suffix:semicolon
id|scb-&gt;sg_count
op_assign
id|ahc_linux_map_seg
c_func
(paren
id|ahc
comma
id|scb
comma
id|sg
comma
id|addr
comma
id|cmd-&gt;request_bufflen
)paren
suffix:semicolon
id|sg-&gt;len
op_or_assign
id|ahc_htole32
c_func
(paren
id|AHC_DMA_LAST_SEG
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Reset the sg list pointer.&n;&t;&t;&t; */
id|scb-&gt;hscb-&gt;sgptr
op_assign
id|ahc_htole32
c_func
(paren
id|scb-&gt;sg_list_phys
op_or
id|SG_FULL_RESID
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Copy the first SG into the &quot;current&quot;&n;&t;&t;&t; * data pointer area.&n;&t;&t;&t; */
id|scb-&gt;hscb-&gt;dataptr
op_assign
id|sg-&gt;addr
suffix:semicolon
id|scb-&gt;hscb-&gt;datacnt
op_assign
id|sg-&gt;len
suffix:semicolon
)brace
r_else
(brace
id|scb-&gt;hscb-&gt;sgptr
op_assign
id|ahc_htole32
c_func
(paren
id|SG_LIST_NULL
)paren
suffix:semicolon
id|scb-&gt;hscb-&gt;dataptr
op_assign
l_int|0
suffix:semicolon
id|scb-&gt;hscb-&gt;datacnt
op_assign
l_int|0
suffix:semicolon
id|scb-&gt;sg_count
op_assign
l_int|0
suffix:semicolon
)brace
id|ahc_sync_sglist
c_func
(paren
id|ahc
comma
id|scb
comma
id|BUS_DMASYNC_PREWRITE
)paren
suffix:semicolon
id|LIST_INSERT_HEAD
c_func
(paren
op_amp
id|ahc-&gt;pending_scbs
comma
id|scb
comma
id|pending_links
)paren
suffix:semicolon
id|dev-&gt;openings
op_decrement
suffix:semicolon
id|dev-&gt;active
op_increment
suffix:semicolon
id|dev-&gt;commands_issued
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|AHC_DEV_PERIODIC_OTAG
)paren
op_ne
l_int|0
)paren
id|dev-&gt;commands_since_idle_or_otag
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We only allow one untagged transaction&n;&t;&t; * per target in the initiator role unless&n;&t;&t; * we are storing a full busy target *lun*&n;&t;&t; * table in SCB space.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|scb-&gt;hscb-&gt;control
op_amp
(paren
id|TARGET_SCB
op_or
id|TAG_ENB
)paren
)paren
op_eq
l_int|0
op_logical_and
(paren
id|ahc-&gt;features
op_amp
id|AHC_SCB_BTT
)paren
op_eq
l_int|0
)paren
(brace
r_struct
id|scb_tailq
op_star
id|untagged_q
suffix:semicolon
r_int
id|target_offset
suffix:semicolon
id|target_offset
op_assign
id|SCB_GET_TARGET_OFFSET
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|untagged_q
op_assign
op_amp
(paren
id|ahc-&gt;untagged_queues
(braket
id|target_offset
)braket
)paren
suffix:semicolon
id|TAILQ_INSERT_TAIL
c_func
(paren
id|untagged_q
comma
id|scb
comma
id|links.tqe
)paren
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_UNTAGGEDQ
suffix:semicolon
r_if
c_cond
(paren
id|TAILQ_FIRST
c_func
(paren
id|untagged_q
)paren
op_ne
id|scb
)paren
r_continue
suffix:semicolon
)brace
id|scb-&gt;flags
op_or_assign
id|SCB_ACTIVE
suffix:semicolon
id|ahc_queue_scb
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * SCSI controller interrupt handler.&n; */
id|irqreturn_t
DECL|function|ahc_linux_isr
id|ahc_linux_isr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
id|u_long
id|flags
suffix:semicolon
r_int
id|ours
suffix:semicolon
id|ahc
op_assign
(paren
r_struct
id|ahc_softc
op_star
)paren
id|dev_id
suffix:semicolon
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|flags
)paren
suffix:semicolon
id|ours
op_assign
id|ahc_intr
c_func
(paren
id|ahc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc_linux_next_device_to_run
c_func
(paren
id|ahc
)paren
op_ne
l_int|NULL
)paren
id|ahc_schedule_runq
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_linux_run_complete_queue
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|flags
)paren
suffix:semicolon
r_return
id|IRQ_RETVAL
c_func
(paren
id|ours
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahc_platform_flushwork
id|ahc_platform_flushwork
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_while
c_loop
(paren
id|ahc_linux_run_complete_queue
c_func
(paren
id|ahc
)paren
op_ne
l_int|NULL
)paren
suffix:semicolon
)brace
r_static
r_struct
id|ahc_linux_target
op_star
DECL|function|ahc_linux_alloc_target
id|ahc_linux_alloc_target
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|u_int
id|channel
comma
id|u_int
id|target
)paren
(brace
r_struct
id|ahc_linux_target
op_star
id|targ
suffix:semicolon
id|u_int
id|target_offset
suffix:semicolon
id|target_offset
op_assign
id|target
suffix:semicolon
r_if
c_cond
(paren
id|channel
op_ne
l_int|0
)paren
id|target_offset
op_add_assign
l_int|8
suffix:semicolon
id|targ
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|targ
)paren
comma
id|M_DEVBUG
comma
id|M_NOWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|targ
op_eq
l_int|NULL
)paren
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|targ
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|targ
)paren
)paren
suffix:semicolon
id|targ-&gt;channel
op_assign
id|channel
suffix:semicolon
id|targ-&gt;target
op_assign
id|target
suffix:semicolon
id|targ-&gt;ahc
op_assign
id|ahc
suffix:semicolon
id|targ-&gt;flags
op_assign
id|AHC_DV_REQUIRED
suffix:semicolon
id|ahc-&gt;platform_data-&gt;targets
(braket
id|target_offset
)braket
op_assign
id|targ
suffix:semicolon
r_return
(paren
id|targ
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahc_linux_free_target
id|ahc_linux_free_target
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_linux_target
op_star
id|targ
)paren
(brace
r_struct
id|ahc_devinfo
id|devinfo
suffix:semicolon
r_struct
id|ahc_initiator_tinfo
op_star
id|tinfo
suffix:semicolon
r_struct
id|ahc_tmode_tstate
op_star
id|tstate
suffix:semicolon
id|u_int
id|our_id
suffix:semicolon
id|u_int
id|target_offset
suffix:semicolon
r_char
id|channel
suffix:semicolon
multiline_comment|/*&n;&t; * Force a negotiation to async/narrow on any&n;&t; * future command to this device unless a bus&n;&t; * reset occurs between now and that command.&n;&t; */
id|channel
op_assign
l_char|&squot;A&squot;
op_plus
id|targ-&gt;channel
suffix:semicolon
id|our_id
op_assign
id|ahc-&gt;our_id
suffix:semicolon
id|target_offset
op_assign
id|targ-&gt;target
suffix:semicolon
r_if
c_cond
(paren
id|targ-&gt;channel
op_ne
l_int|0
)paren
(brace
id|target_offset
op_add_assign
l_int|8
suffix:semicolon
id|our_id
op_assign
id|ahc-&gt;our_id_b
suffix:semicolon
)brace
id|tinfo
op_assign
id|ahc_fetch_transinfo
c_func
(paren
id|ahc
comma
id|channel
comma
id|our_id
comma
id|targ-&gt;target
comma
op_amp
id|tstate
)paren
suffix:semicolon
id|ahc_compile_devinfo
c_func
(paren
op_amp
id|devinfo
comma
id|our_id
comma
id|targ-&gt;target
comma
id|CAM_LUN_WILDCARD
comma
id|channel
comma
id|ROLE_INITIATOR
)paren
suffix:semicolon
id|ahc_set_syncrate
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|AHC_TRANS_GOAL
comma
multiline_comment|/*paused*/
id|FALSE
)paren
suffix:semicolon
id|ahc_set_width
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
comma
id|MSG_EXT_WDTR_BUS_8_BIT
comma
id|AHC_TRANS_GOAL
comma
multiline_comment|/*paused*/
id|FALSE
)paren
suffix:semicolon
id|ahc_update_neg_request
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
comma
id|tstate
comma
id|tinfo
comma
id|AHC_NEG_ALWAYS
)paren
suffix:semicolon
id|ahc-&gt;platform_data-&gt;targets
(braket
id|target_offset
)braket
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|targ-&gt;inq_data
op_ne
l_int|NULL
)paren
id|free
c_func
(paren
id|targ-&gt;inq_data
comma
id|M_DEVBUF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|targ-&gt;dv_buffer
op_ne
l_int|NULL
)paren
id|free
c_func
(paren
id|targ-&gt;dv_buffer
comma
id|M_DEVBUF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|targ-&gt;dv_buffer1
op_ne
l_int|NULL
)paren
id|free
c_func
(paren
id|targ-&gt;dv_buffer1
comma
id|M_DEVBUF
)paren
suffix:semicolon
id|free
c_func
(paren
id|targ
comma
id|M_DEVBUF
)paren
suffix:semicolon
)brace
r_static
r_struct
id|ahc_linux_device
op_star
DECL|function|ahc_linux_alloc_device
id|ahc_linux_alloc_device
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_linux_target
op_star
id|targ
comma
id|u_int
id|lun
)paren
(brace
r_struct
id|ahc_linux_device
op_star
id|dev
suffix:semicolon
id|dev
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|dev
)paren
comma
id|M_DEVBUG
comma
id|M_NOWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|dev
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|dev
)paren
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|dev-&gt;timer
)paren
suffix:semicolon
id|TAILQ_INIT
c_func
(paren
op_amp
id|dev-&gt;busyq
)paren
suffix:semicolon
id|dev-&gt;flags
op_assign
id|AHC_DEV_UNCONFIGURED
suffix:semicolon
id|dev-&gt;lun
op_assign
id|lun
suffix:semicolon
id|dev-&gt;target
op_assign
id|targ
suffix:semicolon
multiline_comment|/*&n;&t; * We start out life using untagged&n;&t; * transactions of which we allow one.&n;&t; */
id|dev-&gt;openings
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Set maxtags to 0.  This will be changed if we&n;&t; * later determine that we are dealing with&n;&t; * a tagged queuing capable device.&n;&t; */
id|dev-&gt;maxtags
op_assign
l_int|0
suffix:semicolon
id|targ-&gt;refcount
op_increment
suffix:semicolon
id|targ-&gt;devices
(braket
id|lun
)braket
op_assign
id|dev
suffix:semicolon
r_return
(paren
id|dev
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahc_linux_free_device
id|ahc_linux_free_device
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_linux_device
op_star
id|dev
)paren
(brace
r_struct
id|ahc_linux_target
op_star
id|targ
suffix:semicolon
id|del_timer_sync
c_func
(paren
op_amp
id|dev-&gt;timer
)paren
suffix:semicolon
id|targ
op_assign
id|dev-&gt;target
suffix:semicolon
id|targ-&gt;devices
(braket
id|dev-&gt;lun
)braket
op_assign
l_int|NULL
suffix:semicolon
id|free
c_func
(paren
id|dev
comma
id|M_DEVBUF
)paren
suffix:semicolon
id|targ-&gt;refcount
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|targ-&gt;refcount
op_eq
l_int|0
op_logical_and
(paren
id|targ-&gt;flags
op_amp
id|AHC_DV_REQUIRED
)paren
op_eq
l_int|0
)paren
id|ahc_linux_free_target
c_func
(paren
id|ahc
comma
id|targ
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahc_send_async
id|ahc_send_async
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_char
id|channel
comma
id|u_int
id|target
comma
id|u_int
id|lun
comma
id|ac_code
id|code
comma
r_void
op_star
id|arg
)paren
(brace
r_switch
c_cond
(paren
id|code
)paren
(brace
r_case
id|AC_TRANSFER_NEG
suffix:colon
(brace
r_char
id|buf
(braket
l_int|80
)braket
suffix:semicolon
r_struct
id|ahc_linux_target
op_star
id|targ
suffix:semicolon
r_struct
id|info_str
id|info
suffix:semicolon
r_struct
id|ahc_initiator_tinfo
op_star
id|tinfo
suffix:semicolon
r_struct
id|ahc_tmode_tstate
op_star
id|tstate
suffix:semicolon
r_int
id|target_offset
suffix:semicolon
id|info.buffer
op_assign
id|buf
suffix:semicolon
id|info.length
op_assign
r_sizeof
(paren
id|buf
)paren
suffix:semicolon
id|info.offset
op_assign
l_int|0
suffix:semicolon
id|info.pos
op_assign
l_int|0
suffix:semicolon
id|tinfo
op_assign
id|ahc_fetch_transinfo
c_func
(paren
id|ahc
comma
id|channel
comma
id|channel
op_eq
l_char|&squot;A&squot;
ques
c_cond
id|ahc-&gt;our_id
suffix:colon
id|ahc-&gt;our_id_b
comma
id|target
comma
op_amp
id|tstate
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Don&squot;t bother reporting results while&n;&t;&t; * negotiations are still pending.&n;&t;&t; */
r_if
c_cond
(paren
id|tinfo-&gt;curr.period
op_ne
id|tinfo-&gt;goal.period
op_logical_or
id|tinfo-&gt;curr.width
op_ne
id|tinfo-&gt;goal.width
op_logical_or
id|tinfo-&gt;curr.offset
op_ne
id|tinfo-&gt;goal.offset
op_logical_or
id|tinfo-&gt;curr.ppr_options
op_ne
id|tinfo-&gt;goal.ppr_options
)paren
r_if
c_cond
(paren
id|bootverbose
op_eq
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Don&squot;t bother reporting results that&n;&t;&t; * are identical to those last reported.&n;&t;&t; */
id|target_offset
op_assign
id|target
suffix:semicolon
r_if
c_cond
(paren
id|channel
op_eq
l_char|&squot;B&squot;
)paren
id|target_offset
op_add_assign
l_int|8
suffix:semicolon
id|targ
op_assign
id|ahc-&gt;platform_data-&gt;targets
(braket
id|target_offset
)braket
suffix:semicolon
r_if
c_cond
(paren
id|targ
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|tinfo-&gt;curr.period
op_eq
id|targ-&gt;last_tinfo.period
op_logical_and
id|tinfo-&gt;curr.width
op_eq
id|targ-&gt;last_tinfo.width
op_logical_and
id|tinfo-&gt;curr.offset
op_eq
id|targ-&gt;last_tinfo.offset
op_logical_and
id|tinfo-&gt;curr.ppr_options
op_eq
id|targ-&gt;last_tinfo.ppr_options
)paren
r_if
c_cond
(paren
id|bootverbose
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|targ-&gt;last_tinfo.period
op_assign
id|tinfo-&gt;curr.period
suffix:semicolon
id|targ-&gt;last_tinfo.width
op_assign
id|tinfo-&gt;curr.width
suffix:semicolon
id|targ-&gt;last_tinfo.offset
op_assign
id|tinfo-&gt;curr.offset
suffix:semicolon
id|targ-&gt;last_tinfo.ppr_options
op_assign
id|tinfo-&gt;curr.ppr_options
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;(%s:%c:&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|channel
)paren
suffix:semicolon
r_if
c_cond
(paren
id|target
op_eq
id|CAM_TARGET_WILDCARD
)paren
id|printf
c_func
(paren
l_string|&quot;*): &quot;
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot;%d): &quot;
comma
id|target
)paren
suffix:semicolon
id|ahc_format_transinfo
c_func
(paren
op_amp
id|info
comma
op_amp
id|tinfo-&gt;curr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info.pos
OL
id|info.length
)paren
op_star
id|info.buffer
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_else
id|buf
(braket
id|info.length
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s&quot;
comma
id|buf
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|AC_SENT_BDR
suffix:colon
(brace
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,5,0)
id|WARN_ON
c_func
(paren
id|lun
op_ne
id|CAM_LUN_WILDCARD
)paren
suffix:semicolon
id|scsi_report_device_reset
c_func
(paren
id|ahc-&gt;platform_data-&gt;host
comma
id|channel
op_minus
l_char|&squot;A&squot;
comma
id|target
)paren
suffix:semicolon
macro_line|#elif LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,3,0)
id|Scsi_Device
op_star
id|scsi_dev
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Find the SCSI device associated with this&n;&t;&t; * request and indicate that a UA is expected.&n;&t;&t; */
r_for
c_loop
(paren
id|scsi_dev
op_assign
id|ahc-&gt;platform_data-&gt;host-&gt;host_queue
suffix:semicolon
id|scsi_dev
op_ne
l_int|NULL
suffix:semicolon
id|scsi_dev
op_assign
id|scsi_dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|channel
op_minus
l_char|&squot;A&squot;
op_eq
id|scsi_dev-&gt;channel
op_logical_and
id|target
op_eq
id|scsi_dev-&gt;id
op_logical_and
(paren
id|lun
op_eq
id|CAM_LUN_WILDCARD
op_logical_or
id|lun
op_eq
id|scsi_dev-&gt;lun
)paren
)paren
(brace
id|scsi_dev-&gt;was_reset
op_assign
l_int|1
suffix:semicolon
id|scsi_dev-&gt;expecting_cc_ua
op_assign
l_int|1
suffix:semicolon
)brace
)brace
macro_line|#endif
r_break
suffix:semicolon
)brace
r_case
id|AC_BUS_RESET
suffix:colon
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,3,0)
r_if
c_cond
(paren
id|ahc-&gt;platform_data-&gt;host
op_ne
l_int|NULL
)paren
(brace
id|scsi_report_bus_reset
c_func
(paren
id|ahc-&gt;platform_data-&gt;host
comma
id|channel
op_minus
l_char|&squot;A&squot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;ahc_send_async: Unexpected async event&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Calls the higher level scsi done function and frees the scb.&n; */
r_void
DECL|function|ahc_done
id|ahc_done
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|scb
op_star
id|scb
)paren
(brace
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
r_struct
id|ahc_linux_device
op_star
id|dev
suffix:semicolon
id|LIST_REMOVE
c_func
(paren
id|scb
comma
id|pending_links
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_UNTAGGEDQ
)paren
op_ne
l_int|0
)paren
(brace
r_struct
id|scb_tailq
op_star
id|untagged_q
suffix:semicolon
r_int
id|target_offset
suffix:semicolon
id|target_offset
op_assign
id|SCB_GET_TARGET_OFFSET
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|untagged_q
op_assign
op_amp
(paren
id|ahc-&gt;untagged_queues
(braket
id|target_offset
)braket
)paren
suffix:semicolon
id|TAILQ_REMOVE
c_func
(paren
id|untagged_q
comma
id|scb
comma
id|links.tqe
)paren
suffix:semicolon
id|ahc_run_untagged_queue
c_func
(paren
id|ahc
comma
id|untagged_q
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_ACTIVE
)paren
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;SCB %d done&squot;d twice&bslash;n&quot;
comma
id|scb-&gt;hscb-&gt;tag
)paren
suffix:semicolon
id|ahc_dump_card_state
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;Stopping for safety&quot;
)paren
suffix:semicolon
)brace
id|cmd
op_assign
id|scb-&gt;io_ctx
suffix:semicolon
id|dev
op_assign
id|scb-&gt;platform_data-&gt;dev
suffix:semicolon
id|dev-&gt;active
op_decrement
suffix:semicolon
id|dev-&gt;openings
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmd-&gt;result
op_amp
(paren
id|CAM_DEV_QFRZN
op_lshift
l_int|16
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|cmd-&gt;result
op_and_assign
op_complement
(paren
id|CAM_DEV_QFRZN
op_lshift
l_int|16
)paren
suffix:semicolon
id|dev-&gt;qfrozen
op_decrement
suffix:semicolon
)brace
id|ahc_linux_unmap_scb
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Guard against stale sense data.&n;&t; * The Linux mid-layer assumes that sense&n;&t; * was retrieved anytime the first byte of&n;&t; * the sense buffer looks &quot;sane&quot;.&n;&t; */
id|cmd-&gt;sense_buffer
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ahc_get_transaction_status
c_func
(paren
id|scb
)paren
op_eq
id|CAM_REQ_INPROG
)paren
(brace
r_uint32
id|amount_xferred
suffix:semicolon
id|amount_xferred
op_assign
id|ahc_get_transfer_length
c_func
(paren
id|scb
)paren
op_minus
id|ahc_get_residual
c_func
(paren
id|scb
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_TRANSMISSION_ERROR
)paren
op_ne
l_int|0
)paren
(brace
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_MISC
)paren
op_ne
l_int|0
)paren
(brace
id|ahc_print_path
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Set CAM_UNCOR_PARITY&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|ahc_set_transaction_status
c_func
(paren
id|scb
comma
id|CAM_UNCOR_PARITY
)paren
suffix:semicolon
macro_line|#ifdef AHC_REPORT_UNDERFLOWS
multiline_comment|/*&n;&t;&t; * This code is disabled by default as some&n;&t;&t; * clients of the SCSI system do not properly&n;&t;&t; * initialize the underflow parameter.  This&n;&t;&t; * results in spurious termination of commands&n;&t;&t; * that complete as expected (e.g. underflow is&n;&t;&t; * allowed as command can return variable amounts&n;&t;&t; * of data.&n;&t;&t; */
)brace
r_else
r_if
c_cond
(paren
id|amount_xferred
OL
id|scb-&gt;io_ctx-&gt;underflow
)paren
(brace
id|u_int
id|i
suffix:semicolon
id|ahc_print_path
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;CDB:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|scb-&gt;io_ctx-&gt;cmd_len
suffix:semicolon
id|i
op_increment
)paren
id|printf
c_func
(paren
l_string|&quot; 0x%x&quot;
comma
id|scb-&gt;io_ctx-&gt;cmnd
(braket
id|i
)braket
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|ahc_print_path
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Saw underflow (%ld of %ld bytes). &quot;
l_string|&quot;Treated as error&bslash;n&quot;
comma
id|ahc_get_residual
c_func
(paren
id|scb
)paren
comma
id|ahc_get_transfer_length
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
id|ahc_set_transaction_status
c_func
(paren
id|scb
comma
id|CAM_DATA_RUN_ERR
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|ahc_set_transaction_status
c_func
(paren
id|scb
comma
id|CAM_REQ_CMP
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|ahc_get_transaction_status
c_func
(paren
id|scb
)paren
op_eq
id|CAM_SCSI_STATUS_ERROR
)paren
(brace
id|ahc_linux_handle_scsi_status
c_func
(paren
id|ahc
comma
id|dev
comma
id|scb
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ahc_get_transaction_status
c_func
(paren
id|scb
)paren
op_eq
id|CAM_SEL_TIMEOUT
)paren
(brace
id|dev-&gt;flags
op_or_assign
id|AHC_DEV_UNCONFIGURED
suffix:semicolon
r_if
c_cond
(paren
id|AHC_DV_CMD
c_func
(paren
id|cmd
)paren
op_eq
id|FALSE
)paren
id|dev-&gt;target-&gt;flags
op_and_assign
op_complement
id|AHC_DV_REQUIRED
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Start DV for devices that require it assuming the first command&n;&t; * sent does not result in a selection timeout.&n;&t; */
r_if
c_cond
(paren
id|ahc_get_transaction_status
c_func
(paren
id|scb
)paren
op_ne
id|CAM_SEL_TIMEOUT
op_logical_and
(paren
id|dev-&gt;target-&gt;flags
op_amp
id|AHC_DV_REQUIRED
)paren
op_ne
l_int|0
)paren
id|ahc_linux_start_dv
c_func
(paren
id|ahc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;openings
op_eq
l_int|1
op_logical_and
id|ahc_get_transaction_status
c_func
(paren
id|scb
)paren
op_eq
id|CAM_REQ_CMP
op_logical_and
id|ahc_get_scsi_status
c_func
(paren
id|scb
)paren
op_ne
id|SCSI_STATUS_QUEUE_FULL
)paren
id|dev-&gt;tag_success_count
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * Some devices deal with temporary internal resource&n;&t; * shortages by returning queue full.  When the queue&n;&t; * full occurrs, we throttle back.  Slowly try to get&n;&t; * back to our previous queue depth.&n;&t; */
r_if
c_cond
(paren
(paren
id|dev-&gt;openings
op_plus
id|dev-&gt;active
)paren
template_param
id|AHC_TAG_SUCCESS_INTERVAL
)paren
(brace
id|dev-&gt;tag_success_count
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;openings
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;active
op_eq
l_int|0
)paren
id|dev-&gt;commands_since_idle_or_otag
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|TAILQ_EMPTY
c_func
(paren
op_amp
id|dev-&gt;busyq
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|AHC_DEV_UNCONFIGURED
)paren
op_ne
l_int|0
op_logical_and
id|dev-&gt;active
op_eq
l_int|0
op_logical_and
(paren
id|dev-&gt;flags
op_amp
id|AHC_DEV_TIMER_ACTIVE
)paren
op_eq
l_int|0
)paren
id|ahc_linux_free_device
c_func
(paren
id|ahc
comma
id|dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|AHC_DEV_ON_RUN_LIST
)paren
op_eq
l_int|0
)paren
(brace
id|TAILQ_INSERT_TAIL
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;device_runq
comma
id|dev
comma
id|links
)paren
suffix:semicolon
id|dev-&gt;flags
op_or_assign
id|AHC_DEV_ON_RUN_LIST
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_RECOVERY_SCB
)paren
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Recovery SCB completes&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc_get_transaction_status
c_func
(paren
id|scb
)paren
op_eq
id|CAM_BDR_SENT
op_logical_or
id|ahc_get_transaction_status
c_func
(paren
id|scb
)paren
op_eq
id|CAM_REQ_ABORTED
)paren
id|ahc_set_transaction_status
c_func
(paren
id|scb
comma
id|CAM_CMD_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;platform_data-&gt;flags
op_amp
id|AHC_UP_EH_SEMAPHORE
)paren
op_ne
l_int|0
)paren
(brace
id|ahc-&gt;platform_data-&gt;flags
op_and_assign
op_complement
id|AHC_UP_EH_SEMAPHORE
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;eh_sem
)paren
suffix:semicolon
)brace
)brace
id|ahc_free_scb
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|ahc_linux_queue_cmd_complete
c_func
(paren
id|ahc
comma
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;platform_data-&gt;flags
op_amp
id|AHC_DV_WAIT_SIMQ_EMPTY
)paren
op_ne
l_int|0
op_logical_and
id|LIST_FIRST
c_func
(paren
op_amp
id|ahc-&gt;pending_scbs
)paren
op_eq
l_int|NULL
)paren
(brace
id|ahc-&gt;platform_data-&gt;flags
op_and_assign
op_complement
id|AHC_DV_WAIT_SIMQ_EMPTY
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;dv_sem
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|ahc_linux_handle_scsi_status
id|ahc_linux_handle_scsi_status
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_linux_device
op_star
id|dev
comma
r_struct
id|scb
op_star
id|scb
)paren
(brace
r_struct
id|ahc_devinfo
id|devinfo
suffix:semicolon
id|ahc_compile_devinfo
c_func
(paren
op_amp
id|devinfo
comma
id|ahc-&gt;our_id
comma
id|dev-&gt;target-&gt;target
comma
id|dev-&gt;lun
comma
id|dev-&gt;target-&gt;channel
op_eq
l_int|0
ques
c_cond
l_char|&squot;A&squot;
suffix:colon
l_char|&squot;B&squot;
comma
id|ROLE_INITIATOR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We don&squot;t currently trust the mid-layer to&n;&t; * properly deal with queue full or busy.  So,&n;&t; * when one occurs, we tell the mid-layer to&n;&t; * unconditionally requeue the command to us&n;&t; * so that we can retry it ourselves.  We also&n;&t; * implement our own throttling mechanism so&n;&t; * we don&squot;t clobber the device with too many&n;&t; * commands.&n;&t; */
r_switch
c_cond
(paren
id|ahc_get_scsi_status
c_func
(paren
id|scb
)paren
)paren
(brace
r_default
suffix:colon
r_break
suffix:semicolon
r_case
id|SCSI_STATUS_CHECK_COND
suffix:colon
r_case
id|SCSI_STATUS_CMD_TERMINATED
suffix:colon
(brace
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Copy sense information to the OS&squot;s cmd&n;&t;&t; * structure if it is available.&n;&t;&t; */
id|cmd
op_assign
id|scb-&gt;io_ctx
suffix:semicolon
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_SENSE
)paren
(brace
id|u_int
id|sense_size
suffix:semicolon
id|sense_size
op_assign
id|MIN
c_func
(paren
r_sizeof
(paren
r_struct
id|scsi_sense_data
)paren
op_minus
id|ahc_get_sense_residual
c_func
(paren
id|scb
)paren
comma
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|cmd-&gt;sense_buffer
comma
id|ahc_get_sense_buf
c_func
(paren
id|ahc
comma
id|scb
)paren
comma
id|sense_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sense_size
OL
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
)paren
id|memset
c_func
(paren
op_amp
id|cmd-&gt;sense_buffer
(braket
id|sense_size
)braket
comma
l_int|0
comma
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
op_minus
id|sense_size
)paren
suffix:semicolon
id|cmd-&gt;result
op_or_assign
(paren
id|DRIVER_SENSE
op_lshift
l_int|24
)paren
suffix:semicolon
macro_line|#ifdef AHC_DEBUG
r_if
c_cond
(paren
id|ahc_debug
op_amp
id|AHC_SHOW_SENSE
)paren
(brace
r_int
id|i
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Copied %d bytes of sense data:&quot;
comma
id|sense_size
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sense_size
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_amp
l_int|0xF
)paren
op_eq
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;0x%x &quot;
comma
id|cmd-&gt;sense_buffer
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
r_break
suffix:semicolon
)brace
r_case
id|SCSI_STATUS_QUEUE_FULL
suffix:colon
(brace
multiline_comment|/*&n;&t;&t; * By the time the core driver has returned this&n;&t;&t; * command, all other commands that were queued&n;&t;&t; * to us but not the device have been returned.&n;&t;&t; * This ensures that dev-&gt;active is equal to&n;&t;&t; * the number of commands actually queued to&n;&t;&t; * the device.&n;&t;&t; */
id|dev-&gt;tag_success_count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;active
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Drop our opening count to the number&n;&t;&t;&t; * of commands currently outstanding.&n;&t;&t;&t; */
id|dev-&gt;openings
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;ahc_print_path(ahc, scb);&n;&t;&t;&t;printf(&quot;Dropping tag count to %d&bslash;n&quot;, dev-&gt;active);&n; */
r_if
c_cond
(paren
id|dev-&gt;active
op_eq
id|dev-&gt;tags_on_last_queuefull
)paren
(brace
id|dev-&gt;last_queuefull_same_count
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * If we repeatedly see a queue full&n;&t;&t;&t;&t; * at the same queue depth, this&n;&t;&t;&t;&t; * device has a fixed number of tag&n;&t;&t;&t;&t; * slots.  Lock in this tag depth&n;&t;&t;&t;&t; * so we stop seeing queue fulls from&n;&t;&t;&t;&t; * this device.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|dev-&gt;last_queuefull_same_count
op_eq
id|AHC_LOCK_TAGS_COUNT
)paren
(brace
id|dev-&gt;maxtags
op_assign
id|dev-&gt;active
suffix:semicolon
id|ahc_print_path
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Locking max tag count at %d&bslash;n&quot;
comma
id|dev-&gt;active
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|dev-&gt;tags_on_last_queuefull
op_assign
id|dev-&gt;active
suffix:semicolon
id|dev-&gt;last_queuefull_same_count
op_assign
l_int|0
suffix:semicolon
)brace
id|ahc_set_transaction_status
c_func
(paren
id|scb
comma
id|CAM_REQUEUE_REQ
)paren
suffix:semicolon
id|ahc_set_scsi_status
c_func
(paren
id|scb
comma
id|SCSI_STATUS_OK
)paren
suffix:semicolon
id|ahc_platform_set_tags
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
comma
(paren
id|dev-&gt;flags
op_amp
id|AHC_DEV_Q_BASIC
)paren
ques
c_cond
id|AHC_QUEUE_BASIC
suffix:colon
id|AHC_QUEUE_TAGGED
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Drop down to a single opening, and treat this&n;&t;&t; * as if the target returned BUSY SCSI status.&n;&t;&t; */
id|dev-&gt;openings
op_assign
l_int|1
suffix:semicolon
id|ahc_set_scsi_status
c_func
(paren
id|scb
comma
id|SCSI_STATUS_BUSY
)paren
suffix:semicolon
id|ahc_platform_set_tags
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
comma
(paren
id|dev-&gt;flags
op_amp
id|AHC_DEV_Q_BASIC
)paren
ques
c_cond
id|AHC_QUEUE_BASIC
suffix:colon
id|AHC_QUEUE_TAGGED
)paren
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
)brace
r_case
id|SCSI_STATUS_BUSY
suffix:colon
(brace
multiline_comment|/*&n;&t;&t; * Set a short timer to defer sending commands for&n;&t;&t; * a bit since Linux will not delay in this case.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|AHC_DEV_TIMER_ACTIVE
)paren
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s:%c:%d: Device Timer still active during &quot;
l_string|&quot;busy processing&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|dev-&gt;target-&gt;channel
comma
id|dev-&gt;target-&gt;target
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|dev-&gt;flags
op_or_assign
id|AHC_DEV_TIMER_ACTIVE
suffix:semicolon
id|dev-&gt;qfrozen
op_increment
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|dev-&gt;timer
)paren
suffix:semicolon
id|dev-&gt;timer.data
op_assign
(paren
id|u_long
)paren
id|dev
suffix:semicolon
id|dev-&gt;timer.expires
op_assign
id|jiffies
op_plus
(paren
id|HZ
op_div
l_int|2
)paren
suffix:semicolon
id|dev-&gt;timer.function
op_assign
id|ahc_linux_dev_timed_unfreeze
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|dev-&gt;timer
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_static
r_void
DECL|function|ahc_linux_queue_cmd_complete
id|ahc_linux_queue_cmd_complete
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
multiline_comment|/*&n;&t; * Typically, the complete queue has very few entries&n;&t; * queued to it before the queue is emptied by&n;&t; * ahc_linux_run_complete_queue, so sorting the entries&n;&t; * by generation number should be inexpensive.&n;&t; * We perform the sort so that commands that complete&n;&t; * with an error are retuned in the order origionally&n;&t; * queued to the controller so that any subsequent retries&n;&t; * are performed in order.  The underlying ahc routines do&n;&t; * not guarantee the order that aborted commands will be&n;&t; * returned to us.&n;&t; */
r_struct
id|ahc_completeq
op_star
id|completeq
suffix:semicolon
r_struct
id|ahc_cmd
op_star
id|list_cmd
suffix:semicolon
r_struct
id|ahc_cmd
op_star
id|acmd
suffix:semicolon
multiline_comment|/*&n;&t; * Map CAM error codes into Linux Error codes.  We&n;&t; * avoid the conversion so that the DV code has the&n;&t; * full error information available when making&n;&t; * state change decisions.&n;&t; */
r_if
c_cond
(paren
id|AHC_DV_CMD
c_func
(paren
id|cmd
)paren
op_eq
id|FALSE
)paren
(brace
id|u_int
id|new_status
suffix:semicolon
r_switch
c_cond
(paren
id|ahc_cmd_get_transaction_status
c_func
(paren
id|cmd
)paren
)paren
(brace
r_case
id|CAM_REQ_INPROG
suffix:colon
r_case
id|CAM_REQ_CMP
suffix:colon
r_case
id|CAM_SCSI_STATUS_ERROR
suffix:colon
id|new_status
op_assign
id|DID_OK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CAM_REQ_ABORTED
suffix:colon
id|new_status
op_assign
id|DID_ABORT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CAM_BUSY
suffix:colon
id|new_status
op_assign
id|DID_BUS_BUSY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CAM_REQ_INVALID
suffix:colon
r_case
id|CAM_PATH_INVALID
suffix:colon
id|new_status
op_assign
id|DID_BAD_TARGET
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CAM_SEL_TIMEOUT
suffix:colon
id|new_status
op_assign
id|DID_NO_CONNECT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CAM_SCSI_BUS_RESET
suffix:colon
r_case
id|CAM_BDR_SENT
suffix:colon
id|new_status
op_assign
id|DID_RESET
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CAM_UNCOR_PARITY
suffix:colon
id|new_status
op_assign
id|DID_PARITY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CAM_CMD_TIMEOUT
suffix:colon
id|new_status
op_assign
id|DID_TIME_OUT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CAM_UA_ABORT
suffix:colon
r_case
id|CAM_REQ_CMP_ERR
suffix:colon
r_case
id|CAM_AUTOSENSE_FAIL
suffix:colon
r_case
id|CAM_NO_HBA
suffix:colon
r_case
id|CAM_DATA_RUN_ERR
suffix:colon
r_case
id|CAM_UNEXP_BUSFREE
suffix:colon
r_case
id|CAM_SEQUENCE_FAIL
suffix:colon
r_case
id|CAM_CCB_LEN_ERR
suffix:colon
r_case
id|CAM_PROVIDE_FAIL
suffix:colon
r_case
id|CAM_REQ_TERMIO
suffix:colon
r_case
id|CAM_UNREC_HBA_ERROR
suffix:colon
r_case
id|CAM_REQ_TOO_BIG
suffix:colon
id|new_status
op_assign
id|DID_ERROR
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CAM_REQUEUE_REQ
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * If we want the request requeued, make sure there&n;&t;&t;&t; * are sufficent retries.  In the old scsi error code,&n;&t;&t;&t; * we used to be able to specify a result code that&n;&t;&t;&t; * bypassed the retry count.  Now we must use this&n;&t;&t;&t; * hack.  We also &quot;fake&quot; a check condition with&n;&t;&t;&t; * a sense code of ABORTED COMMAND.  This seems to&n;&t;&t;&t; * evoke a retry even if this command is being sent&n;&t;&t;&t; * via the eh thread.  Ick!  Ick!  Ick!&n;&t;&t;&t; */
r_if
c_cond
(paren
id|cmd-&gt;retries
OG
l_int|0
)paren
id|cmd-&gt;retries
op_decrement
suffix:semicolon
id|new_status
op_assign
id|DID_OK
suffix:semicolon
id|ahc_cmd_set_scsi_status
c_func
(paren
id|cmd
comma
id|SCSI_STATUS_CHECK_COND
)paren
suffix:semicolon
id|cmd-&gt;result
op_or_assign
(paren
id|DRIVER_SENSE
op_lshift
l_int|24
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cmd-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
)paren
suffix:semicolon
id|cmd-&gt;sense_buffer
(braket
l_int|0
)braket
op_assign
id|SSD_ERRCODE_VALID
op_or
id|SSD_CURRENT_ERROR
suffix:semicolon
id|cmd-&gt;sense_buffer
(braket
l_int|2
)braket
op_assign
id|SSD_KEY_ABORTED_COMMAND
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* We should never get here */
id|new_status
op_assign
id|DID_ERROR
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ahc_cmd_set_transaction_status
c_func
(paren
id|cmd
comma
id|new_status
)paren
suffix:semicolon
)brace
id|completeq
op_assign
op_amp
id|ahc-&gt;platform_data-&gt;completeq
suffix:semicolon
id|list_cmd
op_assign
id|TAILQ_FIRST
c_func
(paren
id|completeq
)paren
suffix:semicolon
id|acmd
op_assign
(paren
r_struct
id|ahc_cmd
op_star
)paren
id|cmd
suffix:semicolon
r_while
c_loop
(paren
id|list_cmd
op_ne
l_int|NULL
op_logical_and
id|acmd_scsi_cmd
c_func
(paren
id|list_cmd
)paren
dot
id|serial_number
OL
id|acmd_scsi_cmd
c_func
(paren
id|acmd
)paren
dot
id|serial_number
)paren
id|list_cmd
op_assign
id|TAILQ_NEXT
c_func
(paren
id|list_cmd
comma
id|acmd_links.tqe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_cmd
op_ne
l_int|NULL
)paren
id|TAILQ_INSERT_BEFORE
c_func
(paren
id|list_cmd
comma
id|acmd
comma
id|acmd_links.tqe
)paren
suffix:semicolon
r_else
id|TAILQ_INSERT_TAIL
c_func
(paren
id|completeq
comma
id|acmd
comma
id|acmd_links.tqe
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahc_linux_filter_inquiry
id|ahc_linux_filter_inquiry
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
)paren
(brace
r_struct
id|scsi_inquiry_data
op_star
id|sid
suffix:semicolon
r_struct
id|ahc_initiator_tinfo
op_star
id|tinfo
suffix:semicolon
r_struct
id|ahc_transinfo
op_star
id|user
suffix:semicolon
r_struct
id|ahc_transinfo
op_star
id|goal
suffix:semicolon
r_struct
id|ahc_transinfo
op_star
id|curr
suffix:semicolon
r_struct
id|ahc_tmode_tstate
op_star
id|tstate
suffix:semicolon
r_struct
id|ahc_syncrate
op_star
id|syncrate
suffix:semicolon
r_struct
id|ahc_linux_device
op_star
id|dev
suffix:semicolon
id|u_int
id|maxsync
suffix:semicolon
id|u_int
id|width
suffix:semicolon
id|u_int
id|period
suffix:semicolon
id|u_int
id|offset
suffix:semicolon
id|u_int
id|ppr_options
suffix:semicolon
id|u_int
id|trans_version
suffix:semicolon
id|u_int
id|prot_version
suffix:semicolon
multiline_comment|/*&n;&t; * Determine if this lun actually exists.  If so,&n;&t; * hold on to its corresponding device structure.&n;&t; * If not, make sure we release the device and&n;&t; * don&squot;t bother processing the rest of this inquiry&n;&t; * command.&n;&t; */
id|dev
op_assign
id|ahc_linux_get_device
c_func
(paren
id|ahc
comma
id|devinfo-&gt;channel
op_minus
l_char|&squot;A&squot;
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
comma
multiline_comment|/*alloc*/
id|TRUE
)paren
suffix:semicolon
id|sid
op_assign
(paren
r_struct
id|scsi_inquiry_data
op_star
)paren
id|dev-&gt;target-&gt;inq_data
suffix:semicolon
r_if
c_cond
(paren
id|SID_QUAL
c_func
(paren
id|sid
)paren
op_eq
id|SID_QUAL_LU_CONNECTED
)paren
(brace
id|dev-&gt;flags
op_and_assign
op_complement
id|AHC_DEV_UNCONFIGURED
suffix:semicolon
)brace
r_else
(brace
id|dev-&gt;flags
op_or_assign
id|AHC_DEV_UNCONFIGURED
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Update our notion of this device&squot;s transfer&n;&t; * negotiation capabilities.&n;&t; */
id|tinfo
op_assign
id|ahc_fetch_transinfo
c_func
(paren
id|ahc
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;our_scsiid
comma
id|devinfo-&gt;target
comma
op_amp
id|tstate
)paren
suffix:semicolon
id|user
op_assign
op_amp
id|tinfo-&gt;user
suffix:semicolon
id|goal
op_assign
op_amp
id|tinfo-&gt;goal
suffix:semicolon
id|curr
op_assign
op_amp
id|tinfo-&gt;curr
suffix:semicolon
id|width
op_assign
id|user-&gt;width
suffix:semicolon
id|period
op_assign
id|user-&gt;period
suffix:semicolon
id|offset
op_assign
id|user-&gt;offset
suffix:semicolon
id|ppr_options
op_assign
id|user-&gt;ppr_options
suffix:semicolon
id|trans_version
op_assign
id|user-&gt;transport_version
suffix:semicolon
id|prot_version
op_assign
id|MIN
c_func
(paren
id|user-&gt;protocol_version
comma
id|SID_ANSI_REV
c_func
(paren
id|sid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Only attempt SPI3/4 once we&squot;ve verified that&n;&t; * the device claims to support SPI3/4 features.&n;&t; */
r_if
c_cond
(paren
id|prot_version
OL
id|SCSI_REV_2
)paren
id|trans_version
op_assign
id|SID_ANSI_REV
c_func
(paren
id|sid
)paren
suffix:semicolon
r_else
id|trans_version
op_assign
id|SCSI_REV_2
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sid-&gt;flags
op_amp
id|SID_WBus16
)paren
op_eq
l_int|0
)paren
id|width
op_assign
id|MSG_EXT_WDTR_BUS_8_BIT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sid-&gt;flags
op_amp
id|SID_Sync
)paren
op_eq
l_int|0
)paren
(brace
id|period
op_assign
l_int|0
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
id|ppr_options
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|sid-&gt;spi3data
op_amp
id|SID_SPI_QAS
)paren
op_eq
l_int|0
)paren
id|ppr_options
op_and_assign
op_complement
id|MSG_EXT_PPR_QAS_REQ
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sid-&gt;spi3data
op_amp
id|SID_SPI_CLOCK_DT
)paren
op_eq
l_int|0
)paren
id|ppr_options
op_and_assign
id|MSG_EXT_PPR_QAS_REQ
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sid-&gt;spi3data
op_amp
id|SID_SPI_IUS
)paren
op_eq
l_int|0
)paren
id|ppr_options
op_and_assign
(paren
id|MSG_EXT_PPR_DT_REQ
op_or
id|MSG_EXT_PPR_QAS_REQ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prot_version
OG
id|SCSI_REV_2
op_logical_and
id|ppr_options
op_ne
l_int|0
)paren
id|trans_version
op_assign
id|user-&gt;transport_version
suffix:semicolon
id|ahc_validate_width
c_func
(paren
id|ahc
comma
multiline_comment|/*tinfo limit*/
l_int|NULL
comma
op_amp
id|width
comma
id|ROLE_UNKNOWN
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_ne
l_int|0
)paren
id|maxsync
op_assign
id|AHC_SYNCRATE_DT
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_ULTRA
)paren
op_ne
l_int|0
)paren
id|maxsync
op_assign
id|AHC_SYNCRATE_ULTRA
suffix:semicolon
r_else
id|maxsync
op_assign
id|AHC_SYNCRATE_FAST
suffix:semicolon
id|syncrate
op_assign
id|ahc_find_syncrate
c_func
(paren
id|ahc
comma
op_amp
id|period
comma
op_amp
id|ppr_options
comma
id|maxsync
)paren
suffix:semicolon
id|ahc_validate_offset
c_func
(paren
id|ahc
comma
multiline_comment|/*tinfo limit*/
l_int|NULL
comma
id|syncrate
comma
op_amp
id|offset
comma
id|width
comma
id|ROLE_UNKNOWN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_eq
l_int|0
op_logical_or
id|period
op_eq
l_int|0
)paren
(brace
id|period
op_assign
l_int|0
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
id|ppr_options
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Apply our filtered user settings. */
id|curr-&gt;transport_version
op_assign
id|trans_version
suffix:semicolon
id|curr-&gt;protocol_version
op_assign
id|prot_version
suffix:semicolon
id|ahc_set_width
c_func
(paren
id|ahc
comma
id|devinfo
comma
id|width
comma
id|AHC_TRANS_GOAL
comma
multiline_comment|/*paused*/
id|FALSE
)paren
suffix:semicolon
id|ahc_set_syncrate
c_func
(paren
id|ahc
comma
id|devinfo
comma
id|syncrate
comma
id|period
comma
id|offset
comma
id|ppr_options
comma
id|AHC_TRANS_GOAL
comma
multiline_comment|/*paused*/
id|FALSE
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahc_linux_sem_timeout
id|ahc_linux_sem_timeout
c_func
(paren
id|u_long
id|arg
)paren
(brace
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
id|u_long
id|s
suffix:semicolon
id|ahc
op_assign
(paren
r_struct
id|ahc_softc
op_star
)paren
id|arg
suffix:semicolon
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;platform_data-&gt;flags
op_amp
id|AHC_UP_EH_SEMAPHORE
)paren
op_ne
l_int|0
)paren
(brace
id|ahc-&gt;platform_data-&gt;flags
op_and_assign
op_complement
id|AHC_UP_EH_SEMAPHORE
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;eh_sem
)paren
suffix:semicolon
)brace
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahc_linux_freeze_simq
id|ahc_linux_freeze_simq
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
id|ahc-&gt;platform_data-&gt;qfrozen
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;platform_data-&gt;qfrozen
op_eq
l_int|1
)paren
(brace
id|scsi_block_requests
c_func
(paren
id|ahc-&gt;platform_data-&gt;host
)paren
suffix:semicolon
multiline_comment|/* XXX What about Twin channels? */
id|ahc_platform_abort_scbs
c_func
(paren
id|ahc
comma
id|CAM_TARGET_WILDCARD
comma
id|ALL_CHANNELS
comma
id|CAM_LUN_WILDCARD
comma
id|SCB_LIST_NULL
comma
id|ROLE_INITIATOR
comma
id|CAM_REQUEUE_REQ
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|ahc_linux_release_simq
id|ahc_linux_release_simq
c_func
(paren
id|u_long
id|arg
)paren
(brace
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
id|u_long
id|s
suffix:semicolon
r_int
id|unblock_reqs
suffix:semicolon
id|ahc
op_assign
(paren
r_struct
id|ahc_softc
op_star
)paren
id|arg
suffix:semicolon
id|unblock_reqs
op_assign
l_int|0
suffix:semicolon
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;platform_data-&gt;qfrozen
OG
l_int|0
)paren
id|ahc-&gt;platform_data-&gt;qfrozen
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;platform_data-&gt;qfrozen
op_eq
l_int|0
)paren
id|unblock_reqs
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|AHC_DV_SIMQ_FROZEN
c_func
(paren
id|ahc
)paren
op_logical_and
(paren
(paren
id|ahc-&gt;platform_data-&gt;flags
op_amp
id|AHC_DV_WAIT_SIMQ_RELEASE
)paren
op_ne
l_int|0
)paren
)paren
(brace
id|ahc-&gt;platform_data-&gt;flags
op_and_assign
op_complement
id|AHC_DV_WAIT_SIMQ_RELEASE
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;dv_sem
)paren
suffix:semicolon
)brace
id|ahc_schedule_runq
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * There is still a race here.  The mid-layer&n;&t; * should keep its own freeze count and use&n;&t; * a bottom half handler to run the queues&n;&t; * so we can unblock with our own lock held.&n;&t; */
r_if
c_cond
(paren
id|unblock_reqs
)paren
id|scsi_unblock_requests
c_func
(paren
id|ahc-&gt;platform_data-&gt;host
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahc_linux_dev_timed_unfreeze
id|ahc_linux_dev_timed_unfreeze
c_func
(paren
id|u_long
id|arg
)paren
(brace
r_struct
id|ahc_linux_device
op_star
id|dev
suffix:semicolon
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
id|u_long
id|s
suffix:semicolon
id|dev
op_assign
(paren
r_struct
id|ahc_linux_device
op_star
)paren
id|arg
suffix:semicolon
id|ahc
op_assign
id|dev-&gt;target-&gt;ahc
suffix:semicolon
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
id|dev-&gt;flags
op_and_assign
op_complement
id|AHC_DEV_TIMER_ACTIVE
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;qfrozen
OG
l_int|0
)paren
id|dev-&gt;qfrozen
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;qfrozen
op_eq
l_int|0
op_logical_and
(paren
id|dev-&gt;flags
op_amp
id|AHC_DEV_ON_RUN_LIST
)paren
op_eq
l_int|0
)paren
id|ahc_linux_run_device_queue
c_func
(paren
id|ahc
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TAILQ_EMPTY
c_func
(paren
op_amp
id|dev-&gt;busyq
)paren
op_logical_and
id|dev-&gt;active
op_eq
l_int|0
)paren
id|ahc_linux_free_device
c_func
(paren
id|ahc
comma
id|dev
)paren
suffix:semicolon
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|ahc_linux_queue_recovery_cmd
id|ahc_linux_queue_recovery_cmd
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
id|scb_flag
id|flag
)paren
(brace
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
r_struct
id|ahc_cmd
op_star
id|acmd
suffix:semicolon
r_struct
id|ahc_cmd
op_star
id|list_acmd
suffix:semicolon
r_struct
id|ahc_linux_device
op_star
id|dev
suffix:semicolon
r_struct
id|scb
op_star
id|pending_scb
suffix:semicolon
id|u_long
id|s
suffix:semicolon
id|u_int
id|saved_scbptr
suffix:semicolon
id|u_int
id|active_scb_index
suffix:semicolon
id|u_int
id|last_phase
suffix:semicolon
id|u_int
id|saved_scsiid
suffix:semicolon
id|u_int
id|cdb_byte
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_int
id|was_paused
suffix:semicolon
r_int
id|paused
suffix:semicolon
r_int
id|wait
suffix:semicolon
r_int
id|disconnected
suffix:semicolon
id|pending_scb
op_assign
l_int|NULL
suffix:semicolon
id|paused
op_assign
id|FALSE
suffix:semicolon
id|wait
op_assign
id|FALSE
suffix:semicolon
id|ahc
op_assign
op_star
(paren
r_struct
id|ahc_softc
op_star
op_star
)paren
id|cmd-&gt;device-&gt;host-&gt;hostdata
suffix:semicolon
id|acmd
op_assign
(paren
r_struct
id|ahc_cmd
op_star
)paren
id|cmd
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s:%d:%d:%d: Attempting to queue a%s message&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|cmd-&gt;device-&gt;channel
comma
id|cmd-&gt;device-&gt;id
comma
id|cmd-&gt;device-&gt;lun
comma
id|flag
op_eq
id|SCB_ABORT
ques
c_cond
l_string|&quot;n ABORT&quot;
suffix:colon
l_string|&quot; TARGET RESET&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;CDB:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cdb_byte
op_assign
l_int|0
suffix:semicolon
id|cdb_byte
OL
id|cmd-&gt;cmd_len
suffix:semicolon
id|cdb_byte
op_increment
)paren
id|printf
c_func
(paren
l_string|&quot; 0x%x&quot;
comma
id|cmd-&gt;cmnd
(braket
id|cdb_byte
)braket
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * In all versions of Linux, we have to work around&n;&t; * a major flaw in how the mid-layer is locked down&n;&t; * if we are to sleep successfully in our error handler&n;&t; * while allowing our interrupt handler to run.  Since&n;&t; * the midlayer acquires either the io_request_lock or&n;&t; * our lock prior to calling us, we must use the&n;&t; * spin_unlock_irq() method for unlocking our lock.&n;&t; * This will force interrupts to be enabled on the&n;&t; * current CPU.  Since the EH thread should not have&n;&t; * been running with CPU interrupts disabled other than&n;&t; * by acquiring either the io_request_lock or our own&n;&t; * lock, this *should* be safe.&n;&t; */
id|ahc_midlayer_entrypoint_lock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * First determine if we currently own this command.&n;&t; * Start by searching the device queue.  If not found&n;&t; * there, check the pending_scb list.  If not found&n;&t; * at all, and the system wanted us to just abort the&n;&t; * command, return success.&n;&t; */
id|dev
op_assign
id|ahc_linux_get_device
c_func
(paren
id|ahc
comma
id|cmd-&gt;device-&gt;channel
comma
id|cmd-&gt;device-&gt;id
comma
id|cmd-&gt;device-&gt;lun
comma
multiline_comment|/*alloc*/
id|FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * No target device for this command exists,&n;&t;&t; * so we must not still own the command.&n;&t;&t; */
id|printf
c_func
(paren
l_string|&quot;%s:%d:%d:%d: Is not an active device&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|cmd-&gt;device-&gt;channel
comma
id|cmd-&gt;device-&gt;id
comma
id|cmd-&gt;device-&gt;lun
)paren
suffix:semicolon
id|retval
op_assign
id|SUCCESS
suffix:semicolon
r_goto
id|no_cmd
suffix:semicolon
)brace
id|TAILQ_FOREACH
c_func
(paren
id|list_acmd
comma
op_amp
id|dev-&gt;busyq
comma
id|acmd_links.tqe
)paren
(brace
r_if
c_cond
(paren
id|list_acmd
op_eq
id|acmd
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|list_acmd
op_ne
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s:%d:%d:%d: Command found on device queue&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|cmd-&gt;device-&gt;channel
comma
id|cmd-&gt;device-&gt;id
comma
id|cmd-&gt;device-&gt;lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_eq
id|SCB_ABORT
)paren
(brace
id|TAILQ_REMOVE
c_func
(paren
op_amp
id|dev-&gt;busyq
comma
id|list_acmd
comma
id|acmd_links.tqe
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
id|ahc_linux_queue_cmd_complete
c_func
(paren
id|ahc
comma
id|cmd
)paren
suffix:semicolon
id|retval
op_assign
id|SUCCESS
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
(paren
id|AHC_DEV_Q_BASIC
op_or
id|AHC_DEV_Q_TAGGED
)paren
)paren
op_eq
l_int|0
op_logical_and
id|ahc_search_untagged_queues
c_func
(paren
id|ahc
comma
id|cmd
comma
id|cmd-&gt;device-&gt;id
comma
id|cmd-&gt;device-&gt;channel
op_plus
l_char|&squot;A&squot;
comma
id|cmd-&gt;device-&gt;lun
comma
id|CAM_REQ_ABORTED
comma
id|SEARCH_COMPLETE
)paren
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s:%d:%d:%d: Command found on untagged queue&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|cmd-&gt;device-&gt;channel
comma
id|cmd-&gt;device-&gt;id
comma
id|cmd-&gt;device-&gt;lun
)paren
suffix:semicolon
id|retval
op_assign
id|SUCCESS
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * See if we can find a matching cmd in the pending list.&n;&t; */
id|LIST_FOREACH
c_func
(paren
id|pending_scb
comma
op_amp
id|ahc-&gt;pending_scbs
comma
id|pending_links
)paren
(brace
r_if
c_cond
(paren
id|pending_scb-&gt;io_ctx
op_eq
id|cmd
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pending_scb
op_eq
l_int|NULL
op_logical_and
id|flag
op_eq
id|SCB_DEVICE_RESET
)paren
(brace
multiline_comment|/* Any SCB for this device will do for a target reset */
id|LIST_FOREACH
c_func
(paren
id|pending_scb
comma
op_amp
id|ahc-&gt;pending_scbs
comma
id|pending_links
)paren
(brace
r_if
c_cond
(paren
id|ahc_match_scb
c_func
(paren
id|ahc
comma
id|pending_scb
comma
id|cmd-&gt;device-&gt;id
comma
id|cmd-&gt;device-&gt;channel
op_plus
l_char|&squot;A&squot;
comma
id|CAM_LUN_WILDCARD
comma
id|SCB_LIST_NULL
comma
id|ROLE_INITIATOR
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|pending_scb
op_eq
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s:%d:%d:%d: Command not found&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|cmd-&gt;device-&gt;channel
comma
id|cmd-&gt;device-&gt;id
comma
id|cmd-&gt;device-&gt;lun
)paren
suffix:semicolon
r_goto
id|no_cmd
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|pending_scb-&gt;flags
op_amp
id|SCB_RECOVERY_SCB
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * We can&squot;t queue two recovery actions using the same SCB&n;&t;&t; */
id|retval
op_assign
id|FAILED
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Ensure that the card doesn&squot;t do anything&n;&t; * behind our back and that we didn&squot;t &quot;just&quot; miss&n;&t; * an interrupt that would affect this cmd.&n;&t; */
id|was_paused
op_assign
id|ahc_is_paused
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_pause_and_flushwork
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|paused
op_assign
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pending_scb-&gt;flags
op_amp
id|SCB_ACTIVE
)paren
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s:%d:%d:%d: Command already completed&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|cmd-&gt;device-&gt;channel
comma
id|cmd-&gt;device-&gt;id
comma
id|cmd-&gt;device-&gt;lun
)paren
suffix:semicolon
r_goto
id|no_cmd
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;%s: At time of recovery, card was %spaused&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|was_paused
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;not &quot;
)paren
suffix:semicolon
id|ahc_dump_card_state
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|disconnected
op_assign
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_eq
id|SCB_ABORT
)paren
(brace
r_if
c_cond
(paren
id|ahc_search_qinfifo
c_func
(paren
id|ahc
comma
id|cmd-&gt;device-&gt;id
comma
id|cmd-&gt;device-&gt;channel
op_plus
l_char|&squot;A&squot;
comma
id|cmd-&gt;device-&gt;lun
comma
id|pending_scb-&gt;hscb-&gt;tag
comma
id|ROLE_INITIATOR
comma
id|CAM_REQ_ABORTED
comma
id|SEARCH_COMPLETE
)paren
OG
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s:%d:%d:%d: Cmd aborted from QINFIFO&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|cmd-&gt;device-&gt;channel
comma
id|cmd-&gt;device-&gt;id
comma
id|cmd-&gt;device-&gt;lun
)paren
suffix:semicolon
id|retval
op_assign
id|SUCCESS
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|ahc_search_qinfifo
c_func
(paren
id|ahc
comma
id|cmd-&gt;device-&gt;id
comma
id|cmd-&gt;device-&gt;channel
op_plus
l_char|&squot;A&squot;
comma
id|cmd-&gt;device-&gt;lun
comma
id|pending_scb-&gt;hscb-&gt;tag
comma
id|ROLE_INITIATOR
comma
multiline_comment|/*status*/
l_int|0
comma
id|SEARCH_COUNT
)paren
OG
l_int|0
)paren
(brace
id|disconnected
op_assign
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|disconnected
op_logical_and
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SEQ_FLAGS
)paren
op_amp
id|NOT_IDENTIFIED
)paren
op_eq
l_int|0
)paren
(brace
r_struct
id|scb
op_star
id|bus_scb
suffix:semicolon
id|bus_scb
op_assign
id|ahc_lookup_scb
c_func
(paren
id|ahc
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_TAG
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bus_scb
op_eq
id|pending_scb
)paren
id|disconnected
op_assign
id|FALSE
suffix:semicolon
r_else
r_if
c_cond
(paren
id|flag
op_ne
id|SCB_ABORT
op_logical_and
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SAVED_SCSIID
)paren
op_eq
id|pending_scb-&gt;hscb-&gt;scsiid
op_logical_and
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SAVED_LUN
)paren
op_eq
id|SCB_GET_LUN
c_func
(paren
id|pending_scb
)paren
)paren
id|disconnected
op_assign
id|FALSE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * At this point, pending_scb is the scb associated with the&n;&t; * passed in command.  That command is currently active on the&n;&t; * bus, is in the disconnected state, or we&squot;re hoping to find&n;&t; * a command for the same target active on the bus to abuse to&n;&t; * send a BDR.  Queue the appropriate message based on which of&n;&t; * these states we are in.&n;&t; */
id|last_phase
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|LASTPHASE
)paren
suffix:semicolon
id|saved_scbptr
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCBPTR
)paren
suffix:semicolon
id|active_scb_index
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_TAG
)paren
suffix:semicolon
id|saved_scsiid
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SAVED_SCSIID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last_phase
op_ne
id|P_BUSFREE
op_logical_and
(paren
id|pending_scb-&gt;hscb-&gt;tag
op_eq
id|active_scb_index
op_logical_or
(paren
id|flag
op_eq
id|SCB_DEVICE_RESET
op_logical_and
id|SCSIID_TARGET
c_func
(paren
id|ahc
comma
id|saved_scsiid
)paren
op_eq
id|cmd-&gt;device-&gt;id
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * We&squot;re active on the bus, so assert ATN&n;&t;&t; * and hope that the target responds.&n;&t;&t; */
id|pending_scb
op_assign
id|ahc_lookup_scb
c_func
(paren
id|ahc
comma
id|active_scb_index
)paren
suffix:semicolon
id|pending_scb-&gt;flags
op_or_assign
id|SCB_RECOVERY_SCB
op_or
id|flag
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|MSG_OUT
comma
id|HOST_MSG
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSISIGO
comma
id|last_phase
op_or
id|ATNO
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s:%d:%d:%d: Device is active, asserting ATN&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|cmd-&gt;device-&gt;channel
comma
id|cmd-&gt;device-&gt;id
comma
id|cmd-&gt;device-&gt;lun
)paren
suffix:semicolon
id|wait
op_assign
id|TRUE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|disconnected
)paren
(brace
multiline_comment|/*&n;&t;&t; * Actually re-queue this SCB in an attempt&n;&t;&t; * to select the device before it reconnects.&n;&t;&t; * In either case (selection or reselection),&n;&t;&t; * we will now issue the approprate message&n;&t;&t; * to the timed-out device.&n;&t;&t; *&n;&t;&t; * Set the MK_MESSAGE control bit indicating&n;&t;&t; * that we desire to send a message.  We&n;&t;&t; * also set the disconnected flag since&n;&t;&t; * in the paging case there is no guarantee&n;&t;&t; * that our SCB control byte matches the&n;&t;&t; * version on the card.  We don&squot;t want the&n;&t;&t; * sequencer to abort the command thinking&n;&t;&t; * an unsolicited reselection occurred.&n;&t;&t; */
id|pending_scb-&gt;hscb-&gt;control
op_or_assign
id|MK_MESSAGE
op_or
id|DISCONNECTED
suffix:semicolon
id|pending_scb-&gt;flags
op_or_assign
id|SCB_RECOVERY_SCB
op_or
id|flag
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Remove any cached copy of this SCB in the&n;&t;&t; * disconnected list in preparation for the&n;&t;&t; * queuing of our abort SCB.  We use the&n;&t;&t; * same element in the SCB, SCB_NEXT, for&n;&t;&t; * both the qinfifo and the disconnected list.&n;&t;&t; */
id|ahc_search_disc_list
c_func
(paren
id|ahc
comma
id|cmd-&gt;device-&gt;id
comma
id|cmd-&gt;device-&gt;channel
op_plus
l_char|&squot;A&squot;
comma
id|cmd-&gt;device-&gt;lun
comma
id|pending_scb-&gt;hscb-&gt;tag
comma
multiline_comment|/*stop_on_first*/
id|TRUE
comma
multiline_comment|/*remove*/
id|TRUE
comma
multiline_comment|/*save_state*/
id|FALSE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * In the non-paging case, the sequencer will&n;&t;&t; * never re-reference the in-core SCB.&n;&t;&t; * To make sure we are notified during&n;&t;&t; * reslection, set the MK_MESSAGE flag in&n;&t;&t; * the card&squot;s copy of the SCB.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ahc-&gt;flags
op_amp
id|AHC_PAGESCBS
)paren
op_eq
l_int|0
)paren
(brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBPTR
comma
id|pending_scb-&gt;hscb-&gt;tag
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCB_CONTROL
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_CONTROL
)paren
op_or
id|MK_MESSAGE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Clear out any entries in the QINFIFO first&n;&t;&t; * so we are the next SCB for this target&n;&t;&t; * to run.&n;&t;&t; */
id|ahc_search_qinfifo
c_func
(paren
id|ahc
comma
id|cmd-&gt;device-&gt;id
comma
id|cmd-&gt;device-&gt;channel
op_plus
l_char|&squot;A&squot;
comma
id|cmd-&gt;device-&gt;lun
comma
id|SCB_LIST_NULL
comma
id|ROLE_INITIATOR
comma
id|CAM_REQUEUE_REQ
comma
id|SEARCH_COMPLETE
)paren
suffix:semicolon
id|ahc_qinfifo_requeue_tail
c_func
(paren
id|ahc
comma
id|pending_scb
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBPTR
comma
id|saved_scbptr
)paren
suffix:semicolon
id|ahc_print_path
c_func
(paren
id|ahc
comma
id|pending_scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Device is disconnected, re-queuing SCB&bslash;n&quot;
)paren
suffix:semicolon
id|wait
op_assign
id|TRUE
suffix:semicolon
)brace
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;%s:%d:%d:%d: Unable to deliver message&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|cmd-&gt;device-&gt;channel
comma
id|cmd-&gt;device-&gt;id
comma
id|cmd-&gt;device-&gt;lun
)paren
suffix:semicolon
id|retval
op_assign
id|FAILED
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|no_cmd
suffix:colon
multiline_comment|/*&n;&t; * Our assumption is that if we don&squot;t have the command, no&n;&t; * recovery action was required, so we return success.  Again,&n;&t; * the semantics of the mid-layer recovery engine are not&n;&t; * well defined, so this may change in time.&n;&t; */
id|retval
op_assign
id|SUCCESS
suffix:semicolon
id|done
suffix:colon
r_if
c_cond
(paren
id|paused
)paren
id|ahc_unpause
c_func
(paren
id|ahc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait
)paren
(brace
r_struct
id|timer_list
id|timer
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|ahc-&gt;platform_data-&gt;flags
op_or_assign
id|AHC_UP_EH_SEMAPHORE
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;spin_lock
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|timer
)paren
suffix:semicolon
id|timer.data
op_assign
(paren
id|u_long
)paren
id|ahc
suffix:semicolon
id|timer.expires
op_assign
id|jiffies
op_plus
(paren
l_int|5
op_star
id|HZ
)paren
suffix:semicolon
id|timer.function
op_assign
id|ahc_linux_sem_timeout
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|timer
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Recovery code sleeping&bslash;n&quot;
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;eh_sem
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Recovery code awake&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|del_timer_sync
c_func
(paren
op_amp
id|timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Timer Expired&bslash;n&quot;
)paren
suffix:semicolon
id|retval
op_assign
id|FAILED
suffix:semicolon
)brace
id|spin_lock_irq
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;spin_lock
)paren
suffix:semicolon
)brace
id|ahc_schedule_runq
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_linux_run_complete_queue
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_midlayer_entrypoint_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
r_return
(paren
id|retval
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahc_platform_dump_card_state
id|ahc_platform_dump_card_state
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_struct
id|ahc_linux_device
op_star
id|dev
suffix:semicolon
r_int
id|channel
suffix:semicolon
r_int
id|maxchannel
suffix:semicolon
r_int
id|target
suffix:semicolon
r_int
id|maxtarget
suffix:semicolon
r_int
id|lun
suffix:semicolon
r_int
id|i
suffix:semicolon
id|maxchannel
op_assign
(paren
id|ahc-&gt;features
op_amp
id|AHC_TWIN
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|maxtarget
op_assign
(paren
id|ahc-&gt;features
op_amp
id|AHC_WIDE
)paren
ques
c_cond
l_int|15
suffix:colon
l_int|7
suffix:semicolon
r_for
c_loop
(paren
id|channel
op_assign
l_int|0
suffix:semicolon
id|channel
op_le
id|maxchannel
suffix:semicolon
id|channel
op_increment
)paren
(brace
r_for
c_loop
(paren
id|target
op_assign
l_int|0
suffix:semicolon
id|target
op_le
id|maxtarget
suffix:semicolon
id|target
op_increment
)paren
(brace
r_for
c_loop
(paren
id|lun
op_assign
l_int|0
suffix:semicolon
id|lun
OL
id|AHC_NUM_LUNS
suffix:semicolon
id|lun
op_increment
)paren
(brace
r_struct
id|ahc_cmd
op_star
id|acmd
suffix:semicolon
id|dev
op_assign
id|ahc_linux_get_device
c_func
(paren
id|ahc
comma
id|channel
comma
id|target
comma
id|lun
comma
multiline_comment|/*alloc*/
id|FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;DevQ(%d:%d:%d): &quot;
comma
id|channel
comma
id|target
comma
id|lun
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
id|TAILQ_FOREACH
c_func
(paren
id|acmd
comma
op_amp
id|dev-&gt;busyq
comma
id|acmd_links.tqe
)paren
(brace
r_if
c_cond
(paren
id|i
op_increment
OG
id|AHC_SCB_MAX
)paren
r_break
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;%d waiting&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_static
r_void
id|ahc_linux_exit
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|__init
DECL|function|ahc_linux_init
id|ahc_linux_init
c_func
(paren
r_void
)paren
(brace
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,5,0)
r_int
id|rc
op_assign
id|ahc_linux_detect
c_func
(paren
op_amp
id|aic7xxx_driver_template
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|ahc_linux_exit
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
macro_line|#else
id|scsi_register_module
c_func
(paren
id|MODULE_SCSI_HA
comma
op_amp
id|aic7xxx_driver_template
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_driver_template.present
op_eq
l_int|0
)paren
(brace
id|scsi_unregister_module
c_func
(paren
id|MODULE_SCSI_HA
comma
op_amp
id|aic7xxx_driver_template
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif
)brace
r_static
r_void
DECL|function|ahc_linux_exit
id|ahc_linux_exit
c_func
(paren
r_void
)paren
(brace
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
id|u_long
id|l
suffix:semicolon
multiline_comment|/*&n;&t; * Shutdown DV threads before going into the SCSI mid-layer.&n;&t; * This avoids situations where the mid-layer locks the entire&n;&t; * kernel so that waiting for our DV threads to exit leads&n;&t; * to deadlock.&n;&t; */
id|ahc_list_lock
c_func
(paren
op_amp
id|l
)paren
suffix:semicolon
id|TAILQ_FOREACH
c_func
(paren
id|ahc
comma
op_amp
id|ahc_tailq
comma
id|links
)paren
(brace
id|ahc_linux_kill_dv_thread
c_func
(paren
id|ahc
)paren
suffix:semicolon
)brace
id|ahc_list_unlock
c_func
(paren
op_amp
id|l
)paren
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,5,0)
multiline_comment|/*&n;&t; * In 2.4 we have to unregister from the PCI core _after_&n;&t; * unregistering from the scsi midlayer to avoid dangling&n;&t; * references.&n;&t; */
id|scsi_unregister_module
c_func
(paren
id|MODULE_SCSI_HA
comma
op_amp
id|aic7xxx_driver_template
)paren
suffix:semicolon
macro_line|#endif
id|ahc_linux_pci_exit
c_func
(paren
)paren
suffix:semicolon
id|ahc_linux_eisa_exit
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|ahc_linux_init
id|module_init
c_func
(paren
id|ahc_linux_init
)paren
suffix:semicolon
DECL|variable|ahc_linux_exit
id|module_exit
c_func
(paren
id|ahc_linux_exit
)paren
suffix:semicolon
eof
