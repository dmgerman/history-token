multiline_comment|/*&n; * Adaptec AIC7xxx device driver for Linux.&n; *&n; * $Id: //depot/src/linux/drivers/scsi/aic7xxx/aic7xxx_linux.c#66 $&n; *&n; * Copyright (c) 1994 John Aycock&n; *   The University of Calgary Department of Computer Science.&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; see the file COPYING.  If not, write to&n; * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; * Sources include the Adaptec 1740 driver (aha1740.c), the Ultrastor 24F&n; * driver (ultrastor.c), various Linux kernel source, the Adaptec EISA&n; * config file (!adp7771.cfg), the Adaptec AHA-2740A Series User&squot;s Guide,&n; * the Linux Kernel Hacker&squot;s Guide, Writing a SCSI Device Driver for Linux,&n; * the Adaptec 1542 driver (aha1542.c), the Adaptec EISA overlay file&n; * (adp7770.ovl), the Adaptec AHA-2740 Series Technical Reference Manual,&n; * the Adaptec AIC-7770 Data Book, the ANSI SCSI specification, the&n; * ANSI SCSI-2 specification (draft 10c), ...&n; *&n; * --------------------------------------------------------------------------&n; *&n; *  Modifications by Daniel M. Eischen (deischen@iworks.InterWorks.org):&n; *&n; *  Substantially modified to include support for wide and twin bus&n; *  adapters, DMAing of SCBs, tagged queueing, IRQ sharing, bug fixes,&n; *  SCB paging, and other rework of the code.&n; *&n; * --------------------------------------------------------------------------&n; * Copyright (c) 1994, 1995, 1996, 1997, 1998, 1999, 2000 Justin T. Gibbs.&n; * Copyright (c) 2000 Adaptec Inc.&n; * All rights reserved.&n; *&n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions&n; * are met:&n; * 1. Redistributions of source code must retain the above copyright&n; *    notice, this list of conditions, and the following disclaimer,&n; *    without modification.&n; * 2. The name of the author may not be used to endorse or promote products&n; *    derived from this software without specific prior written permission.&n; *&n; * Alternatively, this software may be distributed under the terms of the&n; * GNU Public License (&quot;GPL&quot;).&n; *&n; * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS&squot;&squot; AND&n; * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE&n; * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE&n; * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR&n; * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL&n; * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS&n; * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)&n; * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT&n; * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY&n; * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF&n; * SUCH DAMAGE.&n; *&n; *---------------------------------------------------------------------------&n; *&n; *  Thanks also go to (in alphabetical order) the following:&n; *&n; *    Rory Bolt     - Sequencer bug fixes&n; *    Jay Estabrook - Initial DEC Alpha support&n; *    Doug Ledford  - Much needed abort/reset bug fixes&n; *    Kai Makisara  - DMAing of SCBs&n; *&n; *  A Boot time option was also added for not resetting the scsi bus.&n; *&n; *    Form:  aic7xxx=extended&n; *           aic7xxx=no_reset&n; *           aic7xxx=ultra&n; *           aic7xxx=irq_trigger:[0,1]  # 0 edge, 1 level&n; *           aic7xxx=verbose&n; *&n; *  Daniel M. Eischen, deischen@iworks.InterWorks.org, 1/23/97&n; *&n; *  Id: aic7xxx.c,v 4.1 1997/06/12 08:23:42 deang Exp&n; */
multiline_comment|/*&n; * Further driver modifications made by Doug Ledford &lt;dledford@redhat.com&gt;&n; *&n; * Copyright (c) 1997-1999 Doug Ledford&n; *&n; * These changes are released under the same licensing terms as the FreeBSD&n; * driver written by Justin Gibbs.  Please see his Copyright notice above&n; * for the exact terms and conditions covering my changes as well as the&n; * warranty statement.&n; *&n; * Modifications made to the aic7xxx.c,v 4.1 driver from Dan Eischen include&n; * but are not limited to:&n; *&n; *  1: Import of the latest FreeBSD sequencer code for this driver&n; *  2: Modification of kernel code to accomodate different sequencer semantics&n; *  3: Extensive changes throughout kernel portion of driver to improve&n; *     abort/reset processing and error hanndling&n; *  4: Other work contributed by various people on the Internet&n; *  5: Changes to printk information and verbosity selection code&n; *  6: General reliability related changes, especially in IRQ management&n; *  7: Modifications to the default probe/attach order for supported cards&n; *  8: SMP friendliness has been improved&n; *&n; */
multiline_comment|/*&n; * The next three defines are user configurable.  These should be the only&n; * defines a user might need to get in here and change.  There are other&n; * defines buried deeper in the code, but those really shouldn&squot;t need touched&n; * under normal conditions.&n; */
macro_line|#if defined(MODULE) || defined(PCMCIA)
macro_line|#include &lt;linux/module.h&gt;
macro_line|#endif
macro_line|#if defined(PCMCIA)
DECL|macro|MODULE
macro_line|#undef MODULE
macro_line|#endif
macro_line|#include &quot;aic7xxx_osm.h&quot;
macro_line|#include &quot;aic7xxx_inline.h&quot;
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,3,0)
macro_line|#include &lt;linux/init.h&gt;&t;&t;/* __setup */
macro_line|#endif
macro_line|#include &quot;../sd.h&quot;&t;&t;/* For geometry detection */
multiline_comment|/*&n; * To generate the correct addresses for the controller to issue&n; * on the bus.  Originally added for DEC Alpha support.&n; */
DECL|macro|VIRT_TO_BUS
mdefine_line|#define VIRT_TO_BUS(a) (uint32_t)virt_to_bus((void *)(a))
macro_line|#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,3,0)
DECL|variable|proc_scsi_aic7xxx
r_struct
id|proc_dir_entry
id|proc_scsi_aic7xxx
op_assign
(brace
id|PROC_SCSI_AIC7XXX
comma
l_int|7
comma
l_string|&quot;aic7xxx&quot;
comma
id|S_IFDIR
op_or
id|S_IRUGO
op_or
id|S_IXUGO
comma
l_int|2
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Set this to the delay in seconds after SCSI bus reset.&n; * Note, we honor this only for the initial bus reset.&n; * The scsi error recovery code performs its own bus settle&n; * delay handling for error recovery actions.&n; */
macro_line|#ifdef CONFIG_AIC7XXX_RESET_DELAY_MS
DECL|macro|AIC7XXX_RESET_DELAY
mdefine_line|#define AIC7XXX_RESET_DELAY CONFIG_AIC7XXX_RESET_DELAY_MS
macro_line|#else
DECL|macro|AIC7XXX_RESET_DELAY
mdefine_line|#define AIC7XXX_RESET_DELAY 5000
macro_line|#endif
multiline_comment|/*&n; * Control collection of SCSI transfer statistics for the /proc filesystem.&n; *&n; * NOTE: Do NOT enable this when running on kernels version 1.2.x and below.&n; * NOTE: This does affect performance since it has to maintain statistics.&n; */
macro_line|#ifdef CONFIG_AIC7XXX_PROC_STATS
DECL|macro|AIC7XXX_PROC_STATS
mdefine_line|#define AIC7XXX_PROC_STATS
macro_line|#endif
multiline_comment|/*&n; * To change the default number of tagged transactions allowed per-device,&n; * add a line to the lilo.conf file like:&n; * append=&quot;aic7xxx=verbose,tag_info:{{32,32,32,32},{32,32,32,32}}&quot;&n; * which will result in the first four devices on the first two&n; * controllers being set to a tagged queue depth of 32.&n; *&n; * The tag_commands is an array of 16 to allow for wide and twin adapters.&n; * Twin adapters will use indexes 0-7 for channel 0, and indexes 8-15&n; * for channel 1.&n; */
r_typedef
r_struct
(brace
DECL|member|tag_commands
r_uint8
id|tag_commands
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* Allow for wide/twin adapters. */
DECL|typedef|adapter_tag_info_t
)brace
id|adapter_tag_info_t
suffix:semicolon
multiline_comment|/*&n; * Modify this as you see fit for your system.&n; *&n; * 0&t;&t;&t;tagged queuing disabled&n; * 1 &lt;= n &lt;= 253&t;n == max tags ever dispatched.&n; *&n; * The driver will throttle the number of commands dispatched to a&n; * device if it returns queue full.  For devices with a fixed maximum&n; * queue depth, the driver will eventually determine this depth and&n; * lock it in (a console message is printed to indicate that a lock&n; * has occurred).  On some devices, queue full is returned for a temporary&n; * resource shortage.  These devices will return queue full at varying&n; * depths.  The driver will throttle back when the queue fulls occur and&n; * attempt to slowly increase the depth over time as the device recovers&n; * from the resource shortage.&n; *&n; * In this example, the first line will disable tagged queueing for all&n; * the devices on the first probed aic7xxx adapter.&n; *&n; * The second line enables tagged queueing with 4 commands/LUN for IDs&n; * (0, 2-11, 13-15), disables tagged queueing for ID 12, and tells the&n; * driver to attempt to use up to 64 tags for ID 1.&n; *&n; * The third line is the same as the first line.&n; *&n; * The fourth line disables tagged queueing for devices 0 and 3.  It&n; * enables tagged queueing for the other IDs, with 16 commands/LUN&n; * for IDs 1 and 4, 127 commands/LUN for ID 8, and 4 commands/LUN for&n; * IDs 2, 5-7, and 9-15.&n; */
multiline_comment|/*&n; * NOTE: The below structure is for reference only, the actual structure&n; *       to modify in order to change things is just below this comment block.&n;adapter_tag_info_t aic7xxx_tag_info[] =&n;{&n;&t;{{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},&n;&t;{{4, 64, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 4, 4, 4}},&n;&t;{{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},&n;&t;{{0, 16, 4, 0, 16, 4, 4, 4, 127, 4, 4, 4, 4, 4, 4, 4}}&n;};&n;*/
macro_line|#ifdef CONFIG_AIC7XXX_CMDS_PER_DEVICE
DECL|macro|AIC7XXX_CMDS_PER_DEVICE
mdefine_line|#define AIC7XXX_CMDS_PER_DEVICE CONFIG_AIC7XXX_CMDS_PER_DEVICE
macro_line|#else
DECL|macro|AIC7XXX_CMDS_PER_DEVICE
mdefine_line|#define AIC7XXX_CMDS_PER_DEVICE AHC_MAX_QUEUE
macro_line|#endif
DECL|macro|AIC7XXX_CONFIGED_TAG_COMMANDS
mdefine_line|#define AIC7XXX_CONFIGED_TAG_COMMANDS {&t;&t;&t;&t;&t;&bslash;&n;&t;AIC7XXX_CMDS_PER_DEVICE, AIC7XXX_CMDS_PER_DEVICE,&t;&t;&bslash;&n;&t;AIC7XXX_CMDS_PER_DEVICE, AIC7XXX_CMDS_PER_DEVICE,&t;&t;&bslash;&n;&t;AIC7XXX_CMDS_PER_DEVICE, AIC7XXX_CMDS_PER_DEVICE,&t;&t;&bslash;&n;&t;AIC7XXX_CMDS_PER_DEVICE, AIC7XXX_CMDS_PER_DEVICE,&t;&t;&bslash;&n;&t;AIC7XXX_CMDS_PER_DEVICE, AIC7XXX_CMDS_PER_DEVICE,&t;&t;&bslash;&n;&t;AIC7XXX_CMDS_PER_DEVICE, AIC7XXX_CMDS_PER_DEVICE,&t;&t;&bslash;&n;&t;AIC7XXX_CMDS_PER_DEVICE, AIC7XXX_CMDS_PER_DEVICE,&t;&t;&bslash;&n;&t;AIC7XXX_CMDS_PER_DEVICE, AIC7XXX_CMDS_PER_DEVICE&t;&t;&bslash;&n;}
multiline_comment|/*&n; * By default, use the number of commands specified by&n; * the users kernel configuration.&n; */
DECL|variable|aic7xxx_tag_info
r_static
id|adapter_tag_info_t
id|aic7xxx_tag_info
(braket
)braket
op_assign
(brace
(brace
id|AIC7XXX_CONFIGED_TAG_COMMANDS
)brace
comma
(brace
id|AIC7XXX_CONFIGED_TAG_COMMANDS
)brace
comma
(brace
id|AIC7XXX_CONFIGED_TAG_COMMANDS
)brace
comma
(brace
id|AIC7XXX_CONFIGED_TAG_COMMANDS
)brace
comma
(brace
id|AIC7XXX_CONFIGED_TAG_COMMANDS
)brace
comma
(brace
id|AIC7XXX_CONFIGED_TAG_COMMANDS
)brace
comma
(brace
id|AIC7XXX_CONFIGED_TAG_COMMANDS
)brace
comma
(brace
id|AIC7XXX_CONFIGED_TAG_COMMANDS
)brace
comma
(brace
id|AIC7XXX_CONFIGED_TAG_COMMANDS
)brace
comma
(brace
id|AIC7XXX_CONFIGED_TAG_COMMANDS
)brace
comma
(brace
id|AIC7XXX_CONFIGED_TAG_COMMANDS
)brace
comma
(brace
id|AIC7XXX_CONFIGED_TAG_COMMANDS
)brace
comma
(brace
id|AIC7XXX_CONFIGED_TAG_COMMANDS
)brace
comma
(brace
id|AIC7XXX_CONFIGED_TAG_COMMANDS
)brace
comma
(brace
id|AIC7XXX_CONFIGED_TAG_COMMANDS
)brace
comma
(brace
id|AIC7XXX_CONFIGED_TAG_COMMANDS
)brace
)brace
suffix:semicolon
multiline_comment|/*&n; * There should be a specific return value for this in scsi.h, but&n; * it seems that most drivers ignore it.&n; */
DECL|macro|DID_UNDERFLOW
mdefine_line|#define DID_UNDERFLOW   DID_ERROR
r_void
DECL|function|ahc_print_path
id|ahc_print_path
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|scb
op_star
id|scb
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;(scsi%d:%c:%d:%d): &quot;
comma
id|ahc-&gt;platform_data-&gt;host-&gt;host_no
comma
id|scb
op_ne
l_int|NULL
ques
c_cond
id|SCB_GET_CHANNEL
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:colon
l_char|&squot;X&squot;
comma
id|scb
op_ne
l_int|NULL
ques
c_cond
id|SCB_GET_TARGET
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:colon
op_minus
l_int|1
comma
id|scb
op_ne
l_int|NULL
ques
c_cond
id|SCB_GET_LUN
c_func
(paren
id|scb
)paren
suffix:colon
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * XXX - these options apply unilaterally to _all_ 274x/284x/294x&n; *       cards in the system.  This should be fixed.  Exceptions to this&n; *       rule are noted in the comments.&n; */
multiline_comment|/*&n; * Skip the scsi bus reset.  Non 0 make us skip the reset at startup.  This&n; * has no effect on any later resets that might occur due to things like&n; * SCSI bus timeouts.&n; */
DECL|variable|aic7xxx_no_reset
r_static
r_uint32
id|aic7xxx_no_reset
suffix:semicolon
multiline_comment|/*&n; * Certain PCI motherboards will scan PCI devices from highest to lowest,&n; * others scan from lowest to highest, and they tend to do all kinds of&n; * strange things when they come into contact with PCI bridge chips.  The&n; * net result of all this is that the PCI card that is actually used to boot&n; * the machine is very hard to detect.  Most motherboards go from lowest&n; * PCI slot number to highest, and the first SCSI controller found is the&n; * one you boot from.  The only exceptions to this are when a controller&n; * has its BIOS disabled.  So, we by default sort all of our SCSI controllers&n; * from lowest PCI slot number to highest PCI slot number.  We also force&n; * all controllers with their BIOS disabled to the end of the list.  This&n; * works on *almost* all computers.  Where it doesn&squot;t work, we have this&n; * option.  Setting this option to non-0 will reverse the order of the sort&n; * to highest first, then lowest, but will still leave cards with their BIOS&n; * disabled at the very end.  That should fix everyone up unless there are&n; * really strange cirumstances.&n; */
DECL|variable|aic7xxx_reverse_scan
r_static
r_int
id|aic7xxx_reverse_scan
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Should we force EXTENDED translation on a controller.&n; *     0 == Use whatever is in the SEEPROM or default to off&n; *     1 == Use whatever is in the SEEPROM or default to on&n; */
DECL|variable|aic7xxx_extended
r_static
r_uint32
id|aic7xxx_extended
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * The IRQ trigger method used on EISA controllers. Does not effect PCI cards.&n; *   -1 = Use detected settings.&n; *    0 = Force Edge triggered mode.&n; *    1 = Force Level triggered mode.&n; */
DECL|variable|aic7xxx_irq_trigger
r_static
r_int
id|aic7xxx_irq_trigger
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n; * This variable is used to override the termination settings on a controller.&n; * This should not be used under normal conditions.  However, in the case&n; * that a controller does not have a readable SEEPROM (so that we can&squot;t&n; * read the SEEPROM settings directly) and that a controller has a buggered&n; * version of the cable detection logic, this can be used to force the&n; * correct termination.  It is preferable to use the manual termination&n; * settings in the BIOS if possible, but some motherboard controllers store&n; * those settings in a format we can&squot;t read.  In other cases, auto term&n; * should also work, but the chipset was put together with no auto term&n; * logic (common on motherboard controllers).  In those cases, we have&n; * 32 bits here to work with.  That&squot;s good for 8 controllers/channels.  The&n; * bits are organized as 4 bits per channel, with scsi0 getting the lowest&n; * 4 bits in the int.  A 1 in a bit position indicates the termination setting&n; * that corresponds to that bit should be enabled, a 0 is disabled.&n; * It looks something like this:&n; *&n; *    0x0f =  1111-Single Ended Low Byte Termination on/off&n; *            ||&bslash;-Single Ended High Byte Termination on/off&n; *            |&bslash;-LVD Low Byte Termination on/off&n; *            &bslash;-LVD High Byte Termination on/off&n; *&n; * For non-Ultra2 controllers, the upper 2 bits are not important.  So, to&n; * enable both high byte and low byte termination on scsi0, I would need to&n; * make sure that the override_term variable was set to 0x03 (bits 0011).&n; * To make sure that all termination is enabled on an Ultra2 controller at&n; * scsi2 and only high byte termination on scsi1 and high and low byte&n; * termination on scsi0, I would set override_term=0xf23 (bits 1111 0010 0011)&n; *&n; * For the most part, users should never have to use this, that&squot;s why I&n; * left it fairly cryptic instead of easy to understand.  If you need it,&n; * most likely someone will be telling you what your&squot;s needs to be set to.&n; */
DECL|variable|aic7xxx_override_term
r_static
r_int
id|aic7xxx_override_term
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n; * Certain motherboard chipset controllers tend to screw&n; * up the polarity of the term enable output pin.  Use this variable&n; * to force the correct polarity for your system.  This is a bitfield variable&n; * similar to the previous one, but this one has one bit per channel instead&n; * of four.&n; *    0 = Force the setting to active low.&n; *    1 = Force setting to active high.&n; * Most Adaptec cards are active high, several motherboards are active low.&n; * To force a 2940 card at SCSI 0 to active high and a motherboard 7895&n; * controller at scsi1 and scsi2 to active low, and a 2910 card at scsi3&n; * to active high, you would need to set stpwlev=0x9 (bits 1001).&n; *&n; * People shouldn&squot;t need to use this, but if you are experiencing lots of&n; * SCSI timeout problems, this may help.  There is one sure way to test what&n; * this option needs to be.  Using a boot floppy to boot the system, configure&n; * your system to enable all SCSI termination (in the Adaptec SCSI BIOS) and&n; * if needed then also pass a value to override_term to make sure that the&n; * driver is enabling SCSI termination, then set this variable to either 0&n; * or 1.  When the driver boots, make sure there are *NO* SCSI cables&n; * connected to your controller.  If it finds and inits the controller&n; * without problem, then the setting you passed to stpwlev was correct.  If&n; * the driver goes into a reset loop and hangs the system, then you need the&n; * other setting for this variable.  If neither setting lets the machine&n; * boot then you have definite termination problems that may not be fixable.&n; */
DECL|variable|aic7xxx_stpwlev
r_static
r_int
id|aic7xxx_stpwlev
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n; * Set this to non-0 in order to force the driver to panic the kernel&n; * and print out debugging info on a SCSI abort or reset cycle.&n; */
DECL|variable|aic7xxx_panic_on_abort
r_static
r_int
id|aic7xxx_panic_on_abort
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * PCI bus parity checking of the Adaptec controllers.  This is somewhat&n; * dubious at best.  To my knowledge, this option has never actually&n; * solved a PCI parity problem, but on certain machines with broken PCI&n; * chipset configurations, it can generate tons of false error messages.&n; * It&squot;s included in the driver for completeness.&n; *   0 = Shut off PCI parity check&n; *  -1 = Normal polarity pci parity checking&n; *   1 = reverse polarity pci parity checking&n; *&n; * NOTE: you can&squot;t actually pass -1 on the lilo prompt.  So, to set this&n; * variable to -1 you would actually want to simply pass the variable&n; * name without a number.  That will invert the 0 which will result in&n; * -1.&n; */
DECL|variable|aic7xxx_pci_parity
r_static
r_int
id|aic7xxx_pci_parity
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Set this to a non-0 value to make us dump out the 32 bit instruction&n; * registers on the card after completing the sequencer download.  This&n; * allows the actual sequencer download to be verified.  It is possible&n; * to use this option and still boot up and run your system.  This is&n; * only intended for debugging purposes.&n; */
DECL|variable|aic7xxx_dump_sequencer
r_static
r_int
id|aic7xxx_dump_sequencer
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Certain newer motherboards have put new PCI based devices into the&n; * IO spaces that used to typically be occupied by VLB or EISA cards.&n; * This overlap can cause these newer motherboards to lock up when scanned&n; * for older EISA and VLB devices.  Setting this option to non-0 will&n; * cause the driver to skip scanning for any VLB or EISA controllers and&n; * only support the PCI controllers.  NOTE: this means that if the kernel&n; * os compiled with PCI support disabled, then setting this to non-0&n; * would result in never finding any devices :)&n; */
DECL|variable|aic7xxx_no_probe
r_int
id|aic7xxx_no_probe
suffix:semicolon
multiline_comment|/*&n; * aic7xxx_detect() has been run, so register all device arrivals&n; * immediately with the system rather than deferring to the sorted&n; * attachment performed by aic7xxx_detect().&n; */
DECL|variable|aic7xxx_detect_complete
r_int
id|aic7xxx_detect_complete
suffix:semicolon
multiline_comment|/*&n; * So that we can set how long each device is given as a selection timeout.&n; * The table of values goes like this:&n; *   0 - 256ms&n; *   1 - 128ms&n; *   2 - 64ms&n; *   3 - 32ms&n; * We default to 256ms because some older devices need a longer time&n; * to respond to initial selection.&n; */
DECL|variable|aic7xxx_seltime
r_static
r_int
id|aic7xxx_seltime
op_assign
l_int|0x00
suffix:semicolon
multiline_comment|/*&n; * So that insmod can find the variable and make it point to something&n; */
macro_line|#ifdef MODULE
DECL|variable|aic7xxx
r_static
r_char
op_star
id|aic7xxx
op_assign
l_int|NULL
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|aic7xxx
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * Just in case someone uses commas to separate items on the insmod&n; * command line, we define a dummy buffer here to avoid having insmod&n; * write wild stuff into our code segment&n; */
DECL|variable|dummy_buffer
r_static
r_char
id|dummy_buffer
(braket
l_int|60
)braket
op_assign
l_string|&quot;Please don&squot;t trounce on me insmod!!&bslash;n&quot;
suffix:semicolon
macro_line|#endif
r_static
r_void
id|ahc_linux_handle_scsi_status
c_func
(paren
r_struct
id|ahc_softc
op_star
comma
r_struct
id|ahc_linux_device
op_star
comma
r_struct
id|scb
op_star
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_filter_command
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_sem_timeout
c_func
(paren
id|u_long
id|arg
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_freeze_sim_queue
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_release_sim_queue
c_func
(paren
id|u_long
id|arg
)paren
suffix:semicolon
r_static
r_int
id|ahc_linux_queue_recovery_cmd
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
id|scb_flag
id|flag
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_initialize_scsi_bus
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_select_queue_depth
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
id|Scsi_Device
op_star
id|scsi_devs
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_device_queue_depth
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|Scsi_Device
op_star
id|device
)paren
suffix:semicolon
r_static
r_struct
id|ahc_linux_target
op_star
id|ahc_linux_alloc_target
c_func
(paren
r_struct
id|ahc_softc
op_star
comma
id|u_int
comma
id|u_int
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_free_target
c_func
(paren
r_struct
id|ahc_softc
op_star
comma
r_struct
id|ahc_linux_target
op_star
)paren
suffix:semicolon
r_static
r_struct
id|ahc_linux_device
op_star
id|ahc_linux_alloc_device
c_func
(paren
r_struct
id|ahc_softc
op_star
comma
r_struct
id|ahc_linux_target
op_star
comma
id|u_int
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_free_device
c_func
(paren
r_struct
id|ahc_softc
op_star
comma
r_struct
id|ahc_linux_device
op_star
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_run_device_queue
c_func
(paren
r_struct
id|ahc_softc
op_star
comma
r_struct
id|ahc_linux_device
op_star
)paren
suffix:semicolon
r_static
r_void
id|ahc_linux_setup_tag_info
c_func
(paren
r_char
op_star
id|p
comma
r_char
op_star
id|end
)paren
suffix:semicolon
r_static
r_int
id|ahc_linux_next_unit
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|ahc_linux_halt
c_func
(paren
r_struct
id|notifier_block
op_star
id|nb
comma
id|u_long
id|event
comma
r_void
op_star
id|buf
)paren
suffix:semicolon
r_static
id|__inline
r_struct
id|ahc_linux_device
op_star
id|ahc_linux_get_device
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|u_int
id|channel
comma
id|u_int
id|target
comma
id|u_int
id|lun
comma
r_int
id|alloc
)paren
suffix:semicolon
r_static
id|__inline
r_void
id|ahc_linux_queue_cmd_complete
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
suffix:semicolon
r_static
id|__inline
r_void
id|ahc_linux_run_complete_queue
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_cmd
op_star
id|acmd
)paren
suffix:semicolon
r_static
id|__inline
r_void
id|ahc_linux_check_device_queue
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_linux_device
op_star
id|dev
)paren
suffix:semicolon
r_static
id|__inline
r_void
id|ahc_linux_sniff_command
c_func
(paren
r_struct
id|ahc_softc
op_star
comma
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
r_static
id|__inline
r_void
id|ahc_linux_unmap_scb
c_func
(paren
r_struct
id|ahc_softc
op_star
comma
r_struct
id|scb
op_star
)paren
suffix:semicolon
r_static
id|__inline
r_struct
id|ahc_linux_device
op_star
DECL|function|ahc_linux_get_device
id|ahc_linux_get_device
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|u_int
id|channel
comma
id|u_int
id|target
comma
id|u_int
id|lun
comma
r_int
id|alloc
)paren
(brace
r_struct
id|ahc_linux_target
op_star
id|targ
suffix:semicolon
r_struct
id|ahc_linux_device
op_star
id|dev
suffix:semicolon
id|u_int
id|target_offset
suffix:semicolon
id|target_offset
op_assign
id|target
suffix:semicolon
r_if
c_cond
(paren
id|channel
op_ne
l_int|0
)paren
id|target_offset
op_add_assign
l_int|8
suffix:semicolon
id|targ
op_assign
id|ahc-&gt;platform_data-&gt;targets
(braket
id|target_offset
)braket
suffix:semicolon
r_if
c_cond
(paren
id|targ
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|alloc
op_ne
l_int|0
)paren
(brace
id|targ
op_assign
id|ahc_linux_alloc_target
c_func
(paren
id|ahc
comma
id|channel
comma
id|target
)paren
suffix:semicolon
r_if
c_cond
(paren
id|targ
op_eq
l_int|NULL
)paren
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
id|dev
op_assign
id|targ-&gt;devices
(braket
id|lun
)braket
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
op_logical_and
id|alloc
op_ne
l_int|0
)paren
id|dev
op_assign
id|ahc_linux_alloc_device
c_func
(paren
id|ahc
comma
id|targ
comma
id|lun
)paren
suffix:semicolon
r_return
(paren
id|dev
)paren
suffix:semicolon
)brace
r_static
id|__inline
r_void
DECL|function|ahc_linux_queue_cmd_complete
id|ahc_linux_queue_cmd_complete
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
multiline_comment|/*&n;&t; * Typically, the complete queue has very few entries&n;&t; * queued to it before the queue is emptied by&n;&t; * ahc_linux_run_complete_queue, so sorting the entries&n;&t; * by generation number should be inexpensive.&n;&t; * We perform the sort so that commands that complete&n;&t; * with an error are retuned in the order origionally&n;&t; * queued to the controller so that any subsequent retries&n;&t; * are performed in order.  The underlying ahc routines do&n;&t; * not guarantee the order that aborted commands will be&n;&t; * returned to us.&n;&t; */
r_struct
id|ahc_completeq
op_star
id|completeq
suffix:semicolon
r_struct
id|ahc_cmd
op_star
id|list_cmd
suffix:semicolon
r_struct
id|ahc_cmd
op_star
id|acmd
suffix:semicolon
multiline_comment|/*&n;&t; * If we want the request requeued, make sure there&n;&t; * are sufficent retries.  In the old scsi error code,&n;&t; * we used to be able to specify a result code that&n;&t; * bypassed the retry count.  Now we must use this&n;&t; * hack.&n;&t; */
r_if
c_cond
(paren
id|cmd-&gt;result
op_eq
(paren
id|CAM_REQUEUE_REQ
op_lshift
l_int|16
)paren
)paren
id|cmd-&gt;retries
op_decrement
suffix:semicolon
id|completeq
op_assign
op_amp
id|ahc-&gt;platform_data-&gt;completeq
suffix:semicolon
id|list_cmd
op_assign
id|TAILQ_FIRST
c_func
(paren
id|completeq
)paren
suffix:semicolon
id|acmd
op_assign
(paren
r_struct
id|ahc_cmd
op_star
)paren
id|cmd
suffix:semicolon
r_while
c_loop
(paren
id|list_cmd
op_ne
l_int|NULL
op_logical_and
id|acmd_scsi_cmd
c_func
(paren
id|list_cmd
)paren
dot
id|serial_number
OL
id|acmd_scsi_cmd
c_func
(paren
id|acmd
)paren
dot
id|serial_number
)paren
id|list_cmd
op_assign
id|TAILQ_NEXT
c_func
(paren
id|list_cmd
comma
id|acmd_links.tqe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_cmd
op_ne
l_int|NULL
)paren
id|TAILQ_INSERT_BEFORE
c_func
(paren
id|list_cmd
comma
id|acmd
comma
id|acmd_links.tqe
)paren
suffix:semicolon
r_else
id|TAILQ_INSERT_TAIL
c_func
(paren
id|completeq
comma
id|acmd
comma
id|acmd_links.tqe
)paren
suffix:semicolon
)brace
r_static
id|__inline
r_void
DECL|function|ahc_linux_run_complete_queue
id|ahc_linux_run_complete_queue
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_cmd
op_star
id|acmd
)paren
(brace
id|u_long
id|done_flags
suffix:semicolon
id|ahc_done_lock
c_func
(paren
id|ahc
comma
op_amp
id|done_flags
)paren
suffix:semicolon
r_while
c_loop
(paren
id|acmd
op_ne
l_int|NULL
)paren
(brace
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
id|cmd
op_assign
op_amp
id|acmd_scsi_cmd
c_func
(paren
id|acmd
)paren
suffix:semicolon
id|acmd
op_assign
id|TAILQ_NEXT
c_func
(paren
id|acmd
comma
id|acmd_links.tqe
)paren
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
id|ahc_done_unlock
c_func
(paren
id|ahc
comma
op_amp
id|done_flags
)paren
suffix:semicolon
)brace
r_static
id|__inline
r_void
DECL|function|ahc_linux_check_device_queue
id|ahc_linux_check_device_queue
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_linux_device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|AHC_DEV_FREEZE_TIL_EMPTY
)paren
op_ne
l_int|0
op_logical_and
id|dev-&gt;active
op_eq
l_int|0
)paren
(brace
id|dev-&gt;flags
op_and_assign
op_complement
id|AHC_DEV_FREEZE_TIL_EMPTY
suffix:semicolon
id|dev-&gt;qfrozen
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TAILQ_FIRST
c_func
(paren
op_amp
id|dev-&gt;busyq
)paren
op_eq
l_int|NULL
op_logical_or
id|dev-&gt;openings
op_eq
l_int|0
op_logical_or
id|dev-&gt;qfrozen
op_ne
l_int|0
)paren
r_return
suffix:semicolon
id|ahc_linux_run_device_queue
c_func
(paren
id|ahc
comma
id|dev
)paren
suffix:semicolon
)brace
r_static
id|__inline
r_void
DECL|function|ahc_linux_run_device_queues
id|ahc_linux_run_device_queues
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_struct
id|ahc_linux_device
op_star
id|dev
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ahc-&gt;flags
op_amp
id|AHC_RESOURCE_SHORTAGE
)paren
op_eq
l_int|0
op_logical_and
id|ahc-&gt;platform_data-&gt;qfrozen
op_eq
l_int|0
op_logical_and
(paren
id|dev
op_assign
id|LIST_FIRST
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;device_runq
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|LIST_REMOVE
c_func
(paren
id|dev
comma
id|links
)paren
suffix:semicolon
id|dev-&gt;flags
op_and_assign
op_complement
id|AHC_DEV_ON_RUN_LIST
suffix:semicolon
id|ahc_linux_check_device_queue
c_func
(paren
id|ahc
comma
id|dev
)paren
suffix:semicolon
)brace
)brace
r_static
id|__inline
r_void
DECL|function|ahc_linux_sniff_command
id|ahc_linux_sniff_command
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
multiline_comment|/*&n;&t; * Determine whether we care to filter&n;&t; * information out of this command.  If so,&n;&t; * pass it on to ahc_linux_filter_command() for more&n;&t; * heavy weight processing.&n;&t; */
r_if
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
id|ahc_linux_filter_command
c_func
(paren
id|ahc
comma
id|cmd
)paren
suffix:semicolon
)brace
r_static
id|__inline
r_void
DECL|function|ahc_linux_unmap_scb
id|ahc_linux_unmap_scb
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|scb
op_star
id|scb
)paren
(brace
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
id|cmd
op_assign
id|scb-&gt;io_ctx
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;use_sg
op_ne
l_int|0
)paren
(brace
r_struct
id|scatterlist
op_star
id|sg
suffix:semicolon
id|sg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;request_buffer
suffix:semicolon
id|pci_unmap_sg
c_func
(paren
id|ahc-&gt;dev_softc
comma
id|sg
comma
id|cmd-&gt;use_sg
comma
id|scsi_to_pci_dma_dir
c_func
(paren
id|cmd-&gt;sc_data_direction
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmd-&gt;request_bufflen
op_ne
l_int|0
)paren
id|pci_unmap_single
c_func
(paren
id|ahc-&gt;dev_softc
comma
id|ahc_le32toh
c_func
(paren
id|scb-&gt;sg_list
(braket
l_int|0
)braket
dot
id|addr
)paren
comma
id|cmd-&gt;request_bufflen
comma
id|scsi_to_pci_dma_dir
c_func
(paren
id|cmd-&gt;sc_data_direction
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/************************ Shutdown/halt/reboot hook ***************************/
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;linux/reboot.h&gt;
DECL|variable|ahc_linux_notifier
r_static
r_struct
id|notifier_block
id|ahc_linux_notifier
op_assign
(brace
id|ahc_linux_halt
comma
l_int|NULL
comma
l_int|0
)brace
suffix:semicolon
DECL|function|ahc_linux_halt
r_static
r_int
id|ahc_linux_halt
c_func
(paren
r_struct
id|notifier_block
op_star
id|nb
comma
id|u_long
id|event
comma
r_void
op_star
id|buf
)paren
(brace
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
id|TAILQ_FOREACH
c_func
(paren
id|ahc
comma
op_amp
id|ahc_tailq
comma
id|links
)paren
(brace
id|ahc_shutdown
c_func
(paren
id|ahc
)paren
suffix:semicolon
)brace
r_return
(paren
id|NOTIFY_OK
)paren
suffix:semicolon
)brace
multiline_comment|/******************************** Macros **************************************/
DECL|macro|BUILD_SCSIID
mdefine_line|#define BUILD_SCSIID(ahc, cmd)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;((((cmd)-&gt;target &lt;&lt; TID_SHIFT) &amp; TID)&t;&t;&t;&t;&bslash;&n;&t;| (((cmd)-&gt;channel == 0) ? (ahc)-&gt;our_id : (ahc)-&gt;our_id_b)&t;&bslash;&n;&t;| (((cmd)-&gt;channel == 0) ? 0 : TWIN_CHNLB))
multiline_comment|/******************************** Bus DMA *************************************/
r_int
DECL|function|ahc_dma_tag_create
id|ahc_dma_tag_create
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|bus_dma_tag_t
id|parent
comma
id|bus_size_t
id|alignment
comma
id|bus_size_t
id|boundary
comma
id|bus_addr_t
id|lowaddr
comma
id|bus_addr_t
id|highaddr
comma
id|bus_dma_filter_t
op_star
id|filter
comma
r_void
op_star
id|filterarg
comma
id|bus_size_t
id|maxsize
comma
r_int
id|nsegments
comma
id|bus_size_t
id|maxsegsz
comma
r_int
id|flags
comma
id|bus_dma_tag_t
op_star
id|ret_tag
)paren
(brace
id|bus_dma_tag_t
id|dmat
suffix:semicolon
id|dmat
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|dmat
)paren
comma
id|M_DEVBUF
comma
id|M_NOWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmat
op_eq
l_int|NULL
)paren
r_return
(paren
id|ENOMEM
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Linux is very simplistic about DMA memory.  For now don&squot;t&n;&t; * maintain all specification information.  Once Linux supplies&n;&t; * better facilities for doing these operations, or the&n;&t; * needs of this particular driver change, we might need to do&n;&t; * more here.&n;&t; */
id|dmat-&gt;alignment
op_assign
id|alignment
suffix:semicolon
id|dmat-&gt;boundary
op_assign
id|boundary
suffix:semicolon
id|dmat-&gt;maxsize
op_assign
id|maxsize
suffix:semicolon
op_star
id|ret_tag
op_assign
id|dmat
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahc_dma_tag_destroy
id|ahc_dma_tag_destroy
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|bus_dma_tag_t
id|dmat
)paren
(brace
id|free
c_func
(paren
id|dmat
comma
id|M_DEVBUF
)paren
suffix:semicolon
)brace
r_int
DECL|function|ahc_dmamem_alloc
id|ahc_dmamem_alloc
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|bus_dma_tag_t
id|dmat
comma
r_void
op_star
op_star
id|vaddr
comma
r_int
id|flags
comma
id|bus_dmamap_t
op_star
id|mapp
)paren
(brace
id|bus_dmamap_t
id|map
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,3,0)
id|map
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|map
)paren
comma
id|M_DEVBUF
comma
id|M_NOWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|map
op_eq
l_int|NULL
)paren
r_return
(paren
id|ENOMEM
)paren
suffix:semicolon
op_star
id|vaddr
op_assign
id|pci_alloc_consistent
c_func
(paren
id|ahc-&gt;dev_softc
comma
id|dmat-&gt;maxsize
comma
op_amp
id|map-&gt;bus_addr
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/*&n;&t; * At least in 2.2.14, malloc is a slab allocator so all&n;&t; * allocations are aligned.  We assume, for these kernel versions&n;&t; * that all allocations will be bellow 4Gig, physically contiguous,&n;&t; * and accessable via DMA by the controller.&n;&t; */
id|map
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* No additional information to store */
op_star
id|vaddr
op_assign
id|malloc
c_func
(paren
id|dmat-&gt;maxsize
comma
id|M_DEVBUF
comma
id|M_NOWAIT
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_star
id|vaddr
op_eq
l_int|NULL
)paren
r_return
(paren
id|ENOMEM
)paren
suffix:semicolon
op_star
id|mapp
op_assign
id|map
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|ahc_dmamem_free
id|ahc_dmamem_free
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|bus_dma_tag_t
id|dmat
comma
r_void
op_star
id|vaddr
comma
id|bus_dmamap_t
id|map
)paren
(brace
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,3,0)
id|pci_free_consistent
c_func
(paren
id|ahc-&gt;dev_softc
comma
id|dmat-&gt;maxsize
comma
id|vaddr
comma
id|map-&gt;bus_addr
)paren
suffix:semicolon
macro_line|#else
id|free
c_func
(paren
id|vaddr
comma
id|M_DEVBUF
)paren
suffix:semicolon
macro_line|#endif
)brace
r_int
DECL|function|ahc_dmamap_load
id|ahc_dmamap_load
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|bus_dma_tag_t
id|dmat
comma
id|bus_dmamap_t
id|map
comma
r_void
op_star
id|buf
comma
id|bus_size_t
id|buflen
comma
id|bus_dmamap_callback_t
op_star
id|cb
comma
r_void
op_star
id|cb_arg
comma
r_int
id|flags
)paren
(brace
multiline_comment|/*&n;&t; * Assume for now that this will only be used during&n;&t; * initialization and not for per-transaction buffer mapping.&n;&t; */
id|bus_dma_segment_t
id|stack_sg
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,3,0)
id|stack_sg.ds_addr
op_assign
id|map-&gt;bus_addr
suffix:semicolon
macro_line|#else
id|stack_sg.ds_addr
op_assign
id|VIRT_TO_BUS
c_func
(paren
id|buf
)paren
suffix:semicolon
macro_line|#endif
id|stack_sg.ds_len
op_assign
id|dmat-&gt;maxsize
suffix:semicolon
id|cb
c_func
(paren
id|cb_arg
comma
op_amp
id|stack_sg
comma
multiline_comment|/*nseg*/
l_int|1
comma
multiline_comment|/*error*/
l_int|0
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahc_dmamap_destroy
id|ahc_dmamap_destroy
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|bus_dma_tag_t
id|dmat
comma
id|bus_dmamap_t
id|map
)paren
(brace
multiline_comment|/*&n;&t; * The map may is NULL in our &lt; 2.3.X implementation.&n;&t; */
r_if
c_cond
(paren
id|map
op_ne
l_int|NULL
)paren
id|free
c_func
(paren
id|map
comma
id|M_DEVBUF
)paren
suffix:semicolon
)brace
r_int
DECL|function|ahc_dmamap_unload
id|ahc_dmamap_unload
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|bus_dma_tag_t
id|dmat
comma
id|bus_dmamap_t
id|map
)paren
(brace
multiline_comment|/* Nothing to do */
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/********************* Platform Dependent Functions ***************************/
r_int
DECL|function|ahc_softc_comp
id|ahc_softc_comp
c_func
(paren
r_struct
id|ahc_softc
op_star
id|lahc
comma
r_struct
id|ahc_softc
op_star
id|rahc
)paren
(brace
r_int
id|value
suffix:semicolon
r_int
id|rvalue
suffix:semicolon
r_int
id|lvalue
suffix:semicolon
multiline_comment|/*&n;&t; * Under Linux, cards are ordered as follows:&n;&t; *&t;1) VLB/EISA BIOS enabled devices sorted by BIOS address.&n;&t; *&t;2) PCI devices with BIOS enabled sorted by bus/slot/func.&n;&t; *&t;3) All remaining VLB/EISA devices sorted by ioport.&n;&t; *&t;4) All remaining PCI devices sorted by bus/slot/func.&n;&t; */
id|value
op_assign
(paren
id|lahc-&gt;flags
op_amp
id|AHC_BIOS_ENABLED
)paren
op_minus
(paren
id|rahc-&gt;flags
op_amp
id|AHC_BIOS_ENABLED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_ne
l_int|0
)paren
multiline_comment|/* Controllers with BIOS enabled have a *higher* priority */
r_return
(paren
op_minus
id|value
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Same BIOS setting, now sort based on bus type.&n;&t; * EISA and VL controllers sort together.  EISA/VL&n;&t; * have higher priority than PCI.&n;&t; */
id|rvalue
op_assign
(paren
id|rahc-&gt;chip
op_amp
id|AHC_BUS_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rvalue
op_eq
id|AHC_VL
)paren
id|rvalue
op_assign
id|AHC_EISA
suffix:semicolon
id|lvalue
op_assign
(paren
id|lahc-&gt;chip
op_amp
id|AHC_BUS_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lvalue
op_eq
id|AHC_VL
)paren
id|lvalue
op_assign
id|AHC_EISA
suffix:semicolon
id|value
op_assign
id|lvalue
op_minus
id|rvalue
suffix:semicolon
r_if
c_cond
(paren
id|value
op_ne
l_int|0
)paren
r_return
(paren
id|value
)paren
suffix:semicolon
multiline_comment|/* Still equal.  Sort by BIOS address, ioport, or bus/slot/func. */
r_switch
c_cond
(paren
id|rvalue
)paren
(brace
r_case
id|AHC_PCI
suffix:colon
(brace
r_char
id|primary_channel
suffix:semicolon
id|value
op_assign
id|ahc_get_pci_bus
c_func
(paren
id|lahc-&gt;dev_softc
)paren
op_minus
id|ahc_get_pci_bus
c_func
(paren
id|rahc-&gt;dev_softc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_ne
l_int|0
)paren
r_break
suffix:semicolon
id|value
op_assign
id|ahc_get_pci_slot
c_func
(paren
id|lahc-&gt;dev_softc
)paren
op_minus
id|ahc_get_pci_slot
c_func
(paren
id|rahc-&gt;dev_softc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_ne
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * On multi-function devices, the user can choose&n;&t;&t; * to have function 1 probed before function 0.&n;&t;&t; * Give whichever channel is the primary channel&n;&t;&t; * the lowest priority.&n;&t;&t; */
id|primary_channel
op_assign
(paren
id|lahc-&gt;flags
op_amp
id|AHC_PRIMARY_CHANNEL
)paren
op_plus
l_char|&squot;A&squot;
suffix:semicolon
id|value
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|lahc-&gt;channel
op_eq
id|primary_channel
)paren
id|value
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|AHC_EISA
suffix:colon
r_if
c_cond
(paren
(paren
id|rahc-&gt;flags
op_amp
id|AHC_BIOS_ENABLED
)paren
op_ne
l_int|0
)paren
(brace
id|value
op_assign
id|lahc-&gt;platform_data-&gt;bios_address
op_minus
id|rahc-&gt;platform_data-&gt;bios_address
suffix:semicolon
)brace
r_else
(brace
id|value
op_assign
id|lahc-&gt;bsh.ioport
op_minus
id|rahc-&gt;bsh.ioport
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;ahc_softc_sort: invalid bus type&quot;
)paren
suffix:semicolon
)brace
r_return
(paren
id|value
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahc_linux_setup_tag_info
id|ahc_linux_setup_tag_info
c_func
(paren
r_char
op_star
id|p
comma
r_char
op_star
id|end
)paren
(brace
r_char
op_star
id|base
suffix:semicolon
r_char
op_star
id|tok
suffix:semicolon
r_char
op_star
id|tok_end
suffix:semicolon
r_char
op_star
id|tok_end2
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|instance
suffix:semicolon
r_int
id|targ
suffix:semicolon
r_int
id|done
suffix:semicolon
r_char
id|tok_list
(braket
)braket
op_assign
(brace
l_char|&squot;.&squot;
comma
l_char|&squot;,&squot;
comma
l_char|&squot;{&squot;
comma
l_char|&squot;}&squot;
comma
l_char|&squot;&bslash;0&squot;
)brace
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_ne
l_char|&squot;:&squot;
)paren
r_return
suffix:semicolon
id|instance
op_assign
op_minus
l_int|1
suffix:semicolon
id|targ
op_assign
op_minus
l_int|1
suffix:semicolon
id|done
op_assign
id|FALSE
suffix:semicolon
id|base
op_assign
id|p
suffix:semicolon
multiline_comment|/* Forward us just past the &squot;:&squot; */
id|tok
op_assign
id|base
op_plus
l_int|1
suffix:semicolon
id|tok_end
op_assign
id|strchr
c_func
(paren
id|tok
comma
l_char|&squot;&bslash;0&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tok_end
OL
id|end
)paren
op_star
id|tok_end
op_assign
l_char|&squot;,&squot;
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|done
)paren
(brace
r_switch
c_cond
(paren
op_star
id|tok
)paren
(brace
r_case
l_char|&squot;{&squot;
suffix:colon
r_if
c_cond
(paren
id|instance
op_eq
op_minus
l_int|1
)paren
id|instance
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|targ
op_eq
op_minus
l_int|1
)paren
id|targ
op_assign
l_int|0
suffix:semicolon
id|tok
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;}&squot;
suffix:colon
r_if
c_cond
(paren
id|targ
op_ne
op_minus
l_int|1
)paren
id|targ
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|instance
op_ne
op_minus
l_int|1
)paren
id|instance
op_assign
op_minus
l_int|1
suffix:semicolon
id|tok
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;,&squot;
suffix:colon
r_case
l_char|&squot;.&squot;
suffix:colon
r_if
c_cond
(paren
id|instance
op_eq
op_minus
l_int|1
)paren
id|done
op_assign
id|TRUE
suffix:semicolon
r_else
r_if
c_cond
(paren
id|targ
op_ge
l_int|0
)paren
id|targ
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|instance
op_ge
l_int|0
)paren
id|instance
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|targ
op_ge
id|AHC_NUM_TARGETS
)paren
op_logical_or
(paren
id|instance
op_ge
id|NUM_ELEMENTS
c_func
(paren
id|aic7xxx_tag_info
)paren
)paren
)paren
id|done
op_assign
id|TRUE
suffix:semicolon
id|tok
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|done
)paren
(brace
id|base
op_assign
id|tok
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;&bslash;0&squot;
suffix:colon
id|done
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|done
op_assign
id|TRUE
suffix:semicolon
id|tok_end
op_assign
id|strchr
c_func
(paren
id|tok
comma
l_char|&squot;&bslash;0&squot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|tok_list
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tok_end2
op_assign
id|strchr
c_func
(paren
id|tok
comma
id|tok_list
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tok_end2
)paren
op_logical_and
(paren
id|tok_end2
OL
id|tok_end
)paren
)paren
(brace
id|tok_end
op_assign
id|tok_end2
suffix:semicolon
id|done
op_assign
id|FALSE
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|instance
op_ge
l_int|0
)paren
op_logical_and
(paren
id|targ
op_ge
l_int|0
)paren
op_logical_and
(paren
id|instance
OL
id|NUM_ELEMENTS
c_func
(paren
id|aic7xxx_tag_info
)paren
)paren
op_logical_and
(paren
id|targ
OL
id|AHC_NUM_TARGETS
)paren
)paren
(brace
id|aic7xxx_tag_info
(braket
id|instance
)braket
dot
id|tag_commands
(braket
id|targ
)braket
op_assign
id|simple_strtoul
c_func
(paren
id|tok
comma
l_int|NULL
comma
l_int|0
)paren
op_amp
l_int|0xff
suffix:semicolon
)brace
id|tok
op_assign
id|tok_end
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|p
op_ne
id|base
)paren
op_logical_and
(paren
id|p
op_ne
l_int|NULL
)paren
)paren
id|p
op_assign
id|strtok
c_func
(paren
l_int|NULL
comma
l_string|&quot;,.&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Handle Linux boot parameters. This routine allows for assigning a value&n; * to a parameter with a &squot;:&squot; between the parameter and the value.&n; * ie. aic7xxx=unpause:0x0A,extended&n; */
r_int
DECL|function|aic7xxx_setup
id|aic7xxx_setup
c_func
(paren
r_char
op_star
id|s
)paren
(brace
r_int
id|i
comma
id|n
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
r_char
op_star
id|end
suffix:semicolon
r_static
r_struct
(brace
r_const
r_char
op_star
id|name
suffix:semicolon
r_uint32
op_star
id|flag
suffix:semicolon
)brace
id|options
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;extended&quot;
comma
op_amp
id|aic7xxx_extended
)brace
comma
(brace
l_string|&quot;no_reset&quot;
comma
op_amp
id|aic7xxx_no_reset
)brace
comma
(brace
l_string|&quot;irq_trigger&quot;
comma
op_amp
id|aic7xxx_irq_trigger
)brace
comma
(brace
l_string|&quot;verbose&quot;
comma
op_amp
id|aic7xxx_verbose
)brace
comma
(brace
l_string|&quot;reverse_scan&quot;
comma
op_amp
id|aic7xxx_reverse_scan
)brace
comma
(brace
l_string|&quot;override_term&quot;
comma
op_amp
id|aic7xxx_override_term
)brace
comma
(brace
l_string|&quot;stpwlev&quot;
comma
op_amp
id|aic7xxx_stpwlev
)brace
comma
(brace
l_string|&quot;no_probe&quot;
comma
op_amp
id|aic7xxx_no_probe
)brace
comma
(brace
l_string|&quot;panic_on_abort&quot;
comma
op_amp
id|aic7xxx_panic_on_abort
)brace
comma
(brace
l_string|&quot;pci_parity&quot;
comma
op_amp
id|aic7xxx_pci_parity
)brace
comma
(brace
l_string|&quot;dump_sequencer&quot;
comma
op_amp
id|aic7xxx_dump_sequencer
)brace
comma
(brace
l_string|&quot;seltime&quot;
comma
op_amp
id|aic7xxx_seltime
)brace
comma
(brace
l_string|&quot;tag_info&quot;
comma
l_int|NULL
)brace
)brace
suffix:semicolon
id|end
op_assign
id|strchr
c_func
(paren
id|s
comma
l_char|&squot;&bslash;0&squot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|strtok
c_func
(paren
id|s
comma
l_string|&quot;,.&quot;
)paren
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|strtok
c_func
(paren
l_int|NULL
comma
l_string|&quot;,.&quot;
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_ELEMENTS
c_func
(paren
id|options
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|n
op_assign
id|strlen
c_func
(paren
id|options
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|options
(braket
id|i
)braket
dot
id|name
comma
id|p
comma
id|n
)paren
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|p
comma
l_string|&quot;tag_info&quot;
comma
id|n
)paren
op_eq
l_int|0
)paren
(brace
id|ahc_linux_setup_tag_info
c_func
(paren
id|p
op_plus
id|n
comma
id|end
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|p
(braket
id|n
)braket
op_eq
l_char|&squot;:&squot;
)paren
(brace
op_star
(paren
id|options
(braket
id|i
)braket
dot
id|flag
)paren
op_assign
id|simple_strtoul
c_func
(paren
id|p
op_plus
id|n
op_plus
l_int|1
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|p
comma
l_string|&quot;verbose&quot;
comma
id|n
)paren
)paren
(brace
op_star
(paren
id|options
(braket
id|i
)braket
dot
id|flag
)paren
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
op_star
(paren
id|options
(braket
id|i
)braket
dot
id|flag
)paren
op_assign
op_complement
(paren
op_star
(paren
id|options
(braket
id|i
)braket
dot
id|flag
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
id|register_reboot_notifier
c_func
(paren
op_amp
id|ahc_linux_notifier
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#if LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,3,0)
id|__setup
c_func
(paren
l_string|&quot;aic7xxx=&quot;
comma
id|aic7xxx_setup
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|aic7xxx_verbose
r_int
id|aic7xxx_verbose
suffix:semicolon
multiline_comment|/*&n; * Try to detect an Adaptec 7XXX controller.&n; */
r_int
DECL|function|ahc_linux_detect
id|ahc_linux_detect
c_func
(paren
id|Scsi_Host_Template
op_star
r_template
)paren
(brace
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
r_int
id|found
suffix:semicolon
multiline_comment|/*&n;&t; * Sanity checking of Linux SCSI data structures so&n;&t; * that some of our hacks^H^H^H^H^Hassumptions aren&squot;t&n;&t; * violated.&n;&t; */
r_if
c_cond
(paren
m_offsetof
(paren
r_struct
id|ahc_cmd_internal
comma
id|end
)paren
OG
m_offsetof
(paren
r_struct
id|scsi_cmnd
comma
id|host_scribble
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;ahc_linux_detect: SCSI data structures changed.&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;ahc_linux_detect: Unable to attach&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
multiline_comment|/*&n;&t; * If we&squot;ve been passed any parameters, process them now.&n;&t; */
r_if
c_cond
(paren
id|aic7xxx
)paren
id|aic7xxx_setup
c_func
(paren
id|aic7xxx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dummy_buffer
(braket
l_int|0
)braket
op_ne
l_char|&squot;P&squot;
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;aic7xxx: Please read the file /usr/src/linux/drivers/scsi/README.aic7xxx&bslash;n&quot;
l_string|&quot;aic7xxx: to see the proper way to specify options to the aic7xxx module&bslash;n&quot;
l_string|&quot;aic7xxx: Specifically, don&squot;t use any commas when passing arguments to&bslash;n&quot;
l_string|&quot;aic7xxx: insmod or else it might trash certain memory areas.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,3,0)
r_template
op_member_access_from_pointer
id|proc_name
op_assign
l_string|&quot;aic7xxx&quot;
suffix:semicolon
macro_line|#else
r_template
op_member_access_from_pointer
id|proc_dir
op_assign
op_amp
id|proc_scsi_aic7xxx
suffix:semicolon
macro_line|#endif
r_template
op_member_access_from_pointer
id|sg_tablesize
op_assign
id|AHC_NSEG
suffix:semicolon
macro_line|#ifdef CONFIG_PCI
id|ahc_linux_pci_probe
c_func
(paren
r_template
)paren
suffix:semicolon
macro_line|#endif
id|aic7770_linux_probe
c_func
(paren
r_template
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Register with the SCSI layer all&n;&t; * controllers we&squot;ve found.&n;&t; */
id|found
op_assign
l_int|0
suffix:semicolon
id|TAILQ_FOREACH
c_func
(paren
id|ahc
comma
op_amp
id|ahc_tailq
comma
id|links
)paren
(brace
r_if
c_cond
(paren
id|ahc_linux_register_host
c_func
(paren
id|ahc
comma
r_template
)paren
op_eq
l_int|0
)paren
id|found
op_increment
suffix:semicolon
)brace
id|aic7xxx_detect_complete
op_increment
suffix:semicolon
r_return
(paren
id|found
)paren
suffix:semicolon
)brace
r_int
DECL|function|ahc_linux_register_host
id|ahc_linux_register_host
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|Scsi_Host_Template
op_star
r_template
)paren
(brace
r_char
id|buf
(braket
l_int|80
)braket
suffix:semicolon
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
r_char
op_star
id|new_name
suffix:semicolon
id|u_long
id|s
suffix:semicolon
r_template
op_member_access_from_pointer
id|name
op_assign
id|ahc-&gt;description
suffix:semicolon
id|host
op_assign
id|scsi_register
c_func
(paren
r_template
comma
r_sizeof
(paren
r_struct
id|ahc_softc
op_star
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|host
op_eq
l_int|NULL
)paren
r_return
(paren
id|ENOMEM
)paren
suffix:semicolon
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
op_star
(paren
(paren
r_struct
id|ahc_softc
op_star
op_star
)paren
id|host-&gt;hostdata
)paren
op_assign
id|ahc
suffix:semicolon
id|ahc-&gt;platform_data-&gt;host
op_assign
id|host
suffix:semicolon
id|host-&gt;can_queue
op_assign
id|AHC_MAX_QUEUE
suffix:semicolon
id|host-&gt;cmd_per_lun
op_assign
l_int|2
suffix:semicolon
id|host-&gt;sg_tablesize
op_assign
id|AHC_NSEG
suffix:semicolon
id|host-&gt;select_queue_depths
op_assign
id|ahc_linux_select_queue_depth
suffix:semicolon
multiline_comment|/* XXX No way to communicate the ID for multiple channels */
id|host-&gt;this_id
op_assign
id|ahc-&gt;our_id
suffix:semicolon
id|host-&gt;irq
op_assign
id|ahc-&gt;platform_data-&gt;irq
suffix:semicolon
id|host-&gt;max_id
op_assign
(paren
id|ahc-&gt;features
op_amp
id|AHC_WIDE
)paren
ques
c_cond
l_int|16
suffix:colon
l_int|8
suffix:semicolon
id|host-&gt;max_channel
op_assign
(paren
id|ahc-&gt;features
op_amp
id|AHC_TWIN
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|ahc_set_unit
c_func
(paren
id|ahc
comma
id|ahc_linux_next_unit
c_func
(paren
)paren
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;scsi%d&quot;
comma
id|host-&gt;host_no
)paren
suffix:semicolon
id|new_name
op_assign
id|malloc
c_func
(paren
id|strlen
c_func
(paren
id|buf
)paren
op_plus
l_int|1
comma
id|M_DEVBUF
comma
id|M_NOWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_name
op_ne
l_int|NULL
)paren
(brace
id|strcpy
c_func
(paren
id|new_name
comma
id|buf
)paren
suffix:semicolon
id|ahc_set_name
c_func
(paren
id|ahc
comma
id|new_name
)paren
suffix:semicolon
)brace
id|host-&gt;unique_id
op_assign
id|ahc-&gt;unit
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,4,4)
id|scsi_set_pci_device
c_func
(paren
id|host
comma
id|ahc-&gt;dev_softc
)paren
suffix:semicolon
macro_line|#endif
id|ahc_linux_initialize_scsi_bus
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Find the smallest available unit number to use&n; * for a new device.  We don&squot;t just use a static&n; * count to handle the &quot;repeated hot-(un)plug&quot;&n; * scenario.&n; */
r_static
r_int
DECL|function|ahc_linux_next_unit
id|ahc_linux_next_unit
c_func
(paren
)paren
(brace
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
r_int
id|unit
suffix:semicolon
id|unit
op_assign
l_int|0
suffix:semicolon
id|retry
suffix:colon
id|TAILQ_FOREACH
c_func
(paren
id|ahc
comma
op_amp
id|ahc_tailq
comma
id|links
)paren
(brace
r_if
c_cond
(paren
id|ahc-&gt;unit
op_eq
id|unit
)paren
(brace
id|unit
op_increment
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
)brace
r_return
(paren
id|unit
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Place the SCSI bus into a known state by either resetting it,&n; * or forcing transfer negotiations on the next command to any&n; * target.&n; */
r_void
DECL|function|ahc_linux_initialize_scsi_bus
id|ahc_linux_initialize_scsi_bus
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|numtarg
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
id|numtarg
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|aic7xxx_no_reset
op_ne
l_int|0
)paren
id|ahc-&gt;flags
op_and_assign
op_complement
(paren
id|AHC_RESET_BUS_A
op_or
id|AHC_RESET_BUS_B
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;flags
op_amp
id|AHC_RESET_BUS_A
)paren
op_ne
l_int|0
)paren
id|ahc_reset_channel
c_func
(paren
id|ahc
comma
l_char|&squot;A&squot;
comma
multiline_comment|/*initiate_reset*/
id|TRUE
)paren
suffix:semicolon
r_else
id|numtarg
op_assign
(paren
id|ahc-&gt;features
op_amp
id|AHC_WIDE
)paren
ques
c_cond
l_int|16
suffix:colon
l_int|8
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_TWIN
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|ahc-&gt;flags
op_amp
id|AHC_RESET_BUS_B
)paren
op_ne
l_int|0
)paren
(brace
id|ahc_reset_channel
c_func
(paren
id|ahc
comma
l_char|&squot;B&squot;
comma
multiline_comment|/*initiate_reset*/
id|TRUE
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|numtarg
op_eq
l_int|0
)paren
id|i
op_assign
l_int|8
suffix:semicolon
id|numtarg
op_add_assign
l_int|8
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|numtarg
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ahc_devinfo
id|devinfo
suffix:semicolon
r_struct
id|ahc_initiator_tinfo
op_star
id|tinfo
suffix:semicolon
r_struct
id|ahc_tmode_tstate
op_star
id|tstate
suffix:semicolon
id|u_int
id|our_id
suffix:semicolon
id|u_int
id|target_id
suffix:semicolon
r_char
id|channel
suffix:semicolon
id|channel
op_assign
l_char|&squot;A&squot;
suffix:semicolon
id|our_id
op_assign
id|ahc-&gt;our_id
suffix:semicolon
id|target_id
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|7
op_logical_and
(paren
id|ahc-&gt;features
op_amp
id|AHC_TWIN
)paren
op_ne
l_int|0
)paren
(brace
id|channel
op_assign
l_char|&squot;B&squot;
suffix:semicolon
id|our_id
op_assign
id|ahc-&gt;our_id_b
suffix:semicolon
id|target_id
op_assign
id|i
op_mod
l_int|8
suffix:semicolon
)brace
id|tinfo
op_assign
id|ahc_fetch_transinfo
c_func
(paren
id|ahc
comma
id|channel
comma
id|our_id
comma
id|target_id
comma
op_amp
id|tstate
)paren
suffix:semicolon
id|tinfo-&gt;goal
op_assign
id|tinfo-&gt;user
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Don&squot;t try negotiations that require PPR messages&n;&t;&t; * until we successfully retrieve Inquiry data.&n;&t;&t; */
id|tinfo-&gt;goal.ppr_options
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tinfo-&gt;goal.transport_version
OG
id|SCSI_REV_2
)paren
id|tinfo-&gt;goal.transport_version
op_assign
id|SCSI_REV_2
suffix:semicolon
id|ahc_compile_devinfo
c_func
(paren
op_amp
id|devinfo
comma
id|our_id
comma
id|target_id
comma
id|CAM_LUN_WILDCARD
comma
id|channel
comma
id|ROLE_INITIATOR
)paren
suffix:semicolon
id|ahc_update_neg_request
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
comma
id|tstate
comma
id|tinfo
comma
multiline_comment|/*force*/
id|FALSE
)paren
suffix:semicolon
)brace
multiline_comment|/* Give the bus some time to recover */
r_if
c_cond
(paren
(paren
id|ahc-&gt;flags
op_amp
(paren
id|AHC_RESET_BUS_A
op_or
id|AHC_RESET_BUS_B
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|ahc_linux_freeze_sim_queue
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;reset_timer
)paren
suffix:semicolon
id|ahc-&gt;platform_data-&gt;reset_timer.data
op_assign
(paren
id|u_long
)paren
id|ahc
suffix:semicolon
id|ahc-&gt;platform_data-&gt;reset_timer.expires
op_assign
id|jiffies
op_plus
(paren
id|AIC7XXX_RESET_DELAY
op_star
id|HZ
)paren
op_div
l_int|1000
suffix:semicolon
id|ahc-&gt;platform_data-&gt;reset_timer.function
op_assign
id|ahc_linux_release_sim_queue
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;reset_timer
)paren
suffix:semicolon
)brace
)brace
r_int
DECL|function|ahc_platform_alloc
id|ahc_platform_alloc
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_void
op_star
id|platform_arg
)paren
(brace
id|ahc-&gt;platform_data
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ahc_platform_data
)paren
comma
id|M_DEVBUF
comma
id|M_NOWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;platform_data
op_eq
l_int|NULL
)paren
r_return
(paren
id|ENOMEM
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ahc-&gt;platform_data
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ahc_platform_data
)paren
)paren
suffix:semicolon
id|TAILQ_INIT
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;completeq
)paren
suffix:semicolon
id|LIST_INIT
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;device_runq
)paren
suffix:semicolon
id|ahc_lockinit
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_done_lockinit
c_func
(paren
id|ahc
)paren
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,3,0)
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;eh_sem
)paren
suffix:semicolon
macro_line|#else
id|ahc-&gt;platform_data-&gt;eh_sem
op_assign
id|MUTEX_LOCKED
suffix:semicolon
macro_line|#endif
id|ahc-&gt;seltime
op_assign
(paren
id|aic7xxx_seltime
op_amp
l_int|0x3
)paren
op_lshift
l_int|4
suffix:semicolon
id|ahc-&gt;seltime_b
op_assign
(paren
id|aic7xxx_seltime
op_amp
l_int|0x3
)paren
op_lshift
l_int|4
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahc_platform_free
id|ahc_platform_free
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_if
c_cond
(paren
id|ahc-&gt;platform_data
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|ahc-&gt;platform_data-&gt;host
op_ne
l_int|NULL
)paren
id|scsi_unregister
c_func
(paren
id|ahc-&gt;platform_data-&gt;host
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;platform_data-&gt;irq
)paren
id|free_irq
c_func
(paren
id|ahc-&gt;platform_data-&gt;irq
comma
id|ahc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;tag
op_eq
id|BUS_SPACE_PIO
op_logical_and
id|ahc-&gt;bsh.ioport
op_ne
l_int|0
)paren
id|release_region
c_func
(paren
id|ahc-&gt;bsh.ioport
comma
l_int|256
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;tag
op_eq
id|BUS_SPACE_MEMIO
op_logical_and
id|ahc-&gt;bsh.maddr
op_ne
l_int|NULL
)paren
(brace
id|u_long
id|base_addr
suffix:semicolon
id|base_addr
op_assign
(paren
id|u_long
)paren
id|ahc-&gt;bsh.maddr
suffix:semicolon
id|base_addr
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|base_addr
)paren
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,4,0)
id|release_mem_region
c_func
(paren
id|ahc-&gt;platform_data-&gt;mem_busaddr
comma
l_int|0x1000
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,4,0)
multiline_comment|/* XXX Need an instance detach in the PCI code */
r_if
c_cond
(paren
id|ahc-&gt;dev_softc
op_ne
l_int|NULL
)paren
id|ahc-&gt;dev_softc-&gt;driver
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
id|free
c_func
(paren
id|ahc-&gt;platform_data
comma
id|M_DEVBUF
)paren
suffix:semicolon
)brace
)brace
r_void
DECL|function|ahc_platform_freeze_devq
id|ahc_platform_freeze_devq
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|scb
op_star
id|scb
)paren
(brace
id|ahc_platform_abort_scbs
c_func
(paren
id|ahc
comma
id|SCB_GET_TARGET
c_func
(paren
id|ahc
comma
id|scb
)paren
comma
id|SCB_GET_CHANNEL
c_func
(paren
id|ahc
comma
id|scb
)paren
comma
id|SCB_GET_LUN
c_func
(paren
id|scb
)paren
comma
id|SCB_LIST_NULL
comma
id|ROLE_UNKNOWN
comma
id|CAM_REQUEUE_REQ
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahc_platform_set_tags
id|ahc_platform_set_tags
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_devinfo
op_star
id|devinfo
comma
id|ahc_queue_alg
id|alg
)paren
(brace
r_struct
id|ahc_linux_device
op_star
id|dev
suffix:semicolon
r_int
id|was_queuing
suffix:semicolon
r_int
id|now_queuing
suffix:semicolon
id|dev
op_assign
id|ahc_linux_get_device
c_func
(paren
id|ahc
comma
id|devinfo-&gt;channel
op_minus
l_char|&squot;A&squot;
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
comma
multiline_comment|/*alloc*/
id|FALSE
)paren
suffix:semicolon
id|was_queuing
op_assign
id|dev-&gt;flags
op_amp
(paren
id|AHC_DEV_Q_BASIC
op_or
id|AHC_DEV_Q_TAGGED
)paren
suffix:semicolon
id|now_queuing
op_assign
id|alg
op_ne
id|AHC_QUEUE_NONE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|AHC_DEV_FREEZE_TIL_EMPTY
)paren
op_eq
l_int|0
op_logical_and
(paren
id|was_queuing
op_ne
id|now_queuing
)paren
op_logical_and
(paren
id|dev-&gt;active
op_ne
l_int|0
)paren
)paren
(brace
id|dev-&gt;flags
op_or_assign
id|AHC_DEV_FREEZE_TIL_EMPTY
suffix:semicolon
id|dev-&gt;qfrozen
op_increment
suffix:semicolon
)brace
id|dev-&gt;flags
op_and_assign
op_complement
(paren
id|AHC_DEV_Q_BASIC
op_or
id|AHC_DEV_Q_TAGGED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|now_queuing
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|was_queuing
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Start out agressively and allow our&n;&t;&t;&t; * dynamic queue depth algorithm to take&n;&t;&t;&t; * care of the rest.&n;&t;&t;&t; */
id|dev-&gt;maxtags
op_assign
id|AHC_MAX_QUEUE
suffix:semicolon
id|dev-&gt;openings
op_assign
id|dev-&gt;maxtags
op_minus
id|dev-&gt;active
suffix:semicolon
)brace
r_if
c_cond
(paren
id|alg
op_eq
id|AHC_QUEUE_TAGGED
)paren
id|dev-&gt;flags
op_or_assign
id|AHC_DEV_Q_TAGGED
suffix:semicolon
r_else
id|dev-&gt;flags
op_or_assign
id|AHC_DEV_Q_BASIC
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We can only have one opening */
id|dev-&gt;maxtags
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;openings
op_assign
l_int|1
op_minus
id|dev-&gt;active
suffix:semicolon
)brace
)brace
r_int
DECL|function|ahc_platform_abort_scbs
id|ahc_platform_abort_scbs
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_int
id|target
comma
r_char
id|channel
comma
r_int
id|lun
comma
id|u_int
id|tag
comma
id|role_t
id|role
comma
r_uint32
id|status
)paren
(brace
r_int
id|chan
suffix:semicolon
r_int
id|maxchan
suffix:semicolon
r_int
id|targ
suffix:semicolon
r_int
id|maxtarg
suffix:semicolon
r_int
id|clun
suffix:semicolon
r_int
id|maxlun
suffix:semicolon
r_int
id|count
suffix:semicolon
r_if
c_cond
(paren
id|tag
op_ne
id|SCB_LIST_NULL
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|chan
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|channel
op_ne
id|ALL_CHANNELS
)paren
(brace
id|chan
op_assign
id|channel
op_minus
l_char|&squot;A&squot;
suffix:semicolon
id|maxchan
op_assign
id|chan
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|maxchan
op_assign
(paren
id|ahc-&gt;features
op_amp
id|AHC_TWIN
)paren
ques
c_cond
l_int|2
suffix:colon
l_int|1
suffix:semicolon
)brace
id|targ
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|target
op_ne
id|CAM_TARGET_WILDCARD
)paren
(brace
id|targ
op_assign
id|target
suffix:semicolon
id|maxtarg
op_assign
id|targ
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|maxtarg
op_assign
(paren
id|ahc-&gt;features
op_amp
id|AHC_WIDE
)paren
ques
c_cond
l_int|16
suffix:colon
l_int|8
suffix:semicolon
)brace
id|clun
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|lun
op_ne
id|CAM_LUN_WILDCARD
)paren
(brace
id|clun
op_assign
id|lun
suffix:semicolon
id|maxlun
op_assign
id|clun
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|maxlun
op_assign
l_int|16
suffix:semicolon
)brace
id|count
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|chan
OL
id|maxchan
suffix:semicolon
id|chan
op_increment
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|targ
OL
id|maxtarg
suffix:semicolon
id|targ
op_increment
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|clun
OL
id|maxlun
suffix:semicolon
id|clun
op_increment
)paren
(brace
r_struct
id|ahc_linux_device
op_star
id|dev
suffix:semicolon
r_struct
id|ahc_busyq
op_star
id|busyq
suffix:semicolon
r_struct
id|ahc_cmd
op_star
id|acmd
suffix:semicolon
id|dev
op_assign
id|ahc_linux_get_device
c_func
(paren
id|ahc
comma
id|chan
comma
id|targ
comma
id|clun
comma
multiline_comment|/*alloc*/
id|FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|busyq
op_assign
op_amp
id|dev-&gt;busyq
suffix:semicolon
r_while
c_loop
(paren
(paren
id|acmd
op_assign
id|TAILQ_FIRST
c_func
(paren
id|busyq
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
id|cmd
op_assign
op_amp
id|acmd_scsi_cmd
c_func
(paren
id|acmd
)paren
suffix:semicolon
id|TAILQ_REMOVE
c_func
(paren
id|busyq
comma
id|acmd
comma
id|acmd_links.tqe
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
id|cmd-&gt;result
op_assign
id|status
op_lshift
l_int|16
suffix:semicolon
id|ahc_linux_queue_cmd_complete
c_func
(paren
id|ahc
comma
id|cmd
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_return
(paren
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Sets the queue depth for each SCSI device hanging&n; * off the input host adapter.&n; */
r_static
r_void
DECL|function|ahc_linux_select_queue_depth
id|ahc_linux_select_queue_depth
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
id|Scsi_Device
op_star
id|scsi_devs
)paren
(brace
id|Scsi_Device
op_star
id|device
suffix:semicolon
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
id|u_long
id|flags
suffix:semicolon
r_int
id|scbnum
suffix:semicolon
id|ahc
op_assign
op_star
(paren
(paren
r_struct
id|ahc_softc
op_star
op_star
)paren
id|host-&gt;hostdata
)paren
suffix:semicolon
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|flags
)paren
suffix:semicolon
id|scbnum
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|device
op_assign
id|scsi_devs
suffix:semicolon
id|device
op_ne
l_int|NULL
suffix:semicolon
id|device
op_assign
id|device-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|device-&gt;host
op_eq
id|host
)paren
(brace
id|ahc_linux_device_queue_depth
c_func
(paren
id|ahc
comma
id|device
)paren
suffix:semicolon
id|scbnum
op_add_assign
id|device-&gt;queue_depth
suffix:semicolon
)brace
)brace
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Determines the queue depth for a given device.&n; */
r_static
r_void
DECL|function|ahc_linux_device_queue_depth
id|ahc_linux_device_queue_depth
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|Scsi_Device
op_star
id|device
)paren
(brace
r_struct
id|ahc_devinfo
id|devinfo
suffix:semicolon
r_struct
id|ahc_initiator_tinfo
op_star
id|targ_info
suffix:semicolon
r_struct
id|ahc_tmode_tstate
op_star
id|tstate
suffix:semicolon
r_uint8
id|tags
suffix:semicolon
id|ahc_compile_devinfo
c_func
(paren
op_amp
id|devinfo
comma
id|device-&gt;channel
op_eq
l_int|0
ques
c_cond
id|ahc-&gt;our_id
suffix:colon
id|ahc-&gt;our_id_b
comma
id|device-&gt;id
comma
id|device-&gt;lun
comma
id|device-&gt;channel
op_eq
l_int|0
ques
c_cond
l_char|&squot;A&squot;
suffix:colon
l_char|&squot;B&squot;
comma
id|ROLE_INITIATOR
)paren
suffix:semicolon
id|targ_info
op_assign
id|ahc_fetch_transinfo
c_func
(paren
id|ahc
comma
id|devinfo.channel
comma
id|devinfo.our_scsiid
comma
id|devinfo.target
comma
op_amp
id|tstate
)paren
suffix:semicolon
id|tags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|device-&gt;tagged_supported
op_ne
l_int|0
op_logical_and
(paren
id|ahc-&gt;user_discenable
op_amp
id|devinfo.target_mask
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ahc-&gt;unit
op_ge
id|NUM_ELEMENTS
c_func
(paren
id|aic7xxx_tag_info
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;aic7xxx: WARNING, insufficient &quot;
l_string|&quot;tag_info instances for installed &quot;
l_string|&quot;controllers. Using defaults&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;aic7xxx: Please update the &quot;
l_string|&quot;aic7xxx_tag_info array in the &quot;
l_string|&quot;aic7xxx.c source file.&bslash;n&quot;
)paren
suffix:semicolon
id|tags
op_assign
id|AHC_MAX_QUEUE
suffix:semicolon
)brace
r_else
(brace
id|adapter_tag_info_t
op_star
id|tag_info
suffix:semicolon
id|tag_info
op_assign
op_amp
id|aic7xxx_tag_info
(braket
id|ahc-&gt;unit
)braket
suffix:semicolon
id|tags
op_assign
id|tag_info-&gt;tag_commands
(braket
id|devinfo.target_offset
)braket
suffix:semicolon
r_if
c_cond
(paren
id|tags
OG
id|AHC_MAX_QUEUE
)paren
id|tags
op_assign
id|AHC_MAX_QUEUE
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tags
op_ne
l_int|0
)paren
(brace
id|device-&gt;queue_depth
op_assign
id|tags
suffix:semicolon
id|ahc_set_tags
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
comma
id|AHC_QUEUE_TAGGED
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;scsi%d:%d:%d:%d: Tagged Queuing enabled.  Depth %d&bslash;n&quot;
comma
id|ahc-&gt;platform_data-&gt;host-&gt;host_no
comma
id|device-&gt;channel
comma
id|device-&gt;id
comma
id|device-&gt;lun
comma
id|tags
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * We allow the OS to queue 2 untagged transactions to&n;&t;&t; * us at any time even though we can only execute them&n;&t;&t; * serially on the controller/device.  This should remove&n;&t;&t; * some latency.&n;&t;&t; */
id|device-&gt;queue_depth
op_assign
l_int|2
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Queue an SCB to the controller.&n; */
r_int
DECL|function|ahc_linux_queue
id|ahc_linux_queue
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|scsi_done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
r_struct
id|ahc_linux_device
op_star
id|dev
suffix:semicolon
id|u_long
id|flags
suffix:semicolon
id|ahc
op_assign
op_star
(paren
r_struct
id|ahc_softc
op_star
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
suffix:semicolon
multiline_comment|/*&n;&t; * Save the callback on completion function.&n;&t; */
id|cmd-&gt;scsi_done
op_assign
id|scsi_done
suffix:semicolon
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|flags
)paren
suffix:semicolon
id|dev
op_assign
id|ahc_linux_get_device
c_func
(paren
id|ahc
comma
id|cmd-&gt;channel
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
comma
multiline_comment|/*alloc*/
id|TRUE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|flags
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;aic7xxx_linux_queue: Unable to allocate device!&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
id|cmd-&gt;result
op_assign
id|CAM_REQ_INPROG
op_lshift
l_int|16
suffix:semicolon
id|TAILQ_INSERT_TAIL
c_func
(paren
op_amp
id|dev-&gt;busyq
comma
(paren
r_struct
id|ahc_cmd
op_star
)paren
id|cmd
comma
id|acmd_links.tqe
)paren
suffix:semicolon
id|ahc_linux_run_device_queue
c_func
(paren
id|ahc
comma
id|dev
)paren
suffix:semicolon
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|flags
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahc_linux_run_device_queue
id|ahc_linux_run_device_queue
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_linux_device
op_star
id|dev
)paren
(brace
r_struct
id|ahc_cmd
op_star
id|acmd
suffix:semicolon
r_struct
id|scsi_cmnd
op_star
id|cmd
suffix:semicolon
r_struct
id|scb
op_star
id|scb
suffix:semicolon
r_struct
id|hardware_scb
op_star
id|hscb
suffix:semicolon
r_struct
id|ahc_initiator_tinfo
op_star
id|tinfo
suffix:semicolon
r_struct
id|ahc_tmode_tstate
op_star
id|tstate
suffix:semicolon
r_uint16
id|mask
suffix:semicolon
r_while
c_loop
(paren
(paren
id|acmd
op_assign
id|TAILQ_FIRST
c_func
(paren
op_amp
id|dev-&gt;busyq
)paren
)paren
op_ne
l_int|NULL
op_logical_and
id|dev-&gt;openings
OG
l_int|0
op_logical_and
id|dev-&gt;qfrozen
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Schedule us to run later.  The only reason we are not&n;&t;&t; * running is because the whole controller Q is frozen.&n;&t;&t; */
r_if
c_cond
(paren
id|ahc-&gt;platform_data-&gt;qfrozen
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|AHC_DEV_ON_RUN_LIST
)paren
op_ne
l_int|0
)paren
r_return
suffix:semicolon
id|LIST_INSERT_HEAD
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;device_runq
comma
id|dev
comma
id|links
)paren
suffix:semicolon
id|dev-&gt;flags
op_or_assign
id|AHC_DEV_ON_RUN_LIST
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Get an scb to use.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|scb
op_assign
id|ahc_get_scb
c_func
(paren
id|ahc
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|AHC_DEV_ON_RUN_LIST
)paren
op_ne
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;running device on run list&quot;
)paren
suffix:semicolon
id|LIST_INSERT_HEAD
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;device_runq
comma
id|dev
comma
id|links
)paren
suffix:semicolon
id|dev-&gt;flags
op_or_assign
id|AHC_DEV_ON_RUN_LIST
suffix:semicolon
id|ahc-&gt;flags
op_or_assign
id|AHC_RESOURCE_SHORTAGE
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s: Temporary Resource Shortage&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|TAILQ_REMOVE
c_func
(paren
op_amp
id|dev-&gt;busyq
comma
id|acmd
comma
id|acmd_links.tqe
)paren
suffix:semicolon
id|cmd
op_assign
op_amp
id|acmd_scsi_cmd
c_func
(paren
id|acmd
)paren
suffix:semicolon
id|scb-&gt;io_ctx
op_assign
id|cmd
suffix:semicolon
id|scb-&gt;platform_data-&gt;dev
op_assign
id|dev
suffix:semicolon
id|hscb
op_assign
id|scb-&gt;hscb
suffix:semicolon
id|cmd-&gt;host_scribble
op_assign
(paren
r_char
op_star
)paren
id|scb
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Fill out basics of the HSCB.&n;&t;&t; */
id|hscb-&gt;control
op_assign
l_int|0
suffix:semicolon
id|hscb-&gt;scsiid
op_assign
id|BUILD_SCSIID
c_func
(paren
id|ahc
comma
id|cmd
)paren
suffix:semicolon
id|hscb-&gt;lun
op_assign
id|cmd-&gt;lun
suffix:semicolon
id|mask
op_assign
id|SCB_GET_TARGET_MASK
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|tinfo
op_assign
id|ahc_fetch_transinfo
c_func
(paren
id|ahc
comma
id|SCB_GET_CHANNEL
c_func
(paren
id|ahc
comma
id|scb
)paren
comma
id|SCB_GET_OUR_ID
c_func
(paren
id|scb
)paren
comma
id|SCB_GET_TARGET
c_func
(paren
id|ahc
comma
id|scb
)paren
comma
op_amp
id|tstate
)paren
suffix:semicolon
id|hscb-&gt;scsirate
op_assign
id|tinfo-&gt;scsirate
suffix:semicolon
id|hscb-&gt;scsioffset
op_assign
id|tinfo-&gt;curr.offset
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tstate-&gt;ultraenb
op_amp
id|mask
)paren
op_ne
l_int|0
)paren
id|hscb-&gt;control
op_or_assign
id|ULTRAENB
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;user_discenable
op_amp
id|mask
)paren
op_ne
l_int|0
)paren
id|hscb-&gt;control
op_or_assign
id|DISCENB
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tstate-&gt;auto_negotiate
op_amp
id|mask
)paren
op_ne
l_int|0
)paren
(brace
id|scb-&gt;flags
op_or_assign
id|SCB_AUTO_NEGOTIATE
suffix:semicolon
id|scb-&gt;hscb-&gt;control
op_or_assign
id|MK_MESSAGE
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
(paren
id|AHC_DEV_Q_TAGGED
op_or
id|AHC_DEV_Q_BASIC
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;commands_since_idle_or_otag
op_eq
id|AHC_OTAG_THRESH
op_logical_and
(paren
id|dev-&gt;flags
op_amp
id|AHC_DEV_Q_TAGGED
)paren
op_ne
l_int|0
)paren
(brace
id|hscb-&gt;control
op_or_assign
id|MSG_ORDERED_TASK
suffix:semicolon
id|dev-&gt;commands_since_idle_or_otag
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|hscb-&gt;control
op_or_assign
id|MSG_SIMPLE_TASK
suffix:semicolon
)brace
)brace
id|hscb-&gt;cdb_len
op_assign
id|cmd-&gt;cmd_len
suffix:semicolon
r_if
c_cond
(paren
id|hscb-&gt;cdb_len
op_le
l_int|12
)paren
(brace
id|memcpy
c_func
(paren
id|hscb-&gt;shared_data.cdb
comma
id|cmd-&gt;cmnd
comma
id|hscb-&gt;cdb_len
)paren
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|hscb-&gt;cdb32
comma
id|cmd-&gt;cmnd
comma
id|hscb-&gt;cdb_len
)paren
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_CDB32_PTR
suffix:semicolon
)brace
id|scb-&gt;platform_data-&gt;xfer_len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;use_sg
op_ne
l_int|0
)paren
(brace
r_struct
id|ahc_dma_seg
op_star
id|sg
suffix:semicolon
r_struct
id|scatterlist
op_star
id|cur_seg
suffix:semicolon
r_struct
id|scatterlist
op_star
id|end_seg
suffix:semicolon
r_int
id|nseg
suffix:semicolon
id|cur_seg
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;request_buffer
suffix:semicolon
id|nseg
op_assign
id|pci_map_sg
c_func
(paren
id|ahc-&gt;dev_softc
comma
id|cur_seg
comma
id|cmd-&gt;use_sg
comma
id|scsi_to_pci_dma_dir
c_func
(paren
id|cmd
op_member_access_from_pointer
id|sc_data_direction
)paren
)paren
suffix:semicolon
id|end_seg
op_assign
id|cur_seg
op_plus
id|nseg
suffix:semicolon
multiline_comment|/* Copy the segments into the SG list. */
id|sg
op_assign
id|scb-&gt;sg_list
suffix:semicolon
r_while
c_loop
(paren
id|cur_seg
OL
id|end_seg
)paren
(brace
id|sg-&gt;addr
op_assign
id|ahc_htole32
c_func
(paren
id|sg_dma_address
c_func
(paren
id|cur_seg
)paren
)paren
suffix:semicolon
multiline_comment|/* XXX Add in the 5th byte of the address later.*/
id|sg-&gt;len
op_assign
id|ahc_htole32
c_func
(paren
id|sg_dma_len
c_func
(paren
id|cur_seg
)paren
)paren
suffix:semicolon
id|scb-&gt;platform_data-&gt;xfer_len
op_add_assign
id|sg_dma_len
c_func
(paren
id|cur_seg
)paren
suffix:semicolon
id|sg
op_increment
suffix:semicolon
id|cur_seg
op_increment
suffix:semicolon
)brace
id|sg
op_decrement
suffix:semicolon
id|sg-&gt;len
op_or_assign
id|ahc_htole32
c_func
(paren
id|AHC_DMA_LAST_SEG
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Reset the sg list pointer.&n;&t;&t;&t; */
id|scb-&gt;hscb-&gt;sgptr
op_assign
id|ahc_htole32
c_func
(paren
id|scb-&gt;sg_list_phys
op_or
id|SG_FULL_RESID
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Copy the first SG into the &quot;current&quot;&n;&t;&t;&t; * data pointer area.&n;&t;&t;&t; */
id|scb-&gt;hscb-&gt;dataptr
op_assign
id|scb-&gt;sg_list-&gt;addr
suffix:semicolon
id|scb-&gt;hscb-&gt;datacnt
op_assign
id|scb-&gt;sg_list-&gt;len
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Remember the number of segments for later&n;&t;&t;&t; * residual calculations.&n;&t;&t;&t; */
id|scb-&gt;sg_count
op_assign
id|nseg
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmd-&gt;request_bufflen
op_ne
l_int|0
)paren
(brace
r_struct
id|ahc_dma_seg
op_star
id|sg
suffix:semicolon
r_uint32
id|baddr
suffix:semicolon
id|sg
op_assign
id|scb-&gt;sg_list
suffix:semicolon
id|baddr
op_assign
id|pci_map_single
c_func
(paren
id|ahc-&gt;dev_softc
comma
id|cmd-&gt;request_buffer
comma
id|cmd-&gt;request_bufflen
comma
id|scsi_to_pci_dma_dir
c_func
(paren
id|cmd-&gt;sc_data_direction
)paren
)paren
suffix:semicolon
id|sg-&gt;addr
op_assign
id|ahc_htole32
c_func
(paren
id|baddr
)paren
suffix:semicolon
id|sg-&gt;len
op_assign
id|ahc_htole32
c_func
(paren
id|cmd-&gt;request_bufflen
op_or
id|AHC_DMA_LAST_SEG
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Reset the sg list pointer.&n;&t;&t;&t; */
id|scb-&gt;hscb-&gt;sgptr
op_assign
id|ahc_htole32
c_func
(paren
id|scb-&gt;sg_list_phys
op_or
id|SG_FULL_RESID
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Copy the first SG into the &quot;current&quot;&n;&t;&t;&t; * data pointer area.&n;&t;&t;&t; */
id|scb-&gt;hscb-&gt;dataptr
op_assign
id|sg-&gt;addr
suffix:semicolon
id|scb-&gt;hscb-&gt;datacnt
op_assign
id|sg-&gt;len
suffix:semicolon
id|scb-&gt;platform_data-&gt;xfer_len
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Remember the number of segments for later&n;&t;&t;&t; * residual calculations.&n;&t;&t;&t; */
id|scb-&gt;sg_count
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|scb-&gt;hscb-&gt;sgptr
op_assign
id|ahc_htole32
c_func
(paren
id|SG_LIST_NULL
)paren
suffix:semicolon
id|scb-&gt;hscb-&gt;dataptr
op_assign
l_int|0
suffix:semicolon
id|scb-&gt;hscb-&gt;datacnt
op_assign
l_int|0
suffix:semicolon
id|scb-&gt;sg_count
op_assign
l_int|0
suffix:semicolon
)brace
id|LIST_INSERT_HEAD
c_func
(paren
op_amp
id|ahc-&gt;pending_scbs
comma
id|scb
comma
id|pending_links
)paren
suffix:semicolon
id|dev-&gt;openings
op_decrement
suffix:semicolon
id|dev-&gt;active
op_increment
suffix:semicolon
id|dev-&gt;commands_issued
op_increment
suffix:semicolon
id|dev-&gt;commands_since_idle_or_otag
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We only allow one untagged transaction&n;&t;&t; * per target in the initiator role unless&n;&t;&t; * we are storing a full busy target *lun*&n;&t;&t; * table in SCB space.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|scb-&gt;hscb-&gt;control
op_amp
(paren
id|TARGET_SCB
op_or
id|TAG_ENB
)paren
)paren
op_eq
l_int|0
op_logical_and
(paren
id|ahc-&gt;features
op_amp
id|AHC_SCB_BTT
)paren
op_eq
l_int|0
)paren
(brace
r_struct
id|scb_tailq
op_star
id|untagged_q
suffix:semicolon
r_int
id|target_offset
suffix:semicolon
id|target_offset
op_assign
id|SCB_GET_TARGET_OFFSET
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|untagged_q
op_assign
op_amp
(paren
id|ahc-&gt;untagged_queues
(braket
id|target_offset
)braket
)paren
suffix:semicolon
id|TAILQ_INSERT_TAIL
c_func
(paren
id|untagged_q
comma
id|scb
comma
id|links.tqe
)paren
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_UNTAGGEDQ
suffix:semicolon
r_if
c_cond
(paren
id|TAILQ_FIRST
c_func
(paren
id|untagged_q
)paren
op_ne
id|scb
)paren
r_continue
suffix:semicolon
)brace
id|scb-&gt;flags
op_or_assign
id|SCB_ACTIVE
suffix:semicolon
id|ahc_queue_scb
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * SCSI controller interrupt handler.&n; */
r_void
DECL|function|ahc_linux_isr
id|ahc_linux_isr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
r_struct
id|ahc_cmd
op_star
id|acmd
suffix:semicolon
id|u_long
id|flags
suffix:semicolon
id|ahc
op_assign
(paren
r_struct
id|ahc_softc
op_star
)paren
id|dev_id
suffix:semicolon
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|flags
)paren
suffix:semicolon
id|ahc_intr
c_func
(paren
id|ahc
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * It would be nice to run the device queues from a&n;&t; * bottom half handler, but as there is no way to&n;&t; * dynamically register one, we&squot;ll have to postpone&n;&t; * that until we get integrated into the kernel.&n;&t; */
id|ahc_linux_run_device_queues
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|acmd
op_assign
id|TAILQ_FIRST
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;completeq
)paren
suffix:semicolon
id|TAILQ_INIT
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;completeq
)paren
suffix:semicolon
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acmd
op_ne
l_int|NULL
)paren
id|ahc_linux_run_complete_queue
c_func
(paren
id|ahc
comma
id|acmd
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahc_platform_flushwork
id|ahc_platform_flushwork
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_struct
id|ahc_cmd
op_star
id|acmd
suffix:semicolon
id|acmd
op_assign
id|TAILQ_FIRST
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;completeq
)paren
suffix:semicolon
id|TAILQ_INIT
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;completeq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acmd
op_ne
l_int|NULL
)paren
id|ahc_linux_run_complete_queue
c_func
(paren
id|ahc
comma
id|acmd
)paren
suffix:semicolon
)brace
r_static
r_struct
id|ahc_linux_target
op_star
DECL|function|ahc_linux_alloc_target
id|ahc_linux_alloc_target
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|u_int
id|channel
comma
id|u_int
id|target
)paren
(brace
r_struct
id|ahc_linux_target
op_star
id|targ
suffix:semicolon
id|u_int
id|target_offset
suffix:semicolon
id|targ
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|targ
)paren
comma
id|M_DEVBUG
comma
id|M_NOWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|targ
op_eq
l_int|NULL
)paren
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|targ
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|targ
)paren
)paren
suffix:semicolon
id|targ-&gt;channel
op_assign
id|channel
suffix:semicolon
id|targ-&gt;target
op_assign
id|target
suffix:semicolon
id|target_offset
op_assign
id|target
suffix:semicolon
r_if
c_cond
(paren
id|channel
op_ne
l_int|0
)paren
id|target_offset
op_add_assign
l_int|8
suffix:semicolon
id|ahc-&gt;platform_data-&gt;targets
(braket
id|target_offset
)braket
op_assign
id|targ
suffix:semicolon
r_return
(paren
id|targ
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahc_linux_free_target
id|ahc_linux_free_target
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_linux_target
op_star
id|targ
)paren
(brace
id|u_int
id|target_offset
suffix:semicolon
id|target_offset
op_assign
id|targ-&gt;target
suffix:semicolon
r_if
c_cond
(paren
id|targ-&gt;channel
op_ne
l_int|0
)paren
id|target_offset
op_add_assign
l_int|8
suffix:semicolon
id|ahc-&gt;platform_data-&gt;targets
(braket
id|target_offset
)braket
op_assign
l_int|NULL
suffix:semicolon
id|free
c_func
(paren
id|targ
comma
id|M_DEVBUF
)paren
suffix:semicolon
)brace
r_static
r_struct
id|ahc_linux_device
op_star
DECL|function|ahc_linux_alloc_device
id|ahc_linux_alloc_device
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_linux_target
op_star
id|targ
comma
id|u_int
id|lun
)paren
(brace
r_struct
id|ahc_linux_device
op_star
id|dev
suffix:semicolon
id|dev
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|dev
)paren
comma
id|M_DEVBUG
comma
id|M_NOWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|dev
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|dev
)paren
)paren
suffix:semicolon
id|TAILQ_INIT
c_func
(paren
op_amp
id|dev-&gt;busyq
)paren
suffix:semicolon
id|dev-&gt;flags
op_assign
id|AHC_DEV_UNCONFIGURED
suffix:semicolon
id|dev-&gt;lun
op_assign
id|lun
suffix:semicolon
id|dev-&gt;target
op_assign
id|targ
suffix:semicolon
multiline_comment|/*&n;&t; * We start out life using untagged&n;&t; * transactions of which we allow one.&n;&t; */
id|dev-&gt;openings
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Set maxtags to 0.  This will be changed if we&n;&t; * later determine that we are dealing with&n;&t; * a tagged queuing capable device.&n;&t; */
id|dev-&gt;maxtags
op_assign
l_int|0
suffix:semicolon
id|targ-&gt;refcount
op_increment
suffix:semicolon
id|targ-&gt;devices
(braket
id|lun
)braket
op_assign
id|dev
suffix:semicolon
r_return
(paren
id|dev
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahc_linux_free_device
id|ahc_linux_free_device
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_linux_device
op_star
id|dev
)paren
(brace
r_struct
id|ahc_linux_target
op_star
id|targ
suffix:semicolon
id|targ
op_assign
id|dev-&gt;target
suffix:semicolon
id|targ-&gt;devices
(braket
id|dev-&gt;lun
)braket
op_assign
l_int|NULL
suffix:semicolon
id|free
c_func
(paren
id|dev
comma
id|M_DEVBUF
)paren
suffix:semicolon
id|targ-&gt;refcount
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|targ-&gt;refcount
op_eq
l_int|0
)paren
id|ahc_linux_free_target
c_func
(paren
id|ahc
comma
id|targ
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Return a string describing the driver.&n; */
r_const
r_char
op_star
DECL|function|ahc_linux_info
id|ahc_linux_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_static
r_char
id|buffer
(braket
l_int|512
)braket
suffix:semicolon
r_char
id|ahc_info
(braket
l_int|256
)braket
suffix:semicolon
r_char
op_star
id|bp
suffix:semicolon
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
id|bp
op_assign
op_amp
id|buffer
(braket
l_int|0
)braket
suffix:semicolon
id|ahc
op_assign
op_star
(paren
r_struct
id|ahc_softc
op_star
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|memset
c_func
(paren
id|bp
comma
l_int|0
comma
r_sizeof
(paren
id|buffer
)paren
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|bp
comma
l_string|&quot;Adaptec AIC7XXX EISA/VLB/PCI SCSI HBA DRIVER, Rev &quot;
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
id|AIC7XXX_DRIVER_VERSION
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
l_string|&quot;        &lt;&quot;
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
id|ahc-&gt;description
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
l_string|&quot;&gt;&bslash;n&quot;
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
l_string|&quot;        &quot;
)paren
suffix:semicolon
id|ahc_controller_info
c_func
(paren
id|ahc
comma
id|ahc_info
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
id|ahc_info
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|bp
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
id|bp
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahc_send_async
id|ahc_send_async
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_char
id|channel
comma
id|u_int
id|target
comma
id|u_int
id|lun
comma
id|ac_code
id|code
comma
r_void
op_star
id|arg
)paren
(brace
r_switch
c_cond
(paren
id|code
)paren
(brace
r_case
id|AC_TRANSFER_NEG
suffix:colon
(brace
r_char
id|buf
(braket
l_int|80
)braket
suffix:semicolon
r_struct
id|ahc_linux_target
op_star
id|targ
suffix:semicolon
r_struct
id|info_str
id|info
suffix:semicolon
r_struct
id|ahc_initiator_tinfo
op_star
id|tinfo
suffix:semicolon
r_struct
id|ahc_tmode_tstate
op_star
id|tstate
suffix:semicolon
r_int
id|target_offset
suffix:semicolon
id|info.buffer
op_assign
id|buf
suffix:semicolon
id|info.length
op_assign
r_sizeof
(paren
id|buf
)paren
suffix:semicolon
id|info.offset
op_assign
l_int|0
suffix:semicolon
id|info.pos
op_assign
l_int|0
suffix:semicolon
id|tinfo
op_assign
id|ahc_fetch_transinfo
c_func
(paren
id|ahc
comma
id|channel
comma
id|channel
op_eq
l_char|&squot;A&squot;
ques
c_cond
id|ahc-&gt;our_id
suffix:colon
id|ahc-&gt;our_id_b
comma
id|target
comma
op_amp
id|tstate
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Don&squot;t bother reporting results while&n;&t;&t; * negotiations are still pending.&n;&t;&t; */
r_if
c_cond
(paren
id|tinfo-&gt;curr.period
op_ne
id|tinfo-&gt;goal.period
op_logical_or
id|tinfo-&gt;curr.width
op_ne
id|tinfo-&gt;goal.width
op_logical_or
id|tinfo-&gt;curr.offset
op_ne
id|tinfo-&gt;goal.offset
op_logical_or
id|tinfo-&gt;curr.ppr_options
op_ne
id|tinfo-&gt;goal.ppr_options
)paren
r_if
c_cond
(paren
id|bootverbose
op_eq
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Don&squot;t bother reporting results that&n;&t;&t; * are identical to those last reported.&n;&t;&t; */
id|target_offset
op_assign
id|target
suffix:semicolon
r_if
c_cond
(paren
id|channel
op_eq
l_char|&squot;B&squot;
)paren
id|target_offset
op_add_assign
l_int|8
suffix:semicolon
id|targ
op_assign
id|ahc-&gt;platform_data-&gt;targets
(braket
id|target_offset
)braket
suffix:semicolon
r_if
c_cond
(paren
id|targ
op_ne
l_int|NULL
op_logical_and
id|tinfo-&gt;curr.period
op_eq
id|targ-&gt;last_tinfo.period
op_logical_and
id|tinfo-&gt;curr.width
op_eq
id|targ-&gt;last_tinfo.width
op_logical_and
id|tinfo-&gt;curr.offset
op_eq
id|targ-&gt;last_tinfo.offset
op_logical_and
id|tinfo-&gt;curr.ppr_options
op_eq
id|targ-&gt;last_tinfo.ppr_options
)paren
r_if
c_cond
(paren
id|bootverbose
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|targ-&gt;last_tinfo.period
op_assign
id|tinfo-&gt;curr.period
suffix:semicolon
id|targ-&gt;last_tinfo.width
op_assign
id|tinfo-&gt;curr.width
suffix:semicolon
id|targ-&gt;last_tinfo.offset
op_assign
id|tinfo-&gt;curr.offset
suffix:semicolon
id|targ-&gt;last_tinfo.ppr_options
op_assign
id|tinfo-&gt;curr.ppr_options
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;(%s:%c:&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|channel
)paren
suffix:semicolon
r_if
c_cond
(paren
id|target
op_eq
id|CAM_TARGET_WILDCARD
)paren
id|printf
c_func
(paren
l_string|&quot;*): &quot;
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot;%d): &quot;
comma
id|target
)paren
suffix:semicolon
id|ahc_format_transinfo
c_func
(paren
op_amp
id|info
comma
op_amp
id|tinfo-&gt;curr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info.pos
OL
id|info.length
)paren
op_star
id|info.buffer
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_else
id|buf
(braket
id|info.length
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s&quot;
comma
id|buf
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|AC_SENT_BDR
suffix:colon
r_break
suffix:semicolon
r_case
id|AC_BUS_RESET
suffix:colon
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,3,0)
id|scsi_report_bus_reset
c_func
(paren
id|ahc-&gt;platform_data-&gt;host
comma
id|channel
op_minus
l_char|&squot;A&squot;
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;ahc_send_async: Unexpected async event&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Calls the higher level scsi done function and frees the scb.&n; */
r_void
DECL|function|ahc_done
id|ahc_done
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|scb
op_star
id|scb
)paren
(brace
id|Scsi_Cmnd
op_star
id|cmd
suffix:semicolon
r_struct
id|ahc_linux_device
op_star
id|dev
suffix:semicolon
id|LIST_REMOVE
c_func
(paren
id|scb
comma
id|pending_links
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_UNTAGGEDQ
)paren
op_ne
l_int|0
)paren
(brace
r_struct
id|scb_tailq
op_star
id|untagged_q
suffix:semicolon
r_int
id|target_offset
suffix:semicolon
id|target_offset
op_assign
id|SCB_GET_TARGET_OFFSET
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|untagged_q
op_assign
op_amp
(paren
id|ahc-&gt;untagged_queues
(braket
id|target_offset
)braket
)paren
suffix:semicolon
id|TAILQ_REMOVE
c_func
(paren
id|untagged_q
comma
id|scb
comma
id|links.tqe
)paren
suffix:semicolon
id|ahc_run_untagged_queue
c_func
(paren
id|ahc
comma
id|untagged_q
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_ACTIVE
)paren
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;SCB %d done&squot;d twice&bslash;n&quot;
comma
id|scb-&gt;hscb-&gt;tag
)paren
suffix:semicolon
id|ahc_dump_card_state
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;Stopping for safety&quot;
)paren
suffix:semicolon
)brace
id|cmd
op_assign
id|scb-&gt;io_ctx
suffix:semicolon
id|dev
op_assign
id|scb-&gt;platform_data-&gt;dev
suffix:semicolon
id|dev-&gt;active
op_decrement
suffix:semicolon
id|dev-&gt;openings
op_increment
suffix:semicolon
id|ahc_linux_unmap_scb
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_SENSE
)paren
(brace
id|memcpy
c_func
(paren
id|cmd-&gt;sense_buffer
comma
id|ahc_get_sense_buf
c_func
(paren
id|ahc
comma
id|scb
)paren
comma
id|MIN
c_func
(paren
r_sizeof
(paren
r_struct
id|scsi_sense_data
)paren
comma
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ahc_get_transaction_status
c_func
(paren
id|scb
)paren
op_eq
id|CAM_REQ_INPROG
)paren
(brace
r_uint32
id|amount_xferred
suffix:semicolon
id|amount_xferred
op_assign
id|ahc_get_transfer_length
c_func
(paren
id|scb
)paren
op_minus
id|ahc_get_residual
c_func
(paren
id|scb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|amount_xferred
OL
id|scb-&gt;io_ctx-&gt;underflow
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Saw underflow (%ld of %ld bytes). &quot;
l_string|&quot;Treated as error&bslash;n&quot;
comma
id|ahc_get_residual
c_func
(paren
id|scb
)paren
comma
id|ahc_get_transfer_length
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
id|ahc_set_transaction_status
c_func
(paren
id|scb
comma
id|CAM_DATA_RUN_ERR
)paren
suffix:semicolon
)brace
r_else
(brace
id|ahc_set_transaction_status
c_func
(paren
id|scb
comma
id|CAM_REQ_CMP
)paren
suffix:semicolon
id|ahc_linux_sniff_command
c_func
(paren
id|ahc
comma
id|cmd
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|ahc_get_transaction_status
c_func
(paren
id|scb
)paren
op_eq
id|DID_OK
)paren
(brace
id|ahc_linux_handle_scsi_status
c_func
(paren
id|ahc
comma
id|dev
comma
id|scb
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ahc_get_transaction_status
c_func
(paren
id|scb
)paren
op_eq
id|DID_NO_CONNECT
)paren
(brace
multiline_comment|/*&n;&t;&t; * Should a selection timeout kill the device?&n;&t;&t; * That depends on whether the selection timeout&n;&t;&t; * is persistent.  Since we have no guarantee that&n;&t;&t; * the mid-layer will issue an inquiry for this device&n;&t;&t; * again, we can&squot;t just kill it off.&n;&t;&t;dev-&gt;flags |= AHC_DEV_UNCONFIGURED;&n;&t;&t; */
)brace
r_if
c_cond
(paren
id|dev-&gt;openings
op_eq
l_int|1
op_logical_and
id|ahc_get_transaction_status
c_func
(paren
id|scb
)paren
op_eq
id|CAM_REQ_CMP
op_logical_and
id|ahc_get_scsi_status
c_func
(paren
id|scb
)paren
op_ne
id|SCSI_STATUS_QUEUE_FULL
)paren
id|dev-&gt;tag_success_count
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * Some devices deal with temporary internal resource&n;&t; * shortages by returning queue full.  When the queue&n;&t; * full occurrs, we throttle back.  Slowly try to get&n;&t; * back to our previous queue depth.&n;&t; */
r_if
c_cond
(paren
(paren
id|dev-&gt;openings
op_plus
id|dev-&gt;active
)paren
template_param
id|AHC_TAG_SUCCESS_INTERVAL
)paren
(brace
id|dev-&gt;tag_success_count
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;openings
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;active
op_eq
l_int|0
)paren
id|dev-&gt;commands_since_idle_or_otag
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|TAILQ_EMPTY
c_func
(paren
op_amp
id|dev-&gt;busyq
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|AHC_DEV_UNCONFIGURED
)paren
op_ne
l_int|0
op_logical_and
id|dev-&gt;active
op_eq
l_int|0
)paren
id|ahc_linux_free_device
c_func
(paren
id|ahc
comma
id|dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|AHC_DEV_ON_RUN_LIST
)paren
op_eq
l_int|0
)paren
(brace
id|LIST_INSERT_HEAD
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;device_runq
comma
id|dev
comma
id|links
)paren
suffix:semicolon
id|dev-&gt;flags
op_or_assign
id|AHC_DEV_ON_RUN_LIST
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_RECOVERY_SCB
)paren
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Recovery SCB completes&bslash;n&quot;
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;eh_sem
)paren
suffix:semicolon
)brace
id|ahc_free_scb
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|ahc_linux_queue_cmd_complete
c_func
(paren
id|ahc
comma
id|cmd
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahc_linux_handle_scsi_status
id|ahc_linux_handle_scsi_status
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
r_struct
id|ahc_linux_device
op_star
id|dev
comma
r_struct
id|scb
op_star
id|scb
)paren
(brace
multiline_comment|/*&n;&t; * We don&squot;t currently trust the mid-layer to&n;&t; * properly deal with queue full or busy.  So,&n;&t; * when one occurs, we tell the mid-layer to&n;&t; * unconditionally requeue the command to us&n;&t; * so that we can retry it ourselves.  We also&n;&t; * implement our own throttling mechanism so&n;&t; * we don&squot;t clobber the device with too many&n;&t; * commands.&n;&t; */
r_switch
c_cond
(paren
id|ahc_get_scsi_status
c_func
(paren
id|scb
)paren
)paren
(brace
r_default
suffix:colon
r_break
suffix:semicolon
r_case
id|SCSI_STATUS_QUEUE_FULL
suffix:colon
(brace
multiline_comment|/*&n;&t;&t; * By the time the core driver has returned this&n;&t;&t; * command, all other commands that were queued&n;&t;&t; * to us but not the device have been returned.&n;&t;&t; * This ensures that dev-&gt;active is equal to&n;&t;&t; * the number of commands actually queued to&n;&t;&t; * the device.&n;&t;&t; */
id|dev-&gt;tag_success_count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;active
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Drop our opening count to the number&n;&t;&t;&t; * of commands currently outstanding.&n;&t;&t;&t; */
id|dev-&gt;openings
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;ahc_print_path(ahc, scb);&n;&t;&t;&t;printf(&quot;Dropping tag count to %d&bslash;n&quot;, dev-&gt;active);&n; */
r_if
c_cond
(paren
id|dev-&gt;active
op_eq
id|dev-&gt;tags_on_last_queuefull
)paren
(brace
id|dev-&gt;last_queuefull_same_count
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * If we repeatedly see a queue full&n;&t;&t;&t;&t; * at the same queue depth, this&n;&t;&t;&t;&t; * device has a fixed number of tag&n;&t;&t;&t;&t; * slots.  Lock in this tag depth&n;&t;&t;&t;&t; * so we stop seeing queue fulls from&n;&t;&t;&t;&t; * this device.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|dev-&gt;last_queuefull_same_count
op_eq
id|AHC_LOCK_TAGS_COUNT
)paren
(brace
id|dev-&gt;maxtags
op_assign
id|dev-&gt;active
suffix:semicolon
id|ahc_print_path
c_func
(paren
id|ahc
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Locking max tag count at %d&bslash;n&quot;
comma
id|dev-&gt;active
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|dev-&gt;tags_on_last_queuefull
op_assign
id|dev-&gt;active
suffix:semicolon
id|dev-&gt;last_queuefull_same_count
op_assign
l_int|0
suffix:semicolon
)brace
id|ahc_set_transaction_status
c_func
(paren
id|scb
comma
id|CAM_REQUEUE_REQ
)paren
suffix:semicolon
id|ahc_set_scsi_status
c_func
(paren
id|scb
comma
id|SCSI_STATUS_OK
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Drop down to a single opening, and treat this&n;&t;&t; * as if the target return BUSY SCSI status.&n;&t;&t; */
id|dev-&gt;openings
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
)brace
r_case
id|SCSI_STATUS_BUSY
suffix:colon
multiline_comment|/*&n;&t;&t; * XXX Set a timer and handle ourselves????&n;&t;&t; * For now we pray that the mid-layer does something&n;&t;&t; * sane for devices that are busy.&n;&t;&t; */
id|ahc_set_scsi_status
c_func
(paren
id|scb
comma
id|SCSI_STATUS_BUSY
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|ahc_linux_filter_command
id|ahc_linux_filter_command
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
comma
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_switch
c_cond
(paren
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
id|INQUIRY
suffix:colon
(brace
r_struct
id|ahc_devinfo
id|devinfo
suffix:semicolon
r_struct
id|scsi_inquiry_data
op_star
id|sid
suffix:semicolon
r_struct
id|ahc_initiator_tinfo
op_star
id|targ_info
suffix:semicolon
r_struct
id|ahc_tmode_tstate
op_star
id|tstate
suffix:semicolon
r_struct
id|ahc_syncrate
op_star
id|syncrate
suffix:semicolon
r_struct
id|ahc_linux_device
op_star
id|dev
suffix:semicolon
id|u_int
id|scsiid
suffix:semicolon
id|u_int
id|maxsync
suffix:semicolon
r_int
id|minlen
suffix:semicolon
id|u_int
id|width
suffix:semicolon
id|u_int
id|period
suffix:semicolon
id|u_int
id|offset
suffix:semicolon
id|u_int
id|ppr_options
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;use_sg
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: SG Inquiry response ignored&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|sid
op_assign
(paren
r_struct
id|scsi_inquiry_data
op_star
)paren
id|cmd-&gt;request_buffer
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Determine if this lun actually exists.  If so,&n;&t;&t; * hold on to its corresponding device structure.&n;&t;&t; * If not, make sure we release the device and&n;&t;&t; * don&squot;t bother processing the rest of this inquiry&n;&t;&t; * command.&n;&t;&t; */
id|dev
op_assign
id|ahc_linux_get_device
c_func
(paren
id|ahc
comma
id|cmd-&gt;channel
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
comma
multiline_comment|/*alloc*/
id|FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;request_bufflen
op_ge
l_int|1
op_logical_and
id|SID_QUAL
c_func
(paren
id|sid
)paren
op_eq
id|SID_QUAL_LU_CONNECTED
)paren
(brace
id|dev-&gt;flags
op_and_assign
op_complement
id|AHC_DEV_UNCONFIGURED
suffix:semicolon
)brace
r_else
(brace
id|dev-&gt;flags
op_or_assign
id|AHC_DEV_UNCONFIGURED
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Update our notion of this device&squot;s transfer&n;&t;&t; * negotiation capabilities.&n;&t;&t; */
id|scsiid
op_assign
id|BUILD_SCSIID
c_func
(paren
id|ahc
comma
id|cmd
)paren
suffix:semicolon
id|ahc_compile_devinfo
c_func
(paren
op_amp
id|devinfo
comma
id|SCSIID_OUR_ID
c_func
(paren
id|scsiid
)paren
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
comma
id|SCSIID_CHANNEL
c_func
(paren
id|ahc
comma
id|scsiid
)paren
comma
id|ROLE_INITIATOR
)paren
suffix:semicolon
id|targ_info
op_assign
id|ahc_fetch_transinfo
c_func
(paren
id|ahc
comma
id|devinfo.channel
comma
id|devinfo.our_scsiid
comma
id|devinfo.target
comma
op_amp
id|tstate
)paren
suffix:semicolon
multiline_comment|/* Structure copy */
id|width
op_assign
id|targ_info-&gt;user.width
suffix:semicolon
id|period
op_assign
id|targ_info-&gt;user.period
suffix:semicolon
id|offset
op_assign
id|targ_info-&gt;user.offset
suffix:semicolon
id|ppr_options
op_assign
id|targ_info-&gt;user.ppr_options
suffix:semicolon
id|minlen
op_assign
m_offsetof
(paren
r_struct
id|scsi_inquiry_data
comma
id|version
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;request_bufflen
op_ge
id|minlen
)paren
(brace
id|targ_info-&gt;curr.protocol_version
op_assign
id|SID_ANSI_REV
c_func
(paren
id|sid
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Only attempt SPI3 once we&squot;ve verified that&n;&t;&t;&t; * the device claims to support SPI3 features.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|targ_info-&gt;curr.protocol_version
OL
id|SCSI_REV_2
)paren
id|targ_info-&gt;curr.transport_version
op_assign
id|SID_ANSI_REV
c_func
(paren
id|sid
)paren
suffix:semicolon
r_else
id|targ_info-&gt;curr.transport_version
op_assign
id|SCSI_REV_2
suffix:semicolon
)brace
id|minlen
op_assign
m_offsetof
(paren
r_struct
id|scsi_inquiry_data
comma
id|flags
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;request_bufflen
op_ge
id|minlen
op_logical_and
(paren
id|sid-&gt;additional_length
op_plus
l_int|4
)paren
op_ge
id|minlen
)paren
(brace
r_if
c_cond
(paren
(paren
id|sid-&gt;flags
op_amp
id|SID_WBus16
)paren
op_eq
l_int|0
)paren
id|width
op_assign
id|MSG_EXT_WDTR_BUS_8_BIT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sid-&gt;flags
op_amp
id|SID_Sync
)paren
op_eq
l_int|0
)paren
(brace
id|period
op_assign
l_int|0
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
id|ppr_options
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Keep current settings */
r_break
suffix:semicolon
)brace
id|minlen
op_assign
m_offsetof
(paren
r_struct
id|scsi_inquiry_data
comma
id|spi3data
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This is a kludge to deal with inquiry requests that&n;&t;&t; * are not large enough for us to pull the spi3 bits.&n;&t;&t; * In this case, we assume that a device that tells us&n;&t;&t; * they can provide inquiry data that spans the SPI3&n;&t;&t; * bits can handle a PPR request.  If the inquiry&n;&t;&t; * request has sufficient buffer space to cover these&n;&t;&t; * bits, we check them to see if any ppr options are&n;&t;&t; * available.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|sid-&gt;additional_length
op_plus
l_int|4
)paren
op_ge
id|minlen
)paren
(brace
r_if
c_cond
(paren
id|cmd-&gt;request_bufflen
op_ge
id|minlen
op_logical_and
(paren
id|sid-&gt;spi3data
op_amp
id|SID_SPI_CLOCK_DT
)paren
op_eq
l_int|0
)paren
id|ppr_options
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|targ_info-&gt;curr.protocol_version
OG
id|SCSI_REV_2
)paren
id|targ_info-&gt;curr.transport_version
op_assign
l_int|3
suffix:semicolon
)brace
r_else
(brace
id|ppr_options
op_assign
l_int|0
suffix:semicolon
)brace
id|ahc_validate_width
c_func
(paren
id|ahc
comma
multiline_comment|/*tinfo limit*/
l_int|NULL
comma
op_amp
id|width
comma
id|ROLE_UNKNOWN
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_ULTRA2
)paren
op_ne
l_int|0
)paren
id|maxsync
op_assign
id|AHC_SYNCRATE_DT
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|ahc-&gt;features
op_amp
id|AHC_ULTRA
)paren
op_ne
l_int|0
)paren
id|maxsync
op_assign
id|AHC_SYNCRATE_ULTRA
suffix:semicolon
r_else
id|maxsync
op_assign
id|AHC_SYNCRATE_FAST
suffix:semicolon
id|syncrate
op_assign
id|ahc_find_syncrate
c_func
(paren
id|ahc
comma
op_amp
id|period
comma
op_amp
id|ppr_options
comma
id|maxsync
)paren
suffix:semicolon
id|ahc_validate_offset
c_func
(paren
id|ahc
comma
multiline_comment|/*tinfo limit*/
l_int|NULL
comma
id|syncrate
comma
op_amp
id|offset
comma
id|width
comma
id|ROLE_UNKNOWN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_eq
l_int|0
op_logical_or
id|period
op_eq
l_int|0
)paren
(brace
id|period
op_assign
l_int|0
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
id|ppr_options
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Apply our filtered user settings. */
id|ahc_set_width
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
comma
id|width
comma
id|AHC_TRANS_GOAL
comma
multiline_comment|/*paused*/
id|FALSE
)paren
suffix:semicolon
id|ahc_set_syncrate
c_func
(paren
id|ahc
comma
op_amp
id|devinfo
comma
id|syncrate
comma
id|period
comma
id|offset
comma
id|ppr_options
comma
id|AHC_TRANS_GOAL
comma
multiline_comment|/*paused*/
id|FALSE
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;ahc_linux_filter_command: Unexpected Command type  %x&bslash;n&quot;
comma
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|ahc_linux_sem_timeout
id|ahc_linux_sem_timeout
c_func
(paren
id|u_long
id|arg
)paren
(brace
r_struct
id|semaphore
op_star
id|sem
suffix:semicolon
id|sem
op_assign
(paren
r_struct
id|semaphore
op_star
)paren
id|arg
suffix:semicolon
id|up
c_func
(paren
id|sem
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahc_linux_freeze_sim_queue
id|ahc_linux_freeze_sim_queue
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
id|ahc-&gt;platform_data-&gt;qfrozen
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;platform_data-&gt;qfrozen
op_eq
l_int|1
)paren
id|scsi_block_requests
c_func
(paren
id|ahc-&gt;platform_data-&gt;host
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahc_linux_release_sim_queue
id|ahc_linux_release_sim_queue
c_func
(paren
id|u_long
id|arg
)paren
(brace
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
id|u_long
id|s
suffix:semicolon
r_int
id|unblock_reqs
suffix:semicolon
id|ahc
op_assign
(paren
r_struct
id|ahc_softc
op_star
)paren
id|arg
suffix:semicolon
id|unblock_reqs
op_assign
l_int|0
suffix:semicolon
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;platform_data-&gt;qfrozen
OG
l_int|0
)paren
id|ahc-&gt;platform_data-&gt;qfrozen
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|ahc-&gt;platform_data-&gt;qfrozen
op_eq
l_int|0
)paren
(brace
id|unblock_reqs
op_assign
l_int|1
suffix:semicolon
id|ahc_linux_run_device_queues
c_func
(paren
id|ahc
)paren
suffix:semicolon
)brace
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * There is still a race here.  The mid-layer&n;&t; * should keep its own freeze count and use&n;&t; * a bottom half handler to run the queues&n;&t; * so we can unblock with our own lock held.&n;&t; */
r_if
c_cond
(paren
id|unblock_reqs
)paren
id|scsi_unblock_requests
c_func
(paren
id|ahc-&gt;platform_data-&gt;host
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|ahc_linux_queue_recovery_cmd
id|ahc_linux_queue_recovery_cmd
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
comma
id|scb_flag
id|flag
)paren
(brace
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
r_struct
id|ahc_cmd
op_star
id|acmd
suffix:semicolon
r_struct
id|ahc_cmd
op_star
id|list_acmd
suffix:semicolon
r_struct
id|ahc_linux_device
op_star
id|dev
suffix:semicolon
r_struct
id|scb
op_star
id|pending_scb
suffix:semicolon
id|u_long
id|s
suffix:semicolon
id|u_int
id|saved_scbptr
suffix:semicolon
id|u_int
id|active_scb_index
suffix:semicolon
id|u_int
id|last_phase
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_int
id|paused
suffix:semicolon
r_int
id|wait
suffix:semicolon
r_int
id|disconnected
suffix:semicolon
id|paused
op_assign
id|FALSE
suffix:semicolon
id|wait
op_assign
id|FALSE
suffix:semicolon
id|ahc
op_assign
op_star
(paren
r_struct
id|ahc_softc
op_star
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
suffix:semicolon
id|acmd
op_assign
(paren
r_struct
id|ahc_cmd
op_star
)paren
id|cmd
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s:%d:%d:%d: Attempting to queue a%s message&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|cmd-&gt;channel
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
comma
id|flag
op_eq
id|SCB_ABORT
ques
c_cond
l_string|&quot;n ABORT&quot;
suffix:colon
l_string|&quot; TARGET RESET&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * It is a bug that the upper layer takes&n;&t; * this lock just prior to calling us.&n;&t; */
id|spin_unlock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * First determine if we currently own this command.&n;&t; * Start by searching the device queue.  If not found&n;&t; * there, check the pending_scb list.  If not found&n;&t; * at all, and the system wanted us to just abort the&n;&t; * command return success.&n;&t; */
id|dev
op_assign
id|ahc_linux_get_device
c_func
(paren
id|ahc
comma
id|cmd-&gt;channel
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
comma
multiline_comment|/*alloc*/
id|FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * No target device for this command exists,&n;&t;&t; * so we must not still own the command.&n;&t;&t; */
id|printf
c_func
(paren
l_string|&quot;%s:%d:%d:%d: Is not an active device&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|cmd-&gt;channel
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
id|retval
op_assign
id|SUCCESS
suffix:semicolon
r_goto
id|no_cmd
suffix:semicolon
)brace
id|TAILQ_FOREACH
c_func
(paren
id|list_acmd
comma
op_amp
id|dev-&gt;busyq
comma
id|acmd_links.tqe
)paren
(brace
r_if
c_cond
(paren
id|list_acmd
op_eq
id|acmd
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|list_acmd
op_ne
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s:%d:%d:%d: Command found on device queue&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|cmd-&gt;channel
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_eq
id|SCB_ABORT
)paren
(brace
id|TAILQ_REMOVE
c_func
(paren
op_amp
id|dev-&gt;busyq
comma
id|list_acmd
comma
id|acmd_links.tqe
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
id|ahc_linux_queue_cmd_complete
c_func
(paren
id|ahc
comma
id|cmd
)paren
suffix:semicolon
id|retval
op_assign
id|SUCCESS
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * See if we can find a matching cmd in the pending list.&n;&t; */
id|LIST_FOREACH
c_func
(paren
id|pending_scb
comma
op_amp
id|ahc-&gt;pending_scbs
comma
id|pending_links
)paren
(brace
r_if
c_cond
(paren
id|pending_scb-&gt;io_ctx
op_eq
id|cmd
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pending_scb
op_eq
l_int|NULL
op_logical_and
id|flag
op_eq
id|SCB_DEVICE_RESET
)paren
(brace
multiline_comment|/* Any SCB for this device will do for a target reset */
id|LIST_FOREACH
c_func
(paren
id|pending_scb
comma
op_amp
id|ahc-&gt;pending_scbs
comma
id|pending_links
)paren
(brace
r_if
c_cond
(paren
id|ahc_match_scb
c_func
(paren
id|ahc
comma
id|pending_scb
comma
id|cmd-&gt;target
comma
id|cmd-&gt;channel
comma
id|CAM_LUN_WILDCARD
comma
id|SCB_LIST_NULL
comma
id|ROLE_INITIATOR
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|pending_scb
op_eq
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s:%d:%d:%d: Command not found&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|cmd-&gt;channel
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
r_goto
id|no_cmd
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|pending_scb-&gt;flags
op_amp
id|SCB_RECOVERY_SCB
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * We can&squot;t queue two recovery actions using the same SCB&n;&t;&t; */
id|retval
op_assign
id|FAILED
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Ensure that the card doesn&squot;t do anything&n;&t; * behind our back.  Also make sure that we&n;&t; * didn&squot;t &quot;just&quot; miss an interrupt that would&n;&t; * affect this cmd.&n;&t; */
id|ahc-&gt;flags
op_or_assign
id|AHC_ALL_INTERRUPTS
suffix:semicolon
r_do
(brace
id|ahc_intr
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_pause
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|ahc_clear_critical_section
c_func
(paren
id|ahc
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ahc_inb
c_func
(paren
id|ahc
comma
id|INTSTAT
)paren
op_amp
id|INT_PEND
)paren
suffix:semicolon
id|ahc-&gt;flags
op_and_assign
op_complement
id|AHC_ALL_INTERRUPTS
suffix:semicolon
id|paused
op_assign
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
)paren
id|ahc_dump_card_state
c_func
(paren
id|ahc
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pending_scb-&gt;flags
op_amp
id|SCB_ACTIVE
)paren
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s:%d:%d:%d: Command already completed&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|cmd-&gt;channel
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
r_goto
id|no_cmd
suffix:semicolon
)brace
id|disconnected
op_assign
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_eq
id|SCB_ABORT
)paren
(brace
r_if
c_cond
(paren
id|ahc_search_qinfifo
c_func
(paren
id|ahc
comma
id|cmd-&gt;target
comma
id|cmd-&gt;channel
op_plus
l_char|&squot;A&squot;
comma
id|cmd-&gt;lun
comma
id|pending_scb-&gt;hscb-&gt;tag
comma
id|ROLE_INITIATOR
comma
id|CAM_REQ_ABORTED
comma
id|SEARCH_COMPLETE
)paren
OG
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s:%d:%d:%d: Cmd aborted from QINFIFO&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|cmd-&gt;channel
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
id|retval
op_assign
id|SUCCESS
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|ahc_search_qinfifo
c_func
(paren
id|ahc
comma
id|cmd-&gt;target
comma
id|cmd-&gt;channel
op_plus
l_char|&squot;A&squot;
comma
id|cmd-&gt;lun
comma
id|pending_scb-&gt;hscb-&gt;tag
comma
id|ROLE_INITIATOR
comma
multiline_comment|/*status*/
l_int|0
comma
id|SEARCH_COUNT
)paren
OG
l_int|0
)paren
(brace
id|disconnected
op_assign
id|FALSE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * At this point, pending_scb is the scb associated with the&n;&t; * passed in command.  That command is currently active on the&n;&t; * bus, is in the disconnected state, or we&squot;re hoping to find&n;&t; * a command for the same target active on the bus to abuse to&n;&t; * send a BDR.  Queue the appropriate message based on which of&n;&t; * these states we are in.&n;&t; */
id|last_phase
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|LASTPHASE
)paren
suffix:semicolon
id|saved_scbptr
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCBPTR
)paren
suffix:semicolon
id|active_scb_index
op_assign
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_TAG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last_phase
op_ne
id|P_BUSFREE
op_logical_and
(paren
id|pending_scb-&gt;hscb-&gt;tag
op_eq
id|active_scb_index
op_logical_or
(paren
id|flag
op_eq
id|SCB_DEVICE_RESET
op_logical_and
id|SCSIID_TARGET
c_func
(paren
id|ahc
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SAVED_SCSIID
)paren
)paren
op_eq
id|cmd-&gt;target
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * We&squot;re active on the bus, so assert ATN&n;&t;&t; * and hope that the target responds.&n;&t;&t; */
id|pending_scb
op_assign
id|ahc_lookup_scb
c_func
(paren
id|ahc
comma
id|active_scb_index
)paren
suffix:semicolon
id|pending_scb-&gt;flags
op_or_assign
id|SCB_RECOVERY_SCB
op_or
id|flag
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|MSG_OUT
comma
id|HOST_MSG
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCSISIGO
comma
id|last_phase
op_or
id|ATNO
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s:%d:%d:%d: Device is active, asserting ATN&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|cmd-&gt;channel
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
id|wait
op_assign
id|TRUE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|disconnected
)paren
(brace
multiline_comment|/*&n;&t;&t; * Actually re-queue this SCB in an attempt&n;&t;&t; * to select the device before it reconnects.&n;&t;&t; * In either case (selection or reselection),&n;&t;&t; * we will now issue a the approprate message&n;&t;&t; * to the timed-out device.&n;&t;&t; *&n;&t;&t; * Set the MK_MESSAGE control bit indicating&n;&t;&t; * that we desire to send a message.  We&n;&t;&t; * also set the disconnected flag since&n;&t;&t; * in the paging case there is no guarantee&n;&t;&t; * that our SCB control byte matches the&n;&t;&t; * version on the card.  We don&squot;t want the&n;&t;&t; * sequencer to abort the command thinking&n;&t;&t; * an unsolicited reselection occurred.&n;&t;&t; */
id|pending_scb-&gt;hscb-&gt;control
op_or_assign
id|MK_MESSAGE
op_or
id|DISCONNECTED
suffix:semicolon
id|pending_scb-&gt;flags
op_or_assign
id|SCB_RECOVERY_SCB
op_or
id|flag
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Remove any cached copy of this SCB in the&n;&t;&t; * disconnected list in preparation for the&n;&t;&t; * queuing of our abort SCB.  We use the&n;&t;&t; * same element in the SCB, SCB_NEXT, for&n;&t;&t; * both the qinfifo and the disconnected list.&n;&t;&t; */
id|ahc_search_disc_list
c_func
(paren
id|ahc
comma
id|cmd-&gt;target
comma
id|cmd-&gt;channel
op_plus
l_char|&squot;A&squot;
comma
id|cmd-&gt;lun
comma
id|pending_scb-&gt;hscb-&gt;tag
comma
multiline_comment|/*stop_on_first*/
id|TRUE
comma
multiline_comment|/*remove*/
id|TRUE
comma
multiline_comment|/*save_state*/
id|FALSE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * In the non-paging case, the sequencer will&n;&t;&t; * never re-reference the in-core SCB.&n;&t;&t; * To make sure we are notified during&n;&t;&t; * reslection, set the MK_MESSAGE flag in&n;&t;&t; * the card&squot;s copy of the SCB.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ahc-&gt;flags
op_amp
id|AHC_PAGESCBS
)paren
op_eq
l_int|0
)paren
(brace
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBPTR
comma
id|pending_scb-&gt;hscb-&gt;tag
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCB_CONTROL
comma
id|ahc_inb
c_func
(paren
id|ahc
comma
id|SCB_CONTROL
)paren
op_or
id|MK_MESSAGE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Clear out any entries in the QINFIFO first&n;&t;&t; * so we are the next SCB for this target&n;&t;&t; * to run.&n;&t;&t; */
id|ahc_search_qinfifo
c_func
(paren
id|ahc
comma
id|cmd-&gt;target
comma
id|cmd-&gt;channel
op_plus
l_char|&squot;A&squot;
comma
id|cmd-&gt;lun
comma
id|SCB_LIST_NULL
comma
id|ROLE_INITIATOR
comma
id|CAM_REQUEUE_REQ
comma
id|SEARCH_COMPLETE
)paren
suffix:semicolon
id|ahc_print_path
c_func
(paren
id|ahc
comma
id|pending_scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Queuing a recovery SCB&bslash;n&quot;
)paren
suffix:semicolon
id|ahc_qinfifo_requeue_tail
c_func
(paren
id|ahc
comma
id|pending_scb
)paren
suffix:semicolon
id|ahc_outb
c_func
(paren
id|ahc
comma
id|SCBPTR
comma
id|saved_scbptr
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s:%d:%d:%d: Device is disconnected, re-queuing SCB&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|cmd-&gt;channel
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
id|wait
op_assign
id|TRUE
suffix:semicolon
)brace
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;%s:%d:%d:%d: Unable to deliver message&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|cmd-&gt;channel
comma
id|cmd-&gt;target
comma
id|cmd-&gt;lun
)paren
suffix:semicolon
id|retval
op_assign
id|FAILED
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|no_cmd
suffix:colon
multiline_comment|/*&n;&t; * Our assumption is that if we don&squot;t have the command, no&n;&t; * recovery action was required, so we return success.  Again,&n;&t; * the semantics of the mid-layer recovery engine are not&n;&t; * well defined, so this may change in time.&n;&t; */
id|retval
op_assign
id|SUCCESS
suffix:semicolon
id|done
suffix:colon
r_if
c_cond
(paren
id|paused
)paren
id|ahc_unpause
c_func
(paren
id|ahc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait
)paren
(brace
r_struct
id|timer_list
id|timer
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|timer
)paren
suffix:semicolon
id|timer.data
op_assign
(paren
id|u_long
)paren
op_amp
id|ahc-&gt;platform_data-&gt;eh_sem
suffix:semicolon
id|timer.expires
op_assign
id|jiffies
op_plus
(paren
l_int|5
op_star
id|HZ
)paren
suffix:semicolon
id|timer.function
op_assign
id|ahc_linux_sem_timeout
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|timer
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Recovery code sleeping&bslash;n&quot;
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;eh_sem
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Recovery code awake&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|del_timer
c_func
(paren
op_amp
id|timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Timer Expired&bslash;n&quot;
)paren
suffix:semicolon
id|retval
op_assign
id|FAILED
suffix:semicolon
)brace
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
)brace
id|ahc_linux_run_device_queues
c_func
(paren
id|ahc
)paren
suffix:semicolon
id|acmd
op_assign
id|TAILQ_FIRST
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;completeq
)paren
suffix:semicolon
id|TAILQ_INIT
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;completeq
)paren
suffix:semicolon
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acmd
op_ne
l_int|NULL
)paren
id|ahc_linux_run_complete_queue
c_func
(paren
id|ahc
comma
id|acmd
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
r_return
(paren
id|retval
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Abort the current SCSI command(s).&n; */
r_int
DECL|function|ahc_linux_abort
id|ahc_linux_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|error
suffix:semicolon
id|error
op_assign
id|ahc_linux_queue_recovery_cmd
c_func
(paren
id|cmd
comma
id|SCB_ABORT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;aic7xxx_abort returns %d&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Attempt to send a target reset message to the device that timed out.&n; */
r_int
DECL|function|ahc_linux_dev_reset
id|ahc_linux_dev_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_int
id|error
suffix:semicolon
id|error
op_assign
id|ahc_linux_queue_recovery_cmd
c_func
(paren
id|cmd
comma
id|SCB_DEVICE_RESET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;aic7xxx_dev_reset returns %d&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Reset the SCSI bus.&n; */
r_int
DECL|function|ahc_linux_bus_reset
id|ahc_linux_bus_reset
c_func
(paren
id|Scsi_Cmnd
op_star
id|cmd
)paren
(brace
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
r_struct
id|ahc_cmd
op_star
id|acmd
suffix:semicolon
id|u_long
id|s
suffix:semicolon
r_int
id|found
suffix:semicolon
multiline_comment|/*&n;&t; * It is a bug that the upper layer takes&n;&t; * this lock just prior to calling us.&n;&t; */
id|spin_unlock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
id|ahc
op_assign
op_star
(paren
r_struct
id|ahc_softc
op_star
op_star
)paren
id|cmd-&gt;host-&gt;hostdata
suffix:semicolon
id|ahc_lock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
id|found
op_assign
id|ahc_reset_channel
c_func
(paren
id|ahc
comma
id|cmd-&gt;channel
op_plus
l_char|&squot;A&squot;
comma
multiline_comment|/*initiate reset*/
id|TRUE
)paren
suffix:semicolon
id|acmd
op_assign
id|TAILQ_FIRST
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;completeq
)paren
suffix:semicolon
id|TAILQ_INIT
c_func
(paren
op_amp
id|ahc-&gt;platform_data-&gt;completeq
)paren
suffix:semicolon
id|ahc_unlock
c_func
(paren
id|ahc
comma
op_amp
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
)paren
id|printf
c_func
(paren
l_string|&quot;%s: SCSI bus reset delivered. &quot;
l_string|&quot;%d SCBs aborted.&bslash;n&quot;
comma
id|ahc_name
c_func
(paren
id|ahc
)paren
comma
id|found
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acmd
op_ne
l_int|NULL
)paren
id|ahc_linux_run_complete_queue
c_func
(paren
id|ahc
comma
id|acmd
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n; * Return the disk geometry for the given SCSI device.&n; */
r_int
DECL|function|ahc_linux_biosparam
id|ahc_linux_biosparam
c_func
(paren
id|Disk
op_star
id|disk
comma
id|kdev_t
id|dev
comma
r_int
id|geom
(braket
)braket
)paren
(brace
r_int
id|heads
suffix:semicolon
r_int
id|sectors
suffix:semicolon
r_int
id|cylinders
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|extended
suffix:semicolon
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|ahc
op_assign
op_star
(paren
(paren
r_struct
id|ahc_softc
op_star
op_star
)paren
id|disk-&gt;device-&gt;host-&gt;hostdata
)paren
suffix:semicolon
id|bh
op_assign
id|bread
c_func
(paren
id|MKDEV
c_func
(paren
id|MAJOR
c_func
(paren
id|dev
)paren
comma
id|MINOR
c_func
(paren
id|dev
)paren
op_amp
op_complement
l_int|0xf
)paren
comma
l_int|0
comma
l_int|1024
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh
)paren
(brace
id|ret
op_assign
id|scsi_partsize
c_func
(paren
id|bh
comma
id|disk-&gt;capacity
comma
op_amp
id|geom
(braket
l_int|2
)braket
comma
op_amp
id|geom
(braket
l_int|0
)braket
comma
op_amp
id|geom
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
op_minus
l_int|1
)paren
r_return
(paren
id|ret
)paren
suffix:semicolon
)brace
id|heads
op_assign
l_int|64
suffix:semicolon
id|sectors
op_assign
l_int|32
suffix:semicolon
id|cylinders
op_assign
id|disk-&gt;capacity
op_div
(paren
id|heads
op_star
id|sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|disk-&gt;device-&gt;channel
op_eq
l_int|0
)paren
id|extended
op_assign
(paren
id|ahc-&gt;flags
op_amp
id|AHC_EXTENDED_TRANS_A
)paren
op_ne
l_int|0
suffix:semicolon
r_else
id|extended
op_assign
(paren
id|ahc-&gt;flags
op_amp
id|AHC_EXTENDED_TRANS_B
)paren
op_ne
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|extended
op_logical_and
id|cylinders
op_ge
l_int|1024
)paren
(brace
id|heads
op_assign
l_int|255
suffix:semicolon
id|sectors
op_assign
l_int|63
suffix:semicolon
id|cylinders
op_assign
id|disk-&gt;capacity
op_div
(paren
id|heads
op_star
id|sectors
)paren
suffix:semicolon
)brace
id|geom
(braket
l_int|0
)braket
op_assign
id|heads
suffix:semicolon
id|geom
(braket
l_int|1
)braket
op_assign
id|sectors
suffix:semicolon
id|geom
(braket
l_int|2
)braket
op_assign
id|cylinders
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Free the passed in Scsi_Host memory structures prior to unloading the&n; * module.&n; */
r_int
DECL|function|ahc_linux_release
id|ahc_linux_release
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_struct
id|ahc_softc
op_star
id|ahc
suffix:semicolon
r_if
c_cond
(paren
id|host
op_ne
l_int|NULL
)paren
(brace
id|ahc
op_assign
op_star
(paren
r_struct
id|ahc_softc
op_star
op_star
)paren
id|host-&gt;hostdata
suffix:semicolon
id|ahc_free
c_func
(paren
id|ahc
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TAILQ_EMPTY
c_func
(paren
op_amp
id|ahc_tailq
)paren
)paren
(brace
id|unregister_reboot_notifier
c_func
(paren
op_amp
id|ahc_linux_notifier
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PCI
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,4,0)
id|pci_unregister_driver
c_func
(paren
op_amp
id|aic7xxx_pci_driver
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahc_platform_dump_card_state
id|ahc_platform_dump_card_state
c_func
(paren
r_struct
id|ahc_softc
op_star
id|ahc
)paren
(brace
r_struct
id|ahc_linux_device
op_star
id|dev
suffix:semicolon
r_int
id|channel
suffix:semicolon
r_int
id|maxchannel
suffix:semicolon
r_int
id|target
suffix:semicolon
r_int
id|maxtarget
suffix:semicolon
r_int
id|lun
suffix:semicolon
r_int
id|i
suffix:semicolon
id|maxchannel
op_assign
(paren
id|ahc-&gt;features
op_amp
id|AHC_TWIN
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|maxtarget
op_assign
(paren
id|ahc-&gt;features
op_amp
id|AHC_WIDE
)paren
ques
c_cond
l_int|15
suffix:colon
l_int|7
suffix:semicolon
r_for
c_loop
(paren
id|channel
op_assign
l_int|0
suffix:semicolon
id|channel
op_le
id|maxchannel
suffix:semicolon
id|channel
op_increment
)paren
(brace
r_for
c_loop
(paren
id|target
op_assign
l_int|0
suffix:semicolon
id|target
op_le
id|maxtarget
suffix:semicolon
id|target
op_increment
)paren
(brace
r_for
c_loop
(paren
id|lun
op_assign
l_int|0
suffix:semicolon
id|lun
OL
id|AHC_NUM_LUNS
suffix:semicolon
id|lun
op_increment
)paren
(brace
r_struct
id|ahc_cmd
op_star
id|acmd
suffix:semicolon
id|dev
op_assign
id|ahc_linux_get_device
c_func
(paren
id|ahc
comma
id|channel
comma
id|target
comma
id|lun
comma
multiline_comment|/*alloc*/
id|FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;DevQ(%d:%d:%d): &quot;
comma
id|channel
comma
id|target
comma
id|lun
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
id|TAILQ_FOREACH
c_func
(paren
id|acmd
comma
op_amp
id|dev-&gt;busyq
comma
id|acmd_links.tqe
)paren
(brace
r_if
c_cond
(paren
id|i
op_increment
OG
l_int|256
)paren
r_break
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;%d waiting&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
macro_line|#if defined(MODULE) || LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,4,0)
DECL|variable|driver_template
r_static
id|Scsi_Host_Template
id|driver_template
op_assign
id|AIC7XXX
suffix:semicolon
DECL|variable|aic7xxx_driver_template
id|Scsi_Host_Template
op_star
id|aic7xxx_driver_template
op_assign
op_amp
id|driver_template
suffix:semicolon
macro_line|#include &quot;../scsi_module.c&quot;
macro_line|#endif
eof
