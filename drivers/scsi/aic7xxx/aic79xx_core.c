multiline_comment|/*&n; * Core routines and tables shareable across OS platforms.&n; *&n; * Copyright (c) 1994-2002 Justin T. Gibbs.&n; * Copyright (c) 2000-2003 Adaptec Inc.&n; * All rights reserved.&n; *&n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions&n; * are met:&n; * 1. Redistributions of source code must retain the above copyright&n; *    notice, this list of conditions, and the following disclaimer,&n; *    without modification.&n; * 2. Redistributions in binary form must reproduce at minimum a disclaimer&n; *    substantially similar to the &quot;NO WARRANTY&quot; disclaimer below&n; *    (&quot;Disclaimer&quot;) and any redistribution must be conditioned upon&n; *    including a substantially similar Disclaimer requirement for further&n; *    binary redistribution.&n; * 3. Neither the names of the above-listed copyright holders nor the names&n; *    of any contributors may be used to endorse or promote products derived&n; *    from this software without specific prior written permission.&n; *&n; * Alternatively, this software may be distributed under the terms of the&n; * GNU General Public License (&quot;GPL&quot;) version 2 as published by the Free&n; * Software Foundation.&n; *&n; * NO WARRANTY&n; * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS&n; * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT&n; * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR&n; * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT&n; * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL&n; * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS&n; * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)&n; * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,&n; * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING&n; * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE&n; * POSSIBILITY OF SUCH DAMAGES.&n; *&n; * $Id: //depot/aic7xxx/aic7xxx/aic79xx.c#161 $&n; *&n; * $FreeBSD$&n; */
macro_line|#ifdef __linux__
macro_line|#include &quot;aic79xx_osm.h&quot;
macro_line|#include &quot;aic79xx_inline.h&quot;
macro_line|#include &quot;aicasm/aicasm_insformat.h&quot;
macro_line|#else
macro_line|#include &lt;dev/aic7xxx/aic79xx_osm.h&gt;
macro_line|#include &lt;dev/aic7xxx/aic79xx_inline.h&gt;
macro_line|#include &lt;dev/aic7xxx/aicasm/aicasm_insformat.h&gt;
macro_line|#endif
multiline_comment|/******************************** Globals *************************************/
DECL|variable|ahd_tailq
r_struct
id|ahd_softc_tailq
id|ahd_tailq
op_assign
id|TAILQ_HEAD_INITIALIZER
c_func
(paren
id|ahd_tailq
)paren
suffix:semicolon
multiline_comment|/***************************** Lookup Tables **********************************/
DECL|variable|ahd_chip_names
r_char
op_star
id|ahd_chip_names
(braket
)braket
op_assign
(brace
l_string|&quot;NONE&quot;
comma
l_string|&quot;aic7901&quot;
comma
l_string|&quot;aic7902&quot;
comma
l_string|&quot;aic7901A&quot;
)brace
suffix:semicolon
DECL|variable|num_chip_names
r_static
r_const
id|u_int
id|num_chip_names
op_assign
id|NUM_ELEMENTS
c_func
(paren
id|ahd_chip_names
)paren
suffix:semicolon
multiline_comment|/*&n; * Hardware error codes.&n; */
DECL|struct|ahd_hard_error_entry
r_struct
id|ahd_hard_error_entry
(brace
DECL|member|errno
r_uint8
id|errno
suffix:semicolon
DECL|member|errmesg
r_char
op_star
id|errmesg
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|ahd_hard_errors
r_static
r_struct
id|ahd_hard_error_entry
id|ahd_hard_errors
(braket
)braket
op_assign
(brace
(brace
id|DSCTMOUT
comma
l_string|&quot;Discard Timer has timed out&quot;
)brace
comma
(brace
id|ILLOPCODE
comma
l_string|&quot;Illegal Opcode in sequencer program&quot;
)brace
comma
(brace
id|SQPARERR
comma
l_string|&quot;Sequencer Parity Error&quot;
)brace
comma
(brace
id|DPARERR
comma
l_string|&quot;Data-path Parity Error&quot;
)brace
comma
(brace
id|MPARERR
comma
l_string|&quot;Scratch or SCB Memory Parity Error&quot;
)brace
comma
(brace
id|CIOPARERR
comma
l_string|&quot;CIOBUS Parity Error&quot;
)brace
comma
)brace
suffix:semicolon
DECL|variable|num_errors
r_static
r_const
id|u_int
id|num_errors
op_assign
id|NUM_ELEMENTS
c_func
(paren
id|ahd_hard_errors
)paren
suffix:semicolon
DECL|variable|ahd_phase_table
r_static
r_struct
id|ahd_phase_table_entry
id|ahd_phase_table
(braket
)braket
op_assign
(brace
(brace
id|P_DATAOUT
comma
id|MSG_NOOP
comma
l_string|&quot;in Data-out phase&quot;
)brace
comma
(brace
id|P_DATAIN
comma
id|MSG_INITIATOR_DET_ERR
comma
l_string|&quot;in Data-in phase&quot;
)brace
comma
(brace
id|P_DATAOUT_DT
comma
id|MSG_NOOP
comma
l_string|&quot;in DT Data-out phase&quot;
)brace
comma
(brace
id|P_DATAIN_DT
comma
id|MSG_INITIATOR_DET_ERR
comma
l_string|&quot;in DT Data-in phase&quot;
)brace
comma
(brace
id|P_COMMAND
comma
id|MSG_NOOP
comma
l_string|&quot;in Command phase&quot;
)brace
comma
(brace
id|P_MESGOUT
comma
id|MSG_NOOP
comma
l_string|&quot;in Message-out phase&quot;
)brace
comma
(brace
id|P_STATUS
comma
id|MSG_INITIATOR_DET_ERR
comma
l_string|&quot;in Status phase&quot;
)brace
comma
(brace
id|P_MESGIN
comma
id|MSG_PARITY_ERROR
comma
l_string|&quot;in Message-in phase&quot;
)brace
comma
(brace
id|P_BUSFREE
comma
id|MSG_NOOP
comma
l_string|&quot;while idle&quot;
)brace
comma
(brace
l_int|0
comma
id|MSG_NOOP
comma
l_string|&quot;in unknown phase&quot;
)brace
)brace
suffix:semicolon
multiline_comment|/*&n; * In most cases we only wish to itterate over real phases, so&n; * exclude the last element from the count.&n; */
DECL|variable|num_phases
r_static
r_const
id|u_int
id|num_phases
op_assign
id|NUM_ELEMENTS
c_func
(paren
id|ahd_phase_table
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Our Sequencer Program */
macro_line|#include &quot;aic79xx_seq.h&quot;
multiline_comment|/**************************** Function Declarations ***************************/
r_static
r_void
id|ahd_handle_transmission_error
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
suffix:semicolon
r_static
r_void
id|ahd_handle_lqiphase_error
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
id|u_int
id|lqistat1
)paren
suffix:semicolon
r_static
r_int
id|ahd_handle_pkt_busfree
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
id|u_int
id|busfreetime
)paren
suffix:semicolon
r_static
r_int
id|ahd_handle_nonpkt_busfree
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
suffix:semicolon
r_static
r_void
id|ahd_handle_proto_violation
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
suffix:semicolon
r_static
r_void
id|ahd_force_renegotiation
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_devinfo
op_star
id|devinfo
)paren
suffix:semicolon
r_static
r_struct
id|ahd_tmode_tstate
op_star
id|ahd_alloc_tstate
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
id|u_int
id|scsi_id
comma
r_char
id|channel
)paren
suffix:semicolon
macro_line|#ifdef AHD_TARGET_MODE
r_static
r_void
id|ahd_free_tstate
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
id|u_int
id|scsi_id
comma
r_char
id|channel
comma
r_int
id|force
)paren
suffix:semicolon
macro_line|#endif
r_static
r_void
id|ahd_devlimited_syncrate
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_initiator_tinfo
op_star
comma
id|u_int
op_star
id|period
comma
id|u_int
op_star
id|ppr_options
comma
id|role_t
id|role
)paren
suffix:semicolon
r_static
r_void
id|ahd_update_neg_table
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_devinfo
op_star
id|devinfo
comma
r_struct
id|ahd_transinfo
op_star
id|tinfo
)paren
suffix:semicolon
r_static
r_void
id|ahd_update_pending_scbs
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
suffix:semicolon
r_static
r_void
id|ahd_fetch_devinfo
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_devinfo
op_star
id|devinfo
)paren
suffix:semicolon
r_static
r_void
id|ahd_scb_devinfo
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_devinfo
op_star
id|devinfo
comma
r_struct
id|scb
op_star
id|scb
)paren
suffix:semicolon
r_static
r_void
id|ahd_setup_initiator_msgout
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_devinfo
op_star
id|devinfo
comma
r_struct
id|scb
op_star
id|scb
)paren
suffix:semicolon
r_static
r_void
id|ahd_build_transfer_msg
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_devinfo
op_star
id|devinfo
)paren
suffix:semicolon
r_static
r_void
id|ahd_construct_sdtr
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_devinfo
op_star
id|devinfo
comma
id|u_int
id|period
comma
id|u_int
id|offset
)paren
suffix:semicolon
r_static
r_void
id|ahd_construct_wdtr
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_devinfo
op_star
id|devinfo
comma
id|u_int
id|bus_width
)paren
suffix:semicolon
r_static
r_void
id|ahd_construct_ppr
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_devinfo
op_star
id|devinfo
comma
id|u_int
id|period
comma
id|u_int
id|offset
comma
id|u_int
id|bus_width
comma
id|u_int
id|ppr_options
)paren
suffix:semicolon
r_static
r_void
id|ahd_clear_msg_state
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
suffix:semicolon
r_static
r_void
id|ahd_handle_message_phase
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
suffix:semicolon
r_typedef
r_enum
(brace
DECL|enumerator|AHDMSG_1B
id|AHDMSG_1B
comma
DECL|enumerator|AHDMSG_2B
id|AHDMSG_2B
comma
DECL|enumerator|AHDMSG_EXT
id|AHDMSG_EXT
DECL|typedef|ahd_msgtype
)brace
id|ahd_msgtype
suffix:semicolon
r_static
r_int
id|ahd_sent_msg
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
id|ahd_msgtype
id|type
comma
id|u_int
id|msgval
comma
r_int
id|full
)paren
suffix:semicolon
r_static
r_int
id|ahd_parse_msg
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_devinfo
op_star
id|devinfo
)paren
suffix:semicolon
r_static
r_int
id|ahd_handle_msg_reject
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_devinfo
op_star
id|devinfo
)paren
suffix:semicolon
r_static
r_void
id|ahd_handle_ign_wide_residue
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_devinfo
op_star
id|devinfo
)paren
suffix:semicolon
r_static
r_void
id|ahd_reinitialize_dataptrs
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
suffix:semicolon
r_static
r_void
id|ahd_handle_devreset
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_devinfo
op_star
id|devinfo
comma
id|u_int
id|lun
comma
id|cam_status
id|status
comma
r_char
op_star
id|message
comma
r_int
id|verbose_level
)paren
suffix:semicolon
macro_line|#if AHD_TARGET_MODE
r_static
r_void
id|ahd_setup_target_msgin
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_devinfo
op_star
id|devinfo
comma
r_struct
id|scb
op_star
id|scb
)paren
suffix:semicolon
macro_line|#endif
r_static
id|u_int
id|ahd_sglist_size
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
suffix:semicolon
r_static
id|u_int
id|ahd_sglist_allocsize
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
suffix:semicolon
r_static
id|bus_dmamap_callback_t
DECL|variable|ahd_dmamap_cb
id|ahd_dmamap_cb
suffix:semicolon
r_static
r_void
id|ahd_initialize_hscbs
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
suffix:semicolon
r_static
r_int
id|ahd_init_scbdata
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
suffix:semicolon
r_static
r_void
id|ahd_fini_scbdata
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
suffix:semicolon
r_static
r_void
id|ahd_setup_iocell_workaround
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
suffix:semicolon
r_static
r_void
id|ahd_iocell_first_selection
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
suffix:semicolon
r_static
r_void
id|ahd_add_col_list
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|scb
op_star
id|scb
comma
id|u_int
id|col_idx
)paren
suffix:semicolon
r_static
r_void
id|ahd_rem_col_list
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|scb
op_star
id|scb
)paren
suffix:semicolon
r_static
r_void
id|ahd_chip_init
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
suffix:semicolon
r_static
r_void
id|ahd_qinfifo_requeue
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|scb
op_star
id|prev_scb
comma
r_struct
id|scb
op_star
id|scb
)paren
suffix:semicolon
r_static
r_int
id|ahd_qinfifo_count
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
suffix:semicolon
r_static
r_int
id|ahd_search_scb_list
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_int
id|target
comma
r_char
id|channel
comma
r_int
id|lun
comma
id|u_int
id|tag
comma
id|role_t
id|role
comma
r_uint32
id|status
comma
id|ahd_search_action
id|action
comma
id|u_int
op_star
id|list_head
comma
id|u_int
id|tid
)paren
suffix:semicolon
r_static
r_void
id|ahd_stitch_tid_list
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
id|u_int
id|tid_prev
comma
id|u_int
id|tid_cur
comma
id|u_int
id|tid_next
)paren
suffix:semicolon
r_static
r_void
id|ahd_add_scb_to_free_list
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
id|u_int
id|scbid
)paren
suffix:semicolon
r_static
id|u_int
id|ahd_rem_wscb
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
id|u_int
id|scbid
comma
id|u_int
id|prev
comma
id|u_int
id|next
comma
id|u_int
id|tid
)paren
suffix:semicolon
r_static
r_void
id|ahd_reset_current_bus
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
suffix:semicolon
DECL|variable|ahd_reset_poll
r_static
id|ahd_callback_t
id|ahd_reset_poll
suffix:semicolon
DECL|variable|ahd_stat_timer
r_static
id|ahd_callback_t
id|ahd_stat_timer
suffix:semicolon
macro_line|#ifdef AHD_DUMP_SEQ
r_static
r_void
id|ahd_dumpseq
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
suffix:semicolon
macro_line|#endif
r_static
r_void
id|ahd_loadseq
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
suffix:semicolon
r_static
r_int
id|ahd_check_patch
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|patch
op_star
op_star
id|start_patch
comma
id|u_int
id|start_instr
comma
id|u_int
op_star
id|skip_addr
)paren
suffix:semicolon
r_static
id|u_int
id|ahd_resolve_seqaddr
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
id|u_int
id|address
)paren
suffix:semicolon
r_static
r_void
id|ahd_download_instr
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
id|u_int
id|instrptr
comma
r_uint8
op_star
id|dconsts
)paren
suffix:semicolon
r_static
r_int
id|ahd_probe_stack_size
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
suffix:semicolon
macro_line|#ifdef AHD_TARGET_MODE
r_static
r_void
id|ahd_queue_lstate_event
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_tmode_lstate
op_star
id|lstate
comma
id|u_int
id|initiator_id
comma
id|u_int
id|event_type
comma
id|u_int
id|event_arg
)paren
suffix:semicolon
r_static
r_void
id|ahd_update_scsiid
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
id|u_int
id|targid_mask
)paren
suffix:semicolon
r_static
r_int
id|ahd_handle_target_cmd
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|target_cmd
op_star
id|cmd
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/******************************** Private Inlines *****************************/
r_static
id|__inline
r_void
id|ahd_assert_atn
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
suffix:semicolon
r_static
id|__inline
r_int
id|ahd_currently_packetized
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
suffix:semicolon
r_static
id|__inline
r_int
id|ahd_set_active_fifo
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
suffix:semicolon
r_static
id|__inline
r_void
DECL|function|ahd_assert_atn
id|ahd_assert_atn
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCSISIGO
comma
id|ATNO
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Determine if the current connection has a packetized&n; * agreement.  This does not necessarily mean that we&n; * are currently in a packetized transfer.  We could&n; * just as easily be sending or receiving a message.&n; */
r_static
id|__inline
r_int
DECL|function|ahd_currently_packetized
id|ahd_currently_packetized
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
id|ahd_mode_state
id|saved_modes
suffix:semicolon
r_int
id|packetized
suffix:semicolon
id|saved_modes
op_assign
id|ahd_save_modes
c_func
(paren
id|ahd
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;bugs
op_amp
id|AHD_PKTIZED_STATUS_BUG
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * The packetized bit refers to the last&n;&t;&t; * connection, not the current one.  Check&n;&t;&t; * for non-zero LQISTATE instead.&n;&t;&t; */
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_CFG
comma
id|AHD_MODE_CFG
)paren
suffix:semicolon
id|packetized
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LQISTATE
)paren
op_ne
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI
comma
id|AHD_MODE_SCSI
)paren
suffix:semicolon
id|packetized
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LQISTAT2
)paren
op_amp
id|PACKETIZED
suffix:semicolon
)brace
id|ahd_restore_modes
c_func
(paren
id|ahd
comma
id|saved_modes
)paren
suffix:semicolon
r_return
(paren
id|packetized
)paren
suffix:semicolon
)brace
r_static
id|__inline
r_int
DECL|function|ahd_set_active_fifo
id|ahd_set_active_fifo
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
id|u_int
id|active_fifo
suffix:semicolon
id|AHD_ASSERT_MODES
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI_MSK
comma
id|AHD_MODE_SCSI_MSK
)paren
suffix:semicolon
id|active_fifo
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|DFFSTAT
)paren
op_amp
id|CURRFIFO
suffix:semicolon
r_switch
c_cond
(paren
id|active_fifo
)paren
(brace
r_case
l_int|0
suffix:colon
r_case
l_int|1
suffix:colon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|active_fifo
comma
id|active_fifo
)paren
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
r_default
suffix:colon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/************************* Sequencer Execution Control ************************/
multiline_comment|/*&n; * Restart the sequencer program from address zero&n; */
r_void
DECL|function|ahd_restart
id|ahd_restart
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
id|ahd_pause
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI
comma
id|AHD_MODE_SCSI
)paren
suffix:semicolon
multiline_comment|/* No more pending messages */
id|ahd_clear_msg_state
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCSISIGO
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* De-assert BSY */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|MSG_OUT
comma
id|MSG_NOOP
)paren
suffix:semicolon
multiline_comment|/* No message to send */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SXFRCTL1
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SXFRCTL1
)paren
op_amp
op_complement
id|BITBUCKET
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SEQINTCTL
comma
l_int|0
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|LASTPHASE
comma
id|P_BUSFREE
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SEQ_FLAGS
comma
l_int|0
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SAVED_SCSIID
comma
l_int|0xFF
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SAVED_LUN
comma
l_int|0xFF
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ensure that the sequencer&squot;s idea of TQINPOS&n;&t; * matches our own.  The sequencer increments TQINPOS&n;&t; * only after it sees a DMA complete and a reset could&n;&t; * occur before the increment leaving the kernel to believe&n;&t; * the command arrived but the sequencer to not.&n;&t; */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|TQINPOS
comma
id|ahd-&gt;tqinfifonext
)paren
suffix:semicolon
multiline_comment|/* Always allow reselection */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCSISEQ1
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSISEQ_TEMPLATE
)paren
op_amp
(paren
id|ENSELI
op_or
id|ENRSELI
op_or
id|ENAUTOATNP
)paren
)paren
suffix:semicolon
multiline_comment|/* Ensure that no DMA operations are in progress */
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_CCHAN
comma
id|AHD_MODE_CCHAN
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCBHCNT
comma
l_int|0
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CCSCBCTL
comma
id|CCSCBRESET
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SEQCTL0
comma
id|FASTMODE
op_or
id|SEQRESET
)paren
suffix:semicolon
id|ahd_unpause
c_func
(paren
id|ahd
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahd_clear_fifo
id|ahd_clear_fifo
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
id|u_int
id|fifo
)paren
(brace
id|ahd_mode_state
id|saved_modes
suffix:semicolon
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_FIFOS
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;%s: Clearing FIFO %d&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|fifo
)paren
suffix:semicolon
macro_line|#endif
id|saved_modes
op_assign
id|ahd_save_modes
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|fifo
comma
id|fifo
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|DFFSXFRCTL
comma
id|RSTCHN
op_or
id|CLRSHCNT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SG_STATE
)paren
op_amp
id|FETCH_INPROG
)paren
op_ne
l_int|0
)paren
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CCSGCTL
comma
id|CCSGRESET
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|LONGJMP_ADDR
op_plus
l_int|1
comma
id|INVALID_ADDR
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SG_STATE
comma
l_int|0
)paren
suffix:semicolon
id|ahd_restore_modes
c_func
(paren
id|ahd
comma
id|saved_modes
)paren
suffix:semicolon
)brace
multiline_comment|/************************* Input/Output Queues ********************************/
multiline_comment|/*&n; * Flush and completed commands that are sitting in the command&n; * complete queues down on the chip but have yet to be dma&squot;ed back up.&n; */
r_void
DECL|function|ahd_flush_qoutfifo
id|ahd_flush_qoutfifo
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
r_struct
id|scb
op_star
id|scb
suffix:semicolon
id|ahd_mode_state
id|saved_modes
suffix:semicolon
id|u_int
id|saved_scbptr
suffix:semicolon
id|u_int
id|ccscbctl
suffix:semicolon
id|u_int
id|scbid
suffix:semicolon
id|u_int
id|next_scbid
suffix:semicolon
id|saved_modes
op_assign
id|ahd_save_modes
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_CCHAN
comma
id|AHD_MODE_CCHAN
)paren
suffix:semicolon
id|saved_scbptr
op_assign
id|ahd_get_scbptr
c_func
(paren
id|ahd
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Wait for any inprogress DMA to complete and clear DMA state&n;&t; * if this if for an SCB in the qinfifo.&n;&t; */
r_while
c_loop
(paren
(paren
id|ccscbctl
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|CCSCBCTL
)paren
op_amp
(paren
id|CCARREN
op_or
id|CCSCBEN
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|ccscbctl
op_amp
(paren
id|CCSCBDIR
op_or
id|CCARREN
)paren
)paren
op_eq
(paren
id|CCSCBDIR
op_or
id|CCARREN
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|ccscbctl
op_amp
id|ARRDONE
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|ccscbctl
op_amp
id|CCSCBDONE
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
id|ahd_delay
c_func
(paren
l_int|200
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ccscbctl
op_amp
id|CCSCBDIR
)paren
op_ne
l_int|0
)paren
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CCSCBCTL
comma
id|ccscbctl
op_amp
op_complement
(paren
id|CCARREN
op_or
id|CCSCBEN
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Complete any SCBs that just finished being&n;&t; * DMA&squot;ed into the qoutfifo.&n;&t; */
id|ahd_run_qoutfifo
c_func
(paren
id|ahd
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Manually update/complete any completed SCBs that are waiting to be&n;&t; * DMA&squot;ed back up to the host.&n;&t; */
id|scbid
op_assign
id|ahd_inw
c_func
(paren
id|ahd
comma
id|COMPLETE_DMA_SCB_HEAD
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|SCBID_IS_NULL
c_func
(paren
id|scbid
)paren
)paren
(brace
r_uint8
op_star
id|hscb_ptr
suffix:semicolon
id|u_int
id|i
suffix:semicolon
id|ahd_set_scbptr
c_func
(paren
id|ahd
comma
id|scbid
)paren
suffix:semicolon
id|next_scbid
op_assign
id|ahd_inw
c_func
(paren
id|ahd
comma
id|SCB_NEXT_COMPLETE
)paren
suffix:semicolon
id|scb
op_assign
id|ahd_lookup_scb
c_func
(paren
id|ahd
comma
id|scbid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: Warning - DMA-up and complete &quot;
l_string|&quot;SCB %d invalid&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|scbid
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|hscb_ptr
op_assign
(paren
r_uint8
op_star
)paren
id|scb-&gt;hscb
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
r_struct
id|hardware_scb
)paren
suffix:semicolon
id|i
op_increment
)paren
op_star
id|hscb_ptr
op_increment
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCB_BASE
op_plus
id|i
)paren
suffix:semicolon
id|ahd_complete_scb
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|scbid
op_assign
id|next_scbid
suffix:semicolon
)brace
id|ahd_outw
c_func
(paren
id|ahd
comma
id|COMPLETE_DMA_SCB_HEAD
comma
id|SCB_LIST_NULL
)paren
suffix:semicolon
id|scbid
op_assign
id|ahd_inw
c_func
(paren
id|ahd
comma
id|COMPLETE_SCB_HEAD
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|SCBID_IS_NULL
c_func
(paren
id|scbid
)paren
)paren
(brace
id|ahd_set_scbptr
c_func
(paren
id|ahd
comma
id|scbid
)paren
suffix:semicolon
id|next_scbid
op_assign
id|ahd_inw
c_func
(paren
id|ahd
comma
id|SCB_NEXT_COMPLETE
)paren
suffix:semicolon
id|scb
op_assign
id|ahd_lookup_scb
c_func
(paren
id|ahd
comma
id|scbid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: Warning - Complete SCB %d invalid&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|scbid
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|ahd_complete_scb
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|scbid
op_assign
id|next_scbid
suffix:semicolon
)brace
id|ahd_outw
c_func
(paren
id|ahd
comma
id|COMPLETE_SCB_HEAD
comma
id|SCB_LIST_NULL
)paren
suffix:semicolon
id|ahd_set_scbptr
c_func
(paren
id|ahd
comma
id|saved_scbptr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Flush the good status FIFO for compelted packetized commands.&n;&t; */
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI
comma
id|AHD_MODE_SCSI
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LQISTAT2
)paren
op_amp
id|LQIGSAVAIL
)paren
op_ne
l_int|0
)paren
(brace
id|scbid
op_assign
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|GSFIFO
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
op_or
id|ahd_inb
c_func
(paren
id|ahd
comma
id|GSFIFO
)paren
suffix:semicolon
id|scb
op_assign
id|ahd_lookup_scb
c_func
(paren
id|ahd
comma
id|scbid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: Warning - GSFIFO SCB %d invalid&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|scbid
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|ahd_complete_scb
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Restore state.&n;&t; */
id|ahd_restore_modes
c_func
(paren
id|ahd
comma
id|saved_modes
)paren
suffix:semicolon
id|ahd-&gt;flags
op_or_assign
id|AHD_UPDATE_PEND_CMDS
suffix:semicolon
)brace
r_void
DECL|function|ahd_run_qoutfifo
id|ahd_run_qoutfifo
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
r_struct
id|scb
op_star
id|scb
suffix:semicolon
id|u_int
id|scb_index
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;flags
op_amp
id|AHD_RUNNING_QOUTFIFO
)paren
op_ne
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;ahd_run_qoutfifo recursion&quot;
)paren
suffix:semicolon
id|ahd-&gt;flags
op_or_assign
id|AHD_RUNNING_QOUTFIFO
suffix:semicolon
id|ahd_sync_qoutfifo
c_func
(paren
id|ahd
comma
id|BUS_DMASYNC_POSTREAD
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ahd-&gt;qoutfifo
(braket
id|ahd-&gt;qoutfifonext
)braket
op_amp
id|QOUTFIFO_ENTRY_VALID_LE
)paren
op_eq
id|ahd-&gt;qoutfifonext_valid_tag
)paren
(brace
id|scb_index
op_assign
id|ahd_le16toh
c_func
(paren
id|ahd-&gt;qoutfifo
(braket
id|ahd-&gt;qoutfifonext
)braket
op_amp
op_complement
id|QOUTFIFO_ENTRY_VALID_LE
)paren
suffix:semicolon
id|scb
op_assign
id|ahd_lookup_scb
c_func
(paren
id|ahd
comma
id|scb_index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: WARNING no command for scb %d &quot;
l_string|&quot;(cmdcmplt)&bslash;nQOUTPOS = %d&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|scb_index
comma
id|ahd-&gt;qoutfifonext
)paren
suffix:semicolon
id|ahd_dump_card_state
c_func
(paren
id|ahd
)paren
suffix:semicolon
)brace
r_else
id|ahd_complete_scb
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|ahd-&gt;qoutfifonext
op_assign
(paren
id|ahd-&gt;qoutfifonext
op_plus
l_int|1
)paren
op_amp
(paren
id|AHD_QOUT_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahd-&gt;qoutfifonext
op_eq
l_int|0
)paren
id|ahd-&gt;qoutfifonext_valid_tag
op_xor_assign
id|QOUTFIFO_ENTRY_VALID_LE
suffix:semicolon
)brace
id|ahd-&gt;flags
op_and_assign
op_complement
id|AHD_RUNNING_QOUTFIFO
suffix:semicolon
)brace
multiline_comment|/************************* Interrupt Handling *********************************/
r_void
DECL|function|ahd_handle_hwerrint
id|ahd_handle_hwerrint
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
multiline_comment|/*&n;&t; * Some catastrophic hardware error has occurred.&n;&t; * Print it for the user and disable the controller.&n;&t; */
r_int
id|i
suffix:semicolon
r_int
id|error
suffix:semicolon
id|error
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|ERROR
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_errors
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_amp
id|ahd_hard_errors
(braket
id|i
)braket
dot
id|errno
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;%s: hwerrint, %s&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|ahd_hard_errors
(braket
id|i
)braket
dot
id|errmesg
)paren
suffix:semicolon
)brace
id|ahd_dump_card_state
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;BRKADRINT&quot;
)paren
suffix:semicolon
multiline_comment|/* Tell everyone that this HBA is no longer availible */
id|ahd_abort_scbs
c_func
(paren
id|ahd
comma
id|CAM_TARGET_WILDCARD
comma
id|ALL_CHANNELS
comma
id|CAM_LUN_WILDCARD
comma
id|SCB_LIST_NULL
comma
id|ROLE_UNKNOWN
comma
id|CAM_NO_HBA
)paren
suffix:semicolon
multiline_comment|/* Tell the system that this controller has gone away. */
id|ahd_free
c_func
(paren
id|ahd
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahd_handle_seqint
id|ahd_handle_seqint
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
id|u_int
id|intstat
)paren
(brace
id|u_int
id|seqintcode
suffix:semicolon
multiline_comment|/*&n;&t; * Save the sequencer interrupt code and clear the SEQINT&n;&t; * bit. We will unpause the sequencer, if appropriate,&n;&t; * after servicing the request.&n;&t; */
id|seqintcode
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SEQINTCODE
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRINT
comma
id|CLRSEQINT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;bugs
op_amp
id|AHD_INTCOLLISION_BUG
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Unpause the sequencer and let it clear&n;&t;&t; * SEQINT by writing NO_SEQINT to it.  This&n;&t;&t; * will cause the sequencer to be paused again,&n;&t;&t; * which is the expected state of this routine.&n;&t;&t; */
id|ahd_unpause
c_func
(paren
id|ahd
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|ahd_is_paused
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRINT
comma
id|CLRSEQINT
)paren
suffix:semicolon
)brace
id|ahd_update_modes
c_func
(paren
id|ahd
)paren
suffix:semicolon
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_MISC
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;%s: Handle Seqint Called for code %d&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|seqintcode
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|seqintcode
)paren
(brace
r_case
id|ENTERING_NONPACK
suffix:colon
(brace
r_struct
id|scb
op_star
id|scb
suffix:semicolon
id|u_int
id|scbid
suffix:semicolon
id|AHD_ASSERT_MODES
c_func
(paren
id|ahd
comma
op_complement
(paren
id|AHD_MODE_UNKNOWN_MSK
op_or
id|AHD_MODE_CFG_MSK
)paren
comma
op_complement
(paren
id|AHD_MODE_UNKNOWN_MSK
op_or
id|AHD_MODE_CFG_MSK
)paren
)paren
suffix:semicolon
id|scbid
op_assign
id|ahd_get_scbptr
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|scb
op_assign
id|ahd_lookup_scb
c_func
(paren
id|ahd
comma
id|scbid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Somehow need to know if this&n;&t;&t;&t; * is from a selection or reselection.&n;&t;&t;&t; * From that, we can termine target&n;&t;&t;&t; * ID so we at least have an I_T nexus.&n;&t;&t;&t; */
)brace
r_else
(brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SAVED_SCSIID
comma
id|scb-&gt;hscb-&gt;scsiid
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SAVED_LUN
comma
id|scb-&gt;hscb-&gt;lun
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SEQ_FLAGS
comma
l_int|0x0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LQISTAT2
)paren
op_amp
id|LQIPHASE_OUTPKT
)paren
op_ne
l_int|0
op_logical_and
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSISIGO
)paren
op_amp
id|ATNO
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Phase change after read stream with&n;&t;&t;&t; * CRC error with P0 asserted on last&n;&t;&t;&t; * packet.&n;&t;&t;&t; */
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_RECOVERY
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;%s: Assuming LQIPHASE_NLQ with &quot;
l_string|&quot;P0 assertion&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_RECOVERY
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;%s: Entering NONPACK&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
r_case
id|INVALID_SEQINT
suffix:colon
id|printf
c_func
(paren
l_string|&quot;%s: Invalid Sequencer interrupt occurred.&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
id|ahd_dump_card_state
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_reset_channel
c_func
(paren
id|ahd
comma
l_char|&squot;A&squot;
comma
multiline_comment|/*Initiate Reset*/
id|TRUE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|STATUS_OVERRUN
suffix:colon
(brace
id|printf
c_func
(paren
l_string|&quot;%s: Status Overrun&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
id|ahd_dump_card_state
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_reset_channel
c_func
(paren
id|ahd
comma
l_char|&squot;A&squot;
comma
multiline_comment|/*Initiate Reset*/
id|TRUE
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|CFG4ISTAT_INTR
suffix:colon
(brace
r_struct
id|scb
op_star
id|scb
suffix:semicolon
id|u_int
id|scbid
suffix:semicolon
id|scbid
op_assign
id|ahd_get_scbptr
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|scb
op_assign
id|ahd_lookup_scb
c_func
(paren
id|ahd
comma
id|scbid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
id|ahd_dump_card_state
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;CFG4ISTAT: Free SCB %d referenced&quot;
comma
id|scbid
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;For safety&quot;
)paren
suffix:semicolon
)brace
id|ahd_outq
c_func
(paren
id|ahd
comma
id|HADDR
comma
id|scb-&gt;sense_busaddr
)paren
suffix:semicolon
id|ahd_outw
c_func
(paren
id|ahd
comma
id|HCNT
comma
id|AHD_SENSE_BUFSIZE
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|HCNT
op_plus
l_int|2
comma
l_int|0
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SG_CACHE_PRE
comma
id|SG_LAST_SEG
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|DFCNTRL
comma
id|PRELOADEN
op_or
id|SCSIEN
op_or
id|HDMAEN
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|ILLEGAL_PHASE
suffix:colon
(brace
id|u_int
id|bus_phase
suffix:semicolon
id|bus_phase
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSISIGI
)paren
op_amp
id|PHASE_MASK
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s: ILLEGAL_PHASE 0x%x&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|bus_phase
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|bus_phase
)paren
(brace
r_case
id|P_DATAOUT
suffix:colon
r_case
id|P_DATAIN
suffix:colon
r_case
id|P_DATAOUT_DT
suffix:colon
r_case
id|P_DATAIN_DT
suffix:colon
r_case
id|P_MESGOUT
suffix:colon
r_case
id|P_STATUS
suffix:colon
r_case
id|P_MESGIN
suffix:colon
id|ahd_reset_channel
c_func
(paren
id|ahd
comma
l_char|&squot;A&squot;
comma
multiline_comment|/*Initiate Reset*/
id|TRUE
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s: Issued Bus Reset.&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_COMMAND
suffix:colon
(brace
r_struct
id|ahd_devinfo
id|devinfo
suffix:semicolon
r_struct
id|scb
op_star
id|scb
suffix:semicolon
r_struct
id|ahd_initiator_tinfo
op_star
id|targ_info
suffix:semicolon
r_struct
id|ahd_tmode_tstate
op_star
id|tstate
suffix:semicolon
r_struct
id|ahd_transinfo
op_star
id|tinfo
suffix:semicolon
id|u_int
id|scbid
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If a target takes us into the command phase&n;&t;&t;&t; * assume that it has been externally reset and&n;&t;&t;&t; * has thus lost our previous packetized negotiation&n;&t;&t;&t; * agreement.  Since we have not sent an identify&n;&t;&t;&t; * message and may not have fully qualified the&n;&t;&t;&t; * connection, we change our command to TUR, assert&n;&t;&t;&t; * ATN and ABORT the task when we go to message in&n;&t;&t;&t; * phase.  The OSM will see the REQUEUE_REQUEST&n;&t;&t;&t; * status and retry the command.&n;&t;&t;&t; */
id|scbid
op_assign
id|ahd_get_scbptr
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|scb
op_assign
id|ahd_lookup_scb
c_func
(paren
id|ahd
comma
id|scbid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Invalid phase with no valid SCB.  &quot;
l_string|&quot;Resetting bus.&bslash;n&quot;
)paren
suffix:semicolon
id|ahd_reset_channel
c_func
(paren
id|ahd
comma
l_char|&squot;A&squot;
comma
multiline_comment|/*Initiate Reset*/
id|TRUE
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ahd_compile_devinfo
c_func
(paren
op_amp
id|devinfo
comma
id|SCB_GET_OUR_ID
c_func
(paren
id|scb
)paren
comma
id|SCB_GET_TARGET
c_func
(paren
id|ahd
comma
id|scb
)paren
comma
id|SCB_GET_LUN
c_func
(paren
id|scb
)paren
comma
id|SCB_GET_CHANNEL
c_func
(paren
id|ahd
comma
id|scb
)paren
comma
id|ROLE_INITIATOR
)paren
suffix:semicolon
id|targ_info
op_assign
id|ahd_fetch_transinfo
c_func
(paren
id|ahd
comma
id|devinfo.channel
comma
id|devinfo.our_scsiid
comma
id|devinfo.target
comma
op_amp
id|tstate
)paren
suffix:semicolon
id|tinfo
op_assign
op_amp
id|targ_info-&gt;curr
suffix:semicolon
id|ahd_set_width
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
comma
id|MSG_EXT_WDTR_BUS_8_BIT
comma
id|AHD_TRANS_ACTIVE
comma
multiline_comment|/*paused*/
id|TRUE
)paren
suffix:semicolon
id|ahd_set_syncrate
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
comma
multiline_comment|/*period*/
l_int|0
comma
multiline_comment|/*offset*/
l_int|0
comma
multiline_comment|/*ppr_options*/
l_int|0
comma
id|AHD_TRANS_ACTIVE
comma
multiline_comment|/*paused*/
id|TRUE
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCB_CDB_STORE
comma
l_int|0
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCB_CDB_STORE
op_plus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCB_CDB_STORE
op_plus
l_int|2
comma
l_int|0
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCB_CDB_STORE
op_plus
l_int|3
comma
l_int|0
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCB_CDB_STORE
op_plus
l_int|4
comma
l_int|0
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCB_CDB_STORE
op_plus
l_int|5
comma
l_int|0
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCB_CDB_LEN
comma
l_int|6
)paren
suffix:semicolon
id|scb-&gt;hscb-&gt;control
op_and_assign
op_complement
(paren
id|TAG_ENB
op_or
id|SCB_TAG_TYPE
)paren
suffix:semicolon
id|scb-&gt;hscb-&gt;control
op_or_assign
id|MK_MESSAGE
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCB_CONTROL
comma
id|scb-&gt;hscb-&gt;control
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|MSG_OUT
comma
id|HOST_MSG
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SAVED_SCSIID
comma
id|scb-&gt;hscb-&gt;scsiid
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * The lun is 0, regardless of the SCB&squot;s lun&n;&t;&t;&t; * as we have not sent an identify message.&n;&t;&t;&t; */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SAVED_LUN
comma
l_int|0
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SEQ_FLAGS
comma
l_int|0
)paren
suffix:semicolon
id|ahd_assert_atn
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|scb-&gt;flags
op_and_assign
op_complement
(paren
id|SCB_PACKETIZED
)paren
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_ABORT
op_or
id|SCB_CMDPHASE_ABORT
suffix:semicolon
id|ahd_freeze_devq
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|ahd_set_transaction_status
c_func
(paren
id|scb
comma
id|CAM_REQUEUE_REQ
)paren
suffix:semicolon
id|ahd_freeze_scb
c_func
(paren
id|scb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Allow the sequencer to continue with&n;&t;&t;&t; * non-pack processing.&n;&t;&t;&t; */
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI
comma
id|AHD_MODE_SCSI
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRLQOINT1
comma
id|CLRLQOPHACHGINPKT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;bugs
op_amp
id|AHD_CLRLQO_AUTOCLR_BUG
)paren
op_ne
l_int|0
)paren
(brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRLQOINT1
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_RECOVERY
)paren
op_ne
l_int|0
)paren
(brace
id|ahd_print_path
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Unexpected command phase from &quot;
l_string|&quot;packetized target&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_break
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
r_case
id|CFG4OVERRUN
suffix:colon
(brace
r_struct
id|scb
op_star
id|scb
suffix:semicolon
id|u_int
id|scb_index
suffix:semicolon
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_RECOVERY
)paren
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: CFG4OVERRUN mode = %x&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|MODE_PTR
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|scb_index
op_assign
id|ahd_get_scbptr
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|scb
op_assign
id|ahd_lookup_scb
c_func
(paren
id|ahd
comma
id|scb_index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Attempt to transfer to an SCB that is&n;&t;&t;&t; * not outstanding.&n;&t;&t;&t; */
id|ahd_assert_atn
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|MSG_OUT
comma
id|HOST_MSG
)paren
suffix:semicolon
id|ahd-&gt;msgout_buf
(braket
l_int|0
)braket
op_assign
id|MSG_ABORT_TASK
suffix:semicolon
id|ahd-&gt;msgout_len
op_assign
l_int|1
suffix:semicolon
id|ahd-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|ahd-&gt;msg_type
op_assign
id|MSG_TYPE_INITIATOR_MSGOUT
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Clear status received flag to prevent any&n;&t;&t;&t; * attempt to complete this bogus SCB.&n;&t;&t;&t; */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCB_CONTROL
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCB_CONTROL
)paren
op_amp
op_complement
id|STATUS_RCVD
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_case
id|DUMP_CARD_STATE
suffix:colon
(brace
id|ahd_dump_card_state
c_func
(paren
id|ahd
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|PDATA_REINIT
suffix:colon
(brace
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_RECOVERY
)paren
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: PDATA_REINIT - DFCNTRL = 0x%x &quot;
l_string|&quot;SG_CACHE_SHADOW = 0x%x&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|DFCNTRL
)paren
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SG_CACHE_SHADOW
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|ahd_reinitialize_dataptrs
c_func
(paren
id|ahd
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|HOST_MSG_LOOP
suffix:colon
(brace
r_struct
id|ahd_devinfo
id|devinfo
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The sequencer has encountered a message phase&n;&t;&t; * that requires host assistance for completion.&n;&t;&t; * While handling the message phase(s), we will be&n;&t;&t; * notified by the sequencer after each byte is&n;&t;&t; * transfered so we can track bus phase changes.&n;&t;&t; *&n;&t;&t; * If this is the first time we&squot;ve seen a HOST_MSG_LOOP&n;&t;&t; * interrupt, initialize the state of the host message&n;&t;&t; * loop.&n;&t;&t; */
id|ahd_fetch_devinfo
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahd-&gt;msg_type
op_eq
id|MSG_TYPE_NONE
)paren
(brace
r_struct
id|scb
op_star
id|scb
suffix:semicolon
id|u_int
id|scb_index
suffix:semicolon
id|u_int
id|bus_phase
suffix:semicolon
id|bus_phase
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSISIGI
)paren
op_amp
id|PHASE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|bus_phase
op_ne
id|P_MESGIN
op_logical_and
id|bus_phase
op_ne
id|P_MESGOUT
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;ahd_intr: HOST_MSG_LOOP bad &quot;
l_string|&quot;phase 0x%x&bslash;n&quot;
comma
id|bus_phase
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Probably transitioned to bus free before&n;&t;&t;&t;&t; * we got here.  Just punt the message.&n;&t;&t;&t;&t; */
id|ahd_dump_card_state
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_clear_intstat
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_restart
c_func
(paren
id|ahd
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|scb_index
op_assign
id|ahd_get_scbptr
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|scb
op_assign
id|ahd_lookup_scb
c_func
(paren
id|ahd
comma
id|scb_index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devinfo.role
op_eq
id|ROLE_INITIATOR
)paren
(brace
r_if
c_cond
(paren
id|bus_phase
op_eq
id|P_MESGOUT
)paren
id|ahd_setup_initiator_msgout
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
comma
id|scb
)paren
suffix:semicolon
r_else
(brace
id|ahd-&gt;msg_type
op_assign
id|MSG_TYPE_INITIATOR_MSGIN
suffix:semicolon
id|ahd-&gt;msgin_index
op_assign
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#if AHD_TARGET_MODE
r_else
(brace
r_if
c_cond
(paren
id|bus_phase
op_eq
id|P_MESGOUT
)paren
(brace
id|ahd-&gt;msg_type
op_assign
id|MSG_TYPE_TARGET_MSGOUT
suffix:semicolon
id|ahd-&gt;msgin_index
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|ahd_setup_target_msgin
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
comma
id|scb
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
id|ahd_handle_message_phase
c_func
(paren
id|ahd
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|NO_MATCH
suffix:colon
(brace
multiline_comment|/* Ensure we don&squot;t leave the selection hardware on */
id|AHD_ASSERT_MODES
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI_MSK
comma
id|AHD_MODE_SCSI_MSK
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCSISEQ0
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSISEQ0
)paren
op_amp
op_complement
id|ENSELO
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s:%c:%d: no active SCB for reconnecting &quot;
l_string|&quot;target - issuing BUS DEVICE RESET&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
l_char|&squot;A&squot;
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SELID
)paren
op_rshift
l_int|4
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;SAVED_SCSIID == 0x%x, SAVED_LUN == 0x%x, &quot;
l_string|&quot;REG0 == 0x%x ACCUM = 0x%x&bslash;n&quot;
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SAVED_SCSIID
)paren
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SAVED_LUN
)paren
comma
id|ahd_inw
c_func
(paren
id|ahd
comma
id|REG0
)paren
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|ACCUM
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;SEQ_FLAGS == 0x%x, SCBPTR == 0x%x, BTT == 0x%x, &quot;
l_string|&quot;SINDEX == 0x%x&bslash;n&quot;
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SEQ_FLAGS
)paren
comma
id|ahd_get_scbptr
c_func
(paren
id|ahd
)paren
comma
id|ahd_find_busy_tcl
c_func
(paren
id|ahd
comma
id|BUILD_TCL
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SAVED_SCSIID
)paren
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SAVED_LUN
)paren
)paren
)paren
comma
id|ahd_inw
c_func
(paren
id|ahd
comma
id|SINDEX
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;SELID == 0x%x, SCB_SCSIID == 0x%x, SCB_LUN == 0x%x, &quot;
l_string|&quot;SCB_CONTROL == 0x%x&bslash;n&quot;
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SELID
)paren
comma
id|ahd_inb_scbram
c_func
(paren
id|ahd
comma
id|SCB_SCSIID
)paren
comma
id|ahd_inb_scbram
c_func
(paren
id|ahd
comma
id|SCB_LUN
)paren
comma
id|ahd_inb_scbram
c_func
(paren
id|ahd
comma
id|SCB_CONTROL
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;SCSIBUS[0] == 0x%x, SCSISIGI == 0x%x&bslash;n&quot;
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSIBUS
)paren
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSISIGI
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;SXFRCTL0 == 0x%x&bslash;n&quot;
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SXFRCTL0
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;SEQCTL0 == 0x%x&bslash;n&quot;
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SEQCTL0
)paren
)paren
suffix:semicolon
id|ahd_dump_card_state
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd-&gt;msgout_buf
(braket
l_int|0
)braket
op_assign
id|MSG_BUS_DEV_RESET
suffix:semicolon
id|ahd-&gt;msgout_len
op_assign
l_int|1
suffix:semicolon
id|ahd-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|ahd-&gt;msg_type
op_assign
id|MSG_TYPE_INITIATOR_MSGOUT
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|MSG_OUT
comma
id|HOST_MSG
)paren
suffix:semicolon
id|ahd_assert_atn
c_func
(paren
id|ahd
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|PROTO_VIOLATION
suffix:colon
(brace
id|ahd_handle_proto_violation
c_func
(paren
id|ahd
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|IGN_WIDE_RES
suffix:colon
(brace
r_struct
id|ahd_devinfo
id|devinfo
suffix:semicolon
id|ahd_fetch_devinfo
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
)paren
suffix:semicolon
id|ahd_handle_ign_wide_residue
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|BAD_PHASE
suffix:colon
(brace
id|u_int
id|lastphase
suffix:semicolon
id|lastphase
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LASTPHASE
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s:%c:%d: unknown scsi bus phase %x, &quot;
l_string|&quot;lastphase = 0x%x.  Attempting to continue&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
l_char|&squot;A&squot;
comma
id|SCSIID_TARGET
c_func
(paren
id|ahd
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SAVED_SCSIID
)paren
)paren
comma
id|lastphase
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSISIGI
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MISSED_BUSFREE
suffix:colon
(brace
id|u_int
id|lastphase
suffix:semicolon
id|lastphase
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LASTPHASE
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s:%c:%d: Missed busfree. &quot;
l_string|&quot;Lastphase = 0x%x, Curphase = 0x%x&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
l_char|&squot;A&squot;
comma
id|SCSIID_TARGET
c_func
(paren
id|ahd
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SAVED_SCSIID
)paren
)paren
comma
id|lastphase
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSISIGI
)paren
)paren
suffix:semicolon
id|ahd_restart
c_func
(paren
id|ahd
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_case
id|DATA_OVERRUN
suffix:colon
(brace
multiline_comment|/*&n;&t;&t; * When the sequencer detects an overrun, it&n;&t;&t; * places the controller in &quot;BITBUCKET&quot; mode&n;&t;&t; * and allows the target to complete its transfer.&n;&t;&t; * Unfortunately, none of the counters get updated&n;&t;&t; * when the controller is in this mode, so we have&n;&t;&t; * no way of knowing how large the overrun was.&n;&t;&t; */
r_struct
id|scb
op_star
id|scb
suffix:semicolon
id|u_int
id|scbindex
suffix:semicolon
macro_line|#ifdef AHD_DEBUG
id|u_int
id|lastphase
suffix:semicolon
macro_line|#endif
id|scbindex
op_assign
id|ahd_get_scbptr
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|scb
op_assign
id|ahd_lookup_scb
c_func
(paren
id|ahd
comma
id|scbindex
)paren
suffix:semicolon
macro_line|#ifdef AHD_DEBUG
id|lastphase
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LASTPHASE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_RECOVERY
)paren
op_ne
l_int|0
)paren
(brace
id|ahd_print_path
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;data overrun detected %s.  Tag == 0x%x.&bslash;n&quot;
comma
id|ahd_lookup_phase_entry
c_func
(paren
id|lastphase
)paren
op_member_access_from_pointer
id|phasemsg
comma
id|SCB_GET_TAG
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
id|ahd_print_path
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s seen Data Phase.  Length = %ld.  &quot;
l_string|&quot;NumSGs = %d.&bslash;n&quot;
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SEQ_FLAGS
)paren
op_amp
id|DPHASE
ques
c_cond
l_string|&quot;Have&quot;
suffix:colon
l_string|&quot;Haven&squot;t&quot;
comma
id|ahd_get_transfer_length
c_func
(paren
id|scb
)paren
comma
id|scb-&gt;sg_count
)paren
suffix:semicolon
id|ahd_dump_sglist
c_func
(paren
id|scb
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;&t; * Set this and it will take effect when the&n;&t;&t; * target does a command complete.&n;&t;&t; */
id|ahd_freeze_devq
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|ahd_set_transaction_status
c_func
(paren
id|scb
comma
id|CAM_DATA_RUN_ERR
)paren
suffix:semicolon
id|ahd_freeze_scb
c_func
(paren
id|scb
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MKMSG_FAILED
suffix:colon
(brace
r_struct
id|ahd_devinfo
id|devinfo
suffix:semicolon
r_struct
id|scb
op_star
id|scb
suffix:semicolon
id|u_int
id|scbid
suffix:semicolon
id|ahd_fetch_devinfo
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s:%c:%d:%d: Attempt to issue message failed&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|devinfo.channel
comma
id|devinfo.target
comma
id|devinfo.lun
)paren
suffix:semicolon
id|scbid
op_assign
id|ahd_get_scbptr
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|scb
op_assign
id|ahd_lookup_scb
c_func
(paren
id|ahd
comma
id|scbid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_ne
l_int|NULL
op_logical_and
(paren
id|scb-&gt;flags
op_amp
id|SCB_RECOVERY_SCB
)paren
op_ne
l_int|0
)paren
multiline_comment|/*&n;&t;&t;&t; * Ensure that we didn&squot;t put a second instance of this&n;&t;&t;&t; * SCB into the QINFIFO.&n;&t;&t;&t; */
id|ahd_search_qinfifo
c_func
(paren
id|ahd
comma
id|SCB_GET_TARGET
c_func
(paren
id|ahd
comma
id|scb
)paren
comma
id|SCB_GET_CHANNEL
c_func
(paren
id|ahd
comma
id|scb
)paren
comma
id|SCB_GET_LUN
c_func
(paren
id|scb
)paren
comma
id|SCB_GET_TAG
c_func
(paren
id|scb
)paren
comma
id|ROLE_INITIATOR
comma
multiline_comment|/*status*/
l_int|0
comma
id|SEARCH_REMOVE
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCB_CONTROL
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCB_CONTROL
)paren
op_amp
op_complement
id|MK_MESSAGE
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|TASKMGMT_FUNC_COMPLETE
suffix:colon
(brace
id|u_int
id|scbid
suffix:semicolon
r_struct
id|scb
op_star
id|scb
suffix:semicolon
id|scbid
op_assign
id|ahd_get_scbptr
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|scb
op_assign
id|ahd_lookup_scb
c_func
(paren
id|ahd
comma
id|scbid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_ne
l_int|NULL
)paren
(brace
id|u_int
id|lun
suffix:semicolon
id|u_int
id|tag
suffix:semicolon
id|cam_status
id|error
suffix:semicolon
id|ahd_print_path
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Task Management Func 0x%x Complete&bslash;n&quot;
comma
id|scb-&gt;hscb-&gt;task_management
)paren
suffix:semicolon
id|lun
op_assign
id|CAM_LUN_WILDCARD
suffix:semicolon
id|tag
op_assign
id|SCB_LIST_NULL
suffix:semicolon
r_switch
c_cond
(paren
id|scb-&gt;hscb-&gt;task_management
)paren
(brace
r_case
id|SIU_TASKMGMT_ABORT_TASK
suffix:colon
id|tag
op_assign
id|scb-&gt;hscb-&gt;tag
suffix:semicolon
r_case
id|SIU_TASKMGMT_ABORT_TASK_SET
suffix:colon
r_case
id|SIU_TASKMGMT_CLEAR_TASK_SET
suffix:colon
id|lun
op_assign
id|scb-&gt;hscb-&gt;lun
suffix:semicolon
id|error
op_assign
id|CAM_REQ_ABORTED
suffix:semicolon
id|ahd_abort_scbs
c_func
(paren
id|ahd
comma
id|SCB_GET_TARGET
c_func
(paren
id|ahd
comma
id|scb
)paren
comma
l_char|&squot;A&squot;
comma
id|lun
comma
id|tag
comma
id|ROLE_INITIATOR
comma
id|error
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIU_TASKMGMT_LUN_RESET
suffix:colon
id|lun
op_assign
id|scb-&gt;hscb-&gt;lun
suffix:semicolon
r_case
id|SIU_TASKMGMT_TARGET_RESET
suffix:colon
(brace
r_struct
id|ahd_devinfo
id|devinfo
suffix:semicolon
id|ahd_scb_devinfo
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
comma
id|scb
)paren
suffix:semicolon
id|error
op_assign
id|CAM_BDR_SENT
suffix:semicolon
id|ahd_handle_devreset
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
comma
id|lun
comma
id|CAM_BDR_SENT
comma
id|lun
op_ne
id|CAM_LUN_WILDCARD
ques
c_cond
l_string|&quot;Lun Reset&quot;
suffix:colon
l_string|&quot;Target Reset&quot;
comma
multiline_comment|/*verbose_level*/
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;Unexpected TaskMgmt Func&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
r_case
id|TASKMGMT_CMD_CMPLT_OKAY
suffix:colon
(brace
id|u_int
id|scbid
suffix:semicolon
r_struct
id|scb
op_star
id|scb
suffix:semicolon
multiline_comment|/*&n;&t;&t; * An ABORT TASK TMF failed to be delivered before&n;&t;&t; * the targeted command completed normally.&n;&t;&t; */
id|scbid
op_assign
id|ahd_get_scbptr
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|scb
op_assign
id|ahd_lookup_scb
c_func
(paren
id|ahd
comma
id|scbid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Remove the second instance of this SCB from&n;&t;&t;&t; * the QINFIFO if it is still there.&n;                         */
id|ahd_print_path
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;SCB completes before TMF&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Handle losing the race.  Wait until any&n;&t;&t;&t; * current selection completes.  We will then&n;&t;&t;&t; * set the TMF back to zero in this SCB so that&n;&t;&t;&t; * the sequencer doesn&squot;t bother to issue another&n;&t;&t;&t; * sequencer interrupt for its completion.&n;&t;&t;&t; */
r_while
c_loop
(paren
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSISEQ0
)paren
op_amp
id|ENSELO
)paren
op_ne
l_int|0
op_logical_and
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SSTAT0
)paren
op_amp
id|SELDO
)paren
op_eq
l_int|0
op_logical_and
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SSTAT1
)paren
op_amp
id|SELTO
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCB_TASK_MANAGEMENT
comma
l_int|0
)paren
suffix:semicolon
id|ahd_search_qinfifo
c_func
(paren
id|ahd
comma
id|SCB_GET_TARGET
c_func
(paren
id|ahd
comma
id|scb
)paren
comma
id|SCB_GET_CHANNEL
c_func
(paren
id|ahd
comma
id|scb
)paren
comma
id|SCB_GET_LUN
c_func
(paren
id|scb
)paren
comma
id|scb-&gt;hscb-&gt;tag
comma
id|ROLE_INITIATOR
comma
multiline_comment|/*status*/
l_int|0
comma
id|SEARCH_REMOVE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_case
id|TRACEPOINT0
suffix:colon
r_case
id|TRACEPOINT1
suffix:colon
r_case
id|TRACEPOINT2
suffix:colon
r_case
id|TRACEPOINT3
suffix:colon
id|printf
c_func
(paren
l_string|&quot;%s: Tracepoint %d&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|seqintcode
op_minus
id|TRACEPOINT0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NO_SEQINT
suffix:colon
r_break
suffix:semicolon
r_case
id|SAW_HWERR
suffix:colon
id|ahd_handle_hwerrint
c_func
(paren
id|ahd
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printf
c_func
(paren
l_string|&quot;%s: Unexpected SEQINTCODE %d&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|seqintcode
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  The sequencer is paused immediately on&n;&t; *  a SEQINT, so we should restart it when&n;&t; *  we&squot;re done.&n;&t; */
id|ahd_unpause
c_func
(paren
id|ahd
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahd_handle_scsiint
id|ahd_handle_scsiint
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
id|u_int
id|intstat
)paren
(brace
r_struct
id|scb
op_star
id|scb
suffix:semicolon
id|u_int
id|status0
suffix:semicolon
id|u_int
id|status3
suffix:semicolon
id|u_int
id|status
suffix:semicolon
id|u_int
id|lqistat1
suffix:semicolon
id|u_int
id|lqostat0
suffix:semicolon
id|u_int
id|scbid
suffix:semicolon
id|u_int
id|busfreetime
suffix:semicolon
id|ahd_update_modes
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI
comma
id|AHD_MODE_SCSI
)paren
suffix:semicolon
id|status3
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SSTAT3
)paren
op_amp
(paren
id|NTRAMPERR
op_or
id|OSRAMPERR
)paren
suffix:semicolon
id|status0
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SSTAT0
)paren
op_amp
(paren
id|IOERR
op_or
id|OVERRUN
op_or
id|SELDI
op_or
id|SELDO
)paren
suffix:semicolon
id|status
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SSTAT1
)paren
op_amp
(paren
id|SELTO
op_or
id|SCSIRSTI
op_or
id|BUSFREE
op_or
id|SCSIPERR
)paren
suffix:semicolon
id|lqistat1
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LQISTAT1
)paren
suffix:semicolon
id|lqostat0
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LQOSTAT0
)paren
suffix:semicolon
id|busfreetime
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SSTAT2
)paren
op_amp
id|BUSFREETIME
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status0
op_amp
(paren
id|SELDI
op_or
id|SELDO
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|u_int
id|simode0
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_CFG
comma
id|AHD_MODE_CFG
)paren
suffix:semicolon
id|simode0
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SIMODE0
)paren
suffix:semicolon
id|status0
op_and_assign
id|simode0
op_amp
(paren
id|IOERR
op_or
id|OVERRUN
op_or
id|SELDI
op_or
id|SELDO
)paren
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI
comma
id|AHD_MODE_SCSI
)paren
suffix:semicolon
)brace
id|scbid
op_assign
id|ahd_get_scbptr
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|scb
op_assign
id|ahd_lookup_scb
c_func
(paren
id|ahd
comma
id|scbid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_ne
l_int|NULL
op_logical_and
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SEQ_FLAGS
)paren
op_amp
id|NOT_IDENTIFIED
)paren
op_ne
l_int|0
)paren
id|scb
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Make sure the sequencer is in a safe location. */
id|ahd_clear_critical_section
c_func
(paren
id|ahd
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status0
op_amp
id|IOERR
)paren
op_ne
l_int|0
)paren
(brace
id|u_int
id|now_lvd
suffix:semicolon
id|now_lvd
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SBLKCTL
)paren
op_amp
id|ENAB40
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s: Transceiver State Has Changed to %s mode&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|now_lvd
ques
c_cond
l_string|&quot;LVD&quot;
suffix:colon
l_string|&quot;SE&quot;
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRSINT0
comma
id|CLRIOERR
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * A change in I/O mode is equivalent to a bus reset.&n;&t;&t; */
id|ahd_reset_channel
c_func
(paren
id|ahd
comma
l_char|&squot;A&squot;
comma
multiline_comment|/*Initiate Reset*/
id|FALSE
)paren
suffix:semicolon
id|ahd_pause
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_setup_iocell_workaround
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_unpause
c_func
(paren
id|ahd
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|status0
op_amp
id|OVERRUN
)paren
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: SCSI offset overrun detected.  Resetting bus.&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
id|ahd_reset_channel
c_func
(paren
id|ahd
comma
l_char|&squot;A&squot;
comma
multiline_comment|/*Initiate Reset*/
id|TRUE
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|status
op_amp
id|SCSIRSTI
)paren
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: Someone reset channel A&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
id|ahd_reset_channel
c_func
(paren
id|ahd
comma
l_char|&squot;A&squot;
comma
multiline_comment|/*Initiate Reset*/
id|FALSE
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|status
op_amp
id|SCSIPERR
)paren
op_ne
l_int|0
)paren
(brace
id|ahd_handle_transmission_error
c_func
(paren
id|ahd
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lqostat0
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: lqostat0 == 0x%x!&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|lqostat0
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRLQOINT0
comma
id|lqostat0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;bugs
op_amp
id|AHD_CLRLQO_AUTOCLR_BUG
)paren
op_ne
l_int|0
)paren
(brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRLQOINT1
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|status
op_amp
id|SELTO
)paren
op_ne
l_int|0
)paren
(brace
id|u_int
id|scbid
suffix:semicolon
multiline_comment|/* Stop the selection */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCSISEQ0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* No more pending messages */
id|ahd_clear_msg_state
c_func
(paren
id|ahd
)paren
suffix:semicolon
multiline_comment|/* Clear interrupt state */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRSINT1
comma
id|CLRSELTIMEO
op_or
id|CLRBUSFREE
op_or
id|CLRSCSIPERR
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Although the driver does not care about the&n;&t;&t; * &squot;Selection in Progress&squot; status bit, the busy&n;&t;&t; * LED does.  SELINGO is only cleared by a sucessfull&n;&t;&t; * selection, so we must manually clear it to insure&n;&t;&t; * the LED turns off just incase no future successful&n;&t;&t; * selections occur (e.g. no devices on the bus).&n;&t;&t; */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRSINT0
comma
id|CLRSELINGO
)paren
suffix:semicolon
id|scbid
op_assign
id|ahd_inw
c_func
(paren
id|ahd
comma
id|WAITING_TID_HEAD
)paren
suffix:semicolon
id|scb
op_assign
id|ahd_lookup_scb
c_func
(paren
id|ahd
comma
id|scbid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: ahd_intr - referenced scb not &quot;
l_string|&quot;valid during SELTO scb(0x%x)&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|scbid
)paren
suffix:semicolon
id|ahd_dump_card_state
c_func
(paren
id|ahd
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|ahd_devinfo
id|devinfo
suffix:semicolon
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_SELTO
)paren
op_ne
l_int|0
)paren
(brace
id|ahd_print_path
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Saw Selection Timeout for SCB 0x%x&bslash;n&quot;
comma
id|scbid
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;&t;&t; * Force a renegotiation with this target just in&n;&t;&t;&t; * case the cable was pulled and will later be&n;&t;&t;&t; * re-attached.  The target may forget its negotiation&n;&t;&t;&t; * settings with us should it attempt to reselect&n;&t;&t;&t; * during the interruption.  The target will not issue&n;&t;&t;&t; * a unit attention in this case, so we must always&n;&t;&t;&t; * renegotiate.&n;&t;&t;&t; */
id|ahd_scb_devinfo
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
comma
id|scb
)paren
suffix:semicolon
id|ahd_force_renegotiation
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
)paren
suffix:semicolon
id|ahd_set_transaction_status
c_func
(paren
id|scb
comma
id|CAM_SEL_TIMEOUT
)paren
suffix:semicolon
id|ahd_freeze_devq
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
)brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRINT
comma
id|CLRSCSIINT
)paren
suffix:semicolon
id|ahd_iocell_first_selection
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_unpause
c_func
(paren
id|ahd
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|status0
op_amp
(paren
id|SELDI
op_or
id|SELDO
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|ahd_iocell_first_selection
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_unpause
c_func
(paren
id|ahd
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status3
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: SCSI Cell parity error SSTAT3 == 0x%x&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|status3
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRSINT3
comma
id|status3
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|lqistat1
op_amp
(paren
id|LQIPHASE_LQ
op_or
id|LQIPHASE_NLQ
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|ahd_handle_lqiphase_error
c_func
(paren
id|ahd
comma
id|lqistat1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|lqistat1
op_amp
id|LQICRCI_NLQ
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * This status can be delayed during some&n;&t;&t; * streaming operations.  The SCSIPHASE&n;&t;&t; * handler has already dealt with this case&n;&t;&t; * so just clear the error.&n;&t;&t; */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRLQIINT1
comma
id|CLRLQICRCI_NLQ
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|status
op_amp
id|BUSFREE
)paren
op_ne
l_int|0
)paren
(brace
id|u_int
id|lqostat1
suffix:semicolon
r_int
id|restart
suffix:semicolon
r_int
id|clear_fifo
suffix:semicolon
r_int
id|packetized
suffix:semicolon
id|u_int
id|mode
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Clear our selection hardware as soon as possible.&n;&t;&t; * We may have an entry in the waiting Q for this target,&n;&t;&t; * that is affected by this busfree and we don&squot;t want to&n;&t;&t; * go about selecting the target while we handle the event.&n;&t;&t; */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCSISEQ0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Determine what we were up to at the time of&n;&t;&t; * the busfree.&n;&t;&t; */
id|mode
op_assign
id|AHD_MODE_SCSI
suffix:semicolon
id|busfreetime
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SSTAT2
)paren
op_amp
id|BUSFREETIME
suffix:semicolon
id|lqostat1
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LQOSTAT1
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|busfreetime
)paren
(brace
r_case
id|BUSFREE_DFF0
suffix:colon
r_case
id|BUSFREE_DFF1
suffix:colon
(brace
id|u_int
id|scbid
suffix:semicolon
r_struct
id|scb
op_star
id|scb
suffix:semicolon
id|mode
op_assign
id|busfreetime
op_eq
id|BUSFREE_DFF0
ques
c_cond
id|AHD_MODE_DFF0
suffix:colon
id|AHD_MODE_DFF1
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|mode
comma
id|mode
)paren
suffix:semicolon
id|scbid
op_assign
id|ahd_get_scbptr
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|scb
op_assign
id|ahd_lookup_scb
c_func
(paren
id|ahd
comma
id|scbid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: Invalid SCB in DFF%d &quot;
l_string|&quot;during unexpected busfree&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|mode
)paren
suffix:semicolon
id|packetized
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|packetized
op_assign
(paren
id|scb-&gt;flags
op_amp
id|SCB_PACKETIZED
)paren
op_ne
l_int|0
suffix:semicolon
id|clear_fifo
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|BUSFREE_LQO
suffix:colon
id|clear_fifo
op_assign
l_int|0
suffix:semicolon
id|packetized
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|clear_fifo
op_assign
l_int|0
suffix:semicolon
id|packetized
op_assign
(paren
id|lqostat1
op_amp
id|LQOBUSFREE
)paren
op_ne
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|packetized
op_logical_and
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LASTPHASE
)paren
op_eq
id|P_BUSFREE
)paren
id|packetized
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_MISC
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;Saw Busfree.  Busfreetime = 0x%x.&bslash;n&quot;
comma
id|busfreetime
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t; * Busfrees that occur in non-packetized phases are&n;&t;&t; * handled by the nonpkt_busfree handler.&n;&t;&t; */
r_if
c_cond
(paren
id|packetized
op_logical_and
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LASTPHASE
)paren
op_eq
id|P_BUSFREE
)paren
(brace
id|restart
op_assign
id|ahd_handle_pkt_busfree
c_func
(paren
id|ahd
comma
id|busfreetime
)paren
suffix:semicolon
)brace
r_else
(brace
id|packetized
op_assign
l_int|0
suffix:semicolon
id|restart
op_assign
id|ahd_handle_nonpkt_busfree
c_func
(paren
id|ahd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Clear the busfree interrupt status.  The setting of&n;&t;&t; * the interrupt is a pulse, so in a perfect world, we&n;&t;&t; * would not need to muck with the ENBUSFREE logic.  This&n;&t;&t; * would ensure that if the bus moves on to another&n;&t;&t; * connection, busfree protection is still in force.  If&n;&t;&t; * BUSFREEREV is broken, however, we must manually clear&n;&t;&t; * the ENBUSFREE if the busfree occurred during a non-pack&n;&t;&t; * connection so that we don&squot;t get false positives during&n;&t;&t; * future, packetized, connections.&n;&t;&t; */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRSINT1
comma
id|CLRBUSFREE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|packetized
op_eq
l_int|0
op_logical_and
(paren
id|ahd-&gt;bugs
op_amp
id|AHD_BUSFREEREV_BUG
)paren
op_ne
l_int|0
)paren
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SIMODE1
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SIMODE1
)paren
op_amp
op_complement
id|ENBUSFREE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clear_fifo
)paren
id|ahd_clear_fifo
c_func
(paren
id|ahd
comma
id|mode
)paren
suffix:semicolon
id|ahd_clear_msg_state
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRINT
comma
id|CLRSCSIINT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|restart
)paren
(brace
id|ahd_restart
c_func
(paren
id|ahd
)paren
suffix:semicolon
)brace
r_else
(brace
id|ahd_unpause
c_func
(paren
id|ahd
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;%s: Missing case in ahd_handle_scsiint. status = %x&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|status
)paren
suffix:semicolon
id|ahd_dump_card_state
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_clear_intstat
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_unpause
c_func
(paren
id|ahd
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|ahd_handle_transmission_error
id|ahd_handle_transmission_error
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
r_struct
id|scb
op_star
id|scb
suffix:semicolon
id|u_int
id|scbid
suffix:semicolon
id|u_int
id|lqistat1
suffix:semicolon
id|u_int
id|lqistat2
suffix:semicolon
id|u_int
id|msg_out
suffix:semicolon
id|u_int
id|curphase
suffix:semicolon
id|u_int
id|lastphase
suffix:semicolon
id|u_int
id|perrdiag
suffix:semicolon
id|u_int
id|cur_col
suffix:semicolon
r_int
id|silent
suffix:semicolon
id|scb
op_assign
l_int|NULL
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI
comma
id|AHD_MODE_SCSI
)paren
suffix:semicolon
id|lqistat1
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LQISTAT1
)paren
op_amp
op_complement
(paren
id|LQIPHASE_LQ
op_or
id|LQIPHASE_NLQ
)paren
suffix:semicolon
id|lqistat2
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LQISTAT2
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lqistat1
op_amp
(paren
id|LQICRCI_NLQ
op_or
id|LQICRCI_LQ
)paren
)paren
op_eq
l_int|0
op_logical_and
(paren
id|ahd-&gt;bugs
op_amp
id|AHD_NLQICRC_DELAYED_BUG
)paren
op_ne
l_int|0
)paren
(brace
id|u_int
id|lqistate
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_CFG
comma
id|AHD_MODE_CFG
)paren
suffix:semicolon
id|lqistate
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LQISTATE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lqistate
op_ge
l_int|0x1E
op_logical_and
id|lqistate
op_le
l_int|0x24
)paren
op_logical_or
(paren
id|lqistate
op_eq
l_int|0x29
)paren
)paren
(brace
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_RECOVERY
)paren
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: NLQCRC found via LQISTATE&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|lqistat1
op_or_assign
id|LQICRCI_NLQ
suffix:semicolon
)brace
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI
comma
id|AHD_MODE_SCSI
)paren
suffix:semicolon
)brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRLQIINT1
comma
id|lqistat1
)paren
suffix:semicolon
id|lastphase
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LASTPHASE
)paren
suffix:semicolon
id|curphase
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSISIGI
)paren
op_amp
id|PHASE_MASK
suffix:semicolon
id|perrdiag
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|PERRDIAG
)paren
suffix:semicolon
id|msg_out
op_assign
id|MSG_INITIATOR_DET_ERR
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRSINT1
comma
id|CLRSCSIPERR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Try to find the SCB associated with this error.&n;&t; */
id|silent
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|lqistat1
op_eq
l_int|0
op_logical_or
(paren
id|lqistat1
op_amp
id|LQICRCI_NLQ
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|lqistat1
op_amp
(paren
id|LQICRCI_NLQ
op_or
id|LQIOVERI_NLQ
)paren
)paren
op_ne
l_int|0
)paren
id|ahd_set_active_fifo
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|scbid
op_assign
id|ahd_get_scbptr
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|scb
op_assign
id|ahd_lookup_scb
c_func
(paren
id|ahd
comma
id|scbid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_ne
l_int|NULL
op_logical_and
id|SCB_IS_SILENT
c_func
(paren
id|scb
)paren
)paren
id|silent
op_assign
id|TRUE
suffix:semicolon
)brace
id|cur_col
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|silent
op_eq
id|FALSE
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: Transmission error detected&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
id|ahd_lqistat1_print
c_func
(paren
id|lqistat1
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_lastphase_print
c_func
(paren
id|lastphase
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_scsisigi_print
c_func
(paren
id|curphase
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_perrdiag_print
c_func
(paren
id|perrdiag
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|ahd_dump_card_state
c_func
(paren
id|ahd
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|lqistat1
op_amp
(paren
id|LQIOVERI_LQ
op_or
id|LQIOVERI_NLQ
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|silent
op_eq
id|FALSE
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: Gross protocol error during incoming &quot;
l_string|&quot;packet.  lqistat1 == 0x%x.  Resetting bus.&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|lqistat1
)paren
suffix:semicolon
)brace
id|ahd_reset_channel
c_func
(paren
id|ahd
comma
l_char|&squot;A&squot;
comma
multiline_comment|/*Initiate Reset*/
id|TRUE
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|lqistat1
op_amp
id|LQICRCI_LQ
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * A CRC error has been detected on an incoming LQ.&n;&t;&t; * The bus is currently hung on the last ACK.&n;&t;&t; * Hit LQIRETRY to release the last ack, and&n;&t;&t; * wait for the sequencer to determine that ATNO&n;&t;&t; * is asserted while in message out to take us&n;&t;&t; * to our host message loop.  No NONPACKREQ or&n;&t;&t; * LQIPHASE type errors will occur in this&n;&t;&t; * scenario.  After this first LQIRETRY, the LQI&n;&t;&t; * manager will be in ISELO where it will&n;&t;&t; * happily sit until another packet phase begins.&n;&t;&t; * Unexpected bus free detection is enabled&n;&t;&t; * through any phases that occur after we release&n;&t;&t; * this last ack until the LQI manager sees a&n;&t;&t; * packet phase.  This implies we may have to&n;&t;&t; * ignore a perfectly valid &quot;unexected busfree&quot;&n;&t;&t; * after our &quot;initiator detected error&quot; message is&n;&t;&t; * sent.  A busfree is the expected response after&n;&t;&t; * we tell the target that it&squot;s L_Q was corrupted.&n;&t;&t; * (SPI4R09 10.7.3.3.3)&n;&t;&t; */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|LQCTL2
comma
id|LQIRETRY
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;LQIRetry for LQICRCI_LQ to release ACK&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|lqistat1
op_amp
id|LQICRCI_NLQ
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * We detected a CRC error in a NON-LQ packet.&n;&t;&t; * The hardware has varying behavior in this situation&n;&t;&t; * depending on whether this packet was part of a&n;&t;&t; * stream or not.&n;&t;&t; *&n;&t;&t; * PKT by PKT mode:&n;&t;&t; * The hardware has already acked the complete packet.&n;&t;&t; * If the target honors our outstanding ATN condition,&n;&t;&t; * we should be (or soon will be) in MSGOUT phase.&n;&t;&t; * This will trigger the LQIPHASE_LQ status bit as the&n;&t;&t; * hardware was expecting another LQ.  Unexpected&n;&t;&t; * busfree detection is enabled.  Once LQIPHASE_LQ is&n;&t;&t; * true (first entry into host message loop is much&n;&t;&t; * the same), we must clear LQIPHASE_LQ and hit&n;&t;&t; * LQIRETRY so the hardware is ready to handle&n;&t;&t; * a future LQ.  NONPACKREQ will not be asserted again&n;&t;&t; * once we hit LQIRETRY until another packet is&n;&t;&t; * processed.  The target may either go busfree&n;&t;&t; * or start another packet in response to our message.&n;&t;&t; *&n;&t;&t; * Read Streaming P0 asserted:&n;&t;&t; * If we raise ATN and the target completes the entire&n;&t;&t; * stream (P0 asserted during the last packet), the&n;&t;&t; * hardware will ack all data and return to the ISTART&n;&t;&t; * state.  When the target reponds to our ATN condition,&n;&t;&t; * LQIPHASE_LQ will be asserted.  We should respond to&n;&t;&t; * this with an LQIRETRY to prepare for any future&n;&t;&t; * packets.  NONPACKREQ will not be asserted again&n;&t;&t; * once we hit LQIRETRY until another packet is&n;&t;&t; * processed.  The target may either go busfree or&n;&t;&t; * start another packet in response to our message.&n;&t;&t; * Busfree detection is enabled.&n;&t;&t; *&n;&t;&t; * Read Streaming P0 not asserted:&n;&t;&t; * If we raise ATN and the target transitions to&n;&t;&t; * MSGOUT in or after a packet where P0 is not&n;&t;&t; * asserted, the hardware will assert LQIPHASE_NLQ.&n;&t;&t; * We should respond to the LQIPHASE_NLQ with an&n;&t;&t; * LQIRETRY.  Should the target stay in a non-pkt&n;&t;&t; * phase after we send our message, the hardware&n;&t;&t; * will assert LQIPHASE_LQ.  Recovery is then just as&n;&t;&t; * listed above for the read streaming with P0 asserted.&n;&t;&t; * Busfree detection is enabled.&n;&t;&t; */
r_if
c_cond
(paren
id|silent
op_eq
id|FALSE
)paren
id|printf
c_func
(paren
l_string|&quot;LQICRC_NLQ&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: No SCB valid for LQICRC_NLQ.  &quot;
l_string|&quot;Resetting bus&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
id|ahd_reset_channel
c_func
(paren
id|ahd
comma
l_char|&squot;A&squot;
comma
multiline_comment|/*Initiate Reset*/
id|TRUE
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|lqistat1
op_amp
id|LQIBADLQI
)paren
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Need to handle BADLQI!&bslash;n&quot;
)paren
suffix:semicolon
id|ahd_reset_channel
c_func
(paren
id|ahd
comma
l_char|&squot;A&squot;
comma
multiline_comment|/*Initiate Reset*/
id|TRUE
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|perrdiag
op_amp
(paren
id|PARITYERR
op_or
id|PREVPHASE
)paren
)paren
op_eq
id|PARITYERR
)paren
(brace
r_if
c_cond
(paren
(paren
id|curphase
op_amp
op_complement
id|P_DATAIN_DT
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Ack the byte.  So we can continue. */
r_if
c_cond
(paren
id|silent
op_eq
id|FALSE
)paren
id|printf
c_func
(paren
l_string|&quot;Acking %s to clear perror&bslash;n&quot;
comma
id|ahd_lookup_phase_entry
c_func
(paren
id|curphase
)paren
op_member_access_from_pointer
id|phasemsg
)paren
suffix:semicolon
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSIDAT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|curphase
op_eq
id|P_MESGIN
)paren
id|msg_out
op_assign
id|MSG_PARITY_ERROR
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We&squot;ve set the hardware to assert ATN if we &n;&t; * get a parity error on &quot;in&quot; phases, so all we&n;&t; * need to do is stuff the message buffer with&n;&t; * the appropriate message.  &quot;In&quot; phases have set&n;&t; * mesg_out to something other than MSG_NOP.&n;&t; */
id|ahd-&gt;send_msg_perror
op_assign
id|msg_out
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_ne
l_int|NULL
op_logical_and
id|msg_out
op_eq
id|MSG_INITIATOR_DET_ERR
)paren
id|scb-&gt;flags
op_or_assign
id|SCB_TRANSMISSION_ERROR
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|MSG_OUT
comma
id|HOST_MSG
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRINT
comma
id|CLRSCSIINT
)paren
suffix:semicolon
id|ahd_unpause
c_func
(paren
id|ahd
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahd_handle_lqiphase_error
id|ahd_handle_lqiphase_error
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
id|u_int
id|lqistat1
)paren
(brace
multiline_comment|/*&n;&t; * Clear the sources of the interrupts.&n;&t; */
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI
comma
id|AHD_MODE_SCSI
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRLQIINT1
comma
id|lqistat1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the &quot;illegal&quot; phase changes were in response&n;&t; * to our ATN to flag a CRC error, AND we ended up&n;&t; * on packet boundaries, clear the error, restart the&n;&t; * LQI manager as appropriate, and go on our merry&n;&t; * way toward sending the message.  Otherwise, reset&n;&t; * the bus to clear the error.&n;&t; */
id|ahd_set_active_fifo
c_func
(paren
id|ahd
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSISIGO
)paren
op_amp
id|ATNO
)paren
op_ne
l_int|0
op_logical_and
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|MDFFSTAT
)paren
op_amp
id|DLZERO
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|lqistat1
op_amp
id|LQIPHASE_LQ
)paren
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;LQIRETRY for LQIPHASE_LQ&bslash;n&quot;
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|LQCTL2
comma
id|LQIRETRY
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|lqistat1
op_amp
id|LQIPHASE_NLQ
)paren
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;LQIRETRY for LQIPHASE_NLQ&bslash;n&quot;
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|LQCTL2
comma
id|LQIRETRY
)paren
suffix:semicolon
)brace
r_else
id|panic
c_func
(paren
l_string|&quot;ahd_handle_lqiphase_error: No phase errors&bslash;n&quot;
)paren
suffix:semicolon
id|ahd_dump_card_state
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRINT
comma
id|CLRSCSIINT
)paren
suffix:semicolon
id|ahd_unpause
c_func
(paren
id|ahd
)paren
suffix:semicolon
)brace
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;Reseting Channel for LQI Phase error&bslash;n&quot;
)paren
suffix:semicolon
id|ahd_dump_card_state
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_reset_channel
c_func
(paren
id|ahd
comma
l_char|&squot;A&squot;
comma
multiline_comment|/*Initiate Reset*/
id|TRUE
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Packetized unexpected or expected busfree.&n; * Entered in mode based on busfreetime.&n; */
r_static
r_int
DECL|function|ahd_handle_pkt_busfree
id|ahd_handle_pkt_busfree
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
id|u_int
id|busfreetime
)paren
(brace
id|u_int
id|lqostat1
suffix:semicolon
id|AHD_ASSERT_MODES
c_func
(paren
id|ahd
comma
op_complement
(paren
id|AHD_MODE_UNKNOWN_MSK
op_or
id|AHD_MODE_CFG_MSK
)paren
comma
op_complement
(paren
id|AHD_MODE_UNKNOWN_MSK
op_or
id|AHD_MODE_CFG_MSK
)paren
)paren
suffix:semicolon
id|lqostat1
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LQOSTAT1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lqostat1
op_amp
id|LQOBUSFREE
)paren
op_ne
l_int|0
)paren
(brace
r_struct
id|scb
op_star
id|scb
suffix:semicolon
id|u_int
id|scbid
suffix:semicolon
id|u_int
id|saved_scbptr
suffix:semicolon
id|u_int
id|waiting_h
suffix:semicolon
id|u_int
id|waiting_t
suffix:semicolon
id|u_int
id|next
suffix:semicolon
r_if
c_cond
(paren
(paren
id|busfreetime
op_amp
id|BUSFREE_LQO
)paren
op_eq
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;%s: Warning, BUSFREE time is 0x%x.  &quot;
l_string|&quot;Expected BUSFREE_LQO.&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|busfreetime
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The LQO manager detected an unexpected busfree&n;&t;&t; * either:&n;&t;&t; *&n;&t;&t; * 1) During an outgoing LQ.&n;&t;&t; * 2) After an outgoing LQ but before the first&n;&t;&t; *    REQ of the command packet.&n;&t;&t; * 3) During an outgoing command packet.&n;&t;&t; *&n;&t;&t; * In all cases, CURRSCB is pointing to the&n;&t;&t; * SCB that encountered the failure.  Clean&n;&t;&t; * up the queue, clear SELDO and LQOBUSFREE,&n;&t;&t; * and allow the sequencer to restart the select&n;&t;&t; * out at its lesure.&n;&t;&t; */
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI
comma
id|AHD_MODE_SCSI
)paren
suffix:semicolon
id|scbid
op_assign
id|ahd_inw
c_func
(paren
id|ahd
comma
id|CURRSCB
)paren
suffix:semicolon
id|scb
op_assign
id|ahd_lookup_scb
c_func
(paren
id|ahd
comma
id|scbid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;SCB not valid during LQOBUSFREE&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Clear the status.&n;&t;&t; */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRLQOINT1
comma
id|CLRLQOBUSFREE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;bugs
op_amp
id|AHD_CLRLQO_AUTOCLR_BUG
)paren
op_ne
l_int|0
)paren
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRLQOINT1
comma
l_int|0
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCSISEQ0
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSISEQ0
)paren
op_amp
op_complement
id|ENSELO
)paren
suffix:semicolon
id|ahd_flush_device_writes
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRSINT0
comma
id|CLRSELDO
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Return the LQO manager to its idle loop.  It will&n;&t;&t; * not do this automatically if the busfree occurs&n;&t;&t; * after the first REQ of either the LQ or command&n;&t;&t; * packet or between the LQ and command packet.&n;&t;&t; */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|LQCTL2
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LQCTL2
)paren
op_or
id|LQOTOIDLE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Update the waiting for selection queue so&n;&t;&t; * we restart on the correct SCB.&n;&t;&t; */
id|waiting_h
op_assign
id|ahd_inw
c_func
(paren
id|ahd
comma
id|WAITING_TID_HEAD
)paren
suffix:semicolon
id|saved_scbptr
op_assign
id|ahd_get_scbptr
c_func
(paren
id|ahd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waiting_h
op_ne
id|scbid
)paren
(brace
id|ahd_outw
c_func
(paren
id|ahd
comma
id|WAITING_TID_HEAD
comma
id|scbid
)paren
suffix:semicolon
id|waiting_t
op_assign
id|ahd_inw
c_func
(paren
id|ahd
comma
id|WAITING_TID_TAIL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waiting_t
op_eq
id|waiting_h
)paren
(brace
id|ahd_outw
c_func
(paren
id|ahd
comma
id|WAITING_TID_TAIL
comma
id|scbid
)paren
suffix:semicolon
id|next
op_assign
id|SCB_LIST_NULL
suffix:semicolon
)brace
r_else
(brace
id|ahd_set_scbptr
c_func
(paren
id|ahd
comma
id|waiting_h
)paren
suffix:semicolon
id|next
op_assign
id|ahd_inw
c_func
(paren
id|ahd
comma
id|SCB_NEXT2
)paren
suffix:semicolon
)brace
id|ahd_set_scbptr
c_func
(paren
id|ahd
comma
id|scbid
)paren
suffix:semicolon
id|ahd_outw
c_func
(paren
id|ahd
comma
id|SCB_NEXT2
comma
id|next
)paren
suffix:semicolon
)brace
id|ahd_set_scbptr
c_func
(paren
id|ahd
comma
id|saved_scbptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb-&gt;crc_retry_count
OL
id|AHD_MAX_LQ_CRC_ERRORS
)paren
(brace
r_if
c_cond
(paren
id|SCB_IS_SILENT
c_func
(paren
id|scb
)paren
op_eq
id|FALSE
)paren
(brace
id|ahd_print_path
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Probable outgoing LQ CRC error.  &quot;
l_string|&quot;Retrying command&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|scb-&gt;crc_retry_count
op_increment
suffix:semicolon
)brace
r_else
(brace
id|ahd_set_transaction_status
c_func
(paren
id|scb
comma
id|CAM_UNCOR_PARITY
)paren
suffix:semicolon
id|ahd_freeze_scb
c_func
(paren
id|scb
)paren
suffix:semicolon
id|ahd_freeze_devq
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
)brace
multiline_comment|/* Return unpausing the sequencer. */
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|PERRDIAG
)paren
op_amp
id|PARITYERR
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Ignore what are really parity errors that&n;&t;&t; * occur on the last REQ of a free running&n;&t;&t; * clock prior to going busfree.  Some drives&n;&t;&t; * do not properly active negate just before&n;&t;&t; * going busfree resulting in a parity glitch.&n;&t;&t; */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRSINT1
comma
id|CLRSCSIPERR
op_or
id|CLRBUSFREE
)paren
suffix:semicolon
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_MASKED_ERRORS
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;%s: Parity on last REQ detected &quot;
l_string|&quot;during busfree phase.&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Return unpausing the sequencer. */
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ahd-&gt;src_mode
op_ne
id|AHD_MODE_SCSI
)paren
(brace
id|u_int
id|scbid
suffix:semicolon
r_struct
id|scb
op_star
id|scb
suffix:semicolon
id|scbid
op_assign
id|ahd_get_scbptr
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|scb
op_assign
id|ahd_lookup_scb
c_func
(paren
id|ahd
comma
id|scbid
)paren
suffix:semicolon
id|ahd_print_path
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Unexpected PKT busfree condition&bslash;n&quot;
)paren
suffix:semicolon
id|ahd_dump_card_state
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_abort_scbs
c_func
(paren
id|ahd
comma
id|SCB_GET_TARGET
c_func
(paren
id|ahd
comma
id|scb
)paren
comma
l_char|&squot;A&squot;
comma
id|SCB_GET_LUN
c_func
(paren
id|scb
)paren
comma
id|SCB_GET_TAG
c_func
(paren
id|scb
)paren
comma
id|ROLE_INITIATOR
comma
id|CAM_UNEXP_BUSFREE
)paren
suffix:semicolon
multiline_comment|/* Return restarting the sequencer. */
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;%s: Unexpected PKT busfree condition&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
id|ahd_dump_card_state
c_func
(paren
id|ahd
)paren
suffix:semicolon
multiline_comment|/* Restart the sequencer. */
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Non-packetized unexpected or expected busfree.&n; */
r_static
r_int
DECL|function|ahd_handle_nonpkt_busfree
id|ahd_handle_nonpkt_busfree
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
r_struct
id|ahd_devinfo
id|devinfo
suffix:semicolon
r_struct
id|scb
op_star
id|scb
suffix:semicolon
id|u_int
id|lastphase
suffix:semicolon
id|u_int
id|saved_scsiid
suffix:semicolon
id|u_int
id|saved_lun
suffix:semicolon
id|u_int
id|target
suffix:semicolon
id|u_int
id|initiator_role_id
suffix:semicolon
id|u_int
id|scbid
suffix:semicolon
id|u_int
id|ppr_busfree
suffix:semicolon
r_int
id|printerror
suffix:semicolon
multiline_comment|/*&n;&t; * Look at what phase we were last in.  If its message out,&n;&t; * chances are pretty good that the busfree was in response&n;&t; * to one of our abort requests.&n;&t; */
id|lastphase
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LASTPHASE
)paren
suffix:semicolon
id|saved_scsiid
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SAVED_SCSIID
)paren
suffix:semicolon
id|saved_lun
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SAVED_LUN
)paren
suffix:semicolon
id|target
op_assign
id|SCSIID_TARGET
c_func
(paren
id|ahd
comma
id|saved_scsiid
)paren
suffix:semicolon
id|initiator_role_id
op_assign
id|SCSIID_OUR_ID
c_func
(paren
id|saved_scsiid
)paren
suffix:semicolon
id|ahd_compile_devinfo
c_func
(paren
op_amp
id|devinfo
comma
id|initiator_role_id
comma
id|target
comma
id|saved_lun
comma
l_char|&squot;A&squot;
comma
id|ROLE_INITIATOR
)paren
suffix:semicolon
id|printerror
op_assign
l_int|1
suffix:semicolon
id|scbid
op_assign
id|ahd_get_scbptr
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|scb
op_assign
id|ahd_lookup_scb
c_func
(paren
id|ahd
comma
id|scbid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_ne
l_int|NULL
op_logical_and
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SEQ_FLAGS
)paren
op_amp
id|NOT_IDENTIFIED
)paren
op_ne
l_int|0
)paren
id|scb
op_assign
l_int|NULL
suffix:semicolon
id|ppr_busfree
op_assign
(paren
id|ahd-&gt;msg_flags
op_amp
id|MSG_FLAG_EXPECT_PPR_BUSFREE
)paren
op_ne
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|lastphase
op_eq
id|P_MESGOUT
)paren
(brace
id|u_int
id|tag
suffix:semicolon
id|tag
op_assign
id|SCB_LIST_NULL
suffix:semicolon
r_if
c_cond
(paren
id|ahd_sent_msg
c_func
(paren
id|ahd
comma
id|AHDMSG_1B
comma
id|MSG_ABORT_TAG
comma
id|TRUE
)paren
op_logical_or
id|ahd_sent_msg
c_func
(paren
id|ahd
comma
id|AHDMSG_1B
comma
id|MSG_ABORT
comma
id|TRUE
)paren
)paren
(brace
r_int
id|found
suffix:semicolon
r_int
id|sent_msg
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
id|ahd_print_devinfo
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Abort for unidentified &quot;
l_string|&quot;connection completed.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* restart the sequencer. */
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|sent_msg
op_assign
id|ahd-&gt;msgout_buf
(braket
id|ahd-&gt;msgout_index
op_minus
l_int|1
)braket
suffix:semicolon
id|ahd_print_path
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;SCB %d - Abort%s Completed.&bslash;n&quot;
comma
id|SCB_GET_TAG
c_func
(paren
id|scb
)paren
comma
id|sent_msg
op_eq
id|MSG_ABORT_TAG
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot; Tag&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sent_msg
op_eq
id|MSG_ABORT_TAG
)paren
id|tag
op_assign
id|SCB_GET_TAG
c_func
(paren
id|scb
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_CMDPHASE_ABORT
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * This abort is in response to an&n;&t;&t;&t;&t; * unexpected switch to command phase&n;&t;&t;&t;&t; * for a packetized connection.  Since&n;&t;&t;&t;&t; * the identify message was never sent,&n;&t;&t;&t;&t; * &quot;saved lun&quot; is 0.  We really want to&n;&t;&t;&t;&t; * abort only the SCB that encountered&n;&t;&t;&t;&t; * this error, which could have a different&n;&t;&t;&t;&t; * lun.  The SCB will be retried so the OS&n;&t;&t;&t;&t; * will see the UA after renegotiating to&n;&t;&t;&t;&t; * packetized.&n;&t;&t;&t;&t; */
id|tag
op_assign
id|SCB_GET_TAG
c_func
(paren
id|scb
)paren
suffix:semicolon
id|saved_lun
op_assign
id|scb-&gt;hscb-&gt;lun
suffix:semicolon
)brace
id|found
op_assign
id|ahd_abort_scbs
c_func
(paren
id|ahd
comma
id|target
comma
l_char|&squot;A&squot;
comma
id|saved_lun
comma
id|tag
comma
id|ROLE_INITIATOR
comma
id|CAM_REQ_ABORTED
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;found == 0x%x&bslash;n&quot;
comma
id|found
)paren
suffix:semicolon
id|printerror
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ahd_sent_msg
c_func
(paren
id|ahd
comma
id|AHDMSG_1B
comma
id|MSG_BUS_DEV_RESET
comma
id|TRUE
)paren
)paren
(brace
macro_line|#ifdef __FreeBSD__
multiline_comment|/*&n;&t;&t;&t; * Don&squot;t mark the user&squot;s request for this BDR&n;&t;&t;&t; * as completing with CAM_BDR_SENT.  CAM3&n;&t;&t;&t; * specifies CAM_REQ_CMP.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|scb
op_ne
l_int|NULL
op_logical_and
id|scb-&gt;io_ctx-&gt;ccb_h.func_code
op_eq
id|XPT_RESET_DEV
op_logical_and
id|ahd_match_scb
c_func
(paren
id|ahd
comma
id|scb
comma
id|target
comma
l_char|&squot;A&squot;
comma
id|CAM_LUN_WILDCARD
comma
id|SCB_LIST_NULL
comma
id|ROLE_INITIATOR
)paren
)paren
id|ahd_set_transaction_status
c_func
(paren
id|scb
comma
id|CAM_REQ_CMP
)paren
suffix:semicolon
macro_line|#endif
id|ahd_handle_devreset
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
comma
id|CAM_LUN_WILDCARD
comma
id|CAM_BDR_SENT
comma
l_string|&quot;Bus Device Reset&quot;
comma
multiline_comment|/*verbose_level*/
l_int|0
)paren
suffix:semicolon
id|printerror
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ahd_sent_msg
c_func
(paren
id|ahd
comma
id|AHDMSG_EXT
comma
id|MSG_EXT_PPR
comma
id|FALSE
)paren
op_logical_and
id|ppr_busfree
op_eq
l_int|0
)paren
(brace
r_struct
id|ahd_initiator_tinfo
op_star
id|tinfo
suffix:semicolon
r_struct
id|ahd_tmode_tstate
op_star
id|tstate
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * PPR Rejected.  Try non-ppr negotiation&n;&t;&t;&t; * and retry command.&n;&t;&t;&t; */
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_MESSAGES
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;PPR negotiation rejected busfree.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|tinfo
op_assign
id|ahd_fetch_transinfo
c_func
(paren
id|ahd
comma
id|devinfo.channel
comma
id|devinfo.our_scsiid
comma
id|devinfo.target
comma
op_amp
id|tstate
)paren
suffix:semicolon
id|tinfo-&gt;curr.transport_version
op_assign
l_int|2
suffix:semicolon
id|tinfo-&gt;goal.transport_version
op_assign
l_int|2
suffix:semicolon
id|tinfo-&gt;goal.ppr_options
op_assign
l_int|0
suffix:semicolon
id|ahd_qinfifo_requeue_tail
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|printerror
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|ahd_sent_msg
c_func
(paren
id|ahd
comma
id|AHDMSG_EXT
comma
id|MSG_EXT_WDTR
comma
id|FALSE
)paren
op_logical_or
id|ahd_sent_msg
c_func
(paren
id|ahd
comma
id|AHDMSG_EXT
comma
id|MSG_EXT_SDTR
comma
id|FALSE
)paren
)paren
op_logical_and
id|ppr_busfree
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Negotiation Rejected.  Go-async and&n;&t;&t;&t; * retry command.&n;&t;&t;&t; */
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_MESSAGES
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;Negotiation rejected busfree.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|ahd_set_width
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
comma
id|MSG_EXT_WDTR_BUS_8_BIT
comma
id|AHD_TRANS_CUR
op_or
id|AHD_TRANS_GOAL
comma
multiline_comment|/*paused*/
id|TRUE
)paren
suffix:semicolon
id|ahd_set_syncrate
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
comma
multiline_comment|/*period*/
l_int|0
comma
multiline_comment|/*offset*/
l_int|0
comma
multiline_comment|/*ppr_options*/
l_int|0
comma
id|AHD_TRANS_CUR
op_or
id|AHD_TRANS_GOAL
comma
multiline_comment|/*paused*/
id|TRUE
)paren
suffix:semicolon
id|ahd_qinfifo_requeue_tail
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|printerror
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|ahd-&gt;msg_flags
op_amp
id|MSG_FLAG_EXPECT_IDE_BUSFREE
)paren
op_ne
l_int|0
op_logical_and
id|ahd_sent_msg
c_func
(paren
id|ahd
comma
id|AHDMSG_1B
comma
id|MSG_INITIATOR_DET_ERR
comma
id|TRUE
)paren
)paren
(brace
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_MESSAGES
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;Expected IDE Busfree&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|printerror
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|ahd-&gt;msg_flags
op_amp
id|MSG_FLAG_EXPECT_QASREJ_BUSFREE
)paren
op_logical_and
id|ahd_sent_msg
c_func
(paren
id|ahd
comma
id|AHDMSG_1B
comma
id|MSG_MESSAGE_REJECT
comma
id|TRUE
)paren
)paren
(brace
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_MESSAGES
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;Expected QAS Reject Busfree&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|printerror
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * The busfree required flag is honored at the end of&n;&t; * the message phases.  We check it last in case we&n;&t; * had to send some other message that caused a busfree.&n;&t; */
r_if
c_cond
(paren
id|printerror
op_ne
l_int|0
op_logical_and
(paren
id|lastphase
op_eq
id|P_MESGIN
op_logical_or
id|lastphase
op_eq
id|P_MESGOUT
)paren
op_logical_and
(paren
(paren
id|ahd-&gt;msg_flags
op_amp
id|MSG_FLAG_EXPECT_PPR_BUSFREE
)paren
op_ne
l_int|0
)paren
)paren
(brace
id|ahd_freeze_devq
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|ahd_set_transaction_status
c_func
(paren
id|scb
comma
id|CAM_REQUEUE_REQ
)paren
suffix:semicolon
id|ahd_freeze_scb
c_func
(paren
id|scb
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;msg_flags
op_amp
id|MSG_FLAG_IU_REQ_CHANGED
)paren
op_ne
l_int|0
)paren
(brace
id|ahd_abort_scbs
c_func
(paren
id|ahd
comma
id|SCB_GET_TARGET
c_func
(paren
id|ahd
comma
id|scb
)paren
comma
id|SCB_GET_CHANNEL
c_func
(paren
id|ahd
comma
id|scb
)paren
comma
id|SCB_GET_LUN
c_func
(paren
id|scb
)paren
comma
id|SCB_LIST_NULL
comma
id|ROLE_INITIATOR
comma
id|CAM_REQ_ABORTED
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_MESSAGES
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;PPR Negotiation Busfree.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|ahd_done
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
)brace
id|printerror
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|printerror
op_ne
l_int|0
)paren
(brace
r_int
id|aborted
suffix:semicolon
id|aborted
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_ne
l_int|NULL
)paren
(brace
id|u_int
id|tag
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb-&gt;hscb-&gt;control
op_amp
id|TAG_ENB
)paren
op_ne
l_int|0
)paren
id|tag
op_assign
id|SCB_GET_TAG
c_func
(paren
id|scb
)paren
suffix:semicolon
r_else
id|tag
op_assign
id|SCB_LIST_NULL
suffix:semicolon
id|ahd_print_path
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|aborted
op_assign
id|ahd_abort_scbs
c_func
(paren
id|ahd
comma
id|target
comma
l_char|&squot;A&squot;
comma
id|SCB_GET_LUN
c_func
(paren
id|scb
)paren
comma
id|tag
comma
id|ROLE_INITIATOR
comma
id|CAM_UNEXP_BUSFREE
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * We had not fully identified this connection,&n;&t;&t;&t; * so we cannot abort anything.&n;&t;&t;&t; */
id|printf
c_func
(paren
l_string|&quot;%s: &quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lastphase
op_ne
id|P_BUSFREE
)paren
id|ahd_force_renegotiation
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Unexpected busfree %s, %d SCBs aborted, &quot;
l_string|&quot;PRGMCNT == 0x%x&bslash;n&quot;
comma
id|ahd_lookup_phase_entry
c_func
(paren
id|lastphase
)paren
op_member_access_from_pointer
id|phasemsg
comma
id|aborted
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|PRGMCNT
)paren
op_or
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|PRGMCNT
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
id|ahd_dump_card_state
c_func
(paren
id|ahd
)paren
suffix:semicolon
)brace
multiline_comment|/* Always restart the sequencer. */
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahd_handle_proto_violation
id|ahd_handle_proto_violation
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
r_struct
id|ahd_devinfo
id|devinfo
suffix:semicolon
r_struct
id|scb
op_star
id|scb
suffix:semicolon
id|u_int
id|scbid
suffix:semicolon
id|u_int
id|seq_flags
suffix:semicolon
id|u_int
id|curphase
suffix:semicolon
id|u_int
id|lastphase
suffix:semicolon
r_int
id|found
suffix:semicolon
id|ahd_fetch_devinfo
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
)paren
suffix:semicolon
id|scbid
op_assign
id|ahd_get_scbptr
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|scb
op_assign
id|ahd_lookup_scb
c_func
(paren
id|ahd
comma
id|scbid
)paren
suffix:semicolon
id|seq_flags
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SEQ_FLAGS
)paren
suffix:semicolon
id|curphase
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSISIGI
)paren
op_amp
id|PHASE_MASK
suffix:semicolon
id|lastphase
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LASTPHASE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|seq_flags
op_amp
id|NOT_IDENTIFIED
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * The reconnecting target either did not send an&n;&t;&t; * identify message, or did, but we didn&squot;t find an SCB&n;&t;&t; * to match.&n;&t;&t; */
id|ahd_print_devinfo
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Target did not send an IDENTIFY message. &quot;
l_string|&quot;LASTPHASE = 0x%x.&bslash;n&quot;
comma
id|lastphase
)paren
suffix:semicolon
id|scb
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * We don&squot;t seem to have an SCB active for this&n;&t;&t; * transaction.  Print an error and reset the bus.&n;&t;&t; */
id|ahd_print_devinfo
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;No SCB found during protocol violation&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|proto_violation_reset
suffix:semicolon
)brace
r_else
(brace
id|ahd_set_transaction_status
c_func
(paren
id|scb
comma
id|CAM_SEQUENCE_FAIL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|seq_flags
op_amp
id|NO_CDB_SENT
)paren
op_ne
l_int|0
)paren
(brace
id|ahd_print_path
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;No or incomplete CDB sent to device.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCB_CONTROL
)paren
op_amp
id|STATUS_RCVD
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * The target never bothered to provide status to&n;&t;&t;&t; * us prior to completing the command.  Since we don&squot;t&n;&t;&t;&t; * know the disposition of this command, we must attempt&n;&t;&t;&t; * to abort it.  Assert ATN and prepare to send an abort&n;&t;&t;&t; * message.&n;&t;&t;&t; */
id|ahd_print_path
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Completed command without status.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|ahd_print_path
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Unknown protocol violation.&bslash;n&quot;
)paren
suffix:semicolon
id|ahd_dump_card_state
c_func
(paren
id|ahd
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|lastphase
op_amp
op_complement
id|P_DATAIN_DT
)paren
op_eq
l_int|0
op_logical_or
id|lastphase
op_eq
id|P_COMMAND
)paren
(brace
id|proto_violation_reset
suffix:colon
multiline_comment|/*&n;&t;&t; * Target either went directly to data&n;&t;&t; * phase or didn&squot;t respond to our ATN.&n;&t;&t; * The only safe thing to do is to blow&n;&t;&t; * it away with a bus reset.&n;&t;&t; */
id|found
op_assign
id|ahd_reset_channel
c_func
(paren
id|ahd
comma
l_char|&squot;A&squot;
comma
id|TRUE
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s: Issued Channel %c Bus Reset. &quot;
l_string|&quot;%d SCBs aborted&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
l_char|&squot;A&squot;
comma
id|found
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Leave the selection hardware off in case&n;&t;&t; * this abort attempt will affect yet to&n;&t;&t; * be sent commands.&n;&t;&t; */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCSISEQ0
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSISEQ0
)paren
op_amp
op_complement
id|ENSELO
)paren
suffix:semicolon
id|ahd_assert_atn
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|MSG_OUT
comma
id|HOST_MSG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
id|ahd_print_devinfo
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
)paren
suffix:semicolon
id|ahd-&gt;msgout_buf
(braket
l_int|0
)braket
op_assign
id|MSG_ABORT_TASK
suffix:semicolon
id|ahd-&gt;msgout_len
op_assign
l_int|1
suffix:semicolon
id|ahd-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|ahd-&gt;msg_type
op_assign
id|MSG_TYPE_INITIATOR_MSGOUT
suffix:semicolon
)brace
r_else
(brace
id|ahd_print_path
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_ABORT
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;Protocol violation %s.  Attempting to abort.&bslash;n&quot;
comma
id|ahd_lookup_phase_entry
c_func
(paren
id|curphase
)paren
op_member_access_from_pointer
id|phasemsg
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Force renegotiation to occur the next time we initiate&n; * a command to the current device.&n; */
r_static
r_void
DECL|function|ahd_force_renegotiation
id|ahd_force_renegotiation
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_devinfo
op_star
id|devinfo
)paren
(brace
r_struct
id|ahd_initiator_tinfo
op_star
id|targ_info
suffix:semicolon
r_struct
id|ahd_tmode_tstate
op_star
id|tstate
suffix:semicolon
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_MESSAGES
)paren
op_ne
l_int|0
)paren
(brace
id|ahd_print_devinfo
c_func
(paren
id|ahd
comma
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Forcing renegotiation&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|targ_info
op_assign
id|ahd_fetch_transinfo
c_func
(paren
id|ahd
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;our_scsiid
comma
id|devinfo-&gt;target
comma
op_amp
id|tstate
)paren
suffix:semicolon
id|ahd_update_neg_request
c_func
(paren
id|ahd
comma
id|devinfo
comma
id|tstate
comma
id|targ_info
comma
id|AHD_NEG_IF_NON_ASYNC
)paren
suffix:semicolon
)brace
DECL|macro|AHD_MAX_STEPS
mdefine_line|#define AHD_MAX_STEPS 2000
r_void
DECL|function|ahd_clear_critical_section
id|ahd_clear_critical_section
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
id|ahd_mode_state
id|saved_modes
suffix:semicolon
r_int
id|stepping
suffix:semicolon
r_int
id|steps
suffix:semicolon
r_int
id|first_instr
suffix:semicolon
id|u_int
id|simode0
suffix:semicolon
id|u_int
id|simode1
suffix:semicolon
id|u_int
id|simode3
suffix:semicolon
id|u_int
id|lqimode0
suffix:semicolon
id|u_int
id|lqimode1
suffix:semicolon
id|u_int
id|lqomode0
suffix:semicolon
id|u_int
id|lqomode1
suffix:semicolon
r_if
c_cond
(paren
id|ahd-&gt;num_critical_sections
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|stepping
op_assign
id|FALSE
suffix:semicolon
id|steps
op_assign
l_int|0
suffix:semicolon
id|first_instr
op_assign
l_int|0
suffix:semicolon
id|simode0
op_assign
l_int|0
suffix:semicolon
id|simode1
op_assign
l_int|0
suffix:semicolon
id|simode3
op_assign
l_int|0
suffix:semicolon
id|lqimode0
op_assign
l_int|0
suffix:semicolon
id|lqimode1
op_assign
l_int|0
suffix:semicolon
id|lqomode0
op_assign
l_int|0
suffix:semicolon
id|lqomode1
op_assign
l_int|0
suffix:semicolon
id|saved_modes
op_assign
id|ahd_save_modes
c_func
(paren
id|ahd
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|cs
op_star
id|cs
suffix:semicolon
id|u_int
id|seqaddr
suffix:semicolon
id|u_int
id|i
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI
comma
id|AHD_MODE_SCSI
)paren
suffix:semicolon
id|seqaddr
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|CURADDR
)paren
op_or
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|CURADDR
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
id|cs
op_assign
id|ahd-&gt;critical_sections
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ahd-&gt;num_critical_sections
suffix:semicolon
id|i
op_increment
comma
id|cs
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cs-&gt;begin
OL
id|seqaddr
op_logical_and
id|cs-&gt;end
op_ge
id|seqaddr
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|ahd-&gt;num_critical_sections
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|steps
OG
id|AHD_MAX_STEPS
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: Infinite loop in critical section&bslash;n&quot;
l_string|&quot;%s: First Instruction 0x%x now 0x%x&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|first_instr
comma
id|seqaddr
)paren
suffix:semicolon
id|ahd_dump_card_state
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;critical section loop&quot;
)paren
suffix:semicolon
)brace
id|steps
op_increment
suffix:semicolon
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_MISC
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;%s: Single stepping at 0x%x&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|seqaddr
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|stepping
op_eq
id|FALSE
)paren
(brace
id|first_instr
op_assign
id|seqaddr
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_CFG
comma
id|AHD_MODE_CFG
)paren
suffix:semicolon
id|simode0
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SIMODE0
)paren
suffix:semicolon
id|simode3
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SIMODE3
)paren
suffix:semicolon
id|lqimode0
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LQIMODE0
)paren
suffix:semicolon
id|lqimode1
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LQIMODE1
)paren
suffix:semicolon
id|lqomode0
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LQOMODE0
)paren
suffix:semicolon
id|lqomode1
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LQOMODE1
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SIMODE0
comma
l_int|0
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SIMODE3
comma
l_int|0
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|LQIMODE0
comma
l_int|0
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|LQIMODE1
comma
l_int|0
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|LQOMODE0
comma
l_int|0
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|LQOMODE1
comma
l_int|0
)paren
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI
comma
id|AHD_MODE_SCSI
)paren
suffix:semicolon
id|simode1
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SIMODE1
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SIMODE1
comma
id|ENBUSFREE
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SEQCTL0
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SEQCTL0
)paren
op_or
id|STEP
)paren
suffix:semicolon
id|stepping
op_assign
id|TRUE
suffix:semicolon
)brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRSINT1
comma
id|CLRBUSFREE
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRINT
comma
id|CLRSCSIINT
)paren
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|ahd-&gt;saved_src_mode
comma
id|ahd-&gt;saved_dst_mode
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|HCNTRL
comma
id|ahd-&gt;unpause
)paren
suffix:semicolon
r_do
(brace
id|ahd_delay
c_func
(paren
l_int|200
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|ahd_is_paused
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
id|ahd_update_modes
c_func
(paren
id|ahd
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stepping
)paren
(brace
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_CFG
comma
id|AHD_MODE_CFG
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SIMODE0
comma
id|simode0
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SIMODE3
comma
id|simode3
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|LQIMODE0
comma
id|lqimode0
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|LQIMODE1
comma
id|lqimode1
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|LQOMODE0
comma
id|lqomode0
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|LQOMODE1
comma
id|lqomode1
)paren
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI
comma
id|AHD_MODE_SCSI
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SEQCTL0
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SEQCTL0
)paren
op_amp
op_complement
id|STEP
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SIMODE1
comma
id|simode1
)paren
suffix:semicolon
)brace
id|ahd_restore_modes
c_func
(paren
id|ahd
comma
id|saved_modes
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Clear any pending interrupt status.&n; */
r_void
DECL|function|ahd_clear_intstat
id|ahd_clear_intstat
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
id|AHD_ASSERT_MODES
c_func
(paren
id|ahd
comma
op_complement
(paren
id|AHD_MODE_UNKNOWN_MSK
op_or
id|AHD_MODE_CFG_MSK
)paren
comma
op_complement
(paren
id|AHD_MODE_UNKNOWN_MSK
op_or
id|AHD_MODE_CFG_MSK
)paren
)paren
suffix:semicolon
multiline_comment|/* Clear any interrupt conditions this may have caused */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRLQIINT0
comma
id|CLRLQIATNQAS
op_or
id|CLRLQICRCT1
op_or
id|CLRLQICRCT2
op_or
id|CLRLQIBADLQT
op_or
id|CLRLQIATNLQ
op_or
id|CLRLQIATNCMD
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRLQIINT1
comma
id|CLRLQIPHASE_LQ
op_or
id|CLRLQIPHASE_NLQ
op_or
id|CLRLIQABORT
op_or
id|CLRLQICRCI_LQ
op_or
id|CLRLQICRCI_NLQ
op_or
id|CLRLQIBADLQI
op_or
id|CLRLQIOVERI_LQ
op_or
id|CLRLQIOVERI_NLQ
op_or
id|CLRNONPACKREQ
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRLQOINT0
comma
id|CLRLQOTARGSCBPERR
op_or
id|CLRLQOSTOPT2
op_or
id|CLRLQOATNLQ
op_or
id|CLRLQOATNPKT
op_or
id|CLRLQOTCRC
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRLQOINT1
comma
id|CLRLQOINITSCBPERR
op_or
id|CLRLQOSTOPI2
op_or
id|CLRLQOBADQAS
op_or
id|CLRLQOBUSFREE
op_or
id|CLRLQOPHACHGINPKT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;bugs
op_amp
id|AHD_CLRLQO_AUTOCLR_BUG
)paren
op_ne
l_int|0
)paren
(brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRLQOINT0
comma
l_int|0
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRLQOINT1
comma
l_int|0
)paren
suffix:semicolon
)brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRSINT3
comma
id|CLRNTRAMPERR
op_or
id|CLROSRAMPERR
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRSINT1
comma
id|CLRSELTIMEO
op_or
id|CLRATNO
op_or
id|CLRSCSIRSTI
op_or
id|CLRBUSFREE
op_or
id|CLRSCSIPERR
op_or
id|CLRREQINIT
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRSINT0
comma
id|CLRSELDO
op_or
id|CLRSELDI
op_or
id|CLRSELINGO
op_or
id|CLRIOERR
op_or
id|CLROVERRUN
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRINT
comma
id|CLRSCSIINT
)paren
suffix:semicolon
)brace
multiline_comment|/**************************** Debugging Routines ******************************/
macro_line|#ifdef AHD_DEBUG
DECL|variable|ahd_debug
r_uint32
id|ahd_debug
op_assign
id|AHD_DEBUG_OPTS
suffix:semicolon
macro_line|#endif
r_void
DECL|function|ahd_print_scb
id|ahd_print_scb
c_func
(paren
r_struct
id|scb
op_star
id|scb
)paren
(brace
r_struct
id|hardware_scb
op_star
id|hscb
suffix:semicolon
r_int
id|i
suffix:semicolon
id|hscb
op_assign
id|scb-&gt;hscb
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;scb:%p control:0x%x scsiid:0x%x lun:%d cdb_len:%d&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|scb
comma
id|hscb-&gt;control
comma
id|hscb-&gt;scsiid
comma
id|hscb-&gt;lun
comma
id|hscb-&gt;cdb_len
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Shared Data: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|hscb-&gt;shared_data.idata.cdb
)paren
suffix:semicolon
id|i
op_increment
)paren
id|printf
c_func
(paren
l_string|&quot;%#02x&quot;
comma
id|hscb-&gt;shared_data.idata.cdb
(braket
id|i
)braket
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;        dataptr:%#x%x datacnt:%#x sgptr:%#x tag:%#x&bslash;n&quot;
comma
(paren
r_uint32
)paren
(paren
(paren
id|ahd_le64toh
c_func
(paren
id|hscb-&gt;dataptr
)paren
op_rshift
l_int|32
)paren
op_amp
l_int|0xFFFFFFFF
)paren
comma
(paren
r_uint32
)paren
(paren
id|ahd_le64toh
c_func
(paren
id|hscb-&gt;dataptr
)paren
op_amp
l_int|0xFFFFFFFF
)paren
comma
id|ahd_le32toh
c_func
(paren
id|hscb-&gt;datacnt
)paren
comma
id|ahd_le32toh
c_func
(paren
id|hscb-&gt;sgptr
)paren
comma
id|SCB_GET_TAG
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
id|ahd_dump_sglist
c_func
(paren
id|scb
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahd_dump_sglist
id|ahd_dump_sglist
c_func
(paren
r_struct
id|scb
op_star
id|scb
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|scb-&gt;sg_count
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|scb-&gt;ahd_softc-&gt;flags
op_amp
id|AHD_64BIT_ADDRESSING
)paren
op_ne
l_int|0
)paren
(brace
r_struct
id|ahd_dma64_seg
op_star
id|sg_list
suffix:semicolon
id|sg_list
op_assign
(paren
r_struct
id|ahd_dma64_seg
op_star
)paren
id|scb-&gt;sg_list
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|scb-&gt;sg_count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_uint64
id|addr
suffix:semicolon
r_uint32
id|len
suffix:semicolon
id|addr
op_assign
id|ahd_le64toh
c_func
(paren
id|sg_list
(braket
id|i
)braket
dot
id|addr
)paren
suffix:semicolon
id|len
op_assign
id|ahd_le32toh
c_func
(paren
id|sg_list
(braket
id|i
)braket
dot
id|len
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;sg[%d] - Addr 0x%x%x : Length %d%s&bslash;n&quot;
comma
id|i
comma
(paren
r_uint32
)paren
(paren
(paren
id|addr
op_rshift
l_int|32
)paren
op_amp
l_int|0xFFFFFFFF
)paren
comma
(paren
r_uint32
)paren
(paren
id|addr
op_amp
l_int|0xFFFFFFFF
)paren
comma
id|sg_list
(braket
id|i
)braket
dot
id|len
op_amp
id|AHD_SG_LEN_MASK
comma
(paren
id|sg_list
(braket
id|i
)braket
dot
id|len
op_amp
id|AHD_DMA_LAST_SEG
)paren
ques
c_cond
l_string|&quot; Last&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_struct
id|ahd_dma_seg
op_star
id|sg_list
suffix:semicolon
id|sg_list
op_assign
(paren
r_struct
id|ahd_dma_seg
op_star
)paren
id|scb-&gt;sg_list
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|scb-&gt;sg_count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_uint32
id|len
suffix:semicolon
id|len
op_assign
id|ahd_le32toh
c_func
(paren
id|sg_list
(braket
id|i
)braket
dot
id|len
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;sg[%d] - Addr 0x%x%x : Length %d%s&bslash;n&quot;
comma
id|i
comma
(paren
id|len
op_rshift
l_int|24
)paren
op_amp
id|SG_HIGH_ADDR_BITS
comma
id|ahd_le32toh
c_func
(paren
id|sg_list
(braket
id|i
)braket
dot
id|addr
)paren
comma
id|len
op_amp
id|AHD_SG_LEN_MASK
comma
id|len
op_amp
id|AHD_DMA_LAST_SEG
ques
c_cond
l_string|&quot; Last&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/************************* Transfer Negotiation *******************************/
multiline_comment|/*&n; * Allocate per target mode instance (ID we respond to as a target)&n; * transfer negotiation data structures.&n; */
r_static
r_struct
id|ahd_tmode_tstate
op_star
DECL|function|ahd_alloc_tstate
id|ahd_alloc_tstate
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
id|u_int
id|scsi_id
comma
r_char
id|channel
)paren
(brace
r_struct
id|ahd_tmode_tstate
op_star
id|master_tstate
suffix:semicolon
r_struct
id|ahd_tmode_tstate
op_star
id|tstate
suffix:semicolon
r_int
id|i
suffix:semicolon
id|master_tstate
op_assign
id|ahd-&gt;enabled_targets
(braket
id|ahd-&gt;our_id
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ahd-&gt;enabled_targets
(braket
id|scsi_id
)braket
op_ne
l_int|NULL
op_logical_and
id|ahd-&gt;enabled_targets
(braket
id|scsi_id
)braket
op_ne
id|master_tstate
)paren
id|panic
c_func
(paren
l_string|&quot;%s: ahd_alloc_tstate - Target already allocated&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
id|tstate
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|tstate
)paren
comma
id|M_DEVBUF
comma
id|M_NOWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tstate
op_eq
l_int|NULL
)paren
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we have allocated a master tstate, copy user settings from&n;&t; * the master tstate (taken from SRAM or the EEPROM) for this&n;&t; * channel, but reset our current and goal settings to async/narrow&n;&t; * until an initiator talks to us.&n;&t; */
r_if
c_cond
(paren
id|master_tstate
op_ne
l_int|NULL
)paren
(brace
id|memcpy
c_func
(paren
id|tstate
comma
id|master_tstate
comma
r_sizeof
(paren
op_star
id|tstate
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|tstate-&gt;enabled_luns
comma
l_int|0
comma
r_sizeof
(paren
id|tstate-&gt;enabled_luns
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|memset
c_func
(paren
op_amp
id|tstate-&gt;transinfo
(braket
id|i
)braket
dot
id|curr
comma
l_int|0
comma
r_sizeof
(paren
id|tstate-&gt;transinfo
(braket
id|i
)braket
dot
id|curr
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|tstate-&gt;transinfo
(braket
id|i
)braket
dot
id|goal
comma
l_int|0
comma
r_sizeof
(paren
id|tstate-&gt;transinfo
(braket
id|i
)braket
dot
id|goal
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
id|memset
c_func
(paren
id|tstate
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|tstate
)paren
)paren
suffix:semicolon
id|ahd-&gt;enabled_targets
(braket
id|scsi_id
)braket
op_assign
id|tstate
suffix:semicolon
r_return
(paren
id|tstate
)paren
suffix:semicolon
)brace
macro_line|#ifdef AHD_TARGET_MODE
multiline_comment|/*&n; * Free per target mode instance (ID we respond to as a target)&n; * transfer negotiation data structures.&n; */
r_static
r_void
DECL|function|ahd_free_tstate
id|ahd_free_tstate
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
id|u_int
id|scsi_id
comma
r_char
id|channel
comma
r_int
id|force
)paren
(brace
r_struct
id|ahd_tmode_tstate
op_star
id|tstate
suffix:semicolon
multiline_comment|/*&n;&t; * Don&squot;t clean up our &quot;master&quot; tstate.&n;&t; * It has our default user settings.&n;&t; */
r_if
c_cond
(paren
id|scsi_id
op_eq
id|ahd-&gt;our_id
op_logical_and
id|force
op_eq
id|FALSE
)paren
r_return
suffix:semicolon
id|tstate
op_assign
id|ahd-&gt;enabled_targets
(braket
id|scsi_id
)braket
suffix:semicolon
r_if
c_cond
(paren
id|tstate
op_ne
l_int|NULL
)paren
id|free
c_func
(paren
id|tstate
comma
id|M_DEVBUF
)paren
suffix:semicolon
id|ahd-&gt;enabled_targets
(braket
id|scsi_id
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Called when we have an active connection to a target on the bus,&n; * this function finds the nearest period to the input period limited&n; * by the capabilities of the bus connectivity of and sync settings for&n; * the target.&n; */
r_void
DECL|function|ahd_devlimited_syncrate
id|ahd_devlimited_syncrate
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_initiator_tinfo
op_star
id|tinfo
comma
id|u_int
op_star
id|period
comma
id|u_int
op_star
id|ppr_options
comma
id|role_t
id|role
)paren
(brace
r_struct
id|ahd_transinfo
op_star
id|transinfo
suffix:semicolon
id|u_int
id|maxsync
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SBLKCTL
)paren
op_amp
id|ENAB40
)paren
op_ne
l_int|0
op_logical_and
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SSTAT2
)paren
op_amp
id|EXP_ACTIVE
)paren
op_eq
l_int|0
)paren
(brace
id|maxsync
op_assign
id|AHD_SYNCRATE_PACED
suffix:semicolon
)brace
r_else
(brace
id|maxsync
op_assign
id|AHD_SYNCRATE_ULTRA
suffix:semicolon
multiline_comment|/* Can&squot;t do DT related options on an SE bus */
op_star
id|ppr_options
op_and_assign
id|MSG_EXT_PPR_QAS_REQ
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Never allow a value higher than our current goal&n;&t; * period otherwise we may allow a target initiated&n;&t; * negotiation to go above the limit as set by the&n;&t; * user.  In the case of an initiator initiated&n;&t; * sync negotiation, we limit based on the user&n;&t; * setting.  This allows the system to still accept&n;&t; * incoming negotiations even if target initiated&n;&t; * negotiation is not performed.&n;&t; */
r_if
c_cond
(paren
id|role
op_eq
id|ROLE_TARGET
)paren
id|transinfo
op_assign
op_amp
id|tinfo-&gt;user
suffix:semicolon
r_else
id|transinfo
op_assign
op_amp
id|tinfo-&gt;goal
suffix:semicolon
op_star
id|ppr_options
op_and_assign
(paren
id|transinfo-&gt;ppr_options
op_or
id|MSG_EXT_PPR_PCOMP_EN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|transinfo-&gt;width
op_eq
id|MSG_EXT_WDTR_BUS_8_BIT
)paren
(brace
id|maxsync
op_assign
id|MAX
c_func
(paren
id|maxsync
comma
id|AHD_SYNCRATE_ULTRA2
)paren
suffix:semicolon
op_star
id|ppr_options
op_and_assign
op_complement
id|MSG_EXT_PPR_DT_REQ
suffix:semicolon
)brace
r_if
c_cond
(paren
id|transinfo-&gt;period
op_eq
l_int|0
)paren
(brace
op_star
id|period
op_assign
l_int|0
suffix:semicolon
op_star
id|ppr_options
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
op_star
id|period
op_assign
id|MAX
c_func
(paren
op_star
id|period
comma
id|transinfo-&gt;period
)paren
suffix:semicolon
id|ahd_find_syncrate
c_func
(paren
id|ahd
comma
id|period
comma
id|ppr_options
comma
id|maxsync
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Look up the valid period to SCSIRATE conversion in our table.&n; * Return the period and offset that should be sent to the target&n; * if this was the beginning of an SDTR.&n; */
r_void
DECL|function|ahd_find_syncrate
id|ahd_find_syncrate
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
id|u_int
op_star
id|period
comma
id|u_int
op_star
id|ppr_options
comma
id|u_int
id|maxsync
)paren
(brace
r_if
c_cond
(paren
op_star
id|period
OL
id|maxsync
)paren
op_star
id|period
op_assign
id|maxsync
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|ppr_options
op_amp
id|MSG_EXT_PPR_DT_REQ
)paren
op_ne
l_int|0
op_logical_and
op_star
id|period
OG
id|AHD_SYNCRATE_MIN_DT
)paren
op_star
id|ppr_options
op_and_assign
op_complement
id|MSG_EXT_PPR_DT_REQ
suffix:semicolon
r_if
c_cond
(paren
op_star
id|period
OG
id|AHD_SYNCRATE_MIN
)paren
op_star
id|period
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Honor PPR option conformance rules. */
r_if
c_cond
(paren
op_star
id|period
OG
id|AHD_SYNCRATE_PACED
)paren
op_star
id|ppr_options
op_and_assign
op_complement
id|MSG_EXT_PPR_RTI
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|ppr_options
op_amp
id|MSG_EXT_PPR_IU_REQ
)paren
op_eq
l_int|0
)paren
op_star
id|ppr_options
op_and_assign
(paren
id|MSG_EXT_PPR_DT_REQ
op_or
id|MSG_EXT_PPR_QAS_REQ
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|ppr_options
op_amp
id|MSG_EXT_PPR_DT_REQ
)paren
op_eq
l_int|0
)paren
op_star
id|ppr_options
op_and_assign
id|MSG_EXT_PPR_QAS_REQ
suffix:semicolon
multiline_comment|/* Skip all PACED only entries if IU is not available */
r_if
c_cond
(paren
(paren
op_star
id|ppr_options
op_amp
id|MSG_EXT_PPR_IU_REQ
)paren
op_eq
l_int|0
op_logical_and
op_star
id|period
OL
id|AHD_SYNCRATE_DT
)paren
op_star
id|period
op_assign
id|AHD_SYNCRATE_DT
suffix:semicolon
multiline_comment|/* Skip all DT only entries if DT is not available */
r_if
c_cond
(paren
(paren
op_star
id|ppr_options
op_amp
id|MSG_EXT_PPR_DT_REQ
)paren
op_eq
l_int|0
op_logical_and
op_star
id|period
OL
id|AHD_SYNCRATE_ULTRA2
)paren
op_star
id|period
op_assign
id|AHD_SYNCRATE_ULTRA2
suffix:semicolon
)brace
multiline_comment|/*&n; * Truncate the given synchronous offset to a value the&n; * current adapter type and syncrate are capable of.&n; */
r_void
DECL|function|ahd_validate_offset
id|ahd_validate_offset
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_initiator_tinfo
op_star
id|tinfo
comma
id|u_int
id|period
comma
id|u_int
op_star
id|offset
comma
r_int
id|wide
comma
id|role_t
id|role
)paren
(brace
id|u_int
id|maxoffset
suffix:semicolon
multiline_comment|/* Limit offset to what we can do */
r_if
c_cond
(paren
id|period
op_eq
l_int|0
)paren
id|maxoffset
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|period
op_le
id|AHD_SYNCRATE_PACED
)paren
(brace
r_if
c_cond
(paren
(paren
id|ahd-&gt;bugs
op_amp
id|AHD_PACED_NEGTABLE_BUG
)paren
op_ne
l_int|0
)paren
id|maxoffset
op_assign
id|MAX_OFFSET_PACED_BUG
suffix:semicolon
r_else
id|maxoffset
op_assign
id|MAX_OFFSET_PACED
suffix:semicolon
)brace
r_else
id|maxoffset
op_assign
id|MAX_OFFSET_NON_PACED
suffix:semicolon
op_star
id|offset
op_assign
id|MIN
c_func
(paren
op_star
id|offset
comma
id|maxoffset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tinfo
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|role
op_eq
id|ROLE_TARGET
)paren
op_star
id|offset
op_assign
id|MIN
c_func
(paren
op_star
id|offset
comma
id|tinfo-&gt;user.offset
)paren
suffix:semicolon
r_else
op_star
id|offset
op_assign
id|MIN
c_func
(paren
op_star
id|offset
comma
id|tinfo-&gt;goal.offset
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Truncate the given transfer width parameter to a value the&n; * current adapter type is capable of.&n; */
r_void
DECL|function|ahd_validate_width
id|ahd_validate_width
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_initiator_tinfo
op_star
id|tinfo
comma
id|u_int
op_star
id|bus_width
comma
id|role_t
id|role
)paren
(brace
r_switch
c_cond
(paren
op_star
id|bus_width
)paren
(brace
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|ahd-&gt;features
op_amp
id|AHD_WIDE
)paren
(brace
multiline_comment|/* Respond Wide */
op_star
id|bus_width
op_assign
id|MSG_EXT_WDTR_BUS_16_BIT
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* FALLTHROUGH */
r_case
id|MSG_EXT_WDTR_BUS_8_BIT
suffix:colon
op_star
id|bus_width
op_assign
id|MSG_EXT_WDTR_BUS_8_BIT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tinfo
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|role
op_eq
id|ROLE_TARGET
)paren
op_star
id|bus_width
op_assign
id|MIN
c_func
(paren
id|tinfo-&gt;user.width
comma
op_star
id|bus_width
)paren
suffix:semicolon
r_else
op_star
id|bus_width
op_assign
id|MIN
c_func
(paren
id|tinfo-&gt;goal.width
comma
op_star
id|bus_width
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Update the bitmask of targets for which the controller should&n; * negotiate with at the next convenient oportunity.  This currently&n; * means the next time we send the initial identify messages for&n; * a new transaction.&n; */
r_int
DECL|function|ahd_update_neg_request
id|ahd_update_neg_request
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_devinfo
op_star
id|devinfo
comma
r_struct
id|ahd_tmode_tstate
op_star
id|tstate
comma
r_struct
id|ahd_initiator_tinfo
op_star
id|tinfo
comma
id|ahd_neg_type
id|neg_type
)paren
(brace
id|u_int
id|auto_negotiate_orig
suffix:semicolon
id|auto_negotiate_orig
op_assign
id|tstate-&gt;auto_negotiate
suffix:semicolon
r_if
c_cond
(paren
id|neg_type
op_eq
id|AHD_NEG_ALWAYS
)paren
(brace
multiline_comment|/*&n;&t;&t; * Force our &quot;current&quot; settings to be&n;&t;&t; * unknown so that unless a bus reset&n;&t;&t; * occurs the need to renegotiate is&n;&t;&t; * recorded persistently.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ahd-&gt;features
op_amp
id|AHD_WIDE
)paren
op_ne
l_int|0
)paren
id|tinfo-&gt;curr.width
op_assign
id|AHD_WIDTH_UNKNOWN
suffix:semicolon
id|tinfo-&gt;curr.period
op_assign
id|AHD_PERIOD_UNKNOWN
suffix:semicolon
id|tinfo-&gt;curr.offset
op_assign
id|AHD_OFFSET_UNKNOWN
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tinfo-&gt;curr.period
op_ne
id|tinfo-&gt;goal.period
op_logical_or
id|tinfo-&gt;curr.width
op_ne
id|tinfo-&gt;goal.width
op_logical_or
id|tinfo-&gt;curr.offset
op_ne
id|tinfo-&gt;goal.offset
op_logical_or
id|tinfo-&gt;curr.ppr_options
op_ne
id|tinfo-&gt;goal.ppr_options
op_logical_or
(paren
id|neg_type
op_eq
id|AHD_NEG_IF_NON_ASYNC
op_logical_and
(paren
id|tinfo-&gt;goal.offset
op_ne
l_int|0
op_logical_or
id|tinfo-&gt;goal.width
op_ne
id|MSG_EXT_WDTR_BUS_8_BIT
op_logical_or
id|tinfo-&gt;goal.ppr_options
op_ne
l_int|0
)paren
)paren
)paren
id|tstate-&gt;auto_negotiate
op_or_assign
id|devinfo-&gt;target_mask
suffix:semicolon
r_else
id|tstate-&gt;auto_negotiate
op_and_assign
op_complement
id|devinfo-&gt;target_mask
suffix:semicolon
r_return
(paren
id|auto_negotiate_orig
op_ne
id|tstate-&gt;auto_negotiate
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Update the user/goal/curr tables of synchronous negotiation&n; * parameters as well as, in the case of a current or active update,&n; * any data structures on the host controller.  In the case of an&n; * active update, the specified target is currently talking to us on&n; * the bus, so the transfer parameter update must take effect&n; * immediately.&n; */
r_void
DECL|function|ahd_set_syncrate
id|ahd_set_syncrate
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_devinfo
op_star
id|devinfo
comma
id|u_int
id|period
comma
id|u_int
id|offset
comma
id|u_int
id|ppr_options
comma
id|u_int
id|type
comma
r_int
id|paused
)paren
(brace
r_struct
id|ahd_initiator_tinfo
op_star
id|tinfo
suffix:semicolon
r_struct
id|ahd_tmode_tstate
op_star
id|tstate
suffix:semicolon
id|u_int
id|old_period
suffix:semicolon
id|u_int
id|old_offset
suffix:semicolon
id|u_int
id|old_ppr
suffix:semicolon
r_int
id|active
suffix:semicolon
r_int
id|update_needed
suffix:semicolon
id|active
op_assign
(paren
id|type
op_amp
id|AHD_TRANS_ACTIVE
)paren
op_eq
id|AHD_TRANS_ACTIVE
suffix:semicolon
id|update_needed
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|period
op_eq
l_int|0
op_logical_or
id|offset
op_eq
l_int|0
)paren
(brace
id|period
op_assign
l_int|0
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
)brace
id|tinfo
op_assign
id|ahd_fetch_transinfo
c_func
(paren
id|ahd
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;our_scsiid
comma
id|devinfo-&gt;target
comma
op_amp
id|tstate
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|type
op_amp
id|AHD_TRANS_USER
)paren
op_ne
l_int|0
)paren
(brace
id|tinfo-&gt;user.period
op_assign
id|period
suffix:semicolon
id|tinfo-&gt;user.offset
op_assign
id|offset
suffix:semicolon
id|tinfo-&gt;user.ppr_options
op_assign
id|ppr_options
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|type
op_amp
id|AHD_TRANS_GOAL
)paren
op_ne
l_int|0
)paren
(brace
id|tinfo-&gt;goal.period
op_assign
id|period
suffix:semicolon
id|tinfo-&gt;goal.offset
op_assign
id|offset
suffix:semicolon
id|tinfo-&gt;goal.ppr_options
op_assign
id|ppr_options
suffix:semicolon
)brace
id|old_period
op_assign
id|tinfo-&gt;curr.period
suffix:semicolon
id|old_offset
op_assign
id|tinfo-&gt;curr.offset
suffix:semicolon
id|old_ppr
op_assign
id|tinfo-&gt;curr.ppr_options
suffix:semicolon
r_if
c_cond
(paren
(paren
id|type
op_amp
id|AHD_TRANS_CUR
)paren
op_ne
l_int|0
op_logical_and
(paren
id|old_period
op_ne
id|period
op_logical_or
id|old_offset
op_ne
id|offset
op_logical_or
id|old_ppr
op_ne
id|ppr_options
)paren
)paren
(brace
id|update_needed
op_increment
suffix:semicolon
id|tinfo-&gt;curr.period
op_assign
id|period
suffix:semicolon
id|tinfo-&gt;curr.offset
op_assign
id|offset
suffix:semicolon
id|tinfo-&gt;curr.ppr_options
op_assign
id|ppr_options
suffix:semicolon
id|ahd_send_async
c_func
(paren
id|ahd
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|CAM_LUN_WILDCARD
comma
id|AC_TRANSFER_NEG
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
)paren
(brace
r_if
c_cond
(paren
id|offset
op_ne
l_int|0
)paren
(brace
r_int
id|options
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s: target %d synchronous with &quot;
l_string|&quot;period = 0x%x, offset = 0x%x&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|devinfo-&gt;target
comma
id|period
comma
id|offset
)paren
suffix:semicolon
id|options
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ppr_options
op_amp
id|MSG_EXT_PPR_DT_REQ
)paren
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;(DT&quot;
)paren
suffix:semicolon
id|options
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ppr_options
op_amp
id|MSG_EXT_PPR_IU_REQ
)paren
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s&quot;
comma
id|options
ques
c_cond
l_string|&quot;|IU&quot;
suffix:colon
l_string|&quot;(IU&quot;
)paren
suffix:semicolon
id|options
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ppr_options
op_amp
id|MSG_EXT_PPR_RTI
)paren
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s&quot;
comma
id|options
ques
c_cond
l_string|&quot;|RTI&quot;
suffix:colon
l_string|&quot;(RTI&quot;
)paren
suffix:semicolon
id|options
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ppr_options
op_amp
id|MSG_EXT_PPR_QAS_REQ
)paren
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s&quot;
comma
id|options
ques
c_cond
l_string|&quot;|QAS&quot;
suffix:colon
l_string|&quot;(QAS&quot;
)paren
suffix:semicolon
id|options
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|options
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;)&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;%s: target %d using &quot;
l_string|&quot;asynchronous transfers%s&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|devinfo-&gt;target
comma
(paren
id|ppr_options
op_amp
id|MSG_EXT_PPR_QAS_REQ
)paren
op_ne
l_int|0
ques
c_cond
l_string|&quot;(QAS)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * Always refresh the neg-table to handle the case of the&n;&t; * sequencer setting the ENATNO bit for a MK_MESSAGE request.&n;&t; * We will always renegotiate in that case if this is a&n;&t; * packetized request.  Also manage the busfree expected flag&n;&t; * from this common routine so that we catch changes due to&n;&t; * WDTR or SDTR messages.&n;&t; */
r_if
c_cond
(paren
(paren
id|type
op_amp
id|AHD_TRANS_CUR
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|paused
)paren
id|ahd_pause
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_update_neg_table
c_func
(paren
id|ahd
comma
id|devinfo
comma
op_amp
id|tinfo-&gt;curr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|paused
)paren
id|ahd_unpause
c_func
(paren
id|ahd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahd-&gt;msg_type
op_ne
id|MSG_TYPE_NONE
)paren
(brace
r_if
c_cond
(paren
(paren
id|old_ppr
op_amp
id|MSG_EXT_PPR_IU_REQ
)paren
op_ne
(paren
id|ppr_options
op_amp
id|MSG_EXT_PPR_IU_REQ
)paren
)paren
(brace
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_MESSAGES
)paren
op_ne
l_int|0
)paren
(brace
id|ahd_print_devinfo
c_func
(paren
id|ahd
comma
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Expecting IU Change busfree&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|ahd-&gt;msg_flags
op_or_assign
id|MSG_FLAG_EXPECT_PPR_BUSFREE
op_or
id|MSG_FLAG_IU_REQ_CHANGED
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|old_ppr
op_amp
id|MSG_EXT_PPR_IU_REQ
)paren
op_ne
l_int|0
)paren
(brace
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_MESSAGES
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;PPR with IU_REQ outstanding&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|ahd-&gt;msg_flags
op_or_assign
id|MSG_FLAG_EXPECT_PPR_BUSFREE
suffix:semicolon
)brace
)brace
)brace
id|update_needed
op_add_assign
id|ahd_update_neg_request
c_func
(paren
id|ahd
comma
id|devinfo
comma
id|tstate
comma
id|tinfo
comma
id|AHD_NEG_TO_GOAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|update_needed
op_logical_and
id|active
)paren
id|ahd_update_pending_scbs
c_func
(paren
id|ahd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Update the user/goal/curr tables of wide negotiation&n; * parameters as well as, in the case of a current or active update,&n; * any data structures on the host controller.  In the case of an&n; * active update, the specified target is currently talking to us on&n; * the bus, so the transfer parameter update must take effect&n; * immediately.&n; */
r_void
DECL|function|ahd_set_width
id|ahd_set_width
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_devinfo
op_star
id|devinfo
comma
id|u_int
id|width
comma
id|u_int
id|type
comma
r_int
id|paused
)paren
(brace
r_struct
id|ahd_initiator_tinfo
op_star
id|tinfo
suffix:semicolon
r_struct
id|ahd_tmode_tstate
op_star
id|tstate
suffix:semicolon
id|u_int
id|oldwidth
suffix:semicolon
r_int
id|active
suffix:semicolon
r_int
id|update_needed
suffix:semicolon
id|active
op_assign
(paren
id|type
op_amp
id|AHD_TRANS_ACTIVE
)paren
op_eq
id|AHD_TRANS_ACTIVE
suffix:semicolon
id|update_needed
op_assign
l_int|0
suffix:semicolon
id|tinfo
op_assign
id|ahd_fetch_transinfo
c_func
(paren
id|ahd
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;our_scsiid
comma
id|devinfo-&gt;target
comma
op_amp
id|tstate
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|type
op_amp
id|AHD_TRANS_USER
)paren
op_ne
l_int|0
)paren
id|tinfo-&gt;user.width
op_assign
id|width
suffix:semicolon
r_if
c_cond
(paren
(paren
id|type
op_amp
id|AHD_TRANS_GOAL
)paren
op_ne
l_int|0
)paren
id|tinfo-&gt;goal.width
op_assign
id|width
suffix:semicolon
id|oldwidth
op_assign
id|tinfo-&gt;curr.width
suffix:semicolon
r_if
c_cond
(paren
(paren
id|type
op_amp
id|AHD_TRANS_CUR
)paren
op_ne
l_int|0
op_logical_and
id|oldwidth
op_ne
id|width
)paren
(brace
id|update_needed
op_increment
suffix:semicolon
id|tinfo-&gt;curr.width
op_assign
id|width
suffix:semicolon
id|ahd_send_async
c_func
(paren
id|ahd
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|CAM_LUN_WILDCARD
comma
id|AC_TRANSFER_NEG
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: target %d using %dbit transfers&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|devinfo-&gt;target
comma
l_int|8
op_star
(paren
l_int|0x01
op_lshift
id|width
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|type
op_amp
id|AHD_TRANS_CUR
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|paused
)paren
id|ahd_pause
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_update_neg_table
c_func
(paren
id|ahd
comma
id|devinfo
comma
op_amp
id|tinfo-&gt;curr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|paused
)paren
id|ahd_unpause
c_func
(paren
id|ahd
)paren
suffix:semicolon
)brace
id|update_needed
op_add_assign
id|ahd_update_neg_request
c_func
(paren
id|ahd
comma
id|devinfo
comma
id|tstate
comma
id|tinfo
comma
id|AHD_NEG_TO_GOAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|update_needed
op_logical_and
id|active
)paren
id|ahd_update_pending_scbs
c_func
(paren
id|ahd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Update the current state of tagged queuing for a given target.&n; */
r_void
DECL|function|ahd_set_tags
id|ahd_set_tags
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_devinfo
op_star
id|devinfo
comma
id|ahd_queue_alg
id|alg
)paren
(brace
id|ahd_platform_set_tags
c_func
(paren
id|ahd
comma
id|devinfo
comma
id|alg
)paren
suffix:semicolon
id|ahd_send_async
c_func
(paren
id|ahd
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
comma
id|AC_TRANSFER_NEG
comma
op_amp
id|alg
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahd_update_neg_table
id|ahd_update_neg_table
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_devinfo
op_star
id|devinfo
comma
r_struct
id|ahd_transinfo
op_star
id|tinfo
)paren
(brace
id|ahd_mode_state
id|saved_modes
suffix:semicolon
id|u_int
id|period
suffix:semicolon
id|u_int
id|ppr_opts
suffix:semicolon
id|u_int
id|con_opts
suffix:semicolon
id|u_int
id|offset
suffix:semicolon
id|u_int
id|saved_negoaddr
suffix:semicolon
r_uint8
id|iocell_opts
(braket
r_sizeof
(paren
id|ahd-&gt;iocell_opts
)paren
)braket
suffix:semicolon
id|saved_modes
op_assign
id|ahd_save_modes
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI
comma
id|AHD_MODE_SCSI
)paren
suffix:semicolon
id|saved_negoaddr
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|NEGOADDR
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|NEGOADDR
comma
id|devinfo-&gt;target
)paren
suffix:semicolon
id|period
op_assign
id|tinfo-&gt;period
suffix:semicolon
id|offset
op_assign
id|tinfo-&gt;offset
suffix:semicolon
id|memcpy
c_func
(paren
id|iocell_opts
comma
id|ahd-&gt;iocell_opts
comma
r_sizeof
(paren
id|ahd-&gt;iocell_opts
)paren
)paren
suffix:semicolon
id|ppr_opts
op_assign
id|tinfo-&gt;ppr_options
op_amp
(paren
id|MSG_EXT_PPR_QAS_REQ
op_or
id|MSG_EXT_PPR_DT_REQ
op_or
id|MSG_EXT_PPR_IU_REQ
op_or
id|MSG_EXT_PPR_RTI
)paren
suffix:semicolon
id|con_opts
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|period
op_eq
l_int|0
)paren
id|period
op_assign
id|AHD_SYNCRATE_ASYNC
suffix:semicolon
r_if
c_cond
(paren
id|period
op_eq
id|AHD_SYNCRATE_160
)paren
(brace
r_if
c_cond
(paren
(paren
id|ahd-&gt;bugs
op_amp
id|AHD_PACED_NEGTABLE_BUG
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * When the SPI4 spec was finalized, PACE transfers&n;&t;&t;&t; * was not made a configurable option in the PPR&n;&t;&t;&t; * message.  Instead it is assumed to be enabled for&n;&t;&t;&t; * any syncrate faster than 80MHz.  Nevertheless,&n;&t;&t;&t; * Harpoon2A4 allows this to be configurable.&n;&t;&t;&t; *&n;&t;&t;&t; * Harpoon2A4 also assumes at most 2 data bytes per&n;&t;&t;&t; * negotiated REQ/ACK offset.  Paced transfers take&n;&t;&t;&t; * 4, so we must adjust our offset.&n;&t;&t;&t; */
id|ppr_opts
op_or_assign
id|PPROPT_PACE
suffix:semicolon
id|offset
op_mul_assign
l_int|2
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Harpoon2A assumed that there would be a&n;&t;&t;&t; * fallback rate between 160MHz and 80Mhz,&n;&t;&t;&t; * so 7 is used as the period factor rather&n;&t;&t;&t; * than 8 for 160MHz.&n;&t;&t;&t; */
id|period
op_assign
id|AHD_SYNCRATE_REVA_160
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|tinfo-&gt;ppr_options
op_amp
id|MSG_EXT_PPR_PCOMP_EN
)paren
op_eq
l_int|0
)paren
id|iocell_opts
(braket
id|AHD_PRECOMP_SLEW_INDEX
)braket
op_and_assign
op_complement
id|AHD_PRECOMP_MASK
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Precomp should be disabled for non-paced transfers.&n;&t;&t; */
id|iocell_opts
(braket
id|AHD_PRECOMP_SLEW_INDEX
)braket
op_and_assign
op_complement
id|AHD_PRECOMP_MASK
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;features
op_amp
id|AHD_NEW_IOCELL_OPTS
)paren
op_ne
l_int|0
op_logical_and
(paren
id|ppr_opts
op_amp
id|MSG_EXT_PPR_DT_REQ
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Slow down our CRC interval to be&n;&t;&t;&t; * compatible with devices that can&squot;t&n;&t;&t;&t; * handle a CRC at full speed.&n;&t;&t;&t; */
id|con_opts
op_or_assign
id|ENSLOWCRC
suffix:semicolon
)brace
)brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|ANNEXCOL
comma
id|AHD_ANNEXCOL_PRECOMP_SLEW
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|ANNEXDAT
comma
id|iocell_opts
(braket
id|AHD_PRECOMP_SLEW_INDEX
)braket
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|ANNEXCOL
comma
id|AHD_ANNEXCOL_AMPLITUDE
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|ANNEXDAT
comma
id|iocell_opts
(braket
id|AHD_AMPLITUDE_INDEX
)braket
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|NEGPERIOD
comma
id|period
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|NEGPPROPTS
comma
id|ppr_opts
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|NEGOFFSET
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tinfo-&gt;width
op_eq
id|MSG_EXT_WDTR_BUS_16_BIT
)paren
id|con_opts
op_or_assign
id|WIDEXFER
suffix:semicolon
multiline_comment|/*&n;&t; * During packetized transfers, the target will&n;&t; * give us the oportunity to send command packets&n;&t; * without us asserting attention.&n;&t; */
r_if
c_cond
(paren
(paren
id|tinfo-&gt;ppr_options
op_amp
id|MSG_EXT_PPR_IU_REQ
)paren
op_eq
l_int|0
)paren
id|con_opts
op_or_assign
id|ENAUTOATNO
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|NEGCONOPTS
comma
id|con_opts
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|NEGOADDR
comma
id|saved_negoaddr
)paren
suffix:semicolon
id|ahd_restore_modes
c_func
(paren
id|ahd
comma
id|saved_modes
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * When the transfer settings for a connection change, setup for&n; * negotiation in pending SCBs to effect the change as quickly as&n; * possible.  We also cancel any negotiations that are scheduled&n; * for inflight SCBs that have not been started yet.&n; */
r_static
r_void
DECL|function|ahd_update_pending_scbs
id|ahd_update_pending_scbs
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
r_struct
id|scb
op_star
id|pending_scb
suffix:semicolon
r_int
id|pending_scb_count
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|paused
suffix:semicolon
id|u_int
id|saved_scbptr
suffix:semicolon
id|ahd_mode_state
id|saved_modes
suffix:semicolon
multiline_comment|/*&n;&t; * Traverse the pending SCB list and ensure that all of the&n;&t; * SCBs there have the proper settings.  We can only safely&n;&t; * clear the negotiation required flag (setting requires the&n;&t; * execution queue to be modified) and this is only possible&n;&t; * if we are not already attempting to select out for this&n;&t; * SCB.  For this reason, all callers only call this routine&n;&t; * if we are changing the negotiation settings for the currently&n;&t; * active transaction on the bus.&n;&t; */
id|pending_scb_count
op_assign
l_int|0
suffix:semicolon
id|LIST_FOREACH
c_func
(paren
id|pending_scb
comma
op_amp
id|ahd-&gt;pending_scbs
comma
id|pending_links
)paren
(brace
r_struct
id|ahd_devinfo
id|devinfo
suffix:semicolon
r_struct
id|hardware_scb
op_star
id|pending_hscb
suffix:semicolon
r_struct
id|ahd_initiator_tinfo
op_star
id|tinfo
suffix:semicolon
r_struct
id|ahd_tmode_tstate
op_star
id|tstate
suffix:semicolon
id|ahd_scb_devinfo
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
comma
id|pending_scb
)paren
suffix:semicolon
id|tinfo
op_assign
id|ahd_fetch_transinfo
c_func
(paren
id|ahd
comma
id|devinfo.channel
comma
id|devinfo.our_scsiid
comma
id|devinfo.target
comma
op_amp
id|tstate
)paren
suffix:semicolon
id|pending_hscb
op_assign
id|pending_scb-&gt;hscb
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tstate-&gt;auto_negotiate
op_amp
id|devinfo.target_mask
)paren
op_eq
l_int|0
op_logical_and
(paren
id|pending_scb-&gt;flags
op_amp
id|SCB_AUTO_NEGOTIATE
)paren
op_ne
l_int|0
)paren
(brace
id|pending_scb-&gt;flags
op_and_assign
op_complement
id|SCB_AUTO_NEGOTIATE
suffix:semicolon
id|pending_hscb-&gt;control
op_and_assign
op_complement
id|MK_MESSAGE
suffix:semicolon
)brace
id|ahd_sync_scb
c_func
(paren
id|ahd
comma
id|pending_scb
comma
id|BUS_DMASYNC_PREREAD
op_or
id|BUS_DMASYNC_PREWRITE
)paren
suffix:semicolon
id|pending_scb_count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pending_scb_count
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|ahd_is_paused
c_func
(paren
id|ahd
)paren
)paren
(brace
id|paused
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|paused
op_assign
l_int|0
suffix:semicolon
id|ahd_pause
c_func
(paren
id|ahd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Force the sequencer to reinitialize the selection for&n;&t; * the command at the head of the execution queue if it&n;&t; * has already been setup.  The negotiation changes may&n;&t; * effect whether we select-out with ATN.&n;&t; */
id|saved_modes
op_assign
id|ahd_save_modes
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI
comma
id|AHD_MODE_SCSI
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCSISEQ0
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSISEQ0
)paren
op_amp
op_complement
id|ENSELO
)paren
suffix:semicolon
id|saved_scbptr
op_assign
id|ahd_get_scbptr
c_func
(paren
id|ahd
)paren
suffix:semicolon
multiline_comment|/* Ensure that the hscbs down on the card match the new information */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ahd-&gt;scb_data.maxhscbs
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|hardware_scb
op_star
id|pending_hscb
suffix:semicolon
id|u_int
id|control
suffix:semicolon
id|u_int
id|scb_tag
suffix:semicolon
id|ahd_set_scbptr
c_func
(paren
id|ahd
comma
id|i
)paren
suffix:semicolon
id|scb_tag
op_assign
id|i
suffix:semicolon
id|pending_scb
op_assign
id|ahd_lookup_scb
c_func
(paren
id|ahd
comma
id|scb_tag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pending_scb
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|pending_hscb
op_assign
id|pending_scb-&gt;hscb
suffix:semicolon
id|control
op_assign
id|ahd_inb_scbram
c_func
(paren
id|ahd
comma
id|SCB_CONTROL
)paren
suffix:semicolon
id|control
op_and_assign
op_complement
id|MK_MESSAGE
suffix:semicolon
id|control
op_or_assign
id|pending_hscb-&gt;control
op_amp
id|MK_MESSAGE
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCB_CONTROL
comma
id|control
)paren
suffix:semicolon
)brace
id|ahd_set_scbptr
c_func
(paren
id|ahd
comma
id|saved_scbptr
)paren
suffix:semicolon
id|ahd_restore_modes
c_func
(paren
id|ahd
comma
id|saved_modes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|paused
op_eq
l_int|0
)paren
id|ahd_unpause
c_func
(paren
id|ahd
)paren
suffix:semicolon
)brace
multiline_comment|/**************************** Pathing Information *****************************/
r_static
r_void
DECL|function|ahd_fetch_devinfo
id|ahd_fetch_devinfo
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_devinfo
op_star
id|devinfo
)paren
(brace
id|ahd_mode_state
id|saved_modes
suffix:semicolon
id|u_int
id|saved_scsiid
suffix:semicolon
id|role_t
id|role
suffix:semicolon
r_int
id|our_id
suffix:semicolon
id|saved_modes
op_assign
id|ahd_save_modes
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI
comma
id|AHD_MODE_SCSI
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SSTAT0
)paren
op_amp
id|TARGET
)paren
id|role
op_assign
id|ROLE_TARGET
suffix:semicolon
r_else
id|role
op_assign
id|ROLE_INITIATOR
suffix:semicolon
r_if
c_cond
(paren
id|role
op_eq
id|ROLE_TARGET
op_logical_and
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SEQ_FLAGS
)paren
op_amp
id|CMDPHASE_PENDING
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* We were selected, so pull our id from TARGIDIN */
id|our_id
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|TARGIDIN
)paren
op_amp
id|OID
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|role
op_eq
id|ROLE_TARGET
)paren
id|our_id
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|TOWNID
)paren
suffix:semicolon
r_else
id|our_id
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|IOWNID
)paren
suffix:semicolon
id|saved_scsiid
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SAVED_SCSIID
)paren
suffix:semicolon
id|ahd_compile_devinfo
c_func
(paren
id|devinfo
comma
id|our_id
comma
id|SCSIID_TARGET
c_func
(paren
id|ahd
comma
id|saved_scsiid
)paren
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SAVED_LUN
)paren
comma
id|SCSIID_CHANNEL
c_func
(paren
id|ahd
comma
id|saved_scsiid
)paren
comma
id|role
)paren
suffix:semicolon
id|ahd_restore_modes
c_func
(paren
id|ahd
comma
id|saved_modes
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahd_print_devinfo
id|ahd_print_devinfo
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_devinfo
op_star
id|devinfo
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s:%c:%d:%d: &quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
l_char|&squot;A&squot;
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
)paren
suffix:semicolon
)brace
r_struct
id|ahd_phase_table_entry
op_star
DECL|function|ahd_lookup_phase_entry
id|ahd_lookup_phase_entry
c_func
(paren
r_int
id|phase
)paren
(brace
r_struct
id|ahd_phase_table_entry
op_star
id|entry
suffix:semicolon
r_struct
id|ahd_phase_table_entry
op_star
id|last_entry
suffix:semicolon
multiline_comment|/*&n;&t; * num_phases doesn&squot;t include the default entry which&n;&t; * will be returned if the phase doesn&squot;t match.&n;&t; */
id|last_entry
op_assign
op_amp
id|ahd_phase_table
(braket
id|num_phases
)braket
suffix:semicolon
r_for
c_loop
(paren
id|entry
op_assign
id|ahd_phase_table
suffix:semicolon
id|entry
OL
id|last_entry
suffix:semicolon
id|entry
op_increment
)paren
(brace
r_if
c_cond
(paren
id|phase
op_eq
id|entry-&gt;phase
)paren
r_break
suffix:semicolon
)brace
r_return
(paren
id|entry
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahd_compile_devinfo
id|ahd_compile_devinfo
c_func
(paren
r_struct
id|ahd_devinfo
op_star
id|devinfo
comma
id|u_int
id|our_id
comma
id|u_int
id|target
comma
id|u_int
id|lun
comma
r_char
id|channel
comma
id|role_t
id|role
)paren
(brace
id|devinfo-&gt;our_scsiid
op_assign
id|our_id
suffix:semicolon
id|devinfo-&gt;target
op_assign
id|target
suffix:semicolon
id|devinfo-&gt;lun
op_assign
id|lun
suffix:semicolon
id|devinfo-&gt;target_offset
op_assign
id|target
suffix:semicolon
id|devinfo-&gt;channel
op_assign
id|channel
suffix:semicolon
id|devinfo-&gt;role
op_assign
id|role
suffix:semicolon
r_if
c_cond
(paren
id|channel
op_eq
l_char|&squot;B&squot;
)paren
id|devinfo-&gt;target_offset
op_add_assign
l_int|8
suffix:semicolon
id|devinfo-&gt;target_mask
op_assign
(paren
l_int|0x01
op_lshift
id|devinfo-&gt;target_offset
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahd_scb_devinfo
id|ahd_scb_devinfo
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_devinfo
op_star
id|devinfo
comma
r_struct
id|scb
op_star
id|scb
)paren
(brace
id|role_t
id|role
suffix:semicolon
r_int
id|our_id
suffix:semicolon
id|our_id
op_assign
id|SCSIID_OUR_ID
c_func
(paren
id|scb-&gt;hscb-&gt;scsiid
)paren
suffix:semicolon
id|role
op_assign
id|ROLE_INITIATOR
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb-&gt;hscb-&gt;control
op_amp
id|TARGET_SCB
)paren
op_ne
l_int|0
)paren
id|role
op_assign
id|ROLE_TARGET
suffix:semicolon
id|ahd_compile_devinfo
c_func
(paren
id|devinfo
comma
id|our_id
comma
id|SCB_GET_TARGET
c_func
(paren
id|ahd
comma
id|scb
)paren
comma
id|SCB_GET_LUN
c_func
(paren
id|scb
)paren
comma
id|SCB_GET_CHANNEL
c_func
(paren
id|ahd
comma
id|scb
)paren
comma
id|role
)paren
suffix:semicolon
)brace
multiline_comment|/************************ Message Phase Processing ****************************/
multiline_comment|/*&n; * When an initiator transaction with the MK_MESSAGE flag either reconnects&n; * or enters the initial message out phase, we are interrupted.  Fill our&n; * outgoing message buffer with the appropriate message and beging handing&n; * the message phase(s) manually.&n; */
r_static
r_void
DECL|function|ahd_setup_initiator_msgout
id|ahd_setup_initiator_msgout
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_devinfo
op_star
id|devinfo
comma
r_struct
id|scb
op_star
id|scb
)paren
(brace
multiline_comment|/*&n;&t; * To facilitate adding multiple messages together,&n;&t; * each routine should increment the index and len&n;&t; * variables instead of setting them explicitly.&n;&t; */
id|ahd-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|ahd-&gt;msgout_len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ahd_currently_packetized
c_func
(paren
id|ahd
)paren
)paren
id|ahd-&gt;msg_flags
op_or_assign
id|MSG_FLAG_PACKETIZED
suffix:semicolon
r_if
c_cond
(paren
id|ahd-&gt;send_msg_perror
op_logical_and
id|ahd_inb
c_func
(paren
id|ahd
comma
id|MSG_OUT
)paren
op_eq
id|HOST_MSG
)paren
(brace
id|ahd-&gt;msgout_buf
(braket
id|ahd-&gt;msgout_index
op_increment
)braket
op_assign
id|ahd-&gt;send_msg_perror
suffix:semicolon
id|ahd-&gt;msgout_len
op_increment
suffix:semicolon
id|ahd-&gt;msg_type
op_assign
id|MSG_TYPE_INITIATOR_MSGOUT
suffix:semicolon
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_MESSAGES
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;Setting up for Parity Error delivery&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: WARNING. No pending message for &quot;
l_string|&quot;I_T msgin.  Issuing NO-OP&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
id|ahd-&gt;msgout_buf
(braket
id|ahd-&gt;msgout_index
op_increment
)braket
op_assign
id|MSG_NOOP
suffix:semicolon
id|ahd-&gt;msgout_len
op_increment
suffix:semicolon
id|ahd-&gt;msg_type
op_assign
id|MSG_TYPE_INITIATOR_MSGOUT
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_DEVICE_RESET
)paren
op_eq
l_int|0
op_logical_and
(paren
id|scb-&gt;flags
op_amp
id|SCB_PACKETIZED
)paren
op_eq
l_int|0
op_logical_and
id|ahd_inb
c_func
(paren
id|ahd
comma
id|MSG_OUT
)paren
op_eq
id|MSG_IDENTIFYFLAG
)paren
(brace
id|u_int
id|identify_msg
suffix:semicolon
id|identify_msg
op_assign
id|MSG_IDENTIFYFLAG
op_or
id|SCB_GET_LUN
c_func
(paren
id|scb
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb-&gt;hscb-&gt;control
op_amp
id|DISCENB
)paren
op_ne
l_int|0
)paren
id|identify_msg
op_or_assign
id|MSG_IDENTIFY_DISCFLAG
suffix:semicolon
id|ahd-&gt;msgout_buf
(braket
id|ahd-&gt;msgout_index
op_increment
)braket
op_assign
id|identify_msg
suffix:semicolon
id|ahd-&gt;msgout_len
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb-&gt;hscb-&gt;control
op_amp
id|TAG_ENB
)paren
op_ne
l_int|0
)paren
(brace
id|ahd-&gt;msgout_buf
(braket
id|ahd-&gt;msgout_index
op_increment
)braket
op_assign
id|scb-&gt;hscb-&gt;control
op_amp
(paren
id|TAG_ENB
op_or
id|SCB_TAG_TYPE
)paren
suffix:semicolon
id|ahd-&gt;msgout_buf
(braket
id|ahd-&gt;msgout_index
op_increment
)braket
op_assign
id|SCB_GET_TAG
c_func
(paren
id|scb
)paren
suffix:semicolon
id|ahd-&gt;msgout_len
op_add_assign
l_int|2
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|scb-&gt;flags
op_amp
id|SCB_DEVICE_RESET
)paren
(brace
id|ahd-&gt;msgout_buf
(braket
id|ahd-&gt;msgout_index
op_increment
)braket
op_assign
id|MSG_BUS_DEV_RESET
suffix:semicolon
id|ahd-&gt;msgout_len
op_increment
suffix:semicolon
id|ahd_print_path
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Bus Device Reset Message Sent&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Clear our selection hardware in advance of&n;&t;&t; * the busfree.  We may have an entry in the waiting&n;&t;&t; * Q for this target, and we don&squot;t want to go about&n;&t;&t; * selecting while we handle the busfree and blow it&n;&t;&t; * away.&n;&t;&t; */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCSISEQ0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_ABORT
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|scb-&gt;hscb-&gt;control
op_amp
id|TAG_ENB
)paren
op_ne
l_int|0
)paren
(brace
id|ahd-&gt;msgout_buf
(braket
id|ahd-&gt;msgout_index
op_increment
)braket
op_assign
id|MSG_ABORT_TAG
suffix:semicolon
)brace
r_else
(brace
id|ahd-&gt;msgout_buf
(braket
id|ahd-&gt;msgout_index
op_increment
)braket
op_assign
id|MSG_ABORT
suffix:semicolon
)brace
id|ahd-&gt;msgout_len
op_increment
suffix:semicolon
id|ahd_print_path
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Abort%s Message Sent&bslash;n&quot;
comma
(paren
id|scb-&gt;hscb-&gt;control
op_amp
id|TAG_ENB
)paren
op_ne
l_int|0
ques
c_cond
l_string|&quot; Tag&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Clear our selection hardware in advance of&n;&t;&t; * the busfree.  We may have an entry in the waiting&n;&t;&t; * Q for this target, and we don&squot;t want to go about&n;&t;&t; * selecting while we handle the busfree and blow it&n;&t;&t; * away.&n;&t;&t; */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCSISEQ0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
(paren
id|SCB_AUTO_NEGOTIATE
op_or
id|SCB_NEGOTIATE
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|ahd_build_transfer_msg
c_func
(paren
id|ahd
comma
id|devinfo
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Clear our selection hardware in advance of potential&n;&t;&t; * PPR IU status change busfree.  We may have an entry in&n;&t;&t; * the waiting Q for this target, and we don&squot;t want to go&n;&t;&t; * about selecting while we handle the busfree and blow&n;&t;&t; * it away.&n;&t;&t; */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCSISEQ0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;ahd_intr: AWAITING_MSG for an SCB that &quot;
l_string|&quot;does not have a waiting message&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;SCSIID = %x, target_mask = %x&bslash;n&quot;
comma
id|scb-&gt;hscb-&gt;scsiid
comma
id|devinfo-&gt;target_mask
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;SCB = %d, SCB Control = %x:%x, MSG_OUT = %x &quot;
l_string|&quot;SCB flags = %x&quot;
comma
id|SCB_GET_TAG
c_func
(paren
id|scb
)paren
comma
id|scb-&gt;hscb-&gt;control
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCB_CONTROL
)paren
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|MSG_OUT
)paren
comma
id|scb-&gt;flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Clear the MK_MESSAGE flag from the SCB so we aren&squot;t&n;&t; * asked to send this message again.&n;&t; */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCB_CONTROL
comma
id|ahd_inb_scbram
c_func
(paren
id|ahd
comma
id|SCB_CONTROL
)paren
op_amp
op_complement
id|MK_MESSAGE
)paren
suffix:semicolon
id|scb-&gt;hscb-&gt;control
op_and_assign
op_complement
id|MK_MESSAGE
suffix:semicolon
id|ahd-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|ahd-&gt;msg_type
op_assign
id|MSG_TYPE_INITIATOR_MSGOUT
suffix:semicolon
)brace
multiline_comment|/*&n; * Build an appropriate transfer negotiation message for the&n; * currently active target.&n; */
r_static
r_void
DECL|function|ahd_build_transfer_msg
id|ahd_build_transfer_msg
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_devinfo
op_star
id|devinfo
)paren
(brace
multiline_comment|/*&n;&t; * We need to initiate transfer negotiations.&n;&t; * If our current and goal settings are identical,&n;&t; * we want to renegotiate due to a check condition.&n;&t; */
r_struct
id|ahd_initiator_tinfo
op_star
id|tinfo
suffix:semicolon
r_struct
id|ahd_tmode_tstate
op_star
id|tstate
suffix:semicolon
r_int
id|dowide
suffix:semicolon
r_int
id|dosync
suffix:semicolon
r_int
id|doppr
suffix:semicolon
id|u_int
id|period
suffix:semicolon
id|u_int
id|ppr_options
suffix:semicolon
id|u_int
id|offset
suffix:semicolon
id|tinfo
op_assign
id|ahd_fetch_transinfo
c_func
(paren
id|ahd
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;our_scsiid
comma
id|devinfo-&gt;target
comma
op_amp
id|tstate
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Filter our period based on the current connection.&n;&t; * If we can&squot;t perform DT transfers on this segment (not in LVD&n;&t; * mode for instance), then our decision to issue a PPR message&n;&t; * may change.&n;&t; */
id|period
op_assign
id|tinfo-&gt;goal.period
suffix:semicolon
id|ppr_options
op_assign
id|tinfo-&gt;goal.ppr_options
suffix:semicolon
multiline_comment|/* Target initiated PPR is not allowed in the SCSI spec */
r_if
c_cond
(paren
id|devinfo-&gt;role
op_eq
id|ROLE_TARGET
)paren
id|ppr_options
op_assign
l_int|0
suffix:semicolon
id|ahd_devlimited_syncrate
c_func
(paren
id|ahd
comma
id|tinfo
comma
op_amp
id|period
comma
op_amp
id|ppr_options
comma
id|devinfo-&gt;role
)paren
suffix:semicolon
id|dowide
op_assign
id|tinfo-&gt;curr.width
op_ne
id|tinfo-&gt;goal.width
suffix:semicolon
id|dosync
op_assign
id|tinfo-&gt;curr.period
op_ne
id|period
suffix:semicolon
multiline_comment|/*&n;&t; * Only use PPR if we have options that need it, even if the device&n;&t; * claims to support it.  There might be an expander in the way&n;&t; * that doesn&squot;t.&n;&t; */
id|doppr
op_assign
id|ppr_options
op_ne
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dowide
op_logical_and
op_logical_neg
id|dosync
op_logical_and
op_logical_neg
id|doppr
)paren
(brace
id|dowide
op_assign
id|tinfo-&gt;goal.width
op_ne
id|MSG_EXT_WDTR_BUS_8_BIT
suffix:semicolon
id|dosync
op_assign
id|tinfo-&gt;goal.period
op_ne
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dowide
op_logical_and
op_logical_neg
id|dosync
op_logical_and
op_logical_neg
id|doppr
)paren
(brace
multiline_comment|/*&n;&t;&t; * Force async with a WDTR message if we have a wide bus,&n;&t;&t; * or just issue an SDTR with a 0 offset.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ahd-&gt;features
op_amp
id|AHD_WIDE
)paren
op_ne
l_int|0
)paren
id|dowide
op_assign
l_int|1
suffix:semicolon
r_else
id|dosync
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
)paren
(brace
id|ahd_print_devinfo
c_func
(paren
id|ahd
comma
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Ensuring async&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Target initiated PPR is not allowed in the SCSI spec */
r_if
c_cond
(paren
id|devinfo-&gt;role
op_eq
id|ROLE_TARGET
)paren
id|doppr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Both the PPR message and SDTR message require the&n;&t; * goal syncrate to be limited to what the target device&n;&t; * is capable of handling (based on whether an LVD-&gt;SE&n;&t; * expander is on the bus), so combine these two cases.&n;&t; * Regardless, guarantee that if we are using WDTR and SDTR&n;&t; * messages that WDTR comes first.&n;&t; */
r_if
c_cond
(paren
id|doppr
op_logical_or
(paren
id|dosync
op_logical_and
op_logical_neg
id|dowide
)paren
)paren
(brace
id|offset
op_assign
id|tinfo-&gt;goal.offset
suffix:semicolon
id|ahd_validate_offset
c_func
(paren
id|ahd
comma
id|tinfo
comma
id|period
comma
op_amp
id|offset
comma
id|doppr
ques
c_cond
id|tinfo-&gt;goal.width
suffix:colon
id|tinfo-&gt;curr.width
comma
id|devinfo-&gt;role
)paren
suffix:semicolon
r_if
c_cond
(paren
id|doppr
)paren
(brace
id|ahd_construct_ppr
c_func
(paren
id|ahd
comma
id|devinfo
comma
id|period
comma
id|offset
comma
id|tinfo-&gt;goal.width
comma
id|ppr_options
)paren
suffix:semicolon
)brace
r_else
(brace
id|ahd_construct_sdtr
c_func
(paren
id|ahd
comma
id|devinfo
comma
id|period
comma
id|offset
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|ahd_construct_wdtr
c_func
(paren
id|ahd
comma
id|devinfo
comma
id|tinfo-&gt;goal.width
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Build a synchronous negotiation message in our message&n; * buffer based on the input parameters.&n; */
r_static
r_void
DECL|function|ahd_construct_sdtr
id|ahd_construct_sdtr
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_devinfo
op_star
id|devinfo
comma
id|u_int
id|period
comma
id|u_int
id|offset
)paren
(brace
r_if
c_cond
(paren
id|offset
op_eq
l_int|0
)paren
id|period
op_assign
id|AHD_ASYNC_XFER_PERIOD
suffix:semicolon
id|ahd-&gt;msgout_buf
(braket
id|ahd-&gt;msgout_index
op_increment
)braket
op_assign
id|MSG_EXTENDED
suffix:semicolon
id|ahd-&gt;msgout_buf
(braket
id|ahd-&gt;msgout_index
op_increment
)braket
op_assign
id|MSG_EXT_SDTR_LEN
suffix:semicolon
id|ahd-&gt;msgout_buf
(braket
id|ahd-&gt;msgout_index
op_increment
)braket
op_assign
id|MSG_EXT_SDTR
suffix:semicolon
id|ahd-&gt;msgout_buf
(braket
id|ahd-&gt;msgout_index
op_increment
)braket
op_assign
id|period
suffix:semicolon
id|ahd-&gt;msgout_buf
(braket
id|ahd-&gt;msgout_index
op_increment
)braket
op_assign
id|offset
suffix:semicolon
id|ahd-&gt;msgout_len
op_add_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;(%s:%c:%d:%d): Sending SDTR period %x, offset %x&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
comma
id|period
comma
id|offset
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Build a wide negotiateion message in our message&n; * buffer based on the input parameters.&n; */
r_static
r_void
DECL|function|ahd_construct_wdtr
id|ahd_construct_wdtr
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_devinfo
op_star
id|devinfo
comma
id|u_int
id|bus_width
)paren
(brace
id|ahd-&gt;msgout_buf
(braket
id|ahd-&gt;msgout_index
op_increment
)braket
op_assign
id|MSG_EXTENDED
suffix:semicolon
id|ahd-&gt;msgout_buf
(braket
id|ahd-&gt;msgout_index
op_increment
)braket
op_assign
id|MSG_EXT_WDTR_LEN
suffix:semicolon
id|ahd-&gt;msgout_buf
(braket
id|ahd-&gt;msgout_index
op_increment
)braket
op_assign
id|MSG_EXT_WDTR
suffix:semicolon
id|ahd-&gt;msgout_buf
(braket
id|ahd-&gt;msgout_index
op_increment
)braket
op_assign
id|bus_width
suffix:semicolon
id|ahd-&gt;msgout_len
op_add_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;(%s:%c:%d:%d): Sending WDTR %x&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
comma
id|bus_width
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Build a parallel protocol request message in our message&n; * buffer based on the input parameters.&n; */
r_static
r_void
DECL|function|ahd_construct_ppr
id|ahd_construct_ppr
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_devinfo
op_star
id|devinfo
comma
id|u_int
id|period
comma
id|u_int
id|offset
comma
id|u_int
id|bus_width
comma
id|u_int
id|ppr_options
)paren
(brace
multiline_comment|/*&n;&t; * Always request precompensation from&n;&t; * the other target if we are running&n;&t; * at paced syncrates.&n;&t; */
r_if
c_cond
(paren
id|period
op_le
id|AHD_SYNCRATE_PACED
)paren
id|ppr_options
op_or_assign
id|MSG_EXT_PPR_PCOMP_EN
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_eq
l_int|0
)paren
id|period
op_assign
id|AHD_ASYNC_XFER_PERIOD
suffix:semicolon
id|ahd-&gt;msgout_buf
(braket
id|ahd-&gt;msgout_index
op_increment
)braket
op_assign
id|MSG_EXTENDED
suffix:semicolon
id|ahd-&gt;msgout_buf
(braket
id|ahd-&gt;msgout_index
op_increment
)braket
op_assign
id|MSG_EXT_PPR_LEN
suffix:semicolon
id|ahd-&gt;msgout_buf
(braket
id|ahd-&gt;msgout_index
op_increment
)braket
op_assign
id|MSG_EXT_PPR
suffix:semicolon
id|ahd-&gt;msgout_buf
(braket
id|ahd-&gt;msgout_index
op_increment
)braket
op_assign
id|period
suffix:semicolon
id|ahd-&gt;msgout_buf
(braket
id|ahd-&gt;msgout_index
op_increment
)braket
op_assign
l_int|0
suffix:semicolon
id|ahd-&gt;msgout_buf
(braket
id|ahd-&gt;msgout_index
op_increment
)braket
op_assign
id|offset
suffix:semicolon
id|ahd-&gt;msgout_buf
(braket
id|ahd-&gt;msgout_index
op_increment
)braket
op_assign
id|bus_width
suffix:semicolon
id|ahd-&gt;msgout_buf
(braket
id|ahd-&gt;msgout_index
op_increment
)braket
op_assign
id|ppr_options
suffix:semicolon
id|ahd-&gt;msgout_len
op_add_assign
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;(%s:%c:%d:%d): Sending PPR bus_width %x, period %x, &quot;
l_string|&quot;offset %x, ppr_options %x&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
comma
id|bus_width
comma
id|period
comma
id|offset
comma
id|ppr_options
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Clear any active message state.&n; */
r_static
r_void
DECL|function|ahd_clear_msg_state
id|ahd_clear_msg_state
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
id|ahd_mode_state
id|saved_modes
suffix:semicolon
id|saved_modes
op_assign
id|ahd_save_modes
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI
comma
id|AHD_MODE_SCSI
)paren
suffix:semicolon
id|ahd-&gt;send_msg_perror
op_assign
l_int|0
suffix:semicolon
id|ahd-&gt;msg_flags
op_assign
id|MSG_FLAG_NONE
suffix:semicolon
id|ahd-&gt;msgout_len
op_assign
l_int|0
suffix:semicolon
id|ahd-&gt;msgin_index
op_assign
l_int|0
suffix:semicolon
id|ahd-&gt;msg_type
op_assign
id|MSG_TYPE_NONE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSISIGO
)paren
op_amp
id|ATNO
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * The target didn&squot;t care to respond to our&n;&t;&t; * message request, so clear ATN.&n;&t;&t; */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRSINT1
comma
id|CLRATNO
)paren
suffix:semicolon
)brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|MSG_OUT
comma
id|MSG_NOOP
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SEQ_FLAGS2
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SEQ_FLAGS2
)paren
op_amp
op_complement
id|TARGET_MSG_PENDING
)paren
suffix:semicolon
id|ahd_restore_modes
c_func
(paren
id|ahd
comma
id|saved_modes
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Manual message loop handler.&n; */
r_static
r_void
DECL|function|ahd_handle_message_phase
id|ahd_handle_message_phase
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
r_struct
id|ahd_devinfo
id|devinfo
suffix:semicolon
id|u_int
id|bus_phase
suffix:semicolon
r_int
id|end_session
suffix:semicolon
id|ahd_fetch_devinfo
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
)paren
suffix:semicolon
id|end_session
op_assign
id|FALSE
suffix:semicolon
id|bus_phase
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LASTPHASE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LQISTAT2
)paren
op_amp
id|LQIPHASE_OUTPKT
)paren
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;LQIRETRY for LQIPHASE_OUTPKT&bslash;n&quot;
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|LQCTL2
comma
id|LQIRETRY
)paren
suffix:semicolon
)brace
id|reswitch
suffix:colon
r_switch
c_cond
(paren
id|ahd-&gt;msg_type
)paren
(brace
r_case
id|MSG_TYPE_INITIATOR_MSGOUT
suffix:colon
(brace
r_int
id|lastbyte
suffix:semicolon
r_int
id|phasemis
suffix:semicolon
r_int
id|msgdone
suffix:semicolon
r_if
c_cond
(paren
id|ahd-&gt;msgout_len
op_eq
l_int|0
op_logical_and
id|ahd-&gt;send_msg_perror
op_eq
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;HOST_MSG_LOOP interrupt with no active message&quot;
)paren
suffix:semicolon
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_MESSAGES
)paren
op_ne
l_int|0
)paren
(brace
id|ahd_print_devinfo
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;INITIATOR_MSG_OUT&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|phasemis
op_assign
id|bus_phase
op_ne
id|P_MESGOUT
suffix:semicolon
r_if
c_cond
(paren
id|phasemis
)paren
(brace
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_MESSAGES
)paren
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot; PHASEMIS %s&bslash;n&quot;
comma
id|ahd_lookup_phase_entry
c_func
(paren
id|bus_phase
)paren
op_member_access_from_pointer
id|phasemsg
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|bus_phase
op_eq
id|P_MESGIN
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Change gears and see if&n;&t;&t;&t;&t; * this messages is of interest to&n;&t;&t;&t;&t; * us or should be passed back to&n;&t;&t;&t;&t; * the sequencer.&n;&t;&t;&t;&t; */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRSINT1
comma
id|CLRATNO
)paren
suffix:semicolon
id|ahd-&gt;send_msg_perror
op_assign
l_int|0
suffix:semicolon
id|ahd-&gt;msg_type
op_assign
id|MSG_TYPE_INITIATOR_MSGIN
suffix:semicolon
id|ahd-&gt;msgin_index
op_assign
l_int|0
suffix:semicolon
r_goto
id|reswitch
suffix:semicolon
)brace
id|end_session
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ahd-&gt;send_msg_perror
)paren
(brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRSINT1
comma
id|CLRATNO
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRSINT1
comma
id|CLRREQINIT
)paren
suffix:semicolon
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_MESSAGES
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot; byte 0x%x&bslash;n&quot;
comma
id|ahd-&gt;send_msg_perror
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t;&t; * If we are notifying the target of a CRC error&n;&t;&t;&t; * during packetized operations, the target is&n;&t;&t;&t; * within its rights to acknowledge our message&n;&t;&t;&t; * with a busfree.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|ahd-&gt;msg_flags
op_amp
id|MSG_FLAG_PACKETIZED
)paren
op_ne
l_int|0
op_logical_and
id|ahd-&gt;send_msg_perror
op_eq
id|MSG_INITIATOR_DET_ERR
)paren
id|ahd-&gt;msg_flags
op_or_assign
id|MSG_FLAG_EXPECT_IDE_BUSFREE
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|RETURN_2
comma
id|ahd-&gt;send_msg_perror
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|RETURN_1
comma
id|CONT_MSG_LOOP_WRITE
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|msgdone
op_assign
id|ahd-&gt;msgout_index
op_eq
id|ahd-&gt;msgout_len
suffix:semicolon
r_if
c_cond
(paren
id|msgdone
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * The target has requested a retry.&n;&t;&t;&t; * Re-assert ATN, reset our message index to&n;&t;&t;&t; * 0, and try again.&n;&t;&t;&t; */
id|ahd-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|ahd_assert_atn
c_func
(paren
id|ahd
)paren
suffix:semicolon
)brace
id|lastbyte
op_assign
id|ahd-&gt;msgout_index
op_eq
(paren
id|ahd-&gt;msgout_len
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lastbyte
)paren
(brace
multiline_comment|/* Last byte is signified by dropping ATN */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRSINT1
comma
id|CLRATNO
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Clear our interrupt status and present&n;&t;&t; * the next byte on the bus.&n;&t;&t; */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRSINT1
comma
id|CLRREQINIT
)paren
suffix:semicolon
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_MESSAGES
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot; byte 0x%x&bslash;n&quot;
comma
id|ahd-&gt;msgout_buf
(braket
id|ahd-&gt;msgout_index
)braket
)paren
suffix:semicolon
macro_line|#endif
id|ahd_outb
c_func
(paren
id|ahd
comma
id|RETURN_2
comma
id|ahd-&gt;msgout_buf
(braket
id|ahd-&gt;msgout_index
op_increment
)braket
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|RETURN_1
comma
id|CONT_MSG_LOOP_WRITE
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MSG_TYPE_INITIATOR_MSGIN
suffix:colon
(brace
r_int
id|phasemis
suffix:semicolon
r_int
id|message_done
suffix:semicolon
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_MESSAGES
)paren
op_ne
l_int|0
)paren
(brace
id|ahd_print_devinfo
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;INITIATOR_MSG_IN&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|phasemis
op_assign
id|bus_phase
op_ne
id|P_MESGIN
suffix:semicolon
r_if
c_cond
(paren
id|phasemis
)paren
(brace
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_MESSAGES
)paren
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot; PHASEMIS %s&bslash;n&quot;
comma
id|ahd_lookup_phase_entry
c_func
(paren
id|bus_phase
)paren
op_member_access_from_pointer
id|phasemsg
)paren
suffix:semicolon
)brace
macro_line|#endif
id|ahd-&gt;msgin_index
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|bus_phase
op_eq
id|P_MESGOUT
op_logical_and
(paren
id|ahd-&gt;send_msg_perror
op_ne
l_int|0
op_logical_or
(paren
id|ahd-&gt;msgout_len
op_ne
l_int|0
op_logical_and
id|ahd-&gt;msgout_index
op_eq
l_int|0
)paren
)paren
)paren
(brace
id|ahd-&gt;msg_type
op_assign
id|MSG_TYPE_INITIATOR_MSGOUT
suffix:semicolon
r_goto
id|reswitch
suffix:semicolon
)brace
id|end_session
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Pull the byte in without acking it */
id|ahd-&gt;msgin_buf
(braket
id|ahd-&gt;msgin_index
)braket
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSIBUS
)paren
suffix:semicolon
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_MESSAGES
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot; byte 0x%x&bslash;n&quot;
comma
id|ahd-&gt;msgin_buf
(braket
id|ahd-&gt;msgin_index
)braket
)paren
suffix:semicolon
macro_line|#endif
id|message_done
op_assign
id|ahd_parse_msg
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|message_done
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Clear our incoming message buffer in case there&n;&t;&t;&t; * is another message following this one.&n;&t;&t;&t; */
id|ahd-&gt;msgin_index
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If this message illicited a response,&n;&t;&t;&t; * assert ATN so the target takes us to the&n;&t;&t;&t; * message out phase.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ahd-&gt;msgout_len
op_ne
l_int|0
)paren
(brace
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_MESSAGES
)paren
op_ne
l_int|0
)paren
(brace
id|ahd_print_devinfo
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Asserting ATN for response&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|ahd_assert_atn
c_func
(paren
id|ahd
)paren
suffix:semicolon
)brace
)brace
r_else
id|ahd-&gt;msgin_index
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|message_done
op_eq
id|MSGLOOP_TERMINATED
)paren
(brace
id|end_session
op_assign
id|TRUE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Ack the byte */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRSINT1
comma
id|CLRREQINIT
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|RETURN_1
comma
id|CONT_MSG_LOOP_READ
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_case
id|MSG_TYPE_TARGET_MSGIN
suffix:colon
(brace
r_int
id|msgdone
suffix:semicolon
r_int
id|msgout_request
suffix:semicolon
multiline_comment|/*&n;&t;&t; * By default, the message loop will continue.&n;&t;&t; */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|RETURN_1
comma
id|CONT_MSG_LOOP_TARG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahd-&gt;msgout_len
op_eq
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;Target MSGIN with no active message&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we interrupted a mesgout session, the initiator&n;&t;&t; * will not know this until our first REQ.  So, we&n;&t;&t; * only honor mesgout requests after we&squot;ve sent our&n;&t;&t; * first byte.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSISIGI
)paren
op_amp
id|ATNI
)paren
op_ne
l_int|0
op_logical_and
id|ahd-&gt;msgout_index
OG
l_int|0
)paren
id|msgout_request
op_assign
id|TRUE
suffix:semicolon
r_else
id|msgout_request
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|msgout_request
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Change gears and see if&n;&t;&t;&t; * this messages is of interest to&n;&t;&t;&t; * us or should be passed back to&n;&t;&t;&t; * the sequencer.&n;&t;&t;&t; */
id|ahd-&gt;msg_type
op_assign
id|MSG_TYPE_TARGET_MSGOUT
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCSISIGO
comma
id|P_MESGOUT
op_or
id|BSYO
)paren
suffix:semicolon
id|ahd-&gt;msgin_index
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Dummy read to REQ for first byte */
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSIDAT
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SXFRCTL0
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SXFRCTL0
)paren
op_or
id|SPIOEN
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|msgdone
op_assign
id|ahd-&gt;msgout_index
op_eq
id|ahd-&gt;msgout_len
suffix:semicolon
r_if
c_cond
(paren
id|msgdone
)paren
(brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SXFRCTL0
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SXFRCTL0
)paren
op_amp
op_complement
id|SPIOEN
)paren
suffix:semicolon
id|end_session
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Present the next byte on the bus.&n;&t;&t; */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SXFRCTL0
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SXFRCTL0
)paren
op_or
id|SPIOEN
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCSIDAT
comma
id|ahd-&gt;msgout_buf
(braket
id|ahd-&gt;msgout_index
op_increment
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MSG_TYPE_TARGET_MSGOUT
suffix:colon
(brace
r_int
id|lastbyte
suffix:semicolon
r_int
id|msgdone
suffix:semicolon
multiline_comment|/*&n;&t;&t; * By default, the message loop will continue.&n;&t;&t; */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|RETURN_1
comma
id|CONT_MSG_LOOP_TARG
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The initiator signals that this is&n;&t;&t; * the last byte by dropping ATN.&n;&t;&t; */
id|lastbyte
op_assign
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSISIGI
)paren
op_amp
id|ATNI
)paren
op_eq
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Read the latched byte, but turn off SPIOEN first&n;&t;&t; * so that we don&squot;t inadvertently cause a REQ for the&n;&t;&t; * next byte.&n;&t;&t; */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SXFRCTL0
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SXFRCTL0
)paren
op_amp
op_complement
id|SPIOEN
)paren
suffix:semicolon
id|ahd-&gt;msgin_buf
(braket
id|ahd-&gt;msgin_index
)braket
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSIDAT
)paren
suffix:semicolon
id|msgdone
op_assign
id|ahd_parse_msg
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msgdone
op_eq
id|MSGLOOP_TERMINATED
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * The message is *really* done in that it caused&n;&t;&t;&t; * us to go to bus free.  The sequencer has already&n;&t;&t;&t; * been reset at this point, so pull the ejection&n;&t;&t;&t; * handle.&n;&t;&t;&t; */
r_return
suffix:semicolon
)brace
id|ahd-&gt;msgin_index
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * XXX Read spec about initiator dropping ATN too soon&n;&t;&t; *     and use msgdone to detect it.&n;&t;&t; */
r_if
c_cond
(paren
id|msgdone
op_eq
id|MSGLOOP_MSGCOMPLETE
)paren
(brace
id|ahd-&gt;msgin_index
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If this message illicited a response, transition&n;&t;&t;&t; * to the Message in phase and send it.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ahd-&gt;msgout_len
op_ne
l_int|0
)paren
(brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCSISIGO
comma
id|P_MESGIN
op_or
id|BSYO
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SXFRCTL0
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SXFRCTL0
)paren
op_or
id|SPIOEN
)paren
suffix:semicolon
id|ahd-&gt;msg_type
op_assign
id|MSG_TYPE_TARGET_MSGIN
suffix:semicolon
id|ahd-&gt;msgin_index
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|lastbyte
)paren
id|end_session
op_assign
id|TRUE
suffix:semicolon
r_else
(brace
multiline_comment|/* Ask for the next byte. */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SXFRCTL0
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SXFRCTL0
)paren
op_or
id|SPIOEN
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;Unknown REQINIT message type&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|end_session
)paren
(brace
r_if
c_cond
(paren
(paren
id|ahd-&gt;msg_flags
op_amp
id|MSG_FLAG_PACKETIZED
)paren
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: Returning to Idle Loop&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|LASTPHASE
comma
id|P_BUSFREE
)paren
suffix:semicolon
id|ahd_clear_msg_state
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SEQCTL0
comma
id|FASTMODE
op_or
id|SEQRESET
)paren
suffix:semicolon
)brace
r_else
(brace
id|ahd_clear_msg_state
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|RETURN_1
comma
id|EXIT_MSG_LOOP
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * See if we sent a particular extended message to the target.&n; * If &quot;full&quot; is true, return true only if the target saw the full&n; * message.  If &quot;full&quot; is false, return true if the target saw at&n; * least the first byte of the message.&n; */
r_static
r_int
DECL|function|ahd_sent_msg
id|ahd_sent_msg
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
id|ahd_msgtype
id|type
comma
id|u_int
id|msgval
comma
r_int
id|full
)paren
(brace
r_int
id|found
suffix:semicolon
id|u_int
id|index
suffix:semicolon
id|found
op_assign
id|FALSE
suffix:semicolon
id|index
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|index
OL
id|ahd-&gt;msgout_len
)paren
(brace
r_if
c_cond
(paren
id|ahd-&gt;msgout_buf
(braket
id|index
)braket
op_eq
id|MSG_EXTENDED
)paren
(brace
id|u_int
id|end_index
suffix:semicolon
id|end_index
op_assign
id|index
op_plus
l_int|1
op_plus
id|ahd-&gt;msgout_buf
(braket
id|index
op_plus
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ahd-&gt;msgout_buf
(braket
id|index
op_plus
l_int|2
)braket
op_eq
id|msgval
op_logical_and
id|type
op_eq
id|AHDMSG_EXT
)paren
(brace
r_if
c_cond
(paren
id|full
)paren
(brace
r_if
c_cond
(paren
id|ahd-&gt;msgout_index
OG
id|end_index
)paren
id|found
op_assign
id|TRUE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ahd-&gt;msgout_index
OG
id|index
)paren
id|found
op_assign
id|TRUE
suffix:semicolon
)brace
id|index
op_assign
id|end_index
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ahd-&gt;msgout_buf
(braket
id|index
)braket
op_ge
id|MSG_SIMPLE_TASK
op_logical_and
id|ahd-&gt;msgout_buf
(braket
id|index
)braket
op_le
id|MSG_IGN_WIDE_RESIDUE
)paren
(brace
multiline_comment|/* Skip tag type and tag id or residue param*/
id|index
op_add_assign
l_int|2
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Single byte message */
r_if
c_cond
(paren
id|type
op_eq
id|AHDMSG_1B
op_logical_and
id|ahd-&gt;msgout_index
OG
id|index
op_logical_and
(paren
id|ahd-&gt;msgout_buf
(braket
id|index
)braket
op_eq
id|msgval
op_logical_or
(paren
(paren
id|ahd-&gt;msgout_buf
(braket
id|index
)braket
op_amp
id|MSG_IDENTIFYFLAG
)paren
op_ne
l_int|0
op_logical_and
id|msgval
op_eq
id|MSG_IDENTIFYFLAG
)paren
)paren
)paren
id|found
op_assign
id|TRUE
suffix:semicolon
id|index
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|found
)paren
r_break
suffix:semicolon
)brace
r_return
(paren
id|found
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait for a complete incoming message, parse it, and respond accordingly.&n; */
r_static
r_int
DECL|function|ahd_parse_msg
id|ahd_parse_msg
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_devinfo
op_star
id|devinfo
)paren
(brace
r_struct
id|ahd_initiator_tinfo
op_star
id|tinfo
suffix:semicolon
r_struct
id|ahd_tmode_tstate
op_star
id|tstate
suffix:semicolon
r_int
id|reject
suffix:semicolon
r_int
id|done
suffix:semicolon
r_int
id|response
suffix:semicolon
id|done
op_assign
id|MSGLOOP_IN_PROG
suffix:semicolon
id|response
op_assign
id|FALSE
suffix:semicolon
id|reject
op_assign
id|FALSE
suffix:semicolon
id|tinfo
op_assign
id|ahd_fetch_transinfo
c_func
(paren
id|ahd
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;our_scsiid
comma
id|devinfo-&gt;target
comma
op_amp
id|tstate
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Parse as much of the message as is availible,&n;&t; * rejecting it if we don&squot;t support it.  When&n;&t; * the entire message is availible and has been&n;&t; * handled, return MSGLOOP_MSGCOMPLETE, indicating&n;&t; * that we have parsed an entire message.&n;&t; *&n;&t; * In the case of extended messages, we accept the length&n;&t; * byte outright and perform more checking once we know the&n;&t; * extended message type.&n;&t; */
r_switch
c_cond
(paren
id|ahd-&gt;msgin_buf
(braket
l_int|0
)braket
)paren
(brace
r_case
id|MSG_DISCONNECT
suffix:colon
r_case
id|MSG_SAVEDATAPOINTER
suffix:colon
r_case
id|MSG_CMDCOMPLETE
suffix:colon
r_case
id|MSG_RESTOREPOINTERS
suffix:colon
r_case
id|MSG_IGN_WIDE_RESIDUE
suffix:colon
multiline_comment|/*&n;&t;&t; * End our message loop as these are messages&n;&t;&t; * the sequencer handles on its own.&n;&t;&t; */
id|done
op_assign
id|MSGLOOP_TERMINATED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MSG_MESSAGE_REJECT
suffix:colon
id|response
op_assign
id|ahd_handle_msg_reject
c_func
(paren
id|ahd
comma
id|devinfo
)paren
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_case
id|MSG_NOOP
suffix:colon
id|done
op_assign
id|MSGLOOP_MSGCOMPLETE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MSG_EXTENDED
suffix:colon
(brace
multiline_comment|/* Wait for enough of the message to begin validation */
r_if
c_cond
(paren
id|ahd-&gt;msgin_index
OL
l_int|2
)paren
r_break
suffix:semicolon
r_switch
c_cond
(paren
id|ahd-&gt;msgin_buf
(braket
l_int|2
)braket
)paren
(brace
r_case
id|MSG_EXT_SDTR
suffix:colon
(brace
id|u_int
id|period
suffix:semicolon
id|u_int
id|ppr_options
suffix:semicolon
id|u_int
id|offset
suffix:semicolon
id|u_int
id|saved_offset
suffix:semicolon
r_if
c_cond
(paren
id|ahd-&gt;msgin_buf
(braket
l_int|1
)braket
op_ne
id|MSG_EXT_SDTR_LEN
)paren
(brace
id|reject
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Wait until we have both args before validating&n;&t;&t;&t; * and acting on this message.&n;&t;&t;&t; *&n;&t;&t;&t; * Add one to MSG_EXT_SDTR_LEN to account for&n;&t;&t;&t; * the extended message preamble.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ahd-&gt;msgin_index
OL
(paren
id|MSG_EXT_SDTR_LEN
op_plus
l_int|1
)paren
)paren
r_break
suffix:semicolon
id|period
op_assign
id|ahd-&gt;msgin_buf
(braket
l_int|3
)braket
suffix:semicolon
id|ppr_options
op_assign
l_int|0
suffix:semicolon
id|saved_offset
op_assign
id|offset
op_assign
id|ahd-&gt;msgin_buf
(braket
l_int|4
)braket
suffix:semicolon
id|ahd_devlimited_syncrate
c_func
(paren
id|ahd
comma
id|tinfo
comma
op_amp
id|period
comma
op_amp
id|ppr_options
comma
id|devinfo-&gt;role
)paren
suffix:semicolon
id|ahd_validate_offset
c_func
(paren
id|ahd
comma
id|tinfo
comma
id|period
comma
op_amp
id|offset
comma
id|tinfo-&gt;curr.width
comma
id|devinfo-&gt;role
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;(%s:%c:%d:%d): Received &quot;
l_string|&quot;SDTR period %x, offset %x&bslash;n&bslash;t&quot;
l_string|&quot;Filtered to period %x, offset %x&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
comma
id|ahd-&gt;msgin_buf
(braket
l_int|3
)braket
comma
id|saved_offset
comma
id|period
comma
id|offset
)paren
suffix:semicolon
)brace
id|ahd_set_syncrate
c_func
(paren
id|ahd
comma
id|devinfo
comma
id|period
comma
id|offset
comma
id|ppr_options
comma
id|AHD_TRANS_ACTIVE
op_or
id|AHD_TRANS_GOAL
comma
multiline_comment|/*paused*/
id|TRUE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * See if we initiated Sync Negotiation&n;&t;&t;&t; * and didn&squot;t have to fall down to async&n;&t;&t;&t; * transfers.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ahd_sent_msg
c_func
(paren
id|ahd
comma
id|AHDMSG_EXT
comma
id|MSG_EXT_SDTR
comma
id|TRUE
)paren
)paren
(brace
multiline_comment|/* We started it */
r_if
c_cond
(paren
id|saved_offset
op_ne
id|offset
)paren
(brace
multiline_comment|/* Went too low - force async */
id|reject
op_assign
id|TRUE
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Send our own SDTR in reply&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|bootverbose
op_logical_and
id|devinfo-&gt;role
op_eq
id|ROLE_INITIATOR
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;(%s:%c:%d:%d): Target &quot;
l_string|&quot;Initiated SDTR&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
)paren
suffix:semicolon
)brace
id|ahd-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|ahd-&gt;msgout_len
op_assign
l_int|0
suffix:semicolon
id|ahd_construct_sdtr
c_func
(paren
id|ahd
comma
id|devinfo
comma
id|period
comma
id|offset
)paren
suffix:semicolon
id|ahd-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|response
op_assign
id|TRUE
suffix:semicolon
)brace
id|done
op_assign
id|MSGLOOP_MSGCOMPLETE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MSG_EXT_WDTR
suffix:colon
(brace
id|u_int
id|bus_width
suffix:semicolon
id|u_int
id|saved_width
suffix:semicolon
id|u_int
id|sending_reply
suffix:semicolon
id|sending_reply
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|ahd-&gt;msgin_buf
(braket
l_int|1
)braket
op_ne
id|MSG_EXT_WDTR_LEN
)paren
(brace
id|reject
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Wait until we have our arg before validating&n;&t;&t;&t; * and acting on this message.&n;&t;&t;&t; *&n;&t;&t;&t; * Add one to MSG_EXT_WDTR_LEN to account for&n;&t;&t;&t; * the extended message preamble.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ahd-&gt;msgin_index
OL
(paren
id|MSG_EXT_WDTR_LEN
op_plus
l_int|1
)paren
)paren
r_break
suffix:semicolon
id|bus_width
op_assign
id|ahd-&gt;msgin_buf
(braket
l_int|3
)braket
suffix:semicolon
id|saved_width
op_assign
id|bus_width
suffix:semicolon
id|ahd_validate_width
c_func
(paren
id|ahd
comma
id|tinfo
comma
op_amp
id|bus_width
comma
id|devinfo-&gt;role
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;(%s:%c:%d:%d): Received WDTR &quot;
l_string|&quot;%x filtered to %x&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
comma
id|saved_width
comma
id|bus_width
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ahd_sent_msg
c_func
(paren
id|ahd
comma
id|AHDMSG_EXT
comma
id|MSG_EXT_WDTR
comma
id|TRUE
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Don&squot;t send a WDTR back to the&n;&t;&t;&t;&t; * target, since we asked first.&n;&t;&t;&t;&t; * If the width went higher than our&n;&t;&t;&t;&t; * request, reject it.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|saved_width
OG
id|bus_width
)paren
(brace
id|reject
op_assign
id|TRUE
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;(%s:%c:%d:%d): requested %dBit &quot;
l_string|&quot;transfers.  Rejecting...&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
comma
l_int|8
op_star
(paren
l_int|0x01
op_lshift
id|bus_width
)paren
)paren
suffix:semicolon
id|bus_width
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Send our own WDTR in reply&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|bootverbose
op_logical_and
id|devinfo-&gt;role
op_eq
id|ROLE_INITIATOR
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;(%s:%c:%d:%d): Target &quot;
l_string|&quot;Initiated WDTR&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
)paren
suffix:semicolon
)brace
id|ahd-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|ahd-&gt;msgout_len
op_assign
l_int|0
suffix:semicolon
id|ahd_construct_wdtr
c_func
(paren
id|ahd
comma
id|devinfo
comma
id|bus_width
)paren
suffix:semicolon
id|ahd-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|response
op_assign
id|TRUE
suffix:semicolon
id|sending_reply
op_assign
id|TRUE
suffix:semicolon
)brace
id|ahd_set_width
c_func
(paren
id|ahd
comma
id|devinfo
comma
id|bus_width
comma
id|AHD_TRANS_ACTIVE
op_or
id|AHD_TRANS_GOAL
comma
multiline_comment|/*paused*/
id|TRUE
)paren
suffix:semicolon
multiline_comment|/* After a wide message, we are async */
id|ahd_set_syncrate
c_func
(paren
id|ahd
comma
id|devinfo
comma
multiline_comment|/*period*/
l_int|0
comma
multiline_comment|/*offset*/
l_int|0
comma
multiline_comment|/*ppr_options*/
l_int|0
comma
id|AHD_TRANS_ACTIVE
comma
multiline_comment|/*paused*/
id|TRUE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sending_reply
op_eq
id|FALSE
op_logical_and
id|reject
op_eq
id|FALSE
)paren
(brace
r_if
c_cond
(paren
id|tinfo-&gt;goal.offset
)paren
(brace
id|ahd-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|ahd-&gt;msgout_len
op_assign
l_int|0
suffix:semicolon
id|ahd_build_transfer_msg
c_func
(paren
id|ahd
comma
id|devinfo
)paren
suffix:semicolon
id|ahd-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|response
op_assign
id|TRUE
suffix:semicolon
)brace
)brace
id|done
op_assign
id|MSGLOOP_MSGCOMPLETE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MSG_EXT_PPR
suffix:colon
(brace
id|u_int
id|period
suffix:semicolon
id|u_int
id|offset
suffix:semicolon
id|u_int
id|bus_width
suffix:semicolon
id|u_int
id|ppr_options
suffix:semicolon
id|u_int
id|saved_width
suffix:semicolon
id|u_int
id|saved_offset
suffix:semicolon
id|u_int
id|saved_ppr_options
suffix:semicolon
r_if
c_cond
(paren
id|ahd-&gt;msgin_buf
(braket
l_int|1
)braket
op_ne
id|MSG_EXT_PPR_LEN
)paren
(brace
id|reject
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Wait until we have all args before validating&n;&t;&t;&t; * and acting on this message.&n;&t;&t;&t; *&n;&t;&t;&t; * Add one to MSG_EXT_PPR_LEN to account for&n;&t;&t;&t; * the extended message preamble.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ahd-&gt;msgin_index
OL
(paren
id|MSG_EXT_PPR_LEN
op_plus
l_int|1
)paren
)paren
r_break
suffix:semicolon
id|period
op_assign
id|ahd-&gt;msgin_buf
(braket
l_int|3
)braket
suffix:semicolon
id|offset
op_assign
id|ahd-&gt;msgin_buf
(braket
l_int|5
)braket
suffix:semicolon
id|bus_width
op_assign
id|ahd-&gt;msgin_buf
(braket
l_int|6
)braket
suffix:semicolon
id|saved_width
op_assign
id|bus_width
suffix:semicolon
id|ppr_options
op_assign
id|ahd-&gt;msgin_buf
(braket
l_int|7
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * According to the spec, a DT only&n;&t;&t;&t; * period factor with no DT option&n;&t;&t;&t; * set implies async.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|ppr_options
op_amp
id|MSG_EXT_PPR_DT_REQ
)paren
op_eq
l_int|0
op_logical_and
id|period
op_le
l_int|9
)paren
id|offset
op_assign
l_int|0
suffix:semicolon
id|saved_ppr_options
op_assign
id|ppr_options
suffix:semicolon
id|saved_offset
op_assign
id|offset
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Transfer options are only available if we&n;&t;&t;&t; * are negotiating wide.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|bus_width
op_eq
l_int|0
)paren
id|ppr_options
op_and_assign
id|MSG_EXT_PPR_QAS_REQ
suffix:semicolon
id|ahd_validate_width
c_func
(paren
id|ahd
comma
id|tinfo
comma
op_amp
id|bus_width
comma
id|devinfo-&gt;role
)paren
suffix:semicolon
id|ahd_devlimited_syncrate
c_func
(paren
id|ahd
comma
id|tinfo
comma
op_amp
id|period
comma
op_amp
id|ppr_options
comma
id|devinfo-&gt;role
)paren
suffix:semicolon
id|ahd_validate_offset
c_func
(paren
id|ahd
comma
id|tinfo
comma
id|period
comma
op_amp
id|offset
comma
id|bus_width
comma
id|devinfo-&gt;role
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahd_sent_msg
c_func
(paren
id|ahd
comma
id|AHDMSG_EXT
comma
id|MSG_EXT_PPR
comma
id|TRUE
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * If we are unable to do any of the&n;&t;&t;&t;&t; * requested options (we went too low),&n;&t;&t;&t;&t; * then we&squot;ll have to reject the message.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|saved_width
OG
id|bus_width
op_logical_or
id|saved_offset
op_ne
id|offset
op_logical_or
id|saved_ppr_options
op_ne
id|ppr_options
)paren
(brace
id|reject
op_assign
id|TRUE
suffix:semicolon
id|period
op_assign
l_int|0
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
id|bus_width
op_assign
l_int|0
suffix:semicolon
id|ppr_options
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|devinfo-&gt;role
op_ne
id|ROLE_TARGET
)paren
id|printf
c_func
(paren
l_string|&quot;(%s:%c:%d:%d): Target &quot;
l_string|&quot;Initiated PPR&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot;(%s:%c:%d:%d): Initiator &quot;
l_string|&quot;Initiated PPR&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
)paren
suffix:semicolon
id|ahd-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|ahd-&gt;msgout_len
op_assign
l_int|0
suffix:semicolon
id|ahd_construct_ppr
c_func
(paren
id|ahd
comma
id|devinfo
comma
id|period
comma
id|offset
comma
id|bus_width
comma
id|ppr_options
)paren
suffix:semicolon
id|ahd-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|response
op_assign
id|TRUE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bootverbose
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;(%s:%c:%d:%d): Received PPR width %x, &quot;
l_string|&quot;period %x, offset %x,options %x&bslash;n&quot;
l_string|&quot;&bslash;tFiltered to width %x, period %x, &quot;
l_string|&quot;offset %x, options %x&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
comma
id|saved_width
comma
id|ahd-&gt;msgin_buf
(braket
l_int|3
)braket
comma
id|saved_offset
comma
id|saved_ppr_options
comma
id|bus_width
comma
id|period
comma
id|offset
comma
id|ppr_options
)paren
suffix:semicolon
)brace
id|ahd_set_width
c_func
(paren
id|ahd
comma
id|devinfo
comma
id|bus_width
comma
id|AHD_TRANS_ACTIVE
op_or
id|AHD_TRANS_GOAL
comma
multiline_comment|/*paused*/
id|TRUE
)paren
suffix:semicolon
id|ahd_set_syncrate
c_func
(paren
id|ahd
comma
id|devinfo
comma
id|period
comma
id|offset
comma
id|ppr_options
comma
id|AHD_TRANS_ACTIVE
op_or
id|AHD_TRANS_GOAL
comma
multiline_comment|/*paused*/
id|TRUE
)paren
suffix:semicolon
id|done
op_assign
id|MSGLOOP_MSGCOMPLETE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
multiline_comment|/* Unknown extended message.  Reject it. */
id|reject
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
macro_line|#ifdef AHD_TARGET_MODE
r_case
id|MSG_BUS_DEV_RESET
suffix:colon
id|ahd_handle_devreset
c_func
(paren
id|ahd
comma
id|devinfo
comma
id|CAM_LUN_WILDCARD
comma
id|CAM_BDR_SENT
comma
l_string|&quot;Bus Device Reset Received&quot;
comma
multiline_comment|/*verbose_level*/
l_int|0
)paren
suffix:semicolon
id|ahd_restart
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|done
op_assign
id|MSGLOOP_TERMINATED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MSG_ABORT_TAG
suffix:colon
r_case
id|MSG_ABORT
suffix:colon
r_case
id|MSG_CLEAR_QUEUE
suffix:colon
(brace
r_int
id|tag
suffix:semicolon
multiline_comment|/* Target mode messages */
r_if
c_cond
(paren
id|devinfo-&gt;role
op_ne
id|ROLE_TARGET
)paren
(brace
id|reject
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tag
op_assign
id|SCB_LIST_NULL
suffix:semicolon
r_if
c_cond
(paren
id|ahd-&gt;msgin_buf
(braket
l_int|0
)braket
op_eq
id|MSG_ABORT_TAG
)paren
id|tag
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|INITIATOR_TAG
)paren
suffix:semicolon
id|ahd_abort_scbs
c_func
(paren
id|ahd
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;lun
comma
id|tag
comma
id|ROLE_TARGET
comma
id|CAM_REQ_ABORTED
)paren
suffix:semicolon
id|tstate
op_assign
id|ahd-&gt;enabled_targets
(braket
id|devinfo-&gt;our_scsiid
)braket
suffix:semicolon
r_if
c_cond
(paren
id|tstate
op_ne
l_int|NULL
)paren
(brace
r_struct
id|ahd_tmode_lstate
op_star
id|lstate
suffix:semicolon
id|lstate
op_assign
id|tstate-&gt;enabled_luns
(braket
id|devinfo-&gt;lun
)braket
suffix:semicolon
r_if
c_cond
(paren
id|lstate
op_ne
l_int|NULL
)paren
(brace
id|ahd_queue_lstate_event
c_func
(paren
id|ahd
comma
id|lstate
comma
id|devinfo-&gt;our_scsiid
comma
id|ahd-&gt;msgin_buf
(braket
l_int|0
)braket
comma
multiline_comment|/*arg*/
id|tag
)paren
suffix:semicolon
id|ahd_send_lstate_events
c_func
(paren
id|ahd
comma
id|lstate
)paren
suffix:semicolon
)brace
)brace
id|ahd_restart
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|done
op_assign
id|MSGLOOP_TERMINATED
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif
r_case
id|MSG_QAS_REQUEST
suffix:colon
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_MESSAGES
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;%s: QAS request.  SCSISIGI == 0x%x&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSISIGI
)paren
)paren
suffix:semicolon
macro_line|#endif
id|ahd-&gt;msg_flags
op_or_assign
id|MSG_FLAG_EXPECT_QASREJ_BUSFREE
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_case
id|MSG_TERM_IO_PROC
suffix:colon
r_default
suffix:colon
id|reject
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reject
)paren
(brace
multiline_comment|/*&n;&t;&t; * Setup to reject the message.&n;&t;&t; */
id|ahd-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|ahd-&gt;msgout_len
op_assign
l_int|1
suffix:semicolon
id|ahd-&gt;msgout_buf
(braket
l_int|0
)braket
op_assign
id|MSG_MESSAGE_REJECT
suffix:semicolon
id|done
op_assign
id|MSGLOOP_MSGCOMPLETE
suffix:semicolon
id|response
op_assign
id|TRUE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|done
op_ne
id|MSGLOOP_IN_PROG
op_logical_and
op_logical_neg
id|response
)paren
multiline_comment|/* Clear the outgoing message buffer */
id|ahd-&gt;msgout_len
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|done
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Process a message reject message.&n; */
r_static
r_int
DECL|function|ahd_handle_msg_reject
id|ahd_handle_msg_reject
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_devinfo
op_star
id|devinfo
)paren
(brace
multiline_comment|/*&n;&t; * What we care about here is if we had an&n;&t; * outstanding SDTR or WDTR message for this&n;&t; * target.  If we did, this is a signal that&n;&t; * the target is refusing negotiation.&n;&t; */
r_struct
id|scb
op_star
id|scb
suffix:semicolon
r_struct
id|ahd_initiator_tinfo
op_star
id|tinfo
suffix:semicolon
r_struct
id|ahd_tmode_tstate
op_star
id|tstate
suffix:semicolon
id|u_int
id|scb_index
suffix:semicolon
id|u_int
id|last_msg
suffix:semicolon
r_int
id|response
op_assign
l_int|0
suffix:semicolon
id|scb_index
op_assign
id|ahd_get_scbptr
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|scb
op_assign
id|ahd_lookup_scb
c_func
(paren
id|ahd
comma
id|scb_index
)paren
suffix:semicolon
id|tinfo
op_assign
id|ahd_fetch_transinfo
c_func
(paren
id|ahd
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;our_scsiid
comma
id|devinfo-&gt;target
comma
op_amp
id|tstate
)paren
suffix:semicolon
multiline_comment|/* Might be necessary */
id|last_msg
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LAST_MSG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahd_sent_msg
c_func
(paren
id|ahd
comma
id|AHDMSG_EXT
comma
id|MSG_EXT_PPR
comma
multiline_comment|/*full*/
id|FALSE
)paren
)paren
(brace
r_if
c_cond
(paren
id|ahd_sent_msg
c_func
(paren
id|ahd
comma
id|AHDMSG_EXT
comma
id|MSG_EXT_PPR
comma
multiline_comment|/*full*/
id|TRUE
)paren
op_logical_and
id|tinfo-&gt;goal.period
op_le
id|AHD_SYNCRATE_PACED
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Target may not like our SPI-4 PPR Options.&n;&t;&t;&t; * Attempt to negotiate 80MHz which will turn&n;&t;&t;&t; * off these options.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|bootverbose
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;(%s:%c:%d:%d): PPR Rejected. &quot;
l_string|&quot;Trying simple U160 PPR&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
)paren
suffix:semicolon
)brace
id|tinfo-&gt;goal.period
op_assign
id|AHD_SYNCRATE_DT
suffix:semicolon
id|tinfo-&gt;goal.ppr_options
op_and_assign
id|MSG_EXT_PPR_IU_REQ
op_or
id|MSG_EXT_PPR_QAS_REQ
op_or
id|MSG_EXT_PPR_DT_REQ
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Target does not support the PPR message.&n;&t;&t;&t; * Attempt to negotiate SPI-2 style.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|bootverbose
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;(%s:%c:%d:%d): PPR Rejected. &quot;
l_string|&quot;Trying WDTR/SDTR&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
)paren
suffix:semicolon
)brace
id|tinfo-&gt;goal.ppr_options
op_assign
l_int|0
suffix:semicolon
id|tinfo-&gt;curr.transport_version
op_assign
l_int|2
suffix:semicolon
id|tinfo-&gt;goal.transport_version
op_assign
l_int|2
suffix:semicolon
)brace
id|ahd-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|ahd-&gt;msgout_len
op_assign
l_int|0
suffix:semicolon
id|ahd_build_transfer_msg
c_func
(paren
id|ahd
comma
id|devinfo
)paren
suffix:semicolon
id|ahd-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|response
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ahd_sent_msg
c_func
(paren
id|ahd
comma
id|AHDMSG_EXT
comma
id|MSG_EXT_WDTR
comma
multiline_comment|/*full*/
id|FALSE
)paren
)paren
(brace
multiline_comment|/* note 8bit xfers */
id|printf
c_func
(paren
l_string|&quot;(%s:%c:%d:%d): refuses WIDE negotiation.  Using &quot;
l_string|&quot;8bit transfers&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
)paren
suffix:semicolon
id|ahd_set_width
c_func
(paren
id|ahd
comma
id|devinfo
comma
id|MSG_EXT_WDTR_BUS_8_BIT
comma
id|AHD_TRANS_ACTIVE
op_or
id|AHD_TRANS_GOAL
comma
multiline_comment|/*paused*/
id|TRUE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * No need to clear the sync rate.  If the target&n;&t;&t; * did not accept the command, our syncrate is&n;&t;&t; * unaffected.  If the target started the negotiation,&n;&t;&t; * but rejected our response, we already cleared the&n;&t;&t; * sync rate before sending our WDTR.&n;&t;&t; */
r_if
c_cond
(paren
id|tinfo-&gt;goal.offset
op_ne
id|tinfo-&gt;curr.offset
)paren
(brace
multiline_comment|/* Start the sync negotiation */
id|ahd-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|ahd-&gt;msgout_len
op_assign
l_int|0
suffix:semicolon
id|ahd_build_transfer_msg
c_func
(paren
id|ahd
comma
id|devinfo
)paren
suffix:semicolon
id|ahd-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|response
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|ahd_sent_msg
c_func
(paren
id|ahd
comma
id|AHDMSG_EXT
comma
id|MSG_EXT_SDTR
comma
multiline_comment|/*full*/
id|FALSE
)paren
)paren
(brace
multiline_comment|/* note asynch xfers and clear flag */
id|ahd_set_syncrate
c_func
(paren
id|ahd
comma
id|devinfo
comma
multiline_comment|/*period*/
l_int|0
comma
multiline_comment|/*offset*/
l_int|0
comma
multiline_comment|/*ppr_options*/
l_int|0
comma
id|AHD_TRANS_ACTIVE
op_or
id|AHD_TRANS_GOAL
comma
multiline_comment|/*paused*/
id|TRUE
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;(%s:%c:%d:%d): refuses synchronous negotiation. &quot;
l_string|&quot;Using asynchronous transfers&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|scb-&gt;hscb-&gt;control
op_amp
id|MSG_SIMPLE_TASK
)paren
op_ne
l_int|0
)paren
(brace
r_int
id|tag_type
suffix:semicolon
r_int
id|mask
suffix:semicolon
id|tag_type
op_assign
(paren
id|scb-&gt;hscb-&gt;control
op_amp
id|MSG_SIMPLE_TASK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tag_type
op_eq
id|MSG_SIMPLE_TASK
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;(%s:%c:%d:%d): refuses tagged commands.  &quot;
l_string|&quot;Performing non-tagged I/O&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
)paren
suffix:semicolon
id|ahd_set_tags
c_func
(paren
id|ahd
comma
id|devinfo
comma
id|AHD_QUEUE_NONE
)paren
suffix:semicolon
id|mask
op_assign
op_complement
l_int|0x23
suffix:semicolon
)brace
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;(%s:%c:%d:%d): refuses %s tagged commands.  &quot;
l_string|&quot;Performing simple queue tagged I/O only&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;lun
comma
id|tag_type
op_eq
id|MSG_ORDERED_TASK
ques
c_cond
l_string|&quot;ordered&quot;
suffix:colon
l_string|&quot;head of queue&quot;
)paren
suffix:semicolon
id|ahd_set_tags
c_func
(paren
id|ahd
comma
id|devinfo
comma
id|AHD_QUEUE_BASIC
)paren
suffix:semicolon
id|mask
op_assign
op_complement
l_int|0x03
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Resend the identify for this CCB as the target&n;&t;&t; * may believe that the selection is invalid otherwise.&n;&t;&t; */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCB_CONTROL
comma
id|ahd_inb_scbram
c_func
(paren
id|ahd
comma
id|SCB_CONTROL
)paren
op_amp
id|mask
)paren
suffix:semicolon
id|scb-&gt;hscb-&gt;control
op_and_assign
id|mask
suffix:semicolon
id|ahd_set_transaction_tag
c_func
(paren
id|scb
comma
multiline_comment|/*enabled*/
id|FALSE
comma
multiline_comment|/*type*/
id|MSG_SIMPLE_TASK
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|MSG_OUT
comma
id|MSG_IDENTIFYFLAG
)paren
suffix:semicolon
id|ahd_assert_atn
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_busy_tcl
c_func
(paren
id|ahd
comma
id|BUILD_TCL
c_func
(paren
id|scb-&gt;hscb-&gt;scsiid
comma
id|devinfo-&gt;lun
)paren
comma
id|SCB_GET_TAG
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Requeue all tagged commands for this target&n;&t;&t; * currently in our posession so they can be&n;&t;&t; * converted to untagged commands.&n;&t;&t; */
id|ahd_search_qinfifo
c_func
(paren
id|ahd
comma
id|SCB_GET_TARGET
c_func
(paren
id|ahd
comma
id|scb
)paren
comma
id|SCB_GET_CHANNEL
c_func
(paren
id|ahd
comma
id|scb
)paren
comma
id|SCB_GET_LUN
c_func
(paren
id|scb
)paren
comma
multiline_comment|/*tag*/
id|SCB_LIST_NULL
comma
id|ROLE_INITIATOR
comma
id|CAM_REQUEUE_REQ
comma
id|SEARCH_COMPLETE
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ahd_sent_msg
c_func
(paren
id|ahd
comma
id|AHDMSG_1B
comma
id|MSG_IDENTIFYFLAG
comma
id|TRUE
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Most likely the device believes that we had&n;&t;&t; * previously negotiated packetized.&n;&t;&t; */
id|ahd-&gt;msg_flags
op_or_assign
id|MSG_FLAG_EXPECT_PPR_BUSFREE
op_or
id|MSG_FLAG_IU_REQ_CHANGED
suffix:semicolon
id|ahd_force_renegotiation
c_func
(paren
id|ahd
comma
id|devinfo
)paren
suffix:semicolon
id|ahd-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|ahd-&gt;msgout_len
op_assign
l_int|0
suffix:semicolon
id|ahd_build_transfer_msg
c_func
(paren
id|ahd
comma
id|devinfo
)paren
suffix:semicolon
id|ahd-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|response
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Otherwise, we ignore it.&n;&t;&t; */
id|printf
c_func
(paren
l_string|&quot;%s:%c:%d: Message reject for %x -- ignored&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|last_msg
)paren
suffix:semicolon
)brace
r_return
(paren
id|response
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Process an ingnore wide residue message.&n; */
r_static
r_void
DECL|function|ahd_handle_ign_wide_residue
id|ahd_handle_ign_wide_residue
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_devinfo
op_star
id|devinfo
)paren
(brace
id|u_int
id|scb_index
suffix:semicolon
r_struct
id|scb
op_star
id|scb
suffix:semicolon
id|scb_index
op_assign
id|ahd_get_scbptr
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|scb
op_assign
id|ahd_lookup_scb
c_func
(paren
id|ahd
comma
id|scb_index
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * XXX Actually check data direction in the sequencer?&n;&t; * Perhaps add datadir to some spare bits in the hscb?&n;&t; */
r_if
c_cond
(paren
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SEQ_FLAGS
)paren
op_amp
id|DPHASE
)paren
op_eq
l_int|0
op_logical_or
id|ahd_get_transfer_dir
c_func
(paren
id|scb
)paren
op_ne
id|CAM_DIR_IN
)paren
(brace
multiline_comment|/*&n;&t;&t; * Ignore the message if we haven&squot;t&n;&t;&t; * seen an appropriate data phase yet.&n;&t;&t; */
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * If the residual occurred on the last&n;&t;&t; * transfer and the transfer request was&n;&t;&t; * expected to end on an odd count, do&n;&t;&t; * nothing.  Otherwise, subtract a byte&n;&t;&t; * and update the residual count accordingly.&n;&t;&t; */
r_uint32
id|sgptr
suffix:semicolon
id|sgptr
op_assign
id|ahd_inb_scbram
c_func
(paren
id|ahd
comma
id|SCB_RESIDUAL_SGPTR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sgptr
op_amp
id|SG_LIST_NULL
)paren
op_ne
l_int|0
op_logical_and
id|ahd_inb
c_func
(paren
id|ahd
comma
id|DATA_COUNT_ODD
)paren
op_eq
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If the residual occurred on the last&n;&t;&t;&t; * transfer and the transfer request was&n;&t;&t;&t; * expected to end on an odd count, do&n;&t;&t;&t; * nothing.&n;&t;&t;&t; */
)brace
r_else
(brace
r_uint32
id|data_cnt
suffix:semicolon
r_uint64
id|data_addr
suffix:semicolon
r_uint32
id|sglen
suffix:semicolon
multiline_comment|/* Pull in the rest of the sgptr */
id|sgptr
op_or_assign
(paren
id|ahd_inb_scbram
c_func
(paren
id|ahd
comma
id|SCB_RESIDUAL_SGPTR
op_plus
l_int|3
)paren
op_lshift
l_int|24
)paren
op_or
(paren
id|ahd_inb_scbram
c_func
(paren
id|ahd
comma
id|SCB_RESIDUAL_SGPTR
op_plus
l_int|2
)paren
op_lshift
l_int|16
)paren
op_or
(paren
id|ahd_inb_scbram
c_func
(paren
id|ahd
comma
id|SCB_RESIDUAL_SGPTR
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
id|sgptr
op_and_assign
id|SG_PTR_MASK
suffix:semicolon
id|data_cnt
op_assign
(paren
id|ahd_inb_scbram
c_func
(paren
id|ahd
comma
id|SCB_RESIDUAL_DATACNT
op_plus
l_int|3
)paren
op_lshift
l_int|24
)paren
op_or
(paren
id|ahd_inb_scbram
c_func
(paren
id|ahd
comma
id|SCB_RESIDUAL_DATACNT
op_plus
l_int|2
)paren
op_lshift
l_int|16
)paren
op_or
(paren
id|ahd_inb_scbram
c_func
(paren
id|ahd
comma
id|SCB_RESIDUAL_DATACNT
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|ahd_inb_scbram
c_func
(paren
id|ahd
comma
id|SCB_RESIDUAL_DATACNT
)paren
)paren
suffix:semicolon
id|data_addr
op_assign
(paren
(paren
(paren
r_uint64
)paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SHADDR
op_plus
l_int|7
)paren
)paren
op_lshift
l_int|56
)paren
op_or
(paren
(paren
(paren
r_uint64
)paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SHADDR
op_plus
l_int|6
)paren
)paren
op_lshift
l_int|48
)paren
op_or
(paren
(paren
(paren
r_uint64
)paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SHADDR
op_plus
l_int|5
)paren
)paren
op_lshift
l_int|40
)paren
op_or
(paren
(paren
(paren
r_uint64
)paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SHADDR
op_plus
l_int|4
)paren
)paren
op_lshift
l_int|32
)paren
op_or
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SHADDR
op_plus
l_int|3
)paren
op_lshift
l_int|24
)paren
op_or
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SHADDR
op_plus
l_int|2
)paren
op_lshift
l_int|16
)paren
op_or
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SHADDR
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SHADDR
)paren
)paren
suffix:semicolon
id|data_cnt
op_add_assign
l_int|1
suffix:semicolon
id|data_addr
op_sub_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;flags
op_amp
id|AHD_64BIT_ADDRESSING
)paren
op_ne
l_int|0
)paren
(brace
r_struct
id|ahd_dma64_seg
op_star
id|sg
suffix:semicolon
id|sg
op_assign
id|ahd_sg_bus_to_virt
c_func
(paren
id|ahd
comma
id|scb
comma
id|sgptr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * The residual sg ptr points to the next S/G&n;&t;&t;&t;&t; * to load so we must go back one.&n;&t;&t;&t;&t; */
id|sg
op_decrement
suffix:semicolon
id|sglen
op_assign
id|ahd_le32toh
c_func
(paren
id|sg-&gt;len
)paren
op_amp
id|AHD_SG_LEN_MASK
suffix:semicolon
r_if
c_cond
(paren
id|sg
op_ne
id|scb-&gt;sg_list
op_logical_and
id|sglen
OL
(paren
id|data_cnt
op_amp
id|AHD_SG_LEN_MASK
)paren
)paren
(brace
id|sg
op_decrement
suffix:semicolon
id|sglen
op_assign
id|ahd_le32toh
c_func
(paren
id|sg-&gt;len
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Preserve High Address and SG_LIST&n;&t;&t;&t;&t;&t; * bits while setting the count to 1.&n;&t;&t;&t;&t;&t; */
id|data_cnt
op_assign
l_int|1
op_or
(paren
id|sglen
op_amp
(paren
op_complement
id|AHD_SG_LEN_MASK
)paren
)paren
suffix:semicolon
id|data_addr
op_assign
id|ahd_le64toh
c_func
(paren
id|sg-&gt;addr
)paren
op_plus
(paren
id|sglen
op_amp
id|AHD_SG_LEN_MASK
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Increment sg so it points to the&n;&t;&t;&t;&t;&t; * &quot;next&quot; sg.&n;&t;&t;&t;&t;&t; */
id|sg
op_increment
suffix:semicolon
id|sgptr
op_assign
id|ahd_sg_virt_to_bus
c_func
(paren
id|ahd
comma
id|scb
comma
id|sg
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_struct
id|ahd_dma_seg
op_star
id|sg
suffix:semicolon
id|sg
op_assign
id|ahd_sg_bus_to_virt
c_func
(paren
id|ahd
comma
id|scb
comma
id|sgptr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * The residual sg ptr points to the next S/G&n;&t;&t;&t;&t; * to load so we must go back one.&n;&t;&t;&t;&t; */
id|sg
op_decrement
suffix:semicolon
id|sglen
op_assign
id|ahd_le32toh
c_func
(paren
id|sg-&gt;len
)paren
op_amp
id|AHD_SG_LEN_MASK
suffix:semicolon
r_if
c_cond
(paren
id|sg
op_ne
id|scb-&gt;sg_list
op_logical_and
id|sglen
OL
(paren
id|data_cnt
op_amp
id|AHD_SG_LEN_MASK
)paren
)paren
(brace
id|sg
op_decrement
suffix:semicolon
id|sglen
op_assign
id|ahd_le32toh
c_func
(paren
id|sg-&gt;len
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Preserve High Address and SG_LIST&n;&t;&t;&t;&t;&t; * bits while setting the count to 1.&n;&t;&t;&t;&t;&t; */
id|data_cnt
op_assign
l_int|1
op_or
(paren
id|sglen
op_amp
(paren
op_complement
id|AHD_SG_LEN_MASK
)paren
)paren
suffix:semicolon
id|data_addr
op_assign
id|ahd_le32toh
c_func
(paren
id|sg-&gt;addr
)paren
op_plus
(paren
id|sglen
op_amp
id|AHD_SG_LEN_MASK
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Increment sg so it points to the&n;&t;&t;&t;&t;&t; * &quot;next&quot; sg.&n;&t;&t;&t;&t;&t; */
id|sg
op_increment
suffix:semicolon
id|sgptr
op_assign
id|ahd_sg_virt_to_bus
c_func
(paren
id|ahd
comma
id|scb
comma
id|sg
)paren
suffix:semicolon
)brace
)brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCB_RESIDUAL_SGPTR
op_plus
l_int|3
comma
id|sgptr
op_rshift
l_int|24
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCB_RESIDUAL_SGPTR
op_plus
l_int|2
comma
id|sgptr
op_rshift
l_int|16
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCB_RESIDUAL_SGPTR
op_plus
l_int|1
comma
id|sgptr
op_rshift
l_int|8
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCB_RESIDUAL_SGPTR
comma
id|sgptr
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCB_RESIDUAL_DATACNT
op_plus
l_int|3
comma
id|data_cnt
op_rshift
l_int|24
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCB_RESIDUAL_DATACNT
op_plus
l_int|2
comma
id|data_cnt
op_rshift
l_int|16
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCB_RESIDUAL_DATACNT
op_plus
l_int|1
comma
id|data_cnt
op_rshift
l_int|8
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCB_RESIDUAL_DATACNT
comma
id|data_cnt
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * The FIFO&squot;s pointers will be updated if/when the&n;&t;&t;&t; * sequencer re-enters a data phase.&n;&t;&t;&t; */
)brace
)brace
)brace
multiline_comment|/*&n; * Reinitialize the data pointers for the active transfer&n; * based on its current residual.&n; */
r_static
r_void
DECL|function|ahd_reinitialize_dataptrs
id|ahd_reinitialize_dataptrs
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
r_struct
id|scb
op_star
id|scb
suffix:semicolon
id|ahd_mode_state
id|saved_modes
suffix:semicolon
id|u_int
id|scb_index
suffix:semicolon
id|u_int
id|wait
suffix:semicolon
r_uint32
id|sgptr
suffix:semicolon
r_uint32
id|resid
suffix:semicolon
r_uint64
id|dataptr
suffix:semicolon
id|AHD_ASSERT_MODES
c_func
(paren
id|ahd
comma
id|AHD_MODE_DFF0_MSK
op_or
id|AHD_MODE_DFF1_MSK
comma
id|AHD_MODE_DFF0_MSK
op_or
id|AHD_MODE_DFF1_MSK
)paren
suffix:semicolon
id|scb_index
op_assign
id|ahd_get_scbptr
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|scb
op_assign
id|ahd_lookup_scb
c_func
(paren
id|ahd
comma
id|scb_index
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Release and reacquire the FIFO so we&n;&t; * have a clean slate.&n;&t; */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|DFFSXFRCTL
comma
id|CLRCHN
)paren
suffix:semicolon
id|wait
op_assign
l_int|1000
suffix:semicolon
r_do
(brace
id|ahd_delay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|wait
op_logical_and
op_logical_neg
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|MDFFSTAT
)paren
op_amp
id|FIFOFREE
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait
op_eq
l_int|0
)paren
(brace
id|ahd_print_path
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;ahd_reinitialize_dataptrs: Forcing FIFO free.&bslash;n&quot;
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|DFFSXFRCTL
comma
id|RSTCHN
op_or
id|CLRSHCNT
)paren
suffix:semicolon
)brace
id|saved_modes
op_assign
id|ahd_save_modes
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI
comma
id|AHD_MODE_SCSI
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|DFFSTAT
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|DFFSTAT
)paren
op_or
(paren
id|saved_modes
op_eq
l_int|0x11
ques
c_cond
id|CURRFIFO_1
suffix:colon
id|CURRFIFO_0
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Determine initial values for data_addr and data_cnt&n;&t; * for resuming the data phase.&n;&t; */
id|sgptr
op_assign
(paren
id|ahd_inb_scbram
c_func
(paren
id|ahd
comma
id|SCB_RESIDUAL_SGPTR
op_plus
l_int|3
)paren
op_lshift
l_int|24
)paren
op_or
(paren
id|ahd_inb_scbram
c_func
(paren
id|ahd
comma
id|SCB_RESIDUAL_SGPTR
op_plus
l_int|2
)paren
op_lshift
l_int|16
)paren
op_or
(paren
id|ahd_inb_scbram
c_func
(paren
id|ahd
comma
id|SCB_RESIDUAL_SGPTR
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
op_or
id|ahd_inb_scbram
c_func
(paren
id|ahd
comma
id|SCB_RESIDUAL_SGPTR
)paren
suffix:semicolon
id|sgptr
op_and_assign
id|SG_PTR_MASK
suffix:semicolon
id|resid
op_assign
(paren
id|ahd_inb_scbram
c_func
(paren
id|ahd
comma
id|SCB_RESIDUAL_DATACNT
op_plus
l_int|2
)paren
op_lshift
l_int|16
)paren
op_or
(paren
id|ahd_inb_scbram
c_func
(paren
id|ahd
comma
id|SCB_RESIDUAL_DATACNT
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
op_or
id|ahd_inb_scbram
c_func
(paren
id|ahd
comma
id|SCB_RESIDUAL_DATACNT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;flags
op_amp
id|AHD_64BIT_ADDRESSING
)paren
op_ne
l_int|0
)paren
(brace
r_struct
id|ahd_dma64_seg
op_star
id|sg
suffix:semicolon
id|sg
op_assign
id|ahd_sg_bus_to_virt
c_func
(paren
id|ahd
comma
id|scb
comma
id|sgptr
)paren
suffix:semicolon
multiline_comment|/* The residual sg_ptr always points to the next sg */
id|sg
op_decrement
suffix:semicolon
id|dataptr
op_assign
id|ahd_le64toh
c_func
(paren
id|sg-&gt;addr
)paren
op_plus
(paren
id|ahd_le32toh
c_func
(paren
id|sg-&gt;len
)paren
op_amp
id|AHD_SG_LEN_MASK
)paren
op_minus
id|resid
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|HADDR
op_plus
l_int|7
comma
id|dataptr
op_rshift
l_int|56
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|HADDR
op_plus
l_int|6
comma
id|dataptr
op_rshift
l_int|48
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|HADDR
op_plus
l_int|5
comma
id|dataptr
op_rshift
l_int|40
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|HADDR
op_plus
l_int|4
comma
id|dataptr
op_rshift
l_int|32
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|ahd_dma_seg
op_star
id|sg
suffix:semicolon
id|sg
op_assign
id|ahd_sg_bus_to_virt
c_func
(paren
id|ahd
comma
id|scb
comma
id|sgptr
)paren
suffix:semicolon
multiline_comment|/* The residual sg_ptr always points to the next sg */
id|sg
op_decrement
suffix:semicolon
id|dataptr
op_assign
id|ahd_le32toh
c_func
(paren
id|sg-&gt;addr
)paren
op_plus
(paren
id|ahd_le32toh
c_func
(paren
id|sg-&gt;len
)paren
op_amp
id|AHD_SG_LEN_MASK
)paren
op_minus
id|resid
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|HADDR
op_plus
l_int|4
comma
(paren
id|ahd_le32toh
c_func
(paren
id|sg-&gt;len
)paren
op_amp
op_complement
id|AHD_SG_LEN_MASK
)paren
op_rshift
l_int|24
)paren
suffix:semicolon
)brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|HADDR
op_plus
l_int|3
comma
id|dataptr
op_rshift
l_int|24
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|HADDR
op_plus
l_int|2
comma
id|dataptr
op_rshift
l_int|16
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|HADDR
op_plus
l_int|1
comma
id|dataptr
op_rshift
l_int|8
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|HADDR
comma
id|dataptr
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|HCNT
op_plus
l_int|2
comma
id|resid
op_rshift
l_int|16
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|HCNT
op_plus
l_int|1
comma
id|resid
op_rshift
l_int|8
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|HCNT
comma
id|resid
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Handle the effects of issuing a bus device reset message.&n; */
r_static
r_void
DECL|function|ahd_handle_devreset
id|ahd_handle_devreset
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_devinfo
op_star
id|devinfo
comma
id|u_int
id|lun
comma
id|cam_status
id|status
comma
r_char
op_star
id|message
comma
r_int
id|verbose_level
)paren
(brace
macro_line|#ifdef AHD_TARGET_MODE
r_struct
id|ahd_tmode_tstate
op_star
id|tstate
suffix:semicolon
macro_line|#endif
r_int
id|found
suffix:semicolon
id|found
op_assign
id|ahd_abort_scbs
c_func
(paren
id|ahd
comma
id|devinfo-&gt;target
comma
id|devinfo-&gt;channel
comma
id|lun
comma
id|SCB_LIST_NULL
comma
id|devinfo-&gt;role
comma
id|status
)paren
suffix:semicolon
macro_line|#ifdef AHD_TARGET_MODE
multiline_comment|/*&n;&t; * Send an immediate notify ccb to all target mord peripheral&n;&t; * drivers affected by this action.&n;&t; */
id|tstate
op_assign
id|ahd-&gt;enabled_targets
(braket
id|devinfo-&gt;our_scsiid
)braket
suffix:semicolon
r_if
c_cond
(paren
id|tstate
op_ne
l_int|NULL
)paren
(brace
id|u_int
id|cur_lun
suffix:semicolon
id|u_int
id|max_lun
suffix:semicolon
r_if
c_cond
(paren
id|lun
op_ne
id|CAM_LUN_WILDCARD
)paren
(brace
id|cur_lun
op_assign
l_int|0
suffix:semicolon
id|max_lun
op_assign
id|AHD_NUM_LUNS
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|cur_lun
op_assign
id|lun
suffix:semicolon
id|max_lun
op_assign
id|lun
suffix:semicolon
)brace
r_for
c_loop
(paren
id|cur_lun
op_le
id|max_lun
suffix:semicolon
id|cur_lun
op_increment
)paren
(brace
r_struct
id|ahd_tmode_lstate
op_star
id|lstate
suffix:semicolon
id|lstate
op_assign
id|tstate-&gt;enabled_luns
(braket
id|cur_lun
)braket
suffix:semicolon
r_if
c_cond
(paren
id|lstate
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|ahd_queue_lstate_event
c_func
(paren
id|ahd
comma
id|lstate
comma
id|devinfo-&gt;our_scsiid
comma
id|MSG_BUS_DEV_RESET
comma
multiline_comment|/*arg*/
l_int|0
)paren
suffix:semicolon
id|ahd_send_lstate_events
c_func
(paren
id|ahd
comma
id|lstate
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Go back to async/narrow transfers and renegotiate.&n;&t; */
id|ahd_set_width
c_func
(paren
id|ahd
comma
id|devinfo
comma
id|MSG_EXT_WDTR_BUS_8_BIT
comma
id|AHD_TRANS_CUR
comma
multiline_comment|/*paused*/
id|TRUE
)paren
suffix:semicolon
id|ahd_set_syncrate
c_func
(paren
id|ahd
comma
id|devinfo
comma
multiline_comment|/*period*/
l_int|0
comma
multiline_comment|/*offset*/
l_int|0
comma
multiline_comment|/*ppr_options*/
l_int|0
comma
id|AHD_TRANS_CUR
comma
multiline_comment|/*paused*/
id|TRUE
)paren
suffix:semicolon
id|ahd_send_async
c_func
(paren
id|ahd
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|lun
comma
id|AC_SENT_BDR
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|message
op_ne
l_int|NULL
op_logical_and
(paren
id|verbose_level
op_le
id|bootverbose
)paren
)paren
id|printf
c_func
(paren
l_string|&quot;%s: %s on %c:%d. %d SCBs aborted&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|message
comma
id|devinfo-&gt;channel
comma
id|devinfo-&gt;target
comma
id|found
)paren
suffix:semicolon
)brace
macro_line|#ifdef AHD_TARGET_MODE
r_static
r_void
DECL|function|ahd_setup_target_msgin
id|ahd_setup_target_msgin
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_devinfo
op_star
id|devinfo
comma
r_struct
id|scb
op_star
id|scb
)paren
(brace
multiline_comment|/*              &n;&t; * To facilitate adding multiple messages together,&n;&t; * each routine should increment the index and len&n;&t; * variables instead of setting them explicitly.&n;&t; */
id|ahd-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|ahd-&gt;msgout_len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_ne
l_int|NULL
op_logical_and
(paren
id|scb-&gt;flags
op_amp
id|SCB_AUTO_NEGOTIATE
)paren
op_ne
l_int|0
)paren
id|ahd_build_transfer_msg
c_func
(paren
id|ahd
comma
id|devinfo
)paren
suffix:semicolon
r_else
id|panic
c_func
(paren
l_string|&quot;ahd_intr: AWAITING target message with no message&quot;
)paren
suffix:semicolon
id|ahd-&gt;msgout_index
op_assign
l_int|0
suffix:semicolon
id|ahd-&gt;msg_type
op_assign
id|MSG_TYPE_TARGET_MSGIN
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/**************************** Initialization **********************************/
r_static
id|u_int
DECL|function|ahd_sglist_size
id|ahd_sglist_size
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
id|bus_size_t
id|list_size
suffix:semicolon
id|list_size
op_assign
r_sizeof
(paren
r_struct
id|ahd_dma_seg
)paren
op_star
id|AHD_NSEG
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;flags
op_amp
id|AHD_64BIT_ADDRESSING
)paren
op_ne
l_int|0
)paren
id|list_size
op_assign
r_sizeof
(paren
r_struct
id|ahd_dma64_seg
)paren
op_star
id|AHD_NSEG
suffix:semicolon
r_return
(paren
id|list_size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Calculate the optimum S/G List allocation size.  S/G elements used&n; * for a given transaction must be physically contiguous.  Assume the&n; * OS will allocate full pages to us, so it doesn&squot;t make sense to request&n; * less than a page.&n; */
r_static
id|u_int
DECL|function|ahd_sglist_allocsize
id|ahd_sglist_allocsize
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
id|bus_size_t
id|sg_list_increment
suffix:semicolon
id|bus_size_t
id|sg_list_size
suffix:semicolon
id|bus_size_t
id|max_list_size
suffix:semicolon
id|bus_size_t
id|best_list_size
suffix:semicolon
multiline_comment|/* Start out with the minimum required for AHD_NSEG. */
id|sg_list_increment
op_assign
id|ahd_sglist_size
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|sg_list_size
op_assign
id|sg_list_increment
suffix:semicolon
multiline_comment|/* Get us as close as possible to a page in size. */
r_while
c_loop
(paren
(paren
id|sg_list_size
op_plus
id|sg_list_increment
)paren
op_le
id|PAGE_SIZE
)paren
id|sg_list_size
op_add_assign
id|sg_list_increment
suffix:semicolon
multiline_comment|/*&n;&t; * Try to reduce the amount of wastage by allocating&n;&t; * multiple pages.&n;&t; */
id|best_list_size
op_assign
id|sg_list_size
suffix:semicolon
id|max_list_size
op_assign
id|roundup
c_func
(paren
id|sg_list_increment
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|max_list_size
OL
l_int|4
op_star
id|PAGE_SIZE
)paren
id|max_list_size
op_assign
l_int|4
op_star
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|max_list_size
OG
(paren
id|AHD_SCB_MAX_ALLOC
op_star
id|sg_list_increment
)paren
)paren
id|max_list_size
op_assign
(paren
id|AHD_SCB_MAX_ALLOC
op_star
id|sg_list_increment
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|sg_list_size
op_plus
id|sg_list_increment
)paren
op_le
id|max_list_size
op_logical_and
(paren
id|sg_list_size
op_mod
id|PAGE_SIZE
)paren
op_ne
l_int|0
)paren
(brace
id|bus_size_t
id|new_mod
suffix:semicolon
id|bus_size_t
id|best_mod
suffix:semicolon
id|sg_list_size
op_add_assign
id|sg_list_increment
suffix:semicolon
id|new_mod
op_assign
id|sg_list_size
op_mod
id|PAGE_SIZE
suffix:semicolon
id|best_mod
op_assign
id|best_list_size
op_mod
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|new_mod
OG
id|best_mod
op_logical_or
id|new_mod
op_eq
l_int|0
)paren
(brace
id|best_list_size
op_assign
id|sg_list_size
suffix:semicolon
)brace
)brace
r_return
(paren
id|best_list_size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate a controller structure for a new device&n; * and perform initial initializion.&n; */
r_struct
id|ahd_softc
op_star
DECL|function|ahd_alloc
id|ahd_alloc
c_func
(paren
r_void
op_star
id|platform_arg
comma
r_char
op_star
id|name
)paren
(brace
r_struct
id|ahd_softc
op_star
id|ahd
suffix:semicolon
macro_line|#ifndef&t;__FreeBSD__
id|ahd
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|ahd
)paren
comma
id|M_DEVBUF
comma
id|M_NOWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ahd
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;aic7xxx: cannot malloc softc!&bslash;n&quot;
)paren
suffix:semicolon
id|free
c_func
(paren
id|name
comma
id|M_DEVBUF
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#else
id|ahd
op_assign
id|device_get_softc
c_func
(paren
(paren
id|device_t
)paren
id|platform_arg
)paren
suffix:semicolon
macro_line|#endif
id|memset
c_func
(paren
id|ahd
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|ahd
)paren
)paren
suffix:semicolon
id|ahd-&gt;seep_config
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|ahd-&gt;seep_config
)paren
comma
id|M_DEVBUF
comma
id|M_NOWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahd-&gt;seep_config
op_eq
l_int|NULL
)paren
(brace
macro_line|#ifndef&t;__FreeBSD__
id|free
c_func
(paren
id|ahd
comma
id|M_DEVBUF
)paren
suffix:semicolon
macro_line|#endif
id|free
c_func
(paren
id|name
comma
id|M_DEVBUF
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
id|LIST_INIT
c_func
(paren
op_amp
id|ahd-&gt;pending_scbs
)paren
suffix:semicolon
multiline_comment|/* We don&squot;t know our unit number until the OSM sets it */
id|ahd-&gt;name
op_assign
id|name
suffix:semicolon
id|ahd-&gt;unit
op_assign
op_minus
l_int|1
suffix:semicolon
id|ahd-&gt;description
op_assign
l_int|NULL
suffix:semicolon
id|ahd-&gt;bus_description
op_assign
l_int|NULL
suffix:semicolon
id|ahd-&gt;channel
op_assign
l_char|&squot;A&squot;
suffix:semicolon
id|ahd-&gt;chip
op_assign
id|AHD_NONE
suffix:semicolon
id|ahd-&gt;features
op_assign
id|AHD_FENONE
suffix:semicolon
id|ahd-&gt;bugs
op_assign
id|AHD_BUGNONE
suffix:semicolon
id|ahd-&gt;flags
op_assign
id|AHD_SPCHK_ENB_A
op_or
id|AHD_RESET_BUS_A
op_or
id|AHD_TERM_ENB_A
op_or
id|AHD_EXTENDED_TRANS_A
op_or
id|AHD_STPWLEVEL_A
suffix:semicolon
id|ahd_timer_init
c_func
(paren
op_amp
id|ahd-&gt;reset_timer
)paren
suffix:semicolon
id|ahd_timer_init
c_func
(paren
op_amp
id|ahd-&gt;stat_timer
)paren
suffix:semicolon
id|ahd-&gt;int_coalessing_timer
op_assign
id|AHD_INT_COALESSING_TIMER_DEFAULT
suffix:semicolon
id|ahd-&gt;int_coalessing_maxcmds
op_assign
id|AHD_INT_COALESSING_MAXCMDS_DEFAULT
suffix:semicolon
id|ahd-&gt;int_coalessing_mincmds
op_assign
id|AHD_INT_COALESSING_MINCMDS_DEFAULT
suffix:semicolon
id|ahd-&gt;int_coalessing_threshold
op_assign
id|AHD_INT_COALESSING_THRESHOLD_DEFAULT
suffix:semicolon
id|ahd-&gt;int_coalessing_stop_threshold
op_assign
id|AHD_INT_COALESSING_STOP_THRESHOLD_DEFAULT
suffix:semicolon
r_if
c_cond
(paren
id|ahd_platform_alloc
c_func
(paren
id|ahd
comma
id|platform_arg
)paren
op_ne
l_int|0
)paren
(brace
id|ahd_free
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_MEMORY
)paren
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: scb size = 0x%x, hscb size = 0x%x&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
(paren
id|u_int
)paren
r_sizeof
(paren
r_struct
id|scb
)paren
comma
(paren
id|u_int
)paren
r_sizeof
(paren
r_struct
id|hardware_scb
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
(paren
id|ahd
)paren
suffix:semicolon
)brace
r_int
DECL|function|ahd_softc_init
id|ahd_softc_init
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
id|ahd-&gt;unpause
op_assign
l_int|0
suffix:semicolon
id|ahd-&gt;pause
op_assign
id|PAUSE
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahd_softc_insert
id|ahd_softc_insert
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
r_struct
id|ahd_softc
op_star
id|list_ahd
suffix:semicolon
macro_line|#if AHD_PCI_CONFIG &gt; 0
multiline_comment|/*&n;&t; * Second Function PCI devices need to inherit some&n;&t; * settings from function 0.&n;&t; */
r_if
c_cond
(paren
(paren
id|ahd-&gt;features
op_amp
id|AHD_MULTI_FUNC
)paren
op_ne
l_int|0
)paren
(brace
id|TAILQ_FOREACH
c_func
(paren
id|list_ahd
comma
op_amp
id|ahd_tailq
comma
id|links
)paren
(brace
id|ahd_dev_softc_t
id|list_pci
suffix:semicolon
id|ahd_dev_softc_t
id|pci
suffix:semicolon
id|list_pci
op_assign
id|list_ahd-&gt;dev_softc
suffix:semicolon
id|pci
op_assign
id|ahd-&gt;dev_softc
suffix:semicolon
r_if
c_cond
(paren
id|ahd_get_pci_slot
c_func
(paren
id|list_pci
)paren
op_eq
id|ahd_get_pci_slot
c_func
(paren
id|pci
)paren
op_logical_and
id|ahd_get_pci_bus
c_func
(paren
id|list_pci
)paren
op_eq
id|ahd_get_pci_bus
c_func
(paren
id|pci
)paren
)paren
(brace
r_struct
id|ahd_softc
op_star
id|master
suffix:semicolon
r_struct
id|ahd_softc
op_star
id|slave
suffix:semicolon
r_if
c_cond
(paren
id|ahd_get_pci_function
c_func
(paren
id|list_pci
)paren
op_eq
l_int|0
)paren
(brace
id|master
op_assign
id|list_ahd
suffix:semicolon
id|slave
op_assign
id|ahd
suffix:semicolon
)brace
r_else
(brace
id|master
op_assign
id|ahd
suffix:semicolon
id|slave
op_assign
id|list_ahd
suffix:semicolon
)brace
id|slave-&gt;flags
op_and_assign
op_complement
id|AHD_BIOS_ENABLED
suffix:semicolon
id|slave-&gt;flags
op_or_assign
id|master-&gt;flags
op_amp
id|AHD_BIOS_ENABLED
suffix:semicolon
id|slave-&gt;flags
op_and_assign
op_complement
id|AHD_PRIMARY_CHANNEL
suffix:semicolon
id|slave-&gt;flags
op_or_assign
id|master-&gt;flags
op_amp
id|AHD_PRIMARY_CHANNEL
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Insertion sort into our list of softcs.&n;&t; */
id|list_ahd
op_assign
id|TAILQ_FIRST
c_func
(paren
op_amp
id|ahd_tailq
)paren
suffix:semicolon
r_while
c_loop
(paren
id|list_ahd
op_ne
l_int|NULL
op_logical_and
id|ahd_softc_comp
c_func
(paren
id|list_ahd
comma
id|ahd
)paren
op_le
l_int|0
)paren
id|list_ahd
op_assign
id|TAILQ_NEXT
c_func
(paren
id|list_ahd
comma
id|links
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_ahd
op_ne
l_int|NULL
)paren
id|TAILQ_INSERT_BEFORE
c_func
(paren
id|list_ahd
comma
id|ahd
comma
id|links
)paren
suffix:semicolon
r_else
id|TAILQ_INSERT_TAIL
c_func
(paren
op_amp
id|ahd_tailq
comma
id|ahd
comma
id|links
)paren
suffix:semicolon
id|ahd-&gt;init_level
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; * Verify that the passed in softc pointer is for a&n; * controller that is still configured.&n; */
r_struct
id|ahd_softc
op_star
DECL|function|ahd_find_softc
id|ahd_find_softc
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
r_struct
id|ahd_softc
op_star
id|list_ahd
suffix:semicolon
id|TAILQ_FOREACH
c_func
(paren
id|list_ahd
comma
op_amp
id|ahd_tailq
comma
id|links
)paren
(brace
r_if
c_cond
(paren
id|list_ahd
op_eq
id|ahd
)paren
r_return
(paren
id|ahd
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahd_set_unit
id|ahd_set_unit
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_int
id|unit
)paren
(brace
id|ahd-&gt;unit
op_assign
id|unit
suffix:semicolon
)brace
r_void
DECL|function|ahd_set_name
id|ahd_set_name
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_char
op_star
id|name
)paren
(brace
r_if
c_cond
(paren
id|ahd-&gt;name
op_ne
l_int|NULL
)paren
id|free
c_func
(paren
id|ahd-&gt;name
comma
id|M_DEVBUF
)paren
suffix:semicolon
id|ahd-&gt;name
op_assign
id|name
suffix:semicolon
)brace
r_void
DECL|function|ahd_free
id|ahd_free
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
r_int
id|i
suffix:semicolon
id|ahd_fini_scbdata
c_func
(paren
id|ahd
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ahd-&gt;init_level
)paren
(brace
r_default
suffix:colon
r_case
l_int|5
suffix:colon
id|ahd_shutdown
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|TAILQ_REMOVE
c_func
(paren
op_amp
id|ahd_tailq
comma
id|ahd
comma
id|links
)paren
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_case
l_int|4
suffix:colon
id|ahd_dmamap_unload
c_func
(paren
id|ahd
comma
id|ahd-&gt;shared_data_dmat
comma
id|ahd-&gt;shared_data_dmamap
)paren
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_case
l_int|3
suffix:colon
id|ahd_dmamem_free
c_func
(paren
id|ahd
comma
id|ahd-&gt;shared_data_dmat
comma
id|ahd-&gt;qoutfifo
comma
id|ahd-&gt;shared_data_dmamap
)paren
suffix:semicolon
id|ahd_dmamap_destroy
c_func
(paren
id|ahd
comma
id|ahd-&gt;shared_data_dmat
comma
id|ahd-&gt;shared_data_dmamap
)paren
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_case
l_int|2
suffix:colon
id|ahd_dma_tag_destroy
c_func
(paren
id|ahd
comma
id|ahd-&gt;shared_data_dmat
)paren
suffix:semicolon
r_case
l_int|1
suffix:colon
macro_line|#ifndef __linux__
id|ahd_dma_tag_destroy
c_func
(paren
id|ahd
comma
id|ahd-&gt;buffer_dmat
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
)brace
macro_line|#ifndef __linux__
id|ahd_dma_tag_destroy
c_func
(paren
id|ahd
comma
id|ahd-&gt;parent_dmat
)paren
suffix:semicolon
macro_line|#endif
id|ahd_platform_free
c_func
(paren
id|ahd
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AHD_NUM_TARGETS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|ahd_tmode_tstate
op_star
id|tstate
suffix:semicolon
id|tstate
op_assign
id|ahd-&gt;enabled_targets
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|tstate
op_ne
l_int|NULL
)paren
(brace
macro_line|#if AHD_TARGET_MODE
r_int
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|AHD_NUM_LUNS
suffix:semicolon
id|j
op_increment
)paren
(brace
r_struct
id|ahd_tmode_lstate
op_star
id|lstate
suffix:semicolon
id|lstate
op_assign
id|tstate-&gt;enabled_luns
(braket
id|j
)braket
suffix:semicolon
r_if
c_cond
(paren
id|lstate
op_ne
l_int|NULL
)paren
(brace
id|xpt_free_path
c_func
(paren
id|lstate-&gt;path
)paren
suffix:semicolon
id|free
c_func
(paren
id|lstate
comma
id|M_DEVBUF
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
id|free
c_func
(paren
id|tstate
comma
id|M_DEVBUF
)paren
suffix:semicolon
)brace
)brace
macro_line|#if AHD_TARGET_MODE
r_if
c_cond
(paren
id|ahd-&gt;black_hole
op_ne
l_int|NULL
)paren
(brace
id|xpt_free_path
c_func
(paren
id|ahd-&gt;black_hole-&gt;path
)paren
suffix:semicolon
id|free
c_func
(paren
id|ahd-&gt;black_hole
comma
id|M_DEVBUF
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|ahd-&gt;name
op_ne
l_int|NULL
)paren
id|free
c_func
(paren
id|ahd-&gt;name
comma
id|M_DEVBUF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahd-&gt;seep_config
op_ne
l_int|NULL
)paren
id|free
c_func
(paren
id|ahd-&gt;seep_config
comma
id|M_DEVBUF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahd-&gt;saved_stack
op_ne
l_int|NULL
)paren
id|free
c_func
(paren
id|ahd-&gt;saved_stack
comma
id|M_DEVBUF
)paren
suffix:semicolon
macro_line|#ifndef __FreeBSD__
id|free
c_func
(paren
id|ahd
comma
id|M_DEVBUF
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
r_void
DECL|function|ahd_shutdown
id|ahd_shutdown
c_func
(paren
r_void
op_star
id|arg
)paren
(brace
r_struct
id|ahd_softc
op_star
id|ahd
suffix:semicolon
id|ahd
op_assign
(paren
r_struct
id|ahd_softc
op_star
)paren
id|arg
suffix:semicolon
multiline_comment|/*&n;&t; * Stop periodic timer callbacks.&n;&t; */
id|ahd_timer_stop
c_func
(paren
op_amp
id|ahd-&gt;reset_timer
)paren
suffix:semicolon
id|ahd_timer_stop
c_func
(paren
op_amp
id|ahd-&gt;stat_timer
)paren
suffix:semicolon
multiline_comment|/* This will reset most registers to 0, but not all */
id|ahd_reset
c_func
(paren
id|ahd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Reset the controller and record some information about it&n; * that is only available just after a reset.&n; */
r_int
DECL|function|ahd_reset
id|ahd_reset
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
id|u_int
id|sxfrctl1
suffix:semicolon
r_int
id|wait
suffix:semicolon
r_uint32
id|cmd
suffix:semicolon
multiline_comment|/*&n;&t; * Preserve the value of the SXFRCTL1 register for all channels.&n;&t; * It contains settings that affect termination and we don&squot;t want&n;&t; * to disturb the integrity of the bus.&n;&t; */
id|ahd_pause
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|sxfrctl1
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SXFRCTL1
)paren
suffix:semicolon
id|cmd
op_assign
id|ahd_pci_read_config
c_func
(paren
id|ahd-&gt;dev_softc
comma
id|PCIR_COMMAND
comma
multiline_comment|/*bytes*/
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;bugs
op_amp
id|AHD_PCIX_CHIPRST_BUG
)paren
op_ne
l_int|0
)paren
(brace
r_uint32
id|mod_cmd
suffix:semicolon
multiline_comment|/*&n;&t;&t; * A4 Razor #632&n;&t;&t; * During the assertion of CHIPRST, the chip&n;&t;&t; * does not disable its parity logic prior to&n;&t;&t; * the start of the reset.  This may cause a&n;&t;&t; * parity error to be detected and thus a&n;&t;&t; * spurious SERR or PERR assertion.  Disble&n;&t;&t; * PERR and SERR responses during the CHIPRST.&n;&t;&t; */
id|mod_cmd
op_assign
id|cmd
op_amp
op_complement
(paren
id|PCIM_CMD_PERRESPEN
op_or
id|PCIM_CMD_SERRESPEN
)paren
suffix:semicolon
id|ahd_pci_write_config
c_func
(paren
id|ahd-&gt;dev_softc
comma
id|PCIR_COMMAND
comma
id|mod_cmd
comma
multiline_comment|/*bytes*/
l_int|2
)paren
suffix:semicolon
)brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|HCNTRL
comma
id|CHIPRST
op_or
id|ahd-&gt;pause
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ensure that the reset has finished.  We delay 1000us&n;&t; * prior to reading the register to make sure the chip&n;&t; * has sufficiently completed its reset to handle register&n;&t; * accesses.&n;&t; */
id|wait
op_assign
l_int|1000
suffix:semicolon
r_do
(brace
id|ahd_delay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|wait
op_logical_and
op_logical_neg
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|HCNTRL
)paren
op_amp
id|CHIPRSTACK
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: WARNING - Failed chip reset!  &quot;
l_string|&quot;Trying to initialize anyway.&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
)brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|HCNTRL
comma
id|ahd-&gt;pause
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;bugs
op_amp
id|AHD_PCIX_CHIPRST_BUG
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Clear any latched PCI error status and restore&n;&t;&t; * previous SERR and PERR response enables.&n;&t;&t; */
id|ahd_pci_write_config
c_func
(paren
id|ahd-&gt;dev_softc
comma
id|PCIR_STATUS
op_plus
l_int|1
comma
l_int|0xFF
comma
multiline_comment|/*bytes*/
l_int|1
)paren
suffix:semicolon
id|ahd_pci_write_config
c_func
(paren
id|ahd-&gt;dev_softc
comma
id|PCIR_COMMAND
comma
id|cmd
comma
multiline_comment|/*bytes*/
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/* After a reset, we know the state of the mode register. */
id|ahd_known_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI
comma
id|AHD_MODE_SCSI
)paren
suffix:semicolon
multiline_comment|/* Determine chip configuration */
id|ahd-&gt;features
op_and_assign
op_complement
id|AHD_WIDE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SBLKCTL
)paren
op_amp
id|SELWIDE
)paren
op_ne
l_int|0
)paren
id|ahd-&gt;features
op_or_assign
id|AHD_WIDE
suffix:semicolon
multiline_comment|/*&n;&t; * Restore SXFRCTL1.&n;&t; *&n;&t; * We must always initialize STPWEN to 1 before we&n;&t; * restore the saved values.  STPWEN is initialized&n;&t; * to a tri-state condition which can only be cleared&n;&t; * by turning it on.&n;&t; */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SXFRCTL1
comma
id|sxfrctl1
op_or
id|STPWEN
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SXFRCTL1
comma
id|sxfrctl1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If a recovery action has forced a chip reset,&n;&t; * re-initialize the chip to our liking.&n;&t; */
r_if
c_cond
(paren
id|ahd-&gt;init_level
OG
l_int|0
)paren
id|ahd_chip_init
c_func
(paren
id|ahd
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Determine the number of SCBs available on the controller&n; */
r_int
DECL|function|ahd_probe_scbs
id|ahd_probe_scbs
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
r_int
id|i
suffix:semicolon
id|AHD_ASSERT_MODES
c_func
(paren
id|ahd
comma
op_complement
(paren
id|AHD_MODE_UNKNOWN_MSK
op_or
id|AHD_MODE_CFG_MSK
)paren
comma
op_complement
(paren
id|AHD_MODE_UNKNOWN_MSK
op_or
id|AHD_MODE_CFG_MSK
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AHD_SCB_MAX
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|j
suffix:semicolon
id|ahd_set_scbptr
c_func
(paren
id|ahd
comma
id|i
)paren
suffix:semicolon
id|ahd_outw
c_func
(paren
id|ahd
comma
id|SCB_BASE
comma
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|2
suffix:semicolon
id|j
OL
l_int|64
suffix:semicolon
id|j
op_increment
)paren
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCB_BASE
op_plus
id|j
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Start out life as unallocated (needing an abort) */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCB_CONTROL
comma
id|MK_MESSAGE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahd_inw_scbram
c_func
(paren
id|ahd
comma
id|SCB_BASE
)paren
op_ne
id|i
)paren
r_break
suffix:semicolon
id|ahd_set_scbptr
c_func
(paren
id|ahd
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahd_inw_scbram
c_func
(paren
id|ahd
comma
id|SCB_BASE
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_return
(paren
id|i
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahd_dmamap_cb
id|ahd_dmamap_cb
c_func
(paren
r_void
op_star
id|arg
comma
id|bus_dma_segment_t
op_star
id|segs
comma
r_int
id|nseg
comma
r_int
id|error
)paren
(brace
id|bus_addr_t
op_star
id|baddr
suffix:semicolon
id|baddr
op_assign
(paren
id|bus_addr_t
op_star
)paren
id|arg
suffix:semicolon
op_star
id|baddr
op_assign
id|segs-&gt;ds_addr
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahd_initialize_hscbs
id|ahd_initialize_hscbs
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ahd-&gt;scb_data.maxhscbs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ahd_set_scbptr
c_func
(paren
id|ahd
comma
id|i
)paren
suffix:semicolon
multiline_comment|/* Clear the control byte. */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCB_CONTROL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Set the next pointer */
id|ahd_outw
c_func
(paren
id|ahd
comma
id|SCB_NEXT
comma
id|SCB_LIST_NULL
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|ahd_init_scbdata
id|ahd_init_scbdata
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
r_struct
id|scb_data
op_star
id|scb_data
suffix:semicolon
r_int
id|i
suffix:semicolon
id|scb_data
op_assign
op_amp
id|ahd-&gt;scb_data
suffix:semicolon
id|TAILQ_INIT
c_func
(paren
op_amp
id|scb_data-&gt;free_scbs
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AHD_NUM_TARGETS
op_star
id|AHD_NUM_LUNS_NONPKT
suffix:semicolon
id|i
op_increment
)paren
id|LIST_INIT
c_func
(paren
op_amp
id|scb_data-&gt;free_scb_lists
(braket
id|i
)braket
)paren
suffix:semicolon
id|LIST_INIT
c_func
(paren
op_amp
id|scb_data-&gt;any_dev_free_scb_list
)paren
suffix:semicolon
id|SLIST_INIT
c_func
(paren
op_amp
id|scb_data-&gt;hscb_maps
)paren
suffix:semicolon
id|SLIST_INIT
c_func
(paren
op_amp
id|scb_data-&gt;sg_maps
)paren
suffix:semicolon
id|SLIST_INIT
c_func
(paren
op_amp
id|scb_data-&gt;sense_maps
)paren
suffix:semicolon
multiline_comment|/* Determine the number of hardware SCBs and initialize them */
id|scb_data-&gt;maxhscbs
op_assign
id|ahd_probe_scbs
c_func
(paren
id|ahd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb_data-&gt;maxhscbs
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: No SCB space found&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
r_return
(paren
id|ENXIO
)paren
suffix:semicolon
)brace
id|ahd_initialize_hscbs
c_func
(paren
id|ahd
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Create our DMA tags.  These tags define the kinds of device&n;&t; * accessible memory allocations and memory mappings we will&n;&t; * need to perform during normal operation.&n;&t; *&n;&t; * Unless we need to further restrict the allocation, we rely&n;&t; * on the restrictions of the parent dmat, hence the common&n;&t; * use of MAXADDR and MAXSIZE.&n;&t; */
multiline_comment|/* DMA tag for our hardware scb structures */
r_if
c_cond
(paren
id|ahd_dma_tag_create
c_func
(paren
id|ahd
comma
id|ahd-&gt;parent_dmat
comma
multiline_comment|/*alignment*/
l_int|1
comma
multiline_comment|/*boundary*/
id|BUS_SPACE_MAXADDR_32BIT
op_plus
l_int|1
comma
multiline_comment|/*lowaddr*/
id|BUS_SPACE_MAXADDR_32BIT
comma
multiline_comment|/*highaddr*/
id|BUS_SPACE_MAXADDR
comma
multiline_comment|/*filter*/
l_int|NULL
comma
multiline_comment|/*filterarg*/
l_int|NULL
comma
id|PAGE_SIZE
comma
multiline_comment|/*nsegments*/
l_int|1
comma
multiline_comment|/*maxsegsz*/
id|BUS_SPACE_MAXSIZE_32BIT
comma
multiline_comment|/*flags*/
l_int|0
comma
op_amp
id|scb_data-&gt;hscb_dmat
)paren
op_ne
l_int|0
)paren
(brace
r_goto
id|error_exit
suffix:semicolon
)brace
id|scb_data-&gt;init_level
op_increment
suffix:semicolon
multiline_comment|/* DMA tag for our S/G structures. */
r_if
c_cond
(paren
id|ahd_dma_tag_create
c_func
(paren
id|ahd
comma
id|ahd-&gt;parent_dmat
comma
multiline_comment|/*alignment*/
l_int|1
comma
multiline_comment|/*boundary*/
id|BUS_SPACE_MAXADDR_32BIT
op_plus
l_int|1
comma
multiline_comment|/*lowaddr*/
id|BUS_SPACE_MAXADDR_32BIT
comma
multiline_comment|/*highaddr*/
id|BUS_SPACE_MAXADDR
comma
multiline_comment|/*filter*/
l_int|NULL
comma
multiline_comment|/*filterarg*/
l_int|NULL
comma
id|ahd_sglist_allocsize
c_func
(paren
id|ahd
)paren
comma
multiline_comment|/*nsegments*/
l_int|1
comma
multiline_comment|/*maxsegsz*/
id|BUS_SPACE_MAXSIZE_32BIT
comma
multiline_comment|/*flags*/
l_int|0
comma
op_amp
id|scb_data-&gt;sg_dmat
)paren
op_ne
l_int|0
)paren
(brace
r_goto
id|error_exit
suffix:semicolon
)brace
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_MEMORY
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;%s: ahd_sglist_allocsize = 0x%x&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|ahd_sglist_allocsize
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
macro_line|#endif
id|scb_data-&gt;init_level
op_increment
suffix:semicolon
multiline_comment|/* DMA tag for our sense buffers.  We allocate in page sized chunks */
r_if
c_cond
(paren
id|ahd_dma_tag_create
c_func
(paren
id|ahd
comma
id|ahd-&gt;parent_dmat
comma
multiline_comment|/*alignment*/
l_int|1
comma
multiline_comment|/*boundary*/
id|BUS_SPACE_MAXADDR_32BIT
op_plus
l_int|1
comma
multiline_comment|/*lowaddr*/
id|BUS_SPACE_MAXADDR_32BIT
comma
multiline_comment|/*highaddr*/
id|BUS_SPACE_MAXADDR
comma
multiline_comment|/*filter*/
l_int|NULL
comma
multiline_comment|/*filterarg*/
l_int|NULL
comma
id|PAGE_SIZE
comma
multiline_comment|/*nsegments*/
l_int|1
comma
multiline_comment|/*maxsegsz*/
id|BUS_SPACE_MAXSIZE_32BIT
comma
multiline_comment|/*flags*/
l_int|0
comma
op_amp
id|scb_data-&gt;sense_dmat
)paren
op_ne
l_int|0
)paren
(brace
r_goto
id|error_exit
suffix:semicolon
)brace
id|scb_data-&gt;init_level
op_increment
suffix:semicolon
multiline_comment|/* Perform initial CCB allocation */
id|ahd_alloc_scbs
c_func
(paren
id|ahd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb_data-&gt;numscbs
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: ahd_init_scbdata - &quot;
l_string|&quot;Unable to allocate initial scbs&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
r_goto
id|error_exit
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Note that we were successfull&n;&t; */
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|error_exit
suffix:colon
r_return
(paren
id|ENOMEM
)paren
suffix:semicolon
)brace
r_static
r_struct
id|scb
op_star
DECL|function|ahd_find_scb_by_tag
id|ahd_find_scb_by_tag
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
id|u_int
id|tag
)paren
(brace
r_struct
id|scb
op_star
id|scb
suffix:semicolon
multiline_comment|/*&n;&t; * Look on the pending list.&n;&t; */
id|LIST_FOREACH
c_func
(paren
id|scb
comma
op_amp
id|ahd-&gt;pending_scbs
comma
id|pending_links
)paren
(brace
r_if
c_cond
(paren
id|SCB_GET_TAG
c_func
(paren
id|scb
)paren
op_eq
id|tag
)paren
r_return
(paren
id|scb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Then on all of the collision free lists.&n;&t; */
id|TAILQ_FOREACH
c_func
(paren
id|scb
comma
op_amp
id|ahd-&gt;scb_data.free_scbs
comma
id|links.tqe
)paren
(brace
r_struct
id|scb
op_star
id|list_scb
suffix:semicolon
id|list_scb
op_assign
id|scb
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|SCB_GET_TAG
c_func
(paren
id|list_scb
)paren
op_eq
id|tag
)paren
r_return
(paren
id|list_scb
)paren
suffix:semicolon
id|list_scb
op_assign
id|LIST_NEXT
c_func
(paren
id|list_scb
comma
id|collision_links
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|list_scb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * And finally on the generic free list.&n;&t; */
id|LIST_FOREACH
c_func
(paren
id|scb
comma
op_amp
id|ahd-&gt;scb_data.any_dev_free_scb_list
comma
id|links.le
)paren
(brace
r_if
c_cond
(paren
id|SCB_GET_TAG
c_func
(paren
id|scb
)paren
op_eq
id|tag
)paren
r_return
(paren
id|scb
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahd_fini_scbdata
id|ahd_fini_scbdata
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
r_struct
id|scb_data
op_star
id|scb_data
suffix:semicolon
id|scb_data
op_assign
op_amp
id|ahd-&gt;scb_data
suffix:semicolon
r_if
c_cond
(paren
id|scb_data
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_switch
c_cond
(paren
id|scb_data-&gt;init_level
)paren
(brace
r_default
suffix:colon
(brace
)brace
r_case
l_int|7
suffix:colon
(brace
r_struct
id|map_node
op_star
id|sns_map
suffix:semicolon
r_while
c_loop
(paren
(paren
id|sns_map
op_assign
id|SLIST_FIRST
c_func
(paren
op_amp
id|scb_data-&gt;sense_maps
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|SLIST_REMOVE_HEAD
c_func
(paren
op_amp
id|scb_data-&gt;sense_maps
comma
id|links
)paren
suffix:semicolon
id|ahd_dmamap_unload
c_func
(paren
id|ahd
comma
id|scb_data-&gt;sense_dmat
comma
id|sns_map-&gt;dmamap
)paren
suffix:semicolon
id|ahd_dmamem_free
c_func
(paren
id|ahd
comma
id|scb_data-&gt;sense_dmat
comma
id|sns_map-&gt;vaddr
comma
id|sns_map-&gt;dmamap
)paren
suffix:semicolon
id|free
c_func
(paren
id|sns_map
comma
id|M_DEVBUF
)paren
suffix:semicolon
)brace
id|ahd_dma_tag_destroy
c_func
(paren
id|ahd
comma
id|scb_data-&gt;sense_dmat
)paren
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
)brace
r_case
l_int|6
suffix:colon
(brace
r_struct
id|map_node
op_star
id|sg_map
suffix:semicolon
r_while
c_loop
(paren
(paren
id|sg_map
op_assign
id|SLIST_FIRST
c_func
(paren
op_amp
id|scb_data-&gt;sg_maps
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|SLIST_REMOVE_HEAD
c_func
(paren
op_amp
id|scb_data-&gt;sg_maps
comma
id|links
)paren
suffix:semicolon
id|ahd_dmamap_unload
c_func
(paren
id|ahd
comma
id|scb_data-&gt;sg_dmat
comma
id|sg_map-&gt;dmamap
)paren
suffix:semicolon
id|ahd_dmamem_free
c_func
(paren
id|ahd
comma
id|scb_data-&gt;sg_dmat
comma
id|sg_map-&gt;vaddr
comma
id|sg_map-&gt;dmamap
)paren
suffix:semicolon
id|free
c_func
(paren
id|sg_map
comma
id|M_DEVBUF
)paren
suffix:semicolon
)brace
id|ahd_dma_tag_destroy
c_func
(paren
id|ahd
comma
id|scb_data-&gt;sg_dmat
)paren
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
)brace
r_case
l_int|5
suffix:colon
(brace
r_struct
id|map_node
op_star
id|hscb_map
suffix:semicolon
r_while
c_loop
(paren
(paren
id|hscb_map
op_assign
id|SLIST_FIRST
c_func
(paren
op_amp
id|scb_data-&gt;hscb_maps
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|SLIST_REMOVE_HEAD
c_func
(paren
op_amp
id|scb_data-&gt;hscb_maps
comma
id|links
)paren
suffix:semicolon
id|ahd_dmamap_unload
c_func
(paren
id|ahd
comma
id|scb_data-&gt;hscb_dmat
comma
id|hscb_map-&gt;dmamap
)paren
suffix:semicolon
id|ahd_dmamem_free
c_func
(paren
id|ahd
comma
id|scb_data-&gt;hscb_dmat
comma
id|hscb_map-&gt;vaddr
comma
id|hscb_map-&gt;dmamap
)paren
suffix:semicolon
id|free
c_func
(paren
id|hscb_map
comma
id|M_DEVBUF
)paren
suffix:semicolon
)brace
id|ahd_dma_tag_destroy
c_func
(paren
id|ahd
comma
id|scb_data-&gt;hscb_dmat
)paren
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
)brace
r_case
l_int|4
suffix:colon
r_case
l_int|3
suffix:colon
r_case
l_int|2
suffix:colon
r_case
l_int|1
suffix:colon
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * DSP filter Bypass must be enabled until the first selection&n; * after a change in bus mode (Razor #491 and #493).&n; */
r_static
r_void
DECL|function|ahd_setup_iocell_workaround
id|ahd_setup_iocell_workaround
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
id|ahd_mode_state
id|saved_modes
suffix:semicolon
id|saved_modes
op_assign
id|ahd_save_modes
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_CFG
comma
id|AHD_MODE_CFG
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|DSPDATACTL
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|DSPDATACTL
)paren
op_or
id|BYPASSENAB
op_or
id|RCVROFFSTDIS
op_or
id|XMITOFFSTDIS
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SIMODE0
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SIMODE0
)paren
op_or
(paren
id|ENSELDO
op_or
id|ENSELDI
)paren
)paren
suffix:semicolon
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_MISC
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;%s: Setting up iocell workaround&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
macro_line|#endif
id|ahd_restore_modes
c_func
(paren
id|ahd
comma
id|saved_modes
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahd_iocell_first_selection
id|ahd_iocell_first_selection
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
id|ahd_mode_state
id|saved_modes
suffix:semicolon
id|u_int
id|sblkctl
suffix:semicolon
id|saved_modes
op_assign
id|ahd_save_modes
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI
comma
id|AHD_MODE_SCSI
)paren
suffix:semicolon
id|sblkctl
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SBLKCTL
)paren
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_CFG
comma
id|AHD_MODE_CFG
)paren
suffix:semicolon
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_MISC
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;%s: iocell first selection&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|sblkctl
op_amp
id|ENAB40
)paren
op_ne
l_int|0
)paren
(brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|DSPDATACTL
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|DSPDATACTL
)paren
op_amp
op_complement
id|BYPASSENAB
)paren
suffix:semicolon
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_MISC
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;%s: BYPASS now disabled&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SIMODE0
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SIMODE0
)paren
op_amp
op_complement
(paren
id|ENSELDO
op_or
id|ENSELDI
)paren
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRINT
comma
id|CLRSCSIINT
)paren
suffix:semicolon
id|ahd_restore_modes
c_func
(paren
id|ahd
comma
id|saved_modes
)paren
suffix:semicolon
)brace
multiline_comment|/*************************** SCB Management ***********************************/
r_static
r_void
DECL|function|ahd_add_col_list
id|ahd_add_col_list
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|scb
op_star
id|scb
comma
id|u_int
id|col_idx
)paren
(brace
r_struct
id|scb_list
op_star
id|free_list
suffix:semicolon
r_struct
id|scb_tailq
op_star
id|free_tailq
suffix:semicolon
r_struct
id|scb
op_star
id|first_scb
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_ON_COL_LIST
suffix:semicolon
id|AHD_SET_SCB_COL_IDX
c_func
(paren
id|scb
comma
id|col_idx
)paren
suffix:semicolon
id|free_list
op_assign
op_amp
id|ahd-&gt;scb_data.free_scb_lists
(braket
id|col_idx
)braket
suffix:semicolon
id|free_tailq
op_assign
op_amp
id|ahd-&gt;scb_data.free_scbs
suffix:semicolon
id|first_scb
op_assign
id|LIST_FIRST
c_func
(paren
id|free_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|first_scb
op_ne
l_int|NULL
)paren
(brace
id|LIST_INSERT_AFTER
c_func
(paren
id|first_scb
comma
id|scb
comma
id|collision_links
)paren
suffix:semicolon
)brace
r_else
(brace
id|LIST_INSERT_HEAD
c_func
(paren
id|free_list
comma
id|scb
comma
id|collision_links
)paren
suffix:semicolon
id|TAILQ_INSERT_TAIL
c_func
(paren
id|free_tailq
comma
id|scb
comma
id|links.tqe
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|ahd_rem_col_list
id|ahd_rem_col_list
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|scb
op_star
id|scb
)paren
(brace
r_struct
id|scb_list
op_star
id|free_list
suffix:semicolon
r_struct
id|scb_tailq
op_star
id|free_tailq
suffix:semicolon
r_struct
id|scb
op_star
id|first_scb
suffix:semicolon
id|u_int
id|col_idx
suffix:semicolon
id|scb-&gt;flags
op_and_assign
op_complement
id|SCB_ON_COL_LIST
suffix:semicolon
id|col_idx
op_assign
id|AHD_GET_SCB_COL_IDX
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|free_list
op_assign
op_amp
id|ahd-&gt;scb_data.free_scb_lists
(braket
id|col_idx
)braket
suffix:semicolon
id|free_tailq
op_assign
op_amp
id|ahd-&gt;scb_data.free_scbs
suffix:semicolon
id|first_scb
op_assign
id|LIST_FIRST
c_func
(paren
id|free_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|first_scb
op_eq
id|scb
)paren
(brace
r_struct
id|scb
op_star
id|next_scb
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Maintain order in the collision free&n;&t;&t; * lists for fairness if this device has&n;&t;&t; * other colliding tags active.&n;&t;&t; */
id|next_scb
op_assign
id|LIST_NEXT
c_func
(paren
id|scb
comma
id|collision_links
)paren
suffix:semicolon
r_if
c_cond
(paren
id|next_scb
op_ne
l_int|NULL
)paren
(brace
id|TAILQ_INSERT_AFTER
c_func
(paren
id|free_tailq
comma
id|scb
comma
id|next_scb
comma
id|links.tqe
)paren
suffix:semicolon
)brace
id|TAILQ_REMOVE
c_func
(paren
id|free_tailq
comma
id|scb
comma
id|links.tqe
)paren
suffix:semicolon
)brace
id|LIST_REMOVE
c_func
(paren
id|scb
comma
id|collision_links
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Get a free scb. If there are none, see if we can allocate a new SCB.&n; */
r_struct
id|scb
op_star
DECL|function|ahd_get_scb
id|ahd_get_scb
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
id|u_int
id|col_idx
)paren
(brace
r_struct
id|scb
op_star
id|scb
suffix:semicolon
r_int
id|tries
suffix:semicolon
id|tries
op_assign
l_int|0
suffix:semicolon
id|look_again
suffix:colon
id|TAILQ_FOREACH
c_func
(paren
id|scb
comma
op_amp
id|ahd-&gt;scb_data.free_scbs
comma
id|links.tqe
)paren
(brace
r_if
c_cond
(paren
id|AHD_GET_SCB_COL_IDX
c_func
(paren
id|ahd
comma
id|scb
)paren
op_ne
id|col_idx
)paren
(brace
id|ahd_rem_col_list
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
r_goto
id|found
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|scb
op_assign
id|LIST_FIRST
c_func
(paren
op_amp
id|ahd-&gt;scb_data.any_dev_free_scb_list
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|tries
op_increment
op_ne
l_int|0
)paren
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
id|ahd_alloc_scbs
c_func
(paren
id|ahd
)paren
suffix:semicolon
r_goto
id|look_again
suffix:semicolon
)brace
id|LIST_REMOVE
c_func
(paren
id|scb
comma
id|links.le
)paren
suffix:semicolon
r_if
c_cond
(paren
id|col_idx
op_ne
id|AHD_NEVER_COL_IDX
op_logical_and
(paren
id|scb-&gt;col_scb
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|scb-&gt;col_scb-&gt;flags
op_amp
id|SCB_ACTIVE
)paren
op_eq
l_int|0
)paren
(brace
id|LIST_REMOVE
c_func
(paren
id|scb-&gt;col_scb
comma
id|links.le
)paren
suffix:semicolon
id|ahd_add_col_list
c_func
(paren
id|ahd
comma
id|scb-&gt;col_scb
comma
id|col_idx
)paren
suffix:semicolon
)brace
id|found
suffix:colon
id|scb-&gt;flags
op_or_assign
id|SCB_ACTIVE
suffix:semicolon
r_return
(paren
id|scb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Return an SCB resource to the free list.&n; */
r_void
DECL|function|ahd_free_scb
id|ahd_free_scb
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|scb
op_star
id|scb
)paren
(brace
multiline_comment|/* Clean up for the next user */
id|scb-&gt;flags
op_assign
id|SCB_FLAG_NONE
suffix:semicolon
id|scb-&gt;hscb-&gt;control
op_assign
l_int|0
suffix:semicolon
id|ahd-&gt;scb_data.scbindex
(braket
id|scb-&gt;hscb-&gt;tag
)braket
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|scb-&gt;col_scb
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * No collision possible.  Just free normally.&n;&t;&t; */
id|LIST_INSERT_HEAD
c_func
(paren
op_amp
id|ahd-&gt;scb_data.any_dev_free_scb_list
comma
id|scb
comma
id|links.le
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|scb-&gt;col_scb-&gt;flags
op_amp
id|SCB_ON_COL_LIST
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * The SCB we might have collided with is on&n;&t;&t; * a free collision list.  Put both SCBs on&n;&t;&t; * the generic list.&n;&t;&t; */
id|ahd_rem_col_list
c_func
(paren
id|ahd
comma
id|scb-&gt;col_scb
)paren
suffix:semicolon
id|LIST_INSERT_HEAD
c_func
(paren
op_amp
id|ahd-&gt;scb_data.any_dev_free_scb_list
comma
id|scb
comma
id|links.le
)paren
suffix:semicolon
id|LIST_INSERT_HEAD
c_func
(paren
op_amp
id|ahd-&gt;scb_data.any_dev_free_scb_list
comma
id|scb-&gt;col_scb
comma
id|links.le
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|scb-&gt;col_scb-&gt;flags
op_amp
(paren
id|SCB_PACKETIZED
op_or
id|SCB_ACTIVE
)paren
)paren
op_eq
id|SCB_ACTIVE
op_logical_and
(paren
id|scb-&gt;col_scb-&gt;hscb-&gt;control
op_amp
id|TAG_ENB
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * The SCB we might collide with on the next allocation&n;&t;&t; * is still active in a non-packetized, tagged, context.&n;&t;&t; * Put us on the SCB collision list.&n;&t;&t; */
id|ahd_add_col_list
c_func
(paren
id|ahd
comma
id|scb
comma
id|AHD_GET_SCB_COL_IDX
c_func
(paren
id|ahd
comma
id|scb-&gt;col_scb
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * The SCB we might collide with on the next allocation&n;&t;&t; * is either active in a packetized context, or free.&n;&t;&t; * Since we can&squot;t collide, put this SCB on the generic&n;&t;&t; * free list.&n;&t;&t; */
id|LIST_INSERT_HEAD
c_func
(paren
op_amp
id|ahd-&gt;scb_data.any_dev_free_scb_list
comma
id|scb
comma
id|links.le
)paren
suffix:semicolon
)brace
id|ahd_platform_scb_free
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahd_alloc_scbs
id|ahd_alloc_scbs
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
r_struct
id|scb_data
op_star
id|scb_data
suffix:semicolon
r_struct
id|scb
op_star
id|next_scb
suffix:semicolon
r_struct
id|hardware_scb
op_star
id|hscb
suffix:semicolon
r_struct
id|map_node
op_star
id|hscb_map
suffix:semicolon
r_struct
id|map_node
op_star
id|sg_map
suffix:semicolon
r_struct
id|map_node
op_star
id|sense_map
suffix:semicolon
r_uint8
op_star
id|segs
suffix:semicolon
r_uint8
op_star
id|sense_data
suffix:semicolon
id|bus_addr_t
id|hscb_busaddr
suffix:semicolon
id|bus_addr_t
id|sg_busaddr
suffix:semicolon
id|bus_addr_t
id|sense_busaddr
suffix:semicolon
r_int
id|newcount
suffix:semicolon
r_int
id|i
suffix:semicolon
id|scb_data
op_assign
op_amp
id|ahd-&gt;scb_data
suffix:semicolon
r_if
c_cond
(paren
id|scb_data-&gt;numscbs
op_ge
id|AHD_SCB_MAX_ALLOC
)paren
multiline_comment|/* Can&squot;t allocate any more */
r_return
suffix:semicolon
r_if
c_cond
(paren
id|scb_data-&gt;scbs_left
op_ne
l_int|0
)paren
(brace
r_int
id|offset
suffix:semicolon
id|offset
op_assign
(paren
id|PAGE_SIZE
op_div
r_sizeof
(paren
op_star
id|hscb
)paren
)paren
op_minus
id|scb_data-&gt;scbs_left
suffix:semicolon
id|hscb_map
op_assign
id|SLIST_FIRST
c_func
(paren
op_amp
id|scb_data-&gt;hscb_maps
)paren
suffix:semicolon
id|hscb
op_assign
op_amp
(paren
(paren
r_struct
id|hardware_scb
op_star
)paren
id|hscb_map-&gt;vaddr
)paren
(braket
id|offset
)braket
suffix:semicolon
id|hscb_busaddr
op_assign
id|hscb_map-&gt;physaddr
op_plus
(paren
id|offset
op_star
r_sizeof
(paren
op_star
id|hscb
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|hscb_map
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|hscb_map
)paren
comma
id|M_DEVBUF
comma
id|M_NOWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hscb_map
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
multiline_comment|/* Allocate the next batch of hardware SCBs */
r_if
c_cond
(paren
id|ahd_dmamem_alloc
c_func
(paren
id|ahd
comma
id|scb_data-&gt;hscb_dmat
comma
(paren
r_void
op_star
op_star
)paren
op_amp
id|hscb_map-&gt;vaddr
comma
id|BUS_DMA_NOWAIT
comma
op_amp
id|hscb_map-&gt;dmamap
)paren
op_ne
l_int|0
)paren
(brace
id|free
c_func
(paren
id|hscb_map
comma
id|M_DEVBUF
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|SLIST_INSERT_HEAD
c_func
(paren
op_amp
id|scb_data-&gt;hscb_maps
comma
id|hscb_map
comma
id|links
)paren
suffix:semicolon
id|ahd_dmamap_load
c_func
(paren
id|ahd
comma
id|scb_data-&gt;hscb_dmat
comma
id|hscb_map-&gt;dmamap
comma
id|hscb_map-&gt;vaddr
comma
id|PAGE_SIZE
comma
id|ahd_dmamap_cb
comma
op_amp
id|hscb_map-&gt;physaddr
comma
multiline_comment|/*flags*/
l_int|0
)paren
suffix:semicolon
id|hscb
op_assign
(paren
r_struct
id|hardware_scb
op_star
)paren
id|hscb_map-&gt;vaddr
suffix:semicolon
id|hscb_busaddr
op_assign
id|hscb_map-&gt;physaddr
suffix:semicolon
id|scb_data-&gt;scbs_left
op_assign
id|PAGE_SIZE
op_div
r_sizeof
(paren
op_star
id|hscb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scb_data-&gt;sgs_left
op_ne
l_int|0
)paren
(brace
r_int
id|offset
suffix:semicolon
id|offset
op_assign
id|ahd_sglist_allocsize
c_func
(paren
id|ahd
)paren
op_minus
(paren
id|scb_data-&gt;sgs_left
op_star
id|ahd_sglist_size
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
id|sg_map
op_assign
id|SLIST_FIRST
c_func
(paren
op_amp
id|scb_data-&gt;sg_maps
)paren
suffix:semicolon
id|segs
op_assign
id|sg_map-&gt;vaddr
op_plus
id|offset
suffix:semicolon
id|sg_busaddr
op_assign
id|sg_map-&gt;physaddr
op_plus
id|offset
suffix:semicolon
)brace
r_else
(brace
id|sg_map
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|sg_map
)paren
comma
id|M_DEVBUF
comma
id|M_NOWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sg_map
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
multiline_comment|/* Allocate the next batch of S/G lists */
r_if
c_cond
(paren
id|ahd_dmamem_alloc
c_func
(paren
id|ahd
comma
id|scb_data-&gt;sg_dmat
comma
(paren
r_void
op_star
op_star
)paren
op_amp
id|sg_map-&gt;vaddr
comma
id|BUS_DMA_NOWAIT
comma
op_amp
id|sg_map-&gt;dmamap
)paren
op_ne
l_int|0
)paren
(brace
id|free
c_func
(paren
id|sg_map
comma
id|M_DEVBUF
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|SLIST_INSERT_HEAD
c_func
(paren
op_amp
id|scb_data-&gt;sg_maps
comma
id|sg_map
comma
id|links
)paren
suffix:semicolon
id|ahd_dmamap_load
c_func
(paren
id|ahd
comma
id|scb_data-&gt;sg_dmat
comma
id|sg_map-&gt;dmamap
comma
id|sg_map-&gt;vaddr
comma
id|ahd_sglist_allocsize
c_func
(paren
id|ahd
)paren
comma
id|ahd_dmamap_cb
comma
op_amp
id|sg_map-&gt;physaddr
comma
multiline_comment|/*flags*/
l_int|0
)paren
suffix:semicolon
id|segs
op_assign
id|sg_map-&gt;vaddr
suffix:semicolon
id|sg_busaddr
op_assign
id|sg_map-&gt;physaddr
suffix:semicolon
id|scb_data-&gt;sgs_left
op_assign
id|ahd_sglist_allocsize
c_func
(paren
id|ahd
)paren
op_div
id|ahd_sglist_size
c_func
(paren
id|ahd
)paren
suffix:semicolon
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_MEMORY
)paren
id|printf
c_func
(paren
l_string|&quot;Mapped SG data&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|scb_data-&gt;sense_left
op_ne
l_int|0
)paren
(brace
r_int
id|offset
suffix:semicolon
id|offset
op_assign
id|PAGE_SIZE
op_minus
(paren
id|AHD_SENSE_BUFSIZE
op_star
id|scb_data-&gt;sense_left
)paren
suffix:semicolon
id|sense_map
op_assign
id|SLIST_FIRST
c_func
(paren
op_amp
id|scb_data-&gt;sense_maps
)paren
suffix:semicolon
id|sense_data
op_assign
id|sense_map-&gt;vaddr
op_plus
id|offset
suffix:semicolon
id|sense_busaddr
op_assign
id|sense_map-&gt;physaddr
op_plus
id|offset
suffix:semicolon
)brace
r_else
(brace
id|sense_map
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|sense_map
)paren
comma
id|M_DEVBUF
comma
id|M_NOWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sense_map
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
multiline_comment|/* Allocate the next batch of sense buffers */
r_if
c_cond
(paren
id|ahd_dmamem_alloc
c_func
(paren
id|ahd
comma
id|scb_data-&gt;sense_dmat
comma
(paren
r_void
op_star
op_star
)paren
op_amp
id|sense_map-&gt;vaddr
comma
id|BUS_DMA_NOWAIT
comma
op_amp
id|sense_map-&gt;dmamap
)paren
op_ne
l_int|0
)paren
(brace
id|free
c_func
(paren
id|sense_map
comma
id|M_DEVBUF
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|SLIST_INSERT_HEAD
c_func
(paren
op_amp
id|scb_data-&gt;sense_maps
comma
id|sense_map
comma
id|links
)paren
suffix:semicolon
id|ahd_dmamap_load
c_func
(paren
id|ahd
comma
id|scb_data-&gt;sense_dmat
comma
id|sense_map-&gt;dmamap
comma
id|sense_map-&gt;vaddr
comma
id|PAGE_SIZE
comma
id|ahd_dmamap_cb
comma
op_amp
id|sense_map-&gt;physaddr
comma
multiline_comment|/*flags*/
l_int|0
)paren
suffix:semicolon
id|sense_data
op_assign
id|sense_map-&gt;vaddr
suffix:semicolon
id|sense_busaddr
op_assign
id|sense_map-&gt;physaddr
suffix:semicolon
id|scb_data-&gt;sense_left
op_assign
id|PAGE_SIZE
op_div
id|AHD_SENSE_BUFSIZE
suffix:semicolon
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_MEMORY
)paren
id|printf
c_func
(paren
l_string|&quot;Mapped sense data&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
id|newcount
op_assign
id|MIN
c_func
(paren
id|scb_data-&gt;sense_left
comma
id|scb_data-&gt;scbs_left
)paren
suffix:semicolon
id|newcount
op_assign
id|MIN
c_func
(paren
id|newcount
comma
id|scb_data-&gt;sgs_left
)paren
suffix:semicolon
id|newcount
op_assign
id|MIN
c_func
(paren
id|newcount
comma
(paren
id|AHD_SCB_MAX_ALLOC
op_minus
id|scb_data-&gt;numscbs
)paren
)paren
suffix:semicolon
id|scb_data-&gt;sense_left
op_sub_assign
id|newcount
suffix:semicolon
id|scb_data-&gt;scbs_left
op_sub_assign
id|newcount
suffix:semicolon
id|scb_data-&gt;sgs_left
op_sub_assign
id|newcount
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|newcount
suffix:semicolon
id|i
op_increment
)paren
(brace
id|u_int
id|col_tag
suffix:semicolon
r_struct
id|scb_platform_data
op_star
id|pdata
suffix:semicolon
macro_line|#ifndef __linux__
r_int
id|error
suffix:semicolon
macro_line|#endif
id|next_scb
op_assign
(paren
r_struct
id|scb
op_star
)paren
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|next_scb
)paren
comma
id|M_DEVBUF
comma
id|M_NOWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|next_scb
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|pdata
op_assign
(paren
r_struct
id|scb_platform_data
op_star
)paren
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|pdata
)paren
comma
id|M_DEVBUF
comma
id|M_NOWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pdata
op_eq
l_int|NULL
)paren
(brace
id|free
c_func
(paren
id|next_scb
comma
id|M_DEVBUF
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|next_scb-&gt;platform_data
op_assign
id|pdata
suffix:semicolon
id|next_scb-&gt;hscb_map
op_assign
id|hscb_map
suffix:semicolon
id|next_scb-&gt;sg_map
op_assign
id|sg_map
suffix:semicolon
id|next_scb-&gt;sense_map
op_assign
id|sense_map
suffix:semicolon
id|next_scb-&gt;sg_list
op_assign
id|segs
suffix:semicolon
id|next_scb-&gt;sense_data
op_assign
id|sense_data
suffix:semicolon
id|next_scb-&gt;sense_busaddr
op_assign
id|sense_busaddr
suffix:semicolon
id|next_scb-&gt;hscb
op_assign
id|hscb
suffix:semicolon
id|hscb-&gt;hscb_busaddr
op_assign
id|ahd_htole32
c_func
(paren
id|hscb_busaddr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The sequencer always starts with the second entry.&n;&t;&t; * The first entry is embedded in the scb.&n;&t;&t; */
id|next_scb-&gt;sg_list_busaddr
op_assign
id|sg_busaddr
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;flags
op_amp
id|AHD_64BIT_ADDRESSING
)paren
op_ne
l_int|0
)paren
id|next_scb-&gt;sg_list_busaddr
op_add_assign
r_sizeof
(paren
r_struct
id|ahd_dma64_seg
)paren
suffix:semicolon
r_else
id|next_scb-&gt;sg_list_busaddr
op_add_assign
r_sizeof
(paren
r_struct
id|ahd_dma_seg
)paren
suffix:semicolon
id|next_scb-&gt;ahd_softc
op_assign
id|ahd
suffix:semicolon
id|next_scb-&gt;flags
op_assign
id|SCB_FLAG_NONE
suffix:semicolon
macro_line|#ifndef __linux__
id|error
op_assign
id|ahd_dmamap_create
c_func
(paren
id|ahd
comma
id|ahd-&gt;buffer_dmat
comma
multiline_comment|/*flags*/
l_int|0
comma
op_amp
id|next_scb-&gt;dmamap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
(brace
id|free
c_func
(paren
id|next_scb
comma
id|M_DEVBUF
)paren
suffix:semicolon
id|free
c_func
(paren
id|pdata
comma
id|M_DEVBUF
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif
id|next_scb-&gt;hscb-&gt;tag
op_assign
id|ahd_htole16
c_func
(paren
id|scb_data-&gt;numscbs
)paren
suffix:semicolon
id|col_tag
op_assign
id|scb_data-&gt;numscbs
op_xor
l_int|0x100
suffix:semicolon
id|next_scb-&gt;col_scb
op_assign
id|ahd_find_scb_by_tag
c_func
(paren
id|ahd
comma
id|col_tag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|next_scb-&gt;col_scb
op_ne
l_int|NULL
)paren
id|next_scb-&gt;col_scb-&gt;col_scb
op_assign
id|next_scb
suffix:semicolon
id|ahd_free_scb
c_func
(paren
id|ahd
comma
id|next_scb
)paren
suffix:semicolon
id|hscb
op_increment
suffix:semicolon
id|hscb_busaddr
op_add_assign
r_sizeof
(paren
op_star
id|hscb
)paren
suffix:semicolon
id|segs
op_add_assign
id|ahd_sglist_size
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|sg_busaddr
op_add_assign
id|ahd_sglist_size
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|sense_data
op_add_assign
id|AHD_SENSE_BUFSIZE
suffix:semicolon
id|sense_busaddr
op_add_assign
id|AHD_SENSE_BUFSIZE
suffix:semicolon
id|scb_data-&gt;numscbs
op_increment
suffix:semicolon
)brace
)brace
r_void
DECL|function|ahd_controller_info
id|ahd_controller_info
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_char
op_star
id|buf
)paren
(brace
r_const
r_char
op_star
id|speed
suffix:semicolon
r_const
r_char
op_star
id|type
suffix:semicolon
r_int
id|len
suffix:semicolon
id|len
op_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%s: &quot;
comma
id|ahd_chip_names
(braket
id|ahd-&gt;chip
op_amp
id|AHD_CHIPID_MASK
)braket
)paren
suffix:semicolon
id|buf
op_add_assign
id|len
suffix:semicolon
id|speed
op_assign
l_string|&quot;Ultra320 &quot;
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;features
op_amp
id|AHD_WIDE
)paren
op_ne
l_int|0
)paren
(brace
id|type
op_assign
l_string|&quot;Wide &quot;
suffix:semicolon
)brace
r_else
(brace
id|type
op_assign
l_string|&quot;Single &quot;
suffix:semicolon
)brace
id|len
op_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%s%sChannel %c, SCSI Id=%d, &quot;
comma
id|speed
comma
id|type
comma
id|ahd-&gt;channel
comma
id|ahd-&gt;our_id
)paren
suffix:semicolon
id|buf
op_add_assign
id|len
suffix:semicolon
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%s, %d SCBs&quot;
comma
id|ahd-&gt;bus_description
comma
id|ahd-&gt;scb_data.maxhscbs
)paren
suffix:semicolon
)brace
DECL|variable|channel_strings
r_static
r_const
r_char
op_star
id|channel_strings
(braket
)braket
op_assign
(brace
l_string|&quot;Primary Low&quot;
comma
l_string|&quot;Primary High&quot;
comma
l_string|&quot;Secondary Low&quot;
comma
l_string|&quot;Secondary High&quot;
)brace
suffix:semicolon
DECL|variable|termstat_strings
r_static
r_const
r_char
op_star
id|termstat_strings
(braket
)braket
op_assign
(brace
l_string|&quot;Terminated Correctly&quot;
comma
l_string|&quot;Over Terminated&quot;
comma
l_string|&quot;Under Terminated&quot;
comma
l_string|&quot;Not Configured&quot;
)brace
suffix:semicolon
multiline_comment|/*&n; * Start the board, ready for normal operation&n; */
r_int
DECL|function|ahd_init
id|ahd_init
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
r_uint8
op_star
id|base_vaddr
suffix:semicolon
r_uint8
op_star
id|next_vaddr
suffix:semicolon
id|bus_addr_t
id|next_baddr
suffix:semicolon
r_int
id|driver_data_size
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|error
suffix:semicolon
id|u_int
id|warn_user
suffix:semicolon
r_uint8
id|current_sensing
suffix:semicolon
r_uint8
id|fstat
suffix:semicolon
id|AHD_ASSERT_MODES
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI_MSK
comma
id|AHD_MODE_SCSI_MSK
)paren
suffix:semicolon
id|ahd-&gt;stack_size
op_assign
id|ahd_probe_stack_size
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd-&gt;saved_stack
op_assign
id|malloc
c_func
(paren
id|ahd-&gt;stack_size
op_star
r_sizeof
(paren
r_uint16
)paren
comma
id|M_DEVBUF
comma
id|M_NOWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahd-&gt;saved_stack
op_eq
l_int|NULL
)paren
r_return
(paren
id|ENOMEM
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Verify that the compiler hasn&squot;t over-agressively&n;&t; * padded important structures.&n;&t; */
r_if
c_cond
(paren
r_sizeof
(paren
r_struct
id|hardware_scb
)paren
op_ne
l_int|64
)paren
id|panic
c_func
(paren
l_string|&quot;Hardware SCB size is incorrect&quot;
)paren
suffix:semicolon
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_DEBUG_SEQUENCER
)paren
op_ne
l_int|0
)paren
id|ahd-&gt;flags
op_or_assign
id|AHD_SEQUENCER_DEBUG
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Default to allowing initiator operations.&n;&t; */
id|ahd-&gt;flags
op_or_assign
id|AHD_INITIATORROLE
suffix:semicolon
multiline_comment|/*&n;&t; * Only allow target mode features if this unit has them enabled.&n;&t; */
r_if
c_cond
(paren
(paren
id|AHD_TMODE_ENABLE
op_amp
(paren
l_int|0x1
op_lshift
id|ahd-&gt;unit
)paren
)paren
op_eq
l_int|0
)paren
id|ahd-&gt;features
op_and_assign
op_complement
id|AHD_TARGETMODE
suffix:semicolon
macro_line|#ifndef __linux__
multiline_comment|/* DMA tag for mapping buffers into device visible space. */
r_if
c_cond
(paren
id|ahd_dma_tag_create
c_func
(paren
id|ahd
comma
id|ahd-&gt;parent_dmat
comma
multiline_comment|/*alignment*/
l_int|1
comma
multiline_comment|/*boundary*/
id|BUS_SPACE_MAXADDR_32BIT
op_plus
l_int|1
comma
multiline_comment|/*lowaddr*/
id|BUS_SPACE_MAXADDR
comma
multiline_comment|/*highaddr*/
id|BUS_SPACE_MAXADDR
comma
multiline_comment|/*filter*/
l_int|NULL
comma
multiline_comment|/*filterarg*/
l_int|NULL
comma
multiline_comment|/*maxsize*/
(paren
id|AHD_NSEG
op_minus
l_int|1
)paren
op_star
id|PAGE_SIZE
comma
multiline_comment|/*nsegments*/
id|AHD_NSEG
comma
multiline_comment|/*maxsegsz*/
id|AHD_MAXTRANSFER_SIZE
comma
multiline_comment|/*flags*/
id|BUS_DMA_ALLOCNOW
comma
op_amp
id|ahd-&gt;buffer_dmat
)paren
op_ne
l_int|0
)paren
(brace
r_return
(paren
id|ENOMEM
)paren
suffix:semicolon
)brace
macro_line|#endif
id|ahd-&gt;init_level
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * DMA tag for our command fifos and other data in system memory&n;&t; * the card&squot;s sequencer must be able to access.  For initiator&n;&t; * roles, we need to allocate space for the qoutfifo.  When providing&n;&t; * for the target mode role, we must additionally provide space for&n;&t; * the incoming target command fifo.&n;&t; */
id|driver_data_size
op_assign
id|AHD_SCB_MAX
op_star
r_sizeof
(paren
r_uint16
)paren
op_plus
r_sizeof
(paren
r_struct
id|hardware_scb
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;features
op_amp
id|AHD_TARGETMODE
)paren
op_ne
l_int|0
)paren
id|driver_data_size
op_add_assign
id|AHD_TMODE_CMDS
op_star
r_sizeof
(paren
r_struct
id|target_cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;bugs
op_amp
id|AHD_PKT_BITBUCKET_BUG
)paren
op_ne
l_int|0
)paren
id|driver_data_size
op_add_assign
id|PKT_OVERRUN_BUFSIZE
suffix:semicolon
r_if
c_cond
(paren
id|ahd_dma_tag_create
c_func
(paren
id|ahd
comma
id|ahd-&gt;parent_dmat
comma
multiline_comment|/*alignment*/
l_int|1
comma
multiline_comment|/*boundary*/
id|BUS_SPACE_MAXADDR_32BIT
op_plus
l_int|1
comma
multiline_comment|/*lowaddr*/
id|BUS_SPACE_MAXADDR_32BIT
comma
multiline_comment|/*highaddr*/
id|BUS_SPACE_MAXADDR
comma
multiline_comment|/*filter*/
l_int|NULL
comma
multiline_comment|/*filterarg*/
l_int|NULL
comma
id|driver_data_size
comma
multiline_comment|/*nsegments*/
l_int|1
comma
multiline_comment|/*maxsegsz*/
id|BUS_SPACE_MAXSIZE_32BIT
comma
multiline_comment|/*flags*/
l_int|0
comma
op_amp
id|ahd-&gt;shared_data_dmat
)paren
op_ne
l_int|0
)paren
(brace
r_return
(paren
id|ENOMEM
)paren
suffix:semicolon
)brace
id|ahd-&gt;init_level
op_increment
suffix:semicolon
multiline_comment|/* Allocation of driver data */
r_if
c_cond
(paren
id|ahd_dmamem_alloc
c_func
(paren
id|ahd
comma
id|ahd-&gt;shared_data_dmat
comma
(paren
r_void
op_star
op_star
)paren
op_amp
id|base_vaddr
comma
id|BUS_DMA_NOWAIT
comma
op_amp
id|ahd-&gt;shared_data_dmamap
)paren
op_ne
l_int|0
)paren
(brace
r_return
(paren
id|ENOMEM
)paren
suffix:semicolon
)brace
id|ahd-&gt;init_level
op_increment
suffix:semicolon
multiline_comment|/* And permanently map it in */
id|ahd_dmamap_load
c_func
(paren
id|ahd
comma
id|ahd-&gt;shared_data_dmat
comma
id|ahd-&gt;shared_data_dmamap
comma
id|base_vaddr
comma
id|driver_data_size
comma
id|ahd_dmamap_cb
comma
op_amp
id|ahd-&gt;shared_data_busaddr
comma
multiline_comment|/*flags*/
l_int|0
)paren
suffix:semicolon
id|ahd-&gt;qoutfifo
op_assign
(paren
r_uint16
op_star
)paren
id|base_vaddr
suffix:semicolon
id|next_vaddr
op_assign
(paren
r_uint8
op_star
)paren
op_amp
id|ahd-&gt;qoutfifo
(braket
id|AHD_QOUT_SIZE
)braket
suffix:semicolon
id|next_baddr
op_assign
id|ahd-&gt;shared_data_busaddr
op_plus
id|AHD_QOUT_SIZE
op_star
r_sizeof
(paren
r_uint16
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;features
op_amp
id|AHD_TARGETMODE
)paren
op_ne
l_int|0
)paren
(brace
id|ahd-&gt;targetcmds
op_assign
(paren
r_struct
id|target_cmd
op_star
)paren
id|next_vaddr
suffix:semicolon
id|next_vaddr
op_add_assign
id|AHD_TMODE_CMDS
op_star
r_sizeof
(paren
r_struct
id|target_cmd
)paren
suffix:semicolon
id|next_baddr
op_add_assign
id|AHD_TMODE_CMDS
op_star
r_sizeof
(paren
r_struct
id|target_cmd
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ahd-&gt;bugs
op_amp
id|AHD_PKT_BITBUCKET_BUG
)paren
op_ne
l_int|0
)paren
(brace
id|ahd-&gt;overrun_buf
op_assign
id|next_vaddr
suffix:semicolon
id|next_vaddr
op_add_assign
id|PKT_OVERRUN_BUFSIZE
suffix:semicolon
id|next_baddr
op_add_assign
id|PKT_OVERRUN_BUFSIZE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We need one SCB to serve as the &quot;next SCB&quot;.  Since the&n;&t; * tag identifier in this SCB will never be used, there is&n;&t; * no point in using a valid HSCB tag from an SCB pulled from&n;&t; * the standard free pool.  So, we allocate this &quot;sentinel&quot;&n;&t; * specially from the DMA safe memory chunk used for the QOUTFIFO.&n;&t; */
id|ahd-&gt;next_queued_hscb
op_assign
(paren
r_struct
id|hardware_scb
op_star
)paren
id|next_vaddr
suffix:semicolon
id|ahd-&gt;next_queued_hscb-&gt;hscb_busaddr
op_assign
id|next_baddr
suffix:semicolon
id|ahd-&gt;init_level
op_increment
suffix:semicolon
multiline_comment|/* Allocate SCB data now that buffer_dmat is initialized */
r_if
c_cond
(paren
id|ahd_init_scbdata
c_func
(paren
id|ahd
)paren
op_ne
l_int|0
)paren
r_return
(paren
id|ENOMEM
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;flags
op_amp
id|AHD_INITIATORROLE
)paren
op_eq
l_int|0
)paren
id|ahd-&gt;flags
op_and_assign
op_complement
id|AHD_RESET_BUS_A
suffix:semicolon
multiline_comment|/*&n;&t; * Before committing these settings to the chip, give&n;&t; * the OSM one last chance to modify our configuration.&n;&t; */
id|ahd_platform_init
c_func
(paren
id|ahd
)paren
suffix:semicolon
multiline_comment|/* Bring up the chip. */
id|ahd_chip_init
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|AHD_ASSERT_MODES
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI_MSK
comma
id|AHD_MODE_SCSI_MSK
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;flags
op_amp
id|AHD_CURRENT_SENSING
)paren
op_eq
l_int|0
)paren
r_goto
id|init_done
suffix:semicolon
multiline_comment|/*&n;&t; * Verify termination based on current draw and&n;&t; * warn user if the bus is over/under terminated.&n;&t; */
id|error
op_assign
id|ahd_write_flexport
c_func
(paren
id|ahd
comma
id|FLXADDR_ROMSTAT_CURSENSECTL
comma
id|CURSENSE_ENB
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: current sensing timeout 1&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
r_goto
id|init_done
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|20
comma
id|fstat
op_assign
id|FLX_FSTAT_BUSY
suffix:semicolon
(paren
id|fstat
op_amp
id|FLX_FSTAT_BUSY
)paren
op_ne
l_int|0
op_logical_and
id|i
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|error
op_assign
id|ahd_read_flexport
c_func
(paren
id|ahd
comma
id|FLXADDR_FLEXSTAT
comma
op_amp
id|fstat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: current sensing timeout 2&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
r_goto
id|init_done
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: Timedout during current-sensing test&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
r_goto
id|init_done
suffix:semicolon
)brace
multiline_comment|/* Latch Current Sensing status. */
id|error
op_assign
id|ahd_read_flexport
c_func
(paren
id|ahd
comma
id|FLXADDR_CURRENT_STAT
comma
op_amp
id|current_sensing
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: current sensing timeout 3&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
r_goto
id|init_done
suffix:semicolon
)brace
multiline_comment|/* Diable current sensing. */
id|ahd_write_flexport
c_func
(paren
id|ahd
comma
id|FLXADDR_ROMSTAT_CURSENSECTL
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_TERMCTL
)paren
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: current_sensing == 0x%x&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|current_sensing
)paren
suffix:semicolon
)brace
macro_line|#endif
id|warn_user
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
comma
id|current_sensing
op_rshift_assign
id|FLX_CSTAT_SHIFT
)paren
(brace
id|u_int
id|term_stat
suffix:semicolon
id|term_stat
op_assign
(paren
id|current_sensing
op_amp
id|FLX_CSTAT_MASK
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|term_stat
)paren
(brace
r_case
id|FLX_CSTAT_OVER
suffix:colon
r_case
id|FLX_CSTAT_UNDER
suffix:colon
id|warn_user
op_increment
suffix:semicolon
r_case
id|FLX_CSTAT_INVALID
suffix:colon
r_case
id|FLX_CSTAT_OKAY
suffix:colon
r_if
c_cond
(paren
id|warn_user
op_eq
l_int|0
op_logical_and
id|bootverbose
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s: %s Channel %s&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|channel_strings
(braket
id|i
)braket
comma
id|termstat_strings
(braket
id|term_stat
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|warn_user
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: WARNING. Termination is not configured correctly.&bslash;n&quot;
l_string|&quot;%s: WARNING. SCSI bus operations may FAIL.&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
)brace
id|init_done
suffix:colon
id|ahd_restart
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_timer_reset
c_func
(paren
op_amp
id|ahd-&gt;stat_timer
comma
id|AHD_STAT_UPDATE_US
comma
id|ahd_stat_timer
comma
id|ahd
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * (Re)initialize chip state after a chip reset.&n; */
r_static
r_void
DECL|function|ahd_chip_init
id|ahd_chip_init
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
r_uint32
id|busaddr
suffix:semicolon
id|u_int
id|sxfrctl1
suffix:semicolon
id|u_int
id|scsiseq_template
suffix:semicolon
id|u_int
id|wait
suffix:semicolon
id|u_int
id|i
suffix:semicolon
id|u_int
id|target
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI
comma
id|AHD_MODE_SCSI
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Take the LED out of diagnostic mode&n;&t; */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SBLKCTL
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SBLKCTL
)paren
op_amp
op_complement
(paren
id|DIAGLEDEN
op_or
id|DIAGLEDON
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Return HS_MAILBOX to its default value.&n;&t; */
id|ahd-&gt;hs_mailbox
op_assign
l_int|0
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|HS_MAILBOX
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Set the SCSI Id, SXFRCTL0, SXFRCTL1, and SIMODE1. */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|IOWNID
comma
id|ahd-&gt;our_id
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|TOWNID
comma
id|ahd-&gt;our_id
)paren
suffix:semicolon
id|sxfrctl1
op_assign
(paren
id|ahd-&gt;flags
op_amp
id|AHD_TERM_ENB_A
)paren
op_ne
l_int|0
ques
c_cond
id|STPWEN
suffix:colon
l_int|0
suffix:semicolon
id|sxfrctl1
op_or_assign
(paren
id|ahd-&gt;flags
op_amp
id|AHD_SPCHK_ENB_A
)paren
op_ne
l_int|0
ques
c_cond
id|ENSPCHK
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;bugs
op_amp
id|AHD_LONG_SETIMO_BUG
)paren
op_logical_and
(paren
id|ahd-&gt;seltime
op_ne
id|STIMESEL_MIN
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * The selection timer duration is twice as long&n;&t;&t; * as it should be.  Halve it by adding &quot;1&quot; to&n;&t;&t; * the user specified setting.&n;&t;&t; */
id|sxfrctl1
op_or_assign
id|ahd-&gt;seltime
op_plus
id|STIMESEL_BUG_ADJ
suffix:semicolon
)brace
r_else
(brace
id|sxfrctl1
op_or_assign
id|ahd-&gt;seltime
suffix:semicolon
)brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SXFRCTL0
comma
id|DFON
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SXFRCTL1
comma
id|sxfrctl1
op_or
id|ahd-&gt;seltime
op_or
id|ENSTIMER
op_or
id|ACTNEGEN
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SIMODE1
comma
id|ENSELTIMO
op_or
id|ENSCSIRST
op_or
id|ENSCSIPERR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now that termination is set, wait for up&n;&t; * to 500ms for our transceivers to settle.  If&n;&t; * the adapter does not have a cable attached,&n;&t; * the tranceivers may never settle, so don&squot;t&n;&t; * complain if we fail here.&n;&t; */
r_for
c_loop
(paren
id|wait
op_assign
l_int|10000
suffix:semicolon
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SBLKCTL
)paren
op_amp
(paren
id|ENAB40
op_or
id|ENAB20
)paren
)paren
op_eq
l_int|0
op_logical_and
id|wait
suffix:semicolon
id|wait
op_decrement
)paren
id|ahd_delay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* Clear any false bus resets due to the transceivers settling */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRSINT1
comma
id|CLRSCSIRSTI
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRINT
comma
id|CLRSCSIINT
)paren
suffix:semicolon
multiline_comment|/* Initialize mode specific S/G state. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_DFF0
op_plus
id|i
comma
id|AHD_MODE_DFF0
op_plus
id|i
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|LONGJMP_ADDR
op_plus
l_int|1
comma
id|INVALID_ADDR
)paren
suffix:semicolon
id|ahd_outw
c_func
(paren
id|ahd
comma
id|LONGJMP_SCB
comma
id|SCB_LIST_NULL
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SG_STATE
comma
l_int|0
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRSEQINTSRC
comma
l_int|0xFF
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SEQIMODE
comma
id|ENSAVEPTRS
op_or
id|ENCFG4DATA
op_or
id|ENCFG4ISTAT
op_or
id|ENCFG4TSTAT
op_or
id|ENCFG4ICMD
op_or
id|ENCFG4TCMD
)paren
suffix:semicolon
)brace
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_CFG
comma
id|AHD_MODE_CFG
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|DSCOMMAND0
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|DSCOMMAND0
)paren
op_or
id|MPARCKEN
op_or
id|CACHETHEN
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|DFF_THRSH
comma
id|RD_DFTHRSH_75
op_or
id|WR_DFTHRSH_75
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SIMODE0
comma
id|ENIOERR
op_or
id|ENOVERRUN
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SIMODE3
comma
id|ENNTRAMPERR
op_or
id|ENOSRAMPERR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;bugs
op_amp
id|AHD_BUSFREEREV_BUG
)paren
op_ne
l_int|0
)paren
(brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|OPTIONMODE
comma
id|AUTOACKEN
op_or
id|AUTO_MSGOUT_DE
)paren
suffix:semicolon
)brace
r_else
(brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|OPTIONMODE
comma
id|AUTOACKEN
op_or
id|BUSFREEREV
op_or
id|AUTO_MSGOUT_DE
)paren
suffix:semicolon
)brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCSCHKN
comma
id|CURRFIFODEF
op_or
id|WIDERESEN
op_or
id|SHVALIDSTDIS
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;chip
op_amp
id|AHD_BUS_MASK
)paren
op_eq
id|AHD_PCIX
)paren
multiline_comment|/*&n;&t;&t; * Do not issue a target abort when a split completion&n;&t;&t; * error occurs.  Let our PCIX interrupt handler deal&n;&t;&t; * with it instead. H2A4 Razor #625&n;&t;&t; */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|PCIXCTL
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|PCIXCTL
)paren
op_or
id|SPLTSTADIS
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;bugs
op_amp
id|AHD_LQOOVERRUN_BUG
)paren
op_ne
l_int|0
)paren
id|ahd_outb
c_func
(paren
id|ahd
comma
id|LQOSCSCTL
comma
id|LQONOCHKOVER
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Tweak IOCELL settings.&n;&t; */
r_if
c_cond
(paren
(paren
id|ahd-&gt;flags
op_amp
id|AHD_HP_BOARD
)paren
op_ne
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUMDSPS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|DSPSELECT
comma
id|i
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|WRTBIASCTL
comma
id|WRTBIASCTL_HP_DEFAULT
)paren
suffix:semicolon
)brace
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_MISC
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;%s: WRTBIASCTL now 0x%x&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|WRTBIASCTL_HP_DEFAULT
)paren
suffix:semicolon
macro_line|#endif
)brace
id|ahd_setup_iocell_workaround
c_func
(paren
id|ahd
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Enable LQI Manager interrupts.&n;&t; */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|LQIMODE1
comma
id|ENLQIPHASE_LQ
op_or
id|ENLQIPHASE_NLQ
op_or
id|ENLIQABORT
op_or
id|ENLQICRCI_LQ
op_or
id|ENLQICRCI_NLQ
op_or
id|ENLQIBADLQI
op_or
id|ENLQIOVERI_LQ
op_or
id|ENLQIOVERI_NLQ
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|LQOMODE0
comma
id|ENLQOATNLQ
op_or
id|ENLQOATNPKT
op_or
id|ENLQOTCRC
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * An interrupt from LQOBUSFREE is made redundant by the&n;&t; * BUSFREE interrupt.  We choose to have the sequencer catch&n;&t; * LQOPHCHGINPKT errors manually for the command phase at the&n;&t; * start of a packetized selection case.&n;&t;ahd_outb(ahd, LQOMODE1, ENLQOBUSFREE|ENLQOPHACHGINPKT);&n;&t; */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|LQOMODE1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Setup sequencer interrupt handlers.&n;&t; */
id|ahd_outw
c_func
(paren
id|ahd
comma
id|INTVEC1_ADDR
comma
id|ahd_resolve_seqaddr
c_func
(paren
id|ahd
comma
id|LABEL_seq_isr
)paren
)paren
suffix:semicolon
id|ahd_outw
c_func
(paren
id|ahd
comma
id|INTVEC2_ADDR
comma
id|ahd_resolve_seqaddr
c_func
(paren
id|ahd
comma
id|LABEL_timer_isr
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Setup SCB Offset registers.&n;&t; */
r_if
c_cond
(paren
(paren
id|ahd-&gt;bugs
op_amp
id|AHD_PKT_LUN_BUG
)paren
op_ne
l_int|0
)paren
(brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|LUNPTR
comma
m_offsetof
(paren
r_struct
id|hardware_scb
comma
id|pkt_long_lun
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|LUNPTR
comma
m_offsetof
(paren
r_struct
id|hardware_scb
comma
id|lun
)paren
)paren
suffix:semicolon
)brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CMDLENPTR
comma
m_offsetof
(paren
r_struct
id|hardware_scb
comma
id|cdb_len
)paren
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|ATTRPTR
comma
m_offsetof
(paren
r_struct
id|hardware_scb
comma
id|task_attribute
)paren
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|FLAGPTR
comma
m_offsetof
(paren
r_struct
id|hardware_scb
comma
id|task_management
)paren
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CMDPTR
comma
m_offsetof
(paren
r_struct
id|hardware_scb
comma
id|shared_data.idata.cdb
)paren
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|QNEXTPTR
comma
m_offsetof
(paren
r_struct
id|hardware_scb
comma
id|next_hscb_busaddr
)paren
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|ABRTBITPTR
comma
id|MK_MESSAGE_BIT_OFFSET
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|ABRTBYTEPTR
comma
m_offsetof
(paren
r_struct
id|hardware_scb
comma
id|control
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;bugs
op_amp
id|AHD_PKT_LUN_BUG
)paren
op_ne
l_int|0
)paren
(brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|LUNLEN
comma
r_sizeof
(paren
id|ahd-&gt;next_queued_hscb-&gt;pkt_long_lun
)paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|LUNLEN
comma
r_sizeof
(paren
id|ahd-&gt;next_queued_hscb-&gt;lun
)paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CDBLIMIT
comma
id|SCB_CDB_LEN_PTR
op_minus
l_int|1
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|MAXCMD
comma
l_int|0xFF
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCBAUTOPTR
comma
id|AUSCBPTR_EN
op_or
m_offsetof
(paren
r_struct
id|hardware_scb
comma
id|tag
)paren
)paren
suffix:semicolon
multiline_comment|/* We haven&squot;t been enabled for target mode yet. */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|MULTARGID
comma
l_int|0
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|MULTARGID
op_plus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI
comma
id|AHD_MODE_SCSI
)paren
suffix:semicolon
multiline_comment|/* Initialize the negotiation table. */
r_if
c_cond
(paren
(paren
id|ahd-&gt;features
op_amp
id|AHD_NEW_IOCELL_OPTS
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Clear the spare bytes in the neg table to avoid&n;&t;&t; * spurious parity errors.&n;&t;&t; */
r_for
c_loop
(paren
id|target
op_assign
l_int|0
suffix:semicolon
id|target
OL
id|AHD_NUM_TARGETS
suffix:semicolon
id|target
op_increment
)paren
(brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|NEGOADDR
comma
id|target
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|ANNEXCOL
comma
id|AHD_ANNEXCOL_PER_DEV0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AHD_NUM_PER_DEV_ANNEXCOLS
suffix:semicolon
id|i
op_increment
)paren
id|ahd_outb
c_func
(paren
id|ahd
comma
id|ANNEXDAT
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|target
op_assign
l_int|0
suffix:semicolon
id|target
OL
id|AHD_NUM_TARGETS
suffix:semicolon
id|target
op_increment
)paren
(brace
r_struct
id|ahd_devinfo
id|devinfo
suffix:semicolon
r_struct
id|ahd_initiator_tinfo
op_star
id|tinfo
suffix:semicolon
r_struct
id|ahd_tmode_tstate
op_star
id|tstate
suffix:semicolon
id|tinfo
op_assign
id|ahd_fetch_transinfo
c_func
(paren
id|ahd
comma
l_char|&squot;A&squot;
comma
id|ahd-&gt;our_id
comma
id|target
comma
op_amp
id|tstate
)paren
suffix:semicolon
id|ahd_compile_devinfo
c_func
(paren
op_amp
id|devinfo
comma
id|ahd-&gt;our_id
comma
id|target
comma
id|CAM_LUN_WILDCARD
comma
l_char|&squot;A&squot;
comma
id|ROLE_INITIATOR
)paren
suffix:semicolon
id|ahd_update_neg_table
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
comma
op_amp
id|tinfo-&gt;curr
)paren
suffix:semicolon
)brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRSINT3
comma
id|NTRAMPERR
op_or
id|OSRAMPERR
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRINT
comma
id|CLRSCSIINT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Always enable abort on incoming L_Qs if this feature is&n;&t; * supported.  We use this to catch invalid SCB references.&n;&t; */
r_if
c_cond
(paren
(paren
id|ahd-&gt;bugs
op_amp
id|AHD_ABORT_LQI_BUG
)paren
op_eq
l_int|0
)paren
id|ahd_outb
c_func
(paren
id|ahd
comma
id|LQCTL1
comma
id|ABORTPENDING
)paren
suffix:semicolon
r_else
id|ahd_outb
c_func
(paren
id|ahd
comma
id|LQCTL1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* All of our queues are empty */
id|ahd-&gt;qoutfifonext
op_assign
l_int|0
suffix:semicolon
id|ahd-&gt;qoutfifonext_valid_tag
op_assign
id|QOUTFIFO_ENTRY_VALID_LE
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|QOUTFIFO_ENTRY_VALID_TAG
comma
id|QOUTFIFO_ENTRY_VALID
op_rshift
l_int|8
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AHD_QOUT_SIZE
suffix:semicolon
id|i
op_increment
)paren
id|ahd-&gt;qoutfifo
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|ahd_sync_qoutfifo
c_func
(paren
id|ahd
comma
id|BUS_DMASYNC_PREREAD
)paren
suffix:semicolon
id|ahd-&gt;qinfifonext
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AHD_QIN_SIZE
suffix:semicolon
id|i
op_increment
)paren
id|ahd-&gt;qinfifo
(braket
id|i
)braket
op_assign
id|SCB_LIST_NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;features
op_amp
id|AHD_TARGETMODE
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* All target command blocks start out invalid. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AHD_TMODE_CMDS
suffix:semicolon
id|i
op_increment
)paren
id|ahd-&gt;targetcmds
(braket
id|i
)braket
dot
id|cmd_valid
op_assign
l_int|0
suffix:semicolon
id|ahd_sync_tqinfifo
c_func
(paren
id|ahd
comma
id|BUS_DMASYNC_PREREAD
)paren
suffix:semicolon
id|ahd-&gt;tqinfifonext
op_assign
l_int|1
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|KERNEL_TQINPOS
comma
id|ahd-&gt;tqinfifonext
op_minus
l_int|1
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|TQINPOS
comma
id|ahd-&gt;tqinfifonext
)paren
suffix:semicolon
)brace
multiline_comment|/* Initialize Scratch Ram. */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SEQ_FLAGS
comma
l_int|0
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SEQ_FLAGS2
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* We don&squot;t have any waiting selections */
id|ahd_outw
c_func
(paren
id|ahd
comma
id|WAITING_TID_HEAD
comma
id|SCB_LIST_NULL
)paren
suffix:semicolon
id|ahd_outw
c_func
(paren
id|ahd
comma
id|WAITING_TID_TAIL
comma
id|SCB_LIST_NULL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AHD_NUM_TARGETS
suffix:semicolon
id|i
op_increment
)paren
id|ahd_outw
c_func
(paren
id|ahd
comma
id|WAITING_SCB_TAILS
op_plus
(paren
l_int|2
op_star
id|i
)paren
comma
id|SCB_LIST_NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Nobody is waiting to be DMAed into the QOUTFIFO.&n;&t; */
id|ahd_outw
c_func
(paren
id|ahd
comma
id|COMPLETE_SCB_HEAD
comma
id|SCB_LIST_NULL
)paren
suffix:semicolon
id|ahd_outw
c_func
(paren
id|ahd
comma
id|COMPLETE_SCB_DMAINPROG_HEAD
comma
id|SCB_LIST_NULL
)paren
suffix:semicolon
id|ahd_outw
c_func
(paren
id|ahd
comma
id|COMPLETE_DMA_SCB_HEAD
comma
id|SCB_LIST_NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The Freeze Count is 0.&n;&t; */
id|ahd_outw
c_func
(paren
id|ahd
comma
id|QFREEZE_COUNT
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Tell the sequencer where it can find our arrays in memory.&n;&t; */
id|busaddr
op_assign
id|ahd-&gt;shared_data_busaddr
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SHARED_DATA_ADDR
comma
id|busaddr
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SHARED_DATA_ADDR
op_plus
l_int|1
comma
(paren
id|busaddr
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SHARED_DATA_ADDR
op_plus
l_int|2
comma
(paren
id|busaddr
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SHARED_DATA_ADDR
op_plus
l_int|3
comma
(paren
id|busaddr
op_rshift
l_int|24
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|QOUTFIFO_NEXT_ADDR
comma
id|busaddr
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|QOUTFIFO_NEXT_ADDR
op_plus
l_int|1
comma
(paren
id|busaddr
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|QOUTFIFO_NEXT_ADDR
op_plus
l_int|2
comma
(paren
id|busaddr
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|QOUTFIFO_NEXT_ADDR
op_plus
l_int|3
comma
(paren
id|busaddr
op_rshift
l_int|24
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Setup the allowed SCSI Sequences based on operational mode.&n;&t; * If we are a target, we&squot;ll enable select in operations once&n;&t; * we&squot;ve had a lun enabled.&n;&t; */
id|scsiseq_template
op_assign
id|ENAUTOATNP
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;flags
op_amp
id|AHD_INITIATORROLE
)paren
op_ne
l_int|0
)paren
id|scsiseq_template
op_or_assign
id|ENRSELI
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCSISEQ_TEMPLATE
comma
id|scsiseq_template
)paren
suffix:semicolon
multiline_comment|/* There are no busy SCBs yet. */
r_for
c_loop
(paren
id|target
op_assign
l_int|0
suffix:semicolon
id|target
OL
id|AHD_NUM_TARGETS
suffix:semicolon
id|target
op_increment
)paren
(brace
r_int
id|lun
suffix:semicolon
r_for
c_loop
(paren
id|lun
op_assign
l_int|0
suffix:semicolon
id|lun
OL
id|AHD_NUM_LUNS_NONPKT
suffix:semicolon
id|lun
op_increment
)paren
id|ahd_unbusy_tcl
c_func
(paren
id|ahd
comma
id|BUILD_TCL_RAW
c_func
(paren
id|target
comma
l_char|&squot;A&squot;
comma
id|lun
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Initialize the group code to command length table.&n;&t; * Vendor Unique codes are set to 0 so we only capture&n;&t; * the first byte of the cdb.  These can be overridden&n;&t; * when target mode is enabled.&n;&t; */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CMDSIZE_TABLE
comma
l_int|5
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CMDSIZE_TABLE
op_plus
l_int|1
comma
l_int|9
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CMDSIZE_TABLE
op_plus
l_int|2
comma
l_int|9
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CMDSIZE_TABLE
op_plus
l_int|3
comma
l_int|0
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CMDSIZE_TABLE
op_plus
l_int|4
comma
l_int|15
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CMDSIZE_TABLE
op_plus
l_int|5
comma
l_int|11
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CMDSIZE_TABLE
op_plus
l_int|6
comma
l_int|0
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CMDSIZE_TABLE
op_plus
l_int|7
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Tell the sequencer of our initial queue positions */
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_CCHAN
comma
id|AHD_MODE_CCHAN
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|QOFF_CTLSTA
comma
id|SCB_QSIZE_512
)paren
suffix:semicolon
id|ahd-&gt;qinfifonext
op_assign
l_int|0
suffix:semicolon
id|ahd_set_hnscb_qoff
c_func
(paren
id|ahd
comma
id|ahd-&gt;qinfifonext
)paren
suffix:semicolon
id|ahd_set_hescb_qoff
c_func
(paren
id|ahd
comma
l_int|0
)paren
suffix:semicolon
id|ahd_set_snscb_qoff
c_func
(paren
id|ahd
comma
l_int|0
)paren
suffix:semicolon
id|ahd_set_sescb_qoff
c_func
(paren
id|ahd
comma
l_int|0
)paren
suffix:semicolon
id|ahd_set_sdscb_qoff
c_func
(paren
id|ahd
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Tell the sequencer which SCB will be the next one it receives.&n;&t; */
id|busaddr
op_assign
id|ahd_le32toh
c_func
(paren
id|ahd-&gt;next_queued_hscb-&gt;hscb_busaddr
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|NEXT_QUEUED_SCB_ADDR
op_plus
l_int|0
comma
id|busaddr
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|NEXT_QUEUED_SCB_ADDR
op_plus
l_int|1
comma
(paren
id|busaddr
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|NEXT_QUEUED_SCB_ADDR
op_plus
l_int|2
comma
(paren
id|busaddr
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|NEXT_QUEUED_SCB_ADDR
op_plus
l_int|3
comma
(paren
id|busaddr
op_rshift
l_int|24
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Default to coalessing disabled.&n;&t; */
id|ahd_outw
c_func
(paren
id|ahd
comma
id|INT_COALESSING_CMDCOUNT
comma
l_int|0
)paren
suffix:semicolon
id|ahd_outw
c_func
(paren
id|ahd
comma
id|CMDS_PENDING
comma
l_int|0
)paren
suffix:semicolon
id|ahd_update_coalessing_values
c_func
(paren
id|ahd
comma
id|ahd-&gt;int_coalessing_timer
comma
id|ahd-&gt;int_coalessing_maxcmds
comma
id|ahd-&gt;int_coalessing_mincmds
)paren
suffix:semicolon
id|ahd_enable_coalessing
c_func
(paren
id|ahd
comma
id|FALSE
)paren
suffix:semicolon
id|ahd_loadseq
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI
comma
id|AHD_MODE_SCSI
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Setup default device and controller settings.&n; * This should only be called if our probe has&n; * determined that no configuration data is available.&n; */
r_int
DECL|function|ahd_default_config
id|ahd_default_config
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
r_int
id|targ
suffix:semicolon
id|ahd-&gt;our_id
op_assign
l_int|7
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate a tstate to house information for our&n;&t; * initiator presence on the bus as well as the user&n;&t; * data for any target mode initiator.&n;&t; */
r_if
c_cond
(paren
id|ahd_alloc_tstate
c_func
(paren
id|ahd
comma
id|ahd-&gt;our_id
comma
l_char|&squot;A&squot;
)paren
op_eq
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: unable to allocate ahd_tmode_tstate.  &quot;
l_string|&quot;Failing attach&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
r_return
(paren
id|ENOMEM
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|targ
op_assign
l_int|0
suffix:semicolon
id|targ
OL
id|AHD_NUM_TARGETS
suffix:semicolon
id|targ
op_increment
)paren
(brace
r_struct
id|ahd_devinfo
id|devinfo
suffix:semicolon
r_struct
id|ahd_initiator_tinfo
op_star
id|tinfo
suffix:semicolon
r_struct
id|ahd_tmode_tstate
op_star
id|tstate
suffix:semicolon
r_uint16
id|target_mask
suffix:semicolon
id|tinfo
op_assign
id|ahd_fetch_transinfo
c_func
(paren
id|ahd
comma
l_char|&squot;A&squot;
comma
id|ahd-&gt;our_id
comma
id|targ
comma
op_amp
id|tstate
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We support SPC2 and SPI4.&n;&t;&t; */
id|tinfo-&gt;user.protocol_version
op_assign
l_int|4
suffix:semicolon
id|tinfo-&gt;user.transport_version
op_assign
l_int|4
suffix:semicolon
id|target_mask
op_assign
l_int|0x01
op_lshift
id|targ
suffix:semicolon
id|ahd-&gt;user_discenable
op_or_assign
id|target_mask
suffix:semicolon
id|tstate-&gt;discenable
op_or_assign
id|target_mask
suffix:semicolon
id|ahd-&gt;user_tagenable
op_or_assign
id|target_mask
suffix:semicolon
macro_line|#ifdef AHD_FORCE_160
id|tinfo-&gt;user.period
op_assign
id|AHD_SYNCRATE_DT
suffix:semicolon
macro_line|#else
id|tinfo-&gt;user.period
op_assign
id|AHD_SYNCRATE_160
suffix:semicolon
macro_line|#endif
id|tinfo-&gt;user.offset
op_assign
op_complement
l_int|0
suffix:semicolon
id|tinfo-&gt;user.ppr_options
op_assign
id|MSG_EXT_PPR_RD_STRM
op_or
id|MSG_EXT_PPR_WR_FLOW
op_or
id|MSG_EXT_PPR_HOLD_MCS
op_or
id|MSG_EXT_PPR_IU_REQ
op_or
id|MSG_EXT_PPR_QAS_REQ
op_or
id|MSG_EXT_PPR_DT_REQ
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;features
op_amp
id|AHD_RTI
)paren
op_ne
l_int|0
)paren
id|tinfo-&gt;user.ppr_options
op_or_assign
id|MSG_EXT_PPR_RTI
suffix:semicolon
id|tinfo-&gt;user.width
op_assign
id|MSG_EXT_WDTR_BUS_16_BIT
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Start out Async/Narrow/Untagged and with&n;&t;&t; * conservative protocol support.&n;&t;&t; */
id|tinfo-&gt;goal.protocol_version
op_assign
l_int|2
suffix:semicolon
id|tinfo-&gt;goal.transport_version
op_assign
l_int|2
suffix:semicolon
id|tinfo-&gt;curr.protocol_version
op_assign
l_int|2
suffix:semicolon
id|tinfo-&gt;curr.transport_version
op_assign
l_int|2
suffix:semicolon
id|ahd_compile_devinfo
c_func
(paren
op_amp
id|devinfo
comma
id|ahd-&gt;our_id
comma
id|targ
comma
id|CAM_LUN_WILDCARD
comma
l_char|&squot;A&squot;
comma
id|ROLE_INITIATOR
)paren
suffix:semicolon
id|tstate-&gt;tagenable
op_and_assign
op_complement
id|target_mask
suffix:semicolon
id|ahd_set_width
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
comma
id|MSG_EXT_WDTR_BUS_8_BIT
comma
id|AHD_TRANS_CUR
op_or
id|AHD_TRANS_GOAL
comma
multiline_comment|/*paused*/
id|TRUE
)paren
suffix:semicolon
id|ahd_set_syncrate
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
comma
multiline_comment|/*period*/
l_int|0
comma
multiline_comment|/*offset*/
l_int|0
comma
multiline_comment|/*ppr_options*/
l_int|0
comma
id|AHD_TRANS_CUR
op_or
id|AHD_TRANS_GOAL
comma
multiline_comment|/*paused*/
id|TRUE
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Parse device configuration information.&n; */
r_int
DECL|function|ahd_parse_cfgdata
id|ahd_parse_cfgdata
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|seeprom_config
op_star
id|sc
)paren
(brace
r_int
id|targ
suffix:semicolon
r_int
id|max_targ
suffix:semicolon
id|max_targ
op_assign
id|sc-&gt;max_targets
op_amp
id|CFMAXTARG
suffix:semicolon
id|ahd-&gt;our_id
op_assign
id|sc-&gt;brtime_id
op_amp
id|CFSCSIID
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate a tstate to house information for our&n;&t; * initiator presence on the bus as well as the user&n;&t; * data for any target mode initiator.&n;&t; */
r_if
c_cond
(paren
id|ahd_alloc_tstate
c_func
(paren
id|ahd
comma
id|ahd-&gt;our_id
comma
l_char|&squot;A&squot;
)paren
op_eq
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: unable to allocate ahd_tmode_tstate.  &quot;
l_string|&quot;Failing attach&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
r_return
(paren
id|ENOMEM
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|targ
op_assign
l_int|0
suffix:semicolon
id|targ
OL
id|max_targ
suffix:semicolon
id|targ
op_increment
)paren
(brace
r_struct
id|ahd_devinfo
id|devinfo
suffix:semicolon
r_struct
id|ahd_initiator_tinfo
op_star
id|tinfo
suffix:semicolon
r_struct
id|ahd_transinfo
op_star
id|user_tinfo
suffix:semicolon
r_struct
id|ahd_tmode_tstate
op_star
id|tstate
suffix:semicolon
r_uint16
id|target_mask
suffix:semicolon
id|tinfo
op_assign
id|ahd_fetch_transinfo
c_func
(paren
id|ahd
comma
l_char|&squot;A&squot;
comma
id|ahd-&gt;our_id
comma
id|targ
comma
op_amp
id|tstate
)paren
suffix:semicolon
id|user_tinfo
op_assign
op_amp
id|tinfo-&gt;user
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We support SPC2 and SPI4.&n;&t;&t; */
id|tinfo-&gt;user.protocol_version
op_assign
l_int|4
suffix:semicolon
id|tinfo-&gt;user.transport_version
op_assign
l_int|4
suffix:semicolon
id|target_mask
op_assign
l_int|0x01
op_lshift
id|targ
suffix:semicolon
id|ahd-&gt;user_discenable
op_and_assign
op_complement
id|target_mask
suffix:semicolon
id|tstate-&gt;discenable
op_and_assign
op_complement
id|target_mask
suffix:semicolon
id|ahd-&gt;user_tagenable
op_and_assign
op_complement
id|target_mask
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;device_flags
(braket
id|targ
)braket
op_amp
id|CFDISC
)paren
(brace
id|tstate-&gt;discenable
op_or_assign
id|target_mask
suffix:semicolon
id|ahd-&gt;user_discenable
op_or_assign
id|target_mask
suffix:semicolon
id|ahd-&gt;user_tagenable
op_or_assign
id|target_mask
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Cannot be packetized without disconnection.&n;&t;&t;&t; */
id|sc-&gt;device_flags
(braket
id|targ
)braket
op_and_assign
op_complement
id|CFPACKETIZED
suffix:semicolon
)brace
id|user_tinfo-&gt;ppr_options
op_assign
l_int|0
suffix:semicolon
id|user_tinfo-&gt;period
op_assign
(paren
id|sc-&gt;device_flags
(braket
id|targ
)braket
op_amp
id|CFXFER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|user_tinfo-&gt;period
OL
id|CFXFER_ASYNC
)paren
(brace
r_if
c_cond
(paren
id|user_tinfo-&gt;period
op_le
id|AHD_PERIOD_10MHz
)paren
id|user_tinfo-&gt;ppr_options
op_or_assign
id|MSG_EXT_PPR_DT_REQ
suffix:semicolon
id|user_tinfo-&gt;offset
op_assign
id|MAX_OFFSET
suffix:semicolon
)brace
r_else
(brace
id|user_tinfo-&gt;offset
op_assign
l_int|0
suffix:semicolon
id|user_tinfo-&gt;period
op_assign
id|AHD_ASYNC_XFER_PERIOD
suffix:semicolon
)brace
macro_line|#ifdef AHD_FORCE_160
r_if
c_cond
(paren
id|user_tinfo-&gt;period
op_le
id|AHD_SYNCRATE_160
)paren
id|user_tinfo-&gt;period
op_assign
id|AHD_SYNCRATE_DT
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|sc-&gt;device_flags
(braket
id|targ
)braket
op_amp
id|CFPACKETIZED
)paren
op_ne
l_int|0
)paren
(brace
id|user_tinfo-&gt;ppr_options
op_or_assign
id|MSG_EXT_PPR_RD_STRM
op_or
id|MSG_EXT_PPR_WR_FLOW
op_or
id|MSG_EXT_PPR_HOLD_MCS
op_or
id|MSG_EXT_PPR_IU_REQ
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;features
op_amp
id|AHD_RTI
)paren
op_ne
l_int|0
)paren
id|user_tinfo-&gt;ppr_options
op_or_assign
id|MSG_EXT_PPR_RTI
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|sc-&gt;device_flags
(braket
id|targ
)braket
op_amp
id|CFQAS
)paren
op_ne
l_int|0
)paren
id|user_tinfo-&gt;ppr_options
op_or_assign
id|MSG_EXT_PPR_QAS_REQ
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sc-&gt;device_flags
(braket
id|targ
)braket
op_amp
id|CFWIDEB
)paren
op_ne
l_int|0
)paren
id|user_tinfo-&gt;width
op_assign
id|MSG_EXT_WDTR_BUS_16_BIT
suffix:semicolon
r_else
id|user_tinfo-&gt;width
op_assign
id|MSG_EXT_WDTR_BUS_8_BIT
suffix:semicolon
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_MISC
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;(%d): %x:%x:%x:%x&bslash;n&quot;
comma
id|targ
comma
id|user_tinfo-&gt;width
comma
id|user_tinfo-&gt;period
comma
id|user_tinfo-&gt;offset
comma
id|user_tinfo-&gt;ppr_options
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t; * Start out Async/Narrow/Untagged and with&n;&t;&t; * conservative protocol support.&n;&t;&t; */
id|tstate-&gt;tagenable
op_and_assign
op_complement
id|target_mask
suffix:semicolon
id|tinfo-&gt;goal.protocol_version
op_assign
l_int|2
suffix:semicolon
id|tinfo-&gt;goal.transport_version
op_assign
l_int|2
suffix:semicolon
id|tinfo-&gt;curr.protocol_version
op_assign
l_int|2
suffix:semicolon
id|tinfo-&gt;curr.transport_version
op_assign
l_int|2
suffix:semicolon
id|ahd_compile_devinfo
c_func
(paren
op_amp
id|devinfo
comma
id|ahd-&gt;our_id
comma
id|targ
comma
id|CAM_LUN_WILDCARD
comma
l_char|&squot;A&squot;
comma
id|ROLE_INITIATOR
)paren
suffix:semicolon
id|ahd_set_width
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
comma
id|MSG_EXT_WDTR_BUS_8_BIT
comma
id|AHD_TRANS_CUR
op_or
id|AHD_TRANS_GOAL
comma
multiline_comment|/*paused*/
id|TRUE
)paren
suffix:semicolon
id|ahd_set_syncrate
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
comma
multiline_comment|/*period*/
l_int|0
comma
multiline_comment|/*offset*/
l_int|0
comma
multiline_comment|/*ppr_options*/
l_int|0
comma
id|AHD_TRANS_CUR
op_or
id|AHD_TRANS_GOAL
comma
multiline_comment|/*paused*/
id|TRUE
)paren
suffix:semicolon
)brace
id|ahd-&gt;flags
op_and_assign
op_complement
id|AHD_SPCHK_ENB_A
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;bios_control
op_amp
id|CFSPARITY
)paren
id|ahd-&gt;flags
op_or_assign
id|AHD_SPCHK_ENB_A
suffix:semicolon
id|ahd-&gt;flags
op_and_assign
op_complement
id|AHD_RESET_BUS_A
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;bios_control
op_amp
id|CFRESETB
)paren
id|ahd-&gt;flags
op_or_assign
id|AHD_RESET_BUS_A
suffix:semicolon
id|ahd-&gt;flags
op_and_assign
op_complement
id|AHD_EXTENDED_TRANS_A
suffix:semicolon
r_if
c_cond
(paren
id|sc-&gt;bios_control
op_amp
id|CFEXTEND
)paren
id|ahd-&gt;flags
op_or_assign
id|AHD_EXTENDED_TRANS_A
suffix:semicolon
id|ahd-&gt;flags
op_and_assign
op_complement
id|AHD_BIOS_ENABLED
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sc-&gt;bios_control
op_amp
id|CFBIOSSTATE
)paren
op_eq
id|CFBS_ENABLED
)paren
id|ahd-&gt;flags
op_or_assign
id|AHD_BIOS_ENABLED
suffix:semicolon
id|ahd-&gt;flags
op_and_assign
op_complement
id|AHD_STPWLEVEL_A
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sc-&gt;adapter_control
op_amp
id|CFSTPWLEVEL
)paren
op_ne
l_int|0
)paren
id|ahd-&gt;flags
op_or_assign
id|AHD_STPWLEVEL_A
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahd_intr_enable
id|ahd_intr_enable
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_int
id|enable
)paren
(brace
id|u_int
id|hcntrl
suffix:semicolon
id|hcntrl
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|HCNTRL
)paren
suffix:semicolon
id|hcntrl
op_and_assign
op_complement
id|INTEN
suffix:semicolon
id|ahd-&gt;pause
op_and_assign
op_complement
id|INTEN
suffix:semicolon
id|ahd-&gt;unpause
op_and_assign
op_complement
id|INTEN
suffix:semicolon
r_if
c_cond
(paren
id|enable
)paren
(brace
id|hcntrl
op_or_assign
id|INTEN
suffix:semicolon
id|ahd-&gt;pause
op_or_assign
id|INTEN
suffix:semicolon
id|ahd-&gt;unpause
op_or_assign
id|INTEN
suffix:semicolon
)brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|HCNTRL
comma
id|hcntrl
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahd_update_coalessing_values
id|ahd_update_coalessing_values
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
id|u_int
id|timer
comma
id|u_int
id|maxcmds
comma
id|u_int
id|mincmds
)paren
(brace
r_if
c_cond
(paren
id|timer
OG
id|AHD_TIMER_MAX_US
)paren
id|timer
op_assign
id|AHD_TIMER_MAX_US
suffix:semicolon
id|ahd-&gt;int_coalessing_timer
op_assign
id|timer
suffix:semicolon
r_if
c_cond
(paren
id|maxcmds
OG
id|AHD_INT_COALESSING_MAXCMDS_MAX
)paren
id|maxcmds
op_assign
id|AHD_INT_COALESSING_MAXCMDS_MAX
suffix:semicolon
r_if
c_cond
(paren
id|mincmds
OG
id|AHD_INT_COALESSING_MINCMDS_MAX
)paren
id|mincmds
op_assign
id|AHD_INT_COALESSING_MINCMDS_MAX
suffix:semicolon
id|ahd-&gt;int_coalessing_maxcmds
op_assign
id|maxcmds
suffix:semicolon
id|ahd_outw
c_func
(paren
id|ahd
comma
id|INT_COALESSING_TIMER
comma
id|timer
op_div
id|AHD_TIMER_US_PER_TICK
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|INT_COALESSING_MAXCMDS
comma
op_minus
id|maxcmds
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|INT_COALESSING_MINCMDS
comma
op_minus
id|mincmds
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahd_enable_coalessing
id|ahd_enable_coalessing
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_int
id|enable
)paren
(brace
id|ahd-&gt;hs_mailbox
op_and_assign
op_complement
id|ENINT_COALESS
suffix:semicolon
r_if
c_cond
(paren
id|enable
)paren
id|ahd-&gt;hs_mailbox
op_or_assign
id|ENINT_COALESS
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|HS_MAILBOX
comma
id|ahd-&gt;hs_mailbox
)paren
suffix:semicolon
id|ahd_flush_device_writes
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_run_qoutfifo
c_func
(paren
id|ahd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Ensure that the card is paused in a location&n; * outside of all critical sections and that all&n; * pending work is completed prior to returning.&n; * This routine should only be called from outside&n; * an interrupt context.&n; */
r_void
DECL|function|ahd_pause_and_flushwork
id|ahd_pause_and_flushwork
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
id|ahd_mode_state
id|saved_modes
suffix:semicolon
id|u_int
id|intstat
suffix:semicolon
id|u_int
id|maxloops
suffix:semicolon
r_int
id|paused
suffix:semicolon
id|maxloops
op_assign
l_int|1000
suffix:semicolon
id|ahd-&gt;flags
op_or_assign
id|AHD_ALL_INTERRUPTS
suffix:semicolon
id|paused
op_assign
id|FALSE
suffix:semicolon
r_do
(brace
r_struct
id|scb
op_star
id|waiting_scb
suffix:semicolon
r_if
c_cond
(paren
id|paused
)paren
id|ahd_unpause
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_intr
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_pause
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|paused
op_assign
id|TRUE
suffix:semicolon
id|ahd_clear_critical_section
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|saved_modes
op_assign
id|ahd_save_modes
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI
comma
id|AHD_MODE_SCSI
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SSTAT0
)paren
op_amp
(paren
id|SELDO
op_or
id|SELINGO
)paren
)paren
op_eq
l_int|0
)paren
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCSISEQ0
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSISEQ0
)paren
op_amp
op_complement
id|ENSELO
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * In the non-packetized case, the sequencer (for Rev A),&n;&t;&t; * relies on ENSELO remaining set after SELDO.  The hardware&n;&t;&t; * auto-clears ENSELO in the packetized case.&n;&t;&t; */
id|waiting_scb
op_assign
id|ahd_lookup_scb
c_func
(paren
id|ahd
comma
id|ahd_inw
c_func
(paren
id|ahd
comma
id|WAITING_TID_HEAD
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waiting_scb
op_ne
l_int|NULL
op_logical_and
(paren
id|waiting_scb-&gt;flags
op_amp
id|SCB_PACKETIZED
)paren
op_eq
l_int|0
op_logical_and
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SSTAT0
)paren
op_amp
(paren
id|SELDO
op_or
id|SELINGO
)paren
)paren
op_ne
l_int|0
)paren
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCSISEQ0
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSISEQ0
)paren
op_or
id|ENSELO
)paren
suffix:semicolon
id|intstat
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|INTSTAT
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|maxloops
op_logical_and
(paren
id|intstat
op_ne
l_int|0xFF
op_logical_or
(paren
id|ahd-&gt;features
op_amp
id|AHD_REMOVABLE
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
(paren
id|intstat
op_amp
id|INT_PEND
)paren
op_ne
l_int|0
op_logical_or
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SSTAT0
)paren
op_amp
(paren
id|SELDO
op_or
id|SELINGO
)paren
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|maxloops
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Infinite interrupt loop, INTSTAT = %x&quot;
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|INTSTAT
)paren
)paren
suffix:semicolon
)brace
id|ahd_flush_qoutfifo
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_platform_flushwork
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd-&gt;flags
op_and_assign
op_complement
id|AHD_ALL_INTERRUPTS
suffix:semicolon
id|ahd_restore_modes
c_func
(paren
id|ahd
comma
id|saved_modes
)paren
suffix:semicolon
)brace
r_int
DECL|function|ahd_suspend
id|ahd_suspend
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
macro_line|#if 0
r_uint8
op_star
id|ptr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ahd_pause_and_flushwork
c_func
(paren
id|ahd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|LIST_FIRST
c_func
(paren
op_amp
id|ahd-&gt;pending_scbs
)paren
op_ne
l_int|NULL
)paren
r_return
(paren
id|EBUSY
)paren
suffix:semicolon
macro_line|#if AHD_TARGET_MODE
multiline_comment|/*&n;&t; * XXX What about ATIOs that have not yet been serviced?&n;&t; * Perhaps we should just refuse to be suspended if we&n;&t; * are acting in a target role.&n;&t; */
r_if
c_cond
(paren
id|ahd-&gt;pending_device
op_ne
l_int|NULL
)paren
r_return
(paren
id|EBUSY
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Save volatile registers */
id|ahd-&gt;suspend_state.channel
(braket
l_int|0
)braket
dot
id|scsiseq
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSISEQ0
)paren
suffix:semicolon
id|ahd-&gt;suspend_state.channel
(braket
l_int|0
)braket
dot
id|sxfrctl0
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SXFRCTL0
)paren
suffix:semicolon
id|ahd-&gt;suspend_state.channel
(braket
l_int|0
)braket
dot
id|sxfrctl1
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SXFRCTL1
)paren
suffix:semicolon
id|ahd-&gt;suspend_state.channel
(braket
l_int|0
)braket
dot
id|simode0
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SIMODE0
)paren
suffix:semicolon
id|ahd-&gt;suspend_state.channel
(braket
l_int|0
)braket
dot
id|simode1
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SIMODE1
)paren
suffix:semicolon
id|ahd-&gt;suspend_state.channel
(braket
l_int|0
)braket
dot
id|seltimer
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SELTIMER
)paren
suffix:semicolon
id|ahd-&gt;suspend_state.channel
(braket
l_int|0
)braket
dot
id|seqctl
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SEQCTL0
)paren
suffix:semicolon
id|ahd-&gt;suspend_state.dscommand0
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|DSCOMMAND0
)paren
suffix:semicolon
id|ahd-&gt;suspend_state.dspcistatus
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|DSPCISTATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;features
op_amp
id|AHD_DT
)paren
op_ne
l_int|0
)paren
(brace
id|u_int
id|sfunct
suffix:semicolon
id|sfunct
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SFUNCT
)paren
op_amp
op_complement
id|ALT_MODE
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SFUNCT
comma
id|sfunct
op_or
id|ALT_MODE
)paren
suffix:semicolon
id|ahd-&gt;suspend_state.optionmode
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|OPTIONMODE
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SFUNCT
comma
id|sfunct
)paren
suffix:semicolon
id|ahd-&gt;suspend_state.crccontrol1
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|CRCCONTROL1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ahd-&gt;features
op_amp
id|AHD_MULTI_FUNC
)paren
op_ne
l_int|0
)paren
id|ahd-&gt;suspend_state.scbbaddr
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCBBADDR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;features
op_amp
id|AHD_ULTRA2
)paren
op_ne
l_int|0
)paren
id|ahd-&gt;suspend_state.dff_thrsh
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|DFF_THRSH
)paren
suffix:semicolon
id|ptr
op_assign
id|ahd-&gt;suspend_state.scratch_ram
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|64
suffix:semicolon
id|i
op_increment
)paren
op_star
id|ptr
op_increment
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SRAM_BASE
op_plus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;features
op_amp
id|AHD_MORE_SRAM
)paren
op_ne
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
op_star
id|ptr
op_increment
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|TARG_OFFSET
op_plus
id|i
)paren
suffix:semicolon
)brace
id|ptr
op_assign
id|ahd-&gt;suspend_state.btt
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AHD_NUM_TARGETS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|AHD_NUM_LUNS_NONPKT
suffix:semicolon
id|j
op_increment
)paren
(brace
id|u_int
id|tcl
suffix:semicolon
id|tcl
op_assign
id|BUILD_TCL_RAW
c_func
(paren
id|i
comma
l_char|&squot;A&squot;
comma
id|j
)paren
suffix:semicolon
op_star
id|ptr
op_assign
id|ahd_find_busy_tcl
c_func
(paren
id|ahd
comma
id|tcl
)paren
suffix:semicolon
)brace
)brace
id|ahd_shutdown
c_func
(paren
id|ahd
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_int
DECL|function|ahd_resume
id|ahd_resume
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
macro_line|#if 0
r_uint8
op_star
id|ptr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ahd_reset
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_build_free_scb_list
c_func
(paren
id|ahd
)paren
suffix:semicolon
multiline_comment|/* Restore volatile registers */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCSISEQ0
comma
id|ahd-&gt;suspend_state.channel
(braket
l_int|0
)braket
dot
id|scsiseq
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SXFRCTL0
comma
id|ahd-&gt;suspend_state.channel
(braket
l_int|0
)braket
dot
id|sxfrctl0
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SXFRCTL1
comma
id|ahd-&gt;suspend_state.channel
(braket
l_int|0
)braket
dot
id|sxfrctl1
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SIMODE0
comma
id|ahd-&gt;suspend_state.channel
(braket
l_int|0
)braket
dot
id|simode0
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SIMODE1
comma
id|ahd-&gt;suspend_state.channel
(braket
l_int|0
)braket
dot
id|simode1
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SELTIMER
comma
id|ahd-&gt;suspend_state.channel
(braket
l_int|0
)braket
dot
id|seltimer
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SEQCTL0
comma
id|ahd-&gt;suspend_state.channel
(braket
l_int|0
)braket
dot
id|seqctl
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;features
op_amp
id|AHD_ULTRA2
)paren
op_ne
l_int|0
)paren
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCSIID_ULTRA2
comma
id|ahd-&gt;our_id
)paren
suffix:semicolon
r_else
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCSIID
comma
id|ahd-&gt;our_id
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|DSCOMMAND0
comma
id|ahd-&gt;suspend_state.dscommand0
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|DSPCISTATUS
comma
id|ahd-&gt;suspend_state.dspcistatus
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;features
op_amp
id|AHD_DT
)paren
op_ne
l_int|0
)paren
(brace
id|u_int
id|sfunct
suffix:semicolon
id|sfunct
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SFUNCT
)paren
op_amp
op_complement
id|ALT_MODE
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SFUNCT
comma
id|sfunct
op_or
id|ALT_MODE
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|OPTIONMODE
comma
id|ahd-&gt;suspend_state.optionmode
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SFUNCT
comma
id|sfunct
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CRCCONTROL1
comma
id|ahd-&gt;suspend_state.crccontrol1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ahd-&gt;features
op_amp
id|AHD_MULTI_FUNC
)paren
op_ne
l_int|0
)paren
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCBBADDR
comma
id|ahd-&gt;suspend_state.scbbaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;features
op_amp
id|AHD_ULTRA2
)paren
op_ne
l_int|0
)paren
id|ahd_outb
c_func
(paren
id|ahd
comma
id|DFF_THRSH
comma
id|ahd-&gt;suspend_state.dff_thrsh
)paren
suffix:semicolon
id|ptr
op_assign
id|ahd-&gt;suspend_state.scratch_ram
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|64
suffix:semicolon
id|i
op_increment
)paren
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SRAM_BASE
op_plus
id|i
comma
op_star
id|ptr
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;features
op_amp
id|AHD_MORE_SRAM
)paren
op_ne
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
id|ahd_outb
c_func
(paren
id|ahd
comma
id|TARG_OFFSET
op_plus
id|i
comma
op_star
id|ptr
op_increment
)paren
suffix:semicolon
)brace
id|ptr
op_assign
id|ahd-&gt;suspend_state.btt
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AHD_NUM_TARGETS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|AHD_NUM_LUNS
suffix:semicolon
id|j
op_increment
)paren
(brace
id|u_int
id|tcl
suffix:semicolon
id|tcl
op_assign
id|BUILD_TCL
c_func
(paren
id|i
op_lshift
l_int|4
comma
id|j
)paren
suffix:semicolon
id|ahd_busy_tcl
c_func
(paren
id|ahd
comma
id|tcl
comma
op_star
id|ptr
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/************************** Busy Target Table *********************************/
multiline_comment|/*&n; * Set SCBPTR to the SCB that contains the busy&n; * table entry for TCL.  Return the offset into&n; * the SCB that contains the entry for TCL.&n; * saved_scbid is dereferenced and set to the&n; * scbid that should be restored once manipualtion&n; * of the TCL entry is complete.&n; */
r_static
id|__inline
id|u_int
DECL|function|ahd_index_busy_tcl
id|ahd_index_busy_tcl
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
id|u_int
op_star
id|saved_scbid
comma
id|u_int
id|tcl
)paren
(brace
multiline_comment|/*&n;&t; * Index to the SCB that contains the busy entry.&n;&t; */
id|AHD_ASSERT_MODES
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI_MSK
comma
id|AHD_MODE_SCSI_MSK
)paren
suffix:semicolon
op_star
id|saved_scbid
op_assign
id|ahd_get_scbptr
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_set_scbptr
c_func
(paren
id|ahd
comma
id|TCL_LUN
c_func
(paren
id|tcl
)paren
op_or
(paren
(paren
id|TCL_TARGET_OFFSET
c_func
(paren
id|tcl
)paren
op_amp
l_int|0xC
)paren
op_lshift
l_int|4
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * And now calculate the SCB offset to the entry.&n;&t; * Each entry is 2 bytes wide, hence the&n;&t; * multiplication by 2.&n;&t; */
r_return
(paren
(paren
(paren
id|TCL_TARGET_OFFSET
c_func
(paren
id|tcl
)paren
op_amp
l_int|0x3
)paren
op_lshift
l_int|1
)paren
op_plus
id|SCB_DISCONNECTED_LISTS
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Return the untagged transaction id for a given target/channel lun.&n; * Optionally, clear the entry.&n; */
id|u_int
DECL|function|ahd_find_busy_tcl
id|ahd_find_busy_tcl
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
id|u_int
id|tcl
)paren
(brace
id|u_int
id|scbid
suffix:semicolon
id|u_int
id|scb_offset
suffix:semicolon
id|u_int
id|saved_scbptr
suffix:semicolon
id|scb_offset
op_assign
id|ahd_index_busy_tcl
c_func
(paren
id|ahd
comma
op_amp
id|saved_scbptr
comma
id|tcl
)paren
suffix:semicolon
id|scbid
op_assign
id|ahd_inw_scbram
c_func
(paren
id|ahd
comma
id|scb_offset
)paren
suffix:semicolon
id|ahd_set_scbptr
c_func
(paren
id|ahd
comma
id|saved_scbptr
)paren
suffix:semicolon
r_return
(paren
id|scbid
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahd_busy_tcl
id|ahd_busy_tcl
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
id|u_int
id|tcl
comma
id|u_int
id|scbid
)paren
(brace
id|u_int
id|scb_offset
suffix:semicolon
id|u_int
id|saved_scbptr
suffix:semicolon
id|scb_offset
op_assign
id|ahd_index_busy_tcl
c_func
(paren
id|ahd
comma
op_amp
id|saved_scbptr
comma
id|tcl
)paren
suffix:semicolon
id|ahd_outw
c_func
(paren
id|ahd
comma
id|scb_offset
comma
id|scbid
)paren
suffix:semicolon
id|ahd_set_scbptr
c_func
(paren
id|ahd
comma
id|saved_scbptr
)paren
suffix:semicolon
)brace
multiline_comment|/************************** SCB and SCB queue management **********************/
r_int
DECL|function|ahd_match_scb
id|ahd_match_scb
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|scb
op_star
id|scb
comma
r_int
id|target
comma
r_char
id|channel
comma
r_int
id|lun
comma
id|u_int
id|tag
comma
id|role_t
id|role
)paren
(brace
r_int
id|targ
op_assign
id|SCB_GET_TARGET
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
r_char
id|chan
op_assign
id|SCB_GET_CHANNEL
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
r_int
id|slun
op_assign
id|SCB_GET_LUN
c_func
(paren
id|scb
)paren
suffix:semicolon
r_int
id|match
suffix:semicolon
id|match
op_assign
(paren
(paren
id|chan
op_eq
id|channel
)paren
op_logical_or
(paren
id|channel
op_eq
id|ALL_CHANNELS
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|match
op_ne
l_int|0
)paren
id|match
op_assign
(paren
(paren
id|targ
op_eq
id|target
)paren
op_logical_or
(paren
id|target
op_eq
id|CAM_TARGET_WILDCARD
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|match
op_ne
l_int|0
)paren
id|match
op_assign
(paren
(paren
id|lun
op_eq
id|slun
)paren
op_logical_or
(paren
id|lun
op_eq
id|CAM_LUN_WILDCARD
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|match
op_ne
l_int|0
)paren
(brace
macro_line|#if AHD_TARGET_MODE
r_int
id|group
suffix:semicolon
id|group
op_assign
id|XPT_FC_GROUP
c_func
(paren
id|scb-&gt;io_ctx-&gt;ccb_h.func_code
)paren
suffix:semicolon
r_if
c_cond
(paren
id|role
op_eq
id|ROLE_INITIATOR
)paren
(brace
id|match
op_assign
(paren
id|group
op_ne
id|XPT_FC_GROUP_TMODE
)paren
op_logical_and
(paren
(paren
id|tag
op_eq
id|SCB_GET_TAG
c_func
(paren
id|scb
)paren
)paren
op_logical_or
(paren
id|tag
op_eq
id|SCB_LIST_NULL
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|role
op_eq
id|ROLE_TARGET
)paren
(brace
id|match
op_assign
(paren
id|group
op_eq
id|XPT_FC_GROUP_TMODE
)paren
op_logical_and
(paren
(paren
id|tag
op_eq
id|scb-&gt;io_ctx-&gt;csio.tag_id
)paren
op_logical_or
(paren
id|tag
op_eq
id|SCB_LIST_NULL
)paren
)paren
suffix:semicolon
)brace
macro_line|#else /* !AHD_TARGET_MODE */
id|match
op_assign
(paren
(paren
id|tag
op_eq
id|SCB_GET_TAG
c_func
(paren
id|scb
)paren
)paren
op_logical_or
(paren
id|tag
op_eq
id|SCB_LIST_NULL
)paren
)paren
suffix:semicolon
macro_line|#endif /* AHD_TARGET_MODE */
)brace
r_return
id|match
suffix:semicolon
)brace
r_void
DECL|function|ahd_freeze_devq
id|ahd_freeze_devq
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|scb
op_star
id|scb
)paren
(brace
r_int
id|target
suffix:semicolon
r_char
id|channel
suffix:semicolon
r_int
id|lun
suffix:semicolon
id|target
op_assign
id|SCB_GET_TARGET
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|lun
op_assign
id|SCB_GET_LUN
c_func
(paren
id|scb
)paren
suffix:semicolon
id|channel
op_assign
id|SCB_GET_CHANNEL
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|ahd_search_qinfifo
c_func
(paren
id|ahd
comma
id|target
comma
id|channel
comma
id|lun
comma
multiline_comment|/*tag*/
id|SCB_LIST_NULL
comma
id|ROLE_UNKNOWN
comma
id|CAM_REQUEUE_REQ
comma
id|SEARCH_COMPLETE
)paren
suffix:semicolon
id|ahd_platform_freeze_devq
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahd_qinfifo_requeue_tail
id|ahd_qinfifo_requeue_tail
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|scb
op_star
id|scb
)paren
(brace
r_struct
id|scb
op_star
id|prev_scb
suffix:semicolon
id|ahd_mode_state
id|saved_modes
suffix:semicolon
id|saved_modes
op_assign
id|ahd_save_modes
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_CCHAN
comma
id|AHD_MODE_CCHAN
)paren
suffix:semicolon
id|prev_scb
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|ahd_qinfifo_count
c_func
(paren
id|ahd
)paren
op_ne
l_int|0
)paren
(brace
id|u_int
id|prev_tag
suffix:semicolon
id|u_int
id|prev_pos
suffix:semicolon
id|prev_pos
op_assign
id|AHD_QIN_WRAP
c_func
(paren
id|ahd-&gt;qinfifonext
op_minus
l_int|1
)paren
suffix:semicolon
id|prev_tag
op_assign
id|ahd-&gt;qinfifo
(braket
id|prev_pos
)braket
suffix:semicolon
id|prev_scb
op_assign
id|ahd_lookup_scb
c_func
(paren
id|ahd
comma
id|prev_tag
)paren
suffix:semicolon
)brace
id|ahd_qinfifo_requeue
c_func
(paren
id|ahd
comma
id|prev_scb
comma
id|scb
)paren
suffix:semicolon
id|ahd_set_hnscb_qoff
c_func
(paren
id|ahd
comma
id|ahd-&gt;qinfifonext
)paren
suffix:semicolon
id|ahd_restore_modes
c_func
(paren
id|ahd
comma
id|saved_modes
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahd_qinfifo_requeue
id|ahd_qinfifo_requeue
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|scb
op_star
id|prev_scb
comma
r_struct
id|scb
op_star
id|scb
)paren
(brace
r_if
c_cond
(paren
id|prev_scb
op_eq
l_int|NULL
)paren
(brace
r_uint32
id|busaddr
suffix:semicolon
id|busaddr
op_assign
id|ahd_le32toh
c_func
(paren
id|scb-&gt;hscb-&gt;hscb_busaddr
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|NEXT_QUEUED_SCB_ADDR
op_plus
l_int|0
comma
id|busaddr
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|NEXT_QUEUED_SCB_ADDR
op_plus
l_int|1
comma
(paren
id|busaddr
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|NEXT_QUEUED_SCB_ADDR
op_plus
l_int|2
comma
(paren
id|busaddr
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|NEXT_QUEUED_SCB_ADDR
op_plus
l_int|3
comma
(paren
id|busaddr
op_rshift
l_int|24
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
)brace
r_else
(brace
id|prev_scb-&gt;hscb-&gt;next_hscb_busaddr
op_assign
id|scb-&gt;hscb-&gt;hscb_busaddr
suffix:semicolon
id|ahd_sync_scb
c_func
(paren
id|ahd
comma
id|prev_scb
comma
id|BUS_DMASYNC_PREREAD
op_or
id|BUS_DMASYNC_PREWRITE
)paren
suffix:semicolon
)brace
id|ahd-&gt;qinfifo
(braket
id|AHD_QIN_WRAP
c_func
(paren
id|ahd-&gt;qinfifonext
)paren
)braket
op_assign
id|SCB_GET_TAG
c_func
(paren
id|scb
)paren
suffix:semicolon
id|ahd-&gt;qinfifonext
op_increment
suffix:semicolon
id|scb-&gt;hscb-&gt;next_hscb_busaddr
op_assign
id|ahd-&gt;next_queued_hscb-&gt;hscb_busaddr
suffix:semicolon
id|ahd_sync_scb
c_func
(paren
id|ahd
comma
id|scb
comma
id|BUS_DMASYNC_PREREAD
op_or
id|BUS_DMASYNC_PREWRITE
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|ahd_qinfifo_count
id|ahd_qinfifo_count
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
id|u_int
id|qinpos
suffix:semicolon
id|u_int
id|wrap_qinpos
suffix:semicolon
id|u_int
id|wrap_qinfifonext
suffix:semicolon
id|AHD_ASSERT_MODES
c_func
(paren
id|ahd
comma
id|AHD_MODE_CCHAN_MSK
comma
id|AHD_MODE_CCHAN_MSK
)paren
suffix:semicolon
id|qinpos
op_assign
id|ahd_get_snscb_qoff
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|wrap_qinpos
op_assign
id|AHD_QIN_WRAP
c_func
(paren
id|qinpos
)paren
suffix:semicolon
id|wrap_qinfifonext
op_assign
id|AHD_QIN_WRAP
c_func
(paren
id|ahd-&gt;qinfifonext
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wrap_qinfifonext
op_ge
id|wrap_qinpos
)paren
r_return
(paren
id|wrap_qinfifonext
op_minus
id|wrap_qinpos
)paren
suffix:semicolon
r_else
r_return
(paren
id|wrap_qinfifonext
op_plus
id|NUM_ELEMENTS
c_func
(paren
id|ahd-&gt;qinfifo
)paren
op_minus
id|wrap_qinpos
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahd_reset_cmds_pending
id|ahd_reset_cmds_pending
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
r_struct
id|scb
op_star
id|scb
suffix:semicolon
id|ahd_mode_state
id|saved_modes
suffix:semicolon
id|u_int
id|pending_cmds
suffix:semicolon
id|saved_modes
op_assign
id|ahd_save_modes
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_CCHAN
comma
id|AHD_MODE_CCHAN
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Don&squot;t count any commands as outstanding that the&n;&t; * sequencer has already marked for completion.&n;&t; */
id|ahd_flush_qoutfifo
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|pending_cmds
op_assign
l_int|0
suffix:semicolon
id|LIST_FOREACH
c_func
(paren
id|scb
comma
op_amp
id|ahd-&gt;pending_scbs
comma
id|pending_links
)paren
(brace
id|pending_cmds
op_increment
suffix:semicolon
)brace
id|ahd_outw
c_func
(paren
id|ahd
comma
id|CMDS_PENDING
comma
id|pending_cmds
op_minus
id|ahd_qinfifo_count
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
id|ahd_restore_modes
c_func
(paren
id|ahd
comma
id|saved_modes
)paren
suffix:semicolon
id|ahd-&gt;flags
op_and_assign
op_complement
id|AHD_UPDATE_PEND_CMDS
suffix:semicolon
)brace
r_int
DECL|function|ahd_search_qinfifo
id|ahd_search_qinfifo
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_int
id|target
comma
r_char
id|channel
comma
r_int
id|lun
comma
id|u_int
id|tag
comma
id|role_t
id|role
comma
r_uint32
id|status
comma
id|ahd_search_action
id|action
)paren
(brace
r_struct
id|scb
op_star
id|scb
suffix:semicolon
r_struct
id|scb
op_star
id|prev_scb
suffix:semicolon
id|ahd_mode_state
id|saved_modes
suffix:semicolon
id|u_int
id|qinstart
suffix:semicolon
id|u_int
id|qinpos
suffix:semicolon
id|u_int
id|qintail
suffix:semicolon
id|u_int
id|tid_next
suffix:semicolon
id|u_int
id|tid_prev
suffix:semicolon
id|u_int
id|scbid
suffix:semicolon
id|u_int
id|savedscbptr
suffix:semicolon
r_uint32
id|busaddr
suffix:semicolon
r_int
id|found
suffix:semicolon
r_int
id|targets
suffix:semicolon
multiline_comment|/* Must be in CCHAN mode */
id|saved_modes
op_assign
id|ahd_save_modes
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_CCHAN
comma
id|AHD_MODE_CCHAN
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Halt any pending SCB DMA.  The sequencer will reinitiate&n;&t; * this dma if the qinfifo is not empty once we unpause.&n;&t; */
r_if
c_cond
(paren
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|CCSCBCTL
)paren
op_amp
(paren
id|CCARREN
op_or
id|CCSCBEN
op_or
id|CCSCBDIR
)paren
)paren
op_eq
(paren
id|CCARREN
op_or
id|CCSCBEN
op_or
id|CCSCBDIR
)paren
)paren
(brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CCSCBCTL
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|CCSCBCTL
)paren
op_amp
op_complement
(paren
id|CCARREN
op_or
id|CCSCBEN
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|CCSCBCTL
)paren
op_amp
(paren
id|CCARREN
op_or
id|CCSCBEN
)paren
)paren
op_ne
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Determine sequencer&squot;s position in the qinfifo. */
id|qintail
op_assign
id|AHD_QIN_WRAP
c_func
(paren
id|ahd-&gt;qinfifonext
)paren
suffix:semicolon
id|qinstart
op_assign
id|ahd_get_snscb_qoff
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|qinpos
op_assign
id|AHD_QIN_WRAP
c_func
(paren
id|qinstart
)paren
suffix:semicolon
id|found
op_assign
l_int|0
suffix:semicolon
id|prev_scb
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|action
op_eq
id|SEARCH_PRINT
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;qinstart = %d qinfifonext = %d&bslash;nQINFIFO:&quot;
comma
id|qinstart
comma
id|ahd-&gt;qinfifonext
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Start with an empty queue.  Entries that are not chosen&n;&t; * for removal will be re-added to the queue as we go.&n;&t; */
id|ahd-&gt;qinfifonext
op_assign
id|qinstart
suffix:semicolon
id|busaddr
op_assign
id|ahd_le32toh
c_func
(paren
id|ahd-&gt;next_queued_hscb-&gt;hscb_busaddr
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|NEXT_QUEUED_SCB_ADDR
op_plus
l_int|0
comma
id|busaddr
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|NEXT_QUEUED_SCB_ADDR
op_plus
l_int|1
comma
(paren
id|busaddr
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|NEXT_QUEUED_SCB_ADDR
op_plus
l_int|2
comma
(paren
id|busaddr
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|NEXT_QUEUED_SCB_ADDR
op_plus
l_int|3
comma
(paren
id|busaddr
op_rshift
l_int|24
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
r_while
c_loop
(paren
id|qinpos
op_ne
id|qintail
)paren
(brace
id|scb
op_assign
id|ahd_lookup_scb
c_func
(paren
id|ahd
comma
id|ahd-&gt;qinfifo
(braket
id|qinpos
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;qinpos = %d, SCB index = %d&bslash;n&quot;
comma
id|qinpos
comma
id|ahd-&gt;qinfifo
(braket
id|qinpos
)braket
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;Loop 1&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ahd_match_scb
c_func
(paren
id|ahd
comma
id|scb
comma
id|target
comma
id|channel
comma
id|lun
comma
id|tag
comma
id|role
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We found an scb that needs to be acted on.&n;&t;&t;&t; */
id|found
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|action
)paren
(brace
r_case
id|SEARCH_COMPLETE
suffix:colon
(brace
id|cam_status
id|ostat
suffix:semicolon
id|cam_status
id|cstat
suffix:semicolon
id|ostat
op_assign
id|ahd_get_transaction_status
c_func
(paren
id|scb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ostat
op_eq
id|CAM_REQ_INPROG
)paren
id|ahd_set_transaction_status
c_func
(paren
id|scb
comma
id|status
)paren
suffix:semicolon
id|cstat
op_assign
id|ahd_get_transaction_status
c_func
(paren
id|scb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cstat
op_ne
id|CAM_REQ_CMP
)paren
id|ahd_freeze_scb
c_func
(paren
id|scb
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_ACTIVE
)paren
op_eq
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;Inactive SCB in qinfifo&bslash;n&quot;
)paren
suffix:semicolon
id|ahd_done
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
)brace
r_case
id|SEARCH_REMOVE
suffix:colon
r_break
suffix:semicolon
r_case
id|SEARCH_PRINT
suffix:colon
id|printf
c_func
(paren
l_string|&quot; 0x%x&quot;
comma
id|ahd-&gt;qinfifo
(braket
id|qinpos
)braket
)paren
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_case
id|SEARCH_COUNT
suffix:colon
id|ahd_qinfifo_requeue
c_func
(paren
id|ahd
comma
id|prev_scb
comma
id|scb
)paren
suffix:semicolon
id|prev_scb
op_assign
id|scb
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|ahd_qinfifo_requeue
c_func
(paren
id|ahd
comma
id|prev_scb
comma
id|scb
)paren
suffix:semicolon
id|prev_scb
op_assign
id|scb
suffix:semicolon
)brace
id|qinpos
op_assign
id|AHD_QIN_WRAP
c_func
(paren
id|qinpos
op_plus
l_int|1
)paren
suffix:semicolon
)brace
id|ahd_set_hnscb_qoff
c_func
(paren
id|ahd
comma
id|ahd-&gt;qinfifonext
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action
op_eq
id|SEARCH_PRINT
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;nWAITING_TID_QUEUES:&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Search waiting for selection lists.  We traverse the&n;&t; * list of &quot;their ids&quot; waiting for selection and, if&n;&t; * appropriate, traverse the SCBs of each &quot;their id&quot;&n;&t; * looking for matches.&n;&t; */
id|savedscbptr
op_assign
id|ahd_get_scbptr
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|tid_next
op_assign
id|ahd_inw
c_func
(paren
id|ahd
comma
id|WAITING_TID_HEAD
)paren
suffix:semicolon
id|tid_prev
op_assign
id|SCB_LIST_NULL
suffix:semicolon
id|targets
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|scbid
op_assign
id|tid_next
suffix:semicolon
op_logical_neg
id|SCBID_IS_NULL
c_func
(paren
id|scbid
)paren
suffix:semicolon
id|scbid
op_assign
id|tid_next
)paren
(brace
id|u_int
id|tid_head
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We limit based on the number of SCBs since&n;&t;&t; * MK_MESSAGE SCBs are not in the per-tid lists.&n;&t;&t; */
id|targets
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|targets
OG
id|AHD_SCB_MAX
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;TID LIST LOOP&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scbid
op_ge
id|ahd-&gt;scb_data.numscbs
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: Waiting TID List inconsistency. &quot;
l_string|&quot;SCB index == 0x%x, yet numscbs == 0x%x.&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|scbid
comma
id|ahd-&gt;scb_data.numscbs
)paren
suffix:semicolon
id|ahd_dump_card_state
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;for safety&quot;
)paren
suffix:semicolon
)brace
id|scb
op_assign
id|ahd_lookup_scb
c_func
(paren
id|ahd
comma
id|scbid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: SCB = 0x%x Not Active!&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|scbid
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;Waiting TID List traversal&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|ahd_set_scbptr
c_func
(paren
id|ahd
comma
id|scbid
)paren
suffix:semicolon
id|tid_next
op_assign
id|ahd_inw_scbram
c_func
(paren
id|ahd
comma
id|SCB_NEXT2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahd_match_scb
c_func
(paren
id|ahd
comma
id|scb
comma
id|target
comma
id|channel
comma
id|CAM_LUN_WILDCARD
comma
id|SCB_LIST_NULL
comma
id|ROLE_UNKNOWN
)paren
op_eq
l_int|0
)paren
(brace
id|tid_prev
op_assign
id|scbid
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * We found a list of scbs that needs to be searched.&n;&t;&t; */
r_if
c_cond
(paren
id|action
op_eq
id|SEARCH_PRINT
)paren
id|printf
c_func
(paren
l_string|&quot;       %d ( &quot;
comma
id|SCB_GET_TARGET
c_func
(paren
id|ahd
comma
id|scb
)paren
)paren
suffix:semicolon
id|tid_head
op_assign
id|scbid
suffix:semicolon
id|found
op_add_assign
id|ahd_search_scb_list
c_func
(paren
id|ahd
comma
id|target
comma
id|channel
comma
id|lun
comma
id|tag
comma
id|role
comma
id|status
comma
id|action
comma
op_amp
id|tid_head
comma
id|SCB_GET_TARGET
c_func
(paren
id|ahd
comma
id|scb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tid_head
op_ne
id|scbid
)paren
id|ahd_stitch_tid_list
c_func
(paren
id|ahd
comma
id|tid_prev
comma
id|tid_head
comma
id|tid_next
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SCBID_IS_NULL
c_func
(paren
id|tid_head
)paren
)paren
id|tid_prev
op_assign
id|tid_head
suffix:semicolon
r_if
c_cond
(paren
id|action
op_eq
id|SEARCH_PRINT
)paren
id|printf
c_func
(paren
l_string|&quot;)&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|ahd_set_scbptr
c_func
(paren
id|ahd
comma
id|savedscbptr
)paren
suffix:semicolon
id|ahd_restore_modes
c_func
(paren
id|ahd
comma
id|saved_modes
)paren
suffix:semicolon
r_return
(paren
id|found
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|ahd_search_scb_list
id|ahd_search_scb_list
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_int
id|target
comma
r_char
id|channel
comma
r_int
id|lun
comma
id|u_int
id|tag
comma
id|role_t
id|role
comma
r_uint32
id|status
comma
id|ahd_search_action
id|action
comma
id|u_int
op_star
id|list_head
comma
id|u_int
id|tid
)paren
(brace
r_struct
id|scb
op_star
id|scb
suffix:semicolon
id|u_int
id|scbid
suffix:semicolon
id|u_int
id|next
suffix:semicolon
id|u_int
id|prev
suffix:semicolon
r_int
id|found
suffix:semicolon
id|AHD_ASSERT_MODES
c_func
(paren
id|ahd
comma
id|AHD_MODE_CCHAN_MSK
comma
id|AHD_MODE_CCHAN_MSK
)paren
suffix:semicolon
id|found
op_assign
l_int|0
suffix:semicolon
id|prev
op_assign
id|SCB_LIST_NULL
suffix:semicolon
id|next
op_assign
op_star
id|list_head
suffix:semicolon
r_for
c_loop
(paren
id|scbid
op_assign
id|next
suffix:semicolon
op_logical_neg
id|SCBID_IS_NULL
c_func
(paren
id|scbid
)paren
suffix:semicolon
id|scbid
op_assign
id|next
)paren
(brace
r_if
c_cond
(paren
id|scbid
op_ge
id|ahd-&gt;scb_data.numscbs
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s:SCB List inconsistency. &quot;
l_string|&quot;SCB == 0x%x, yet numscbs == 0x%x.&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|scbid
comma
id|ahd-&gt;scb_data.numscbs
)paren
suffix:semicolon
id|ahd_dump_card_state
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;for safety&quot;
)paren
suffix:semicolon
)brace
id|scb
op_assign
id|ahd_lookup_scb
c_func
(paren
id|ahd
comma
id|scbid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scb
op_eq
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: SCB = %d Not Active!&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|scbid
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;Waiting List traversal&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|ahd_set_scbptr
c_func
(paren
id|ahd
comma
id|scbid
)paren
suffix:semicolon
id|next
op_assign
id|ahd_inw_scbram
c_func
(paren
id|ahd
comma
id|SCB_NEXT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahd_match_scb
c_func
(paren
id|ahd
comma
id|scb
comma
id|target
comma
id|channel
comma
id|lun
comma
id|SCB_LIST_NULL
comma
id|role
)paren
op_eq
l_int|0
)paren
(brace
id|prev
op_assign
id|scbid
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|found
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|action
)paren
(brace
r_case
id|SEARCH_COMPLETE
suffix:colon
(brace
id|cam_status
id|ostat
suffix:semicolon
id|cam_status
id|cstat
suffix:semicolon
id|ostat
op_assign
id|ahd_get_transaction_status
c_func
(paren
id|scb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ostat
op_eq
id|CAM_REQ_INPROG
)paren
id|ahd_set_transaction_status
c_func
(paren
id|scb
comma
id|status
)paren
suffix:semicolon
id|cstat
op_assign
id|ahd_get_transaction_status
c_func
(paren
id|scb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cstat
op_ne
id|CAM_REQ_CMP
)paren
id|ahd_freeze_scb
c_func
(paren
id|scb
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_ACTIVE
)paren
op_eq
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;Inactive SCB in Waiting List&bslash;n&quot;
)paren
suffix:semicolon
id|ahd_done
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
)brace
r_case
id|SEARCH_REMOVE
suffix:colon
id|ahd_rem_wscb
c_func
(paren
id|ahd
comma
id|scbid
comma
id|prev
comma
id|next
comma
id|tid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prev
op_eq
id|SCB_LIST_NULL
)paren
op_star
id|list_head
op_assign
id|next
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SEARCH_PRINT
suffix:colon
id|printf
c_func
(paren
l_string|&quot;0x%x &quot;
comma
id|scbid
)paren
suffix:semicolon
r_case
id|SEARCH_COUNT
suffix:colon
id|prev
op_assign
id|scbid
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|found
OG
id|AHD_SCB_MAX
)paren
id|panic
c_func
(paren
l_string|&quot;SCB LIST LOOP&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|action
op_eq
id|SEARCH_COMPLETE
op_logical_or
id|action
op_eq
id|SEARCH_REMOVE
)paren
id|ahd_outw
c_func
(paren
id|ahd
comma
id|CMDS_PENDING
comma
id|ahd_inw
c_func
(paren
id|ahd
comma
id|CMDS_PENDING
)paren
op_minus
id|found
)paren
suffix:semicolon
r_return
(paren
id|found
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahd_stitch_tid_list
id|ahd_stitch_tid_list
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
id|u_int
id|tid_prev
comma
id|u_int
id|tid_cur
comma
id|u_int
id|tid_next
)paren
(brace
id|AHD_ASSERT_MODES
c_func
(paren
id|ahd
comma
id|AHD_MODE_CCHAN_MSK
comma
id|AHD_MODE_CCHAN_MSK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCBID_IS_NULL
c_func
(paren
id|tid_cur
)paren
)paren
(brace
multiline_comment|/* Bypass current TID list */
r_if
c_cond
(paren
id|SCBID_IS_NULL
c_func
(paren
id|tid_prev
)paren
)paren
(brace
id|ahd_outw
c_func
(paren
id|ahd
comma
id|WAITING_TID_HEAD
comma
id|tid_next
)paren
suffix:semicolon
)brace
r_else
(brace
id|ahd_set_scbptr
c_func
(paren
id|ahd
comma
id|tid_prev
)paren
suffix:semicolon
id|ahd_outw
c_func
(paren
id|ahd
comma
id|SCB_NEXT2
comma
id|tid_next
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SCBID_IS_NULL
c_func
(paren
id|tid_next
)paren
)paren
id|ahd_outw
c_func
(paren
id|ahd
comma
id|WAITING_TID_TAIL
comma
id|tid_prev
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Stitch through tid_cur */
r_if
c_cond
(paren
id|SCBID_IS_NULL
c_func
(paren
id|tid_prev
)paren
)paren
(brace
id|ahd_outw
c_func
(paren
id|ahd
comma
id|WAITING_TID_HEAD
comma
id|tid_cur
)paren
suffix:semicolon
)brace
r_else
(brace
id|ahd_set_scbptr
c_func
(paren
id|ahd
comma
id|tid_prev
)paren
suffix:semicolon
id|ahd_outw
c_func
(paren
id|ahd
comma
id|SCB_NEXT2
comma
id|tid_cur
)paren
suffix:semicolon
)brace
id|ahd_set_scbptr
c_func
(paren
id|ahd
comma
id|tid_cur
)paren
suffix:semicolon
id|ahd_outw
c_func
(paren
id|ahd
comma
id|SCB_NEXT2
comma
id|tid_next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCBID_IS_NULL
c_func
(paren
id|tid_next
)paren
)paren
id|ahd_outw
c_func
(paren
id|ahd
comma
id|WAITING_TID_TAIL
comma
id|tid_cur
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Manipulate the waiting for selection list and return the&n; * scb that follows the one that we remove.&n; */
r_static
id|u_int
DECL|function|ahd_rem_wscb
id|ahd_rem_wscb
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
id|u_int
id|scbid
comma
id|u_int
id|prev
comma
id|u_int
id|next
comma
id|u_int
id|tid
)paren
(brace
id|u_int
id|tail_offset
suffix:semicolon
id|AHD_ASSERT_MODES
c_func
(paren
id|ahd
comma
id|AHD_MODE_CCHAN_MSK
comma
id|AHD_MODE_CCHAN_MSK
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SCBID_IS_NULL
c_func
(paren
id|prev
)paren
)paren
(brace
id|ahd_set_scbptr
c_func
(paren
id|ahd
comma
id|prev
)paren
suffix:semicolon
id|ahd_outw
c_func
(paren
id|ahd
comma
id|SCB_NEXT
comma
id|next
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * SCBs that had MK_MESSAGE set in them will not&n;&t; * be queued to the per-target lists, so don&squot;t&n;&t; * blindly clear the tail pointer.&n;&t; */
id|tail_offset
op_assign
id|WAITING_SCB_TAILS
op_plus
(paren
l_int|2
op_star
id|tid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCBID_IS_NULL
c_func
(paren
id|next
)paren
op_logical_and
id|ahd_inw
c_func
(paren
id|ahd
comma
id|tail_offset
)paren
op_eq
id|scbid
)paren
id|ahd_outw
c_func
(paren
id|ahd
comma
id|tail_offset
comma
id|prev
)paren
suffix:semicolon
id|ahd_add_scb_to_free_list
c_func
(paren
id|ahd
comma
id|scbid
)paren
suffix:semicolon
r_return
(paren
id|next
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Add the SCB as selected by SCBPTR onto the on chip list of&n; * free hardware SCBs.  This list is empty/unused if we are not&n; * performing SCB paging.&n; */
r_static
r_void
DECL|function|ahd_add_scb_to_free_list
id|ahd_add_scb_to_free_list
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
id|u_int
id|scbid
)paren
(brace
multiline_comment|/* XXX Need some other mechanism to designate &quot;free&quot;. */
multiline_comment|/*&n;&t; * Invalidate the tag so that our abort&n;&t; * routines don&squot;t think it&squot;s active.&n;&t;ahd_outb(ahd, SCB_TAG, SCB_LIST_NULL);&n;&t; */
)brace
multiline_comment|/******************************** Error Handling ******************************/
multiline_comment|/*&n; * Abort all SCBs that match the given description (target/channel/lun/tag),&n; * setting their status to the passed in status if the status has not already&n; * been modified from CAM_REQ_INPROG.  This routine assumes that the sequencer&n; * is paused before it is called.&n; */
r_int
DECL|function|ahd_abort_scbs
id|ahd_abort_scbs
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_int
id|target
comma
r_char
id|channel
comma
r_int
id|lun
comma
id|u_int
id|tag
comma
id|role_t
id|role
comma
r_uint32
id|status
)paren
(brace
r_struct
id|scb
op_star
id|scbp
suffix:semicolon
r_struct
id|scb
op_star
id|scbp_next
suffix:semicolon
id|u_int
id|active_scb
suffix:semicolon
id|u_int
id|i
comma
id|j
suffix:semicolon
id|u_int
id|maxtarget
suffix:semicolon
id|u_int
id|minlun
suffix:semicolon
id|u_int
id|maxlun
suffix:semicolon
r_int
id|found
suffix:semicolon
id|ahd_mode_state
id|saved_modes
suffix:semicolon
multiline_comment|/* restore these when we&squot;re done */
id|active_scb
op_assign
id|ahd_get_scbptr
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|saved_modes
op_assign
id|ahd_save_modes
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI
comma
id|AHD_MODE_SCSI
)paren
suffix:semicolon
id|found
op_assign
id|ahd_search_qinfifo
c_func
(paren
id|ahd
comma
id|target
comma
id|channel
comma
id|lun
comma
id|SCB_LIST_NULL
comma
id|role
comma
id|CAM_REQUEUE_REQ
comma
id|SEARCH_COMPLETE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Clean out the busy target table for any untagged commands.&n;&t; */
id|i
op_assign
l_int|0
suffix:semicolon
id|maxtarget
op_assign
l_int|16
suffix:semicolon
r_if
c_cond
(paren
id|target
op_ne
id|CAM_TARGET_WILDCARD
)paren
(brace
id|i
op_assign
id|target
suffix:semicolon
r_if
c_cond
(paren
id|channel
op_eq
l_char|&squot;B&squot;
)paren
id|i
op_add_assign
l_int|8
suffix:semicolon
id|maxtarget
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lun
op_eq
id|CAM_LUN_WILDCARD
)paren
(brace
id|minlun
op_assign
l_int|0
suffix:semicolon
id|maxlun
op_assign
id|AHD_NUM_LUNS_NONPKT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lun
op_ge
id|AHD_NUM_LUNS_NONPKT
)paren
(brace
id|minlun
op_assign
id|maxlun
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|minlun
op_assign
id|lun
suffix:semicolon
id|maxlun
op_assign
id|lun
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|role
op_ne
id|ROLE_TARGET
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|maxtarget
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
id|minlun
suffix:semicolon
id|j
OL
id|maxlun
suffix:semicolon
id|j
op_increment
)paren
(brace
id|u_int
id|scbid
suffix:semicolon
id|u_int
id|tcl
suffix:semicolon
id|tcl
op_assign
id|BUILD_TCL_RAW
c_func
(paren
id|i
comma
l_char|&squot;A&squot;
comma
id|j
)paren
suffix:semicolon
id|scbid
op_assign
id|ahd_find_busy_tcl
c_func
(paren
id|ahd
comma
id|tcl
)paren
suffix:semicolon
id|scbp
op_assign
id|ahd_lookup_scb
c_func
(paren
id|ahd
comma
id|scbid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scbp
op_eq
l_int|NULL
op_logical_or
id|ahd_match_scb
c_func
(paren
id|ahd
comma
id|scbp
comma
id|target
comma
id|channel
comma
id|lun
comma
id|tag
comma
id|role
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|ahd_unbusy_tcl
c_func
(paren
id|ahd
comma
id|BUILD_TCL_RAW
c_func
(paren
id|i
comma
l_char|&squot;A&squot;
comma
id|j
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * Don&squot;t abort commands that have already completed,&n;&t; * but haven&squot;t quite made it up to the host yet.&n;&t; */
id|ahd_flush_qoutfifo
c_func
(paren
id|ahd
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Go through the pending CCB list and look for&n;&t; * commands for this target that are still active.&n;&t; * These are other tagged commands that were&n;&t; * disconnected when the reset occurred.&n;&t; */
id|scbp_next
op_assign
id|LIST_FIRST
c_func
(paren
op_amp
id|ahd-&gt;pending_scbs
)paren
suffix:semicolon
r_while
c_loop
(paren
id|scbp_next
op_ne
l_int|NULL
)paren
(brace
id|scbp
op_assign
id|scbp_next
suffix:semicolon
id|scbp_next
op_assign
id|LIST_NEXT
c_func
(paren
id|scbp
comma
id|pending_links
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahd_match_scb
c_func
(paren
id|ahd
comma
id|scbp
comma
id|target
comma
id|channel
comma
id|lun
comma
id|tag
comma
id|role
)paren
)paren
(brace
id|cam_status
id|ostat
suffix:semicolon
id|ostat
op_assign
id|ahd_get_transaction_status
c_func
(paren
id|scbp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ostat
op_eq
id|CAM_REQ_INPROG
)paren
id|ahd_set_transaction_status
c_func
(paren
id|scbp
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahd_get_transaction_status
c_func
(paren
id|scbp
)paren
op_ne
id|CAM_REQ_CMP
)paren
id|ahd_freeze_scb
c_func
(paren
id|scbp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scbp-&gt;flags
op_amp
id|SCB_ACTIVE
)paren
op_eq
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;Inactive SCB on pending list&bslash;n&quot;
)paren
suffix:semicolon
id|ahd_done
c_func
(paren
id|ahd
comma
id|scbp
)paren
suffix:semicolon
id|found
op_increment
suffix:semicolon
)brace
)brace
id|ahd_set_scbptr
c_func
(paren
id|ahd
comma
id|active_scb
)paren
suffix:semicolon
id|ahd_restore_modes
c_func
(paren
id|ahd
comma
id|saved_modes
)paren
suffix:semicolon
id|ahd_platform_abort_scbs
c_func
(paren
id|ahd
comma
id|target
comma
id|channel
comma
id|lun
comma
id|tag
comma
id|role
comma
id|status
)paren
suffix:semicolon
id|ahd-&gt;flags
op_or_assign
id|AHD_UPDATE_PEND_CMDS
suffix:semicolon
r_return
id|found
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahd_reset_current_bus
id|ahd_reset_current_bus
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
r_uint8
id|scsiseq
suffix:semicolon
id|AHD_ASSERT_MODES
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI_MSK
comma
id|AHD_MODE_SCSI_MSK
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SIMODE1
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SIMODE1
)paren
op_amp
op_complement
id|ENSCSIRST
)paren
suffix:semicolon
id|scsiseq
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSISEQ0
)paren
op_amp
op_complement
(paren
id|ENSELO
op_or
id|ENARBO
op_or
id|SCSIRSTO
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCSISEQ0
comma
id|scsiseq
op_or
id|SCSIRSTO
)paren
suffix:semicolon
id|ahd_delay
c_func
(paren
id|AHD_BUSRESET_DELAY
)paren
suffix:semicolon
multiline_comment|/* Turn off the bus reset */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCSISEQ0
comma
id|scsiseq
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;bugs
op_amp
id|AHD_SCSIRST_BUG
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * 2A Razor #474&n;&t;&t; * Certain chip state is not cleared for&n;&t;&t; * SCSI bus resets that we initiate, so&n;&t;&t; * we must reset the chip.&n;&t;&t; */
id|ahd_delay
c_func
(paren
id|AHD_BUSRESET_DELAY
)paren
suffix:semicolon
id|ahd_reset
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_intr_enable
c_func
(paren
id|ahd
comma
multiline_comment|/*enable*/
id|TRUE
)paren
suffix:semicolon
id|AHD_ASSERT_MODES
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI_MSK
comma
id|AHD_MODE_SCSI_MSK
)paren
suffix:semicolon
)brace
id|ahd_clear_intstat
c_func
(paren
id|ahd
)paren
suffix:semicolon
)brace
r_int
DECL|function|ahd_reset_channel
id|ahd_reset_channel
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_char
id|channel
comma
r_int
id|initiate_reset
)paren
(brace
r_struct
id|ahd_devinfo
id|devinfo
suffix:semicolon
id|u_int
id|initiator
suffix:semicolon
id|u_int
id|target
suffix:semicolon
id|u_int
id|max_scsiid
suffix:semicolon
r_int
id|found
suffix:semicolon
id|u_int
id|fifo
suffix:semicolon
id|u_int
id|next_fifo
suffix:semicolon
id|ahd-&gt;pending_device
op_assign
l_int|NULL
suffix:semicolon
id|ahd_compile_devinfo
c_func
(paren
op_amp
id|devinfo
comma
id|CAM_TARGET_WILDCARD
comma
id|CAM_TARGET_WILDCARD
comma
id|CAM_LUN_WILDCARD
comma
id|channel
comma
id|ROLE_UNKNOWN
)paren
suffix:semicolon
id|ahd_pause
c_func
(paren
id|ahd
)paren
suffix:semicolon
multiline_comment|/* Make sure the sequencer is in a safe location. */
id|ahd_clear_critical_section
c_func
(paren
id|ahd
)paren
suffix:semicolon
macro_line|#if AHD_TARGET_MODE
r_if
c_cond
(paren
(paren
id|ahd-&gt;flags
op_amp
id|AHD_TARGETROLE
)paren
op_ne
l_int|0
)paren
(brace
id|ahd_run_tqinfifo
c_func
(paren
id|ahd
comma
multiline_comment|/*paused*/
id|TRUE
)paren
suffix:semicolon
)brace
macro_line|#endif
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI
comma
id|AHD_MODE_SCSI
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Disable selections so no automatic hardware&n;&t; * functions will modify chip state.&n;&t; */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCSISEQ0
comma
l_int|0
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCSISEQ1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Safely shut down our DMA engines.  Always start with&n;&t; * the FIFO that is not currently active (if any are&n;&t; * actively connected).&n;&t; */
id|next_fifo
op_assign
id|fifo
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|DFFSTAT
)paren
op_amp
id|CURRFIFO
suffix:semicolon
r_if
c_cond
(paren
id|next_fifo
OG
id|CURRFIFO_1
)paren
multiline_comment|/* If disconneced, arbitrarily start with FIFO1. */
id|next_fifo
op_assign
id|fifo
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|next_fifo
op_xor_assign
id|CURRFIFO_1
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|next_fifo
comma
id|next_fifo
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|DFCNTRL
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|DFCNTRL
)paren
op_amp
op_complement
(paren
id|SCSIEN
op_or
id|HDMAEN
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|DFCNTRL
)paren
op_amp
id|HDMAENACK
)paren
op_ne
l_int|0
)paren
id|ahd_delay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Set CURRFIFO to the now inactive channel.&n;&t;&t; */
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI
comma
id|AHD_MODE_SCSI
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|DFFSTAT
comma
id|next_fifo
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|next_fifo
op_ne
id|fifo
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Reset the bus if we are initiating this reset&n;&t; */
id|ahd_clear_msg_state
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SIMODE1
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SIMODE1
)paren
op_amp
op_complement
(paren
id|ENBUSFREE
op_or
id|ENSCSIRST
op_or
id|ENBUSFREE
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|initiate_reset
)paren
id|ahd_reset_current_bus
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_clear_intstat
c_func
(paren
id|ahd
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Clean up all the state information for the&n;&t; * pending transactions on this bus.&n;&t; */
id|found
op_assign
id|ahd_abort_scbs
c_func
(paren
id|ahd
comma
id|CAM_TARGET_WILDCARD
comma
id|channel
comma
id|CAM_LUN_WILDCARD
comma
id|SCB_LIST_NULL
comma
id|ROLE_UNKNOWN
comma
id|CAM_SCSI_BUS_RESET
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Cleanup anything left in the FIFOs.&n;&t; */
id|ahd_clear_fifo
c_func
(paren
id|ahd
comma
l_int|0
)paren
suffix:semicolon
id|ahd_clear_fifo
c_func
(paren
id|ahd
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Revert to async/narrow transfers until we renegotiate.&n;&t; */
id|max_scsiid
op_assign
(paren
id|ahd-&gt;features
op_amp
id|AHD_WIDE
)paren
ques
c_cond
l_int|15
suffix:colon
l_int|7
suffix:semicolon
r_for
c_loop
(paren
id|target
op_assign
l_int|0
suffix:semicolon
id|target
op_le
id|max_scsiid
suffix:semicolon
id|target
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ahd-&gt;enabled_targets
(braket
id|target
)braket
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|initiator
op_assign
l_int|0
suffix:semicolon
id|initiator
op_le
id|max_scsiid
suffix:semicolon
id|initiator
op_increment
)paren
(brace
r_struct
id|ahd_devinfo
id|devinfo
suffix:semicolon
id|ahd_compile_devinfo
c_func
(paren
op_amp
id|devinfo
comma
id|target
comma
id|initiator
comma
id|CAM_LUN_WILDCARD
comma
l_char|&squot;A&squot;
comma
id|ROLE_UNKNOWN
)paren
suffix:semicolon
id|ahd_set_width
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
comma
id|MSG_EXT_WDTR_BUS_8_BIT
comma
id|AHD_TRANS_CUR
comma
multiline_comment|/*paused*/
id|TRUE
)paren
suffix:semicolon
id|ahd_set_syncrate
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
comma
multiline_comment|/*period*/
l_int|0
comma
multiline_comment|/*offset*/
l_int|0
comma
multiline_comment|/*ppr_options*/
l_int|0
comma
id|AHD_TRANS_CUR
comma
multiline_comment|/*paused*/
id|TRUE
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef AHD_TARGET_MODE
id|max_scsiid
op_assign
(paren
id|ahd-&gt;features
op_amp
id|AHD_WIDE
)paren
ques
c_cond
l_int|15
suffix:colon
l_int|7
suffix:semicolon
multiline_comment|/*&n;&t; * Send an immediate notify ccb to all target more peripheral&n;&t; * drivers affected by this action.&n;&t; */
r_for
c_loop
(paren
id|target
op_assign
l_int|0
suffix:semicolon
id|target
op_le
id|max_scsiid
suffix:semicolon
id|target
op_increment
)paren
(brace
r_struct
id|ahd_tmode_tstate
op_star
id|tstate
suffix:semicolon
id|u_int
id|lun
suffix:semicolon
id|tstate
op_assign
id|ahd-&gt;enabled_targets
(braket
id|target
)braket
suffix:semicolon
r_if
c_cond
(paren
id|tstate
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|lun
op_assign
l_int|0
suffix:semicolon
id|lun
OL
id|AHD_NUM_LUNS
suffix:semicolon
id|lun
op_increment
)paren
(brace
r_struct
id|ahd_tmode_lstate
op_star
id|lstate
suffix:semicolon
id|lstate
op_assign
id|tstate-&gt;enabled_luns
(braket
id|lun
)braket
suffix:semicolon
r_if
c_cond
(paren
id|lstate
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|ahd_queue_lstate_event
c_func
(paren
id|ahd
comma
id|lstate
comma
id|CAM_TARGET_WILDCARD
comma
id|EVENT_TYPE_BUS_RESET
comma
multiline_comment|/*arg*/
l_int|0
)paren
suffix:semicolon
id|ahd_send_lstate_events
c_func
(paren
id|ahd
comma
id|lstate
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/* Notify the XPT that a bus reset occurred */
id|ahd_send_async
c_func
(paren
id|ahd
comma
id|devinfo.channel
comma
id|CAM_TARGET_WILDCARD
comma
id|CAM_LUN_WILDCARD
comma
id|AC_BUS_RESET
comma
l_int|NULL
)paren
suffix:semicolon
id|ahd_restart
c_func
(paren
id|ahd
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Freeze the SIMQ until our poller can determine that&n;&t; * the bus reset has really gone away.  We set the initial&n;&t; * timer to 0 to have the check performed as soon as possible&n;&t; * from the timer context.&n;&t; */
r_if
c_cond
(paren
(paren
id|ahd-&gt;flags
op_amp
id|AHD_RESET_POLL_ACTIVE
)paren
op_eq
l_int|0
)paren
(brace
id|ahd-&gt;flags
op_or_assign
id|AHD_RESET_POLL_ACTIVE
suffix:semicolon
id|ahd_freeze_simq
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_timer_reset
c_func
(paren
op_amp
id|ahd-&gt;reset_timer
comma
l_int|0
comma
id|ahd_reset_poll
comma
id|ahd
)paren
suffix:semicolon
)brace
r_return
(paren
id|found
)paren
suffix:semicolon
)brace
DECL|macro|AHD_RESET_POLL_US
mdefine_line|#define AHD_RESET_POLL_US 1000
r_static
r_void
DECL|function|ahd_reset_poll
id|ahd_reset_poll
c_func
(paren
r_void
op_star
id|arg
)paren
(brace
r_struct
id|ahd_softc
op_star
id|ahd
suffix:semicolon
id|u_int
id|scsiseq1
suffix:semicolon
id|u_long
id|l
suffix:semicolon
id|u_long
id|s
suffix:semicolon
id|ahd_list_lock
c_func
(paren
op_amp
id|l
)paren
suffix:semicolon
id|ahd
op_assign
id|ahd_find_softc
c_func
(paren
(paren
r_struct
id|ahd_softc
op_star
)paren
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahd
op_eq
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;ahd_reset_poll: Instance %p no longer exists&bslash;n&quot;
comma
id|arg
)paren
suffix:semicolon
id|ahd_list_unlock
c_func
(paren
op_amp
id|l
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ahd_lock
c_func
(paren
id|ahd
comma
op_amp
id|s
)paren
suffix:semicolon
id|ahd_pause
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_update_modes
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI
comma
id|AHD_MODE_SCSI
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|CLRSINT1
comma
id|CLRSCSIRSTI
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SSTAT1
)paren
op_amp
id|SCSIRSTI
)paren
op_ne
l_int|0
)paren
(brace
id|ahd_timer_reset
c_func
(paren
op_amp
id|ahd-&gt;reset_timer
comma
id|AHD_RESET_POLL_US
comma
id|ahd_reset_poll
comma
id|ahd
)paren
suffix:semicolon
id|ahd_unpause
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_unlock
c_func
(paren
id|ahd
comma
op_amp
id|s
)paren
suffix:semicolon
id|ahd_list_unlock
c_func
(paren
op_amp
id|l
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Reset is now low.  Complete chip reinitialization. */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SIMODE1
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SIMODE1
)paren
op_or
id|ENSCSIRST
)paren
suffix:semicolon
id|scsiseq1
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSISEQ_TEMPLATE
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCSISEQ1
comma
id|scsiseq1
op_amp
(paren
id|ENSELI
op_or
id|ENRSELI
op_or
id|ENAUTOATNP
)paren
)paren
suffix:semicolon
id|ahd_unpause
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd-&gt;flags
op_and_assign
op_complement
id|AHD_RESET_POLL_ACTIVE
suffix:semicolon
id|ahd_unlock
c_func
(paren
id|ahd
comma
op_amp
id|s
)paren
suffix:semicolon
id|ahd_release_simq
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_list_unlock
c_func
(paren
op_amp
id|l
)paren
suffix:semicolon
)brace
multiline_comment|/**************************** Statistics Processing ***************************/
r_static
r_void
DECL|function|ahd_stat_timer
id|ahd_stat_timer
c_func
(paren
r_void
op_star
id|arg
)paren
(brace
r_struct
id|ahd_softc
op_star
id|ahd
suffix:semicolon
id|u_long
id|l
suffix:semicolon
id|u_long
id|s
suffix:semicolon
r_int
id|enint_coal
suffix:semicolon
id|ahd_list_lock
c_func
(paren
op_amp
id|l
)paren
suffix:semicolon
id|ahd
op_assign
id|ahd_find_softc
c_func
(paren
(paren
r_struct
id|ahd_softc
op_star
)paren
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahd
op_eq
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;ahd_stat_timer: Instance %p no longer exists&bslash;n&quot;
comma
id|arg
)paren
suffix:semicolon
id|ahd_list_unlock
c_func
(paren
op_amp
id|l
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ahd_lock
c_func
(paren
id|ahd
comma
op_amp
id|s
)paren
suffix:semicolon
id|enint_coal
op_assign
id|ahd-&gt;hs_mailbox
op_amp
id|ENINT_COALESS
suffix:semicolon
r_if
c_cond
(paren
id|ahd-&gt;cmdcmplt_total
OG
id|ahd-&gt;int_coalessing_threshold
)paren
id|enint_coal
op_or_assign
id|ENINT_COALESS
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ahd-&gt;cmdcmplt_total
OL
id|ahd-&gt;int_coalessing_stop_threshold
)paren
id|enint_coal
op_and_assign
op_complement
id|ENINT_COALESS
suffix:semicolon
r_if
c_cond
(paren
id|enint_coal
op_ne
(paren
id|ahd-&gt;hs_mailbox
op_amp
id|ENINT_COALESS
)paren
)paren
(brace
id|ahd_enable_coalessing
c_func
(paren
id|ahd
comma
id|enint_coal
)paren
suffix:semicolon
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_INT_COALESSING
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;%s: Interrupt coalessing &quot;
l_string|&quot;now %sabled. Cmds %d&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
(paren
id|enint_coal
op_amp
id|ENINT_COALESS
)paren
ques
c_cond
l_string|&quot;en&quot;
suffix:colon
l_string|&quot;dis&quot;
comma
id|ahd-&gt;cmdcmplt_total
)paren
suffix:semicolon
macro_line|#endif
)brace
id|ahd-&gt;cmdcmplt_bucket
op_assign
(paren
id|ahd-&gt;cmdcmplt_bucket
op_plus
l_int|1
)paren
op_amp
(paren
id|AHD_STAT_BUCKETS
op_minus
l_int|1
)paren
suffix:semicolon
id|ahd-&gt;cmdcmplt_total
op_sub_assign
id|ahd-&gt;cmdcmplt_counts
(braket
id|ahd-&gt;cmdcmplt_bucket
)braket
suffix:semicolon
id|ahd-&gt;cmdcmplt_counts
(braket
id|ahd-&gt;cmdcmplt_bucket
)braket
op_assign
l_int|0
suffix:semicolon
id|ahd_timer_reset
c_func
(paren
op_amp
id|ahd-&gt;stat_timer
comma
id|AHD_STAT_UPDATE_US
comma
id|ahd_stat_timer
comma
id|ahd
)paren
suffix:semicolon
id|ahd_unlock
c_func
(paren
id|ahd
comma
op_amp
id|s
)paren
suffix:semicolon
id|ahd_list_unlock
c_func
(paren
op_amp
id|l
)paren
suffix:semicolon
)brace
multiline_comment|/****************************** Status Processing *****************************/
r_void
DECL|function|ahd_handle_scb_status
id|ahd_handle_scb_status
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|scb
op_star
id|scb
)paren
(brace
r_if
c_cond
(paren
id|scb-&gt;hscb-&gt;shared_data.istatus.scsi_status
op_ne
l_int|0
)paren
(brace
id|ahd_handle_scsi_status
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
)brace
r_else
(brace
id|ahd_calc_residual
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|ahd_done
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
)brace
)brace
r_void
DECL|function|ahd_handle_scsi_status
id|ahd_handle_scsi_status
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|scb
op_star
id|scb
)paren
(brace
r_struct
id|hardware_scb
op_star
id|hscb
suffix:semicolon
id|u_int
id|qfreeze_cnt
suffix:semicolon
id|ahd_mode_state
id|saved_modes
suffix:semicolon
multiline_comment|/*&n;&t; * The sequencer freezes its select-out queue&n;&t; * anytime a SCSI status error occurs.  We must&n;&t; * handle the error and decrement the QFREEZE count&n;&t; * to allow the sequencer to continue.&n;&t; */
id|hscb
op_assign
id|scb-&gt;hscb
suffix:semicolon
multiline_comment|/* Freeze the queue until the client sees the error. */
id|ahd_pause
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|saved_modes
op_assign
id|ahd_save_modes
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_clear_critical_section
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI
comma
id|AHD_MODE_SCSI
)paren
suffix:semicolon
id|ahd_freeze_devq
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|ahd_freeze_scb
c_func
(paren
id|scb
)paren
suffix:semicolon
id|qfreeze_cnt
op_assign
id|ahd_inw
c_func
(paren
id|ahd
comma
id|QFREEZE_COUNT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qfreeze_cnt
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: Bad status with 0 qfreeze count!&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|qfreeze_cnt
op_decrement
suffix:semicolon
id|ahd_outw
c_func
(paren
id|ahd
comma
id|QFREEZE_COUNT
comma
id|qfreeze_cnt
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|qfreeze_cnt
op_eq
l_int|0
)paren
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SEQ_FLAGS2
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SEQ_FLAGS2
)paren
op_amp
op_complement
id|SELECTOUT_QFROZEN
)paren
suffix:semicolon
id|ahd_unpause
c_func
(paren
id|ahd
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t want to clobber the original sense code */
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_SENSE
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Clear the SCB_SENSE Flag and perform&n;&t;&t; * a normal command completion.&n;&t;&t; */
id|scb-&gt;flags
op_and_assign
op_complement
id|SCB_SENSE
suffix:semicolon
id|ahd_set_transaction_status
c_func
(paren
id|scb
comma
id|CAM_AUTOSENSE_FAIL
)paren
suffix:semicolon
id|ahd_done
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ahd_set_transaction_status
c_func
(paren
id|scb
comma
id|CAM_SCSI_STATUS_ERROR
)paren
suffix:semicolon
id|ahd_set_scsi_status
c_func
(paren
id|scb
comma
id|hscb-&gt;shared_data.istatus.scsi_status
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|hscb-&gt;shared_data.istatus.scsi_status
)paren
(brace
r_case
id|STATUS_PKT_SENSE
suffix:colon
(brace
r_struct
id|scsi_status_iu_header
op_star
id|siu
suffix:semicolon
id|ahd_sync_sense
c_func
(paren
id|ahd
comma
id|scb
comma
id|BUS_DMASYNC_POSTREAD
)paren
suffix:semicolon
id|siu
op_assign
(paren
r_struct
id|scsi_status_iu_header
op_star
)paren
id|scb-&gt;sense_data
suffix:semicolon
id|ahd_set_scsi_status
c_func
(paren
id|scb
comma
id|siu-&gt;status
)paren
suffix:semicolon
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_SENSE
)paren
op_ne
l_int|0
)paren
(brace
id|ahd_print_path
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;SCB 0x%x Received PKT Status of 0x%x&bslash;n&quot;
comma
id|SCB_GET_TAG
c_func
(paren
id|scb
)paren
comma
id|siu-&gt;status
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tflags = 0x%x, sense len = 0x%x, &quot;
l_string|&quot;pktfail = 0x%x&bslash;n&quot;
comma
id|siu-&gt;flags
comma
id|scsi_4btoul
c_func
(paren
id|siu-&gt;sense_length
)paren
comma
id|scsi_4btoul
c_func
(paren
id|siu-&gt;pkt_failures_length
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
(paren
id|siu-&gt;flags
op_amp
id|SIU_RSPVALID
)paren
op_ne
l_int|0
)paren
(brace
id|ahd_print_path
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scsi_4btoul
c_func
(paren
id|siu-&gt;pkt_failures_length
)paren
OL
l_int|4
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Unable to parse pkt_failures&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_switch
c_cond
(paren
id|SIU_PKTFAIL_CODE
c_func
(paren
id|siu
)paren
)paren
(brace
r_case
id|SIU_PFC_NONE
suffix:colon
id|printf
c_func
(paren
l_string|&quot;No packet failure found&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIU_PFC_CIU_FIELDS_INVALID
suffix:colon
id|printf
c_func
(paren
l_string|&quot;Invalid Command IU Field&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIU_PFC_TMF_NOT_SUPPORTED
suffix:colon
id|printf
c_func
(paren
l_string|&quot;TMF not supportd&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIU_PFC_TMF_FAILED
suffix:colon
id|printf
c_func
(paren
l_string|&quot;TMF failed&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIU_PFC_INVALID_TYPE_CODE
suffix:colon
id|printf
c_func
(paren
l_string|&quot;Invalid L_Q Type code&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIU_PFC_ILLEGAL_REQUEST
suffix:colon
id|printf
c_func
(paren
l_string|&quot;Illegal request&bslash;n&quot;
)paren
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|siu-&gt;status
op_eq
id|SCSI_STATUS_OK
)paren
id|ahd_set_transaction_status
c_func
(paren
id|scb
comma
id|CAM_REQ_CMP_ERR
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|siu-&gt;flags
op_amp
id|SIU_SNSVALID
)paren
op_ne
l_int|0
)paren
(brace
id|scb-&gt;flags
op_or_assign
id|SCB_PKT_SENSE
suffix:semicolon
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_SENSE
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;Sense data available&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
id|ahd_done
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|SCSI_STATUS_CMD_TERMINATED
suffix:colon
r_case
id|SCSI_STATUS_CHECK_COND
suffix:colon
(brace
r_struct
id|ahd_devinfo
id|devinfo
suffix:semicolon
r_struct
id|ahd_dma_seg
op_star
id|sg
suffix:semicolon
r_struct
id|scsi_sense
op_star
id|sc
suffix:semicolon
r_struct
id|ahd_initiator_tinfo
op_star
id|targ_info
suffix:semicolon
r_struct
id|ahd_tmode_tstate
op_star
id|tstate
suffix:semicolon
r_struct
id|ahd_transinfo
op_star
id|tinfo
suffix:semicolon
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_SENSE
)paren
(brace
id|ahd_print_path
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;SCB %d: requests Check Status&bslash;n&quot;
comma
id|SCB_GET_TAG
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|ahd_perform_autosense
c_func
(paren
id|scb
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|ahd_compile_devinfo
c_func
(paren
op_amp
id|devinfo
comma
id|SCB_GET_OUR_ID
c_func
(paren
id|scb
)paren
comma
id|SCB_GET_TARGET
c_func
(paren
id|ahd
comma
id|scb
)paren
comma
id|SCB_GET_LUN
c_func
(paren
id|scb
)paren
comma
id|SCB_GET_CHANNEL
c_func
(paren
id|ahd
comma
id|scb
)paren
comma
id|ROLE_INITIATOR
)paren
suffix:semicolon
id|targ_info
op_assign
id|ahd_fetch_transinfo
c_func
(paren
id|ahd
comma
id|devinfo.channel
comma
id|devinfo.our_scsiid
comma
id|devinfo.target
comma
op_amp
id|tstate
)paren
suffix:semicolon
id|tinfo
op_assign
op_amp
id|targ_info-&gt;curr
suffix:semicolon
id|sg
op_assign
id|scb-&gt;sg_list
suffix:semicolon
id|sc
op_assign
(paren
r_struct
id|scsi_sense
op_star
)paren
id|hscb-&gt;shared_data.idata.cdb
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Save off the residual if there is one.&n;&t;&t; */
id|ahd_update_residual
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_SENSE
)paren
(brace
id|ahd_print_path
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Sending Sense&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|scb-&gt;sg_count
op_assign
l_int|0
suffix:semicolon
id|sg
op_assign
id|ahd_sg_setup
c_func
(paren
id|ahd
comma
id|scb
comma
id|sg
comma
id|ahd_get_sense_bufaddr
c_func
(paren
id|ahd
comma
id|scb
)paren
comma
id|ahd_get_sense_bufsize
c_func
(paren
id|ahd
comma
id|scb
)paren
comma
multiline_comment|/*last*/
id|TRUE
)paren
suffix:semicolon
id|sc-&gt;opcode
op_assign
id|REQUEST_SENSE
suffix:semicolon
id|sc-&gt;byte2
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tinfo-&gt;protocol_version
op_le
id|SCSI_REV_2
op_logical_and
id|SCB_GET_LUN
c_func
(paren
id|scb
)paren
OL
l_int|8
)paren
id|sc-&gt;byte2
op_assign
id|SCB_GET_LUN
c_func
(paren
id|scb
)paren
op_lshift
l_int|5
suffix:semicolon
id|sc-&gt;unused
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|sc-&gt;unused
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|sc-&gt;length
op_assign
id|ahd_get_sense_bufsize
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|sc-&gt;control
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We can&squot;t allow the target to disconnect.&n;&t;&t; * This will be an untagged transaction and&n;&t;&t; * having the target disconnect will make this&n;&t;&t; * transaction indestinguishable from outstanding&n;&t;&t; * tagged transactions.&n;&t;&t; */
id|hscb-&gt;control
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This request sense could be because the&n;&t;&t; * the device lost power or in some other&n;&t;&t; * way has lost our transfer negotiations.&n;&t;&t; * Renegotiate if appropriate.  Unit attention&n;&t;&t; * errors will be reported before any data&n;&t;&t; * phases occur.&n;&t;&t; */
r_if
c_cond
(paren
id|ahd_get_residual
c_func
(paren
id|scb
)paren
op_eq
id|ahd_get_transfer_length
c_func
(paren
id|scb
)paren
)paren
(brace
id|ahd_update_neg_request
c_func
(paren
id|ahd
comma
op_amp
id|devinfo
comma
id|tstate
comma
id|targ_info
comma
id|AHD_NEG_IF_NON_ASYNC
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tstate-&gt;auto_negotiate
op_amp
id|devinfo.target_mask
)paren
(brace
id|hscb-&gt;control
op_or_assign
id|MK_MESSAGE
suffix:semicolon
id|scb-&gt;flags
op_and_assign
op_complement
(paren
id|SCB_NEGOTIATE
op_or
id|SCB_ABORT
op_or
id|SCB_DEVICE_RESET
)paren
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_AUTO_NEGOTIATE
suffix:semicolon
)brace
id|hscb-&gt;cdb_len
op_assign
r_sizeof
(paren
op_star
id|sc
)paren
suffix:semicolon
id|ahd_setup_data_scb
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|scb-&gt;flags
op_or_assign
id|SCB_SENSE
suffix:semicolon
id|ahd_queue_scb
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Ensure we have enough time to actually&n;&t;&t; * retrieve the sense.&n;&t;&t; */
id|ahd_scb_timer_reset
c_func
(paren
id|scb
comma
l_int|5
op_star
l_int|1000000
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|SCSI_STATUS_OK
suffix:colon
id|printf
c_func
(paren
l_string|&quot;%s: Interrupted for staus of 0???&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_default
suffix:colon
id|ahd_done
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Calculate the residual for a just completed SCB.&n; */
r_void
DECL|function|ahd_calc_residual
id|ahd_calc_residual
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|scb
op_star
id|scb
)paren
(brace
r_struct
id|hardware_scb
op_star
id|hscb
suffix:semicolon
r_struct
id|initiator_status
op_star
id|spkt
suffix:semicolon
r_uint32
id|sgptr
suffix:semicolon
r_uint32
id|resid_sgptr
suffix:semicolon
r_uint32
id|resid
suffix:semicolon
multiline_comment|/*&n;&t; * 5 cases.&n;&t; * 1) No residual.&n;&t; *    SG_STATUS_VALID clear in sgptr.&n;&t; * 2) Transferless command&n;&t; * 3) Never performed any transfers.&n;&t; *    sgptr has SG_FULL_RESID set.&n;&t; * 4) No residual but target did not&n;&t; *    save data pointers after the&n;&t; *    last transfer, so sgptr was&n;&t; *    never updated.&n;&t; * 5) We have a partial residual.&n;&t; *    Use residual_sgptr to determine&n;&t; *    where we are.&n;&t; */
id|hscb
op_assign
id|scb-&gt;hscb
suffix:semicolon
id|sgptr
op_assign
id|ahd_le32toh
c_func
(paren
id|hscb-&gt;sgptr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sgptr
op_amp
id|SG_STATUS_VALID
)paren
op_eq
l_int|0
)paren
multiline_comment|/* Case 1 */
r_return
suffix:semicolon
id|sgptr
op_and_assign
op_complement
id|SG_STATUS_VALID
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sgptr
op_amp
id|SG_LIST_NULL
)paren
op_ne
l_int|0
)paren
multiline_comment|/* Case 2 */
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Residual fields are the same in both&n;&t; * target and initiator status packets,&n;&t; * so we can always use the initiator fields&n;&t; * regardless of the role for this SCB.&n;&t; */
id|spkt
op_assign
op_amp
id|hscb-&gt;shared_data.istatus
suffix:semicolon
id|resid_sgptr
op_assign
id|ahd_le32toh
c_func
(paren
id|spkt-&gt;residual_sgptr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sgptr
op_amp
id|SG_FULL_RESID
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Case 3 */
id|resid
op_assign
id|ahd_get_transfer_length
c_func
(paren
id|scb
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|resid_sgptr
op_amp
id|SG_LIST_NULL
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Case 4 */
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|resid_sgptr
op_amp
id|SG_OVERRUN_RESID
)paren
op_ne
l_int|0
)paren
(brace
id|ahd_print_path
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;data overrun detected Tag == 0x%x.&bslash;n&quot;
comma
id|SCB_GET_TAG
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
id|ahd_freeze_devq
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|ahd_set_transaction_status
c_func
(paren
id|scb
comma
id|CAM_DATA_RUN_ERR
)paren
suffix:semicolon
id|ahd_freeze_scb
c_func
(paren
id|scb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|resid_sgptr
op_amp
op_complement
id|SG_PTR_MASK
)paren
op_ne
l_int|0
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Bogus resid sgptr value 0x%x&bslash;n&quot;
comma
id|resid_sgptr
)paren
suffix:semicolon
multiline_comment|/* NOTREACHED */
)brace
r_else
(brace
r_struct
id|ahd_dma_seg
op_star
id|sg
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Remainder of the SG where the transfer&n;&t;&t; * stopped.  &n;&t;&t; */
id|resid
op_assign
id|ahd_le32toh
c_func
(paren
id|spkt-&gt;residual_datacnt
)paren
op_amp
id|AHD_SG_LEN_MASK
suffix:semicolon
id|sg
op_assign
id|ahd_sg_bus_to_virt
c_func
(paren
id|ahd
comma
id|scb
comma
id|resid_sgptr
op_amp
id|SG_PTR_MASK
)paren
suffix:semicolon
multiline_comment|/* The residual sg_ptr always points to the next sg */
id|sg
op_decrement
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Add up the contents of all residual&n;&t;&t; * SG segments that are after the SG where&n;&t;&t; * the transfer stopped.&n;&t;&t; */
r_while
c_loop
(paren
(paren
id|ahd_le32toh
c_func
(paren
id|sg-&gt;len
)paren
op_amp
id|AHD_DMA_LAST_SEG
)paren
op_eq
l_int|0
)paren
(brace
id|sg
op_increment
suffix:semicolon
id|resid
op_add_assign
id|ahd_le32toh
c_func
(paren
id|sg-&gt;len
)paren
op_amp
id|AHD_SG_LEN_MASK
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|scb-&gt;flags
op_amp
id|SCB_SENSE
)paren
op_eq
l_int|0
)paren
id|ahd_set_residual
c_func
(paren
id|scb
comma
id|resid
)paren
suffix:semicolon
r_else
id|ahd_set_sense_residual
c_func
(paren
id|scb
comma
id|resid
)paren
suffix:semicolon
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_MISC
)paren
op_ne
l_int|0
)paren
(brace
id|ahd_print_path
c_func
(paren
id|ahd
comma
id|scb
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Handled %sResidual of %d bytes&bslash;n&quot;
comma
(paren
id|scb-&gt;flags
op_amp
id|SCB_SENSE
)paren
ques
c_cond
l_string|&quot;Sense &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|resid
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/******************************* Target Mode **********************************/
macro_line|#ifdef AHD_TARGET_MODE
multiline_comment|/*&n; * Add a target mode event to this lun&squot;s queue&n; */
r_static
r_void
DECL|function|ahd_queue_lstate_event
id|ahd_queue_lstate_event
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_tmode_lstate
op_star
id|lstate
comma
id|u_int
id|initiator_id
comma
id|u_int
id|event_type
comma
id|u_int
id|event_arg
)paren
(brace
r_struct
id|ahd_tmode_event
op_star
id|event
suffix:semicolon
r_int
id|pending
suffix:semicolon
id|xpt_freeze_devq
c_func
(paren
id|lstate-&gt;path
comma
multiline_comment|/*count*/
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lstate-&gt;event_w_idx
op_ge
id|lstate-&gt;event_r_idx
)paren
id|pending
op_assign
id|lstate-&gt;event_w_idx
op_minus
id|lstate-&gt;event_r_idx
suffix:semicolon
r_else
id|pending
op_assign
id|AHD_TMODE_EVENT_BUFFER_SIZE
op_plus
l_int|1
op_minus
(paren
id|lstate-&gt;event_r_idx
op_minus
id|lstate-&gt;event_w_idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|event_type
op_eq
id|EVENT_TYPE_BUS_RESET
op_logical_or
id|event_type
op_eq
id|MSG_BUS_DEV_RESET
)paren
(brace
multiline_comment|/*&n;&t;&t; * Any earlier events are irrelevant, so reset our buffer.&n;&t;&t; * This has the effect of allowing us to deal with reset&n;&t;&t; * floods (an external device holding down the reset line)&n;&t;&t; * without losing the event that is really interesting.&n;&t;&t; */
id|lstate-&gt;event_r_idx
op_assign
l_int|0
suffix:semicolon
id|lstate-&gt;event_w_idx
op_assign
l_int|0
suffix:semicolon
id|xpt_release_devq
c_func
(paren
id|lstate-&gt;path
comma
id|pending
comma
multiline_comment|/*runqueue*/
id|FALSE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pending
op_eq
id|AHD_TMODE_EVENT_BUFFER_SIZE
)paren
(brace
id|xpt_print_path
c_func
(paren
id|lstate-&gt;path
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;immediate event %x:%x lost&bslash;n&quot;
comma
id|lstate-&gt;event_buffer
(braket
id|lstate-&gt;event_r_idx
)braket
dot
id|event_type
comma
id|lstate-&gt;event_buffer
(braket
id|lstate-&gt;event_r_idx
)braket
dot
id|event_arg
)paren
suffix:semicolon
id|lstate-&gt;event_r_idx
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|lstate-&gt;event_r_idx
op_eq
id|AHD_TMODE_EVENT_BUFFER_SIZE
)paren
id|lstate-&gt;event_r_idx
op_assign
l_int|0
suffix:semicolon
id|xpt_release_devq
c_func
(paren
id|lstate-&gt;path
comma
multiline_comment|/*count*/
l_int|1
comma
multiline_comment|/*runqueue*/
id|FALSE
)paren
suffix:semicolon
)brace
id|event
op_assign
op_amp
id|lstate-&gt;event_buffer
(braket
id|lstate-&gt;event_w_idx
)braket
suffix:semicolon
id|event-&gt;initiator_id
op_assign
id|initiator_id
suffix:semicolon
id|event-&gt;event_type
op_assign
id|event_type
suffix:semicolon
id|event-&gt;event_arg
op_assign
id|event_arg
suffix:semicolon
id|lstate-&gt;event_w_idx
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|lstate-&gt;event_w_idx
op_eq
id|AHD_TMODE_EVENT_BUFFER_SIZE
)paren
id|lstate-&gt;event_w_idx
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Send any target mode events queued up waiting&n; * for immediate notify resources.&n; */
r_void
DECL|function|ahd_send_lstate_events
id|ahd_send_lstate_events
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|ahd_tmode_lstate
op_star
id|lstate
)paren
(brace
r_struct
id|ccb_hdr
op_star
id|ccbh
suffix:semicolon
r_struct
id|ccb_immed_notify
op_star
id|inot
suffix:semicolon
r_while
c_loop
(paren
id|lstate-&gt;event_r_idx
op_ne
id|lstate-&gt;event_w_idx
op_logical_and
(paren
id|ccbh
op_assign
id|SLIST_FIRST
c_func
(paren
op_amp
id|lstate-&gt;immed_notifies
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_struct
id|ahd_tmode_event
op_star
id|event
suffix:semicolon
id|event
op_assign
op_amp
id|lstate-&gt;event_buffer
(braket
id|lstate-&gt;event_r_idx
)braket
suffix:semicolon
id|SLIST_REMOVE_HEAD
c_func
(paren
op_amp
id|lstate-&gt;immed_notifies
comma
id|sim_links.sle
)paren
suffix:semicolon
id|inot
op_assign
(paren
r_struct
id|ccb_immed_notify
op_star
)paren
id|ccbh
suffix:semicolon
r_switch
c_cond
(paren
id|event-&gt;event_type
)paren
(brace
r_case
id|EVENT_TYPE_BUS_RESET
suffix:colon
id|ccbh-&gt;status
op_assign
id|CAM_SCSI_BUS_RESET
op_or
id|CAM_DEV_QFRZN
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ccbh-&gt;status
op_assign
id|CAM_MESSAGE_RECV
op_or
id|CAM_DEV_QFRZN
suffix:semicolon
id|inot-&gt;message_args
(braket
l_int|0
)braket
op_assign
id|event-&gt;event_type
suffix:semicolon
id|inot-&gt;message_args
(braket
l_int|1
)braket
op_assign
id|event-&gt;event_arg
suffix:semicolon
r_break
suffix:semicolon
)brace
id|inot-&gt;initiator_id
op_assign
id|event-&gt;initiator_id
suffix:semicolon
id|inot-&gt;sense_len
op_assign
l_int|0
suffix:semicolon
id|xpt_done
c_func
(paren
(paren
r_union
id|ccb
op_star
)paren
id|inot
)paren
suffix:semicolon
id|lstate-&gt;event_r_idx
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|lstate-&gt;event_r_idx
op_eq
id|AHD_TMODE_EVENT_BUFFER_SIZE
)paren
id|lstate-&gt;event_r_idx
op_assign
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/******************** Sequencer Program Patching/Download *********************/
macro_line|#ifdef AHD_DUMP_SEQ
r_void
DECL|function|ahd_dumpseq
id|ahd_dumpseq
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|max_prog
suffix:semicolon
id|max_prog
op_assign
l_int|2048
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SEQCTL0
comma
id|PERRORDIS
op_or
id|FAILDIS
op_or
id|FASTMODE
op_or
id|LOADRAM
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|PRGMCNT
comma
l_int|0
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|PRGMCNT
op_plus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max_prog
suffix:semicolon
id|i
op_increment
)paren
(brace
r_uint8
id|ins_bytes
(braket
l_int|4
)braket
suffix:semicolon
id|ahd_insb
c_func
(paren
id|ahd
comma
id|SEQRAM
comma
id|ins_bytes
comma
l_int|4
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;0x%08x&bslash;n&quot;
comma
id|ins_bytes
(braket
l_int|0
)braket
op_lshift
l_int|24
op_or
id|ins_bytes
(braket
l_int|1
)braket
op_lshift
l_int|16
op_or
id|ins_bytes
(braket
l_int|2
)braket
op_lshift
l_int|8
op_or
id|ins_bytes
(braket
l_int|3
)braket
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
r_static
r_void
DECL|function|ahd_loadseq
id|ahd_loadseq
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
r_struct
id|cs
id|cs_table
(braket
id|num_critical_sections
)braket
suffix:semicolon
id|u_int
id|begin_set
(braket
id|num_critical_sections
)braket
suffix:semicolon
id|u_int
id|end_set
(braket
id|num_critical_sections
)braket
suffix:semicolon
r_struct
id|patch
op_star
id|cur_patch
suffix:semicolon
id|u_int
id|cs_count
suffix:semicolon
id|u_int
id|cur_cs
suffix:semicolon
id|u_int
id|i
suffix:semicolon
r_int
id|downloaded
suffix:semicolon
id|u_int
id|skip_addr
suffix:semicolon
id|u_int
id|sg_prefetch_cnt
suffix:semicolon
id|u_int
id|sg_prefetch_cnt_limit
suffix:semicolon
id|u_int
id|sg_prefetch_align
suffix:semicolon
id|u_int
id|sg_size
suffix:semicolon
r_uint8
id|download_consts
(braket
id|DOWNLOAD_CONST_COUNT
)braket
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
)paren
id|printf
c_func
(paren
l_string|&quot;%s: Downloading Sequencer Program...&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
)paren
suffix:semicolon
macro_line|#if DOWNLOAD_CONST_COUNT != 7
macro_line|#error &quot;Download Const Mismatch&quot;
macro_line|#endif
multiline_comment|/*&n;&t; * Start out with 0 critical sections&n;&t; * that apply to this firmware load.&n;&t; */
id|cs_count
op_assign
l_int|0
suffix:semicolon
id|cur_cs
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|begin_set
comma
l_int|0
comma
r_sizeof
(paren
id|begin_set
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|end_set
comma
l_int|0
comma
r_sizeof
(paren
id|end_set
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Setup downloadable constant table.&n;&t; * &n;&t; * The computation for the S/G prefetch variables is&n;&t; * a bit complicated.  We would like to always fetch&n;&t; * in terms of cachelined sized increments.  However,&n;&t; * if the cacheline is not an even multiple of the&n;&t; * SG element size or is larger than our SG RAM, using&n;&t; * just the cache size might leave us with only a portion&n;&t; * of an SG element at the tail of a prefetch.  If the&n;&t; * cacheline is larger than our S/G prefetch buffer less&n;&t; * the size of an SG element, we may round down to a cacheline&n;&t; * that doesn&squot;t contain any or all of the S/G of interest&n;&t; * within the bounds of our S/G ram.  Provide variables to&n;&t; * the sequencer that will allow it to handle these edge&n;&t; * cases.&n;&t; */
multiline_comment|/* Start by aligning to the nearest cacheline. */
id|sg_prefetch_align
op_assign
id|ahd-&gt;pci_cachesize
suffix:semicolon
r_if
c_cond
(paren
id|sg_prefetch_align
op_eq
l_int|0
)paren
id|sg_prefetch_cnt
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* Round down to the nearest power of 2. */
r_while
c_loop
(paren
id|powerof2
c_func
(paren
id|sg_prefetch_align
)paren
op_eq
l_int|0
)paren
id|sg_prefetch_align
op_decrement
suffix:semicolon
multiline_comment|/*&n;&t; * If the cacheline boundary is greater than half our prefetch RAM&n;&t; * we risk not being able to fetch even a single complete S/G&n;&t; * segment if we align to that boundary.&n;&t; */
r_if
c_cond
(paren
id|sg_prefetch_align
OG
id|CCSGADDR_MAX
op_div
l_int|2
)paren
id|sg_prefetch_align
op_assign
id|CCSGADDR_MAX
op_div
l_int|2
suffix:semicolon
multiline_comment|/* Start by fetching a single cacheline. */
id|sg_prefetch_cnt
op_assign
id|sg_prefetch_align
suffix:semicolon
multiline_comment|/*&n;&t; * Increment the prefetch count by cachelines until&n;&t; * at least one S/G element will fit.&n;&t; */
id|sg_size
op_assign
r_sizeof
(paren
r_struct
id|ahd_dma_seg
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;flags
op_amp
id|AHD_64BIT_ADDRESSING
)paren
op_ne
l_int|0
)paren
id|sg_size
op_assign
r_sizeof
(paren
r_struct
id|ahd_dma64_seg
)paren
suffix:semicolon
r_while
c_loop
(paren
id|sg_prefetch_cnt
OL
id|sg_size
)paren
id|sg_prefetch_cnt
op_add_assign
id|sg_prefetch_align
suffix:semicolon
multiline_comment|/*&n;&t; * If the cacheline is not an even multiple of&n;&t; * the S/G size, we may only get a partial S/G when&n;&t; * we align. Add a cacheline if this is the case.&n;&t; */
r_if
c_cond
(paren
(paren
id|sg_prefetch_align
op_mod
id|sg_size
)paren
op_ne
l_int|0
op_logical_and
(paren
id|sg_prefetch_cnt
OL
id|CCSGADDR_MAX
)paren
)paren
id|sg_prefetch_cnt
op_add_assign
id|sg_prefetch_align
suffix:semicolon
multiline_comment|/*&n;&t; * Lastly, compute a value that the sequencer can use&n;&t; * to determine if the remainder of the CCSGRAM buffer&n;&t; * has a full S/G element in it.&n;&t; */
id|sg_prefetch_cnt_limit
op_assign
op_minus
(paren
id|sg_prefetch_cnt
op_minus
id|sg_size
op_plus
l_int|1
)paren
suffix:semicolon
id|download_consts
(braket
id|SG_PREFETCH_CNT
)braket
op_assign
id|sg_prefetch_cnt
suffix:semicolon
id|download_consts
(braket
id|SG_PREFETCH_CNT_LIMIT
)braket
op_assign
id|sg_prefetch_cnt_limit
suffix:semicolon
id|download_consts
(braket
id|SG_PREFETCH_ALIGN_MASK
)braket
op_assign
op_complement
(paren
id|sg_prefetch_align
op_minus
l_int|1
)paren
suffix:semicolon
id|download_consts
(braket
id|SG_PREFETCH_ADDR_MASK
)braket
op_assign
(paren
id|sg_prefetch_align
op_minus
l_int|1
)paren
suffix:semicolon
id|download_consts
(braket
id|SG_SIZEOF
)braket
op_assign
id|sg_size
suffix:semicolon
id|download_consts
(braket
id|PKT_OVERRUN_BUFOFFSET
)braket
op_assign
(paren
id|ahd-&gt;overrun_buf
op_minus
(paren
r_uint8
op_star
)paren
id|ahd-&gt;qoutfifo
)paren
op_div
l_int|256
suffix:semicolon
id|download_consts
(braket
id|SCB_TRANSFER_SIZE
)braket
op_assign
id|SCB_TRANSFER_SIZE_1BYTE_LUN
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;bugs
op_amp
id|AHD_PKT_LUN_BUG
)paren
op_ne
l_int|0
)paren
id|download_consts
(braket
id|SCB_TRANSFER_SIZE
)braket
op_assign
id|SCB_TRANSFER_SIZE_FULL_LUN
suffix:semicolon
id|cur_patch
op_assign
id|patches
suffix:semicolon
id|downloaded
op_assign
l_int|0
suffix:semicolon
id|skip_addr
op_assign
l_int|0
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SEQCTL0
comma
id|PERRORDIS
op_or
id|FAILDIS
op_or
id|FASTMODE
op_or
id|LOADRAM
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|PRGMCNT
comma
l_int|0
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|PRGMCNT
op_plus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|seqprog
)paren
op_div
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ahd_check_patch
c_func
(paren
id|ahd
comma
op_amp
id|cur_patch
comma
id|i
comma
op_amp
id|skip_addr
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Don&squot;t download this instruction as it&n;&t;&t;&t; * is in a patch that was removed.&n;&t;&t;&t; */
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Move through the CS table until we find a CS&n;&t;&t; * that might apply to this instruction.&n;&t;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|cur_cs
OL
id|num_critical_sections
suffix:semicolon
id|cur_cs
op_increment
)paren
(brace
r_if
c_cond
(paren
id|critical_sections
(braket
id|cur_cs
)braket
dot
id|end
op_le
id|i
)paren
(brace
r_if
c_cond
(paren
id|begin_set
(braket
id|cs_count
)braket
op_eq
id|TRUE
op_logical_and
id|end_set
(braket
id|cs_count
)braket
op_eq
id|FALSE
)paren
(brace
id|cs_table
(braket
id|cs_count
)braket
dot
id|end
op_assign
id|downloaded
suffix:semicolon
id|end_set
(braket
id|cs_count
)braket
op_assign
id|TRUE
suffix:semicolon
id|cs_count
op_increment
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|critical_sections
(braket
id|cur_cs
)braket
dot
id|begin
op_le
id|i
op_logical_and
id|begin_set
(braket
id|cs_count
)braket
op_eq
id|FALSE
)paren
(brace
id|cs_table
(braket
id|cs_count
)braket
dot
id|begin
op_assign
id|downloaded
suffix:semicolon
id|begin_set
(braket
id|cs_count
)braket
op_assign
id|TRUE
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|ahd_download_instr
c_func
(paren
id|ahd
comma
id|i
comma
id|download_consts
)paren
suffix:semicolon
id|downloaded
op_increment
suffix:semicolon
)brace
id|ahd-&gt;num_critical_sections
op_assign
id|cs_count
suffix:semicolon
r_if
c_cond
(paren
id|cs_count
op_ne
l_int|0
)paren
(brace
id|cs_count
op_mul_assign
r_sizeof
(paren
r_struct
id|cs
)paren
suffix:semicolon
id|ahd-&gt;critical_sections
op_assign
id|malloc
c_func
(paren
id|cs_count
comma
id|M_DEVBUF
comma
id|M_NOWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahd-&gt;critical_sections
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;ahd_loadseq: Could not malloc&quot;
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ahd-&gt;critical_sections
comma
id|cs_table
comma
id|cs_count
)paren
suffix:semicolon
)brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SEQCTL0
comma
id|PERRORDIS
op_or
id|FAILDIS
op_or
id|FASTMODE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bootverbose
)paren
(brace
id|printf
c_func
(paren
l_string|&quot; %d instructions downloaded&bslash;n&quot;
comma
id|downloaded
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s: Features 0x%x, Bugs 0x%x, Flags 0x%x&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|ahd-&gt;features
comma
id|ahd-&gt;bugs
comma
id|ahd-&gt;flags
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|ahd_check_patch
id|ahd_check_patch
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|patch
op_star
op_star
id|start_patch
comma
id|u_int
id|start_instr
comma
id|u_int
op_star
id|skip_addr
)paren
(brace
r_struct
id|patch
op_star
id|cur_patch
suffix:semicolon
r_struct
id|patch
op_star
id|last_patch
suffix:semicolon
id|u_int
id|num_patches
suffix:semicolon
id|num_patches
op_assign
r_sizeof
(paren
id|patches
)paren
op_div
r_sizeof
(paren
r_struct
id|patch
)paren
suffix:semicolon
id|last_patch
op_assign
op_amp
id|patches
(braket
id|num_patches
)braket
suffix:semicolon
id|cur_patch
op_assign
op_star
id|start_patch
suffix:semicolon
r_while
c_loop
(paren
id|cur_patch
OL
id|last_patch
op_logical_and
id|start_instr
op_eq
id|cur_patch-&gt;begin
)paren
(brace
r_if
c_cond
(paren
id|cur_patch
op_member_access_from_pointer
id|patch_func
c_func
(paren
id|ahd
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Start rejecting code */
op_star
id|skip_addr
op_assign
id|start_instr
op_plus
id|cur_patch-&gt;skip_instr
suffix:semicolon
id|cur_patch
op_add_assign
id|cur_patch-&gt;skip_patch
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Accepted this patch.  Advance to the next&n;&t;&t;&t; * one and wait for our intruction pointer to&n;&t;&t;&t; * hit this point.&n;&t;&t;&t; */
id|cur_patch
op_increment
suffix:semicolon
)brace
)brace
op_star
id|start_patch
op_assign
id|cur_patch
suffix:semicolon
r_if
c_cond
(paren
id|start_instr
OL
op_star
id|skip_addr
)paren
multiline_comment|/* Still skipping */
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_static
id|u_int
DECL|function|ahd_resolve_seqaddr
id|ahd_resolve_seqaddr
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
id|u_int
id|address
)paren
(brace
r_struct
id|patch
op_star
id|cur_patch
suffix:semicolon
r_int
id|address_offset
suffix:semicolon
id|u_int
id|skip_addr
suffix:semicolon
id|u_int
id|i
suffix:semicolon
id|address_offset
op_assign
l_int|0
suffix:semicolon
id|cur_patch
op_assign
id|patches
suffix:semicolon
id|skip_addr
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|address
suffix:semicolon
)paren
(brace
id|ahd_check_patch
c_func
(paren
id|ahd
comma
op_amp
id|cur_patch
comma
id|i
comma
op_amp
id|skip_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skip_addr
OG
id|i
)paren
(brace
r_int
id|end_addr
suffix:semicolon
id|end_addr
op_assign
id|MIN
c_func
(paren
id|address
comma
id|skip_addr
)paren
suffix:semicolon
id|address_offset
op_add_assign
id|end_addr
op_minus
id|i
suffix:semicolon
id|i
op_assign
id|skip_addr
suffix:semicolon
)brace
r_else
(brace
id|i
op_increment
suffix:semicolon
)brace
)brace
r_return
(paren
id|address
op_minus
id|address_offset
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|ahd_download_instr
id|ahd_download_instr
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
id|u_int
id|instrptr
comma
r_uint8
op_star
id|dconsts
)paren
(brace
r_union
id|ins_formats
id|instr
suffix:semicolon
r_struct
id|ins_format1
op_star
id|fmt1_ins
suffix:semicolon
r_struct
id|ins_format3
op_star
id|fmt3_ins
suffix:semicolon
id|u_int
id|opcode
suffix:semicolon
multiline_comment|/*&n;&t; * The firmware is always compiled into a little endian format.&n;&t; */
id|instr.integer
op_assign
id|ahd_le32toh
c_func
(paren
op_star
(paren
r_uint32
op_star
)paren
op_amp
id|seqprog
(braket
id|instrptr
op_star
l_int|4
)braket
)paren
suffix:semicolon
id|fmt1_ins
op_assign
op_amp
id|instr.format1
suffix:semicolon
id|fmt3_ins
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Pull the opcode */
id|opcode
op_assign
id|instr.format1.opcode
suffix:semicolon
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_case
id|AIC_OP_JMP
suffix:colon
r_case
id|AIC_OP_JC
suffix:colon
r_case
id|AIC_OP_JNC
suffix:colon
r_case
id|AIC_OP_CALL
suffix:colon
r_case
id|AIC_OP_JNE
suffix:colon
r_case
id|AIC_OP_JNZ
suffix:colon
r_case
id|AIC_OP_JE
suffix:colon
r_case
id|AIC_OP_JZ
suffix:colon
(brace
id|fmt3_ins
op_assign
op_amp
id|instr.format3
suffix:semicolon
id|fmt3_ins-&gt;address
op_assign
id|ahd_resolve_seqaddr
c_func
(paren
id|ahd
comma
id|fmt3_ins-&gt;address
)paren
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
)brace
r_case
id|AIC_OP_OR
suffix:colon
r_case
id|AIC_OP_AND
suffix:colon
r_case
id|AIC_OP_XOR
suffix:colon
r_case
id|AIC_OP_ADD
suffix:colon
r_case
id|AIC_OP_ADC
suffix:colon
r_case
id|AIC_OP_BMOV
suffix:colon
r_if
c_cond
(paren
id|fmt1_ins-&gt;parity
op_ne
l_int|0
)paren
(brace
id|fmt1_ins-&gt;immediate
op_assign
id|dconsts
(braket
id|fmt1_ins-&gt;immediate
)braket
suffix:semicolon
)brace
id|fmt1_ins-&gt;parity
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_case
id|AIC_OP_ROL
suffix:colon
(brace
r_int
id|i
comma
id|count
suffix:semicolon
multiline_comment|/* Calculate odd parity for the instruction */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|count
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|31
suffix:semicolon
id|i
op_increment
)paren
(brace
r_uint32
id|mask
suffix:semicolon
id|mask
op_assign
l_int|0x01
op_lshift
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|instr.integer
op_amp
id|mask
)paren
op_ne
l_int|0
)paren
id|count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|count
op_amp
l_int|0x01
)paren
op_eq
l_int|0
)paren
id|instr.format1.parity
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* The sequencer is a little endian cpu */
id|instr.integer
op_assign
id|ahd_htole32
c_func
(paren
id|instr.integer
)paren
suffix:semicolon
id|ahd_outsb
c_func
(paren
id|ahd
comma
id|SEQRAM
comma
id|instr.bytes
comma
l_int|4
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;Unknown opcode encountered in seq program&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|ahd_probe_stack_size
id|ahd_probe_stack_size
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
r_int
id|last_probe
suffix:semicolon
id|last_probe
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We avoid using 0 as a pattern to avoid&n;&t;&t; * confusion if the stack implementation&n;&t;&t; * &quot;back-fills&quot; with zeros when &quot;poping&squot;&n;&t;&t; * entries.&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
id|last_probe
op_plus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|STACK
comma
id|i
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|STACK
comma
(paren
id|i
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
)brace
multiline_comment|/* Verify */
r_for
c_loop
(paren
id|i
op_assign
id|last_probe
op_plus
l_int|1
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|u_int
id|stack_entry
suffix:semicolon
id|stack_entry
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|STACK
)paren
op_or
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|STACK
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stack_entry
op_ne
id|i
)paren
r_goto
id|sized
suffix:semicolon
)brace
id|last_probe
op_increment
suffix:semicolon
)brace
id|sized
suffix:colon
r_return
(paren
id|last_probe
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahd_dump_all_cards_state
id|ahd_dump_all_cards_state
c_func
(paren
)paren
(brace
r_struct
id|ahd_softc
op_star
id|list_ahd
suffix:semicolon
id|TAILQ_FOREACH
c_func
(paren
id|list_ahd
comma
op_amp
id|ahd_tailq
comma
id|links
)paren
(brace
id|ahd_dump_card_state
c_func
(paren
id|list_ahd
)paren
suffix:semicolon
)brace
)brace
r_int
DECL|function|ahd_print_register
id|ahd_print_register
c_func
(paren
id|ahd_reg_parse_entry_t
op_star
id|table
comma
id|u_int
id|num_entries
comma
r_const
r_char
op_star
id|name
comma
id|u_int
id|address
comma
id|u_int
id|value
comma
id|u_int
op_star
id|cur_column
comma
id|u_int
id|wrap_point
)paren
(brace
r_int
id|printed
suffix:semicolon
id|u_int
id|printed_mask
suffix:semicolon
r_if
c_cond
(paren
id|cur_column
op_ne
l_int|NULL
op_logical_and
op_star
id|cur_column
op_ge
id|wrap_point
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|cur_column
op_assign
l_int|0
suffix:semicolon
)brace
id|printed
op_assign
id|printf
c_func
(paren
l_string|&quot;%s[0x%x]&quot;
comma
id|name
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|table
op_eq
l_int|NULL
)paren
(brace
id|printed
op_add_assign
id|printf
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
op_star
id|cur_column
op_add_assign
id|printed
suffix:semicolon
r_return
(paren
id|printed
)paren
suffix:semicolon
)brace
id|printed_mask
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|printed_mask
op_ne
l_int|0xFF
)paren
(brace
r_int
id|entry
suffix:semicolon
r_for
c_loop
(paren
id|entry
op_assign
l_int|0
suffix:semicolon
id|entry
OL
id|num_entries
suffix:semicolon
id|entry
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|value
op_amp
id|table
(braket
id|entry
)braket
dot
id|mask
)paren
op_ne
id|table
(braket
id|entry
)braket
dot
id|value
)paren
op_logical_or
(paren
(paren
id|printed_mask
op_amp
id|table
(braket
id|entry
)braket
dot
id|mask
)paren
op_eq
id|table
(braket
id|entry
)braket
dot
id|mask
)paren
)paren
r_continue
suffix:semicolon
id|printed
op_add_assign
id|printf
c_func
(paren
l_string|&quot;%s%s&quot;
comma
id|printed_mask
op_eq
l_int|0
ques
c_cond
l_string|&quot;:(&quot;
suffix:colon
l_string|&quot;|&quot;
comma
id|table
(braket
id|entry
)braket
dot
id|name
)paren
suffix:semicolon
id|printed_mask
op_or_assign
id|table
(braket
id|entry
)braket
dot
id|mask
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry
op_ge
id|num_entries
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|printed_mask
op_ne
l_int|0
)paren
id|printed
op_add_assign
id|printf
c_func
(paren
l_string|&quot;) &quot;
)paren
suffix:semicolon
r_else
id|printed
op_add_assign
id|printf
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur_column
op_ne
l_int|NULL
)paren
op_star
id|cur_column
op_add_assign
id|printed
suffix:semicolon
r_return
(paren
id|printed
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahd_dump_card_state
id|ahd_dump_card_state
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
r_struct
id|scb
op_star
id|scb
suffix:semicolon
id|ahd_mode_state
id|saved_modes
suffix:semicolon
id|u_int
id|dffstat
suffix:semicolon
r_int
id|paused
suffix:semicolon
id|u_int
id|scb_index
suffix:semicolon
id|u_int
id|saved_scb_index
suffix:semicolon
id|u_int
id|cur_col
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|ahd_is_paused
c_func
(paren
id|ahd
)paren
)paren
(brace
id|paused
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|paused
op_assign
l_int|0
suffix:semicolon
id|ahd_pause
c_func
(paren
id|ahd
)paren
suffix:semicolon
)brace
id|saved_modes
op_assign
id|ahd_save_modes
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI
comma
id|AHD_MODE_SCSI
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Dump Card State Begins &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&bslash;n&quot;
l_string|&quot;%s: Dumping Card State at program address 0x%x Mode 0x%x&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|CURADDR
)paren
op_or
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|CURADDR
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
comma
id|ahd_build_mode_state
c_func
(paren
id|ahd
comma
id|ahd-&gt;saved_src_mode
comma
id|ahd-&gt;saved_dst_mode
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|paused
)paren
id|printf
c_func
(paren
l_string|&quot;Card was paused&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Mode independent registers.&n;&t; */
id|cur_col
op_assign
l_int|0
suffix:semicolon
id|ahd_hs_mailbox_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LOCAL_HS_MAILBOX
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_intctl_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|INTCTL
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_seqintstat_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SEQINTSTAT
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_saved_mode_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SAVED_MODE
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_dffstat_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|DFFSTAT
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_scsisigi_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSISIGI
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_scsiphase_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSIPHASE
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_scsibus_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSIBUS
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_lastphase_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LASTPHASE
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_scsiseq0_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSISEQ0
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_scsiseq1_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSISEQ1
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_seqctl0_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SEQCTL0
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_seqintctl_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SEQINTCTL
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_seq_flags_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SEQ_FLAGS
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_seq_flags2_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SEQ_FLAGS2
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_sstat0_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SSTAT0
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_sstat1_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SSTAT1
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_sstat2_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SSTAT2
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_sstat3_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SSTAT3
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_perrdiag_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|PERRDIAG
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_simode1_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SIMODE1
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_lqistat0_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LQISTAT0
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_lqistat1_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LQISTAT1
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_lqistat2_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LQISTAT2
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_lqostat0_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LQOSTAT0
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_lqostat1_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LQOSTAT1
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_lqostat2_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LQOSTAT2
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;nSCB Count = %d CMDS_PENDING = %d LASTSCB 0x%x &quot;
l_string|&quot;CURRSCB 0x%x NEXTSCB 0x%x&bslash;n&quot;
comma
id|ahd-&gt;scb_data.numscbs
comma
id|ahd_inw
c_func
(paren
id|ahd
comma
id|CMDS_PENDING
)paren
comma
id|ahd_inw
c_func
(paren
id|ahd
comma
id|LASTSCB
)paren
comma
id|ahd_inw
c_func
(paren
id|ahd
comma
id|CURRSCB
)paren
comma
id|ahd_inw
c_func
(paren
id|ahd
comma
id|NEXTSCB
)paren
)paren
suffix:semicolon
id|cur_col
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* QINFIFO */
id|ahd_search_qinfifo
c_func
(paren
id|ahd
comma
id|CAM_TARGET_WILDCARD
comma
id|ALL_CHANNELS
comma
id|CAM_LUN_WILDCARD
comma
id|SCB_LIST_NULL
comma
id|ROLE_UNKNOWN
comma
multiline_comment|/*status*/
l_int|0
comma
id|SEARCH_PRINT
)paren
suffix:semicolon
id|saved_scb_index
op_assign
id|ahd_get_scbptr
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Pending list:&quot;
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
id|LIST_FOREACH
c_func
(paren
id|scb
comma
op_amp
id|ahd-&gt;pending_scbs
comma
id|pending_links
)paren
(brace
r_if
c_cond
(paren
id|i
op_increment
OG
id|AHD_SCB_MAX
)paren
r_break
suffix:semicolon
id|cur_col
op_assign
id|printf
c_func
(paren
l_string|&quot;&bslash;n%3d &quot;
comma
id|SCB_GET_TAG
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
id|ahd_set_scbptr
c_func
(paren
id|ahd
comma
id|SCB_GET_TAG
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
id|ahd_scb_control_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCB_CONTROL
)paren
comma
op_amp
id|cur_col
comma
l_int|60
)paren
suffix:semicolon
id|ahd_scb_scsiid_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCB_SCSIID
)paren
comma
op_amp
id|cur_col
comma
l_int|60
)paren
suffix:semicolon
id|ahd_scb_tag_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCB_TAG
)paren
comma
op_amp
id|cur_col
comma
l_int|60
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;nTotal %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Kernel Free SCB list: &quot;
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
id|TAILQ_FOREACH
c_func
(paren
id|scb
comma
op_amp
id|ahd-&gt;scb_data.free_scbs
comma
id|links.tqe
)paren
(brace
r_struct
id|scb
op_star
id|list_scb
suffix:semicolon
id|list_scb
op_assign
id|scb
suffix:semicolon
r_do
(brace
id|printf
c_func
(paren
l_string|&quot;%d &quot;
comma
id|SCB_GET_TAG
c_func
(paren
id|list_scb
)paren
)paren
suffix:semicolon
id|list_scb
op_assign
id|LIST_NEXT
c_func
(paren
id|list_scb
comma
id|collision_links
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|list_scb
op_logical_and
id|i
op_increment
OL
id|AHD_SCB_MAX
)paren
suffix:semicolon
)brace
id|LIST_FOREACH
c_func
(paren
id|scb
comma
op_amp
id|ahd-&gt;scb_data.any_dev_free_scb_list
comma
id|links.le
)paren
(brace
r_if
c_cond
(paren
id|i
op_increment
OG
id|AHD_SCB_MAX
)paren
r_break
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%d &quot;
comma
id|SCB_GET_TAG
c_func
(paren
id|scb
)paren
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Sequencer Complete DMA-inprog list: &quot;
)paren
suffix:semicolon
id|scb_index
op_assign
id|ahd_inw
c_func
(paren
id|ahd
comma
id|COMPLETE_SCB_DMAINPROG_HEAD
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|SCBID_IS_NULL
c_func
(paren
id|scb_index
)paren
op_logical_and
id|i
op_increment
OL
id|AHD_SCB_MAX
)paren
(brace
id|ahd_set_scbptr
c_func
(paren
id|ahd
comma
id|scb_index
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%d &quot;
comma
id|scb_index
)paren
suffix:semicolon
id|scb_index
op_assign
id|ahd_inw
c_func
(paren
id|ahd
comma
id|SCB_NEXT_COMPLETE
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Sequencer Complete list: &quot;
)paren
suffix:semicolon
id|scb_index
op_assign
id|ahd_inw
c_func
(paren
id|ahd
comma
id|COMPLETE_SCB_HEAD
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|SCBID_IS_NULL
c_func
(paren
id|scb_index
)paren
op_logical_and
id|i
op_increment
OL
id|AHD_SCB_MAX
)paren
(brace
id|ahd_set_scbptr
c_func
(paren
id|ahd
comma
id|scb_index
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%d &quot;
comma
id|scb_index
)paren
suffix:semicolon
id|scb_index
op_assign
id|ahd_inw
c_func
(paren
id|ahd
comma
id|SCB_NEXT_COMPLETE
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Sequencer DMA-Up and Complete list: &quot;
)paren
suffix:semicolon
id|scb_index
op_assign
id|ahd_inw
c_func
(paren
id|ahd
comma
id|COMPLETE_DMA_SCB_HEAD
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|SCBID_IS_NULL
c_func
(paren
id|scb_index
)paren
op_logical_and
id|i
op_increment
OL
id|AHD_SCB_MAX
)paren
(brace
id|ahd_set_scbptr
c_func
(paren
id|ahd
comma
id|scb_index
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%d &quot;
comma
id|scb_index
)paren
suffix:semicolon
id|scb_index
op_assign
id|ahd_inw
c_func
(paren
id|ahd
comma
id|SCB_NEXT_COMPLETE
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|ahd_set_scbptr
c_func
(paren
id|ahd
comma
id|saved_scb_index
)paren
suffix:semicolon
id|dffstat
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|DFFSTAT
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
macro_line|#ifdef AHD_DEBUG
r_struct
id|scb
op_star
id|fifo_scb
suffix:semicolon
macro_line|#endif
id|u_int
id|fifo_scbptr
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_DFF0
op_plus
id|i
comma
id|AHD_MODE_DFF0
op_plus
id|i
)paren
suffix:semicolon
id|fifo_scbptr
op_assign
id|ahd_get_scbptr
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n%s: FIFO%d %s, LONGJMP == 0x%x, &quot;
l_string|&quot;SCB 0x%x, LJSCB 0x%x&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|i
comma
(paren
id|dffstat
op_amp
(paren
id|FIFO0FREE
op_lshift
id|i
)paren
)paren
ques
c_cond
l_string|&quot;Free&quot;
suffix:colon
l_string|&quot;Active&quot;
comma
id|ahd_inw
c_func
(paren
id|ahd
comma
id|LONGJMP_ADDR
)paren
comma
id|fifo_scbptr
comma
id|ahd_inw
c_func
(paren
id|ahd
comma
id|LONGJMP_SCB
)paren
)paren
suffix:semicolon
id|cur_col
op_assign
l_int|0
suffix:semicolon
id|ahd_seqimode_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SEQIMODE
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_seqintsrc_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SEQINTSRC
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_dfcntrl_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|DFCNTRL
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_dfstatus_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|DFSTATUS
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_sg_cache_shadow_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SG_CACHE_SHADOW
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_sg_state_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SG_STATE
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_dffsxfrctl_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|DFFSXFRCTL
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_soffcnt_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SOFFCNT
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|ahd_mdffstat_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|MDFFSTAT
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur_col
OG
l_int|50
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|cur_col
op_assign
l_int|0
suffix:semicolon
)brace
id|cur_col
op_add_assign
id|printf
c_func
(paren
l_string|&quot;SHADDR = 0x%x%x, SHCNT = 0x%x &quot;
comma
id|ahd_inl
c_func
(paren
id|ahd
comma
id|SHADDR
op_plus
l_int|4
)paren
comma
id|ahd_inl
c_func
(paren
id|ahd
comma
id|SHADDR
)paren
comma
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SHCNT
)paren
op_or
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SHCNT
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SHCNT
op_plus
l_int|2
)paren
op_lshift
l_int|16
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur_col
OG
l_int|50
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|cur_col
op_assign
l_int|0
suffix:semicolon
)brace
id|cur_col
op_add_assign
id|printf
c_func
(paren
l_string|&quot;HADDR = 0x%x%x, HCNT = 0x%x &quot;
comma
id|ahd_inl
c_func
(paren
id|ahd
comma
id|HADDR
op_plus
l_int|4
)paren
comma
id|ahd_inl
c_func
(paren
id|ahd
comma
id|HADDR
)paren
comma
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|HCNT
)paren
op_or
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|HCNT
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|HCNT
op_plus
l_int|2
)paren
op_lshift
l_int|16
)paren
)paren
)paren
suffix:semicolon
id|ahd_ccsgctl_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|CCSGCTL
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_SG
)paren
op_ne
l_int|0
)paren
(brace
id|fifo_scb
op_assign
id|ahd_lookup_scb
c_func
(paren
id|ahd
comma
id|fifo_scbptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fifo_scb
op_ne
l_int|NULL
)paren
id|ahd_dump_sglist
c_func
(paren
id|fifo_scb
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;nLQIN: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|20
suffix:semicolon
id|i
op_increment
)paren
id|printf
c_func
(paren
l_string|&quot;0x%x &quot;
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LQIN
op_plus
id|i
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_CFG
comma
id|AHD_MODE_CFG
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s: LQISTATE = 0x%x, LQOSTATE = 0x%x, OPTIONMODE = 0x%x&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LQISTATE
)paren
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|LQOSTATE
)paren
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|OPTIONMODE
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s: OS_SPACE_CNT = 0x%x MAXCMDCNT = 0x%x&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|OS_SPACE_CNT
)paren
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|MAXCMDCNT
)paren
)paren
suffix:semicolon
id|ahd_simode0_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SIMODE0
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_CCHAN
comma
id|AHD_MODE_CCHAN
)paren
suffix:semicolon
id|cur_col
op_assign
l_int|0
suffix:semicolon
id|ahd_ccscbctl_print
c_func
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|CCSCBCTL
)paren
comma
op_amp
id|cur_col
comma
l_int|50
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|ahd-&gt;saved_src_mode
comma
id|ahd-&gt;saved_dst_mode
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s: REG0 == 0x%x, SINDEX = 0x%x, DINDEX = 0x%x&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|ahd_inw
c_func
(paren
id|ahd
comma
id|REG0
)paren
comma
id|ahd_inw
c_func
(paren
id|ahd
comma
id|SINDEX
)paren
comma
id|ahd_inw
c_func
(paren
id|ahd
comma
id|DINDEX
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s: SCBPTR == 0x%x, SCB_NEXT == 0x%x, SCB_NEXT2 == 0x%x&bslash;n&quot;
comma
id|ahd_name
c_func
(paren
id|ahd
)paren
comma
id|ahd_get_scbptr
c_func
(paren
id|ahd
)paren
comma
id|ahd_inw
c_func
(paren
id|ahd
comma
id|SCB_NEXT
)paren
comma
id|ahd_inw
c_func
(paren
id|ahd
comma
id|SCB_NEXT2
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;CDB %x %x %x %x %x %x&bslash;n&quot;
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCB_CDB_STORE
)paren
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCB_CDB_STORE
op_plus
l_int|1
)paren
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCB_CDB_STORE
op_plus
l_int|2
)paren
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCB_CDB_STORE
op_plus
l_int|3
)paren
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCB_CDB_STORE
op_plus
l_int|4
)paren
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCB_CDB_STORE
op_plus
l_int|5
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;STACK:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ahd-&gt;stack_size
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ahd-&gt;saved_stack
(braket
id|i
)braket
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|STACK
)paren
op_or
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|STACK
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot; 0x%x&quot;
comma
id|ahd-&gt;saved_stack
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
id|ahd-&gt;stack_size
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|STACK
comma
id|ahd-&gt;saved_stack
(braket
id|i
)braket
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|STACK
comma
(paren
id|ahd-&gt;saved_stack
(braket
id|i
)braket
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; Dump Card State Ends &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&bslash;n&quot;
)paren
suffix:semicolon
id|ahd_platform_dump_card_state
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_restore_modes
c_func
(paren
id|ahd
comma
id|saved_modes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|paused
op_eq
l_int|0
)paren
id|ahd_unpause
c_func
(paren
id|ahd
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahd_dump_scbs
id|ahd_dump_scbs
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
id|ahd_mode_state
id|saved_modes
suffix:semicolon
id|u_int
id|saved_scb_index
suffix:semicolon
r_int
id|i
suffix:semicolon
id|saved_modes
op_assign
id|ahd_save_modes
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_set_modes
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI
comma
id|AHD_MODE_SCSI
)paren
suffix:semicolon
id|saved_scb_index
op_assign
id|ahd_get_scbptr
c_func
(paren
id|ahd
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AHD_SCB_MAX
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ahd_set_scbptr
c_func
(paren
id|ahd
comma
id|i
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%3d&quot;
comma
id|i
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;(CTRL 0x%x ID 0x%x N 0x%x N2 0x%x SG 0x%x, RSG 0x%x)&bslash;n&quot;
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCB_CONTROL
)paren
comma
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCB_SCSIID
)paren
comma
id|ahd_inw
c_func
(paren
id|ahd
comma
id|SCB_NEXT
)paren
comma
id|ahd_inw
c_func
(paren
id|ahd
comma
id|SCB_NEXT2
)paren
comma
id|ahd_inl
c_func
(paren
id|ahd
comma
id|SCB_SGPTR
)paren
comma
id|ahd_inl
c_func
(paren
id|ahd
comma
id|SCB_RESIDUAL_SGPTR
)paren
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|ahd_set_scbptr
c_func
(paren
id|ahd
comma
id|saved_scb_index
)paren
suffix:semicolon
id|ahd_restore_modes
c_func
(paren
id|ahd
comma
id|saved_modes
)paren
suffix:semicolon
)brace
multiline_comment|/**************************** Flexport Logic **********************************/
multiline_comment|/*&n; * Read count 16bit words from 16bit word address start_addr from the&n; * SEEPROM attached to the controller, into buf, using the controller&squot;s&n; * SEEPROM reading state machine.&n; */
r_int
DECL|function|ahd_read_seeprom
id|ahd_read_seeprom
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_uint16
op_star
id|buf
comma
id|u_int
id|start_addr
comma
id|u_int
id|count
)paren
(brace
id|u_int
id|cur_addr
suffix:semicolon
id|u_int
id|end_addr
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * If we never make it through the loop even once,&n;&t; * we were passed invalid arguments.&n;&t; */
id|error
op_assign
id|EINVAL
suffix:semicolon
id|AHD_ASSERT_MODES
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI_MSK
comma
id|AHD_MODE_SCSI_MSK
)paren
suffix:semicolon
id|end_addr
op_assign
id|start_addr
op_plus
id|count
suffix:semicolon
r_for
c_loop
(paren
id|cur_addr
op_assign
id|start_addr
suffix:semicolon
id|cur_addr
OL
id|end_addr
suffix:semicolon
id|cur_addr
op_increment
)paren
(brace
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SEEADR
comma
id|cur_addr
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SEECTL
comma
id|SEEOP_READ
op_or
id|SEESTART
)paren
suffix:semicolon
id|error
op_assign
id|ahd_wait_seeprom
c_func
(paren
id|ahd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_break
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|ahd_inw
c_func
(paren
id|ahd
comma
id|SEEDAT
)paren
suffix:semicolon
)brace
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Write count 16bit words from buf, into SEEPROM attache to the&n; * controller starting at 16bit word address start_addr, using the&n; * controller&squot;s SEEPROM writing state machine.&n; */
r_int
DECL|function|ahd_write_seeprom
id|ahd_write_seeprom
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_uint16
op_star
id|buf
comma
id|u_int
id|start_addr
comma
id|u_int
id|count
)paren
(brace
id|u_int
id|cur_addr
suffix:semicolon
id|u_int
id|end_addr
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|AHD_ASSERT_MODES
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI_MSK
comma
id|AHD_MODE_SCSI_MSK
)paren
suffix:semicolon
id|error
op_assign
id|ENOENT
suffix:semicolon
multiline_comment|/* Place the chip into write-enable mode */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SEEADR
comma
id|SEEOP_EWEN_ADDR
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SEECTL
comma
id|SEEOP_EWEN
op_or
id|SEESTART
)paren
suffix:semicolon
id|error
op_assign
id|ahd_wait_seeprom
c_func
(paren
id|ahd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Write the data.  If we don&squot;t get throught the loop at&n;&t; * least once, the arguments were invalid.&n;&t; */
id|retval
op_assign
id|EINVAL
suffix:semicolon
id|end_addr
op_assign
id|start_addr
op_plus
id|count
suffix:semicolon
r_for
c_loop
(paren
id|cur_addr
op_assign
id|start_addr
suffix:semicolon
id|cur_addr
OL
id|end_addr
suffix:semicolon
id|cur_addr
op_increment
)paren
(brace
id|ahd_outw
c_func
(paren
id|ahd
comma
id|SEEDAT
comma
op_star
id|buf
op_increment
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SEEADR
comma
id|cur_addr
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SEECTL
comma
id|SEEOP_WRITE
op_or
id|SEESTART
)paren
suffix:semicolon
id|retval
op_assign
id|ahd_wait_seeprom
c_func
(paren
id|ahd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Disable writes.&n;&t; */
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SEEADR
comma
id|SEEOP_EWDS_ADDR
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SEECTL
comma
id|SEEOP_EWDS
op_or
id|SEESTART
)paren
suffix:semicolon
id|error
op_assign
id|ahd_wait_seeprom
c_func
(paren
id|ahd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
r_return
(paren
id|retval
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait ~100us for the serial eeprom to satisfy our request.&n; */
r_int
DECL|function|ahd_wait_seeprom
id|ahd_wait_seeprom
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
r_int
id|cnt
suffix:semicolon
id|cnt
op_assign
l_int|20
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SEESTAT
)paren
op_amp
(paren
id|SEEARBACK
op_or
id|SEEBUSY
)paren
)paren
op_ne
l_int|0
op_logical_and
op_decrement
id|cnt
)paren
id|ahd_delay
c_func
(paren
l_int|5
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_eq
l_int|0
)paren
r_return
(paren
id|ETIMEDOUT
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_int
DECL|function|ahd_verify_cksum
id|ahd_verify_cksum
c_func
(paren
r_struct
id|seeprom_config
op_star
id|sc
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|maxaddr
suffix:semicolon
r_uint32
id|checksum
suffix:semicolon
r_uint16
op_star
id|scarray
suffix:semicolon
id|maxaddr
op_assign
(paren
r_sizeof
(paren
op_star
id|sc
)paren
op_div
l_int|2
)paren
op_minus
l_int|1
suffix:semicolon
id|checksum
op_assign
l_int|0
suffix:semicolon
id|scarray
op_assign
(paren
r_uint16
op_star
)paren
id|sc
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|maxaddr
suffix:semicolon
id|i
op_increment
)paren
id|checksum
op_assign
id|checksum
op_plus
id|scarray
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|checksum
op_eq
l_int|0
op_logical_or
(paren
id|checksum
op_amp
l_int|0xFFFF
)paren
op_ne
id|sc-&gt;checksum
)paren
(brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_int
DECL|function|ahd_acquire_seeprom
id|ahd_acquire_seeprom
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
multiline_comment|/*&n;&t; * We should be able to determine the SEEPROM type&n;&t; * from the flexport logic, but unfortunately not&n;&t; * all implementations have this logic and there is&n;&t; * no programatic method for determining if the logic&n;&t; * is present.&n;&t; */
r_return
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#if 0
r_uint8
id|seetype
suffix:semicolon
r_int
id|error
suffix:semicolon
id|error
op_assign
id|ahd_read_flexport
c_func
(paren
id|ahd
comma
id|FLXADDR_ROMSTAT_CURSENSECTL
comma
op_amp
id|seetype
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
op_logical_or
(paren
(paren
id|seetype
op_amp
id|FLX_ROMSTAT_SEECFG
)paren
op_eq
id|FLX_ROMSTAT_SEE_NONE
)paren
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#endif
)brace
r_void
DECL|function|ahd_release_seeprom
id|ahd_release_seeprom
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
multiline_comment|/* Currently a no-op */
)brace
r_int
DECL|function|ahd_write_flexport
id|ahd_write_flexport
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
id|u_int
id|addr
comma
id|u_int
id|value
)paren
(brace
r_int
id|error
suffix:semicolon
id|AHD_ASSERT_MODES
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI_MSK
comma
id|AHD_MODE_SCSI_MSK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|addr
OG
l_int|7
)paren
id|panic
c_func
(paren
l_string|&quot;ahd_write_flexport: address out of range&quot;
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|BRDCTL
comma
id|BRDEN
op_or
(paren
id|addr
op_lshift
l_int|3
)paren
)paren
suffix:semicolon
id|error
op_assign
id|ahd_wait_flexport
c_func
(paren
id|ahd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|BRDDAT
comma
id|value
)paren
suffix:semicolon
id|ahd_flush_device_writes
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|BRDCTL
comma
id|BRDSTB
op_or
id|BRDEN
op_or
(paren
id|addr
op_lshift
l_int|3
)paren
)paren
suffix:semicolon
id|ahd_flush_device_writes
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|BRDCTL
comma
id|BRDEN
op_or
(paren
id|addr
op_lshift
l_int|3
)paren
)paren
suffix:semicolon
id|ahd_flush_device_writes
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|BRDCTL
comma
l_int|0
)paren
suffix:semicolon
id|ahd_flush_device_writes
c_func
(paren
id|ahd
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_int
DECL|function|ahd_read_flexport
id|ahd_read_flexport
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
id|u_int
id|addr
comma
r_uint8
op_star
id|value
)paren
(brace
r_int
id|error
suffix:semicolon
id|AHD_ASSERT_MODES
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI_MSK
comma
id|AHD_MODE_SCSI_MSK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|addr
OG
l_int|7
)paren
id|panic
c_func
(paren
l_string|&quot;ahd_read_flexport: address out of range&quot;
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|BRDCTL
comma
id|BRDRW
op_or
id|BRDEN
op_or
(paren
id|addr
op_lshift
l_int|3
)paren
)paren
suffix:semicolon
id|error
op_assign
id|ahd_wait_flexport
c_func
(paren
id|ahd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
op_star
id|value
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|BRDDAT
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|BRDCTL
comma
l_int|0
)paren
suffix:semicolon
id|ahd_flush_device_writes
c_func
(paren
id|ahd
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait at most 2 seconds for flexport arbitration to succeed.&n; */
r_int
DECL|function|ahd_wait_flexport
id|ahd_wait_flexport
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
)paren
(brace
r_int
id|cnt
suffix:semicolon
id|AHD_ASSERT_MODES
c_func
(paren
id|ahd
comma
id|AHD_MODE_SCSI_MSK
comma
id|AHD_MODE_SCSI_MSK
)paren
suffix:semicolon
id|cnt
op_assign
l_int|1000000
op_star
l_int|2
op_div
l_int|5
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|BRDCTL
)paren
op_amp
id|FLXARBACK
)paren
op_eq
l_int|0
op_logical_and
op_decrement
id|cnt
)paren
id|ahd_delay
c_func
(paren
l_int|5
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_eq
l_int|0
)paren
r_return
(paren
id|ETIMEDOUT
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/************************* Target Mode ****************************************/
macro_line|#ifdef AHD_TARGET_MODE
id|cam_status
DECL|function|ahd_find_tmode_devs
id|ahd_find_tmode_devs
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|cam_sim
op_star
id|sim
comma
r_union
id|ccb
op_star
id|ccb
comma
r_struct
id|ahd_tmode_tstate
op_star
op_star
id|tstate
comma
r_struct
id|ahd_tmode_lstate
op_star
op_star
id|lstate
comma
r_int
id|notfound_failure
)paren
(brace
r_if
c_cond
(paren
(paren
id|ahd-&gt;features
op_amp
id|AHD_TARGETMODE
)paren
op_eq
l_int|0
)paren
r_return
(paren
id|CAM_REQ_INVALID
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Handle the &squot;black hole&squot; device that sucks up&n;&t; * requests to unattached luns on enabled targets.&n;&t; */
r_if
c_cond
(paren
id|ccb-&gt;ccb_h.target_id
op_eq
id|CAM_TARGET_WILDCARD
op_logical_and
id|ccb-&gt;ccb_h.target_lun
op_eq
id|CAM_LUN_WILDCARD
)paren
(brace
op_star
id|tstate
op_assign
l_int|NULL
suffix:semicolon
op_star
id|lstate
op_assign
id|ahd-&gt;black_hole
suffix:semicolon
)brace
r_else
(brace
id|u_int
id|max_id
suffix:semicolon
id|max_id
op_assign
(paren
id|ahd-&gt;features
op_amp
id|AHD_WIDE
)paren
ques
c_cond
l_int|15
suffix:colon
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|ccb-&gt;ccb_h.target_id
OG
id|max_id
)paren
r_return
(paren
id|CAM_TID_INVALID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccb-&gt;ccb_h.target_lun
op_ge
id|AHD_NUM_LUNS
)paren
r_return
(paren
id|CAM_LUN_INVALID
)paren
suffix:semicolon
op_star
id|tstate
op_assign
id|ahd-&gt;enabled_targets
(braket
id|ccb-&gt;ccb_h.target_id
)braket
suffix:semicolon
op_star
id|lstate
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_star
id|tstate
op_ne
l_int|NULL
)paren
op_star
id|lstate
op_assign
(paren
op_star
id|tstate
)paren
op_member_access_from_pointer
id|enabled_luns
(braket
id|ccb-&gt;ccb_h.target_lun
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|notfound_failure
op_ne
l_int|0
op_logical_and
op_star
id|lstate
op_eq
l_int|NULL
)paren
r_return
(paren
id|CAM_PATH_INVALID
)paren
suffix:semicolon
r_return
(paren
id|CAM_REQ_CMP
)paren
suffix:semicolon
)brace
r_void
DECL|function|ahd_handle_en_lun
id|ahd_handle_en_lun
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|cam_sim
op_star
id|sim
comma
r_union
id|ccb
op_star
id|ccb
)paren
(brace
macro_line|#if NOT_YET
r_struct
id|ahd_tmode_tstate
op_star
id|tstate
suffix:semicolon
r_struct
id|ahd_tmode_lstate
op_star
id|lstate
suffix:semicolon
r_struct
id|ccb_en_lun
op_star
id|cel
suffix:semicolon
id|cam_status
id|status
suffix:semicolon
id|u_int
id|target
suffix:semicolon
id|u_int
id|lun
suffix:semicolon
id|u_int
id|target_mask
suffix:semicolon
id|u_long
id|s
suffix:semicolon
r_char
id|channel
suffix:semicolon
id|status
op_assign
id|ahd_find_tmode_devs
c_func
(paren
id|ahd
comma
id|sim
comma
id|ccb
comma
op_amp
id|tstate
comma
op_amp
id|lstate
comma
multiline_comment|/*notfound_failure*/
id|FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
id|CAM_REQ_CMP
)paren
(brace
id|ccb-&gt;ccb_h.status
op_assign
id|status
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ahd-&gt;features
op_amp
id|AHD_MULTIROLE
)paren
op_ne
l_int|0
)paren
(brace
id|u_int
id|our_id
suffix:semicolon
id|our_id
op_assign
id|ahd-&gt;our_id
suffix:semicolon
r_if
c_cond
(paren
id|ccb-&gt;ccb_h.target_id
op_ne
id|our_id
)paren
(brace
r_if
c_cond
(paren
(paren
id|ahd-&gt;features
op_amp
id|AHD_MULTI_TID
)paren
op_ne
l_int|0
op_logical_and
(paren
id|ahd-&gt;flags
op_amp
id|AHD_INITIATORROLE
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Only allow additional targets if&n;&t;&t;&t;&t; * the initiator role is disabled.&n;&t;&t;&t;&t; * The hardware cannot handle a re-select-in&n;&t;&t;&t;&t; * on the initiator id during a re-select-out&n;&t;&t;&t;&t; * on a different target id.&n;&t;&t;&t;&t; */
id|status
op_assign
id|CAM_TID_INVALID
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|ahd-&gt;flags
op_amp
id|AHD_INITIATORROLE
)paren
op_ne
l_int|0
op_logical_or
id|ahd-&gt;enabled_luns
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Only allow our target id to change&n;&t;&t;&t;&t; * if the initiator role is not configured&n;&t;&t;&t;&t; * and there are no enabled luns which&n;&t;&t;&t;&t; * are attached to the currently registered&n;&t;&t;&t;&t; * scsi id.&n;&t;&t;&t;&t; */
id|status
op_assign
id|CAM_TID_INVALID
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|status
op_ne
id|CAM_REQ_CMP
)paren
(brace
id|ccb-&gt;ccb_h.status
op_assign
id|status
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We now have an id that is valid.&n;&t; * If we aren&squot;t in target mode, switch modes.&n;&t; */
r_if
c_cond
(paren
(paren
id|ahd-&gt;flags
op_amp
id|AHD_TARGETROLE
)paren
op_eq
l_int|0
op_logical_and
id|ccb-&gt;ccb_h.target_id
op_ne
id|CAM_TARGET_WILDCARD
)paren
(brace
id|u_long
id|s
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Configuring Target Mode&bslash;n&quot;
)paren
suffix:semicolon
id|ahd_lock
c_func
(paren
id|ahd
comma
op_amp
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|LIST_FIRST
c_func
(paren
op_amp
id|ahd-&gt;pending_scbs
)paren
op_ne
l_int|NULL
)paren
(brace
id|ccb-&gt;ccb_h.status
op_assign
id|CAM_BUSY
suffix:semicolon
id|ahd_unlock
c_func
(paren
id|ahd
comma
op_amp
id|s
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ahd-&gt;flags
op_or_assign
id|AHD_TARGETROLE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;features
op_amp
id|AHD_MULTIROLE
)paren
op_eq
l_int|0
)paren
id|ahd-&gt;flags
op_and_assign
op_complement
id|AHD_INITIATORROLE
suffix:semicolon
id|ahd_pause
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_loadseq
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_unlock
c_func
(paren
id|ahd
comma
op_amp
id|s
)paren
suffix:semicolon
)brace
id|cel
op_assign
op_amp
id|ccb-&gt;cel
suffix:semicolon
id|target
op_assign
id|ccb-&gt;ccb_h.target_id
suffix:semicolon
id|lun
op_assign
id|ccb-&gt;ccb_h.target_lun
suffix:semicolon
id|channel
op_assign
id|SIM_CHANNEL
c_func
(paren
id|ahd
comma
id|sim
)paren
suffix:semicolon
id|target_mask
op_assign
l_int|0x01
op_lshift
id|target
suffix:semicolon
r_if
c_cond
(paren
id|channel
op_eq
l_char|&squot;B&squot;
)paren
id|target_mask
op_lshift_assign
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|cel-&gt;enable
op_ne
l_int|0
)paren
(brace
id|u_int
id|scsiseq1
suffix:semicolon
multiline_comment|/* Are we already enabled?? */
r_if
c_cond
(paren
id|lstate
op_ne
l_int|NULL
)paren
(brace
id|xpt_print_path
c_func
(paren
id|ccb-&gt;ccb_h.path
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Lun already enabled&bslash;n&quot;
)paren
suffix:semicolon
id|ccb-&gt;ccb_h.status
op_assign
id|CAM_LUN_ALRDY_ENA
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cel-&gt;grp6_len
op_ne
l_int|0
op_logical_or
id|cel-&gt;grp7_len
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Don&squot;t (yet?) support vendor&n;&t;&t;&t; * specific commands.&n;&t;&t;&t; */
id|ccb-&gt;ccb_h.status
op_assign
id|CAM_REQ_INVALID
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Non-zero Group Codes&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Seems to be okay.&n;&t;&t; * Setup our data structures.&n;&t;&t; */
r_if
c_cond
(paren
id|target
op_ne
id|CAM_TARGET_WILDCARD
op_logical_and
id|tstate
op_eq
l_int|NULL
)paren
(brace
id|tstate
op_assign
id|ahd_alloc_tstate
c_func
(paren
id|ahd
comma
id|target
comma
id|channel
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tstate
op_eq
l_int|NULL
)paren
(brace
id|xpt_print_path
c_func
(paren
id|ccb-&gt;ccb_h.path
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Couldn&squot;t allocate tstate&bslash;n&quot;
)paren
suffix:semicolon
id|ccb-&gt;ccb_h.status
op_assign
id|CAM_RESRC_UNAVAIL
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|lstate
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|lstate
)paren
comma
id|M_DEVBUF
comma
id|M_NOWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lstate
op_eq
l_int|NULL
)paren
(brace
id|xpt_print_path
c_func
(paren
id|ccb-&gt;ccb_h.path
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Couldn&squot;t allocate lstate&bslash;n&quot;
)paren
suffix:semicolon
id|ccb-&gt;ccb_h.status
op_assign
id|CAM_RESRC_UNAVAIL
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memset
c_func
(paren
id|lstate
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|lstate
)paren
)paren
suffix:semicolon
id|status
op_assign
id|xpt_create_path
c_func
(paren
op_amp
id|lstate-&gt;path
comma
multiline_comment|/*periph*/
l_int|NULL
comma
id|xpt_path_path_id
c_func
(paren
id|ccb-&gt;ccb_h.path
)paren
comma
id|xpt_path_target_id
c_func
(paren
id|ccb-&gt;ccb_h.path
)paren
comma
id|xpt_path_lun_id
c_func
(paren
id|ccb-&gt;ccb_h.path
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
id|CAM_REQ_CMP
)paren
(brace
id|free
c_func
(paren
id|lstate
comma
id|M_DEVBUF
)paren
suffix:semicolon
id|xpt_print_path
c_func
(paren
id|ccb-&gt;ccb_h.path
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Couldn&squot;t allocate path&bslash;n&quot;
)paren
suffix:semicolon
id|ccb-&gt;ccb_h.status
op_assign
id|CAM_RESRC_UNAVAIL
suffix:semicolon
r_return
suffix:semicolon
)brace
id|SLIST_INIT
c_func
(paren
op_amp
id|lstate-&gt;accept_tios
)paren
suffix:semicolon
id|SLIST_INIT
c_func
(paren
op_amp
id|lstate-&gt;immed_notifies
)paren
suffix:semicolon
id|ahd_lock
c_func
(paren
id|ahd
comma
op_amp
id|s
)paren
suffix:semicolon
id|ahd_pause
c_func
(paren
id|ahd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|target
op_ne
id|CAM_TARGET_WILDCARD
)paren
(brace
id|tstate-&gt;enabled_luns
(braket
id|lun
)braket
op_assign
id|lstate
suffix:semicolon
id|ahd-&gt;enabled_luns
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;features
op_amp
id|AHD_MULTI_TID
)paren
op_ne
l_int|0
)paren
(brace
id|u_int
id|targid_mask
suffix:semicolon
id|targid_mask
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|TARGID
)paren
op_or
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|TARGID
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
id|targid_mask
op_or_assign
id|target_mask
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|TARGID
comma
id|targid_mask
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|TARGID
op_plus
l_int|1
comma
(paren
id|targid_mask
op_rshift
l_int|8
)paren
)paren
suffix:semicolon
id|ahd_update_scsiid
c_func
(paren
id|ahd
comma
id|targid_mask
)paren
suffix:semicolon
)brace
r_else
(brace
id|u_int
id|our_id
suffix:semicolon
r_char
id|channel
suffix:semicolon
id|channel
op_assign
id|SIM_CHANNEL
c_func
(paren
id|ahd
comma
id|sim
)paren
suffix:semicolon
id|our_id
op_assign
id|SIM_SCSI_ID
c_func
(paren
id|ahd
comma
id|sim
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * This can only happen if selections&n;&t;&t;&t;&t; * are not enabled&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|target
op_ne
id|our_id
)paren
(brace
id|u_int
id|sblkctl
suffix:semicolon
r_char
id|cur_channel
suffix:semicolon
r_int
id|swap
suffix:semicolon
id|sblkctl
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SBLKCTL
)paren
suffix:semicolon
id|cur_channel
op_assign
(paren
id|sblkctl
op_amp
id|SELBUSB
)paren
ques
c_cond
l_char|&squot;B&squot;
suffix:colon
l_char|&squot;A&squot;
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;features
op_amp
id|AHD_TWIN
)paren
op_eq
l_int|0
)paren
id|cur_channel
op_assign
l_char|&squot;A&squot;
suffix:semicolon
id|swap
op_assign
id|cur_channel
op_ne
id|channel
suffix:semicolon
id|ahd-&gt;our_id
op_assign
id|target
suffix:semicolon
r_if
c_cond
(paren
id|swap
)paren
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SBLKCTL
comma
id|sblkctl
op_xor
id|SELBUSB
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCSIID
comma
id|target
)paren
suffix:semicolon
r_if
c_cond
(paren
id|swap
)paren
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SBLKCTL
comma
id|sblkctl
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
id|ahd-&gt;black_hole
op_assign
id|lstate
suffix:semicolon
multiline_comment|/* Allow select-in operations */
r_if
c_cond
(paren
id|ahd-&gt;black_hole
op_ne
l_int|NULL
op_logical_and
id|ahd-&gt;enabled_luns
OG
l_int|0
)paren
(brace
id|scsiseq1
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSISEQ_TEMPLATE
)paren
suffix:semicolon
id|scsiseq1
op_or_assign
id|ENSELI
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCSISEQ_TEMPLATE
comma
id|scsiseq1
)paren
suffix:semicolon
id|scsiseq1
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSISEQ1
)paren
suffix:semicolon
id|scsiseq1
op_or_assign
id|ENSELI
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCSISEQ1
comma
id|scsiseq1
)paren
suffix:semicolon
)brace
id|ahd_unpause
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_unlock
c_func
(paren
id|ahd
comma
op_amp
id|s
)paren
suffix:semicolon
id|ccb-&gt;ccb_h.status
op_assign
id|CAM_REQ_CMP
suffix:semicolon
id|xpt_print_path
c_func
(paren
id|ccb-&gt;ccb_h.path
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Lun now enabled for target mode&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|scb
op_star
id|scb
suffix:semicolon
r_int
id|i
comma
id|empty
suffix:semicolon
r_if
c_cond
(paren
id|lstate
op_eq
l_int|NULL
)paren
(brace
id|ccb-&gt;ccb_h.status
op_assign
id|CAM_LUN_INVALID
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ahd_lock
c_func
(paren
id|ahd
comma
op_amp
id|s
)paren
suffix:semicolon
id|ccb-&gt;ccb_h.status
op_assign
id|CAM_REQ_CMP
suffix:semicolon
id|LIST_FOREACH
c_func
(paren
id|scb
comma
op_amp
id|ahd-&gt;pending_scbs
comma
id|pending_links
)paren
(brace
r_struct
id|ccb_hdr
op_star
id|ccbh
suffix:semicolon
id|ccbh
op_assign
op_amp
id|scb-&gt;io_ctx-&gt;ccb_h
suffix:semicolon
r_if
c_cond
(paren
id|ccbh-&gt;func_code
op_eq
id|XPT_CONT_TARGET_IO
op_logical_and
op_logical_neg
id|xpt_path_comp
c_func
(paren
id|ccbh-&gt;path
comma
id|ccb-&gt;ccb_h.path
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;CTIO pending&bslash;n&quot;
)paren
suffix:semicolon
id|ccb-&gt;ccb_h.status
op_assign
id|CAM_REQ_INVALID
suffix:semicolon
id|ahd_unlock
c_func
(paren
id|ahd
comma
op_amp
id|s
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|SLIST_FIRST
c_func
(paren
op_amp
id|lstate-&gt;accept_tios
)paren
op_ne
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;ATIOs pending&bslash;n&quot;
)paren
suffix:semicolon
id|ccb-&gt;ccb_h.status
op_assign
id|CAM_REQ_INVALID
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SLIST_FIRST
c_func
(paren
op_amp
id|lstate-&gt;immed_notifies
)paren
op_ne
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;INOTs pending&bslash;n&quot;
)paren
suffix:semicolon
id|ccb-&gt;ccb_h.status
op_assign
id|CAM_REQ_INVALID
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ccb-&gt;ccb_h.status
op_ne
id|CAM_REQ_CMP
)paren
(brace
id|ahd_unlock
c_func
(paren
id|ahd
comma
op_amp
id|s
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|xpt_print_path
c_func
(paren
id|ccb-&gt;ccb_h.path
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Target mode disabled&bslash;n&quot;
)paren
suffix:semicolon
id|xpt_free_path
c_func
(paren
id|lstate-&gt;path
)paren
suffix:semicolon
id|free
c_func
(paren
id|lstate
comma
id|M_DEVBUF
)paren
suffix:semicolon
id|ahd_pause
c_func
(paren
id|ahd
)paren
suffix:semicolon
multiline_comment|/* Can we clean up the target too? */
r_if
c_cond
(paren
id|target
op_ne
id|CAM_TARGET_WILDCARD
)paren
(brace
id|tstate-&gt;enabled_luns
(braket
id|lun
)braket
op_assign
l_int|NULL
suffix:semicolon
id|ahd-&gt;enabled_luns
op_decrement
suffix:semicolon
r_for
c_loop
(paren
id|empty
op_assign
l_int|1
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|tstate-&gt;enabled_luns
(braket
id|i
)braket
op_ne
l_int|NULL
)paren
(brace
id|empty
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|empty
)paren
(brace
id|ahd_free_tstate
c_func
(paren
id|ahd
comma
id|target
comma
id|channel
comma
multiline_comment|/*force*/
id|FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ahd-&gt;features
op_amp
id|AHD_MULTI_TID
)paren
(brace
id|u_int
id|targid_mask
suffix:semicolon
id|targid_mask
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|TARGID
)paren
op_or
(paren
id|ahd_inb
c_func
(paren
id|ahd
comma
id|TARGID
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
id|targid_mask
op_and_assign
op_complement
id|target_mask
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|TARGID
comma
id|targid_mask
)paren
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|TARGID
op_plus
l_int|1
comma
(paren
id|targid_mask
op_rshift
l_int|8
)paren
)paren
suffix:semicolon
id|ahd_update_scsiid
c_func
(paren
id|ahd
comma
id|targid_mask
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|ahd-&gt;black_hole
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We can&squot;t allow selections without&n;&t;&t;&t; * our black hole device.&n;&t;&t;&t; */
id|empty
op_assign
id|TRUE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ahd-&gt;enabled_luns
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Disallow select-in */
id|u_int
id|scsiseq1
suffix:semicolon
id|scsiseq1
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSISEQ_TEMPLATE
)paren
suffix:semicolon
id|scsiseq1
op_and_assign
op_complement
id|ENSELI
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCSISEQ_TEMPLATE
comma
id|scsiseq1
)paren
suffix:semicolon
id|scsiseq1
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSISEQ1
)paren
suffix:semicolon
id|scsiseq1
op_and_assign
op_complement
id|ENSELI
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCSISEQ1
comma
id|scsiseq1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;features
op_amp
id|AHD_MULTIROLE
)paren
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Configuring Initiator Mode&bslash;n&quot;
)paren
suffix:semicolon
id|ahd-&gt;flags
op_and_assign
op_complement
id|AHD_TARGETROLE
suffix:semicolon
id|ahd-&gt;flags
op_or_assign
id|AHD_INITIATORROLE
suffix:semicolon
id|ahd_pause
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_loadseq
c_func
(paren
id|ahd
)paren
suffix:semicolon
)brace
)brace
id|ahd_unpause
c_func
(paren
id|ahd
)paren
suffix:semicolon
id|ahd_unlock
c_func
(paren
id|ahd
comma
op_amp
id|s
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
r_static
r_void
DECL|function|ahd_update_scsiid
id|ahd_update_scsiid
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
id|u_int
id|targid_mask
)paren
(brace
macro_line|#if NOT_YET
id|u_int
id|scsiid_mask
suffix:semicolon
id|u_int
id|scsiid
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ahd-&gt;features
op_amp
id|AHD_MULTI_TID
)paren
op_eq
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;ahd_update_scsiid called on non-multitid unit&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Since we will rely on the TARGID mask&n;&t; * for selection enables, ensure that OID&n;&t; * in SCSIID is not set to some other ID&n;&t; * that we don&squot;t want to allow selections on.&n;&t; */
r_if
c_cond
(paren
(paren
id|ahd-&gt;features
op_amp
id|AHD_ULTRA2
)paren
op_ne
l_int|0
)paren
id|scsiid
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSIID_ULTRA2
)paren
suffix:semicolon
r_else
id|scsiid
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|SCSIID
)paren
suffix:semicolon
id|scsiid_mask
op_assign
l_int|0x1
op_lshift
(paren
id|scsiid
op_amp
id|OID
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|targid_mask
op_amp
id|scsiid_mask
)paren
op_eq
l_int|0
)paren
(brace
id|u_int
id|our_id
suffix:semicolon
multiline_comment|/* ffs counts from 1 */
id|our_id
op_assign
id|ffs
c_func
(paren
id|targid_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|our_id
op_eq
l_int|0
)paren
id|our_id
op_assign
id|ahd-&gt;our_id
suffix:semicolon
r_else
id|our_id
op_decrement
suffix:semicolon
id|scsiid
op_and_assign
id|TID
suffix:semicolon
id|scsiid
op_or_assign
id|our_id
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ahd-&gt;features
op_amp
id|AHD_ULTRA2
)paren
op_ne
l_int|0
)paren
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCSIID_ULTRA2
comma
id|scsiid
)paren
suffix:semicolon
r_else
id|ahd_outb
c_func
(paren
id|ahd
comma
id|SCSIID
comma
id|scsiid
)paren
suffix:semicolon
macro_line|#endif
)brace
r_void
DECL|function|ahd_run_tqinfifo
id|ahd_run_tqinfifo
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_int
id|paused
)paren
(brace
r_struct
id|target_cmd
op_star
id|cmd
suffix:semicolon
id|ahd_sync_tqinfifo
c_func
(paren
id|ahd
comma
id|BUS_DMASYNC_POSTREAD
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|cmd
op_assign
op_amp
id|ahd-&gt;targetcmds
(braket
id|ahd-&gt;tqinfifonext
)braket
)paren
op_member_access_from_pointer
id|cmd_valid
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Only advance through the queue if we&n;&t;&t; * have the resources to process the command.&n;&t;&t; */
r_if
c_cond
(paren
id|ahd_handle_target_cmd
c_func
(paren
id|ahd
comma
id|cmd
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
id|cmd-&gt;cmd_valid
op_assign
l_int|0
suffix:semicolon
id|ahd_dmamap_sync
c_func
(paren
id|ahd
comma
id|ahd-&gt;shared_data_dmat
comma
id|ahd-&gt;shared_data_dmamap
comma
id|ahd_targetcmd_offset
c_func
(paren
id|ahd
comma
id|ahd-&gt;tqinfifonext
)paren
comma
r_sizeof
(paren
r_struct
id|target_cmd
)paren
comma
id|BUS_DMASYNC_PREREAD
)paren
suffix:semicolon
id|ahd-&gt;tqinfifonext
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Lazily update our position in the target mode incoming&n;&t;&t; * command queue as seen by the sequencer.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ahd-&gt;tqinfifonext
op_amp
(paren
id|HOST_TQINPOS
op_minus
l_int|1
)paren
)paren
op_eq
l_int|1
)paren
(brace
id|u_int
id|hs_mailbox
suffix:semicolon
id|hs_mailbox
op_assign
id|ahd_inb
c_func
(paren
id|ahd
comma
id|HS_MAILBOX
)paren
suffix:semicolon
id|hs_mailbox
op_and_assign
op_complement
id|HOST_TQINPOS
suffix:semicolon
id|hs_mailbox
op_or_assign
id|ahd-&gt;tqinfifonext
op_amp
id|HOST_TQINPOS
suffix:semicolon
id|ahd_outb
c_func
(paren
id|ahd
comma
id|HS_MAILBOX
comma
id|hs_mailbox
)paren
suffix:semicolon
)brace
)brace
)brace
r_static
r_int
DECL|function|ahd_handle_target_cmd
id|ahd_handle_target_cmd
c_func
(paren
r_struct
id|ahd_softc
op_star
id|ahd
comma
r_struct
id|target_cmd
op_star
id|cmd
)paren
(brace
r_struct
id|ahd_tmode_tstate
op_star
id|tstate
suffix:semicolon
r_struct
id|ahd_tmode_lstate
op_star
id|lstate
suffix:semicolon
r_struct
id|ccb_accept_tio
op_star
id|atio
suffix:semicolon
r_uint8
op_star
id|byte
suffix:semicolon
r_int
id|initiator
suffix:semicolon
r_int
id|target
suffix:semicolon
r_int
id|lun
suffix:semicolon
id|initiator
op_assign
id|SCSIID_TARGET
c_func
(paren
id|ahd
comma
id|cmd-&gt;scsiid
)paren
suffix:semicolon
id|target
op_assign
id|SCSIID_OUR_ID
c_func
(paren
id|cmd-&gt;scsiid
)paren
suffix:semicolon
id|lun
op_assign
(paren
id|cmd-&gt;identify
op_amp
id|MSG_IDENTIFY_LUNMASK
)paren
suffix:semicolon
id|byte
op_assign
id|cmd-&gt;bytes
suffix:semicolon
id|tstate
op_assign
id|ahd-&gt;enabled_targets
(braket
id|target
)braket
suffix:semicolon
id|lstate
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|tstate
op_ne
l_int|NULL
)paren
id|lstate
op_assign
id|tstate-&gt;enabled_luns
(braket
id|lun
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Commands for disabled luns go to the black hole driver.&n;&t; */
r_if
c_cond
(paren
id|lstate
op_eq
l_int|NULL
)paren
id|lstate
op_assign
id|ahd-&gt;black_hole
suffix:semicolon
id|atio
op_assign
(paren
r_struct
id|ccb_accept_tio
op_star
)paren
id|SLIST_FIRST
c_func
(paren
op_amp
id|lstate-&gt;accept_tios
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atio
op_eq
l_int|NULL
)paren
(brace
id|ahd-&gt;flags
op_or_assign
id|AHD_TQINFIFO_BLOCKED
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Wait for more ATIOs from the peripheral driver for this lun.&n;&t;&t; */
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_else
id|ahd-&gt;flags
op_and_assign
op_complement
id|AHD_TQINFIFO_BLOCKED
suffix:semicolon
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_TQIN
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;Incoming command from %d for %d:%d%s&bslash;n&quot;
comma
id|initiator
comma
id|target
comma
id|lun
comma
id|lstate
op_eq
id|ahd-&gt;black_hole
ques
c_cond
l_string|&quot;(Black Holed)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
macro_line|#endif
id|SLIST_REMOVE_HEAD
c_func
(paren
op_amp
id|lstate-&gt;accept_tios
comma
id|sim_links.sle
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lstate
op_eq
id|ahd-&gt;black_hole
)paren
(brace
multiline_comment|/* Fill in the wildcards */
id|atio-&gt;ccb_h.target_id
op_assign
id|target
suffix:semicolon
id|atio-&gt;ccb_h.target_lun
op_assign
id|lun
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Package it up and send it off to&n;&t; * whomever has this lun enabled.&n;&t; */
id|atio-&gt;sense_len
op_assign
l_int|0
suffix:semicolon
id|atio-&gt;init_id
op_assign
id|initiator
suffix:semicolon
r_if
c_cond
(paren
id|byte
(braket
l_int|0
)braket
op_ne
l_int|0xFF
)paren
(brace
multiline_comment|/* Tag was included */
id|atio-&gt;tag_action
op_assign
op_star
id|byte
op_increment
suffix:semicolon
id|atio-&gt;tag_id
op_assign
op_star
id|byte
op_increment
suffix:semicolon
id|atio-&gt;ccb_h.flags
op_assign
id|CAM_TAG_ACTION_VALID
suffix:semicolon
)brace
r_else
(brace
id|atio-&gt;ccb_h.flags
op_assign
l_int|0
suffix:semicolon
)brace
id|byte
op_increment
suffix:semicolon
multiline_comment|/* Okay.  Now determine the cdb size based on the command code */
r_switch
c_cond
(paren
op_star
id|byte
op_rshift
id|CMD_GROUP_CODE_SHIFT
)paren
(brace
r_case
l_int|0
suffix:colon
id|atio-&gt;cdb_len
op_assign
l_int|6
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
r_case
l_int|2
suffix:colon
id|atio-&gt;cdb_len
op_assign
l_int|10
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|atio-&gt;cdb_len
op_assign
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|atio-&gt;cdb_len
op_assign
l_int|12
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
r_default
suffix:colon
multiline_comment|/* Only copy the opcode. */
id|atio-&gt;cdb_len
op_assign
l_int|1
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Reserved or VU command code type encountered&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|atio-&gt;cdb_io.cdb_bytes
comma
id|byte
comma
id|atio-&gt;cdb_len
)paren
suffix:semicolon
id|atio-&gt;ccb_h.status
op_or_assign
id|CAM_CDB_RECVD
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmd-&gt;identify
op_amp
id|MSG_IDENTIFY_DISCFLAG
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * We weren&squot;t allowed to disconnect.&n;&t;&t; * We&squot;re hanging on the bus until a&n;&t;&t; * continue target I/O comes in response&n;&t;&t; * to this accept tio.&n;&t;&t; */
macro_line|#ifdef AHD_DEBUG
r_if
c_cond
(paren
(paren
id|ahd_debug
op_amp
id|AHD_SHOW_TQIN
)paren
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;Received Immediate Command %d:%d:%d - %p&bslash;n&quot;
comma
id|initiator
comma
id|target
comma
id|lun
comma
id|ahd-&gt;pending_device
)paren
suffix:semicolon
macro_line|#endif
id|ahd-&gt;pending_device
op_assign
id|lstate
suffix:semicolon
id|ahd_freeze_ccb
c_func
(paren
(paren
r_union
id|ccb
op_star
)paren
id|atio
)paren
suffix:semicolon
id|atio-&gt;ccb_h.flags
op_or_assign
id|CAM_DIS_DISCONNECT
suffix:semicolon
)brace
id|xpt_done
c_func
(paren
(paren
r_union
id|ccb
op_star
)paren
id|atio
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
