multiline_comment|/*&n; *  scsi_error.c Copyright (C) 1997 Eric Youngdale&n; *&n; *  SCSI error/timeout handling&n; *      Initial versions: Eric Youngdale.  Based upon conversations with&n; *                        Leonard Zubkoff and David Miller at Linux Expo, &n; *                        ideas originating from all over the place.&n; *&n; *&t;Restructured scsi_unjam_host and associated functions.&n; *&t;September 04, 2002 Mike Anderson (andmike@us.ibm.com)&n; *&n; *&t;Forward port of Russell King&squot;s (rmk@arm.linux.org.uk) changes and&n; *&t;minor  cleanups.&n; *&t;September 30, 2002 Mike Anderson (andmike@us.ibm.com)&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;scsi/scsi.h&gt;
macro_line|#include &lt;scsi/scsi_dbg.h&gt;
macro_line|#include &lt;scsi/scsi_device.h&gt;
macro_line|#include &lt;scsi/scsi_eh.h&gt;
macro_line|#include &lt;scsi/scsi_host.h&gt;
macro_line|#include &lt;scsi/scsi_ioctl.h&gt;
macro_line|#include &lt;scsi/scsi_request.h&gt;
macro_line|#include &quot;scsi_priv.h&quot;
macro_line|#include &quot;scsi_logging.h&quot;
DECL|macro|SENSE_TIMEOUT
mdefine_line|#define SENSE_TIMEOUT&t;&t;(10*HZ)
DECL|macro|START_UNIT_TIMEOUT
mdefine_line|#define START_UNIT_TIMEOUT&t;(30*HZ)
multiline_comment|/*&n; * These should *probably* be handled by the host itself.&n; * Since it is allowed to sleep, it probably should.&n; */
DECL|macro|BUS_RESET_SETTLE_TIME
mdefine_line|#define BUS_RESET_SETTLE_TIME   (10)
DECL|macro|HOST_RESET_SETTLE_TIME
mdefine_line|#define HOST_RESET_SETTLE_TIME  (10)
multiline_comment|/* called with shost-&gt;host_lock held */
DECL|function|scsi_eh_wakeup
r_void
id|scsi_eh_wakeup
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
)paren
(brace
r_if
c_cond
(paren
id|shost-&gt;host_busy
op_eq
id|shost-&gt;host_failed
)paren
(brace
id|up
c_func
(paren
id|shost-&gt;eh_wait
)paren
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;Waking error handler thread&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * scsi_eh_scmd_add - add scsi cmd to error handling.&n; * @scmd:&t;scmd to run eh on.&n; * @eh_flag:&t;optional SCSI_EH flag.&n; *&n; * Return value:&n; *&t;0 on failure.&n; **/
DECL|function|scsi_eh_scmd_add
r_int
id|scsi_eh_scmd_add
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|scmd
comma
r_int
id|eh_flag
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|shost
op_assign
id|scmd-&gt;device-&gt;host
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|shost-&gt;eh_wait
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|shost-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|scsi_eh_eflags_set
c_func
(paren
id|scmd
comma
id|eh_flag
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME: Can we stop setting owner and state.&n;&t; */
id|scmd-&gt;owner
op_assign
id|SCSI_OWNER_ERROR_HANDLER
suffix:semicolon
id|scmd-&gt;state
op_assign
id|SCSI_STATE_FAILED
suffix:semicolon
multiline_comment|/*&n;&t; * Set the serial_number_at_timeout to the current&n;&t; * serial_number&n;&t; */
id|scmd-&gt;serial_number_at_timeout
op_assign
id|scmd-&gt;serial_number
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|scmd-&gt;eh_entry
comma
op_amp
id|shost-&gt;eh_cmd_q
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|SHOST_RECOVERY
comma
op_amp
id|shost-&gt;shost_state
)paren
suffix:semicolon
id|shost-&gt;host_failed
op_increment
suffix:semicolon
id|scsi_eh_wakeup
c_func
(paren
id|shost
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|shost-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_add_timer - Start timeout timer for a single scsi command.&n; * @scmd:&t;scsi command that is about to start running.&n; * @timeout:&t;amount of time to allow this command to run.&n; * @complete:&t;timeout function to call if timer isn&squot;t canceled.&n; *&n; * Notes:&n; *    This should be turned into an inline function.  Each scsi command&n; *    has its own timer, and as it is added to the queue, we set up the&n; *    timer.  When the command completes, we cancel the timer.&n; **/
DECL|function|scsi_add_timer
r_void
id|scsi_add_timer
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|scmd
comma
r_int
id|timeout
comma
r_void
(paren
op_star
id|complete
)paren
(paren
r_struct
id|scsi_cmnd
op_star
)paren
)paren
(brace
multiline_comment|/*&n;&t; * If the clock was already running for this command, then&n;&t; * first delete the timer.  The timer handling code gets rather&n;&t; * confused if we don&squot;t do this.&n;&t; */
r_if
c_cond
(paren
id|scmd-&gt;eh_timeout.function
)paren
id|del_timer
c_func
(paren
op_amp
id|scmd-&gt;eh_timeout
)paren
suffix:semicolon
id|scmd-&gt;eh_timeout.data
op_assign
(paren
r_int
r_int
)paren
id|scmd
suffix:semicolon
id|scmd-&gt;eh_timeout.expires
op_assign
id|jiffies
op_plus
id|timeout
suffix:semicolon
id|scmd-&gt;eh_timeout.function
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
r_int
r_int
)paren
)paren
id|complete
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;%s: scmd: %p, time:&quot;
l_string|&quot; %d, (%p)&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|scmd
comma
id|timeout
comma
id|complete
)paren
)paren
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|scmd-&gt;eh_timeout
)paren
suffix:semicolon
)brace
DECL|variable|scsi_add_timer
id|EXPORT_SYMBOL
c_func
(paren
id|scsi_add_timer
)paren
suffix:semicolon
multiline_comment|/**&n; * scsi_delete_timer - Delete/cancel timer for a given function.&n; * @scmd:&t;Cmd that we are canceling timer for&n; *&n; * Notes:&n; *     This should be turned into an inline function.&n; *&n; * Return value:&n; *     1 if we were able to detach the timer.  0 if we blew it, and the&n; *     timer function has already started to run.&n; **/
DECL|function|scsi_delete_timer
r_int
id|scsi_delete_timer
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|scmd
)paren
(brace
r_int
id|rtn
suffix:semicolon
id|rtn
op_assign
id|del_timer
c_func
(paren
op_amp
id|scmd-&gt;eh_timeout
)paren
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;%s: scmd: %p,&quot;
l_string|&quot; rtn: %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|scmd
comma
id|rtn
)paren
)paren
suffix:semicolon
id|scmd-&gt;eh_timeout.data
op_assign
(paren
r_int
r_int
)paren
l_int|NULL
suffix:semicolon
id|scmd-&gt;eh_timeout.function
op_assign
l_int|NULL
suffix:semicolon
r_return
id|rtn
suffix:semicolon
)brace
DECL|variable|scsi_delete_timer
id|EXPORT_SYMBOL
c_func
(paren
id|scsi_delete_timer
)paren
suffix:semicolon
multiline_comment|/**&n; * scsi_times_out - Timeout function for normal scsi commands.&n; * @scmd:&t;Cmd that is timing out.&n; *&n; * Notes:&n; *     We do not need to lock this.  There is the potential for a race&n; *     only in that the normal completion handling might run, but if the&n; *     normal completion function determines that the timer has already&n; *     fired, then it mustn&squot;t do anything.&n; **/
DECL|function|scsi_times_out
r_void
id|scsi_times_out
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|scmd
)paren
(brace
id|scsi_log_completion
c_func
(paren
id|scmd
comma
id|TIMEOUT_ERROR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scmd-&gt;device-&gt;host-&gt;hostt-&gt;eh_timed_out
)paren
r_switch
c_cond
(paren
id|scmd-&gt;device-&gt;host-&gt;hostt
op_member_access_from_pointer
id|eh_timed_out
c_func
(paren
id|scmd
)paren
)paren
(brace
r_case
id|EH_HANDLED
suffix:colon
id|__scsi_done
c_func
(paren
id|scmd
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|EH_RESET_TIMER
suffix:colon
multiline_comment|/* This allows a single retry even of a command&n;&t;&t;&t; * with allowed == 0 */
r_if
c_cond
(paren
id|scmd-&gt;retries
op_increment
OG
id|scmd-&gt;allowed
)paren
r_break
suffix:semicolon
id|scsi_add_timer
c_func
(paren
id|scmd
comma
id|scmd-&gt;timeout_per_command
comma
id|scsi_times_out
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|EH_NOT_HANDLED
suffix:colon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|scsi_eh_scmd_add
c_func
(paren
id|scmd
comma
id|SCSI_EH_CANCEL_CMD
)paren
)paren
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Error handler thread not present at %p %p %s %d&quot;
comma
id|scmd
comma
id|scmd-&gt;device-&gt;host
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * scsi_block_when_processing_errors - Prevent cmds from being queued.&n; * @sdev:&t;Device on which we are performing recovery.&n; *&n; * Description:&n; *     We block until the host is out of error recovery, and then check to&n; *     see whether the host or the device is offline.&n; *&n; * Return value:&n; *     0 when dev was taken offline by error recovery. 1 OK to proceed.&n; **/
DECL|function|scsi_block_when_processing_errors
r_int
id|scsi_block_when_processing_errors
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
)paren
(brace
r_int
id|online
suffix:semicolon
id|wait_event
c_func
(paren
id|sdev-&gt;host-&gt;host_wait
comma
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|SHOST_RECOVERY
comma
op_amp
id|sdev-&gt;host-&gt;shost_state
)paren
)paren
)paren
suffix:semicolon
id|online
op_assign
id|scsi_device_online
c_func
(paren
id|sdev
)paren
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;%s: rtn: %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|online
)paren
)paren
suffix:semicolon
r_return
id|online
suffix:semicolon
)brace
DECL|variable|scsi_block_when_processing_errors
id|EXPORT_SYMBOL
c_func
(paren
id|scsi_block_when_processing_errors
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SCSI_LOGGING
multiline_comment|/**&n; * scsi_eh_prt_fail_stats - Log info on failures.&n; * @shost:&t;scsi host being recovered.&n; * @work_q:&t;Queue of scsi cmds to process.&n; **/
DECL|function|scsi_eh_prt_fail_stats
r_static
r_inline
r_void
id|scsi_eh_prt_fail_stats
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
comma
r_struct
id|list_head
op_star
id|work_q
)paren
(brace
r_struct
id|scsi_cmnd
op_star
id|scmd
suffix:semicolon
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
r_int
id|total_failures
op_assign
l_int|0
suffix:semicolon
r_int
id|cmd_failed
op_assign
l_int|0
suffix:semicolon
r_int
id|cmd_cancel
op_assign
l_int|0
suffix:semicolon
r_int
id|devices_failed
op_assign
l_int|0
suffix:semicolon
id|shost_for_each_device
c_func
(paren
id|sdev
comma
id|shost
)paren
(brace
id|list_for_each_entry
c_func
(paren
id|scmd
comma
id|work_q
comma
id|eh_entry
)paren
(brace
r_if
c_cond
(paren
id|scmd-&gt;device
op_eq
id|sdev
)paren
(brace
op_increment
id|total_failures
suffix:semicolon
r_if
c_cond
(paren
id|scsi_eh_eflags_chk
c_func
(paren
id|scmd
comma
id|SCSI_EH_CANCEL_CMD
)paren
)paren
op_increment
id|cmd_cancel
suffix:semicolon
r_else
op_increment
id|cmd_failed
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cmd_cancel
op_logical_or
id|cmd_failed
)paren
(brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;%s: %d:%d:%d:%d cmds failed: %d,&quot;
l_string|&quot; cancel: %d&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|shost-&gt;host_no
comma
id|sdev-&gt;channel
comma
id|sdev-&gt;id
comma
id|sdev-&gt;lun
comma
id|cmd_failed
comma
id|cmd_cancel
)paren
)paren
suffix:semicolon
id|cmd_cancel
op_assign
l_int|0
suffix:semicolon
id|cmd_failed
op_assign
l_int|0
suffix:semicolon
op_increment
id|devices_failed
suffix:semicolon
)brace
)brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;Total of %d commands on %d&quot;
l_string|&quot; devices require eh work&bslash;n&quot;
comma
id|total_failures
comma
id|devices_failed
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/**&n; * scsi_check_sense - Examine scsi cmd sense&n; * @scmd:&t;Cmd to have sense checked.&n; *&n; * Return value:&n; * &t;SUCCESS or FAILED or NEEDS_RETRY&n; *&n; * Notes:&n; *&t;When a deferred error is detected the current command has&n; *&t;not been executed and needs retrying.&n; **/
DECL|function|scsi_check_sense
r_static
r_int
id|scsi_check_sense
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|scmd
)paren
(brace
r_struct
id|scsi_sense_hdr
id|sshdr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_command_normalize_sense
c_func
(paren
id|scmd
comma
op_amp
id|sshdr
)paren
)paren
r_return
id|FAILED
suffix:semicolon
multiline_comment|/* no valid sense data */
r_if
c_cond
(paren
id|scsi_sense_is_deferred
c_func
(paren
op_amp
id|sshdr
)paren
)paren
r_return
id|NEEDS_RETRY
suffix:semicolon
multiline_comment|/*&n;&t; * Previous logic looked for FILEMARK, EOM or ILI which are&n;&t; * mainly associated with tapes and returned SUCCESS.&n;&t; */
r_if
c_cond
(paren
id|sshdr.response_code
op_eq
l_int|0x70
)paren
(brace
multiline_comment|/* fixed format */
r_if
c_cond
(paren
id|scmd-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xe0
)paren
r_return
id|SUCCESS
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * descriptor format: look for &quot;stream commands sense data&n;&t;&t; * descriptor&quot; (see SSC-3). Assume single sense data&n;&t;&t; * descriptor. Ignore ILI from SBC-2 READ LONG and WRITE LONG.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|sshdr.additional_length
OG
l_int|3
)paren
op_logical_and
(paren
id|scmd-&gt;sense_buffer
(braket
l_int|8
)braket
op_eq
l_int|0x4
)paren
op_logical_and
(paren
id|scmd-&gt;sense_buffer
(braket
l_int|11
)braket
op_amp
l_int|0xe0
)paren
)paren
r_return
id|SUCCESS
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|sshdr.sense_key
)paren
(brace
r_case
id|NO_SENSE
suffix:colon
r_return
id|SUCCESS
suffix:semicolon
r_case
id|RECOVERED_ERROR
suffix:colon
r_return
multiline_comment|/* soft_error */
id|SUCCESS
suffix:semicolon
r_case
id|ABORTED_COMMAND
suffix:colon
r_return
id|NEEDS_RETRY
suffix:semicolon
r_case
id|NOT_READY
suffix:colon
r_case
id|UNIT_ATTENTION
suffix:colon
multiline_comment|/*&n;&t;&t; * if we are expecting a cc/ua because of a bus reset that we&n;&t;&t; * performed, treat this just as a retry.  otherwise this is&n;&t;&t; * information that we should pass up to the upper-level driver&n;&t;&t; * so that we can deal with it there.&n;&t;&t; */
r_if
c_cond
(paren
id|scmd-&gt;device-&gt;expecting_cc_ua
)paren
(brace
id|scmd-&gt;device-&gt;expecting_cc_ua
op_assign
l_int|0
suffix:semicolon
r_return
id|NEEDS_RETRY
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * if the device is in the process of becoming ready, we &n;&t;&t; * should retry.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|sshdr.asc
op_eq
l_int|0x04
)paren
op_logical_and
(paren
id|sshdr.ascq
op_eq
l_int|0x01
)paren
)paren
r_return
id|NEEDS_RETRY
suffix:semicolon
multiline_comment|/*&n;&t;&t; * if the device is not started, we need to wake&n;&t;&t; * the error handler to start the motor&n;&t;&t; */
r_if
c_cond
(paren
id|scmd-&gt;device-&gt;allow_restart
op_logical_and
(paren
id|sshdr.asc
op_eq
l_int|0x04
)paren
op_logical_and
(paren
id|sshdr.ascq
op_eq
l_int|0x02
)paren
)paren
r_return
id|FAILED
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
multiline_comment|/* these three are not supported */
r_case
id|COPY_ABORTED
suffix:colon
r_case
id|VOLUME_OVERFLOW
suffix:colon
r_case
id|MISCOMPARE
suffix:colon
r_return
id|SUCCESS
suffix:semicolon
r_case
id|MEDIUM_ERROR
suffix:colon
r_return
id|NEEDS_RETRY
suffix:semicolon
r_case
id|ILLEGAL_REQUEST
suffix:colon
r_case
id|BLANK_CHECK
suffix:colon
r_case
id|DATA_PROTECT
suffix:colon
r_case
id|HARDWARE_ERROR
suffix:colon
r_default
suffix:colon
r_return
id|SUCCESS
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * scsi_eh_completed_normally - Disposition a eh cmd on return from LLD.&n; * @scmd:&t;SCSI cmd to examine.&n; *&n; * Notes:&n; *    This is *only* called when we are examining the status of commands&n; *    queued during error recovery.  the main difference here is that we&n; *    don&squot;t allow for the possibility of retries here, and we are a lot&n; *    more restrictive about what we consider acceptable.&n; **/
DECL|function|scsi_eh_completed_normally
r_static
r_int
id|scsi_eh_completed_normally
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|scmd
)paren
(brace
multiline_comment|/*&n;&t; * first check the host byte, to see if there is anything in there&n;&t; * that would indicate what we need to do.&n;&t; */
r_if
c_cond
(paren
id|host_byte
c_func
(paren
id|scmd-&gt;result
)paren
op_eq
id|DID_RESET
)paren
(brace
multiline_comment|/*&n;&t;&t; * rats.  we are already in the error handler, so we now&n;&t;&t; * get to try and figure out what to do next.  if the sense&n;&t;&t; * is valid, we have a pretty good idea of what to do.&n;&t;&t; * if not, we mark it as FAILED.&n;&t;&t; */
r_return
id|scsi_check_sense
c_func
(paren
id|scmd
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|host_byte
c_func
(paren
id|scmd-&gt;result
)paren
op_ne
id|DID_OK
)paren
r_return
id|FAILED
suffix:semicolon
multiline_comment|/*&n;&t; * next, check the message byte.&n;&t; */
r_if
c_cond
(paren
id|msg_byte
c_func
(paren
id|scmd-&gt;result
)paren
op_ne
id|COMMAND_COMPLETE
)paren
r_return
id|FAILED
suffix:semicolon
multiline_comment|/*&n;&t; * now, check the status byte to see if this indicates&n;&t; * anything special.&n;&t; */
r_switch
c_cond
(paren
id|status_byte
c_func
(paren
id|scmd-&gt;result
)paren
)paren
(brace
r_case
id|GOOD
suffix:colon
r_case
id|COMMAND_TERMINATED
suffix:colon
r_return
id|SUCCESS
suffix:semicolon
r_case
id|CHECK_CONDITION
suffix:colon
r_return
id|scsi_check_sense
c_func
(paren
id|scmd
)paren
suffix:semicolon
r_case
id|CONDITION_GOOD
suffix:colon
r_case
id|INTERMEDIATE_GOOD
suffix:colon
r_case
id|INTERMEDIATE_C_GOOD
suffix:colon
multiline_comment|/*&n;&t;&t; * who knows?  FIXME(eric)&n;&t;&t; */
r_return
id|SUCCESS
suffix:semicolon
r_case
id|BUSY
suffix:colon
r_case
id|QUEUE_FULL
suffix:colon
r_case
id|RESERVATION_CONFLICT
suffix:colon
r_default
suffix:colon
r_return
id|FAILED
suffix:semicolon
)brace
r_return
id|FAILED
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_eh_times_out - timeout function for error handling.&n; * @scmd:&t;Cmd that is timing out.&n; *&n; * Notes:&n; *    During error handling, the kernel thread will be sleeping waiting&n; *    for some action to complete on the device.  our only job is to&n; *    record that it timed out, and to wake up the thread.&n; **/
DECL|function|scsi_eh_times_out
r_static
r_void
id|scsi_eh_times_out
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|scmd
)paren
(brace
id|scsi_eh_eflags_set
c_func
(paren
id|scmd
comma
id|SCSI_EH_REC_TIMEOUT
)paren
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;%s: scmd:%p&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|scmd
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scmd-&gt;device-&gt;host-&gt;eh_action
)paren
id|up
c_func
(paren
id|scmd-&gt;device-&gt;host-&gt;eh_action
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_eh_done - Completion function for error handling.&n; * @scmd:&t;Cmd that is done.&n; **/
DECL|function|scsi_eh_done
r_static
r_void
id|scsi_eh_done
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|scmd
)paren
(brace
multiline_comment|/*&n;&t; * if the timeout handler is already running, then just set the&n;&t; * flag which says we finished late, and return.  we have no&n;&t; * way of stopping the timeout handler from running, so we must&n;&t; * always defer to it.&n;&t; */
r_if
c_cond
(paren
id|del_timer
c_func
(paren
op_amp
id|scmd-&gt;eh_timeout
)paren
)paren
(brace
id|scmd-&gt;request-&gt;rq_status
op_assign
id|RQ_SCSI_DONE
suffix:semicolon
id|scmd-&gt;owner
op_assign
id|SCSI_OWNER_ERROR_HANDLER
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;%s scmd: %p result: %x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|scmd
comma
id|scmd-&gt;result
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scmd-&gt;device-&gt;host-&gt;eh_action
)paren
id|up
c_func
(paren
id|scmd-&gt;device-&gt;host-&gt;eh_action
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * scsi_send_eh_cmnd  - send a cmd to a device as part of error recovery.&n; * @scmd:&t;SCSI Cmd to send.&n; * @timeout:&t;Timeout for cmd.&n; *&n; * Notes:&n; *    The initialization of the structures is quite a bit different in&n; *    this case, and furthermore, there is a different completion handler&n; *    vs scsi_dispatch_cmd.&n; * Return value:&n; *    SUCCESS or FAILED or NEEDS_RETRY&n; **/
DECL|function|scsi_send_eh_cmnd
r_static
r_int
id|scsi_send_eh_cmnd
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|scmd
comma
r_int
id|timeout
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
op_assign
id|scmd-&gt;device-&gt;host
suffix:semicolon
id|DECLARE_MUTEX_LOCKED
c_func
(paren
id|sem
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|rtn
op_assign
id|SUCCESS
suffix:semicolon
multiline_comment|/*&n;&t; * we will use a queued command if possible, otherwise we will&n;&t; * emulate the queuing and calling of completion function ourselves.&n;&t; */
id|scmd-&gt;owner
op_assign
id|SCSI_OWNER_LOWLEVEL
suffix:semicolon
r_if
c_cond
(paren
id|scmd-&gt;device-&gt;scsi_level
op_le
id|SCSI_2
)paren
id|scmd-&gt;cmnd
(braket
l_int|1
)braket
op_assign
(paren
id|scmd-&gt;cmnd
(braket
l_int|1
)braket
op_amp
l_int|0x1f
)paren
op_or
(paren
id|scmd-&gt;device-&gt;lun
op_lshift
l_int|5
op_amp
l_int|0xe0
)paren
suffix:semicolon
id|scsi_add_timer
c_func
(paren
id|scmd
comma
id|timeout
comma
id|scsi_eh_times_out
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set up the semaphore so we wait for the command to complete.&n;&t; */
id|scmd-&gt;device-&gt;host-&gt;eh_action
op_assign
op_amp
id|sem
suffix:semicolon
id|scmd-&gt;request-&gt;rq_status
op_assign
id|RQ_SCSI_BUSY
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|scmd-&gt;device-&gt;host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|scsi_log_send
c_func
(paren
id|scmd
)paren
suffix:semicolon
id|host-&gt;hostt
op_member_access_from_pointer
id|queuecommand
c_func
(paren
id|scmd
comma
id|scsi_eh_done
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|scmd-&gt;device-&gt;host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|sem
)paren
suffix:semicolon
id|scsi_log_completion
c_func
(paren
id|scmd
comma
id|SUCCESS
)paren
suffix:semicolon
id|scmd-&gt;device-&gt;host-&gt;eh_action
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * see if timeout.  if so, tell the host to forget about it.&n;&t; * in other words, we don&squot;t want a callback any more.&n;&t; */
r_if
c_cond
(paren
id|scsi_eh_eflags_chk
c_func
(paren
id|scmd
comma
id|SCSI_EH_REC_TIMEOUT
)paren
)paren
(brace
id|scsi_eh_eflags_clr
c_func
(paren
id|scmd
comma
id|SCSI_EH_REC_TIMEOUT
)paren
suffix:semicolon
id|scmd-&gt;owner
op_assign
id|SCSI_OWNER_LOWLEVEL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * as far as the low level driver is&n;&t;&t; * concerned, this command is still active, so&n;&t;&t; * we must give the low level driver a chance&n;&t;&t; * to abort it. (db) &n;&t;&t; *&n;&t;&t; * FIXME(eric) - we are not tracking whether we could&n;&t;&t; * abort a timed out command or not.  not sure how&n;&t;&t; * we should treat them differently anyways.&n;&t;&t; */
id|spin_lock_irqsave
c_func
(paren
id|scmd-&gt;device-&gt;host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scmd-&gt;device-&gt;host-&gt;hostt-&gt;eh_abort_handler
)paren
id|scmd-&gt;device-&gt;host-&gt;hostt
op_member_access_from_pointer
id|eh_abort_handler
c_func
(paren
id|scmd
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|scmd-&gt;device-&gt;host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|scmd-&gt;request-&gt;rq_status
op_assign
id|RQ_SCSI_DONE
suffix:semicolon
id|scmd-&gt;owner
op_assign
id|SCSI_OWNER_ERROR_HANDLER
suffix:semicolon
id|rtn
op_assign
id|FAILED
suffix:semicolon
)brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;%s: scmd: %p, rtn:%x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|scmd
comma
id|rtn
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * now examine the actual status codes to see whether the command&n;&t; * actually did complete normally.&n;&t; */
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
(brace
id|rtn
op_assign
id|scsi_eh_completed_normally
c_func
(paren
id|scmd
)paren
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;%s: scsi_eh_completed_normally %x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|rtn
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|rtn
)paren
(brace
r_case
id|SUCCESS
suffix:colon
r_case
id|NEEDS_RETRY
suffix:colon
r_case
id|FAILED
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|rtn
op_assign
id|FAILED
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|rtn
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_request_sense - Request sense data from a particular target.&n; * @scmd:&t;SCSI cmd for request sense.&n; *&n; * Notes:&n; *    Some hosts automatically obtain this information, others require&n; *    that we obtain it on our own. This function will *not* return until&n; *    the command either times out, or it completes.&n; **/
DECL|function|scsi_request_sense
r_static
r_int
id|scsi_request_sense
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|scmd
)paren
(brace
r_static
r_int
r_char
id|generic_sense
(braket
l_int|6
)braket
op_assign
(brace
id|REQUEST_SENSE
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|252
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
op_star
id|scsi_result
suffix:semicolon
r_int
id|saved_result
suffix:semicolon
r_int
id|rtn
suffix:semicolon
id|memcpy
c_func
(paren
id|scmd-&gt;cmnd
comma
id|generic_sense
comma
r_sizeof
(paren
id|generic_sense
)paren
)paren
suffix:semicolon
id|scsi_result
op_assign
id|kmalloc
c_func
(paren
l_int|252
comma
id|GFP_ATOMIC
op_or
(paren
id|scmd-&gt;device-&gt;host-&gt;hostt-&gt;unchecked_isa_dma
)paren
ques
c_cond
id|__GFP_DMA
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|scsi_result
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: cannot allocate scsi_result.&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
id|FAILED
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * zero the sense buffer.  some host adapters automatically always&n;&t; * request sense, so it is not a good idea that&n;&t; * scmd-&gt;request_buffer and scmd-&gt;sense_buffer point to the same&n;&t; * address (db).  0 is not a valid sense code. &n;&t; */
id|memset
c_func
(paren
id|scmd-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
(paren
id|scmd-&gt;sense_buffer
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|scsi_result
comma
l_int|0
comma
l_int|252
)paren
suffix:semicolon
id|saved_result
op_assign
id|scmd-&gt;result
suffix:semicolon
id|scmd-&gt;request_buffer
op_assign
id|scsi_result
suffix:semicolon
id|scmd-&gt;request_bufflen
op_assign
l_int|252
suffix:semicolon
id|scmd-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
id|scmd-&gt;cmd_len
op_assign
id|COMMAND_SIZE
c_func
(paren
id|scmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|scmd-&gt;sc_data_direction
op_assign
id|DMA_FROM_DEVICE
suffix:semicolon
id|scmd-&gt;underflow
op_assign
l_int|0
suffix:semicolon
id|rtn
op_assign
id|scsi_send_eh_cmnd
c_func
(paren
id|scmd
comma
id|SENSE_TIMEOUT
)paren
suffix:semicolon
multiline_comment|/* last chance to have valid sense data */
r_if
c_cond
(paren
op_logical_neg
id|SCSI_SENSE_VALID
c_func
(paren
id|scmd
)paren
)paren
(brace
id|memcpy
c_func
(paren
id|scmd-&gt;sense_buffer
comma
id|scmd-&gt;request_buffer
comma
r_sizeof
(paren
id|scmd-&gt;sense_buffer
)paren
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|scsi_result
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * when we eventually call scsi_finish, we really wish to complete&n;&t; * the original request, so let&squot;s restore the original data. (db)&n;&t; */
id|scsi_setup_cmd_retry
c_func
(paren
id|scmd
)paren
suffix:semicolon
id|scmd-&gt;result
op_assign
id|saved_result
suffix:semicolon
r_return
id|rtn
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_eh_finish_cmd - Handle a cmd that eh is finished with.&n; * @scmd:&t;Original SCSI cmd that eh has finished.&n; * @done_q:&t;Queue for processed commands.&n; *&n; * Notes:&n; *    We don&squot;t want to use the normal command completion while we are are&n; *    still handling errors - it may cause other commands to be queued,&n; *    and that would disturb what we are doing.  thus we really want to&n; *    keep a list of pending commands for final completion, and once we&n; *    are ready to leave error handling we handle completion for real.&n; **/
DECL|function|scsi_eh_finish_cmd
r_static
r_void
id|scsi_eh_finish_cmd
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|scmd
comma
r_struct
id|list_head
op_star
id|done_q
)paren
(brace
id|scmd-&gt;device-&gt;host-&gt;host_failed
op_decrement
suffix:semicolon
id|scmd-&gt;state
op_assign
id|SCSI_STATE_BHQUEUE
suffix:semicolon
id|scsi_eh_eflags_clr_all
c_func
(paren
id|scmd
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set this back so that the upper level can correctly free up&n;&t; * things.&n;&t; */
id|scsi_setup_cmd_retry
c_func
(paren
id|scmd
)paren
suffix:semicolon
id|list_move_tail
c_func
(paren
op_amp
id|scmd-&gt;eh_entry
comma
id|done_q
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_eh_get_sense - Get device sense data.&n; * @work_q:&t;Queue of commands to process.&n; * @done_q:&t;Queue of proccessed commands..&n; *&n; * Description:&n; *    See if we need to request sense information.  if so, then get it&n; *    now, so we have a better idea of what to do.  &n; *&n; * Notes:&n; *    This has the unfortunate side effect that if a shost adapter does&n; *    not automatically request sense information, that we end up shutting&n; *    it down before we request it.&n; *&n; *    All drivers should request sense information internally these days,&n; *    so for now all I have to say is tough noogies if you end up in here.&n; *&n; *    XXX: Long term this code should go away, but that needs an audit of&n; *         all LLDDs first.&n; **/
DECL|function|scsi_eh_get_sense
r_static
r_int
id|scsi_eh_get_sense
c_func
(paren
r_struct
id|list_head
op_star
id|work_q
comma
r_struct
id|list_head
op_star
id|done_q
)paren
(brace
r_struct
id|list_head
op_star
id|lh
comma
op_star
id|lh_sf
suffix:semicolon
r_struct
id|scsi_cmnd
op_star
id|scmd
suffix:semicolon
r_int
id|rtn
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|lh
comma
id|lh_sf
comma
id|work_q
)paren
(brace
id|scmd
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|scsi_cmnd
comma
id|eh_entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scsi_eh_eflags_chk
c_func
(paren
id|scmd
comma
id|SCSI_EH_CANCEL_CMD
)paren
op_logical_or
id|SCSI_SENSE_VALID
c_func
(paren
id|scmd
)paren
)paren
r_continue
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|2
comma
id|printk
c_func
(paren
l_string|&quot;%s: requesting sense&quot;
l_string|&quot; for id: %d&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|scmd-&gt;device-&gt;id
)paren
)paren
suffix:semicolon
id|rtn
op_assign
id|scsi_request_sense
c_func
(paren
id|scmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_ne
id|SUCCESS
)paren
r_continue
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;sense requested for %p&quot;
l_string|&quot; result %x&bslash;n&quot;
comma
id|scmd
comma
id|scmd-&gt;result
)paren
)paren
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|scsi_print_sense
c_func
(paren
l_string|&quot;bh&quot;
comma
id|scmd
)paren
)paren
suffix:semicolon
id|rtn
op_assign
id|scsi_decide_disposition
c_func
(paren
id|scmd
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * if the result was normal, then just pass it along to the&n;&t;&t; * upper level.&n;&t;&t; */
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
multiline_comment|/* we don&squot;t want this command reissued, just&n;&t;&t;&t; * finished with the sense data, so set&n;&t;&t;&t; * retries to the max allowed to ensure it&n;&t;&t;&t; * won&squot;t get reissued */
id|scmd-&gt;retries
op_assign
id|scmd-&gt;allowed
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rtn
op_ne
id|NEEDS_RETRY
)paren
r_continue
suffix:semicolon
id|scsi_eh_finish_cmd
c_func
(paren
id|scmd
comma
id|done_q
)paren
suffix:semicolon
)brace
r_return
id|list_empty
c_func
(paren
id|work_q
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_try_to_abort_cmd - Ask host to abort a running command.&n; * @scmd:&t;SCSI cmd to abort from Lower Level.&n; *&n; * Notes:&n; *    This function will not return until the user&squot;s completion function&n; *    has been called.  there is no timeout on this operation.  if the&n; *    author of the low-level driver wishes this operation to be timed,&n; *    they can provide this facility themselves.  helper functions in&n; *    scsi_error.c can be supplied to make this easier to do.&n; **/
DECL|function|scsi_try_to_abort_cmd
r_static
r_int
id|scsi_try_to_abort_cmd
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|scmd
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|rtn
op_assign
id|FAILED
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scmd-&gt;device-&gt;host-&gt;hostt-&gt;eh_abort_handler
)paren
r_return
id|rtn
suffix:semicolon
multiline_comment|/*&n;&t; * scsi_done was called just after the command timed out and before&n;&t; * we had a chance to process it. (db)&n;&t; */
r_if
c_cond
(paren
id|scmd-&gt;serial_number
op_eq
l_int|0
)paren
r_return
id|SUCCESS
suffix:semicolon
id|scmd-&gt;owner
op_assign
id|SCSI_OWNER_LOWLEVEL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|scmd-&gt;device-&gt;host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|rtn
op_assign
id|scmd-&gt;device-&gt;host-&gt;hostt
op_member_access_from_pointer
id|eh_abort_handler
c_func
(paren
id|scmd
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|scmd-&gt;device-&gt;host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|rtn
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_eh_tur - Send TUR to device.&n; * @scmd:&t;Scsi cmd to send TUR&n; *&n; * Return value:&n; *    0 - Device is ready. 1 - Device NOT ready.&n; **/
DECL|function|scsi_eh_tur
r_static
r_int
id|scsi_eh_tur
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|scmd
)paren
(brace
r_static
r_int
r_char
id|tur_command
(braket
l_int|6
)braket
op_assign
(brace
id|TEST_UNIT_READY
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
id|retry_cnt
op_assign
l_int|1
comma
id|rtn
suffix:semicolon
id|retry_tur
suffix:colon
id|memcpy
c_func
(paren
id|scmd-&gt;cmnd
comma
id|tur_command
comma
r_sizeof
(paren
id|tur_command
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * zero the sense buffer.  the scsi spec mandates that any&n;&t; * untransferred sense data should be interpreted as being zero.&n;&t; */
id|memset
c_func
(paren
id|scmd-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
(paren
id|scmd-&gt;sense_buffer
)paren
)paren
suffix:semicolon
id|scmd-&gt;request_buffer
op_assign
l_int|NULL
suffix:semicolon
id|scmd-&gt;request_bufflen
op_assign
l_int|0
suffix:semicolon
id|scmd-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
id|scmd-&gt;cmd_len
op_assign
id|COMMAND_SIZE
c_func
(paren
id|scmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|scmd-&gt;underflow
op_assign
l_int|0
suffix:semicolon
id|scmd-&gt;sc_data_direction
op_assign
id|DMA_NONE
suffix:semicolon
id|rtn
op_assign
id|scsi_send_eh_cmnd
c_func
(paren
id|scmd
comma
id|SENSE_TIMEOUT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * when we eventually call scsi_finish, we really wish to complete&n;&t; * the original request, so let&squot;s restore the original data. (db)&n;&t; */
id|scsi_setup_cmd_retry
c_func
(paren
id|scmd
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * hey, we are done.  let&squot;s look to see what happened.&n;&t; */
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;%s: scmd %p rtn %x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|scmd
comma
id|rtn
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rtn
op_eq
id|NEEDS_RETRY
)paren
r_if
c_cond
(paren
id|retry_cnt
op_decrement
)paren
r_goto
id|retry_tur
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_eh_abort_cmds - abort canceled commands.&n; * @shost:&t;scsi host being recovered.&n; * @eh_done_q:&t;list_head for processed commands.&n; *&n; * Decription:&n; *    Try and see whether or not it makes sense to try and abort the&n; *    running command.  this only works out to be the case if we have one&n; *    command that has timed out.  if the command simply failed, it makes&n; *    no sense to try and abort the command, since as far as the shost&n; *    adapter is concerned, it isn&squot;t running.&n; **/
DECL|function|scsi_eh_abort_cmds
r_static
r_int
id|scsi_eh_abort_cmds
c_func
(paren
r_struct
id|list_head
op_star
id|work_q
comma
r_struct
id|list_head
op_star
id|done_q
)paren
(brace
r_struct
id|list_head
op_star
id|lh
comma
op_star
id|lh_sf
suffix:semicolon
r_struct
id|scsi_cmnd
op_star
id|scmd
suffix:semicolon
r_int
id|rtn
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|lh
comma
id|lh_sf
comma
id|work_q
)paren
(brace
id|scmd
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|scsi_cmnd
comma
id|eh_entry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_eh_eflags_chk
c_func
(paren
id|scmd
comma
id|SCSI_EH_CANCEL_CMD
)paren
)paren
r_continue
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;%s: aborting cmd:&quot;
l_string|&quot;0x%p&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|scmd
)paren
)paren
suffix:semicolon
id|rtn
op_assign
id|scsi_try_to_abort_cmd
c_func
(paren
id|scmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
(brace
id|scsi_eh_eflags_clr
c_func
(paren
id|scmd
comma
id|SCSI_EH_CANCEL_CMD
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_device_online
c_func
(paren
id|scmd-&gt;device
)paren
op_logical_or
op_logical_neg
id|scsi_eh_tur
c_func
(paren
id|scmd
)paren
)paren
(brace
id|scsi_eh_finish_cmd
c_func
(paren
id|scmd
comma
id|done_q
)paren
suffix:semicolon
)brace
)brace
r_else
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;%s: aborting&quot;
l_string|&quot; cmd failed:&quot;
l_string|&quot;0x%p&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|scmd
)paren
)paren
suffix:semicolon
)brace
r_return
id|list_empty
c_func
(paren
id|work_q
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_try_bus_device_reset - Ask host to perform a BDR on a dev&n; * @scmd:&t;SCSI cmd used to send BDR&t;&n; *&n; * Notes:&n; *    There is no timeout for this operation.  if this operation is&n; *    unreliable for a given host, then the host itself needs to put a&n; *    timer on it, and set the host back to a consistent state prior to&n; *    returning.&n; **/
DECL|function|scsi_try_bus_device_reset
r_static
r_int
id|scsi_try_bus_device_reset
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|scmd
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|rtn
op_assign
id|FAILED
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scmd-&gt;device-&gt;host-&gt;hostt-&gt;eh_device_reset_handler
)paren
r_return
id|rtn
suffix:semicolon
id|scmd-&gt;owner
op_assign
id|SCSI_OWNER_LOWLEVEL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|scmd-&gt;device-&gt;host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|rtn
op_assign
id|scmd-&gt;device-&gt;host-&gt;hostt
op_member_access_from_pointer
id|eh_device_reset_handler
c_func
(paren
id|scmd
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|scmd-&gt;device-&gt;host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
(brace
id|scmd-&gt;device-&gt;was_reset
op_assign
l_int|1
suffix:semicolon
id|scmd-&gt;device-&gt;expecting_cc_ua
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|rtn
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_eh_try_stu - Send START_UNIT to device.&n; * @scmd:&t;Scsi cmd to send START_UNIT&n; *&n; * Return value:&n; *    0 - Device is ready. 1 - Device NOT ready.&n; **/
DECL|function|scsi_eh_try_stu
r_static
r_int
id|scsi_eh_try_stu
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|scmd
)paren
(brace
r_static
r_int
r_char
id|stu_command
(braket
l_int|6
)braket
op_assign
(brace
id|START_STOP
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
)brace
suffix:semicolon
r_int
id|rtn
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scmd-&gt;device-&gt;allow_restart
)paren
r_return
l_int|1
suffix:semicolon
id|memcpy
c_func
(paren
id|scmd-&gt;cmnd
comma
id|stu_command
comma
r_sizeof
(paren
id|stu_command
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * zero the sense buffer.  the scsi spec mandates that any&n;&t; * untransferred sense data should be interpreted as being zero.&n;&t; */
id|memset
c_func
(paren
id|scmd-&gt;sense_buffer
comma
l_int|0
comma
r_sizeof
(paren
id|scmd-&gt;sense_buffer
)paren
)paren
suffix:semicolon
id|scmd-&gt;request_buffer
op_assign
l_int|NULL
suffix:semicolon
id|scmd-&gt;request_bufflen
op_assign
l_int|0
suffix:semicolon
id|scmd-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
id|scmd-&gt;cmd_len
op_assign
id|COMMAND_SIZE
c_func
(paren
id|scmd-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|scmd-&gt;underflow
op_assign
l_int|0
suffix:semicolon
id|scmd-&gt;sc_data_direction
op_assign
id|DMA_NONE
suffix:semicolon
id|rtn
op_assign
id|scsi_send_eh_cmnd
c_func
(paren
id|scmd
comma
id|START_UNIT_TIMEOUT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * when we eventually call scsi_finish, we really wish to complete&n;&t; * the original request, so let&squot;s restore the original data. (db)&n;&t; */
id|scsi_setup_cmd_retry
c_func
(paren
id|scmd
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * hey, we are done.  let&squot;s look to see what happened.&n;&t; */
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;%s: scmd %p rtn %x&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|scmd
comma
id|rtn
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_eh_stu - send START_UNIT if needed&n; * @shost:&t;scsi host being recovered.&n; * @eh_done_q:&t;list_head for processed commands.&n; *&n; * Notes:&n; *    If commands are failing due to not ready, initializing command required,&n; *&t;try revalidating the device, which will end up sending a start unit. &n; **/
DECL|function|scsi_eh_stu
r_static
r_int
id|scsi_eh_stu
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
comma
r_struct
id|list_head
op_star
id|work_q
comma
r_struct
id|list_head
op_star
id|done_q
)paren
(brace
r_struct
id|list_head
op_star
id|lh
comma
op_star
id|lh_sf
suffix:semicolon
r_struct
id|scsi_cmnd
op_star
id|scmd
comma
op_star
id|stu_scmd
suffix:semicolon
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
id|shost_for_each_device
c_func
(paren
id|sdev
comma
id|shost
)paren
(brace
id|stu_scmd
op_assign
l_int|NULL
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|scmd
comma
id|work_q
comma
id|eh_entry
)paren
r_if
c_cond
(paren
id|scmd-&gt;device
op_eq
id|sdev
op_logical_and
id|SCSI_SENSE_VALID
c_func
(paren
id|scmd
)paren
op_logical_and
id|scsi_check_sense
c_func
(paren
id|scmd
)paren
op_eq
id|FAILED
)paren
(brace
id|stu_scmd
op_assign
id|scmd
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|stu_scmd
)paren
r_continue
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;%s: Sending START_UNIT to sdev:&quot;
l_string|&quot; 0x%p&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|sdev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_eh_try_stu
c_func
(paren
id|stu_scmd
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|scsi_device_online
c_func
(paren
id|sdev
)paren
op_logical_or
op_logical_neg
id|scsi_eh_tur
c_func
(paren
id|stu_scmd
)paren
)paren
(brace
id|list_for_each_safe
c_func
(paren
id|lh
comma
id|lh_sf
comma
id|work_q
)paren
(brace
id|scmd
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|scsi_cmnd
comma
id|eh_entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scmd-&gt;device
op_eq
id|sdev
)paren
id|scsi_eh_finish_cmd
c_func
(paren
id|scmd
comma
id|done_q
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;%s: START_UNIT failed to sdev:&quot;
l_string|&quot; 0x%p&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|sdev
)paren
)paren
suffix:semicolon
)brace
)brace
r_return
id|list_empty
c_func
(paren
id|work_q
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_eh_bus_device_reset - send bdr if needed&n; * @shost:&t;scsi host being recovered.&n; * @eh_done_q:&t;list_head for processed commands.&n; *&n; * Notes:&n; *    Try a bus device reset.  still, look to see whether we have multiple&n; *    devices that are jammed or not - if we have multiple devices, it&n; *    makes no sense to try bus_device_reset - we really would need to try&n; *    a bus_reset instead. &n; **/
DECL|function|scsi_eh_bus_device_reset
r_static
r_int
id|scsi_eh_bus_device_reset
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
comma
r_struct
id|list_head
op_star
id|work_q
comma
r_struct
id|list_head
op_star
id|done_q
)paren
(brace
r_struct
id|list_head
op_star
id|lh
comma
op_star
id|lh_sf
suffix:semicolon
r_struct
id|scsi_cmnd
op_star
id|scmd
comma
op_star
id|bdr_scmd
suffix:semicolon
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
r_int
id|rtn
suffix:semicolon
id|shost_for_each_device
c_func
(paren
id|sdev
comma
id|shost
)paren
(brace
id|bdr_scmd
op_assign
l_int|NULL
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|scmd
comma
id|work_q
comma
id|eh_entry
)paren
r_if
c_cond
(paren
id|scmd-&gt;device
op_eq
id|sdev
)paren
(brace
id|bdr_scmd
op_assign
id|scmd
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|bdr_scmd
)paren
r_continue
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;%s: Sending BDR sdev:&quot;
l_string|&quot; 0x%p&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|sdev
)paren
)paren
suffix:semicolon
id|rtn
op_assign
id|scsi_try_bus_device_reset
c_func
(paren
id|bdr_scmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|scsi_device_online
c_func
(paren
id|sdev
)paren
op_logical_or
op_logical_neg
id|scsi_eh_tur
c_func
(paren
id|bdr_scmd
)paren
)paren
(brace
id|list_for_each_safe
c_func
(paren
id|lh
comma
id|lh_sf
comma
id|work_q
)paren
(brace
id|scmd
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|scsi_cmnd
comma
id|eh_entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scmd-&gt;device
op_eq
id|sdev
)paren
id|scsi_eh_finish_cmd
c_func
(paren
id|scmd
comma
id|done_q
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;%s: BDR&quot;
l_string|&quot; failed sdev:&quot;
l_string|&quot;0x%p&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|sdev
)paren
)paren
suffix:semicolon
)brace
)brace
r_return
id|list_empty
c_func
(paren
id|work_q
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_try_bus_reset - ask host to perform a bus reset&n; * @scmd:&t;SCSI cmd to send bus reset.&n; **/
DECL|function|scsi_try_bus_reset
r_static
r_int
id|scsi_try_bus_reset
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|scmd
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|rtn
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;%s: Snd Bus RST&bslash;n&quot;
comma
id|__FUNCTION__
)paren
)paren
suffix:semicolon
id|scmd-&gt;owner
op_assign
id|SCSI_OWNER_LOWLEVEL
suffix:semicolon
id|scmd-&gt;serial_number_at_timeout
op_assign
id|scmd-&gt;serial_number
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scmd-&gt;device-&gt;host-&gt;hostt-&gt;eh_bus_reset_handler
)paren
r_return
id|FAILED
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|scmd-&gt;device-&gt;host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|rtn
op_assign
id|scmd-&gt;device-&gt;host-&gt;hostt
op_member_access_from_pointer
id|eh_bus_reset_handler
c_func
(paren
id|scmd
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|scmd-&gt;device-&gt;host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|scmd-&gt;device-&gt;host-&gt;hostt-&gt;skip_settle_delay
)paren
id|ssleep
c_func
(paren
id|BUS_RESET_SETTLE_TIME
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|scmd-&gt;device-&gt;host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|scsi_report_bus_reset
c_func
(paren
id|scmd-&gt;device-&gt;host
comma
id|scmd-&gt;device-&gt;channel
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|scmd-&gt;device-&gt;host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|rtn
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_try_host_reset - ask host adapter to reset itself&n; * @scmd:&t;SCSI cmd to send hsot reset.&n; **/
DECL|function|scsi_try_host_reset
r_static
r_int
id|scsi_try_host_reset
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|scmd
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|rtn
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;%s: Snd Host RST&bslash;n&quot;
comma
id|__FUNCTION__
)paren
)paren
suffix:semicolon
id|scmd-&gt;owner
op_assign
id|SCSI_OWNER_LOWLEVEL
suffix:semicolon
id|scmd-&gt;serial_number_at_timeout
op_assign
id|scmd-&gt;serial_number
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scmd-&gt;device-&gt;host-&gt;hostt-&gt;eh_host_reset_handler
)paren
r_return
id|FAILED
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|scmd-&gt;device-&gt;host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|rtn
op_assign
id|scmd-&gt;device-&gt;host-&gt;hostt
op_member_access_from_pointer
id|eh_host_reset_handler
c_func
(paren
id|scmd
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|scmd-&gt;device-&gt;host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|scmd-&gt;device-&gt;host-&gt;hostt-&gt;skip_settle_delay
)paren
id|ssleep
c_func
(paren
id|HOST_RESET_SETTLE_TIME
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|scmd-&gt;device-&gt;host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|scsi_report_bus_reset
c_func
(paren
id|scmd-&gt;device-&gt;host
comma
id|scmd-&gt;device-&gt;channel
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|scmd-&gt;device-&gt;host-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|rtn
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_eh_bus_reset - send a bus reset &n; * @shost:&t;scsi host being recovered.&n; * @eh_done_q:&t;list_head for processed commands.&n; **/
DECL|function|scsi_eh_bus_reset
r_static
r_int
id|scsi_eh_bus_reset
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
comma
r_struct
id|list_head
op_star
id|work_q
comma
r_struct
id|list_head
op_star
id|done_q
)paren
(brace
r_struct
id|list_head
op_star
id|lh
comma
op_star
id|lh_sf
suffix:semicolon
r_struct
id|scsi_cmnd
op_star
id|scmd
suffix:semicolon
r_struct
id|scsi_cmnd
op_star
id|chan_scmd
suffix:semicolon
r_int
r_int
id|channel
suffix:semicolon
r_int
id|rtn
suffix:semicolon
multiline_comment|/*&n;&t; * we really want to loop over the various channels, and do this on&n;&t; * a channel by channel basis.  we should also check to see if any&n;&t; * of the failed commands are on soft_reset devices, and if so, skip&n;&t; * the reset.  &n;&t; */
r_for
c_loop
(paren
id|channel
op_assign
l_int|0
suffix:semicolon
id|channel
op_le
id|shost-&gt;max_channel
suffix:semicolon
id|channel
op_increment
)paren
(brace
id|chan_scmd
op_assign
l_int|NULL
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|scmd
comma
id|work_q
comma
id|eh_entry
)paren
(brace
r_if
c_cond
(paren
id|channel
op_eq
id|scmd-&gt;device-&gt;channel
)paren
(brace
id|chan_scmd
op_assign
id|scmd
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * FIXME add back in some support for&n;&t;&t;&t;&t; * soft_reset devices.&n;&t;&t;&t;&t; */
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|chan_scmd
)paren
r_continue
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;%s: Sending BRST chan:&quot;
l_string|&quot; %d&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|channel
)paren
)paren
suffix:semicolon
id|rtn
op_assign
id|scsi_try_bus_reset
c_func
(paren
id|chan_scmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
(brace
id|list_for_each_safe
c_func
(paren
id|lh
comma
id|lh_sf
comma
id|work_q
)paren
(brace
id|scmd
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|scsi_cmnd
comma
id|eh_entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|channel
op_eq
id|scmd-&gt;device-&gt;channel
)paren
r_if
c_cond
(paren
op_logical_neg
id|scsi_device_online
c_func
(paren
id|scmd-&gt;device
)paren
op_logical_or
op_logical_neg
id|scsi_eh_tur
c_func
(paren
id|scmd
)paren
)paren
id|scsi_eh_finish_cmd
c_func
(paren
id|scmd
comma
id|done_q
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;%s: BRST&quot;
l_string|&quot; failed chan: %d&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|channel
)paren
)paren
suffix:semicolon
)brace
)brace
r_return
id|list_empty
c_func
(paren
id|work_q
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_eh_host_reset - send a host reset &n; * @work_q:&t;list_head for processed commands.&n; * @done_q:&t;list_head for processed commands.&n; **/
DECL|function|scsi_eh_host_reset
r_static
r_int
id|scsi_eh_host_reset
c_func
(paren
r_struct
id|list_head
op_star
id|work_q
comma
r_struct
id|list_head
op_star
id|done_q
)paren
(brace
r_int
id|rtn
suffix:semicolon
r_struct
id|list_head
op_star
id|lh
comma
op_star
id|lh_sf
suffix:semicolon
r_struct
id|scsi_cmnd
op_star
id|scmd
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|work_q
)paren
)paren
(brace
id|scmd
op_assign
id|list_entry
c_func
(paren
id|work_q-&gt;next
comma
r_struct
id|scsi_cmnd
comma
id|eh_entry
)paren
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;%s: Sending HRST&bslash;n&quot;
comma
id|current-&gt;comm
)paren
)paren
suffix:semicolon
id|rtn
op_assign
id|scsi_try_host_reset
c_func
(paren
id|scmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
(brace
id|list_for_each_safe
c_func
(paren
id|lh
comma
id|lh_sf
comma
id|work_q
)paren
(brace
id|scmd
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|scsi_cmnd
comma
id|eh_entry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_device_online
c_func
(paren
id|scmd-&gt;device
)paren
op_logical_or
(paren
op_logical_neg
id|scsi_eh_try_stu
c_func
(paren
id|scmd
)paren
op_logical_and
op_logical_neg
id|scsi_eh_tur
c_func
(paren
id|scmd
)paren
)paren
op_logical_or
op_logical_neg
id|scsi_eh_tur
c_func
(paren
id|scmd
)paren
)paren
id|scsi_eh_finish_cmd
c_func
(paren
id|scmd
comma
id|done_q
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;%s: HRST&quot;
l_string|&quot; failed&bslash;n&quot;
comma
id|current-&gt;comm
)paren
)paren
suffix:semicolon
)brace
)brace
r_return
id|list_empty
c_func
(paren
id|work_q
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_eh_offline_sdevs - offline scsi devices that fail to recover&n; * @work_q:&t;list_head for processed commands.&n; * @done_q:&t;list_head for processed commands.&n; *&n; **/
DECL|function|scsi_eh_offline_sdevs
r_static
r_void
id|scsi_eh_offline_sdevs
c_func
(paren
r_struct
id|list_head
op_star
id|work_q
comma
r_struct
id|list_head
op_star
id|done_q
)paren
(brace
r_struct
id|list_head
op_star
id|lh
comma
op_star
id|lh_sf
suffix:semicolon
r_struct
id|scsi_cmnd
op_star
id|scmd
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|lh
comma
id|lh_sf
comma
id|work_q
)paren
(brace
id|scmd
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|scsi_cmnd
comma
id|eh_entry
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi: Device offlined - not&quot;
l_string|&quot; ready after error recovery: host&quot;
l_string|&quot; %d channel %d id %d lun %d&bslash;n&quot;
comma
id|scmd-&gt;device-&gt;host-&gt;host_no
comma
id|scmd-&gt;device-&gt;channel
comma
id|scmd-&gt;device-&gt;id
comma
id|scmd-&gt;device-&gt;lun
)paren
suffix:semicolon
id|scsi_device_set_state
c_func
(paren
id|scmd-&gt;device
comma
id|SDEV_OFFLINE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scsi_eh_eflags_chk
c_func
(paren
id|scmd
comma
id|SCSI_EH_CANCEL_CMD
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * FIXME: Handle lost cmds.&n;&t;&t;&t; */
)brace
id|scsi_eh_finish_cmd
c_func
(paren
id|scmd
comma
id|done_q
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_decide_disposition - Disposition a cmd on return from LLD.&n; * @scmd:&t;SCSI cmd to examine.&n; *&n; * Notes:&n; *    This is *only* called when we are examining the status after sending&n; *    out the actual data command.  any commands that are queued for error&n; *    recovery (e.g. test_unit_ready) do *not* come through here.&n; *&n; *    When this routine returns failed, it means the error handler thread&n; *    is woken.  In cases where the error code indicates an error that&n; *    doesn&squot;t require the error handler read (i.e. we don&squot;t need to&n; *    abort/reset), this function should return SUCCESS.&n; **/
DECL|function|scsi_decide_disposition
r_int
id|scsi_decide_disposition
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|scmd
)paren
(brace
r_int
id|rtn
suffix:semicolon
multiline_comment|/*&n;&t; * if the device is offline, then we clearly just pass the result back&n;&t; * up to the top level.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|scsi_device_online
c_func
(paren
id|scmd-&gt;device
)paren
)paren
(brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|5
comma
id|printk
c_func
(paren
l_string|&quot;%s: device offline - report&quot;
l_string|&quot; as SUCCESS&bslash;n&quot;
comma
id|__FUNCTION__
)paren
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * first check the host byte, to see if there is anything in there&n;&t; * that would indicate what we need to do.&n;&t; */
r_switch
c_cond
(paren
id|host_byte
c_func
(paren
id|scmd-&gt;result
)paren
)paren
(brace
r_case
id|DID_PASSTHROUGH
suffix:colon
multiline_comment|/*&n;&t;&t; * no matter what, pass this through to the upper layer.&n;&t;&t; * nuke this special code so that it looks like we are saying&n;&t;&t; * did_ok.&n;&t;&t; */
id|scmd-&gt;result
op_and_assign
l_int|0xff00ffff
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
r_case
id|DID_OK
suffix:colon
multiline_comment|/*&n;&t;&t; * looks good.  drop through, and check the next byte.&n;&t;&t; */
r_break
suffix:semicolon
r_case
id|DID_NO_CONNECT
suffix:colon
r_case
id|DID_BAD_TARGET
suffix:colon
r_case
id|DID_ABORT
suffix:colon
multiline_comment|/*&n;&t;&t; * note - this means that we just report the status back&n;&t;&t; * to the top level driver, not that we actually think&n;&t;&t; * that it indicates SUCCESS.&n;&t;&t; */
r_return
id|SUCCESS
suffix:semicolon
multiline_comment|/*&n;&t;&t; * when the low level driver returns did_soft_error,&n;&t;&t; * it is responsible for keeping an internal retry counter &n;&t;&t; * in order to avoid endless loops (db)&n;&t;&t; *&n;&t;&t; * actually this is a bug in this function here.  we should&n;&t;&t; * be mindful of the maximum number of retries specified&n;&t;&t; * and not get stuck in a loop.&n;&t;&t; */
r_case
id|DID_SOFT_ERROR
suffix:colon
r_goto
id|maybe_retry
suffix:semicolon
r_case
id|DID_IMM_RETRY
suffix:colon
r_return
id|NEEDS_RETRY
suffix:semicolon
r_case
id|DID_ERROR
suffix:colon
r_if
c_cond
(paren
id|msg_byte
c_func
(paren
id|scmd-&gt;result
)paren
op_eq
id|COMMAND_COMPLETE
op_logical_and
id|status_byte
c_func
(paren
id|scmd-&gt;result
)paren
op_eq
id|RESERVATION_CONFLICT
)paren
multiline_comment|/*&n;&t;&t;&t; * execute reservation conflict processing code&n;&t;&t;&t; * lower down&n;&t;&t;&t; */
r_break
suffix:semicolon
multiline_comment|/* fallthrough */
r_case
id|DID_BUS_BUSY
suffix:colon
r_case
id|DID_PARITY
suffix:colon
r_goto
id|maybe_retry
suffix:semicolon
r_case
id|DID_TIME_OUT
suffix:colon
multiline_comment|/*&n;&t;&t; * when we scan the bus, we get timeout messages for&n;&t;&t; * these commands if there is no device available.&n;&t;&t; * other hosts report did_no_connect for the same thing.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|scmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|TEST_UNIT_READY
op_logical_or
id|scmd-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|INQUIRY
)paren
)paren
(brace
r_return
id|SUCCESS
suffix:semicolon
)brace
r_else
(brace
r_return
id|FAILED
suffix:semicolon
)brace
r_case
id|DID_RESET
suffix:colon
r_return
id|SUCCESS
suffix:semicolon
r_default
suffix:colon
r_return
id|FAILED
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * next, check the message byte.&n;&t; */
r_if
c_cond
(paren
id|msg_byte
c_func
(paren
id|scmd-&gt;result
)paren
op_ne
id|COMMAND_COMPLETE
)paren
r_return
id|FAILED
suffix:semicolon
multiline_comment|/*&n;&t; * check the status byte to see if this indicates anything special.&n;&t; */
r_switch
c_cond
(paren
id|status_byte
c_func
(paren
id|scmd-&gt;result
)paren
)paren
(brace
r_case
id|QUEUE_FULL
suffix:colon
multiline_comment|/*&n;&t;&t; * the case of trying to send too many commands to a&n;&t;&t; * tagged queueing device.&n;&t;&t; */
r_case
id|BUSY
suffix:colon
multiline_comment|/*&n;&t;&t; * device can&squot;t talk to us at the moment.  Should only&n;&t;&t; * occur (SAM-3) when the task queue is empty, so will cause&n;&t;&t; * the empty queue handling to trigger a stall in the&n;&t;&t; * device.&n;&t;&t; */
r_return
id|ADD_TO_MLQUEUE
suffix:semicolon
r_case
id|GOOD
suffix:colon
r_case
id|COMMAND_TERMINATED
suffix:colon
r_return
id|SUCCESS
suffix:semicolon
r_case
id|CHECK_CONDITION
suffix:colon
id|rtn
op_assign
id|scsi_check_sense
c_func
(paren
id|scmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|NEEDS_RETRY
)paren
r_goto
id|maybe_retry
suffix:semicolon
multiline_comment|/* if rtn == FAILED, we have no sense information;&n;&t;&t; * returning FAILED will wake the error handler thread&n;&t;&t; * to collect the sense and redo the decide&n;&t;&t; * disposition */
r_return
id|rtn
suffix:semicolon
r_case
id|CONDITION_GOOD
suffix:colon
r_case
id|INTERMEDIATE_GOOD
suffix:colon
r_case
id|INTERMEDIATE_C_GOOD
suffix:colon
multiline_comment|/*&n;&t;&t; * who knows?  FIXME(eric)&n;&t;&t; */
r_return
id|SUCCESS
suffix:semicolon
r_case
id|RESERVATION_CONFLICT
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;scsi: reservation conflict: host&quot;
l_string|&quot; %d channel %d id %d lun %d&bslash;n&quot;
comma
id|scmd-&gt;device-&gt;host-&gt;host_no
comma
id|scmd-&gt;device-&gt;channel
comma
id|scmd-&gt;device-&gt;id
comma
id|scmd-&gt;device-&gt;lun
)paren
suffix:semicolon
r_return
id|SUCCESS
suffix:semicolon
multiline_comment|/* causes immediate i/o error */
r_default
suffix:colon
r_return
id|FAILED
suffix:semicolon
)brace
r_return
id|FAILED
suffix:semicolon
id|maybe_retry
suffix:colon
multiline_comment|/* we requeue for retry because the error was retryable, and&n;&t; * the request was not marked fast fail.  Note that above,&n;&t; * even if the request is marked fast fail, we still requeue&n;&t; * for queue congestion conditions (QUEUE_FULL or BUSY) */
r_if
c_cond
(paren
(paren
op_increment
id|scmd-&gt;retries
)paren
OL
id|scmd-&gt;allowed
op_logical_and
op_logical_neg
id|blk_noretry_request
c_func
(paren
id|scmd-&gt;request
)paren
)paren
(brace
r_return
id|NEEDS_RETRY
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * no more retries - report this one back to upper level.&n;&t;&t; */
r_return
id|SUCCESS
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * scsi_eh_lock_done - done function for eh door lock request&n; * @scmd:&t;SCSI command block for the door lock request&n; *&n; * Notes:&n; * &t;We completed the asynchronous door lock request, and it has either&n; * &t;locked the door or failed.  We must free the command structures&n; * &t;associated with this request.&n; **/
DECL|function|scsi_eh_lock_done
r_static
r_void
id|scsi_eh_lock_done
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|scmd
)paren
(brace
r_struct
id|scsi_request
op_star
id|sreq
op_assign
id|scmd-&gt;sc_request
suffix:semicolon
id|scsi_release_request
c_func
(paren
id|sreq
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_eh_lock_door - Prevent medium removal for the specified device&n; * @sdev:&t;SCSI device to prevent medium removal&n; *&n; * Locking:&n; * &t;We must be called from process context; scsi_allocate_request()&n; * &t;may sleep.&n; *&n; * Notes:&n; * &t;We queue up an asynchronous &quot;ALLOW MEDIUM REMOVAL&quot; request on the&n; * &t;head of the devices request queue, and continue.&n; *&n; * Bugs:&n; * &t;scsi_allocate_request() may sleep waiting for existing requests to&n; * &t;be processed.  However, since we haven&squot;t kicked off any request&n; * &t;processing for this host, this may deadlock.&n; *&n; *&t;If scsi_allocate_request() fails for what ever reason, we&n; *&t;completely forget to lock the door.&n; **/
DECL|function|scsi_eh_lock_door
r_static
r_void
id|scsi_eh_lock_door
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
)paren
(brace
r_struct
id|scsi_request
op_star
id|sreq
op_assign
id|scsi_allocate_request
c_func
(paren
id|sdev
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|sreq
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: request allocate failed,&quot;
l_string|&quot;prevent media removal cmd not sent&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sreq-&gt;sr_cmnd
(braket
l_int|0
)braket
op_assign
id|ALLOW_MEDIUM_REMOVAL
suffix:semicolon
id|sreq-&gt;sr_cmnd
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_cmnd
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_cmnd
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_cmnd
(braket
l_int|4
)braket
op_assign
id|SCSI_REMOVAL_PREVENT
suffix:semicolon
id|sreq-&gt;sr_cmnd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_data_direction
op_assign
id|DMA_NONE
suffix:semicolon
id|sreq-&gt;sr_bufflen
op_assign
l_int|0
suffix:semicolon
id|sreq-&gt;sr_buffer
op_assign
l_int|NULL
suffix:semicolon
id|sreq-&gt;sr_allowed
op_assign
l_int|5
suffix:semicolon
id|sreq-&gt;sr_done
op_assign
id|scsi_eh_lock_done
suffix:semicolon
id|sreq-&gt;sr_timeout_per_command
op_assign
l_int|10
op_star
id|HZ
suffix:semicolon
id|sreq-&gt;sr_cmd_len
op_assign
id|COMMAND_SIZE
c_func
(paren
id|sreq-&gt;sr_cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|scsi_insert_special_req
c_func
(paren
id|sreq
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_restart_operations - restart io operations to the specified host.&n; * @shost:&t;Host we are restarting.&n; *&n; * Notes:&n; *    When we entered the error handler, we blocked all further i/o to&n; *    this device.  we need to &squot;reverse&squot; this process.&n; **/
DECL|function|scsi_restart_operations
r_static
r_void
id|scsi_restart_operations
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
multiline_comment|/*&n;&t; * If the door was locked, we need to insert a door lock request&n;&t; * onto the head of the SCSI request queue for the device.  There&n;&t; * is no point trying to lock the door of an off-line device.&n;&t; */
id|shost_for_each_device
c_func
(paren
id|sdev
comma
id|shost
)paren
(brace
r_if
c_cond
(paren
id|scsi_device_online
c_func
(paren
id|sdev
)paren
op_logical_and
id|sdev-&gt;locked
)paren
id|scsi_eh_lock_door
c_func
(paren
id|sdev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * next free up anything directly waiting upon the host.  this&n;&t; * will be requests for character device operations, and also for&n;&t; * ioctls to queued block devices.&n;&t; */
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;%s: waking up host to restart&bslash;n&quot;
comma
id|__FUNCTION__
)paren
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|SHOST_RECOVERY
comma
op_amp
id|shost-&gt;shost_state
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|shost-&gt;host_wait
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * finally we need to re-initiate requests that may be pending.  we will&n;&t; * have had everything blocked while error handling is taking place, and&n;&t; * now that error recovery is done, we will need to ensure that these&n;&t; * requests are started.&n;&t; */
id|scsi_run_host_queues
c_func
(paren
id|shost
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_eh_ready_devs - check device ready state and recover if not.&n; * @shost: &t;host to be recovered.&n; * @eh_done_q:&t;list_head for processed commands.&n; *&n; **/
DECL|function|scsi_eh_ready_devs
r_static
r_void
id|scsi_eh_ready_devs
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
comma
r_struct
id|list_head
op_star
id|work_q
comma
r_struct
id|list_head
op_star
id|done_q
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|scsi_eh_stu
c_func
(paren
id|shost
comma
id|work_q
comma
id|done_q
)paren
)paren
r_if
c_cond
(paren
op_logical_neg
id|scsi_eh_bus_device_reset
c_func
(paren
id|shost
comma
id|work_q
comma
id|done_q
)paren
)paren
r_if
c_cond
(paren
op_logical_neg
id|scsi_eh_bus_reset
c_func
(paren
id|shost
comma
id|work_q
comma
id|done_q
)paren
)paren
r_if
c_cond
(paren
op_logical_neg
id|scsi_eh_host_reset
c_func
(paren
id|work_q
comma
id|done_q
)paren
)paren
id|scsi_eh_offline_sdevs
c_func
(paren
id|work_q
comma
id|done_q
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_eh_flush_done_q - finish processed commands or retry them.&n; * @done_q:&t;list_head of processed commands.&n; *&n; **/
DECL|function|scsi_eh_flush_done_q
r_static
r_void
id|scsi_eh_flush_done_q
c_func
(paren
r_struct
id|list_head
op_star
id|done_q
)paren
(brace
r_struct
id|list_head
op_star
id|lh
comma
op_star
id|lh_sf
suffix:semicolon
r_struct
id|scsi_cmnd
op_star
id|scmd
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|lh
comma
id|lh_sf
comma
id|done_q
)paren
(brace
id|scmd
op_assign
id|list_entry
c_func
(paren
id|lh
comma
r_struct
id|scsi_cmnd
comma
id|eh_entry
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
id|lh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scsi_device_online
c_func
(paren
id|scmd-&gt;device
)paren
op_logical_and
op_logical_neg
id|blk_noretry_request
c_func
(paren
id|scmd-&gt;request
)paren
op_logical_and
(paren
op_increment
id|scmd-&gt;retries
OL
id|scmd-&gt;allowed
)paren
)paren
(brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;%s: flush&quot;
l_string|&quot; retry cmd: %p&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|scmd
)paren
)paren
suffix:semicolon
id|scsi_queue_insert
c_func
(paren
id|scmd
comma
id|SCSI_MLQUEUE_EH_RETRY
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|scmd-&gt;result
)paren
id|scmd-&gt;result
op_or_assign
(paren
id|DRIVER_TIMEOUT
op_lshift
l_int|24
)paren
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;%s: flush finish&quot;
l_string|&quot; cmd: %p&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|scmd
)paren
)paren
suffix:semicolon
id|scsi_finish_command
c_func
(paren
id|scmd
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/**&n; * scsi_unjam_host - Attempt to fix a host which has a cmd that failed.&n; * @shost:&t;Host to unjam.&n; *&n; * Notes:&n; *    When we come in here, we *know* that all commands on the bus have&n; *    either completed, failed or timed out.  we also know that no further&n; *    commands are being sent to the host, so things are relatively quiet&n; *    and we have freedom to fiddle with things as we wish.&n; *&n; *    This is only the *default* implementation.  it is possible for&n; *    individual drivers to supply their own version of this function, and&n; *    if the maintainer wishes to do this, it is strongly suggested that&n; *    this function be taken as a template and modified.  this function&n; *    was designed to correctly handle problems for about 95% of the&n; *    different cases out there, and it should always provide at least a&n; *    reasonable amount of error recovery.&n; *&n; *    Any command marked &squot;failed&squot; or &squot;timeout&squot; must eventually have&n; *    scsi_finish_cmd() called for it.  we do all of the retry stuff&n; *    here, so when we restart the host after we return it should have an&n; *    empty queue.&n; **/
DECL|function|scsi_unjam_host
r_static
r_void
id|scsi_unjam_host
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|LIST_HEAD
c_func
(paren
id|eh_work_q
)paren
suffix:semicolon
id|LIST_HEAD
c_func
(paren
id|eh_done_q
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
id|shost-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|list_splice_init
c_func
(paren
op_amp
id|shost-&gt;eh_cmd_q
comma
op_amp
id|eh_work_q
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
id|shost-&gt;host_lock
comma
id|flags
)paren
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|1
comma
id|scsi_eh_prt_fail_stats
c_func
(paren
id|shost
comma
op_amp
id|eh_work_q
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_eh_get_sense
c_func
(paren
op_amp
id|eh_work_q
comma
op_amp
id|eh_done_q
)paren
)paren
r_if
c_cond
(paren
op_logical_neg
id|scsi_eh_abort_cmds
c_func
(paren
op_amp
id|eh_work_q
comma
op_amp
id|eh_done_q
)paren
)paren
id|scsi_eh_ready_devs
c_func
(paren
id|shost
comma
op_amp
id|eh_work_q
comma
op_amp
id|eh_done_q
)paren
suffix:semicolon
id|scsi_eh_flush_done_q
c_func
(paren
op_amp
id|eh_done_q
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * scsi_error_handler - Handle errors/timeouts of SCSI cmds.&n; * @data:&t;Host for which we are running.&n; *&n; * Notes:&n; *    This is always run in the context of a kernel thread.  The idea is&n; *    that we start this thing up when the kernel starts up (one per host&n; *    that we detect), and it immediately goes to sleep and waits for some&n; *    event (i.e. failure).  When this takes place, we have the job of&n; *    trying to unjam the bus and restarting things.&n; **/
DECL|function|scsi_error_handler
r_int
id|scsi_error_handler
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|shost
op_assign
(paren
r_struct
id|Scsi_Host
op_star
)paren
id|data
suffix:semicolon
r_int
id|rtn
suffix:semicolon
id|DECLARE_MUTEX_LOCKED
c_func
(paren
id|sem
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *    Flush resources&n;&t; */
id|daemonize
c_func
(paren
l_string|&quot;scsi_eh_%d&quot;
comma
id|shost-&gt;host_no
)paren
suffix:semicolon
id|current-&gt;flags
op_or_assign
id|PF_NOFREEZE
suffix:semicolon
id|shost-&gt;eh_wait
op_assign
op_amp
id|sem
suffix:semicolon
id|shost-&gt;ehandler
op_assign
id|current
suffix:semicolon
multiline_comment|/*&n;&t; * Wake up the thread that created us.&n;&t; */
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|3
comma
id|printk
c_func
(paren
l_string|&quot;Wake up parent of&quot;
l_string|&quot; scsi_eh_%d&bslash;n&quot;
comma
id|shost-&gt;host_no
)paren
)paren
suffix:semicolon
id|complete
c_func
(paren
id|shost-&gt;eh_notify
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; * If we get a signal, it means we are supposed to go&n;&t;&t; * away and die.  This typically happens if the user is&n;&t;&t; * trying to unload a module.&n;&t;&t; */
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;Error handler&quot;
l_string|&quot; scsi_eh_%d&quot;
l_string|&quot; sleeping&bslash;n&quot;
comma
id|shost-&gt;host_no
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Note - we always use down_interruptible with the semaphore&n;&t;&t; * even if the module was loaded as part of the kernel.  The&n;&t;&t; * reason is that down() will cause this thread to be counted&n;&t;&t; * in the load average as a running process, and down&n;&t;&t; * interruptible doesn&squot;t.  Given that we need to allow this&n;&t;&t; * thread to die if the driver was loaded as a module, using&n;&t;&t; * semaphores isn&squot;t unreasonable.&n;&t;&t; */
id|down_interruptible
c_func
(paren
op_amp
id|sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shost-&gt;eh_kill
)paren
r_break
suffix:semicolon
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;Error handler&quot;
l_string|&quot; scsi_eh_%d waking&quot;
l_string|&quot; up&bslash;n&quot;
comma
id|shost-&gt;host_no
)paren
)paren
suffix:semicolon
id|shost-&gt;eh_active
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We have a host that is failing for some reason.  Figure out&n;&t;&t; * what we need to do to get it up and online again (if we can).&n;&t;&t; * If we fail, we end up taking the thing offline.&n;&t;&t; */
r_if
c_cond
(paren
id|shost-&gt;hostt-&gt;eh_strategy_handler
)paren
id|rtn
op_assign
id|shost-&gt;hostt
op_member_access_from_pointer
id|eh_strategy_handler
c_func
(paren
id|shost
)paren
suffix:semicolon
r_else
id|scsi_unjam_host
c_func
(paren
id|shost
)paren
suffix:semicolon
id|shost-&gt;eh_active
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Note - if the above fails completely, the action is to take&n;&t;&t; * individual devices offline and flush the queue of any&n;&t;&t; * outstanding requests that may have been pending.  When we&n;&t;&t; * restart, we restart any I/O to any other devices on the bus&n;&t;&t; * which are still online.&n;&t;&t; */
id|scsi_restart_operations
c_func
(paren
id|shost
)paren
suffix:semicolon
)brace
id|SCSI_LOG_ERROR_RECOVERY
c_func
(paren
l_int|1
comma
id|printk
c_func
(paren
l_string|&quot;Error handler scsi_eh_%d&quot;
l_string|&quot; exiting&bslash;n&quot;
comma
id|shost-&gt;host_no
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure that nobody tries to wake us up again.&n;&t; */
id|shost-&gt;eh_wait
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Knock this down too.  From this point on, the host is flying&n;&t; * without a pilot.  If this is because the module is being unloaded,&n;&t; * that&squot;s fine.  If the user sent a signal to this thing, we are&n;&t; * potentially in real danger.&n;&t; */
id|shost-&gt;eh_active
op_assign
l_int|0
suffix:semicolon
id|shost-&gt;ehandler
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * If anyone is waiting for us to exit (i.e. someone trying to unload&n;&t; * a driver), then wake up that process to let them know we are on&n;&t; * the way out the door.&n;&t; */
id|complete_and_exit
c_func
(paren
id|shost-&gt;eh_notify
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Function:    scsi_report_bus_reset()&n; *&n; * Purpose:     Utility function used by low-level drivers to report that&n; *&t;&t;they have observed a bus reset on the bus being handled.&n; *&n; * Arguments:   shost       - Host in question&n; *&t;&t;channel     - channel on which reset was observed.&n; *&n; * Returns:     Nothing&n; *&n; * Lock status: Host lock must be held.&n; *&n; * Notes:       This only needs to be called if the reset is one which&n; *&t;&t;originates from an unknown location.  Resets originated&n; *&t;&t;by the mid-level itself don&squot;t need to call this, but there&n; *&t;&t;should be no harm.&n; *&n; *&t;&t;The main purpose of this is to make sure that a CHECK_CONDITION&n; *&t;&t;is properly treated.&n; */
DECL|function|scsi_report_bus_reset
r_void
id|scsi_report_bus_reset
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
comma
r_int
id|channel
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
id|__shost_for_each_device
c_func
(paren
id|sdev
comma
id|shost
)paren
(brace
r_if
c_cond
(paren
id|channel
op_eq
id|sdev-&gt;channel
)paren
(brace
id|sdev-&gt;was_reset
op_assign
l_int|1
suffix:semicolon
id|sdev-&gt;expecting_cc_ua
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
DECL|variable|scsi_report_bus_reset
id|EXPORT_SYMBOL
c_func
(paren
id|scsi_report_bus_reset
)paren
suffix:semicolon
multiline_comment|/*&n; * Function:    scsi_report_device_reset()&n; *&n; * Purpose:     Utility function used by low-level drivers to report that&n; *&t;&t;they have observed a device reset on the device being handled.&n; *&n; * Arguments:   shost       - Host in question&n; *&t;&t;channel     - channel on which reset was observed&n; *&t;&t;target&t;    - target on which reset was observed&n; *&n; * Returns:     Nothing&n; *&n; * Lock status: Host lock must be held&n; *&n; * Notes:       This only needs to be called if the reset is one which&n; *&t;&t;originates from an unknown location.  Resets originated&n; *&t;&t;by the mid-level itself don&squot;t need to call this, but there&n; *&t;&t;should be no harm.&n; *&n; *&t;&t;The main purpose of this is to make sure that a CHECK_CONDITION&n; *&t;&t;is properly treated.&n; */
DECL|function|scsi_report_device_reset
r_void
id|scsi_report_device_reset
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|shost
comma
r_int
id|channel
comma
r_int
id|target
)paren
(brace
r_struct
id|scsi_device
op_star
id|sdev
suffix:semicolon
id|__shost_for_each_device
c_func
(paren
id|sdev
comma
id|shost
)paren
(brace
r_if
c_cond
(paren
id|channel
op_eq
id|sdev-&gt;channel
op_logical_and
id|target
op_eq
id|sdev-&gt;id
)paren
(brace
id|sdev-&gt;was_reset
op_assign
l_int|1
suffix:semicolon
id|sdev-&gt;expecting_cc_ua
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
DECL|variable|scsi_report_device_reset
id|EXPORT_SYMBOL
c_func
(paren
id|scsi_report_device_reset
)paren
suffix:semicolon
r_static
r_void
DECL|function|scsi_reset_provider_done_command
id|scsi_reset_provider_done_command
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|scmd
)paren
(brace
)brace
multiline_comment|/*&n; * Function:&t;scsi_reset_provider&n; *&n; * Purpose:&t;Send requested reset to a bus or device at any phase.&n; *&n; * Arguments:&t;device&t;- device to send reset to&n; *&t;&t;flag - reset type (see scsi.h)&n; *&n; * Returns:&t;SUCCESS/FAILURE.&n; *&n; * Notes:&t;This is used by the SCSI Generic driver to provide&n; *&t;&t;Bus/Device reset capability.&n; */
r_int
DECL|function|scsi_reset_provider
id|scsi_reset_provider
c_func
(paren
r_struct
id|scsi_device
op_star
id|dev
comma
r_int
id|flag
)paren
(brace
r_struct
id|scsi_cmnd
op_star
id|scmd
op_assign
id|scsi_get_command
c_func
(paren
id|dev
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_struct
id|request
id|req
suffix:semicolon
r_int
id|rtn
suffix:semicolon
id|scmd-&gt;request
op_assign
op_amp
id|req
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|scmd-&gt;eh_timeout
comma
l_int|0
comma
r_sizeof
(paren
id|scmd-&gt;eh_timeout
)paren
)paren
suffix:semicolon
id|scmd-&gt;request-&gt;rq_status
op_assign
id|RQ_SCSI_BUSY
suffix:semicolon
id|scmd-&gt;state
op_assign
id|SCSI_STATE_INITIALIZING
suffix:semicolon
id|scmd-&gt;owner
op_assign
id|SCSI_OWNER_MIDLEVEL
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|scmd-&gt;cmnd
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|scmd-&gt;cmnd
)paren
)paren
suffix:semicolon
id|scmd-&gt;scsi_done
op_assign
id|scsi_reset_provider_done_command
suffix:semicolon
id|scmd-&gt;done
op_assign
l_int|NULL
suffix:semicolon
id|scmd-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|scmd-&gt;bufflen
op_assign
l_int|0
suffix:semicolon
id|scmd-&gt;request_buffer
op_assign
l_int|NULL
suffix:semicolon
id|scmd-&gt;request_bufflen
op_assign
l_int|0
suffix:semicolon
id|scmd-&gt;internal_timeout
op_assign
id|NORMAL_TIMEOUT
suffix:semicolon
id|scmd-&gt;abort_reason
op_assign
id|DID_ABORT
suffix:semicolon
id|scmd-&gt;cmd_len
op_assign
l_int|0
suffix:semicolon
id|scmd-&gt;sc_data_direction
op_assign
id|DMA_BIDIRECTIONAL
suffix:semicolon
id|scmd-&gt;sc_request
op_assign
l_int|NULL
suffix:semicolon
id|scmd-&gt;sc_magic
op_assign
id|SCSI_CMND_MAGIC
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|scmd-&gt;eh_timeout
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Sometimes the command can get back into the timer chain,&n;&t; * so use the pid as an identifier.&n;&t; */
id|scmd-&gt;pid
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|flag
)paren
(brace
r_case
id|SCSI_TRY_RESET_DEVICE
suffix:colon
id|rtn
op_assign
id|scsi_try_bus_device_reset
c_func
(paren
id|scmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
r_break
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_case
id|SCSI_TRY_RESET_BUS
suffix:colon
id|rtn
op_assign
id|scsi_try_bus_reset
c_func
(paren
id|scmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtn
op_eq
id|SUCCESS
)paren
r_break
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_case
id|SCSI_TRY_RESET_HOST
suffix:colon
id|rtn
op_assign
id|scsi_try_host_reset
c_func
(paren
id|scmd
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|rtn
op_assign
id|FAILED
suffix:semicolon
)brace
id|scsi_delete_timer
c_func
(paren
id|scmd
)paren
suffix:semicolon
id|scsi_next_command
c_func
(paren
id|scmd
)paren
suffix:semicolon
r_return
id|rtn
suffix:semicolon
)brace
DECL|variable|scsi_reset_provider
id|EXPORT_SYMBOL
c_func
(paren
id|scsi_reset_provider
)paren
suffix:semicolon
multiline_comment|/**&n; * scsi_normalize_sense - normalize main elements from either fixed or&n; *&t;&t;&t;descriptor sense data format into a common format.&n; *&n; * @sense_buffer:&t;byte array containing sense data returned by device&n; * @sb_len:&t;&t;number of valid bytes in sense_buffer&n; * @sshdr:&t;&t;pointer to instance of structure that common&n; *&t;&t;&t;elements are written to.&n; *&n; * Notes:&n; *&t;The &quot;main elements&quot; from sense data are: response_code, sense_key,&n; *&t;asc, ascq and additional_length (only for descriptor format).&n; *&n; *&t;Typically this function can be called after a device has&n; *&t;responded to a SCSI command with the CHECK_CONDITION status.&n; *&n; * Return value:&n; *&t;1 if valid sense data information found, else 0;&n; **/
DECL|function|scsi_normalize_sense
r_int
id|scsi_normalize_sense
c_func
(paren
r_const
id|u8
op_star
id|sense_buffer
comma
r_int
id|sb_len
comma
r_struct
id|scsi_sense_hdr
op_star
id|sshdr
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sense_buffer
op_logical_or
op_logical_neg
id|sb_len
op_logical_or
(paren
id|sense_buffer
(braket
l_int|0
)braket
op_amp
l_int|0x70
)paren
op_ne
l_int|0x70
)paren
r_return
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|sshdr
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|scsi_sense_hdr
)paren
)paren
suffix:semicolon
id|sshdr-&gt;response_code
op_assign
(paren
id|sense_buffer
(braket
l_int|0
)braket
op_amp
l_int|0x7f
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sshdr-&gt;response_code
op_ge
l_int|0x72
)paren
(brace
multiline_comment|/*&n;&t;&t; * descriptor format&n;&t;&t; */
r_if
c_cond
(paren
id|sb_len
OG
l_int|1
)paren
id|sshdr-&gt;sense_key
op_assign
(paren
id|sense_buffer
(braket
l_int|1
)braket
op_amp
l_int|0xf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb_len
OG
l_int|2
)paren
id|sshdr-&gt;asc
op_assign
id|sense_buffer
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|sb_len
OG
l_int|3
)paren
id|sshdr-&gt;ascq
op_assign
id|sense_buffer
(braket
l_int|3
)braket
suffix:semicolon
r_if
c_cond
(paren
id|sb_len
OG
l_int|7
)paren
id|sshdr-&gt;additional_length
op_assign
id|sense_buffer
(braket
l_int|7
)braket
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* &n;&t;&t; * fixed format&n;&t;&t; */
r_if
c_cond
(paren
id|sb_len
OG
l_int|2
)paren
id|sshdr-&gt;sense_key
op_assign
(paren
id|sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb_len
OG
l_int|7
)paren
(brace
id|sb_len
op_assign
(paren
id|sb_len
OL
(paren
id|sense_buffer
(braket
l_int|7
)braket
op_plus
l_int|8
)paren
)paren
ques
c_cond
id|sb_len
suffix:colon
(paren
id|sense_buffer
(braket
l_int|7
)braket
op_plus
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb_len
OG
l_int|12
)paren
id|sshdr-&gt;asc
op_assign
id|sense_buffer
(braket
l_int|12
)braket
suffix:semicolon
r_if
c_cond
(paren
id|sb_len
OG
l_int|13
)paren
id|sshdr-&gt;ascq
op_assign
id|sense_buffer
(braket
l_int|13
)braket
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|variable|scsi_normalize_sense
id|EXPORT_SYMBOL
c_func
(paren
id|scsi_normalize_sense
)paren
suffix:semicolon
DECL|function|scsi_request_normalize_sense
r_int
id|scsi_request_normalize_sense
c_func
(paren
r_struct
id|scsi_request
op_star
id|sreq
comma
r_struct
id|scsi_sense_hdr
op_star
id|sshdr
)paren
(brace
r_return
id|scsi_normalize_sense
c_func
(paren
id|sreq-&gt;sr_sense_buffer
comma
r_sizeof
(paren
id|sreq-&gt;sr_sense_buffer
)paren
comma
id|sshdr
)paren
suffix:semicolon
)brace
DECL|variable|scsi_request_normalize_sense
id|EXPORT_SYMBOL
c_func
(paren
id|scsi_request_normalize_sense
)paren
suffix:semicolon
DECL|function|scsi_command_normalize_sense
r_int
id|scsi_command_normalize_sense
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_struct
id|scsi_sense_hdr
op_star
id|sshdr
)paren
(brace
r_return
id|scsi_normalize_sense
c_func
(paren
id|cmd-&gt;sense_buffer
comma
r_sizeof
(paren
id|cmd-&gt;sense_buffer
)paren
comma
id|sshdr
)paren
suffix:semicolon
)brace
DECL|variable|scsi_command_normalize_sense
id|EXPORT_SYMBOL
c_func
(paren
id|scsi_command_normalize_sense
)paren
suffix:semicolon
multiline_comment|/**&n; * scsi_sense_desc_find - search for a given descriptor type in&n; *&t;&t;&t;descriptor sense data format.&n; *&n; * @sense_buffer:&t;byte array of descriptor format sense data&n; * @sb_len:&t;&t;number of valid bytes in sense_buffer&n; * @desc_type:&t;&t;value of descriptor type to find&n; *&t;&t;&t;(e.g. 0 -&gt; information)&n; *&n; * Notes:&n; *&t;only valid when sense data is in descriptor format&n; *&n; * Return value:&n; *&t;pointer to start of (first) descriptor if found else NULL&n; **/
DECL|function|scsi_sense_desc_find
r_const
id|u8
op_star
id|scsi_sense_desc_find
c_func
(paren
r_const
id|u8
op_star
id|sense_buffer
comma
r_int
id|sb_len
comma
r_int
id|desc_type
)paren
(brace
r_int
id|add_sen_len
comma
id|add_len
comma
id|desc_len
comma
id|k
suffix:semicolon
r_const
id|u8
op_star
id|descp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sb_len
OL
l_int|8
)paren
op_logical_or
(paren
l_int|0
op_eq
(paren
id|add_sen_len
op_assign
id|sense_buffer
(braket
l_int|7
)braket
)paren
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sense_buffer
(braket
l_int|0
)braket
OL
l_int|0x72
)paren
op_logical_or
(paren
id|sense_buffer
(braket
l_int|0
)braket
OG
l_int|0x73
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|add_sen_len
op_assign
(paren
id|add_sen_len
OL
(paren
id|sb_len
op_minus
l_int|8
)paren
)paren
ques
c_cond
id|add_sen_len
suffix:colon
(paren
id|sb_len
op_minus
l_int|8
)paren
suffix:semicolon
id|descp
op_assign
op_amp
id|sense_buffer
(braket
l_int|8
)braket
suffix:semicolon
r_for
c_loop
(paren
id|desc_len
op_assign
l_int|0
comma
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|add_sen_len
suffix:semicolon
id|k
op_add_assign
id|desc_len
)paren
(brace
id|descp
op_add_assign
id|desc_len
suffix:semicolon
id|add_len
op_assign
(paren
id|k
OL
(paren
id|add_sen_len
op_minus
l_int|1
)paren
)paren
ques
c_cond
id|descp
(braket
l_int|1
)braket
suffix:colon
op_minus
l_int|1
suffix:semicolon
id|desc_len
op_assign
id|add_len
op_plus
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|descp
(braket
l_int|0
)braket
op_eq
id|desc_type
)paren
r_return
id|descp
suffix:semicolon
r_if
c_cond
(paren
id|add_len
OL
l_int|0
)paren
singleline_comment|// short descriptor ??
r_break
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|variable|scsi_sense_desc_find
id|EXPORT_SYMBOL
c_func
(paren
id|scsi_sense_desc_find
)paren
suffix:semicolon
multiline_comment|/**&n; * scsi_get_sense_info_fld - attempts to get information field from&n; *&t;&t;&t;sense data (either fixed or descriptor format)&n; *&n; * @sense_buffer:&t;byte array of sense data&n; * @sb_len:&t;&t;number of valid bytes in sense_buffer&n; * @info_out:&t;&t;pointer to 64 integer where 8 or 4 byte information&n; *&t;&t;&t;field will be placed if found.&n; *&n; * Return value:&n; *&t;1 if information field found, 0 if not found.&n; **/
DECL|function|scsi_get_sense_info_fld
r_int
id|scsi_get_sense_info_fld
c_func
(paren
r_const
id|u8
op_star
id|sense_buffer
comma
r_int
id|sb_len
comma
id|u64
op_star
id|info_out
)paren
(brace
r_int
id|j
suffix:semicolon
r_const
id|u8
op_star
id|ucp
suffix:semicolon
id|u64
id|ull
suffix:semicolon
r_if
c_cond
(paren
id|sb_len
OL
l_int|7
)paren
r_return
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|sense_buffer
(braket
l_int|0
)braket
op_amp
l_int|0x7f
)paren
(brace
r_case
l_int|0x70
suffix:colon
r_case
l_int|0x71
suffix:colon
r_if
c_cond
(paren
id|sense_buffer
(braket
l_int|0
)braket
op_amp
l_int|0x80
)paren
(brace
op_star
id|info_out
op_assign
(paren
id|sense_buffer
(braket
l_int|3
)braket
op_lshift
l_int|24
)paren
op_plus
(paren
id|sense_buffer
(braket
l_int|4
)braket
op_lshift
l_int|16
)paren
op_plus
(paren
id|sense_buffer
(braket
l_int|5
)braket
op_lshift
l_int|8
)paren
op_plus
id|sense_buffer
(braket
l_int|6
)braket
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
r_case
l_int|0x72
suffix:colon
r_case
l_int|0x73
suffix:colon
id|ucp
op_assign
id|scsi_sense_desc_find
c_func
(paren
id|sense_buffer
comma
id|sb_len
comma
l_int|0
multiline_comment|/* info desc */
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ucp
op_logical_and
(paren
l_int|0xa
op_eq
id|ucp
(braket
l_int|1
)braket
)paren
)paren
(brace
id|ull
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|8
suffix:semicolon
op_increment
id|j
)paren
(brace
r_if
c_cond
(paren
id|j
OG
l_int|0
)paren
id|ull
op_lshift_assign
l_int|8
suffix:semicolon
id|ull
op_or_assign
id|ucp
(braket
l_int|4
op_plus
id|j
)braket
suffix:semicolon
)brace
op_star
id|info_out
op_assign
id|ull
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
)brace
DECL|variable|scsi_get_sense_info_fld
id|EXPORT_SYMBOL
c_func
(paren
id|scsi_get_sense_info_fld
)paren
suffix:semicolon
eof
