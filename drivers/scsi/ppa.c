multiline_comment|/* ppa.c   --  low level driver for the IOMEGA PPA3 &n; * parallel port SCSI host adapter.&n; * &n; * (The PPA3 is the embedded controller in the ZIP drive.)&n; * &n; * (c) 1995,1996 Grant R. Guenther, grant@torque.net,&n; * under the terms of the GNU General Public License.&n; * &n; * Current Maintainer: David Campbell (Perth, Western Australia, GMT+0800)&n; *                     campbell@torque.net&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/parport.h&gt;
macro_line|#include &lt;linux/workqueue.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;scsi/scsi.h&gt;
macro_line|#include &lt;scsi/scsi_cmnd.h&gt;
macro_line|#include &lt;scsi/scsi_device.h&gt;
macro_line|#include &lt;scsi/scsi_host.h&gt;
r_static
r_void
id|ppa_reset_pulse
c_func
(paren
r_int
r_int
id|base
)paren
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|dev
r_struct
id|pardevice
op_star
id|dev
suffix:semicolon
multiline_comment|/* Parport device entry         */
DECL|member|base
r_int
id|base
suffix:semicolon
multiline_comment|/* Actual port address          */
DECL|member|mode
r_int
id|mode
suffix:semicolon
multiline_comment|/* Transfer mode                */
DECL|member|cur_cmd
r_struct
id|scsi_cmnd
op_star
id|cur_cmd
suffix:semicolon
multiline_comment|/* Current queued command       */
DECL|member|ppa_tq
r_struct
id|work_struct
id|ppa_tq
suffix:semicolon
multiline_comment|/* Polling interrupt stuff       */
DECL|member|jstart
r_int
r_int
id|jstart
suffix:semicolon
multiline_comment|/* Jiffies at start             */
DECL|member|recon_tmo
r_int
r_int
id|recon_tmo
suffix:semicolon
multiline_comment|/* How many usecs to wait for reconnection (6th bit) */
DECL|member|failed
r_int
r_int
id|failed
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Failure flag                 */
DECL|member|wanted
r_int
id|wanted
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Parport sharing busy flag    */
DECL|member|waiting
id|wait_queue_head_t
op_star
id|waiting
suffix:semicolon
DECL|member|host
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|typedef|ppa_struct
)brace
id|ppa_struct
suffix:semicolon
macro_line|#include  &quot;ppa.h&quot;
DECL|function|ppa_dev
r_static
r_inline
id|ppa_struct
op_star
id|ppa_dev
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
)paren
(brace
r_return
op_star
(paren
id|ppa_struct
op_star
op_star
)paren
op_amp
id|host-&gt;hostdata
suffix:semicolon
)brace
DECL|variable|arbitration_lock
r_static
id|spinlock_t
id|arbitration_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|function|got_it
r_static
r_void
id|got_it
c_func
(paren
id|ppa_struct
op_star
id|dev
)paren
(brace
id|dev-&gt;base
op_assign
id|dev-&gt;dev-&gt;port-&gt;base
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;cur_cmd
)paren
id|dev-&gt;cur_cmd-&gt;SCp.phase
op_assign
l_int|1
suffix:semicolon
r_else
id|wake_up
c_func
(paren
id|dev-&gt;waiting
)paren
suffix:semicolon
)brace
DECL|function|ppa_wakeup
r_static
r_void
id|ppa_wakeup
c_func
(paren
r_void
op_star
id|ref
)paren
(brace
id|ppa_struct
op_star
id|dev
op_assign
(paren
id|ppa_struct
op_star
)paren
id|ref
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|arbitration_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;wanted
)paren
(brace
id|parport_claim
c_func
(paren
id|dev-&gt;dev
)paren
suffix:semicolon
id|got_it
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;wanted
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|arbitration_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|ppa_pb_claim
r_static
r_int
id|ppa_pb_claim
c_func
(paren
id|ppa_struct
op_star
id|dev
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|res
op_assign
l_int|1
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|arbitration_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parport_claim
c_func
(paren
id|dev-&gt;dev
)paren
op_eq
l_int|0
)paren
(brace
id|got_it
c_func
(paren
id|dev
)paren
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
)brace
id|dev-&gt;wanted
op_assign
id|res
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|arbitration_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|function|ppa_pb_dismiss
r_static
r_void
id|ppa_pb_dismiss
c_func
(paren
id|ppa_struct
op_star
id|dev
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|wanted
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|arbitration_lock
comma
id|flags
)paren
suffix:semicolon
id|wanted
op_assign
id|dev-&gt;wanted
suffix:semicolon
id|dev-&gt;wanted
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|arbitration_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wanted
)paren
id|parport_release
c_func
(paren
id|dev-&gt;dev
)paren
suffix:semicolon
)brace
DECL|function|ppa_pb_release
r_static
r_inline
r_void
id|ppa_pb_release
c_func
(paren
id|ppa_struct
op_star
id|dev
)paren
(brace
id|parport_release
c_func
(paren
id|dev-&gt;dev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Start of Chipset kludges&n; */
multiline_comment|/* This is to give the ppa driver a way to modify the timings (and other&n; * parameters) by writing to the /proc/scsi/ppa/0 file.&n; * Very simple method really... (To simple, no error checking :( )&n; * Reason: Kernel hackers HATE having to unload and reload modules for&n; * testing...&n; * Also gives a method to use a script to obtain optimum timings (TODO)&n; */
DECL|function|ppa_proc_write
r_static
r_inline
r_int
id|ppa_proc_write
c_func
(paren
id|ppa_struct
op_star
id|dev
comma
r_char
op_star
id|buffer
comma
r_int
id|length
)paren
(brace
r_int
r_int
id|x
suffix:semicolon
r_if
c_cond
(paren
(paren
id|length
OG
l_int|5
)paren
op_logical_and
(paren
id|strncmp
c_func
(paren
id|buffer
comma
l_string|&quot;mode=&quot;
comma
l_int|5
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|x
op_assign
id|simple_strtoul
c_func
(paren
id|buffer
op_plus
l_int|5
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|dev-&gt;mode
op_assign
id|x
suffix:semicolon
r_return
id|length
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|length
OG
l_int|10
)paren
op_logical_and
(paren
id|strncmp
c_func
(paren
id|buffer
comma
l_string|&quot;recon_tmo=&quot;
comma
l_int|10
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|x
op_assign
id|simple_strtoul
c_func
(paren
id|buffer
op_plus
l_int|10
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|dev-&gt;recon_tmo
op_assign
id|x
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ppa: recon_tmo set to %ld&bslash;n&quot;
comma
id|x
)paren
suffix:semicolon
r_return
id|length
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;ppa /proc: invalid variable&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
DECL|function|ppa_proc_info
r_static
r_int
id|ppa_proc_info
c_func
(paren
r_struct
id|Scsi_Host
op_star
id|host
comma
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|inout
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|ppa_struct
op_star
id|dev
op_assign
id|ppa_dev
c_func
(paren
id|host
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inout
)paren
r_return
id|ppa_proc_write
c_func
(paren
id|dev
comma
id|buffer
comma
id|length
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Version : %s&bslash;n&quot;
comma
id|PPA_VERSION
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Parport : %s&bslash;n&quot;
comma
id|dev-&gt;dev-&gt;port-&gt;name
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Mode    : %s&bslash;n&quot;
comma
id|PPA_MODE_STRING
(braket
id|dev-&gt;mode
)braket
)paren
suffix:semicolon
macro_line|#if PPA_DEBUG &gt; 0
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;recon_tmo : %lu&bslash;n&quot;
comma
id|dev-&gt;recon_tmo
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Request for beyond end of buffer */
r_if
c_cond
(paren
id|offset
OG
id|length
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
id|offset
suffix:semicolon
id|len
op_sub_assign
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
r_static
r_int
id|device_check
c_func
(paren
id|ppa_struct
op_star
id|dev
)paren
suffix:semicolon
macro_line|#if PPA_DEBUG &gt; 0
DECL|macro|ppa_fail
mdefine_line|#define ppa_fail(x,y) printk(&quot;ppa: ppa_fail(%i) from %s at line %d&bslash;n&quot;,&bslash;&n;&t;   y, __FUNCTION__, __LINE__); ppa_fail_func(x,y);
DECL|function|ppa_fail_func
r_static
r_inline
r_void
id|ppa_fail_func
c_func
(paren
id|ppa_struct
op_star
id|dev
comma
r_int
id|error_code
)paren
macro_line|#else
r_static
r_inline
r_void
id|ppa_fail
c_func
(paren
id|ppa_struct
op_star
id|dev
comma
r_int
id|error_code
)paren
macro_line|#endif
(brace
multiline_comment|/* If we fail a device then we trash status / message bytes */
r_if
c_cond
(paren
id|dev-&gt;cur_cmd
)paren
(brace
id|dev-&gt;cur_cmd-&gt;result
op_assign
id|error_code
op_lshift
l_int|16
suffix:semicolon
id|dev-&gt;failed
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Wait for the high bit to be set.&n; * &n; * In principle, this could be tied to an interrupt, but the adapter&n; * doesn&squot;t appear to be designed to support interrupts.  We spin on&n; * the 0x80 ready bit. &n; */
DECL|function|ppa_wait
r_static
r_int
r_char
id|ppa_wait
c_func
(paren
id|ppa_struct
op_star
id|dev
)paren
(brace
r_int
id|k
suffix:semicolon
r_int
r_int
id|ppb
op_assign
id|dev-&gt;base
suffix:semicolon
r_int
r_char
id|r
suffix:semicolon
id|k
op_assign
id|PPA_SPIN_TMO
suffix:semicolon
multiline_comment|/* Wait for bit 6 and 7 - PJC */
r_for
c_loop
(paren
id|r
op_assign
id|r_str
c_func
(paren
id|ppb
)paren
suffix:semicolon
(paren
(paren
id|r
op_amp
l_int|0xc0
)paren
op_ne
l_int|0xc0
)paren
op_logical_and
(paren
id|k
)paren
suffix:semicolon
id|k
op_decrement
)paren
(brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|r
op_assign
id|r_str
c_func
(paren
id|ppb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * return some status information.&n;&t; * Semantics: 0xc0 = ZIP wants more data&n;&t; *            0xd0 = ZIP wants to send more data&n;&t; *            0xe0 = ZIP is expecting SCSI command data&n;&t; *            0xf0 = end of transfer, ZIP is sending status&n;&t; */
r_if
c_cond
(paren
id|k
)paren
r_return
(paren
id|r
op_amp
l_int|0xf0
)paren
suffix:semicolon
multiline_comment|/* Counter expired - Time out occurred */
id|ppa_fail
c_func
(paren
id|dev
comma
id|DID_TIME_OUT
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ppa timeout in ppa_wait&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* command timed out */
)brace
multiline_comment|/*&n; * Clear EPP Timeout Bit &n; */
DECL|function|epp_reset
r_static
r_inline
r_void
id|epp_reset
c_func
(paren
r_int
r_int
id|ppb
)paren
(brace
r_int
id|i
suffix:semicolon
id|i
op_assign
id|r_str
c_func
(paren
id|ppb
)paren
suffix:semicolon
id|w_str
c_func
(paren
id|ppb
comma
id|i
)paren
suffix:semicolon
id|w_str
c_func
(paren
id|ppb
comma
id|i
op_amp
l_int|0xfe
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Wait for empty ECP fifo (if we are in ECP fifo mode only)&n; */
DECL|function|ecp_sync
r_static
r_inline
r_void
id|ecp_sync
c_func
(paren
id|ppa_struct
op_star
id|dev
)paren
(brace
r_int
id|i
comma
id|ppb_hi
op_assign
id|dev-&gt;dev-&gt;port-&gt;base_hi
suffix:semicolon
r_if
c_cond
(paren
id|ppb_hi
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r_ecr
c_func
(paren
id|ppb_hi
)paren
op_amp
l_int|0xe0
)paren
op_eq
l_int|0x60
)paren
(brace
multiline_comment|/* mode 011 == ECP fifo mode */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|100
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|r_ecr
c_func
(paren
id|ppb_hi
)paren
op_amp
l_int|0x01
)paren
r_return
suffix:semicolon
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;ppa: ECP sync failed as data still present in FIFO.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|ppa_byte_out
r_static
r_int
id|ppa_byte_out
c_func
(paren
r_int
r_int
id|base
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|len
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|w_dtr
c_func
(paren
id|base
comma
op_star
id|buffer
op_increment
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0xe
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0xc
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* All went well - we hope! */
)brace
DECL|function|ppa_byte_in
r_static
r_int
id|ppa_byte_in
c_func
(paren
r_int
r_int
id|base
comma
r_char
op_star
id|buffer
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|len
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
)paren
(brace
op_star
id|buffer
op_increment
op_assign
id|r_dtr
c_func
(paren
id|base
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x27
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x25
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* All went well - we hope! */
)brace
DECL|function|ppa_nibble_in
r_static
r_int
id|ppa_nibble_in
c_func
(paren
r_int
r_int
id|base
comma
r_char
op_star
id|buffer
comma
r_int
id|len
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|len
suffix:semicolon
id|len
op_decrement
)paren
(brace
r_int
r_char
id|h
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x4
)paren
suffix:semicolon
id|h
op_assign
id|r_str
c_func
(paren
id|base
)paren
op_amp
l_int|0xf0
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x6
)paren
suffix:semicolon
op_star
id|buffer
op_increment
op_assign
id|h
op_or
(paren
(paren
id|r_str
c_func
(paren
id|base
)paren
op_amp
l_int|0xf0
)paren
op_rshift
l_int|4
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* All went well - we hope! */
)brace
DECL|function|ppa_out
r_static
r_int
id|ppa_out
c_func
(paren
id|ppa_struct
op_star
id|dev
comma
r_char
op_star
id|buffer
comma
r_int
id|len
)paren
(brace
r_int
id|r
suffix:semicolon
r_int
r_int
id|ppb
op_assign
id|dev-&gt;base
suffix:semicolon
id|r
op_assign
id|ppa_wait
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r
op_amp
l_int|0x50
)paren
op_ne
l_int|0x40
)paren
(brace
id|ppa_fail
c_func
(paren
id|dev
comma
id|DID_ERROR
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|dev-&gt;mode
)paren
(brace
r_case
id|PPA_NIBBLE
suffix:colon
r_case
id|PPA_PS2
suffix:colon
multiline_comment|/* 8 bit output, with a loop */
id|r
op_assign
id|ppa_byte_out
c_func
(paren
id|ppb
comma
id|buffer
comma
id|len
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPA_EPP_32
suffix:colon
r_case
id|PPA_EPP_16
suffix:colon
r_case
id|PPA_EPP_8
suffix:colon
id|epp_reset
c_func
(paren
id|ppb
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x4
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SCSI_IZIP_EPP16
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
(paren
r_int
)paren
id|buffer
op_or
id|len
)paren
op_amp
l_int|0x01
)paren
)paren
id|outsw
c_func
(paren
id|ppb
op_plus
l_int|4
comma
id|buffer
comma
id|len
op_rshift
l_int|1
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
(paren
r_int
)paren
id|buffer
op_or
id|len
)paren
op_amp
l_int|0x03
)paren
)paren
id|outsl
c_func
(paren
id|ppb
op_plus
l_int|4
comma
id|buffer
comma
id|len
op_rshift
l_int|2
)paren
suffix:semicolon
macro_line|#endif
r_else
id|outsb
c_func
(paren
id|ppb
op_plus
l_int|4
comma
id|buffer
comma
id|len
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
id|r
op_assign
op_logical_neg
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x01
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
id|ecp_sync
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;PPA: bug in ppa_out()&bslash;n&quot;
)paren
suffix:semicolon
id|r
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|r
suffix:semicolon
)brace
DECL|function|ppa_in
r_static
r_int
id|ppa_in
c_func
(paren
id|ppa_struct
op_star
id|dev
comma
r_char
op_star
id|buffer
comma
r_int
id|len
)paren
(brace
r_int
id|r
suffix:semicolon
r_int
r_int
id|ppb
op_assign
id|dev-&gt;base
suffix:semicolon
id|r
op_assign
id|ppa_wait
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r
op_amp
l_int|0x50
)paren
op_ne
l_int|0x50
)paren
(brace
id|ppa_fail
c_func
(paren
id|dev
comma
id|DID_ERROR
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|dev-&gt;mode
)paren
(brace
r_case
id|PPA_NIBBLE
suffix:colon
multiline_comment|/* 4 bit input, with a loop */
id|r
op_assign
id|ppa_nibble_in
c_func
(paren
id|ppb
comma
id|buffer
comma
id|len
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPA_PS2
suffix:colon
multiline_comment|/* 8 bit input, with a loop */
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x25
)paren
suffix:semicolon
id|r
op_assign
id|ppa_byte_in
c_func
(paren
id|ppb
comma
id|buffer
comma
id|len
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x4
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PPA_EPP_32
suffix:colon
r_case
id|PPA_EPP_16
suffix:colon
r_case
id|PPA_EPP_8
suffix:colon
id|epp_reset
c_func
(paren
id|ppb
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x24
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SCSI_IZIP_EPP16
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
(paren
r_int
)paren
id|buffer
op_or
id|len
)paren
op_amp
l_int|0x01
)paren
)paren
id|insw
c_func
(paren
id|ppb
op_plus
l_int|4
comma
id|buffer
comma
id|len
op_rshift
l_int|1
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
(paren
r_int
)paren
id|buffer
op_or
id|len
)paren
op_amp
l_int|0x03
)paren
)paren
id|insl
c_func
(paren
id|ppb
op_plus
l_int|4
comma
id|buffer
comma
id|len
op_rshift
l_int|2
)paren
suffix:semicolon
macro_line|#endif
r_else
id|insb
c_func
(paren
id|ppb
op_plus
l_int|4
comma
id|buffer
comma
id|len
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x2c
)paren
suffix:semicolon
id|r
op_assign
op_logical_neg
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x01
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x2c
)paren
suffix:semicolon
id|ecp_sync
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;PPA: bug in ppa_ins()&bslash;n&quot;
)paren
suffix:semicolon
id|r
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|r
suffix:semicolon
)brace
multiline_comment|/* end of ppa_io.h */
DECL|function|ppa_d_pulse
r_static
r_inline
r_void
id|ppa_d_pulse
c_func
(paren
r_int
r_int
id|ppb
comma
r_int
r_char
id|b
)paren
(brace
id|w_dtr
c_func
(paren
id|ppb
comma
id|b
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xe
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x4
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
)brace
DECL|function|ppa_disconnect
r_static
r_void
id|ppa_disconnect
c_func
(paren
id|ppa_struct
op_star
id|dev
)paren
(brace
r_int
r_int
id|ppb
op_assign
id|dev-&gt;base
suffix:semicolon
id|ppa_d_pulse
c_func
(paren
id|ppb
comma
l_int|0
)paren
suffix:semicolon
id|ppa_d_pulse
c_func
(paren
id|ppb
comma
l_int|0x3c
)paren
suffix:semicolon
id|ppa_d_pulse
c_func
(paren
id|ppb
comma
l_int|0x20
)paren
suffix:semicolon
id|ppa_d_pulse
c_func
(paren
id|ppb
comma
l_int|0xf
)paren
suffix:semicolon
)brace
DECL|function|ppa_c_pulse
r_static
r_inline
r_void
id|ppa_c_pulse
c_func
(paren
r_int
r_int
id|ppb
comma
r_int
r_char
id|b
)paren
(brace
id|w_dtr
c_func
(paren
id|ppb
comma
id|b
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x4
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x6
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x4
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
)brace
DECL|function|ppa_connect
r_static
r_inline
r_void
id|ppa_connect
c_func
(paren
id|ppa_struct
op_star
id|dev
comma
r_int
id|flag
)paren
(brace
r_int
r_int
id|ppb
op_assign
id|dev-&gt;base
suffix:semicolon
id|ppa_c_pulse
c_func
(paren
id|ppb
comma
l_int|0
)paren
suffix:semicolon
id|ppa_c_pulse
c_func
(paren
id|ppb
comma
l_int|0x3c
)paren
suffix:semicolon
id|ppa_c_pulse
c_func
(paren
id|ppb
comma
l_int|0x20
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flag
op_eq
id|CONNECT_EPP_MAYBE
)paren
op_logical_and
id|IN_EPP_MODE
c_func
(paren
id|dev-&gt;mode
)paren
)paren
id|ppa_c_pulse
c_func
(paren
id|ppb
comma
l_int|0xcf
)paren
suffix:semicolon
r_else
id|ppa_c_pulse
c_func
(paren
id|ppb
comma
l_int|0x8f
)paren
suffix:semicolon
)brace
DECL|function|ppa_select
r_static
r_int
id|ppa_select
c_func
(paren
id|ppa_struct
op_star
id|dev
comma
r_int
id|target
)paren
(brace
r_int
id|k
suffix:semicolon
r_int
r_int
id|ppb
op_assign
id|dev-&gt;base
suffix:semicolon
multiline_comment|/*&n;&t; * Bit 6 (0x40) is the device selected bit.&n;&t; * First we must wait till the current device goes off line...&n;&t; */
id|k
op_assign
id|PPA_SELECT_TMO
suffix:semicolon
r_do
(brace
id|k
op_decrement
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x40
)paren
op_logical_and
(paren
id|k
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|k
)paren
r_return
l_int|0
suffix:semicolon
id|w_dtr
c_func
(paren
id|ppb
comma
(paren
l_int|1
op_lshift
id|target
)paren
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xe
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
id|w_dtr
c_func
(paren
id|ppb
comma
l_int|0x80
)paren
suffix:semicolon
multiline_comment|/* This is NOT the initator */
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x8
)paren
suffix:semicolon
id|k
op_assign
id|PPA_SELECT_TMO
suffix:semicolon
r_do
(brace
id|k
op_decrement
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x40
)paren
op_logical_and
(paren
id|k
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|k
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &n; * This is based on a trace of what the Iomega DOS &squot;guest&squot; driver does.&n; * I&squot;ve tried several different kinds of parallel ports with guest and&n; * coded this to react in the same ways that it does.&n; * &n; * The return value from this function is just a hint about where the&n; * handshaking failed.&n; * &n; */
DECL|function|ppa_init
r_static
r_int
id|ppa_init
c_func
(paren
id|ppa_struct
op_star
id|dev
)paren
(brace
r_int
id|retv
suffix:semicolon
r_int
r_int
id|ppb
op_assign
id|dev-&gt;base
suffix:semicolon
id|ppa_disconnect
c_func
(paren
id|dev
)paren
suffix:semicolon
id|ppa_connect
c_func
(paren
id|dev
comma
id|CONNECT_NORMAL
)paren
suffix:semicolon
id|retv
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* Failed */
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xe
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x08
)paren
op_eq
l_int|0x08
)paren
id|retv
op_decrement
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x08
)paren
op_eq
l_int|0x00
)paren
id|retv
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retv
)paren
id|ppa_reset_pulse
c_func
(paren
id|ppb
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* Allow devices to settle down */
id|ppa_disconnect
c_func
(paren
id|dev
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* Another delay to allow devices to settle */
r_if
c_cond
(paren
id|retv
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
id|device_check
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
DECL|function|ppa_send_command
r_static
r_inline
r_int
id|ppa_send_command
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
id|ppa_struct
op_star
id|dev
op_assign
id|ppa_dev
c_func
(paren
id|cmd-&gt;device-&gt;host
)paren
suffix:semicolon
r_int
id|k
suffix:semicolon
id|w_ctr
c_func
(paren
id|dev-&gt;base
comma
l_int|0x0c
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|cmd-&gt;cmd_len
suffix:semicolon
id|k
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|ppa_out
c_func
(paren
id|dev
comma
op_amp
id|cmd-&gt;cmnd
(braket
id|k
)braket
comma
l_int|1
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * The bulk flag enables some optimisations in the data transfer loops,&n; * it should be true for any command that transfers data in integral&n; * numbers of sectors.&n; * &n; * The driver appears to remain stable if we speed up the parallel port&n; * i/o in this function, but not elsewhere.&n; */
DECL|function|ppa_completion
r_static
r_int
id|ppa_completion
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
multiline_comment|/* Return codes:&n;&t; * -1     Error&n;&t; *  0     Told to schedule&n;&t; *  1     Finished data transfer&n;&t; */
id|ppa_struct
op_star
id|dev
op_assign
id|ppa_dev
c_func
(paren
id|cmd-&gt;device-&gt;host
)paren
suffix:semicolon
r_int
r_int
id|ppb
op_assign
id|dev-&gt;base
suffix:semicolon
r_int
r_int
id|start_jiffies
op_assign
id|jiffies
suffix:semicolon
r_int
r_char
id|r
comma
id|v
suffix:semicolon
r_int
id|fast
comma
id|bulk
comma
id|status
suffix:semicolon
id|v
op_assign
id|cmd-&gt;cmnd
(braket
l_int|0
)braket
suffix:semicolon
id|bulk
op_assign
(paren
(paren
id|v
op_eq
id|READ_6
)paren
op_logical_or
(paren
id|v
op_eq
id|READ_10
)paren
op_logical_or
(paren
id|v
op_eq
id|WRITE_6
)paren
op_logical_or
(paren
id|v
op_eq
id|WRITE_10
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We only get here if the drive is ready to comunicate,&n;&t; * hence no need for a full ppa_wait.&n;&t; */
id|r
op_assign
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0xf0
)paren
suffix:semicolon
r_while
c_loop
(paren
id|r
op_ne
(paren
r_int
r_char
)paren
l_int|0xf0
)paren
(brace
multiline_comment|/*&n;&t;&t; * If we have been running for more than a full timer tick&n;&t;&t; * then take a rest.&n;&t;&t; */
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|start_jiffies
op_plus
l_int|1
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmd-&gt;SCp.this_residual
op_le
l_int|0
)paren
)paren
(brace
id|ppa_fail
c_func
(paren
id|dev
comma
id|DID_ERROR
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* ERROR_RETURN */
)brace
multiline_comment|/* On some hardware we have SCSI disconnected (6th bit low)&n;&t;&t; * for about 100usecs. It is too expensive to wait a &n;&t;&t; * tick on every loop so we busy wait for no more than&n;&t;&t; * 500usecs to give the drive a chance first. We do not &n;&t;&t; * change things for &quot;normal&quot; hardware since generally &n;&t;&t; * the 6th bit is always high.&n;&t;&t; * This makes the CPU load higher on some hardware &n;&t;&t; * but otherwise we can not get more than 50K/secs &n;&t;&t; * on this problem hardware.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|r
op_amp
l_int|0xc0
)paren
op_ne
l_int|0xc0
)paren
(brace
multiline_comment|/* Wait for reconnection should be no more than &n;&t;&t;&t; * jiffy/2 = 5ms = 5000 loops&n;&t;&t;&t; */
r_int
r_int
id|k
op_assign
id|dev-&gt;recon_tmo
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|k
op_logical_and
(paren
(paren
id|r
op_assign
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0xf0
)paren
)paren
op_amp
l_int|0xc0
)paren
op_ne
l_int|0xc0
suffix:semicolon
id|k
op_decrement
)paren
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|k
)paren
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* determine if we should use burst I/O */
id|fast
op_assign
(paren
id|bulk
op_logical_and
(paren
id|cmd-&gt;SCp.this_residual
op_ge
id|PPA_BURST_SIZE
)paren
)paren
ques
c_cond
id|PPA_BURST_SIZE
suffix:colon
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|r
op_eq
(paren
r_int
r_char
)paren
l_int|0xc0
)paren
id|status
op_assign
id|ppa_out
c_func
(paren
id|dev
comma
id|cmd-&gt;SCp.ptr
comma
id|fast
)paren
suffix:semicolon
r_else
id|status
op_assign
id|ppa_in
c_func
(paren
id|dev
comma
id|cmd-&gt;SCp.ptr
comma
id|fast
)paren
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_add_assign
id|fast
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_sub_assign
id|fast
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
id|ppa_fail
c_func
(paren
id|dev
comma
id|DID_BUS_BUSY
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* ERROR_RETURN */
)brace
r_if
c_cond
(paren
id|cmd-&gt;SCp.buffer
op_logical_and
op_logical_neg
id|cmd-&gt;SCp.this_residual
)paren
(brace
multiline_comment|/* if scatter/gather, advance to the next segment */
r_if
c_cond
(paren
id|cmd-&gt;SCp.buffers_residual
op_decrement
)paren
(brace
id|cmd-&gt;SCp.buffer
op_increment
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|cmd-&gt;SCp.buffer-&gt;length
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
id|page_address
c_func
(paren
id|cmd-&gt;SCp.buffer-&gt;page
)paren
op_plus
id|cmd-&gt;SCp.buffer-&gt;offset
suffix:semicolon
)brace
)brace
multiline_comment|/* Now check to see if the drive is ready to comunicate */
id|r
op_assign
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0xf0
)paren
suffix:semicolon
multiline_comment|/* If not, drop back down to the scheduler and wait a timer tick */
r_if
c_cond
(paren
op_logical_neg
(paren
id|r
op_amp
l_int|0x80
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* FINISH_RETURN */
)brace
multiline_comment|/*&n; * Since the PPA itself doesn&squot;t generate interrupts, we use&n; * the scheduler&squot;s task queue to generate a stream of call-backs and&n; * complete the request when the drive is ready.&n; */
DECL|function|ppa_interrupt
r_static
r_void
id|ppa_interrupt
c_func
(paren
r_void
op_star
id|data
)paren
(brace
id|ppa_struct
op_star
id|dev
op_assign
(paren
id|ppa_struct
op_star
)paren
id|data
suffix:semicolon
r_struct
id|scsi_cmnd
op_star
id|cmd
op_assign
id|dev-&gt;cur_cmd
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PPA: bug in ppa_interrupt&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ppa_engine
c_func
(paren
id|dev
comma
id|cmd
)paren
)paren
(brace
id|dev-&gt;ppa_tq.data
op_assign
(paren
r_void
op_star
)paren
id|dev
suffix:semicolon
id|schedule_delayed_work
c_func
(paren
op_amp
id|dev-&gt;ppa_tq
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Command must of completed hence it is safe to let go... */
macro_line|#if PPA_DEBUG &gt; 0
r_switch
c_cond
(paren
(paren
id|cmd-&gt;result
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
)paren
(brace
r_case
id|DID_OK
suffix:colon
r_break
suffix:semicolon
r_case
id|DID_NO_CONNECT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ppa: no device at SCSI ID %i&bslash;n&quot;
comma
id|cmd-&gt;device-&gt;target
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_BUS_BUSY
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ppa: BUS BUSY - EPP timeout detected&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_TIME_OUT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ppa: unknown timeout&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_ABORT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ppa: told to abort&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_PARITY
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ppa: parity error (???)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_ERROR
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ppa: internal driver error&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_RESET
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ppa: told to reset device&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_BAD_INTR
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ppa: bad interrupt (???)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ppa: bad return code (%02x)&bslash;n&quot;
comma
(paren
id|cmd-&gt;result
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|cmd-&gt;SCp.phase
OG
l_int|1
)paren
id|ppa_disconnect
c_func
(paren
id|dev
)paren
suffix:semicolon
id|ppa_pb_dismiss
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;cur_cmd
op_assign
l_int|0
suffix:semicolon
id|cmd
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
DECL|function|ppa_engine
r_static
r_int
id|ppa_engine
c_func
(paren
id|ppa_struct
op_star
id|dev
comma
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
r_int
r_int
id|ppb
op_assign
id|dev-&gt;base
suffix:semicolon
r_int
r_char
id|l
op_assign
l_int|0
comma
id|h
op_assign
l_int|0
suffix:semicolon
r_int
id|retv
suffix:semicolon
multiline_comment|/* First check for any errors that may of occurred&n;&t; * Here we check for internal errors&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;failed
)paren
r_return
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|cmd-&gt;SCp.phase
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* Phase 0 - Waiting for parport */
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|dev-&gt;jstart
op_plus
id|HZ
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We waited more than a second&n;&t;&t;&t; * for parport to call us&n;&t;&t;&t; */
id|ppa_fail
c_func
(paren
id|dev
comma
id|DID_BUS_BUSY
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* wait until ppa_wakeup claims parport */
r_case
l_int|1
suffix:colon
multiline_comment|/* Phase 1 - Connected */
(brace
multiline_comment|/* Perform a sanity check for cable unplugged */
r_int
id|retv
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* Failed */
id|ppa_connect
c_func
(paren
id|dev
comma
id|CONNECT_EPP_MAYBE
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xe
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x08
)paren
op_eq
l_int|0x08
)paren
id|retv
op_decrement
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0xc
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x08
)paren
op_eq
l_int|0x00
)paren
id|retv
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|retv
)paren
(brace
r_if
c_cond
(paren
(paren
id|jiffies
op_minus
id|dev-&gt;jstart
)paren
OG
(paren
l_int|1
op_star
id|HZ
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;ppa: Parallel port cable is unplugged!!&bslash;n&quot;
)paren
suffix:semicolon
id|ppa_fail
c_func
(paren
id|dev
comma
id|DID_BUS_BUSY
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ppa_disconnect
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Try again in a jiffy */
)brace
)brace
id|cmd-&gt;SCp.phase
op_increment
suffix:semicolon
)brace
r_case
l_int|2
suffix:colon
multiline_comment|/* Phase 2 - We are now talking to the scsi bus */
r_if
c_cond
(paren
op_logical_neg
id|ppa_select
c_func
(paren
id|dev
comma
id|cmd-&gt;device-&gt;id
)paren
)paren
(brace
id|ppa_fail
c_func
(paren
id|dev
comma
id|DID_NO_CONNECT
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|cmd-&gt;SCp.phase
op_increment
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* Phase 3 - Ready to accept a command */
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x80
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ppa_send_command
c_func
(paren
id|cmd
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|cmd-&gt;SCp.phase
op_increment
suffix:semicolon
r_case
l_int|4
suffix:colon
multiline_comment|/* Phase 4 - Setup scatter/gather buffers */
r_if
c_cond
(paren
id|cmd-&gt;use_sg
)paren
(brace
multiline_comment|/* if many buffers are available, start filling the first */
id|cmd-&gt;SCp.buffer
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|cmd-&gt;request_buffer
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|cmd-&gt;SCp.buffer-&gt;length
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
id|page_address
c_func
(paren
id|cmd-&gt;SCp.buffer-&gt;page
)paren
op_plus
id|cmd-&gt;SCp.buffer-&gt;offset
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* else fill the only available buffer */
id|cmd-&gt;SCp.buffer
op_assign
l_int|NULL
suffix:semicolon
id|cmd-&gt;SCp.this_residual
op_assign
id|cmd-&gt;request_bufflen
suffix:semicolon
id|cmd-&gt;SCp.ptr
op_assign
id|cmd-&gt;request_buffer
suffix:semicolon
)brace
id|cmd-&gt;SCp.buffers_residual
op_assign
id|cmd-&gt;use_sg
op_minus
l_int|1
suffix:semicolon
id|cmd-&gt;SCp.phase
op_increment
suffix:semicolon
r_case
l_int|5
suffix:colon
multiline_comment|/* Phase 5 - Data transfer stage */
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|r_str
c_func
(paren
id|ppb
)paren
op_amp
l_int|0x80
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|retv
op_assign
id|ppa_completion
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retv
op_eq
op_minus
l_int|1
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|retv
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
id|cmd-&gt;SCp.phase
op_increment
suffix:semicolon
r_case
l_int|6
suffix:colon
multiline_comment|/* Phase 6 - Read status/message */
id|cmd-&gt;result
op_assign
id|DID_OK
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* Check for data overrun */
r_if
c_cond
(paren
id|ppa_wait
c_func
(paren
id|dev
)paren
op_ne
(paren
r_int
r_char
)paren
l_int|0xf0
)paren
(brace
id|ppa_fail
c_func
(paren
id|dev
comma
id|DID_ERROR
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ppa_in
c_func
(paren
id|dev
comma
op_amp
id|l
comma
l_int|1
)paren
)paren
(brace
multiline_comment|/* read status byte */
multiline_comment|/* Check for optional message byte */
r_if
c_cond
(paren
id|ppa_wait
c_func
(paren
id|dev
)paren
op_eq
(paren
r_int
r_char
)paren
l_int|0xf0
)paren
id|ppa_in
c_func
(paren
id|dev
comma
op_amp
id|h
comma
l_int|1
)paren
suffix:semicolon
id|cmd-&gt;result
op_assign
(paren
id|DID_OK
op_lshift
l_int|16
)paren
op_plus
(paren
id|h
op_lshift
l_int|8
)paren
op_plus
(paren
id|l
op_amp
id|STATUS_MASK
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Finished */
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ppa: Invalid scsi phase&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ppa_queuecommand
r_static
r_int
id|ppa_queuecommand
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
comma
r_void
(paren
op_star
id|done
)paren
(paren
r_struct
id|scsi_cmnd
op_star
)paren
)paren
(brace
id|ppa_struct
op_star
id|dev
op_assign
id|ppa_dev
c_func
(paren
id|cmd-&gt;device-&gt;host
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;cur_cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PPA: bug in ppa_queuecommand&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|dev-&gt;failed
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;jstart
op_assign
id|jiffies
suffix:semicolon
id|dev-&gt;cur_cmd
op_assign
id|cmd
suffix:semicolon
id|cmd-&gt;scsi_done
op_assign
id|done
suffix:semicolon
id|cmd-&gt;result
op_assign
id|DID_ERROR
op_lshift
l_int|16
suffix:semicolon
multiline_comment|/* default return code */
id|cmd-&gt;SCp.phase
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* bus free */
id|dev-&gt;ppa_tq.data
op_assign
id|dev
suffix:semicolon
id|schedule_work
c_func
(paren
op_amp
id|dev-&gt;ppa_tq
)paren
suffix:semicolon
id|ppa_pb_claim
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Apparently the disk-&gt;capacity attribute is off by 1 sector &n; * for all disk drives.  We add the one here, but it should really&n; * be done in sd.c.  Even if it gets fixed there, this will still&n; * work.&n; */
DECL|function|ppa_biosparam
r_static
r_int
id|ppa_biosparam
c_func
(paren
r_struct
id|scsi_device
op_star
id|sdev
comma
r_struct
id|block_device
op_star
id|dev
comma
id|sector_t
id|capacity
comma
r_int
id|ip
(braket
)braket
)paren
(brace
id|ip
(braket
l_int|0
)braket
op_assign
l_int|0x40
suffix:semicolon
id|ip
(braket
l_int|1
)braket
op_assign
l_int|0x20
suffix:semicolon
id|ip
(braket
l_int|2
)braket
op_assign
(paren
(paren
r_int
r_int
)paren
id|capacity
op_plus
l_int|1
)paren
op_div
(paren
id|ip
(braket
l_int|0
)braket
op_star
id|ip
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
(braket
l_int|2
)braket
OG
l_int|1024
)paren
(brace
id|ip
(braket
l_int|0
)braket
op_assign
l_int|0xff
suffix:semicolon
id|ip
(braket
l_int|1
)braket
op_assign
l_int|0x3f
suffix:semicolon
id|ip
(braket
l_int|2
)braket
op_assign
(paren
(paren
r_int
r_int
)paren
id|capacity
op_plus
l_int|1
)paren
op_div
(paren
id|ip
(braket
l_int|0
)braket
op_star
id|ip
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
(braket
l_int|2
)braket
OG
l_int|1023
)paren
id|ip
(braket
l_int|2
)braket
op_assign
l_int|1023
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ppa_abort
r_static
r_int
id|ppa_abort
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
id|ppa_struct
op_star
id|dev
op_assign
id|ppa_dev
c_func
(paren
id|cmd-&gt;device-&gt;host
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * There is no method for aborting commands since Iomega&n;&t; * have tied the SCSI_MESSAGE line high in the interface&n;&t; */
r_switch
c_cond
(paren
id|cmd-&gt;SCp.phase
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* Do not have access to parport */
r_case
l_int|1
suffix:colon
multiline_comment|/* Have not connected to interface */
id|dev-&gt;cur_cmd
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Forget the problem */
r_return
id|SUCCESS
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* SCSI command sent, can not abort */
r_return
id|FAILED
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|ppa_reset_pulse
r_static
r_void
id|ppa_reset_pulse
c_func
(paren
r_int
r_int
id|base
)paren
(brace
id|w_dtr
c_func
(paren
id|base
comma
l_int|0x40
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0x8
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|30
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|base
comma
l_int|0xc
)paren
suffix:semicolon
)brace
DECL|function|ppa_reset
r_static
r_int
id|ppa_reset
c_func
(paren
r_struct
id|scsi_cmnd
op_star
id|cmd
)paren
(brace
id|ppa_struct
op_star
id|dev
op_assign
id|ppa_dev
c_func
(paren
id|cmd-&gt;device-&gt;host
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;SCp.phase
)paren
id|ppa_disconnect
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;cur_cmd
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Forget the problem */
id|ppa_connect
c_func
(paren
id|dev
comma
id|CONNECT_NORMAL
)paren
suffix:semicolon
id|ppa_reset_pulse
c_func
(paren
id|dev-&gt;base
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* device settle delay */
id|ppa_disconnect
c_func
(paren
id|dev
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* device settle delay */
r_return
id|SUCCESS
suffix:semicolon
)brace
DECL|function|device_check
r_static
r_int
id|device_check
c_func
(paren
id|ppa_struct
op_star
id|dev
)paren
(brace
multiline_comment|/* This routine looks for a device and then attempts to use EPP&n;&t;   to send a command. If all goes as planned then EPP is available. */
r_static
r_char
id|cmd
(braket
l_int|6
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
r_int
id|loop
comma
id|old_mode
comma
id|status
comma
id|k
comma
id|ppb
op_assign
id|dev-&gt;base
suffix:semicolon
r_int
r_char
id|l
suffix:semicolon
id|old_mode
op_assign
id|dev-&gt;mode
suffix:semicolon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
l_int|8
suffix:semicolon
id|loop
op_increment
)paren
(brace
multiline_comment|/* Attempt to use EPP for Test Unit Ready */
r_if
c_cond
(paren
(paren
id|ppb
op_amp
l_int|0x0007
)paren
op_eq
l_int|0x0000
)paren
id|dev-&gt;mode
op_assign
id|PPA_EPP_32
suffix:semicolon
id|second_pass
suffix:colon
id|ppa_connect
c_func
(paren
id|dev
comma
id|CONNECT_EPP_MAYBE
)paren
suffix:semicolon
multiline_comment|/* Select SCSI device */
r_if
c_cond
(paren
op_logical_neg
id|ppa_select
c_func
(paren
id|dev
comma
id|loop
)paren
)paren
(brace
id|ppa_disconnect
c_func
(paren
id|dev
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;ppa: Found device at ID %i, Attempting to use %s&bslash;n&quot;
comma
id|loop
comma
id|PPA_MODE_STRING
(braket
id|dev-&gt;mode
)braket
)paren
suffix:semicolon
multiline_comment|/* Send SCSI command */
id|status
op_assign
l_int|1
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
(paren
id|l
OL
l_int|6
)paren
op_logical_and
(paren
id|status
)paren
suffix:semicolon
id|l
op_increment
)paren
id|status
op_assign
id|ppa_out
c_func
(paren
id|dev
comma
id|cmd
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
id|ppa_disconnect
c_func
(paren
id|dev
)paren
suffix:semicolon
id|ppa_connect
c_func
(paren
id|dev
comma
id|CONNECT_EPP_MAYBE
)paren
suffix:semicolon
id|w_dtr
c_func
(paren
id|ppb
comma
l_int|0x40
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x08
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|30
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|ppa_disconnect
c_func
(paren
id|dev
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;mode
op_eq
id|PPA_EPP_32
)paren
(brace
id|dev-&gt;mode
op_assign
id|old_mode
suffix:semicolon
r_goto
id|second_pass
suffix:semicolon
)brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
id|k
op_assign
l_int|1000000
suffix:semicolon
multiline_comment|/* 1 Second */
r_do
(brace
id|l
op_assign
id|r_str
c_func
(paren
id|ppb
)paren
suffix:semicolon
id|k
op_decrement
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|l
op_amp
l_int|0x80
)paren
op_logical_and
(paren
id|k
)paren
)paren
suffix:semicolon
id|l
op_and_assign
l_int|0xf0
suffix:semicolon
r_if
c_cond
(paren
id|l
op_ne
l_int|0xf0
)paren
(brace
id|ppa_disconnect
c_func
(paren
id|dev
)paren
suffix:semicolon
id|ppa_connect
c_func
(paren
id|dev
comma
id|CONNECT_EPP_MAYBE
)paren
suffix:semicolon
id|ppa_reset_pulse
c_func
(paren
id|ppb
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|ppa_disconnect
c_func
(paren
id|dev
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;mode
op_eq
id|PPA_EPP_32
)paren
(brace
id|dev-&gt;mode
op_assign
id|old_mode
suffix:semicolon
r_goto
id|second_pass
suffix:semicolon
)brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|ppa_disconnect
c_func
(paren
id|dev
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ppa: Communication established with ID %i using %s&bslash;n&quot;
comma
id|loop
comma
id|PPA_MODE_STRING
(braket
id|dev-&gt;mode
)braket
)paren
suffix:semicolon
id|ppa_connect
c_func
(paren
id|dev
comma
id|CONNECT_EPP_MAYBE
)paren
suffix:semicolon
id|ppa_reset_pulse
c_func
(paren
id|ppb
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|ppa_disconnect
c_func
(paren
id|dev
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|variable|ppa_template
r_static
r_struct
id|scsi_host_template
id|ppa_template
op_assign
(brace
dot
id|module
op_assign
id|THIS_MODULE
comma
dot
id|proc_name
op_assign
l_string|&quot;ppa&quot;
comma
dot
id|proc_info
op_assign
id|ppa_proc_info
comma
dot
id|name
op_assign
l_string|&quot;Iomega VPI0 (ppa) interface&quot;
comma
dot
id|queuecommand
op_assign
id|ppa_queuecommand
comma
dot
id|eh_abort_handler
op_assign
id|ppa_abort
comma
dot
id|eh_bus_reset_handler
op_assign
id|ppa_reset
comma
dot
id|eh_host_reset_handler
op_assign
id|ppa_reset
comma
dot
id|bios_param
op_assign
id|ppa_biosparam
comma
dot
id|this_id
op_assign
op_minus
l_int|1
comma
dot
id|sg_tablesize
op_assign
id|SG_ALL
comma
dot
id|cmd_per_lun
op_assign
l_int|1
comma
dot
id|use_clustering
op_assign
id|ENABLE_CLUSTERING
comma
dot
id|can_queue
op_assign
l_int|1
comma
)brace
suffix:semicolon
multiline_comment|/***************************************************************************&n; *                   Parallel port probing routines                        *&n; ***************************************************************************/
r_static
id|LIST_HEAD
c_func
(paren
id|ppa_hosts
)paren
suffix:semicolon
DECL|function|__ppa_attach
r_static
r_int
id|__ppa_attach
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
r_struct
id|Scsi_Host
op_star
id|host
suffix:semicolon
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|waiting
)paren
suffix:semicolon
id|DEFINE_WAIT
c_func
(paren
id|wait
)paren
suffix:semicolon
id|ppa_struct
op_star
id|dev
suffix:semicolon
r_int
id|ports
suffix:semicolon
r_int
id|modes
comma
id|ppb
comma
id|ppb_hi
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|dev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|ppa_struct
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|dev
comma
l_int|0
comma
r_sizeof
(paren
id|ppa_struct
)paren
)paren
suffix:semicolon
id|dev-&gt;base
op_assign
op_minus
l_int|1
suffix:semicolon
id|dev-&gt;mode
op_assign
id|PPA_AUTODETECT
suffix:semicolon
id|dev-&gt;recon_tmo
op_assign
id|PPA_RECON_TMO
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|waiting
)paren
suffix:semicolon
id|dev-&gt;dev
op_assign
id|parport_register_device
c_func
(paren
id|pb
comma
l_string|&quot;ppa&quot;
comma
l_int|NULL
comma
id|ppa_wakeup
comma
l_int|NULL
comma
l_int|0
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;dev
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Claim the bus so it remembers what we do to the control&n;&t; * registers. [ CTR and ECP ]&n;&t; */
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
id|dev-&gt;waiting
op_assign
op_amp
id|waiting
suffix:semicolon
id|prepare_to_wait
c_func
(paren
op_amp
id|waiting
comma
op_amp
id|wait
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ppa_pb_claim
c_func
(paren
id|dev
)paren
)paren
id|schedule_timeout
c_func
(paren
l_int|3
op_star
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;wanted
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ppa%d: failed to claim parport because &quot;
l_string|&quot;a pardevice is owning the port for too long &quot;
l_string|&quot;time!&bslash;n&quot;
comma
id|pb-&gt;number
)paren
suffix:semicolon
id|ppa_pb_dismiss
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;waiting
op_assign
l_int|NULL
suffix:semicolon
id|finish_wait
c_func
(paren
op_amp
id|waiting
comma
op_amp
id|wait
)paren
suffix:semicolon
r_goto
id|out1
suffix:semicolon
)brace
id|dev-&gt;waiting
op_assign
l_int|NULL
suffix:semicolon
id|finish_wait
c_func
(paren
op_amp
id|waiting
comma
op_amp
id|wait
)paren
suffix:semicolon
id|ppb
op_assign
id|dev-&gt;base
op_assign
id|dev-&gt;dev-&gt;port-&gt;base
suffix:semicolon
id|ppb_hi
op_assign
id|dev-&gt;dev-&gt;port-&gt;base_hi
suffix:semicolon
id|w_ctr
c_func
(paren
id|ppb
comma
l_int|0x0c
)paren
suffix:semicolon
id|modes
op_assign
id|dev-&gt;dev-&gt;port-&gt;modes
suffix:semicolon
multiline_comment|/* Mode detection works up the chain of speed&n;&t; * This avoids a nasty if-then-else-if-... tree&n;&t; */
id|dev-&gt;mode
op_assign
id|PPA_NIBBLE
suffix:semicolon
r_if
c_cond
(paren
id|modes
op_amp
id|PARPORT_MODE_TRISTATE
)paren
id|dev-&gt;mode
op_assign
id|PPA_PS2
suffix:semicolon
r_if
c_cond
(paren
id|modes
op_amp
id|PARPORT_MODE_ECP
)paren
(brace
id|w_ecr
c_func
(paren
id|ppb_hi
comma
l_int|0x20
)paren
suffix:semicolon
id|dev-&gt;mode
op_assign
id|PPA_PS2
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|modes
op_amp
id|PARPORT_MODE_EPP
)paren
op_logical_and
(paren
id|modes
op_amp
id|PARPORT_MODE_ECP
)paren
)paren
id|w_ecr
c_func
(paren
id|ppb_hi
comma
l_int|0x80
)paren
suffix:semicolon
multiline_comment|/* Done configuration */
id|err
op_assign
id|ppa_init
c_func
(paren
id|dev
)paren
suffix:semicolon
id|ppa_pb_release
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out1
suffix:semicolon
multiline_comment|/* now the glue ... */
r_if
c_cond
(paren
id|dev-&gt;mode
op_eq
id|PPA_NIBBLE
op_logical_or
id|dev-&gt;mode
op_eq
id|PPA_PS2
)paren
id|ports
op_assign
l_int|3
suffix:semicolon
r_else
id|ports
op_assign
l_int|8
suffix:semicolon
id|INIT_WORK
c_func
(paren
op_amp
id|dev-&gt;ppa_tq
comma
id|ppa_interrupt
comma
id|dev
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|host
op_assign
id|scsi_host_alloc
c_func
(paren
op_amp
id|ppa_template
comma
r_sizeof
(paren
id|ppa_struct
op_star
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|host
)paren
r_goto
id|out1
suffix:semicolon
id|host-&gt;io_port
op_assign
id|pb-&gt;base
suffix:semicolon
id|host-&gt;n_io_port
op_assign
id|ports
suffix:semicolon
id|host-&gt;dma_channel
op_assign
op_minus
l_int|1
suffix:semicolon
id|host-&gt;unique_id
op_assign
id|pb-&gt;number
suffix:semicolon
op_star
(paren
id|ppa_struct
op_star
op_star
)paren
op_amp
id|host-&gt;hostdata
op_assign
id|dev
suffix:semicolon
id|dev-&gt;host
op_assign
id|host
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|dev-&gt;list
comma
op_amp
id|ppa_hosts
)paren
suffix:semicolon
id|err
op_assign
id|scsi_add_host
c_func
(paren
id|host
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out2
suffix:semicolon
id|scsi_scan_host
c_func
(paren
id|host
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out2
suffix:colon
id|list_del_init
c_func
(paren
op_amp
id|dev-&gt;list
)paren
suffix:semicolon
id|scsi_host_put
c_func
(paren
id|host
)paren
suffix:semicolon
id|out1
suffix:colon
id|parport_unregister_device
c_func
(paren
id|dev-&gt;dev
)paren
suffix:semicolon
id|out
suffix:colon
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|ppa_attach
r_static
r_void
id|ppa_attach
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
id|__ppa_attach
c_func
(paren
id|pb
)paren
suffix:semicolon
)brace
DECL|function|ppa_detach
r_static
r_void
id|ppa_detach
c_func
(paren
r_struct
id|parport
op_star
id|pb
)paren
(brace
id|ppa_struct
op_star
id|dev
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|dev
comma
op_amp
id|ppa_hosts
comma
id|list
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;dev-&gt;port
op_eq
id|pb
)paren
(brace
id|list_del_init
c_func
(paren
op_amp
id|dev-&gt;list
)paren
suffix:semicolon
id|scsi_remove_host
c_func
(paren
id|dev-&gt;host
)paren
suffix:semicolon
id|scsi_host_put
c_func
(paren
id|dev-&gt;host
)paren
suffix:semicolon
id|parport_unregister_device
c_func
(paren
id|dev-&gt;dev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
DECL|variable|ppa_driver
r_static
r_struct
id|parport_driver
id|ppa_driver
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;ppa&quot;
comma
dot
id|attach
op_assign
id|ppa_attach
comma
dot
id|detach
op_assign
id|ppa_detach
comma
)brace
suffix:semicolon
DECL|function|ppa_driver_init
r_static
r_int
id|__init
id|ppa_driver_init
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ppa: Version %s&bslash;n&quot;
comma
id|PPA_VERSION
)paren
suffix:semicolon
r_return
id|parport_register_driver
c_func
(paren
op_amp
id|ppa_driver
)paren
suffix:semicolon
)brace
DECL|function|ppa_driver_exit
r_static
r_void
id|__exit
id|ppa_driver_exit
c_func
(paren
r_void
)paren
(brace
id|parport_unregister_driver
c_func
(paren
op_amp
id|ppa_driver
)paren
suffix:semicolon
)brace
DECL|variable|ppa_driver_init
id|module_init
c_func
(paren
id|ppa_driver_init
)paren
suffix:semicolon
DECL|variable|ppa_driver_exit
id|module_exit
c_func
(paren
id|ppa_driver_exit
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
