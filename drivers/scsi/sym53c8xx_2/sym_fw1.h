multiline_comment|/*&n; * Device driver for the SYMBIOS/LSILOGIC 53C8XX and 53C1010 family &n; * of PCI-SCSI IO processors.&n; *&n; * Copyright (C) 1999-2001  Gerard Roudier &lt;groudier@free.fr&gt;&n; *&n; * This driver is derived from the Linux sym53c8xx driver.&n; * Copyright (C) 1998-2000  Gerard Roudier&n; *&n; * The sym53c8xx driver is derived from the ncr53c8xx driver that had been &n; * a port of the FreeBSD ncr driver to Linux-1.2.13.&n; *&n; * The original ncr driver has been written for 386bsd and FreeBSD by&n; *         Wolfgang Stanglmeier        &lt;wolf@cologne.de&gt;&n; *         Stefan Esser                &lt;se@mi.Uni-Koeln.de&gt;&n; * Copyright (C) 1994  Wolfgang Stanglmeier&n; *&n; * Other major contributions:&n; *&n; * NVRAM detection and reading.&n; * Copyright (C) 1997 Richard Waltham &lt;dormouse@farsrobt.demon.co.uk&gt;&n; *&n; *-----------------------------------------------------------------------------&n; *&n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions&n; * are met:&n; * 1. Redistributions of source code must retain the above copyright&n; *    notice, this list of conditions and the following disclaimer.&n; * 2. The name of the author may not be used to endorse or promote products&n; *    derived from this software without specific prior written permission.&n; *&n; * Where this Software is combined with software released under the terms of &n; * the GNU Public License (&quot;GPL&quot;) and the terms of the GPL would require the &n; * combined work to also be released under the terms of the GPL, the terms&n; * and conditions of this License will apply in addition to those of the&n; * GPL with the exception of any terms or conditions of this License that&n; * conflict with, or are expressly prohibited by, the GPL.&n; *&n; * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS&squot;&squot; AND&n; * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE&n; * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE&n; * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR&n; * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL&n; * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS&n; * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)&n; * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT&n; * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY&n; * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF&n; * SUCH DAMAGE.&n; */
multiline_comment|/*&n; *  Scripts for SYMBIOS-Processor&n; *&n; *  We have to know the offsets of all labels before we reach &n; *  them (for forward jumps). Therefore we declare a struct &n; *  here. If you make changes inside the script,&n; *&n; *  DONT FORGET TO CHANGE THE LENGTHS HERE!&n; */
multiline_comment|/*&n; *  Script fragments which are loaded into the on-chip RAM &n; *  of 825A, 875, 876, 895, 895A, 896 and 1010 chips.&n; *  Must not exceed 4K bytes.&n; */
DECL|struct|SYM_FWA_SCR
r_struct
id|SYM_FWA_SCR
(brace
DECL|member|start
id|u32
id|start
(braket
l_int|11
)braket
suffix:semicolon
DECL|member|getjob_begin
id|u32
id|getjob_begin
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|_sms_a10
id|u32
id|_sms_a10
(braket
l_int|5
)braket
suffix:semicolon
DECL|member|getjob_end
id|u32
id|getjob_end
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|_sms_a20
id|u32
id|_sms_a20
(braket
l_int|4
)braket
suffix:semicolon
macro_line|#ifdef SYM_CONF_TARGET_ROLE_SUPPORT
DECL|member|select
id|u32
id|select
(braket
l_int|8
)braket
suffix:semicolon
macro_line|#else
DECL|member|select
id|u32
id|select
(braket
l_int|6
)braket
suffix:semicolon
macro_line|#endif
DECL|member|_sms_a30
id|u32
id|_sms_a30
(braket
l_int|5
)braket
suffix:semicolon
DECL|member|wf_sel_done
id|u32
id|wf_sel_done
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|send_ident
id|u32
id|send_ident
(braket
l_int|2
)braket
suffix:semicolon
macro_line|#ifdef SYM_CONF_IARB_SUPPORT
DECL|member|select2
id|u32
id|select2
(braket
l_int|8
)braket
suffix:semicolon
macro_line|#else
DECL|member|select2
id|u32
id|select2
(braket
l_int|2
)braket
suffix:semicolon
macro_line|#endif
DECL|member|command
id|u32
id|command
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|dispatch
id|u32
id|dispatch
(braket
l_int|28
)braket
suffix:semicolon
DECL|member|sel_no_cmd
id|u32
id|sel_no_cmd
(braket
l_int|10
)braket
suffix:semicolon
DECL|member|init
id|u32
id|init
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|clrack
id|u32
id|clrack
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|datai_done
id|u32
id|datai_done
(braket
l_int|11
)braket
suffix:semicolon
DECL|member|datai_done_wsr
id|u32
id|datai_done_wsr
(braket
l_int|20
)braket
suffix:semicolon
DECL|member|datao_done
id|u32
id|datao_done
(braket
l_int|11
)braket
suffix:semicolon
DECL|member|datao_done_wss
id|u32
id|datao_done_wss
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|datai_phase
id|u32
id|datai_phase
(braket
l_int|5
)braket
suffix:semicolon
DECL|member|datao_phase
id|u32
id|datao_phase
(braket
l_int|5
)braket
suffix:semicolon
DECL|member|msg_in
id|u32
id|msg_in
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|msg_in2
id|u32
id|msg_in2
(braket
l_int|10
)braket
suffix:semicolon
macro_line|#ifdef SYM_CONF_IARB_SUPPORT
DECL|member|status
id|u32
id|status
(braket
l_int|14
)braket
suffix:semicolon
macro_line|#else
DECL|member|status
id|u32
id|status
(braket
l_int|10
)braket
suffix:semicolon
macro_line|#endif
DECL|member|complete
id|u32
id|complete
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|complete2
id|u32
id|complete2
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|_sms_a40
id|u32
id|_sms_a40
(braket
l_int|12
)braket
suffix:semicolon
DECL|member|done
id|u32
id|done
(braket
l_int|5
)braket
suffix:semicolon
DECL|member|_sms_a50
id|u32
id|_sms_a50
(braket
l_int|5
)braket
suffix:semicolon
DECL|member|_sms_a60
id|u32
id|_sms_a60
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|done_end
id|u32
id|done_end
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|complete_error
id|u32
id|complete_error
(braket
l_int|5
)braket
suffix:semicolon
DECL|member|save_dp
id|u32
id|save_dp
(braket
l_int|11
)braket
suffix:semicolon
DECL|member|restore_dp
id|u32
id|restore_dp
(braket
l_int|7
)braket
suffix:semicolon
DECL|member|disconnect
id|u32
id|disconnect
(braket
l_int|11
)braket
suffix:semicolon
DECL|member|disconnect2
id|u32
id|disconnect2
(braket
l_int|5
)braket
suffix:semicolon
DECL|member|_sms_a65
id|u32
id|_sms_a65
(braket
l_int|3
)braket
suffix:semicolon
macro_line|#ifdef SYM_CONF_IARB_SUPPORT
DECL|member|idle
id|u32
id|idle
(braket
l_int|4
)braket
suffix:semicolon
macro_line|#else
DECL|member|idle
id|u32
id|idle
(braket
l_int|2
)braket
suffix:semicolon
macro_line|#endif
macro_line|#ifdef SYM_CONF_IARB_SUPPORT
DECL|member|ungetjob
id|u32
id|ungetjob
(braket
l_int|7
)braket
suffix:semicolon
macro_line|#else
DECL|member|ungetjob
id|u32
id|ungetjob
(braket
l_int|5
)braket
suffix:semicolon
macro_line|#endif
macro_line|#ifdef SYM_CONF_TARGET_ROLE_SUPPORT
DECL|member|reselect
id|u32
id|reselect
(braket
l_int|4
)braket
suffix:semicolon
macro_line|#else
DECL|member|reselect
id|u32
id|reselect
(braket
l_int|2
)braket
suffix:semicolon
macro_line|#endif
DECL|member|reselected
id|u32
id|reselected
(braket
l_int|19
)braket
suffix:semicolon
DECL|member|_sms_a70
id|u32
id|_sms_a70
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|_sms_a80
id|u32
id|_sms_a80
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|reselected1
id|u32
id|reselected1
(braket
l_int|25
)braket
suffix:semicolon
DECL|member|_sms_a90
id|u32
id|_sms_a90
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|resel_lun0
id|u32
id|resel_lun0
(braket
l_int|7
)braket
suffix:semicolon
DECL|member|_sms_a100
id|u32
id|_sms_a100
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|resel_tag
id|u32
id|resel_tag
(braket
l_int|8
)braket
suffix:semicolon
macro_line|#if   SYM_CONF_MAX_TASK*4 &gt; 512
DECL|member|_sms_a110
id|u32
id|_sms_a110
(braket
l_int|23
)braket
suffix:semicolon
macro_line|#elif SYM_CONF_MAX_TASK*4 &gt; 256
DECL|member|_sms_a110
id|u32
id|_sms_a110
(braket
l_int|17
)braket
suffix:semicolon
macro_line|#else
DECL|member|_sms_a110
id|u32
id|_sms_a110
(braket
l_int|13
)braket
suffix:semicolon
macro_line|#endif
DECL|member|_sms_a120
id|u32
id|_sms_a120
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|resel_go
id|u32
id|resel_go
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|_sms_a130
id|u32
id|_sms_a130
(braket
l_int|7
)braket
suffix:semicolon
DECL|member|resel_dsa
id|u32
id|resel_dsa
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|resel_dsa1
id|u32
id|resel_dsa1
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|_sms_a140
id|u32
id|_sms_a140
(braket
l_int|7
)braket
suffix:semicolon
DECL|member|resel_no_tag
id|u32
id|resel_no_tag
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|_sms_a145
id|u32
id|_sms_a145
(braket
l_int|7
)braket
suffix:semicolon
DECL|member|data_in
id|u32
id|data_in
(braket
id|SYM_CONF_MAX_SG
op_star
l_int|2
)braket
suffix:semicolon
DECL|member|data_in2
id|u32
id|data_in2
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|data_out
id|u32
id|data_out
(braket
id|SYM_CONF_MAX_SG
op_star
l_int|2
)braket
suffix:semicolon
DECL|member|data_out2
id|u32
id|data_out2
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|pm0_data
id|u32
id|pm0_data
(braket
l_int|12
)braket
suffix:semicolon
DECL|member|pm0_data_out
id|u32
id|pm0_data_out
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|pm0_data_end
id|u32
id|pm0_data_end
(braket
l_int|7
)braket
suffix:semicolon
DECL|member|pm_data_end
id|u32
id|pm_data_end
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|_sms_a150
id|u32
id|_sms_a150
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|pm1_data
id|u32
id|pm1_data
(braket
l_int|12
)braket
suffix:semicolon
DECL|member|pm1_data_out
id|u32
id|pm1_data_out
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|pm1_data_end
id|u32
id|pm1_data_end
(braket
l_int|9
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; *  Script fragments which stay in main memory for all chips &n; *  except for chips that support 8K on-chip RAM.&n; */
DECL|struct|SYM_FWB_SCR
r_struct
id|SYM_FWB_SCR
(brace
DECL|member|no_data
id|u32
id|no_data
(braket
l_int|2
)braket
suffix:semicolon
macro_line|#ifdef SYM_CONF_TARGET_ROLE_SUPPORT
DECL|member|sel_for_abort
id|u32
id|sel_for_abort
(braket
l_int|18
)braket
suffix:semicolon
macro_line|#else
DECL|member|sel_for_abort
id|u32
id|sel_for_abort
(braket
l_int|16
)braket
suffix:semicolon
macro_line|#endif
DECL|member|sel_for_abort_1
id|u32
id|sel_for_abort_1
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|msg_in_etc
id|u32
id|msg_in_etc
(braket
l_int|12
)braket
suffix:semicolon
DECL|member|msg_received
id|u32
id|msg_received
(braket
l_int|5
)braket
suffix:semicolon
DECL|member|msg_weird_seen
id|u32
id|msg_weird_seen
(braket
l_int|5
)braket
suffix:semicolon
DECL|member|msg_extended
id|u32
id|msg_extended
(braket
l_int|17
)braket
suffix:semicolon
DECL|member|_sms_b10
id|u32
id|_sms_b10
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|msg_bad
id|u32
id|msg_bad
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|msg_weird
id|u32
id|msg_weird
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|msg_weird1
id|u32
id|msg_weird1
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|wdtr_resp
id|u32
id|wdtr_resp
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|send_wdtr
id|u32
id|send_wdtr
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|sdtr_resp
id|u32
id|sdtr_resp
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|send_sdtr
id|u32
id|send_sdtr
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|ppr_resp
id|u32
id|ppr_resp
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|send_ppr
id|u32
id|send_ppr
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|nego_bad_phase
id|u32
id|nego_bad_phase
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|msg_out
id|u32
id|msg_out
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|msg_out_done
id|u32
id|msg_out_done
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|data_ovrun
id|u32
id|data_ovrun
(braket
l_int|3
)braket
suffix:semicolon
DECL|member|data_ovrun1
id|u32
id|data_ovrun1
(braket
l_int|22
)braket
suffix:semicolon
DECL|member|data_ovrun2
id|u32
id|data_ovrun2
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|abort_resel
id|u32
id|abort_resel
(braket
l_int|16
)braket
suffix:semicolon
DECL|member|resend_ident
id|u32
id|resend_ident
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|ident_break
id|u32
id|ident_break
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|ident_break_atn
id|u32
id|ident_break_atn
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|sdata_in
id|u32
id|sdata_in
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|resel_bad_lun
id|u32
id|resel_bad_lun
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|bad_i_t_l
id|u32
id|bad_i_t_l
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|bad_i_t_l_q
id|u32
id|bad_i_t_l_q
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|bad_status
id|u32
id|bad_status
(braket
l_int|7
)braket
suffix:semicolon
DECL|member|wsr_ma_helper
id|u32
id|wsr_ma_helper
(braket
l_int|4
)braket
suffix:semicolon
macro_line|#ifdef SYM_OPT_HANDLE_DIR_UNKNOWN
multiline_comment|/* Unknown direction handling */
DECL|member|data_io
id|u32
id|data_io
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|data_io_com
id|u32
id|data_io_com
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|data_io_out
id|u32
id|data_io_out
(braket
l_int|7
)braket
suffix:semicolon
macro_line|#endif
multiline_comment|/* Data area */
DECL|member|zero
id|u32
id|zero
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|scratch
id|u32
id|scratch
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|scratch1
id|u32
id|scratch1
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|prev_done
id|u32
id|prev_done
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|done_pos
id|u32
id|done_pos
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|nextjob
id|u32
id|nextjob
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|startpos
id|u32
id|startpos
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|targtbl
id|u32
id|targtbl
(braket
l_int|1
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; *  Script fragments used at initialisations.&n; *  Only runs out of main memory.&n; */
DECL|struct|SYM_FWZ_SCR
r_struct
id|SYM_FWZ_SCR
(brace
DECL|member|snooptest
id|u32
id|snooptest
(braket
l_int|9
)braket
suffix:semicolon
DECL|member|snoopend
id|u32
id|snoopend
(braket
l_int|2
)braket
suffix:semicolon
macro_line|#ifdef SYM_OPT_NO_BUS_MEMORY_MAPPING
DECL|member|start_ram
id|u32
id|start_ram
(braket
l_int|1
)braket
suffix:semicolon
DECL|member|scripta0_ba
id|u32
id|scripta0_ba
(braket
l_int|4
)braket
suffix:semicolon
macro_line|#endif
)brace
suffix:semicolon
DECL|variable|SYM_FWA_SCR
r_static
r_struct
id|SYM_FWA_SCR
id|SYM_FWA_SCR
op_assign
(brace
multiline_comment|/*--------------------------&lt; START &gt;----------------------------*/
(brace
multiline_comment|/*&n;&t; *  Switch the LED on.&n;&t; *  Will be patched with a NO_OP if LED&n;&t; *  not needed or not desired.&n;&t; */
id|SCR_REG_REG
(paren
id|gpreg
comma
id|SCR_AND
comma
l_int|0xfe
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *      Clear SIGP.&n;&t; */
id|SCR_FROM_REG
(paren
id|ctest2
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Stop here if the C code wants to perform &n;&t; *  some error recovery procedure manually.&n;&t; *  (Indicate this by setting SEM in ISTAT)&n;&t; */
id|SCR_FROM_REG
(paren
id|istat
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Report to the C code the next position in &n;&t; *  the start queue the SCRIPTS will schedule.&n;&t; *  The C code must not change SCRATCHA.&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|PADDR_B
(paren
id|startpos
)paren
comma
id|RADDR_1
(paren
id|scratcha
)paren
comma
id|SCR_INT
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|SEM
comma
id|SEM
)paren
)paren
comma
id|SIR_SCRIPT_STOPPED
comma
multiline_comment|/*&n;&t; *  Start the next job.&n;&t; *&n;&t; *  @DSA     = start point for this job.&n;&t; *  SCRATCHA = address of this job in the start queue.&n;&t; *&n;&t; *  We will restore startpos with SCRATCHA if we fails the &n;&t; *  arbitration or if it is the idle job.&n;&t; *&n;&t; *  The below GETJOB_BEGIN to GETJOB_END section of SCRIPTS &n;&t; *  is a critical path. If it is partially executed, it then &n;&t; *  may happen that the job address is not yet in the DSA &n;&t; *  and the the next queue position points to the next JOB.&n;&t; */
)brace
multiline_comment|/*-------------------------&lt; GETJOB_BEGIN &gt;---------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Copy to a fixed location both the next STARTPOS &n;&t; *  and the current JOB address, using self modifying &n;&t; *  SCRIPTS.&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR_1
(paren
id|scratcha
)paren
comma
id|PADDR_A
(paren
id|_sms_a10
)paren
comma
id|SCR_COPY
(paren
l_int|8
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; _SMS_A10 &gt;-------------------------*/
comma
(brace
l_int|0
comma
id|PADDR_B
(paren
id|nextjob
)paren
comma
multiline_comment|/*&n;&t; *  Move the start address to TEMP using self-&n;&t; *  modifying SCRIPTS and jump indirectly to &n;&t; *  that address.&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|PADDR_B
(paren
id|nextjob
)paren
comma
id|RADDR_1
(paren
id|dsa
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; GETJOB_END &gt;-----------------------*/
comma
(brace
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR_1
(paren
id|dsa
)paren
comma
id|PADDR_A
(paren
id|_sms_a20
)paren
comma
id|SCR_COPY
(paren
l_int|4
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; _SMS_A20 &gt;-------------------------*/
comma
(brace
l_int|0
comma
id|RADDR_1
(paren
id|temp
)paren
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; SELECT &gt;---------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  DSA&t;contains the address of a scheduled&n;&t; *  &t;data structure.&n;&t; *&n;&t; *  SCRATCHA contains the address of the start queue  &n;&t; *  &t;entry which points to the next job.&n;&t; *&n;&t; *  Set Initiator mode.&n;&t; *&n;&t; *  (Target mode is left as an exercise for the reader)&n;&t; */
macro_line|#ifdef SYM_CONF_TARGET_ROLE_SUPPORT
id|SCR_CLR
(paren
id|SCR_TRG
)paren
comma
l_int|0
comma
macro_line|#endif
multiline_comment|/*&n;&t; *      And try to select this target.&n;&t; */
id|SCR_SEL_TBL_ATN
op_xor
m_offsetof
(paren
r_struct
id|sym_dsb
comma
id|select
)paren
comma
id|PADDR_A
(paren
id|ungetjob
)paren
comma
multiline_comment|/*&n;&t; *  Now there are 4 possibilities:&n;&t; *&n;&t; *  (1) The chip looses arbitration.&n;&t; *  This is ok, because it will try again,&n;&t; *  when the bus becomes idle.&n;&t; *  (But beware of the timeout function!)&n;&t; *&n;&t; *  (2) The chip is reselected.&n;&t; *  Then the script processor takes the jump&n;&t; *  to the RESELECT label.&n;&t; *&n;&t; *  (3) The chip wins arbitration.&n;&t; *  Then it will execute SCRIPTS instruction until &n;&t; *  the next instruction that checks SCSI phase.&n;&t; *  Then will stop and wait for selection to be &n;&t; *  complete or selection time-out to occur.&n;&t; *&n;&t; *  After having won arbitration, the SCRIPTS  &n;&t; *  processor is able to execute instructions while &n;&t; *  the SCSI core is performing SCSI selection.&n;&t; */
multiline_comment|/*&n;&t; *  Copy the CCB header to a fixed location &n;&t; *  in the HCB using self-modifying SCRIPTS.&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR_1
(paren
id|dsa
)paren
comma
id|PADDR_A
(paren
id|_sms_a30
)paren
comma
id|SCR_COPY
(paren
r_sizeof
(paren
r_struct
id|sym_ccbh
)paren
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; _SMS_A30 &gt;-------------------------*/
comma
(brace
l_int|0
comma
id|HADDR_1
(paren
id|ccb_head
)paren
comma
multiline_comment|/*&n;&t; *  Initialize the status register&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|HADDR_1
(paren
id|ccb_head.status
)paren
comma
id|RADDR_1
(paren
id|scr0
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; WF_SEL_DONE &gt;----------------------*/
comma
(brace
id|SCR_INT
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|SIR_SEL_ATN_NO_MSG_OUT
comma
)brace
multiline_comment|/*-------------------------&lt; SEND_IDENT &gt;-----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Selection complete.&n;&t; *  Send the IDENTIFY and possibly the TAG message &n;&t; *  and negotiation message if present.&n;&t; */
id|SCR_MOVE_TBL
op_xor
id|SCR_MSG_OUT
comma
m_offsetof
(paren
r_struct
id|sym_dsb
comma
id|smsg
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SELECT2 &gt;--------------------------*/
comma
(brace
macro_line|#ifdef SYM_CONF_IARB_SUPPORT
multiline_comment|/*&n;&t; *  Set IMMEDIATE ARBITRATION if we have been given &n;&t; *  a hint to do so. (Some job to do after this one).&n;&t; */
id|SCR_FROM_REG
(paren
id|HF_REG
)paren
comma
l_int|0
comma
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|MASK
(paren
id|HF_HINT_IARB
comma
id|HF_HINT_IARB
)paren
)paren
comma
l_int|8
comma
id|SCR_REG_REG
(paren
id|scntl1
comma
id|SCR_OR
comma
id|IARB
)paren
comma
l_int|0
comma
macro_line|#endif
multiline_comment|/*&n;&t; *  Anticipate the COMMAND phase.&n;&t; *  This is the PHASE we expect at this point.&n;&t; */
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_COMMAND
)paren
)paren
comma
id|PADDR_A
(paren
id|sel_no_cmd
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; COMMAND &gt;--------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  ... and send the command&n;&t; */
id|SCR_MOVE_TBL
op_xor
id|SCR_COMMAND
comma
m_offsetof
(paren
r_struct
id|sym_dsb
comma
id|cmd
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DISPATCH &gt;-------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  MSG_IN is the only phase that shall be &n;&t; *  entered at least once for each (re)selection.&n;&t; *  So we test it first.&n;&t; */
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR_A
(paren
id|msg_in
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|IF
(paren
id|SCR_DATA_OUT
)paren
)paren
comma
id|PADDR_A
(paren
id|datao_phase
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|IF
(paren
id|SCR_DATA_IN
)paren
)paren
comma
id|PADDR_A
(paren
id|datai_phase
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|IF
(paren
id|SCR_STATUS
)paren
)paren
comma
id|PADDR_A
(paren
id|status
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|IF
(paren
id|SCR_COMMAND
)paren
)paren
comma
id|PADDR_A
(paren
id|command
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|IF
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|PADDR_B
(paren
id|msg_out
)paren
comma
multiline_comment|/*&n;&t; *  Discard as many illegal phases as &n;&t; *  required and tell the C code about.&n;&t; */
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_ILG_OUT
)paren
)paren
comma
l_int|16
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_ILG_OUT
comma
id|HADDR_1
(paren
id|scratch
)paren
comma
id|SCR_JUMPR
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_ILG_OUT
)paren
)paren
comma
op_minus
l_int|16
comma
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_ILG_IN
)paren
)paren
comma
l_int|16
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_ILG_IN
comma
id|HADDR_1
(paren
id|scratch
)paren
comma
id|SCR_JUMPR
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_ILG_IN
)paren
)paren
comma
op_minus
l_int|16
comma
id|SCR_INT
comma
id|SIR_BAD_PHASE
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SEL_NO_CMD &gt;-----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  The target does not switch to command &n;&t; *  phase after IDENTIFY has been sent.&n;&t; *&n;&t; *  If it stays in MSG OUT phase send it &n;&t; *  the IDENTIFY again.&n;&t; */
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|PADDR_B
(paren
id|resend_ident
)paren
comma
multiline_comment|/*&n;&t; *  If target does not switch to MSG IN phase &n;&t; *  and we sent a negotiation, assert the &n;&t; *  failure immediately.&n;&t; */
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
id|SCR_FROM_REG
(paren
id|HS_REG
)paren
comma
l_int|0
comma
id|SCR_INT
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|HS_NEGOTIATE
)paren
)paren
comma
id|SIR_NEGO_FAILED
comma
multiline_comment|/*&n;&t; *  Jump to dispatcher.&n;&t; */
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; INIT &gt;-----------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Wait for the SCSI RESET signal to be &n;&t; *  inactive before restarting operations, &n;&t; *  since the chip may hang on SEL_ATN &n;&t; *  if SCSI RESET is active.&n;&t; */
id|SCR_FROM_REG
(paren
id|sstat0
)paren
comma
l_int|0
comma
id|SCR_JUMPR
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|IRST
comma
id|IRST
)paren
)paren
comma
op_minus
l_int|16
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|start
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; CLRACK &gt;---------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Terminate possible pending message phase.&n;&t; */
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATAI_DONE &gt;-----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Save current pointer to LASTP.&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR_1
(paren
id|temp
)paren
comma
id|HADDR_1
(paren
id|ccb_head.lastp
)paren
comma
multiline_comment|/*&n;&t; *  If the SWIDE is not full, jump to dispatcher.&n;&t; *  We anticipate a STATUS phase.&n;&t; */
id|SCR_FROM_REG
(paren
id|scntl2
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|WSR
comma
id|WSR
)paren
)paren
comma
id|PADDR_A
(paren
id|datai_done_wsr
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_STATUS
)paren
)paren
comma
id|PADDR_A
(paren
id|status
)paren
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATAI_DONE_WSR &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  The SWIDE is full.&n;&t; *  Clear this condition.&n;&t; */
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_OR
comma
id|WSR
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  We are expecting an IGNORE RESIDUE message &n;&t; *  from the device, otherwise we are in data &n;&t; *  overrun condition. Check against MSG_IN phase.&n;&t; */
id|SCR_INT
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|SIR_SWIDE_OVERRUN
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
multiline_comment|/*&n;&t; *  We are in MSG_IN phase,&n;&t; *  Read the first byte of the message.&n;&t; *  If it is not an IGNORE RESIDUE message,&n;&t; *  signal overrun and jump to message &n;&t; *  processing.&n;&t; */
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|HADDR_1
(paren
id|msgin
(braket
l_int|0
)braket
)paren
comma
id|SCR_INT
op_xor
id|IFFALSE
(paren
id|DATA
(paren
id|M_IGN_RESIDUE
)paren
)paren
comma
id|SIR_SWIDE_OVERRUN
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|DATA
(paren
id|M_IGN_RESIDUE
)paren
)paren
comma
id|PADDR_A
(paren
id|msg_in2
)paren
comma
multiline_comment|/*&n;&t; *  We got the message we expected.&n;&t; *  Read the 2nd byte, and jump to dispatcher.&n;&t; */
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|HADDR_1
(paren
id|msgin
(braket
l_int|1
)braket
)paren
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATAO_DONE &gt;-----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Save current pointer to LASTP.&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR_1
(paren
id|temp
)paren
comma
id|HADDR_1
(paren
id|ccb_head.lastp
)paren
comma
multiline_comment|/*&n;&t; *  If the SODL is not full jump to dispatcher.&n;&t; *  We anticipate a STATUS phase.&n;&t; */
id|SCR_FROM_REG
(paren
id|scntl2
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|WSS
comma
id|WSS
)paren
)paren
comma
id|PADDR_A
(paren
id|datao_done_wss
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_STATUS
)paren
)paren
comma
id|PADDR_A
(paren
id|status
)paren
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATAO_DONE_WSS &gt;-------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  The SODL is full, clear this condition.&n;&t; */
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_OR
comma
id|WSS
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  And signal a DATA UNDERRUN condition &n;&t; *  to the C code.&n;&t; */
id|SCR_INT
comma
id|SIR_SODL_UNDERRUN
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATAI_PHASE &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Jump to current pointer.&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|HADDR_1
(paren
id|ccb_head.lastp
)paren
comma
id|RADDR_1
(paren
id|temp
)paren
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; DATAO_PHASE &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Jump to current pointer.&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|HADDR_1
(paren
id|ccb_head.lastp
)paren
comma
id|RADDR_1
(paren
id|temp
)paren
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_IN &gt;---------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Get the first byte of the message.&n;&t; *&n;&t; *  The script processor doesn&squot;t negate the&n;&t; *  ACK signal after this transfer.&n;&t; */
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|HADDR_1
(paren
id|msgin
(braket
l_int|0
)braket
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_IN2 &gt;--------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Check first against 1 byte messages &n;&t; *  that we handle from SCRIPTS.&n;&t; */
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_COMPLETE
)paren
)paren
comma
id|PADDR_A
(paren
id|complete
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_DISCONNECT
)paren
)paren
comma
id|PADDR_A
(paren
id|disconnect
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_SAVE_DP
)paren
)paren
comma
id|PADDR_A
(paren
id|save_dp
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_RESTORE_DP
)paren
)paren
comma
id|PADDR_A
(paren
id|restore_dp
)paren
comma
multiline_comment|/*&n;&t; *  We handle all other messages from the &n;&t; *  C code, so no need to waste on-chip RAM &n;&t; *  for those ones.&n;&t; */
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|msg_in_etc
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; STATUS &gt;---------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  get the status&n;&t; */
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_STATUS
comma
id|HADDR_1
(paren
id|scratch
)paren
comma
macro_line|#ifdef SYM_CONF_IARB_SUPPORT
multiline_comment|/*&n;&t; *  If STATUS is not GOOD, clear IMMEDIATE ARBITRATION, &n;&t; *  since we may have to tamper the start queue from &n;&t; *  the C code.&n;&t; */
id|SCR_JUMPR
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|S_GOOD
)paren
)paren
comma
l_int|8
comma
id|SCR_REG_REG
(paren
id|scntl1
comma
id|SCR_AND
comma
op_complement
id|IARB
)paren
comma
l_int|0
comma
macro_line|#endif
multiline_comment|/*&n;&t; *  save status to scsi_status.&n;&t; *  mark as complete.&n;&t; */
id|SCR_TO_REG
(paren
id|SS_REG
)paren
comma
l_int|0
comma
id|SCR_LOAD_REG
(paren
id|HS_REG
comma
id|HS_COMPLETE
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Anticipate the MESSAGE PHASE for &n;&t; *  the TASK COMPLETE message.&n;&t; */
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR_A
(paren
id|msg_in
)paren
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; COMPLETE &gt;-------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Complete message.&n;&t; *&n;&t; *  When we terminate the cycle by clearing ACK,&n;&t; *  the target may disconnect immediately.&n;&t; *&n;&t; *  We don&squot;t want to be told of an &quot;unexpected disconnect&quot;,&n;&t; *  so we disable this feature.&n;&t; */
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_AND
comma
l_int|0x7f
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Terminate cycle ...&n;&t; */
id|SCR_CLR
(paren
id|SCR_ACK
op_or
id|SCR_ATN
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  ... and wait for the disconnect.&n;&t; */
id|SCR_WAIT_DISC
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; COMPLETE2 &gt;------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Save host status.&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR_1
(paren
id|scr0
)paren
comma
id|HADDR_1
(paren
id|ccb_head.status
)paren
comma
multiline_comment|/*&n;&t; *  Move back the CCB header using self-modifying &n;&t; *  SCRIPTS.&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR_1
(paren
id|dsa
)paren
comma
id|PADDR_A
(paren
id|_sms_a40
)paren
comma
id|SCR_COPY
(paren
r_sizeof
(paren
r_struct
id|sym_ccbh
)paren
)paren
comma
id|HADDR_1
(paren
id|ccb_head
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; _SMS_A40 &gt;-------------------------*/
comma
(brace
l_int|0
comma
multiline_comment|/*&n;&t; *  Some bridges may reorder DMA writes to memory.&n;&t; *  We donnot want the CPU to deal with completions  &n;&t; *  without all the posted write having been flushed &n;&t; *  to memory. This DUMMY READ should flush posted &n;&t; *  buffers prior to the CPU having to deal with &n;&t; *  completions.&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
multiline_comment|/* DUMMY READ */
id|HADDR_1
(paren
id|ccb_head.status
)paren
comma
id|RADDR_1
(paren
id|scr0
)paren
comma
multiline_comment|/*&n;&t; *  If command resulted in not GOOD status,&n;&t; *  call the C code if needed.&n;&t; */
id|SCR_FROM_REG
(paren
id|SS_REG
)paren
comma
l_int|0
comma
id|SCR_CALL
op_xor
id|IFFALSE
(paren
id|DATA
(paren
id|S_GOOD
)paren
)paren
comma
id|PADDR_B
(paren
id|bad_status
)paren
comma
multiline_comment|/*&n;&t; *  If we performed an auto-sense, call &n;&t; *  the C code to synchronyze task aborts &n;&t; *  with UNIT ATTENTION conditions.&n;&t; */
id|SCR_FROM_REG
(paren
id|HF_REG
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|MASK
(paren
l_int|0
comma
(paren
id|HF_SENSE
op_or
id|HF_EXT_ERR
)paren
)paren
)paren
comma
id|PADDR_A
(paren
id|complete_error
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DONE &gt;-----------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Copy the DSA to the DONE QUEUE and &n;&t; *  signal completion to the host.&n;&t; *  If we are interrupted between DONE &n;&t; *  and DONE_END, we must reset, otherwise &n;&t; *  the completed CCB may be lost.&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|PADDR_B
(paren
id|done_pos
)paren
comma
id|PADDR_A
(paren
id|_sms_a50
)paren
comma
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR_1
(paren
id|dsa
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; _SMS_A50 &gt;-------------------------*/
comma
(brace
l_int|0
comma
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|PADDR_B
(paren
id|done_pos
)paren
comma
id|PADDR_A
(paren
id|_sms_a60
)paren
comma
multiline_comment|/*&n;&t; *  The instruction below reads the DONE QUEUE next &n;&t; *  free position from memory.&n;&t; *  In addition it ensures that all PCI posted writes  &n;&t; *  are flushed and so the DSA value of the done &n;&t; *  CCB is visible by the CPU before INTFLY is raised.&n;&t; */
id|SCR_COPY
(paren
l_int|8
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; _SMS_A60 &gt;-------------------------*/
comma
(brace
l_int|0
comma
id|PADDR_B
(paren
id|prev_done
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DONE_END &gt;-------------------------*/
comma
(brace
id|SCR_INT_FLY
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|start
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; COMPLETE_ERROR &gt;-------------------*/
comma
(brace
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|PADDR_B
(paren
id|startpos
)paren
comma
id|RADDR_1
(paren
id|scratcha
)paren
comma
id|SCR_INT
comma
id|SIR_COMPLETE_ERROR
comma
)brace
multiline_comment|/*-------------------------&lt; SAVE_DP &gt;--------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Clear ACK immediately.&n;&t; *  No need to delay it.&n;&t; */
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Keep track we received a SAVE DP, so &n;&t; *  we will switch to the other PM context &n;&t; *  on the next PM since the DP may point &n;&t; *  to the current PM context.&n;&t; */
id|SCR_REG_REG
(paren
id|HF_REG
comma
id|SCR_OR
comma
id|HF_DP_SAVED
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  SAVE_DP message:&n;&t; *  Copy LASTP to SAVEP.&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|HADDR_1
(paren
id|ccb_head.lastp
)paren
comma
id|HADDR_1
(paren
id|ccb_head.savep
)paren
comma
multiline_comment|/*&n;&t; *  Anticipate the MESSAGE PHASE for &n;&t; *  the DISCONNECT message.&n;&t; */
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR_A
(paren
id|msg_in
)paren
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESTORE_DP &gt;-----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Clear ACK immediately.&n;&t; *  No need to delay it.&n;&t; */
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Copy SAVEP to LASTP.&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|HADDR_1
(paren
id|ccb_head.savep
)paren
comma
id|HADDR_1
(paren
id|ccb_head.lastp
)paren
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DISCONNECT &gt;-----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  DISCONNECTing  ...&n;&t; *&n;&t; *  disable the &quot;unexpected disconnect&quot; feature,&n;&t; *  and remove the ACK signal.&n;&t; */
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_AND
comma
l_int|0x7f
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
op_or
id|SCR_ATN
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Wait for the disconnect.&n;&t; */
id|SCR_WAIT_DISC
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Status is: DISCONNECTED.&n;&t; */
id|SCR_LOAD_REG
(paren
id|HS_REG
comma
id|HS_DISCONNECT
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Save host status.&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR_1
(paren
id|scr0
)paren
comma
id|HADDR_1
(paren
id|ccb_head.status
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DISCONNECT2 &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Move back the CCB header using self-modifying &n;&t; *  SCRIPTS.&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR_1
(paren
id|dsa
)paren
comma
id|PADDR_A
(paren
id|_sms_a65
)paren
comma
id|SCR_COPY
(paren
r_sizeof
(paren
r_struct
id|sym_ccbh
)paren
)paren
comma
id|HADDR_1
(paren
id|ccb_head
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; _SMS_A65 &gt;-------------------------*/
comma
(brace
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|start
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; IDLE &gt;-----------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Nothing to do?&n;&t; *  Switch the LED off and wait for reselect.&n;&t; *  Will be patched with a NO_OP if LED&n;&t; *  not needed or not desired.&n;&t; */
id|SCR_REG_REG
(paren
id|gpreg
comma
id|SCR_OR
comma
l_int|0x01
)paren
comma
l_int|0
comma
macro_line|#ifdef SYM_CONF_IARB_SUPPORT
id|SCR_JUMPR
comma
l_int|8
comma
macro_line|#endif
)brace
multiline_comment|/*-------------------------&lt; UNGETJOB &gt;-------------------------*/
comma
(brace
macro_line|#ifdef SYM_CONF_IARB_SUPPORT
multiline_comment|/*&n;&t; *  Set IMMEDIATE ARBITRATION, for the next time.&n;&t; *  This will give us better chance to win arbitration &n;&t; *  for the job we just wanted to do.&n;&t; */
id|SCR_REG_REG
(paren
id|scntl1
comma
id|SCR_OR
comma
id|IARB
)paren
comma
l_int|0
comma
macro_line|#endif
multiline_comment|/*&n;&t; *  We are not able to restart the SCRIPTS if we are &n;&t; *  interrupted and these instruction haven&squot;t been &n;&t; *  all executed. BTW, this is very unlikely to &n;&t; *  happen, but we check that from the C code.&n;&t; */
id|SCR_LOAD_REG
(paren
id|dsa
comma
l_int|0xff
)paren
comma
l_int|0
comma
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR_1
(paren
id|scratcha
)paren
comma
id|PADDR_B
(paren
id|startpos
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESELECT &gt;-------------------------*/
comma
(brace
macro_line|#ifdef SYM_CONF_TARGET_ROLE_SUPPORT
multiline_comment|/*&n;&t; *  Make sure we are in initiator mode.&n;&t; */
id|SCR_CLR
(paren
id|SCR_TRG
)paren
comma
l_int|0
comma
macro_line|#endif
multiline_comment|/*&n;&t; *  Sleep waiting for a reselection.&n;&t; */
id|SCR_WAIT_RESEL
comma
id|PADDR_A
c_func
(paren
id|start
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESELECTED &gt;-----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Switch the LED on.&n;&t; *  Will be patched with a NO_OP if LED&n;&t; *  not needed or not desired.&n;&t; */
id|SCR_REG_REG
(paren
id|gpreg
comma
id|SCR_AND
comma
l_int|0xfe
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  load the target id into the sdid&n;&t; */
id|SCR_REG_SFBR
(paren
id|ssid
comma
id|SCR_AND
comma
l_int|0x8F
)paren
comma
l_int|0
comma
id|SCR_TO_REG
(paren
id|sdid
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Load the target control block address&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|PADDR_B
(paren
id|targtbl
)paren
comma
id|RADDR_1
(paren
id|dsa
)paren
comma
id|SCR_SFBR_REG
(paren
id|dsa
comma
id|SCR_SHL
comma
l_int|0
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|dsa
comma
id|SCR_SHL
comma
l_int|0
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|dsa
comma
id|SCR_AND
comma
l_int|0x3c
)paren
comma
l_int|0
comma
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR_1
(paren
id|dsa
)paren
comma
id|PADDR_A
(paren
id|_sms_a70
)paren
comma
id|SCR_COPY
(paren
l_int|4
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; _SMS_A70 &gt;-------------------------*/
comma
(brace
l_int|0
comma
id|RADDR_1
(paren
id|dsa
)paren
comma
multiline_comment|/*&n;&t; *  Copy the TCB header to a fixed place in &n;&t; *  the HCB.&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR_1
(paren
id|dsa
)paren
comma
id|PADDR_A
(paren
id|_sms_a80
)paren
comma
id|SCR_COPY
(paren
r_sizeof
(paren
r_struct
id|sym_tcbh
)paren
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; _SMS_A80 &gt;-------------------------*/
comma
(brace
l_int|0
comma
id|HADDR_1
(paren
id|tcb_head
)paren
comma
multiline_comment|/*&n;&t; *  We expect MESSAGE IN phase.&n;&t; *  If not, get help from the C code.&n;&t; */
id|SCR_INT
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|SIR_RESEL_NO_MSG_IN
comma
)brace
multiline_comment|/*-------------------------&lt; RESELECTED1 &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Load the synchronous transfer registers.&n;&t; */
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|HADDR_1
(paren
id|tcb_head.wval
)paren
comma
id|RADDR_1
(paren
id|scntl3
)paren
comma
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|HADDR_1
(paren
id|tcb_head.sval
)paren
comma
id|RADDR_1
(paren
id|sxfer
)paren
comma
multiline_comment|/*&n;&t; *  Get the IDENTIFY message.&n;&t; */
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|HADDR_1
(paren
id|msgin
)paren
comma
multiline_comment|/*&n;&t; *  If IDENTIFY LUN #0, use a faster path &n;&t; *  to find the LCB structure.&n;&t; */
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
l_int|0x80
comma
l_int|0xbf
)paren
)paren
comma
id|PADDR_A
(paren
id|resel_lun0
)paren
comma
multiline_comment|/*&n;&t; *  If message isn&squot;t an IDENTIFY, &n;&t; *  tell the C code about.&n;&t; */
id|SCR_INT
op_xor
id|IFFALSE
(paren
id|MASK
(paren
l_int|0x80
comma
l_int|0x80
)paren
)paren
comma
id|SIR_RESEL_NO_IDENTIFY
comma
multiline_comment|/*&n;&t; *  It is an IDENTIFY message,&n;&t; *  Load the LUN control block address.&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|HADDR_1
(paren
id|tcb_head.luntbl_sa
)paren
comma
id|RADDR_1
(paren
id|dsa
)paren
comma
id|SCR_SFBR_REG
(paren
id|dsa
comma
id|SCR_SHL
comma
l_int|0
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|dsa
comma
id|SCR_SHL
comma
l_int|0
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|dsa
comma
id|SCR_AND
comma
l_int|0xfc
)paren
comma
l_int|0
comma
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR_1
(paren
id|dsa
)paren
comma
id|PADDR_A
(paren
id|_sms_a90
)paren
comma
id|SCR_COPY
(paren
l_int|4
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; _SMS_A90 &gt;-------------------------*/
comma
(brace
l_int|0
comma
id|RADDR_1
(paren
id|dsa
)paren
comma
id|SCR_JUMPR
comma
l_int|12
comma
)brace
multiline_comment|/*-------------------------&lt; RESEL_LUN0 &gt;-----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  LUN 0 special case (but usual one :))&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|HADDR_1
(paren
id|tcb_head.lun0_sa
)paren
comma
id|RADDR_1
(paren
id|dsa
)paren
comma
multiline_comment|/*&n;&t; *  Jump indirectly to the reselect action for this LUN.&n;&t; *  (lcb.head.resel_sa assumed at offset zero of lcb).&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR_1
(paren
id|dsa
)paren
comma
id|PADDR_A
(paren
id|_sms_a100
)paren
comma
id|SCR_COPY
(paren
l_int|4
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; _SMS_A100 &gt;------------------------*/
comma
(brace
l_int|0
comma
id|RADDR_1
(paren
id|temp
)paren
comma
id|SCR_RETURN
comma
l_int|0
comma
multiline_comment|/* In normal situations, we jump to RESEL_TAG or RESEL_NO_TAG */
)brace
multiline_comment|/*-------------------------&lt; RESEL_TAG &gt;------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  ACK the IDENTIFY previously received.&n;&t; */
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  It shall be a tagged command.&n;&t; *  Read SIMPLE+TAG.&n;&t; *  The C code will deal with errors.&n;&t; *  Agressive optimization, is&squot;nt it? :)&n;&t; */
id|SCR_MOVE_ABS
(paren
l_int|2
)paren
op_xor
id|SCR_MSG_IN
comma
id|HADDR_1
(paren
id|msgin
)paren
comma
multiline_comment|/*&n;&t; *  Copy the LCB header to a fixed place in &n;&t; *  the HCB using self-modifying SCRIPTS.&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR_1
(paren
id|dsa
)paren
comma
id|PADDR_A
(paren
id|_sms_a110
)paren
comma
id|SCR_COPY
(paren
r_sizeof
(paren
r_struct
id|sym_lcbh
)paren
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; _SMS_A110 &gt;------------------------*/
comma
(brace
l_int|0
comma
id|HADDR_1
(paren
id|lcb_head
)paren
comma
multiline_comment|/*&n;&t; *  Load the pointer to the tagged task &n;&t; *  table for this LUN.&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|HADDR_1
(paren
id|lcb_head.itlq_tbl_sa
)paren
comma
id|RADDR_1
(paren
id|dsa
)paren
comma
multiline_comment|/*&n;&t; *  The SIDL still contains the TAG value.&n;&t; *  Agressive optimization, isn&squot;t it? :):)&n;&t; */
id|SCR_REG_SFBR
(paren
id|sidl
comma
id|SCR_SHL
comma
l_int|0
)paren
comma
l_int|0
comma
macro_line|#if SYM_CONF_MAX_TASK*4 &gt; 512
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|CARRYSET
)paren
comma
l_int|8
comma
id|SCR_REG_REG
(paren
id|dsa1
comma
id|SCR_OR
comma
l_int|2
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|sfbr
comma
id|SCR_SHL
comma
l_int|0
)paren
comma
l_int|0
comma
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|CARRYSET
)paren
comma
l_int|8
comma
id|SCR_REG_REG
(paren
id|dsa1
comma
id|SCR_OR
comma
l_int|1
)paren
comma
l_int|0
comma
macro_line|#elif SYM_CONF_MAX_TASK*4 &gt; 256
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|CARRYSET
)paren
comma
l_int|8
comma
id|SCR_REG_REG
(paren
id|dsa1
comma
id|SCR_OR
comma
l_int|1
)paren
comma
l_int|0
comma
macro_line|#endif
multiline_comment|/*&n;&t; *  Retrieve the DSA of this task.&n;&t; *  JUMP indirectly to the restart point of the CCB.&n;&t; */
id|SCR_SFBR_REG
(paren
id|dsa
comma
id|SCR_AND
comma
l_int|0xfc
)paren
comma
l_int|0
comma
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR_1
(paren
id|dsa
)paren
comma
id|PADDR_A
(paren
id|_sms_a120
)paren
comma
id|SCR_COPY
(paren
l_int|4
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; _SMS_A120 &gt;------------------------*/
comma
(brace
l_int|0
comma
id|RADDR_1
(paren
id|dsa
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESEL_GO &gt;-------------------------*/
comma
(brace
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR_1
(paren
id|dsa
)paren
comma
id|PADDR_A
(paren
id|_sms_a130
)paren
comma
multiline_comment|/*&n;&t; *  Move &squot;ccb.phys.head.go&squot; action to &n;&t; *  scratch/scratch1. So scratch1 will &n;&t; *  contain the &squot;restart&squot; field of the &n;&t; *  &squot;go&squot; structure.&n;&t; */
id|SCR_COPY
(paren
l_int|8
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; _SMS_A130 &gt;------------------------*/
comma
(brace
l_int|0
comma
id|PADDR_B
(paren
id|scratch
)paren
comma
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|PADDR_B
(paren
id|scratch1
)paren
comma
multiline_comment|/* phys.head.go.restart */
id|RADDR_1
(paren
id|temp
)paren
comma
id|SCR_RETURN
comma
l_int|0
comma
multiline_comment|/* In normal situations we branch to RESEL_DSA */
)brace
multiline_comment|/*-------------------------&lt; RESEL_DSA &gt;------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  ACK the IDENTIFY or TAG previously received.&n;&t; */
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; RESEL_DSA1 &gt;-----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Copy the CCB header to a fixed location &n;&t; *  in the HCB using self-modifying SCRIPTS.&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR_1
(paren
id|dsa
)paren
comma
id|PADDR_A
(paren
id|_sms_a140
)paren
comma
id|SCR_COPY
(paren
r_sizeof
(paren
r_struct
id|sym_ccbh
)paren
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; _SMS_A140 &gt;------------------------*/
comma
(brace
l_int|0
comma
id|HADDR_1
(paren
id|ccb_head
)paren
comma
multiline_comment|/*&n;&t; *  Initialize the status register&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|HADDR_1
(paren
id|ccb_head.status
)paren
comma
id|RADDR_1
(paren
id|scr0
)paren
comma
multiline_comment|/*&n;&t; *  Jump to dispatcher.&n;&t; */
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESEL_NO_TAG &gt;---------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Copy the LCB header to a fixed place in &n;&t; *  the HCB using self-modifying SCRIPTS.&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR_1
(paren
id|dsa
)paren
comma
id|PADDR_A
(paren
id|_sms_a145
)paren
comma
id|SCR_COPY
(paren
r_sizeof
(paren
r_struct
id|sym_lcbh
)paren
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; _SMS_A145 &gt;------------------------*/
comma
(brace
l_int|0
comma
id|HADDR_1
(paren
id|lcb_head
)paren
comma
multiline_comment|/*&n;&t; *  Load the DSA with the unique ITL task.&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|HADDR_1
(paren
id|lcb_head.itl_task_sa
)paren
comma
id|RADDR_1
(paren
id|dsa
)paren
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|resel_go
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATA_IN &gt;--------------------------*/
comma
(brace
multiline_comment|/*&n; *  Because the size depends on the&n; *  #define SYM_CONF_MAX_SG parameter,&n; *  it is filled in at runtime.&n; *&n; *  ##===========&lt; i=0; i&lt;SYM_CONF_MAX_SG &gt;=========&n; *  ||&t;SCR_CHMOV_TBL ^ SCR_DATA_IN,&n; *  ||&t;&t;offsetof (struct sym_dsb, data[ i]),&n; *  ##==========================================&n; */
l_int|0
)brace
multiline_comment|/*-------------------------&lt; DATA_IN2 &gt;-------------------------*/
comma
(brace
id|SCR_CALL
comma
id|PADDR_A
(paren
id|datai_done
)paren
comma
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|data_ovrun
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATA_OUT &gt;-------------------------*/
comma
(brace
multiline_comment|/*&n; *  Because the size depends on the&n; *  #define SYM_CONF_MAX_SG parameter,&n; *  it is filled in at runtime.&n; *&n; *  ##===========&lt; i=0; i&lt;SYM_CONF_MAX_SG &gt;=========&n; *  ||&t;SCR_CHMOV_TBL ^ SCR_DATA_OUT,&n; *  ||&t;&t;offsetof (struct sym_dsb, data[ i]),&n; *  ##==========================================&n; */
l_int|0
)brace
multiline_comment|/*-------------------------&lt; DATA_OUT2 &gt;------------------------*/
comma
(brace
id|SCR_CALL
comma
id|PADDR_A
(paren
id|datao_done
)paren
comma
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|data_ovrun
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PM0_DATA &gt;-------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Read our host flags to SFBR, so we will be able &n;&t; *  to check against the data direction we expect.&n;&t; */
id|SCR_FROM_REG
(paren
id|HF_REG
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Check against actual DATA PHASE.&n;&t; */
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_DATA_IN
)paren
)paren
comma
id|PADDR_A
(paren
id|pm0_data_out
)paren
comma
multiline_comment|/*&n;&t; *  Actual phase is DATA IN.&n;&t; *  Check against expected direction.&n;&t; */
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|MASK
(paren
id|HF_DATA_IN
comma
id|HF_DATA_IN
)paren
)paren
comma
id|PADDR_B
(paren
id|data_ovrun
)paren
comma
multiline_comment|/*&n;&t; *  Keep track we are moving data from the &n;&t; *  PM0 DATA mini-script.&n;&t; */
id|SCR_REG_REG
(paren
id|HF_REG
comma
id|SCR_OR
comma
id|HF_IN_PM0
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Move the data to memory.&n;&t; */
id|SCR_CHMOV_TBL
op_xor
id|SCR_DATA_IN
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.pm0.sg
)paren
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|pm0_data_end
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PM0_DATA_OUT &gt;---------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Actual phase is DATA OUT.&n;&t; *  Check against expected direction.&n;&t; */
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|HF_DATA_IN
comma
id|HF_DATA_IN
)paren
)paren
comma
id|PADDR_B
(paren
id|data_ovrun
)paren
comma
multiline_comment|/*&n;&t; *  Keep track we are moving data from the &n;&t; *  PM0 DATA mini-script.&n;&t; */
id|SCR_REG_REG
(paren
id|HF_REG
comma
id|SCR_OR
comma
id|HF_IN_PM0
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Move the data from memory.&n;&t; */
id|SCR_CHMOV_TBL
op_xor
id|SCR_DATA_OUT
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.pm0.sg
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PM0_DATA_END &gt;---------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Clear the flag that told we were moving  &n;&t; *  data from the PM0 DATA mini-script.&n;&t; */
id|SCR_REG_REG
(paren
id|HF_REG
comma
id|SCR_AND
comma
(paren
op_complement
id|HF_IN_PM0
)paren
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Return to the previous DATA script which &n;&t; *  is guaranteed by design (if no bug) to be &n;&t; *  the main DATA script for this transfer.&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR_1
(paren
id|dsa
)paren
comma
id|RADDR_1
(paren
id|scratcha
)paren
comma
id|SCR_REG_REG
(paren
id|scratcha
comma
id|SCR_ADD
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.pm0.ret
)paren
)paren
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; PM_DATA_END &gt;----------------------*/
comma
(brace
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR_1
(paren
id|scratcha
)paren
comma
id|PADDR_A
(paren
id|_sms_a150
)paren
comma
id|SCR_COPY
(paren
l_int|4
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; _SMS_A150 &gt;------------------------*/
comma
(brace
l_int|0
comma
id|RADDR_1
(paren
id|temp
)paren
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; PM1_DATA &gt;-------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Read our host flags to SFBR, so we will be able &n;&t; *  to check against the data direction we expect.&n;&t; */
id|SCR_FROM_REG
(paren
id|HF_REG
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Check against actual DATA PHASE.&n;&t; */
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_DATA_IN
)paren
)paren
comma
id|PADDR_A
(paren
id|pm1_data_out
)paren
comma
multiline_comment|/*&n;&t; *  Actual phase is DATA IN.&n;&t; *  Check against expected direction.&n;&t; */
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|MASK
(paren
id|HF_DATA_IN
comma
id|HF_DATA_IN
)paren
)paren
comma
id|PADDR_B
(paren
id|data_ovrun
)paren
comma
multiline_comment|/*&n;&t; *  Keep track we are moving data from the &n;&t; *  PM1 DATA mini-script.&n;&t; */
id|SCR_REG_REG
(paren
id|HF_REG
comma
id|SCR_OR
comma
id|HF_IN_PM1
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Move the data to memory.&n;&t; */
id|SCR_CHMOV_TBL
op_xor
id|SCR_DATA_IN
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.pm1.sg
)paren
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|pm1_data_end
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PM1_DATA_OUT &gt;---------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Actual phase is DATA OUT.&n;&t; *  Check against expected direction.&n;&t; */
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
id|HF_DATA_IN
comma
id|HF_DATA_IN
)paren
)paren
comma
id|PADDR_B
(paren
id|data_ovrun
)paren
comma
multiline_comment|/*&n;&t; *  Keep track we are moving data from the &n;&t; *  PM1 DATA mini-script.&n;&t; */
id|SCR_REG_REG
(paren
id|HF_REG
comma
id|SCR_OR
comma
id|HF_IN_PM1
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Move the data from memory.&n;&t; */
id|SCR_CHMOV_TBL
op_xor
id|SCR_DATA_OUT
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.pm1.sg
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PM1_DATA_END &gt;---------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Clear the flag that told we were moving  &n;&t; *  data from the PM1 DATA mini-script.&n;&t; */
id|SCR_REG_REG
(paren
id|HF_REG
comma
id|SCR_AND
comma
(paren
op_complement
id|HF_IN_PM1
)paren
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Return to the previous DATA script which &n;&t; *  is guaranteed by design (if no bug) to be &n;&t; *  the main DATA script for this transfer.&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR_1
(paren
id|dsa
)paren
comma
id|RADDR_1
(paren
id|scratcha
)paren
comma
id|SCR_REG_REG
(paren
id|scratcha
comma
id|SCR_ADD
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.pm1.ret
)paren
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|pm_data_end
)paren
comma
)brace
multiline_comment|/*--------------------------&lt;&gt;----------------------------------*/
)brace
suffix:semicolon
DECL|variable|SYM_FWB_SCR
r_static
r_struct
id|SYM_FWB_SCR
id|SYM_FWB_SCR
op_assign
(brace
multiline_comment|/*-------------------------&lt; NO_DATA &gt;--------------------------*/
(brace
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|data_ovrun
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SEL_FOR_ABORT &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  We are jumped here by the C code, if we have &n;&t; *  some target to reset or some disconnected &n;&t; *  job to abort. Since error recovery is a serious &n;&t; *  busyness, we will really reset the SCSI BUS, if &n;&t; *  case of a SCSI interrupt occuring in this path.&n;&t; */
macro_line|#ifdef SYM_CONF_TARGET_ROLE_SUPPORT
multiline_comment|/*&n;&t; *  Set initiator mode.&n;&t; */
id|SCR_CLR
(paren
id|SCR_TRG
)paren
comma
l_int|0
comma
macro_line|#endif
multiline_comment|/*&n;&t; *      And try to select this target.&n;&t; */
id|SCR_SEL_TBL_ATN
op_xor
m_offsetof
(paren
r_struct
id|sym_hcb
comma
id|abrt_sel
)paren
comma
id|PADDR_A
(paren
id|reselect
)paren
comma
multiline_comment|/*&n;&t; *  Wait for the selection to complete or &n;&t; *  the selection to time out.&n;&t; */
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
op_minus
l_int|8
comma
multiline_comment|/*&n;&t; *  Call the C code.&n;&t; */
id|SCR_INT
comma
id|SIR_TARGET_SELECTED
comma
multiline_comment|/*&n;&t; *  The C code should let us continue here. &n;&t; *  Send the &squot;kiss of death&squot; message.&n;&t; *  We expect an immediate disconnect once &n;&t; *  the target has eaten the message.&n;&t; */
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_AND
comma
l_int|0x7f
)paren
comma
l_int|0
comma
id|SCR_MOVE_TBL
op_xor
id|SCR_MSG_OUT
comma
m_offsetof
(paren
r_struct
id|sym_hcb
comma
id|abrt_tbl
)paren
comma
id|SCR_CLR
(paren
id|SCR_ACK
op_or
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_WAIT_DISC
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  Tell the C code that we are done.&n;&t; */
id|SCR_INT
comma
id|SIR_ABORT_SENT
comma
)brace
multiline_comment|/*-------------------------&lt; SEL_FOR_ABORT_1 &gt;------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Jump at scheduler.&n;&t; */
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|start
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_IN_ETC &gt;-----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  If it is an EXTENDED (variable size message)&n;&t; *  Handle it.&n;&t; */
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
id|M_EXTENDED
)paren
)paren
comma
id|PADDR_B
(paren
id|msg_extended
)paren
comma
multiline_comment|/*&n;&t; *  Let the C code handle any other &n;&t; *  1 byte message.&n;&t; */
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
l_int|0x00
comma
l_int|0xf0
)paren
)paren
comma
id|PADDR_B
(paren
id|msg_received
)paren
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|MASK
(paren
l_int|0x10
comma
l_int|0xf0
)paren
)paren
comma
id|PADDR_B
(paren
id|msg_received
)paren
comma
multiline_comment|/*&n;&t; *  We donnot handle 2 bytes messages from SCRIPTS.&n;&t; *  So, let the C code deal with these ones too.&n;&t; */
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|MASK
(paren
l_int|0x20
comma
l_int|0xf0
)paren
)paren
comma
id|PADDR_B
(paren
id|msg_weird_seen
)paren
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|HADDR_1
(paren
id|msgin
(braket
l_int|1
)braket
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_RECEIVED &gt;---------------------*/
comma
(brace
id|SCR_COPY
(paren
l_int|4
)paren
comma
multiline_comment|/* DUMMY READ */
id|HADDR_1
(paren
id|scratch
)paren
comma
id|RADDR_1
(paren
id|scratcha
)paren
comma
id|SCR_INT
comma
id|SIR_MSG_RECEIVED
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_WEIRD_SEEN &gt;-------------------*/
comma
(brace
id|SCR_COPY
(paren
l_int|4
)paren
comma
multiline_comment|/* DUMMY READ */
id|HADDR_1
(paren
id|scratch
)paren
comma
id|RADDR_1
(paren
id|scratcha
)paren
comma
id|SCR_INT
comma
id|SIR_MSG_WEIRD
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_EXTENDED &gt;---------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Clear ACK and get the next byte &n;&t; *  assumed to be the message length.&n;&t; */
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|HADDR_1
(paren
id|msgin
(braket
l_int|1
)braket
)paren
comma
multiline_comment|/*&n;&t; *  Try to catch some unlikely situations as 0 length &n;&t; *  or too large the length.&n;&t; */
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|DATA
(paren
l_int|0
)paren
)paren
comma
id|PADDR_B
(paren
id|msg_weird_seen
)paren
comma
id|SCR_TO_REG
(paren
id|scratcha
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|sfbr
comma
id|SCR_ADD
comma
(paren
l_int|256
op_minus
l_int|8
)paren
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|CARRYSET
)paren
comma
id|PADDR_B
(paren
id|msg_weird_seen
)paren
comma
multiline_comment|/*&n;&t; *  We donnot handle extended messages from SCRIPTS.&n;&t; *  Read the amount of data correponding to the &n;&t; *  message length and call the C code.&n;&t; */
id|SCR_COPY
(paren
l_int|1
)paren
comma
id|RADDR_1
(paren
id|scratcha
)paren
comma
id|PADDR_B
(paren
id|_sms_b10
)paren
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; _SMS_B10 &gt;-------------------------*/
comma
(brace
id|SCR_MOVE_ABS
(paren
l_int|0
)paren
op_xor
id|SCR_MSG_IN
comma
id|HADDR_1
(paren
id|msgin
(braket
l_int|2
)braket
)paren
comma
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|msg_received
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_BAD &gt;--------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  unimplemented message - reject it.&n;&t; */
id|SCR_INT
comma
id|SIR_REJECT_TO_SEND
comma
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|clrack
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_WEIRD &gt;------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  weird message received&n;&t; *  ignore all MSG IN phases and reject it.&n;&t; */
id|SCR_INT
comma
id|SIR_REJECT_TO_SEND
comma
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_WEIRD1 &gt;-----------------------*/
comma
(brace
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_IN
)paren
)paren
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_IN
comma
id|HADDR_1
(paren
id|scratch
)paren
comma
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|msg_weird1
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; WDTR_RESP &gt;------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  let the target fetch our answer.&n;&t; */
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|PADDR_B
(paren
id|nego_bad_phase
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SEND_WDTR &gt;------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Send the M_X_WIDE_REQ&n;&t; */
id|SCR_MOVE_ABS
(paren
l_int|4
)paren
op_xor
id|SCR_MSG_OUT
comma
id|HADDR_1
(paren
id|msgout
)paren
comma
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|msg_out_done
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SDTR_RESP &gt;------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  let the target fetch our answer.&n;&t; */
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|PADDR_B
(paren
id|nego_bad_phase
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SEND_SDTR &gt;------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Send the M_X_SYNC_REQ&n;&t; */
id|SCR_MOVE_ABS
(paren
l_int|5
)paren
op_xor
id|SCR_MSG_OUT
comma
id|HADDR_1
(paren
id|msgout
)paren
comma
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|msg_out_done
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; PPR_RESP &gt;-------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  let the target fetch our answer.&n;&t; */
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
id|SCR_JUMP
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|PADDR_B
(paren
id|nego_bad_phase
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SEND_PPR &gt;-------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Send the M_X_PPR_REQ&n;&t; */
id|SCR_MOVE_ABS
(paren
l_int|8
)paren
op_xor
id|SCR_MSG_OUT
comma
id|HADDR_1
(paren
id|msgout
)paren
comma
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|msg_out_done
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; NEGO_BAD_PHASE &gt;-------------------*/
comma
(brace
id|SCR_INT
comma
id|SIR_NEGO_PROTO
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_OUT &gt;--------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  The target requests a message.&n;&t; *  We donnot send messages that may &n;&t; *  require the device to go to bus free.&n;&t; */
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_OUT
comma
id|HADDR_1
(paren
id|msgout
)paren
comma
multiline_comment|/*&n;&t; *  ... wait for the next phase&n;&t; *  if it&squot;s a message out, send it again, ...&n;&t; */
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_MSG_OUT
)paren
)paren
comma
id|PADDR_B
(paren
id|msg_out
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; MSG_OUT_DONE &gt;---------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Let the C code be aware of the &n;&t; *  sent message and clear the message.&n;&t; */
id|SCR_INT
comma
id|SIR_MSG_OUT_DONE
comma
multiline_comment|/*&n;&t; *  ... and process the next phase&n;&t; */
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATA_OVRUN &gt;-----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Zero scratcha that will count the &n;&t; *  extras bytes.&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|PADDR_B
(paren
id|zero
)paren
comma
id|RADDR_1
(paren
id|scratcha
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATA_OVRUN1 &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  The target may want to transfer too much data.&n;&t; *&n;&t; *  If phase is DATA OUT write 1 byte and count it.&n;&t; */
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|WHEN
(paren
id|SCR_DATA_OUT
)paren
)paren
comma
l_int|16
comma
id|SCR_CHMOV_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_DATA_OUT
comma
id|HADDR_1
(paren
id|scratch
)paren
comma
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|data_ovrun2
)paren
comma
multiline_comment|/*&n;&t; *  If WSR is set, clear this condition, and &n;&t; *  count this byte.&n;&t; */
id|SCR_FROM_REG
(paren
id|scntl2
)paren
comma
l_int|0
comma
id|SCR_JUMPR
op_xor
id|IFFALSE
(paren
id|MASK
(paren
id|WSR
comma
id|WSR
)paren
)paren
comma
l_int|16
comma
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_OR
comma
id|WSR
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|data_ovrun2
)paren
comma
multiline_comment|/*&n;&t; *  Finally check against DATA IN phase.&n;&t; *  Signal data overrun to the C code &n;&t; *  and jump to dispatcher if not so.&n;&t; *  Read 1 byte otherwise and count it.&n;&t; */
id|SCR_JUMPR
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_DATA_IN
)paren
)paren
comma
l_int|16
comma
id|SCR_INT
comma
id|SIR_DATA_OVERRUN
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
id|SCR_CHMOV_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_DATA_IN
comma
id|HADDR_1
(paren
id|scratch
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATA_OVRUN2 &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Count this byte.&n;&t; *  This will allow to return a negative &n;&t; *  residual to user.&n;&t; */
id|SCR_REG_REG
(paren
id|scratcha
comma
id|SCR_ADD
comma
l_int|0x01
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|scratcha1
comma
id|SCR_ADDC
comma
l_int|0
)paren
comma
l_int|0
comma
id|SCR_REG_REG
(paren
id|scratcha2
comma
id|SCR_ADDC
comma
l_int|0
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  .. and repeat as required.&n;&t; */
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|data_ovrun1
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; ABORT_RESEL &gt;----------------------*/
comma
(brace
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_CLR
(paren
id|SCR_ACK
)paren
comma
l_int|0
comma
multiline_comment|/*&n;&t; *  send the abort/abortag/reset message&n;&t; *  we expect an immediate disconnect&n;&t; */
id|SCR_REG_REG
(paren
id|scntl2
comma
id|SCR_AND
comma
l_int|0x7f
)paren
comma
l_int|0
comma
id|SCR_MOVE_ABS
(paren
l_int|1
)paren
op_xor
id|SCR_MSG_OUT
comma
id|HADDR_1
(paren
id|msgout
)paren
comma
id|SCR_CLR
(paren
id|SCR_ACK
op_or
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_WAIT_DISC
comma
l_int|0
comma
id|SCR_INT
comma
id|SIR_RESEL_ABORTED
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|start
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESEND_IDENT &gt;---------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  The target stays in MSG OUT phase after having acked &n;&t; *  Identify [+ Tag [+ Extended message ]]. Targets shall&n;&t; *  behave this way on parity error.&n;&t; *  We must send it again all the messages.&n;&t; */
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
multiline_comment|/* Shall be asserted 2 deskew delays before the  */
l_int|0
comma
multiline_comment|/* 1rst ACK = 90 ns. Hope the chip isn&squot;t too fast */
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|send_ident
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; IDENT_BREAK &gt;----------------------*/
comma
(brace
id|SCR_CLR
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|select2
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; IDENT_BREAK_ATN &gt;------------------*/
comma
(brace
id|SCR_SET
(paren
id|SCR_ATN
)paren
comma
l_int|0
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|select2
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SDATA_IN &gt;-------------------------*/
comma
(brace
id|SCR_CHMOV_TBL
op_xor
id|SCR_DATA_IN
comma
m_offsetof
(paren
r_struct
id|sym_dsb
comma
id|sense
)paren
comma
id|SCR_CALL
comma
id|PADDR_A
(paren
id|datai_done
)paren
comma
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|data_ovrun
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; RESEL_BAD_LUN &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Message is an IDENTIFY, but lun is unknown.&n;&t; *  Signal problem to C code for logging the event.&n;&t; *  Send a M_ABORT to clear all pending tasks.&n;&t; */
id|SCR_INT
comma
id|SIR_RESEL_BAD_LUN
comma
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|abort_resel
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; BAD_I_T_L &gt;------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  We donnot have a task for that I_T_L.&n;&t; *  Signal problem to C code for logging the event.&n;&t; *  Send a M_ABORT message.&n;&t; */
id|SCR_INT
comma
id|SIR_RESEL_BAD_I_T_L
comma
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|abort_resel
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; BAD_I_T_L_Q &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  We donnot have a task that matches the tag.&n;&t; *  Signal problem to C code for logging the event.&n;&t; *  Send a M_ABORTTAG message.&n;&t; */
id|SCR_INT
comma
id|SIR_RESEL_BAD_I_T_L_Q
comma
id|SCR_JUMP
comma
id|PADDR_B
(paren
id|abort_resel
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; BAD_STATUS &gt;-----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Anything different from INTERMEDIATE &n;&t; *  CONDITION MET should be a bad SCSI status, &n;&t; *  given that GOOD status has already been tested.&n;&t; *  Call the C code.&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|PADDR_B
(paren
id|startpos
)paren
comma
id|RADDR_1
(paren
id|scratcha
)paren
comma
id|SCR_INT
op_xor
id|IFFALSE
(paren
id|DATA
(paren
id|S_COND_MET
)paren
)paren
comma
id|SIR_BAD_SCSI_STATUS
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; WSR_MA_HELPER &gt;--------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Helper for the C code when WSR bit is set.&n;&t; *  Perform the move of the residual byte.&n;&t; */
id|SCR_CHMOV_TBL
op_xor
id|SCR_DATA_IN
comma
m_offsetof
(paren
r_struct
id|sym_ccb
comma
id|phys.wresid
)paren
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|dispatch
)paren
comma
macro_line|#ifdef SYM_OPT_HANDLE_DIR_UNKNOWN
)brace
multiline_comment|/*-------------------------&lt; DATA_IO &gt;--------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  We jump here if the data direction was unknown at the &n;&t; *  time we had to queue the command to the scripts processor.&n;&t; *  Pointers had been set as follow in this situation:&n;&t; *    savep   --&gt;   DATA_IO&n;&t; *    lastp   --&gt;   start pointer when DATA_IN&n;&t; *    wlastp  --&gt;   start pointer when DATA_OUT&n;&t; *  This script sets savep and lastp according to the &n;&t; *  direction chosen by the target.&n;&t; */
id|SCR_JUMP
op_xor
id|IFTRUE
(paren
id|WHEN
(paren
id|SCR_DATA_OUT
)paren
)paren
comma
id|PADDR_B
(paren
id|data_io_out
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; DATA_IO_COM &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Direction is DATA IN.&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|HADDR_1
(paren
id|ccb_head.lastp
)paren
comma
id|HADDR_1
(paren
id|ccb_head.savep
)paren
comma
multiline_comment|/*&n;&t; *  Jump to the SCRIPTS according to actual direction.&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|HADDR_1
(paren
id|ccb_head.savep
)paren
comma
id|RADDR_1
(paren
id|temp
)paren
comma
id|SCR_RETURN
comma
l_int|0
comma
)brace
multiline_comment|/*-------------------------&lt; DATA_IO_OUT &gt;----------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Direction is DATA OUT.&n;&t; */
id|SCR_REG_REG
(paren
id|HF_REG
comma
id|SCR_AND
comma
(paren
op_complement
id|HF_DATA_IN
)paren
)paren
comma
l_int|0
comma
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|HADDR_1
(paren
id|ccb_head.wlastp
)paren
comma
id|HADDR_1
(paren
id|ccb_head.lastp
)paren
comma
id|SCR_JUMP
comma
id|PADDR_B
c_func
(paren
id|data_io_com
)paren
comma
macro_line|#endif /* SYM_OPT_HANDLE_DIR_UNKNOWN */
)brace
multiline_comment|/*-------------------------&lt; ZERO &gt;-----------------------------*/
comma
(brace
id|SCR_DATA_ZERO
comma
)brace
multiline_comment|/*-------------------------&lt; SCRATCH &gt;--------------------------*/
comma
(brace
id|SCR_DATA_ZERO
comma
multiline_comment|/* MUST BE BEFORE SCRATCH1 */
)brace
multiline_comment|/*-------------------------&lt; SCRATCH1 &gt;-------------------------*/
comma
(brace
id|SCR_DATA_ZERO
comma
)brace
multiline_comment|/*-------------------------&lt; PREV_DONE &gt;------------------------*/
comma
(brace
id|SCR_DATA_ZERO
comma
multiline_comment|/* MUST BE BEFORE DONE_POS ! */
)brace
multiline_comment|/*-------------------------&lt; DONE_POS &gt;-------------------------*/
comma
(brace
id|SCR_DATA_ZERO
comma
)brace
multiline_comment|/*-------------------------&lt; NEXTJOB &gt;--------------------------*/
comma
(brace
id|SCR_DATA_ZERO
comma
multiline_comment|/* MUST BE BEFORE STARTPOS ! */
)brace
multiline_comment|/*-------------------------&lt; STARTPOS &gt;-------------------------*/
comma
(brace
id|SCR_DATA_ZERO
comma
)brace
multiline_comment|/*-------------------------&lt; TARGTBL &gt;--------------------------*/
comma
(brace
id|SCR_DATA_ZERO
comma
)brace
multiline_comment|/*--------------------------&lt;&gt;----------------------------------*/
)brace
suffix:semicolon
DECL|variable|SYM_FWZ_SCR
r_static
r_struct
id|SYM_FWZ_SCR
id|SYM_FWZ_SCR
op_assign
(brace
multiline_comment|/*-------------------------&lt; SNOOPTEST &gt;------------------------*/
(brace
multiline_comment|/*&n;&t; *  Read the variable.&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|HADDR_1
(paren
id|scratch
)paren
comma
id|RADDR_1
(paren
id|scratcha
)paren
comma
multiline_comment|/*&n;&t; *  Write the variable.&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|RADDR_1
(paren
id|temp
)paren
comma
id|HADDR_1
(paren
id|scratch
)paren
comma
multiline_comment|/*&n;&t; *  Read back the variable.&n;&t; */
id|SCR_COPY
(paren
l_int|4
)paren
comma
id|HADDR_1
(paren
id|scratch
)paren
comma
id|RADDR_1
(paren
id|temp
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SNOOPEND &gt;-------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  And stop.&n;&t; */
id|SCR_INT
comma
l_int|99
comma
macro_line|#ifdef SYM_OPT_NO_BUS_MEMORY_MAPPING
multiline_comment|/*&n;&t; *  We may use MEMORY MOVE instructions to load the on chip-RAM,&n;&t; *  if it happens that mapping PCI memory is not possible.&n;&t; *  But writing the RAM from the CPU is the preferred method, &n;&t; *  since PCI 2.2 seems to disallow PCI self-mastering.&n;&t; */
)brace
multiline_comment|/*-------------------------&lt; START_RAM &gt;------------------------*/
comma
(brace
multiline_comment|/*&n;&t; *  Load the script into on-chip RAM, &n;&t; *  and jump to start point.&n;&t; */
id|SCR_COPY
(paren
r_sizeof
(paren
r_struct
id|SYM_FWA_SCR
)paren
)paren
comma
)brace
multiline_comment|/*-------------------------&lt; SCRIPTA0_BA &gt;----------------------*/
comma
(brace
l_int|0
comma
id|PADDR_A
(paren
id|start
)paren
comma
id|SCR_JUMP
comma
id|PADDR_A
(paren
id|init
)paren
comma
macro_line|#endif /* SYM_OPT_NO_BUS_MEMORY_MAPPING */
)brace
multiline_comment|/*--------------------------&lt;&gt;----------------------------------*/
)brace
suffix:semicolon
eof
