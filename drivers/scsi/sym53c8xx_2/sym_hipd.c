multiline_comment|/*&n; * Device driver for the SYMBIOS/LSILOGIC 53C8XX and 53C1010 family &n; * of PCI-SCSI IO processors.&n; *&n; * Copyright (C) 1999-2001  Gerard Roudier &lt;groudier@free.fr&gt;&n; *&n; * This driver is derived from the Linux sym53c8xx driver.&n; * Copyright (C) 1998-2000  Gerard Roudier&n; *&n; * The sym53c8xx driver is derived from the ncr53c8xx driver that had been &n; * a port of the FreeBSD ncr driver to Linux-1.2.13.&n; *&n; * The original ncr driver has been written for 386bsd and FreeBSD by&n; *         Wolfgang Stanglmeier        &lt;wolf@cologne.de&gt;&n; *         Stefan Esser                &lt;se@mi.Uni-Koeln.de&gt;&n; * Copyright (C) 1994  Wolfgang Stanglmeier&n; *&n; * Other major contributions:&n; *&n; * NVRAM detection and reading.&n; * Copyright (C) 1997 Richard Waltham &lt;dormouse@farsrobt.demon.co.uk&gt;&n; *&n; *-----------------------------------------------------------------------------&n; *&n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions&n; * are met:&n; * 1. Redistributions of source code must retain the above copyright&n; *    notice, this list of conditions and the following disclaimer.&n; * 2. The name of the author may not be used to endorse or promote products&n; *    derived from this software without specific prior written permission.&n; *&n; * Where this Software is combined with software released under the terms of &n; * the GNU Public License (&quot;GPL&quot;) and the terms of the GPL would require the &n; * combined work to also be released under the terms of the GPL, the terms&n; * and conditions of this License will apply in addition to those of the&n; * GPL with the exception of any terms or conditions of this License that&n; * conflict with, or are expressly prohibited by, the GPL.&n; *&n; * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS&squot;&squot; AND&n; * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE&n; * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE&n; * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR&n; * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL&n; * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS&n; * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)&n; * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT&n; * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY&n; * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF&n; * SUCH DAMAGE.&n; */
DECL|macro|SYM_VERSION
mdefine_line|#define SYM_VERSION &quot;2.1.18j&quot;
DECL|macro|SYM_DRIVER_NAME
mdefine_line|#define SYM_DRIVER_NAME&t;&quot;sym-&quot; SYM_VERSION
macro_line|#include &quot;sym_glue.h&quot;
macro_line|#include &quot;sym_nvram.h&quot;
macro_line|#if 0
mdefine_line|#define SYM_DEBUG_GENERIC_SUPPORT
macro_line|#endif
multiline_comment|/*&n; *  Needed function prototypes.&n; */
r_static
r_void
id|sym_int_ma
(paren
id|hcb_p
id|np
)paren
suffix:semicolon
r_static
r_void
id|sym_int_sir
(paren
id|hcb_p
id|np
)paren
suffix:semicolon
r_static
id|ccb_p
id|sym_alloc_ccb
c_func
(paren
id|hcb_p
id|np
)paren
suffix:semicolon
r_static
id|ccb_p
id|sym_ccb_from_dsa
c_func
(paren
id|hcb_p
id|np
comma
id|u32
id|dsa
)paren
suffix:semicolon
r_static
r_void
id|sym_alloc_lcb_tags
(paren
id|hcb_p
id|np
comma
id|u_char
id|tn
comma
id|u_char
id|ln
)paren
suffix:semicolon
r_static
r_void
id|sym_complete_error
(paren
id|hcb_p
id|np
comma
id|ccb_p
id|cp
)paren
suffix:semicolon
r_static
r_void
id|sym_complete_ok
(paren
id|hcb_p
id|np
comma
id|ccb_p
id|cp
)paren
suffix:semicolon
r_static
r_int
id|sym_compute_residual
c_func
(paren
id|hcb_p
id|np
comma
id|ccb_p
id|cp
)paren
suffix:semicolon
multiline_comment|/*&n; *  Returns the name of this driver.&n; */
DECL|function|sym_driver_name
r_char
op_star
id|sym_driver_name
c_func
(paren
r_void
)paren
(brace
r_return
id|SYM_DRIVER_NAME
suffix:semicolon
)brace
multiline_comment|/*&n; *  Print a buffer in hexadecimal format.&n; */
DECL|function|sym_printb_hex
r_static
r_void
id|sym_printb_hex
(paren
id|u_char
op_star
id|p
comma
r_int
id|n
)paren
(brace
r_while
c_loop
(paren
id|n
op_decrement
OG
l_int|0
)paren
id|printf
(paren
l_string|&quot; %x&quot;
comma
op_star
id|p
op_increment
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Same with a label at beginning and .&bslash;n at end.&n; */
DECL|function|sym_printl_hex
r_static
r_void
id|sym_printl_hex
(paren
r_char
op_star
id|label
comma
id|u_char
op_star
id|p
comma
r_int
id|n
)paren
(brace
id|printf
(paren
l_string|&quot;%s&quot;
comma
id|label
)paren
suffix:semicolon
id|sym_printb_hex
(paren
id|p
comma
id|n
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Print something which allows to retrieve the controler type, &n; *  unit, target, lun concerned by a kernel message.&n; */
DECL|function|sym_print_target
r_static
r_void
id|sym_print_target
(paren
id|hcb_p
id|np
comma
r_int
id|target
)paren
(brace
id|printf
(paren
l_string|&quot;%s:%d:&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
comma
id|target
)paren
suffix:semicolon
)brace
DECL|function|sym_print_lun
r_static
r_void
id|sym_print_lun
c_func
(paren
id|hcb_p
id|np
comma
r_int
id|target
comma
r_int
id|lun
)paren
(brace
id|printf
(paren
l_string|&quot;%s:%d:%d:&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
comma
id|target
comma
id|lun
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Print out the content of a SCSI message.&n; */
DECL|function|sym_show_msg
r_static
r_int
id|sym_show_msg
(paren
id|u_char
op_star
id|msg
)paren
(brace
id|u_char
id|i
suffix:semicolon
id|printf
(paren
l_string|&quot;%x&quot;
comma
op_star
id|msg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|msg
op_eq
id|M_EXTENDED
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_minus
l_int|1
OG
id|msg
(braket
l_int|1
)braket
)paren
r_break
suffix:semicolon
id|printf
(paren
l_string|&quot;-%x&quot;
comma
id|msg
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
(paren
id|i
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
op_star
id|msg
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
(brace
id|printf
(paren
l_string|&quot;-%x&quot;
comma
id|msg
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
(paren
l_int|2
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|sym_print_msg
r_static
r_void
id|sym_print_msg
(paren
id|ccb_p
id|cp
comma
r_char
op_star
id|label
comma
id|u_char
op_star
id|msg
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|label
)paren
id|printf
(paren
l_string|&quot;%s: &quot;
comma
id|label
)paren
suffix:semicolon
(paren
r_void
)paren
id|sym_show_msg
(paren
id|msg
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|sym_print_nego_msg
r_static
r_void
id|sym_print_nego_msg
(paren
id|hcb_p
id|np
comma
r_int
id|target
comma
r_char
op_star
id|label
comma
id|u_char
op_star
id|msg
)paren
(brace
id|PRINT_TARGET
c_func
(paren
id|np
comma
id|target
)paren
suffix:semicolon
r_if
c_cond
(paren
id|label
)paren
id|printf
(paren
l_string|&quot;%s: &quot;
comma
id|label
)paren
suffix:semicolon
(paren
r_void
)paren
id|sym_show_msg
(paren
id|msg
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Print something that tells about extended errors.&n; */
DECL|function|sym_print_xerr
r_void
id|sym_print_xerr
c_func
(paren
id|ccb_p
id|cp
comma
r_int
id|x_status
)paren
(brace
r_if
c_cond
(paren
id|x_status
op_amp
id|XE_PARITY_ERR
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;unrecovered SCSI parity error.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x_status
op_amp
id|XE_EXTRA_DATA
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;extraneous data discarded.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x_status
op_amp
id|XE_BAD_PHASE
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;illegal scsi phase (4/5).&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x_status
op_amp
id|XE_SODL_UNRUN
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;ODD transfer in DATA OUT phase.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x_status
op_amp
id|XE_SWIDE_OVRUN
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;ODD transfer in DATA IN phase.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *  Return a string for SCSI BUS mode.&n; */
DECL|function|sym_scsi_bus_mode
r_static
r_char
op_star
id|sym_scsi_bus_mode
c_func
(paren
r_int
id|mode
)paren
(brace
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|SMODE_HVD
suffix:colon
r_return
l_string|&quot;HVD&quot;
suffix:semicolon
r_case
id|SMODE_SE
suffix:colon
r_return
l_string|&quot;SE&quot;
suffix:semicolon
r_case
id|SMODE_LVD
suffix:colon
r_return
l_string|&quot;LVD&quot;
suffix:semicolon
)brace
r_return
l_string|&quot;??&quot;
suffix:semicolon
)brace
multiline_comment|/*&n; *  Soft reset the chip.&n; *&n; *  Raising SRST when the chip is running may cause &n; *  problems on dual function chips (see below).&n; *  On the other hand, LVD devices need some delay &n; *  to settle and report actual BUS mode in STEST4.&n; */
DECL|function|sym_chip_reset
r_static
r_void
id|sym_chip_reset
(paren
id|hcb_p
id|np
)paren
(brace
id|OUTB
(paren
id|nc_istat
comma
id|SRST
)paren
suffix:semicolon
id|UDELAY
(paren
l_int|10
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
l_int|0
)paren
suffix:semicolon
id|UDELAY
c_func
(paren
l_int|2000
)paren
suffix:semicolon
multiline_comment|/* For BUS MODE to settle */
)brace
multiline_comment|/*&n; *  Really soft reset the chip.:)&n; *&n; *  Some 896 and 876 chip revisions may hang-up if we set &n; *  the SRST (soft reset) bit at the wrong time when SCRIPTS &n; *  are running.&n; *  So, we need to abort the current operation prior to &n; *  soft resetting the chip.&n; */
DECL|function|sym_soft_reset
r_static
r_void
id|sym_soft_reset
(paren
id|hcb_p
id|np
)paren
(brace
id|u_char
id|istat
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|np-&gt;features
op_amp
id|FE_ISTAT1
)paren
op_logical_or
op_logical_neg
(paren
id|INB
(paren
id|nc_istat1
)paren
op_amp
id|SCRUN
)paren
)paren
r_goto
id|do_chip_reset
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
id|CABRT
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|100000
suffix:semicolon
id|i
suffix:semicolon
op_decrement
id|i
)paren
(brace
id|istat
op_assign
id|INB
(paren
id|nc_istat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|istat
op_amp
id|SIP
)paren
(brace
id|INW
(paren
id|nc_sist
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|istat
op_amp
id|DIP
)paren
(brace
r_if
c_cond
(paren
id|INB
(paren
id|nc_dstat
)paren
op_amp
id|ABRT
)paren
r_break
suffix:semicolon
)brace
id|UDELAY
c_func
(paren
l_int|5
)paren
suffix:semicolon
)brace
id|OUTB
(paren
id|nc_istat
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
id|printf
c_func
(paren
l_string|&quot;%s: unable to abort current chip operation, &quot;
l_string|&quot;ISTAT=0x%02x.&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
comma
id|istat
)paren
suffix:semicolon
id|do_chip_reset
suffix:colon
id|sym_chip_reset
(paren
id|np
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Start reset process.&n; *&n; *  The interrupt handler will reinitialize the chip.&n; */
DECL|function|sym_start_reset
r_static
r_void
id|sym_start_reset
c_func
(paren
id|hcb_p
id|np
)paren
(brace
(paren
r_void
)paren
id|sym_reset_scsi_bus
c_func
(paren
id|np
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|sym_reset_scsi_bus
r_int
id|sym_reset_scsi_bus
c_func
(paren
id|hcb_p
id|np
comma
r_int
id|enab_int
)paren
(brace
id|u32
id|term
suffix:semicolon
r_int
id|retv
op_assign
l_int|0
suffix:semicolon
id|sym_soft_reset
c_func
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/* Soft reset the chip */
r_if
c_cond
(paren
id|enab_int
)paren
id|OUTW
(paren
id|nc_sien
comma
id|RST
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Enable Tolerant, reset IRQD if present and &n;&t; *  properly set IRQ mode, prior to resetting the bus.&n;&t; */
id|OUTB
(paren
id|nc_stest3
comma
id|TE
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_dcntl
comma
(paren
id|np-&gt;rv_dcntl
op_amp
id|IRQM
)paren
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_scntl1
comma
id|CRST
)paren
suffix:semicolon
id|UDELAY
(paren
l_int|200
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SYM_SETUP_SCSI_BUS_CHECK
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; *  Check for no terminators or SCSI bus shorts to ground.&n;&t; *  Read SCSI data bus, data parity bits and control signals.&n;&t; *  We are expecting RESET to be TRUE and other signals to be &n;&t; *  FALSE.&n;&t; */
id|term
op_assign
id|INB
c_func
(paren
id|nc_sstat0
)paren
suffix:semicolon
id|term
op_assign
(paren
(paren
id|term
op_amp
l_int|2
)paren
op_lshift
l_int|7
)paren
op_plus
(paren
(paren
id|term
op_amp
l_int|1
)paren
op_lshift
l_int|17
)paren
suffix:semicolon
multiline_comment|/* rst sdp0 */
id|term
op_or_assign
(paren
(paren
id|INB
c_func
(paren
id|nc_sstat2
)paren
op_amp
l_int|0x01
)paren
op_lshift
l_int|26
)paren
op_or
multiline_comment|/* sdp1     */
(paren
(paren
id|INW
c_func
(paren
id|nc_sbdl
)paren
op_amp
l_int|0xff
)paren
op_lshift
l_int|9
)paren
op_or
multiline_comment|/* d7-0     */
(paren
(paren
id|INW
c_func
(paren
id|nc_sbdl
)paren
op_amp
l_int|0xff00
)paren
op_lshift
l_int|10
)paren
op_or
multiline_comment|/* d15-8    */
id|INB
c_func
(paren
id|nc_sbcl
)paren
suffix:semicolon
multiline_comment|/* req ack bsy sel atn msg cd io    */
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;maxwide
)paren
id|term
op_and_assign
l_int|0x3ffff
suffix:semicolon
r_if
c_cond
(paren
id|term
op_ne
(paren
l_int|2
op_lshift
l_int|7
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: suspicious SCSI data while resetting the BUS.&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s: %sdp0,d7-0,rst,req,ack,bsy,sel,atn,msg,c/d,i/o = &quot;
l_string|&quot;0x%lx, expecting 0x%lx&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
comma
(paren
id|np-&gt;features
op_amp
id|FE_WIDE
)paren
ques
c_cond
l_string|&quot;dp1,d15-8,&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|u_long
)paren
id|term
comma
(paren
id|u_long
)paren
(paren
l_int|2
op_lshift
l_int|7
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SYM_SETUP_SCSI_BUS_CHECK
op_eq
l_int|1
)paren
id|retv
op_assign
l_int|1
suffix:semicolon
)brace
id|out
suffix:colon
id|OUTB
(paren
id|nc_scntl1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* MDELAY(100); */
r_return
id|retv
suffix:semicolon
)brace
multiline_comment|/*&n; *  Select SCSI clock frequency&n; */
DECL|function|sym_selectclock
r_static
r_void
id|sym_selectclock
c_func
(paren
id|hcb_p
id|np
comma
id|u_char
id|scntl3
)paren
(brace
multiline_comment|/*&n;&t; *  If multiplier not present or not selected, leave here.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;multiplier
op_le
l_int|1
)paren
(brace
id|OUTB
c_func
(paren
id|nc_scntl3
comma
id|scntl3
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sym_verbose
op_ge
l_int|2
)paren
id|printf
(paren
l_string|&quot;%s: enabling clock multiplier&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_stest1
comma
id|DBLEN
)paren
suffix:semicolon
multiline_comment|/* Enable clock multiplier&t;&t;  */
multiline_comment|/*&n;&t; *  Wait for the LCKFRQ bit to be set if supported by the chip.&n;&t; *  Otherwise wait 50 micro-seconds (at least).&n;&t; */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_LCKFRQ
)paren
(brace
r_int
id|i
op_assign
l_int|20
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|INB
c_func
(paren
id|nc_stest4
)paren
op_amp
id|LCKFRQ
)paren
op_logical_and
op_decrement
id|i
OG
l_int|0
)paren
id|UDELAY
(paren
l_int|20
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
id|printf
c_func
(paren
l_string|&quot;%s: the chip cannot lock the frequency&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
)brace
r_else
id|UDELAY
(paren
(paren
l_int|50
op_plus
l_int|10
)paren
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_stest3
comma
id|HSC
)paren
suffix:semicolon
multiline_comment|/* Halt the scsi clock&t;&t;*/
id|OUTB
c_func
(paren
id|nc_scntl3
comma
id|scntl3
)paren
suffix:semicolon
id|OUTB
c_func
(paren
id|nc_stest1
comma
(paren
id|DBLEN
op_or
id|DBLSEL
)paren
)paren
suffix:semicolon
multiline_comment|/* Select clock multiplier&t;*/
id|OUTB
c_func
(paren
id|nc_stest3
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/* Restart scsi clock &t;&t;*/
)brace
multiline_comment|/*&n; *  Determine the chip&squot;s clock frequency.&n; *&n; *  This is essential for the negotiation of the synchronous &n; *  transfer rate.&n; *&n; *  Note: we have to return the correct value.&n; *  THERE IS NO SAFE DEFAULT VALUE.&n; *&n; *  Most NCR/SYMBIOS boards are delivered with a 40 Mhz clock.&n; *  53C860 and 53C875 rev. 1 support fast20 transfers but &n; *  do not have a clock doubler and so are provided with a &n; *  80 MHz clock. All other fast20 boards incorporate a doubler &n; *  and so should be delivered with a 40 MHz clock.&n; *  The recent fast40 chips (895/896/895A/1010) use a 40 Mhz base &n; *  clock and provide a clock quadrupler (160 Mhz).&n; */
multiline_comment|/*&n; *  calculate SCSI clock frequency (in KHz)&n; */
DECL|function|getfreq
r_static
r_int
id|getfreq
(paren
id|hcb_p
id|np
comma
r_int
id|gen
)paren
(brace
r_int
r_int
id|ms
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|f
suffix:semicolon
multiline_comment|/*&n;&t; * Measure GEN timer delay in order &n;&t; * to calculate SCSI clock frequency&n;&t; *&n;&t; * This code will never execute too&n;&t; * many loop iterations (if DELAY is &n;&t; * reasonably correct). It could get&n;&t; * too low a delay (too high a freq.)&n;&t; * if the CPU is slow executing the &n;&t; * loop for some reason (an NMI, for&n;&t; * example). For this reason we will&n;&t; * if multiple measurements are to be &n;&t; * performed trust the higher delay &n;&t; * (lower frequency returned).&n;&t; */
id|OUTW
(paren
id|nc_sien
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* mask all scsi interrupts */
(paren
r_void
)paren
id|INW
(paren
id|nc_sist
)paren
suffix:semicolon
multiline_comment|/* clear pending scsi interrupt */
id|OUTB
(paren
id|nc_dien
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* mask all dma interrupts */
(paren
r_void
)paren
id|INW
(paren
id|nc_sist
)paren
suffix:semicolon
multiline_comment|/* another one, just to be sure :) */
multiline_comment|/*&n;&t; * The C1010-33 core does not report GEN in SIST,&n;&t; * if this interrupt is masked in SIEN.&n;&t; * I don&squot;t know yet if the C1010-66 behaves the same way.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_C10
)paren
(brace
id|OUTW
(paren
id|nc_sien
comma
id|GEN
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_istat1
comma
id|SIRQD
)paren
suffix:semicolon
)brace
id|OUTB
(paren
id|nc_scntl3
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* set pre-scaler to divide by 3 */
id|OUTB
(paren
id|nc_stime1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* disable general purpose timer */
id|OUTB
(paren
id|nc_stime1
comma
id|gen
)paren
suffix:semicolon
multiline_comment|/* set to nominal delay of 1&lt;&lt;gen * 125us */
r_while
c_loop
(paren
op_logical_neg
(paren
id|INW
c_func
(paren
id|nc_sist
)paren
op_amp
id|GEN
)paren
op_logical_and
id|ms
op_increment
OL
l_int|100000
)paren
id|UDELAY
(paren
l_int|1000
op_div
l_int|4
)paren
suffix:semicolon
multiline_comment|/* count in 1/4 of ms */
id|OUTB
(paren
id|nc_stime1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* disable general purpose timer */
multiline_comment|/*&n;&t; * Undo C1010-33 specific settings.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_C10
)paren
(brace
id|OUTW
(paren
id|nc_sien
comma
l_int|0
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_istat1
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; &t; * set prescaler to divide by whatever 0 means&n; &t; * 0 ought to choose divide by 2, but appears&n; &t; * to set divide by 3.5 mode in my 53c810 ...&n; &t; */
id|OUTB
(paren
id|nc_scntl3
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n; &t; * adjust for prescaler, and convert into KHz &n;  &t; */
id|f
op_assign
id|ms
ques
c_cond
(paren
(paren
l_int|1
op_lshift
id|gen
)paren
op_star
(paren
l_int|4340
op_star
l_int|4
)paren
)paren
op_div
id|ms
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * The C1010-33 result is biased by a factor &n;&t; * of 2/3 compared to earlier chips.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_C10
)paren
id|f
op_assign
(paren
id|f
op_star
l_int|2
)paren
op_div
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|sym_verbose
op_ge
l_int|2
)paren
id|printf
(paren
l_string|&quot;%s: Delay (GEN=%d): %u msec, %u KHz&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
comma
id|gen
comma
id|ms
op_div
l_int|4
comma
id|f
)paren
suffix:semicolon
r_return
id|f
suffix:semicolon
)brace
DECL|function|sym_getfreq
r_static
r_int
id|sym_getfreq
(paren
id|hcb_p
id|np
)paren
(brace
id|u_int
id|f1
comma
id|f2
suffix:semicolon
r_int
id|gen
op_assign
l_int|8
suffix:semicolon
(paren
r_void
)paren
id|getfreq
(paren
id|np
comma
id|gen
)paren
suffix:semicolon
multiline_comment|/* throw away first result */
id|f1
op_assign
id|getfreq
(paren
id|np
comma
id|gen
)paren
suffix:semicolon
id|f2
op_assign
id|getfreq
(paren
id|np
comma
id|gen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f1
OG
id|f2
)paren
id|f1
op_assign
id|f2
suffix:semicolon
multiline_comment|/* trust lower result&t;*/
r_return
id|f1
suffix:semicolon
)brace
multiline_comment|/*&n; *  Get/probe chip SCSI clock frequency&n; */
DECL|function|sym_getclock
r_static
r_void
id|sym_getclock
(paren
id|hcb_p
id|np
comma
r_int
id|mult
)paren
(brace
r_int
r_char
id|scntl3
op_assign
id|np-&gt;sv_scntl3
suffix:semicolon
r_int
r_char
id|stest1
op_assign
id|np-&gt;sv_stest1
suffix:semicolon
r_int
id|f1
suffix:semicolon
id|np-&gt;multiplier
op_assign
l_int|1
suffix:semicolon
id|f1
op_assign
l_int|40000
suffix:semicolon
multiline_comment|/*&n;&t; *  True with 875/895/896/895A with clock multiplier selected&n;&t; */
r_if
c_cond
(paren
id|mult
OG
l_int|1
op_logical_and
(paren
id|stest1
op_amp
(paren
id|DBLEN
op_plus
id|DBLSEL
)paren
)paren
op_eq
id|DBLEN
op_plus
id|DBLSEL
)paren
(brace
r_if
c_cond
(paren
id|sym_verbose
op_ge
l_int|2
)paren
id|printf
(paren
l_string|&quot;%s: clock multiplier found&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|np-&gt;multiplier
op_assign
id|mult
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  If multiplier not found or scntl3 not 7,5,3,&n;&t; *  reset chip and get frequency from general purpose timer.&n;&t; *  Otherwise trust scntl3 BIOS setting.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;multiplier
op_ne
id|mult
op_logical_or
(paren
id|scntl3
op_amp
l_int|7
)paren
OL
l_int|3
op_logical_or
op_logical_neg
(paren
id|scntl3
op_amp
l_int|1
)paren
)paren
(brace
id|OUTB
(paren
id|nc_stest1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* make sure doubler is OFF */
id|f1
op_assign
id|sym_getfreq
(paren
id|np
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sym_verbose
)paren
id|printf
(paren
l_string|&quot;%s: chip clock is %uKHz&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
comma
id|f1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f1
OL
l_int|45000
)paren
id|f1
op_assign
l_int|40000
suffix:semicolon
r_else
r_if
c_cond
(paren
id|f1
OL
l_int|55000
)paren
id|f1
op_assign
l_int|50000
suffix:semicolon
r_else
id|f1
op_assign
l_int|80000
suffix:semicolon
r_if
c_cond
(paren
id|f1
template_param
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|sym_verbose
op_ge
l_int|2
)paren
id|printf
(paren
l_string|&quot;%s: clock multiplier assumed&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|np-&gt;multiplier
op_assign
id|mult
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|scntl3
op_amp
l_int|7
)paren
op_eq
l_int|3
)paren
id|f1
op_assign
l_int|40000
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|scntl3
op_amp
l_int|7
)paren
op_eq
l_int|5
)paren
id|f1
op_assign
l_int|80000
suffix:semicolon
r_else
id|f1
op_assign
l_int|160000
suffix:semicolon
id|f1
op_div_assign
id|np-&gt;multiplier
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Compute controller synchronous parameters.&n;&t; */
id|f1
op_mul_assign
id|np-&gt;multiplier
suffix:semicolon
id|np-&gt;clock_khz
op_assign
id|f1
suffix:semicolon
)brace
multiline_comment|/*&n; *  Get/probe PCI clock frequency&n; */
DECL|function|sym_getpciclock
r_static
r_int
id|sym_getpciclock
(paren
id|hcb_p
id|np
)paren
(brace
r_int
id|f
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *  For now, we only need to know about the actual &n;&t; *  PCI BUS clock frequency for C1010-66 chips.&n;&t; */
macro_line|#if 1
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_66MHZ
)paren
(brace
macro_line|#else
r_if
c_cond
(paren
l_int|1
)paren
(brace
macro_line|#endif
id|OUTB
(paren
id|nc_stest1
comma
id|SCLK
)paren
suffix:semicolon
multiline_comment|/* Use the PCI clock as SCSI clock */
id|f
op_assign
(paren
r_int
)paren
id|sym_getfreq
(paren
id|np
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_stest1
comma
l_int|0
)paren
suffix:semicolon
)brace
id|np-&gt;pciclk_khz
op_assign
id|f
suffix:semicolon
r_return
id|f
suffix:semicolon
)brace
multiline_comment|/*&n; *  SYMBIOS chip clock divisor table.&n; *&n; *  Divisors are multiplied by 10,000,000 in order to make &n; *  calculations more simple.&n; */
DECL|macro|_5M
mdefine_line|#define _5M 5000000
DECL|variable|div_10M
r_static
id|u32
id|div_10M
(braket
)braket
op_assign
(brace
l_int|2
op_star
id|_5M
comma
l_int|3
op_star
id|_5M
comma
l_int|4
op_star
id|_5M
comma
l_int|6
op_star
id|_5M
comma
l_int|8
op_star
id|_5M
comma
l_int|12
op_star
id|_5M
comma
l_int|16
op_star
id|_5M
)brace
suffix:semicolon
multiline_comment|/*&n; *  Get clock factor and sync divisor for a given &n; *  synchronous factor period.&n; */
r_static
r_int
DECL|function|sym_getsync
id|sym_getsync
c_func
(paren
id|hcb_p
id|np
comma
id|u_char
id|dt
comma
id|u_char
id|sfac
comma
id|u_char
op_star
id|divp
comma
id|u_char
op_star
id|fakp
)paren
(brace
id|u32
id|clk
op_assign
id|np-&gt;clock_khz
suffix:semicolon
multiline_comment|/* SCSI clock frequency in kHz&t;*/
r_int
id|div
op_assign
id|np-&gt;clock_divn
suffix:semicolon
multiline_comment|/* Number of divisors supported&t;*/
id|u32
id|fak
suffix:semicolon
multiline_comment|/* Sync factor in sxfer&t;&t;*/
id|u32
id|per
suffix:semicolon
multiline_comment|/* Period in tenths of ns&t;*/
id|u32
id|kpc
suffix:semicolon
multiline_comment|/* (per * clk)&t;&t;&t;*/
r_int
id|ret
suffix:semicolon
multiline_comment|/*&n;&t; *  Compute the synchronous period in tenths of nano-seconds&n;&t; */
r_if
c_cond
(paren
id|dt
op_logical_and
id|sfac
op_le
l_int|9
)paren
id|per
op_assign
l_int|125
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sfac
op_le
l_int|10
)paren
id|per
op_assign
l_int|250
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sfac
op_eq
l_int|11
)paren
id|per
op_assign
l_int|303
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sfac
op_eq
l_int|12
)paren
id|per
op_assign
l_int|500
suffix:semicolon
r_else
id|per
op_assign
l_int|40
op_star
id|sfac
suffix:semicolon
id|ret
op_assign
id|per
suffix:semicolon
id|kpc
op_assign
id|per
op_star
id|clk
suffix:semicolon
r_if
c_cond
(paren
id|dt
)paren
id|kpc
op_lshift_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; *  For earliest C10 revision 0, we cannot use extra &n;&t; *  clocks for the setting of the SCSI clocking.&n;&t; *  Note that this limits the lowest sync data transfer &n;&t; *  to 5 Mega-transfers per second and may result in&n;&t; *  using higher clock divisors.&n;&t; */
macro_line|#if 1
r_if
c_cond
(paren
(paren
id|np-&gt;features
op_amp
(paren
id|FE_C10
op_or
id|FE_U3EN
)paren
)paren
op_eq
id|FE_C10
)paren
(brace
multiline_comment|/*&n;&t;&t; *  Look for the lowest clock divisor that allows an &n;&t;&t; *  output speed not faster than the period.&n;&t;&t; */
r_while
c_loop
(paren
id|div
OG
l_int|0
)paren
(brace
op_decrement
id|div
suffix:semicolon
r_if
c_cond
(paren
id|kpc
OG
(paren
id|div_10M
(braket
id|div
)braket
op_lshift
l_int|2
)paren
)paren
(brace
op_increment
id|div
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|fak
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* No extra clocks */
r_if
c_cond
(paren
id|div
op_eq
id|np-&gt;clock_divn
)paren
(brace
multiline_comment|/* Are we too fast ? */
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
op_star
id|divp
op_assign
id|div
suffix:semicolon
op_star
id|fakp
op_assign
id|fak
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; *  Look for the greatest clock divisor that allows an &n;&t; *  input speed faster than the period.&n;&t; */
r_while
c_loop
(paren
id|div
op_decrement
OG
l_int|0
)paren
r_if
c_cond
(paren
id|kpc
op_ge
(paren
id|div_10M
(braket
id|div
)braket
op_lshift
l_int|2
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t; *  Calculate the lowest clock factor that allows an output &n;&t; *  speed not faster than the period, and the max output speed.&n;&t; *  If fak &gt;= 1 we will set both XCLKH_ST and XCLKH_DT.&n;&t; *  If fak &gt;= 2 we will also set XCLKS_ST and XCLKS_DT.&n;&t; */
r_if
c_cond
(paren
id|dt
)paren
(brace
id|fak
op_assign
(paren
id|kpc
op_minus
l_int|1
)paren
op_div
(paren
id|div_10M
(braket
id|div
)braket
op_lshift
l_int|1
)paren
op_plus
l_int|1
op_minus
l_int|2
suffix:semicolon
multiline_comment|/* ret = ((2+fak)*div_10M[div])/np-&gt;clock_khz; */
)brace
r_else
(brace
id|fak
op_assign
(paren
id|kpc
op_minus
l_int|1
)paren
op_div
id|div_10M
(braket
id|div
)braket
op_plus
l_int|1
op_minus
l_int|4
suffix:semicolon
multiline_comment|/* ret = ((4+fak)*div_10M[div])/np-&gt;clock_khz; */
)brace
multiline_comment|/*&n;&t; *  Check against our hardware limits, or bugs :).&n;&t; */
r_if
c_cond
(paren
id|fak
OG
l_int|2
)paren
(brace
id|fak
op_assign
l_int|2
suffix:semicolon
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Compute and return sync parameters.&n;&t; */
op_star
id|divp
op_assign
id|div
suffix:semicolon
op_star
id|fakp
op_assign
id|fak
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; *  SYMBIOS chips allow burst lengths of 2, 4, 8, 16, 32, 64,&n; *  128 transfers. All chips support at least 16 transfers &n; *  bursts. The 825A, 875 and 895 chips support bursts of up &n; *  to 128 transfers and the 895A and 896 support bursts of up&n; *  to 64 transfers. All other chips support up to 16 &n; *  transfers bursts.&n; *&n; *  For PCI 32 bit data transfers each transfer is a DWORD.&n; *  It is a QUADWORD (8 bytes) for PCI 64 bit data transfers.&n; *&n; *  We use log base 2 (burst length) as internal code, with &n; *  value 0 meaning &quot;burst disabled&quot;.&n; */
multiline_comment|/*&n; *  Burst length from burst code.&n; */
DECL|macro|burst_length
mdefine_line|#define burst_length(bc) (!(bc))? 0 : 1 &lt;&lt; (bc)
multiline_comment|/*&n; *  Burst code from io register bits.&n; */
DECL|macro|burst_code
mdefine_line|#define burst_code(dmode, ctest4, ctest5) &bslash;&n;&t;(ctest4) &amp; 0x80? 0 : (((dmode) &amp; 0xc0) &gt;&gt; 6) + ((ctest5) &amp; 0x04) + 1
multiline_comment|/*&n; *  Set initial io register bits from burst code.&n; */
DECL|function|sym_init_burst
r_static
id|__inline
r_void
id|sym_init_burst
c_func
(paren
id|hcb_p
id|np
comma
id|u_char
id|bc
)paren
(brace
id|np-&gt;rv_ctest4
op_and_assign
op_complement
l_int|0x80
suffix:semicolon
id|np-&gt;rv_dmode
op_and_assign
op_complement
(paren
l_int|0x3
op_lshift
l_int|6
)paren
suffix:semicolon
id|np-&gt;rv_ctest5
op_and_assign
op_complement
l_int|0x4
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bc
)paren
(brace
id|np-&gt;rv_ctest4
op_or_assign
l_int|0x80
suffix:semicolon
)brace
r_else
(brace
op_decrement
id|bc
suffix:semicolon
id|np-&gt;rv_dmode
op_or_assign
(paren
(paren
id|bc
op_amp
l_int|0x3
)paren
op_lshift
l_int|6
)paren
suffix:semicolon
id|np-&gt;rv_ctest5
op_or_assign
(paren
id|bc
op_amp
l_int|0x4
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Print out the list of targets that have some flag disabled by user.&n; */
DECL|function|sym_print_targets_flag
r_static
r_void
id|sym_print_targets_flag
c_func
(paren
id|hcb_p
id|np
comma
r_int
id|mask
comma
r_char
op_star
id|msg
)paren
(brace
r_int
id|cnt
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SYM_CONF_MAX_TARGET
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|np-&gt;myaddr
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;target
(braket
id|i
)braket
dot
id|usrflags
op_amp
id|mask
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cnt
op_increment
)paren
id|printf
c_func
(paren
l_string|&quot;%s: %s disabled for targets&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
comma
id|msg
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot; %d&quot;
comma
id|i
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cnt
)paren
id|printf
c_func
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Save initial settings of some IO registers.&n; *  Assumed to have been set by BIOS.&n; *  We cannot reset the chip prior to reading the &n; *  IO registers, since informations will be lost.&n; *  Since the SCRIPTS processor may be running, this &n; *  is not safe on paper, but it seems to work quite &n; *  well. :)&n; */
DECL|function|sym_save_initial_setting
r_static
r_void
id|sym_save_initial_setting
(paren
id|hcb_p
id|np
)paren
(brace
id|np-&gt;sv_scntl0
op_assign
id|INB
c_func
(paren
id|nc_scntl0
)paren
op_amp
l_int|0x0a
suffix:semicolon
id|np-&gt;sv_scntl3
op_assign
id|INB
c_func
(paren
id|nc_scntl3
)paren
op_amp
l_int|0x07
suffix:semicolon
id|np-&gt;sv_dmode
op_assign
id|INB
c_func
(paren
id|nc_dmode
)paren
op_amp
l_int|0xce
suffix:semicolon
id|np-&gt;sv_dcntl
op_assign
id|INB
c_func
(paren
id|nc_dcntl
)paren
op_amp
l_int|0xa8
suffix:semicolon
id|np-&gt;sv_ctest3
op_assign
id|INB
c_func
(paren
id|nc_ctest3
)paren
op_amp
l_int|0x01
suffix:semicolon
id|np-&gt;sv_ctest4
op_assign
id|INB
c_func
(paren
id|nc_ctest4
)paren
op_amp
l_int|0x80
suffix:semicolon
id|np-&gt;sv_gpcntl
op_assign
id|INB
c_func
(paren
id|nc_gpcntl
)paren
suffix:semicolon
id|np-&gt;sv_stest1
op_assign
id|INB
c_func
(paren
id|nc_stest1
)paren
suffix:semicolon
id|np-&gt;sv_stest2
op_assign
id|INB
c_func
(paren
id|nc_stest2
)paren
op_amp
l_int|0x20
suffix:semicolon
id|np-&gt;sv_stest4
op_assign
id|INB
c_func
(paren
id|nc_stest4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_C10
)paren
(brace
multiline_comment|/* Always large DMA fifo + ultra3 */
id|np-&gt;sv_scntl4
op_assign
id|INB
c_func
(paren
id|nc_scntl4
)paren
suffix:semicolon
id|np-&gt;sv_ctest5
op_assign
id|INB
c_func
(paren
id|nc_ctest5
)paren
op_amp
l_int|0x04
suffix:semicolon
)brace
r_else
id|np-&gt;sv_ctest5
op_assign
id|INB
c_func
(paren
id|nc_ctest5
)paren
op_amp
l_int|0x24
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PARISC
DECL|function|parisc_setup_hcb
r_static
id|u32
id|parisc_setup_hcb
c_func
(paren
id|hcb_p
id|np
comma
id|u32
id|period
)paren
(brace
r_int
r_int
id|pdc_period
suffix:semicolon
r_char
id|scsi_mode
suffix:semicolon
r_struct
id|hardware_path
id|hwpath
suffix:semicolon
multiline_comment|/* Host firmware (PDC) keeps a table for crippling SCSI capabilities.&n;&t; * Many newer machines export one channel of 53c896 chip&n;&t; * as SE, 50-pin HD.  Also used for Multi-initiator SCSI clusters&n;&t; * to set the SCSI Initiator ID.&n;&t; */
id|get_pci_node_path
c_func
(paren
id|np-&gt;s.device
comma
op_amp
id|hwpath
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pdc_get_initiator
c_func
(paren
op_amp
id|hwpath
comma
op_amp
id|np-&gt;myaddr
comma
op_amp
id|pdc_period
comma
op_amp
id|np-&gt;maxwide
comma
op_amp
id|scsi_mode
)paren
)paren
r_return
id|period
suffix:semicolon
r_if
c_cond
(paren
id|scsi_mode
op_ge
l_int|0
)paren
(brace
multiline_comment|/* C3000 PDC reports period/mode */
id|SYM_SETUP_SCSI_DIFF
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|scsi_mode
)paren
(brace
r_case
l_int|0
suffix:colon
id|np-&gt;scsi_mode
op_assign
id|SMODE_SE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|np-&gt;scsi_mode
op_assign
id|SMODE_HVD
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|np-&gt;scsi_mode
op_assign
id|SMODE_LVD
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
r_return
(paren
id|u32
)paren
id|pdc_period
suffix:semicolon
)brace
macro_line|#else
DECL|function|parisc_setup_hcb
r_static
r_inline
r_int
id|parisc_setup_hcb
c_func
(paren
id|hcb_p
id|np
comma
id|u32
id|period
)paren
(brace
r_return
id|period
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; *  Prepare io register values used by sym_start_up() &n; *  according to selected and supported features.&n; */
DECL|function|sym_prepare_setting
r_static
r_int
id|sym_prepare_setting
c_func
(paren
id|hcb_p
id|np
comma
r_struct
id|sym_nvram
op_star
id|nvram
)paren
(brace
id|u_char
id|burst_max
suffix:semicolon
id|u32
id|period
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; *  Wide ?&n;&t; */
id|np-&gt;maxwide
op_assign
(paren
id|np-&gt;features
op_amp
id|FE_WIDE
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *  Guess the frequency of the chip&squot;s clock.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
(paren
id|FE_ULTRA3
op_or
id|FE_ULTRA2
)paren
)paren
id|np-&gt;clock_khz
op_assign
l_int|160000
suffix:semicolon
r_else
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_ULTRA
)paren
id|np-&gt;clock_khz
op_assign
l_int|80000
suffix:semicolon
r_else
id|np-&gt;clock_khz
op_assign
l_int|40000
suffix:semicolon
multiline_comment|/*&n;&t; *  Get the clock multiplier factor.&n; &t; */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_QUAD
)paren
id|np-&gt;multiplier
op_assign
l_int|4
suffix:semicolon
r_else
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_DBLR
)paren
id|np-&gt;multiplier
op_assign
l_int|2
suffix:semicolon
r_else
id|np-&gt;multiplier
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; *  Measure SCSI clock frequency for chips &n;&t; *  it may vary from assumed one.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_VARCLK
)paren
id|sym_getclock
c_func
(paren
id|np
comma
id|np-&gt;multiplier
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Divisor to be used for async (timer pre-scaler).&n;&t; */
id|i
op_assign
id|np-&gt;clock_divn
op_minus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|i
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
l_int|10ul
op_star
id|SYM_CONF_MIN_ASYNC
op_star
id|np-&gt;clock_khz
OG
id|div_10M
(braket
id|i
)braket
)paren
(brace
op_increment
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|np-&gt;rv_scntl3
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * The C1010 uses hardwired divisors for async.&n;&t; * So, we just throw away, the async. divisor.:-)&n;&t; */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_C10
)paren
id|np-&gt;rv_scntl3
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Minimum synchronous period factor supported by the chip.&n;&t; * Btw, &squot;period&squot; is in tenths of nanoseconds.&n;&t; */
id|period
op_assign
(paren
l_int|4
op_star
id|div_10M
(braket
l_int|0
)braket
op_plus
id|np-&gt;clock_khz
op_minus
l_int|1
)paren
op_div
id|np-&gt;clock_khz
suffix:semicolon
id|period
op_assign
id|parisc_setup_hcb
c_func
(paren
id|np
comma
id|period
)paren
suffix:semicolon
r_if
c_cond
(paren
id|period
op_le
l_int|250
)paren
id|np-&gt;minsync
op_assign
l_int|10
suffix:semicolon
r_else
r_if
c_cond
(paren
id|period
op_le
l_int|303
)paren
id|np-&gt;minsync
op_assign
l_int|11
suffix:semicolon
r_else
r_if
c_cond
(paren
id|period
op_le
l_int|500
)paren
id|np-&gt;minsync
op_assign
l_int|12
suffix:semicolon
r_else
id|np-&gt;minsync
op_assign
(paren
id|period
op_plus
l_int|40
op_minus
l_int|1
)paren
op_div
l_int|40
suffix:semicolon
multiline_comment|/*&n;&t; * Check against chip SCSI standard support (SCSI-2,ULTRA,ULTRA2).&n;&t; */
r_if
c_cond
(paren
id|np-&gt;minsync
OL
l_int|25
op_logical_and
op_logical_neg
(paren
id|np-&gt;features
op_amp
(paren
id|FE_ULTRA
op_or
id|FE_ULTRA2
op_or
id|FE_ULTRA3
)paren
)paren
)paren
id|np-&gt;minsync
op_assign
l_int|25
suffix:semicolon
r_else
r_if
c_cond
(paren
id|np-&gt;minsync
OL
l_int|12
op_logical_and
op_logical_neg
(paren
id|np-&gt;features
op_amp
(paren
id|FE_ULTRA2
op_or
id|FE_ULTRA3
)paren
)paren
)paren
id|np-&gt;minsync
op_assign
l_int|12
suffix:semicolon
multiline_comment|/*&n;&t; * Maximum synchronous period factor supported by the chip.&n;&t; */
id|period
op_assign
(paren
l_int|11
op_star
id|div_10M
(braket
id|np-&gt;clock_divn
op_minus
l_int|1
)braket
)paren
op_div
(paren
l_int|4
op_star
id|np-&gt;clock_khz
)paren
suffix:semicolon
id|np-&gt;maxsync
op_assign
id|period
OG
l_int|2540
ques
c_cond
l_int|254
suffix:colon
id|period
op_div
l_int|10
suffix:semicolon
multiline_comment|/*&n;&t; * If chip is a C1010, guess the sync limits in DT mode.&n;&t; */
r_if
c_cond
(paren
(paren
id|np-&gt;features
op_amp
(paren
id|FE_C10
op_or
id|FE_ULTRA3
)paren
)paren
op_eq
(paren
id|FE_C10
op_or
id|FE_ULTRA3
)paren
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;clock_khz
op_eq
l_int|160000
)paren
(brace
id|np-&gt;minsync_dt
op_assign
l_int|9
suffix:semicolon
id|np-&gt;maxsync_dt
op_assign
l_int|50
suffix:semicolon
id|np-&gt;maxoffs_dt
op_assign
id|nvram-&gt;type
ques
c_cond
l_int|62
suffix:colon
l_int|31
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *  64 bit addressing  (895A/896/1010) ?&n;&t; */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_DAC
)paren
(brace
macro_line|#if   SYM_CONF_DMA_ADDRESSING_MODE == 0
id|np-&gt;rv_ccntl1
op_or_assign
(paren
id|DDAC
)paren
suffix:semicolon
macro_line|#elif SYM_CONF_DMA_ADDRESSING_MODE == 1
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;use_dac
)paren
id|np-&gt;rv_ccntl1
op_or_assign
(paren
id|DDAC
)paren
suffix:semicolon
r_else
id|np-&gt;rv_ccntl1
op_or_assign
(paren
id|XTIMOD
op_or
id|EXTIBMV
)paren
suffix:semicolon
macro_line|#elif SYM_CONF_DMA_ADDRESSING_MODE == 2
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;use_dac
)paren
id|np-&gt;rv_ccntl1
op_or_assign
(paren
id|DDAC
)paren
suffix:semicolon
r_else
id|np-&gt;rv_ccntl1
op_or_assign
(paren
l_int|0
op_or
id|EXTIBMV
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n;&t; *  Phase mismatch handled by SCRIPTS (895A/896/1010) ?&n;  &t; */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_NOPM
)paren
id|np-&gt;rv_ccntl0
op_or_assign
(paren
id|ENPMJ
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  C1010-33 Errata: Part Number:609-039638 (rev. 1) is fixed.&n;&t; *  In dual channel mode, contention occurs if internal cycles&n;&t; *  are used. Disable internal cycles.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;device_id
op_eq
id|PCI_ID_LSI53C1010_33
op_logical_and
id|np-&gt;revision_id
OL
l_int|0x1
)paren
id|np-&gt;rv_ccntl0
op_or_assign
id|DILS
suffix:semicolon
multiline_comment|/*&n;&t; *  Select burst length (dwords)&n;&t; */
id|burst_max
op_assign
id|SYM_SETUP_BURST_ORDER
suffix:semicolon
r_if
c_cond
(paren
id|burst_max
op_eq
l_int|255
)paren
id|burst_max
op_assign
id|burst_code
c_func
(paren
id|np-&gt;sv_dmode
comma
id|np-&gt;sv_ctest4
comma
id|np-&gt;sv_ctest5
)paren
suffix:semicolon
r_if
c_cond
(paren
id|burst_max
OG
l_int|7
)paren
id|burst_max
op_assign
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|burst_max
OG
id|np-&gt;maxburst
)paren
id|burst_max
op_assign
id|np-&gt;maxburst
suffix:semicolon
multiline_comment|/*&n;&t; *  DEL 352 - 53C810 Rev x11 - Part Number 609-0392140 - ITEM 2.&n;&t; *  This chip and the 860 Rev 1 may wrongly use PCI cache line &n;&t; *  based transactions on LOAD/STORE instructions. So we have &n;&t; *  to prevent these chips from using such PCI transactions in &n;&t; *  this driver. The generic ncr driver that does not use &n;&t; *  LOAD/STORE instructions does not need this work-around.&n;&t; */
r_if
c_cond
(paren
(paren
id|np-&gt;device_id
op_eq
id|PCI_ID_SYM53C810
op_logical_and
id|np-&gt;revision_id
op_ge
l_int|0x10
op_logical_and
id|np-&gt;revision_id
op_le
l_int|0x11
)paren
op_logical_or
(paren
id|np-&gt;device_id
op_eq
id|PCI_ID_SYM53C860
op_logical_and
id|np-&gt;revision_id
op_le
l_int|0x1
)paren
)paren
id|np-&gt;features
op_and_assign
op_complement
(paren
id|FE_WRIE
op_or
id|FE_ERL
op_or
id|FE_ERMP
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Select all supported special features.&n;&t; *  If we are using on-board RAM for scripts, prefetch (PFEN) &n;&t; *  does not help, but burst op fetch (BOF) does.&n;&t; *  Disabling PFEN makes sure BOF will be used.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_ERL
)paren
id|np-&gt;rv_dmode
op_or_assign
id|ERL
suffix:semicolon
multiline_comment|/* Enable Read Line */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_BOF
)paren
id|np-&gt;rv_dmode
op_or_assign
id|BOF
suffix:semicolon
multiline_comment|/* Burst Opcode Fetch */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_ERMP
)paren
id|np-&gt;rv_dmode
op_or_assign
id|ERMP
suffix:semicolon
multiline_comment|/* Enable Read Multiple */
macro_line|#if 1
r_if
c_cond
(paren
(paren
id|np-&gt;features
op_amp
id|FE_PFEN
)paren
op_logical_and
op_logical_neg
id|np-&gt;ram_ba
)paren
macro_line|#else
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_PFEN
)paren
macro_line|#endif
id|np-&gt;rv_dcntl
op_or_assign
id|PFEN
suffix:semicolon
multiline_comment|/* Prefetch Enable */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_CLSE
)paren
id|np-&gt;rv_dcntl
op_or_assign
id|CLSE
suffix:semicolon
multiline_comment|/* Cache Line Size Enable */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_WRIE
)paren
id|np-&gt;rv_ctest3
op_or_assign
id|WRIE
suffix:semicolon
multiline_comment|/* Write and Invalidate */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_DFS
)paren
id|np-&gt;rv_ctest5
op_or_assign
id|DFS
suffix:semicolon
multiline_comment|/* Dma Fifo Size */
multiline_comment|/*&n;&t; *  Select some other&n;&t; */
r_if
c_cond
(paren
id|SYM_SETUP_PCI_PARITY
)paren
id|np-&gt;rv_ctest4
op_or_assign
id|MPEE
suffix:semicolon
multiline_comment|/* Master parity checking */
r_if
c_cond
(paren
id|SYM_SETUP_SCSI_PARITY
)paren
id|np-&gt;rv_scntl0
op_or_assign
l_int|0x0a
suffix:semicolon
multiline_comment|/*  full arb., ena parity, par-&gt;ATN  */
multiline_comment|/*&n;&t; *  Get parity checking, host ID and verbose mode from NVRAM&n;&t; */
id|np-&gt;myaddr
op_assign
l_int|255
suffix:semicolon
id|sym_nvram_setup_host
(paren
id|np
comma
id|nvram
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Get SCSI addr of host adapter (set by bios?).&n;&t; */
r_if
c_cond
(paren
id|np-&gt;myaddr
op_eq
l_int|255
)paren
(brace
id|np-&gt;myaddr
op_assign
id|INB
c_func
(paren
id|nc_scid
)paren
op_amp
l_int|0x07
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;myaddr
)paren
id|np-&gt;myaddr
op_assign
id|SYM_SETUP_HOST_ID
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Prepare initial io register bits for burst length&n;&t; */
id|sym_init_burst
c_func
(paren
id|np
comma
id|burst_max
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Set SCSI BUS mode.&n;&t; *  - LVD capable chips (895/895A/896/1010) report the &n;&t; *    current BUS mode through the STEST4 IO register.&n;&t; *  - For previous generation chips (825/825A/875), &n;&t; *    user has to tell us how to check against HVD, &n;&t; *    since a 100% safe algorithm is not possible.&n;&t; */
id|np-&gt;scsi_mode
op_assign
id|SMODE_SE
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;features
op_amp
(paren
id|FE_ULTRA2
op_or
id|FE_ULTRA3
)paren
)paren
id|np-&gt;scsi_mode
op_assign
(paren
id|np-&gt;sv_stest4
op_amp
id|SMODE
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_DIFF
)paren
(brace
r_if
c_cond
(paren
id|SYM_SETUP_SCSI_DIFF
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;sv_scntl3
)paren
(brace
r_if
c_cond
(paren
id|np-&gt;sv_stest2
op_amp
l_int|0x20
)paren
id|np-&gt;scsi_mode
op_assign
id|SMODE_HVD
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|nvram-&gt;type
op_eq
id|SYM_SYMBIOS_NVRAM
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|INB
c_func
(paren
id|nc_gpreg
)paren
op_amp
l_int|0x08
)paren
)paren
id|np-&gt;scsi_mode
op_assign
id|SMODE_HVD
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|SYM_SETUP_SCSI_DIFF
op_eq
l_int|2
)paren
id|np-&gt;scsi_mode
op_assign
id|SMODE_HVD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|np-&gt;scsi_mode
op_eq
id|SMODE_HVD
)paren
id|np-&gt;rv_stest2
op_or_assign
l_int|0x20
suffix:semicolon
multiline_comment|/*&n;&t; *  Set LED support from SCRIPTS.&n;&t; *  Ignore this feature for boards known to use a &n;&t; *  specific GPIO wiring and for the 895A, 896 &n;&t; *  and 1010 that drive the LED directly.&n;&t; */
r_if
c_cond
(paren
(paren
id|SYM_SETUP_SCSI_LED
op_logical_or
(paren
id|nvram-&gt;type
op_eq
id|SYM_SYMBIOS_NVRAM
op_logical_or
(paren
id|nvram-&gt;type
op_eq
id|SYM_TEKRAM_NVRAM
op_logical_and
id|np-&gt;device_id
op_eq
id|PCI_ID_SYM53C895
)paren
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|np-&gt;features
op_amp
id|FE_LEDC
)paren
op_logical_and
op_logical_neg
(paren
id|np-&gt;sv_gpcntl
op_amp
l_int|0x01
)paren
)paren
id|np-&gt;features
op_or_assign
id|FE_LED0
suffix:semicolon
multiline_comment|/*&n;&t; *  Set irq mode.&n;&t; */
r_switch
c_cond
(paren
id|SYM_SETUP_IRQ_MODE
op_amp
l_int|3
)paren
(brace
r_case
l_int|2
suffix:colon
id|np-&gt;rv_dcntl
op_or_assign
id|IRQM
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|np-&gt;rv_dcntl
op_or_assign
(paren
id|np-&gt;sv_dcntl
op_amp
id|IRQM
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Configure targets according to driver setup.&n;&t; *  If NVRAM present get targets setup from NVRAM.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SYM_CONF_MAX_TARGET
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|i
)braket
suffix:semicolon
id|tp-&gt;tinfo.user.scsi_version
op_assign
id|tp-&gt;tinfo.curr.scsi_version
op_assign
l_int|2
suffix:semicolon
id|tp-&gt;tinfo.user.spi_version
op_assign
id|tp-&gt;tinfo.curr.spi_version
op_assign
l_int|2
suffix:semicolon
id|tp-&gt;tinfo.user.period
op_assign
id|np-&gt;minsync
suffix:semicolon
id|tp-&gt;tinfo.user.offset
op_assign
id|np-&gt;maxoffs
suffix:semicolon
id|tp-&gt;tinfo.user.width
op_assign
id|np-&gt;maxwide
ques
c_cond
id|BUS_16_BIT
suffix:colon
id|BUS_8_BIT
suffix:semicolon
id|tp-&gt;usrflags
op_or_assign
(paren
id|SYM_DISC_ENABLED
op_or
id|SYM_TAGS_ENABLED
)paren
suffix:semicolon
id|tp-&gt;usrtags
op_assign
id|SYM_SETUP_MAX_TAG
suffix:semicolon
id|sym_nvram_setup_target
(paren
id|np
comma
id|i
comma
id|nvram
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Some single-ended devices may crash on receiving a&n;&t;&t; * PPR negotiation attempt.  Only try PPR if we&squot;re in&n;&t;&t; * LVD mode.&n;&t;&t; */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_ULTRA3
)paren
(brace
id|tp-&gt;tinfo.user.options
op_or_assign
id|PPR_OPT_DT
suffix:semicolon
id|tp-&gt;tinfo.user.period
op_assign
id|np-&gt;minsync_dt
suffix:semicolon
id|tp-&gt;tinfo.user.offset
op_assign
id|np-&gt;maxoffs_dt
suffix:semicolon
id|tp-&gt;tinfo.user.spi_version
op_assign
l_int|3
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;usrtags
)paren
id|tp-&gt;usrflags
op_and_assign
op_complement
id|SYM_TAGS_ENABLED
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Let user know about the settings.&n;&t; */
id|i
op_assign
id|nvram-&gt;type
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s: %s NVRAM, ID %d, Fast-%d, %s, %s&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
comma
id|i
op_eq
id|SYM_SYMBIOS_NVRAM
ques
c_cond
l_string|&quot;Symbios&quot;
suffix:colon
(paren
id|i
op_eq
id|SYM_TEKRAM_NVRAM
ques
c_cond
l_string|&quot;Tekram&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
comma
id|np-&gt;myaddr
comma
(paren
id|np-&gt;features
op_amp
id|FE_ULTRA3
)paren
ques
c_cond
l_int|80
suffix:colon
(paren
id|np-&gt;features
op_amp
id|FE_ULTRA2
)paren
ques
c_cond
l_int|40
suffix:colon
(paren
id|np-&gt;features
op_amp
id|FE_ULTRA
)paren
ques
c_cond
l_int|20
suffix:colon
l_int|10
comma
id|sym_scsi_bus_mode
c_func
(paren
id|np-&gt;scsi_mode
)paren
comma
(paren
id|np-&gt;rv_scntl0
op_amp
l_int|0xa
)paren
ques
c_cond
l_string|&quot;parity checking&quot;
suffix:colon
l_string|&quot;NO parity&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Tell him more on demand.&n;&t; */
r_if
c_cond
(paren
id|sym_verbose
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: %s IRQ line driver%s&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
comma
id|np-&gt;rv_dcntl
op_amp
id|IRQM
ques
c_cond
l_string|&quot;totem pole&quot;
suffix:colon
l_string|&quot;open drain&quot;
comma
id|np-&gt;ram_ba
ques
c_cond
l_string|&quot;, using on-chip SRAM&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s: using %s firmware.&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
comma
id|np-&gt;fw_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_NOPM
)paren
id|printf
c_func
(paren
l_string|&quot;%s: handling phase mismatch from SCRIPTS.&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  And still more.&n;&t; */
r_if
c_cond
(paren
id|sym_verbose
op_ge
l_int|2
)paren
(brace
id|printf
(paren
l_string|&quot;%s: initial SCNTL3/DMODE/DCNTL/CTEST3/4/5 = &quot;
l_string|&quot;(hex) %02x/%02x/%02x/%02x/%02x/%02x&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
comma
id|np-&gt;sv_scntl3
comma
id|np-&gt;sv_dmode
comma
id|np-&gt;sv_dcntl
comma
id|np-&gt;sv_ctest3
comma
id|np-&gt;sv_ctest4
comma
id|np-&gt;sv_ctest5
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;%s: final   SCNTL3/DMODE/DCNTL/CTEST3/4/5 = &quot;
l_string|&quot;(hex) %02x/%02x/%02x/%02x/%02x/%02x&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
comma
id|np-&gt;rv_scntl3
comma
id|np-&gt;rv_dmode
comma
id|np-&gt;rv_dcntl
comma
id|np-&gt;rv_ctest3
comma
id|np-&gt;rv_ctest4
comma
id|np-&gt;rv_ctest5
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Let user be aware of targets that have some disable flags set.&n;&t; */
id|sym_print_targets_flag
c_func
(paren
id|np
comma
id|SYM_SCAN_BOOT_DISABLED
comma
l_string|&quot;SCAN AT BOOT&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sym_verbose
)paren
id|sym_print_targets_flag
c_func
(paren
id|np
comma
id|SYM_SCAN_LUNS_DISABLED
comma
l_string|&quot;SCAN FOR LUNS&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Test the pci bus snoop logic :-(&n; *&n; *  Has to be called with interrupts disabled.&n; */
macro_line|#ifndef SYM_CONF_IOMAPPED
DECL|function|sym_regtest
r_static
r_int
id|sym_regtest
(paren
id|hcb_p
id|np
)paren
(brace
r_register
r_volatile
id|u32
id|data
suffix:semicolon
multiline_comment|/*&n;&t; *  chip registers may NOT be cached.&n;&t; *  write 0xffffffff to a read only register area,&n;&t; *  and try to read it back.&n;&t; */
id|data
op_assign
l_int|0xffffffff
suffix:semicolon
id|OUTL_OFF
c_func
(paren
m_offsetof
(paren
r_struct
id|sym_reg
comma
id|nc_dstat
)paren
comma
id|data
)paren
suffix:semicolon
id|data
op_assign
id|INL_OFF
c_func
(paren
m_offsetof
(paren
r_struct
id|sym_reg
comma
id|nc_dstat
)paren
)paren
suffix:semicolon
macro_line|#if 1
r_if
c_cond
(paren
id|data
op_eq
l_int|0xffffffff
)paren
(brace
macro_line|#else
r_if
c_cond
(paren
(paren
id|data
op_amp
l_int|0xe2f0fffd
)paren
op_ne
l_int|0x02000080
)paren
(brace
macro_line|#endif
id|printf
(paren
l_string|&quot;CACHE TEST FAILED: reg dstat-sstat2 readback %x.&bslash;n&quot;
comma
(paren
r_int
)paren
id|data
)paren
suffix:semicolon
r_return
(paren
l_int|0x10
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|sym_snooptest
r_static
r_int
id|sym_snooptest
(paren
id|hcb_p
id|np
)paren
(brace
id|u32
id|sym_rd
comma
id|sym_wr
comma
id|sym_bk
comma
id|host_rd
comma
id|host_wr
comma
id|pc
comma
id|dstat
suffix:semicolon
r_int
id|i
comma
id|err
op_assign
l_int|0
suffix:semicolon
macro_line|#ifndef SYM_CONF_IOMAPPED
id|err
op_or_assign
id|sym_regtest
(paren
id|np
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
(paren
id|err
)paren
suffix:semicolon
macro_line|#endif
id|restart_test
suffix:colon
multiline_comment|/*&n;&t; *  Enable Master Parity Checking as we intend &n;&t; *  to enable it for normal operations.&n;&t; */
id|OUTB
(paren
id|nc_ctest4
comma
(paren
id|np-&gt;rv_ctest4
op_amp
id|MPEE
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  init&n;&t; */
id|pc
op_assign
id|SCRIPTZ_BA
(paren
id|np
comma
id|snooptest
)paren
suffix:semicolon
id|host_wr
op_assign
l_int|1
suffix:semicolon
id|sym_wr
op_assign
l_int|2
suffix:semicolon
multiline_comment|/*&n;&t; *  Set memory and register.&n;&t; */
id|np-&gt;scratch
op_assign
id|cpu_to_scr
c_func
(paren
id|host_wr
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_temp
comma
id|sym_wr
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Start script (exchange values)&n;&t; */
id|OUTL
(paren
id|nc_dsa
comma
id|np-&gt;hcb_ba
)paren
suffix:semicolon
id|OUTL_DSP
(paren
id|pc
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Wait &squot;til done (with timeout)&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SYM_SNOOP_TIMEOUT
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|INB
c_func
(paren
id|nc_istat
)paren
op_amp
(paren
id|INTF
op_or
id|SIP
op_or
id|DIP
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
id|SYM_SNOOP_TIMEOUT
)paren
(brace
id|printf
(paren
l_string|&quot;CACHE TEST FAILED: timeout.&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0x20
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t; *  Check for fatal DMA errors.&n;&t; */
id|dstat
op_assign
id|INB
(paren
id|nc_dstat
)paren
suffix:semicolon
macro_line|#if 1&t;/* Band aiding for broken hardwares that fail PCI parity */
r_if
c_cond
(paren
(paren
id|dstat
op_amp
id|MDPE
)paren
op_logical_and
(paren
id|np-&gt;rv_ctest4
op_amp
id|MPEE
)paren
)paren
(brace
id|printf
(paren
l_string|&quot;%s: PCI DATA PARITY ERROR DETECTED - &quot;
l_string|&quot;DISABLING MASTER DATA PARITY CHECKING.&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|np-&gt;rv_ctest4
op_and_assign
op_complement
id|MPEE
suffix:semicolon
r_goto
id|restart_test
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|dstat
op_amp
(paren
id|MDPE
op_or
id|BF
op_or
id|IID
)paren
)paren
(brace
id|printf
(paren
l_string|&quot;CACHE TEST FAILED: DMA error (dstat=0x%02x).&quot;
comma
id|dstat
)paren
suffix:semicolon
r_return
(paren
l_int|0x80
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Save termination position.&n;&t; */
id|pc
op_assign
id|INL
(paren
id|nc_dsp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Read memory and register.&n;&t; */
id|host_rd
op_assign
id|scr_to_cpu
c_func
(paren
id|np-&gt;scratch
)paren
suffix:semicolon
id|sym_rd
op_assign
id|INL
(paren
id|nc_scratcha
)paren
suffix:semicolon
id|sym_bk
op_assign
id|INL
(paren
id|nc_temp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Check termination position.&n;&t; */
r_if
c_cond
(paren
id|pc
op_ne
id|SCRIPTZ_BA
(paren
id|np
comma
id|snoopend
)paren
op_plus
l_int|8
)paren
(brace
id|printf
(paren
l_string|&quot;CACHE TEST FAILED: script execution failed.&bslash;n&quot;
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;start=%08lx, pc=%08lx, end=%08lx&bslash;n&quot;
comma
(paren
id|u_long
)paren
id|SCRIPTZ_BA
(paren
id|np
comma
id|snooptest
)paren
comma
(paren
id|u_long
)paren
id|pc
comma
(paren
id|u_long
)paren
id|SCRIPTZ_BA
(paren
id|np
comma
id|snoopend
)paren
op_plus
l_int|8
)paren
suffix:semicolon
r_return
(paren
l_int|0x40
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t; *  Show results.&n;&t; */
r_if
c_cond
(paren
id|host_wr
op_ne
id|sym_rd
)paren
(brace
id|printf
(paren
l_string|&quot;CACHE TEST FAILED: host wrote %d, chip read %d.&bslash;n&quot;
comma
(paren
r_int
)paren
id|host_wr
comma
(paren
r_int
)paren
id|sym_rd
)paren
suffix:semicolon
id|err
op_or_assign
l_int|1
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|host_rd
op_ne
id|sym_wr
)paren
(brace
id|printf
(paren
l_string|&quot;CACHE TEST FAILED: chip wrote %d, host read %d.&bslash;n&quot;
comma
(paren
r_int
)paren
id|sym_wr
comma
(paren
r_int
)paren
id|host_rd
)paren
suffix:semicolon
id|err
op_or_assign
l_int|2
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|sym_bk
op_ne
id|sym_wr
)paren
(brace
id|printf
(paren
l_string|&quot;CACHE TEST FAILED: chip wrote %d, read back %d.&bslash;n&quot;
comma
(paren
r_int
)paren
id|sym_wr
comma
(paren
r_int
)paren
id|sym_bk
)paren
suffix:semicolon
id|err
op_or_assign
l_int|4
suffix:semicolon
)brace
suffix:semicolon
r_return
(paren
id|err
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  log message for real hard errors&n; *&n; *  sym0 targ 0?: ERROR (ds:si) (so-si-sd) (sx/s3/s4) @ name (dsp:dbc).&n; *  &t;      reg: r0 r1 r2 r3 r4 r5 r6 ..... rf.&n; *&n; *  exception register:&n; *  &t;ds:&t;dstat&n; *  &t;si:&t;sist&n; *&n; *  SCSI bus lines:&n; *  &t;so:&t;control lines as driven by chip.&n; *  &t;si:&t;control lines as seen by chip.&n; *  &t;sd:&t;scsi data lines as seen by chip.&n; *&n; *  wide/fastmode:&n; *  &t;sx:&t;sxfer  (see the manual)&n; *  &t;s3:&t;scntl3 (see the manual)&n; *  &t;s4:&t;scntl4 (see the manual)&n; *&n; *  current script command:&n; *  &t;dsp:&t;script address (relative to start of script).&n; *  &t;dbc:&t;first word of script command.&n; *&n; *  First 24 register of the chip:&n; *  &t;r0..rf&n; */
DECL|function|sym_log_hard_error
r_static
r_void
id|sym_log_hard_error
c_func
(paren
id|hcb_p
id|np
comma
id|u_short
id|sist
comma
id|u_char
id|dstat
)paren
(brace
id|u32
id|dsp
suffix:semicolon
r_int
id|script_ofs
suffix:semicolon
r_int
id|script_size
suffix:semicolon
r_char
op_star
id|script_name
suffix:semicolon
id|u_char
op_star
id|script_base
suffix:semicolon
r_int
id|i
suffix:semicolon
id|dsp
op_assign
id|INL
(paren
id|nc_dsp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dsp
OG
id|np-&gt;scripta_ba
op_logical_and
id|dsp
op_le
id|np-&gt;scripta_ba
op_plus
id|np-&gt;scripta_sz
)paren
(brace
id|script_ofs
op_assign
id|dsp
op_minus
id|np-&gt;scripta_ba
suffix:semicolon
id|script_size
op_assign
id|np-&gt;scripta_sz
suffix:semicolon
id|script_base
op_assign
(paren
id|u_char
op_star
)paren
id|np-&gt;scripta0
suffix:semicolon
id|script_name
op_assign
l_string|&quot;scripta&quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|np-&gt;scriptb_ba
OL
id|dsp
op_logical_and
id|dsp
op_le
id|np-&gt;scriptb_ba
op_plus
id|np-&gt;scriptb_sz
)paren
(brace
id|script_ofs
op_assign
id|dsp
op_minus
id|np-&gt;scriptb_ba
suffix:semicolon
id|script_size
op_assign
id|np-&gt;scriptb_sz
suffix:semicolon
id|script_base
op_assign
(paren
id|u_char
op_star
)paren
id|np-&gt;scriptb0
suffix:semicolon
id|script_name
op_assign
l_string|&quot;scriptb&quot;
suffix:semicolon
)brace
r_else
(brace
id|script_ofs
op_assign
id|dsp
suffix:semicolon
id|script_size
op_assign
l_int|0
suffix:semicolon
id|script_base
op_assign
l_int|0
suffix:semicolon
id|script_name
op_assign
l_string|&quot;mem&quot;
suffix:semicolon
)brace
id|printf
(paren
l_string|&quot;%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x/%x) @ (%s %x:%08x).&bslash;n&quot;
comma
id|sym_name
(paren
id|np
)paren
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_sdid
)paren
op_amp
l_int|0x0f
comma
id|dstat
comma
id|sist
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_socl
)paren
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_sbcl
)paren
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_sbdl
)paren
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_sxfer
)paren
comma
(paren
r_int
)paren
id|INB
(paren
id|nc_scntl3
)paren
comma
(paren
id|np-&gt;features
op_amp
id|FE_C10
)paren
ques
c_cond
(paren
r_int
)paren
id|INB
(paren
id|nc_scntl4
)paren
suffix:colon
l_int|0
comma
id|script_name
comma
id|script_ofs
comma
(paren
r_int
)paren
id|INL
(paren
id|nc_dbc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|script_ofs
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
r_int
)paren
id|script_ofs
OL
id|script_size
)paren
(brace
id|printf
(paren
l_string|&quot;%s: script cmd = %08x&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
comma
id|scr_to_cpu
c_func
(paren
(paren
r_int
)paren
op_star
(paren
id|u32
op_star
)paren
(paren
id|script_base
op_plus
id|script_ofs
)paren
)paren
)paren
suffix:semicolon
)brace
id|printf
(paren
l_string|&quot;%s: regdump:&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|24
suffix:semicolon
id|i
op_increment
)paren
id|printf
(paren
l_string|&quot; %02x&quot;
comma
(paren
r_int
)paren
id|INB_OFF
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  PCI BUS error.&n;&t; */
r_if
c_cond
(paren
id|dstat
op_amp
(paren
id|MDPE
op_or
id|BF
)paren
)paren
id|sym_log_bus_error
c_func
(paren
id|np
)paren
suffix:semicolon
)brace
DECL|variable|sym_pci_dev_table
r_static
r_struct
id|sym_pci_chip
id|sym_pci_dev_table
(braket
)braket
op_assign
(brace
(brace
id|PCI_ID_SYM53C810
comma
l_int|0x0f
comma
l_string|&quot;810&quot;
comma
l_int|4
comma
l_int|8
comma
l_int|4
comma
l_int|64
comma
id|FE_ERL
)brace
comma
macro_line|#ifdef SYM_DEBUG_GENERIC_SUPPORT
(brace
id|PCI_ID_SYM53C810
comma
l_int|0xff
comma
l_string|&quot;810a&quot;
comma
l_int|4
comma
l_int|8
comma
l_int|4
comma
l_int|1
comma
id|FE_BOF
)brace
comma
macro_line|#else
(brace
id|PCI_ID_SYM53C810
comma
l_int|0xff
comma
l_string|&quot;810a&quot;
comma
l_int|4
comma
l_int|8
comma
l_int|4
comma
l_int|1
comma
id|FE_CACHE_SET
op_or
id|FE_LDSTR
op_or
id|FE_PFEN
op_or
id|FE_BOF
)brace
comma
macro_line|#endif
(brace
id|PCI_ID_SYM53C815
comma
l_int|0xff
comma
l_string|&quot;815&quot;
comma
l_int|4
comma
l_int|8
comma
l_int|4
comma
l_int|64
comma
id|FE_BOF
op_or
id|FE_ERL
)brace
comma
(brace
id|PCI_ID_SYM53C825
comma
l_int|0x0f
comma
l_string|&quot;825&quot;
comma
l_int|6
comma
l_int|8
comma
l_int|4
comma
l_int|64
comma
id|FE_WIDE
op_or
id|FE_BOF
op_or
id|FE_ERL
op_or
id|FE_DIFF
)brace
comma
(brace
id|PCI_ID_SYM53C825
comma
l_int|0xff
comma
l_string|&quot;825a&quot;
comma
l_int|6
comma
l_int|8
comma
l_int|4
comma
l_int|2
comma
id|FE_WIDE
op_or
id|FE_CACHE0_SET
op_or
id|FE_BOF
op_or
id|FE_DFS
op_or
id|FE_LDSTR
op_or
id|FE_PFEN
op_or
id|FE_RAM
op_or
id|FE_DIFF
)brace
comma
(brace
id|PCI_ID_SYM53C860
comma
l_int|0xff
comma
l_string|&quot;860&quot;
comma
l_int|4
comma
l_int|8
comma
l_int|5
comma
l_int|1
comma
id|FE_ULTRA
op_or
id|FE_CACHE_SET
op_or
id|FE_BOF
op_or
id|FE_LDSTR
op_or
id|FE_PFEN
)brace
comma
(brace
id|PCI_ID_SYM53C875
comma
l_int|0x01
comma
l_string|&quot;875&quot;
comma
l_int|6
comma
l_int|16
comma
l_int|5
comma
l_int|2
comma
id|FE_WIDE
op_or
id|FE_ULTRA
op_or
id|FE_CACHE0_SET
op_or
id|FE_BOF
op_or
id|FE_DFS
op_or
id|FE_LDSTR
op_or
id|FE_PFEN
op_or
id|FE_RAM
op_or
id|FE_DIFF
op_or
id|FE_VARCLK
)brace
comma
(brace
id|PCI_ID_SYM53C875
comma
l_int|0xff
comma
l_string|&quot;875&quot;
comma
l_int|6
comma
l_int|16
comma
l_int|5
comma
l_int|2
comma
id|FE_WIDE
op_or
id|FE_ULTRA
op_or
id|FE_DBLR
op_or
id|FE_CACHE0_SET
op_or
id|FE_BOF
op_or
id|FE_DFS
op_or
id|FE_LDSTR
op_or
id|FE_PFEN
op_or
id|FE_RAM
op_or
id|FE_DIFF
op_or
id|FE_VARCLK
)brace
comma
(brace
id|PCI_ID_SYM53C875_2
comma
l_int|0xff
comma
l_string|&quot;875&quot;
comma
l_int|6
comma
l_int|16
comma
l_int|5
comma
l_int|2
comma
id|FE_WIDE
op_or
id|FE_ULTRA
op_or
id|FE_DBLR
op_or
id|FE_CACHE0_SET
op_or
id|FE_BOF
op_or
id|FE_DFS
op_or
id|FE_LDSTR
op_or
id|FE_PFEN
op_or
id|FE_RAM
op_or
id|FE_DIFF
op_or
id|FE_VARCLK
)brace
comma
(brace
id|PCI_ID_SYM53C885
comma
l_int|0xff
comma
l_string|&quot;885&quot;
comma
l_int|6
comma
l_int|16
comma
l_int|5
comma
l_int|2
comma
id|FE_WIDE
op_or
id|FE_ULTRA
op_or
id|FE_DBLR
op_or
id|FE_CACHE0_SET
op_or
id|FE_BOF
op_or
id|FE_DFS
op_or
id|FE_LDSTR
op_or
id|FE_PFEN
op_or
id|FE_RAM
op_or
id|FE_DIFF
op_or
id|FE_VARCLK
)brace
comma
macro_line|#ifdef SYM_DEBUG_GENERIC_SUPPORT
(brace
id|PCI_ID_SYM53C895
comma
l_int|0xff
comma
l_string|&quot;895&quot;
comma
l_int|6
comma
l_int|31
comma
l_int|7
comma
l_int|2
comma
id|FE_WIDE
op_or
id|FE_ULTRA2
op_or
id|FE_QUAD
op_or
id|FE_CACHE_SET
op_or
id|FE_BOF
op_or
id|FE_DFS
op_or
id|FE_RAM
op_or
id|FE_LCKFRQ
)brace
comma
macro_line|#else
(brace
id|PCI_ID_SYM53C895
comma
l_int|0xff
comma
l_string|&quot;895&quot;
comma
l_int|6
comma
l_int|31
comma
l_int|7
comma
l_int|2
comma
id|FE_WIDE
op_or
id|FE_ULTRA2
op_or
id|FE_QUAD
op_or
id|FE_CACHE_SET
op_or
id|FE_BOF
op_or
id|FE_DFS
op_or
id|FE_LDSTR
op_or
id|FE_PFEN
op_or
id|FE_RAM
op_or
id|FE_LCKFRQ
)brace
comma
macro_line|#endif
(brace
id|PCI_ID_SYM53C896
comma
l_int|0xff
comma
l_string|&quot;896&quot;
comma
l_int|6
comma
l_int|31
comma
l_int|7
comma
l_int|4
comma
id|FE_WIDE
op_or
id|FE_ULTRA2
op_or
id|FE_QUAD
op_or
id|FE_CACHE_SET
op_or
id|FE_BOF
op_or
id|FE_DFS
op_or
id|FE_LDSTR
op_or
id|FE_PFEN
op_or
id|FE_RAM
op_or
id|FE_RAM8K
op_or
id|FE_64BIT
op_or
id|FE_DAC
op_or
id|FE_IO256
op_or
id|FE_NOPM
op_or
id|FE_LEDC
op_or
id|FE_LCKFRQ
)brace
comma
(brace
id|PCI_ID_SYM53C895A
comma
l_int|0xff
comma
l_string|&quot;895a&quot;
comma
l_int|6
comma
l_int|31
comma
l_int|7
comma
l_int|4
comma
id|FE_WIDE
op_or
id|FE_ULTRA2
op_or
id|FE_QUAD
op_or
id|FE_CACHE_SET
op_or
id|FE_BOF
op_or
id|FE_DFS
op_or
id|FE_LDSTR
op_or
id|FE_PFEN
op_or
id|FE_RAM
op_or
id|FE_RAM8K
op_or
id|FE_DAC
op_or
id|FE_IO256
op_or
id|FE_NOPM
op_or
id|FE_LEDC
op_or
id|FE_LCKFRQ
)brace
comma
(brace
id|PCI_ID_SYM53C875A
comma
l_int|0xff
comma
l_string|&quot;875a&quot;
comma
l_int|6
comma
l_int|31
comma
l_int|7
comma
l_int|4
comma
id|FE_WIDE
op_or
id|FE_ULTRA
op_or
id|FE_QUAD
op_or
id|FE_CACHE_SET
op_or
id|FE_BOF
op_or
id|FE_DFS
op_or
id|FE_LDSTR
op_or
id|FE_PFEN
op_or
id|FE_RAM
op_or
id|FE_DAC
op_or
id|FE_IO256
op_or
id|FE_NOPM
op_or
id|FE_LEDC
op_or
id|FE_LCKFRQ
)brace
comma
(brace
id|PCI_ID_LSI53C1010_33
comma
l_int|0x00
comma
l_string|&quot;1010-33&quot;
comma
l_int|6
comma
l_int|31
comma
l_int|7
comma
l_int|8
comma
id|FE_WIDE
op_or
id|FE_ULTRA3
op_or
id|FE_QUAD
op_or
id|FE_CACHE_SET
op_or
id|FE_BOF
op_or
id|FE_DFBC
op_or
id|FE_LDSTR
op_or
id|FE_PFEN
op_or
id|FE_RAM
op_or
id|FE_RAM8K
op_or
id|FE_64BIT
op_or
id|FE_DAC
op_or
id|FE_IO256
op_or
id|FE_NOPM
op_or
id|FE_LEDC
op_or
id|FE_CRC
op_or
id|FE_C10
)brace
comma
(brace
id|PCI_ID_LSI53C1010_33
comma
l_int|0xff
comma
l_string|&quot;1010-33&quot;
comma
l_int|6
comma
l_int|31
comma
l_int|7
comma
l_int|8
comma
id|FE_WIDE
op_or
id|FE_ULTRA3
op_or
id|FE_QUAD
op_or
id|FE_CACHE_SET
op_or
id|FE_BOF
op_or
id|FE_DFBC
op_or
id|FE_LDSTR
op_or
id|FE_PFEN
op_or
id|FE_RAM
op_or
id|FE_RAM8K
op_or
id|FE_64BIT
op_or
id|FE_DAC
op_or
id|FE_IO256
op_or
id|FE_NOPM
op_or
id|FE_LEDC
op_or
id|FE_CRC
op_or
id|FE_C10
op_or
id|FE_U3EN
)brace
comma
(brace
id|PCI_ID_LSI53C1010_66
comma
l_int|0xff
comma
l_string|&quot;1010-66&quot;
comma
l_int|6
comma
l_int|31
comma
l_int|7
comma
l_int|8
comma
id|FE_WIDE
op_or
id|FE_ULTRA3
op_or
id|FE_QUAD
op_or
id|FE_CACHE_SET
op_or
id|FE_BOF
op_or
id|FE_DFBC
op_or
id|FE_LDSTR
op_or
id|FE_PFEN
op_or
id|FE_RAM
op_or
id|FE_RAM8K
op_or
id|FE_64BIT
op_or
id|FE_DAC
op_or
id|FE_IO256
op_or
id|FE_NOPM
op_or
id|FE_LEDC
op_or
id|FE_66MHZ
op_or
id|FE_CRC
op_or
id|FE_C10
op_or
id|FE_U3EN
)brace
comma
(brace
id|PCI_ID_LSI53C1510D
comma
l_int|0xff
comma
l_string|&quot;1510d&quot;
comma
l_int|6
comma
l_int|31
comma
l_int|7
comma
l_int|4
comma
id|FE_WIDE
op_or
id|FE_ULTRA2
op_or
id|FE_QUAD
op_or
id|FE_CACHE_SET
op_or
id|FE_BOF
op_or
id|FE_DFS
op_or
id|FE_LDSTR
op_or
id|FE_PFEN
op_or
id|FE_RAM
op_or
id|FE_IO256
op_or
id|FE_LEDC
)brace
)brace
suffix:semicolon
DECL|macro|sym_pci_num_devs
mdefine_line|#define sym_pci_num_devs &bslash;&n;&t;(sizeof(sym_pci_dev_table) / sizeof(sym_pci_dev_table[0]))
multiline_comment|/*&n; *  Look up the chip table.&n; *&n; *  Return a pointer to the chip entry if found, &n; *  zero otherwise.&n; */
r_struct
id|sym_pci_chip
op_star
DECL|function|sym_lookup_pci_chip_table
id|sym_lookup_pci_chip_table
(paren
id|u_short
id|device_id
comma
id|u_char
id|revision
)paren
(brace
r_struct
id|sym_pci_chip
op_star
id|chip
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sym_pci_num_devs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|chip
op_assign
op_amp
id|sym_pci_dev_table
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|device_id
op_ne
id|chip-&gt;device_id
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|revision
OG
id|chip-&gt;revision_id
)paren
r_continue
suffix:semicolon
r_return
id|chip
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if SYM_CONF_DMA_ADDRESSING_MODE == 2
multiline_comment|/*&n; *  Lookup the 64 bit DMA segments map.&n; *  This is only used if the direct mapping &n; *  has been unsuccessful.&n; */
DECL|function|sym_lookup_dmap
r_int
id|sym_lookup_dmap
c_func
(paren
id|hcb_p
id|np
comma
id|u32
id|h
comma
r_int
id|s
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;use_dac
)paren
r_goto
id|weird
suffix:semicolon
multiline_comment|/* Look up existing mappings */
r_for
c_loop
(paren
id|i
op_assign
id|SYM_DMAP_SIZE
op_minus
l_int|1
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|h
op_eq
id|np-&gt;dmap_bah
(braket
id|i
)braket
)paren
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/* If direct mapping is free, get it */
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;dmap_bah
(braket
id|s
)braket
)paren
r_goto
r_new
suffix:semicolon
multiline_comment|/* Collision -&gt; lookup free mappings */
r_for
c_loop
(paren
id|s
op_assign
id|SYM_DMAP_SIZE
op_minus
l_int|1
suffix:semicolon
id|s
OG
l_int|0
suffix:semicolon
id|s
op_decrement
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;dmap_bah
(braket
id|s
)braket
)paren
r_goto
r_new
suffix:semicolon
)brace
id|weird
suffix:colon
id|panic
c_func
(paren
l_string|&quot;sym: ran out of 64 bit DMA segment registers&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
r_new
suffix:colon
id|np-&gt;dmap_bah
(braket
id|s
)braket
op_assign
id|h
suffix:semicolon
id|np-&gt;dmap_dirty
op_assign
l_int|1
suffix:semicolon
r_return
id|s
suffix:semicolon
)brace
multiline_comment|/*&n; *  Update IO registers scratch C..R so they will be &n; *  in sync. with queued CCB expectations.&n; */
DECL|function|sym_update_dmap_regs
r_static
r_void
id|sym_update_dmap_regs
c_func
(paren
id|hcb_p
id|np
)paren
(brace
r_int
id|o
comma
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;dmap_dirty
)paren
r_return
suffix:semicolon
id|o
op_assign
m_offsetof
(paren
r_struct
id|sym_reg
comma
id|nc_scrx
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SYM_DMAP_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|OUTL_OFF
c_func
(paren
id|o
comma
id|np-&gt;dmap_bah
(braket
id|i
)braket
)paren
suffix:semicolon
id|o
op_add_assign
l_int|4
suffix:semicolon
)brace
id|np-&gt;dmap_dirty
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; *  Prepare the next negotiation message if needed.&n; *&n; *  Fill in the part of message buffer that contains the &n; *  negotiation and the nego_status field of the CCB.&n; *  Returns the size of the message in bytes.&n; */
DECL|function|sym_prepare_nego
r_static
r_int
id|sym_prepare_nego
c_func
(paren
id|hcb_p
id|np
comma
id|ccb_p
id|cp
comma
r_int
id|nego
comma
id|u_char
op_star
id|msgptr
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|cp-&gt;target
)braket
suffix:semicolon
r_int
id|msglen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *  Early C1010 chips need a work-around for DT &n;&t; *  data transfer to work.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|np-&gt;features
op_amp
id|FE_U3EN
)paren
)paren
id|tp-&gt;tinfo.goal.options
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *  negotiate using PPR ?&n;&t; */
r_if
c_cond
(paren
id|tp-&gt;tinfo.goal.options
op_amp
id|PPR_OPT_MASK
)paren
id|nego
op_assign
id|NS_PPR
suffix:semicolon
multiline_comment|/*&n;&t; *  negotiate wide transfers ?&n;&t; */
r_else
r_if
c_cond
(paren
id|tp-&gt;tinfo.curr.width
op_ne
id|tp-&gt;tinfo.goal.width
)paren
id|nego
op_assign
id|NS_WIDE
suffix:semicolon
multiline_comment|/*&n;&t; *  negotiate synchronous transfers?&n;&t; */
r_else
r_if
c_cond
(paren
id|tp-&gt;tinfo.curr.period
op_ne
id|tp-&gt;tinfo.goal.period
op_logical_or
id|tp-&gt;tinfo.curr.offset
op_ne
id|tp-&gt;tinfo.goal.offset
)paren
id|nego
op_assign
id|NS_SYNC
suffix:semicolon
r_switch
c_cond
(paren
id|nego
)paren
(brace
r_case
id|NS_SYNC
suffix:colon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_EXTENDED
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
l_int|3
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_X_SYNC_REQ
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|tp-&gt;tinfo.goal.period
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|tp-&gt;tinfo.goal.offset
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NS_WIDE
suffix:colon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_EXTENDED
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
l_int|2
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_X_WIDE_REQ
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|tp-&gt;tinfo.goal.width
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NS_PPR
suffix:colon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_EXTENDED
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
l_int|6
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|M_X_PPR_REQ
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|tp-&gt;tinfo.goal.period
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
l_int|0
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|tp-&gt;tinfo.goal.offset
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|tp-&gt;tinfo.goal.width
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|tp-&gt;tinfo.goal.options
op_amp
id|PPR_OPT_DT
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|cp-&gt;nego_status
op_assign
id|nego
suffix:semicolon
r_if
c_cond
(paren
id|nego
)paren
(brace
id|tp-&gt;nego_cp
op_assign
id|cp
suffix:semicolon
multiline_comment|/* Keep track a nego will be performed */
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|sym_print_nego_msg
c_func
(paren
id|np
comma
id|cp-&gt;target
comma
id|nego
op_eq
id|NS_SYNC
ques
c_cond
l_string|&quot;sync msgout&quot;
suffix:colon
id|nego
op_eq
id|NS_WIDE
ques
c_cond
l_string|&quot;wide msgout&quot;
suffix:colon
l_string|&quot;ppr msgout&quot;
comma
id|msgptr
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
r_return
id|msglen
suffix:semicolon
)brace
multiline_comment|/*&n; *  Insert a job into the start queue.&n; */
DECL|function|sym_put_start_queue
r_void
id|sym_put_start_queue
c_func
(paren
id|hcb_p
id|np
comma
id|ccb_p
id|cp
)paren
(brace
id|u_short
id|qidx
suffix:semicolon
macro_line|#ifdef SYM_CONF_IARB_SUPPORT
multiline_comment|/*&n;&t; *  If the previously queued CCB is not yet done, &n;&t; *  set the IARB hint. The SCRIPTS will go with IARB &n;&t; *  for this job when starting the previous one.&n;&t; *  We leave devices a chance to win arbitration by &n;&t; *  not using more than &squot;iarb_max&squot; consecutive &n;&t; *  immediate arbitrations.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;last_cp
op_logical_and
id|np-&gt;iarb_count
OL
id|np-&gt;iarb_max
)paren
(brace
id|np-&gt;last_cp-&gt;host_flags
op_or_assign
id|HF_HINT_IARB
suffix:semicolon
op_increment
id|np-&gt;iarb_count
suffix:semicolon
)brace
r_else
id|np-&gt;iarb_count
op_assign
l_int|0
suffix:semicolon
id|np-&gt;last_cp
op_assign
id|cp
suffix:semicolon
macro_line|#endif
macro_line|#if   SYM_CONF_DMA_ADDRESSING_MODE == 2
multiline_comment|/*&n;&t; *  Make SCRIPTS aware of the 64 bit DMA &n;&t; *  segment registers not being up-to-date.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;dmap_dirty
)paren
id|cp-&gt;host_xflags
op_or_assign
id|HX_DMAP_DIRTY
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *  Optionnaly, set the IO timeout condition.&n;&t; */
macro_line|#ifdef&t;SYM_OPT_HANDLE_IO_TIMEOUT
id|sym_timeout_ccb
c_func
(paren
id|np
comma
id|cp
comma
id|sym_cam_timeout
c_func
(paren
id|cp-&gt;cam_ccb
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *  Insert first the idle task and then our job.&n;&t; *  The MBs should ensure proper ordering.&n;&t; */
id|qidx
op_assign
id|np-&gt;squeueput
op_plus
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|qidx
op_ge
id|MAX_QUEUE
op_star
l_int|2
)paren
id|qidx
op_assign
l_int|0
suffix:semicolon
id|np-&gt;squeue
(braket
id|qidx
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|np-&gt;idletask_ba
)paren
suffix:semicolon
id|MEMORY_WRITE_BARRIER
c_func
(paren
)paren
suffix:semicolon
id|np-&gt;squeue
(braket
id|np-&gt;squeueput
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|cp-&gt;ccb_ba
)paren
suffix:semicolon
id|np-&gt;squeueput
op_assign
id|qidx
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_QUEUE
)paren
id|printf
(paren
l_string|&quot;%s: queuepos=%d.&bslash;n&quot;
comma
id|sym_name
(paren
id|np
)paren
comma
id|np-&gt;squeueput
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Script processor may be waiting for reselect.&n;&t; *  Wake it up.&n;&t; */
id|MEMORY_WRITE_BARRIER
c_func
(paren
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
id|SIGP
op_or
id|np-&gt;istat_sem
)paren
suffix:semicolon
)brace
macro_line|#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING
multiline_comment|/*&n; *  Start next ready-to-start CCBs.&n; */
DECL|function|sym_start_next_ccbs
r_void
id|sym_start_next_ccbs
c_func
(paren
id|hcb_p
id|np
comma
id|lcb_p
id|lp
comma
r_int
id|maxn
)paren
(brace
id|SYM_QUEHEAD
op_star
id|qp
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
multiline_comment|/* &n;&t; *  Paranoia, as usual. :-)&n;&t; */
m_assert
(paren
op_logical_neg
id|lp-&gt;started_tags
op_logical_or
op_logical_neg
id|lp-&gt;started_no_tag
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Try to start as many commands as asked by caller.&n;&t; *  Prevent from having both tagged and untagged &n;&t; *  commands queued to the device at the same time.&n;&t; */
r_while
c_loop
(paren
id|maxn
op_decrement
)paren
(brace
id|qp
op_assign
id|sym_remque_head
c_func
(paren
op_amp
id|lp-&gt;waiting_ccbq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|qp
)paren
r_break
suffix:semicolon
id|cp
op_assign
id|sym_que_entry
c_func
(paren
id|qp
comma
r_struct
id|sym_ccb
comma
id|link2_ccbq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;tag
op_ne
id|NO_TAG
)paren
(brace
r_if
c_cond
(paren
id|lp-&gt;started_no_tag
op_logical_or
id|lp-&gt;started_tags
op_ge
id|lp-&gt;started_max
)paren
(brace
id|sym_insque_head
c_func
(paren
id|qp
comma
op_amp
id|lp-&gt;waiting_ccbq
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|lp-&gt;itlq_tbl
(braket
id|cp-&gt;tag
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|cp-&gt;ccb_ba
)paren
suffix:semicolon
id|lp-&gt;head.resel_sa
op_assign
id|cpu_to_scr
c_func
(paren
id|SCRIPTA_BA
(paren
id|np
comma
id|resel_tag
)paren
)paren
suffix:semicolon
op_increment
id|lp-&gt;started_tags
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|lp-&gt;started_no_tag
op_logical_or
id|lp-&gt;started_tags
)paren
(brace
id|sym_insque_head
c_func
(paren
id|qp
comma
op_amp
id|lp-&gt;waiting_ccbq
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|lp-&gt;head.itl_task_sa
op_assign
id|cpu_to_scr
c_func
(paren
id|cp-&gt;ccb_ba
)paren
suffix:semicolon
id|lp-&gt;head.resel_sa
op_assign
id|cpu_to_scr
c_func
(paren
id|SCRIPTA_BA
(paren
id|np
comma
id|resel_no_tag
)paren
)paren
suffix:semicolon
op_increment
id|lp-&gt;started_no_tag
suffix:semicolon
)brace
id|cp-&gt;started
op_assign
l_int|1
suffix:semicolon
id|sym_insque_tail
c_func
(paren
id|qp
comma
op_amp
id|lp-&gt;started_ccbq
)paren
suffix:semicolon
id|sym_put_start_queue
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* SYM_OPT_HANDLE_DEVICE_QUEUEING */
multiline_comment|/*&n; *  The chip may have completed jobs. Look at the DONE QUEUE.&n; *&n; *  On paper, memory read barriers may be needed here to &n; *  prevent out of order LOADs by the CPU from having &n; *  prefetched stale data prior to DMA having occurred.&n; */
DECL|function|sym_wakeup_done
r_static
r_int
id|sym_wakeup_done
(paren
id|hcb_p
id|np
)paren
(brace
id|ccb_p
id|cp
suffix:semicolon
r_int
id|i
comma
id|n
suffix:semicolon
id|u32
id|dsa
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
id|np-&gt;dqueueget
suffix:semicolon
multiline_comment|/* MEMORY_READ_BARRIER(); */
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|dsa
op_assign
id|scr_to_cpu
c_func
(paren
id|np-&gt;dqueue
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dsa
)paren
r_break
suffix:semicolon
id|np-&gt;dqueue
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|i
op_plus
l_int|2
)paren
op_ge
id|MAX_QUEUE
op_star
l_int|2
)paren
id|i
op_assign
l_int|0
suffix:semicolon
id|cp
op_assign
id|sym_ccb_from_dsa
c_func
(paren
id|np
comma
id|dsa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp
)paren
(brace
id|MEMORY_READ_BARRIER
c_func
(paren
)paren
suffix:semicolon
id|sym_complete_ok
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
op_increment
id|n
suffix:semicolon
)brace
r_else
id|printf
(paren
l_string|&quot;%s: bad DSA (%x) in done queue.&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
comma
(paren
id|u_int
)paren
id|dsa
)paren
suffix:semicolon
)brace
id|np-&gt;dqueueget
op_assign
id|i
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
multiline_comment|/*&n; *  Complete all active CCBs with error.&n; *  Used on CHIP/SCSI RESET.&n; */
DECL|function|sym_flush_busy_queue
r_static
r_void
id|sym_flush_busy_queue
(paren
id|hcb_p
id|np
comma
r_int
id|cam_status
)paren
(brace
multiline_comment|/*&n;&t; *  Move all active CCBs to the COMP queue &n;&t; *  and flush this queue.&n;&t; */
id|sym_que_splice
c_func
(paren
op_amp
id|np-&gt;busy_ccbq
comma
op_amp
id|np-&gt;comp_ccbq
)paren
suffix:semicolon
id|sym_que_init
c_func
(paren
op_amp
id|np-&gt;busy_ccbq
)paren
suffix:semicolon
id|sym_flush_comp_queue
c_func
(paren
id|np
comma
id|cam_status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Start chip.&n; *&n; *  &squot;reason&squot; means:&n; *     0: initialisation.&n; *     1: SCSI BUS RESET delivered or received.&n; *     2: SCSI BUS MODE changed.&n; */
DECL|function|sym_start_up
r_void
id|sym_start_up
(paren
id|hcb_p
id|np
comma
r_int
id|reason
)paren
(brace
r_int
id|i
suffix:semicolon
id|u32
id|phys
suffix:semicolon
multiline_comment|/*&n;&t; *  Reset chip if asked, otherwise just clear fifos.&n; &t; */
r_if
c_cond
(paren
id|reason
op_eq
l_int|1
)paren
id|sym_soft_reset
c_func
(paren
id|np
)paren
suffix:semicolon
r_else
(brace
id|OUTB
(paren
id|nc_stest3
comma
id|TE
op_or
id|CSF
)paren
suffix:semicolon
id|OUTONB
(paren
id|nc_ctest3
comma
id|CLF
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Clear Start Queue&n;&t; */
id|phys
op_assign
id|np-&gt;squeue_ba
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_QUEUE
op_star
l_int|2
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|np-&gt;squeue
(braket
id|i
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|np-&gt;idletask_ba
)paren
suffix:semicolon
id|np-&gt;squeue
(braket
id|i
op_plus
l_int|1
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|phys
op_plus
(paren
id|i
op_plus
l_int|2
)paren
op_star
l_int|4
)paren
suffix:semicolon
)brace
id|np-&gt;squeue
(braket
id|MAX_QUEUE
op_star
l_int|2
op_minus
l_int|1
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|phys
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Start at first entry.&n;&t; */
id|np-&gt;squeueput
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *  Clear Done Queue&n;&t; */
id|phys
op_assign
id|np-&gt;dqueue_ba
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_QUEUE
op_star
l_int|2
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|np-&gt;dqueue
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|np-&gt;dqueue
(braket
id|i
op_plus
l_int|1
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|phys
op_plus
(paren
id|i
op_plus
l_int|2
)paren
op_star
l_int|4
)paren
suffix:semicolon
)brace
id|np-&gt;dqueue
(braket
id|MAX_QUEUE
op_star
l_int|2
op_minus
l_int|1
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|phys
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Start at first entry.&n;&t; */
id|np-&gt;dqueueget
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *  Install patches in scripts.&n;&t; *  This also let point to first position the start &n;&t; *  and done queue pointers used from SCRIPTS.&n;&t; */
id|np
op_member_access_from_pointer
id|fw_patch
c_func
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Wakeup all pending jobs.&n;&t; */
id|sym_flush_busy_queue
c_func
(paren
id|np
comma
id|CAM_SCSI_BUS_RESET
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Init chip.&n;&t; */
id|OUTB
(paren
id|nc_istat
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/*  Remove Reset, abort */
id|UDELAY
(paren
l_int|2000
)paren
suffix:semicolon
multiline_comment|/* The 895 needs time for the bus mode to settle */
id|OUTB
(paren
id|nc_scntl0
comma
id|np-&gt;rv_scntl0
op_or
l_int|0xc0
)paren
suffix:semicolon
multiline_comment|/*  full arb., ena parity, par-&gt;ATN  */
id|OUTB
(paren
id|nc_scntl1
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/*  odd parity, and remove CRST!! */
id|sym_selectclock
c_func
(paren
id|np
comma
id|np-&gt;rv_scntl3
)paren
suffix:semicolon
multiline_comment|/* Select SCSI clock */
id|OUTB
(paren
id|nc_scid
comma
id|RRE
op_or
id|np-&gt;myaddr
)paren
suffix:semicolon
multiline_comment|/* Adapter SCSI address */
id|OUTW
(paren
id|nc_respid
comma
l_int|1ul
op_lshift
id|np-&gt;myaddr
)paren
suffix:semicolon
multiline_comment|/* Id to respond to */
id|OUTB
(paren
id|nc_istat
comma
id|SIGP
)paren
suffix:semicolon
multiline_comment|/*  Signal Process */
id|OUTB
(paren
id|nc_dmode
comma
id|np-&gt;rv_dmode
)paren
suffix:semicolon
multiline_comment|/* Burst length, dma mode */
id|OUTB
(paren
id|nc_ctest5
comma
id|np-&gt;rv_ctest5
)paren
suffix:semicolon
multiline_comment|/* Large fifo + large burst */
id|OUTB
(paren
id|nc_dcntl
comma
id|NOCOM
op_or
id|np-&gt;rv_dcntl
)paren
suffix:semicolon
multiline_comment|/* Protect SFBR */
id|OUTB
(paren
id|nc_ctest3
comma
id|np-&gt;rv_ctest3
)paren
suffix:semicolon
multiline_comment|/* Write and invalidate */
id|OUTB
(paren
id|nc_ctest4
comma
id|np-&gt;rv_ctest4
)paren
suffix:semicolon
multiline_comment|/* Master parity checking */
multiline_comment|/* Extended Sreq/Sack filtering not supported on the C10 */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_C10
)paren
id|OUTB
(paren
id|nc_stest2
comma
id|np-&gt;rv_stest2
)paren
suffix:semicolon
r_else
id|OUTB
(paren
id|nc_stest2
comma
id|EXT
op_or
id|np-&gt;rv_stest2
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_stest3
comma
id|TE
)paren
suffix:semicolon
multiline_comment|/* TolerANT enable */
id|OUTB
(paren
id|nc_stime0
comma
l_int|0x0c
)paren
suffix:semicolon
multiline_comment|/* HTH disabled  STO 0.25 sec */
multiline_comment|/*&n;&t; *  For now, disable AIP generation on C1010-66.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;device_id
op_eq
id|PCI_ID_LSI53C1010_66
)paren
id|OUTB
(paren
id|nc_aipcntl1
comma
id|DISAIP
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  C10101 rev. 0 errata.&n;&t; *  Errant SGE&squot;s when in narrow. Write bits 4 &amp; 5 of&n;&t; *  STEST1 register to disable SGE. We probably should do &n;&t; *  that from SCRIPTS for each selection/reselection, but &n;&t; *  I just don&squot;t want. :)&n;&t; */
r_if
c_cond
(paren
id|np-&gt;device_id
op_eq
id|PCI_ID_LSI53C1010_33
op_logical_and
id|np-&gt;revision_id
OL
l_int|1
)paren
id|OUTB
(paren
id|nc_stest1
comma
id|INB
c_func
(paren
id|nc_stest1
)paren
op_or
l_int|0x30
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  DEL 441 - 53C876 Rev 5 - Part Number 609-0392787/2788 - ITEM 2.&n;&t; *  Disable overlapped arbitration for some dual function devices, &n;&t; *  regardless revision id (kind of post-chip-design feature. ;-))&n;&t; */
r_if
c_cond
(paren
id|np-&gt;device_id
op_eq
id|PCI_ID_SYM53C875
)paren
id|OUTB
(paren
id|nc_ctest0
comma
(paren
l_int|1
op_lshift
l_int|5
)paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|np-&gt;device_id
op_eq
id|PCI_ID_SYM53C896
)paren
id|np-&gt;rv_ccntl0
op_or_assign
id|DPR
suffix:semicolon
multiline_comment|/*&n;&t; *  Write CCNTL0/CCNTL1 for chips capable of 64 bit addressing &n;&t; *  and/or hardware phase mismatch, since only such chips &n;&t; *  seem to support those IO registers.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
(paren
id|FE_DAC
op_or
id|FE_NOPM
)paren
)paren
(brace
id|OUTB
(paren
id|nc_ccntl0
comma
id|np-&gt;rv_ccntl0
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_ccntl1
comma
id|np-&gt;rv_ccntl1
)paren
suffix:semicolon
)brace
macro_line|#if&t;SYM_CONF_DMA_ADDRESSING_MODE == 2
multiline_comment|/*&n;&t; *  Set up scratch C and DRS IO registers to map the 32 bit &n;&t; *  DMA address range our data structures are located in.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;use_dac
)paren
(brace
id|np-&gt;dmap_bah
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ??? */
id|OUTL
(paren
id|nc_scrx
(braket
l_int|0
)braket
comma
id|np-&gt;dmap_bah
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_drs
comma
id|np-&gt;dmap_bah
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; *  If phase mismatch handled by scripts (895A/896/1010),&n;&t; *  set PM jump addresses.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_NOPM
)paren
(brace
id|OUTL
(paren
id|nc_pmjad1
comma
id|SCRIPTB_BA
(paren
id|np
comma
id|pm_handle
)paren
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_pmjad2
comma
id|SCRIPTB_BA
(paren
id|np
comma
id|pm_handle
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *    Enable GPIO0 pin for writing if LED support from SCRIPTS.&n;&t; *    Also set GPIO5 and clear GPIO6 if hardware LED control.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_LED0
)paren
id|OUTB
c_func
(paren
id|nc_gpcntl
comma
id|INB
c_func
(paren
id|nc_gpcntl
)paren
op_amp
op_complement
l_int|0x01
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_LEDC
)paren
id|OUTB
c_func
(paren
id|nc_gpcntl
comma
(paren
id|INB
c_func
(paren
id|nc_gpcntl
)paren
op_amp
op_complement
l_int|0x41
)paren
op_or
l_int|0x20
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      enable ints&n;&t; */
id|OUTW
(paren
id|nc_sien
comma
id|STO
op_or
id|HTH
op_or
id|MA
op_or
id|SGE
op_or
id|UDC
op_or
id|RST
op_or
id|PAR
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_dien
comma
id|MDPE
op_or
id|BF
op_or
id|SSI
op_or
id|SIR
op_or
id|IID
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  For 895/6 enable SBMC interrupt and save current SCSI bus mode.&n;&t; *  Try to eat the spurious SBMC interrupt that may occur when &n;&t; *  we reset the chip but not the SCSI BUS (at initialization).&n;&t; */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
(paren
id|FE_ULTRA2
op_or
id|FE_ULTRA3
)paren
)paren
(brace
id|OUTONW
(paren
id|nc_sien
comma
id|SBMC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reason
op_eq
l_int|0
)paren
(brace
id|MDELAY
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|INW
(paren
id|nc_sist
)paren
suffix:semicolon
)brace
id|np-&gt;scsi_mode
op_assign
id|INB
(paren
id|nc_stest4
)paren
op_amp
id|SMODE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Fill in target structure.&n;&t; *  Reinitialize usrsync.&n;&t; *  Reinitialize usrwide.&n;&t; *  Prepare sync negotiation according to actual SCSI bus mode.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SYM_CONF_MAX_TARGET
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|i
)braket
suffix:semicolon
id|tp-&gt;to_reset
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;head.sval
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;head.wval
op_assign
id|np-&gt;rv_scntl3
suffix:semicolon
id|tp-&gt;head.uval
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;tinfo.curr.period
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;tinfo.curr.offset
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;tinfo.curr.width
op_assign
id|BUS_8_BIT
suffix:semicolon
id|tp-&gt;tinfo.curr.options
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Download SCSI SCRIPTS to on-chip RAM if present,&n;&t; *  and start script processor.&n;&t; *  We do the download preferently from the CPU.&n;&t; *  For platforms that may not support PCI memory mapping,&n;&t; *  we use simple SCRIPTS that performs MEMORY MOVEs.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;ram_ba
)paren
(brace
r_if
c_cond
(paren
id|sym_verbose
op_ge
l_int|2
)paren
id|printf
(paren
l_string|&quot;%s: Downloading SCSI SCRIPTS.&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;ram_ws
op_eq
l_int|8192
)paren
(brace
id|OUTRAM_OFF
c_func
(paren
l_int|4096
comma
id|np-&gt;scriptb0
comma
id|np-&gt;scriptb_sz
)paren
suffix:semicolon
id|phys
op_assign
id|scr_to_cpu
c_func
(paren
id|np-&gt;scr_ram_seg
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_mmws
comma
id|phys
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_mmrs
comma
id|phys
)paren
suffix:semicolon
id|OUTL
(paren
id|nc_sfs
comma
id|phys
)paren
suffix:semicolon
id|phys
op_assign
id|SCRIPTB_BA
(paren
id|np
comma
id|start64
)paren
suffix:semicolon
)brace
r_else
id|phys
op_assign
id|SCRIPTA_BA
(paren
id|np
comma
id|init
)paren
suffix:semicolon
id|OUTRAM_OFF
c_func
(paren
l_int|0
comma
id|np-&gt;scripta0
comma
id|np-&gt;scripta_sz
)paren
suffix:semicolon
)brace
r_else
id|phys
op_assign
id|SCRIPTA_BA
(paren
id|np
comma
id|init
)paren
suffix:semicolon
id|np-&gt;istat_sem
op_assign
l_int|0
suffix:semicolon
id|OUTL
(paren
id|nc_dsa
comma
id|np-&gt;hcb_ba
)paren
suffix:semicolon
id|OUTL_DSP
(paren
id|phys
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Notify the XPT about the RESET condition.&n;&t; */
r_if
c_cond
(paren
id|reason
op_ne
l_int|0
)paren
id|sym_xpt_async_bus_reset
c_func
(paren
id|np
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Switch trans mode for current job and it&squot;s target.&n; */
DECL|function|sym_settrans
r_static
r_void
id|sym_settrans
c_func
(paren
id|hcb_p
id|np
comma
r_int
id|target
comma
id|u_char
id|dt
comma
id|u_char
id|ofs
comma
id|u_char
id|per
comma
id|u_char
id|wide
comma
id|u_char
id|div
comma
id|u_char
id|fak
)paren
(brace
id|SYM_QUEHEAD
op_star
id|qp
suffix:semicolon
id|u_char
id|sval
comma
id|wval
comma
id|uval
suffix:semicolon
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
m_assert
(paren
id|target
op_eq
(paren
id|INB
(paren
id|nc_sdid
)paren
op_amp
l_int|0x0f
)paren
)paren
suffix:semicolon
id|sval
op_assign
id|tp-&gt;head.sval
suffix:semicolon
id|wval
op_assign
id|tp-&gt;head.wval
suffix:semicolon
id|uval
op_assign
id|tp-&gt;head.uval
suffix:semicolon
macro_line|#if 0
id|printf
c_func
(paren
l_string|&quot;XXXX sval=%x wval=%x uval=%x (%x)&bslash;n&quot;
comma
id|sval
comma
id|wval
comma
id|uval
comma
id|np-&gt;rv_scntl3
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *  Set the offset.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|np-&gt;features
op_amp
id|FE_C10
)paren
)paren
id|sval
op_assign
(paren
id|sval
op_amp
op_complement
l_int|0x1f
)paren
op_or
id|ofs
suffix:semicolon
r_else
id|sval
op_assign
(paren
id|sval
op_amp
op_complement
l_int|0x3f
)paren
op_or
id|ofs
suffix:semicolon
multiline_comment|/*&n;&t; *  Set the sync divisor and extra clock factor.&n;&t; */
r_if
c_cond
(paren
id|ofs
op_ne
l_int|0
)paren
(brace
id|wval
op_assign
(paren
id|wval
op_amp
op_complement
l_int|0x70
)paren
op_or
(paren
(paren
id|div
op_plus
l_int|1
)paren
op_lshift
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|np-&gt;features
op_amp
id|FE_C10
)paren
)paren
id|sval
op_assign
(paren
id|sval
op_amp
op_complement
l_int|0xe0
)paren
op_or
(paren
id|fak
op_lshift
l_int|5
)paren
suffix:semicolon
r_else
(brace
id|uval
op_assign
id|uval
op_amp
op_complement
(paren
id|XCLKH_ST
op_or
id|XCLKH_DT
op_or
id|XCLKS_ST
op_or
id|XCLKS_DT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fak
op_ge
l_int|1
)paren
id|uval
op_or_assign
(paren
id|XCLKH_ST
op_or
id|XCLKH_DT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fak
op_ge
l_int|2
)paren
id|uval
op_or_assign
(paren
id|XCLKS_ST
op_or
id|XCLKS_DT
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *  Set the bus width.&n;&t; */
id|wval
op_assign
id|wval
op_amp
op_complement
id|EWS
suffix:semicolon
r_if
c_cond
(paren
id|wide
op_ne
l_int|0
)paren
id|wval
op_or_assign
id|EWS
suffix:semicolon
multiline_comment|/*&n;&t; *  Set misc. ultra enable bits.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_C10
)paren
(brace
id|uval
op_assign
id|uval
op_amp
op_complement
(paren
id|U3EN
op_or
id|AIPCKEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dt
)paren
(brace
m_assert
(paren
id|np-&gt;features
op_amp
id|FE_U3EN
)paren
suffix:semicolon
id|uval
op_or_assign
id|U3EN
suffix:semicolon
)brace
)brace
r_else
(brace
id|wval
op_assign
id|wval
op_amp
op_complement
id|ULTRA
suffix:semicolon
r_if
c_cond
(paren
id|per
op_le
l_int|12
)paren
id|wval
op_or_assign
id|ULTRA
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *   Stop there if sync parameters are unchanged.&n;&t; */
r_if
c_cond
(paren
id|tp-&gt;head.sval
op_eq
id|sval
op_logical_and
id|tp-&gt;head.wval
op_eq
id|wval
op_logical_and
id|tp-&gt;head.uval
op_eq
id|uval
)paren
r_return
suffix:semicolon
id|tp-&gt;head.sval
op_assign
id|sval
suffix:semicolon
id|tp-&gt;head.wval
op_assign
id|wval
suffix:semicolon
id|tp-&gt;head.uval
op_assign
id|uval
suffix:semicolon
multiline_comment|/*&n;&t; *  Disable extended Sreq/Sack filtering if per &lt; 50.&n;&t; *  Not supported on the C1010.&n;&t; */
r_if
c_cond
(paren
id|per
OL
l_int|50
op_logical_and
op_logical_neg
(paren
id|np-&gt;features
op_amp
id|FE_C10
)paren
)paren
id|OUTOFFB
(paren
id|nc_stest2
comma
id|EXT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  set actual value and sync_status&n;&t; */
id|OUTB
(paren
id|nc_sxfer
comma
id|tp-&gt;head.sval
)paren
suffix:semicolon
id|OUTB
(paren
id|nc_scntl3
comma
id|tp-&gt;head.wval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_C10
)paren
(brace
id|OUTB
(paren
id|nc_scntl4
comma
id|tp-&gt;head.uval
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  patch ALL busy ccbs of this target.&n;&t; */
id|FOR_EACH_QUEUED_ELEMENT
c_func
(paren
op_amp
id|np-&gt;busy_ccbq
comma
id|qp
)paren
(brace
id|ccb_p
id|cp
suffix:semicolon
id|cp
op_assign
id|sym_que_entry
c_func
(paren
id|qp
comma
r_struct
id|sym_ccb
comma
id|link_ccbq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;target
op_ne
id|target
)paren
r_continue
suffix:semicolon
id|cp-&gt;phys.select.sel_scntl3
op_assign
id|tp-&gt;head.wval
suffix:semicolon
id|cp-&gt;phys.select.sel_sxfer
op_assign
id|tp-&gt;head.sval
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_C10
)paren
(brace
id|cp-&gt;phys.select.sel_scntl4
op_assign
id|tp-&gt;head.uval
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; *  We received a WDTR.&n; *  Let everything be aware of the changes.&n; */
DECL|function|sym_setwide
r_static
r_void
id|sym_setwide
c_func
(paren
id|hcb_p
id|np
comma
r_int
id|target
comma
id|u_char
id|wide
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
id|sym_settrans
c_func
(paren
id|np
comma
id|target
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|wide
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|tp-&gt;tinfo.goal.width
op_assign
id|tp-&gt;tinfo.curr.width
op_assign
id|wide
suffix:semicolon
id|tp-&gt;tinfo.curr.offset
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;tinfo.curr.period
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;tinfo.curr.options
op_assign
l_int|0
suffix:semicolon
id|sym_xpt_async_nego_wide
c_func
(paren
id|np
comma
id|target
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  We received a SDTR.&n; *  Let everything be aware of the changes.&n; */
r_static
r_void
DECL|function|sym_setsync
id|sym_setsync
c_func
(paren
id|hcb_p
id|np
comma
r_int
id|target
comma
id|u_char
id|ofs
comma
id|u_char
id|per
comma
id|u_char
id|div
comma
id|u_char
id|fak
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
id|u_char
id|wide
op_assign
(paren
id|tp-&gt;head.wval
op_amp
id|EWS
)paren
ques
c_cond
id|BUS_16_BIT
suffix:colon
id|BUS_8_BIT
suffix:semicolon
id|sym_settrans
c_func
(paren
id|np
comma
id|target
comma
l_int|0
comma
id|ofs
comma
id|per
comma
id|wide
comma
id|div
comma
id|fak
)paren
suffix:semicolon
id|tp-&gt;tinfo.curr.period
op_assign
id|per
suffix:semicolon
id|tp-&gt;tinfo.curr.offset
op_assign
id|ofs
suffix:semicolon
id|tp-&gt;tinfo.curr.options
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tp-&gt;tinfo.goal.options
op_amp
id|PPR_OPT_MASK
)paren
)paren
(brace
id|tp-&gt;tinfo.goal.period
op_assign
id|per
suffix:semicolon
id|tp-&gt;tinfo.goal.offset
op_assign
id|ofs
suffix:semicolon
id|tp-&gt;tinfo.goal.options
op_assign
l_int|0
suffix:semicolon
)brace
id|sym_xpt_async_nego_sync
c_func
(paren
id|np
comma
id|target
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  We received a PPR.&n; *  Let everything be aware of the changes.&n; */
r_static
r_void
DECL|function|sym_setpprot
id|sym_setpprot
c_func
(paren
id|hcb_p
id|np
comma
r_int
id|target
comma
id|u_char
id|dt
comma
id|u_char
id|ofs
comma
id|u_char
id|per
comma
id|u_char
id|wide
comma
id|u_char
id|div
comma
id|u_char
id|fak
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
id|sym_settrans
c_func
(paren
id|np
comma
id|target
comma
id|dt
comma
id|ofs
comma
id|per
comma
id|wide
comma
id|div
comma
id|fak
)paren
suffix:semicolon
id|tp-&gt;tinfo.goal.width
op_assign
id|tp-&gt;tinfo.curr.width
op_assign
id|wide
suffix:semicolon
id|tp-&gt;tinfo.goal.period
op_assign
id|tp-&gt;tinfo.curr.period
op_assign
id|per
suffix:semicolon
id|tp-&gt;tinfo.goal.offset
op_assign
id|tp-&gt;tinfo.curr.offset
op_assign
id|ofs
suffix:semicolon
id|tp-&gt;tinfo.goal.options
op_assign
id|tp-&gt;tinfo.curr.options
op_assign
id|dt
suffix:semicolon
id|sym_xpt_async_nego_ppr
c_func
(paren
id|np
comma
id|target
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  generic recovery from scsi interrupt&n; *&n; *  The doc says that when the chip gets an SCSI interrupt,&n; *  it tries to stop in an orderly fashion, by completing &n; *  an instruction fetch that had started or by flushing &n; *  the DMA fifo for a write to memory that was executing.&n; *  Such a fashion is not enough to know if the instruction &n; *  that was just before the current DSP value has been &n; *  executed or not.&n; *&n; *  There are some small SCRIPTS sections that deal with &n; *  the start queue and the done queue that may break any &n; *  assomption from the C code if we are interrupted &n; *  inside, so we reset if this happens. Btw, since these &n; *  SCRIPTS sections are executed while the SCRIPTS hasn&squot;t &n; *  started SCSI operations, it is very unlikely to happen.&n; *&n; *  All the driver data structures are supposed to be &n; *  allocated from the same 4 GB memory window, so there &n; *  is a 1 to 1 relationship between DSA and driver data &n; *  structures. Since we are careful :) to invalidate the &n; *  DSA when we complete a command or when the SCRIPTS &n; *  pushes a DSA into a queue, we can trust it when it &n; *  points to a CCB.&n; */
DECL|function|sym_recover_scsi_int
r_static
r_void
id|sym_recover_scsi_int
(paren
id|hcb_p
id|np
comma
id|u_char
id|hsts
)paren
(brace
id|u32
id|dsp
op_assign
id|INL
(paren
id|nc_dsp
)paren
suffix:semicolon
id|u32
id|dsa
op_assign
id|INL
(paren
id|nc_dsa
)paren
suffix:semicolon
id|ccb_p
id|cp
op_assign
id|sym_ccb_from_dsa
c_func
(paren
id|np
comma
id|dsa
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  If we haven&squot;t been interrupted inside the SCRIPTS &n;&t; *  critical pathes, we can safely restart the SCRIPTS &n;&t; *  and trust the DSA value if it matches a CCB.&n;&t; */
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|dsp
OG
id|SCRIPTA_BA
(paren
id|np
comma
id|getjob_begin
)paren
op_logical_and
id|dsp
OL
id|SCRIPTA_BA
(paren
id|np
comma
id|getjob_end
)paren
op_plus
l_int|1
)paren
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|dsp
OG
id|SCRIPTA_BA
(paren
id|np
comma
id|ungetjob
)paren
op_logical_and
id|dsp
OL
id|SCRIPTA_BA
(paren
id|np
comma
id|reselect
)paren
op_plus
l_int|1
)paren
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|dsp
OG
id|SCRIPTB_BA
(paren
id|np
comma
id|sel_for_abort
)paren
op_logical_and
id|dsp
OL
id|SCRIPTB_BA
(paren
id|np
comma
id|sel_for_abort_1
)paren
op_plus
l_int|1
)paren
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|dsp
OG
id|SCRIPTA_BA
(paren
id|np
comma
id|done
)paren
op_logical_and
id|dsp
OL
id|SCRIPTA_BA
(paren
id|np
comma
id|done_end
)paren
op_plus
l_int|1
)paren
)paren
)paren
(brace
id|OUTB
(paren
id|nc_ctest3
comma
id|np-&gt;rv_ctest3
op_or
id|CLF
)paren
suffix:semicolon
multiline_comment|/* clear dma fifo  */
id|OUTB
(paren
id|nc_stest3
comma
id|TE
op_or
id|CSF
)paren
suffix:semicolon
multiline_comment|/* clear scsi fifo */
multiline_comment|/*&n;&t;&t; *  If we have a CCB, let the SCRIPTS call us back for &n;&t;&t; *  the handling of the error with SCRATCHA filled with &n;&t;&t; *  STARTPOS. This way, we will be able to freeze the &n;&t;&t; *  device queue and requeue awaiting IOs.&n;&t;&t; */
r_if
c_cond
(paren
id|cp
)paren
(brace
id|cp-&gt;host_status
op_assign
id|hsts
suffix:semicolon
id|OUTL_DSP
(paren
id|SCRIPTA_BA
(paren
id|np
comma
id|complete_error
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  Otherwise just restart the SCRIPTS.&n;&t;&t; */
r_else
(brace
id|OUTL
(paren
id|nc_dsa
comma
l_int|0xffffff
)paren
suffix:semicolon
id|OUTL_DSP
(paren
id|SCRIPTA_BA
(paren
id|np
comma
id|start
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
r_goto
id|reset_all
suffix:semicolon
r_return
suffix:semicolon
id|reset_all
suffix:colon
id|sym_start_reset
c_func
(paren
id|np
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  chip exception handler for selection timeout&n; */
DECL|function|sym_int_sto
r_static
r_void
id|sym_int_sto
(paren
id|hcb_p
id|np
)paren
(brace
id|u32
id|dsp
op_assign
id|INL
(paren
id|nc_dsp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printf
(paren
l_string|&quot;T&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dsp
op_eq
id|SCRIPTA_BA
(paren
id|np
comma
id|wf_sel_done
)paren
op_plus
l_int|8
)paren
id|sym_recover_scsi_int
c_func
(paren
id|np
comma
id|HS_SEL_TIMEOUT
)paren
suffix:semicolon
r_else
id|sym_start_reset
c_func
(paren
id|np
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  chip exception handler for unexpected disconnect&n; */
DECL|function|sym_int_udc
r_static
r_void
id|sym_int_udc
(paren
id|hcb_p
id|np
)paren
(brace
id|printf
(paren
l_string|&quot;%s: unexpected disconnect&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|sym_recover_scsi_int
c_func
(paren
id|np
comma
id|HS_UNEXPECTED
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  chip exception handler for SCSI bus mode change&n; *&n; *  spi2-r12 11.2.3 says a transceiver mode change must &n; *  generate a reset event and a device that detects a reset &n; *  event shall initiate a hard reset. It says also that a&n; *  device that detects a mode change shall set data transfer &n; *  mode to eight bit asynchronous, etc...&n; *  So, just reinitializing all except chip should be enough.&n; */
DECL|function|sym_int_sbmc
r_static
r_void
id|sym_int_sbmc
(paren
id|hcb_p
id|np
)paren
(brace
id|u_char
id|scsi_mode
op_assign
id|INB
(paren
id|nc_stest4
)paren
op_amp
id|SMODE
suffix:semicolon
multiline_comment|/*&n;&t; *  Notify user.&n;&t; */
id|printf
c_func
(paren
l_string|&quot;%s: SCSI BUS mode change from %s to %s.&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
comma
id|sym_scsi_bus_mode
c_func
(paren
id|np-&gt;scsi_mode
)paren
comma
id|sym_scsi_bus_mode
c_func
(paren
id|scsi_mode
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Should suspend command processing for a few seconds and &n;&t; *  reinitialize all except the chip.&n;&t; */
id|sym_start_up
(paren
id|np
comma
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  chip exception handler for SCSI parity error.&n; *&n; *  When the chip detects a SCSI parity error and is &n; *  currently executing a (CH)MOV instruction, it does &n; *  not interrupt immediately, but tries to finish the &n; *  transfer of the current scatter entry before &n; *  interrupting. The following situations may occur:&n; *&n; *  - The complete scatter entry has been transferred &n; *    without the device having changed phase.&n; *    The chip will then interrupt with the DSP pointing &n; *    to the instruction that follows the MOV.&n; *&n; *  - A phase mismatch occurs before the MOV finished &n; *    and phase errors are to be handled by the C code.&n; *    The chip will then interrupt with both PAR and MA &n; *    conditions set.&n; *&n; *  - A phase mismatch occurs before the MOV finished and &n; *    phase errors are to be handled by SCRIPTS.&n; *    The chip will load the DSP with the phase mismatch &n; *    JUMP address and interrupt the host processor.&n; */
DECL|function|sym_int_par
r_static
r_void
id|sym_int_par
(paren
id|hcb_p
id|np
comma
id|u_short
id|sist
)paren
(brace
id|u_char
id|hsts
op_assign
id|INB
(paren
id|HS_PRT
)paren
suffix:semicolon
id|u32
id|dsp
op_assign
id|INL
(paren
id|nc_dsp
)paren
suffix:semicolon
id|u32
id|dbc
op_assign
id|INL
(paren
id|nc_dbc
)paren
suffix:semicolon
id|u32
id|dsa
op_assign
id|INL
(paren
id|nc_dsa
)paren
suffix:semicolon
id|u_char
id|sbcl
op_assign
id|INB
(paren
id|nc_sbcl
)paren
suffix:semicolon
id|u_char
id|cmd
op_assign
id|dbc
op_rshift
l_int|24
suffix:semicolon
r_int
id|phase
op_assign
id|cmd
op_amp
l_int|7
suffix:semicolon
id|ccb_p
id|cp
op_assign
id|sym_ccb_from_dsa
c_func
(paren
id|np
comma
id|dsa
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s: SCSI parity error detected: SCR1=%d DBC=%x SBCL=%x&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
comma
id|hsts
comma
id|dbc
comma
id|sbcl
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Check that the chip is connected to the SCSI BUS.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|INB
(paren
id|nc_scntl1
)paren
op_amp
id|ISCON
)paren
)paren
(brace
id|sym_recover_scsi_int
c_func
(paren
id|np
comma
id|HS_UNEXPECTED
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  If the nexus is not clearly identified, reset the bus.&n;&t; *  We will try to do better later.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_goto
id|reset_all
suffix:semicolon
multiline_comment|/*&n;&t; *  Check instruction was a MOV, direction was INPUT and &n;&t; *  ATN is asserted.&n;&t; */
r_if
c_cond
(paren
(paren
id|cmd
op_amp
l_int|0xc0
)paren
op_logical_or
op_logical_neg
(paren
id|phase
op_amp
l_int|1
)paren
op_logical_or
op_logical_neg
(paren
id|sbcl
op_amp
l_int|0x8
)paren
)paren
r_goto
id|reset_all
suffix:semicolon
multiline_comment|/*&n;&t; *  Keep track of the parity error.&n;&t; */
id|OUTONB
(paren
id|HF_PRT
comma
id|HF_EXT_ERR
)paren
suffix:semicolon
id|cp-&gt;xerr_status
op_or_assign
id|XE_PARITY_ERR
suffix:semicolon
multiline_comment|/*&n;&t; *  Prepare the message to send to the device.&n;&t; */
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
(paren
id|phase
op_eq
l_int|7
)paren
ques
c_cond
id|M_PARITY
suffix:colon
id|M_ID_ERROR
suffix:semicolon
multiline_comment|/*&n;&t; *  If the old phase was DATA IN phase, we have to deal with&n;&t; *  the 3 situations described above.&n;&t; *  For other input phases (MSG IN and STATUS), the device &n;&t; *  must resend the whole thing that failed parity checking &n;&t; *  or signal error. So, jumping to dispatcher should be OK.&n;&t; */
r_if
c_cond
(paren
id|phase
op_eq
l_int|1
op_logical_or
id|phase
op_eq
l_int|5
)paren
(brace
multiline_comment|/* Phase mismatch handled by SCRIPTS */
r_if
c_cond
(paren
id|dsp
op_eq
id|SCRIPTB_BA
(paren
id|np
comma
id|pm_handle
)paren
)paren
id|OUTL_DSP
(paren
id|dsp
)paren
suffix:semicolon
multiline_comment|/* Phase mismatch handled by the C code */
r_else
r_if
c_cond
(paren
id|sist
op_amp
id|MA
)paren
id|sym_int_ma
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/* No phase mismatch occurred */
r_else
(brace
id|sym_set_script_dp
(paren
id|np
comma
id|cp
comma
id|dsp
)paren
suffix:semicolon
id|OUTL_DSP
(paren
id|SCRIPTA_BA
(paren
id|np
comma
id|dispatch
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|phase
op_eq
l_int|7
)paren
multiline_comment|/* We definitely cannot handle parity errors */
macro_line|#if 1&t;&t;&t;&t;/* in message-in phase due to the relection  */
r_goto
id|reset_all
suffix:semicolon
multiline_comment|/* path and various message anticipations.   */
macro_line|#else
id|OUTL_DSP
(paren
id|SCRIPTA_BA
(paren
id|np
comma
id|clrack
)paren
)paren
suffix:semicolon
macro_line|#endif
r_else
id|OUTL_DSP
(paren
id|SCRIPTA_BA
(paren
id|np
comma
id|dispatch
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
id|reset_all
suffix:colon
id|sym_start_reset
c_func
(paren
id|np
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *  chip exception handler for phase errors.&n; *&n; *  We have to construct a new transfer descriptor,&n; *  to transfer the rest of the current block.&n; */
DECL|function|sym_int_ma
r_static
r_void
id|sym_int_ma
(paren
id|hcb_p
id|np
)paren
(brace
id|u32
id|dbc
suffix:semicolon
id|u32
id|rest
suffix:semicolon
id|u32
id|dsp
suffix:semicolon
id|u32
id|dsa
suffix:semicolon
id|u32
id|nxtdsp
suffix:semicolon
id|u32
op_star
id|vdsp
suffix:semicolon
id|u32
id|oadr
comma
id|olen
suffix:semicolon
id|u32
op_star
id|tblp
suffix:semicolon
id|u32
id|newcmd
suffix:semicolon
id|u_int
id|delta
suffix:semicolon
id|u_char
id|cmd
suffix:semicolon
id|u_char
id|hflags
comma
id|hflags0
suffix:semicolon
r_struct
id|sym_pmc
op_star
id|pm
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
id|dsp
op_assign
id|INL
(paren
id|nc_dsp
)paren
suffix:semicolon
id|dbc
op_assign
id|INL
(paren
id|nc_dbc
)paren
suffix:semicolon
id|dsa
op_assign
id|INL
(paren
id|nc_dsa
)paren
suffix:semicolon
id|cmd
op_assign
id|dbc
op_rshift
l_int|24
suffix:semicolon
id|rest
op_assign
id|dbc
op_amp
l_int|0xffffff
suffix:semicolon
id|delta
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *  locate matching cp if any.&n;&t; */
id|cp
op_assign
id|sym_ccb_from_dsa
c_func
(paren
id|np
comma
id|dsa
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Donnot take into account dma fifo and various buffers in &n;&t; *  INPUT phase since the chip flushes everything before &n;&t; *  raising the MA interrupt for interrupted INPUT phases.&n;&t; *  For DATA IN phase, we will check for the SWIDE later.&n;&t; */
r_if
c_cond
(paren
(paren
id|cmd
op_amp
l_int|7
)paren
op_ne
l_int|1
op_logical_and
(paren
id|cmd
op_amp
l_int|7
)paren
op_ne
l_int|5
)paren
(brace
id|u_char
id|ss0
comma
id|ss2
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_DFBC
)paren
id|delta
op_assign
id|INW
(paren
id|nc_dfbc
)paren
suffix:semicolon
r_else
(brace
id|u32
id|dfifo
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Read DFIFO, CTEST[4-6] using 1 PCI bus ownership.&n;&t;&t;&t; */
id|dfifo
op_assign
id|INL
c_func
(paren
id|nc_dfifo
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *  Calculate remaining bytes in DMA fifo.&n;&t;&t;&t; *  (CTEST5 = dfifo &gt;&gt; 16)&n;&t;&t;&t; */
r_if
c_cond
(paren
id|dfifo
op_amp
(paren
id|DFS
op_lshift
l_int|16
)paren
)paren
id|delta
op_assign
(paren
(paren
(paren
(paren
id|dfifo
op_rshift
l_int|8
)paren
op_amp
l_int|0x300
)paren
op_or
(paren
id|dfifo
op_amp
l_int|0xff
)paren
)paren
op_minus
id|rest
)paren
op_amp
l_int|0x3ff
suffix:semicolon
r_else
id|delta
op_assign
(paren
(paren
id|dfifo
op_amp
l_int|0xff
)paren
op_minus
id|rest
)paren
op_amp
l_int|0x7f
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  The data in the dma fifo has not been transfered to&n;&t;&t; *  the target -&gt; add the amount to the rest&n;&t;&t; *  and clear the data.&n;&t;&t; *  Check the sstat2 register in case of wide transfer.&n;&t;&t; */
id|rest
op_add_assign
id|delta
suffix:semicolon
id|ss0
op_assign
id|INB
(paren
id|nc_sstat0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ss0
op_amp
id|OLF
)paren
id|rest
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|np-&gt;features
op_amp
id|FE_C10
)paren
)paren
r_if
c_cond
(paren
id|ss0
op_amp
id|ORF
)paren
id|rest
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cp
op_logical_and
(paren
id|cp-&gt;phys.select.sel_scntl3
op_amp
id|EWS
)paren
)paren
(brace
id|ss2
op_assign
id|INB
(paren
id|nc_sstat2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ss2
op_amp
id|OLF1
)paren
id|rest
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|np-&gt;features
op_amp
id|FE_C10
)paren
)paren
r_if
c_cond
(paren
id|ss2
op_amp
id|ORF1
)paren
id|rest
op_increment
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Clear fifos.&n;&t;&t; */
id|OUTB
(paren
id|nc_ctest3
comma
id|np-&gt;rv_ctest3
op_or
id|CLF
)paren
suffix:semicolon
multiline_comment|/* dma fifo  */
id|OUTB
(paren
id|nc_stest3
comma
id|TE
op_or
id|CSF
)paren
suffix:semicolon
multiline_comment|/* scsi fifo */
)brace
multiline_comment|/*&n;&t; *  log the information&n;&t; */
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
(paren
id|DEBUG_TINY
op_or
id|DEBUG_PHASE
)paren
)paren
id|printf
(paren
l_string|&quot;P%x%x RL=%d D=%d &quot;
comma
id|cmd
op_amp
l_int|7
comma
id|INB
c_func
(paren
id|nc_sbcl
)paren
op_amp
l_int|7
comma
(paren
r_int
)paren
id|rest
comma
(paren
r_int
)paren
id|delta
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  try to find the interrupted script command,&n;&t; *  and the address at which to continue.&n;&t; */
id|vdsp
op_assign
l_int|0
suffix:semicolon
id|nxtdsp
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dsp
OG
id|np-&gt;scripta_ba
op_logical_and
id|dsp
op_le
id|np-&gt;scripta_ba
op_plus
id|np-&gt;scripta_sz
)paren
(brace
id|vdsp
op_assign
(paren
id|u32
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|np-&gt;scripta0
op_plus
(paren
id|dsp
op_minus
id|np-&gt;scripta_ba
op_minus
l_int|8
)paren
)paren
suffix:semicolon
id|nxtdsp
op_assign
id|dsp
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dsp
OG
id|np-&gt;scriptb_ba
op_logical_and
id|dsp
op_le
id|np-&gt;scriptb_ba
op_plus
id|np-&gt;scriptb_sz
)paren
(brace
id|vdsp
op_assign
(paren
id|u32
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|np-&gt;scriptb0
op_plus
(paren
id|dsp
op_minus
id|np-&gt;scriptb_ba
op_minus
l_int|8
)paren
)paren
suffix:semicolon
id|nxtdsp
op_assign
id|dsp
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  log the information&n;&t; */
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_PHASE
)paren
(brace
id|printf
(paren
l_string|&quot;&bslash;nCP=%p DSP=%x NXT=%x VDSP=%p CMD=%x &quot;
comma
id|cp
comma
(paren
r_int
)paren
id|dsp
comma
(paren
r_int
)paren
id|nxtdsp
comma
id|vdsp
comma
id|cmd
)paren
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vdsp
)paren
(brace
id|printf
(paren
l_string|&quot;%s: interrupted SCRIPT address not found.&bslash;n&quot;
comma
id|sym_name
(paren
id|np
)paren
)paren
suffix:semicolon
r_goto
id|reset_all
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
(brace
id|printf
(paren
l_string|&quot;%s: SCSI phase error fixup: CCB already dequeued.&bslash;n&quot;
comma
id|sym_name
(paren
id|np
)paren
)paren
suffix:semicolon
r_goto
id|reset_all
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  get old startaddress and old length.&n;&t; */
id|oadr
op_assign
id|scr_to_cpu
c_func
(paren
id|vdsp
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_amp
l_int|0x10
)paren
(brace
multiline_comment|/* Table indirect */
id|tblp
op_assign
(paren
id|u32
op_star
)paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|cp-&gt;phys
op_plus
id|oadr
)paren
suffix:semicolon
id|olen
op_assign
id|scr_to_cpu
c_func
(paren
id|tblp
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|oadr
op_assign
id|scr_to_cpu
c_func
(paren
id|tblp
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|tblp
op_assign
(paren
id|u32
op_star
)paren
l_int|0
suffix:semicolon
id|olen
op_assign
id|scr_to_cpu
c_func
(paren
id|vdsp
(braket
l_int|0
)braket
)paren
op_amp
l_int|0xffffff
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_PHASE
)paren
(brace
id|printf
(paren
l_string|&quot;OCMD=%x&bslash;nTBLP=%p OLEN=%x OADR=%x&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|scr_to_cpu
c_func
(paren
id|vdsp
(braket
l_int|0
)braket
)paren
op_rshift
l_int|24
)paren
comma
id|tblp
comma
(paren
r_int
)paren
id|olen
comma
(paren
r_int
)paren
id|oadr
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t; *  check cmd against assumed interrupted script command.&n;&t; *  If dt data phase, the MOVE instruction hasn&squot;t bit 4 of &n;&t; *  the phase.&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|cmd
op_amp
l_int|2
)paren
ques
c_cond
id|cmd
suffix:colon
(paren
id|cmd
op_amp
op_complement
l_int|4
)paren
)paren
op_ne
(paren
id|scr_to_cpu
c_func
(paren
id|vdsp
(braket
l_int|0
)braket
)paren
op_rshift
l_int|24
)paren
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;internal error: cmd=%02x != %02x=(vdsp[0] &gt;&gt; 24)&bslash;n&quot;
comma
(paren
r_int
)paren
id|cmd
comma
(paren
r_int
)paren
id|scr_to_cpu
c_func
(paren
id|vdsp
(braket
l_int|0
)braket
)paren
op_rshift
l_int|24
)paren
suffix:semicolon
r_goto
id|reset_all
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t; *  if old phase not dataphase, leave here.&n;&t; */
r_if
c_cond
(paren
id|cmd
op_amp
l_int|2
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;phase change %x-%x %d@%08x resid=%d.&bslash;n&quot;
comma
id|cmd
op_amp
l_int|7
comma
id|INB
c_func
(paren
id|nc_sbcl
)paren
op_amp
l_int|7
comma
(paren
r_int
)paren
id|olen
comma
(paren
r_int
)paren
id|oadr
comma
(paren
r_int
)paren
id|rest
)paren
suffix:semicolon
r_goto
id|unexpected_phase
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t; *  Choose the correct PM save area.&n;&t; *&n;&t; *  Look at the PM_SAVE SCRIPT if you want to understand &n;&t; *  this stuff. The equivalent code is implemented in &n;&t; *  SCRIPTS for the 895A, 896 and 1010 that are able to &n;&t; *  handle PM from the SCRIPTS processor.&n;&t; */
id|hflags0
op_assign
id|INB
(paren
id|HF_PRT
)paren
suffix:semicolon
id|hflags
op_assign
id|hflags0
suffix:semicolon
r_if
c_cond
(paren
id|hflags
op_amp
(paren
id|HF_IN_PM0
op_or
id|HF_IN_PM1
op_or
id|HF_DP_SAVED
)paren
)paren
(brace
r_if
c_cond
(paren
id|hflags
op_amp
id|HF_IN_PM0
)paren
id|nxtdsp
op_assign
id|scr_to_cpu
c_func
(paren
id|cp-&gt;phys.pm0.ret
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|hflags
op_amp
id|HF_IN_PM1
)paren
id|nxtdsp
op_assign
id|scr_to_cpu
c_func
(paren
id|cp-&gt;phys.pm1.ret
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hflags
op_amp
id|HF_DP_SAVED
)paren
id|hflags
op_xor_assign
id|HF_ACT_PM
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|hflags
op_amp
id|HF_ACT_PM
)paren
)paren
(brace
id|pm
op_assign
op_amp
id|cp-&gt;phys.pm0
suffix:semicolon
id|newcmd
op_assign
id|SCRIPTA_BA
(paren
id|np
comma
id|pm0_data
)paren
suffix:semicolon
)brace
r_else
(brace
id|pm
op_assign
op_amp
id|cp-&gt;phys.pm1
suffix:semicolon
id|newcmd
op_assign
id|SCRIPTA_BA
(paren
id|np
comma
id|pm1_data
)paren
suffix:semicolon
)brace
id|hflags
op_and_assign
op_complement
(paren
id|HF_IN_PM0
op_or
id|HF_IN_PM1
op_or
id|HF_DP_SAVED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hflags
op_ne
id|hflags0
)paren
id|OUTB
(paren
id|HF_PRT
comma
id|hflags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  fillin the phase mismatch context&n;&t; */
id|pm-&gt;sg.addr
op_assign
id|cpu_to_scr
c_func
(paren
id|oadr
op_plus
id|olen
op_minus
id|rest
)paren
suffix:semicolon
id|pm-&gt;sg.size
op_assign
id|cpu_to_scr
c_func
(paren
id|rest
)paren
suffix:semicolon
id|pm-&gt;ret
op_assign
id|cpu_to_scr
c_func
(paren
id|nxtdsp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  If we have a SWIDE,&n;&t; *  - prepare the address to write the SWIDE from SCRIPTS,&n;&t; *  - compute the SCRIPTS address to restart from,&n;&t; *  - move current data pointer context by one byte.&n;&t; */
id|nxtdsp
op_assign
id|SCRIPTA_BA
(paren
id|np
comma
id|dispatch
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmd
op_amp
l_int|7
)paren
op_eq
l_int|1
op_logical_and
id|cp
op_logical_and
(paren
id|cp-&gt;phys.select.sel_scntl3
op_amp
id|EWS
)paren
op_logical_and
(paren
id|INB
(paren
id|nc_scntl2
)paren
op_amp
id|WSR
)paren
)paren
(brace
id|u32
id|tmp
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Set up the table indirect for the MOVE&n;&t;&t; *  of the residual byte and adjust the data &n;&t;&t; *  pointer context.&n;&t;&t; */
id|tmp
op_assign
id|scr_to_cpu
c_func
(paren
id|pm-&gt;sg.addr
)paren
suffix:semicolon
id|cp-&gt;phys.wresid.addr
op_assign
id|cpu_to_scr
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|pm-&gt;sg.addr
op_assign
id|cpu_to_scr
c_func
(paren
id|tmp
op_plus
l_int|1
)paren
suffix:semicolon
id|tmp
op_assign
id|scr_to_cpu
c_func
(paren
id|pm-&gt;sg.size
)paren
suffix:semicolon
id|cp-&gt;phys.wresid.size
op_assign
id|cpu_to_scr
c_func
(paren
(paren
id|tmp
op_amp
l_int|0xff000000
)paren
op_or
l_int|1
)paren
suffix:semicolon
id|pm-&gt;sg.size
op_assign
id|cpu_to_scr
c_func
(paren
id|tmp
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  If only the residual byte is to be moved, &n;&t;&t; *  no PM context is needed.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|tmp
op_amp
l_int|0xffffff
)paren
op_eq
l_int|1
)paren
id|newcmd
op_assign
id|pm-&gt;ret
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Prepare the address of SCRIPTS that will &n;&t;&t; *  move the residual byte to memory.&n;&t;&t; */
id|nxtdsp
op_assign
id|SCRIPTB_BA
(paren
id|np
comma
id|wsr_ma_helper
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_PHASE
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;PM %x %x %x / %x %x %x.&bslash;n&quot;
comma
id|hflags0
comma
id|hflags
comma
id|newcmd
comma
(paren
r_int
)paren
id|scr_to_cpu
c_func
(paren
id|pm-&gt;sg.addr
)paren
comma
(paren
r_int
)paren
id|scr_to_cpu
c_func
(paren
id|pm-&gt;sg.size
)paren
comma
(paren
r_int
)paren
id|scr_to_cpu
c_func
(paren
id|pm-&gt;ret
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Restart the SCRIPTS processor.&n;&t; */
id|sym_set_script_dp
(paren
id|np
comma
id|cp
comma
id|newcmd
)paren
suffix:semicolon
id|OUTL_DSP
(paren
id|nxtdsp
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/*&n;&t; *  Unexpected phase changes that occurs when the current phase &n;&t; *  is not a DATA IN or DATA OUT phase are due to error conditions.&n;&t; *  Such event may only happen when the SCRIPTS is using a &n;&t; *  multibyte SCSI MOVE.&n;&t; *&n;&t; *  Phase change&t;&t;Some possible cause&n;&t; *&n;&t; *  COMMAND  --&gt; MSG IN&t;SCSI parity error detected by target.&n;&t; *  COMMAND  --&gt; STATUS&t;Bad command or refused by target.&n;&t; *  MSG OUT  --&gt; MSG IN     Message rejected by target.&n;&t; *  MSG OUT  --&gt; COMMAND    Bogus target that discards extended&n;&t; *  &t;&t;&t;negotiation messages.&n;&t; *&n;&t; *  The code below does not care of the new phase and so &n;&t; *  trusts the target. Why to annoy it ?&n;&t; *  If the interrupted phase is COMMAND phase, we restart at&n;&t; *  dispatcher.&n;&t; *  If a target does not get all the messages after selection, &n;&t; *  the code assumes blindly that the target discards extended &n;&t; *  messages and clears the negotiation status.&n;&t; *  If the target does not want all our response to negotiation,&n;&t; *  we force a SIR_NEGO_PROTO interrupt (it is a hack that avoids &n;&t; *  bloat for such a should_not_happen situation).&n;&t; *  In all other situation, we reset the BUS.&n;&t; *  Are these assumptions reasonnable ? (Wait and see ...)&n;&t; */
id|unexpected_phase
suffix:colon
id|dsp
op_sub_assign
l_int|8
suffix:semicolon
id|nxtdsp
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
op_amp
l_int|7
)paren
(brace
r_case
l_int|2
suffix:colon
multiline_comment|/* COMMAND phase */
id|nxtdsp
op_assign
id|SCRIPTA_BA
(paren
id|np
comma
id|dispatch
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#if 0
r_case
l_int|3
suffix:colon
multiline_comment|/* STATUS  phase */
id|nxtdsp
op_assign
id|SCRIPTA_BA
(paren
id|np
comma
id|dispatch
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_case
l_int|6
suffix:colon
multiline_comment|/* MSG OUT phase */
multiline_comment|/*&n;&t;&t; *  If the device may want to use untagged when we want &n;&t;&t; *  tagged, we prepare an IDENTIFY without disc. granted, &n;&t;&t; *  since we will not be able to handle reselect.&n;&t;&t; *  Otherwise, we just don&squot;t care.&n;&t;&t; */
r_if
c_cond
(paren
id|dsp
op_eq
id|SCRIPTA_BA
(paren
id|np
comma
id|send_ident
)paren
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;tag
op_ne
id|NO_TAG
op_logical_and
id|olen
op_minus
id|rest
op_le
l_int|3
)paren
(brace
id|cp-&gt;host_status
op_assign
id|HS_BUSY
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_IDENTIFY
op_or
id|cp-&gt;lun
suffix:semicolon
id|nxtdsp
op_assign
id|SCRIPTB_BA
(paren
id|np
comma
id|ident_break_atn
)paren
suffix:semicolon
)brace
r_else
id|nxtdsp
op_assign
id|SCRIPTB_BA
(paren
id|np
comma
id|ident_break
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dsp
op_eq
id|SCRIPTB_BA
(paren
id|np
comma
id|send_wdtr
)paren
op_logical_or
id|dsp
op_eq
id|SCRIPTB_BA
(paren
id|np
comma
id|send_sdtr
)paren
op_logical_or
id|dsp
op_eq
id|SCRIPTB_BA
(paren
id|np
comma
id|send_ppr
)paren
)paren
(brace
id|nxtdsp
op_assign
id|SCRIPTB_BA
(paren
id|np
comma
id|nego_bad_phase
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
macro_line|#if 0
r_case
l_int|7
suffix:colon
multiline_comment|/* MSG IN  phase */
id|nxtdsp
op_assign
id|SCRIPTA_BA
(paren
id|np
comma
id|clrack
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|nxtdsp
)paren
(brace
id|OUTL_DSP
(paren
id|nxtdsp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|reset_all
suffix:colon
id|sym_start_reset
c_func
(paren
id|np
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  chip interrupt handler&n; *&n; *  In normal situations, interrupt conditions occur one at &n; *  a time. But when something bad happens on the SCSI BUS, &n; *  the chip may raise several interrupt flags before &n; *  stopping and interrupting the CPU. The additionnal &n; *  interrupt flags are stacked in some extra registers &n; *  after the SIP and/or DIP flag has been raised in the &n; *  ISTAT. After the CPU has read the interrupt condition &n; *  flag from SIST or DSTAT, the chip unstacks the other &n; *  interrupt flags and sets the corresponding bits in &n; *  SIST or DSTAT. Since the chip starts stacking once the &n; *  SIP or DIP flag is set, there is a small window of time &n; *  where the stacking does not occur.&n; *&n; *  Typically, multiple interrupt conditions may happen in &n; *  the following situations:&n; *&n; *  - SCSI parity error + Phase mismatch  (PAR|MA)&n; *    When an parity error is detected in input phase &n; *    and the device switches to msg-in phase inside a &n; *    block MOV.&n; *  - SCSI parity error + Unexpected disconnect (PAR|UDC)&n; *    When a stupid device does not want to handle the &n; *    recovery of an SCSI parity error.&n; *  - Some combinations of STO, PAR, UDC, ...&n; *    When using non compliant SCSI stuff, when user is &n; *    doing non compliant hot tampering on the BUS, when &n; *    something really bad happens to a device, etc ...&n; *&n; *  The heuristic suggested by SYMBIOS to handle &n; *  multiple interrupts is to try unstacking all &n; *  interrupts conditions and to handle them on some &n; *  priority based on error severity.&n; *  This will work when the unstacking has been &n; *  successful, but we cannot be 100 % sure of that, &n; *  since the CPU may have been faster to unstack than &n; *  the chip is able to stack. Hmmm ... But it seems that &n; *  such a situation is very unlikely to happen.&n; *&n; *  If this happen, for example STO caught by the CPU &n; *  then UDC happenning before the CPU have restarted &n; *  the SCRIPTS, the driver may wrongly complete the &n; *  same command on UDC, since the SCRIPTS didn&squot;t restart &n; *  and the DSA still points to the same command.&n; *  We avoid this situation by setting the DSA to an &n; *  invalid value when the CCB is completed and before &n; *  restarting the SCRIPTS.&n; *&n; *  Another issue is that we need some section of our &n; *  recovery procedures to be somehow uninterruptible but &n; *  the SCRIPTS processor does not provides such a &n; *  feature. For this reason, we handle recovery preferently &n; *  from the C code and check against some SCRIPTS critical &n; *  sections from the C code.&n; *&n; *  Hopefully, the interrupt handling of the driver is now &n; *  able to resist to weird BUS error conditions, but donnot &n; *  ask me for any guarantee that it will never fail. :-)&n; *  Use at your own decision and risk.&n; */
DECL|function|sym_interrupt
r_void
id|sym_interrupt
(paren
id|hcb_p
id|np
)paren
(brace
id|u_char
id|istat
comma
id|istatc
suffix:semicolon
id|u_char
id|dstat
suffix:semicolon
id|u_short
id|sist
suffix:semicolon
multiline_comment|/*&n;&t; *  interrupt on the fly ?&n;&t; *  (SCRIPTS may still be running)&n;&t; *&n;&t; *  A `dummy read&squot; is needed to ensure that the &n;&t; *  clear of the INTF flag reaches the device &n;&t; *  and that posted writes are flushed to memory&n;&t; *  before the scanning of the DONE queue.&n;&t; *  Note that SCRIPTS also (dummy) read to memory &n;&t; *  prior to deliver the INTF interrupt condition.&n;&t; */
id|istat
op_assign
id|INB
(paren
id|nc_istat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|istat
op_amp
id|INTF
)paren
(brace
id|OUTB
(paren
id|nc_istat
comma
(paren
id|istat
op_amp
id|SIGP
)paren
op_or
id|INTF
op_or
id|np-&gt;istat_sem
)paren
suffix:semicolon
id|istat
op_assign
id|INB
(paren
id|nc_istat
)paren
suffix:semicolon
multiline_comment|/* DUMMY READ */
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printf
(paren
l_string|&quot;F &quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|sym_wakeup_done
(paren
id|np
)paren
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|istat
op_amp
(paren
id|SIP
op_or
id|DIP
)paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#if 0&t;/* We should never get this one */
r_if
c_cond
(paren
id|istat
op_amp
id|CABRT
)paren
id|OUTB
(paren
id|nc_istat
comma
id|CABRT
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *  PAR and MA interrupts may occur at the same time,&n;&t; *  and we need to know of both in order to handle &n;&t; *  this situation properly. We try to unstack SCSI &n;&t; *  interrupts for that reason. BTW, I dislike a LOT &n;&t; *  such a loop inside the interrupt routine.&n;&t; *  Even if DMA interrupt stacking is very unlikely to &n;&t; *  happen, we also try unstacking these ones, since &n;&t; *  this has no performance impact.&n;&t; */
id|sist
op_assign
l_int|0
suffix:semicolon
id|dstat
op_assign
l_int|0
suffix:semicolon
id|istatc
op_assign
id|istat
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|istatc
op_amp
id|SIP
)paren
id|sist
op_or_assign
id|INW
(paren
id|nc_sist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|istatc
op_amp
id|DIP
)paren
id|dstat
op_or_assign
id|INB
(paren
id|nc_dstat
)paren
suffix:semicolon
id|istatc
op_assign
id|INB
(paren
id|nc_istat
)paren
suffix:semicolon
id|istat
op_or_assign
id|istatc
suffix:semicolon
)brace
r_while
c_loop
(paren
id|istatc
op_amp
(paren
id|SIP
op_or
id|DIP
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printf
(paren
l_string|&quot;&lt;%d|%x:%x|%x:%x&gt;&quot;
comma
(paren
r_int
)paren
id|INB
c_func
(paren
id|nc_scr0
)paren
comma
id|dstat
comma
id|sist
comma
(paren
r_int
)paren
id|INL
c_func
(paren
id|nc_dsp
)paren
comma
(paren
r_int
)paren
id|INL
c_func
(paren
id|nc_dbc
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  On paper, a memory read barrier may be needed here to &n;&t; *  prevent out of order LOADs by the CPU from having &n;&t; *  prefetched stale data prior to DMA having occurred.&n;&t; *  And since we are paranoid ... :)&n;&t; */
id|MEMORY_READ_BARRIER
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  First, interrupts we want to service cleanly.&n;&t; *&n;&t; *  Phase mismatch (MA) is the most frequent interrupt &n;&t; *  for chip earlier than the 896 and so we have to service &n;&t; *  it as quickly as possible.&n;&t; *  A SCSI parity error (PAR) may be combined with a phase &n;&t; *  mismatch condition (MA).&n;&t; *  Programmed interrupts (SIR) are used to call the C code &n;&t; *  from SCRIPTS.&n;&t; *  The single step interrupt (SSI) is not used in this &n;&t; *  driver.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|sist
op_amp
(paren
id|STO
op_or
id|GEN
op_or
id|HTH
op_or
id|SGE
op_or
id|UDC
op_or
id|SBMC
op_or
id|RST
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|dstat
op_amp
(paren
id|MDPE
op_or
id|BF
op_or
id|ABRT
op_or
id|IID
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|sist
op_amp
id|PAR
)paren
id|sym_int_par
(paren
id|np
comma
id|sist
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sist
op_amp
id|MA
)paren
id|sym_int_ma
(paren
id|np
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dstat
op_amp
id|SIR
)paren
id|sym_int_sir
(paren
id|np
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dstat
op_amp
id|SSI
)paren
id|OUTONB_STD
(paren
)paren
suffix:semicolon
r_else
r_goto
id|unknown_int
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t; *  Now, interrupts that donnot happen in normal &n;&t; *  situations and that we may need to recover from.&n;&t; *&n;&t; *  On SCSI RESET (RST), we reset everything.&n;&t; *  On SCSI BUS MODE CHANGE (SBMC), we complete all &n;&t; *  active CCBs with RESET status, prepare all devices &n;&t; *  for negotiating again and restart the SCRIPTS.&n;&t; *  On STO and UDC, we complete the CCB with the corres- &n;&t; *  ponding status and restart the SCRIPTS.&n;&t; */
r_if
c_cond
(paren
id|sist
op_amp
id|RST
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: SCSI BUS reset detected.&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
id|sym_start_up
(paren
id|np
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
id|OUTB
(paren
id|nc_ctest3
comma
id|np-&gt;rv_ctest3
op_or
id|CLF
)paren
suffix:semicolon
multiline_comment|/* clear dma fifo  */
id|OUTB
(paren
id|nc_stest3
comma
id|TE
op_or
id|CSF
)paren
suffix:semicolon
multiline_comment|/* clear scsi fifo */
r_if
c_cond
(paren
op_logical_neg
(paren
id|sist
op_amp
(paren
id|GEN
op_or
id|HTH
op_or
id|SGE
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|dstat
op_amp
(paren
id|MDPE
op_or
id|BF
op_or
id|ABRT
op_or
id|IID
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|sist
op_amp
id|SBMC
)paren
id|sym_int_sbmc
(paren
id|np
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sist
op_amp
id|STO
)paren
id|sym_int_sto
(paren
id|np
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sist
op_amp
id|UDC
)paren
id|sym_int_udc
(paren
id|np
)paren
suffix:semicolon
r_else
r_goto
id|unknown_int
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t; *  Now, interrupts we are not able to recover cleanly.&n;&t; *&n;&t; *  Log message for hard errors.&n;&t; *  Reset everything.&n;&t; */
id|sym_log_hard_error
c_func
(paren
id|np
comma
id|sist
comma
id|dstat
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sist
op_amp
(paren
id|GEN
op_or
id|HTH
op_or
id|SGE
)paren
)paren
op_logical_or
(paren
id|dstat
op_amp
(paren
id|MDPE
op_or
id|BF
op_or
id|ABRT
op_or
id|IID
)paren
)paren
)paren
(brace
id|sym_start_reset
c_func
(paren
id|np
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
id|unknown_int
suffix:colon
multiline_comment|/*&n;&t; *  We just miss the cause of the interrupt. :(&n;&t; *  Print a message. The timeout will do the real work.&n;&t; */
id|printf
c_func
(paren
l_string|&quot;%s: unknown interrupt(s) ignored, &quot;
l_string|&quot;ISTAT=0x%x DSTAT=0x%x SIST=0x%x&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
comma
id|istat
comma
id|dstat
comma
id|sist
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Dequeue from the START queue all CCBs that match &n; *  a given target/lun/task condition (-1 means all),&n; *  and move them from the BUSY queue to the COMP queue &n; *  with CAM_REQUEUE_REQ status condition.&n; *  This function is used during error handling/recovery.&n; *  It is called with SCRIPTS not running.&n; */
r_static
r_int
DECL|function|sym_dequeue_from_squeue
id|sym_dequeue_from_squeue
c_func
(paren
id|hcb_p
id|np
comma
r_int
id|i
comma
r_int
id|target
comma
r_int
id|lun
comma
r_int
id|task
)paren
(brace
r_int
id|j
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
multiline_comment|/*&n;&t; *  Make sure the starting index is within range.&n;&t; */
m_assert
(paren
(paren
id|i
op_ge
l_int|0
)paren
op_logical_and
(paren
id|i
OL
l_int|2
op_star
id|MAX_QUEUE
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Walk until end of START queue and dequeue every job &n;&t; *  that matches the target/lun/task condition.&n;&t; */
id|j
op_assign
id|i
suffix:semicolon
r_while
c_loop
(paren
id|i
op_ne
id|np-&gt;squeueput
)paren
(brace
id|cp
op_assign
id|sym_ccb_from_dsa
c_func
(paren
id|np
comma
id|scr_to_cpu
c_func
(paren
id|np-&gt;squeue
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
m_assert
(paren
id|cp
)paren
suffix:semicolon
macro_line|#ifdef SYM_CONF_IARB_SUPPORT
multiline_comment|/* Forget hints for IARB, they may be no longer relevant */
id|cp-&gt;host_flags
op_and_assign
op_complement
id|HF_HINT_IARB
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|target
op_eq
op_minus
l_int|1
op_logical_or
id|cp-&gt;target
op_eq
id|target
)paren
op_logical_and
(paren
id|lun
op_eq
op_minus
l_int|1
op_logical_or
id|cp-&gt;lun
op_eq
id|lun
)paren
op_logical_and
(paren
id|task
op_eq
op_minus
l_int|1
op_logical_or
id|cp-&gt;tag
op_eq
id|task
)paren
)paren
(brace
id|sym_set_cam_status
c_func
(paren
id|cp-&gt;cam_ccb
comma
id|CAM_REQUEUE_REQ
)paren
suffix:semicolon
id|sym_remque
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
)paren
suffix:semicolon
id|sym_insque_tail
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
comma
op_amp
id|np-&gt;comp_ccbq
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|i
op_ne
id|j
)paren
id|np-&gt;squeue
(braket
id|j
)braket
op_assign
id|np-&gt;squeue
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|j
op_add_assign
l_int|2
)paren
op_ge
id|MAX_QUEUE
op_star
l_int|2
)paren
id|j
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|i
op_add_assign
l_int|2
)paren
op_ge
id|MAX_QUEUE
op_star
l_int|2
)paren
id|i
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_ne
id|j
)paren
multiline_comment|/* Copy back the idle task if needed */
id|np-&gt;squeue
(braket
id|j
)braket
op_assign
id|np-&gt;squeue
(braket
id|i
)braket
suffix:semicolon
id|np-&gt;squeueput
op_assign
id|j
suffix:semicolon
multiline_comment|/* Update our current start queue pointer */
r_return
(paren
id|i
op_minus
id|j
)paren
op_div
l_int|2
suffix:semicolon
)brace
multiline_comment|/*&n; *  Complete all CCBs queued to the COMP queue.&n; *&n; *  These CCBs are assumed:&n; *  - Not to be referenced either by devices or &n; *    SCRIPTS-related queues and datas.&n; *  - To have to be completed with an error condition &n; *    or requeued.&n; *&n; *  The device queue freeze count is incremented &n; *  for each CCB that does not prevent this.&n; *  This function is called when all CCBs involved &n; *  in error handling/recovery have been reaped.&n; */
DECL|function|sym_flush_comp_queue
r_void
id|sym_flush_comp_queue
c_func
(paren
id|hcb_p
id|np
comma
r_int
id|cam_status
)paren
(brace
id|SYM_QUEHEAD
op_star
id|qp
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
r_while
c_loop
(paren
(paren
id|qp
op_assign
id|sym_remque_head
c_func
(paren
op_amp
id|np-&gt;comp_ccbq
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|cam_ccb_p
id|ccb
suffix:semicolon
id|cp
op_assign
id|sym_que_entry
c_func
(paren
id|qp
comma
r_struct
id|sym_ccb
comma
id|link_ccbq
)paren
suffix:semicolon
id|sym_insque_tail
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
comma
op_amp
id|np-&gt;busy_ccbq
)paren
suffix:semicolon
multiline_comment|/* Leave quiet CCBs waiting for resources */
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_WAIT
)paren
r_continue
suffix:semicolon
id|ccb
op_assign
id|cp-&gt;cam_ccb
suffix:semicolon
r_if
c_cond
(paren
id|cam_status
)paren
id|sym_set_cam_status
c_func
(paren
id|ccb
comma
id|cam_status
)paren
suffix:semicolon
macro_line|#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING
r_if
c_cond
(paren
id|sym_get_cam_status
c_func
(paren
id|ccb
)paren
op_eq
id|CAM_REQUEUE_REQ
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|cp-&gt;target
)braket
suffix:semicolon
id|lcb_p
id|lp
op_assign
id|sym_lp
c_func
(paren
id|np
comma
id|tp
comma
id|cp-&gt;lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp
)paren
(brace
id|sym_remque
c_func
(paren
op_amp
id|cp-&gt;link2_ccbq
)paren
suffix:semicolon
id|sym_insque_tail
c_func
(paren
op_amp
id|cp-&gt;link2_ccbq
comma
op_amp
id|lp-&gt;waiting_ccbq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;started
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;tag
op_ne
id|NO_TAG
)paren
op_decrement
id|lp-&gt;started_tags
suffix:semicolon
r_else
op_decrement
id|lp-&gt;started_no_tag
suffix:semicolon
)brace
)brace
id|cp-&gt;started
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
macro_line|#endif
id|sym_free_ccb
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
id|sym_freeze_cam_ccb
c_func
(paren
id|ccb
)paren
suffix:semicolon
id|sym_xpt_done
c_func
(paren
id|np
comma
id|ccb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *  chip handler for bad SCSI status condition&n; *&n; *  In case of bad SCSI status, we unqueue all the tasks &n; *  currently queued to the controller but not yet started &n; *  and then restart the SCRIPTS processor immediately.&n; *&n; *  QUEUE FULL and BUSY conditions are handled the same way.&n; *  Basically all the not yet started tasks are requeued in &n; *  device queue and the queue is frozen until a completion.&n; *&n; *  For CHECK CONDITION and COMMAND TERMINATED status, we use &n; *  the CCB of the failed command to prepare a REQUEST SENSE &n; *  SCSI command and queue it to the controller queue.&n; *&n; *  SCRATCHA is assumed to have been loaded with STARTPOS &n; *  before the SCRIPTS called the C code.&n; */
DECL|function|sym_sir_bad_scsi_status
r_static
r_void
id|sym_sir_bad_scsi_status
c_func
(paren
id|hcb_p
id|np
comma
r_int
id|num
comma
id|ccb_p
id|cp
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|cp-&gt;target
)braket
suffix:semicolon
id|u32
id|startp
suffix:semicolon
id|u_char
id|s_status
op_assign
id|cp-&gt;ssss_status
suffix:semicolon
id|u_char
id|h_flags
op_assign
id|cp-&gt;host_flags
suffix:semicolon
r_int
id|msglen
suffix:semicolon
r_int
id|nego
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; *  Compute the index of the next job to start from SCRIPTS.&n;&t; */
id|i
op_assign
(paren
id|INL
(paren
id|nc_scratcha
)paren
op_minus
id|np-&gt;squeue_ba
)paren
op_div
l_int|4
suffix:semicolon
multiline_comment|/*&n;&t; *  The last CCB queued used for IARB hint may be &n;&t; *  no longer relevant. Forget it.&n;&t; */
macro_line|#ifdef SYM_CONF_IARB_SUPPORT
r_if
c_cond
(paren
id|np-&gt;last_cp
)paren
id|np-&gt;last_cp
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *  Now deal with the SCSI status.&n;&t; */
r_switch
c_cond
(paren
id|s_status
)paren
(brace
r_case
id|S_BUSY
suffix:colon
r_case
id|S_QUEUE_FULL
suffix:colon
r_if
c_cond
(paren
id|sym_verbose
op_ge
l_int|2
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|s_status
op_eq
id|S_BUSY
ques
c_cond
l_string|&quot;BUSY&quot;
suffix:colon
l_string|&quot;QUEUE FULL&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_default
suffix:colon
multiline_comment|/* S_INT, S_INT_COND_MET, S_CONFLICT */
id|sym_complete_error
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_TERMINATED
suffix:colon
r_case
id|S_CHECK_COND
suffix:colon
multiline_comment|/*&n;&t;&t; *  If we get an SCSI error when requesting sense, give up.&n;&t;&t; */
r_if
c_cond
(paren
id|h_flags
op_amp
id|HF_SENSE
)paren
(brace
id|sym_complete_error
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  Dequeue all queued CCBs for that device not yet started,&n;&t;&t; *  and restart the SCRIPTS processor immediately.&n;&t;&t; */
(paren
r_void
)paren
id|sym_dequeue_from_squeue
c_func
(paren
id|np
comma
id|i
comma
id|cp-&gt;target
comma
id|cp-&gt;lun
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|OUTL_DSP
(paren
id|SCRIPTA_BA
(paren
id|np
comma
id|start
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Save some info of the actual IO.&n;&t;&t; *  Compute the data residual.&n;&t;&t; */
id|cp-&gt;sv_scsi_status
op_assign
id|cp-&gt;ssss_status
suffix:semicolon
id|cp-&gt;sv_xerr_status
op_assign
id|cp-&gt;xerr_status
suffix:semicolon
id|cp-&gt;sv_resid
op_assign
id|sym_compute_residual
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Prepare all needed data structures for &n;&t;&t; *  requesting sense data.&n;&t;&t; */
multiline_comment|/*&n;&t;&t; *  identify message&n;&t;&t; */
id|cp-&gt;scsi_smsg2
(braket
l_int|0
)braket
op_assign
id|M_IDENTIFY
op_or
id|cp-&gt;lun
suffix:semicolon
id|msglen
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  If we are currently using anything different from &n;&t;&t; *  async. 8 bit data transfers with that target,&n;&t;&t; *  start a negotiation, since the device may want &n;&t;&t; *  to report us a UNIT ATTENTION condition due to &n;&t;&t; *  a cause we currently ignore, and we donnot want &n;&t;&t; *  to be stuck with WIDE and/or SYNC data transfer.&n;&t;&t; *&n;&t;&t; *  cp-&gt;nego_status is filled by sym_prepare_nego().&n;&t;&t; */
id|cp-&gt;nego_status
op_assign
l_int|0
suffix:semicolon
id|nego
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;tinfo.curr.options
op_amp
id|PPR_OPT_MASK
)paren
id|nego
op_assign
id|NS_PPR
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tp-&gt;tinfo.curr.width
op_ne
id|BUS_8_BIT
)paren
id|nego
op_assign
id|NS_WIDE
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tp-&gt;tinfo.curr.offset
op_ne
l_int|0
)paren
id|nego
op_assign
id|NS_SYNC
suffix:semicolon
r_if
c_cond
(paren
id|nego
)paren
id|msglen
op_add_assign
id|sym_prepare_nego
(paren
id|np
comma
id|cp
comma
id|nego
comma
op_amp
id|cp-&gt;scsi_smsg2
(braket
id|msglen
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Message table indirect structure.&n;&t;&t; */
id|cp-&gt;phys.smsg.addr
op_assign
id|cpu_to_scr
c_func
(paren
id|CCB_BA
(paren
id|cp
comma
id|scsi_smsg2
)paren
)paren
suffix:semicolon
id|cp-&gt;phys.smsg.size
op_assign
id|cpu_to_scr
c_func
(paren
id|msglen
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  sense command&n;&t;&t; */
id|cp-&gt;phys.cmd.addr
op_assign
id|cpu_to_scr
c_func
(paren
id|CCB_BA
(paren
id|cp
comma
id|sensecmd
)paren
)paren
suffix:semicolon
id|cp-&gt;phys.cmd.size
op_assign
id|cpu_to_scr
c_func
(paren
l_int|6
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  patch requested size into sense command&n;&t;&t; */
id|cp-&gt;sensecmd
(braket
l_int|0
)braket
op_assign
id|REQUEST_SENSE
suffix:semicolon
id|cp-&gt;sensecmd
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;tinfo.curr.scsi_version
op_le
l_int|2
op_logical_and
id|cp-&gt;lun
op_le
l_int|7
)paren
id|cp-&gt;sensecmd
(braket
l_int|1
)braket
op_assign
id|cp-&gt;lun
op_lshift
l_int|5
suffix:semicolon
id|cp-&gt;sensecmd
(braket
l_int|4
)braket
op_assign
id|SYM_SNS_BBUF_LEN
suffix:semicolon
id|cp-&gt;data_len
op_assign
id|SYM_SNS_BBUF_LEN
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  sense data&n;&t;&t; */
id|bzero
c_func
(paren
id|cp-&gt;sns_bbuf
comma
id|SYM_SNS_BBUF_LEN
)paren
suffix:semicolon
id|cp-&gt;phys.sense.addr
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
c_func
(paren
id|cp-&gt;sns_bbuf
)paren
)paren
suffix:semicolon
id|cp-&gt;phys.sense.size
op_assign
id|cpu_to_scr
c_func
(paren
id|SYM_SNS_BBUF_LEN
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  requeue the command.&n;&t;&t; */
id|startp
op_assign
id|SCRIPTB_BA
(paren
id|np
comma
id|sdata_in
)paren
suffix:semicolon
id|cp-&gt;phys.head.savep
op_assign
id|cpu_to_scr
c_func
(paren
id|startp
)paren
suffix:semicolon
id|cp-&gt;phys.head.lastp
op_assign
id|cpu_to_scr
c_func
(paren
id|startp
)paren
suffix:semicolon
id|cp-&gt;startp
op_assign
id|cpu_to_scr
c_func
(paren
id|startp
)paren
suffix:semicolon
id|cp-&gt;goalp
op_assign
id|cpu_to_scr
c_func
(paren
id|startp
op_plus
l_int|16
)paren
suffix:semicolon
id|cp-&gt;host_xflags
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;host_status
op_assign
id|cp-&gt;nego_status
ques
c_cond
id|HS_NEGOTIATE
suffix:colon
id|HS_BUSY
suffix:semicolon
id|cp-&gt;ssss_status
op_assign
id|S_ILLEGAL
suffix:semicolon
id|cp-&gt;host_flags
op_assign
(paren
id|HF_SENSE
op_or
id|HF_DATA_IN
)paren
suffix:semicolon
id|cp-&gt;xerr_status
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;extra_bytes
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;phys.head.go.start
op_assign
id|cpu_to_scr
c_func
(paren
id|SCRIPTA_BA
(paren
id|np
comma
id|select
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Requeue the command.&n;&t;&t; */
id|sym_put_start_queue
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Give back to upper layer everything we have dequeued.&n;&t;&t; */
id|sym_flush_comp_queue
c_func
(paren
id|np
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *  After a device has accepted some management message &n; *  as BUS DEVICE RESET, ABORT TASK, etc ..., or when &n; *  a device signals a UNIT ATTENTION condition, some &n; *  tasks are thrown away by the device. We are required &n; *  to reflect that on our tasks list since the device &n; *  will never complete these tasks.&n; *&n; *  This function move from the BUSY queue to the COMP &n; *  queue all disconnected CCBs for a given target that &n; *  match the following criteria:&n; *  - lun=-1  means any logical UNIT otherwise a given one.&n; *  - task=-1 means any task, otherwise a given one.&n; */
DECL|function|sym_clear_tasks
r_int
id|sym_clear_tasks
c_func
(paren
id|hcb_p
id|np
comma
r_int
id|cam_status
comma
r_int
id|target
comma
r_int
id|lun
comma
r_int
id|task
)paren
(brace
id|SYM_QUEHEAD
id|qtmp
comma
op_star
id|qp
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
multiline_comment|/*&n;&t; *  Move the entire BUSY queue to our temporary queue.&n;&t; */
id|sym_que_init
c_func
(paren
op_amp
id|qtmp
)paren
suffix:semicolon
id|sym_que_splice
c_func
(paren
op_amp
id|np-&gt;busy_ccbq
comma
op_amp
id|qtmp
)paren
suffix:semicolon
id|sym_que_init
c_func
(paren
op_amp
id|np-&gt;busy_ccbq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Put all CCBs that matches our criteria into &n;&t; *  the COMP queue and put back other ones into &n;&t; *  the BUSY queue.&n;&t; */
r_while
c_loop
(paren
(paren
id|qp
op_assign
id|sym_remque_head
c_func
(paren
op_amp
id|qtmp
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|cam_ccb_p
id|ccb
suffix:semicolon
id|cp
op_assign
id|sym_que_entry
c_func
(paren
id|qp
comma
r_struct
id|sym_ccb
comma
id|link_ccbq
)paren
suffix:semicolon
id|ccb
op_assign
id|cp-&gt;cam_ccb
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;host_status
op_ne
id|HS_DISCONNECT
op_logical_or
id|cp-&gt;target
op_ne
id|target
op_logical_or
(paren
id|lun
op_ne
op_minus
l_int|1
op_logical_and
id|cp-&gt;lun
op_ne
id|lun
)paren
op_logical_or
(paren
id|task
op_ne
op_minus
l_int|1
op_logical_and
(paren
id|cp-&gt;tag
op_ne
id|NO_TAG
op_logical_and
id|cp-&gt;scsi_smsg
(braket
l_int|2
)braket
op_ne
id|task
)paren
)paren
)paren
(brace
id|sym_insque_tail
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
comma
op_amp
id|np-&gt;busy_ccbq
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|sym_insque_tail
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
comma
op_amp
id|np-&gt;comp_ccbq
)paren
suffix:semicolon
multiline_comment|/* Preserve the software timeout condition */
r_if
c_cond
(paren
id|sym_get_cam_status
c_func
(paren
id|ccb
)paren
op_ne
id|CAM_CMD_TIMEOUT
)paren
id|sym_set_cam_status
c_func
(paren
id|ccb
comma
id|cam_status
)paren
suffix:semicolon
op_increment
id|i
suffix:semicolon
macro_line|#if 0
id|printf
c_func
(paren
l_string|&quot;XXXX TASK @%p CLEARED&bslash;n&quot;
comma
id|cp
)paren
suffix:semicolon
macro_line|#endif
)brace
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/*&n; *  chip handler for TASKS recovery&n; *&n; *  We cannot safely abort a command, while the SCRIPTS &n; *  processor is running, since we just would be in race &n; *  with it.&n; *&n; *  As long as we have tasks to abort, we keep the SEM &n; *  bit set in the ISTAT. When this bit is set, the &n; *  SCRIPTS processor interrupts (SIR_SCRIPT_STOPPED) &n; *  each time it enters the scheduler.&n; *&n; *  If we have to reset a target, clear tasks of a unit,&n; *  or to perform the abort of a disconnected job, we &n; *  restart the SCRIPTS for selecting the target. Once &n; *  selected, the SCRIPTS interrupts (SIR_TARGET_SELECTED).&n; *  If it loses arbitration, the SCRIPTS will interrupt again &n; *  the next time it will enter its scheduler, and so on ...&n; *&n; *  On SIR_TARGET_SELECTED, we scan for the more &n; *  appropriate thing to do:&n; *&n; *  - If nothing, we just sent a M_ABORT message to the &n; *    target to get rid of the useless SCSI bus ownership.&n; *    According to the specs, no tasks shall be affected.&n; *  - If the target is to be reset, we send it a M_RESET &n; *    message.&n; *  - If a logical UNIT is to be cleared , we send the &n; *    IDENTIFY(lun) + M_ABORT.&n; *  - If an untagged task is to be aborted, we send the &n; *    IDENTIFY(lun) + M_ABORT.&n; *  - If a tagged task is to be aborted, we send the &n; *    IDENTIFY(lun) + task attributes + M_ABORT_TAG.&n; *&n; *  Once our &squot;kiss of death&squot; :) message has been accepted &n; *  by the target, the SCRIPTS interrupts again &n; *  (SIR_ABORT_SENT). On this interrupt, we complete &n; *  all the CCBs that should have been aborted by the &n; *  target according to our message.&n; */
DECL|function|sym_sir_task_recovery
r_static
r_void
id|sym_sir_task_recovery
c_func
(paren
id|hcb_p
id|np
comma
r_int
id|num
)paren
(brace
id|SYM_QUEHEAD
op_star
id|qp
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
id|tcb_p
id|tp
suffix:semicolon
r_int
id|target
op_assign
op_minus
l_int|1
comma
id|lun
op_assign
op_minus
l_int|1
comma
id|task
suffix:semicolon
r_int
id|i
comma
id|k
suffix:semicolon
r_switch
c_cond
(paren
id|num
)paren
(brace
multiline_comment|/*&n;&t; *  The SCRIPTS processor stopped before starting&n;&t; *  the next command in order to allow us to perform &n;&t; *  some task recovery.&n;&t; */
r_case
id|SIR_SCRIPT_STOPPED
suffix:colon
multiline_comment|/*&n;&t;&t; *  Do we have any target to reset or unit to clear ?&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SYM_CONF_MAX_TARGET
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;to_reset
op_logical_or
(paren
id|tp-&gt;lun0p
op_logical_and
id|tp-&gt;lun0p-&gt;to_clear
)paren
)paren
(brace
id|target
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;lunmp
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|1
suffix:semicolon
id|k
OL
id|SYM_CONF_MAX_LUN
suffix:semicolon
id|k
op_increment
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;lunmp
(braket
id|k
)braket
op_logical_and
id|tp-&gt;lunmp
(braket
id|k
)braket
op_member_access_from_pointer
id|to_clear
)paren
(brace
id|target
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|target
op_ne
op_minus
l_int|1
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  If not, walk the busy queue for any &n;&t;&t; *  disconnected CCB to be aborted.&n;&t;&t; */
r_if
c_cond
(paren
id|target
op_eq
op_minus
l_int|1
)paren
(brace
id|FOR_EACH_QUEUED_ELEMENT
c_func
(paren
op_amp
id|np-&gt;busy_ccbq
comma
id|qp
)paren
(brace
id|cp
op_assign
id|sym_que_entry
c_func
(paren
id|qp
comma
r_struct
id|sym_ccb
comma
id|link_ccbq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;host_status
op_ne
id|HS_DISCONNECT
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;to_abort
)paren
(brace
id|target
op_assign
id|cp-&gt;target
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t; *  If some target is to be selected, &n;&t;&t; *  prepare and start the selection.&n;&t;&t; */
r_if
c_cond
(paren
id|target
op_ne
op_minus
l_int|1
)paren
(brace
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
id|np-&gt;abrt_sel.sel_id
op_assign
id|target
suffix:semicolon
id|np-&gt;abrt_sel.sel_scntl3
op_assign
id|tp-&gt;head.wval
suffix:semicolon
id|np-&gt;abrt_sel.sel_sxfer
op_assign
id|tp-&gt;head.sval
suffix:semicolon
id|OUTL
c_func
(paren
id|nc_dsa
comma
id|np-&gt;hcb_ba
)paren
suffix:semicolon
id|OUTL_DSP
(paren
id|SCRIPTB_BA
(paren
id|np
comma
id|sel_for_abort
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  Now look for a CCB to abort that haven&squot;t started yet.&n;&t;&t; *  Btw, the SCRIPTS processor is still stopped, so &n;&t;&t; *  we are not in race.&n;&t;&t; */
id|i
op_assign
l_int|0
suffix:semicolon
id|cp
op_assign
l_int|0
suffix:semicolon
id|FOR_EACH_QUEUED_ELEMENT
c_func
(paren
op_amp
id|np-&gt;busy_ccbq
comma
id|qp
)paren
(brace
id|cp
op_assign
id|sym_que_entry
c_func
(paren
id|qp
comma
r_struct
id|sym_ccb
comma
id|link_ccbq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;host_status
op_ne
id|HS_BUSY
op_logical_and
id|cp-&gt;host_status
op_ne
id|HS_NEGOTIATE
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp-&gt;to_abort
)paren
r_continue
suffix:semicolon
macro_line|#ifdef SYM_CONF_IARB_SUPPORT
multiline_comment|/*&n;&t;&t;&t; *    If we are using IMMEDIATE ARBITRATION, we donnot &n;&t;&t;&t; *    want to cancel the last queued CCB, since the &n;&t;&t;&t; *    SCRIPTS may have anticipated the selection.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|cp
op_eq
id|np-&gt;last_cp
)paren
(brace
id|cp-&gt;to_abort
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
macro_line|#endif
id|i
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Means we have found some */
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *  We are done, so we donnot need &n;&t;&t;&t; *  to synchronize with the SCRIPTS anylonger.&n;&t;&t;&t; *  Remove the SEM flag from the ISTAT.&n;&t;&t;&t; */
id|np-&gt;istat_sem
op_assign
l_int|0
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
id|SIGP
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  Compute index of next position in the start &n;&t;&t; *  queue the SCRIPTS intends to start and dequeue &n;&t;&t; *  all CCBs for that device that haven&squot;t been started.&n;&t;&t; */
id|i
op_assign
(paren
id|INL
(paren
id|nc_scratcha
)paren
op_minus
id|np-&gt;squeue_ba
)paren
op_div
l_int|4
suffix:semicolon
id|i
op_assign
id|sym_dequeue_from_squeue
c_func
(paren
id|np
comma
id|i
comma
id|cp-&gt;target
comma
id|cp-&gt;lun
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Make sure at least our IO to abort has been dequeued.&n;&t;&t; */
macro_line|#ifndef SYM_OPT_HANDLE_DEVICE_QUEUEING
m_assert
(paren
id|i
op_logical_and
id|sym_get_cam_status
c_func
(paren
id|cp-&gt;cam_ccb
)paren
op_eq
id|CAM_REQUEUE_REQ
)paren
suffix:semicolon
macro_line|#else
id|sym_remque
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
)paren
suffix:semicolon
id|sym_insque_tail
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
comma
op_amp
id|np-&gt;comp_ccbq
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t; *  Keep track in cam status of the reason of the abort.&n;&t;&t; */
r_if
c_cond
(paren
id|cp-&gt;to_abort
op_eq
l_int|2
)paren
id|sym_set_cam_status
c_func
(paren
id|cp-&gt;cam_ccb
comma
id|CAM_CMD_TIMEOUT
)paren
suffix:semicolon
r_else
id|sym_set_cam_status
c_func
(paren
id|cp-&gt;cam_ccb
comma
id|CAM_REQ_ABORTED
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Complete with error everything that we have dequeued.&n;&t; &t; */
id|sym_flush_comp_queue
c_func
(paren
id|np
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t; *  The SCRIPTS processor has selected a target &n;&t; *  we may have some manual recovery to perform for.&n;&t; */
r_case
id|SIR_TARGET_SELECTED
suffix:colon
id|target
op_assign
(paren
id|INB
(paren
id|nc_sdid
)paren
op_amp
l_int|0xf
)paren
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
id|np-&gt;abrt_tbl.addr
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
c_func
(paren
id|np-&gt;abrt_msg
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  If the target is to be reset, prepare a &n;&t;&t; *  M_RESET message and clear the to_reset flag &n;&t;&t; *  since we donnot expect this operation to fail.&n;&t;&t; */
r_if
c_cond
(paren
id|tp-&gt;to_reset
)paren
(brace
id|np-&gt;abrt_msg
(braket
l_int|0
)braket
op_assign
id|M_RESET
suffix:semicolon
id|np-&gt;abrt_tbl.size
op_assign
l_int|1
suffix:semicolon
id|tp-&gt;to_reset
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  Otherwise, look for some logical unit to be cleared.&n;&t;&t; */
r_if
c_cond
(paren
id|tp-&gt;lun0p
op_logical_and
id|tp-&gt;lun0p-&gt;to_clear
)paren
id|lun
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tp-&gt;lunmp
)paren
(brace
r_for
c_loop
(paren
id|k
op_assign
l_int|1
suffix:semicolon
id|k
OL
id|SYM_CONF_MAX_LUN
suffix:semicolon
id|k
op_increment
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;lunmp
(braket
id|k
)braket
op_logical_and
id|tp-&gt;lunmp
(braket
id|k
)braket
op_member_access_from_pointer
id|to_clear
)paren
(brace
id|lun
op_assign
id|k
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t; *  If a logical unit is to be cleared, prepare &n;&t;&t; *  an IDENTIFY(lun) + ABORT MESSAGE.&n;&t;&t; */
r_if
c_cond
(paren
id|lun
op_ne
op_minus
l_int|1
)paren
(brace
id|lcb_p
id|lp
op_assign
id|sym_lp
c_func
(paren
id|np
comma
id|tp
comma
id|lun
)paren
suffix:semicolon
id|lp-&gt;to_clear
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We donnot expect to fail here */
id|np-&gt;abrt_msg
(braket
l_int|0
)braket
op_assign
id|M_IDENTIFY
op_or
id|lun
suffix:semicolon
id|np-&gt;abrt_msg
(braket
l_int|1
)braket
op_assign
id|M_ABORT
suffix:semicolon
id|np-&gt;abrt_tbl.size
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  Otherwise, look for some disconnected job to &n;&t;&t; *  abort for this target.&n;&t;&t; */
id|i
op_assign
l_int|0
suffix:semicolon
id|cp
op_assign
l_int|0
suffix:semicolon
id|FOR_EACH_QUEUED_ELEMENT
c_func
(paren
op_amp
id|np-&gt;busy_ccbq
comma
id|qp
)paren
(brace
id|cp
op_assign
id|sym_que_entry
c_func
(paren
id|qp
comma
r_struct
id|sym_ccb
comma
id|link_ccbq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;host_status
op_ne
id|HS_DISCONNECT
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;target
op_ne
id|target
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp-&gt;to_abort
)paren
r_continue
suffix:semicolon
id|i
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Means we have some */
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  If we have none, probably since the device has &n;&t;&t; *  completed the command before we won abitration,&n;&t;&t; *  send a M_ABORT message without IDENTIFY.&n;&t;&t; *  According to the specs, the device must just &n;&t;&t; *  disconnect the BUS and not abort any task.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
(brace
id|np-&gt;abrt_msg
(braket
l_int|0
)braket
op_assign
id|M_ABORT
suffix:semicolon
id|np-&gt;abrt_tbl.size
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  We have some task to abort.&n;&t;&t; *  Set the IDENTIFY(lun)&n;&t;&t; */
id|np-&gt;abrt_msg
(braket
l_int|0
)braket
op_assign
id|M_IDENTIFY
op_or
id|cp-&gt;lun
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  If we want to abort an untagged command, we &n;&t;&t; *  will send a IDENTIFY + M_ABORT.&n;&t;&t; *  Otherwise (tagged command), we will send &n;&t;&t; *  a IDENTITFY + task attributes + ABORT TAG.&n;&t;&t; */
r_if
c_cond
(paren
id|cp-&gt;tag
op_eq
id|NO_TAG
)paren
(brace
id|np-&gt;abrt_msg
(braket
l_int|1
)braket
op_assign
id|M_ABORT
suffix:semicolon
id|np-&gt;abrt_tbl.size
op_assign
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|np-&gt;abrt_msg
(braket
l_int|1
)braket
op_assign
id|cp-&gt;scsi_smsg
(braket
l_int|1
)braket
suffix:semicolon
id|np-&gt;abrt_msg
(braket
l_int|2
)braket
op_assign
id|cp-&gt;scsi_smsg
(braket
l_int|2
)braket
suffix:semicolon
id|np-&gt;abrt_msg
(braket
l_int|3
)braket
op_assign
id|M_ABORT_TAG
suffix:semicolon
id|np-&gt;abrt_tbl.size
op_assign
l_int|4
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  Keep track of software timeout condition, since the &n;&t;&t; *  peripheral driver may not count retries on abort &n;&t;&t; *  conditions not due to timeout.&n;&t;&t; */
r_if
c_cond
(paren
id|cp-&gt;to_abort
op_eq
l_int|2
)paren
id|sym_set_cam_status
c_func
(paren
id|cp-&gt;cam_ccb
comma
id|CAM_CMD_TIMEOUT
)paren
suffix:semicolon
id|cp-&gt;to_abort
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We donnot expect to fail here */
r_break
suffix:semicolon
multiline_comment|/*&n;&t; *  The target has accepted our message and switched &n;&t; *  to BUS FREE phase as we expected.&n;&t; */
r_case
id|SIR_ABORT_SENT
suffix:colon
id|target
op_assign
(paren
id|INB
(paren
id|nc_sdid
)paren
op_amp
l_int|0xf
)paren
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t;**  If we didn&squot;t abort anything, leave here.&n;&t;&t;*/
r_if
c_cond
(paren
id|np-&gt;abrt_msg
(braket
l_int|0
)braket
op_eq
id|M_ABORT
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  If we sent a M_RESET, then a hardware reset has &n;&t;&t; *  been performed by the target.&n;&t;&t; *  - Reset everything to async 8 bit&n;&t;&t; *  - Tell ourself to negotiate next time :-)&n;&t;&t; *  - Prepare to clear all disconnected CCBs for &n;&t;&t; *    this target from our task list (lun=task=-1)&n;&t;&t; */
id|lun
op_assign
op_minus
l_int|1
suffix:semicolon
id|task
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;abrt_msg
(braket
l_int|0
)braket
op_eq
id|M_RESET
)paren
(brace
id|tp-&gt;head.sval
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;head.wval
op_assign
id|np-&gt;rv_scntl3
suffix:semicolon
id|tp-&gt;head.uval
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;tinfo.curr.period
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;tinfo.curr.offset
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;tinfo.curr.width
op_assign
id|BUS_8_BIT
suffix:semicolon
id|tp-&gt;tinfo.curr.options
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  Otherwise, check for the LUN and TASK(s) &n;&t;&t; *  concerned by the cancelation.&n;&t;&t; *  If it is not ABORT_TAG then it is CLEAR_QUEUE &n;&t;&t; *  or an ABORT message :-)&n;&t;&t; */
r_else
(brace
id|lun
op_assign
id|np-&gt;abrt_msg
(braket
l_int|0
)braket
op_amp
l_int|0x3f
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;abrt_msg
(braket
l_int|1
)braket
op_eq
id|M_ABORT_TAG
)paren
id|task
op_assign
id|np-&gt;abrt_msg
(braket
l_int|2
)braket
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  Complete all the CCBs the device should have &n;&t;&t; *  aborted due to our &squot;kiss of death&squot; message.&n;&t;&t; */
id|i
op_assign
(paren
id|INL
(paren
id|nc_scratcha
)paren
op_minus
id|np-&gt;squeue_ba
)paren
op_div
l_int|4
suffix:semicolon
(paren
r_void
)paren
id|sym_dequeue_from_squeue
c_func
(paren
id|np
comma
id|i
comma
id|target
comma
id|lun
comma
op_minus
l_int|1
)paren
suffix:semicolon
(paren
r_void
)paren
id|sym_clear_tasks
c_func
(paren
id|np
comma
id|CAM_REQ_ABORTED
comma
id|target
comma
id|lun
comma
id|task
)paren
suffix:semicolon
id|sym_flush_comp_queue
c_func
(paren
id|np
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  If we sent a BDR, make upper layer aware of that.&n; &t;&t; */
r_if
c_cond
(paren
id|np-&gt;abrt_msg
(braket
l_int|0
)braket
op_eq
id|M_RESET
)paren
id|sym_xpt_async_sent_bdr
c_func
(paren
id|np
comma
id|target
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Print to the log the message we intend to send.&n;&t; */
r_if
c_cond
(paren
id|num
op_eq
id|SIR_TARGET_SELECTED
)paren
(brace
id|PRINT_TARGET
c_func
(paren
id|np
comma
id|target
)paren
suffix:semicolon
id|sym_printl_hex
c_func
(paren
l_string|&quot;control msgout:&quot;
comma
id|np-&gt;abrt_msg
comma
id|np-&gt;abrt_tbl.size
)paren
suffix:semicolon
id|np-&gt;abrt_tbl.size
op_assign
id|cpu_to_scr
c_func
(paren
id|np-&gt;abrt_tbl.size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Let the SCRIPTS processor continue.&n;&t; */
id|OUTONB_STD
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Gerard&squot;s alchemy:) that deals with with the data &n; *  pointer for both MDP and the residual calculation.&n; *&n; *  I didn&squot;t want to bloat the code by more than 200 &n; *  lignes for the handling of both MDP and the residual.&n; *  This has been achieved by using a data pointer &n; *  representation consisting in an index in the data &n; *  array (dp_sg) and a negative offset (dp_ofs) that &n; *  have the following meaning:&n; *&n; *  - dp_sg = SYM_CONF_MAX_SG&n; *    we are at the end of the data script.&n; *  - dp_sg &lt; SYM_CONF_MAX_SG&n; *    dp_sg points to the next entry of the scatter array &n; *    we want to transfer.&n; *  - dp_ofs &lt; 0&n; *    dp_ofs represents the residual of bytes of the &n; *    previous entry scatter entry we will send first.&n; *  - dp_ofs = 0&n; *    no residual to send first.&n; *&n; *  The function sym_evaluate_dp() accepts an arbitray &n; *  offset (basically from the MDP message) and returns &n; *  the corresponding values of dp_sg and dp_ofs.&n; */
DECL|function|sym_evaluate_dp
r_static
r_int
id|sym_evaluate_dp
c_func
(paren
id|hcb_p
id|np
comma
id|ccb_p
id|cp
comma
id|u32
id|scr
comma
r_int
op_star
id|ofs
)paren
(brace
id|u32
id|dp_scr
suffix:semicolon
r_int
id|dp_ofs
comma
id|dp_sg
comma
id|dp_sgmin
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_struct
id|sym_pmc
op_star
id|pm
suffix:semicolon
multiline_comment|/*&n;&t; *  Compute the resulted data pointer in term of a script &n;&t; *  address within some DATA script and a signed byte offset.&n;&t; */
id|dp_scr
op_assign
id|scr
suffix:semicolon
id|dp_ofs
op_assign
op_star
id|ofs
suffix:semicolon
r_if
c_cond
(paren
id|dp_scr
op_eq
id|SCRIPTA_BA
(paren
id|np
comma
id|pm0_data
)paren
)paren
id|pm
op_assign
op_amp
id|cp-&gt;phys.pm0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dp_scr
op_eq
id|SCRIPTA_BA
(paren
id|np
comma
id|pm1_data
)paren
)paren
id|pm
op_assign
op_amp
id|cp-&gt;phys.pm1
suffix:semicolon
r_else
id|pm
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pm
)paren
(brace
id|dp_scr
op_assign
id|scr_to_cpu
c_func
(paren
id|pm-&gt;ret
)paren
suffix:semicolon
id|dp_ofs
op_sub_assign
id|scr_to_cpu
c_func
(paren
id|pm-&gt;sg.size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  If we are auto-sensing, then we are done.&n;&t; */
r_if
c_cond
(paren
id|cp-&gt;host_flags
op_amp
id|HF_SENSE
)paren
(brace
op_star
id|ofs
op_assign
id|dp_ofs
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Deduce the index of the sg entry.&n;&t; *  Keep track of the index of the first valid entry.&n;&t; *  If result is dp_sg = SYM_CONF_MAX_SG, then we are at the &n;&t; *  end of the data.&n;&t; */
id|tmp
op_assign
id|scr_to_cpu
c_func
(paren
id|sym_goalp
c_func
(paren
id|cp
)paren
)paren
suffix:semicolon
id|dp_sg
op_assign
id|SYM_CONF_MAX_SG
suffix:semicolon
r_if
c_cond
(paren
id|dp_scr
op_ne
id|tmp
)paren
id|dp_sg
op_sub_assign
(paren
id|tmp
op_minus
l_int|8
op_minus
(paren
r_int
)paren
id|dp_scr
)paren
op_div
(paren
l_int|2
op_star
l_int|4
)paren
suffix:semicolon
id|dp_sgmin
op_assign
id|SYM_CONF_MAX_SG
op_minus
id|cp-&gt;segments
suffix:semicolon
multiline_comment|/*&n;&t; *  Move to the sg entry the data pointer belongs to.&n;&t; *&n;&t; *  If we are inside the data area, we expect result to be:&n;&t; *&n;&t; *  Either,&n;&t; *      dp_ofs = 0 and dp_sg is the index of the sg entry&n;&t; *      the data pointer belongs to (or the end of the data)&n;&t; *  Or,&n;&t; *      dp_ofs &lt; 0 and dp_sg is the index of the sg entry &n;&t; *      the data pointer belongs to + 1.&n;&t; */
r_if
c_cond
(paren
id|dp_ofs
OL
l_int|0
)paren
(brace
r_int
id|n
suffix:semicolon
r_while
c_loop
(paren
id|dp_sg
OG
id|dp_sgmin
)paren
(brace
op_decrement
id|dp_sg
suffix:semicolon
id|tmp
op_assign
id|scr_to_cpu
c_func
(paren
id|cp-&gt;phys.data
(braket
id|dp_sg
)braket
dot
id|size
)paren
suffix:semicolon
id|n
op_assign
id|dp_ofs
op_plus
(paren
id|tmp
op_amp
l_int|0xffffff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
l_int|0
)paren
(brace
op_increment
id|dp_sg
suffix:semicolon
r_break
suffix:semicolon
)brace
id|dp_ofs
op_assign
id|n
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|dp_ofs
OG
l_int|0
)paren
(brace
r_while
c_loop
(paren
id|dp_sg
OL
id|SYM_CONF_MAX_SG
)paren
(brace
id|tmp
op_assign
id|scr_to_cpu
c_func
(paren
id|cp-&gt;phys.data
(braket
id|dp_sg
)braket
dot
id|size
)paren
suffix:semicolon
id|dp_ofs
op_sub_assign
(paren
id|tmp
op_amp
l_int|0xffffff
)paren
suffix:semicolon
op_increment
id|dp_sg
suffix:semicolon
r_if
c_cond
(paren
id|dp_ofs
op_le
l_int|0
)paren
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *  Make sure the data pointer is inside the data area.&n;&t; *  If not, return some error.&n;&t; */
r_if
c_cond
(paren
id|dp_sg
OL
id|dp_sgmin
op_logical_or
(paren
id|dp_sg
op_eq
id|dp_sgmin
op_logical_and
id|dp_ofs
OL
l_int|0
)paren
)paren
r_goto
id|out_err
suffix:semicolon
r_else
r_if
c_cond
(paren
id|dp_sg
OG
id|SYM_CONF_MAX_SG
op_logical_or
(paren
id|dp_sg
op_eq
id|SYM_CONF_MAX_SG
op_logical_and
id|dp_ofs
OG
l_int|0
)paren
)paren
r_goto
id|out_err
suffix:semicolon
multiline_comment|/*&n;&t; *  Save the extreme pointer if needed.&n;&t; */
r_if
c_cond
(paren
id|dp_sg
OG
id|cp-&gt;ext_sg
op_logical_or
(paren
id|dp_sg
op_eq
id|cp-&gt;ext_sg
op_logical_and
id|dp_ofs
OG
id|cp-&gt;ext_ofs
)paren
)paren
(brace
id|cp-&gt;ext_sg
op_assign
id|dp_sg
suffix:semicolon
id|cp-&gt;ext_ofs
op_assign
id|dp_ofs
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Return data.&n;&t; */
op_star
id|ofs
op_assign
id|dp_ofs
suffix:semicolon
r_return
id|dp_sg
suffix:semicolon
id|out_err
suffix:colon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; *  chip handler for MODIFY DATA POINTER MESSAGE&n; *&n; *  We also call this function on IGNORE WIDE RESIDUE &n; *  messages that do not match a SWIDE full condition.&n; *  Btw, we assume in that situation that such a message &n; *  is equivalent to a MODIFY DATA POINTER (offset=-1).&n; */
DECL|function|sym_modify_dp
r_static
r_void
id|sym_modify_dp
c_func
(paren
id|hcb_p
id|np
comma
id|tcb_p
id|tp
comma
id|ccb_p
id|cp
comma
r_int
id|ofs
)paren
(brace
r_int
id|dp_ofs
op_assign
id|ofs
suffix:semicolon
id|u32
id|dp_scr
op_assign
id|sym_get_script_dp
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
id|u32
id|dp_ret
suffix:semicolon
id|u32
id|tmp
suffix:semicolon
id|u_char
id|hflags
suffix:semicolon
r_int
id|dp_sg
suffix:semicolon
r_struct
id|sym_pmc
op_star
id|pm
suffix:semicolon
multiline_comment|/*&n;&t; *  Not supported for auto-sense.&n;&t; */
r_if
c_cond
(paren
id|cp-&gt;host_flags
op_amp
id|HF_SENSE
)paren
r_goto
id|out_reject
suffix:semicolon
multiline_comment|/*&n;&t; *  Apply our alchemy:) (see comments in sym_evaluate_dp()), &n;&t; *  to the resulted data pointer.&n;&t; */
id|dp_sg
op_assign
id|sym_evaluate_dp
c_func
(paren
id|np
comma
id|cp
comma
id|dp_scr
comma
op_amp
id|dp_ofs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dp_sg
OL
l_int|0
)paren
r_goto
id|out_reject
suffix:semicolon
multiline_comment|/*&n;&t; *  And our alchemy:) allows to easily calculate the data &n;&t; *  script address we want to return for the next data phase.&n;&t; */
id|dp_ret
op_assign
id|cpu_to_scr
c_func
(paren
id|sym_goalp
c_func
(paren
id|cp
)paren
)paren
suffix:semicolon
id|dp_ret
op_assign
id|dp_ret
op_minus
l_int|8
op_minus
(paren
id|SYM_CONF_MAX_SG
op_minus
id|dp_sg
)paren
op_star
(paren
l_int|2
op_star
l_int|4
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  If offset / scatter entry is zero we donnot need &n;&t; *  a context for the new current data pointer.&n;&t; */
r_if
c_cond
(paren
id|dp_ofs
op_eq
l_int|0
)paren
(brace
id|dp_scr
op_assign
id|dp_ret
suffix:semicolon
r_goto
id|out_ok
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Get a context for the new current data pointer.&n;&t; */
id|hflags
op_assign
id|INB
(paren
id|HF_PRT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hflags
op_amp
id|HF_DP_SAVED
)paren
id|hflags
op_xor_assign
id|HF_ACT_PM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|hflags
op_amp
id|HF_ACT_PM
)paren
)paren
(brace
id|pm
op_assign
op_amp
id|cp-&gt;phys.pm0
suffix:semicolon
id|dp_scr
op_assign
id|SCRIPTA_BA
(paren
id|np
comma
id|pm0_data
)paren
suffix:semicolon
)brace
r_else
(brace
id|pm
op_assign
op_amp
id|cp-&gt;phys.pm1
suffix:semicolon
id|dp_scr
op_assign
id|SCRIPTA_BA
(paren
id|np
comma
id|pm1_data
)paren
suffix:semicolon
)brace
id|hflags
op_and_assign
op_complement
(paren
id|HF_DP_SAVED
)paren
suffix:semicolon
id|OUTB
(paren
id|HF_PRT
comma
id|hflags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Set up the new current data pointer.&n;&t; *  ofs &lt; 0 there, and for the next data phase, we &n;&t; *  want to transfer part of the data of the sg entry &n;&t; *  corresponding to index dp_sg-1 prior to returning &n;&t; *  to the main data script.&n;&t; */
id|pm-&gt;ret
op_assign
id|cpu_to_scr
c_func
(paren
id|dp_ret
)paren
suffix:semicolon
id|tmp
op_assign
id|scr_to_cpu
c_func
(paren
id|cp-&gt;phys.data
(braket
id|dp_sg
op_minus
l_int|1
)braket
dot
id|addr
)paren
suffix:semicolon
id|tmp
op_add_assign
id|scr_to_cpu
c_func
(paren
id|cp-&gt;phys.data
(braket
id|dp_sg
op_minus
l_int|1
)braket
dot
id|size
)paren
op_plus
id|dp_ofs
suffix:semicolon
id|pm-&gt;sg.addr
op_assign
id|cpu_to_scr
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|pm-&gt;sg.size
op_assign
id|cpu_to_scr
c_func
(paren
op_minus
id|dp_ofs
)paren
suffix:semicolon
id|out_ok
suffix:colon
id|sym_set_script_dp
(paren
id|np
comma
id|cp
comma
id|dp_scr
)paren
suffix:semicolon
id|OUTL_DSP
(paren
id|SCRIPTA_BA
(paren
id|np
comma
id|clrack
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
id|out_reject
suffix:colon
id|OUTL_DSP
(paren
id|SCRIPTB_BA
(paren
id|np
comma
id|msg_bad
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  chip calculation of the data residual.&n; *&n; *  As I used to say, the requirement of data residual &n; *  in SCSI is broken, useless and cannot be achieved &n; *  without huge complexity.&n; *  But most OSes and even the official CAM require it.&n; *  When stupidity happens to be so widely spread inside &n; *  a community, it gets hard to convince.&n; *&n; *  Anyway, I don&squot;t care, since I am not going to use &n; *  any software that considers this data residual as &n; *  a relevant information. :)&n; */
DECL|function|sym_compute_residual
r_int
id|sym_compute_residual
c_func
(paren
id|hcb_p
id|np
comma
id|ccb_p
id|cp
)paren
(brace
r_int
id|dp_sg
comma
id|dp_sgmin
comma
id|resid
op_assign
l_int|0
suffix:semicolon
r_int
id|dp_ofs
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *  Check for some data lost or just thrown away.&n;&t; *  We are not required to be quite accurate in this &n;&t; *  situation. Btw, if we are odd for output and the &n;&t; *  device claims some more data, it may well happen &n;&t; *  than our residual be zero. :-)&n;&t; */
r_if
c_cond
(paren
id|cp-&gt;xerr_status
op_amp
(paren
id|XE_EXTRA_DATA
op_or
id|XE_SODL_UNRUN
op_or
id|XE_SWIDE_OVRUN
)paren
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;xerr_status
op_amp
id|XE_EXTRA_DATA
)paren
id|resid
op_sub_assign
id|cp-&gt;extra_bytes
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;xerr_status
op_amp
id|XE_SODL_UNRUN
)paren
op_increment
id|resid
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;xerr_status
op_amp
id|XE_SWIDE_OVRUN
)paren
op_decrement
id|resid
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  If all data has been transferred,&n;&t; *  there is no residual.&n;&t; */
r_if
c_cond
(paren
id|cp-&gt;phys.head.lastp
op_eq
id|sym_goalp
c_func
(paren
id|cp
)paren
)paren
r_return
id|resid
suffix:semicolon
multiline_comment|/*&n;&t; *  If no data transfer occurs, or if the data&n;&t; *  pointer is weird, return full residual.&n;&t; */
r_if
c_cond
(paren
id|cp-&gt;startp
op_eq
id|cp-&gt;phys.head.lastp
op_logical_or
id|sym_evaluate_dp
c_func
(paren
id|np
comma
id|cp
comma
id|scr_to_cpu
c_func
(paren
id|cp-&gt;phys.head.lastp
)paren
comma
op_amp
id|dp_ofs
)paren
OL
l_int|0
)paren
(brace
r_return
id|cp-&gt;data_len
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  If we were auto-sensing, then we are done.&n;&t; */
r_if
c_cond
(paren
id|cp-&gt;host_flags
op_amp
id|HF_SENSE
)paren
(brace
r_return
op_minus
id|dp_ofs
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  We are now full comfortable in the computation &n;&t; *  of the data residual (2&squot;s complement).&n;&t; */
id|dp_sgmin
op_assign
id|SYM_CONF_MAX_SG
op_minus
id|cp-&gt;segments
suffix:semicolon
id|resid
op_assign
op_minus
id|cp-&gt;ext_ofs
suffix:semicolon
r_for
c_loop
(paren
id|dp_sg
op_assign
id|cp-&gt;ext_sg
suffix:semicolon
id|dp_sg
OL
id|SYM_CONF_MAX_SG
suffix:semicolon
op_increment
id|dp_sg
)paren
(brace
id|u_int
id|tmp
op_assign
id|scr_to_cpu
c_func
(paren
id|cp-&gt;phys.data
(braket
id|dp_sg
)braket
dot
id|size
)paren
suffix:semicolon
id|resid
op_add_assign
(paren
id|tmp
op_amp
l_int|0xffffff
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Hopefully, the result is not too wrong.&n;&t; */
r_return
id|resid
suffix:semicolon
)brace
multiline_comment|/*&n; *  Negotiation for WIDE and SYNCHRONOUS DATA TRANSFER.&n; *&n; *  When we try to negotiate, we append the negotiation message&n; *  to the identify and (maybe) simple tag message.&n; *  The host status field is set to HS_NEGOTIATE to mark this&n; *  situation.&n; *&n; *  If the target doesn&squot;t answer this message immediately&n; *  (as required by the standard), the SIR_NEGO_FAILED interrupt&n; *  will be raised eventually.&n; *  The handler removes the HS_NEGOTIATE status, and sets the&n; *  negotiated value to the default (async / nowide).&n; *&n; *  If we receive a matching answer immediately, we check it&n; *  for validity, and set the values.&n; *&n; *  If we receive a Reject message immediately, we assume the&n; *  negotiation has failed, and fall back to standard values.&n; *&n; *  If we receive a negotiation message while not in HS_NEGOTIATE&n; *  state, it&squot;s a target initiated negotiation. We prepare a&n; *  (hopefully) valid answer, set our parameters, and send back &n; *  this answer to the target.&n; *&n; *  If the target doesn&squot;t fetch the answer (no message out phase),&n; *  we assume the negotiation has failed, and fall back to default&n; *  settings (SIR_NEGO_PROTO interrupt).&n; *&n; *  When we set the values, we adjust them in all ccbs belonging &n; *  to this target, in the controller&squot;s register, and in the &quot;phys&quot;&n; *  field of the controller&squot;s struct sym_hcb.&n; */
multiline_comment|/*&n; *  chip handler for SYNCHRONOUS DATA TRANSFER REQUEST (SDTR) message.&n; */
r_static
r_int
DECL|function|sym_sync_nego_check
id|sym_sync_nego_check
c_func
(paren
id|hcb_p
id|np
comma
r_int
id|req
comma
r_int
id|target
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
id|u_char
id|chg
comma
id|ofs
comma
id|per
comma
id|fak
comma
id|div
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|sym_print_nego_msg
c_func
(paren
id|np
comma
id|target
comma
l_string|&quot;sync msgin&quot;
comma
id|np-&gt;msgin
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t; *  Get requested values.&n;&t; */
id|chg
op_assign
l_int|0
suffix:semicolon
id|per
op_assign
id|np-&gt;msgin
(braket
l_int|3
)braket
suffix:semicolon
id|ofs
op_assign
id|np-&gt;msgin
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/*&n;&t; *  Check values against our limits.&n;&t; */
r_if
c_cond
(paren
id|ofs
)paren
(brace
r_if
c_cond
(paren
id|ofs
OG
id|np-&gt;maxoffs
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|ofs
op_assign
id|np-&gt;maxoffs
suffix:semicolon
)brace
r_if
c_cond
(paren
id|req
)paren
(brace
r_if
c_cond
(paren
id|ofs
OG
id|tp-&gt;tinfo.user.offset
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|ofs
op_assign
id|tp-&gt;tinfo.user.offset
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|ofs
)paren
(brace
r_if
c_cond
(paren
id|per
OL
id|np-&gt;minsync
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|per
op_assign
id|np-&gt;minsync
suffix:semicolon
)brace
r_if
c_cond
(paren
id|req
)paren
(brace
r_if
c_cond
(paren
id|per
OL
id|tp-&gt;tinfo.user.period
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|per
op_assign
id|tp-&gt;tinfo.user.period
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; *  Get new chip synchronous parameters value.&n;&t; */
id|div
op_assign
id|fak
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ofs
op_logical_and
id|sym_getsync
c_func
(paren
id|np
comma
l_int|0
comma
id|per
comma
op_amp
id|div
comma
op_amp
id|fak
)paren
OL
l_int|0
)paren
r_goto
id|reject_it
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_TARGET
c_func
(paren
id|np
comma
id|target
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;sdtr: ofs=%d per=%d div=%d fak=%d chg=%d.&bslash;n&quot;
comma
id|ofs
comma
id|per
comma
id|div
comma
id|fak
comma
id|chg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  If it was an answer we want to change, &n;&t; *  then it isn&squot;t acceptable. Reject it.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|req
op_logical_and
id|chg
)paren
r_goto
id|reject_it
suffix:semicolon
multiline_comment|/*&n;&t; *  Apply new values.&n;&t; */
id|sym_setsync
(paren
id|np
comma
id|target
comma
id|ofs
comma
id|per
comma
id|div
comma
id|fak
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  It was an answer. We are done.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|req
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *  It was a request. Prepare an answer message.&n;&t; */
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_EXTENDED
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|1
)braket
op_assign
l_int|3
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|2
)braket
op_assign
id|M_X_SYNC_REQ
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|3
)braket
op_assign
id|per
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|4
)braket
op_assign
id|ofs
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|sym_print_nego_msg
c_func
(paren
id|np
comma
id|target
comma
l_string|&quot;sync msgout&quot;
comma
id|np-&gt;msgout
)paren
suffix:semicolon
)brace
id|np-&gt;msgin
(braket
l_int|0
)braket
op_assign
id|M_NOOP
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|reject_it
suffix:colon
id|sym_setsync
(paren
id|np
comma
id|target
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|sym_sync_nego
r_static
r_void
id|sym_sync_nego
c_func
(paren
id|hcb_p
id|np
comma
id|tcb_p
id|tp
comma
id|ccb_p
id|cp
)paren
(brace
r_int
id|req
op_assign
l_int|1
suffix:semicolon
r_int
id|result
suffix:semicolon
multiline_comment|/*&n;&t; *  Request or answer ?&n;&t; */
r_if
c_cond
(paren
id|INB
(paren
id|HS_PRT
)paren
op_eq
id|HS_NEGOTIATE
)paren
(brace
id|OUTB
(paren
id|HS_PRT
comma
id|HS_BUSY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;nego_status
op_logical_and
id|cp-&gt;nego_status
op_ne
id|NS_SYNC
)paren
r_goto
id|reject_it
suffix:semicolon
id|req
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Check and apply new values.&n;&t; */
id|result
op_assign
id|sym_sync_nego_check
c_func
(paren
id|np
comma
id|req
comma
id|cp-&gt;target
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
multiline_comment|/* Not acceptable, reject it */
r_goto
id|reject_it
suffix:semicolon
r_if
c_cond
(paren
id|req
)paren
(brace
multiline_comment|/* Was a request, send response. */
id|cp-&gt;nego_status
op_assign
id|NS_SYNC
suffix:semicolon
id|OUTL_DSP
(paren
id|SCRIPTB_BA
(paren
id|np
comma
id|sdtr_resp
)paren
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* Was a response, we are done. */
id|OUTL_DSP
(paren
id|SCRIPTA_BA
(paren
id|np
comma
id|clrack
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
id|reject_it
suffix:colon
id|OUTL_DSP
(paren
id|SCRIPTB_BA
(paren
id|np
comma
id|msg_bad
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  chip handler for PARALLEL PROTOCOL REQUEST (PPR) message.&n; */
r_static
r_int
DECL|function|sym_ppr_nego_check
id|sym_ppr_nego_check
c_func
(paren
id|hcb_p
id|np
comma
r_int
id|req
comma
r_int
id|target
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
id|u_char
id|chg
comma
id|ofs
comma
id|per
comma
id|fak
comma
id|dt
comma
id|div
comma
id|wide
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|sym_print_nego_msg
c_func
(paren
id|np
comma
id|target
comma
l_string|&quot;ppr msgin&quot;
comma
id|np-&gt;msgin
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t; *  Get requested values.&n;&t; */
id|chg
op_assign
l_int|0
suffix:semicolon
id|per
op_assign
id|np-&gt;msgin
(braket
l_int|3
)braket
suffix:semicolon
id|ofs
op_assign
id|np-&gt;msgin
(braket
l_int|5
)braket
suffix:semicolon
id|wide
op_assign
id|np-&gt;msgin
(braket
l_int|6
)braket
suffix:semicolon
id|dt
op_assign
id|np-&gt;msgin
(braket
l_int|7
)braket
op_amp
id|PPR_OPT_DT
suffix:semicolon
multiline_comment|/*&n;&t; *  Check values against our limits.&n;&t; */
r_if
c_cond
(paren
id|wide
OG
id|np-&gt;maxwide
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|wide
op_assign
id|np-&gt;maxwide
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|wide
op_logical_or
op_logical_neg
(paren
id|np-&gt;features
op_amp
id|FE_ULTRA3
)paren
)paren
id|dt
op_and_assign
op_complement
id|PPR_OPT_DT
suffix:semicolon
r_if
c_cond
(paren
id|req
)paren
(brace
r_if
c_cond
(paren
id|wide
OG
id|tp-&gt;tinfo.user.width
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|wide
op_assign
id|tp-&gt;tinfo.user.width
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|np-&gt;features
op_amp
id|FE_U3EN
)paren
)paren
multiline_comment|/* Broken U3EN bit not supported */
id|dt
op_and_assign
op_complement
id|PPR_OPT_DT
suffix:semicolon
r_if
c_cond
(paren
id|dt
op_ne
(paren
id|np-&gt;msgin
(braket
l_int|7
)braket
op_amp
id|PPR_OPT_MASK
)paren
)paren
id|chg
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ofs
)paren
(brace
r_if
c_cond
(paren
id|dt
)paren
(brace
r_if
c_cond
(paren
id|ofs
OG
id|np-&gt;maxoffs_dt
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|ofs
op_assign
id|np-&gt;maxoffs_dt
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|ofs
OG
id|np-&gt;maxoffs
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|ofs
op_assign
id|np-&gt;maxoffs
suffix:semicolon
)brace
r_if
c_cond
(paren
id|req
)paren
(brace
r_if
c_cond
(paren
id|ofs
OG
id|tp-&gt;tinfo.user.offset
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|ofs
op_assign
id|tp-&gt;tinfo.user.offset
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|ofs
)paren
(brace
r_if
c_cond
(paren
id|dt
)paren
(brace
r_if
c_cond
(paren
id|per
OL
id|np-&gt;minsync_dt
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|per
op_assign
id|np-&gt;minsync_dt
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|per
OL
id|np-&gt;minsync
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|per
op_assign
id|np-&gt;minsync
suffix:semicolon
)brace
r_if
c_cond
(paren
id|req
)paren
(brace
r_if
c_cond
(paren
id|per
OL
id|tp-&gt;tinfo.user.period
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|per
op_assign
id|tp-&gt;tinfo.user.period
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; *  Get new chip synchronous parameters value.&n;&t; */
id|div
op_assign
id|fak
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ofs
op_logical_and
id|sym_getsync
c_func
(paren
id|np
comma
id|dt
comma
id|per
comma
op_amp
id|div
comma
op_amp
id|fak
)paren
OL
l_int|0
)paren
r_goto
id|reject_it
suffix:semicolon
multiline_comment|/*&n;&t; *  If it was an answer we want to change, &n;&t; *  then it isn&squot;t acceptable. Reject it.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|req
op_logical_and
id|chg
)paren
r_goto
id|reject_it
suffix:semicolon
multiline_comment|/*&n;&t; *  Apply new values.&n;&t; */
id|sym_setpprot
(paren
id|np
comma
id|target
comma
id|dt
comma
id|ofs
comma
id|per
comma
id|wide
comma
id|div
comma
id|fak
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  It was an answer. We are done.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|req
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *  It was a request. Prepare an answer message.&n;&t; */
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_EXTENDED
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|1
)braket
op_assign
l_int|6
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|2
)braket
op_assign
id|M_X_PPR_REQ
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|3
)braket
op_assign
id|per
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|5
)braket
op_assign
id|ofs
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|6
)braket
op_assign
id|wide
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|7
)braket
op_assign
id|dt
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|sym_print_nego_msg
c_func
(paren
id|np
comma
id|target
comma
l_string|&quot;ppr msgout&quot;
comma
id|np-&gt;msgout
)paren
suffix:semicolon
)brace
id|np-&gt;msgin
(braket
l_int|0
)braket
op_assign
id|M_NOOP
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|reject_it
suffix:colon
id|sym_setpprot
(paren
id|np
comma
id|target
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  If it is a device response that should result in  &n;&t; *  ST, we may want to try a legacy negotiation later.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|req
op_logical_and
op_logical_neg
id|dt
)paren
(brace
id|tp-&gt;tinfo.goal.options
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;tinfo.goal.width
op_assign
id|wide
suffix:semicolon
id|tp-&gt;tinfo.goal.period
op_assign
id|per
suffix:semicolon
id|tp-&gt;tinfo.goal.offset
op_assign
id|ofs
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|sym_ppr_nego
r_static
r_void
id|sym_ppr_nego
c_func
(paren
id|hcb_p
id|np
comma
id|tcb_p
id|tp
comma
id|ccb_p
id|cp
)paren
(brace
r_int
id|req
op_assign
l_int|1
suffix:semicolon
r_int
id|result
suffix:semicolon
multiline_comment|/*&n;&t; *  Request or answer ?&n;&t; */
r_if
c_cond
(paren
id|INB
(paren
id|HS_PRT
)paren
op_eq
id|HS_NEGOTIATE
)paren
(brace
id|OUTB
(paren
id|HS_PRT
comma
id|HS_BUSY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;nego_status
op_logical_and
id|cp-&gt;nego_status
op_ne
id|NS_PPR
)paren
r_goto
id|reject_it
suffix:semicolon
id|req
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Check and apply new values.&n;&t; */
id|result
op_assign
id|sym_ppr_nego_check
c_func
(paren
id|np
comma
id|req
comma
id|cp-&gt;target
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
multiline_comment|/* Not acceptable, reject it */
r_goto
id|reject_it
suffix:semicolon
r_if
c_cond
(paren
id|req
)paren
(brace
multiline_comment|/* Was a request, send response. */
id|cp-&gt;nego_status
op_assign
id|NS_PPR
suffix:semicolon
id|OUTL_DSP
(paren
id|SCRIPTB_BA
(paren
id|np
comma
id|ppr_resp
)paren
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* Was a response, we are done. */
id|OUTL_DSP
(paren
id|SCRIPTA_BA
(paren
id|np
comma
id|clrack
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
id|reject_it
suffix:colon
id|OUTL_DSP
(paren
id|SCRIPTB_BA
(paren
id|np
comma
id|msg_bad
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  chip handler for WIDE DATA TRANSFER REQUEST (WDTR) message.&n; */
r_static
r_int
DECL|function|sym_wide_nego_check
id|sym_wide_nego_check
c_func
(paren
id|hcb_p
id|np
comma
r_int
id|req
comma
r_int
id|target
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
id|u_char
id|chg
comma
id|wide
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|sym_print_nego_msg
c_func
(paren
id|np
comma
id|target
comma
l_string|&quot;wide msgin&quot;
comma
id|np-&gt;msgin
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t; *  Get requested values.&n;&t; */
id|chg
op_assign
l_int|0
suffix:semicolon
id|wide
op_assign
id|np-&gt;msgin
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/*&n;&t; *  Check values against our limits.&n;&t; */
r_if
c_cond
(paren
id|wide
OG
id|np-&gt;maxwide
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|wide
op_assign
id|np-&gt;maxwide
suffix:semicolon
)brace
r_if
c_cond
(paren
id|req
)paren
(brace
r_if
c_cond
(paren
id|wide
OG
id|tp-&gt;tinfo.user.width
)paren
(brace
id|chg
op_assign
l_int|1
suffix:semicolon
id|wide
op_assign
id|tp-&gt;tinfo.user.width
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|PRINT_TARGET
c_func
(paren
id|np
comma
id|target
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;wdtr: wide=%d chg=%d.&bslash;n&quot;
comma
id|wide
comma
id|chg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  If it was an answer we want to change, &n;&t; *  then it isn&squot;t acceptable. Reject it.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|req
op_logical_and
id|chg
)paren
r_goto
id|reject_it
suffix:semicolon
multiline_comment|/*&n;&t; *  Apply new values.&n;&t; */
id|sym_setwide
(paren
id|np
comma
id|target
comma
id|wide
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  It was an answer. We are done.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|req
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *  It was a request. Prepare an answer message.&n;&t; */
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_EXTENDED
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|1
)braket
op_assign
l_int|2
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|2
)braket
op_assign
id|M_X_WIDE_REQ
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|3
)braket
op_assign
id|wide
suffix:semicolon
id|np-&gt;msgin
(braket
l_int|0
)braket
op_assign
id|M_NOOP
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|sym_print_nego_msg
c_func
(paren
id|np
comma
id|target
comma
l_string|&quot;wide msgout&quot;
comma
id|np-&gt;msgout
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|reject_it
suffix:colon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|sym_wide_nego
r_static
r_void
id|sym_wide_nego
c_func
(paren
id|hcb_p
id|np
comma
id|tcb_p
id|tp
comma
id|ccb_p
id|cp
)paren
(brace
r_int
id|req
op_assign
l_int|1
suffix:semicolon
r_int
id|result
suffix:semicolon
multiline_comment|/*&n;&t; *  Request or answer ?&n;&t; */
r_if
c_cond
(paren
id|INB
(paren
id|HS_PRT
)paren
op_eq
id|HS_NEGOTIATE
)paren
(brace
id|OUTB
(paren
id|HS_PRT
comma
id|HS_BUSY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;nego_status
op_logical_and
id|cp-&gt;nego_status
op_ne
id|NS_WIDE
)paren
r_goto
id|reject_it
suffix:semicolon
id|req
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Check and apply new values.&n;&t; */
id|result
op_assign
id|sym_wide_nego_check
c_func
(paren
id|np
comma
id|req
comma
id|cp-&gt;target
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
multiline_comment|/* Not acceptable, reject it */
r_goto
id|reject_it
suffix:semicolon
r_if
c_cond
(paren
id|req
)paren
(brace
multiline_comment|/* Was a request, send response. */
id|cp-&gt;nego_status
op_assign
id|NS_WIDE
suffix:semicolon
id|OUTL_DSP
(paren
id|SCRIPTB_BA
(paren
id|np
comma
id|wdtr_resp
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Was a response. */
multiline_comment|/*&n;&t;&t; * Negotiate for SYNC immediately after WIDE response.&n;&t;&t; * This allows to negotiate for both WIDE and SYNC on &n;&t;&t; * a single SCSI command (Suggested by Justin Gibbs).&n;&t;&t; */
r_if
c_cond
(paren
id|tp-&gt;tinfo.goal.offset
)paren
(brace
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_EXTENDED
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|1
)braket
op_assign
l_int|3
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|2
)braket
op_assign
id|M_X_SYNC_REQ
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|3
)braket
op_assign
id|tp-&gt;tinfo.goal.period
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|4
)braket
op_assign
id|tp-&gt;tinfo.goal.offset
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_NEGO
)paren
(brace
id|sym_print_nego_msg
c_func
(paren
id|np
comma
id|cp-&gt;target
comma
l_string|&quot;sync msgout&quot;
comma
id|np-&gt;msgout
)paren
suffix:semicolon
)brace
id|cp-&gt;nego_status
op_assign
id|NS_SYNC
suffix:semicolon
id|OUTB
(paren
id|HS_PRT
comma
id|HS_NEGOTIATE
)paren
suffix:semicolon
id|OUTL_DSP
(paren
id|SCRIPTB_BA
(paren
id|np
comma
id|sdtr_resp
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
id|OUTL_DSP
(paren
id|SCRIPTA_BA
(paren
id|np
comma
id|clrack
)paren
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
suffix:semicolon
id|reject_it
suffix:colon
id|OUTL_DSP
(paren
id|SCRIPTB_BA
(paren
id|np
comma
id|msg_bad
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Reset DT, SYNC or WIDE to default settings.&n; *&n; *  Called when a negotiation does not succeed either &n; *  on rejection or on protocol error.&n; *&n; *  A target that understands a PPR message should never &n; *  reject it, and messing with it is very unlikely.&n; *  So, if a PPR makes problems, we may just want to &n; *  try a legacy negotiation later.&n; */
DECL|function|sym_nego_default
r_static
r_void
id|sym_nego_default
c_func
(paren
id|hcb_p
id|np
comma
id|tcb_p
id|tp
comma
id|ccb_p
id|cp
)paren
(brace
r_switch
c_cond
(paren
id|cp-&gt;nego_status
)paren
(brace
r_case
id|NS_PPR
suffix:colon
macro_line|#if 0
id|sym_setpprot
(paren
id|np
comma
id|cp-&gt;target
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
macro_line|#else
id|tp-&gt;tinfo.goal.options
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;tinfo.goal.period
OL
id|np-&gt;minsync
)paren
id|tp-&gt;tinfo.goal.period
op_assign
id|np-&gt;minsync
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;tinfo.goal.offset
OG
id|np-&gt;maxoffs
)paren
id|tp-&gt;tinfo.goal.offset
op_assign
id|np-&gt;maxoffs
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|NS_SYNC
suffix:colon
id|sym_setsync
(paren
id|np
comma
id|cp-&gt;target
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NS_WIDE
suffix:colon
id|sym_setwide
(paren
id|np
comma
id|cp-&gt;target
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|np-&gt;msgin
(braket
l_int|0
)braket
op_assign
id|M_NOOP
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_NOOP
suffix:semicolon
id|cp-&gt;nego_status
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  chip handler for MESSAGE REJECT received in response to &n; *  PPR, WIDE or SYNCHRONOUS negotiation.&n; */
DECL|function|sym_nego_rejected
r_static
r_void
id|sym_nego_rejected
c_func
(paren
id|hcb_p
id|np
comma
id|tcb_p
id|tp
comma
id|ccb_p
id|cp
)paren
(brace
id|sym_nego_default
c_func
(paren
id|np
comma
id|tp
comma
id|cp
)paren
suffix:semicolon
id|OUTB
(paren
id|HS_PRT
comma
id|HS_BUSY
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  chip exception handler for programmed interrupts.&n; */
DECL|function|sym_int_sir
r_static
r_void
id|sym_int_sir
(paren
id|hcb_p
id|np
)paren
(brace
id|u_char
id|num
op_assign
id|INB
(paren
id|nc_dsps
)paren
suffix:semicolon
id|u32
id|dsa
op_assign
id|INL
(paren
id|nc_dsa
)paren
suffix:semicolon
id|ccb_p
id|cp
op_assign
id|sym_ccb_from_dsa
c_func
(paren
id|np
comma
id|dsa
)paren
suffix:semicolon
id|u_char
id|target
op_assign
id|INB
(paren
id|nc_sdid
)paren
op_amp
l_int|0x0f
suffix:semicolon
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TINY
)paren
id|printf
(paren
l_string|&quot;I#%d&quot;
comma
id|num
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|num
)paren
(brace
macro_line|#if   SYM_CONF_DMA_ADDRESSING_MODE == 2
multiline_comment|/*&n;&t; *  SCRIPTS tell us that we may have to update &n;&t; *  64 bit DMA segment registers.&n;&t; */
r_case
id|SIR_DMAP_DIRTY
suffix:colon
id|sym_update_dmap_regs
c_func
(paren
id|np
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *  Command has been completed with error condition &n;&t; *  or has been auto-sensed.&n;&t; */
r_case
id|SIR_COMPLETE_ERROR
suffix:colon
id|sym_complete_error
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/*&n;&t; *  The C code is currently trying to recover from something.&n;&t; *  Typically, user want to abort some command.&n;&t; */
r_case
id|SIR_SCRIPT_STOPPED
suffix:colon
r_case
id|SIR_TARGET_SELECTED
suffix:colon
r_case
id|SIR_ABORT_SENT
suffix:colon
id|sym_sir_task_recovery
c_func
(paren
id|np
comma
id|num
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/*&n;&t; *  The device didn&squot;t go to MSG OUT phase after having &n;&t; *  been selected with ATN. We donnot want to handle &n;&t; *  that.&n;&t; */
r_case
id|SIR_SEL_ATN_NO_MSG_OUT
suffix:colon
id|printf
(paren
l_string|&quot;%s:%d: No MSG OUT phase after selection with ATN.&bslash;n&quot;
comma
id|sym_name
(paren
id|np
)paren
comma
id|target
)paren
suffix:semicolon
r_goto
id|out_stuck
suffix:semicolon
multiline_comment|/*&n;&t; *  The device didn&squot;t switch to MSG IN phase after &n;&t; *  having reseleted the initiator.&n;&t; */
r_case
id|SIR_RESEL_NO_MSG_IN
suffix:colon
id|printf
(paren
l_string|&quot;%s:%d: No MSG IN phase after reselection.&bslash;n&quot;
comma
id|sym_name
(paren
id|np
)paren
comma
id|target
)paren
suffix:semicolon
r_goto
id|out_stuck
suffix:semicolon
multiline_comment|/*&n;&t; *  After reselection, the device sent a message that wasn&squot;t &n;&t; *  an IDENTIFY.&n;&t; */
r_case
id|SIR_RESEL_NO_IDENTIFY
suffix:colon
id|printf
(paren
l_string|&quot;%s:%d: No IDENTIFY after reselection.&bslash;n&quot;
comma
id|sym_name
(paren
id|np
)paren
comma
id|target
)paren
suffix:semicolon
r_goto
id|out_stuck
suffix:semicolon
multiline_comment|/*&n;&t; *  The device reselected a LUN we donnot know about.&n;&t; */
r_case
id|SIR_RESEL_BAD_LUN
suffix:colon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_RESET
suffix:semicolon
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; *  The device reselected for an untagged nexus and we &n;&t; *  haven&squot;t any.&n;&t; */
r_case
id|SIR_RESEL_BAD_I_T_L
suffix:colon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_ABORT
suffix:semicolon
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; *  The device reselected for a tagged nexus that we donnot &n;&t; *  have.&n;&t; */
r_case
id|SIR_RESEL_BAD_I_T_L_Q
suffix:colon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_ABORT_TAG
suffix:semicolon
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; *  The SCRIPTS let us know that the device has grabbed &n;&t; *  our message and will abort the job.&n;&t; */
r_case
id|SIR_RESEL_ABORTED
suffix:colon
id|np-&gt;lastmsg
op_assign
id|np-&gt;msgout
(braket
l_int|0
)braket
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_NOOP
suffix:semicolon
id|printf
(paren
l_string|&quot;%s:%d: message %x sent on bad reselection.&bslash;n&quot;
comma
id|sym_name
(paren
id|np
)paren
comma
id|target
comma
id|np-&gt;lastmsg
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; *  The SCRIPTS let us know that a message has been &n;&t; *  successfully sent to the device.&n;&t; */
r_case
id|SIR_MSG_OUT_DONE
suffix:colon
id|np-&gt;lastmsg
op_assign
id|np-&gt;msgout
(braket
l_int|0
)braket
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_NOOP
suffix:semicolon
multiline_comment|/* Should we really care of that */
r_if
c_cond
(paren
id|np-&gt;lastmsg
op_eq
id|M_PARITY
op_logical_or
id|np-&gt;lastmsg
op_eq
id|M_ID_ERROR
)paren
(brace
r_if
c_cond
(paren
id|cp
)paren
(brace
id|cp-&gt;xerr_status
op_and_assign
op_complement
id|XE_PARITY_ERR
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp-&gt;xerr_status
)paren
id|OUTOFFB
(paren
id|HF_PRT
comma
id|HF_EXT_ERR
)paren
suffix:semicolon
)brace
)brace
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; *  The device didn&squot;t send a GOOD SCSI status.&n;&t; *  We may have some work to do prior to allow &n;&t; *  the SCRIPTS processor to continue.&n;&t; */
r_case
id|SIR_BAD_SCSI_STATUS
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_goto
id|out
suffix:semicolon
id|sym_sir_bad_scsi_status
c_func
(paren
id|np
comma
id|num
comma
id|cp
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/*&n;&t; *  We are asked by the SCRIPTS to prepare a &n;&t; *  REJECT message.&n;&t; */
r_case
id|SIR_REJECT_TO_SEND
suffix:colon
id|sym_print_msg
c_func
(paren
id|cp
comma
l_string|&quot;M_REJECT to send for &quot;
comma
id|np-&gt;msgin
)paren
suffix:semicolon
id|np-&gt;msgout
(braket
l_int|0
)braket
op_assign
id|M_REJECT
suffix:semicolon
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; *  We have been ODD at the end of a DATA IN &n;&t; *  transfer and the device didn&squot;t send a &n;&t; *  IGNORE WIDE RESIDUE message.&n;&t; *  It is a data overrun condition.&n;&t; */
r_case
id|SIR_SWIDE_OVERRUN
suffix:colon
r_if
c_cond
(paren
id|cp
)paren
(brace
id|OUTONB
(paren
id|HF_PRT
comma
id|HF_EXT_ERR
)paren
suffix:semicolon
id|cp-&gt;xerr_status
op_or_assign
id|XE_SWIDE_OVRUN
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; *  We have been ODD at the end of a DATA OUT &n;&t; *  transfer.&n;&t; *  It is a data underrun condition.&n;&t; */
r_case
id|SIR_SODL_UNDERRUN
suffix:colon
r_if
c_cond
(paren
id|cp
)paren
(brace
id|OUTONB
(paren
id|HF_PRT
comma
id|HF_EXT_ERR
)paren
suffix:semicolon
id|cp-&gt;xerr_status
op_or_assign
id|XE_SODL_UNRUN
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; *  The device wants us to tranfer more data than &n;&t; *  expected or in the wrong direction.&n;&t; *  The number of extra bytes is in scratcha.&n;&t; *  It is a data overrun condition.&n;&t; */
r_case
id|SIR_DATA_OVERRUN
suffix:colon
r_if
c_cond
(paren
id|cp
)paren
(brace
id|OUTONB
(paren
id|HF_PRT
comma
id|HF_EXT_ERR
)paren
suffix:semicolon
id|cp-&gt;xerr_status
op_or_assign
id|XE_EXTRA_DATA
suffix:semicolon
id|cp-&gt;extra_bytes
op_add_assign
id|INL
(paren
id|nc_scratcha
)paren
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; *  The device switched to an illegal phase (4/5).&n;&t; */
r_case
id|SIR_BAD_PHASE
suffix:colon
r_if
c_cond
(paren
id|cp
)paren
(brace
id|OUTONB
(paren
id|HF_PRT
comma
id|HF_EXT_ERR
)paren
suffix:semicolon
id|cp-&gt;xerr_status
op_or_assign
id|XE_BAD_PHASE
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; *  We received a message.&n;&t; */
r_case
id|SIR_MSG_RECEIVED
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_goto
id|out_stuck
suffix:semicolon
r_switch
c_cond
(paren
id|np-&gt;msgin
(braket
l_int|0
)braket
)paren
(brace
multiline_comment|/*&n;&t;&t; *  We received an extended message.&n;&t;&t; *  We handle MODIFY DATA POINTER, SDTR, WDTR &n;&t;&t; *  and reject all other extended messages.&n;&t;&t; */
r_case
id|M_EXTENDED
suffix:colon
r_switch
c_cond
(paren
id|np-&gt;msgin
(braket
l_int|2
)braket
)paren
(brace
r_case
id|M_X_MODIFY_DP
suffix:colon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_POINTER
)paren
id|sym_print_msg
c_func
(paren
id|cp
comma
l_string|&quot;modify DP&quot;
comma
id|np-&gt;msgin
)paren
suffix:semicolon
id|tmp
op_assign
(paren
id|np-&gt;msgin
(braket
l_int|3
)braket
op_lshift
l_int|24
)paren
op_plus
(paren
id|np-&gt;msgin
(braket
l_int|4
)braket
op_lshift
l_int|16
)paren
op_plus
(paren
id|np-&gt;msgin
(braket
l_int|5
)braket
op_lshift
l_int|8
)paren
op_plus
(paren
id|np-&gt;msgin
(braket
l_int|6
)braket
)paren
suffix:semicolon
id|sym_modify_dp
c_func
(paren
id|np
comma
id|tp
comma
id|cp
comma
id|tmp
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|M_X_SYNC_REQ
suffix:colon
id|sym_sync_nego
c_func
(paren
id|np
comma
id|tp
comma
id|cp
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|M_X_PPR_REQ
suffix:colon
id|sym_ppr_nego
c_func
(paren
id|np
comma
id|tp
comma
id|cp
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|M_X_WIDE_REQ
suffix:colon
id|sym_wide_nego
c_func
(paren
id|np
comma
id|tp
comma
id|cp
)paren
suffix:semicolon
r_return
suffix:semicolon
r_default
suffix:colon
r_goto
id|out_reject
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  We received a 1/2 byte message not handled from SCRIPTS.&n;&t;&t; *  We are only expecting MESSAGE REJECT and IGNORE WIDE &n;&t;&t; *  RESIDUE messages that haven&squot;t been anticipated by &n;&t;&t; *  SCRIPTS on SWIDE full condition. Unanticipated IGNORE &n;&t;&t; *  WIDE RESIDUE messages are aliased as MODIFY DP (-1).&n;&t;&t; */
r_case
id|M_IGN_RESIDUE
suffix:colon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_POINTER
)paren
id|sym_print_msg
c_func
(paren
id|cp
comma
l_string|&quot;ign wide residue&quot;
comma
id|np-&gt;msgin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;host_flags
op_amp
id|HF_SENSE
)paren
id|OUTL_DSP
(paren
id|SCRIPTA_BA
(paren
id|np
comma
id|clrack
)paren
)paren
suffix:semicolon
r_else
id|sym_modify_dp
c_func
(paren
id|np
comma
id|tp
comma
id|cp
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|M_REJECT
suffix:colon
r_if
c_cond
(paren
id|INB
(paren
id|HS_PRT
)paren
op_eq
id|HS_NEGOTIATE
)paren
id|sym_nego_rejected
c_func
(paren
id|np
comma
id|tp
comma
id|cp
)paren
suffix:semicolon
r_else
(brace
id|PRINT_ADDR
c_func
(paren
id|cp
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;M_REJECT received (%x:%x).&bslash;n&quot;
comma
id|scr_to_cpu
c_func
(paren
id|np-&gt;lastmsg
)paren
comma
id|np-&gt;msgout
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
r_goto
id|out_clrack
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_goto
id|out_reject
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/*&n;&t; *  We received an unknown message.&n;&t; *  Ignore all MSG IN phases and reject it.&n;&t; */
r_case
id|SIR_MSG_WEIRD
suffix:colon
id|sym_print_msg
c_func
(paren
id|cp
comma
l_string|&quot;WEIRD message received&quot;
comma
id|np-&gt;msgin
)paren
suffix:semicolon
id|OUTL_DSP
(paren
id|SCRIPTB_BA
(paren
id|np
comma
id|msg_weird
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/*&n;&t; *  Negotiation failed.&n;&t; *  Target does not send us the reply.&n;&t; *  Remove the HS_NEGOTIATE status.&n;&t; */
r_case
id|SIR_NEGO_FAILED
suffix:colon
id|OUTB
(paren
id|HS_PRT
comma
id|HS_BUSY
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Negotiation failed.&n;&t; *  Target does not want answer message.&n;&t; */
r_case
id|SIR_NEGO_PROTO
suffix:colon
id|sym_nego_default
c_func
(paren
id|np
comma
id|tp
comma
id|cp
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
suffix:semicolon
id|out
suffix:colon
id|OUTONB_STD
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
id|out_reject
suffix:colon
id|OUTL_DSP
(paren
id|SCRIPTB_BA
(paren
id|np
comma
id|msg_bad
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
id|out_clrack
suffix:colon
id|OUTL_DSP
(paren
id|SCRIPTA_BA
(paren
id|np
comma
id|clrack
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
id|out_stuck
suffix:colon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *  Acquire a control block&n; */
DECL|function|sym_get_ccb
id|ccb_p
id|sym_get_ccb
(paren
id|hcb_p
id|np
comma
id|u_char
id|tn
comma
id|u_char
id|ln
comma
id|u_char
id|tag_order
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|tn
)braket
suffix:semicolon
id|lcb_p
id|lp
op_assign
id|sym_lp
c_func
(paren
id|np
comma
id|tp
comma
id|ln
)paren
suffix:semicolon
id|u_short
id|tag
op_assign
id|NO_TAG
suffix:semicolon
id|SYM_QUEHEAD
op_star
id|qp
suffix:semicolon
id|ccb_p
id|cp
op_assign
(paren
id|ccb_p
)paren
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *  Look for a free CCB&n;&t; */
r_if
c_cond
(paren
id|sym_que_empty
c_func
(paren
op_amp
id|np-&gt;free_ccbq
)paren
)paren
(paren
r_void
)paren
id|sym_alloc_ccb
c_func
(paren
id|np
)paren
suffix:semicolon
id|qp
op_assign
id|sym_remque_head
c_func
(paren
op_amp
id|np-&gt;free_ccbq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|qp
)paren
r_goto
id|out
suffix:semicolon
id|cp
op_assign
id|sym_que_entry
c_func
(paren
id|qp
comma
r_struct
id|sym_ccb
comma
id|link_ccbq
)paren
suffix:semicolon
macro_line|#ifndef SYM_OPT_HANDLE_DEVICE_QUEUEING
multiline_comment|/*&n;&t; *  If the LCB is not yet available and the LUN&n;&t; *  has been probed ok, try to allocate the LCB.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|lp
op_logical_and
id|sym_is_bit
c_func
(paren
id|tp-&gt;lun_map
comma
id|ln
)paren
)paren
(brace
id|lp
op_assign
id|sym_alloc_lcb
c_func
(paren
id|np
comma
id|tn
comma
id|ln
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
r_goto
id|out_free
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; *  If the LCB is not available here, then the &n;&t; *  logical unit is not yet discovered. For those &n;&t; *  ones only accept 1 SCSI IO per logical unit, &n;&t; *  since we cannot allow disconnections.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sym_is_bit
c_func
(paren
id|tp-&gt;busy0_map
comma
id|ln
)paren
)paren
id|sym_set_bit
c_func
(paren
id|tp-&gt;busy0_map
comma
id|ln
)paren
suffix:semicolon
r_else
r_goto
id|out_free
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; *  If we have been asked for a tagged command.&n;&t;&t; */
r_if
c_cond
(paren
id|tag_order
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *  Debugging purpose.&n;&t;&t;&t; */
macro_line|#ifndef SYM_OPT_HANDLE_DEVICE_QUEUEING
m_assert
(paren
id|lp-&gt;busy_itl
op_eq
l_int|0
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t;&t; *  Allocate resources for tags if not yet.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;cb_tags
)paren
(brace
id|sym_alloc_lcb_tags
c_func
(paren
id|np
comma
id|tn
comma
id|ln
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;cb_tags
)paren
r_goto
id|out_free
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; *  Get a tag for this SCSI IO and set up&n;&t;&t;&t; *  the CCB bus address for reselection, &n;&t;&t;&t; *  and count it for this LUN.&n;&t;&t;&t; *  Toggle reselect path to tagged.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|lp-&gt;busy_itlq
OL
id|SYM_CONF_MAX_TASK
)paren
(brace
id|tag
op_assign
id|lp-&gt;cb_tags
(braket
id|lp-&gt;ia_tag
)braket
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|lp-&gt;ia_tag
op_eq
id|SYM_CONF_MAX_TASK
)paren
id|lp-&gt;ia_tag
op_assign
l_int|0
suffix:semicolon
op_increment
id|lp-&gt;busy_itlq
suffix:semicolon
macro_line|#ifndef SYM_OPT_HANDLE_DEVICE_QUEUEING
id|lp-&gt;itlq_tbl
(braket
id|tag
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|cp-&gt;ccb_ba
)paren
suffix:semicolon
id|lp-&gt;head.resel_sa
op_assign
id|cpu_to_scr
c_func
(paren
id|SCRIPTA_BA
(paren
id|np
comma
id|resel_tag
)paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef SYM_OPT_LIMIT_COMMAND_REORDERING
id|cp-&gt;tags_si
op_assign
id|lp-&gt;tags_si
suffix:semicolon
op_increment
id|lp-&gt;tags_sum
(braket
id|cp-&gt;tags_si
)braket
suffix:semicolon
op_increment
id|lp-&gt;tags_since
suffix:semicolon
macro_line|#endif
)brace
r_else
r_goto
id|out_free
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  This command will not be tagged.&n;&t;&t; *  If we already have either a tagged or untagged &n;&t;&t; *  one, refuse to overlap this untagged one.&n;&t;&t; */
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; *  Debugging purpose.&n;&t;&t;&t; */
macro_line|#ifndef SYM_OPT_HANDLE_DEVICE_QUEUEING
m_assert
(paren
id|lp-&gt;busy_itl
op_eq
l_int|0
op_logical_and
id|lp-&gt;busy_itlq
op_eq
l_int|0
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t;&t; *  Count this nexus for this LUN.&n;&t;&t;&t; *  Set up the CCB bus address for reselection.&n;&t;&t;&t; *  Toggle reselect path to untagged.&n;&t;&t;&t; */
op_increment
id|lp-&gt;busy_itl
suffix:semicolon
macro_line|#ifndef SYM_OPT_HANDLE_DEVICE_QUEUEING
r_if
c_cond
(paren
id|lp-&gt;busy_itl
op_eq
l_int|1
)paren
(brace
id|lp-&gt;head.itl_task_sa
op_assign
id|cpu_to_scr
c_func
(paren
id|cp-&gt;ccb_ba
)paren
suffix:semicolon
id|lp-&gt;head.resel_sa
op_assign
id|cpu_to_scr
c_func
(paren
id|SCRIPTA_BA
(paren
id|np
comma
id|resel_no_tag
)paren
)paren
suffix:semicolon
)brace
r_else
r_goto
id|out_free
suffix:semicolon
macro_line|#endif
)brace
)brace
multiline_comment|/*&n;&t; *  Put the CCB into the busy queue.&n;&t; */
id|sym_insque_tail
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
comma
op_amp
id|np-&gt;busy_ccbq
)paren
suffix:semicolon
macro_line|#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING
r_if
c_cond
(paren
id|lp
)paren
(brace
id|sym_remque
c_func
(paren
op_amp
id|cp-&gt;link2_ccbq
)paren
suffix:semicolon
id|sym_insque_tail
c_func
(paren
op_amp
id|cp-&gt;link2_ccbq
comma
op_amp
id|lp-&gt;waiting_ccbq
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; *  Remember all informations needed to free this CCB.&n;&t; */
id|cp-&gt;to_abort
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;tag
op_assign
id|tag
suffix:semicolon
id|cp-&gt;order
op_assign
id|tag_order
suffix:semicolon
id|cp-&gt;target
op_assign
id|tn
suffix:semicolon
id|cp-&gt;lun
op_assign
id|ln
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TAGS
)paren
(brace
id|PRINT_LUN
c_func
(paren
id|np
comma
id|tn
comma
id|ln
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;ccb @%p using tag %d.&bslash;n&quot;
comma
id|cp
comma
id|tag
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|cp
suffix:semicolon
id|out_free
suffix:colon
id|sym_insque_head
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
comma
op_amp
id|np-&gt;free_ccbq
)paren
suffix:semicolon
r_return
(paren
id|ccb_p
)paren
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Release one control block&n; */
DECL|function|sym_free_ccb
r_void
id|sym_free_ccb
(paren
id|hcb_p
id|np
comma
id|ccb_p
id|cp
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|cp-&gt;target
)braket
suffix:semicolon
id|lcb_p
id|lp
op_assign
id|sym_lp
c_func
(paren
id|np
comma
id|tp
comma
id|cp-&gt;lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TAGS
)paren
(brace
id|PRINT_LUN
c_func
(paren
id|np
comma
id|cp-&gt;target
comma
id|cp-&gt;lun
)paren
suffix:semicolon
id|printf
(paren
l_string|&quot;ccb @%p freeing tag %d.&bslash;n&quot;
comma
id|cp
comma
id|cp-&gt;tag
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  If LCB available,&n;&t; */
r_if
c_cond
(paren
id|lp
)paren
(brace
multiline_comment|/*&n;&t;&t; *  If tagged, release the tag, set the relect path &n;&t;&t; */
r_if
c_cond
(paren
id|cp-&gt;tag
op_ne
id|NO_TAG
)paren
(brace
macro_line|#ifdef SYM_OPT_LIMIT_COMMAND_REORDERING
op_decrement
id|lp-&gt;tags_sum
(braket
id|cp-&gt;tags_si
)braket
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t;&t; *  Free the tag value.&n;&t;&t;&t; */
id|lp-&gt;cb_tags
(braket
id|lp-&gt;if_tag
)braket
op_assign
id|cp-&gt;tag
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|lp-&gt;if_tag
op_eq
id|SYM_CONF_MAX_TASK
)paren
id|lp-&gt;if_tag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *  Make the reselect path invalid, &n;&t;&t;&t; *  and uncount this CCB.&n;&t;&t;&t; */
id|lp-&gt;itlq_tbl
(braket
id|cp-&gt;tag
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|np-&gt;bad_itlq_ba
)paren
suffix:semicolon
op_decrement
id|lp-&gt;busy_itlq
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Untagged */
multiline_comment|/*&n;&t;&t;&t; *  Make the reselect path invalid, &n;&t;&t;&t; *  and uncount this CCB.&n;&t;&t;&t; */
id|lp-&gt;head.itl_task_sa
op_assign
id|cpu_to_scr
c_func
(paren
id|np-&gt;bad_itl_ba
)paren
suffix:semicolon
op_decrement
id|lp-&gt;busy_itl
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  If no JOB active, make the LUN reselect path invalid.&n;&t;&t; */
r_if
c_cond
(paren
id|lp-&gt;busy_itlq
op_eq
l_int|0
op_logical_and
id|lp-&gt;busy_itl
op_eq
l_int|0
)paren
id|lp-&gt;head.resel_sa
op_assign
id|cpu_to_scr
c_func
(paren
id|SCRIPTB_BA
(paren
id|np
comma
id|resel_bad_lun
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Otherwise, we only accept 1 IO per LUN.&n;&t; *  Clear the bit that keeps track of this IO.&n;&t; */
r_else
id|sym_clr_bit
c_func
(paren
id|tp-&gt;busy0_map
comma
id|cp-&gt;lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  We donnot queue more than 1 ccb per target &n;&t; *  with negotiation at any time. If this ccb was &n;&t; *  used for negotiation, clear this info in the tcb.&n;&t; */
r_if
c_cond
(paren
id|cp
op_eq
id|tp-&gt;nego_cp
)paren
id|tp-&gt;nego_cp
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef SYM_CONF_IARB_SUPPORT
multiline_comment|/*&n;&t; *  If we just complete the last queued CCB,&n;&t; *  clear this info that is no longer relevant.&n;&t; */
r_if
c_cond
(paren
id|cp
op_eq
id|np-&gt;last_cp
)paren
id|np-&gt;last_cp
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *  Unmap user data from DMA map if needed.&n;&t; */
id|sym_data_dmamap_unload
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Make this CCB available.&n;&t; */
id|cp-&gt;cam_ccb
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;host_status
op_assign
id|HS_IDLE
suffix:semicolon
id|sym_remque
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
)paren
suffix:semicolon
id|sym_insque_head
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
comma
op_amp
id|np-&gt;free_ccbq
)paren
suffix:semicolon
macro_line|#ifdef&t;SYM_OPT_HANDLE_IO_TIMEOUT
multiline_comment|/*&n;&t; *  Cancel any pending timeout condition.&n;&t; */
id|sym_untimeout_ccb
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING
r_if
c_cond
(paren
id|lp
)paren
(brace
id|sym_remque
c_func
(paren
op_amp
id|cp-&gt;link2_ccbq
)paren
suffix:semicolon
id|sym_insque_tail
c_func
(paren
op_amp
id|cp-&gt;link2_ccbq
comma
op_amp
id|np-&gt;dummy_ccbq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;started
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;tag
op_ne
id|NO_TAG
)paren
op_decrement
id|lp-&gt;started_tags
suffix:semicolon
r_else
op_decrement
id|lp-&gt;started_no_tag
suffix:semicolon
)brace
)brace
id|cp-&gt;started
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; *  Allocate a CCB from memory and initialize its fixed part.&n; */
DECL|function|sym_alloc_ccb
r_static
id|ccb_p
id|sym_alloc_ccb
c_func
(paren
id|hcb_p
id|np
)paren
(brace
id|ccb_p
id|cp
op_assign
l_int|0
suffix:semicolon
r_int
id|hcode
suffix:semicolon
multiline_comment|/*&n;&t; *  Prevent from allocating more CCBs than we can &n;&t; *  queue to the controller.&n;&t; */
r_if
c_cond
(paren
id|np-&gt;actccbs
op_ge
id|SYM_CONF_MAX_START
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *  Allocate memory for this CCB.&n;&t; */
id|cp
op_assign
id|sym_calloc_dma
c_func
(paren
r_sizeof
(paren
r_struct
id|sym_ccb
)paren
comma
l_string|&quot;CCB&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp
)paren
r_goto
id|out_free
suffix:semicolon
multiline_comment|/*&n;&t; *  Allocate a bounce buffer for sense data.&n;&t; */
id|cp-&gt;sns_bbuf
op_assign
id|sym_calloc_dma
c_func
(paren
id|SYM_SNS_BBUF_LEN
comma
l_string|&quot;SNS_BBUF&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cp-&gt;sns_bbuf
)paren
r_goto
id|out_free
suffix:semicolon
multiline_comment|/*&n;&t; *  Allocate a map for the DMA of user data.&n;&t; */
r_if
c_cond
(paren
id|sym_data_dmamap_create
c_func
(paren
id|np
comma
id|cp
)paren
)paren
r_goto
id|out_free
suffix:semicolon
multiline_comment|/*&n;&t; *  Count it.&n;&t; */
id|np-&gt;actccbs
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; *  Compute the bus address of this ccb.&n;&t; */
id|cp-&gt;ccb_ba
op_assign
id|vtobus
c_func
(paren
id|cp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Insert this ccb into the hashed list.&n;&t; */
id|hcode
op_assign
id|CCB_HASH_CODE
c_func
(paren
id|cp-&gt;ccb_ba
)paren
suffix:semicolon
id|cp-&gt;link_ccbh
op_assign
id|np-&gt;ccbh
(braket
id|hcode
)braket
suffix:semicolon
id|np-&gt;ccbh
(braket
id|hcode
)braket
op_assign
id|cp
suffix:semicolon
multiline_comment|/*&n;&t; *  Initialyze the start and restart actions.&n;&t; */
id|cp-&gt;phys.head.go.start
op_assign
id|cpu_to_scr
c_func
(paren
id|SCRIPTA_BA
(paren
id|np
comma
id|idle
)paren
)paren
suffix:semicolon
id|cp-&gt;phys.head.go.restart
op_assign
id|cpu_to_scr
c_func
(paren
id|SCRIPTB_BA
(paren
id|np
comma
id|bad_i_t_l
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Initilialyze some other fields.&n;&t; */
id|cp-&gt;phys.smsg_ext.addr
op_assign
id|cpu_to_scr
c_func
(paren
id|HCB_BA
c_func
(paren
id|np
comma
id|msgin
(braket
l_int|2
)braket
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Chain into free ccb queue.&n;&t; */
id|sym_insque_head
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
comma
op_amp
id|np-&gt;free_ccbq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Chain into optionnal lists.&n;&t; */
macro_line|#ifdef&t;SYM_OPT_HANDLE_IO_TIMEOUT
id|sym_insque_head
c_func
(paren
op_amp
id|cp-&gt;tmo_linkq
comma
op_amp
id|np-&gt;tmo0_ccbq
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING
id|sym_insque_head
c_func
(paren
op_amp
id|cp-&gt;link2_ccbq
comma
op_amp
id|np-&gt;dummy_ccbq
)paren
suffix:semicolon
macro_line|#endif
r_return
id|cp
suffix:semicolon
id|out_free
suffix:colon
r_if
c_cond
(paren
id|cp
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;sns_bbuf
)paren
id|sym_mfree_dma
c_func
(paren
id|cp-&gt;sns_bbuf
comma
id|SYM_SNS_BBUF_LEN
comma
l_string|&quot;SNS_BBUF&quot;
)paren
suffix:semicolon
id|sym_mfree_dma
c_func
(paren
id|cp
comma
r_sizeof
(paren
op_star
id|cp
)paren
comma
l_string|&quot;CCB&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Look up a CCB from a DSA value.&n; */
DECL|function|sym_ccb_from_dsa
r_static
id|ccb_p
id|sym_ccb_from_dsa
c_func
(paren
id|hcb_p
id|np
comma
id|u32
id|dsa
)paren
(brace
r_int
id|hcode
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
id|hcode
op_assign
id|CCB_HASH_CODE
c_func
(paren
id|dsa
)paren
suffix:semicolon
id|cp
op_assign
id|np-&gt;ccbh
(braket
id|hcode
)braket
suffix:semicolon
r_while
c_loop
(paren
id|cp
)paren
(brace
r_if
c_cond
(paren
id|cp-&gt;ccb_ba
op_eq
id|dsa
)paren
r_break
suffix:semicolon
id|cp
op_assign
id|cp-&gt;link_ccbh
suffix:semicolon
)brace
r_return
id|cp
suffix:semicolon
)brace
multiline_comment|/*&n; *  Target control block initialisation.&n; *  Nothing important to do at the moment.&n; */
DECL|function|sym_init_tcb
r_static
r_void
id|sym_init_tcb
(paren
id|hcb_p
id|np
comma
id|u_char
id|tn
)paren
(brace
macro_line|#if 0&t;/*  Hmmm... this checking looks paranoid. */
multiline_comment|/*&n;&t; *  Check some alignments required by the chip.&n;&t; */
m_assert
(paren
(paren
(paren
m_offsetof
(paren
r_struct
id|sym_reg
comma
id|nc_sxfer
)paren
op_xor
m_offsetof
(paren
r_struct
id|sym_tcb
comma
id|head.sval
)paren
)paren
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
suffix:semicolon
m_assert
(paren
(paren
(paren
m_offsetof
(paren
r_struct
id|sym_reg
comma
id|nc_scntl3
)paren
op_xor
m_offsetof
(paren
r_struct
id|sym_tcb
comma
id|head.wval
)paren
)paren
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; *  Lun control block allocation and initialization.&n; */
DECL|function|sym_alloc_lcb
id|lcb_p
id|sym_alloc_lcb
(paren
id|hcb_p
id|np
comma
id|u_char
id|tn
comma
id|u_char
id|ln
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|tn
)braket
suffix:semicolon
id|lcb_p
id|lp
op_assign
id|sym_lp
c_func
(paren
id|np
comma
id|tp
comma
id|ln
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Already done, just return.&n;&t; */
r_if
c_cond
(paren
id|lp
)paren
r_return
id|lp
suffix:semicolon
multiline_comment|/*&n;&t; *  Donnot allow LUN control block &n;&t; *  allocation for not probed LUNs.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sym_is_bit
c_func
(paren
id|tp-&gt;lun_map
comma
id|ln
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *  Initialize the target control block if not yet.&n;&t; */
id|sym_init_tcb
(paren
id|np
comma
id|tn
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Allocate the LCB bus address array.&n;&t; *  Compute the bus address of this table.&n;&t; */
r_if
c_cond
(paren
id|ln
op_logical_and
op_logical_neg
id|tp-&gt;luntbl
)paren
(brace
r_int
id|i
suffix:semicolon
id|tp-&gt;luntbl
op_assign
id|sym_calloc_dma
c_func
(paren
l_int|256
comma
l_string|&quot;LUNTBL&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;luntbl
)paren
r_goto
id|fail
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|64
suffix:semicolon
id|i
op_increment
)paren
id|tp-&gt;luntbl
(braket
id|i
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
c_func
(paren
op_amp
id|np-&gt;badlun_sa
)paren
)paren
suffix:semicolon
id|tp-&gt;head.luntbl_sa
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
c_func
(paren
id|tp-&gt;luntbl
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Allocate the table of pointers for LUN(s) &gt; 0, if needed.&n;&t; */
r_if
c_cond
(paren
id|ln
op_logical_and
op_logical_neg
id|tp-&gt;lunmp
)paren
(brace
id|tp-&gt;lunmp
op_assign
id|sym_calloc
c_func
(paren
id|SYM_CONF_MAX_LUN
op_star
r_sizeof
(paren
id|lcb_p
)paren
comma
l_string|&quot;LUNMP&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;lunmp
)paren
r_goto
id|fail
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Allocate the lcb.&n;&t; *  Make it available to the chip.&n;&t; */
id|lp
op_assign
id|sym_calloc_dma
c_func
(paren
r_sizeof
(paren
r_struct
id|sym_lcb
)paren
comma
l_string|&quot;LCB&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
r_goto
id|fail
suffix:semicolon
r_if
c_cond
(paren
id|ln
)paren
(brace
id|tp-&gt;lunmp
(braket
id|ln
)braket
op_assign
id|lp
suffix:semicolon
id|tp-&gt;luntbl
(braket
id|ln
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
c_func
(paren
id|lp
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|tp-&gt;lun0p
op_assign
id|lp
suffix:semicolon
id|tp-&gt;head.lun0_sa
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
c_func
(paren
id|lp
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Let the itl task point to error handling.&n;&t; */
id|lp-&gt;head.itl_task_sa
op_assign
id|cpu_to_scr
c_func
(paren
id|np-&gt;bad_itl_ba
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Set the reselect pattern to our default. :)&n;&t; */
id|lp-&gt;head.resel_sa
op_assign
id|cpu_to_scr
c_func
(paren
id|SCRIPTB_BA
(paren
id|np
comma
id|resel_bad_lun
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Set user capabilities.&n;&t; */
id|lp-&gt;user_flags
op_assign
id|tp-&gt;usrflags
op_amp
(paren
id|SYM_DISC_ENABLED
op_or
id|SYM_TAGS_ENABLED
)paren
suffix:semicolon
macro_line|#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING
multiline_comment|/*&n;&t; *  Initialize device queueing.&n;&t; */
id|sym_que_init
c_func
(paren
op_amp
id|lp-&gt;waiting_ccbq
)paren
suffix:semicolon
id|sym_que_init
c_func
(paren
op_amp
id|lp-&gt;started_ccbq
)paren
suffix:semicolon
id|lp-&gt;started_max
op_assign
id|SYM_CONF_MAX_TASK
suffix:semicolon
id|lp-&gt;started_limit
op_assign
id|SYM_CONF_MAX_TASK
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *  If we are busy, count the IO.&n;&t; */
r_if
c_cond
(paren
id|sym_is_bit
c_func
(paren
id|tp-&gt;busy0_map
comma
id|ln
)paren
)paren
(brace
id|lp-&gt;busy_itl
op_assign
l_int|1
suffix:semicolon
id|sym_clr_bit
c_func
(paren
id|tp-&gt;busy0_map
comma
id|ln
)paren
suffix:semicolon
)brace
id|fail
suffix:colon
r_return
id|lp
suffix:semicolon
)brace
multiline_comment|/*&n; *  Allocate LCB resources for tagged command queuing.&n; */
DECL|function|sym_alloc_lcb_tags
r_static
r_void
id|sym_alloc_lcb_tags
(paren
id|hcb_p
id|np
comma
id|u_char
id|tn
comma
id|u_char
id|ln
)paren
(brace
id|tcb_p
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|tn
)braket
suffix:semicolon
id|lcb_p
id|lp
op_assign
id|sym_lp
c_func
(paren
id|np
comma
id|tp
comma
id|ln
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; *  If LCB not available, try to allocate it.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|lp
op_logical_and
op_logical_neg
(paren
id|lp
op_assign
id|sym_alloc_lcb
c_func
(paren
id|np
comma
id|tn
comma
id|ln
)paren
)paren
)paren
r_goto
id|fail
suffix:semicolon
multiline_comment|/*&n;&t; *  Allocate the task table and and the tag allocation &n;&t; *  circular buffer. We want both or none.&n;&t; */
id|lp-&gt;itlq_tbl
op_assign
id|sym_calloc_dma
c_func
(paren
id|SYM_CONF_MAX_TASK
op_star
l_int|4
comma
l_string|&quot;ITLQ_TBL&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;itlq_tbl
)paren
r_goto
id|fail
suffix:semicolon
id|lp-&gt;cb_tags
op_assign
id|sym_calloc
c_func
(paren
id|SYM_CONF_MAX_TASK
comma
l_string|&quot;CB_TAGS&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;cb_tags
)paren
(brace
id|sym_mfree_dma
c_func
(paren
id|lp-&gt;itlq_tbl
comma
id|SYM_CONF_MAX_TASK
op_star
l_int|4
comma
l_string|&quot;ITLQ_TBL&quot;
)paren
suffix:semicolon
id|lp-&gt;itlq_tbl
op_assign
l_int|0
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Initialize the task table with invalid entries.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SYM_CONF_MAX_TASK
suffix:semicolon
id|i
op_increment
)paren
id|lp-&gt;itlq_tbl
(braket
id|i
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|np-&gt;notask_ba
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Fill up the tag buffer with tag numbers.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SYM_CONF_MAX_TASK
suffix:semicolon
id|i
op_increment
)paren
id|lp-&gt;cb_tags
(braket
id|i
)braket
op_assign
id|i
suffix:semicolon
multiline_comment|/*&n;&t; *  Make the task table available to SCRIPTS, &n;&t; *  And accept tagged commands now.&n;&t; */
id|lp-&gt;head.itlq_tbl_sa
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
c_func
(paren
id|lp-&gt;itlq_tbl
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
id|fail
suffix:colon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *  Queue a SCSI IO to the controller.&n; */
DECL|function|sym_queue_scsiio
r_int
id|sym_queue_scsiio
c_func
(paren
id|hcb_p
id|np
comma
id|cam_scsiio_p
id|csio
comma
id|ccb_p
id|cp
)paren
(brace
id|tcb_p
id|tp
suffix:semicolon
id|lcb_p
id|lp
suffix:semicolon
id|u_char
id|idmsg
comma
op_star
id|msgptr
suffix:semicolon
id|u_int
id|msglen
suffix:semicolon
multiline_comment|/*&n;&t; *  Keep track of the IO in our CCB.&n;&t; */
id|cp-&gt;cam_ccb
op_assign
(paren
id|cam_ccb_p
)paren
id|csio
suffix:semicolon
multiline_comment|/*&n;&t; *  Retreive the target descriptor.&n;&t; */
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|cp-&gt;target
)braket
suffix:semicolon
multiline_comment|/*&n;&t; *  Retreive the lun descriptor.&n;&t; */
id|lp
op_assign
id|sym_lp
c_func
(paren
id|np
comma
id|tp
comma
id|cp-&gt;lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Build the IDENTIFY message.&n;&t; */
id|idmsg
op_assign
id|M_IDENTIFY
op_or
id|cp-&gt;lun
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;tag
op_ne
id|NO_TAG
op_logical_or
(paren
id|lp
op_logical_and
(paren
id|lp-&gt;curr_flags
op_amp
id|SYM_DISC_ENABLED
)paren
)paren
)paren
id|idmsg
op_or_assign
l_int|0x40
suffix:semicolon
id|msgptr
op_assign
id|cp-&gt;scsi_smsg
suffix:semicolon
id|msglen
op_assign
l_int|0
suffix:semicolon
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|idmsg
suffix:semicolon
multiline_comment|/*&n;&t; *  Build the tag message if present.&n;&t; */
r_if
c_cond
(paren
id|cp-&gt;tag
op_ne
id|NO_TAG
)paren
(brace
id|u_char
id|order
op_assign
id|cp-&gt;order
suffix:semicolon
r_switch
c_cond
(paren
id|order
)paren
(brace
r_case
id|M_ORDERED_TAG
suffix:colon
r_break
suffix:semicolon
r_case
id|M_HEAD_TAG
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|order
op_assign
id|M_SIMPLE_TAG
suffix:semicolon
)brace
macro_line|#ifdef SYM_OPT_LIMIT_COMMAND_REORDERING
multiline_comment|/*&n;&t;&t; *  Avoid too much reordering of SCSI commands.&n;&t;&t; *  The algorithm tries to prevent completion of any &n;&t;&t; *  tagged command from being delayed against more &n;&t;&t; *  than 3 times the max number of queued commands.&n;&t;&t; */
r_if
c_cond
(paren
id|lp
op_logical_and
id|lp-&gt;tags_since
OG
l_int|3
op_star
id|SYM_CONF_MAX_TAG
)paren
(brace
id|lp-&gt;tags_si
op_assign
op_logical_neg
(paren
id|lp-&gt;tags_si
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tags_sum
(braket
id|lp-&gt;tags_si
)braket
)paren
(brace
id|order
op_assign
id|M_ORDERED_TAG
suffix:semicolon
r_if
c_cond
(paren
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_TAGS
)paren
op_logical_or
id|sym_verbose
OG
l_int|1
)paren
(brace
id|PRINT_ADDR
c_func
(paren
id|cp
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;ordered tag forced.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|lp-&gt;tags_since
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|order
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  For less than 128 tags, actual tags are numbered &n;&t;&t; *  1,3,5,..2*MAXTAGS+1,since we may have to deal &n;&t;&t; *  with devices that have problems with #TAG 0 or too &n;&t;&t; *  great #TAG numbers. For more tags (up to 256), &n;&t;&t; *  we use directly our tag number.&n;&t;&t; */
macro_line|#if SYM_CONF_MAX_TASK &gt; (512/4)
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
id|cp-&gt;tag
suffix:semicolon
macro_line|#else
id|msgptr
(braket
id|msglen
op_increment
)braket
op_assign
(paren
id|cp-&gt;tag
op_lshift
l_int|1
)paren
op_plus
l_int|1
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n;&t; *  Build a negotiation message if needed.&n;&t; *  (nego_status is filled by sym_prepare_nego())&n;&t; */
id|cp-&gt;nego_status
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;tinfo.curr.width
op_ne
id|tp-&gt;tinfo.goal.width
op_logical_or
id|tp-&gt;tinfo.curr.period
op_ne
id|tp-&gt;tinfo.goal.period
op_logical_or
id|tp-&gt;tinfo.curr.offset
op_ne
id|tp-&gt;tinfo.goal.offset
op_logical_or
id|tp-&gt;tinfo.curr.options
op_ne
id|tp-&gt;tinfo.goal.options
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;nego_cp
op_logical_and
id|lp
)paren
id|msglen
op_add_assign
id|sym_prepare_nego
c_func
(paren
id|np
comma
id|cp
comma
l_int|0
comma
id|msgptr
op_plus
id|msglen
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Startqueue&n;&t; */
id|cp-&gt;phys.head.go.start
op_assign
id|cpu_to_scr
c_func
(paren
id|SCRIPTA_BA
(paren
id|np
comma
id|select
)paren
)paren
suffix:semicolon
id|cp-&gt;phys.head.go.restart
op_assign
id|cpu_to_scr
c_func
(paren
id|SCRIPTA_BA
(paren
id|np
comma
id|resel_dsa
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  select&n;&t; */
id|cp-&gt;phys.select.sel_id
op_assign
id|cp-&gt;target
suffix:semicolon
id|cp-&gt;phys.select.sel_scntl3
op_assign
id|tp-&gt;head.wval
suffix:semicolon
id|cp-&gt;phys.select.sel_sxfer
op_assign
id|tp-&gt;head.sval
suffix:semicolon
id|cp-&gt;phys.select.sel_scntl4
op_assign
id|tp-&gt;head.uval
suffix:semicolon
multiline_comment|/*&n;&t; *  message&n;&t; */
id|cp-&gt;phys.smsg.addr
op_assign
id|cpu_to_scr
c_func
(paren
id|CCB_BA
(paren
id|cp
comma
id|scsi_smsg
)paren
)paren
suffix:semicolon
id|cp-&gt;phys.smsg.size
op_assign
id|cpu_to_scr
c_func
(paren
id|msglen
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  status&n;&t; */
id|cp-&gt;host_xflags
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;host_status
op_assign
id|cp-&gt;nego_status
ques
c_cond
id|HS_NEGOTIATE
suffix:colon
id|HS_BUSY
suffix:semicolon
id|cp-&gt;ssss_status
op_assign
id|S_ILLEGAL
suffix:semicolon
id|cp-&gt;xerr_status
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;host_flags
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;extra_bytes
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *  extreme data pointer.&n;&t; *  shall be positive, so -1 is lower than lowest.:)&n;&t; */
id|cp-&gt;ext_sg
op_assign
op_minus
l_int|1
suffix:semicolon
id|cp-&gt;ext_ofs
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *  Build the CDB and DATA descriptor block &n;&t; *  and start the IO.&n;&t; */
r_return
id|sym_setup_data_and_start
c_func
(paren
id|np
comma
id|csio
comma
id|cp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Reset a SCSI target (all LUNs of this target).&n; */
DECL|function|sym_reset_scsi_target
r_int
id|sym_reset_scsi_target
c_func
(paren
id|hcb_p
id|np
comma
r_int
id|target
)paren
(brace
id|tcb_p
id|tp
suffix:semicolon
r_if
c_cond
(paren
id|target
op_eq
id|np-&gt;myaddr
op_logical_or
(paren
id|u_int
)paren
id|target
op_ge
id|SYM_CONF_MAX_TARGET
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
id|tp-&gt;to_reset
op_assign
l_int|1
suffix:semicolon
id|np-&gt;istat_sem
op_assign
id|SEM
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
id|SIGP
op_or
id|SEM
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Abort a SCSI IO.&n; */
DECL|function|sym_abort_ccb
r_int
id|sym_abort_ccb
c_func
(paren
id|hcb_p
id|np
comma
id|ccb_p
id|cp
comma
r_int
id|timed_out
)paren
(brace
multiline_comment|/*&n;&t; *  Check that the IO is active.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|cp
op_logical_or
op_logical_neg
id|cp-&gt;host_status
op_logical_or
id|cp-&gt;host_status
op_eq
id|HS_WAIT
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; *  If a previous abort didn&squot;t succeed in time,&n;&t; *  perform a BUS reset.&n;&t; */
r_if
c_cond
(paren
id|cp-&gt;to_abort
)paren
(brace
id|sym_reset_scsi_bus
c_func
(paren
id|np
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Mark the CCB for abort and allow time for.&n;&t; */
id|cp-&gt;to_abort
op_assign
id|timed_out
ques
c_cond
l_int|2
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; *  Tell the SCRIPTS processor to stop and synchronize with us.&n;&t; */
id|np-&gt;istat_sem
op_assign
id|SEM
suffix:semicolon
id|OUTB
(paren
id|nc_istat
comma
id|SIGP
op_or
id|SEM
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sym_abort_scsiio
r_int
id|sym_abort_scsiio
c_func
(paren
id|hcb_p
id|np
comma
id|cam_ccb_p
id|ccb
comma
r_int
id|timed_out
)paren
(brace
id|ccb_p
id|cp
suffix:semicolon
id|SYM_QUEHEAD
op_star
id|qp
suffix:semicolon
multiline_comment|/*&n;&t; *  Look up our CCB control block.&n;&t; */
id|cp
op_assign
l_int|0
suffix:semicolon
id|FOR_EACH_QUEUED_ELEMENT
c_func
(paren
op_amp
id|np-&gt;busy_ccbq
comma
id|qp
)paren
(brace
id|ccb_p
id|cp2
op_assign
id|sym_que_entry
c_func
(paren
id|qp
comma
r_struct
id|sym_ccb
comma
id|link_ccbq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp2-&gt;cam_ccb
op_eq
id|ccb
)paren
(brace
id|cp
op_assign
id|cp2
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|sym_abort_ccb
c_func
(paren
id|np
comma
id|cp
comma
id|timed_out
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Complete execution of a SCSI command with extented &n; *  error, SCSI status error, or having been auto-sensed.&n; *&n; *  The SCRIPTS processor is not running there, so we &n; *  can safely access IO registers and remove JOBs from  &n; *  the START queue.&n; *  SCRATCHA is assumed to have been loaded with STARTPOS &n; *  before the SCRIPTS called the C code.&n; */
DECL|function|sym_complete_error
r_void
id|sym_complete_error
(paren
id|hcb_p
id|np
comma
id|ccb_p
id|cp
)paren
(brace
id|tcb_p
id|tp
suffix:semicolon
id|lcb_p
id|lp
suffix:semicolon
r_int
id|resid
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; *  Paranoid check. :)&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|cp
op_logical_or
op_logical_neg
id|cp-&gt;cam_ccb
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
(paren
id|DEBUG_TINY
op_or
id|DEBUG_RESULT
)paren
)paren
(brace
id|printf
(paren
l_string|&quot;CCB=%lx STAT=%x/%x/%x DEV=%d/%d&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|cp
comma
id|cp-&gt;host_status
comma
id|cp-&gt;ssss_status
comma
id|cp-&gt;host_flags
comma
id|cp-&gt;target
comma
id|cp-&gt;lun
)paren
suffix:semicolon
id|MDELAY
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Get target and lun pointers.&n;&t; */
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|cp-&gt;target
)braket
suffix:semicolon
id|lp
op_assign
id|sym_lp
c_func
(paren
id|np
comma
id|tp
comma
id|cp-&gt;lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Check for extended errors.&n;&t; */
r_if
c_cond
(paren
id|cp-&gt;xerr_status
)paren
(brace
r_if
c_cond
(paren
id|sym_verbose
)paren
id|sym_print_xerr
c_func
(paren
id|cp
comma
id|cp-&gt;xerr_status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
)paren
id|cp-&gt;host_status
op_assign
id|HS_COMP_ERR
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Calculate the residual.&n;&t; */
id|resid
op_assign
id|sym_compute_residual
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SYM_SETUP_RESIDUAL_SUPPORT
)paren
(brace
multiline_comment|/* If user does not want residuals */
id|resid
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* throw them away. :)&t;&t;    */
id|cp-&gt;sv_resid
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_2_0_X
r_if
c_cond
(paren
id|resid
)paren
id|printf
c_func
(paren
l_string|&quot;XXXX RESID= %d - 0x%x&bslash;n&quot;
comma
id|resid
comma
id|resid
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *  Dequeue all queued CCBs for that device &n;&t; *  not yet started by SCRIPTS.&n;&t; */
id|i
op_assign
(paren
id|INL
(paren
id|nc_scratcha
)paren
op_minus
id|np-&gt;squeue_ba
)paren
op_div
l_int|4
suffix:semicolon
id|i
op_assign
id|sym_dequeue_from_squeue
c_func
(paren
id|np
comma
id|i
comma
id|cp-&gt;target
comma
id|cp-&gt;lun
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Restart the SCRIPTS processor.&n;&t; */
id|OUTL_DSP
(paren
id|SCRIPTA_BA
(paren
id|np
comma
id|start
)paren
)paren
suffix:semicolon
macro_line|#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING
r_if
c_cond
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
op_logical_and
id|cp-&gt;ssss_status
op_eq
id|S_QUEUE_FULL
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|lp
op_logical_or
id|lp-&gt;started_tags
op_minus
id|i
OL
l_int|2
)paren
r_goto
id|weirdness
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Decrease queue depth as needed.&n;&t;&t; */
id|lp-&gt;started_max
op_assign
id|lp-&gt;started_tags
op_minus
id|i
op_minus
l_int|1
suffix:semicolon
id|lp-&gt;num_sgood
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sym_verbose
op_ge
l_int|2
)paren
(brace
id|PRINT_LUN
c_func
(paren
id|np
comma
id|cp-&gt;target
comma
id|cp-&gt;lun
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot; queue depth is now %d&bslash;n&quot;
comma
id|lp-&gt;started_max
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  Repair the CCB.&n;&t;&t; */
id|cp-&gt;host_status
op_assign
id|HS_BUSY
suffix:semicolon
id|cp-&gt;ssss_status
op_assign
id|S_ILLEGAL
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Let&squot;s requeue it to device.&n;&t;&t; */
id|sym_set_cam_status
c_func
(paren
id|cp-&gt;cam_ccb
comma
id|CAM_REQUEUE_REQ
)paren
suffix:semicolon
r_goto
id|finish
suffix:semicolon
)brace
id|weirdness
suffix:colon
macro_line|#endif
multiline_comment|/*&n;&t; *  Synchronize DMA map if needed.&n;&t; */
id|sym_data_dmamap_postsync
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Build result in CAM ccb.&n;&t; */
id|sym_set_cam_result_error
c_func
(paren
id|np
comma
id|cp
comma
id|resid
)paren
suffix:semicolon
macro_line|#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING
id|finish
suffix:colon
macro_line|#endif
multiline_comment|/*&n;&t; *  Add this one to the COMP queue.&n;&t; */
id|sym_remque
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
)paren
suffix:semicolon
id|sym_insque_head
c_func
(paren
op_amp
id|cp-&gt;link_ccbq
comma
op_amp
id|np-&gt;comp_ccbq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Complete all those commands with either error &n;&t; *  or requeue condition.&n;&t; */
id|sym_flush_comp_queue
c_func
(paren
id|np
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING
multiline_comment|/*&n;&t; *  Donnot start more than 1 command after an error.&n;&t; */
r_if
c_cond
(paren
id|lp
)paren
id|sym_start_next_ccbs
c_func
(paren
id|np
comma
id|lp
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; *  Complete execution of a successful SCSI command.&n; *&n; *  Only successful commands go to the DONE queue, &n; *  since we need to have the SCRIPTS processor &n; *  stopped on any error condition.&n; *  The SCRIPTS processor is running while we are &n; *  completing successful commands.&n; */
DECL|function|sym_complete_ok
r_void
id|sym_complete_ok
(paren
id|hcb_p
id|np
comma
id|ccb_p
id|cp
)paren
(brace
id|tcb_p
id|tp
suffix:semicolon
id|lcb_p
id|lp
suffix:semicolon
id|cam_ccb_p
id|ccb
suffix:semicolon
r_int
id|resid
suffix:semicolon
multiline_comment|/*&n;&t; *  Paranoid check. :)&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|cp
op_logical_or
op_logical_neg
id|cp-&gt;cam_ccb
)paren
r_return
suffix:semicolon
m_assert
(paren
id|cp-&gt;host_status
op_eq
id|HS_COMPLETE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Get user command.&n;&t; */
id|ccb
op_assign
id|cp-&gt;cam_ccb
suffix:semicolon
multiline_comment|/*&n;&t; *  Get target and lun pointers.&n;&t; */
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|cp-&gt;target
)braket
suffix:semicolon
id|lp
op_assign
id|sym_lp
c_func
(paren
id|np
comma
id|tp
comma
id|cp-&gt;lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Assume device discovered on first success.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
id|sym_set_bit
c_func
(paren
id|tp-&gt;lun_map
comma
id|cp-&gt;lun
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  If all data have been transferred, given than no&n;&t; *  extended error did occur, there is no residual.&n;&t; */
id|resid
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cp-&gt;phys.head.lastp
op_ne
id|sym_goalp
c_func
(paren
id|cp
)paren
)paren
id|resid
op_assign
id|sym_compute_residual
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Wrong transfer residuals may be worse than just always &n;&t; *  returning zero. User can disable this feature from &n;&t; *  sym_conf.h. Residual support is enabled by default.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|SYM_SETUP_RESIDUAL_SUPPORT
)paren
id|resid
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG_2_0_X
r_if
c_cond
(paren
id|resid
)paren
id|printf
c_func
(paren
l_string|&quot;XXXX RESID= %d - 0x%x&bslash;n&quot;
comma
id|resid
comma
id|resid
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *  Synchronize DMA map if needed.&n;&t; */
id|sym_data_dmamap_postsync
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Build result in CAM ccb.&n;&t; */
id|sym_set_cam_result_ok
c_func
(paren
id|np
comma
id|cp
comma
id|resid
)paren
suffix:semicolon
macro_line|#ifdef&t;SYM_OPT_SNIFF_INQUIRY
multiline_comment|/*&n;&t; *  On standard INQUIRY response (EVPD and CmDt &n;&t; *  not set), sniff out device capabilities.&n;&t; */
r_if
c_cond
(paren
id|cp-&gt;cdb_buf
(braket
l_int|0
)braket
op_eq
id|INQUIRY
op_logical_and
op_logical_neg
(paren
id|cp-&gt;cdb_buf
(braket
l_int|1
)braket
op_amp
l_int|0x3
)paren
)paren
id|sym_sniff_inquiry
c_func
(paren
id|np
comma
id|cp-&gt;cam_ccb
comma
id|resid
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING
multiline_comment|/*&n;&t; *  If max number of started ccbs had been reduced,&n;&t; *  increase it if 200 good status received.&n;&t; */
r_if
c_cond
(paren
id|lp
op_logical_and
id|lp-&gt;started_max
OL
id|lp-&gt;started_limit
)paren
(brace
op_increment
id|lp-&gt;num_sgood
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;num_sgood
op_ge
l_int|200
)paren
(brace
id|lp-&gt;num_sgood
op_assign
l_int|0
suffix:semicolon
op_increment
id|lp-&gt;started_max
suffix:semicolon
r_if
c_cond
(paren
id|sym_verbose
op_ge
l_int|2
)paren
(brace
id|PRINT_LUN
c_func
(paren
id|np
comma
id|cp-&gt;target
comma
id|cp-&gt;lun
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot; queue depth is now %d&bslash;n&quot;
comma
id|lp-&gt;started_max
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t; *  Free our CCB.&n;&t; */
id|sym_free_ccb
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
macro_line|#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING
multiline_comment|/*&n;&t; *  Requeue a couple of awaiting scsi commands.&n;&t; */
r_if
c_cond
(paren
id|lp
op_logical_and
op_logical_neg
id|sym_que_empty
c_func
(paren
op_amp
id|lp-&gt;waiting_ccbq
)paren
)paren
id|sym_start_next_ccbs
c_func
(paren
id|np
comma
id|lp
comma
l_int|2
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *  Complete the command.&n;&t; */
id|sym_xpt_done
c_func
(paren
id|np
comma
id|ccb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Soft-attach the controller.&n; */
macro_line|#ifdef SYM_OPT_NVRAM_PRE_READ
DECL|function|sym_hcb_attach
r_int
id|sym_hcb_attach
c_func
(paren
id|hcb_p
id|np
comma
r_struct
id|sym_fw
op_star
id|fw
comma
r_struct
id|sym_nvram
op_star
id|nvram
)paren
macro_line|#else
r_int
id|sym_hcb_attach
c_func
(paren
id|hcb_p
id|np
comma
r_struct
id|sym_fw
op_star
id|fw
)paren
macro_line|#endif
(brace
macro_line|#ifndef SYM_OPT_NVRAM_PRE_READ
r_struct
id|sym_nvram
id|nvram_buf
comma
op_star
id|nvram
op_assign
op_amp
id|nvram_buf
suffix:semicolon
macro_line|#endif
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; *  Get some info about the firmware.&n;&t; */
id|np-&gt;scripta_sz
op_assign
id|fw-&gt;a_size
suffix:semicolon
id|np-&gt;scriptb_sz
op_assign
id|fw-&gt;b_size
suffix:semicolon
id|np-&gt;scriptz_sz
op_assign
id|fw-&gt;z_size
suffix:semicolon
id|np-&gt;fw_setup
op_assign
id|fw-&gt;setup
suffix:semicolon
id|np-&gt;fw_patch
op_assign
id|fw-&gt;patch
suffix:semicolon
id|np-&gt;fw_name
op_assign
id|fw-&gt;name
suffix:semicolon
multiline_comment|/*&n;&t; *  Save setting of some IO registers, so we will &n;&t; *  be able to probe specific implementations.&n;&t; */
id|sym_save_initial_setting
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Reset the chip now, since it has been reported &n;&t; *  that SCSI clock calibration may not work properly &n;&t; *  if the chip is currently active.&n;&t; */
id|sym_chip_reset
(paren
id|np
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Try to read the user set-up.&n;&t; */
macro_line|#ifndef SYM_OPT_NVRAM_PRE_READ
(paren
r_void
)paren
id|sym_read_nvram
c_func
(paren
id|np
comma
id|nvram
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *  Prepare controller and devices settings, according &n;&t; *  to chip features, user set-up and driver set-up.&n;&t; */
(paren
r_void
)paren
id|sym_prepare_setting
c_func
(paren
id|np
comma
id|nvram
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Check the PCI clock frequency.&n;&t; *  Must be performed after prepare_setting since it destroys &n;&t; *  STEST1 that is used to probe for the clock doubler.&n;&t; */
id|i
op_assign
id|sym_getpciclock
c_func
(paren
id|np
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|37000
op_logical_and
op_logical_neg
(paren
id|np-&gt;features
op_amp
id|FE_66MHZ
)paren
)paren
id|printf
c_func
(paren
l_string|&quot;%s: PCI BUS clock seems too high: %u KHz.&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
comma
id|i
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Allocate the start queue.&n;&t; */
id|np-&gt;squeue
op_assign
(paren
id|u32
op_star
)paren
id|sym_calloc_dma
c_func
(paren
r_sizeof
(paren
id|u32
)paren
op_star
(paren
id|MAX_QUEUE
op_star
l_int|2
)paren
comma
l_string|&quot;SQUEUE&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;squeue
)paren
r_goto
id|attach_failed
suffix:semicolon
id|np-&gt;squeue_ba
op_assign
id|vtobus
c_func
(paren
id|np-&gt;squeue
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Allocate the done queue.&n;&t; */
id|np-&gt;dqueue
op_assign
(paren
id|u32
op_star
)paren
id|sym_calloc_dma
c_func
(paren
r_sizeof
(paren
id|u32
)paren
op_star
(paren
id|MAX_QUEUE
op_star
l_int|2
)paren
comma
l_string|&quot;DQUEUE&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;dqueue
)paren
r_goto
id|attach_failed
suffix:semicolon
id|np-&gt;dqueue_ba
op_assign
id|vtobus
c_func
(paren
id|np-&gt;dqueue
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Allocate the target bus address array.&n;&t; */
id|np-&gt;targtbl
op_assign
(paren
id|u32
op_star
)paren
id|sym_calloc_dma
c_func
(paren
l_int|256
comma
l_string|&quot;TARGTBL&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;targtbl
)paren
r_goto
id|attach_failed
suffix:semicolon
id|np-&gt;targtbl_ba
op_assign
id|vtobus
c_func
(paren
id|np-&gt;targtbl
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Allocate SCRIPTS areas.&n;&t; */
id|np-&gt;scripta0
op_assign
id|sym_calloc_dma
c_func
(paren
id|np-&gt;scripta_sz
comma
l_string|&quot;SCRIPTA0&quot;
)paren
suffix:semicolon
id|np-&gt;scriptb0
op_assign
id|sym_calloc_dma
c_func
(paren
id|np-&gt;scriptb_sz
comma
l_string|&quot;SCRIPTB0&quot;
)paren
suffix:semicolon
id|np-&gt;scriptz0
op_assign
id|sym_calloc_dma
c_func
(paren
id|np-&gt;scriptz_sz
comma
l_string|&quot;SCRIPTZ0&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;scripta0
op_logical_or
op_logical_neg
id|np-&gt;scriptb0
op_logical_or
op_logical_neg
id|np-&gt;scriptz0
)paren
r_goto
id|attach_failed
suffix:semicolon
multiline_comment|/*&n;&t; *  Allocate the array of lists of CCBs hashed by DSA.&n;&t; */
id|np-&gt;ccbh
op_assign
id|sym_calloc
c_func
(paren
r_sizeof
(paren
id|ccb_p
op_star
)paren
op_star
id|CCB_HASH_SIZE
comma
l_string|&quot;CCBH&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;ccbh
)paren
r_goto
id|attach_failed
suffix:semicolon
multiline_comment|/*&n;&t; *  Initialyze the CCB free and busy queues.&n;&t; */
id|sym_que_init
c_func
(paren
op_amp
id|np-&gt;free_ccbq
)paren
suffix:semicolon
id|sym_que_init
c_func
(paren
op_amp
id|np-&gt;busy_ccbq
)paren
suffix:semicolon
id|sym_que_init
c_func
(paren
op_amp
id|np-&gt;comp_ccbq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Initializations for optional handling &n;&t; *  of IO timeouts and device queueing.&n;&t; */
macro_line|#ifdef&t;SYM_OPT_HANDLE_IO_TIMEOUT
id|sym_que_init
c_func
(paren
op_amp
id|np-&gt;tmo0_ccbq
)paren
suffix:semicolon
id|np-&gt;tmo_ccbq
op_assign
id|sym_calloc
c_func
(paren
l_int|2
op_star
id|SYM_CONF_TIMEOUT_ORDER_MAX
op_star
r_sizeof
(paren
id|SYM_QUEHEAD
)paren
comma
l_string|&quot;TMO_CCBQ&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
op_star
id|SYM_CONF_TIMEOUT_ORDER_MAX
suffix:semicolon
id|i
op_increment
)paren
id|sym_que_init
c_func
(paren
op_amp
id|np-&gt;tmo_ccbq
(braket
id|i
)braket
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING
id|sym_que_init
c_func
(paren
op_amp
id|np-&gt;dummy_ccbq
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *  Allocate some CCB. We need at least ONE.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sym_alloc_ccb
c_func
(paren
id|np
)paren
)paren
r_goto
id|attach_failed
suffix:semicolon
multiline_comment|/*&n;&t; *  Calculate BUS addresses where we are going &n;&t; *  to load the SCRIPTS.&n;&t; */
id|np-&gt;scripta_ba
op_assign
id|vtobus
c_func
(paren
id|np-&gt;scripta0
)paren
suffix:semicolon
id|np-&gt;scriptb_ba
op_assign
id|vtobus
c_func
(paren
id|np-&gt;scriptb0
)paren
suffix:semicolon
id|np-&gt;scriptz_ba
op_assign
id|vtobus
c_func
(paren
id|np-&gt;scriptz0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;ram_ba
)paren
(brace
id|np-&gt;scripta_ba
op_assign
id|np-&gt;ram_ba
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;features
op_amp
id|FE_RAM8K
)paren
(brace
id|np-&gt;ram_ws
op_assign
l_int|8192
suffix:semicolon
id|np-&gt;scriptb_ba
op_assign
id|np-&gt;scripta_ba
op_plus
l_int|4096
suffix:semicolon
macro_line|#if 0&t;/* May get useful for 64 BIT PCI addressing */
id|np-&gt;scr_ram_seg
op_assign
id|cpu_to_scr
c_func
(paren
id|np-&gt;scripta_ba
op_rshift
l_int|32
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
id|np-&gt;ram_ws
op_assign
l_int|4096
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Copy scripts to controller instance.&n;&t; */
id|memcpy
c_func
(paren
id|np-&gt;scripta0
comma
id|fw-&gt;a_base
comma
id|np-&gt;scripta_sz
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|np-&gt;scriptb0
comma
id|fw-&gt;b_base
comma
id|np-&gt;scriptb_sz
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|np-&gt;scriptz0
comma
id|fw-&gt;z_base
comma
id|np-&gt;scriptz_sz
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Setup variable parts in scripts and compute&n;&t; *  scripts bus addresses used from the C code.&n;&t; */
id|np
op_member_access_from_pointer
id|fw_setup
c_func
(paren
id|np
comma
id|fw
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Bind SCRIPTS with physical addresses usable by the &n;&t; *  SCRIPTS processor (as seen from the BUS = BUS addresses).&n;&t; */
id|sym_fw_bind_script
c_func
(paren
id|np
comma
(paren
id|u32
op_star
)paren
id|np-&gt;scripta0
comma
id|np-&gt;scripta_sz
)paren
suffix:semicolon
id|sym_fw_bind_script
c_func
(paren
id|np
comma
(paren
id|u32
op_star
)paren
id|np-&gt;scriptb0
comma
id|np-&gt;scriptb_sz
)paren
suffix:semicolon
id|sym_fw_bind_script
c_func
(paren
id|np
comma
(paren
id|u32
op_star
)paren
id|np-&gt;scriptz0
comma
id|np-&gt;scriptz_sz
)paren
suffix:semicolon
macro_line|#ifdef SYM_CONF_IARB_SUPPORT
multiline_comment|/*&n;&t; *    If user wants IARB to be set when we win arbitration &n;&t; *    and have other jobs, compute the max number of consecutive &n;&t; *    settings of IARB hints before we leave devices a chance to &n;&t; *    arbitrate for reselection.&n;&t; */
macro_line|#ifdef&t;SYM_SETUP_IARB_MAX
id|np-&gt;iarb_max
op_assign
id|SYM_SETUP_IARB_MAX
suffix:semicolon
macro_line|#else
id|np-&gt;iarb_max
op_assign
l_int|4
suffix:semicolon
macro_line|#endif
macro_line|#endif
multiline_comment|/*&n;&t; *  Prepare the idle and invalid task actions.&n;&t; */
id|np-&gt;idletask.start
op_assign
id|cpu_to_scr
c_func
(paren
id|SCRIPTA_BA
(paren
id|np
comma
id|idle
)paren
)paren
suffix:semicolon
id|np-&gt;idletask.restart
op_assign
id|cpu_to_scr
c_func
(paren
id|SCRIPTB_BA
(paren
id|np
comma
id|bad_i_t_l
)paren
)paren
suffix:semicolon
id|np-&gt;idletask_ba
op_assign
id|vtobus
c_func
(paren
op_amp
id|np-&gt;idletask
)paren
suffix:semicolon
id|np-&gt;notask.start
op_assign
id|cpu_to_scr
c_func
(paren
id|SCRIPTA_BA
(paren
id|np
comma
id|idle
)paren
)paren
suffix:semicolon
id|np-&gt;notask.restart
op_assign
id|cpu_to_scr
c_func
(paren
id|SCRIPTB_BA
(paren
id|np
comma
id|bad_i_t_l
)paren
)paren
suffix:semicolon
id|np-&gt;notask_ba
op_assign
id|vtobus
c_func
(paren
op_amp
id|np-&gt;notask
)paren
suffix:semicolon
id|np-&gt;bad_itl.start
op_assign
id|cpu_to_scr
c_func
(paren
id|SCRIPTA_BA
(paren
id|np
comma
id|idle
)paren
)paren
suffix:semicolon
id|np-&gt;bad_itl.restart
op_assign
id|cpu_to_scr
c_func
(paren
id|SCRIPTB_BA
(paren
id|np
comma
id|bad_i_t_l
)paren
)paren
suffix:semicolon
id|np-&gt;bad_itl_ba
op_assign
id|vtobus
c_func
(paren
op_amp
id|np-&gt;bad_itl
)paren
suffix:semicolon
id|np-&gt;bad_itlq.start
op_assign
id|cpu_to_scr
c_func
(paren
id|SCRIPTA_BA
(paren
id|np
comma
id|idle
)paren
)paren
suffix:semicolon
id|np-&gt;bad_itlq.restart
op_assign
id|cpu_to_scr
c_func
(paren
id|SCRIPTB_BA
(paren
id|np
comma
id|bad_i_t_l_q
)paren
)paren
suffix:semicolon
id|np-&gt;bad_itlq_ba
op_assign
id|vtobus
c_func
(paren
op_amp
id|np-&gt;bad_itlq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Allocate and prepare the lun JUMP table that is used &n;&t; *  for a target prior the probing of devices (bad lun table).&n;&t; *  A private table will be allocated for the target on the &n;&t; *  first INQUIRY response received.&n;&t; */
id|np-&gt;badluntbl
op_assign
id|sym_calloc_dma
c_func
(paren
l_int|256
comma
l_string|&quot;BADLUNTBL&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|np-&gt;badluntbl
)paren
r_goto
id|attach_failed
suffix:semicolon
id|np-&gt;badlun_sa
op_assign
id|cpu_to_scr
c_func
(paren
id|SCRIPTB_BA
(paren
id|np
comma
id|resel_bad_lun
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|64
suffix:semicolon
id|i
op_increment
)paren
multiline_comment|/* 64 luns/target, no less */
id|np-&gt;badluntbl
(braket
id|i
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
c_func
(paren
op_amp
id|np-&gt;badlun_sa
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Prepare the bus address array that contains the bus &n;&t; *  address of each target control block.&n;&t; *  For now, assume all logical units are wrong. :)&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SYM_CONF_MAX_TARGET
suffix:semicolon
id|i
op_increment
)paren
(brace
id|np-&gt;targtbl
(braket
id|i
)braket
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
c_func
(paren
op_amp
id|np-&gt;target
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
id|np-&gt;target
(braket
id|i
)braket
dot
id|head.luntbl_sa
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
c_func
(paren
id|np-&gt;badluntbl
)paren
)paren
suffix:semicolon
id|np-&gt;target
(braket
id|i
)braket
dot
id|head.lun0_sa
op_assign
id|cpu_to_scr
c_func
(paren
id|vtobus
c_func
(paren
op_amp
id|np-&gt;badlun_sa
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Now check the cache handling of the pci chipset.&n;&t; */
r_if
c_cond
(paren
id|sym_snooptest
(paren
id|np
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%s: CACHE INCORRECTLY CONFIGURED.&bslash;n&quot;
comma
id|sym_name
c_func
(paren
id|np
)paren
)paren
suffix:semicolon
r_goto
id|attach_failed
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t; *  Sigh! we are done.&n;&t; */
r_return
l_int|0
suffix:semicolon
id|attach_failed
suffix:colon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/*&n; *  Free everything that has been allocated for this device.&n; */
DECL|function|sym_hcb_free
r_void
id|sym_hcb_free
c_func
(paren
id|hcb_p
id|np
)paren
(brace
id|SYM_QUEHEAD
op_star
id|qp
suffix:semicolon
id|ccb_p
id|cp
suffix:semicolon
id|tcb_p
id|tp
suffix:semicolon
id|lcb_p
id|lp
suffix:semicolon
r_int
id|target
comma
id|lun
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;scriptz0
)paren
id|sym_mfree_dma
c_func
(paren
id|np-&gt;scriptz0
comma
id|np-&gt;scriptz_sz
comma
l_string|&quot;SCRIPTZ0&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;scriptb0
)paren
id|sym_mfree_dma
c_func
(paren
id|np-&gt;scriptb0
comma
id|np-&gt;scriptb_sz
comma
l_string|&quot;SCRIPTB0&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;scripta0
)paren
id|sym_mfree_dma
c_func
(paren
id|np-&gt;scripta0
comma
id|np-&gt;scripta_sz
comma
l_string|&quot;SCRIPTA0&quot;
)paren
suffix:semicolon
macro_line|#ifdef&t;SYM_OPT_HANDLE_IO_TIMEOUT
r_if
c_cond
(paren
id|np-&gt;tmo_ccbq
)paren
id|sym_mfree
c_func
(paren
id|np-&gt;tmo_ccbq
comma
l_int|2
op_star
id|SYM_CONF_TIMEOUT_ORDER_MAX
op_star
r_sizeof
(paren
id|SYM_QUEHEAD
)paren
comma
l_string|&quot;TMO_CCBQ&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|np-&gt;squeue
)paren
id|sym_mfree_dma
c_func
(paren
id|np-&gt;squeue
comma
r_sizeof
(paren
id|u32
)paren
op_star
(paren
id|MAX_QUEUE
op_star
l_int|2
)paren
comma
l_string|&quot;SQUEUE&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;dqueue
)paren
id|sym_mfree_dma
c_func
(paren
id|np-&gt;dqueue
comma
r_sizeof
(paren
id|u32
)paren
op_star
(paren
id|MAX_QUEUE
op_star
l_int|2
)paren
comma
l_string|&quot;DQUEUE&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;actccbs
)paren
(brace
r_while
c_loop
(paren
(paren
id|qp
op_assign
id|sym_remque_head
c_func
(paren
op_amp
id|np-&gt;free_ccbq
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|cp
op_assign
id|sym_que_entry
c_func
(paren
id|qp
comma
r_struct
id|sym_ccb
comma
id|link_ccbq
)paren
suffix:semicolon
id|sym_data_dmamap_destroy
c_func
(paren
id|np
comma
id|cp
)paren
suffix:semicolon
id|sym_mfree_dma
c_func
(paren
id|cp-&gt;sns_bbuf
comma
id|SYM_SNS_BBUF_LEN
comma
l_string|&quot;SNS_BBUF&quot;
)paren
suffix:semicolon
id|sym_mfree_dma
c_func
(paren
id|cp
comma
r_sizeof
(paren
op_star
id|cp
)paren
comma
l_string|&quot;CCB&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|np-&gt;ccbh
)paren
id|sym_mfree
c_func
(paren
id|np-&gt;ccbh
comma
r_sizeof
(paren
id|ccb_p
op_star
)paren
op_star
id|CCB_HASH_SIZE
comma
l_string|&quot;CCBH&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;badluntbl
)paren
id|sym_mfree_dma
c_func
(paren
id|np-&gt;badluntbl
comma
l_int|256
comma
l_string|&quot;BADLUNTBL&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|target
op_assign
l_int|0
suffix:semicolon
id|target
OL
id|SYM_CONF_MAX_TARGET
suffix:semicolon
id|target
op_increment
)paren
(brace
id|tp
op_assign
op_amp
id|np-&gt;target
(braket
id|target
)braket
suffix:semicolon
r_for
c_loop
(paren
id|lun
op_assign
l_int|0
suffix:semicolon
id|lun
OL
id|SYM_CONF_MAX_LUN
suffix:semicolon
id|lun
op_increment
)paren
(brace
id|lp
op_assign
id|sym_lp
c_func
(paren
id|np
comma
id|tp
comma
id|lun
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;itlq_tbl
)paren
id|sym_mfree_dma
c_func
(paren
id|lp-&gt;itlq_tbl
comma
id|SYM_CONF_MAX_TASK
op_star
l_int|4
comma
l_string|&quot;ITLQ_TBL&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;cb_tags
)paren
id|sym_mfree
c_func
(paren
id|lp-&gt;cb_tags
comma
id|SYM_CONF_MAX_TASK
comma
l_string|&quot;CB_TAGS&quot;
)paren
suffix:semicolon
id|sym_mfree_dma
c_func
(paren
id|lp
comma
r_sizeof
(paren
op_star
id|lp
)paren
comma
l_string|&quot;LCB&quot;
)paren
suffix:semicolon
)brace
macro_line|#if SYM_CONF_MAX_LUN &gt; 1
r_if
c_cond
(paren
id|tp-&gt;lunmp
)paren
id|sym_mfree
c_func
(paren
id|tp-&gt;lunmp
comma
id|SYM_CONF_MAX_LUN
op_star
r_sizeof
(paren
id|lcb_p
)paren
comma
l_string|&quot;LUNMP&quot;
)paren
suffix:semicolon
macro_line|#endif 
)brace
r_if
c_cond
(paren
id|np-&gt;targtbl
)paren
id|sym_mfree_dma
c_func
(paren
id|np-&gt;targtbl
comma
l_int|256
comma
l_string|&quot;TARGTBL&quot;
)paren
suffix:semicolon
)brace
eof
