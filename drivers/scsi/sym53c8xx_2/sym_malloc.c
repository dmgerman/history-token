multiline_comment|/*&n; * Device driver for the SYMBIOS/LSILOGIC 53C8XX and 53C1010 family &n; * of PCI-SCSI IO processors.&n; *&n; * Copyright (C) 1999-2001  Gerard Roudier &lt;groudier@free.fr&gt;&n; *&n; * This driver is derived from the Linux sym53c8xx driver.&n; * Copyright (C) 1998-2000  Gerard Roudier&n; *&n; * The sym53c8xx driver is derived from the ncr53c8xx driver that had been &n; * a port of the FreeBSD ncr driver to Linux-1.2.13.&n; *&n; * The original ncr driver has been written for 386bsd and FreeBSD by&n; *         Wolfgang Stanglmeier        &lt;wolf@cologne.de&gt;&n; *         Stefan Esser                &lt;se@mi.Uni-Koeln.de&gt;&n; * Copyright (C) 1994  Wolfgang Stanglmeier&n; *&n; * Other major contributions:&n; *&n; * NVRAM detection and reading.&n; * Copyright (C) 1997 Richard Waltham &lt;dormouse@farsrobt.demon.co.uk&gt;&n; *&n; *-----------------------------------------------------------------------------&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#ifdef __FreeBSD__
macro_line|#include &lt;dev/sym/sym_glue.h&gt;
macro_line|#else
macro_line|#include &quot;sym_glue.h&quot;
macro_line|#endif
multiline_comment|/*&n; *  Simple power of two buddy-like generic allocator.&n; *  Provides naturally aligned memory chunks.&n; *&n; *  This simple code is not intended to be fast, but to &n; *  provide power of 2 aligned memory allocations.&n; *  Since the SCRIPTS processor only supplies 8 bit arithmetic, &n; *  this allocator allows simple and fast address calculations  &n; *  from the SCRIPTS code. In addition, cache line alignment &n; *  is guaranteed for power of 2 cache line size.&n; *&n; *  This allocator has been developped for the Linux sym53c8xx  &n; *  driver, since this O/S does not provide naturally aligned &n; *  allocations.&n; *  It has the advantage of allowing the driver to use private &n; *  pages of memory that will be useful if we ever need to deal &n; *  with IO MMUs for PCI.&n; */
DECL|function|___sym_malloc
r_static
r_void
op_star
id|___sym_malloc
c_func
(paren
id|m_pool_p
id|mp
comma
r_int
id|size
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|s
op_assign
(paren
l_int|1
op_lshift
id|SYM_MEM_SHIFT
)paren
suffix:semicolon
r_int
id|j
suffix:semicolon
r_void
op_star
id|a
suffix:semicolon
id|m_link_p
id|h
op_assign
id|mp-&gt;h
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|SYM_MEM_CLUSTER_SIZE
)paren
r_return
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
id|s
)paren
(brace
id|s
op_lshift_assign
l_int|1
suffix:semicolon
op_increment
id|i
suffix:semicolon
)brace
id|j
op_assign
id|i
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|h
(braket
id|j
)braket
dot
id|next
)paren
(brace
r_if
c_cond
(paren
id|s
op_eq
id|SYM_MEM_CLUSTER_SIZE
)paren
(brace
id|h
(braket
id|j
)braket
dot
id|next
op_assign
(paren
id|m_link_p
)paren
id|M_GET_MEM_CLUSTER
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|h
(braket
id|j
)braket
dot
id|next
)paren
id|h
(braket
id|j
)braket
dot
id|next-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
op_increment
id|j
suffix:semicolon
id|s
op_lshift_assign
l_int|1
suffix:semicolon
)brace
id|a
op_assign
id|h
(braket
id|j
)braket
dot
id|next
suffix:semicolon
r_if
c_cond
(paren
id|a
)paren
(brace
id|h
(braket
id|j
)braket
dot
id|next
op_assign
id|h
(braket
id|j
)braket
dot
id|next-&gt;next
suffix:semicolon
r_while
c_loop
(paren
id|j
OG
id|i
)paren
(brace
id|j
op_sub_assign
l_int|1
suffix:semicolon
id|s
op_rshift_assign
l_int|1
suffix:semicolon
id|h
(braket
id|j
)braket
dot
id|next
op_assign
(paren
id|m_link_p
)paren
(paren
id|a
op_plus
id|s
)paren
suffix:semicolon
id|h
(braket
id|j
)braket
dot
id|next-&gt;next
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
macro_line|#ifdef DEBUG
id|printf
c_func
(paren
l_string|&quot;___sym_malloc(%d) = %p&bslash;n&quot;
comma
id|size
comma
(paren
r_void
op_star
)paren
id|a
)paren
suffix:semicolon
macro_line|#endif
r_return
id|a
suffix:semicolon
)brace
multiline_comment|/*&n; *  Counter-part of the generic allocator.&n; */
DECL|function|___sym_mfree
r_static
r_void
id|___sym_mfree
c_func
(paren
id|m_pool_p
id|mp
comma
r_void
op_star
id|ptr
comma
r_int
id|size
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|s
op_assign
(paren
l_int|1
op_lshift
id|SYM_MEM_SHIFT
)paren
suffix:semicolon
id|m_link_p
id|q
suffix:semicolon
r_int
r_int
id|a
comma
id|b
suffix:semicolon
id|m_link_p
id|h
op_assign
id|mp-&gt;h
suffix:semicolon
macro_line|#ifdef DEBUG
id|printf
c_func
(paren
l_string|&quot;___sym_mfree(%p, %d)&bslash;n&quot;
comma
id|ptr
comma
id|size
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|size
OG
id|SYM_MEM_CLUSTER_SIZE
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
id|s
)paren
(brace
id|s
op_lshift_assign
l_int|1
suffix:semicolon
op_increment
id|i
suffix:semicolon
)brace
id|a
op_assign
(paren
r_int
r_int
)paren
id|ptr
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|s
op_eq
id|SYM_MEM_CLUSTER_SIZE
)paren
(brace
macro_line|#ifdef SYM_MEM_FREE_UNUSED
id|M_FREE_MEM_CLUSTER
c_func
(paren
(paren
r_void
op_star
)paren
id|a
)paren
suffix:semicolon
macro_line|#else
(paren
(paren
id|m_link_p
)paren
id|a
)paren
op_member_access_from_pointer
id|next
op_assign
id|h
(braket
id|i
)braket
dot
id|next
suffix:semicolon
id|h
(braket
id|i
)braket
dot
id|next
op_assign
(paren
id|m_link_p
)paren
id|a
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
id|b
op_assign
id|a
op_xor
id|s
suffix:semicolon
id|q
op_assign
op_amp
id|h
(braket
id|i
)braket
suffix:semicolon
r_while
c_loop
(paren
id|q-&gt;next
op_logical_and
id|q-&gt;next
op_ne
(paren
id|m_link_p
)paren
id|b
)paren
(brace
id|q
op_assign
id|q-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|q-&gt;next
)paren
(brace
(paren
(paren
id|m_link_p
)paren
id|a
)paren
op_member_access_from_pointer
id|next
op_assign
id|h
(braket
id|i
)braket
dot
id|next
suffix:semicolon
id|h
(braket
id|i
)braket
dot
id|next
op_assign
(paren
id|m_link_p
)paren
id|a
suffix:semicolon
r_break
suffix:semicolon
)brace
id|q-&gt;next
op_assign
id|q-&gt;next-&gt;next
suffix:semicolon
id|a
op_assign
id|a
op_amp
id|b
suffix:semicolon
id|s
op_lshift_assign
l_int|1
suffix:semicolon
op_increment
id|i
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *  Verbose and zeroing allocator that wrapps to the generic allocator.&n; */
DECL|function|__sym_calloc2
r_static
r_void
op_star
id|__sym_calloc2
c_func
(paren
id|m_pool_p
id|mp
comma
r_int
id|size
comma
r_char
op_star
id|name
comma
r_int
id|uflags
)paren
(brace
r_void
op_star
id|p
suffix:semicolon
id|p
op_assign
id|___sym_malloc
c_func
(paren
id|mp
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_ALLOC
)paren
(brace
id|printf
(paren
l_string|&quot;new %-10s[%4d] @%p.&bslash;n&quot;
comma
id|name
comma
id|size
comma
id|p
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p
)paren
id|memset
c_func
(paren
id|p
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|uflags
op_amp
id|SYM_MEM_WARN
)paren
id|printf
(paren
l_string|&quot;__sym_calloc2: failed to allocate %s[%d]&bslash;n&quot;
comma
id|name
comma
id|size
)paren
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
DECL|macro|__sym_calloc
mdefine_line|#define __sym_calloc(mp, s, n)&t;__sym_calloc2(mp, s, n, SYM_MEM_WARN)
multiline_comment|/*&n; *  Its counter-part.&n; */
DECL|function|__sym_mfree
r_static
r_void
id|__sym_mfree
c_func
(paren
id|m_pool_p
id|mp
comma
r_void
op_star
id|ptr
comma
r_int
id|size
comma
r_char
op_star
id|name
)paren
(brace
r_if
c_cond
(paren
id|DEBUG_FLAGS
op_amp
id|DEBUG_ALLOC
)paren
id|printf
(paren
l_string|&quot;freeing %-10s[%4d] @%p.&bslash;n&quot;
comma
id|name
comma
id|size
comma
id|ptr
)paren
suffix:semicolon
id|___sym_mfree
c_func
(paren
id|mp
comma
id|ptr
comma
id|size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Default memory pool we donnot need to involve in DMA.&n; *&n; *  With DMA abstraction, we use functions (methods), to &n; *  distinguish between non DMAable memory and DMAable memory.&n; */
DECL|function|___mp0_get_mem_cluster
r_static
r_void
op_star
id|___mp0_get_mem_cluster
c_func
(paren
id|m_pool_p
id|mp
)paren
(brace
r_void
op_star
id|m
op_assign
id|sym_get_mem_cluster
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
)paren
op_increment
id|mp-&gt;nump
suffix:semicolon
r_return
id|m
suffix:semicolon
)brace
macro_line|#ifdef&t;SYM_MEM_FREE_UNUSED
DECL|function|___mp0_free_mem_cluster
r_static
r_void
id|___mp0_free_mem_cluster
c_func
(paren
id|m_pool_p
id|mp
comma
r_void
op_star
id|m
)paren
(brace
id|sym_free_mem_cluster
c_func
(paren
id|m
)paren
suffix:semicolon
op_decrement
id|mp-&gt;nump
suffix:semicolon
)brace
macro_line|#else
DECL|macro|___mp0_free_mem_cluster
mdefine_line|#define ___mp0_free_mem_cluster NULL
macro_line|#endif
DECL|variable|mp0
r_static
r_struct
id|sym_m_pool
id|mp0
op_assign
(brace
l_int|NULL
comma
id|___mp0_get_mem_cluster
comma
id|___mp0_free_mem_cluster
)brace
suffix:semicolon
multiline_comment|/*&n; *  Methods that maintains DMAable pools according to user allocations.&n; *  New pools are created on the fly when a new pool id is provided.&n; *  They are deleted on the fly when they get emptied.&n; */
multiline_comment|/* Get a memory cluster that matches the DMA constraints of a given pool */
DECL|function|___get_dma_mem_cluster
r_static
r_void
op_star
id|___get_dma_mem_cluster
c_func
(paren
id|m_pool_p
id|mp
)paren
(brace
id|m_vtob_p
id|vbp
suffix:semicolon
r_void
op_star
id|vaddr
suffix:semicolon
id|vbp
op_assign
id|__sym_calloc
c_func
(paren
op_amp
id|mp0
comma
r_sizeof
(paren
op_star
id|vbp
)paren
comma
l_string|&quot;VTOB&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vbp
)paren
r_goto
id|out_err
suffix:semicolon
id|vaddr
op_assign
id|sym_m_get_dma_mem_cluster
c_func
(paren
id|mp
comma
id|vbp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vaddr
)paren
(brace
r_int
id|hc
op_assign
id|VTOB_HASH_CODE
c_func
(paren
id|vaddr
)paren
suffix:semicolon
id|vbp-&gt;next
op_assign
id|mp-&gt;vtob
(braket
id|hc
)braket
suffix:semicolon
id|mp-&gt;vtob
(braket
id|hc
)braket
op_assign
id|vbp
suffix:semicolon
op_increment
id|mp-&gt;nump
suffix:semicolon
)brace
r_return
id|vaddr
suffix:semicolon
id|out_err
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef&t;SYM_MEM_FREE_UNUSED
multiline_comment|/* Free a memory cluster and associated resources for DMA */
DECL|function|___free_dma_mem_cluster
r_static
r_void
id|___free_dma_mem_cluster
c_func
(paren
id|m_pool_p
id|mp
comma
r_void
op_star
id|m
)paren
(brace
id|m_vtob_p
op_star
id|vbpp
comma
id|vbp
suffix:semicolon
r_int
id|hc
op_assign
id|VTOB_HASH_CODE
c_func
(paren
id|m
)paren
suffix:semicolon
id|vbpp
op_assign
op_amp
id|mp-&gt;vtob
(braket
id|hc
)braket
suffix:semicolon
r_while
c_loop
(paren
op_star
id|vbpp
op_logical_and
(paren
op_star
id|vbpp
)paren
op_member_access_from_pointer
id|vaddr
op_ne
id|m
)paren
id|vbpp
op_assign
op_amp
(paren
op_star
id|vbpp
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
r_if
c_cond
(paren
op_star
id|vbpp
)paren
(brace
id|vbp
op_assign
op_star
id|vbpp
suffix:semicolon
op_star
id|vbpp
op_assign
(paren
op_star
id|vbpp
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
id|sym_m_free_dma_mem_cluster
c_func
(paren
id|mp
comma
id|vbp
)paren
suffix:semicolon
id|__sym_mfree
c_func
(paren
op_amp
id|mp0
comma
id|vbp
comma
r_sizeof
(paren
op_star
id|vbp
)paren
comma
l_string|&quot;VTOB&quot;
)paren
suffix:semicolon
op_decrement
id|mp-&gt;nump
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/* Fetch the memory pool for a given pool id (i.e. DMA constraints) */
DECL|function|___get_dma_pool
r_static
id|__inline
id|m_pool_p
id|___get_dma_pool
c_func
(paren
id|m_pool_ident_t
id|dev_dmat
)paren
(brace
id|m_pool_p
id|mp
suffix:semicolon
r_for
c_loop
(paren
id|mp
op_assign
id|mp0.next
suffix:semicolon
id|mp
op_logical_and
op_logical_neg
id|sym_m_pool_match
c_func
(paren
id|mp-&gt;dev_dmat
comma
id|dev_dmat
)paren
suffix:semicolon
id|mp
op_assign
id|mp-&gt;next
)paren
suffix:semicolon
r_return
id|mp
suffix:semicolon
)brace
multiline_comment|/* Create a new memory DMAable pool (when fetch failed) */
DECL|function|___cre_dma_pool
r_static
id|m_pool_p
id|___cre_dma_pool
c_func
(paren
id|m_pool_ident_t
id|dev_dmat
)paren
(brace
id|m_pool_p
id|mp
op_assign
id|__sym_calloc
c_func
(paren
op_amp
id|mp0
comma
r_sizeof
(paren
op_star
id|mp
)paren
comma
l_string|&quot;MPOOL&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
)paren
(brace
id|mp-&gt;dev_dmat
op_assign
id|dev_dmat
suffix:semicolon
id|mp-&gt;get_mem_cluster
op_assign
id|___get_dma_mem_cluster
suffix:semicolon
macro_line|#ifdef&t;SYM_MEM_FREE_UNUSED
id|mp-&gt;free_mem_cluster
op_assign
id|___free_dma_mem_cluster
suffix:semicolon
macro_line|#endif
id|mp-&gt;next
op_assign
id|mp0.next
suffix:semicolon
id|mp0.next
op_assign
id|mp
suffix:semicolon
r_return
id|mp
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef&t;SYM_MEM_FREE_UNUSED
multiline_comment|/* Destroy a DMAable memory pool (when got emptied) */
DECL|function|___del_dma_pool
r_static
r_void
id|___del_dma_pool
c_func
(paren
id|m_pool_p
id|p
)paren
(brace
id|m_pool_p
op_star
id|pp
op_assign
op_amp
id|mp0.next
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pp
op_logical_and
op_star
id|pp
op_ne
id|p
)paren
id|pp
op_assign
op_amp
(paren
op_star
id|pp
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pp
)paren
(brace
op_star
id|pp
op_assign
(paren
op_star
id|pp
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
id|__sym_mfree
c_func
(paren
op_amp
id|mp0
comma
id|p
comma
r_sizeof
(paren
op_star
id|p
)paren
comma
l_string|&quot;MPOOL&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/* This lock protects only the memory allocation/free.  */
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|sym53c8xx_lock
)paren
suffix:semicolon
multiline_comment|/*&n; *  Actual allocator for DMAable memory.&n; */
DECL|function|__sym_calloc_dma
r_void
op_star
id|__sym_calloc_dma
c_func
(paren
id|m_pool_ident_t
id|dev_dmat
comma
r_int
id|size
comma
r_char
op_star
id|name
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|m_pool_p
id|mp
suffix:semicolon
r_void
op_star
id|m
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sym53c8xx_lock
comma
id|flags
)paren
suffix:semicolon
id|mp
op_assign
id|___get_dma_pool
c_func
(paren
id|dev_dmat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mp
)paren
id|mp
op_assign
id|___cre_dma_pool
c_func
(paren
id|dev_dmat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mp
)paren
r_goto
id|out
suffix:semicolon
id|m
op_assign
id|__sym_calloc
c_func
(paren
id|mp
comma
id|size
comma
id|name
)paren
suffix:semicolon
macro_line|#ifdef&t;SYM_MEM_FREE_UNUSED
r_if
c_cond
(paren
op_logical_neg
id|mp-&gt;nump
)paren
id|___del_dma_pool
c_func
(paren
id|mp
)paren
suffix:semicolon
macro_line|#endif
id|out
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sym53c8xx_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|m
suffix:semicolon
)brace
DECL|function|__sym_mfree_dma
r_void
id|__sym_mfree_dma
c_func
(paren
id|m_pool_ident_t
id|dev_dmat
comma
r_void
op_star
id|m
comma
r_int
id|size
comma
r_char
op_star
id|name
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|m_pool_p
id|mp
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sym53c8xx_lock
comma
id|flags
)paren
suffix:semicolon
id|mp
op_assign
id|___get_dma_pool
c_func
(paren
id|dev_dmat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mp
)paren
r_goto
id|out
suffix:semicolon
id|__sym_mfree
c_func
(paren
id|mp
comma
id|m
comma
id|size
comma
id|name
)paren
suffix:semicolon
macro_line|#ifdef&t;SYM_MEM_FREE_UNUSED
r_if
c_cond
(paren
op_logical_neg
id|mp-&gt;nump
)paren
id|___del_dma_pool
c_func
(paren
id|mp
)paren
suffix:semicolon
macro_line|#endif
id|out
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sym53c8xx_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Actual virtual to bus physical address translator &n; *  for 32 bit addressable DMAable memory.&n; */
DECL|function|__vtobus
id|dma_addr_t
id|__vtobus
c_func
(paren
id|m_pool_ident_t
id|dev_dmat
comma
r_void
op_star
id|m
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|m_pool_p
id|mp
suffix:semicolon
r_int
id|hc
op_assign
id|VTOB_HASH_CODE
c_func
(paren
id|m
)paren
suffix:semicolon
id|m_vtob_p
id|vp
op_assign
l_int|NULL
suffix:semicolon
r_void
op_star
id|a
op_assign
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|m
op_amp
op_complement
id|SYM_MEM_CLUSTER_MASK
)paren
suffix:semicolon
id|dma_addr_t
id|b
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sym53c8xx_lock
comma
id|flags
)paren
suffix:semicolon
id|mp
op_assign
id|___get_dma_pool
c_func
(paren
id|dev_dmat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
)paren
(brace
id|vp
op_assign
id|mp-&gt;vtob
(braket
id|hc
)braket
suffix:semicolon
r_while
c_loop
(paren
id|vp
op_logical_and
id|vp-&gt;vaddr
op_ne
id|a
)paren
id|vp
op_assign
id|vp-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|vp
)paren
id|panic
c_func
(paren
l_string|&quot;sym: VTOBUS FAILED!&bslash;n&quot;
)paren
suffix:semicolon
id|b
op_assign
id|vp-&gt;baddr
op_plus
(paren
id|m
op_minus
id|a
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sym53c8xx_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|b
suffix:semicolon
)brace
eof
